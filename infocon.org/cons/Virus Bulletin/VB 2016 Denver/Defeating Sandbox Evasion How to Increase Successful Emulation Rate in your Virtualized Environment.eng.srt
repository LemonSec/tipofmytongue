1
00:00:00,089 --> 00:00:02,399
good morning again I would like to

2
00:00:02,399 --> 00:00:06,000
invite you to our next session which

3
00:00:06,000 --> 00:00:11,240
will be the defeating sandbox and

4
00:00:11,240 --> 00:00:14,219
evasion how to increase successful

5
00:00:14,219 --> 00:00:16,529
emulation rate in your virtualized

6
00:00:16,529 --> 00:00:20,430
environment and my pleasure is to invite

7
00:00:20,430 --> 00:00:23,279
to the stage stage slash Kurata which

8
00:00:23,279 --> 00:00:26,640
and Alexandre child litko both from

9
00:00:26,640 --> 00:00:33,930
checkpoint software thank for it and in

10
00:00:33,930 --> 00:00:36,870
our presentation our topic today is one

11
00:00:36,870 --> 00:00:40,680
of the like hottest topics on the

12
00:00:40,680 --> 00:00:43,230
research scene at the moment so I hope

13
00:00:43,230 --> 00:00:45,660
you will enjoy the talk quickly about

14
00:00:45,660 --> 00:00:46,440
who we are

15
00:00:46,440 --> 00:00:48,780
my name is Alexandra and I'm leading the

16
00:00:48,780 --> 00:00:50,250
team of highly talented reverse

17
00:00:50,250 --> 00:00:52,829
engineers and here is one of them

18
00:00:52,829 --> 00:00:56,309
stanislav with welcome and today we have

19
00:00:56,309 --> 00:00:58,109
a lot of things to cover so let's go

20
00:00:58,109 --> 00:01:00,530
straight to the point

21
00:01:00,530 --> 00:01:03,090
okay so we'll focus on box found in kuku

22
00:01:03,090 --> 00:01:04,500
sandbox which may lead to the detection

23
00:01:04,500 --> 00:01:07,080
and evasion of it and then we'll propose

24
00:01:07,080 --> 00:01:09,450
fixes for them in addition we will do

25
00:01:09,450 --> 00:01:10,860
the same for different virtualized

26
00:01:10,860 --> 00:01:13,080
environments and finally we will present

27
00:01:13,080 --> 00:01:16,619
our sandbox detection tool which

28
00:01:16,619 --> 00:01:18,210
contains most of the deductions known

29
00:01:18,210 --> 00:01:21,810
till this date and our two can be easily

30
00:01:21,810 --> 00:01:23,490
configured three using the edges on

31
00:01:23,490 --> 00:01:25,799
configuration files and can be used for

32
00:01:25,799 --> 00:01:27,689
assessment of your internal virtualized

33
00:01:27,689 --> 00:01:29,820
systems so now as we transfer the

34
00:01:29,820 --> 00:01:31,680
presentation to stanislav and he will

35
00:01:31,680 --> 00:01:35,100
guide you through first part of it he

36
00:01:35,100 --> 00:01:37,890
sings alexander kouko-san works is a

37
00:01:37,890 --> 00:01:39,240
leading open source malware analysis

38
00:01:39,240 --> 00:01:41,670
system and let's discuss bugs who have

39
00:01:41,670 --> 00:01:43,079
found in it

40
00:01:43,079 --> 00:01:44,939
the first one and probably one of our

41
00:01:44,939 --> 00:01:46,740
favorite ones is technical and balance

42
00:01:46,740 --> 00:01:49,110
tech it may be applied to any type of

43
00:01:49,110 --> 00:01:51,960
user mode functions who can use the

44
00:01:51,960 --> 00:01:53,579
similar cooking technique as coca

45
00:01:53,579 --> 00:01:55,950
monitor does let's take a look what

46
00:01:55,950 --> 00:01:58,200
happens if function who are not present

47
00:01:58,200 --> 00:02:00,840
at first we push function arguments on

48
00:02:00,840 --> 00:02:02,149
the stack

49
00:02:02,149 --> 00:02:04,740
after that we move stack pointer towards

50
00:02:04,740 --> 00:02:06,630
lower addresses on the space we need to

51
00:02:06,630 --> 00:02:08,729
store return address in function local

52
00:02:08,729 --> 00:02:10,949
variables and after that we store in

53
00:02:10,949 --> 00:02:14,110
balance dictionaries under the stack

54
00:02:14,110 --> 00:02:16,450
we restored the stack pointer value and

55
00:02:16,450 --> 00:02:19,390
we perform a function called return and

56
00:02:19,390 --> 00:02:22,500
registered on the stack and function use

57
00:02:22,500 --> 00:02:25,300
stack space for its local variables as

58
00:02:25,300 --> 00:02:27,010
you can see and ballistic Canaries are

59
00:02:27,010 --> 00:02:30,820
not corrupted let's see what happens if

60
00:02:30,820 --> 00:02:33,010
we are calling function which is hooked

61
00:02:33,010 --> 00:02:36,430
by Coco monitor remove sir the same

62
00:02:36,430 --> 00:02:42,910
steps as previously what we do next we

63
00:02:42,910 --> 00:02:47,110
call a function but now hooks hook is

64
00:02:47,110 --> 00:02:49,120
executed so it uses some space on the

65
00:02:49,120 --> 00:02:50,980
stack and only after that it calls

66
00:02:50,980 --> 00:02:52,840
original functions it also uses some

67
00:02:52,840 --> 00:02:54,840
space on the stack as we can see

68
00:02:54,840 --> 00:02:57,250
unbalanced the Canaries are corrupted so

69
00:02:57,250 --> 00:03:01,209
cuckoo monitor is detected one of the

70
00:03:01,209 --> 00:03:03,430
proposed solution is of course usage of

71
00:03:03,430 --> 00:03:05,620
caramel mode hooking but if you want to

72
00:03:05,620 --> 00:03:06,910
stay with user mode the following

73
00:03:06,910 --> 00:03:10,630
tactics may be applied we move through

74
00:03:10,630 --> 00:03:16,180
the same steps as previously but what we

75
00:03:16,180 --> 00:03:19,930
do in our hook we must echo inter on the

76
00:03:19,930 --> 00:03:21,459
address that allows an unbalanced a

77
00:03:21,459 --> 00:03:23,350
Canaries and we copy function arguments

78
00:03:23,350 --> 00:03:26,950
and only after that we call our hook

79
00:03:26,950 --> 00:03:30,340
function as we can see spaces by hook

80
00:03:30,340 --> 00:03:32,680
and spaces by function local variables

81
00:03:32,680 --> 00:03:34,780
does not affect unbalanced accuracy at

82
00:03:34,780 --> 00:03:37,870
all so let's talk a little bit now on

83
00:03:37,870 --> 00:03:39,370
the sleep skip logic implemented in

84
00:03:39,370 --> 00:03:41,980
Cocoa monitor according to the first

85
00:03:41,980 --> 00:03:44,530
conditions only delays within the first

86
00:03:44,530 --> 00:03:48,700
G sleep max skip second pass skipped the

87
00:03:48,700 --> 00:03:50,800
second feature is usage available

88
00:03:50,800 --> 00:03:52,600
variable G times keep as it is used for

89
00:03:52,600 --> 00:03:54,480
accumulation of skip delays and the

90
00:03:54,480 --> 00:03:57,880
second place was a problem exists the

91
00:03:57,880 --> 00:04:00,220
search feature that actually implements

92
00:04:00,220 --> 00:04:02,980
skipping is implemented here real delay

93
00:04:02,980 --> 00:04:06,670
is replaced with 0.1 millisecond so

94
00:04:06,670 --> 00:04:08,260
let's take a look were slip skip

95
00:04:08,260 --> 00:04:10,540
function and this a couple variables I

96
00:04:10,540 --> 00:04:13,239
used step script function is used in

97
00:04:13,239 --> 00:04:15,379
until execution hook and

98
00:04:15,379 --> 00:04:18,010
G times capable variable is used in

99
00:04:18,010 --> 00:04:20,329
system date/time related functions such

100
00:04:20,329 --> 00:04:22,479
as antiquary system time get to count

101
00:04:22,479 --> 00:04:24,919
get local time with system time with

102
00:04:24,919 --> 00:04:28,790
system type of spell time functions okay

103
00:04:28,790 --> 00:04:30,919
let's move to handling of incident delay

104
00:04:30,919 --> 00:04:34,160
by entitle execution function when the

105
00:04:34,160 --> 00:04:35,990
application calls sleep was infinite

106
00:04:35,990 --> 00:04:38,449
delay it moves down and calls the box

107
00:04:38,449 --> 00:04:39,850
function was in philly delay

108
00:04:39,850 --> 00:04:43,220
however sleep function converts infinite

109
00:04:43,220 --> 00:04:45,050
delay in appropriate manner and pass it

110
00:04:45,050 --> 00:04:46,810
to anti delay execution as an argument

111
00:04:46,810 --> 00:04:49,460
such a delay interval thread will sleep

112
00:04:49,460 --> 00:04:51,979
forever let's see what is one when the

113
00:04:51,979 --> 00:04:54,139
integer execution is cooked by the cocoa

114
00:04:54,139 --> 00:04:57,010
monitor we have the same route to the

115
00:04:57,010 --> 00:05:01,660
integer execution but what happens now

116
00:05:01,660 --> 00:05:04,639
the integer execution cook called slip

117
00:05:04,639 --> 00:05:06,380
skip function and delay interval is

118
00:05:06,380 --> 00:05:09,800
replaced with 0.1 millisecond so until

119
00:05:09,800 --> 00:05:12,289
the execution original function will be

120
00:05:12,289 --> 00:05:14,210
executed with delay interval that equals

121
00:05:14,210 --> 00:05:16,639
to 0.1 millisecond so instead of

122
00:05:16,639 --> 00:05:18,590
sleeping forever thread will sleep only

123
00:05:18,590 --> 00:05:20,360
for 0.1 milliseconds as cuckoo is

124
00:05:20,360 --> 00:05:23,810
detected proposed solution for such a

125
00:05:23,810 --> 00:05:25,400
detection is just to add one additional

126
00:05:25,400 --> 00:05:28,220
condition as it checks delay interval

127
00:05:28,220 --> 00:05:31,280
value let's take a look at the dredge

128
00:05:31,280 --> 00:05:33,620
simulation problem when we are calling

129
00:05:33,620 --> 00:05:37,099
slip family functions the delay interval

130
00:05:37,099 --> 00:05:38,810
is added to the global variable G time

131
00:05:38,810 --> 00:05:41,510
skipped and when we call antiquary

132
00:05:41,510 --> 00:05:43,479
system time functions

133
00:05:43,479 --> 00:05:46,370
cuckoo monitor hook performs sis call

134
00:05:46,370 --> 00:05:48,590
for in T query system time functions and

135
00:05:48,590 --> 00:05:51,740
after that it adds a global variable G

136
00:05:51,740 --> 00:05:53,990
time skipped value 2 to the time it

137
00:05:53,990 --> 00:05:56,270
received so basically it's done in order

138
00:05:56,270 --> 00:06:00,530
to avoid detection by skip delays so but

139
00:06:00,530 --> 00:06:03,530
what we can do in the first write we can

140
00:06:03,530 --> 00:06:05,510
query current system time and after that

141
00:06:05,510 --> 00:06:07,400
we can start waiting for some object for

142
00:06:07,400 --> 00:06:10,400
100 milliseconds for example in the

143
00:06:10,400 --> 00:06:12,560
second thread we call slip x function

144
00:06:12,560 --> 00:06:14,330
with the delay interval the t calls for

145
00:06:14,330 --> 00:06:17,720
example 3 days thus this delay interval

146
00:06:17,720 --> 00:06:19,099
decided to G times keep the global

147
00:06:19,099 --> 00:06:21,860
variable after waiting for 100

148
00:06:21,860 --> 00:06:23,539
milliseconds in the first thread we

149
00:06:23,539 --> 00:06:25,550
simply call it quick query system time

150
00:06:25,550 --> 00:06:27,139
function for the second time

151
00:06:27,139 --> 00:06:29,300
and we compare the difference between a

152
00:06:29,300 --> 00:06:30,650
current system time and previously

153
00:06:30,650 --> 00:06:32,870
queried system time and if it's more

154
00:06:32,870 --> 00:06:36,229
than like one day a few days we can tell

155
00:06:36,229 --> 00:06:37,909
that we have detected cuckoo because

156
00:06:37,909 --> 00:06:39,650
after waiting 100 milliseconds for some

157
00:06:39,650 --> 00:06:42,110
object system time will change for about

158
00:06:42,110 --> 00:06:46,819
3 days ok so the first evasion technique

159
00:06:46,819 --> 00:06:49,370
we won't describe today is keeping of

160
00:06:49,370 --> 00:06:52,189
delays only within the first G sleep

161
00:06:52,189 --> 00:06:54,590
mark skips millisecond from the analysis

162
00:06:54,590 --> 00:06:57,469
start let's take a look at the evasion

163
00:06:57,469 --> 00:07:00,319
technique we perform some time consuming

164
00:07:00,319 --> 00:07:02,389
operations within the first district

165
00:07:02,389 --> 00:07:05,479
skips milliseconds and after that we can

166
00:07:05,479 --> 00:07:07,639
perform many large delay skips as a

167
00:07:07,639 --> 00:07:09,580
succeeding the critical time out for the

168
00:07:09,580 --> 00:07:12,860
execution after that we can perform any

169
00:07:12,860 --> 00:07:15,289
malicious activities we once because

170
00:07:15,289 --> 00:07:18,560
guest manager already sent signal to the

171
00:07:18,560 --> 00:07:21,919
VM that it should be shut down so the

172
00:07:21,919 --> 00:07:23,599
proposed solution is to skip all the

173
00:07:23,599 --> 00:07:24,909
layers that are larger than some

174
00:07:24,909 --> 00:07:28,430
constant value and for smaller delays we

175
00:07:28,430 --> 00:07:30,589
can use sliding window technique this

176
00:07:30,589 --> 00:07:32,120
technique is described on the current

177
00:07:32,120 --> 00:07:35,659
slide we collect collect the number of

178
00:07:35,659 --> 00:07:37,879
hits for a delay within the last 10

179
00:07:37,879 --> 00:07:40,789
seconds and if the number of hits for

180
00:07:40,789 --> 00:07:42,919
some delay X it's upper limit then we

181
00:07:42,919 --> 00:07:45,699
skip the delay to the end of execution

182
00:07:45,699 --> 00:07:48,529
as each technique it has its own pluses

183
00:07:48,529 --> 00:07:51,110
and minuses as a placer says that we

184
00:07:51,110 --> 00:07:54,379
skip a little large delays and small

185
00:07:54,379 --> 00:07:56,779
delays a limited set of skipped however

186
00:07:56,779 --> 00:07:59,060
the - is that distribution of delays

187
00:07:59,060 --> 00:08:02,719
between 0 and G slip mean skip delay may

188
00:08:02,719 --> 00:08:05,689
be pretty high the specific glaser upper

189
00:08:05,689 --> 00:08:09,289
limit will not be exceeded the subject

190
00:08:09,289 --> 00:08:11,180
problem we can actually group delays

191
00:08:11,180 --> 00:08:15,379
into swarms let's take a brief look at

192
00:08:15,379 --> 00:08:18,050
the communication architecture between

193
00:08:18,050 --> 00:08:20,750
host and guest virtual machines and the

194
00:08:20,750 --> 00:08:22,370
highest virtual machine guest manager is

195
00:08:22,370 --> 00:08:24,050
responsible for sending requests to the

196
00:08:24,050 --> 00:08:26,240
guest virtual machine and in the guest

197
00:08:26,240 --> 00:08:27,770
virtual machine we have a server that is

198
00:08:27,770 --> 00:08:30,319
called agent and it's responsible for

199
00:08:30,319 --> 00:08:34,990
sending responses to the host machine so

200
00:08:34,990 --> 00:08:37,339
agent is responsible for communication

201
00:08:37,339 --> 00:08:38,659
was host as it was mentioned as a

202
00:08:38,659 --> 00:08:39,380
previous slide

203
00:08:39,380 --> 00:08:42,230
and guest machine initialization and

204
00:08:42,230 --> 00:08:44,360
start enough modules is responsible for

205
00:08:44,360 --> 00:08:46,910
model tracking the name of that model

206
00:08:46,910 --> 00:08:48,980
its analyzer and we will discuss it

207
00:08:48,980 --> 00:08:49,910
later

208
00:08:49,910 --> 00:08:52,790
so some implementation details that will

209
00:08:52,790 --> 00:08:55,010
help us to detect the presence of agent

210
00:08:55,010 --> 00:08:58,490
is it listens on all interfaces on 8,000

211
00:08:58,490 --> 00:09:00,920
part actually detection may be performed

212
00:09:00,920 --> 00:09:03,920
on any part and it uses simple XML RPC

213
00:09:03,920 --> 00:09:06,760
server class for communication interface

214
00:09:06,760 --> 00:09:10,280
so to detect run in agent all we need to

215
00:09:10,280 --> 00:09:12,140
do is just simply enumerator listening

216
00:09:12,140 --> 00:09:14,990
circuits since crafted packet and wait

217
00:09:14,990 --> 00:09:17,450
for response if we received a specific

218
00:09:17,450 --> 00:09:18,650
response and we assume that we are

219
00:09:18,650 --> 00:09:21,220
running in coefficient box environment

220
00:09:21,220 --> 00:09:24,290
an example of crafted packet is

221
00:09:24,290 --> 00:09:26,510
presented from the left side an example

222
00:09:26,510 --> 00:09:28,430
of response is presented on the right

223
00:09:28,430 --> 00:09:33,380
side our proposed solution is present on

224
00:09:33,380 --> 00:09:35,450
the current slide if the connection

225
00:09:35,450 --> 00:09:38,080
request is coming from external

226
00:09:38,080 --> 00:09:41,050
interface then we simply accept it and

227
00:09:41,050 --> 00:09:44,630
if it comes from internal interface and

228
00:09:44,630 --> 00:09:51,050
we rejected ok I just mentioned earlier

229
00:09:51,050 --> 00:09:53,170
analyzer model is responsible for

230
00:09:53,170 --> 00:09:55,720
initialization of analysis procedure

231
00:09:55,720 --> 00:09:58,280
execution of analysis procedures of

232
00:09:58,280 --> 00:10:00,740
handling pipe messages grab coming from

233
00:10:00,740 --> 00:10:04,520
cuckoo monitor so some implementation

234
00:10:04,520 --> 00:10:06,230
details it is started by the agent

235
00:10:06,230 --> 00:10:09,350
module and its location is calculated in

236
00:10:09,350 --> 00:10:13,640
the random way so as we can see in the

237
00:10:13,640 --> 00:10:15,230
screens the container is the name of the

238
00:10:15,230 --> 00:10:17,810
folder that is created under the system

239
00:10:17,810 --> 00:10:20,690
Drive and the name is generated randomly

240
00:10:20,690 --> 00:10:23,840
but the problem is that in that folder

241
00:10:23,840 --> 00:10:26,240
we store two files with name analyzer

242
00:10:26,240 --> 00:10:28,790
file and analysis conf and this looks

243
00:10:28,790 --> 00:10:31,130
like is a way to detect presence of

244
00:10:31,130 --> 00:10:35,750
cocoa sandbox all we need to do we

245
00:10:35,750 --> 00:10:38,360
enumerate on folder some system drive we

246
00:10:38,360 --> 00:10:41,060
check if any folder contains those files

247
00:10:41,060 --> 00:10:44,120
and if file surprises and we assume that

248
00:10:44,120 --> 00:10:46,970
we run in cocoa sandbox environment the

249
00:10:46,970 --> 00:10:47,960
proposed solution is pretty

250
00:10:47,960 --> 00:10:49,570
straightforward what we should do we

251
00:10:49,570 --> 00:10:51,120
regenerate

252
00:10:51,120 --> 00:10:53,120
random name for the analyzer module and

253
00:10:53,120 --> 00:10:55,410
we generate the random name for the

254
00:10:55,410 --> 00:10:56,940
configuration file and pass it as an

255
00:10:56,940 --> 00:11:02,130
argument to the analyzer module let's

256
00:11:02,130 --> 00:11:03,510
move the very cool evasion techniques

257
00:11:03,510 --> 00:11:05,100
that may be used by malware outdoors to

258
00:11:05,100 --> 00:11:07,410
avoid behavior monitoring by cuckoo

259
00:11:07,410 --> 00:11:09,930
sandbox at the beginning you have to

260
00:11:09,930 --> 00:11:12,300
take a look on how analyzer decides to

261
00:11:12,300 --> 00:11:14,910
inject a lot to inject code into the

262
00:11:14,910 --> 00:11:18,600
process if the analyzer process list

263
00:11:18,600 --> 00:11:20,640
already contains a bit we want to inject

264
00:11:20,640 --> 00:11:23,220
a monitor we just performed some

265
00:11:23,220 --> 00:11:24,720
operations and return from the function

266
00:11:24,720 --> 00:11:27,630
without injecting code however if it

267
00:11:27,630 --> 00:11:29,100
does not contain the feed we add the

268
00:11:29,100 --> 00:11:32,370
speech to the process list and we start

269
00:11:32,370 --> 00:11:36,930
injection process as it's added to the

270
00:11:36,930 --> 00:11:38,070
process trees they should be removed

271
00:11:38,070 --> 00:11:41,790
somewhere as well then the laser checks

272
00:11:41,790 --> 00:11:44,580
if the process is still alive and if

273
00:11:44,580 --> 00:11:46,470
it's not then it removes speech from the

274
00:11:46,470 --> 00:11:49,200
process list however this branch will be

275
00:11:49,200 --> 00:11:53,550
executed only when pick check equals

276
00:11:53,550 --> 00:11:56,400
true but if we will force it to be false

277
00:11:56,400 --> 00:11:58,920
then the branch will never be executed

278
00:11:58,920 --> 00:12:00,690
so now pits will be deleted from the

279
00:12:00,690 --> 00:12:03,690
process list we can easily for spit

280
00:12:03,690 --> 00:12:06,120
check to be false by specifying in first

281
00:12:06,120 --> 00:12:11,730
timeout argument to the cuckoo so some

282
00:12:11,730 --> 00:12:13,290
Window System pits can repeat quite

283
00:12:13,290 --> 00:12:15,570
often we can create a list of already

284
00:12:15,570 --> 00:12:18,570
used bits and we can in the infinite

285
00:12:18,570 --> 00:12:20,640
loop we can create a process and check

286
00:12:20,640 --> 00:12:24,180
if process belongs to our list if it

287
00:12:24,180 --> 00:12:26,430
doesn't then we add the speed to our

288
00:12:26,430 --> 00:12:29,640
list at the same time analyzer adds the

289
00:12:29,640 --> 00:12:32,370
speed to the process list but when we

290
00:12:32,370 --> 00:12:35,430
meet Pete that is that is already in our

291
00:12:35,430 --> 00:12:39,330
pits list that simply means that the

292
00:12:39,330 --> 00:12:41,070
process list already contains that bit

293
00:12:41,070 --> 00:12:43,500
as well because it was not removed even

294
00:12:43,500 --> 00:12:46,170
if it was killed so monitor code will

295
00:12:46,170 --> 00:12:49,670
not be injected here so Coco sandbox

296
00:12:49,670 --> 00:12:54,480
behavior analysis was awaited the

297
00:12:54,480 --> 00:12:57,360
proposed solution is simple when the

298
00:12:57,360 --> 00:12:59,670
monitor process calls exit process

299
00:12:59,670 --> 00:13:03,060
family functions the Keele comment is

300
00:13:03,060 --> 00:13:06,120
sent via pipe so we can handle it and

301
00:13:06,120 --> 00:13:09,329
add just one line this removes the pitch

302
00:13:09,329 --> 00:13:13,890
from the process list the next diversion

303
00:13:13,890 --> 00:13:16,589
technique we want to describe is related

304
00:13:16,589 --> 00:13:18,089
to a Windows feature the name of the

305
00:13:18,089 --> 00:13:20,520
feature is task scheduler it's used for

306
00:13:20,520 --> 00:13:22,500
scheduling tasks for a specific time or

307
00:13:22,500 --> 00:13:25,620
interval it's available on own versions

308
00:13:25,620 --> 00:13:27,810
of Windows starting from windows 95 and

309
00:13:27,810 --> 00:13:30,150
its main feature we will use it task

310
00:13:30,150 --> 00:13:32,370
creation is not handled at all by cuckoo

311
00:13:32,370 --> 00:13:36,060
monitor so we have a malicious process

312
00:13:36,060 --> 00:13:39,000
named process 1 and we have database in

313
00:13:39,000 --> 00:13:41,339
the process to create a new task named

314
00:13:41,339 --> 00:13:46,650
AC task and after that we start that

315
00:13:46,650 --> 00:13:49,829
process and we can perform any malicious

316
00:13:49,829 --> 00:13:52,079
activity once because participated as

317
00:13:52,079 --> 00:13:56,310
objects are not monitored by cuckoo the

318
00:13:56,310 --> 00:13:59,070
last way to evade focus on works that we

319
00:13:59,070 --> 00:14:02,579
found is very simple and cool as you can

320
00:14:02,579 --> 00:14:04,320
see we have DLL main function is the

321
00:14:04,320 --> 00:14:06,870
entry function of community our model

322
00:14:06,870 --> 00:14:09,959
injected to the process everything looks

323
00:14:09,959 --> 00:14:12,959
fine except of this check if it's

324
00:14:12,959 --> 00:14:14,339
ignored protest function returns

325
00:14:14,339 --> 00:14:15,839
something except of zeros and we

326
00:14:15,839 --> 00:14:18,990
basically skip in monitor initialization

327
00:14:18,990 --> 00:14:23,370
functions so let's check how we can

328
00:14:23,370 --> 00:14:25,230
force is ignore process to return

329
00:14:25,230 --> 00:14:27,779
something except of zero we should

330
00:14:27,779 --> 00:14:31,079
simply create process from one of the

331
00:14:31,079 --> 00:14:34,310
pass from the jig nor process pass list

332
00:14:34,310 --> 00:14:40,020
so we check one file from the wait list

333
00:14:40,020 --> 00:14:42,300
process list who create this process in

334
00:14:42,300 --> 00:14:46,470
suspended state so now Monaco monitor

335
00:14:46,470 --> 00:14:48,000
initialization routines were not

336
00:14:48,000 --> 00:14:51,270
executed and what we do now we simply

337
00:14:51,270 --> 00:14:53,430
inject malicious code and resume threat

338
00:14:53,430 --> 00:14:58,189
so what is process is monitored

339
00:14:58,400 --> 00:15:00,600
okay so proposed solution is just to

340
00:15:00,600 --> 00:15:02,100
remove full process pass from the

341
00:15:02,100 --> 00:15:04,140
whitelist

342
00:15:04,140 --> 00:15:07,529
let's move to the next detection

343
00:15:07,529 --> 00:15:09,390
technique that is based on number of

344
00:15:09,390 --> 00:15:12,029
accurate exceptions as you can see we

345
00:15:12,029 --> 00:15:13,380
have a static variable as it is

346
00:15:13,380 --> 00:15:15,779
responsible for accumulating accurate

347
00:15:15,779 --> 00:15:19,650
exceptions and we check if it equals to

348
00:15:19,650 --> 00:15:22,140
some hard-coded value and if it's true

349
00:15:22,140 --> 00:15:25,589
then we simply exit the process with our

350
00:15:25,589 --> 00:15:26,370
code one

351
00:15:26,370 --> 00:15:29,610
let's see role of exception is used it's

352
00:15:29,610 --> 00:15:31,290
used in the hotel dispatch exception

353
00:15:31,290 --> 00:15:37,410
hook so if a cleared exception is not

354
00:15:37,410 --> 00:15:38,940
quite listed then this function is

355
00:15:38,940 --> 00:15:42,930
called so to detect presence of cuca

356
00:15:42,930 --> 00:15:45,690
sandbox environment we create a second

357
00:15:45,690 --> 00:15:47,910
process in the second process we'll

358
00:15:47,910 --> 00:15:49,650
simply raise exception marks count plus

359
00:15:49,650 --> 00:15:52,500
one exceptions and if our tell dispatch

360
00:15:52,500 --> 00:15:55,260
exception is hooked then process will

361
00:15:55,260 --> 00:15:58,170
exit with our code one if it's not hook

362
00:15:58,170 --> 00:16:00,270
if it's not hook then it will exit is

363
00:16:00,270 --> 00:16:03,060
error code 0 so in the first process we

364
00:16:03,060 --> 00:16:06,510
just collect process exit code and if it

365
00:16:06,510 --> 00:16:08,820
equals once and it means that question

366
00:16:08,820 --> 00:16:12,270
box was detected the last detection

367
00:16:12,270 --> 00:16:15,000
technique for cocoa sandbox we want to

368
00:16:15,000 --> 00:16:17,040
present today is based on configuration

369
00:16:17,040 --> 00:16:18,360
files it is responsible for

370
00:16:18,360 --> 00:16:20,209
configuration of cocoa monitor into

371
00:16:20,209 --> 00:16:25,020
introduced the problem is that location

372
00:16:25,020 --> 00:16:27,270
of that file is well known and it's

373
00:16:27,270 --> 00:16:30,900
located under C Drive and file name is

374
00:16:30,900 --> 00:16:35,190
Coco person detainee so we simply create

375
00:16:35,190 --> 00:16:37,920
some photos in suspended State we as far

376
00:16:37,920 --> 00:16:41,010
as we have process ID we check the C

377
00:16:41,010 --> 00:16:43,830
Drive for the presence of cuckoo prod

378
00:16:43,830 --> 00:16:46,980
sent detainee file for a few times with

379
00:16:46,980 --> 00:16:50,520
a some delay Stesha file is present and

380
00:16:50,520 --> 00:16:52,560
assumes that we are running side coco

381
00:16:52,560 --> 00:16:55,529
sandbox environment okay that's all for

382
00:16:55,529 --> 00:16:58,350
cocoa sandbox now I'll pass presentation

383
00:16:58,350 --> 00:17:00,570
to Alex and he will tell you about your

384
00:17:00,570 --> 00:17:02,870
environment detection techniques and

385
00:17:02,870 --> 00:17:06,800
sandbox so we have created

386
00:17:07,839 --> 00:17:10,628
thanks thanks love so now let's talk

387
00:17:10,628 --> 00:17:12,339
about that things which may be used to

388
00:17:12,339 --> 00:17:14,429
detect your virtual environment itself

389
00:17:14,429 --> 00:17:17,829
so the first typically is based on the

390
00:17:17,829 --> 00:17:20,549
fact that tampering with a date and time

391
00:17:20,549 --> 00:17:23,409
in your virtualized environments so the

392
00:17:23,409 --> 00:17:26,529
detection based on three main points in

393
00:17:26,529 --> 00:17:29,470
real environment the system on the

394
00:17:29,470 --> 00:17:31,659
system time should correlate with a web

395
00:17:31,659 --> 00:17:33,700
time we should not see a lot of

396
00:17:33,700 --> 00:17:35,519
difference here for all those reasons

397
00:17:35,519 --> 00:17:39,009
so another thing as we want to execute

398
00:17:39,009 --> 00:17:40,659
as much code as possible in a very

399
00:17:40,659 --> 00:17:42,600
limited amount of time of the emulation

400
00:17:42,600 --> 00:17:45,220
we need to utilize their sleeves keeping

401
00:17:45,220 --> 00:17:48,190
functionality and the third one that

402
00:17:48,190 --> 00:17:49,889
sometimes in virtual environments

403
00:17:49,889 --> 00:17:51,940
responses from the web services are

404
00:17:51,940 --> 00:17:55,509
emulated because you most probably don't

405
00:17:55,509 --> 00:17:57,070
want to use the dirty line connection

406
00:17:57,070 --> 00:18:00,999
option in kuku so let's see how all

407
00:18:00,999 --> 00:18:05,529
these can lead us to the detection we

408
00:18:05,529 --> 00:18:07,600
have approach number one which performs

409
00:18:07,600 --> 00:18:09,789
the following operations first of all it

410
00:18:09,789 --> 00:18:12,490
gets a local time and then let's get the

411
00:18:12,490 --> 00:18:15,399
web time for example by sending requests

412
00:18:15,399 --> 00:18:18,820
to Google servers and person responds in

413
00:18:18,820 --> 00:18:21,970
the next step it sleeps for 60 seconds

414
00:18:21,970 --> 00:18:23,950
and then it repeats the same operations

415
00:18:23,950 --> 00:18:28,919
once again it sends the response and

416
00:18:28,919 --> 00:18:32,110
questions get the response so we can

417
00:18:32,110 --> 00:18:34,990
assume that if the difference between

418
00:18:34,990 --> 00:18:37,990
the web time and the local time is more

419
00:18:37,990 --> 00:18:40,570
than five seconds then most likely we

420
00:18:40,570 --> 00:18:42,850
are running injury in the virtualized

421
00:18:42,850 --> 00:18:45,700
environment it can be either emulation

422
00:18:45,700 --> 00:18:47,590
of web services or sleep skipping

423
00:18:47,590 --> 00:18:50,559
technique also we can tell them what

424
00:18:50,559 --> 00:18:52,389
specifically what happened here is by

425
00:18:52,389 --> 00:18:55,149
executing two additional checks if he

426
00:18:55,149 --> 00:18:57,149
observes at a time Delta between the

427
00:18:57,149 --> 00:19:00,759
first and second function calls less

428
00:19:00,759 --> 00:19:03,879
than 60 seconds that we've tried to

429
00:19:03,879 --> 00:19:06,909
sleep initially most likely something is

430
00:19:06,909 --> 00:19:11,580
implied it other web services or sleep

431
00:19:11,580 --> 00:19:15,129
so the second technique is based on the

432
00:19:15,129 --> 00:19:16,290
fact that you

433
00:19:16,290 --> 00:19:19,280
sandbox games only run on a single core

434
00:19:19,280 --> 00:19:23,040
while real machines utilize more than

435
00:19:23,040 --> 00:19:25,890
one of course so what were uses of fact

436
00:19:25,890 --> 00:19:28,070
and checks the number of processors and

437
00:19:28,070 --> 00:19:30,870
by some figures whether it's running in

438
00:19:30,870 --> 00:19:33,990
the virtualized environment or not let's

439
00:19:33,990 --> 00:19:37,040
take a look at how the number of course

440
00:19:37,040 --> 00:19:39,420
can be retrieved nowadays by the malware

441
00:19:39,420 --> 00:19:42,330
in the wild first of all it can use the

442
00:19:42,330 --> 00:19:46,290
function gets system info it can get it

443
00:19:46,290 --> 00:19:49,170
directly from PAB or it can use get

444
00:19:49,170 --> 00:19:53,610
native system info API unfortunately all

445
00:19:53,610 --> 00:19:57,600
these can be patched so we discovered a

446
00:19:57,600 --> 00:19:59,280
new technique should we haven't seen in

447
00:19:59,280 --> 00:20:01,590
the wild yet but most likely we would

448
00:20:01,590 --> 00:20:04,890
the bad guys are watching us so here it

449
00:20:04,890 --> 00:20:07,800
is first we get a number of potential

450
00:20:07,800 --> 00:20:10,140
course by one of the standard method

451
00:20:10,140 --> 00:20:12,810
mentioned on the previous slide as each

452
00:20:12,810 --> 00:20:14,790
core represents logical processor we can

453
00:20:14,790 --> 00:20:16,770
set a thread affinity mask in the way

454
00:20:16,770 --> 00:20:18,900
that will allow our thread to run only

455
00:20:18,900 --> 00:20:21,990
on that specific core then we run CP on

456
00:20:21,990 --> 00:20:24,690
the instruction and as a result we get

457
00:20:24,690 --> 00:20:27,990
an API CID for that specific logical

458
00:20:27,990 --> 00:20:30,660
core and put it in the unique set we

459
00:20:30,660 --> 00:20:34,130
repeat this step for each core finally

460
00:20:34,130 --> 00:20:37,350
if this unique set size is less the

461
00:20:37,350 --> 00:20:40,050
number of detected course then we know

462
00:20:40,050 --> 00:20:41,610
that most likely we're dealing with the

463
00:20:41,610 --> 00:20:43,410
hood function which tempers with a

464
00:20:43,410 --> 00:20:45,030
number of course result in virtual

465
00:20:45,030 --> 00:20:47,700
environment detection but where there is

466
00:20:47,700 --> 00:20:53,130
no fix for that yet so another

467
00:20:53,130 --> 00:20:55,830
well-known technique is detection by rod

468
00:20:55,830 --> 00:20:58,500
firmware table content this technique

469
00:20:58,500 --> 00:21:04,100
was first implemented in VMD 2 and the

470
00:21:04,100 --> 00:21:07,050
travesty systems the content can be

471
00:21:07,050 --> 00:21:09,990
retrieved by using the integrated

472
00:21:09,990 --> 00:21:14,010
virtual memory Cisco from the ACS she

473
00:21:14,010 --> 00:21:17,580
has a recess service and on the Vista

474
00:21:17,580 --> 00:21:19,120
and above systems

475
00:21:19,120 --> 00:21:20,740
content of those tables can be retrieved

476
00:21:20,740 --> 00:21:23,320
using by using antiquary system

477
00:21:23,320 --> 00:21:27,010
information function the fact it is that

478
00:21:27,010 --> 00:21:31,030
even this technique is well known there

479
00:21:31,030 --> 00:21:32,830
is no like proposed solution for that

480
00:21:32,830 --> 00:21:38,230
yet so we've prepared one for you as

481
00:21:38,230 --> 00:21:40,330
there are two different mutations the

482
00:21:40,330 --> 00:21:42,940
solutions will also differ so on the

483
00:21:42,940 --> 00:21:45,820
previous systems we propose using to

484
00:21:45,820 --> 00:21:50,080
read virtual memory service splicing you

485
00:21:50,080 --> 00:21:51,340
should check if the written dress is

486
00:21:51,340 --> 00:21:53,320
equal to see four zeros or

487
00:21:53,320 --> 00:21:56,470
four zeros if it is then if you'd modify

488
00:21:56,470 --> 00:21:58,900
the buffer which will return to the user

489
00:21:58,900 --> 00:22:01,000
space by either removing the artifacts

490
00:22:01,000 --> 00:22:03,429
or just returning another legitimate

491
00:22:03,429 --> 00:22:06,820
movement here on the visitor in highest

492
00:22:06,820 --> 00:22:09,220
systems we propose who can the NT query

493
00:22:09,220 --> 00:22:12,130
system information service first if you

494
00:22:12,130 --> 00:22:13,990
check of the system information class is

495
00:22:13,990 --> 00:22:15,580
equal to system from where table

496
00:22:15,580 --> 00:22:18,730
information then we parse it in from a

497
00:22:18,730 --> 00:22:20,290
table information structure and get

498
00:22:20,290 --> 00:22:23,160
provider signature and table ID fields

499
00:22:23,160 --> 00:22:25,480
then we check if the provider signature

500
00:22:25,480 --> 00:22:31,720
resides a room or our SMB and then we

501
00:22:31,720 --> 00:22:33,880
are calling an original antique where

502
00:22:33,880 --> 00:22:35,679
information routine and taking the same

503
00:22:35,679 --> 00:22:38,080
measures as we do with the previous

504
00:22:38,080 --> 00:22:41,170
systems would find that will be returned

505
00:22:41,170 --> 00:22:46,000
to the user space so since we discovered

506
00:22:46,000 --> 00:22:47,500
through the need detection techniques

507
00:22:47,500 --> 00:22:49,600
for kuku sandbox as well as very cool

508
00:22:49,600 --> 00:22:52,000
environments and proposed fixes for that

509
00:22:52,000 --> 00:22:54,100
we realize that at the moment there is

510
00:22:54,100 --> 00:22:55,809
no such - on the internet that will

511
00:22:55,809 --> 00:22:59,050
allow you to assess your virtual

512
00:22:59,050 --> 00:23:01,000
environments in an easy and reliable way

513
00:23:01,000 --> 00:23:04,000
and will contain the most recent and

514
00:23:04,000 --> 00:23:06,730
up-to-date detection techniques also

515
00:23:06,730 --> 00:23:09,400
existing tools will only tell you like

516
00:23:09,400 --> 00:23:11,380
what they found but know how to fix it

517
00:23:11,380 --> 00:23:14,230
so we decide to create our own tool that

518
00:23:14,230 --> 00:23:16,059
will address all these drawbacks

519
00:23:16,059 --> 00:23:18,250
more than that anyone can contribute to

520
00:23:18,250 --> 00:23:20,920
that - even without touching the source

521
00:23:20,920 --> 00:23:25,210
code at all so as I already mentioned we

522
00:23:25,210 --> 00:23:27,010
wanted the generic tools will cover a

523
00:23:27,010 --> 00:23:28,690
lot of different virtual environments

524
00:23:28,690 --> 00:23:30,700
detection links and group proposed fix

525
00:23:30,700 --> 00:23:32,580
it for that

526
00:23:32,580 --> 00:23:34,380
we wanted it to be easily extendable so

527
00:23:34,380 --> 00:23:35,730
the support for new virtual environments

528
00:23:35,730 --> 00:23:37,100
can be added quickly

529
00:23:37,100 --> 00:23:40,080
also since kuku sandbox is the most

530
00:23:40,080 --> 00:23:42,390
prevalent to automated malware analysis

531
00:23:42,390 --> 00:23:44,070
we wanted to include the detection of it

532
00:23:44,070 --> 00:23:48,000
as well in addition we wanted to create

533
00:23:48,000 --> 00:23:49,650
an ability to introduce new detection

534
00:23:49,650 --> 00:23:50,820
techniques not freely modifying the

535
00:23:50,820 --> 00:23:53,789
source code but by using the JSON

536
00:23:53,789 --> 00:23:55,289
configuration file so the whole

537
00:23:55,289 --> 00:23:56,880
community can contribute towards the

538
00:23:56,880 --> 00:23:59,309
development of that tool and finally we

539
00:23:59,309 --> 00:24:03,179
wanted user friendly reports about the

540
00:24:03,179 --> 00:24:05,610
chat environment and that can be shared

541
00:24:05,610 --> 00:24:09,000
within the organization monk-like purely

542
00:24:09,000 --> 00:24:11,070
technical guys and also a high

543
00:24:11,070 --> 00:24:15,030
management so we support frits pacific

544
00:24:15,030 --> 00:24:16,940
environments such as cocoa sandbox

545
00:24:16,940 --> 00:24:21,960
VirtualBox VM ware and also a set of

546
00:24:21,960 --> 00:24:23,490
generic detection that can be assigned

547
00:24:23,490 --> 00:24:26,760
to any specific environment generic

548
00:24:26,760 --> 00:24:28,890
deductions may be based on registry keys

549
00:24:28,890 --> 00:24:33,409
devices files processes MAC addresses

550
00:24:33,409 --> 00:24:36,210
adapters disk names

551
00:24:36,210 --> 00:24:39,659
firmware contents system object content

552
00:24:39,659 --> 00:24:42,690
protester vendors windows names and

553
00:24:42,690 --> 00:24:48,270
shell folders like etc so for example

554
00:24:48,270 --> 00:24:49,950
let's take a look at the configuration

555
00:24:49,950 --> 00:24:53,549
file content specifically the part that

556
00:24:53,549 --> 00:24:56,370
utilizes registry key detection as you

557
00:24:56,370 --> 00:24:57,960
may notice we can specify more than one

558
00:24:57,960 --> 00:25:00,659
artifact so the search would be

559
00:25:00,659 --> 00:25:02,520
performed on the set of artifacts which

560
00:25:02,520 --> 00:25:04,890
is quite useful and we can also add the

561
00:25:04,890 --> 00:25:09,780
key recursive all sub Keys within the

562
00:25:09,780 --> 00:25:13,710
parent key so configuration supports all

563
00:25:13,710 --> 00:25:16,460
previously mentioned artifacts as well

564
00:25:16,460 --> 00:25:19,470
so to add a new detection artifact we

565
00:25:19,470 --> 00:25:20,669
just need to add a new entry in the

566
00:25:20,669 --> 00:25:23,340
configuration file the results lutely no

567
00:25:23,340 --> 00:25:25,940
need to redo a compilation of the tool

568
00:25:25,940 --> 00:25:28,799
as an example we can add such a section

569
00:25:28,799 --> 00:25:30,780
in the configuration file to detect

570
00:25:30,780 --> 00:25:32,130
other environments based on a specific

571
00:25:32,130 --> 00:25:37,380
device so if you want to add a new

572
00:25:37,380 --> 00:25:38,730
virtual environment support

573
00:25:38,730 --> 00:25:40,470
we just need to implement the following

574
00:25:40,470 --> 00:25:43,039
template

575
00:25:43,820 --> 00:25:48,259
so it's pretty easy let's move on to the

576
00:25:48,259 --> 00:25:50,960
hood interfaces here is a list of how to

577
00:25:50,960 --> 00:25:54,080
interpret that we have we cannot put the

578
00:25:54,080 --> 00:25:56,359
report this is the most user-friendly

579
00:25:56,359 --> 00:25:58,789
version of the output you get like a

580
00:25:58,789 --> 00:26:00,919
nice HTML file with a description of

581
00:26:00,919 --> 00:26:03,320
detection techniques and also with

582
00:26:03,320 --> 00:26:06,190
advices on how to fix them

583
00:26:06,190 --> 00:26:08,299
the second option is output to the

584
00:26:08,299 --> 00:26:11,539
console this method is usually useful

585
00:26:11,539 --> 00:26:14,049
like to get the debug information and

586
00:26:14,049 --> 00:26:18,649
the third one is we can create a file

587
00:26:18,649 --> 00:26:21,919
for each specific detection technique

588
00:26:21,919 --> 00:26:23,989
and the file name will contain detection

589
00:26:23,989 --> 00:26:26,090
technique name class detected or not

590
00:26:26,090 --> 00:26:28,899
detected postfix and this method is most

591
00:26:28,899 --> 00:26:31,519
convenient for chickens in environments

592
00:26:31,519 --> 00:26:33,529
where we don't have a full access and

593
00:26:33,529 --> 00:26:36,349
you can just upload the file like such

594
00:26:36,349 --> 00:26:39,349
as virustotal or malware or any other

595
00:26:39,349 --> 00:26:43,279
sandbox out there so here is a sample of

596
00:26:43,279 --> 00:26:45,679
the report how the report looks like

597
00:26:45,679 --> 00:26:48,710
it's just like part of it it's usually

598
00:26:48,710 --> 00:26:54,619
much bigger but it looks like that so

599
00:26:54,619 --> 00:26:56,599
let's sum up we present a lot of

600
00:26:56,599 --> 00:26:59,149
introduction evasions for kuku sandbox

601
00:26:59,149 --> 00:27:01,220
today and we hope that they will be

602
00:27:01,220 --> 00:27:03,289
fixed as soon as possible by recorders

603
00:27:03,289 --> 00:27:05,659
or by the community we're in contact

604
00:27:05,659 --> 00:27:07,399
with the kuku developers and we're

605
00:27:07,399 --> 00:27:09,549
willing to help and share information

606
00:27:09,549 --> 00:27:12,649
we'll develop an easily extendable to

607
00:27:12,649 --> 00:27:14,720
four virtual environments assessments

608
00:27:14,720 --> 00:27:17,899
which supports easy interface for adding

609
00:27:17,899 --> 00:27:19,820
new environments additional new

610
00:27:19,820 --> 00:27:22,190
detection techniques using configuration

611
00:27:22,190 --> 00:27:26,229
files and also a multiple output options

612
00:27:26,229 --> 00:27:28,489
the most important part is that our

613
00:27:28,489 --> 00:27:33,529
tools available is open source so now

614
00:27:33,529 --> 00:27:37,210
it's time for questions thank you

615
00:27:39,000 --> 00:27:42,140
thank you for your interesting talk and

616
00:27:42,140 --> 00:27:45,320
there are any questions here right there

617
00:27:45,320 --> 00:27:47,909
have you seen malware authors adapt

618
00:27:47,909 --> 00:27:49,799
their techniques based on the work that

619
00:27:49,799 --> 00:27:52,400
you've done so far

620
00:27:52,530 --> 00:27:57,419
basically I think that we've presented I

621
00:27:57,419 --> 00:27:59,970
think that malware authors will adopt

622
00:27:59,970 --> 00:28:02,610
them but as I said we're with a contact

623
00:28:02,610 --> 00:28:05,909
with within the contact with the chorus

624
00:28:05,909 --> 00:28:11,100
so we hope that those bugs will be fixed

625
00:28:11,100 --> 00:28:14,580
before anybody can do any harm so we're

626
00:28:14,580 --> 00:28:16,260
willing to share information so if you

627
00:28:16,260 --> 00:28:18,500
have any requests please contact us and

628
00:28:18,500 --> 00:28:23,059
we'll provide like technical information

629
00:28:32,120 --> 00:28:37,380
techniques on the vendor spoke how they

630
00:28:37,380 --> 00:28:38,970
were working if they are the same

631
00:28:38,970 --> 00:28:40,409
working in this and there's four core

632
00:28:40,409 --> 00:28:42,780
because you are testing them under them

633
00:28:42,780 --> 00:28:45,179
upstream main line they said the guys

634
00:28:45,179 --> 00:28:47,400
from the kuku foundation did you test

635
00:28:47,400 --> 00:28:52,650
the same techniques on the other fork we

636
00:28:52,650 --> 00:28:55,169
have tested it on our c1 like the latest

637
00:28:55,169 --> 00:29:05,580
you know stable version okay I'm afraid

638
00:29:05,580 --> 00:29:07,679
we are running out of time so if you

639
00:29:07,679 --> 00:29:10,770
have any questions you can contact

640
00:29:10,770 --> 00:29:15,770
directly speakers so thank you very much

