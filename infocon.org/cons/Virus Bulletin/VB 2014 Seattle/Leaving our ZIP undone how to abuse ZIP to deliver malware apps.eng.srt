1
00:00:00,000 --> 00:00:03,000
okay so let's continue with our program

2
00:00:03,000 --> 00:00:06,740
the last presentation before lunch and

3
00:00:06,740 --> 00:00:09,780
Gregory panaqa will show you how to

4
00:00:09,780 --> 00:00:12,509
abuse zip to deliver malware apps I

5
00:00:12,509 --> 00:00:15,120
think isn't it yeah thank you I'm

6
00:00:15,120 --> 00:00:16,770
Gregory panicle from case on computing

7
00:00:16,770 --> 00:00:18,420
what I will be covering in this

8
00:00:18,420 --> 00:00:20,010
presentation today he is the

9
00:00:20,010 --> 00:00:22,350
exploitation of the zip file format that

10
00:00:22,350 --> 00:00:23,970
forms the base for an Android

11
00:00:23,970 --> 00:00:26,430
application we will be covering a few

12
00:00:26,430 --> 00:00:28,380
handpick cases of Android

13
00:00:28,380 --> 00:00:30,090
vulnerabilities that are caused due to

14
00:00:30,090 --> 00:00:32,640
it zip file format handling oh sorry

15
00:00:32,640 --> 00:00:37,620
about that so will then look at a novel

16
00:00:37,620 --> 00:00:40,850
method to bypass deep inspection of

17
00:00:40,850 --> 00:00:42,840
Android applications by antivirus

18
00:00:42,840 --> 00:00:45,809
software by using specially crafted ap

19
00:00:45,809 --> 00:00:48,840
case we will then see the chameleons if

20
00:00:48,840 --> 00:00:51,719
that can be interpreted differently you

21
00:00:51,719 --> 00:00:53,489
know depending on the application that

22
00:00:53,489 --> 00:00:59,460
process said first a quick look at the

23
00:00:59,460 --> 00:01:02,190
zip file format the zip file contains

24
00:01:02,190 --> 00:01:04,049
automated data related to the files it

25
00:01:04,049 --> 00:01:06,630
holds sorry to both those who already

26
00:01:06,630 --> 00:01:09,869
know this the zip file contains a lot of

27
00:01:09,869 --> 00:01:12,060
you know it condenses handle directly

28
00:01:12,060 --> 00:01:13,350
header that is located at the end of the

29
00:01:13,350 --> 00:01:15,420
file the details in the central

30
00:01:15,420 --> 00:01:17,220
directory header contains information

31
00:01:17,220 --> 00:01:19,979
such as the file names the compressor

32
00:01:19,979 --> 00:01:22,350
and uncompressed data sizes the

33
00:01:22,350 --> 00:01:23,640
compression method used to compress

34
00:01:23,640 --> 00:01:27,210
these files as well as relative offset

35
00:01:27,210 --> 00:01:29,060
from the start of the file were the

36
00:01:29,060 --> 00:01:31,020
local file header for the corresponding

37
00:01:31,020 --> 00:01:34,799
file could be located the archived data

38
00:01:34,799 --> 00:01:36,810
for a particular file follows the local

39
00:01:36,810 --> 00:01:38,310
file header that is located towards the

40
00:01:38,310 --> 00:01:41,790
start of the file now an anarchic

41
00:01:41,790 --> 00:01:43,439
application typically starts processing

42
00:01:43,439 --> 00:01:46,979
a zip file by first look locating

43
00:01:46,979 --> 00:01:49,079
central directory header that is located

44
00:01:49,079 --> 00:01:50,880
towards the end of the file for that it

45
00:01:50,880 --> 00:01:52,890
scans the last 64 kb of the file for

46
00:01:52,890 --> 00:01:54,810
special magic values in order to locate

47
00:01:54,810 --> 00:01:56,549
the end of the end of central directory

48
00:01:56,549 --> 00:01:58,079
header and then it starts working

49
00:01:58,079 --> 00:02:00,570
towards start of the file to locate be

50
00:02:00,570 --> 00:02:04,770
archived data now moving on to the APK

51
00:02:04,770 --> 00:02:07,649
file format the APK file format or the

52
00:02:07,649 --> 00:02:09,330
android package follows a predefined

53
00:02:09,330 --> 00:02:12,590
directory structure that enables the

54
00:02:12,590 --> 00:02:14,530
you know android package manager to

55
00:02:14,530 --> 00:02:16,340
cryptographically verify the whole

56
00:02:16,340 --> 00:02:19,250
package it can it's essentially a Java

57
00:02:19,250 --> 00:02:22,190
archive that contains a android specific

58
00:02:22,190 --> 00:02:24,260
files one being the android manifest map

59
00:02:24,260 --> 00:02:26,930
file which basically describes the

60
00:02:26,930 --> 00:02:29,660
application as well as any permission it

61
00:02:29,660 --> 00:02:33,170
requires the main dialogue executable

62
00:02:33,170 --> 00:02:35,390
that is the classes or decks is

63
00:02:35,390 --> 00:02:37,760
essentially an amalgamated file which is

64
00:02:37,760 --> 00:02:40,220
which you know the all the classes that

65
00:02:40,220 --> 00:02:42,349
are required required for execution are

66
00:02:42,349 --> 00:02:46,610
all mashed up together the epic a will

67
00:02:46,610 --> 00:02:49,250
also contain signing related files that

68
00:02:49,250 --> 00:02:52,040
helps validate the whole package the APK

69
00:02:52,040 --> 00:02:54,380
would contain in other information or

70
00:02:54,380 --> 00:02:57,590
the resources that the epic the whole

71
00:02:57,590 --> 00:03:00,500
land Royd package would require let us

72
00:03:00,500 --> 00:03:02,780
see how the APK is handled by the

73
00:03:02,780 --> 00:03:05,450
android OS for in verification and

74
00:03:05,450 --> 00:03:08,060
installation the android OS on both

75
00:03:08,060 --> 00:03:10,370
starts to services that are relevant to

76
00:03:10,370 --> 00:03:12,379
us one being the install d or the

77
00:03:12,379 --> 00:03:15,560
install Damon it's essentially a

78
00:03:15,560 --> 00:03:20,060
component that's written in C C++ it it

79
00:03:20,060 --> 00:03:21,829
listens on domains or kids waiting for

80
00:03:21,829 --> 00:03:24,739
commands to install an APK to a specific

81
00:03:24,739 --> 00:03:27,549
directory with appropriate permissions

82
00:03:27,549 --> 00:03:30,200
then you have a component called package

83
00:03:30,200 --> 00:03:32,720
manager service that it is a component

84
00:03:32,720 --> 00:03:35,239
written in Java it gets loaded as part

85
00:03:35,239 --> 00:03:37,099
of the system server process which is

86
00:03:37,099 --> 00:03:40,700
also started on boot now this component

87
00:03:40,700 --> 00:03:43,430
validates an EPK prior to issuing

88
00:03:43,430 --> 00:03:46,010
commands to the install Damon to perform

89
00:03:46,010 --> 00:03:48,620
the actual on dis installation the user

90
00:03:48,620 --> 00:03:50,630
may interact with a component called

91
00:03:50,630 --> 00:03:54,470
package manager which you know helps the

92
00:03:54,470 --> 00:03:56,359
user to install an APK interactively

93
00:03:56,359 --> 00:03:58,549
this component would communicate with

94
00:03:58,549 --> 00:03:59,889
the background package manager service

95
00:03:59,889 --> 00:04:05,060
whenever required now as you have seen

96
00:04:05,060 --> 00:04:07,099
you have two components in android OS

97
00:04:07,099 --> 00:04:10,669
that deals with the APK file format the

98
00:04:10,669 --> 00:04:13,160
one that is a returning Java else with

99
00:04:13,160 --> 00:04:15,470
the verification of validation of the

100
00:04:15,470 --> 00:04:18,560
apk and you have the CC purpose

101
00:04:18,560 --> 00:04:21,409
component that extracts and you know the

102
00:04:21,409 --> 00:04:22,820
final comment that is loaded onto the

103
00:04:22,820 --> 00:04:26,090
system it is as part of the installation

104
00:04:26,090 --> 00:04:28,480
now the logic for these implementations

105
00:04:28,480 --> 00:04:31,130
cannot only be different but we mutually

106
00:04:31,130 --> 00:04:33,460
opposite at certain parts in the code

107
00:04:33,460 --> 00:04:38,240
now this means that you have you know

108
00:04:38,240 --> 00:04:39,889
because of the logic difference there is

109
00:04:39,889 --> 00:04:41,990
an opportunity for the attackers to

110
00:04:41,990 --> 00:04:43,669
bypass the cryptographic verification

111
00:04:43,669 --> 00:04:46,190
process of the android OS allowing

112
00:04:46,190 --> 00:04:48,620
progenies apks to be installed onto the

113
00:04:48,620 --> 00:04:50,680
system as though it was verified clean

114
00:04:50,680 --> 00:04:53,360
let's take a look at you know the few

115
00:04:53,360 --> 00:04:55,790
prominent Warner abilities that I've you

116
00:04:55,790 --> 00:04:57,590
know come across we have come across in

117
00:04:57,590 --> 00:04:59,960
the last couple of years the first is

118
00:04:59,960 --> 00:05:02,330
the master key vulnerability of course

119
00:05:02,330 --> 00:05:05,120
the master key vulnerability arises due

120
00:05:05,120 --> 00:05:07,340
to the discrepancy in the way the

121
00:05:07,340 --> 00:05:10,100
android OS handles or the components

122
00:05:10,100 --> 00:05:11,900
that handled the APK inside the android

123
00:05:11,900 --> 00:05:13,880
OS handled the occurrence of multiple

124
00:05:13,880 --> 00:05:16,340
files with the same name within the APK

125
00:05:16,340 --> 00:05:19,610
archive now the java component when it

126
00:05:19,610 --> 00:05:21,710
wants to ala date a particular entry

127
00:05:21,710 --> 00:05:24,410
would pick the very last entry from you

128
00:05:24,410 --> 00:05:26,180
know the multiple entries that you find

129
00:05:26,180 --> 00:05:29,150
while the CC previous component would

130
00:05:29,150 --> 00:05:30,830
extract the very first entry from the

131
00:05:30,830 --> 00:05:34,039
APK now this you know entry would never

132
00:05:34,039 --> 00:05:35,720
have been validated by the java layer

133
00:05:35,720 --> 00:05:38,000
but it gets extracted and loaded onto

134
00:05:38,000 --> 00:05:39,710
the system as though it was verified

135
00:05:39,710 --> 00:05:42,650
clean now this gives an opportunity to

136
00:05:42,650 --> 00:05:44,180
you know for the malicious attacker to

137
00:05:44,180 --> 00:05:46,400
place it as the malicious entry to be

138
00:05:46,400 --> 00:05:48,080
place as the first entry and this is the

139
00:05:48,080 --> 00:05:49,490
one that he actually gets loaded on the

140
00:05:49,490 --> 00:05:52,490
system now this vulnerability of x

141
00:05:52,490 --> 00:05:57,800
android OS prior to jellybean the next

142
00:05:57,800 --> 00:06:00,650
vulnerability is to do with how you know

143
00:06:00,650 --> 00:06:02,240
both these implementation that is in

144
00:06:02,240 --> 00:06:04,789
java and c process try to locate the

145
00:06:04,789 --> 00:06:07,310
archive data now in order to locate the

146
00:06:07,310 --> 00:06:09,229
archive data first is locates the

147
00:06:09,229 --> 00:06:10,610
particular entry within the central

148
00:06:10,610 --> 00:06:13,070
directory header and from there it finds

149
00:06:13,070 --> 00:06:14,720
the offset for the local file header

150
00:06:14,720 --> 00:06:16,910
what you see on screen is the local file

151
00:06:16,910 --> 00:06:19,250
later it contains some variable length

152
00:06:19,250 --> 00:06:21,710
fields one being the file name and the

153
00:06:21,710 --> 00:06:24,740
other being the extra data field both

154
00:06:24,740 --> 00:06:26,360
the lengths are specified within the

155
00:06:26,360 --> 00:06:29,060
header it's both our 16-bit fields now

156
00:06:29,060 --> 00:06:31,220
the vulnerability is to do with how the

157
00:06:31,220 --> 00:06:32,990
Java layer and the sea pusses layer

158
00:06:32,990 --> 00:06:36,620
treats this extra field length field the

159
00:06:36,620 --> 00:06:38,450
Java layer incorrectly treated as a

160
00:06:38,450 --> 00:06:39,470
signed integer

161
00:06:39,470 --> 00:06:41,720
while the CC proposed component is

162
00:06:41,720 --> 00:06:46,750
correctly as a you know unsigned integer

163
00:06:46,750 --> 00:06:49,580
so if one place is a very large value

164
00:06:49,580 --> 00:06:51,650
within this field this means that it

165
00:06:51,650 --> 00:06:53,090
would get treated as a negative number

166
00:06:53,090 --> 00:06:54,890
by the Java let whilst rated as a very

167
00:06:54,890 --> 00:06:56,390
large positive number by the sea pasilla

168
00:06:56,390 --> 00:06:59,660
for you know for example let us say we

169
00:06:59,660 --> 00:07:02,450
place the value F F F D here and that

170
00:07:02,450 --> 00:07:04,460
means when it tries to locate the

171
00:07:04,460 --> 00:07:07,280
archived data the Java layer would treat

172
00:07:07,280 --> 00:07:09,440
it as negative 3 and instead of moving

173
00:07:09,440 --> 00:07:11,650
forward to locate you know the

174
00:07:11,650 --> 00:07:13,910
corresponding archive data it actually

175
00:07:13,910 --> 00:07:16,310
moves back three steps while the CC

176
00:07:16,310 --> 00:07:17,960
prefers component when it wants to

177
00:07:17,960 --> 00:07:19,670
extract the particular data would jump

178
00:07:19,670 --> 00:07:22,760
forward by approximately 64 K so if one

179
00:07:22,760 --> 00:07:25,880
locates a you know you know trusted APK

180
00:07:25,880 --> 00:07:28,550
that has a classic text that's less than

181
00:07:28,550 --> 00:07:31,940
64 kb in size you could exploit this

182
00:07:31,940 --> 00:07:33,950
vulnerability so what you could do is

183
00:07:33,950 --> 00:07:37,370
you could place the malicious classes

184
00:07:37,370 --> 00:07:41,000
dot txt pass the benign entry and you

185
00:07:41,000 --> 00:07:42,980
actually have to merge the first three

186
00:07:42,980 --> 00:07:45,620
bites of the classes dot text with the

187
00:07:45,620 --> 00:07:48,590
last three bites of the name of classes

188
00:07:48,590 --> 00:07:51,110
dot X because in order to account for

189
00:07:51,110 --> 00:07:53,270
the three bites that you are wrong you

190
00:07:53,270 --> 00:07:54,919
know that you're you have to account for

191
00:07:54,919 --> 00:07:57,590
that in that top so what you do is you

192
00:07:57,590 --> 00:07:59,330
take the original trusted a week a

193
00:07:59,330 --> 00:08:01,160
package it back with the stored method

194
00:08:01,160 --> 00:08:03,530
so that no real compression algorithm

195
00:08:03,530 --> 00:08:05,600
gets applied and you merge the three

196
00:08:05,600 --> 00:08:07,850
bites that is part of the file name as

197
00:08:07,850 --> 00:08:09,710
well as the first three bites of the

198
00:08:09,710 --> 00:08:12,350
magic header of the classes dot txt who

199
00:08:12,350 --> 00:08:16,370
so once this is done the what the Java

200
00:08:16,370 --> 00:08:18,800
layer would see is the benign entry and

201
00:08:18,800 --> 00:08:20,330
this is the one that gets validated and

202
00:08:20,330 --> 00:08:22,370
the sea pusses layer would see this

203
00:08:22,370 --> 00:08:24,680
particular the last entry of class or

204
00:08:24,680 --> 00:08:26,450
text and that's the one that actually

205
00:08:26,450 --> 00:08:28,790
gets loaded and the malicious clustered

206
00:08:28,790 --> 00:08:32,299
ex would get loaded onto system the next

207
00:08:32,299 --> 00:08:34,460
one Apple again is to do with how the

208
00:08:34,460 --> 00:08:36,349
both the implementation attempt to

209
00:08:36,349 --> 00:08:39,559
locate the archived data for example the

210
00:08:39,559 --> 00:08:42,890
Java layer in order located you know the

211
00:08:42,890 --> 00:08:44,870
archive data would pick the filename

212
00:08:44,870 --> 00:08:47,300
length that is cached from the central

213
00:08:47,300 --> 00:08:49,370
directory header while the local file

214
00:08:49,370 --> 00:08:51,470
header I mean for the extra data like it

215
00:08:51,470 --> 00:08:52,910
picks from the local file header

216
00:08:52,910 --> 00:08:56,210
while the CC purpose implementation pics

217
00:08:56,210 --> 00:08:58,670
both both the length from the send you

218
00:08:58,670 --> 00:09:00,950
know the local file header itself so

219
00:09:00,950 --> 00:09:02,690
this means that if you have two separate

220
00:09:02,690 --> 00:09:04,670
values from the central directory header

221
00:09:04,670 --> 00:09:06,950
and local file data for the file name

222
00:09:06,950 --> 00:09:08,660
length you could have both

223
00:09:08,660 --> 00:09:10,100
implementation see at two different

224
00:09:10,100 --> 00:09:12,560
locations for the you know archive data

225
00:09:12,560 --> 00:09:15,710
for the classic dot X so yet again with

226
00:09:15,710 --> 00:09:18,260
the you know if you find a small you

227
00:09:18,260 --> 00:09:20,420
know and trusted APK with a very small

228
00:09:20,420 --> 00:09:22,910
class decks that's around let's say 64

229
00:09:22,910 --> 00:09:26,000
kb in size you could place two separate

230
00:09:26,000 --> 00:09:28,400
values in you know the for the file name

231
00:09:28,400 --> 00:09:30,140
length field you can have the valid one

232
00:09:30,140 --> 00:09:32,080
within the send Rec director header and

233
00:09:32,080 --> 00:09:34,790
very dodgy are you specified within the

234
00:09:34,790 --> 00:09:38,060
local file header so the format or the

235
00:09:38,060 --> 00:09:40,730
layout of the crafted APK would be very

236
00:09:40,730 --> 00:09:42,740
similar to the previous vulnerability

237
00:09:42,740 --> 00:09:45,950
and the malicious APK is the one or the

238
00:09:45,950 --> 00:09:47,840
malicious class next is the one actually

239
00:09:47,840 --> 00:09:50,390
that gets finally extracted to disk now

240
00:09:50,390 --> 00:09:51,950
the details for this are you know

241
00:09:51,950 --> 00:09:53,690
slightly wrong in the paper I apologize

242
00:09:53,690 --> 00:09:58,190
for the mistake so moving on now the

243
00:09:58,190 --> 00:10:01,990
android OS to handle a particular APK

244
00:10:01,990 --> 00:10:04,910
uses only two out of you know possible

245
00:10:04,910 --> 00:10:06,920
65,000 fine and 36 compression methods

246
00:10:06,920 --> 00:10:11,150
and one being the store method were it

247
00:10:11,150 --> 00:10:13,700
actually puts the data inside the APK

248
00:10:13,700 --> 00:10:15,290
without applying any compression

249
00:10:15,290 --> 00:10:17,570
algorithm the other one the android OS

250
00:10:17,570 --> 00:10:21,020
supports is the popular deflate

251
00:10:21,020 --> 00:10:25,400
algorithm which has the value 8 so now

252
00:10:25,400 --> 00:10:27,380
the android OS make some assumptions

253
00:10:27,380 --> 00:10:29,060
when handling this compression method

254
00:10:29,060 --> 00:10:32,270
fields for android OS you know kit kat

255
00:10:32,270 --> 00:10:35,420
and above what it does is it checks if

256
00:10:35,420 --> 00:10:37,070
the particular compression method that

257
00:10:37,070 --> 00:10:38,810
specified within the APK archive is

258
00:10:38,810 --> 00:10:41,510
stored it assumes if it is not stored it

259
00:10:41,510 --> 00:10:43,670
assumes deflate while in earlier

260
00:10:43,670 --> 00:10:45,380
versions of Android jelly bean and Kit

261
00:10:45,380 --> 00:10:48,230
Kat sorry Ice Cream Sandwich you have a

262
00:10:48,230 --> 00:10:50,180
reversal of check within the Java layer

263
00:10:50,180 --> 00:10:52,220
who are it checks like the method if it

264
00:10:52,220 --> 00:10:54,230
is deflate if not it assumes stored

265
00:10:54,230 --> 00:10:56,240
while the CC plus an implementation has

266
00:10:56,240 --> 00:10:58,760
remained same so this means that you

267
00:10:58,760 --> 00:11:00,890
know they have actually tried to address

268
00:11:00,890 --> 00:11:02,780
this and be consistent in the newer

269
00:11:02,780 --> 00:11:04,730
version of the operating system however

270
00:11:04,730 --> 00:11:05,720
the awesome

271
00:11:05,720 --> 00:11:07,519
patients are still there that is the you

272
00:11:07,519 --> 00:11:08,300
know what are the different

273
00:11:08,300 --> 00:11:10,220
possibilities of compression method that

274
00:11:10,220 --> 00:11:12,230
is there so this kind of gives an

275
00:11:12,230 --> 00:11:14,449
opportunity for the militia a tracker to

276
00:11:14,449 --> 00:11:17,959
abuse these assumptions and you know we

277
00:11:17,959 --> 00:11:21,410
the security that may be in place now

278
00:11:21,410 --> 00:11:22,759
let us see how an anti-virus software

279
00:11:22,759 --> 00:11:26,240
typically handles a you know in a picket

280
00:11:26,240 --> 00:11:29,689
what they're the put generally more

281
00:11:29,689 --> 00:11:31,009
stricter checks when handling any

282
00:11:31,009 --> 00:11:32,720
particular file format this is usually

283
00:11:32,720 --> 00:11:35,959
done for performance and to handle any

284
00:11:35,959 --> 00:11:38,750
form of you know format abuse while a

285
00:11:38,750 --> 00:11:40,519
nun are coming application or in this

286
00:11:40,519 --> 00:11:43,490
case the android OS has more you know

287
00:11:43,490 --> 00:11:46,779
relaxed checks so if one place is a

288
00:11:46,779 --> 00:11:48,949
value in the compression method field

289
00:11:48,949 --> 00:11:50,810
other than stored or deflate there is

290
00:11:50,810 --> 00:11:53,540
other than 08 it would still get get

291
00:11:53,540 --> 00:11:55,639
treated as one of them by the android OS

292
00:11:55,639 --> 00:11:57,829
because of the assumptions it makes but

293
00:11:57,829 --> 00:12:00,740
the antivirus soft brick because it will

294
00:12:00,740 --> 00:12:02,389
if it is an unsupported compression

295
00:12:02,389 --> 00:12:04,939
method it would try to extract or it

296
00:12:04,939 --> 00:12:06,379
would just skip over the file and move

297
00:12:06,379 --> 00:12:08,750
on to the next file the supported method

298
00:12:08,750 --> 00:12:10,399
it would attempt to extract whatever

299
00:12:10,399 --> 00:12:12,529
data that is given based on the

300
00:12:12,529 --> 00:12:14,449
algorithm that specified which would not

301
00:12:14,449 --> 00:12:16,309
be compatible and it would break again

302
00:12:16,309 --> 00:12:20,620
so in order to test the effects of this

303
00:12:20,620 --> 00:12:22,610
manipulation of this compression method

304
00:12:22,610 --> 00:12:24,350
field we picked up you know potentially

305
00:12:24,350 --> 00:12:27,199
unwanted utility called droid chief it

306
00:12:27,199 --> 00:12:30,410
is a symbol like a hacking utility it up

307
00:12:30,410 --> 00:12:32,959
the reason one of the reason why we pick

308
00:12:32,959 --> 00:12:35,959
that was we notice that most of the AVS

309
00:12:35,959 --> 00:12:38,149
were detecting on closet decks with in

310
00:12:38,149 --> 00:12:40,579
this package and even when you resign it

311
00:12:40,579 --> 00:12:42,559
with the different sign up the detection

312
00:12:42,559 --> 00:12:45,050
was still there so we created two

313
00:12:45,050 --> 00:12:47,350
crafted apks to test the effects and

314
00:12:47,350 --> 00:12:50,779
these are the results the first one is a

315
00:12:50,779 --> 00:12:52,730
control test case to ensure that the AV

316
00:12:52,730 --> 00:12:54,769
detection was maintained even if you

317
00:12:54,769 --> 00:12:56,870
repackage with a different saina so as

318
00:12:56,870 --> 00:12:59,089
you can see the fe detection was minted

319
00:12:59,089 --> 00:13:03,050
and for android 4.3 and below and 4.4

320
00:13:03,050 --> 00:13:04,809
and we had to create two separate

321
00:13:04,809 --> 00:13:07,399
crafted apks because you have the

322
00:13:07,399 --> 00:13:09,170
reversal of checks within the java layer

323
00:13:09,170 --> 00:13:11,870
in the targeted OS where the

324
00:13:11,870 --> 00:13:14,179
installation was successful the av's

325
00:13:14,179 --> 00:13:16,490
failed to detect both during you know at

326
00:13:16,490 --> 00:13:17,779
the time of installation when we had the

327
00:13:17,779 --> 00:13:18,380
real

328
00:13:18,380 --> 00:13:20,570
a competent running as well as when we

329
00:13:20,570 --> 00:13:23,000
did an on-demand scan post insulation

330
00:13:23,000 --> 00:13:25,790
and so was the case with you know the

331
00:13:25,790 --> 00:13:28,490
new versions of the epic a targeting the

332
00:13:28,490 --> 00:13:32,000
newer versions as so the non-targeted OS

333
00:13:32,000 --> 00:13:34,430
because the it was not compatible with

334
00:13:34,430 --> 00:13:35,840
the checks made by the operating system

335
00:13:35,840 --> 00:13:39,860
the installation itself failed and so

336
00:13:39,860 --> 00:13:42,790
that was the results now let's see how

337
00:13:42,790 --> 00:13:46,220
this you know the these crafted apks was

338
00:13:46,220 --> 00:13:50,300
prepared so for the original APK by

339
00:13:50,300 --> 00:13:52,640
default the class adored x got

340
00:13:52,640 --> 00:13:54,590
compressed so that means that the

341
00:13:54,590 --> 00:13:57,050
deflate our algorithm kicks in so which

342
00:13:57,050 --> 00:13:58,940
has evaluate this is the field that we

343
00:13:58,940 --> 00:14:00,740
keep manipulating for the you know

344
00:14:00,740 --> 00:14:04,790
creating the crafted application so for

345
00:14:04,790 --> 00:14:07,610
the first crafted APK that is targeting

346
00:14:07,610 --> 00:14:11,390
android 4.4 and above you what we do is

347
00:14:11,390 --> 00:14:14,060
we change the compression method field

348
00:14:14,060 --> 00:14:16,700
to a value other than 0 or eight so we

349
00:14:16,700 --> 00:14:18,710
pick the next higher value that is from

350
00:14:18,710 --> 00:14:21,410
0 1 which stands actually for a strong

351
00:14:21,410 --> 00:14:24,050
method so we did the change in both in

352
00:14:24,050 --> 00:14:26,060
the central directory header as well as

353
00:14:26,060 --> 00:14:27,530
in the local file header to be

354
00:14:27,530 --> 00:14:29,630
consistent and just with these changes

355
00:14:29,630 --> 00:14:31,730
the APK still installed successfully in

356
00:14:31,730 --> 00:14:35,210
the android OS while the av's which we

357
00:14:35,210 --> 00:14:37,010
tested against which ad running in the

358
00:14:37,010 --> 00:14:38,870
background failed to install our failed

359
00:14:38,870 --> 00:14:40,910
to detect both during installation phase

360
00:14:40,910 --> 00:14:43,480
as well as when we did on demand scan

361
00:14:43,480 --> 00:14:49,940
for android OS prior to 4.3 and below it

362
00:14:49,940 --> 00:14:51,140
was a bit more challenging each

363
00:14:51,140 --> 00:14:53,780
construct and construct the APK because

364
00:14:53,780 --> 00:14:55,310
you have the reversal of checks between

365
00:14:55,310 --> 00:14:57,740
the sea purpose and the java components

366
00:14:57,740 --> 00:15:00,260
so what we did was we laid out all the

367
00:15:00,260 --> 00:15:02,630
files that needed to go into the APK

368
00:15:02,630 --> 00:15:05,500
except for the signing related files and

369
00:15:05,500 --> 00:15:08,150
the first step what we did was we pre

370
00:15:08,150 --> 00:15:10,160
compress the classes decks using a

371
00:15:10,160 --> 00:15:12,830
custom as you know custom return 0

372
00:15:12,830 --> 00:15:15,170
utility it skipped writing the headers

373
00:15:15,170 --> 00:15:17,120
in the compressed data so that it was

374
00:15:17,120 --> 00:15:19,730
compatible with the unzip function that

375
00:15:19,730 --> 00:15:22,220
was found in the c++ handling layer for

376
00:15:22,220 --> 00:15:24,590
the zip within the android OS so we

377
00:15:24,590 --> 00:15:27,470
replace the file within the directory

378
00:15:27,470 --> 00:15:29,660
layer and so the you know as you can see

379
00:15:29,660 --> 00:15:31,640
the file size came down

380
00:15:31,640 --> 00:15:34,430
next step what we did was we in our cave

381
00:15:34,430 --> 00:15:36,470
the whole directory using a standard

382
00:15:36,470 --> 00:15:40,070
zipping utility let's say win draw we

383
00:15:40,070 --> 00:15:42,380
stored we chose the store method so no

384
00:15:42,380 --> 00:15:44,360
real you know compression algorithm

385
00:15:44,360 --> 00:15:46,820
kicked it the files as such was stored

386
00:15:46,820 --> 00:15:49,400
in the arcade and we renamed it to dot

387
00:15:49,400 --> 00:15:51,530
apk and then ran it through through the

388
00:15:51,530 --> 00:15:54,620
jaw saina process what the jaw saina

389
00:15:54,620 --> 00:15:56,060
process does is it extracts each and

390
00:15:56,060 --> 00:15:58,160
every files within the APK our cave and

391
00:15:58,160 --> 00:16:01,430
calculates a sha-1 hash for it and it

392
00:16:01,430 --> 00:16:03,980
places that in into manifest or mf5 and

393
00:16:03,980 --> 00:16:05,900
signs it with whatever you know keys you

394
00:16:05,900 --> 00:16:10,850
provide so now it is it is important to

395
00:16:10,850 --> 00:16:12,890
keep in mind that the classics here is

396
00:16:12,890 --> 00:16:14,570
actually pre-compressed and water shower

397
00:16:14,570 --> 00:16:16,400
is calculated is for the pre compressed

398
00:16:16,400 --> 00:16:19,700
data and not for the final classes decks

399
00:16:19,700 --> 00:16:21,230
that actually would get loaded onto the

400
00:16:21,230 --> 00:16:25,790
system the next step was changing the

401
00:16:25,790 --> 00:16:28,880
headers the first step what we did again

402
00:16:28,880 --> 00:16:30,380
was you know change the compression

403
00:16:30,380 --> 00:16:31,940
method to value other and stored or

404
00:16:31,940 --> 00:16:34,220
deflate again we picked you know one

405
00:16:34,220 --> 00:16:36,380
standing for shrunk method then we

406
00:16:36,380 --> 00:16:39,110
change the uncompressed size to reflect

407
00:16:39,110 --> 00:16:40,550
the very original size of the class of

408
00:16:40,550 --> 00:16:44,030
decks that was above 80 kb this was

409
00:16:44,030 --> 00:16:45,740
because it was necessary because the sea

410
00:16:45,740 --> 00:16:48,110
purpose component actually desk check

411
00:16:48,110 --> 00:16:50,510
this you know the weather the file sizes

412
00:16:50,510 --> 00:16:52,850
matches at the very last step after

413
00:16:52,850 --> 00:16:55,520
during extraction so with just these

414
00:16:55,520 --> 00:16:57,920
changes the APK installed successfully

415
00:16:57,920 --> 00:17:00,260
on to the android OS so what happened

416
00:17:00,260 --> 00:17:02,840
underneath is the Java layer when it

417
00:17:02,840 --> 00:17:05,839
performs a validation would check the

418
00:17:05,839 --> 00:17:07,609
compression method against being deflate

419
00:17:07,609 --> 00:17:09,890
it sees its not so it assumes stored

420
00:17:09,890 --> 00:17:13,250
method and starts calculating the sha-1

421
00:17:13,250 --> 00:17:15,859
hash for we know the raw data and at

422
00:17:15,859 --> 00:17:17,300
this point it calculates a shaman for

423
00:17:17,300 --> 00:17:19,459
classes as well but it doesn't verify

424
00:17:19,459 --> 00:17:21,199
whether the file format that is within

425
00:17:21,199 --> 00:17:24,230
that a peek at that point is of dex

426
00:17:24,230 --> 00:17:26,780
format so as long as the sha-1 hash is

427
00:17:26,780 --> 00:17:29,840
checks out for the raw data the APK is

428
00:17:29,840 --> 00:17:33,770
assumed valid and then then moving on to

429
00:17:33,770 --> 00:17:36,020
when it goes to you know the CPU layer

430
00:17:36,020 --> 00:17:39,020
for installation it has the reverse

431
00:17:39,020 --> 00:17:41,030
check were checks the compression method

432
00:17:41,030 --> 00:17:44,540
against being stored it ceases not so it

433
00:17:44,540 --> 00:17:45,440
assumes deflate

434
00:17:45,440 --> 00:17:47,600
which is correct and once it is able to

435
00:17:47,600 --> 00:17:49,490
decompress the data and it combines the

436
00:17:49,490 --> 00:17:52,580
file size and that two checks out and so

437
00:17:52,580 --> 00:17:55,250
the package installed successfully on to

438
00:17:55,250 --> 00:17:57,409
the android OS it again from as you can

439
00:17:57,409 --> 00:17:59,659
as you have seen from the results the

440
00:17:59,659 --> 00:18:01,100
av's which we are running in the

441
00:18:01,100 --> 00:18:04,159
background failed to detect during you

442
00:18:04,159 --> 00:18:05,480
know both the installation phase and

443
00:18:05,480 --> 00:18:08,659
when we did an on-demand scan so as a

444
00:18:08,659 --> 00:18:10,580
mitigation step even though we do not

445
00:18:10,580 --> 00:18:13,490
consider this as a vulnerability of the

446
00:18:13,490 --> 00:18:15,740
android OS we do believe that most

447
00:18:15,740 --> 00:18:17,809
richter checks need to be placed as part

448
00:18:17,809 --> 00:18:20,090
of you know the android OS code so that

449
00:18:20,090 --> 00:18:22,909
they don't allow installation of such

450
00:18:22,909 --> 00:18:25,129
crafted apks because it just lowers the

451
00:18:25,129 --> 00:18:26,870
overall security of the android

452
00:18:26,870 --> 00:18:31,220
ecosystem as far as you know the other

453
00:18:31,220 --> 00:18:32,750
thing I want to just stress before the

454
00:18:32,750 --> 00:18:35,000
next point is that we have to

455
00:18:35,000 --> 00:18:36,950
implementation of see proces in and Java

456
00:18:36,950 --> 00:18:39,440
that is handling the APK file format so

457
00:18:39,440 --> 00:18:42,169
that always increases the risk of you

458
00:18:42,169 --> 00:18:43,940
know you have difference in code or the

459
00:18:43,940 --> 00:18:46,129
difference in logic which may bring up

460
00:18:46,129 --> 00:18:48,019
you know similar cryptographic

461
00:18:48,019 --> 00:18:50,750
verification process by past as well so

462
00:18:50,750 --> 00:18:53,470
as for the antivirus vendors who are

463
00:18:53,470 --> 00:18:55,940
potentially the most affected by crafted

464
00:18:55,940 --> 00:18:59,029
apks we have a few suggestions oneness

465
00:18:59,029 --> 00:19:02,090
to curiosity click flag any apk that as

466
00:19:02,090 --> 00:19:04,070
an unsupported compression type because

467
00:19:04,070 --> 00:19:06,529
it is a clear indicator of the apk

468
00:19:06,529 --> 00:19:09,309
package being crafted the other

469
00:19:09,309 --> 00:19:11,299
suggestion which we actually do not

470
00:19:11,299 --> 00:19:13,250
recommend is to actually emulate the

471
00:19:13,250 --> 00:19:14,990
behavior of the android OS in which you

472
00:19:14,990 --> 00:19:17,360
are currently installed in it obviously

473
00:19:17,360 --> 00:19:19,070
increases the queue and the development

474
00:19:19,070 --> 00:19:22,929
effort so no recommendation for that as

475
00:19:22,929 --> 00:19:26,809
moving out to the chameleon zip now the

476
00:19:26,809 --> 00:19:29,419
zip file format has turned into a very

477
00:19:29,419 --> 00:19:31,759
versatile convenient packaging format

478
00:19:31,759 --> 00:19:34,309
for a variety of applications we have

479
00:19:34,309 --> 00:19:37,190
already seen it you know as used as part

480
00:19:37,190 --> 00:19:39,620
of android packages and obviously it's

481
00:19:39,620 --> 00:19:42,429
you know being used for Tizen as well

482
00:19:42,429 --> 00:19:44,840
and now the other formats it comes in

483
00:19:44,840 --> 00:19:47,090
the package format which comes up is in

484
00:19:47,090 --> 00:19:50,899
Java archives and you know you have it

485
00:19:50,899 --> 00:19:53,659
in various document formats as you know

486
00:19:53,659 --> 00:19:55,070
with docx and

487
00:19:55,070 --> 00:19:57,289
Metro apps with our you know a PEC

488
00:19:57,289 --> 00:20:00,889
extension as well so this this has

489
00:20:00,889 --> 00:20:02,750
created new challenges for the AV

490
00:20:02,750 --> 00:20:04,309
windows in order to recognize the

491
00:20:04,309 --> 00:20:06,740
correct package type to do context level

492
00:20:06,740 --> 00:20:08,600
passing just based on the continent you

493
00:20:08,600 --> 00:20:10,519
know if you don't account for the

494
00:20:10,519 --> 00:20:13,279
extension also if you have any

495
00:20:13,279 --> 00:20:15,409
automation systems in the back end that

496
00:20:15,409 --> 00:20:17,360
wants to evaluate behavior of a

497
00:20:17,360 --> 00:20:19,970
particular file or a package based on

498
00:20:19,970 --> 00:20:21,799
the you know the type of package it is

499
00:20:21,799 --> 00:20:24,549
there is new challenges there as well so

500
00:20:24,549 --> 00:20:27,889
what what a package type of analyzing

501
00:20:27,889 --> 00:20:29,720
component typically does it looks for

502
00:20:29,720 --> 00:20:32,269
specific files at specific locations in

503
00:20:32,269 --> 00:20:33,950
order to recognize a particular package

504
00:20:33,950 --> 00:20:36,440
type for JA you have the signing related

505
00:20:36,440 --> 00:20:38,179
information under the meta-inf directory

506
00:20:38,179 --> 00:20:39,889
and you have you know one or more class

507
00:20:39,889 --> 00:20:42,830
files in the root for the APK you have

508
00:20:42,830 --> 00:20:44,539
similar signing related information as

509
00:20:44,539 --> 00:20:46,460
well as the android specific files such

510
00:20:46,460 --> 00:20:48,889
as the android manifest and cross don

511
00:20:48,889 --> 00:20:51,350
text for docx you have the content types

512
00:20:51,350 --> 00:20:53,750
as well you know other files that are

513
00:20:53,750 --> 00:20:55,909
related to the document for metro apps

514
00:20:55,909 --> 00:20:57,950
that is epic extension it has its own

515
00:20:57,950 --> 00:21:00,740
manifest file as well as you know were

516
00:21:00,740 --> 00:21:03,350
the ones that holds the hashes for the

517
00:21:03,350 --> 00:21:06,200
various files within the package no no

518
00:21:06,200 --> 00:21:08,779
if you combine all the files that are in

519
00:21:08,779 --> 00:21:10,850
all these various packages into a single

520
00:21:10,850 --> 00:21:14,299
directory you know you could actually

521
00:21:14,299 --> 00:21:16,610
create a single package that could be

522
00:21:16,610 --> 00:21:20,450
treated as all these ones so as you can

523
00:21:20,450 --> 00:21:22,190
see in the directory you can you have

524
00:21:22,190 --> 00:21:24,470
the docx file jar file you know all with

525
00:21:24,470 --> 00:21:27,049
various types together we are given the

526
00:21:27,049 --> 00:21:29,269
you know this amalgamated package the

527
00:21:29,269 --> 00:21:32,809
sobriquet chameleons if so what we did

528
00:21:32,809 --> 00:21:34,970
we just package everything in using a

529
00:21:34,970 --> 00:21:38,960
standard archiving utility and we tested

530
00:21:38,960 --> 00:21:40,639
it out against the various are entering

531
00:21:40,639 --> 00:21:43,879
utilities so what we observed was a

532
00:21:43,879 --> 00:21:48,320
valid APK is also valid jar file because

533
00:21:48,320 --> 00:21:50,059
both of them follow the same underlying

534
00:21:50,059 --> 00:21:53,509
you know verification process so as long

535
00:21:53,509 --> 00:21:56,899
as the hash is for the files which it

536
00:21:56,899 --> 00:21:59,090
doesn't know about like and java archive

537
00:21:59,090 --> 00:22:00,889
wouldn't know about the android manifest

538
00:22:00,889 --> 00:22:02,899
file but as long as the hashes were

539
00:22:02,899 --> 00:22:04,669
present in the manifest at MF it does

540
00:22:04,669 --> 00:22:05,350
not matter

541
00:22:05,350 --> 00:22:07,539
just regular data foil for the you know

542
00:22:07,539 --> 00:22:09,910
for the respective applications so it

543
00:22:09,910 --> 00:22:12,190
installed successfully in the android OS

544
00:22:12,190 --> 00:22:15,160
and the when we invented to dodge jar it

545
00:22:15,160 --> 00:22:16,150
loaded successfully in the Java

546
00:22:16,150 --> 00:22:18,669
environment as for the docx file when we

547
00:22:18,669 --> 00:22:20,350
rename the package is doc Ock's and try

548
00:22:20,350 --> 00:22:21,850
to open in Microsoft Word it throw an

549
00:22:21,850 --> 00:22:25,059
error that the package was corrupted

550
00:22:25,059 --> 00:22:27,280
what we you know notice was even the

551
00:22:27,280 --> 00:22:29,980
presence of a unaccounted file within

552
00:22:29,980 --> 00:22:31,960
the doc Ock's package was enough to

553
00:22:31,960 --> 00:22:34,419
throw off you know the microsoft words

554
00:22:34,419 --> 00:22:37,480
you know like the integrity check for

555
00:22:37,480 --> 00:22:40,270
for the doc expel phase however when we

556
00:22:40,270 --> 00:22:43,360
try to open it with in OpenOffice it

557
00:22:43,360 --> 00:22:45,220
open successfully display the content

558
00:22:45,220 --> 00:22:47,710
and without any you know visible errors

559
00:22:47,710 --> 00:22:51,549
or warnings as for Metro apps it has a

560
00:22:51,549 --> 00:22:53,470
similar requirement that it should also

561
00:22:53,470 --> 00:22:55,900
be validated prior to being installed so

562
00:22:55,900 --> 00:23:00,640
this means that creating a valid apk and

563
00:23:00,640 --> 00:23:02,350
a valid epic simultaneous having as a

564
00:23:02,350 --> 00:23:04,510
package which is both valid may not be

565
00:23:04,510 --> 00:23:07,059
feasible because it requires updating

566
00:23:07,059 --> 00:23:10,059
two separate files with these you know

567
00:23:10,059 --> 00:23:11,980
hashes for all the files within the

568
00:23:11,980 --> 00:23:14,919
package so changing one file which holds

569
00:23:14,919 --> 00:23:17,049
the hashes would affect the other so it

570
00:23:17,049 --> 00:23:20,080
may not be feasible to create both both

571
00:23:20,080 --> 00:23:22,870
valid packages at the same time however

572
00:23:22,870 --> 00:23:24,880
the presence of the files that awful

573
00:23:24,880 --> 00:23:26,890
it's a in apex with the package might be

574
00:23:26,890 --> 00:23:28,780
enough to throw off a package type

575
00:23:28,780 --> 00:23:34,870
analyzing component for concluding so as

576
00:23:34,870 --> 00:23:37,059
you I mean zip file always has been very

577
00:23:37,059 --> 00:23:40,000
flexible format and so it has always

578
00:23:40,000 --> 00:23:43,809
been abused a antivirus vendors are all

579
00:23:43,809 --> 00:23:45,850
too familiar with you know gateway

580
00:23:45,850 --> 00:23:48,610
bypass using crafted archive file

581
00:23:48,610 --> 00:23:50,799
formats so we can we expect the trend to

582
00:23:50,799 --> 00:23:54,190
continue as far as the crafted AP case

583
00:23:54,190 --> 00:23:57,760
is concerned we had tested out with you

584
00:23:57,760 --> 00:23:59,980
know few antivirus products we found

585
00:23:59,980 --> 00:24:02,559
that both their Android versions or

586
00:24:02,559 --> 00:24:04,270
Android products and the windows engines

587
00:24:04,270 --> 00:24:06,850
were equally affected we had reported

588
00:24:06,850 --> 00:24:09,610
this issue to the you know the vendors

589
00:24:09,610 --> 00:24:11,559
whom we checked against some of them

590
00:24:11,559 --> 00:24:14,320
responded acknowledged and promised to

591
00:24:14,320 --> 00:24:16,450
fix the issue by the way we had case and

592
00:24:16,450 --> 00:24:18,170
I rolled out the fix as well

593
00:24:18,170 --> 00:24:20,850
those vendors who haven't responded we

594
00:24:20,850 --> 00:24:23,100
hope that they take it up and address it

595
00:24:23,100 --> 00:24:25,800
from their side there's some effort

596
00:24:25,800 --> 00:24:27,720
going on on the I through bill tagging

597
00:24:27,720 --> 00:24:30,390
friend to validate the top top level apk

598
00:24:30,390 --> 00:24:32,940
and not just the contents inside so it

599
00:24:32,940 --> 00:24:34,470
is being actively discussed and we are

600
00:24:34,470 --> 00:24:37,470
looking forward to that as well as for

601
00:24:37,470 --> 00:24:39,960
the chameleons if we were unable to test

602
00:24:39,960 --> 00:24:42,150
the effects of the package on the

603
00:24:42,150 --> 00:24:44,400
automation system we live it up to the

604
00:24:44,400 --> 00:24:46,500
vendors to evaluate the internal systems

605
00:24:46,500 --> 00:24:49,020
to see you know how it treats these

606
00:24:49,020 --> 00:24:52,020
packages with that I is if myself to

607
00:24:52,020 --> 00:24:57,470
thank you any question okay

