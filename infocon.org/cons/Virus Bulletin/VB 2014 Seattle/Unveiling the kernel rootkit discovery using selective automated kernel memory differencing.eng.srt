1
00:00:00,000 --> 00:00:01,770
i right ladies and gentlemen this brings

2
00:00:01,770 --> 00:00:05,279
us to the last last talk that's not a

3
00:00:05,279 --> 00:00:08,490
panel for the entire conference so

4
00:00:08,490 --> 00:00:10,290
without any more ado I leave you in the

5
00:00:10,290 --> 00:00:11,910
capable hands of our meds a key and

6
00:00:11,910 --> 00:00:13,740
Benjamin Humphrey it will tell us about

7
00:00:13,740 --> 00:00:15,809
selective automated kernel memory

8
00:00:15,809 --> 00:00:18,000
differencing which sounds technical so

9
00:00:18,000 --> 00:00:21,539
gentlemen over deal okay hello everyone

10
00:00:21,539 --> 00:00:24,630
my colleague is amazake he's a senior

11
00:00:24,630 --> 00:00:26,880
threat research at softball slide UK my

12
00:00:26,880 --> 00:00:28,680
name is Benjamin Humphrey and I am a

13
00:00:28,680 --> 00:00:30,630
threat researcher at sophos labs UK and

14
00:00:30,630 --> 00:00:32,790
this is unveiling the colonel rootkit

15
00:00:32,790 --> 00:00:34,469
discovery using selective automated

16
00:00:34,469 --> 00:00:36,480
kernel memory differencing and so we're

17
00:00:36,480 --> 00:00:38,219
basically trying to define a method of

18
00:00:38,219 --> 00:00:40,230
automating the discovery and analysis of

19
00:00:40,230 --> 00:00:43,260
kernel-mode rootkits so we'll go through

20
00:00:43,260 --> 00:00:45,270
the agenda first we'll go through the

21
00:00:45,270 --> 00:00:47,160
objective and the method so what we're

22
00:00:47,160 --> 00:00:48,780
trying to achieve and how we're going to

23
00:00:48,780 --> 00:00:50,309
try and achieve it will go through the

24
00:00:50,309 --> 00:00:52,320
system design and implementation so we

25
00:00:52,320 --> 00:00:53,940
look at how we're going to run drivers

26
00:00:53,940 --> 00:00:56,039
what kind of data we're going to extract

27
00:00:56,039 --> 00:00:57,539
from the colonel what we're going to do

28
00:00:57,539 --> 00:00:58,920
with that data and then how we're going

29
00:00:58,920 --> 00:01:00,840
to report it and then we'll go through a

30
00:01:00,840 --> 00:01:02,699
number of experiments and so we've run a

31
00:01:02,699 --> 00:01:04,379
number of high-profile rootkits through

32
00:01:04,379 --> 00:01:05,909
the system see what kind of data we can

33
00:01:05,909 --> 00:01:08,700
get back we've run a number of clean and

34
00:01:08,700 --> 00:01:10,229
malicious driver files through the

35
00:01:10,229 --> 00:01:11,820
system in order to see if we can

36
00:01:11,820 --> 00:01:14,189
attribute any level of maliciousness to

37
00:01:14,189 --> 00:01:16,680
specific colonel modifications and then

38
00:01:16,680 --> 00:01:18,360
we've run a random set of peace files

39
00:01:18,360 --> 00:01:19,650
through the system and see what data we

40
00:01:19,650 --> 00:01:21,479
can get back there will then conclude

41
00:01:21,479 --> 00:01:25,439
and start looking at future work so what

42
00:01:25,439 --> 00:01:27,000
we actually trying to achieve here well

43
00:01:27,000 --> 00:01:29,310
we know rootkits are bad and we know

44
00:01:29,310 --> 00:01:31,409
they're pretty hard to find and our lab

45
00:01:31,409 --> 00:01:32,939
gets a lot of samples every day you know

46
00:01:32,939 --> 00:01:35,640
approximately 300,000 so we need to find

47
00:01:35,640 --> 00:01:39,119
some way of weeding out the potential

48
00:01:39,119 --> 00:01:41,040
samples I could exhibit any kind of

49
00:01:41,040 --> 00:01:43,380
Colonel Lloyd behavior ideally would

50
00:01:43,380 --> 00:01:44,970
like to list the modifications that

51
00:01:44,970 --> 00:01:46,290
these samples are actually made to the

52
00:01:46,290 --> 00:01:48,570
colonel and then if we can identify the

53
00:01:48,570 --> 00:01:49,920
maliciousness of these specific

54
00:01:49,920 --> 00:01:51,899
modifications and then it would be quite

55
00:01:51,899 --> 00:01:53,759
good if we could import that data into

56
00:01:53,759 --> 00:01:56,100
other systems in order to leverage it in

57
00:01:56,100 --> 00:01:59,460
some way so how are we actually going to

58
00:01:59,460 --> 00:02:01,770
automate this process well we could use

59
00:02:01,770 --> 00:02:04,229
existing tools but we haven't really

60
00:02:04,229 --> 00:02:05,159
found anything out there that

61
00:02:05,159 --> 00:02:08,250
specifically looks at rootkits so we

62
00:02:08,250 --> 00:02:10,139
need to build our own system now we

63
00:02:10,139 --> 00:02:11,730
could automate this using existing

64
00:02:11,730 --> 00:02:12,700
anti-rootkit to

65
00:02:12,700 --> 00:02:14,349
but there's a number of problems there

66
00:02:14,349 --> 00:02:16,840
for one we can't control the format of

67
00:02:16,840 --> 00:02:18,489
the log files they come out so you know

68
00:02:18,489 --> 00:02:19,870
lots of different log files lots of

69
00:02:19,870 --> 00:02:21,069
different passing that could be a

70
00:02:21,069 --> 00:02:23,560
problem they can be relatively tricky to

71
00:02:23,560 --> 00:02:25,900
automate not all of them have a nice

72
00:02:25,900 --> 00:02:29,290
command line option but more importantly

73
00:02:29,290 --> 00:02:30,970
we can't control what areas of the

74
00:02:30,970 --> 00:02:32,470
colonel they're actually looking at and

75
00:02:32,470 --> 00:02:34,420
how they do that so if some new rootkit

76
00:02:34,420 --> 00:02:35,860
technique comes up you know we can't

77
00:02:35,860 --> 00:02:38,170
modify these applications in order to

78
00:02:38,170 --> 00:02:40,660
deal with this new bar new technique so

79
00:02:40,660 --> 00:02:42,610
we've decided to go with our own custom

80
00:02:42,610 --> 00:02:44,319
solution and basically what we're going

81
00:02:44,319 --> 00:02:46,900
to do is snap shot specific areas of the

82
00:02:46,900 --> 00:02:49,660
colonel and then we can run our sample

83
00:02:49,660 --> 00:02:51,489
through it snapshot it again and then we

84
00:02:51,489 --> 00:02:53,500
can do a diff and see exactly what

85
00:02:53,500 --> 00:02:55,900
modifications have been made so now you

86
00:02:55,900 --> 00:02:58,209
know roughly what we're trying to do and

87
00:02:58,209 --> 00:02:59,590
how we want to do it I'll pass you over

88
00:02:59,590 --> 00:03:01,299
to Albert who will explain that in a bit

89
00:03:01,299 --> 00:03:05,319
more detail thanks Ben hello yeah so you

90
00:03:05,319 --> 00:03:11,049
can hear me so as I mentioned we wanted

91
00:03:11,049 --> 00:03:13,450
a quick way to Swift through hundreds of

92
00:03:13,450 --> 00:03:16,630
thousands of samples every day and be

93
00:03:16,630 --> 00:03:19,109
able to identify in a quick fashion

94
00:03:19,109 --> 00:03:24,220
potential rootkit activity and we didn't

95
00:03:24,220 --> 00:03:26,950
want to really reinvent the wheel so we

96
00:03:26,950 --> 00:03:28,750
looked at what's what dynamic systems

97
00:03:28,750 --> 00:03:30,340
were out there that we can use for our

98
00:03:30,340 --> 00:03:34,989
purposes and basically design on them or

99
00:03:34,989 --> 00:03:37,870
build on them what we want to do the

100
00:03:37,870 --> 00:03:40,840
obvious target was obviously coo coo i'm

101
00:03:40,840 --> 00:03:42,430
sure many of you sitting here usually

102
00:03:42,430 --> 00:03:44,739
before and very familiar with it but

103
00:03:44,739 --> 00:03:47,709
yeah it's an open source dynamic canal

104
00:03:47,709 --> 00:03:52,090
system written mainly in python the win

105
00:03:52,090 --> 00:03:56,250
for us highly modular double win it's

106
00:03:56,250 --> 00:03:58,959
used by there's a large community behind

107
00:03:58,959 --> 00:04:02,200
it which is awesome for us as well so so

108
00:04:02,200 --> 00:04:03,280
we thought yeah we're going to use

109
00:04:03,280 --> 00:04:06,400
cuckoo and we're going to customize it

110
00:04:06,400 --> 00:04:10,510
for our purposes we use in our in our

111
00:04:10,510 --> 00:04:13,419
tests and in the back of this system we

112
00:04:13,419 --> 00:04:15,989
used an ubuntu OS as the host of us and

113
00:04:15,989 --> 00:04:22,210
the guest VM was windows 7 x86 sp1 vm in

114
00:04:22,210 --> 00:04:25,080
a virtual box environment we had to

115
00:04:25,080 --> 00:04:27,689
our system to a maximum of four minutes

116
00:04:27,689 --> 00:04:30,599
per job because if we want to go through

117
00:04:30,599 --> 00:04:32,520
hundreds of thousands of samples we

118
00:04:32,520 --> 00:04:34,710
really need to be quick and we need to

119
00:04:34,710 --> 00:04:37,020
be able to identify what we want quickly

120
00:04:37,020 --> 00:04:42,210
as well per sample execution inside the

121
00:04:42,210 --> 00:04:46,409
vm we take around 120 seconds we start

122
00:04:46,409 --> 00:04:49,169
the scanning 105 seconds inside after

123
00:04:49,169 --> 00:04:51,210
sample execution quickly a bird's-eye

124
00:04:51,210 --> 00:04:53,939
view what we're doing here what modules

125
00:04:53,939 --> 00:04:56,400
are all speaking ku ku terminology so

126
00:04:56,400 --> 00:04:57,690
I'm sure many of you will know what I'm

127
00:04:57,690 --> 00:05:00,629
talking about we build an auxiliary

128
00:05:00,629 --> 00:05:02,280
module sitting on the host in order to

129
00:05:02,280 --> 00:05:06,360
pull down the internal data that our

130
00:05:06,360 --> 00:05:07,889
engine sitting inside the guest VM is

131
00:05:07,889 --> 00:05:09,900
going to use in order to dump the

132
00:05:09,900 --> 00:05:12,810
essential information that we want and

133
00:05:12,810 --> 00:05:15,060
then inside the guest OS will have an

134
00:05:15,060 --> 00:05:17,639
analysis package basically a python

135
00:05:17,639 --> 00:05:20,669
script to run driver files because that

136
00:05:20,669 --> 00:05:22,289
doesn't by default come with cuckoo so

137
00:05:22,289 --> 00:05:24,210
we had to write that and we needed an

138
00:05:24,210 --> 00:05:26,490
analysis package in order to baseline in

139
00:05:26,490 --> 00:05:29,460
the system basically give us no

140
00:05:29,460 --> 00:05:31,680
operation job i'm going to talk more

141
00:05:31,680 --> 00:05:35,190
about that later and then we have an

142
00:05:35,190 --> 00:05:37,199
auxiliary modules inside the guest VM to

143
00:05:37,199 --> 00:05:39,509
instrument our Sophos antivirus engine

144
00:05:39,509 --> 00:05:43,440
and on the host s we grab that data we

145
00:05:43,440 --> 00:05:45,719
dip it in the processing module goes

146
00:05:45,719 --> 00:05:47,550
through a set of cuckoo signatures and

147
00:05:47,550 --> 00:05:50,460
finally some nice Django templates to

148
00:05:50,460 --> 00:05:56,789
expose this information so jumping

149
00:05:56,789 --> 00:05:59,839
inside the guest VM will have a driver

150
00:05:59,839 --> 00:06:03,779
analysis package basically cuckoo checks

151
00:06:03,779 --> 00:06:07,560
the P header identifies what the if it's

152
00:06:07,560 --> 00:06:09,210
a native subsystem then we know it's

153
00:06:09,210 --> 00:06:12,509
possibly a driver then we use that

154
00:06:12,509 --> 00:06:14,250
script inside the guest VM in order to

155
00:06:14,250 --> 00:06:18,389
run the driver file as very

156
00:06:18,389 --> 00:06:20,969
straightforward really used service

157
00:06:20,969 --> 00:06:22,650
control manager in order to create a

158
00:06:22,650 --> 00:06:25,710
service after we create the service we

159
00:06:25,710 --> 00:06:27,900
use antelope driver by default in order

160
00:06:27,900 --> 00:06:31,469
to run the driver you can specify so by

161
00:06:31,469 --> 00:06:33,990
default coo coo gives you the option to

162
00:06:33,990 --> 00:06:36,690
specify up the options for the analysis

163
00:06:36,690 --> 00:06:38,220
package so

164
00:06:38,220 --> 00:06:40,530
all the options we exposed in this

165
00:06:40,530 --> 00:06:42,690
module were basically the service name

166
00:06:42,690 --> 00:06:44,220
you can specify what service you want to

167
00:06:44,220 --> 00:06:45,690
use what's everything you want to use

168
00:06:45,690 --> 00:06:47,550
the start type of the service the

169
00:06:47,550 --> 00:06:50,670
service type and the load mode here is

170
00:06:50,670 --> 00:06:53,040
something so you can brute force you can

171
00:06:53,040 --> 00:06:55,170
use antelope driver and if it doesn't

172
00:06:55,170 --> 00:06:56,490
work try the service control manager

173
00:06:56,490 --> 00:06:58,860
start the service itself or you can use

174
00:06:58,860 --> 00:07:01,740
one of them or yeah that's that's

175
00:07:01,740 --> 00:07:05,520
basically it now I'm going to hand you

176
00:07:05,520 --> 00:07:07,320
over to Ben's once we run the sample

177
00:07:07,320 --> 00:07:08,850
itself now it's time to get this

178
00:07:08,850 --> 00:07:12,690
information okay so in order to extract

179
00:07:12,690 --> 00:07:14,130
the data from the colonel we are using

180
00:07:14,130 --> 00:07:16,860
our own software santa virus engine we

181
00:07:16,860 --> 00:07:18,390
toyed with the idea of writing their own

182
00:07:18,390 --> 00:07:20,220
custom solution for it but you know this

183
00:07:20,220 --> 00:07:22,140
requires a lot of resources and you know

184
00:07:22,140 --> 00:07:23,670
but we don't have much time you know

185
00:07:23,670 --> 00:07:25,140
being the busy analysts that we are and

186
00:07:25,140 --> 00:07:27,000
stuff like that so and with the sad

187
00:07:27,000 --> 00:07:29,160
engine what we get is this existing

188
00:07:29,160 --> 00:07:31,320
presence in the kernel we get the

189
00:07:31,320 --> 00:07:33,630
ability to examine and dump areas of

190
00:07:33,630 --> 00:07:35,430
kernel memory and we also get the

191
00:07:35,430 --> 00:07:36,900
ability to write to a log file so that's

192
00:07:36,900 --> 00:07:39,210
everything we need it's worth noting

193
00:07:39,210 --> 00:07:41,040
that this is a kind of modular design so

194
00:07:41,040 --> 00:07:42,780
if at some point we find some limitation

195
00:07:42,780 --> 00:07:44,130
with our engine you know something we

196
00:07:44,130 --> 00:07:45,960
can't access but any reason at all we

197
00:07:45,960 --> 00:07:47,550
could write our own system and we can

198
00:07:47,550 --> 00:07:49,140
plug it straight in there and as long as

199
00:07:49,140 --> 00:07:50,910
it spits the data right in the way that

200
00:07:50,910 --> 00:07:52,350
we need you know everything will work

201
00:07:52,350 --> 00:07:56,070
just fine so what do we actually want to

202
00:07:56,070 --> 00:07:58,050
look at okay so the first thing we want

203
00:07:58,050 --> 00:07:59,400
to look at drivers specifically the

204
00:07:59,400 --> 00:08:01,080
driver object you know every rootkit is

205
00:08:01,080 --> 00:08:03,419
basically done a big in life as a driver

206
00:08:03,419 --> 00:08:05,460
so this is an obvious one we want to

207
00:08:05,460 --> 00:08:06,750
have a look in the module list so you

208
00:08:06,750 --> 00:08:08,430
know changes to the module list whether

209
00:08:08,430 --> 00:08:09,840
you know something's been deleted or

210
00:08:09,840 --> 00:08:11,940
maybe it's been added possibly it's been

211
00:08:11,940 --> 00:08:13,080
modified you know this could be

212
00:08:13,080 --> 00:08:14,729
indicative of a rootkit like behavior

213
00:08:14,729 --> 00:08:17,790
the SS DT is another obvious one so you

214
00:08:17,790 --> 00:08:19,440
know have there been any SS DT hooks

215
00:08:19,440 --> 00:08:21,090
it's something trying to hide a file

216
00:08:21,090 --> 00:08:22,380
somehow or is it trying to hide a

217
00:08:22,380 --> 00:08:23,729
process you know this is good

218
00:08:23,729 --> 00:08:27,210
information for us the IDT so has a new

219
00:08:27,210 --> 00:08:30,510
interrupt being added you know and it to

220
00:08:30,510 --> 00:08:31,830
call in interrupt there's only two bites

221
00:08:31,830 --> 00:08:33,089
you know so if you want to save space in

222
00:08:33,089 --> 00:08:34,919
your hook then you may may use

223
00:08:34,919 --> 00:08:37,559
interrupts callbacks is another good one

224
00:08:37,559 --> 00:08:39,360
so this is operating system defined

225
00:08:39,360 --> 00:08:40,860
functions but you know we found that

226
00:08:40,860 --> 00:08:42,570
rootkit writers like to use callbacks

227
00:08:42,570 --> 00:08:44,700
because you know they can you know for

228
00:08:44,700 --> 00:08:47,100
firing event when a new process has been

229
00:08:47,100 --> 00:08:48,959
added or maybe you've modified the

230
00:08:48,959 --> 00:08:50,880
registry or something like that and

231
00:08:50,880 --> 00:08:52,150
finally we want to look at

232
00:08:52,150 --> 00:08:54,010
information so you know has the MDR

233
00:08:54,010 --> 00:08:55,960
changed has the partition table change

234
00:08:55,960 --> 00:08:58,210
you know has the vbi change in order to

235
00:08:58,210 --> 00:09:00,220
find boot kits and stuff like that so

236
00:09:00,220 --> 00:09:02,950
now you know what we want to find a much

237
00:09:02,950 --> 00:09:04,180
going to tell you what we're going to do

238
00:09:04,180 --> 00:09:08,770
with the data so once we get this

239
00:09:08,770 --> 00:09:11,380
information dumped in JSON format this

240
00:09:11,380 --> 00:09:13,120
gets sent back by the auxiliary module

241
00:09:13,120 --> 00:09:15,100
settings are the guest VM to the

242
00:09:15,100 --> 00:09:17,620
processing module on the host the host

243
00:09:17,620 --> 00:09:20,230
machine the processing module is then

244
00:09:20,230 --> 00:09:21,850
going to be responsible for identifying

245
00:09:21,850 --> 00:09:24,820
the base log to use two diff against our

246
00:09:24,820 --> 00:09:28,390
benchmark when is when we set up the

247
00:09:28,390 --> 00:09:30,940
system we set it up so that purse

248
00:09:30,940 --> 00:09:32,620
snatched shot you have us you have a

249
00:09:32,620 --> 00:09:35,470
specific baseline log the baseline log

250
00:09:35,470 --> 00:09:38,770
gets instantiated by using the analysis

251
00:09:38,770 --> 00:09:41,260
package of no operation as in we don't

252
00:09:41,260 --> 00:09:43,720
sent the sample inside the guest VM to

253
00:09:43,720 --> 00:09:46,810
run we just run a no operation job grab

254
00:09:46,810 --> 00:09:48,580
all the data that we want and we tie you

255
00:09:48,580 --> 00:09:50,470
to a specific unique identifier /

256
00:09:50,470 --> 00:09:52,950
snapshot so you can have single machine

257
00:09:52,950 --> 00:09:56,320
6 snapshots sickness six different

258
00:09:56,320 --> 00:09:59,260
baselines this is obviously in order to

259
00:09:59,260 --> 00:10:03,760
avoid the SLR noise so yeah once once

260
00:10:03,760 --> 00:10:05,320
this information comes back from the

261
00:10:05,320 --> 00:10:07,690
sample analysis log then we're going to

262
00:10:07,690 --> 00:10:10,210
dip it we identify what's added what's

263
00:10:10,210 --> 00:10:13,410
changed what's deleted we then

264
00:10:13,410 --> 00:10:16,330
identified noise heuristically so we ran

265
00:10:16,330 --> 00:10:19,840
a set of files we find out for example

266
00:10:19,840 --> 00:10:21,760
that paging out might happen in the

267
00:10:21,760 --> 00:10:23,380
process so we need to eliminate that

268
00:10:23,380 --> 00:10:24,910
noise we don't want that noise to show

269
00:10:24,910 --> 00:10:28,810
up in our def object this is in addition

270
00:10:28,810 --> 00:10:31,210
of course when a snapshot is paused then

271
00:10:31,210 --> 00:10:33,190
you resume from it there's some disk

272
00:10:33,190 --> 00:10:35,230
noise that might happen so we needed to

273
00:10:35,230 --> 00:10:39,280
eliminate that as well finally we tag

274
00:10:39,280 --> 00:10:41,260
and organize data according to the

275
00:10:41,260 --> 00:10:44,320
sections so the driver objects the

276
00:10:44,320 --> 00:10:46,420
modules the IDT all of this information

277
00:10:46,420 --> 00:10:48,910
that Ben was just talking about so we

278
00:10:48,910 --> 00:10:50,820
the processing module attacks this

279
00:10:50,820 --> 00:10:53,800
properly and organizes it and at the end

280
00:10:53,800 --> 00:10:56,110
appends it to the general cuckoo

281
00:10:56,110 --> 00:10:57,700
container that contains all of them

282
00:10:57,700 --> 00:11:01,690
analysis log this is an example of what

283
00:11:01,690 --> 00:11:03,990
it looks like so this is

284
00:11:03,990 --> 00:11:06,839
basically and the SS part of the SS the

285
00:11:06,839 --> 00:11:08,310
key log so you can see the system calls

286
00:11:08,310 --> 00:11:11,070
here you can see the function VA's yeah

287
00:11:11,070 --> 00:11:12,660
they're negative because it's decimals

288
00:11:12,660 --> 00:11:17,190
but it's all dealt in hex and so you can

289
00:11:17,190 --> 00:11:19,410
see the function VA is the eight first

290
00:11:19,410 --> 00:11:21,300
eight bytes of each system call this is

291
00:11:21,300 --> 00:11:22,800
an order for a student file in line

292
00:11:22,800 --> 00:11:25,830
hooks this is an example of a baseline

293
00:11:25,830 --> 00:11:30,149
for a log for a certain snapshot so you

294
00:11:30,149 --> 00:11:31,560
can see the function VA here and the

295
00:11:31,560 --> 00:11:35,790
star bite yeah the function vm start

296
00:11:35,790 --> 00:11:37,230
bites and then here you can see in the

297
00:11:37,230 --> 00:11:40,020
analysis log there's obviously a table

298
00:11:40,020 --> 00:11:41,459
hook because the function via is

299
00:11:41,459 --> 00:11:44,610
different this is what the processing

300
00:11:44,610 --> 00:11:46,890
module spits out after the different

301
00:11:46,890 --> 00:11:49,950
things so you can see here the

302
00:11:49,950 --> 00:11:51,899
difference in the VA is the difference

303
00:11:51,899 --> 00:11:55,080
in the bytes died perky which is the key

304
00:11:55,080 --> 00:12:02,760
here is the name of a system call right

305
00:12:02,760 --> 00:12:05,880
so the processing module produces all

306
00:12:05,880 --> 00:12:08,220
this information the score goes through

307
00:12:08,220 --> 00:12:10,860
a set of signatures I mean here coo coo

308
00:12:10,860 --> 00:12:13,649
signatures that run against all this

309
00:12:13,649 --> 00:12:15,899
information in order to highlight what's

310
00:12:15,899 --> 00:12:18,660
interesting to us flag it up and then

311
00:12:18,660 --> 00:12:21,180
finally as per standard cuckoo process

312
00:12:21,180 --> 00:12:23,690
you go through a set of reports that

313
00:12:23,690 --> 00:12:29,279
bubble up this information so what

314
00:12:29,279 --> 00:12:32,520
signatures did we write new driver

315
00:12:32,520 --> 00:12:34,649
objects modified driver objects the v2

316
00:12:34,649 --> 00:12:39,810
driver objects same four modules new

317
00:12:39,810 --> 00:12:41,970
device objects created and we also have

318
00:12:41,970 --> 00:12:44,490
a signature for device objects

319
00:12:44,490 --> 00:12:47,730
associated with the service so in case

320
00:12:47,730 --> 00:12:50,190
you submitted to driver file analysis

321
00:12:50,190 --> 00:12:51,450
and you know the name of the service

322
00:12:51,450 --> 00:12:53,970
that you wanted to give that specific

323
00:12:53,970 --> 00:12:56,250
driver we will look for device objects

324
00:12:56,250 --> 00:13:00,110
created for that specific service new

325
00:13:00,110 --> 00:13:03,320
registered callbacks modified callbacks

326
00:13:03,320 --> 00:13:06,270
this is the two hooks and IDT hooks and

327
00:13:06,270 --> 00:13:08,880
finally some disc information so if the

328
00:13:08,880 --> 00:13:11,279
Master Boot Record was modified we will

329
00:13:11,279 --> 00:13:13,079
flagging it up if the volume Boot Record

330
00:13:13,079 --> 00:13:14,499
was modified to flag that up

331
00:13:14,499 --> 00:13:16,719
and a signature for the end of this size

332
00:13:16,719 --> 00:13:20,259
this means the slack space between the

333
00:13:20,259 --> 00:13:22,479
end of the file system and the disk so

334
00:13:22,479 --> 00:13:25,179
we know the last sector for the file

335
00:13:25,179 --> 00:13:27,519
system and we know the last sector of

336
00:13:27,519 --> 00:13:30,279
disk in some case boot kits will hide

337
00:13:30,279 --> 00:13:33,099
their file system in that slack space so

338
00:13:33,099 --> 00:13:37,319
we need to identify if that was the case

339
00:13:37,649 --> 00:13:40,209
so this is an example of their imports

340
00:13:40,209 --> 00:13:42,009
that we get the nice jangling templates

341
00:13:42,009 --> 00:13:45,129
that we added to cuckoo this is the

342
00:13:45,129 --> 00:13:47,379
current memory changes this according so

343
00:13:47,379 --> 00:13:49,269
for example here we submitted to drive a

344
00:13:49,269 --> 00:13:51,279
file this was the name of the service we

345
00:13:51,279 --> 00:13:53,799
gave you can see here the new modules

346
00:13:53,799 --> 00:13:56,529
the new image base size and we can see

347
00:13:56,529 --> 00:13:59,019
that this specific we dumped here the

348
00:13:59,019 --> 00:14:00,699
whole driver objects to all the IR peas

349
00:14:00,699 --> 00:14:04,839
or the VA's the device list all the

350
00:14:04,839 --> 00:14:07,149
parameters of the driver object

351
00:14:07,149 --> 00:14:10,299
structure and we can see that in this

352
00:14:10,299 --> 00:14:13,839
case this driver hooked anti set value

353
00:14:13,839 --> 00:14:20,139
key then we show all of the different

354
00:14:20,139 --> 00:14:23,439
parts of the log so the sample analysis

355
00:14:23,439 --> 00:14:26,259
love we exposed all that information so

356
00:14:26,259 --> 00:14:28,269
we expose all the drivers and for each

357
00:14:28,269 --> 00:14:31,119
driver you can see here or the irps you

358
00:14:31,119 --> 00:14:34,329
can see some of the fields of the driver

359
00:14:34,329 --> 00:14:36,849
object structure and all of them but all

360
00:14:36,849 --> 00:14:38,199
of them are present in the log so you

361
00:14:38,199 --> 00:14:39,789
can write really signatures on them this

362
00:14:39,789 --> 00:14:42,009
is just for showing you know what we

363
00:14:42,009 --> 00:14:45,129
thought was interesting then you have

364
00:14:45,129 --> 00:14:51,099
the modules the SSD key the callbacks

365
00:14:51,099 --> 00:14:55,089
whatever callbacks are registered the

366
00:14:55,089 --> 00:14:57,129
MVR it's not really MBR it's more than

367
00:14:57,129 --> 00:14:59,709
that it's it's the partition table so we

368
00:14:59,709 --> 00:15:01,479
really show the partition table and the

369
00:15:01,479 --> 00:15:05,649
Shah for each vbr and in this case we

370
00:15:05,649 --> 00:15:07,239
had two partitions the active one

371
00:15:07,239 --> 00:15:10,209
weekend gia and yeah where they'll be

372
00:15:10,209 --> 00:15:12,129
here for the last sector of disk and the

373
00:15:12,129 --> 00:15:17,470
LBA of the last secretary fault system

374
00:15:17,470 --> 00:15:23,590
and the IDT for each CPU so that's so

375
00:15:23,590 --> 00:15:28,600
nice and sweet but this going to work we

376
00:15:28,600 --> 00:15:30,670
really need to see if that's going to

377
00:15:30,670 --> 00:15:32,410
make any sense is this system going to

378
00:15:32,410 --> 00:15:36,880
be helpful for our own purpose what was

379
00:15:36,880 --> 00:15:39,580
our design goal the design goal was that

380
00:15:39,580 --> 00:15:43,170
we need to find out if a sample is

381
00:15:43,170 --> 00:15:45,550
potentially a rootkit it's not an

382
00:15:45,550 --> 00:15:47,590
exhaustive system for leukot analysis we

383
00:15:47,590 --> 00:15:51,460
did this is not what we had mind so what

384
00:15:51,460 --> 00:15:55,090
we did we had three sets of tests the

385
00:15:55,090 --> 00:15:58,360
first set was we against some

386
00:15:58,360 --> 00:16:00,640
high-profile rootkits so Lucas that you

387
00:16:00,640 --> 00:16:04,720
all heard of or most of you heard of so

388
00:16:04,720 --> 00:16:07,930
we grabbed TDL gaps third line neckers

389
00:16:07,930 --> 00:16:11,620
and we know what we what the research

390
00:16:11,620 --> 00:16:13,330
out there what from our analysis what we

391
00:16:13,330 --> 00:16:15,820
should be seeing compared to what we saw

392
00:16:15,820 --> 00:16:17,890
from our system and we we see the

393
00:16:17,890 --> 00:16:21,340
difference and the set of malicious and

394
00:16:21,340 --> 00:16:24,520
clean driver files and a set of randomly

395
00:16:24,520 --> 00:16:29,560
selected malicious executables so TDL

396
00:16:29,560 --> 00:16:32,560
sure many of you are available no no

397
00:16:32,560 --> 00:16:34,060
what TD LSD deal has been out there

398
00:16:34,060 --> 00:16:36,250
since late 2010 and there many

399
00:16:36,250 --> 00:16:40,450
derivatives there were many knockoffs of

400
00:16:40,450 --> 00:16:44,170
it we basically wanted to test if we're

401
00:16:44,170 --> 00:16:46,840
going to capture the NBR change are we

402
00:16:46,840 --> 00:16:49,060
going to be see are we going to see the

403
00:16:49,060 --> 00:16:50,740
difference when that happens on what

404
00:16:50,740 --> 00:16:53,290
else are you going to see standard

405
00:16:53,290 --> 00:16:56,200
classic TDL for will hook driver start I

406
00:16:56,200 --> 00:16:59,560
of the miniport driver it will override

407
00:16:59,560 --> 00:17:01,720
the MBR and will steal one of the device

408
00:17:01,720 --> 00:17:04,839
objects of associated with the miniport

409
00:17:04,839 --> 00:17:07,960
driver are we going to see this here we

410
00:17:07,960 --> 00:17:11,940
got the MBR change but we did not get

411
00:17:11,940 --> 00:17:14,800
the drivers start io hook and you didn't

412
00:17:14,800 --> 00:17:16,839
get the device objects change what we

413
00:17:16,839 --> 00:17:19,660
got instead was a change in the file

414
00:17:19,660 --> 00:17:24,250
system driver and which means so we got

415
00:17:24,250 --> 00:17:26,530
the file system filter manages the

416
00:17:26,530 --> 00:17:28,930
signature hit on on both to driver

417
00:17:28,930 --> 00:17:31,330
objects and we got a device object

418
00:17:31,330 --> 00:17:33,370
added in this case this was the address

419
00:17:33,370 --> 00:17:36,399
of the device object and this is the

420
00:17:36,399 --> 00:17:40,090
type of the device for have a closer

421
00:17:40,090 --> 00:17:43,059
look we can see that this device object

422
00:17:43,059 --> 00:17:44,740
was the same device subject that was

423
00:17:44,740 --> 00:17:46,960
added file system bro so the device list

424
00:17:46,960 --> 00:17:50,500
of file system row includes the devices

425
00:17:50,500 --> 00:17:53,380
of filesystem filter manager so we can

426
00:17:53,380 --> 00:17:57,159
see in this case the same VA for that

427
00:17:57,159 --> 00:17:59,860
same device object which means probably

428
00:17:59,860 --> 00:18:02,919
this was of mini filters and stored in

429
00:18:02,919 --> 00:18:06,669
order to filter out io request packets

430
00:18:06,669 --> 00:18:09,309
through to the file system itself it's

431
00:18:09,309 --> 00:18:11,980
not exactly the same TDL classic version

432
00:18:11,980 --> 00:18:16,630
that everyone knows about the second

433
00:18:16,630 --> 00:18:21,130
test was with gaps so they were if you

434
00:18:21,130 --> 00:18:22,990
were watching Eugene and Alex s today

435
00:18:22,990 --> 00:18:24,250
we're talking about their two variants

436
00:18:24,250 --> 00:18:26,980
of gaps there's the MBR modifier one and

437
00:18:26,980 --> 00:18:29,260
there's the one that modifies the hidden

438
00:18:29,260 --> 00:18:31,360
sectors d word in the bios parameter

439
00:18:31,360 --> 00:18:34,120
block this is the one that modifies the

440
00:18:34,120 --> 00:18:35,889
hidden sectors of the voice parameter

441
00:18:35,889 --> 00:18:39,100
clock in the VBR so we want to see if

442
00:18:39,100 --> 00:18:40,840
we're going to capture that in addition

443
00:18:40,840 --> 00:18:42,279
to that change we know that gaps

444
00:18:42,279 --> 00:18:46,090
normally introduces some kernel sections

445
00:18:46,090 --> 00:18:48,760
or code sections inside the current not

446
00:18:48,760 --> 00:18:50,950
as not a full PE and currently when it

447
00:18:50,950 --> 00:18:54,929
loads and it but it's instantiates that

448
00:18:54,929 --> 00:18:58,200
by first hijacking the boot process

449
00:18:58,200 --> 00:19:00,760
which is exactly what it's doing bio in

450
00:19:00,760 --> 00:19:03,460
defying the hidden sectors d word we got

451
00:19:03,460 --> 00:19:06,789
that and this is a this is the example

452
00:19:06,789 --> 00:19:09,789
of what noise for example we left in the

453
00:19:09,789 --> 00:19:13,330
system so sometimes system calls will be

454
00:19:13,330 --> 00:19:16,659
paved in during job we will keep that in

455
00:19:16,659 --> 00:19:19,690
case we encounter a sample for example

456
00:19:19,690 --> 00:19:22,539
that will want to page in a certain

457
00:19:22,539 --> 00:19:25,779
syscall and hook it so we want to keep

458
00:19:25,779 --> 00:19:27,460
that information but we label it as page

459
00:19:27,460 --> 00:19:29,019
then we know that this was paid and

460
00:19:29,019 --> 00:19:30,340
before because we can compare it against

461
00:19:30,340 --> 00:19:33,340
the baseline now i'm going to pass you

462
00:19:33,340 --> 00:19:34,389
over to Ben who's going to talk about

463
00:19:34,389 --> 00:19:36,909
Carolyn Decker's and the militias and

464
00:19:36,909 --> 00:19:40,330
clean driver sir ok so teller also known

465
00:19:40,330 --> 00:19:41,500
as like a robber

466
00:19:41,500 --> 00:19:42,970
this was booked by GK to in March

467
00:19:42,970 --> 00:19:44,740
earlier this year but it's been around

468
00:19:44,740 --> 00:19:47,500
for for a couple years now so from

469
00:19:47,500 --> 00:19:49,240
research we know that it installs an

470
00:19:49,240 --> 00:19:51,070
interrupt we know it has a hidden

471
00:19:51,070 --> 00:19:52,930
encrypted file system on the disk and we

472
00:19:52,930 --> 00:19:54,400
know it hooks a number of SSD T

473
00:19:54,400 --> 00:19:56,890
functions are with this interrupt so

474
00:19:56,890 --> 00:19:58,690
running it through our system what do we

475
00:19:58,690 --> 00:20:01,330
see ok so we see a driver's been loaded

476
00:20:01,330 --> 00:20:03,340
Colonel budget been added we see device

477
00:20:03,340 --> 00:20:06,130
objects been added we see SS dt function

478
00:20:06,130 --> 00:20:08,170
has been hooked and we also see that the

479
00:20:08,170 --> 00:20:11,470
IDT has been modified so looking at this

480
00:20:11,470 --> 00:20:14,530
a bit further so we see the SS dt

481
00:20:14,530 --> 00:20:16,780
functions SS dt functions here that have

482
00:20:16,780 --> 00:20:18,700
been hooked we can get the start bytes

483
00:20:18,700 --> 00:20:20,950
of those and if we disassemble them we

484
00:20:20,950 --> 00:20:22,390
see we've got a push and then we haven't

485
00:20:22,390 --> 00:20:25,270
interrupt this is interrupts III and if

486
00:20:25,270 --> 00:20:26,950
we have a look at the IDT modifications

487
00:20:26,950 --> 00:20:29,890
lo and behold we have c3 and if we would

488
00:20:29,890 --> 00:20:32,680
take this this be a here we would see

489
00:20:32,680 --> 00:20:34,660
that it lies within the kernel module

490
00:20:34,660 --> 00:20:35,620
that's been added so we can directly

491
00:20:35,620 --> 00:20:39,100
attribute this this interrupt to you

492
00:20:39,100 --> 00:20:41,230
know to the driver that's been added the

493
00:20:41,230 --> 00:20:42,940
next one is neckers so this has been

494
00:20:42,940 --> 00:20:45,970
around since about 2011 it was packaged

495
00:20:45,970 --> 00:20:47,830
with fake a B and there's more recently

496
00:20:47,830 --> 00:20:51,430
Packard with package with Zeus it's got

497
00:20:51,430 --> 00:20:53,260
usual rootkit behavior so install the

498
00:20:53,260 --> 00:20:55,990
driver it creates a service the driver

499
00:20:55,990 --> 00:20:58,120
hides the service and the driver file on

500
00:20:58,120 --> 00:21:00,520
the disk and it also controls what

501
00:21:00,520 --> 00:21:03,070
applications are loaded so running it

502
00:21:03,070 --> 00:21:05,890
through our system we see a driver has

503
00:21:05,890 --> 00:21:08,230
has been loaded we see a driver objects

504
00:21:08,230 --> 00:21:09,520
been modified and we see a call backs

505
00:21:09,520 --> 00:21:12,160
being added now if we look at the driver

506
00:21:12,160 --> 00:21:13,810
that's been loaded we see we have a name

507
00:21:13,810 --> 00:21:15,520
but we do not have a path and we do not

508
00:21:15,520 --> 00:21:17,440
have a shot and the reason for this is

509
00:21:17,440 --> 00:21:19,000
that our system can't access the file

510
00:21:19,000 --> 00:21:21,100
and disk and most likely reason for that

511
00:21:21,100 --> 00:21:23,650
is because it's been hidden now if we

512
00:21:23,650 --> 00:21:25,870
look at the modification so we see a

513
00:21:25,870 --> 00:21:27,640
device has been added to the file system

514
00:21:27,640 --> 00:21:29,890
filter manager and we also see we've got

515
00:21:29,890 --> 00:21:31,870
a load image notify call back so the

516
00:21:31,870 --> 00:21:33,730
load image file callback will control

517
00:21:33,730 --> 00:21:36,220
what applications loaded and in both

518
00:21:36,220 --> 00:21:38,470
cases we can attribute this driver named

519
00:21:38,470 --> 00:21:41,140
to the driver that's been loaded now in

520
00:21:41,140 --> 00:21:43,810
all four of these examples and what we

521
00:21:43,810 --> 00:21:45,430
can take away for this is that we're not

522
00:21:45,430 --> 00:21:47,110
always getting enough information to

523
00:21:47,110 --> 00:21:49,720
classify specific family so the TDL we

524
00:21:49,720 --> 00:21:51,490
and we only get the MBR modification but

525
00:21:51,490 --> 00:21:53,200
we don't get anything else but what we

526
00:21:53,200 --> 00:21:55,649
are getting is enough information to war

527
00:21:55,649 --> 00:21:58,330
investigating further investigation by a

528
00:21:58,330 --> 00:22:01,659
researcher so looking at the next

529
00:22:01,659 --> 00:22:03,100
experiment we took a number of clean

530
00:22:03,100 --> 00:22:04,570
drivers and a number of malicious

531
00:22:04,570 --> 00:22:06,669
drivers about 3,000 in total we put them

532
00:22:06,669 --> 00:22:07,869
through our system to see what kind of

533
00:22:07,869 --> 00:22:09,729
changes they've made see if we can you

534
00:22:09,729 --> 00:22:12,039
know kind of identify which which

535
00:22:12,039 --> 00:22:13,450
modifications are more likely to be

536
00:22:13,450 --> 00:22:15,789
malicious now we found that fifty

537
00:22:15,789 --> 00:22:18,129
percent of the clean drivers did not

538
00:22:18,129 --> 00:22:20,289
return any Colonel data whereas only

539
00:22:20,289 --> 00:22:22,090
about eighteen percent of the malicious

540
00:22:22,090 --> 00:22:24,279
drivers did not return Colonel data now

541
00:22:24,279 --> 00:22:26,769
this tells us in a roundabout way that

542
00:22:26,769 --> 00:22:28,570
just because something returns Colonel

543
00:22:28,570 --> 00:22:29,950
data there's a slightly higher chance

544
00:22:29,950 --> 00:22:31,619
that it's actually going to be malicious

545
00:22:31,619 --> 00:22:34,330
now looking at the results of this so

546
00:22:34,330 --> 00:22:36,489
new drivers this is neither clean normal

547
00:22:36,489 --> 00:22:37,929
issues you know everything's going to

548
00:22:37,929 --> 00:22:40,869
create this this new driver the modified

549
00:22:40,869 --> 00:22:43,090
driver we're seeing that this is more of

550
00:22:43,090 --> 00:22:45,700
a militia straight than a clean straight

551
00:22:45,700 --> 00:22:47,889
new module once again exactly the same

552
00:22:47,889 --> 00:22:51,129
as new driver that's to be inspected the

553
00:22:51,129 --> 00:22:52,629
next one was a little bit of a surprise

554
00:22:52,629 --> 00:22:55,570
to us so SSD t hooks we found that more

555
00:22:55,570 --> 00:22:57,580
clean sample took the SSD t the

556
00:22:57,580 --> 00:22:59,109
malicious ones which was a bit strange

557
00:22:59,109 --> 00:23:00,999
so I'm after drilling into this a bit

558
00:23:00,999 --> 00:23:02,590
more we realize that we've got a lot of

559
00:23:02,590 --> 00:23:04,539
security software in our clean set and

560
00:23:04,539 --> 00:23:06,190
security software would like to monitor

561
00:23:06,190 --> 00:23:07,989
the system in some way so you know that

562
00:23:07,989 --> 00:23:10,019
that's kind of a why that happened and

563
00:23:10,019 --> 00:23:12,340
newhall backs we're seeing that this is

564
00:23:12,340 --> 00:23:14,799
normally abused more wire malicious

565
00:23:14,799 --> 00:23:19,049
drivers than clean as with the generic

566
00:23:19,049 --> 00:23:21,609
attached device so this is new devices

567
00:23:21,609 --> 00:23:23,349
that have attached themselves to other

568
00:23:23,349 --> 00:23:27,149
driver objects but the the modified MBR

569
00:23:27,149 --> 00:23:30,429
the sorry the generic new device link so

570
00:23:30,429 --> 00:23:31,929
this is where our new driver has created

571
00:23:31,929 --> 00:23:33,849
a new device you know this is kind of

572
00:23:33,849 --> 00:23:36,129
like they're clean normal issues so what

573
00:23:36,129 --> 00:23:38,440
we can take from this is you know yes we

574
00:23:38,440 --> 00:23:40,210
can say that a certain modification is

575
00:23:40,210 --> 00:23:42,129
more malicious than others but we can't

576
00:23:42,129 --> 00:23:43,809
directly attribute definite

577
00:23:43,809 --> 00:23:45,479
maliciousness to any single one of them

578
00:23:45,479 --> 00:23:48,009
now a party over 2l no two will go

579
00:23:48,009 --> 00:23:50,679
through the last bit and wrap up talk so

580
00:23:50,679 --> 00:23:52,599
Ben was just talking about the set of

581
00:23:52,599 --> 00:23:54,249
clean and malicious driver files that we

582
00:23:54,249 --> 00:23:57,609
looked at the intention of this system

583
00:23:57,609 --> 00:24:01,239
was to flag out potential interesting

584
00:24:01,239 --> 00:24:03,489
samples for us we wanted a quick way to

585
00:24:03,489 --> 00:24:05,470
be looking to look at this torrent file

586
00:24:05,470 --> 00:24:08,370
such samples this is an example

587
00:24:08,370 --> 00:24:11,340
of such case so in this case this is a

588
00:24:11,340 --> 00:24:13,410
driver that didn't create a driver

589
00:24:13,410 --> 00:24:16,140
object didn't create a new module yet it

590
00:24:16,140 --> 00:24:18,150
installed to call backs so we have here

591
00:24:18,150 --> 00:24:20,490
a call back on crepe rotors notify a

592
00:24:20,490 --> 00:24:22,920
call back on load image notify with an

593
00:24:22,920 --> 00:24:25,680
unknown driver unknown file path and

594
00:24:25,680 --> 00:24:31,770
normal you interesting we also got to

595
00:24:31,770 --> 00:24:34,800
SSD t hooks you can see that those were

596
00:24:34,800 --> 00:24:36,420
in line hooks you can obviously the e 9

597
00:24:36,420 --> 00:24:39,300
there and anti numerate key standard

598
00:24:39,300 --> 00:24:42,090
stuff interesting anti-flash instruction

599
00:24:42,090 --> 00:24:46,020
cache this is exactly what our system or

600
00:24:46,020 --> 00:24:48,179
what we want our system to flag up to us

601
00:24:48,179 --> 00:24:49,800
so that we can go further and

602
00:24:49,800 --> 00:24:52,500
investigate what is the sample what is

603
00:24:52,500 --> 00:24:56,700
it doing now we look at the set of PE

604
00:24:56,700 --> 00:24:58,980
files that we ran against good news is

605
00:24:58,980 --> 00:25:00,510
that we really got ninety six percent

606
00:25:00,510 --> 00:25:02,850
success rate as in the four minutes was

607
00:25:02,850 --> 00:25:05,610
more than enough to get a ninety-six

608
00:25:05,610 --> 00:25:07,740
percent success rate this is good news

609
00:25:07,740 --> 00:25:09,570
for us because we don't want to exceed

610
00:25:09,570 --> 00:25:12,420
four minutes in our cluster that's the

611
00:25:12,420 --> 00:25:13,530
maximum time that we want to give per

612
00:25:13,530 --> 00:25:19,740
sample the well the other news was that

613
00:25:19,740 --> 00:25:22,230
we got less than five percent kernel

614
00:25:22,230 --> 00:25:24,420
memory changes most of the samples

615
00:25:24,420 --> 00:25:27,679
returned the same they didn't induce any

616
00:25:27,679 --> 00:25:29,870
current any changes in kernel memory

617
00:25:29,870 --> 00:25:32,970
nothing happened this could be for wide

618
00:25:32,970 --> 00:25:35,040
variety of reasons could be intended the

619
00:25:35,040 --> 00:25:38,640
anti sandboxing it could be equivalent

620
00:25:38,640 --> 00:25:41,010
sample doesn't do anything it could be

621
00:25:41,010 --> 00:25:42,780
that because it doesn't really do any

622
00:25:42,780 --> 00:25:46,679
currently memory modifications but the

623
00:25:46,679 --> 00:25:49,500
interesting thing from here is that the

624
00:25:49,500 --> 00:25:51,179
highest hit was in modified driver

625
00:25:51,179 --> 00:25:55,650
objects this was the highest it we got

626
00:25:55,650 --> 00:25:58,500
almost equivalent hits and new driver

627
00:25:58,500 --> 00:26:00,870
objects created that new modules less

628
00:26:00,870 --> 00:26:05,970
hits in SS DT and IDT hooks and lower

629
00:26:05,970 --> 00:26:08,580
hits in in or no hits an attached device

630
00:26:08,580 --> 00:26:11,010
objects the idea here is basically what

631
00:26:11,010 --> 00:26:12,600
we're seeing is that there's a higher

632
00:26:12,600 --> 00:26:15,390
chance that a malicious author of a

633
00:26:15,390 --> 00:26:18,300
rootkit will not go and hook you know

634
00:26:18,300 --> 00:26:22,380
your traditional ssdd IDT whatnot

635
00:26:22,380 --> 00:26:24,780
we'll go he would go or he or she will

636
00:26:24,780 --> 00:26:27,330
go for the modified or driver object

637
00:26:27,330 --> 00:26:30,210
because it's much more difficult for a

638
00:26:30,210 --> 00:26:32,640
researcher to enumerate each and every

639
00:26:32,640 --> 00:26:35,130
driver object and find out what has been

640
00:26:35,130 --> 00:26:37,740
hooked so it's easier to hide them

641
00:26:37,740 --> 00:26:42,930
they're putting this all together we

642
00:26:42,930 --> 00:26:45,090
didn't obviously get hits on all of our

643
00:26:45,090 --> 00:26:49,110
signatures but we used our own

644
00:26:49,110 --> 00:26:51,210
experience in addition to the stats that

645
00:26:51,210 --> 00:26:54,270
you just saw earlier so we classified

646
00:26:54,270 --> 00:26:56,490
for example the creation of new driver

647
00:26:56,490 --> 00:26:59,160
objects or new modules as info level

648
00:26:59,160 --> 00:27:01,340
signatures this is this is by the way

649
00:27:01,340 --> 00:27:04,290
standard cuckoo level security so in

650
00:27:04,290 --> 00:27:06,900
cuckoo it gives you the ability to rank

651
00:27:06,900 --> 00:27:09,270
signatures at square one being less

652
00:27:09,270 --> 00:27:11,700
malicious you know that blue label and

653
00:27:11,700 --> 00:27:15,540
then you have your yellow suspicious

654
00:27:15,540 --> 00:27:22,080
activity and malicious stuff three so

655
00:27:22,080 --> 00:27:24,420
yeah and then we classify the suspicious

656
00:27:24,420 --> 00:27:26,550
the modification of a driver object that

657
00:27:26,550 --> 00:27:29,700
modification of a module standard SSD t

658
00:27:29,700 --> 00:27:32,280
and IDT hooks is suspicious you can see

659
00:27:32,280 --> 00:27:33,960
sometimes clean drivers doing this

660
00:27:33,960 --> 00:27:35,940
actually a lot of security drivers will

661
00:27:35,940 --> 00:27:40,730
do this the registration of a callback

662
00:27:40,730 --> 00:27:43,080
attaching a device this is all

663
00:27:43,080 --> 00:27:45,960
suspicious more likely to be malicious

664
00:27:45,960 --> 00:27:48,650
then clean is the modification of an MBR

665
00:27:48,650 --> 00:27:50,880
obviously the vdr and the end of disk

666
00:27:50,880 --> 00:27:56,790
size so in conclusion what what what did

667
00:27:56,790 --> 00:27:59,190
we what didn't get out of all of us what

668
00:27:59,190 --> 00:28:01,970
was what was the outcome of all of us

669
00:28:01,970 --> 00:28:04,140
what we can definitely tell is that

670
00:28:04,140 --> 00:28:05,760
malicious activity can be identified by

671
00:28:05,760 --> 00:28:09,150
our modifications rather than creation I

672
00:28:09,150 --> 00:28:12,420
ie the creation of a driver object or a

673
00:28:12,420 --> 00:28:14,940
device object isn't per se suspicious

674
00:28:14,940 --> 00:28:17,820
but the modification of a driver object

675
00:28:17,820 --> 00:28:19,230
is likely to be an indication of

676
00:28:19,230 --> 00:28:20,430
malicious activity more than anything

677
00:28:20,430 --> 00:28:23,070
else more than it's likely to be clean

678
00:28:23,070 --> 00:28:26,550
driver doing this the second conclusion

679
00:28:26,550 --> 00:28:28,470
was that malicious drivers are unlikely

680
00:28:28,470 --> 00:28:30,330
to employ anti sandboxing thinks this is

681
00:28:30,330 --> 00:28:32,850
evident from the fact that we got quite

682
00:28:32,850 --> 00:28:34,790
a high rate of replication

683
00:28:34,790 --> 00:28:38,200
successful replication in driver files

684
00:28:38,200 --> 00:28:44,930
compared to our PE files in many cases

685
00:28:44,930 --> 00:28:49,640
the dropper will be doing the job of you

686
00:28:49,640 --> 00:28:52,100
know detecting the vm or the sandbox etc

687
00:28:52,100 --> 00:28:54,920
and the driver one wouldn't be doing

688
00:28:54,920 --> 00:28:59,420
this in many cases last but not least we

689
00:28:59,420 --> 00:29:03,320
found out that actually our system is

690
00:29:03,320 --> 00:29:07,130
not so bad in terms of flanging up

691
00:29:07,130 --> 00:29:10,520
interesting samples for us it can it can

692
00:29:10,520 --> 00:29:14,420
run quick it will give us good

693
00:29:14,420 --> 00:29:17,000
information on malicious potentially

694
00:29:17,000 --> 00:29:19,160
malicious activity and allow us to go

695
00:29:19,160 --> 00:29:23,030
and dig further finally obviously this

696
00:29:23,030 --> 00:29:25,940
is far from done work and we're still

697
00:29:25,940 --> 00:29:27,740
working on this and we're still going to

698
00:29:27,740 --> 00:29:30,620
continue working on it one of the things

699
00:29:30,620 --> 00:29:31,910
that we're looking at we're looking at

700
00:29:31,910 --> 00:29:34,280
dumping more information so the current

701
00:29:34,280 --> 00:29:36,170
objects table I'm going to start doing

702
00:29:36,170 --> 00:29:39,140
that we're going to look at decom as

703
00:29:39,140 --> 00:29:40,760
well and 64-bit drivers because at the

704
00:29:40,760 --> 00:29:43,840
moment we only look at 32 bit drivers

705
00:29:43,840 --> 00:29:45,770
we're also going to look at sample

706
00:29:45,770 --> 00:29:47,510
clustering more intelligent signatures

707
00:29:47,510 --> 00:29:49,790
since we have so since we're running

708
00:29:49,790 --> 00:29:52,940
cuckoo signatures really we can use

709
00:29:52,940 --> 00:29:56,090
information from several places so we

710
00:29:56,090 --> 00:29:59,240
can use for example the kernel memory

711
00:29:59,240 --> 00:30:00,830
changes in addition to network activity

712
00:30:00,830 --> 00:30:03,140
in addition to user mode activity and

713
00:30:03,140 --> 00:30:05,540
put that all together into more

714
00:30:05,540 --> 00:30:08,630
intelligent clustering and finally yeah

715
00:30:08,630 --> 00:30:10,970
user mode rootkits your traditional iat

716
00:30:10,970 --> 00:30:15,380
DLL injection stuff and that is really

717
00:30:15,380 --> 00:30:21,430
it thank you all very much questions

