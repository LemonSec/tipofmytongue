1
00:00:08,880 --> 00:00:09,840
hello everyone

2
00:00:09,840 --> 00:00:11,840
welcome on our virus bulletin

3
00:00:11,840 --> 00:00:13,280
presentation

4
00:00:13,280 --> 00:00:16,079
a new open source hypervisor level

5
00:00:16,079 --> 00:00:18,720
malware monitoring and extraction system

6
00:00:18,720 --> 00:00:21,279
and today we are going to present its

7
00:00:21,279 --> 00:00:22,320
current state

8
00:00:22,320 --> 00:00:25,760
and some further challenges my name is

9
00:00:25,760 --> 00:00:27,119
michael lestenski

10
00:00:27,119 --> 00:00:30,080
i work as an i.t security engineer at

11
00:00:30,080 --> 00:00:31,920
search poland and i do

12
00:00:31,920 --> 00:00:34,239
malware analysis tools and

13
00:00:34,239 --> 00:00:36,239
infrastructure development

14
00:00:36,239 --> 00:00:38,719
and also from time to time i'm breaking

15
00:00:38,719 --> 00:00:39,360
or

16
00:00:39,360 --> 00:00:43,360
auditing or fixing web applications

17
00:00:43,360 --> 00:00:45,600
my name is kristof chansky currently i'm

18
00:00:45,600 --> 00:00:47,920
working in one of polish financial

19
00:00:47,920 --> 00:00:49,760
institutions

20
00:00:49,760 --> 00:00:53,199
but i'm going to present my

21
00:00:53,199 --> 00:00:55,600
research that i've done together at

22
00:00:55,600 --> 00:00:56,640
mihao

23
00:00:56,640 --> 00:00:59,760
when i was working in start poland

24
00:00:59,760 --> 00:01:04,559
last year i like breaking computers

25
00:01:04,559 --> 00:01:07,760
and from time to time in my free time

26
00:01:07,760 --> 00:01:10,080
i like playing capture the flag

27
00:01:10,080 --> 00:01:11,600
competitions with

28
00:01:11,600 --> 00:01:13,520
p14

29
00:01:13,520 --> 00:01:15,200
[Music]

30
00:01:15,200 --> 00:01:18,479
so let's start from scratch by analyzing

31
00:01:18,479 --> 00:01:21,119
ordinary consumer targeting malware we

32
00:01:21,119 --> 00:01:22,479
could easily

33
00:01:22,479 --> 00:01:25,439
spot that we have many many different

34
00:01:25,439 --> 00:01:26,720
samples packed by

35
00:01:26,720 --> 00:01:28,880
many many different packers but very

36
00:01:28,880 --> 00:01:29,920
often it's

37
00:01:29,920 --> 00:01:33,040
the same malware core underneath them so

38
00:01:33,040 --> 00:01:33,920
we want to

39
00:01:33,920 --> 00:01:36,799
extract the malware core out of the

40
00:01:36,799 --> 00:01:38,159
packed samples to have

41
00:01:38,159 --> 00:01:40,960
easy identification and easy data

42
00:01:40,960 --> 00:01:42,880
extraction

43
00:01:42,880 --> 00:01:45,119
and this is how we do malware processing

44
00:01:45,119 --> 00:01:46,399
at cert pl

45
00:01:46,399 --> 00:01:48,799
essentially we are focused on the

46
00:01:48,799 --> 00:01:50,320
malware unpacking and

47
00:01:50,320 --> 00:01:52,640
extraction of all the interesting stuff

48
00:01:52,640 --> 00:01:53,680
that is contained

49
00:01:53,680 --> 00:01:56,399
in the binary itself so we take a

50
00:01:56,399 --> 00:01:58,880
portable executables we put them on the

51
00:01:58,880 --> 00:01:59,920
sandbox

52
00:01:59,920 --> 00:02:03,520
then the sandbox is making memory dumps

53
00:02:03,520 --> 00:02:06,719
out of the execution and then these

54
00:02:06,719 --> 00:02:08,000
memory dumps are

55
00:02:08,000 --> 00:02:11,840
further analyzed by other systems

56
00:02:11,840 --> 00:02:14,640
and this is how it could look like for

57
00:02:14,640 --> 00:02:14,959
some

58
00:02:14,959 --> 00:02:18,319
emoted packed sample so

59
00:02:18,319 --> 00:02:21,280
we took a sample which i believe was

60
00:02:21,280 --> 00:02:22,959
sent through the email or

61
00:02:22,959 --> 00:02:27,520
distributed in other similar way

62
00:02:27,520 --> 00:02:30,480
then it arrived to our sandbox it was

63
00:02:30,480 --> 00:02:32,640
unpacked automatically

64
00:02:32,640 --> 00:02:35,760
and then our post-processing systems

65
00:02:35,760 --> 00:02:38,400
identified from the memory dump that

66
00:02:38,400 --> 00:02:39,120
it's

67
00:02:39,120 --> 00:02:42,000
this is the code of the family emoted

68
00:02:42,000 --> 00:02:43,280
and moreover we've

69
00:02:43,280 --> 00:02:46,640
extracted all the information that was

70
00:02:46,640 --> 00:02:48,959
hurt coded within the sample so

71
00:02:48,959 --> 00:02:51,360
the public key for encryption and all

72
00:02:51,360 --> 00:02:52,800
the hard coded

73
00:02:52,800 --> 00:02:57,760
cnc's all the information like that

74
00:02:58,239 --> 00:03:01,120
so yeah while the portable executable

75
00:03:01,120 --> 00:03:02,959
and the json are

76
00:03:02,959 --> 00:03:05,200
well well-known concepts and what about

77
00:03:05,200 --> 00:03:06,159
memory dumps

78
00:03:06,159 --> 00:03:09,599
so the memory dumps as as far as we

79
00:03:09,599 --> 00:03:11,040
understand them

80
00:03:11,040 --> 00:03:14,239
are the logical dump of the memory of at

81
00:03:14,239 --> 00:03:17,840
given point of time and together

82
00:03:17,840 --> 00:03:20,879
and they are relevant with together with

83
00:03:20,879 --> 00:03:23,599
important metadata which is the base

84
00:03:23,599 --> 00:03:26,400
address at which the dump was made

85
00:03:26,400 --> 00:03:30,319
and also the reason of the dump is very

86
00:03:30,319 --> 00:03:33,519
important to know like

87
00:03:33,519 --> 00:03:35,680
for instance we did a memory dump

88
00:03:35,680 --> 00:03:37,200
because malware called

89
00:03:37,200 --> 00:03:40,640
some crypto api or internet api which

90
00:03:40,640 --> 00:03:42,159
would indicate that

91
00:03:42,159 --> 00:03:44,840
this malware is already unpacked in

92
00:03:44,840 --> 00:03:46,159
memory

93
00:03:46,159 --> 00:03:49,280
and the profit is the unpacked malware

94
00:03:49,280 --> 00:03:53,040
or at least sometimes

95
00:03:53,200 --> 00:03:56,239
so in order to have good memory dumps we

96
00:03:56,239 --> 00:03:58,560
need good charistics and to have

97
00:03:58,560 --> 00:04:00,799
to have good charistics we need good

98
00:04:00,799 --> 00:04:03,439
behavioral monitoring

99
00:04:03,439 --> 00:04:07,439
so why can't we just use the

100
00:04:07,439 --> 00:04:11,040
an ordinary sandbox so

101
00:04:11,040 --> 00:04:14,239
yeah we we do we we use it but

102
00:04:14,239 --> 00:04:18,720
there are lots of problems around it

103
00:04:20,639 --> 00:04:23,280
so let's talk about problems we may

104
00:04:23,280 --> 00:04:25,600
encounter

105
00:04:25,600 --> 00:04:28,160
during the process of malware monitoring

106
00:04:28,160 --> 00:04:28,720
using

107
00:04:28,720 --> 00:04:32,880
conventional sandbox so let's take this

108
00:04:32,880 --> 00:04:34,160
trigbot sample

109
00:04:34,160 --> 00:04:37,919
as an example trigbot is a well-known

110
00:04:37,919 --> 00:04:38,880
troian

111
00:04:38,880 --> 00:04:42,080
or stealer

112
00:04:42,080 --> 00:04:45,199
is distributed in a form of packed

113
00:04:45,199 --> 00:04:48,479
binaries for windows and this particular

114
00:04:48,479 --> 00:04:49,759
sample is using

115
00:04:49,759 --> 00:04:52,720
process hollowing using direct system

116
00:04:52,720 --> 00:04:54,080
calls

117
00:04:54,080 --> 00:04:57,919
so since it's making the system calls

118
00:04:57,919 --> 00:04:58,960
directly

119
00:04:58,960 --> 00:05:02,080
as visible on on the the listing shown

120
00:05:02,080 --> 00:05:03,759
on the slide

121
00:05:03,759 --> 00:05:06,400
it's not possible for the user mode

122
00:05:06,400 --> 00:05:07,039
level

123
00:05:07,039 --> 00:05:11,759
sandbox to even detect such an activity

124
00:05:11,759 --> 00:05:15,120
another example could be this remco

125
00:05:15,120 --> 00:05:18,400
sample which is a remote access troy on

126
00:05:18,400 --> 00:05:18,960
and

127
00:05:18,960 --> 00:05:22,320
again it's targeting windows

128
00:05:22,320 --> 00:05:25,520
consumers and this particular sample is

129
00:05:25,520 --> 00:05:26,639
hollowing

130
00:05:26,639 --> 00:05:29,600
the service host using write process

131
00:05:29,600 --> 00:05:31,520
memory

132
00:05:31,520 --> 00:05:34,719
win api call

133
00:05:35,600 --> 00:05:39,360
so let's inspect the cuckoo's

134
00:05:39,360 --> 00:05:42,479
hooking mechanism as an example so this

135
00:05:42,479 --> 00:05:43,360
is how

136
00:05:43,360 --> 00:05:47,440
coco would place the hook on win api

137
00:05:47,440 --> 00:05:51,280
including write process memory

138
00:05:51,280 --> 00:05:55,120
so basically it would take the first

139
00:05:55,120 --> 00:05:58,000
five bytes of the function about to be

140
00:05:58,000 --> 00:05:58,880
hooked and

141
00:05:58,880 --> 00:06:02,000
then it will override the first byte

142
00:06:02,000 --> 00:06:02,560
with the

143
00:06:02,560 --> 00:06:05,759
unconditional jump op code and

144
00:06:05,759 --> 00:06:08,560
the next four bytes with the relative

145
00:06:08,560 --> 00:06:10,160
address

146
00:06:10,160 --> 00:06:15,360
of the hooking runtime so now let's see

147
00:06:15,360 --> 00:06:20,240
some parts of the ram course

148
00:06:20,240 --> 00:06:23,360
which is binary matching the first

149
00:06:23,360 --> 00:06:26,479
export this is the frame shown in

150
00:06:26,479 --> 00:06:29,840
in the debugger and then it

151
00:06:29,840 --> 00:06:32,880
it has a loop which for each export

152
00:06:32,880 --> 00:06:35,520
finds the third instruction and then

153
00:06:35,520 --> 00:06:36,960
overrides the first

154
00:06:36,960 --> 00:06:40,080
instruction and it overrides

155
00:06:40,080 --> 00:06:43,600
exactly the first five bytes to ensure

156
00:06:43,600 --> 00:06:43,919
that

157
00:06:43,919 --> 00:06:47,120
the function is unhooked so it basically

158
00:06:47,120 --> 00:06:50,400
this this code basically reverts all the

159
00:06:50,400 --> 00:06:51,520
job that was done

160
00:06:51,520 --> 00:06:55,360
by cuckoo previously the sample was

161
00:06:55,360 --> 00:06:56,240
manually

162
00:06:56,240 --> 00:06:59,360
unpacked by nazivam

163
00:06:59,360 --> 00:07:02,400
thank you very much

164
00:07:02,400 --> 00:07:05,440
so yeah basically to counter that

165
00:07:05,440 --> 00:07:08,880
cocoa could implement nti

166
00:07:08,880 --> 00:07:12,479
unhooking and then could implement nti

167
00:07:12,479 --> 00:07:15,759
nti unhooking so then

168
00:07:15,759 --> 00:07:18,400
the coco could implement the further

169
00:07:18,400 --> 00:07:19,520
iterations of

170
00:07:19,520 --> 00:07:23,440
nti unhooking but usually the malware

171
00:07:23,440 --> 00:07:24,639
will be

172
00:07:24,639 --> 00:07:28,800
one step further always

173
00:07:28,800 --> 00:07:32,400
so let's take chronos as a third example

174
00:07:32,400 --> 00:07:35,120
so this chrono sample is a banking

175
00:07:35,120 --> 00:07:36,479
malware

176
00:07:36,479 --> 00:07:39,199
which is again distributed in a form of

177
00:07:39,199 --> 00:07:40,400
windows binaries and

178
00:07:40,400 --> 00:07:43,599
is making some strange kind of

179
00:07:43,599 --> 00:07:47,680
api hammering technique

180
00:07:47,680 --> 00:07:50,639
so it is executing pretty long sequence

181
00:07:50,639 --> 00:07:52,000
of operations which are

182
00:07:52,000 --> 00:07:54,400
touching the registry keys creating

183
00:07:54,400 --> 00:07:55,680
directories and

184
00:07:55,680 --> 00:07:59,039
doing some other stuff

185
00:07:59,039 --> 00:08:02,160
so on the slide we see an example of api

186
00:08:02,160 --> 00:08:03,840
hammering that

187
00:08:03,840 --> 00:08:08,000
some particular registry key was created

188
00:08:08,000 --> 00:08:13,280
over 40 000 times

189
00:08:13,280 --> 00:08:16,639
without any specific purpose other that

190
00:08:16,639 --> 00:08:19,759
just confusing the sandboxes which

191
00:08:19,759 --> 00:08:23,039
monitor all the activity like that

192
00:08:23,039 --> 00:08:25,759
and after uploading this sample to coco

193
00:08:25,759 --> 00:08:27,440
cert ee

194
00:08:27,440 --> 00:08:30,800
we saw that the sample was reported so

195
00:08:30,800 --> 00:08:33,120
the analyze is completed successfully

196
00:08:33,120 --> 00:08:34,559
but actually after

197
00:08:34,559 --> 00:08:37,679
clicking on the analysis it displays

198
00:08:37,679 --> 00:08:39,839
that the specified analysis does not

199
00:08:39,839 --> 00:08:40,880
exist

200
00:08:40,880 --> 00:08:43,839
which would indicate that something

201
00:08:43,839 --> 00:08:44,560
crashed

202
00:08:44,560 --> 00:08:47,920
in between while analyzing this sample

203
00:08:47,920 --> 00:08:50,959
and on our old and rusty cuckoo one we

204
00:08:50,959 --> 00:08:51,760
saw

205
00:08:51,760 --> 00:08:54,320
that the analyzes has failed because an

206
00:08:54,320 --> 00:08:56,959
existing connection was forcibly closed

207
00:08:56,959 --> 00:08:57,600
by

208
00:08:57,600 --> 00:09:00,880
remote host which i believe was the case

209
00:09:00,880 --> 00:09:02,000
of the

210
00:09:02,000 --> 00:09:05,279
agent inside the vm just disconnected

211
00:09:05,279 --> 00:09:08,640
during the analysis still

212
00:09:08,640 --> 00:09:11,760
don't know the exact reason why but this

213
00:09:11,760 --> 00:09:13,839
api hammering was actually

214
00:09:13,839 --> 00:09:18,320
successful okay so let's do it on our

215
00:09:18,320 --> 00:09:20,240
own

216
00:09:20,240 --> 00:09:23,519
so while choosing some other malware

217
00:09:23,519 --> 00:09:25,200
monitoring system

218
00:09:25,200 --> 00:09:28,160
we could basically choose between user

219
00:09:28,160 --> 00:09:28,800
mode

220
00:09:28,800 --> 00:09:32,240
kernel mode being a rootkit inside the

221
00:09:32,240 --> 00:09:33,120
vm

222
00:09:33,120 --> 00:09:36,320
or the external monitoring on the level

223
00:09:36,320 --> 00:09:38,080
of hypervisor

224
00:09:38,080 --> 00:09:41,279
we have this three possible modes of

225
00:09:41,279 --> 00:09:42,399
operation

226
00:09:42,399 --> 00:09:46,480
and we would not choose user mode again

227
00:09:46,480 --> 00:09:48,480
due to the problems that were already

228
00:09:48,480 --> 00:09:50,959
mentioned so we have the choice between

229
00:09:50,959 --> 00:09:54,720
kernel mode and the hypervisor while

230
00:09:54,720 --> 00:09:57,839
both are hard we've

231
00:09:57,839 --> 00:10:00,959
established that the hypervisor

232
00:10:00,959 --> 00:10:03,360
approach would probably bring us much

233
00:10:03,360 --> 00:10:05,760
more profit in the long term so

234
00:10:05,760 --> 00:10:09,519
let's go with the hypervisor

235
00:10:09,519 --> 00:10:13,279
so in order to build the hypervisor

236
00:10:13,279 --> 00:10:15,279
level memory dumping

237
00:10:15,279 --> 00:10:18,959
system we need something open source

238
00:10:18,959 --> 00:10:22,720
to extend it we would not want to write

239
00:10:22,720 --> 00:10:26,240
all this thing from scratch and it must

240
00:10:26,240 --> 00:10:27,600
be a pretty decent

241
00:10:27,600 --> 00:10:30,399
malware monitor already as we said

242
00:10:30,399 --> 00:10:32,560
before we need to have a good

243
00:10:32,560 --> 00:10:35,839
behavioral logs and we will just simply

244
00:10:35,839 --> 00:10:36,560
add the

245
00:10:36,560 --> 00:10:39,839
memory dumping thing to this project

246
00:10:39,839 --> 00:10:42,320
and it's turned out that the ideal

247
00:10:42,320 --> 00:10:42,959
project

248
00:10:42,959 --> 00:10:46,079
to perform such a modifications

249
00:10:46,079 --> 00:10:48,480
is already present and it's called

250
00:10:48,480 --> 00:10:49,600
drackwoof

251
00:10:49,600 --> 00:10:52,079
which is a blackbox hypervisor level

252
00:10:52,079 --> 00:10:54,160
malware monitoring system

253
00:10:54,160 --> 00:10:56,640
based on the virtual machine

254
00:10:56,640 --> 00:11:01,519
introspection technique

255
00:11:01,519 --> 00:11:03,920
so what is vmi virtual machine

256
00:11:03,920 --> 00:11:05,440
introspection

257
00:11:05,440 --> 00:11:08,720
basically it's a system that

258
00:11:08,720 --> 00:11:12,240
is based on virtual machines

259
00:11:12,240 --> 00:11:15,440
physical memory that analyzes it makes

260
00:11:15,440 --> 00:11:16,240
translation

261
00:11:16,240 --> 00:11:20,640
and can extract data from it

262
00:11:20,640 --> 00:11:24,320
like as we can see in this example

263
00:11:24,320 --> 00:11:27,760
process process list virtual memory

264
00:11:27,760 --> 00:11:30,880
of processes and so on

265
00:11:30,880 --> 00:11:34,640
drag roof it's

266
00:11:34,959 --> 00:11:40,000
a system built on top of leap vmi

267
00:11:40,000 --> 00:11:42,959
and the shortest description might be

268
00:11:42,959 --> 00:11:44,079
strace for

269
00:11:44,079 --> 00:11:47,760
virtual machines so it's a program

270
00:11:47,760 --> 00:11:51,120
running clearly on host and

271
00:11:51,120 --> 00:11:54,240
by examining virtual machines physical

272
00:11:54,240 --> 00:11:55,360
memory

273
00:11:55,360 --> 00:11:58,560
it can show all the ciscos that

274
00:11:58,560 --> 00:12:01,600
are being executed inside the vm they

275
00:12:01,600 --> 00:12:03,120
clear vm without any

276
00:12:03,120 --> 00:12:06,480
agent inside it

277
00:12:06,480 --> 00:12:09,920
so what's next we have drag roof

278
00:12:09,920 --> 00:12:13,279
that is a system

279
00:12:13,279 --> 00:12:16,560
for tracing execution inside

280
00:12:16,560 --> 00:12:19,680
windows on kernel level so

281
00:12:19,680 --> 00:12:23,600
we can trace ciscos and it's stalled so

282
00:12:23,600 --> 00:12:26,560
the applications cannot see the hooks

283
00:12:26,560 --> 00:12:27,360
inside and

284
00:12:27,360 --> 00:12:31,200
it's pretty much undetectable

285
00:12:31,200 --> 00:12:35,680
what we want to achieve is memory dump

286
00:12:35,680 --> 00:12:40,240
for extraction for extracting

287
00:12:40,240 --> 00:12:43,279
malware core and behavioral

288
00:12:43,279 --> 00:12:46,720
analysis so we want to extract

289
00:12:46,720 --> 00:12:49,519
the information about user mode api

290
00:12:49,519 --> 00:12:49,920
calls

291
00:12:49,920 --> 00:12:53,839
that has been called

292
00:12:54,000 --> 00:12:55,839
let's talk about memory dumps

293
00:12:55,839 --> 00:12:57,279
specifically so

294
00:12:57,279 --> 00:12:59,200
as it was said we need to dump

295
00:12:59,200 --> 00:13:01,040
interesting memory regions at

296
00:13:01,040 --> 00:13:04,240
interesting points of runtime and

297
00:13:04,240 --> 00:13:06,720
to do it we could use the existing clip

298
00:13:06,720 --> 00:13:09,360
vmi features like memory inspection at

299
00:13:09,360 --> 00:13:10,320
low level

300
00:13:10,320 --> 00:13:13,120
so we could read write or interpret

301
00:13:13,120 --> 00:13:14,959
guest kernel structures

302
00:13:14,959 --> 00:13:17,440
and we could also place hooks on system

303
00:13:17,440 --> 00:13:18,720
calls

304
00:13:18,720 --> 00:13:21,200
in a way it is not visible to the guest

305
00:13:21,200 --> 00:13:22,160
vm and

306
00:13:22,160 --> 00:13:25,519
we could even do a little bit more

307
00:13:25,519 --> 00:13:28,720
so let's talk about our first

308
00:13:28,720 --> 00:13:32,000
very simple charistic for unpacking

309
00:13:32,000 --> 00:13:34,240
we could hook anti-protect virtual

310
00:13:34,240 --> 00:13:35,120
memory

311
00:13:35,120 --> 00:13:38,560
system call in order to check

312
00:13:38,560 --> 00:13:42,320
whether the memory about to be protected

313
00:13:42,320 --> 00:13:46,079
contains the mz string as the first

314
00:13:46,079 --> 00:13:49,839
two bytes and also whether the

315
00:13:49,839 --> 00:13:52,399
system call is related to the self

316
00:13:52,399 --> 00:13:53,279
process

317
00:13:53,279 --> 00:13:56,480
so the process handle is equal not

318
00:13:56,480 --> 00:14:00,480
zero the negated zero in such a case we

319
00:14:00,480 --> 00:14:01,440
could suspect

320
00:14:01,440 --> 00:14:04,320
that this portion of memory could

321
00:14:04,320 --> 00:14:05,519
contain the

322
00:14:05,519 --> 00:14:08,160
portable executable because of this

323
00:14:08,160 --> 00:14:08,880
correct

324
00:14:08,880 --> 00:14:11,920
characteristic msat magic

325
00:14:11,920 --> 00:14:14,240
string at the beginning and we could

326
00:14:14,240 --> 00:14:16,399
just dump this memory as

327
00:14:16,399 --> 00:14:19,760
suspicious another case could be

328
00:14:19,760 --> 00:14:23,120
hooking anti-free virtual memory

329
00:14:23,120 --> 00:14:26,399
so in this case again we could check

330
00:14:26,399 --> 00:14:30,560
whether this operation occurs within

331
00:14:30,560 --> 00:14:33,760
the same process and we could check the

332
00:14:33,760 --> 00:14:34,880
page tables

333
00:14:34,880 --> 00:14:38,240
of this process related to the address

334
00:14:38,240 --> 00:14:41,519
to be freed in order to check whether

335
00:14:41,519 --> 00:14:42,160
this

336
00:14:42,160 --> 00:14:45,839
page table entry is valid and flagged as

337
00:14:45,839 --> 00:14:48,720
writable and executable at the same time

338
00:14:48,720 --> 00:14:50,079
in such case we have

339
00:14:50,079 --> 00:14:52,720
the memory which is both writable and

340
00:14:52,720 --> 00:14:54,160
executable

341
00:14:54,160 --> 00:14:58,639
we could dump it as an interesting rwx

342
00:14:58,639 --> 00:15:03,440
memory which probably contains some

343
00:15:03,440 --> 00:15:06,959
unpacked malware

344
00:15:07,040 --> 00:15:09,760
and here we have some problems related

345
00:15:09,760 --> 00:15:10,639
to the

346
00:15:10,639 --> 00:15:13,040
memory dumping this way so for instance

347
00:15:13,040 --> 00:15:16,639
if we have a single suspicious pointer

348
00:15:16,639 --> 00:15:19,120
how we could find the corresponding

349
00:15:19,120 --> 00:15:21,600
memory region so

350
00:15:21,600 --> 00:15:24,320
from what address should we start and

351
00:15:24,320 --> 00:15:24,880
still

352
00:15:24,880 --> 00:15:27,920
what address should we dump the memory

353
00:15:27,920 --> 00:15:30,399
and the answer is to look inside the

354
00:15:30,399 --> 00:15:32,720
virtual address descriptors so

355
00:15:32,720 --> 00:15:35,040
in the windows kernel for each process

356
00:15:35,040 --> 00:15:36,160
there is a

357
00:15:36,160 --> 00:15:39,839
structure called view virtual address

358
00:15:39,839 --> 00:15:42,560
descriptor tree

359
00:15:42,560 --> 00:15:45,920
which contains the information about

360
00:15:45,920 --> 00:15:49,600
all the allocations that were done

361
00:15:49,600 --> 00:15:52,000
by this process so the ranges of the

362
00:15:52,000 --> 00:15:54,959
virtual addresses that are valid for

363
00:15:54,959 --> 00:15:57,360
this process and also some informations

364
00:15:57,360 --> 00:15:59,680
if some memory allocation is

365
00:15:59,680 --> 00:16:02,720
backed by some file is it

366
00:16:02,720 --> 00:16:06,320
private or is it a shared allocation and

367
00:16:06,320 --> 00:16:10,000
for instance it allows us to determine

368
00:16:10,000 --> 00:16:13,120
whether this belongs to some dll or some

369
00:16:13,120 --> 00:16:15,920
executable

370
00:16:16,480 --> 00:16:19,839
so yeah what if we don't have

371
00:16:19,839 --> 00:16:22,639
any pointer provided as an argument so

372
00:16:22,639 --> 00:16:24,079
for instance

373
00:16:24,079 --> 00:16:27,600
if we want to create a character

374
00:16:27,600 --> 00:16:30,720
based on the anti-terminate process

375
00:16:30,720 --> 00:16:33,680
it's not a memory related system call we

376
00:16:33,680 --> 00:16:34,880
don't have any

377
00:16:34,880 --> 00:16:38,320
memory related pointer passed

378
00:16:38,320 --> 00:16:40,480
as an argument to this system call but

379
00:16:40,480 --> 00:16:41,360
it's still

380
00:16:41,360 --> 00:16:45,040
interesting to inspect who called the

381
00:16:45,040 --> 00:16:47,839
anti-terminate process system call and

382
00:16:47,839 --> 00:16:48,560
the

383
00:16:48,560 --> 00:16:51,680
answer here is to simply perform the

384
00:16:51,680 --> 00:16:54,880
stack work so how to perform the stack

385
00:16:54,880 --> 00:16:55,759
work

386
00:16:55,759 --> 00:16:59,040
knowing the cpu context inside the cisco

387
00:16:59,040 --> 00:16:59,519
because

388
00:16:59,519 --> 00:17:03,680
we are breaking the process

389
00:17:03,680 --> 00:17:06,959
inside the cisco so we need to

390
00:17:06,959 --> 00:17:10,160
find where is the user land part of the

391
00:17:10,160 --> 00:17:11,839
stack what is the

392
00:17:11,839 --> 00:17:15,119
value of the rsp on the user land

393
00:17:15,119 --> 00:17:18,720
so what value would be restored

394
00:17:18,720 --> 00:17:21,039
when we are back in the user mode and

395
00:17:21,039 --> 00:17:23,919
for 64 bit the situation is pretty

396
00:17:23,919 --> 00:17:26,079
straightforward because we have

397
00:17:26,079 --> 00:17:28,319
k thread structure in which we have a

398
00:17:28,319 --> 00:17:29,600
trap frame

399
00:17:29,600 --> 00:17:33,120
containing the rsp value

400
00:17:33,120 --> 00:17:35,440
and we are run and if we are running

401
00:17:35,440 --> 00:17:36,720
that 32

402
00:17:36,720 --> 00:17:40,640
bit sample on the windows which is

403
00:17:40,640 --> 00:17:43,840
64 bit then we have to deal with such

404
00:17:43,840 --> 00:17:47,039
strange thing as a windows and windows

405
00:17:47,039 --> 00:17:47,440
and

406
00:17:47,440 --> 00:17:50,240
we have to inspect the windows and

407
00:17:50,240 --> 00:17:52,160
windows context structure which is

408
00:17:52,160 --> 00:17:53,440
actually hidden

409
00:17:53,440 --> 00:17:56,960
inside tls slots in threat environment

410
00:17:56,960 --> 00:17:58,640
block and it's not

411
00:17:58,640 --> 00:18:02,559
really well documented

412
00:18:02,720 --> 00:18:05,679
so since we know where is the user land

413
00:18:05,679 --> 00:18:06,960
part of the stack

414
00:18:06,960 --> 00:18:10,320
we have to unwind the stack in order to

415
00:18:10,320 --> 00:18:13,919
know what functions were on the stack

416
00:18:13,919 --> 00:18:15,280
and we were researching

417
00:18:15,280 --> 00:18:19,840
many different methods to establish

418
00:18:19,840 --> 00:18:23,200
how to unwind stack reliably

419
00:18:23,200 --> 00:18:26,440
in a way that would work for both

420
00:18:26,440 --> 00:18:29,840
x86 and x64

421
00:18:29,840 --> 00:18:32,320
and actually it turned out that the best

422
00:18:32,320 --> 00:18:34,160
method is just to

423
00:18:34,160 --> 00:18:37,120
go through the stack and take everything

424
00:18:37,120 --> 00:18:39,760
which looks like a pointer

425
00:18:39,760 --> 00:18:42,960
check if it points to the valid range of

426
00:18:42,960 --> 00:18:44,320
the memory and if it

427
00:18:44,320 --> 00:18:48,000
points to the executable page page and

428
00:18:48,000 --> 00:18:52,799
simply treat it as a stack entry

429
00:18:54,720 --> 00:18:56,960
about user mode hooking first thing to

430
00:18:56,960 --> 00:18:57,760
mention

431
00:18:57,760 --> 00:19:00,799
is how drag roof works

432
00:19:00,799 --> 00:19:03,600
it uses ept extended patch table

433
00:19:03,600 --> 00:19:04,240
mechanism

434
00:19:04,240 --> 00:19:09,679
in intel processors to transparently map

435
00:19:09,679 --> 00:19:12,720
guest memory to host memory and it has

436
00:19:12,720 --> 00:19:14,320
some additional features

437
00:19:14,320 --> 00:19:16,640
like additional privileges on this

438
00:19:16,640 --> 00:19:18,000
memory

439
00:19:18,000 --> 00:19:20,559
and when we add breakpoint on some

440
00:19:20,559 --> 00:19:21,600
memory page

441
00:19:21,600 --> 00:19:24,880
it gets cloned we have as you can see

442
00:19:24,880 --> 00:19:26,720
the original

443
00:19:26,720 --> 00:19:29,120
page the green one and the copy with

444
00:19:29,120 --> 00:19:30,320
breakpoint

445
00:19:30,320 --> 00:19:33,840
and by default it points to

446
00:19:33,840 --> 00:19:36,880
this only executable red page

447
00:19:36,880 --> 00:19:39,840
and when the process tries to reach from

448
00:19:39,840 --> 00:19:42,000
something from it

449
00:19:42,000 --> 00:19:44,400
we have exception because there is no

450
00:19:44,400 --> 00:19:45,679
read privilege

451
00:19:45,679 --> 00:19:48,640
and it gets switched to the original one

452
00:19:48,640 --> 00:19:49,120
which

453
00:19:49,120 --> 00:19:51,520
doesn't have this brey point it's it's

454
00:19:51,520 --> 00:19:53,840
single steps only for this read or write

455
00:19:53,840 --> 00:19:54,960
instruction

456
00:19:54,960 --> 00:19:57,679
and then change back to this execute

457
00:19:57,679 --> 00:19:59,280
only which makes

458
00:19:59,280 --> 00:20:02,720
our which makes our breakpoints

459
00:20:02,720 --> 00:20:06,080
undetectable and transfer and

460
00:20:06,080 --> 00:20:09,360
constant because if some someone wants

461
00:20:09,360 --> 00:20:11,039
to write on them

462
00:20:11,039 --> 00:20:14,080
they will be placed back

463
00:20:14,080 --> 00:20:17,200
so why do we want to have user mode

464
00:20:17,200 --> 00:20:17,679
hooks

465
00:20:17,679 --> 00:20:21,280
when we have the better system

466
00:20:21,280 --> 00:20:26,559
called hooks basically we are analyzing

467
00:20:26,559 --> 00:20:29,600
user mode malware so it's

468
00:20:29,600 --> 00:20:32,080
closer to us to have hooks on user mode

469
00:20:32,080 --> 00:20:33,760
calls

470
00:20:33,760 --> 00:20:36,799
and sometimes it's possible to extract

471
00:20:36,799 --> 00:20:38,480
some information

472
00:20:38,480 --> 00:20:42,080
from system calls on what

473
00:20:42,080 --> 00:20:45,840
user mode calls were called on some

474
00:20:45,840 --> 00:20:46,720
sequences

475
00:20:46,720 --> 00:20:50,480
or some side channel read or writes but

476
00:20:50,480 --> 00:20:53,760
it's not clear it's a hacky way

477
00:20:53,760 --> 00:20:56,240
so we wanted to make it clear clear

478
00:20:56,240 --> 00:20:57,760
approach

479
00:20:57,760 --> 00:21:01,200
and two most important factors

480
00:21:01,200 --> 00:21:04,799
are that there are some user mode calls

481
00:21:04,799 --> 00:21:07,679
for example in crypto api that do not

482
00:21:07,679 --> 00:21:08,880
call any

483
00:21:08,880 --> 00:21:12,080
system calls and

484
00:21:12,080 --> 00:21:15,520
last but not least we can have

485
00:21:15,520 --> 00:21:19,200
full behavioral analysis so list of all

486
00:21:19,200 --> 00:21:22,400
user mode calls that were called

487
00:21:22,400 --> 00:21:25,600
which is helpful for analytics that

488
00:21:25,600 --> 00:21:28,480
might not understand everything from a

489
00:21:28,480 --> 00:21:29,200
list of

490
00:21:29,200 --> 00:21:32,320
clear system calls

491
00:21:32,880 --> 00:21:36,000
and a short demo we have a short

492
00:21:36,000 --> 00:21:37,039
application

493
00:21:37,039 --> 00:21:40,720
that generates random sequence using

494
00:21:40,720 --> 00:21:45,840
crypto api

495
00:21:47,600 --> 00:21:49,840
as you can see some random sequence

496
00:21:49,840 --> 00:21:51,679
random sequence

497
00:21:51,679 --> 00:21:54,480
it's clear virtual machine with no agent

498
00:21:54,480 --> 00:21:55,280
inside

499
00:21:55,280 --> 00:21:58,320
and from hypervisor level we're

500
00:21:58,320 --> 00:22:01,440
starting some specific version of drag

501
00:22:01,440 --> 00:22:02,240
wolf

502
00:22:02,240 --> 00:22:04,720
and see it now it's a little bit less

503
00:22:04,720 --> 00:22:05,919
random

504
00:22:05,919 --> 00:22:09,360
so nice trick it might be helpful

505
00:22:09,360 --> 00:22:15,039
to understand what are our possibilities

506
00:22:22,000 --> 00:22:24,320
okay so we'll start we need the we need

507
00:22:24,320 --> 00:22:25,600
to find a place

508
00:22:25,600 --> 00:22:28,320
where the dlrs are loaded unfortunately

509
00:22:28,320 --> 00:22:29,600
we don't have cisco

510
00:22:29,600 --> 00:22:32,799
loads dll the closest matches are this

511
00:22:32,799 --> 00:22:34,960
to cisco score correspondently to

512
00:22:34,960 --> 00:22:38,240
64 and 32-bit applications

513
00:22:38,240 --> 00:22:40,960
every time the the other is loaded those

514
00:22:40,960 --> 00:22:41,679
two

515
00:22:41,679 --> 00:22:44,960
one of those two ciscos is called

516
00:22:44,960 --> 00:22:48,720
and in this point we know that dll is

517
00:22:48,720 --> 00:22:49,919
loaded

518
00:22:49,919 --> 00:22:52,159
but in a lazy way it's not mapped to

519
00:22:52,159 --> 00:22:54,159
physical memory yet

520
00:22:54,159 --> 00:22:56,640
dragwoof unfortunately can only operate

521
00:22:56,640 --> 00:22:58,320
on physical memory

522
00:22:58,320 --> 00:23:01,440
so we can't just place hook on virtual

523
00:23:01,440 --> 00:23:02,720
memory

524
00:23:02,720 --> 00:23:06,640
we need to make sure we had a page fault

525
00:23:06,640 --> 00:23:09,840
and the physical memory was populated

526
00:23:09,840 --> 00:23:12,640
so we had several approaches to solving

527
00:23:12,640 --> 00:23:14,080
this problem

528
00:23:14,080 --> 00:23:17,200
first one was to hook rights to

529
00:23:17,200 --> 00:23:21,039
page table see if

530
00:23:21,039 --> 00:23:24,480
the right was to the memory that

531
00:23:24,480 --> 00:23:27,679
interests us so that

532
00:23:27,679 --> 00:23:30,159
it it's been populated and if so place

533
00:23:30,159 --> 00:23:31,120
the hook

534
00:23:31,120 --> 00:23:34,159
in in this place and

535
00:23:34,159 --> 00:23:36,159
this approach worked pretty well but the

536
00:23:36,159 --> 00:23:38,000
code is complicated

537
00:23:38,000 --> 00:23:41,440
because of four level page table in

538
00:23:41,440 --> 00:23:44,559
windows and it was very slow because

539
00:23:44,559 --> 00:23:47,840
page false happened very often in

540
00:23:47,840 --> 00:23:52,240
real life second approach

541
00:23:52,240 --> 00:23:55,279
was to manually inject

542
00:23:55,279 --> 00:23:59,840
page fault by placing some code that

543
00:23:59,840 --> 00:24:02,480
makes the read from in interesting

544
00:24:02,480 --> 00:24:03,279
memory

545
00:24:03,279 --> 00:24:06,480
place make a single step on it

546
00:24:06,480 --> 00:24:10,880
then recover the state of processor that

547
00:24:10,880 --> 00:24:12,400
that we saved before calling this

548
00:24:12,400 --> 00:24:15,840
instruction and

549
00:24:15,840 --> 00:24:19,279
and continue execution and this

550
00:24:19,279 --> 00:24:23,200
approach was very fast but unfortunately

551
00:24:23,200 --> 00:24:26,720
unstable invasive i think it would be

552
00:24:26,720 --> 00:24:29,840
easy easy to detect by malware and

553
00:24:29,840 --> 00:24:32,400
hard to implement in drag wolf because

554
00:24:32,400 --> 00:24:33,840
it

555
00:24:33,840 --> 00:24:37,279
it uses single steps in itself so

556
00:24:37,279 --> 00:24:40,559
it was hard to make a single step

557
00:24:40,559 --> 00:24:43,840
and what was our first third approach it

558
00:24:43,840 --> 00:24:48,080
wasn't actually ours we just saw that

559
00:24:48,080 --> 00:24:51,200
somebody made a comment to libsy mi

560
00:24:51,200 --> 00:24:53,919
and ma and made it for us so that we

561
00:24:53,919 --> 00:24:55,679
could easily

562
00:24:55,679 --> 00:24:58,960
place page false

563
00:24:58,960 --> 00:25:02,240
in hypervisor level

564
00:25:02,240 --> 00:25:05,279
and it was stable fast somebody did for

565
00:25:05,279 --> 00:25:06,080
us

566
00:25:06,080 --> 00:25:09,120
perfect we lost like two two

567
00:25:09,120 --> 00:25:12,840
months of work and the problem solved

568
00:25:12,840 --> 00:25:15,840
itself

569
00:25:16,000 --> 00:25:19,120
okay so we're inside the

570
00:25:19,120 --> 00:25:21,440
syscall that loads our dll we parse the

571
00:25:21,440 --> 00:25:22,159
pe

572
00:25:22,159 --> 00:25:26,400
the header read the export directory

573
00:25:26,400 --> 00:25:28,640
if it's not accessible we put a petrol

574
00:25:28,640 --> 00:25:29,679
on it

575
00:25:29,679 --> 00:25:32,880
then we try to place a hook

576
00:25:32,880 --> 00:25:36,559
on function if it's not accessible

577
00:25:36,559 --> 00:25:37,600
either

578
00:25:37,600 --> 00:25:40,840
we put a patchful on it and finally put

579
00:25:40,840 --> 00:25:44,158
our hook

580
00:25:44,799 --> 00:25:47,360
some problems

581
00:25:48,559 --> 00:25:51,760
the export the the export directory made

582
00:25:51,760 --> 00:25:54,720
might be corrupted and placing a patch

583
00:25:54,720 --> 00:25:55,600
fold

584
00:25:55,600 --> 00:25:59,440
on it would then crush the the system

585
00:25:59,440 --> 00:26:03,360
as a whole but we can

586
00:26:03,360 --> 00:26:07,679
hook handler for blue screens in windows

587
00:26:07,679 --> 00:26:10,799
and pretend nothing happened

588
00:26:10,799 --> 00:26:13,679
so before placing the page fault we put

589
00:26:13,679 --> 00:26:14,240
a flag

590
00:26:14,240 --> 00:26:17,679
that we're messing with something and

591
00:26:17,679 --> 00:26:20,559
in this handler we're checking if it's

592
00:26:20,559 --> 00:26:22,080
our fault and if so

593
00:26:22,080 --> 00:26:26,000
we're just silently continuing execution

594
00:26:26,000 --> 00:26:28,080
if it's not our fault we just pass the

595
00:26:28,080 --> 00:26:31,840
execution and show the blue screen

596
00:26:32,240 --> 00:26:35,279
another problem remember the ramkos

597
00:26:35,279 --> 00:26:36,320
mower that

598
00:26:36,320 --> 00:26:39,520
took down the hooks

599
00:26:39,520 --> 00:26:43,520
in in this case it it would not be

600
00:26:43,520 --> 00:26:46,320
taken down but in windows we have copy

601
00:26:46,320 --> 00:26:48,080
and write mechanism

602
00:26:48,080 --> 00:26:51,279
so the dealers are shared between

603
00:26:51,279 --> 00:26:53,360
processes

604
00:26:53,360 --> 00:26:57,600
and if if some process wants to

605
00:26:57,600 --> 00:27:01,120
make a write on its own dll the shared

606
00:27:01,120 --> 00:27:04,080
page physical page is copied to another

607
00:27:04,080 --> 00:27:05,039
place

608
00:27:05,039 --> 00:27:09,840
and unfortunately we will lose our hook

609
00:27:09,840 --> 00:27:13,360
so we can hook function that is

610
00:27:13,360 --> 00:27:16,799
responsible for copy on right and

611
00:27:16,799 --> 00:27:20,880
see if the page that is currently copied

612
00:27:20,880 --> 00:27:24,240
contains some hooks and if so place the

613
00:27:24,240 --> 00:27:27,440
hooks on the new page

614
00:27:27,520 --> 00:27:29,440
and the best test program for us was

615
00:27:29,440 --> 00:27:31,039
internet explorer that does

616
00:27:31,039 --> 00:27:33,600
almost everything that is allowed in

617
00:27:33,600 --> 00:27:34,240
windows

618
00:27:34,240 --> 00:27:37,440
including writing on its own dls

619
00:27:37,440 --> 00:27:40,080
so on the top you can see the message

620
00:27:40,080 --> 00:27:41,279
box functions

621
00:27:41,279 --> 00:27:44,960
function from user32 dll

622
00:27:44,960 --> 00:27:48,080
and on the bottom you can see the same

623
00:27:48,080 --> 00:27:51,840
function in internal explorer execution

624
00:27:51,840 --> 00:27:53,840
as you can see it passes the execution

625
00:27:53,840 --> 00:27:55,919
to its own code

626
00:27:55,919 --> 00:27:58,080
and on the left you can see the original

627
00:27:58,080 --> 00:27:59,279
code and

628
00:27:59,279 --> 00:28:03,039
on the right the hooked code

629
00:28:03,039 --> 00:28:07,120
by internet explorer so it behaves

630
00:28:07,120 --> 00:28:10,240
just like malware and

631
00:28:10,240 --> 00:28:13,360
here's the list of dlls hooked by

632
00:28:13,360 --> 00:28:15,840
internet explorer

633
00:28:15,840 --> 00:28:18,880
we didn't know why why tries to do it do

634
00:28:18,880 --> 00:28:20,799
this why internet explorer behaves like

635
00:28:20,799 --> 00:28:22,720
malware

636
00:28:22,720 --> 00:28:26,159
now i can say it's shim mechanism

637
00:28:26,159 --> 00:28:29,679
that is used for compatibility so

638
00:28:29,679 --> 00:28:32,799
internet explorer has its own better

639
00:28:32,799 --> 00:28:35,440
apis

640
00:28:38,240 --> 00:28:41,200
so right now let's use our user mode

641
00:28:41,200 --> 00:28:42,720
hooking features in some

642
00:28:42,720 --> 00:28:47,520
funny and i hope illustrative way

643
00:28:47,520 --> 00:28:51,279
we have again we have clean windows 7 vm

644
00:28:51,279 --> 00:28:54,159
with heroes of might and magic 3

645
00:28:54,159 --> 00:28:58,159
installed in it and it is monitored by

646
00:28:58,159 --> 00:28:59,360
dracuff

647
00:28:59,360 --> 00:29:02,799
and we could see that drackwoof could

648
00:29:02,799 --> 00:29:06,080
detect in this case how much money we

649
00:29:06,080 --> 00:29:08,799
currently have in heroes of might and

650
00:29:08,799 --> 00:29:10,840
magic

651
00:29:10,840 --> 00:29:14,159
3. so yeah we could see that we are

652
00:29:14,159 --> 00:29:16,880
gaining additional null money by passing

653
00:29:16,880 --> 00:29:18,720
the turn which is a normal thing in

654
00:29:18,720 --> 00:29:21,039
heroes of might and magic free

655
00:29:21,039 --> 00:29:23,840
and we also can set the amount of money

656
00:29:23,840 --> 00:29:25,440
we would like to have at the moment

657
00:29:25,440 --> 00:29:28,480
using the volume bar

658
00:29:28,480 --> 00:29:31,840
of the windows explorer so that's

659
00:29:31,840 --> 00:29:32,720
basically

660
00:29:32,720 --> 00:29:35,600
detected by our external monitoring

661
00:29:35,600 --> 00:29:38,080
program and then the memory of heroes 3

662
00:29:38,080 --> 00:29:41,840
is altered

663
00:29:47,200 --> 00:29:49,520
so after solving all the problems

664
00:29:49,520 --> 00:29:52,000
previously mentioned we've created the

665
00:29:52,000 --> 00:29:54,080
another project called track with

666
00:29:54,080 --> 00:29:56,240
sandbox which is basically

667
00:29:56,240 --> 00:29:58,720
a wrapper for drag wolf containing a web

668
00:29:58,720 --> 00:29:59,919
interface

669
00:29:59,919 --> 00:30:03,120
an easy installation process sample

670
00:30:03,120 --> 00:30:03,600
queue

671
00:30:03,600 --> 00:30:06,960
and all the remaining basic features

672
00:30:06,960 --> 00:30:10,240
you would expect from a simple sandbox

673
00:30:10,240 --> 00:30:13,520
here is the screenshot from one of the

674
00:30:13,520 --> 00:30:16,799
yearly versions of the dragoof sandbox

675
00:30:16,799 --> 00:30:19,919
which displays the win api

676
00:30:19,919 --> 00:30:25,120
logs of some process in a web interface

677
00:30:25,120 --> 00:30:28,799
it's free and fully open source

678
00:30:28,799 --> 00:30:32,000
so we encourage to visit

679
00:30:32,000 --> 00:30:36,159
us on github and to try to play

680
00:30:36,159 --> 00:30:38,399
with a truck with sandbox and any

681
00:30:38,399 --> 00:30:42,239
feedback would be appreciated

682
00:30:42,720 --> 00:30:45,039
we are also constantly researching

683
00:30:45,039 --> 00:30:45,919
whether we could

684
00:30:45,919 --> 00:30:49,679
use additional hardware features to

685
00:30:49,679 --> 00:30:53,440
enhance our existing malware monitoring

686
00:30:53,440 --> 00:30:56,559
process and one of the examples

687
00:30:56,559 --> 00:30:59,679
is intel processor trace

688
00:30:59,679 --> 00:31:02,880
so there was an attempt to implement

689
00:31:02,880 --> 00:31:06,799
the ipt feature support within the zen

690
00:31:06,799 --> 00:31:08,000
hypervisor but

691
00:31:08,000 --> 00:31:11,360
the patches were unfortunately abandoned

692
00:31:11,360 --> 00:31:14,559
so basically we took them after a few

693
00:31:14,559 --> 00:31:15,440
years and

694
00:31:15,440 --> 00:31:19,760
we fixed them and resubmitted them as a

695
00:31:19,760 --> 00:31:22,159
new patch series called implement

696
00:31:22,159 --> 00:31:23,360
support for

697
00:31:23,360 --> 00:31:27,840
external ipt monitoring

698
00:31:27,840 --> 00:31:30,399
this is the path of our further research

699
00:31:30,399 --> 00:31:31,360
and

700
00:31:31,360 --> 00:31:35,600
more details will be coming soon

701
00:31:36,320 --> 00:31:39,760
so to summarize i would like to highly

702
00:31:39,760 --> 00:31:41,279
encourage you to try

703
00:31:41,279 --> 00:31:43,760
all the open source projects we were

704
00:31:43,760 --> 00:31:44,799
contributing

705
00:31:44,799 --> 00:31:48,159
into while making the described solution

706
00:31:48,159 --> 00:31:50,880
and i would also like to say thank you

707
00:31:50,880 --> 00:31:51,440
to the

708
00:31:51,440 --> 00:31:55,360
cert pl reverse engineers nazivam pasrok

709
00:31:55,360 --> 00:31:56,159
yadan and

710
00:31:56,159 --> 00:32:00,000
msm for important remarks and hints

711
00:32:00,000 --> 00:32:02,399
about malware monitoring

712
00:32:02,399 --> 00:32:06,240
also special thanks for bonus tivai

713
00:32:06,240 --> 00:32:08,480
and constanti which are search pl

714
00:32:08,480 --> 00:32:09,919
developers

715
00:32:09,919 --> 00:32:12,320
for helping us with the further

716
00:32:12,320 --> 00:32:14,240
development of track wolf

717
00:32:14,240 --> 00:32:17,519
and drag wolf sandbox moreover i would

718
00:32:17,519 --> 00:32:18,320
like to

719
00:32:18,320 --> 00:32:20,960
say thank you to mati kotovic for

720
00:32:20,960 --> 00:32:22,000
providing

721
00:32:22,000 --> 00:32:24,000
many good characteristics for memory

722
00:32:24,000 --> 00:32:26,720
dumping and some hints about using them

723
00:32:26,720 --> 00:32:29,679
and to thomas l'engle for the fact he is

724
00:32:29,679 --> 00:32:31,200
a creator

725
00:32:31,200 --> 00:32:33,760
and maintainer of the drakoff project on

726
00:32:33,760 --> 00:32:34,799
github

727
00:32:34,799 --> 00:32:38,320
and many many times he provided

728
00:32:38,320 --> 00:32:41,440
a lot of helpful remarks during our

729
00:32:41,440 --> 00:32:43,600
research

730
00:32:43,600 --> 00:32:46,720
if you would like to access the data

731
00:32:46,720 --> 00:32:50,159
we've shown on the emoted examples

732
00:32:50,159 --> 00:32:53,360
so our malware data the data about the

733
00:32:53,360 --> 00:32:56,159
static configurations of the malware

734
00:32:56,159 --> 00:33:00,480
you could apply at mwdb search pl

735
00:33:00,480 --> 00:33:03,760
we have the free service within which

736
00:33:03,760 --> 00:33:05,919
we share a lot of data about malware

737
00:33:05,919 --> 00:33:07,200
with white hat

738
00:33:07,200 --> 00:33:11,279
external researchers and at this point

739
00:33:11,279 --> 00:33:15,519
i would like to thank you for your

740
00:33:20,360 --> 00:33:23,360
attention

