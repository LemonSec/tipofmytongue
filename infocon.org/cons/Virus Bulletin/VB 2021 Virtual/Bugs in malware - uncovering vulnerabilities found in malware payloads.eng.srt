1
00:00:02,640 --> 00:00:05,819
[Music]

2
00:00:16,160 --> 00:00:17,920
hello and welcome everyone to our

3
00:00:17,920 --> 00:00:19,920
presentation on bugs and malware

4
00:00:19,920 --> 00:00:21,279
covering vulnerabilities found in

5
00:00:21,279 --> 00:00:22,880
malware payloads

6
00:00:22,880 --> 00:00:25,199
my name is nirmal singh i'm working as

7
00:00:25,199 --> 00:00:27,680
director for marvel as in g skiller

8
00:00:27,680 --> 00:00:30,480
and with me i have my colleague

9
00:00:30,480 --> 00:00:32,719
singh who is working as staff security

10
00:00:32,719 --> 00:00:34,800
searcher in g schedule

11
00:00:34,800 --> 00:00:36,719
in this presentation we will be showing

12
00:00:36,719 --> 00:00:39,120
our findings related to coding books in

13
00:00:39,120 --> 00:00:42,239
different malware families

14
00:00:42,399 --> 00:00:46,079
we will first start with the agenda so

15
00:00:46,079 --> 00:00:48,000
the agenda for today's presentation is

16
00:00:48,000 --> 00:00:50,160
as following so we will start with the

17
00:00:50,160 --> 00:00:52,160
introduction and then explaining the

18
00:00:52,160 --> 00:00:54,239
study approach and finally presenting

19
00:00:54,239 --> 00:00:57,199
the different case studies

20
00:00:57,199 --> 00:00:59,120
so we know that malware authors often

21
00:00:59,120 --> 00:01:01,120
take advantage of vulnerabilities

22
00:01:01,120 --> 00:01:03,039
foreign popular

23
00:01:03,039 --> 00:01:04,159
softwares

24
00:01:04,159 --> 00:01:07,200
and they do it uh for alien faction or

25
00:01:07,200 --> 00:01:09,920
they do it for you know developing npvm

26
00:01:09,920 --> 00:01:12,720
and sandbox technologies and sometimes

27
00:01:12,720 --> 00:01:15,119
to bypass the av products and we have

28
00:01:15,119 --> 00:01:17,600
seen that there are a lot of research on

29
00:01:17,600 --> 00:01:18,960
you know on the

30
00:01:18,960 --> 00:01:21,200
on these this side like finding the

31
00:01:21,200 --> 00:01:22,560
vulnerability

32
00:01:22,560 --> 00:01:25,360
from the popular softwares but there is

33
00:01:25,360 --> 00:01:28,000
very less research on finding bugs and

34
00:01:28,000 --> 00:01:30,560
vulnerabilities in the malware side

35
00:01:30,560 --> 00:01:33,200
because malware you know is also

36
00:01:33,200 --> 00:01:36,479
a software and uh it also prone to bugs

37
00:01:36,479 --> 00:01:39,600
and coding errors and uh we can use

38
00:01:39,600 --> 00:01:41,360
those coding errors and bugs and

39
00:01:41,360 --> 00:01:43,520
sometimes those can serve as big back

40
00:01:43,520 --> 00:01:45,600
doors always can serve as back doors for

41
00:01:45,600 --> 00:01:46,880
white hats

42
00:01:46,880 --> 00:01:49,759
and during our study we also found that

43
00:01:49,759 --> 00:01:51,759
there are you know

44
00:01:51,759 --> 00:01:53,200
different bugs and different malware

45
00:01:53,200 --> 00:01:55,680
families they often persist in in a

46
00:01:55,680 --> 00:01:57,920
malware family for a long time so here

47
00:01:57,920 --> 00:02:01,360
we have shown one statistics and this is

48
00:02:01,360 --> 00:02:03,840
uh for six months in

49
00:02:03,840 --> 00:02:04,799
the first

50
00:02:04,799 --> 00:02:07,040
semester of 2021

51
00:02:07,040 --> 00:02:08,878
and we found

52
00:02:08,878 --> 00:02:11,920
nearby 8896

53
00:02:11,920 --> 00:02:13,680
uh malware sample different malware

54
00:02:13,680 --> 00:02:16,319
samples those were crashing in g scalar

55
00:02:16,319 --> 00:02:19,120
cloud sandbox

56
00:02:19,120 --> 00:02:21,760
so if you talk about the purpose of this

57
00:02:21,760 --> 00:02:23,840
research and then the research purpose

58
00:02:23,840 --> 00:02:26,640
is threefold the first one is to look at

59
00:02:26,640 --> 00:02:28,879
what type of vulnerabilities exist in

60
00:02:28,879 --> 00:02:31,200
some of the privileged malware families

61
00:02:31,200 --> 00:02:33,360
and then the second one is you know to

62
00:02:33,360 --> 00:02:35,680
discuss how we can use these bugs

63
00:02:35,680 --> 00:02:38,000
vulnerabilities um

64
00:02:38,000 --> 00:02:40,319
in preventing the malware infection or

65
00:02:40,319 --> 00:02:42,080
how we can use those vulnerabilities for

66
00:02:42,080 --> 00:02:43,840
example for kill chain

67
00:02:43,840 --> 00:02:45,760
and finally uh

68
00:02:45,760 --> 00:02:48,160
to find out whether these uh

69
00:02:48,160 --> 00:02:50,959
vulnerabilities are you know real uh

70
00:02:50,959 --> 00:02:53,200
coding errors near vulnerabilities or

71
00:02:53,200 --> 00:02:57,200
these are just scape mechanisms

72
00:02:57,200 --> 00:02:58,400
okay so

73
00:02:58,400 --> 00:03:01,360
to do the study on this topic so we did

74
00:03:01,360 --> 00:03:04,000
a large scale analysis on data set of

75
00:03:04,000 --> 00:03:06,159
malicious samples that we collected from

76
00:03:06,159 --> 00:03:09,040
cloud sandbox uh g scalar cloud sandbox

77
00:03:09,040 --> 00:03:11,040
using uh a

78
00:03:11,040 --> 00:03:13,519
few different behavior based signatures

79
00:03:13,519 --> 00:03:14,959
in the cloud symbol

80
00:03:14,959 --> 00:03:18,400
so we collected samples from 2019

81
00:03:18,400 --> 00:03:22,080
starting from 2019 to march 2021

82
00:03:22,080 --> 00:03:24,319
and uh then we clustered the samples

83
00:03:24,319 --> 00:03:26,239
some malicious samples using behavior

84
00:03:26,239 --> 00:03:28,400
similarities right like how those were

85
00:03:28,400 --> 00:03:31,200
crashing in the g scalar cloud sandbox

86
00:03:31,200 --> 00:03:34,239
and finally we categorize those one

87
00:03:34,239 --> 00:03:37,599
abilities or works using writer's common

88
00:03:37,599 --> 00:03:40,959
weakness and operation system

89
00:03:40,959 --> 00:03:43,519
okay so let's start with the first case

90
00:03:43,519 --> 00:03:46,000
study and this is related to password

91
00:03:46,000 --> 00:03:49,599
stealer vr and we found multiple uh bugs

92
00:03:49,599 --> 00:03:52,080
or recording errors in this smartphone

93
00:03:52,080 --> 00:03:54,879
and uh vidar is basically uh information

94
00:03:54,879 --> 00:03:57,200
stealing uh uh malware

95
00:03:57,200 --> 00:04:00,080
and it also you know uh steal

96
00:04:00,080 --> 00:04:02,319
information from different digital

97
00:04:02,319 --> 00:04:03,360
wallets

98
00:04:03,360 --> 00:04:06,480
in g scalar cloud we found 94 samples

99
00:04:06,480 --> 00:04:09,519
those were showing execution errors and

100
00:04:09,519 --> 00:04:11,599
here we have shown statistics and you

101
00:04:11,599 --> 00:04:14,799
can see that we found samples those were

102
00:04:14,799 --> 00:04:16,238
crashing in the

103
00:04:16,238 --> 00:04:19,040
cloud sandbox or showing execution

104
00:04:19,040 --> 00:04:20,079
errors

105
00:04:20,079 --> 00:04:21,120
in

106
00:04:21,120 --> 00:04:24,880
february in april and in may and in june

107
00:04:24,880 --> 00:04:26,639
so on different time frames we found

108
00:04:26,639 --> 00:04:29,600
different number of samples

109
00:04:29,600 --> 00:04:32,000
okay so uh let's uh discuss about the

110
00:04:32,000 --> 00:04:34,960
first work that we found in the vidar

111
00:04:34,960 --> 00:04:38,160
and that is uh regarding input check of

112
00:04:38,160 --> 00:04:41,600
function return so here we have uh

113
00:04:41,600 --> 00:04:43,840
one function in the vidar

114
00:04:43,840 --> 00:04:45,520
and the purpose of this function is

115
00:04:45,520 --> 00:04:48,000
basically you know to collect uh stored

116
00:04:48,000 --> 00:04:50,960
passwords in the gsps and as i mentioned

117
00:04:50,960 --> 00:04:52,639
earlier you know the

118
00:04:52,639 --> 00:04:54,240
this is some information stealing the

119
00:04:54,240 --> 00:04:56,479
malware and it sees lot of information

120
00:04:56,479 --> 00:04:57,840
from the system

121
00:04:57,840 --> 00:05:00,560
but the issue in this code is that it

122
00:05:00,560 --> 00:05:03,600
for extracting the password uh you know

123
00:05:03,600 --> 00:05:05,840
from the district key it is using

124
00:05:05,840 --> 00:05:08,160
password key and then it is extracting

125
00:05:08,160 --> 00:05:09,840
or getting the registry value of that

126
00:05:09,840 --> 00:05:11,600
using get

127
00:05:11,600 --> 00:05:13,759
rich get value api

128
00:05:13,759 --> 00:05:15,120
and

129
00:05:15,120 --> 00:05:17,520
here we can see that this after this

130
00:05:17,520 --> 00:05:19,840
call the malware code is not checking

131
00:05:19,840 --> 00:05:22,320
the return code well it's not verifying

132
00:05:22,320 --> 00:05:25,199
whether the call to this particular apa

133
00:05:25,199 --> 00:05:27,680
was successful or not right and then

134
00:05:27,680 --> 00:05:30,000
it's directly passing whatever value it

135
00:05:30,000 --> 00:05:32,800
gets from from this call whether it is

136
00:05:32,800 --> 00:05:34,960
just a null string right it's directly

137
00:05:34,960 --> 00:05:37,199
passing to this function so uh the

138
00:05:37,199 --> 00:05:39,039
purpose of this function is basically to

139
00:05:39,039 --> 00:05:40,800
decrypt the password because the

140
00:05:40,800 --> 00:05:42,240
password and the gesture key will be

141
00:05:42,240 --> 00:05:44,320
stored as encrypted in an encrypted form

142
00:05:44,320 --> 00:05:48,400
right so we found that if the value of

143
00:05:48,400 --> 00:05:50,400
this particular registry key is set to

144
00:05:50,400 --> 00:05:51,199
null

145
00:05:51,199 --> 00:05:53,840
then it will crash so it will crash with

146
00:05:53,840 --> 00:05:54,880
our sample

147
00:05:54,880 --> 00:05:58,800
so uh we categorize this bug uh as of uh

148
00:05:58,800 --> 00:06:01,759
cwe 253 and

149
00:06:01,759 --> 00:06:04,639
it has the the this uh

150
00:06:04,639 --> 00:06:06,880
i mean this category is defines like it

151
00:06:06,880 --> 00:06:10,000
has consequences such as unexpected

152
00:06:10,000 --> 00:06:13,199
state ddos you know crash exit or

153
00:06:13,199 --> 00:06:15,759
restart the system

154
00:06:15,759 --> 00:06:18,840
okay now let's move to the second case

155
00:06:18,840 --> 00:06:21,039
study second book in the first case

156
00:06:21,039 --> 00:06:23,520
study that is later to be done and

157
00:06:23,520 --> 00:06:26,080
that is regarding uh when the malware is

158
00:06:26,080 --> 00:06:29,199
trying to you know get the data from cnt

159
00:06:29,199 --> 00:06:31,759
cnc server but it is using the same

160
00:06:31,759 --> 00:06:33,759
buffer for downloading you know the full

161
00:06:33,759 --> 00:06:36,080
data so here we can see that it is

162
00:06:36,080 --> 00:06:38,960
trying to download near what 2 kb data

163
00:06:38,960 --> 00:06:42,000
from cnc server and this is a loop and

164
00:06:42,000 --> 00:06:44,319
in this loop it is using internet read

165
00:06:44,319 --> 00:06:45,600
file api

166
00:06:45,600 --> 00:06:46,800
and

167
00:06:46,800 --> 00:06:49,039
here we can see that it is using the

168
00:06:49,039 --> 00:06:52,479
same buffer you know uh in in the loop

169
00:06:52,479 --> 00:06:55,199
so if the data is more than what is

170
00:06:55,199 --> 00:06:57,360
defined here uh meaning like if it's

171
00:06:57,360 --> 00:07:00,000
more than uh 2kb then

172
00:07:00,000 --> 00:07:02,000
the mod this code will use the same

173
00:07:02,000 --> 00:07:05,120
buffer right and later on uh the malware

174
00:07:05,120 --> 00:07:07,759
will not be able to find the information

175
00:07:07,759 --> 00:07:09,599
that it is required so it's kind of like

176
00:07:09,599 --> 00:07:12,400
corrupting uh the data that is getting

177
00:07:12,400 --> 00:07:14,639
uh from the cnc server

178
00:07:14,639 --> 00:07:17,280
so we can categorize this uh

179
00:07:17,280 --> 00:07:21,280
bug as cwe seven eight at seven uh

180
00:07:21,280 --> 00:07:23,759
and it is uh later to where uh malware

181
00:07:23,759 --> 00:07:26,560
writes uh data past the end of buffer

182
00:07:26,560 --> 00:07:28,880
which results into caption of data crash

183
00:07:28,880 --> 00:07:31,840
or code execution

184
00:07:31,840 --> 00:07:32,720
okay

185
00:07:32,720 --> 00:07:35,599
uh and the final bug that we found in

186
00:07:35,599 --> 00:07:38,160
vidar was related to when it is trying

187
00:07:38,160 --> 00:07:41,199
to find you know a string which is not

188
00:07:41,199 --> 00:07:43,440
present in the config data so here we

189
00:07:43,440 --> 00:07:45,440
can see in this first step it is

190
00:07:45,440 --> 00:07:48,080
downloading the config data from cnc

191
00:07:48,080 --> 00:07:49,360
server

192
00:07:49,360 --> 00:07:53,039
and then it is using find str location

193
00:07:53,039 --> 00:07:54,080
function

194
00:07:54,080 --> 00:07:57,360
to find the field uh value so meaning

195
00:07:57,360 --> 00:08:00,560
like here it is search of trying to find

196
00:08:00,560 --> 00:08:04,240
abort string in the uh cnc data

197
00:08:04,240 --> 00:08:06,960
and this function basically the find str

198
00:08:06,960 --> 00:08:09,520
location function will basically return

199
00:08:09,520 --> 00:08:11,520
uh minus one

200
00:08:11,520 --> 00:08:13,919
if the string is not formed right so

201
00:08:13,919 --> 00:08:16,319
here we can see that if the string is

202
00:08:16,319 --> 00:08:19,360
formed then it will go inside the loop

203
00:08:19,360 --> 00:08:21,599
sorry inside the if statement

204
00:08:21,599 --> 00:08:23,520
and then it will

205
00:08:23,520 --> 00:08:25,440
use string token

206
00:08:25,440 --> 00:08:29,840
str token function to find further uh

207
00:08:29,840 --> 00:08:31,039
you know the

208
00:08:31,039 --> 00:08:33,120
fields in the

209
00:08:33,120 --> 00:08:34,320
buffer

210
00:08:34,320 --> 00:08:35,039
but

211
00:08:35,039 --> 00:08:37,039
here we can see that if the string is

212
00:08:37,039 --> 00:08:40,399
not found then it is directly jumping to

213
00:08:40,399 --> 00:08:43,200
crash here meaning like it is it is

214
00:08:43,200 --> 00:08:45,600
jumping here the execution will come

215
00:08:45,600 --> 00:08:48,160
here and then here we can see that it's

216
00:08:48,160 --> 00:08:50,399
using string token

217
00:08:50,399 --> 00:08:53,519
uh variable but this will not be this

218
00:08:53,519 --> 00:08:56,720
will be uh you know null because the

219
00:08:56,720 --> 00:08:58,720
string uh because

220
00:08:58,720 --> 00:08:59,839
this

221
00:08:59,839 --> 00:09:03,040
variable is assigned a value inside the

222
00:09:03,040 --> 00:09:06,640
if statement right so this will be uh

223
00:09:06,640 --> 00:09:08,240
this variable will contain unknown

224
00:09:08,240 --> 00:09:10,880
signed value and that will result in

225
00:09:10,880 --> 00:09:12,640
crashing the sample

226
00:09:12,640 --> 00:09:18,000
and we categorize this uh bug as cwe 390

227
00:09:18,000 --> 00:09:18,720
and

228
00:09:18,720 --> 00:09:20,640
this is regarding where the marker

229
00:09:20,640 --> 00:09:22,880
detects an error but doesn't perform any

230
00:09:22,880 --> 00:09:25,600
action to prevent the consequences of it

231
00:09:25,600 --> 00:09:28,240
which may result in sample crash

232
00:09:28,240 --> 00:09:31,279
so uh from here i will hand over to uday

233
00:09:31,279 --> 00:09:34,160
for covering rest of the case studies uh

234
00:09:34,160 --> 00:09:36,480
thank you nimal for this wonderful

235
00:09:36,480 --> 00:09:39,760
introduction and uh now i will start

236
00:09:39,760 --> 00:09:42,320
from case 32 which is like a

237
00:09:42,320 --> 00:09:45,279
incorrect calculation of buffer size so

238
00:09:45,279 --> 00:09:47,200
here you will take the

239
00:09:47,200 --> 00:09:50,000
case study of a downloader malware

240
00:09:50,000 --> 00:09:53,680
rugby which is seen downloading ads like

241
00:09:53,680 --> 00:09:56,240
ramco's and other type of ads

242
00:09:56,240 --> 00:09:59,120
for malware so we saw approximately 15

243
00:09:59,120 --> 00:10:01,360
plus samples for this malware and it was

244
00:10:01,360 --> 00:10:04,720
active around february and march 2021 so

245
00:10:04,720 --> 00:10:06,240
you can say this is a very recent

246
00:10:06,240 --> 00:10:07,360
molecule

247
00:10:07,360 --> 00:10:10,320
so this follower what does it it does

248
00:10:10,320 --> 00:10:12,880
like it usually download a png file from

249
00:10:12,880 --> 00:10:15,519
umgo.com which contains configuration

250
00:10:15,519 --> 00:10:17,600
data and a payload file

251
00:10:17,600 --> 00:10:20,320
so the data inside the png file is

252
00:10:20,320 --> 00:10:22,240
compressed and encrypted

253
00:10:22,240 --> 00:10:25,600
and the decryption logic assumes that

254
00:10:25,600 --> 00:10:28,079
the size of the uncompressed data will

255
00:10:28,079 --> 00:10:30,079
be four times of the size

256
00:10:30,079 --> 00:10:32,959
so it will allocate a memory accordingly

257
00:10:32,959 --> 00:10:36,880
so that code should will show next slide

258
00:10:36,880 --> 00:10:38,800
so you can see here

259
00:10:38,800 --> 00:10:41,440
uh this one this line uh

260
00:10:41,440 --> 00:10:44,720
it is calling cat files guys then if we

261
00:10:44,720 --> 00:10:47,600
go next uh it is uh moving that thing

262
00:10:47,600 --> 00:10:50,160
and then loading that uh file size into

263
00:10:50,160 --> 00:10:52,640
four that i said earlier into esi

264
00:10:52,640 --> 00:10:53,839
register

265
00:10:53,839 --> 00:10:56,560
and allocate memory accordingly uh you

266
00:10:56,560 --> 00:10:58,640
can see it is uh allocating to virtual

267
00:10:58,640 --> 00:11:00,640
lock that's a normal

268
00:11:00,640 --> 00:11:02,880
function to allocate memory and pushing

269
00:11:02,880 --> 00:11:04,640
esa as an argument

270
00:11:04,640 --> 00:11:06,000
so

271
00:11:06,000 --> 00:11:07,839
when it was sometime what happened the

272
00:11:07,839 --> 00:11:10,000
file size is greater than that so it

273
00:11:10,000 --> 00:11:11,680
will be something like that buffer

274
00:11:11,680 --> 00:11:13,120
overflow issue

275
00:11:13,120 --> 00:11:15,519
so if we go

276
00:11:15,519 --> 00:11:17,600
ahead you you will see that there is an

277
00:11:17,600 --> 00:11:20,959
extra violation while writing on this

278
00:11:20,959 --> 00:11:24,480
location so this is a classic uh buffer

279
00:11:24,480 --> 00:11:26,800
overflow issue so we will categorize

280
00:11:26,800 --> 00:11:30,399
this under cw 131 so you can say it

281
00:11:30,399 --> 00:11:32,000
means it is states like

282
00:11:32,000 --> 00:11:33,680
it leads an out of bound rate right

283
00:11:33,680 --> 00:11:38,480
possibly contrast sometimes if one can

284
00:11:38,480 --> 00:11:40,720
exploit it properly it may allow

285
00:11:40,720 --> 00:11:43,440
arbitrary code execution or expose

286
00:11:43,440 --> 00:11:45,600
sensitive data as well

287
00:11:45,600 --> 00:11:48,240
next slide name at least

288
00:11:48,240 --> 00:11:51,519
so if now we come to case study three

289
00:11:51,519 --> 00:11:54,480
this is like a

290
00:11:54,800 --> 00:11:57,920
some type of compilation bug you can say

291
00:11:57,920 --> 00:12:00,240
this is like a loading unvalidated

292
00:12:00,240 --> 00:12:02,639
relocation table so let's take an

293
00:12:02,639 --> 00:12:05,360
example uh suppose we write a code of a

294
00:12:05,360 --> 00:12:08,320
dll we compile it we compile it of

295
00:12:08,320 --> 00:12:10,880
several flags nowadays like okay like we

296
00:12:10,880 --> 00:12:12,720
have been able to ep we have to enable

297
00:12:12,720 --> 00:12:16,240
aslr same similarly we have to tell that

298
00:12:16,240 --> 00:12:18,720
okay we will have a relocation table

299
00:12:18,720 --> 00:12:21,120
so uh

300
00:12:21,120 --> 00:12:22,720
what is the bug that i will describe

301
00:12:22,720 --> 00:12:24,720
later firstly let me introduce which

302
00:12:24,720 --> 00:12:26,480
small bit

303
00:12:26,480 --> 00:12:29,440
it has a another uh dual loader malware

304
00:12:29,440 --> 00:12:32,480
it is a very famous malware which is

305
00:12:32,480 --> 00:12:34,399
which used to download somewhere in

306
00:12:34,399 --> 00:12:36,720
banking malware and it

307
00:12:36,720 --> 00:12:37,519
is

308
00:12:37,519 --> 00:12:39,440
a really really active one

309
00:12:39,440 --> 00:12:42,800
so we found the again 19 sample

310
00:12:42,800 --> 00:12:46,320
which was showing crash due to this bug

311
00:12:46,320 --> 00:12:48,639
so let me describe the

312
00:12:48,639 --> 00:12:50,639
working of this malware

313
00:12:50,639 --> 00:12:53,120
the for installation on this uh

314
00:12:53,120 --> 00:12:55,600
sample drop itself in program data and

315
00:12:55,600 --> 00:12:57,920
starts a new instance using the below

316
00:12:57,920 --> 00:13:00,240
command line generated.exe some initial

317
00:13:00,240 --> 00:13:03,120
file location and given this argument

318
00:13:03,120 --> 00:13:05,440
and after that it starts second.exe

319
00:13:05,440 --> 00:13:07,279
legitimate processing in suspended mode

320
00:13:07,279 --> 00:13:10,880
using create process wpa and write dlna

321
00:13:10,880 --> 00:13:12,639
and initialization code for dll using

322
00:13:12,639 --> 00:13:15,920
the virtual up and right process memory

323
00:13:15,920 --> 00:13:18,639
next slide please number so now here

324
00:13:18,639 --> 00:13:20,800
comes the main thing

325
00:13:20,800 --> 00:13:21,839
uh

326
00:13:21,839 --> 00:13:23,760
the standard deal english legend code

327
00:13:23,760 --> 00:13:25,920
perform the following actions like fix

328
00:13:25,920 --> 00:13:27,680
the dl offset using the location table

329
00:13:27,680 --> 00:13:29,680
in the p header

330
00:13:29,680 --> 00:13:31,920
remember this step because we are going

331
00:13:31,920 --> 00:13:34,399
to use this next slide uh other three

332
00:13:34,399 --> 00:13:36,639
things are pass the importable then

333
00:13:36,639 --> 00:13:38,959
build the import table with the

334
00:13:38,959 --> 00:13:41,279
ldr gate processor address api and calls

335
00:13:41,279 --> 00:13:43,839
the entry point of dll

336
00:13:43,839 --> 00:13:47,519
so next slide number is

337
00:13:47,519 --> 00:13:48,399
so

338
00:13:48,399 --> 00:13:50,720
the issue here is that like

339
00:13:50,720 --> 00:13:52,720
this dl file is compiled with image file

340
00:13:52,720 --> 00:13:56,079
relocation uh strip meaning it can't be

341
00:13:56,079 --> 00:13:58,800
loaded on any render address

342
00:13:58,800 --> 00:14:00,959
so here you can see

343
00:14:00,959 --> 00:14:03,680
we have the location table rba

344
00:14:03,680 --> 00:14:04,560
rv

345
00:14:04,560 --> 00:14:06,560
related virtual address

346
00:14:06,560 --> 00:14:08,000
or

347
00:14:08,000 --> 00:14:09,839
through which we calculate the image

348
00:14:09,839 --> 00:14:11,440
base and

349
00:14:11,440 --> 00:14:13,600
relative address and loaded the file

350
00:14:13,600 --> 00:14:16,079
same reload relocation table absolute

351
00:14:16,079 --> 00:14:18,320
address and base address of pe to inject

352
00:14:18,320 --> 00:14:19,839
so you can see in yellow part that

353
00:14:19,839 --> 00:14:22,639
relocation table address is zero

354
00:14:22,639 --> 00:14:25,519
so the code this in this figure you can

355
00:14:25,519 --> 00:14:28,160
see indicate that the index injector

356
00:14:28,160 --> 00:14:30,079
doesn't check whether the location table

357
00:14:30,079 --> 00:14:31,839
address is present in the p header or

358
00:14:31,839 --> 00:14:34,320
not so this result in incorrect

359
00:14:34,320 --> 00:14:36,160
relocation calculation when the dll

360
00:14:36,160 --> 00:14:38,000
initialization code loads the dll in the

361
00:14:38,000 --> 00:14:39,680
target process

362
00:14:39,680 --> 00:14:43,839
so if uh now if you go to

363
00:14:43,839 --> 00:14:46,399
and check this that it states that if

364
00:14:46,399 --> 00:14:48,240
the location information registered from

365
00:14:48,240 --> 00:14:50,720
the file then the file must be loaded

366
00:14:50,720 --> 00:14:53,600
as its preferred base address if the

367
00:14:53,600 --> 00:14:55,600
page address is not available the loader

368
00:14:55,600 --> 00:14:57,199
reports an error

369
00:14:57,199 --> 00:15:00,560
so here is the classic case so we don't

370
00:15:00,560 --> 00:15:02,399
have relocation table so it has to be

371
00:15:02,399 --> 00:15:04,240
downloaded preferred base address but no

372
00:15:04,240 --> 00:15:06,000
we don't have we have to still calculate

373
00:15:06,000 --> 00:15:06,800
it

374
00:15:06,800 --> 00:15:08,560
using relocation table which is not

375
00:15:08,560 --> 00:15:09,760
present so

376
00:15:09,760 --> 00:15:12,399
it will ultimately crash though so this

377
00:15:12,399 --> 00:15:13,360
bugs

378
00:15:13,360 --> 00:15:16,560
this bug falls under cwe 913

379
00:15:16,560 --> 00:15:18,320
which relate to improper control of

380
00:15:18,320 --> 00:15:20,800
dynamically managed code issues

381
00:15:20,800 --> 00:15:23,040
and in this in this case that that

382
00:15:23,040 --> 00:15:24,959
dynamic managed code resources our

383
00:15:24,959 --> 00:15:26,800
relocation table

384
00:15:26,800 --> 00:15:30,800
thanks our next slide number

385
00:15:30,800 --> 00:15:32,000
yeah so

386
00:15:32,000 --> 00:15:34,399
this is a very very interesting case

387
00:15:34,399 --> 00:15:35,360
study

388
00:15:35,360 --> 00:15:37,360
that we found it's like incorrect check

389
00:15:37,360 --> 00:15:39,199
of function written value

390
00:15:39,199 --> 00:15:42,160
so i'm just informing in advance here

391
00:15:42,160 --> 00:15:44,959
that we can use this as a k switch

392
00:15:44,959 --> 00:15:46,639
how let's see

393
00:15:46,639 --> 00:15:47,519
so

394
00:15:47,519 --> 00:15:50,320
uh let me firstly introduce again the

395
00:15:50,320 --> 00:15:53,199
from the multiple side so this bug is

396
00:15:53,199 --> 00:15:56,399
found in austin alvia ascii malware is

397
00:15:56,399 --> 00:15:59,360
basically a it's a stealer which steals

398
00:15:59,360 --> 00:16:00,800
browser data

399
00:16:00,800 --> 00:16:02,959
we take the case of google chrome here

400
00:16:02,959 --> 00:16:05,120
uh so for

401
00:16:05,120 --> 00:16:07,839
the sake of the

402
00:16:07,839 --> 00:16:09,759
i'm telling here how google chrome

403
00:16:09,759 --> 00:16:12,320
stores data like it is stores uh in a

404
00:16:12,320 --> 00:16:14,880
sqlite format format

405
00:16:14,880 --> 00:16:16,720
it stores in local app data google

406
00:16:16,720 --> 00:16:19,279
chrome user data default directory what

407
00:16:19,279 --> 00:16:22,480
malware does malware copy this file in a

408
00:16:22,480 --> 00:16:25,680
time folder of its specified location

409
00:16:25,680 --> 00:16:29,040
so you can see in the code here like it

410
00:16:29,040 --> 00:16:30,000
is uh

411
00:16:30,000 --> 00:16:32,399
opening that file sqlad three dot split

412
00:16:32,399 --> 00:16:34,320
in the scope and you can see the query

413
00:16:34,320 --> 00:16:36,720
select origin underscore url username

414
00:16:36,720 --> 00:16:39,279
password value from logins

415
00:16:39,279 --> 00:16:42,160
so we will see how can we alter it next

416
00:16:42,160 --> 00:16:44,000
class reasonable

417
00:16:44,000 --> 00:16:46,880
so uh we are using a database tools to

418
00:16:46,880 --> 00:16:50,800
show you how that chrome database chrome

419
00:16:50,800 --> 00:16:52,560
username password are saved so you can

420
00:16:52,560 --> 00:16:54,560
see admin and there is a password in the

421
00:16:54,560 --> 00:16:56,480
blog and that blog is your type of

422
00:16:56,480 --> 00:16:57,839
binary

423
00:16:57,839 --> 00:17:00,399
so the password is stored in but the

424
00:17:00,399 --> 00:17:02,160
password value is stored as a binary

425
00:17:02,160 --> 00:17:02,959
here

426
00:17:02,959 --> 00:17:05,520
now we will see how can we use it

427
00:17:05,520 --> 00:17:08,000
next slide

428
00:17:09,359 --> 00:17:10,079
so

429
00:17:10,079 --> 00:17:12,640
here here you see like

430
00:17:12,640 --> 00:17:15,520
this thing is uh

431
00:17:16,079 --> 00:17:17,439
here it is

432
00:17:17,439 --> 00:17:18,959
firstly taking the

433
00:17:18,959 --> 00:17:21,359
size but it doesn't verify the return

434
00:17:21,359 --> 00:17:24,400
length from the sqlite common byte api

435
00:17:24,400 --> 00:17:26,640
now if the password value suppose this

436
00:17:26,640 --> 00:17:29,120
password value v

437
00:17:29,120 --> 00:17:31,200
we make it null

438
00:17:31,200 --> 00:17:33,200
we make it null then this api will

439
00:17:33,200 --> 00:17:36,240
return a null pointer and that the same

440
00:17:36,240 --> 00:17:38,240
null pointer will be used in this uh if

441
00:17:38,240 --> 00:17:40,960
you go lower down than this decrypt data

442
00:17:40,960 --> 00:17:44,400
function which now if

443
00:17:44,400 --> 00:17:46,720
nothing is to decrypt that there will be

444
00:17:46,720 --> 00:17:49,440
a null data reference exception and it

445
00:17:49,440 --> 00:17:51,280
will cause the

446
00:17:51,280 --> 00:17:52,320
crash

447
00:17:52,320 --> 00:17:53,840
so

448
00:17:53,840 --> 00:17:57,360
we see next slide uh

449
00:17:57,360 --> 00:18:00,960
so what we do we make this make a entry

450
00:18:00,960 --> 00:18:03,200
with null password value so what will

451
00:18:03,200 --> 00:18:04,080
happen

452
00:18:04,080 --> 00:18:06,960
whenever this malware reads the value

453
00:18:06,960 --> 00:18:08,559
there will be a null value passed to

454
00:18:08,559 --> 00:18:10,160
that decrypt function

455
00:18:10,160 --> 00:18:12,799
and it will cause a crash so

456
00:18:12,799 --> 00:18:15,039
as i said earlier we can use it as a

457
00:18:15,039 --> 00:18:17,760
kill switch for oscar stillers or maybe

458
00:18:17,760 --> 00:18:20,880
other steelers as well uh we just had a

459
00:18:20,880 --> 00:18:22,559
case of stereoscopy and many other

460
00:18:22,559 --> 00:18:24,480
models they have such a

461
00:18:24,480 --> 00:18:26,559
huge cases where they are not checking

462
00:18:26,559 --> 00:18:31,520
the return value of from sqlite database

463
00:18:36,160 --> 00:18:39,360
okay so we take the cases d5 and this

464
00:18:39,360 --> 00:18:41,679
cases today is all about http response

465
00:18:41,679 --> 00:18:42,720
handling

466
00:18:42,720 --> 00:18:45,600
so we will see a couple of apis from

467
00:18:45,600 --> 00:18:46,720
msdn

468
00:18:46,720 --> 00:18:49,679
which are used to read http response

469
00:18:49,679 --> 00:18:52,000
when a malware try to connect to c2 and

470
00:18:52,000 --> 00:18:54,880
response comes back

471
00:18:54,880 --> 00:18:56,880
what happened here the malware doesn't

472
00:18:56,880 --> 00:18:59,919
handle http response properly so we will

473
00:18:59,919 --> 00:19:02,240
take the first case of like penguis

474
00:19:02,240 --> 00:19:05,120
downloader this is a downloader which

475
00:19:05,120 --> 00:19:07,520
used to download other type of malware

476
00:19:07,520 --> 00:19:09,120
so here

477
00:19:09,120 --> 00:19:12,720
if we see in the few next code like we

478
00:19:12,720 --> 00:19:15,039
have a decrypt c2 path

479
00:19:15,039 --> 00:19:19,200
then we have these struct internal data

480
00:19:19,200 --> 00:19:21,600
which are like unknown to port number

481
00:19:21,600 --> 00:19:22,480
and

482
00:19:22,480 --> 00:19:25,520
2c2 path so you can see here

483
00:19:25,520 --> 00:19:26,400
so

484
00:19:26,400 --> 00:19:28,400
the c2 underscore communication function

485
00:19:28,400 --> 00:19:30,080
use internet read file for downloading

486
00:19:30,080 --> 00:19:32,880
c2 data this function returns a value of

487
00:19:32,880 --> 00:19:35,600
1 if it is able to download the c2 data

488
00:19:35,600 --> 00:19:38,720
and 0 otherwise the download data and

489
00:19:38,720 --> 00:19:41,760
size of data in the in this structure

490
00:19:41,760 --> 00:19:44,559
like internet data pointer and disposito

491
00:19:44,559 --> 00:19:45,760
data full

492
00:19:45,760 --> 00:19:48,080
and dw size of two cd data pointer

493
00:19:48,080 --> 00:19:49,840
respectively

494
00:19:49,840 --> 00:19:50,720
so

495
00:19:50,720 --> 00:19:53,520
this uh in this figure we can see like

496
00:19:53,520 --> 00:19:54,240
uh

497
00:19:54,240 --> 00:19:56,160
there is no check for a written value

498
00:19:56,160 --> 00:19:58,080
for c2 communication function and it

499
00:19:58,080 --> 00:19:59,919
tries to modify

500
00:19:59,919 --> 00:20:02,640
the data stored in c2 data full

501
00:20:02,640 --> 00:20:05,039
but if there is no data available

502
00:20:05,039 --> 00:20:07,039
means uh already i am saying like this

503
00:20:07,039 --> 00:20:09,520
is a data controlled uh system and he's

504
00:20:09,520 --> 00:20:11,200
not sending data

505
00:20:11,200 --> 00:20:14,000
so here we are not handling it at all so

506
00:20:14,000 --> 00:20:16,559
it will cause a crash again with a null

507
00:20:16,559 --> 00:20:18,480
reference exception

508
00:20:18,480 --> 00:20:21,280
so

509
00:20:21,280 --> 00:20:23,679
here we can say this improper http

510
00:20:23,679 --> 00:20:25,520
response it should have a check of

511
00:20:25,520 --> 00:20:28,559
length whether whatever the data came

512
00:20:28,559 --> 00:20:30,559
what are the data received what is the

513
00:20:30,559 --> 00:20:32,320
length if it is if it is equal to length

514
00:20:32,320 --> 00:20:34,320
equals to 0 then it should have some

515
00:20:34,320 --> 00:20:38,159
other alternate path to execute but it

516
00:20:38,159 --> 00:20:39,440
is uh

517
00:20:39,440 --> 00:20:40,720
crashing here

518
00:20:40,720 --> 00:20:43,360
so similarly we will go to next slide

519
00:20:43,360 --> 00:20:45,840
and we will have a similar work but

520
00:20:45,840 --> 00:20:48,799
but different api so this time

521
00:20:48,799 --> 00:20:50,720
there is another downloader which which

522
00:20:50,720 --> 00:20:53,039
is downloading the very

523
00:20:53,039 --> 00:20:55,280
known malware book table

524
00:20:55,280 --> 00:20:57,600
and here api is little different it is

525
00:20:57,600 --> 00:21:00,000
url download to file api

526
00:21:00,000 --> 00:21:01,760
so here you can see the function c2

527
00:21:01,760 --> 00:21:03,919
underscore talk

528
00:21:03,919 --> 00:21:04,720
so

529
00:21:04,720 --> 00:21:07,039
again you can see uh c2 underscore talk

530
00:21:07,039 --> 00:21:11,039
uses uri download to file api and after

531
00:21:11,039 --> 00:21:13,840
that return value is not getting checked

532
00:21:13,840 --> 00:21:14,880
and

533
00:21:14,880 --> 00:21:16,640
the whatever data

534
00:21:16,640 --> 00:21:20,000
received as return value

535
00:21:20,000 --> 00:21:21,840
is passed to decrypt data function which

536
00:21:21,840 --> 00:21:24,080
is again causing

537
00:21:24,080 --> 00:21:25,200
crash

538
00:21:25,200 --> 00:21:27,360
because of that null value received and

539
00:21:27,360 --> 00:21:29,919
null reference exception will be there

540
00:21:29,919 --> 00:21:32,320
so these both are similar type of bugs

541
00:21:32,320 --> 00:21:34,799
but with different apis so we kept it in

542
00:21:34,799 --> 00:21:37,919
a single bucket of cw

543
00:21:37,919 --> 00:21:40,320
which states that uh misinterpretation

544
00:21:40,320 --> 00:21:43,360
of http response so which is crossing

545
00:21:43,360 --> 00:21:44,480
here

546
00:21:44,480 --> 00:21:46,320
the sample

547
00:21:46,320 --> 00:21:48,720
now we will come to our the most

548
00:21:48,720 --> 00:21:49,679
interesting

549
00:21:49,679 --> 00:21:50,480
most

550
00:21:50,480 --> 00:21:53,039
interesting study of emoted

551
00:21:53,039 --> 00:21:54,799
uh this is very known malware and i

552
00:21:54,799 --> 00:21:57,120
guess it needs no introduction

553
00:21:57,120 --> 00:21:58,559
uh

554
00:21:58,559 --> 00:22:01,600
again but uh i'm describing here like it

555
00:22:01,600 --> 00:22:03,280
was seen

556
00:22:03,280 --> 00:22:04,480
in

557
00:22:04,480 --> 00:22:06,000
2014

558
00:22:06,000 --> 00:22:07,679
and uh

559
00:22:07,679 --> 00:22:09,840
the start of this year

560
00:22:09,840 --> 00:22:11,679
it was taken down by

561
00:22:11,679 --> 00:22:13,679
law enforcement agencies

562
00:22:13,679 --> 00:22:16,240
so we were styling it from a very very

563
00:22:16,240 --> 00:22:18,720
long time and found a

564
00:22:18,720 --> 00:22:20,799
found a few issue

565
00:22:20,799 --> 00:22:23,200
so this issue is especially ready to do

566
00:22:23,200 --> 00:22:25,360
almost 300 plus sample

567
00:22:25,360 --> 00:22:28,159
where uh there was an issue in the logic

568
00:22:28,159 --> 00:22:30,080
uh where it is used to get the address

569
00:22:30,080 --> 00:22:31,840
of ntdl.dl

570
00:22:31,840 --> 00:22:33,520
system dll

571
00:22:33,520 --> 00:22:35,919
so what happened it uses process

572
00:22:35,919 --> 00:22:37,679
environment block to get the image space

573
00:22:37,679 --> 00:22:39,919
of the required dll then uses a custom

574
00:22:39,919 --> 00:22:41,919
get pro address like function to

575
00:22:41,919 --> 00:22:44,000
retrieve the address of an export

576
00:22:44,000 --> 00:22:47,120
function from the dll you can see in the

577
00:22:47,120 --> 00:22:48,720
image

578
00:22:48,720 --> 00:22:49,840
uh

579
00:22:49,840 --> 00:22:52,559
like it uses you can say like

580
00:22:52,559 --> 00:22:54,559
in load order model is to get the base

581
00:22:54,559 --> 00:22:56,480
number of the module and compares only

582
00:22:56,480 --> 00:22:59,360
the module name not the extension

583
00:22:59,360 --> 00:23:00,799
so if

584
00:23:00,799 --> 00:23:03,440
uh suppose now it is trying to get

585
00:23:03,440 --> 00:23:04,880
anterior led

586
00:23:04,880 --> 00:23:07,039
and i rename

587
00:23:07,039 --> 00:23:10,559
the value itself nt dll.exe

588
00:23:10,559 --> 00:23:12,480
then it will be on the that top of the

589
00:23:12,480 --> 00:23:13,679
list

590
00:23:13,679 --> 00:23:15,679
as it is not checking the extension so

591
00:23:15,679 --> 00:23:18,559
it will try to load ntdl.exe instead of

592
00:23:18,559 --> 00:23:20,480
ntdl.dll

593
00:23:20,480 --> 00:23:24,400
and uh because of that it will crash uh

594
00:23:24,400 --> 00:23:27,200
it will not get desired uh functions

595
00:23:27,200 --> 00:23:29,360
so this was the one kill switch we can

596
00:23:29,360 --> 00:23:30,080
say

597
00:23:30,080 --> 00:23:31,440
just rename

598
00:23:31,440 --> 00:23:34,240
uh this version of the imported as

599
00:23:34,240 --> 00:23:38,320
ntdl.exe and it will never run

600
00:23:38,320 --> 00:23:40,159
normal next slide please

601
00:23:40,159 --> 00:23:41,679
yeah

602
00:23:41,679 --> 00:23:43,039
so

603
00:23:43,039 --> 00:23:45,679
this is also similar issue but having a

604
00:23:45,679 --> 00:23:47,600
little different approach

605
00:23:47,600 --> 00:23:51,240
here like uh

606
00:23:51,279 --> 00:23:53,520
the sample is trying to load different

607
00:23:53,520 --> 00:23:58,159
fda like us um this this deal is used by

608
00:23:58,159 --> 00:24:01,360
almost every sample like kernel 32. dll

609
00:24:01,360 --> 00:24:03,039
here if we change the file name to

610
00:24:03,039 --> 00:24:04,799
anything that start with k it will

611
00:24:04,799 --> 00:24:06,480
result the crash

612
00:24:06,480 --> 00:24:07,840
uh reason

613
00:24:07,840 --> 00:24:09,760
uh that logic

614
00:24:09,760 --> 00:24:12,799
which again extract kernel 32.bll means

615
00:24:12,799 --> 00:24:15,120
which which tries to extract the image

616
00:24:15,120 --> 00:24:17,600
base of kernel 32.dlf

617
00:24:17,600 --> 00:24:21,039
like similar to earlier one it uh use it

618
00:24:21,039 --> 00:24:23,360
in load order order modulus to get the

619
00:24:23,360 --> 00:24:25,679
paste here name then the paste name is

620
00:24:25,679 --> 00:24:27,600
converted to lowercase

621
00:24:27,600 --> 00:24:29,440
if we see here

622
00:24:29,440 --> 00:24:30,880
yeah

623
00:24:30,880 --> 00:24:34,720
and a hash is calculated if you see here

624
00:24:34,720 --> 00:24:37,360
yeah it has calculated uh using all the

625
00:24:37,360 --> 00:24:39,440
characters in the deal name

626
00:24:39,440 --> 00:24:41,520
uh now the dl name is a wide

627
00:24:41,520 --> 00:24:43,520
characteristic so to get the next

628
00:24:43,520 --> 00:24:44,559
character

629
00:24:44,559 --> 00:24:46,320
you have to add 2 byte to the base

630
00:24:46,320 --> 00:24:48,080
pointer however

631
00:24:48,080 --> 00:24:51,200
in if we see the code in this code we

632
00:24:51,200 --> 00:24:53,840
are saying that only one one is added so

633
00:24:53,840 --> 00:24:57,279
the result will be like it will exit

634
00:24:57,279 --> 00:24:58,960
from the loop just after the first

635
00:24:58,960 --> 00:25:01,279
character and it will return the

636
00:25:01,279 --> 00:25:04,000
return the image base even if only one

637
00:25:04,000 --> 00:25:05,600
character is matched

638
00:25:05,600 --> 00:25:06,640
so

639
00:25:06,640 --> 00:25:09,039
if we rename our

640
00:25:09,039 --> 00:25:10,640
sample as

641
00:25:10,640 --> 00:25:12,000
something like

642
00:25:12,000 --> 00:25:14,960
kx py something like starting with k

643
00:25:14,960 --> 00:25:15,840
only

644
00:25:15,840 --> 00:25:17,919
then there will be a match and it will

645
00:25:17,919 --> 00:25:20,240
load that uh

646
00:25:20,240 --> 00:25:22,080
uh load

647
00:25:22,080 --> 00:25:25,919
that sample itself and not that kernel

648
00:25:25,919 --> 00:25:27,360
the issue is little different from

649
00:25:27,360 --> 00:25:30,240
earlier on earlier it was directly

650
00:25:30,240 --> 00:25:33,120
loading the dll based on the name

651
00:25:33,120 --> 00:25:34,880
but here it is just calculating some

652
00:25:34,880 --> 00:25:36,960
other stuff and trying to match first

653
00:25:36,960 --> 00:25:39,039
character right

654
00:25:39,039 --> 00:25:41,279
so it will cause a crash

655
00:25:41,279 --> 00:25:43,760
so again these two are kill switch for

656
00:25:43,760 --> 00:25:44,960
immoted

657
00:25:44,960 --> 00:25:47,360
so these are all from my side

658
00:25:47,360 --> 00:25:50,640
now nirmal please

659
00:25:50,640 --> 00:25:56,279
take over from here and finish thank you

660
00:25:56,320 --> 00:25:57,919
okay so

661
00:25:57,919 --> 00:26:00,320
yeah so let's talk about uh

662
00:26:00,320 --> 00:26:02,240
case number seven case study number

663
00:26:02,240 --> 00:26:03,120
seven

664
00:26:03,120 --> 00:26:05,039
and this is regarding the use of

665
00:26:05,039 --> 00:26:06,640
function with the inconsistent

666
00:26:06,640 --> 00:26:09,360
implementation uh this this is a case

667
00:26:09,360 --> 00:26:12,880
study uh where you know like uh you know

668
00:26:12,880 --> 00:26:14,799
malware sometimes what they do is like

669
00:26:14,799 --> 00:26:17,360
they i mean all the malwares they use

670
00:26:17,360 --> 00:26:18,559
spectra right

671
00:26:18,559 --> 00:26:21,279
and some times packer can

672
00:26:21,279 --> 00:26:24,400
uh you know result in crashing the

673
00:26:24,400 --> 00:26:26,880
application not uh you know not by

674
00:26:26,880 --> 00:26:29,440
having any coding issues but sometimes

675
00:26:29,440 --> 00:26:31,520
some configuration issues as well so

676
00:26:31,520 --> 00:26:33,520
this is this case study is regarding the

677
00:26:33,520 --> 00:26:36,240
raccoon malware and this one is also a

678
00:26:36,240 --> 00:26:39,120
password sealer uh stealing you know a

679
00:26:39,120 --> 00:26:40,960
lot of information from the infected

680
00:26:40,960 --> 00:26:41,919
system

681
00:26:41,919 --> 00:26:44,159
uh one important uh you know the

682
00:26:44,159 --> 00:26:46,000
information that it steals from the

683
00:26:46,000 --> 00:26:47,120
infected

684
00:26:47,120 --> 00:26:50,559
system is this the credentials stored by

685
00:26:50,559 --> 00:26:52,000
internet explorer like the username and

686
00:26:52,000 --> 00:26:54,559
password stored in internet explorer

687
00:26:54,559 --> 00:26:56,720
uh so we know that starting with windows

688
00:26:56,720 --> 00:26:59,360
7 internet explorer shows uh the

689
00:26:59,360 --> 00:27:01,440
sensitive information you know including

690
00:27:01,440 --> 00:27:03,679
username and password and windows world

691
00:27:03,679 --> 00:27:08,320
and uh it pro it uses a dll world uh cli

692
00:27:08,320 --> 00:27:10,960
or dln and malware many malwares use

693
00:27:10,960 --> 00:27:13,200
this dll right they use different apis

694
00:27:13,200 --> 00:27:15,840
from uh this dll to extract the

695
00:27:15,840 --> 00:27:17,600
information username password right a

696
00:27:17,600 --> 00:27:19,039
lot of things

697
00:27:19,039 --> 00:27:20,080
but

698
00:27:20,080 --> 00:27:22,000
there is a catch like uh

699
00:27:22,000 --> 00:27:24,720
there is a change in the one of the api

700
00:27:24,720 --> 00:27:27,200
that is used to extract the information

701
00:27:27,200 --> 00:27:30,240
and that is world get item and that has

702
00:27:30,240 --> 00:27:33,840
been changed starting from windows 8 and

703
00:27:33,840 --> 00:27:36,480
how that is resulting into crashing the

704
00:27:36,480 --> 00:27:40,240
system we will describe in coming slides

705
00:27:40,240 --> 00:27:41,200
okay

706
00:27:41,200 --> 00:27:43,440
so uh as i mentioned like uh there is a

707
00:27:43,440 --> 00:27:45,919
change in the api uh in starting from

708
00:27:45,919 --> 00:27:48,000
windows 8. so if you need to change if

709
00:27:48,000 --> 00:27:50,320
you need to use the correct api then you

710
00:27:50,320 --> 00:27:52,880
need to first verify

711
00:27:52,880 --> 00:27:55,279
which version what is the version of

712
00:27:55,279 --> 00:27:57,440
operating system where the application

713
00:27:57,440 --> 00:28:00,880
is running right so most of the uh you

714
00:28:00,880 --> 00:28:02,960
know malwares or even the flashy mode

715
00:28:02,960 --> 00:28:05,520
application they use get version

716
00:28:05,520 --> 00:28:07,919
windows api for getting the operating

717
00:28:07,919 --> 00:28:09,440
system information

718
00:28:09,440 --> 00:28:11,039
but another thing important thing here

719
00:28:11,039 --> 00:28:14,480
is that this api has also been changed

720
00:28:14,480 --> 00:28:17,440
starting from windows 8.1

721
00:28:17,440 --> 00:28:20,880
and for this api to work correctly the

722
00:28:20,880 --> 00:28:23,520
applications need to be manifested for

723
00:28:23,520 --> 00:28:26,559
the particular operating system so if

724
00:28:26,559 --> 00:28:28,559
the application is not manifested for

725
00:28:28,559 --> 00:28:29,600
example

726
00:28:29,600 --> 00:28:31,919
for windows 8 or windows 10 then this

727
00:28:31,919 --> 00:28:35,360
api will always return windows

728
00:28:35,360 --> 00:28:37,679
8 os version information and that will

729
00:28:37,679 --> 00:28:39,200
be 6.

730
00:28:39,200 --> 00:28:42,000
2. so here we can see that it is using

731
00:28:42,000 --> 00:28:46,799
get version uh exe w api and then it's

732
00:28:46,799 --> 00:28:48,880
verifying the result right and then

733
00:28:48,880 --> 00:28:52,399
according to that it will jump and use

734
00:28:52,399 --> 00:28:54,960
the function

735
00:28:54,960 --> 00:28:58,000
but the issue here is that the packer is

736
00:28:58,000 --> 00:29:00,640
manifested for windows 10 and different

737
00:29:00,640 --> 00:29:03,600
operating systems right but the code the

738
00:29:03,600 --> 00:29:07,200
the malware code is written for uh for a

739
00:29:07,200 --> 00:29:09,679
specific operating system right so when

740
00:29:09,679 --> 00:29:12,159
we use api for example for windows 10

741
00:29:12,159 --> 00:29:15,520
then the get version api here will

742
00:29:15,520 --> 00:29:16,799
return

743
00:29:16,799 --> 00:29:20,559
different values and then it means that

744
00:29:20,559 --> 00:29:23,360
the malware will select a wrong version

745
00:29:23,360 --> 00:29:25,520
of the api and then finally it will

746
00:29:25,520 --> 00:29:28,480
result in crash

747
00:29:28,960 --> 00:29:31,200
yeah

748
00:29:31,600 --> 00:29:34,000
okay so uh

749
00:29:34,000 --> 00:29:36,159
the final case study that we have in

750
00:29:36,159 --> 00:29:38,559
today's for today's presentation is

751
00:29:38,559 --> 00:29:40,720
regarding a ransomware and that is

752
00:29:40,720 --> 00:29:43,200
regarding when the

753
00:29:43,200 --> 00:29:45,760
when the sample is not able to verify

754
00:29:45,760 --> 00:29:48,480
whether it is having you know uh

755
00:29:48,480 --> 00:29:50,720
sufficient privileges or permission to

756
00:29:50,720 --> 00:29:54,159
access a folder so here we are we are

757
00:29:54,159 --> 00:29:56,640
giving we have given example of

758
00:29:56,640 --> 00:29:58,799
a ram somewhere that encrypts files

759
00:29:58,799 --> 00:30:00,000
right from

760
00:30:00,000 --> 00:30:02,880
encrypt all files in the c drive and

761
00:30:02,880 --> 00:30:05,120
here you can see in the code that it's

762
00:30:05,120 --> 00:30:07,039
trying to access up

763
00:30:07,039 --> 00:30:09,279
a path for example in windows 10 it's

764
00:30:09,279 --> 00:30:11,760
trying to access document and settings

765
00:30:11,760 --> 00:30:14,159
folder but uh

766
00:30:14,159 --> 00:30:16,880
this folder is protected and

767
00:30:16,880 --> 00:30:18,960
the sample or the malware

768
00:30:18,960 --> 00:30:21,840
maybe the process is not having

769
00:30:21,840 --> 00:30:24,000
sufficient privileges to access this

770
00:30:24,000 --> 00:30:26,640
folder and then it will finally result

771
00:30:26,640 --> 00:30:28,960
in crashing the application

772
00:30:28,960 --> 00:30:32,480
the the ransomware will show a ransom

773
00:30:32,480 --> 00:30:35,200
node but it will not be able to cover

774
00:30:35,200 --> 00:30:37,600
all the you know fi encrypt all the

775
00:30:37,600 --> 00:30:40,000
files yeah and then it will finally

776
00:30:40,000 --> 00:30:41,360
crash

777
00:30:41,360 --> 00:30:44,240
okay so yeah so with that we will

778
00:30:44,240 --> 00:30:45,679
conclude our

779
00:30:45,679 --> 00:30:48,720
presentation so what we have uh kind of

780
00:30:48,720 --> 00:30:50,640
like what are the findings that we have

781
00:30:50,640 --> 00:30:53,760
um kind of like described so far

782
00:30:53,760 --> 00:30:55,600
so we

783
00:30:55,600 --> 00:30:58,559
found vulnerabilities in you know all

784
00:30:58,559 --> 00:31:00,399
type of malwares like ram somewhere

785
00:31:00,399 --> 00:31:02,159
password stealers right

786
00:31:02,159 --> 00:31:02,960
and

787
00:31:02,960 --> 00:31:04,960
the the types of vulnerabilities are

788
00:31:04,960 --> 00:31:07,200
also very different right and then we

789
00:31:07,200 --> 00:31:09,039
try to classify

790
00:31:09,039 --> 00:31:11,600
all the bugs to micro cve list and then

791
00:31:11,600 --> 00:31:15,519
we meaning like we we defined what uh

792
00:31:15,519 --> 00:31:18,640
bug or vulnerability you know falls

793
00:31:18,640 --> 00:31:20,559
under which category

794
00:31:20,559 --> 00:31:22,720
and uh we also like included as i

795
00:31:22,720 --> 00:31:24,799
mentioned broad range of malwares from

796
00:31:24,799 --> 00:31:26,559
sealers downloads and somewhere else

797
00:31:26,559 --> 00:31:30,080
right and this also shows that uh you

798
00:31:30,080 --> 00:31:31,039
know

799
00:31:31,039 --> 00:31:33,760
in the clean um samples or we can say in

800
00:31:33,760 --> 00:31:36,000
the software in the software development

801
00:31:36,000 --> 00:31:38,000
testing is very important phase right so

802
00:31:38,000 --> 00:31:39,840
there are a lot of testing tools pen

803
00:31:39,840 --> 00:31:41,279
testing is involved and all of those

804
00:31:41,279 --> 00:31:44,320
things but malware they don't have i

805
00:31:44,320 --> 00:31:47,120
don't think they kind of like use uh

806
00:31:47,120 --> 00:31:49,600
these kind of technologies to uh you

807
00:31:49,600 --> 00:31:50,640
know

808
00:31:50,640 --> 00:31:53,279
make sure that their code is uh bug free

809
00:31:53,279 --> 00:31:56,320
right so there is no proper uh quality

810
00:31:56,320 --> 00:31:58,080
insurance check here in the malware code

811
00:31:58,080 --> 00:31:59,519
that we have

812
00:31:59,519 --> 00:32:03,120
and we also have shown few case studies

813
00:32:03,120 --> 00:32:04,960
where you know we can modify a few

814
00:32:04,960 --> 00:32:06,880
settings for example for registry keys

815
00:32:06,880 --> 00:32:11,279
right few a few entries in in

816
00:32:11,279 --> 00:32:13,760
the database or sqlite database right

817
00:32:13,760 --> 00:32:15,840
and security vendors can basically use

818
00:32:15,840 --> 00:32:17,919
those kind of bugs and write different

819
00:32:17,919 --> 00:32:20,080
type of signatures as well and

820
00:32:20,080 --> 00:32:21,760
can also identify

821
00:32:21,760 --> 00:32:24,240
uh and block such kind of malwares by

822
00:32:24,240 --> 00:32:27,440
creating the kill switches

823
00:32:27,440 --> 00:32:29,919
with that uh thank you very much thanks

824
00:32:29,919 --> 00:32:33,960
everyone for attending our session

825
00:32:34,220 --> 00:32:37,390
[Music]

