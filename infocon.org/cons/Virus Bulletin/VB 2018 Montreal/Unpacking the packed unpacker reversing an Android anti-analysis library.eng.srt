1
00:00:00,350 --> 00:00:05,069
okay so please be seated everybody and

2
00:00:05,069 --> 00:00:09,510
we will start with our new session and

3
00:00:09,510 --> 00:00:12,960
start with unpacking the packed unpacker

4
00:00:12,960 --> 00:00:15,120
I'm not going beyond that it's very

5
00:00:15,120 --> 00:00:17,580
difficult to pronounce for me I don't

6
00:00:17,580 --> 00:00:19,830
know if that's on purpose but it's your

7
00:00:19,830 --> 00:00:22,260
yours now thank you

8
00:00:22,260 --> 00:00:24,150
hi welcome to unpacking the packed on

9
00:00:24,150 --> 00:00:27,480
Packer I am Maddy stone and I am a

10
00:00:27,480 --> 00:00:29,160
reverse engineer on google's android

11
00:00:29,160 --> 00:00:34,410
security team so sort of the whole point

12
00:00:34,410 --> 00:00:38,640
in why this matters is remembering that

13
00:00:38,640 --> 00:00:42,360
in malware analysis in defending it is

14
00:00:42,360 --> 00:00:45,180
us as malware analysis versus the

15
00:00:45,180 --> 00:00:46,920
malware authors and each of us are

16
00:00:46,920 --> 00:00:49,170
striving for this asymmetric advantage

17
00:00:49,170 --> 00:00:51,960
where they want to be able to create put

18
00:00:51,960 --> 00:00:54,420
malware out with less investment than it

19
00:00:54,420 --> 00:00:57,449
takes for us to detect it so keeping

20
00:00:57,449 --> 00:01:00,629
that in mind we come to anti analysis

21
00:01:00,629 --> 00:01:02,940
and basically this just means any

22
00:01:02,940 --> 00:01:06,420
techniques that make it harder for us as

23
00:01:06,420 --> 00:01:09,000
defenders to figure out what the malware

24
00:01:09,000 --> 00:01:14,340
is doing so before we get directly into

25
00:01:14,340 --> 00:01:16,380
the library we're talking about let's

26
00:01:16,380 --> 00:01:18,810
set the stage for how this happened

27
00:01:18,810 --> 00:01:22,320
I was doing our general reverse

28
00:01:22,320 --> 00:01:24,630
engineering reviewing the list of apps

29
00:01:24,630 --> 00:01:26,130
that we have in a queue that to

30
00:01:26,130 --> 00:01:27,630
determine whether or not it's malware

31
00:01:27,630 --> 00:01:30,900
and the key is that I need to do it

32
00:01:30,900 --> 00:01:33,509
quickly because there are many apps in

33
00:01:33,509 --> 00:01:35,670
this queue and it's affecting its on

34
00:01:35,670 --> 00:01:37,950
users devices and thus I want to protect

35
00:01:37,950 --> 00:01:40,829
them very quickly if it is so the app

36
00:01:40,829 --> 00:01:42,600
looks suspicious but I need to find the

37
00:01:42,600 --> 00:01:46,229
evidence first the interesting thing the

38
00:01:46,229 --> 00:01:48,329
app won't run in any sort of dynamic

39
00:01:48,329 --> 00:01:51,570
analysis that I set up next when I take

40
00:01:51,570 --> 00:01:54,090
a look at it statically most of the code

41
00:01:54,090 --> 00:01:56,159
is native it's not Java as you would

42
00:01:56,159 --> 00:01:58,460
expect in an Android application and

43
00:01:58,460 --> 00:02:01,710
lastly there were a lot of similar

44
00:02:01,710 --> 00:02:03,659
applications meaning I really want to

45
00:02:03,659 --> 00:02:05,850
figure out what it's doing because it's

46
00:02:05,850 --> 00:02:08,160
more than just this one apk that I'm

47
00:02:08,160 --> 00:02:11,970
looking at so if you're not as familiar

48
00:02:11,970 --> 00:02:12,590
with

49
00:02:12,590 --> 00:02:14,959
Android malware analysis Android apps

50
00:02:14,959 --> 00:02:16,190
are in a file format called

51
00:02:16,190 --> 00:02:19,340
apk usually they're written in Java code

52
00:02:19,340 --> 00:02:22,340
or or Kotlin but that all of that is in

53
00:02:22,340 --> 00:02:23,650
classes.dex

54
00:02:23,650 --> 00:02:26,239
however within the apk you can include

55
00:02:26,239 --> 00:02:29,720
other files such as natively compiled so

56
00:02:29,720 --> 00:02:33,290
C or C++ compiled code as libraries that

57
00:02:33,290 --> 00:02:37,069
the Java code can call and execute so

58
00:02:37,069 --> 00:02:40,819
for us that looks like I elf with the

59
00:02:40,819 --> 00:02:43,310
shared objects file extension within the

60
00:02:43,310 --> 00:02:46,069
apk and that's what we're gonna talk

61
00:02:46,069 --> 00:02:49,040
through and what I was reversing for

62
00:02:49,040 --> 00:02:52,880
this talk so introducing wedding cake

63
00:02:52,880 --> 00:02:55,310
because it's got lots of layers and

64
00:02:55,310 --> 00:02:57,290
that's what we're gonna be going through

65
00:02:57,290 --> 00:02:58,640
and talking about the different anti

66
00:02:58,640 --> 00:03:01,730
analysis techniques that they have so

67
00:03:01,730 --> 00:03:03,049
the all the different techniques that

68
00:03:03,049 --> 00:03:05,239
wedding-cake decided to embed in this

69
00:03:05,239 --> 00:03:07,640
native library that has been included in

70
00:03:07,640 --> 00:03:09,709
many different applications it's first

71
00:03:09,709 --> 00:03:11,260
they do Java native interface

72
00:03:11,260 --> 00:03:14,299
manipulations changing from the specific

73
00:03:14,299 --> 00:03:18,200
expected way that the J&I works next

74
00:03:18,200 --> 00:03:20,239
they use some anti reverse engineering

75
00:03:20,239 --> 00:03:23,389
techniques after that they use in place

76
00:03:23,389 --> 00:03:26,030
decryption of the elf finally we get

77
00:03:26,030 --> 00:03:28,310
into 45 different runtime environment

78
00:03:28,310 --> 00:03:30,079
checks that include checking the system

79
00:03:30,079 --> 00:03:32,540
properties verifying what CPU

80
00:03:32,540 --> 00:03:34,519
architecture you're running on looking

81
00:03:34,519 --> 00:03:37,609
for a monkey who which is a tap

82
00:03:37,609 --> 00:03:40,519
emulation type of software and then

83
00:03:40,519 --> 00:03:42,019
finally looking for the xposed framework

84
00:03:42,019 --> 00:03:46,790
which is a hooking software so some of

85
00:03:46,790 --> 00:03:48,590
the first characteristics of wedding

86
00:03:48,590 --> 00:03:50,959
cake first it's a native library as

87
00:03:50,959 --> 00:03:54,620
hence by the title next the title of the

88
00:03:54,620 --> 00:03:56,780
library as it's included in apks is

89
00:03:56,780 --> 00:03:59,030
randomly generated and is usually three

90
00:03:59,030 --> 00:04:00,980
to eight random characters lowercase

91
00:04:00,980 --> 00:04:04,310
characters next all of the because it's

92
00:04:04,310 --> 00:04:06,500
a native library within a java

93
00:04:06,500 --> 00:04:08,450
application or android application it

94
00:04:08,450 --> 00:04:11,299
has to be called by java code so all of

95
00:04:11,299 --> 00:04:13,489
the Java code that interfaces with the

96
00:04:13,489 --> 00:04:16,010
native library is randomly generated

97
00:04:16,010 --> 00:04:19,548
class names in the sample that I linked

98
00:04:19,548 --> 00:04:20,599
to and talked through in this

99
00:04:20,599 --> 00:04:23,630
presentation it was this really easy to

100
00:04:23,630 --> 00:04:26,260
discuss class name that's listed here

101
00:04:26,260 --> 00:04:30,710
lastly within the elf there is usually

102
00:04:30,710 --> 00:04:33,500
two strings in the comment section of

103
00:04:33,500 --> 00:04:36,340
the elf that are seen in wedding cake

104
00:04:36,340 --> 00:04:38,900
the final sort of characteristics which

105
00:04:38,900 --> 00:04:41,150
are helpful in determining whether or

106
00:04:41,150 --> 00:04:42,860
not a sample is wedding cake is that

107
00:04:42,860 --> 00:04:44,750
there are two Java declared native

108
00:04:44,750 --> 00:04:47,900
methods meaning that they declared the

109
00:04:47,900 --> 00:04:49,850
method in Java so that it can be called

110
00:04:49,850 --> 00:04:50,900
from the java code within the

111
00:04:50,900 --> 00:04:52,850
application and is implemented in the c

112
00:04:52,850 --> 00:04:56,510
and so the names are always changing

113
00:04:56,510 --> 00:04:57,800
within the samples but they always have

114
00:04:57,800 --> 00:05:00,470
these two signatures so the first one

115
00:05:00,470 --> 00:05:03,050
takes an array of objects and the second

116
00:05:03,050 --> 00:05:05,360
one and returns an int and the second

117
00:05:05,360 --> 00:05:08,210
one takes an int and returns a string so

118
00:05:08,210 --> 00:05:10,460
these are really helpful for determining

119
00:05:10,460 --> 00:05:12,290
what you're looking at and where your

120
00:05:12,290 --> 00:05:14,870
analysis should be lastly some of the

121
00:05:14,870 --> 00:05:16,729
samples have this third method but it's

122
00:05:16,729 --> 00:05:18,290
not included in all and I talked about

123
00:05:18,290 --> 00:05:22,130
that little more in my paper a next

124
00:05:22,130 --> 00:05:24,950
interesting feature of wedding cake is

125
00:05:24,950 --> 00:05:26,750
that it has been compiled for many

126
00:05:26,750 --> 00:05:29,000
different cpu variants meaning that it

127
00:05:29,000 --> 00:05:30,890
is very likely distributed as source

128
00:05:30,890 --> 00:05:34,190
code so the most common one and what I

129
00:05:34,190 --> 00:05:36,890
will focus on today is the army API

130
00:05:36,890 --> 00:05:40,910
version 32-bit arm the other three that

131
00:05:40,910 --> 00:05:43,250
I've seen mill in samples in the wild

132
00:05:43,250 --> 00:05:47,630
is 32-bit arm for v7 arm 64 as well as

133
00:05:47,630 --> 00:05:50,180
x86 if you'd like to compare some of the

134
00:05:50,180 --> 00:05:52,250
different cpu variants or versions of

135
00:05:52,250 --> 00:05:53,479
wedding-cake to each other

136
00:05:53,479 --> 00:05:55,490
here is a sample the short link goes to

137
00:05:55,490 --> 00:05:57,139
the virustotal page so you can download

138
00:05:57,139 --> 00:06:00,470
the APK and you'll see the different

139
00:06:00,470 --> 00:06:02,870
versions of it there what's interesting

140
00:06:02,870 --> 00:06:05,570
though and why I only feel the need to

141
00:06:05,570 --> 00:06:07,550
focus on one through this talk and in

142
00:06:07,550 --> 00:06:09,710
the paper is that across all of the

143
00:06:09,710 --> 00:06:11,660
different cpu variants it has the same

144
00:06:11,660 --> 00:06:13,970
functionality techniques that doesn't

145
00:06:13,970 --> 00:06:15,380
change they just compiled it for

146
00:06:15,380 --> 00:06:20,210
different CPUs so what's the purpose of

147
00:06:20,210 --> 00:06:22,490
wedding cake why do you care why did I

148
00:06:22,490 --> 00:06:23,810
think it's worthwhile talking about

149
00:06:23,810 --> 00:06:27,800
first just until August of this year

150
00:06:27,800 --> 00:06:30,380
there had been five thousand at least

151
00:06:30,380 --> 00:06:32,630
five thousand distinct apk samples I had

152
00:06:32,630 --> 00:06:35,570
found that included wedding cake the

153
00:06:35,570 --> 00:06:37,820
next and why and it initially ended up

154
00:06:37,820 --> 00:06:39,740
on my radar was that new

155
00:06:39,740 --> 00:06:42,860
our variance of the Shinhwa Android PHA

156
00:06:42,860 --> 00:06:45,259
family we're using it

157
00:06:45,259 --> 00:06:49,009
so this graph below shows the picture of

158
00:06:49,009 --> 00:06:50,930
the different stages of Shinhwa that

159
00:06:50,930 --> 00:06:54,530
Google had posted in a blog post in 2017

160
00:06:54,530 --> 00:06:56,569
and the key feature here that we're

161
00:06:56,569 --> 00:06:59,599
looking at is the stage 3 elf after

162
00:06:59,599 --> 00:07:01,789
getting through all of the tech anti

163
00:07:01,789 --> 00:07:05,030
analysis techniques of wedding cake what

164
00:07:05,030 --> 00:07:06,800
I found is that they'd simply wrapped

165
00:07:06,800 --> 00:07:09,190
the initial stage 3 code and

166
00:07:09,190 --> 00:07:11,690
functionality in all of these wedding

167
00:07:11,690 --> 00:07:14,389
cake techniques so wedding cake is a

168
00:07:14,389 --> 00:07:18,229
wrapper around what the malware

169
00:07:18,229 --> 00:07:21,169
developers want to hide it's not in and

170
00:07:21,169 --> 00:07:23,960
of itself a standalone library so that

171
00:07:23,960 --> 00:07:26,000
is how we came about unpacking the

172
00:07:26,000 --> 00:07:28,310
packed unpacker because stage 3 and

173
00:07:28,310 --> 00:07:30,409
Shinhwa is an unpacker in and of itself

174
00:07:30,409 --> 00:07:32,750
so they've wrapped their previous

175
00:07:32,750 --> 00:07:39,169
unpacker in this so analyzing wedding

176
00:07:39,169 --> 00:07:41,210
cake here's a sample and again a short

177
00:07:41,210 --> 00:07:43,759
link to virus total if you're interested

178
00:07:43,759 --> 00:07:45,259
in looking or following along at some

179
00:07:45,259 --> 00:07:49,460
point it's also listed in the paper so

180
00:07:49,460 --> 00:07:50,659
the very first thing we need to start

181
00:07:50,659 --> 00:07:52,610
with is a very quick overview of the

182
00:07:52,610 --> 00:07:54,020
Java native interface if you've never

183
00:07:54,020 --> 00:07:56,360
looked at it basically J&I allows

184
00:07:56,360 --> 00:07:59,150
developers to include compiled C or C++

185
00:07:59,150 --> 00:08:03,409
code within a java application and for

186
00:08:03,409 --> 00:08:05,120
us here that java application is an

187
00:08:05,120 --> 00:08:07,909
android application so the developer

188
00:08:07,909 --> 00:08:11,330
will declare the native methods in their

189
00:08:11,330 --> 00:08:13,639
java code just saying hey this is what

190
00:08:13,639 --> 00:08:16,219
i'm naming these functions what they're

191
00:08:16,219 --> 00:08:19,370
actually implemented or c and c++ so in

192
00:08:19,370 --> 00:08:21,800
your java code you would see just these

193
00:08:21,800 --> 00:08:24,740
declarations no code there but any other

194
00:08:24,740 --> 00:08:26,750
java code can call them and then they

195
00:08:26,750 --> 00:08:29,150
are run from what's been implemented in

196
00:08:29,150 --> 00:08:34,039
C or C++ to do this though that elf for

197
00:08:34,039 --> 00:08:36,708
the library where those methods have

198
00:08:36,708 --> 00:08:38,839
been implemented have to be loaded into

199
00:08:38,839 --> 00:08:42,229
memory so for J and I you can do that

200
00:08:42,229 --> 00:08:44,089
and you call it from your java code with

201
00:08:44,089 --> 00:08:46,760
either a load library or load when these

202
00:08:46,760 --> 00:08:48,980
are called in the java code it calls a

203
00:08:48,980 --> 00:08:51,050
function in the elf library called j and

204
00:08:51,050 --> 00:08:51,630
i

205
00:08:51,630 --> 00:08:56,579
and we'll get to why this matters the

206
00:08:56,579 --> 00:08:58,920
next step in being able to use J&I and

207
00:08:58,920 --> 00:09:03,000
run native code in your java application

208
00:09:03,000 --> 00:09:04,529
is you have to be able to do that

209
00:09:04,529 --> 00:09:07,410
pairing so you've declared these methods

210
00:09:07,410 --> 00:09:09,029
as being native in Java

211
00:09:09,029 --> 00:09:10,949
but they're actually implemented in the

212
00:09:10,949 --> 00:09:14,250
C or C++ library and so you need a way

213
00:09:14,250 --> 00:09:16,470
for the interface to know hey whenever I

214
00:09:16,470 --> 00:09:18,449
call this method in Java this is what

215
00:09:18,449 --> 00:09:20,389
you actually run in the native library

216
00:09:20,389 --> 00:09:23,430
so there are two different ways of what

217
00:09:23,430 --> 00:09:26,190
they call registering this pairing one

218
00:09:26,190 --> 00:09:29,670
is discovery where you simply just name

219
00:09:29,670 --> 00:09:32,160
the function that's in the C or C++

220
00:09:32,160 --> 00:09:36,420
native code with this syntax Java

221
00:09:36,420 --> 00:09:38,519
underscore class name underscore mangled

222
00:09:38,519 --> 00:09:40,470
method name so that's a really clear

223
00:09:40,470 --> 00:09:42,029
easy to find signal as a reverse

224
00:09:42,029 --> 00:09:44,490
engineer the other method that you have

225
00:09:44,490 --> 00:09:47,250
to use if you're not going to name your

226
00:09:47,250 --> 00:09:49,050
functions that and want to strip the

227
00:09:49,050 --> 00:09:50,850
names from them is you have to use the

228
00:09:50,850 --> 00:09:54,540
register native API call and but the

229
00:09:54,540 --> 00:09:55,889
interesting thing is the register

230
00:09:55,889 --> 00:09:58,170
natives API call work requires this

231
00:09:58,170 --> 00:10:01,079
struct that includes the string of the

232
00:10:01,079 --> 00:10:04,730
declared method name the signature of

233
00:10:04,730 --> 00:10:07,980
the native method and then finally a

234
00:10:07,980 --> 00:10:11,130
pointer to the function in C or C++ if

235
00:10:11,130 --> 00:10:13,829
you're not familiar with Java signatures

236
00:10:13,829 --> 00:10:16,230
it looks like the one below here's our

237
00:10:16,230 --> 00:10:19,529
declared method in Java and that's what

238
00:10:19,529 --> 00:10:21,569
the signature would look like so it's a

239
00:10:21,569 --> 00:10:23,939
pretty easy to see pattern it stands out

240
00:10:23,939 --> 00:10:29,310
quite a bit so knowing this I open up

241
00:10:29,310 --> 00:10:31,560
this elf of this app that I really need

242
00:10:31,560 --> 00:10:33,329
to determine if it's malware or not and

243
00:10:33,329 --> 00:10:35,130
the very first thing I look at is

244
00:10:35,130 --> 00:10:37,350
checking to see if any of the function

245
00:10:37,350 --> 00:10:40,050
names have been named those native

246
00:10:40,050 --> 00:10:42,029
methods that were declared in Java I

247
00:10:42,029 --> 00:10:43,589
know I'm trying to find what that

248
00:10:43,589 --> 00:10:45,660
functionality is because I saw in the

249
00:10:45,660 --> 00:10:47,459
Java code that they're being called at

250
00:10:47,459 --> 00:10:49,529
interesting points and so I want to know

251
00:10:49,529 --> 00:10:51,529
what they're putting in the native code

252
00:10:51,529 --> 00:10:54,750
but I can't easily find them in the

253
00:10:54,750 --> 00:10:58,470
function names within my ID database the

254
00:10:58,470 --> 00:11:00,569
next thing I look for is the strings

255
00:11:00,569 --> 00:11:02,610
section because if they're not

256
00:11:02,610 --> 00:11:04,260
using the discovery method of doing that

257
00:11:04,260 --> 00:11:06,630
pairing between the declared method in

258
00:11:06,630 --> 00:11:09,390
the implemented function then that means

259
00:11:09,390 --> 00:11:11,070
they have to have the strings there

260
00:11:11,070 --> 00:11:13,019
because it's called register natives

261
00:11:13,019 --> 00:11:16,320
requires though that however it's not

262
00:11:16,320 --> 00:11:18,779
there there are no method names of

263
00:11:18,779 --> 00:11:21,360
strings and there are no signatures as

264
00:11:21,360 --> 00:11:23,760
strings either so that means something

265
00:11:23,760 --> 00:11:25,950
else has got got to be going on because

266
00:11:25,950 --> 00:11:30,149
it's required for the code to run so I

267
00:11:30,149 --> 00:11:32,130
decided to back up and start with J and

268
00:11:32,130 --> 00:11:35,519
I onload because as I said before that

269
00:11:35,519 --> 00:11:38,100
has to be run whenever the Java code

270
00:11:38,100 --> 00:11:41,399
calls load or load library which is

271
00:11:41,399 --> 00:11:44,459
required to load it in elf so one of the

272
00:11:44,459 --> 00:11:47,430
interesting features of this library is

273
00:11:47,430 --> 00:11:50,760
that all the different army ABI very I

274
00:11:50,760 --> 00:11:53,370
have loaded into Ida and none of them

275
00:11:53,370 --> 00:11:58,140
was Ida able to define the function so

276
00:11:58,140 --> 00:12:00,029
it's they see it as exported but it's

277
00:12:00,029 --> 00:12:01,920
not defined because these two blocks

278
00:12:01,920 --> 00:12:03,390
that are highlighted in yellow are

279
00:12:03,390 --> 00:12:05,430
always defined as data rather than code

280
00:12:05,430 --> 00:12:08,640
so once you redefine those as code

281
00:12:08,640 --> 00:12:11,760
define it as a function you I started my

282
00:12:11,760 --> 00:12:14,850
analysis and very quickly something

283
00:12:14,850 --> 00:12:17,279
stood out at the end of J and I onload

284
00:12:17,279 --> 00:12:20,640
there is a long block of code that is

285
00:12:20,640 --> 00:12:23,579
calling the same function over and over

286
00:12:23,579 --> 00:12:25,680
again but with different pointers as

287
00:12:25,680 --> 00:12:27,779
arguments and this is a really strong

288
00:12:27,779 --> 00:12:29,870
signal of encryption and decryption

289
00:12:29,870 --> 00:12:31,649
because they're running the same

290
00:12:31,649 --> 00:12:33,449
decryption function that function that

291
00:12:33,449 --> 00:12:35,640
that's being called repeatedly over

292
00:12:35,640 --> 00:12:38,220
different blocks of memory so that is

293
00:12:38,220 --> 00:12:39,690
the next place I need to take a look

294
00:12:39,690 --> 00:12:41,910
because I still need to figure out where

295
00:12:41,910 --> 00:12:44,339
are those native methods that are

296
00:12:44,339 --> 00:12:47,070
declared in Java so decrypting it is my

297
00:12:47,070 --> 00:12:50,250
next step so I take a look at the

298
00:12:50,250 --> 00:12:52,920
decryption function and it takes four

299
00:12:52,920 --> 00:12:56,190
different arguments the pointer to the

300
00:12:56,190 --> 00:12:57,750
array of bytes that you want to decrypt

301
00:12:57,750 --> 00:13:00,510
the length of that array and then to

302
00:13:00,510 --> 00:13:02,490
different seed arrays for every single

303
00:13:02,490 --> 00:13:04,260
call to decryption these two seed arrays

304
00:13:04,260 --> 00:13:07,560
are same are the same in this library so

305
00:13:07,560 --> 00:13:09,779
the next thing I needed to do was figure

306
00:13:09,779 --> 00:13:11,250
out what those seed arrays are because I

307
00:13:11,250 --> 00:13:13,560
knew I just wanted to decrypt this code

308
00:13:13,560 --> 00:13:15,310
and I take a quick look

309
00:13:15,310 --> 00:13:17,560
at the generating the seed array

310
00:13:17,560 --> 00:13:21,160
algorithm and this is what cleaned up i

311
00:13:21,160 --> 00:13:24,610
de de compilation looks like so kind of

312
00:13:24,610 --> 00:13:27,550
complex not really clear exactly what

313
00:13:27,550 --> 00:13:29,710
they're generating so i quickly do a

314
00:13:29,710 --> 00:13:33,160
basic translation to python to after

315
00:13:33,160 --> 00:13:35,860
hours of looking at this and decide to

316
00:13:35,860 --> 00:13:38,050
just run it to get the values of the two

317
00:13:38,050 --> 00:13:41,890
arrays and what i find is it's two

318
00:13:41,890 --> 00:13:45,730
arrays from 0 to 255 so this is what

319
00:13:45,730 --> 00:13:47,620
stood out as the first anti reversing

320
00:13:47,620 --> 00:13:50,800
technique because this is a much more

321
00:13:50,800 --> 00:13:53,580
complex algorithm than is necessary to

322
00:13:53,580 --> 00:14:01,180
allocate two arrays from 0 to 255 so not

323
00:14:01,180 --> 00:14:03,850
very easy but what I learned instead of

324
00:14:03,850 --> 00:14:05,770
in what you should do instead of doing

325
00:14:05,770 --> 00:14:08,200
the same as me is next time I would just

326
00:14:08,200 --> 00:14:10,000
run it dynamically in memory and capture

327
00:14:10,000 --> 00:14:13,960
it after presenting this talk at

328
00:14:13,960 --> 00:14:18,100
blackhat in August Chris and noticed

329
00:14:18,100 --> 00:14:20,020
that the constants in the generating

330
00:14:20,020 --> 00:14:22,660
seed array algorithm matches G Lib C's

331
00:14:22,660 --> 00:14:25,150
implementation of Rand which is a simple

332
00:14:25,150 --> 00:14:30,610
linear congruential generator and so the

333
00:14:30,610 --> 00:14:32,440
guess is that maybe they actually had

334
00:14:32,440 --> 00:14:34,480
been attempting to generate random

335
00:14:34,480 --> 00:14:37,450
values and did it wrong and shorten the

336
00:14:37,450 --> 00:14:39,970
period and so based on the other changes

337
00:14:39,970 --> 00:14:41,500
they did they ended up with two arrays

338
00:14:41,500 --> 00:14:42,760
from 0 to 255

339
00:14:42,760 --> 00:14:45,480
but either way when you're a malware

340
00:14:45,480 --> 00:14:48,490
analyst either start and just trying to

341
00:14:48,490 --> 00:14:49,720
get to the bottom of what something's

342
00:14:49,720 --> 00:14:52,480
doing it can still look like an anti

343
00:14:52,480 --> 00:14:57,250
reversing technique so now I'm ready to

344
00:14:57,250 --> 00:14:58,990
understand what this decryption

345
00:14:58,990 --> 00:15:01,300
algorithm is doing or but more

346
00:15:01,300 --> 00:15:02,920
importantly I don't necessarily need to

347
00:15:02,920 --> 00:15:05,110
understand it I just need to get the

348
00:15:05,110 --> 00:15:07,330
what if this elf looks like when it's

349
00:15:07,330 --> 00:15:09,610
decrypted in memory but the overall

350
00:15:09,610 --> 00:15:11,860
framework of what the decryption looks

351
00:15:11,860 --> 00:15:14,230
like each time it's called is it's

352
00:15:14,230 --> 00:15:16,120
passed the array of encrypted bytes it

353
00:15:16,120 --> 00:15:18,460
does the decryption and then it over

354
00:15:18,460 --> 00:15:20,410
writes the previously encrypted bytes

355
00:15:20,410 --> 00:15:22,510
with the new decrypted ones so they're

356
00:15:22,510 --> 00:15:24,010
not writing it somewhere else in memory

357
00:15:24,010 --> 00:15:26,110
as this load is happening because

358
00:15:26,110 --> 00:15:27,790
remember this is in j and i on

359
00:15:27,790 --> 00:15:29,740
they're actually decrypting them in

360
00:15:29,740 --> 00:15:33,460
place I have not identified this as any

361
00:15:33,460 --> 00:15:35,920
known encryption or a decryption

362
00:15:35,920 --> 00:15:38,680
algorithm but it's in the document and I

363
00:15:38,680 --> 00:15:41,290
also in my paper and so if any of you

364
00:15:41,290 --> 00:15:43,060
all do notice it as a known one I'd be

365
00:15:43,060 --> 00:15:46,840
very interested in hearing so at this

366
00:15:46,840 --> 00:15:49,090
point I really don't care though to

367
00:15:49,090 --> 00:15:51,190
fully understand every aspect of it I

368
00:15:51,190 --> 00:15:53,830
just want a solution that is going to

369
00:15:53,830 --> 00:15:55,360
decrypt it and show it to me what it

370
00:15:55,360 --> 00:15:57,070
looks like in memory and also be

371
00:15:57,070 --> 00:15:59,440
flexible and abstract enough that I can

372
00:15:59,440 --> 00:16:01,360
run it across the many different samples

373
00:16:01,360 --> 00:16:03,940
I have and not be dependent on the

374
00:16:03,940 --> 00:16:07,840
specific memory addresses or registers

375
00:16:07,840 --> 00:16:10,930
that the disassembled version is now so

376
00:16:10,930 --> 00:16:13,330
I chose to use an Ida Python script the

377
00:16:13,330 --> 00:16:15,970
script is open source it's available and

378
00:16:15,970 --> 00:16:19,180
my Ida Python embedded toolkit repo and

379
00:16:19,180 --> 00:16:21,490
if you're more interested in hearing my

380
00:16:21,490 --> 00:16:23,440
thought process about how I build it why

381
00:16:23,440 --> 00:16:26,080
I built it the way I did you can check

382
00:16:26,080 --> 00:16:28,510
out both the paper or my black hat talk

383
00:16:28,510 --> 00:16:31,780
which was a longer time period so I run

384
00:16:31,780 --> 00:16:34,930
this I had a Python script over my Ida

385
00:16:34,930 --> 00:16:37,060
database of the library and what I find

386
00:16:37,060 --> 00:16:39,550
is what previously looks like random

387
00:16:39,550 --> 00:16:42,040
encrypted bytes at the top I now have

388
00:16:42,040 --> 00:16:44,440
all these strings and then it is now

389
00:16:44,440 --> 00:16:46,210
showing me all of the missing strings

390
00:16:46,210 --> 00:16:49,030
that I knew how to be there that weren't

391
00:16:49,030 --> 00:16:51,700
in the original library so now we can

392
00:16:51,700 --> 00:16:53,860
clearly see we have all those signatures

393
00:16:53,860 --> 00:16:58,240
we needed and clearly we now have here a

394
00:16:58,240 --> 00:17:02,260
structure that points to the string of

395
00:17:02,260 --> 00:17:05,560
our method named VX eg a string or a

396
00:17:05,560 --> 00:17:07,569
pointer to the string of the signature

397
00:17:07,569 --> 00:17:10,030
for that Java declared method and then

398
00:17:10,030 --> 00:17:13,150
the pointer to the function of where

399
00:17:13,150 --> 00:17:15,550
that code is actually implemented so now

400
00:17:15,550 --> 00:17:17,199
we get back to our original goal of

401
00:17:17,199 --> 00:17:19,480
being able to reverse-engineer and

402
00:17:19,480 --> 00:17:23,290
understand what the native methods were

403
00:17:23,290 --> 00:17:26,680
doing in the java application and this

404
00:17:26,680 --> 00:17:29,110
leads us into all of the runtime

405
00:17:29,110 --> 00:17:32,920
environment checks still from the

406
00:17:32,920 --> 00:17:35,050
malware authors point of view or the

407
00:17:35,050 --> 00:17:37,060
developers of wedding-cake the goal of

408
00:17:37,060 --> 00:17:38,980
all of these runtime environment checks

409
00:17:38,980 --> 00:17:41,429
to detect if the application is being

410
00:17:41,429 --> 00:17:44,980
dynamically analyzed debug or emulated

411
00:17:44,980 --> 00:17:46,540
and they don't want to run in those

412
00:17:46,540 --> 00:17:48,940
cases but what that means and based on

413
00:17:48,940 --> 00:17:50,770
the checks they've choose they're also

414
00:17:50,770 --> 00:17:54,010
willing to limit the potential targets

415
00:17:54,010 --> 00:17:55,900
of where their malware is running in

416
00:17:55,900 --> 00:17:58,870
order to prevent them from being

417
00:17:58,870 --> 00:18:01,860
detected and that gets into this sort of

418
00:18:01,860 --> 00:18:05,530
asymmetric investment between malware

419
00:18:05,530 --> 00:18:07,809
analysts and malware developers they

420
00:18:07,809 --> 00:18:09,309
want to make it harder for us to

421
00:18:09,309 --> 00:18:10,809
understand what they're doing and

422
00:18:10,809 --> 00:18:13,450
willing to risk losing a small portion

423
00:18:13,450 --> 00:18:17,890
of the potential targets so the very

424
00:18:17,890 --> 00:18:22,750
first oh I I lost a slide so I started

425
00:18:22,750 --> 00:18:25,990
my analysis of VX e G that function that

426
00:18:25,990 --> 00:18:27,549
we now know where the M limit and

427
00:18:27,549 --> 00:18:29,770
pointers are and that's where I saw this

428
00:18:29,770 --> 00:18:31,720
start of all of these different runtime

429
00:18:31,720 --> 00:18:34,570
analysis checks so the very first steps

430
00:18:34,570 --> 00:18:37,350
of that function that we now have found

431
00:18:37,350 --> 00:18:40,330
is it goes through and checks the values

432
00:18:40,330 --> 00:18:43,419
of 37 specific system properties within

433
00:18:43,419 --> 00:18:45,640
the Android library they're all listed

434
00:18:45,640 --> 00:18:48,940
in the paper as well as linked here but

435
00:18:48,940 --> 00:18:51,309
basically they're trying to check if you

436
00:18:51,309 --> 00:18:54,309
are running on an emulator or debugging

437
00:18:54,309 --> 00:18:57,100
board after if you've made it through

438
00:18:57,100 --> 00:19:01,260
all 37 of those checks then it will

439
00:19:01,260 --> 00:19:04,809
check for the existence of any of the

440
00:19:04,809 --> 00:19:07,120
these next five that are listed here on

441
00:19:07,120 --> 00:19:11,230
the right side so VBox key mu goldfish

442
00:19:11,230 --> 00:19:13,090
these are all emulators as well so

443
00:19:13,090 --> 00:19:14,260
they're really trying to cover the

444
00:19:14,260 --> 00:19:16,570
different emulators in the space to

445
00:19:16,570 --> 00:19:18,760
ensure that they're not running and so

446
00:19:18,760 --> 00:19:20,470
one of the keys things that for all of

447
00:19:20,470 --> 00:19:22,570
these runtime environment checks if a

448
00:19:22,570 --> 00:19:26,830
single one of the 47 I believe 45 Plus

449
00:19:26,830 --> 00:19:31,059
fails it will call Linux it's exit

450
00:19:31,059 --> 00:19:33,340
command and stop the application the

451
00:19:33,340 --> 00:19:35,500
application won't run so a single one of

452
00:19:35,500 --> 00:19:37,929
these will cause the application to no

453
00:19:37,929 --> 00:19:42,990
longer run if you've made it through all

454
00:19:42,990 --> 00:19:46,360
40 plus of the system property checks

455
00:19:46,360 --> 00:19:48,909
the next thing they do is check what CPU

456
00:19:48,909 --> 00:19:51,280
architecture you're running on obviously

457
00:19:51,280 --> 00:19:52,150
arm

458
00:19:52,150 --> 00:19:55,840
most mobile devices and so that's what

459
00:19:55,840 --> 00:19:58,330
they're looking for but to do this they

460
00:19:58,330 --> 00:20:01,420
actually will read 20 bytes from the

461
00:20:01,420 --> 00:20:03,910
beginning of Lib C which is the elf

462
00:20:03,910 --> 00:20:06,040
header and then they will check two

463
00:20:06,040 --> 00:20:07,240
values there first

464
00:20:07,240 --> 00:20:10,990
eeew dn't eClass which is whether it's

465
00:20:10,990 --> 00:20:14,260
running a 32-bit or 64-bit and then the

466
00:20:14,260 --> 00:20:17,080
machine so they are looking for only two

467
00:20:17,080 --> 00:20:19,810
combinations are possible 32-bit ARM or

468
00:20:19,810 --> 00:20:22,510
64-bit arc this is especially

469
00:20:22,510 --> 00:20:24,580
interesting when if you remember earlier

470
00:20:24,580 --> 00:20:26,380
on I told you that there are x86

471
00:20:26,380 --> 00:20:28,050
versions of this library about

472
00:20:28,050 --> 00:20:32,050
applications so in those cases it will

473
00:20:32,050 --> 00:20:35,020
still run the library up until this

474
00:20:35,020 --> 00:20:36,700
point and then fail they're still in

475
00:20:36,700 --> 00:20:39,070
those x86 implementations looking to

476
00:20:39,070 --> 00:20:43,120
make sure you're running on arm the next

477
00:20:43,120 --> 00:20:44,500
runtime environment check they will look

478
00:20:44,500 --> 00:20:46,840
for is to see whether or not monkey is

479
00:20:46,840 --> 00:20:50,530
running so monkey is a package that is

480
00:20:50,530 --> 00:20:52,510
used when you're running on an emulator

481
00:20:52,510 --> 00:20:55,840
do test and simulate user clicks wipes

482
00:20:55,840 --> 00:20:57,760
things like that so you can test those

483
00:20:57,760 --> 00:20:59,560
without having to actually sit there and

484
00:20:59,560 --> 00:21:02,110
run them yourself so the ways that they

485
00:21:02,110 --> 00:21:04,300
go about looking for each of these is

486
00:21:04,300 --> 00:21:06,480
they're going to iterate through every

487
00:21:06,480 --> 00:21:10,270
single pit directory under proc to see

488
00:21:10,270 --> 00:21:12,760
if they can find the monkey package jams

489
00:21:12,760 --> 00:21:14,620
note that this no longer works on

490
00:21:14,620 --> 00:21:18,430
android and plus but they still attempt

491
00:21:18,430 --> 00:21:20,950
it in the case that it's Android n plus

492
00:21:20,950 --> 00:21:24,670
and it fails on opening proc they will

493
00:21:24,670 --> 00:21:26,050
actually still continue

494
00:21:26,050 --> 00:21:29,800
they only exit if they find androids

495
00:21:29,800 --> 00:21:33,010
or monkey so this is the whole step of

496
00:21:33,010 --> 00:21:35,410
how they actually go about doing this is

497
00:21:35,410 --> 00:21:39,580
that they look to see after they've

498
00:21:39,580 --> 00:21:41,200
opened proc they iterate through every

499
00:21:41,200 --> 00:21:43,570
node under proc looking to see if it has

500
00:21:43,570 --> 00:21:46,000
the directory file type or not then they

501
00:21:46,000 --> 00:21:47,860
check to see if the name of that node

502
00:21:47,860 --> 00:21:50,710
under proc is an integer they construct

503
00:21:50,710 --> 00:21:52,360
these two paths for calm and

504
00:21:52,360 --> 00:21:54,820
command-line read seven F bytes look

505
00:21:54,820 --> 00:21:56,860
through all whichever one has more bytes

506
00:21:56,860 --> 00:22:00,419
checking for monkey

507
00:22:01,159 --> 00:22:03,440
the final sort of grouping of runtime

508
00:22:03,440 --> 00:22:05,809
environment checks that let's do is

509
00:22:05,809 --> 00:22:08,359
looking for the xposed framework so

510
00:22:08,359 --> 00:22:11,649
exposed is used a hook and analyze

511
00:22:11,649 --> 00:22:16,789
Android applications so for here what

512
00:22:16,789 --> 00:22:18,919
they will do is they look in proc self

513
00:22:18,919 --> 00:22:22,759
maps first and will look for live

514
00:22:22,759 --> 00:22:26,090
exposed art or exposed bridge jar and if

515
00:22:26,090 --> 00:22:28,159
either of those exists it decides to

516
00:22:28,159 --> 00:22:31,639
exit if that still succeeds they want to

517
00:22:31,639 --> 00:22:33,379
do one more check to make sure exposed

518
00:22:33,379 --> 00:22:35,779
really isn't running and that's when the

519
00:22:35,779 --> 00:22:38,059
they will use the fine class method for

520
00:22:38,059 --> 00:22:39,649
J and I and look for either of these two

521
00:22:39,649 --> 00:22:43,399
classes to see if it is in application

522
00:22:43,399 --> 00:22:48,259
process so we got to all of we got

523
00:22:48,259 --> 00:22:50,299
through finally all of the different

524
00:22:50,299 --> 00:22:52,039
checks that wedding-cake

525
00:22:52,039 --> 00:22:54,649
implements so if you have gotten through

526
00:22:54,649 --> 00:22:56,779
all of these not a single one of them

527
00:22:56,779 --> 00:22:59,210
fails then what I found was it had the

528
00:22:59,210 --> 00:23:01,249
exact same functionality as the earlier

529
00:23:01,249 --> 00:23:02,809
versions of Shema that i had looked at

530
00:23:02,809 --> 00:23:05,059
for this application so i got my answer

531
00:23:05,059 --> 00:23:08,269
of whether or not it was malware but it

532
00:23:08,269 --> 00:23:12,649
took quite a bit of time to get there so

533
00:23:12,649 --> 00:23:15,320
interestingly before blackhat when I was

534
00:23:15,320 --> 00:23:16,970
writing the paper everything here I've

535
00:23:16,970 --> 00:23:18,470
been tracking looking at the different

536
00:23:18,470 --> 00:23:21,619
evolutions of wedding-cake watch looking

537
00:23:21,619 --> 00:23:22,999
at all the different samples where was

538
00:23:22,999 --> 00:23:25,279
used in the Android ecosystem and so

539
00:23:25,279 --> 00:23:27,529
obviously after going public with this I

540
00:23:27,529 --> 00:23:29,470
was very interested in what would happen

541
00:23:29,470 --> 00:23:32,450
so the biggest change is the elf is no

542
00:23:32,450 --> 00:23:35,559
longer statically included in the apk

543
00:23:35,559 --> 00:23:38,599
instead when you open up the apk there's

544
00:23:38,599 --> 00:23:41,539
no longer a file of elfs within it they

545
00:23:41,539 --> 00:23:42,799
will now do a couple of different

546
00:23:42,799 --> 00:23:45,259
techniques to dynamically download the

547
00:23:45,259 --> 00:23:48,830
elf and then run it but if you can get

548
00:23:48,830 --> 00:23:51,619
the elf to dynamically download then

549
00:23:51,619 --> 00:23:54,109
it's really just some cosmetic changes

550
00:23:54,109 --> 00:23:57,379
I'm assuming probably to test if I was

551
00:23:57,379 --> 00:23:59,359
signature specific types of bytes or

552
00:23:59,359 --> 00:24:01,309
things like that within the library

553
00:24:01,309 --> 00:24:02,840
because they moved some of those

554
00:24:02,840 --> 00:24:05,989
encryption initialization contents just

555
00:24:05,989 --> 00:24:08,479
around keeping the same ones but just

556
00:24:08,479 --> 00:24:10,369
putting them at different places and in

557
00:24:10,369 --> 00:24:14,330
different orders so that means

558
00:24:14,330 --> 00:24:17,490
description script that I released still

559
00:24:17,490 --> 00:24:20,940
works will still decrypt it and all of

560
00:24:20,940 --> 00:24:23,190
these Sam runtime environments are the

561
00:24:23,190 --> 00:24:24,630
same ones that are being used and there

562
00:24:24,630 --> 00:24:30,600
haven't been any changes to that yet so

563
00:24:30,600 --> 00:24:34,650
in conclusion one of the interesting

564
00:24:34,650 --> 00:24:38,250
things I found was as the low-hanging

565
00:24:38,250 --> 00:24:41,460
fruit in the Android ecosystem gets to

566
00:24:41,460 --> 00:24:45,390
be less low-hanging basically we're

567
00:24:45,390 --> 00:24:48,390
seeing that our authors are willing to

568
00:24:48,390 --> 00:24:50,460
miss out on some potential targets if

569
00:24:50,460 --> 00:24:53,190
that means extending their longevity and

570
00:24:53,190 --> 00:24:55,350
not being a detected and so they're

571
00:24:55,350 --> 00:24:57,030
putting more effort into developing

572
00:24:57,030 --> 00:24:59,550
complex anti analysis technique weeks

573
00:24:59,550 --> 00:25:01,290
cloaking techniques things like that

574
00:25:01,290 --> 00:25:03,420
what was interesting to me about this

575
00:25:03,420 --> 00:25:06,090
library too though was how they layered

576
00:25:06,090 --> 00:25:08,280
all of the different techniques because

577
00:25:08,280 --> 00:25:11,070
they target the human reviewer through

578
00:25:11,070 --> 00:25:14,360
anti re and decryption or static

579
00:25:14,360 --> 00:25:16,920
reviewer in that sense and then they

580
00:25:16,920 --> 00:25:19,340
also try and prevent dynamic analysis as

581
00:25:19,340 --> 00:25:23,030
well as finally preventing debugging

582
00:25:23,030 --> 00:25:25,050
emulation and different things that

583
00:25:25,050 --> 00:25:27,240
might be in an automated pipeline so I

584
00:25:27,240 --> 00:25:28,680
thought that was interesting and how

585
00:25:28,680 --> 00:25:30,180
they sort of broke it out to target

586
00:25:30,180 --> 00:25:33,210
those different reviewers and with that

587
00:25:33,210 --> 00:25:36,770
thank you I'll take any questions

588
00:25:36,970 --> 00:25:41,859
[Applause]

