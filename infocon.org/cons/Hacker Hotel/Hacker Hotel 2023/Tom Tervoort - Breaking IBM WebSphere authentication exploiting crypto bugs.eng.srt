1
00:03:58,799 --> 00:04:01,080
it's your session uh when you're going

2
00:04:01,080 --> 00:04:03,000
to a web shop and you buy things you

3
00:04:03,000 --> 00:04:04,440
want them to stay into your shopping

4
00:04:04,440 --> 00:04:07,319
cart and the situation traditional way

5
00:04:07,319 --> 00:04:09,900
to achieve this is uh with a so-called

6
00:04:09,900 --> 00:04:11,580
session identifier just a random

7
00:04:11,580 --> 00:04:13,680
unguessable number that you sent to the

8
00:04:13,680 --> 00:04:16,380
clients and with every uh request within

9
00:04:16,380 --> 00:04:18,478
a session the clients submits this

10
00:04:18,478 --> 00:04:22,560
number and the surfer looks up what the

11
00:04:22,560 --> 00:04:23,820
state of the session is what kind of

12
00:04:23,820 --> 00:04:25,139
items do you currently have in your

13
00:04:25,139 --> 00:04:27,660
shopping baskets for example

14
00:04:27,660 --> 00:04:31,560
and uh whenever you're uh scaling up

15
00:04:31,560 --> 00:04:33,300
your application and using multiple

16
00:04:33,300 --> 00:04:34,919
application servers you need to find

17
00:04:34,919 --> 00:04:36,360
some way to synchronize the session

18
00:04:36,360 --> 00:04:38,880
State between them so that when fr1

19
00:04:38,880 --> 00:04:41,400
server goes down or your request just

20
00:04:41,400 --> 00:04:43,139
happens to get load balanced to another

21
00:04:43,139 --> 00:04:45,660
Surfer uh you don't suddenly lose all

22
00:04:45,660 --> 00:04:47,340
the context contents of your shopping

23
00:04:47,340 --> 00:04:49,199
baskets

24
00:04:49,199 --> 00:04:51,479
um so you need to have some kind of

25
00:04:51,479 --> 00:04:53,580
central database can be a regular SQL

26
00:04:53,580 --> 00:04:56,100
database can be a key Value Store can be

27
00:04:56,100 --> 00:05:00,560
a specialized session database where you

28
00:05:00,560 --> 00:05:02,100
yeah

29
00:05:02,100 --> 00:05:04,520
thanks

30
00:05:09,120 --> 00:05:12,120
oh

31
00:05:12,419 --> 00:05:14,479
yeah yeah

32
00:05:25,440 --> 00:05:27,539
don't kill

33
00:05:27,539 --> 00:05:29,659
us

34
00:05:29,940 --> 00:05:31,860
um

35
00:05:31,860 --> 00:05:34,979
um this is very useful uh you you have

36
00:05:34,979 --> 00:05:37,199
one consistent source of truth about

37
00:05:37,199 --> 00:05:38,940
what's this current state if your

38
00:05:38,940 --> 00:05:41,580
session is but it does require these

39
00:05:41,580 --> 00:05:43,139
additional lookups to a centralized

40
00:05:43,139 --> 00:05:44,220
store

41
00:05:44,220 --> 00:05:47,100
so another approach that you see more

42
00:05:47,100 --> 00:05:50,580
and more is to basically throw away this

43
00:05:50,580 --> 00:05:52,860
session centralized session storage and

44
00:05:52,860 --> 00:05:54,479
store the session information on the

45
00:05:54,479 --> 00:05:56,340
clients

46
00:05:56,340 --> 00:05:58,979
um of course in many cases you do not

47
00:05:58,979 --> 00:06:01,199
actually trust the clients to provide

48
00:06:01,199 --> 00:06:02,880
accurate session information especially

49
00:06:02,880 --> 00:06:04,979
when the session information contains

50
00:06:04,979 --> 00:06:07,680
something like uh well your privileges

51
00:06:07,680 --> 00:06:09,360
like for example I am an administrator

52
00:06:09,360 --> 00:06:11,580
you don't want users to decide that

53
00:06:11,580 --> 00:06:15,120
themselves so you use cryptography to

54
00:06:15,120 --> 00:06:16,500
prevent people from messing with their

55
00:06:16,500 --> 00:06:19,320
own sessions so instead of sending a

56
00:06:19,320 --> 00:06:22,020
short identifier you basically send all

57
00:06:22,020 --> 00:06:23,940
accession data to the client as like a

58
00:06:23,940 --> 00:06:27,120
cookie or an item in local storage and

59
00:06:27,120 --> 00:06:28,979
you use cryptography to protect it

60
00:06:28,979 --> 00:06:31,259
against tampering

61
00:06:31,259 --> 00:06:32,580
um this

62
00:06:32,580 --> 00:06:35,160
that's myself this does have a few uh

63
00:06:35,160 --> 00:06:37,560
potential issues and additional risks

64
00:06:37,560 --> 00:06:39,539
you have to take into account so first

65
00:06:39,539 --> 00:06:42,539
of all um I can always just swap out my

66
00:06:42,539 --> 00:06:44,460
session data with an older version of my

67
00:06:44,460 --> 00:06:46,979
session uh data you also need to think

68
00:06:46,979 --> 00:06:48,900
about how you want to invalidate them

69
00:06:48,900 --> 00:06:50,460
usually this is done by an expiration

70
00:06:50,460 --> 00:06:53,340
timestamp embedded in the session data

71
00:06:53,340 --> 00:06:55,979
itself and you certainly have to deal

72
00:06:55,979 --> 00:06:57,419
with cryptography now which means you

73
00:06:57,419 --> 00:06:59,340
have to keep some key secrets and it

74
00:06:59,340 --> 00:07:00,600
happens pretty often that people

75
00:07:00,600 --> 00:07:02,940
accidentally uh commit the key that they

76
00:07:02,940 --> 00:07:04,800
use for protection of the session data

77
00:07:04,800 --> 00:07:06,840
to their public GitHub or it leaks out

78
00:07:06,840 --> 00:07:08,280
in some other way or they pick the

79
00:07:08,280 --> 00:07:10,139
default that was in the code sample or

80
00:07:10,139 --> 00:07:12,539
in stack Overflow and when you know this

81
00:07:12,539 --> 00:07:14,280
key you can match with session data and

82
00:07:14,280 --> 00:07:15,900
usually that results in authentication

83
00:07:15,900 --> 00:07:17,699
by passers or privilege escalation

84
00:07:17,699 --> 00:07:19,440
vulnerabilities because you can change

85
00:07:19,440 --> 00:07:21,599
anything about your session and usually

86
00:07:21,599 --> 00:07:23,759
that's pretty bad

87
00:07:23,759 --> 00:07:25,440
um and besides all of that if you

88
00:07:25,440 --> 00:07:27,000
organize it properly keep your key

89
00:07:27,000 --> 00:07:30,380
Secrets this can have some advantages

90
00:07:30,380 --> 00:07:32,340
especially when it comes to Performance

91
00:07:32,340 --> 00:07:34,020
if you want to scale up really widely

92
00:07:34,020 --> 00:07:36,720
you no longer need the session store uh

93
00:07:36,720 --> 00:07:38,160
there's definitely some use cases

94
00:07:38,160 --> 00:07:40,259
especially on large scales where this is

95
00:07:40,259 --> 00:07:42,180
a good solution

96
00:07:42,180 --> 00:07:44,099
um but of course even if you manage your

97
00:07:44,099 --> 00:07:45,319
keys correctly

98
00:07:45,319 --> 00:07:47,880
you also need to use the right kinds of

99
00:07:47,880 --> 00:07:50,039
cryptography and that's where I'm going

100
00:07:50,039 --> 00:07:52,380
to focus on right now and specifically

101
00:07:52,380 --> 00:07:55,620
one implementation of this calls the

102
00:07:55,620 --> 00:07:57,960
ltpa the lightword third-party

103
00:07:57,960 --> 00:08:00,000
authentication mechanism you can

104
00:08:00,000 --> 00:08:01,860
recognize it whenever you're logging

105
00:08:01,860 --> 00:08:03,240
into an application you get a cookie

106
00:08:03,240 --> 00:08:05,580
like that looks like this you're dealing

107
00:08:05,580 --> 00:08:08,099
probably with a web sphere Surfer

108
00:08:08,099 --> 00:08:10,319
um and it's using this type of

109
00:08:10,319 --> 00:08:12,060
authentication mechanism

110
00:08:12,060 --> 00:08:14,940
so ltpa tokens they're used for various

111
00:08:14,940 --> 00:08:17,940
purposes also single sign-on protocols

112
00:08:17,940 --> 00:08:19,919
but most of the time they're used as a

113
00:08:19,919 --> 00:08:21,419
kind of an alternative for a session

114
00:08:21,419 --> 00:08:23,759
identifier they don't really contain

115
00:08:23,759 --> 00:08:25,620
much session States other than the

116
00:08:25,620 --> 00:08:27,979
identity of the current user so

117
00:08:27,979 --> 00:08:30,900
basically you use this to cookie to

118
00:08:30,900 --> 00:08:33,120
prove after logging in once you get a

119
00:08:33,120 --> 00:08:34,860
cookie like this and this proves that

120
00:08:34,860 --> 00:08:37,500
you are who you say you are and because

121
00:08:37,500 --> 00:08:39,299
of the use of cryptography you can send

122
00:08:39,299 --> 00:08:41,219
this cookie to multiple web servers and

123
00:08:41,219 --> 00:08:42,539
without communicating with each other

124
00:08:42,539 --> 00:08:45,120
these different web servers know ah this

125
00:08:45,120 --> 00:08:46,920
user has logs in at one of our web

126
00:08:46,920 --> 00:08:49,800
servers has been authenticated we now

127
00:08:49,800 --> 00:08:52,380
know their identity

128
00:08:52,380 --> 00:08:55,680
and how this actually works so the whole

129
00:08:55,680 --> 00:08:59,880
token is encrypted using AES and within

130
00:08:59,880 --> 00:09:03,420
uh there's a specific type of Syntax for

131
00:09:03,420 --> 00:09:06,120
this kind of token that contains uh most

132
00:09:06,120 --> 00:09:10,620
importantly your user identity in the uh

133
00:09:10,620 --> 00:09:12,360
in the form of some kind of application

134
00:09:12,360 --> 00:09:14,339
specific identifier so the application

135
00:09:14,339 --> 00:09:16,019
should be able to know what this

136
00:09:16,019 --> 00:09:18,180
identity means and determine what kind

137
00:09:18,180 --> 00:09:21,060
of level of access you have so all the

138
00:09:21,060 --> 00:09:22,680
token really does is prove that you have

139
00:09:22,680 --> 00:09:25,680
authenticated as this particular user it

140
00:09:25,680 --> 00:09:28,620
also has an expiration timestamp so

141
00:09:28,620 --> 00:09:31,080
that's your session can't be reused

142
00:09:31,080 --> 00:09:32,820
indefinitely for example when you log in

143
00:09:32,820 --> 00:09:35,940
it's valid for 30 minutes and then

144
00:09:35,940 --> 00:09:38,100
unless the token gets renewed after 30

145
00:09:38,100 --> 00:09:39,839
minutes your session will effectively

146
00:09:39,839 --> 00:09:42,779
end because the token is no longer valid

147
00:09:42,779 --> 00:09:45,120
this first part of the session in green

148
00:09:45,120 --> 00:09:48,060
here is called the signed user data and

149
00:09:48,060 --> 00:09:50,580
this is also protected by an RSA

150
00:09:50,580 --> 00:09:53,480
signature to protect against tampering

151
00:09:53,480 --> 00:09:55,920
then there's a little part in the middle

152
00:09:55,920 --> 00:09:58,019
which is basically a copy of your

153
00:09:58,019 --> 00:10:00,600
expiration date that is not science the

154
00:10:00,600 --> 00:10:02,220
reason for this is that older versions

155
00:10:02,220 --> 00:10:04,980
of the software uh didn't sign

156
00:10:04,980 --> 00:10:06,839
expiration dates it was just in the

157
00:10:06,839 --> 00:10:08,100
middle here it was not covered by the

158
00:10:08,100 --> 00:10:10,260
signature which creates a tempering risk

159
00:10:10,260 --> 00:10:12,959
they saw that so then they also added it

160
00:10:12,959 --> 00:10:15,620
to the signed part of the message

161
00:10:15,620 --> 00:10:19,080
and what's a server does to process this

162
00:10:19,080 --> 00:10:21,120
in practice they first look at the

163
00:10:21,120 --> 00:10:22,200
signed parts

164
00:10:22,200 --> 00:10:23,820
validator signature if there's an

165
00:10:23,820 --> 00:10:26,060
expiration timestamp in there

166
00:10:26,060 --> 00:10:28,320
it'll just use that one and completely

167
00:10:28,320 --> 00:10:30,360
ignore the middle block only when the

168
00:10:30,360 --> 00:10:31,920
site message doesn't have an expiration

169
00:10:31,920 --> 00:10:33,779
a timestamp it will fall back on the

170
00:10:33,779 --> 00:10:35,700
middle block but if it does then this

171
00:10:35,700 --> 00:10:37,440
middle part is just completely ignored

172
00:10:37,440 --> 00:10:39,540
and conclude contain any kind of

173
00:10:39,540 --> 00:10:43,339
arbitrary garbage basically

174
00:10:43,560 --> 00:10:48,120
so to manage Keys you have a file called

175
00:10:48,120 --> 00:10:52,079
ltpa dot keys this contains your RSA

176
00:10:52,079 --> 00:10:55,339
private key and your as key the

177
00:10:55,339 --> 00:10:57,839
configuration option is still labeled

178
00:10:57,839 --> 00:10:59,220
triple desk key but it's actually not

179
00:10:59,220 --> 00:11:00,980
used for triple this

180
00:11:00,980 --> 00:11:04,380
and if you want multiple servers to use

181
00:11:04,380 --> 00:11:06,420
the same kind of session tokens you just

182
00:11:06,420 --> 00:11:08,160
copy this file to these multiple servers

183
00:11:08,160 --> 00:11:10,079
these are randomly generated when you

184
00:11:10,079 --> 00:11:13,320
set up a new websphere instance the keys

185
00:11:13,320 --> 00:11:15,540
are also password protected but by

186
00:11:15,540 --> 00:11:17,339
default it's a hard-coded standards

187
00:11:17,339 --> 00:11:21,000
password something like was admin so in

188
00:11:21,000 --> 00:11:23,220
99 of cases they will be protected with

189
00:11:23,220 --> 00:11:25,440
the standard passwords this also means

190
00:11:25,440 --> 00:11:27,360
that if you accidentally Commit This to

191
00:11:27,360 --> 00:11:29,519
your public GitHub Anyone who reads this

192
00:11:29,519 --> 00:11:31,260
can completely impersonate all users

193
00:11:31,260 --> 00:11:34,440
because they can forge their own tokens

194
00:11:34,440 --> 00:11:35,760
um and if you go Googling for this

195
00:11:35,760 --> 00:11:37,019
you'll probably find quite a few

196
00:11:37,019 --> 00:11:38,640
instances where people have accidentally

197
00:11:38,640 --> 00:11:42,060
published their case File uh but let's

198
00:11:42,060 --> 00:11:43,680
assume that people keep their case File

199
00:11:43,680 --> 00:11:45,959
secrets and that this is completely

200
00:11:45,959 --> 00:11:47,700
unknown to an attacker

201
00:11:47,700 --> 00:11:50,519
what can we do

202
00:11:50,519 --> 00:11:52,800
um well the first type of attack has to

203
00:11:52,800 --> 00:11:55,140
do with this specific type of tokens

204
00:11:55,140 --> 00:11:58,440
syntax that's uh used within the

205
00:11:58,440 --> 00:12:00,899
encrypted token

206
00:12:00,899 --> 00:12:02,399
so

207
00:12:02,399 --> 00:12:04,140
um what I showed before was basically a

208
00:12:04,140 --> 00:12:06,120
token with two Fields a user identifier

209
00:12:06,120 --> 00:12:08,459
and expiration dates but actually the

210
00:12:08,459 --> 00:12:10,860
component that parses this supports a

211
00:12:10,860 --> 00:12:13,860
whole uh much more extensive syntax to

212
00:12:13,860 --> 00:12:15,920
contain like arbitrary key value pairs

213
00:12:15,920 --> 00:12:19,140
so the web server will validate all the

214
00:12:19,140 --> 00:12:21,240
cryptography and then it will parse this

215
00:12:21,240 --> 00:12:24,180
token and store it into an internal data

216
00:12:24,180 --> 00:12:25,620
structure it looks something like this

217
00:12:25,620 --> 00:12:28,740
so you have a differently labeled keys

218
00:12:28,740 --> 00:12:33,060
and each key can have one or more values

219
00:12:33,060 --> 00:12:35,160
um when this is serialized again and put

220
00:12:35,160 --> 00:12:38,100
into a token the difference key value

221
00:12:38,100 --> 00:12:41,100
pairs are separated by dollar signs

222
00:12:41,100 --> 00:12:42,899
um the key and the value themselves are

223
00:12:42,899 --> 00:12:44,880
separated by a colon and when there's

224
00:12:44,880 --> 00:12:46,560
multiple values these different values

225
00:12:46,560 --> 00:12:51,000
are separated by bar characters

226
00:12:51,000 --> 00:12:53,100
um also if your value happens to contain

227
00:12:53,100 --> 00:12:54,660
one of these special characters a

228
00:12:54,660 --> 00:12:56,160
backslash is put in front of it to

229
00:12:56,160 --> 00:12:57,959
escape it so you can distinguish it from

230
00:12:57,959 --> 00:13:00,899
the uh from the actual separators in

231
00:13:00,899 --> 00:13:03,180
your token

232
00:13:03,180 --> 00:13:06,000
so I took a look at how this parser

233
00:13:06,000 --> 00:13:08,040
works at the source codes of the open

234
00:13:08,040 --> 00:13:10,920
source variants of web sphere and I

235
00:13:10,920 --> 00:13:12,420
found something interesting maybe you

236
00:13:12,420 --> 00:13:14,760
can spot it here so we have these four

237
00:13:14,760 --> 00:13:16,980
types of special characters and then

238
00:13:16,980 --> 00:13:18,839
there's this escaping function that puts

239
00:13:18,839 --> 00:13:20,639
backslashes in front of only three out

240
00:13:20,639 --> 00:13:22,800
of four of them so they forgot one of

241
00:13:22,800 --> 00:13:24,540
the characters the bar characters they

242
00:13:24,540 --> 00:13:28,260
forgot to escape it also uh um they

243
00:13:28,260 --> 00:13:30,060
forgot to escape the backslash character

244
00:13:30,060 --> 00:13:32,220
itself so the Escape function is a bit

245
00:13:32,220 --> 00:13:36,000
insufficient with the bar character so

246
00:13:36,000 --> 00:13:37,740
what could we do with this

247
00:13:37,740 --> 00:13:40,320
well let's say we have an application

248
00:13:40,320 --> 00:13:42,480
where the attacker is able to decide

249
00:13:42,480 --> 00:13:44,880
their own username typical example of

250
00:13:44,880 --> 00:13:47,220
this would be an app where the user

251
00:13:47,220 --> 00:13:49,860
identifier is their email address you

252
00:13:49,860 --> 00:13:51,899
can sign up with any email address that

253
00:13:51,899 --> 00:13:53,399
you actually own well there's a lot of

254
00:13:53,399 --> 00:13:56,100
freedom in email address syntax uh where

255
00:13:56,100 --> 00:13:57,839
you can come where you can decide most

256
00:13:57,839 --> 00:14:00,180
of your own email address and register

257
00:14:00,180 --> 00:14:02,459
with this and get this into your token

258
00:14:02,459 --> 00:14:04,860
so let's say we have a user called admin

259
00:14:04,860 --> 00:14:07,560
that's the user we want to attack whose

260
00:14:07,560 --> 00:14:09,480
accounts we want to take over and we

261
00:14:09,480 --> 00:14:11,700
register a new user account called admin

262
00:14:11,700 --> 00:14:13,260
bar not really

263
00:14:13,260 --> 00:14:17,339
well you log in the server will put uh

264
00:14:17,339 --> 00:14:19,380
this into an internal data structure so

265
00:14:19,380 --> 00:14:20,720
far so good

266
00:14:20,720 --> 00:14:24,120
where the user fail you contains your

267
00:14:24,120 --> 00:14:28,200
user bar some not really

268
00:14:28,200 --> 00:14:31,440
then it will bake a token for you and

269
00:14:31,440 --> 00:14:33,480
because there's no backslashes in front

270
00:14:33,480 --> 00:14:35,220
of the bar characters it does not get

271
00:14:35,220 --> 00:14:36,620
escaped properly

272
00:14:36,620 --> 00:14:39,720
so whenever you then this serialize the

273
00:14:39,720 --> 00:14:42,839
token again it looks like the whole

274
00:14:42,839 --> 00:14:45,540
username with the admin username and the

275
00:14:45,540 --> 00:14:48,180
not really part are two different values

276
00:14:48,180 --> 00:14:50,459
for the user key

277
00:14:50,459 --> 00:14:53,880
and well what happens next how does the

278
00:14:53,880 --> 00:14:56,519
application interprets a somebody with

279
00:14:56,519 --> 00:14:58,260
two different usernames

280
00:14:58,260 --> 00:15:00,240
it simply picks the first one in the

281
00:15:00,240 --> 00:15:01,860
list there's actually a code that says

282
00:15:01,860 --> 00:15:03,420
well if there's multiple usernames I'll

283
00:15:03,420 --> 00:15:05,279
just pick the first username and I'm

284
00:15:05,279 --> 00:15:06,360
going to assume that this is an

285
00:15:06,360 --> 00:15:09,540
administrator so there we go first CV to

286
00:15:09,540 --> 00:15:14,220
be fair I haven't actually seen an uh

287
00:15:14,220 --> 00:15:16,380
deployments in the Wilds that was

288
00:15:16,380 --> 00:15:18,240
vulnerable to this because most of the

289
00:15:18,240 --> 00:15:20,639
time the usual IDs are not completely

290
00:15:20,639 --> 00:15:22,980
under your control and yeah getting a

291
00:15:22,980 --> 00:15:24,839
character like a bar in your username

292
00:15:24,839 --> 00:15:26,639
like a lot of email validators don't

293
00:15:26,639 --> 00:15:28,920
really allow that so it's mostly

294
00:15:28,920 --> 00:15:31,560
theoretical but uh if you just happen to

295
00:15:31,560 --> 00:15:34,620
have an uh setup that allows people to

296
00:15:34,620 --> 00:15:36,300
pick their own usernames or partially

297
00:15:36,300 --> 00:15:38,040
pick them and have a bar character in

298
00:15:38,040 --> 00:15:40,620
them you might be in trouble

299
00:15:40,620 --> 00:15:42,720
so now let's actually attack the

300
00:15:42,720 --> 00:15:45,720
cryptography because that's the fun part

301
00:15:45,720 --> 00:15:49,199
how does this whole I told you it uses

302
00:15:49,199 --> 00:15:52,440
AES it uses RSA but how does it compose

303
00:15:52,440 --> 00:15:53,699
these different Primitives because

304
00:15:53,699 --> 00:15:56,100
usually it's very rare for people to

305
00:15:56,100 --> 00:15:57,660
completely roll their own crypto but

306
00:15:57,660 --> 00:15:58,920
when you start working with these low

307
00:15:58,920 --> 00:16:00,779
level cryptographic Primitives there's a

308
00:16:00,779 --> 00:16:03,120
lot that can go wrong here so what do

309
00:16:03,120 --> 00:16:05,880
they do first we have the RSA signature

310
00:16:05,880 --> 00:16:09,779
parts that one is actually largely fine

311
00:16:09,779 --> 00:16:11,519
um at least at first sight it appears to

312
00:16:11,519 --> 00:16:13,740
be largely fine and then the encryption

313
00:16:13,740 --> 00:16:16,199
part happens and they use AES in the

314
00:16:16,199 --> 00:16:18,779
so-called CBC modes

315
00:16:18,779 --> 00:16:22,440
um CBC is basically a way of turning a

316
00:16:22,440 --> 00:16:24,360
block Cipher into a more general purpose

317
00:16:24,360 --> 00:16:26,399
Cipher because a block Cipher like AES

318
00:16:26,399 --> 00:16:28,440
what what they can do you give them a

319
00:16:28,440 --> 00:16:29,699
key and you give them an input that's

320
00:16:29,699 --> 00:16:31,980
exactly 16 bytes long it gives you an

321
00:16:31,980 --> 00:16:33,720
output that's exactly 16 bytes long

322
00:16:33,720 --> 00:16:35,579
which is great if you want to encrypt

323
00:16:35,579 --> 00:16:37,199
messages of 16 bytes but when your

324
00:16:37,199 --> 00:16:39,240
messages become longer that no longer

325
00:16:39,240 --> 00:16:40,440
works so you need to use some kind of

326
00:16:40,440 --> 00:16:42,259
construction to extend

327
00:16:42,259 --> 00:16:45,959
AES for longer messages the CBC modes

328
00:16:45,959 --> 00:16:48,959
works by basically when you're

329
00:16:48,959 --> 00:16:50,759
encrypting something you break it up in

330
00:16:50,759 --> 00:16:52,980
blocks of 16 bytes and when you encrypt

331
00:16:52,980 --> 00:16:56,220
one block you first X or the previous

332
00:16:56,220 --> 00:16:58,199
ciphertext block with your plain text

333
00:16:58,199 --> 00:17:01,980
and then you do the AAS encryption step

334
00:17:01,980 --> 00:17:02,699
um

335
00:17:02,699 --> 00:17:04,679
and this way this allows you to

336
00:17:04,679 --> 00:17:07,319
basically keep using this uh 16 bytes

337
00:17:07,319 --> 00:17:10,859
operation for much longer ciphertext of

338
00:17:10,859 --> 00:17:13,079
course the very first block doesn't have

339
00:17:13,079 --> 00:17:15,059
a preceding ciphertext block so there it

340
00:17:15,059 --> 00:17:16,740
extorts it with a parameter called the

341
00:17:16,740 --> 00:17:19,439
initialization Factor

342
00:17:19,439 --> 00:17:22,500
um which is a um uh a parameter that's

343
00:17:22,500 --> 00:17:24,000
supposed to be unique for every message

344
00:17:24,000 --> 00:17:26,640
but does not have to be kept secrets

345
00:17:26,640 --> 00:17:29,340
uh except that's the way that they use

346
00:17:29,340 --> 00:17:30,900
it in the case of web sphere is they

347
00:17:30,900 --> 00:17:32,280
actually use their key as an

348
00:17:32,280 --> 00:17:34,320
initialization factor and if you read

349
00:17:34,320 --> 00:17:35,820
any instructions on how you're supposed

350
00:17:35,820 --> 00:17:38,760
to use aescbc it doesn't tell you to do

351
00:17:38,760 --> 00:17:41,940
this this is actually a um a violation

352
00:17:41,940 --> 00:17:43,679
of

353
00:17:43,679 --> 00:17:45,480
um how you're supposed to use this

354
00:17:45,480 --> 00:17:46,799
Cipher

355
00:17:46,799 --> 00:17:49,919
and there's a few other uh problems so

356
00:17:49,919 --> 00:17:52,020
this is actually a very very common

357
00:17:52,020 --> 00:17:54,900
issue whenever you want people assume

358
00:17:54,900 --> 00:17:57,000
cryptography automatically implies some

359
00:17:57,000 --> 00:17:59,580
kind of temper protection which is not

360
00:17:59,580 --> 00:18:02,280
necessarily the case and ascbc is

361
00:18:02,280 --> 00:18:05,400
actually if used correctly it's very

362
00:18:05,400 --> 00:18:08,220
good at protecting against passive

363
00:18:08,220 --> 00:18:10,740
listeners or even so-called chosen plain

364
00:18:10,740 --> 00:18:12,419
text attack where I can decide part of

365
00:18:12,419 --> 00:18:14,280
the plain text and not the other part

366
00:18:14,280 --> 00:18:15,780
and then I look at the encrypted part it

367
00:18:15,780 --> 00:18:16,740
still doesn't give me any information

368
00:18:16,740 --> 00:18:19,799
but what ascbc does not do is defend you

369
00:18:19,799 --> 00:18:21,660
again you against chosen ciphertext

370
00:18:21,660 --> 00:18:24,240
attacks so the moment I can submit

371
00:18:24,240 --> 00:18:26,039
something that is supposed to be

372
00:18:26,039 --> 00:18:28,140
encrypted with ascbc but I can make some

373
00:18:28,140 --> 00:18:29,580
kind of malicious modifications to it

374
00:18:29,580 --> 00:18:32,400
and I Supply it to the surfer then all

375
00:18:32,400 --> 00:18:34,919
bets are off then AES CBC does not give

376
00:18:34,919 --> 00:18:37,440
you any security guarantees anymore in

377
00:18:37,440 --> 00:18:38,460
practice

378
00:18:38,460 --> 00:18:41,100
it's still not you're still not

379
00:18:41,100 --> 00:18:42,900
completely done as an attacker but you

380
00:18:42,900 --> 00:18:45,240
can no longer rely on ascbc security

381
00:18:45,240 --> 00:18:47,160
guarantees it's basically not secure

382
00:18:47,160 --> 00:18:49,440
against Joseph ciphertext attacks

383
00:18:49,440 --> 00:18:51,299
and whenever you're using it to encrypt

384
00:18:51,299 --> 00:18:52,740
cookies that you're sending to somebody

385
00:18:52,740 --> 00:18:55,380
who you don't trust chosen ciphertext

386
00:18:55,380 --> 00:18:56,940
attacks or especially what you should be

387
00:18:56,940 --> 00:18:58,679
guarding it without so that's a major

388
00:18:58,679 --> 00:19:00,480
design flaw

389
00:19:00,480 --> 00:19:03,480
the other requirement for using aescbc

390
00:19:03,480 --> 00:19:05,520
securely is that every message should

391
00:19:05,520 --> 00:19:07,440
use a different unique IV you should

392
00:19:07,440 --> 00:19:09,179
never repeat the same if two different

393
00:19:09,179 --> 00:19:11,160
messages well when you use the

394
00:19:11,160 --> 00:19:12,600
encryption key as an IV it will never

395
00:19:12,600 --> 00:19:14,720
change so this requirement is violated

396
00:19:14,720 --> 00:19:16,799
uh once again

397
00:19:16,799 --> 00:19:19,380
these security properties of ascbc don't

398
00:19:19,380 --> 00:19:22,260
hold anymore and finally I an IV should

399
00:19:22,260 --> 00:19:24,000
not be an encryption key that's simply

400
00:19:24,000 --> 00:19:26,460
uh and if it should be a random unique

401
00:19:26,460 --> 00:19:28,980
value it should not be your key and that

402
00:19:28,980 --> 00:19:30,120
actually has a lot of practical

403
00:19:30,120 --> 00:19:31,679
implications

404
00:19:31,679 --> 00:19:34,080
so normally especially uh with whenever

405
00:19:34,080 --> 00:19:36,240
with points one when you can do a chosen

406
00:19:36,240 --> 00:19:37,559
ciphertext attack there's a really

407
00:19:37,559 --> 00:19:40,440
classical attack against CBC it's a

408
00:19:40,440 --> 00:19:42,000
decryption attack that reveals to you

409
00:19:42,000 --> 00:19:45,059
the original plain text uh called uh for

410
00:19:45,059 --> 00:19:46,880
the next betting Oracle attack

411
00:19:46,880 --> 00:19:49,860
and I'm not going to go into the details

412
00:19:49,860 --> 00:19:52,200
of it but it basically boils down to

413
00:19:52,200 --> 00:19:54,179
using a decryption errors to get

414
00:19:54,179 --> 00:19:56,460
information about plain text so you mess

415
00:19:56,460 --> 00:19:59,640
with your ciphertext and depending on

416
00:19:59,640 --> 00:20:03,120
how you mess with it it can break

417
00:20:03,120 --> 00:20:06,720
um uh virtual syntax error basically in

418
00:20:06,720 --> 00:20:08,220
your plain text in the way how your

419
00:20:08,220 --> 00:20:11,400
plain text is padded and by looking at

420
00:20:11,400 --> 00:20:13,440
when you get this syntax error and even

421
00:20:13,440 --> 00:20:14,940
when you don't get the syntax error you

422
00:20:14,940 --> 00:20:16,260
learn a little bit of information about

423
00:20:16,260 --> 00:20:18,240
your plain text so okay if I get an

424
00:20:18,240 --> 00:20:19,919
error this bit plus B1 if I don't get an

425
00:20:19,919 --> 00:20:22,320
error this bit bus media zero and then

426
00:20:22,320 --> 00:20:23,820
basically by sending a whole bunch of

427
00:20:23,820 --> 00:20:25,380
requests submitting a whole bunch of

428
00:20:25,380 --> 00:20:26,940
ciphertext you can eventually decrypt

429
00:20:26,940 --> 00:20:28,080
the whole thing

430
00:20:28,080 --> 00:20:30,480
unfortunately this doesn't really I mean

431
00:20:30,480 --> 00:20:32,100
this would work in theory and you can

432
00:20:32,100 --> 00:20:33,780
probably make an elaborate timing attack

433
00:20:33,780 --> 00:20:36,299
out of this but it's not very practical

434
00:20:36,299 --> 00:20:37,860
to do this against web sphere because

435
00:20:37,860 --> 00:20:39,539
when there's anything wrong with your

436
00:20:39,539 --> 00:20:42,240
whole token web sphere will just say

437
00:20:42,240 --> 00:20:44,580
your token is in favorites but it

438
00:20:44,580 --> 00:20:46,380
doesn't say why it's inference it could

439
00:20:46,380 --> 00:20:49,200
be because the padding was incorrect it

440
00:20:49,200 --> 00:20:51,360
could be because the RSA signature was

441
00:20:51,360 --> 00:20:54,299
incorrect it could be uh because of some

442
00:20:54,299 --> 00:20:56,220
kind of other parsing error happens if

443
00:20:56,220 --> 00:20:58,020
any kind of error happens doesn't matter

444
00:20:58,020 --> 00:21:00,480
what kind of error you'll just say token

445
00:21:00,480 --> 00:21:02,280
it will just say token is wrong and it

446
00:21:02,280 --> 00:21:03,900
doesn't give you any ways to distinguish

447
00:21:03,900 --> 00:21:05,820
between different types of Errors so

448
00:21:05,820 --> 00:21:09,120
this standard attack no longer works

449
00:21:09,120 --> 00:21:11,520
so yeah if the only thing the web server

450
00:21:11,520 --> 00:21:13,440
will tell you if a token is valid or if

451
00:21:13,440 --> 00:21:16,740
it's invalid that raises the question is

452
00:21:16,740 --> 00:21:18,240
there any way we can miss with this

453
00:21:18,240 --> 00:21:21,419
token without invalidating it because if

454
00:21:21,419 --> 00:21:23,160
there's only one type of token that you

455
00:21:23,160 --> 00:21:24,660
can supply there's not much available

456
00:21:24,660 --> 00:21:26,400
room for attacks here

457
00:21:26,400 --> 00:21:28,860
and it turns out

458
00:21:28,860 --> 00:21:31,620
this is where this Legacy timestamp

459
00:21:31,620 --> 00:21:34,679
comes in so normally the whole uh this

460
00:21:34,679 --> 00:21:38,039
timestamp in between two percent signs

461
00:21:38,039 --> 00:21:40,080
um it's just ignored by the web server

462
00:21:40,080 --> 00:21:42,179
if the first part is correct so this can

463
00:21:42,179 --> 00:21:43,980
just contain any old garbage it doesn't

464
00:21:43,980 --> 00:21:47,340
even have to be filed at your utf-8

465
00:21:47,340 --> 00:21:49,380
um so what you can do is if you inject

466
00:21:49,380 --> 00:21:51,360
some new blocks in the right place you

467
00:21:51,360 --> 00:21:53,640
can get a token that decrypts that has

468
00:21:53,640 --> 00:21:55,740
the same prefix the same user data the

469
00:21:55,740 --> 00:21:57,539
same signature but the part in the

470
00:21:57,539 --> 00:21:59,220
middle is all scrambled up

471
00:21:59,220 --> 00:22:01,260
and it will still be fine

472
00:22:01,260 --> 00:22:04,080
unless this scrambled up part in the

473
00:22:04,080 --> 00:22:05,700
middle happens to have a percent sign

474
00:22:05,700 --> 00:22:08,340
anywhere because how this parser works

475
00:22:08,340 --> 00:22:09,780
it splits up the whole token in percent

476
00:22:09,780 --> 00:22:12,960
time assigns and expects three parts if

477
00:22:12,960 --> 00:22:14,280
it's more than three parts it will give

478
00:22:14,280 --> 00:22:16,559
an error so the moments that the random

479
00:22:16,559 --> 00:22:18,179
garbage in the middle

480
00:22:18,179 --> 00:22:20,760
happens to contain a percent sign the

481
00:22:20,760 --> 00:22:23,039
token will be in valid

482
00:22:23,039 --> 00:22:25,440
but here we can use this little bit of

483
00:22:25,440 --> 00:22:27,960
information to basically have the server

484
00:22:27,960 --> 00:22:30,780
tell us does this blob of encrypted data

485
00:22:30,780 --> 00:22:32,580
when you decrypt it contain a percent

486
00:22:32,580 --> 00:22:33,720
sign

487
00:22:33,720 --> 00:22:36,659
and whether it does or not well depends

488
00:22:36,659 --> 00:22:38,280
on what the original block of encrypted

489
00:22:38,280 --> 00:22:39,559
data was

490
00:22:39,559 --> 00:22:42,059
and the interesting thing is because of

491
00:22:42,059 --> 00:22:43,799
the way how CBC works you can partially

492
00:22:43,799 --> 00:22:46,799
control the decision attacker so when

493
00:22:46,799 --> 00:22:49,380
you have these garbage blobs and you uh

494
00:22:49,380 --> 00:22:51,480
flip bits in a certain place this can

495
00:22:51,480 --> 00:22:53,400
cause a percent sign to appear somewhere

496
00:22:53,400 --> 00:22:55,799
or not appear somewhere and it gives you

497
00:22:55,799 --> 00:22:57,480
a little bit of information about a

498
00:22:57,480 --> 00:22:59,100
piece of plain text the piece that was

499
00:22:59,100 --> 00:23:02,059
supposed to be a secret

500
00:23:02,059 --> 00:23:03,600
so

501
00:23:03,600 --> 00:23:05,760
eventually this could be turned into an

502
00:23:05,760 --> 00:23:08,340
elaborate kind of attack I won't go into

503
00:23:08,340 --> 00:23:10,380
details through all the steps if you are

504
00:23:10,380 --> 00:23:13,380
interested you can uh talk to me later

505
00:23:13,380 --> 00:23:15,780
but basically we use this little bit of

506
00:23:15,780 --> 00:23:17,820
information this kind of

507
00:23:17,820 --> 00:23:20,760
um uh whether there's a percent sign in

508
00:23:20,760 --> 00:23:23,460
an encrypted block or not to uh cleverly

509
00:23:23,460 --> 00:23:27,419
swap blocks around uh change bits bits

510
00:23:27,419 --> 00:23:30,059
by bits and eventually we will be able

511
00:23:30,059 --> 00:23:32,640
to decrypt one single block by just

512
00:23:32,640 --> 00:23:34,320
looking at the error messages when it's

513
00:23:34,320 --> 00:23:36,059
token valid when is the token invalid

514
00:23:36,059 --> 00:23:39,179
eventually bits by bits you can decrypt

515
00:23:39,179 --> 00:23:40,440
the original block

516
00:23:40,440 --> 00:23:43,320
and this original block Well normally it

517
00:23:43,320 --> 00:23:45,600
would be the plain text xsort with your

518
00:23:45,600 --> 00:23:48,419
IV but because here they're they're

519
00:23:48,419 --> 00:23:50,460
using the encryption key as an IV it

520
00:23:50,460 --> 00:23:52,200
will be the plain text xsort with the

521
00:23:52,200 --> 00:23:54,539
encryption key and well the nice thing

522
00:23:54,539 --> 00:23:56,700
about Exodus if we know one part we can

523
00:23:56,700 --> 00:23:59,360
guess the other parts

524
00:23:59,400 --> 00:24:00,900
um and the plain text is pretty

525
00:24:00,900 --> 00:24:02,700
predictable because what's at front of

526
00:24:02,700 --> 00:24:03,960
the plaintext it's your expiration

527
00:24:03,960 --> 00:24:05,880
timestamp

528
00:24:05,880 --> 00:24:07,200
um it will always start with the text

529
00:24:07,200 --> 00:24:09,059
expire column this is completely

530
00:24:09,059 --> 00:24:12,240
predictable uh and then well

531
00:24:12,240 --> 00:24:14,700
probably when you get a token and you're

532
00:24:14,700 --> 00:24:15,960
doing this attack you can make some

533
00:24:15,960 --> 00:24:17,640
reasonable assumptions like for example

534
00:24:17,640 --> 00:24:19,440
it will expire somewhere in the next 10

535
00:24:19,440 --> 00:24:21,419
days probably you can make a much

536
00:24:21,419 --> 00:24:22,799
broader assumption but this is already

537
00:24:22,799 --> 00:24:24,539
enough so you can guess the first few

538
00:24:24,539 --> 00:24:26,760
digits of the timestamp depending on

539
00:24:26,760 --> 00:24:28,320
what time it is at that time it's

540
00:24:28,320 --> 00:24:30,840
extended posix timestamp by the way and

541
00:24:30,840 --> 00:24:32,100
then you just have like a few hundred

542
00:24:32,100 --> 00:24:34,380
thousand options you can just brute

543
00:24:34,380 --> 00:24:35,940
force and you can do this brute forcing

544
00:24:35,940 --> 00:24:37,980
offline because you can basically keep

545
00:24:37,980 --> 00:24:41,760
trying an option and see if this um uh

546
00:24:41,760 --> 00:24:43,440
if this results in a valid AES

547
00:24:43,440 --> 00:24:44,760
decryption key that allows you to

548
00:24:44,760 --> 00:24:46,799
decrypt the whole thing so you could

549
00:24:46,799 --> 00:24:49,080
just go to these three thousand options

550
00:24:49,080 --> 00:24:51,900
the whole attack from both the active

551
00:24:51,900 --> 00:24:53,760
part of sending the different tokens and

552
00:24:53,760 --> 00:24:55,020
this brute forcing it takes a few

553
00:24:55,020 --> 00:24:56,880
seconds in practice maybe a bit longer

554
00:24:56,880 --> 00:24:58,620
if your web server is slow or the

555
00:24:58,620 --> 00:25:00,059
network connection is not but this is

556
00:25:00,059 --> 00:25:02,880
very easy to accomplish just to run a

557
00:25:02,880 --> 00:25:04,440
script against the web server and the

558
00:25:04,440 --> 00:25:06,780
encryption key comes falling out

559
00:25:06,780 --> 00:25:09,720
so now we have stolen the encryption key

560
00:25:09,720 --> 00:25:11,700
and what is this encryption key doing it

561
00:25:11,700 --> 00:25:14,400
is encrypting somebody's username and

562
00:25:14,400 --> 00:25:16,799
their tokens expiration timestamp

563
00:25:16,799 --> 00:25:18,720
that is not very exciting though because

564
00:25:18,720 --> 00:25:20,220
basically what we could do up to this

565
00:25:20,220 --> 00:25:22,260
point is we can we need to get a fellow

566
00:25:22,260 --> 00:25:24,419
token ourselves so we need to log in and

567
00:25:24,419 --> 00:25:26,100
then we can figure out what our own

568
00:25:26,100 --> 00:25:28,020
username is I guess I mean if you would

569
00:25:28,020 --> 00:25:29,520
somehow get somebody else talking you

570
00:25:29,520 --> 00:25:31,200
can look for the username is or the user

571
00:25:31,200 --> 00:25:33,539
identifier not very exciting so far

572
00:25:33,539 --> 00:25:35,760
because we still have this whole RSA

573
00:25:35,760 --> 00:25:37,440
signature that's supposed to actually

574
00:25:37,440 --> 00:25:39,720
give The Temper protection this is just

575
00:25:39,720 --> 00:25:41,400
some confidentiality layer that actually

576
00:25:41,400 --> 00:25:44,460
doesn't really accomplish much so yeah

577
00:25:44,460 --> 00:25:46,740
fun attack but it appears to have very

578
00:25:46,740 --> 00:25:49,140
low impacts because sure you can

579
00:25:49,140 --> 00:25:51,840
subverts encryption but if this

580
00:25:51,840 --> 00:25:53,100
encryption isn't really doing anything

581
00:25:53,100 --> 00:25:56,279
useful you you're still

582
00:25:56,279 --> 00:25:57,779
um you haven't really achieved much as

583
00:25:57,779 --> 00:25:59,460
an attacker

584
00:25:59,460 --> 00:26:00,840
but

585
00:26:00,840 --> 00:26:03,120
here's the problem because these tokens

586
00:26:03,120 --> 00:26:07,200
are always both signed and encrypted

587
00:26:07,200 --> 00:26:09,659
um usually these two layers are not

588
00:26:09,659 --> 00:26:11,940
really tested in isolation

589
00:26:11,940 --> 00:26:14,220
so whenever a pen tester would look at

590
00:26:14,220 --> 00:26:15,480
an application like this the scene

591
00:26:15,480 --> 00:26:17,039
encrypted blow up in the token maybe

592
00:26:17,039 --> 00:26:19,559
Shuffle some bits around fails to

593
00:26:19,559 --> 00:26:21,840
decrypt token doesn't work it looks like

594
00:26:21,840 --> 00:26:24,360
the application is secure

595
00:26:24,360 --> 00:26:26,100
um if you look at test cases that you

596
00:26:26,100 --> 00:26:28,200
used in Webster Liberty themselves they

597
00:26:28,200 --> 00:26:31,100
create a whole token signing encrypting

598
00:26:31,100 --> 00:26:33,419
and because the encryption layer is in

599
00:26:33,419 --> 00:26:34,799
the way any changes you make will

600
00:26:34,799 --> 00:26:36,120
probably break the encryption layer

601
00:26:36,120 --> 00:26:37,980
unless you you do low conclude the trick

602
00:26:37,980 --> 00:26:40,200
that I did so it looks like oh well

603
00:26:40,200 --> 00:26:42,480
tokens are tamper proof if I mess with

604
00:26:42,480 --> 00:26:45,539
my token it will not be valid but all

605
00:26:45,539 --> 00:26:46,440
these

606
00:26:46,440 --> 00:26:48,840
um but when you typically temper a token

607
00:26:48,840 --> 00:26:50,700
you just trigger decryption apps you

608
00:26:50,700 --> 00:26:52,520
don't actually reach the signature yet

609
00:26:52,520 --> 00:26:56,159
so this whole signature verification

610
00:26:56,159 --> 00:26:58,260
Parts in the case of Webster Liberty

611
00:26:58,260 --> 00:27:00,179
does that appear to have been tested

612
00:27:00,179 --> 00:27:01,140
very well

613
00:27:01,140 --> 00:27:03,120
and it turns out well they have a nice

614
00:27:03,120 --> 00:27:05,279
validation function here

615
00:27:05,279 --> 00:27:07,679
and when your signature is not valid it

616
00:27:07,679 --> 00:27:09,779
will return false otherwise it returns

617
00:27:09,779 --> 00:27:12,120
true and it can also throw an exception

618
00:27:12,120 --> 00:27:13,740
when the syntax is wrong when there's

619
00:27:13,740 --> 00:27:15,299
when your signature is not long enough

620
00:27:15,299 --> 00:27:17,039
or when it's not base64 encoded or

621
00:27:17,039 --> 00:27:19,200
something like that

622
00:27:19,200 --> 00:27:21,299
and then when you see how this function

623
00:27:21,299 --> 00:27:24,000
is actually used it is called but it

624
00:27:24,000 --> 00:27:26,340
does the function calling it does not

625
00:27:26,340 --> 00:27:28,260
actually look at its return value

626
00:27:28,260 --> 00:27:31,080
because in most cases whenever you mess

627
00:27:31,080 --> 00:27:33,120
with the token it throws an exception

628
00:27:33,120 --> 00:27:34,620
and you don't need to care about your

629
00:27:34,620 --> 00:27:36,539
return value it's a bit Yeah ambiguous

630
00:27:36,539 --> 00:27:37,740
what am I supposed to do with this

631
00:27:37,740 --> 00:27:40,440
methods and I suppose uh it can throw an

632
00:27:40,440 --> 00:27:41,940
exception that the token is inflict or

633
00:27:41,940 --> 00:27:43,860
it can return a Boolean that indicates

634
00:27:43,860 --> 00:27:45,539
the token is invalid it's a bit

635
00:27:45,539 --> 00:27:48,179
ambiguous and clearly well developers

636
00:27:48,179 --> 00:27:49,980
got confused they just relied on the

637
00:27:49,980 --> 00:27:51,600
exception and because of the whole

638
00:27:51,600 --> 00:27:52,919
encryption layer getting in the way this

639
00:27:52,919 --> 00:27:56,279
was never properly tested so if you can

640
00:27:56,279 --> 00:27:58,020
make this function return false instead

641
00:27:58,020 --> 00:28:00,000
of throwing an exception you can

642
00:28:00,000 --> 00:28:02,400
basically bypass an invalid signature

643
00:28:02,400 --> 00:28:05,580
and it turns out that this happens

644
00:28:05,580 --> 00:28:07,620
whenever your signature syntax is

645
00:28:07,620 --> 00:28:08,940
correct and whenever the encryption

646
00:28:08,940 --> 00:28:10,380
layer is correct

647
00:28:10,380 --> 00:28:12,659
so we can now put this all together to

648
00:28:12,659 --> 00:28:14,520
create an attack so first of all you

649
00:28:14,520 --> 00:28:16,860
just log in as some user this

650
00:28:16,860 --> 00:28:18,659
unfortunately it's not what's not

651
00:28:18,659 --> 00:28:19,799
possible to turn this into an

652
00:28:19,799 --> 00:28:21,480
unauthenticated variant so you do need

653
00:28:21,480 --> 00:28:23,820
to have some accounts so you need it's

654
00:28:23,820 --> 00:28:25,500
some you have to attack a multi-user

655
00:28:25,500 --> 00:28:28,320
system and you get your own ltpa token

656
00:28:28,320 --> 00:28:30,360
with your own name in it then you go

657
00:28:30,360 --> 00:28:32,279
through the whole key stealing attack by

658
00:28:32,279 --> 00:28:33,659
sending all these variations of the

659
00:28:33,659 --> 00:28:36,360
token after a few thousand requests you

660
00:28:36,360 --> 00:28:38,700
can figure out the encryption key so

661
00:28:38,700 --> 00:28:40,260
then you have your own token again you

662
00:28:40,260 --> 00:28:41,820
can decrypt it you see your own original

663
00:28:41,820 --> 00:28:44,820
token and then you can just mess with

664
00:28:44,820 --> 00:28:47,340
the property so you set a username to

665
00:28:47,340 --> 00:28:49,440
admin you can even make the timestamp

666
00:28:49,440 --> 00:28:51,480
valid until like hundreds of years in

667
00:28:51,480 --> 00:28:54,360
the future why not uh while we're edits

668
00:28:54,360 --> 00:28:56,460
and the signature you just

669
00:28:56,460 --> 00:28:58,260
leave it in place you don't do anything

670
00:28:58,260 --> 00:29:00,179
specific with the signature you just

671
00:29:00,179 --> 00:29:01,799
re-encrypt the whole thing and send it

672
00:29:01,799 --> 00:29:04,260
to the server now what happens server

673
00:29:04,260 --> 00:29:06,600
decrypts a token is valid succeeds no

674
00:29:06,600 --> 00:29:08,520
problem it looks like the signature

675
00:29:08,520 --> 00:29:11,100
signature is invalid method returns

676
00:29:11,100 --> 00:29:13,140
false but because those syntax is

677
00:29:13,140 --> 00:29:14,460
correct this false return value is

678
00:29:14,460 --> 00:29:15,900
ignored and the surf will just continue

679
00:29:15,900 --> 00:29:18,539
as if your token is completely valid

680
00:29:18,539 --> 00:29:19,919
so

681
00:29:19,919 --> 00:29:23,100
now the web server thinks you are the

682
00:29:23,100 --> 00:29:25,260
user you just impersonate it

683
00:29:25,260 --> 00:29:29,580
and this worked against web sphere

684
00:29:29,580 --> 00:29:32,399
Liberty and open Liberty uh before uh

685
00:29:32,399 --> 00:29:36,200
well I disclose this and it was patched

686
00:29:36,200 --> 00:29:40,860
and well the implication is you have a

687
00:29:40,860 --> 00:29:43,279
complete identity spoofing attack

688
00:29:43,279 --> 00:29:46,620
and there are definitely use cases where

689
00:29:46,620 --> 00:29:49,039
this authentication mechanism is used

690
00:29:49,039 --> 00:29:52,679
for multi-user systems even people

691
00:29:52,679 --> 00:29:54,419
logging in from the internet with

692
00:29:54,419 --> 00:29:57,360
different accounts and even where the

693
00:29:57,360 --> 00:29:59,580
user base is very large let's say the

694
00:29:59,580 --> 00:30:02,100
entire Dutch population for example

695
00:30:02,100 --> 00:30:03,659
um and where it would definitely be a

696
00:30:03,659 --> 00:30:06,419
problem if one user could impersonates

697
00:30:06,419 --> 00:30:08,880
um another user there's also the

698
00:30:08,880 --> 00:30:10,860
traditional web sphere like the older

699
00:30:10,860 --> 00:30:14,279
version uh that one technically is also

700
00:30:14,279 --> 00:30:15,600
vulnerable for the key stealing attack

701
00:30:15,600 --> 00:30:17,100
because the o'kee stealing attack is

702
00:30:17,100 --> 00:30:18,840
like a fundamental protocol crypto issue

703
00:30:18,840 --> 00:30:20,220
if you implement this you're basically

704
00:30:20,220 --> 00:30:21,720
vulnerable although you can do some

705
00:30:21,720 --> 00:30:23,580
things to make the attack really hard

706
00:30:23,580 --> 00:30:27,419
to execute uh but they are I didn't have

707
00:30:27,419 --> 00:30:29,880
the signature validation flaw so

708
00:30:29,880 --> 00:30:33,720
um uh the old Bachelor Liberty shouldn't

709
00:30:33,720 --> 00:30:35,460
be vulnerable to this

710
00:30:35,460 --> 00:30:37,200
although I must say I haven't researched

711
00:30:37,200 --> 00:30:39,360
that one in detail because it's not open

712
00:30:39,360 --> 00:30:41,159
source it's a lot more difficult to get

713
00:30:41,159 --> 00:30:42,480
working because it's the expensive

714
00:30:42,480 --> 00:30:44,580
commercial products so I can't guarantee

715
00:30:44,580 --> 00:30:46,260
that there is there's not other issues

716
00:30:46,260 --> 00:30:48,899
here uh when it comes to regular Webster

717
00:30:48,899 --> 00:30:50,940
Liberty and open Liberty um well you

718
00:30:50,940 --> 00:30:52,620
should really patch it the whole key

719
00:30:52,620 --> 00:30:55,440
recovery flaw basically I recommended a

720
00:30:55,440 --> 00:30:56,820
bunch of fixers that would make it

721
00:30:56,820 --> 00:30:59,039
really hard to execute is basically like

722
00:30:59,039 --> 00:31:02,640
check the timestamp in the middle I I

723
00:31:02,640 --> 00:31:04,140
can't say that this makes it completely

724
00:31:04,140 --> 00:31:06,179
unexploitable you may be able to do time

725
00:31:06,179 --> 00:31:08,100
timing into extra other clever attacks

726
00:31:08,100 --> 00:31:10,440
but it's very impractical now and even

727
00:31:10,440 --> 00:31:11,880
if you could do it you only have this

728
00:31:11,880 --> 00:31:14,760
encryption key but now they did a very

729
00:31:14,760 --> 00:31:17,279
simple fix to just actually check the

730
00:31:17,279 --> 00:31:18,539
signature and actually use the return

731
00:31:18,539 --> 00:31:20,340
value I think they even just threw the

732
00:31:20,340 --> 00:31:21,720
return value away and all this where

733
00:31:21,720 --> 00:31:22,980
it's just made a function throw an

734
00:31:22,980 --> 00:31:24,779
exception

735
00:31:24,779 --> 00:31:28,320
um so uh this attack will no longer work

736
00:31:28,320 --> 00:31:31,500
um against these types of surfers

737
00:31:31,500 --> 00:31:34,440
um also even if you use an outdated

738
00:31:34,440 --> 00:31:37,200
Webster Liberty Surfers these whole ltpa

739
00:31:37,200 --> 00:31:38,760
authentication mechanism is not always

740
00:31:38,760 --> 00:31:40,799
used by default

741
00:31:40,799 --> 00:31:42,480
um you can choose to use different

742
00:31:42,480 --> 00:31:44,880
authentication mechanism based on more

743
00:31:44,880 --> 00:31:46,679
traditional stateful session identifiers

744
00:31:46,679 --> 00:31:49,200
I would actually recommend that also

745
00:31:49,200 --> 00:31:50,580
because of all the other problems with

746
00:31:50,580 --> 00:31:54,960
encrypted session data you can use jwts

747
00:31:54,960 --> 00:31:58,620
uh or just choose to pick something else

748
00:31:58,620 --> 00:32:01,260
this is an option I see it used a lot in

749
00:32:01,260 --> 00:32:02,880
practice especially for like large

750
00:32:02,880 --> 00:32:05,880
applications but it's definitely not the

751
00:32:05,880 --> 00:32:10,039
most popular session management solution

752
00:32:10,980 --> 00:32:14,220
so a few takeaways from this research

753
00:32:14,220 --> 00:32:16,740
what can we learn from this well first

754
00:32:16,740 --> 00:32:21,360
of all don't use unauthenticated AES in

755
00:32:21,360 --> 00:32:23,640
CBC mode or actually don't use CBC at

756
00:32:23,640 --> 00:32:27,059
all it is in my experience incredibly

757
00:32:27,059 --> 00:32:28,559
calm this is probably one of the most

758
00:32:28,559 --> 00:32:30,000
common crypto box you see in

759
00:32:30,000 --> 00:32:32,640
applications somebody wants to send

760
00:32:32,640 --> 00:32:33,960
something to the clients doesn't want

761
00:32:33,960 --> 00:32:35,760
the client to mess with it's well you

762
00:32:35,760 --> 00:32:37,140
look up okay what's the most popular

763
00:32:37,140 --> 00:32:40,080
encryption methods it's ascbc which

764
00:32:40,080 --> 00:32:42,140
doesn't come with a clear warning that

765
00:32:42,140 --> 00:32:44,220
ascbc is actually not secure against

766
00:32:44,220 --> 00:32:46,500
chosen ciphertext attacks which is

767
00:32:46,500 --> 00:32:47,720
especially

768
00:32:47,720 --> 00:32:50,159
uh exactly what you should be worrying

769
00:32:50,159 --> 00:32:51,539
about

770
00:32:51,539 --> 00:32:52,799
um of course a lot of people will be

771
00:32:52,799 --> 00:32:54,539
saying don't roll your own crypto don't

772
00:32:54,539 --> 00:32:57,299
use crypto but that's a bit simplistic

773
00:32:57,299 --> 00:32:59,820
there are very legitimate use cases to

774
00:32:59,820 --> 00:33:01,860
apply your own cryptography and a lot of

775
00:33:01,860 --> 00:33:03,659
people don't even think they're using

776
00:33:03,659 --> 00:33:05,100
their own crypto because they're using

777
00:33:05,100 --> 00:33:07,740
AES one of the most established ciphers

778
00:33:07,740 --> 00:33:10,620
out there AES has got to be secure right

779
00:33:10,620 --> 00:33:12,899
and yes AES is very good at what it's

780
00:33:12,899 --> 00:33:15,539
supposed to do but it's also a very low

781
00:33:15,539 --> 00:33:17,399
level mechanism so actually using it

782
00:33:17,399 --> 00:33:19,860
correctly can be very tricky and this is

783
00:33:19,860 --> 00:33:21,179
not helped by the fact that a lot of

784
00:33:21,179 --> 00:33:22,919
standard libraries like the Java

785
00:33:22,919 --> 00:33:25,220
standard library.net standard Library

786
00:33:25,220 --> 00:33:27,299
they give you super low level

787
00:33:27,299 --> 00:33:28,919
cryptographic tools instead of just

788
00:33:28,919 --> 00:33:30,360
giving you a function that does

789
00:33:30,360 --> 00:33:31,919
everything correctly so where you plug

790
00:33:31,919 --> 00:33:34,279
in a key and it will just

791
00:33:34,279 --> 00:33:36,600
use authenticated encryption that's

792
00:33:36,600 --> 00:33:39,240
protected against uh tampering against

793
00:33:39,240 --> 00:33:41,820
disclosure doesn't require you to keep

794
00:33:41,820 --> 00:33:44,340
non-sus or IVs just handles it all for

795
00:33:44,340 --> 00:33:46,080
you there are libraries that do this but

796
00:33:46,080 --> 00:33:47,580
these are usually not the standard

797
00:33:47,580 --> 00:33:48,500
Library

798
00:33:48,500 --> 00:33:50,760
so it is very common that people get

799
00:33:50,760 --> 00:33:51,899
this wrong they want to use a stand

800
00:33:51,899 --> 00:33:54,120
Library do encryption use something very

801
00:33:54,120 --> 00:33:55,440
well known something very well

802
00:33:55,440 --> 00:33:57,539
established but that just happens to

803
00:33:57,539 --> 00:33:58,740
have different properties than you

804
00:33:58,740 --> 00:34:00,179
actually expect

805
00:34:00,179 --> 00:34:03,299
also crypto bugs are not just about

806
00:34:03,299 --> 00:34:05,159
information disclosure it's not just

807
00:34:05,159 --> 00:34:06,899
about somebody being

808
00:34:06,899 --> 00:34:09,300
um having an uh a malicious Wi-Fi

809
00:34:09,300 --> 00:34:11,820
hotspot and reading your WhatsApp

810
00:34:11,820 --> 00:34:14,760
messages a lot of authentication logic

811
00:34:14,760 --> 00:34:16,918
is also used as cryptography and I would

812
00:34:16,918 --> 00:34:18,780
say there's often a lot more critical

813
00:34:18,780 --> 00:34:21,480
and importance often when people think

814
00:34:21,480 --> 00:34:22,739
about cryptography they think about

815
00:34:22,739 --> 00:34:25,440
keeping stuff Secrets but

816
00:34:25,440 --> 00:34:27,960
um this well encrypted session tokens

817
00:34:27,960 --> 00:34:29,699
are everywhere and these are critical

818
00:34:29,699 --> 00:34:32,879
authentic education mechanisms

819
00:34:32,879 --> 00:34:35,940
for identity Federation like

820
00:34:35,940 --> 00:34:37,918
um cryptography is used all the time

821
00:34:37,918 --> 00:34:40,379
even when the it's terrible cryptography

822
00:34:40,379 --> 00:34:42,060
in my opinion in the case of summer for

823
00:34:42,060 --> 00:34:43,800
example

824
00:34:43,800 --> 00:34:46,500
um for authentication uh with your

825
00:34:46,500 --> 00:34:48,899
fingerprints for example is in false

826
00:34:48,899 --> 00:34:51,320
cryptography through digital signatures

827
00:34:51,320 --> 00:34:52,918
and

828
00:34:52,918 --> 00:34:55,500
a lot some some of these systems are

829
00:34:55,500 --> 00:34:57,119
really well designed stay involved

830
00:34:57,119 --> 00:34:58,800
cryptographers they use a lot of reset

831
00:34:58,800 --> 00:35:00,960
knowledge but some of these systems have

832
00:35:00,960 --> 00:35:02,880
been around since the late 90s or early

833
00:35:02,880 --> 00:35:04,740
2000s which is kind of the case with

834
00:35:04,740 --> 00:35:07,740
ltpa or its predecessors and nobody

835
00:35:07,740 --> 00:35:10,140
really has refuted much it's basically

836
00:35:10,140 --> 00:35:11,760
it's some obscure cryptographic

837
00:35:11,760 --> 00:35:13,079
mechanism that does something very

838
00:35:13,079 --> 00:35:16,200
important but it's very clearly when you

839
00:35:16,200 --> 00:35:17,880
see these really obvious mistakes even

840
00:35:17,880 --> 00:35:20,160
if you don't we are not able to

841
00:35:20,160 --> 00:35:21,599
formulate this attack if you just follow

842
00:35:21,599 --> 00:35:23,220
the standard checklist of what you're

843
00:35:23,220 --> 00:35:25,500
not supposed to do uh and you will see

844
00:35:25,500 --> 00:35:27,599
oh they use their encryption key as an

845
00:35:27,599 --> 00:35:29,760
initialization factor in AES they should

846
00:35:29,760 --> 00:35:31,500
already raise a red flag you probably

847
00:35:31,500 --> 00:35:33,599
don't want to have this exploitable or

848
00:35:33,599 --> 00:35:34,859
not you don't want to have these obvious

849
00:35:34,859 --> 00:35:36,480
mistakes in your critical Authentication

850
00:35:36,480 --> 00:35:38,460
Protocol

851
00:35:38,460 --> 00:35:41,220
and cookie encryption is also a

852
00:35:41,220 --> 00:35:44,040
cryptographic protocol so ideally you

853
00:35:44,040 --> 00:35:46,220
should have some kind of experts

854
00:35:46,220 --> 00:35:49,820
uh take a look at it

855
00:35:49,820 --> 00:35:51,839
not just

856
00:35:51,839 --> 00:35:53,579
and that's can of course be very

857
00:35:53,579 --> 00:35:56,700
difficult especially if you uh are an

858
00:35:56,700 --> 00:35:58,440
application developer yourself you can't

859
00:35:58,440 --> 00:36:00,060
easily find a cryptographer somewhere to

860
00:36:00,060 --> 00:36:02,220
review your codes but this may be more

861
00:36:02,220 --> 00:36:04,140
feasible for a large organization such

862
00:36:04,140 --> 00:36:07,380
as IBM that is making a uh web

863
00:36:07,380 --> 00:36:09,420
application platform or web framework

864
00:36:09,420 --> 00:36:11,579
that's they are selling for a lot of

865
00:36:11,579 --> 00:36:14,099
money to a lot of users so especially

866
00:36:14,099 --> 00:36:17,040
for framework developers

867
00:36:17,040 --> 00:36:20,339
um or web server developers or just

868
00:36:20,339 --> 00:36:22,079
people that make libraries that offer

869
00:36:22,079 --> 00:36:23,280
these fundamental authentication

870
00:36:23,280 --> 00:36:25,500
mechanisms

871
00:36:25,500 --> 00:36:27,119
um people should be taking a look at it

872
00:36:27,119 --> 00:36:28,380
ideally also the code and the

873
00:36:28,380 --> 00:36:30,240
implementation but at the very least the

874
00:36:30,240 --> 00:36:32,940
protocol design have an expert take a

875
00:36:32,940 --> 00:36:35,339
look at it and say like are you using

876
00:36:35,339 --> 00:36:37,920
these protocols correctly

877
00:36:37,920 --> 00:36:40,920
and this does not apply just to Legacy

878
00:36:40,920 --> 00:36:43,859
protocols like ltpa

879
00:36:43,859 --> 00:36:47,460
um I won't go into like right now a more

880
00:36:47,460 --> 00:36:50,160
modern equivalent for LCPA or Json web

881
00:36:50,160 --> 00:36:54,660
tokens jwts uh to be fair these are

882
00:36:54,660 --> 00:36:57,000
designed a lot better than these ltpa

883
00:36:57,000 --> 00:36:58,079
tokens

884
00:36:58,079 --> 00:37:00,420
but they also still have a lot of

885
00:37:00,420 --> 00:37:01,740
cryptographic issues that a lot of

886
00:37:01,740 --> 00:37:03,599
cryptographers are complaining about all

887
00:37:03,599 --> 00:37:07,020
the time and even despite all that it

888
00:37:07,020 --> 00:37:09,720
became one of the most popular uh

889
00:37:09,720 --> 00:37:13,200
um encrypted token standards despite all

890
00:37:13,200 --> 00:37:15,359
these potential design flaws and even if

891
00:37:15,359 --> 00:37:18,180
these flaws don't really result into a

892
00:37:18,180 --> 00:37:21,680
direct clear vulnerability

893
00:37:21,720 --> 00:37:23,940
um it does yeah maybe ask you to

894
00:37:23,940 --> 00:37:26,099
reconsider should we really rely on this

895
00:37:26,099 --> 00:37:27,420
for essential authentication

896
00:37:27,420 --> 00:37:29,700
functionality should we maybe not have a

897
00:37:29,700 --> 00:37:30,839
little bit higher standard of review

898
00:37:30,839 --> 00:37:33,200
because when we have something like TLS

899
00:37:33,200 --> 00:37:35,640
uh when it comes to transport encryption

900
00:37:35,640 --> 00:37:37,619
everyone is on to it everybody is

901
00:37:37,619 --> 00:37:39,480
researching it many papers come out so

902
00:37:39,480 --> 00:37:41,660
much vulnerabilities in TLS

903
00:37:41,660 --> 00:37:43,680
but when

904
00:37:43,680 --> 00:37:45,900
uh when we have something like an

905
00:37:45,900 --> 00:37:48,660
essential uh well authentication token

906
00:37:48,660 --> 00:37:51,119
basically it doesn't nearly get as much

907
00:37:51,119 --> 00:37:52,500
analysis or at least the analysis

908
00:37:52,500 --> 00:37:55,140
doesn't nearly get as much attention so

909
00:37:55,140 --> 00:37:56,700
while it's maybe a lot more exciting

910
00:37:56,700 --> 00:37:58,680
sometimes to take a look at about

911
00:37:58,680 --> 00:38:01,380
popular messaging apps uh maybe we

912
00:38:01,380 --> 00:38:02,400
should also spend a little bit more

913
00:38:02,400 --> 00:38:03,780
effort to looking at all these other

914
00:38:03,780 --> 00:38:06,119
crypto components that fulfill some

915
00:38:06,119 --> 00:38:07,920
essential function

916
00:38:07,920 --> 00:38:13,200
so yeah that was my talk yeah yeah so

917
00:38:15,240 --> 00:38:16,560
um I think we still have like 10 minutes

918
00:38:16,560 --> 00:38:20,880
for questions right so if there's anyone

919
00:38:20,880 --> 00:38:22,980
there's a question

920
00:38:22,980 --> 00:38:25,079
yes

921
00:38:25,079 --> 00:38:28,940
do you have microphone or

922
00:38:42,180 --> 00:38:45,000
so uh would be interesting for me to

923
00:38:45,000 --> 00:38:48,240
know the rough timeline from starting to

924
00:38:48,240 --> 00:38:51,540
research the the product to finding the

925
00:38:51,540 --> 00:38:55,740
bug and fix and communication with the

926
00:38:55,740 --> 00:38:58,980
vendor like how much time was

927
00:38:58,980 --> 00:39:01,740
you used for that

928
00:39:01,740 --> 00:39:04,680
um so the whole research

929
00:39:04,680 --> 00:39:07,619
um I didn't really did this in uh one go

930
00:39:07,619 --> 00:39:09,960
I kind of started with a lot of these

931
00:39:09,960 --> 00:39:11,940
projects but just casually looking

932
00:39:11,940 --> 00:39:14,040
around at source codes and sometimes

933
00:39:14,040 --> 00:39:15,119
when there's a nice protocol

934
00:39:15,119 --> 00:39:18,000
specification with crypto uh then I

935
00:39:18,000 --> 00:39:20,460
prefer to do that but in this case

936
00:39:20,460 --> 00:39:22,260
um the actually what prompted me to look

937
00:39:22,260 --> 00:39:24,599
into this is I did a pen test I had one

938
00:39:24,599 --> 00:39:26,460
of these ltpa tokens I was curious how

939
00:39:26,460 --> 00:39:28,020
it works

940
00:39:28,020 --> 00:39:31,380
um I tried just something simple I used

941
00:39:31,380 --> 00:39:35,940
um uh burp Intruder like a typical tool

942
00:39:35,940 --> 00:39:37,560
during applique a web application pen

943
00:39:37,560 --> 00:39:39,780
test it just made it flip every single

944
00:39:39,780 --> 00:39:42,540
bit in the token one by one and what I

945
00:39:42,540 --> 00:39:43,680
saw is that when it flips a bit

946
00:39:43,680 --> 00:39:45,060
somewhere in the middle it actually did

947
00:39:45,060 --> 00:39:47,040
not invalidate the token I was like hmm

948
00:39:47,040 --> 00:39:49,140
interesting there may be something up

949
00:39:49,140 --> 00:39:51,359
with this token but yeah you have a

950
00:39:51,359 --> 00:39:53,839
short deadline uh uh

951
00:39:53,839 --> 00:39:56,280
a pen test you don't really have time to

952
00:39:56,280 --> 00:39:58,980
further investigate that and I was

953
00:39:58,980 --> 00:40:01,200
thinking yeah it's like obscure IBM

954
00:40:01,200 --> 00:40:02,820
stuff but we actually do see this thing

955
00:40:02,820 --> 00:40:04,140
a lot with assessments let's try to

956
00:40:04,140 --> 00:40:05,579
figure out how this works so you try to

957
00:40:05,579 --> 00:40:07,320
look for documentation you find some

958
00:40:07,320 --> 00:40:08,579
documentation but nothing really

959
00:40:08,579 --> 00:40:10,320
explains what the cryptography does and

960
00:40:10,320 --> 00:40:11,760
it was like oh they have a nice open

961
00:40:11,760 --> 00:40:13,500
source implementation here they're just

962
00:40:13,500 --> 00:40:14,820
the browse gate up and see how this

963
00:40:14,820 --> 00:40:16,020
works

964
00:40:16,020 --> 00:40:18,000
and then yeah you very quickly see this

965
00:40:18,000 --> 00:40:20,460
like theoretical issues like this

966
00:40:20,460 --> 00:40:22,040
problem with AES

967
00:40:22,040 --> 00:40:26,339
and initially I did not notice the very

968
00:40:26,339 --> 00:40:27,780
obvious signature flaw so I had no idea

969
00:40:27,780 --> 00:40:29,099
it could mess with the signature so at

970
00:40:29,099 --> 00:40:30,480
first I thought yeah it's a bit useless

971
00:40:30,480 --> 00:40:33,060
to attack I can maybe decrypt a token

972
00:40:33,060 --> 00:40:35,520
but not really mess with the signature

973
00:40:35,520 --> 00:40:38,099
but then I had some fake ideas about

974
00:40:38,099 --> 00:40:40,440
maybe I can uh trick the partial in some

975
00:40:40,440 --> 00:40:43,260
way by first decrypting it and doing all

976
00:40:43,260 --> 00:40:46,200
kinds of tricks to make the parser uh

977
00:40:46,200 --> 00:40:48,900
treat my token differently with that

978
00:40:48,900 --> 00:40:50,280
kind of result in that whole injection

979
00:40:50,280 --> 00:40:52,020
attack actually my original idea didn't

980
00:40:52,020 --> 00:40:54,119
turn out to work but when I was testing

981
00:40:54,119 --> 00:40:56,460
this in my lab setup by the way this

982
00:40:56,460 --> 00:40:58,560
first attack maybe took like a month to

983
00:40:58,560 --> 00:41:01,020
get this working but it did not work on

984
00:41:01,020 --> 00:41:03,000
it a lot for sure like in a bit of extra

985
00:41:03,000 --> 00:41:06,540
time and then I kind of accidentally uh

986
00:41:06,540 --> 00:41:08,579
I was trying stuff out with the token to

987
00:41:08,579 --> 00:41:10,079
test the Porsche and how it would behave

988
00:41:10,079 --> 00:41:12,119
and then I saw like hey why is my token

989
00:41:12,119 --> 00:41:14,339
accept it and then I went through the

990
00:41:14,339 --> 00:41:15,599
code and actually found out stupid

991
00:41:15,599 --> 00:41:18,240
signature lot as I completely missed so

992
00:41:18,240 --> 00:41:19,500
it's not surprising that these

993
00:41:19,500 --> 00:41:21,900
developers missed it I really uh has

994
00:41:21,900 --> 00:41:23,160
focused a lot on this code and I

995
00:41:23,160 --> 00:41:24,240
completely missed it as well it's a

996
00:41:24,240 --> 00:41:26,099
really weird part

997
00:41:26,099 --> 00:41:28,140
um but yeah I think research probably

998
00:41:28,140 --> 00:41:30,960
one or two months uh I mean if I really

999
00:41:30,960 --> 00:41:32,880
also with these kinds of things usually

1000
00:41:32,880 --> 00:41:34,859
it helps to do a little bit of research

1001
00:41:34,859 --> 00:41:36,780
think about it or go back to it later to

1002
00:41:36,780 --> 00:41:39,119
get attach some new ideas like actual

1003
00:41:39,119 --> 00:41:40,800
implementation is probably of like

1004
00:41:40,800 --> 00:41:42,780
attack scripts only a few days

1005
00:41:42,780 --> 00:41:45,900
and I think I don't remember from the

1006
00:41:45,900 --> 00:41:47,700
top of my head how long the vendor took

1007
00:41:47,700 --> 00:41:49,740
to release a patch it was not super long

1008
00:41:49,740 --> 00:41:53,700
I mean the communication with IBM was

1009
00:41:53,700 --> 00:41:56,520
could be better could be worse it's uh

1010
00:41:56,520 --> 00:41:57,540
they at first they didn't really

1011
00:41:57,540 --> 00:42:00,359
understand the issue yet if despite a

1012
00:42:00,359 --> 00:42:03,060
very long write-up they had to

1013
00:42:03,060 --> 00:42:07,200
um uh look at it again then they finally

1014
00:42:07,200 --> 00:42:09,359
came with an advisory they gave it a CVS

1015
00:42:09,359 --> 00:42:12,900
escort of 5.0 and I was like it is a

1016
00:42:12,900 --> 00:42:15,000
complete identity spoofing bug like I

1017
00:42:15,000 --> 00:42:17,040
know like some use cases where this

1018
00:42:17,040 --> 00:42:19,260
would be have a huge impacts are you

1019
00:42:19,260 --> 00:42:21,359
sure about this and then they changed

1020
00:42:21,359 --> 00:42:24,240
the CVS escort again

1021
00:42:24,240 --> 00:42:27,240
um and that's yeah that probably I mean

1022
00:42:27,240 --> 00:42:29,099
I think it took another month or maybe

1023
00:42:29,099 --> 00:42:30,900
two months for the patch to be uh

1024
00:42:30,900 --> 00:42:34,079
released I'm personally not but when it

1025
00:42:34,079 --> 00:42:36,060
comes to this crypto protocol stuff I'm

1026
00:42:36,060 --> 00:42:37,560
personally not very strict with this

1027
00:42:37,560 --> 00:42:39,420
whole 90-day disclosure deadline because

1028
00:42:39,420 --> 00:42:41,040
these things are often a pain to fix so

1029
00:42:41,040 --> 00:42:42,240
you have all these systems integrating

1030
00:42:42,240 --> 00:42:43,920
with each other and it's very

1031
00:42:43,920 --> 00:42:45,359
understandable this takes a little bit

1032
00:42:45,359 --> 00:42:46,980
longer

1033
00:42:46,980 --> 00:42:49,079
um but yeah it was a bit

1034
00:42:49,079 --> 00:42:52,500
um uh the whole process

1035
00:42:52,500 --> 00:42:54,839
which could be better but on the other

1036
00:42:54,839 --> 00:42:57,599
hand I mean it's IBM I actually was

1037
00:42:57,599 --> 00:42:59,040
afraid that it would be a lot worse so

1038
00:42:59,040 --> 00:43:01,579
it's uh

1039
00:43:03,380 --> 00:43:07,380
yeah yeah I mean it when it comes to uh

1040
00:43:07,380 --> 00:43:09,540
patch timelines uh they were a lot

1041
00:43:09,540 --> 00:43:12,060
faster than Microsoft uh can be uh

1042
00:43:12,060 --> 00:43:16,460
exactly yeah thank you yeah

1043
00:43:16,619 --> 00:43:18,420
any other questions

1044
00:43:18,420 --> 00:43:21,140
oh yeah

1045
00:43:23,700 --> 00:43:25,500
I mean I don't really think you should

1046
00:43:25,500 --> 00:43:28,319
blame developers from

1047
00:43:28,319 --> 00:43:30,300
um writing software that has bugs in it

1048
00:43:30,300 --> 00:43:32,220
because

1049
00:43:32,220 --> 00:43:35,160
um every developer does that everyone

1050
00:43:35,160 --> 00:43:37,380
there's always bugs and software

1051
00:43:37,380 --> 00:43:39,240
development would be impossible

1052
00:43:39,240 --> 00:43:42,119
uh also you kind of have to probably

1053
00:43:42,119 --> 00:43:43,440
feel it a little bit in the context of

1054
00:43:43,440 --> 00:43:46,260
the time when this was developed uh I

1055
00:43:46,260 --> 00:43:49,500
think it was uh like 2008 2009 they had

1056
00:43:49,500 --> 00:43:51,660
an earlier version

1057
00:43:51,660 --> 00:43:53,040
um yeah

1058
00:43:53,040 --> 00:43:56,040
a lot of crypto attacks were known but

1059
00:43:56,040 --> 00:43:57,900
it was kind of really more the area of

1060
00:43:57,900 --> 00:43:59,700
like a few experts that really knew much

1061
00:43:59,700 --> 00:44:00,859
about it

1062
00:44:00,859 --> 00:44:03,480
and everyone was basically doing stuff

1063
00:44:03,480 --> 00:44:05,819
like this like uh you don't have that

1064
00:44:05,819 --> 00:44:07,640
many crypto experts around

1065
00:44:07,640 --> 00:44:10,260
and the tools are also not very good

1066
00:44:10,260 --> 00:44:11,579
because everyone has this super low

1067
00:44:11,579 --> 00:44:13,619
level building blocks like you have the

1068
00:44:13,619 --> 00:44:14,880
standard library and you could do like

1069
00:44:14,880 --> 00:44:16,980
AES and CBC mode a lot of each and

1070
00:44:16,980 --> 00:44:18,300
modern Alternatives were not really

1071
00:44:18,300 --> 00:44:20,400
available yet and definitely not very

1072
00:44:20,400 --> 00:44:23,280
widespread yet so it makes a lot of

1073
00:44:23,280 --> 00:44:24,660
sense that these things go wrong I can

1074
00:44:24,660 --> 00:44:26,640
really imagine that and I can all sort

1075
00:44:26,640 --> 00:44:28,319
of kind of see the how these kinds of

1076
00:44:28,319 --> 00:44:31,380
bugs can happen and yeah even with

1077
00:44:31,380 --> 00:44:34,260
crypto implementations uh yeah it's the

1078
00:44:34,260 --> 00:44:35,579
same as regular software you'll always

1079
00:44:35,579 --> 00:44:38,160
have vulnerability somewhere so I don't

1080
00:44:38,160 --> 00:44:41,220
really blame them uh I think this is

1081
00:44:41,220 --> 00:44:43,140
kind of a bit of a broader issue

1082
00:44:43,140 --> 00:44:45,060
um that it's still there's a lot of very

1083
00:44:45,060 --> 00:44:48,000
useful use cases for like using

1084
00:44:48,000 --> 00:44:50,540
cryptography or applications uh

1085
00:44:50,540 --> 00:44:52,740
especially things where you want to send

1086
00:44:52,740 --> 00:44:54,980
stuff to a clients like a web browser

1087
00:44:54,980 --> 00:44:58,560
and protect against tampering and

1088
00:44:58,560 --> 00:45:00,060
there's many different kind of ad hoc

1089
00:45:00,060 --> 00:45:01,980
implementations some are secure some are

1090
00:45:01,980 --> 00:45:03,900
not that secure

1091
00:45:03,900 --> 00:45:04,560
um

1092
00:45:04,560 --> 00:45:06,960
but it's not something that really gets

1093
00:45:06,960 --> 00:45:09,420
a lot of research put into it and that's

1094
00:45:09,420 --> 00:45:11,460
why it's a great field for me to take a

1095
00:45:11,460 --> 00:45:14,400
look at so I think we probably uh need

1096
00:45:14,400 --> 00:45:16,440
to develop some better tools to to solve

1097
00:45:16,440 --> 00:45:18,240
these kinds of things better tools to

1098
00:45:18,240 --> 00:45:20,700
review these kinds of things but

1099
00:45:20,700 --> 00:45:22,200
there definitely wasn't there back into

1100
00:45:22,200 --> 00:45:23,700
the other day so yeah I don't really

1101
00:45:23,700 --> 00:45:25,740
blame anyone this uh these kind of

1102
00:45:25,740 --> 00:45:28,160
things can happen

1103
00:45:32,339 --> 00:45:35,280
that's it okay never done

1104
00:45:35,280 --> 00:45:38,000
oh yeah

1105
00:45:41,220 --> 00:45:43,200
on finding crypto bugs

1106
00:45:43,200 --> 00:45:46,140
to get you uh no not yet actually my

1107
00:45:46,140 --> 00:45:47,880
next research is going to be about uh

1108
00:45:47,880 --> 00:45:51,599
Jason web tokens jwts uh nothing really

1109
00:45:51,599 --> 00:45:53,760
as bad as this but I did take a look at

1110
00:45:53,760 --> 00:45:56,160
a lot of JWT libraries and a lot of

1111
00:45:56,160 --> 00:45:58,920
obscure features that uh and found some

1112
00:45:58,920 --> 00:46:01,260
interesting things but uh that's uh what

1113
00:46:01,260 --> 00:46:03,480
I should submit that's a uh blackheads

1114
00:46:03,480 --> 00:46:05,099
or I'm planning to submit that blackhead

1115
00:46:05,099 --> 00:46:07,079
talk about they even just opened the

1116
00:46:07,079 --> 00:46:08,940
golfer paper so uh there was not time

1117
00:46:08,940 --> 00:46:11,099
there to get it accepted so yeah

1118
00:46:11,099 --> 00:46:12,720
hopefully there will I will be able to

1119
00:46:12,720 --> 00:46:16,399
present more about stuff like this

1120
00:46:19,500 --> 00:46:20,280
thank you

1121
00:46:20,280 --> 00:46:22,669
[Applause]

