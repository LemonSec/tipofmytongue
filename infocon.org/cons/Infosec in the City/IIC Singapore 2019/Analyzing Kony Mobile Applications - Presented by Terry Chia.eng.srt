1
00:00:00,030 --> 00:00:02,429
all right so welcome to my talk called

2
00:00:02,429 --> 00:00:05,460
analyzing Kony mobile applications I'm

3
00:00:05,460 --> 00:00:07,560
Terry and I'm a security consultant at

4
00:00:07,560 --> 00:00:10,260
Centurion information security and here

5
00:00:10,260 --> 00:00:11,940
are some of the places you can find me

6
00:00:11,940 --> 00:00:14,580
online such as my blog also my github

7
00:00:14,580 --> 00:00:18,390
account the agenda for today will look

8
00:00:18,390 --> 00:00:21,359
at what is Kony and some of the problems

9
00:00:21,359 --> 00:00:22,650
that you might have if you are trying to

10
00:00:22,650 --> 00:00:25,890
analyze a Kony application so we'll look

11
00:00:25,890 --> 00:00:28,140
at how the Scone you were internally as

12
00:00:28,140 --> 00:00:29,760
well as some of the problem some of the

13
00:00:29,760 --> 00:00:31,170
tooling that I wrote to solve some of

14
00:00:31,170 --> 00:00:34,649
the problems that you might have so just

15
00:00:34,649 --> 00:00:36,750
a disclaimer this is not a talk about

16
00:00:36,750 --> 00:00:38,910
security vulnerabilities in the Kony

17
00:00:38,910 --> 00:00:41,040
framework it's more about understanding

18
00:00:41,040 --> 00:00:43,829
how the framework functions so if you

19
00:00:43,829 --> 00:00:45,570
are doing a security you know doing a

20
00:00:45,570 --> 00:00:47,190
pen test for example on a cooling

21
00:00:47,190 --> 00:00:49,399
application you're able to effectively

22
00:00:49,399 --> 00:00:51,360
understand what it's doing and how to

23
00:00:51,360 --> 00:00:55,320
debug it for example so what is koni

24
00:00:55,320 --> 00:00:58,289
koni is a cross-platform application

25
00:00:58,289 --> 00:01:00,840
development environment and the idea of

26
00:01:00,840 --> 00:01:02,609
Kony is that you can write a single code

27
00:01:02,609 --> 00:01:04,170
base and you can generate applications

28
00:01:04,170 --> 00:01:07,130
for different platforms like Android iOS

29
00:01:07,130 --> 00:01:11,010
even Windows 10 yeah but it's most

30
00:01:11,010 --> 00:01:12,960
commonly used for mobile mobile

31
00:01:12,960 --> 00:01:14,939
applications so that is where you're

32
00:01:14,939 --> 00:01:17,729
most likely run across it and like all

33
00:01:17,729 --> 00:01:19,710
modern frameworks it involves the use of

34
00:01:19,710 --> 00:01:23,759
JavaScript licenses for Konya are

35
00:01:23,759 --> 00:01:26,850
relatively expensive so I took a look at

36
00:01:26,850 --> 00:01:28,890
Kony's pricing page on their website and

37
00:01:28,890 --> 00:01:32,360
the public price is $2,500 USD a month

38
00:01:32,360 --> 00:01:35,040
as a result of that their client base

39
00:01:35,040 --> 00:01:37,350
mostly consists of banks and other large

40
00:01:37,350 --> 00:01:39,869
corporations and they have a very

41
00:01:39,869 --> 00:01:42,150
helpful featured client page you might

42
00:01:42,150 --> 00:01:44,280
recognize some familiar names including

43
00:01:44,280 --> 00:01:49,140
a few banks so what is what are the

44
00:01:49,140 --> 00:01:50,280
problems you might have if you are

45
00:01:50,280 --> 00:01:53,220
looking at a coding application so when

46
00:01:53,220 --> 00:01:55,950
I first took a look at Cooney I try all

47
00:01:55,950 --> 00:01:57,960
the standard reverse engineering tooling

48
00:01:57,960 --> 00:01:59,670
so if you think about how you might do

49
00:01:59,670 --> 00:02:02,700
security analysis on a Android app you

50
00:02:02,700 --> 00:02:04,380
might pull out you might decompile the

51
00:02:04,380 --> 00:02:06,479
apk file and you look at the idea of it

52
00:02:06,479 --> 00:02:08,399
byte code you want to decompile it to

53
00:02:08,399 --> 00:02:10,410
something more readable like smiley code

54
00:02:10,410 --> 00:02:13,600
or Java for an iOS application you

55
00:02:13,600 --> 00:02:15,790
extract the macro binary from the IPA

56
00:02:15,790 --> 00:02:18,810
file and you might throw it into a

57
00:02:18,810 --> 00:02:22,120
decompiler like ida pro hopper or binary

58
00:02:22,120 --> 00:02:24,880
ninja you might want to do some dynamic

59
00:02:24,880 --> 00:02:27,070
analysis through runtime hooking using

60
00:02:27,070 --> 00:02:29,680
tools like Freda objection or expose

61
00:02:29,680 --> 00:02:32,050
which for any one of you who've done a

62
00:02:32,050 --> 00:02:33,700
mobile in tests should be very familiar

63
00:02:33,700 --> 00:02:35,370
to you

64
00:02:35,370 --> 00:02:37,840
however this what flow does not work for

65
00:02:37,840 --> 00:02:40,330
applications written with Coney mainly

66
00:02:40,330 --> 00:02:41,950
because the application logic of the

67
00:02:41,950 --> 00:02:44,590
application is not continually by code

68
00:02:44,590 --> 00:02:49,180
or the macro binary this screenshot here

69
00:02:49,180 --> 00:02:52,170
I have is a jxd compiler output of a

70
00:02:52,170 --> 00:02:54,790
production bill of AF that I pulled from

71
00:02:54,790 --> 00:02:56,980
the Play Store and you might look you

72
00:02:56,980 --> 00:02:58,540
might notice some familiar clusters like

73
00:02:58,540 --> 00:03:01,300
the boot config or the our class that

74
00:03:01,300 --> 00:03:02,800
contains some pointers to your

75
00:03:02,800 --> 00:03:05,440
application assets but there are there

76
00:03:05,440 --> 00:03:08,170
is no clusters or methods and so on

77
00:03:08,170 --> 00:03:11,380
actually contains the business logic of

78
00:03:11,380 --> 00:03:16,780
your application so when I started

79
00:03:16,780 --> 00:03:18,880
looking at Kuni I looked at some of the

80
00:03:18,880 --> 00:03:20,440
past research that other people have

81
00:03:20,440 --> 00:03:22,750
done because I did not want to like

82
00:03:22,750 --> 00:03:24,100
reverse engineer the framework if I

83
00:03:24,100 --> 00:03:26,650
didn't have to so what I found was that

84
00:03:26,650 --> 00:03:29,980
there were two one blog post and one

85
00:03:29,980 --> 00:03:32,710
talked about Kony and for Kuni versions

86
00:03:32,710 --> 00:03:35,620
less than 6.0 there's a blog post by NCC

87
00:03:35,620 --> 00:03:37,990
group and what they found was that the

88
00:03:37,990 --> 00:03:39,640
application code for the inversion of

89
00:03:39,640 --> 00:03:42,640
the free mode is written in law so if

90
00:03:42,640 --> 00:03:45,220
you extract that foul from the apk file

91
00:03:45,220 --> 00:03:47,200
and you pass it truly through a logic

92
00:03:47,200 --> 00:03:49,300
Impala you will be able to extract

93
00:03:49,300 --> 00:03:51,820
source code in clear-text and you can

94
00:03:51,820 --> 00:03:57,040
read it for Kony version 6.0 onwards to

95
00:03:57,040 --> 00:03:59,560
the latest version of Kuni there was a

96
00:03:59,560 --> 00:04:01,750
talk by a guy called Chris Whedon at one

97
00:04:01,750 --> 00:04:04,210
of the black heads in 2015 and title

98
00:04:04,210 --> 00:04:06,160
deconstructing Kony Android applications

99
00:04:06,160 --> 00:04:08,650
and what he found was that for Colin

100
00:04:08,650 --> 00:04:10,870
version 6.0 and this is true up to the

101
00:04:10,870 --> 00:04:13,030
latest version of Kony the application

102
00:04:13,030 --> 00:04:15,040
code is written in JavaScript and it's

103
00:04:15,040 --> 00:04:17,260
actually stored encrypted in your I PFR

104
00:04:17,260 --> 00:04:18,950
or apk file

105
00:04:18,950 --> 00:04:21,529
and he came up with some of the some

106
00:04:21,529 --> 00:04:23,240
tooling to extract that source code from

107
00:04:23,240 --> 00:04:25,700
application but what I found was the

108
00:04:25,700 --> 00:04:28,490
later versions of Kony framework his

109
00:04:28,490 --> 00:04:30,350
techniques obsolete because of some

110
00:04:30,350 --> 00:04:33,050
changes so I extended upon his research

111
00:04:33,050 --> 00:04:34,310
and came up with new tools and

112
00:04:34,310 --> 00:04:36,560
techniques for them and this will be the

113
00:04:36,560 --> 00:04:40,760
focus of the top buddy so how does Kony

114
00:04:40,760 --> 00:04:43,400
what yeah the first thing I knew might

115
00:04:43,400 --> 00:04:45,200
want to know is what version of Kony is

116
00:04:45,200 --> 00:04:47,390
used to build the application and you

117
00:04:47,390 --> 00:04:49,520
can get that information from a file in

118
00:04:49,520 --> 00:04:52,250
the apk called plug-in version stock

119
00:04:52,250 --> 00:04:54,950
properties and that file contains the

120
00:04:54,950 --> 00:04:57,010
version strings of all economy related

121
00:04:57,010 --> 00:04:59,720
tools plugins and implications used to

122
00:04:59,720 --> 00:05:02,120
be the application and the version is

123
00:05:02,120 --> 00:05:04,070
important because Kony constantly

124
00:05:04,070 --> 00:05:06,020
changes so if you have a technique that

125
00:05:06,020 --> 00:05:07,940
works on one version and does not work

126
00:05:07,940 --> 00:05:09,830
on the other version it's probably

127
00:05:09,830 --> 00:05:11,210
because there was an update in between

128
00:05:11,210 --> 00:05:14,540
that broke something and this is a

129
00:05:14,540 --> 00:05:16,820
sample output of the plug-in versions

130
00:05:16,820 --> 00:05:19,310
file I highlight the relevant line in

131
00:05:19,310 --> 00:05:21,200
yellow which is the version of kali

132
00:05:21,200 --> 00:05:23,630
studio used to build the application and

133
00:05:23,630 --> 00:05:26,620
Kuni studio is the name of the Kony IDE

134
00:05:26,620 --> 00:05:30,460
integrated development environment and

135
00:05:30,460 --> 00:05:33,530
the application source code is in a

136
00:05:33,530 --> 00:05:37,010
folder assess the SSDs footer of the apk

137
00:05:37,010 --> 00:05:39,620
file and you might see a few different

138
00:05:39,620 --> 00:05:42,650
files in there two of them the common

139
00:05:42,650 --> 00:05:45,380
J's lips taki FM and the worker trans

140
00:05:45,380 --> 00:05:48,110
taki FM are more or less like the Kony

141
00:05:48,110 --> 00:05:50,420
standard library and they'll be found in

142
00:05:50,420 --> 00:05:52,430
every single application live Kony and

143
00:05:52,430 --> 00:05:56,540
they start J's files where are your code

144
00:05:56,540 --> 00:05:58,100
specific to the application so your

145
00:05:58,100 --> 00:06:00,530
business logic for example this is where

146
00:06:00,530 --> 00:06:05,450
you live so I started reverse

147
00:06:05,450 --> 00:06:07,610
engineering the framework and what I

148
00:06:07,610 --> 00:06:10,490
found was that the when a Kodi

149
00:06:10,490 --> 00:06:12,320
application starts up it actually loads

150
00:06:12,320 --> 00:06:15,980
a library called Cornelius VM so you if

151
00:06:15,980 --> 00:06:18,230
you decompile the dalvik bytecode of the

152
00:06:18,230 --> 00:06:20,600
apk you will see a method that calls

153
00:06:20,600 --> 00:06:22,970
system that library any loads ecologist

154
00:06:22,970 --> 00:06:25,700
v-initial angry and there will be a

155
00:06:25,700 --> 00:06:27,500
different shall i brief for every cpu

156
00:06:27,500 --> 00:06:29,000
architecture that the application is

157
00:06:29,000 --> 00:06:31,449
meant to support so if the

158
00:06:31,449 --> 00:06:33,580
men to support x86 and arm you'll see

159
00:06:33,580 --> 00:06:34,930
two different versions of the MSHA

160
00:06:34,930 --> 00:06:39,069
library and the shall I bring contains

161
00:06:39,069 --> 00:06:41,589
symbols that indicate the use of the v8

162
00:06:41,589 --> 00:06:44,229
JavaScript engine so this is just a very

163
00:06:44,229 --> 00:06:46,539
tiny subset of all the related symbols

164
00:06:46,539 --> 00:06:48,759
in the shall I agree and the entire

165
00:06:48,759 --> 00:06:50,740
JavaScript engine is actually statically

166
00:06:50,740 --> 00:06:53,080
compiled into the UM konnichi SVM

167
00:06:53,080 --> 00:06:57,639
library and there is a interesting

168
00:06:57,639 --> 00:06:59,710
function in the library called cone eg

169
00:06:59,710 --> 00:07:02,979
SVM load falls to VM that is during the

170
00:07:02,979 --> 00:07:05,169
start process and in this only caught

171
00:07:05,169 --> 00:07:06,969
once when the application is launched

172
00:07:06,969 --> 00:07:09,629
and the function does three main things

173
00:07:09,629 --> 00:07:12,550
first it derives the decryption key for

174
00:07:12,550 --> 00:07:15,249
the source code it decrypts the source

175
00:07:15,249 --> 00:07:17,620
code and finally it loads the decrypted

176
00:07:17,620 --> 00:07:22,180
code into the v8 engine if you want to

177
00:07:22,180 --> 00:07:23,979
decrypt if you want to pull out the

178
00:07:23,979 --> 00:07:25,659
source code you only decrypt it it's

179
00:07:25,659 --> 00:07:27,339
important to know what the key

180
00:07:27,339 --> 00:07:29,649
derivation logic is so how does the

181
00:07:29,649 --> 00:07:31,870
application know or how does it derive

182
00:07:31,870 --> 00:07:33,580
the decryption key used to decrypt the

183
00:07:33,580 --> 00:07:37,029
source code and that logic is taught in

184
00:07:37,029 --> 00:07:39,069
the college's VM load force to VM

185
00:07:39,069 --> 00:07:41,830
function and the first thing it does is

186
00:07:41,830 --> 00:07:44,710
is it allocates 256 bytes of memory with

187
00:07:44,710 --> 00:07:48,009
the main set function next it calls a

188
00:07:48,009 --> 00:07:50,589
function called gap time and with the

189
00:07:50,589 --> 00:07:52,089
return value of the item function it

190
00:07:52,089 --> 00:07:54,999
shows it into HR XOR function before

191
00:07:54,999 --> 00:07:57,759
appending the return value of death to a

192
00:07:57,759 --> 00:08:01,389
located block of memory it then does the

193
00:08:01,389 --> 00:08:03,669
same process but with another function

194
00:08:03,669 --> 00:08:08,229
called the en function and finally it

195
00:08:08,229 --> 00:08:09,879
calls a function called a package name

196
00:08:09,879 --> 00:08:12,849
any trust it into a different track sole

197
00:08:12,849 --> 00:08:14,860
function before appending that value

198
00:08:14,860 --> 00:08:23,740
into the allocated block of memory once

199
00:08:23,740 --> 00:08:26,379
the key generation is done it will

200
00:08:26,379 --> 00:08:28,990
finally call a simple sha-256 function

201
00:08:28,990 --> 00:08:32,440
to hash all the the allocated block of

202
00:08:32,440 --> 00:08:35,440
memory into a single 256 bit key that is

203
00:08:35,440 --> 00:08:39,880
used for decryption you might be

204
00:08:39,880 --> 00:08:41,169
interested to know what the three

205
00:08:41,169 --> 00:08:42,429
different functions that occurred during

206
00:08:42,429 --> 00:08:44,130
the key derivation process

207
00:08:44,130 --> 00:08:46,530
and they are actually Java functions

208
00:08:46,530 --> 00:08:48,630
they are indeed having my code so the

209
00:08:48,630 --> 00:08:51,390
native the native code in the couny gspn

210
00:08:51,390 --> 00:08:53,460
chat library calls out to some other

211
00:08:53,460 --> 00:08:57,330
function in your IP keifa and the first

212
00:08:57,330 --> 00:08:58,980
functional causes the prank stem

213
00:08:58,980 --> 00:09:02,610
function which basics d4 decodes a VM FY

214
00:09:02,610 --> 00:09:06,540
string that is actually VAR b 64 encoded

215
00:09:06,540 --> 00:09:10,230
so it uses that string as a key value

216
00:09:10,230 --> 00:09:12,750
and reads it from application properties

217
00:09:12,750 --> 00:09:15,540
file and that he actually contains the

218
00:09:15,540 --> 00:09:17,610
timestamp value of when the APK file was

219
00:09:17,610 --> 00:09:20,460
built so if you have the same apk and

220
00:09:20,460 --> 00:09:23,070
you build twice the decryption he will

221
00:09:23,070 --> 00:09:26,760
be different for each time digit X

222
00:09:26,760 --> 00:09:28,560
function the get name function calls

223
00:09:28,560 --> 00:09:31,290
enjoy its context it's got package name

224
00:09:31,290 --> 00:09:33,630
method which returns the package name of

225
00:09:33,630 --> 00:09:36,240
the Android application for the binary

226
00:09:36,240 --> 00:09:38,670
the apk for the I was analyzing I put

227
00:09:38,670 --> 00:09:40,830
from the Play Store the package name is

228
00:09:40,830 --> 00:09:43,220
calm dot Coney dog function preview em

229
00:09:43,220 --> 00:09:47,340
and finally the gain function which the

230
00:09:47,340 --> 00:09:49,440
app ID key from the same application

231
00:09:49,440 --> 00:09:52,170
properties file and that he contains

232
00:09:52,170 --> 00:09:54,540
something called the Coney app ID of the

233
00:09:54,540 --> 00:09:56,460
application and this is probably

234
00:09:56,460 --> 00:09:58,200
something that is different for every

235
00:09:58,200 --> 00:10:02,190
Coney application so this is a example

236
00:10:02,190 --> 00:10:04,260
of the application of properties file

237
00:10:04,260 --> 00:10:06,420
it's a bit small so I blew up the

238
00:10:06,420 --> 00:10:08,820
relevant section and you see that the

239
00:10:08,820 --> 00:10:11,940
MIT in this case is FBA and the VAR key

240
00:10:11,940 --> 00:10:14,310
contains the unix time stem of brandy

241
00:10:14,310 --> 00:10:18,690
application was until now that we know

242
00:10:18,690 --> 00:10:20,430
how the decryption key is derived the

243
00:10:20,430 --> 00:10:22,260
final piece of the puzzle we need to

244
00:10:22,260 --> 00:10:24,630
decrypt the source code is the actual

245
00:10:24,630 --> 00:10:26,250
algorithm that's used for encryption and

246
00:10:26,250 --> 00:10:26,940
decryption

247
00:10:26,940 --> 00:10:29,790
I was unable to identify the specific

248
00:10:29,790 --> 00:10:32,280
algorithm from the shell library but I

249
00:10:32,280 --> 00:10:34,200
found hints that boring SSL or

250
00:10:34,200 --> 00:10:37,410
statically compiled into the library so

251
00:10:37,410 --> 00:10:38,790
it turns out that we need to look

252
00:10:38,790 --> 00:10:41,760
somewhere else and that somewhere else

253
00:10:41,760 --> 00:10:45,290
is actually a Korean score load for

254
00:10:45,290 --> 00:10:48,150
executable that was used during the boot

255
00:10:48,150 --> 00:10:51,600
process the quarry visualizer idea you

256
00:10:51,600 --> 00:10:53,699
that executable to encrypt the source

257
00:10:53,699 --> 00:10:56,190
code before packaging it into the apk

258
00:10:56,190 --> 00:10:59,850
file on the IPE file and the interesting

259
00:10:59,850 --> 00:11:01,949
thing is that we can put executable from

260
00:11:01,949 --> 00:11:04,290
the Installer so the Installer is freely

261
00:11:04,290 --> 00:11:06,839
available online for download you can

262
00:11:06,839 --> 00:11:09,120
actually use the IDE to butan anything

263
00:11:09,120 --> 00:11:11,279
without a valid license key but you can

264
00:11:11,279 --> 00:11:13,380
extract false work from it for analyzing

265
00:11:13,380 --> 00:11:16,920
analysis and the the compiler output of

266
00:11:16,920 --> 00:11:18,930
the executable shows that the encryption

267
00:11:18,930 --> 00:11:24,949
algorithm in use is aes-256 in CBC mode

268
00:11:25,009 --> 00:11:29,430
in the couny look for exe executable

269
00:11:29,430 --> 00:11:33,089
there is there's a call to open SSL VPN

270
00:11:33,089 --> 00:11:35,399
criminate function and the fourth

271
00:11:35,399 --> 00:11:36,870
argument of that function is the

272
00:11:36,870 --> 00:11:39,060
specifies the initialization vector of

273
00:11:39,060 --> 00:11:41,550
the encryption process and it points to

274
00:11:41,550 --> 00:11:43,800
the dot data section which contains a

275
00:11:43,800 --> 00:11:47,370
string ABCD 1 2 3 4 eh

276
00:11:47,370 --> 00:11:50,069
5 6 7 8 so that is most likely the

277
00:11:50,069 --> 00:11:51,660
initialization vector used during the

278
00:11:51,660 --> 00:11:54,449
encryption process and we found the same

279
00:11:54,449 --> 00:11:56,970
string in the Kali load files to VM

280
00:11:56,970 --> 00:11:58,319
function in the shall I Bree

281
00:11:58,319 --> 00:12:01,230
so it's very very likely that that is

282
00:12:01,230 --> 00:12:05,910
actually the IV so when it comes to

283
00:12:05,910 --> 00:12:08,040
writing a decrypter Chris we then

284
00:12:08,040 --> 00:12:11,040
actually had a idea in 2015 to tonday

285
00:12:11,040 --> 00:12:14,069
Colin look for exe encrypted into a

286
00:12:14,069 --> 00:12:16,500
decrypted by binary patching the

287
00:12:16,500 --> 00:12:19,639
executable for other versions of OpenSSL

288
00:12:19,639 --> 00:12:22,500
you initialize the encryption routine by

289
00:12:22,500 --> 00:12:25,740
the cipher in underscore X function that

290
00:12:25,740 --> 00:12:27,720
has a single parameter that takes an

291
00:12:27,720 --> 00:12:29,880
integer that decides whether it's used

292
00:12:29,880 --> 00:12:32,069
for encryption or decryption so what he

293
00:12:32,069 --> 00:12:34,230
did was he binary patch is no biting

294
00:12:34,230 --> 00:12:36,209
that executable and you can now use it

295
00:12:36,209 --> 00:12:38,699
for to decrypt the source code instead

296
00:12:38,699 --> 00:12:42,089
of encrypting it however this no longer

297
00:12:42,089 --> 00:12:44,220
works for newer versions of Connie

298
00:12:44,220 --> 00:12:47,189
because updates to the executable makes

299
00:12:47,189 --> 00:12:50,639
use of a newer open SSL API which has

300
00:12:50,639 --> 00:12:51,810
separate encryption and decryption

301
00:12:51,810 --> 00:12:54,480
functions so you can no longer just

302
00:12:54,480 --> 00:12:55,889
binary patch Lee single byte in the

303
00:12:55,889 --> 00:12:57,930
executable to turn it from encrypted we

304
00:12:57,930 --> 00:12:59,809
decrypt

305
00:12:59,809 --> 00:13:02,220
so we have to reemployment everything

306
00:13:02,220 --> 00:13:05,120
from scratch ourselves I had a few

307
00:13:05,120 --> 00:13:06,890
ideas of how to do it the first

308
00:13:06,890 --> 00:13:08,870
potential option is to just rewrite the

309
00:13:08,870 --> 00:13:11,630
whole key derivation algorithm in Python

310
00:13:11,630 --> 00:13:13,730
or a different programming language but

311
00:13:13,730 --> 00:13:15,380
this is actually very tedious to do

312
00:13:15,380 --> 00:13:16,490
because you have to get all these

313
00:13:16,490 --> 00:13:19,070
specific steps right and it is quite

314
00:13:19,070 --> 00:13:21,290
brittle as if the update leaf framework

315
00:13:21,290 --> 00:13:23,779
use a to change the algorithm slightly

316
00:13:23,779 --> 00:13:26,260
you have to rewrite the whole thing and

317
00:13:26,260 --> 00:13:28,580
the key derivation process actually

318
00:13:28,580 --> 00:13:31,700
makes us in a secret value that's unique

319
00:13:31,700 --> 00:13:33,650
to each version of the colony framework

320
00:13:33,650 --> 00:13:35,570
and you if you want to statically

321
00:13:35,570 --> 00:13:39,680
extract that data automatically without

322
00:13:39,680 --> 00:13:41,779
human analysis it will take quite a bit

323
00:13:41,779 --> 00:13:43,510
of effort

324
00:13:43,510 --> 00:13:46,310
the second option I came up with was to

325
00:13:46,310 --> 00:13:48,620
pull the derive key at runtime from the

326
00:13:48,620 --> 00:13:50,360
actual application that's that you are

327
00:13:50,360 --> 00:13:53,300
analyzing so this is quite simple to do

328
00:13:53,300 --> 00:13:56,089
with a debugger or a dynamic binary

329
00:13:56,089 --> 00:13:57,950
instrumentation framework it's

330
00:13:57,950 --> 00:14:00,380
relatively simple to implement and this

331
00:14:00,380 --> 00:14:02,270
is the approach I eventually ended up

332
00:14:02,270 --> 00:14:06,350
with the option that I did not actually

333
00:14:06,350 --> 00:14:08,330
implement but it's interesting to

334
00:14:08,330 --> 00:14:09,950
consider is that you can just emulate

335
00:14:09,950 --> 00:14:12,320
the key derivation within so I think

336
00:14:12,320 --> 00:14:14,690
Alice mentioned the unique on emulator

337
00:14:14,690 --> 00:14:17,900
idea it's fantastic it's actually very

338
00:14:17,900 --> 00:14:20,360
simple to use in economy later to

339
00:14:20,360 --> 00:14:23,240
emulate the key derivation process you

340
00:14:23,240 --> 00:14:25,610
just have to substitute in the calls to

341
00:14:25,610 --> 00:14:29,690
the Java functions this is a very useful

342
00:14:29,690 --> 00:14:32,330
keep in mind if the application you're

343
00:14:32,330 --> 00:14:34,880
analyzing has a lot of NP debugging

344
00:14:34,880 --> 00:14:37,130
mechanisms in place which makes it a bit

345
00:14:37,130 --> 00:14:38,480
more difficult if you want to attach a

346
00:14:38,480 --> 00:14:42,890
debugger EBI when it comes to the

347
00:14:42,890 --> 00:14:44,900
implementation of the decryption routine

348
00:14:44,900 --> 00:14:48,290
I decided to make use of frida which is

349
00:14:48,290 --> 00:14:50,570
a dynamic memory binary instrumentation

350
00:14:50,570 --> 00:14:52,940
free mode if any of you have done a

351
00:14:52,940 --> 00:14:55,190
mobile application analysis you would

352
00:14:55,190 --> 00:14:57,380
most likely be familiar with freedom it

353
00:14:57,380 --> 00:14:59,000
gives you the ability to do things like

354
00:14:59,000 --> 00:15:01,490
attaching two functions you can done

355
00:15:01,490 --> 00:15:04,040
memory from the running process and you

356
00:15:04,040 --> 00:15:05,570
can even like modify runtime behavior

357
00:15:05,570 --> 00:15:09,050
and the goal is to write a frida script

358
00:15:09,050 --> 00:15:11,420
to attach to a point in your key

359
00:15:11,420 --> 00:15:13,040
derivation process and to dumb the

360
00:15:13,040 --> 00:15:16,089
decryption key when it's done

361
00:15:20,540 --> 00:15:23,040
so looking back at the key derivation

362
00:15:23,040 --> 00:15:25,500
process it appears that the simple

363
00:15:25,500 --> 00:15:27,420
sha-256 function is the most appropriate

364
00:15:27,420 --> 00:15:29,730
location to whom because that is when

365
00:15:29,730 --> 00:15:31,440
the key derivation process is completed

366
00:15:31,440 --> 00:15:34,440
and the argument to that function is a

367
00:15:34,440 --> 00:15:37,130
pointer to where the output of the

368
00:15:37,130 --> 00:15:40,470
hashing function is written so we can

369
00:15:40,470 --> 00:15:42,569
just hook that function and extract 32

370
00:15:42,569 --> 00:15:44,670
bytes from it when the function is done

371
00:15:44,670 --> 00:15:50,009
running and this is the core of the

372
00:15:50,009 --> 00:15:52,290
frida script that I ended up with you

373
00:15:52,290 --> 00:15:53,550
can see in the first line that I

374
00:15:53,550 --> 00:15:55,050
highlight that we are attaching to the

375
00:15:55,050 --> 00:15:57,319
simple sha-256 function in the library

376
00:15:57,319 --> 00:15:59,579
in this second line we are telling

377
00:15:59,579 --> 00:16:00,949
Friedlander we want to hook the

378
00:16:00,949 --> 00:16:04,050
parameter to that function and on the

379
00:16:04,050 --> 00:16:06,569
third line once the function is done

380
00:16:06,569 --> 00:16:08,910
executing we are telling Freda to dump

381
00:16:08,910 --> 00:16:11,519
32 by 32 bytes of memory from that

382
00:16:11,519 --> 00:16:15,470
pointer address and return it to us

383
00:16:15,829 --> 00:16:18,180
after dumping the key we can write a

384
00:16:18,180 --> 00:16:19,709
Python script to decrypt the application

385
00:16:19,709 --> 00:16:23,670
source code one complication I ran into

386
00:16:23,670 --> 00:16:26,100
was the older versions of Connie instead

387
00:16:26,100 --> 00:16:28,380
of the ABCD one two three four IV that I

388
00:16:28,380 --> 00:16:30,779
found was actually using all zeros for

389
00:16:30,779 --> 00:16:34,410
the IV however this is quite simple to

390
00:16:34,410 --> 00:16:36,810
get around because you can just try both

391
00:16:36,810 --> 00:16:39,779
IVs and see which one results in a valid

392
00:16:39,779 --> 00:16:42,000
decryption and this is especially easy

393
00:16:42,000 --> 00:16:44,850
to do because the decrypted output is

394
00:16:44,850 --> 00:16:47,459
supposed to be a zip file so all we have

395
00:16:47,459 --> 00:16:49,949
to do is run the decryption process and

396
00:16:49,949 --> 00:16:51,480
we check the first few bytes of the

397
00:16:51,480 --> 00:16:54,959
output if it matches the magic value of

398
00:16:54,959 --> 00:16:57,209
a zip file we can just say that the

399
00:16:57,209 --> 00:16:58,860
decryption is successful and we can stop

400
00:16:58,860 --> 00:17:03,389
otherwise we just try the other IV so

401
00:17:03,389 --> 00:17:08,640
for my first demo I'm going to be

402
00:17:08,640 --> 00:17:12,650
showing the decryption script running

403
00:17:12,650 --> 00:17:15,199
all right

404
00:17:15,199 --> 00:17:17,299
so you can see on the right side I have

405
00:17:17,299 --> 00:17:19,220
my Android device running so I'm running

406
00:17:19,220 --> 00:17:23,059
the application so on the Left I have

407
00:17:23,059 --> 00:17:24,919
the terminal where I'll be running the

408
00:17:24,919 --> 00:17:27,769
decryption script so I wrote a script

409
00:17:27,769 --> 00:17:30,139
code unpacking of Pi which which will

410
00:17:30,139 --> 00:17:32,419
decrypt the what we shall run launch the

411
00:17:32,419 --> 00:17:34,309
application pull out the key and decrypt

412
00:17:34,309 --> 00:17:36,559
the source code and it takes three

413
00:17:36,559 --> 00:17:38,929
parameters which is the apk file the

414
00:17:38,929 --> 00:17:40,639
package name of the application and the

415
00:17:40,639 --> 00:17:43,220
output directory of where the decrypted

416
00:17:43,220 --> 00:17:45,100
source code is from will be written to

417
00:17:45,100 --> 00:17:47,269
so you see that I launched the

418
00:17:47,269 --> 00:17:48,739
application i extracted the key and

419
00:17:48,739 --> 00:17:52,489
advocate that the source code and there

420
00:17:52,489 --> 00:17:53,989
are three files in the output directory

421
00:17:53,989 --> 00:17:56,210
and they're all zip files containing

422
00:17:56,210 --> 00:18:03,019
JavaScript source code if we unzip one

423
00:18:03,019 --> 00:18:05,600
of the zip files we will see a bunch of

424
00:18:05,600 --> 00:18:07,489
JavaScript source code and that is where

425
00:18:07,489 --> 00:18:08,779
all your business logic of the

426
00:18:08,779 --> 00:18:17,659
application lies so just the component

427
00:18:17,659 --> 00:18:20,119
the decryption process is currently done

428
00:18:20,119 --> 00:18:21,889
we can open up any of the JavaScript

429
00:18:21,889 --> 00:18:24,950
files and we will see the source code of

430
00:18:24,950 --> 00:18:33,950
the application in here Thanks right so

431
00:18:33,950 --> 00:18:36,739
that's how you extract source code from

432
00:18:36,739 --> 00:18:39,259
a Coney Android application however I

433
00:18:39,259 --> 00:18:41,779
wanted something more because I wanted a

434
00:18:41,779 --> 00:18:45,049
runtime debugger and the reason for that

435
00:18:45,049 --> 00:18:47,059
is if you want to go through a source

436
00:18:47,059 --> 00:18:49,609
code of a for an application it's not

437
00:18:49,609 --> 00:18:51,470
really fun especially if the application

438
00:18:51,470 --> 00:18:54,109
is very lunch if you have a runtime

439
00:18:54,109 --> 00:18:56,570
debugger for a framework you can make

440
00:18:56,570 --> 00:18:58,909
your analysis very easy by giving you

441
00:18:58,909 --> 00:19:00,379
the capabilities like setting

442
00:19:00,379 --> 00:19:03,139
breakpoints you can monitor any variable

443
00:19:03,139 --> 00:19:04,909
value change and you can even like

444
00:19:04,909 --> 00:19:07,309
modify how a function is implemented if

445
00:19:07,309 --> 00:19:11,269
you want to bypass some behaviors the

446
00:19:11,269 --> 00:19:13,909
first option that we have for a debugger

447
00:19:13,909 --> 00:19:16,309
is we can of course this gdb you can

448
00:19:16,309 --> 00:19:18,200
attach the gdb to a running application

449
00:19:18,200 --> 00:19:20,659
on Android and you can analyze the

450
00:19:20,659 --> 00:19:22,490
native instructions that are on

451
00:19:22,490 --> 00:19:24,920
however this is not very ideal because

452
00:19:24,920 --> 00:19:27,280
there is no good way to make a series of

453
00:19:27,280 --> 00:19:30,590
for example x86 instructions into a line

454
00:19:30,590 --> 00:19:32,990
of JavaScript code so you actually lose

455
00:19:32,990 --> 00:19:35,630
the semantics of the application when

456
00:19:35,630 --> 00:19:39,740
you are debugging it that way looking at

457
00:19:39,740 --> 00:19:42,560
the Coney documentation so like all

458
00:19:42,560 --> 00:19:45,230
these development environments the Coney

459
00:19:45,230 --> 00:19:48,140
ID offers debugging capabilities and you

460
00:19:48,140 --> 00:19:49,880
can access those capabilities if you

461
00:19:49,880 --> 00:19:51,800
build the application in debug mode and

462
00:19:51,800 --> 00:19:54,830
the interesting thing here is then coney

463
00:19:54,830 --> 00:19:56,630
uses chrome dev tools as their official

464
00:19:56,630 --> 00:19:59,450
debugger which suggests that the

465
00:19:59,450 --> 00:20:01,420
debugging capabilities implemented with

466
00:20:01,420 --> 00:20:03,980
your standard v8 functions instead of

467
00:20:03,980 --> 00:20:08,440
something more custom so at this point

468
00:20:08,440 --> 00:20:11,540
let's take a detour into a quick history

469
00:20:11,540 --> 00:20:15,680
lesson of debugging we initially contain

470
00:20:15,680 --> 00:20:18,320
a debug API that started a remote

471
00:20:18,320 --> 00:20:20,840
debugging service on a TCP port so

472
00:20:20,840 --> 00:20:23,330
there's there was an enable agent method

473
00:20:23,330 --> 00:20:25,250
and if you caught a method you will

474
00:20:25,250 --> 00:20:27,890
launch a PCB service listening only part

475
00:20:27,890 --> 00:20:29,870
that you specify where you can connect

476
00:20:29,870 --> 00:20:32,690
to it and about the application this

477
00:20:32,690 --> 00:20:35,120
agent was eventually removed in later

478
00:20:35,120 --> 00:20:37,910
versions of v8 and from what I found

479
00:20:37,910 --> 00:20:40,040
from the v8 mailing lists the

480
00:20:40,040 --> 00:20:42,290
justification that we did not want to

481
00:20:42,290 --> 00:20:45,260
ship on TCP related code because they do

482
00:20:45,260 --> 00:20:47,300
not want to maintain code for a specific

483
00:20:47,300 --> 00:20:49,970
platform if you think about a TCP

484
00:20:49,970 --> 00:20:51,680
service will be slightly different for

485
00:20:51,680 --> 00:20:54,920
Windows Linux and Mac OS and we wanted

486
00:20:54,920 --> 00:20:56,900
to leave it up to the consumers of the

487
00:20:56,900 --> 00:21:01,220
JavaScript engine to implement them so

488
00:21:01,220 --> 00:21:03,320
consumers of the implementer code that

489
00:21:03,320 --> 00:21:05,900
imitated the behavior of the or remote

490
00:21:05,900 --> 00:21:07,550
debugging service that was removed and

491
00:21:07,550 --> 00:21:09,830
this was mostly stolen your existing

492
00:21:09,830 --> 00:21:11,770
debuggers will continue to work for

493
00:21:11,770 --> 00:21:14,630
example no Jay no J's did something like

494
00:21:14,630 --> 00:21:16,610
this ready implemented a some custom

495
00:21:16,610 --> 00:21:18,920
code that essentially did what the old

496
00:21:18,920 --> 00:21:26,600
departing service did and this debug API

497
00:21:26,600 --> 00:21:29,060
in later versions of v8 was actually

498
00:21:29,060 --> 00:21:31,250
removed in favor of a new inspector API

499
00:21:31,250 --> 00:21:33,430
with more capabilities

500
00:21:33,430 --> 00:21:35,620
and this inspector API is what chrome

501
00:21:35,620 --> 00:21:37,210
dev tools in a current version of chrome

502
00:21:37,210 --> 00:21:42,070
uses so how is this relevant to what we

503
00:21:42,070 --> 00:21:43,720
want to do which is a runtime debugger

504
00:21:43,720 --> 00:21:46,600
for koni koni uses a version of yet that

505
00:21:46,600 --> 00:21:49,030
does not support the new inspector API

506
00:21:49,030 --> 00:21:51,340
so if you look at all the related debug

507
00:21:51,340 --> 00:21:53,620
functions you will notice methods from

508
00:21:53,620 --> 00:21:56,350
the namespace instead of the inspector

509
00:21:56,350 --> 00:21:59,980
namespace so Kony is probably

510
00:21:59,980 --> 00:22:02,200
implementing like whatnot GSD they

511
00:22:02,200 --> 00:22:04,060
implemented the same remote debugging

512
00:22:04,060 --> 00:22:07,090
service over a TCP port and the problem

513
00:22:07,090 --> 00:22:09,310
was that I could not find any traces of

514
00:22:09,310 --> 00:22:11,110
that code in the release build of the

515
00:22:11,110 --> 00:22:16,330
library so after looking at the build

516
00:22:16,330 --> 00:22:18,820
process of Kuni further what I found was

517
00:22:18,820 --> 00:22:20,950
that many many Kony application is built

518
00:22:20,950 --> 00:22:23,890
in debug mode everything else everything

519
00:22:23,890 --> 00:22:25,300
else in the application is the same

520
00:22:25,300 --> 00:22:27,910
except that a different library is

521
00:22:27,910 --> 00:22:30,880
packaged in and if we pull out the two

522
00:22:30,880 --> 00:22:32,590
different libraries from the Installer

523
00:22:32,590 --> 00:22:35,290
we can do analysis to see like what is

524
00:22:35,290 --> 00:22:38,950
the difference between the two so if we

525
00:22:38,950 --> 00:22:42,010
binary diff the two sure libraries so we

526
00:22:42,010 --> 00:22:45,180
can use a tool like bindi for die for

527
00:22:45,180 --> 00:22:47,320
yes so this is what I did and what I

528
00:22:47,320 --> 00:22:48,970
found was that if you want to do this

529
00:22:48,970 --> 00:22:51,880
you need to be sure library from this

530
00:22:51,880 --> 00:22:54,490
same version of Kony to avoid any noise

531
00:22:54,490 --> 00:22:56,560
from for example code implementing new

532
00:22:56,560 --> 00:23:00,250
functions so what I found was that the

533
00:23:00,250 --> 00:23:02,380
debug shall I bring contains several

534
00:23:02,380 --> 00:23:04,960
methods from this GSD but Egypt familiar

535
00:23:04,960 --> 00:23:07,330
functions that actually implements the

536
00:23:07,330 --> 00:23:10,930
remote debugging service and the

537
00:23:10,930 --> 00:23:12,550
interesting thing is that the GSD but

538
00:23:12,550 --> 00:23:15,340
agent functions actually gni functions

539
00:23:15,340 --> 00:23:17,230
which means that they have a

540
00:23:17,230 --> 00:23:19,270
corresponding Java class so that the apk

541
00:23:19,270 --> 00:23:21,880
can call it and this Java class is

542
00:23:21,880 --> 00:23:25,210
actually the GSD but a gen class and the

543
00:23:25,210 --> 00:23:26,980
class is still present in the idea of ik

544
00:23:26,980 --> 00:23:28,840
by code of a release P of the

545
00:23:28,840 --> 00:23:32,800
application so this is what the class

546
00:23:32,800 --> 00:23:34,900
will look like just a very small snippet

547
00:23:34,900 --> 00:23:37,360
of it and you might notice that there is

548
00:23:37,360 --> 00:23:39,910
a pot where is a variable called pot

549
00:23:39,910 --> 00:23:40,740
where

550
00:23:40,740 --> 00:23:42,720
specify which part you wanna debug the

551
00:23:42,720 --> 00:23:47,309
debugger to be listening on so at this

552
00:23:47,309 --> 00:23:48,690
point once we know all of this

553
00:23:48,690 --> 00:23:51,330
information we have a game plan to get a

554
00:23:51,330 --> 00:23:53,760
debugger running for a release build of

555
00:23:53,760 --> 00:23:56,400
Kuni what we can do is we can repackage

556
00:23:56,400 --> 00:23:58,620
the apk file with the debug version of

557
00:23:58,620 --> 00:24:00,630
the shot library because everything else

558
00:24:00,630 --> 00:24:02,280
about the application remains the same

559
00:24:02,280 --> 00:24:04,920
we can then use something like Frieda to

560
00:24:04,920 --> 00:24:08,670
the GSD per region Java class to anybody

561
00:24:08,670 --> 00:24:11,040
debugger so once we've done all of that

562
00:24:11,040 --> 00:24:12,630
we should then be able to connect to the

563
00:24:12,630 --> 00:24:16,650
application using chrome dev tools so

564
00:24:16,650 --> 00:24:18,150
there were a few problems that I ran

565
00:24:18,150 --> 00:24:20,370
across along the way the first was that

566
00:24:20,370 --> 00:24:22,770
we cannot just call the GSD but each and

567
00:24:22,770 --> 00:24:24,510
Java class from the main track of the

568
00:24:24,510 --> 00:24:26,670
application because it needs to run in

569
00:24:26,670 --> 00:24:27,240
the background

570
00:24:27,240 --> 00:24:29,070
otherwise your application will just be

571
00:24:29,070 --> 00:24:32,370
standard so that's already code in the

572
00:24:32,370 --> 00:24:35,040
dalvik bytecode that does this so all

573
00:24:35,040 --> 00:24:36,300
you have to do is we have to find it and

574
00:24:36,300 --> 00:24:38,790
we have to call it and the method that

575
00:24:38,790 --> 00:24:40,590
we are interested in lives in a class

576
00:24:40,590 --> 00:24:43,170
called Kony mean however there's a

577
00:24:43,170 --> 00:24:45,750
different name on every bit of Kony due

578
00:24:45,750 --> 00:24:48,360
to program application so you have to do

579
00:24:48,360 --> 00:24:50,730
some manual manual analysis to find out

580
00:24:50,730 --> 00:24:53,040
which is the method that you need to

581
00:24:53,040 --> 00:24:56,250
trigger so what you want to look for is

582
00:24:56,250 --> 00:24:57,600
you want to look for a method that

583
00:24:57,600 --> 00:25:00,480
returns a Enloe object and for in that

584
00:25:00,480 --> 00:25:02,400
class there should only be one of such

585
00:25:02,400 --> 00:25:03,990
methods so it should be relatively easy

586
00:25:03,990 --> 00:25:08,429
to and then identify yeah so this is the

587
00:25:08,429 --> 00:25:12,000
jxd compiled output of the class and the

588
00:25:12,000 --> 00:25:14,520
method n is something that is what you

589
00:25:14,520 --> 00:25:16,740
should be looking for so as you can see

590
00:25:16,740 --> 00:25:19,230
it returns the handler chain and there

591
00:25:19,230 --> 00:25:20,700
will only be one of such methods in that

592
00:25:20,700 --> 00:25:28,050
class so as you I wrote a Freda script

593
00:25:28,050 --> 00:25:30,600
and you for this script you have to

594
00:25:30,600 --> 00:25:32,370
modify the method name that you want to

595
00:25:32,370 --> 00:25:33,809
call because like I said that would be

596
00:25:33,809 --> 00:25:36,150
different for every build in this case

597
00:25:36,150 --> 00:25:37,679
we are calling the end method and we are

598
00:25:37,679 --> 00:25:41,809
telling it to listen on port 9 2 to 2

599
00:25:46,930 --> 00:25:49,460
so the free descrip actually runs the

600
00:25:49,460 --> 00:25:51,050
debugger on port 92 do

601
00:25:51,050 --> 00:25:53,390
however the problem I found was that I

602
00:25:53,390 --> 00:25:54,740
was still unable to connect to it using

603
00:25:54,740 --> 00:25:57,560
chrome dev dues because like I mentioned

604
00:25:57,560 --> 00:25:59,450
earlier the newer versions of chrome dev

605
00:25:59,450 --> 00:26:02,090
tools uses the new inspector API instead

606
00:26:02,090 --> 00:26:06,980
of the old liebe API so when the couny

607
00:26:06,980 --> 00:26:09,020
IDE actually launches this process they

608
00:26:09,020 --> 00:26:10,880
probably have some corn in place to

609
00:26:10,880 --> 00:26:13,730
bridge between the two different API so

610
00:26:13,730 --> 00:26:16,790
I initially when I first ran across this

611
00:26:16,790 --> 00:26:18,290
problem I thought that I have to

612
00:26:18,290 --> 00:26:20,870
implement that bridge myself but what I

613
00:26:20,870 --> 00:26:22,730
found was the visual Studios code

614
00:26:22,730 --> 00:26:23,570
debugger

615
00:26:23,570 --> 00:26:26,450
actually supports the OL debugging

616
00:26:26,450 --> 00:26:28,550
protocol which is most likely because

617
00:26:28,550 --> 00:26:30,620
they want the ability to debug older

618
00:26:30,620 --> 00:26:33,410
versions of not GS and this saves us the

619
00:26:33,410 --> 00:26:36,830
work of implementing the bridge and we

620
00:26:36,830 --> 00:26:38,360
can configure it be just to do Scotney

621
00:26:38,360 --> 00:26:41,090
bugger to use the legacy protocol using

622
00:26:41,090 --> 00:26:43,790
a launch dot JSON config file so

623
00:26:43,790 --> 00:26:46,340
something like this and what you can see

624
00:26:46,340 --> 00:26:48,050
is that I'm telling the visual studio

625
00:26:48,050 --> 00:26:50,930
debugger that I want to connect to pot

626
00:26:50,930 --> 00:26:56,380
92 too and use the legacy protocol and

627
00:26:56,380 --> 00:26:59,540
once the debugger connects you will see

628
00:26:59,540 --> 00:27:01,130
something like this in your V just your

629
00:27:01,130 --> 00:27:12,830
code which I will show a demo of now so

630
00:27:12,830 --> 00:27:14,420
the first thing that we need to do is we

631
00:27:14,420 --> 00:27:16,670
need to repackage the apk file with the

632
00:27:16,670 --> 00:27:20,360
char library and I wrote a patch debug

633
00:27:20,360 --> 00:27:23,750
script to do that and it takes in the

634
00:27:23,750 --> 00:27:27,350
apk file the library the debug version

635
00:27:27,350 --> 00:27:29,780
of the share library and the name of the

636
00:27:29,780 --> 00:27:31,460
output apk file that you want to write

637
00:27:31,460 --> 00:27:34,940
to so I'm writing to a file called

638
00:27:34,940 --> 00:27:36,800
apk and you will take a while to run

639
00:27:36,800 --> 00:27:38,420
because you are repackaging the entire

640
00:27:38,420 --> 00:27:41,540
application and once you free package it

641
00:27:41,540 --> 00:27:43,550
you ready to sign it to run it on actual

642
00:27:43,550 --> 00:27:52,460
Android device so now I will install the

643
00:27:52,460 --> 00:27:55,670
new apk dive created into my Android

644
00:27:55,670 --> 00:27:57,700
device

645
00:28:05,179 --> 00:28:07,950
right so once we've installed the

646
00:28:07,950 --> 00:28:09,390
application we can ensure that it

647
00:28:09,390 --> 00:28:17,309
actually runs properly so yeah yeah so

648
00:28:17,309 --> 00:28:19,250
the application is now all running so

649
00:28:19,250 --> 00:28:22,260
the next thing I'll do is I will use my

650
00:28:22,260 --> 00:28:31,110
Freda script to activate a debugger once

651
00:28:31,110 --> 00:28:32,610
that script runs you will notice that

652
00:28:32,610 --> 00:28:34,140
the application will pop up a message

653
00:28:34,140 --> 00:28:35,880
saying that waiting for debugger to

654
00:28:35,880 --> 00:28:42,000
connect right so now the application is

655
00:28:42,000 --> 00:28:45,650
waiting for a debugger to connect to it

656
00:28:47,300 --> 00:28:49,860
so the next thing that you need to do is

657
00:28:49,860 --> 00:28:52,050
you need to put forward the listening

658
00:28:52,050 --> 00:28:53,910
part from the mobile device to your host

659
00:28:53,910 --> 00:28:57,030
machine and you can do that using ADB

660
00:28:57,030 --> 00:29:01,970
forward which is what I'll be doing now

661
00:29:01,970 --> 00:29:04,860
so I'm port forwarding nine point nine

662
00:29:04,860 --> 00:29:06,809
two two two on my mobile device to my

663
00:29:06,809 --> 00:29:11,190
into two two on my host machine and when

664
00:29:11,190 --> 00:29:15,059
I click debug button I am connected to

665
00:29:15,059 --> 00:29:20,730
the Android application so you see that

666
00:29:20,730 --> 00:29:22,440
the message is now gone and you can use

667
00:29:22,440 --> 00:29:25,860
the application like normally so with a

668
00:29:25,860 --> 00:29:27,600
runtime debugger you can do things like

669
00:29:27,600 --> 00:29:29,490
of course you can look at the source

670
00:29:29,490 --> 00:29:30,690
code of the application when it's

671
00:29:30,690 --> 00:29:33,270
running you can have capabilities like

672
00:29:33,270 --> 00:29:37,380
attaching breakpoints to look places in

673
00:29:37,380 --> 00:29:40,890
the code that you're interested in so

674
00:29:40,890 --> 00:29:42,150
I'm setting a breakpoint on that

675
00:29:42,150 --> 00:29:45,990
particular line you can actually tell

676
00:29:45,990 --> 00:29:47,370
the debugger that you are interested in

677
00:29:47,370 --> 00:29:48,720
certain variables and you wanna monitor

678
00:29:48,720 --> 00:29:54,179
what values they have yeah and you can

679
00:29:54,179 --> 00:29:56,700
even modify what a function is doing so

680
00:29:56,700 --> 00:29:58,440
if you want to catch out certain

681
00:29:58,440 --> 00:30:00,960
security check so you want to bypass for

682
00:30:00,960 --> 00:30:03,059
example SSL pinning you can just edit

683
00:30:03,059 --> 00:30:04,650
the function when it's in the

684
00:30:04,650 --> 00:30:07,160
application

685
00:30:08,440 --> 00:30:11,860
all right so everything I've shown up to

686
00:30:11,860 --> 00:30:14,710
now is for Android so that's of course

687
00:30:14,710 --> 00:30:16,060
in our platform that we are interested

688
00:30:16,060 --> 00:30:20,260
in which is iOS and for iOS I did not

689
00:30:20,260 --> 00:30:21,340
want to have to reverse engineer

690
00:30:21,340 --> 00:30:24,010
everything from scratch so my logical

691
00:30:24,010 --> 00:30:25,120
assumption was that the implementation

692
00:30:25,120 --> 00:30:27,220
should be very similar to what Android

693
00:30:27,220 --> 00:30:29,680
is using so I started looking for

694
00:30:29,680 --> 00:30:31,720
references to cryptographic functions in

695
00:30:31,720 --> 00:30:34,000
the Emeco binary and what I found was

696
00:30:34,000 --> 00:30:36,280
that there were several references to

697
00:30:36,280 --> 00:30:39,670
the common crypto family of CC crypto

698
00:30:39,670 --> 00:30:41,980
functions for those of you unfamiliar

699
00:30:41,980 --> 00:30:44,650
with Mac OS or iOS programming common

700
00:30:44,650 --> 00:30:46,660
crypto is Apple's standard library for

701
00:30:46,660 --> 00:30:51,670
cryptography and after I started doing

702
00:30:51,670 --> 00:30:52,930
some tracing and debugging on the

703
00:30:52,930 --> 00:30:55,870
application I found the secret familiar

704
00:30:55,870 --> 00:30:57,130
functions were called when the

705
00:30:57,130 --> 00:30:59,530
application starts up which is a very

706
00:30:59,530 --> 00:31:01,030
strong indication that there is actually

707
00:31:01,030 --> 00:31:05,410
the method used for decryption so

708
00:31:05,410 --> 00:31:07,720
similar to what enjoy is using the

709
00:31:07,720 --> 00:31:09,460
JavaScript source code is encrypted with

710
00:31:09,460 --> 00:31:12,820
AES 256 in CBC mode but the difference

711
00:31:12,820 --> 00:31:14,530
is that the ivy appears to be different

712
00:31:14,530 --> 00:31:17,080
for every application so on Android you

713
00:31:17,080 --> 00:31:20,020
have this static ABCD 1 2 3 4 so on Ivy

714
00:31:20,020 --> 00:31:22,960
but for iOS the Ivy is different for

715
00:31:22,960 --> 00:31:25,120
every application so what we need to do

716
00:31:25,120 --> 00:31:26,860
is we need to pull out the Ivy alongside

717
00:31:26,860 --> 00:31:28,780
the key when we are doing it with Frieda

718
00:31:28,780 --> 00:31:32,890
and we can write a free transcript to

719
00:31:32,890 --> 00:31:35,290
hook CC crypto create that particular

720
00:31:35,290 --> 00:31:37,900
function and extract the key and Ivy

721
00:31:37,900 --> 00:31:40,480
from the function arguments so this is

722
00:31:40,480 --> 00:31:42,730
the function definition from a post

723
00:31:42,730 --> 00:31:45,250
documentation and you can see where the

724
00:31:45,250 --> 00:31:49,780
key and Ivy parameters are so like my

725
00:31:49,780 --> 00:31:50,710
Android implementation

726
00:31:50,710 --> 00:31:54,460
I wrote a Freda script for iOS on the

727
00:31:54,460 --> 00:31:56,920
first line I highlighted I am attaching

728
00:31:56,920 --> 00:32:00,880
to the C secret function in the second

729
00:32:00,880 --> 00:32:03,750
line I'm extracting the Ivy from the

730
00:32:03,750 --> 00:32:07,420
fourth parameter and in the third line

731
00:32:07,420 --> 00:32:13,120
I'm extracting the key so just the demo

732
00:32:13,120 --> 00:32:16,280
[Music]

733
00:32:17,990 --> 00:32:20,760
so the scrip is actually exactly the

734
00:32:20,760 --> 00:32:23,550
same function parameters arguments as

735
00:32:23,550 --> 00:32:26,160
the Android version it takes the IPA

736
00:32:26,160 --> 00:32:28,800
file the name of the package name of the

737
00:32:28,800 --> 00:32:31,020
application and the output directory

738
00:32:31,020 --> 00:32:33,680
that you want to write the results into

739
00:32:33,680 --> 00:32:40,620
so I am running the script now and you

740
00:32:40,620 --> 00:32:42,450
can see that our yeah I've extracted the

741
00:32:42,450 --> 00:32:45,060
ID energy from your application and if I

742
00:32:45,060 --> 00:32:46,770
look at the J's files directory there

743
00:32:46,770 --> 00:32:49,260
will be a single zip file that contains

744
00:32:49,260 --> 00:32:51,720
the application source code of the cipa

745
00:32:51,720 --> 00:32:55,680
file if you unzip it you will see a

746
00:32:55,680 --> 00:32:59,460
bunch of JavaScript code and if we open

747
00:32:59,460 --> 00:33:03,710
one of the files you'll be in clear text

748
00:33:06,120 --> 00:33:09,540
[Music]

749
00:33:18,830 --> 00:33:21,840
so for the debugger situation I was not

750
00:33:21,840 --> 00:33:23,610
able to come up with a working debugger

751
00:33:23,610 --> 00:33:27,060
for iOS because iOS I'm sorry yeah Kunie

752
00:33:27,060 --> 00:33:29,670
on iOS uses the JavaScript core engine

753
00:33:29,670 --> 00:33:32,850
instead of the v8 engine so I couldn't

754
00:33:32,850 --> 00:33:34,590
quite figure out how to get a debugger

755
00:33:34,590 --> 00:33:36,660
working however I figured this was

756
00:33:36,660 --> 00:33:38,720
actually good enough for most situations

757
00:33:38,720 --> 00:33:41,280
because the application logic should be

758
00:33:41,280 --> 00:33:43,020
exactly the same as the Android

759
00:33:43,020 --> 00:33:45,120
application because the promise of

760
00:33:45,120 --> 00:33:46,830
cooling is the single codebase you can

761
00:33:46,830 --> 00:33:49,020
generate the same app for multiple

762
00:33:49,020 --> 00:33:50,180
platforms

763
00:33:50,180 --> 00:33:53,430
so aside from some may be some platform

764
00:33:53,430 --> 00:33:56,610
specific interactions like biometrics

765
00:33:56,610 --> 00:33:58,890
for example the application logic should

766
00:33:58,890 --> 00:34:00,540
be exactly the same between native app

767
00:34:00,540 --> 00:34:03,560
to applications

768
00:34:03,920 --> 00:34:09,120
so in conclusion we've covered the Coney

769
00:34:09,120 --> 00:34:11,400
mobile application startup process we've

770
00:34:11,400 --> 00:34:13,380
shown how to extract application source

771
00:34:13,380 --> 00:34:15,659
code from your apk file or your IPA file

772
00:34:15,659 --> 00:34:18,239
and we've shown how to debug a Kali

773
00:34:18,239 --> 00:34:21,449
Android application all the scripts I've

774
00:34:21,449 --> 00:34:23,610
shown today are available on github so

775
00:34:23,610 --> 00:34:25,650
if you are actually doing analysis on

776
00:34:25,650 --> 00:34:27,310
Coney you can just

777
00:34:27,310 --> 00:34:29,918
the Android debugger script does not

778
00:34:29,918 --> 00:34:32,679
ship with the required version of a look

779
00:34:32,679 --> 00:34:35,440
the lip congest VM shell library you

780
00:34:35,440 --> 00:34:37,000
have to extract that from the Installer

781
00:34:37,000 --> 00:34:38,980
yourself but you can just download the

782
00:34:38,980 --> 00:34:43,449
Installer from Kony's website and just a

783
00:34:43,449 --> 00:34:45,070
few random parts to close out the

784
00:34:45,070 --> 00:34:47,080
presentation there are a lot of new

785
00:34:47,080 --> 00:34:49,179
mobile frameworks coming up that's not

786
00:34:49,179 --> 00:34:50,290
using your native development

787
00:34:50,290 --> 00:34:52,389
environments so you have things like

788
00:34:52,389 --> 00:34:54,100
I've actually Cordova or react native

789
00:34:54,100 --> 00:34:58,200
and your standard application analysis

790
00:34:58,200 --> 00:35:00,670
method or tooling will probably not work

791
00:35:00,670 --> 00:35:03,730
on those frameworks so you tooling needs

792
00:35:03,730 --> 00:35:05,590
to be written to keep up with changes in

793
00:35:05,590 --> 00:35:08,830
the different environments and if you're

794
00:35:08,830 --> 00:35:11,580
looking at mobile applications it's

795
00:35:11,580 --> 00:35:13,780
useful to have very basic reverse

796
00:35:13,780 --> 00:35:16,090
engineering skills especially for

797
00:35:16,090 --> 00:35:17,470
Android if you're looking at native

798
00:35:17,470 --> 00:35:20,170
functions or iOS your entire application

799
00:35:20,170 --> 00:35:25,570
it's actually just a macro binary so yep

800
00:35:25,570 --> 00:35:27,610
the github link for where the scripts

801
00:35:27,610 --> 00:35:40,060
can be found and questions yes

802
00:35:40,060 --> 00:35:43,450
so the avene the Android app was static

803
00:35:43,450 --> 00:35:46,720
right yes but was it dynamic in the iOS

804
00:35:46,720 --> 00:35:49,240
version looked like dynamic so it's on

805
00:35:49,240 --> 00:35:51,970
it's still stepping in a sense that the

806
00:35:51,970 --> 00:35:53,890
application has the same IP each time

807
00:35:53,890 --> 00:35:56,890
but it's different for every view of a

808
00:35:56,890 --> 00:35:59,110
iOS application so if you're analyzing

809
00:35:59,110 --> 00:36:01,030
two different iOS apps the IV will be

810
00:36:01,030 --> 00:36:03,070
different for the iOS but not for its

811
00:36:03,070 --> 00:36:04,690
Android that yes so for Android

812
00:36:04,690 --> 00:36:06,010
depending on the version they are either

813
00:36:06,010 --> 00:36:10,170
happy old zeros on the ABCD IP

