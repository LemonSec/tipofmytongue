1
00:00:08,320 --> 00:00:10,380
- So welcome to this presentation.

2
00:00:10,380 --> 00:00:11,940
My name is Tjerand Slide

3
00:00:11,940 --> 00:00:13,040
I'm a PhD student

4
00:00:13,040 --> 00:00:16,250
at the Norwegian University
of Science and Technology.

5
00:00:16,250 --> 00:00:17,540
I'm going to present the paper,

6
00:00:17,540 --> 00:00:19,040
Lattice-Based prove of Shuffle

7
00:00:19,040 --> 00:00:20,939
and Applications to Electronic Voting.

8
00:00:22,320 --> 00:00:24,810
This is a joint work
with Diego and Carsten

9
00:00:24,810 --> 00:00:27,913
at Aarhus University and
Kristian and Thor at NTNU.

10
00:00:30,110 --> 00:00:31,910
So in this talk I'm going to give

11
00:00:31,910 --> 00:00:35,760
you a short overview of the
main constructions in our paper.

12
00:00:35,760 --> 00:00:38,830
I'm going to talk about the
primitives that we used.

13
00:00:38,830 --> 00:00:40,870
I'm going to describe the shuffle protocol

14
00:00:40,870 --> 00:00:44,440
and some details about what we do

15
00:00:44,440 --> 00:00:46,330
and how we use the shuffle protocol

16
00:00:46,330 --> 00:00:49,699
to create a voting system combining

17
00:00:49,700 --> 00:00:52,610
it to a preferred voting system.

18
00:00:52,610 --> 00:00:55,220
Finally, I'm going to give
you performance number

19
00:00:55,220 --> 00:00:57,873
of the implementation of this system.

20
00:00:59,830 --> 00:01:01,589
For this talk I want
you to have the picture

21
00:01:01,590 --> 00:01:03,490
on the right side in mind.

22
00:01:03,490 --> 00:01:08,220
So in the voting system we have users, UI.

23
00:01:08,220 --> 00:01:10,883
They submit the votes to a ballot box.

24
00:01:12,020 --> 00:01:13,450
When the election is over,

25
00:01:13,450 --> 00:01:16,760
the ballot box just takes
all votes he received

26
00:01:16,760 --> 00:01:20,610
from all the voters, strip
information from it and send it

27
00:01:20,610 --> 00:01:24,550
to shuffle decryption server

28
00:01:24,550 --> 00:01:27,230
that then decrypt all the votes,

29
00:01:27,230 --> 00:01:31,110
shuffle them and output the print exports.

30
00:01:31,110 --> 00:01:33,090
And it also output a prove of shuttle

31
00:01:33,090 --> 00:01:36,620
to make sure that everything
is being done correctly.

32
00:01:36,620 --> 00:01:39,330
For example, that the shuffle
server did not replace any

33
00:01:39,330 --> 00:01:40,703
of the votes by his choice.

34
00:01:42,240 --> 00:01:44,920
Finally, there's is going
to be an election authority

35
00:01:44,920 --> 00:01:47,930
that will make sure that
there's consistency between

36
00:01:47,930 --> 00:01:50,970
what the ballot box sees
and the shuffled server sees

37
00:01:50,970 --> 00:01:52,970
and make sure that the prove is correct.

38
00:01:56,790 --> 00:01:58,090
So to give you an overview over

39
00:01:58,090 --> 00:02:00,900
the contributions of the paper,

40
00:02:00,900 --> 00:02:03,480
we present the first
practical verifiable shuffle

41
00:02:03,480 --> 00:02:07,150
of known content and it's based
on lattice based primitives

42
00:02:07,150 --> 00:02:09,133
to ensure the longterm privacy.

43
00:02:10,070 --> 00:02:12,440
It follow on the exist
certain verifiable shuffles

44
00:02:12,440 --> 00:02:16,120
in the literature but most of
them are based on assumptions

45
00:02:16,120 --> 00:02:18,490
like the discrete log problem

46
00:02:18,490 --> 00:02:20,990
that are not secure against
the quantum adversely.

47
00:02:21,890 --> 00:02:25,630
So to make sure that we
have long-term privacy

48
00:02:25,630 --> 00:02:28,750
in the system, for example,
for electronic voting

49
00:02:28,750 --> 00:02:30,250
we want to be made...

50
00:02:30,250 --> 00:02:32,250
We use this use primitives

51
00:02:32,250 --> 00:02:34,350
that are secure against quantum computers.

52
00:02:36,430 --> 00:02:39,900
So we construct this
shuffle and we combine this

53
00:02:39,900 --> 00:02:41,770
with lattice based verifiable encryption

54
00:02:41,770 --> 00:02:44,290
to get an electronic voting system.

55
00:02:44,290 --> 00:02:46,980
We also return using a
return code mechanism

56
00:02:46,980 --> 00:02:50,910
for voter verifiability in
case the voter doesn't trust

57
00:02:50,910 --> 00:02:54,243
that the computer
encrypted the correct vote.

58
00:02:55,360 --> 00:02:57,120
And finally we implement this

59
00:02:57,120 --> 00:03:01,520
and we give you performance
numbers for size and timings.

60
00:03:01,520 --> 00:03:02,920
It's worth mentioning that

61
00:03:02,920 --> 00:03:06,450
we proved this construction
secure into Random Oracle Model

62
00:03:06,450 --> 00:03:08,920
but not the Quantum Random Oracle Model.

63
00:03:08,920 --> 00:03:12,459
So the longterm privacy security

64
00:03:12,460 --> 00:03:15,120
is against the quantum
computer that gets hold

65
00:03:15,120 --> 00:03:17,870
of the transcript of the shuffle

66
00:03:17,870 --> 00:03:20,913
but not necessarily
against the quantum prover.

67
00:03:25,070 --> 00:03:29,250
The primitives we use are
Lattice-based commitments

68
00:03:29,250 --> 00:03:32,510
with zero-knowledge proves
of linear relations.

69
00:03:32,510 --> 00:03:35,570
And we combine this with
Lattice-based verifiable encryption

70
00:03:35,570 --> 00:03:36,769
and the boarding scheme.

71
00:03:38,240 --> 00:03:40,240
In particular you use
the commitment scheme

72
00:03:40,240 --> 00:03:44,630
by Baum et al. from SCN 2018.

73
00:03:44,630 --> 00:03:48,150
And the commitment scheme also

74
00:03:48,150 --> 00:03:50,303
have very efficient zero-knowledge proves.

75
00:03:51,550 --> 00:03:54,111
Then we're going to adapt the
verifiable encryption scheme

76
00:03:54,111 --> 00:03:57,660
by Lyubashevsky and
Neven from Encrypt 2017

77
00:03:57,660 --> 00:04:00,220
and encrypt openings of the commitments.

78
00:04:00,220 --> 00:04:03,660
So when we prove that we have
encrypted something correctly,

79
00:04:03,660 --> 00:04:08,100
we proved that the Pantex
is actually the opening.

80
00:04:08,100 --> 00:04:08,933
That is the message

81
00:04:08,933 --> 00:04:11,507
and the randomness used
in the commitment scheme.

82
00:04:14,350 --> 00:04:17,769
So the shuffle protocol,
here we have two sets.

83
00:04:19,410 --> 00:04:22,237
One set of messages and
one set of commitments.

84
00:04:22,237 --> 00:04:24,170
And what we want to prove is that

85
00:04:25,167 --> 00:04:27,200
the set of messages is equal

86
00:04:27,200 --> 00:04:29,960
to a permutation of the
openings of the commitments.

87
00:04:29,960 --> 00:04:32,722
We're going to call this permutation PI.

88
00:04:33,570 --> 00:04:35,343
So given these two sets, we want to prove

89
00:04:35,343 --> 00:04:38,570
that the sets are the same
just in a different order.

90
00:04:38,570 --> 00:04:40,670
This is the relation are shuffled

91
00:04:40,670 --> 00:04:44,210
but the bitterness is the
permutation part is the openings

92
00:04:44,210 --> 00:04:47,219
to the commitment, Mi and Ri,

93
00:04:47,220 --> 00:04:49,530
and we want to prove for all of them

94
00:04:49,530 --> 00:04:54,530
that when we open at commuted
set of the commitments

95
00:04:54,710 --> 00:04:58,923
with Mi and Ri this is a valid
opening of the commitments.

96
00:05:01,187 --> 00:05:03,230
So the main idea for the construction

97
00:05:03,230 --> 00:05:07,150
is from Neff at CCS 2001

98
00:05:07,150 --> 00:05:09,950
where he created a verifiable
shuffle based on that,

99
00:05:09,950 --> 00:05:11,640
the fact that polynomials are stable

100
00:05:11,640 --> 00:05:14,490
and the permutation of their roots.

101
00:05:14,490 --> 00:05:17,270
So to connect this to the votes

102
00:05:17,270 --> 00:05:19,680
if you have one whole set
of messages and one set

103
00:05:19,680 --> 00:05:21,360
of commitments and different

104
00:05:21,360 --> 00:05:22,660
where the messages are commuted.

105
00:05:22,660 --> 00:05:25,190
Again, we use those to
create two polynomials

106
00:05:26,074 --> 00:05:27,240
and then we can...

107
00:05:27,240 --> 00:05:29,420
Then those polynomials should be the same

108
00:05:29,420 --> 00:05:30,943
if the messages are the same.

109
00:05:32,260 --> 00:05:35,120
So we're going to the
Schwartz-Zippel Lemma to do this

110
00:05:35,120 --> 00:05:37,130
to prove that they're equal.

111
00:05:37,130 --> 00:05:39,300
Lemma, says two different
polynomials differs

112
00:05:39,300 --> 00:05:40,640
with overwhelming probability

113
00:05:40,640 --> 00:05:42,323
when evaluated in a random point.

114
00:05:43,410 --> 00:05:46,060
So then the protocol
will be that we commit

115
00:05:46,060 --> 00:05:47,910
to many randomly linear combinations

116
00:05:47,910 --> 00:05:51,070
of commitments and
messages that we could use

117
00:05:51,070 --> 00:05:53,603
this to create two large polynomials.

118
00:05:54,690 --> 00:05:56,810
We're gonna evaluate
them by random challenge

119
00:05:56,810 --> 00:06:00,210
we get from the verifier and
then we're going to prove

120
00:06:00,210 --> 00:06:02,330
that those are equal.

121
00:06:02,330 --> 00:06:04,440
And in discrete log settings,

122
00:06:04,440 --> 00:06:07,410
you can often prove
linear relations directly

123
00:06:07,410 --> 00:06:08,980
but the Lattice-space setting we need

124
00:06:08,980 --> 00:06:10,630
to prove this in zero knowledge.

125
00:06:10,630 --> 00:06:12,310
So we need to use the
zero knowledge approach

126
00:06:12,310 --> 00:06:14,440
of linear relations to put that each one

127
00:06:14,440 --> 00:06:19,090
of these equations equal, which then means

128
00:06:19,090 --> 00:06:21,383
that the two polynomials are equal.

129
00:06:24,680 --> 00:06:29,210
So for the voting system
we have several players.

130
00:06:29,210 --> 00:06:31,799
We got the user, ballot
box, shuffle server,

131
00:06:31,800 --> 00:06:34,220
and election authorities.

132
00:06:34,220 --> 00:06:37,130
The users they commit
and encrypt their ballot.

133
00:06:37,130 --> 00:06:38,570
The reason why they need to do both

134
00:06:38,570 --> 00:06:40,880
is because the shuffle
server needs commitments

135
00:06:40,880 --> 00:06:44,147
to prove correct shuffle,
but will need the openings

136
00:06:44,147 --> 00:06:46,860
of the commitments to be able to do that.

137
00:06:46,860 --> 00:06:48,440
We encrypt the openings

138
00:06:48,440 --> 00:06:50,637
and send them together with the count.

139
00:06:50,637 --> 00:06:54,200
The user also need to put
correctness so that the...

140
00:06:54,200 --> 00:06:58,658
Encryption actually is an
opening of the commitment.

141
00:06:58,658 --> 00:07:02,180
Then some information is
then sent to the ballot box,

142
00:07:02,180 --> 00:07:06,020
the ballot box then receive
votes, check the proves,

143
00:07:06,020 --> 00:07:08,590
and strip information like identities

144
00:07:08,590 --> 00:07:10,539
and signatures that was used

145
00:07:10,540 --> 00:07:12,370
to make sure that everything is correct

146
00:07:12,370 --> 00:07:13,620
and then send only the encryptions

147
00:07:13,620 --> 00:07:16,757
and the commitments to the shuffle server.

148
00:07:18,090 --> 00:07:21,705
The shuffle server then receive
all the encrypted votes.

149
00:07:21,706 --> 00:07:25,280
It decrypts all the subtext

150
00:07:25,280 --> 00:07:28,669
and then publish the ballots
in a different order.

151
00:07:28,670 --> 00:07:31,443
Finally, it gives prove that this shuffle

152
00:07:31,443 --> 00:07:33,026
was done correctly.

153
00:07:34,030 --> 00:07:36,840
The election authority ensure
that everything went well,

154
00:07:36,840 --> 00:07:38,570
that the views of the ballot box

155
00:07:38,570 --> 00:07:40,380
and the shuffle server are consistent

156
00:07:40,380 --> 00:07:41,930
and that the prove are correct.

157
00:07:43,620 --> 00:07:45,390
We also have a return
mechanism code mechanism

158
00:07:45,390 --> 00:07:49,360
so that the voter is ensured that his vote

159
00:07:49,360 --> 00:07:51,200
was received properly.

160
00:07:51,200 --> 00:07:54,060
That is that the computer did
not encrypt a different vote

161
00:07:54,060 --> 00:07:55,870
than what the voter wanted.

162
00:07:55,870 --> 00:07:57,370
Then he gets a return code

163
00:07:57,370 --> 00:08:01,010
and he can check that the
return code is consistent

164
00:08:01,010 --> 00:08:02,810
with the vote that he had submitted.

165
00:08:04,990 --> 00:08:07,470
So for the voting system we care about

166
00:08:07,470 --> 00:08:09,570
the integrity and privacy.

167
00:08:09,570 --> 00:08:12,190
And the integrity follow from
the zero-knowledge proves.

168
00:08:12,190 --> 00:08:15,038
So even if different players collude,

169
00:08:15,038 --> 00:08:17,460
the integrity is still insured

170
00:08:17,460 --> 00:08:19,793
because they can not cheat in the proves.

171
00:08:20,900 --> 00:08:24,631
For ballot privacy, we
need that the ballot box

172
00:08:24,631 --> 00:08:27,030
and the shuttle server does not collude.

173
00:08:27,030 --> 00:08:32,030
So if the votes are public
and the commitments are public

174
00:08:32,090 --> 00:08:35,270
we need that the permutation
and a whole server secure,

175
00:08:35,270 --> 00:08:37,669
or otherwise you connect the votes

176
00:08:37,669 --> 00:08:39,939
to the commitments of the votes

177
00:08:39,940 --> 00:08:41,493
and hence also to the voter.

178
00:08:42,590 --> 00:08:45,140
So we need the ballot box
and the shuffle server

179
00:08:45,140 --> 00:08:46,793
to not share the permutation.

180
00:08:48,130 --> 00:08:49,820
Finally, we get voter verifiability

181
00:08:49,820 --> 00:08:53,910
from the return code mechanism
so we can get and make sure

182
00:08:53,910 --> 00:08:56,113
that the correct vote was counted.

183
00:08:58,420 --> 00:09:00,270
Finally, for performance,

184
00:09:00,270 --> 00:09:02,910
we will work over the
cyclotomic ring, Rq,`

185
00:09:02,910 --> 00:09:05,230
here N is the power of two.

186
00:09:05,230 --> 00:09:07,930
In this case we're going to choose 1024

187
00:09:07,930 --> 00:09:10,900
and q is a 32 bit prime or modulo 4.

188
00:09:13,420 --> 00:09:16,250
The shuffle prove itself it
consists of one commitment,

189
00:09:16,250 --> 00:09:18,700
one ring element and
one zero-knowledge prove

190
00:09:18,700 --> 00:09:20,480
of linear relation.

191
00:09:20,480 --> 00:09:22,580
Decrypt choose a commitment scheme

192
00:09:22,580 --> 00:09:24,970
that is smaller than the one we use

193
00:09:24,970 --> 00:09:27,961
but this usually it's too
larger zero-knowledge prove

194
00:09:27,961 --> 00:09:30,180
and we need because we have one of each,

195
00:09:30,180 --> 00:09:31,793
the sub meltdown to be small.

196
00:09:33,200 --> 00:09:34,810
This also mean if others come up

197
00:09:34,810 --> 00:09:37,310
with more efficient zero-knowledge proves,

198
00:09:37,310 --> 00:09:40,002
this also directly makes
our shuffle more efficient.

199
00:09:41,880 --> 00:09:45,630
For a concrete timings, the
decryption plus the shuffle

200
00:09:45,630 --> 00:09:48,310
takes about 32 millisecond per vote

201
00:09:48,310 --> 00:09:51,209
and has size and 17 kilobytes per vote.

202
00:09:52,560 --> 00:09:54,280
When we compare to other systems,

203
00:09:54,280 --> 00:09:58,060
we are about five times faster
and at least 50% smaller

204
00:09:58,060 --> 00:10:01,257
than the voting system by
del Pino et al. from CSS 2017

205
00:10:04,360 --> 00:10:06,410
where we can handle operatory votes

206
00:10:06,410 --> 00:10:09,573
and they can only handle binary votes.

207
00:10:12,500 --> 00:10:15,390
So for those of you interested
in the details of the paper,

208
00:10:15,390 --> 00:10:17,540
we have a full version published eprint

209
00:10:17,540 --> 00:10:19,050
and I'm happy to take questions either

210
00:10:19,050 --> 00:10:21,890
by email or in the live
session at the conference.

211
00:10:21,890 --> 00:10:22,723
Thank you.

212
00:10:25,990 --> 00:10:27,020
- [Toomas] Hello.

213
00:10:27,020 --> 00:10:27,949
My name is Toomas Krip

214
00:10:27,950 --> 00:10:31,300
and I'm here to give a
presentation about our paper,

215
00:10:31,300 --> 00:10:32,930
More Efficient Shuffle Argument

216
00:10:32,930 --> 00:10:35,890
from Unix Factorization
by me and Helger Lipmaa.

217
00:10:35,890 --> 00:10:37,910
So the issue is the following.

218
00:10:37,910 --> 00:10:41,030
Assume that you have
a bunch of ciphertexts

219
00:10:41,030 --> 00:10:44,280
and you want to hide the
order before you decrypt them.

220
00:10:44,280 --> 00:10:46,780
For example, one national
point might be evil thing

221
00:10:46,780 --> 00:10:48,620
so you might know that...

222
00:10:48,620 --> 00:10:49,690
When people voted, you might know

223
00:10:49,690 --> 00:10:52,150
that this count is the first,
this count is second and so on

224
00:10:52,150 --> 00:10:53,600
and you might see when the votes come

225
00:10:53,600 --> 00:10:55,033
in to the voting center.

226
00:10:56,510 --> 00:10:58,240
Even if everything else is secure,

227
00:10:58,240 --> 00:11:03,010
if you just dig up the
votes, then you can see that

228
00:11:03,010 --> 00:11:05,500
the count of that first guy
who voted, voted for this guy

229
00:11:05,500 --> 00:11:07,309
and I know who the first
voter whoever it is

230
00:11:07,309 --> 00:11:09,850
so all the security goes out the window.

231
00:11:09,850 --> 00:11:14,330
So we need to shuffle around
our ciphertext a bit before...

232
00:11:14,330 --> 00:11:19,150
Of course for accountability
we should at least

233
00:11:19,150 --> 00:11:22,260
in some way be able to
see that original vector

234
00:11:22,260 --> 00:11:24,750
of ciphertext and the
permitted order of ciphertexts.

235
00:11:24,750 --> 00:11:27,820
So only permitting will not be useful

236
00:11:27,820 --> 00:11:29,730
because if we can do both of them,

237
00:11:29,730 --> 00:11:31,500
then it's kind of trivial to reverse

238
00:11:31,500 --> 00:11:33,490
the process and to be pointless.

239
00:11:33,490 --> 00:11:36,390
So we need to change this new
vectors of ciphertext a bit.

240
00:11:38,260 --> 00:11:39,403
One version of how to do it

241
00:11:39,403 --> 00:11:41,050
would be some kind of random permutation,

242
00:11:41,050 --> 00:11:44,300
so you could...

243
00:11:44,300 --> 00:11:47,089
If our encryption scheme is for morphic

244
00:11:47,090 --> 00:11:50,340
you could just add an encryption of zero

245
00:11:50,340 --> 00:11:53,240
or with some randomness
to all of the ciphertexts.

246
00:11:53,240 --> 00:11:55,333
Now all the new ciphertext look different

247
00:11:55,333 --> 00:11:56,890
on all of the old ones.

248
00:11:56,890 --> 00:11:59,720
So at least that's good.

249
00:11:59,720 --> 00:12:02,040
However, now we have this new problem

250
00:12:02,040 --> 00:12:04,469
that what if that shuffler is malicious?

251
00:12:04,470 --> 00:12:07,140
What if it then did
anything in the wrong way?

252
00:12:07,140 --> 00:12:09,437
So maybe it didn't add
an encryption field,

253
00:12:09,437 --> 00:12:11,600
it add an encryption of 1,000 or maybe

254
00:12:11,600 --> 00:12:13,587
it added just it's own ciphertext

255
00:12:13,587 --> 00:12:16,610
and it replaced all the previous ones.

256
00:12:16,610 --> 00:12:19,463
So we want to prevent
that and to prove that...

257
00:12:19,463 --> 00:12:21,670
The shuffler should somehow prove

258
00:12:21,670 --> 00:12:24,240
that he did everything correctly.

259
00:12:24,240 --> 00:12:27,223
So this is a classical
zero-knowledge prove.

260
00:12:29,045 --> 00:12:30,860
There's a proveer, there's a verifier,

261
00:12:30,860 --> 00:12:32,940
third is two vectors of ciphertexts

262
00:12:32,940 --> 00:12:36,037
and the prover needs the
convince the verifier

263
00:12:36,037 --> 00:12:38,040
that this second vector was obtained

264
00:12:38,040 --> 00:12:40,310
from the first vector by
applying the permutation

265
00:12:40,310 --> 00:12:42,949
and then applying some
rerandomization factors.

266
00:12:42,950 --> 00:12:47,950
And the verifier should
learn only whether the prover

267
00:12:48,020 --> 00:12:50,439
is lying or not and nothing else.

268
00:12:50,440 --> 00:12:52,940
So the verifier should
not learn, for example,

269
00:12:52,940 --> 00:12:55,780
that permutation or that
rerandomization factors

270
00:12:55,780 --> 00:12:57,040
or anything.

271
00:12:57,040 --> 00:12:59,230
Also note that, the proveer here doesn't

272
00:12:59,230 --> 00:13:02,840
have to know what's
inside those ciphertext.

273
00:13:02,840 --> 00:13:04,680
And if we use this in e-voting, of course,

274
00:13:04,680 --> 00:13:08,020
then we need to do this several
times because in this case

275
00:13:08,020 --> 00:13:11,680
this proveer knows the
permutation is a bit bad too.

276
00:13:11,680 --> 00:13:14,252
But that's not the topic of today's talk.

277
00:13:15,100 --> 00:13:18,833
So let's go to the scheme.

278
00:13:19,940 --> 00:13:24,813
So any other vision part
isn't that interesting

279
00:13:24,813 --> 00:13:28,030
and kind of just like have to keep intact

280
00:13:28,030 --> 00:13:29,742
that you use the correct
bookkeeping, so that...

281
00:13:29,743 --> 00:13:31,790
I mean, interesting, so we'll just ignore

282
00:13:31,790 --> 00:13:33,183
that for the stock.

283
00:13:34,520 --> 00:13:37,400
The interesting part
is the permutation part

284
00:13:38,530 --> 00:13:40,610
so if you are in computer science

285
00:13:40,610 --> 00:13:45,610
you will often depict permutation
with a permutation matrix.

286
00:13:45,910 --> 00:13:48,969
So this is kind of square
binary matrix or an entro

287
00:13:48,970 --> 00:13:51,110
and each column is precisely one, one

288
00:13:51,110 --> 00:13:53,030
or the other elements are the generals.

289
00:13:53,030 --> 00:13:56,260
And what you would do
if you are the prover

290
00:13:56,260 --> 00:13:58,620
is that you would take your metrics,

291
00:13:58,620 --> 00:14:01,850
you would encoat this in some way

292
00:14:01,850 --> 00:14:05,835
so that, that could send
this thing to the verifier

293
00:14:05,835 --> 00:14:07,470
and this thing that you included,

294
00:14:07,470 --> 00:14:09,150
it should hide the permutation

295
00:14:09,150 --> 00:14:12,163
but also it should be usable
in the next step of the prove.

296
00:14:13,130 --> 00:14:14,480
For example, in our case

297
00:14:15,847 --> 00:14:17,810
is there's a multi commitments to commit

298
00:14:17,810 --> 00:14:20,040
to the column vectors of the matrix.

299
00:14:20,040 --> 00:14:21,963
So the next step of the problems too

300
00:14:21,963 --> 00:14:24,430
is that it needs to convince the verifier.

301
00:14:24,430 --> 00:14:27,270
I think that's inside this encoding,

302
00:14:27,270 --> 00:14:28,569
it's this matrix that is inside,

303
00:14:28,570 --> 00:14:29,840
it actually is a permutation metrics

304
00:14:29,840 --> 00:14:34,840
not some other metrics
is that he needs to prove

305
00:14:35,113 --> 00:14:37,520
that M times the original
vector of ciphertext

306
00:14:37,520 --> 00:14:39,727
is equal to the new vector ciphertext

307
00:14:39,727 --> 00:14:42,036
or the rerandomization factor.

308
00:14:42,037 --> 00:14:45,080
So all contributions were mostly

309
00:14:45,080 --> 00:14:47,197
to that second step here and proving

310
00:14:47,197 --> 00:14:48,720
that M is a permutation matrix

311
00:14:48,720 --> 00:14:51,570
so I will talk on that also next time

312
00:14:51,570 --> 00:14:52,760
so I don't have just the time

313
00:14:52,760 --> 00:14:54,673
to talk about the other issues.

314
00:14:55,590 --> 00:14:57,930
So our approach built

315
00:14:57,930 --> 00:15:01,082
on this previous approach
called verificatum.

316
00:15:01,082 --> 00:15:03,550
In verificatum we have this result

317
00:15:03,550 --> 00:15:05,319
that M is a permutation matrix

318
00:15:05,320 --> 00:15:10,320
if first that preserves a unit vector,

319
00:15:10,500 --> 00:15:11,767
and second, which is...

320
00:15:11,767 --> 00:15:15,140
This is a bit more complicated statement

321
00:15:15,140 --> 00:15:16,780
to continue down the slide.

322
00:15:16,780 --> 00:15:20,939
So it's a statement in
this polynomial ring

323
00:15:20,940 --> 00:15:23,030
with many variables.

324
00:15:23,030 --> 00:15:25,579
It's identity of polynomials,

325
00:15:25,580 --> 00:15:29,840
so it states that if you
take the column vectors...

326
00:15:29,840 --> 00:15:32,500
If you take a column vector of the matrix

327
00:15:32,500 --> 00:15:34,040
and compute this kind of product

328
00:15:34,040 --> 00:15:36,740
with a vector of variables

329
00:15:36,740 --> 00:15:38,800
and you do this thing
for all the conductors

330
00:15:38,800 --> 00:15:41,400
and you multiply all the scalars there

331
00:15:41,400 --> 00:15:43,280
then this should be the same polynomial

332
00:15:43,280 --> 00:15:47,650
as when you would just multiply
all the variables together.

333
00:15:47,650 --> 00:15:51,060
So there's this equation of
equality of the polynomials

334
00:15:51,060 --> 00:15:53,739
and usually in this case it's when we need

335
00:15:53,740 --> 00:15:56,340
to show that this thing holds,

336
00:15:56,340 --> 00:15:58,970
we just evaluate it at
a randomly pick point.

337
00:15:58,970 --> 00:16:03,450
So the verifier should provide
this autonomy pick point

338
00:16:03,450 --> 00:16:07,780
so he sends N randomly
picked challenges, X1 to XN

339
00:16:07,780 --> 00:16:09,180
and now the prover should demonstrate

340
00:16:09,180 --> 00:16:11,829
that this thing holds
indeed at this random point

341
00:16:11,830 --> 00:16:14,263
that the verifier gave him.

342
00:16:16,230 --> 00:16:18,590
Unfortunately, I don't
have time right now to get

343
00:16:18,590 --> 00:16:20,610
into how the prover demonstrated

344
00:16:20,610 --> 00:16:22,053
this is kind of the...

345
00:16:23,130 --> 00:16:25,770
That exists primitive to this.

346
00:16:25,770 --> 00:16:28,680
Unfortunately don't have
time to get into it,

347
00:16:28,680 --> 00:16:30,500
but what I would like to
draw your attention to

348
00:16:30,500 --> 00:16:33,950
is that the verifier
needs to sent N challenges

349
00:16:33,950 --> 00:16:36,443
and this N can actually be
quite large in practice.

350
00:16:37,540 --> 00:16:41,490
So this N is equal to
the number of elements

351
00:16:41,490 --> 00:16:46,490
in our ciphertexts as well
the number of elements

352
00:16:46,590 --> 00:16:47,490
we want to shuffle

353
00:16:49,550 --> 00:16:51,359
and it might be let's say a million.

354
00:16:51,360 --> 00:16:53,380
So in that case the verifier I would have

355
00:16:53,380 --> 00:16:55,000
to send a million challenges

356
00:16:55,000 --> 00:16:56,160
and that's quite a big number.

357
00:16:56,160 --> 00:16:59,630
So if we could make this smaller

358
00:16:59,630 --> 00:17:01,110
then we could reduce
the communication costs

359
00:17:01,110 --> 00:17:02,750
so that would be nice.

360
00:17:02,750 --> 00:17:05,010
So what indeed we did is that we...

361
00:17:05,010 --> 00:17:07,500
In to these all contribution is

362
00:17:07,500 --> 00:17:11,619
that we introduced this new
mathematic concept called

363
00:17:11,619 --> 00:17:14,550
a family of PM-evidential polynomials

364
00:17:14,550 --> 00:17:17,579
which is a family of very
multivariate polynomials

365
00:17:17,579 --> 00:17:19,460
with special properties that I will define

366
00:17:19,460 --> 00:17:20,670
in the next slide

367
00:17:20,670 --> 00:17:23,609
but what sort of we want
from them, why they exist?

368
00:17:23,609 --> 00:17:25,919
Why did we introduce them?

369
00:17:25,920 --> 00:17:28,920
Is that we can replace those
Xi with those polynomial Phi i.

370
00:17:30,444 --> 00:17:32,090
So you can see that the theory is that

371
00:17:32,090 --> 00:17:34,800
we have restated the results
from the previous slide,

372
00:17:34,800 --> 00:17:38,270
but we have replaced all the older Xi

373
00:17:38,270 --> 00:17:40,320
with Phi i so that...

374
00:17:42,552 --> 00:17:45,062
In this equality of product.

375
00:17:47,539 --> 00:17:50,000
And if you think about it, then actually

376
00:17:50,000 --> 00:17:51,730
the result of the previous slide

377
00:17:51,730 --> 00:17:56,120
is actually a special case
of this result if you...

378
00:17:56,120 --> 00:17:58,156
Indeed if the family

379
00:17:58,156 --> 00:18:00,970
of polymnomials X1, X2, X3 until XN

380
00:18:00,970 --> 00:18:02,663
is also a family of
PM-evidential polynomials

381
00:18:02,663 --> 00:18:04,180
and if you use those

382
00:18:05,440 --> 00:18:09,330
then this is exactly the result
from that previous slide.

383
00:18:09,330 --> 00:18:11,580
So in a way, this is a generalization

384
00:18:11,580 --> 00:18:13,310
of the results from previous slide

385
00:18:13,310 --> 00:18:15,580
but it isn't just generalization

386
00:18:15,580 --> 00:18:17,840
for the sake of generalization.

387
00:18:17,840 --> 00:18:19,510
There are some benefits here

388
00:18:19,510 --> 00:18:21,810
and the main benefit is that here,

389
00:18:21,810 --> 00:18:26,560
these multivariate polynomials
may use much less variables.

390
00:18:26,560 --> 00:18:29,550
Well, if you step one
in the previous slides

391
00:18:29,550 --> 00:18:30,530
then it of course it doesn't

392
00:18:30,530 --> 00:18:32,660
but it's probably possible
to use if you pick

393
00:18:32,660 --> 00:18:36,380
them cleverly enough that you
can use much less variables.

394
00:18:36,380 --> 00:18:39,200
So they're very, very much have different

395
00:18:39,200 --> 00:18:40,237
like such challenges.

396
00:18:40,237 --> 00:18:41,930
And in our case, we managed

397
00:18:41,930 --> 00:18:45,630
to get it down to N equals two.

398
00:18:45,630 --> 00:18:47,790
N prime equals two so
that the verifier only

399
00:18:47,790 --> 00:18:49,290
has to send to two challenges.

400
00:18:50,340 --> 00:18:54,303
Also, another thing that
we did is that this quality

401
00:18:54,303 --> 00:18:58,720
of products at this point,
please I've skipped.

402
00:18:58,720 --> 00:19:03,720
We used a different previously
existing argument for that.

403
00:19:03,770 --> 00:19:04,780
So we used...

404
00:19:04,780 --> 00:19:06,830
There is something called
groths product argument

405
00:19:06,830 --> 00:19:11,040
and that what made things more efficient

406
00:19:11,040 --> 00:19:12,663
and save us, I think around.

407
00:19:13,840 --> 00:19:17,223
Okay, so what are these
PM evidential polynomials?

408
00:19:18,300 --> 00:19:21,350
So these are exactly the
polynomials that are needed

409
00:19:21,350 --> 00:19:24,110
for the result to hold
in the previous slides

410
00:19:24,110 --> 00:19:28,453
or they are like built
for this executor reason.

411
00:19:29,480 --> 00:19:31,916
So it must satisfy three properties

412
00:19:31,916 --> 00:19:32,800
of these family of polynomials.

413
00:19:32,800 --> 00:19:35,110
First, none of all those polynomials

414
00:19:35,110 --> 00:19:36,933
is allowed to be a zero polynomial.

415
00:19:37,910 --> 00:19:40,400
Secondly, if you take your product

416
00:19:40,400 --> 00:19:43,220
then no non-trivial combination

417
00:19:43,220 --> 00:19:45,570
of the Phi i is allowed
to divide the product,

418
00:19:45,570 --> 00:19:48,255
meaning that, for example, Phi i

419
00:19:48,256 --> 00:19:52,860
is allowed to divide for
example three times Phi one

420
00:19:52,860 --> 00:19:55,300
but it's not allowed to
divide three times Phi one

421
00:19:55,300 --> 00:19:58,610
plus four times Phi two, for example.

422
00:19:58,610 --> 00:20:03,560
And thirdly, no square of Phi i is allowed

423
00:20:03,560 --> 00:20:07,639
to divide the product or
the other of the properties.

424
00:20:07,640 --> 00:20:10,750
And on my task, okay, now we have defined

425
00:20:10,750 --> 00:20:13,570
these PM-evidential
that will actual exist.

426
00:20:13,570 --> 00:20:15,790
Well, one thing that we saw previous

427
00:20:15,790 --> 00:20:19,753
with these very simple family
X1, X2, X3 and so on to XN

428
00:20:22,290 --> 00:20:24,730
is a family of PM-evidential polynomials

429
00:20:24,730 --> 00:20:26,535
but that isn't really polynomial

430
00:20:26,535 --> 00:20:30,280
so to that it's just
actually any other families

431
00:20:31,160 --> 00:20:34,660
or we built this so that
we could use less variables

432
00:20:34,660 --> 00:20:36,460
and indeed that do.

433
00:20:36,460 --> 00:20:39,460
The family of polynomials Phi i

434
00:20:39,460 --> 00:20:44,460
is equal Phi i with variables X and Y

435
00:20:44,670 --> 00:20:46,060
is equal to X the power I

436
00:20:46,060 --> 00:20:49,530
plus Y and if you take
this family of polynomials,

437
00:20:49,530 --> 00:20:51,915
this is indeed PM evidential,
and so we consider

438
00:20:51,915 --> 00:20:54,387
this is a very simple
family of polynomials

439
00:20:54,387 --> 00:20:58,629
and very easy to compute and very nice.

440
00:20:58,630 --> 00:21:02,450
So what can we take away from this?

441
00:21:02,450 --> 00:21:07,450
So this idea is that if you
have some kind of setting

442
00:21:09,500 --> 00:21:12,620
or you have this large
number of random challenges

443
00:21:12,620 --> 00:21:15,689
that are needed then maybe
you can sort of compress

444
00:21:15,690 --> 00:21:16,850
those challenges in a way

445
00:21:16,850 --> 00:21:19,590
if you think of some kind of...

446
00:21:19,590 --> 00:21:22,659
Look at the algebra properties
of the underlying scheme,

447
00:21:22,660 --> 00:21:26,010
so maybe you can replace a
vector of N random challenges

448
00:21:26,010 --> 00:21:30,550
with some kind of a family
of multivariate polynomials

449
00:21:30,550 --> 00:21:34,480
and then you can have like
a number of challenges

450
00:21:34,480 --> 00:21:38,500
can be smaller maybe if
you can otherwise position.

451
00:21:38,500 --> 00:21:40,680
So this was our paper,

452
00:21:40,680 --> 00:21:42,283
so thank you for your attention.

453
00:21:46,870 --> 00:21:48,010
- [Giuseppe] Hello, everyone.

454
00:21:48,010 --> 00:21:49,810
I'm Giuseppe Vitto and this talk

455
00:21:49,810 --> 00:21:51,590
will be about Cryptanalysis

456
00:21:51,590 --> 00:21:55,120
of a Dynamic Universal
Accumulator over Bilinear Groups.

457
00:21:55,120 --> 00:21:58,622
A joint work with Alex
Biryukov and Aleksei Udovenko.

458
00:22:00,330 --> 00:22:02,543
Let's start with some definitions.

459
00:22:03,450 --> 00:22:06,820
An cryptographic accumulators
scheme allows segregation

460
00:22:06,820 --> 00:22:09,169
of many values in to short digest,

461
00:22:09,170 --> 00:22:10,893
cool and accumulated value.

462
00:22:11,830 --> 00:22:14,730
Despite those functions,
accumulative schemes,

463
00:22:14,730 --> 00:22:18,060
further allow to show whenever
an element is accumulated

464
00:22:18,060 --> 00:22:20,100
or not in the cumulative value.

465
00:22:20,100 --> 00:22:23,082
Thanks to special values called witnesses.

466
00:22:24,631 --> 00:22:27,210
And the accumulator is said to be dynamic

467
00:22:27,210 --> 00:22:31,440
if it supports both addition
and deletions of elements.

468
00:22:31,440 --> 00:22:35,800
While it is safe universal,
if it supports membership

469
00:22:35,800 --> 00:22:37,592
and non-members witnesses.

470
00:22:38,920 --> 00:22:40,900
The object of this talk will be

471
00:22:40,900 --> 00:22:42,770
the Dynamic Universal Accumulator

472
00:22:42,770 --> 00:22:47,123
by Au et al. publisher at CT-RSA in 2009.

473
00:22:49,150 --> 00:22:51,260
This accumulator is defined over

474
00:22:51,260 --> 00:22:54,010
a symmetric bilinear
group G of prime order

475
00:22:54,010 --> 00:22:55,363
and base point B.

476
00:22:56,670 --> 00:22:59,610
And this security relies on the secrecy

477
00:22:59,610 --> 00:23:01,540
of a random value and that is P,

478
00:23:01,540 --> 00:23:04,893
which we call the secret
accumulator parameter Alpha.

479
00:23:06,350 --> 00:23:08,600
Within this as top, the accumulator

480
00:23:08,600 --> 00:23:12,683
can then accumulate any
element Zp except minus Alpha.

481
00:23:14,610 --> 00:23:17,149
We say that some elements in ZP

482
00:23:17,150 --> 00:23:20,060
are accumulated into
the accumulative value V

483
00:23:20,060 --> 00:23:23,903
if the product shifted by
Alpha times P is equal to P.

484
00:23:25,340 --> 00:23:28,080
Due to it's simple polynomial definition

485
00:23:28,080 --> 00:23:30,649
we will denote the discrete
loca rate in base P

486
00:23:30,650 --> 00:23:34,780
of the cumulative value V as fv of Alpha.

487
00:23:34,780 --> 00:23:37,453
With fv a polynomial in Zp.

488
00:23:38,700 --> 00:23:40,450
Almost straightforwardly,

489
00:23:40,450 --> 00:23:44,100
addition and deletion operations follow

490
00:23:44,100 --> 00:23:46,290
from the accumulator definition

491
00:23:46,290 --> 00:23:49,070
and elements are added into or removed

492
00:23:49,070 --> 00:23:51,820
from the accumulator by simply multiplying

493
00:23:51,820 --> 00:23:53,760
or dividing the cumulative value

494
00:23:53,760 --> 00:23:57,083
by the scalars obtained
from shifting such elements.

495
00:23:58,810 --> 00:24:03,000
The last missing part is
how witnesses are computed.

496
00:24:03,000 --> 00:24:06,160
Au et al, described two possible ways,

497
00:24:06,160 --> 00:24:08,460
and we were refer to
them as the Alpha based

498
00:24:08,460 --> 00:24:10,603
and CRS-based construction.

499
00:24:12,170 --> 00:24:13,980
Let's start from the first one,

500
00:24:13,980 --> 00:24:15,663
the Alpha based construction.

501
00:24:17,400 --> 00:24:21,060
A witness for an element Y always consists

502
00:24:21,060 --> 00:24:26,060
of two values, analytical
C and the scalar D.

503
00:24:26,280 --> 00:24:31,220
For membership witnesses D is
set to zero and C is computed

504
00:24:31,220 --> 00:24:33,440
by multiplying the cumulative value

505
00:24:33,440 --> 00:24:35,613
by one over Y plus Alpha.

506
00:24:37,020 --> 00:24:40,740
Such membership witness
definition is shared among

507
00:24:40,740 --> 00:24:43,273
the Alpha and the CRS-based construction.

508
00:24:44,640 --> 00:24:46,802
The difference resize and set

509
00:24:46,802 --> 00:24:50,260
and the non-membership
witnesses are defined.

510
00:24:50,260 --> 00:24:52,290
In the Alpha-based construction,

511
00:24:52,290 --> 00:24:56,030
D is computed by reducing
fv of Alpha first

512
00:24:56,030 --> 00:24:59,149
by y plus Alpha and then by P.

513
00:24:59,150 --> 00:25:01,553
C is then computed accordingly.

514
00:25:02,690 --> 00:25:04,990
A membership or non membership witness

515
00:25:04,990 --> 00:25:07,370
is said to be valid with respect

516
00:25:07,370 --> 00:25:09,129
to the cumulative value V

517
00:25:09,130 --> 00:25:11,770
if it verifies such bilinear equation

518
00:25:11,770 --> 00:25:15,293
where we recall q is
equal to Alpha times P.

519
00:25:17,696 --> 00:25:20,379
The attack we are going
to describe explores

520
00:25:20,380 --> 00:25:23,040
the definition of D for
non-membership witnesses

521
00:25:23,040 --> 00:25:25,180
in the Alpha-based construction

522
00:25:25,180 --> 00:25:26,660
and allow to recover

523
00:25:26,660 --> 00:25:29,080
the secret accumulator parameter Alpha,

524
00:25:29,080 --> 00:25:31,060
whose knowledge can complete or brick

525
00:25:31,060 --> 00:25:32,409
the security of the scheme.

526
00:25:34,160 --> 00:25:37,860
Assuming Y to be a fix-it
non accumulated element,

527
00:25:37,860 --> 00:25:41,520
we would like to understand
how the circus action

528
00:25:41,520 --> 00:25:42,353
is available.

529
00:25:42,353 --> 00:25:45,300
Y plus Alpha and by
affect the distribution

530
00:25:45,300 --> 00:25:47,040
of the scalar C.

531
00:25:47,040 --> 00:25:49,710
To do so, we introduced detailed Y

532
00:25:49,710 --> 00:25:51,760
which is equal to dy except

533
00:25:51,760 --> 00:25:54,420
for the last it must be a reduction.

534
00:25:54,420 --> 00:25:57,690
Three main facts can be observed.

535
00:25:57,690 --> 00:26:01,833
First, if Y is random, then
dy is equal to detail dy

536
00:26:01,833 --> 00:26:04,113
with probability higher than In Log 2.

537
00:26:06,070 --> 00:26:10,000
If q is a small prime
dividing y plus Alpha

538
00:26:10,000 --> 00:26:15,000
then fv of Alpha is equal dy
mod q with probability one

539
00:26:15,060 --> 00:26:17,610
if the dy is equal to detail dy

540
00:26:17,610 --> 00:26:20,102
and with probably zero otherwise.

541
00:26:21,940 --> 00:26:25,490
If instead, q doesn't divide y plus Alpha,

542
00:26:25,490 --> 00:26:28,330
dy mod q would be just a random value zq

543
00:26:28,330 --> 00:26:32,293
and equals fv of Alpha with
probability one over q.

544
00:26:33,810 --> 00:26:35,730
By combining all these facts,

545
00:26:35,730 --> 00:26:37,850
we obtain that dy mod q

546
00:26:37,850 --> 00:26:40,959
as an higher chance to be
equal to fv of Alpha mod q

547
00:26:40,960 --> 00:26:43,373
with respect to any other value in zq.

548
00:26:45,438 --> 00:26:49,150
An attacker willing to
partial recover fv of Alpha

549
00:26:49,150 --> 00:26:52,630
will then need just few partial
non-membership witnesses dyi

550
00:26:52,630 --> 00:26:54,190
for elements, y1, yn.

551
00:26:56,080 --> 00:26:58,500
Indeed, fv of Alpha mod q

552
00:26:58,500 --> 00:27:00,290
will be the most frequent residue

553
00:27:00,290 --> 00:27:03,913
among dy1 mod q and dyn mod q.

554
00:27:05,100 --> 00:27:06,679
By repeating this process,

555
00:27:06,680 --> 00:27:09,137
just take and look over fv of Alpha,

556
00:27:09,137 --> 00:27:11,023
modulo many different small prime qi.

557
00:27:13,250 --> 00:27:16,720
At this point, we will like
to use the partials knowns

558
00:27:16,720 --> 00:27:19,503
of fv of Alpha to fully recover Alpha.

559
00:27:20,840 --> 00:27:22,870
But arranging one of the conditions

560
00:27:22,870 --> 00:27:24,929
we have seen before we obtain

561
00:27:24,930 --> 00:27:27,753
that whenever dy is equal to detail dy,

562
00:27:28,740 --> 00:27:32,580
if dy mod q is not equal
to fv of Alpha mod q,

563
00:27:32,580 --> 00:27:36,000
then q kind of dy would
kind of divide y plus Alpha

564
00:27:36,000 --> 00:27:40,123
and hence Alpha mod q cannot
be equal to minus y mod q.

565
00:27:41,670 --> 00:27:44,770
In our paper, we show
that even if allow dy

566
00:27:44,770 --> 00:27:45,850
to be a different...

567
00:27:45,850 --> 00:27:48,120
To be different from detail dy,

568
00:27:48,120 --> 00:27:50,530
the probability that Alpha is not equal

569
00:27:50,530 --> 00:27:53,040
to minus y mod q given that dy

570
00:27:53,040 --> 00:27:56,243
is not equal to fv of
Alpha mod q is still high.

571
00:27:57,820 --> 00:27:59,600
Similarly as before,

572
00:27:59,600 --> 00:28:02,480
it follows that if we
consider all the y elements

573
00:28:02,480 --> 00:28:05,860
for which dy is not equal
to fv of Alpha mod q

574
00:28:05,860 --> 00:28:08,649
then Alpha corresponds
to the least frequent

575
00:28:08,650 --> 00:28:11,400
or not occurring at all residue among

576
00:28:11,400 --> 00:28:13,693
the opposite of such elements mod q.

577
00:28:15,470 --> 00:28:18,980
By repeating this process
with different small primes q,

578
00:28:18,980 --> 00:28:20,880
we can then recover Alpha using

579
00:28:20,880 --> 00:28:22,623
the Chinese Reminder Theorem.

580
00:28:24,840 --> 00:28:26,370
Now, I'll briefly discuss

581
00:28:26,370 --> 00:28:29,010
the second witness
issue mechanism provided

582
00:28:29,010 --> 00:28:32,803
by, Au et al. namely the
CRS-based conception.

583
00:28:35,160 --> 00:28:37,653
As we said before, the only difference

584
00:28:37,653 --> 00:28:39,320
with the Alpha-based construction

585
00:28:39,320 --> 00:28:42,240
is now the scholar d
for membership witnesses

586
00:28:42,240 --> 00:28:44,270
is defined here.

587
00:28:44,270 --> 00:28:47,913
Here, it is equal to fv minus y mod p.

588
00:28:49,620 --> 00:28:52,000
The name of this construction
comes from the fact

589
00:28:52,000 --> 00:28:54,490
that both membership and
non-membership witnesses

590
00:28:54,490 --> 00:28:56,840
can be publicly computed without knowing

591
00:28:56,840 --> 00:28:59,199
the cumulative secret parameter, Alpha

592
00:28:59,200 --> 00:29:02,190
and using only a common
reference string consisting

593
00:29:02,190 --> 00:29:04,713
of powers of Alpha times the base point P.

594
00:29:06,900 --> 00:29:09,450
The security of an accumulator scheme

595
00:29:09,450 --> 00:29:12,350
is usually intended as
a collision resistance.

596
00:29:12,350 --> 00:29:14,780
And this means that an attacker forges

597
00:29:14,780 --> 00:29:17,810
with a membership witness for
a non-accumulated elements

598
00:29:17,810 --> 00:29:18,940
all on the country

599
00:29:18,940 --> 00:29:21,780
and no member should witness
for an accumulated element

600
00:29:21,780 --> 00:29:23,423
with negligible probability.

601
00:29:24,290 --> 00:29:27,170
For the CRS-based construction,
collision resistance

602
00:29:27,170 --> 00:29:30,533
is shown under the t-SDH assumption.

603
00:29:32,400 --> 00:29:35,160
Since it is possible to issue witnesses

604
00:29:35,160 --> 00:29:39,480
and update the cumulative
value by knowing only the CRS,

605
00:29:39,480 --> 00:29:42,340
its knowledge is in
fact function equivalent

606
00:29:42,340 --> 00:29:44,169
to the knowledge of Alpha.

607
00:29:44,170 --> 00:29:46,380
Also, only by knowing the latter

608
00:29:46,380 --> 00:29:49,133
it is possible to break
collision resistance.

609
00:29:50,510 --> 00:29:52,170
In Au et al. security model

610
00:29:52,170 --> 00:29:55,540
the CRS is always
accessible to the attacker

611
00:29:56,380 --> 00:29:59,050
but there exists some
concrete applications

612
00:29:59,050 --> 00:30:00,210
of the accumulator scheme,

613
00:30:00,210 --> 00:30:02,040
for example, y to blacklist

614
00:30:03,961 --> 00:30:06,270
the cumulative based
authentication mechanisms

615
00:30:06,270 --> 00:30:08,580
where only a central
authorities should be able

616
00:30:08,580 --> 00:30:10,350
to issue witnesses.

617
00:30:10,350 --> 00:30:13,350
Thus, such a cumulative
manager keeps both Alpha

618
00:30:13,350 --> 00:30:14,663
and the CRS private.

619
00:30:16,254 --> 00:30:19,649
Within this model, we the ask ourself

620
00:30:19,650 --> 00:30:23,193
which attack could be able
to recover the secret CRS?

621
00:30:25,170 --> 00:30:26,950
Let's then suppose an attacker

622
00:30:26,950 --> 00:30:30,190
has access to N elements, y1, yn along

623
00:30:30,190 --> 00:30:33,007
with the respective
non members witness cyi

624
00:30:33,007 --> 00:30:37,703
and dyi computed accordingly
to the CRS-based construction.

625
00:30:39,430 --> 00:30:43,000
Since the DYI, our evaluations

626
00:30:43,000 --> 00:30:45,603
of FV in the known values yi,

627
00:30:46,509 --> 00:30:50,290
they can be used to interpolate
the polynomial fv of x.

628
00:30:51,610 --> 00:30:54,459
At this point, the attacker
can explicitly write

629
00:30:54,460 --> 00:30:59,460
the polynomials gyi of x
dividing fv of x minus dy

630
00:30:59,930 --> 00:31:01,893
by y plus x.

631
00:31:02,840 --> 00:31:04,802
What is interesting for the attacker

632
00:31:04,802 --> 00:31:08,577
is that this polynomial gyi
evaluated in Alpha times P,

633
00:31:08,577 --> 00:31:11,730
equal the Cyi values of
the non membership witness

634
00:31:11,730 --> 00:31:13,153
it possess.

635
00:31:15,060 --> 00:31:18,580
With high probabilities,
this Gyi polynomials

636
00:31:18,580 --> 00:31:20,330
will be independent

637
00:31:20,330 --> 00:31:23,550
and by using linear algebra,
the attacker will be able

638
00:31:23,550 --> 00:31:27,110
to write linear combinations
resulting in polynomials

639
00:31:27,110 --> 00:31:28,750
of the from X to the k

640
00:31:28,750 --> 00:31:30,793
for some certain integer k.

641
00:31:31,926 --> 00:31:33,490
The attacker then applies

642
00:31:33,490 --> 00:31:35,390
the same leaner combinations over

643
00:31:35,390 --> 00:31:40,390
the corresponding value Cyi and
obtains elements in the CRS.

644
00:31:43,070 --> 00:31:45,230
To conclude, in this work,

645
00:31:45,230 --> 00:31:47,913
we analyzed the two
accumulator variants proposed

646
00:31:47,913 --> 00:31:49,620
by Au et al.

647
00:31:49,620 --> 00:31:53,483
Namely, the Alpha-based and
the CRS based construction.

648
00:31:54,440 --> 00:31:57,080
For the first one, we
detail different attacks

649
00:31:57,080 --> 00:31:59,870
that break the security
of the scheme requiring

650
00:31:59,870 --> 00:32:01,540
the attacker to access only one

651
00:32:01,540 --> 00:32:03,883
of the non-membership witnesses.

652
00:32:05,200 --> 00:32:08,650
We then showed how such
shortcomings can be prevented

653
00:32:08,650 --> 00:32:11,833
by using the corrected
expression for witnesses.

654
00:32:13,400 --> 00:32:17,450
We then investigate resistance
to witness forgeries

655
00:32:17,450 --> 00:32:19,960
of the CRS-based construction under

656
00:32:19,960 --> 00:32:22,740
the policies that the cumulative manager

657
00:32:22,740 --> 00:32:25,090
as exclusive rise to issue witnesses

658
00:32:25,090 --> 00:32:27,293
and that skips the CRS private.

659
00:32:28,750 --> 00:32:31,740
We showed that an attacker
accessing multiple witnesses

660
00:32:31,740 --> 00:32:35,050
can infact and reconstruct the secret CRS

661
00:32:35,050 --> 00:32:37,850
but this can be prevented
by properly initializing

662
00:32:37,850 --> 00:32:39,342
the cumulative value.

663
00:32:40,780 --> 00:32:41,613
Thank you.

