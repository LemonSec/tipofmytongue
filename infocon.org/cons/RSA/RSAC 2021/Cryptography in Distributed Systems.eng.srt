1
00:00:01,480 --> 00:00:02,929
- Hello, my name is Roman Walch,

2
00:00:02,930 --> 00:00:05,670
and I'm a PhD student
at the Know-Center GmbH

3
00:00:05,670 --> 00:00:07,220
and behalf with cooperation

4
00:00:07,220 --> 00:00:09,360
of the Graz University of Technology,

5
00:00:09,360 --> 00:00:12,389
and I'm mainly working on
privacy preserving cryptography.

6
00:00:12,390 --> 00:00:15,190
And in this presentation,
I will talk about our work,

7
00:00:15,190 --> 00:00:17,259
multi-party revocation in Sovrin

8
00:00:17,260 --> 00:00:19,330
performance through distributed trust.

9
00:00:19,330 --> 00:00:22,107
And this is a joint work
with Lukas Helminger,

10
00:00:22,107 --> 00:00:25,349
Daniel Kales and Sebastian Ramacher.

11
00:00:25,350 --> 00:00:26,183
In this presentation,

12
00:00:26,183 --> 00:00:29,530
it will mainly talk about
cryptographic accumulators.

13
00:00:29,530 --> 00:00:31,308
Accumulators allow us to represent

14
00:00:31,308 --> 00:00:33,670
a large set very efficiently.

15
00:00:33,670 --> 00:00:34,770
As an example,

16
00:00:34,770 --> 00:00:37,050
I want to talk about the
Merkle-tree accumulator,

17
00:00:37,050 --> 00:00:41,029
which is the most commonly
known and most commonly used.

18
00:00:41,030 --> 00:00:43,630
So the Merkle-tree is
basically just a tree

19
00:00:43,630 --> 00:00:46,390
where each node is the
hash of its children.

20
00:00:46,390 --> 00:00:48,010
And to form an accumulator,

21
00:00:48,010 --> 00:00:50,920
all the elements of the
set we want to accumulate

22
00:00:50,920 --> 00:00:52,800
are located in the leaves.

23
00:00:52,800 --> 00:00:55,980
And the accumulator itself
is standard root node.

24
00:00:55,980 --> 00:00:58,209
And each element of the accumulator

25
00:00:58,210 --> 00:00:59,900
has a corresponding witness

26
00:00:59,900 --> 00:01:02,120
which basically proves that this element

27
00:01:02,120 --> 00:01:04,349
is part of the accumulation process.

28
00:01:04,349 --> 00:01:05,479
And in the Merkle-tree,

29
00:01:05,480 --> 00:01:08,425
this witness all elements
that are required

30
00:01:08,425 --> 00:01:12,149
together with the element
itself, create the accumulator.

31
00:01:12,150 --> 00:01:14,590
So create the root node.

32
00:01:14,590 --> 00:01:15,980
And this already shows

33
00:01:15,980 --> 00:01:18,040
a disadvantage of the
Merkle-tree accumulator

34
00:01:18,040 --> 00:01:20,760
that the witness size is dependent

35
00:01:20,760 --> 00:01:23,788
on the number of elements accumulated

36
00:01:23,788 --> 00:01:25,833
in the accumulator.

37
00:01:25,833 --> 00:01:29,370
Alternatively, one can use
public key accumulators,

38
00:01:29,370 --> 00:01:30,306
which are based

39
00:01:30,306 --> 00:01:32,830
on very known Cryptographic
Hardness Assumptions,

40
00:01:32,830 --> 00:01:35,899
and these accumulators have
a constant witness size.

41
00:01:35,900 --> 00:01:38,060
However, in this accumulators,

42
00:01:38,060 --> 00:01:39,780
there's a secret trapdoor involved.

43
00:01:39,780 --> 00:01:41,790
And if you have knowledge
of this trapdoor,

44
00:01:41,790 --> 00:01:44,090
you can create witnesses for non members,

45
00:01:44,090 --> 00:01:45,670
and that is very bad.

46
00:01:45,670 --> 00:01:48,600
Alternatively, if you don't
know the secret trapdoor

47
00:01:48,600 --> 00:01:50,369
you can still use this accumulators,

48
00:01:50,370 --> 00:01:52,320
but then they are not really efficient.

49
00:01:53,430 --> 00:01:55,380
Now let's talk about accumulators

50
00:01:55,380 --> 00:01:58,140
in digital identity management systems

51
00:01:58,140 --> 00:02:00,340
such like Sovrin which
we have in the title.

52
00:02:01,370 --> 00:02:02,920
Let's say we have a credential manager.

53
00:02:02,920 --> 00:02:06,300
And he has a list of people
here Alice, Bob, and Charlie

54
00:02:06,300 --> 00:02:07,929
of which he has credentials.

55
00:02:07,930 --> 00:02:10,389
And let's say, Bob wants
to use these credentials

56
00:02:10,389 --> 00:02:12,869
to authenticate users voice service.

57
00:02:12,870 --> 00:02:14,210
What then happens is that

58
00:02:14,210 --> 00:02:16,300
the credential manager
creates an accumulator

59
00:02:16,300 --> 00:02:20,730
and sends it to Bob, and
each user receive a witness

60
00:02:20,730 --> 00:02:22,963
of its himself being in the accumulator.

61
00:02:23,840 --> 00:02:26,370
So when Alice then wants
to authenticate to Bob,

62
00:02:26,370 --> 00:02:29,110
she basically says, hey Bob, I am Alice,

63
00:02:29,110 --> 00:02:31,310
I'm on the list and here's my witness.

64
00:02:31,310 --> 00:02:33,900
And then Bob can look at the witness

65
00:02:33,900 --> 00:02:36,490
and verify against his accumulator.

66
00:02:36,490 --> 00:02:39,883
And if it checks out, then
he can authenticate Alice.

67
00:02:40,900 --> 00:02:44,240
This approach is also compatible
with anonymous credentials,

68
00:02:44,240 --> 00:02:46,910
where the users do not want
to disclose themselves,

69
00:02:46,910 --> 00:02:49,290
or their witnesses to the authenticator.

70
00:02:49,290 --> 00:02:51,469
And how this works is the following,

71
00:02:51,469 --> 00:02:54,980
Alice constructs a zero
knowledge proof of knowledge

72
00:02:54,980 --> 00:02:56,890
that she knows a witness of herself

73
00:02:56,890 --> 00:02:58,420
being in the accumulator.

74
00:02:58,420 --> 00:03:01,369
And Bob can then check
whether this proof works

75
00:03:01,370 --> 00:03:03,360
or if it is the wrong proof.

76
00:03:03,360 --> 00:03:06,090
And so, Bob can authenticate Alice

77
00:03:06,090 --> 00:03:10,253
without knowing Alice and
without seeing her witness.

78
00:03:11,480 --> 00:03:13,470
Also, what is very important

79
00:03:13,470 --> 00:03:16,380
for accumulators in digital
identity management system

80
00:03:16,380 --> 00:03:18,320
is that they need to be updatable.

81
00:03:18,320 --> 00:03:20,690
Let's say we have the credential manager

82
00:03:20,690 --> 00:03:23,350
wants to revoke the
credentials for Charlie,

83
00:03:23,350 --> 00:03:25,290
then we still need to be able

84
00:03:25,290 --> 00:03:28,060
to efficiently update the accumulator,

85
00:03:28,060 --> 00:03:29,340
and also each user

86
00:03:29,340 --> 00:03:31,980
needs to be able to
efficiently update its witness

87
00:03:31,980 --> 00:03:33,609
to match the new accumulator

88
00:03:33,610 --> 00:03:36,713
otherwise, the user won't be
able to authenticate anymore.

89
00:03:38,090 --> 00:03:40,580
So let's talk about the q-SDH accumulator.

90
00:03:40,580 --> 00:03:43,480
It's an accumulator with
constant size witnesses.

91
00:03:43,480 --> 00:03:44,920
And it also is compatible

92
00:03:44,920 --> 00:03:46,829
with efficiency or knowledge proofs.

93
00:03:46,830 --> 00:03:48,660
But as I said in beginning,

94
00:03:48,660 --> 00:03:50,920
without the secret
trapdoor that is involved,

95
00:03:50,920 --> 00:03:52,373
it is not very efficient.

96
00:03:53,490 --> 00:03:56,390
So in this accumulator, we
have the secret trapdoor S,

97
00:03:56,390 --> 00:03:59,029
and the public key, which is
basically just to generate,

98
00:03:59,030 --> 00:04:01,270
raised to the power of S.

99
00:04:01,270 --> 00:04:03,760
And if you want to accumulate the set A,

100
00:04:03,760 --> 00:04:06,399
what we do is that we define a polynomial

101
00:04:06,400 --> 00:04:09,130
with all the elements
of the set as the roots

102
00:04:09,130 --> 00:04:12,470
and we evaluate this polynomial
at the secret trapdoor S

103
00:04:12,470 --> 00:04:14,505
and to accumulated (indistinct)

104
00:04:14,505 --> 00:04:18,500
is evaluated polynomial in
the power of the generator.

105
00:04:18,500 --> 00:04:19,333
Yeah.

106
00:04:20,339 --> 00:04:23,859
And witness of the element
X in this accumulator

107
00:04:23,860 --> 00:04:27,590
is basically just the accumulator
without this element X.

108
00:04:27,590 --> 00:04:30,090
And we can verify if
this witness is correct

109
00:04:30,090 --> 00:04:32,770
by checking whether the
exponents of the witness

110
00:04:32,770 --> 00:04:35,887
and the element itself match
the initial accumulator.

111
00:04:35,887 --> 00:04:39,193
And we can do this via
operation of a bearing equation.

112
00:04:40,810 --> 00:04:42,270
So if we have the
knowledge of the trapdoor,

113
00:04:42,270 --> 00:04:45,219
we can easily compute S plus X

114
00:04:45,220 --> 00:04:48,120
and the inverse of S
plus X very efficiently,

115
00:04:48,120 --> 00:04:48,970
and this implies

116
00:04:48,970 --> 00:04:51,930
that we can also create
the witnesses of elements

117
00:04:51,930 --> 00:04:55,000
and also update the
accumulator very efficiently.

118
00:04:55,000 --> 00:04:59,857
But this also implies that we
can calculate this S plus X

119
00:04:59,857 --> 00:05:01,590
and the inverse of S plus X,

120
00:05:01,590 --> 00:05:03,767
for X not being in the initial set,

121
00:05:03,767 --> 00:05:06,630
and therefore, we can create
witnesses for non members

122
00:05:06,630 --> 00:05:10,073
for which the verification
equation still works out.

123
00:05:11,210 --> 00:05:14,400
Same practice, if you want
to use the q-SDH accumulator,

124
00:05:14,400 --> 00:05:16,359
we have to forget this trapdoor

125
00:05:16,360 --> 00:05:18,770
after the public key is created.

126
00:05:18,770 --> 00:05:21,996
But the public key here also contains no

127
00:05:21,996 --> 00:05:25,010
G raised to the powers of S.

128
00:05:25,010 --> 00:05:28,280
And we can use this new elements

129
00:05:28,280 --> 00:05:30,919
to evaluate this polynomial
from the previous slides

130
00:05:30,920 --> 00:05:32,970
already in the exponent of the generator.

131
00:05:33,960 --> 00:05:36,859
However, since we do not have
access to the secret trapdoor,

132
00:05:36,860 --> 00:05:38,890
we cannot calculate S plus X

133
00:05:38,890 --> 00:05:41,550
or S plus X to the power of minus one,

134
00:05:41,550 --> 00:05:43,070
which basically says,

135
00:05:43,070 --> 00:05:45,630
if you want to create a
witness for an element,

136
00:05:45,630 --> 00:05:48,260
or if you want to update our accumulator,

137
00:05:48,260 --> 00:05:50,960
we have to re accumulate the whole set.

138
00:05:50,960 --> 00:05:53,590
And therefore we have around
them for all algorithms,

139
00:05:53,590 --> 00:05:56,332
which is dependent on the size of the set

140
00:05:56,332 --> 00:05:58,178
we want to accumulate.

141
00:05:58,178 --> 00:06:00,043
And this is very bad for that sets.

142
00:06:01,505 --> 00:06:02,740
Therefore, we had this idea

143
00:06:02,740 --> 00:06:06,500
that if we can split the secret trapdoors

144
00:06:06,500 --> 00:06:08,520
among several accumulated managers

145
00:06:08,520 --> 00:06:10,130
and therefore split the trust

146
00:06:10,130 --> 00:06:13,173
in not misusing this trapdoor.

147
00:06:15,690 --> 00:06:18,270
And this approach is
already very compatible

148
00:06:18,270 --> 00:06:20,560
with the

149
00:06:20,560 --> 00:06:22,950
Sovrin environment because in Sovrin

150
00:06:22,950 --> 00:06:24,570
we already have these

151
00:06:24,570 --> 00:06:27,430
multiple semi trusted foundation managers.

152
00:06:27,430 --> 00:06:30,560
And as a consequence, if
you split this trapdoor,

153
00:06:30,560 --> 00:06:32,660
no accumulator managed on its own,

154
00:06:32,660 --> 00:06:37,000
can misuse the trapdoor to
create witnesses for non members.

155
00:06:37,000 --> 00:06:39,740
But they can still use their
shares of this trapdoor

156
00:06:39,740 --> 00:06:42,680
to engage in secure multi-party
computation protocols

157
00:06:42,680 --> 00:06:45,670
to still evaluate stuff like S plus X

158
00:06:45,670 --> 00:06:47,720
and S plus X to the power of minus one,

159
00:06:47,720 --> 00:06:52,050
efficiently in constant time,
independent of the set size,

160
00:06:52,050 --> 00:06:55,890
and therefore we can
also create the witnesses

161
00:06:55,890 --> 00:06:57,770
and also update accumulators

162
00:06:57,770 --> 00:07:00,169
in efficient constant time algorithms.

163
00:07:00,170 --> 00:07:02,930
So as a result, the initial accumulation

164
00:07:02,930 --> 00:07:05,360
still is dependent on the set size

165
00:07:05,360 --> 00:07:07,910
and all our operations under accumulator

166
00:07:07,910 --> 00:07:09,123
running constant time.

167
00:07:10,870 --> 00:07:13,310
Furthermore, our construction
is generic enough

168
00:07:13,310 --> 00:07:17,160
that it can be instantiated
with different MPC protocols.

169
00:07:17,160 --> 00:07:18,672
For example, with speeds

170
00:07:18,672 --> 00:07:21,530
in which an honest accumulator manager

171
00:07:21,530 --> 00:07:23,549
always detects malicious behavior.

172
00:07:23,550 --> 00:07:25,010
And all accumulator managers

173
00:07:25,010 --> 00:07:26,830
are required to respond honestly

174
00:07:26,830 --> 00:07:30,560
for correctness of the evaluations.

175
00:07:30,560 --> 00:07:33,323
On the other hand, we can
also instantiate our protocol

176
00:07:33,323 --> 00:07:37,770
with our accumulator with
Shamir based MPC protocols,

177
00:07:37,770 --> 00:07:39,400
where only a subset of parties

178
00:07:39,400 --> 00:07:42,200
need to respond honestly
or need to participate

179
00:07:42,200 --> 00:07:43,479
in the computations.

180
00:07:43,480 --> 00:07:46,330
And therefore, this instantiation would be

181
00:07:47,323 --> 00:07:50,260
naturally robust against
parties dropping out

182
00:07:50,260 --> 00:07:51,980
during the competition.

183
00:07:51,980 --> 00:07:53,300
We implement and verify

184
00:07:53,300 --> 00:07:57,200
the efficiency of our MPC
accumulator in the MP-SPDZ library

185
00:07:57,200 --> 00:07:59,979
and we had to integrate the Relic-library

186
00:07:59,980 --> 00:08:03,330
for pairing based elliptic
curve cryptography there.

187
00:08:03,330 --> 00:08:05,582
So next slide have a
look at some benchmarks.

188
00:08:06,730 --> 00:08:09,450
So as a baseline, I want to talk about

189
00:08:09,450 --> 00:08:12,560
benchmarks of the
standard q-SDH accumulator

190
00:08:12,560 --> 00:08:15,300
without having access
to the secret trapdoor.

191
00:08:15,300 --> 00:08:18,560
And I want to give you timings
for the initial accumulation

192
00:08:18,560 --> 00:08:22,150
for creating a witness, or
updating the accumulator

193
00:08:22,150 --> 00:08:24,289
after we added or deleted an element

194
00:08:24,290 --> 00:08:28,440
and also updating the
witnesses of the elements.

195
00:08:28,440 --> 00:08:31,110
And I give you timings for
two different set sizes

196
00:08:31,110 --> 00:08:33,919
two the power of 10 and
two the power of 14.

197
00:08:33,919 --> 00:08:36,880
And one can clearly see
here in this benchmarks,

198
00:08:36,880 --> 00:08:38,840
that update algorithm,

199
00:08:38,840 --> 00:08:41,309
so updating the accumulator

200
00:08:41,309 --> 00:08:43,219
after elements get added or removed,

201
00:08:43,220 --> 00:08:45,940
but also creating witnesses
have the same runtime

202
00:08:45,940 --> 00:08:48,000
as the initial accumulation.

203
00:08:48,000 --> 00:08:49,950
And also this runtime is very slow.

204
00:08:49,950 --> 00:08:54,330
So for two the power of
14, elements in our set,

205
00:08:54,330 --> 00:08:57,180
this runtime is already
more than 100 seconds,

206
00:08:57,180 --> 00:08:58,430
which is very slow

207
00:08:59,660 --> 00:09:00,492
for comparison.

208
00:09:00,493 --> 00:09:04,810
And I want to talk about
benchmarks of our MPC accumulator.

209
00:09:04,810 --> 00:09:08,349
And more specifically, we
instantiated this accumulator

210
00:09:08,350 --> 00:09:12,010
for these benchmarks with
the SPDZ-MPC protocol,

211
00:09:12,010 --> 00:09:14,760
and if you hear timings
for the online phase

212
00:09:14,760 --> 00:09:16,533
in a very fast LAN network.

213
00:09:17,440 --> 00:09:20,240
And I also give you the
benchmarks if the two set sizes,

214
00:09:20,240 --> 00:09:23,570
but also two different numbers
of accumulator manager.

215
00:09:23,570 --> 00:09:26,590
So in the first line, we have
two accumulate the managers

216
00:09:26,590 --> 00:09:28,880
and in the second line we have five.

217
00:09:28,880 --> 00:09:31,140
And one can really observe here

218
00:09:31,140 --> 00:09:33,689
that except for the initial accumulation,

219
00:09:33,690 --> 00:09:37,820
all algorithms have runtime
independent of the set size.

220
00:09:37,820 --> 00:09:39,290
And also the over runtimes

221
00:09:39,290 --> 00:09:41,599
are much faster than in the previous slide

222
00:09:41,600 --> 00:09:44,240
with the slowest one being
the initial accumulation

223
00:09:44,240 --> 00:09:46,280
for five accumulator managers

224
00:09:46,280 --> 00:09:48,350
and two the power of 14 elements.

225
00:09:48,350 --> 00:09:52,230
And this runtime is still
less than a quarter second,

226
00:09:52,230 --> 00:09:54,610
and yeah, this is much faster

227
00:09:54,610 --> 00:09:56,913
than the 100 seconds
from the previous slide.

228
00:09:57,990 --> 00:10:00,107
For comparison, I give you times

229
00:10:00,107 --> 00:10:02,420
for the same benchmarks
in a slower network,

230
00:10:02,420 --> 00:10:04,280
a slower WAN network.

231
00:10:04,280 --> 00:10:06,500
And the same behavior
as in the previous slide

232
00:10:06,500 --> 00:10:09,930
can also be seen here with all algorithms

233
00:10:09,930 --> 00:10:12,626
except for the initial accumulation again,

234
00:10:12,626 --> 00:10:16,199
run in the time independent
of the set size.

235
00:10:16,200 --> 00:10:18,480
Only that the runtime somehow slower

236
00:10:18,480 --> 00:10:20,410
due to this lower network,

237
00:10:20,410 --> 00:10:23,072
but the overall runtimes, the slowest one

238
00:10:23,072 --> 00:10:26,630
is still slower than four seconds,

239
00:10:26,630 --> 00:10:28,950
which is still less than four seconds,

240
00:10:28,950 --> 00:10:31,764
which is much faster than
this 100 seconds again

241
00:10:31,764 --> 00:10:33,977
of the non MPC (indistinct).

242
00:10:35,650 --> 00:10:38,860
So to conclude this talk,

243
00:10:38,860 --> 00:10:40,600
in this paper, and this presentation,

244
00:10:40,600 --> 00:10:44,500
we introduced secret
shared q-SDH accumulators

245
00:10:44,500 --> 00:10:47,000
which have constant witness sizes.

246
00:10:47,000 --> 00:10:47,833
They are compatible

247
00:10:47,833 --> 00:10:49,660
with their efficiency or knowledge proofs

248
00:10:49,660 --> 00:10:51,740
and they have constant time algorithms

249
00:10:51,740 --> 00:10:55,042
for accumulated updates
and witness creation.

250
00:10:55,042 --> 00:10:56,980
Our accumulator can be instantiated

251
00:10:56,980 --> 00:10:58,930
with different MPC protocols.

252
00:10:58,930 --> 00:11:02,420
For example, if the dishonest
majority SPDZ protocol

253
00:11:02,420 --> 00:11:06,089
and threshold protocols based
on Shamir Secret Sharing.

254
00:11:06,090 --> 00:11:09,220
We have an open source implementation,

255
00:11:09,220 --> 00:11:12,528
which is on GitHub, and our
implementation is in the

256
00:11:12,528 --> 00:11:15,030
community used MP-SPDZ slowly.

257
00:11:15,030 --> 00:11:18,260
In the paper, we have
more extensive benchmarks.

258
00:11:18,260 --> 00:11:21,000
And we also have a security
proof of our construction

259
00:11:21,000 --> 00:11:22,150
that you see framework,

260
00:11:22,150 --> 00:11:23,900
which is the standard to prove security

261
00:11:23,900 --> 00:11:26,973
for our MPC protocols and accumulators.

262
00:11:27,940 --> 00:11:29,760
So this was my presentation.

263
00:11:29,760 --> 00:11:31,710
I want to thank you for your attention.

264
00:11:33,910 --> 00:11:35,579
- Hello, everyone.

265
00:11:35,580 --> 00:11:36,733
My name is Hamid.

266
00:11:38,070 --> 00:11:40,870
I'm gonna talk about balancing
privacy and accountability

267
00:11:40,870 --> 00:11:43,310
in blockchain identity management.

268
00:11:43,310 --> 00:11:47,119
This is a joint work with a
Ivan Damgard, Chaya Ganesh,

269
00:11:47,120 --> 00:11:49,453
Claudio Orlandi and Luisa Siniscalchi.

270
00:11:51,930 --> 00:11:54,073
Let's start with the problem statement.

271
00:11:55,010 --> 00:11:58,680
So the first generation of
distributed payment system,

272
00:11:58,680 --> 00:11:59,863
such as Bitcoin,

273
00:12:01,120 --> 00:12:02,400
we can say that we have a bank

274
00:12:02,400 --> 00:12:05,260
that is replaced with a distributed ledger

275
00:12:05,260 --> 00:12:06,773
and a consensus system.

276
00:12:07,900 --> 00:12:10,520
So these systems provide pseudonymity.

277
00:12:10,520 --> 00:12:12,840
But the issue with these systems is that

278
00:12:14,399 --> 00:12:18,420
the account balance is revealed
actually in the transaction.

279
00:12:18,420 --> 00:12:21,030
And although they have pseudonymity,

280
00:12:21,030 --> 00:12:26,030
but it's easy to analyze the
transaction graph of the users

281
00:12:26,180 --> 00:12:28,882
and learn some information
about their identity.

282
00:12:30,420 --> 00:12:31,829
So to solve this problem,

283
00:12:31,830 --> 00:12:36,830
we have the second generation of systems,

284
00:12:36,940 --> 00:12:40,250
privacy preserving systems such as Zcash,

285
00:12:40,250 --> 00:12:42,150
that they use some zero knowledge proofs

286
00:12:42,150 --> 00:12:43,992
for the correctness of transaction.

287
00:12:44,900 --> 00:12:47,540
And they have this advantage

288
00:12:47,540 --> 00:12:50,410
that they provide full
anonymity for the users.

289
00:12:50,410 --> 00:12:51,910
But now the issue is that

290
00:12:51,910 --> 00:12:54,920
they are not compliant
with bank regulations

291
00:12:54,920 --> 00:12:59,083
such as, know your customer and
anti money laundering rules.

292
00:13:00,280 --> 00:13:03,550
And the fact that they
don't provide any protection

293
00:13:03,550 --> 00:13:04,969
against money laundering

294
00:13:04,970 --> 00:13:09,970
makes these systems very
attractive for fraud activities.

295
00:13:11,190 --> 00:13:12,620
So the solution for this problem

296
00:13:12,620 --> 00:13:14,980
is to add accountability to the system,

297
00:13:14,980 --> 00:13:18,830
meaning that in the case
of a reasonable suspicion,

298
00:13:18,830 --> 00:13:22,700
then there are some authorized
parties in this system

299
00:13:22,700 --> 00:13:25,790
that can revoke the anonymity of the user

300
00:13:25,790 --> 00:13:30,483
and see the transaction history, etc.

301
00:13:32,550 --> 00:13:35,459
Now, the fact that these two properties

302
00:13:35,460 --> 00:13:37,690
of privacy and accountability,

303
00:13:37,690 --> 00:13:42,400
or like two contradictory
requirements for the system,

304
00:13:42,400 --> 00:13:45,160
the question is, can we find a balance

305
00:13:45,160 --> 00:13:47,100
between these two properties?

306
00:13:47,100 --> 00:13:49,010
And this is the purpose of this work.

307
00:13:49,010 --> 00:13:53,350
So we design, an identity
management system

308
00:13:53,350 --> 00:13:55,863
for balancing between
these two properties.

309
00:13:57,639 --> 00:14:01,210
Our design in high level is as follows.

310
00:14:01,210 --> 00:14:03,565
We have three different
players in the system,

311
00:14:03,565 --> 00:14:07,600
account holder, which are
just the users of the system,

312
00:14:07,600 --> 00:14:12,600
and two types of authorized
parties, identity providers,

313
00:14:13,150 --> 00:14:14,823
and anonymity revokers.

314
00:14:16,710 --> 00:14:17,740
At the beginning,

315
00:14:17,740 --> 00:14:22,740
the users that wants to create
account on the blockchain,

316
00:14:23,060 --> 00:14:26,329
they need to register
with an identity provider.

317
00:14:26,330 --> 00:14:28,573
So we assume that we
have an account holder

318
00:14:28,573 --> 00:14:33,500
with an identity that
we show with IDAH here.

319
00:14:33,500 --> 00:14:35,880
The account holder has
a list of attributes

320
00:14:35,880 --> 00:14:39,103
where one of them is called a MaxACC,

321
00:14:40,820 --> 00:14:43,800
which is specified the
maximum number of accounts

322
00:14:43,800 --> 00:14:46,280
that this user can open.

323
00:14:46,280 --> 00:14:50,040
So this parameter can be defined

324
00:14:50,040 --> 00:14:55,040
as based on an agreement
with the identity provider.

325
00:14:56,600 --> 00:15:00,223
The account holder also has
a key pair and a PRF key K.

326
00:15:01,130 --> 00:15:03,290
And with this information,

327
00:15:03,290 --> 00:15:07,900
the account holder runs interactive
blind signature protocol

328
00:15:07,900 --> 00:15:09,393
with the identity provider.

329
00:15:11,360 --> 00:15:13,130
So they run this protocol together.

330
00:15:13,130 --> 00:15:14,640
And at the end of the protocol,

331
00:15:14,640 --> 00:15:17,260
the account holder receives a signature

332
00:15:17,260 --> 00:15:21,300
from the identity provider
on his attribute list,

333
00:15:21,300 --> 00:15:24,579
and his secret key and the PRF key K.

334
00:15:24,580 --> 00:15:27,520
And it is important that
the identity provider

335
00:15:27,520 --> 00:15:31,970
doesn't learn about the
secret key, and the PRF key,

336
00:15:31,970 --> 00:15:33,750
of the account holder.

337
00:15:33,750 --> 00:15:36,863
So it's the signature
isn't in a blind way.

338
00:15:38,120 --> 00:15:42,830
And at the end, the account
holder received the signature

339
00:15:42,830 --> 00:15:45,809
and the identity provider also

340
00:15:45,809 --> 00:15:50,809
received some information
that stores at the end,

341
00:15:52,240 --> 00:15:54,803
which are the identity
of the account holder,

342
00:15:56,170 --> 00:15:59,770
the attribute list, and the
public key of the account holder

343
00:15:59,770 --> 00:16:02,280
and the encryption of the PRF key

344
00:16:02,280 --> 00:16:04,630
under the public key of
the anonymity revorker.

345
00:16:05,710 --> 00:16:09,230
Now that the account holder
has this certificate,

346
00:16:09,230 --> 00:16:11,580
has this signature from
the identity provider,

347
00:16:11,580 --> 00:16:15,180
he can create several different accounts.

348
00:16:15,180 --> 00:16:18,099
And the account creation is as follows.

349
00:16:18,100 --> 00:16:20,860
So we assume that the account holder

350
00:16:20,860 --> 00:16:23,410
can create different accounts

351
00:16:23,410 --> 00:16:25,892
for different policies
that he wants to use.

352
00:16:27,690 --> 00:16:31,210
So the account creation is by,

353
00:16:31,210 --> 00:16:34,990
start with a generating a
key pair for the account.

354
00:16:34,990 --> 00:16:39,740
And then computing the
encryption of the the public key,

355
00:16:39,740 --> 00:16:41,330
the account holder public key

356
00:16:41,330 --> 00:16:45,820
under the public key of
the anonymity revoker.

357
00:16:45,820 --> 00:16:49,740
Then computing the PRF of X

358
00:16:50,690 --> 00:16:52,710
at the time that this account holder

359
00:16:52,710 --> 00:16:54,883
is creating the X account.

360
00:16:57,020 --> 00:16:59,313
So we call this the account ID.

361
00:17:00,360 --> 00:17:03,170
And then generating an easy proof

362
00:17:03,170 --> 00:17:05,909
for proving the knowledge
of the certificate

363
00:17:05,910 --> 00:17:07,550
from the identity provider,

364
00:17:07,550 --> 00:17:10,099
and the knowledge of the
secret key of the account.

365
00:17:11,430 --> 00:17:13,040
This NIZK proof also

366
00:17:14,220 --> 00:17:16,880
shows the correctness of the computation

367
00:17:16,880 --> 00:17:20,603
and the fact that the attribute
list satisfy the policy.

368
00:17:21,700 --> 00:17:26,150
And the fact that this X is
less than MaxACC parameter.

369
00:17:26,150 --> 00:17:29,410
So the account holder is
not creating more than

370
00:17:30,318 --> 00:17:32,883
accounts that he's allowed to open.

371
00:17:34,700 --> 00:17:38,550
And then the account holder
publish this information

372
00:17:38,550 --> 00:17:41,169
which is called account
creation information

373
00:17:41,170 --> 00:17:42,430
on the blockchain,

374
00:17:42,430 --> 00:17:45,660
consisting of the account ID, E-ID,

375
00:17:45,660 --> 00:17:49,190
the public key of the
account, the public policy

376
00:17:49,190 --> 00:17:50,023
and the NIZK proof.

377
00:17:50,023 --> 00:17:53,850
And now everyone can publicly
verify the correctness,

378
00:17:53,850 --> 00:17:55,360
the validity of this account

379
00:17:55,360 --> 00:17:58,622
by checking the NIZK proof.

380
00:18:00,880 --> 00:18:05,880
Now, if at some point, there
are some suspicious account,

381
00:18:08,240 --> 00:18:12,700
we need to revoke the anonymity
of the user in this case.

382
00:18:12,700 --> 00:18:16,170
A suspicious account can be
for example, an account that

383
00:18:16,170 --> 00:18:19,560
its account ID is
duplicated in the system.

384
00:18:19,560 --> 00:18:21,929
So if the account holder is not,

385
00:18:21,930 --> 00:18:24,050
because the account holder
is not allowed to open

386
00:18:24,050 --> 00:18:26,770
more than the MaxACC number of accounts,

387
00:18:26,770 --> 00:18:29,490
one way to cheat is to
create two different accounts

388
00:18:29,490 --> 00:18:31,150
with the same ID.

389
00:18:31,150 --> 00:18:32,950
So in this case,

390
00:18:32,950 --> 00:18:36,290
the anonymity revoker and the ID provider

391
00:18:38,880 --> 00:18:40,080
with help of each other

392
00:18:40,080 --> 00:18:43,399
they can decrypt and revoke
the anonymity of the user.

393
00:18:43,400 --> 00:18:46,590
So the anonymity revoker decrypt the E-ID

394
00:18:46,590 --> 00:18:49,159
inside the account creation information,

395
00:18:49,160 --> 00:18:51,440
and send the public key
of the account holder

396
00:18:51,440 --> 00:18:53,480
to the identity provider.

397
00:18:53,480 --> 00:18:55,390
Now that the identity provider

398
00:18:55,390 --> 00:18:59,230
knows the identity of the account holder

399
00:18:59,230 --> 00:19:01,130
corresponding to this public key,

400
00:19:01,130 --> 00:19:03,672
he can just reveal this identity

401
00:19:03,672 --> 00:19:08,672
to everyone, anyone, for example,
to the authorized parties.

402
00:19:10,490 --> 00:19:12,773
And now that we know one party,

403
00:19:14,250 --> 00:19:17,920
we know the identity
of the account holder,

404
00:19:17,920 --> 00:19:20,920
we want to also be able to
trace different accounts

405
00:19:20,920 --> 00:19:24,950
that this party is creating in the chain.

406
00:19:24,950 --> 00:19:26,740
So the idea is that in this case,

407
00:19:26,740 --> 00:19:31,260
the identity provider sent the
encryption of the PRF key K

408
00:19:32,120 --> 00:19:34,090
to the anonymity revoker,

409
00:19:34,090 --> 00:19:37,889
because you're assuming
that the identity provider

410
00:19:37,890 --> 00:19:41,150
is storing the cipher text
in the inside the tuple

411
00:19:41,150 --> 00:19:44,593
is receiving from the after
the blind signature protocol.

412
00:19:45,540 --> 00:19:47,657
He sent the cipher text
to the anonymity revoker

413
00:19:47,657 --> 00:19:49,270
and anonymity to revoke or decrypt

414
00:19:49,270 --> 00:19:53,028
and they both together
can find the PRF key K.

415
00:19:53,028 --> 00:19:57,630
And now they can find a
compute PRF of key for X

416
00:19:57,630 --> 00:19:59,670
for extra one up to MaxACC

417
00:19:59,670 --> 00:20:01,570
which are all possible account IDs

418
00:20:01,570 --> 00:20:04,273
that this account holder might have.

419
00:20:06,150 --> 00:20:09,720
So, we implement or design

420
00:20:09,720 --> 00:20:13,050
with a lot of cryptographic
tools and techniques,

421
00:20:13,050 --> 00:20:15,690
including Pederson commitment.

422
00:20:15,690 --> 00:20:17,713
And for the PRF,

423
00:20:20,870 --> 00:20:22,060
for the PRF construction

424
00:20:22,060 --> 00:20:25,679
they use a PRF by Dodis and Yampolskiy.

425
00:20:25,680 --> 00:20:26,900
For the blind signature,

426
00:20:26,900 --> 00:20:28,890
we use a signature type of signature

427
00:20:28,890 --> 00:20:30,680
from Pointcheval-Sanders,

428
00:20:30,680 --> 00:20:34,480
and for the anonymity
revoker, we actually implement

429
00:20:34,480 --> 00:20:38,340
we assume a threshold assumption
on the anonymity revoker.

430
00:20:38,340 --> 00:20:41,843
So, there exists and
different anonymity revokers.

431
00:20:41,844 --> 00:20:46,080
And they use a threshold encryption

432
00:20:46,980 --> 00:20:48,320
for these anonymity revokers,

433
00:20:48,320 --> 00:20:51,159
which is implemented by
Shamir Secret Sharing

434
00:20:51,160 --> 00:20:55,760
and indicates that they want
to encrypt a group element,

435
00:20:55,760 --> 00:20:58,900
we use ElGamal encryption.

436
00:20:58,900 --> 00:21:01,254
And in the case of
encrypting a field element,

437
00:21:01,254 --> 00:21:05,020
for example, the PRF
encrypting the PRF key,

438
00:21:05,020 --> 00:21:09,320
we use another encryption
scheme called the CL encryption.

439
00:21:09,320 --> 00:21:12,149
For the NIZK proof also we
use a field Fiat-Shamir NIZKs

440
00:21:12,150 --> 00:21:13,920
based on signal protocols

441
00:21:13,920 --> 00:21:17,623
in combination with the
zk-SNARKs on committed inputs.

442
00:21:19,120 --> 00:21:21,790
For the security analysis
as I said before,

443
00:21:21,790 --> 00:21:25,250
they make a threshold assumption
on the anonymity revokers

444
00:21:25,250 --> 00:21:28,110
such that even a malicious
identity provider

445
00:21:28,110 --> 00:21:31,209
with cooperating with the
malicious anonymity revoker,

446
00:21:31,210 --> 00:21:35,183
they cannot connect an
account to an account holder.

447
00:21:36,120 --> 00:21:37,659
And also for the security,

448
00:21:37,660 --> 00:21:40,430
we prove the security in the user model

449
00:21:40,430 --> 00:21:42,993
against a actively corrupt account holder.

450
00:21:44,800 --> 00:21:46,590
Passively corrupt identity providers

451
00:21:46,590 --> 00:21:49,679
and its threshold number
of passively corrupt

452
00:21:49,680 --> 00:21:50,843
anonymity revokers.

453
00:21:52,130 --> 00:21:54,240
Thanks for your attention.

454
00:21:54,240 --> 00:21:57,050
And the full version of
the paper is on e-print

455
00:21:57,050 --> 00:21:59,763
so if you're interested,
you can check it out.

456
00:22:02,120 --> 00:22:03,070
- Hi, I'm Yash.

457
00:22:03,070 --> 00:22:05,659
I'm a PhD candidate in
Northeastern University.

458
00:22:05,660 --> 00:22:07,180
And I'll be telling you about my work

459
00:22:07,180 --> 00:22:10,338
on non interactive half
aggregation of EdDSA

460
00:22:10,338 --> 00:22:12,055
and Schnorr signatures.

461
00:22:12,055 --> 00:22:17,055
This is joint work with Konstas,
Francois Garillot and Novi.

462
00:22:17,088 --> 00:22:18,090
So in this work,

463
00:22:18,090 --> 00:22:20,090
we study how to non interactively advocate

464
00:22:20,090 --> 00:22:22,959
Schnorr or EdDSA signatures using methods

465
00:22:22,960 --> 00:22:24,960
that don't depend on the exact code

466
00:22:24,960 --> 00:22:27,720
of the hash function and the group.

467
00:22:27,720 --> 00:22:30,679
And we design and implement
both of our constructions

468
00:22:30,679 --> 00:22:32,560
which achieve various trade offs

469
00:22:32,560 --> 00:22:34,790
in terms of efficiency and security.

470
00:22:34,790 --> 00:22:37,620
And we show that such techniques
are essentially optimal,

471
00:22:37,620 --> 00:22:40,003
and that they can't go
beyond 50% compression.

472
00:22:41,900 --> 00:22:43,900
Right, so a quick recap
of the characteristics

473
00:22:43,900 --> 00:22:47,020
of Schnorr signatures as follows.

474
00:22:47,020 --> 00:22:49,810
So what's good about them
is that you achieve security

475
00:22:49,810 --> 00:22:51,960
under conservative well
studied assumptions

476
00:22:51,960 --> 00:22:54,390
specifically, that is
the discrete log problem

477
00:22:54,390 --> 00:22:55,923
being hard in its group.

478
00:22:56,950 --> 00:22:59,700
And individual signatures
are quite compact

479
00:22:59,700 --> 00:23:03,060
and fast to generate and verify
as you may be instantiated

480
00:23:03,060 --> 00:23:04,909
in elliptic curve group for instance.

481
00:23:06,260 --> 00:23:07,950
Additionally, the linear structure

482
00:23:07,950 --> 00:23:09,980
allows efficient interactive aggregation,

483
00:23:09,980 --> 00:23:12,450
that is it's quite easy to
construct threshold signing

484
00:23:12,450 --> 00:23:14,470
and multi signature protocol Schnorr.

485
00:23:16,010 --> 00:23:18,045
But on the downside,

486
00:23:18,045 --> 00:23:21,640
we don't have any native
interactive aggregation.

487
00:23:21,640 --> 00:23:22,950
So in native non interactive

488
00:23:22,950 --> 00:23:24,630
aggregation procedures for Schnorr

489
00:23:24,630 --> 00:23:25,823
unlike say, BLS.

490
00:23:27,890 --> 00:23:31,600
What do I mean when I say a
non interactive aggregation?

491
00:23:31,600 --> 00:23:34,560
So let's say Alice has
a bunch of signatures

492
00:23:34,560 --> 00:23:37,133
under some public keys for some messages.

493
00:23:38,036 --> 00:23:40,160
Once she's collected these signatures,

494
00:23:40,160 --> 00:23:42,660
she wants to transmit them to Bob.

495
00:23:42,660 --> 00:23:44,570
The simple and naive way to do this

496
00:23:44,570 --> 00:23:48,850
would be to simply have Alice
send all of the signatures

497
00:23:48,850 --> 00:23:49,850
to Bob (indistinct),

498
00:23:51,090 --> 00:23:53,320
and this achieves this goal.

499
00:23:53,320 --> 00:23:56,270
But we can do something more
sophisticated in certain cases.

500
00:23:56,270 --> 00:23:59,139
That is we can have Alice
feed all of her signatures

501
00:23:59,140 --> 00:24:01,530
into some sort of aggregation machinery,

502
00:24:01,530 --> 00:24:03,910
which then outputs an aggregate signature,

503
00:24:03,910 --> 00:24:05,440
which combines the effect

504
00:24:05,440 --> 00:24:07,340
of all of these individual signatures.

505
00:24:09,060 --> 00:24:11,429
Alice can then send this
aggregated signature to Bob

506
00:24:11,430 --> 00:24:13,650
and based off the individual signatures

507
00:24:13,650 --> 00:24:16,000
and the advantage of doing such a thing

508
00:24:16,000 --> 00:24:18,090
is that presumably this
aggregate signature

509
00:24:18,090 --> 00:24:21,030
is lighter than these individual
signatures in some sense.

510
00:24:21,030 --> 00:24:23,410
In our case, it's going to mean that

511
00:24:23,410 --> 00:24:25,790
this aggregate signature
consumes less bandwidth

512
00:24:25,790 --> 00:24:27,520
than the individual signatures.

513
00:24:28,620 --> 00:24:31,000
As a simple application
of such a technique,

514
00:24:31,000 --> 00:24:33,460
we can compress blockchain blocks

515
00:24:33,460 --> 00:24:36,599
that is if we consider
each block in a blockchain

516
00:24:36,599 --> 00:24:39,610
to be comprised of a number
of individual signatures.

517
00:24:39,610 --> 00:24:41,280
Applying that aggregation machinery

518
00:24:41,280 --> 00:24:44,710
we can shrink these
blocks to smaller sizes

519
00:24:44,710 --> 00:24:45,853
and save on bandwidth.

520
00:24:48,220 --> 00:24:50,900
So the scope of our problem
is defined as follows.

521
00:24:50,900 --> 00:24:53,830
We look at the task of
constructing a proof of knowledge

522
00:24:53,830 --> 00:24:56,419
for the language of Schnorr signatures.

523
00:24:56,420 --> 00:24:58,450
That is an aggregate signature

524
00:24:58,450 --> 00:24:59,870
serves as a non interactive proof

525
00:24:59,870 --> 00:25:03,429
that the aggregator has
seen Schnorr signatures

526
00:25:03,430 --> 00:25:06,210
that correspond to those
public keys and messages

527
00:25:06,210 --> 00:25:07,687
known to the world.

528
00:25:08,800 --> 00:25:11,040
The idea is to use this
as a drop in replacement

529
00:25:11,040 --> 00:25:12,440
in any larger protocol

530
00:25:12,440 --> 00:25:14,990
that requires bunches
of Schnorr signatures

531
00:25:14,990 --> 00:25:16,123
to be centered on.

532
00:25:17,700 --> 00:25:21,260
And the idea is to get nice
composition guarantees from this

533
00:25:21,260 --> 00:25:24,157
that is the placing an
object in a larger protocol

534
00:25:24,157 --> 00:25:26,929
with a proof of knowledge of that object.

535
00:25:26,930 --> 00:25:30,090
Make sure that you don't
have to spend a lot of effort

536
00:25:30,090 --> 00:25:32,240
re-proving security of
the larger protocol.

537
00:25:35,240 --> 00:25:36,350
The thing is we already know

538
00:25:36,350 --> 00:25:38,330
how to build such compressing
proofs of knowledge

539
00:25:38,330 --> 00:25:40,179
take your favorite SNARK for example.

540
00:25:41,780 --> 00:25:43,530
While this establishes feasibility

541
00:25:43,530 --> 00:25:45,560
using a genetic SNARK for such a task

542
00:25:45,560 --> 00:25:48,312
is prohibitively expensive
for most applications.

543
00:25:49,320 --> 00:25:50,283
In particular,

544
00:25:52,920 --> 00:25:54,560
using a genetic technique

545
00:25:54,560 --> 00:25:57,889
would require like representing

546
00:25:57,890 --> 00:25:59,930
the hash function of Schnorr as a circuit

547
00:25:59,930 --> 00:26:02,190
and then feeding it into the SNARK.

548
00:26:02,190 --> 00:26:05,040
And for standard hash
functions such as SHA2

549
00:26:05,040 --> 00:26:06,710
that's used by EdDSA

550
00:26:06,710 --> 00:26:09,010
this induces a really large circuit

551
00:26:09,010 --> 00:26:11,593
and makes it quite expensive
for most applications.

552
00:26:13,060 --> 00:26:14,800
So, we introduced an additional constraint

553
00:26:14,800 --> 00:26:17,379
that whatever technique
we design must be blackbox

554
00:26:17,380 --> 00:26:18,400
in the hash function,

555
00:26:18,400 --> 00:26:20,170
that is use the hash function

556
00:26:20,170 --> 00:26:21,770
and group operations as oracles.

557
00:26:23,920 --> 00:26:25,710
So, our techniques are as follow.

558
00:26:25,710 --> 00:26:27,600
A quick recap of what the Sigma protocol

559
00:26:27,600 --> 00:26:29,062
is for a revelation.

560
00:26:29,063 --> 00:26:30,700
A prover has a witness W

561
00:26:30,700 --> 00:26:32,530
that proves membership in some language

562
00:26:32,530 --> 00:26:34,629
of some public statement X.

563
00:26:34,630 --> 00:26:36,610
So public instance X,

564
00:26:36,610 --> 00:26:40,510
the prover begins by
sending the first message A

565
00:26:40,510 --> 00:26:42,879
to which it is challenged
by the verifier of it E.

566
00:26:44,098 --> 00:26:46,163
And finally, the prover responses with Z.

567
00:26:47,630 --> 00:26:50,360
And the idea is that Sigma protocol

568
00:26:50,360 --> 00:26:51,689
has n-special soundness

569
00:26:51,690 --> 00:26:55,230
that is given n-accepting conversations

570
00:26:55,230 --> 00:26:58,120
such that they all share
the same first message A.

571
00:26:58,120 --> 00:26:59,919
There is an efficient method

572
00:26:59,920 --> 00:27:02,183
to extract a witness W for the statement.

573
00:27:04,230 --> 00:27:06,910
So within this framework, we
construct a Sigma protocol

574
00:27:06,910 --> 00:27:10,400
for the proving knowledge
of Schnorr signature.

575
00:27:10,400 --> 00:27:12,540
So recall that a Schnorr signature

576
00:27:12,540 --> 00:27:15,270
consists of these components a public key,

577
00:27:15,270 --> 00:27:16,443
a non skeptor R,

578
00:27:18,200 --> 00:27:19,360
E, that is the challenge

579
00:27:19,360 --> 00:27:21,927
that's the diode by hashing the public key

580
00:27:21,927 --> 00:27:23,419
the nonce and the message being signed.

581
00:27:23,420 --> 00:27:25,370
And S which is a linear combination

582
00:27:25,370 --> 00:27:27,669
of the public of the
secret key and the nonce.

583
00:27:29,790 --> 00:27:32,010
A Schnorr signature is
verified as follows.

584
00:27:32,010 --> 00:27:37,010
First, we compute capital S
as the same linear combination

585
00:27:37,060 --> 00:27:41,080
in the exponent that E
times the public key plus R.

586
00:27:41,080 --> 00:27:43,830
And then we check that
this lowercase S value

587
00:27:43,830 --> 00:27:47,240
is indeed the discrete
log of the capital S

588
00:27:47,240 --> 00:27:48,340
that we just computed.

589
00:27:50,270 --> 00:27:53,240
So observe that if we omit
this lowercase S value,

590
00:27:53,240 --> 00:27:56,390
we're still able to execute
the first step of verification,

591
00:27:56,390 --> 00:27:58,930
that is, we can still
compute this capital S,

592
00:27:58,930 --> 00:28:01,580
that's a combination of the
public key and the nonce.

593
00:28:02,930 --> 00:28:04,340
And I claim now that

594
00:28:04,340 --> 00:28:08,030
instead in place of
revealing this S value,

595
00:28:08,030 --> 00:28:10,879
this lowercase S value
directly to the verifier,

596
00:28:10,880 --> 00:28:13,140
it is just as good if we
gave a proof of knowledge

597
00:28:13,140 --> 00:28:14,920
of discrete log of capital S.

598
00:28:14,920 --> 00:28:16,877
And capital S is specified
by just the public key

599
00:28:16,877 --> 00:28:19,193
and the nonce and the message.

600
00:28:21,600 --> 00:28:23,669
The second tool that
we use for compression

601
00:28:23,670 --> 00:28:27,820
is the standard tool of
compressing proofs knowledge

602
00:28:27,820 --> 00:28:30,570
from multiple discrete log instances.

603
00:28:30,570 --> 00:28:32,280
And this proceeds as follows.

604
00:28:32,280 --> 00:28:33,113
For

605
00:28:34,480 --> 00:28:36,840
a number of public let's
say, elliptic curve points

606
00:28:36,840 --> 00:28:38,889
capital X one to capital Xn,

607
00:28:38,890 --> 00:28:42,406
Alice possesses that
discrete logs lowercase X,

608
00:28:42,406 --> 00:28:44,352
X one to lowercase Xn.

609
00:28:45,820 --> 00:28:48,189
Bob, who is the verifier challenges Alice

610
00:28:48,190 --> 00:28:51,340
to reveal some linear combination
of these our discrete logs

611
00:28:51,340 --> 00:28:53,783
that is he sends over value E and Zq.

612
00:28:55,060 --> 00:28:58,820
And Alice computes a linear
combination of these Xi values

613
00:28:58,820 --> 00:29:00,649
where the coefficient of the (indistinct)

614
00:29:00,650 --> 00:29:02,910
at the linear combination is just E

615
00:29:02,910 --> 00:29:04,510
raised to the power I minus one.

616
00:29:06,220 --> 00:29:08,135
Alice then sends combination Z,

617
00:29:08,135 --> 00:29:11,283
which Bob can check in the
exponent for correctness.

618
00:29:13,570 --> 00:29:16,139
So what this achieves
is n-special soundness

619
00:29:16,140 --> 00:29:18,770
specifically given
n-excepting conversations,

620
00:29:18,770 --> 00:29:21,820
we now have n-linearly
independent combinations

621
00:29:21,820 --> 00:29:22,990
of these Xi values.

622
00:29:22,990 --> 00:29:24,830
So that's n equations and n unknowns,

623
00:29:24,830 --> 00:29:26,629
and we can simply solve for each Xi.

624
00:29:29,280 --> 00:29:30,840
So now we can combine these two tools

625
00:29:30,840 --> 00:29:32,429
to get a compress Sigma protocol

626
00:29:32,430 --> 00:29:34,580
to prove knowledge of
n Schnorr signatures.

627
00:29:36,360 --> 00:29:38,250
This (indistinct) as follows,

628
00:29:38,250 --> 00:29:39,940
given that the messages and public keys

629
00:29:39,940 --> 00:29:41,840
are known to both the
prover and the verifier,

630
00:29:41,840 --> 00:29:46,266
the prover, Alice, additionally
has signatures Ri and Si

631
00:29:46,267 --> 00:29:47,554
for each I and M

632
00:29:47,554 --> 00:29:49,850
and the prover then
sends over these nonces

633
00:29:49,850 --> 00:29:51,743
these R, S to the verifier Bob.

634
00:29:53,120 --> 00:29:55,280
The verifier then for each I and M

635
00:29:55,280 --> 00:29:58,920
executes the first step of
the verification process

636
00:29:58,920 --> 00:30:00,990
that is computing this capital Si,

637
00:30:00,990 --> 00:30:04,041
as a linear combination of
the public key and the nonce,

638
00:30:04,041 --> 00:30:08,659
where the combination is baited
by hashing the public key,

639
00:30:08,660 --> 00:30:09,960
the nonce and the message.

640
00:30:11,760 --> 00:30:14,673
The verifier then sends
the challenge E and Zq,

641
00:30:15,647 --> 00:30:18,740
which the prover uses
the same way as earlier

642
00:30:18,740 --> 00:30:23,133
to compute a linear
combination of its Si values,

643
00:30:23,969 --> 00:30:27,170
where the (indistinct) quotation
does equal Vi minus one,

644
00:30:27,170 --> 00:30:28,290
I'll call this Z.

645
00:30:28,290 --> 00:30:30,651
Once Z is sent over to the verifier,

646
00:30:30,651 --> 00:30:34,170
he can then check that this relation does

647
00:30:34,170 --> 00:30:35,833
indeed hold in the exponent.

648
00:30:38,280 --> 00:30:41,010
So what this accomplishes is that

649
00:30:41,010 --> 00:30:42,580
whereas naive transmission requires

650
00:30:42,580 --> 00:30:44,872
sending each other in Si for I and M,

651
00:30:45,710 --> 00:30:48,060
the compressed Sigma
protocols requires you

652
00:30:48,060 --> 00:30:50,440
to send only the Ri values

653
00:30:50,440 --> 00:30:53,640
and also a single Z in
place of all the S values.

654
00:30:53,640 --> 00:30:56,070
And given that R and S
that from the same size

655
00:30:56,070 --> 00:30:58,403
this is essentially 50% compression.

656
00:31:00,760 --> 00:31:02,660
So now what we have is a Sigma protocol,

657
00:31:02,660 --> 00:31:03,580
which is interactive,

658
00:31:03,580 --> 00:31:05,822
but what we want is a
non interactive proof.

659
00:31:07,110 --> 00:31:09,520
That a standard compilers
to go from a Sigma protocol

660
00:31:09,520 --> 00:31:11,320
to a non interactive proof of knowledge

661
00:31:11,320 --> 00:31:14,730
such as Fiat-Shamir, which
achieves optimal efficiency

662
00:31:14,730 --> 00:31:16,670
at the cost of loose security proof.

663
00:31:16,670 --> 00:31:20,200
All that efficient, which
gives us a tight security proof

664
00:31:20,200 --> 00:31:21,633
by the reduced efficiency.

665
00:31:23,680 --> 00:31:26,430
We implement and benchmark
both constructions

666
00:31:26,430 --> 00:31:29,260
using the Dalek library for EdDSA.

667
00:31:29,260 --> 00:31:32,350
And our takeaway is that
the Fiat-Shamir construction

668
00:31:32,350 --> 00:31:33,659
is already very practical.

669
00:31:33,660 --> 00:31:36,030
And that you can aggregate
over 1000 signatures

670
00:31:36,030 --> 00:31:37,680
in less than a millisecond.

671
00:31:37,680 --> 00:31:40,640
And verifying these and
verifying an aggregate signature

672
00:31:40,640 --> 00:31:41,690
comes with no penalty

673
00:31:43,125 --> 00:31:44,520
because it costs the same as verifying

674
00:31:44,520 --> 00:31:47,070
1000 signatures by themselves
and the (indistinct).

675
00:31:48,380 --> 00:31:50,070
Fischlin transformation on the other hand,

676
00:31:50,070 --> 00:31:52,281
gives a much more extensive
object to compute and verify

677
00:31:52,281 --> 00:31:53,929
but it does give tight security

678
00:31:53,930 --> 00:31:56,770
and achieves close to 50% compression

679
00:31:56,770 --> 00:31:58,620
as the number of signatures increase.

680
00:32:01,420 --> 00:32:03,850
It's natural to ask, if
we can do any better.

681
00:32:03,850 --> 00:32:07,838
That is, if we can achieve any
better than 50% compression.

682
00:32:07,838 --> 00:32:09,540
Unfortunately, we show
that this compression data

683
00:32:09,540 --> 00:32:12,370
is essentially optimal
for any aggregation scheme

684
00:32:12,370 --> 00:32:15,020
that makes Oracle uses the
hash function and Schnorr.

685
00:32:16,160 --> 00:32:17,820
What this means is that

686
00:32:17,820 --> 00:32:21,610
going beyond this 50% compression rate

687
00:32:21,610 --> 00:32:24,340
must inherently depend on the
code if the hash function.

688
00:32:24,340 --> 00:32:26,310
And unfortunately, all
methods that we know

689
00:32:26,310 --> 00:32:29,940
that make non blackbox use of
the code of the hash function

690
00:32:29,940 --> 00:32:31,210
are quite expensive.

691
00:32:31,210 --> 00:32:32,043
For instance,

692
00:32:32,043 --> 00:32:34,969
feeding the expression the
hash function as a circuit

693
00:32:34,970 --> 00:32:38,100
and then feeding the circuit
into a SNARK for proving.

694
00:32:38,100 --> 00:32:40,459
And this can get quite expensive
in practice for instance,

695
00:32:40,460 --> 00:32:43,320
for EdDSA proving
knowledge of n signatures

696
00:32:43,320 --> 00:32:46,223
would imply proving knowledge
of n SHA2 pre-images.

697
00:32:48,680 --> 00:32:51,440
So I encourage you to see
the paper for our discussions

698
00:32:51,440 --> 00:32:54,010
on how to use these
constructions, optimizations

699
00:32:54,010 --> 00:32:55,683
and generally more discussions.

700
00:32:57,450 --> 00:33:01,470
So how to apply these constructions
in your own protocol is

701
00:33:01,470 --> 00:33:04,340
first see if your higher
level protocol involves

702
00:33:04,340 --> 00:33:06,649
sending out large batches of signatures

703
00:33:06,650 --> 00:33:10,380
and ask if the exact bit
representations of these batches

704
00:33:10,380 --> 00:33:12,030
are really that important.

705
00:33:12,030 --> 00:33:14,530
And if not, then you can apply
on aggregation construction

706
00:33:14,530 --> 00:33:16,879
to maybe save up to 50% in bandwidth

707
00:33:16,880 --> 00:33:18,680
when the signatures are transmitted.

708
00:33:21,210 --> 00:33:22,420
Thank you for your attention.

709
00:33:22,420 --> 00:33:24,750
And please do check out our work online

710
00:33:24,750 --> 00:33:28,262
and the code is available
publicly on GitHub as well.

711
00:33:28,262 --> 00:33:29,095
Thanks.

