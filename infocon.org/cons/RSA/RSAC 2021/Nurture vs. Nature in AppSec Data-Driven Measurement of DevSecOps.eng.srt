1
00:00:01,410 --> 00:00:04,900
- Hi, my name is Jay Jacobs
I'm chief data scientist

2
00:00:04,900 --> 00:00:07,123
and a partner at Cyentia Institute.

3
00:00:08,020 --> 00:00:11,059
I worked on the Verizon DBIR and I've been

4
00:00:11,060 --> 00:00:13,300
a data scientist for a
number of years and working

5
00:00:13,300 --> 00:00:16,930
in security for 20 plus
years and so it's great

6
00:00:16,930 --> 00:00:18,393
to be presenting at RSA.

7
00:00:19,320 --> 00:00:23,000
My co-presenter Ben Edwards,
is a senior data scientist

8
00:00:23,000 --> 00:00:25,190
with me at Cyentia Institute.

9
00:00:25,190 --> 00:00:29,320
He's got a PhD from
University of New Mexico.

10
00:00:29,320 --> 00:00:33,230
And he will be joining talking
about some some stuff later

11
00:00:33,230 --> 00:00:35,730
on in the slides and I'm
gonna start out here, so.

12
00:00:37,110 --> 00:00:38,690
So what we're gonna cover today

13
00:00:38,690 --> 00:00:41,309
we're talking about
application security and some

14
00:00:41,310 --> 00:00:44,810
of the fun things about it and some

15
00:00:44,810 --> 00:00:47,370
of the security aspects
associated with that.

16
00:00:47,370 --> 00:00:50,540
And so this is gonna be a
very, very data-driven talk

17
00:00:50,540 --> 00:00:54,320
and so we're gonna talk about
a lot of application data

18
00:00:54,320 --> 00:00:56,470
a lot of flaws and the fixed times and

19
00:00:56,470 --> 00:00:57,350
a whole bunch of stuff.

20
00:00:57,350 --> 00:01:01,350
And so first we wanna cover
where this data came from

21
00:01:01,350 --> 00:01:05,010
and then that helps
establish the frame, set up

22
00:01:05,010 --> 00:01:07,040
any potential biases in the data.

23
00:01:07,040 --> 00:01:08,430
Then we're gonna talk about just sort of

24
00:01:08,430 --> 00:01:11,080
an introduction, set a foundation about

25
00:01:11,080 --> 00:01:13,830
how secure are applications.

26
00:01:13,830 --> 00:01:15,980
And then, we're gonna talk little bit

27
00:01:15,980 --> 00:01:18,610
about remediation fixed
times things like that

28
00:01:18,610 --> 00:01:21,310
and then we're gonna get
into how does the language

29
00:01:21,310 --> 00:01:23,480
the development language affect security

30
00:01:23,480 --> 00:01:26,300
and what do we see across
different languages.

31
00:01:26,300 --> 00:01:28,509
Then we're gonna get into
some open source stuff talk

32
00:01:28,510 --> 00:01:31,210
about open source libraries,
third party libraries

33
00:01:31,210 --> 00:01:32,776
and inclusion in the applications

34
00:01:32,777 --> 00:01:34,940
and what that does for security.

35
00:01:34,940 --> 00:01:37,840
And then the best part I
think of the whole talk

36
00:01:37,840 --> 00:01:41,280
is gonna be this last section
where we talk about, looking

37
00:01:41,280 --> 00:01:44,840
at that remediation and look at attributes

38
00:01:44,840 --> 00:01:48,070
that can contribute to faster
or slower fixed times now

39
00:01:48,070 --> 00:01:51,363
there'll be the nature versus
nurture part of the talk.

40
00:01:52,900 --> 00:01:56,040
So let's start out and
talk about the data here.

41
00:01:56,040 --> 00:01:57,310
Essentially we're looking

42
00:01:57,310 --> 00:02:01,278
at 130,000 applications over 130,000.

43
00:02:01,278 --> 00:02:03,290
And depending on how we slice
it it'll be a little bit less

44
00:02:03,290 --> 00:02:05,460
than that depending on
what we're looking at.

45
00:02:05,460 --> 00:02:09,320
But this is all coming from
Veracode customers and a lot

46
00:02:09,320 --> 00:02:11,380
of this is covered in the volume 11

47
00:02:11,380 --> 00:02:13,359
of State of The Software
Security report, which

48
00:02:13,360 --> 00:02:14,513
is free to download.

49
00:02:15,600 --> 00:02:19,340
And so we've got this
this bias in there that

50
00:02:19,340 --> 00:02:23,570
these applications are from
organizations that are vested

51
00:02:23,570 --> 00:02:25,090
in security already.

52
00:02:25,090 --> 00:02:28,070
And so this might be
perhaps overestimating some

53
00:02:28,070 --> 00:02:29,609
of the security aspects because they

54
00:02:29,610 --> 00:02:32,850
are already putting money
into and putting their time

55
00:02:32,850 --> 00:02:34,340
into security aspects.

56
00:02:34,340 --> 00:02:37,753
And so, just got to keep that
in mind might actually be

57
00:02:37,753 --> 00:02:39,630
that the whole world might
be a little bit worse

58
00:02:39,630 --> 00:02:41,960
than the data we're looking
at, but I think that's good.

59
00:02:41,960 --> 00:02:44,320
I think that we're looking
at sort of best case

60
00:02:44,320 --> 00:02:47,810
of companies actually
investing in security.

61
00:02:47,810 --> 00:02:51,880
We have over a million
code scans over the amount

62
00:02:51,880 --> 00:02:54,859
of data we have here
and it's a lot of data.

63
00:02:54,860 --> 00:02:57,970
We have over 10 million
findings that has flaws that

64
00:02:57,970 --> 00:03:01,010
have been found typically
from static analysis

65
00:03:01,010 --> 00:03:03,429
other we're gonna look
at some dynamic analysis

66
00:03:03,430 --> 00:03:04,303
and stuff too.

67
00:03:05,240 --> 00:03:06,640
And one of the things that we're doing

68
00:03:06,640 --> 00:03:08,790
is that we're gonna
analyze the full history

69
00:03:08,790 --> 00:03:11,450
of any active applications,
what we've done

70
00:03:11,450 --> 00:03:13,429
in previous state of
software security reports

71
00:03:13,430 --> 00:03:15,740
and sort of look at the last 12 months.

72
00:03:15,740 --> 00:03:18,500
And this year we're taking
a look at the full history

73
00:03:18,500 --> 00:03:21,630
from when an application came
on board for the first time,

74
00:03:21,630 --> 00:03:22,980
to the last time it was scanned right

75
00:03:22,980 --> 00:03:24,950
before we pulled the data.

76
00:03:24,950 --> 00:03:28,130
And again, this is volume 11 of the State

77
00:03:28,130 --> 00:03:31,190
of Software Security
report through Veracode

78
00:03:31,190 --> 00:03:33,700
and we are not, employees of Veracode we

79
00:03:33,700 --> 00:03:35,869
are independent researchers
that work with Veracode

80
00:03:35,870 --> 00:03:38,590
on this so.

81
00:03:38,590 --> 00:03:41,630
Let's get into the actual
security aspect here.

82
00:03:41,630 --> 00:03:43,310
So, let's first talk about

83
00:03:43,310 --> 00:03:45,580
how common our application flaws.

84
00:03:45,580 --> 00:03:48,430
If you think of an
application, what is the chance

85
00:03:48,430 --> 00:03:51,050
that static code analysis
would find some type

86
00:03:51,050 --> 00:03:52,480
of flaw in it?

87
00:03:52,480 --> 00:03:55,700
And so most applications at
some point or another have

88
00:03:55,700 --> 00:03:57,339
at least one flaw.

89
00:03:57,340 --> 00:04:00,310
And then this is completely
independent of application size.

90
00:04:00,310 --> 00:04:03,110
So this might be one, 10 lines of code for

91
00:04:03,110 --> 00:04:07,050
a small quick library in
JavaScript or it could be, 10 gig

92
00:04:07,050 --> 00:04:09,340
of files in Java.

93
00:04:09,340 --> 00:04:13,140
And so, could be any size
and so across there obviously

94
00:04:13,140 --> 00:04:15,320
the larger apps are gonna have more flaws.

95
00:04:15,320 --> 00:04:18,560
But just blanket regardless
of size what we see

96
00:04:18,560 --> 00:04:22,520
is about three out of four
will have some type of flaw.

97
00:04:22,520 --> 00:04:24,840
But on the bottom side we
see about one out of four

98
00:04:24,840 --> 00:04:27,169
has high severity and that's high

99
00:04:27,170 --> 00:04:31,120
or critical severity ranking
in the Veracode platform.

100
00:04:31,120 --> 00:04:34,720
The middle two, if the flaw
is one of the things listed

101
00:04:34,720 --> 00:04:39,333
in the OWASP top 10, we see
about 66 two out of three, 66%

102
00:04:40,700 --> 00:04:44,099
of those have at least
one OWASP top 10 flaw.

103
00:04:44,100 --> 00:04:46,070
And then the SANS top 25
but I think that's now

104
00:04:46,070 --> 00:04:48,580
the CWE top 25.

105
00:04:48,580 --> 00:04:51,890
But when we were looking at
it was still the SANS 25.

106
00:04:51,890 --> 00:04:56,890
I mean, we see about 60% of
things in that top 25 from SANS.

107
00:04:57,000 --> 00:05:00,240
So, and we're seeing that
relatively consistent even

108
00:05:00,240 --> 00:05:03,640
from volume one up to volume
11 hanging right around

109
00:05:03,640 --> 00:05:07,729
that three out of four applications
have at least one flaw.

110
00:05:07,730 --> 00:05:09,430
Now when we take into account the size of

111
00:05:09,430 --> 00:05:12,550
the application we see some
really interesting things here.

112
00:05:12,550 --> 00:05:15,180
If you notice these are trying
to show the distributions

113
00:05:15,180 --> 00:05:19,560
and that the number of flaws
per one megabyte of code.

114
00:05:19,560 --> 00:05:22,480
And this is gonna vary based
on the language things like

115
00:05:22,480 --> 00:05:24,840
that some are a little bit
more dense, some spread out.

116
00:05:24,840 --> 00:05:27,311
But the cool thing is if you notice

117
00:05:27,311 --> 00:05:31,450
the distributions here, you
see how they're pretty smooth.

118
00:05:31,450 --> 00:05:32,840
I think that's a really interesting thing

119
00:05:32,840 --> 00:05:35,460
and that's personally an
artifact of the amount

120
00:05:35,460 --> 00:05:37,080
of data that we have here.

121
00:05:37,080 --> 00:05:39,530
And that it's just sort
of a smooth distribution

122
00:05:39,530 --> 00:05:43,222
from basically one in a hundred million.

123
00:05:45,120 --> 00:05:47,420
So if you look at the left to the right

124
00:05:47,420 --> 00:05:52,210
we're seeing things going
from relatively not dense

125
00:05:52,210 --> 00:05:54,890
at all a whole bunch of
code and very few flaws.

126
00:05:54,890 --> 00:05:57,669
To on the right side of you
see a whole bunch of flaws

127
00:05:57,670 --> 00:06:00,040
and perhaps not that much code.

128
00:06:00,040 --> 00:06:03,160
But, again we're seeing that
distribution any flaws there's

129
00:06:03,160 --> 00:06:05,960
a lot more on the critical
flaws there's less,

130
00:06:05,960 --> 00:06:08,520
but there is this wide distribution
that's what we're trying

131
00:06:08,520 --> 00:06:09,353
to get at here.

132
00:06:09,353 --> 00:06:11,700
There are some that
have a tremendous amount

133
00:06:11,700 --> 00:06:15,229
of critical flaws for the amount
of code that they have so.

134
00:06:15,230 --> 00:06:17,580
And that's sort of what
we're getting at there.

135
00:06:19,130 --> 00:06:22,360
So, getting away from sort
of these general statements

136
00:06:22,360 --> 00:06:25,700
about flaws we wanna take
a look at what flaw types

137
00:06:25,700 --> 00:06:27,440
are most common.

138
00:06:27,440 --> 00:06:30,990
And so at the top here what we see

139
00:06:30,990 --> 00:06:34,730
is things like information
leakage, CRLF injection.

140
00:06:34,730 --> 00:06:37,110
And some of these aren't critical

141
00:06:37,110 --> 00:06:39,760
and we have another problem
too is we classify these

142
00:06:39,760 --> 00:06:44,760
these are taken from CWE, the
common weakness enumeration.

143
00:06:46,140 --> 00:06:49,890
And that trying to put
these things in a bucket

144
00:06:49,890 --> 00:06:51,810
is very difficult and
so if you take a look

145
00:06:51,810 --> 00:06:55,100
at something like
insufficient input validation

146
00:06:55,100 --> 00:07:00,100
the sixth one down that is
sort of a blanket catch-all

147
00:07:00,150 --> 00:07:00,983
but if you take

148
00:07:00,983 --> 00:07:04,330
a look like CRLF injection,
directory traversal.

149
00:07:04,330 --> 00:07:06,680
Cross-site scripting, SQL
injection all of those

150
00:07:06,680 --> 00:07:09,520
are also insufficient input validation.

151
00:07:09,520 --> 00:07:11,870
And so, it's a little bit
hard trying to try to keep

152
00:07:11,870 --> 00:07:13,690
them in their own bucket
and things like that.

153
00:07:13,690 --> 00:07:16,320
But we see a lot of that
upfront, we see a lot of

154
00:07:16,320 --> 00:07:19,590
that insufficient input
validation so that's one

155
00:07:19,590 --> 00:07:21,619
of the key things and that's
obviously in the top 10

156
00:07:21,620 --> 00:07:23,820
for OWASP and things like that.

157
00:07:23,820 --> 00:07:26,530
Some other interesting things,
obviously some of these

158
00:07:26,530 --> 00:07:29,859
have been around for so long
still talking about them

159
00:07:29,860 --> 00:07:30,870
since the dawn of time.

160
00:07:30,870 --> 00:07:31,860
So like on the bottom we've

161
00:07:31,860 --> 00:07:35,410
got buffer overflow, buffer
management errors, things like

162
00:07:35,410 --> 00:07:37,050
that they're still around.

163
00:07:37,050 --> 00:07:39,580
But what we're seeing is that
some of the languages make

164
00:07:39,580 --> 00:07:41,349
that a non issue.

165
00:07:41,350 --> 00:07:45,280
So buffer overflow in Java
it's a really tricky thing

166
00:07:45,280 --> 00:07:48,063
to get in an application
to have that happen, but.

167
00:07:49,230 --> 00:07:51,690
So, it's interesting just
to see this distribution

168
00:07:51,690 --> 00:07:52,860
and talk about them.

169
00:07:52,860 --> 00:07:56,630
Now we can also look at
how dense are these flaws

170
00:07:56,630 --> 00:07:58,120
in the code.

171
00:07:58,120 --> 00:08:00,780
So again, we're gonna look at
the percent of applications

172
00:08:00,780 --> 00:08:05,710
with the flow type across
the X-axis to the horizontal.

173
00:08:05,710 --> 00:08:08,580
And then vertically up
and down, things that have

174
00:08:08,580 --> 00:08:11,159
that appear more often
in application are gonna

175
00:08:11,160 --> 00:08:14,030
be higher up and things that
appear really infrequently

176
00:08:14,030 --> 00:08:14,863
are gonna be lower down.

177
00:08:14,863 --> 00:08:18,210
So like in the top right
we've got CRLF Injection

178
00:08:18,210 --> 00:08:20,760
so it's in a lot of
applications and when it's in

179
00:08:20,760 --> 00:08:24,469
an application, it's in there
repeatedly 10 to 11 times

180
00:08:24,470 --> 00:08:27,380
on average across the application.

181
00:08:27,380 --> 00:08:30,594
In the upper left you see
coding standards when it's not

182
00:08:30,595 --> 00:08:35,070
a whole lot of applications
but when it's in there

183
00:08:35,070 --> 00:08:36,370
it's in there a whole lot.

184
00:08:37,530 --> 00:08:40,159
And so it's just interesting
seeing this sort of flow

185
00:08:40,159 --> 00:08:43,559
from not a lot of apps,
not a lot of spread

186
00:08:43,559 --> 00:08:45,800
in the application up to the upper right

187
00:08:45,800 --> 00:08:49,579
where it's in a whole lot
of applications and we see

188
00:08:49,580 --> 00:08:52,780
it a lot more in the density.

189
00:08:52,780 --> 00:08:55,339
Now this is taken from
the report and we're

190
00:08:55,340 --> 00:08:58,620
what we're talking about
is these flaws and so, you

191
00:08:58,620 --> 00:09:01,180
might be perceived the best
thing here is to just not put

192
00:09:01,180 --> 00:09:04,530
in the code in the first
place which is good but really

193
00:09:04,530 --> 00:09:07,770
for security teams, for
dev ops, for developers

194
00:09:07,770 --> 00:09:12,329
what you wanna do is be able
to recover and fail safe here

195
00:09:12,330 --> 00:09:13,816
on these flaws.

196
00:09:13,816 --> 00:09:15,140
And so you wanna be able to remediate

197
00:09:15,140 --> 00:09:18,720
these flaws quickly and thoroughly.

198
00:09:18,720 --> 00:09:22,520
And so we're gonna talk
about how spread out are

199
00:09:22,520 --> 00:09:26,790
these time-wise, how long
does it take to remediate

200
00:09:26,790 --> 00:09:29,189
and then how many are
actually being remediated.

201
00:09:30,830 --> 00:09:32,910
So when we take a look
at that this is how many

202
00:09:32,910 --> 00:09:34,030
are actually fixed.

203
00:09:34,030 --> 00:09:39,030
So out of all the flaws on
the bottom roughly 72.6%, 73%

204
00:09:40,320 --> 00:09:42,960
of all flaws will eventually be remediated

205
00:09:42,960 --> 00:09:47,960
which means, roughly 27% are still open at

206
00:09:48,030 --> 00:09:49,630
the time we pulled this data.

207
00:09:49,630 --> 00:09:52,540
And that's gonna that's gonna
remain relatively constant.

208
00:09:52,540 --> 00:09:55,420
We're gonna have flaws closed
out but we're gonna discover

209
00:09:55,420 --> 00:09:56,550
some new ones.

210
00:09:56,550 --> 00:09:59,469
We're probably gonna hang
right around this ratio.

211
00:09:59,470 --> 00:10:03,630
And then you look up to like
high severity 82% roughly

212
00:10:03,630 --> 00:10:06,760
about seven out of eight are
gonna be fixed, but we still

213
00:10:06,760 --> 00:10:09,873
have roughly one out of eight
sort of hanging out there.

214
00:10:11,140 --> 00:10:14,189
And so it's interesting to
think about and it's always hard

215
00:10:14,190 --> 00:10:16,510
there's always gonna be
flaws out there that we want

216
00:10:16,510 --> 00:10:17,593
to go in after.

217
00:10:19,340 --> 00:10:23,000
And if we talk about over
time we're gonna get into time

218
00:10:23,000 --> 00:10:25,040
a little bit more later, some of

219
00:10:25,040 --> 00:10:27,740
the actual speed of remediation.

220
00:10:27,740 --> 00:10:32,350
But this is gonna look at
the capacity to remediate.

221
00:10:32,350 --> 00:10:34,040
And so if you think of an application

222
00:10:34,040 --> 00:10:36,477
as a living organism we wanna know

223
00:10:36,477 --> 00:10:39,650
our applications generally
reducing the amount of flaws,

224
00:10:39,650 --> 00:10:42,740
the flaw density that we
see in the applications or

225
00:10:42,740 --> 00:10:45,170
are they getting worse, are
they adding a bunch of features

226
00:10:45,170 --> 00:10:46,420
and a bunch of code in there

227
00:10:46,420 --> 00:10:48,400
and actually introducing more bugs?

228
00:10:48,400 --> 00:10:49,620
So what we see is when we look

229
00:10:49,620 --> 00:10:53,280
at all flaws actually across
all of these categories

230
00:10:53,280 --> 00:10:56,530
there are more applications
that are reducing the amount

231
00:10:56,530 --> 00:11:00,480
of flaws then that are
increasing the flaws, the yellow

232
00:11:01,321 --> 00:11:02,154
on the right.

233
00:11:02,154 --> 00:11:03,520
And then a lot of them have
no change especially as we get

234
00:11:03,520 --> 00:11:04,730
to high severity.

235
00:11:04,730 --> 00:11:07,170
A lot of them just either
close them out right away

236
00:11:07,170 --> 00:11:09,270
and just keep them closed
and anything new comes up

237
00:11:09,270 --> 00:11:10,449
they close them right away.

238
00:11:10,450 --> 00:11:13,610
So they're mainly
maintaining the flaw density

239
00:11:13,610 --> 00:11:15,763
of high severity hopefully to zero.

240
00:11:16,810 --> 00:11:18,839
But we do see it on the
right we see these features

241
00:11:18,840 --> 00:11:22,330
being added things like that
are increasing the amount

242
00:11:22,330 --> 00:11:25,400
of flaw density in applications
which isn't necessarily

243
00:11:25,400 --> 00:11:26,653
a great thing so.

244
00:11:27,810 --> 00:11:30,599
And so it's nice to see the
spread though, there's a lot

245
00:11:30,600 --> 00:11:33,840
of variations a lot of
variety in these applications.

246
00:11:33,840 --> 00:11:36,530
And let's talk about the language though

247
00:11:36,530 --> 00:11:39,949
because this I think gets
into an interesting aspect

248
00:11:39,950 --> 00:11:42,960
because, a lot of people will
generally stick to language

249
00:11:42,960 --> 00:11:46,630
that they know and or they're
used to something and so

250
00:11:46,630 --> 00:11:50,807
they focus on that and we'll
get new applications in there.

251
00:11:50,807 --> 00:11:54,550
And so when we look at
the type of languages

252
00:11:54,550 --> 00:11:58,089
that we see across industries,
largely we see Java and .Net.

253
00:11:58,089 --> 00:12:01,780
Those are dominating the landscape.

254
00:12:01,780 --> 00:12:04,020
It's a little interesting
since we see government sort

255
00:12:04,020 --> 00:12:07,329
of as a odd ball here second
from the bottom, where

256
00:12:07,330 --> 00:12:10,610
we see more .Net than Java otherwise, we

257
00:12:10,610 --> 00:12:14,150
almost exclusively see more
Java than .Net but those two

258
00:12:14,150 --> 00:12:16,030
are absolutely dominating.

259
00:12:16,030 --> 00:12:17,430
Then we see some JavaScript in

260
00:12:17,430 --> 00:12:20,880
the third place, roughly
one out of six applications

261
00:12:20,880 --> 00:12:23,630
are JavaScript depending on the industry

262
00:12:23,630 --> 00:12:25,240
and then the others.

263
00:12:25,240 --> 00:12:29,540
And that's, Python, Android,
PHP, C++ and there's Ruby

264
00:12:29,540 --> 00:12:32,920
and just a whole bunch of other
languages sorta going along

265
00:12:32,920 --> 00:12:33,992
that tail there.

266
00:12:35,860 --> 00:12:40,860
Now if we take a look at
the top 10 flaws that we saw

267
00:12:41,290 --> 00:12:44,290
on that bar chart, I think
these are most of the top 10

268
00:12:44,290 --> 00:12:45,459
there but we're looking at

269
00:12:45,460 --> 00:12:47,900
these top 10 across the languages.

270
00:12:47,900 --> 00:12:50,510
And so what you notice
right away is that none

271
00:12:50,510 --> 00:12:51,990
of these look the same.

272
00:12:51,990 --> 00:12:53,490
So these flaws are gonna

273
00:12:53,490 --> 00:12:55,840
be very very different across languages.

274
00:12:55,840 --> 00:12:57,870
Like in Java you see that CRLF Injection.

275
00:12:57,870 --> 00:12:59,910
Cross-site scripting the upper right.

276
00:12:59,910 --> 00:13:02,800
When we look at PHP you just
see the cross-site scripting.

277
00:13:02,800 --> 00:13:06,000
Python, most of these
specific flaws are down

278
00:13:06,000 --> 00:13:08,420
in the lower left meaning not
a lot of applications have

279
00:13:08,420 --> 00:13:10,719
it, when they have it
they're not very intense

280
00:13:10,720 --> 00:13:13,993
they're not very dense in the application.

281
00:13:13,993 --> 00:13:16,840
But when we take these
languages and look at the top 10

282
00:13:16,840 --> 00:13:20,519
within each language, we get
a very different story here

283
00:13:20,519 --> 00:13:22,820
and I think this is
really, really interesting.

284
00:13:22,820 --> 00:13:25,670
So first you can notice with
the red being a high proportion

285
00:13:25,670 --> 00:13:28,900
of applications, that PHP
really sticks out that there are

286
00:13:28,900 --> 00:13:31,860
a lot roughly three out
of four applications have

287
00:13:31,860 --> 00:13:35,463
had cross-site scripting problems
when it's written in PHP.

288
00:13:35,463 --> 00:13:36,949
Whereas something like Java script

289
00:13:36,950 --> 00:13:39,440
where cross-site scripting
is also number one,

290
00:13:39,440 --> 00:13:42,680
but roughly under a third
compared to three out

291
00:13:42,680 --> 00:13:45,050
of four for PHP.

292
00:13:45,050 --> 00:13:46,890
So you see some really stark differences

293
00:13:46,890 --> 00:13:48,400
here across the languages.

294
00:13:48,400 --> 00:13:49,680
And even looking across

295
00:13:49,680 --> 00:13:52,609
the top two like .Net you
see information liquids

296
00:13:52,610 --> 00:13:54,910
and code quality and the third one being

297
00:13:54,910 --> 00:13:56,719
that insufficient input validation.

298
00:13:56,720 --> 00:13:59,740
C++ error handling and buffer management.

299
00:13:59,740 --> 00:14:01,890
Even though there was a
small proportion overall

300
00:14:01,890 --> 00:14:04,480
of the flaws it is a huge thing in C++

301
00:14:04,480 --> 00:14:06,300
that buffer management.

302
00:14:06,300 --> 00:14:09,240
In Java you have that
CRFL injection problem.

303
00:14:09,240 --> 00:14:13,910
Code quality and the information
leakage similar to .Net

304
00:14:13,910 --> 00:14:17,050
and some of those JavaScript, we get

305
00:14:17,050 --> 00:14:19,770
the cross-site scripting as well as PHP.

306
00:14:19,770 --> 00:14:21,780
Python we get some cryptographic issues

307
00:14:21,780 --> 00:14:23,410
in the cross-site scripting so.

308
00:14:23,410 --> 00:14:25,689
Depending on the language
that you like to work in

309
00:14:25,690 --> 00:14:29,240
and intend to work in,
you're gonna wanna be aware

310
00:14:29,240 --> 00:14:31,840
of different things so you
can't just look at like here's

311
00:14:31,840 --> 00:14:35,490
the top list of all vulnerabilities
are all flaws in code.

312
00:14:35,490 --> 00:14:37,000
You're gonna wanna say hey, since I work

313
00:14:37,000 --> 00:14:39,520
in JavaScript I have to be more aware

314
00:14:39,520 --> 00:14:42,120
of cross-site scripting,
credential management.

315
00:14:42,120 --> 00:14:45,680
CRLF injection than say
someone working in C++

316
00:14:45,680 --> 00:14:46,989
or something like that.

317
00:14:46,990 --> 00:14:48,480
You'd have a different focus.

318
00:14:48,480 --> 00:14:50,150
And this is the same exact data shown

319
00:14:50,150 --> 00:14:52,040
just slightly different, this again

320
00:14:52,040 --> 00:14:53,607
like really highlights PHP.

321
00:14:54,600 --> 00:14:57,210
So if you notice PHP that
sort of darker green one

322
00:14:57,210 --> 00:15:00,897
is what does that cross
site scripting in the top.

323
00:15:00,897 --> 00:15:03,330
And if you follow that dark
green you can see it's sort

324
00:15:03,330 --> 00:15:06,260
of hovering between 20, 25%.

325
00:15:06,260 --> 00:15:09,140
Most apps goes up to 30% for JavaScript

326
00:15:09,140 --> 00:15:12,360
but, largely down there except
for PHP it jumps way up.

327
00:15:12,360 --> 00:15:14,440
And so this was just sort of fun to look

328
00:15:14,440 --> 00:15:15,950
at this particular one and see how

329
00:15:15,950 --> 00:15:18,487
it pans out across the languages.

330
00:15:20,020 --> 00:15:22,360
All right, and now we're gonna
talk about some third party

331
00:15:22,360 --> 00:15:25,010
and open source libraries
and I'm gonna pass it over

332
00:15:25,010 --> 00:15:26,723
to my partner Ben.

333
00:15:27,930 --> 00:15:30,380
- And I'd like to thank Jay for that.

334
00:15:30,380 --> 00:15:31,939
We are gonna talk about third-party

335
00:15:31,940 --> 00:15:33,530
and open source libraries.

336
00:15:33,530 --> 00:15:37,209
Because as we were doing this
analysis, we realized that

337
00:15:37,210 --> 00:15:39,860
of course all this code is
not written by the developers

338
00:15:39,860 --> 00:15:43,260
in house and we probably
wanna think about the effect

339
00:15:43,260 --> 00:15:46,819
of open source libraries and
the flaws that they introduce.

340
00:15:46,820 --> 00:15:49,760
So of course, the first
question that we wanna ask

341
00:15:49,760 --> 00:15:52,350
is what proportion of
applications are actually composed

342
00:15:52,350 --> 00:15:54,400
of third-party code versus in-house code.

343
00:15:55,340 --> 00:15:58,560
And so what this chart shows
is it's really variable.

344
00:15:58,560 --> 00:16:01,739
And of course as Jay
said, language matters.

345
00:16:01,740 --> 00:16:04,240
So across the horizontal
axis is the percentage

346
00:16:04,240 --> 00:16:07,610
of the application that
is a third-party code

347
00:16:07,610 --> 00:16:10,900
or open source code,
however we wanna call it.

348
00:16:10,900 --> 00:16:14,242
And each here dub represents 1%.

349
00:16:14,243 --> 00:16:15,950
And so what we can see again, we have

350
00:16:15,950 --> 00:16:17,460
this huge variation in languages.

351
00:16:17,460 --> 00:16:21,790
Java, almost all of the
density is far to the right

352
00:16:21,790 --> 00:16:24,209
where we have most of the
most of the applications

353
00:16:24,210 --> 00:16:27,990
are almost 100% third-party code.

354
00:16:27,990 --> 00:16:30,530
And then it kind of tails
off far to the left of course

355
00:16:30,530 --> 00:16:33,100
there are some Java
applications at least 1%

356
00:16:33,100 --> 00:16:35,130
that are written totally
from scratch, but it

357
00:16:35,130 --> 00:16:36,503
is generally pretty rare.

358
00:16:37,566 --> 00:16:39,210
And then we have things like .Net where

359
00:16:39,210 --> 00:16:41,570
it's more spread out across there.

360
00:16:41,570 --> 00:16:44,720
Java script we kind of have
this bi-modal lots of things

361
00:16:44,720 --> 00:16:47,310
at 0% lots of things at 100%.

362
00:16:47,310 --> 00:16:50,030
And a lot of this starts to
make sense when you think

363
00:16:50,030 --> 00:16:52,079
about how these languages are constructed.

364
00:16:52,080 --> 00:16:53,930
So for Java, when you bring

365
00:16:53,930 --> 00:16:55,780
in functionality you're bringing down

366
00:16:55,780 --> 00:16:58,040
those classes, somebody
has already written it.

367
00:16:58,040 --> 00:17:00,180
You go to Apache comments
and you find the library

368
00:17:00,180 --> 00:17:01,760
and you bring it in.

369
00:17:01,760 --> 00:17:04,819
In a large part so with
JavaScript as well, lots

370
00:17:04,819 --> 00:17:07,069
of very small libraries
that you're including.

371
00:17:07,069 --> 00:17:10,750
And so that leads to this
large percentage of code

372
00:17:10,750 --> 00:17:12,940
that is open source.

373
00:17:12,940 --> 00:17:16,349
Now if we go down to C++
and kinda surprisingly PHP,

374
00:17:16,349 --> 00:17:19,819
most of those applications
are written from scratch.

375
00:17:19,819 --> 00:17:22,599
So there is some library
use, but the bulk of the code

376
00:17:22,599 --> 00:17:25,052
is actually 0%.

377
00:17:26,337 --> 00:17:30,210
And so, this should totally
not be surprising to us, right.

378
00:17:30,210 --> 00:17:33,830
Because, of course developers
don't need to reinvent

379
00:17:33,830 --> 00:17:36,500
the wheel or as we're saying here reinvent

380
00:17:36,500 --> 00:17:39,980
the B+ tree every time they
need a new data structure.

381
00:17:39,980 --> 00:17:43,660
So the B+ tree is kind
of an example for me

382
00:17:43,660 --> 00:17:46,070
because my sophomore
computer science class,

383
00:17:46,070 --> 00:17:48,540
our professor asked us
to implement a B+ tree

384
00:17:48,540 --> 00:17:51,310
on disc in C++.

385
00:17:51,310 --> 00:17:53,909
And realize that it was incredibly hard

386
00:17:53,910 --> 00:17:56,580
for sophomore computer science majors

387
00:17:56,580 --> 00:17:59,020
and ended up actually saying,
well you just use a library

388
00:17:59,020 --> 00:18:00,570
for this anyway.

389
00:18:00,570 --> 00:18:03,700
And so obviously like when
developers find a problem

390
00:18:03,700 --> 00:18:07,880
that requires difficult
coding, performance code

391
00:18:07,880 --> 00:18:09,700
they're gonna go reach for a library.

392
00:18:09,700 --> 00:18:12,790
And that's really an
obvious boon, but it has

393
00:18:12,790 --> 00:18:14,129
its inherent risks.

394
00:18:14,130 --> 00:18:16,370
And so we want to start
asking some of these questions

395
00:18:16,370 --> 00:18:17,500
like, how has Free

396
00:18:17,500 --> 00:18:19,370
and Open Source Software
used in applications?

397
00:18:19,370 --> 00:18:20,709
What parts are used?

398
00:18:20,710 --> 00:18:22,200
When do they come in?

399
00:18:22,200 --> 00:18:23,850
What are the flaws that are introduced?

400
00:18:23,850 --> 00:18:25,570
You know, Jay talks a
lot about those flaws

401
00:18:25,570 --> 00:18:28,010
that are introduced in homegrown code.

402
00:18:28,010 --> 00:18:30,780
We wanna know more about
the open source code.

403
00:18:30,780 --> 00:18:32,780
And then once we know
about kind of the landscape

404
00:18:32,780 --> 00:18:34,960
of those flaws, how do we manage that?

405
00:18:34,960 --> 00:18:35,830
How do we manage it?

406
00:18:35,830 --> 00:18:40,030
Because as Jay said,
it's not just a matter

407
00:18:40,030 --> 00:18:43,000
of fixing everything cause we're
never gonna fix everything,

408
00:18:43,000 --> 00:18:44,870
but it's a matter of
prioritizing and getting

409
00:18:44,870 --> 00:18:48,770
the right things fixed to make
the application more secure.

410
00:18:48,770 --> 00:18:51,360
So to that end I am gonna
tell you about we wrote

411
00:18:51,360 --> 00:18:53,050
a different report the State

412
00:18:53,050 --> 00:18:55,120
of Software Security open-source edition.

413
00:18:55,120 --> 00:18:57,729
I'm gonna touch on some research
that's in here on some that

414
00:18:57,730 --> 00:18:59,780
was not published in
here, but there's a lot

415
00:18:59,780 --> 00:19:01,230
of good stuff there.

416
00:19:01,230 --> 00:19:03,890
If you wanna go take a look
at that, if you're interested

417
00:19:03,890 --> 00:19:05,630
in this part of the talk
you wanna go take a look,

418
00:19:05,630 --> 00:19:07,330
there's great information there.

419
00:19:07,330 --> 00:19:10,610
But probably most importantly
like language matters

420
00:19:10,610 --> 00:19:13,659
as we've seen before in
open source use as well.

421
00:19:13,660 --> 00:19:16,610
Most laws are not serious,
we're gonna get to that.

422
00:19:16,610 --> 00:19:17,443
And of course there's

423
00:19:17,443 --> 00:19:22,023
a large variance across open
source use by applications.

424
00:19:23,340 --> 00:19:25,070
So let's get to that first question

425
00:19:25,070 --> 00:19:28,770
and that just asks
third-party libraries like

426
00:19:28,770 --> 00:19:30,430
how many are you using?

427
00:19:30,430 --> 00:19:32,470
So if we take a typical
application off the shelf

428
00:19:32,470 --> 00:19:35,850
and say like how many libraries
do you actually import?

429
00:19:35,850 --> 00:19:38,669
The answer of course is highly variable.

430
00:19:38,670 --> 00:19:40,750
So there are some JavaScript
applications that we looked

431
00:19:40,750 --> 00:19:43,970
at the have thousands of libraries.

432
00:19:43,970 --> 00:19:48,400
And as I said before, this
is not totally surprising.

433
00:19:48,400 --> 00:19:50,180
If you'll remember there was a debacle

434
00:19:50,180 --> 00:19:53,930
a few years ago concerning
a library called left-pad.

435
00:19:53,930 --> 00:19:56,640
And it was a library that has
single function it pads out

436
00:19:56,640 --> 00:19:59,990
a string on the left side of the string.

437
00:19:59,990 --> 00:20:02,930
And developer pulled it
off the package repository,

438
00:20:02,930 --> 00:20:05,570
the node package repository
and broke alert number

439
00:20:05,570 --> 00:20:07,889
of applications because
people were relying

440
00:20:07,890 --> 00:20:11,410
on this very simple one function library.

441
00:20:11,410 --> 00:20:13,827
And that's kind of what the
culture around JavaScript

442
00:20:13,827 --> 00:20:16,190
and the ecosystem of JavaScript is.

443
00:20:16,190 --> 00:20:19,020
Very small functionality
packaged up in a library.

444
00:20:19,020 --> 00:20:21,990
And that leads to high
numbers of life or use

445
00:20:21,990 --> 00:20:23,970
when you build these applications.

446
00:20:23,970 --> 00:20:26,770
Now if you go down to something
say like Python, where

447
00:20:26,770 --> 00:20:29,610
the libraries tend to be
larger, more functionality.

448
00:20:29,610 --> 00:20:32,879
We get kind of lower numbers
of imports, lower number

449
00:20:32,880 --> 00:20:35,360
of requirements to get pulled in.

450
00:20:35,360 --> 00:20:39,620
So, 16 is kind of typical but
all the way up into dozens.

451
00:20:39,620 --> 00:20:40,739
And as you can see, there's

452
00:20:40,740 --> 00:20:43,010
a large variability across all of these.

453
00:20:43,010 --> 00:20:46,879
And a lot of applications
have several orders,

454
00:20:46,880 --> 00:20:48,780
there could be several orders
of magnitude difference

455
00:20:48,780 --> 00:20:50,423
between different applications.

456
00:20:52,170 --> 00:20:54,800
And so, like once we've
seen all those libraries

457
00:20:54,800 --> 00:20:59,220
the next question we might
wanna ask is how exactly

458
00:20:59,220 --> 00:21:02,630
are those libraries getting
into the application.

459
00:21:02,630 --> 00:21:04,550
Are they coming in because

460
00:21:04,550 --> 00:21:08,260
the developer saying
yes, I need that library.

461
00:21:08,260 --> 00:21:10,680
Or, is it kind of this more of a backdoor

462
00:21:10,680 --> 00:21:13,070
this transitive dependency where a library

463
00:21:13,070 --> 00:21:15,090
has actually called another library, which

464
00:21:15,090 --> 00:21:16,240
has called another library, which

465
00:21:16,240 --> 00:21:18,850
has called another library
as I said it's libraries all

466
00:21:18,850 --> 00:21:19,800
the way down.

467
00:21:19,800 --> 00:21:22,639
And so we call those
transitive dependencies, things

468
00:21:22,640 --> 00:21:25,403
that come in based on other library calls.

469
00:21:26,330 --> 00:21:28,560
So we wanted to look at, so
for each application look

470
00:21:28,560 --> 00:21:31,610
at kind of the balance
between those two types

471
00:21:31,610 --> 00:21:34,179
of dependencies direct and transitive.

472
00:21:34,180 --> 00:21:37,270
So we did as we classified
each application is either kind

473
00:21:37,270 --> 00:21:41,290
of direct heavy, transitive
heavy or balanced.

474
00:21:41,290 --> 00:21:44,450
And we broke this up into thirds.

475
00:21:44,450 --> 00:21:48,650
And again, we can see a huge
difference based on language.

476
00:21:48,650 --> 00:21:51,460
For .Net, almost all applications

477
00:21:51,460 --> 00:21:53,890
are really direct dependency heavy.

478
00:21:53,890 --> 00:21:58,290
About 90% of applications
almost, the vast majority

479
00:21:58,290 --> 00:22:00,300
of includes are direct.

480
00:22:00,300 --> 00:22:03,899
And again, down at the bottom
there Ruby and JavaScript

481
00:22:03,900 --> 00:22:07,230
these kinds of web based languages

482
00:22:07,230 --> 00:22:09,540
a lot of those dependencies
are transitive.

483
00:22:09,540 --> 00:22:11,260
So you have these big trees that go out

484
00:22:11,260 --> 00:22:13,680
and all the transitive libraries come in

485
00:22:13,680 --> 00:22:15,140
and give you that weight.

486
00:22:15,140 --> 00:22:17,820
And so this makes a difference
because if you are looking

487
00:22:17,820 --> 00:22:20,679
at it from a security
standpoint and you wanna know

488
00:22:20,680 --> 00:22:22,240
where flaws are coming in.

489
00:22:22,240 --> 00:22:23,930
There may be a lot that are included

490
00:22:23,930 --> 00:22:25,560
that you're not directly including.

491
00:22:25,560 --> 00:22:28,406
So, you may hear about a flow
on an open source library

492
00:22:28,406 --> 00:22:30,570
and you think ah, I don't
use that in my application

493
00:22:30,570 --> 00:22:32,149
but it might be getting
sucked in through some

494
00:22:32,150 --> 00:22:33,860
of your other dependencies.

495
00:22:33,860 --> 00:22:35,199
So it really is something
to think about it

496
00:22:35,200 --> 00:22:37,390
is that, it's not just
what you've used it's

497
00:22:37,390 --> 00:22:40,610
what you use uses and so on down the line.

498
00:22:40,610 --> 00:22:42,800
So what kind of exposure does

499
00:22:42,800 --> 00:22:44,893
this actually give applications?

500
00:22:46,000 --> 00:22:47,880
And this leads us to the question

501
00:22:47,880 --> 00:22:51,680
is more libraries really more problems.

502
00:22:51,680 --> 00:22:56,070
And the answer is yeah, generally
but it doesn't have to be.

503
00:22:56,070 --> 00:22:59,070
So what this graphic shows
again, broken out by language

504
00:22:59,070 --> 00:23:01,470
because again, we know that
makes a lot of difference

505
00:23:01,470 --> 00:23:03,350
is on the horizontal axis is the number

506
00:23:03,350 --> 00:23:06,179
of libraries included in the application.

507
00:23:06,180 --> 00:23:08,090
And, as we said before this can be up into

508
00:23:08,090 --> 00:23:10,340
the thousands depending on the language.

509
00:23:10,340 --> 00:23:13,850
And the vertical axis is the
number of flaws introduced

510
00:23:13,850 --> 00:23:15,760
by those libraries.

511
00:23:15,760 --> 00:23:18,379
So, and this is only open-source
laws we're not talking

512
00:23:18,380 --> 00:23:19,570
about homegrown flaws.

513
00:23:19,570 --> 00:23:21,720
This is the stuff that
the library brings with it

514
00:23:21,720 --> 00:23:23,940
when it gets included in the application.

515
00:23:23,940 --> 00:23:26,820
And think there could be
a lot said on each segment

516
00:23:26,820 --> 00:23:29,300
of this graph but, it's
important to point out that we do

517
00:23:29,300 --> 00:23:32,419
have this kind of it's
linear but on a log log scale

518
00:23:32,420 --> 00:23:36,050
so sort of a power law relationship
for languages like Java

519
00:23:36,050 --> 00:23:38,113
and JavaScript Python in particular.

520
00:23:39,950 --> 00:23:43,290
And we can why that's the
case, why it scales like that

521
00:23:43,290 --> 00:23:45,270
is they're some interesting questions.

522
00:23:45,270 --> 00:23:50,270
But I think one of the big
takeaways here is yes, generally

523
00:23:50,330 --> 00:23:52,260
if you include more
libraries you're increasing

524
00:23:52,260 --> 00:23:55,410
that risk surface you may have
more flaws, but it doesn't

525
00:23:55,410 --> 00:23:56,630
have to be.

526
00:23:56,630 --> 00:23:57,980
So in particular if you look at kind

527
00:23:57,980 --> 00:24:02,060
of the lower left corner
of the blob in JavaScript,

528
00:24:02,060 --> 00:24:04,120
you'll see that there are applications

529
00:24:04,120 --> 00:24:07,729
that have thousands literally
thousands of libraries,

530
00:24:07,730 --> 00:24:10,860
with only one or two flaws
induced by those libraries.

531
00:24:10,860 --> 00:24:13,760
And so if you've got this huge
ecosystem that you're pulling

532
00:24:13,760 --> 00:24:16,129
into your application, it
may still be manageable

533
00:24:16,130 --> 00:24:18,780
if you're doing the right
things in the background

534
00:24:18,780 --> 00:24:20,170
to manage those flaws.

535
00:24:20,170 --> 00:24:21,680
And the same thing can be said for a lot

536
00:24:21,680 --> 00:24:22,930
of these other applications.

537
00:24:22,930 --> 00:24:25,080
You know the lower
right-hand corner of Java

538
00:24:25,080 --> 00:24:27,399
there's applications with
hundreds of libraries,

539
00:24:27,400 --> 00:24:28,901
almost no flaws.

540
00:24:28,901 --> 00:24:32,770
.Net has a lot of libraries with no flaws

541
00:24:32,770 --> 00:24:35,623
and so you can manage this issue.

542
00:24:37,410 --> 00:24:39,730
So, the next thing we
wanted to ask is like

543
00:24:39,730 --> 00:24:42,230
how dangerous are these flaws?

544
00:24:42,230 --> 00:24:43,870
And we wanted to kind
of build up a hierarchy

545
00:24:43,870 --> 00:24:47,270
of how rare they are and
how important they are.

546
00:24:47,270 --> 00:24:51,410
So you can think of this bar
graph is kind of like a funnel.

547
00:24:51,410 --> 00:24:54,360
So at the top, it's the
number of the percentage

548
00:24:54,360 --> 00:24:55,820
of applications that have just kind

549
00:24:55,820 --> 00:24:58,919
of any open source library that has a flaw

550
00:24:58,920 --> 00:25:00,750
and that flaw is still open.

551
00:25:00,750 --> 00:25:02,770
And what I mean by open
is it means the developer

552
00:25:02,770 --> 00:25:05,200
hasn't addressed it in any way.

553
00:25:05,200 --> 00:25:07,387
It's possible to have an
application that has a flaw

554
00:25:07,387 --> 00:25:09,649
and the developer says I'm
not gonna worry about it.

555
00:25:09,650 --> 00:25:11,540
Close it, don't worry about it.

556
00:25:11,540 --> 00:25:16,430
But what we see is if you
include open-source libraries

557
00:25:16,430 --> 00:25:19,990
you're really likely to
have at least one flaw.

558
00:25:19,990 --> 00:25:22,210
So when the question is,
how much should I worry

559
00:25:22,210 --> 00:25:24,310
about in a particular flaw?

560
00:25:24,310 --> 00:25:26,763
Well, turns out about 50%
of applications have flaws

561
00:25:26,763 --> 00:25:29,230
that have a proof of concept.

562
00:25:29,230 --> 00:25:31,330
And the way we figured
this out as we partnered

563
00:25:31,330 --> 00:25:34,080
with Kenna security and
got some of their data.

564
00:25:34,080 --> 00:25:38,139
And they have information on
when a particular library has

565
00:25:38,140 --> 00:25:40,880
a vulnerability, has there
been a proof of concept

566
00:25:40,880 --> 00:25:43,724
that exercises that
vulnerability published.

567
00:25:43,724 --> 00:25:46,909
So about half applications go have that.

568
00:25:46,910 --> 00:25:49,030
So the next level down is
worrying about well, it has

569
00:25:49,030 --> 00:25:52,120
a proof of concept but is our
attackers actually using it.

570
00:25:52,120 --> 00:25:53,919
And that's not 25%.

571
00:25:53,920 --> 00:25:57,440
So that is proof of concept
and we've seen it exploited

572
00:25:57,440 --> 00:25:58,890
in the wild.

573
00:25:58,890 --> 00:26:01,780
And so, about a quarter of
applications have this kind

574
00:26:01,780 --> 00:26:03,379
of higher level.

575
00:26:03,380 --> 00:26:07,152
And then last there's one piece
of information another piece

576
00:26:07,152 --> 00:26:09,290
of information we get
from Veracode, which is

577
00:26:09,290 --> 00:26:12,770
is that library on the executable path?

578
00:26:12,770 --> 00:26:15,360
So, is the flaw that's included in

579
00:26:15,360 --> 00:26:19,060
that library actually able to
be exercised by an attacker.

580
00:26:19,060 --> 00:26:22,260
Now this is a lower bound
cause it is impossible

581
00:26:22,260 --> 00:26:25,370
to say exactly whether every
floor is reachable or not

582
00:26:25,370 --> 00:26:28,270
in the code base, but it does
give us an idea that actually

583
00:26:28,270 --> 00:26:29,700
this is pretty rare.

584
00:26:29,700 --> 00:26:32,810
So having a flaw in a library
that is being exploited

585
00:26:32,810 --> 00:26:35,450
in the wild and is accessible by attackers

586
00:26:35,450 --> 00:26:37,660
is only 1% of flaws.

587
00:26:37,660 --> 00:26:39,450
So that's good news for us, right.

588
00:26:39,450 --> 00:26:42,350
So even if you have hundreds
or thousands of flaws,

589
00:26:42,350 --> 00:26:44,520
this gives us a to kind
of look at prioritization

590
00:26:44,520 --> 00:26:47,562
and think about which ones
we should address first.

591
00:26:49,300 --> 00:26:53,810
Now, that begs the question
like how should we address them?

592
00:26:53,810 --> 00:26:57,683
And of course, the easiest
answer is you just update things.

593
00:26:58,640 --> 00:27:02,020
So, in particular we wanted
to look at is how hard it

594
00:27:02,020 --> 00:27:05,220
is to update a library to
a version without a flaw

595
00:27:05,220 --> 00:27:08,180
and what kind of a big jump that was in

596
00:27:08,180 --> 00:27:10,170
the semantic versioning sense.

597
00:27:10,170 --> 00:27:14,190
And the great thing is more
than 80% of library flaws can

598
00:27:14,190 --> 00:27:18,190
be can be resolved by
just updating the library.

599
00:27:18,190 --> 00:27:23,190
And that update is really
small like, less than 2.1 less

600
00:27:23,820 --> 00:27:25,020
than that minor version.

601
00:27:25,870 --> 00:27:28,719
Now so about 20% you're all
gonna have to jump from 1.0

602
00:27:28,720 --> 00:27:32,660
to 2.0, but that will
depend on the application.

603
00:27:32,660 --> 00:27:34,740
Hopefully it doesn't break the workflow

604
00:27:34,740 --> 00:27:37,520
and you can find a way around that.

605
00:27:37,520 --> 00:27:40,340
So, I know there are some
of you out there who might

606
00:27:40,340 --> 00:27:43,149
be scoffing and saying
like hey, it is never

607
00:27:43,150 --> 00:27:44,850
of course that easy.

608
00:27:44,850 --> 00:27:47,760
Once you update the library
that may introduce new flaws

609
00:27:47,760 --> 00:27:50,320
and then those new
flaws have to be updated

610
00:27:50,320 --> 00:27:52,639
and then you're in this endless cycle.

611
00:27:52,640 --> 00:27:55,900
So we took a minute to try to
think about what those cycles

612
00:27:55,900 --> 00:27:59,840
could look like and what the
chain of updates can look like.

613
00:27:59,840 --> 00:28:04,293
And so we came up with five
classes two of which ended

614
00:28:04,294 --> 00:28:07,890
in a final update one is a
single step and one's multi-step.

615
00:28:07,890 --> 00:28:09,900
You can do the same thing
and kind of not end up with

616
00:28:09,900 --> 00:28:12,400
a version that doesn't
have any kinds of flaws.

617
00:28:12,400 --> 00:28:14,810
Either there isn't one available
or you take a few steps

618
00:28:14,810 --> 00:28:15,990
to get there.

619
00:28:15,990 --> 00:28:18,210
And then there's this rare
thing that actually came out

620
00:28:18,210 --> 00:28:20,010
in the data that we had to look for.

621
00:28:20,980 --> 00:28:23,060
Which was is there a circular update?

622
00:28:23,060 --> 00:28:25,870
So sometimes the recommendation
when there's a flaw

623
00:28:25,870 --> 00:28:28,010
is that you should kind
of downgrade and go to

624
00:28:28,010 --> 00:28:29,240
a previous version.

625
00:28:29,240 --> 00:28:31,050
But if you do that and
that version still has

626
00:28:31,050 --> 00:28:32,540
a flaw you may go down the train

627
00:28:32,540 --> 00:28:33,790
a little bit before you jump back.

628
00:28:33,790 --> 00:28:37,480
So, just looking at like how often each of

629
00:28:37,480 --> 00:28:40,810
these occur we get some more good news.

630
00:28:40,810 --> 00:28:43,830
So most of the time, two
thirds of the time you

631
00:28:43,830 --> 00:28:48,830
can fix flaws with one or
several steps broken up

632
00:28:50,010 --> 00:28:52,129
to about one third, one
third, so that's great.

633
00:28:52,130 --> 00:28:54,310
So most of the time you
can get to that end point

634
00:28:54,310 --> 00:28:57,879
where you're including a
library with no known flaws.

635
00:28:57,880 --> 00:29:00,660
And then those circular updates
those bad ones that kind of

636
00:29:00,660 --> 00:29:05,220
are the most complicated and
icky are a vanishingly small

637
00:29:05,220 --> 00:29:07,040
about half a percent.

638
00:29:07,040 --> 00:29:08,433
So we're lucky on that end.

639
00:29:09,560 --> 00:29:12,960
We wanted to do kind of a more
complex breakdown of thinking

640
00:29:12,960 --> 00:29:15,920
about kind of where these
things fall in this bar graph.

641
00:29:15,920 --> 00:29:18,530
So if we think about
these different classes

642
00:29:18,530 --> 00:29:21,320
and where the the size
of the versions end up.

643
00:29:21,320 --> 00:29:25,149
Because I did tell you that,
you know 80% are minor patch

644
00:29:25,150 --> 00:29:28,010
or smaller but that may not
be the case for these kinds

645
00:29:28,010 --> 00:29:30,923
of update chains so we wanted
to look at that as well.

646
00:29:31,940 --> 00:29:35,830
And it turns out that
actually most of the updates

647
00:29:35,830 --> 00:29:38,500
are still pretty small.

648
00:29:38,500 --> 00:29:42,040
So again, a good percentage
of flaws are just

649
00:29:42,040 --> 00:29:43,513
a pretty small update.

650
00:29:44,430 --> 00:29:46,666
And then two thirds of those, end up in

651
00:29:46,666 --> 00:29:50,405
a clean state once you've
done enough updates.

652
00:29:50,405 --> 00:29:53,320
But the nice part is
75% of those two thirds

653
00:29:54,580 --> 00:29:57,939
are still minor version or
less, minor version of patch.

654
00:29:57,940 --> 00:30:00,990
And so we do get this nice
even though you may go down

655
00:30:00,990 --> 00:30:03,760
this update chain, it's
still gonna be small.

656
00:30:03,760 --> 00:30:07,100
You're still not gonna do
too much and so we can kind

657
00:30:07,100 --> 00:30:08,540
of fix open source.

658
00:30:08,540 --> 00:30:11,610
And and thinking about open
source we've given you a lot

659
00:30:11,610 --> 00:30:14,419
of detail, but that's a
practice for developers to kind

660
00:30:14,420 --> 00:30:16,320
of look at and be thinking about

661
00:30:16,320 --> 00:30:18,470
as they're developing their apps.

662
00:30:18,470 --> 00:30:21,590
And so to break that down
and kind of talk tie all

663
00:30:21,590 --> 00:30:22,669
the things that we've talked

664
00:30:22,670 --> 00:30:24,210
about today together,
I'm gonna throw it back

665
00:30:24,210 --> 00:30:26,290
to my colleague, Jay.

666
00:30:26,290 --> 00:30:27,570
- All right, thanks Ben.

667
00:30:27,570 --> 00:30:30,260
We're gonna get into the
really fun part of this

668
00:30:30,260 --> 00:30:34,440
and talk about nature
versus nurture and the type

669
00:30:34,440 --> 00:30:38,790
of attributes and aspects of
development in applications

670
00:30:38,790 --> 00:30:41,180
that will contribute to either faster

671
00:30:41,180 --> 00:30:43,053
or slower remediation times.

672
00:30:43,960 --> 00:30:47,940
So the first problem we
have is trying to measure

673
00:30:47,940 --> 00:30:50,830
how fast flaws are getting
fixed when we talk about

674
00:30:50,830 --> 00:30:52,699
that time aspect.

675
00:30:52,700 --> 00:30:56,870
And what we see is that the
one of the super easy ways

676
00:30:56,870 --> 00:30:59,040
is the looking at the top line here where

677
00:30:59,040 --> 00:31:03,200
this is a distribution of flaws
and that we're we're closed.

678
00:31:03,200 --> 00:31:05,730
And this is a really easy way
to say how long does it take

679
00:31:05,730 --> 00:31:07,340
to close something where
you can look at everything

680
00:31:07,340 --> 00:31:11,173
that's closed and figure
out the median is 86 days.

681
00:31:12,970 --> 00:31:16,610
The problem with that, is
that when you start with

682
00:31:16,610 --> 00:31:19,330
a whole list of flaws you
don't know which one of those

683
00:31:19,330 --> 00:31:22,030
are gonna be closed and
then you have to consider

684
00:31:22,030 --> 00:31:24,330
the bottom line here which
is the open findings.

685
00:31:24,330 --> 00:31:27,080
And essentially these
are flaws that were found

686
00:31:27,080 --> 00:31:31,870
and are still open and the
median open time here is 216 days

687
00:31:31,870 --> 00:31:33,590
and getting longer.

688
00:31:33,590 --> 00:31:37,610
So, the question is are the
flaw that you see at day zero

689
00:31:37,610 --> 00:31:40,500
is that gonna be part of the
closed findings and closed

690
00:31:40,500 --> 00:31:43,660
on average of 86 days,
or is it gonna stay open

691
00:31:43,660 --> 00:31:47,830
for over six, seven months on average?

692
00:31:47,830 --> 00:31:49,810
And so the challenge is
you can't just look at

693
00:31:49,810 --> 00:31:53,070
the close you have to account
for these open findings.

694
00:31:53,070 --> 00:31:56,250
And you do that through a set
of techniques sort of under

695
00:31:56,250 --> 00:31:59,190
the umbrella term of survival analysis.

696
00:31:59,190 --> 00:32:01,370
And so with that we can take a look at all

697
00:32:01,370 --> 00:32:04,379
of the flaws even the
ones that are still open

698
00:32:04,380 --> 00:32:07,880
and account for them, in the
probability that something will

699
00:32:07,880 --> 00:32:09,923
be fixed in some time period.

700
00:32:10,800 --> 00:32:13,720
And so when we take a
look here on the top left

701
00:32:13,720 --> 00:32:15,960
this is where a hundred
percent of these flaws

702
00:32:15,960 --> 00:32:17,670
are still open.

703
00:32:17,670 --> 00:32:21,170
And so in the first roughly what, 32 days

704
00:32:21,170 --> 00:32:24,340
the first month roughly about
one in four of those flaws

705
00:32:24,340 --> 00:32:25,669
will be closed.

706
00:32:25,670 --> 00:32:28,300
And so what we're seeing
is in that first month,

707
00:32:28,300 --> 00:32:31,909
a lot of activity the line is
really steep coming in there.

708
00:32:31,910 --> 00:32:35,270
And what we get is about
one in four being closed.

709
00:32:35,270 --> 00:32:38,330
Now it takes another
five months after that

710
00:32:38,330 --> 00:32:39,889
to get to half.

711
00:32:39,890 --> 00:32:42,130
So you can see the slope of
that line is flattening out

712
00:32:42,130 --> 00:32:44,880
a little bit and we get about
half the flaws are fixed

713
00:32:44,880 --> 00:32:46,920
in the first six months.

714
00:32:46,920 --> 00:32:49,930
And conversely, after
six months half of them

715
00:32:49,930 --> 00:32:51,696
are still open.

716
00:32:51,696 --> 00:32:53,149
And so it's concerning right, but we see

717
00:32:53,150 --> 00:32:54,670
this line flattening out.

718
00:32:54,670 --> 00:32:59,250
And it takes over a year and
a half to get to the next 25%,

719
00:32:59,250 --> 00:33:02,040
where one in four flaws still
remain open after a year

720
00:33:02,040 --> 00:33:03,300
and a half.

721
00:33:03,300 --> 00:33:05,520
And so we see this
remediation, we see a lot

722
00:33:05,520 --> 00:33:06,860
of flurry up front.

723
00:33:06,860 --> 00:33:09,959
We see it go in the first
month a lot, quarter of them

724
00:33:09,960 --> 00:33:12,720
are being closed and it
starts to slow down from there

725
00:33:12,720 --> 00:33:14,560
and then year and a
half later we still have

726
00:33:14,560 --> 00:33:16,580
a quarter of them are open.

727
00:33:16,580 --> 00:33:19,060
So there's some things we
can look at like for example,

728
00:33:19,060 --> 00:33:22,570
if we look at the rate
of scanning how often

729
00:33:22,570 --> 00:33:26,510
is code scanning performed and
what kind of a feedback loop

730
00:33:26,510 --> 00:33:27,343
are we seeing?

731
00:33:27,343 --> 00:33:29,500
And in fact when we see applications

732
00:33:29,500 --> 00:33:32,863
that scan very infrequently
what we see is that median

733
00:33:34,750 --> 00:33:37,890
if I go back here the
average is about six months.

734
00:33:37,890 --> 00:33:41,340
What we see for the applications
that are scanning 12

735
00:33:41,340 --> 00:33:46,010
or less times we're seeing
about 217 days which is

736
00:33:46,010 --> 00:33:50,210
what about 30 35 days
faster that are slower

737
00:33:50,210 --> 00:33:51,890
than the average.

738
00:33:51,890 --> 00:33:53,380
But then you see applications that

739
00:33:53,380 --> 00:33:55,360
are scanning roughly daily

740
00:33:55,360 --> 00:33:59,060
for every Workday over
260 times in a year.

741
00:33:59,060 --> 00:34:02,580
And we see those with an
average of 62 days closing half

742
00:34:02,580 --> 00:34:06,510
of their flaws, which is a
dramatic difference here, right.

743
00:34:06,510 --> 00:34:08,822
So we see a huge shift.

744
00:34:09,840 --> 00:34:12,210
Now, what we wanted to do was to take all

745
00:34:12,210 --> 00:34:15,690
of these factors together,
put them into a model and see

746
00:34:15,690 --> 00:34:17,510
what they did to remediation time.

747
00:34:17,510 --> 00:34:20,730
And so we ended up
gathering a bunch of factors

748
00:34:20,730 --> 00:34:23,969
of development applications,
the organizations they're in

749
00:34:23,969 --> 00:34:25,929
and we throw them all into
a model and they sort of fit

750
00:34:25,929 --> 00:34:28,790
into these two categories
of nature versus nurture

751
00:34:28,790 --> 00:34:30,489
hence the analogy here.

752
00:34:30,489 --> 00:34:33,020
So, you talk about the nature
of applications you've got

753
00:34:33,020 --> 00:34:34,570
the size of the organization.

754
00:34:34,570 --> 00:34:36,639
you know, generally
larger organizations have

755
00:34:36,639 --> 00:34:40,239
more communication paths,
a lot more complexity

756
00:34:40,239 --> 00:34:42,759
then you get the age of
the application how big

757
00:34:42,760 --> 00:34:43,639
is that application?

758
00:34:43,639 --> 00:34:47,020
Is it complex and large or
sort of small and lightweight?

759
00:34:47,020 --> 00:34:50,550
The flaw density typically
known as security debt.

760
00:34:50,550 --> 00:34:54,060
And then on the nurture
of applications we've got,

761
00:34:54,060 --> 00:34:56,040
how often is it being scanned?

762
00:34:56,040 --> 00:34:58,470
Is that scan cadence steady or is

763
00:34:58,470 --> 00:35:01,799
it really bursty right
around the last step of

764
00:35:01,800 --> 00:35:03,480
a waterfall method?

765
00:35:03,480 --> 00:35:06,933
And then do we see other
aspects of security?

766
00:35:07,983 --> 00:35:10,140
Or do they do in dynamic
scans along with static?

767
00:35:10,140 --> 00:35:12,299
Are they doing SCA scanning?

768
00:35:12,300 --> 00:35:15,080
It's the software composition analysis.

769
00:35:15,080 --> 00:35:17,520
They have an API integration
in other words, it's part of

770
00:35:17,520 --> 00:35:20,200
their continuous integration
and they're part of like

771
00:35:20,200 --> 00:35:22,390
a code check-in is
hitting the API and doing

772
00:35:22,390 --> 00:35:23,830
this code scanning.

773
00:35:23,830 --> 00:35:26,270
When we see all of that this
is the output that we see.

774
00:35:26,270 --> 00:35:29,380
We see this the some very
simple bar chart that has

775
00:35:29,380 --> 00:35:31,740
a whole bunch of
complexity on the back end.

776
00:35:31,740 --> 00:35:35,609
So we see things like at
the top here, DAST with SAS.

777
00:35:35,610 --> 00:35:38,640
So the dynamic with static
that gets much quicker

778
00:35:38,640 --> 00:35:41,150
and this is not saying
that scanning dynamic will

779
00:35:41,150 --> 00:35:43,842
cause any of this it's
just saying, I think what

780
00:35:43,842 --> 00:35:45,680
this is saying is that
teams that are dedicated

781
00:35:45,680 --> 00:35:49,180
to security are gonna close
things faster and they're gonna

782
00:35:49,180 --> 00:35:51,970
have dynamic scanning and
they're gonna use the API

783
00:35:51,970 --> 00:35:54,169
and they're gonna have SCA
all of those contribute

784
00:35:54,170 --> 00:35:55,440
to faster things.

785
00:35:55,440 --> 00:35:58,040
That's largely probably some
other attribute of that team

786
00:35:58,040 --> 00:36:00,620
that's really investing in security.

787
00:36:00,620 --> 00:36:02,770
But we do see frequent scanning

788
00:36:02,770 --> 00:36:05,550
where you're scanning very steady those

789
00:36:05,550 --> 00:36:07,040
are also contributing.

790
00:36:07,040 --> 00:36:09,200
And what we see on the
on the negative side

791
00:36:09,200 --> 00:36:13,460
are things like the flaw density
that's the bottom one here.

792
00:36:13,460 --> 00:36:17,630
Roughly 63 days slower when you
go up one standard deviation

793
00:36:17,630 --> 00:36:18,640
of your flaw density.

794
00:36:18,640 --> 00:36:21,160
If you remember in the beginning
we had those distributions

795
00:36:21,160 --> 00:36:22,790
if you go one standard deviation off

796
00:36:22,790 --> 00:36:25,750
of normal, you're gonna go
six to three days slower.

797
00:36:25,750 --> 00:36:28,850
Conversely if you get that
flaw density below average,

798
00:36:28,850 --> 00:36:31,950
you're gonna be 63 days quicker if you're

799
00:36:31,950 --> 00:36:35,950
a standard deviation above
with less flaw density.

800
00:36:35,950 --> 00:36:39,252
Larger applications, more
complex lot of things in there.

801
00:36:40,430 --> 00:36:43,279
And if we look at the
survival curve at the very

802
00:36:43,280 --> 00:36:47,410
that yellow one is basically
bad nurture, bad nature.

803
00:36:47,410 --> 00:36:51,330
You know, poor action, poor environment.

804
00:36:51,330 --> 00:36:53,520
But when you start shifting
it and you get over

805
00:36:53,520 --> 00:36:56,120
to that very dark one where
you've got good actions

806
00:36:56,120 --> 00:36:58,120
you're doing all the good
things and you've got

807
00:36:58,120 --> 00:37:00,690
a good environment, you've
got lightweight applications.

808
00:37:00,690 --> 00:37:02,573
You're gonna have a lot
faster remediation times

809
00:37:02,573 --> 00:37:04,993
and that's what bears out in the data.

810
00:37:06,090 --> 00:37:08,450
So let's jump into the takeaways.

811
00:37:08,450 --> 00:37:11,410
One of the first things
is to sort of absorb

812
00:37:11,410 --> 00:37:13,870
this I mean, like the
bar chart that we talked

813
00:37:13,870 --> 00:37:15,440
about the nature versus nurture there's

814
00:37:15,440 --> 00:37:17,350
a lot of stuff in there

815
00:37:17,350 --> 00:37:20,860
And think about your own
applications and what you see.

816
00:37:20,860 --> 00:37:25,030
And then so for example, the
big things were security debt

817
00:37:25,030 --> 00:37:26,310
and the large application

818
00:37:26,310 --> 00:37:29,890
so consider splitting up
large legacy applications

819
00:37:29,890 --> 00:37:32,310
You know, look at
microservices look towards

820
00:37:33,250 --> 00:37:35,030
maybe spinning up some
different teams trying

821
00:37:35,030 --> 00:37:36,460
to split that out more.

822
00:37:36,460 --> 00:37:39,680
Try to drive down that flaw
density too so really go after

823
00:37:39,680 --> 00:37:41,839
that technical debt you
wanna try and get some of

824
00:37:41,840 --> 00:37:44,420
these really bloated applications down

825
00:37:44,420 --> 00:37:45,973
and really close those up.

826
00:37:46,980 --> 00:37:49,000
And you want to improve

827
00:37:49,000 --> 00:37:51,070
that feedback cycle, we talked about that.

828
00:37:51,070 --> 00:37:53,620
So if you can get a team that's invested

829
00:37:53,620 --> 00:37:56,370
in security you wanna give
them the tools to do that

830
00:37:56,370 --> 00:37:59,490
and that's gonna be more
in variety of scanning,

831
00:37:59,490 --> 00:38:03,270
more tools to get more views
and perspectives on that.

832
00:38:03,270 --> 00:38:04,920
And that's gonna be really, really helpful

833
00:38:04,920 --> 00:38:07,272
and you don't have to go
commercial there's plenty

834
00:38:07,272 --> 00:38:09,230
of open source options here too.

835
00:38:09,230 --> 00:38:12,080
And then, just make sure
that this is part of

836
00:38:12,080 --> 00:38:14,470
the pipeline you don't wanna
bolt this on afterwards.

837
00:38:14,470 --> 00:38:17,029
You wanna make sure that
as code gets checked in,

838
00:38:17,030 --> 00:38:18,470
as you're going through that pipeline

839
00:38:18,470 --> 00:38:20,910
that security is part
of that whole pipeline

840
00:38:20,910 --> 00:38:23,069
and integrated into that.

841
00:38:23,070 --> 00:38:27,080
And with that, we will wrap up
and open it up for questions

842
00:38:27,080 --> 00:38:29,330
and thank you very much for your time.

