1
00:00:08,250 --> 00:00:10,600
- Thanks for the chairman's introduction.

2
00:00:10,600 --> 00:00:13,570
It's my pleasure to
share our new work FAN,

3
00:00:13,570 --> 00:00:16,760
our newly designed
lightweight authenticated

4
00:00:16,760 --> 00:00:19,580
cryptographic algorithm here.

5
00:00:19,580 --> 00:00:22,720
My presentation will be given in six parts

6
00:00:22,720 --> 00:00:24,743
to introduce the new algorithm.

7
00:00:25,660 --> 00:00:26,900
I would like to start

8
00:00:26,900 --> 00:00:29,439
by briefly reviewing the previous work

9
00:00:29,440 --> 00:00:32,200
in lightweight symmetric design.

10
00:00:32,200 --> 00:00:35,760
Wide application of
low-end embedded devices

11
00:00:35,760 --> 00:00:39,992
has largely stimulated development
of lightweight ciphers.

12
00:00:40,919 --> 00:00:42,690
They share similar features.

13
00:00:42,690 --> 00:00:45,120
Well, lightweight block ciphers

14
00:00:45,120 --> 00:00:48,387
has already possessed
many successful designs,

15
00:00:48,387 --> 00:00:49,910
but lightweight stream ciphers

16
00:00:49,910 --> 00:00:52,949
hit the bottleneck of
large internal state size

17
00:00:52,950 --> 00:00:55,113
to resist the TMTO attacks.

18
00:00:56,050 --> 00:01:00,660
There comes a solution, using
cipher key stored in devices

19
00:01:00,660 --> 00:01:04,340
non-volatile memory, not
only for initialization,

20
00:01:04,340 --> 00:01:06,480
but also encryption.

21
00:01:06,480 --> 00:01:09,270
From the view of practical engineering,

22
00:01:09,270 --> 00:01:12,530
it's better to access key continuously.

23
00:01:12,530 --> 00:01:14,803
Name the design principle as CKU.

24
00:01:16,030 --> 00:01:18,100
Immediate CKU-based the designs,

25
00:01:18,100 --> 00:01:20,660
now are now adopting Grain-like structure,

26
00:01:20,660 --> 00:01:22,780
which has recently been reported

27
00:01:22,780 --> 00:01:24,933
vulnerable to correlation attacks.

28
00:01:25,930 --> 00:01:28,390
First, we are motivated to design

29
00:01:28,390 --> 00:01:32,020
a new CKU-based lightweight stream cipher,

30
00:01:32,020 --> 00:01:34,920
with entirely different structure.

31
00:01:34,920 --> 00:01:39,140
Support integrated encryption
and authentication.

32
00:01:39,140 --> 00:01:42,530
It results in a new
lightweight AEAD algorithm,

33
00:01:42,530 --> 00:01:43,763
named as FAN.

34
00:01:45,250 --> 00:01:48,150
Let's move on to the specification.

35
00:01:48,150 --> 00:01:52,833
FAN supports 128-bit key, 64-bit IV,

36
00:01:52,833 --> 00:01:56,120
promising 128-bit security,

37
00:01:56,120 --> 00:02:01,120
and up to 72-bit tag with the
IV-respecting restriction.

38
00:02:01,440 --> 00:02:06,440
It has two work modes, stream
cipher, and AEAD algorithm.

39
00:02:06,920 --> 00:02:11,130
The maximum amount of
inputs is two to 64 bits.

40
00:02:12,450 --> 00:02:15,737
It contains a full
process of initialization,

41
00:02:15,737 --> 00:02:17,222
and finalization.

42
00:02:18,570 --> 00:02:23,570
FAN has 192-bit state
composed of four blades,

43
00:02:23,900 --> 00:02:26,630
one accumulator, one spindle.

44
00:02:26,630 --> 00:02:29,192
Additionally, it has one-byte counter.

45
00:02:31,010 --> 00:02:33,350
For the main function in FAN,

46
00:02:33,350 --> 00:02:35,739
the output function linearly expects

47
00:02:35,740 --> 00:02:37,960
three bytes of the spindle,

48
00:02:37,960 --> 00:02:40,433
and accumulator for each output byte.

49
00:02:41,910 --> 00:02:45,040
The StateUpdate function has a constant

50
00:02:45,040 --> 00:02:47,109
and mutual feedback structure.

51
00:02:47,110 --> 00:02:50,990
For each blade, one byte has
a feedback from accumulator

52
00:02:50,990 --> 00:02:52,450
and the rotate.

53
00:02:52,450 --> 00:02:54,839
One has a feedback from spindle,

54
00:02:54,840 --> 00:02:57,070
the other two are invariant.

55
00:02:57,070 --> 00:03:02,070
Finally, these four blades run
a wholly blade-wise rotation.

56
00:03:02,240 --> 00:03:05,390
The accumulator has one invariant byte

57
00:03:05,390 --> 00:03:09,049
from each blade on different units.

58
00:03:09,050 --> 00:03:12,010
The spindle takes S-P-S network.

59
00:03:12,010 --> 00:03:14,220
The other invariant byte from each blade

60
00:03:14,220 --> 00:03:16,913
is added to the spindle
on different units.

61
00:03:18,860 --> 00:03:21,170
The subkey sequence and the message blocks

62
00:03:21,170 --> 00:03:24,149
are defined differently in each process,

63
00:03:24,150 --> 00:03:26,903
and added to the last three spindle bytes.

64
00:03:28,650 --> 00:03:32,400
The counter updates in the control of rC6.

65
00:03:32,400 --> 00:03:35,850
If it equals zero, then
the six bytes update

66
00:03:35,850 --> 00:03:38,160
has a maximum free rate, (mumbles),

67
00:03:40,620 --> 00:03:44,080
then they are run together to update rC6.

68
00:03:44,080 --> 00:03:45,817
Once it arrives at one,

69
00:03:47,294 --> 00:03:49,973
these seven bytes do not change any more.

70
00:03:49,973 --> 00:03:54,000
Counter state is always added
to the first spindle byte

71
00:03:54,000 --> 00:03:56,020
as a round constant.

72
00:03:56,020 --> 00:03:58,430
rC7 is defined as follows

73
00:03:58,430 --> 00:04:01,407
to separate the processing associated data

74
00:04:01,407 --> 00:04:03,053
and the encryption phases.

75
00:04:04,220 --> 00:04:06,200
For the initialization,

76
00:04:06,200 --> 00:04:09,489
we first load key and IV into state

77
00:04:09,490 --> 00:04:12,100
then updates 52 rounds.

78
00:04:12,100 --> 00:04:16,409
Set a counter message block
and round key as follows.

79
00:04:16,410 --> 00:04:19,350
Which means neither
subkey nor message block

80
00:04:19,350 --> 00:04:21,783
takes part in the state update.

81
00:04:22,908 --> 00:04:25,820
For the processing associated data phase,

82
00:04:25,820 --> 00:04:29,990
it processes AD in 24-bit block.

83
00:04:29,990 --> 00:04:31,820
Here is the padding rule.

84
00:04:31,820 --> 00:04:35,650
Set the counter message block
and the round key as follows,

85
00:04:35,650 --> 00:04:39,280
which means only the AD takes
part in the state update

86
00:04:39,280 --> 00:04:40,679
and not the subkey.

87
00:04:41,837 --> 00:04:46,837
For encryption, it processes
plain text in 24-bit blocks.

88
00:04:46,940 --> 00:04:49,020
There is the padding rule.

89
00:04:49,020 --> 00:04:52,669
Set the counter message block
and round key as follows.

90
00:04:52,670 --> 00:04:54,795
AD subkey similarly,

91
00:04:54,795 --> 00:04:59,200
(mumbles) has next to
three consecutive blocks

92
00:04:59,200 --> 00:05:00,092
of cipher key.

93
00:05:01,070 --> 00:05:03,849
Each round generates the keystream block,

94
00:05:03,850 --> 00:05:06,330
and then the ciphertext block.

95
00:05:06,330 --> 00:05:08,169
Next update is state.

96
00:05:08,170 --> 00:05:11,953
Both the plain text and subkey
blocks join in the update.

97
00:05:13,890 --> 00:05:17,320
For finalization, key-IV first direct XOR

98
00:05:17,320 --> 00:05:21,270
to the internal state,
then update state 28 rounds

99
00:05:21,270 --> 00:05:22,719
using the initial iterations.

100
00:05:24,630 --> 00:05:27,880
Next, (indistinct) was
tagged using the iteration

101
00:05:27,880 --> 00:05:30,030
in keystream generation.

102
00:05:30,030 --> 00:05:32,210
Set the counter message,

103
00:05:32,210 --> 00:05:34,423
block key and the round key as follows.

104
00:05:36,340 --> 00:05:38,789
The decryption and verification

105
00:05:38,790 --> 00:05:42,360
is similar as encryption and finalization.

106
00:05:42,360 --> 00:05:44,930
Here is the overall workflow.

107
00:05:44,930 --> 00:05:48,080
To resist the traditional
attacks on stream ciphers,

108
00:05:48,080 --> 00:05:52,820
internal state is wholly
updated in a non-linear way.

109
00:05:52,820 --> 00:05:54,760
To offer a balanced performance

110
00:05:54,760 --> 00:05:58,390
in software and hardware implementations,

111
00:05:58,390 --> 00:06:01,890
FAN adopts byte-wise operations.

112
00:06:01,890 --> 00:06:05,260
Well, let's run to the design rationale.

113
00:06:05,260 --> 00:06:08,659
The structure is inspired by electric fan,

114
00:06:08,660 --> 00:06:12,140
which rapidly provides
highly confused level

115
00:06:12,140 --> 00:06:16,190
by parallel constant mutual feedbacks

116
00:06:16,190 --> 00:06:20,303
between the nonlinear
spindle and linear blades.

117
00:06:22,330 --> 00:06:24,159
Since FAN is byte oriented,

118
00:06:24,160 --> 00:06:27,776
it naturally takes eight times 8S-box.

119
00:06:27,776 --> 00:06:31,550
For hardware efficiency,
we newly design S-box

120
00:06:31,550 --> 00:06:35,653
and its logic circuit with
relatively good properties.

121
00:06:36,640 --> 00:06:39,330
It is constructed by a
three-round balanced,

122
00:06:39,330 --> 00:06:40,969
the Feistel structure,

123
00:06:40,970 --> 00:06:44,570
with three different
4-bit to 4-bit functions,

124
00:06:44,570 --> 00:06:46,880
and a bit shuffle to make the terms

125
00:06:46,880 --> 00:06:49,623
distributed as evenly as possible.

126
00:06:50,560 --> 00:06:55,430
To achieve enough active S-boxes
in minimum initial rounds,

127
00:06:55,430 --> 00:06:59,260
we choose byte-wise permutation
with maximum differential

128
00:06:59,260 --> 00:07:02,022
and linear branch numbers of five.

129
00:07:02,890 --> 00:07:05,990
For the sake of low memory
footprint in hardware

130
00:07:05,990 --> 00:07:09,197
and a high efficiency in software,

131
00:07:09,197 --> 00:07:13,350
we choose the well
designed primitive in AES.

132
00:07:13,350 --> 00:07:16,450
To achieve strong initialization security,

133
00:07:16,450 --> 00:07:20,163
we have checked IV-key
differences propagation,

134
00:07:21,820 --> 00:07:26,820
and there are at least 32
active S-box in 26 rounds.

135
00:07:27,190 --> 00:07:30,180
Thus, we set the initialization rounds

136
00:07:30,180 --> 00:07:33,180
by a double to 52 rounds.

137
00:07:33,180 --> 00:07:35,870
FAN injects message into the state,

138
00:07:35,870 --> 00:07:38,753
so that it could obtain
authentication for free.

139
00:07:39,690 --> 00:07:44,150
In order to divide different
work phases, a counter is set.

140
00:07:44,150 --> 00:07:46,690
To achieve strong encryption security,

141
00:07:46,690 --> 00:07:50,193
the key also participates
in encryption phase.

142
00:07:51,730 --> 00:07:54,770
We will now come to the
security evaluation.

143
00:07:54,770 --> 00:07:59,640
We analyze the security of
every phases with lacer items.

144
00:07:59,640 --> 00:08:03,530
It resolves that, FAN can
achieve enough security margin

145
00:08:03,530 --> 00:08:05,573
against the known attacks.

146
00:08:06,809 --> 00:08:10,663
(mumbles) talk about the
implementation performance.

147
00:08:12,020 --> 00:08:16,219
It takes about eight
(mumbles) byte for encryption

148
00:08:16,220 --> 00:08:17,713
and software performance.

149
00:08:18,630 --> 00:08:21,903
It occupies about 2,327 GE,

150
00:08:24,420 --> 00:08:29,420
and has the speed of
9.6 Gigabytes per second

151
00:08:29,650 --> 00:08:31,412
with hardware performance.

152
00:08:33,570 --> 00:08:35,640
It shows that, FAN can achieve

153
00:08:35,640 --> 00:08:40,140
competitive hardware and
software performances

154
00:08:40,140 --> 00:08:43,633
compared with other known
lightweight stream ciphers.

155
00:08:44,850 --> 00:08:49,850
To sum up, we propose a
new AEAD algorithm FAN.

156
00:08:50,500 --> 00:08:55,470
It is the first non-Grain-like
small-state stream cipher,

157
00:08:55,470 --> 00:08:58,320
and also the first small-state cipher

158
00:08:58,320 --> 00:09:01,200
with authentication function.

159
00:09:01,200 --> 00:09:05,630
For the apply, we expect
our work can push forward

160
00:09:05,630 --> 00:09:09,439
such small-state designs
to a wider perspectives,

161
00:09:09,440 --> 00:09:11,533
and inspire further research.

162
00:09:12,500 --> 00:09:13,913
That's all, thank you.

163
00:09:18,310 --> 00:09:21,430
- Hello everyone, my name is Yuqing Zhao.

164
00:09:21,430 --> 00:09:25,109
Today our topic is, Related-Key Analysis

165
00:09:25,110 --> 00:09:27,460
of Generalized Feistel Networks

166
00:09:30,064 --> 00:09:32,589
with Expanding Round Functions.

167
00:09:32,590 --> 00:09:35,580
This is a joint work with
Wenqi Yu and (mumbles)

168
00:09:35,580 --> 00:09:39,433
professor Guo, we're all
from Shandong university.

169
00:09:40,890 --> 00:09:43,199
Here is outline of our talk.

170
00:09:43,200 --> 00:09:45,483
I will first introduce background.

171
00:09:46,500 --> 00:09:50,070
We will recall something
about Feistel networks.

172
00:09:50,070 --> 00:09:52,690
Feistel networks is well
as the most popular way

173
00:09:52,690 --> 00:09:57,690
to (indistinct) of Feistel permutation.

174
00:09:58,020 --> 00:10:01,610
The Feistel permutation maps
two n-bits to two n-bits

175
00:10:01,610 --> 00:10:03,200
at this picture,

176
00:10:03,200 --> 00:10:06,490
where F is a domain-preserving
round function,

177
00:10:06,490 --> 00:10:08,830
mapping n-bits to n-bits.

178
00:10:08,830 --> 00:10:12,430
As you can see the picture,
we turn to the left.

179
00:10:12,430 --> 00:10:15,890
The right side is A ⊕ F(B).

180
00:10:15,890 --> 00:10:18,439
I replaced the round function
with contracting ones,

181
00:10:18,440 --> 00:10:22,740
which come to contracting
Feistel networks.

182
00:10:22,740 --> 00:10:25,840
I replaced the round
function with expanding ones,

183
00:10:25,840 --> 00:10:29,390
which become expanding Feistel networks.

184
00:10:29,390 --> 00:10:31,160
By alternatively using

185
00:10:31,160 --> 00:10:33,569
contracting and expanding round functions,

186
00:10:33,570 --> 00:10:36,760
we come to alternating Feistel networks.

187
00:10:36,760 --> 00:10:41,100
Because these contractions
generalize Feistel networks,

188
00:10:41,100 --> 00:10:44,830
in this paper, we focus
our related-key security

189
00:10:44,830 --> 00:10:46,910
on generalized Feistel networks

190
00:10:46,910 --> 00:10:49,673
with expanding round functions.

191
00:10:51,200 --> 00:10:54,670
But now briefly we will
use the previous research.

192
00:10:54,670 --> 00:10:57,900
In the single-key
setting, Luby and Rackoff

193
00:10:57,900 --> 00:11:01,420
initiated a provable
security of Feistel networks

194
00:11:01,420 --> 00:11:02,372
and their variants.

195
00:11:03,310 --> 00:11:06,292
Hoang and Rogaway, Shen et proved that,

196
00:11:06,293 --> 00:11:10,967
CFN, EFN and AFN could
all achieve CCA security

197
00:11:10,967 --> 00:11:14,463
up to nearly 2 to m adversarial queries,

198
00:11:15,380 --> 00:11:18,053
m being the domain size
of the round function.

199
00:11:19,850 --> 00:11:22,058
In the related-key setting,

200
00:11:22,058 --> 00:11:24,240
Bellare and Kohno initiated

201
00:11:24,240 --> 00:11:27,060
the theoretical treatment of security

202
00:11:27,060 --> 00:11:28,772
under related-key attacks.

203
00:11:29,909 --> 00:11:33,218
Barbosa and Farshim
established the RKA security

204
00:11:33,218 --> 00:11:36,750
for four rounds balanced Feistel networks.

205
00:11:36,750 --> 00:11:39,370
Guo established the RKA security

206
00:11:39,370 --> 00:11:42,543
for the so-called
Feistel-2 Feistel ciphers.

207
00:11:43,650 --> 00:11:46,175
Let's introduced our motivation.

208
00:11:46,176 --> 00:11:49,946
Lucks, Nachef and Patarin
showed expanding functions

209
00:11:49,946 --> 00:11:52,245
are attractive in theory

210
00:11:52,245 --> 00:11:54,186
AFNs have been the structure

211
00:11:54,186 --> 00:11:57,463
of the NIST format-preserving
encryption standards.

212
00:11:58,408 --> 00:12:02,940
The contracting round functions
are built from AES-CBC,

213
00:12:02,940 --> 00:12:06,720
while the expanding are from AES-CTR.

214
00:12:06,720 --> 00:12:11,720
EFN and AFN asymptotically
optimal bounds have been proved,

215
00:12:11,850 --> 00:12:13,750
while the minimal number of rounds

216
00:12:13,750 --> 00:12:17,870
necessary for CCA
security remains unclear.

217
00:12:17,870 --> 00:12:21,643
GFN remain far less
understood in the RKA model.

218
00:12:23,120 --> 00:12:26,680
The second part is our contributions.

219
00:12:26,680 --> 00:12:28,675
In this paper, we studied

220
00:12:28,675 --> 00:12:32,359
related-key security or
generalized Feistel networks

221
00:12:32,360 --> 00:12:35,190
using expanding round functions.

222
00:12:35,190 --> 00:12:37,517
For expanding Feistel
networks (indistinct),

223
00:12:38,927 --> 00:12:40,460
2m divided by n,

224
00:12:40,460 --> 00:12:43,510
and k is the upper integer
of those two rounds

225
00:12:43,510 --> 00:12:45,813
are sufficient for single K CCA security.

226
00:12:46,820 --> 00:12:50,301
When two independent case K1, K2,

227
00:12:50,301 --> 00:12:52,390
are alternatively used in two rounds

228
00:12:52,390 --> 00:12:57,189
2m divided by n and k is
upper integer plus two rounds

229
00:12:57,190 --> 00:13:00,390
are sufficient for RKA CCA security

230
00:13:00,390 --> 00:13:03,823
up to 2 to n divided by
2 adversarial queries.

231
00:13:05,160 --> 00:13:08,543
This table is a provable
security results on EFN.

232
00:13:09,470 --> 00:13:11,740
As you can see from this table,

233
00:13:11,740 --> 00:13:13,660
for robusted balance security,

234
00:13:13,660 --> 00:13:15,270
we reduce number of rounds

235
00:13:15,270 --> 00:13:17,670
and increase the robustness
or the (indistinct).

236
00:13:19,300 --> 00:13:22,050
For alternating Feistel networks,

237
00:13:22,050 --> 00:13:23,650
4 rounds using (k1, k2, k1, k2),

238
00:13:25,685 --> 00:13:30,685
is RKA CCA secured to up to two
to n divided by two queries.

239
00:13:31,704 --> 00:13:35,320
And using tweakable keyed
function as a round function,

240
00:13:35,321 --> 00:13:39,422
4-round AFN with identical
round key is RKA CCA

241
00:13:39,422 --> 00:13:43,820
secure to up to 2 to n
divided by two queries.

242
00:13:43,820 --> 00:13:46,663
This table shows the provable
security results on AFN.

243
00:13:49,150 --> 00:13:53,189
The third part is our security proofs.

244
00:13:53,190 --> 00:13:56,880
In all our proof we used
the two-step approach.

245
00:13:56,880 --> 00:13:58,590
The RK security proof

246
00:13:58,590 --> 00:14:02,470
starts with a generic
standard-to-ideal reduction,

247
00:14:02,470 --> 00:14:06,060
replacing the round function
with ideal keyed function.

248
00:14:06,060 --> 00:14:09,760
Then the core is to analyze
the idealized networks

249
00:14:09,760 --> 00:14:11,467
in the RKA setting.

250
00:14:11,467 --> 00:14:15,550
For the RKA analysis of
the idealized networks,

251
00:14:15,550 --> 00:14:19,660
we employed the widely used
H-coefficient technique.

252
00:14:19,660 --> 00:14:22,969
This step follow the same general pattern

253
00:14:22,970 --> 00:14:25,289
as the H-coefficient
(mumbles) the single case

254
00:14:25,289 --> 00:14:26,723
CCA security analysis.

255
00:14:27,980 --> 00:14:30,940
So, the analysis had to consider

256
00:14:30,940 --> 00:14:32,610
the interaction between queries

257
00:14:32,610 --> 00:14:35,490
under different relative keys.

258
00:14:35,490 --> 00:14:38,210
And interference between different rounds

259
00:14:38,210 --> 00:14:39,660
that are using the same keys.

260
00:14:41,680 --> 00:14:45,809
We now briefly discuss the proof for EFN.

261
00:14:45,809 --> 00:14:49,300
Firstly, we pinpoint the number of rounds

262
00:14:49,300 --> 00:14:51,410
that are pair sufficient.

263
00:14:51,410 --> 00:14:52,650
You can say the the patrion.

264
00:14:52,650 --> 00:14:54,819
We identify light number rounds

265
00:14:54,820 --> 00:14:57,040
sufficient for full diffusion,

266
00:14:57,040 --> 00:15:00,901
is m divided by n, and
k is the upper integer.

267
00:15:00,902 --> 00:15:03,274
And the two middle rounds are sufficient

268
00:15:03,274 --> 00:15:05,210
as the randomness source.

269
00:15:05,210 --> 00:15:08,963
So this is the RKA CCA
security expanding Feistel.

270
00:15:10,550 --> 00:15:14,569
Now we pay attention to robust
balance security of EFN,

271
00:15:14,570 --> 00:15:17,540
where F maps n-bits to m-bits.

272
00:15:17,540 --> 00:15:22,540
For theorem 1, this is
advantage for 2m divided by n,

273
00:15:22,540 --> 00:15:25,438
and there's upper integer
for these two rounds.

274
00:15:25,438 --> 00:15:30,438
Our EFN is our first step
where we place the K function.

275
00:15:30,930 --> 00:15:34,160
F, n-bits to m-bits
with a random function,

276
00:15:34,160 --> 00:15:37,010
RF n-bits to m-bits.

277
00:15:37,010 --> 00:15:41,030
As two independent case,
k1, k2, are involved,

278
00:15:41,030 --> 00:15:45,140
a standard hybrid argument
yields this inequality.

279
00:15:45,140 --> 00:15:48,263
Well, the first step is to
analyze the idealized EFN.

280
00:15:51,100 --> 00:15:54,910
So we will use H-coefficient technique.

281
00:15:54,910 --> 00:15:58,372
We will define bad predicts
or bad transcripts,

282
00:15:59,230 --> 00:16:02,910
and upper bound is the
probability in ideal world.

283
00:16:02,910 --> 00:16:04,079
And let me show you guys

284
00:16:04,080 --> 00:16:07,550
the probability to obtain
an attainable transcript

285
00:16:07,550 --> 00:16:12,260
in the real world and the ideal
world as efficiently close.

286
00:16:12,260 --> 00:16:16,760
So bad transcripts helps to
either claw or switch in Tau.

287
00:16:16,760 --> 00:16:21,340
It is clear that, the
probability of Tid in Tau bad,

288
00:16:21,340 --> 00:16:25,067
is less than or equal to
the advantage for claw-free

289
00:16:25,067 --> 00:16:27,453
plus the advantage for switch-free.

290
00:16:29,130 --> 00:16:31,870
Next, analyzing good transcripts.

291
00:16:31,870 --> 00:16:35,380
Well, to start, we need
to define bad predicate

292
00:16:35,380 --> 00:16:39,369
of the ideal keyed function
RF, n-bits to m-bits.

293
00:16:39,369 --> 00:16:42,329
Such that, once this is not fulfilled,

294
00:16:42,329 --> 00:16:44,709
the event Tid equal to Tau

295
00:16:44,709 --> 00:16:47,919
is equivalent to RF, n-bits to m-bits,

296
00:16:47,919 --> 00:16:51,983
satisfying 2q new and
the distinct equations.

297
00:16:51,983 --> 00:16:53,900
These are 2q equations.

298
00:16:55,815 --> 00:16:59,790
The proof for AFN is similar
to the proof for EFN,

299
00:16:59,790 --> 00:17:04,790
they must certify the bad
predicate of the ideal k function,

300
00:17:05,040 --> 00:17:08,855
such that it is satisfying 2q equations.

301
00:17:08,855 --> 00:17:12,740
For theorem 2, this is
all for the one page,

302
00:17:12,740 --> 00:17:16,619
for four rounds of AFN,
we use triple K function

303
00:17:16,619 --> 00:17:20,669
that behave as contracting
for checking point zero,

304
00:17:20,670 --> 00:17:22,770
while expanding for triple 1.

305
00:17:22,770 --> 00:17:26,150
For the AFN using such a triple K function

306
00:17:26,150 --> 00:17:27,819
as a round function,

307
00:17:27,819 --> 00:17:30,200
the reduction is able to handle the case

308
00:17:30,200 --> 00:17:32,350
of identical round case.

309
00:17:32,350 --> 00:17:35,483
So we kind of turn the Corollary 1,

310
00:17:35,483 --> 00:17:37,893
this is advantage for four rounds of AFN

311
00:17:38,834 --> 00:17:41,933
using a triple round function, single K.

312
00:17:42,850 --> 00:17:47,600
For conclusion, we show that
when two independent case

313
00:17:47,600 --> 00:17:51,590
k1, k2, are alternatively
used in each round,

314
00:17:51,590 --> 00:17:56,312
2m divided by n, and gets the
upper integer plus two rounds

315
00:17:56,312 --> 00:17:59,132
are sufficient for
related-key security of EFN.

316
00:18:00,660 --> 00:18:02,327
A constant number of 4 rounds

317
00:18:02,327 --> 00:18:05,953
are sufficient for
related-key security of AFN.

318
00:18:06,910 --> 00:18:08,870
Our results complete the picture

319
00:18:08,870 --> 00:18:12,760
of provable related-key security of GFN,

320
00:18:12,760 --> 00:18:16,090
and provide additional theoretical support

321
00:18:16,090 --> 00:18:18,540
for the AFN-based NIST format

322
00:18:18,540 --> 00:18:23,053
preserving encryption
standards, FF1 and FF3.

323
00:18:24,450 --> 00:18:26,310
Apply what you have learned today.

324
00:18:26,310 --> 00:18:28,320
Next week, you should understand

325
00:18:28,320 --> 00:18:30,490
the H-coefficient technique.

326
00:18:30,490 --> 00:18:33,699
Within four months you
should prove RKA CCA

327
00:18:33,699 --> 00:18:36,880
of EFN and AFN is single-key setting.

328
00:18:37,880 --> 00:18:40,210
Okay, that's all, thank you for listening,

329
00:18:40,210 --> 00:18:42,250
I'm happy to take the questions.

330
00:18:46,450 --> 00:18:50,460
- So this paper is about The
Key-Dependent Message Security

331
00:18:50,460 --> 00:18:53,690
of Key-Alternating Feistel Ciphers,

332
00:18:53,690 --> 00:18:57,099
and it's a joint work with
Pooya Farshim, Yannick Seurin

333
00:18:57,099 --> 00:18:58,379
and Damien Vergnaud.

334
00:18:58,380 --> 00:19:02,860
So, I'm Louiza Khati, and I
work at ANSSI and the ENS.

335
00:19:02,860 --> 00:19:06,620
So, the goal of this paper
is to give a proof technique

336
00:19:06,620 --> 00:19:11,620
to analyze symmetric
construction under this trunk,

337
00:19:11,820 --> 00:19:13,913
key-dependent message security model.

338
00:19:15,210 --> 00:19:17,420
So let's see what is KDM security.

339
00:19:17,420 --> 00:19:20,900
KDM stands for key-dependent
message security.

340
00:19:20,900 --> 00:19:22,640
And in the secret model,

341
00:19:22,640 --> 00:19:25,130
we take into account a
very strong adversary

342
00:19:25,130 --> 00:19:27,790
that has access to some cipher decks,

343
00:19:27,790 --> 00:19:31,040
that are the result of the
encryption of some message,

344
00:19:31,040 --> 00:19:32,610
that depend on the key

345
00:19:32,610 --> 00:19:35,433
even if the adversary
has no access to the key.

346
00:19:38,200 --> 00:19:40,050
So, this model was first introduced

347
00:19:40,050 --> 00:19:41,643
by Blake (indistinct) in 2003.

348
00:19:44,280 --> 00:19:47,170
And our use case is full disk encryption.

349
00:19:47,170 --> 00:19:49,350
When you're using a full
disk encryption tool,

350
00:19:49,350 --> 00:19:54,350
what happen is that your data
are encrypted at a low level

351
00:19:54,350 --> 00:19:57,780
and the encryption key
might end in the disc.

352
00:19:57,780 --> 00:20:01,633
So you wouldn't encrypt
this key by itself.

353
00:20:03,570 --> 00:20:06,950
And the construction
we analyze is the KAF.

354
00:20:06,950 --> 00:20:10,200
So for Key-Alternating Feistel ciphers,

355
00:20:10,200 --> 00:20:12,540
this is the construction here.

356
00:20:12,540 --> 00:20:15,020
You can see that it's an instantiation

357
00:20:15,020 --> 00:20:16,510
of the five-star network.

358
00:20:16,510 --> 00:20:19,710
So the message is split into the left part

359
00:20:19,710 --> 00:20:21,070
and the right part.

360
00:20:21,070 --> 00:20:23,627
The right part will be exertive of subkey.

361
00:20:25,440 --> 00:20:27,200
And then this value will be processed

362
00:20:27,200 --> 00:20:28,870
by a random function F1,

363
00:20:28,870 --> 00:20:32,229
and then exerted to the
left part of the message.

364
00:20:32,230 --> 00:20:34,453
So this is one around KAF.

365
00:20:35,690 --> 00:20:39,490
So the configuration of a
KAF is a number of rounds

366
00:20:39,490 --> 00:20:43,170
if all these functions
are equal and different.

367
00:20:43,170 --> 00:20:45,680
Of course, if all these
functions are equal

368
00:20:45,680 --> 00:20:48,070
it means that we have an
efficient configuration

369
00:20:48,070 --> 00:20:51,393
because we implement
this function only once.

370
00:20:52,260 --> 00:20:55,730
And the configuration encompasses

371
00:20:55,730 --> 00:20:59,643
also the fact that all these
keys are equal and different.

372
00:21:00,850 --> 00:21:04,213
Usually in practice, all these keys,

373
00:21:04,213 --> 00:21:06,293
they're related from a master key.

374
00:21:07,420 --> 00:21:09,220
And the previous work on this construction

375
00:21:09,220 --> 00:21:12,450
was done by Lampe and Seurin in 2015.

376
00:21:12,450 --> 00:21:14,790
They analyzed this construction

377
00:21:14,790 --> 00:21:17,550
under the indistinguishability game.

378
00:21:17,550 --> 00:21:19,649
And the same year Guo and Lin

379
00:21:19,650 --> 00:21:22,980
analyzed the
indifferentiability of the KAF*.

380
00:21:22,980 --> 00:21:26,290
So the KAF* is a little
bit different from the KAF.

381
00:21:26,290 --> 00:21:30,520
So instead of exerting this key
before this random function,

382
00:21:30,520 --> 00:21:32,113
it will be exerted after.

383
00:21:34,500 --> 00:21:36,720
And this construction is important

384
00:21:36,720 --> 00:21:39,420
because it's used in practice

385
00:21:40,370 --> 00:21:42,822
in the DES and GOST block ciphers.

386
00:21:44,690 --> 00:21:47,400
So here is the indistinguishability game

387
00:21:47,400 --> 00:21:49,650
for the KDM adversary.

388
00:21:49,650 --> 00:21:52,050
So as in all indistinguishability game,

389
00:21:52,050 --> 00:21:55,710
we have this adversary
that talks to an oracle,

390
00:21:55,710 --> 00:21:58,730
and this oracle either
implement the real world

391
00:21:58,730 --> 00:22:00,160
or the ideal world.

392
00:22:00,160 --> 00:22:02,500
So in the real world,
we have the construction

393
00:22:02,500 --> 00:22:04,350
we want to analyze.

394
00:22:04,350 --> 00:22:07,360
And in ideal world, we
have this ideal primitive,

395
00:22:07,360 --> 00:22:11,020
so for block ciphers,
it's a random validation.

396
00:22:11,020 --> 00:22:12,850
And to simulate the fact

397
00:22:12,850 --> 00:22:15,899
that this adversary can
access some cipher decks

398
00:22:15,900 --> 00:22:19,370
that are the result of
the encryption of message

399
00:22:19,370 --> 00:22:20,850
that depend on the key,

400
00:22:20,850 --> 00:22:24,419
we will allow the adversary
to send a function Phi,

401
00:22:24,420 --> 00:22:25,770
that can depend on the key

402
00:22:25,770 --> 00:22:29,420
even if this adversary
does not know the key.

403
00:22:29,420 --> 00:22:32,930
So, if this function is
a constant, it means that

404
00:22:32,930 --> 00:22:35,800
we are in the regular
indistinguishability game.

405
00:22:35,800 --> 00:22:37,120
And if it's depends on the key,

406
00:22:37,120 --> 00:22:41,963
so we have our KDM-CPA adversary.

407
00:22:43,260 --> 00:22:46,640
So here, the oracle will compute Phi of k,

408
00:22:46,640 --> 00:22:50,270
and then it will evaluate
the output of Phi of k

409
00:22:50,270 --> 00:22:52,920
under either the construction
you want to analyze

410
00:22:52,920 --> 00:22:55,490
either this random validation.

411
00:22:55,490 --> 00:22:57,220
And of course, if we have

412
00:22:58,811 --> 00:23:01,169
a KDM security construction adversary,

413
00:23:01,170 --> 00:23:02,850
you should not be able to distinguish

414
00:23:02,850 --> 00:23:04,132
between these two games.

415
00:23:05,010 --> 00:23:07,270
So here is the advantage of the adversary,

416
00:23:07,270 --> 00:23:10,150
it's the classical definition of it.

417
00:23:10,150 --> 00:23:12,053
And for the CCA adversary,

418
00:23:15,531 --> 00:23:17,889
he's also allowed to
decrypt some cipher decks,

419
00:23:17,890 --> 00:23:19,063
and these cipher decks,

420
00:23:20,690 --> 00:23:22,680
he's allowed only to
decrypt some constants.

421
00:23:22,680 --> 00:23:26,440
Because we can think that we can allow him

422
00:23:26,440 --> 00:23:28,560
to send a function Phi,

423
00:23:28,560 --> 00:23:29,990
so a cipher deck that depend on the key

424
00:23:29,990 --> 00:23:32,570
but there is no use-case for that.

425
00:23:32,570 --> 00:23:34,770
So this is a standard decryption.

426
00:23:36,720 --> 00:23:39,760
So when you want to
analyze the KDM security

427
00:23:39,760 --> 00:23:41,490
of a construction,

428
00:23:41,490 --> 00:23:45,480
you need to find the
largest set of function Phi,

429
00:23:45,480 --> 00:23:48,140
such that the previous advantage is small.

430
00:23:48,140 --> 00:23:50,320
And it should include
the constant function

431
00:23:50,320 --> 00:23:54,100
because this is what it's
done in the regular SPA game.

432
00:23:54,100 --> 00:23:57,072
You can encrypt messages
that are constants.

433
00:23:58,150 --> 00:24:00,610
And we know that since the seminar paper,

434
00:24:00,610 --> 00:24:04,540
that the KDM set has to be restricted

435
00:24:04,540 --> 00:24:07,700
otherwise we can extract the key.

436
00:24:07,700 --> 00:24:10,390
And we gave an example in a previous work

437
00:24:10,390 --> 00:24:13,113
done with (mumbles) and Damien Vergnaud.

438
00:24:14,070 --> 00:24:17,399
We exploited this kind of function,

439
00:24:17,400 --> 00:24:18,840
the function that has closed

440
00:24:18,840 --> 00:24:22,889
that collide under the key k.

441
00:24:22,890 --> 00:24:24,940
So Phi 1 and Phi 2 are different,

442
00:24:24,940 --> 00:24:27,770
but Phi 1 of k is equal to Phi 2 of k.

443
00:24:27,770 --> 00:24:30,889
So we should put some
constraints on this KDM set,

444
00:24:30,890 --> 00:24:34,130
and the first one is this claw-freeness

445
00:24:34,130 --> 00:24:36,090
to remove this kind of function.

446
00:24:36,090 --> 00:24:38,800
On this work, we also proved that

447
00:24:38,800 --> 00:24:41,993
the Idle-Cipher is KDM-secure
under a claw-free sets.

448
00:24:43,210 --> 00:24:47,370
And now we will see the
KDM security of this KAF.

449
00:24:47,370 --> 00:24:52,370
So here you can see that I
took the KDM security game,

450
00:24:53,290 --> 00:24:55,680
and I just instantiated for the KAF.

451
00:24:55,680 --> 00:24:58,530
So the adversary here, can ask to encrypt

452
00:24:58,530 --> 00:25:02,290
under this couple of
function, Phi L and Phi R

453
00:25:02,290 --> 00:25:06,210
because of this five-step
live construction.

454
00:25:06,210 --> 00:25:10,140
And we also gave access
to this public function

455
00:25:10,140 --> 00:25:12,080
to the addressee, because they are public

456
00:25:12,080 --> 00:25:13,993
and the same in the ideal world.

457
00:25:17,030 --> 00:25:19,740
So, we feel that claw-freeness

458
00:25:19,740 --> 00:25:24,740
it's important to have KDM
security, but it's not enough.

459
00:25:25,040 --> 00:25:28,899
So for example, for the 4-round KAF,

460
00:25:28,900 --> 00:25:32,380
where all the internal function are equal.

461
00:25:32,380 --> 00:25:35,470
So the efficient version
of the full round KAF,

462
00:25:35,470 --> 00:25:38,220
and where all the keys are independent.

463
00:25:38,220 --> 00:25:41,050
If the only restriction is claw-freeness,

464
00:25:41,050 --> 00:25:44,690
we can find some function
to broke the security game

465
00:25:44,690 --> 00:25:46,550
with only two queries.

466
00:25:46,550 --> 00:25:49,870
And we took advantage of
this kind of function,

467
00:25:49,870 --> 00:25:53,479
the sum function that offsets a subkey.

468
00:25:53,480 --> 00:25:57,120
So this kind of function looked like this,

469
00:25:57,120 --> 00:26:00,973
Phi of k is equal to k1 is or a constant.

470
00:26:02,480 --> 00:26:04,810
So for this configuration,

471
00:26:04,810 --> 00:26:07,550
we feel that we need
also these new properties

472
00:26:07,550 --> 00:26:11,240
offset-freeness for the set file.

473
00:26:11,240 --> 00:26:13,823
You can find, of course,
it's there in the paper.

474
00:26:14,810 --> 00:26:17,060
Another friendly attack
is the sliding attack

475
00:26:17,060 --> 00:26:20,860
that works for any number of rounds,

476
00:26:20,860 --> 00:26:23,466
for the configuration where
all the internal function

477
00:26:23,467 --> 00:26:25,840
and all the keys are equal.

478
00:26:25,840 --> 00:26:26,820
We already know

479
00:26:26,820 --> 00:26:30,050
that this construction
is not even CPA secure,

480
00:26:30,050 --> 00:26:32,970
but we've our strong adversary,

481
00:26:32,970 --> 00:26:35,743
with one query we can
extract the key easily.

482
00:26:38,010 --> 00:26:41,510
So, now I will just give you an overview

483
00:26:41,510 --> 00:26:44,210
of the proof technique

484
00:26:44,210 --> 00:26:47,653
because this is the heart of our paper.

485
00:26:51,160 --> 00:26:53,230
So this proof technique

486
00:26:53,230 --> 00:26:56,680
is based on the game playing technique

487
00:26:56,680 --> 00:26:58,120
and the H-coefficient technique.

488
00:26:58,120 --> 00:27:00,370
So the H-coefficient technique

489
00:27:00,370 --> 00:27:03,850
was first introduced by Patarin,

490
00:27:03,850 --> 00:27:07,340
and it's a widely used technique

491
00:27:07,340 --> 00:27:09,513
to analyze the security of block ciphers.

492
00:27:10,680 --> 00:27:12,950
And here we have our adversary.

493
00:27:12,950 --> 00:27:16,960
You can recognize our
ideal world, our real word,

494
00:27:16,960 --> 00:27:20,780
and in the middle, we
introduced this perfect world.

495
00:27:20,780 --> 00:27:24,899
So this perfect world was introduced

496
00:27:24,900 --> 00:27:28,400
to catch the claw-freeness,

497
00:27:28,400 --> 00:27:30,700
yeah, the claw-freeness property.

498
00:27:30,700 --> 00:27:33,260
So here, each time the adversary

499
00:27:33,260 --> 00:27:37,370
will ask the encryption
of some function Phi,

500
00:27:37,370 --> 00:27:39,750
who will assemble a random output.

501
00:27:39,750 --> 00:27:42,890
So here, if we choose two
function that have a claws,

502
00:27:42,890 --> 00:27:45,233
or we will have a different behavior here.

503
00:27:46,480 --> 00:27:50,370
So this first advantage is generic.

504
00:27:50,370 --> 00:27:52,409
So if you want to use this proof technique

505
00:27:52,410 --> 00:27:54,010
to analyze another construction,

506
00:27:54,010 --> 00:27:56,820
you don't have to recompute this one.

507
00:27:56,820 --> 00:27:59,270
But you will need to work on that one

508
00:27:59,270 --> 00:28:03,100
because this one is close
to the construction.

509
00:28:03,100 --> 00:28:06,719
So, I don't have much
time to go into detail

510
00:28:06,720 --> 00:28:11,720
because you can find all of
the details in the paper.

511
00:28:13,660 --> 00:28:16,323
So, now I will just present our results.

512
00:28:17,680 --> 00:28:21,703
So here in blue, we have what we proved.

513
00:28:22,640 --> 00:28:25,087
So we proved that the 4-round Feistel

514
00:28:27,170 --> 00:28:29,810
where all the internal
functions are equal.

515
00:28:29,810 --> 00:28:34,810
So the efficient version of the F1 KAF,

516
00:28:36,882 --> 00:28:39,160
and where all these keys are different

517
00:28:39,160 --> 00:28:43,737
and actually we don't care
about the values in the middle.

518
00:28:43,737 --> 00:28:44,570
We have KDM security

519
00:28:44,570 --> 00:28:47,807
under a set that is
claw-free, offset-free.

520
00:28:47,807 --> 00:28:50,600
And offset (indistinct) free.

521
00:28:50,600 --> 00:28:55,600
So, we are not surprised about
this two first constraints,

522
00:28:55,990 --> 00:29:00,990
because we said that
claw-freeness is needed.

523
00:29:01,400 --> 00:29:04,290
Offset-freeness where we
showed that we have an attack

524
00:29:04,290 --> 00:29:08,200
if we only have a claw-free KDM set.

525
00:29:08,200 --> 00:29:11,590
And we have this new constraint,

526
00:29:11,590 --> 00:29:13,350
this offset (indistinct) freeness,

527
00:29:13,350 --> 00:29:15,469
which includes these kinds of function.

528
00:29:15,470 --> 00:29:18,390
So function that the (mumbles)
of two different function

529
00:29:18,390 --> 00:29:19,563
and a constant.

530
00:29:21,030 --> 00:29:24,520
So here are the two conjectures we have,

531
00:29:24,520 --> 00:29:27,720
like we didn't prove these two lines.

532
00:29:27,720 --> 00:29:31,390
So we feel that we can
remove this new condition,

533
00:29:31,390 --> 00:29:33,610
this new restriction on the KDM set,

534
00:29:33,610 --> 00:29:36,199
if we have different functions.

535
00:29:36,200 --> 00:29:38,280
So, 4-round in different function,

536
00:29:38,280 --> 00:29:42,899
or if we want to have an
efficient constriction,

537
00:29:42,900 --> 00:29:44,410
so the same internal function.

538
00:29:44,410 --> 00:29:47,270
We need to go to five rounds.

539
00:29:47,270 --> 00:29:48,280
And as you can see,

540
00:29:48,280 --> 00:29:51,760
we will only remove these
offset (indistinct) freeness.

541
00:29:51,760 --> 00:29:53,620
And the big question is,

542
00:29:53,620 --> 00:29:56,750
how many rounds do we need to
have the KDM security level

543
00:29:56,750 --> 00:29:58,730
of the ideal cipher?

544
00:29:58,730 --> 00:30:03,730
So, KDM security under a
set that is only claw-free.

545
00:30:04,100 --> 00:30:07,882
So, we do not have the answer,

546
00:30:08,900 --> 00:30:12,790
but we know that we cannot
have the KDM security

547
00:30:12,790 --> 00:30:14,820
under claw-free set for the configuration,

548
00:30:14,820 --> 00:30:19,149
where all Fi's are equal
and where all Ki's are equal

549
00:30:19,150 --> 00:30:21,690
because we have the sliding attack.

550
00:30:21,690 --> 00:30:26,590
So I will end this talk now.

551
00:30:26,590 --> 00:30:31,590
So, just remember that our
next talk is about this line.

552
00:30:32,170 --> 00:30:34,830
So this is the important thing to do

553
00:30:38,309 --> 00:30:41,440
in new work in the next week.

554
00:30:41,440 --> 00:30:45,307
So, thank you for your attention.

