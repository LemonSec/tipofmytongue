1
00:00:01,440 --> 00:00:04,059
- Welcome to our session,
Beyond Living-off-the-Land.

2
00:00:04,059 --> 00:00:07,270
Why XP exploits still matter today?

3
00:00:07,270 --> 00:00:09,750
So here are a few questions for you.

4
00:00:09,750 --> 00:00:12,580
What if I told you that Windows XP exploit

5
00:00:12,580 --> 00:00:15,362
can still affect the security
of your organizations

6
00:00:15,362 --> 00:00:19,790
even if you're not using
any Windows XP machines

7
00:00:19,790 --> 00:00:22,430
what if I told you that
security researcher

8
00:00:22,430 --> 00:00:24,710
should care about these exploits

9
00:00:24,710 --> 00:00:27,400
because they are still relevant today.

10
00:00:27,400 --> 00:00:29,162
What if I told you that defenders

11
00:00:29,162 --> 00:00:32,250
should consider putting Windows XP exploit

12
00:00:32,250 --> 00:00:35,230
in their threat model even
if none of their systems

13
00:00:35,230 --> 00:00:38,072
are using the this old
NT operating systems.

14
00:00:38,073 --> 00:00:41,210
I'm Jean-Ian, and together
with Zuzana my colleague,

15
00:00:41,210 --> 00:00:43,890
we will walk you through
why XP exploits still matter

16
00:00:43,890 --> 00:00:44,811
through use cases.

17
00:00:44,811 --> 00:00:48,020
We will discuss why you
should consider including it

18
00:00:48,020 --> 00:00:49,350
in your threat model.

19
00:00:49,350 --> 00:00:51,533
And also walk you through
defense mechanisms

20
00:00:51,533 --> 00:00:54,870
that you can put so that
your organizations is safe

21
00:00:54,870 --> 00:00:56,720
from this threat factor.

22
00:00:56,720 --> 00:00:58,660
So why Windows XP exploits?

23
00:00:58,660 --> 00:01:01,568
So could it be that attackers
that already have access

24
00:01:01,568 --> 00:01:05,950
to a system could actually
leverage all Windows binaries

25
00:01:05,950 --> 00:01:08,017
to achieve more stuff.

26
00:01:08,017 --> 00:01:09,822
Well, if you want to
protect your environment

27
00:01:09,822 --> 00:01:12,365
you should expect the unexpected.

28
00:01:12,365 --> 00:01:15,646
And today we will cover the unexpected.

29
00:01:15,646 --> 00:01:17,738
A threat actor that in a recent campaign

30
00:01:17,738 --> 00:01:21,666
use all the Windows binaries
to achieve their goals.

31
00:01:21,666 --> 00:01:24,270
But before we go there,
how did we get here?

32
00:01:24,270 --> 00:01:27,115
How come this technique
is of relevance today?

33
00:01:27,115 --> 00:01:32,115
So the first step is
Living-off-the-Land techniques.

34
00:01:34,040 --> 00:01:37,080
And in this section, we
will go over a solution

35
00:01:37,080 --> 00:01:41,090
and bring you one step ahead
and in the evolution chain.

36
00:01:41,090 --> 00:01:44,060
So this Living-off-the-Land
name was coined

37
00:01:44,060 --> 00:01:46,650
back in 2013 at DerbyCon.

38
00:01:46,650 --> 00:01:49,260
And these are binaries
that are already present

39
00:01:49,260 --> 00:01:52,760
on a system so-called
LOLBins that can be abused

40
00:01:52,760 --> 00:01:55,510
by attackers for several goals,

41
00:01:55,510 --> 00:01:57,430
so they can achieve
persistence through it.

42
00:01:57,430 --> 00:02:00,710
They can also achieve
execution, network communication

43
00:02:00,710 --> 00:02:03,369
lateral movement, basically
anything they need

44
00:02:03,370 --> 00:02:05,370
to have a successful campaign.

45
00:02:05,370 --> 00:02:08,620
And we all live through
the increased usage

46
00:02:08,620 --> 00:02:10,410
of living-off-the-land techniques.

47
00:02:10,410 --> 00:02:13,950
And there are now a standard
component of modern attacks

48
00:02:13,950 --> 00:02:16,299
with the aim of evading security solutions

49
00:02:16,300 --> 00:02:18,943
as the main driver behind their adoption.

50
00:02:20,340 --> 00:02:22,440
So now various smaller families

51
00:02:22,440 --> 00:02:25,510
are using Living-off-the-land techniques.

52
00:02:25,510 --> 00:02:27,940
They enable also called fileless malware

53
00:02:27,940 --> 00:02:31,590
meaning that no malware
will ever touch the disk.

54
00:02:31,590 --> 00:02:35,640
And these tools cannot usually
be blocked by IT security

55
00:02:35,640 --> 00:02:38,070
because IT operations actually need

56
00:02:38,070 --> 00:02:39,859
them in their daily activities.

57
00:02:39,860 --> 00:02:41,840
And this illustrates well, the trade-off

58
00:02:41,840 --> 00:02:45,680
or fight between IT
security and IT operations

59
00:02:45,680 --> 00:02:50,150
total security against these
tools is usually not an option.

60
00:02:50,150 --> 00:02:53,960
As this technique became more mainstream

61
00:02:53,960 --> 00:02:57,200
defenders started to include
them in the threat model

62
00:02:57,200 --> 00:03:00,500
and can now benefit from
tools to better detect them

63
00:03:00,500 --> 00:03:03,020
and also mitigate the
threat if an attacker

64
00:03:03,020 --> 00:03:06,660
wants to use LOLBins as
part of the campaigns.

65
00:03:06,660 --> 00:03:09,049
It also spring up a new area of research

66
00:03:09,050 --> 00:03:11,470
where pentesters and attackers are alike.

67
00:03:11,470 --> 00:03:14,920
Were looking for these
binaries on your system

68
00:03:14,920 --> 00:03:18,760
and trying to abuse them to
reach their campaign goals.

69
00:03:18,760 --> 00:03:21,290
So what happens when an
attacker needs something

70
00:03:21,290 --> 00:03:22,581
that is not provided by the LOLBins

71
00:03:22,581 --> 00:03:24,815
that are already on the system?

72
00:03:24,815 --> 00:03:29,370
This brings us to the next
step in the evolution chain.

73
00:03:29,370 --> 00:03:31,120
So if they're are already in the system

74
00:03:31,120 --> 00:03:35,690
they are able to download and
bring their own executable.

75
00:03:35,690 --> 00:03:38,230
They can then bring their
own legitimate application

76
00:03:38,230 --> 00:03:40,530
and abuse them to reach their goals.

77
00:03:40,530 --> 00:03:43,160
So that's brings us
back in September, 2019

78
00:03:43,160 --> 00:03:46,290
where Microsoft published this
research that you see here

79
00:03:46,290 --> 00:03:48,150
which is bringing your own LOLBins.

80
00:03:48,150 --> 00:03:50,450
The Multi-stage fileless Nodersok campaign

81
00:03:50,450 --> 00:03:53,459
and this is the next step
in our evolution chain.

82
00:03:53,460 --> 00:03:55,090
And basically what this campaign did

83
00:03:55,090 --> 00:03:57,620
is that they brought two legitimate tools.

84
00:03:57,620 --> 00:03:59,100
One of them was Nagios XI

85
00:03:59,100 --> 00:04:01,960
which is the Microsoft
Windows implementation

86
00:04:01,960 --> 00:04:04,726
of the widely popular Nagios framework.

87
00:04:04,726 --> 00:04:08,440
And the other one was WinDivert which is

88
00:04:08,440 --> 00:04:13,440
a network architecture and
manipulation (indistinct)

89
00:04:13,730 --> 00:04:15,997
So as a recap, we have
bring your own LOLBins

90
00:04:15,997 --> 00:04:18,300
as a next step to LOLBins.

91
00:04:18,300 --> 00:04:21,610
So attacker that have
already access to a system

92
00:04:21,610 --> 00:04:24,010
that are bringing in
legitimate applications

93
00:04:24,010 --> 00:04:26,780
that they can then abuse
to reach their goals.

94
00:04:26,780 --> 00:04:29,179
Now, as these are widely known

95
00:04:29,180 --> 00:04:31,760
and usually widely seen applications,

96
00:04:31,760 --> 00:04:34,308
they are likely to fly under the radar

97
00:04:34,309 --> 00:04:38,170
of your defense mechanisms.

98
00:04:38,170 --> 00:04:41,710
Now, what we believe will be the next step

99
00:04:41,710 --> 00:04:45,090
to the evolution is actually VULNBins.

100
00:04:45,090 --> 00:04:48,001
So this is a term for vulnerable binaries.

101
00:04:48,002 --> 00:04:52,090
So threat attackers that
are actually bringing in

102
00:04:52,090 --> 00:04:54,859
vulnerable applications
and exploiting them

103
00:04:54,860 --> 00:04:57,330
to further gain access to a network

104
00:04:57,330 --> 00:05:00,680
or be able to achieve their goals.

105
00:05:00,680 --> 00:05:04,326
So in the next session, we'll
look at how threat actor

106
00:05:04,326 --> 00:05:07,640
can leverage these VULNBins
and have persistence,

107
00:05:07,640 --> 00:05:09,669
but stealthiness along with it.

108
00:05:09,670 --> 00:05:13,710
How many more kind of footprint
be when they use VULNBins?

109
00:05:13,710 --> 00:05:16,070
Zuzana will walk you through a recent case

110
00:05:16,070 --> 00:05:18,150
we documented, Zuzana.

111
00:05:18,150 --> 00:05:21,169
- Hello everyone and let's
jump right into this case study

112
00:05:21,170 --> 00:05:24,230
to show you a more concrete
example of this technique

113
00:05:24,230 --> 00:05:26,620
that Jean-Ian introduced to us.

114
00:05:26,620 --> 00:05:29,420
So in 2020, we were a part of a targeted

115
00:05:29,420 --> 00:05:33,070
espionage investigation
threat actor activity

116
00:05:33,070 --> 00:05:35,150
called InvisiMole.

117
00:05:35,150 --> 00:05:37,469
And as Jean-Ian already
hinted, the threat actor

118
00:05:37,470 --> 00:05:39,190
made our life more difficult

119
00:05:39,190 --> 00:05:42,010
because of the way how they
minimize their footprint

120
00:05:42,010 --> 00:05:44,039
on the target system.

121
00:05:44,040 --> 00:05:45,863
But we were working with
the effected parties

122
00:05:45,863 --> 00:05:48,253
and so we were able to
connect the dots anyway.

123
00:05:48,253 --> 00:05:50,810
Thanks for it's cooperation.

124
00:05:50,810 --> 00:05:52,240
And so we got the unique look

125
00:05:52,240 --> 00:05:54,610
into their post-compromised activities

126
00:05:54,610 --> 00:05:57,120
and we discovered this technique.

127
00:05:57,120 --> 00:05:58,500
So today we want to focus

128
00:05:58,500 --> 00:06:02,220
on this Post-compromised
technique used by InvisiMole.

129
00:06:02,220 --> 00:06:05,740
So more concretely we want
to cover persistence methods

130
00:06:05,740 --> 00:06:07,830
used by InvisiMole.

131
00:06:07,830 --> 00:06:09,829
As you can see we
identified four different

132
00:06:09,829 --> 00:06:12,930
persistence strategies
and these are designed

133
00:06:12,930 --> 00:06:14,640
for different types of victims.

134
00:06:14,640 --> 00:06:16,840
So the attackers would choose one of these

135
00:06:16,840 --> 00:06:18,943
persistence methods based on victims,

136
00:06:18,944 --> 00:06:22,030
OS version, architecture
based on whether they were

137
00:06:22,030 --> 00:06:24,063
able to get admin privileges or not.

138
00:06:25,290 --> 00:06:28,640
But in all of these cases,
the strategy is the same.

139
00:06:28,640 --> 00:06:31,280
These attackers rely heavily on LOLBins

140
00:06:31,280 --> 00:06:35,869
so legitimate binaries and
also what we call VULNBins.

141
00:06:35,870 --> 00:06:38,243
So there's legitimate vulnerable binaries.

142
00:06:39,370 --> 00:06:42,740
So this threat actor brings
also LOLBins and VULNBins

143
00:06:42,740 --> 00:06:45,130
to the target system, and then misuses

144
00:06:45,130 --> 00:06:49,270
or exploits both of these,
to load the malicious code

145
00:06:49,270 --> 00:06:51,930
which is encrypted in the registry.

146
00:06:51,930 --> 00:06:54,900
So let's look at how these
VULNBins are incorporated

147
00:06:54,900 --> 00:06:57,219
in these long execution chains.

148
00:06:57,220 --> 00:06:59,053
And let's look at two examples.

149
00:07:00,570 --> 00:07:03,380
Starting with this simple execution chain,

150
00:07:03,380 --> 00:07:06,780
just to give you an idea
about the role of the VULNBin.

151
00:07:06,780 --> 00:07:10,270
So this chain is used for
the cases where the attackers

152
00:07:10,270 --> 00:07:12,469
were not able to get admin privileges

153
00:07:12,470 --> 00:07:14,163
on the compromised machine.

154
00:07:15,210 --> 00:07:16,710
And at the center of the stage,

155
00:07:16,710 --> 00:07:19,489
is a piece of vulnerable
video player software

156
00:07:19,490 --> 00:07:21,800
which the attackers bring
to the target system

157
00:07:21,800 --> 00:07:23,650
along with some other libraries

158
00:07:23,650 --> 00:07:25,919
that it needs for execution.

159
00:07:25,920 --> 00:07:29,563
This is then scheduled to
run on every system startup.

160
00:07:30,510 --> 00:07:34,530
Now the software is outdated
and it's no longer maintained.

161
00:07:34,530 --> 00:07:36,510
And it has a bag of a full vulnerability

162
00:07:36,510 --> 00:07:39,810
which can be triggered by
a rogue configuration file.

163
00:07:39,810 --> 00:07:42,480
So this is what InvisiMole uses.

164
00:07:42,480 --> 00:07:44,760
So when this vulnerability is triggered

165
00:07:44,760 --> 00:07:48,099
this exploit used by InvisiMole
looks at the next stage

166
00:07:48,100 --> 00:07:50,283
in the chain with the malicious code.

167
00:07:51,670 --> 00:07:54,520
So to recap the role of
this vulnerable video player

168
00:07:54,520 --> 00:07:57,500
in the chain, is the role of the VULNBin.

169
00:07:57,500 --> 00:07:59,810
So similar to LOLBins that we know

170
00:07:59,810 --> 00:08:03,130
from the many cases before,
but there is a difference

171
00:08:03,130 --> 00:08:05,400
and this is the next step in the evolution

172
00:08:05,400 --> 00:08:07,510
that we are talking about.

173
00:08:07,510 --> 00:08:09,890
So instead of misusing some functionality

174
00:08:09,890 --> 00:08:11,510
of a legitimate tool,

175
00:08:11,510 --> 00:08:14,254
the attackers now exploit some software

176
00:08:14,254 --> 00:08:16,690
to get any functionality they want.

177
00:08:16,690 --> 00:08:18,010
So not just the functionality

178
00:08:18,010 --> 00:08:20,633
which is already provided by the tool.

179
00:08:21,920 --> 00:08:23,920
So to summarize this whole chain

180
00:08:23,920 --> 00:08:27,750
the technique is to just
use legitimate files

181
00:08:27,750 --> 00:08:30,993
and all the malicious code
is encrypted in the registry.

182
00:08:31,850 --> 00:08:33,890
As you can see the only part of this chain

183
00:08:33,890 --> 00:08:36,569
which is not legitimate and not encrypted

184
00:08:36,570 --> 00:08:40,463
is this small file with the
configuration, with the exploit.

185
00:08:41,429 --> 00:08:45,109
So keep this simple mechanism
in mind, as we shift our focus

186
00:08:45,110 --> 00:08:48,670
to our main topic, which
is another execution chain.

187
00:08:48,670 --> 00:08:51,681
So this is the preferred
method of how InvisiMole

188
00:08:51,682 --> 00:08:55,370
(indistinct) persistence
on the target machine.

189
00:08:55,370 --> 00:08:59,070
So this method is used
on newest OS versions

190
00:08:59,070 --> 00:09:00,570
for the cases where the attackers

191
00:09:00,570 --> 00:09:03,550
were able to get admin privileges.

192
00:09:03,550 --> 00:09:05,790
And interestingly, even though this chain

193
00:09:05,790 --> 00:09:08,270
is used on the latest OS versions,

194
00:09:08,270 --> 00:09:12,273
this is where the Windows XP
exploit plays the main role.

195
00:09:13,470 --> 00:09:15,930
So let's dive into this chain, which again

196
00:09:15,930 --> 00:09:18,293
starts with the legitimate binary.

197
00:09:19,160 --> 00:09:21,645
So there's legitimate binary
is a Windows component

198
00:09:21,645 --> 00:09:22,478
with an undocumented feature.

199
00:09:22,478 --> 00:09:24,385
And the only reason why
InvisiMole uses this part

200
00:09:24,385 --> 00:09:27,900
of the chain is because it allows them

201
00:09:27,900 --> 00:09:30,793
to run this command line.

202
00:09:31,740 --> 00:09:35,890
Now what gets executed wdigest.dll,

203
00:09:35,890 --> 00:09:38,800
which is again a legitimate
Windows component.

204
00:09:38,800 --> 00:09:41,473
This time, a Windows XP library.

205
00:09:42,410 --> 00:09:45,199
So of course, to successfully
load this library

206
00:09:45,200 --> 00:09:47,754
the attackers also bring
a Windows XP version

207
00:09:47,754 --> 00:09:52,743
of Rundll32.exe so that this
chain works successfully.

208
00:09:53,850 --> 00:09:56,290
Now what's interesting about this library

209
00:09:56,290 --> 00:09:57,680
is that you should know that it has

210
00:09:57,680 --> 00:10:00,140
an input validation vulnerability

211
00:10:00,140 --> 00:10:03,170
which allows the attackers
to load shell code

212
00:10:03,170 --> 00:10:05,949
as a parameter in the command line.

213
00:10:05,950 --> 00:10:08,680
So when the library is
loaded with these parameters,

214
00:10:08,680 --> 00:10:11,069
with this shell code in the command line,

215
00:10:11,070 --> 00:10:13,767
the shell code ends up rewriting
one of the global variables

216
00:10:13,767 --> 00:10:15,053
called LsaFunctions.

217
00:10:17,020 --> 00:10:20,030
Now the same variable is
used later in the code

218
00:10:20,030 --> 00:10:21,900
to calculate an address.

219
00:10:21,900 --> 00:10:25,340
So in this way InvisiMole can
determine what kind of address

220
00:10:25,340 --> 00:10:30,030
what kind of code will be loaded
and called by the library.

221
00:10:30,030 --> 00:10:33,530
Because of course this address
is taken from the shell code.

222
00:10:33,530 --> 00:10:34,877
And now as see we can
see, the address ends

223
00:10:34,878 --> 00:10:38,890
up pointing back to
the vulnerable library.

224
00:10:38,890 --> 00:10:41,122
As we can see the addresses are the same.

225
00:10:42,410 --> 00:10:44,260
Now, how is this possible?

226
00:10:44,260 --> 00:10:46,806
Remember this is a Windows XP library

227
00:10:46,806 --> 00:10:49,882
which means that there
was no ASLR at the time,

228
00:10:49,882 --> 00:10:52,483
and that means that the
attackers know precisely

229
00:10:52,483 --> 00:10:55,290
at which addresses this
library will be loaded

230
00:10:55,290 --> 00:10:57,380
at the time of execution.

231
00:10:57,380 --> 00:10:58,730
So it means that in the shell code

232
00:10:58,730 --> 00:11:02,070
they can directly reference
addresses from the library.

233
00:11:02,070 --> 00:11:04,380
In this case, a jump instruction

234
00:11:04,380 --> 00:11:07,600
which passes the control
back to the shell code.

235
00:11:07,600 --> 00:11:09,862
And then the shell code
loads another stage,

236
00:11:09,862 --> 00:11:11,723
shell code loader again.

237
00:11:12,870 --> 00:11:15,460
So at this point, this next stage

238
00:11:15,460 --> 00:11:17,220
could be any executable, right?

239
00:11:17,220 --> 00:11:21,930
Because the exploitation
phase is over at this point.

240
00:11:21,930 --> 00:11:24,250
But this is not what's happening here.

241
00:11:24,250 --> 00:11:27,200
What happens, is that
this shell code loader

242
00:11:27,200 --> 00:11:29,200
continues to use code gadgets

243
00:11:29,200 --> 00:11:31,790
from the vulnerable Windows XP library.

244
00:11:31,790 --> 00:11:34,640
So it continues to use
different pieces of code

245
00:11:34,640 --> 00:11:39,069
referring to them by the
addresses that they know already,

246
00:11:39,070 --> 00:11:40,670
instead of of implementing the code

247
00:11:40,670 --> 00:11:44,620
or the functionality directly
in the shellcode loader.

248
00:11:44,620 --> 00:11:47,212
They can also use directly
the inputs that are loaded

249
00:11:47,212 --> 00:11:50,840
by the vulnerable library,
because they will also know

250
00:11:50,840 --> 00:11:53,253
at which addresses these
inputs will be loaded.

251
00:11:54,360 --> 00:11:56,910
Now, why do the attackers do it this way?

252
00:11:56,910 --> 00:12:00,380
We know that code
gadgets are commonly used

253
00:12:00,380 --> 00:12:01,970
by exploit writers, right?

254
00:12:01,970 --> 00:12:03,943
When they want to get to some system.

255
00:12:04,830 --> 00:12:07,310
But this is not the
case because InvisiMole

256
00:12:07,310 --> 00:12:09,069
is already in the system.

257
00:12:09,070 --> 00:12:12,760
So they have a different
motivation behind this step.

258
00:12:12,760 --> 00:12:15,210
The reason why they use
so many code gadgets

259
00:12:15,210 --> 00:12:18,320
so why they reference
heavily this vulnerable

260
00:12:18,320 --> 00:12:21,460
legitimate library is
because they want to minimize

261
00:12:21,460 --> 00:12:23,200
their footprint on the system.

262
00:12:23,200 --> 00:12:25,580
So they want to bring
as little malicious code

263
00:12:25,580 --> 00:12:27,263
on the system as possible.

264
00:12:28,200 --> 00:12:30,130
When you look at the chain indeed,

265
00:12:30,130 --> 00:12:32,370
it's mostly legitimate files.

266
00:12:32,370 --> 00:12:36,690
And then there is this exploit
with little malicious code

267
00:12:36,690 --> 00:12:39,143
and the rest of the chain is encrypted.

268
00:12:40,100 --> 00:12:41,623
So this is their strategy.

269
00:12:42,600 --> 00:12:43,604
Now about the encryption.

270
00:12:43,604 --> 00:12:46,320
It's also interesting to point out

271
00:12:46,320 --> 00:12:48,600
that these attackers use mechanism called

272
00:12:48,600 --> 00:12:51,780
Data Protection API, or DPAPI,

273
00:12:51,780 --> 00:12:55,270
which is a standard
mechanism to protect cookies

274
00:12:55,270 --> 00:12:56,554
or logging passwords.

275
00:12:56,554 --> 00:13:00,170
And how it works, is that
when you encrypt your data

276
00:13:00,170 --> 00:13:02,253
with this CryptProtectData function

277
00:13:02,254 --> 00:13:05,320
you can only decrypt
it on the same computer

278
00:13:05,320 --> 00:13:06,917
when the encryption was done.

279
00:13:06,917 --> 00:13:08,995
Now, this is a standard
mechanism, but in the hands

280
00:13:08,995 --> 00:13:13,344
of the attackers, it gets very
useful because in this way,

281
00:13:13,344 --> 00:13:17,066
they're able to encrypt the
malicious payloads per victim.

282
00:13:17,066 --> 00:13:21,390
So even if AVS or
researchers get hold on these

283
00:13:21,390 --> 00:13:24,939
malicious components they
are not able to decrypt it

284
00:13:24,940 --> 00:13:27,330
without or having access to the computer

285
00:13:27,330 --> 00:13:28,573
where it was encrypted.

286
00:13:29,820 --> 00:13:31,615
Now, in our case we had this cooperation

287
00:13:31,615 --> 00:13:32,498
with the affected parties.

288
00:13:32,498 --> 00:13:34,708
So we were able to decrypt
all of these components

289
00:13:34,708 --> 00:13:38,515
and locate the computer
when they were encrypted.

290
00:13:38,515 --> 00:13:42,003
But it wouldn't be so easy
without that cooperation.

291
00:13:43,677 --> 00:13:47,514
So here you can see the
whole chain, the whole stages

292
00:13:47,514 --> 00:13:50,477
from the beginning until
the malicious payload.

293
00:13:50,477 --> 00:13:53,530
So again, let's take this
opportunity to look at the

294
00:13:53,530 --> 00:13:56,893
what kind of footprint these
attackers leave on the system.

295
00:13:57,760 --> 00:14:00,880
And again, we can see, they
use a lot of legitimate files

296
00:14:00,880 --> 00:14:04,700
and then the most of the
malicious code is encrypted

297
00:14:04,700 --> 00:14:08,253
in the registry, effectively fileless.

298
00:14:09,300 --> 00:14:11,959
Again, the only component,
which is not legitimate

299
00:14:11,960 --> 00:14:16,960
and not encrypted is this
small exploit in the registry.

300
00:14:16,960 --> 00:14:20,240
But as we know, this
exploit is mostly references

301
00:14:20,240 --> 00:14:23,410
to code gadgets from the
legitimate Windows XP library.

302
00:14:23,410 --> 00:14:26,372
So by itself, it's hard
to look like as malicious.

303
00:14:27,940 --> 00:14:30,960
And when we compare it to the
other persistent technique

304
00:14:30,960 --> 00:14:33,350
that we were looking at earlier,

305
00:14:33,350 --> 00:14:35,453
we can see a recurring pattern here.

306
00:14:37,000 --> 00:14:41,000
So seeing the role of the
vulnerable Windows XP library

307
00:14:41,000 --> 00:14:44,233
in this chain, that brings me
back to the original question.

308
00:14:45,370 --> 00:14:47,780
Do XP exploits still matter?

309
00:14:47,780 --> 00:14:49,490
Jean-Ian.

310
00:14:49,490 --> 00:14:52,430
- Thank you Zuzana, so before
answering this question,

311
00:14:52,430 --> 00:14:54,209
let's look at the facts.

312
00:14:54,210 --> 00:14:56,800
So most of the
vulnerabilities abused or used

313
00:14:56,800 --> 00:15:00,380
by threat actors are
either used to gain access

314
00:15:00,380 --> 00:15:02,970
to a network or to
elevate their privileges.

315
00:15:02,970 --> 00:15:04,970
So if we look at the first class

316
00:15:04,970 --> 00:15:07,050
there is Remote coding Execution or RCE,

317
00:15:07,050 --> 00:15:10,930
which are used by an
attacker to gain access

318
00:15:10,930 --> 00:15:14,489
and controlling an
unpatched remote system.

319
00:15:14,490 --> 00:15:17,450
Of course, this is of high
value for a threat actor

320
00:15:17,450 --> 00:15:20,220
because this is the
first step in the chain

321
00:15:20,220 --> 00:15:22,740
before getting successful campaign.

322
00:15:22,740 --> 00:15:25,340
Of course, Windows XP vulnerabilities

323
00:15:25,340 --> 00:15:27,770
cannot be used to get access to a network

324
00:15:27,770 --> 00:15:29,640
at least the vast majority of them.

325
00:15:29,640 --> 00:15:32,840
So do they matter when it
comes to aggregating remote

326
00:15:32,840 --> 00:15:34,870
access? No, they don't.

327
00:15:34,870 --> 00:15:36,540
The second class of vulnerabilities

328
00:15:36,540 --> 00:15:39,660
is Local Privilege Escalation or LPE,

329
00:15:39,660 --> 00:15:42,350
which allows an attacker
to access resources

330
00:15:42,350 --> 00:15:45,690
or perform operations
not normally permitted

331
00:15:45,690 --> 00:15:47,180
by normal users.

332
00:15:47,180 --> 00:15:49,380
So of course, attackers need this access

333
00:15:49,380 --> 00:15:52,520
because most of their campaigns
are meant to get access

334
00:15:52,520 --> 00:15:55,970
to sensitive information
or to run commands

335
00:15:55,970 --> 00:15:58,960
hard to get further in
a network, for example.

336
00:15:58,960 --> 00:16:02,570
So again, Windows XP era
vulnerabilities are generally

337
00:16:02,570 --> 00:16:05,860
not suitable to escalate
privilege on a modern system.

338
00:16:05,860 --> 00:16:07,830
So do they matter when it comes to

339
00:16:07,830 --> 00:16:10,920
adequately escalating
privileges? No, they don't.

340
00:16:10,920 --> 00:16:14,680
However, Windows XP exploit
can be used to obtain

341
00:16:14,680 --> 00:16:16,890
invisibility, as we've just seen.

342
00:16:16,890 --> 00:16:19,640
We are talking about
post-compromised phase.

343
00:16:19,640 --> 00:16:21,870
The attacker is already in the system.

344
00:16:21,870 --> 00:16:25,313
And in some cases already
as an elevated users.

345
00:16:26,490 --> 00:16:28,690
Through these uptakes, the vulnerabilities

346
00:16:28,690 --> 00:16:30,909
that zuzana just discussed,

347
00:16:30,909 --> 00:16:34,339
can have serious
consequences for defenders.

348
00:16:34,339 --> 00:16:36,720
Some of them are not
serious enough to get patch

349
00:16:36,720 --> 00:16:38,480
or they are too old to get patch

350
00:16:38,480 --> 00:16:41,748
meaning that this is one more
reason to watch out for them

351
00:16:41,748 --> 00:16:45,056
because discovering an attacker
actually leveraging VULNBins

352
00:16:45,056 --> 00:16:45,889
will be that much harder.

353
00:16:45,889 --> 00:16:50,480
And remember, these are all the binaries.

354
00:16:50,480 --> 00:16:53,470
Meaning that some of the
newest operating system

355
00:16:53,470 --> 00:16:56,280
defense mechanisms will not apply here.

356
00:16:56,280 --> 00:16:59,105
Think, for example, ASLR, meaning that

357
00:16:59,105 --> 00:17:04,077
a return-oriented programming
will be easier to leverage.

358
00:17:04,077 --> 00:17:06,977
Now, this technique is
not exclusively used

359
00:17:06,977 --> 00:17:08,339
by the InvisiMole group.

360
00:17:08,339 --> 00:17:12,819
Simbot analyzed by Gabor
Szappanos from Sophos in 2014

361
00:17:12,819 --> 00:17:14,810
was using a similar technique

362
00:17:14,810 --> 00:17:16,290
but this is a rare site.

363
00:17:16,290 --> 00:17:20,599
We found the two public cases
that in the past few years

364
00:17:20,599 --> 00:17:22,860
that we're seeing threat
actors leveraging VULNBins.

365
00:17:22,861 --> 00:17:27,260
However, as detection
mechanisms are not as mature

366
00:17:27,260 --> 00:17:30,330
as for LOLBins, we
believe this might be only

367
00:17:30,330 --> 00:17:32,419
a tip of the iceberg.

368
00:17:32,420 --> 00:17:34,230
So back to our original questions,

369
00:17:34,230 --> 00:17:36,730
do XP exploit still matter?

370
00:17:36,730 --> 00:17:39,190
So we've coined the term VULNBins,

371
00:17:39,190 --> 00:17:42,610
which is attackers bringing
vulnerable binaries

372
00:17:42,610 --> 00:17:44,159
to a system under control.

373
00:17:44,160 --> 00:17:47,840
So we believe that these
are different than LOLBins.

374
00:17:47,840 --> 00:17:50,970
So you might wonder why
exactly We are saying this.

375
00:17:50,970 --> 00:17:54,220
Well, from attackers perspective,
they are very different.

376
00:17:54,220 --> 00:17:55,990
So from an external point of view

377
00:17:55,990 --> 00:17:58,823
they will be the same type
of legitimate applications

378
00:17:58,823 --> 00:18:01,940
that an attacker can bring to a system

379
00:18:01,940 --> 00:18:04,140
but the attacker can actually use them.

380
00:18:04,140 --> 00:18:06,220
They will pick them and be able to run

381
00:18:06,220 --> 00:18:08,070
any type of code through them.

382
00:18:08,070 --> 00:18:11,050
So they are more powerful
than the VULNBins

383
00:18:11,050 --> 00:18:13,644
and should then be treated differently.

384
00:18:13,644 --> 00:18:15,830
Now you might wonder whether defenders

385
00:18:15,830 --> 00:18:17,770
should treat them differently

386
00:18:17,770 --> 00:18:20,020
and we believe that they should.

387
00:18:20,020 --> 00:18:22,165
And this is why we are
bringing up this new concept.

388
00:18:22,165 --> 00:18:25,360
There is close to no
guidance as how defenders

389
00:18:25,360 --> 00:18:27,090
should deal with VULNBins.

390
00:18:27,090 --> 00:18:29,568
Whereas for a LOLBin,
there's a lot of resources

391
00:18:29,568 --> 00:18:31,651
that can help them mitigate

392
00:18:31,651 --> 00:18:33,800
and protect their network against them.

393
00:18:33,800 --> 00:18:37,800
And a good example is let's
say for EDR rules would exist

394
00:18:37,800 --> 00:18:40,649
for specific LOLBins,
but of course VULNBins

395
00:18:40,650 --> 00:18:44,560
are not likely to be
covered by any rules by EDR.

396
00:18:44,560 --> 00:18:47,206
Also another point to
consider is that VULNBins

397
00:18:47,207 --> 00:18:49,790
are far stealthier than LOLBins.

398
00:18:49,790 --> 00:18:53,320
LOLBins as I said,
there's a lot of resources

399
00:18:53,320 --> 00:18:55,919
which will explain how
attackers can leverage them.

400
00:18:55,920 --> 00:18:58,240
And you can go through
your logs or use tools to

401
00:18:58,240 --> 00:19:01,510
find artifacts of an attacker
using them in your network.

402
00:19:01,510 --> 00:19:03,760
Such as, for example,
command line arguments.

403
00:19:03,760 --> 00:19:05,000
But there is no such thing for VULNBins

404
00:19:05,000 --> 00:19:09,498
because there are far more stealthier.

405
00:19:09,498 --> 00:19:13,150
Let's go back to the example
that Zuzana explained

406
00:19:13,150 --> 00:19:16,970
where a malicious
configuration file with all

407
00:19:16,970 --> 00:19:19,980
that was needed to abuse
(indistinct) modification.

408
00:19:19,980 --> 00:19:22,130
So good luck looking for traces

409
00:19:22,130 --> 00:19:24,617
of this behavior in your network.

410
00:19:24,617 --> 00:19:28,170
And so this is why we believe
that VULNBins and LOLBins

411
00:19:28,170 --> 00:19:32,203
are definitely different and
should be treated differently.

412
00:19:32,203 --> 00:19:36,280
Now back to our question,
does XP exploit still matter?

413
00:19:36,280 --> 00:19:38,740
So you might be wondering
are VULNBins only applicable

414
00:19:38,740 --> 00:19:41,513
to old binaries? Of course
not an attacker could bring

415
00:19:41,513 --> 00:19:46,040
a newer application and then
achieve the same results.

416
00:19:46,040 --> 00:19:50,028
However, Windows XP, or even
previous Windows binaries

417
00:19:50,028 --> 00:19:53,430
have a significant advantage for attackers

418
00:19:53,430 --> 00:19:55,252
because there are legitimate applications

419
00:19:55,252 --> 00:19:58,480
that are likely to be on white listing

420
00:19:58,480 --> 00:20:00,240
of some security solutions.

421
00:20:00,240 --> 00:20:03,050
Moreover, some of them
might even be signed

422
00:20:03,050 --> 00:20:05,780
adding a layer of legitimacy to two.

423
00:20:05,780 --> 00:20:08,570
How many security solutions out
there will treat differently

424
00:20:08,570 --> 00:20:12,899
an old signed binaries from
Microsoft versus a newer one,

425
00:20:12,900 --> 00:20:14,540
probably not a lot of them.

426
00:20:14,540 --> 00:20:17,505
So for all these reasons,
this is why we believe

427
00:20:17,506 --> 00:20:20,523
that XP exploit still matter, Zuzana.

428
00:20:22,540 --> 00:20:26,620
- Alright, so we answered
why XP exploits still matter.

429
00:20:26,620 --> 00:20:29,010
And also how this technique evolved

430
00:20:29,010 --> 00:20:32,470
from the traditional living
of the land technique.

431
00:20:32,470 --> 00:20:36,030
Now what's left, is perhaps
the most important question.

432
00:20:36,030 --> 00:20:38,120
What can we do about this?

433
00:20:38,120 --> 00:20:40,489
So in this last part of our session

434
00:20:40,490 --> 00:20:42,390
we will walk you through some ideas

435
00:20:42,390 --> 00:20:46,915
on how we can fortify our
defenses against this threat.

436
00:20:46,915 --> 00:20:49,693
So starting with this InvisiMole case,

437
00:20:51,119 --> 00:20:53,030
that we have covered earlier
in the session, you should know

438
00:20:53,030 --> 00:20:55,500
that we didn't really
start our investigation

439
00:20:55,500 --> 00:20:57,253
with VULNBins in mind.

440
00:20:58,190 --> 00:21:00,570
The reason we uncovered
this campaign was that

441
00:21:00,570 --> 00:21:02,970
we were already monitoring
this threat actor

442
00:21:02,970 --> 00:21:05,460
based on our previous work.

443
00:21:05,460 --> 00:21:07,500
So we already knew where to look

444
00:21:07,500 --> 00:21:10,500
and also how to identify
InvisiMole samples

445
00:21:10,500 --> 00:21:13,250
among other malicious detections.

446
00:21:13,250 --> 00:21:16,650
So for example, these two
four-byte magic values

447
00:21:16,650 --> 00:21:19,340
which InvisiMole uses as the magic header

448
00:21:19,340 --> 00:21:22,769
in their characteristic
blocks, and also uses them

449
00:21:22,769 --> 00:21:26,313
as an integrity check in
their InvisiMole loaders.

450
00:21:27,310 --> 00:21:29,429
So we first discovered
this campaign thanks

451
00:21:29,430 --> 00:21:30,339
to our in-memory detection.

452
00:21:30,339 --> 00:21:33,760
And from there, we were
able to look further

453
00:21:33,760 --> 00:21:37,060
in the file system, in
memory, in the registry

454
00:21:37,060 --> 00:21:39,205
for other InvisiMole components.

455
00:21:39,205 --> 00:21:41,725
And remember, we also had this cooperation

456
00:21:41,725 --> 00:21:43,679
with the affected parties.

457
00:21:43,680 --> 00:21:47,180
So we were able to decrypt all
of those malicious components

458
00:21:47,180 --> 00:21:50,583
which were encrypted for
a victim with the DPAPI.

459
00:21:51,440 --> 00:21:52,407
So based on that research,

460
00:21:52,407 --> 00:21:55,647
we were able to reconstruct
the full persistence chains

461
00:21:55,647 --> 00:21:57,437
and also the lateral movement

462
00:21:57,438 --> 00:22:00,463
or the delivery strategies and so on.

463
00:22:01,840 --> 00:22:03,466
So we put together a couple
of Yara and Sigma rules

464
00:22:03,466 --> 00:22:04,299
based on this research.

465
00:22:04,299 --> 00:22:07,730
And we are sharing them with the community

466
00:22:07,730 --> 00:22:10,610
so that you can check
whether you're compromised.

467
00:22:10,610 --> 00:22:12,850
You can also leverage the ILCs or the

468
00:22:12,850 --> 00:22:16,879
my traffic technique
mapping for prioritization

469
00:22:16,880 --> 00:22:19,993
or read the full white
paper for detailed analysis.

470
00:22:21,000 --> 00:22:24,200
But remember, this particular
case was only uncovered

471
00:22:24,200 --> 00:22:26,190
because we're already looking there

472
00:22:26,190 --> 00:22:28,342
were already handling product threat actor

473
00:22:28,342 --> 00:22:30,303
and also we have this cooperation.

474
00:22:31,600 --> 00:22:34,620
So of course detecting InvisiMole

475
00:22:34,620 --> 00:22:36,189
will only get you that far.

476
00:22:36,190 --> 00:22:38,720
And that's why Jean and I
will now walk you through

477
00:22:38,720 --> 00:22:41,163
some more general detection strategies.

478
00:22:42,860 --> 00:22:44,030
- Alright, thank you Zuzana.

479
00:22:44,030 --> 00:22:46,560
So, yes, when it comes to
general detection strategies

480
00:22:46,560 --> 00:22:48,087
that tie to InvisiMole,

481
00:22:48,087 --> 00:22:50,870
we must look at how VULNBins are used

482
00:22:50,870 --> 00:22:52,939
and how they are abused for (indistinct).

483
00:22:52,940 --> 00:22:55,550
So for security researchers, we believe

484
00:22:55,550 --> 00:22:58,740
that the same mechanisms
that are applied to LOLBins

485
00:22:58,740 --> 00:23:00,930
could be applied as well for VULNBins.

486
00:23:00,930 --> 00:23:02,030
So if you look on the internet,

487
00:23:02,030 --> 00:23:03,820
you will see a lot of resources

488
00:23:03,820 --> 00:23:06,020
that are listing all the possible LOLBins

489
00:23:06,020 --> 00:23:07,970
and how attackers can abuse them.

490
00:23:07,970 --> 00:23:11,590
A good example of this is a
LOLBAS Project that you see here

491
00:23:11,590 --> 00:23:14,820
where they are trying to list
all known LOLBins out there

492
00:23:14,820 --> 00:23:16,530
and how they can be abused by attackers.

493
00:23:16,530 --> 00:23:18,758
So we propose to build such a list

494
00:23:18,758 --> 00:23:21,570
as well with known cases of VULNBins.

495
00:23:21,570 --> 00:23:24,010
Of course, we cannot
build an extensive list

496
00:23:24,010 --> 00:23:27,160
of all vulnerable applications,
because this would be

497
00:23:27,160 --> 00:23:31,710
a task that would be way too
hard, way too exhaustive.

498
00:23:31,710 --> 00:23:34,453
So what we are trying to
achieve is to find VULNBins

499
00:23:34,453 --> 00:23:37,280
that are known to be abused by attackers

500
00:23:37,280 --> 00:23:40,540
and also focus on older Windows binaries

501
00:23:40,540 --> 00:23:44,040
especially sign one that
could be abused by an attacker

502
00:23:44,040 --> 00:23:47,560
to get more stuff in a system.

503
00:23:47,560 --> 00:23:50,300
Now, this is a call for action
for all security researchers

504
00:23:50,300 --> 00:23:51,592
that are watching this.

505
00:23:52,914 --> 00:23:54,850
If you know of cases
that VULNBins were used

506
00:23:54,850 --> 00:23:57,469
in the campaign we will
be very happy to hear it.

507
00:23:57,470 --> 00:24:00,070
Because as you know, there's
only a few public cases

508
00:24:00,070 --> 00:24:03,919
and that is documented,
and using your input,

509
00:24:03,920 --> 00:24:05,453
we could start such a list.

510
00:24:06,400 --> 00:24:08,630
Now, even if this space existed

511
00:24:08,630 --> 00:24:10,610
and that defenders could use them

512
00:24:10,610 --> 00:24:13,533
to try to protect their
networks, they will still try,

513
00:24:13,533 --> 00:24:15,952
they will still have to come up with ways

514
00:24:15,952 --> 00:24:19,197
to mitigate this threat
because usually VULNBins

515
00:24:19,197 --> 00:24:22,530
cannot be blocked by
antivirus or security solution

516
00:24:22,530 --> 00:24:25,930
as they can be used for
legitimate purposes.

517
00:24:25,930 --> 00:24:29,921
So one way to achieve that
would be to block these VULNBins

518
00:24:29,921 --> 00:24:33,080
either by applying Windows Defender

519
00:24:33,080 --> 00:24:35,156
Application Control POlicy or WDAC

520
00:24:35,156 --> 00:24:37,010
or AppLocker to block the
execution of these files.

521
00:24:37,010 --> 00:24:42,010
Now, if you wonder what
WDAC rules might look like

522
00:24:42,522 --> 00:24:45,530
Microsoft has it's
recommended block rules.

523
00:24:45,530 --> 00:24:47,680
And if you look at how they are built

524
00:24:47,680 --> 00:24:49,771
you will basically specify the application

525
00:24:49,771 --> 00:24:51,135
that you want to block,

526
00:24:51,135 --> 00:24:54,410
and you specify a minimum file version.

527
00:24:54,410 --> 00:24:55,243
Up there, you can specify
the maximum value,

528
00:24:55,243 --> 00:24:58,675
meaning that all the
version of this application

529
00:24:58,675 --> 00:25:01,733
will be blocked from
running from your network.

530
00:25:01,733 --> 00:25:04,669
But you can also specify
the minimum version

531
00:25:04,670 --> 00:25:05,503
of the application.

532
00:25:05,503 --> 00:25:07,383
And then you could pick the first version

533
00:25:07,383 --> 00:25:08,216
for which development it was patched,

534
00:25:08,216 --> 00:25:11,274
meaning that our previous
version that are susceptible

535
00:25:11,275 --> 00:25:15,060
to be exploited by attacker
would be actually forbidden by

536
00:25:15,060 --> 00:25:17,678
from running in your network.

537
00:25:17,679 --> 00:25:21,050
Now, if a known VULNBin cannot be blocked

538
00:25:21,050 --> 00:25:25,110
for business reasons, you must monitor it.

539
00:25:25,110 --> 00:25:27,530
So you must monitor process behavior

540
00:25:27,530 --> 00:25:29,800
to detect suspicious
activities or anomalies

541
00:25:29,800 --> 00:25:32,676
such as network activity
coming from a video player.

542
00:25:32,676 --> 00:25:35,110
Also it can flag binary
executed from uncommon

543
00:25:35,111 --> 00:25:36,332
or auto start locations.

544
00:25:36,332 --> 00:25:38,222
Of course it's much easier to achieve

545
00:25:38,222 --> 00:25:39,055
if you have an EDR solution in place,

546
00:25:39,055 --> 00:25:44,055
which brings us to our next topic, Zuzana

547
00:25:46,120 --> 00:25:47,600
- Thank you, Jean-Ian.

548
00:25:47,600 --> 00:25:49,196
So indeed let's finish
with a couple of ideas

549
00:25:49,196 --> 00:25:54,196
of how we could detect this
technique using EDR products.

550
00:25:54,760 --> 00:25:56,740
So generally it's always a good idea

551
00:25:56,740 --> 00:25:58,840
to flag unpopular applications.

552
00:25:58,840 --> 00:26:00,740
In our case, it would be that outdated

553
00:26:00,740 --> 00:26:02,876
video player software, but in general,

554
00:26:02,876 --> 00:26:05,770
it's because we want to
narrow down the candidates

555
00:26:05,770 --> 00:26:08,520
for possible vulnerable applications

556
00:26:08,520 --> 00:26:11,628
they're often old,
outdated or just misplaced.

557
00:26:11,628 --> 00:26:16,082
To be able to identify possible
VULNBins in our systems.

558
00:26:16,970 --> 00:26:19,347
So another idea would be
to flag Windows binaries

559
00:26:19,347 --> 00:26:23,340
which are executed from outside
of their original locations

560
00:26:23,340 --> 00:26:25,264
that could suggest an older Windows binary

561
00:26:25,264 --> 00:26:27,110
or a vulnerable one brought to the system

562
00:26:27,111 --> 00:26:30,730
maybe to some user folder and then misused

563
00:26:30,730 --> 00:26:32,570
by the attackers.

564
00:26:32,570 --> 00:26:34,620
But maybe more interesting way

565
00:26:34,620 --> 00:26:37,000
how we could identify potential VULNBins,

566
00:26:37,000 --> 00:26:40,150
would be to focus on digital signatures.

567
00:26:40,150 --> 00:26:45,010
More concretely to flag
unsigned Windows binaries.

568
00:26:45,010 --> 00:26:48,800
And now what do I mean by these
unsigned Windows binaries?

569
00:26:48,800 --> 00:26:52,230
Well, we know that Windows
binaries are commonly signed

570
00:26:52,230 --> 00:26:54,120
with embedded digital signatures,

571
00:26:54,120 --> 00:26:55,929
but that's not always the case.

572
00:26:55,930 --> 00:26:58,100
Other ones are assigned by catalog files

573
00:26:58,100 --> 00:27:00,929
which sign multiple files at once.

574
00:27:00,930 --> 00:27:03,670
And now what happens when
you take a Windows binary

575
00:27:03,670 --> 00:27:05,520
which is signed by a catalog file

576
00:27:05,520 --> 00:27:08,850
and bring it to another
Windows OS version?

577
00:27:08,850 --> 00:27:10,417
Well, if the catalog file is not presented

578
00:27:10,417 --> 00:27:15,417
probably there is a newer
version of the same binary

579
00:27:15,510 --> 00:27:18,100
which will have a catalog
file with the signature.

580
00:27:18,100 --> 00:27:22,490
Now the old binary, the old
version will appear as usigned.

581
00:27:22,490 --> 00:27:24,000
Here, you can see an example.

582
00:27:24,000 --> 00:27:27,600
We took the library which
InvisiMole uses for stealth

583
00:27:27,600 --> 00:27:30,699
so that vulnerable Windows XP library.

584
00:27:30,700 --> 00:27:34,110
And we ran sigcheck on
two Windows OS versions.

585
00:27:34,110 --> 00:27:38,379
As you can see on Windows XP,
this library appears signed

586
00:27:38,380 --> 00:27:42,270
whereas on Windows 10,
it appears as unsigned.

587
00:27:42,270 --> 00:27:45,940
And now this is a legitimate
behavior. This is expected.

588
00:27:45,940 --> 00:27:49,330
But what we are trying to
say is that we can leverage

589
00:27:49,330 --> 00:27:51,242
this behavior for detection purposes.

590
00:27:51,242 --> 00:27:54,020
So we could try to flag these instances

591
00:27:54,020 --> 00:27:57,960
of unsigned Windows
binaries for inspections

592
00:27:57,960 --> 00:28:01,000
if this was legitimate and
if this Windows component

593
00:28:01,000 --> 00:28:03,163
was supposed to be in your environment.

594
00:28:04,490 --> 00:28:05,810
But also there are other ways

595
00:28:05,810 --> 00:28:08,048
how we could flag older Windows binaries

596
00:28:08,048 --> 00:28:11,950
brought to newer system, for
example by flagging instances

597
00:28:11,950 --> 00:28:14,450
where the binary version doesn't match

598
00:28:14,450 --> 00:28:15,993
the Windows OS version.

599
00:28:16,950 --> 00:28:21,160
And of course, we could also
try to apply same heuristics

600
00:28:21,160 --> 00:28:24,350
for third party applications,
because as Jean-Ian said,

601
00:28:24,350 --> 00:28:28,221
VULNBins are not reserved
to Windows applications.

602
00:28:28,221 --> 00:28:31,305
So for example, we could
again parse version input

603
00:28:31,305 --> 00:28:35,560
to check if your installed
application is up-to-date,

604
00:28:35,560 --> 00:28:37,379
or maybe try to find other heuristics

605
00:28:37,380 --> 00:28:40,690
such as parsing the compilation time step

606
00:28:40,690 --> 00:28:42,135
and deciding on a threshold.

607
00:28:42,135 --> 00:28:45,670
For example, all the
binaries which were compiled

608
00:28:45,670 --> 00:28:49,240
more than 10 years ago
need further inspection.

609
00:28:49,240 --> 00:28:52,290
Are for those widely used applications,

610
00:28:52,290 --> 00:28:54,090
the widely popular software.

611
00:28:54,090 --> 00:28:54,923
There is usually a public API where

612
00:28:54,923 --> 00:28:59,230
you can check the latest
available version.

613
00:28:59,230 --> 00:29:02,340
And then, we could try
to compare this version

614
00:29:02,340 --> 00:29:03,416
with the one actually installed.

615
00:29:03,416 --> 00:29:07,700
And again, maybe decide on
a threshold to figure out

616
00:29:07,700 --> 00:29:11,600
what kind of old application
or what kind of old update

617
00:29:11,600 --> 00:29:14,265
is applicable in our environment.

618
00:29:14,266 --> 00:29:16,999
Now, of course, none of
these flags would suggest

619
00:29:16,999 --> 00:29:18,409
a successful compromise.

620
00:29:18,409 --> 00:29:22,500
What we are trying to do is
to narrow down candidates

621
00:29:22,500 --> 00:29:27,123
to possibly identify VULNBins
used by attackers for stealth.

622
00:29:28,480 --> 00:29:30,490
And that brings me to
the end of this session

623
00:29:30,490 --> 00:29:35,000
so let me summarize it by
saying the main takeaways

624
00:29:35,000 --> 00:29:36,253
that we covered today.

625
00:29:37,320 --> 00:29:41,062
So, first of all, we know
the XP exploits still matter,

626
00:29:41,900 --> 00:29:46,572
even today, not only
on Windows XP machines.

627
00:29:46,572 --> 00:29:50,810
Now threat actors can
use them and do use them

628
00:29:50,810 --> 00:29:54,333
along with other vulnerable
binaries for invisibility

629
00:29:54,334 --> 00:29:58,183
and for resilience against
our detection mechanisms.

630
00:29:59,300 --> 00:30:00,840
Now, of course this technique

631
00:30:00,840 --> 00:30:02,800
is not in everyone's threat model.

632
00:30:02,800 --> 00:30:04,770
Of course, the threat
actors will not bother

633
00:30:04,770 --> 00:30:05,830
going to these lengths

634
00:30:05,830 --> 00:30:08,043
unless they really want to be invisible.

635
00:30:09,050 --> 00:30:12,100
But if you are operating
in a secure environment,

636
00:30:12,100 --> 00:30:14,193
then you should consider this technique.

637
00:30:15,650 --> 00:30:18,146
So we provided a couple
of ideas and guidance

638
00:30:18,146 --> 00:30:21,197
on how we can improve
our detection mechanisms

639
00:30:21,198 --> 00:30:23,910
to catch these VULNBins.

640
00:30:23,910 --> 00:30:26,000
But of course, this is just the beginning.

641
00:30:26,000 --> 00:30:29,100
So we hope to be able to
work with the community

642
00:30:29,100 --> 00:30:30,780
to come up with other ideas,

643
00:30:30,780 --> 00:30:33,562
how to build our resilience
against this technique.

644
00:30:34,428 --> 00:30:36,790
And that brings me to the end.

645
00:30:36,790 --> 00:30:38,629
So thank you for your attention.

646
00:30:38,630 --> 00:30:40,530
We will be happy to take your questions

647
00:30:40,530 --> 00:30:42,663
or further discuss this topic.

648
00:30:43,751 --> 00:30:47,360
You can also contact us or
our colleague Anton Cherepanov

649
00:30:47,360 --> 00:30:50,909
who led the InvisiMole
investigation in our lab.

650
00:30:50,910 --> 00:30:51,743
Thank you.

