1
00:00:07,300 --> 00:00:08,790
- Hello, my name is Lars Schlieper

2
00:00:08,790 --> 00:00:13,020
and I'm a PhD student from
Ruhr-University Bochum,

3
00:00:13,020 --> 00:00:16,059
and I will talk about the ideas behind

4
00:00:16,059 --> 00:00:18,910
the Noisy Simon Period Finding.

5
00:00:18,910 --> 00:00:21,210
First of all, period
finding are not only used

6
00:00:21,210 --> 00:00:25,010
to factorize and break
the discrete log problem,

7
00:00:25,010 --> 00:00:28,500
but can also be used to
attack many symmetric ciphers

8
00:00:28,500 --> 00:00:32,490
like the provably secure
Even-Mansour cipher,

9
00:00:32,490 --> 00:00:36,520
which can be broken with
quantum access in roughly

10
00:00:36,520 --> 00:00:37,643
polynomial time.

11
00:00:38,746 --> 00:00:41,400
Our goal was it to implement
Simon's period finding

12
00:00:41,400 --> 00:00:45,183
algorithm on the quantum
device to study this behavior.

13
00:00:46,080 --> 00:00:48,839
Since today, quantum
computers are not noiseless.

14
00:00:48,840 --> 00:00:52,530
We expect some errors in some measurements

15
00:00:52,530 --> 00:00:54,200
and we were interested in the question

16
00:00:54,200 --> 00:00:56,520
how is this errors looks like if you can

17
00:00:56,520 --> 00:00:59,550
despite this errors still
computes the hidden period out

18
00:00:59,550 --> 00:01:02,650
of the measurements and whether
we can even gain advantage

19
00:01:02,650 --> 00:01:04,349
from this noisy quantum computers.

20
00:01:06,290 --> 00:01:09,640
Simon's algorithms can solve
the problem to compute a hidden

21
00:01:09,640 --> 00:01:11,600
period s given the quantum access

22
00:01:11,600 --> 00:01:15,059
to a periodic function,
two to one function

23
00:01:15,060 --> 00:01:19,830
with f of x is equal to
f of x plus s for all x.

24
00:01:19,830 --> 00:01:21,870
This problem is critical hard to solve

25
00:01:21,870 --> 00:01:25,303
and required at least two to
the power of n half steps.

26
00:01:26,300 --> 00:01:29,179
On the other hand, with
quantum access to the function

27
00:01:29,180 --> 00:01:31,690
the problem can be solved with noisy

28
00:01:31,690 --> 00:01:34,963
and this noiseless quantum
computers in polynomial time.

29
00:01:36,440 --> 00:01:38,709
This is done by assembling
organized Vectors s

30
00:01:38,709 --> 00:01:43,493
using quantum circuits, and
then determining s via Gauss.

31
00:01:44,370 --> 00:01:46,310
On the right side, we can see such

32
00:01:46,310 --> 00:01:49,820
a sample or measurement
probability distribution

33
00:01:49,820 --> 00:01:54,210
for a function with period
zero one zero zero zero one one

34
00:01:55,310 --> 00:01:56,910
on a noiseless quantum computer.

35
00:01:57,780 --> 00:02:01,220
The vectors are ordered lexicographically

36
00:02:01,220 --> 00:02:03,170
and probability is uniform distributed

37
00:02:03,170 --> 00:02:05,383
over all orthogonal vectors.

38
00:02:06,320 --> 00:02:09,120
Moreover, the probability
of any non-orthogonal vector

39
00:02:09,120 --> 00:02:11,020
is zero and didn't appear in this plot

40
00:02:12,150 --> 00:02:15,520
but this is not to expect
for real quantum computers

41
00:02:15,520 --> 00:02:20,520
at the moment. For our
experiments, we used IBM-Q16.

42
00:02:21,350 --> 00:02:26,010
This is a public accessible
quantum computer with 15 qubits.

43
00:02:26,010 --> 00:02:28,980
Due to the limited
capabilities of the IBM-Q16,

44
00:02:28,980 --> 00:02:32,066
we were only able to implement
the circuit up to a dimension

45
00:02:32,066 --> 00:02:35,863
of seven without any
additional error correction.

46
00:02:37,050 --> 00:02:39,820
Some of the measurement frequencies

47
00:02:39,820 --> 00:02:41,722
can be seen on the right.

48
00:02:41,723 --> 00:02:45,930
As expected, we see all the
error relative measurements

49
00:02:45,930 --> 00:02:48,360
of vectors that are
non-orthogonal vectors.

50
00:02:48,360 --> 00:02:50,210
They are indicated with the red bars.

51
00:02:51,560 --> 00:02:55,830
Tau gives the total percentage
of any a bad measurements

52
00:02:55,830 --> 00:02:58,356
or measurements of non-orthogonal vectors.

53
00:02:58,356 --> 00:03:02,603
You can see that tau
increased with the dimension.

54
00:03:06,380 --> 00:03:09,380
On the good side however, we see that tau

55
00:03:09,380 --> 00:03:11,430
for our experiments are quite small

56
00:03:11,430 --> 00:03:14,350
and these natural orthogonal
vectors much more often than

57
00:03:14,350 --> 00:03:16,320
non orthogonal vectors.

58
00:03:16,320 --> 00:03:19,739
However, on the bad side, we
see additional bad behavior.

59
00:03:19,740 --> 00:03:23,340
Bad side of the evidence,
vectors that are non orthogonal

60
00:03:23,340 --> 00:03:26,180
to s. We get all biased towards

61
00:03:26,180 --> 00:03:29,094
zero so that vectors
with lower Hamming weight

62
00:03:29,094 --> 00:03:33,290
more frequently than Vectors
with high Hamming weight

63
00:03:33,290 --> 00:03:37,209
and see some different
qubit qualities that can be

64
00:03:37,210 --> 00:03:40,160
here seen, for example,
for the vector that starts

65
00:03:40,160 --> 00:03:43,740
with zero one and the vector
that starts with one zero,

66
00:03:43,740 --> 00:03:46,320
both have the same Hamming
weight, but the vector is zero

67
00:03:46,320 --> 00:03:50,120
one has only a probability of 0.05

68
00:03:51,303 --> 00:03:54,780
and the vector of s starting with one zero

69
00:03:54,780 --> 00:03:57,523
has a probability of 0.07.

70
00:03:59,287 --> 00:04:00,780
There was a question I raised

71
00:04:00,780 --> 00:04:05,483
can we mitigate this
additional bad behavior?

72
00:04:06,440 --> 00:04:09,293
For this we introduced
some smoothing techniques.

73
00:04:11,510 --> 00:04:14,060
All smoothing techniques
nearly erase the influence

74
00:04:14,060 --> 00:04:16,010
of the different qubits qualities

75
00:04:16,010 --> 00:04:18,649
as well as a bias towards zero

76
00:04:18,649 --> 00:04:22,320
and created approximately
uniform distribution of all

77
00:04:22,320 --> 00:04:24,540
the subset of orthogonal vectors

78
00:04:24,540 --> 00:04:26,970
and the subset of non-orthogonal vectors

79
00:04:26,970 --> 00:04:29,013
as it can be seen here on the right.

80
00:04:32,790 --> 00:04:35,450
Other interesting point in
this distribution is that

81
00:04:35,450 --> 00:04:39,479
it can only be described
by the parameter tau since

82
00:04:39,480 --> 00:04:43,593
everything else is approximately
uniform distributed.

83
00:04:44,810 --> 00:04:47,160
For experiments, we use
mainly two different

84
00:04:47,160 --> 00:04:49,583
smoothing techniques,
the permutation technique

85
00:04:49,583 --> 00:04:51,477
and the hamming technique.

86
00:04:51,477 --> 00:04:54,003
Let's take a closer look
in this two techniques.

87
00:04:55,170 --> 00:04:57,280
First of all, the permutation technique.

88
00:04:57,280 --> 00:04:59,010
For the permutation techniques

89
00:04:59,010 --> 00:05:03,620
we can rotate the qubits
assignments in our quantum circuit

90
00:05:03,620 --> 00:05:06,790
with respect to the circuit
layout and the device layout

91
00:05:06,790 --> 00:05:10,010
and take measurements to
different permutations.

92
00:05:10,010 --> 00:05:13,920
This average individual
hamming weight of the qubits

93
00:05:13,920 --> 00:05:15,803
and then mitigate the influence.

94
00:05:16,900 --> 00:05:20,010
The graph on the right
is a combination of 50

95
00:05:20,010 --> 00:05:22,630
random permutations of
qubit Simon's for which

96
00:05:22,630 --> 00:05:24,713
the circuit layout stays the same.

97
00:05:26,110 --> 00:05:27,580
It can be observed, that the influence

98
00:05:27,580 --> 00:05:32,580
of the one position of
the vectors decrease.

99
00:05:32,840 --> 00:05:35,469
For example, our example,
vectors that starting

100
00:05:35,470 --> 00:05:40,470
with one zero and zero one
and the vector that starts

101
00:05:40,720 --> 00:05:44,823
with one zero now have both
roughly a probability of 0.06.

102
00:05:47,770 --> 00:05:52,310
We see that errors of them,

103
00:05:53,640 --> 00:05:58,640
the bias towards zero still
occur, to mitigate this behavior

104
00:05:58,890 --> 00:06:00,849
also, we combined system
permutation technique

105
00:06:00,850 --> 00:06:01,983
with our second one.

106
00:06:03,672 --> 00:06:05,303
Our second technique is
the hamming technique.

107
00:06:08,921 --> 00:06:11,143
For the hamming technique we
have first to get a vector

108
00:06:11,143 --> 00:06:16,143
that has a higher Hamming
weight and is alternate to s.

109
00:06:16,400 --> 00:06:19,530
We know that at least one
of the n plus one Vectors

110
00:06:19,530 --> 00:06:22,609
with the highest hamming
weight orthogonal to s.

111
00:06:22,610 --> 00:06:27,610
In our experiments we use the
vector this all ones for this.

112
00:06:29,040 --> 00:06:32,370
We then add this vector
randomly to the measurements.

113
00:06:32,370 --> 00:06:34,340
This resides through a flipping

114
00:06:34,340 --> 00:06:38,799
of the Hamming weight around
roughly one half and half

115
00:06:38,800 --> 00:06:42,370
and create a bias towards
one for this measurements

116
00:06:42,370 --> 00:06:45,260
in combination with non
flipping measurements

117
00:06:45,260 --> 00:06:47,743
this leads to a cancellation of the bias.

118
00:06:49,090 --> 00:06:54,090
And though to our smooth
distribution, as can be seen here

119
00:06:54,320 --> 00:06:57,190
on the right, out of
the smooth distribution

120
00:06:57,190 --> 00:06:59,790
resample with probability one minus tau

121
00:06:59,790 --> 00:07:02,850
approximately uniform
alternate vector to s

122
00:07:02,850 --> 00:07:05,513
and with probability tau
and non orthogonal one.

123
00:07:06,510 --> 00:07:09,599
Because the problem to compute
s out of such distributed

124
00:07:09,600 --> 00:07:12,193
sampling the learning
Simon with noise problem.

125
00:07:13,590 --> 00:07:17,419
Formerly the learning Simon
with noise problem state

126
00:07:17,420 --> 00:07:19,600
that if we obtain the
proper risk probability

127
00:07:19,600 --> 00:07:23,900
one minus tau uniformly at
random, an orthogonal vector to s

128
00:07:23,900 --> 00:07:27,250
and s uniformly at random
orthogonal vector to s

129
00:07:27,250 --> 00:07:31,280
we wanted to compute S.
This problem is similar

130
00:07:31,280 --> 00:07:35,000
to a vague known learning
parity with noise problem

131
00:07:35,000 --> 00:07:38,130
which States that given
access to samples A comma,

132
00:07:38,130 --> 00:07:41,290
scalar product of A comma S,
whereas the scalar product

133
00:07:41,290 --> 00:07:44,623
is flipped with probability
tau we want to compute s.

134
00:07:45,500 --> 00:07:47,090
We show in our paper, indeed

135
00:07:47,090 --> 00:07:50,260
that this two problems are
pulling out time equivalent

136
00:07:51,130 --> 00:07:53,953
and that a reduction request
only a linear overhead.

137
00:07:55,460 --> 00:07:58,190
On the negative side, this
state that's a computation

138
00:07:58,190 --> 00:08:01,710
of s with noisy sampling is quite hard

139
00:08:01,710 --> 00:08:04,712
and we can't expect to compute
s in polynomial time anymore.

140
00:08:05,600 --> 00:08:08,010
On the good side however, they
are pretty good algorithms

141
00:08:08,010 --> 00:08:09,633
to solve the LPN Problem.

142
00:08:11,420 --> 00:08:14,047
More precisely for every
tau smaller than one half,

143
00:08:14,047 --> 00:08:16,790
the LPN problem can be
solved polynomial faster

144
00:08:16,790 --> 00:08:17,853
than Simon's problem.

145
00:08:19,230 --> 00:08:21,194
We now can combine the different parts,

146
00:08:21,194 --> 00:08:24,860
the noisy measurements
or from the client device

147
00:08:24,860 --> 00:08:26,640
the smoothing techniques,
and the reduction

148
00:08:26,640 --> 00:08:30,479
to the LPN problem to solve
the Simon's problem with aid

149
00:08:30,480 --> 00:08:33,330
of noisy quantum computer
faster than purely classically.

150
00:08:35,230 --> 00:08:37,640
Let us summarize our results.

151
00:08:37,640 --> 00:08:39,893
We shown that simple techniques,

152
00:08:41,466 --> 00:08:42,943
we've shown that with simpler techniques

153
00:08:42,943 --> 00:08:46,340
the problem to handle the
noisy output can be translated

154
00:08:46,340 --> 00:08:51,167
to a LSN problem and that LSN
problem then is polynomial

155
00:08:51,167 --> 00:08:53,743
time equivalent to the LPN problem.

156
00:08:55,040 --> 00:08:58,750
In combination, we
obtain a polynomial speed

157
00:08:58,750 --> 00:09:02,330
up against purely classical
solution to Simon's problem.

158
00:09:02,330 --> 00:09:04,543
I told no longer exponent slip one.

159
00:09:06,260 --> 00:09:09,220
In conclusion, this leads to
the fact that even mid-scale

160
00:09:09,220 --> 00:09:12,440
noisy current device may be
useful and provided advantage

161
00:09:12,440 --> 00:09:15,340
of a purely classical approach
for such kinds of problems.

162
00:09:17,160 --> 00:09:18,610
Thank you for your attention.

163
00:09:22,817 --> 00:09:26,010
- Hi, my name is Marloes
Venema and I will be presenting

164
00:09:26,010 --> 00:09:29,439
the paper, a bunch of broken
schemes: a simple yet powerful

165
00:09:29,440 --> 00:09:32,590
linear approach to analyzing
security of attribute-based

166
00:09:32,590 --> 00:09:36,103
encryption which I wrote
with my co author Greg Alpar.

167
00:09:37,410 --> 00:09:39,000
So, first I want to talk a little bit

168
00:09:39,000 --> 00:09:41,630
about the relevance of
attribute based encryption

169
00:09:41,630 --> 00:09:45,860
or ABE for short, especially
ciphertext-policy ABE

170
00:09:45,860 --> 00:09:47,990
is a very popular primitive.

171
00:09:47,990 --> 00:09:51,060
Many schemes have been designed
for various applications

172
00:09:51,060 --> 00:09:53,223
involving for instance, the cloud.

173
00:09:54,230 --> 00:09:57,070
And the reason why this is
such a popular primitive

174
00:09:57,070 --> 00:10:00,070
is because it allows for the
secure management of data

175
00:10:00,070 --> 00:10:03,980
despite having an untrusted
platform and especially

176
00:10:03,980 --> 00:10:07,380
multi-authority variance
of ABE are very popular

177
00:10:07,380 --> 00:10:11,310
because it allows for the
sharing of data across domains.

178
00:10:11,310 --> 00:10:14,045
So for instance, if you
consider a medical setting

179
00:10:14,045 --> 00:10:17,339
in which you have insurance
companies and hospitals

180
00:10:17,340 --> 00:10:20,453
you could still securely share data.

181
00:10:22,090 --> 00:10:26,990
So in order for ABE to work
securely in that regard

182
00:10:26,990 --> 00:10:28,840
it needs to be secure.

183
00:10:28,840 --> 00:10:31,960
Unfortunately, proving and
even verifying security

184
00:10:31,960 --> 00:10:35,690
of ABE is very difficult and
to sort of illustrate this

185
00:10:35,690 --> 00:10:38,220
we've broken several pairing based schemes

186
00:10:38,220 --> 00:10:40,943
in this work, to learn something from this

187
00:10:40,943 --> 00:10:44,384
we systematize our methods
to a linear approach

188
00:10:44,384 --> 00:10:47,820
and its approach consists
of stronger attack models

189
00:10:47,820 --> 00:10:51,460
and concise notation because
we use pairing encodings

190
00:10:51,460 --> 00:10:53,940
and finding a text generically.

191
00:10:53,940 --> 00:10:56,640
And it's actually a
simplified security analysis

192
00:10:56,640 --> 00:11:01,640
considerably because we first
manually analyze the security

193
00:11:02,410 --> 00:11:05,310
apparatus, we do not need any expertise

194
00:11:05,310 --> 00:11:07,550
in complex proof techniques.

195
00:11:07,550 --> 00:11:12,550
So before we start on anything
related to our approach,

196
00:11:12,650 --> 00:11:15,810
talk a little bit about what
is attribute based encryption.

197
00:11:15,810 --> 00:11:19,209
so much like in traditional
public key crypto we consider

198
00:11:19,210 --> 00:11:21,600
a setting with an Alice and Bob

199
00:11:21,600 --> 00:11:24,380
and in the setting Alice
is often the sender

200
00:11:24,380 --> 00:11:26,720
and Bob is often the receiver.

201
00:11:26,720 --> 00:11:28,830
However, in attribute based encryption

202
00:11:28,830 --> 00:11:32,460
we also have two entities
called the key generation

203
00:11:32,460 --> 00:11:35,570
authority and a cloud.

204
00:11:35,570 --> 00:11:38,194
And essentially we use
the cloud to store data

205
00:11:38,194 --> 00:11:41,651
and the key generation
authority generates the keys.

206
00:11:41,652 --> 00:11:45,480
So in particular the key
generation authority generates

207
00:11:45,480 --> 00:11:48,320
the master secret and a master public key.

208
00:11:48,320 --> 00:11:51,347
And anyone who wants to
encrypt anything can access

209
00:11:51,347 --> 00:11:52,843
the master public key.

210
00:11:53,710 --> 00:11:57,570
However, this master secret
key can be used to generate

211
00:11:57,570 --> 00:12:01,910
secret keys for users who
are eligible to receive some.

212
00:12:01,910 --> 00:12:03,819
So for instance, Bob is a doctor

213
00:12:03,820 --> 00:12:06,582
at the Mayo clinic, at
the neurology department

214
00:12:06,582 --> 00:12:10,203
and therefore he can receive
a key for those attributes.

215
00:12:11,160 --> 00:12:13,360
Now, if Alice wants to encrypt something

216
00:12:13,360 --> 00:12:17,173
then she can do this by
specifying who she wants,

217
00:12:18,872 --> 00:12:22,430
who she wants to authorize
the access of her data.

218
00:12:22,430 --> 00:12:25,969
So for instance, she could
say only doctors and nurses

219
00:12:25,970 --> 00:12:29,510
at the Mayo clinic at
the neurology department

220
00:12:29,510 --> 00:12:30,900
can decrypt my data.

221
00:12:30,900 --> 00:12:35,300
So she could specify this in
a policy, encrypt her data

222
00:12:35,300 --> 00:12:38,803
under the master public key
and then put it on the cloud.

223
00:12:40,000 --> 00:12:43,550
Now, Bob can decrypt this
because he has a secret key

224
00:12:43,550 --> 00:12:46,479
that satisfies, related to attributes

225
00:12:46,480 --> 00:12:48,460
that satisfies the policy.

226
00:12:48,460 --> 00:12:50,540
So because he is a doctor
at the Mayo clinic,

227
00:12:50,540 --> 00:12:55,219
at the neurology department he
can decrypt and importantly,

228
00:12:55,220 --> 00:12:58,020
Charlie, who is a nurse in the radiology

229
00:12:58,020 --> 00:13:00,114
department cannot decrypt this.

230
00:13:00,114 --> 00:13:02,900
And of course, people who
do not have secret keys

231
00:13:02,900 --> 00:13:04,600
can also not decrypt this.

232
00:13:06,399 --> 00:13:09,570
So this sort of implies
that we have a notion

233
00:13:09,570 --> 00:13:11,833
of security for attribute
based encryption.

234
00:13:13,350 --> 00:13:15,830
Well, much like in
traditional public key crypto

235
00:13:15,830 --> 00:13:17,530
we considered indistinguishability

236
00:13:19,060 --> 00:13:22,410
under chosen-plaintext attacks.

237
00:13:22,410 --> 00:13:26,270
So for those of you who
know what that means,

238
00:13:26,270 --> 00:13:28,939
the attacker will specify two messages.

239
00:13:28,940 --> 00:13:31,740
The challenger will encrypt one of the two

240
00:13:31,740 --> 00:13:33,790
and then the attacker
has to guess at the end

241
00:13:33,790 --> 00:13:38,140
of the security game which one
of the message was encrypted.

242
00:13:38,140 --> 00:13:40,409
And he should not be able
to do this with more than

243
00:13:40,409 --> 00:13:44,343
the negligible advantage
over running random guessing.

244
00:13:45,643 --> 00:13:49,890
However, the attacker is
actually allowed to do more.

245
00:13:49,890 --> 00:13:52,890
So like we said in the
previous slides, Charlie

246
00:13:52,890 --> 00:13:56,670
who is a radiology nurse
may also have a key and even

247
00:13:56,671 --> 00:14:01,020
and we even don't want
them to be able to decrypt

248
00:14:01,020 --> 00:14:04,992
because he's not authorized
to see the message.

249
00:14:06,330 --> 00:14:08,220
So the attacker can sort of do this

250
00:14:08,220 --> 00:14:11,960
by querying secret keys
for sets of attributes.

251
00:14:11,960 --> 00:14:14,230
And of course, none of these
sets of attributes maybe

252
00:14:14,230 --> 00:14:17,820
authorized to decrypt the
ciphertext in the first place.

253
00:14:17,820 --> 00:14:22,820
So, in particular the attacker
can query more than one key

254
00:14:24,180 --> 00:14:26,250
which sort of symbolizes collusion.

255
00:14:26,250 --> 00:14:29,604
So Charlie can work together
with Dave and with Erica

256
00:14:29,604 --> 00:14:33,150
and these might also have
their sets of attributes.

257
00:14:33,150 --> 00:14:34,590
And even if they have that

258
00:14:34,590 --> 00:14:36,340
they should not be able to decrypt.

259
00:14:38,820 --> 00:14:42,490
So formally the security model
covers collusion and IND-CPA

260
00:14:42,490 --> 00:14:46,720
security but it actually also
protects against other attacks

261
00:14:46,720 --> 00:14:50,550
and these attacks will be very
important in our methodology.

262
00:14:50,550 --> 00:14:53,930
So implicitly this model
ensures that users cannot

263
00:14:53,930 --> 00:14:57,339
collectively decrypt if they
cannot individually decrypt.

264
00:14:57,340 --> 00:15:00,380
They can also not generate
a key for the collective

265
00:15:00,380 --> 00:15:04,380
set of attributes or
extract the master key.

266
00:15:04,380 --> 00:15:06,780
And these give rise to our attack models.

267
00:15:06,780 --> 00:15:11,410
So in a master key attack,
the attacker would acquire

268
00:15:11,410 --> 00:15:14,469
a master key of one of the
key generation authorities.

269
00:15:14,470 --> 00:15:15,960
In an attribute key attack,

270
00:15:15,960 --> 00:15:18,570
the attacker would generate a
secret key for the collective

271
00:15:18,570 --> 00:15:20,190
set of attributes.

272
00:15:20,190 --> 00:15:22,357
In a decryption attack,
the attacker would decrypt

273
00:15:22,357 --> 00:15:25,959
the ciphertext for which
he has no authorized key.

274
00:15:25,960 --> 00:15:30,780
And in this type of attack,
we also consider two different

275
00:15:30,780 --> 00:15:35,199
type of decryption attacks,
namely, in a complete decryption

276
00:15:35,200 --> 00:15:38,010
attack the attacker would be
able to decrypt everything

277
00:15:38,010 --> 00:15:40,490
while in conditional decryption attacks

278
00:15:40,490 --> 00:15:42,610
the attacker would only be able to decrypt

279
00:15:42,610 --> 00:15:46,083
ciphertext for which the
collective set is authorized.

280
00:15:48,410 --> 00:15:50,050
We look at the security model.

281
00:15:50,050 --> 00:15:53,319
We have like a key query
phase, a challenge phase

282
00:15:53,320 --> 00:15:55,033
and another key query phase.

283
00:15:56,020 --> 00:16:01,020
And our attacks sort of
relate to the model like this.

284
00:16:01,570 --> 00:16:04,410
So the master key and the
attributes key attacks

285
00:16:05,580 --> 00:16:09,222
should be manageable to perform

286
00:16:09,222 --> 00:16:11,540
after just one key query phase.

287
00:16:11,540 --> 00:16:14,990
Also to complete and the
conditional decryption attacks

288
00:16:14,990 --> 00:16:18,420
we also need a ciphertext
which is the one that we get

289
00:16:18,420 --> 00:16:20,250
from the challenge phase.

290
00:16:20,250 --> 00:16:22,790
So note that these
attacks are much stronger

291
00:16:22,790 --> 00:16:24,569
than chosen-plaintext attacks.

292
00:16:24,570 --> 00:16:26,350
So if we can find them

293
00:16:26,350 --> 00:16:29,180
then we can also perform
a chosen-plaintext attacks

294
00:16:29,180 --> 00:16:33,709
which also means that we cannot
use these models for proving

295
00:16:33,710 --> 00:16:37,100
security but we will show
that they're very useful

296
00:16:37,100 --> 00:16:39,460
for proving insecurity.

297
00:16:39,460 --> 00:16:42,700
So especially these attacks,
these are very strong

298
00:16:43,770 --> 00:16:46,540
but we see that they're
actually also very powerful like

299
00:16:46,540 --> 00:16:49,363
we can break many schemes
with respect to these attacks.

300
00:16:52,230 --> 00:16:55,380
Another aspects of our methodology

301
00:16:55,380 --> 00:16:57,710
is that we use pair encodings.

302
00:16:57,710 --> 00:17:00,670
So a popular subclass of ABE uses pairings

303
00:17:01,590 --> 00:17:05,730
and a very commonly used
obstruction in this regard

304
00:17:05,730 --> 00:17:08,174
are pair encodings, which
is essentially what happens

305
00:17:08,174 --> 00:17:10,950
in the exponents of the schemes.

306
00:17:10,950 --> 00:17:12,800
For those of you who are a little bit

307
00:17:14,680 --> 00:17:16,452
familiar with these schemes.

308
00:17:16,452 --> 00:17:21,430
And essentially what we're
doing is we sort of symbolized

309
00:17:21,430 --> 00:17:23,869
pairing operations with
multiplications of these

310
00:17:23,869 --> 00:17:27,770
pair encodings and other group
operations are essentially

311
00:17:27,770 --> 00:17:31,079
the same as doing
additions and subtractions.

312
00:17:31,079 --> 00:17:34,389
And the advantage of this is
that we have much shorter,

313
00:17:34,389 --> 00:17:37,379
much more structured notation.

314
00:17:37,380 --> 00:17:40,160
And because we strip away
all of the group structure,

315
00:17:40,160 --> 00:17:44,640
it is also generic. As we see
finding attacks generically

316
00:17:44,640 --> 00:17:48,240
is essentially just the same
as doing linear algebra.

317
00:17:48,240 --> 00:17:50,660
Linear algebra is for most of us

318
00:17:50,660 --> 00:17:55,233
I think easier than doing a
complex security analysis.

319
00:17:56,210 --> 00:18:01,029
So this is useful, now to
see how this sort of works

320
00:18:01,029 --> 00:18:05,420
the approach we sort of,
we give an example of one

321
00:18:05,420 --> 00:18:08,720
of the schemes that we broke,
which is called DAC-MACS.

322
00:18:08,720 --> 00:18:11,059
And we found a complete decryption attack.

323
00:18:11,059 --> 00:18:13,100
And if we look at the paper

324
00:18:13,100 --> 00:18:16,469
then we see that it's
two pages, two columns.

325
00:18:16,470 --> 00:18:19,940
And if we just obstruct the
way everything that we do not

326
00:18:19,940 --> 00:18:23,660
need sort of group structure,
all of the functionality

327
00:18:23,660 --> 00:18:26,102
that we do not want to break, but just

328
00:18:26,102 --> 00:18:29,570
like the basic scheme, then
we can sort of condense all

329
00:18:29,570 --> 00:18:33,429
of that information in a couple
of lines. So we have the key

330
00:18:33,430 --> 00:18:35,690
components, we have the
ciphertext components,

331
00:18:35,690 --> 00:18:37,340
we have a blinding value.

332
00:18:37,340 --> 00:18:40,720
So the blinding value is
what hides the message.

333
00:18:40,720 --> 00:18:42,160
So if we can find that then

334
00:18:42,160 --> 00:18:45,670
we can also decrypt the ciphertext.

335
00:18:45,670 --> 00:18:47,750
So now the goal is also very clear.

336
00:18:47,750 --> 00:18:49,851
We want to have this alpha IS

337
00:18:49,851 --> 00:18:52,083
and we also know what we have.

338
00:18:53,190 --> 00:18:56,680
So from that, it also
becomes relatively easy

339
00:18:56,680 --> 00:18:58,130
to find an attack.

340
00:18:58,130 --> 00:19:01,210
So we have a goal, we
have alpha IS, and we know

341
00:19:01,210 --> 00:19:04,610
that we can multiply key
and ciphertext components

342
00:19:04,610 --> 00:19:06,669
and basically linearly combine them

343
00:19:06,670 --> 00:19:08,823
in order to retrieve this blinding value.

344
00:19:09,960 --> 00:19:13,500
So instead of blindly
trying all combinations

345
00:19:13,500 --> 00:19:16,570
we're going to do this also
in a very targeted way.

346
00:19:16,570 --> 00:19:18,620
So we just look at which combinations

347
00:19:18,620 --> 00:19:21,953
to make in order to retrieve alpha IS.

348
00:19:23,130 --> 00:19:26,402
So by multiplying the first two components

349
00:19:26,402 --> 00:19:29,750
we gained this and we know

350
00:19:29,750 --> 00:19:33,066
that we need to cancel these parts.

351
00:19:33,066 --> 00:19:37,860
And then we just have to see
which combinations to make

352
00:19:37,860 --> 00:19:39,236
in order to do that.

353
00:19:39,237 --> 00:19:42,947
And we see that we can do
that, so the attack works.

354
00:19:42,947 --> 00:19:46,822
The advantage of this approach
is also that it extends

355
00:19:46,822 --> 00:19:50,082
very naturally to the
multi authority setting.

356
00:19:50,083 --> 00:19:52,050
So in a multi authority setting

357
00:19:52,050 --> 00:19:53,922
we consider that's the setting

358
00:19:53,922 --> 00:19:58,690
in which we have one authority,
but two or more basically.

359
00:19:58,690 --> 00:20:01,050
And like in this example,
we have a hospital

360
00:20:01,050 --> 00:20:04,669
and insurance company, which
might not trust one another.

361
00:20:04,670 --> 00:20:07,931
So this also implies a security notion.

362
00:20:07,931 --> 00:20:11,560
So does additional security
requirements essentially says

363
00:20:11,560 --> 00:20:14,830
that the scheme should
still be secure with respect

364
00:20:14,830 --> 00:20:18,679
to the honest authorities, even
if one or more are corrupt.

365
00:20:18,680 --> 00:20:21,930
And we can do this by
modeling the knowledge

366
00:20:21,930 --> 00:20:25,340
that the attacker gains or in our approach

367
00:20:25,340 --> 00:20:28,050
we would extend the
space with coefficients,

368
00:20:28,050 --> 00:20:31,251
in which the coefficients live
and the linear combinations.

369
00:20:31,251 --> 00:20:33,379
And it may enable an attack against

370
00:20:33,380 --> 00:20:35,393
the honest key generation authorities.

371
00:20:36,500 --> 00:20:40,480
Or in order to see how powerful
this approach is we have,

372
00:20:40,480 --> 00:20:43,832
we have broken quite
some schemes, 11 schemes

373
00:20:43,832 --> 00:20:48,000
and actually the majority of
all of these schemes are broken

374
00:20:48,000 --> 00:20:50,700
with respect to the
strongest attack models.

375
00:20:50,700 --> 00:20:54,140
So the master key attacks and
complete decryption attacks.

376
00:20:54,140 --> 00:20:59,140
So yeah, the most parts
are broken under corruption

377
00:20:59,480 --> 00:21:01,350
but this still breaks these schemes.

378
00:21:01,350 --> 00:21:03,730
And only two of them are broken

379
00:21:03,730 --> 00:21:06,930
on the attribute key
attacks under collusion.

380
00:21:06,930 --> 00:21:08,880
So that's how powerful this approach is.

381
00:21:08,880 --> 00:21:11,000
Nine out of the 11 schemes are broken

382
00:21:11,000 --> 00:21:13,564
under the two strongest attacks.

383
00:21:13,564 --> 00:21:15,900
So in conclusion, we presented the simple

384
00:21:15,900 --> 00:21:18,740
yet powerful linear approach
to analyzing security

385
00:21:18,740 --> 00:21:21,720
of ABE as very effective in practice.

386
00:21:21,720 --> 00:21:25,220
We broke a bunch of schemes
as a very useful tool

387
00:21:25,220 --> 00:21:28,723
and the design of an analysis of schemes.

388
00:21:29,830 --> 00:21:31,280
Thank you for your attention.

389
00:21:35,500 --> 00:21:38,630
- The topic we are going
to discuss today is zero

390
00:21:38,630 --> 00:21:42,760
correlation linear cryptanalysis
with equal treatment

391
00:21:42,760 --> 00:21:45,200
for plaintexts and tweakys.

392
00:21:45,200 --> 00:21:46,630
And my name is Chao Niu

393
00:21:48,120 --> 00:21:52,770
from Shandong University,
China. The author of this paper

394
00:21:52,770 --> 00:21:56,523
is Chao Niu, Muzhou Li,
Siwei Sun, Meiqin Wang.

395
00:21:58,820 --> 00:22:01,182
First, we will introduce the motivation

396
00:22:01,182 --> 00:22:04,810
and the contributions of this work.

397
00:22:04,810 --> 00:22:09,370
And next we will introduce the
new zero-correlation linear

398
00:22:09,370 --> 00:22:13,592
cryptanalysis method and
the automatic search method.

399
00:22:15,580 --> 00:22:18,043
About zero-correlation
linear cryptanalysis.

400
00:22:20,670 --> 00:22:25,020
Zero-correlation linear
cryptanalysis is a variant of linear

401
00:22:25,020 --> 00:22:29,410
cryptanalysis. Another
interesting development

402
00:22:29,410 --> 00:22:33,220
of the zero correlation linear
cryptanalysis discussing

403
00:22:33,220 --> 00:22:38,220
the effect of the tweakys
proposed by Ankele et al.

404
00:22:39,720 --> 00:22:44,200
The method applies to ciphers
with linear tweaky schedule

405
00:22:45,470 --> 00:22:50,470
and work at the word level
which come as some are not

406
00:22:50,670 --> 00:22:52,773
operators distinguishers.

407
00:22:55,650 --> 00:23:00,320
Motivation and contributions,
many block ciphers

408
00:23:00,320 --> 00:23:03,100
including tweaked block cipher all include

409
00:23:03,100 --> 00:23:04,929
more complex key schedule

410
00:23:05,820 --> 00:23:09,913
such as a non-linear part
due to its complexity.

411
00:23:13,060 --> 00:23:15,570
It is hard to derive the propagation

412
00:23:15,570 --> 00:23:18,112
of the linear mask by hand.

413
00:23:19,040 --> 00:23:24,040
So looking for automatic
search method can help.

414
00:23:25,680 --> 00:23:30,347
We generalize Ankele et al's
idea by considering zero

415
00:23:31,320 --> 00:23:35,659
correlation linear
approximation involving the bits

416
00:23:35,660 --> 00:23:40,660
of plaintexts, keys, and tweaks

417
00:23:41,130 --> 00:23:45,423
and our method works at the bit level.

418
00:23:48,320 --> 00:23:52,014
We will introduce the
original zero-correlation

419
00:23:52,015 --> 00:23:54,410
linear cryptoanalysis.

420
00:23:54,410 --> 00:23:57,510
we call the M bit vector alpha

421
00:23:57,510 --> 00:24:00,600
and the beta linear mask

422
00:24:00,600 --> 00:24:03,230
on the plaintext and the ciphertexts

423
00:24:04,277 --> 00:24:07,380
and they define the following equation

424
00:24:07,380 --> 00:24:12,000
as a correlation between alpha and beta

425
00:24:12,980 --> 00:24:17,980
on the block cipher E
bracket alpha x, denote

426
00:24:19,950 --> 00:24:23,660
the inner product of plaintext x

427
00:24:23,660 --> 00:24:26,043
and the linear mask alpha.

428
00:24:30,003 --> 00:24:33,703
We can see that when we
reverse the Plaintext x

429
00:24:35,500 --> 00:24:39,430
we can't get to the value
of the above formula

430
00:24:41,400 --> 00:24:44,530
and when this formula equal to zero

431
00:24:45,460 --> 00:24:50,460
we can see this alpha beta
form a zero correlation

432
00:24:50,800 --> 00:24:55,800
approximation, just like
differential cryptanalysis

433
00:24:56,086 --> 00:25:00,033
then you must have a similar
set of propagation rules.

434
00:25:02,580 --> 00:25:05,669
In zero correlation
analysis we always start

435
00:25:05,670 --> 00:25:10,020
from the plaintext and
the ciphertext to push

436
00:25:10,020 --> 00:25:15,020
the propagation of the linear
mask backwards and forward.

437
00:25:17,750 --> 00:25:19,300
When the mask propagation

438
00:25:19,300 --> 00:25:21,570
in the two direction meets together

439
00:25:22,620 --> 00:25:27,300
and a contradiction occurs,
we find our zero-correlation

440
00:25:27,300 --> 00:25:29,978
distinguisher then we will

441
00:25:29,978 --> 00:25:34,433
introduce our four round AES
zero-correlation distinguisher.

442
00:25:36,310 --> 00:25:41,310
This is a four round
zero-correlation linear hull.

443
00:25:41,550 --> 00:25:46,550
And the gray block denotes
active, now zero linear mask

444
00:25:47,700 --> 00:25:52,633
and the white block denotes
the inactive zero linear mask.

445
00:25:53,620 --> 00:25:58,620
The input alpha is kept
active through the S box.

446
00:26:00,100 --> 00:26:03,120
And then a shift to row operation

447
00:26:03,120 --> 00:26:04,923
and the mixcolumn operation.

448
00:26:06,440 --> 00:26:11,440
Propagate to the S state
then derive the propagation

449
00:26:12,690 --> 00:26:16,933
of the output mask in
the reverse direction.

450
00:26:18,510 --> 00:26:23,510
We can get to this state
then the contradiction occurs

451
00:26:24,050 --> 00:26:27,953
because the branch number of AES is five.

452
00:26:32,650 --> 00:26:37,650
The linear approximation expression

453
00:26:37,960 --> 00:26:40,580
of the original zero-correlation being

454
00:26:40,580 --> 00:26:43,760
their analysis is only consider the mask

455
00:26:43,760 --> 00:26:46,983
on the plaintext and ciphertext.

456
00:26:49,270 --> 00:26:53,930
We add gamma in the product key exclusive

457
00:26:53,930 --> 00:26:57,000
or lambda in the product tweak

458
00:26:58,210 --> 00:27:03,210
to this formula and form the
new linear approximation.

459
00:27:03,635 --> 00:27:08,635
From the above definition we
can see that the correlation

460
00:27:09,390 --> 00:27:14,390
is computed over all possible
plaintext, keys and tweaks.

461
00:27:17,790 --> 00:27:21,440
Since keys and tweaks bits have been added

462
00:27:21,440 --> 00:27:23,383
into linear approximation.

463
00:27:24,260 --> 00:27:28,190
We should also consider
the key/tweak schedule

464
00:27:28,190 --> 00:27:30,403
when analyzing this zero correlation.

465
00:27:31,930 --> 00:27:35,478
In order to better
understand the propagation

466
00:27:35,478 --> 00:27:39,547
of the mask on the key/tweak schedule

467
00:27:39,547 --> 00:27:41,783
we first introduce two propagation rules.

468
00:27:44,410 --> 00:27:49,410
The correlation is not zero
if and only if the output mask

469
00:27:50,105 --> 00:27:52,855
Alpha is equal to two input mask.

470
00:27:55,188 --> 00:27:59,659
When the linear mask passes
through the branch operation,

471
00:27:59,659 --> 00:28:02,870
the correlation is not zero if and only

472
00:28:02,870 --> 00:28:05,870
if the article mask is the exclusive

473
00:28:06,879 --> 00:28:11,462
of the two input mask alpha
exclusive or beta exclusive

474
00:28:14,730 --> 00:28:16,933
or beta equals to alpha.

475
00:28:18,240 --> 00:28:22,783
Next, we will consider a
simple tweak block cipher.

476
00:28:24,060 --> 00:28:29,060
As shown in the figure
lambda denote the leaner mask

477
00:28:30,500 --> 00:28:31,743
on the master tweak.

478
00:28:33,720 --> 00:28:38,720
Gamma i denote the linear mask
around the S round subtweak .

479
00:28:40,784 --> 00:28:45,701
Because the mask propagation
through exclusive r operation.

480
00:28:47,120 --> 00:28:50,786
So the mini mask on the
septic is gamma two.

481
00:28:53,390 --> 00:28:57,587
Since this tweak block
cipher exclusive of the sum T

482
00:28:59,460 --> 00:29:04,460
in each row according to
the branch operation role

483
00:29:06,600 --> 00:29:09,340
there has been mask tweak lambda

484
00:29:10,220 --> 00:29:13,368
equal to the exclusive r sum

485
00:29:13,368 --> 00:29:17,629
of a linear mask gamma zero to gamma r

486
00:29:19,100 --> 00:29:21,419
then we can get a set

487
00:29:21,420 --> 00:29:26,333
of all possible lambda that
make the correlation now zero.

488
00:29:27,270 --> 00:29:30,660
Finally, we'll pick a
Lambda, not in this set

489
00:29:32,860 --> 00:29:36,102
and then we can deduce the contradiction.

490
00:29:38,100 --> 00:29:40,310
What happens when we consider

491
00:29:40,310 --> 00:29:43,600
a block Cipher with a
complex key schedule.

492
00:29:43,600 --> 00:29:47,300
The main idea is the
same, in this picture,

493
00:29:47,300 --> 00:29:51,570
h is a key schedule function

494
00:29:51,570 --> 00:29:55,639
which may contain a non-linear function.

495
00:29:55,640 --> 00:30:00,020
G is a subkey extraction function

496
00:30:00,020 --> 00:30:04,694
accurately checking the
propagation of the linear mask

497
00:30:04,694 --> 00:30:06,360
in the key schedule.

498
00:30:08,168 --> 00:30:12,001
We can also get the set
of linear mask lambda,

499
00:30:13,220 --> 00:30:14,940
and the way it shows linear mask

500
00:30:14,940 --> 00:30:19,853
that don't belong to this set
then we get the contradiction.

501
00:30:23,330 --> 00:30:27,300
Since our linear approximation expression

502
00:30:27,300 --> 00:30:29,353
contains the security input K,

503
00:30:31,453 --> 00:30:35,520
we cannot traverse this input
to get to the correlation.

504
00:30:35,520 --> 00:30:38,713
To solve this problem we
use the theorem proposed

505
00:30:39,611 --> 00:30:44,380
by Sun et al to convert the
zero correlation distinguisher

506
00:30:44,380 --> 00:30:46,313
into an integral distinguisher.

507
00:30:47,440 --> 00:30:52,440
Assume we are in the sixth
block of the K is a zero mask

508
00:30:53,630 --> 00:30:58,200
the first block on the
plaintext is the active mask

509
00:30:58,200 --> 00:31:03,130
and the first block on the
ciphertext is the active mask.

510
00:31:03,130 --> 00:31:08,130
Then we can convert this
zero correlation linear

511
00:31:08,570 --> 00:31:11,100
into an integral of the following form

512
00:31:13,873 --> 00:31:18,153
where the sixth block in the
K is active and the plaintext

513
00:31:20,950 --> 00:31:24,340
except for the first block as a constant

514
00:31:24,340 --> 00:31:27,679
the others are active
and we can get the first

515
00:31:27,680 --> 00:31:32,680
block of the intact as a balanced block.

516
00:31:35,740 --> 00:31:40,740
In order to find this zero
correlation linear approximation

517
00:31:41,450 --> 00:31:45,713
we use an automatic
search method based STP.

518
00:31:49,290 --> 00:31:53,580
A block cipher purely
contains key/tweak schedule

519
00:31:53,580 --> 00:31:55,463
and round function.

520
00:31:56,530 --> 00:31:59,160
When the propagation of the linear mask

521
00:31:59,160 --> 00:32:01,820
through the block cipher algorithm

522
00:32:01,820 --> 00:32:05,101
the mode only, the components
we can piece together

523
00:32:05,101 --> 00:32:07,860
entire blocks of algorithm.

524
00:32:07,860 --> 00:32:12,860
Next we realistically select
some input mask and output mask

525
00:32:14,540 --> 00:32:17,010
and the limits on tools input

526
00:32:17,010 --> 00:32:22,010
of the model M and a rather SAT model.

527
00:32:22,500 --> 00:32:25,460
If the model returns invalid,

528
00:32:26,305 --> 00:32:30,878
the zero correlation approximation
from the buzzer selects

529
00:32:30,878 --> 00:32:34,993
the mask is a distinguisher.

530
00:32:38,080 --> 00:32:41,062
Next we will introduce the application.

531
00:32:42,210 --> 00:32:45,770
Both of the two block ciphers
have a nonlinear key schedule

532
00:32:46,700 --> 00:32:50,833
and we apply our method we can
get a longest distinguisher

533
00:32:50,833 --> 00:32:54,120
for TWINE and a longer
distinguisher for LBlock

534
00:32:55,276 --> 00:32:59,650
then we apply our method
to SKINNY and improve

535
00:32:59,650 --> 00:33:03,580
the result of Ankele et al by searching

536
00:33:03,580 --> 00:33:07,223
after the bit level and the
keep the same data complexity.

537
00:33:09,350 --> 00:33:12,360
Next week, you should
understand the core idea

538
00:33:12,360 --> 00:33:16,071
of our attack in the first
three months you should try

539
00:33:16,071 --> 00:33:18,793
to do the propagation of a linear mask.

540
00:33:18,793 --> 00:33:23,449
Within six months you should
make a zero correlation attacks

541
00:33:23,450 --> 00:33:26,437
on other blocks cipher. Thank you.

