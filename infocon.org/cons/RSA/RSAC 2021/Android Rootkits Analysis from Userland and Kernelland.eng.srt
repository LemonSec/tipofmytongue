1
00:00:01,800 --> 00:00:03,929
- Hi, hello everyone,

2
00:00:03,930 --> 00:00:07,266
so today we will be talking about

3
00:00:07,266 --> 00:00:08,132
analyzing Android Rootkits,

4
00:00:09,634 --> 00:00:12,433
using Userland and Kernelland techniques.

5
00:00:14,430 --> 00:00:18,710
Myself Dinesh, I'm a security
researcher at Google,

6
00:00:18,710 --> 00:00:22,030
I worked in Microsoft
prior to joining Google

7
00:00:22,030 --> 00:00:24,070
and Symantec and HCL,

8
00:00:24,070 --> 00:00:26,270
I am one of the mathematician

9
00:00:26,270 --> 00:00:27,770
who tries to apply mathematics

10
00:00:28,720 --> 00:00:30,810
in the world's engineering tasks,

11
00:00:30,810 --> 00:00:33,610
and I am also in a long pursuit

12
00:00:33,610 --> 00:00:35,890
of building malware knowledge graph,

13
00:00:35,890 --> 00:00:39,420
we're representing all the
malware I have analyzed so far

14
00:00:39,420 --> 00:00:40,530
in a knowledge graph

15
00:00:40,530 --> 00:00:45,310
that can help create
actionable threat intelligence

16
00:00:45,310 --> 00:00:47,270
and explainable machine learning,

17
00:00:47,270 --> 00:00:52,037
I have my talented colleague
Aditi with me, Aditi.

18
00:00:53,290 --> 00:00:55,188
- Hey, hi, so I'm Aditi,

19
00:00:55,188 --> 00:00:57,170
I'm security engineer at Atlassian,

20
00:00:57,170 --> 00:00:59,210
I'm a hobbyist hacker, security researcher

21
00:00:59,210 --> 00:01:00,760
and techno-sociologist,

22
00:01:00,760 --> 00:01:02,500
I am spreading cyber awareness

23
00:01:02,500 --> 00:01:04,989
through my initiative Infinite Hacks,

24
00:01:04,989 --> 00:01:07,100
which is there on aditi.fyi.

25
00:01:07,100 --> 00:01:08,899
So really excited for this presentation

26
00:01:08,900 --> 00:01:10,370
and let's get started.

27
00:01:12,190 --> 00:01:14,304
- Sure thank you Aditi.

28
00:01:14,305 --> 00:01:19,305
So before we take a deep
dive into the actual content

29
00:01:19,420 --> 00:01:22,350
we would like to set the
context of this session.

30
00:01:22,350 --> 00:01:23,309
So in this session,

31
00:01:23,310 --> 00:01:27,660
we will be talking about
Android Rootkit techniques,

32
00:01:27,660 --> 00:01:31,460
and how to analyze them predominantly

33
00:01:31,460 --> 00:01:35,490
and how can it be
improved to repurpose them

34
00:01:35,490 --> 00:01:38,220
as an instrumentation framework,

35
00:01:38,220 --> 00:01:40,160
so that you will be able to use it

36
00:01:40,160 --> 00:01:42,770
in the automated behavior
extraction frameworks

37
00:01:42,770 --> 00:01:44,020
that you may have,

38
00:01:44,020 --> 00:01:48,863
like wonderful addition to
existing sandbox environments,

39
00:01:49,760 --> 00:01:51,380
so the scope,

40
00:01:51,380 --> 00:01:53,390
sometimes it is easy to

41
00:01:55,010 --> 00:01:56,610
when we refer to Rootkits

42
00:01:56,610 --> 00:01:59,200
it is easy to think it of as a jailbreak

43
00:01:59,200 --> 00:02:01,509
equal on top of Android right?

44
00:02:01,509 --> 00:02:02,830
So in this case we are not going

45
00:02:02,830 --> 00:02:06,140
to talk about jailbreaking
or rooting the device,

46
00:02:06,140 --> 00:02:08,221
instead we will be talking rootkits

47
00:02:08,221 --> 00:02:10,277
in the traditional malware sense,

48
00:02:10,277 --> 00:02:13,220
where we will be talking
about different ways

49
00:02:13,220 --> 00:02:16,410
to hide certain artifacts,

50
00:02:16,410 --> 00:02:18,440
which otherwise is not possible,

51
00:02:18,440 --> 00:02:22,200
so we will be covering Userland
and Kernelland techniques

52
00:02:22,200 --> 00:02:25,410
at the same time we will be also covering

53
00:02:25,410 --> 00:02:26,750
how to analyze the Rootkits

54
00:02:26,750 --> 00:02:29,070
from Userland and Kernelland techniques.

55
00:02:29,070 --> 00:02:31,140
So Aditi will take over,

56
00:02:31,140 --> 00:02:33,209
covering Userland techniques

57
00:02:33,210 --> 00:02:35,870
using dynamic binary
instrumentation frameworks

58
00:02:35,870 --> 00:02:40,870
and tool that she has written
on top of frida as well,

59
00:02:40,940 --> 00:02:43,020
and then I will take it over again

60
00:02:43,020 --> 00:02:46,480
and cover from memory
forensics perspective

61
00:02:46,480 --> 00:02:51,480
using volatility, frida,
and knowledge graph,

62
00:02:51,670 --> 00:02:52,833
so I will hand it over to Aditi now.

63
00:02:55,570 --> 00:02:57,539
- Yeah so as Dinesh mentioned

64
00:02:57,539 --> 00:02:58,880
we'll be talking about Rootkits,

65
00:02:58,880 --> 00:03:01,660
from Userland and Kernelland perspective.

66
00:03:01,660 --> 00:03:03,820
Now in Userland I'll
be covering LD Preload

67
00:03:03,820 --> 00:03:04,970
will be seeing the Rootkit,

68
00:03:04,970 --> 00:03:06,720
which is using LD Preload,

69
00:03:06,720 --> 00:03:08,890
and then we'll be covering
the analysis techniques

70
00:03:08,890 --> 00:03:10,200
from Userland.

71
00:03:10,200 --> 00:03:11,033
And in Kernelland,

72
00:03:11,033 --> 00:03:12,799
we'll be covering Ptrace, Sys Call Hook,

73
00:03:12,800 --> 00:03:14,860
and other things that Dinesh will cover.

74
00:03:14,860 --> 00:03:18,433
So let's get into Userland
rootkit and analysis.

75
00:03:19,860 --> 00:03:22,170
Now, LD preload as you
must be familiar with

76
00:03:22,170 --> 00:03:23,459
is an age-old trick,

77
00:03:23,460 --> 00:03:26,780
it exploits functionality
provided by the dynamic linker

78
00:03:26,780 --> 00:03:28,720
that allows you to tell the linker

79
00:03:28,720 --> 00:03:31,950
to bind symbols provided
by a certain shared library

80
00:03:31,950 --> 00:03:33,799
before other libraries.

81
00:03:33,800 --> 00:03:37,280
So it has been a hook which
is there, which has been there

82
00:03:37,280 --> 00:03:38,660
and we'll be exploiting this one

83
00:03:38,660 --> 00:03:40,480
to create a rootkit which will be trying

84
00:03:40,480 --> 00:03:43,489
to hide its presence from Android system.

85
00:03:43,490 --> 00:03:45,223
So let's see how that works,

86
00:03:47,380 --> 00:03:51,570
you'll see here that, it's
now that it is a toy rootkit

87
00:03:51,570 --> 00:03:54,079
which I have called Android system update.

88
00:03:54,080 --> 00:03:56,270
Now, as any typical app in Android

89
00:03:56,270 --> 00:03:59,170
when you open systems in
apps and notifications

90
00:03:59,170 --> 00:04:01,171
you'll be seeing this app

91
00:04:01,171 --> 00:04:02,780
the icon and the name of the app

92
00:04:02,780 --> 00:04:05,250
right, similarly, when
you open all the list

93
00:04:05,250 --> 00:04:08,160
this app again appears, and
that is a way to let user know

94
00:04:08,160 --> 00:04:09,810
that this is installed.

95
00:04:09,810 --> 00:04:12,300
Now, I will be creating
a live hook from that SL

96
00:04:12,300 --> 00:04:14,480
which is essentially a C code

97
00:04:14,480 --> 00:04:16,640
compiled and pushed into Android,

98
00:04:16,640 --> 00:04:18,209
and then we'll be setting it up

99
00:04:18,209 --> 00:04:21,489
as the LDP load hook for the app settings.

100
00:04:21,490 --> 00:04:24,820
So see that we need the for
massive mode documents for that

101
00:04:24,820 --> 00:04:26,550
that is what I'm doing
in the command shell

102
00:04:26,550 --> 00:04:28,100
in the terminal here,

103
00:04:28,100 --> 00:04:31,334
and I'll set the property
wrapped of conduct

104
00:04:31,334 --> 00:04:34,730
and all your settings LDP
load to point to this as well

105
00:04:34,730 --> 00:04:37,370
which have pushed into the device.

106
00:04:37,370 --> 00:04:39,730
So now once I've pushed the SO

107
00:04:39,730 --> 00:04:42,900
let's try to open settings
again and see what happens

108
00:04:43,970 --> 00:04:46,770
now you see that when we click
on apps and notifications

109
00:04:46,770 --> 00:04:49,450
the app has gone, we won't
be able to see the icon

110
00:04:49,450 --> 00:04:51,680
or the name of the app anywhere,

111
00:04:51,680 --> 00:04:54,590
and this is a typical of the notification

112
00:04:54,590 --> 00:04:57,842
then file will hide its presence
by using the LD load hook.

113
00:04:59,020 --> 00:05:01,960
So now having looked at this demo

114
00:05:01,960 --> 00:05:04,580
let's move towards our analysis approach.

115
00:05:04,580 --> 00:05:05,740
Now, how do we analyze such a scenario

116
00:05:05,740 --> 00:05:10,210
such as Userland infection,
how to go about starting it?

117
00:05:10,210 --> 00:05:12,479
Now what we have done is basically split

118
00:05:12,480 --> 00:05:14,260
the analysis approach into four steps,

119
00:05:14,260 --> 00:05:15,830
which are pretty into intuitive.

120
00:05:15,830 --> 00:05:18,000
What we want to do is right have the state

121
00:05:18,000 --> 00:05:20,190
of the system before the infection.

122
00:05:20,190 --> 00:05:21,840
Now, when I say state of the system

123
00:05:21,840 --> 00:05:22,953
what I want to do is

124
00:05:22,953 --> 00:05:25,200
animate all the processes
which are running

125
00:05:25,200 --> 00:05:26,469
and all of the modules,

126
00:05:26,470 --> 00:05:28,870
which are loaded within those processes.

127
00:05:28,870 --> 00:05:31,430
So once I have captured that base state

128
00:05:31,430 --> 00:05:34,210
I'll do infection on the device.

129
00:05:34,210 --> 00:05:37,000
And we capture this state
again after the infection

130
00:05:37,000 --> 00:05:39,940
so capture the state after
you get it has infected

131
00:05:39,940 --> 00:05:42,469
again animate all the
processes and all the modules

132
00:05:42,470 --> 00:05:45,930
and then we compare and
analyze the two states.

133
00:05:45,930 --> 00:05:47,680
I will be talking about third point more

134
00:05:47,680 --> 00:05:49,020
in the coming slide,

135
00:05:49,020 --> 00:05:50,539
and then in the fourth point

136
00:05:50,540 --> 00:05:52,860
we identify the memory
segments of interest

137
00:05:52,860 --> 00:05:55,910
and dump it to reverse
engineer and analyze.

138
00:05:55,910 --> 00:05:58,066
So these are the four steps approach

139
00:05:58,066 --> 00:05:59,549
that will be taking in our

140
00:05:59,550 --> 00:06:02,150
analysis of this Userland rootkit.

141
00:06:02,150 --> 00:06:05,020
So what you will be able to
detect using these is that

142
00:06:05,020 --> 00:06:07,320
if any new process has appeared or not

143
00:06:07,320 --> 00:06:08,940
because we have captured the state before

144
00:06:08,940 --> 00:06:11,130
and after the infection,
we'll be able to know

145
00:06:11,130 --> 00:06:13,380
if there's any new
processes which has appeared

146
00:06:13,380 --> 00:06:16,730
or deleted any new module which has loaded

147
00:06:16,730 --> 00:06:17,927
in any of the processes,

148
00:06:17,927 --> 00:06:21,070
and we can also see whether
the module have been loaded

149
00:06:21,070 --> 00:06:24,780
from the same path as, before,
or has the path changed,

150
00:06:24,780 --> 00:06:26,229
what about the size of the module?

151
00:06:26,230 --> 00:06:27,580
Is it the same?

152
00:06:27,580 --> 00:06:30,998
So those are the kinds of things
that we do in the analysis.

153
00:06:30,999 --> 00:06:33,010
And you'll all see the
change in protection levels

154
00:06:33,010 --> 00:06:34,719
and all sorts of things which come up

155
00:06:34,720 --> 00:06:38,440
when a module is dynamically
loaded in any of the processes.

156
00:06:38,440 --> 00:06:40,680
So we'll do that and we'll analyze

157
00:06:40,680 --> 00:06:42,740
also all the popular shared libraries.

158
00:06:42,740 --> 00:06:45,507
So in Android, all the processes
are from both of cycles

159
00:06:45,507 --> 00:06:47,530
And all of them have a set of libraries

160
00:06:47,530 --> 00:06:49,760
which are common, which
are system libraries

161
00:06:49,760 --> 00:06:51,370
that the app is trying to use,

162
00:06:51,370 --> 00:06:54,240
so the idea is enlist on
the popular shared libraries

163
00:06:54,240 --> 00:06:56,870
across all the processes and find out

164
00:06:56,870 --> 00:06:59,820
whether they have been patched
or not due to the infection.

165
00:07:01,900 --> 00:07:04,549
So, and you wouldn't be doing
a lot of this manually, right,

166
00:07:04,550 --> 00:07:05,383
otherwise what's the point of it

167
00:07:05,383 --> 00:07:06,859
it'll take a long time.

168
00:07:06,860 --> 00:07:08,550
So we have created a tool for this

169
00:07:08,550 --> 00:07:10,220
which is called a Smart Alec

170
00:07:10,220 --> 00:07:12,430
which brings all these four steps together

171
00:07:12,430 --> 00:07:14,130
and conducts the analysis for you.

172
00:07:15,520 --> 00:07:17,522
So in this tool, which
is based on top of frida

173
00:07:17,523 --> 00:07:20,490
will be using typical
frida functionalities

174
00:07:20,490 --> 00:07:23,520
to capture the enumerate
rate ranges synchronous,

175
00:07:23,520 --> 00:07:26,229
so basically finding out
what happened with it

176
00:07:26,230 --> 00:07:27,063
you know as a part of the process

177
00:07:27,063 --> 00:07:29,349
what are the different
modules, which are loaded

178
00:07:29,350 --> 00:07:32,010
and essentially using the memory function,

179
00:07:32,010 --> 00:07:34,010
which frida provides
need to file all these

180
00:07:34,010 --> 00:07:37,530
so basically we are trying
to fetch that plot SO file

181
00:07:37,530 --> 00:07:40,780
that you know infected from
within the memory and dump it

182
00:07:40,780 --> 00:07:43,380
so that you can think it,
and reverse engineer then.

183
00:07:44,990 --> 00:07:47,343
So let's see how Smart Alec functions.

184
00:07:49,400 --> 00:07:51,623
Now, here in this demo,
what we'll be doing is

185
00:07:51,623 --> 00:07:54,500
capture the state, do the infection,

186
00:07:54,500 --> 00:07:57,420
capture the state up to
infection, do the analysis

187
00:07:57,420 --> 00:08:00,573
and then dump the SO of interest
for reverse engineering.

188
00:08:01,460 --> 00:08:03,102
So let's see what happens.

189
00:08:04,780 --> 00:08:06,900
Now, note that we do need server,

190
00:08:06,900 --> 00:08:09,830
so in the initial steps there's
a moment setting up frida

191
00:08:09,830 --> 00:08:11,180
on Android,

192
00:08:11,180 --> 00:08:14,640
so I will push frida
server in Android server

193
00:08:14,640 --> 00:08:15,979
in client some architecture

194
00:08:15,980 --> 00:08:18,270
so we need server to be
pushed in the emulator

195
00:08:18,270 --> 00:08:19,370
and then the client

196
00:08:19,370 --> 00:08:22,230
which is the AI system from
which we are connecting.

197
00:08:22,230 --> 00:08:27,230
So here, I'm just pushing
frida server of HD 364

198
00:08:27,760 --> 00:08:29,680
which is my emulator's architecture

199
00:08:29,680 --> 00:08:31,730
into the device, into the emulator,

200
00:08:31,730 --> 00:08:34,520
and once I've done that, I run the server

201
00:08:34,520 --> 00:08:36,870
and I test whether the
connection has been established

202
00:08:36,870 --> 00:08:38,860
between the system and the client.

203
00:08:38,860 --> 00:08:40,683
This is done by running frida PSU command,

204
00:08:40,683 --> 00:08:43,398
so when I run frida down PSU

205
00:08:43,398 --> 00:08:45,290
it will enlist all the processes

206
00:08:45,290 --> 00:08:47,969
which are there running on the system,

207
00:08:47,970 --> 00:08:50,300
on the Android I'm sorry.

208
00:08:50,300 --> 00:08:52,240
So and let's talk about processes

209
00:08:52,240 --> 00:08:54,640
and you would know that, okay, cool

210
00:08:54,640 --> 00:08:56,120
the connection been established

211
00:08:56,120 --> 00:08:59,290
So that is the first part of
the demo setting up frida.

212
00:08:59,290 --> 00:09:02,319
Now this is the sample rootkit of file

213
00:09:02,320 --> 00:09:03,890
which will be using to create,

214
00:09:03,890 --> 00:09:05,830
to simulate a rootkit infection.

215
00:09:05,830 --> 00:09:08,470
What it is trying to do is
basically setting the Linux

216
00:09:08,470 --> 00:09:11,770
in permissive mode and after
that setting properties

217
00:09:11,770 --> 00:09:15,260
for three different apps,
settings app, calendar and email,

218
00:09:15,260 --> 00:09:17,930
so we're pointing all of them
to load the lip hooked up

219
00:09:17,930 --> 00:09:20,130
as so that we just saw
in the previous demo.

220
00:09:22,450 --> 00:09:24,760
So all the time we'll be loading this,

221
00:09:24,760 --> 00:09:27,194
we are not yet infected but this is a file

222
00:09:27,194 --> 00:09:28,743
we will be using for infection.

223
00:09:31,420 --> 00:09:34,219
So now let's do the pull
system offered approach

224
00:09:34,220 --> 00:09:37,730
which was capture the state of the device,

225
00:09:37,730 --> 00:09:42,050
for that we'll be using the Smart Alec.

226
00:09:42,050 --> 00:09:44,510
So let's just push this file also

227
00:09:44,510 --> 00:09:46,550
in this system so that we can run it,

228
00:09:46,550 --> 00:09:48,390
when we want to do the analysis

229
00:09:48,390 --> 00:09:50,183
just before the post would get analysis

230
00:09:50,183 --> 00:09:52,520
we will be running the file.

231
00:09:52,520 --> 00:09:56,353
So I'm just pushing it
into the device right now.

232
00:10:00,530 --> 00:10:02,510
So once this is done,

233
00:10:02,510 --> 00:10:03,992
let's move to Smart Alec,

234
00:10:11,959 --> 00:10:13,579
The Smart Alec is a pupling script

235
00:10:13,580 --> 00:10:17,140
which is using frida internally

236
00:10:17,140 --> 00:10:20,480
and it gives a set of
functionality that we can use

237
00:10:20,480 --> 00:10:22,890
which is essentially the
same set of the steps

238
00:10:22,890 --> 00:10:25,689
that we just saw insights before.

239
00:10:25,690 --> 00:10:29,290
So also they need to use 3.7
biting version to run this

240
00:10:29,290 --> 00:10:31,459
because of the compatibility with frida

241
00:10:32,650 --> 00:10:34,310
Now you'll see that we have different set

242
00:10:34,310 --> 00:10:38,050
of arguments here which is
capturing the state compared

243
00:10:38,050 --> 00:10:40,803
to state dump the process and so on.

244
00:10:43,360 --> 00:10:46,980
So now I'll be using the
capture argument of the tool

245
00:10:46,980 --> 00:10:48,787
to capture all, I mean, all the processes

246
00:10:48,787 --> 00:10:52,460
which are running in
this emulator right now,

247
00:10:52,460 --> 00:10:55,420
and I'll put all of the
results in three Rootkit

248
00:10:55,420 --> 00:10:56,430
which is a folder,

249
00:10:56,430 --> 00:10:58,310
so let's see what happens.

250
00:10:58,310 --> 00:11:00,880
You'll see that it starts
enumerating all the modules

251
00:11:00,880 --> 00:11:02,390
and different processes.

252
00:11:02,390 --> 00:11:05,060
And if folder is created,
which is three Rootkit,

253
00:11:05,060 --> 00:11:07,410
and you can see that in the processes

254
00:11:07,410 --> 00:11:08,860
it will enlist all the processes

255
00:11:08,860 --> 00:11:10,808
which are running along with the PID

256
00:11:10,808 --> 00:11:13,050
and in order, what is the
process, which is running

257
00:11:13,050 --> 00:11:17,120
and modules you can see, I
spell like for every process

258
00:11:17,120 --> 00:11:20,060
we'll have all the modules
which are being loaded,

259
00:11:20,060 --> 00:11:22,680
so if you go and open one of them

260
00:11:22,680 --> 00:11:26,060
you'll see that we have
things like the base address

261
00:11:26,060 --> 00:11:28,457
or the size and the
prediction levels of the files

262
00:11:28,457 --> 00:11:30,560
for this here, just doing the,

263
00:11:30,560 --> 00:11:33,290
our expectation level of
files but you can configure it

264
00:11:33,290 --> 00:11:35,620
to load all the different kind of modules.

265
00:11:38,370 --> 00:11:41,700
So this will run it will
emulate all the processes,

266
00:11:41,700 --> 00:11:45,670
you can see audio server
Bold, the RM server,

267
00:11:45,670 --> 00:11:47,810
these are all the different
processes, which keep running

268
00:11:47,810 --> 00:11:51,260
on your Android device
whenever it's functional.

269
00:11:51,260 --> 00:11:53,393
So once we have done that,

270
00:11:54,320 --> 00:11:57,050
let's move to the infection part of it,

271
00:11:57,050 --> 00:11:59,469
so now what we will try to do is in fact

272
00:11:59,470 --> 00:12:00,623
so run basically the shell file

273
00:12:00,623 --> 00:12:02,630
that we just saw rooting for you

274
00:12:04,300 --> 00:12:08,109
we'll go to the location
where that file is pushed

275
00:12:09,050 --> 00:12:11,020
and we'll run the file.

276
00:12:11,020 --> 00:12:14,699
So now all of these hooks have been set,

277
00:12:14,700 --> 00:12:16,260
now since it is LDP load

278
00:12:16,260 --> 00:12:18,340
we would need to run the processes again

279
00:12:18,340 --> 00:12:20,550
so that it gets loaded into the memory,

280
00:12:20,550 --> 00:12:22,420
so that is something which
is expected to happen

281
00:12:22,420 --> 00:12:26,370
when infection will
execute on the emulator

282
00:12:26,370 --> 00:12:28,090
or on user end.

283
00:12:28,090 --> 00:12:29,820
So we'll open up settings,

284
00:12:29,820 --> 00:12:32,070
we'll open up calendar,
we'll open up email

285
00:12:32,070 --> 00:12:35,133
which are the three apps
that we set up the hooks for,

286
00:12:36,230 --> 00:12:38,330
and I don't want to see how that all this,

287
00:12:39,390 --> 00:12:41,970
we believe that the infection
has been done properly

288
00:12:41,970 --> 00:12:45,160
on the device and now we'll
go and capture the state

289
00:12:45,160 --> 00:12:49,300
of the device now which is
the post-rootkit part, right,

290
00:12:49,300 --> 00:12:51,219
so let's go back to Smart Alec

291
00:12:51,220 --> 00:12:53,853
and run capture all our post-root kit.

292
00:12:59,660 --> 00:13:01,490
So you'll do the same thing again

293
00:13:02,410 --> 00:13:04,780
enumerate all the processes
which are open up now

294
00:13:04,780 --> 00:13:08,050
and all the modules that have
been loading in this process,

295
00:13:08,050 --> 00:13:10,900
so you can see that again,
same kind of files are created

296
00:13:12,386 --> 00:13:13,913
and all of them will be having
the same kind of features

297
00:13:13,913 --> 00:13:15,730
that we just saw

298
00:13:15,730 --> 00:13:17,550
which is essentially all
the different modules

299
00:13:17,550 --> 00:13:20,530
and their base addresses,
their size, protection levels

300
00:13:20,530 --> 00:13:25,353
and file bath, the bathroom
where they are loaded and so on.

301
00:13:30,047 --> 00:13:31,890
So you can see that if any
of the process got created

302
00:13:31,890 --> 00:13:33,766
because of the infection,
we'll be able to see it here

303
00:13:33,767 --> 00:13:35,040
and if any module got used,

304
00:13:35,040 --> 00:13:37,730
it will be somewhere in the files, right,

305
00:13:37,730 --> 00:13:39,046
because we are capturing

306
00:13:39,046 --> 00:13:42,046
and we are animating all the
modules which have been loaded.

307
00:13:44,340 --> 00:13:46,130
So once this is done

308
00:13:46,130 --> 00:13:49,573
let's move to the step three
offer analysis approach,

309
00:13:51,940 --> 00:13:54,550
Which is essentially comparing.

310
00:13:54,550 --> 00:13:57,055
So you will see that we have pre-rootkit

311
00:13:57,055 --> 00:13:58,479
and we have post-rootkit,
the two folders here

312
00:13:58,480 --> 00:14:01,690
we captured that states before
and after the infection.

313
00:14:01,690 --> 00:14:04,670
So now let's go ahead
and compare these two,

314
00:14:04,670 --> 00:14:08,423
we will do this using a
Smart Aleck compare argument.

315
00:14:11,440 --> 00:14:15,057
So we give the pre-rootkit folder

316
00:14:15,057 --> 00:14:17,620
and post-rootkit in that
order before and after

317
00:14:17,620 --> 00:14:20,740
and we'll ask for comparison analysis

318
00:14:20,740 --> 00:14:23,083
and the tool will
generate a report for you,

319
00:14:24,100 --> 00:14:27,483
you can see on the left side,
the report has appeared,

320
00:14:28,730 --> 00:14:31,030
and what this does is basically tell you

321
00:14:31,030 --> 00:14:32,810
if any process has been killed

322
00:14:32,810 --> 00:14:37,449
or spawned during this state change

323
00:14:37,450 --> 00:14:40,320
and if any module in
any of those processes

324
00:14:40,320 --> 00:14:42,970
has appealed or deleted or modified

325
00:14:44,170 --> 00:14:46,410
then you'll do this that
for all of the processes,

326
00:14:46,410 --> 00:14:48,439
you'll see most of the
processes are showing nothing

327
00:14:48,440 --> 00:14:49,870
because they are not affected.

328
00:14:49,870 --> 00:14:50,963
But look at this one,

329
00:14:52,090 --> 00:14:53,980
now here we're warning
that it has been loaded

330
00:14:53,980 --> 00:14:56,110
from data partition and if we look at it,

331
00:14:56,110 --> 00:14:58,100
it's the thecom.android.email,

332
00:14:58,100 --> 00:15:01,300
one of the apps we infected.

333
00:15:01,300 --> 00:15:03,640
So the modules appealed is to one,

334
00:15:03,640 --> 00:15:04,640
nothing has been deleted

335
00:15:04,640 --> 00:15:07,160
or modified, but we saw
a new module appearing

336
00:15:07,160 --> 00:15:09,719
which has been loaded
from the data partition.

337
00:15:09,720 --> 00:15:11,687
Now this is open for
us because in Android,

338
00:15:11,687 --> 00:15:13,660
you don't see things being loaded

339
00:15:13,660 --> 00:15:15,100
from data partition, right,

340
00:15:15,100 --> 00:15:17,000
so if this is not different data partition

341
00:15:17,000 --> 00:15:19,587
and that is what we are
highlighting in the report here.

342
00:15:19,587 --> 00:15:22,760
That hey ,these three
modules which are loaded.

343
00:15:22,760 --> 00:15:23,640
Now what do we want to do?

344
00:15:23,640 --> 00:15:26,210
We see that, okay, there
are modules which are loaded

345
00:15:26,210 --> 00:15:27,900
and now I want to study that,

346
00:15:27,900 --> 00:15:29,660
I want to see what is the exact module

347
00:15:29,660 --> 00:15:31,430
so that I can reverse engineer it

348
00:15:31,430 --> 00:15:33,000
and that is where

349
00:15:33,000 --> 00:15:36,900
the final step of the analysis comes

350
00:15:36,900 --> 00:15:41,492
which is essentially dumping,
dumping the self-interest.

351
00:15:44,840 --> 00:15:46,520
So we use this Smart Alec again

352
00:15:46,520 --> 00:15:49,723
and this time we'll use the argument B.

353
00:15:50,780 --> 00:15:52,360
Now we'll ask for the process,

354
00:15:52,360 --> 00:15:54,130
from which you want to
dump the module four

355
00:15:54,130 --> 00:15:56,890
and he pointed out to be one
of the infective processes

356
00:15:56,890 --> 00:15:59,340
which is combat and royal settings here,

357
00:15:59,340 --> 00:16:01,930
we point out the module, which
is the name of the binary,

358
00:16:01,930 --> 00:16:04,780
which we saw got loaded, which is lipo.sl

359
00:16:05,810 --> 00:16:07,589
and then we asked to output it.

360
00:16:07,590 --> 00:16:10,350
and you'll see that on the
left side, we saw combat

361
00:16:10,350 --> 00:16:12,890
enroll dot settings lipo dot SOP down

362
00:16:14,440 --> 00:16:17,430
and now let's go and
read despite this file.

363
00:16:17,430 --> 00:16:18,819
Let's see what is in this.

364
00:16:21,450 --> 00:16:23,500
So you go to the annoying pool kit

365
00:16:23,500 --> 00:16:26,000
So this is the sort of
pool kit which comes along

366
00:16:26,000 --> 00:16:28,170
with the Android SDK

367
00:16:28,170 --> 00:16:30,203
and you can use this to perform the,

368
00:16:30,203 --> 00:16:31,449
a lot of different interesting things

369
00:16:31,450 --> 00:16:34,800
we'll be using it to
just reading this file,

370
00:16:34,800 --> 00:16:38,416
So we'll use S66-64 Linux in the values

371
00:16:41,730 --> 00:16:45,390
So let's just go to the
directory and run that file

372
00:16:47,053 --> 00:16:49,480
run then read a fun, the
thing that we just loaded

373
00:16:49,480 --> 00:16:52,200
which is live.hook.so

374
00:16:55,410 --> 00:16:56,973
So when we run this,

375
00:17:00,620 --> 00:17:02,803
this is like the typical Linux command.

376
00:17:05,099 --> 00:17:08,819
When we run this on the dot
SDX we dumped from the memory

377
00:17:08,819 --> 00:17:12,980
you will see things which you
kind of would be expecting,

378
00:17:12,980 --> 00:17:16,829
So it will give you the typical header

379
00:17:17,790 --> 00:17:19,819
the information about the Ls

380
00:17:19,819 --> 00:17:21,960
and then, so this ideally tells you

381
00:17:21,960 --> 00:17:24,530
that's the state of the
file, what kind of file it is

382
00:17:24,530 --> 00:17:28,057
and then you can take this
file and put it in binary,

383
00:17:28,057 --> 00:17:28,890
MGL, cutter

384
00:17:28,890 --> 00:17:31,360
or whatever it is your
favorite tool of interest and

385
00:17:31,360 --> 00:17:32,973
reverse engineer it and know more about

386
00:17:32,973 --> 00:17:35,300
what is this SL trying to do

387
00:17:35,300 --> 00:17:38,570
and what kind of corruption
is it causing on the emulator.

388
00:17:38,570 --> 00:17:40,169
So that is about Smart Alec

389
00:17:40,170 --> 00:17:42,673
and that is a demo that we just saw.

390
00:17:48,090 --> 00:17:51,800
So essentially if you can do any thing

391
00:17:51,800 --> 00:17:54,190
which have been made now,
there is an argument that

392
00:17:54,190 --> 00:17:57,200
what if there's no typical new .so file,

393
00:17:57,200 --> 00:17:59,400
which is loaded, but something is patched,

394
00:17:59,400 --> 00:18:01,930
So Smart Alec will identify
the popular shared modules

395
00:18:01,930 --> 00:18:04,507
So the idea is dump the
so files before and after,

396
00:18:04,507 --> 00:18:06,040
and then compare, right?

397
00:18:06,040 --> 00:18:07,770
Because they will be changed in size

398
00:18:07,770 --> 00:18:10,570
and once you have done the
things you can easily compare

399
00:18:11,770 --> 00:18:13,980
so that is the idea and
make it even more smarter

400
00:18:13,980 --> 00:18:15,810
So you have open sources project

401
00:18:15,810 --> 00:18:18,230
and it's present on the github paper,

402
00:18:18,230 --> 00:18:19,063
the link is there

403
00:18:19,063 --> 00:18:20,460
you can go ahead to each board

404
00:18:20,460 --> 00:18:22,110
and use it for your own benefit.

405
00:18:22,110 --> 00:18:24,979
So that's all and let's
move to the other part

406
00:18:24,980 --> 00:18:28,610
of the presentation now,
which is Kernelland analysis.

407
00:18:28,610 --> 00:18:30,409
So over to you Dinesh

408
00:18:30,410 --> 00:18:35,130
- So now that we have
discussed how to analyze some

409
00:18:35,130 --> 00:18:39,210
of the rootkits from the
Userland, it's time to switch

410
00:18:39,210 --> 00:18:44,210
to the Kernelland, like how
to perform a rootkit analysis

411
00:18:44,340 --> 00:18:45,597
from Kernelland

412
00:18:47,160 --> 00:18:50,140
which can handle Userland rootkits

413
00:18:50,140 --> 00:18:52,293
as well as Kernelland rootkits.

414
00:18:53,250 --> 00:18:55,650
So, as I have

415
00:18:57,020 --> 00:18:59,540
outlined in the intro slides.

416
00:18:59,540 --> 00:19:01,879
We will be approaching this task

417
00:19:01,880 --> 00:19:04,870
from memory forum 6 perspective.

418
00:19:04,870 --> 00:19:06,860
So one of the common tasks

419
00:19:06,860 --> 00:19:09,689
or some of the common tasks
that is, that are associated

420
00:19:09,690 --> 00:19:14,240
with memory forum 6 is
acquire, prepare, and analyze.

421
00:19:14,240 --> 00:19:17,250
So that in the acquisition phase,

422
00:19:17,250 --> 00:19:20,150
we have to find a sound way

423
00:19:20,150 --> 00:19:23,600
to perform live memory acquisition,

424
00:19:23,600 --> 00:19:27,669
that is dumping the content
of the RAM of the device

425
00:19:27,670 --> 00:19:29,970
which we are going to
perform the analysis on.

426
00:19:31,600 --> 00:19:35,280
So this process has been a
very mature process so far

427
00:19:35,280 --> 00:19:38,920
because memory forum 6 itself
has been a mature field

428
00:19:38,920 --> 00:19:43,230
and we use some of the
predominant open source software,

429
00:19:43,230 --> 00:19:45,580
as a test line and volatility

430
00:19:45,580 --> 00:19:48,980
as the main tools to
perform this analysis.

431
00:19:48,980 --> 00:19:51,720
So there are a few unique
steps when it comes

432
00:19:51,720 --> 00:19:53,950
to Android memory acquisition

433
00:19:53,950 --> 00:19:58,550
because of the platform
specific constraints

434
00:19:58,550 --> 00:20:00,100
that is associated with Android

435
00:20:01,270 --> 00:20:03,980
when it comes to performing
memory forensics.

436
00:20:03,980 --> 00:20:07,600
So we need to rebuild the
kernel with LKM support

437
00:20:07,600 --> 00:20:09,800
that is loadable kernel module support

438
00:20:09,800 --> 00:20:12,850
so that the line model can
be loaded in the device

439
00:20:12,850 --> 00:20:15,899
and we also need to cross
compile the LiME kernel

440
00:20:15,900 --> 00:20:18,410
with the kernel source or of the Android

441
00:20:18,410 --> 00:20:21,820
of the target device and
we need to disable SELinux

442
00:20:21,820 --> 00:20:23,389
and then we need to load the LiME

443
00:20:23,390 --> 00:20:25,710
and then stream the RAM
and go over the socket

444
00:20:25,710 --> 00:20:28,700
which can be consumed in our host system.

445
00:20:28,700 --> 00:20:30,560
So once the memory is acquired,

446
00:20:30,560 --> 00:20:32,550
it is time to prepare the profile

447
00:20:32,550 --> 00:20:34,419
for the particular memory dump

448
00:20:34,420 --> 00:20:38,250
so that the volatility framework
can understand parsing it

449
00:20:38,250 --> 00:20:40,530
and apply various plugins on it.

450
00:20:40,530 --> 00:20:41,879
So in order to do that,

451
00:20:41,880 --> 00:20:44,020
that is a very very
well documented process

452
00:20:44,020 --> 00:20:49,020
in the github page of
the Android volatility,

453
00:20:50,227 --> 00:20:54,490
the only detail is like a
human need to get the some

454
00:20:54,490 --> 00:20:57,550
of the artifacts which are
generated from the step one

455
00:20:57,550 --> 00:20:59,909
as part of compilation of your kernel,

456
00:20:59,910 --> 00:21:02,120
so once you do that
you will have a profile

457
00:21:02,120 --> 00:21:04,419
which can be used by the volatility.

458
00:21:04,420 --> 00:21:08,990
So now you have acquired memory,

459
00:21:08,990 --> 00:21:11,030
you have created a profile

460
00:21:11,030 --> 00:21:13,879
it is time to combine both with volatility

461
00:21:13,880 --> 00:21:16,653
and use some of the existing Linux plugin,

462
00:21:18,580 --> 00:21:21,870
which comes by default with volatility,

463
00:21:21,870 --> 00:21:24,389
some of the plugins are Linux PS list

464
00:21:24,390 --> 00:21:28,940
PROC maps, dump map,
psenv, psxview and then

465
00:21:29,810 --> 00:21:33,840
what we are proposing and
introducing in this talk is

466
00:21:35,430 --> 00:21:38,250
application of knowledge
graph and the ML plugins

467
00:21:38,250 --> 00:21:40,860
to the existing volatility plugins.

468
00:21:40,860 --> 00:21:44,790
So we basically build on
top of the existing plugins

469
00:21:44,790 --> 00:21:47,360
and add seven features

470
00:21:47,360 --> 00:21:51,620
which persist the context
throughout the analysis,

471
00:21:51,620 --> 00:21:54,273
we will talk more about it
in the subsequent slides.

472
00:21:55,120 --> 00:21:58,080
And these are the things
that we will be covering

473
00:22:00,220 --> 00:22:01,940
in the subsequent slides.

474
00:22:01,940 --> 00:22:04,677
So we will cover both, as I said

475
00:22:05,610 --> 00:22:06,443
userland rootkit analysis

476
00:22:06,443 --> 00:22:09,150
as well as Kernelland rootkit analysis.

477
00:22:09,150 --> 00:22:11,360
So like Aditi has explained

478
00:22:11,360 --> 00:22:14,050
we will see how to use the plugins

479
00:22:14,050 --> 00:22:16,680
to uncover LD preload hooks

480
00:22:16,680 --> 00:22:18,690
and the PTrace based rootkits

481
00:22:19,617 --> 00:22:22,600
and rootkits that work by
hooking the system call

482
00:22:22,600 --> 00:22:25,969
and some of the powerful
rootkits that works

483
00:22:25,970 --> 00:22:29,030
by directly manipulating
the kernel data structure

484
00:22:29,030 --> 00:22:33,190
which is a task counterpart
structure of the Linux system

485
00:22:34,220 --> 00:22:39,140
so data hides processes,
like It'll be explained.

486
00:22:39,140 --> 00:22:42,860
So we are going to do the
same process hiding technique

487
00:22:42,860 --> 00:22:47,469
and the app hiding feature
with five different techniques

488
00:22:47,470 --> 00:22:50,250
LD Preload, Ptrace, SYSCALL hook and DKOM,

489
00:22:50,250 --> 00:22:54,013
and then we will uncover
it using the memory 416.

490
00:22:55,420 --> 00:22:57,490
So let's talk about preload,

491
00:22:57,490 --> 00:23:01,610
Aditi has covered the
internal working of preload

492
00:23:01,610 --> 00:23:03,189
so in the benefit of time

493
00:23:03,190 --> 00:23:06,530
I will directly go to the analysis part,

494
00:23:06,530 --> 00:23:10,670
so in case of analyzing
LD preload rootkits

495
00:23:10,670 --> 00:23:12,520
from the memory forensics perspective

496
00:23:13,660 --> 00:23:17,340
we are going to leverage an
existing plugin that comes

497
00:23:17,340 --> 00:23:19,580
by default with volatility framework

498
00:23:19,580 --> 00:23:22,169
which is the Linux under score, PSENB.

499
00:23:22,170 --> 00:23:24,440
So this particular plugin,

500
00:23:24,440 --> 00:23:26,470
enumerates all the running processes

501
00:23:26,470 --> 00:23:28,970
at the time of acquisition of the memory

502
00:23:28,970 --> 00:23:32,110
and then it would inspect
the environment variables

503
00:23:32,110 --> 00:23:34,500
in the process context, and wherever the

504
00:23:34,500 --> 00:23:36,220
LD preload variable is set,

505
00:23:36,220 --> 00:23:40,140
it would flag data as
for further analysis.

506
00:23:40,140 --> 00:23:43,040
And then we have redone
some automation on top of it

507
00:23:43,040 --> 00:23:46,159
as a work bench graphical user interface

508
00:23:46,160 --> 00:23:49,570
which can automatically
dump the particular module

509
00:23:49,570 --> 00:23:51,460
and then load it in a disassembler

510
00:23:51,460 --> 00:23:54,803
and show the code where the
hook has been established.

511
00:23:55,992 --> 00:23:58,322
In addition to that, as I have said

512
00:23:58,323 --> 00:24:01,300
we are also persisting the context

513
00:24:01,300 --> 00:24:03,669
because when a particular plugin runs,

514
00:24:03,670 --> 00:24:05,850
it is generally the
lifecycle of the plugin

515
00:24:05,850 --> 00:24:07,600
is starting from data analysis

516
00:24:07,600 --> 00:24:10,280
and they end up the analysis
of that particular plugin.

517
00:24:10,280 --> 00:24:13,510
What we are trying to
do across the execution

518
00:24:13,510 --> 00:24:17,310
of different plugins is that
we gather the intelligence,

519
00:24:17,310 --> 00:24:19,530
We gather all the data points

520
00:24:19,530 --> 00:24:21,980
and then store them in knowledge graph

521
00:24:21,980 --> 00:24:24,060
as and when the plugin is executes.

522
00:24:24,060 --> 00:24:26,909
So while a plugin is
running in the front end,

523
00:24:26,910 --> 00:24:29,410
in the backend we populate a graph

524
00:24:29,410 --> 00:24:32,260
of all the memory artifacts,
all the memory objects

525
00:24:32,260 --> 00:24:34,343
in the form of NTD relationships,

526
00:24:35,376 --> 00:24:38,960
so that it becomes quite
natural for an analyst

527
00:24:38,960 --> 00:24:40,950
and the analyst can become intuitive

528
00:24:41,900 --> 00:24:45,297
when it comes to analyzing
a particular rootkit

529
00:24:47,210 --> 00:24:49,330
that she is trying to analyze.

530
00:24:49,330 --> 00:24:53,419
So in this case, as you
could see, the LD preload

531
00:24:54,267 --> 00:24:56,810
so file this is the LD preload the so file

532
00:24:56,810 --> 00:25:00,200
we will see an elaborate demo
in the subsequent slides.

533
00:25:00,200 --> 00:25:02,250
So as you could see,
there are three notes,

534
00:25:02,250 --> 00:25:04,510
these three notes are process IDs,

535
00:25:04,510 --> 00:25:07,140
and that this particular preload S4 file

536
00:25:07,140 --> 00:25:09,370
which has a relationship
with all these three file,

537
00:25:09,370 --> 00:25:10,709
all these three notes.

538
00:25:10,710 --> 00:25:14,130
So it is all about asking the
right questions when it comes

539
00:25:14,130 --> 00:25:16,850
to performing RE or RC, right?

540
00:25:16,850 --> 00:25:18,437
So the answers are everywhere,

541
00:25:18,437 --> 00:25:20,320
it is all about asking right questions.

542
00:25:20,320 --> 00:25:23,860
So knowledge graph is,
it's a fundamental method

543
00:25:23,860 --> 00:25:26,949
which can navigate an analyst
to ask the right questions

544
00:25:26,950 --> 00:25:28,840
and narrow down the energy.

545
00:25:28,840 --> 00:25:32,040
So similarly in PTRACE, PTRACE
is again a Userland rootkit,

546
00:25:33,550 --> 00:25:35,570
so how does it work?

547
00:25:35,570 --> 00:25:37,204
It's very well documented,

548
00:25:37,204 --> 00:25:42,204
it uses Linux speed risk
call to attach to a process

549
00:25:42,353 --> 00:25:44,081
that it tries to infect

550
00:25:44,081 --> 00:25:47,831
and then PTRACE hook to
overwrite some of the

551
00:25:49,440 --> 00:25:50,273
more modules

552
00:25:50,273 --> 00:25:51,621
that it wants to infect

553
00:25:51,622 --> 00:25:53,953
and then it creates a memory infection.

554
00:25:53,953 --> 00:25:55,410
So when it comes to PTRACE

555
00:25:55,410 --> 00:25:59,600
it is a little bit trickier to flag,

556
00:25:59,600 --> 00:26:02,020
or to identify the infection,

557
00:26:02,020 --> 00:26:05,590
so that is where we are
introducing a very simple plugin,

558
00:26:05,590 --> 00:26:09,340
it is nothing fancy we will
see the fancy plugins later.

559
00:26:09,340 --> 00:26:11,020
So in this case, what we are doing is

560
00:26:11,020 --> 00:26:14,190
we are enumerating all the task structure

561
00:26:14,190 --> 00:26:17,830
and if the task structure
is we are enumerating

562
00:26:17,830 --> 00:26:19,460
through the, all the task structure

563
00:26:19,460 --> 00:26:23,360
and then if the particular flag is set

564
00:26:23,360 --> 00:26:25,550
when it comes to Linux PTRACE,

565
00:26:25,550 --> 00:26:28,040
So when a process decides
to put PTRACE on it,

566
00:26:28,040 --> 00:26:32,520
so we will have this particular
field PTRACE set to one,

567
00:26:32,520 --> 00:26:34,850
so if the PTRACE value is set to one

568
00:26:34,850 --> 00:26:37,570
we are simply adding
the particular process

569
00:26:37,570 --> 00:26:41,679
as a infected process and then
the parent of the processes

570
00:26:41,680 --> 00:26:43,990
that actually infect them
because fundamentally

571
00:26:43,990 --> 00:26:46,890
when a particular process
is opening a PTRACE call

572
00:26:46,890 --> 00:26:49,060
to the other process it becomes the parent

573
00:26:49,060 --> 00:26:51,510
of the process at that moment, right?

574
00:26:51,510 --> 00:26:54,840
So we are using that logic
and creating a table.

575
00:26:54,840 --> 00:26:56,189
So as you could see here

576
00:26:57,390 --> 00:27:01,390
this particular application
presser has put a hook

577
00:27:01,390 --> 00:27:04,150
on these three applications,
which are running.

578
00:27:04,150 --> 00:27:06,530
So the very interesting point is,

579
00:27:06,530 --> 00:27:10,530
most of the practical rootkits,
they don't use Ptrace LiME,

580
00:27:10,530 --> 00:27:12,520
they just, they're quickly attached to it

581
00:27:12,520 --> 00:27:15,700
and then inject F4 file,
and then they detach it.

582
00:27:15,700 --> 00:27:18,660
So this particular
technique will not be useful

583
00:27:18,660 --> 00:27:21,140
when it comes to the actual rootkits.

584
00:27:21,140 --> 00:27:23,120
So that is where there is another plugin,

585
00:27:23,120 --> 00:27:23,953
which we have written.

586
00:27:23,953 --> 00:27:27,160
The next Ptrace all
which basically leverages

587
00:27:27,160 --> 00:27:28,620
this kernel tainting,

588
00:27:28,620 --> 00:27:31,070
so whenever somebody tries a Ptrace call

589
00:27:31,070 --> 00:27:33,860
we are emitting a taint
message from the kernel,

590
00:27:33,860 --> 00:27:38,860
we're capturing it in the D message demo

591
00:27:39,210 --> 00:27:41,750
and then we are displaying
all the historic information

592
00:27:41,750 --> 00:27:44,490
of Ptrace calls over a period of time.

593
00:27:44,490 --> 00:27:46,300
So similarly SYScall table hook,

594
00:27:46,300 --> 00:27:49,590
it is all about getting the
system table start address

595
00:27:49,590 --> 00:27:53,709
and then modifying an
entry to find to a function

596
00:27:53,710 --> 00:27:55,420
which is present in kernel objects,

597
00:27:55,420 --> 00:27:57,580
so this is where the
kernel module rootkit comes

598
00:27:57,580 --> 00:28:00,199
into the picture where root
it's that not only written

599
00:28:00,200 --> 00:28:01,700
as an application, but they are written

600
00:28:01,700 --> 00:28:04,590
as a notable tunnel modules themselves.

601
00:28:04,590 --> 00:28:07,360
So they basically modify
as a SYScall table

602
00:28:07,360 --> 00:28:10,649
and it puts a hook on open assistant call

603
00:28:10,650 --> 00:28:15,270
and every time a particular
application file is being open,

604
00:28:15,270 --> 00:28:17,940
instead of passing the original file

605
00:28:17,940 --> 00:28:21,420
it will pass a different
file so that it gets hidden.

606
00:28:21,420 --> 00:28:25,570
So we will see a very
quick demo of SysCall hook

607
00:28:25,570 --> 00:28:29,290
and then we will see what
plugin we use in volatility.

608
00:28:32,689 --> 00:28:36,451
So we use this Linux_check_SysCall plugin,

609
00:28:36,451 --> 00:28:38,160
which basically enumerates

610
00:28:38,160 --> 00:28:40,849
the system called table
and finds the hook,

611
00:28:40,849 --> 00:28:44,599
and now we will see all
the demos one by one.

612
00:28:52,857 --> 00:28:55,730
(clears throat)

613
00:28:55,730 --> 00:28:59,033
So in the interest of time,
I will be splitting up the,

614
00:29:02,900 --> 00:29:06,890
yeah, so you could see now
this particular nor data

615
00:29:06,890 --> 00:29:09,300
local, temporary load .so,

616
00:29:09,300 --> 00:29:12,780
so when you plot in the graph,

617
00:29:12,780 --> 00:29:16,183
so you will be able to
expand each and every node

618
00:29:16,183 --> 00:29:19,293
to see the relationship
among all these nodes,

619
00:29:20,620 --> 00:29:25,239
which can intuitively help an analyst

620
00:29:25,240 --> 00:29:28,700
to point to a direction how
the infection has happened,

621
00:29:28,700 --> 00:29:30,890
who was responsible for the infection,

622
00:29:30,890 --> 00:29:32,177
what were the pre infection scenarios

623
00:29:32,177 --> 00:29:35,493
and what are the post-infection effects.

624
00:29:36,560 --> 00:29:40,100
So now we will see how this
particular thing was populated,

625
00:29:40,100 --> 00:29:43,129
so we are just automated
the infection process,

626
00:29:43,130 --> 00:29:45,330
as well as the analysis process,

627
00:29:45,330 --> 00:29:47,610
so in the infection
process, now you can see

628
00:29:50,510 --> 00:29:52,600
all the activities that we have mentioned

629
00:29:52,600 --> 00:29:55,270
so it automatically tries
to play up the memdump,

630
00:29:55,270 --> 00:29:57,160
any previous memdump.

631
00:29:57,160 --> 00:29:58,590
It inserts the payload,

632
00:29:58,590 --> 00:30:00,040
it sets the LD preload hook

633
00:30:00,040 --> 00:30:02,490
which Aditi has done in her script

634
00:30:02,490 --> 00:30:05,040
and one support for writing a set

635
00:30:05,040 --> 00:30:08,003
it streams the content of
the RAM, and we consume it

636
00:30:08,003 --> 00:30:11,649
over a network socket and
persist in the local disk.

637
00:30:11,650 --> 00:30:15,290
So as you could see at the
stage the Chrome application

638
00:30:15,290 --> 00:30:18,379
has been hidden which
you can see previously,

639
00:30:18,380 --> 00:30:20,140
which was that in the listing.

640
00:30:20,140 --> 00:30:25,140
So now we'll run the
Linux_PS list command,

641
00:30:28,100 --> 00:30:30,510
and then we will also see

642
00:30:30,510 --> 00:30:33,460
how the particular graph is populated.

643
00:30:33,460 --> 00:30:36,603
So now we have noted that
Android settings PAD7028,

644
00:30:38,950 --> 00:30:42,190
and we are running the
particular 7028 node

645
00:30:42,190 --> 00:30:45,607
with the new plugin Linux_proc_maps_kg,

646
00:30:47,430 --> 00:30:48,753
as you could see here.

647
00:30:51,540 --> 00:30:54,203
So now as this particular plugin runs,

648
00:30:55,940 --> 00:30:57,863
you'll be able to see that the database

649
00:30:57,863 --> 00:31:01,063
at this stage has no values, it is empty.

650
00:31:07,960 --> 00:31:10,660
So you could see there are
no nodes or edges right now

651
00:31:11,553 --> 00:31:13,580
there are no labels in the database.

652
00:31:13,580 --> 00:31:16,810
So now when this particular
volatility plugin is running,

653
00:31:18,957 --> 00:31:22,707
it will do its normal functionality as is.

654
00:31:22,707 --> 00:31:27,707
At the same time, we also
input PI2 new library,

655
00:31:28,150 --> 00:31:31,650
which is basically a Python
library that can communicate

656
00:31:31,650 --> 00:31:34,130
with a new for the graph database

657
00:31:34,130 --> 00:31:36,600
and we persist all the information

658
00:31:36,600 --> 00:31:40,929
in the form of a graph
with the nodes and edges.

659
00:31:40,930 --> 00:31:43,580
As you could see now we have
emitted a simple message

660
00:31:43,580 --> 00:31:46,449
loaded new and now we could go back

661
00:31:46,450 --> 00:31:47,730
to your graph database

662
00:31:47,730 --> 00:31:51,490
and see the edges labels populated now,

663
00:31:51,490 --> 00:31:54,890
so currently 625 nodes are populated.

664
00:31:54,890 --> 00:31:57,300
So from this point onwards,

665
00:31:57,300 --> 00:32:00,580
you will be able to carry all
the PADs which were running

666
00:32:00,580 --> 00:32:02,389
at the time of acquisition,

667
00:32:02,390 --> 00:32:04,313
you can pick one particular PAD

668
00:32:04,313 --> 00:32:06,460
or you can pick one particular file

669
00:32:06,460 --> 00:32:08,850
and you can continue your analysis

670
00:32:08,850 --> 00:32:10,760
in the most intuitive way.

671
00:32:10,760 --> 00:32:13,717
And this is only for the
demonstration purpose, right?

672
00:32:13,717 --> 00:32:15,350
In a real time environment,

673
00:32:15,350 --> 00:32:18,550
all these things will happen
as a command line utility,

674
00:32:18,550 --> 00:32:23,550
so visualization is great for
analysis, but for automation

675
00:32:24,430 --> 00:32:27,040
the framework also supports automatically

676
00:32:27,040 --> 00:32:28,500
performing all these tasks,

677
00:32:28,500 --> 00:32:31,233
instead of we double
clicking each and every node

678
00:32:31,233 --> 00:32:33,860
we will be able to do
the community detection

679
00:32:33,860 --> 00:32:36,360
and all the graph data sends libraries

680
00:32:36,360 --> 00:32:38,979
to automatically infer intelligence,

681
00:32:38,980 --> 00:32:43,530
So that's the advantage
of a knowledge graph

682
00:32:43,530 --> 00:32:47,010
and representing and combining
your ML and knowledge graph

683
00:32:47,010 --> 00:32:48,683
in memory forensics framework.

684
00:32:49,640 --> 00:32:52,980
And as I have said,
some of the unique steps

685
00:32:52,980 --> 00:32:56,440
of just ignoring the many
forensics, preparing your kernel

686
00:32:56,440 --> 00:32:57,933
and then combining it to,

687
00:32:59,360 --> 00:33:02,370
with all the pre-configured
parameters involved

688
00:33:02,370 --> 00:33:07,219
So we are introducing a
memory forensics workbench

689
00:33:07,220 --> 00:33:09,870
for especially for mobile security.

690
00:33:09,870 --> 00:33:14,199
And we could see most of the
tasks can be automated here

691
00:33:15,150 --> 00:33:17,990
so you can build the kernel that you want,

692
00:33:17,990 --> 00:33:22,180
so in this case, I'm
choosing X86 64 architecture

693
00:33:22,180 --> 00:33:24,820
with LKM support with K-prop support

694
00:33:24,820 --> 00:33:26,530
and I don't want verified boot,

695
00:33:26,530 --> 00:33:28,860
so once you submit it.

696
00:33:28,860 --> 00:33:31,179
It will pull the goldfish
kernel in this case

697
00:33:31,180 --> 00:33:33,020
because it is goldfish
kernel for other devices

698
00:33:33,020 --> 00:33:35,670
it will be the respective kernel branch

699
00:33:35,670 --> 00:33:37,796
and then it will do the pre configuration

700
00:33:37,796 --> 00:33:40,300
and it will build a kernel for you

701
00:33:40,300 --> 00:33:43,340
which can be flashed and into the device

702
00:33:43,340 --> 00:33:46,100
and used for the LiME memory forensics.

703
00:33:46,100 --> 00:33:49,050
So now we could see that
this boot image is ready

704
00:33:49,050 --> 00:33:52,909
or you can run the random emulator

705
00:33:52,910 --> 00:33:55,410
with this newly created kernel image,

706
00:33:55,410 --> 00:33:59,550
and once that is done, you can
use all the functionalities

707
00:33:59,550 --> 00:34:02,520
like Preloading, Ptrace, SysCall, Dkom

708
00:34:02,520 --> 00:34:05,820
and loader model, loader module, proc kg

709
00:34:05,820 --> 00:34:07,500
and you can also submit

710
00:34:07,500 --> 00:34:10,280
the wireless total
convert knowledge graph,

711
00:34:10,280 --> 00:34:11,780
in front knowledge graph.

712
00:34:11,780 --> 00:34:14,639
So everything is automated
in this process so far,

713
00:34:14,639 --> 00:34:16,761
whatever we have discussed.

714
00:34:16,761 --> 00:34:18,090
So in the benefit of time

715
00:34:19,219 --> 00:34:22,522
I'm moving ahead a little bit faster so.

716
00:34:32,179 --> 00:34:34,549
So at this stage, you can see that

717
00:34:36,550 --> 00:34:38,159
we are clinging on the app and for,

718
00:34:38,159 --> 00:34:40,560
and the process, the Chrome

719
00:34:40,560 --> 00:34:44,210
which we want to make to
disappear has disappeared

720
00:34:44,210 --> 00:34:47,710
and we are going to perform
the same functionality

721
00:34:47,710 --> 00:34:49,103
with Ptrace now.

722
00:34:50,880 --> 00:34:55,880
So this LDP load, and now I
click on the Ptrace button,

723
00:34:56,440 --> 00:35:00,950
so now what would happen is it
will perform all the cleanup

724
00:35:00,950 --> 00:35:04,830
and then perform the
Ptrace rootkit injection

725
00:35:04,830 --> 00:35:05,732
into the emulator.

726
00:35:07,816 --> 00:35:09,709
So this is essentially a frida script

727
00:35:09,710 --> 00:35:12,360
because frida works based on Ptrace,

728
00:35:12,360 --> 00:35:14,700
so now I'm clearing the
cache of the target app

729
00:35:14,700 --> 00:35:16,852
so that any previous effects are erased,

730
00:35:18,860 --> 00:35:21,199
so I run so many other
applications as well

731
00:35:21,199 --> 00:35:22,220
in order to demonstrate

732
00:35:22,220 --> 00:35:26,450
that this app is not only
putting a hook on one process,

733
00:35:26,450 --> 00:35:28,810
in fact, more than one process.

734
00:35:28,810 --> 00:35:31,330
So now we should be able to see that,

735
00:35:31,330 --> 00:35:34,350
the processes then at
the opposite and again

736
00:35:34,350 --> 00:35:39,350
and each and every time it
will generate a LiME file.

737
00:35:40,799 --> 00:35:42,580
The LiME file is basically
the content of the RAM,

738
00:35:42,580 --> 00:35:44,040
which is two GB in this case

739
00:35:44,040 --> 00:35:47,140
because the simulator has two GB of RAM.

740
00:35:47,140 --> 00:35:48,859
So when it comes to SysCall hook,

741
00:35:48,860 --> 00:35:51,950
it basically hides a particular PAD

742
00:35:51,950 --> 00:35:56,950
by manipulating the system
called Table-on system call,

743
00:35:57,020 --> 00:36:00,353
So again, you will be
able to see that the app

744
00:36:00,353 --> 00:36:05,100
and it was hidden and you
will have a LiME dump as well

745
00:36:05,100 --> 00:36:06,970
at the end of the stage.

746
00:36:06,970 --> 00:36:10,602
So similarly for Dkom,

747
00:36:11,630 --> 00:36:13,530
you will be able to see that

748
00:36:13,530 --> 00:36:15,420
once the rootkit module is loaded

749
00:36:15,420 --> 00:36:18,770
using the LS in smart command.

750
00:36:18,770 --> 00:36:22,259
The PAD of the
android.com.android.settings

751
00:36:22,260 --> 00:36:26,863
is hidden from any processing
simulation commands.

752
00:36:29,410 --> 00:36:32,609
So now we can see that we
are pushing the Dkom payload,

753
00:36:32,610 --> 00:36:34,363
which is essentially an LKM module,

754
00:36:35,360 --> 00:36:38,040
which manipulates the
kernel data structures

755
00:36:38,040 --> 00:36:43,040
to D link process that
tasks that data structures

756
00:36:43,190 --> 00:36:45,200
from the double link list.

757
00:36:45,200 --> 00:36:47,540
So once that is done, you can see that now

758
00:36:47,540 --> 00:36:50,250
before the rootkit affects 6752,

759
00:36:50,250 --> 00:36:53,310
which is the process idea
of com.android.settings,

760
00:36:53,310 --> 00:36:57,692
but once the rootkit is loaded
that PAD is hidden forever.

761
00:37:01,350 --> 00:37:04,600
So now at this stage you know,

762
00:37:04,600 --> 00:37:08,420
we have created all the
infections and dump the memories

763
00:37:08,420 --> 00:37:10,420
so now we clicked on the analyze button,

764
00:37:11,320 --> 00:37:14,770
so it will load the LiME file,

765
00:37:14,770 --> 00:37:16,869
which is the memory dump of the RAM,

766
00:37:16,869 --> 00:37:18,386
and it will perform the logistics

767
00:37:18,386 --> 00:37:20,590
and then it identifies
this particular process

768
00:37:20,590 --> 00:37:22,460
has some or many infection

769
00:37:22,460 --> 00:37:27,460
and it loads that particular
module, which has been injected

770
00:37:27,910 --> 00:37:32,120
into the memory space in
a fair or disassembler.

771
00:37:32,120 --> 00:37:36,569
And then it can navigate
you to the code block

772
00:37:36,570 --> 00:37:39,783
which is responsible for
the particular infection.

773
00:37:43,310 --> 00:37:46,070
So which happens to be this, right.

774
00:37:46,070 --> 00:37:49,760
So essentially in the interest of time

775
00:37:49,760 --> 00:37:52,080
we have not covered
all the functionalities

776
00:37:52,080 --> 00:37:54,009
of this particular as you could see

777
00:37:54,860 --> 00:37:58,423
this particular what been
has 32 functionalities,

778
00:37:59,310 --> 00:38:01,590
some of them are very mundane tasks,

779
00:38:01,590 --> 00:38:04,230
some of them are complex task,

780
00:38:04,230 --> 00:38:07,700
but the overall goal is
to make it as a complete

781
00:38:07,700 --> 00:38:09,910
into an analysis framework

782
00:38:09,910 --> 00:38:12,325
which combines the power of volatility

783
00:38:12,325 --> 00:38:17,325
with the power of knowledge
graph and other ML plugins

784
00:38:17,850 --> 00:38:22,160
so that we have a
framework which can be used

785
00:38:22,160 --> 00:38:24,267
to gain actionable threat Intel

786
00:38:24,267 --> 00:38:26,180
and explainable mission done.

787
00:38:26,180 --> 00:38:29,990
So this is the key takeaway
of this particular talk,

788
00:38:29,990 --> 00:38:33,399
where you can use some of
the concepts we discussed

789
00:38:33,400 --> 00:38:38,400
in this presentation as a
instrumentation framework

790
00:38:38,990 --> 00:38:42,700
to empower your existing
analysis framework

791
00:38:42,700 --> 00:38:44,669
to create automatic
extraction of information

792
00:38:44,670 --> 00:38:47,840
not only for rootkits, but
also for any other malware.

793
00:38:47,840 --> 00:38:50,120
So we hope this is useful,

794
00:38:50,120 --> 00:38:53,589
we are open for any questions even online

795
00:38:53,590 --> 00:38:56,480
or offline off this presentation,
thank you very much.

