1
00:00:01,230 --> 00:00:02,150
- Hello everyone.

2
00:00:02,150 --> 00:00:04,540
And thank you for joining
me on this session.

3
00:00:04,540 --> 00:00:07,200
Nir Chako here and I'm
excited to share with you

4
00:00:07,200 --> 00:00:09,540
a few insights from a
research we conducted

5
00:00:09,540 --> 00:00:11,299
at CyberArk clubs.

6
00:00:11,300 --> 00:00:14,320
Please feel free to ask
questions in the Q and A chat.

7
00:00:14,320 --> 00:00:16,680
I'll be happy to answer them.

8
00:00:16,680 --> 00:00:19,410
And before we start, I hope
that you have a glass of water

9
00:00:19,410 --> 00:00:20,620
by your side.

10
00:00:20,620 --> 00:00:22,960
And if so, have you ever
wondered how the water

11
00:00:22,960 --> 00:00:24,460
even got there?

12
00:00:24,460 --> 00:00:28,020
I mean, we are used to open
the tap and get a strong flow

13
00:00:28,020 --> 00:00:28,880
of water.

14
00:00:28,880 --> 00:00:32,210
Miraculously water just
passes through pumps and pipes

15
00:00:32,210 --> 00:00:35,770
until it comes out at our
taps and into our glasses.

16
00:00:35,770 --> 00:00:38,120
And of course as long as it works,

17
00:00:38,120 --> 00:00:40,120
we are not interested in plumbing.

18
00:00:40,120 --> 00:00:43,459
As long as water reaches
from one end to another.

19
00:00:43,460 --> 00:00:46,340
This phenomenon is not
different in technology.

20
00:00:46,340 --> 00:00:48,487
There's a known programmer saying,

21
00:00:48,487 --> 00:00:51,160
"If it works, don't touch it."

22
00:00:51,160 --> 00:00:55,120
Well in Kubernetes, as
long as this magic works,

23
00:00:55,120 --> 00:00:58,300
as long as the data passes
from one pod to another,

24
00:00:58,300 --> 00:00:59,672
why would it interest us?

25
00:00:59,673 --> 00:01:00,690
(mouse clicking)

26
00:01:00,690 --> 00:01:02,070
Let me tell you why.

27
00:01:02,070 --> 00:01:05,180
Because when you have less interest

28
00:01:05,180 --> 00:01:07,670
in the darkest spots of technology,

29
00:01:07,670 --> 00:01:10,740
this is where hackers
will find their way in.

30
00:01:10,740 --> 00:01:13,390
And this is where the next
attack will come from.

31
00:01:13,390 --> 00:01:15,630
I can't emphasize that enough.

32
00:01:15,630 --> 00:01:18,360
It's important for you to
know exactly what happens

33
00:01:18,360 --> 00:01:19,950
in your Kubernetes networks.

34
00:01:19,950 --> 00:01:23,520
We are all used to the
traditional structure of networks.

35
00:01:23,520 --> 00:01:27,210
We know that there's routers,
switches and firewall,

36
00:01:27,210 --> 00:01:30,919
all of separate components,
all of them in their boxes

37
00:01:30,920 --> 00:01:35,270
but in that case they all
sit under the same roof.

38
00:01:35,270 --> 00:01:38,160
We all want our Kubernetes
clusters to be as secure

39
00:01:38,160 --> 00:01:39,710
as they can be.

40
00:01:39,710 --> 00:01:42,929
To do so in this session,
we'll dive into Kubernetes

41
00:01:42,930 --> 00:01:45,910
network's architecture so
you could better understand

42
00:01:45,910 --> 00:01:48,140
potential attack vectors.

43
00:01:48,140 --> 00:01:52,420
I'll demonstrate three of
them which include also a CVE

44
00:01:52,420 --> 00:01:57,330
and a security issue, new
security issue in a BGP RFC.

45
00:01:57,330 --> 00:02:00,470
So this way, you know better
what you are up against

46
00:02:00,470 --> 00:02:03,630
so you could keep your assets safe.

47
00:02:03,630 --> 00:02:06,280
The best way to do this
is to get into the head

48
00:02:06,280 --> 00:02:07,560
of the attacker.

49
00:02:07,560 --> 00:02:09,289
Know how we thinks.

50
00:02:09,289 --> 00:02:12,280
Understand what steps will be taken.

51
00:02:12,280 --> 00:02:17,080
Before my role as a team leader
of a security research team,

52
00:02:17,080 --> 00:02:19,370
I was a team leader of a red team.

53
00:02:19,370 --> 00:02:23,000
My job was to be that
sophisticated hacker.

54
00:02:23,000 --> 00:02:26,330
And after researching the
field of network in Kubernetes

55
00:02:26,330 --> 00:02:28,260
I can tell you one thing,

56
00:02:28,260 --> 00:02:30,820
you must change your current perception

57
00:02:30,820 --> 00:02:34,370
you have about networks and
understand that the threat model

58
00:02:34,370 --> 00:02:36,100
is different now.

59
00:02:36,100 --> 00:02:36,933
Let's start.

60
00:02:37,907 --> 00:02:39,420
There are three main building blocks

61
00:02:39,420 --> 00:02:41,010
for Kubernetes networks.

62
00:02:41,010 --> 00:02:44,010
First, we have their network namespaces.

63
00:02:44,010 --> 00:02:46,850
Then, we have their
network devices such as

64
00:02:46,850 --> 00:02:51,170
virtual ethernet, bridges
and overlay devices.

65
00:02:51,170 --> 00:02:54,000
We also have data flow decisions.

66
00:02:54,000 --> 00:02:59,000
It includes iptables,
ARP tables and so on.

67
00:02:59,530 --> 00:03:01,046
Let's have a look at what it looks like.

68
00:03:01,046 --> 00:03:01,950
(mouse clicking)

69
00:03:01,950 --> 00:03:05,540
We're looking at then an
obstruction of a network

70
00:03:05,540 --> 00:03:08,260
in a worker node with three pods.

71
00:03:08,260 --> 00:03:12,019
In that case, you can see that
each pod of it have its own

72
00:03:12,020 --> 00:03:13,730
network namespace.

73
00:03:13,730 --> 00:03:17,739
And that they are all
connected to the same br0,

74
00:03:17,740 --> 00:03:19,240
bridge device.

75
00:03:19,240 --> 00:03:23,230
Now you might ask yourself,
how can one network namespace,

76
00:03:23,230 --> 00:03:25,359
let's say the namespace of pod one

77
00:03:25,360 --> 00:03:27,650
can connect to the root network namespace

78
00:03:27,650 --> 00:03:29,630
where the bridge is at.

79
00:03:29,630 --> 00:03:33,820
So the answer is that we
use virtual ethernet devices

80
00:03:33,820 --> 00:03:38,700
which can connect between two
different network namespaces.

81
00:03:38,700 --> 00:03:41,660
Other than that, there's
the overlay network device

82
00:03:41,660 --> 00:03:43,980
which we'll cover more later on.

83
00:03:43,980 --> 00:03:48,560
And there's the ens33 interface
which is the main interface

84
00:03:48,560 --> 00:03:50,440
of the worker node.

85
00:03:50,440 --> 00:03:53,840
We are left with data flow
decisions, the routing tables

86
00:03:53,840 --> 00:03:57,720
and ARP tables and so on that
are configured by the kernel

87
00:03:57,720 --> 00:04:01,310
or by the network plugin pod.

88
00:04:01,310 --> 00:04:05,630
Now, we have one last player on the field

89
00:04:05,630 --> 00:04:08,500
which is the kube-proxy
here on the left side

90
00:04:08,500 --> 00:04:09,333
of the diagram.

91
00:04:09,333 --> 00:04:10,426
(whooshing sound)

92
00:04:10,426 --> 00:04:13,859
Kube-proxy is not part of
network plugin components.

93
00:04:13,860 --> 00:04:17,060
It's a Kubernetes component
that is responsible mainly

94
00:04:17,060 --> 00:04:20,640
for configuring the iptables'
rules according to services

95
00:04:20,640 --> 00:04:21,959
on the cluster.

96
00:04:21,959 --> 00:04:25,060
Let's say that you own a
microservice with three different

97
00:04:25,060 --> 00:04:27,310
pods called my app.

98
00:04:27,310 --> 00:04:29,910
Each of these pods have its own IP address

99
00:04:29,910 --> 00:04:32,840
and it's not a good practice
to make the client remember

100
00:04:32,840 --> 00:04:34,700
all of this IP addresses.

101
00:04:34,700 --> 00:04:38,060
So what we do instead is
configure one IP address

102
00:04:38,060 --> 00:04:39,690
for the whole service.

103
00:04:39,690 --> 00:04:44,690
So let's say the IP of the
service will be 10.001.

104
00:04:44,740 --> 00:04:48,230
Now when the client wants
to reach his, this service,

105
00:04:48,230 --> 00:04:53,090
he'll just approach 10.001 and
the iptables will translate

106
00:04:53,090 --> 00:04:56,929
this IP address to the IP
address of one of those pods.

107
00:04:56,930 --> 00:04:59,693
It will do a bit of load
balancing on the way.

108
00:05:00,580 --> 00:05:03,289
So that was the last
important building block

109
00:05:03,290 --> 00:05:05,011
of Kubernetes networking.

110
00:05:05,011 --> 00:05:05,844
(mouse clicking)

111
00:05:05,844 --> 00:05:08,770
Now that we speak the same
language, we can continue

112
00:05:08,770 --> 00:05:11,260
and talk about the first
kind of network plugins

113
00:05:11,260 --> 00:05:14,000
which is layer two network plugins.

114
00:05:14,000 --> 00:05:17,690
In this chapter, we'll discuss
attack vectors that utilize

115
00:05:17,690 --> 00:05:19,900
layer two network plugins features.

116
00:05:19,900 --> 00:05:23,880
Specifically, attack scenarios
based on network devices

117
00:05:23,880 --> 00:05:26,600
and overlay network's features.

118
00:05:26,600 --> 00:05:29,580
We'll demonstrate these scenarios
against a popular network

119
00:05:29,580 --> 00:05:31,729
plugin called flannel.

120
00:05:31,730 --> 00:05:34,350
Layer two network plugins
are those who sets,

121
00:05:34,350 --> 00:05:36,280
all of the pods that are on the same node

122
00:05:36,280 --> 00:05:37,940
in the same subnet.

123
00:05:37,940 --> 00:05:41,260
More than that, they'll be
on the same broadcast domain.

124
00:05:41,260 --> 00:05:43,830
That means that all of
the pods on the same node

125
00:05:43,830 --> 00:05:46,719
can send each other layer two frames

126
00:05:46,720 --> 00:05:51,140
and specifically they can send
ARP packets to each other.

127
00:05:51,140 --> 00:05:54,000
That type of architecture
increases the likelihood

128
00:05:54,000 --> 00:05:57,640
of men in the middle attacks
based on app spoofing attacks,

129
00:05:57,640 --> 00:06:00,610
an attack in which an attacker
inject his MAC address

130
00:06:00,610 --> 00:06:03,190
instead of another MAC address.

131
00:06:03,190 --> 00:06:05,990
This can help an attacker
to gain a men in the middle

132
00:06:05,990 --> 00:06:06,823
position.

133
00:06:07,720 --> 00:06:10,630
Now, a known men in the middle position,

134
00:06:10,630 --> 00:06:13,030
a known attack-based men
in the middle position

135
00:06:13,030 --> 00:06:15,690
is DNS spoofing.

136
00:06:15,690 --> 00:06:19,120
DNS spoofing is when a
legitimate DNS session

137
00:06:19,120 --> 00:06:21,410
marked as number one.

138
00:06:21,410 --> 00:06:24,370
A DNS request is sent to the DNS server,

139
00:06:24,370 --> 00:06:27,430
the DNS server then
reply with the IP address

140
00:06:27,430 --> 00:06:30,540
of the requested domain name
and then the client exits

141
00:06:30,540 --> 00:06:32,080
the site.

142
00:06:32,080 --> 00:06:33,740
In the DNS spoofing attack,

143
00:06:33,740 --> 00:06:36,350
an attacker in the men
in the middle position

144
00:06:36,350 --> 00:06:38,750
will capture the victim's DNS request

145
00:06:38,750 --> 00:06:42,160
and will send a fake
DNS reply to the victim.

146
00:06:42,160 --> 00:06:45,690
Now the victim will then
access the fake and malicious

147
00:06:45,690 --> 00:06:50,090
IP address instead of the
legitimate IP address of the site.

148
00:06:50,090 --> 00:06:52,837
Let's see how it might
work on Kubernetes cluster.

149
00:06:52,837 --> 00:06:53,860
(mouse clicking)

150
00:06:53,860 --> 00:06:57,330
First of all, starting with
the app spoofing attack,

151
00:06:57,330 --> 00:07:00,719
an attacker on pod one will
send the forged app reply

152
00:07:00,720 --> 00:07:03,620
to both br0 and pod two.

153
00:07:03,620 --> 00:07:06,410
That will put him as a, in
a men in the middle position

154
00:07:06,410 --> 00:07:09,220
between br0 and pod two.

155
00:07:09,220 --> 00:07:12,370
In that case, we would
expect that the DNS request

156
00:07:12,370 --> 00:07:16,040
would go directly to pod one like that.

157
00:07:16,040 --> 00:07:19,310
Instead, we see that the
DNS request move those,

158
00:07:19,310 --> 00:07:23,700
the host interface out to the DNS service.

159
00:07:23,700 --> 00:07:25,219
Why is that?

160
00:07:25,220 --> 00:07:29,150
Well, do you remember we talked
about Kubernetes services

161
00:07:29,150 --> 00:07:31,010
and iptables rules?

162
00:07:31,010 --> 00:07:34,340
Once the packet was sent from
pod two and passed through

163
00:07:34,340 --> 00:07:39,119
the br0 interface, it walked
into the root network namespace

164
00:07:39,120 --> 00:07:43,730
where we have iptable rules
that changed the destination IP.

165
00:07:43,730 --> 00:07:47,080
In that case, the DNS requests will just

166
00:07:47,080 --> 00:07:51,469
follow through the iptables
and go forward to the DNS pod.

167
00:07:51,470 --> 00:07:54,180
But, don't lose hope.

168
00:07:54,180 --> 00:07:58,290
When the DNS replies come
back, the bridge device thinks

169
00:07:58,290 --> 00:08:00,560
that pod one is pod two.

170
00:08:00,560 --> 00:08:04,590
So the packet goes to
the attacker on pod one.

171
00:08:04,590 --> 00:08:09,109
Then the attacker can change
the content of the DNS reply

172
00:08:09,110 --> 00:08:12,060
and send it back to pod two.

173
00:08:12,060 --> 00:08:15,990
On this case, we should consider
the iptables rules again

174
00:08:15,990 --> 00:08:17,740
in that case as well.

175
00:08:17,740 --> 00:08:20,310
When the forged reply goes
back to the root network

176
00:08:20,310 --> 00:08:23,740
namespace, the DNAT tool will
anticipate the IP address

177
00:08:23,740 --> 00:08:25,380
of the DNS pod.

178
00:08:25,380 --> 00:08:28,210
So it could transport it
back to the IP address

179
00:08:28,210 --> 00:08:30,049
of the DNS service.

180
00:08:30,050 --> 00:08:33,015
Otherwise, the tech won't work.

181
00:08:33,015 --> 00:08:36,110
On my GitHub, you can
find the Kubernetes DNS

182
00:08:36,110 --> 00:08:40,190
spoofing script that
demonstrate this attack vector.

183
00:08:40,190 --> 00:08:41,962
Let's have a look at how it's done.

184
00:08:41,962 --> 00:08:43,016
(mouse clicking)

185
00:08:43,017 --> 00:08:46,460
Okay so, on the left
we have the master node

186
00:08:46,460 --> 00:08:50,640
and on the right we
have an ftp pod which is

187
00:08:50,640 --> 00:08:52,870
part of the ftp service.

188
00:08:52,870 --> 00:08:57,360
The ftp service is using TCP port 8080,

189
00:08:57,360 --> 00:09:01,640
and on this ftp surface
there's a file with the content

190
00:09:01,640 --> 00:09:03,047
FTP Server.

191
00:09:03,980 --> 00:09:07,050
Now let's see, okay we open up the server

192
00:09:08,150 --> 00:09:11,350
and on the top of the screen
right now we can see that

193
00:09:11,350 --> 00:09:13,610
we have the attacker controlled pod

194
00:09:13,610 --> 00:09:15,941
and on the bottom we have app one pod.

195
00:09:15,941 --> 00:09:17,020
(mouse clicking)

196
00:09:17,020 --> 00:09:21,780
If we try to download from
the ftp service the test file

197
00:09:21,780 --> 00:09:25,760
on the app one pod, we can see
that the content of the file

198
00:09:25,760 --> 00:09:28,100
includes the FTP Server texts.

199
00:09:28,100 --> 00:09:31,085
Which means that we download
it really from the FTP Servers.

200
00:09:31,085 --> 00:09:31,960
(mouse clicking)

201
00:09:31,960 --> 00:09:35,150
Now we will start the DNS spoofing attack.

202
00:09:35,150 --> 00:09:38,069
First of all, we need to
know exactly what are the

203
00:09:38,070 --> 00:09:41,770
IP addresses of app one and br0.

204
00:09:41,770 --> 00:09:44,720
In order to do so, we
can look at the ARP table

205
00:09:44,720 --> 00:09:46,860
because we are on the
same broadcast domain

206
00:09:46,860 --> 00:09:49,150
and we get the IPs from them.

207
00:09:49,150 --> 00:09:52,100
We should also know what are
the, what is the IP of the pod

208
00:09:52,100 --> 00:09:57,100
we're currently on, which is 10.244.1.44.

209
00:09:57,891 --> 00:10:00,030
(mouse clicking)

210
00:10:00,030 --> 00:10:03,860
And one last thing you can
see that the test file here

211
00:10:03,860 --> 00:10:08,453
is with the text attacker control
pod, just so we know that.

212
00:10:09,650 --> 00:10:14,453
Now we start the server
on the same TCP port 8080.

213
00:10:18,900 --> 00:10:22,069
And we can start the
attack by using the DNS

214
00:10:22,070 --> 00:10:23,750
spoofing script.

215
00:10:23,750 --> 00:10:28,510
On the target, we enter
the IP address of app one.

216
00:10:28,510 --> 00:10:31,200
The gateway is br0.

217
00:10:31,200 --> 00:10:34,380
The domain name we want to spoof is ftp.

218
00:10:34,380 --> 00:10:39,280
And we entered our IP address
as the spoofed IP address.

219
00:10:39,280 --> 00:10:44,280
Now on app one we'll try
to download this file.

220
00:10:44,780 --> 00:10:49,270
Instead of reaching to the
legitimate ftp, it will reach to

221
00:10:49,270 --> 00:10:50,987
our attacker controlled pod.

222
00:10:50,987 --> 00:10:54,630
And as you can see, the text
said, "Attacker Controlled Pod"

223
00:10:54,630 --> 00:10:56,510
with a small smiley.

224
00:10:56,510 --> 00:11:01,510
So, yeah you might ask yourself,
"That's cool and all but

225
00:11:02,720 --> 00:11:05,160
what can I do to mitigate this risk?"

226
00:11:05,160 --> 00:11:06,380
That's a great question.

227
00:11:06,380 --> 00:11:09,030
So, let's talk about it for a second.

228
00:11:09,030 --> 00:11:12,270
There are two straightforward
ways to mitigate this risk.

229
00:11:12,270 --> 00:11:14,520
The first one would be using a firewall,

230
00:11:14,520 --> 00:11:16,680
in our case iptables.

231
00:11:16,680 --> 00:11:20,010
That will include an allowance
policy in which app one

232
00:11:20,010 --> 00:11:24,800
can only communicate with the
IP of the real ftp service.

233
00:11:24,800 --> 00:11:28,819
A much stronger one would be
to drop the NET_RAW capability

234
00:11:28,820 --> 00:11:31,240
from pod one's configuration.

235
00:11:31,240 --> 00:11:34,850
You can do so by adding
this signs you can see here

236
00:11:34,850 --> 00:11:37,380
to the (mumbles) file of your pods.

237
00:11:37,380 --> 00:11:40,460
If there's no specific need
for a packet manipulation

238
00:11:40,460 --> 00:11:44,670
or usage of ping messages,
there's no reason for a pod

239
00:11:44,670 --> 00:11:47,800
to obtain the default NET_RAW capability.

240
00:11:47,800 --> 00:11:50,646
Doping this capability
will block any attempt

241
00:11:50,647 --> 00:11:54,880
of the attacker to manipulate
the MAC and IP address

242
00:11:54,880 --> 00:11:55,860
of packets.

243
00:11:55,860 --> 00:11:58,570
So the attacker won't be
able to perform the app's

244
00:11:58,570 --> 00:12:01,270
spoofing attack in the first place.

245
00:12:01,270 --> 00:12:03,970
These are two pretty strong techniques.

246
00:12:03,970 --> 00:12:06,453
But, it sounds promising, right?

247
00:12:07,710 --> 00:12:09,700
But wait, there's more.

248
00:12:09,700 --> 00:12:12,170
If you thought these tricks
will make it impossible

249
00:12:12,170 --> 00:12:15,760
for an attacker to spoof his
IP address, you're wrong.

250
00:12:15,760 --> 00:12:17,780
There's another ingredient in the dish.

251
00:12:17,780 --> 00:12:19,449
We haven't talked about it yet.

252
00:12:19,450 --> 00:12:21,403
And this is the overlay network.

253
00:12:22,360 --> 00:12:25,410
An overlay network is an
encapsulation techniques

254
00:12:25,410 --> 00:12:29,060
in which the communication
between pods in the cluster

255
00:12:29,060 --> 00:12:31,949
is encapsulated and from
outside of the node,

256
00:12:31,950 --> 00:12:35,040
it looks like node one is
speaking with node two.

257
00:12:35,040 --> 00:12:40,010
Instead what really happens
is that Pod A from node one

258
00:12:40,010 --> 00:12:43,700
sends a packet to Pod B on node two.

259
00:12:43,700 --> 00:12:47,730
What happens is that the package
from Pod A will go through

260
00:12:47,730 --> 00:12:51,650
the bridge device and
then to the overlay device

261
00:12:51,650 --> 00:12:53,040
where it will be wrapped.

262
00:12:53,040 --> 00:12:56,680
So let's say it will be
wrapped with VXLAN headers,

263
00:12:56,680 --> 00:12:58,339
in the overlay network device.

264
00:12:58,340 --> 00:13:01,370
And it will continue
to the nodes interface

265
00:13:01,370 --> 00:13:04,070
where the original packet is the payload

266
00:13:04,070 --> 00:13:07,480
of the new encapsulated
packet between the nodes.

267
00:13:07,480 --> 00:13:09,460
When the package reaches the second node,

268
00:13:09,460 --> 00:13:12,552
the overlay device there
will unwrap the packet

269
00:13:12,552 --> 00:13:16,530
and will pass the original
packet without VXLAN headers

270
00:13:16,530 --> 00:13:17,733
to Pod B.

271
00:13:18,770 --> 00:13:21,689
This is what an encapsulated VXLAN packet

272
00:13:21,690 --> 00:13:23,930
from Pod A to Pod B looks like.

273
00:13:23,930 --> 00:13:27,810
In the IP headers, we can see
the IP address of the nodes.

274
00:13:27,810 --> 00:13:31,816
Then, there's the VXLAN
headers and the UDP port 8472

275
00:13:33,160 --> 00:13:36,540
which symbol that this
is a VXLAN connection.

276
00:13:36,540 --> 00:13:39,060
Then, there's the MAC
addresses of the overlay,

277
00:13:39,060 --> 00:13:40,739
overlay network device.

278
00:13:40,740 --> 00:13:44,560
And then as the payload,
we can see the IP addresses

279
00:13:44,560 --> 00:13:47,390
of Pod A and Pod B.

280
00:13:47,390 --> 00:13:50,370
If you'd like to see how
VXLAN packets move within

281
00:13:50,370 --> 00:13:53,500
your Kubernetes clusters,
you can use the Lua Script

282
00:13:53,500 --> 00:13:54,950
I wrote for Wireshark.

283
00:13:54,950 --> 00:13:56,980
It's on my GitHub as well.

284
00:13:56,980 --> 00:13:59,022
Just a reminder, we talked about dropping

285
00:13:59,022 --> 00:14:02,090
the NET_RAW capability
from the attacker's pod.

286
00:14:02,090 --> 00:14:05,380
So the attacker won't
be able to manipulate

287
00:14:05,380 --> 00:14:07,410
MAC and IP addresses.

288
00:14:07,410 --> 00:14:10,319
This should have blocked the
attacker's efforts to spoof

289
00:14:10,320 --> 00:14:12,030
any other pod.

290
00:14:12,030 --> 00:14:16,260
Now, we talked about the
original packet being the payload

291
00:14:16,260 --> 00:14:18,439
of the encapsulated packet, right?

292
00:14:18,440 --> 00:14:20,700
So from the attacker's perspective,

293
00:14:20,700 --> 00:14:23,410
he can't change the layer
two, layer three headers

294
00:14:23,410 --> 00:14:26,410
but he can manipulate the packet.

295
00:14:26,410 --> 00:14:29,130
Looking at the structure
of the VXLAN packet,

296
00:14:29,130 --> 00:14:31,439
an attacker can build a crafted payload

297
00:14:31,440 --> 00:14:34,140
that looks like VXLAN in a packet

298
00:14:34,140 --> 00:14:37,449
and open the UDP connection
with the second node

299
00:14:37,450 --> 00:14:40,880
on UDP 8472.

300
00:14:40,880 --> 00:14:44,439
That way the remote overlay
device will think that it got

301
00:14:44,440 --> 00:14:46,060
an encapsulated packet.

302
00:14:46,060 --> 00:14:48,987
The remote device will unwrap the packet.

303
00:14:48,987 --> 00:14:52,500
And the inner packet which
is the attacker controlled

304
00:14:52,500 --> 00:14:56,860
payload will be treated as a
legitimate packet between pods.

305
00:14:56,860 --> 00:14:59,710
In that case, as you
can see in the diagram,

306
00:14:59,710 --> 00:15:04,590
the attacker can change the
values of the source IP, Pod X,

307
00:15:04,590 --> 00:15:07,550
and the destination IP, Pod Y.

308
00:15:07,550 --> 00:15:10,410
And by that, the attacker
can spoof his way out

309
00:15:10,410 --> 00:15:13,360
of the security controls we configured.

310
00:15:13,360 --> 00:15:15,660
Let's talk about specific example.

311
00:15:15,660 --> 00:15:18,290
In that case, we configure the pod without

312
00:15:18,290 --> 00:15:19,770
the NET_RAW capability.

313
00:15:19,770 --> 00:15:22,579
And we added an iptable rule that dictates

314
00:15:22,580 --> 00:15:26,150
that the web server, where
there's a low privilege detector,

315
00:15:26,150 --> 00:15:30,720
can't speak with a DB Server on port 1433.

316
00:15:30,720 --> 00:15:33,992
So we would expect that an
attacker won't be able to send

317
00:15:33,992 --> 00:15:38,390
any packets from the web
server to the DB Server.

318
00:15:38,390 --> 00:15:42,000
He's not supposed to be able
to spoof his IP address.

319
00:15:42,000 --> 00:15:45,730
And there's an iptable rule
that would block any attempt

320
00:15:45,730 --> 00:15:48,600
to communicate with the DB Server.

321
00:15:48,600 --> 00:15:50,890
What can an attacker do in this case?

322
00:15:50,890 --> 00:15:54,620
As we talked, he can craft a VXLAN packet

323
00:15:54,620 --> 00:15:57,740
in a way that would pass
those security controls.

324
00:15:57,740 --> 00:15:58,774
It's demo time.

325
00:15:58,774 --> 00:15:59,607
(mouse clicking)

326
00:15:59,607 --> 00:16:02,970
On the top right, we have the ftp service.

327
00:16:02,970 --> 00:16:05,800
On the bottom right, we have app one.

328
00:16:05,800 --> 00:16:08,329
And on the left, we have the
attacker's controlled pod

329
00:16:08,330 --> 00:16:11,360
with NET_RAW capabilities.

330
00:16:11,360 --> 00:16:13,810
So with the starting point
from the attacker's pod,

331
00:16:13,810 --> 00:16:16,329
we can ping the ftp pod.

332
00:16:16,330 --> 00:16:20,640
Then we set an iptables rules
that block ping messages

333
00:16:20,640 --> 00:16:23,650
from the attacker's pod to the ftp pod.

334
00:16:23,650 --> 00:16:24,483
Let's see.

335
00:16:34,850 --> 00:16:36,483
Now the ping won't work.

336
00:16:44,400 --> 00:16:45,610
Okay here.

337
00:16:45,610 --> 00:16:50,490
Yet an attacker can still
spoof the IP address of app one

338
00:16:50,490 --> 00:16:53,570
and send ping messages to the ftp pod.

339
00:16:53,570 --> 00:16:57,820
We can see the ftp pod
receives the ping request.

340
00:16:57,820 --> 00:17:01,410
And then we'll also see
that the app one pod

341
00:17:01,410 --> 00:17:03,600
receives the ping reply.

342
00:17:03,600 --> 00:17:06,762
Even though it didn't
initiated this session.

343
00:17:08,050 --> 00:17:10,530
Now, let's make things more difficult.

344
00:17:10,530 --> 00:17:13,760
The attacker will be now on the pod

345
00:17:13,760 --> 00:17:16,599
without NET_RAW capabilities.

346
00:17:16,599 --> 00:17:18,209
Let's see.

347
00:17:18,210 --> 00:17:23,210
And if you'll try to
spoof app one IP address,

348
00:17:24,270 --> 00:17:28,550
we can see that the operation
of manipulating the packet

349
00:17:28,550 --> 00:17:29,783
is not permitted.

350
00:17:31,640 --> 00:17:36,310
Okay so now, let's block
the attacker pod access

351
00:17:36,310 --> 00:17:39,960
to port 8080 on the ftp pod.

352
00:17:39,960 --> 00:17:42,860
And now we'll use the
technique of manipulating

353
00:17:42,860 --> 00:17:44,949
the VXLAN packet.

354
00:17:44,950 --> 00:17:49,040
We try to sniff this
communication on the port 8080

355
00:17:49,040 --> 00:17:51,830
on the ftp pod.

356
00:17:51,830 --> 00:17:56,419
And to do so, we construct
the payload and send it

357
00:17:56,420 --> 00:17:59,320
leaving off the land style
using their best feature

358
00:17:59,320 --> 00:18:00,773
to send packets.

359
00:18:11,140 --> 00:18:14,830
We will send the crafted
payload to the remote node

360
00:18:14,830 --> 00:18:19,439
on what you'll see as UDP port 8472.

361
00:18:19,440 --> 00:18:22,870
So it will be wrapped,
it will be unwrapped

362
00:18:22,870 --> 00:18:25,562
as a VXLAN packet on the other side.

363
00:18:29,819 --> 00:18:32,569
(mouse clicking)

364
00:18:34,320 --> 00:18:37,580
We send it to the IP
address of the remote node

365
00:18:37,580 --> 00:18:40,562
to UDP port 8472.

366
00:18:48,340 --> 00:18:53,340
Okay so now, we'll send
the crafted packet.

367
00:18:54,639 --> 00:18:57,389
(mouse clicking)

368
00:18:58,510 --> 00:19:02,080
And we can see that the, and
we can see that the ftp pod

369
00:19:03,820 --> 00:19:06,679
received the packet from
the forged IP address

370
00:19:06,680 --> 00:19:08,790
of app one pod.

371
00:19:08,790 --> 00:19:11,770
Yay, so we did it again.

372
00:19:11,770 --> 00:19:15,580
We demonstrated how we can
bypass the two most common

373
00:19:15,580 --> 00:19:17,139
security controls.

374
00:19:17,140 --> 00:19:19,560
But, now what?

375
00:19:19,560 --> 00:19:22,830
First of all, it's still a
good practice to make sure

376
00:19:22,830 --> 00:19:26,710
you drop the NET_RAW
capability from your pods.

377
00:19:26,710 --> 00:19:30,500
Other than that, I would suggest
to also block any attempt

378
00:19:30,500 --> 00:19:33,350
to send encapsulated packets from pods.

379
00:19:33,350 --> 00:19:36,012
That should completely mitigate this risk.

380
00:19:36,012 --> 00:19:36,970
(mouse clicking)

381
00:19:36,970 --> 00:19:40,530
Until this point, we talked
about layer two network plugins.

382
00:19:40,530 --> 00:19:44,340
But there are a lot of layer
three network plugins as well.

383
00:19:44,340 --> 00:19:46,570
When using layer three network plugin,

384
00:19:46,570 --> 00:19:48,379
we deal with different risks.

385
00:19:48,380 --> 00:19:52,810
We no longer have pods that
share the same broadcast domain.

386
00:19:52,810 --> 00:19:56,409
So men in the middle
attacks are less common.

387
00:19:56,410 --> 00:19:58,933
Another key feature is different,

388
00:20:00,130 --> 00:20:02,840
is different than the
user routing daemons.

389
00:20:02,840 --> 00:20:06,020
If we talked about bridge
devices and ARP tables,

390
00:20:06,020 --> 00:20:08,580
here we'll talk more about routing tables

391
00:20:08,580 --> 00:20:10,540
and routing daemons.

392
00:20:10,540 --> 00:20:13,990
Routing daemons function as
routers in the architecture

393
00:20:13,990 --> 00:20:16,410
and distribute routing
data between the nodes

394
00:20:16,410 --> 00:20:17,750
of the cluster.

395
00:20:17,750 --> 00:20:22,661
They use known routing
protocols such as BGP and OSPF.

396
00:20:22,661 --> 00:20:23,640
(mouse clicking)

397
00:20:23,640 --> 00:20:26,950
As we said, the threat
landscape has changed.

398
00:20:26,950 --> 00:20:30,140
In Kubernetes environments,
routers are an integral part

399
00:20:30,140 --> 00:20:31,100
of the host.

400
00:20:31,100 --> 00:20:33,620
They run on the host as a process.

401
00:20:33,620 --> 00:20:36,510
This aspect changed the whole of the game.

402
00:20:36,510 --> 00:20:39,520
We are used to routers as a separate box.

403
00:20:39,520 --> 00:20:42,810
One that is less vulnerable
to common attack vectors.

404
00:20:42,810 --> 00:20:46,770
But now, if there's a
vulnerable service on the host,

405
00:20:46,770 --> 00:20:49,650
the whole routing mechanism is under risk.

406
00:20:49,650 --> 00:20:53,110
And as a result, the data
flow of the whole cluster

407
00:20:53,110 --> 00:20:55,310
is under risks as well.

408
00:20:55,310 --> 00:20:59,060
Another issue we should talk
about although it's less common

409
00:20:59,060 --> 00:21:02,940
is pods that are configured
with the root network namespace.

410
00:21:02,940 --> 00:21:06,620
If an attacker successfully
compromised this kind of a pod,

411
00:21:06,620 --> 00:21:09,870
he will also get direct
access to all of the

412
00:21:09,870 --> 00:21:13,139
routing's decisions of
the node and potentially

413
00:21:13,140 --> 00:21:14,259
of all of the cluster.

414
00:21:14,259 --> 00:21:15,092
(mouse clicking)

415
00:21:15,092 --> 00:21:20,060
Let's discuss a specific example
of Calico's network plugin.

416
00:21:20,060 --> 00:21:23,020
And what's the flow of the
control plane and data plane

417
00:21:23,020 --> 00:21:24,800
in that case?

418
00:21:24,800 --> 00:21:27,550
In order for data to pass from app one pod

419
00:21:27,550 --> 00:21:31,030
to the core DNS pod, the
routing daemons of Calico

420
00:21:31,030 --> 00:21:33,629
should distribute the
routing data to each other.

421
00:21:33,630 --> 00:21:36,880
The routing daemons of node
one tells the routing daemon

422
00:21:36,880 --> 00:21:39,450
of the master node that
it wants to communicate

423
00:21:39,450 --> 00:21:40,860
with app one.

424
00:21:40,860 --> 00:21:43,860
It would send the packets
to its overlay device

425
00:21:43,860 --> 00:21:45,283
and vice versa.

426
00:21:46,130 --> 00:21:50,320
Now, looking at that attack
surface, we thought to ourself,

427
00:21:50,320 --> 00:21:52,909
how can we obtain a men
in the middle position

428
00:21:52,910 --> 00:21:55,060
in this kind of architecture?

429
00:21:55,060 --> 00:21:59,050
We can't see, we can't use
any of the previous techniques

430
00:21:59,050 --> 00:22:02,610
but what we can do is
attack the routing daemons.

431
00:22:02,610 --> 00:22:05,760
To do so, we assume that the
attacker was able to gain

432
00:22:05,760 --> 00:22:08,210
a grip as a low privileged user,

433
00:22:08,210 --> 00:22:10,830
no high permissions needed here,

434
00:22:10,830 --> 00:22:14,750
on either the host or
on a pod that is defined

435
00:22:14,750 --> 00:22:16,890
with root network namespace.

436
00:22:16,890 --> 00:22:21,290
In Calico's design, they use
BGP as the routing protocol.

437
00:22:21,290 --> 00:22:25,070
And the known BGP attack is BGP hijacking.

438
00:22:25,070 --> 00:22:29,040
Now, BGP hijacking is when
a hacker manage to hijack

439
00:22:29,040 --> 00:22:33,310
a BGP session and inject
a forged routing data.

440
00:22:33,310 --> 00:22:34,850
As you can see on the right,

441
00:22:34,850 --> 00:22:38,620
a BGP session starts with
a TCP three-way handshake.

442
00:22:38,620 --> 00:22:41,649
And then, there are all
sorts of BGP messages

443
00:22:41,650 --> 00:22:45,860
such as OPEN message, KeepAlive
messages, UPDATE messages

444
00:22:45,860 --> 00:22:47,590
and so on.

445
00:22:47,590 --> 00:22:51,250
If an attacker hijack the
session, he can change the data

446
00:22:51,250 --> 00:22:54,580
on the left figure so
that the next hop section

447
00:22:54,580 --> 00:22:57,110
will be the IP address
of the server controlled

448
00:22:57,110 --> 00:22:58,719
by the attacker.

449
00:22:58,720 --> 00:23:02,210
It's a major risk as this
kind of an attack can change

450
00:23:02,210 --> 00:23:04,330
the data flow of the whole cluster,

451
00:23:04,330 --> 00:23:07,780
just by achieving a low
privileged access to the host.

452
00:23:07,780 --> 00:23:10,560
Once an attacker gains a
grip on a relevant position

453
00:23:10,560 --> 00:23:13,710
on the root network namespace,
any packet he'll send,

454
00:23:13,710 --> 00:23:18,190
he'll send out will be with
the IP address of the node.

455
00:23:18,190 --> 00:23:22,200
By doing so, we can start a TCP
session with a remote daemon

456
00:23:22,200 --> 00:23:24,510
in the name of the local daemon.

457
00:23:24,510 --> 00:23:27,520
Well in that case, it sounds easy, right?

458
00:23:27,520 --> 00:23:30,920
The issue was that the
BGP daemon was configured

459
00:23:30,920 --> 00:23:33,310
with Graceful Restart capability.

460
00:23:33,310 --> 00:23:36,879
Which allowed the original
session to hijack the session

461
00:23:36,880 --> 00:23:41,220
right back from the attacker
and no harm was done.

462
00:23:41,220 --> 00:23:45,310
We could leave it as it is,
denial of service attack,

463
00:23:45,310 --> 00:23:46,720
but we wanted more.

464
00:23:46,720 --> 00:23:50,550
We wanted to get a permanent
grip of the BGP session.

465
00:23:50,550 --> 00:23:53,050
So we could inject routing data and be

466
00:23:53,050 --> 00:23:56,810
in the men in the middle
position for the whole cluster.

467
00:23:56,810 --> 00:24:01,379
To do so, we discovered a new
security issue in the BGP RFC

468
00:24:01,380 --> 00:24:05,130
that helped us to gain
persistent BGP connection after

469
00:24:05,130 --> 00:24:06,060
we hijacked it.

470
00:24:06,060 --> 00:24:08,730
On the right, you can
see the RFC that dictates

471
00:24:08,730 --> 00:24:11,060
that by using Graceful Restart mechanisms,

472
00:24:11,060 --> 00:24:16,060
a new connection will cause the
current TCP session to drop.

473
00:24:16,130 --> 00:24:20,080
What we did was to send a
notification message that stated

474
00:24:20,080 --> 00:24:23,699
that the remote BGP
peer won't support this

475
00:24:23,700 --> 00:24:25,690
Graceful Restart capability.

476
00:24:25,690 --> 00:24:28,837
In this way, the next
time the session starts,

477
00:24:28,837 --> 00:24:32,030
this mechanism won't work.

478
00:24:32,030 --> 00:24:35,710
It means that after the
attacker starts the BGP session,

479
00:24:35,710 --> 00:24:38,800
the original session won't
be able to re-initiate it.

480
00:24:38,800 --> 00:24:39,740
(mouse clicking)

481
00:24:39,740 --> 00:24:43,319
So after doing that, we
can inject routing data

482
00:24:43,319 --> 00:24:46,310
that will cause the
communication between pods

483
00:24:46,310 --> 00:24:48,629
to go through any
attacker controlled server

484
00:24:48,630 --> 00:24:50,690
outside of the cluster.

485
00:24:50,690 --> 00:24:53,610
We disclosed this attack
vector to Calico project

486
00:24:53,610 --> 00:24:58,199
by (mumbles) in the issue
of the fixing version 3.17.

487
00:24:58,200 --> 00:25:01,430
Let's demonstrate what this
attack might look like.

488
00:25:01,430 --> 00:25:03,940
Okay, so here on the master node,

489
00:25:03,940 --> 00:25:08,373
we can see that there are
two pods, app one and db pod.

490
00:25:09,260 --> 00:25:12,920
We can also see the
that when app one pings,

491
00:25:12,920 --> 00:25:16,850
we'll try to do a ping,
when app one pings,

492
00:25:16,850 --> 00:25:20,810
the db pod, the attacker
controlled server,

493
00:25:20,810 --> 00:25:22,523
won't receive any data.

494
00:25:23,730 --> 00:25:27,300
So now let's monitor the routing table

495
00:25:27,300 --> 00:25:30,690
on the node that app
one pod is running on.

496
00:25:30,690 --> 00:25:34,610
And we can see that the subnet
of the db pod is configured

497
00:25:34,610 --> 00:25:37,429
to go through node to IP address.

498
00:25:37,430 --> 00:25:40,319
What we want to do is to
inject new routing data

499
00:25:40,319 --> 00:25:44,510
that will make packets
from app one to db pod,

500
00:25:44,510 --> 00:25:47,150
go through the attacker's machine.

501
00:25:47,150 --> 00:25:50,839
But before we do that,
we should create an IP,

502
00:25:50,839 --> 00:25:55,360
an IP overlay device in the
attacker's machine as well.

503
00:25:55,360 --> 00:25:59,679
As packets will be sent in an
IP and IP encapsulation way.

504
00:25:59,680 --> 00:26:03,970
Now, assuming there's a low
privileged attacker on node two,

505
00:26:03,970 --> 00:26:08,260
he can run the BGP hijacking
attack with the new RFC issue

506
00:26:08,260 --> 00:26:11,070
and inject the new routing data.

507
00:26:11,070 --> 00:26:13,129
Now we look at the routing table

508
00:26:13,130 --> 00:26:15,780
and we can see that the
routing table now shows that

509
00:26:15,780 --> 00:26:18,820
the packets that are sent
to the db pod IP address

510
00:26:18,820 --> 00:26:22,230
should go through the IP address
of the attacker's service.

511
00:26:22,230 --> 00:26:26,200
So sending ping from app one to the db pod

512
00:26:26,200 --> 00:26:28,330
will end up in the attacker's machine.

513
00:26:28,330 --> 00:26:29,829
Let's see.

514
00:26:29,829 --> 00:26:31,720
(mouse clicking)

515
00:26:31,720 --> 00:26:35,360
Okay so, third time the charm.

516
00:26:35,360 --> 00:26:38,409
That was our last demo
for this presentation.

517
00:26:38,410 --> 00:26:39,620
(mouse clicking)

518
00:26:39,620 --> 00:26:41,949
And that's cool and all but,

519
00:26:41,950 --> 00:26:45,090
why is it important for us
to talk and learn more about

520
00:26:45,090 --> 00:26:46,720
this attack vectors?

521
00:26:46,720 --> 00:26:50,750
First of all, we all must
start changing our world view

522
00:26:50,750 --> 00:26:53,690
from traditional networks
to networks in containerized

523
00:26:53,690 --> 00:26:55,160
environments.

524
00:26:55,160 --> 00:26:56,990
The attack surface has changed

525
00:26:56,990 --> 00:26:59,700
and there are a lot more
new threats out there.

526
00:26:59,700 --> 00:27:03,250
And most importantly, you
must stay with the passion

527
00:27:03,250 --> 00:27:05,160
that kept you here with me today,

528
00:27:05,160 --> 00:27:07,160
in this dirty network pipelines,

529
00:27:07,160 --> 00:27:10,520
so that your Kubernetes
clusters will be more secure

530
00:27:10,520 --> 00:27:13,240
and your assets will stay protected.

531
00:27:13,240 --> 00:27:15,390
What can you do to make it happen?

532
00:27:15,390 --> 00:27:19,720
Well, starting next week,
you should be able to know

533
00:27:19,720 --> 00:27:21,723
which network plugins you use.

534
00:27:21,723 --> 00:27:23,370
Let's start with that.

535
00:27:23,370 --> 00:27:26,899
And then you should be able
to identify the mechanisms

536
00:27:26,900 --> 00:27:29,070
that are part of your cluster networking.

537
00:27:29,070 --> 00:27:31,300
You should know about
your network devices,

538
00:27:31,300 --> 00:27:33,490
the type of overlay network you use.

539
00:27:33,490 --> 00:27:35,320
You should know about routing components

540
00:27:35,320 --> 00:27:37,133
and IP address management.

541
00:27:38,040 --> 00:27:41,379
In the first three months
following this presentation,

542
00:27:41,380 --> 00:27:43,520
you should be able to
define the appropriate

543
00:27:43,520 --> 00:27:46,740
network policy solution
for your organization.

544
00:27:46,740 --> 00:27:49,780
You should also, must raise awareness

545
00:27:49,780 --> 00:27:53,230
of the risks involved in
using default pod capabilities

546
00:27:53,230 --> 00:27:57,250
and proactively drop the
use of NET_RAW capability

547
00:27:57,250 --> 00:27:59,260
unless it must be used.

548
00:27:59,260 --> 00:28:02,020
Lastly, you should configure
your routing daemon

549
00:28:02,020 --> 00:28:04,820
to work securely by using a password

550
00:28:04,820 --> 00:28:07,439
for the routing protocol session.

551
00:28:07,440 --> 00:28:11,180
But most of all, you must not
afraid of diving into the dirt

552
00:28:11,180 --> 00:28:13,050
and learn how things work.

553
00:28:13,050 --> 00:28:15,159
Hackers do that every day.

554
00:28:15,160 --> 00:28:16,530
Don't let them reach you.

555
00:28:16,530 --> 00:28:17,520
(mouse clicking)

556
00:28:17,520 --> 00:28:19,810
It was a great honor and
a pleasure to be here

557
00:28:19,810 --> 00:28:21,040
with you today.

558
00:28:21,040 --> 00:28:23,560
I hope you were interested
and that I was able to

559
00:28:23,560 --> 00:28:26,159
convey the importance of the subject.

560
00:28:26,160 --> 00:28:28,550
We have more time for Q and A in the chat.

561
00:28:28,550 --> 00:28:30,399
And in addition in a few minutes,

562
00:28:30,400 --> 00:28:33,420
a live Q and A session will start with me.

563
00:28:33,420 --> 00:28:35,780
You are welcome and I
will be happy to answer

564
00:28:35,780 --> 00:28:37,770
all of your questions.

565
00:28:37,770 --> 00:28:40,120
I am Nir Chako from CyberArk clubs.

566
00:28:40,120 --> 00:28:41,820
You can find me on Twitter

567
00:28:41,820 --> 00:28:45,169
and read more details about
the research on our blog.

568
00:28:45,170 --> 00:28:47,647
Thank you very much for your time.

