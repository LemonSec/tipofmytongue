1
00:00:01,200 --> 00:00:02,380
- Hello everyone.

2
00:00:02,380 --> 00:00:04,109
Thank you for coming to our session,

3
00:00:04,110 --> 00:00:08,080
The Game of Cyber Threat
Hunting: The Return of the Fun.

4
00:00:08,080 --> 00:00:10,073
I'm Jiyong from IBM research.

5
00:00:11,190 --> 00:00:13,590
And today with my colleague Xiaokui,

6
00:00:14,650 --> 00:00:17,850
we present our open source
threat hunting language

7
00:00:17,850 --> 00:00:21,013
for simple, composable
and sharable huntflow.

8
00:00:21,950 --> 00:00:24,710
In the movie, we often see threat hunters

9
00:00:24,710 --> 00:00:26,480
use various fancy tools

10
00:00:26,480 --> 00:00:29,900
like augmented reality navigation tool

11
00:00:29,900 --> 00:00:33,463
to easily have all the necessary
data at their fingertips.

12
00:00:34,350 --> 00:00:35,960
And then they can simply focus

13
00:00:35,960 --> 00:00:40,600
on constructing and validating
various data hypothesis,

14
00:00:40,600 --> 00:00:42,603
which actually looks like fun.

15
00:00:43,490 --> 00:00:46,730
In reality, we do have a lot of advanced

16
00:00:46,730 --> 00:00:49,599
threat detection and hunting tools,

17
00:00:49,600 --> 00:00:50,760
such as SIEM,

18
00:00:50,760 --> 00:00:53,930
security information and
event management system

19
00:00:53,930 --> 00:00:57,213
and EDR, endpoint detection
and response solution.

20
00:00:58,400 --> 00:01:00,010
But many different tools

21
00:01:00,010 --> 00:01:02,360
also come with many different manuals

22
00:01:02,360 --> 00:01:04,700
and API documentation to read,

23
00:01:04,700 --> 00:01:06,550
and many different records to digest.

24
00:01:07,911 --> 00:01:11,030
So we ended up spending
majority of our time

25
00:01:11,030 --> 00:01:13,570
on learning how to construct query

26
00:01:13,570 --> 00:01:16,270
and how to interpret query result

27
00:01:16,270 --> 00:01:18,490
and then going through record by record

28
00:01:18,490 --> 00:01:21,800
to teach observation from multiple tools,

29
00:01:21,800 --> 00:01:25,720
which often require significant
amount of manual work.

30
00:01:25,720 --> 00:01:30,090
So the gap between movie and reality shows

31
00:01:30,090 --> 00:01:33,470
there are two types of
questions in threat hunting:

32
00:01:33,470 --> 00:01:35,443
what to hunt and how to hunt.

33
00:01:36,780 --> 00:01:39,810
We tend to spend more time on how to hunt,

34
00:01:39,810 --> 00:01:42,610
like how should I construct a query

35
00:01:42,610 --> 00:01:45,750
that I want to ask for this EDR solution,

36
00:01:45,750 --> 00:01:48,257
or how should I interpret the query result

37
00:01:48,257 --> 00:01:51,520
and extract the field that I need,

38
00:01:51,520 --> 00:01:54,030
or how to connect multiple observation

39
00:01:54,030 --> 00:01:58,640
by reading through manual and
API documentation for each two

40
00:01:58,640 --> 00:02:01,943
and building the custom
script to train them.

41
00:02:03,290 --> 00:02:04,470
But at the same time,

42
00:02:04,470 --> 00:02:08,070
we do know that the core
value of threat hunting

43
00:02:08,070 --> 00:02:09,382
comes from what to hunt,

44
00:02:10,560 --> 00:02:14,560
like constructing and validating
new threat hypothesis,

45
00:02:14,560 --> 00:02:16,530
or discovering the new insight

46
00:02:16,530 --> 00:02:19,483
using threat intelligence or
the machine learning model.

47
00:02:20,880 --> 00:02:22,293
Then the question is:

48
00:02:23,130 --> 00:02:26,963
how can you make the threat
hunting more fun and efficient?

49
00:02:28,490 --> 00:02:30,960
We need to prioritize the hunting task

50
00:02:30,960 --> 00:02:34,590
such that we spend more
time on thinking about

51
00:02:34,590 --> 00:02:37,770
stealthy attack plot
and threat hypothesis,

52
00:02:37,770 --> 00:02:40,443
rather than learning how
to use an integrate tool.

53
00:02:41,450 --> 00:02:46,450
That's why today we are
going to introduce Kestrel,

54
00:02:46,860 --> 00:02:49,250
our open source threat hunting language

55
00:02:49,250 --> 00:02:53,410
to shift the focus from how
to hunt to what to hunt.

56
00:02:53,410 --> 00:02:54,863
- Why a new language?

57
00:02:55,720 --> 00:03:00,133
Because threat hunters need
a way to express the what.

58
00:03:01,752 --> 00:03:05,680
Think about describing control
flows of a hunting program,

59
00:03:05,680 --> 00:03:09,330
plus the control flows
can be modified on the fly

60
00:03:09,330 --> 00:03:11,680
regarding the dynamic
nature of threat hunting.

61
00:03:13,020 --> 00:03:16,863
We need the description
power that does not exist.

62
00:03:19,350 --> 00:03:23,170
We expect senior hunters
to describe hunting steps

63
00:03:23,170 --> 00:03:25,143
and connect them into huntflows,

64
00:03:26,670 --> 00:03:29,059
we expect huntflows to be shared

65
00:03:29,060 --> 00:03:30,323
and re-execute it,

66
00:03:31,970 --> 00:03:35,403
and we expect different ways
of executing the language.

67
00:03:36,430 --> 00:03:38,110
That's half of the story,

68
00:03:38,110 --> 00:03:40,103
the top half about the what.

69
00:03:41,720 --> 00:03:44,300
As we relieve the users of the how,

70
00:03:44,300 --> 00:03:47,503
someone or something needs
to take care of the how.

71
00:03:49,170 --> 00:03:52,403
We develop the Kestrel runtime
to complete the mission.

72
00:03:54,690 --> 00:03:57,243
Kestrel runtime has three main interfaces,

73
00:03:58,180 --> 00:04:00,890
all of which can pass the what

74
00:04:00,890 --> 00:04:02,059
from the users

75
00:04:03,070 --> 00:04:05,019
deeply down the stack

76
00:04:05,020 --> 00:04:07,143
to figure out the how and execute.

77
00:04:08,770 --> 00:04:11,273
The runtime complete the how for the what,

78
00:04:12,190 --> 00:04:15,963
and generate codes to be
executed locally and remotely.

79
00:04:17,810 --> 00:04:19,250
One big yolk for hunting

80
00:04:19,250 --> 00:04:21,760
is data and information retrieval.

81
00:04:21,760 --> 00:04:25,530
We build on top of the open
source project STIX shifter

82
00:04:25,530 --> 00:04:28,969
to enable access to a
variety of data sources

83
00:04:28,970 --> 00:04:30,570
and threat intelligence sources.

84
00:04:32,500 --> 00:04:35,320
We also take advantage of containers

85
00:04:35,320 --> 00:04:36,510
and serverless computing

86
00:04:36,510 --> 00:04:40,240
as a means to invoke external knowledge,

87
00:04:40,240 --> 00:04:43,450
proprietary knowledge or complex logic

88
00:04:43,450 --> 00:04:44,650
into building huntflows.

89
00:04:47,400 --> 00:04:48,460
Threat hunters may get bored

90
00:04:48,460 --> 00:04:51,849
about these complex gray
boxes in Kestrel runtime.

91
00:04:51,850 --> 00:04:53,510
No worry.

92
00:04:53,510 --> 00:04:55,270
The takeaway here is

93
00:04:55,270 --> 00:04:58,440
these boxes will do the how for you

94
00:04:58,440 --> 00:05:01,840
and provide you a logical
data representation

95
00:05:01,840 --> 00:05:05,039
to help describe the what in steps

96
00:05:05,040 --> 00:05:07,173
and change them into huntflows.

97
00:05:09,870 --> 00:05:11,793
So what are the what?

98
00:05:12,810 --> 00:05:14,650
In the language design,

99
00:05:14,650 --> 00:05:18,332
we carefully abstract the
what into two categories.

100
00:05:20,020 --> 00:05:25,020
First is patterns, or graph
patterns as our ultimate goal.

101
00:05:26,610 --> 00:05:29,030
A user can use a pattern to describe

102
00:05:29,030 --> 00:05:31,732
what he or she wants to take a close look.

103
00:05:33,760 --> 00:05:35,522
Some interesting processes,

104
00:05:37,600 --> 00:05:39,293
instances of TTPs,

105
00:05:41,800 --> 00:05:44,943
connected entities like
child processes of a process,

106
00:05:48,070 --> 00:05:50,520
or any entity that has some relations

107
00:05:50,520 --> 00:05:52,140
or share some common information

108
00:05:52,140 --> 00:05:54,743
with what he or she already inspected.

109
00:05:56,820 --> 00:06:00,670
Patterns in Kestrel are
similar to regular expressions,

110
00:06:00,670 --> 00:06:03,610
but match against
structured computation logs,

111
00:06:03,610 --> 00:06:06,313
such as process trees from EDR systems,

112
00:06:07,147 --> 00:06:09,103
or NetFlow records from firewalls.

113
00:06:10,950 --> 00:06:13,420
Patterns is about data retrieval,

114
00:06:13,420 --> 00:06:15,860
hunter's one pattern after another

115
00:06:15,860 --> 00:06:20,363
to iteratively find the entities
that belong to an attack.

116
00:06:22,040 --> 00:06:24,890
Sometimes, that's not enough.

117
00:06:24,890 --> 00:06:28,522
So we give the hunters the
second expression of what,

118
00:06:29,710 --> 00:06:30,832
the analytics.

119
00:06:31,920 --> 00:06:35,120
Kestrel has a modular
foreign language interface

120
00:06:35,120 --> 00:06:38,983
to execute any external
logic as analytics,

121
00:06:41,000 --> 00:06:43,370
invoking external threat intel

122
00:06:43,370 --> 00:06:46,223
to calculate the suspiciousness
of given processes,

123
00:06:48,050 --> 00:06:50,540
determine the likelihood
of data exfiltration

124
00:06:50,540 --> 00:06:51,853
on given network traffic,

125
00:06:54,160 --> 00:06:57,473
or draw the data on the
canvas in an interactive hunt.

126
00:06:59,390 --> 00:07:01,662
You can think about analytics

127
00:07:01,662 --> 00:07:03,890
as serverless computing functions

128
00:07:03,890 --> 00:07:05,570
running in the cloud,

129
00:07:05,570 --> 00:07:09,563
but obey the rules Kestrel
define for input and output.

130
00:07:12,050 --> 00:07:15,170
Now, threat hunter has two powerful means

131
00:07:15,170 --> 00:07:17,293
to express the what in their mind,

132
00:07:18,170 --> 00:07:21,273
and they need to do one
more thing to make a hunt:

133
00:07:22,260 --> 00:07:25,772
compose a huntflow with
patterns and analytics.

134
00:07:29,010 --> 00:07:30,263
We like things simple,

135
00:07:31,320 --> 00:07:33,710
we like things powerful.

136
00:07:33,710 --> 00:07:35,250
We want both.

137
00:07:35,250 --> 00:07:37,180
Yes, it's possible.

138
00:07:37,180 --> 00:07:40,363
With the idea composability
from functional programming,

139
00:07:42,010 --> 00:07:45,120
a threat hunter not only can
change different patterns

140
00:07:45,120 --> 00:07:47,690
but also analytics after pattern,

141
00:07:47,690 --> 00:07:49,400
analytics after analytics,

142
00:07:49,400 --> 00:07:51,510
pattern after analytics.

143
00:07:51,510 --> 00:07:52,453
An example here.

144
00:07:53,630 --> 00:07:55,100
a hunter first uses a pattern

145
00:07:56,000 --> 00:07:58,943
to match a list of
processes he is interested,

146
00:07:59,970 --> 00:08:03,113
which access /etc/shadow
and spawn a shell,

147
00:08:04,370 --> 00:08:07,040
then he pipes it to analytics

148
00:08:07,040 --> 00:08:09,350
that invokes external threat intel

149
00:08:09,350 --> 00:08:11,793
to rank the matched
processes from the pattern.

150
00:08:14,530 --> 00:08:16,880
We can describe the pattern in a graph

151
00:08:18,120 --> 00:08:20,793
and execute the analytics
in a docker container.

152
00:08:22,040 --> 00:08:24,183
That's our first simple huntflow.

153
00:08:25,860 --> 00:08:30,420
We can extend it to have a
pattern before our old one.

154
00:08:30,420 --> 00:08:33,200
So the worker process
in the second pattern

155
00:08:33,200 --> 00:08:36,980
is not matched against
any processes on the host,

156
00:08:36,980 --> 00:08:40,169
but against a list of
pre-matched processes

157
00:08:40,169 --> 00:08:41,392
from the first pattern.

158
00:08:42,760 --> 00:08:46,170
Of course, we can pipe an
outlier detection analytics

159
00:08:46,170 --> 00:08:47,502
after our first analytics.

160
00:08:49,600 --> 00:08:51,350
Besides adding more,

161
00:08:51,350 --> 00:08:53,683
threat hunting is an
interactive procedure.

162
00:08:54,660 --> 00:08:59,189
It is common for hunters
to manipulate the huntflow,

163
00:08:59,190 --> 00:09:02,393
replace the second analytics
with a machine learning model,

164
00:09:03,840 --> 00:09:06,453
merge multiple flows into one,

165
00:09:07,580 --> 00:09:11,480
or fork a huntflow branch to
verify a different version

166
00:09:11,480 --> 00:09:12,803
of the threat hypothesis.

167
00:09:15,570 --> 00:09:18,730
We expect what are the what,

168
00:09:18,730 --> 00:09:21,433
we expect what is the composability.

169
00:09:22,700 --> 00:09:26,060
What's the secret source to
make huntflow compostable

170
00:09:26,060 --> 00:09:28,093
from any pattern or analytics?

171
00:09:29,940 --> 00:09:33,210
The magic is a logical data representation

172
00:09:33,210 --> 00:09:36,183
human naturally use, entities.

173
00:09:37,320 --> 00:09:39,140
A host is an entity,

174
00:09:39,140 --> 00:09:41,302
a network traffic is an entity,

175
00:09:41,302 --> 00:09:42,503
a process is an entity,

176
00:09:42,503 --> 00:09:43,970
a user is an entity.

177
00:09:43,970 --> 00:09:44,883
Okay, you get it.

178
00:09:45,720 --> 00:09:48,900
Before we work with entities in Kestrel,

179
00:09:48,900 --> 00:09:52,810
threat hunters directly
work with raw logs, records,

180
00:09:52,810 --> 00:09:56,203
or observations generated
by monitoring systems.

181
00:09:57,760 --> 00:10:01,800
The diverse formats and
semantics of these raw records

182
00:10:01,800 --> 00:10:04,479
contributes largely to the time

183
00:10:04,480 --> 00:10:06,233
threat hunter spend on the how.

184
00:10:08,000 --> 00:10:10,570
A fundamental idea of Kestrel

185
00:10:10,570 --> 00:10:15,520
is for the runtime to assemble
records into entities,

186
00:10:15,520 --> 00:10:20,520
and enforce the input and output
of any pattern or analytics

187
00:10:20,960 --> 00:10:23,993
to be a homogeneous list of entities.

188
00:10:25,110 --> 00:10:29,363
Then, we have entity-based
cyber reasoning.

189
00:10:32,408 --> 00:10:35,453
Let's search for TTP
pattern with three entities.

190
00:10:36,418 --> 00:10:40,863
A nodeJS process, a worker
process, and a binary.

191
00:10:41,970 --> 00:10:44,480
Can we get the worker process entities

192
00:10:44,480 --> 00:10:45,980
that are forked from a nodeJS

193
00:10:45,980 --> 00:10:48,373
but has a different executable associated?

194
00:10:49,260 --> 00:10:51,203
That's a exploited process.

195
00:10:52,410 --> 00:10:53,502
That's easy.

196
00:10:56,600 --> 00:10:58,930
Can we get child process entities

197
00:10:58,930 --> 00:11:00,772
of the processes in eworker?

198
00:11:02,420 --> 00:11:03,252
Easy.

199
00:11:05,020 --> 00:11:07,660
Can we load a list of IP addresses

200
00:11:07,660 --> 00:11:11,173
into the variable
senshost as host entities?

201
00:11:12,360 --> 00:11:13,193
Yes.

202
00:11:14,560 --> 00:11:18,469
Can we search for any
process forked from shell

203
00:11:18,470 --> 00:11:19,970
and connected to any senshost?

204
00:11:21,240 --> 00:11:22,073
Sure.

205
00:11:24,278 --> 00:11:28,540
Can we even get process
entities from another endpoint

206
00:11:28,540 --> 00:11:32,089
that connects to any
exploited process in eworker?

207
00:11:33,170 --> 00:11:34,002
We can.

208
00:11:35,480 --> 00:11:36,313
Lastly,

209
00:11:37,390 --> 00:11:40,453
can we trace back to the
root cause of this attack?

210
00:11:41,480 --> 00:11:42,313
Here it is.

211
00:11:44,480 --> 00:11:47,800
Finally, can we get other type of entities

212
00:11:47,800 --> 00:11:49,813
like files in a Kestrel variable?

213
00:11:50,760 --> 00:11:54,363
Can we apply an analytics
on a Kestrel variable?

214
00:11:56,570 --> 00:11:59,660
Can we search for entities
from different sensors,

215
00:11:59,660 --> 00:12:03,140
EDRs, NDRs, firewall, SIEM systems?

216
00:12:03,140 --> 00:12:04,923
Yes, yes, and yes.

217
00:12:06,040 --> 00:12:09,069
Next, let's see the enabler

218
00:12:09,070 --> 00:12:11,810
of heterogeneous data source queries.

219
00:12:11,810 --> 00:12:12,689
- At this moment,

220
00:12:12,690 --> 00:12:17,090
you may start wondering how
it is possible for Kestrel

221
00:12:17,090 --> 00:12:19,880
to operate across multiple data sources.

222
00:12:20,882 --> 00:12:21,719
For the purpose,

223
00:12:21,720 --> 00:12:23,660
we embrace STIX,

224
00:12:23,660 --> 00:12:26,073
structured threat information expression.

225
00:12:27,940 --> 00:12:29,680
STIX open standard maintained

226
00:12:29,680 --> 00:12:34,620
by OASIS Cyber Threat
Intelligence Technical Committee.

227
00:12:34,620 --> 00:12:39,130
And STIX is to use exchange
cyber threat intelligence.

228
00:12:39,130 --> 00:12:40,470
And STIX patterning

229
00:12:40,470 --> 00:12:43,490
is a patterning language
supporting STIX indicators

230
00:12:43,490 --> 00:12:46,973
with which set of
operators to match pattern.

231
00:12:48,160 --> 00:12:51,163
We (indistinct) STIX in
Kestrel for two reasons.

232
00:12:52,120 --> 00:12:55,010
First, we strongly
believe an open standard

233
00:12:55,010 --> 00:12:57,580
can facilitate information sharing

234
00:12:57,580 --> 00:12:59,600
across multiple organizations

235
00:12:59,600 --> 00:13:03,023
to protect against ever
evolving cyber threats together.

236
00:13:03,940 --> 00:13:06,650
Second, our entity-based reasoning

237
00:13:06,650 --> 00:13:09,850
is where we take graph-based model

238
00:13:09,850 --> 00:13:13,210
which can connect various
heterogeneous (indistinct)

239
00:13:13,210 --> 00:13:14,940
with their relationship.

240
00:13:14,940 --> 00:13:17,480
STIX shifter is an open source project

241
00:13:17,480 --> 00:13:20,383
hosted by Open
Cybersecurity Alliance, OCA,

242
00:13:21,280 --> 00:13:24,100
to enable universal data access

243
00:13:24,100 --> 00:13:25,550
while data stays where it is.

244
00:13:26,610 --> 00:13:27,550
For example,

245
00:13:27,550 --> 00:13:29,550
as listed on the right-hand side,

246
00:13:29,550 --> 00:13:31,829
a single STIX patterning can be translated

247
00:13:31,830 --> 00:13:34,410
into multiple native query

248
00:13:34,410 --> 00:13:37,300
through various STIX shifter connector

249
00:13:37,300 --> 00:13:40,229
to communicate with multiple
different data sources,

250
00:13:40,230 --> 00:13:43,573
for example, EDI, SIEM and data lake.

251
00:13:44,570 --> 00:13:46,960
And then the query result are returned

252
00:13:46,960 --> 00:13:49,403
as STIX observations in JSON format.

253
00:13:50,810 --> 00:13:51,939
So in other words,

254
00:13:51,940 --> 00:13:54,500
STIX shifter provide a standard way

255
00:13:54,500 --> 00:13:56,653
to integrate with multiple product.

256
00:13:57,530 --> 00:13:59,480
And as you can see on this chart,

257
00:13:59,480 --> 00:14:02,980
STIX shifter support many
different data sources today

258
00:14:02,980 --> 00:14:06,440
and it continuously evolve
with open source community.

259
00:14:06,440 --> 00:14:07,890
Next, we'll demonstrate

260
00:14:07,890 --> 00:14:10,660
how we can actually do the threat hunting

261
00:14:10,660 --> 00:14:12,680
with Kestrel hunting language

262
00:14:12,680 --> 00:14:15,050
to discover data breach

263
00:14:15,050 --> 00:14:17,410
started by (indistinct) phishing email.

264
00:14:17,410 --> 00:14:20,250
During the demonstration,
as a threat hunter,

265
00:14:20,250 --> 00:14:24,350
we would not know anything
about the entire attack plot,

266
00:14:24,350 --> 00:14:28,160
instead, we simply have
to rely on observation

267
00:14:28,160 --> 00:14:31,370
at a few endpoints to
discover the whole attack,

268
00:14:32,457 --> 00:14:35,902
like real-time whole and network-based

269
00:14:35,902 --> 00:14:37,480
(indistinct) monitoring solution

270
00:14:37,480 --> 00:14:40,840
which you might already
use in your day-to-day job.

271
00:14:40,840 --> 00:14:43,140
For example, we use the Sysmon

272
00:14:43,140 --> 00:14:45,500
for monitoring a Windows machine,

273
00:14:45,500 --> 00:14:49,671
and we use open source system
telemetry called SysFlow

274
00:14:49,671 --> 00:14:51,469
for monitoring a server,

275
00:14:51,469 --> 00:14:52,490
and web proxy

276
00:14:52,490 --> 00:14:54,723
will use to monitor the web traffic.

277
00:14:56,150 --> 00:15:00,980
And these raw data insert
into elastic stack and SIEM,

278
00:15:00,980 --> 00:15:04,673
which we are gonna utilize
and correlate using Kestrel.

279
00:15:05,830 --> 00:15:09,840
Okay, then let's dive into
the attempting with Kestrel.

280
00:15:09,840 --> 00:15:11,880
- [Xiaokui] Hello, this is Xiaokui.

281
00:15:11,880 --> 00:15:13,010
In this demo,

282
00:15:13,010 --> 00:15:16,803
I am a threat hunter searching
for attacks like this ones.

283
00:15:17,800 --> 00:15:21,163
Recently, I get a new client, StarX,

284
00:15:22,750 --> 00:15:26,220
who finds me to do a hunt
in their enterprise network

285
00:15:26,220 --> 00:15:28,380
to discover advanced threats

286
00:15:28,380 --> 00:15:31,563
beyond what firewalls and IDS can detect.

287
00:15:32,500 --> 00:15:33,820
Okay, let's start.

288
00:15:33,820 --> 00:15:37,010
So I usually use Jupiter
Notebook to do hunting.

289
00:15:37,010 --> 00:15:42,003
And let's create our first
Kestrel huntflow for StarX.

290
00:15:45,380 --> 00:15:49,840
And we can give it a name.

291
00:15:49,840 --> 00:15:52,053
And before we start,

292
00:15:54,560 --> 00:15:56,892
we need to understand target StarX,

293
00:15:58,070 --> 00:16:01,750
their assets, their
services, their monitors,

294
00:16:01,750 --> 00:16:04,520
so we know what to ask in a hunt.

295
00:16:04,520 --> 00:16:06,199
For this purpose,

296
00:16:06,200 --> 00:16:09,443
I get the topology so
that we can take a look.

297
00:16:10,510 --> 00:16:11,343
Okay?

298
00:16:11,343 --> 00:16:14,670
And we can (indistinct) markdown,

299
00:16:14,670 --> 00:16:16,969
and display that, okay.

300
00:16:16,970 --> 00:16:20,640
So StarX has two private networks:

301
00:16:20,640 --> 00:16:24,199
one for their employees'
laptops and workstations,

302
00:16:24,200 --> 00:16:25,490
one for their servers.

303
00:16:25,490 --> 00:16:26,960
All servers are Linux,

304
00:16:26,960 --> 00:16:29,880
and they have SysFlow running
on all of the servers,

305
00:16:29,880 --> 00:16:33,330
which are monitors that we
can ask for real-time data,

306
00:16:33,330 --> 00:16:34,580
what's happening there.

307
00:16:34,580 --> 00:16:36,140
So the company has security mind.

308
00:16:36,140 --> 00:16:40,630
So they have web proxy
that on all data and logs,

309
00:16:40,630 --> 00:16:43,060
or HTTP and HTTPS traffic

310
00:16:43,060 --> 00:16:44,630
before they hit the internet.

311
00:16:44,630 --> 00:16:47,290
And they put their sensitive
data, commercial secrets,

312
00:16:47,290 --> 00:16:50,620
in a network storage, and
has limited access to it,

313
00:16:50,620 --> 00:16:54,980
only give it the access to
specific servers and end users.

314
00:16:54,980 --> 00:16:56,630
Okay.

315
00:16:56,630 --> 00:16:58,653
So where to start?

316
00:17:03,978 --> 00:17:06,476
We can start from one of the servers.

317
00:17:06,477 --> 00:17:08,343
The first server, server one,

318
00:17:08,343 --> 00:17:10,910
and we can start with my favorite TTP,

319
00:17:10,910 --> 00:17:12,433
the web service exploit.

320
00:17:13,609 --> 00:17:15,372
So as I explained earlier,

321
00:17:16,390 --> 00:17:17,223
in the slides,

322
00:17:17,223 --> 00:17:18,450
this web service exploit

323
00:17:19,295 --> 00:17:22,580
is something that we can match instance

324
00:17:23,730 --> 00:17:28,130
that shows this is a new
process forked from web service

325
00:17:28,130 --> 00:17:29,580
but not actually web service.

326
00:17:29,580 --> 00:17:31,659
So we can say,

327
00:17:31,660 --> 00:17:33,463
we use STIX shifter to access data,

328
00:17:34,586 --> 00:17:37,340
Linuxserver 31,

329
00:17:37,340 --> 00:17:40,000
and we need to use this pattern

330
00:17:43,530 --> 00:17:44,700
parent ref

331
00:17:44,700 --> 00:17:47,460
to describe the TTP pattern

332
00:17:47,460 --> 00:17:52,460
so that process binary
ref.name not equals to node.

333
00:17:53,050 --> 00:17:56,100
So this is basically what this pattern is,

334
00:17:56,100 --> 00:17:57,889
and we want to find this process,

335
00:17:57,890 --> 00:18:00,070
if it does exist.

336
00:18:00,070 --> 00:18:03,480
So to make the search faster,

337
00:18:03,480 --> 00:18:06,320
we do not want to (indistinct)
the server of months of data,

338
00:18:06,320 --> 00:18:07,320
we want to restrict it,

339
00:18:07,320 --> 00:18:08,510
for example, for a day.

340
00:18:08,510 --> 00:18:10,010
Today is April 5th,

341
00:18:10,010 --> 00:18:11,960
and let's do April 5th.

342
00:18:11,960 --> 00:18:15,500
Usually, this data is about
10 gigabytes from SysFlow

343
00:18:15,500 --> 00:18:18,480
and ooh, that's pretty quick, okay.

344
00:18:18,480 --> 00:18:21,490
So we get back over 100 records.

345
00:18:21,490 --> 00:18:22,490
Do not worry.

346
00:18:22,490 --> 00:18:24,460
So records are not entities,

347
00:18:24,460 --> 00:18:26,530
records are raw data that we get back,

348
00:18:26,530 --> 00:18:28,690
a Kestrel will process that for you,

349
00:18:28,690 --> 00:18:31,733
so that you can ask it
for entity information.

350
00:18:33,150 --> 00:18:36,123
So name pid command line,

351
00:18:37,430 --> 00:18:39,630
actually there's only one entity here,

352
00:18:39,630 --> 00:18:42,150
even we get so many records back

353
00:18:42,150 --> 00:18:45,750
that this single entity has
a single pid with two names.

354
00:18:45,750 --> 00:18:47,370
The reason for it is

355
00:18:47,370 --> 00:18:49,810
this is how Linux handle process creation.

356
00:18:49,810 --> 00:18:51,110
There're two system calls.

357
00:18:52,252 --> 00:18:53,452
So this is the final one

358
00:18:56,015 --> 00:18:58,910
that will do a netcat

359
00:18:58,910 --> 00:19:01,225
connects to a compromised server

360
00:19:01,225 --> 00:19:03,649
and fork a bash node, change to a bash.

361
00:19:03,650 --> 00:19:07,723
So let's see if we find
something like this.

362
00:19:08,830 --> 00:19:09,663
Created by

363
00:19:14,990 --> 00:19:17,880
name pid and command line,

364
00:19:17,880 --> 00:19:20,563
so that if we are lucky,

365
00:19:21,810 --> 00:19:23,310
if attacker is lucky to get in

366
00:19:23,310 --> 00:19:26,159
and it's better to
establish this successfully,

367
00:19:26,160 --> 00:19:31,160
we will see that a netcat
process folks from it,

368
00:19:31,160 --> 00:19:34,950
and then that one will
change itself to a bash

369
00:19:34,950 --> 00:19:37,120
according to this command.

370
00:19:37,120 --> 00:19:38,370
What does it mean?

371
00:19:38,370 --> 00:19:39,520
Okay, we get it.

372
00:19:39,520 --> 00:19:41,900
Usually we get choose on record back,

373
00:19:41,900 --> 00:19:46,130
but actually these records are
sort of with three entities,

374
00:19:46,130 --> 00:19:48,940
or just one entity actually,
with one single pid.

375
00:19:48,940 --> 00:19:51,230
As we said, this is a parent,

376
00:19:51,230 --> 00:19:52,820
this is a forked,

377
00:19:52,820 --> 00:19:54,919
and this is a final process.

378
00:19:54,920 --> 00:19:58,190
Okay, so this is actually
turned into a bash.

379
00:19:58,190 --> 00:20:01,010
When attacker comes in and
connects through a bash,

380
00:20:01,010 --> 00:20:02,580
what will he do?

381
00:20:02,580 --> 00:20:04,000
So let's see,

382
00:20:04,000 --> 00:20:05,500
find process

383
00:20:06,450 --> 00:20:08,750
created by netcat

384
00:20:08,750 --> 00:20:13,750
and let's display name,
pid, and command line

385
00:20:14,875 --> 00:20:15,708
as usual.

386
00:20:18,630 --> 00:20:23,630
Okay, so this will give you an idea

387
00:20:23,700 --> 00:20:25,930
about what activities that attacker did

388
00:20:26,980 --> 00:20:30,733
after getting in and folk
a bash into the system.

389
00:20:31,700 --> 00:20:33,910
Okay, the netcat and bash
are actually the same one,

390
00:20:33,910 --> 00:20:36,520
as you can see the pid is the same.

391
00:20:36,520 --> 00:20:37,423
So,

392
00:20:38,660 --> 00:20:39,493
okay, okay,

393
00:20:39,493 --> 00:20:40,470
that's not too slow.

394
00:20:41,420 --> 00:20:45,263
We get many, many things
that attacker did, okay,

395
00:20:47,040 --> 00:20:48,149
too many of them.

396
00:20:48,150 --> 00:20:51,810
So which one is more
important than others?

397
00:20:51,810 --> 00:20:55,860
So that's we can further drill down.

398
00:20:55,860 --> 00:20:58,733
We need to ask, get some intelligence.

399
00:20:59,620 --> 00:21:02,340
If there is something that can sort it

400
00:21:02,340 --> 00:21:04,139
by the suspiciousness,

401
00:21:04,140 --> 00:21:05,340
there'll be very useful.

402
00:21:06,859 --> 00:21:09,466
Here, we introduce our first analytics.

403
00:21:11,393 --> 00:21:14,580
Then we can run analytics
as docker containers,

404
00:21:14,580 --> 00:21:16,720
as I previously said,

405
00:21:16,720 --> 00:21:18,530
suspicious process scoring,

406
00:21:18,530 --> 00:21:22,583
so this is the one that we can run.

407
00:21:24,420 --> 00:21:29,123
And we can also show some
of the suspicious things,

408
00:21:30,000 --> 00:21:31,860
not only the command line

409
00:21:31,860 --> 00:21:36,860
but also a new attribute set
generated by these analytics.

410
00:21:37,560 --> 00:21:39,659
So these analytics
actually use sigma rules

411
00:21:39,660 --> 00:21:42,150
and some of the other kind of knowledge

412
00:21:42,150 --> 00:21:46,160
to understand how suspicious a process is.

413
00:21:46,160 --> 00:21:47,513
I said we need to rank it.

414
00:21:48,900 --> 00:21:53,370
And we can sort suspicious by

415
00:21:53,370 --> 00:21:57,250
so that we replace the original variable

416
00:21:57,250 --> 00:22:00,720
with the same name variable,
with the sorted result,

417
00:22:00,720 --> 00:22:01,880
and show it.

418
00:22:02,940 --> 00:22:05,863
Then this is a most suspicious process

419
00:22:05,863 --> 00:22:08,950
that we can drill down next.

420
00:22:08,950 --> 00:22:12,450
So looks like this is
something related to Twitter,

421
00:22:12,450 --> 00:22:13,560
maybe some network traffic.

422
00:22:13,560 --> 00:22:16,310
So let's match it,

423
00:22:16,310 --> 00:22:20,197
and also see whether there's
any network traffic from it.

424
00:22:20,198 --> 00:22:21,360
So that,

425
00:22:21,360 --> 00:22:25,229
what we can do is to match anything from,

426
00:22:25,230 --> 00:22:26,063
not from a data source,

427
00:22:26,063 --> 00:22:28,500
but from a previous variable that we have

428
00:22:28,500 --> 00:22:29,990
on all the activities

429
00:22:29,990 --> 00:22:33,320
and get a Twitter process,

430
00:22:33,320 --> 00:22:36,740
and then try to see whether
there's any network traffic.

431
00:22:36,740 --> 00:22:41,380
We get five distinct network
traffic flows from it.

432
00:22:41,380 --> 00:22:44,150
So most of them connects to,

433
00:22:44,150 --> 00:22:48,070
this is the one that we
are inspecting the source,

434
00:22:48,070 --> 00:22:50,879
most of them connecting to this one

435
00:22:50,880 --> 00:22:53,330
that actually this is the web proxy,

436
00:22:53,330 --> 00:22:56,102
so that means we do not
get a real destination.

437
00:22:57,320 --> 00:22:58,899
If we want to get a real destination,

438
00:22:58,900 --> 00:23:02,820
we need to ask the other
half of the proxy traffic

439
00:23:06,312 --> 00:23:07,919
from the web proxy.

440
00:23:07,920 --> 00:23:10,513
So what we can do is,

441
00:23:12,060 --> 00:23:17,060
so this time, we asks web proxy which is,

442
00:23:17,900 --> 00:23:19,920
which has a curator

443
00:23:19,920 --> 00:23:22,630
is running there and get
all the logs from there,

444
00:23:22,630 --> 00:23:24,530
we can ask the curator box

445
00:23:24,530 --> 00:23:26,833
which is the commercial SIEM system,

446
00:23:27,800 --> 00:23:30,600
and then we can ask all
the network traffic from it

447
00:23:30,600 --> 00:23:33,199
that matches the criteria we give.

448
00:23:33,200 --> 00:23:34,033
What are the criteria?

449
00:23:34,033 --> 00:23:35,030
That is,

450
00:23:35,030 --> 00:23:37,410
that has the IP address,

451
00:23:37,410 --> 00:23:40,033
of the source IP address, source port,

452
00:23:41,087 --> 00:23:44,660
and as well Kestrel
will derive a timestamp

453
00:23:44,660 --> 00:23:46,170
from our previous traffic,

454
00:23:46,170 --> 00:23:49,270
so that actually, it's a three tuple,

455
00:23:49,270 --> 00:23:51,580
the source IP, source port, and timestamp

456
00:23:51,580 --> 00:23:54,439
that will uniquely identify these traffic,

457
00:23:54,440 --> 00:23:57,580
so that we get second half
of the traffic going out,

458
00:23:57,580 --> 00:24:00,620
we get a real destination IP address.

459
00:24:00,620 --> 00:24:03,040
So this one seems to be familiar, okay,

460
00:24:03,040 --> 00:24:06,350
this is network storage
sensitive data here,

461
00:24:06,350 --> 00:24:07,270
we still don't know

462
00:24:07,270 --> 00:24:10,580
what are the other network
traffic IP addresses.

463
00:24:10,580 --> 00:24:12,342
We can do some of the,

464
00:24:14,120 --> 00:24:17,399
kind of IP address enrichment.

465
00:24:17,400 --> 00:24:18,400
Yes, we can.

466
00:24:18,400 --> 00:24:21,980
We can apply the second analytics
here to help us do that.

467
00:24:21,980 --> 00:24:24,173
That's the destination IP enrichment.

468
00:24:25,490 --> 00:24:30,383
And then we can display
the information there.

469
00:24:31,550 --> 00:24:33,550
Basically, this is analytics

470
00:24:33,550 --> 00:24:36,190
that's run live in a docker container

471
00:24:36,190 --> 00:24:38,010
to reach out who is, server is,

472
00:24:38,010 --> 00:24:41,780
to get the domain name
and corporation back.

473
00:24:41,780 --> 00:24:45,770
So that we see that not only
it's internal sending one

474
00:24:45,770 --> 00:24:49,970
it's also reach out to some
of the external Twitter IP

475
00:24:49,970 --> 00:24:51,270
and Cloudflare.

476
00:24:51,270 --> 00:24:54,070
This looks like data exfiltration.

477
00:24:54,070 --> 00:24:55,053
Are we sure?

478
00:24:56,110 --> 00:24:59,689
So we can get some other help from

479
00:25:02,000 --> 00:25:05,310
one of the data exfiltration
model that I've used

480
00:25:05,310 --> 00:25:07,879
within the last couple of weeks

481
00:25:07,880 --> 00:25:11,710
that digest the normal traffic from StarX

482
00:25:12,609 --> 00:25:14,370
about which server usually (indistinct)

483
00:25:14,370 --> 00:25:16,739
which type of traffic,
which IP address is,

484
00:25:16,740 --> 00:25:20,930
and try to decide whether
this is something suspicious,

485
00:25:20,930 --> 00:25:22,730
look like exfiltration or not.

486
00:25:22,730 --> 00:25:25,653
This is the third analytics we can run.

487
00:25:27,850 --> 00:25:30,860
So as you see, I piped the second and this

488
00:25:30,860 --> 00:25:32,189
on top of the first one,

489
00:25:32,190 --> 00:25:35,390
so that we can show the IP address

490
00:25:35,390 --> 00:25:37,410
with what we get from the first analytics

491
00:25:37,410 --> 00:25:40,380
and what we get from the second analytics.

492
00:25:40,380 --> 00:25:41,853
As it shows here,

493
00:25:43,070 --> 00:25:45,689
this is a highly likely data exfiltration

494
00:25:45,690 --> 00:25:47,220
to this IP address,

495
00:25:47,220 --> 00:25:48,380
given the model

496
00:25:48,380 --> 00:25:51,900
that viewed through the
last couple of weeks,

497
00:25:51,900 --> 00:25:54,520
and okay,

498
00:25:54,520 --> 00:25:56,000
then that's pretty good

499
00:25:56,000 --> 00:25:58,700
that we have a very easy hunt,

500
00:25:58,700 --> 00:26:00,570
get some of the very useful information.

501
00:26:00,570 --> 00:26:03,510
But one question we
still do not understand

502
00:26:03,510 --> 00:26:05,650
where the attacker is coming from.

503
00:26:07,700 --> 00:26:10,160
So we know that this is exploit,

504
00:26:10,160 --> 00:26:14,150
and can we get that incoming
traffic from this exploit?

505
00:26:14,150 --> 00:26:15,440
Exploited

506
00:26:15,440 --> 00:26:19,440
kind of process.

507
00:26:19,440 --> 00:26:21,630
We can find network traffic

508
00:26:24,290 --> 00:26:29,270
created by this process.

509
00:26:29,270 --> 00:26:31,410
We found zero network traffic,

510
00:26:31,410 --> 00:26:32,243
okay,

511
00:26:32,243 --> 00:26:36,470
that is because this one is
actually the forked process,

512
00:26:36,470 --> 00:26:38,633
and actually the nodeJS main process

513
00:26:38,633 --> 00:26:40,203
handles network traffic.

514
00:26:40,203 --> 00:26:45,203
What we can do is we can find,

515
00:26:45,450 --> 00:26:50,450
try to find the parent
process of this one,

516
00:26:51,070 --> 00:26:54,493
and then to find network
traffic from there,

517
00:26:55,370 --> 00:27:00,370
so that we can try to find
and display network traffic

518
00:27:00,690 --> 00:27:03,900
from the parent process of this exploit.

519
00:27:03,900 --> 00:27:05,060
Okay, we get that.

520
00:27:05,060 --> 00:27:07,100
This is destination IP

521
00:27:07,100 --> 00:27:10,629
which is our current investigating server

522
00:27:10,630 --> 00:27:13,535
and this is source,

523
00:27:13,535 --> 00:27:16,883
oh, it's coming from
insider's threats here,

524
00:27:18,050 --> 00:27:19,993
one of the employees' laptop.

525
00:27:20,970 --> 00:27:23,750
Fortunately, we have Sysmon running there

526
00:27:23,750 --> 00:27:26,600
so that we can ask server for more details

527
00:27:26,600 --> 00:27:27,433
about what happened

528
00:27:27,433 --> 00:27:29,900
within the, not server, the laptop.

529
00:27:29,900 --> 00:27:34,370
So this is network traffic that
viewed from the server side,

530
00:27:34,370 --> 00:27:36,726
but we can also have
the same network traffic

531
00:27:36,727 --> 00:27:39,990
but viewed from the Windows laptop side,

532
00:27:39,990 --> 00:27:44,990
so that we can do what's with
similarly for the curator

533
00:27:45,270 --> 00:27:49,553
that we try to match network
traffic from Windows laptop,

534
00:27:51,130 --> 00:27:52,840
one for one,

535
00:27:52,840 --> 00:27:57,840
and then we match it from
their destination IP address

536
00:27:59,950 --> 00:28:00,990
and source port,

537
00:28:00,990 --> 00:28:04,070
as well as timestamp that
will be automatically derived.

538
00:28:04,070 --> 00:28:05,537
So we get a similar network traffic,

539
00:28:05,537 --> 00:28:09,340
but this time, we get that
from the Windows laptop.

540
00:28:09,340 --> 00:28:12,753
So let's see which process get that.

541
00:28:16,032 --> 00:28:19,112
Created dnt display p,

542
00:28:20,690 --> 00:28:21,580
our name,

543
00:28:23,768 --> 00:28:24,610
command line.

544
00:28:24,610 --> 00:28:27,943
Let's get some of the
basic idea what happened.

545
00:28:28,830 --> 00:28:32,079
There is a powershell on the script,

546
00:28:32,079 --> 00:28:36,223
vaccine availability
jpeg that causes traffic,

547
00:28:37,381 --> 00:28:39,820
and penetrate into the server.

548
00:28:39,820 --> 00:28:40,653
So

549
00:28:41,650 --> 00:28:43,630
what's really is

550
00:28:49,010 --> 00:28:51,010
a parent process,

551
00:28:51,010 --> 00:28:52,073
let's see,

552
00:28:54,500 --> 00:28:57,753
and the parent process of the powershell

553
00:28:57,753 --> 00:29:01,342
is a email client, okay.

554
00:29:03,180 --> 00:29:04,910
That looks like this is something

555
00:29:07,510 --> 00:29:09,060
like a spam

556
00:29:10,650 --> 00:29:12,860
and the user just

557
00:29:13,950 --> 00:29:14,950
created by,

558
00:29:14,950 --> 00:29:16,040
sorry, that's here,

559
00:29:16,040 --> 00:29:21,040
I try to match the child
process of the powershell

560
00:29:22,790 --> 00:29:25,350
to see what else the attacker did.

561
00:29:25,350 --> 00:29:27,639
Okay, lot of pings,

562
00:29:27,640 --> 00:29:31,760
and then open-end jpeg.

563
00:29:31,760 --> 00:29:34,490
Okay, that's expected.

564
00:29:34,490 --> 00:29:38,900
So that basically currently
we have a good idea

565
00:29:38,900 --> 00:29:41,680
what happens for the attack.

566
00:29:41,680 --> 00:29:44,837
So let's write summary about attack.

567
00:29:45,909 --> 00:29:48,930
And the source of attack happens

568
00:29:48,930 --> 00:29:53,200
when there was a phishing email
going into the email client

569
00:29:53,200 --> 00:29:57,310
that was clicked by the
employee on this machine

570
00:29:57,310 --> 00:30:00,840
and the powershell script penetrates

571
00:30:00,840 --> 00:30:03,350
into another server, vulnerable server,

572
00:30:03,350 --> 00:30:06,718
and then has the C&C established

573
00:30:06,719 --> 00:30:09,200
and exfiltrate data out through Twitter.

574
00:30:09,200 --> 00:30:10,983
That's all about the attack.

575
00:30:12,200 --> 00:30:13,033
That's good.

576
00:30:14,400 --> 00:30:16,090
Thank you for watching.

577
00:30:16,090 --> 00:30:17,523
This is entire hunt.

578
00:30:19,760 --> 00:30:20,593
- Okay.

579
00:30:20,593 --> 00:30:24,740
As we just demonstrated with
Kestrel hunting language,

580
00:30:24,740 --> 00:30:27,130
you can easily connect and correlate

581
00:30:27,130 --> 00:30:29,320
with your multiple data sources

582
00:30:29,320 --> 00:30:31,973
and start building your
own hunting pattern.

583
00:30:32,840 --> 00:30:35,600
And you can even share your
advanced hunting analytics

584
00:30:35,600 --> 00:30:37,290
with open source community,

585
00:30:37,290 --> 00:30:40,730
and you can also learn from
more experienced threat hunters

586
00:30:40,730 --> 00:30:42,930
by (indistinct) their huntflows.

587
00:30:42,930 --> 00:30:45,130
And we share more detailed information

588
00:30:45,130 --> 00:30:48,870
about how to start using
our open source Kestrel

589
00:30:48,870 --> 00:30:50,370
during the Q&A session.

590
00:30:50,370 --> 00:30:52,679
We'd like close by thanking everyone

591
00:30:52,680 --> 00:30:55,890
who has supported and
contributed to Kestrel,

592
00:30:55,890 --> 00:30:57,600
and thank for visiting our talk

593
00:30:57,600 --> 00:31:00,004
and we are happy to take any questions.

594
00:31:00,004 --> 00:31:01,087
- Thank you.

