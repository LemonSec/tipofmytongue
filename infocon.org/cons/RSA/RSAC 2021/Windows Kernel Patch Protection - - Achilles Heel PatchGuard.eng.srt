1
00:00:01,050 --> 00:00:02,100
- Hey everybody,

2
00:00:02,100 --> 00:00:03,940
I'm so excited to finally talk to you guys

3
00:00:03,940 --> 00:00:08,760
at the RSA 2021 Virtual
Conference about my presentation,

4
00:00:08,760 --> 00:00:12,379
Windows Kernel Patch
Protections-Achilles Heel: PatchGuard.

5
00:00:12,380 --> 00:00:15,683
My name is Arush Agarampur, and
let's get started right now.

6
00:00:16,560 --> 00:00:18,840
So let's start with a little bit about me.

7
00:00:18,840 --> 00:00:21,009
I'm a High School senior at
Amador Valley High School

8
00:00:21,010 --> 00:00:22,350
in Pleasanton, California.

9
00:00:22,350 --> 00:00:24,510
I'm a self taught programmer,
and I love working

10
00:00:24,510 --> 00:00:25,960
with the Windows operating system

11
00:00:25,960 --> 00:00:30,010
and all sorts of programming,
such as the kernel, internals.

12
00:00:30,010 --> 00:00:33,840
Other technologies such as
RPC, COM, DCOM, et cetera.

13
00:00:33,840 --> 00:00:36,900
And I also have a few
privilege escalation projects

14
00:00:36,900 --> 00:00:39,030
which you can find on my GitHub page,

15
00:00:39,030 --> 00:00:41,040
and they work with code integrity systems

16
00:00:41,040 --> 00:00:42,360
of the operating system.

17
00:00:42,360 --> 00:00:43,890
However that's enough about me,

18
00:00:43,890 --> 00:00:45,383
let's get started right now.

19
00:00:46,670 --> 00:00:48,320
All right so what's the agenda

20
00:00:48,320 --> 00:00:50,200
for our presentation?

21
00:00:50,200 --> 00:00:51,960
We're gonna be talking
about Window's Kernel

22
00:00:51,960 --> 00:00:55,420
Patch Protections or internally,
it's called PatchGuard.

23
00:00:55,420 --> 00:00:57,320
And we will just go over a few objectives

24
00:00:57,320 --> 00:01:01,370
about why you would be
attacking PatchGuard in 2021.

25
00:01:01,370 --> 00:01:03,140
And then, we'll go over an intro

26
00:01:03,140 --> 00:01:05,450
to the Kernel Patch Protection engine,

27
00:01:05,450 --> 00:01:09,440
we will go over and go
through its response analysis.

28
00:01:09,440 --> 00:01:12,210
And after that, we'll have
the bulk of the presentation

29
00:01:12,210 --> 00:01:14,360
which is our attack walkthrough.

30
00:01:14,360 --> 00:01:17,840
After our attack walkthrough,
we will have a short demo

31
00:01:17,840 --> 00:01:20,880
and then I'll go over some
problems and improvements

32
00:01:20,880 --> 00:01:22,649
that's with my attack right here.

33
00:01:22,650 --> 00:01:26,130
In end we'll talk about a
mitigation and next steps

34
00:01:26,130 --> 00:01:29,350
for a commercial, enterprise
and even home users,

35
00:01:29,350 --> 00:01:31,720
anybody who uses Microsoft
products and Windows

36
00:01:31,720 --> 00:01:35,030
and at the end, we will
finally answer some questions.

37
00:01:35,030 --> 00:01:37,370
And if you guys do have
questions along the way,

38
00:01:37,370 --> 00:01:39,720
feel free to just ask them in the Q&A

39
00:01:39,720 --> 00:01:41,670
as you can ask them at any time.

40
00:01:41,670 --> 00:01:43,343
All right, so let's get started.

41
00:01:44,450 --> 00:01:45,283
So the objectives,

42
00:01:45,283 --> 00:01:46,850
why even bother with something

43
00:01:46,850 --> 00:01:49,470
like Kernel Patch Protection in 2021?

44
00:01:49,470 --> 00:01:51,929
Well the kernel is the heart
of the operating system,

45
00:01:51,930 --> 00:01:53,540
and it encompasses everything,

46
00:01:53,540 --> 00:01:55,443
it runs everything zero.

47
00:01:58,678 --> 00:02:00,070
It has a maximum privilege of anything

48
00:02:00,070 --> 00:02:01,869
you can do on your computer

49
00:02:01,870 --> 00:02:04,260
and if you're able to
compromise the kernel,

50
00:02:04,260 --> 00:02:06,300
you can bypass most of the standard

51
00:02:06,300 --> 00:02:08,190
security features in Windows.

52
00:02:08,190 --> 00:02:11,570
Now it's important to remember
that it's isn't just Windows,

53
00:02:11,570 --> 00:02:13,280
every operating system has a kernel

54
00:02:13,280 --> 00:02:16,140
because everything we do
happens at the kernel.

55
00:02:16,140 --> 00:02:18,410
Now why should we protect the kernel?

56
00:02:18,410 --> 00:02:21,280
Well, if your kernel is compromised

57
00:02:21,280 --> 00:02:23,210
you can spy on data requests,

58
00:02:23,210 --> 00:02:24,860
you get complete access to hardware

59
00:02:24,860 --> 00:02:27,810
and obviously that's not a good
thing that should happened.

60
00:02:28,650 --> 00:02:32,240
So what even is Kernel
Patch Protection anyways?

61
00:02:32,240 --> 00:02:34,600
Well it's a system that
was designed to detect

62
00:02:34,600 --> 00:02:37,670
and respond to unauthorized
kernel code modifications.

63
00:02:37,670 --> 00:02:40,541
Microsoft introduced it back in 2005

64
00:02:40,541 --> 00:02:44,160
with the introduction of Windows XP

65
00:02:44,160 --> 00:02:47,770
on 64-bit additions with server path one.

66
00:02:47,770 --> 00:02:50,550
Now patching the kernel like
I said are just modifications

67
00:02:50,550 --> 00:02:53,090
and it's never been
supported by Microsoft.

68
00:02:53,090 --> 00:02:55,260
However, this system was introduced

69
00:02:55,260 --> 00:02:58,049
to detect those modifications
and bring the system down

70
00:02:58,050 --> 00:02:59,440
in case one is detected

71
00:02:59,440 --> 00:03:01,710
to prevent further security compromise,

72
00:03:01,710 --> 00:03:03,110
it's like a bank alarm.

73
00:03:03,110 --> 00:03:06,440
It does not stop the actual
bank robbery from happening,

74
00:03:06,440 --> 00:03:08,450
but it goes off when one is detected.

75
00:03:08,450 --> 00:03:11,510
And PatchGuard simply follows this cycle

76
00:03:11,510 --> 00:03:14,840
where it initializes
sleeps, it does a check,

77
00:03:14,840 --> 00:03:17,973
and then it takes a response
action if necessary.

78
00:03:19,630 --> 00:03:22,609
All right so what exactly
does Kernel Patch Protection

79
00:03:22,610 --> 00:03:24,230
check in the first place?

80
00:03:24,230 --> 00:03:26,019
Well of course it's gonna check itself

81
00:03:26,020 --> 00:03:29,120
and it checks the kernel in
its associated data structures,

82
00:03:29,120 --> 00:03:31,600
if they have been tampered
or modified in any way,

83
00:03:31,600 --> 00:03:33,340
now what are those data structures?

84
00:03:33,340 --> 00:03:36,700
It is pretty simple, they just
check three main categories

85
00:03:36,700 --> 00:03:39,739
the generic data regions,
CPU data structures,

86
00:03:39,740 --> 00:03:41,710
and object types.

87
00:03:41,710 --> 00:03:43,840
Now I won't list them all
out as they're on screen

88
00:03:43,840 --> 00:03:46,910
but these are core data
structures used by the operating

89
00:03:46,910 --> 00:03:50,549
system almost every second during uptime.

90
00:03:50,550 --> 00:03:52,400
But however Kernel Patch Protection

91
00:03:52,400 --> 00:03:56,150
does not prevent other
modules from being modified

92
00:03:56,150 --> 00:04:00,000
except a few, such as the
win32k family series of drivers

93
00:04:00,000 --> 00:04:03,200
which provide your user
interface GUI functionality

94
00:04:03,200 --> 00:04:04,320
for the operating system

95
00:04:04,320 --> 00:04:07,940
and the code integrity module CI.dll.

96
00:04:07,940 --> 00:04:09,230
And there are probably some others

97
00:04:09,230 --> 00:04:10,929
which I hadn't figured out yet

98
00:04:10,930 --> 00:04:12,813
but there are a few exempt modules.

99
00:04:14,580 --> 00:04:17,430
All right so let's dig
into the response analysis

100
00:04:17,430 --> 00:04:18,570
of Kernel Patch Protection.

101
00:04:18,570 --> 00:04:20,399
We know what it is and
we know what it checks,

102
00:04:20,399 --> 00:04:23,539
but what actually happens
when something detected?

103
00:04:23,540 --> 00:04:26,050
Well what can you do when
something is detected?

104
00:04:26,050 --> 00:04:27,820
It's not like you can go back and fix it

105
00:04:27,820 --> 00:04:29,890
because you don't know
how it would modify.

106
00:04:29,890 --> 00:04:31,919
So the only logical thing that will happen

107
00:04:31,920 --> 00:04:33,770
is bringing this system down.

108
00:04:33,770 --> 00:04:36,799
There are two main stages
when you crash the system

109
00:04:36,800 --> 00:04:38,887
you will prepare for a system crash

110
00:04:38,887 --> 00:04:40,810
and then actually crash the system.

111
00:04:40,810 --> 00:04:42,240
How does this work?

112
00:04:42,240 --> 00:04:45,100
Well Kernel Patch Protection will first

113
00:04:45,100 --> 00:04:47,340
capture some information
about the corruption

114
00:04:47,340 --> 00:04:49,719
and then it will rewrite the callstack.

115
00:04:49,720 --> 00:04:52,000
And after it rewrite the
callstack it will rewrite

116
00:04:52,000 --> 00:04:53,070
and saved routines,

117
00:04:53,070 --> 00:04:55,690
and then destroy the callstack in the end.

118
00:04:55,690 --> 00:04:57,110
Now what does that do?

119
00:04:57,110 --> 00:04:58,990
Well I'll explain that
later, but we first need

120
00:04:58,990 --> 00:05:01,450
to understand the actual
bug check process.

121
00:05:01,450 --> 00:05:02,283
And what is that?

122
00:05:02,283 --> 00:05:04,140
That's basically what the function

123
00:05:04,140 --> 00:05:06,659
KeBugCheckEx as it is does.

124
00:05:06,660 --> 00:05:09,550
It brings down the
system and causes a BSOD.

125
00:05:09,550 --> 00:05:11,520
Now what are the saved critical routines?

126
00:05:11,520 --> 00:05:14,109
They are basically
routines that are important

127
00:05:14,110 --> 00:05:15,190
in the bug check process

128
00:05:15,190 --> 00:05:18,050
routines functions, the interchangeable.

129
00:05:18,050 --> 00:05:20,060
Some of these are listed on the screen

130
00:05:20,060 --> 00:05:21,630
and there are probably many, many, more

131
00:05:21,630 --> 00:05:24,260
that are also critical but
I'm not just gonna list them.

132
00:05:24,260 --> 00:05:26,130
And one of the pictures,
there is an example

133
00:05:26,130 --> 00:05:28,180
of a destroyed callsack from PatchGuard

134
00:05:28,180 --> 00:05:31,780
as you can see, the first color
in the list is KeBugCheckEx

135
00:05:31,780 --> 00:05:34,559
you have no idea what was called before.

136
00:05:34,560 --> 00:05:37,480
The classic security through
obscurity model is used

137
00:05:37,480 --> 00:05:40,070
here because you don't want
to know what caused the crash

138
00:05:40,070 --> 00:05:41,020
in the first place.

139
00:05:42,660 --> 00:05:44,830
All right so now that we know what happens

140
00:05:44,830 --> 00:05:48,159
before a crash is issued how do we...

141
00:05:48,160 --> 00:05:50,130
We need to understand what happens

142
00:05:50,130 --> 00:05:51,800
when the system is brought down.

143
00:05:51,800 --> 00:05:54,500
So like I said, PatchGuard
will eventually call

144
00:05:54,500 --> 00:05:57,530
KeBugCheckEx when a crash is detected.

145
00:05:57,530 --> 00:05:58,809
Now what does that do?

146
00:05:58,810 --> 00:06:01,070
All it does is collect the CPU context,

147
00:06:01,070 --> 00:06:04,830
and sets the current
IRQL to dispatch level.

148
00:06:04,830 --> 00:06:07,080
After that it's simply
increments the global variable

149
00:06:07,080 --> 00:06:10,310
KiHardwarTrigger, and that
is shown in the assembly

150
00:06:10,310 --> 00:06:11,143
on the right.

151
00:06:11,143 --> 00:06:12,559
It was the first picture

152
00:06:12,560 --> 00:06:15,750
as you can see it calls RtlCaptureContext

153
00:06:16,700 --> 00:06:19,219
to store the current process context

154
00:06:19,220 --> 00:06:21,750
in the kernel processor control block

155
00:06:21,750 --> 00:06:24,830
which is a special
control block used for CPU

156
00:06:24,830 --> 00:06:26,810
on a pursuit (indistinct) basis.

157
00:06:26,810 --> 00:06:28,900
And after that it does some modifications

158
00:06:28,900 --> 00:06:32,260
on RtlCaptureContext so
it does not represent

159
00:06:32,260 --> 00:06:35,200
the context of KeBuCheck itself

160
00:06:35,200 --> 00:06:37,783
and it represents the
context of the color.

161
00:06:38,670 --> 00:06:41,260
After doing that you can
see it simply increments

162
00:06:41,260 --> 00:06:43,250
KiHardwareTrigger with a lot prefix

163
00:06:43,250 --> 00:06:45,500
because it's an atonic operation,

164
00:06:45,500 --> 00:06:47,800
and after that it will
simply call KeBuCheck2.

165
00:06:48,898 --> 00:06:53,170
A KeBuCheck2 is where
everything actually happens,

166
00:06:53,170 --> 00:06:54,190
you're using computer

167
00:06:54,190 --> 00:06:56,420
everyone knows these
(indistinct) blue screen

168
00:06:56,420 --> 00:06:57,920
millions of people have heard of them.

169
00:06:57,920 --> 00:06:59,040
Where does that actually happen?

170
00:06:59,040 --> 00:07:00,820
That's where this happens.

171
00:07:00,820 --> 00:07:03,430
What it does is it spends
most of its time preparing

172
00:07:03,430 --> 00:07:06,040
information and it'll
eventually write a crashdump

173
00:07:06,040 --> 00:07:07,270
which is what you see when it says

174
00:07:07,270 --> 00:07:09,090
collecting air information,

175
00:07:09,090 --> 00:07:11,619
and it will freeze
execution on other CPUs.

176
00:07:11,620 --> 00:07:14,040
Because the only sequence
of execution that we want

177
00:07:14,040 --> 00:07:16,340
is gonna be on the current CPU.

178
00:07:16,340 --> 00:07:18,950
After that, it will simply
display the blue screen

179
00:07:18,950 --> 00:07:20,050
we all know and love,

180
00:07:20,050 --> 00:07:22,900
which is basically the
function KiDisplayBlueScreen.

181
00:07:22,900 --> 00:07:25,120
And in the end it will reboot or break

182
00:07:25,120 --> 00:07:26,793
into the kernel debugger.

183
00:07:29,390 --> 00:07:31,620
All right so now that we
know what actually happens

184
00:07:31,620 --> 00:07:35,460
during the bug check process
such as if it will break

185
00:07:35,460 --> 00:07:37,930
into kernel debugger or
not it will just review

186
00:07:37,930 --> 00:07:38,763
what information is collected

187
00:07:38,763 --> 00:07:41,590
we can start to go over some flaws.

188
00:07:41,590 --> 00:07:45,270
Now there is a number of
flaws but the biggest one

189
00:07:45,270 --> 00:07:47,180
which you guys can probably tell

190
00:07:47,180 --> 00:07:50,280
is that this all happens
in ring 0 memory space.

191
00:07:50,280 --> 00:07:54,260
So everything happens
in the same memory space

192
00:07:54,260 --> 00:07:56,890
PatchGuard, kernel, other drivers

193
00:07:56,890 --> 00:07:58,560
they are all in the memory space.

194
00:07:58,560 --> 00:08:02,543
So without even needing to
design and formulate an attack,

195
00:08:02,543 --> 00:08:05,640
you can already tell if something
is the same memory space,

196
00:08:05,640 --> 00:08:08,090
with the same permission,
with the same everything,

197
00:08:08,090 --> 00:08:11,340
it is possible theoretically
to circumvent any insecurity

198
00:08:11,340 --> 00:08:13,479
product that runs in
(indistinct) memory space

199
00:08:13,480 --> 00:08:17,620
because there is no physical
hardware bound isolation

200
00:08:17,620 --> 00:08:19,880
between the two, like if
you're running on a ring 1

201
00:08:19,880 --> 00:08:22,620
or ring 2, on user mode which is ring 3.

202
00:08:22,620 --> 00:08:24,310
The second major flaw that we have

203
00:08:24,310 --> 00:08:26,010
are the missing protections,

204
00:08:26,010 --> 00:08:27,690
now PatchGuard of course is being used

205
00:08:27,690 --> 00:08:30,160
on every single Windows
operating system, right?

206
00:08:30,160 --> 00:08:34,010
That goes for phone, mobile, server, Xbox

207
00:08:34,010 --> 00:08:36,220
almost everything that
runs the empty kernel.

208
00:08:36,220 --> 00:08:38,309
So of course you are
going to have some things

209
00:08:38,309 --> 00:08:39,500
that are not protected,

210
00:08:39,500 --> 00:08:41,350
but however certain
things should be protected

211
00:08:41,350 --> 00:08:44,250
because they are critical
to system security

212
00:08:44,250 --> 00:08:48,290
such as the .data section of
the kernel is not protected

213
00:08:48,290 --> 00:08:52,300
When you can do things
like modified tables,

214
00:08:52,300 --> 00:08:55,109
global variables and other
things in the .data section

215
00:08:55,110 --> 00:08:57,967
since it's not protected by
.text or .idata or .edata.

216
00:08:59,300 --> 00:09:01,500
The other thing that's
not protected is padding.

217
00:09:01,500 --> 00:09:03,543
Padding, if you're familiar with padding

218
00:09:03,543 --> 00:09:06,840
it's just a block of zeros
in one of these sections,

219
00:09:06,840 --> 00:09:08,480
but why are they important?

220
00:09:08,480 --> 00:09:11,050
Well that's because PatchGuard

221
00:09:11,050 --> 00:09:13,209
has a way of detecting callbacks

222
00:09:13,210 --> 00:09:15,620
that are not registered within drivers.

223
00:09:15,620 --> 00:09:19,210
If you manly map drivers where
they aren't supposed to be

224
00:09:19,210 --> 00:09:21,730
normally you would create
a callback into your driver

225
00:09:21,730 --> 00:09:24,070
which is not in the loaded modules.

226
00:09:24,070 --> 00:09:27,660
However since padding is
not protected in PatchGuard,

227
00:09:27,660 --> 00:09:30,829
you can simply insert your
own jumps into the padding

228
00:09:30,830 --> 00:09:32,670
and just like that you got around one

229
00:09:32,670 --> 00:09:34,349
of PatchGuard detection mechanisms.

230
00:09:34,350 --> 00:09:36,760
The padding should be
protected because it completely

231
00:09:36,760 --> 00:09:38,400
allows you to use callbacks

232
00:09:38,400 --> 00:09:40,350
that aren't even in the loaded modules.

233
00:09:41,500 --> 00:09:43,860
And the biggest problem with this response

234
00:09:43,860 --> 00:09:46,050
are the missing save routines.

235
00:09:46,050 --> 00:09:48,260
Now these save routines are exploitable

236
00:09:48,260 --> 00:09:50,760
and it's what makes this attack possible.

237
00:09:50,760 --> 00:09:53,020
However, like I said not every single

238
00:09:53,020 --> 00:09:55,020
saved routine needs to be safe

239
00:09:55,020 --> 00:09:57,877
because some of them are
inlined or are used many times

240
00:09:57,877 --> 00:10:00,670
you probably won't have to rewrite them.

241
00:10:00,670 --> 00:10:04,209
However some routines such
as the ones we'll talk about

242
00:10:04,210 --> 00:10:07,030
are necessary to be saved in kernel

243
00:10:07,030 --> 00:10:10,449
because these routines can
be used to snatch execution

244
00:10:10,450 --> 00:10:13,570
and sabotage the password
response process.

245
00:10:13,570 --> 00:10:15,323
So what exactly are these routines?

246
00:10:16,840 --> 00:10:20,580
Well there is one exploitable
unprotected routine

247
00:10:20,580 --> 00:10:21,903
called memset.

248
00:10:22,860 --> 00:10:24,840
Memset, you're probably thinking memset

249
00:10:24,840 --> 00:10:27,560
oh come on that's like
what every c programmer

250
00:10:27,560 --> 00:10:30,109
learned when they just started.

251
00:10:30,110 --> 00:10:31,290
Well yeah that's what this attack

252
00:10:31,290 --> 00:10:33,040
is actually based off, memset.

253
00:10:33,040 --> 00:10:35,790
And you can see this attack is very simple

254
00:10:35,790 --> 00:10:38,829
all we'll do is we will
stop the password response

255
00:10:38,830 --> 00:10:42,080
by calling memset or when memset is called

256
00:10:42,080 --> 00:10:44,870
all will do is check if the
current call is KeBuCheck2

257
00:10:44,870 --> 00:10:48,610
which means is being called
in a blue screen scenario.

258
00:10:48,610 --> 00:10:51,580
If it is, we will check
the first parameter of RCX

259
00:10:51,580 --> 00:10:53,640
that was past KeBuCheckEx,

260
00:10:53,640 --> 00:10:57,050
remember because KeBuCheck
install the KeBuCheckEx.

261
00:10:57,050 --> 00:11:00,680
If that is equal to 0x109
which is a crash dump code

262
00:11:00,680 --> 00:11:02,359
that PatchGuard uses

263
00:11:02,360 --> 00:11:06,220
then will simply still
execution and stop it forever.

264
00:11:06,220 --> 00:11:08,680
Otherwise if either of those cases fail

265
00:11:08,680 --> 00:11:10,060
we will simply jump to our own

266
00:11:10,060 --> 00:11:12,550
driver implemented memset intrinsic

267
00:11:12,550 --> 00:11:14,819
and then we'll simply
return to the external code

268
00:11:14,820 --> 00:11:17,340
so we do the operation that was wanted.

269
00:11:17,340 --> 00:11:20,040
And just as a slide say
you're probably thinking

270
00:11:20,040 --> 00:11:23,410
this isn't even a great
attack because it's a super

271
00:11:23,410 --> 00:11:26,280
simple function like I said
memset is so primitive,

272
00:11:26,280 --> 00:11:28,775
it's used by almost all C code

273
00:11:28,775 --> 00:11:31,459
all threads running on the system.

274
00:11:31,460 --> 00:11:33,140
You're probably thinking
that it can't really stop

275
00:11:33,140 --> 00:11:35,400
an entire operating system
from running, right?

276
00:11:35,400 --> 00:11:37,220
Well yeah, that's what I also thought

277
00:11:37,220 --> 00:11:38,970
until I figured out how to actually do it

278
00:11:38,970 --> 00:11:43,423
because attacking memset isn't
the real problem at hand.

279
00:11:45,880 --> 00:11:48,980
It's figuring out how to attack memset,

280
00:11:48,980 --> 00:11:52,810
so my attack will simply use
memeset to hook execution

281
00:11:52,810 --> 00:11:54,109
like I just said.

282
00:11:54,110 --> 00:11:57,500
However there's a problem
with that, it's been called

283
00:11:57,500 --> 00:12:00,173
so many times every second.

284
00:12:01,160 --> 00:12:02,900
Because it's so easy to understand

285
00:12:02,900 --> 00:12:05,340
and use it used all the
time like I just said.

286
00:12:05,340 --> 00:12:07,510
Like how many times probably a second,

287
00:12:07,510 --> 00:12:08,880
it's actually probably
been called millions

288
00:12:08,880 --> 00:12:11,920
of billions of times a
second and that is a lot.

289
00:12:11,920 --> 00:12:15,199
Now as fast as computers are today,

290
00:12:15,200 --> 00:12:16,420
you know how fast they are

291
00:12:16,420 --> 00:12:20,870
so interest swapping code
bites to simply hook a function

292
00:12:20,870 --> 00:12:22,880
you may think that it could be fast enough

293
00:12:22,880 --> 00:12:24,510
and sure it can be.

294
00:12:24,510 --> 00:12:27,150
You can write two threads
that are completely racing

295
00:12:27,150 --> 00:12:29,220
against each other and
attempt to patch them

296
00:12:29,220 --> 00:12:31,060
and most of the time it will work.

297
00:12:31,060 --> 00:12:32,619
But not with this function

298
00:12:32,620 --> 00:12:35,280
it is being called by every
single grid on the system

299
00:12:35,280 --> 00:12:37,477
probably billions of times a second

300
00:12:37,477 --> 00:12:41,310
and that is a major obstacle
that we have to get over

301
00:12:41,310 --> 00:12:44,089
because like the diagram
shows if you can see,

302
00:12:44,090 --> 00:12:45,510
if you try to write directly to memset

303
00:12:45,510 --> 00:12:47,069
you're just gonna jam everything up

304
00:12:47,070 --> 00:12:49,943
and you have a locked up
system with nowhere to go.

305
00:12:52,120 --> 00:12:55,730
So if only there was a way we
good catch execution, right?

306
00:12:55,730 --> 00:12:59,030
Well there actually is, CPU
debug registers to the rescue.

307
00:12:59,030 --> 00:13:01,220
Now what I found out
about CPU debug registers

308
00:13:01,220 --> 00:13:02,980
I almost forgot that
I could have used them

309
00:13:02,980 --> 00:13:05,910
for this purpose, but they're
extremely helpful for us

310
00:13:05,910 --> 00:13:09,560
because we can actually
use them to steal execution

311
00:13:09,560 --> 00:13:13,359
of a thread at any point in memory.

312
00:13:13,360 --> 00:13:14,270
So what happens?

313
00:13:14,270 --> 00:13:16,340
When you do use CPU debug registers,

314
00:13:16,340 --> 00:13:17,770
you're actually just
going to raise interrupt

315
00:13:17,770 --> 00:13:20,960
that (indistinct) number one
when something to be read,

316
00:13:20,960 --> 00:13:25,860
written or executed depending
on the flags you specify.

317
00:13:25,860 --> 00:13:27,090
Is this abusable?

318
00:13:27,090 --> 00:13:29,593
It seems like it's abusable
to me, so how do we abuse it?

319
00:13:29,593 --> 00:13:31,949
It should be pretty simple, right?

320
00:13:31,950 --> 00:13:34,080
we can write up a function to hook

321
00:13:34,080 --> 00:13:36,470
the interrupt descriptor table,

322
00:13:36,470 --> 00:13:39,830
and then that function will
hijack the current handler

323
00:13:39,830 --> 00:13:44,690
for vector one and pointed
to our own handler.

324
00:13:44,690 --> 00:13:47,450
And since every CPU has its
own interrupt descriptor table

325
00:13:47,450 --> 00:13:49,540
we'll call that function to hook the table

326
00:13:49,540 --> 00:13:51,569
on all of the processors.

327
00:13:51,570 --> 00:13:54,170
After we do that all we'll
need is another function

328
00:13:54,170 --> 00:13:55,569
to initialize the debug registers

329
00:13:55,570 --> 00:13:58,223
with every CPU has its
own debug registers.

330
00:13:59,090 --> 00:14:01,520
And then we will call that
initialization function

331
00:14:01,520 --> 00:14:02,930
on our processors.

332
00:14:02,930 --> 00:14:06,170
A super simple thing
but CPU debug registers

333
00:14:06,170 --> 00:14:07,853
are actually very helpful to us.

334
00:14:10,100 --> 00:14:11,600
So how do we do this?

335
00:14:11,600 --> 00:14:13,600
Well it is pretty simple actually,

336
00:14:13,600 --> 00:14:15,070
let's just start looking at the code.

337
00:14:15,070 --> 00:14:17,310
The first thing we have is a function

338
00:14:17,310 --> 00:14:19,979
as you can see which is called RlInitDr.

339
00:14:19,980 --> 00:14:20,940
It's very simple,

340
00:14:20,940 --> 00:14:23,490
it follows a prototype used for IPI calls.

341
00:14:23,490 --> 00:14:25,180
Now what are IPI calls?

342
00:14:25,180 --> 00:14:27,609
They are called
inter-processor interrupt calls

343
00:14:27,610 --> 00:14:30,670
and they're basically calls
which execute on all CPU

344
00:14:30,670 --> 00:14:31,719
at the same time.

345
00:14:31,720 --> 00:14:32,860
That is what I'll be able using

346
00:14:32,860 --> 00:14:34,940
to call this function on all CPUs.

347
00:14:36,150 --> 00:14:40,770
So our IPI call over
here will simply write

348
00:14:40,770 --> 00:14:43,410
to debug register seven and it will say,

349
00:14:43,410 --> 00:14:46,449
hey I want to break on execution

350
00:14:46,450 --> 00:14:48,670
and the size of my break
point will be zero.

351
00:14:48,670 --> 00:14:51,579
Because you need to specify a size zero

352
00:14:51,580 --> 00:14:53,253
execution break point.

353
00:14:54,320 --> 00:14:57,610
After that it will simply
write to debug register zero

354
00:14:57,610 --> 00:14:59,460
because I told dr7,

355
00:14:59,460 --> 00:15:02,940
all right look the break point
I want is going to be in dr0.

356
00:15:02,940 --> 00:15:05,040
So the right to the dr0
is the target address

357
00:15:05,040 --> 00:15:06,790
now what is our target address?

358
00:15:06,790 --> 00:15:08,467
It will simply be memset.

359
00:15:09,490 --> 00:15:12,210
Now we need that function to actually hook

360
00:15:12,210 --> 00:15:13,430
the interrupt descriptor table

361
00:15:13,430 --> 00:15:15,670
because of all our stuff won't work

362
00:15:15,670 --> 00:15:17,189
if you don't have hook the current

363
00:15:17,190 --> 00:15:18,760
interrupt descriptor table,

364
00:15:18,760 --> 00:15:19,750
how do we do that?

365
00:15:19,750 --> 00:15:22,920
Well there comes a second
function as it says on screen.

366
00:15:22,920 --> 00:15:23,949
It's pretty simple

367
00:15:23,950 --> 00:15:25,520
as you can see one of the first lines

368
00:15:25,520 --> 00:15:28,189
is just to save the current
interrupt descriptor table

369
00:15:28,190 --> 00:15:29,420
in a structure.

370
00:15:29,420 --> 00:15:31,243
After that we'll simply take its base

371
00:15:31,244 --> 00:15:33,520
and add 16 times one or just 16 to it

372
00:15:33,520 --> 00:15:36,383
because we have first selector in it.

373
00:15:37,296 --> 00:15:38,460
And after that we're simply going

374
00:15:38,460 --> 00:15:39,930
to flip the write protect bit.

375
00:15:39,930 --> 00:15:41,890
Now why are we flipping
the write protect bit?

376
00:15:41,890 --> 00:15:45,610
I thought you may have thought
that it's not good practice

377
00:15:45,610 --> 00:15:46,900
if the incremental code especially

378
00:15:46,900 --> 00:15:49,750
if you want to read or write
to read on the (indistinct)

379
00:15:49,750 --> 00:15:51,330
Well here's what we can do it.

380
00:15:51,330 --> 00:15:53,810
We're gonna be calling
this function at IPI level

381
00:15:53,810 --> 00:15:57,170
and if you don't want to
switch between processors

382
00:15:57,170 --> 00:15:59,040
and lose your current
control values to zero

383
00:15:59,040 --> 00:16:01,099
you need to be at least
this dispatch level.

384
00:16:01,100 --> 00:16:04,670
Our dispatch level is
two, IPI is way above two

385
00:16:04,670 --> 00:16:05,740
so we are fine.

386
00:16:05,740 --> 00:16:08,580
We can safely switch the write protect bit

387
00:16:08,580 --> 00:16:10,650
and now we can write
to read on (indistinct)

388
00:16:10,650 --> 00:16:13,069
After we switched that
bit, it's pretty simple

389
00:16:13,070 --> 00:16:14,860
all we do is just save the current entry

390
00:16:14,860 --> 00:16:16,520
because we're gonna need it later.

391
00:16:16,520 --> 00:16:19,110
So that's what we do, I'll save
it as returnValue out there

392
00:16:19,110 --> 00:16:21,530
it's simply part of the data table entry.

393
00:16:21,530 --> 00:16:23,370
And after that I'll
take the first parameter

394
00:16:23,370 --> 00:16:25,170
passes function called newIsr

395
00:16:26,010 --> 00:16:30,700
and that will take our IDT table

396
00:16:30,700 --> 00:16:33,430
and it will edit it according
to the low middle high offset

397
00:16:33,430 --> 00:16:36,609
and then it'll simply
set that to kind entry.

398
00:16:36,610 --> 00:16:38,920
In the end we're just gonna
the write protect bit again

399
00:16:38,920 --> 00:16:40,560
in case anyone else does snooping

400
00:16:40,560 --> 00:16:43,229
and then we say, hey your
write protective (indistinct)

401
00:16:43,230 --> 00:16:45,200
change it, you don't
want that's to happen.

402
00:16:45,200 --> 00:16:47,140
So we're just gonna set it back

403
00:16:47,140 --> 00:16:48,810
and then after that
we're simply gonna return

404
00:16:48,810 --> 00:16:49,910
the original entry.

405
00:16:49,910 --> 00:16:52,189
So this function will
hook the entry it's given

406
00:16:52,190 --> 00:16:55,090
and returning the original
entry, pretty straight forward.

407
00:16:56,097 --> 00:16:59,860
All right so we have a few functions,

408
00:16:59,860 --> 00:17:04,047
we have ones that will
actually hook the IDT,

409
00:17:05,319 --> 00:17:08,020
we have ones that will
initialize the debug registers

410
00:17:08,020 --> 00:17:11,139
but now we need to actually
create the servicing routine.

411
00:17:11,140 --> 00:17:13,520
Now this is what's being called

412
00:17:13,520 --> 00:17:16,119
when our interrupt one is raised

413
00:17:16,119 --> 00:17:17,709
because we gonna hook our IDT,

414
00:17:17,710 --> 00:17:18,920
we set the debug register

415
00:17:18,920 --> 00:17:20,170
so this is what's called.

416
00:17:21,021 --> 00:17:22,440
There's a few problems with this,

417
00:17:22,440 --> 00:17:23,784
well not problems, there's a few things

418
00:17:23,784 --> 00:17:25,579
you need to be careful.

419
00:17:25,579 --> 00:17:27,980
It is being called so many times

420
00:17:27,980 --> 00:17:30,280
because we were hooking
such a primitive function.

421
00:17:30,280 --> 00:17:33,040
It's hard to emphasize how
many times it's being called,

422
00:17:33,040 --> 00:17:35,370
but it's being called billions of times.

423
00:17:35,370 --> 00:17:38,429
And not just that, it's being
called on all different CPUs

424
00:17:38,430 --> 00:17:40,190
in all different IRQLs

425
00:17:40,190 --> 00:17:43,520
or hardware interrupt already levels.

426
00:17:43,520 --> 00:17:46,320
So there's a lot of things
we need to manage here

427
00:17:46,320 --> 00:17:48,870
because even on your simple computer,

428
00:17:48,870 --> 00:17:50,479
you probably have four calls

429
00:17:50,480 --> 00:17:53,670
so you need to be able to
manage the different IRQLs,

430
00:17:53,670 --> 00:17:57,030
of the different CPU's on your computer.

431
00:17:57,030 --> 00:17:58,620
Now how do we do that?

432
00:17:58,620 --> 00:18:00,090
Well there is no easy way to do it

433
00:18:00,090 --> 00:18:04,233
all we have to do is write
our ISR with extreme caution.

434
00:18:05,163 --> 00:18:06,510
And in the meanwhile,

435
00:18:06,510 --> 00:18:09,190
we will have our simple
driver in the background

436
00:18:09,190 --> 00:18:11,810
checking if our ISR is complete,

437
00:18:11,810 --> 00:18:15,980
if our ISR has successfully
completed the patching process.

438
00:18:15,980 --> 00:18:19,213
So how exactly did we do
that, should be pretty simple.

439
00:18:20,600 --> 00:18:23,179
So this may look intimidating at first

440
00:18:23,180 --> 00:18:24,270
but it is really not

441
00:18:24,270 --> 00:18:26,980
so let's dig into what
this is actually doing.

442
00:18:26,980 --> 00:18:28,780
Let's start all the way on the left,

443
00:18:29,640 --> 00:18:32,800
if we're writing an interrupt
service routine, right?

444
00:18:32,800 --> 00:18:34,350
You can't write it in plain C code

445
00:18:34,350 --> 00:18:38,360
at least with the default
MSNBC installation.

446
00:18:38,360 --> 00:18:39,870
So how are we gonna do this?

447
00:18:39,870 --> 00:18:42,291
Well all I have is some
simple massive assembly

448
00:18:42,291 --> 00:18:45,669
I'll say some registers
that need to be saved during

449
00:18:45,670 --> 00:18:47,390
the interrupt service routine,

450
00:18:47,390 --> 00:18:49,380
and then after that I'll
simply set up a stack

451
00:18:49,380 --> 00:18:52,400
and call the real function,
write my (indistinct)

452
00:18:52,400 --> 00:18:56,600
which is that line that says
call RlpDebugTrapOrFault.

453
00:18:56,600 --> 00:19:00,500
After we call that we will
simply destroy the stack

454
00:19:00,500 --> 00:19:04,360
by adding 28x to it, popping
off all the saved registers

455
00:19:04,360 --> 00:19:06,679
and we're done, you can
return from the intro.

456
00:19:06,680 --> 00:19:09,050
So this is basically a stub which we'll go

457
00:19:09,050 --> 00:19:12,320
on to our actual interrupt handler.

458
00:19:12,320 --> 00:19:15,250
Now the actual interrupt
handler is kind of tricky

459
00:19:15,250 --> 00:19:17,720
but let's dissect it piece by piece.

460
00:19:17,720 --> 00:19:19,386
What does this do? Well
the first thing you can see

461
00:19:19,386 --> 00:19:21,424
is we have two static variables

462
00:19:21,424 --> 00:19:23,150
and these are static because we don't want

463
00:19:23,150 --> 00:19:25,360
their value to change no matter
when the functions calls.

464
00:19:25,360 --> 00:19:26,810
So they're basically global

465
00:19:26,810 --> 00:19:29,669
but they're only visible
to the current function.

466
00:19:29,670 --> 00:19:32,770
And after that we will
set up the current IRQL

467
00:19:32,770 --> 00:19:35,570
and the old IRQL if we changed it.

468
00:19:35,570 --> 00:19:37,050
So first thing we're gonna wanna do

469
00:19:37,050 --> 00:19:38,970
is we'd have to set up a block of code

470
00:19:38,970 --> 00:19:40,760
which is actually responsible

471
00:19:40,760 --> 00:19:42,310
for changing the code on memset set.

472
00:19:42,310 --> 00:19:46,419
Because you can't let
all of those things clash

473
00:19:46,420 --> 00:19:48,170
at the same time, because
that defeats the purpose

474
00:19:48,170 --> 00:19:50,790
of setting up this
complicated hooking mechanism.

475
00:19:50,790 --> 00:19:52,920
So it's a very simple
primitive locking thing

476
00:19:52,920 --> 00:19:53,950
I came up with

477
00:19:53,950 --> 00:19:57,780
it's just two booleans
isPatching and isPatched.

478
00:19:57,780 --> 00:20:00,730
Both of them are false, meaning
nothing has been patched yet

479
00:20:00,730 --> 00:20:03,030
and nothing is being patched.

480
00:20:03,030 --> 00:20:04,560
So how is this supposed to work?

481
00:20:04,560 --> 00:20:05,460
It's pretty simple

482
00:20:06,610 --> 00:20:09,550
if nothing is being patched
or nothing has been patched

483
00:20:09,550 --> 00:20:10,383
let's enter it.

484
00:20:10,383 --> 00:20:12,970
And the first thing we're
gonna do is interlock exchange

485
00:20:12,970 --> 00:20:15,870
isPatching to true because
we are in the process

486
00:20:15,870 --> 00:20:18,750
of patching and doing it
as an interlock operation

487
00:20:18,750 --> 00:20:20,950
because only threads are accessing this

488
00:20:20,950 --> 00:20:22,360
you don't want anything to clash

489
00:20:22,360 --> 00:20:24,030
so it's atomic.

490
00:20:24,030 --> 00:20:26,470
After that we're just
gonna get the current IRQL

491
00:20:26,470 --> 00:20:28,490
and then check if it's equal
to dispatch level or not.

492
00:20:28,490 --> 00:20:30,300
If it's less than dispatch level

493
00:20:30,300 --> 00:20:32,139
we're simply going to
raise it to dispatch level

494
00:20:32,140 --> 00:20:35,030
and save the old IRQL this is what we do.

495
00:20:35,030 --> 00:20:37,330
Now since we're at least
dispatch level or higher

496
00:20:37,330 --> 00:20:39,521
we can safely flip the
write protect bit again.

497
00:20:39,521 --> 00:20:41,480
And now that we flip the write protect bit

498
00:20:41,480 --> 00:20:44,640
we can write to read on
the pages in (indistinct)

499
00:20:44,640 --> 00:20:46,280
After that the first thing we do

500
00:20:46,280 --> 00:20:48,170
is just write our move instruction.

501
00:20:48,170 --> 00:20:50,712
So this assembly you can see where it says

502
00:20:50,712 --> 00:20:51,813
(indistinct) keeping memset.

503
00:20:52,860 --> 00:20:55,979
All that is, is it writes two opcodes,

504
00:20:55,980 --> 00:20:57,650
it will move an absolute value

505
00:20:57,650 --> 00:20:59,950
into the accumulator register.

506
00:20:59,950 --> 00:21:02,200
And after that it will actually
move the linear address

507
00:21:02,200 --> 00:21:05,290
of our reroute routine, which
is what I'll go over next.

508
00:21:05,290 --> 00:21:06,930
And after it moved the linear address

509
00:21:06,930 --> 00:21:10,715
of our reroute routine,
it will simply write jump

510
00:21:10,715 --> 00:21:13,639
to whatever's in the accumulator register

511
00:21:13,640 --> 00:21:16,250
which is what OxEOFF means

512
00:21:16,250 --> 00:21:17,620
or if you're reading a little in the end

513
00:21:17,620 --> 00:21:18,453
it's FFE0.

514
00:21:19,400 --> 00:21:21,470
After you do that you just gotta clean up

515
00:21:21,470 --> 00:21:23,550
so it's set to write protect bit again

516
00:21:23,550 --> 00:21:26,159
and after we set the write protect bit,

517
00:21:26,160 --> 00:21:29,650
if the IRQL that we came in

518
00:21:32,460 --> 00:21:34,950
was not dispatch level or higher

519
00:21:34,950 --> 00:21:37,070
we will simply lower back
to our original IRQL.

520
00:21:37,070 --> 00:21:39,580
So if we were either like zero or one

521
00:21:39,580 --> 00:21:42,240
so if they're passive
level or (indistinct) level

522
00:21:42,240 --> 00:21:45,600
we will simply go back to
whatever the original IRQL is.

523
00:21:45,600 --> 00:21:48,820
Then we we set isPatched to true,

524
00:21:48,820 --> 00:21:52,570
now that we have both boolean
(indistinct) IsPatched to true

525
00:21:52,570 --> 00:21:55,860
we will simply change
out IsPatching for false

526
00:21:55,860 --> 00:21:58,822
because we're not patching
anymore, we have patched.

527
00:21:58,823 --> 00:22:01,910
And the reason why it IsPatched
is true is not interlock

528
00:22:01,910 --> 00:22:05,090
'cause If you read our
if statement, IsPatching

529
00:22:05,090 --> 00:22:06,360
will always be patched first

530
00:22:06,360 --> 00:22:08,550
because that's how,
(indistinct) will be things.

531
00:22:08,550 --> 00:22:12,350
I mean IsPatching will
be(indistinct), IsPatched will not

532
00:22:12,350 --> 00:22:15,409
because the second that
check fails, it'll go on.

533
00:22:15,410 --> 00:22:16,930
All right so underneath
that, we have a simple

534
00:22:16,930 --> 00:22:18,960
while isPatching, now what does that do?

535
00:22:18,960 --> 00:22:20,970
It basically does what you think it does

536
00:22:20,970 --> 00:22:23,071
if something is patching,

537
00:22:23,071 --> 00:22:24,397
you don't want to continue execution

538
00:22:24,397 --> 00:22:27,840
you just wanna stop the
CPU while it is patching

539
00:22:27,840 --> 00:22:29,850
so we're basically going
to spin right there.

540
00:22:29,850 --> 00:22:32,709
And then the second we set
isPatching is to force you

541
00:22:32,710 --> 00:22:33,800
continue execution.

542
00:22:33,800 --> 00:22:36,094
So everything from that
point will just flip down,

543
00:22:36,094 --> 00:22:39,360
everything from the top
which is (indistinct) patch

544
00:22:39,360 --> 00:22:40,760
will also (indistinct) down.

545
00:22:41,740 --> 00:22:43,460
All right so we've got
the hard part right away

546
00:22:43,460 --> 00:22:45,090
now how do we clean up?

547
00:22:45,090 --> 00:22:46,300
It's pretty simple,

548
00:22:46,300 --> 00:22:51,300
all we do is write to dr7
debug register, some flags

549
00:22:51,540 --> 00:22:54,293
and after that I'm gonna
write to the current dr0,

550
00:22:55,610 --> 00:22:57,010
the value of zero.

551
00:22:57,010 --> 00:22:59,650
And after that we will
simply clear a few bits

552
00:22:59,650 --> 00:23:01,550
in debug register six

553
00:23:01,550 --> 00:23:03,639
and I have a array that I'm using

554
00:23:03,640 --> 00:23:06,240
which will basically say
which processes hadn't patched

555
00:23:06,240 --> 00:23:08,040
used by my main driver.

556
00:23:08,040 --> 00:23:10,909
I'll simply set the current
processor (indistinct)

557
00:23:10,910 --> 00:23:14,800
now probably wondering why
are we setting dr0 to zero?

558
00:23:14,800 --> 00:23:16,840
Well if you remember the
interrupt routine handler

559
00:23:16,840 --> 00:23:20,740
will be called on each CPU
that fires the interrupt

560
00:23:20,740 --> 00:23:23,830
and it will be very
complicated to try to patch

561
00:23:26,886 --> 00:23:30,159
your interrupt routine handler again.

562
00:23:30,160 --> 00:23:32,220
So we'll simply clear it here

563
00:23:32,220 --> 00:23:33,740
by the time everything's done

564
00:23:33,740 --> 00:23:37,083
you will have unhook interrupt
handler pretty simple.

565
00:23:38,647 --> 00:23:41,290
And this is some easy
stuff that you can write

566
00:23:41,290 --> 00:23:43,420
before actually doing it (indistinct)

567
00:23:43,420 --> 00:23:46,160
here as you can see an
allocating the memory pool

568
00:23:46,160 --> 00:23:48,760
to hold the Boolean array
after that and simply zeroing

569
00:23:48,760 --> 00:23:50,770
it out then you can see I use KEIP

570
00:23:50,770 --> 00:23:53,475
a generic called a hook IDT in all CPUS

571
00:23:53,475 --> 00:23:55,100
initially like the debug registers.

572
00:23:55,100 --> 00:23:56,870
And the second that called returns

573
00:23:56,870 --> 00:24:00,169
it'll start hammering the
(indistinct) we wrote.

574
00:24:00,170 --> 00:24:02,520
And you can see in the background
it's a simple four loop,

575
00:24:02,520 --> 00:24:05,210
it's constantly checking
all CDs are finished.

576
00:24:05,210 --> 00:24:06,750
If they are we will simply clean up

577
00:24:06,750 --> 00:24:08,800
we'll hook the table again,
but instead of hooking

578
00:24:08,800 --> 00:24:11,530
it with our custom would
restore the original

579
00:24:11,530 --> 00:24:13,870
the technically restoring the hook,

580
00:24:13,870 --> 00:24:16,300
after that would simply free
the already we allocated

581
00:24:16,300 --> 00:24:17,240
and we're done.

582
00:24:17,240 --> 00:24:22,240
We've used debug (indistinct)
to hook a (indistinct)

583
00:24:23,283 --> 00:24:24,879
Alright so now that we've
actually done that we need

584
00:24:24,880 --> 00:24:25,760
actually create the hook

585
00:24:25,760 --> 00:24:28,090
because we've written a
jump to our hook right now.

586
00:24:28,090 --> 00:24:29,120
What is the hook?

587
00:24:29,120 --> 00:24:30,050
It should be pretty simple

588
00:24:30,050 --> 00:24:32,220
all we need to do is just check

589
00:24:32,220 --> 00:24:35,700
the current return address
that is on the stack, right?

590
00:24:35,700 --> 00:24:39,540
And make sure that the
color of the previous color

591
00:24:39,540 --> 00:24:40,960
is actually KeBugCheck2

592
00:24:40,960 --> 00:24:42,010
now how do we do that?

593
00:24:42,010 --> 00:24:43,510
Well all I'm doing is
checking if the current

594
00:24:43,510 --> 00:24:45,570
return address is KeBugCheck2

595
00:24:48,100 --> 00:24:50,129
and by doing that I just check if the base

596
00:24:50,130 --> 00:24:52,640
is within bounds of the
call the (indistinct)

597
00:24:52,640 --> 00:24:55,800
KeBugCheck and after that
we need to check if the...

598
00:24:55,800 --> 00:24:58,050
So we know that it is calling KeBugCheck2

599
00:24:58,050 --> 00:25:00,470
but we need to check if
this is a patch call, right?

600
00:25:00,470 --> 00:25:02,450
So all I'll do is extract that context

601
00:25:02,450 --> 00:25:07,300
which is stored in the
KPRCB back in KeBugCheckEx

602
00:25:07,300 --> 00:25:10,040
and I'll check if the
RCX parameter was 0x109

603
00:25:10,980 --> 00:25:14,040
if it is well we will
go to our solid routine

604
00:25:14,040 --> 00:25:15,670
to stop execution forever

605
00:25:15,670 --> 00:25:18,650
if it's not, we will go to memset.

606
00:25:18,650 --> 00:25:20,640
Easy because we don't want
to touch anything else

607
00:25:20,640 --> 00:25:22,840
and so this will be
written in period sense.

608
00:25:24,100 --> 00:25:27,179
And the stall routine is
where stuff starts to get easy

609
00:25:27,180 --> 00:25:30,320
again, all we have to do
here is stop execution

610
00:25:30,320 --> 00:25:33,210
of the current thread forever
and then undo all the changes

611
00:25:33,210 --> 00:25:35,600
that our previous bug
check function have done.

612
00:25:35,600 --> 00:25:37,620
Which means re-enabling interrupts,

613
00:25:37,620 --> 00:25:40,120
changing the RPO back to passive level,

614
00:25:40,120 --> 00:25:41,760
decrementing (indistinct) harder trigger

615
00:25:41,760 --> 00:25:43,450
and obviously writing a log file entry

616
00:25:43,450 --> 00:25:45,640
I chose to do it because
I wanna see what happens

617
00:25:45,640 --> 00:25:48,110
and then stopping execution forever.

618
00:25:48,110 --> 00:25:49,290
But this is pretty straightforward

619
00:25:49,290 --> 00:25:53,810
we don't need much ASN and it's
a very small amount of code,

620
00:25:53,810 --> 00:25:54,825
so what is that code?

621
00:25:54,825 --> 00:25:56,590
It's basically this,

622
00:25:56,590 --> 00:25:58,419
so you can see the first
thing we do is just

623
00:25:58,420 --> 00:26:00,800
enable our interrupts
lower to passive level

624
00:26:00,800 --> 00:26:04,310
and then detriment part KiHardwareTrigger.

625
00:26:04,310 --> 00:26:06,010
Now the bulk of the code in the middle

626
00:26:06,010 --> 00:26:08,900
it's the stuff that I put in
just because I wanna generate

627
00:26:08,900 --> 00:26:11,450
a log file entry so I can see the log file

628
00:26:11,450 --> 00:26:14,500
to gather some information,
all it'll do is tell me

629
00:26:14,500 --> 00:26:16,140
where the bug check occurred,

630
00:26:16,140 --> 00:26:19,210
what processes occurred and
what threaded it occurred.

631
00:26:19,210 --> 00:26:21,240
After that it will
simply write it to a file

632
00:26:21,240 --> 00:26:24,150
and flush the file buffer
so it'll be on the disc.

633
00:26:24,150 --> 00:26:26,040
And in the end the last
line is what actually

634
00:26:26,040 --> 00:26:27,536
holds the (indistinct)

635
00:26:27,536 --> 00:26:31,150
You will simply wait for
the current threat object

636
00:26:31,150 --> 00:26:32,140
to be signal.

637
00:26:32,140 --> 00:26:33,780
And since we're waiting for ourselves

638
00:26:33,780 --> 00:26:35,440
we're technically just gonna wait forever

639
00:26:35,440 --> 00:26:37,063
so we stop execution.

640
00:26:37,910 --> 00:26:38,973
Pretty simple,

641
00:26:40,820 --> 00:26:42,610
however there's one more
thing we need to do, right?

642
00:26:42,610 --> 00:26:43,699
Because none of this will work

643
00:26:43,700 --> 00:26:45,640
if we don't know the
address of the malfunctions

644
00:26:45,640 --> 00:26:49,870
life KiHardwareTrigger,
KeBugCheck2 and empty memset.

645
00:26:49,870 --> 00:26:54,870
And the offset of the context
structure in the KPRCB,

646
00:26:54,920 --> 00:26:55,900
how do we do that?

647
00:26:55,900 --> 00:26:57,560
Well we don't have to
use symbols or anything

648
00:26:57,560 --> 00:26:59,919
it's already in the compound kernel force.

649
00:26:59,920 --> 00:27:02,320
All we do is start scanning KeBugCheckEx

650
00:27:02,320 --> 00:27:05,060
you can see the first thing
I do is just scan backwards

651
00:27:05,060 --> 00:27:08,588
because the last call
it makes is KeBugCheck2

652
00:27:08,588 --> 00:27:09,930
So (indistinct) we found the last call

653
00:27:09,930 --> 00:27:12,390
okay that's our address
of the KeBugCheck2.

654
00:27:12,390 --> 00:27:15,600
And right before that they
will be a lock instruction,

655
00:27:15,600 --> 00:27:17,730
the only lock instruction
in the entire function

656
00:27:17,730 --> 00:27:20,010
is the one that uses KiHardwareTrigger.

657
00:27:20,010 --> 00:27:22,820
So I checked for S zero,
which is a lock prefix

658
00:27:22,820 --> 00:27:24,659
and then I found KiHardwareTrigger

659
00:27:24,660 --> 00:27:27,150
so I'll just part the machine code there

660
00:27:27,150 --> 00:27:29,420
and expect the point
and generate a pointer

661
00:27:29,420 --> 00:27:30,770
KiHardwareTrigger.

662
00:27:30,770 --> 00:27:33,310
Now after that I need to find
the offset of the context

663
00:27:33,310 --> 00:27:36,320
in the KPRCB because
these are internal values

664
00:27:36,320 --> 00:27:39,070
it's by operating system so
they can change at any time.

665
00:27:39,070 --> 00:27:42,490
So the KPRCB is used early in the function

666
00:27:42,490 --> 00:27:43,820
so this time we'll start scanning

667
00:27:43,820 --> 00:27:46,540
is like the KeBugCheckEx from the start.

668
00:27:46,540 --> 00:27:49,430
And the first call in KeBugCheckEx

669
00:27:49,430 --> 00:27:52,960
is to save the contents in the KPRCV.

670
00:27:52,960 --> 00:27:55,100
So if I find the first call in the start

671
00:27:55,100 --> 00:27:57,790
you can see right there
all I do is simply curves

672
00:27:57,790 --> 00:28:01,639
our data structured to extract
the address of the context.

673
00:28:01,640 --> 00:28:03,420
And at the end it's some simple API calls

674
00:28:03,420 --> 00:28:05,630
I'll get the number of processors we need

675
00:28:05,630 --> 00:28:09,660
now use mmget system looking
address to get an address

676
00:28:09,660 --> 00:28:10,690
of memset.

677
00:28:10,690 --> 00:28:12,600
I can't simply use
memset, because remember

678
00:28:12,600 --> 00:28:15,230
if I just use memset
like in standard C code

679
00:28:15,230 --> 00:28:17,710
that will be pointed to
my driver's own intrinsic

680
00:28:17,710 --> 00:28:20,000
of memset I don't want
that, I want the kernel one

681
00:28:20,000 --> 00:28:24,020
so I have to explicitly call
it using the get system routine

682
00:28:24,020 --> 00:28:24,853
as function.

683
00:28:27,010 --> 00:28:28,447
All right so this is all great in all

684
00:28:28,447 --> 00:28:30,360
but does it actually work?

685
00:28:30,360 --> 00:28:31,669
Well yeah, it should work

686
00:28:31,670 --> 00:28:33,150
let's go over a quick demo.

687
00:28:33,150 --> 00:28:34,210
That one will be super simple

688
00:28:34,210 --> 00:28:36,550
all it'll do is it'll do the attack

689
00:28:36,550 --> 00:28:39,320
and it will be printing
some stuff out to debug you

690
00:28:39,320 --> 00:28:41,659
and in the end instead of
simply returning success

691
00:28:41,660 --> 00:28:44,020
I will actually call KeBugCheckEx

692
00:28:44,020 --> 00:28:47,200
would be parameter one to 0x109

693
00:28:47,200 --> 00:28:50,260
to simulate as this patch
is actually calling in.

694
00:28:50,260 --> 00:28:51,830
And because that'll
happen our driver entry

695
00:28:51,830 --> 00:28:52,663
will never return

696
00:28:52,663 --> 00:28:57,570
and our start requests
will never return either

697
00:28:57,570 --> 00:29:00,220
because we're gonna
hang execution forever.

698
00:29:00,220 --> 00:29:01,053
So how do we do that?

699
00:29:01,053 --> 00:29:04,280
Well let's just look at a
really quick example back here.

700
00:29:04,280 --> 00:29:07,080
So I have a virtual machine right here

701
00:29:07,080 --> 00:29:08,939
and right now I have unpaused it

702
00:29:08,940 --> 00:29:13,293
and what this will do is it
will simply call our handler.

703
00:29:14,780 --> 00:29:19,490
Let's get started the
first thing we should do

704
00:29:19,490 --> 00:29:21,890
is open up DbgView because
you guys should be able

705
00:29:21,890 --> 00:29:25,980
to see the debugger output
and I've already set up

706
00:29:25,980 --> 00:29:28,077
some filters so you don't
see all the other system

707
00:29:28,077 --> 00:29:29,110
(indistinct) messages here

708
00:29:29,110 --> 00:29:32,260
so you will only see what our driver does.

709
00:29:32,260 --> 00:29:37,260
The first thing I will do is
CD into my downloads folder

710
00:29:37,720 --> 00:29:40,430
now load my driver I'm gonna
be using a well-known Windows

711
00:29:40,430 --> 00:29:41,600
exploit called dsefix

712
00:29:42,618 --> 00:29:43,939
and what it does is it uses

713
00:29:43,940 --> 00:29:48,060
a vulnerable virtual
box driver to overwrite

714
00:29:48,060 --> 00:29:50,300
global variable called CII options

715
00:29:50,300 --> 00:29:52,070
in the code integrity module.

716
00:29:52,070 --> 00:29:54,370
And this will allow me to load my driver

717
00:29:54,370 --> 00:29:56,750
because it's unsigned because
I don't have an (indistinct)

718
00:29:56,750 --> 00:29:58,609
signing certificate as there are a couple

719
00:29:58,609 --> 00:30:00,189
of thousands of dollars

720
00:30:00,190 --> 00:30:04,063
so I'll use this just to load
my on-site driver for now.

721
00:30:05,140 --> 00:30:07,360
So I use dsefix and you can see right here

722
00:30:07,360 --> 00:30:10,800
that it has modified the
GCI options value right now

723
00:30:10,800 --> 00:30:13,090
so now I can load my (indistinct)

724
00:30:13,090 --> 00:30:15,939
So I will simply start the
service because it's a service

725
00:30:17,270 --> 00:30:18,620
and have just named it...

726
00:30:19,670 --> 00:30:23,370
Oops, (indistinct) right there.

727
00:30:23,370 --> 00:30:26,070
All right there and you can see right here

728
00:30:26,070 --> 00:30:27,470
so I just named the supernatural

729
00:30:27,470 --> 00:30:29,117
'cause that's the name
of the attack I gave it.

730
00:30:29,117 --> 00:30:32,300
And you can see anything
brief to SN is our attack

731
00:30:32,300 --> 00:30:35,419
so you can see the first thing
it did was it got called,

732
00:30:35,420 --> 00:30:38,520
it gathered information so
it got where a KeBugCheck2

733
00:30:38,520 --> 00:30:42,100
KiHardwareTrigger, memset,
FIELD_OFFSE the context is

734
00:30:42,100 --> 00:30:44,669
and the number of processes just EMS.

735
00:30:44,670 --> 00:30:47,240
After that it just did some
stuff created our Boolean

736
00:30:47,240 --> 00:30:48,490
array hooked IDT

737
00:30:48,490 --> 00:30:51,190
And this is the address
of the original ISR

738
00:30:51,190 --> 00:30:52,747
that the Windows panel has.

739
00:30:52,747 --> 00:30:55,090
And you can see right here
it initialized the debug

740
00:30:55,090 --> 00:30:55,980
registers and bam,

741
00:30:55,980 --> 00:30:58,800
right after it has finished
patching completely.

742
00:30:58,800 --> 00:31:00,500
Then it simply restored the hook

743
00:31:00,500 --> 00:31:02,294
and right now called KeBugCheckEx

744
00:31:02,294 --> 00:31:04,293
'cause in PatchGuard. And
you can see it right now

745
00:31:04,293 --> 00:31:06,110
this command hasn't returned yet, right?

746
00:31:06,110 --> 00:31:08,600
That's because installed execution forever

747
00:31:08,600 --> 00:31:10,740
and it's called the KeBugCheckEx.

748
00:31:10,740 --> 00:31:15,660
And in fact we can look at
the log title right here

749
00:31:15,660 --> 00:31:18,730
block BugCheck from thread 112

750
00:31:18,730 --> 00:31:20,690
in process four which is the kernel.

751
00:31:20,690 --> 00:31:24,810
So in fact what we can do is we can go

752
00:31:24,810 --> 00:31:27,847
and look at the stack trace of thread 112

753
00:31:27,847 --> 00:31:30,379
and 112 is obviously a worker thread

754
00:31:30,380 --> 00:31:33,190
because drivers are loaded
using worker threads.

755
00:31:33,190 --> 00:31:35,850
And you can see right here,
it calls the driver entry

756
00:31:35,850 --> 00:31:38,439
and this is our driver
and our driver calls

757
00:31:38,440 --> 00:31:40,023
KeBugCheckEx, KeBugCheck2

758
00:31:41,160 --> 00:31:42,780
then our driver has intercepted the call

759
00:31:42,780 --> 00:31:44,600
and stop the execution forever

760
00:31:44,600 --> 00:31:47,230
basically suppressing
the PatchGuard response

761
00:31:47,230 --> 00:31:48,903
from ever happening again.

762
00:31:49,960 --> 00:31:52,320
So this is the proof of concept

763
00:31:52,320 --> 00:31:54,800
and like I just said this is the output

764
00:31:54,800 --> 00:31:57,340
and our IDT will have been restored

765
00:31:57,340 --> 00:31:58,939
so you don't have to
worry about PatchGuard

766
00:31:58,940 --> 00:32:01,390
detecting the IDT again

767
00:32:01,390 --> 00:32:03,493
because it has been restored already.

768
00:32:04,610 --> 00:32:07,033
So that is the quick demo.

769
00:32:08,595 --> 00:32:10,040
All right so what are some problems

770
00:32:10,040 --> 00:32:12,610
and improvements with this?

771
00:32:12,610 --> 00:32:14,889
Well that's because, one of the problems

772
00:32:14,890 --> 00:32:16,500
and improvements are PatchGuard DPCs.

773
00:32:16,500 --> 00:32:19,080
DPCs are not supposed to hang such as one

774
00:32:19,080 --> 00:32:20,740
of the DPCs listed there,

775
00:32:20,740 --> 00:32:22,790
ff you do hang the DPC you will crash

776
00:32:22,790 --> 00:32:25,120
with this bug check code so
I need to figure out a way

777
00:32:25,120 --> 00:32:27,969
around that, possible things
are to hook (indistinct) DPC

778
00:32:29,060 --> 00:32:31,290
or to block some of these calls,

779
00:32:31,290 --> 00:32:34,270
the FsRtl and MdlReadCompleteDevEx call

780
00:32:34,270 --> 00:32:36,550
is actually what I think is a main task

781
00:32:36,550 --> 00:32:37,960
call verification routine.

782
00:32:37,960 --> 00:32:39,910
I analyze some crash dumps and it seemed

783
00:32:39,910 --> 00:32:42,550
that it called that so I
think that's what the main

784
00:32:42,550 --> 00:32:44,899
function that actually
got all this stuff is.

785
00:32:44,900 --> 00:32:47,120
And these custom recurs a routine seem

786
00:32:47,120 --> 00:32:49,060
to call that function
so there's a way to get

787
00:32:49,060 --> 00:32:51,419
around that, that could possibly help us

788
00:32:51,420 --> 00:32:52,320
in selecting RDPC.

789
00:32:54,900 --> 00:32:58,710
Okay, so what do we do now
with this information, right?

790
00:32:58,710 --> 00:33:01,930
It's not good if we just go
around start abusing this

791
00:33:01,930 --> 00:33:03,970
so first thing I did even before I start

792
00:33:03,970 --> 00:33:06,800
to talk to, I will say about
this was I tried to tell MS,

793
00:33:06,800 --> 00:33:08,220
hey look we have this problem,

794
00:33:08,220 --> 00:33:09,070
what did they do?

795
00:33:10,010 --> 00:33:11,810
Nothing really, they
really didn't do anything

796
00:33:11,810 --> 00:33:14,659
I contacted them multiple times

797
00:33:14,660 --> 00:33:16,700
they just didn't get back to me.

798
00:33:16,700 --> 00:33:18,400
So we'll leave that,
Microsoft didn't really

799
00:33:18,400 --> 00:33:19,233
do anything (indistinct)

800
00:33:19,233 --> 00:33:20,800
but when I attempted to
tell them (indistinct)

801
00:33:20,800 --> 00:33:22,860
So what can we take away from this?

802
00:33:22,860 --> 00:33:25,860
Well so some administrators
can compromise an entire system

803
00:33:25,860 --> 00:33:28,860
as you saw in group separating
is simply not sufficient

804
00:33:28,860 --> 00:33:30,879
because since you're modifying the kernel

805
00:33:30,880 --> 00:33:32,940
you can get around all
the security feature,

806
00:33:32,940 --> 00:33:34,650
and of course since this is a kernel level

807
00:33:34,650 --> 00:33:36,560
it is quiet and undetected.

808
00:33:36,560 --> 00:33:38,649
You cannot detect this happening unless

809
00:33:38,650 --> 00:33:40,050
you have some special software

810
00:33:40,050 --> 00:33:42,510
which should be able to
detect read and rights,

811
00:33:42,510 --> 00:33:44,010
but I don't think that exists.

812
00:33:45,410 --> 00:33:48,080
But what's the bigger thing
we should get away from this?

813
00:33:48,080 --> 00:33:49,470
Well there's enough...

814
00:33:49,470 --> 00:33:50,880
Well in the next three months,

815
00:33:50,880 --> 00:33:52,090
six months in the next year

816
00:33:52,090 --> 00:33:53,939
there are a few things that should happen.

817
00:33:53,940 --> 00:33:55,640
Obviously this needs to be patched, right?

818
00:33:55,640 --> 00:33:58,510
So KPP needs an update and organizations

819
00:33:58,510 --> 00:34:01,430
should start to increase
their hardware based testing.

820
00:34:01,430 --> 00:34:03,110
Now notice how we didn't cook a function

821
00:34:03,110 --> 00:34:04,610
by simply using three lines of code

822
00:34:04,610 --> 00:34:05,959
like most people would.

823
00:34:05,960 --> 00:34:08,040
We'd have to set up a
complicated interrupt

824
00:34:08,040 --> 00:34:11,110
descriptive table
hooking, synchronization,

825
00:34:11,110 --> 00:34:13,389
locking mechanism to hook things based

826
00:34:13,389 --> 00:34:17,129
on a per CPU basis and
automatically undo itself.

827
00:34:17,130 --> 00:34:19,980
This is where it's harder
based testing should be brought

828
00:34:19,980 --> 00:34:23,920
in because we successfully
(indistinct) bug et cetera.

829
00:34:23,920 --> 00:34:25,989
In the next six months
organization should start

830
00:34:25,989 --> 00:34:28,062
to use these hardware based testing things

831
00:34:28,063 --> 00:34:31,120
or detections of like root
kits and data integrity

832
00:34:31,120 --> 00:34:32,750
just like (indistinct) has done

833
00:34:32,750 --> 00:34:34,429
because three months is too little time

834
00:34:34,429 --> 00:34:37,489
so you should start to
invest in around six months

835
00:34:37,489 --> 00:34:39,699
from now in a hardware based testing

836
00:34:39,699 --> 00:34:44,306
at low level firmware based API and stuff.

837
00:34:44,306 --> 00:34:47,330
And in the next year this
should have this hardware based

838
00:34:47,330 --> 00:34:48,610
testing hardening et cetera.

839
00:34:48,610 --> 00:34:50,170
Should be spend to the cloud,

840
00:34:50,170 --> 00:34:51,540
well why the cloud?

841
00:34:51,540 --> 00:34:53,159
Well we know where the
future is going, right?

842
00:34:53,159 --> 00:34:54,620
Everything is running
in the cloud nowadays,

843
00:34:54,620 --> 00:34:56,779
everything you hear of is
running in the cloud, right?

844
00:34:56,780 --> 00:34:58,910
So for the future of cloud security

845
00:34:58,910 --> 00:35:01,850
and security for everyone,
secure systems are crucial

846
00:35:01,850 --> 00:35:03,560
because that's where all
of our data will live

847
00:35:03,560 --> 00:35:05,220
like it not in the future,

848
00:35:05,220 --> 00:35:07,189
so someone can do this in the cloud level

849
00:35:07,190 --> 00:35:09,790
it's really not a good idea to not invest

850
00:35:09,790 --> 00:35:11,610
in hardware based as in the cloud

851
00:35:11,610 --> 00:35:14,403
because cloud systems are
crucial to our future.

852
00:35:16,000 --> 00:35:17,830
And with that we should be done,

853
00:35:17,830 --> 00:35:20,040
I will take my time now
to answer your questions

854
00:35:20,040 --> 00:35:22,290
and I'd like to thank
everybody for watching.

