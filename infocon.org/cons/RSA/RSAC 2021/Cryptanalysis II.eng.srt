1
00:00:02,249 --> 00:00:04,702
- I will present on work
title of mesh messaging

2
00:00:04,702 --> 00:00:07,664
in large-scale protests,
Breaking Bridgefy.

3
00:00:07,664 --> 00:00:10,020
Then in collaboration
with Martin Albrecht,

4
00:00:10,020 --> 00:00:12,513
Jorge Blasco and Rikke Jensen.

5
00:00:15,190 --> 00:00:16,610
The story begins with the Hong Kong

6
00:00:16,610 --> 00:00:19,060
Anti Extradition Law
Amendment Bill protests

7
00:00:19,060 --> 00:00:20,823
that started in 2019.

8
00:00:22,040 --> 00:00:24,200
Organization of these large-scale protests

9
00:00:24,200 --> 00:00:26,950
has been described as mostly leaderless

10
00:00:26,950 --> 00:00:30,189
and that might have use of
various online platforms.

11
00:00:30,190 --> 00:00:31,630
So given this, there were fears

12
00:00:31,630 --> 00:00:34,360
that the government would
use its emergency powers

13
00:00:34,360 --> 00:00:36,860
and block of these platforms
in order to prevent

14
00:00:36,860 --> 00:00:38,843
the protestors from communicating.

15
00:00:40,177 --> 00:00:42,110
In the setting, a number of articles

16
00:00:42,110 --> 00:00:45,230
reported on the apparent
rise of messaging apps

17
00:00:45,230 --> 00:00:47,339
which enable communication in the face

18
00:00:47,340 --> 00:00:50,700
of potential internet
shutdown by the government.

19
00:00:50,700 --> 00:00:53,870
And these reports focused
on one app in particular

20
00:00:53,870 --> 00:00:56,010
And this was Bridgefy

21
00:00:56,010 --> 00:00:58,320
It allows people to
communicate without internet

22
00:00:58,320 --> 00:01:02,720
using a mesh network that is
composed of mobile devices

23
00:01:02,720 --> 00:01:04,712
connected to each other via Bluetooth.

24
00:01:05,640 --> 00:01:07,890
Now Bridgefy was first conceived as an app

25
00:01:07,890 --> 00:01:10,760
for music concerts and sports stadiums

26
00:01:10,760 --> 00:01:12,994
where mobile networks
may become congested.

27
00:01:12,994 --> 00:01:16,140
But this is miles away
from the potentially

28
00:01:16,140 --> 00:01:19,410
highly adversarial setting of a protest.

29
00:01:19,410 --> 00:01:21,429
However, the app was still being marketed

30
00:01:21,430 --> 00:01:24,520
as secure and encrypted.

31
00:01:24,520 --> 00:01:26,179
And once it started to gaining attraction

32
00:01:26,180 --> 00:01:29,910
in Hong Kong and other
places experiencing protests

33
00:01:29,910 --> 00:01:33,363
the developers also began
promoting it for this use case.

34
00:01:34,400 --> 00:01:35,902
Now an actual internet shut down,

35
00:01:35,902 --> 00:01:37,869
never materialized in Hong Kong,

36
00:01:37,869 --> 00:01:40,860
but mobile networks did get congested

37
00:01:40,860 --> 00:01:43,660
which could have also contributed
to the apps downloads.

38
00:01:45,930 --> 00:01:48,880
However, Hong Kong's role
was to serve as inspiration

39
00:01:48,880 --> 00:01:51,330
for protestors in many other countries

40
00:01:51,330 --> 00:01:53,773
and indeed in invest
the different contexts.

41
00:01:55,040 --> 00:01:57,740
Bridgefy started appearing
as part of Hong Kong tactics

42
00:01:57,740 --> 00:02:00,330
that were being adopted elsewhere.

43
00:02:00,330 --> 00:02:02,090
Now, just to name a few.

44
00:02:02,090 --> 00:02:05,330
This included the Citizenship
Amendment Act protests

45
00:02:05,330 --> 00:02:08,750
in India that happened
during December, 2019

46
00:02:08,750 --> 00:02:11,780
when the government
mandated internet shutdowns

47
00:02:11,780 --> 00:02:13,213
actually did take place.

48
00:02:14,710 --> 00:02:16,840
It was being promoted
during the resurgence

49
00:02:16,840 --> 00:02:19,663
of the Black Lives Matter
protests in the US.

50
00:02:20,640 --> 00:02:23,149
And then also fear or
for government shutdown

51
00:02:23,150 --> 00:02:24,790
during protests and Zimbabwe

52
00:02:24,790 --> 00:02:27,423
urged protesters to install Bridgefy.

53
00:02:28,470 --> 00:02:30,609
During the presidential
election in Belarus

54
00:02:30,610 --> 00:02:33,310
and the days of protests that followed

55
00:02:33,310 --> 00:02:35,270
internet was partially blocked,

56
00:02:35,270 --> 00:02:37,693
which again let some
protesters to Bridgefy.

57
00:02:38,640 --> 00:02:41,470
The last example I will
mention is Thailand

58
00:02:41,470 --> 00:02:44,190
that moved to block
certain independent media

59
00:02:44,190 --> 00:02:46,603
and also the messaging
application Telegram.

60
00:02:48,000 --> 00:02:50,460
Of course judging adoption on the ground,

61
00:02:50,460 --> 00:02:54,010
purely by press reports
and social media posts

62
00:02:54,010 --> 00:02:57,554
one could get an overblown
picture of its actual use

63
00:02:57,554 --> 00:03:01,680
especially since for mesh
to work as advertised

64
00:03:01,680 --> 00:03:04,423
the app requires a certain
critical number of users.

65
00:03:05,630 --> 00:03:07,880
However, there is sufficient
evidence to suggest

66
00:03:07,880 --> 00:03:11,859
that whenever there was a new
flare up of protest activity

67
00:03:11,860 --> 00:03:14,950
or a government move to
limit internet access,

68
00:03:14,950 --> 00:03:17,972
people downloaded and tried
to use Bridefy in response.

69
00:03:20,333 --> 00:03:22,579
So we took an interest and decided

70
00:03:22,580 --> 00:03:25,793
to investigate how secure
this app was in reality.

71
00:03:28,230 --> 00:03:29,920
Since the source code was not available

72
00:03:29,920 --> 00:03:32,132
we reverse-engineered to the Android app.

73
00:03:33,360 --> 00:03:36,280
And in short, we focused on the case

74
00:03:36,280 --> 00:03:39,843
when internet is unavailable
and so Bluetooth is used.

75
00:03:40,980 --> 00:03:43,600
The mesh that is composed of all devices

76
00:03:43,600 --> 00:03:48,280
with rich fine stalled is just
a managed flood based network

77
00:03:48,280 --> 00:03:52,260
which uses time to live counters
that decrease on every app

78
00:03:52,260 --> 00:03:55,190
and receipts that indicate
that a measure message

79
00:03:55,190 --> 00:03:57,033
has reached its destination.

80
00:03:57,910 --> 00:03:59,390
And so the messages that are sent

81
00:03:59,390 --> 00:04:02,867
in his mess network are
first compressed with Gzip

82
00:04:02,867 --> 00:04:06,609
and then encrypted
block by block using RSA

83
00:04:06,610 --> 00:04:10,650
with the now deprecated
PKCS one version 1.5

84
00:04:10,650 --> 00:04:11,500
packing standard.

85
00:04:12,570 --> 00:04:14,400
And without access to internet

86
00:04:14,400 --> 00:04:16,810
all devices that come into Bluetooth range

87
00:04:16,810 --> 00:04:19,890
of each other automatically
perform a handshake

88
00:04:19,890 --> 00:04:22,680
during which they
exchange their public use.

89
00:04:24,190 --> 00:04:26,850
We discovered a number of
vulnerabilities stemming

90
00:04:26,850 --> 00:04:27,893
from this setup.

91
00:04:28,900 --> 00:04:30,669
So to summarize.

92
00:04:30,670 --> 00:04:32,700
First, an attacker or
the physical presence

93
00:04:32,700 --> 00:04:34,680
can easily track Bridgefy users

94
00:04:34,680 --> 00:04:36,560
and reveal their social graphs

95
00:04:36,560 --> 00:04:38,963
just by passively observing the network.

96
00:04:40,210 --> 00:04:44,620
The handshake was not
cryptographically authenticated

97
00:04:44,620 --> 00:04:49,120
and instead, only relied on
user IDs and Bluetooth addresses

98
00:04:49,120 --> 00:04:51,130
to establish identity.

99
00:04:51,130 --> 00:04:54,210
And as a result, there was
nothing stopping an attacker

100
00:04:54,210 --> 00:04:56,780
from impersonating any user

101
00:04:56,780 --> 00:04:59,869
and also from performing a full attacker

102
00:04:59,870 --> 00:05:03,102
in the middle between any devices

103
00:05:03,102 --> 00:05:04,602
Bluetooth range of each other.

104
00:05:06,600 --> 00:05:10,460
Further, while the use
of PKCS one version 1.5

105
00:05:10,460 --> 00:05:13,303
didn't immediately
provide a pending article,

106
00:05:13,303 --> 00:05:16,230
one could still be built
thanks to the composition

107
00:05:16,230 --> 00:05:18,620
with Gzip compression.

108
00:05:18,620 --> 00:05:20,900
And so a new variant of
whacking backers attack

109
00:05:20,900 --> 00:05:24,239
could be instantiated that
could decrypt a message

110
00:05:24,240 --> 00:05:26,993
using an average two to
the 17 chosen ciphertexts.

111
00:05:29,150 --> 00:05:32,609
Finally, it was possible to
perform denial of service

112
00:05:32,610 --> 00:05:34,890
on the network by using a zip bomb

113
00:05:34,890 --> 00:05:37,229
which is just a small
file that decompresses

114
00:05:37,230 --> 00:05:38,703
to a very large fail load.

115
00:05:40,500 --> 00:05:41,950
We verified all of these attacks

116
00:05:41,950 --> 00:05:45,620
in practice on the Android
devices, using Frida

117
00:05:45,620 --> 00:05:47,860
which is a dynamic instrumentation toolkit

118
00:05:47,860 --> 00:05:52,200
that allows injecting scripts
into running processes

119
00:05:52,200 --> 00:05:54,143
and then essentially black box manner.

120
00:05:57,100 --> 00:05:59,330
I will now go through a short timeline

121
00:05:59,330 --> 00:06:02,203
of the disclosure process
with Bridgefy the company.

122
00:06:05,490 --> 00:06:09,920
We first contacted them
privately in April, 2020

123
00:06:09,920 --> 00:06:12,360
initially offering the standard 90 days

124
00:06:12,360 --> 00:06:14,280
before public disclosure,

125
00:06:14,280 --> 00:06:17,453
but after some inference that
this was moved to August.

126
00:06:18,460 --> 00:06:20,680
However, before the agreed date

127
00:06:20,680 --> 00:06:23,860
the company started
partially informing its users

128
00:06:23,860 --> 00:06:26,380
about the existing issues

129
00:06:26,380 --> 00:06:28,730
in a somewhat non-standard manner.

130
00:06:28,730 --> 00:06:31,380
So they first tweeted that
they removed encryption

131
00:06:31,380 --> 00:06:34,110
from the app, which was
not actually the case

132
00:06:34,110 --> 00:06:37,560
but they said this was their
attempt to explain to users

133
00:06:37,560 --> 00:06:40,550
in a simpler way that there
are issues with encryption

134
00:06:40,550 --> 00:06:43,133
without having just say
precisely what went wrong.

135
00:06:44,370 --> 00:06:45,540
And further, they announced that

136
00:06:45,540 --> 00:06:48,850
they were redoing their
protocol from scratch.

137
00:06:48,850 --> 00:06:51,280
The app or its description
on the app store however,

138
00:06:51,280 --> 00:06:52,809
did not mention the issues

139
00:06:52,810 --> 00:06:56,713
and the app continued to be
promoted in protest contexts.

140
00:06:58,260 --> 00:07:00,320
Then by the agreed date in August,

141
00:07:00,320 --> 00:07:02,440
it wasn't clear what the timeline

142
00:07:02,440 --> 00:07:04,510
for the new protocols would be.

143
00:07:04,510 --> 00:07:07,789
We considered moving the
disclosure date forward

144
00:07:07,790 --> 00:07:11,280
but there was no assurance that
this wouldn't happen again.

145
00:07:11,280 --> 00:07:13,320
And so given these partial disclosures

146
00:07:13,320 --> 00:07:15,203
we decided to disclose as planned.

147
00:07:16,430 --> 00:07:18,750
We released an abridged
version of our paper

148
00:07:18,750 --> 00:07:21,030
that came out alongside a media article

149
00:07:21,030 --> 00:07:24,200
informing about dangers
of using the app as it is

150
00:07:25,200 --> 00:07:28,130
without giving details of
their implemented architecture

151
00:07:28,130 --> 00:07:30,800
and Bridgefy also published a statement

152
00:07:30,800 --> 00:07:32,563
of their own confirming the issues.

153
00:07:33,850 --> 00:07:37,010
Finally, at the end of
October, the app was updated

154
00:07:37,010 --> 00:07:39,813
supposedly integrating
the signal protocol.

155
00:07:40,730 --> 00:07:43,470
However, we have not
reviewed these changes

156
00:07:43,470 --> 00:07:45,450
and so we cannot comment on whether

157
00:07:45,450 --> 00:07:47,493
the implementation is actually adequate.

158
00:07:48,390 --> 00:07:50,013
And we have also recommended to Bridgefy

159
00:07:50,013 --> 00:07:53,332
that they employ an
independent audit if they can.

160
00:07:56,540 --> 00:07:58,533
I would like to end with
a couple of thoughts.

161
00:07:59,800 --> 00:08:02,110
First of all, you would be right to note

162
00:08:02,110 --> 00:08:04,580
that there was nothing
particularly surprising

163
00:08:04,580 --> 00:08:09,039
about the attacks we found
since once the specification

164
00:08:09,040 --> 00:08:12,690
was extracted from the
reverse-engineered implementation

165
00:08:12,690 --> 00:08:15,603
it was kind of clear
where it was going to go.

166
00:08:16,820 --> 00:08:18,409
And one reason for this is of course

167
00:08:18,410 --> 00:08:21,943
that the app was not intended
for the protest setting.

168
00:08:23,760 --> 00:08:26,750
However, we are on thin ground here.

169
00:08:26,750 --> 00:08:28,420
Once this trend picked up

170
00:08:28,420 --> 00:08:30,200
even the developers of Bridgefy,

171
00:08:30,200 --> 00:08:33,169
didn't shy away from
explicitly promoting it

172
00:08:33,169 --> 00:08:34,746
as a protest app.

173
00:08:36,099 --> 00:08:38,440
And therefore we would like
to raise two open questions

174
00:08:38,440 --> 00:08:40,023
for security researchers.

175
00:08:41,101 --> 00:08:43,960
First, what security can even be achieved

176
00:08:43,960 --> 00:08:45,910
in the mesh setting in the first place?

177
00:08:46,770 --> 00:08:48,130
There's a lot of common ground

178
00:08:48,130 --> 00:08:50,970
with messaging protocols in general.

179
00:08:50,970 --> 00:08:53,790
However, there are particular
features of this setting

180
00:08:53,790 --> 00:08:56,089
which mean we need to re-examine

181
00:08:56,090 --> 00:08:58,553
the security notions
that are deemed ideal.

182
00:09:00,210 --> 00:09:03,860
Second, bringing back the focus
to the users of these apps,

183
00:09:03,860 --> 00:09:05,600
what security needs do protesters

184
00:09:05,600 --> 00:09:07,200
in these settings actually have?

185
00:09:08,050 --> 00:09:11,089
We have someone glided
over this in our analysis,

186
00:09:11,090 --> 00:09:12,990
imagining scenarios, and assuming

187
00:09:12,990 --> 00:09:17,320
that certain basic properties
are shared among many users

188
00:09:17,320 --> 00:09:20,340
regardless of whether they
participate in a protest

189
00:09:20,340 --> 00:09:22,010
and whether that it's in Hong Kong

190
00:09:22,010 --> 00:09:24,080
or one of the many other countries

191
00:09:24,080 --> 00:09:26,233
where Bridgefy horizon adoption.

192
00:09:30,051 --> 00:09:32,160
And these included a
vast range rigid regimes

193
00:09:32,160 --> 00:09:34,063
and therefore potential thread models.

194
00:09:35,060 --> 00:09:38,530
So more fundamental research
into this question is needed

195
00:09:38,530 --> 00:09:41,089
so that designers can
avoid creating solutions

196
00:09:41,090 --> 00:09:43,573
which do not actually
fit their user's needs.

197
00:09:46,380 --> 00:09:48,580
Finally, applications on
a subject such as this

198
00:09:48,580 --> 00:09:52,030
are usually not the easiest
to find but nonetheless,

199
00:09:52,030 --> 00:09:53,670
there are a couple of lessons

200
00:09:53,670 --> 00:09:55,370
that can be learned from our work.

201
00:09:56,480 --> 00:09:59,160
And even though this
happens time and time again

202
00:09:59,160 --> 00:10:01,990
it seems that developers are still turning

203
00:10:01,990 --> 00:10:04,470
to old deprecated standards

204
00:10:04,470 --> 00:10:07,963
and therefore compromising the
security of their products.

205
00:10:09,400 --> 00:10:11,000
Further, our work emphasizes

206
00:10:11,000 --> 00:10:14,390
that there is a need for
applications to be evaluated

207
00:10:14,390 --> 00:10:17,600
under the conditions
they are actually used in

208
00:10:17,600 --> 00:10:19,870
even if their designers
may not have imagined

209
00:10:19,870 --> 00:10:21,573
such use cases when they began.

210
00:10:23,000 --> 00:10:25,320
And the fact that protesters
turned to Bridgefy

211
00:10:25,320 --> 00:10:29,090
one was targeting an
entirely different population

212
00:10:29,090 --> 00:10:31,860
also makes it clear that
the mesh messaging space

213
00:10:31,860 --> 00:10:34,380
is liking alternative solutions

214
00:10:34,380 --> 00:10:37,450
especially when it comes
to mobile mesh networking,

215
00:10:37,450 --> 00:10:40,930
meaning without the need
for any additional hardware.

216
00:10:40,930 --> 00:10:44,620
Now, Briar gets mentioned
in these contexts sometimes

217
00:10:44,620 --> 00:10:47,229
but this is an app which only
allows direct connections

218
00:10:47,229 --> 00:10:50,810
without relaying private
messages into the mesh.

219
00:10:50,810 --> 00:10:53,983
So it can't really be considered
to be in the same category.

220
00:10:54,880 --> 00:10:57,850
So would this work, we
would also like to highlight

221
00:10:57,850 --> 00:11:00,663
the existing gap for technology designers.

222
00:11:02,110 --> 00:11:03,343
Thank you for listening.

223
00:11:04,990 --> 00:11:06,570
- Hello, my name is Karen Klein.

224
00:11:06,570 --> 00:11:08,540
I'm a PhD student at ISD Austria

225
00:11:08,540 --> 00:11:10,650
and today will talk about
Inverse-Sybil attacks

226
00:11:10,650 --> 00:11:12,273
in automated contact tracing.

227
00:11:14,080 --> 00:11:15,860
Conduct tracing is a very important tool

228
00:11:15,860 --> 00:11:18,490
to prevent contagious
diseases such as COVID-19

229
00:11:18,490 --> 00:11:19,890
from uncontrolled spreading.

230
00:11:20,870 --> 00:11:22,430
Whenever parties diagnose sick,

231
00:11:22,430 --> 00:11:24,349
all parties that have been in the vicinity

232
00:11:24,350 --> 00:11:27,140
during the contagious period
should immediately be warned

233
00:11:27,140 --> 00:11:28,480
so that they can isolate already

234
00:11:28,480 --> 00:11:30,453
before they get contagious themselves.

235
00:11:31,580 --> 00:11:34,330
Since men are contact tracing
soon reaches its limits

236
00:11:34,330 --> 00:11:35,700
and many people are affected

237
00:11:35,700 --> 00:11:38,070
and furthermore only identifies contacts

238
00:11:38,070 --> 00:11:40,050
the diagnose party knows

239
00:11:40,050 --> 00:11:42,252
an automated solution can be very helpful.

240
00:11:43,140 --> 00:11:45,430
There are many project
developing such automated tools

241
00:11:45,430 --> 00:11:46,910
leveraging the fact that many people

242
00:11:46,910 --> 00:11:49,110
carry around mobile
phones most of the time.

243
00:11:50,670 --> 00:11:53,800
Most of these approaches are
based on low energy Bluetooth.

244
00:11:53,800 --> 00:11:56,780
Major projects include
East and West coast PACT,

245
00:11:56,780 --> 00:12:00,579
COVID Watch, DP-3T, Robert
and its success Desire

246
00:12:00,580 --> 00:12:01,503
and Pepp-PT.

247
00:12:02,580 --> 00:12:04,760
Google and Apple jointly
developed the so-called

248
00:12:04,760 --> 00:12:07,797
Google-Apple exposure
notification system, short GAEN

249
00:12:08,680 --> 00:12:10,729
which is widely employed,
especially in Europe

250
00:12:10,730 --> 00:12:13,023
and it's similar to the DP-3T protocol.

251
00:12:14,286 --> 00:12:16,089
Clearly the goal is to construct simple

252
00:12:16,090 --> 00:12:18,960
and efficient schemes that
can be implemented timely.

253
00:12:18,960 --> 00:12:21,320
And at the same time
provide strong security

254
00:12:21,320 --> 00:12:23,483
and privacy guarantees.

255
00:12:25,690 --> 00:12:27,640
Typically in such contact tracing schemes

256
00:12:27,640 --> 00:12:30,150
users broadcast messages using Bluetooth

257
00:12:30,150 --> 00:12:32,020
so that only users in the close proximity

258
00:12:32,020 --> 00:12:33,633
can receive and process them.

259
00:12:34,790 --> 00:12:37,300
When diagnosed to get permission to upload

260
00:12:37,300 --> 00:12:40,300
the report messages should
have backend server.

261
00:12:40,300 --> 00:12:42,490
These report messages to
get with the local state

262
00:12:42,490 --> 00:12:44,500
of the user then allows to evaluate

263
00:12:44,500 --> 00:12:46,153
whether the user is at risk.

264
00:12:47,530 --> 00:12:49,439
Here one differentiates
between centralized

265
00:12:49,440 --> 00:12:51,010
and decentralized approaches.

266
00:12:51,010 --> 00:12:52,420
In centralized schemes,

267
00:12:52,420 --> 00:12:54,410
the risk evaluation is done by the server

268
00:12:54,410 --> 00:12:55,400
whereas in decentralized scheme

269
00:12:55,400 --> 00:12:57,502
it is done locally on users phone.

270
00:12:59,160 --> 00:13:02,130
In our work we are concerned
about important security aspect

271
00:13:02,130 --> 00:13:04,173
of preventing false positives.

272
00:13:06,050 --> 00:13:09,400
While false positives cannot
be prevented completely

273
00:13:09,400 --> 00:13:10,699
we are very devout detects

274
00:13:10,700 --> 00:13:13,030
can be launched on a large scale.

275
00:13:13,030 --> 00:13:15,280
Such large scale attacks
triggering false positives

276
00:13:15,280 --> 00:13:17,550
might not only affect
deployment of the app

277
00:13:17,550 --> 00:13:20,823
but also influence external
events, such as elections.

278
00:13:22,300 --> 00:13:24,030
One type of such attacks
are replay attacks,

279
00:13:24,030 --> 00:13:26,305
where an adversary broadcast messages

280
00:13:26,305 --> 00:13:29,599
it previously received from other users.

281
00:13:29,600 --> 00:13:32,800
The first interactive solution
to prevent replay attacks

282
00:13:32,800 --> 00:13:34,449
was proposed per session with me.

283
00:13:35,390 --> 00:13:38,250
Later schme like Pronto-C2 and
Desire prevent reply attacks

284
00:13:38,250 --> 00:13:40,123
or non-interactive exchange.

285
00:13:41,300 --> 00:13:43,219
Both these approaches
are privacy preserving,

286
00:13:43,220 --> 00:13:46,173
however slightly using
efficiency and simplicity.

287
00:13:47,850 --> 00:13:49,810
Google and Apple on the end decided

288
00:13:49,810 --> 00:13:52,819
for non-interactive solution
that store and authenticate

289
00:13:52,820 --> 00:13:54,283
the epoch of each encounter,

290
00:13:55,210 --> 00:13:58,163
which clearly implies a loss of privacy.

291
00:13:59,520 --> 00:14:02,010
A unidirectional and
privacy preserving solution

292
00:14:02,010 --> 00:14:04,710
to prevent replay attacks
is delayed authentication

293
00:14:04,710 --> 00:14:07,963
which was proposed by Joseph
Pietrzak in decrypt 2020.

294
00:14:09,650 --> 00:14:11,920
Even if replay attacks can be prevented

295
00:14:11,920 --> 00:14:14,610
relay attacks might still be possible

296
00:14:14,610 --> 00:14:16,850
if an adversary sends messages it received

297
00:14:16,850 --> 00:14:19,130
to another device far away in real time

298
00:14:19,130 --> 00:14:21,160
to be replayed there.

299
00:14:21,160 --> 00:14:22,280
But the best of our knowledge

300
00:14:22,280 --> 00:14:23,850
all schemes preventing relay attacks

301
00:14:23,850 --> 00:14:26,580
require location dependent
values like GPS coordinates

302
00:14:26,580 --> 00:14:27,963
or cell tower IDs.

303
00:14:29,960 --> 00:14:31,500
There is another class of attacks

304
00:14:31,500 --> 00:14:33,550
that has not gained much attention so far

305
00:14:33,550 --> 00:14:35,423
which you call Inverse-Sybil attacks.

306
00:14:36,730 --> 00:14:39,610
While in replay and relay
attacks episodes repeat messages

307
00:14:39,610 --> 00:14:41,420
they received, Inverse-Sybil attacks

308
00:14:41,420 --> 00:14:43,180
are of a different flavor

309
00:14:43,180 --> 00:14:44,930
and will be the topic of this talk.

310
00:14:46,020 --> 00:14:47,730
Recall that in a so called Sybil attack

311
00:14:47,730 --> 00:14:50,583
one party pretends to be
many different parties.

312
00:14:51,450 --> 00:14:53,720
In an Inverse-Sybil attack in contrast,

313
00:14:53,720 --> 00:14:56,190
many devices pretend to be just one user

314
00:14:56,190 --> 00:14:58,950
so that in case one of them
gets diagnosed positive

315
00:14:58,950 --> 00:15:00,270
all users that were in contact

316
00:15:00,270 --> 00:15:02,670
with any of the malicious
users will be alerted.

317
00:15:03,740 --> 00:15:06,090
This attack was previously
discussed per session with me

318
00:15:06,090 --> 00:15:07,640
who call it a terrorist attack.

319
00:15:09,740 --> 00:15:11,570
We will now discussed
an Inverse-Sybil attack

320
00:15:11,570 --> 00:15:14,070
on the example of the
widely employed GAEN scheme.

321
00:15:15,960 --> 00:15:17,590
First let's recall the
high level structure

322
00:15:17,590 --> 00:15:18,690
of this protocol.

323
00:15:18,690 --> 00:15:22,080
In the GAEN scheme, each
user holds some private key

324
00:15:22,080 --> 00:15:23,790
which is regularly rotated

325
00:15:23,790 --> 00:15:26,813
and it's used to derive a
formal IDs to be broadcasted.

326
00:15:27,720 --> 00:15:30,720
Users receiving such random
they can store them in the list.

327
00:15:31,750 --> 00:15:34,090
When a user gets diagnosed positive

328
00:15:34,090 --> 00:15:37,580
it receives an upload
token and sends its key

329
00:15:37,580 --> 00:15:40,270
from the last weeks in permitted order

330
00:15:40,270 --> 00:15:43,189
together with the token
to the beacon server,

331
00:15:43,190 --> 00:15:45,370
which stores them in a list.

332
00:15:45,370 --> 00:15:48,340
On users regularly
download this updated list

333
00:15:48,340 --> 00:15:50,450
and check whether one of
the keys matches an entry

334
00:15:50,450 --> 00:15:52,730
in their own local list of encounters.

335
00:15:52,730 --> 00:15:55,280
If this is indeed the case,
they receive a warning.

336
00:15:57,140 --> 00:15:58,790
Unfortunately Inverse-Sybil attacks

337
00:15:58,790 --> 00:16:02,250
can easily be launched on
the GAEN scheme as follows.

338
00:16:02,250 --> 00:16:05,720
The blue holes represent
malicious users or earnest users

339
00:16:05,720 --> 00:16:10,100
whose phones cortex and
we assume all these users

340
00:16:10,100 --> 00:16:12,403
set up the devices
using the same keys key.

341
00:16:14,120 --> 00:16:16,980
They will then use these keys
to derive a familiar ideas

342
00:16:17,980 --> 00:16:20,320
which will broadcast to
users in the proximity

343
00:16:20,320 --> 00:16:22,270
represented by the arrows on the right.

344
00:16:25,570 --> 00:16:29,330
When later one of the blue
holes gets diagnosed positive

345
00:16:29,330 --> 00:16:32,620
it will upload the common keys
from each of the green holes

346
00:16:33,980 --> 00:16:36,350
derive all the random beacons

347
00:16:36,350 --> 00:16:39,930
that were previously broadcasted
by any of the blue holes.

348
00:16:39,930 --> 00:16:42,020
First, all green holes
will receive an alert

349
00:16:42,020 --> 00:16:43,079
that will be sent the current time

350
00:16:43,080 --> 00:16:45,360
while in fact only the third one indeed

351
00:16:45,360 --> 00:16:46,573
had a positive contact.

352
00:16:47,890 --> 00:16:49,573
Know that this attack explodes the fact

353
00:16:49,573 --> 00:16:52,073
that the formal IDs are
derived deterministically.

354
00:16:54,070 --> 00:16:56,430
Inverse-Sybil attacks can also
be launched in other schemes

355
00:16:56,430 --> 00:16:58,849
including protocols using
non-interactive exchange

356
00:16:58,850 --> 00:17:00,543
such as Desire or Robert tool.

357
00:17:01,630 --> 00:17:05,150
However, in centralized protocols
such as Robert or Desire,

358
00:17:05,150 --> 00:17:07,599
the risk evaluation is done by the server,

359
00:17:07,599 --> 00:17:10,000
Inverse-Sybil attacks to
not scale it dramatically

360
00:17:10,000 --> 00:17:12,140
because the server sees the total number

361
00:17:12,140 --> 00:17:14,523
of encounters and can
simply cap this number.

362
00:17:16,390 --> 00:17:18,542
In our book, we proposed two protocols

363
00:17:18,542 --> 00:17:20,592
that to the best of our
knowledge are the first

364
00:17:20,593 --> 00:17:23,063
that do not account the
Inverse-Sybil attacks.

365
00:17:24,980 --> 00:17:27,339
Our approach to prevent
Inverse-Sybil attacks

366
00:17:27,339 --> 00:17:29,990
is to drive random beacons from hash chain

367
00:17:29,990 --> 00:17:32,910
to enforce the test chains
of different uses divert

368
00:17:32,910 --> 00:17:34,960
include some external randomness.

369
00:17:34,960 --> 00:17:37,530
This could either be random
values that are exchanged

370
00:17:37,530 --> 00:17:39,600
with other users that it counter

371
00:17:39,600 --> 00:17:41,300
or some location-based coordinate.

372
00:17:43,050 --> 00:17:44,899
So if two users are set up maliciously

373
00:17:44,900 --> 00:17:46,310
and use the same initialization,

374
00:17:46,310 --> 00:17:49,290
their hash change will only
coincide in the first block.

375
00:17:49,290 --> 00:17:51,960
And by collision resistance
of the hash function

376
00:17:51,960 --> 00:17:53,360
there is no chance for the adversary

377
00:17:53,360 --> 00:17:56,050
to later combine these
chains the single hash chain

378
00:17:56,050 --> 00:17:57,750
that can be uploaded to the server

379
00:17:59,010 --> 00:18:02,573
thus only one of them can
ultimately upload their has chain.

380
00:18:04,830 --> 00:18:06,050
If you make the assumption

381
00:18:06,050 --> 00:18:08,159
the devices cannot
communicate since otherwise

382
00:18:08,160 --> 00:18:11,100
an Inverse-Sybil attack
seems hard to avoid

383
00:18:11,100 --> 00:18:12,699
without giving up on privacy

384
00:18:12,700 --> 00:18:15,560
or making very strong
additional assumptions.

385
00:18:15,560 --> 00:18:19,030
For our constructions to
execute Inverse-Sybil attacks

386
00:18:19,030 --> 00:18:19,920
on a large scale,

387
00:18:19,920 --> 00:18:22,170
devices would need to
constantly communicate.

388
00:18:23,710 --> 00:18:26,680
Efficiency-wise, our approach
is compared with the GAEN

389
00:18:26,680 --> 00:18:29,340
but requires larger download cost.

390
00:18:29,340 --> 00:18:32,459
Furthermore, we require a
non-interactive exchange

391
00:18:32,460 --> 00:18:34,063
or some form of location data.

392
00:18:35,340 --> 00:18:38,340
Concerning privacy, we put a
little more trust on the server

393
00:18:38,340 --> 00:18:40,399
since it inherently learns some ordering

394
00:18:40,400 --> 00:18:42,083
of the uploaded random values.

395
00:18:43,720 --> 00:18:46,360
Finally, let us know that
this approach can be used

396
00:18:46,360 --> 00:18:49,110
to assign centralized as well
as decentralized schemes.

397
00:18:50,590 --> 00:18:53,293
I'll now give a brief
overview of our two protocols.

398
00:18:55,100 --> 00:18:58,340
The first scheme is based
on non-interactive exchange.

399
00:18:58,340 --> 00:19:01,970
It has progress some hash
chain and store two lists,

400
00:19:01,970 --> 00:19:03,240
one for risk evaluation

401
00:19:03,240 --> 00:19:04,770
the other one to upload to the server

402
00:19:04,770 --> 00:19:06,920
in case they should
get diagnosed positive.

403
00:19:07,930 --> 00:19:10,300
In regular intervals, they
sample a random string

404
00:19:10,300 --> 00:19:13,283
and broadcast it to get it with
the tip of their hash chain.

405
00:19:14,200 --> 00:19:15,950
If they receive another user's message

406
00:19:15,950 --> 00:19:17,370
to store to receive hash,

407
00:19:17,370 --> 00:19:20,040
to get their own random string
in the abbreviation list

408
00:19:20,040 --> 00:19:22,770
and their own hash together
with the received random string

409
00:19:22,770 --> 00:19:23,723
in the report list.

410
00:19:24,930 --> 00:19:26,720
Then the progress that hash chain infusing

411
00:19:26,720 --> 00:19:28,120
the receive trend on string.

412
00:19:29,700 --> 00:19:32,440
If a party gets sick, it
uploads its report list

413
00:19:32,440 --> 00:19:35,570
to the server, which checks,
where did the to happen,

414
00:19:35,570 --> 00:19:37,720
load it as well indeed
from the hash chain.

415
00:19:39,030 --> 00:19:42,350
To evaluate the risk status
parties regularly download

416
00:19:42,350 --> 00:19:44,179
the list from the server and check

417
00:19:44,180 --> 00:19:46,050
whether their evaluation list contains

418
00:19:46,050 --> 00:19:47,500
a list from the servers list.

419
00:19:50,820 --> 00:19:52,950
This type of protocol
provides a minimum solution

420
00:19:52,950 --> 00:19:54,850
to prevent Inverse-Sybil attacks.

421
00:19:54,850 --> 00:19:57,929
However, it has some
correctness and privacy issues,

422
00:19:57,930 --> 00:19:59,880
which we saw it in our final protocols.

423
00:20:01,040 --> 00:20:03,165
First to allow for parallel encounters,

424
00:20:03,165 --> 00:20:04,615
our schema advances in epochs

425
00:20:05,710 --> 00:20:08,050
collecting received random strings

426
00:20:08,050 --> 00:20:09,970
in a pool of messages that is later used

427
00:20:09,970 --> 00:20:11,220
to extend the hash chain.

428
00:20:12,250 --> 00:20:14,980
Concerning privacy to
avoid that receiving users

429
00:20:14,980 --> 00:20:17,630
can reconstruct test
chains and learn the number

430
00:20:17,630 --> 00:20:20,090
of encounters diagnosed user had.

431
00:20:20,090 --> 00:20:22,577
Use keyed hash functions
and let the server permute

432
00:20:22,577 --> 00:20:24,960
the list of hash values.

433
00:20:24,960 --> 00:20:26,440
Clearly this does not improve privacy

434
00:20:26,440 --> 00:20:27,620
against malicious servers

435
00:20:27,620 --> 00:20:29,320
since the server requires the key

436
00:20:29,320 --> 00:20:32,723
to check the uploaded values
indeed from the hash chain.

437
00:20:34,010 --> 00:20:36,723
Finally, to avoid that
the server can learn

438
00:20:36,723 --> 00:20:39,120
that the two hash chains
had a common encounter

439
00:20:39,120 --> 00:20:41,219
we use unique chaining values namely,

440
00:20:41,220 --> 00:20:43,570
instead of S we use a hash company S

441
00:20:43,570 --> 00:20:45,169
into two tips of the hash chain.

442
00:20:47,270 --> 00:20:48,180
To summarize.

443
00:20:48,180 --> 00:20:49,910
Our first protocol is rather efficient,

444
00:20:49,910 --> 00:20:52,000
however, the up and downloads are linear

445
00:20:52,000 --> 00:20:53,400
in the number of encounters.

446
00:20:54,540 --> 00:20:57,173
Furthermore, it requires
non-interactive exchange.

447
00:20:58,420 --> 00:21:01,530
Since users broadcast unlinkable
pseudo random beacons,

448
00:21:01,530 --> 00:21:03,340
privacy on the user side is as good

449
00:21:03,340 --> 00:21:05,620
as for the unlinkable GAEN protocol,

450
00:21:05,620 --> 00:21:07,300
but we put more trust in the server,

451
00:21:07,300 --> 00:21:09,483
which learns an ordering of the beacons.

452
00:21:11,380 --> 00:21:12,720
In our second protocol,

453
00:21:12,720 --> 00:21:16,020
instead of random strings
exchange during encounters

454
00:21:16,020 --> 00:21:17,215
the chain values are derived

455
00:21:17,215 --> 00:21:19,303
from some location dependent data.

456
00:21:20,420 --> 00:21:23,090
This could be costly
as location set our IDs

457
00:21:23,090 --> 00:21:25,023
or information from my IP addresses.

458
00:21:25,990 --> 00:21:29,840
Also in this scheme users send
and received random beacons.

459
00:21:29,840 --> 00:21:31,939
But again, we have to put
slightly more trust in server

460
00:21:31,940 --> 00:21:33,433
which can link these beacons.

461
00:21:34,710 --> 00:21:36,650
Security against Inverse-Sybil attacks

462
00:21:36,650 --> 00:21:37,613
only holds under the assumption

463
00:21:37,613 --> 00:21:40,363
that the locations of the
encounters are unpredictable.

464
00:21:41,410 --> 00:21:43,160
We believe that whenever
the location coordinates

465
00:21:43,160 --> 00:21:44,650
which was not too cause,

466
00:21:44,650 --> 00:21:47,300
this still implies meaningful security.

467
00:21:47,300 --> 00:21:49,360
The advantage of this scheme is that

468
00:21:49,360 --> 00:21:51,993
it also provides security
against relay attacks.

469
00:21:54,390 --> 00:21:56,420
To summarize our results,

470
00:21:56,420 --> 00:21:59,080
we provide first form of
models of Inverse-Sybil attacks

471
00:21:59,080 --> 00:22:01,889
and propose two different
privacy preserving schemes

472
00:22:01,890 --> 00:22:03,690
that do not succumb to such attacks.

473
00:22:04,910 --> 00:22:07,720
Both schemes are based on hash chains.

474
00:22:07,720 --> 00:22:09,840
The first one relies on
non-interactive exchange.

475
00:22:09,840 --> 00:22:11,949
The second on some
location-based coordinate

476
00:22:11,950 --> 00:22:14,150
where location data is
of course not stored.

477
00:22:15,590 --> 00:22:17,300
Why both our schemes are decentralized,

478
00:22:17,300 --> 00:22:18,780
it is straightforward to adopt them

479
00:22:18,780 --> 00:22:20,180
through centralized setting.

480
00:22:22,160 --> 00:22:25,140
For more details refer to our paper.

481
00:22:25,140 --> 00:22:26,130
Thanks for your attention.

482
00:22:26,130 --> 00:22:28,630
I hope to see many of you
at the discussion later.

483
00:22:33,060 --> 00:22:35,040
- So welcome to my presentation.

484
00:22:35,040 --> 00:22:37,960
I'm a sales coordinator from the EPFL

485
00:22:37,960 --> 00:22:40,500
and I'm going to present
you some joint work

486
00:22:40,500 --> 00:22:44,180
with Vincenzo Iovino and Martin Vuagnoux.

487
00:22:44,180 --> 00:22:45,380
This presentation will be

488
00:22:45,380 --> 00:22:48,710
on a decentralized contact tracing

489
00:22:48,710 --> 00:22:53,710
and I will explain you the architecture.

490
00:22:53,860 --> 00:22:56,100
So the architecture works like this.

491
00:22:56,100 --> 00:22:59,439
So you have people wearing smartphones

492
00:22:59,440 --> 00:23:02,930
and those smartphones are
sending random numbers.

493
00:23:02,930 --> 00:23:06,670
These random numbers
are changing frequently.

494
00:23:06,670 --> 00:23:10,660
So these numbers are
visible by their neighbors.

495
00:23:10,660 --> 00:23:14,293
So everyone is keeping a
list of all the numbers

496
00:23:14,293 --> 00:23:16,469
that they have sent and or the numbers

497
00:23:16,470 --> 00:23:19,500
that they have received
from their neighbors.

498
00:23:19,500 --> 00:23:22,840
And the idea is that if someone gets sick,

499
00:23:22,840 --> 00:23:26,419
this person will receive some access code

500
00:23:26,420 --> 00:23:29,290
which will give the
privilege to be able to post

501
00:23:29,290 --> 00:23:30,980
on a public bulletin board

502
00:23:30,980 --> 00:23:34,200
all the random numbers
which have been sent

503
00:23:34,200 --> 00:23:37,460
in the recent past together with time

504
00:23:37,460 --> 00:23:39,610
when they have been sent

505
00:23:39,610 --> 00:23:41,610
so that everybody will be able to check

506
00:23:41,610 --> 00:23:46,000
on the public bulletin board,
the numbers which been sent

507
00:23:46,000 --> 00:23:50,260
and belonging to someone who was diagnosed

508
00:23:50,260 --> 00:23:54,140
and people will be able
to compare these numbers

509
00:23:54,140 --> 00:23:55,960
with all the numbers that have received

510
00:23:55,960 --> 00:23:59,660
and if there's a new match,
there will be an alert.

511
00:23:59,660 --> 00:24:03,010
And in the case of an alert,
this person is supposed

512
00:24:03,010 --> 00:24:06,360
to go to quarantine or to get a test.

513
00:24:06,360 --> 00:24:07,570
But in any case,

514
00:24:07,570 --> 00:24:10,913
it is a supposed to be
a stressful situation.

515
00:24:11,830 --> 00:24:16,830
So now the stressful situation
can be used by adversaries.

516
00:24:17,490 --> 00:24:19,360
The idea is that we'll
will have adversaries

517
00:24:19,360 --> 00:24:21,580
trying to inject some false alerts

518
00:24:21,580 --> 00:24:26,060
on the smartphone of their
victim to put them under stress.

519
00:24:26,060 --> 00:24:29,440
We'll consider the attack
model where for instance

520
00:24:29,440 --> 00:24:31,950
the lazy student would
like to have a course

521
00:24:31,950 --> 00:24:33,523
or an exam canceled.

522
00:24:35,050 --> 00:24:37,790
For this he would inject some false alert

523
00:24:37,790 --> 00:24:40,633
on his teachers or classmates.

524
00:24:40,633 --> 00:24:43,380
This can be sort of the same situation

525
00:24:43,380 --> 00:24:46,489
for someone who wants
to inject a false alerts

526
00:24:46,489 --> 00:24:50,260
to his competitors in
any kind of competition

527
00:24:50,260 --> 00:24:52,980
so that his competitor
will be put under stress

528
00:24:52,980 --> 00:24:55,220
and the adversary will have some advantage

529
00:24:55,220 --> 00:24:56,800
in the competition.

530
00:24:56,800 --> 00:24:58,889
We can imagine some kind of terrorism

531
00:24:58,890 --> 00:25:02,220
where someone would
like to massively spread

532
00:25:02,220 --> 00:25:07,220
some false alerts in a population
to cause some disruption.

533
00:25:09,120 --> 00:25:11,409
And we can also imagine someone who wants

534
00:25:11,410 --> 00:25:13,870
to self-inject a false alert on himself,

535
00:25:13,870 --> 00:25:18,179
just to have a good excuse to
escape from some boring events

536
00:25:18,180 --> 00:25:21,253
such as a for instance
dinner at the in-laws.

537
00:25:22,270 --> 00:25:27,000
So how to inject some false alerts.

538
00:25:27,000 --> 00:25:30,190
First, we consider an attack that we call,

539
00:25:30,190 --> 00:25:35,190
keep it stupid simple,
because that's design paradigm

540
00:25:35,970 --> 00:25:38,420
of the decentralized
contact tracing system.

541
00:25:38,420 --> 00:25:40,498
Keep it stupid simple.

542
00:25:40,498 --> 00:25:43,830
So we first considered this,
keep it stupid simple attack

543
00:25:43,830 --> 00:25:46,181
where an adversary is just waiting

544
00:25:46,181 --> 00:25:50,070
until someone posts a random number

545
00:25:50,070 --> 00:25:51,700
on a public bulletin board

546
00:25:52,750 --> 00:25:56,800
and check if the time
where this number was sent

547
00:25:56,800 --> 00:26:00,100
makes it still valid at the present time.

548
00:26:00,100 --> 00:26:02,189
If it is a case, then this adversary

549
00:26:02,190 --> 00:26:04,550
can just replace this random number

550
00:26:04,550 --> 00:26:08,020
and wait until his victim will
check on the bulletin board

551
00:26:08,020 --> 00:26:10,460
because it will raise an alert.

552
00:26:10,460 --> 00:26:12,810
So this attack is really simple.

553
00:26:12,810 --> 00:26:17,409
It's so stupid that we have
some hard time to imagine

554
00:26:17,410 --> 00:26:20,720
that this attack is even possible.

555
00:26:20,720 --> 00:26:22,250
So for that, we have to check

556
00:26:22,250 --> 00:26:27,030
and we check on the public
bulletin board of many regions.

557
00:26:27,030 --> 00:26:31,370
And here we, we drew a
map of all the regions.

558
00:26:31,370 --> 00:26:33,729
So all the call-out regions as the regions

559
00:26:33,730 --> 00:26:37,560
which use the decentralized
contact tracing system

560
00:26:37,560 --> 00:26:39,629
by Apple and Google.

561
00:26:39,630 --> 00:26:44,370
And so the countries, the
regions, which are in gray

562
00:26:44,370 --> 00:26:46,719
are the regions that we didn't test

563
00:26:46,720 --> 00:26:49,630
and all other with tested them.

564
00:26:49,630 --> 00:26:52,430
Regions which are in red are those regions

565
00:26:52,430 --> 00:26:54,950
in which this keys attack is possible.

566
00:26:54,950 --> 00:26:58,720
So for instance, in Italy, in
Austria, in the Netherlands,

567
00:26:58,720 --> 00:27:02,970
in Latvia, we have seen
when we did have our test.

568
00:27:02,970 --> 00:27:06,165
So our test was in last two weeks.

569
00:27:06,165 --> 00:27:07,710
In the last two weeks, we have seen

570
00:27:07,710 --> 00:27:11,230
that sometimes a random number is posted

571
00:27:11,230 --> 00:27:14,210
and this random number is still active.

572
00:27:14,210 --> 00:27:15,043
It's still valid.

573
00:27:15,043 --> 00:27:17,370
We can replay it and it
injects some false alerts.

574
00:27:18,580 --> 00:27:22,870
So in those red countries
we can have such attack.

575
00:27:22,870 --> 00:27:25,919
In the orange countries the
situation is a bit different

576
00:27:25,920 --> 00:27:30,770
because these countries sometimes
copies the random numbers

577
00:27:30,770 --> 00:27:32,550
which have been posted
on the bulletin board

578
00:27:32,550 --> 00:27:34,399
of the right countries.

579
00:27:34,400 --> 00:27:37,910
So if you're, for instance,
in Germany and you can see

580
00:27:37,910 --> 00:27:40,730
on the public bulletin
board of the Netherlands

581
00:27:40,730 --> 00:27:44,080
that there is a key which
is posted and still valid

582
00:27:44,080 --> 00:27:46,699
you can still try to replay it

583
00:27:46,700 --> 00:27:49,150
to all your neighbors in Germany

584
00:27:49,150 --> 00:27:53,340
and maybe in a few hours, this
random numbers will be copied

585
00:27:53,340 --> 00:27:55,939
on the German bulletin board

586
00:27:55,940 --> 00:27:58,610
and it will raise an
alert on your neighbors.

587
00:27:58,610 --> 00:28:03,550
So the attack is still valid
on all those orange regions.

588
00:28:03,550 --> 00:28:07,817
In the green regions, we
didn't see any such case

589
00:28:09,330 --> 00:28:13,370
during the two weeks during
which we did the test.

590
00:28:13,370 --> 00:28:15,459
So if you're in a green country

591
00:28:15,460 --> 00:28:18,660
and this attack is not working

592
00:28:18,660 --> 00:28:23,500
or is so rare that it's not
useful for the adversary

593
00:28:23,500 --> 00:28:26,270
you may still want to
inject some false alerts.

594
00:28:26,270 --> 00:28:29,060
And for that, we will
use another technique.

595
00:28:29,060 --> 00:28:32,250
We will use actually a time machine.

596
00:28:32,250 --> 00:28:36,590
Remember this old movie,
'Back to the Future' in 1985

597
00:28:36,590 --> 00:28:39,270
where someone invented a time machine

598
00:28:39,270 --> 00:28:44,070
and he set as a golden rule,
never to set it to 2020.

599
00:28:44,070 --> 00:28:46,110
At this time, we didn't know why,

600
00:28:46,110 --> 00:28:48,990
but now I can tell you the reasons.

601
00:28:48,990 --> 00:28:53,200
The reason is that
because of time machine,

602
00:28:53,200 --> 00:28:58,200
we can inject some false
alerts very easily.

603
00:28:58,240 --> 00:28:59,120
So how does it work?

604
00:28:59,120 --> 00:29:00,649
Imagine that you have an adversary

605
00:29:00,650 --> 00:29:03,640
who can make his victim
travels through time.

606
00:29:03,640 --> 00:29:05,250
So this adversary's waiting

607
00:29:05,250 --> 00:29:08,583
until a random number is
posted on the bulletin board.

608
00:29:08,583 --> 00:29:13,583
This random number comes
with a time of validity.

609
00:29:13,710 --> 00:29:17,540
Then this adversary will
make his victim travel

610
00:29:17,540 --> 00:29:19,149
to this time of validity.

611
00:29:19,150 --> 00:29:21,940
He will replace a number,
and then he will wait

612
00:29:21,940 --> 00:29:25,090
until his victim comes
back to the present time,

613
00:29:25,090 --> 00:29:28,770
checks the bulletin
board and gets an alert.

614
00:29:28,770 --> 00:29:30,570
So the attack is simple.

615
00:29:30,570 --> 00:29:32,639
We just need a time machine.

616
00:29:32,640 --> 00:29:36,230
So far we didn't succeed to
make people travels through time

617
00:29:36,230 --> 00:29:38,550
but for smartphones it's quite easy

618
00:29:38,550 --> 00:29:42,700
because the smartphones
are not so smart actually,

619
00:29:42,700 --> 00:29:47,357
if we tell them that we
are say in 2020 or in 2030,

620
00:29:49,090 --> 00:29:49,949
they will believe it.

621
00:29:49,950 --> 00:29:52,600
So we can just tell them what is the date

622
00:29:52,600 --> 00:29:54,969
and the smartphone will believe it.

623
00:29:54,970 --> 00:29:59,930
So we made three kinds of time machines

624
00:29:59,930 --> 00:30:02,350
to make smartphones travels through time.

625
00:30:02,350 --> 00:30:06,169
So the easiest one is when
we have some physical access

626
00:30:06,170 --> 00:30:07,640
to the smartphone of the victim,

627
00:30:07,640 --> 00:30:11,930
we can just set the clock
manually or using a malware.

628
00:30:11,930 --> 00:30:14,270
But if we are not in this situation

629
00:30:14,270 --> 00:30:18,210
we can still assume that the smartphone

630
00:30:18,210 --> 00:30:21,790
of the victim and the
equipment of the adversary

631
00:30:21,790 --> 00:30:24,590
are connected to the same wifi network.

632
00:30:24,590 --> 00:30:26,290
If it is a case then the adversary

633
00:30:26,290 --> 00:30:29,260
can do some auth soothing
on the wifi network

634
00:30:29,260 --> 00:30:32,930
and redirect or the NTP
request by the smartphone.

635
00:30:32,930 --> 00:30:36,580
This NTP communication will intercept

636
00:30:36,580 --> 00:30:37,970
as a request to the clock

637
00:30:37,970 --> 00:30:41,094
and we will just be able
to tell the smartphone

638
00:30:41,094 --> 00:30:46,094
what time it is and what date
it is and decide about it.

639
00:30:46,390 --> 00:30:51,390
It works if there is no
priority to set the date,

640
00:30:51,810 --> 00:30:56,810
which is based on the network,
on the communication network.

641
00:30:58,960 --> 00:31:02,010
If there is a priority on
the communication network

642
00:31:02,010 --> 00:31:04,320
what we can do is to make
a rogue based station.

643
00:31:04,320 --> 00:31:07,679
So this is the equipment to
make a rogue based station.

644
00:31:07,680 --> 00:31:09,910
We did it and it works very well.

645
00:31:09,910 --> 00:31:14,141
We tested it in a Faraday
cage and we can set the clock

646
00:31:14,141 --> 00:31:17,450
of a smartphone at a distance this way.

647
00:31:17,450 --> 00:31:18,490
It works very well.

648
00:31:19,460 --> 00:31:24,260
So like this, we can do
a master off time attack.

649
00:31:24,260 --> 00:31:26,660
The idea is that once we get a key

650
00:31:26,660 --> 00:31:29,550
on a public bulletin board
on a time of validity

651
00:31:29,550 --> 00:31:33,419
we make the victim jump to this time.

652
00:31:33,420 --> 00:31:38,420
And then we replay this key
during a few milliseconds

653
00:31:39,130 --> 00:31:41,630
as this key will be
captured by the smartphone.

654
00:31:41,630 --> 00:31:44,480
And if we'll count like
five minutes and counter,

655
00:31:44,480 --> 00:31:48,160
then we'll make another time
job by five minutes ahead,

656
00:31:48,160 --> 00:31:51,060
it will trigger another Bluetooth scan

657
00:31:51,060 --> 00:31:52,990
and it will count for
another five minutes.

658
00:31:52,990 --> 00:31:56,580
We make an additional time
shop of five minutes ahead.

659
00:31:56,580 --> 00:31:59,100
And like this, the smartphone will believe

660
00:31:59,100 --> 00:32:02,219
that he has met someone during 15 minutes.

661
00:32:02,220 --> 00:32:06,180
Also the attack took only one second.

662
00:32:06,180 --> 00:32:08,920
We make the smartphone beliefs
that we have encountered

663
00:32:08,920 --> 00:32:11,720
during 15 minutes, and we can do it

664
00:32:11,720 --> 00:32:16,720
over a quite large region
with a smart equipment.

665
00:32:18,450 --> 00:32:22,770
So like these, the attack
works and it works very easily

666
00:32:22,770 --> 00:32:25,710
and it's very fast and quite discreet.

667
00:32:25,710 --> 00:32:28,830
We can also use this technique

668
00:32:28,830 --> 00:32:31,060
to defeat the privacy protection,

669
00:32:31,060 --> 00:32:33,683
which is in a decentralized
contact tracing.

670
00:32:35,990 --> 00:32:38,096
To defeat the privacy
we can, for instance,

671
00:32:38,096 --> 00:32:42,570
right now recognize if
one of the smartphones

672
00:32:42,570 --> 00:32:46,210
that we can see because it's
sending some random numbers.

673
00:32:46,210 --> 00:32:49,600
We can check if the smartphone is the same

674
00:32:49,600 --> 00:32:52,219
as a smartphone that
we have seen yesterday.

675
00:32:52,220 --> 00:32:53,990
Yesterday we have seen a smartphone,

676
00:32:53,990 --> 00:32:56,240
you sent some random numbers and to check

677
00:32:56,240 --> 00:32:58,440
if the smartphones that we
see right now is the same,

678
00:32:58,440 --> 00:33:02,890
we can make this smartphone
travel back to yesterday

679
00:33:02,890 --> 00:33:04,790
and replay a number.

680
00:33:04,790 --> 00:33:05,670
If the number is the same

681
00:33:05,670 --> 00:33:08,310
we can deduce that the
smartphone was the same.

682
00:33:08,310 --> 00:33:11,270
We can recognize smartphones
that we have seen in the past.

683
00:33:11,270 --> 00:33:14,450
We can anticipate a
recognition in the future

684
00:33:14,450 --> 00:33:18,480
and we can also de
anonymize any smartphone

685
00:33:18,480 --> 00:33:21,590
by making it jump to some reference date

686
00:33:21,590 --> 00:33:24,429
like the 1st of January, 2030.

687
00:33:24,430 --> 00:33:28,072
And like this every
smartphone will always replay

688
00:33:28,072 --> 00:33:31,360
the same number in the
1st of January, 2030.

689
00:33:31,360 --> 00:33:34,580
We can recognize a smartphone this way

690
00:33:34,580 --> 00:33:35,860
by your unique number.

691
00:33:35,860 --> 00:33:38,209
So this is a way to
de-anonymize smartphone.

692
00:33:38,210 --> 00:33:40,710
We essentially ask them, who are you?

693
00:33:40,710 --> 00:33:42,613
And they replied by the same number.

694
00:33:43,920 --> 00:33:48,920
So this attack, we have
documented it last year

695
00:33:50,870 --> 00:33:52,739
and we have reported it.

696
00:33:52,740 --> 00:33:57,410
And the typical reactions that
we have seen is like this.

697
00:33:57,410 --> 00:34:00,350
So people who deploy this
infrastructure considers

698
00:34:00,350 --> 00:34:03,040
that the risk is
acceptable and essentially

699
00:34:03,040 --> 00:34:07,072
they will not implement
any protection against it.

700
00:34:08,980 --> 00:34:11,679
To defeat this type of attack,

701
00:34:11,679 --> 00:34:14,449
what we can say is that
we can try to mandate

702
00:34:14,449 --> 00:34:17,909
the use of a secure cloud
by the operating system.

703
00:34:17,909 --> 00:34:20,420
But I think it will take several years

704
00:34:20,420 --> 00:34:23,563
until we have a secure
clock in operating systems.

705
00:34:24,639 --> 00:34:29,469
We can also try in a
decentralized contact tracing app

706
00:34:29,469 --> 00:34:32,330
to checks at the time is only increasing,

707
00:34:32,330 --> 00:34:35,259
but if we do so we will also
open the way to some denial

708
00:34:35,260 --> 00:34:38,853
of services attack which
is not always a good idea.

709
00:34:40,159 --> 00:34:42,850
And lastly, we can also try to have

710
00:34:42,850 --> 00:34:47,850
some more elaborate detection
of clock manipulation

711
00:34:49,780 --> 00:34:53,863
which is a bit more
complicated, but it's feasible.

712
00:34:55,000 --> 00:34:57,610
So that's for the possible countermeasure.

713
00:34:57,610 --> 00:35:00,890
As a final conclusion, what I can say is

714
00:35:00,890 --> 00:35:03,890
that these decentralized
contact tracing systems

715
00:35:03,890 --> 00:35:06,460
which were proposed
more than one years ago,

716
00:35:06,460 --> 00:35:09,290
it was proposed with objective

717
00:35:09,290 --> 00:35:12,070
to have a very high security protection

718
00:35:12,070 --> 00:35:14,360
and very high privacy protection.

719
00:35:14,360 --> 00:35:19,040
But we can see that all those
promises have been broken.

720
00:35:19,040 --> 00:35:20,930
The security is not so good.

721
00:35:20,930 --> 00:35:23,620
The privacy protection is not so good.

722
00:35:23,620 --> 00:35:28,470
And we believe that people
have been deceived by this.

723
00:35:28,470 --> 00:35:32,337
I collected also many other observation

724
00:35:32,337 --> 00:35:35,670
on these decentralized contact
tracing system on this year

725
00:35:35,670 --> 00:35:38,620
and I invite you to check this.

726
00:35:38,620 --> 00:35:40,596
Thank you very much for your attention.

