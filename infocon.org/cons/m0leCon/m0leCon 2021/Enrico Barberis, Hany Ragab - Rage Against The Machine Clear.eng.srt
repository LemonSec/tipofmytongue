1
00:00:03,040 --> 00:00:06,319
yes welcome to our talk the name is rage

2
00:00:06,319 --> 00:00:08,000
against the machine clear

3
00:00:08,000 --> 00:00:10,639
a systematic analysis of machine clears

4
00:00:10,639 --> 00:00:12,080
and an implication for transcendent

5
00:00:12,080 --> 00:00:14,080
execution attacks

6
00:00:14,080 --> 00:00:16,560
this was a paper made by me and my

7
00:00:16,560 --> 00:00:19,039
colleague hani ragab together with our

8
00:00:19,039 --> 00:00:21,760
professor herbert and cristiano

9
00:00:21,760 --> 00:00:23,359
and we are coming from the vusak

10
00:00:23,359 --> 00:00:26,800
security group in amsterdam

11
00:00:27,039 --> 00:00:28,960
the torque will be

12
00:00:28,960 --> 00:00:30,880
splitter in this way we start with a

13
00:00:30,880 --> 00:00:32,719
small background section

14
00:00:32,719 --> 00:00:34,399
and then we go to the main core of the

15
00:00:34,399 --> 00:00:36,399
presentation that is the

16
00:00:36,399 --> 00:00:38,079
machine clears indeed

17
00:00:38,079 --> 00:00:41,120
and also i know you you like this stuff

18
00:00:41,120 --> 00:00:42,559
we're going to show you a full antenna

19
00:00:42,559 --> 00:00:45,920
exploit on firefox on based on our work

20
00:00:45,920 --> 00:00:48,079
and finally we conclude on some

21
00:00:48,079 --> 00:00:50,079
results

22
00:00:50,079 --> 00:00:51,120
okay

23
00:00:51,120 --> 00:00:52,719
let's break the eyes

24
00:00:52,719 --> 00:00:56,239
how many of you know this this image

25
00:00:56,239 --> 00:00:59,440
maybe okay see one two three okay good

26
00:00:59,440 --> 00:01:00,239
so

27
00:01:00,239 --> 00:01:02,399
this is a perfect example of side

28
00:01:02,399 --> 00:01:04,959
channel basically

29
00:01:04,959 --> 00:01:06,720
the police the dutch police

30
00:01:06,720 --> 00:01:09,439
managed to discover uh people growing

31
00:01:09,439 --> 00:01:11,280
weed in their apartment

32
00:01:11,280 --> 00:01:13,600
just by observing the melted snow on the

33
00:01:13,600 --> 00:01:14,479
roof

34
00:01:14,479 --> 00:01:16,240
due to the high temperature of

35
00:01:16,240 --> 00:01:18,080
growing the plants

36
00:01:18,080 --> 00:01:19,840
so the police just by passing there they

37
00:01:19,840 --> 00:01:21,200
managed to

38
00:01:21,200 --> 00:01:23,840
understand something that is not visible

39
00:01:23,840 --> 00:01:26,479
but yet thanks to a side effect of the

40
00:01:26,479 --> 00:01:28,799
action you can still discover what's

41
00:01:28,799 --> 00:01:30,000
happening

42
00:01:30,000 --> 00:01:32,880
behind let's say a wall

43
00:01:32,880 --> 00:01:35,040
but today we are talking about computers

44
00:01:35,040 --> 00:01:37,119
not about growing weeds sorry so all

45
00:01:37,119 --> 00:01:38,079
these

46
00:01:38,079 --> 00:01:40,720
correlate with the processors

47
00:01:40,720 --> 00:01:43,680
well that was a thermal say channel

48
00:01:43,680 --> 00:01:46,479
with cpu is much better to talk about

49
00:01:46,479 --> 00:01:48,159
timing say channel

50
00:01:48,159 --> 00:01:49,280
and the most

51
00:01:49,280 --> 00:01:51,520
famous one is a flashing reload

52
00:01:51,520 --> 00:01:54,320
it's a quite simple in the end imagine

53
00:01:54,320 --> 00:01:56,719
we have two processes attacker and

54
00:01:56,719 --> 00:01:57,759
victim

55
00:01:57,759 --> 00:01:59,600
and we have the data cache in the bottom

56
00:01:59,600 --> 00:02:00,799
that is a

57
00:02:00,799 --> 00:02:02,399
shared resource of

58
00:02:02,399 --> 00:02:03,759
on the processor it's a physical

59
00:02:03,759 --> 00:02:05,360
resource

60
00:02:05,360 --> 00:02:07,200
the first step is to

61
00:02:07,200 --> 00:02:09,440
remove from the cache every cache line

62
00:02:09,440 --> 00:02:11,599
in the in the cache indeed

63
00:02:11,599 --> 00:02:12,959
and then

64
00:02:12,959 --> 00:02:14,879
we wait for the victim to execute some

65
00:02:14,879 --> 00:02:16,319
secret code

66
00:02:16,319 --> 00:02:18,879
and let's say that depending on a secret

67
00:02:18,879 --> 00:02:21,120
b of a cryptographic cryptographic key

68
00:02:21,120 --> 00:02:23,200
for example the victim is either

69
00:02:23,200 --> 00:02:25,760
accessing entry zero or one of the array

70
00:02:25,760 --> 00:02:28,000
and let's say for example the entry one

71
00:02:28,000 --> 00:02:29,440
was accessed

72
00:02:29,440 --> 00:02:31,440
this means that the processor will bring

73
00:02:31,440 --> 00:02:32,959
into the cache

74
00:02:32,959 --> 00:02:34,000
array

75
00:02:34,000 --> 00:02:35,519
one

76
00:02:35,519 --> 00:02:38,080
and later the attacker using the reload

77
00:02:38,080 --> 00:02:39,280
step

78
00:02:39,280 --> 00:02:42,319
it can measure the access time of every

79
00:02:42,319 --> 00:02:44,160
array entry

80
00:02:44,160 --> 00:02:46,080
and the first one will be slow because

81
00:02:46,080 --> 00:02:47,280
the data

82
00:02:47,280 --> 00:02:49,360
is not there so it will take a lot of

83
00:02:49,360 --> 00:02:51,840
time to read this value

84
00:02:51,840 --> 00:02:53,920
while reading a red one will be much

85
00:02:53,920 --> 00:02:55,519
faster because the data is already in

86
00:02:55,519 --> 00:02:57,519
the cache and the load time will be much

87
00:02:57,519 --> 00:02:59,760
faster and this timing difference is

88
00:02:59,760 --> 00:03:02,480
measurable on the processor

89
00:03:02,480 --> 00:03:03,200
so

90
00:03:03,200 --> 00:03:06,159
again just by a side effect of caching

91
00:03:06,159 --> 00:03:08,480
or not caching something an attacker can

92
00:03:08,480 --> 00:03:10,560
observe a timing difference

93
00:03:10,560 --> 00:03:13,680
in a load operation

94
00:03:14,400 --> 00:03:16,239
things get very interesting when

95
00:03:16,239 --> 00:03:18,640
combining these timing side channel

96
00:03:18,640 --> 00:03:21,040
with uh speculative execution

97
00:03:21,040 --> 00:03:23,680
it is also called transit execution

98
00:03:23,680 --> 00:03:25,760
so again processor to optimize

99
00:03:25,760 --> 00:03:28,319
performance as much as possible

100
00:03:28,319 --> 00:03:30,480
it will speculate on instruction that

101
00:03:30,480 --> 00:03:33,599
will be executed later so for example

102
00:03:33,599 --> 00:03:35,599
this is a very normal snippet of code we

103
00:03:35,599 --> 00:03:38,480
have a bounded array access

104
00:03:38,480 --> 00:03:40,799
and we are very fine that the

105
00:03:40,799 --> 00:03:42,319
load operation is in

106
00:03:42,319 --> 00:03:45,360
the bound size of the array

107
00:03:45,360 --> 00:03:46,959
let's say that for example the array

108
00:03:46,959 --> 00:03:49,280
size is uh not really available is

109
00:03:49,280 --> 00:03:52,159
coming from a long load operation

110
00:03:52,159 --> 00:03:55,760
the processor will not wait to

111
00:03:55,760 --> 00:03:57,360
you know wait this load to know what to

112
00:03:57,360 --> 00:04:00,159
do next it will speculate and execute

113
00:04:00,159 --> 00:04:03,200
the inner body of this condition even if

114
00:04:03,200 --> 00:04:07,040
maybe this is a wrong execution path

115
00:04:07,040 --> 00:04:09,200
so let's say you speculate execute the

116
00:04:09,200 --> 00:04:11,439
body of the branch and as we saw earlier

117
00:04:11,439 --> 00:04:13,280
we are also caching

118
00:04:13,280 --> 00:04:14,640
some entry

119
00:04:14,640 --> 00:04:17,358
due to this load of the array x

120
00:04:17,358 --> 00:04:18,959
but let's say again that this prediction

121
00:04:18,959 --> 00:04:20,079
was wrong

122
00:04:20,079 --> 00:04:22,560
the processor must revert everything and

123
00:04:22,560 --> 00:04:25,120
then take the other branch path

124
00:04:25,120 --> 00:04:28,000
however this entry is still present in

125
00:04:28,000 --> 00:04:31,120
the cache even if destruction never

126
00:04:31,120 --> 00:04:33,199
retired or was never committed

127
00:04:33,199 --> 00:04:35,280
so the attacker can observe what the

128
00:04:35,280 --> 00:04:37,919
processor did on the wrong path

129
00:04:37,919 --> 00:04:40,000
and here

130
00:04:40,000 --> 00:04:41,600
many attacks can

131
00:04:41,600 --> 00:04:42,560
be

132
00:04:42,560 --> 00:04:44,240
generated as you can see

133
00:04:44,240 --> 00:04:45,680
this is just the

134
00:04:45,680 --> 00:04:47,840
most famous attack of the

135
00:04:47,840 --> 00:04:48,960
last years

136
00:04:48,960 --> 00:04:51,040
from 2017 basically

137
00:04:51,040 --> 00:04:52,960
probably you know about spectra meltdown

138
00:04:52,960 --> 00:04:54,840
that was quite famous back in the

139
00:04:54,840 --> 00:04:57,360
days later there was this big class

140
00:04:57,360 --> 00:04:58,759
named

141
00:04:58,759 --> 00:05:00,320
microsampling

142
00:05:00,320 --> 00:05:02,080
it's basically leaking from many other

143
00:05:02,080 --> 00:05:04,320
buffers in the

144
00:05:04,320 --> 00:05:06,880
in the processor we also for example

145
00:05:06,880 --> 00:05:08,880
orbital injection

146
00:05:08,880 --> 00:05:11,440
later also we had the crosstalk we are

147
00:05:11,440 --> 00:05:13,600
not only leaking in the same

148
00:05:13,600 --> 00:05:14,880
core but

149
00:05:14,880 --> 00:05:18,160
from other addition cores so we are

150
00:05:18,160 --> 00:05:20,080
removing this bound

151
00:05:20,080 --> 00:05:21,759
and now today we are presenting our

152
00:05:21,759 --> 00:05:24,080
latest work it is a new category of this

153
00:05:24,080 --> 00:05:26,560
kind of attack that is machine clear

154
00:05:26,560 --> 00:05:28,560
and here we managed to build two attack

155
00:05:28,560 --> 00:05:30,720
primitives confirmed by

156
00:05:30,720 --> 00:05:32,320
major vendors that are floating point by

157
00:05:32,320 --> 00:05:34,639
injection and speculative code store by

158
00:05:34,639 --> 00:05:36,240
pass

159
00:05:36,240 --> 00:05:37,680
now we'll give

160
00:05:37,680 --> 00:05:40,240
to a high in this stage

161
00:05:40,240 --> 00:05:42,240
all right so um

162
00:05:42,240 --> 00:05:44,960
intel defines the bad speculation or the

163
00:05:44,960 --> 00:05:47,680
main cause of discarding uh

164
00:05:47,680 --> 00:05:49,840
issued micro operations and exists

165
00:05:49,840 --> 00:05:52,400
processors so whenever we

166
00:05:52,400 --> 00:05:54,800
not commit some sort of

167
00:05:54,800 --> 00:05:57,039
micro patients on x86 processors this is

168
00:05:57,039 --> 00:05:58,639
a bad speculation and it can be caused

169
00:05:58,639 --> 00:06:01,840
by many different root causes

170
00:06:01,840 --> 00:06:04,800
the and they're classified by intel into

171
00:06:04,800 --> 00:06:06,880
two main classes the first one is

172
00:06:06,880 --> 00:06:08,319
branches prediction where we have a

173
00:06:08,319 --> 00:06:10,080
bench predictor that mispredicts either

174
00:06:10,080 --> 00:06:11,600
the target or the detection of our

175
00:06:11,600 --> 00:06:13,440
branch as we saw earlier

176
00:06:13,440 --> 00:06:14,400
and

177
00:06:14,400 --> 00:06:16,000
the second one is called machine clear

178
00:06:16,000 --> 00:06:17,840
where we have a condition that

179
00:06:17,840 --> 00:06:20,000
deterministically will flush the entire

180
00:06:20,000 --> 00:06:21,759
pipeline and restart the execution from

181
00:06:21,759 --> 00:06:23,919
the last retired instruction

182
00:06:23,919 --> 00:06:25,199
and this is what we're going to present

183
00:06:25,199 --> 00:06:26,160
today

184
00:06:26,160 --> 00:06:28,160
so again branch predictions have been

185
00:06:28,160 --> 00:06:30,319
widely used along with different types

186
00:06:30,319 --> 00:06:33,199
of faults and intel tsx abortions in all

187
00:06:33,199 --> 00:06:35,280
the main trans execution attacks that

188
00:06:35,280 --> 00:06:37,520
have been widely discovered in the

189
00:06:37,520 --> 00:06:38,639
recent years

190
00:06:38,639 --> 00:06:40,479
but the same cannot be said about the

191
00:06:40,479 --> 00:06:42,000
class of machine clear that remains

192
00:06:42,000 --> 00:06:44,240
until our work widely unexplored and

193
00:06:44,240 --> 00:06:46,840
this is what we are going to do

194
00:06:46,840 --> 00:06:49,680
today so in this work we performed the

195
00:06:49,680 --> 00:06:51,680
reverse engineering and the security

196
00:06:51,680 --> 00:06:54,000
analysis of the four four main types of

197
00:06:54,000 --> 00:06:55,680
machine clear which are self-modifying

198
00:06:55,680 --> 00:06:57,919
code floating point memory ordering and

199
00:06:57,919 --> 00:07:00,479
memory jumbication machine clear

200
00:07:00,479 --> 00:07:02,160
two of these four types led us to

201
00:07:02,160 --> 00:07:07,039
discover um two uh brand new transaction

202
00:07:07,039 --> 00:07:08,880
execution based attack primitives the

203
00:07:08,880 --> 00:07:10,319
first one is called speculative code

204
00:07:10,319 --> 00:07:11,599
store bypass

205
00:07:11,599 --> 00:07:13,280
and the second one is called floating

206
00:07:13,280 --> 00:07:16,758
point value injection

207
00:07:17,120 --> 00:07:19,280
um furthermore uh following point value

208
00:07:19,280 --> 00:07:21,599
injection led us to mount and end and

209
00:07:21,599 --> 00:07:23,680
exploit leaking advertising memory

210
00:07:23,680 --> 00:07:26,000
addresses inside the latest firefox web

211
00:07:26,000 --> 00:07:29,199
browser that main users are using and

212
00:07:29,199 --> 00:07:31,520
this attack can reach a leakage rate

213
00:07:31,520 --> 00:07:34,319
that can be up to 13 kilobytes per

214
00:07:34,319 --> 00:07:36,560
second

215
00:07:36,560 --> 00:07:38,160
so in order to perform the

216
00:07:38,160 --> 00:07:39,919
re-engineering of these

217
00:07:39,919 --> 00:07:41,919
types of machine clear we first try to

218
00:07:41,919 --> 00:07:43,120
understand what is the architectural

219
00:07:43,120 --> 00:07:44,639
environment behind each type of machine

220
00:07:44,639 --> 00:07:46,000
clear

221
00:07:46,000 --> 00:07:47,919
second how this invariant can be

222
00:07:47,919 --> 00:07:50,000
violated and therefore triggering a

223
00:07:50,000 --> 00:07:51,280
machine clear flushing the entire

224
00:07:51,280 --> 00:07:52,879
pipeline

225
00:07:52,879 --> 00:07:53,759
third

226
00:07:53,759 --> 00:07:56,240
how this invariant violation what is the

227
00:07:56,240 --> 00:07:58,560
security implication of this violation

228
00:07:58,560 --> 00:07:59,759
and

229
00:07:59,759 --> 00:08:01,360
lastly how this

230
00:08:01,360 --> 00:08:03,919
violation can be exploited leaking to

231
00:08:03,919 --> 00:08:07,440
a leakage of secret information

232
00:08:07,440 --> 00:08:08,639
so the first type of machine clear

233
00:08:08,639 --> 00:08:09,840
representing today is called

234
00:08:09,840 --> 00:08:11,919
self-refined code machine clear and it's

235
00:08:11,919 --> 00:08:13,440
based on the concept of self-modifying

236
00:08:13,440 --> 00:08:15,520
code which is a program storing

237
00:08:15,520 --> 00:08:18,319
instructions as data modifying its own

238
00:08:18,319 --> 00:08:20,560
code as it's being executed

239
00:08:20,560 --> 00:08:22,400
uh self-marketing code have been widely

240
00:08:22,400 --> 00:08:23,440
used

241
00:08:23,440 --> 00:08:25,039
in malware trying to unpack themselves

242
00:08:25,039 --> 00:08:26,879
at the right moment this one of the most

243
00:08:26,879 --> 00:08:28,879
famous use cases

244
00:08:28,879 --> 00:08:30,879
but here we'll see it in a totally

245
00:08:30,879 --> 00:08:33,599
different way that it's being used

246
00:08:33,599 --> 00:08:35,599
let's take the snippet of code where we

247
00:08:35,599 --> 00:08:37,760
have two instructions we have a store

248
00:08:37,760 --> 00:08:40,399
and a load the store is trying to modify

249
00:08:40,399 --> 00:08:41,440
the load

250
00:08:41,440 --> 00:08:43,519
changing it from a load secret to an

251
00:08:43,519 --> 00:08:46,080
operation

252
00:08:46,720 --> 00:08:49,519
modern front ends of modern x86

253
00:08:49,519 --> 00:08:50,959
processors

254
00:08:50,959 --> 00:08:53,519
try to speculatively fetch the code and

255
00:08:53,519 --> 00:08:55,120
execute to maximize the execution

256
00:08:55,120 --> 00:08:57,040
throughput they're not going to wait

257
00:08:57,040 --> 00:08:58,560
until the architectural information is

258
00:08:58,560 --> 00:09:00,240
ready so they try to do this in a

259
00:09:00,240 --> 00:09:02,560
totally speculative manner

260
00:09:02,560 --> 00:09:04,080
and when

261
00:09:04,080 --> 00:09:07,120
the front-end encounters a self-refined

262
00:09:07,120 --> 00:09:08,640
code

263
00:09:08,640 --> 00:09:10,800
the store at some point will have to

264
00:09:10,800 --> 00:09:13,920
modify the following instruction and

265
00:09:13,920 --> 00:09:15,200
we'll do this

266
00:09:15,200 --> 00:09:17,040
by

267
00:09:17,040 --> 00:09:19,680
modifying and targeting the already

268
00:09:19,680 --> 00:09:22,640
residing instruction in the uh

269
00:09:22,640 --> 00:09:24,880
in the instruction cache but by the time

270
00:09:24,880 --> 00:09:27,279
that this is actually detected

271
00:09:27,279 --> 00:09:29,279
the cpu have already

272
00:09:29,279 --> 00:09:31,920
decoded and executed the load secret

273
00:09:31,920 --> 00:09:33,360
speculatively

274
00:09:33,360 --> 00:09:34,959
and by the time it actually detects that

275
00:09:34,959 --> 00:09:37,200
there was a store trying to modify this

276
00:09:37,200 --> 00:09:38,800
already fetched the code and executed

277
00:09:38,800 --> 00:09:41,279
instruction this have already left an

278
00:09:41,279 --> 00:09:42,959
observable micro-architectural trace as

279
00:09:42,959 --> 00:09:45,120
we saw earlier that an attacker can

280
00:09:45,120 --> 00:09:46,320
observe

281
00:09:46,320 --> 00:09:48,000
so this detection of a self-modifying

282
00:09:48,000 --> 00:09:50,720
code is not immediate and it leaves some

283
00:09:50,720 --> 00:09:51,839
time

284
00:09:51,839 --> 00:09:52,640
for

285
00:09:52,640 --> 00:09:54,880
instruction to be executed speculatively

286
00:09:54,880 --> 00:09:57,360
leaving an observable microarchitectural

287
00:09:57,360 --> 00:09:59,680
trace

288
00:09:59,680 --> 00:10:02,000
so the architectural implied here of a

289
00:10:02,000 --> 00:10:03,600
self-modifying code is that store

290
00:10:03,600 --> 00:10:06,000
instructions always target data

291
00:10:06,000 --> 00:10:07,760
addresses

292
00:10:07,760 --> 00:10:09,680
this event is violated in the case of a

293
00:10:09,680 --> 00:10:12,000
cell phone frame code which targets code

294
00:10:12,000 --> 00:10:14,880
addresses instead

295
00:10:15,360 --> 00:10:17,760
this allows an attacker to transiently

296
00:10:17,760 --> 00:10:19,760
execute still code which in this case

297
00:10:19,760 --> 00:10:21,200
the load secret

298
00:10:21,200 --> 00:10:23,200
this load secret will never be committed

299
00:10:23,200 --> 00:10:25,600
because the committed instruction is the

300
00:10:25,600 --> 00:10:27,200
no operation not the load secret the

301
00:10:27,200 --> 00:10:28,480
load circuit have been executed

302
00:10:28,480 --> 00:10:30,480
speculatively leaving an observable

303
00:10:30,480 --> 00:10:31,440
micro

304
00:10:31,440 --> 00:10:34,240
micro architectural trace

305
00:10:34,240 --> 00:10:35,839
and in order to understand how this can

306
00:10:35,839 --> 00:10:37,760
be exploited we have to understand what

307
00:10:37,760 --> 00:10:38,800
is the attack primitive that the

308
00:10:38,800 --> 00:10:40,480
software friend code is actually giving

309
00:10:40,480 --> 00:10:42,560
us

310
00:10:42,560 --> 00:10:43,760
so the decorative would have to be

311
00:10:43,760 --> 00:10:45,440
mounted on top of sulfur code machine

312
00:10:45,440 --> 00:10:46,720
clear is called

313
00:10:46,720 --> 00:10:48,560
speculative code search bypass

314
00:10:48,560 --> 00:10:49,920
and its

315
00:10:49,920 --> 00:10:52,800
main use case uh is an environment where

316
00:10:52,800 --> 00:10:54,560
an attacker can perform the two main

317
00:10:54,560 --> 00:10:56,320
steps of all self-modifying code which

318
00:10:56,320 --> 00:11:00,480
are writing code and executing it

319
00:11:00,480 --> 00:11:01,839
one of the

320
00:11:01,839 --> 00:11:03,040
most famous

321
00:11:03,040 --> 00:11:04,720
attack scenarios in this case are jit

322
00:11:04,720 --> 00:11:07,440
engines where an attacker control code

323
00:11:07,440 --> 00:11:11,200
is manipulated and it can be executed

324
00:11:11,200 --> 00:11:13,440
when when the attacker wants basically

325
00:11:13,440 --> 00:11:14,560
so

326
00:11:14,560 --> 00:11:17,680
in this case we have a function f that

327
00:11:17,680 --> 00:11:19,440
the attacker is trying to write to

328
00:11:19,440 --> 00:11:20,800
perform the first step of software frame

329
00:11:20,800 --> 00:11:22,959
code and then we'll later try to execute

330
00:11:22,959 --> 00:11:23,760
it

331
00:11:23,760 --> 00:11:25,440
but before getting into the three main

332
00:11:25,440 --> 00:11:27,040
steps of our attack primitive keep in

333
00:11:27,040 --> 00:11:29,760
mind that code and data are two

334
00:11:29,760 --> 00:11:33,120
views of the same exact memory

335
00:11:33,120 --> 00:11:34,560
and they always they're always kept

336
00:11:34,560 --> 00:11:37,040
coherent between each other

337
00:11:37,040 --> 00:11:38,399
so in the first step of our attack

338
00:11:38,399 --> 00:11:40,640
primitive as we said the attacker will

339
00:11:40,640 --> 00:11:41,600
try to

340
00:11:41,600 --> 00:11:44,399
write the code of a function f where the

341
00:11:44,399 --> 00:11:46,880
code of a function g is already residing

342
00:11:46,880 --> 00:11:49,440
and again this is done on the data view

343
00:11:49,440 --> 00:11:53,120
we are writing code as data

344
00:11:53,440 --> 00:11:55,040
then this

345
00:11:55,040 --> 00:11:57,600
this store instruction of the function f

346
00:11:57,600 --> 00:12:00,880
will temporarily desynchronize code view

347
00:12:00,880 --> 00:12:02,560
and data view the code view will

348
00:12:02,560 --> 00:12:05,360
continue to contain

349
00:12:05,360 --> 00:12:07,760
the code of the function g the data view

350
00:12:07,760 --> 00:12:10,000
will contain the new code that attacker

351
00:12:10,000 --> 00:12:13,040
just wrote and now if the attacker tries

352
00:12:13,040 --> 00:12:15,760
to execute and call the function that it

353
00:12:15,760 --> 00:12:18,240
just wrote what will happen is that the

354
00:12:18,240 --> 00:12:20,639
cpu will fetch the code residing at the

355
00:12:20,639 --> 00:12:22,880
same address from the code view

356
00:12:22,880 --> 00:12:25,600
which is temporarily synchronized

357
00:12:25,600 --> 00:12:28,320
so it will speculatively execute the

358
00:12:28,320 --> 00:12:31,279
code of function g instead

359
00:12:31,279 --> 00:12:32,480
at some point

360
00:12:32,480 --> 00:12:34,639
the cpu will detect there has been a

361
00:12:34,639 --> 00:12:36,320
self modifying code the synchronizing

362
00:12:36,320 --> 00:12:38,480
code and data and will issue a machine

363
00:12:38,480 --> 00:12:40,720
clear flushing its pipeline from the

364
00:12:40,720 --> 00:12:42,399
code that has been speculatively

365
00:12:42,399 --> 00:12:44,480
executed which is in this case

366
00:12:44,480 --> 00:12:46,639
function g

367
00:12:46,639 --> 00:12:48,639
eventually the cpu will restore the

368
00:12:48,639 --> 00:12:50,959
coherence between code and data and will

369
00:12:50,959 --> 00:12:51,839
write

370
00:12:51,839 --> 00:12:53,920
the new code also in the code view and

371
00:12:53,920 --> 00:12:56,160
will take the architectural execution

372
00:12:56,160 --> 00:12:58,800
path of executing the new code that was

373
00:12:58,800 --> 00:13:02,639
meant to be executed in the first place

374
00:13:03,200 --> 00:13:05,440
we tried to understand how intel

375
00:13:05,440 --> 00:13:06,639
suggests to

376
00:13:06,639 --> 00:13:08,480
handle software find code and cross

377
00:13:08,480 --> 00:13:10,639
modifying code and we

378
00:13:10,639 --> 00:13:12,240
observed that

379
00:13:12,240 --> 00:13:13,680
the first option that intel is actually

380
00:13:13,680 --> 00:13:16,480
suggesting to do so is describing the

381
00:13:16,480 --> 00:13:19,200
exact steps that our attack primitive is

382
00:13:19,200 --> 00:13:20,480
actually doing

383
00:13:20,480 --> 00:13:21,839
it's telling

384
00:13:21,839 --> 00:13:24,399
write code and execute it without no

385
00:13:24,399 --> 00:13:26,560
notion of this the synchronization that

386
00:13:26,560 --> 00:13:28,000
can actually happen in the back in the

387
00:13:28,000 --> 00:13:29,680
background so

388
00:13:29,680 --> 00:13:32,000
any program that is adopting option one

389
00:13:32,000 --> 00:13:33,440
to handle self and code and

390
00:13:33,440 --> 00:13:35,279
cross-modifying code they are actually

391
00:13:35,279 --> 00:13:36,880
performing a speculative code

392
00:13:36,880 --> 00:13:38,720
store-by-pass attack in the background

393
00:13:38,720 --> 00:13:42,000
with actually knowing about it

394
00:13:42,399 --> 00:13:43,279
so

395
00:13:43,279 --> 00:13:45,440
how we can actually mitigate such such

396
00:13:45,440 --> 00:13:48,079
an attack what we need to do is that

397
00:13:48,079 --> 00:13:50,800
once we store a new code this is already

398
00:13:50,800 --> 00:13:52,959
visible in the code view so whenever we

399
00:13:52,959 --> 00:13:54,800
try to call it we're calling the new

400
00:13:54,800 --> 00:13:57,279
code and not the the sale one and what

401
00:13:57,279 --> 00:13:58,480
we do is

402
00:13:58,480 --> 00:14:00,720
actually adopting option two which is

403
00:14:00,720 --> 00:14:03,760
suggesting to uh call uh issuing a

404
00:14:03,760 --> 00:14:06,000
serializing instruction right after we

405
00:14:06,000 --> 00:14:07,680
call uh right after we store the new

406
00:14:07,680 --> 00:14:10,079
code so what we do is

407
00:14:10,079 --> 00:14:12,399
write the new code serialize

408
00:14:12,399 --> 00:14:14,880
and make sure that the code view is

409
00:14:14,880 --> 00:14:16,720
containing the new code and not any

410
00:14:16,720 --> 00:14:20,399
state code that was residing there

411
00:14:21,440 --> 00:14:23,440
interestingly

412
00:14:23,440 --> 00:14:24,320
both

413
00:14:24,320 --> 00:14:26,560
chrome and firefox the two main web

414
00:14:26,560 --> 00:14:28,480
browsers that millions of users are

415
00:14:28,480 --> 00:14:31,360
using they do not do anything when they

416
00:14:31,360 --> 00:14:33,199
actually write new code because they are

417
00:14:33,199 --> 00:14:36,240
relying on option one that cpu vendors

418
00:14:36,240 --> 00:14:38,800
are suggesting which is code and data

419
00:14:38,800 --> 00:14:40,480
are meant to be coherent all the time

420
00:14:40,480 --> 00:14:42,240
don't worry about it just write your new

421
00:14:42,240 --> 00:14:44,800
code and execute it but based on what we

422
00:14:44,800 --> 00:14:47,519
do what we discovered we are actually

423
00:14:47,519 --> 00:14:49,040
performing a speculative code story

424
00:14:49,040 --> 00:14:51,199
bypass without knowing anything anything

425
00:14:51,199 --> 00:14:53,599
about it

426
00:14:53,760 --> 00:14:56,320
so for exploitation of

427
00:14:56,320 --> 00:14:59,199
smc we have a speculative story bypass

428
00:14:59,199 --> 00:15:01,360
which allows an attacker to uh

429
00:15:01,360 --> 00:15:03,279
transiently execute cell code which is

430
00:15:03,279 --> 00:15:04,800
somehow similar to its architectural

431
00:15:04,800 --> 00:15:06,720
counterpart which is a user use of the

432
00:15:06,720 --> 00:15:08,560
free attack primitive which allows an

433
00:15:08,560 --> 00:15:10,320
attacker to

434
00:15:10,320 --> 00:15:12,800
dereference memory which uh is no lo no

435
00:15:12,800 --> 00:15:15,040
longer referenced uh yet

436
00:15:15,040 --> 00:15:17,519
anymore sorry

437
00:15:17,519 --> 00:15:19,440
okay so this was one type of machine

438
00:15:19,440 --> 00:15:21,199
clear the second type we're presenting

439
00:15:21,199 --> 00:15:23,839
is called memory ordering and it's built

440
00:15:23,839 --> 00:15:26,800
on top of the total store order memory

441
00:15:26,800 --> 00:15:29,040
model which guarantees that all cpu

442
00:15:29,040 --> 00:15:32,160
cores see all memory operations as the

443
00:15:32,160 --> 00:15:35,600
program order except of one case

444
00:15:35,600 --> 00:15:37,279
when we have a store instruction

445
00:15:37,279 --> 00:15:39,600
followed by a load instruction operating

446
00:15:39,600 --> 00:15:41,600
on different addresses these two

447
00:15:41,600 --> 00:15:45,199
instructions may be reordered

448
00:15:45,199 --> 00:15:47,040
let's take a look at this

449
00:15:47,040 --> 00:15:49,279
example we have processor a that is

450
00:15:49,279 --> 00:15:52,000
performing two load operations and then

451
00:15:52,000 --> 00:15:54,639
a function call on a dependent

452
00:15:54,639 --> 00:15:56,800
result and we have processor b which is

453
00:15:56,800 --> 00:15:58,399
performing two store

454
00:15:58,399 --> 00:16:00,160
operations on the same addresses that

455
00:16:00,160 --> 00:16:02,880
processor a is manipulating

456
00:16:02,880 --> 00:16:04,959
so let's assume that for some reason the

457
00:16:04,959 --> 00:16:07,600
first load of processor a is slow due to

458
00:16:07,600 --> 00:16:10,160
cache misses the the data at address x

459
00:16:10,160 --> 00:16:11,440
needs to be fetched from main memory

460
00:16:11,440 --> 00:16:12,800
this takes time

461
00:16:12,800 --> 00:16:15,279
so what processor a will do is again

462
00:16:15,279 --> 00:16:16,800
tries to maximize the execution

463
00:16:16,800 --> 00:16:19,519
throughput by not waiting for the data

464
00:16:19,519 --> 00:16:21,600
of address x to be fetched and will

465
00:16:21,600 --> 00:16:24,160
execute out of order the second load on

466
00:16:24,160 --> 00:16:26,240
address y and all subsequent dependent

467
00:16:26,240 --> 00:16:28,399
operations and we'll keep them in a

468
00:16:28,399 --> 00:16:31,360
ready to commit state so once

469
00:16:31,360 --> 00:16:33,680
the data address x is fed from memory it

470
00:16:33,680 --> 00:16:35,759
will commit everything in program order

471
00:16:35,759 --> 00:16:38,079
following the total store order memory

472
00:16:38,079 --> 00:16:39,040
model

473
00:16:39,040 --> 00:16:41,360
but let's assume that at this point

474
00:16:41,360 --> 00:16:43,360
processor b executes its store

475
00:16:43,360 --> 00:16:46,160
operations what will happen here is that

476
00:16:46,160 --> 00:16:49,120
processor a cannot commit

477
00:16:49,120 --> 00:16:51,199
what it actually executed out of order

478
00:16:51,199 --> 00:16:53,759
as is because it would be the proof that

479
00:16:53,759 --> 00:16:55,920
it violated the memory model

480
00:16:55,920 --> 00:16:57,600
so what it will do

481
00:16:57,600 --> 00:17:00,160
it will flush its pipeline from this

482
00:17:00,160 --> 00:17:02,639
instructions executed out of order take

483
00:17:02,639 --> 00:17:05,359
into account the new value uh stored by

484
00:17:05,359 --> 00:17:08,000
processor b re-execute all the

485
00:17:08,000 --> 00:17:09,359
instructions that it actually flushed

486
00:17:09,359 --> 00:17:11,839
before and commit again everything

487
00:17:11,839 --> 00:17:14,879
following the memory model

488
00:17:16,720 --> 00:17:17,520
so

489
00:17:17,520 --> 00:17:19,039
here the architectural environment of

490
00:17:19,039 --> 00:17:20,880
this type of machine clear is out of

491
00:17:20,880 --> 00:17:23,280
order execution always complies with the

492
00:17:23,280 --> 00:17:25,520
total store order memory model this

493
00:17:25,520 --> 00:17:27,599
environment is violated because in the

494
00:17:27,599 --> 00:17:30,000
case of a memory ordering

495
00:17:30,000 --> 00:17:32,960
machine clear where we allow an attacker

496
00:17:32,960 --> 00:17:35,440
to transiently like steal data

497
00:17:35,440 --> 00:17:38,640
by performing this type of operations

498
00:17:38,640 --> 00:17:41,039
and to exploit this we tried

499
00:17:41,039 --> 00:17:43,280
many times but it's not trivial trivial

500
00:17:43,280 --> 00:17:44,720
at all due to the strict

501
00:17:44,720 --> 00:17:47,039
synchronizations between processor b and

502
00:17:47,039 --> 00:17:49,280
processor a you need to make sure that

503
00:17:49,280 --> 00:17:51,280
you actually write or perform these

504
00:17:51,280 --> 00:17:53,039
stores that would just disrupt the

505
00:17:53,039 --> 00:17:54,799
memory model of processor a at a

506
00:17:54,799 --> 00:17:56,960
specific time and this is not easy at

507
00:17:56,960 --> 00:17:58,720
all

508
00:17:58,720 --> 00:18:00,720
now i'll hand over to enrique who will

509
00:18:00,720 --> 00:18:02,559
tell you about the floating point

510
00:18:02,559 --> 00:18:05,120
machine clear

511
00:18:05,440 --> 00:18:08,400
okay thank you annie

512
00:18:10,000 --> 00:18:11,200
yes so

513
00:18:11,200 --> 00:18:13,440
the floating point machine clear

514
00:18:13,440 --> 00:18:15,120
is based on a very strange

515
00:18:15,120 --> 00:18:17,440
representation of floating point numbers

516
00:18:17,440 --> 00:18:20,080
it is called the subnormal

517
00:18:20,080 --> 00:18:21,440
that are number

518
00:18:21,440 --> 00:18:24,080
uh below this 2 to the power of minus

519
00:18:24,080 --> 00:18:25,600
1022

520
00:18:25,600 --> 00:18:27,520
but to keep it simple as abnormal number

521
00:18:27,520 --> 00:18:29,440
is a very small

522
00:18:29,440 --> 00:18:31,760
floating point number

523
00:18:31,760 --> 00:18:33,760
so as usual let's make an example to

524
00:18:33,760 --> 00:18:35,679
clarify the concept where this machine

525
00:18:35,679 --> 00:18:37,280
creator is coming from

526
00:18:37,280 --> 00:18:39,039
very common

527
00:18:39,039 --> 00:18:40,559
piece of code we have a floating point

528
00:18:40,559 --> 00:18:42,320
division followed by a floating point

529
00:18:42,320 --> 00:18:44,880
addition for example

530
00:18:44,880 --> 00:18:46,160
and

531
00:18:46,160 --> 00:18:47,600
basically

532
00:18:47,600 --> 00:18:49,679
the floating point unit is not capable

533
00:18:49,679 --> 00:18:53,520
to handle such strange number

534
00:18:53,600 --> 00:18:56,000
the hardware must be faster so you can

535
00:18:56,000 --> 00:18:56,960
only

536
00:18:56,960 --> 00:18:59,360
manage standard floating point numbers

537
00:18:59,360 --> 00:19:02,000
so the other is specialized for

538
00:19:02,000 --> 00:19:03,679
normal floating point numbers

539
00:19:03,679 --> 00:19:07,200
and whenever we have a sub normal number

540
00:19:07,200 --> 00:19:09,600
as a floating point operand

541
00:19:09,600 --> 00:19:11,679
the processor is not capable to manage

542
00:19:11,679 --> 00:19:14,640
such number and it will relies on on

543
00:19:14,640 --> 00:19:17,679
software to compute the correct result

544
00:19:17,679 --> 00:19:20,240
so again let's look at the example we

545
00:19:20,240 --> 00:19:22,720
perform a floating point division

546
00:19:22,720 --> 00:19:25,840
and uh let's say that the result

547
00:19:25,840 --> 00:19:27,840
or sorry one of the operands is a

548
00:19:27,840 --> 00:19:29,600
subnormal number

549
00:19:29,600 --> 00:19:31,120
what happened is that the floating point

550
00:19:31,120 --> 00:19:32,240
unit

551
00:19:32,240 --> 00:19:34,240
gave to the processor to the subsequent

552
00:19:34,240 --> 00:19:36,720
instruction a wrong result because again

553
00:19:36,720 --> 00:19:38,720
the photon community floating community

554
00:19:38,720 --> 00:19:41,120
is not capable of handling such numbers

555
00:19:41,120 --> 00:19:42,720
so what happened is basically the

556
00:19:42,720 --> 00:19:44,000
processor

557
00:19:44,000 --> 00:19:46,080
uh executed speculatively some

558
00:19:46,080 --> 00:19:48,080
instruction using wrong floating point

559
00:19:48,080 --> 00:19:50,480
numbers from the previous

560
00:19:50,480 --> 00:19:51,760
computation

561
00:19:51,760 --> 00:19:54,000
so the processor is forced to

562
00:19:54,000 --> 00:19:55,440
flash to

563
00:19:55,440 --> 00:19:56,960
remove all the subsequent instructions

564
00:19:56,960 --> 00:19:59,280
that were based on a wrong floating

565
00:19:59,280 --> 00:20:00,720
point result

566
00:20:00,720 --> 00:20:03,919
and now it needs to come back recompute

567
00:20:03,919 --> 00:20:05,440
the results in software using a

568
00:20:05,440 --> 00:20:07,919
microcode assist and then giving the

569
00:20:07,919 --> 00:20:10,320
result back so as you can see floating

570
00:20:10,320 --> 00:20:12,559
point machine clips is quite demanding

571
00:20:12,559 --> 00:20:14,080
because you need to recompute the

572
00:20:14,080 --> 00:20:16,559
mathematical operation over

573
00:20:16,559 --> 00:20:18,559
again because the arbor is not really

574
00:20:18,559 --> 00:20:22,000
capable of handling such numbers

575
00:20:22,000 --> 00:20:23,360
here the environment is that the

576
00:20:23,360 --> 00:20:25,200
floating point unit always operate on

577
00:20:25,200 --> 00:20:26,480
these uh

578
00:20:26,480 --> 00:20:28,400
floating point numbers that are

579
00:20:28,400 --> 00:20:30,080
the dollar is capable of

580
00:20:30,080 --> 00:20:32,880
and whenever there is a normal we pay

581
00:20:32,880 --> 00:20:35,120
the price of you know waiting up more

582
00:20:35,120 --> 00:20:37,440
for the correct result

583
00:20:37,440 --> 00:20:39,200
to violate this is super simple you just

584
00:20:39,200 --> 00:20:41,440
need to make a mathematical operation

585
00:20:41,440 --> 00:20:42,559
using this

586
00:20:42,559 --> 00:20:44,720
sub normal number these strange floating

587
00:20:44,720 --> 00:20:46,640
point numbers

588
00:20:46,640 --> 00:20:48,640
and it's great implication is that

589
00:20:48,640 --> 00:20:51,520
for a few instructions later they're

590
00:20:51,520 --> 00:20:54,720
using a wrongly computed result

591
00:20:54,720 --> 00:20:57,440
and for exploitation here uh things get

592
00:20:57,440 --> 00:20:59,120
very interesting because we managed to

593
00:20:59,120 --> 00:21:02,000
build a end-to-end exploit running on

594
00:21:02,000 --> 00:21:03,600
firefox

595
00:21:03,600 --> 00:21:06,240
and this is our attack setup

596
00:21:06,240 --> 00:21:08,080
uh on the left you can see the victim

597
00:21:08,080 --> 00:21:10,159
page it has a different origin to the

598
00:21:10,159 --> 00:21:12,000
iframe on the right

599
00:21:12,000 --> 00:21:13,679
imagine the right part as an

600
00:21:13,679 --> 00:21:17,200
advertisement in a web page

601
00:21:17,200 --> 00:21:19,520
and our goal is to link the the content

602
00:21:19,520 --> 00:21:21,280
of the victim page from a different

603
00:21:21,280 --> 00:21:22,960
iframe

604
00:21:22,960 --> 00:21:24,559
so let's go back for a moment to the

605
00:21:24,559 --> 00:21:26,960
14-point numbers we release a tool that

606
00:21:26,960 --> 00:21:29,200
you can find on github but basically you

607
00:21:29,200 --> 00:21:30,559
provide the

608
00:21:30,559 --> 00:21:32,960
wrongly computer result of the

609
00:21:32,960 --> 00:21:34,960
floating point operation and this tool

610
00:21:34,960 --> 00:21:37,280
will give you two operands

611
00:21:37,280 --> 00:21:39,200
that will translate generate the number

612
00:21:39,200 --> 00:21:40,640
that you want so for example if you want

613
00:21:40,640 --> 00:21:44,000
that beef as a wrongly completed result

614
00:21:44,000 --> 00:21:46,000
this tool will give you the x and y

615
00:21:46,000 --> 00:21:48,080
operands of the division that will

616
00:21:48,080 --> 00:21:50,080
transiently generate

617
00:21:50,080 --> 00:21:51,760
that specific

618
00:21:51,760 --> 00:21:53,840
result and here maybe you can see when

619
00:21:53,840 --> 00:21:55,840
you divide for example these two numbers

620
00:21:55,840 --> 00:22:01,200
this minus the 69 divided by 4.94

621
00:22:01,200 --> 00:22:02,880
architecturally

622
00:22:02,880 --> 00:22:05,760
will be minus infinity

623
00:22:05,760 --> 00:22:07,200
but again since the processor cannot

624
00:22:07,200 --> 00:22:08,799
handle these results

625
00:22:08,799 --> 00:22:10,480
speculatively the first result the wrong

626
00:22:10,480 --> 00:22:13,039
one will be this strange number here on

627
00:22:13,039 --> 00:22:15,360
the bottom with the that beef value that

628
00:22:15,360 --> 00:22:17,440
we wanted to to have

629
00:22:17,440 --> 00:22:19,840
but now you can also see on the top we

630
00:22:19,840 --> 00:22:21,600
have this fffb

631
00:22:21,600 --> 00:22:23,120
why so

632
00:22:23,120 --> 00:22:25,440
because our victim is the

633
00:22:25,440 --> 00:22:28,400
javascript engine of firefox and there

634
00:22:28,400 --> 00:22:30,400
every object variable is representing

635
00:22:30,400 --> 00:22:32,960
using a floating point number

636
00:22:32,960 --> 00:22:35,600
strange yes but actually they did a very

637
00:22:35,600 --> 00:22:36,720
nice trick

638
00:22:36,720 --> 00:22:39,360
they use the upper bits that are used

639
00:22:39,360 --> 00:22:41,120
for none numbers

640
00:22:41,120 --> 00:22:42,480
and the upper bits

641
00:22:42,480 --> 00:22:44,320
is simply the type of the variable so

642
00:22:44,320 --> 00:22:46,480
for example ffb

643
00:22:46,480 --> 00:22:48,080
it means that the variable will be of

644
00:22:48,080 --> 00:22:49,520
type string

645
00:22:49,520 --> 00:22:53,039
while the bottom bits the that b 0 0 0

646
00:22:53,039 --> 00:22:56,880
is the pointer to the string okay

647
00:22:56,880 --> 00:22:58,799
so if in javascript we perform the

648
00:22:58,799 --> 00:23:00,720
division between these two numbers

649
00:23:00,720 --> 00:23:02,720
and then we ask the javascript engine

650
00:23:02,720 --> 00:23:03,760
look

651
00:23:03,760 --> 00:23:05,600
what is the type of this 14 point

652
00:23:05,600 --> 00:23:06,559
division

653
00:23:06,559 --> 00:23:10,159
of course you will tell me is the

654
00:23:10,159 --> 00:23:11,760
is a floating point numbers right you

655
00:23:11,760 --> 00:23:12,960
should not take

656
00:23:12,960 --> 00:23:14,799
the red branch indeed architecturally

657
00:23:14,799 --> 00:23:16,720
will take the the blue range

658
00:23:16,720 --> 00:23:18,559
however for a short amount of time with

659
00:23:18,559 --> 00:23:20,880
the wrongly computed result

660
00:23:20,880 --> 00:23:22,400
the javascript engine will believe that

661
00:23:22,400 --> 00:23:25,360
defaulting by division will be a string

662
00:23:25,360 --> 00:23:27,200
and we control the string pointer

663
00:23:27,200 --> 00:23:29,360
because again the red value

664
00:23:29,360 --> 00:23:31,200
was chosen by us

665
00:23:31,200 --> 00:23:33,039
and now it's basically game over we can

666
00:23:33,039 --> 00:23:34,960
simply

667
00:23:34,960 --> 00:23:36,640
ask for example the length parameter of

668
00:23:36,640 --> 00:23:39,440
the string and we are literally reading

669
00:23:39,440 --> 00:23:41,919
the others that we want in memory

670
00:23:41,919 --> 00:23:44,159
and then with a simple flasher reload

671
00:23:44,159 --> 00:23:46,080
copper channel we can

672
00:23:46,080 --> 00:23:48,159
observe the leaked memory

673
00:23:48,159 --> 00:23:49,600
entirely so

674
00:23:49,600 --> 00:23:51,360
again to simplify here

675
00:23:51,360 --> 00:23:53,440
from a single 14-point division we can

676
00:23:53,440 --> 00:23:55,520
mount a

677
00:23:55,520 --> 00:23:57,840
load primitive we can read any memory

678
00:23:57,840 --> 00:23:59,360
address in memory

679
00:23:59,360 --> 00:24:01,039
just because the arrow is not capable of

680
00:24:01,039 --> 00:24:02,840
rendering such

681
00:24:02,840 --> 00:24:04,480
numbers

682
00:24:04,480 --> 00:24:06,080
the last step that is also quite

683
00:24:06,080 --> 00:24:08,159
powerful to show the attack that when we

684
00:24:08,159 --> 00:24:10,159
perform this load we cannot crash the

685
00:24:10,159 --> 00:24:12,159
program because all this instruction is

686
00:24:12,159 --> 00:24:13,520
speculative okay

687
00:24:13,520 --> 00:24:16,320
the processor will discard everything

688
00:24:16,320 --> 00:24:18,080
so this is super helpful for us to break

689
00:24:18,080 --> 00:24:20,640
slr we just i don't know allocate one

690
00:24:20,640 --> 00:24:23,760
gigabyte of known text and then we start

691
00:24:23,760 --> 00:24:25,840
reading every memory address of the

692
00:24:25,840 --> 00:24:28,400
processor in a course green way

693
00:24:28,400 --> 00:24:30,080
we find our

694
00:24:30,080 --> 00:24:31,919
spray memory and then we do a small

695
00:24:31,919 --> 00:24:34,640
fine-grained search to find where the

696
00:24:34,640 --> 00:24:38,400
firefox process is located in memory

697
00:24:38,400 --> 00:24:41,600
now we have made a video not a live demo

698
00:24:41,600 --> 00:24:42,720
because

699
00:24:42,720 --> 00:24:44,159
it's safer but

700
00:24:44,159 --> 00:24:45,760
it should be still cool

701
00:24:45,760 --> 00:24:48,480
so again victim and uh iframe on the

702
00:24:48,480 --> 00:24:50,720
right here we are just starting spraying

703
00:24:50,720 --> 00:24:53,200
the memory again to break the slr to

704
00:24:53,200 --> 00:24:55,039
find where firefox

705
00:24:55,039 --> 00:24:57,919
is present and here please again

706
00:24:57,919 --> 00:24:59,200
we are just doing floating point

707
00:24:59,200 --> 00:25:02,080
division over and over we control the

708
00:25:02,080 --> 00:25:03,520
parameters

709
00:25:03,520 --> 00:25:05,279
but still we can leak arbitrary memory

710
00:25:05,279 --> 00:25:06,640
others thanks

711
00:25:06,640 --> 00:25:08,960
to this unboxing presentation we can

712
00:25:08,960 --> 00:25:11,279
read arbitrary memory addresses

713
00:25:11,279 --> 00:25:13,120
so you can see here is just breaking slr

714
00:25:13,120 --> 00:25:15,840
it takes 20 30 seconds

715
00:25:15,840 --> 00:25:18,320
exactly and now we are already leaking

716
00:25:18,320 --> 00:25:21,039
the firefox process memory we're not

717
00:25:21,039 --> 00:25:22,720
printing anything but we're just making

718
00:25:22,720 --> 00:25:23,840
meaningful

719
00:25:23,840 --> 00:25:25,760
text to not clobber the

720
00:25:25,760 --> 00:25:26,640
output

721
00:25:26,640 --> 00:25:29,279
and as you can see in few seconds

722
00:25:29,279 --> 00:25:31,760
exactly now we are leaking the secret

723
00:25:31,760 --> 00:25:33,360
victim page

724
00:25:33,360 --> 00:25:36,240
from a different origin only using 14

725
00:25:36,240 --> 00:25:37,600
point division

726
00:25:37,600 --> 00:25:39,679
to think about is pretty

727
00:25:39,679 --> 00:25:43,290
crazy in our opinion

728
00:25:43,290 --> 00:25:49,200
[Applause]

729
00:25:49,200 --> 00:25:51,360
and

730
00:25:51,760 --> 00:25:53,679
okay the damn also broke the

731
00:25:53,679 --> 00:25:56,679
mistakes

732
00:25:57,679 --> 00:25:59,200
oh great

733
00:25:59,200 --> 00:26:00,799
and also the cool part is we are looking

734
00:26:00,799 --> 00:26:03,120
also other javascript part in firefox

735
00:26:03,120 --> 00:26:04,720
who knows we are looking all the process

736
00:26:04,720 --> 00:26:05,919
memory so

737
00:26:05,919 --> 00:26:08,480
pretty nice

738
00:26:08,640 --> 00:26:10,000
to conclude on floating point the

739
00:26:10,000 --> 00:26:11,840
leakage rate that we measure was 13

740
00:26:11,840 --> 00:26:14,400
kilobytes per second not bad

741
00:26:14,400 --> 00:26:16,320
and we can mitigate these in different

742
00:26:16,320 --> 00:26:18,640
way just by disabling these floating

743
00:26:18,640 --> 00:26:20,559
point numbers

744
00:26:20,559 --> 00:26:22,559
or we also implemented a compiler pass

745
00:26:22,559 --> 00:26:23,520
to

746
00:26:23,520 --> 00:26:25,520
serialize the pipeline of the processor

747
00:26:25,520 --> 00:26:28,159
when we detect these these gadgets

748
00:26:28,159 --> 00:26:30,880
or as firefox did made a

749
00:26:30,880 --> 00:26:32,240
precise

750
00:26:32,240 --> 00:26:34,159
defense whenever now you're doing a

751
00:26:34,159 --> 00:26:36,240
floating body division in firefox

752
00:26:36,240 --> 00:26:37,840
firefox is checking that the result is

753
00:26:37,840 --> 00:26:39,679
not of type none

754
00:26:39,679 --> 00:26:41,520
or simply chrome was already safe

755
00:26:41,520 --> 00:26:45,360
because they were using site isolation

756
00:26:45,440 --> 00:26:46,960
last type of machine clear for today

757
00:26:46,960 --> 00:26:50,080
that is uh memory is obligation

758
00:26:50,080 --> 00:26:50,880
so

759
00:26:50,880 --> 00:26:52,640
we know the instruction is following a

760
00:26:52,640 --> 00:26:55,200
story instruction and the destination

761
00:26:55,200 --> 00:26:57,039
are not yet known

762
00:26:57,039 --> 00:26:59,120
there is a special predictor in the cpu

763
00:26:59,120 --> 00:27:01,120
that tries to predict if you can perform

764
00:27:01,120 --> 00:27:04,159
this operation of the folder or not

765
00:27:04,159 --> 00:27:06,720
oh well if the the other system you need

766
00:27:06,720 --> 00:27:08,400
to execute them in order

767
00:27:08,400 --> 00:27:10,240
otherwise out of order

768
00:27:10,240 --> 00:27:13,279
again let's make an example to clarify

769
00:27:13,279 --> 00:27:15,440
again very simple uh snippet of code a

770
00:27:15,440 --> 00:27:18,640
store followed by a load operation

771
00:27:18,640 --> 00:27:20,320
and let's say that the store operation

772
00:27:20,320 --> 00:27:22,159
the target address of the store is not

773
00:27:22,159 --> 00:27:23,279
yet known

774
00:27:23,279 --> 00:27:25,440
so the processor will not wait and would

775
00:27:25,440 --> 00:27:27,520
like to execute the subsequent load out

776
00:27:27,520 --> 00:27:28,640
of order

777
00:27:28,640 --> 00:27:31,200
and for that is asking the cpu

778
00:27:31,200 --> 00:27:33,120
wait these store and load addresses are

779
00:27:33,120 --> 00:27:34,720
the same because if they are different i

780
00:27:34,720 --> 00:27:38,240
can execute them out of order

781
00:27:38,240 --> 00:27:40,240
let's say that predictor will say no no

782
00:27:40,240 --> 00:27:42,720
come on you can go out of order they are

783
00:27:42,720 --> 00:27:46,880
different addresses feel free to do that

784
00:27:46,880 --> 00:27:49,200
and and the processor will execute the

785
00:27:49,200 --> 00:27:51,039
load before the store is actually

786
00:27:51,039 --> 00:27:52,399
executed

787
00:27:52,399 --> 00:27:54,240
but let's say that this prediction was

788
00:27:54,240 --> 00:27:56,080
was wrong so the store and the others

789
00:27:56,080 --> 00:27:57,919
were actually the same

790
00:27:57,919 --> 00:28:00,000
the processor must flush the pipeline

791
00:28:00,000 --> 00:28:02,640
and re-execute again

792
00:28:02,640 --> 00:28:06,480
the store and the load in program order

793
00:28:06,480 --> 00:28:08,720
here the environment is that the

794
00:28:08,720 --> 00:28:11,120
predictor never makes a mistake

795
00:28:11,120 --> 00:28:13,120
and obviously it can

796
00:28:13,120 --> 00:28:15,279
and to relate that you need to massage

797
00:28:15,279 --> 00:28:17,679
the predictor to make this misprediction

798
00:28:17,679 --> 00:28:18,960
happening

799
00:28:18,960 --> 00:28:21,520
and here implication is simply that the

800
00:28:21,520 --> 00:28:23,919
speculative executed load

801
00:28:23,919 --> 00:28:26,080
took some steel data so the attacker can

802
00:28:26,080 --> 00:28:27,679
execute some still data from previous

803
00:28:27,679 --> 00:28:29,120
execution

804
00:28:29,120 --> 00:28:31,840
and this was already a known attack was

805
00:28:31,840 --> 00:28:33,840
named spectre before

806
00:28:33,840 --> 00:28:35,120
but here you want to show it as a

807
00:28:35,120 --> 00:28:36,559
machine clear because

808
00:28:36,559 --> 00:28:39,200
it's a data misspeculation rather than a

809
00:28:39,200 --> 00:28:41,279
control flow speculation but annie will

810
00:28:41,279 --> 00:28:44,080
talk about that later

811
00:28:44,080 --> 00:28:46,159
uh four already a lot i know but in our

812
00:28:46,159 --> 00:28:48,050
paper there are even more if you want uh

813
00:28:48,050 --> 00:28:49,360
[Music]

814
00:28:49,360 --> 00:28:50,799
a bit more pain

815
00:28:50,799 --> 00:28:53,120
uh and you can you can find them there

816
00:28:53,120 --> 00:28:55,039
are some interesting ones like uh

817
00:28:55,039 --> 00:28:57,679
exception or some strange musketeer

818
00:28:57,679 --> 00:28:59,840
instruction of intel

819
00:28:59,840 --> 00:29:01,520
feel free to read our paper for more

820
00:29:01,520 --> 00:29:03,679
information

821
00:29:03,679 --> 00:29:07,520
and now back for some results

822
00:29:08,320 --> 00:29:09,760
all right so

823
00:29:09,760 --> 00:29:11,200
now that we've seen four types of

824
00:29:11,200 --> 00:29:12,720
machine clear let's zoom out a bit and

825
00:29:12,720 --> 00:29:14,880
look at the big picture so we've seen

826
00:29:14,880 --> 00:29:17,679
software frame code that is affecting

827
00:29:17,679 --> 00:29:20,399
not only jit engines but is affecting

828
00:29:20,399 --> 00:29:22,640
browsers operating systems hypervisors

829
00:29:22,640 --> 00:29:25,600
or any software writing code and

830
00:29:25,600 --> 00:29:27,600
executing it without first

831
00:29:27,600 --> 00:29:29,520
serializing the execution

832
00:29:29,520 --> 00:29:31,520
then we saw memory ordering machine

833
00:29:31,520 --> 00:29:34,559
clear where one processor violates the

834
00:29:34,559 --> 00:29:36,320
memory ordering model of the other

835
00:29:36,320 --> 00:29:37,840
processor allowing

836
00:29:37,840 --> 00:29:39,200
still

837
00:29:39,200 --> 00:29:41,200
still later to be leaked

838
00:29:41,200 --> 00:29:43,039
and then floating point

839
00:29:43,039 --> 00:29:44,320
where we

840
00:29:44,320 --> 00:29:47,520
have the control of injecting a specific

841
00:29:47,520 --> 00:29:50,159
wrong result in subsequent operations

842
00:29:50,159 --> 00:29:52,640
and this can let us an attacker to in

843
00:29:52,640 --> 00:29:55,360
this case leak arbitrary memory and then

844
00:29:55,360 --> 00:29:58,799
finally members ambiguation where we can

845
00:29:58,799 --> 00:30:01,679
can train a different predictor to

846
00:30:01,679 --> 00:30:03,120
mispredict

847
00:30:03,120 --> 00:30:05,840
in disambiguating two addresses allowing

848
00:30:05,840 --> 00:30:10,320
an attacker to again leak stale memory

849
00:30:10,320 --> 00:30:11,120
we

850
00:30:11,120 --> 00:30:13,760
try to evaluate these types of machine

851
00:30:13,760 --> 00:30:16,240
clear compared to all previous

852
00:30:16,240 --> 00:30:17,600
known

853
00:30:17,600 --> 00:30:20,480
ways of creating transit execution paths

854
00:30:20,480 --> 00:30:23,440
and here are the results

855
00:30:23,440 --> 00:30:25,600
on the x-axis we have the different ways

856
00:30:25,600 --> 00:30:27,679
of creating this uh

857
00:30:27,679 --> 00:30:29,600
transit execution path

858
00:30:29,600 --> 00:30:31,679
which means executing instructions and

859
00:30:31,679 --> 00:30:33,600
then flushing them and then re-executing

860
00:30:33,600 --> 00:30:35,440
the architectural path these are all

861
00:30:35,440 --> 00:30:37,279
different ways of creating this this

862
00:30:37,279 --> 00:30:39,520
behavior on the x-axis we have all

863
00:30:39,520 --> 00:30:41,279
different behaviors uh different

864
00:30:41,279 --> 00:30:43,440
mechanisms sorry and on the y-axis we

865
00:30:43,440 --> 00:30:46,159
have two plots that are representing two

866
00:30:46,159 --> 00:30:48,640
properties the top plot is the number of

867
00:30:48,640 --> 00:30:50,799
transient loads that can fit in one

868
00:30:50,799 --> 00:30:53,440
single window one single transient

869
00:30:53,440 --> 00:30:56,320
window created by the corresponding uh

870
00:30:56,320 --> 00:30:57,760
transit execution

871
00:30:57,760 --> 00:31:01,440
mechanism and the bottom plot shows

872
00:31:01,440 --> 00:31:03,200
what is the leakage rate of such a

873
00:31:03,200 --> 00:31:06,320
primitive if i create for example a

874
00:31:06,320 --> 00:31:09,039
transient window with a fault what is

875
00:31:09,039 --> 00:31:10,559
the leakage rate that i can get out of

876
00:31:10,559 --> 00:31:12,080
it

877
00:31:12,080 --> 00:31:15,360
so here the bars of fluorescent reload

878
00:31:15,360 --> 00:31:17,600
these are the architectural upper limit

879
00:31:17,600 --> 00:31:19,360
of a leakage rate this is a

880
00:31:19,360 --> 00:31:21,760
architectural leakage so nothing can get

881
00:31:21,760 --> 00:31:22,960
beyond this

882
00:31:22,960 --> 00:31:25,519
because this is a committed leakage so

883
00:31:25,519 --> 00:31:26,799
these instructions will be committed at

884
00:31:26,799 --> 00:31:28,240
the end rather than all the other

885
00:31:28,240 --> 00:31:30,159
mechanisms will never be committed so

886
00:31:30,159 --> 00:31:32,559
they must have a lower lower leakage

887
00:31:32,559 --> 00:31:36,480
rate then we have intel tsx the bhd and

888
00:31:36,480 --> 00:31:38,960
folds which are the three main

889
00:31:38,960 --> 00:31:40,799
mechanisms that all previous trans

890
00:31:40,799 --> 00:31:42,399
execution attacks were

891
00:31:42,399 --> 00:31:44,960
relying on to create this behavior of

892
00:31:44,960 --> 00:31:47,360
executing instructions and reverting

893
00:31:47,360 --> 00:31:49,919
these were the all the only the three

894
00:31:49,919 --> 00:31:52,960
known ways of creating such behavior and

895
00:31:52,960 --> 00:31:54,720
intel tsx is only available only in

896
00:31:54,720 --> 00:31:57,279
intel and again it's not available

897
00:31:57,279 --> 00:31:59,120
anymore due to all the texts that

898
00:31:59,120 --> 00:32:01,600
actually abuse this mechanism

899
00:32:01,600 --> 00:32:03,519
so an attacker would have been left with

900
00:32:03,519 --> 00:32:04,880
only two ways of creating such a

901
00:32:04,880 --> 00:32:07,200
behavior phd so mispredicting a branch

902
00:32:07,200 --> 00:32:09,279
like we saw in the beginning of this

903
00:32:09,279 --> 00:32:11,279
presentation and then a fault

904
00:32:11,279 --> 00:32:13,440
which would have crashed potentially

905
00:32:13,440 --> 00:32:15,200
program but in our work we are

906
00:32:15,200 --> 00:32:16,720
presenting five different ways of

907
00:32:16,720 --> 00:32:18,640
creating such a behavior and they are

908
00:32:18,640 --> 00:32:22,559
also available on amd processors

909
00:32:22,559 --> 00:32:24,640
one interesting result is how many

910
00:32:24,640 --> 00:32:26,799
transient loads can fit in one single

911
00:32:26,799 --> 00:32:28,480
window created by a self-defense called

912
00:32:28,480 --> 00:32:30,760
machine clear here we measured more than

913
00:32:30,760 --> 00:32:33,919
160 transient loads in a single window

914
00:32:33,919 --> 00:32:35,519
these are loads that will never be

915
00:32:35,519 --> 00:32:38,159
committed will not will never have an

916
00:32:38,159 --> 00:32:40,240
architectural

917
00:32:40,240 --> 00:32:41,679
result at the end that a program can

918
00:32:41,679 --> 00:32:42,399
observe

919
00:32:42,399 --> 00:32:44,559
these can only be observed only on the

920
00:32:44,559 --> 00:32:47,519
architectural level through uh some some

921
00:32:47,519 --> 00:32:49,679
sort of cover channel as we saw

922
00:32:49,679 --> 00:32:52,240
so in a 160 loads

923
00:32:52,240 --> 00:32:53,919
many things can fit and many things can

924
00:32:53,919 --> 00:32:55,440
be executed in the background without

925
00:32:55,440 --> 00:32:58,159
even noticing

926
00:32:58,159 --> 00:32:59,600
another interesting result is the

927
00:32:59,600 --> 00:33:01,039
leakage rate of floating point machine

928
00:33:01,039 --> 00:33:02,240
clear

929
00:33:02,240 --> 00:33:04,240
which can reach more than four megabits

930
00:33:04,240 --> 00:33:06,320
per second and this is thanks to its

931
00:33:06,320 --> 00:33:08,559
determinism once you have an x and y you

932
00:33:08,559 --> 00:33:10,159
are deterministically creating a

933
00:33:10,159 --> 00:33:11,600
transient window

934
00:33:11,600 --> 00:33:14,080
that is super controlled under uh under

935
00:33:14,080 --> 00:33:15,279
all the the information that the

936
00:33:15,279 --> 00:33:17,519
attacker can decide there is no branch

937
00:33:17,519 --> 00:33:19,360
to uh there is no branch predictor to

938
00:33:19,360 --> 00:33:22,960
train or mistrain uh here x and y you

939
00:33:22,960 --> 00:33:24,399
have a transient window that you can

940
00:33:24,399 --> 00:33:28,080
create uh easily

941
00:33:28,799 --> 00:33:31,279
we also try to classify all these ways

942
00:33:31,279 --> 00:33:33,039
of creating trans execution attack to

943
00:33:33,039 --> 00:33:35,120
make it a bit more clear

944
00:33:35,120 --> 00:33:36,000
when

945
00:33:36,000 --> 00:33:37,919
when we are looking at all these uh

946
00:33:37,919 --> 00:33:40,240
different uh root causes so first we

947
00:33:40,240 --> 00:33:42,240
start with control forum's prediction

948
00:33:42,240 --> 00:33:44,080
and data prediction which are the two

949
00:33:44,080 --> 00:33:45,679
subclasses the two main subclasses under

950
00:33:45,679 --> 00:33:47,600
bad speculation and which are

951
00:33:47,600 --> 00:33:50,640
representing uh a simple idea are we

952
00:33:50,640 --> 00:33:51,840
speculating

953
00:33:51,840 --> 00:33:54,480
on code or are we speculating on data

954
00:33:54,480 --> 00:33:56,799
then we start reasoning on how we can

955
00:33:56,799 --> 00:33:59,519
split speculate on code or data it makes

956
00:33:59,519 --> 00:34:01,360
it easier this way to look at these

957
00:34:01,360 --> 00:34:03,200
different root causes

958
00:34:03,200 --> 00:34:05,919
each subclass has its own predictor

959
00:34:05,919 --> 00:34:07,360
surplus which represents all the

960
00:34:07,360 --> 00:34:09,679
predictors that are speculating on code

961
00:34:09,679 --> 00:34:11,440
or data

962
00:34:11,440 --> 00:34:12,960
while contraformers predictions are

963
00:34:12,960 --> 00:34:15,040
failed attempts to predict the next

964
00:34:15,040 --> 00:34:16,800
instruction to execute data

965
00:34:16,800 --> 00:34:18,560
mispredictions are failed attempts to

966
00:34:18,560 --> 00:34:20,960
operate on data that has not validated

967
00:34:20,960 --> 00:34:24,480
has not been validated yet

968
00:34:25,040 --> 00:34:27,040
then we have the exception subclass that

969
00:34:27,040 --> 00:34:28,800
is that belongs to datum's prediction

970
00:34:28,800 --> 00:34:30,399
where we have all the architectural

971
00:34:30,399 --> 00:34:31,599
exceptions that have been widely

972
00:34:31,599 --> 00:34:33,520
explored in previous attacks

973
00:34:33,520 --> 00:34:36,000
then we introduced in this work a

974
00:34:36,000 --> 00:34:37,599
subclass of data inspection called

975
00:34:37,599 --> 00:34:39,599
likely in variance validations where we

976
00:34:39,599 --> 00:34:41,119
have all the architectural environments

977
00:34:41,119 --> 00:34:43,679
that usually hold but occasionally fail

978
00:34:43,679 --> 00:34:45,359
like for example in the case of floating

979
00:34:45,359 --> 00:34:47,199
point if we provide two floating point

980
00:34:47,199 --> 00:34:49,599
numbers that are normal numbers nothing

981
00:34:49,599 --> 00:34:51,599
will happen and this is the assumption

982
00:34:51,599 --> 00:34:53,280
this is the invariant that a floating

983
00:34:53,280 --> 00:34:56,159
point uh unit uh works with but if i

984
00:34:56,159 --> 00:34:57,920
provide a floating point number that is

985
00:34:57,920 --> 00:35:00,079
at the norm or subnormal number things

986
00:35:00,079 --> 00:35:02,640
break and then the invite the invariant

987
00:35:02,640 --> 00:35:05,040
is violated

988
00:35:05,040 --> 00:35:06,800
and finally we have another subclass of

989
00:35:06,800 --> 00:35:08,160
later inspiration which represents the

990
00:35:08,160 --> 00:35:10,079
hardware interrupts that were yet

991
00:35:10,079 --> 00:35:11,599
another way of creating transit

992
00:35:11,599 --> 00:35:14,079
execution path that we observed uh

993
00:35:14,079 --> 00:35:17,839
during our reverse engineering

994
00:35:17,839 --> 00:35:20,560
um we disclosed uh floating point value

995
00:35:20,560 --> 00:35:21,920
injection and

996
00:35:21,920 --> 00:35:23,520
speculative code survey paths to all

997
00:35:23,520 --> 00:35:25,520
major cpu browser operating system

998
00:35:25,520 --> 00:35:29,440
hypervisor vendors earlier this year and

999
00:35:29,440 --> 00:35:33,200
we uh we confirmed that uh

1000
00:35:33,200 --> 00:35:34,720
speculative code server pass is

1001
00:35:34,720 --> 00:35:38,480
affecting all intel cpus all amd cpus

1002
00:35:38,480 --> 00:35:41,599
but is not affecting arm cpus and in the

1003
00:35:41,599 --> 00:35:43,040
case of arm cpus they are not affected

1004
00:35:43,040 --> 00:35:45,119
because of the explicit

1005
00:35:45,119 --> 00:35:47,760
coherence between code and data is

1006
00:35:47,760 --> 00:35:50,240
explicitly left to the programmer

1007
00:35:50,240 --> 00:35:52,560
you have to explicitly make sure that

1008
00:35:52,560 --> 00:35:54,480
these two views contain the same

1009
00:35:54,480 --> 00:35:56,079
information

1010
00:35:56,079 --> 00:35:57,440
when it comes to floating point value

1011
00:35:57,440 --> 00:36:00,240
injection again all amd all intel cpus

1012
00:36:00,240 --> 00:36:02,480
are affected all mdcpus are affected and

1013
00:36:02,480 --> 00:36:04,960
again most of the arm floating point

1014
00:36:04,960 --> 00:36:06,720
implementations in our hardware we were

1015
00:36:06,720 --> 00:36:08,400
informed later after our disclosure that

1016
00:36:08,400 --> 00:36:10,320
you are also affected by floating point

1017
00:36:10,320 --> 00:36:12,880
value injection

1018
00:36:12,880 --> 00:36:14,960
mozilla confirmed the vulnerability and

1019
00:36:14,960 --> 00:36:16,960
the plutonium negation uh based on

1020
00:36:16,960 --> 00:36:18,880
conditionally masking the malicious numb

1021
00:36:18,880 --> 00:36:21,280
boxed transient result that we

1022
00:36:21,280 --> 00:36:23,760
forward to the cpu and

1023
00:36:23,760 --> 00:36:25,920
the mitigation the current measure is uh

1024
00:36:25,920 --> 00:36:28,240
have been deployed from firefox 87 and

1025
00:36:28,240 --> 00:36:30,480
on

1026
00:36:30,480 --> 00:36:33,040
lastly the zen hypervisor also mitigated

1027
00:36:33,040 --> 00:36:35,440
a csb and released a security advisory

1028
00:36:35,440 --> 00:36:37,839
where they actually suggest to

1029
00:36:37,839 --> 00:36:39,359
issue a serializing instruction after

1030
00:36:39,359 --> 00:36:41,440
you write the new code to make sure that

1031
00:36:41,440 --> 00:36:45,520
code and data views are coherent

1032
00:36:45,520 --> 00:36:46,720
to conclude

1033
00:36:46,720 --> 00:36:49,119
bad speculation is not caused only by

1034
00:36:49,119 --> 00:36:51,839
classic branch mispredictions as we

1035
00:36:51,839 --> 00:36:54,560
we knew up until to this work but also

1036
00:36:54,560 --> 00:36:56,800
by market actual architectural

1037
00:36:56,800 --> 00:36:58,640
environment violations like all the

1038
00:36:58,640 --> 00:37:00,079
different types of machine clear that

1039
00:37:00,079 --> 00:37:02,240
were presented today

1040
00:37:02,240 --> 00:37:04,000
these are architectural environments can

1041
00:37:04,000 --> 00:37:06,160
be exploited creating new security

1042
00:37:06,160 --> 00:37:08,560
threats like by injection and

1043
00:37:08,560 --> 00:37:10,480
speculative codes are bypass

1044
00:37:10,480 --> 00:37:12,960
and we think that defenses must focus on

1045
00:37:12,960 --> 00:37:15,520
the wider meaning of speculation it's

1046
00:37:15,520 --> 00:37:17,119
not only

1047
00:37:17,119 --> 00:37:19,040
speculating over a branch but the water

1048
00:37:19,040 --> 00:37:21,599
meaning of this as we

1049
00:37:21,599 --> 00:37:22,480
show

1050
00:37:22,480 --> 00:37:24,400
in this work

1051
00:37:24,400 --> 00:37:27,359
you can find the paper the code and the

1052
00:37:27,359 --> 00:37:29,200
reverse engineering

1053
00:37:29,200 --> 00:37:32,720
code and the exploit on our websites and

1054
00:37:32,720 --> 00:37:35,040
yeah you can ask us any questions or

1055
00:37:35,040 --> 00:37:36,800
twitter or hear during the

1056
00:37:36,800 --> 00:37:41,000
conference thanks for your attention

1057
00:37:46,100 --> 00:37:49,779
[Applause]

1058
00:37:50,079 --> 00:37:52,400
thank you enrico and any uh are there

1059
00:37:52,400 --> 00:37:54,000
any questions for them

1060
00:37:54,000 --> 00:37:56,560
how exactly did you like stumble on this

1061
00:37:56,560 --> 00:37:58,640
field of research like uh

1062
00:37:58,640 --> 00:38:00,880
how does like a paper like this start

1063
00:38:00,880 --> 00:38:03,040
what's the idea behind it it's very

1064
00:38:03,040 --> 00:38:04,880
simple by reading the intel manual and

1065
00:38:04,880 --> 00:38:07,920
finding something suspicious like

1066
00:38:07,920 --> 00:38:10,240
you read some specification you say um

1067
00:38:10,240 --> 00:38:12,160
there's like uh there is something

1068
00:38:12,160 --> 00:38:13,680
behind it

1069
00:38:13,680 --> 00:38:14,480
and

1070
00:38:14,480 --> 00:38:16,400
yeah mainly that yeah you need to read a

1071
00:38:16,400 --> 00:38:19,680
lot of documentation hoping to find uh

1072
00:38:19,680 --> 00:38:21,920
you know something to to leak from yeah

1073
00:38:21,920 --> 00:38:24,000
okay so as a security researcher you

1074
00:38:24,000 --> 00:38:24,880
were just

1075
00:38:24,880 --> 00:38:26,960
reading the the documentations of

1076
00:38:26,960 --> 00:38:29,119
various uh okay so

1077
00:38:29,119 --> 00:38:30,720
again like

1078
00:38:30,720 --> 00:38:32,960
up until this work everything everyone

1079
00:38:32,960 --> 00:38:34,800
thought that creating trends in windows

1080
00:38:34,800 --> 00:38:36,640
is by mispredicting a branch but it

1081
00:38:36,640 --> 00:38:39,280
seemed too too naive as as a conclusion

1082
00:38:39,280 --> 00:38:41,920
so there must have been another way that

1083
00:38:41,920 --> 00:38:44,400
you can actually do this and if you look

1084
00:38:44,400 --> 00:38:46,240
also from another perspective of

1085
00:38:46,240 --> 00:38:48,000
performance performance degradation

1086
00:38:48,000 --> 00:38:49,760
where do you actually lose clock cycles

1087
00:38:49,760 --> 00:38:51,680
in the execution and then you can

1088
00:38:51,680 --> 00:38:53,839
backtrack what are the different causes

1089
00:38:53,839 --> 00:38:56,880
of losing uh execution throughput and

1090
00:38:56,880 --> 00:38:58,320
then you can see all the different

1091
00:38:58,320 --> 00:39:00,079
reasons and one of them is actually the

1092
00:39:00,079 --> 00:39:02,480
entire class of machine clear okay thank

1093
00:39:02,480 --> 00:39:03,760
you

1094
00:39:03,760 --> 00:39:08,359
so thanks again enrique on hani

1095
00:39:12,140 --> 00:39:15,219
[Applause]

