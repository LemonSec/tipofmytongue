1
00:00:05,040 --> 00:00:05,600
hello

2
00:00:05,600 --> 00:00:07,839
this is fabi traversa i'm the cto of

3
00:00:07,839 --> 00:00:08,880
memp computing

4
00:00:08,880 --> 00:00:10,800
spinoff from university of california

5
00:00:10,800 --> 00:00:12,799
san diego during this call i'm going to

6
00:00:12,799 --> 00:00:13,679
introduce

7
00:00:13,679 --> 00:00:17,039
a new computing paradigm we call them

8
00:00:17,039 --> 00:00:17,920
computing

9
00:00:17,920 --> 00:00:21,760
as the company but before introducing uh

10
00:00:21,760 --> 00:00:24,800
mem computing let me just recall

11
00:00:24,800 --> 00:00:26,960
what is a turing machine that is a very

12
00:00:26,960 --> 00:00:28,480
simple ideal

13
00:00:28,480 --> 00:00:31,519
concept of a computing machine that

14
00:00:31,519 --> 00:00:34,640
really describes all computers

15
00:00:34,640 --> 00:00:37,600
and computing architectures that we use

16
00:00:37,600 --> 00:00:39,440
today to perform

17
00:00:39,440 --> 00:00:42,239
tasks and the turing machine is a very

18
00:00:42,239 --> 00:00:44,000
simple concept as i said

19
00:00:44,000 --> 00:00:47,039
and it is composed of it is an ideal

20
00:00:47,039 --> 00:00:48,320
object composed of

21
00:00:48,320 --> 00:00:50,960
a tape in which there are symbols that

22
00:00:50,960 --> 00:00:51,840
are written

23
00:00:51,840 --> 00:00:54,480
and there is an head that can read and

24
00:00:54,480 --> 00:00:54,879
write

25
00:00:54,879 --> 00:00:57,360
those symbols following a table of

26
00:00:57,360 --> 00:00:58,320
instructions

27
00:00:58,320 --> 00:01:02,800
now this is a very useful

28
00:01:02,800 --> 00:01:04,720
mathematical concept because we can use

29
00:01:04,720 --> 00:01:06,479
this to address the computational

30
00:01:06,479 --> 00:01:07,520
complexity

31
00:01:07,520 --> 00:01:10,479
of problems that we try to solve with

32
00:01:10,479 --> 00:01:11,680
our computers

33
00:01:11,680 --> 00:01:14,640
and not only that we can use also to

34
00:01:14,640 --> 00:01:17,280
optimize

35
00:01:17,520 --> 00:01:20,000
design of computing architectures and

36
00:01:20,000 --> 00:01:21,600
talking about design of computer

37
00:01:21,600 --> 00:01:24,960
architectures for example most of them

38
00:01:24,960 --> 00:01:27,439
if not all of them basically have in

39
00:01:27,439 --> 00:01:28,320
common in this

40
00:01:28,320 --> 00:01:31,280
very simple uh sketch of architecture

41
00:01:31,280 --> 00:01:31,759
which

42
00:01:31,759 --> 00:01:34,079
we call today phenomenal architecture

43
00:01:34,079 --> 00:01:35,360
and this is a

44
00:01:35,360 --> 00:01:37,920
very simple as i said we have an input

45
00:01:37,920 --> 00:01:40,240
device that sends

46
00:01:40,240 --> 00:01:43,600
inputs to a center processing unit that

47
00:01:43,600 --> 00:01:46,640
computes these inputs and while the if

48
00:01:46,640 --> 00:01:49,280
it is computing since it cannot store

49
00:01:49,280 --> 00:01:50,000
really

50
00:01:50,000 --> 00:01:52,159
the memory itself it exchanges

51
00:01:52,159 --> 00:01:53,200
continuously

52
00:01:53,200 --> 00:01:55,759
with a memory unit the data that is

53
00:01:55,759 --> 00:01:57,200
processing and when

54
00:01:57,200 --> 00:02:00,240
it finishes to process which means

55
00:02:00,240 --> 00:02:02,479
it finishes all the stages of an

56
00:02:02,479 --> 00:02:03,680
algorithm

57
00:02:03,680 --> 00:02:06,880
then it outputs the results now

58
00:02:06,880 --> 00:02:10,080
uh the first thing that here we can see

59
00:02:10,080 --> 00:02:10,639
is that

60
00:02:10,639 --> 00:02:12,959
there is a main limitation for this uh

61
00:02:12,959 --> 00:02:14,400
architecture which is

62
00:02:14,400 --> 00:02:18,080
uh the bottleneck of uh exchanging com

63
00:02:18,080 --> 00:02:21,840
constantly uh data between

64
00:02:21,840 --> 00:02:23,760
the memory unit and the processing unit

65
00:02:23,760 --> 00:02:24,879
this is called

66
00:02:24,879 --> 00:02:26,959
the phenomenon bottleneck and the white

67
00:02:26,959 --> 00:02:28,879
is a bottom not just because

68
00:02:28,879 --> 00:02:32,480
uh uh it it creates a bottleneck in the

69
00:02:32,480 --> 00:02:33,440
speed but

70
00:02:33,440 --> 00:02:35,599
also because the ninety percent of the

71
00:02:35,599 --> 00:02:37,040
energy expenditure for

72
00:02:37,040 --> 00:02:41,120
today's architectures comes from

73
00:02:41,120 --> 00:02:43,519
that exchange between memory and

74
00:02:43,519 --> 00:02:44,959
processing units so

75
00:02:44,959 --> 00:02:49,599
avoiding this step will be a great uh

76
00:02:49,599 --> 00:02:53,040
leap in computing architectures and

77
00:02:53,040 --> 00:02:56,879
nevertheless we have basically that all

78
00:02:56,879 --> 00:02:59,599
our modern computer architecture have

79
00:02:59,599 --> 00:03:00,959
have this this scheme

80
00:03:00,959 --> 00:03:04,080
the default scheme starting from gpu cpu

81
00:03:04,080 --> 00:03:06,480
ending to more specialized architectures

82
00:03:06,480 --> 00:03:07,440
like asics

83
00:03:07,440 --> 00:03:10,720
and fpgas however they are very

84
00:03:10,720 --> 00:03:12,000
efficient

85
00:03:12,000 --> 00:03:15,680
in doing many tasks like uh graphics

86
00:03:15,680 --> 00:03:17,120
machine learning simulation data

87
00:03:17,120 --> 00:03:18,879
analytics and support in fact

88
00:03:18,879 --> 00:03:22,400
we use them every day and we use

89
00:03:22,400 --> 00:03:25,680
them starting from our watches that they

90
00:03:25,680 --> 00:03:28,000
are smart watches because they can they

91
00:03:28,000 --> 00:03:30,319
can perform many many tasks like

92
00:03:30,319 --> 00:03:32,720
very small computers and finishing two

93
00:03:32,720 --> 00:03:34,080
warehouse

94
00:03:34,080 --> 00:03:38,480
that contains a

95
00:03:38,720 --> 00:03:41,120
humongous amount of data and they

96
00:03:41,120 --> 00:03:42,640
continuously compute

97
00:03:42,640 --> 00:03:45,760
and in fact today mainly most of the

98
00:03:45,760 --> 00:03:47,040
computations

99
00:03:47,040 --> 00:03:49,519
is migrating to what is called for

100
00:03:49,519 --> 00:03:51,519
example the cloud computing

101
00:03:51,519 --> 00:03:54,720
and in fact people they

102
00:03:54,720 --> 00:03:57,280
limited using cloud computing but for

103
00:03:57,280 --> 00:03:59,200
example larger enterprises even

104
00:03:59,200 --> 00:04:00,080
governments

105
00:04:00,080 --> 00:04:02,200
are migrating their

106
00:04:02,200 --> 00:04:03,519
[Music]

107
00:04:03,519 --> 00:04:06,239
their needs to cloud computing instead

108
00:04:06,239 --> 00:04:06,640
of

109
00:04:06,640 --> 00:04:10,560
in-house servers and in fact the need of

110
00:04:10,560 --> 00:04:11,599
computation

111
00:04:11,599 --> 00:04:14,879
is everyday growing here there is a

112
00:04:14,879 --> 00:04:15,760
forecast

113
00:04:15,760 --> 00:04:18,880
of how much energy we are going to need

114
00:04:18,880 --> 00:04:22,639
to continue uh the trend of

115
00:04:22,639 --> 00:04:26,240
our computation of today and in fact by

116
00:04:26,240 --> 00:04:29,759
2030 35 and this forecast say that

117
00:04:29,759 --> 00:04:32,560
we will have not uh any more enough

118
00:04:32,560 --> 00:04:33,440
energy

119
00:04:33,440 --> 00:04:36,800
just to uh run our servers and

120
00:04:36,800 --> 00:04:38,880
uh that's not the only problem there is

121
00:04:38,880 --> 00:04:40,080
another problem that

122
00:04:40,080 --> 00:04:42,320
uh the trend of the moore law it's

123
00:04:42,320 --> 00:04:44,000
unfortunately finishing

124
00:04:44,000 --> 00:04:47,199
uh the murloc is a very simple

125
00:04:47,199 --> 00:04:50,400
law that says that uh basically you can

126
00:04:50,400 --> 00:04:53,440
double the number of transistors

127
00:04:53,440 --> 00:04:56,720
uh within a

128
00:04:56,720 --> 00:04:59,280
unit of area of of of a chip on an

129
00:04:59,280 --> 00:05:00,560
integrated

130
00:05:00,560 --> 00:05:02,479
circuit but unfortunately we have

131
00:05:02,479 --> 00:05:03,680
arrived to

132
00:05:03,680 --> 00:05:06,400
about seven nanometers which is

133
00:05:06,400 --> 00:05:07,360
basically

134
00:05:07,360 --> 00:05:10,720
a a physical limit because

135
00:05:10,720 --> 00:05:13,759
with that channel length we already are

136
00:05:13,759 --> 00:05:16,720
experiencing a lot of quantum effects in

137
00:05:16,720 --> 00:05:18,240
our transistor which means that

138
00:05:18,240 --> 00:05:22,000
they don't really behave as we expect

139
00:05:22,000 --> 00:05:26,000
and therefore there is a big need for

140
00:05:26,000 --> 00:05:28,479
new computing architectures for example

141
00:05:28,479 --> 00:05:29,039
many

142
00:05:29,039 --> 00:05:31,600
large corporations are working on

143
00:05:31,600 --> 00:05:32,639
quantum computing

144
00:05:32,639 --> 00:05:35,919
starting from ibm phishing to google

145
00:05:35,919 --> 00:05:37,440
microsoft

146
00:05:37,440 --> 00:05:40,400
and intel just to mention some of the

147
00:05:40,400 --> 00:05:41,280
big players

148
00:05:41,280 --> 00:05:43,199
then there are also startups that are

149
00:05:43,199 --> 00:05:45,039
trying to build quantum computers

150
00:05:45,039 --> 00:05:47,840
and then there is also this called

151
00:05:47,840 --> 00:05:49,680
neuromorphic computing which is

152
00:05:49,680 --> 00:05:52,560
basically trying to mimic our brain and

153
00:05:52,560 --> 00:05:54,080
put the brain on the chip

154
00:05:54,080 --> 00:05:57,120
essentially so sort of neural network on

155
00:05:57,120 --> 00:05:58,000
chip

156
00:05:58,000 --> 00:06:00,560
so they are asynchronous circuits that

157
00:06:00,560 --> 00:06:01,120
tries

158
00:06:01,120 --> 00:06:03,520
to uh perform some computation that is

159
00:06:03,520 --> 00:06:04,639
still

160
00:06:04,639 --> 00:06:06,960
in its infancy i will say because they

161
00:06:06,960 --> 00:06:08,639
are a very hard

162
00:06:08,639 --> 00:06:11,440
circuit to

163
00:06:11,759 --> 00:06:14,080
manage and finally there is mem

164
00:06:14,080 --> 00:06:15,039
computing which is

165
00:06:15,039 --> 00:06:16,960
the proposal that we have done here at

166
00:06:16,960 --> 00:06:19,280
the university of california

167
00:06:19,280 --> 00:06:21,520
which is a bit different is kind of

168
00:06:21,520 --> 00:06:22,400
resemble

169
00:06:22,400 --> 00:06:24,639
neuromorphic computing but instead of

170
00:06:24,639 --> 00:06:26,080
having something

171
00:06:26,080 --> 00:06:28,160
uh that are basically spiking neural

172
00:06:28,160 --> 00:06:29,360
networks we use

173
00:06:29,360 --> 00:06:32,319
instead a self-organizing circuit that

174
00:06:32,319 --> 00:06:33,039
uh

175
00:06:33,039 --> 00:06:36,000
try to manipulate algebra and logic i

176
00:06:36,000 --> 00:06:36,479
will

177
00:06:36,479 --> 00:06:40,400
uh show you how but uh however before

178
00:06:40,400 --> 00:06:44,160
going uh uh to um discuss how

179
00:06:44,160 --> 00:06:46,240
a main computing machine work let me

180
00:06:46,240 --> 00:06:48,560
just recall that uh

181
00:06:48,560 --> 00:06:50,639
those machines obviously stand from

182
00:06:50,639 --> 00:06:51,680
standard

183
00:06:51,680 --> 00:06:53,599
to unconventional computing can be used

184
00:06:53,599 --> 00:06:55,759
also to perform attacks

185
00:06:55,759 --> 00:06:59,039
to our uh secure system today

186
00:06:59,039 --> 00:07:02,000
and uh just let me briefly uh divide the

187
00:07:02,000 --> 00:07:04,560
attacks into two big families so one is

188
00:07:04,560 --> 00:07:06,479
brute force attack so for example

189
00:07:06,479 --> 00:07:08,479
breaking keys or inverting shatu

190
00:07:08,479 --> 00:07:10,960
or recovering passwords and the other

191
00:07:10,960 --> 00:07:11,759
attack

192
00:07:11,759 --> 00:07:14,639
obviously is can be smarter like

193
00:07:14,639 --> 00:07:15,360
exploiting

194
00:07:15,360 --> 00:07:17,440
vulnerability credential staffing

195
00:07:17,440 --> 00:07:19,360
fishings and so on

196
00:07:19,360 --> 00:07:21,919
we will concentrate more here on brute

197
00:07:21,919 --> 00:07:23,199
force attack because

198
00:07:23,199 --> 00:07:26,160
we want to know uh what really new

199
00:07:26,160 --> 00:07:27,360
architecture

200
00:07:27,360 --> 00:07:29,199
architectures can do in terms of

201
00:07:29,199 --> 00:07:31,360
computations so

202
00:07:31,360 --> 00:07:34,240
we are not going to try to use them so

203
00:07:34,240 --> 00:07:36,240
smartly

204
00:07:36,240 --> 00:07:39,199
and so here we can divide basically the

205
00:07:39,199 --> 00:07:40,400
cyber attacks

206
00:07:40,400 --> 00:07:43,440
into the smart ones that are basically

207
00:07:43,440 --> 00:07:45,840
uh the ones that we can do with our uh

208
00:07:45,840 --> 00:07:47,680
conventional hardware

209
00:07:47,680 --> 00:07:49,680
and that's why we don't try even to do

210
00:07:49,680 --> 00:07:50,879
brute force attacks with the

211
00:07:50,879 --> 00:07:52,479
conventional hardwares because

212
00:07:52,479 --> 00:07:55,759
they uh the for example imagine rsa

213
00:07:55,759 --> 00:07:58,639
and that is based on factorization of

214
00:07:58,639 --> 00:07:59,599
prime numbers

215
00:07:59,599 --> 00:08:01,360
uh has been chosen the factorization

216
00:08:01,360 --> 00:08:03,120
exactly because is

217
00:08:03,120 --> 00:08:06,400
a very difficult and intensive tasks for

218
00:08:06,400 --> 00:08:09,199
uh today's architecture so they those

219
00:08:09,199 --> 00:08:10,080
are

220
00:08:10,080 --> 00:08:12,879
problems that are let's say impossible

221
00:08:12,879 --> 00:08:14,240
to solve

222
00:08:14,240 --> 00:08:16,639
to be solved by uh standard the

223
00:08:16,639 --> 00:08:17,520
computing machine

224
00:08:17,520 --> 00:08:20,240
computers and so forth or at least uh

225
00:08:20,240 --> 00:08:21,120
they will need

226
00:08:21,120 --> 00:08:24,240
the age or the the time that uh overcome

227
00:08:24,240 --> 00:08:26,080
the age of the universe

228
00:08:26,080 --> 00:08:28,960
then we have neuromorphic computing as i

229
00:08:28,960 --> 00:08:31,599
said and that unfortunately

230
00:08:31,599 --> 00:08:35,519
makes no promises about

231
00:08:35,599 --> 00:08:39,120
some attacks or really is not geared

232
00:08:39,120 --> 00:08:40,958
towards these problems then we have

233
00:08:40,958 --> 00:08:42,559
quantum computing which

234
00:08:42,559 --> 00:08:46,080
actually it became famous because uh

235
00:08:46,080 --> 00:08:46,720
sure

236
00:08:46,720 --> 00:08:50,000
in the uh 90s uh showed that if you had

237
00:08:50,000 --> 00:08:51,120
a quantum computer

238
00:08:51,120 --> 00:08:53,680
you can actually factorize large prime

239
00:08:53,680 --> 00:08:54,399
numbers

240
00:08:54,399 --> 00:08:56,160
obviously you need a large quantum

241
00:08:56,160 --> 00:08:57,440
computer to do that

242
00:08:57,440 --> 00:09:00,320
and then finally there is mem computing

243
00:09:00,320 --> 00:09:00,640
now

244
00:09:00,640 --> 00:09:03,120
uh when computing has been devised not

245
00:09:03,120 --> 00:09:04,160
to make

246
00:09:04,160 --> 00:09:06,880
cyber attacks but has been devised to

247
00:09:06,880 --> 00:09:08,000
solve uh

248
00:09:08,000 --> 00:09:11,839
hard combinatorial problems and i uh

249
00:09:11,839 --> 00:09:15,200
will show how and uh but obviously

250
00:09:15,200 --> 00:09:16,720
if you can solve a hard combinatorial

251
00:09:16,720 --> 00:09:19,040
problems maybe you can solve hard set

252
00:09:19,040 --> 00:09:19,839
problems

253
00:09:19,839 --> 00:09:23,279
which ultimately uh can be used

254
00:09:23,279 --> 00:09:26,480
to make seven attacks and

255
00:09:26,480 --> 00:09:29,519
uh but before going on an application on

256
00:09:29,519 --> 00:09:30,080
to comp

257
00:09:30,080 --> 00:09:33,279
on computing let me just briefly

258
00:09:33,279 --> 00:09:35,920
give an overview of where we stand with

259
00:09:35,920 --> 00:09:37,600
quantum computing because i'm

260
00:09:37,600 --> 00:09:40,880
i'm sure that uh some of you it's

261
00:09:40,880 --> 00:09:42,080
curious to know if

262
00:09:42,080 --> 00:09:44,720
really you can use a quantum computing

263
00:09:44,720 --> 00:09:46,320
computer in short term

264
00:09:46,320 --> 00:09:49,680
to perform some attack and uh so here

265
00:09:49,680 --> 00:09:50,800
quantum computers are

266
00:09:50,800 --> 00:09:53,839
are really uh beautiful

267
00:09:53,839 --> 00:09:57,279
uh objects they are very complicated you

268
00:09:57,279 --> 00:09:58,720
need the physicists to run a quantum

269
00:09:58,720 --> 00:10:00,080
computer of course

270
00:10:00,080 --> 00:10:03,680
they are meant not just to makes

271
00:10:03,680 --> 00:10:06,640
solve prime factorization problems but

272
00:10:06,640 --> 00:10:08,560
they will be great

273
00:10:08,560 --> 00:10:11,120
to for example simulate other quantum

274
00:10:11,120 --> 00:10:12,480
systems so you can

275
00:10:12,480 --> 00:10:15,760
basically assimilate molecules and make

276
00:10:15,760 --> 00:10:17,680
drug discovery and

277
00:10:17,680 --> 00:10:20,880
and for example if we had some big

278
00:10:20,880 --> 00:10:22,399
some large quantum computer we could

279
00:10:22,399 --> 00:10:24,560
have find very quickly

280
00:10:24,560 --> 00:10:27,839
uh some uh made for

281
00:10:27,839 --> 00:10:30,720
for the copy this in this moment but

282
00:10:30,720 --> 00:10:31,279
still

283
00:10:31,279 --> 00:10:34,000
they are in their infancy and so we have

284
00:10:34,000 --> 00:10:36,959
just very small

285
00:10:38,079 --> 00:10:41,680
creation of these and in fact

286
00:10:41,680 --> 00:10:43,760
we have two type of quantum computers

287
00:10:43,760 --> 00:10:44,880
today uh

288
00:10:44,880 --> 00:10:47,200
one is based on quantum annealing there

289
00:10:47,200 --> 00:10:48,160
is for example

290
00:10:48,160 --> 00:10:50,959
very famous the way machine that

291
00:10:50,959 --> 00:10:52,560
implements quantum annealing

292
00:10:52,560 --> 00:10:55,440
however quantum aliening is not really

293
00:10:55,440 --> 00:10:56,399
what you expect

294
00:10:56,399 --> 00:10:59,440
for from a typical quantum computer

295
00:10:59,440 --> 00:11:00,480
quantum monitoring

296
00:11:00,480 --> 00:11:03,360
is more used to uh solve optimization

297
00:11:03,360 --> 00:11:04,160
problems

298
00:11:04,160 --> 00:11:07,279
and really even today is not really well

299
00:11:07,279 --> 00:11:08,000
known

300
00:11:08,000 --> 00:11:10,880
how useful is going to be a quantum

301
00:11:10,880 --> 00:11:12,240
annealing machine

302
00:11:12,240 --> 00:11:14,160
then on the other side we have another

303
00:11:14,160 --> 00:11:15,519
type of quantum computer

304
00:11:15,519 --> 00:11:17,760
uh which is basically what is trying to

305
00:11:17,760 --> 00:11:19,279
build what is building

306
00:11:19,279 --> 00:11:22,640
uh ibm for example uh which has uh

307
00:11:22,640 --> 00:11:25,760
a system composed of uh several uh

308
00:11:25,760 --> 00:11:27,200
quantum bits

309
00:11:27,200 --> 00:11:31,519
and they are fully entangled and you can

310
00:11:31,519 --> 00:11:33,680
manipulate those using what they are

311
00:11:33,680 --> 00:11:35,120
called quantum gates

312
00:11:35,120 --> 00:11:37,519
now is this kind of quantum computer

313
00:11:37,519 --> 00:11:39,680
which is called also universal quantum

314
00:11:39,680 --> 00:11:40,480
computer

315
00:11:40,480 --> 00:11:43,760
that you can use to implement the short

316
00:11:43,760 --> 00:11:44,560
algorithm

317
00:11:44,560 --> 00:11:47,360
and for example the ibm quantum computer

318
00:11:47,360 --> 00:11:48,800
you can do that but

319
00:11:48,800 --> 00:11:51,040
unfortunately you today you have just

320
00:11:51,040 --> 00:11:52,480
your disposal like

321
00:11:52,480 --> 00:11:54,639
10 or something like that a fully

322
00:11:54,639 --> 00:11:56,160
entangled qubit and

323
00:11:56,160 --> 00:11:58,800
just to give an order of magnitude of

324
00:11:58,800 --> 00:12:00,399
how many qubits you need

325
00:12:00,399 --> 00:12:04,800
to really break a a 1024

326
00:12:04,800 --> 00:12:07,519
bit key you are going to need the order

327
00:12:07,519 --> 00:12:07,920
of

328
00:12:07,920 --> 00:12:10,959
10 to the six order millions of fully

329
00:12:10,959 --> 00:12:11,920
entangled

330
00:12:11,920 --> 00:12:15,279
entangled qubit and just to

331
00:12:15,279 --> 00:12:18,399
give an idea in 10 years maybe

332
00:12:18,399 --> 00:12:22,639
ibm will arrive to 100 food entangled

333
00:12:22,639 --> 00:12:24,639
qubits if they are lucky because

334
00:12:24,639 --> 00:12:27,360
they and the qubits really do not double

335
00:12:27,360 --> 00:12:29,360
every year like the transistors

336
00:12:29,360 --> 00:12:32,399
because it is very hard to uh increase

337
00:12:32,399 --> 00:12:34,480
the number of food entangled qubits in a

338
00:12:34,480 --> 00:12:36,399
system of qubits so they

339
00:12:36,399 --> 00:12:39,200
rather add a few qubits each year rather

340
00:12:39,200 --> 00:12:39,839
than

341
00:12:39,839 --> 00:12:42,639
multiplying the entire system so let's

342
00:12:42,639 --> 00:12:43,440
say that uh

343
00:12:43,440 --> 00:12:47,680
using a quantum computer for uh attacks

344
00:12:47,680 --> 00:12:50,880
it's still far away for now

345
00:12:50,880 --> 00:12:54,399
and so now finally we have arrived

346
00:12:54,399 --> 00:12:58,079
to mam computing that is this

347
00:12:58,079 --> 00:13:00,320
a new alternative we have introduced so

348
00:13:00,320 --> 00:13:01,839
first of all

349
00:13:01,839 --> 00:13:05,360
let me say mem computing does not rely

350
00:13:05,360 --> 00:13:06,560
on uh

351
00:13:06,560 --> 00:13:08,880
for neumann architecture and in fact we

352
00:13:08,880 --> 00:13:11,120
introduced this as a

353
00:13:11,120 --> 00:13:14,160
an idealization at the beginning of a

354
00:13:14,160 --> 00:13:15,839
computational memory itself

355
00:13:15,839 --> 00:13:19,279
so let's see uh this this

356
00:13:19,279 --> 00:13:20,959
so you can review a universal main

357
00:13:20,959 --> 00:13:23,120
computing machine as a counterpart

358
00:13:23,120 --> 00:13:26,160
of a universal turing machine so it's a

359
00:13:26,160 --> 00:13:27,200
non-touring

360
00:13:27,200 --> 00:13:30,720
uh type of uh computational paradigm

361
00:13:30,720 --> 00:13:32,560
you have at the center as i said this

362
00:13:32,560 --> 00:13:34,959
computational memory which is a

363
00:13:34,959 --> 00:13:38,399
an ideal object an ideal network of

364
00:13:38,399 --> 00:13:40,800
a small processor you can imagine that

365
00:13:40,800 --> 00:13:43,040
can store

366
00:13:43,040 --> 00:13:46,000
information and

367
00:13:46,079 --> 00:13:48,880
manipulate it at the same time without

368
00:13:48,880 --> 00:13:50,639
exchanging data with

369
00:13:50,639 --> 00:13:54,000
an external uh memory unit

370
00:13:54,000 --> 00:13:55,920
then you have this control unit that

371
00:13:55,920 --> 00:13:58,160
just sends signals in order to

372
00:13:58,160 --> 00:13:59,839
start the computation from the

373
00:13:59,839 --> 00:14:01,839
computational memory now this

374
00:14:01,839 --> 00:14:05,199
this as a mathematical object you must

375
00:14:05,199 --> 00:14:06,800
have some

376
00:14:06,800 --> 00:14:09,279
extra

377
00:14:09,920 --> 00:14:12,480
feature we call for example we have

378
00:14:12,480 --> 00:14:13,199
defined this

379
00:14:13,199 --> 00:14:15,360
extra feature like intrinsic parallelism

380
00:14:15,360 --> 00:14:16,399
which means that

381
00:14:16,399 --> 00:14:20,800
each of these processors will uh

382
00:14:20,800 --> 00:14:24,000
compute and perform computation all all

383
00:14:24,000 --> 00:14:25,760
in parallel basically you can imagine

384
00:14:25,760 --> 00:14:27,839
that there is sort of collective state

385
00:14:27,839 --> 00:14:31,040
of all these processors

386
00:14:31,040 --> 00:14:35,519
that that drives their their state

387
00:14:35,519 --> 00:14:39,440
in time and then there is another

388
00:14:39,440 --> 00:14:41,040
important feature that they should have

389
00:14:41,040 --> 00:14:42,839
to really

390
00:14:42,839 --> 00:14:46,079
perform uh better than a turing machine

391
00:14:46,079 --> 00:14:47,120
they they should be

392
00:14:47,120 --> 00:14:49,519
specialized we call this information red

393
00:14:49,519 --> 00:14:51,519
but basically means that

394
00:14:51,519 --> 00:14:54,639
the this network

395
00:14:54,639 --> 00:14:58,000
must include some uh extra

396
00:14:58,000 --> 00:15:01,199
feature of the problem so it's not

397
00:15:01,199 --> 00:15:03,440
just a random topology or something like

398
00:15:03,440 --> 00:15:05,120
a neural network for example that you

399
00:15:05,120 --> 00:15:06,000
train to

400
00:15:06,000 --> 00:15:10,320
to have to have some uh property

401
00:15:10,320 --> 00:15:12,320
we have formalized this concept we have

402
00:15:12,320 --> 00:15:13,760
published a few uh

403
00:15:13,760 --> 00:15:16,480
peer-reviewed paper and uh we have

404
00:15:16,480 --> 00:15:17,839
proved that uh

405
00:15:17,839 --> 00:15:20,800
if you uh have these if you formalize

406
00:15:20,800 --> 00:15:22,480
this as you formalize for example a

407
00:15:22,480 --> 00:15:24,000
turing machine you discovered

408
00:15:24,000 --> 00:15:25,920
that basically the main computing

409
00:15:25,920 --> 00:15:27,839
machine is equivalent

410
00:15:27,839 --> 00:15:30,880
to a non-deterministic turing machine

411
00:15:30,880 --> 00:15:34,160
this has a very immediate consequence

412
00:15:34,160 --> 00:15:34,959
that is

413
00:15:34,959 --> 00:15:36,480
you can solve with the mem computing

414
00:15:36,480 --> 00:15:38,800
machine non-deterministic polynomial

415
00:15:38,800 --> 00:15:40,959
problems in polynomial time

416
00:15:40,959 --> 00:15:42,639
well non-intermediate and problem

417
00:15:42,639 --> 00:15:44,399
polynomial times it's a big claim

418
00:15:44,399 --> 00:15:45,519
because it means that

419
00:15:45,519 --> 00:15:47,600
you can solve efficiently all

420
00:15:47,600 --> 00:15:50,320
satisfiability problems for example

421
00:15:50,320 --> 00:15:52,399
and for efficiently means in polynomial

422
00:15:52,399 --> 00:15:54,079
time now

423
00:15:54,079 --> 00:15:57,839
uh anyway that's the theory right

424
00:15:57,839 --> 00:16:01,360
and so if you can build the one of

425
00:16:01,360 --> 00:16:04,480
these machines of course you can first

426
00:16:04,480 --> 00:16:05,040
of all

427
00:16:05,040 --> 00:16:08,079
solve efficiently this uh

428
00:16:08,079 --> 00:16:10,720
hard this computational complaint this i

429
00:16:10,720 --> 00:16:11,440
have the

430
00:16:11,440 --> 00:16:15,759
computational complexity problem and or

431
00:16:15,759 --> 00:16:18,160
mitigate the fundamental bottleneck

432
00:16:18,160 --> 00:16:20,000
because again

433
00:16:20,000 --> 00:16:21,519
i recall that these are basically

434
00:16:21,519 --> 00:16:23,120
computational memory so

435
00:16:23,120 --> 00:16:25,040
the the idea that was at the basis of

436
00:16:25,040 --> 00:16:26,320
this that if

437
00:16:26,320 --> 00:16:29,519
is that you eliminate

438
00:16:29,519 --> 00:16:32,000
the data exchange between processing

439
00:16:32,000 --> 00:16:34,639
unit and memory

440
00:16:34,639 --> 00:16:37,839
and obviously here is the challenge

441
00:16:37,839 --> 00:16:40,800
uh that's all theory but how we can

442
00:16:40,800 --> 00:16:41,600
design

443
00:16:41,600 --> 00:16:43,360
a practical and computing machine so

444
00:16:43,360 --> 00:16:44,720
something that we can

445
00:16:44,720 --> 00:16:47,759
actually use to solve

446
00:16:47,759 --> 00:16:51,600
hard problems and so

447
00:16:51,600 --> 00:16:56,000
we are working uh since roughly 2015

448
00:16:56,000 --> 00:16:58,959
in designing uh mem computing machines

449
00:16:58,959 --> 00:16:59,279
and

450
00:16:59,279 --> 00:17:02,079
we have divided those in two big

451
00:17:02,079 --> 00:17:02,800
families

452
00:17:02,800 --> 00:17:05,119
one that are self-organizing circuits

453
00:17:05,119 --> 00:17:05,919
which we

454
00:17:05,919 --> 00:17:09,439
use to solve hard combinatorial problems

455
00:17:09,439 --> 00:17:13,199
and another family that are based on

456
00:17:13,199 --> 00:17:15,359
based on dynamic computing random access

457
00:17:15,359 --> 00:17:17,039
memory architecture

458
00:17:17,039 --> 00:17:20,319
that is you can imagine really a ram

459
00:17:20,319 --> 00:17:24,079
but uh is composed of uh some cells

460
00:17:24,079 --> 00:17:26,160
that can communicate and can perform

461
00:17:26,160 --> 00:17:28,400
directly computation on the ram without

462
00:17:28,400 --> 00:17:29,360
needing

463
00:17:29,360 --> 00:17:32,960
a a cpu uh

464
00:17:32,960 --> 00:17:34,960
i'm going to discuss today just the

465
00:17:34,960 --> 00:17:36,720
self-organizing circuit

466
00:17:36,720 --> 00:17:39,919
because is they are the ones that we can

467
00:17:39,919 --> 00:17:41,039
use to solve

468
00:17:41,039 --> 00:17:43,520
hard combinatorial problems and and

469
00:17:43,520 --> 00:17:45,200
therefore you can imagine that

470
00:17:45,200 --> 00:17:48,640
one day you can use also to

471
00:17:48,880 --> 00:17:51,679
perform attacks with some of those

472
00:17:51,679 --> 00:17:52,960
machines

473
00:17:52,960 --> 00:17:55,679
and uh so let me introduce a little bit

474
00:17:55,679 --> 00:17:56,720
more in detail

475
00:17:56,720 --> 00:18:00,960
what are the self-organizing secret

476
00:18:00,960 --> 00:18:03,039
before doing that let me just very

477
00:18:03,039 --> 00:18:04,320
briefly recall

478
00:18:04,320 --> 00:18:07,440
what is a boolean gate

479
00:18:07,440 --> 00:18:10,480
boolean gate is a very

480
00:18:10,480 --> 00:18:13,919
basic object an input output object to

481
00:18:13,919 --> 00:18:16,160
be more precise and in fact we can feed

482
00:18:16,160 --> 00:18:16,640
the

483
00:18:16,640 --> 00:18:19,600
inputs to the input terminals and it

484
00:18:19,600 --> 00:18:20,559
will return an

485
00:18:20,559 --> 00:18:24,160
output at the output the output terminal

486
00:18:24,160 --> 00:18:26,799
following what we call a through table

487
00:18:26,799 --> 00:18:28,160
this is for example

488
00:18:28,160 --> 00:18:31,440
the truth table of an end gate now we

489
00:18:31,440 --> 00:18:32,320
can

490
00:18:32,320 --> 00:18:36,080
use this gate and put together with

491
00:18:36,080 --> 00:18:38,480
other similar gates form a boolean

492
00:18:38,480 --> 00:18:39,200
circuit

493
00:18:39,200 --> 00:18:41,679
we feed inputs this will return outputs

494
00:18:41,679 --> 00:18:43,120
that we can use as

495
00:18:43,120 --> 00:18:46,240
new inputs for the next stage and

496
00:18:46,240 --> 00:18:49,520
and so forth uh till arriving to

497
00:18:49,520 --> 00:18:53,360
the final output that is the solution of

498
00:18:53,360 --> 00:18:56,720
whatever problem we are trying to solve

499
00:18:56,720 --> 00:18:59,919
with the boolean logic uh

500
00:18:59,919 --> 00:19:03,360
now this is the sketch

501
00:19:03,360 --> 00:19:05,600
of how basically internally our

502
00:19:05,600 --> 00:19:07,840
computers really are working

503
00:19:07,840 --> 00:19:11,200
uh let us rethink about this

504
00:19:11,200 --> 00:19:14,240
so we can introduce one possible

505
00:19:14,240 --> 00:19:15,200
realization of a

506
00:19:15,200 --> 00:19:18,160
computing machine so let's consider uh

507
00:19:18,160 --> 00:19:18,640
again

508
00:19:18,640 --> 00:19:21,840
the same gate this gate is an end gate

509
00:19:21,840 --> 00:19:23,360
but at this

510
00:19:23,360 --> 00:19:26,559
time we do not limit our gate

511
00:19:26,559 --> 00:19:30,000
to just being a a sequential object but

512
00:19:30,000 --> 00:19:32,720
we allow our gates to accept input and

513
00:19:32,720 --> 00:19:34,240
output

514
00:19:34,240 --> 00:19:36,960
from all terminals so and they are

515
00:19:36,960 --> 00:19:39,039
superpositional signals essentially

516
00:19:39,039 --> 00:19:42,320
and the only requirement is that being a

517
00:19:42,320 --> 00:19:44,960
dynamical system it will self-organize

518
00:19:44,960 --> 00:19:45,440
it will

519
00:19:45,440 --> 00:19:48,880
uh in order to satisfy uh the relation

520
00:19:48,880 --> 00:19:49,760
in this case

521
00:19:49,760 --> 00:19:52,880
the end relation here self-organized uh

522
00:19:52,880 --> 00:19:55,520
you can image as i say the dynamical

523
00:19:55,520 --> 00:19:56,080
system

524
00:19:56,080 --> 00:19:58,480
self-organized means that you will find

525
00:19:58,480 --> 00:19:59,760
an equilibrium

526
00:19:59,760 --> 00:20:03,360
if and only if the boolean relation

527
00:20:03,360 --> 00:20:06,159
is satisfied otherwise you can imagine

528
00:20:06,159 --> 00:20:07,280
that there are current

529
00:20:07,280 --> 00:20:11,440
voltages there until it is not satisfied

530
00:20:11,440 --> 00:20:14,480
they will fluctuate in time now

531
00:20:14,480 --> 00:20:17,679
we can take these

532
00:20:17,679 --> 00:20:20,640
self-organizing gates and form a

533
00:20:20,640 --> 00:20:22,640
self-organizing circuit this is

534
00:20:22,640 --> 00:20:24,640
exactly one of those computational

535
00:20:24,640 --> 00:20:26,640
memories i was talking about

536
00:20:26,640 --> 00:20:28,720
and in fact we can use this to solve

537
00:20:28,720 --> 00:20:30,400
directly problems

538
00:20:30,400 --> 00:20:34,240
without exchanging data with a memory

539
00:20:34,240 --> 00:20:36,400
an external memory in fact is enough

540
00:20:36,400 --> 00:20:38,400
that we

541
00:20:38,400 --> 00:20:41,919
fix some of the nodes as inputs and

542
00:20:41,919 --> 00:20:45,679
then when the entire circuit will self

543
00:20:45,679 --> 00:20:48,559
organize will rearrange voltages and

544
00:20:48,559 --> 00:20:50,480
currents then we can

545
00:20:50,480 --> 00:20:53,600
read the output why this is solving a

546
00:20:53,600 --> 00:20:55,360
problem because imagine that

547
00:20:55,360 --> 00:20:58,720
if the circuit has found

548
00:20:58,720 --> 00:21:01,200
an equilibrium it means that all gates

549
00:21:01,200 --> 00:21:02,159
involved

550
00:21:02,159 --> 00:21:04,960
are satisfied so you can encode a

551
00:21:04,960 --> 00:21:05,840
problem

552
00:21:05,840 --> 00:21:08,559
into the gates that you want to be

553
00:21:08,559 --> 00:21:09,679
satisfied

554
00:21:09,679 --> 00:21:11,919
and those will satisfy a boolean

555
00:21:11,919 --> 00:21:13,039
relation which means

556
00:21:13,039 --> 00:21:15,280
you are satisfying you are finding the

557
00:21:15,280 --> 00:21:17,360
solution to a satisfiability problem

558
00:21:17,360 --> 00:21:20,159
just rearranging all voltages in a

559
00:21:20,159 --> 00:21:22,480
circuit

560
00:21:22,480 --> 00:21:26,320
how they really work how you can design

561
00:21:26,320 --> 00:21:27,919
something like this as i say that they

562
00:21:27,919 --> 00:21:31,679
are basically electronic circuit

563
00:21:31,679 --> 00:21:34,080
so let's consider this a simple sketch

564
00:21:34,080 --> 00:21:34,880
here of

565
00:21:34,880 --> 00:21:38,080
of a gate and let's look inside in this

566
00:21:38,080 --> 00:21:39,039
gate

567
00:21:39,039 --> 00:21:40,799
we can see that there are these blocks

568
00:21:40,799 --> 00:21:42,159
dcm we call them

569
00:21:42,159 --> 00:21:44,880
dynamic correcting modules how they work

570
00:21:44,880 --> 00:21:46,480
imagine that

571
00:21:46,480 --> 00:21:49,440
the configuration of the gate is the

572
00:21:49,440 --> 00:21:50,480
following

573
00:21:50,480 --> 00:21:54,080
and this is an end gate this means that

574
00:21:54,080 --> 00:21:57,120
this configuration is not consistent

575
00:21:57,120 --> 00:21:59,679
with the end relation and in fact either

576
00:21:59,679 --> 00:22:01,200
the upper

577
00:22:01,200 --> 00:22:04,799
right terminal should be 1 or

578
00:22:04,799 --> 00:22:08,080
the output terminal should be 0. now

579
00:22:08,080 --> 00:22:10,240
since the configuration is wrong we have

580
00:22:10,240 --> 00:22:12,000
these dynamic correcting modules that

581
00:22:12,000 --> 00:22:15,120
what they do is uh feeding

582
00:22:15,120 --> 00:22:18,640
uh some current for example the upper

583
00:22:18,640 --> 00:22:20,640
dynamic correcting module will feed a

584
00:22:20,640 --> 00:22:21,919
current trying

585
00:22:21,919 --> 00:22:24,640
to raise the voltage the upper terminal

586
00:22:24,640 --> 00:22:24,960
and

587
00:22:24,960 --> 00:22:28,000
switching from zero to one while the

588
00:22:28,000 --> 00:22:29,360
bottom

589
00:22:29,360 --> 00:22:33,520
uh dcm will do exactly the opposite

590
00:22:33,520 --> 00:22:36,000
trying to lower the voltage from one to

591
00:22:36,000 --> 00:22:37,120
zero

592
00:22:37,120 --> 00:22:40,159
and so they are working collectively

593
00:22:40,159 --> 00:22:41,600
here you can imagine that

594
00:22:41,600 --> 00:22:43,600
all these dynamic correcting modules

595
00:22:43,600 --> 00:22:44,799
they are all

596
00:22:44,799 --> 00:22:47,200
working together in into the circuit

597
00:22:47,200 --> 00:22:48,559
trying to satisfy

598
00:22:48,559 --> 00:22:52,320
all uh the gates at once

599
00:22:52,320 --> 00:22:55,760
now can we really design

600
00:22:55,760 --> 00:22:58,960
those dcms yes yes we can we have done

601
00:22:58,960 --> 00:22:59,919
several designs

602
00:22:59,919 --> 00:23:03,280
patented them and we are currently even

603
00:23:03,280 --> 00:23:06,400
building those things and they are

604
00:23:06,400 --> 00:23:09,440
simple feedback circuits

605
00:23:09,440 --> 00:23:13,039
feedback non-linear circuits that they

606
00:23:13,039 --> 00:23:15,760
instantaneously can read the voltage

607
00:23:15,760 --> 00:23:17,280
state at the terminal and they

608
00:23:17,280 --> 00:23:18,320
accordingly

609
00:23:18,320 --> 00:23:20,720
inject some current in order to behave

610
00:23:20,720 --> 00:23:21,520
as i

611
00:23:21,520 --> 00:23:25,919
explained before uh

612
00:23:25,919 --> 00:23:29,039
how we use those as i just said we can

613
00:23:29,039 --> 00:23:31,039
take our problem whatever it is

614
00:23:31,039 --> 00:23:34,159
we can write down

615
00:23:34,159 --> 00:23:37,679
as a set of boolean formulas

616
00:23:37,679 --> 00:23:41,760
and then we build a circuit that uh

617
00:23:41,760 --> 00:23:44,880
resemble exactly that embeds this

618
00:23:44,880 --> 00:23:47,760
boolean formula so we are

619
00:23:47,760 --> 00:23:50,159
creating a self-organizing circuit that

620
00:23:50,159 --> 00:23:51,760
is specialized for that

621
00:23:51,760 --> 00:23:55,039
instant of the problem here we find for

622
00:23:55,039 --> 00:23:56,720
example what i was talking about

623
00:23:56,720 --> 00:23:59,039
this information overhead so each of

624
00:23:59,039 --> 00:24:00,159
those circuits

625
00:24:00,159 --> 00:24:02,960
is specialized for an instance of a

626
00:24:02,960 --> 00:24:04,000
problem because

627
00:24:04,000 --> 00:24:07,600
the connectivity is a mapping of the

628
00:24:07,600 --> 00:24:09,200
problem itself

629
00:24:09,200 --> 00:24:12,799
into the circuit now why this should

630
00:24:12,799 --> 00:24:13,679
work

631
00:24:13,679 --> 00:24:17,120
i'm not going to bother you with a lot

632
00:24:17,120 --> 00:24:18,000
of math here

633
00:24:18,000 --> 00:24:21,440
we have written many articles explaining

634
00:24:21,440 --> 00:24:23,440
all the properties that these circuits

635
00:24:23,440 --> 00:24:25,360
should have we have used

636
00:24:25,360 --> 00:24:29,120
a lot of functional analysis uh

637
00:24:29,120 --> 00:24:32,720
topology topological and so forth

638
00:24:32,720 --> 00:24:36,080
and in principle

639
00:24:36,080 --> 00:24:37,840
you can have essentially a dynamical

640
00:24:37,840 --> 00:24:39,760
system you can design a dynamical system

641
00:24:39,760 --> 00:24:40,159
that

642
00:24:40,159 --> 00:24:43,600
from wherever you make it

643
00:24:43,600 --> 00:24:47,200
start it will converge to an equilibrium

644
00:24:47,200 --> 00:24:49,360
and that equilibrium is essentially

645
00:24:49,360 --> 00:24:51,600
the solution of your problem that's the

646
00:24:51,600 --> 00:24:54,000
overall concept how you can do that

647
00:24:54,000 --> 00:24:56,400
it's not super easy because those are

648
00:24:56,400 --> 00:24:57,200
non-linear

649
00:24:57,200 --> 00:25:00,480
dynamical systems but it is possible and

650
00:25:00,480 --> 00:25:03,600
that is what we are designing uh uh at

651
00:25:03,600 --> 00:25:05,120
mem computing and also

652
00:25:05,120 --> 00:25:08,000
at uc san diego in this moment uh here

653
00:25:08,000 --> 00:25:09,360
just uh

654
00:25:09,360 --> 00:25:13,360
to give uh some uh extra information of

655
00:25:13,360 --> 00:25:16,159
of those circuits uh they they do not

656
00:25:16,159 --> 00:25:17,600
work really like

657
00:25:17,600 --> 00:25:21,919
a normal um digital circuit in which you

658
00:25:21,919 --> 00:25:22,240
have

659
00:25:22,240 --> 00:25:24,880
your gates they they work like more like

660
00:25:24,880 --> 00:25:26,880
as i said like a dynamical system

661
00:25:26,880 --> 00:25:30,799
and they in fact show some of the

662
00:25:30,799 --> 00:25:32,880
the effects that you would find in a

663
00:25:32,880 --> 00:25:34,480
quantum computer for example

664
00:25:34,480 --> 00:25:37,600
there is a an emergence of what are

665
00:25:37,600 --> 00:25:39,200
called scale-free correlation it means

666
00:25:39,200 --> 00:25:41,200
that these circuits

667
00:25:41,200 --> 00:25:44,400
they have all nodes all gates that are

668
00:25:44,400 --> 00:25:46,480
extremely correlated which means that if

669
00:25:46,480 --> 00:25:47,679
you perturb

670
00:25:47,679 --> 00:25:50,159
some a point in the circuit any other

671
00:25:50,159 --> 00:25:52,400
point very far from that point feels

672
00:25:52,400 --> 00:25:54,480
almost instantaneously the perturbation

673
00:25:54,480 --> 00:25:57,200
this this is kind of a non-local effect

674
00:25:57,200 --> 00:26:00,159
that we leverage uh to converge very

675
00:26:00,159 --> 00:26:00,880
quickly

676
00:26:00,880 --> 00:26:03,520
to the solution of the problems then

677
00:26:03,520 --> 00:26:04,080
there is

678
00:26:04,080 --> 00:26:06,799
also other effects for example a sort of

679
00:26:06,799 --> 00:26:08,799
classical tunneling that we find

680
00:26:08,799 --> 00:26:10,640
in this in this circus that is very

681
00:26:10,640 --> 00:26:12,240
similar to what

682
00:26:12,240 --> 00:26:14,480
happens also in quantum computers but

683
00:26:14,480 --> 00:26:16,640
this is completely classical

684
00:26:16,640 --> 00:26:19,520
and uh we call this uh emergence of

685
00:26:19,520 --> 00:26:20,880
wistantonic phases

686
00:26:20,880 --> 00:26:23,520
which is basically uh the system jumps

687
00:26:23,520 --> 00:26:24,240
from

688
00:26:24,240 --> 00:26:26,720
saddle points to several points reaching

689
00:26:26,720 --> 00:26:28,559
uh equilibria

690
00:26:28,559 --> 00:26:30,880
or saddle points that have lesser and

691
00:26:30,880 --> 00:26:33,200
lesser um

692
00:26:33,200 --> 00:26:36,320
unstable directions and finally reaching

693
00:26:36,320 --> 00:26:39,919
the global minimum of of of

694
00:26:39,919 --> 00:26:44,240
the the circuit

695
00:26:44,240 --> 00:26:47,919
how we use nowadays to solve finally

696
00:26:47,919 --> 00:26:51,360
some problem uh well for example here i

697
00:26:51,360 --> 00:26:53,279
got a comment how to use

698
00:26:53,279 --> 00:26:55,279
these new architectures to solve

699
00:26:55,279 --> 00:26:57,200
satisfiability problems

700
00:26:57,200 --> 00:27:00,000
and uh let me recall that a

701
00:27:00,000 --> 00:27:01,840
satisfiability problem in conjunctive

702
00:27:01,840 --> 00:27:02,880
normal form

703
00:27:02,880 --> 00:27:06,320
is a collection of clauses

704
00:27:06,320 --> 00:27:09,440
and each clause includes

705
00:27:09,440 --> 00:27:11,919
literals that are variables or negation

706
00:27:11,919 --> 00:27:13,120
of variables

707
00:27:13,120 --> 00:27:16,159
and the goal here if it's a

708
00:27:16,159 --> 00:27:18,159
general maximum satisfiability process

709
00:27:18,159 --> 00:27:19,279
that includes also

710
00:27:19,279 --> 00:27:21,200
normal satisfaction problems is

711
00:27:21,200 --> 00:27:23,440
maximizing is finding an assignment to

712
00:27:23,440 --> 00:27:24,240
the variables that

713
00:27:24,240 --> 00:27:27,440
maximizes the number of clauses that are

714
00:27:27,440 --> 00:27:31,279
satisfied and how

715
00:27:31,279 --> 00:27:34,720
we can use mem computing to solve a

716
00:27:34,720 --> 00:27:36,480
system like this so let's consider for

717
00:27:36,480 --> 00:27:37,039
example

718
00:27:37,039 --> 00:27:40,000
this conjunctive normal form and a

719
00:27:40,000 --> 00:27:41,120
boolean circuit

720
00:27:41,120 --> 00:27:43,520
that represents this conjunctive normal

721
00:27:43,520 --> 00:27:45,279
form as you see from this slide

722
00:27:45,279 --> 00:27:47,840
so uh how it is representing for each

723
00:27:47,840 --> 00:27:48,720
clause

724
00:27:48,720 --> 00:27:51,760
there is a nor gate an n terminal or

725
00:27:51,760 --> 00:27:52,480
gate

726
00:27:52,480 --> 00:27:54,799
that exactly represents that clause and

727
00:27:54,799 --> 00:27:55,520
then

728
00:27:55,520 --> 00:28:00,399
all inputs are connecting following

729
00:28:00,399 --> 00:28:03,600
the variables obviously

730
00:28:03,600 --> 00:28:06,799
you can see that you cannot really use

731
00:28:06,799 --> 00:28:09,039
standard the boolean circuits to solve

732
00:28:09,039 --> 00:28:10,960
this problem the reason is very simple

733
00:28:10,960 --> 00:28:11,679
because

734
00:28:11,679 --> 00:28:14,880
the unknown of these problems are

735
00:28:14,880 --> 00:28:18,159
the voltages or the state of the

736
00:28:18,159 --> 00:28:21,039
input terminals of these or gates and so

737
00:28:21,039 --> 00:28:21,440
uh

738
00:28:21,440 --> 00:28:25,200
a standard the or gate cannot provide

739
00:28:25,200 --> 00:28:28,559
the inputs knowing the outputs but

740
00:28:28,559 --> 00:28:31,679
if they are self-organizing gates so if

741
00:28:31,679 --> 00:28:34,720
those are computing gates essentially we

742
00:28:34,720 --> 00:28:36,080
can just feed the

743
00:28:36,080 --> 00:28:39,120
ones to the output and so requiring that

744
00:28:39,120 --> 00:28:42,080
those gates are essentially satisfied

745
00:28:42,080 --> 00:28:42,640
and

746
00:28:42,640 --> 00:28:46,480
all the uh voltages at the terminal will

747
00:28:46,480 --> 00:28:49,039
rearrange with self organized in order

748
00:28:49,039 --> 00:28:50,880
to find an assignment

749
00:28:50,880 --> 00:28:55,760
that satisfies all these or gates

750
00:28:56,399 --> 00:28:59,600
and okay so we have even

751
00:28:59,600 --> 00:29:02,880
uh tested these uh emulating

752
00:29:02,880 --> 00:29:05,279
software for example these are some

753
00:29:05,279 --> 00:29:07,440
preliminaries that we did with the

754
00:29:07,440 --> 00:29:10,480
the super computing center of san diego

755
00:29:10,480 --> 00:29:13,760
we we were solving here some hard uh sat

756
00:29:13,760 --> 00:29:17,440
problems and uh we were comparing

757
00:29:17,440 --> 00:29:19,919
from against one of the best solvers

758
00:29:19,919 --> 00:29:20,480
from the

759
00:29:20,480 --> 00:29:23,760
the sat competition that was the dcls

760
00:29:23,760 --> 00:29:29,039
is called this is from 2016-17

761
00:29:29,039 --> 00:29:31,679
are those tests here and we can see that

762
00:29:31,679 --> 00:29:32,960
whitman computing

763
00:29:32,960 --> 00:29:36,080
the scaling is essentially linear in

764
00:29:36,080 --> 00:29:37,440
solving those problems

765
00:29:37,440 --> 00:29:39,840
and we arrived solvencies of those

766
00:29:39,840 --> 00:29:40,960
problems

767
00:29:40,960 --> 00:29:43,679
up to 64 million variables which are

768
00:29:43,679 --> 00:29:45,279
very large circuit

769
00:29:45,279 --> 00:29:48,080
they include for this kind of tests they

770
00:29:48,080 --> 00:29:48,799
were including

771
00:29:48,799 --> 00:29:51,600
more than 300 millions gates so you can

772
00:29:51,600 --> 00:29:53,039
imagine

773
00:29:53,039 --> 00:29:56,159
and we were simulating just these in in

774
00:29:56,159 --> 00:29:56,880
software

775
00:29:56,880 --> 00:29:58,960
the dynamics of this circuit so they

776
00:29:58,960 --> 00:30:00,880
were pretty efficient in solving

777
00:30:00,880 --> 00:30:04,080
these instances of problems and also

778
00:30:04,080 --> 00:30:06,880
here just to show the simulation itself

779
00:30:06,880 --> 00:30:08,000
that does not require

780
00:30:08,000 --> 00:30:10,159
[Music]

781
00:30:10,159 --> 00:30:13,600
really a big uses of memory and so forth

782
00:30:13,600 --> 00:30:14,000
even

783
00:30:14,000 --> 00:30:16,159
the the ram that we used to to make the

784
00:30:16,159 --> 00:30:17,919
simulation of those circuits was

785
00:30:17,919 --> 00:30:20,080
really bounded just just proportional to

786
00:30:20,080 --> 00:30:21,600
the input size

787
00:30:21,600 --> 00:30:26,480
and so that that's for example

788
00:30:26,480 --> 00:30:28,799
how you can use web computing to solve

789
00:30:28,799 --> 00:30:30,640
some problems we have

790
00:30:30,640 --> 00:30:33,760
many more uh articles that are around

791
00:30:33,760 --> 00:30:34,559
that you can

792
00:30:34,559 --> 00:30:37,679
uh look on internet that shows

793
00:30:37,679 --> 00:30:40,000
other tests so for example on icing

794
00:30:40,000 --> 00:30:41,440
problems that are the ones that you

795
00:30:41,440 --> 00:30:42,559
solve usually with

796
00:30:42,559 --> 00:30:45,520
quantum computers and other sat

797
00:30:45,520 --> 00:30:46,240
instances

798
00:30:46,240 --> 00:30:49,279
just these days there is another article

799
00:30:49,279 --> 00:30:50,799
from ucsd that uh

800
00:30:50,799 --> 00:30:54,000
maxiventra tested the

801
00:30:54,000 --> 00:30:56,559
mem computing to solve uh hard distance

802
00:30:56,559 --> 00:30:57,039
of

803
00:30:57,039 --> 00:31:00,480
instances of such provinces on

804
00:31:00,480 --> 00:31:03,519
scientific report then

805
00:31:03,519 --> 00:31:08,240
just uh to give a broader

806
00:31:09,039 --> 00:31:11,360
overview of mem computing let me also

807
00:31:11,360 --> 00:31:12,399
discuss

808
00:31:12,399 --> 00:31:14,880
how you can use it to solve not just

809
00:31:14,880 --> 00:31:16,799
satisfiability problems but

810
00:31:16,799 --> 00:31:19,200
more general problems like integer

811
00:31:19,200 --> 00:31:21,519
linear programming problems

812
00:31:21,519 --> 00:31:24,080
now integer linear problem problems

813
00:31:24,080 --> 00:31:24,880
probably

814
00:31:24,880 --> 00:31:26,399
everybody knows how they are they are

815
00:31:26,399 --> 00:31:28,080
basically a collection

816
00:31:28,080 --> 00:31:31,120
of linear inequalities and you want to

817
00:31:31,120 --> 00:31:34,159
find assignments to the variables that

818
00:31:34,159 --> 00:31:37,679
variables can be continuous discrete

819
00:31:37,679 --> 00:31:41,279
binary variables that satisfy

820
00:31:41,279 --> 00:31:44,080
all these inequalities and plus you have

821
00:31:44,080 --> 00:31:46,240
usually an objective function which is

822
00:31:46,240 --> 00:31:47,440
linear

823
00:31:47,440 --> 00:31:50,720
that you want to either minimize or

824
00:31:50,720 --> 00:31:53,440
maximize how we can solve this kind of

825
00:31:53,440 --> 00:31:55,360
problems using web computing and this is

826
00:31:55,360 --> 00:31:55,679
a

827
00:31:55,679 --> 00:31:58,559
little bit more complicated because we

828
00:31:58,559 --> 00:31:59,279
should

829
00:31:59,279 --> 00:32:02,720
design gates that are no longer

830
00:32:02,720 --> 00:32:05,200
uh logic gates those are a little bit

831
00:32:05,200 --> 00:32:06,640
more complicated because

832
00:32:06,640 --> 00:32:08,880
they are what we call self-organizing

833
00:32:08,880 --> 00:32:10,080
algebraic gates

834
00:32:10,080 --> 00:32:12,640
and they are meant to solve this linear

835
00:32:12,640 --> 00:32:14,159
inequality so for each

836
00:32:14,159 --> 00:32:16,960
of these uh algebraic gate

837
00:32:16,960 --> 00:32:20,480
self-organizing algebraic gates

838
00:32:20,480 --> 00:32:22,960
we associate one of the linear

839
00:32:22,960 --> 00:32:24,159
inequalities of

840
00:32:24,159 --> 00:32:26,320
the ilp problem and so the entire

841
00:32:26,320 --> 00:32:27,200
circuit that

842
00:32:27,200 --> 00:32:28,960
is an interconnection of those gates

843
00:32:28,960 --> 00:32:31,440
will try to find an assignment to the

844
00:32:31,440 --> 00:32:32,399
variables

845
00:32:32,399 --> 00:32:35,679
that satisfy all the constraints

846
00:32:35,679 --> 00:32:38,159
at once and the idea here is very

847
00:32:38,159 --> 00:32:39,200
similar to

848
00:32:39,200 --> 00:32:41,840
self-organizing logic and in fact those

849
00:32:41,840 --> 00:32:43,679
gates are composed of

850
00:32:43,679 --> 00:32:46,320
dynamic corrective modules and they do

851
00:32:46,320 --> 00:32:47,679
the same work they will

852
00:32:47,679 --> 00:32:50,720
inject currents or in order to change

853
00:32:50,720 --> 00:32:52,880
the state of the voltages according to

854
00:32:52,880 --> 00:32:56,480
the entire states of that gate

855
00:32:56,480 --> 00:32:59,519
we have tested this on many problems

856
00:32:59,519 --> 00:33:01,039
actually

857
00:33:01,039 --> 00:33:03,760
the implementation of self-organizing

858
00:33:03,760 --> 00:33:04,320
algebra

859
00:33:04,320 --> 00:33:08,000
gates is the product of our company

860
00:33:08,000 --> 00:33:10,480
at the moment and we are using uh to

861
00:33:10,480 --> 00:33:11,440
solve

862
00:33:11,440 --> 00:33:14,159
many other optimization problems that

863
00:33:14,159 --> 00:33:16,320
the industry is facing today

864
00:33:16,320 --> 00:33:18,559
and uh unfortunately i cannot really

865
00:33:18,559 --> 00:33:19,840
share

866
00:33:19,840 --> 00:33:22,640
what we are doing with industry because

867
00:33:22,640 --> 00:33:24,000
basically all the projects that

868
00:33:24,000 --> 00:33:27,279
we have are covered by nda but i can

869
00:33:27,279 --> 00:33:30,080
uh share some public uh tests that we

870
00:33:30,080 --> 00:33:30,720
have done

871
00:33:30,720 --> 00:33:32,480
is out there for example there is a very

872
00:33:32,480 --> 00:33:34,080
famous slave library

873
00:33:34,080 --> 00:33:36,559
uh for people that deal with the integer

874
00:33:36,559 --> 00:33:38,480
linear prime which is called

875
00:33:38,480 --> 00:33:41,679
amigo this is the library that usually

876
00:33:41,679 --> 00:33:43,279
is used to test

877
00:33:43,279 --> 00:33:46,320
solvers now um there are a

878
00:33:46,320 --> 00:33:47,919
couple of articles that are out there

879
00:33:47,919 --> 00:33:50,559
that describe

880
00:33:50,880 --> 00:33:53,440
many tests that we have done or other

881
00:33:53,440 --> 00:33:54,080
people have

882
00:33:54,080 --> 00:33:56,720
done on on the meeple but there is here

883
00:33:56,720 --> 00:33:57,120
just

884
00:33:57,120 --> 00:33:59,039
want to discuss in particular one

885
00:33:59,039 --> 00:34:00,559
problem just to give you an

886
00:34:00,559 --> 00:34:03,840
idea uh uh that is f2 thousand this uh

887
00:34:03,840 --> 00:34:07,039
this problem actually is in the

888
00:34:07,039 --> 00:34:10,399
uh in this library but comes from

889
00:34:10,399 --> 00:34:13,679
the pseudo boolean competition and

890
00:34:13,679 --> 00:34:17,280
uh is essentially a sad problem okay

891
00:34:17,280 --> 00:34:18,399
that is there and

892
00:34:18,399 --> 00:34:20,560
it is very very hard has been there

893
00:34:20,560 --> 00:34:22,560
eight years nobody has been

894
00:34:22,560 --> 00:34:25,359
able to solve this problem and we were

895
00:34:25,359 --> 00:34:27,599
using just to benchmark

896
00:34:27,599 --> 00:34:30,800
our uh first release of the solver this

897
00:34:30,800 --> 00:34:31,280
is

898
00:34:31,280 --> 00:34:34,560
back in 2018 and uh

899
00:34:34,560 --> 00:34:37,119
here for example this is the old web

900
00:34:37,119 --> 00:34:38,480
page from

901
00:34:38,480 --> 00:34:40,239
from the library that says that the

902
00:34:40,239 --> 00:34:41,760
feasibility is even unknown because

903
00:34:41,760 --> 00:34:43,040
nobody was able to

904
00:34:43,040 --> 00:34:45,440
find any solution to this problem and we

905
00:34:45,440 --> 00:34:46,239
ran

906
00:34:46,239 --> 00:34:49,199
while we were benchmarking uh our system

907
00:34:49,199 --> 00:34:50,560
and we find solution

908
00:34:50,560 --> 00:34:53,040
uh within 60 seconds the first one and

909
00:34:53,040 --> 00:34:55,440
then multiple solutions just running

910
00:34:55,440 --> 00:34:58,400
longer and it was a great achievement

911
00:34:58,400 --> 00:35:00,560
for our first prototype

912
00:35:00,560 --> 00:35:03,680
of integer programming uh solver

913
00:35:03,680 --> 00:35:06,560
using them computing and in fact now on

914
00:35:06,560 --> 00:35:08,079
the website you can go and

915
00:35:08,079 --> 00:35:10,960
it reports that we have uh solved this

916
00:35:10,960 --> 00:35:11,839
problem with

917
00:35:11,839 --> 00:35:13,920
we've been the first that after eight

918
00:35:13,920 --> 00:35:16,079
years we're able to solve the

919
00:35:16,079 --> 00:35:19,760
f2 thousand and also

920
00:35:19,760 --> 00:35:23,920
another application recently

921
00:35:23,920 --> 00:35:26,400
airbus proposed a series of five

922
00:35:26,400 --> 00:35:27,839
problems that they could

923
00:35:27,839 --> 00:35:30,079
not really solve efficiently and they

924
00:35:30,079 --> 00:35:30,880
propose that

925
00:35:30,880 --> 00:35:33,200
challenge for quantum computers right

926
00:35:33,200 --> 00:35:33,920
and

927
00:35:33,920 --> 00:35:36,800
uh what we did was uh picking one of

928
00:35:36,800 --> 00:35:37,520
them

929
00:35:37,520 --> 00:35:39,920
just because we could not really

930
00:35:39,920 --> 00:35:40,640
participate

931
00:35:40,640 --> 00:35:42,880
to the challenge because what was for

932
00:35:42,880 --> 00:35:44,079
quantum computers

933
00:35:44,079 --> 00:35:47,200
and not for uh other technologies

934
00:35:47,200 --> 00:35:50,240
even if we submitted our solution but

935
00:35:50,240 --> 00:35:52,960
obviously they they didn't accept for

936
00:35:52,960 --> 00:35:54,480
the reasons i just said

937
00:35:54,480 --> 00:35:57,760
and uh one of these that we we solved

938
00:35:57,760 --> 00:35:58,640
them there is

939
00:35:58,640 --> 00:36:00,960
a paper out there that explain how to do

940
00:36:00,960 --> 00:36:02,160
is uh the

941
00:36:02,160 --> 00:36:05,680
optimization of the

942
00:36:05,680 --> 00:36:08,960
aircraft loading and so basically

943
00:36:08,960 --> 00:36:12,000
you have an aircraft and you

944
00:36:12,000 --> 00:36:15,440
have to um

945
00:36:17,520 --> 00:36:20,320
to load several different containers

946
00:36:20,320 --> 00:36:21,760
with different sizes

947
00:36:21,760 --> 00:36:25,119
and you have many different

948
00:36:25,119 --> 00:36:27,920
constraints here starting from the total

949
00:36:27,920 --> 00:36:29,680
weight total volume

950
00:36:29,680 --> 00:36:32,240
and the shear curve and the center of

951
00:36:32,240 --> 00:36:33,680
gravity and so forth

952
00:36:33,680 --> 00:36:36,880
so it's a pretty complicated problem

953
00:36:36,880 --> 00:36:40,000
and we showed how to

954
00:36:40,000 --> 00:36:43,280
um transform this problem into

955
00:36:43,280 --> 00:36:46,400
an ilp and how to run uh with the

956
00:36:46,400 --> 00:36:49,200
mem computing and here for example uh

957
00:36:49,200 --> 00:36:50,880
there is some

958
00:36:50,880 --> 00:36:53,680
tests we did that shows how you find the

959
00:36:53,680 --> 00:36:54,000
global

960
00:36:54,000 --> 00:36:57,040
optimal of this problem at scale scaling

961
00:36:57,040 --> 00:37:00,240
uh the size up to uh very large uh

962
00:37:00,240 --> 00:37:02,480
instances of the problem that is

963
00:37:02,480 --> 00:37:03,359
basically

964
00:37:03,359 --> 00:37:07,440
what they face today for the cargos

965
00:37:07,440 --> 00:37:11,040
and as a final

966
00:37:11,040 --> 00:37:13,760
application that i'm gonna very briefly

967
00:37:13,760 --> 00:37:14,800
discuss today

968
00:37:14,800 --> 00:37:16,880
is the training of neural network for

969
00:37:16,880 --> 00:37:18,240
example we've applied

970
00:37:18,240 --> 00:37:20,240
both supervised and unsupervised

971
00:37:20,240 --> 00:37:23,040
training because those are essentially

972
00:37:23,040 --> 00:37:25,440
optimization problems okay pretty hard

973
00:37:25,440 --> 00:37:27,280
to solve because they are

974
00:37:27,280 --> 00:37:30,560
non-convex and unconstrained

975
00:37:30,560 --> 00:37:32,000
optimization problems

976
00:37:32,000 --> 00:37:34,800
and for example here just to briefly

977
00:37:34,800 --> 00:37:35,359
report

978
00:37:35,359 --> 00:37:38,880
what we did with a restricted boltzmann

979
00:37:38,880 --> 00:37:39,839
machine

980
00:37:39,839 --> 00:37:42,920
and so you have uh basically a

981
00:37:42,920 --> 00:37:45,040
[Music]

982
00:37:45,040 --> 00:37:48,720
receivable machine that is a multi-layer

983
00:37:48,720 --> 00:37:52,079
and network sorry that is a multi-layer

984
00:37:52,079 --> 00:37:55,040
of uh restricted watson machines all

985
00:37:55,040 --> 00:37:55,920
stacked

986
00:37:55,920 --> 00:38:00,160
and this usually is very hard to

987
00:38:00,160 --> 00:38:03,359
train and in fact you cannot just use

988
00:38:03,359 --> 00:38:04,000
directly

989
00:38:04,000 --> 00:38:07,359
uh normal gradient descent methods or

990
00:38:07,359 --> 00:38:10,320
similar but you need uh to pre-train the

991
00:38:10,320 --> 00:38:11,200
machine

992
00:38:11,200 --> 00:38:14,240
before training it and

993
00:38:14,240 --> 00:38:16,800
usually the uh the way in which you

994
00:38:16,800 --> 00:38:18,400
pre-train it is

995
00:38:18,400 --> 00:38:20,320
using a method that is called

996
00:38:20,320 --> 00:38:22,640
contrasting the divergence

997
00:38:22,640 --> 00:38:25,920
uh now that contrast visual

998
00:38:25,920 --> 00:38:29,119
divergence is kind of efficient but

999
00:38:29,119 --> 00:38:31,280
uh really not so much in the sense that

1000
00:38:31,280 --> 00:38:33,359
it takes many many epochs

1001
00:38:33,359 --> 00:38:36,079
to make a good pre-training here is

1002
00:38:36,079 --> 00:38:37,520
there is for example

1003
00:38:37,520 --> 00:38:39,920
uh the contrastive divergence using

1004
00:38:39,920 --> 00:38:42,160
sampling that is uh the the most used

1005
00:38:42,160 --> 00:38:44,000
that and we can see that for example

1006
00:38:44,000 --> 00:38:46,000
within a 50 uh

1007
00:38:46,000 --> 00:38:49,440
pre-training iteration still our network

1008
00:38:49,440 --> 00:38:52,480
is not uh trained and

1009
00:38:52,480 --> 00:38:55,520
then lockheed martin had

1010
00:38:55,520 --> 00:38:58,720
this great idea of using a quantum

1011
00:38:58,720 --> 00:39:00,640
annealer the wave they just bought the

1012
00:39:00,640 --> 00:39:01,520
wave at the time

1013
00:39:01,520 --> 00:39:04,560
when they did this test uh and they

1014
00:39:04,560 --> 00:39:06,079
showed that you can use quantum

1015
00:39:06,079 --> 00:39:07,520
annealing

1016
00:39:07,520 --> 00:39:10,800
uh uh in order to boost uh the

1017
00:39:10,800 --> 00:39:13,359
the pre-training and how you do that you

1018
00:39:13,359 --> 00:39:14,000
basically

1019
00:39:14,000 --> 00:39:17,839
uh uh replace the contrastive divergence

1020
00:39:17,839 --> 00:39:18,400
with the

1021
00:39:18,400 --> 00:39:20,400
with the a quadratic and constrained

1022
00:39:20,400 --> 00:39:21,680
binary problem

1023
00:39:21,680 --> 00:39:25,119
and if you sample from

1024
00:39:25,119 --> 00:39:28,240
this quantum computer while he's trying

1025
00:39:28,240 --> 00:39:30,800
to solve this problem you can have

1026
00:39:30,800 --> 00:39:31,599
sampling

1027
00:39:31,599 --> 00:39:35,520
to pre-train uh the your

1028
00:39:35,520 --> 00:39:38,960
your restricted boltzmann machine and

1029
00:39:38,960 --> 00:39:42,400
since we can do roughly the same

1030
00:39:42,400 --> 00:39:44,400
with the mem computing machine so we can

1031
00:39:44,400 --> 00:39:45,520
because it's a circuit

1032
00:39:45,520 --> 00:39:47,520
you can implement this quadratic and

1033
00:39:47,520 --> 00:39:49,520
constraint binary problem on it

1034
00:39:49,520 --> 00:39:53,760
and since it solves with the dynamics

1035
00:39:53,760 --> 00:39:56,400
of the circuit you can basically do the

1036
00:39:56,400 --> 00:39:57,680
same you can sample

1037
00:39:57,680 --> 00:40:01,119
from from the the very dynamics of

1038
00:40:01,119 --> 00:40:03,359
of the mem computing which is what we

1039
00:40:03,359 --> 00:40:04,800
did and

1040
00:40:04,800 --> 00:40:08,160
the results are what are reported here

1041
00:40:08,160 --> 00:40:10,000
so we were able to

1042
00:40:10,000 --> 00:40:13,520
train at optimality the the

1043
00:40:13,520 --> 00:40:15,680
the restricted boltzmann machine even

1044
00:40:15,680 --> 00:40:17,119
slightly better than

1045
00:40:17,119 --> 00:40:21,920
than a quantum computer just because

1046
00:40:21,920 --> 00:40:25,200
it is affected by non-ideality since

1047
00:40:25,200 --> 00:40:28,319
it is a real hardware

1048
00:40:28,319 --> 00:40:32,400
and with this i finish my talk

1049
00:40:32,400 --> 00:40:34,000
and thank you for

1050
00:40:34,000 --> 00:40:35,760
[Music]

1051
00:40:35,760 --> 00:40:37,680
listening if you have any questions

1052
00:40:37,680 --> 00:40:39,839
please

1053
00:40:42,720 --> 00:40:45,680
meanwhile fabio joined us so fabio if

1054
00:40:45,680 --> 00:40:46,960
you can hear me

1055
00:40:46,960 --> 00:40:50,000
can you turn on your video yes sure

1056
00:40:50,000 --> 00:40:53,920
hi hi thank you for the talk and

1057
00:40:53,920 --> 00:40:55,680
as i said before to the other speakers

1058
00:40:55,680 --> 00:40:57,520
there is a little bit of delay

1059
00:40:57,520 --> 00:41:00,480
from the zoom call to the youtube stream

1060
00:41:00,480 --> 00:41:01,280
so we'll wait

1061
00:41:01,280 --> 00:41:02,720
about one minute to see if there are

1062
00:41:02,720 --> 00:41:05,440
questions meanwhile

1063
00:41:05,440 --> 00:41:07,680
there is uh yes there is one question

1064
00:41:07,680 --> 00:41:09,359
from emmanuel

1065
00:41:09,359 --> 00:41:12,160
that says uh for quantum computings

1066
00:41:12,160 --> 00:41:13,599
there are libraries

1067
00:41:13,599 --> 00:41:15,040
that you can use to start playing with

1068
00:41:15,040 --> 00:41:16,640
the coding paradigm

1069
00:41:16,640 --> 00:41:18,240
even though of course when you run your

1070
00:41:18,240 --> 00:41:20,800
code it's simulated on regular computers

1071
00:41:20,800 --> 00:41:22,319
is there any tool that we can use to

1072
00:41:22,319 --> 00:41:25,200
start playing with man computing

1073
00:41:25,200 --> 00:41:28,720
yes sure so as i said we have a company

1074
00:41:28,720 --> 00:41:29,520
in san diego

1075
00:41:29,520 --> 00:41:31,200
right now and what we are developing at

1076
00:41:31,200 --> 00:41:34,880
the moment is a simulator of these

1077
00:41:34,880 --> 00:41:35,599
circuits

1078
00:41:35,599 --> 00:41:37,599
uh is called the virtual main computing

1079
00:41:37,599 --> 00:41:38,800
machine just because

1080
00:41:38,800 --> 00:41:40,400
we emulate and we are not really

1081
00:41:40,400 --> 00:41:42,160
building it we we probably will start

1082
00:41:42,160 --> 00:41:43,520
building some of

1083
00:41:43,520 --> 00:41:46,319
uh those ones specific for some tasks

1084
00:41:46,319 --> 00:41:47,200
starting

1085
00:41:47,200 --> 00:41:50,319
next year and uh you can go on our

1086
00:41:50,319 --> 00:41:51,119
website

1087
00:41:51,119 --> 00:41:53,119
and register for free especially if you

1088
00:41:53,119 --> 00:41:55,200
are either a university or

1089
00:41:55,200 --> 00:41:57,599
you work with some company we can

1090
00:41:57,599 --> 00:41:59,839
provide access

1091
00:41:59,839 --> 00:42:03,839
free time that you can use to

1092
00:42:03,839 --> 00:42:06,560
start playing with non-computing uh the

1093
00:42:06,560 --> 00:42:07,040
since

1094
00:42:07,040 --> 00:42:09,520
we as i said during the talk we are

1095
00:42:09,520 --> 00:42:10,160
using

1096
00:42:10,160 --> 00:42:13,760
mostly for solving optimization problem

1097
00:42:13,760 --> 00:42:15,440
from industry

1098
00:42:15,440 --> 00:42:19,920
you can uh plug problems uh in form in

1099
00:42:19,920 --> 00:42:23,200
ilp format not in in some inside format

1100
00:42:23,200 --> 00:42:23,760
but uh

1101
00:42:23,760 --> 00:42:26,240
that's a really uh if you have a sad

1102
00:42:26,240 --> 00:42:26,960
problem

1103
00:42:26,960 --> 00:42:30,079
uh transforming uh into an ilp is

1104
00:42:30,079 --> 00:42:32,720
a trivial task so you can actually even

1105
00:42:32,720 --> 00:42:33,520
uh run

1106
00:42:33,520 --> 00:42:36,560
after uh converting uh satisfiability

1107
00:42:36,560 --> 00:42:37,440
problems uh

1108
00:42:37,440 --> 00:42:41,119
on it again that is a a an emulation of

1109
00:42:41,119 --> 00:42:44,079
those circuits so still is not uh

1110
00:42:44,079 --> 00:42:47,280
as efficient as you would have if you

1111
00:42:47,280 --> 00:42:48,079
build it

1112
00:42:48,079 --> 00:42:51,040
uh but definitely you can start playing

1113
00:42:51,040 --> 00:42:52,160
and see how

1114
00:42:52,160 --> 00:42:55,280
it reacts when you try to solve uh hard

1115
00:42:55,280 --> 00:42:57,520
combinatory problems like satisfiability

1116
00:42:57,520 --> 00:42:58,640
ones

1117
00:42:58,640 --> 00:43:01,280
okay thank you so i see that there are

1118
00:43:01,280 --> 00:43:02,240
no more questions

1119
00:43:02,240 --> 00:43:05,440
or oh sorry yes there is one question

1120
00:43:05,440 --> 00:43:06,960
what are the possible applications of

1121
00:43:06,960 --> 00:43:10,480
men computing to cyber security

1122
00:43:10,480 --> 00:43:13,680
uh yes as uh as i discussed the uh

1123
00:43:13,680 --> 00:43:17,599
since you uh can uh

1124
00:43:17,599 --> 00:43:20,240
try to uh solve satisfyability problem

1125
00:43:20,240 --> 00:43:21,200
you can use

1126
00:43:21,200 --> 00:43:24,880
to perform attacks uh and so to see if

1127
00:43:24,880 --> 00:43:29,200
i don't know trying to uh factorize uh

1128
00:43:29,200 --> 00:43:32,240
large numbers uh or uh even trying to

1129
00:43:32,240 --> 00:43:33,520
attack a

1130
00:43:33,520 --> 00:43:36,240
ash system like chaturang at the end of

1131
00:43:36,240 --> 00:43:36,800
the day

1132
00:43:36,800 --> 00:43:40,000
it's a bunch of one-way functions

1133
00:43:40,000 --> 00:43:42,960
uh all of them are boolean and uh the

1134
00:43:42,960 --> 00:43:45,280
idea is that you can for example build a

1135
00:43:45,280 --> 00:43:47,040
a circuit and try to

1136
00:43:47,040 --> 00:43:50,319
uh just uh invert uh brute force

1137
00:43:50,319 --> 00:43:52,720
uh shadow rather than trying to find all

1138
00:43:52,720 --> 00:43:54,079
combinations like

1139
00:43:54,079 --> 00:43:56,240
they do for example for mining bitcoins

1140
00:43:56,240 --> 00:43:59,119
or or uh crypto values so uh uh

1141
00:43:59,119 --> 00:44:01,440
yeah the the the the easy and straight

1142
00:44:01,440 --> 00:44:03,280
answer is that you can use basically to

1143
00:44:03,280 --> 00:44:04,560
try attacks

1144
00:44:04,560 --> 00:44:08,800
to secure assistance

1145
00:44:08,800 --> 00:44:11,520
okay thank you i have one last question

1146
00:44:11,520 --> 00:44:13,040
that may be silly

1147
00:44:13,040 --> 00:44:16,079
but uh i'll try and do you have compared

1148
00:44:16,079 --> 00:44:16,960
your uh

1149
00:44:16,960 --> 00:44:20,079
thought solving uh tools with the

1150
00:44:20,079 --> 00:44:22,720
common tools that are used in hacking or

1151
00:44:22,720 --> 00:44:25,680
ctfs like z3

1152
00:44:25,680 --> 00:44:29,280
uh no uh for many reasons

1153
00:44:29,280 --> 00:44:33,280
so the most important reason is that

1154
00:44:33,280 --> 00:44:37,040
our commercial grade solution is more

1155
00:44:37,040 --> 00:44:39,680
focused on uh optimization problems

1156
00:44:39,680 --> 00:44:40,480
because

1157
00:44:40,480 --> 00:44:42,319
obviously you know we are a startup we

1158
00:44:42,319 --> 00:44:43,920
are trying to

1159
00:44:43,920 --> 00:44:47,200
have some revenue and making a tax yes

1160
00:44:47,200 --> 00:44:48,000
you can

1161
00:44:48,000 --> 00:44:51,440
try to build the market around that but

1162
00:44:51,440 --> 00:44:53,839
really if you have something that solves

1163
00:44:53,839 --> 00:44:55,359
efficiently optimization probably

1164
00:44:55,359 --> 00:44:56,560
combinatorial problems

1165
00:44:56,560 --> 00:45:01,280
you can use uh for other more lucrative

1166
00:45:01,280 --> 00:45:03,280
applications like for example we are

1167
00:45:03,280 --> 00:45:05,680
working a lot with oil and gas

1168
00:45:05,680 --> 00:45:07,680
or with transportation logistics you can

1169
00:45:07,680 --> 00:45:09,280
imagine that this this

1170
00:45:09,280 --> 00:45:13,040
this field this they have

1171
00:45:13,040 --> 00:45:15,680
many uh hard problems that they need to

1172
00:45:15,680 --> 00:45:17,119
solve and in fact we are working with

1173
00:45:17,119 --> 00:45:17,599
them

1174
00:45:17,599 --> 00:45:20,720
and that is the the most trivial

1175
00:45:20,720 --> 00:45:24,079
uh answer uh the second reason why we

1176
00:45:24,079 --> 00:45:25,680
are not doing that at the moment because

1177
00:45:25,680 --> 00:45:26,000
we

1178
00:45:26,000 --> 00:45:28,720
really prefer working uh with

1179
00:45:28,720 --> 00:45:30,319
governments about that because you know

1180
00:45:30,319 --> 00:45:31,280
uh

1181
00:45:31,280 --> 00:45:34,560
if it is involved national security is

1182
00:45:34,560 --> 00:45:36,160
something that

1183
00:45:36,160 --> 00:45:43,279
we prefer having the government involved

