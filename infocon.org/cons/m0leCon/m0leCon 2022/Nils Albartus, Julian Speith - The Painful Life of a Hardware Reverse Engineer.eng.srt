1
00:00:01,439 --> 00:00:03,540
thanks for having us thanks for giving

2
00:00:03,540 --> 00:00:05,279
us the opportunity to talk about our

3
00:00:05,279 --> 00:00:06,720
Niche topic of Hardware reverse

4
00:00:06,720 --> 00:00:09,059
engineering here in Italy first time in

5
00:00:09,059 --> 00:00:10,980
Italy at least for me uh hopefully not

6
00:00:10,980 --> 00:00:12,599
the last one

7
00:00:12,599 --> 00:00:15,299
um so yeah let's get started we're

8
00:00:15,299 --> 00:00:17,279
actually from both from Germany so we're

9
00:00:17,279 --> 00:00:18,900
working at the Max Planck Institute for

10
00:00:18,900 --> 00:00:20,520
security and privacy which was like

11
00:00:20,520 --> 00:00:22,980
founded three years ago there is all

12
00:00:22,980 --> 00:00:24,840
other kinds of security research stuff

13
00:00:24,840 --> 00:00:26,519
in bochum like the university the

14
00:00:26,519 --> 00:00:28,800
security Institute big pile of money

15
00:00:28,800 --> 00:00:32,759
called Kaza and a startup incubator

16
00:00:32,759 --> 00:00:34,200
called Q5

17
00:00:34,200 --> 00:00:35,940
and as I said we're actually working for

18
00:00:35,940 --> 00:00:38,579
Max Planck so this is a rather new

19
00:00:38,579 --> 00:00:41,160
Institute founded in 2019 which is

20
00:00:41,160 --> 00:00:42,899
supposed to grow to 200 researchers I

21
00:00:42,899 --> 00:00:45,540
think we're at 70 to 80 right now and

22
00:00:45,540 --> 00:00:46,739
one of its missions is to do

23
00:00:46,739 --> 00:00:48,960
interdisciplinary research

24
00:00:48,960 --> 00:00:49,559
um

25
00:00:49,559 --> 00:00:50,940
so

26
00:00:50,940 --> 00:00:53,280
that's it and some acknowledgments for

27
00:00:53,280 --> 00:00:54,660
the web we are going to present like we

28
00:00:54,660 --> 00:00:56,219
have an entire soccer team on our paper

29
00:00:56,219 --> 00:00:57,899
that we've submitted on the work 11

30
00:00:57,899 --> 00:00:59,039
people

31
00:00:59,039 --> 00:01:00,899
um these are some of them some students

32
00:01:00,899 --> 00:01:04,519
other PhD students work colleagues

33
00:01:04,519 --> 00:01:06,780
and other university and Community

34
00:01:06,780 --> 00:01:08,040
people

35
00:01:08,040 --> 00:01:10,619
all right

36
00:01:10,619 --> 00:01:13,799
some background and I sadly have the uh

37
00:01:13,799 --> 00:01:16,439
the obligation to do the dry part of the

38
00:01:16,439 --> 00:01:18,060
of the presentation and Niels will do

39
00:01:18,060 --> 00:01:20,400
the fun part so I will have to give you

40
00:01:20,400 --> 00:01:21,960
some some background because I think

41
00:01:21,960 --> 00:01:23,700
like there's going to be a hard a tough

42
00:01:23,700 --> 00:01:25,799
sell on you like software people talking

43
00:01:25,799 --> 00:01:27,900
about Hardware I will need to introduce

44
00:01:27,900 --> 00:01:30,780
some some Basics I guess

45
00:01:30,780 --> 00:01:32,400
um some of you might have heard of uh

46
00:01:32,400 --> 00:01:33,960
field programmable gate arrays already

47
00:01:33,960 --> 00:01:37,020
like fpgas it's a special kind of

48
00:01:37,020 --> 00:01:38,700
Hardware so it's not like a usual

49
00:01:38,700 --> 00:01:40,320
Hardware chip that's manufactured and

50
00:01:40,320 --> 00:01:42,479
then fixed in functionality but it

51
00:01:42,479 --> 00:01:44,820
allows you to actually change the

52
00:01:44,820 --> 00:01:46,860
implementation on Hardware after

53
00:01:46,860 --> 00:01:48,600
manufacturing so there is some

54
00:01:48,600 --> 00:01:50,399
configuration file called the bitstream

55
00:01:50,399 --> 00:01:53,100
that allows you to implement arbitrary

56
00:01:53,100 --> 00:01:55,079
Logic on the device after it has been

57
00:01:55,079 --> 00:01:58,380
manufactured and some of these fpgas can

58
00:01:58,380 --> 00:02:00,180
actually be changed at runtime so the

59
00:02:00,180 --> 00:02:02,600
implementation can be swapped at runtime

60
00:02:02,600 --> 00:02:05,880
allowing for some fancy features and

61
00:02:05,880 --> 00:02:08,220
this is a really simplified view of one

62
00:02:08,220 --> 00:02:10,080
of these fdga architectures how it

63
00:02:10,080 --> 00:02:12,900
basically works that they they have like

64
00:02:12,900 --> 00:02:15,239
um we configurable logic blocks all over

65
00:02:15,239 --> 00:02:17,640
the place and they are connected by some

66
00:02:17,640 --> 00:02:20,459
weak configurable interconnect and or

67
00:02:20,459 --> 00:02:22,319
then there is some i o and all of this

68
00:02:22,319 --> 00:02:23,819
is configured by the bitstream so

69
00:02:23,819 --> 00:02:24,959
there's bits in the bitstream

70
00:02:24,959 --> 00:02:26,760
controlling what the logic blocks

71
00:02:26,760 --> 00:02:28,319
Implement and how the routing is

72
00:02:28,319 --> 00:02:31,459
implemented in the interconnect

73
00:02:31,459 --> 00:02:33,720
these devices have lots of real world

74
00:02:33,720 --> 00:02:36,780
applications because usually they are

75
00:02:36,780 --> 00:02:40,200
used for low volume Productions so for

76
00:02:40,200 --> 00:02:42,420
example if you want to do some testing

77
00:02:42,420 --> 00:02:44,819
in cars in the military if like tanks or

78
00:02:44,819 --> 00:02:46,379
fighter jets are produced couple of

79
00:02:46,379 --> 00:02:48,180
thousands of times it doesn't doesn't

80
00:02:48,180 --> 00:02:50,640
make sense to produce an actual chip in

81
00:02:50,640 --> 00:02:52,980
medical devices in space they are also

82
00:02:52,980 --> 00:02:55,800
quite quite big and in total their their

83
00:02:55,800 --> 00:02:58,019
market value is roughly like 10 billion

84
00:02:58,019 --> 00:03:01,200
dollars at least in 2020 and constantly

85
00:03:01,200 --> 00:03:04,500
Rising so they are kind of important

86
00:03:04,500 --> 00:03:06,360
um they have some advantages over Asics

87
00:03:06,360 --> 00:03:08,400
for example as I already said like the

88
00:03:08,400 --> 00:03:10,500
better cost efficiency in lower volumes

89
00:03:10,500 --> 00:03:12,420
shorter design times because you don't

90
00:03:12,420 --> 00:03:13,860
need to manufacture the chip you can

91
00:03:13,860 --> 00:03:16,140
just program the chip so you can like

92
00:03:16,140 --> 00:03:18,060
design your your Hardware implementation

93
00:03:18,060 --> 00:03:20,819
and go from there and they allow for

94
00:03:20,819 --> 00:03:22,140
more flexibility because you can

95
00:03:22,140 --> 00:03:23,819
actually reconfigure them

96
00:03:23,819 --> 00:03:26,519
they have also some disadvantages so for

97
00:03:26,519 --> 00:03:27,900
example if you put them in things that

98
00:03:27,900 --> 00:03:29,540
you produce millions of times

99
00:03:29,540 --> 00:03:31,800
they are really really cost inefficient

100
00:03:31,800 --> 00:03:33,659
because they are more expensive than

101
00:03:33,659 --> 00:03:36,780
producing dedicated dedicated chips they

102
00:03:36,780 --> 00:03:38,519
require more area on the chip they

103
00:03:38,519 --> 00:03:41,459
require more power to be to be run and

104
00:03:41,459 --> 00:03:42,959
the computations are usually kind of

105
00:03:42,959 --> 00:03:47,220
slower than on on regular A6

106
00:03:47,220 --> 00:03:49,200
and this again is like the the cost

107
00:03:49,200 --> 00:03:51,299
volume trade-off you have with Asics and

108
00:03:51,299 --> 00:03:53,159
fpgas

109
00:03:53,159 --> 00:03:54,840
okay let's talk a bit about the

110
00:03:54,840 --> 00:03:56,700
bitstream uh the bitstream is actually

111
00:03:56,700 --> 00:03:58,799
just a binary file and the ones and

112
00:03:58,799 --> 00:04:00,840
zeros in that binary file directly

113
00:04:00,840 --> 00:04:02,700
translate to transistors so to little

114
00:04:02,700 --> 00:04:05,519
switches on the on the fpga that turn on

115
00:04:05,519 --> 00:04:07,620
and off different things

116
00:04:07,620 --> 00:04:09,360
um so there is a header as with most

117
00:04:09,360 --> 00:04:11,939
files and then there is a so-called sync

118
00:04:11,939 --> 00:04:14,159
word and after that sync word the entire

119
00:04:14,159 --> 00:04:16,199
or the the fpga configuration starts

120
00:04:16,199 --> 00:04:17,940
that is actually configuring the device

121
00:04:17,940 --> 00:04:19,620
actually configuring the logic blocks

122
00:04:19,620 --> 00:04:21,540
and the interconnect

123
00:04:21,540 --> 00:04:23,160
okay

124
00:04:23,160 --> 00:04:25,020
netlist is another term that we might

125
00:04:25,020 --> 00:04:27,120
need to introduce Netflix is basically

126
00:04:27,120 --> 00:04:28,800
just a circuit representation of what's

127
00:04:28,800 --> 00:04:31,259
implemented on the device and usually if

128
00:04:31,259 --> 00:04:32,759
you if you hear about that what you

129
00:04:32,759 --> 00:04:34,139
probably think about is okay it looks

130
00:04:34,139 --> 00:04:35,460
like this so the net list there's some

131
00:04:35,460 --> 00:04:37,860
CPU some as some communication whatever

132
00:04:37,860 --> 00:04:39,720
and you can clearly distinguish between

133
00:04:39,720 --> 00:04:42,660
them nope sadly it usually looks like

134
00:04:42,660 --> 00:04:44,880
this it's a huge mess of interconnected

135
00:04:44,880 --> 00:04:47,400
logic gates that do not make sense just

136
00:04:47,400 --> 00:04:49,680
by looking at them

137
00:04:49,680 --> 00:04:50,340
um

138
00:04:50,340 --> 00:04:52,320
and

139
00:04:52,320 --> 00:04:55,320
of course like if you want to if you do

140
00:04:55,320 --> 00:04:57,060
want a hard reverse engineering or why

141
00:04:57,060 --> 00:04:58,740
would you do or why would you want to do

142
00:04:58,740 --> 00:05:00,540
Hardware reverse engineering

143
00:05:00,540 --> 00:05:02,580
um there's different different purposes

144
00:05:02,580 --> 00:05:04,680
there's some legitimate ones for example

145
00:05:04,680 --> 00:05:06,540
for testing and the detection of

146
00:05:06,540 --> 00:05:09,360
malicious manipulations usually Hardware

147
00:05:09,360 --> 00:05:11,280
is not manufactured and designed at the

148
00:05:11,280 --> 00:05:13,020
same place some people design Hardware

149
00:05:13,020 --> 00:05:14,759
send it over to Asia where it's going to

150
00:05:14,759 --> 00:05:17,460
be manufactured and then that's going to

151
00:05:17,460 --> 00:05:19,080
be sent back so you want to probably

152
00:05:19,080 --> 00:05:21,919
detect manipulations if those happened

153
00:05:21,919 --> 00:05:24,479
you want to prove IP infringement if

154
00:05:24,479 --> 00:05:26,280
other companies ripped off your IP and

155
00:05:26,280 --> 00:05:28,259
you might want to do security analysis

156
00:05:28,259 --> 00:05:29,940
but there's also illegitimate

157
00:05:29,940 --> 00:05:32,100
applications for example like the exact

158
00:05:32,100 --> 00:05:34,979
opposite of the of the legislative ones

159
00:05:34,979 --> 00:05:37,940
committing IP theft design plugin

160
00:05:37,940 --> 00:05:39,740
plagiarism

161
00:05:39,740 --> 00:05:42,419
and for example finding insertion points

162
00:05:42,419 --> 00:05:44,460
for Hardware Trojans that can also be

163
00:05:44,460 --> 00:05:46,199
done using Hardware reverse engineering

164
00:05:46,199 --> 00:05:48,900
so brief overview of what Hardware

165
00:05:48,900 --> 00:05:51,419
reverse engineering actually entails

166
00:05:51,419 --> 00:05:53,160
um again differentiating between the

167
00:05:53,160 --> 00:05:55,080
Asics like the real chips manufactured

168
00:05:55,080 --> 00:05:57,240
and the fpgas that can just be

169
00:05:57,240 --> 00:05:59,280
configured starting with the real ones

170
00:05:59,280 --> 00:06:01,440
you usually have the chip in the like

171
00:06:01,440 --> 00:06:03,300
like package with the pins coming out

172
00:06:03,300 --> 00:06:05,400
you first need to take off the package

173
00:06:05,400 --> 00:06:07,139
so you need to get to the actual die

174
00:06:07,139 --> 00:06:09,240
that implements the logic once you have

175
00:06:09,240 --> 00:06:10,979
the die that usually consists of

176
00:06:10,979 --> 00:06:13,199
different layers with the transistors at

177
00:06:13,199 --> 00:06:15,120
the bottom and then lots of interconnect

178
00:06:15,120 --> 00:06:18,419
layers on top uh so sadly you need to

179
00:06:18,419 --> 00:06:19,740
look at all the layers to actually

180
00:06:19,740 --> 00:06:22,139
understand what the chip is doing

181
00:06:22,139 --> 00:06:24,720
um so you need to do delayering like

182
00:06:24,720 --> 00:06:26,880
um grind down layer by layer and then

183
00:06:26,880 --> 00:06:29,580
take pictures of every layer you need to

184
00:06:29,580 --> 00:06:31,560
process all these images stitch them

185
00:06:31,560 --> 00:06:33,780
together stack them so that you have a

186
00:06:33,780 --> 00:06:36,780
3D model of the of the actual chip and

187
00:06:36,780 --> 00:06:38,400
once you have done the image processing

188
00:06:38,400 --> 00:06:40,080
you get out like you receive the net

189
00:06:40,080 --> 00:06:41,039
list

190
00:06:41,039 --> 00:06:43,319
and then this is usually where we come

191
00:06:43,319 --> 00:06:44,759
in like we do netlist and that list

192
00:06:44,759 --> 00:06:46,919
netlist analysis

193
00:06:46,919 --> 00:06:47,520
um

194
00:06:47,520 --> 00:06:49,500
because all the stuff up there that you

195
00:06:49,500 --> 00:06:51,539
see usually requires equipment in the

196
00:06:51,539 --> 00:06:53,699
millions and we don't have that and we

197
00:06:53,699 --> 00:06:55,680
don't know how to use it so we usually

198
00:06:55,680 --> 00:06:58,160
expect the netlist to be there already

199
00:06:58,160 --> 00:07:01,139
for fpgas it's a bit like easier because

200
00:07:01,139 --> 00:07:02,639
as I said you just need that

201
00:07:02,639 --> 00:07:04,620
configuration file called the bitstream

202
00:07:04,620 --> 00:07:06,660
so you need to get that configuration

203
00:07:06,660 --> 00:07:09,419
file of the fpga or of the

204
00:07:09,419 --> 00:07:12,539
from firmware error and then you can try

205
00:07:12,539 --> 00:07:13,740
to understand the format of the

206
00:07:13,740 --> 00:07:16,080
bitstream reverse engineer the bitstream

207
00:07:16,080 --> 00:07:17,639
format and convert the bitstream to an

208
00:07:17,639 --> 00:07:19,740
actual netlist because a bit stream is

209
00:07:19,740 --> 00:07:21,860
nothing but like a proprietary

210
00:07:21,860 --> 00:07:24,720
representation of the actual netlist so

211
00:07:24,720 --> 00:07:26,460
if you find out what bit does what on

212
00:07:26,460 --> 00:07:28,500
the fpga you can actually translate it

213
00:07:28,500 --> 00:07:30,960
back into a netlist representation

214
00:07:30,960 --> 00:07:32,940
all right so most of you are probably

215
00:07:32,940 --> 00:07:33,900
familiar with software versus

216
00:07:33,900 --> 00:07:36,419
engineering so software reverse

217
00:07:36,419 --> 00:07:37,979
engineering has a quite active Community

218
00:07:37,979 --> 00:07:41,520
as you see here in industry in Academia

219
00:07:41,520 --> 00:07:44,220
and there's lots of tools like guidera

220
00:07:44,220 --> 00:07:47,099
and Ida Pro they are Advanced Frameworks

221
00:07:47,099 --> 00:07:48,840
of binary analysis they allow for

222
00:07:48,840 --> 00:07:51,360
plugins to be loaded into the into the

223
00:07:51,360 --> 00:07:53,520
actual Frameworks there's open source

224
00:07:53,520 --> 00:07:56,099
tools like like Jada again

225
00:07:56,099 --> 00:07:58,319
but the situation for Hardware reverse

226
00:07:58,319 --> 00:08:00,060
engineering is kind of different because

227
00:08:00,060 --> 00:08:02,160
there is nothing out there there is no

228
00:08:02,160 --> 00:08:04,080
no tool that you could actually use for

229
00:08:04,080 --> 00:08:07,139
this netlist analysis part uh so like

230
00:08:07,139 --> 00:08:09,060
six or seven years ago our group set out

231
00:08:09,060 --> 00:08:11,160
uh the challenge of like developing one

232
00:08:11,160 --> 00:08:13,199
of these tools because in the hardware

233
00:08:13,199 --> 00:08:14,520
world if you if you want to do something

234
00:08:14,520 --> 00:08:17,220
you need to do it yourself usually

235
00:08:17,220 --> 00:08:19,139
um so that's when we started creating

236
00:08:19,139 --> 00:08:22,319
how our netlist uh analysis framework

237
00:08:22,319 --> 00:08:25,379
within in modern C plus plus and it also

238
00:08:25,379 --> 00:08:28,800
also allows for for plugins and stuff

239
00:08:28,800 --> 00:08:31,080
um so nowadays we have this fancy

240
00:08:31,080 --> 00:08:32,880
software and it doesn't crash as often

241
00:08:32,880 --> 00:08:34,799
as it used to in the back in the days so

242
00:08:34,799 --> 00:08:36,059
we actually want to make some use out of

243
00:08:36,059 --> 00:08:37,320
it

244
00:08:37,320 --> 00:08:39,360
um so we set out and look for like

245
00:08:39,360 --> 00:08:40,919
targets real world targets that we could

246
00:08:40,919 --> 00:08:41,659
Target

247
00:08:41,659 --> 00:08:44,399
because we wanted to do like some some

248
00:08:44,399 --> 00:08:46,260
cool real world case studies with all

249
00:08:46,260 --> 00:08:48,300
the work we have done so far

250
00:08:48,300 --> 00:08:49,800
and that's how we ended up on Reddit

251
00:08:49,800 --> 00:08:51,180
because if you don't know what to do

252
00:08:51,180 --> 00:08:53,100
like us people on Reddit

253
00:08:53,100 --> 00:08:55,380
um and we actually posted on Reddit and

254
00:08:55,380 --> 00:08:56,940
asked for people like whether they know

255
00:08:56,940 --> 00:09:00,779
devices that feature actual fpga that

256
00:09:00,779 --> 00:09:02,580
have like cool purposes

257
00:09:02,580 --> 00:09:04,920
because usually like you've seen all the

258
00:09:04,920 --> 00:09:06,839
applications military space and stuff

259
00:09:06,839 --> 00:09:09,180
it's hard to get these fpgas out of a

260
00:09:09,180 --> 00:09:10,740
rocket and it's hard to convince

261
00:09:10,740 --> 00:09:13,019
companies to give you those chips if you

262
00:09:13,019 --> 00:09:14,459
just tell them yeah I wanna I wanna

263
00:09:14,459 --> 00:09:17,220
attack them so we needed to find like

264
00:09:17,220 --> 00:09:19,560
consumer products that feature fpgas

265
00:09:19,560 --> 00:09:21,839
to actually Target and reverse engineer

266
00:09:21,839 --> 00:09:22,620
them

267
00:09:22,620 --> 00:09:24,959
first thing that came up is this Chinese

268
00:09:24,959 --> 00:09:27,920
intelligence asking

269
00:09:28,680 --> 00:09:31,080
so after a while after like we we

270
00:09:31,080 --> 00:09:32,880
actually

271
00:09:32,880 --> 00:09:34,620
um told them our affiliation and stuff

272
00:09:34,620 --> 00:09:36,360
we actually ended up with a good tip

273
00:09:36,360 --> 00:09:38,700
like the iPhone 7 and 7 plus actually

274
00:09:38,700 --> 00:09:41,519
they feature lettuce fpga for whatever

275
00:09:41,519 --> 00:09:43,440
reason because it's it's like a device

276
00:09:43,440 --> 00:09:45,360
sold in the millions so fpga in there

277
00:09:45,360 --> 00:09:47,339
makes no sense

278
00:09:47,339 --> 00:09:49,080
um but still there was that one iPhone

279
00:09:49,080 --> 00:09:52,440
back in 2016 I guess that featured the

280
00:09:52,440 --> 00:09:54,839
fpga

281
00:09:54,839 --> 00:09:57,899
um so yeah 2016 it's the latest ice40

282
00:09:57,899 --> 00:10:00,420
Ultra fpga world's most powerful low

283
00:10:00,420 --> 00:10:02,760
power fpga

284
00:10:02,760 --> 00:10:04,920
um and of course we asked ourselves okay

285
00:10:04,920 --> 00:10:06,240
why would you do that why would you put

286
00:10:06,240 --> 00:10:08,399
an fpga in there it cost like three to

287
00:10:08,399 --> 00:10:10,980
four bucks per per chip if you

288
00:10:10,980 --> 00:10:13,680
manufacture A6 in that quantity

289
00:10:13,680 --> 00:10:16,140
especially those Asics or an Asic but

290
00:10:16,140 --> 00:10:17,700
that functionality it would be in the

291
00:10:17,700 --> 00:10:20,640
lower send uh that would cost in the

292
00:10:20,640 --> 00:10:22,380
lower sense area

293
00:10:22,380 --> 00:10:24,200
um

294
00:10:24,200 --> 00:10:27,540
therefore would be much cheaper one note

295
00:10:27,540 --> 00:10:29,100
here Apple refers to that chip

296
00:10:29,100 --> 00:10:31,260
internally as Maggie and Maggie talks to

297
00:10:31,260 --> 00:10:33,180
homer which is another like arm-based

298
00:10:33,180 --> 00:10:36,660
CPU so like The Simpsons obviously we

299
00:10:36,660 --> 00:10:38,459
are going to use the term Maggie

300
00:10:38,459 --> 00:10:40,440
throughout our talk at some point but

301
00:10:40,440 --> 00:10:42,540
Maggie just refers to the fpga Chip And

302
00:10:42,540 --> 00:10:43,920
The implementation

303
00:10:43,920 --> 00:10:46,440
all right then after after getting that

304
00:10:46,440 --> 00:10:47,940
hint we found some newspaper articles

305
00:10:47,940 --> 00:10:49,680
where people already wondered about what

306
00:10:49,680 --> 00:10:52,500
this chip might do some like suggested

307
00:10:52,500 --> 00:10:54,420
it would do encryption others were more

308
00:10:54,420 --> 00:10:56,399
in favor of machine learning stuff and

309
00:10:56,399 --> 00:10:59,640
artificial intelligence so

310
00:10:59,640 --> 00:11:01,800
that sounded interesting targeted quiet

311
00:11:01,800 --> 00:11:04,940
let's dive into Maggie's functionality

312
00:11:04,940 --> 00:11:09,660
and just like a small spoiler our work

313
00:11:09,660 --> 00:11:11,820
tries to take like three three research

314
00:11:11,820 --> 00:11:14,279
questions first of all is have a reverse

315
00:11:14,279 --> 00:11:15,779
engineering of a real world fpga

316
00:11:15,779 --> 00:11:17,880
implementation actually a realistic

317
00:11:17,880 --> 00:11:19,500
threat because no one has ever done that

318
00:11:19,500 --> 00:11:22,560
before publicly on that scale

319
00:11:22,560 --> 00:11:24,779
um whatever it is required to do so like

320
00:11:24,779 --> 00:11:26,640
to perform such a reverse engineering

321
00:11:26,640 --> 00:11:29,339
tag and do we need to develop new

322
00:11:29,339 --> 00:11:30,779
approaches or can we just take stuff

323
00:11:30,779 --> 00:11:33,720
from literature and execute what we have

324
00:11:33,720 --> 00:11:36,540
spoiler alert uh we only discovered what

325
00:11:36,540 --> 00:11:38,760
the makes the Iphone vibrate there is no

326
00:11:38,760 --> 00:11:40,500
security implications here apart from

327
00:11:40,500 --> 00:11:42,600
the IP theft thing

328
00:11:42,600 --> 00:11:43,260
um

329
00:11:43,260 --> 00:11:44,940
and this technique is going to be

330
00:11:44,940 --> 00:11:46,620
primarily about the techniques we use to

331
00:11:46,620 --> 00:11:47,940
perform the hardware versus engineering

332
00:11:47,940 --> 00:11:49,980
not so much about the outcome because

333
00:11:49,980 --> 00:11:51,959
the outcome is some signal processing

334
00:11:51,959 --> 00:11:53,339
stuff and I don't want to bore you with

335
00:11:53,339 --> 00:11:54,380
that

336
00:11:54,380 --> 00:11:57,779
so but the techniques are kind of cool

337
00:11:57,779 --> 00:11:59,399
um and this is for kind of structuring

338
00:11:59,399 --> 00:12:01,800
of the talk we in the paper we submitted

339
00:12:01,800 --> 00:12:03,240
we

340
00:12:03,240 --> 00:12:05,100
split the entire process of Hardware

341
00:12:05,100 --> 00:12:06,480
reverse engineering into three parts

342
00:12:06,480 --> 00:12:08,339
first would be net this recovery so we

343
00:12:08,339 --> 00:12:10,019
have that bit stream and we need to get

344
00:12:10,019 --> 00:12:11,399
to some high level representation like

345
00:12:11,399 --> 00:12:13,079
the net list

346
00:12:13,079 --> 00:12:15,240
um so phase one is netlist recovery

347
00:12:15,240 --> 00:12:18,060
phase two is uh kind of structuring the

348
00:12:18,060 --> 00:12:19,800
net list because the net list is really

349
00:12:19,800 --> 00:12:22,200
just a big sea of gates with and gate

350
00:12:22,200 --> 00:12:24,720
flip-flops or Gates whatever and they

351
00:12:24,720 --> 00:12:26,579
don't make any sense to you at all at

352
00:12:26,579 --> 00:12:28,800
this point so you try to find like red

353
00:12:28,800 --> 00:12:31,160
level structures registers whatever

354
00:12:31,160 --> 00:12:33,300
and phase three would be the high level

355
00:12:33,300 --> 00:12:35,640
understanding so making sense out of all

356
00:12:35,640 --> 00:12:37,560
the like Word level structures for

357
00:12:37,560 --> 00:12:39,480
example that is discovered and finding

358
00:12:39,480 --> 00:12:41,700
out what the chip is actually doing to

359
00:12:41,700 --> 00:12:43,560
in this case basically rip off the

360
00:12:43,560 --> 00:12:44,760
functionality

361
00:12:44,760 --> 00:12:46,860
all right let's start with the Phase One

362
00:12:46,860 --> 00:12:48,600
netlist recovery

363
00:12:48,600 --> 00:12:50,160
first thing is you need to get the bit

364
00:12:50,160 --> 00:12:52,200
streams from somewhere so usually

365
00:12:52,200 --> 00:12:54,720
because fpgas are or at least these

366
00:12:54,720 --> 00:12:57,420
sram-based fpgas they cannot hold their

367
00:12:57,420 --> 00:12:59,639
bitstream permanently so when you turn

368
00:12:59,639 --> 00:13:01,620
them off the bitstream is like it's

369
00:13:01,620 --> 00:13:03,660
flushed from the from the fpga it's not

370
00:13:03,660 --> 00:13:05,760
on the fpga anymore so they are stored

371
00:13:05,760 --> 00:13:06,839
externally

372
00:13:06,839 --> 00:13:08,639
so there's different options in this

373
00:13:08,639 --> 00:13:11,459
case we were lucky

374
00:13:11,459 --> 00:13:13,579
um

375
00:13:13,980 --> 00:13:16,019
we were lucky that the bitstream is

376
00:13:16,019 --> 00:13:17,940
actually in the iPhone firmware so

377
00:13:17,940 --> 00:13:19,019
whenever you download the iPhone

378
00:13:19,019 --> 00:13:20,399
firmware the bit stream is going to be

379
00:13:20,399 --> 00:13:24,060
part of it and it's in like an IPS ipsw

380
00:13:24,060 --> 00:13:26,040
package which is basically like a zip

381
00:13:26,040 --> 00:13:27,660
container

382
00:13:27,660 --> 00:13:28,560
um

383
00:13:28,560 --> 00:13:31,440
and there is a root folder in that

384
00:13:31,440 --> 00:13:33,240
VMware that contains all the Frameworks

385
00:13:33,240 --> 00:13:34,920
for different components of the of the

386
00:13:34,920 --> 00:13:38,220
iPhone including the bitstream and you

387
00:13:38,220 --> 00:13:39,540
can actually see the bit stream down

388
00:13:39,540 --> 00:13:42,480
here in that in that um

389
00:13:42,480 --> 00:13:44,639
in that container

390
00:13:44,639 --> 00:13:47,279
um and what we've seen once we looked at

391
00:13:47,279 --> 00:13:51,000
a couple of of iOS versions is that they

392
00:13:51,000 --> 00:13:52,380
actually on the release of the iPhone

393
00:13:52,380 --> 00:13:55,139
iPhone 7 there was one version of the

394
00:13:55,139 --> 00:13:56,880
bit stream in a couple of months later I

395
00:13:56,880 --> 00:13:58,560
think about three months later they

396
00:13:58,560 --> 00:14:00,720
actually updated the bitstream which is

397
00:14:00,720 --> 00:14:03,120
one of the advantages of fpgas you can

398
00:14:03,120 --> 00:14:05,339
actually update them after the effect so

399
00:14:05,339 --> 00:14:06,779
once you've shipped the iPhones you can

400
00:14:06,779 --> 00:14:08,459
still

401
00:14:08,459 --> 00:14:10,680
change functionality in some way or fix

402
00:14:10,680 --> 00:14:12,959
bugs and this is also one of the things

403
00:14:12,959 --> 00:14:14,639
we we assumed here that Apple has

404
00:14:14,639 --> 00:14:16,380
probably was probably not ready to

405
00:14:16,380 --> 00:14:18,899
release this this chip yet and that's

406
00:14:18,899 --> 00:14:20,940
why they use an fpga to be able to after

407
00:14:20,940 --> 00:14:23,399
afterwards update their the bugs they

408
00:14:23,399 --> 00:14:25,139
have still in the they still have in

409
00:14:25,139 --> 00:14:27,600
their design kinda

410
00:14:27,600 --> 00:14:28,860
all right

411
00:14:28,860 --> 00:14:31,440
again this allows for Hardware changes

412
00:14:31,440 --> 00:14:33,540
via software updates which is kind of

413
00:14:33,540 --> 00:14:34,800
cool

414
00:14:34,800 --> 00:14:35,399
um

415
00:14:35,399 --> 00:14:38,100
and how you would go or if you want to

416
00:14:38,100 --> 00:14:40,260
reverse engineer the bitstream there is

417
00:14:40,260 --> 00:14:42,180
some dedicated process that you would

418
00:14:42,180 --> 00:14:43,440
follow

419
00:14:43,440 --> 00:14:45,420
um so first of all I mean you need to

420
00:14:45,420 --> 00:14:46,800
understand the format of that bitstream

421
00:14:46,800 --> 00:14:48,480
there is two ways to do that you can

422
00:14:48,480 --> 00:14:51,360
either Target the the design tool that

423
00:14:51,360 --> 00:14:52,980
generated the bit stream and find like

424
00:14:52,980 --> 00:14:54,779
databases that do the bit mapping and

425
00:14:54,779 --> 00:14:56,760
stuff but then it's hard to publish

426
00:14:56,760 --> 00:14:59,160
because you have like broken various

427
00:14:59,160 --> 00:15:01,079
license agreements

428
00:15:01,079 --> 00:15:03,839
um so we cannot really do that and what

429
00:15:03,839 --> 00:15:05,399
is usually being done by some other open

430
00:15:05,399 --> 00:15:07,320
source projects as well is just to

431
00:15:07,320 --> 00:15:08,820
generate lots of bit streams and then

432
00:15:08,820 --> 00:15:10,320
try to find what find out what bit

433
00:15:10,320 --> 00:15:12,660
collides to what functionality in this

434
00:15:12,660 --> 00:15:14,100
case you start with an empty bit stream

435
00:15:14,100 --> 00:15:16,620
then you start instantiating some of the

436
00:15:16,620 --> 00:15:19,320
logic gates within your designs and you

437
00:15:19,320 --> 00:15:21,300
just observe after feeding it through

438
00:15:21,300 --> 00:15:23,399
the Ada tools what changes in your

439
00:15:23,399 --> 00:15:24,959
bitstream and then you build up a big

440
00:15:24,959 --> 00:15:27,959
database with all the correlations

441
00:15:27,959 --> 00:15:30,420
between the designs you you've

442
00:15:30,420 --> 00:15:32,100
implemented and the between bits that

443
00:15:32,100 --> 00:15:33,240
have been set

444
00:15:33,240 --> 00:15:36,180
and this is usually how you get like or

445
00:15:36,180 --> 00:15:38,519
how you deduct like the the bits to

446
00:15:38,519 --> 00:15:39,779
inform it

447
00:15:39,779 --> 00:15:42,540
um through lots and lots of Works

448
00:15:42,540 --> 00:15:45,180
basically by fuzzers who fast the design

449
00:15:45,180 --> 00:15:47,940
tools uh with various obvious different

450
00:15:47,940 --> 00:15:49,920
design variations

451
00:15:49,920 --> 00:15:52,620
okay luckily we didn't really have to do

452
00:15:52,620 --> 00:15:54,500
this because someone else already did it

453
00:15:54,500 --> 00:15:56,880
there is a project called project ice

454
00:15:56,880 --> 00:15:58,920
storm out there which is basically an

455
00:15:58,920 --> 00:16:00,180
open source bitstream documentation

456
00:16:00,180 --> 00:16:02,519
project their original goal is to

457
00:16:02,519 --> 00:16:05,100
facilitate open source design tools so

458
00:16:05,100 --> 00:16:07,620
they want to be independent of the

459
00:16:07,620 --> 00:16:09,000
design tools of the hardware vendors

460
00:16:09,000 --> 00:16:10,680
because you usually don't don't know

461
00:16:10,680 --> 00:16:12,060
what they are doing in the back end you

462
00:16:12,060 --> 00:16:15,000
have no idea how to like inspect whether

463
00:16:15,000 --> 00:16:16,800
they are actually properly working or

464
00:16:16,800 --> 00:16:19,199
whether they introduce any any big doors

465
00:16:19,199 --> 00:16:21,839
any bugs or whatever so they want to

466
00:16:21,839 --> 00:16:23,940
have independent open source tool flows

467
00:16:23,940 --> 00:16:25,380
for all of this and of course if you

468
00:16:25,380 --> 00:16:27,300
want to go from your Hardware design to

469
00:16:27,300 --> 00:16:29,040
the bitstream you need to understand the

470
00:16:29,040 --> 00:16:31,260
bitstream format to do exactly that to

471
00:16:31,260 --> 00:16:33,060
open source or to create open source

472
00:16:33,060 --> 00:16:33,959
tooling

473
00:16:33,959 --> 00:16:37,800
so we kind of abuse the database

474
00:16:37,800 --> 00:16:40,920
and but the problem was that our exact

475
00:16:40,920 --> 00:16:43,800
fpga was not really supported but

476
00:16:43,800 --> 00:16:45,120
luckily it had a very similar

477
00:16:45,120 --> 00:16:46,680
architecture so we don't didn't have to

478
00:16:46,680 --> 00:16:48,779
do like lots of fuzzing again it was all

479
00:16:48,779 --> 00:16:50,339
there for us just some tweaks to the

480
00:16:50,339 --> 00:16:52,800
database and we were ready to go

481
00:16:52,800 --> 00:16:55,019
um the big problem was that as I said it

482
00:16:55,019 --> 00:16:56,579
was not created for the bitstream to

483
00:16:56,579 --> 00:16:57,779
netlist part not for the netlist

484
00:16:57,779 --> 00:16:59,420
recovery part

485
00:16:59,420 --> 00:17:02,279
there was no tooling to convert like our

486
00:17:02,279 --> 00:17:04,260
bitstream back to a net list so we had

487
00:17:04,260 --> 00:17:06,240
to adapt some existing tooling to

488
00:17:06,240 --> 00:17:09,000
actually do that but there was also like

489
00:17:09,000 --> 00:17:10,740
a piece of cake but it was kind of easy

490
00:17:10,740 --> 00:17:12,859
compared to what followed

491
00:17:12,859 --> 00:17:15,119
so what you would do here is you feed

492
00:17:15,119 --> 00:17:16,380
your bitstream into your bitstream

493
00:17:16,380 --> 00:17:18,299
conversion tool of course and out comes

494
00:17:18,299 --> 00:17:20,520
the net list again netlist just being

495
00:17:20,520 --> 00:17:23,160
connected Gates interconnected Gates

496
00:17:23,160 --> 00:17:24,780
okay

497
00:17:24,780 --> 00:17:26,720
let's see whether this works

498
00:17:26,720 --> 00:17:30,360
I've actually prepared a wonderful small

499
00:17:30,360 --> 00:17:32,460
live demo of the actual netlist that we

500
00:17:32,460 --> 00:17:35,780
extracted so now we are we have we have

501
00:17:35,780 --> 00:17:37,440
accomplished like the necklace

502
00:17:37,440 --> 00:17:38,640
extraction we have converted the

503
00:17:38,640 --> 00:17:40,799
bitstream to a net list and this is what

504
00:17:40,799 --> 00:17:42,780
it actually looks like in our tool and

505
00:17:42,780 --> 00:17:45,360
as you can see it's quite huge and if

506
00:17:45,360 --> 00:17:47,580
you just look at it there is no way to

507
00:17:47,580 --> 00:17:50,100
find out what's going on uh so you need

508
00:17:50,100 --> 00:17:53,780
really need to automate this process

509
00:18:00,720 --> 00:18:03,240
so like within our tool you have like

510
00:18:03,240 --> 00:18:04,620
you see down here that you can get

511
00:18:04,620 --> 00:18:07,020
information of all kinds of stuff

512
00:18:07,020 --> 00:18:08,820
um there is the different net the

513
00:18:08,820 --> 00:18:10,679
different Gates uh you can actually

514
00:18:10,679 --> 00:18:12,600
interact with the entire thing we are

515
00:18:12,600 --> 00:18:14,220
python so we have python bindings for

516
00:18:14,220 --> 00:18:16,679
most of our API

517
00:18:16,679 --> 00:18:18,960
um and you can do like you can actually

518
00:18:18,960 --> 00:18:21,179
automate via VIA python script or also

519
00:18:21,179 --> 00:18:22,919
via C plus plus plugins you can actually

520
00:18:22,919 --> 00:18:24,900
automate the entire reverse engineering

521
00:18:24,900 --> 00:18:27,900
flow so our usual approach would be to

522
00:18:27,900 --> 00:18:29,640
look at stuff find out whether there's

523
00:18:29,640 --> 00:18:31,740
patterns patterns or anything

524
00:18:31,740 --> 00:18:33,419
interesting and then automate detection

525
00:18:33,419 --> 00:18:35,460
for that kind of stuff

526
00:18:35,460 --> 00:18:36,059
um

527
00:18:36,059 --> 00:18:37,740
and

528
00:18:37,740 --> 00:18:39,720
as you're seeing like this is kind of

529
00:18:39,720 --> 00:18:42,740
messy so if you wanna

530
00:18:43,440 --> 00:18:45,240
if you want to do like some more useful

531
00:18:45,240 --> 00:18:47,220
exploration of the netlist you can also

532
00:18:47,220 --> 00:18:50,220
just by unfolding it

533
00:18:50,220 --> 00:18:52,559
like this for example there is there's

534
00:18:52,559 --> 00:18:55,500
easy ways to or easier ways to to

535
00:18:55,500 --> 00:18:57,720
actually achieve some understanding of

536
00:18:57,720 --> 00:19:00,179
the net list either manually or using

537
00:19:00,179 --> 00:19:01,200
automation

538
00:19:01,200 --> 00:19:02,880
anything I should add on the demo no

539
00:19:02,880 --> 00:19:06,179
okay wonderful then let's go back to the

540
00:19:06,179 --> 00:19:08,460
presentation

541
00:19:08,460 --> 00:19:10,380
um so phase one is basically completed

542
00:19:10,380 --> 00:19:12,660
we have the net list now but now we need

543
00:19:12,660 --> 00:19:14,640
to do some prep or some pre-processing

544
00:19:14,640 --> 00:19:16,860
to actually detect structures that we

545
00:19:16,860 --> 00:19:19,260
can make sense of later on

546
00:19:19,260 --> 00:19:21,480
um starting point is a netlist we've

547
00:19:21,480 --> 00:19:23,460
just seen no labels no Hardware Key no

548
00:19:23,460 --> 00:19:25,320
comments no nothing because it just

549
00:19:25,320 --> 00:19:26,880
comes out of the bits of the bitstream

550
00:19:26,880 --> 00:19:29,520
and it obviously doesn't store comments

551
00:19:29,520 --> 00:19:30,120
um

552
00:19:30,120 --> 00:19:32,160
so and what we want to achieve is a

553
00:19:32,160 --> 00:19:35,520
partially modulized uh net list with

554
00:19:35,520 --> 00:19:37,020
annotated bit order information and

555
00:19:37,020 --> 00:19:38,880
you'll see why that is important and

556
00:19:38,880 --> 00:19:41,520
what that actually means in a bit

557
00:19:41,520 --> 00:19:42,960
um there's three stages the first one

558
00:19:42,960 --> 00:19:44,580
we're gonna omit here because that's

559
00:19:44,580 --> 00:19:46,799
kind of fpga specific

560
00:19:46,799 --> 00:19:48,840
um then we have the word level structure

561
00:19:48,840 --> 00:19:50,820
detection where we actually try to get

562
00:19:50,820 --> 00:19:52,559
like the flip flops so the storage

563
00:19:52,559 --> 00:19:55,200
Elements which each store one bit to

564
00:19:55,200 --> 00:19:58,500
organize them in registers of 16 32 bits

565
00:19:58,500 --> 00:19:59,640
whatever

566
00:19:59,640 --> 00:20:01,140
um we have some bigger Max structures

567
00:20:01,140 --> 00:20:03,600
which are basically if branches kinda so

568
00:20:03,600 --> 00:20:05,580
we want to detect those in like also

569
00:20:05,580 --> 00:20:07,620
Word level structure 16-bit 32-bit

570
00:20:07,620 --> 00:20:10,200
whatever address counters all kinds of

571
00:20:10,200 --> 00:20:12,720
stuff that will help us later on to

572
00:20:12,720 --> 00:20:15,480
actually understand what's going on

573
00:20:15,480 --> 00:20:17,640
um and then we want to have some form of

574
00:20:17,640 --> 00:20:19,260
restoring the bit order because if you

575
00:20:19,260 --> 00:20:21,120
just group flip flops together you have

576
00:20:21,120 --> 00:20:22,919
no idea and what or what order these

577
00:20:22,919 --> 00:20:25,320
flip flops make up the register

578
00:20:25,320 --> 00:20:25,860
um

579
00:20:25,860 --> 00:20:29,400
so first off the register recovery

580
00:20:29,400 --> 00:20:31,919
basically that's actually the topic that

581
00:20:31,919 --> 00:20:33,360
Niels got invited for this conference

582
00:20:33,360 --> 00:20:34,980
for

583
00:20:34,980 --> 00:20:38,400
initially but with this

584
00:20:38,400 --> 00:20:39,679
with the cells then

585
00:20:39,679 --> 00:20:42,059
so this is data flow analysis which

586
00:20:42,059 --> 00:20:45,660
basically uses some metrics to finally

587
00:20:45,660 --> 00:20:47,880
recover registers out of the Sea of gate

588
00:20:47,880 --> 00:20:49,500
so it basically takes flip flops

589
00:20:49,500 --> 00:20:51,660
analyzes their control inputs like

590
00:20:51,660 --> 00:20:54,299
enable reset clock whatever and

591
00:20:54,299 --> 00:20:56,160
according to these information groups

592
00:20:56,160 --> 00:20:58,080
the flip flops into registers and that

593
00:20:58,080 --> 00:20:59,340
actually allows you to do some cool

594
00:20:59,340 --> 00:21:01,020
stuff on its own like detecting crypto

595
00:21:01,020 --> 00:21:03,539
algorithms if you just look for 128 bit

596
00:21:03,539 --> 00:21:05,580
registers for example for AES

597
00:21:05,580 --> 00:21:07,620
can be easily used to just detect crypto

598
00:21:07,620 --> 00:21:10,820
and unknown netlists

599
00:21:10,980 --> 00:21:14,039
and that's basically it for Dana so the

600
00:21:14,039 --> 00:21:15,780
outcome of Dana is some I don't know

601
00:21:15,780 --> 00:21:18,600
8-bit 16-bit registers and we do

602
00:21:18,600 --> 00:21:20,700
something very similar for Max's Maxes

603
00:21:20,700 --> 00:21:23,520
are just Gates that have three inputs

604
00:21:23,520 --> 00:21:25,679
and two data inputs and one select input

605
00:21:25,679 --> 00:21:27,299
and the select input basically decides

606
00:21:27,299 --> 00:21:29,100
which of the data input is inputs is

607
00:21:29,100 --> 00:21:30,440
forwarded

608
00:21:30,440 --> 00:21:33,720
so you can imagine like these also are

609
00:21:33,720 --> 00:21:35,520
heavily used on the data path so on the

610
00:21:35,520 --> 00:21:38,159
on the on the kind of logic that that

611
00:21:38,159 --> 00:21:41,460
works on the actual data of the chip

612
00:21:41,460 --> 00:21:43,740
and here we just look at the select

613
00:21:43,740 --> 00:21:45,419
signals and group different flip flops

614
00:21:45,419 --> 00:21:48,179
different Max gates with similar selects

615
00:21:48,179 --> 00:21:50,640
together and then use some analysis of

616
00:21:50,640 --> 00:21:52,919
predecessors and successors to finally

617
00:21:52,919 --> 00:21:55,200
uh to finalize our groupings to like

618
00:21:55,200 --> 00:21:58,980
8-bit 16-bit Max structures

619
00:21:58,980 --> 00:22:00,419
um that help us understand the data

620
00:22:00,419 --> 00:22:02,460
paths in the end

621
00:22:02,460 --> 00:22:05,159
and then as I already said there is

622
00:22:05,159 --> 00:22:06,960
there is eddos there's counters and

623
00:22:06,960 --> 00:22:09,299
stuff that we need for address Logic for

624
00:22:09,299 --> 00:22:11,340
example to figure out how how addresses

625
00:22:11,340 --> 00:22:13,440
are dealt with that access memory and

626
00:22:13,440 --> 00:22:14,760
stuff

627
00:22:14,760 --> 00:22:17,100
um so these we identify by structural

628
00:22:17,100 --> 00:22:18,600
analysis because they all look the same

629
00:22:18,600 --> 00:22:20,880
in the implementer in the net list and

630
00:22:20,880 --> 00:22:22,500
then we actually use smt solving to

631
00:22:22,500 --> 00:22:25,380
verify their exact functionality

632
00:22:25,380 --> 00:22:28,620
um including presets enables whatever

633
00:22:28,620 --> 00:22:29,820
okay

634
00:22:29,820 --> 00:22:31,500
last but not least the bit order

635
00:22:31,500 --> 00:22:32,820
propagation

636
00:22:32,820 --> 00:22:34,860
as I said some of the structures lack

637
00:22:34,860 --> 00:22:37,320
any information of where which bit or

638
00:22:37,320 --> 00:22:38,880
where which flip flop where which gate

639
00:22:38,880 --> 00:22:41,100
is located within the structure so we

640
00:22:41,100 --> 00:22:43,500
really like if we do further analysis of

641
00:22:43,500 --> 00:22:45,000
the data that passes through these

642
00:22:45,000 --> 00:22:47,460
structures we need to know in what what

643
00:22:47,460 --> 00:22:49,320
order the bits are otherwise it will not

644
00:22:49,320 --> 00:22:50,760
make sense we want to interpret like

645
00:22:50,760 --> 00:22:53,220
integers in the end and not bits

646
00:22:53,220 --> 00:22:53,940
um

647
00:22:53,940 --> 00:22:57,840
so we need to find out how the registers

648
00:22:57,840 --> 00:23:00,780
and Maxes are organized how they are how

649
00:23:00,780 --> 00:23:02,580
their bit order is and we take that bit

650
00:23:02,580 --> 00:23:04,140
all information from neighboring Gates

651
00:23:04,140 --> 00:23:05,820
and structures like viadas for example

652
00:23:05,820 --> 00:23:08,280
that have an inherent inherent bid order

653
00:23:08,280 --> 00:23:10,440
through their like carry chains for

654
00:23:10,440 --> 00:23:12,720
example or the Brams were just just a

655
00:23:12,720 --> 00:23:15,059
fixed gate that has like 16 16 bit

656
00:23:15,059 --> 00:23:17,280
inputs in fixed order so we can take

657
00:23:17,280 --> 00:23:18,600
that information and propagate through

658
00:23:18,600 --> 00:23:21,059
the net list to actually recover the bit

659
00:23:21,059 --> 00:23:22,260
order

660
00:23:22,260 --> 00:23:24,120
all right and this is where I hand over

661
00:23:24,120 --> 00:23:27,840
to Niels for the fun part

662
00:23:27,840 --> 00:23:28,919
okay

663
00:23:28,919 --> 00:23:31,140
yeah sorry for so much background

664
00:23:31,140 --> 00:23:33,299
information but now we're gonna do like

665
00:23:33,299 --> 00:23:34,980
some cool Hardware stuff

666
00:23:34,980 --> 00:23:38,280
um so let's have a look at the uh goal

667
00:23:38,280 --> 00:23:39,840
of the third phase again at our starting

668
00:23:39,840 --> 00:23:42,480
point so we basically shifted from like

669
00:23:42,480 --> 00:23:44,340
the Sea of gates you know all these

670
00:23:44,340 --> 00:23:47,220
little Gates that Julian just showed to

671
00:23:47,220 --> 00:23:49,020
like a sea of modules so we have like

672
00:23:49,020 --> 00:23:50,640
these headers and all these things

673
00:23:50,640 --> 00:23:52,919
available so it's a little more

674
00:23:52,919 --> 00:23:56,100
um like easier to understand

675
00:23:56,100 --> 00:23:58,260
um and now our goal is to figure out

676
00:23:58,260 --> 00:24:01,080
what's what this does on a higher level

677
00:24:01,080 --> 00:24:03,360
um and therefore I mean you guys know

678
00:24:03,360 --> 00:24:04,559
this when you do like software versus

679
00:24:04,559 --> 00:24:05,940
engineering you usually try to figure

680
00:24:05,940 --> 00:24:06,900
out

681
00:24:06,900 --> 00:24:08,820
um as much possibly as you can on the

682
00:24:08,820 --> 00:24:10,080
internet you look through patents you

683
00:24:10,080 --> 00:24:11,340
look through documentation of your

684
00:24:11,340 --> 00:24:13,260
microcontroller and whatnot so we

685
00:24:13,260 --> 00:24:14,880
basically did the same so we tried to

686
00:24:14,880 --> 00:24:17,039
look at the Apple patterns that we're

687
00:24:17,039 --> 00:24:19,080
describing what this was doing not going

688
00:24:19,080 --> 00:24:21,780
into much detail on this one

689
00:24:21,780 --> 00:24:24,179
um we also did an analysis of like the

690
00:24:24,179 --> 00:24:26,340
communication interfaces so how does our

691
00:24:26,340 --> 00:24:30,120
data actually get into our fpga

692
00:24:30,120 --> 00:24:32,580
um and then in the final thing we did

693
00:24:32,580 --> 00:24:34,320
like the data pass understanding to

694
00:24:34,320 --> 00:24:37,620
figure out what this actually is doing

695
00:24:37,620 --> 00:24:39,480
um so a little bit more background

696
00:24:39,480 --> 00:24:40,980
information

697
00:24:40,980 --> 00:24:43,320
um so Julian already said that the

698
00:24:43,320 --> 00:24:45,419
iPhone the fpga in there is not doing

699
00:24:45,419 --> 00:24:48,360
sadly anything with security but it's

700
00:24:48,360 --> 00:24:50,400
doing like something with the vibration

701
00:24:50,400 --> 00:24:53,159
stuff um and it's actually controlling

702
00:24:53,159 --> 00:24:54,840
this little thing that you see right

703
00:24:54,840 --> 00:24:56,280
over there this is like the taptic

704
00:24:56,280 --> 00:24:59,820
engine which basically simulates these

705
00:24:59,820 --> 00:25:02,940
nice vibrations that you can feel and

706
00:25:02,940 --> 00:25:04,980
one new addition that the iPhone 7 had

707
00:25:04,980 --> 00:25:06,900
was it had like this virtual home button

708
00:25:06,900 --> 00:25:09,059
so there's no physical button anymore

709
00:25:09,059 --> 00:25:12,120
and this thing basically is able to

710
00:25:12,120 --> 00:25:15,059
simulate a super realistic click so that

711
00:25:15,059 --> 00:25:17,640
you don't actually notice that the video

712
00:25:17,640 --> 00:25:20,460
physical button is missing and as you

713
00:25:20,460 --> 00:25:22,200
can imagine this requires some a lot of

714
00:25:22,200 --> 00:25:23,100
like

715
00:25:23,100 --> 00:25:25,440
um signal processing and whatnot and

716
00:25:25,440 --> 00:25:27,360
this is actually what our fpga was kind

717
00:25:27,360 --> 00:25:31,440
of for to do all of this processing

718
00:25:31,440 --> 00:25:34,380
Okay so

719
00:25:34,380 --> 00:25:36,600
um this is some information we kind of

720
00:25:36,600 --> 00:25:38,400
derived from the patents and on our own

721
00:25:38,400 --> 00:25:40,679
so basically all of this in the middle

722
00:25:40,679 --> 00:25:43,500
this is like inside the fpga so these

723
00:25:43,500 --> 00:25:45,360
are the information that we actually

724
00:25:45,360 --> 00:25:47,580
reverse engineered ourselves and

725
00:25:47,580 --> 00:25:49,799
everything around that is basically the

726
00:25:49,799 --> 00:25:51,600
things you can see on the PCB so there's

727
00:25:51,600 --> 00:25:54,240
like this n A10 SOC which is like the

728
00:25:54,240 --> 00:25:56,700
big SOC that Apple designs by themselves

729
00:25:56,700 --> 00:25:59,100
you know basically the CPU with like a

730
00:25:59,100 --> 00:26:01,679
bunch of extra modules on there and then

731
00:26:01,679 --> 00:26:03,779
you have you know Maggie talking again

732
00:26:03,779 --> 00:26:07,140
to Homer over there which is um yeah the

733
00:26:07,140 --> 00:26:09,360
thing that basically talks to the motor

734
00:26:09,360 --> 00:26:12,000
driver in the taptic engine in the end

735
00:26:12,000 --> 00:26:13,740
okay

736
00:26:13,740 --> 00:26:14,580
um

737
00:26:14,580 --> 00:26:15,900
so we had to get it a little bit

738
00:26:15,900 --> 00:26:18,240
creative here because it was actually

739
00:26:18,240 --> 00:26:20,340
still quite hard figuring out what's

740
00:26:20,340 --> 00:26:21,840
what's happening here because we have no

741
00:26:21,840 --> 00:26:24,120
clue about like signal processing and

742
00:26:24,120 --> 00:26:26,340
one thing that we came up with is doing

743
00:26:26,340 --> 00:26:28,679
a simulation based analysis yeah so what

744
00:26:28,679 --> 00:26:29,820
does it mean

745
00:26:29,820 --> 00:26:32,100
um you can basically do this on partial

746
00:26:32,100 --> 00:26:35,400
um yeah on some selected parts of the

747
00:26:35,400 --> 00:26:37,320
net list where you just like simulate

748
00:26:37,320 --> 00:26:39,120
what's going on

749
00:26:39,120 --> 00:26:41,520
um which is quite fast and quite nice

750
00:26:41,520 --> 00:26:43,320
and you can like generate some arbitrary

751
00:26:43,320 --> 00:26:45,179
inputs on yourself

752
00:26:45,179 --> 00:26:46,559
um and see what's what's going on inside

753
00:26:46,559 --> 00:26:48,900
but you can also do like a full Network

754
00:26:48,900 --> 00:26:50,640
simulation and if you have like a

755
00:26:50,640 --> 00:26:53,159
perfectly recovered net list

756
00:26:53,159 --> 00:26:54,840
um that would be super cool because then

757
00:26:54,840 --> 00:26:56,700
you could check every signal at any time

758
00:26:56,700 --> 00:26:58,919
and see what's happening there but we

759
00:26:58,919 --> 00:27:01,620
had to get creative on like to feed the

760
00:27:01,620 --> 00:27:03,360
ship with the correct data that goes in

761
00:27:03,360 --> 00:27:04,620
there

762
00:27:04,620 --> 00:27:07,559
um this is yeah quite slow because it's

763
00:27:07,559 --> 00:27:09,960
quite big yeah the netlist has like 10

764
00:27:09,960 --> 00:27:11,460
000 gate and there's like lots of

765
00:27:11,460 --> 00:27:13,440
complicated skates inside

766
00:27:13,440 --> 00:27:15,600
um so this is like taking a lot longer

767
00:27:15,600 --> 00:27:17,340
time we Outsource it to a server which

768
00:27:17,340 --> 00:27:19,860
was like taking a couple of hours

769
00:27:19,860 --> 00:27:22,200
um but it was super cool so basically

770
00:27:22,200 --> 00:27:23,940
the rough ideas for following so what we

771
00:27:23,940 --> 00:27:25,980
wanted to do is we wanted to record the

772
00:27:25,980 --> 00:27:29,880
actual data that goes into our fpga so

773
00:27:29,880 --> 00:27:31,620
basically the communication between the

774
00:27:31,620 --> 00:27:35,760
iPhone PCB and our Mega fpga so we

775
00:27:35,760 --> 00:27:38,279
somehow had to like connect an FB or

776
00:27:38,279 --> 00:27:41,100
fpga to a logic analyzer to recall all

777
00:27:41,100 --> 00:27:43,980
the input and outputs and then as I said

778
00:27:43,980 --> 00:27:46,380
we want to feed the recorded data into a

779
00:27:46,380 --> 00:27:48,480
simulator and then simulate what's

780
00:27:48,480 --> 00:27:50,460
happening in there and then we can

781
00:27:50,460 --> 00:27:53,460
perform our Dynamic netlist Behavior and

782
00:27:53,460 --> 00:27:54,480
the cool part is

783
00:27:54,480 --> 00:27:57,179
that this allows us to focus on the data

784
00:27:57,179 --> 00:27:59,820
path entirely yeah because one of the

785
00:27:59,820 --> 00:28:02,880
problems is that with the entire control

786
00:28:02,880 --> 00:28:06,059
logic you have to know what inputs you

787
00:28:06,059 --> 00:28:08,279
have to feed to the control logic so

788
00:28:08,279 --> 00:28:10,200
that certain actions happen on the data

789
00:28:10,200 --> 00:28:11,940
path but if we have the correct inputs

790
00:28:11,940 --> 00:28:15,299
already feeding into our tip the inputs

791
00:28:15,299 --> 00:28:17,100
basically take care of the correct

792
00:28:17,100 --> 00:28:19,980
actions on the data path and this allows

793
00:28:19,980 --> 00:28:23,520
us to not reverse Engineers just these

794
00:28:23,520 --> 00:28:25,919
complex State machines and just focus on

795
00:28:25,919 --> 00:28:28,799
how the data is processed

796
00:28:28,799 --> 00:28:29,580
um

797
00:28:29,580 --> 00:28:31,620
right so this is kind of what it looks

798
00:28:31,620 --> 00:28:33,840
like in hell I'm going to show you like

799
00:28:33,840 --> 00:28:36,480
a little recorded live demo

800
00:28:36,480 --> 00:28:37,740
um over there you have like these

801
00:28:37,740 --> 00:28:39,360
waveforms and if you've ever done like

802
00:28:39,360 --> 00:28:41,580
Hardware design you know how painful

803
00:28:41,580 --> 00:28:44,220
it's debugging those yeah imagine how we

804
00:28:44,220 --> 00:28:46,020
how painful it is reverse engineering

805
00:28:46,020 --> 00:28:47,279
those

806
00:28:47,279 --> 00:28:48,900
um you already see that this is kind of

807
00:28:48,900 --> 00:28:50,640
modularized so there's like some shift

808
00:28:50,640 --> 00:28:52,740
registers we already found like the SPI

809
00:28:52,740 --> 00:28:54,299
interface there's some headers in there

810
00:28:54,299 --> 00:28:56,760
so we could actually do the

811
00:28:56,760 --> 00:28:59,580
um yeah simulation on the modularized

812
00:28:59,580 --> 00:29:02,340
net list and it's not super clearly

813
00:29:02,340 --> 00:29:05,400
visible in the um in the on the on the

814
00:29:05,400 --> 00:29:07,260
projector here but all these different

815
00:29:07,260 --> 00:29:09,840
Nets so the connection between the gates

816
00:29:09,840 --> 00:29:12,360
have like different colors depending on

817
00:29:12,360 --> 00:29:14,700
where that cursor over there is set to

818
00:29:14,700 --> 00:29:15,299
um

819
00:29:15,299 --> 00:29:17,220
and then this shows you if this certain

820
00:29:17,220 --> 00:29:19,200
signal is like one or zero at a certain

821
00:29:19,200 --> 00:29:21,240
time yeah and we call that Realtor

822
00:29:21,240 --> 00:29:23,279
probing because it allows you to access

823
00:29:23,279 --> 00:29:25,679
every signal at every given time and

824
00:29:25,679 --> 00:29:27,960
observe what it's doing like under

825
00:29:27,960 --> 00:29:29,159
operation

826
00:29:29,159 --> 00:29:32,039
uh so this is what it kind of looked

827
00:29:32,039 --> 00:29:33,299
likes in

828
00:29:33,299 --> 00:29:34,980
hell

829
00:29:34,980 --> 00:29:38,700
let me just start that video real quick

830
00:29:38,700 --> 00:29:39,539
okay

831
00:29:39,539 --> 00:29:41,520
so on the right you have like this um

832
00:29:41,520 --> 00:29:43,919
this waveform viewer and this basically

833
00:29:43,919 --> 00:29:46,860
shows all your clock Cycles yeah

834
00:29:46,860 --> 00:29:48,600
um and you can take that cursor around

835
00:29:48,600 --> 00:29:50,580
there and you can see that these these

836
00:29:50,580 --> 00:29:52,679
signal changes their color depending on

837
00:29:52,679 --> 00:29:54,600
which clock cycle you're on so basically

838
00:29:54,600 --> 00:29:58,919
we can we know the value of every

839
00:29:58,919 --> 00:30:01,860
signal at any time and can use it for

840
00:30:01,860 --> 00:30:04,740
our us Engineering Process

841
00:30:04,740 --> 00:30:06,600
the biggest biggest problem of this was

842
00:30:06,600 --> 00:30:08,460
that we were not able to get to the

843
00:30:08,460 --> 00:30:10,440
connections of the fpga because as you

844
00:30:10,440 --> 00:30:12,899
can see here these things usually have

845
00:30:12,899 --> 00:30:15,059
like a ball grid array so all these

846
00:30:15,059 --> 00:30:17,700
connections are under yeah underneath

847
00:30:17,700 --> 00:30:19,440
the fpga basically because it's like

848
00:30:19,440 --> 00:30:22,980
soldered on top of the PCB and the i o

849
00:30:22,980 --> 00:30:25,260
is not accessible right away so we had

850
00:30:25,260 --> 00:30:28,260
to be creative and what we did basically

851
00:30:28,260 --> 00:30:30,960
this was what we did was we designed a

852
00:30:30,960 --> 00:30:34,140
custom breakout board so

853
00:30:34,140 --> 00:30:37,140
um we removed Maggie from the iPhone PCB

854
00:30:37,140 --> 00:30:39,600
so this is like the the idea that we had

855
00:30:39,600 --> 00:30:41,880
we put it on our custom breakout board

856
00:30:41,880 --> 00:30:44,640
soldered that back onto the

857
00:30:44,640 --> 00:30:46,860
um iPhone PCB and then as you can see

858
00:30:46,860 --> 00:30:48,360
like with these golden connections on

859
00:30:48,360 --> 00:30:50,340
these edges over there we were able to

860
00:30:50,340 --> 00:30:51,779
like basically

861
00:30:51,779 --> 00:30:52,440
um

862
00:30:52,440 --> 00:30:55,440
yeah take all the the data out of there

863
00:30:55,440 --> 00:30:58,500
and use it to record it with our logic

864
00:30:58,500 --> 00:31:02,520
analyzer so a little I can I can show

865
00:31:02,520 --> 00:31:04,980
you this was a lot of struggle until

866
00:31:04,980 --> 00:31:06,539
um we got this working so basically what

867
00:31:06,539 --> 00:31:08,940
we did step one we have to remove Maggie

868
00:31:08,940 --> 00:31:12,059
from the iPhone PCB yeah problem is we

869
00:31:12,059 --> 00:31:14,159
couldn't find a way to remove Maggie

870
00:31:14,159 --> 00:31:16,320
without destroying it because we always

871
00:31:16,320 --> 00:31:19,020
this is like there's like some glue on

872
00:31:19,020 --> 00:31:21,539
the iPhone PCB that basically prevents

873
00:31:21,539 --> 00:31:23,820
it like from Catching dust and also like

874
00:31:23,820 --> 00:31:25,440
from from

875
00:31:25,440 --> 00:31:27,720
um water or something

876
00:31:27,720 --> 00:31:29,760
um so we were never able to get Maggie

877
00:31:29,760 --> 00:31:31,200
out of there without this drugging

878
00:31:31,200 --> 00:31:33,659
without destroying Maggie so in the end

879
00:31:33,659 --> 00:31:36,360
we just used a Mill and get completely

880
00:31:36,360 --> 00:31:38,220
rid of Maggie

881
00:31:38,220 --> 00:31:39,419
um this is kind of what it looks like

882
00:31:39,419 --> 00:31:41,399
yeah so there's like this Mill that

883
00:31:41,399 --> 00:31:43,260
basically just

884
00:31:43,260 --> 00:31:46,559
um kills Maggie and as you can see now

885
00:31:46,559 --> 00:31:49,380
these connections on the orange circle

886
00:31:49,380 --> 00:31:52,559
over there are free for us to use and

887
00:31:52,559 --> 00:31:54,899
what we just did we bought new parts of

888
00:31:54,899 --> 00:31:57,179
Maggie so you can just buy them online

889
00:31:57,179 --> 00:31:59,820
um so we we just bought a new fpga put

890
00:31:59,820 --> 00:32:00,899
it on the

891
00:32:00,899 --> 00:32:03,360
um yeah on our backout board which you

892
00:32:03,360 --> 00:32:05,279
can see over there so we put Maggie on

893
00:32:05,279 --> 00:32:06,659
the breakout board

894
00:32:06,659 --> 00:32:09,059
um then we placed like a cube underneath

895
00:32:09,059 --> 00:32:12,299
you're gonna see what I mean by Cube and

896
00:32:12,299 --> 00:32:14,279
one second to like lift it a bit higher

897
00:32:14,279 --> 00:32:15,539
because they're like as you can see

898
00:32:15,539 --> 00:32:17,940
other chips on there which but so we

899
00:32:17,940 --> 00:32:19,679
needed to get like a bit higher so to

900
00:32:19,679 --> 00:32:23,580
actually get it back on the PCB again

901
00:32:23,580 --> 00:32:25,320
um yeah so this is kind of what it looks

902
00:32:25,320 --> 00:32:27,960
like so on the PCB we put like these

903
00:32:27,960 --> 00:32:31,260
cubes which you basically would cut off

904
00:32:31,260 --> 00:32:33,720
and then put here so the finished

905
00:32:33,720 --> 00:32:35,760
product you can see over there so this

906
00:32:35,760 --> 00:32:38,100
adds like additional height to it so

907
00:32:38,100 --> 00:32:41,399
that it can go back on the board

908
00:32:41,399 --> 00:32:44,039
um so another important thing is you had

909
00:32:44,039 --> 00:32:47,520
to get like these balls back onto the

910
00:32:47,520 --> 00:32:51,120
um onto the board onto the fpga and end

911
00:32:51,120 --> 00:32:52,980
again to our PCB to do the connection

912
00:32:52,980 --> 00:32:55,679
and as you can see those balls are like

913
00:32:55,679 --> 00:32:58,980
super small so it's like uh a

914
00:32:58,980 --> 00:33:00,840
pain in the ass to do that luckily there

915
00:33:00,840 --> 00:33:02,640
are machines that can help you there's

916
00:33:02,640 --> 00:33:04,919
like this reballing machine and you have

917
00:33:04,919 --> 00:33:05,880
like

918
00:33:05,880 --> 00:33:07,860
um the the actually the PCB under the

919
00:33:07,860 --> 00:33:09,899
micro microscope and you can basically

920
00:33:09,899 --> 00:33:12,120
shoot these bolts there and it takes

921
00:33:12,120 --> 00:33:14,519
care of you that takes care takes care

922
00:33:14,519 --> 00:33:15,960
of that for you and in the end you can

923
00:33:15,960 --> 00:33:18,659
see it worked out quite great and the

924
00:33:18,659 --> 00:33:20,399
um yeah the boards were in the right

925
00:33:20,399 --> 00:33:22,140
positions

926
00:33:22,140 --> 00:33:23,039
um

927
00:33:23,039 --> 00:33:25,260
so that was that was okay the problem

928
00:33:25,260 --> 00:33:26,820
was we couldn't do that for the iPhone

929
00:33:26,820 --> 00:33:29,640
PCB because yeah they never stuck so we

930
00:33:29,640 --> 00:33:32,519
had to do that manually which was a

931
00:33:32,519 --> 00:33:34,740
really not fun

932
00:33:34,740 --> 00:33:37,980
um so we had to put like another Cube on

933
00:33:37,980 --> 00:33:39,659
there to actually get it a little bit

934
00:33:39,659 --> 00:33:41,399
higher more because the other parts were

935
00:33:41,399 --> 00:33:44,220
too high for us to fit it on again

936
00:33:44,220 --> 00:33:45,960
um so in the end we had like these two

937
00:33:45,960 --> 00:33:49,500
cubes our PCB and then Maggie

938
00:33:49,500 --> 00:33:50,519
um

939
00:33:50,519 --> 00:33:52,200
yeah this shows basically how we place

940
00:33:52,200 --> 00:33:54,240
them on top of each other that's like a

941
00:33:54,240 --> 00:33:55,919
special machine that has like these two

942
00:33:55,919 --> 00:33:57,179
cameras

943
00:33:57,179 --> 00:33:59,580
um that are facing up and down so only

944
00:33:59,580 --> 00:34:02,159
one part there's like this this breakout

945
00:34:02,159 --> 00:34:04,380
board that we um put there and below

946
00:34:04,380 --> 00:34:06,840
here you can see the iPhone PCB and what

947
00:34:06,840 --> 00:34:08,520
this camera basically does it puts like

948
00:34:08,520 --> 00:34:10,980
these images on top of each other so now

949
00:34:10,980 --> 00:34:13,260
you can like align them perfectly and

950
00:34:13,260 --> 00:34:15,480
then put them down and then they are

951
00:34:15,480 --> 00:34:17,159
like aligned perfectly and you can

952
00:34:17,159 --> 00:34:19,800
solder them back together

953
00:34:19,800 --> 00:34:23,580
uh okay so that was basically it we got

954
00:34:23,580 --> 00:34:26,879
it working in the end and Maggie is now

955
00:34:26,879 --> 00:34:29,399
operating like in a normal mode so that

956
00:34:29,399 --> 00:34:31,800
worked out quite great and we were able

957
00:34:31,800 --> 00:34:34,379
to you know tap all these connections

958
00:34:34,379 --> 00:34:36,540
that are going in and out of Maggie and

959
00:34:36,540 --> 00:34:39,839
connect them to our logic analyzer to do

960
00:34:39,839 --> 00:34:42,780
um the analysis and record the inputs

961
00:34:42,780 --> 00:34:45,780
so this is how it looks like huh the

962
00:34:45,780 --> 00:34:48,000
iPhone we never put it back in the case

963
00:34:48,000 --> 00:34:50,399
of course yeah so it's it's running it's

964
00:34:50,399 --> 00:34:52,260
running like this with a stripped

965
00:34:52,260 --> 00:34:54,960
functionality basically

966
00:34:54,960 --> 00:34:57,300
um some more pictures this is like a on

967
00:34:57,300 --> 00:34:59,760
top view of our setup and as you can see

968
00:34:59,760 --> 00:35:01,859
the iPhone is actually working even

969
00:35:01,859 --> 00:35:04,800
though yeah we did our little magic

970
00:35:04,800 --> 00:35:05,820
there

971
00:35:05,820 --> 00:35:08,420
so what lessons did we learn we had to

972
00:35:08,420 --> 00:35:10,740
commemorate eight iPhones I think in the

973
00:35:10,740 --> 00:35:12,359
end it was even 10 that we destroyed in

974
00:35:12,359 --> 00:35:14,040
that process

975
00:35:14,040 --> 00:35:16,800
um we ran through Maggie supplies of two

976
00:35:16,800 --> 00:35:20,220
iPhone repair shops so this is like uh

977
00:35:20,220 --> 00:35:22,079
yeah not the popular part apparently

978
00:35:22,079 --> 00:35:23,760
anymore

979
00:35:23,760 --> 00:35:26,880
um it took in the end we had like a

980
00:35:26,880 --> 00:35:28,380
workflow that took about three to four

981
00:35:28,380 --> 00:35:29,760
hours but figuring out the entire

982
00:35:29,760 --> 00:35:32,400
process took us three or four weeks

983
00:35:32,400 --> 00:35:34,020
and

984
00:35:34,020 --> 00:35:35,820
another thing I cannot recommend doing

985
00:35:35,820 --> 00:35:37,619
is once you've finished your first

986
00:35:37,619 --> 00:35:40,380
iPhone don't drop it yeah so this was

987
00:35:40,380 --> 00:35:42,900
the thing after having like these eight

988
00:35:42,900 --> 00:35:45,000
iPhones that were not working we finally

989
00:35:45,000 --> 00:35:47,280
think we got one that was working and

990
00:35:47,280 --> 00:35:48,599
then

991
00:35:48,599 --> 00:35:52,020
yeah it fell down so that was not fun uh

992
00:35:52,020 --> 00:35:55,140
but we eventually got it working we

993
00:35:55,140 --> 00:35:57,119
applied some epoxy though so it we could

994
00:35:57,119 --> 00:35:58,920
like even ship it and transport it and

995
00:35:58,920 --> 00:36:01,260
we had like this nice Tower over there

996
00:36:01,260 --> 00:36:03,960
that helped us do all of this so I need

997
00:36:03,960 --> 00:36:06,240
to check a bit on the time I just think

998
00:36:06,240 --> 00:36:09,240
we're still good 36 minutes great

999
00:36:09,240 --> 00:36:11,040
um so what so what if you do with the

1000
00:36:11,040 --> 00:36:13,560
recorded data and I'm going to show you

1001
00:36:13,560 --> 00:36:16,320
like the first example

1002
00:36:16,320 --> 00:36:18,000
um and one one of the things that the

1003
00:36:18,000 --> 00:36:22,200
yeah uh fpga is basically assisting with

1004
00:36:22,200 --> 00:36:25,859
is that um the processing for the the

1005
00:36:25,859 --> 00:36:28,079
clicks so in the settings of the iPhone

1006
00:36:28,079 --> 00:36:30,540
you can choose how hard you want your

1007
00:36:30,540 --> 00:36:33,180
haptic feedback to be like soft medium

1008
00:36:33,180 --> 00:36:34,560
or heart and you can set like these

1009
00:36:34,560 --> 00:36:37,260
three levels and now with our setup we

1010
00:36:37,260 --> 00:36:39,480
basically recorded what is happening

1011
00:36:39,480 --> 00:36:43,260
when we set these three levels yeah so

1012
00:36:43,260 --> 00:36:44,940
um it's like a super high level overview

1013
00:36:44,940 --> 00:36:48,480
we saw that every time we send set like

1014
00:36:48,480 --> 00:36:50,280
different settings on the uh on the

1015
00:36:50,280 --> 00:36:52,680
iPhone software that there was like data

1016
00:36:52,680 --> 00:36:55,260
being sent via this SPI interface to our

1017
00:36:55,260 --> 00:36:58,260
iPhone yeah so setting it to level one

1018
00:36:58,260 --> 00:37:00,780
issued the sending of this First Data

1019
00:37:00,780 --> 00:37:03,480
packet then setting it to level two we

1020
00:37:03,480 --> 00:37:06,599
observed the none of that another data

1021
00:37:06,599 --> 00:37:09,060
package coming in and then for level

1022
00:37:09,060 --> 00:37:11,460
three of the same so we had a look

1023
00:37:11,460 --> 00:37:13,020
um at what's what's happening inside and

1024
00:37:13,020 --> 00:37:16,500
this is like a super simplified overview

1025
00:37:16,500 --> 00:37:19,380
um so in our fpga there's like this SPI

1026
00:37:19,380 --> 00:37:21,480
receiver and then the data basically

1027
00:37:21,480 --> 00:37:24,180
goes all up to like some Rams that are

1028
00:37:24,180 --> 00:37:26,820
featured in our fpga

1029
00:37:26,820 --> 00:37:27,540
um

1030
00:37:27,540 --> 00:37:29,460
and what we observed basically that the

1031
00:37:29,460 --> 00:37:31,500
data once you set them like to the three

1032
00:37:31,500 --> 00:37:34,260
different levels there's like some curve

1033
00:37:34,260 --> 00:37:36,480
coming in that we were able to extract

1034
00:37:36,480 --> 00:37:38,760
using our simulation yeah so we

1035
00:37:38,760 --> 00:37:41,040
basically observed the content that was

1036
00:37:41,040 --> 00:37:44,099
in the fpga after these these packages

1037
00:37:44,099 --> 00:37:46,920
for the levels came in and we extracted

1038
00:37:46,920 --> 00:37:49,140
these license little curves and you can

1039
00:37:49,140 --> 00:37:51,839
see like there's like an increase

1040
00:37:51,839 --> 00:37:53,579
um yeah

1041
00:37:53,579 --> 00:37:56,280
Peak basically the higher the level is

1042
00:37:56,280 --> 00:37:59,640
so the harder the touch should feel

1043
00:37:59,640 --> 00:38:01,260
okay

1044
00:38:01,260 --> 00:38:03,540
yeah I'm gonna skip through this because

1045
00:38:03,540 --> 00:38:06,839
I don't have that much time anymore

1046
00:38:06,839 --> 00:38:08,700
um this is actually like the super

1047
00:38:08,700 --> 00:38:10,680
complex part so you're kind of lucky

1048
00:38:10,680 --> 00:38:12,060
that we

1049
00:38:12,060 --> 00:38:14,820
cannot get into much detail

1050
00:38:14,820 --> 00:38:16,859
um

1051
00:38:16,859 --> 00:38:18,720
so basically what this allowed us to do

1052
00:38:18,720 --> 00:38:20,400
and this is like very low level and now

1053
00:38:20,400 --> 00:38:22,320
there is some some dsps in there that do

1054
00:38:22,320 --> 00:38:24,480
the computation and now we have to do

1055
00:38:24,480 --> 00:38:27,300
like an analysis on yeah no you know

1056
00:38:27,300 --> 00:38:29,820
over time on how this all works in the

1057
00:38:29,820 --> 00:38:32,730
end we get a python module out of a

1058
00:38:32,730 --> 00:38:33,839
[Music]

1059
00:38:33,839 --> 00:38:36,660
we basically re-implemented the entire

1060
00:38:36,660 --> 00:38:39,780
data path from the iPhone in Python so

1061
00:38:39,780 --> 00:38:41,780
our python model that we extracted

1062
00:38:41,780 --> 00:38:44,220
exactly behaves like the actual data

1063
00:38:44,220 --> 00:38:46,859
pass so we kind of yeah we're happy that

1064
00:38:46,859 --> 00:38:49,680
we moved away from from the from the

1065
00:38:49,680 --> 00:38:51,180
gates and whatnot

1066
00:38:51,180 --> 00:38:53,820
um to like a higher level of yeah

1067
00:38:53,820 --> 00:38:57,359
abstraction and this is where we

1068
00:38:57,359 --> 00:38:59,520
gave everything like all the algorithms

1069
00:38:59,520 --> 00:39:01,260
all the mass formulas that we extracted

1070
00:39:01,260 --> 00:39:03,359
from out of there then in this prices

1071
00:39:03,359 --> 00:39:05,160
group we gave to our colleague you know

1072
00:39:05,160 --> 00:39:06,960
who has like an idea on how to do signal

1073
00:39:06,960 --> 00:39:09,240
processing and after two weeks of

1074
00:39:09,240 --> 00:39:12,119
staring at that he figured out what is

1075
00:39:12,119 --> 00:39:14,760
what this is exactly doing on like a

1076
00:39:14,760 --> 00:39:16,740
very low level there's like some Fourier

1077
00:39:16,740 --> 00:39:18,540
Transformations I don't ask me about

1078
00:39:18,540 --> 00:39:19,920
this yeah

1079
00:39:19,920 --> 00:39:22,200
um in there so it's very super complex

1080
00:39:22,200 --> 00:39:24,359
system and it's actually super cool yeah

1081
00:39:24,359 --> 00:39:26,640
if it has like this super weird sensors

1082
00:39:26,640 --> 00:39:28,280
that even when your iPhone might drop

1083
00:39:28,280 --> 00:39:30,720
these vibrations these little vibrations

1084
00:39:30,720 --> 00:39:32,460
might have a little feel a little

1085
00:39:32,460 --> 00:39:34,500
different so they have like sensors that

1086
00:39:34,500 --> 00:39:37,260
you know feedback the data into the fpga

1087
00:39:37,260 --> 00:39:39,480
to compensate for that so that it

1088
00:39:39,480 --> 00:39:43,140
doesn't feel yeah any changed okay so

1089
00:39:43,140 --> 00:39:44,820
our conclusion is Hardware reverse

1090
00:39:44,820 --> 00:39:46,920
engineering is super painful

1091
00:39:46,920 --> 00:39:50,220
um but it's feasible even with our

1092
00:39:50,220 --> 00:39:52,140
limited University resources that we

1093
00:39:52,140 --> 00:39:55,140
have so you know no idea what's going on

1094
00:39:55,140 --> 00:39:56,820
behind closed doors at the NSA and

1095
00:39:56,820 --> 00:39:58,380
whatnot

1096
00:39:58,380 --> 00:40:00,780
um the dynamic analysis that we used was

1097
00:40:00,780 --> 00:40:02,339
like for us a key to actually

1098
00:40:02,339 --> 00:40:04,619
understanding of what is going on in

1099
00:40:04,619 --> 00:40:05,940
there

1100
00:40:05,940 --> 00:40:08,160
um and the interplay

1101
00:40:08,160 --> 00:40:10,920
between like these manual and semi-auto

1102
00:40:10,920 --> 00:40:12,839
automated reverse engineering techniques

1103
00:40:12,839 --> 00:40:14,640
that we came up with and that Julian

1104
00:40:14,640 --> 00:40:17,339
introduced was actually the the key to

1105
00:40:17,339 --> 00:40:19,140
achieve like this understanding in the

1106
00:40:19,140 --> 00:40:22,200
end so what you can basically do is you

1107
00:40:22,200 --> 00:40:24,540
can do IP theft so competitor analysis

1108
00:40:24,540 --> 00:40:27,359
or whatever on also like maybe and

1109
00:40:27,359 --> 00:40:29,160
especially for fpgas because they have

1110
00:40:29,160 --> 00:40:31,079
this updatable bit stream find

1111
00:40:31,079 --> 00:40:33,480
meaningful Hardware Trojan insertion

1112
00:40:33,480 --> 00:40:36,420
points so it poses a realistic threat

1113
00:40:36,420 --> 00:40:39,480
okay thank you very much

1114
00:40:39,480 --> 00:40:47,400
[Applause]

1115
00:40:48,180 --> 00:40:50,700
any questions yeah

1116
00:40:50,700 --> 00:40:52,859
yeah all right maybe a provocative one

1117
00:40:52,859 --> 00:40:54,900
first uh you've been referring to a

1118
00:40:54,900 --> 00:40:57,000
restricted budget that you had which

1119
00:40:57,000 --> 00:40:59,099
include the date iPhones being yeah

1120
00:40:59,099 --> 00:41:02,820
broken uh I just wonder do you imagine

1121
00:41:02,820 --> 00:41:05,579
this being ever available for everyday

1122
00:41:05,579 --> 00:41:07,320
people with everyday budget you know

1123
00:41:07,320 --> 00:41:09,619
it's like they can do some hardware

1124
00:41:09,619 --> 00:41:12,540
tinkering and and and get some some

1125
00:41:12,540 --> 00:41:15,980
intelligence out of it like you did

1126
00:41:16,079 --> 00:41:17,520
I mean

1127
00:41:17,520 --> 00:41:20,160
um for the for the static part so

1128
00:41:20,160 --> 00:41:21,660
basically our tool is open source it's

1129
00:41:21,660 --> 00:41:23,280
on GitHub you can download it and and

1130
00:41:23,280 --> 00:41:25,619
analyze netlist the dynamic part where

1131
00:41:25,619 --> 00:41:27,240
we had to capture the inputs It's

1132
00:41:27,240 --> 00:41:28,619
probably hard to do without these

1133
00:41:28,619 --> 00:41:29,820
machines

1134
00:41:29,820 --> 00:41:32,180
um available and without

1135
00:41:32,180 --> 00:41:34,740
the respective micro microscopes and

1136
00:41:34,740 --> 00:41:37,020
stuff so you need kind of a hardware lab

1137
00:41:37,020 --> 00:41:39,780
to do the the chip up and implementation

1138
00:41:39,780 --> 00:41:41,460
of the of the

1139
00:41:41,460 --> 00:41:42,140
um

1140
00:41:42,140 --> 00:41:45,839
the board to capture the the inputs but

1141
00:41:45,839 --> 00:41:47,339
for the static part where you just look

1142
00:41:47,339 --> 00:41:48,839
at the net list do some automatic

1143
00:41:48,839 --> 00:41:50,700
detection techniques that's completely

1144
00:41:50,700 --> 00:41:52,380
possible on your on your machine on your

1145
00:41:52,380 --> 00:41:54,680
laptop

1146
00:41:55,380 --> 00:41:58,500
that answers your question

1147
00:41:58,500 --> 00:42:00,540
yeah to be honest I was more focused on

1148
00:42:00,540 --> 00:42:02,099
the hardware part so I wonder if this

1149
00:42:02,099 --> 00:42:03,720
will ever be available you know for for

1150
00:42:03,720 --> 00:42:05,339
everyday people what I kind of hear out

1151
00:42:05,339 --> 00:42:07,200
that you say no because you need

1152
00:42:07,200 --> 00:42:08,940
specialized lab equipment for that right

1153
00:42:08,940 --> 00:42:11,400
yep all right thanks

1154
00:42:11,400 --> 00:42:13,320
but not the not the very expensive

1155
00:42:13,320 --> 00:42:15,420
equipment so that's still affordable to

1156
00:42:15,420 --> 00:42:17,040
to companies for example smaller

1157
00:42:17,040 --> 00:42:19,920
companies or universities I would say

1158
00:42:19,920 --> 00:42:22,980
we are using fpgas to accelerate very

1159
00:42:22,980 --> 00:42:25,320
important functions such as neural

1160
00:42:25,320 --> 00:42:28,380
networks or AI the edge of networks so

1161
00:42:28,380 --> 00:42:30,000
do you think that these analysis you

1162
00:42:30,000 --> 00:42:31,680
carried out with the development of the

1163
00:42:31,680 --> 00:42:34,980
tools and all the stuff related do you

1164
00:42:34,980 --> 00:42:37,380
think that this stuff poses some serious

1165
00:42:37,380 --> 00:42:40,260
threat to the deployment of for example

1166
00:42:40,260 --> 00:42:42,540
AI at the edge of Networks

1167
00:42:42,540 --> 00:42:46,320
and I I have a similar project on on

1168
00:42:46,320 --> 00:42:48,060
machine learning acceleration or we try

1169
00:42:48,060 --> 00:42:49,859
to manipulate such an accelerator for

1170
00:42:49,859 --> 00:42:51,900
machine learning Networks

1171
00:42:51,900 --> 00:42:52,619
um

1172
00:42:52,619 --> 00:42:55,200
but in general it's not as much of a

1173
00:42:55,200 --> 00:42:56,579
threat to machine learning I would say

1174
00:42:56,579 --> 00:42:58,140
as it is to security for example if you

1175
00:42:58,140 --> 00:42:59,760
have crypto running on your fpga and we

1176
00:42:59,760 --> 00:43:01,260
detect and we find keys and stuff that's

1177
00:43:01,260 --> 00:43:03,119
more serious

1178
00:43:03,119 --> 00:43:05,280
um for sure if you wanna if you can

1179
00:43:05,280 --> 00:43:06,960
Implement Hardware Trojans in the

1180
00:43:06,960 --> 00:43:09,119
accelerators or in the machine learning

1181
00:43:09,119 --> 00:43:10,619
implementation through hardwareverse

1182
00:43:10,619 --> 00:43:12,900
engineering this is of course a threat

1183
00:43:12,900 --> 00:43:17,339
let's thank again Niels and Julian

1184
00:43:17,339 --> 00:43:19,759
thanks

