1
00:00:01,439 --> 00:00:03,419
so as you see the title is very

2
00:00:03,419 --> 00:00:04,920
complicated so I will not repeat that

3
00:00:04,920 --> 00:00:06,899
but as you guess I'm presenting every

4
00:00:06,899 --> 00:00:09,720
click today and okay I can already see

5
00:00:09,720 --> 00:00:12,059
it's like some of you

6
00:00:12,059 --> 00:00:14,340
does this work yes

7
00:00:14,340 --> 00:00:16,619
thinking okay come on this is yet

8
00:00:16,619 --> 00:00:18,420
another CPU bug what the we are

9
00:00:18,420 --> 00:00:20,880
like done with it it's like the 25th one

10
00:00:20,880 --> 00:00:25,080
and okay yeah I mean I can see that but

11
00:00:25,080 --> 00:00:27,900
every single CPU bug that we like had

12
00:00:27,900 --> 00:00:30,900
previous from this one have something in

13
00:00:30,900 --> 00:00:33,840
common and the the thing is they all

14
00:00:33,840 --> 00:00:36,239
rely on side channels and okay

15
00:00:36,239 --> 00:00:38,700
implementing aside channel is like very

16
00:00:38,700 --> 00:00:40,739
complex to get it right it's super noisy

17
00:00:40,739 --> 00:00:42,719
you will have like errors we like to

18
00:00:42,719 --> 00:00:44,760
repeat your talk like thousands of time

19
00:00:44,760 --> 00:00:46,860
to like have some leak that makes sense

20
00:00:46,860 --> 00:00:49,140
and you will have errors and everything

21
00:00:49,140 --> 00:00:51,180
everyone says okay this is like academic

22
00:00:51,180 --> 00:00:53,340
work it doesn't work no one will like

23
00:00:53,340 --> 00:00:56,579
never use that so I mean I was wondering

24
00:00:56,579 --> 00:00:59,280
why can we have something something that

25
00:00:59,280 --> 00:01:01,860
is easier to implement something that

26
00:01:01,860 --> 00:01:03,359
literally can lick the data

27
00:01:03,359 --> 00:01:05,280
architecturally and if I'm here on stage

28
00:01:05,280 --> 00:01:07,799
obviously the answer is yes and today I

29
00:01:07,799 --> 00:01:10,799
will present you every click that's not

30
00:01:10,799 --> 00:01:13,140
yet another side Channel and to

31
00:01:13,140 --> 00:01:15,240
demonstrate you that we will go through

32
00:01:15,240 --> 00:01:17,580
that and like understand what's every

33
00:01:17,580 --> 00:01:19,020
click

34
00:01:19,020 --> 00:01:20,700
so every click is the first

35
00:01:20,700 --> 00:01:23,100
architectural bug that leaks data

36
00:01:23,100 --> 00:01:25,500
without any site Channel not a Channel

37
00:01:25,500 --> 00:01:28,200
at all it is not a Transit execution

38
00:01:28,200 --> 00:01:29,880
attack either it doesn't use speculation

39
00:01:29,880 --> 00:01:32,580
or transient faults in the CPU

40
00:01:32,580 --> 00:01:34,860
it deterministically leaks data even

41
00:01:34,860 --> 00:01:37,079
from sgx enclaves that is like the

42
00:01:37,079 --> 00:01:40,079
highest protected place in the CPU and

43
00:01:40,079 --> 00:01:42,540
now our trading is required either so

44
00:01:42,540 --> 00:01:44,640
you don't even know to do like Poor

45
00:01:44,640 --> 00:01:46,500
contentional Side Channels with between

46
00:01:46,500 --> 00:01:48,840
multiple tradings so that Intel can just

47
00:01:48,840 --> 00:01:50,939
say okay just disable every trading and

48
00:01:50,939 --> 00:01:54,960
you're done no and it affects sorry or

49
00:01:54,960 --> 00:01:56,100
this is trash

50
00:01:56,100 --> 00:01:57,899
okay it affects

51
00:01:57,899 --> 00:02:02,820
all or most of the latest CPU from Intel

52
00:02:02,820 --> 00:02:04,680
so okay no one cares about the outline

53
00:02:04,680 --> 00:02:06,060
you will see that

54
00:02:06,060 --> 00:02:08,220
and let's just

55
00:02:08,220 --> 00:02:10,619
answer what is every click and to answer

56
00:02:10,619 --> 00:02:13,980
that we will first have to see okay

57
00:02:13,980 --> 00:02:15,840
what is actually the Epic where the name

58
00:02:15,840 --> 00:02:17,760
come from and the Epic stands for

59
00:02:17,760 --> 00:02:19,440
advanced programmable interrupt

60
00:02:19,440 --> 00:02:21,599
controller I got it right and it's

61
00:02:21,599 --> 00:02:24,180
actually like a component inside CPU

62
00:02:24,180 --> 00:02:27,239
whose uh whose focus is to generate

63
00:02:27,239 --> 00:02:29,700
receive and forward interrupts in modern

64
00:02:29,700 --> 00:02:32,760
CPUs you have local epics in like inside

65
00:02:32,760 --> 00:02:35,340
each of the CPUs and you have one IO

66
00:02:35,340 --> 00:02:37,620
Avic that generates interrupts towards

67
00:02:37,620 --> 00:02:39,180
external devices

68
00:02:39,180 --> 00:02:42,060
the Epic can be programmed through the

69
00:02:42,060 --> 00:02:44,640
Epic registers that by default are

70
00:02:44,640 --> 00:02:45,959
memory mapped

71
00:02:45,959 --> 00:02:48,300
the location in like in the physical

72
00:02:48,300 --> 00:02:51,540
memory is controlled by an MSR so that

73
00:02:51,540 --> 00:02:53,400
in the physical memory you will have

74
00:02:53,400 --> 00:02:56,459
those epic registers that you can use so

75
00:02:56,459 --> 00:02:58,980
like overwrite or read to program for

76
00:02:58,980 --> 00:03:01,140
example the Epic timer interrupts that's

77
00:03:01,140 --> 00:03:03,180
the type that's the interrupt that your

78
00:03:03,180 --> 00:03:05,879
CPU constantly receives to like make it

79
00:03:05,879 --> 00:03:07,319
alive

80
00:03:07,319 --> 00:03:09,780
every single epic register is mapped as

81
00:03:09,780 --> 00:03:11,280
a 32-bit value

82
00:03:11,280 --> 00:03:14,040
and all their big registers are aligned

83
00:03:14,040 --> 00:03:15,780
to 16 bytes

84
00:03:15,780 --> 00:03:19,019
this means that you have like a lot of

85
00:03:19,019 --> 00:03:21,900
the bytes in the Epic mmio region that

86
00:03:21,900 --> 00:03:24,300
should not be accessed so all the bytes

87
00:03:24,300 --> 00:03:27,959
through four like from 4 to 15 should

88
00:03:27,959 --> 00:03:29,640
never be accessed

89
00:03:29,640 --> 00:03:32,040
and if you like try to understand why

90
00:03:32,040 --> 00:03:34,739
you can read an inter manual and it says

91
00:03:34,739 --> 00:03:38,599
okay any access that touches those bytes

92
00:03:38,599 --> 00:03:40,980
Behavior and these and different

93
00:03:40,980 --> 00:03:43,620
Behavior like includes hangs in correct

94
00:03:43,620 --> 00:03:46,980
results or even unexpected exceptions

95
00:03:46,980 --> 00:03:49,980
and this is like very tempting it's like

96
00:03:49,980 --> 00:03:52,620
when you see a sign with do not touch on

97
00:03:52,620 --> 00:03:54,239
a like in a shop

98
00:03:54,239 --> 00:03:56,519
you go in touch with you

99
00:03:56,519 --> 00:03:58,860
so yeah let's let's try this and let's

100
00:03:58,860 --> 00:04:01,019
touch those Bites come on

101
00:04:01,019 --> 00:04:02,400
so

102
00:04:02,400 --> 00:04:06,180
this is the basic POC of every click and

103
00:04:06,180 --> 00:04:09,120
it's so simple that even fits into it or

104
00:04:09,120 --> 00:04:13,439
on Mastodon like next week

105
00:04:13,439 --> 00:04:15,780
so it's super simple we will just want

106
00:04:15,780 --> 00:04:17,820
to see what's happening what will happen

107
00:04:17,820 --> 00:04:21,298
if we like map those physical memory and

108
00:04:21,298 --> 00:04:23,220
access the bytes that we shouldn't be be

109
00:04:23,220 --> 00:04:24,180
able to access

110
00:04:24,180 --> 00:04:27,720
so as I saw as I told you before this is

111
00:04:27,720 --> 00:04:29,340
a physical other so we have to map this

112
00:04:29,340 --> 00:04:31,680
address and then we can start dumping

113
00:04:31,680 --> 00:04:34,919
why this is so much slow come on okay

114
00:04:34,919 --> 00:04:37,800
and you can start dumping the the Epic

115
00:04:37,800 --> 00:04:40,259
mmao region and okay in the first one

116
00:04:40,259 --> 00:04:42,900
that's that defined it became a mayor

117
00:04:42,900 --> 00:04:45,000
register nothing much interesting will

118
00:04:45,000 --> 00:04:46,919
happen it's a Divine it's I don't know

119
00:04:46,919 --> 00:04:50,220
timer to interrupt epic register is zero

120
00:04:50,220 --> 00:04:52,919
now and that's fine but we can try to

121
00:04:52,919 --> 00:04:56,340
like read those bytes and like we read

122
00:04:56,340 --> 00:04:59,240
read again and we start seeing something

123
00:04:59,240 --> 00:05:02,460
and here something is happening we are

124
00:05:02,460 --> 00:05:05,220
seeing data and this is literally the

125
00:05:05,220 --> 00:05:07,979
first string I leaked from a CPU and

126
00:05:07,979 --> 00:05:11,220
it's like a warning and definitely the

127
00:05:11,220 --> 00:05:13,380
Epic shouldn't have a warning unless

128
00:05:13,380 --> 00:05:15,120
Intel wanted to tell us hey please don't

129
00:05:15,120 --> 00:05:17,220
touch this memory but it's literally

130
00:05:17,220 --> 00:05:19,400
data that we're leaking if we continue

131
00:05:19,400 --> 00:05:22,680
to leak data we are continuing to leak

132
00:05:22,680 --> 00:05:24,900
to architecturally leak just by dumping

133
00:05:24,900 --> 00:05:27,960
the epic style values in the CPU and we

134
00:05:27,960 --> 00:05:30,060
can see data that is leaked but also we

135
00:05:30,060 --> 00:05:33,000
can like continue and see other stuff

136
00:05:33,000 --> 00:05:36,000
and in this case it's instructions we

137
00:05:36,000 --> 00:05:38,460
can even disassemble that and see that

138
00:05:38,460 --> 00:05:40,440
okay we're leaking data we're rigging

139
00:05:40,440 --> 00:05:43,320
instruction what is happening

140
00:05:43,320 --> 00:05:46,139
we are literally reading undefined

141
00:05:46,139 --> 00:05:48,900
ranges in the Epic and we are seeing

142
00:05:48,900 --> 00:05:51,419
data that shouldn't be there and okay on

143
00:05:51,419 --> 00:05:52,919
most CPUs

144
00:05:52,919 --> 00:05:55,199
this is not doing much okay you either

145
00:05:55,199 --> 00:05:58,620
read zeros or F's or even the CPU hangs

146
00:05:58,620 --> 00:06:01,500
or even triple filter results itself but

147
00:06:01,500 --> 00:06:03,840
on some of the newer CPUs

148
00:06:03,840 --> 00:06:07,139
you see data and you leak stuff

149
00:06:07,139 --> 00:06:09,479
so we should try to understand okay but

150
00:06:09,479 --> 00:06:11,340
what is happening what data are we

151
00:06:11,340 --> 00:06:13,320
seeing now where are we living from and

152
00:06:13,320 --> 00:06:15,060
we are trying to like we can try to

153
00:06:15,060 --> 00:06:19,199
design experiments that try to tell us

154
00:06:19,199 --> 00:06:22,740
okay here we see the data is arriving

155
00:06:22,740 --> 00:06:26,100
from this like region inside the CPU

156
00:06:26,100 --> 00:06:27,840
every single one of these experiments

157
00:06:27,840 --> 00:06:31,280
let's like will allow us to like remove

158
00:06:31,280 --> 00:06:34,020
hypotheses from where we delete data

159
00:06:34,020 --> 00:06:37,080
from so we can start by trying to for

160
00:06:37,080 --> 00:06:39,660
example have some data kept in register

161
00:06:39,660 --> 00:06:41,940
do some I don't know arithmetic

162
00:06:41,940 --> 00:06:44,160
computation in the data and try to dump

163
00:06:44,160 --> 00:06:46,080
the Epic to see if we are leaking those

164
00:06:46,080 --> 00:06:47,940
data that you are Computing from and

165
00:06:47,940 --> 00:06:49,380
this doesn't happen

166
00:06:49,380 --> 00:06:52,020
we can continue and try to leak data

167
00:06:52,020 --> 00:06:54,419
from the caches maybe do some like

168
00:06:54,419 --> 00:06:58,080
memory read the memory right that like I

169
00:06:58,080 --> 00:06:59,819
don't know touches memory but not that

170
00:06:59,819 --> 00:07:01,860
much memory that got flushed by the

171
00:07:01,860 --> 00:07:04,620
cache and here we still don't see that

172
00:07:04,620 --> 00:07:05,880
data

173
00:07:05,880 --> 00:07:08,460
we can do more and we can try to to see

174
00:07:08,460 --> 00:07:11,699
if we can leak data from other CPU cores

175
00:07:11,699 --> 00:07:14,220
and from those course we still don't see

176
00:07:14,220 --> 00:07:16,259
that memory but the problem is that we

177
00:07:16,259 --> 00:07:18,960
are seeing data so what are we reading

178
00:07:18,960 --> 00:07:21,960
and the like the answer is okay we're

179
00:07:21,960 --> 00:07:23,759
literally leaking from the component in

180
00:07:23,759 --> 00:07:26,340
the middle we only leak data when we

181
00:07:26,340 --> 00:07:28,440
have some eviction that goes from the L2

182
00:07:28,440 --> 00:07:30,960
to the LSC cache and every time data

183
00:07:30,960 --> 00:07:32,819
passes through those caches

184
00:07:32,819 --> 00:07:35,880
we see that and we can lick that and

185
00:07:35,880 --> 00:07:38,400
this component is the super queue no one

186
00:07:38,400 --> 00:07:40,080
knows what the super queue is I didn't

187
00:07:40,080 --> 00:07:41,759
know either but basically the super

188
00:07:41,759 --> 00:07:43,319
queue is like a decoupling buffer

189
00:07:43,319 --> 00:07:45,840
between the L2 and the last level cache

190
00:07:45,840 --> 00:07:47,759
and this the goblin buffer is used as a

191
00:07:47,759 --> 00:07:50,039
performance optimizations and entries

192
00:07:50,039 --> 00:07:52,199
and entries in this the goblin buffer

193
00:07:52,199 --> 00:07:55,919
are reserved by the CPU and use

194
00:07:55,919 --> 00:07:58,319
so this this buffer as I said like

195
00:07:58,319 --> 00:08:01,560
contains data and is if you're like if

196
00:08:01,560 --> 00:08:03,419
you know like MDS attacks they were like

197
00:08:03,419 --> 00:08:05,220
leaking data from line field buffers

198
00:08:05,220 --> 00:08:07,319
this is like landfill buffers between

199
00:08:07,319 --> 00:08:09,960
the S1 and L2 cache

200
00:08:09,960 --> 00:08:12,120
now the the question is

201
00:08:12,120 --> 00:08:14,160
what is happening here we are leaking

202
00:08:14,160 --> 00:08:15,960
data that is contained in the super

203
00:08:15,960 --> 00:08:18,120
queue we should try to understand okay

204
00:08:18,120 --> 00:08:20,460
what kind of data are we leaking

205
00:08:20,460 --> 00:08:23,879
and as we as we mentioned we only leak

206
00:08:23,879 --> 00:08:25,800
from those undefined Ranger ranges in

207
00:08:25,800 --> 00:08:28,500
the avicmio region so first of all we

208
00:08:28,500 --> 00:08:31,259
cannot leak from the like zero to Fourth

209
00:08:31,259 --> 00:08:33,360
byte of every cache line since those

210
00:08:33,360 --> 00:08:35,700
bytes if you try to read the Epic MMA

211
00:08:35,700 --> 00:08:37,440
region from those bytes

212
00:08:37,440 --> 00:08:39,539
you will just read the defined values in

213
00:08:39,539 --> 00:08:41,700
the Epic so you cannot lick these those

214
00:08:41,700 --> 00:08:43,020
bytes

215
00:08:43,020 --> 00:08:44,520
and

216
00:08:44,520 --> 00:08:48,240
I have no idea why but we only observe

217
00:08:48,240 --> 00:08:51,779
data that is in even cache lines

218
00:08:51,779 --> 00:08:53,940
this is very strange we don't have an

219
00:08:53,940 --> 00:08:55,980
answer to that but the only data like to

220
00:08:55,980 --> 00:08:57,660
observe while we're living with epic MMA

221
00:08:57,660 --> 00:09:00,420
like dumping the Arabic mmio it's only

222
00:09:00,420 --> 00:09:03,000
in even cache lines but this is I will

223
00:09:03,000 --> 00:09:05,220
demonstrate that this is way enough to

224
00:09:05,220 --> 00:09:08,100
like own a system

225
00:09:08,100 --> 00:09:10,560
so we know that we leak data from this

226
00:09:10,560 --> 00:09:12,360
work queue

227
00:09:12,360 --> 00:09:14,279
the super queue is this buffer that is

228
00:09:14,279 --> 00:09:15,600
contained in the middle and every time

229
00:09:15,600 --> 00:09:18,720
data is there we are linking those data

230
00:09:18,720 --> 00:09:21,000
if we think about it

231
00:09:21,000 --> 00:09:23,220
what is happening inside the CPU is that

232
00:09:23,220 --> 00:09:25,260
the CPU is reserving entries in the

233
00:09:25,260 --> 00:09:27,839
super queue to give you the answer for

234
00:09:27,839 --> 00:09:29,339
the data that you're requesting for from

235
00:09:29,339 --> 00:09:31,380
the Epic mmao region

236
00:09:31,380 --> 00:09:33,839
but what should what should you like

237
00:09:33,839 --> 00:09:35,700
when you're like programming something

238
00:09:35,700 --> 00:09:37,740
like that you are reserving an entry you

239
00:09:37,740 --> 00:09:39,899
should initialize the entry to zero and

240
00:09:39,899 --> 00:09:41,640
then override the parts and what is

241
00:09:41,640 --> 00:09:43,500
happening here is that the CPU is

242
00:09:43,500 --> 00:09:46,980
returning uninitialized data from like

243
00:09:46,980 --> 00:09:48,959
an internal CPU buffer that it gets

244
00:09:48,959 --> 00:09:51,600
reserved for the memory request and what

245
00:09:51,600 --> 00:09:52,920
is happening is that it doesn't

246
00:09:52,920 --> 00:09:55,980
initialize all the entries in this entry

247
00:09:55,980 --> 00:09:59,160
that is giving back to you and only one

248
00:09:59,160 --> 00:10:01,740
entry gets ridden that's defined epic my

249
00:10:01,740 --> 00:10:02,820
oranges

250
00:10:02,820 --> 00:10:04,980
and the other entry contains an

251
00:10:04,980 --> 00:10:06,959
initialized data and that's the data

252
00:10:06,959 --> 00:10:10,560
that you get and you leak from

253
00:10:10,560 --> 00:10:12,839
but the problem here is that okay this

254
00:10:12,839 --> 00:10:14,160
attack is very very good you can

255
00:10:14,160 --> 00:10:16,440
literally dump a region from physical

256
00:10:16,440 --> 00:10:18,779
memory and leak data

257
00:10:18,779 --> 00:10:21,360
but the problem is that as I said you

258
00:10:21,360 --> 00:10:23,760
need to access physical memory so you

259
00:10:23,760 --> 00:10:26,519
need to map the Epic MMI origin and the

260
00:10:26,519 --> 00:10:28,339
Epic memory origin is like a really

261
00:10:28,339 --> 00:10:31,800
privileged area inside the CPU and to

262
00:10:31,800 --> 00:10:34,620
access that you you have to Maps like

263
00:10:34,620 --> 00:10:36,600
physically that memory so you have to be

264
00:10:36,600 --> 00:10:38,339
uttering zero

265
00:10:38,339 --> 00:10:40,560
so this seems like a very powerful

266
00:10:40,560 --> 00:10:42,839
attack but you need like kernel

267
00:10:42,839 --> 00:10:46,200
Primitives to leak those data so is this

268
00:10:46,200 --> 00:10:49,800
useless I think here like the CPU world

269
00:10:49,800 --> 00:10:52,260
was very lucky that such a powerful

270
00:10:52,260 --> 00:10:55,019
vulnerabilities was prevented

271
00:10:55,019 --> 00:10:57,420
just by the fact that this is a

272
00:10:57,420 --> 00:11:00,540
privileged area but okay we need a

273
00:11:00,540 --> 00:11:02,880
kernel to leak those data but there is

274
00:11:02,880 --> 00:11:04,680
something that in the CPU should protect

275
00:11:04,680 --> 00:11:07,140
you even from kernel attackers

276
00:11:07,140 --> 00:11:10,260
and that's oh come on and that's data

277
00:11:10,260 --> 00:11:13,500
that is in sgx and clays as Jack's

278
00:11:13,500 --> 00:11:17,040
enclaves in the in CPUs are this uh I

279
00:11:17,040 --> 00:11:19,980
would say special region in memory that

280
00:11:19,980 --> 00:11:22,980
should you protect you even if you don't

281
00:11:22,980 --> 00:11:24,899
trust even the operating system or the

282
00:11:24,899 --> 00:11:27,360
hypervisor let's think about it if you I

283
00:11:27,360 --> 00:11:28,320
don't know

284
00:11:28,320 --> 00:11:32,399
rent a server on AWS or Google Cloud if

285
00:11:32,399 --> 00:11:33,959
you want your data to be secure even

286
00:11:33,959 --> 00:11:36,000
against Google Cloud you will lose an

287
00:11:36,000 --> 00:11:38,579
sgx enclave so that those data cannot be

288
00:11:38,579 --> 00:11:42,120
leaked even from a malicious supervisor

289
00:11:42,120 --> 00:11:46,140
so what is uh like sjx in a nutshell it

290
00:11:46,140 --> 00:11:48,720
just like isolated environment that

291
00:11:48,720 --> 00:11:50,640
should protect you from any kind of

292
00:11:50,640 --> 00:11:53,880
attacker even the most privileged ones

293
00:11:53,880 --> 00:11:55,320
it

294
00:11:55,320 --> 00:11:57,899
come on but it's okay it transparently

295
00:11:57,899 --> 00:11:59,700
creeps those pages

296
00:11:59,700 --> 00:12:01,740
that are the one that should be

297
00:12:01,740 --> 00:12:04,560
protected it's like it reserves a region

298
00:12:04,560 --> 00:12:07,140
in the physical memory that's called APC

299
00:12:07,140 --> 00:12:10,680
and cleft page cache and those memory

300
00:12:10,680 --> 00:12:12,600
regions are transparently encrypted

301
00:12:12,600 --> 00:12:14,339
meaning that if you read those memory

302
00:12:14,339 --> 00:12:16,560
region outside of an enclave you will

303
00:12:16,560 --> 00:12:18,899
read garbage data while if you read

304
00:12:18,899 --> 00:12:21,240
those region inside an enclave you will

305
00:12:21,240 --> 00:12:24,540
read actual data and these Pages can be

306
00:12:24,540 --> 00:12:27,180
moved between The Enclave page cache and

307
00:12:27,180 --> 00:12:30,660
ROM by particular instructions

308
00:12:30,660 --> 00:12:33,000
moreover these enclaves are like

309
00:12:33,000 --> 00:12:35,399
lightweight processes so they need to

310
00:12:35,399 --> 00:12:37,620
manage interrupts and like this kind of

311
00:12:37,620 --> 00:12:39,720
stuff that can happen to processes so

312
00:12:39,720 --> 00:12:41,640
they even use a safe state area so that

313
00:12:41,640 --> 00:12:43,139
the registers that are using during the

314
00:12:43,139 --> 00:12:46,680
execution are protected and saved in the

315
00:12:46,680 --> 00:12:49,440
APC so that even if the for example

316
00:12:49,440 --> 00:12:51,180
librarian system constantly interrupts

317
00:12:51,180 --> 00:12:53,399
The Enclave cannot read the register

318
00:12:53,399 --> 00:12:55,019
values

319
00:12:55,019 --> 00:12:57,959
I will use this since I'm done with this

320
00:12:57,959 --> 00:13:01,860
so this registers this SSA region

321
00:13:01,860 --> 00:13:04,019
stores The Enclave State during context

322
00:13:04,019 --> 00:13:07,139
switches and it even includes registered

323
00:13:07,139 --> 00:13:09,180
values

324
00:13:09,180 --> 00:13:11,339
so we already know that we can sample

325
00:13:11,339 --> 00:13:13,860
from sgx enclaves just using the

326
00:13:13,860 --> 00:13:15,839
exposure to show you before you can

327
00:13:15,839 --> 00:13:17,700
literally just dump the Epic while an

328
00:13:17,700 --> 00:13:19,920
enclave is running and you will get data

329
00:13:19,920 --> 00:13:22,740
that is used by The sjx Enclave

330
00:13:22,740 --> 00:13:24,779
but this is not enough come on we want

331
00:13:24,779 --> 00:13:27,959
to leak interesting data we we should

332
00:13:27,959 --> 00:13:31,139
try to think okay can we force Target

333
00:13:31,139 --> 00:13:33,120
data inside the super queue so that the

334
00:13:33,120 --> 00:13:35,100
data will be there and dumping the Epic

335
00:13:35,100 --> 00:13:37,680
mmao region you can like literally leak

336
00:13:37,680 --> 00:13:40,019
the data that you want and since reading

337
00:13:40,019 --> 00:13:42,000
the data from the Epic MMA region is

338
00:13:42,000 --> 00:13:44,459
kind of slow can we keep the data inside

339
00:13:44,459 --> 00:13:46,440
the super queue long enough that okay

340
00:13:46,440 --> 00:13:48,899
it's there but it will be there while we

341
00:13:48,899 --> 00:13:51,899
leak that from the Epic mmio region

342
00:13:51,899 --> 00:13:53,820
and to overcome both of the challenges

343
00:13:53,820 --> 00:13:56,100
we designed two different techniques

344
00:13:56,100 --> 00:13:58,800
that I will present you the first one is

345
00:13:58,800 --> 00:14:01,260
Enclave shaking

346
00:14:01,260 --> 00:14:04,260
the idea of Enclave shaking is to force

347
00:14:04,260 --> 00:14:06,300
the data that you want to leak into the

348
00:14:06,300 --> 00:14:09,240
Super queue we abuse the instructions

349
00:14:09,240 --> 00:14:13,860
that are AWB and ldu for page dropping

350
00:14:13,860 --> 00:14:15,740
so the AWB instruction

351
00:14:15,740 --> 00:14:19,560
encrypts a page from ABC and stories to

352
00:14:19,560 --> 00:14:21,180
the ROM

353
00:14:21,180 --> 00:14:23,279
and the L do instruction does the

354
00:14:23,279 --> 00:14:24,899
opposite and takes a page that was

355
00:14:24,899 --> 00:14:27,240
encrypted in Iran and puts back into the

356
00:14:27,240 --> 00:14:29,940
APC so that it can be used by an enclave

357
00:14:29,940 --> 00:14:32,100
but let's try to think what is happening

358
00:14:32,100 --> 00:14:34,320
why when we execute those instructions

359
00:14:34,320 --> 00:14:37,680
so we have our RAM and inside the ram

360
00:14:37,680 --> 00:14:39,899
there is this dedicated memory region

361
00:14:39,899 --> 00:14:42,600
that is the EPC which is encrypted by

362
00:14:42,600 --> 00:14:43,800
enclaves

363
00:14:43,800 --> 00:14:46,139
from like foreign execution that's the

364
00:14:46,139 --> 00:14:48,300
IPC and we have a page in that memory

365
00:14:48,300 --> 00:14:51,180
region when we execute the ewb

366
00:14:51,180 --> 00:14:53,760
instruction we want to put that page

367
00:14:53,760 --> 00:14:56,519
outside of the encrypted memory so that

368
00:14:56,519 --> 00:14:59,339
we can like use more memory save it swap

369
00:14:59,339 --> 00:15:01,800
it out or whatever what is happening

370
00:15:01,800 --> 00:15:03,480
here to encrypt you have to like do

371
00:15:03,480 --> 00:15:05,279
computation inside the CPU

372
00:15:05,279 --> 00:15:07,860
so it literally passes through all of

373
00:15:07,860 --> 00:15:10,440
the caches that you like you can you can

374
00:15:10,440 --> 00:15:12,360
have inside the CPU

375
00:15:12,360 --> 00:15:14,579
and what is happening it's passing

376
00:15:14,579 --> 00:15:16,980
through the super queue so we have this

377
00:15:16,980 --> 00:15:20,820
way of selecting pages in memory and by

378
00:15:20,820 --> 00:15:24,240
making let them go back and forth into

379
00:15:24,240 --> 00:15:25,800
the Super queue so that they will be

380
00:15:25,800 --> 00:15:28,680
there and we can try to force them data

381
00:15:28,680 --> 00:15:30,600
that we want to leak into the Super

382
00:15:30,600 --> 00:15:33,300
queue and same thing happens for the for

383
00:15:33,300 --> 00:15:35,040
the opposite when we have an encrypted

384
00:15:35,040 --> 00:15:38,820
pages in in the normal Ram with the LD

385
00:15:38,820 --> 00:15:41,579
instruction we can decrypt it and put it

386
00:15:41,579 --> 00:15:44,820
back in the IPC and as well here what is

387
00:15:44,820 --> 00:15:46,260
happening

388
00:15:46,260 --> 00:15:50,279
we put the page into the like uh

389
00:15:50,279 --> 00:15:51,720
into memory

390
00:15:51,720 --> 00:15:53,880
into all the caches in the super queue

391
00:15:53,880 --> 00:15:57,120
then so that we have those data that we

392
00:15:57,120 --> 00:15:58,380
can leak from

393
00:15:58,380 --> 00:16:00,779
the problem here is that we are moving

394
00:16:00,779 --> 00:16:03,779
whole pages and while we're doing this

395
00:16:03,779 --> 00:16:07,800
we we left like 4K bytes passing through

396
00:16:07,800 --> 00:16:09,660
the super queue and this is too much

397
00:16:09,660 --> 00:16:11,820
bytes to be able to lick all of them and

398
00:16:11,820 --> 00:16:13,920
lick interesting ones and the problem is

399
00:16:13,920 --> 00:16:16,560
that we may be interesting to Target

400
00:16:16,560 --> 00:16:19,620
some data that you want to leak not a

401
00:16:19,620 --> 00:16:21,660
whole page or you will be not fast

402
00:16:21,660 --> 00:16:23,940
enough to leak one single one like whole

403
00:16:23,940 --> 00:16:24,899
page

404
00:16:24,899 --> 00:16:27,300
so we also introduced cache line

405
00:16:27,300 --> 00:16:29,519
freezing

406
00:16:29,519 --> 00:16:32,220
and the idea is that okay we want to

407
00:16:32,220 --> 00:16:34,680
keep data in the super queue selecting

408
00:16:34,680 --> 00:16:36,720
the data that we want to leak long

409
00:16:36,720 --> 00:16:40,380
enough so that we can leak those data

410
00:16:40,380 --> 00:16:42,660
so as I said at the beginning

411
00:16:42,660 --> 00:16:44,699
the attack like by default doesn't

412
00:16:44,699 --> 00:16:46,560
require threat

413
00:16:46,560 --> 00:16:48,600
and if you think about it and never

414
00:16:48,600 --> 00:16:50,820
mentioned our third option now so we are

415
00:16:50,820 --> 00:16:53,040
not using the other rubber thread that's

416
00:16:53,040 --> 00:16:55,380
it since the CPU to be used for

417
00:16:55,380 --> 00:16:58,620
so we can try to optimize our attack by

418
00:16:58,620 --> 00:17:00,839
leveraging their trading so we don't

419
00:17:00,839 --> 00:17:02,940
need double trading but we can use it to

420
00:17:02,940 --> 00:17:04,859
make our talk better

421
00:17:04,859 --> 00:17:07,559
the thing the the idea behind this is

422
00:17:07,559 --> 00:17:09,540
the super queue is shared between the

423
00:17:09,540 --> 00:17:11,520
other threads so if one of our thread is

424
00:17:11,520 --> 00:17:15,000
able to like affect the content of the

425
00:17:15,000 --> 00:17:17,220
super queue then we affect the totally

426
00:17:17,220 --> 00:17:19,199
content that we leak from those from

427
00:17:19,199 --> 00:17:22,520
those like exploits

428
00:17:22,859 --> 00:17:24,780
there is a theory here

429
00:17:24,780 --> 00:17:26,880
and that's zero block are not

430
00:17:26,880 --> 00:17:29,220
transferred over the superhero

431
00:17:29,220 --> 00:17:31,980
and this is this was a theory that

432
00:17:31,980 --> 00:17:35,580
I mean up to now it felt useless there

433
00:17:35,580 --> 00:17:37,620
was no application for this but we will

434
00:17:37,620 --> 00:17:41,400
see how we can exploit this Theory to

435
00:17:41,400 --> 00:17:45,240
leverage and selectively leak data from

436
00:17:45,240 --> 00:17:48,780
enclaves but let's try to understand how

437
00:17:48,780 --> 00:17:50,220
this works

438
00:17:50,220 --> 00:17:52,919
so we will have like in our model two

439
00:17:52,919 --> 00:17:55,919
threads that access two different memory

440
00:17:55,919 --> 00:17:57,299
areas

441
00:17:57,299 --> 00:17:59,880
let's assume that those memory areas are

442
00:17:59,880 --> 00:18:01,740
congruent in the CPU sets that they have

443
00:18:01,740 --> 00:18:04,320
in the cache sets that they have so that

444
00:18:04,320 --> 00:18:08,280
they will share the same cache lines and

445
00:18:08,280 --> 00:18:11,340
that every time we'll Access Memory they

446
00:18:11,340 --> 00:18:14,220
will contain those cache lines

447
00:18:14,220 --> 00:18:16,320
so we will have thread one that is

448
00:18:16,320 --> 00:18:18,600
accessing one data and this wants to

449
00:18:18,600 --> 00:18:21,419
load the secret to access like uh it

450
00:18:21,419 --> 00:18:22,740
wants to load the allocation that

451
00:18:22,740 --> 00:18:25,200
contains a secret to access it just for

452
00:18:25,200 --> 00:18:27,660
like his own computations

453
00:18:27,660 --> 00:18:30,360
and what is happening here the cigarette

454
00:18:30,360 --> 00:18:33,059
gets loaded in the super queue

455
00:18:33,059 --> 00:18:35,760
then it gets loaded in the caches

456
00:18:35,760 --> 00:18:38,100
and then gets accessed

457
00:18:38,100 --> 00:18:40,320
now we have our second thread

458
00:18:40,320 --> 00:18:43,320
addresses

459
00:18:44,880 --> 00:18:46,799
and here

460
00:18:46,799 --> 00:18:48,600
loads the data in the super queue they

461
00:18:48,600 --> 00:18:51,480
will contend on the cache line so also

462
00:18:51,480 --> 00:18:53,880
on the super queue lines

463
00:18:53,880 --> 00:18:56,700
it will load the cache

464
00:18:56,700 --> 00:18:59,340
and it will access but

465
00:18:59,340 --> 00:19:01,620
we did nothing here right we just

466
00:19:01,620 --> 00:19:03,840
overridden our secrets like what the

467
00:19:03,840 --> 00:19:05,760
 did we obtain nothing

468
00:19:05,760 --> 00:19:07,620
but we can be smarter

469
00:19:07,620 --> 00:19:10,140
what if our data is zero what if the

470
00:19:10,140 --> 00:19:11,400
attacker threat

471
00:19:11,400 --> 00:19:13,500
data is zero

472
00:19:13,500 --> 00:19:15,600
so we remember that we have this theory

473
00:19:15,600 --> 00:19:18,059
that the zeros are not transferred

474
00:19:18,059 --> 00:19:20,280
through the super queue so let's do this

475
00:19:20,280 --> 00:19:22,740
this whole thing again the first thread

476
00:19:22,740 --> 00:19:25,260
the victim thread access to cigarette it

477
00:19:25,260 --> 00:19:26,940
will load in the super queue it will

478
00:19:26,940 --> 00:19:29,820
load in the cache and it will access it

479
00:19:29,820 --> 00:19:32,220
then we have our second thread going to

480
00:19:32,220 --> 00:19:34,860
like to execute

481
00:19:34,860 --> 00:19:37,679
it will load the zero but now

482
00:19:37,679 --> 00:19:40,440
what happens the zero will not be loaded

483
00:19:40,440 --> 00:19:41,700
in the super queue

484
00:19:41,700 --> 00:19:43,860
actually there will be something

485
00:19:43,860 --> 00:19:45,720
probably like one bit inside the

486
00:19:45,720 --> 00:19:48,840
supercum metadata that says okay there

487
00:19:48,840 --> 00:19:51,720
is no reason to like write zeros here

488
00:19:51,720 --> 00:19:54,120
and then forward them since if the whole

489
00:19:54,120 --> 00:19:56,280
cache if the whole super queue line is

490
00:19:56,280 --> 00:19:59,100
zeros then you know that it's zeros why

491
00:19:59,100 --> 00:20:00,780
should you like waste time into writing

492
00:20:00,780 --> 00:20:03,059
that so that's like a really small

493
00:20:03,059 --> 00:20:05,100
optimization since optimization inside

494
00:20:05,100 --> 00:20:07,080
the CPUs

495
00:20:07,080 --> 00:20:10,080
but here what is happening the secret is

496
00:20:10,080 --> 00:20:13,380
not overridden when we access our data

497
00:20:13,380 --> 00:20:16,020
then okay the information that this was

498
00:20:16,020 --> 00:20:18,299
Zero will be forwarded

499
00:20:18,299 --> 00:20:20,039
no idea what's happening in the caches

500
00:20:20,039 --> 00:20:22,080
if the zero is written there or just

501
00:20:22,080 --> 00:20:23,340
forwarded

502
00:20:23,340 --> 00:20:26,520
but eventually the zero will arrive to

503
00:20:26,520 --> 00:20:29,640
the threat too but what we did here is

504
00:20:29,640 --> 00:20:32,400
to freeze a cigarette inside the cache

505
00:20:32,400 --> 00:20:34,919
line and inside the super queue so as

506
00:20:34,919 --> 00:20:37,919
long as we keep accessing our zero data

507
00:20:37,919 --> 00:20:40,679
the data there will be stuck inside the

508
00:20:40,679 --> 00:20:44,720
super queue and can't move anymore

509
00:20:44,880 --> 00:20:47,220
so these are the two techniques that

510
00:20:47,220 --> 00:20:49,980
make happy click possible and make us

511
00:20:49,980 --> 00:20:53,700
possible to choose precisely what do we

512
00:20:53,700 --> 00:20:55,860
want to leak and exactly

513
00:20:55,860 --> 00:20:59,460
when we want to lick it and what

514
00:20:59,460 --> 00:21:01,860
so the whole attack okay is very

515
00:21:01,860 --> 00:21:04,320
difficult as a figure not sure if it's

516
00:21:04,320 --> 00:21:05,520
understandable

517
00:21:05,520 --> 00:21:07,320
but the whole attack here is basically

518
00:21:07,320 --> 00:21:09,059
combine the two techniques that I

519
00:21:09,059 --> 00:21:11,220
explained before we have Enclave shaking

520
00:21:11,220 --> 00:21:14,039
to make whole pages from like sgx

521
00:21:14,039 --> 00:21:16,260
sineclaves go back and forth from the

522
00:21:16,260 --> 00:21:18,780
memory to the to the super queue through

523
00:21:18,780 --> 00:21:20,940
the super queue to the CPU so that the

524
00:21:20,940 --> 00:21:24,059
pages will like work uh inside the

525
00:21:24,059 --> 00:21:25,679
memory and then we will have cache line

526
00:21:25,679 --> 00:21:28,260
freezing that let us select a particular

527
00:21:28,260 --> 00:21:31,620
cache line that we want to freeze inside

528
00:21:31,620 --> 00:21:33,539
the CPU

529
00:21:33,539 --> 00:21:36,539
inside sorry the the super queue

530
00:21:36,539 --> 00:21:39,720
what can you do with this as we said we

531
00:21:39,720 --> 00:21:41,460
can leak three quarters

532
00:21:41,460 --> 00:21:43,740
of even Cash Line

533
00:21:43,740 --> 00:21:47,460
from any arbitrary sgx page

534
00:21:47,460 --> 00:21:49,919
so that you can literally select which

535
00:21:49,919 --> 00:21:51,900
page

536
00:21:51,900 --> 00:21:55,080
which cache line to leak data from and

537
00:21:55,080 --> 00:21:57,720
you can notice all of this we never add

538
00:21:57,720 --> 00:21:59,340
The Enclave running

539
00:21:59,340 --> 00:22:01,320
it's just sufficient that the data of

540
00:22:01,320 --> 00:22:03,059
The Enclave is in memory we don't need

541
00:22:03,059 --> 00:22:04,679
the Enclave running we just we are

542
00:22:04,679 --> 00:22:07,380
leaking data from the static data that

543
00:22:07,380 --> 00:22:09,360
is there in memory we don't need the

544
00:22:09,360 --> 00:22:11,760
Enclave to access the data we can force

545
00:22:11,760 --> 00:22:16,100
the data to be accessed from The Enclave

546
00:22:16,260 --> 00:22:18,360
so the first idea okay let's let's

547
00:22:18,360 --> 00:22:19,679
exploit this

548
00:22:19,679 --> 00:22:22,020
we want to start it and we want to leak

549
00:22:22,020 --> 00:22:24,419
for example data and cut pages from the

550
00:22:24,419 --> 00:22:26,820
enclave and how can we do that

551
00:22:26,820 --> 00:22:29,400
first of all we just start the enclave

552
00:22:29,400 --> 00:22:31,440
and we make the enclave

553
00:22:31,440 --> 00:22:34,140
to reach the precise point where we want

554
00:22:34,140 --> 00:22:36,900
to lick that data

555
00:22:36,900 --> 00:22:39,659
when the precise point is Rich for

556
00:22:39,659 --> 00:22:41,280
example The Enclave may be have

557
00:22:41,280 --> 00:22:43,860
generated private keys or has downloaded

558
00:22:43,860 --> 00:22:45,840
private Keys like encrypted from the

559
00:22:45,840 --> 00:22:47,880
internet and the grips of them

560
00:22:47,880 --> 00:22:50,220
we just want the Enclave to reach the

561
00:22:50,220 --> 00:22:51,780
point where we know the data is there

562
00:22:51,780 --> 00:22:53,220
and we can lick that

563
00:22:53,220 --> 00:22:55,020
and then what we do we just do the

564
00:22:55,020 --> 00:22:56,760
techniques that we saw before we move

565
00:22:56,760 --> 00:22:59,940
the page out of the APC so that the data

566
00:22:59,940 --> 00:23:02,520
will pass through the super queue and in

567
00:23:02,520 --> 00:23:04,200
a parallel average thread we will do

568
00:23:04,200 --> 00:23:05,700
cache line freezing so that the data

569
00:23:05,700 --> 00:23:08,580
gets freezed while it's passing so that

570
00:23:08,580 --> 00:23:12,000
there will have our data then what we do

571
00:23:12,000 --> 00:23:15,179
we just dump there becoming my origin

572
00:23:15,179 --> 00:23:16,559
dumping that

573
00:23:16,559 --> 00:23:19,380
we leak at the data that is there

574
00:23:19,380 --> 00:23:21,480
and we will see the data that we want to

575
00:23:21,480 --> 00:23:22,380
leak

576
00:23:22,380 --> 00:23:25,080
then we want to repeat that process to

577
00:23:25,080 --> 00:23:27,720
be I don't know more confident that we

578
00:23:27,720 --> 00:23:29,700
leaked the right data and do it more

579
00:23:29,700 --> 00:23:32,159
than once for example we move the page

580
00:23:32,159 --> 00:23:34,380
back into memory

581
00:23:34,380 --> 00:23:37,020
and repeat all of that

582
00:23:37,020 --> 00:23:40,799
so we have an iterative way to leak the

583
00:23:40,799 --> 00:23:42,780
data that we want to select from sgx

584
00:23:42,780 --> 00:23:43,799
enclase

585
00:23:43,799 --> 00:23:47,520
architecturally and deterministically

586
00:23:47,520 --> 00:23:50,280
we can do even more as I was saying at

587
00:23:50,280 --> 00:23:51,120
the beginning

588
00:23:51,120 --> 00:23:54,419
as Jackson enclaves use SSA region to

589
00:23:54,419 --> 00:23:56,840
save the register so what if okay

590
00:23:56,840 --> 00:23:59,700
Enclave Riders get smarter let's not

591
00:23:59,700 --> 00:24:02,159
have like data in memory let's only use

592
00:24:02,159 --> 00:24:04,679
registers

593
00:24:04,679 --> 00:24:06,539
the problem there is that those

594
00:24:06,539 --> 00:24:07,799
registers

595
00:24:07,799 --> 00:24:10,320
will be dumped in memory when an

596
00:24:10,320 --> 00:24:12,720
interrupt is received by The sdx Enclave

597
00:24:12,720 --> 00:24:15,480
so that we do the same exact exploit

598
00:24:15,480 --> 00:24:17,280
we start The Enclave stop at the right

599
00:24:17,280 --> 00:24:20,580
moment move the SSA page this time not

600
00:24:20,580 --> 00:24:24,179
update our code page out and back into

601
00:24:24,179 --> 00:24:26,100
the memory while performing Cash Line

602
00:24:26,100 --> 00:24:27,780
freezing to freeze the data that we want

603
00:24:27,780 --> 00:24:30,600
to leak and then we can leak that just

604
00:24:30,600 --> 00:24:32,580
by dumping the Epic mmao region and

605
00:24:32,580 --> 00:24:33,780
remove it

606
00:24:33,780 --> 00:24:35,340
so unfortunately we're going to click

607
00:24:35,340 --> 00:24:37,679
all the registers and this is due to the

608
00:24:37,679 --> 00:24:40,260
fact that we can only leak cache lines

609
00:24:40,260 --> 00:24:42,539
that are even entry quarters of those

610
00:24:42,539 --> 00:24:44,880
cache lines and in the table you see the

611
00:24:44,880 --> 00:24:46,740
registers that we can leak

612
00:24:46,740 --> 00:24:49,679
but those registers are for example most

613
00:24:49,679 --> 00:24:52,620
of the like vector registers that are

614
00:24:52,620 --> 00:24:55,679
used for AES encryptions for example or

615
00:24:55,679 --> 00:24:57,960
general passports like most of the

616
00:24:57,960 --> 00:25:00,720
general passport part purpose

617
00:25:00,720 --> 00:25:03,299
registers that are used by this view so

618
00:25:03,299 --> 00:25:05,340
we can leak all those registers

619
00:25:05,340 --> 00:25:07,919
and we want to see this in practice I

620
00:25:07,919 --> 00:25:09,240
would say

621
00:25:09,240 --> 00:25:12,179
so here we have an enclave and we just

622
00:25:12,179 --> 00:25:14,039
start it

623
00:25:14,039 --> 00:25:17,940
and then we dump it that's it

624
00:25:17,940 --> 00:25:19,860
what is happening here okay this was

625
00:25:19,860 --> 00:25:22,559
very fast but what is happening here

626
00:25:22,559 --> 00:25:24,240
we made The Enclave to reach the point

627
00:25:24,240 --> 00:25:27,299
where the data is loaded in memory

628
00:25:27,299 --> 00:25:30,299
and then we dump the page as we were

629
00:25:30,299 --> 00:25:32,880
seeing just by dumping the page in the

630
00:25:32,880 --> 00:25:35,220
Epic MMA region and influencing what

631
00:25:35,220 --> 00:25:37,919
page are we looking from we can see that

632
00:25:37,919 --> 00:25:39,840
we leaked the data that The Enclave was

633
00:25:39,840 --> 00:25:41,580
Computing on

634
00:25:41,580 --> 00:25:43,380
and I don't know if you saw that but

635
00:25:43,380 --> 00:25:46,140
that was immediate that's why we are not

636
00:25:46,140 --> 00:25:48,419
using aside Channel or any Transit

637
00:25:48,419 --> 00:25:50,460
execution attack we'll just execute the

638
00:25:50,460 --> 00:25:51,480
enclave

639
00:25:51,480 --> 00:25:53,940
and dump it and that's it

640
00:25:53,940 --> 00:25:56,100
we can do more okay what if the data is

641
00:25:56,100 --> 00:25:58,760
in the registers

642
00:25:59,039 --> 00:26:00,720
we do the same

643
00:26:00,720 --> 00:26:02,820
and this was even faster

644
00:26:02,820 --> 00:26:05,220
we just execute The Enclave stop it at

645
00:26:05,220 --> 00:26:07,380
the right moment down to the Epic memory

646
00:26:07,380 --> 00:26:09,779
region while pointing at the right

647
00:26:09,779 --> 00:26:11,460
location that we want to do but we want

648
00:26:11,460 --> 00:26:14,360
to leak through cash flow and freezing

649
00:26:14,360 --> 00:26:17,760
and that's it it was literally like that

650
00:26:17,760 --> 00:26:21,299
we just executed dump it and we did our

651
00:26:21,299 --> 00:26:22,320
exploit

652
00:26:22,320 --> 00:26:26,600
and I would say that that was super fast

653
00:26:29,220 --> 00:26:33,720
so what can we do with that

654
00:26:33,720 --> 00:26:36,840
I would say if I would have to think

655
00:26:36,840 --> 00:26:38,400
about it

656
00:26:38,400 --> 00:26:40,200
my recommendation will be okay let's

657
00:26:40,200 --> 00:26:43,500
just disable epic MMI origin this is a

658
00:26:43,500 --> 00:26:45,539
region that is not needed there are

659
00:26:45,539 --> 00:26:48,059
faster so this is the default

660
00:26:48,059 --> 00:26:50,700
epic controlling region but there are

661
00:26:50,700 --> 00:26:52,500
faster way to control an Avic that are

662
00:26:52,500 --> 00:26:55,200
not needed that are like more efficient

663
00:26:55,200 --> 00:26:57,960
so if you can just disable it then we're

664
00:26:57,960 --> 00:26:59,880
done we don't have any more that region

665
00:26:59,880 --> 00:27:01,919
that's leaking data

666
00:27:01,919 --> 00:27:03,779
Interstate no

667
00:27:03,779 --> 00:27:06,000
since they don't want to deprecate stuff

668
00:27:06,000 --> 00:27:08,279
so they release a My Group update

669
00:27:08,279 --> 00:27:10,559
this magical update just flushes the

670
00:27:10,559 --> 00:27:13,260
super queue on sdx transitions

671
00:27:13,260 --> 00:27:15,900
this means

672
00:27:15,900 --> 00:27:20,100
if you have like a CPU that is like uh

673
00:27:20,100 --> 00:27:21,840
affected by this vulnerability the

674
00:27:21,840 --> 00:27:24,000
vulnerability is still there if you dump

675
00:27:24,000 --> 00:27:26,039
the Epic you will still lick the super

676
00:27:26,039 --> 00:27:29,400
queue but what Intel did is just

677
00:27:29,400 --> 00:27:32,820
flush the super Q in sgx transition so

678
00:27:32,820 --> 00:27:35,820
that sgx data will not be there when you

679
00:27:35,820 --> 00:27:38,880
leak it but you can see leak data

680
00:27:38,880 --> 00:27:40,260
and obviously

681
00:27:40,260 --> 00:27:43,260
again Intel recommends to disable hyper

682
00:27:43,260 --> 00:27:44,279
threading

683
00:27:44,279 --> 00:27:47,039
since if you like League it in parallel

684
00:27:47,039 --> 00:27:49,980
you will not be fast enough as a

685
00:27:49,980 --> 00:27:51,360
mitigation to flush the super queue

686
00:27:51,360 --> 00:27:54,659
before the other ever thread leaks the

687
00:27:54,659 --> 00:27:55,980
data

688
00:27:55,980 --> 00:27:58,860
so that's the recommended mediation

689
00:27:58,860 --> 00:28:00,900
for who's interested this is the

690
00:28:00,900 --> 00:28:02,460
timeline this attack was discovered in

691
00:28:02,460 --> 00:28:05,940
December 2021 and it undergo a super

692
00:28:05,940 --> 00:28:08,580
long Embargo of almost like one year I

693
00:28:08,580 --> 00:28:10,679
would say we eventually were able to

694
00:28:10,679 --> 00:28:13,919
present it in Augusta black at USA where

695
00:28:13,919 --> 00:28:16,020
we like Intel the day before at the

696
00:28:16,020 --> 00:28:18,000
public release of the attack

697
00:28:18,000 --> 00:28:20,220
but I would say this was like a super

698
00:28:20,220 --> 00:28:22,620
long embargo that was needed to be able

699
00:28:22,620 --> 00:28:25,799
to fix the vulnerability even if they

700
00:28:25,799 --> 00:28:29,100
just flushed their like internal caches

701
00:28:29,100 --> 00:28:31,440
now I will I would like to conclude with

702
00:28:31,440 --> 00:28:33,000
like

703
00:28:33,000 --> 00:28:34,740
a thought

704
00:28:34,740 --> 00:28:38,940
we saw a lot of Hardware vulnerabilities

705
00:28:38,940 --> 00:28:41,340
and we saw like a lot of issues that

706
00:28:41,340 --> 00:28:43,140
were affecting CPUs

707
00:28:43,140 --> 00:28:46,200
we can try to okay see what's the root

708
00:28:46,200 --> 00:28:48,360
cause of those issues what is happening

709
00:28:48,360 --> 00:28:51,419
here in CPUs like why there are so many

710
00:28:51,419 --> 00:28:52,380
bugs

711
00:28:52,380 --> 00:28:53,880
if we think about existing

712
00:28:53,880 --> 00:28:56,039
vulnerabilities now let's not do it too

713
00:28:56,039 --> 00:28:59,880
too much detail but like Zone below that

714
00:28:59,880 --> 00:29:01,860
was leaking from like line field buffers

715
00:29:01,860 --> 00:29:04,740
was literally used after Free lime field

716
00:29:04,740 --> 00:29:07,200
buffers were allocated and then they are

717
00:29:07,200 --> 00:29:09,120
located by this view so used from other

718
00:29:09,120 --> 00:29:10,440
data

719
00:29:10,440 --> 00:29:12,720
but they were also used

720
00:29:12,720 --> 00:29:15,380
still used

721
00:29:16,140 --> 00:29:18,600
and this was simply meaning that when

722
00:29:18,600 --> 00:29:20,940
you will access them you will leak data

723
00:29:20,940 --> 00:29:23,460
so it was literally a software use of

724
00:29:23,460 --> 00:29:26,039
the free in the hardware

725
00:29:26,039 --> 00:29:28,799
Spectra we could see Spectra like us as

726
00:29:28,799 --> 00:29:30,720
an out of bound operation

727
00:29:30,720 --> 00:29:33,120
you have a bound check that is not

728
00:29:33,120 --> 00:29:36,419
performed at least speculatively is not

729
00:29:36,419 --> 00:29:38,640
performed so that you will access data

730
00:29:38,640 --> 00:29:40,039
that you were not supposed to access

731
00:29:40,039 --> 00:29:43,140
this is still like as in software you

732
00:29:43,140 --> 00:29:45,179
are accessing an array over the bounce

733
00:29:45,179 --> 00:29:47,399
since you didn't do a bound check it's

734
00:29:47,399 --> 00:29:49,500
literally a softer vulnerabilities that

735
00:29:49,500 --> 00:29:51,000
we see in Hardware

736
00:29:51,000 --> 00:29:53,159
and as we said

737
00:29:53,159 --> 00:29:56,159
every click here is impropriatization

738
00:29:56,159 --> 00:29:58,200
meaning that

739
00:29:58,200 --> 00:30:00,600
you will use memory that is not

740
00:30:00,600 --> 00:30:03,899
initialized so we are seeing a lot of

741
00:30:03,899 --> 00:30:05,880
vulnerabilities in the CPU

742
00:30:05,880 --> 00:30:07,260
that are literally softer

743
00:30:07,260 --> 00:30:09,179
vulnerabilities and what's the reason

744
00:30:09,179 --> 00:30:12,179
for that is literally that Hardware is

745
00:30:12,179 --> 00:30:14,340
designed in software like RTL language

746
00:30:14,340 --> 00:30:16,860
is very long and early stuff you will

747
00:30:16,860 --> 00:30:19,140
Design and program literally your CPU

748
00:30:19,140 --> 00:30:21,000
with software

749
00:30:21,000 --> 00:30:23,100
so it's I would say predictable that we

750
00:30:23,100 --> 00:30:25,980
will see more and more of bugs that we

751
00:30:25,980 --> 00:30:28,080
have in software but at the hardware

752
00:30:28,080 --> 00:30:30,439
level

753
00:30:30,600 --> 00:30:33,179
so thank you for attending and

754
00:30:33,179 --> 00:30:35,580
today I presented the first circulatory

755
00:30:35,580 --> 00:30:37,799
CPU vulnerability that leaks data from

756
00:30:37,799 --> 00:30:39,720
the super Q and as we say it does not

757
00:30:39,720 --> 00:30:41,820
require double Trading

758
00:30:41,820 --> 00:30:44,279
and affects all like most of the most

759
00:30:44,279 --> 00:30:46,919
recent CPUs if you're like interested to

760
00:30:46,919 --> 00:30:49,500
know more we have a nice logo a website

761
00:30:49,500 --> 00:30:51,480
to check it out and a full paper that

762
00:30:51,480 --> 00:30:54,240
describes the issues like in depth thank

763
00:30:54,240 --> 00:30:55,560
you

764
00:30:55,560 --> 00:31:05,659
[Applause]

765
00:31:05,659 --> 00:31:09,380
so you say that for the exploit to work

766
00:31:09,380 --> 00:31:12,840
you need to stop the Executioner

767
00:31:12,840 --> 00:31:14,960
in the right time

768
00:31:14,960 --> 00:31:18,320
uh where is it where is it that needed

769
00:31:18,320 --> 00:31:21,840
to for the exploit work

770
00:31:21,840 --> 00:31:24,360
so you you have two issues if you want

771
00:31:24,360 --> 00:31:25,080
to

772
00:31:25,080 --> 00:31:27,240
if you want to leak from the data or if

773
00:31:27,240 --> 00:31:29,940
you want to look from the registers if

774
00:31:29,940 --> 00:31:32,159
you want to link from the data you will

775
00:31:32,159 --> 00:31:34,860
not need to be that precise you can just

776
00:31:34,860 --> 00:31:36,899
stop The Enclave when you know that the

777
00:31:36,899 --> 00:31:38,820
data is already in memory for example

778
00:31:38,820 --> 00:31:41,279
think about okay you are executing an

779
00:31:41,279 --> 00:31:43,260
enclave that does not secret data at the

780
00:31:43,260 --> 00:31:44,700
moment but you want The Enclave to

781
00:31:44,700 --> 00:31:46,740
download the data from internet for

782
00:31:46,740 --> 00:31:48,840
example or decrypt some data and you

783
00:31:48,840 --> 00:31:51,840
want to lick the decrypted data but if

784
00:31:51,840 --> 00:31:53,880
you want to lick a register you need a

785
00:31:53,880 --> 00:31:56,159
lot of precision since you're leading a

786
00:31:56,159 --> 00:31:57,840
register and the registers are like

787
00:31:57,840 --> 00:32:00,480
changed like online and every time okay

788
00:32:00,480 --> 00:32:02,460
so it's just if you want to link some

789
00:32:02,460 --> 00:32:04,919
register you will want to stop at the

790
00:32:04,919 --> 00:32:07,320
right time so you have you know that in

791
00:32:07,320 --> 00:32:09,179
some register there is no I don't know

792
00:32:09,179 --> 00:32:11,100
some special values that okay perfect

793
00:32:11,100 --> 00:32:13,080
and if you're interested in how we are

794
00:32:13,080 --> 00:32:15,299
able to stop the Enclave precisely yeah

795
00:32:15,299 --> 00:32:17,700
I was curious also about yeah we will

796
00:32:17,700 --> 00:32:19,679
leverage technique this is called sgx

797
00:32:19,679 --> 00:32:21,960
Step and basically it's

798
00:32:21,960 --> 00:32:24,779
okay The Enclave code will be placed in

799
00:32:24,779 --> 00:32:27,539
a page that is called page and you make

800
00:32:27,539 --> 00:32:30,120
that page like not executable so that

801
00:32:30,120 --> 00:32:32,640
when The Enclave will reach that page it

802
00:32:32,640 --> 00:32:34,260
will stop execution and like trigger

803
00:32:34,260 --> 00:32:35,100
fault

804
00:32:35,100 --> 00:32:36,899
so that the operating system knows that

805
00:32:36,899 --> 00:32:39,360
The Enclave is going to be executed in

806
00:32:39,360 --> 00:32:41,520
the page then you have another problem

807
00:32:41,520 --> 00:32:43,799
okay you know the page where it's

808
00:32:43,799 --> 00:32:45,240
executing but you want to know the

809
00:32:45,240 --> 00:32:46,140
extraction

810
00:32:46,140 --> 00:32:49,020
so you repeatedly Like You Can Count

811
00:32:49,020 --> 00:32:51,240
okay when The Enclave reaches that page

812
00:32:51,240 --> 00:32:53,100
how many instructions you want to stop

813
00:32:53,100 --> 00:32:55,799
The Enclave after reaching that page you

814
00:32:55,799 --> 00:32:57,899
say for example 10 instruction and then

815
00:32:57,899 --> 00:32:59,940
every time you make The Enclave execute

816
00:32:59,940 --> 00:33:01,919
a single instruction full thing so you

817
00:33:01,919 --> 00:33:03,899
count how many instruction executed and

818
00:33:03,899 --> 00:33:05,760
then you stop it and that's the only way

819
00:33:05,760 --> 00:33:07,140
this attack is

820
00:33:07,140 --> 00:33:10,140
I would say is low but okay it's not

821
00:33:10,140 --> 00:33:12,059
slow but slower than it could be since

822
00:33:12,059 --> 00:33:13,799
you have to precisely arrive at the

823
00:33:13,799 --> 00:33:15,720
point but for example for data leaking

824
00:33:15,720 --> 00:33:18,059
is like leader instant

825
00:33:18,059 --> 00:33:21,899
perfect thank you so I was wondering um

826
00:33:21,899 --> 00:33:24,480
how did you um

827
00:33:24,480 --> 00:33:26,159
why did you focus on that particular

828
00:33:26,159 --> 00:33:29,340
component of the architecture

829
00:33:29,340 --> 00:33:31,640
so this was I would say a long journey

830
00:33:31,640 --> 00:33:34,320
it started with a completely different

831
00:33:34,320 --> 00:33:36,899
like topic and torque that was the

832
00:33:36,899 --> 00:33:38,460
second black talk that they did this

833
00:33:38,460 --> 00:33:40,380
summer was basically reverse engineering

834
00:33:40,380 --> 00:33:42,539
magical good and while I was the reverse

835
00:33:42,539 --> 00:33:44,340
engineering microboard

836
00:33:44,340 --> 00:33:46,740
I thought of an exploit to leak

837
00:33:46,740 --> 00:33:49,140
decrypted macro updates and these

838
00:33:49,140 --> 00:33:51,960
decrypted my group updates were based

839
00:33:51,960 --> 00:33:54,179
basically they were saved on an internal

840
00:33:54,179 --> 00:33:55,740
buffer of the CPU

841
00:33:55,740 --> 00:33:58,320
as I like mentioned before you can move

842
00:33:58,320 --> 00:34:01,559
the Epic so I started shadowing this

843
00:34:01,559 --> 00:34:03,600
internal buffer with the Epic with an

844
00:34:03,600 --> 00:34:04,740
attack that is called like memory

845
00:34:04,740 --> 00:34:06,419
sinkhole by Christopher Thomas I don't

846
00:34:06,419 --> 00:34:08,580
know if you know him but you can Shadow

847
00:34:08,580 --> 00:34:10,859
regions of the other space moving the

848
00:34:10,859 --> 00:34:13,199
Epic while I was struggling the like

849
00:34:13,199 --> 00:34:15,359
those regions I started seeing that the

850
00:34:15,359 --> 00:34:16,440
Epic was

851
00:34:16,440 --> 00:34:18,418
not deterministic and was something

852
00:34:18,418 --> 00:34:20,159
strange was happening I didn't see

853
00:34:20,159 --> 00:34:22,379
leaking data since I was trying this on

854
00:34:22,379 --> 00:34:24,418
a CPU that is not vulnerable to every

855
00:34:24,418 --> 00:34:26,659
click but I saw the devic was like

856
00:34:26,659 --> 00:34:29,879
behaving not deterministically so I got

857
00:34:29,879 --> 00:34:32,339
back to the inter manual so oh this

858
00:34:32,339 --> 00:34:34,800
is like undefined behavior and then I

859
00:34:34,800 --> 00:34:36,659
literally took all the CPUs that I had

860
00:34:36,659 --> 00:34:39,659
at the time and then tried everywhere to

861
00:34:39,659 --> 00:34:41,879
see what is happening and then so

862
00:34:41,879 --> 00:34:44,280
that's bios data and that was the like

863
00:34:44,280 --> 00:34:46,560
warning string that was a bio string

864
00:34:46,560 --> 00:34:48,899
that I licked and so okay this is not

865
00:34:48,899 --> 00:34:51,000
supposed to be there

866
00:34:51,000 --> 00:34:52,800
but it was a long journey I would say

867
00:34:52,800 --> 00:34:54,000
yeah

868
00:34:54,000 --> 00:34:56,580
so at the end of the presentation you

869
00:34:56,580 --> 00:34:59,220
mentioned that there are bugs also

870
00:34:59,220 --> 00:35:01,440
because Hardware is designed by software

871
00:35:01,440 --> 00:35:03,420
so

872
00:35:03,420 --> 00:35:05,700
what would be your solution I know it's

873
00:35:05,700 --> 00:35:07,740
a strange question but would you change

874
00:35:07,740 --> 00:35:10,740
the approach or would you focus more on

875
00:35:10,740 --> 00:35:12,900
the software we use to design order to

876
00:35:12,900 --> 00:35:15,780
make it more secure in the pipeline

877
00:35:15,780 --> 00:35:17,880
I would say there is no right answer

878
00:35:17,880 --> 00:35:21,300
here I would say definitely you cannot

879
00:35:21,300 --> 00:35:22,859
remove the software from the hardware

880
00:35:22,859 --> 00:35:24,420
since now the hardware is too complex

881
00:35:24,420 --> 00:35:27,000
you cannot reason only on like Hardware

882
00:35:27,000 --> 00:35:29,760
signals you need some kind of software

883
00:35:29,760 --> 00:35:31,740
to design the hardware

884
00:35:31,740 --> 00:35:34,859
it's very hard so like obviously since

885
00:35:34,859 --> 00:35:36,720
you are approaching this as a black box

886
00:35:36,720 --> 00:35:39,839
you only see the CPU from the outside

887
00:35:39,839 --> 00:35:42,119
so as an Hardware vendor I would like

888
00:35:42,119 --> 00:35:44,160
invest a lot of money but I think they

889
00:35:44,160 --> 00:35:46,800
are doing that into testing via software

890
00:35:46,800 --> 00:35:49,560
what you're making Hardware off so via

891
00:35:49,560 --> 00:35:52,440
fighting or sonic analysis or trying to

892
00:35:52,440 --> 00:35:54,119
prove that your implementation is

893
00:35:54,119 --> 00:35:56,280
correct or something like that I know

894
00:35:56,280 --> 00:35:59,400
they are doing that kind of but maybe

895
00:35:59,400 --> 00:36:02,339
it's not that effective I don't know but

896
00:36:02,339 --> 00:36:05,460
it's very complex like it's billions and

897
00:36:05,460 --> 00:36:07,380
billions of components inside the CPU so

898
00:36:07,380 --> 00:36:10,920
it's I would say most of them are proven

899
00:36:10,920 --> 00:36:13,680
to be correct singularly but then you

900
00:36:13,680 --> 00:36:15,060
have to consider all the interactions

901
00:36:15,060 --> 00:36:17,880
between them and that's super complex

902
00:36:17,880 --> 00:36:21,380
so no idea

903
00:36:21,660 --> 00:36:24,960
so have you tried like writing to those

904
00:36:24,960 --> 00:36:26,640
Arabic registers

905
00:36:26,640 --> 00:36:30,060
sorry have you tried like to write those

906
00:36:30,060 --> 00:36:33,300
epic registers yes it didn't happen much

907
00:36:33,300 --> 00:36:36,420
okay then I would say it's difficult to

908
00:36:36,420 --> 00:36:39,060
know if okay you're literally overriding

909
00:36:39,060 --> 00:36:42,000
the super Q entry and then that is I

910
00:36:42,000 --> 00:36:44,220
would say uh

911
00:36:44,220 --> 00:36:47,220
um I was called back and forth Behavior

912
00:36:47,220 --> 00:36:49,440
but however the entries that you're

913
00:36:49,440 --> 00:36:52,079
using are not used anymore by the CPU

914
00:36:52,079 --> 00:36:54,060
so these are entries that are reserved

915
00:36:54,060 --> 00:36:57,720
for the Epic so okay you can even if it

916
00:36:57,720 --> 00:37:01,140
was possible to write to those entries

917
00:37:01,140 --> 00:37:04,440
then I would say it wouldn't affect much

918
00:37:04,440 --> 00:37:06,599
so say that

919
00:37:06,599 --> 00:37:09,000
also during the Embargo video the Intel

920
00:37:09,000 --> 00:37:11,940
release another attack on mmao region

921
00:37:11,940 --> 00:37:14,099
that is super obscure and no one has

922
00:37:14,099 --> 00:37:15,540
idea what is happening there they

923
00:37:15,540 --> 00:37:17,880
released only uh like security bulletin

924
00:37:17,880 --> 00:37:20,579
to say we fix this and I think that

925
00:37:20,579 --> 00:37:21,780
attack

926
00:37:21,780 --> 00:37:24,540
yet both directions so you could write

927
00:37:24,540 --> 00:37:26,940
some obscure MMA region they didn't

928
00:37:26,940 --> 00:37:29,640
disclose what was that so definitely

929
00:37:29,640 --> 00:37:32,040
there is more to discover there

930
00:37:32,040 --> 00:37:34,680
what I tried it didn't work but if you

931
00:37:34,680 --> 00:37:37,819
have ideas you're welcome

932
00:37:38,400 --> 00:37:40,020
you said he was looking at another

933
00:37:40,020 --> 00:37:43,680
exploit while uh you served the strange

934
00:37:43,680 --> 00:37:45,900
behavior of the CPU but how much time

935
00:37:45,900 --> 00:37:48,599
did it take to get from that moment to

936
00:37:48,599 --> 00:37:51,839
actually get POC

937
00:37:51,839 --> 00:37:55,260
so the bug is so disastrous that I

938
00:37:55,260 --> 00:37:57,359
already had a POC like what I was doing

939
00:37:57,359 --> 00:37:59,400
was already leading memory and that was

940
00:37:59,400 --> 00:38:01,859
the POC the first POC that I had I was

941
00:38:01,859 --> 00:38:03,780
doing literally something else but it

942
00:38:03,780 --> 00:38:05,339
was already linking memory so I would

943
00:38:05,339 --> 00:38:07,800
say that was the first POC okay then

944
00:38:07,800 --> 00:38:10,020
okay you isolate the behavior and then

945
00:38:10,020 --> 00:38:13,619
you start like optimizing it and for

946
00:38:13,619 --> 00:38:16,560
example uh fixing the

947
00:38:16,560 --> 00:38:18,300
I would say the performance and try to

948
00:38:18,300 --> 00:38:20,220
make it faster and faster and then takes

949
00:38:20,220 --> 00:38:22,560
time obviously but I wasn't alone I

950
00:38:22,560 --> 00:38:24,300
would say the second order Andreas

951
00:38:24,300 --> 00:38:26,160
cobbler is responsible for discovering

952
00:38:26,160 --> 00:38:27,720
cache line freezing that is the

953
00:38:27,720 --> 00:38:29,820
technique of fixing the data that you

954
00:38:29,820 --> 00:38:32,339
want to link in memory but I would say

955
00:38:32,339 --> 00:38:35,460
it's an either approach in thirdly I

956
00:38:35,460 --> 00:38:37,619
think from Discovery to have the paper

957
00:38:37,619 --> 00:38:39,480
ready it was like three months something

958
00:38:39,480 --> 00:38:42,960
like that but I would say this was just

959
00:38:42,960 --> 00:38:44,460
due to the fact that the bug is so

960
00:38:44,460 --> 00:38:47,099
disastrous that is very easy to exploit

961
00:38:47,099 --> 00:38:48,960
all right thank you

962
00:38:48,960 --> 00:38:52,619
so I was wondering uh did you do some

963
00:38:52,619 --> 00:38:55,079
research about EMD processor

964
00:38:55,079 --> 00:38:58,380
AMD AMD yeah obviously so this affects

965
00:38:58,380 --> 00:39:01,200
only Intel I think yeah so obviously we

966
00:39:01,200 --> 00:39:03,540
tried this attack on MD but it seems

967
00:39:03,540 --> 00:39:07,140
It's secure in this kind of uh I would

968
00:39:07,140 --> 00:39:09,420
say point of view okay

969
00:39:09,420 --> 00:39:14,280
but I didn't have many AMD processors to

970
00:39:14,280 --> 00:39:16,260
try this on yeah because it depends on

971
00:39:16,260 --> 00:39:19,500
the architecture of single processor so

972
00:39:19,500 --> 00:39:21,240
this kind of attack didn't work at all

973
00:39:21,240 --> 00:39:24,540
on MD okay we tried all of the most

974
00:39:24,540 --> 00:39:26,339
common architecture from MD we also

975
00:39:26,339 --> 00:39:27,780
contacted them and confirmed that they

976
00:39:27,780 --> 00:39:30,240
are not vulnerable

977
00:39:30,240 --> 00:39:33,300
but also here is I would say hard to say

978
00:39:33,300 --> 00:39:34,560
yeah just a question they are not

979
00:39:34,560 --> 00:39:38,040
vulnerable but yeah like what we tried

980
00:39:38,040 --> 00:39:39,780
uh this is leaving

981
00:39:39,780 --> 00:39:42,660
okay you saw the last Light but but what

982
00:39:42,660 --> 00:39:43,560
we

983
00:39:43,560 --> 00:39:46,380
try it okay

984
00:39:46,380 --> 00:39:48,180
what we tried it didn't work on AMD

985
00:39:48,180 --> 00:39:50,640
basically okay thank you

986
00:39:50,640 --> 00:39:52,440
thanks again Pietro for your nice

987
00:39:52,440 --> 00:39:54,250
presentation

988
00:39:54,250 --> 00:40:00,610
[Applause]

