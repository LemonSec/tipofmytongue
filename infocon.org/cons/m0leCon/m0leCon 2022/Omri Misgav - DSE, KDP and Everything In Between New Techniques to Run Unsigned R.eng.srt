1
00:00:03,560 --> 00:00:05,819
hi everyone

2
00:00:05,819 --> 00:00:07,880
sorry for the

3
00:00:07,880 --> 00:00:10,800
technical difficulties and the trial run

4
00:00:10,800 --> 00:00:13,440
before it worked well but we improvised

5
00:00:13,440 --> 00:00:15,360
and it's all good now

6
00:00:15,360 --> 00:00:16,139
um

7
00:00:16,139 --> 00:00:19,380
so thanks for having me I'll be speaking

8
00:00:19,380 --> 00:00:23,279
about how to run rootkits on unsigned

9
00:00:23,279 --> 00:00:25,640
root kits on Windows 11.

10
00:00:25,640 --> 00:00:30,420
my name is Omri I'm working on OS

11
00:00:30,420 --> 00:00:32,520
internals vulnerability research malware

12
00:00:32,520 --> 00:00:36,840
analysis in 14 at Israel

13
00:00:36,840 --> 00:00:39,000
are presented in various conferences in

14
00:00:39,000 --> 00:00:40,800
the past but it's my first time here and

15
00:00:40,800 --> 00:00:45,140
in Italy as well so thanks for having me

16
00:00:45,899 --> 00:00:48,960
we'll talk about a bit what about this

17
00:00:48,960 --> 00:00:51,239
driver signing enforcement on Windows

18
00:00:51,239 --> 00:00:54,420
the Restriction that it has how much how

19
00:00:54,420 --> 00:00:57,960
it's being bypassed in the world and how

20
00:00:57,960 --> 00:01:00,379
Microsoft tried to protect against it

21
00:01:00,379 --> 00:01:03,239
and then we'll go ahead and show you the

22
00:01:03,239 --> 00:01:05,360
new techniques that we built

23
00:01:05,360 --> 00:01:09,680
and we'll also try to run a live demo

24
00:01:09,680 --> 00:01:12,060
hopefully there won't be any hiccups

25
00:01:12,060 --> 00:01:13,080
with that

26
00:01:13,080 --> 00:01:16,500
and then we'll go ahead to show you like

27
00:01:16,500 --> 00:01:18,600
the mitigation that we try to come up

28
00:01:18,600 --> 00:01:20,700
with and like try to summarize

29
00:01:20,700 --> 00:01:23,479
afterwards

30
00:01:23,580 --> 00:01:26,640
start with the warning though

31
00:01:26,640 --> 00:01:28,799
um you what you're going to see here

32
00:01:28,799 --> 00:01:31,560
today gonna might be a bit hard on your

33
00:01:31,560 --> 00:01:33,740
eyes

34
00:01:34,799 --> 00:01:37,920
not because it's that radical but it's

35
00:01:37,920 --> 00:01:39,659
because I'm doing my own slides and I'm

36
00:01:39,659 --> 00:01:42,960
really bad with Graphics as a as an

37
00:01:42,960 --> 00:01:44,620
example you can see that

38
00:01:44,620 --> 00:01:45,299
[Music]

39
00:01:45,299 --> 00:01:46,560
um

40
00:01:46,560 --> 00:01:48,780
I'll need to be better at it in the

41
00:01:48,780 --> 00:01:50,759
future though I've told this joke more

42
00:01:50,759 --> 00:01:52,560
than once and it's not funny as it used

43
00:01:52,560 --> 00:01:54,799
to be

44
00:01:55,500 --> 00:01:59,159
so starting off basically driver signing

45
00:01:59,159 --> 00:02:03,240
enforcement or DSC is a quite uh

46
00:02:03,240 --> 00:02:06,060
well-known feature by now

47
00:02:06,060 --> 00:02:06,659
um

48
00:02:06,659 --> 00:02:10,639
basically when you try to run some code

49
00:02:10,639 --> 00:02:13,680
you can check it if it's signed or not

50
00:02:13,680 --> 00:02:15,720
and specifically when you try to run a

51
00:02:15,720 --> 00:02:18,599
driver on Windows then it has to be

52
00:02:18,599 --> 00:02:21,319
signed digitally

53
00:02:21,319 --> 00:02:24,720
Microsoft did some tricks there that

54
00:02:24,720 --> 00:02:26,000
initially

55
00:02:26,000 --> 00:02:28,280
like had you

56
00:02:28,280 --> 00:02:31,920
get a digital certificate only from a

57
00:02:31,920 --> 00:02:36,060
specific vendor only from a specific set

58
00:02:36,060 --> 00:02:39,480
of CAS and then along the years they

59
00:02:39,480 --> 00:02:41,640
changed that that you have to go through

60
00:02:41,640 --> 00:02:44,580
them and basically they have to sign

61
00:02:44,580 --> 00:02:47,220
your driver as well

62
00:02:47,220 --> 00:02:50,459
which for attackers is not really ideal

63
00:02:50,459 --> 00:02:52,500
because you literally hand your payload

64
00:02:52,500 --> 00:02:55,200
to The Defenders which is obviously what

65
00:02:55,200 --> 00:02:58,319
you try to avoid and those signatures

66
00:02:58,319 --> 00:03:01,440
are being tested and verified each time

67
00:03:01,440 --> 00:03:05,400
that the driver is loaded into memory

68
00:03:05,400 --> 00:03:07,920
so specifically how it works if we look

69
00:03:07,920 --> 00:03:10,140
in the left and the left hand side of

70
00:03:10,140 --> 00:03:13,080
the slide basically when the kernel

71
00:03:13,080 --> 00:03:15,060
starts during the boot phase of the

72
00:03:15,060 --> 00:03:17,640
operating system it will try to

73
00:03:17,640 --> 00:03:20,780
initialize the call Integrity feature

74
00:03:20,780 --> 00:03:24,060
which is implemented in an additional

75
00:03:24,060 --> 00:03:28,680
kernel Library which is called cidll

76
00:03:28,680 --> 00:03:30,180
um all of the symbols that you see here

77
00:03:30,180 --> 00:03:33,840
are private they are not exported except

78
00:03:33,840 --> 00:03:38,340
for the one in red the CI initialized

79
00:03:38,340 --> 00:03:41,459
basically what is the flow the process

80
00:03:41,459 --> 00:03:46,140
does is try to set some Global flags

81
00:03:46,140 --> 00:03:49,019
that will state that controls the states

82
00:03:49,019 --> 00:03:52,379
of the feature and provides callbacks

83
00:03:52,379 --> 00:03:54,980
initialize an array of callbacks

84
00:03:54,980 --> 00:03:58,680
for it internal function in citl Back to

85
00:03:58,680 --> 00:04:02,580
the kernel then when you try to load

86
00:04:02,580 --> 00:04:04,760
when you try to load some driver

87
00:04:04,760 --> 00:04:08,360
and the kernel will call

88
00:04:08,360 --> 00:04:12,540
wrapper functions in this example we

89
00:04:12,540 --> 00:04:16,918
have the SD validate image adder

90
00:04:16,918 --> 00:04:20,160
and SD validate image data which

91
00:04:20,160 --> 00:04:22,680
eventually called just invoke the

92
00:04:22,680 --> 00:04:25,340
callbacks as you can see in the

93
00:04:25,340 --> 00:04:28,080
disassembly on the right

94
00:04:28,080 --> 00:04:30,660
along the years there have been a few

95
00:04:30,660 --> 00:04:33,300
changes we teach different operating

96
00:04:33,300 --> 00:04:36,300
system version starting with Windows 8

97
00:04:36,300 --> 00:04:39,900
basically there's only one flag that

98
00:04:39,900 --> 00:04:43,440
will control the state of the CI of code

99
00:04:43,440 --> 00:04:44,540
Integrity

100
00:04:44,540 --> 00:04:47,280
also the Callback structure changed

101
00:04:47,280 --> 00:04:49,320
again it's an internal structure it's

102
00:04:49,320 --> 00:04:50,600
not exported

103
00:04:50,600 --> 00:04:52,759
but basically

104
00:04:52,759 --> 00:04:56,880
the core callbacks that will be talked

105
00:04:56,880 --> 00:05:00,300
about we mentioned are still there the

106
00:05:00,300 --> 00:05:03,660
flow for using them changed a bit as

107
00:05:03,660 --> 00:05:05,699
only one

108
00:05:05,699 --> 00:05:07,919
one callback will be used during this

109
00:05:07,919 --> 00:05:10,940
process and

110
00:05:10,940 --> 00:05:14,040
and the name of the private symbol

111
00:05:14,040 --> 00:05:16,620
changed but this is just will be a

112
00:05:16,620 --> 00:05:18,720
reference for later

113
00:05:18,720 --> 00:05:22,740
so how can you bypass this restriction

114
00:05:22,740 --> 00:05:25,380
um well the obvious solution is to get

115
00:05:25,380 --> 00:05:27,380
your own valid certificate

116
00:05:27,380 --> 00:05:30,120
either you steal one or you get some CA

117
00:05:30,120 --> 00:05:36,060
to assign you one or you can try to run

118
00:05:36,060 --> 00:05:38,000
some Shell Code

119
00:05:38,000 --> 00:05:41,460
past like as a result of some

120
00:05:41,460 --> 00:05:44,100
vulnerability that you exploited but

121
00:05:44,100 --> 00:05:46,520
that's not that

122
00:05:46,520 --> 00:05:49,680
let's say comfortable at the end like

123
00:05:49,680 --> 00:05:52,320
writing assembly code and Shell Code

124
00:05:52,320 --> 00:05:55,199
it's likely not as easy or comfortable

125
00:05:55,199 --> 00:05:57,720
it's just writing C code and having a

126
00:05:57,720 --> 00:06:01,800
compiler run it and build it and there

127
00:06:01,800 --> 00:06:04,620
are also some complexities to it when

128
00:06:04,620 --> 00:06:06,300
you try to

129
00:06:06,300 --> 00:06:09,600
to run it in the kernel uh kernel mode

130
00:06:09,600 --> 00:06:11,900
is not that nice environment

131
00:06:11,900 --> 00:06:15,180
so the last thing that usually attackers

132
00:06:15,180 --> 00:06:19,020
do is just disable this enforcement on

133
00:06:19,020 --> 00:06:22,039
runtime and just leverage the entire OS

134
00:06:22,039 --> 00:06:25,500
as usually as usual as as the normal

135
00:06:25,500 --> 00:06:29,000
process of loading a driver is

136
00:06:29,160 --> 00:06:31,440
what they do is simply flipping the

137
00:06:31,440 --> 00:06:34,560
control bits of the flags changing them

138
00:06:34,560 --> 00:06:37,380
on on runtime using a camera right

139
00:06:37,380 --> 00:06:39,720
primitive

140
00:06:39,720 --> 00:06:42,419
um those flags again are internal they

141
00:06:42,419 --> 00:06:45,539
are not exported but finding him finding

142
00:06:45,539 --> 00:06:48,180
them is quite quite easy with a simple

143
00:06:48,180 --> 00:06:50,160
pattern matching

144
00:06:50,160 --> 00:06:50,759
um

145
00:06:50,759 --> 00:06:53,160
again they overwrite it and load their

146
00:06:53,160 --> 00:06:56,400
driver and they restore it so they avoid

147
00:06:56,400 --> 00:06:58,220
some protections

148
00:06:58,220 --> 00:07:01,199
to get the the kernel light primitive

149
00:07:01,199 --> 00:07:03,900
they usually bring their own driver or

150
00:07:03,900 --> 00:07:06,919
their own vulnerable driver

151
00:07:06,960 --> 00:07:10,800
which is just some driver from a known

152
00:07:10,800 --> 00:07:14,759
vendor usually that has some poor coding

153
00:07:14,759 --> 00:07:17,160
done to it or

154
00:07:17,160 --> 00:07:20,539
that they found some way to leverage

155
00:07:20,539 --> 00:07:23,900
vulnerability in it

156
00:07:24,180 --> 00:07:27,900
so in order to deal with that Microsoft

157
00:07:27,900 --> 00:07:31,860
introduced a few protection mechanisms

158
00:07:31,860 --> 00:07:35,120
the first one is a patch guard

159
00:07:35,120 --> 00:07:37,680
for those of you who are familiar with

160
00:07:37,680 --> 00:07:40,080
the windows environment it basically

161
00:07:40,080 --> 00:07:43,440
prevents you from doing modifications to

162
00:07:43,440 --> 00:07:46,380
Kernel data structures and code for long

163
00:07:46,380 --> 00:07:49,380
periods of time if it will detect a

164
00:07:49,380 --> 00:07:51,479
change it will just blue screen the

165
00:07:51,479 --> 00:07:52,500
system

166
00:07:52,500 --> 00:07:54,780
and it's being updated with each new

167
00:07:54,780 --> 00:07:56,960
version

168
00:07:57,599 --> 00:07:59,819
since veggie wasn't that effective

169
00:07:59,819 --> 00:08:02,819
Microsoft tried to introduce new ways to

170
00:08:02,819 --> 00:08:05,340
protect against it the first one is

171
00:08:05,340 --> 00:08:06,780
using a

172
00:08:06,780 --> 00:08:10,020
driver block list in order to prevent

173
00:08:10,020 --> 00:08:12,000
attackers from Gaining the kernel

174
00:08:12,000 --> 00:08:14,639
primitive kernel right primitive

175
00:08:14,639 --> 00:08:15,780
um

176
00:08:15,780 --> 00:08:19,400
basically it's being enforced via

177
00:08:19,400 --> 00:08:23,699
Windows Defender or the secure kernel I

178
00:08:23,699 --> 00:08:26,879
included a link to the latest list on

179
00:08:26,879 --> 00:08:29,699
the Microsoft website there is a small

180
00:08:29,699 --> 00:08:33,479
asterisk there a few weeks back there

181
00:08:33,479 --> 00:08:37,339
was a quite a hot debate on Twitter

182
00:08:37,339 --> 00:08:40,140
that the researcher tried to like look

183
00:08:40,140 --> 00:08:42,479
and how how much this list is actually

184
00:08:42,479 --> 00:08:43,580
effective

185
00:08:43,580 --> 00:08:46,160
I'm not sure if Twitter is there anymore

186
00:08:46,160 --> 00:08:48,080
but

187
00:08:48,080 --> 00:08:51,720
in these days you can't know but you can

188
00:08:51,720 --> 00:08:53,480
try look it up later

189
00:08:53,480 --> 00:08:56,339
the bottom line was that he found out

190
00:08:56,339 --> 00:09:00,000
the list wasn't updated for like two or

191
00:09:00,000 --> 00:09:02,100
three years and it wasn't even pushed to

192
00:09:02,100 --> 00:09:04,800
the endpoints even though they the docs

193
00:09:04,800 --> 00:09:06,010
claimed otherwise

194
00:09:06,010 --> 00:09:07,560
[Music]

195
00:09:07,560 --> 00:09:11,339
and maintaining block lists is obviously

196
00:09:11,339 --> 00:09:15,060
not that not that simple it constantly

197
00:09:15,060 --> 00:09:18,480
makes you need to run run around it run

198
00:09:18,480 --> 00:09:21,360
after the attackers and see what happens

199
00:09:21,360 --> 00:09:22,200
um

200
00:09:22,200 --> 00:09:23,720
and

201
00:09:23,720 --> 00:09:27,600
in order to try a new approach that it

202
00:09:27,600 --> 00:09:29,060
should be better

203
00:09:29,060 --> 00:09:31,399
Microsoft tried to

204
00:09:31,399 --> 00:09:34,800
use kernel data protection which is a

205
00:09:34,800 --> 00:09:36,080
new feature based on their

206
00:09:36,080 --> 00:09:38,580
virtualization based security

207
00:09:38,580 --> 00:09:40,740
architecture

208
00:09:40,740 --> 00:09:43,620
in order to prevent changes to this uh

209
00:09:43,620 --> 00:09:46,920
to be to prevent being able to change

210
00:09:46,920 --> 00:09:49,380
the actual Flags in memory during

211
00:09:49,380 --> 00:09:50,820
runtime

212
00:09:50,820 --> 00:09:53,160
it's a fairly new

213
00:09:53,160 --> 00:09:56,399
um new feature as you can see basically

214
00:09:56,399 --> 00:09:58,800
with VBS

215
00:09:58,800 --> 00:10:01,680
um you know with the kernel you have an

216
00:10:01,680 --> 00:10:03,720
additional kernel which is called the

217
00:10:03,720 --> 00:10:05,660
security I mentioned before

218
00:10:05,660 --> 00:10:09,420
basically the kernel itself doesn't run

219
00:10:09,420 --> 00:10:12,380
alone anymore but it runs

220
00:10:12,380 --> 00:10:16,320
with an hypervisor and then with the

221
00:10:16,320 --> 00:10:19,200
hypervisor there is an additional set of

222
00:10:19,200 --> 00:10:23,459
permissions that is basically

223
00:10:23,459 --> 00:10:26,220
um being enforced by the hardware by the

224
00:10:26,220 --> 00:10:29,660
CPU because you have two page tables now

225
00:10:29,660 --> 00:10:33,060
when you try to access memory

226
00:10:33,060 --> 00:10:35,420
and the secure kernel basically

227
00:10:35,420 --> 00:10:39,500
maintains this uh the second

228
00:10:39,500 --> 00:10:42,660
page table that the driver that the

229
00:10:42,660 --> 00:10:46,440
regular kernel can't access and once you

230
00:10:46,440 --> 00:10:49,320
ask the secure kernel to protect this uh

231
00:10:49,320 --> 00:10:52,459
these areas of memory it will just

232
00:10:52,459 --> 00:10:55,820
take off the right protection right

233
00:10:55,820 --> 00:10:58,920
permissions from that from those pages

234
00:10:58,920 --> 00:11:00,959
and then

235
00:11:00,959 --> 00:11:02,160
um you won't be able to ride that

236
00:11:02,160 --> 00:11:03,600
anymore

237
00:11:03,600 --> 00:11:06,600
so how it looks on the sci dealer how it

238
00:11:06,600 --> 00:11:09,899
was implemented basically

239
00:11:09,899 --> 00:11:12,660
as you can see on the left

240
00:11:12,660 --> 00:11:14,640
the global variable is now being

241
00:11:14,640 --> 00:11:17,339
protected during the initialization

242
00:11:17,339 --> 00:11:19,940
phase of cidll

243
00:11:19,940 --> 00:11:25,220
and the variable was put in a in its own

244
00:11:25,220 --> 00:11:28,380
in its own data section

245
00:11:28,380 --> 00:11:32,540
which will be very helpful for us

246
00:11:32,540 --> 00:11:35,959
in quite a bit

247
00:11:36,300 --> 00:11:38,760
that the data section is called the CI

248
00:11:38,760 --> 00:11:40,339
policy

249
00:11:40,339 --> 00:11:45,380
that's just for a future reference

250
00:11:45,660 --> 00:11:48,000
so let's go ahead and start talking

251
00:11:48,000 --> 00:11:50,300
about our new techniques

252
00:11:50,300 --> 00:11:54,420
basically the flow again just for a

253
00:11:54,420 --> 00:11:57,620
quick reminder for a DC tampering is

254
00:11:57,620 --> 00:12:02,579
locate overwrite load and revert we'll

255
00:12:02,579 --> 00:12:04,380
focus on the

256
00:12:04,380 --> 00:12:07,380
active two main points two first points

257
00:12:07,380 --> 00:12:09,899
the locate and override the load

258
00:12:09,899 --> 00:12:12,420
obviously stayed the same and revert is

259
00:12:12,420 --> 00:12:14,519
just the same is override but doing the

260
00:12:14,519 --> 00:12:16,019
other way around

261
00:12:16,019 --> 00:12:17,160
but

262
00:12:17,160 --> 00:12:20,339
so first off the first technique that we

263
00:12:20,339 --> 00:12:23,820
called that we named in a very creative

264
00:12:23,820 --> 00:12:26,540
way it's called page swapping

265
00:12:26,540 --> 00:12:29,339
instead of just trying to write to a

266
00:12:29,339 --> 00:12:31,680
page that is not writable why not create

267
00:12:31,680 --> 00:12:35,300
our own page that is writable place the

268
00:12:35,300 --> 00:12:38,760
the value that we expect in in it and

269
00:12:38,760 --> 00:12:41,640
just mess around with the virtual

270
00:12:41,640 --> 00:12:43,560
address mapping

271
00:12:43,560 --> 00:12:44,279
um

272
00:12:44,279 --> 00:12:48,660
so we create our own page just for the

273
00:12:48,660 --> 00:12:52,579
illustration and then in order to

274
00:12:52,579 --> 00:12:54,680
basically trick

275
00:12:54,680 --> 00:12:57,500
the CI dll

276
00:12:57,500 --> 00:13:00,000
we just need to change the virtual

277
00:13:00,000 --> 00:13:00,860
address

278
00:13:00,860 --> 00:13:03,779
mapping basically

279
00:13:03,779 --> 00:13:08,519
change the pity in the page table

280
00:13:08,519 --> 00:13:10,920
as you can see

281
00:13:10,920 --> 00:13:14,040
and then the entire mapping flow changes

282
00:13:14,040 --> 00:13:15,320
and the

283
00:13:15,320 --> 00:13:17,940
CPU will see

284
00:13:17,940 --> 00:13:18,899
um

285
00:13:18,899 --> 00:13:23,700
the CPU will get to the uh basically our

286
00:13:23,700 --> 00:13:27,200
value that we control on

287
00:13:27,360 --> 00:13:31,500
so I'll just go over the steps quickly

288
00:13:31,500 --> 00:13:34,320
we allocate the memory we look at memory

289
00:13:34,320 --> 00:13:36,540
this is which is writable we need to

290
00:13:36,540 --> 00:13:39,360
find the CI options flag just as was

291
00:13:39,360 --> 00:13:41,279
done before there's no nothing new in

292
00:13:41,279 --> 00:13:44,639
that in order to mess with the page with

293
00:13:44,639 --> 00:13:48,899
the pts we can do that using their

294
00:13:48,899 --> 00:13:51,060
a virtual address there is a place

295
00:13:51,060 --> 00:13:53,279
there's an area in memory in Canada

296
00:13:53,279 --> 00:13:57,180
memory that is called the pts based

297
00:13:57,180 --> 00:14:01,380
and to just do a simple translation from

298
00:14:01,380 --> 00:14:03,660
the virtual address that we need to find

299
00:14:03,660 --> 00:14:05,880
it pretty and we need a variable that

300
00:14:05,880 --> 00:14:08,560
it's called the pte base

301
00:14:08,560 --> 00:14:09,779
[Music]

302
00:14:09,779 --> 00:14:12,540
it's it's being randomized right now by

303
00:14:12,540 --> 00:14:14,720
kslr

304
00:14:14,720 --> 00:14:18,660
but fortunately for us we already had to

305
00:14:18,660 --> 00:14:21,000
tackle this in this issue in a previous

306
00:14:21,000 --> 00:14:23,279
research and there is a way with the

307
00:14:23,279 --> 00:14:26,220
single kernel read that you can

308
00:14:26,220 --> 00:14:28,560
basically get this

309
00:14:28,560 --> 00:14:32,160
uh this value okay this function is

310
00:14:32,160 --> 00:14:34,639
exported it's easy to find

311
00:14:34,639 --> 00:14:38,820
and with one read you can basically find

312
00:14:38,820 --> 00:14:41,639
this value that you mean that we need

313
00:14:41,639 --> 00:14:45,360
then we need to find the pfn to the page

314
00:14:45,360 --> 00:14:48,680
that we allocated at the start

315
00:14:48,680 --> 00:14:52,320
and copy its entire content

316
00:14:52,320 --> 00:14:56,040
and modify the value for the flag

317
00:14:56,040 --> 00:14:58,620
change

318
00:14:58,620 --> 00:15:02,699
to change the PT for the original CI

319
00:15:02,699 --> 00:15:06,420
options page load the driver and restore

320
00:15:06,420 --> 00:15:07,800
the person

321
00:15:07,800 --> 00:15:09,440
so

322
00:15:09,440 --> 00:15:12,240
that's quite long that's quite

323
00:15:12,240 --> 00:15:15,000
complicated and when I initially

324
00:15:15,000 --> 00:15:18,180
implemented it I wasn't really happy it

325
00:15:18,180 --> 00:15:19,920
involves a lot of Kernel reads and

326
00:15:19,920 --> 00:15:21,680
kernel rights

327
00:15:21,680 --> 00:15:24,600
so I tried to figure out like in a

328
00:15:24,600 --> 00:15:27,120
different approach and apparently with a

329
00:15:27,120 --> 00:15:30,899
very minor tweak we can really like

330
00:15:30,899 --> 00:15:33,680
reduce the amount of reads and rights

331
00:15:33,680 --> 00:15:37,560
instead of allocating memory in kernel

332
00:15:37,560 --> 00:15:40,380
space you can just allocate memory in

333
00:15:40,380 --> 00:15:44,279
the user space that we obviously running

334
00:15:44,279 --> 00:15:47,220
the the rest of the process stays pretty

335
00:15:47,220 --> 00:15:48,500
much the same

336
00:15:48,500 --> 00:15:52,740
with one minor change we can rely on the

337
00:15:52,740 --> 00:15:56,100
default values of that page because all

338
00:15:56,100 --> 00:15:58,560
of the data that they moved to all of

339
00:15:58,560 --> 00:16:00,300
the data that the other variables that

340
00:16:00,300 --> 00:16:03,180
they move to that page we can kind of uh

341
00:16:03,180 --> 00:16:05,399
assume that what are the default values

342
00:16:05,399 --> 00:16:07,079
are for them

343
00:16:07,079 --> 00:16:09,420
um just as they are on disk and

344
00:16:09,420 --> 00:16:11,959
it just works

345
00:16:11,959 --> 00:16:15,899
this and then we initialize uh the page

346
00:16:15,899 --> 00:16:19,500
to the value that we need to set the

347
00:16:19,500 --> 00:16:22,079
global variable change the PT just as

348
00:16:22,079 --> 00:16:24,480
just as we did before load the driver

349
00:16:24,480 --> 00:16:26,839
and restore

350
00:16:26,839 --> 00:16:30,480
the original PT value

351
00:16:30,480 --> 00:16:31,800
foreign

352
00:16:31,800 --> 00:16:35,279
so I talked quite a lot until now and

353
00:16:35,279 --> 00:16:37,740
now you'll probably want to see that I

354
00:16:37,740 --> 00:16:39,120
wasn't messing with you and it actually

355
00:16:39,120 --> 00:16:41,600
works

356
00:16:42,779 --> 00:16:47,600
so there we go move here

357
00:16:50,279 --> 00:16:54,060
so I have a Windows build here for from

358
00:16:54,060 --> 00:16:57,899
about two weeks ago

359
00:16:57,899 --> 00:17:00,060
um it's the latest Windows 11 Insider

360
00:17:00,060 --> 00:17:00,779
build

361
00:17:00,779 --> 00:17:05,640
if we go down you can see that VBS is on

362
00:17:05,640 --> 00:17:08,099
okay you won't see KDP here for some

363
00:17:08,099 --> 00:17:10,919
reason but it's on by default

364
00:17:10,919 --> 00:17:13,319
and the first thing we start is that

365
00:17:13,319 --> 00:17:15,780
I'll try to show you

366
00:17:15,780 --> 00:17:16,619
um

367
00:17:16,619 --> 00:17:18,740
basically

368
00:17:18,740 --> 00:17:23,459
that I'll run the existing

369
00:17:23,780 --> 00:17:27,419
technique in the wild to bypass KDP and

370
00:17:27,419 --> 00:17:30,559
that should blue screen the system

371
00:17:31,799 --> 00:17:34,940
so far so good

372
00:17:36,120 --> 00:17:40,520
we were just quickly

373
00:17:42,780 --> 00:17:45,379
okay

374
00:17:45,900 --> 00:17:49,020
so now I'll just show you that I have an

375
00:17:49,020 --> 00:17:52,580
unsigned driver here

376
00:17:55,380 --> 00:17:57,120
it is

377
00:17:57,120 --> 00:18:01,260
see there is no like uh digital this is

378
00:18:01,260 --> 00:18:04,879
a signature tab here okay

379
00:18:06,600 --> 00:18:09,740
um I'll try to install it

380
00:18:12,360 --> 00:18:16,820
and run it and this should fail

381
00:18:21,000 --> 00:18:24,980
right the driver is not signed

382
00:18:26,640 --> 00:18:30,179
now I run my plc

383
00:18:30,179 --> 00:18:33,000
and try to run it try to run the driver

384
00:18:33,000 --> 00:18:34,919
again

385
00:18:34,919 --> 00:18:38,059
and it started

386
00:18:40,160 --> 00:18:43,200
skip going over the printing here it's

387
00:18:43,200 --> 00:18:44,780
not that interesting

388
00:18:44,780 --> 00:18:46,020
[Music]

389
00:18:46,020 --> 00:18:49,320
but here you should be able

390
00:18:49,320 --> 00:18:51,240
to see

391
00:18:51,240 --> 00:18:53,660
Prince from the K from the rootkit right

392
00:18:53,660 --> 00:18:58,020
would get started would get running

393
00:18:58,020 --> 00:19:03,360
and logging like new process starts

394
00:19:03,360 --> 00:19:05,760
now if I try to stop the root kit and

395
00:19:05,760 --> 00:19:08,240
run it again

396
00:19:10,080 --> 00:19:14,280
no I get I see the roadkid stopped

397
00:19:14,280 --> 00:19:17,000
and

398
00:19:17,100 --> 00:19:19,860
running already no

399
00:19:19,860 --> 00:19:22,399
all right

400
00:19:22,740 --> 00:19:25,440
I just didn't I started it again instead

401
00:19:25,440 --> 00:19:28,039
of stopping it

402
00:19:30,840 --> 00:19:33,240
and now and

403
00:19:33,240 --> 00:19:34,500
again

404
00:19:34,500 --> 00:19:38,539
that won't run because I reverted back

405
00:19:38,820 --> 00:19:43,039
okay go back to the slides

406
00:19:43,080 --> 00:19:46,260
so just to recap here the number of read

407
00:19:46,260 --> 00:19:49,260
the rights and the allocation needed for

408
00:19:49,260 --> 00:19:50,970
reference

409
00:19:50,970 --> 00:19:53,039
[Music]

410
00:19:53,039 --> 00:19:54,960
it's still not as good as the current

411
00:19:54,960 --> 00:19:57,000
technique in the world so I still wanted

412
00:19:57,000 --> 00:19:58,580
to try and approve it

413
00:19:58,580 --> 00:20:01,799
so this is why we come we came up with

414
00:20:01,799 --> 00:20:05,280
another technique which also have a very

415
00:20:05,280 --> 00:20:07,919
creative name that we called the

416
00:20:07,919 --> 00:20:10,799
Callback swapping

417
00:20:10,799 --> 00:20:12,440
um basically

418
00:20:12,440 --> 00:20:16,500
why if we look at how the idea of the

419
00:20:16,500 --> 00:20:18,299
interface between the candle and cidll

420
00:20:18,299 --> 00:20:20,240
we can see

421
00:20:20,240 --> 00:20:23,280
we will be reminded that basically there

422
00:20:23,280 --> 00:20:25,380
is there are callbacks involved

423
00:20:25,380 --> 00:20:27,960
um so why not just uh

424
00:20:27,960 --> 00:20:30,900
instead of running sorry instead of

425
00:20:30,900 --> 00:20:31,860
running

426
00:20:31,860 --> 00:20:35,520
to the regular CI function and expect it

427
00:20:35,520 --> 00:20:38,400
to do the work and return true

428
00:20:38,400 --> 00:20:39,000
um

429
00:20:39,000 --> 00:20:41,700
or return status success actually why

430
00:20:41,700 --> 00:20:44,340
wouldn't why shouldn't we just change

431
00:20:44,340 --> 00:20:46,100
the pointer to

432
00:20:46,100 --> 00:20:48,780
to another function that will just

433
00:20:48,780 --> 00:20:50,760
return the same return return the same

434
00:20:50,760 --> 00:20:53,100
return value

435
00:20:53,100 --> 00:20:55,380
um so let's look at for a second now we

436
00:20:55,380 --> 00:20:56,520
can do it

437
00:20:56,520 --> 00:21:00,000
uh basically we need to find the the

438
00:21:00,000 --> 00:21:03,299
Callback structure in entos

439
00:21:03,299 --> 00:21:05,760
it's not that difficult basically

440
00:21:05,760 --> 00:21:07,160
because CI

441
00:21:07,160 --> 00:21:11,039
initialize gets a pointer to it and it's

442
00:21:11,039 --> 00:21:12,780
an important function so we can just

443
00:21:12,780 --> 00:21:15,660
walk over the import table and find it

444
00:21:15,660 --> 00:21:18,179
find the reference equal for it from the

445
00:21:18,179 --> 00:21:19,679
import table

446
00:21:19,679 --> 00:21:22,200
and then from from the call to it just

447
00:21:22,200 --> 00:21:24,110
walk back and find the parameter

448
00:21:24,110 --> 00:21:26,460
[Music]

449
00:21:26,460 --> 00:21:30,539
that will point to an uninitialized

450
00:21:30,539 --> 00:21:33,000
memory in entos

451
00:21:33,000 --> 00:21:35,039
as you can see

452
00:21:35,039 --> 00:21:37,740
now we need to find a new callback that

453
00:21:37,740 --> 00:21:40,100
will just return a zero

454
00:21:40,100 --> 00:21:42,600
we can either find some exported

455
00:21:42,600 --> 00:21:46,020
function in nthos or we can find some

456
00:21:46,020 --> 00:21:49,500
Gadget in cidll and all of those things

457
00:21:49,500 --> 00:21:52,140
we are doing purely in user space no

458
00:21:52,140 --> 00:21:56,720
kernel reading is needed

459
00:21:56,780 --> 00:22:00,419
once we we did that we need to find the

460
00:22:00,419 --> 00:22:01,280
original

461
00:22:01,280 --> 00:22:04,140
callbacks in user space again so we can

462
00:22:04,140 --> 00:22:06,480
avoid the kernel reads

463
00:22:06,480 --> 00:22:10,559
um basically we can find this pattern

464
00:22:10,559 --> 00:22:12,179
the pattern of instructions to

465
00:22:12,179 --> 00:22:14,940
initialize the Callback in the CI

466
00:22:14,940 --> 00:22:17,000
initialize function

467
00:22:17,000 --> 00:22:20,340
and once we we did that and we look at

468
00:22:20,340 --> 00:22:21,200
the

469
00:22:21,200 --> 00:22:24,419
layer instructions and we just we can

470
00:22:24,419 --> 00:22:27,419
just verify those these offsets are for

471
00:22:27,419 --> 00:22:30,059
functions basically we can use the

472
00:22:30,059 --> 00:22:33,059
unwide information in the dll

473
00:22:33,059 --> 00:22:36,360
and that will let us know that we

474
00:22:36,360 --> 00:22:38,880
probably find the right spot

475
00:22:38,880 --> 00:22:40,880
um

476
00:22:41,120 --> 00:22:43,740
this is the this allows us to find

477
00:22:43,740 --> 00:22:46,760
basically everything we needed and then

478
00:22:46,760 --> 00:22:50,340
by simple right we can just override the

479
00:22:50,340 --> 00:22:51,900
Callback

480
00:22:51,900 --> 00:22:54,659
load the driver and restore the Callback

481
00:22:54,659 --> 00:22:56,840
again

482
00:22:57,059 --> 00:23:01,158
so let's try another demo

483
00:23:03,900 --> 00:23:06,179
I'll just clean

484
00:23:06,179 --> 00:23:09,380
the log here

485
00:23:12,059 --> 00:23:14,940
so we already saw that the driver is not

486
00:23:14,940 --> 00:23:17,299
loaded

487
00:23:18,020 --> 00:23:21,900
and I'll try to run it again

488
00:23:21,900 --> 00:23:24,980
and it started

489
00:23:25,860 --> 00:23:29,520
just revert it back so I want a visual

490
00:23:29,520 --> 00:23:31,740
repair yard in the meantime

491
00:23:31,740 --> 00:23:34,799
and we see our rootkit is running

492
00:23:34,799 --> 00:23:38,059
and try to stop it again

493
00:23:38,280 --> 00:23:41,460
and run it again just so we can see the

494
00:23:41,460 --> 00:23:44,159
revert succeeded

495
00:23:44,159 --> 00:23:47,059
and there we go

496
00:23:50,700 --> 00:23:52,559
so

497
00:23:52,559 --> 00:23:55,740
um one last comp one last slide to

498
00:23:55,740 --> 00:23:59,820
compare all the all the techniques

499
00:23:59,820 --> 00:24:02,640
basically we can see that callback

500
00:24:02,640 --> 00:24:04,919
swapping at least from Windows 11 when

501
00:24:04,919 --> 00:24:07,440
from Windows 8.

502
00:24:07,440 --> 00:24:08,100
um

503
00:24:08,100 --> 00:24:10,440
works pretty well and it's

504
00:24:10,440 --> 00:24:12,840
quite the same as the current technique

505
00:24:12,840 --> 00:24:14,640
in the wild

506
00:24:14,640 --> 00:24:15,960
um

507
00:24:15,960 --> 00:24:18,900
and that that pretty much let us achieve

508
00:24:18,900 --> 00:24:20,520
our goal

509
00:24:20,520 --> 00:24:22,440
um

510
00:24:22,440 --> 00:24:25,740
so we didn't really want to put things

511
00:24:25,740 --> 00:24:28,500
like keep things the way they were and

512
00:24:28,500 --> 00:24:30,960
we try to find like to think about the

513
00:24:30,960 --> 00:24:34,460
way that we can maybe introduce some

514
00:24:34,460 --> 00:24:38,100
method to deal with this issue because

515
00:24:38,100 --> 00:24:40,679
obviously the current protections that

516
00:24:40,679 --> 00:24:44,419
Microsoft delivered are not that ideal

517
00:24:44,419 --> 00:24:48,960
so the thought that we have was why not

518
00:24:48,960 --> 00:24:52,200
just try to leverage the same principles

519
00:24:52,200 --> 00:24:54,960
that attack you use why not just try to

520
00:24:54,960 --> 00:24:57,539
verify like to find out what the current

521
00:24:57,539 --> 00:25:00,419
state of DST during runtime we can use

522
00:25:00,419 --> 00:25:04,320
the same logic to find the the same

523
00:25:04,320 --> 00:25:06,659
internal variables

524
00:25:06,659 --> 00:25:11,280
uh in our own and then we just need to

525
00:25:11,280 --> 00:25:13,440
um like save their initial state that we

526
00:25:13,440 --> 00:25:16,500
run in that we when we start the reason

527
00:25:16,500 --> 00:25:19,440
for that is that again because of patch

528
00:25:19,440 --> 00:25:21,299
guard those changes are have to be more

529
00:25:21,299 --> 00:25:23,820
momentarily so it it's kind of a fair

530
00:25:23,820 --> 00:25:25,700
assumption that when we'll start running

531
00:25:25,700 --> 00:25:29,340
uh the assist state will be uh will be

532
00:25:29,340 --> 00:25:30,960
valid

533
00:25:30,960 --> 00:25:31,679
um

534
00:25:31,679 --> 00:25:34,559
we copy the values when we start and

535
00:25:34,559 --> 00:25:36,600
then we need to figure out how to

536
00:25:36,600 --> 00:25:38,760
intercept the driver loading procedure

537
00:25:38,760 --> 00:25:41,880
we can do that by placing a user mode

538
00:25:41,880 --> 00:25:44,779
hook but that's pretty weak we can

539
00:25:44,779 --> 00:25:47,360
Instead try to use kernel callbacks

540
00:25:47,360 --> 00:25:50,039
either on registry or on file system

541
00:25:50,039 --> 00:25:51,500
access

542
00:25:51,500 --> 00:25:56,100
and then verify uh basically look up the

543
00:25:56,100 --> 00:25:58,559
internal variables again and match them

544
00:25:58,559 --> 00:26:02,220
to the state that we captured and in

545
00:26:02,220 --> 00:26:03,620
order to block

546
00:26:03,620 --> 00:26:06,120
the driver loading at this stage we can

547
00:26:06,120 --> 00:26:08,960
just either

548
00:26:08,960 --> 00:26:13,460
deny the i o request or we can just like

549
00:26:13,460 --> 00:26:16,620
rewrite the variables on our own to the

550
00:26:16,620 --> 00:26:18,900
initial State and that we captured and

551
00:26:18,900 --> 00:26:22,159
then the OS just will

552
00:26:22,159 --> 00:26:26,600
deny the driver loading itself

553
00:26:27,419 --> 00:26:30,539
so to sum up

554
00:26:30,539 --> 00:26:34,080
data oriented mitigations are pretty

555
00:26:34,080 --> 00:26:37,919
difficult to implement even if in the

556
00:26:37,919 --> 00:26:40,100
views of some researchers in Microsoft

557
00:26:40,100 --> 00:26:43,140
it's really interesting to see how

558
00:26:43,140 --> 00:26:45,539
different groups in the same

559
00:26:45,539 --> 00:26:48,620
organizations view different problems

560
00:26:48,620 --> 00:26:51,860
view the same problems differently

561
00:26:51,860 --> 00:26:53,659
you can

562
00:26:53,659 --> 00:26:59,580
use the mitigation that we suggested but

563
00:26:59,580 --> 00:27:01,919
honestly the real solution for it is to

564
00:27:01,919 --> 00:27:04,039
enable another

565
00:27:04,039 --> 00:27:06,179
technology by Microsoft and other

566
00:27:06,179 --> 00:27:08,179
security mitigation that it's called

567
00:27:08,179 --> 00:27:10,740
hvci I kind of skipped it at the

568
00:27:10,740 --> 00:27:11,900
beginning

569
00:27:11,900 --> 00:27:15,260
it's short for hypervisor code Integrity

570
00:27:15,260 --> 00:27:18,900
basically the secure kernel can also do

571
00:27:18,900 --> 00:27:21,419
the additional validation of the code

572
00:27:21,419 --> 00:27:25,100
the code signature and keep the

573
00:27:25,100 --> 00:27:27,799
keep the same

574
00:27:27,799 --> 00:27:29,840
permissions

575
00:27:29,840 --> 00:27:33,600
like KDP does just instead of using the

576
00:27:33,600 --> 00:27:36,960
right bit use the execute bit

577
00:27:36,960 --> 00:27:37,799
um

578
00:27:37,799 --> 00:27:39,799
and then basically

579
00:27:39,799 --> 00:27:42,120
attackers won't be able to bypass it

580
00:27:42,120 --> 00:27:44,820
this feature is exists for like seven

581
00:27:44,820 --> 00:27:48,720
years now but for some reason it's not

582
00:27:48,720 --> 00:27:52,820
not on by default till now

583
00:27:52,820 --> 00:27:55,080
that's starting to deploy that or

584
00:27:55,080 --> 00:27:56,580
started to deploy it with the latest

585
00:27:56,580 --> 00:27:59,159
Windows 11 builds

586
00:27:59,159 --> 00:28:00,120
um

587
00:28:00,120 --> 00:28:02,820
and again DC won't completely disappear

588
00:28:02,820 --> 00:28:05,159
because at the end of day we'll also

589
00:28:05,159 --> 00:28:08,460
we'll always have a misconfigure systems

590
00:28:08,460 --> 00:28:11,419
or Legacy systems that exist for

591
00:28:11,419 --> 00:28:14,279
quite uh quite long after we wish them

592
00:28:14,279 --> 00:28:18,960
to to not be here and you have all the

593
00:28:18,960 --> 00:28:20,659
details in our blog here that we link

594
00:28:20,659 --> 00:28:23,159
and thank you very much

595
00:28:23,159 --> 00:28:26,419
any questions

596
00:28:29,720 --> 00:28:35,520
[Applause]

597
00:28:35,520 --> 00:28:38,779
I actually have two questions

598
00:28:38,779 --> 00:28:41,580
the first one is that you said as you

599
00:28:41,580 --> 00:28:44,340
showed in the demos we can only just

600
00:28:44,340 --> 00:28:46,919
briefly turn off the protections load in

601
00:28:46,919 --> 00:28:48,779
our malicious driver and then turn back

602
00:28:48,779 --> 00:28:52,860
on because otherwise uh patch defender

603
00:28:52,860 --> 00:28:54,360
or something will just blue screen the

604
00:28:54,360 --> 00:28:58,020
system right yeah okay and the other

605
00:28:58,020 --> 00:29:00,779
question I was wanted to ask is why did

606
00:29:00,779 --> 00:29:02,400
you keep track

607
00:29:02,400 --> 00:29:05,400
I mean why are the kernel calls

608
00:29:05,400 --> 00:29:07,860
important like you had the timeline of

609
00:29:07,860 --> 00:29:10,980
you reducing the number of right calls

610
00:29:10,980 --> 00:29:14,220
and read calls that you do uh from the

611
00:29:14,220 --> 00:29:16,620
kernel side are those important because

612
00:29:16,620 --> 00:29:18,659
they require additional privileges or

613
00:29:18,659 --> 00:29:21,059
are they tracked by anti-viruses or

614
00:29:21,059 --> 00:29:23,580
something like that why is that a metric

615
00:29:23,580 --> 00:29:25,440
that you kept referencing through the

616
00:29:25,440 --> 00:29:26,460
slides

617
00:29:26,460 --> 00:29:27,899
okay

618
00:29:27,899 --> 00:29:31,520
um so basically

619
00:29:31,520 --> 00:29:36,200
my assumption in this research was that

620
00:29:36,200 --> 00:29:39,960
gaining right gaining the right and red

621
00:29:39,960 --> 00:29:42,020
Primitives is difficult

622
00:29:42,020 --> 00:29:43,740
because

623
00:29:43,740 --> 00:29:46,159
block lists are great

624
00:29:46,159 --> 00:29:49,919
but like at the end I like wanted to

625
00:29:49,919 --> 00:29:51,720
take the more

626
00:29:51,720 --> 00:29:53,279
uh

627
00:29:53,279 --> 00:29:55,260
more restrictive approach

628
00:29:55,260 --> 00:29:59,100
and like assume that you get it via some

629
00:29:59,100 --> 00:30:02,700
kernel exploits okay okay and so when

630
00:30:02,700 --> 00:30:05,240
you have a kernel exploit you probably

631
00:30:05,240 --> 00:30:08,760
want to reduce the amount of time that

632
00:30:08,760 --> 00:30:11,039
you trigger it okay okay so this is why

633
00:30:11,039 --> 00:30:13,740
I wanted to do it as much as to use that

634
00:30:13,740 --> 00:30:17,700
as much as as less as I could

635
00:30:17,700 --> 00:30:20,399
and also because I compared it to the to

636
00:30:20,399 --> 00:30:21,860
the

637
00:30:21,860 --> 00:30:25,919
current Uh current current technique in

638
00:30:25,919 --> 00:30:28,260
the world to tamper with this which is

639
00:30:28,260 --> 00:30:31,500
fairly simple okay just one right so it

640
00:30:31,500 --> 00:30:34,500
won't be that uh

641
00:30:34,500 --> 00:30:35,520
um

642
00:30:35,520 --> 00:30:40,559
that uh appealing for attackers to use

643
00:30:40,559 --> 00:30:43,140
okay thank you great great talk I was

644
00:30:43,140 --> 00:30:44,220
just curious what your thoughts were

645
00:30:44,220 --> 00:30:46,320
around nsa's recent announcement around

646
00:30:46,320 --> 00:30:48,779
trying to move organizations away from C

647
00:30:48,779 --> 00:30:51,659
and C plus plus to rust and more secure

648
00:30:51,659 --> 00:30:53,640
kind of Kernel languages

649
00:30:53,640 --> 00:30:54,240
[Music]

650
00:30:54,240 --> 00:30:54,899
um

651
00:30:54,899 --> 00:30:57,720
I think it's interesting

652
00:30:57,720 --> 00:31:00,240
it's gonna take quite a while

653
00:31:00,240 --> 00:31:02,520
especially with all the fat party

654
00:31:02,520 --> 00:31:05,039
drivers

655
00:31:05,039 --> 00:31:05,820
um

656
00:31:05,820 --> 00:31:07,919
but at the end like most of these

657
00:31:07,919 --> 00:31:10,500
vulnerable drivers it's by Design it's

658
00:31:10,500 --> 00:31:13,080
not like uh that

659
00:31:13,080 --> 00:31:16,140
it's not that they have like some it's

660
00:31:16,140 --> 00:31:18,000
more it's more like logical bugs okay

661
00:31:18,000 --> 00:31:20,820
it's like they just take parameters from

662
00:31:20,820 --> 00:31:22,679
user space scores and just pass it

663
00:31:22,679 --> 00:31:25,500
together to like to Kernel apis and

664
00:31:25,500 --> 00:31:27,899
stuff like that it's not like some very

665
00:31:27,899 --> 00:31:28,330
complex

666
00:31:28,330 --> 00:31:29,720
[Music]

667
00:31:29,720 --> 00:31:32,340
like memory Corruptions or stuff like

668
00:31:32,340 --> 00:31:35,220
that so on that front I don't think rust

669
00:31:35,220 --> 00:31:37,140
will do a lot of

670
00:31:37,140 --> 00:31:38,880
thank you

671
00:31:38,880 --> 00:31:44,460
it seems to me that sometimes these bug

672
00:31:44,460 --> 00:31:48,960
these vulnerabilities are intentional

673
00:31:48,960 --> 00:31:52,740
because they they don't don't activate

674
00:31:52,740 --> 00:31:56,640
the the right Defender system I don't

675
00:31:56,640 --> 00:31:59,640
know what do you think

676
00:31:59,640 --> 00:32:02,399
I'm not not sure which bugs are you

677
00:32:02,399 --> 00:32:06,059
meaning for example the not activation

678
00:32:06,059 --> 00:32:10,140
of the right Defender system like H

679
00:32:10,140 --> 00:32:13,559
Busia I don't remember ah no this is

680
00:32:13,559 --> 00:32:16,440
like Microsoft issues decisions probably

681
00:32:16,440 --> 00:32:17,940
because

682
00:32:17,940 --> 00:32:21,659
I don't really know I just assume that

683
00:32:21,659 --> 00:32:25,100
they had the compatibility issues

684
00:32:25,100 --> 00:32:27,559
like with third party

685
00:32:27,559 --> 00:32:30,440
probably with third-party drivers

686
00:32:30,440 --> 00:32:33,299
so they decided to postpone it until

687
00:32:33,299 --> 00:32:37,919
they uh like force vendors to fix

688
00:32:37,919 --> 00:32:41,640
everything so that's it's not like it's

689
00:32:41,640 --> 00:32:44,640
probably not what they they set out like

690
00:32:44,640 --> 00:32:46,380
what they hope for this feature seven

691
00:32:46,380 --> 00:32:50,520
years ago but that's just the price of

692
00:32:50,520 --> 00:32:53,700
of having such a long-running OS and

693
00:32:53,700 --> 00:32:55,559
user base

694
00:32:55,559 --> 00:32:56,940
thank you

695
00:32:56,940 --> 00:32:59,640
thanks again Omri for installing thank

696
00:32:59,640 --> 00:33:01,760
you

