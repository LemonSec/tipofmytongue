1
00:00:00,000 --> 00:00:13,470
[Music]

2
00:00:14,000 --> 00:00:15,200
google has changed

3
00:00:15,200 --> 00:00:17,840
its android runtime code drastically and

4
00:00:17,840 --> 00:00:19,680
based on the user behavior

5
00:00:19,680 --> 00:00:21,920
profiling of data is done for various

6
00:00:21,920 --> 00:00:23,359
system level

7
00:00:23,359 --> 00:00:26,400
updates storage performance etc the next

8
00:00:26,400 --> 00:00:27,599
talk is going to

9
00:00:27,599 --> 00:00:30,080
show you how to steal data in real time

10
00:00:30,080 --> 00:00:31,519
from android 10

11
00:00:31,519 --> 00:00:35,360
art without execution of code using

12
00:00:35,360 --> 00:00:38,160
this compiler or decomposer let's invite

13
00:00:38,160 --> 00:00:39,760
our next speaker

14
00:00:39,760 --> 00:00:42,320
soon young song to deliver his

15
00:00:42,320 --> 00:00:43,520
presentation

16
00:00:43,520 --> 00:00:46,879
on deep dive into dynamic binary

17
00:00:46,879 --> 00:00:49,200
analysis

18
00:00:49,200 --> 00:00:52,480
thank you yeah i was going to introduce

19
00:00:52,480 --> 00:00:53,600
you but you can go ahead

20
00:00:53,600 --> 00:00:55,360
you can go ahead thank you for

21
00:00:55,360 --> 00:00:58,480
introducing me can i share my screen

22
00:00:58,480 --> 00:01:02,559
absolutely go ahead yeah okay

23
00:01:04,720 --> 00:01:09,920
okay can you see my screen yes

24
00:01:10,840 --> 00:01:12,080
okay

25
00:01:12,080 --> 00:01:14,159
uh nice to meet you everyone my name is

26
00:01:14,159 --> 00:01:15,280
hong hyun song

27
00:01:15,280 --> 00:01:18,000
i work at the fsi of south korea the

28
00:01:18,000 --> 00:01:18,880
apsa is

29
00:01:18,880 --> 00:01:21,439
responsible for the security of korean

30
00:01:21,439 --> 00:01:23,119
financial industry

31
00:01:23,119 --> 00:01:27,040
i am researching mobile security at fsi

32
00:01:27,040 --> 00:01:29,360
and i do penetration testing for korean

33
00:01:29,360 --> 00:01:30,880
financial company

34
00:01:30,880 --> 00:01:32,799
and i have experience speaking at

35
00:01:32,799 --> 00:01:35,439
several international security companies

36
00:01:35,439 --> 00:01:38,479
in europe and asia

37
00:01:38,479 --> 00:01:41,200
today i'd like to analyze how android

38
00:01:41,200 --> 00:01:43,759
runtime works in detail

39
00:01:43,759 --> 00:01:46,799
and based on the analysis result

40
00:01:46,799 --> 00:01:51,280
i'm going to propose a technique uh

41
00:01:51,280 --> 00:01:53,680
to analyze the app easily and

42
00:01:53,680 --> 00:01:56,159
effectively by customizing the android

43
00:01:56,159 --> 00:01:58,640
runtime

44
00:01:58,719 --> 00:02:01,360
first of all i want to explain why i

45
00:02:01,360 --> 00:02:05,280
became interested in android runtime

46
00:02:05,280 --> 00:02:07,920
analyzing mobile app is very important

47
00:02:07,920 --> 00:02:08,560
process

48
00:02:08,560 --> 00:02:12,640
for those who work in mobile security

49
00:02:12,640 --> 00:02:15,920
like marvel analysts or hackers

50
00:02:15,920 --> 00:02:18,400
this is because it's possible to get

51
00:02:18,400 --> 00:02:20,080
clear idea of

52
00:02:20,080 --> 00:02:23,599
how mario works or find vulnerability in

53
00:02:23,599 --> 00:02:26,239
your mobile apps

54
00:02:26,239 --> 00:02:30,879
when proper analysis is done beforehand

55
00:02:30,879 --> 00:02:33,760
there are two main ways uh analyzed

56
00:02:33,760 --> 00:02:35,200
mobile apps

57
00:02:35,200 --> 00:02:37,599
first you can analyze the app if it

58
00:02:37,599 --> 00:02:38,319
exists as

59
00:02:38,319 --> 00:02:41,920
a file in general in android bytecode

60
00:02:41,920 --> 00:02:43,360
can be converted

61
00:02:43,360 --> 00:02:46,080
back to the original java source code

62
00:02:46,080 --> 00:02:48,319
using open source tool such as

63
00:02:48,319 --> 00:02:53,120
text jar another way is to analyze the

64
00:02:53,120 --> 00:02:53,519
app

65
00:02:53,519 --> 00:02:56,640
on while the file is executed and

66
00:02:56,640 --> 00:02:59,519
loaded in memory there is a dynamic

67
00:02:59,519 --> 00:03:00,560
analysis tool

68
00:03:00,560 --> 00:03:03,519
called frida they can analyze the app

69
00:03:03,519 --> 00:03:06,239
during the runtime

70
00:03:06,239 --> 00:03:08,800
freedive is very high level framework

71
00:03:08,800 --> 00:03:09,519
and it's

72
00:03:09,519 --> 00:03:12,159
used by almost or security researchers

73
00:03:12,159 --> 00:03:13,519
to die

74
00:03:13,519 --> 00:03:16,159
so applications that handle sensitive

75
00:03:16,159 --> 00:03:16,959
information

76
00:03:16,959 --> 00:03:20,560
such as banking gaming and healthcare

77
00:03:20,560 --> 00:03:24,080
adopted a secret technique to protect it

78
00:03:24,080 --> 00:03:27,440
protect themselves from the analysis and

79
00:03:27,440 --> 00:03:29,920
attacks

80
00:03:30,640 --> 00:03:33,519
we call this technique rasp runtime

81
00:03:33,519 --> 00:03:34,319
application

82
00:03:34,319 --> 00:03:37,680
self protection many security companies

83
00:03:37,680 --> 00:03:41,440
develop rasp make it module

84
00:03:41,440 --> 00:03:45,360
and sell it and most of apps are

85
00:03:45,360 --> 00:03:46,000
sensitive

86
00:03:46,000 --> 00:03:48,560
information are actually using the

87
00:03:48,560 --> 00:03:49,680
module

88
00:03:49,680 --> 00:03:51,920
this technique check not only whether

89
00:03:51,920 --> 00:03:54,080
the os has been tempored

90
00:03:54,080 --> 00:03:56,560
but they also encrypted transmit or

91
00:03:56,560 --> 00:03:58,080
received data

92
00:03:58,080 --> 00:04:02,000
in addition to that they detect and

93
00:04:02,000 --> 00:04:02,879
block

94
00:04:02,879 --> 00:04:05,760
to unblock the attackers from accessing

95
00:04:05,760 --> 00:04:08,720
the memory area

96
00:04:09,120 --> 00:04:12,640
so if we try to analyze an uh protected

97
00:04:12,640 --> 00:04:12,959
by

98
00:04:12,959 --> 00:04:16,639
rasp you will be detected and blocked

99
00:04:16,639 --> 00:04:20,478
as shown in picture here

100
00:04:20,478 --> 00:04:23,360
this top picture shows the process of

101
00:04:23,360 --> 00:04:24,400
decompile

102
00:04:24,400 --> 00:04:27,199
decompiling to the original java source

103
00:04:27,199 --> 00:04:27,600
code

104
00:04:27,600 --> 00:04:31,280
using desktop since the app is protected

105
00:04:31,280 --> 00:04:31,600
by

106
00:04:31,600 --> 00:04:34,720
ntd compile technique you are in trouble

107
00:04:34,720 --> 00:04:35,040
with

108
00:04:35,040 --> 00:04:38,800
converting it back to the original code

109
00:04:38,800 --> 00:04:41,120
the bottom picture here shown warning

110
00:04:41,120 --> 00:04:42,240
message

111
00:04:42,240 --> 00:04:45,280
generated when it detected running in

112
00:04:45,280 --> 00:04:48,800
a rooted environment or any attempt to

113
00:04:48,800 --> 00:04:51,680
only any attempt to of dynamically

114
00:04:51,680 --> 00:04:56,080
analysis using frida

115
00:04:56,080 --> 00:04:59,440
so can we bypass rasp

116
00:04:59,440 --> 00:05:02,800
of course in my thought there does not

117
00:05:02,800 --> 00:05:06,000
exist 100 percent of ckt but

118
00:05:06,000 --> 00:05:08,240
what i want is an automated and

119
00:05:08,240 --> 00:05:09,120
effective

120
00:05:09,120 --> 00:05:12,800
and first method however secret modules

121
00:05:12,800 --> 00:05:14,479
are difficult to bypass

122
00:05:14,479 --> 00:05:17,120
because they are applied in multi-ways

123
00:05:17,120 --> 00:05:18,720
technique

124
00:05:18,720 --> 00:05:21,840
so what's the problem

125
00:05:21,840 --> 00:05:25,199
the problem is time they also know

126
00:05:25,199 --> 00:05:28,560
that the rasp cannot depend completely

127
00:05:28,560 --> 00:05:31,520
the attacker the propos the purpose of

128
00:05:31,520 --> 00:05:32,560
the rasp

129
00:05:32,560 --> 00:05:35,199
is to annoy the attacker as much as

130
00:05:35,199 --> 00:05:36,240
possible

131
00:05:36,240 --> 00:05:38,479
and increase the time required for the

132
00:05:38,479 --> 00:05:39,520
attack

133
00:05:39,520 --> 00:05:42,160
there is no perfect mechanism and we are

134
00:05:42,160 --> 00:05:46,240
in state of continue to have to fight

135
00:05:46,240 --> 00:05:48,960
i want to get away from the end of this

136
00:05:48,960 --> 00:05:49,440
fight

137
00:05:49,440 --> 00:05:52,720
between protection and bypass just like

138
00:05:52,720 --> 00:05:56,400
time injury so over the past few years

139
00:05:56,400 --> 00:05:59,360
i have been thinking about how the how

140
00:05:59,360 --> 00:06:01,360
to analyze the app easily and

141
00:06:01,360 --> 00:06:02,560
effectively

142
00:06:02,560 --> 00:06:07,600
without being detected by rasp

143
00:06:07,600 --> 00:06:10,400
then i found the two paper published in

144
00:06:10,400 --> 00:06:12,319
eugenics 2010

145
00:06:12,319 --> 00:06:16,800
and amc 2016. the main subject of the

146
00:06:16,800 --> 00:06:18,880
paper were about developing the

147
00:06:18,880 --> 00:06:20,080
framework that can

148
00:06:20,080 --> 00:06:22,400
dynamically analyze that by modifying

149
00:06:22,400 --> 00:06:24,240
the runtime of android

150
00:06:24,240 --> 00:06:27,199
it was very interesting as it modified

151
00:06:27,199 --> 00:06:27,919
the os

152
00:06:27,919 --> 00:06:34,160
to create environment for the analysis

153
00:06:34,160 --> 00:06:36,880
advantage of this technique uh was that

154
00:06:36,880 --> 00:06:37,680
the app could

155
00:06:37,680 --> 00:06:40,400
be innervised without directory access

156
00:06:40,400 --> 00:06:40,720
to

157
00:06:40,720 --> 00:06:44,240
the app's executable file or memory

158
00:06:44,240 --> 00:06:47,600
but sadly the paper were written for old

159
00:06:47,600 --> 00:06:48,800
android

160
00:06:48,800 --> 00:06:51,440
so i had to analyze the new runtime in

161
00:06:51,440 --> 00:06:54,880
android 10 in detail

162
00:06:55,360 --> 00:06:59,599
so i shipped my podcast from application

163
00:06:59,599 --> 00:07:02,800
to android os itself there is

164
00:07:02,800 --> 00:07:06,000
corner and platform

165
00:07:06,319 --> 00:07:08,960
in the first few years i started

166
00:07:08,960 --> 00:07:11,120
analyzing the android source code

167
00:07:11,120 --> 00:07:15,120
and developing the custom os

168
00:07:15,120 --> 00:07:18,319
so i ended up building the android os

169
00:07:18,319 --> 00:07:21,039
by customizing the kernel and platform

170
00:07:21,039 --> 00:07:22,560
the os has built-in

171
00:07:22,560 --> 00:07:25,360
functions such as backdoor for

172
00:07:25,360 --> 00:07:26,960
probability excavation

173
00:07:26,960 --> 00:07:30,000
sc linux bypass android verify boot

174
00:07:30,000 --> 00:07:35,120
by face and corner memory access driver

175
00:07:35,120 --> 00:07:37,520
i don't think i can cover all of these

176
00:07:37,520 --> 00:07:38,800
today due to

177
00:07:38,800 --> 00:07:41,680
the limitation of time so in this

178
00:07:41,680 --> 00:07:42,400
session

179
00:07:42,400 --> 00:07:45,680
i will focus the presentation presenting

180
00:07:45,680 --> 00:07:48,960
how customizing the runtime for dynamic

181
00:07:48,960 --> 00:07:52,080
analysis of app

182
00:07:52,560 --> 00:07:55,919
aert is obviation for android runtime

183
00:07:55,919 --> 00:07:59,280
ait can be called heart of android

184
00:07:59,280 --> 00:08:02,639
and player key role in loading app

185
00:08:02,639 --> 00:08:04,960
loading and binary application memory

186
00:08:04,960 --> 00:08:06,080
management

187
00:08:06,080 --> 00:08:09,919
app execution and optimization however

188
00:08:09,919 --> 00:08:12,960
it is not easy to analyze in deep how to

189
00:08:12,960 --> 00:08:15,440
how the runtime works in the residence

190
00:08:15,440 --> 00:08:18,240
version of android

191
00:08:18,240 --> 00:08:21,520
this is because the size of code is huge

192
00:08:21,520 --> 00:08:24,560
about 100 gigabyte and

193
00:08:24,560 --> 00:08:28,080
various techniques compiling profiling

194
00:08:28,080 --> 00:08:31,199
and optimization are also applied to

195
00:08:31,199 --> 00:08:35,200
the rest this version of ait in addition

196
00:08:35,200 --> 00:08:37,440
since google has changed the android

197
00:08:37,440 --> 00:08:38,839
runtime to rest

198
00:08:38,839 --> 00:08:41,760
touristically each time of new version

199
00:08:41,760 --> 00:08:42,880
of android

200
00:08:42,880 --> 00:08:46,880
is released to optimize the performance

201
00:08:46,880 --> 00:08:49,200
storage usage and the system of data

202
00:08:49,200 --> 00:08:50,240
webs

203
00:08:50,240 --> 00:08:53,200
how is structure and how it operates are

204
00:08:53,200 --> 00:08:54,000
different from

205
00:08:54,000 --> 00:08:57,279
each runtime version

206
00:08:58,640 --> 00:09:01,760
however since all since all the code of

207
00:09:01,760 --> 00:09:03,120
app is interpreted

208
00:09:03,120 --> 00:09:06,080
and executed through the aert if the

209
00:09:06,080 --> 00:09:06,800
attacker

210
00:09:06,800 --> 00:09:10,560
understands how exactly the app works on

211
00:09:10,560 --> 00:09:13,839
ait all necessary information can be

212
00:09:13,839 --> 00:09:15,600
stolen in real time

213
00:09:15,600 --> 00:09:18,480
to analyze there in this speaking

214
00:09:18,480 --> 00:09:19,680
therefore aim to

215
00:09:19,680 --> 00:09:22,880
analyze android 10 art in detail

216
00:09:22,880 --> 00:09:25,360
i propose a new technique to quickly and

217
00:09:25,360 --> 00:09:26,480
effectively

218
00:09:26,480 --> 00:09:30,480
analyze the app by modifying the ait

219
00:09:30,480 --> 00:09:34,000
to divide from the existing app analysis

220
00:09:34,000 --> 00:09:35,519
method

221
00:09:35,519 --> 00:09:39,200
i propose a new technique this technique

222
00:09:39,200 --> 00:09:40,480
is not detected by

223
00:09:40,480 --> 00:09:44,959
rasp and enable dynamical analysis

224
00:09:44,959 --> 00:09:48,839
of all the function executed through the

225
00:09:48,839 --> 00:09:50,480
aid

226
00:09:50,480 --> 00:09:53,519
and i also develop a framework in

227
00:09:53,519 --> 00:09:56,560
in which an attacker can still call

228
00:09:56,560 --> 00:09:59,839
interface parameters written value

229
00:09:59,839 --> 00:10:02,640
field and stack trace of running

230
00:10:02,640 --> 00:10:04,480
function in the real time

231
00:10:04,480 --> 00:10:08,720
without using debugger or hooking tool

232
00:10:10,000 --> 00:10:12,959
let's take a look at how android runtime

233
00:10:12,959 --> 00:10:19,680
has changed from version to version

234
00:10:19,680 --> 00:10:22,399
first uh when we talk about java and

235
00:10:22,399 --> 00:10:23,920
java virtual machine

236
00:10:23,920 --> 00:10:26,160
an android application is written in

237
00:10:26,160 --> 00:10:27,920
java language for developer

238
00:10:27,920 --> 00:10:31,120
productivity and code mobility

239
00:10:31,120 --> 00:10:33,519
on desktop and server environment or

240
00:10:33,519 --> 00:10:34,240
java

241
00:10:34,240 --> 00:10:36,480
program is compiled to the java byte

242
00:10:36,480 --> 00:10:38,079
code

243
00:10:38,079 --> 00:10:41,040
which is an intermediate representation

244
00:10:41,040 --> 00:10:42,959
for java virtual machine

245
00:10:42,959 --> 00:10:45,839
jpm run the java byte code and the java

246
00:10:45,839 --> 00:10:48,320
byte code is based on a stack based

247
00:10:48,320 --> 00:10:51,200
instruction however since the

248
00:10:51,200 --> 00:10:53,279
performance of a stack trace

249
00:10:53,279 --> 00:10:56,360
stack-based java-based java byte code on

250
00:10:56,360 --> 00:10:57,920
resource-limited

251
00:10:57,920 --> 00:11:00,640
mobile device is poor due to slow

252
00:11:00,640 --> 00:11:03,440
interpretation

253
00:11:03,440 --> 00:11:05,920
so android researchers have created a

254
00:11:05,920 --> 00:11:07,519
new byte code set

255
00:11:07,519 --> 00:11:09,680
which is a diabetic byte code for

256
00:11:09,680 --> 00:11:12,000
diabetic virtual machine

257
00:11:12,000 --> 00:11:14,079
to improve the performance of android

258
00:11:14,079 --> 00:11:15,279
application

259
00:11:15,279 --> 00:11:18,320
in contrast java byte code direct byte

260
00:11:18,320 --> 00:11:20,000
code is based on the

261
00:11:20,000 --> 00:11:22,800
register based instruction set therefore

262
00:11:22,800 --> 00:11:24,880
it can reduce the code size and the

263
00:11:24,880 --> 00:11:25,760
running time

264
00:11:25,760 --> 00:11:29,279
in mobile device

265
00:11:29,279 --> 00:11:32,160
until android pro had earlier there was

266
00:11:32,160 --> 00:11:33,360
only interpreter

267
00:11:33,360 --> 00:11:36,000
in derby virtual machine every time you

268
00:11:36,000 --> 00:11:37,519
run app

269
00:11:37,519 --> 00:11:39,760
the interpreter converts all byte code

270
00:11:39,760 --> 00:11:41,760
into dative code

271
00:11:41,760 --> 00:11:45,519
is slow down up startup time so battery

272
00:11:45,519 --> 00:11:49,279
in order to boost up the performance

273
00:11:49,279 --> 00:11:52,079
jit compiler was introduced in android

274
00:11:52,079 --> 00:11:54,480
pro on derby virtual machine

275
00:11:54,480 --> 00:11:56,880
jit compiler catch the code while

276
00:11:56,880 --> 00:11:58,160
generating

277
00:11:58,160 --> 00:12:02,079
the native code at the time of execution

278
00:12:02,079 --> 00:12:05,360
to prevent to prevent repeated generated

279
00:12:05,360 --> 00:12:05,680
of

280
00:12:05,680 --> 00:12:08,399
native code for each time of same

281
00:12:08,399 --> 00:12:10,240
function call

282
00:12:10,240 --> 00:12:12,240
as frequently used functions are

283
00:12:12,240 --> 00:12:14,639
executed with the native code

284
00:12:14,639 --> 00:12:17,600
that was created in advance the

285
00:12:17,600 --> 00:12:18,320
performance

286
00:12:18,320 --> 00:12:21,760
has increased this code however

287
00:12:21,760 --> 00:12:25,120
consumed the amount of memory

288
00:12:25,120 --> 00:12:27,839
the runtime structure when did an

289
00:12:27,839 --> 00:12:28,959
interpreter

290
00:12:28,959 --> 00:12:31,600
were in place had not changed for a

291
00:12:31,600 --> 00:12:33,920
while

292
00:12:34,079 --> 00:12:36,639
the conventional approaching result is

293
00:12:36,639 --> 00:12:38,079
very raw performance

294
00:12:38,079 --> 00:12:40,880
when compared to the compiled language

295
00:12:40,880 --> 00:12:41,279
like

296
00:12:41,279 --> 00:12:45,279
c and c plus plus as a result

297
00:12:45,279 --> 00:12:47,680
slow and space space constrained

298
00:12:47,680 --> 00:12:49,040
computing device

299
00:12:49,040 --> 00:12:51,120
have tended not to include virtual

300
00:12:51,120 --> 00:12:53,360
machine

301
00:12:53,360 --> 00:12:56,480
so android kitkat google introduced a

302
00:12:56,480 --> 00:12:57,440
new runtime

303
00:12:57,440 --> 00:13:00,480
aert in android kitkat

304
00:13:00,480 --> 00:13:04,480
ait was experimentally available

305
00:13:04,480 --> 00:13:08,720
starting from android lollipop in 2015

306
00:13:08,720 --> 00:13:10,959
google decided to replace typing virtual

307
00:13:10,959 --> 00:13:11,760
machine and

308
00:13:11,760 --> 00:13:15,200
made alt as the default runtime

309
00:13:15,200 --> 00:13:20,000
to improve the runtime and performance

310
00:13:20,000 --> 00:13:22,800
ait adopted ahead of time compilation

311
00:13:22,800 --> 00:13:24,000
strategies

312
00:13:24,000 --> 00:13:27,839
instead of interpretation ait provide

313
00:13:27,839 --> 00:13:31,920
compiler called dex 208 the dex 2080

314
00:13:31,920 --> 00:13:34,480
will directly compile text byte code

315
00:13:34,480 --> 00:13:36,000
into data code

316
00:13:36,000 --> 00:13:39,279
during app installation and then stored

317
00:13:39,279 --> 00:13:39,600
as

318
00:13:39,600 --> 00:13:43,120
an aot file

319
00:13:43,120 --> 00:13:46,639
the result is essentially an erf file

320
00:13:46,639 --> 00:13:47,600
that

321
00:13:47,600 --> 00:13:50,720
that is then executed natively

322
00:13:50,720 --> 00:13:53,600
so instead of having byte code that is

323
00:13:53,600 --> 00:13:54,720
interpreting

324
00:13:54,720 --> 00:13:57,920
by virtual machine it now has native

325
00:13:57,920 --> 00:13:59,120
code they can

326
00:13:59,120 --> 00:14:02,880
execute it natively by the processor

327
00:14:02,880 --> 00:14:06,399
this is called aot compilation but

328
00:14:06,399 --> 00:14:09,360
main deployment is aert pre-compiled

329
00:14:09,360 --> 00:14:11,279
pre-comprise everything

330
00:14:11,279 --> 00:14:13,680
the target virtual machine using

331
00:14:13,680 --> 00:14:14,560
heuristic

332
00:14:14,560 --> 00:14:17,600
to detect the code that runs

333
00:14:17,600 --> 00:14:20,959
most to open and only compile the subset

334
00:14:20,959 --> 00:14:22,240
of byte code

335
00:14:22,240 --> 00:14:25,199
during execution

336
00:14:25,600 --> 00:14:28,639
and another difference between old deep

337
00:14:28,639 --> 00:14:31,519
dark virtual machine and art was the

338
00:14:31,519 --> 00:14:33,199
performance

339
00:14:33,199 --> 00:14:36,480
as all execution code of app were when

340
00:14:36,480 --> 00:14:39,519
as a native code the startup or speed

341
00:14:39,519 --> 00:14:40,480
was improved

342
00:14:40,480 --> 00:14:43,839
compared to the bytecode in addition to

343
00:14:43,839 --> 00:14:46,079
that every time you render out

344
00:14:46,079 --> 00:14:48,720
it didn't use an interpreter but it

345
00:14:48,720 --> 00:14:51,360
called the native code

346
00:14:51,360 --> 00:14:54,079
and it resulted in reducing battery

347
00:14:54,079 --> 00:14:55,279
consumption

348
00:14:55,279 --> 00:14:59,680
consumption our cheat was used anymore

349
00:14:59,680 --> 00:15:02,240
the memory usage was also reduced

350
00:15:02,240 --> 00:15:03,040
because

351
00:15:03,040 --> 00:15:06,160
it didn't keep the code cache memory

352
00:15:06,160 --> 00:15:09,199
and wait on aot compilation

353
00:15:09,199 --> 00:15:12,320
to tax 2080 compiler can perform

354
00:15:12,320 --> 00:15:13,680
multiple passes for

355
00:15:13,680 --> 00:15:16,160
optimization to archive a better

356
00:15:16,160 --> 00:15:18,800
performance

357
00:15:19,680 --> 00:15:23,199
but it lost as much as it gained

358
00:15:23,199 --> 00:15:26,079
the biggest problem was it took too much

359
00:15:26,079 --> 00:15:28,079
time to install apps

360
00:15:28,079 --> 00:15:30,800
and it took too much time to update the

361
00:15:30,800 --> 00:15:31,440
system

362
00:15:31,440 --> 00:15:34,720
via ota eventually

363
00:15:34,720 --> 00:15:38,240
by compiling all bytecode to native code

364
00:15:38,240 --> 00:15:41,279
at app install time it gain the app's

365
00:15:41,279 --> 00:15:42,399
performance

366
00:15:42,399 --> 00:15:45,759
however it requires more time to update

367
00:15:45,759 --> 00:15:47,360
apps and system

368
00:15:47,360 --> 00:15:50,880
and more storage too then

369
00:15:50,880 --> 00:15:54,079
it is really too best to pass to compile

370
00:15:54,079 --> 00:15:57,120
or write code into dative code at

371
00:15:57,120 --> 00:16:00,240
app insert time we need to first

372
00:16:00,240 --> 00:16:04,560
understand usage pattern of mobile users

373
00:16:04,560 --> 00:16:07,680
in fact we don't use all menus in

374
00:16:07,680 --> 00:16:10,480
in the app for example i use the mobile

375
00:16:10,480 --> 00:16:11,600
banking app

376
00:16:11,600 --> 00:16:14,160
there are a lot of financial related

377
00:16:14,160 --> 00:16:16,800
menu in there

378
00:16:16,800 --> 00:16:19,839
and i use just two menu

379
00:16:19,839 --> 00:16:22,880
first i check how much is my

380
00:16:22,880 --> 00:16:26,399
how much in my account second i transfer

381
00:16:26,399 --> 00:16:27,440
money from

382
00:16:27,440 --> 00:16:30,880
the account that's it although there are

383
00:16:30,880 --> 00:16:32,639
so many menus in the up

384
00:16:32,639 --> 00:16:35,680
i use only two feature then

385
00:16:35,680 --> 00:16:37,360
you don't really need to compile

386
00:16:37,360 --> 00:16:41,279
everything wasting your time and stories

387
00:16:41,279 --> 00:16:43,839
all you need is a selectively compiled

388
00:16:43,839 --> 00:16:44,320
code

389
00:16:44,320 --> 00:16:48,800
that is frequently used by users

390
00:16:49,519 --> 00:16:52,800
so in android 7 google was reintroduced

391
00:16:52,800 --> 00:16:53,120
the

392
00:16:53,120 --> 00:16:56,639
just-in-time compiler that was removed

393
00:16:56,639 --> 00:16:59,199
in android 5.

394
00:16:59,199 --> 00:17:02,320
the jit compiler complements aut

395
00:17:02,320 --> 00:17:03,360
compiler

396
00:17:03,360 --> 00:17:07,839
and help improve runtime performance

397
00:17:07,839 --> 00:17:10,400
and they removed the bytecode compiling

398
00:17:10,400 --> 00:17:10,880
step

399
00:17:10,880 --> 00:17:13,760
in aut compilation during the app

400
00:17:13,760 --> 00:17:15,439
installation

401
00:17:15,439 --> 00:17:21,439
so when the aut compiler starts working

402
00:17:21,439 --> 00:17:23,839
google introduced a new technique called

403
00:17:23,839 --> 00:17:26,480
profile guide optimization

404
00:17:26,480 --> 00:17:29,039
during the app installation the aot

405
00:17:29,039 --> 00:17:31,120
compiler does not operate

406
00:17:31,120 --> 00:17:34,559
and the app is is installed immediately

407
00:17:34,559 --> 00:17:37,600
by as bytecode

408
00:17:37,600 --> 00:17:39,840
when you use the app the bytecode is

409
00:17:39,840 --> 00:17:40,640
executed

410
00:17:40,640 --> 00:17:43,840
using the interpreter and it counts how

411
00:17:43,840 --> 00:17:44,880
many times

412
00:17:44,880 --> 00:17:47,440
each individual function is called at

413
00:17:47,440 --> 00:17:50,400
execution time

414
00:17:51,280 --> 00:17:54,080
as the number of execution increases it

415
00:17:54,080 --> 00:17:54,480
by

416
00:17:54,480 --> 00:17:57,600
it divides a state of function from cold

417
00:17:57,600 --> 00:18:01,600
to one and finally had once the state of

418
00:18:01,600 --> 00:18:05,360
function uh becomes warm profiling info

419
00:18:05,360 --> 00:18:09,039
is created created to record the

420
00:18:09,039 --> 00:18:10,559
information

421
00:18:10,559 --> 00:18:13,760
such as a number of execution then save

422
00:18:13,760 --> 00:18:16,799
in the mobile device

423
00:18:16,799 --> 00:18:19,200
when you don't use your phone or when

424
00:18:19,200 --> 00:18:20,720
you charge it

425
00:18:20,720 --> 00:18:23,440
based on the profiling input the profile

426
00:18:23,440 --> 00:18:25,679
service is used on auto

427
00:18:25,679 --> 00:18:28,400
compile to the byte code into native

428
00:18:28,400 --> 00:18:29,200
code

429
00:18:29,200 --> 00:18:33,039
and store it and once once the state of

430
00:18:33,039 --> 00:18:33,600
function

431
00:18:33,600 --> 00:18:36,320
reached the heart the byte code is

432
00:18:36,320 --> 00:18:37,360
compiling

433
00:18:37,360 --> 00:18:39,520
compiled into native code by git

434
00:18:39,520 --> 00:18:40,559
compiler

435
00:18:40,559 --> 00:18:45,280
and stored in memory as a cache

436
00:18:45,280 --> 00:18:47,919
i explained earlier and the old

437
00:18:47,919 --> 00:18:50,400
compilation method convert all byte code

438
00:18:50,400 --> 00:18:51,360
into

439
00:18:51,360 --> 00:18:54,640
native code and store the regardless of

440
00:18:54,640 --> 00:18:57,039
the usage pattern

441
00:18:57,039 --> 00:19:00,080
it it really slowed down the update and

442
00:19:00,080 --> 00:19:03,919
installation and required more space

443
00:19:03,919 --> 00:19:06,480
but now we have profile guided

444
00:19:06,480 --> 00:19:07,840
optimization

445
00:19:07,840 --> 00:19:10,720
that selectively create a native code

446
00:19:10,720 --> 00:19:13,679
for the feature frequently used

447
00:19:13,679 --> 00:19:16,000
profile guide optimization already

448
00:19:16,000 --> 00:19:17,600
android runtime to help

449
00:19:17,600 --> 00:19:21,440
improve improve the app's performance

450
00:19:21,440 --> 00:19:24,880
by profiling by building a profile

451
00:19:24,880 --> 00:19:27,919
of the app's hard code and focusing in

452
00:19:27,919 --> 00:19:30,160
each optimization

453
00:19:30,160 --> 00:19:33,200
it uh it leads to big improvement

454
00:19:33,200 --> 00:19:36,880
while reducing the traditional memory

455
00:19:36,880 --> 00:19:39,600
and the storage impact of a fully

456
00:19:39,600 --> 00:19:41,200
compiled app

457
00:19:41,200 --> 00:19:44,080
it seems we found the perfect balance

458
00:19:44,080 --> 00:19:45,760
between app speed

459
00:19:45,760 --> 00:19:48,400
storage usage and the update time

460
00:19:48,400 --> 00:19:49,600
however

461
00:19:49,600 --> 00:19:52,320
sadly on this method turn out bring

462
00:19:52,320 --> 00:19:54,240
another problem

463
00:19:54,240 --> 00:19:58,000
so watch problem here

464
00:19:59,760 --> 00:20:02,799
however f1 slow at first once

465
00:20:02,799 --> 00:20:06,159
because profile guide optimization rely

466
00:20:06,159 --> 00:20:07,360
on the device

467
00:20:07,360 --> 00:20:10,960
to optimize app based on this code

468
00:20:10,960 --> 00:20:11,679
profile

469
00:20:11,679 --> 00:20:15,039
in either time which means it could be

470
00:20:15,039 --> 00:20:18,840
a few days before on the app to run

471
00:20:18,840 --> 00:20:20,799
faster

472
00:20:20,799 --> 00:20:23,679
to solve the problem of slow execution

473
00:20:23,679 --> 00:20:24,799
at first launch

474
00:20:24,799 --> 00:20:28,159
of app google introduced or introduced

475
00:20:28,159 --> 00:20:30,400
cloud-based profile technique

476
00:20:30,400 --> 00:20:33,840
in android 9. as shown in figure the

477
00:20:33,840 --> 00:20:36,320
profile information of app created

478
00:20:36,320 --> 00:20:39,760
on each user's device is uploaded to the

479
00:20:39,760 --> 00:20:41,840
cloud server

480
00:20:41,840 --> 00:20:45,919
the cloud server most uh app share

481
00:20:45,919 --> 00:20:47,840
good amount of code profiling

482
00:20:47,840 --> 00:20:50,159
information that are used across of

483
00:20:50,159 --> 00:20:51,520
different users

484
00:20:51,520 --> 00:20:54,960
and device and this can be globally

485
00:20:54,960 --> 00:20:57,520
optimized for everyone

486
00:20:57,520 --> 00:21:00,640
the initial user's device can create

487
00:21:00,640 --> 00:21:03,679
profile information for rest of

488
00:21:03,679 --> 00:21:07,440
the user space so the following users

489
00:21:07,440 --> 00:21:08,960
can optimize the

490
00:21:08,960 --> 00:21:11,600
app after aud compilation using

491
00:21:11,600 --> 00:21:14,000
cloud-based profile data

492
00:21:14,000 --> 00:21:17,840
at the time of app insulation

493
00:21:18,960 --> 00:21:22,240
this slide shows the whole process

494
00:21:22,240 --> 00:21:25,760
of how apps are compiled and executed

495
00:21:25,760 --> 00:21:29,039
in android 10. first when you try to

496
00:21:29,039 --> 00:21:32,240
install app apk file downloaded from

497
00:21:32,240 --> 00:21:34,880
downloaded to your mobile device along

498
00:21:34,880 --> 00:21:36,080
with optimize

499
00:21:36,080 --> 00:21:39,919
the profile data as i described earlier

500
00:21:39,919 --> 00:21:42,400
during the installation the profile

501
00:21:42,400 --> 00:21:43,679
information is used

502
00:21:43,679 --> 00:21:47,280
by aot compiler to selectively compile

503
00:21:47,280 --> 00:21:50,000
the byte code into aud code

504
00:21:50,000 --> 00:21:52,880
for fun for the function are commonly

505
00:21:52,880 --> 00:21:54,720
used by users

506
00:21:54,720 --> 00:21:58,000
second when you executed a art check

507
00:21:58,000 --> 00:22:00,480
whether the code of the running method

508
00:22:00,480 --> 00:22:02,480
is compiled or not

509
00:22:02,480 --> 00:22:04,960
if the code is already compiled by did

510
00:22:04,960 --> 00:22:06,559
or aot

511
00:22:06,559 --> 00:22:08,799
it directly called the code voted in

512
00:22:08,799 --> 00:22:10,840
memory and executed it

513
00:22:10,840 --> 00:22:13,200
immediately if the code is still

514
00:22:13,200 --> 00:22:14,640
bytecode

515
00:22:14,640 --> 00:22:17,679
the interpreter executed in and increase

516
00:22:17,679 --> 00:22:21,200
the method execution counter

517
00:22:21,200 --> 00:22:23,760
if the counter of the method continued

518
00:22:23,760 --> 00:22:25,120
to increase

519
00:22:25,120 --> 00:22:28,640
and it become warm state the profile

520
00:22:28,640 --> 00:22:31,679
information such as the number of

521
00:22:31,679 --> 00:22:34,240
number of method execution is saved in

522
00:22:34,240 --> 00:22:36,799
the device as your file

523
00:22:36,799 --> 00:22:39,919
why you are not using the phone just

524
00:22:39,919 --> 00:22:41,520
charging overnight

525
00:22:41,520 --> 00:22:43,679
the service compared the service

526
00:22:43,679 --> 00:22:45,039
compiled the one step

527
00:22:45,039 --> 00:22:48,080
one method using aut compiler

528
00:22:48,080 --> 00:22:52,720
and disable it in in file as a aot code

529
00:22:52,720 --> 00:22:55,360
next time method will uh will be

530
00:22:55,360 --> 00:22:56,240
executed

531
00:22:56,240 --> 00:22:59,280
right way as aot code

532
00:22:59,280 --> 00:23:02,960
from beginning and if the counter keep

533
00:23:02,960 --> 00:23:04,240
increasing

534
00:23:04,240 --> 00:23:07,120
and it finally becomes hot state the

535
00:23:07,120 --> 00:23:09,280
method is compiled in the real time

536
00:23:09,280 --> 00:23:12,640
by jit compiler and stored in memory as

537
00:23:12,640 --> 00:23:16,559
code cache then the code odd memory

538
00:23:16,559 --> 00:23:19,200
is executed as soon as function is

539
00:23:19,200 --> 00:23:21,280
called

540
00:23:21,280 --> 00:23:24,240
as you can see here a art is a barrier

541
00:23:24,240 --> 00:23:25,360
status

542
00:23:25,360 --> 00:23:29,280
state of code and complex structure

543
00:23:29,280 --> 00:23:31,919
where the app are optimized and executed

544
00:23:31,919 --> 00:23:33,360
based on the pattern

545
00:23:33,360 --> 00:23:38,159
of the individual and entire user base

546
00:23:38,159 --> 00:23:41,919
okay now i'd like to take

547
00:23:41,919 --> 00:23:44,240
a closer look at the android one time at

548
00:23:44,240 --> 00:23:45,679
the code weber

549
00:23:45,679 --> 00:23:48,080
based on that i'm going to propose a

550
00:23:48,080 --> 00:23:50,240
technique to analyze the execution

551
00:23:50,240 --> 00:23:54,159
of app during the ait customization

552
00:23:54,159 --> 00:23:56,880
as we saw earlier there are three types

553
00:23:56,880 --> 00:23:58,960
of code in ait

554
00:23:58,960 --> 00:24:02,400
the basic text code compiled a

555
00:24:02,400 --> 00:24:06,799
aot code and the cheat code aot code and

556
00:24:06,799 --> 00:24:10,000
byte code are saved in the file while

557
00:24:10,000 --> 00:24:11,200
zip code

558
00:24:11,200 --> 00:24:15,200
exists in memory as a cache code

559
00:24:15,200 --> 00:24:17,600
in mobile device there are three files

560
00:24:17,600 --> 00:24:19,679
in application

561
00:24:19,679 --> 00:24:22,080
application directory the stored aot

562
00:24:22,080 --> 00:24:22,960
code

563
00:24:22,960 --> 00:24:26,320
and bytecode bytecode information

564
00:24:26,320 --> 00:24:29,760
the first one is base ait

565
00:24:29,760 --> 00:24:32,760
the file contains art internal

566
00:24:32,760 --> 00:24:33,919
representation

567
00:24:33,919 --> 00:24:37,200
of some strings and classes rest

568
00:24:37,200 --> 00:24:40,720
in apk used to use it to boost up

569
00:24:40,720 --> 00:24:44,320
application startup time the second one

570
00:24:44,320 --> 00:24:47,520
is base odex file the file contains the

571
00:24:47,520 --> 00:24:49,440
aut compiled code for

572
00:24:49,440 --> 00:24:53,440
method in apk the rest one is base

573
00:24:53,440 --> 00:24:56,480
base bridex file this file contains

574
00:24:56,480 --> 00:25:00,000
text code in apk with some additional

575
00:25:00,000 --> 00:25:02,799
meth uh metadata to speed up

576
00:25:02,799 --> 00:25:05,600
verification

577
00:25:06,799 --> 00:25:09,600
this file can be dumped on to text byte

578
00:25:09,600 --> 00:25:13,520
code and aut code using oat dump module

579
00:25:13,520 --> 00:25:16,080
these features show the result of

580
00:25:16,080 --> 00:25:17,039
dumping

581
00:25:17,039 --> 00:25:20,400
the base odex file stored in

582
00:25:20,400 --> 00:25:23,440
application directory

583
00:25:23,440 --> 00:25:27,120
if we look at the first line in blue

584
00:25:27,120 --> 00:25:30,320
there is the any function as

585
00:25:30,320 --> 00:25:33,600
as first method in in the class and

586
00:25:33,600 --> 00:25:39,279
the name is uh com f epsilon internal ac

587
00:25:39,440 --> 00:25:41,520
this any function exists in two

588
00:25:41,520 --> 00:25:44,240
different forms

589
00:25:44,240 --> 00:25:47,360
the part written as dexcode is a byte

590
00:25:47,360 --> 00:25:48,000
code of

591
00:25:48,000 --> 00:25:51,039
any function the second part is

592
00:25:51,039 --> 00:25:53,919
written code is compiled code which was

593
00:25:53,919 --> 00:25:54,880
converted from

594
00:25:54,880 --> 00:25:58,320
bytecode into aut compiler

595
00:25:58,320 --> 00:26:01,120
and if you look at another part you can

596
00:26:01,120 --> 00:26:03,039
see any function

597
00:26:03,039 --> 00:26:08,799
in class com apps fire internal td1

598
00:26:08,880 --> 00:26:12,240
this function has dax code but

599
00:26:12,240 --> 00:26:16,720
the code area just shows no code

600
00:26:16,720 --> 00:26:19,840
it has no compiled code but it exists

601
00:26:19,840 --> 00:26:22,000
only as byte code

602
00:26:22,000 --> 00:26:24,640
so what does it mean even if the

603
00:26:24,640 --> 00:26:25,200
function

604
00:26:25,200 --> 00:26:27,840
converted and saved into the compiled

605
00:26:27,840 --> 00:26:28,559
code by

606
00:26:28,559 --> 00:26:31,840
aot compiler the byte code is saved

607
00:26:31,840 --> 00:26:33,279
anyway

608
00:26:33,279 --> 00:26:35,600
this is because the original byte code

609
00:26:35,600 --> 00:26:36,400
is used

610
00:26:36,400 --> 00:26:39,440
when debugging is required or ait

611
00:26:39,440 --> 00:26:40,320
updated

612
00:26:40,320 --> 00:26:45,439
to re-optimize the code in india

613
00:26:46,559 --> 00:26:50,640
if so let's take how bytecode and aot

614
00:26:50,640 --> 00:26:51,840
code are loaded

615
00:26:51,840 --> 00:26:55,360
into memory by ait it's called link

616
00:26:55,360 --> 00:26:57,919
to ait method object through the class

617
00:26:57,919 --> 00:26:59,360
wrinkle

618
00:26:59,360 --> 00:27:04,960
the alt object is art method object is

619
00:27:04,960 --> 00:27:08,400
is the instantiated object

620
00:27:08,400 --> 00:27:11,760
in the form of c plus plus class

621
00:27:11,760 --> 00:27:14,640
to executed each method within the java

622
00:27:14,640 --> 00:27:16,880
class on art

623
00:27:16,880 --> 00:27:19,840
base odx file contain the oat code and

624
00:27:19,840 --> 00:27:23,039
the base redex file contain the bytecode

625
00:27:23,039 --> 00:27:26,080
when the app is executed

626
00:27:26,080 --> 00:27:28,480
each file wrote it into memory by one

627
00:27:28,480 --> 00:27:29,600
time

628
00:27:29,600 --> 00:27:32,720
this this is a simple simplified picture

629
00:27:32,720 --> 00:27:36,240
how aortical aot and byte code

630
00:27:36,240 --> 00:27:39,440
are linked to ait method object

631
00:27:39,440 --> 00:27:41,840
inside inside the art through the

632
00:27:41,840 --> 00:27:44,720
cross-linker

633
00:27:44,880 --> 00:27:47,520
before the execution or method into

634
00:27:47,520 --> 00:27:48,240
india

635
00:27:48,240 --> 00:27:51,760
are linked to the execution called our

636
00:27:51,760 --> 00:27:55,440
as uh arg object aid message

637
00:27:55,440 --> 00:27:58,080
the class linker called the function set

638
00:27:58,080 --> 00:28:00,000
entry point from

639
00:28:00,000 --> 00:28:02,960
compiled code to assign the address of

640
00:28:02,960 --> 00:28:04,480
aot code

641
00:28:04,480 --> 00:28:07,200
to the entry point from key compiled

642
00:28:07,200 --> 00:28:07,679
code

643
00:28:07,679 --> 00:28:11,200
variable of ait method object

644
00:28:11,200 --> 00:28:14,080
and by calling set the korean correct

645
00:28:14,080 --> 00:28:16,320
set declaring class function

646
00:28:16,320 --> 00:28:19,600
text cache is assigned a declaring class

647
00:28:19,600 --> 00:28:20,559
variable

648
00:28:20,559 --> 00:28:30,080
of a alt method object

649
00:28:30,080 --> 00:28:32,240
now we can call the byte code through

650
00:28:32,240 --> 00:28:33,520
the text cache

651
00:28:33,520 --> 00:28:37,200
in short all functions executed by ait

652
00:28:37,200 --> 00:28:41,840
are loaded into each ait

653
00:28:41,840 --> 00:28:45,200
or alt or method object

654
00:28:45,200 --> 00:28:48,480
we can executed a function through

655
00:28:48,480 --> 00:28:52,320
this object as we saw here

656
00:28:52,320 --> 00:28:55,760
there are more than one type of code

657
00:28:55,760 --> 00:28:59,840
we want executed

658
00:29:00,480 --> 00:29:03,120
so we need to call different type of

659
00:29:03,120 --> 00:29:03,840
code

660
00:29:03,840 --> 00:29:13,360
or bytecode and compiled code

661
00:29:13,360 --> 00:29:15,919
as shown in the picture one main

662
00:29:15,919 --> 00:29:18,320
function consists of

663
00:29:18,320 --> 00:29:20,880
several sub function and each sole

664
00:29:20,880 --> 00:29:23,520
function also consists of

665
00:29:23,520 --> 00:29:26,559
several smaller sole function let's take

666
00:29:26,559 --> 00:29:27,760
a look at

667
00:29:27,760 --> 00:29:31,600
the step to call the execute

668
00:29:31,600 --> 00:29:35,199
so function232

669
00:29:36,080 --> 00:29:39,120
main function and solve function2 so

670
00:29:39,120 --> 00:29:39,760
function 2

671
00:29:39,760 --> 00:29:43,360
3 so function 2 3 2 are called

672
00:29:43,360 --> 00:29:47,360
in that order each function exists

673
00:29:47,360 --> 00:29:48,240
particularly

674
00:29:48,240 --> 00:29:51,919
as bytecode and partially compiled code

675
00:29:51,919 --> 00:29:54,320
because of that we need to call the

676
00:29:54,320 --> 00:29:56,559
compiled code from bytecode

677
00:29:56,559 --> 00:29:59,840
and bytecode from the compiled code

678
00:29:59,840 --> 00:30:03,120
this cross core from different code make

679
00:30:03,120 --> 00:30:07,200
art structure more complicated

680
00:30:07,200 --> 00:30:10,559
so let's see how art cross called the

681
00:30:10,559 --> 00:30:13,440
different code

682
00:30:15,279 --> 00:30:18,320
the first code execution is started

683
00:30:18,320 --> 00:30:21,919
from the ait method this is because the

684
00:30:21,919 --> 00:30:23,520
ait method object

685
00:30:23,520 --> 00:30:27,520
both bytecode and compiled code

686
00:30:27,520 --> 00:30:29,919
if the function exists as a compiled

687
00:30:29,919 --> 00:30:30,720
code

688
00:30:30,720 --> 00:30:33,440
alt directly invoked the code and

689
00:30:33,440 --> 00:30:36,799
executed it

690
00:30:36,799 --> 00:30:39,200
if the compiled code doesn't exist the

691
00:30:39,200 --> 00:30:40,320
interpreter is

692
00:30:40,320 --> 00:30:42,960
used to execute the byte code of the

693
00:30:42,960 --> 00:30:44,320
function

694
00:30:44,320 --> 00:30:46,799
and after the execution of different

695
00:30:46,799 --> 00:30:48,159
type of function

696
00:30:48,159 --> 00:30:50,720
the compiled code called the interpreter

697
00:30:50,720 --> 00:30:52,559
or vice versa

698
00:30:52,559 --> 00:30:54,480
sometimes the interpreter called the

699
00:30:54,480 --> 00:30:56,320
interpreter again

700
00:30:56,320 --> 00:30:59,120
in this way a state changing accord

701
00:30:59,120 --> 00:31:00,559
frequently within the

702
00:31:00,559 --> 00:31:04,880
art structure

703
00:31:04,880 --> 00:31:08,000
this is a code floated analyzed

704
00:31:08,000 --> 00:31:11,200
execution process in ait here

705
00:31:11,200 --> 00:31:15,440
compiled code called the byte code and

706
00:31:15,440 --> 00:31:18,960
byte code called the compiled code and

707
00:31:18,960 --> 00:31:21,919
byte code also called the byte code i

708
00:31:21,919 --> 00:31:22,320
think

709
00:31:22,320 --> 00:31:26,000
it may it may not be easy to understand

710
00:31:26,000 --> 00:31:28,880
the whole process at once but if you

711
00:31:28,880 --> 00:31:31,760
focus on the code execution as path

712
00:31:31,760 --> 00:31:34,080
there are two parts in in the whole

713
00:31:34,080 --> 00:31:35,200
picture

714
00:31:35,200 --> 00:31:39,039
where kodi is executed

715
00:31:39,120 --> 00:31:42,000
the first part is a compiled code which

716
00:31:42,000 --> 00:31:45,120
is called ait quick inbox stop function

717
00:31:45,120 --> 00:31:48,080
through the inbox function in ait method

718
00:31:48,080 --> 00:31:50,000
this function invoked

719
00:31:50,000 --> 00:31:53,840
invoked and executed the compiled code

720
00:31:53,840 --> 00:31:56,880
the second part is the byte code which

721
00:31:56,880 --> 00:32:00,720
executed which which code executed

722
00:32:00,720 --> 00:32:04,799
mtrp inpl or execute switch impl

723
00:32:04,799 --> 00:32:05,760
functions

724
00:32:05,760 --> 00:32:07,840
through the interpreter's execution

725
00:32:07,840 --> 00:32:09,200
function

726
00:32:09,200 --> 00:32:11,519
this function converts byte code into

727
00:32:11,519 --> 00:32:14,880
native code and executed

728
00:32:14,880 --> 00:32:18,080
all the information required to executed

729
00:32:18,080 --> 00:32:22,159
app go to through these two parts

730
00:32:22,159 --> 00:32:25,120
the information contains part of

731
00:32:25,120 --> 00:32:26,399
parameter

732
00:32:26,399 --> 00:32:29,600
and written value and code

733
00:32:29,600 --> 00:32:33,679
course tab and so on in other words if

734
00:32:33,679 --> 00:32:37,200
you watch the if you watch ait method

735
00:32:37,200 --> 00:32:38,240
invoken

736
00:32:38,240 --> 00:32:41,360
interpreter execute function you can

737
00:32:41,360 --> 00:32:42,080
trace all

738
00:32:42,080 --> 00:32:46,080
the code running on android

739
00:32:46,080 --> 00:32:49,519
is that really possible

740
00:32:50,240 --> 00:32:53,279
however there was one missing case the

741
00:32:53,279 --> 00:32:55,919
piecing that we could not see in the

742
00:32:55,919 --> 00:32:57,120
flow

743
00:32:57,120 --> 00:33:00,480
uh what is that that is the process

744
00:33:00,480 --> 00:33:04,080
uh which uh which compiled code called

745
00:33:04,080 --> 00:33:05,840
the compiled code

746
00:33:05,840 --> 00:33:09,120
so why this core uh not shown in the

747
00:33:09,120 --> 00:33:12,960
picture i'd like to go back to the

748
00:33:12,960 --> 00:33:13,840
remind you

749
00:33:13,840 --> 00:33:17,279
how compiled code is called as i explain

750
00:33:17,279 --> 00:33:20,799
explained before ait method invoked

751
00:33:20,799 --> 00:33:24,159
called ait quick inbox subfunction two

752
00:33:24,159 --> 00:33:25,360
executed

753
00:33:25,360 --> 00:33:28,399
compiled code by invoke the code loaded

754
00:33:28,399 --> 00:33:29,600
in memory

755
00:33:29,600 --> 00:33:34,320
let's dig into more about this part

756
00:33:36,799 --> 00:33:39,600
the inbox function of ait method class

757
00:33:39,600 --> 00:33:43,679
called the ait kick inbox function

758
00:33:43,679 --> 00:33:46,640
the ait quick inbox sub function is

759
00:33:46,640 --> 00:33:47,440
written in

760
00:33:47,440 --> 00:33:50,080
arm assembly code to boost up the

761
00:33:50,080 --> 00:33:51,679
execution speed

762
00:33:51,679 --> 00:33:54,640
this function has address of target

763
00:33:54,640 --> 00:33:55,519
function

764
00:33:55,519 --> 00:33:58,559
to be invoked and executed

765
00:33:58,559 --> 00:34:01,760
this picture shows the code get address

766
00:34:01,760 --> 00:34:05,440
function to be executed this part

767
00:34:05,440 --> 00:34:08,639
contain the address of variable entry

768
00:34:08,639 --> 00:34:09,199
point

769
00:34:09,199 --> 00:34:13,119
from key compiled code and this variable

770
00:34:13,119 --> 00:34:15,918
contain the address of the compiled code

771
00:34:15,918 --> 00:34:18,480
for the executing function

772
00:34:18,480 --> 00:34:22,079
put this address into x9 and directly

773
00:34:22,079 --> 00:34:23,599
call the compiled code

774
00:34:23,599 --> 00:34:27,119
using branch instruction

775
00:34:27,359 --> 00:34:30,399
let's call this compiled code a then a

776
00:34:30,399 --> 00:34:32,239
directory called address of

777
00:34:32,239 --> 00:34:35,199
next function b which is in compiled

778
00:34:35,199 --> 00:34:36,480
code

779
00:34:36,480 --> 00:34:38,879
again b directly called address of next

780
00:34:38,879 --> 00:34:40,079
function c

781
00:34:40,079 --> 00:34:43,359
which also exists in a compiled code

782
00:34:43,359 --> 00:34:46,560
unlike the code structure we saw before

783
00:34:46,560 --> 00:34:49,119
we can see the directory call from

784
00:34:49,119 --> 00:34:50,560
memory to memory

785
00:34:50,560 --> 00:34:52,480
when compiled code called another

786
00:34:52,480 --> 00:34:54,239
compiled code

787
00:34:54,239 --> 00:34:57,440
if this is uh if this is the case

788
00:34:57,440 --> 00:35:01,119
it's it's impossible to trace the code

789
00:35:01,119 --> 00:35:03,440
when compiled code is executed from the

790
00:35:03,440 --> 00:35:04,960
compiled code

791
00:35:04,960 --> 00:35:07,280
in addition since the compiled code has

792
00:35:07,280 --> 00:35:09,280
been optimized or rather

793
00:35:09,280 --> 00:35:11,760
a lot of compared to the existing java

794
00:35:11,760 --> 00:35:12,720
code

795
00:35:12,720 --> 00:35:16,480
it quickly it's tricky to extract

796
00:35:16,480 --> 00:35:19,839
original code even if you access the

797
00:35:19,839 --> 00:35:21,760
compiled code

798
00:35:21,760 --> 00:35:24,640
so what i did is uh to change the course

799
00:35:24,640 --> 00:35:25,839
structure

800
00:35:25,839 --> 00:35:29,280
so bytecode was always called instead of

801
00:35:29,280 --> 00:35:29,680
a

802
00:35:29,680 --> 00:35:34,399
compiled code for target function

803
00:35:34,800 --> 00:35:37,119
so i change the ait method inbook

804
00:35:37,119 --> 00:35:40,480
function to stop executed compiled code

805
00:35:40,480 --> 00:35:43,680
and instead use the interpreter

806
00:35:43,680 --> 00:35:47,920
to executed byte code in this method

807
00:35:47,920 --> 00:35:50,880
ait method inbox function to executed

808
00:35:50,880 --> 00:35:52,880
compiled code into

809
00:35:52,880 --> 00:35:56,960
in the existing flow is not called

810
00:35:56,960 --> 00:35:59,839
uh instead it uh forced to always call

811
00:35:59,839 --> 00:36:02,800
the byte code using interpreter

812
00:36:02,800 --> 00:36:06,240
this allows you to twice trace the flow

813
00:36:06,240 --> 00:36:08,000
or function because

814
00:36:08,000 --> 00:36:11,599
they are all executed using interpreter

815
00:36:11,599 --> 00:36:13,680
furthermore you can get the original

816
00:36:13,680 --> 00:36:14,960
code more easily

817
00:36:14,960 --> 00:36:18,240
because the execution code you are

818
00:36:18,240 --> 00:36:19,119
getting in

819
00:36:19,119 --> 00:36:23,170
smartly code format for this purpose

820
00:36:23,170 --> 00:36:24,720
[Music]

821
00:36:24,720 --> 00:36:28,640
i customize ait display all information

822
00:36:28,640 --> 00:36:31,440
by adding the trace feature to two

823
00:36:31,440 --> 00:36:32,400
function

824
00:36:32,400 --> 00:36:34,800
a act method in book and interpreter

825
00:36:34,800 --> 00:36:37,119
execute

826
00:36:37,119 --> 00:36:40,480
as shown here no matter whether there is

827
00:36:40,480 --> 00:36:43,680
compiled code for the function to be

828
00:36:43,680 --> 00:36:44,480
executed

829
00:36:44,480 --> 00:36:47,599
in a lt it will eventually call

830
00:36:47,599 --> 00:36:50,320
bytecode

831
00:36:51,119 --> 00:36:54,720
this feature is a table or table com

832
00:36:54,720 --> 00:36:57,760
comparing is stack trace before and

833
00:36:57,760 --> 00:36:58,320
after

834
00:36:58,320 --> 00:37:01,839
called the flow change in ait

835
00:37:01,839 --> 00:37:04,560
with the technique introduced in the

836
00:37:04,560 --> 00:37:06,079
speaking

837
00:37:06,079 --> 00:37:09,839
uh this feature is uh divided into

838
00:37:09,839 --> 00:37:13,359
two results the above is stack trace

839
00:37:13,359 --> 00:37:16,079
result before changing course structure

840
00:37:16,079 --> 00:37:18,400
and the bottom is result from stack

841
00:37:18,400 --> 00:37:20,640
trace after the change

842
00:37:20,640 --> 00:37:22,880
before changing before change the

843
00:37:22,880 --> 00:37:25,359
function that exists the compiled code

844
00:37:25,359 --> 00:37:26,480
were called

845
00:37:26,480 --> 00:37:28,560
called from function that exists

846
00:37:28,560 --> 00:37:30,320
compiled code

847
00:37:30,320 --> 00:37:33,599
in this case it was impossible to

848
00:37:33,599 --> 00:37:37,280
trace your function in the result of

849
00:37:37,280 --> 00:37:38,640
stack trace

850
00:37:38,640 --> 00:37:41,839
of changes structure the compile

851
00:37:41,839 --> 00:37:44,880
the code cannot it cannot be executed in

852
00:37:44,880 --> 00:37:46,000
the ait

853
00:37:46,000 --> 00:37:49,440
method inbox function and the byte code

854
00:37:49,440 --> 00:37:53,839
is executed by calling interpreter

855
00:37:54,000 --> 00:37:56,000
this chapter introduced the framework

856
00:37:56,000 --> 00:37:57,760
develop with the previous

857
00:37:57,760 --> 00:38:00,960
described technique

858
00:38:01,839 --> 00:38:06,960
i have no time so skip this and

859
00:38:10,960 --> 00:38:19,839
i display i display demo

860
00:38:30,839 --> 00:38:33,839
uh

861
00:38:34,160 --> 00:38:37,839
uh all right is ubuntu console screen

862
00:38:37,839 --> 00:38:47,839
and rept is a phone mirroring screen

863
00:38:49,920 --> 00:38:52,960
the app is analyze centender

864
00:38:52,960 --> 00:38:57,440
uh used in arizentina

865
00:38:58,880 --> 00:39:01,520
and first open the computation file on

866
00:39:01,520 --> 00:39:02,400
on

867
00:39:02,400 --> 00:39:05,520
on mobile device

868
00:39:13,440 --> 00:39:16,800
here is target app uid stack trace

869
00:39:16,800 --> 00:39:17,359
option

870
00:39:17,359 --> 00:39:21,119
code dump option aerg information

871
00:39:21,119 --> 00:39:25,280
and include an exclude option

872
00:39:25,280 --> 00:39:30,320
first you get the uid of target app

873
00:39:38,400 --> 00:39:41,839
target app uid is 10

874
00:39:41,839 --> 00:39:44,320
16

875
00:39:46,400 --> 00:39:49,920
target f ui dj

876
00:39:50,160 --> 00:39:53,760
10 16

877
00:39:53,760 --> 00:39:57,599
and a then

878
00:39:57,599 --> 00:40:00,480
start diet

879
00:40:04,160 --> 00:40:07,680
you can see all function executed in ait

880
00:40:07,680 --> 00:40:10,720
too many functions are executed and

881
00:40:10,720 --> 00:40:14,240
you can save it as logo and analyze it

882
00:40:14,240 --> 00:40:16,640
later

883
00:40:23,680 --> 00:40:26,640
second you will add an option remove the

884
00:40:26,640 --> 00:40:30,078
default android function

885
00:40:37,280 --> 00:40:42,319
second you second

886
00:40:42,319 --> 00:40:44,400
you will add an option remove the

887
00:40:44,400 --> 00:40:46,079
default android function

888
00:40:46,079 --> 00:40:53,839
you will only see the custom function

889
00:40:57,520 --> 00:41:01,359
you will see on your custom functions

890
00:41:05,200 --> 00:41:07,920
the amount or amount of function display

891
00:41:07,920 --> 00:41:11,599
is much smaller than before

892
00:41:13,119 --> 00:41:16,319
and then choose a few functions that you

893
00:41:16,319 --> 00:41:21,839
want to analyze in detail

894
00:41:25,359 --> 00:41:28,800
i select com interrupt

895
00:41:28,800 --> 00:41:35,839
blah blah function

896
00:41:56,880 --> 00:42:03,839
you only need to uh

897
00:42:06,240 --> 00:42:09,440
then you can see the come intra

898
00:42:09,440 --> 00:42:17,839
class in the row

899
00:42:36,640 --> 00:42:38,800
and choose another function you want to

900
00:42:38,800 --> 00:42:40,960
analyze in detail

901
00:42:40,960 --> 00:42:45,839
a com centender

902
00:43:20,480 --> 00:43:24,839
and you can see the parameter and return

903
00:43:24,839 --> 00:43:27,839
value

904
00:43:30,000 --> 00:43:31,760
you can see the parameter and return

905
00:43:31,760 --> 00:43:34,160
value

906
00:43:35,200 --> 00:43:41,839
you can see the credential data

907
00:43:42,160 --> 00:43:55,680
and you can see the encrypt function

908
00:43:55,680 --> 00:43:58,880
finally i choose another function a i

909
00:43:58,880 --> 00:44:04,079
com sentence rio and banking crypto blah

910
00:44:06,839 --> 00:44:09,839
blah

911
00:44:12,960 --> 00:44:17,280
we can see plain text with crypto data

912
00:44:20,839 --> 00:44:23,839
easily

913
00:44:24,960 --> 00:44:27,760
then set the stack trace option you can

914
00:44:27,760 --> 00:44:29,680
see the stack trace

915
00:44:29,680 --> 00:44:34,839
of the target function

916
00:44:34,839 --> 00:44:37,839
and

917
00:44:43,680 --> 00:44:46,720
you can see the damp code

918
00:44:46,720 --> 00:44:51,839
smiley permanent

919
00:44:54,720 --> 00:45:05,839
you can see the private key

920
00:45:19,359 --> 00:45:22,880
in conclusion i developed a new analysis

921
00:45:22,880 --> 00:45:25,599
environment by analyzing and modifying

922
00:45:25,599 --> 00:45:26,560
the structure of

923
00:45:26,560 --> 00:45:29,599
ert this method is very easy

924
00:45:29,599 --> 00:45:32,800
and effective and powerful thank you for

925
00:45:32,800 --> 00:45:33,760
listening

926
00:45:33,760 --> 00:45:38,000
if you have any question please contact

927
00:45:38,000 --> 00:45:47,760
us on twitter or email thank you

