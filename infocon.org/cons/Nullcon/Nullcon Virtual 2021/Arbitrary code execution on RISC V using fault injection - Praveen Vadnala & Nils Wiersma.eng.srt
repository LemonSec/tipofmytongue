1
00:00:00,000 --> 00:00:14,799
[Music]

2
00:00:14,799 --> 00:00:17,119
praveen and nils would you please

3
00:00:17,119 --> 00:00:19,439
uh start your presentation and welcome

4
00:00:19,439 --> 00:00:22,560
to nalcon online

5
00:00:23,600 --> 00:00:26,640
um hi

6
00:00:26,640 --> 00:00:29,679
i guess you can see my screen

7
00:00:29,679 --> 00:00:30,880
absolutely we can see your screen

8
00:00:30,880 --> 00:00:33,279
praveen

9
00:00:34,559 --> 00:00:39,120
so i'm praveen

10
00:00:39,520 --> 00:00:42,559
this is a joint talk with nils we both

11
00:00:42,559 --> 00:00:46,239
are senior security analysts at riskier

12
00:00:46,239 --> 00:00:49,680
this talk is going to be um

13
00:00:49,680 --> 00:00:53,039
how to based on fault injection

14
00:00:53,039 --> 00:00:57,520
and we achieved arbitrary code execution

15
00:00:57,520 --> 00:00:59,039
on risk 5

16
00:00:59,039 --> 00:01:01,440
based

17
00:01:03,039 --> 00:01:05,840
risk fire based devices using fault

18
00:01:05,840 --> 00:01:07,360
injection and we'll show you

19
00:01:07,360 --> 00:01:13,840
how we achieve this

20
00:01:15,280 --> 00:01:18,479
so we start with

21
00:01:18,479 --> 00:01:21,119
a basic introduction to fault injection

22
00:01:21,119 --> 00:01:22,640
attacks

23
00:01:22,640 --> 00:01:25,280
then we explain what is our exact

24
00:01:25,280 --> 00:01:27,119
contribution

25
00:01:27,119 --> 00:01:30,640
and show the different approaches

26
00:01:30,640 --> 00:01:34,079
to controlling program counter

27
00:01:34,079 --> 00:01:37,439
on risk firebase devices and we finally

28
00:01:37,439 --> 00:01:38,320
show

29
00:01:38,320 --> 00:01:41,680
experimental results on one of the

30
00:01:41,680 --> 00:01:46,000
risk 5 based socs

31
00:01:47,119 --> 00:01:50,240
so what do we mean by fault

32
00:01:50,240 --> 00:01:52,840
fault is anything that triggers an

33
00:01:52,840 --> 00:01:54,000
unexpected

34
00:01:54,000 --> 00:01:57,520
and incorrect execution

35
00:01:57,520 --> 00:02:01,040
but that happens by intentionally

36
00:02:01,040 --> 00:02:02,960
altering the environment so sometimes

37
00:02:02,960 --> 00:02:04,159
false can happen

38
00:02:04,159 --> 00:02:07,200
unintentionally but here the goal is to

39
00:02:07,200 --> 00:02:10,239
actually alter the environment in such a

40
00:02:10,239 --> 00:02:10,800
way

41
00:02:10,800 --> 00:02:14,560
that the program execution

42
00:02:14,560 --> 00:02:18,640
uh changes let's take an example

43
00:02:18,640 --> 00:02:22,160
so this is a simple piece of code which

44
00:02:22,160 --> 00:02:26,160
checks signature of uh an image

45
00:02:26,160 --> 00:02:29,360
to authenticate uh before it

46
00:02:29,360 --> 00:02:32,480
executes it so you can see uh there is a

47
00:02:32,480 --> 00:02:34,160
function called check signature

48
00:02:34,160 --> 00:02:38,160
and the image is provided in in this

49
00:02:38,160 --> 00:02:41,599
argument and if

50
00:02:41,599 --> 00:02:45,200
this everything went well

51
00:02:45,200 --> 00:02:48,160
uh the authenticated will be set to true

52
00:02:48,160 --> 00:02:50,400
and if that is the case then

53
00:02:50,400 --> 00:02:53,120
the device starts executing the image

54
00:02:53,120 --> 00:02:54,319
otherwise

55
00:02:54,319 --> 00:02:58,080
uh it does it just resets

56
00:02:58,080 --> 00:03:01,599
the device or it it knows that

57
00:03:01,599 --> 00:03:04,319
the image is not a proper one so it

58
00:03:04,319 --> 00:03:06,159
should not continue execution

59
00:03:06,159 --> 00:03:09,599
so this is normal what you see in most

60
00:03:09,599 --> 00:03:10,720
of the

61
00:03:10,720 --> 00:03:14,080
yeah secure devices

62
00:03:14,080 --> 00:03:19,680
so let's say we want to

63
00:03:19,680 --> 00:03:23,360
induce false while this piece of code is

64
00:03:23,360 --> 00:03:25,120
being executed right

65
00:03:25,120 --> 00:03:27,440
so

66
00:03:28,480 --> 00:03:31,519
specifically we want to induce

67
00:03:31,519 --> 00:03:34,159
faults when this if check is being

68
00:03:34,159 --> 00:03:35,920
performed so

69
00:03:35,920 --> 00:03:38,640
as i mentioned if this authenticator is

70
00:03:38,640 --> 00:03:39,200
true

71
00:03:39,200 --> 00:03:42,159
then it should go here but let's say i

72
00:03:42,159 --> 00:03:42,799
induce

73
00:03:42,799 --> 00:03:47,280
a fault when this if check is happening

74
00:03:47,280 --> 00:03:50,080
and then change the outcome of this if

75
00:03:50,080 --> 00:03:51,280
condition

76
00:03:51,280 --> 00:03:53,840
what can happen instead of going to the

77
00:03:53,840 --> 00:03:54,799
else

78
00:03:54,799 --> 00:03:57,680
the program actually starts executing

79
00:03:57,680 --> 00:03:58,799
and thereby

80
00:03:58,799 --> 00:04:02,400
an image which was not authenticated

81
00:04:02,400 --> 00:04:05,680
will be executed on the device giving

82
00:04:05,680 --> 00:04:09,760
attacker runtime control

83
00:04:09,760 --> 00:04:12,799
so that's that's what

84
00:04:12,799 --> 00:04:15,920
fault injection can do but how can we

85
00:04:15,920 --> 00:04:20,639
trigger falls into devices

86
00:04:20,639 --> 00:04:24,000
typically any uh integrated circuit has

87
00:04:24,000 --> 00:04:27,360
a safe operating area where

88
00:04:27,360 --> 00:04:30,560
what kind of frequency it can operate

89
00:04:30,560 --> 00:04:33,840
at what kind of uh voltage levels it can

90
00:04:33,840 --> 00:04:35,520
operate at

91
00:04:35,520 --> 00:04:39,199
so you see here uh the safe operating

92
00:04:39,199 --> 00:04:40,840
area

93
00:04:40,840 --> 00:04:42,540
right

94
00:04:42,540 --> 00:04:44,639
[Music]

95
00:04:44,639 --> 00:04:47,840
yeah so this is the safe operating area

96
00:04:47,840 --> 00:04:51,120
and then anything

97
00:04:51,120 --> 00:04:54,840
beyond this is not gonna make the chip

98
00:04:54,840 --> 00:04:56,720
work

99
00:04:56,720 --> 00:04:59,360
but uh

100
00:05:00,320 --> 00:05:04,479
let's say the operating area is 1.8 to

101
00:05:04,479 --> 00:05:05,680
5.5 volts

102
00:05:05,680 --> 00:05:08,800
and if you go beyond 5.5

103
00:05:08,800 --> 00:05:12,160
for a long time that could kill the

104
00:05:12,160 --> 00:05:14,080
chick

105
00:05:14,080 --> 00:05:16,320
right so it's overpowers and then it

106
00:05:16,320 --> 00:05:18,479
might kill it

107
00:05:18,479 --> 00:05:21,680
then if we go below 1.8

108
00:05:21,680 --> 00:05:25,120
for a long time the chip might not even

109
00:05:25,120 --> 00:05:28,240
boot so nothing happens

110
00:05:30,639 --> 00:05:32,479
both those scenarios are not something

111
00:05:32,479 --> 00:05:34,160
we are interested in

112
00:05:34,160 --> 00:05:37,520
what we are interested in is

113
00:05:37,520 --> 00:05:40,639
making uh changing this voltage

114
00:05:40,639 --> 00:05:44,479
for a very uh slight

115
00:05:44,479 --> 00:05:47,759
amount of time so that the chip

116
00:05:47,759 --> 00:05:51,039
doesn't uh die

117
00:05:51,039 --> 00:05:54,160
our chip doesn't just not boot uh

118
00:05:54,160 --> 00:05:56,960
but it's it keeps operating but it

119
00:05:56,960 --> 00:05:57,680
triggers

120
00:05:57,680 --> 00:06:01,039
a faulty execution on the program

121
00:06:01,039 --> 00:06:03,840
so we want to change this voltage

122
00:06:03,840 --> 00:06:05,759
outside the safe operating area

123
00:06:05,759 --> 00:06:09,120
only for a very slight

124
00:06:09,120 --> 00:06:12,400
amount of time and then

125
00:06:12,400 --> 00:06:14,479
if you remember the previous example

126
00:06:14,479 --> 00:06:16,400
what we want to do is we want to change

127
00:06:16,400 --> 00:06:18,840
this voltage

128
00:06:18,840 --> 00:06:22,479
exactly when this if check is being

129
00:06:22,479 --> 00:06:26,800
uh executed and but by that

130
00:06:26,800 --> 00:06:30,160
we uh we would be able to

131
00:06:30,160 --> 00:06:32,840
execute an image which was not

132
00:06:32,840 --> 00:06:35,759
authenticated

133
00:06:35,759 --> 00:06:39,199
then um there are a lot of techniques

134
00:06:39,199 --> 00:06:40,479
with which we can

135
00:06:40,479 --> 00:06:44,160
inject falls into devices

136
00:06:44,160 --> 00:06:48,319
we can use laser uh

137
00:06:48,319 --> 00:06:51,919
this allosa is inducing very precise

138
00:06:51,919 --> 00:06:52,560
falls

139
00:06:52,560 --> 00:06:55,680
into a particular part of the chip even

140
00:06:55,680 --> 00:06:59,520
like your cpu or memories

141
00:06:59,520 --> 00:07:02,880
flash um so you can

142
00:07:02,880 --> 00:07:05,360
very precisely in inject falls into a

143
00:07:05,360 --> 00:07:07,120
particular component even to the level

144
00:07:07,120 --> 00:07:07,360
of

145
00:07:07,360 --> 00:07:11,759
a few registers as i already

146
00:07:11,759 --> 00:07:14,720
mentioned earlier you can use voltage to

147
00:07:14,720 --> 00:07:15,599
either

148
00:07:15,599 --> 00:07:19,199
go beyond the operating area or below

149
00:07:19,199 --> 00:07:23,759
it electromagnetic pulses

150
00:07:23,759 --> 00:07:28,000
to create um yeah em false

151
00:07:28,000 --> 00:07:31,120
temperature change the uh yeah

152
00:07:31,120 --> 00:07:35,039
over uh yeah go beyond the

153
00:07:35,039 --> 00:07:37,759
operating conditions of the chip or even

154
00:07:37,759 --> 00:07:39,360
clock frequency

155
00:07:39,360 --> 00:07:41,919
so there exists a lot of ways in which

156
00:07:41,919 --> 00:07:43,120
you can induce faults

157
00:07:43,120 --> 00:07:47,680
into the device

158
00:07:49,039 --> 00:07:52,160
but another thing to note here is that

159
00:07:52,160 --> 00:07:55,010
faults are not limited to just hardware

160
00:07:55,010 --> 00:07:57,199
[Music]

161
00:07:57,199 --> 00:08:00,479
you can induce false even just from

162
00:08:00,479 --> 00:08:01,680
software

163
00:08:01,680 --> 00:08:05,520
there are quite some results

164
00:08:05,520 --> 00:08:08,160
in the recent past which proves that for

165
00:08:08,160 --> 00:08:09,039
example

166
00:08:09,039 --> 00:08:12,240
row hammer attacks which

167
00:08:12,240 --> 00:08:17,039
attacks the dram by

168
00:08:17,520 --> 00:08:20,000
repeatedly accessing certain memory

169
00:08:20,000 --> 00:08:21,360
locations

170
00:08:21,360 --> 00:08:24,639
um then we have clock screw

171
00:08:24,639 --> 00:08:27,520
where this is pretty much similar to

172
00:08:27,520 --> 00:08:29,440
what i explained before the physical

173
00:08:29,440 --> 00:08:30,240
falls

174
00:08:30,240 --> 00:08:33,039
but you don't really have to change

175
00:08:33,039 --> 00:08:33,679
anything

176
00:08:33,679 --> 00:08:36,958
on the device you just need to write

177
00:08:36,958 --> 00:08:39,519
a program in the non-trusted part of the

178
00:08:39,519 --> 00:08:40,479
system

179
00:08:40,479 --> 00:08:43,200
which can change either the clock

180
00:08:43,200 --> 00:08:45,200
frequency or the voltage

181
00:08:45,200 --> 00:08:47,839
uh that the device operates on and then

182
00:08:47,839 --> 00:08:48,640
that can

183
00:08:48,640 --> 00:08:53,040
manifest uh the required falls

184
00:08:53,040 --> 00:08:56,000
um yeah there are some more results that

185
00:08:56,000 --> 00:08:57,200
are similar to that

186
00:08:57,200 --> 00:09:00,399
as well so faults

187
00:09:00,399 --> 00:09:03,440
are not only just limited to uh

188
00:09:03,440 --> 00:09:06,480
hardware but you can also induce them

189
00:09:06,480 --> 00:09:10,880
uh software as well

190
00:09:11,040 --> 00:09:14,720
and yeah so there are

191
00:09:14,720 --> 00:09:17,200
a lot of results uh using fault

192
00:09:17,200 --> 00:09:20,560
injection lately it has been uh

193
00:09:20,560 --> 00:09:25,279
quite let's say uh in the news

194
00:09:25,279 --> 00:09:28,880
um you can see some of our colleagues

195
00:09:28,880 --> 00:09:33,279
also had um results on for example esp32

196
00:09:33,279 --> 00:09:36,800
secure boot so we were able to

197
00:09:37,040 --> 00:09:39,040
bypass the secure boot using fault

198
00:09:39,040 --> 00:09:40,240
injection

199
00:09:40,240 --> 00:09:43,600
and then uh name data hacking

200
00:09:43,600 --> 00:09:47,680
yeah all sorts of things that were

201
00:09:47,680 --> 00:09:51,839
done with the fine

202
00:09:53,200 --> 00:09:56,640
so on this particular topic that

203
00:09:56,640 --> 00:10:00,000
we are going to present today uh

204
00:10:00,000 --> 00:10:02,160
a lot of our ex colleagues and ex

205
00:10:02,160 --> 00:10:03,279
interns

206
00:10:03,279 --> 00:10:07,120
also worked on it similar thing um

207
00:10:07,120 --> 00:10:08,959
some of the examples that you can see

208
00:10:08,959 --> 00:10:10,160
here

209
00:10:10,160 --> 00:10:13,680
um specifically uh controlling pc

210
00:10:13,680 --> 00:10:15,680
on arm this was one of the first papers

211
00:10:15,680 --> 00:10:17,279
which shows

212
00:10:17,279 --> 00:10:20,560
uh how fault injection can be

213
00:10:20,560 --> 00:10:23,279
used to directly control a program

214
00:10:23,279 --> 00:10:24,560
counter

215
00:10:24,560 --> 00:10:27,279
and if you can control program counter

216
00:10:27,279 --> 00:10:27,680
then

217
00:10:27,680 --> 00:10:30,079
you can execute your own code on the

218
00:10:30,079 --> 00:10:31,360
device

219
00:10:31,360 --> 00:10:34,399
so but this one was particularly uh

220
00:10:34,399 --> 00:10:38,480
for arm 32-bit architectures

221
00:10:38,480 --> 00:10:41,519
so then there was later

222
00:10:41,519 --> 00:10:44,839
another presentation by nick and

223
00:10:44,839 --> 00:10:46,640
christopher

224
00:10:46,640 --> 00:10:50,240
this relates to a bit more generic

225
00:10:50,240 --> 00:10:54,000
way of inducing false and yeah

226
00:10:54,000 --> 00:10:57,519
data transfers so that you

227
00:10:57,519 --> 00:11:00,000
get code execution so not only just

228
00:11:00,000 --> 00:11:01,760
changing the program counter but there

229
00:11:01,760 --> 00:11:02,000
are

230
00:11:02,000 --> 00:11:04,800
other options that they show are

231
00:11:04,800 --> 00:11:05,680
possible

232
00:11:05,680 --> 00:11:09,519
to achieve the same uh end result

233
00:11:09,519 --> 00:11:12,839
so in this

234
00:11:12,839 --> 00:11:16,240
uh contra our contribution here

235
00:11:16,240 --> 00:11:19,760
is that we do a similar thing which

236
00:11:19,760 --> 00:11:23,279
is showing that program counter can also

237
00:11:23,279 --> 00:11:23,680
be

238
00:11:23,680 --> 00:11:27,200
controlled on a risk firebase

239
00:11:27,200 --> 00:11:30,480
devices and

240
00:11:30,480 --> 00:11:33,360
while doing that what we discovered is

241
00:11:33,360 --> 00:11:35,600
that

242
00:11:36,079 --> 00:11:38,320
we will get into bit more details later

243
00:11:38,320 --> 00:11:40,560
but the idea is that

244
00:11:40,560 --> 00:11:43,760
in risk 5 i say program counter is not

245
00:11:43,760 --> 00:11:47,040
directly accessible to the programmer so

246
00:11:47,040 --> 00:11:47,360
it's

247
00:11:47,360 --> 00:11:50,480
internal it's not directly exposed

248
00:11:50,480 --> 00:11:54,320
in the programmer model of the isa so

249
00:11:54,320 --> 00:11:57,519
the previous attacks basically for

250
00:11:57,519 --> 00:11:58,639
example on um

251
00:11:58,639 --> 00:12:01,839
how they work is you have uh you change

252
00:12:01,839 --> 00:12:04,240
the destination register of an

253
00:12:04,240 --> 00:12:05,200
instruction

254
00:12:05,200 --> 00:12:10,320
to program counter and then if

255
00:12:10,320 --> 00:12:13,360
you can do that then you you can control

256
00:12:13,360 --> 00:12:14,079
pc

257
00:12:14,079 --> 00:12:17,600
right but

258
00:12:17,600 --> 00:12:20,079
this is possible on arm because um

259
00:12:20,079 --> 00:12:23,600
exposes the pc directly to a programmer

260
00:12:23,600 --> 00:12:26,079
but in case of risk five pc is not

261
00:12:26,079 --> 00:12:27,279
directly exposed

262
00:12:27,279 --> 00:12:30,320
right so then

263
00:12:30,320 --> 00:12:32,880
our expectation before we did this

264
00:12:32,880 --> 00:12:33,680
experiment

265
00:12:33,680 --> 00:12:35,839
was that yeah we cannot directly control

266
00:12:35,839 --> 00:12:37,360
pc so we need to find

267
00:12:37,360 --> 00:12:40,320
indirect ways but during this uh

268
00:12:40,320 --> 00:12:41,360
experiments

269
00:12:41,360 --> 00:12:44,959
we realized that we were still able to

270
00:12:44,959 --> 00:12:47,200
directly change pc

271
00:12:47,200 --> 00:12:50,560
uh we do not exactly

272
00:12:50,560 --> 00:12:53,839
for 100 know how this happened

273
00:12:53,839 --> 00:12:56,000
because sometimes fault injection is

274
00:12:56,000 --> 00:12:57,519
like that we don't know

275
00:12:57,519 --> 00:13:00,639
what exactly happened but we have some

276
00:13:00,639 --> 00:13:01,440
hypothesis

277
00:13:01,440 --> 00:13:04,160
nils will explain later uh during the

278
00:13:04,160 --> 00:13:05,200
experiment

279
00:13:05,200 --> 00:13:08,720
experimental results um what

280
00:13:08,720 --> 00:13:11,440
what i'm talking about here but yeah so

281
00:13:11,440 --> 00:13:12,959
that's also another contribution which

282
00:13:12,959 --> 00:13:13,600
is that

283
00:13:13,600 --> 00:13:17,920
we find new fault models not just

284
00:13:17,920 --> 00:13:21,600
the direct instruction or data related

285
00:13:21,600 --> 00:13:22,000
but

286
00:13:22,000 --> 00:13:26,720
more related to the hardware itself

287
00:13:28,160 --> 00:13:31,279
yeah so then

288
00:13:31,279 --> 00:13:34,399
as i mentioned we are doing it on

289
00:13:34,399 --> 00:13:38,000
risk 5 based devices so some of you may

290
00:13:38,000 --> 00:13:39,120
already know but

291
00:13:39,120 --> 00:13:42,560
for those who don't it's um it's in

292
00:13:42,560 --> 00:13:44,639
free and open instruction set

293
00:13:44,639 --> 00:13:46,720
architecture

294
00:13:46,720 --> 00:13:50,560
and uh the good thing here is that

295
00:13:50,560 --> 00:13:53,680
there is no license fee to

296
00:13:53,680 --> 00:13:57,199
use it um and yeah that that makes

297
00:13:57,199 --> 00:14:00,720
the brings the barrier down

298
00:14:00,720 --> 00:14:04,000
and it's based on reduced instruction

299
00:14:04,000 --> 00:14:05,440
set computer principles

300
00:14:05,440 --> 00:14:09,040
just like uh um our

301
00:14:09,040 --> 00:14:13,440
mips and it has modular design

302
00:14:13,440 --> 00:14:17,279
right so there is a base integer isa

303
00:14:17,279 --> 00:14:21,360
that that is there for all the

304
00:14:21,360 --> 00:14:23,680
implementations but then it can be

305
00:14:23,680 --> 00:14:25,440
easily extended

306
00:14:25,440 --> 00:14:28,480
and because of its modular nature

307
00:14:28,480 --> 00:14:32,320
it makes it very easy to

308
00:14:33,120 --> 00:14:37,519
extend it for your own use case

309
00:14:37,519 --> 00:14:41,199
and we expect that

310
00:14:41,199 --> 00:14:44,399
risk five will be very popular in the

311
00:14:44,399 --> 00:14:46,000
near future

312
00:14:46,000 --> 00:14:47,680
because of the reasons that i just

313
00:14:47,680 --> 00:14:50,079
mentioned

314
00:14:50,959 --> 00:14:54,079
so let's uh

315
00:14:54,079 --> 00:14:56,320
see a bit more into the details of the

316
00:14:56,320 --> 00:14:57,199
risk

317
00:14:57,199 --> 00:15:00,399
uh and if you look at the registers

318
00:15:00,399 --> 00:15:02,880
available

319
00:15:03,279 --> 00:15:06,720
there are 32 registers

320
00:15:06,720 --> 00:15:09,360
um yeah i mean if you if you looked into

321
00:15:09,360 --> 00:15:10,399
any if i

322
00:15:10,399 --> 00:15:12,160
says you know there are a bunch of

323
00:15:12,160 --> 00:15:13,680
registers

324
00:15:13,680 --> 00:15:17,040
some of them you could already see

325
00:15:17,040 --> 00:15:20,560
for example a retina address which is

326
00:15:20,560 --> 00:15:23,760
called link register in

327
00:15:23,760 --> 00:15:26,880
arm and then you have the stack pointer

328
00:15:26,880 --> 00:15:29,519
uh and then you see some of some temp

329
00:15:29,519 --> 00:15:30,959
registers that are

330
00:15:30,959 --> 00:15:34,320
typically used uh yeah to

331
00:15:34,320 --> 00:15:37,920
transfer data uh during the program

332
00:15:37,920 --> 00:15:39,920
execution from one to the other or

333
00:15:39,920 --> 00:15:41,759
operate

334
00:15:41,759 --> 00:15:45,279
on the data and then yes

335
00:15:45,279 --> 00:15:48,079
some registers to store the function

336
00:15:48,079 --> 00:15:50,320
arguments written values and so on so

337
00:15:50,320 --> 00:15:52,000
these are all

338
00:15:52,000 --> 00:15:54,639
nothing fancy here so if you if you

339
00:15:54,639 --> 00:15:55,680
looked at

340
00:15:55,680 --> 00:15:58,480
any other isa you would see very similar

341
00:15:58,480 --> 00:16:00,000
things

342
00:16:00,000 --> 00:16:02,880
but two things here as you as i

343
00:16:02,880 --> 00:16:04,639
mentioned already you don't see

344
00:16:04,639 --> 00:16:08,639
a program counter here so this is not

345
00:16:08,639 --> 00:16:11,759
exposed to the in the programmer model

346
00:16:11,759 --> 00:16:15,199
uh and that's why

347
00:16:15,199 --> 00:16:18,240
we uh we do an

348
00:16:18,240 --> 00:16:21,279
indirect way right so we we still want

349
00:16:21,279 --> 00:16:22,000
to

350
00:16:22,000 --> 00:16:25,040
get code execution but we don't we can't

351
00:16:25,040 --> 00:16:26,480
really control pc

352
00:16:26,480 --> 00:16:29,199
at least as i mentioned that's uh that's

353
00:16:29,199 --> 00:16:31,600
our understanding at the beginning

354
00:16:31,600 --> 00:16:34,240
so what we wanted to do was we wanted to

355
00:16:34,240 --> 00:16:35,920
indirectly

356
00:16:35,920 --> 00:16:38,720
change the program counter that we could

357
00:16:38,720 --> 00:16:39,440
do

358
00:16:39,440 --> 00:16:44,160
um like for example when uh

359
00:16:44,399 --> 00:16:48,320
when a function is exiting

360
00:16:48,320 --> 00:16:50,880
then it has to go back to the called

361
00:16:50,880 --> 00:16:51,759
function

362
00:16:51,759 --> 00:16:55,519
right that which is the color and

363
00:16:55,519 --> 00:16:59,360
uh the the

364
00:16:59,360 --> 00:17:01,440
the address at which it should go back

365
00:17:01,440 --> 00:17:03,519
to is typically stored in this

366
00:17:03,519 --> 00:17:06,720
written address register and we want we

367
00:17:06,720 --> 00:17:07,599
could

368
00:17:07,599 --> 00:17:11,359
change this register and

369
00:17:11,359 --> 00:17:14,319
start executing our payload instead of

370
00:17:14,319 --> 00:17:16,000
the previous function

371
00:17:16,000 --> 00:17:19,520
so that's one target we wanted to uh

372
00:17:19,520 --> 00:17:22,480
have and the second one is stack pointer

373
00:17:22,480 --> 00:17:23,119
so

374
00:17:23,119 --> 00:17:26,559
again here uh you have uh

375
00:17:26,559 --> 00:17:28,319
when when there are nested function

376
00:17:28,319 --> 00:17:30,799
calls or the local data

377
00:17:30,799 --> 00:17:33,360
you have all of them allocated on the

378
00:17:33,360 --> 00:17:34,320
stack

379
00:17:34,320 --> 00:17:38,480
if you can change the

380
00:17:38,480 --> 00:17:41,760
register where the where you know the

381
00:17:41,760 --> 00:17:45,360
top of the stack is located we can

382
00:17:45,360 --> 00:17:47,760
redirect the program execution change

383
00:17:47,760 --> 00:17:48,720
the data

384
00:17:48,720 --> 00:17:52,000
and that all could lead to um

385
00:17:52,000 --> 00:17:56,240
getting code execution on the device

386
00:17:56,880 --> 00:17:59,600
that's about registers let's look at

387
00:17:59,600 --> 00:18:00,000
some of

388
00:18:00,000 --> 00:18:05,280
the details about instructions provided

389
00:18:05,280 --> 00:18:08,480
so as you can see there are uh six

390
00:18:08,480 --> 00:18:09,039
different

391
00:18:09,039 --> 00:18:12,640
instruction formats right um

392
00:18:12,640 --> 00:18:16,000
so the the each

393
00:18:16,000 --> 00:18:19,120
uh instruction will be uh coded using 32

394
00:18:19,120 --> 00:18:21,039
bits

395
00:18:21,039 --> 00:18:25,360
um and instruction is a combination

396
00:18:25,360 --> 00:18:29,200
of what is the operation that it needs

397
00:18:29,200 --> 00:18:30,559
to perform

398
00:18:30,559 --> 00:18:32,960
what is the source register and what is

399
00:18:32,960 --> 00:18:34,960
the destination register

400
00:18:34,960 --> 00:18:37,860
so as you can see

401
00:18:37,860 --> 00:18:40,879
[Music]

402
00:18:40,960 --> 00:18:42,400
different instructions have different

403
00:18:42,400 --> 00:18:43,160
way of

404
00:18:43,160 --> 00:18:46,000
[Music]

405
00:18:46,000 --> 00:18:49,760
presenting that information but

406
00:18:49,760 --> 00:18:52,960
overall the

407
00:18:52,960 --> 00:18:56,480
what is the instruction can be decoded

408
00:18:56,480 --> 00:18:56,880
from

409
00:18:56,880 --> 00:19:00,160
three different uh parameters here func

410
00:19:00,160 --> 00:19:03,679
seven font three and opcode

411
00:19:03,679 --> 00:19:06,080
okay so these three combined will tell

412
00:19:06,080 --> 00:19:06,799
you what

413
00:19:06,799 --> 00:19:10,640
exactly it needs to execute and then

414
00:19:10,640 --> 00:19:15,440
rs1 and rs2 are source registers

415
00:19:15,440 --> 00:19:19,200
and rd is the destination register

416
00:19:19,200 --> 00:19:22,559
so based on the instruction type

417
00:19:22,559 --> 00:19:24,240
some of them might be present some of

418
00:19:24,240 --> 00:19:26,720
them not but you at least have

419
00:19:26,720 --> 00:19:30,240
one op code one source register

420
00:19:30,240 --> 00:19:33,840
and one destination register right

421
00:19:33,840 --> 00:19:36,559
uh yeah sorry about one op code and

422
00:19:36,559 --> 00:19:37,520
either one

423
00:19:37,520 --> 00:19:41,919
source at one destination register

424
00:19:41,919 --> 00:19:45,760
okay so

425
00:19:45,760 --> 00:19:48,559
if you go a bit more into detail this is

426
00:19:48,559 --> 00:19:49,280
how

427
00:19:49,280 --> 00:19:51,600
different instructions look you have the

428
00:19:51,600 --> 00:19:52,559
opcode here

429
00:19:52,559 --> 00:19:56,240
and then other parameters that i just

430
00:19:56,240 --> 00:19:58,640
described

431
00:19:58,640 --> 00:20:01,039
but in particular what we are interested

432
00:20:01,039 --> 00:20:02,240
in is

433
00:20:02,240 --> 00:20:05,360
load operations i explain why

434
00:20:05,360 --> 00:20:08,640
a bit later but let's say uh the

435
00:20:08,640 --> 00:20:11,679
load word instruction here so there is

436
00:20:11,679 --> 00:20:11,919
an

437
00:20:11,919 --> 00:20:14,960
awkward here

438
00:20:14,960 --> 00:20:18,320
this i believe is from three

439
00:20:18,320 --> 00:20:21,200
so these two combined will tell that it

440
00:20:21,200 --> 00:20:22,559
is a load word

441
00:20:22,559 --> 00:20:27,600
operation and then uh you have rs1

442
00:20:27,600 --> 00:20:30,159
which is a source register and this is

443
00:20:30,159 --> 00:20:31,679
immediate value which

444
00:20:31,679 --> 00:20:35,600
means where from from rs1

445
00:20:35,600 --> 00:20:38,320
you add what is there in the immediate

446
00:20:38,320 --> 00:20:38,720
to

447
00:20:38,720 --> 00:20:42,080
go to that particular uh location

448
00:20:42,080 --> 00:20:44,640
and rd is going to be the destination

449
00:20:44,640 --> 00:20:45,360
register

450
00:20:45,360 --> 00:20:48,880
so basically what it does is it loads

451
00:20:48,880 --> 00:20:52,159
from the address that's specified by rs1

452
00:20:52,159 --> 00:20:53,600
and immediate

453
00:20:53,600 --> 00:20:56,640
to register rd

454
00:20:56,640 --> 00:20:59,039
so it's just basically loading a word

455
00:20:59,039 --> 00:21:01,360
from the memory

456
00:21:01,360 --> 00:21:04,080
why are we interested in load operations

457
00:21:04,080 --> 00:21:05,440
because

458
00:21:05,440 --> 00:21:09,360
firstly they are operating on uh

459
00:21:09,360 --> 00:21:12,720
attacker control data right so you

460
00:21:12,720 --> 00:21:16,240
uh we as an attacker can specify

461
00:21:16,240 --> 00:21:19,919
what is being loaded even if you

462
00:21:19,919 --> 00:21:21,600
remember the first example that i was

463
00:21:21,600 --> 00:21:24,240
mentioning the image

464
00:21:24,240 --> 00:21:28,559
which is being authenticated is a

465
00:21:28,559 --> 00:21:31,760
collection of data that we are providing

466
00:21:31,760 --> 00:21:32,640
to the device

467
00:21:32,640 --> 00:21:36,320
so that it can uh authenticate

468
00:21:36,320 --> 00:21:39,679
the data that we are providing so

469
00:21:39,679 --> 00:21:42,880
we have control over what uh

470
00:21:42,880 --> 00:21:46,799
what goes in here and

471
00:21:46,799 --> 00:21:50,000
uh typically they are executed multiple

472
00:21:50,000 --> 00:21:50,559
times

473
00:21:50,559 --> 00:21:53,600
right so basically loading from memory

474
00:21:53,600 --> 00:21:56,720
uh uh external memory to for example

475
00:21:56,720 --> 00:21:59,520
internal memory there will be a bunch of

476
00:21:59,520 --> 00:22:03,200
load operations loads and stores

477
00:22:03,520 --> 00:22:07,440
so that means these are executed

478
00:22:07,440 --> 00:22:11,440
uh a number of times during the copy

479
00:22:11,440 --> 00:22:12,960
of course there are other ways for

480
00:22:12,960 --> 00:22:14,640
example if you use dma this is

481
00:22:14,640 --> 00:22:17,919
different but in most of the

482
00:22:17,919 --> 00:22:21,520
cases uh earlier during the your

483
00:22:21,520 --> 00:22:25,200
for example secured flow you you may

484
00:22:25,200 --> 00:22:29,679
not use dma you just do a simple copy

485
00:22:29,679 --> 00:22:33,440
um and most importantly

486
00:22:33,440 --> 00:22:36,640
they are not protected

487
00:22:36,640 --> 00:22:38,720
especially against fault injection

488
00:22:38,720 --> 00:22:40,400
because yeah i mean

489
00:22:40,400 --> 00:22:42,400
you don't trust the data right you in

490
00:22:42,400 --> 00:22:44,000
any way you are going to authenticate

491
00:22:44,000 --> 00:22:44,480
and

492
00:22:44,480 --> 00:22:47,200
do a proper authentication before you

493
00:22:47,200 --> 00:22:48,159
execute it so

494
00:22:48,159 --> 00:22:51,440
you don't really uh have to add any

495
00:22:51,440 --> 00:22:53,520
protection and i mean that's the normal

496
00:22:53,520 --> 00:22:54,559
um

497
00:22:54,559 --> 00:22:58,799
thinking of the designers

498
00:22:58,799 --> 00:23:02,000
and um yeah as i also mentioned this

499
00:23:02,000 --> 00:23:06,320
the use case so this secure boot

500
00:23:06,320 --> 00:23:08,640
in case of secure boot you you uh load

501
00:23:08,640 --> 00:23:09,600
the data

502
00:23:09,600 --> 00:23:12,720
from an external flash for example into

503
00:23:12,720 --> 00:23:16,159
internal ram and this involves a lot of

504
00:23:16,159 --> 00:23:16,880
uh loads

505
00:23:16,880 --> 00:23:20,240
in stores uh

506
00:23:20,240 --> 00:23:23,520
yeah so that is why we we are interested

507
00:23:23,520 --> 00:23:24,159
in

508
00:23:24,159 --> 00:23:27,280
uh injecting fault into

509
00:23:27,280 --> 00:23:32,080
load operations and finally

510
00:23:32,480 --> 00:23:35,679
we we say that we are targeting a lw

511
00:23:35,679 --> 00:23:37,679
which is load word

512
00:23:37,679 --> 00:23:41,039
but um you can do the same attack

513
00:23:41,039 --> 00:23:44,080
on other kinds of loads as well so

514
00:23:44,080 --> 00:23:48,080
there is nothing stopping uh us from

515
00:23:48,080 --> 00:23:52,240
attacking other load operations

516
00:23:53,039 --> 00:23:56,480
okay now

517
00:23:56,480 --> 00:24:00,080
how we actually do this right

518
00:24:01,279 --> 00:24:03,600
let's let's go back and see uh i

519
00:24:03,600 --> 00:24:05,440
mentioned two registers

520
00:24:05,440 --> 00:24:07,440
right the link register and the stack

521
00:24:07,440 --> 00:24:09,440
pointer register

522
00:24:09,440 --> 00:24:14,000
so the idea here is that

523
00:24:14,000 --> 00:24:16,720
we change the target register in an

524
00:24:16,720 --> 00:24:17,840
operation

525
00:24:17,840 --> 00:24:20,720
in a load operation from something which

526
00:24:20,720 --> 00:24:21,279
is

527
00:24:21,279 --> 00:24:24,640
normally used by the program to

528
00:24:24,640 --> 00:24:28,559
uh our interest

529
00:24:28,559 --> 00:24:32,240
register which is ra here so

530
00:24:32,240 --> 00:24:35,840
if you see if you take any disassembly

531
00:24:35,840 --> 00:24:36,159
of

532
00:24:36,159 --> 00:24:38,880
a simple mem copy operation you would

533
00:24:38,880 --> 00:24:40,960
see a bunch of loads

534
00:24:40,960 --> 00:24:44,320
happening from the memory

535
00:24:44,320 --> 00:24:46,320
into the register so this is a temp

536
00:24:46,320 --> 00:24:47,840
register p0

537
00:24:47,840 --> 00:24:51,360
and this is actually loading

538
00:24:51,360 --> 00:24:54,480
uh from the memory address

539
00:24:54,480 --> 00:24:58,240
a t stored in t4 into

540
00:24:58,240 --> 00:25:01,600
t0 right so this is simple load now the

541
00:25:01,600 --> 00:25:02,799
idea is that

542
00:25:02,799 --> 00:25:07,279
we want to change this t0 to ra

543
00:25:07,279 --> 00:25:10,960
so how can we do that so if you look at

544
00:25:10,960 --> 00:25:13,919
here on the right you see how this

545
00:25:13,919 --> 00:25:15,279
particular instruction

546
00:25:15,279 --> 00:25:18,720
is encoded in binary right so

547
00:25:18,720 --> 00:25:21,840
this is this 32-bit instruction refers

548
00:25:21,840 --> 00:25:22,400
to

549
00:25:22,400 --> 00:25:26,480
this one now if we just change

550
00:25:26,480 --> 00:25:29,520
this particular one

551
00:25:29,520 --> 00:25:33,360
here to 0 then this instruction will

552
00:25:33,360 --> 00:25:35,279
completely change

553
00:25:35,279 --> 00:25:38,320
so instead of the

554
00:25:38,320 --> 00:25:41,760
data being loaded into t0 it will be

555
00:25:41,760 --> 00:25:43,919
loaded into rna

556
00:25:43,919 --> 00:25:48,640
and now imagine if at this location

557
00:25:48,640 --> 00:25:52,080
we store our payload address

558
00:25:52,080 --> 00:25:55,600
right then because of our fault

559
00:25:55,600 --> 00:25:59,039
the ra will have

560
00:25:59,039 --> 00:26:01,600
our payload address instead of the

561
00:26:01,600 --> 00:26:02,799
previous

562
00:26:02,799 --> 00:26:05,919
functions written address now

563
00:26:05,919 --> 00:26:08,880
if you do that what happens when the

564
00:26:08,880 --> 00:26:09,440
current

565
00:26:09,440 --> 00:26:13,360
operation which is in this case mem copy

566
00:26:13,360 --> 00:26:17,279
is returning from the copy operation

567
00:26:17,279 --> 00:26:20,159
it will start executing what is there in

568
00:26:20,159 --> 00:26:21,840
ra

569
00:26:21,840 --> 00:26:25,039
which as we have uh

570
00:26:25,039 --> 00:26:28,320
loaded with our value then the device

571
00:26:28,320 --> 00:26:31,279
starts executing our code

572
00:26:31,279 --> 00:26:34,320
so that's the uh that's the way how we

573
00:26:34,320 --> 00:26:36,799
take control

574
00:26:36,799 --> 00:26:39,520
um yeah so another example let's say

575
00:26:39,520 --> 00:26:42,159
instead of t0 that's t2

576
00:26:42,159 --> 00:26:45,840
then uh this is the uh this is how

577
00:26:45,840 --> 00:26:49,600
the binary looks like and

578
00:26:49,600 --> 00:26:53,760
here instead of a

579
00:26:53,840 --> 00:26:56,960
one bit modification we need to do

580
00:26:56,960 --> 00:27:00,559
we need to modify two bits using fault

581
00:27:00,559 --> 00:27:01,440
injection

582
00:27:01,440 --> 00:27:06,880
then we get the same result again

583
00:27:06,880 --> 00:27:10,640
okay so that's that's what uh we want to

584
00:27:10,640 --> 00:27:11,279
achieve

585
00:27:11,279 --> 00:27:15,120
so we just we discussed what is fault

586
00:27:15,120 --> 00:27:18,240
how to induce faults uh what is risk

587
00:27:18,240 --> 00:27:20,399
fire say

588
00:27:20,399 --> 00:27:22,000
what are the registers what are the

589
00:27:22,000 --> 00:27:24,640
instructions and then finally we decide

590
00:27:24,640 --> 00:27:28,399
we discussed how uh

591
00:27:28,399 --> 00:27:34,159
how we can induce false so that the what

592
00:27:34,159 --> 00:27:37,360
what we want to do for example rea

593
00:27:37,360 --> 00:27:39,760
corruption can be achieved and similarly

594
00:27:39,760 --> 00:27:40,720
we can also do

595
00:27:40,720 --> 00:27:44,960
uh with stack pointer as well

596
00:27:45,120 --> 00:27:48,320
now finally what we

597
00:27:48,320 --> 00:27:50,399
we have seen all the theory now we want

598
00:27:50,399 --> 00:27:51,360
to see

599
00:27:51,360 --> 00:27:54,480
how to perform this attack and to

600
00:27:54,480 --> 00:27:58,080
before we describe the uh actual attack

601
00:27:58,080 --> 00:27:58,880
itself

602
00:27:58,880 --> 00:28:02,559
the target so this is as you can see

603
00:28:02,559 --> 00:28:06,559
um the microcontroller from sci-fi

604
00:28:06,559 --> 00:28:10,480
it's based on risk five uh and

605
00:28:10,480 --> 00:28:14,000
you specifically used a high five review

606
00:28:14,000 --> 00:28:17,440
development board um

607
00:28:17,440 --> 00:28:21,200
and then uh yeah it has the

608
00:28:21,200 --> 00:28:23,600
uh risk five uh basin teacher

609
00:28:23,600 --> 00:28:25,039
instruction set

610
00:28:25,039 --> 00:28:28,080
implemented and uh it can run

611
00:28:28,080 --> 00:28:31,440
quite a reasonable speed with 320 plus

612
00:28:31,440 --> 00:28:34,000
megahertz

613
00:28:37,440 --> 00:28:39,679
for for inducing volt hfi and

614
00:28:39,679 --> 00:28:40,640
specifically

615
00:28:40,640 --> 00:28:43,760
because this is what we did

616
00:28:43,760 --> 00:28:46,240
we we need to look at three different

617
00:28:46,240 --> 00:28:46,960
parameters

618
00:28:46,960 --> 00:28:52,320
right the first one is

619
00:28:52,320 --> 00:28:55,440
the glitch so

620
00:28:55,440 --> 00:28:59,039
here is the place where you have

621
00:28:59,039 --> 00:29:01,919
your trigger let's say this let's go

622
00:29:01,919 --> 00:29:03,440
back to the previous example this is

623
00:29:03,440 --> 00:29:04,240
where let

624
00:29:04,240 --> 00:29:08,799
your uh if comparison is happening

625
00:29:08,799 --> 00:29:11,120
but you don't know where exactly this if

626
00:29:11,120 --> 00:29:13,279
is happening in your program right like

627
00:29:13,279 --> 00:29:16,640
it's not uh it's not straightforward to

628
00:29:16,640 --> 00:29:18,240
know where exactly it is

629
00:29:18,240 --> 00:29:21,440
because of several reasons now

630
00:29:21,440 --> 00:29:24,480
you want to have a

631
00:29:24,480 --> 00:29:27,600
proper point in the program

632
00:29:27,600 --> 00:29:31,440
where you know okay this is where

633
00:29:31,440 --> 00:29:34,559
uh i know uh in the program where

634
00:29:34,559 --> 00:29:36,080
exactly i am

635
00:29:36,080 --> 00:29:38,320
right so this is the place this could be

636
00:29:38,320 --> 00:29:41,520
a uart output this could be a c

637
00:29:41,520 --> 00:29:44,559
flash read you know this happens all the

638
00:29:44,559 --> 00:29:45,120
time

639
00:29:45,120 --> 00:29:49,679
at the very precise moment so from here

640
00:29:49,679 --> 00:29:52,640
you need to go to the actual if check

641
00:29:52,640 --> 00:29:54,320
and this is what we call the glitch

642
00:29:54,320 --> 00:29:56,399
delay

643
00:29:56,399 --> 00:29:58,159
so this glitch delay is from the

644
00:29:58,159 --> 00:29:59,520
relayable trigger

645
00:29:59,520 --> 00:30:02,799
to the actual operation of interest

646
00:30:02,799 --> 00:30:06,559
and then you need to change the old days

647
00:30:06,559 --> 00:30:06,960
right

648
00:30:06,960 --> 00:30:10,240
you need to take it to uh

649
00:30:10,240 --> 00:30:13,360
take it away from its operating voltage

650
00:30:13,360 --> 00:30:16,640
either by reducing or increasing

651
00:30:16,640 --> 00:30:19,679
typically we go below because

652
00:30:19,679 --> 00:30:23,600
that is safer and finally

653
00:30:23,600 --> 00:30:26,000
how long you want to induce this click

654
00:30:26,000 --> 00:30:27,120
so how long you want to

655
00:30:27,120 --> 00:30:31,678
keep the voltage to that level

656
00:30:31,760 --> 00:30:36,799
so these three are important parameters

657
00:30:36,799 --> 00:30:40,240
sometimes we you may also have to uh not

658
00:30:40,240 --> 00:30:41,919
sometimes but most of the times you need

659
00:30:41,919 --> 00:30:43,440
to uh

660
00:30:43,440 --> 00:30:47,039
provide your own uh old power supply

661
00:30:47,039 --> 00:30:50,240
so that you can control it and

662
00:30:50,240 --> 00:30:52,559
some sometimes you may have to remove

663
00:30:52,559 --> 00:30:54,880
the capacitor so that your

664
00:30:54,880 --> 00:31:00,480
glitch is a lot more effective

665
00:31:00,559 --> 00:31:04,320
so this is a typical setup looks like

666
00:31:04,320 --> 00:31:07,760
we have the glitch generator to generate

667
00:31:07,760 --> 00:31:08,080
the

668
00:31:08,080 --> 00:31:11,120
voltage glitches and

669
00:31:11,120 --> 00:31:15,600
glitch amplifier which amplifies the

670
00:31:15,600 --> 00:31:19,279
given uh voltage glitch which will be

671
00:31:19,279 --> 00:31:23,360
provided to the chip or the target

672
00:31:23,360 --> 00:31:26,480
in this experiment

673
00:31:26,480 --> 00:31:29,679
and then uh from the target

674
00:31:29,679 --> 00:31:32,640
you have a trigger signal remember uh

675
00:31:32,640 --> 00:31:34,320
the trigger signal is something that

676
00:31:34,320 --> 00:31:36,720
comes here

677
00:31:36,720 --> 00:31:39,760
and then uh you need to communicate with

678
00:31:39,760 --> 00:31:43,919
yeah with the generator and the target

679
00:31:43,919 --> 00:31:47,200
using the pc and then yeah sometimes it

680
00:31:47,200 --> 00:31:48,000
may also be

681
00:31:48,000 --> 00:31:50,960
good to have a way to reset the device

682
00:31:50,960 --> 00:31:52,240
directly

683
00:31:52,240 --> 00:31:56,399
uh during fault injection

684
00:31:56,640 --> 00:32:00,080
so this is how it looks like

685
00:32:00,080 --> 00:32:02,960
uh you can see the spider which is a

686
00:32:02,960 --> 00:32:04,000
glitch generator

687
00:32:04,000 --> 00:32:07,039
glitch amplifier and then the bunch of

688
00:32:07,039 --> 00:32:10,480
pins here which can be connected to

689
00:32:10,480 --> 00:32:15,519
control either the triggers or resets

690
00:32:25,760 --> 00:32:30,640
directly by ourselves

691
00:32:31,679 --> 00:32:34,720
yeah and then we have a program to

692
00:32:34,720 --> 00:32:37,450
control uh all the

693
00:32:37,450 --> 00:32:38,960
[Music]

694
00:32:38,960 --> 00:32:42,640
setup how to when to inject glitches how

695
00:32:42,640 --> 00:32:43,679
to inject glasses

696
00:32:43,679 --> 00:32:46,720
glitches and when to get the data

697
00:32:46,720 --> 00:32:49,039
and then the parameters that we need to

698
00:32:49,039 --> 00:32:50,080
give

699
00:32:50,080 --> 00:32:52,799
and finally once we have the data how to

700
00:32:52,799 --> 00:32:55,360
interpret it

701
00:32:55,360 --> 00:32:58,559
so let's take a simple example here uh

702
00:32:58,559 --> 00:33:00,960
this is uh before we do the actual test

703
00:33:00,960 --> 00:33:02,000
we want to know

704
00:33:02,000 --> 00:33:04,480
uh the parameters that i just described

705
00:33:04,480 --> 00:33:05,840
how they look like

706
00:33:05,840 --> 00:33:09,039
uh what are the ideal parameters so to

707
00:33:09,039 --> 00:33:11,120
do that we do a simple test like

708
00:33:11,120 --> 00:33:14,320
um doing uh 10 000 times a simple add

709
00:33:14,320 --> 00:33:15,120
operation

710
00:33:15,120 --> 00:33:18,559
and see if we get output

711
00:33:18,559 --> 00:33:22,320
proper or not and during this ad

712
00:33:22,320 --> 00:33:23,519
operations we just

713
00:33:23,519 --> 00:33:25,840
glitch

714
00:33:26,640 --> 00:33:30,880
and then you see here the outputs

715
00:33:30,880 --> 00:33:34,399
from the uh function if the output is 10

716
00:33:34,399 --> 00:33:37,120
000 as expected then it will be marked

717
00:33:37,120 --> 00:33:39,360
as green here

718
00:33:39,360 --> 00:33:42,799
uh if the device

719
00:33:42,799 --> 00:33:45,679
resets or doesn't uh respond back

720
00:33:45,679 --> 00:33:46,960
because of our glitch

721
00:33:46,960 --> 00:33:50,840
or fault uh because we mark it with

722
00:33:50,840 --> 00:33:52,080
yellow and

723
00:33:52,080 --> 00:33:55,039
reds or something that are interesting

724
00:33:55,039 --> 00:33:55,679
because

725
00:33:55,679 --> 00:33:59,440
they they provide uh an

726
00:33:59,440 --> 00:34:01,919
unexpected output for example instead of

727
00:34:01,919 --> 00:34:03,200
10 000 it

728
00:34:03,200 --> 00:34:06,559
sends back 99999

729
00:34:06,559 --> 00:34:09,520
or yeah something like that so the reds

730
00:34:09,520 --> 00:34:10,960
are our interesting

731
00:34:10,960 --> 00:34:15,199
uh uh results

732
00:34:15,199 --> 00:34:18,800
and specifically here uh

733
00:34:18,800 --> 00:34:21,440
we are interested around this region

734
00:34:21,440 --> 00:34:23,040
because here we see a lot of

735
00:34:23,040 --> 00:34:26,639
rats and uh for the actual experiment

736
00:34:26,639 --> 00:34:28,960
which involves corrupting our

737
00:34:28,960 --> 00:34:34,159
ra rsp we use this area

738
00:34:34,159 --> 00:34:37,520
so yeah this is how

739
00:34:37,520 --> 00:34:39,918
we do characterization now uh i will

740
00:34:39,918 --> 00:34:42,560
give it to news to present the actual

741
00:34:42,560 --> 00:34:44,000
experimental results for

742
00:34:44,000 --> 00:34:49,119
uh ra or xp

743
00:34:49,119 --> 00:34:52,000
thank you yeah i think you can hear me

744
00:34:52,000 --> 00:34:53,440
now

745
00:34:53,440 --> 00:34:55,679
yes

746
00:34:59,920 --> 00:35:03,839
and i think you can see it now

747
00:35:04,240 --> 00:35:08,800
all right uh yeah one thing to note here

748
00:35:08,800 --> 00:35:10,640
is that if you are attacking a real

749
00:35:10,640 --> 00:35:11,359
device

750
00:35:11,359 --> 00:35:13,599
or you would try to do something actual

751
00:35:13,599 --> 00:35:15,359
like some actual attack you would

752
00:35:15,359 --> 00:35:17,440
stay a bit longer in this phase and try

753
00:35:17,440 --> 00:35:19,040
to optimize where you get these

754
00:35:19,040 --> 00:35:20,880
successful results

755
00:35:20,880 --> 00:35:22,960
but because they're they are so we're so

756
00:35:22,960 --> 00:35:24,079
abundant in this

757
00:35:24,079 --> 00:35:26,560
particular cpu and we want to generate

758
00:35:26,560 --> 00:35:27,839
these nice pictures for

759
00:35:27,839 --> 00:35:31,280
our own experiments as well

760
00:35:31,280 --> 00:35:34,079
we picked the area where we covered both

761
00:35:34,079 --> 00:35:35,920
successful and unsuccessful

762
00:35:35,920 --> 00:35:38,320
faults

763
00:35:42,000 --> 00:35:45,280
so once we had this we had our

764
00:35:45,280 --> 00:35:48,560
uh yeah our settings for our fault

765
00:35:48,560 --> 00:35:50,320
injection campaign

766
00:35:50,320 --> 00:35:53,200
so then the second thing we needed was a

767
00:35:53,200 --> 00:35:55,760
experimental setup in terms of software

768
00:35:55,760 --> 00:35:58,880
which we can use to show

769
00:35:58,880 --> 00:36:00,720
that the attack we proposed is actually

770
00:36:00,720 --> 00:36:02,960
possible

771
00:36:02,960 --> 00:36:07,599
so for that we used a

772
00:36:07,599 --> 00:36:09,119
yeah we used a small software that's

773
00:36:09,119 --> 00:36:11,200
very similar to what i show you here on

774
00:36:11,200 --> 00:36:12,640
the screen

775
00:36:12,640 --> 00:36:15,119
so there is a test function which is the

776
00:36:15,119 --> 00:36:17,200
entry point for the

777
00:36:17,200 --> 00:36:19,760
for the experiment we wait to receive a

778
00:36:19,760 --> 00:36:21,599
command from outside to actually start

779
00:36:21,599 --> 00:36:23,599
the experiment

780
00:36:23,599 --> 00:36:27,520
and then we have a sort of mem copy

781
00:36:27,520 --> 00:36:31,280
but slightly modified so that it works

782
00:36:31,280 --> 00:36:32,720
for our setup

783
00:36:32,720 --> 00:36:35,520
so what we do is we put some local

784
00:36:35,520 --> 00:36:37,040
memory address in

785
00:36:37,040 --> 00:36:40,160
s7 so that would be our pointer in a

786
00:36:40,160 --> 00:36:42,640
real mem copy to the

787
00:36:42,640 --> 00:36:46,320
uh to the source

788
00:36:46,320 --> 00:36:50,079
of the memcope and then we set up

789
00:36:50,079 --> 00:36:52,320
we load the address of the source of the

790
00:36:52,320 --> 00:36:54,079
memcop into another register

791
00:36:54,079 --> 00:36:56,560
and we store that in this previously

792
00:36:56,560 --> 00:36:58,079
used memory address

793
00:36:58,079 --> 00:37:00,320
and we need to do it like this because

794
00:37:00,320 --> 00:37:01,760
in a real memcopy

795
00:37:01,760 --> 00:37:04,880
you you also have this

796
00:37:04,880 --> 00:37:08,560
method where you dereference a pointer

797
00:37:08,560 --> 00:37:10,160
and that's what you see here in this

798
00:37:10,160 --> 00:37:13,040
load word operation

799
00:37:13,040 --> 00:37:15,839
so here you dereference the address of

800
00:37:15,839 --> 00:37:18,000
s7 which is this local memory address

801
00:37:18,000 --> 00:37:20,880
which contains our payload destination

802
00:37:20,880 --> 00:37:23,119
and since we are doing an experiment

803
00:37:23,119 --> 00:37:25,440
here we put everything just in our local

804
00:37:25,440 --> 00:37:27,440
memory already so in the real world

805
00:37:27,440 --> 00:37:29,680
this payload would be somewhere in your

806
00:37:29,680 --> 00:37:30,720
external

807
00:37:30,720 --> 00:37:33,119
slash for example but here we just put

808
00:37:33,119 --> 00:37:36,480
it alongside it in memory and what the

809
00:37:36,480 --> 00:37:37,280
payload does

810
00:37:37,280 --> 00:37:39,599
is it does two things it puts the

811
00:37:39,599 --> 00:37:41,839
current return address into temporary

812
00:37:41,839 --> 00:37:42,880
register one

813
00:37:42,880 --> 00:37:45,359
and a magic value and temporary register

814
00:37:45,359 --> 00:37:46,400
too

815
00:37:46,400 --> 00:37:48,480
and this information helps us identify

816
00:37:48,480 --> 00:37:50,880
if our

817
00:37:50,880 --> 00:37:54,160
experiment succeeded in executing this

818
00:37:54,160 --> 00:37:56,240
payload

819
00:37:56,240 --> 00:37:59,439
because if

820
00:37:59,920 --> 00:38:02,640
in a normal flow or there are no faults

821
00:38:02,640 --> 00:38:04,800
we start executing a test function

822
00:38:04,800 --> 00:38:06,400
we receive a command we receive the

823
00:38:06,400 --> 00:38:08,160
command to actually start the mem copy

824
00:38:08,160 --> 00:38:09,920
we do the mem copy and then

825
00:38:09,920 --> 00:38:11,520
we reach this return function and what

826
00:38:11,520 --> 00:38:13,599
the return function does is it sets the

827
00:38:13,599 --> 00:38:15,599
program counter to the current return

828
00:38:15,599 --> 00:38:18,000
address value

829
00:38:18,000 --> 00:38:20,320
if there was nothing weird going on the

830
00:38:20,320 --> 00:38:22,480
return address contains the

831
00:38:22,480 --> 00:38:25,440
dislocation where i mean this location

832
00:38:25,440 --> 00:38:28,880
the next instruction after our jump

833
00:38:28,880 --> 00:38:32,800
and then it just keeps loop forever

834
00:38:32,800 --> 00:38:35,599
now with our if we take our fault and

835
00:38:35,599 --> 00:38:38,720
our fault is successful in changing this

836
00:38:38,720 --> 00:38:41,119
temporary register into the return

837
00:38:41,119 --> 00:38:42,160
address

838
00:38:42,160 --> 00:38:44,960
then after we call the return function

839
00:38:44,960 --> 00:38:47,040
the program counter is set to

840
00:38:47,040 --> 00:38:49,280
that value in the return address which

841
00:38:49,280 --> 00:38:52,800
is our payload destination

842
00:38:53,359 --> 00:38:56,480
so if we and then after it's it's not

843
00:38:56,480 --> 00:38:58,640
shown here but after each attempt we did

844
00:38:58,640 --> 00:39:01,280
all the registers on the register values

845
00:39:01,280 --> 00:39:03,599
and if this t2 register contains the

846
00:39:03,599 --> 00:39:04,640
magic value

847
00:39:04,640 --> 00:39:08,640
that we put here in our payload

848
00:39:08,640 --> 00:39:12,839
destination then we know that our attack

849
00:39:12,839 --> 00:39:14,160
succeeded

850
00:39:14,160 --> 00:39:16,160
yeah here i just showed one instruction

851
00:39:16,160 --> 00:39:18,480
but in reality there will be

852
00:39:18,480 --> 00:39:23,599
many instructions in one loop iteration

853
00:39:23,599 --> 00:39:26,640
if you would compile a actual mem copy

854
00:39:26,640 --> 00:39:28,480
it would stick to those temporary

855
00:39:28,480 --> 00:39:30,240
registers there are

856
00:39:30,240 --> 00:39:33,359
six or seven or eight of them

857
00:39:33,359 --> 00:39:35,119
but since we are doing experiments here

858
00:39:35,119 --> 00:39:37,599
we also try to see what happens if we

859
00:39:37,599 --> 00:39:39,760
just use all the registers

860
00:39:39,760 --> 00:39:41,680
and our expectation was that there is a

861
00:39:41,680 --> 00:39:43,440
higher success rate if you use all the

862
00:39:43,440 --> 00:39:44,880
registers

863
00:39:44,880 --> 00:39:48,320
as you cover more of those temporary

864
00:39:48,320 --> 00:39:50,880
encodings

865
00:39:52,079 --> 00:39:54,560
and

866
00:39:55,119 --> 00:39:57,359
yeah how this would look more or less in

867
00:39:57,359 --> 00:39:58,480
memory is that

868
00:39:58,480 --> 00:40:00,480
on the one hand you would have this code

869
00:40:00,480 --> 00:40:02,640
that you trust which is executing the

870
00:40:02,640 --> 00:40:04,319
mem copy

871
00:40:04,319 --> 00:40:07,200
and it will copy into memory this

872
00:40:07,200 --> 00:40:08,400
entrusted code

873
00:40:08,400 --> 00:40:10,400
into interested data which first

874
00:40:10,400 --> 00:40:12,560
contains the payload and then

875
00:40:12,560 --> 00:40:15,839
the address of that payload many many

876
00:40:15,839 --> 00:40:16,960
times

877
00:40:16,960 --> 00:40:18,880
so that every time you copy this address

878
00:40:18,880 --> 00:40:22,079
of the payload is a potential

879
00:40:22,079 --> 00:40:24,640
successful a successful fault could

880
00:40:24,640 --> 00:40:26,079
happen

881
00:40:26,079 --> 00:40:28,480
and we need that level of indirection

882
00:40:28,480 --> 00:40:30,319
like ravine said because we

883
00:40:30,319 --> 00:40:34,079
are not loading this ad address into the

884
00:40:34,079 --> 00:40:36,400
program counter directly

885
00:40:36,400 --> 00:40:40,000
but we are dereferencing it into a

886
00:40:40,000 --> 00:40:44,800
another register

887
00:40:47,440 --> 00:40:50,640
um so in summary we

888
00:40:50,640 --> 00:40:53,359
for so far since we're doing experiments

889
00:40:53,359 --> 00:40:54,160
with a

890
00:40:54,160 --> 00:40:55,839
target we completely control we can

891
00:40:55,839 --> 00:40:58,160
cheat a little bit by using a gpio bit

892
00:40:58,160 --> 00:40:59,760
to trigger a default

893
00:40:59,760 --> 00:41:02,720
to have a very constant moment in time

894
00:41:02,720 --> 00:41:03,119
uh

895
00:41:03,119 --> 00:41:05,520
in a real world scenario you might not

896
00:41:05,520 --> 00:41:07,839
have this so then you might have to rely

897
00:41:07,839 --> 00:41:12,079
on using usb activity or uart activity

898
00:41:12,079 --> 00:41:14,880
or if nothing is there you might have to

899
00:41:14,880 --> 00:41:16,720
take some kind of side channel analysis

900
00:41:16,720 --> 00:41:18,480
probe like

901
00:41:18,480 --> 00:41:20,400
to measure current or to measure em

902
00:41:20,400 --> 00:41:21,760
fields to get a

903
00:41:21,760 --> 00:41:26,319
reliable point to trigger your fault

904
00:41:26,319 --> 00:41:28,640
uh we considered our experiment

905
00:41:28,640 --> 00:41:29,760
successful if we

906
00:41:29,760 --> 00:41:33,520
observe this magic value in d2

907
00:41:33,520 --> 00:41:35,440
and we did two rounds of experiments one

908
00:41:35,440 --> 00:41:36,960
where we use all the

909
00:41:36,960 --> 00:41:39,920
almost all of the registers that are

910
00:41:39,920 --> 00:41:42,000
available to us

911
00:41:42,000 --> 00:41:44,720
in our mem copy and another one where we

912
00:41:44,720 --> 00:41:47,440
only use the temporary registers

913
00:41:47,440 --> 00:41:49,599
and what we found is that both gave us

914
00:41:49,599 --> 00:41:52,480
successful faults

915
00:41:53,760 --> 00:41:55,599
yeah this is a picture that the preview

916
00:41:55,599 --> 00:41:57,359
showed you also during the

917
00:41:57,359 --> 00:41:59,040
characterization

918
00:41:59,040 --> 00:42:02,720
step so there's the green which had no

919
00:42:02,720 --> 00:42:03,280
effect

920
00:42:03,280 --> 00:42:04,880
and then you can see that there is this

921
00:42:04,880 --> 00:42:06,400
curve of yellow where

922
00:42:06,400 --> 00:42:08,319
stuff started happening and if you are

923
00:42:08,319 --> 00:42:10,240
not colorblind you can see there are

924
00:42:10,240 --> 00:42:11,040
some

925
00:42:11,040 --> 00:42:13,839
red dots in here as well those were the

926
00:42:13,839 --> 00:42:17,680
successful folds

927
00:42:17,680 --> 00:42:20,240
yeah this is the numbers so you see the

928
00:42:20,240 --> 00:42:21,839
amount of attempts we did

929
00:42:21,839 --> 00:42:24,079
and a very small percentage of them

930
00:42:24,079 --> 00:42:25,119
succeeded

931
00:42:25,119 --> 00:42:27,200
note that this is a very small one of

932
00:42:27,200 --> 00:42:28,319
the reasons this is the smallest

933
00:42:28,319 --> 00:42:30,800
percentage is because we had a

934
00:42:30,800 --> 00:42:33,440
wide range of parameters we tested if

935
00:42:33,440 --> 00:42:34,720
you were to zoom in

936
00:42:34,720 --> 00:42:38,400
into a region or a

937
00:42:38,400 --> 00:42:40,400
configuration of parameters where you

938
00:42:40,400 --> 00:42:41,440
observe more red

939
00:42:41,440 --> 00:42:43,040
than others for example here you see

940
00:42:43,040 --> 00:42:44,800
none this would

941
00:42:44,800 --> 00:42:47,920
increase your success rate which is

942
00:42:47,920 --> 00:42:49,200
something you would do

943
00:42:49,200 --> 00:42:50,880
in a real attack but since we're just

944
00:42:50,880 --> 00:42:52,319
doing experiments here

945
00:42:52,319 --> 00:42:54,480
we stick to those and also it allowed us

946
00:42:54,480 --> 00:42:56,839
to better compare these different

947
00:42:56,839 --> 00:42:59,040
scenarios

948
00:42:59,040 --> 00:43:02,000
uh yeah what we see here is that when we

949
00:43:02,000 --> 00:43:03,520
only use the temporary registers the

950
00:43:03,520 --> 00:43:04,560
success phase

951
00:43:04,560 --> 00:43:07,760
success rate drops by half

952
00:43:07,760 --> 00:43:11,760
or even more almost by a factor of 10

953
00:43:11,760 --> 00:43:14,000
and then in this last column i i gave

954
00:43:14,000 --> 00:43:15,200
you an indication of

955
00:43:15,200 --> 00:43:16,960
the time until we had our first

956
00:43:16,960 --> 00:43:19,359
successful glitch

957
00:43:19,359 --> 00:43:21,040
and this is of course a number with very

958
00:43:21,040 --> 00:43:22,400
high variance because

959
00:43:22,400 --> 00:43:25,040
yeah since you had it's a statistical

960
00:43:25,040 --> 00:43:26,800
exercise so you might get lucky you

961
00:43:26,800 --> 00:43:29,200
might not get lucky

962
00:43:29,200 --> 00:43:31,040
but yeah you can see this big order of

963
00:43:31,040 --> 00:43:34,240
difference between the two

964
00:43:37,760 --> 00:43:42,160
now i will try to

965
00:43:43,760 --> 00:43:45,200
one last thing i would like to share

966
00:43:45,200 --> 00:43:47,839
with you is that

967
00:43:47,839 --> 00:43:50,560
we had we observed something interesting

968
00:43:50,560 --> 00:43:51,680
here

969
00:43:51,680 --> 00:43:54,160
because if you if you recall what i

970
00:43:54,160 --> 00:43:55,040
showed you before

971
00:43:55,040 --> 00:43:57,040
the payload what it does is it sets a

972
00:43:57,040 --> 00:43:58,880
temporary district to the current return

973
00:43:58,880 --> 00:43:59,839
address value

974
00:43:59,839 --> 00:44:02,880
and another one to the magic value

975
00:44:02,880 --> 00:44:04,640
but one thing we also observed is that

976
00:44:04,640 --> 00:44:06,240
we ended up in our payload

977
00:44:06,240 --> 00:44:09,359
so we got this magic value but the test

978
00:44:09,359 --> 00:44:12,400
function was the return

979
00:44:12,400 --> 00:44:13,760
well not actually the test function but

980
00:44:13,760 --> 00:44:15,760
this gym to test function was

981
00:44:15,760 --> 00:44:18,800
the value in the return address and this

982
00:44:18,800 --> 00:44:20,720
suggests that we somehow

983
00:44:20,720 --> 00:44:23,280
managed to reach our payload without

984
00:44:23,280 --> 00:44:24,800
hitting

985
00:44:24,800 --> 00:44:28,240
a copy instructions situated the address

986
00:44:28,240 --> 00:44:31,839
gets loaded into ra

987
00:44:32,240 --> 00:44:34,240
and yeah if we split those out from the

988
00:44:34,240 --> 00:44:36,160
successful results you can see that

989
00:44:36,160 --> 00:44:38,720
in both cases it's more or less a 50 50

990
00:44:38,720 --> 00:44:40,880
division between

991
00:44:40,880 --> 00:44:42,960
reaching our payload through the return

992
00:44:42,960 --> 00:44:45,119
address and also

993
00:44:45,119 --> 00:44:47,599
the other half was re able to reach

994
00:44:47,599 --> 00:44:49,119
payload without changing the return

995
00:44:49,119 --> 00:44:51,040
address

996
00:44:51,040 --> 00:44:53,839
now there are some theories on what

997
00:44:53,839 --> 00:44:56,480
happened here

998
00:44:56,480 --> 00:45:00,079
perhaps we you we changed the load word

999
00:45:00,079 --> 00:45:00,800
into the

1000
00:45:00,800 --> 00:45:04,000
jumper link register instruction

1001
00:45:04,000 --> 00:45:06,720
which takes a value in a register and

1002
00:45:06,720 --> 00:45:08,400
jumps to it

1003
00:45:08,400 --> 00:45:11,440
so you yeah that's you don't control

1004
00:45:11,440 --> 00:45:14,640
pc directly but it's almost directly

1005
00:45:14,640 --> 00:45:15,280
because you

1006
00:45:15,280 --> 00:45:17,839
change the pc to a value in a register

1007
00:45:17,839 --> 00:45:19,200
that you specify

1008
00:45:19,200 --> 00:45:21,920
however another thing this instruction

1009
00:45:21,920 --> 00:45:23,760
does is it sets

1010
00:45:23,760 --> 00:45:28,000
a second register argument to the

1011
00:45:28,160 --> 00:45:29,680
basically the return address program

1012
00:45:29,680 --> 00:45:31,359
counter plus 4 but it doesn't have to be

1013
00:45:31,359 --> 00:45:33,119
the return address register

1014
00:45:33,119 --> 00:45:34,400
however when we looked at the other

1015
00:45:34,400 --> 00:45:36,400
registers we did not observe this value

1016
00:45:36,400 --> 00:45:37,119
so

1017
00:45:37,119 --> 00:45:40,800
it could happen but it's not likely

1018
00:45:41,040 --> 00:45:42,319
another thing that could have happened

1019
00:45:42,319 --> 00:45:44,240
is that we are

1020
00:45:44,240 --> 00:45:47,920
executing our load words in a loop

1021
00:45:47,920 --> 00:45:50,079
and this loop goes back to the beginning

1022
00:45:50,079 --> 00:45:52,800
of the loop using a branch instruction

1023
00:45:52,800 --> 00:45:54,319
and this branch instruction takes an

1024
00:45:54,319 --> 00:45:55,920
offset and perhaps its offset was

1025
00:45:55,920 --> 00:45:57,119
changed

1026
00:45:57,119 --> 00:46:01,040
again this could could have happened but

1027
00:46:01,040 --> 00:46:02,640
it's also unlikely because it would

1028
00:46:02,640 --> 00:46:04,640
require very specific bit flips to get

1029
00:46:04,640 --> 00:46:07,520
the exact offset required

1030
00:46:07,520 --> 00:46:10,960
and then another uh possible explanation

1031
00:46:10,960 --> 00:46:11,359
is that

1032
00:46:11,359 --> 00:46:13,680
even though we cannot directly load

1033
00:46:13,680 --> 00:46:14,960
values into pro

1034
00:46:14,960 --> 00:46:16,880
into the program counter using the

1035
00:46:16,880 --> 00:46:19,040
available instructions

1036
00:46:19,040 --> 00:46:21,680
if you think about the hardware in the

1037
00:46:21,680 --> 00:46:23,920
end the cpu will have one big

1038
00:46:23,920 --> 00:46:26,720
multiplexer to select which register to

1039
00:46:26,720 --> 00:46:27,119
use

1040
00:46:27,119 --> 00:46:30,079
for a value that's somewhere else in the

1041
00:46:30,079 --> 00:46:32,000
in the cpu

1042
00:46:32,000 --> 00:46:34,000
and even though it's not exposed this

1043
00:46:34,000 --> 00:46:35,920
multiplexer will

1044
00:46:35,920 --> 00:46:38,079
also be able to reach the program

1045
00:46:38,079 --> 00:46:39,920
counter register

1046
00:46:39,920 --> 00:46:41,920
because it needs to update the program

1047
00:46:41,920 --> 00:46:43,599
counter

1048
00:46:43,599 --> 00:46:45,200
so although it's not exposed as an

1049
00:46:45,200 --> 00:46:47,359
instruction there is still a data path

1050
00:46:47,359 --> 00:46:50,480
from whatever value you have in your cpu

1051
00:46:50,480 --> 00:46:53,280
for the current operation to the program

1052
00:46:53,280 --> 00:46:54,079
counter

1053
00:46:54,079 --> 00:46:56,000
and what we suspect and if you would

1054
00:46:56,000 --> 00:46:57,200
look at

1055
00:46:57,200 --> 00:46:58,880
open source implementations of the

1056
00:46:58,880 --> 00:47:01,119
risc-5 architecture

1057
00:47:01,119 --> 00:47:03,200
you can actually see that this data path

1058
00:47:03,200 --> 00:47:04,800
exists

1059
00:47:04,800 --> 00:47:08,319
so this is our like most what we

1060
00:47:08,319 --> 00:47:10,079
think is the most probable hypothesis

1061
00:47:10,079 --> 00:47:12,000
about how we are able to reach our

1062
00:47:12,000 --> 00:47:14,960
payloads without

1063
00:47:15,200 --> 00:47:17,040
going through the return address

1064
00:47:17,040 --> 00:47:19,280
interaction that we expected to be

1065
00:47:19,280 --> 00:47:22,720
necessary when we started these

1066
00:47:22,839 --> 00:47:25,359
experiments

1067
00:47:25,359 --> 00:47:27,920
so we are running a bit out of time so

1068
00:47:27,920 --> 00:47:28,880
i'm gonna just

1069
00:47:28,880 --> 00:47:30,960
fly through this second set of

1070
00:47:30,960 --> 00:47:32,640
experiments

1071
00:47:32,640 --> 00:47:35,520
just in a in a brief summary we also did

1072
00:47:35,520 --> 00:47:37,599
the same experiment with trying

1073
00:47:37,599 --> 00:47:42,960
we try to target the stack pointer

1074
00:47:42,960 --> 00:47:45,520
one downside of using return address as

1075
00:47:45,520 --> 00:47:46,960
a target is that

1076
00:47:46,960 --> 00:47:49,280
if you are not in a leave function so

1077
00:47:49,280 --> 00:47:51,280
memcop usually is a leave function which

1078
00:47:51,280 --> 00:47:54,559
means it doesn't call other functions

1079
00:47:54,559 --> 00:47:57,200
so it does not overwrite the return

1080
00:47:57,200 --> 00:47:59,200
address but if memcopy would call

1081
00:47:59,200 --> 00:48:01,599
more functions then the return address

1082
00:48:01,599 --> 00:48:03,040
value would be updated

1083
00:48:03,040 --> 00:48:07,520
to the return address of that

1084
00:48:07,520 --> 00:48:10,559
of that calling function and that would

1085
00:48:10,559 --> 00:48:12,160
negate your attack

1086
00:48:12,160 --> 00:48:15,680
however if you do it through a stack

1087
00:48:15,680 --> 00:48:17,200
pointer

1088
00:48:17,200 --> 00:48:18,800
then you would need another level of

1089
00:48:18,800 --> 00:48:20,400
interaction because you have to go

1090
00:48:20,400 --> 00:48:22,160
not only through the return address but

1091
00:48:22,160 --> 00:48:24,079
through the return that is stored on the

1092
00:48:24,079 --> 00:48:25,440
stack

1093
00:48:25,440 --> 00:48:28,000
but this is more powerful because you

1094
00:48:28,000 --> 00:48:28,559
are not

1095
00:48:28,559 --> 00:48:31,200
restricted to those leave functions and

1096
00:48:31,200 --> 00:48:32,240
then it's basically

1097
00:48:32,240 --> 00:48:34,400
a classical stack overflow attack you

1098
00:48:34,400 --> 00:48:36,559
know from software exploitation

1099
00:48:36,559 --> 00:48:38,800
that we just triggered it not through a

1100
00:48:38,800 --> 00:48:40,720
stack buffer overflow but

1101
00:48:40,720 --> 00:48:44,160
through fault injection yeah

1102
00:48:44,160 --> 00:48:47,280
we also succeeded in this if you compare

1103
00:48:47,280 --> 00:48:50,319
those percentages they are lower and one

1104
00:48:50,319 --> 00:48:51,520
number that really stands out

1105
00:48:51,520 --> 00:48:54,640
is eight minutes here because

1106
00:48:54,640 --> 00:48:58,079
here we needed 22 minutes to reach a

1107
00:48:58,079 --> 00:48:59,359
successful

1108
00:48:59,359 --> 00:49:02,400
fault here we needed nine hours

1109
00:49:02,400 --> 00:49:04,880
and here we needed only eight minutes

1110
00:49:04,880 --> 00:49:06,640
but even though this percentage is super

1111
00:49:06,640 --> 00:49:07,760
low

1112
00:49:07,760 --> 00:49:09,359
and yeah this is comes back to this

1113
00:49:09,359 --> 00:49:10,880
variance i told you about

1114
00:49:10,880 --> 00:49:13,200
before for about this number we just

1115
00:49:13,200 --> 00:49:16,000
like we just got lucky here

1116
00:49:16,000 --> 00:49:18,880
which i mean that's one of the sexy

1117
00:49:18,880 --> 00:49:20,240
things about fault injection you can

1118
00:49:20,240 --> 00:49:23,200
always just get lucky

1119
00:49:24,000 --> 00:49:27,119
yeah so quick words about again why this

1120
00:49:27,119 --> 00:49:27,440
is

1121
00:49:27,440 --> 00:49:31,440
such a cool thing to do our typical use

1122
00:49:31,440 --> 00:49:33,440
case is that we like to bypass secure

1123
00:49:33,440 --> 00:49:33,920
boots

1124
00:49:33,920 --> 00:49:36,800
and this is a really cool way of doing

1125
00:49:36,800 --> 00:49:37,200
that

1126
00:49:37,200 --> 00:49:40,480
because you uh do it before

1127
00:49:40,480 --> 00:49:43,680
even reaching any authentication or what

1128
00:49:43,680 --> 00:49:46,160
whatsoever you are like you're right in

1129
00:49:46,160 --> 00:49:47,760
the middle

1130
00:49:47,760 --> 00:49:50,240
um

1131
00:49:53,599 --> 00:49:55,040
yeah you like you don't even have to

1132
00:49:55,040 --> 00:49:56,960
think about the authentication you just

1133
00:49:56,960 --> 00:49:58,640
jump directly to whatever you are

1134
00:49:58,640 --> 00:50:00,640
copying into your

1135
00:50:00,640 --> 00:50:03,839
device and another thing

1136
00:50:03,839 --> 00:50:06,240
is privileged escalation so most cpus

1137
00:50:06,240 --> 00:50:07,040
have

1138
00:50:07,040 --> 00:50:08,480
some kind of distinction between the

1139
00:50:08,480 --> 00:50:11,040
privileged and non-privileged mode

1140
00:50:11,040 --> 00:50:13,040
in our address 5 we call it it's called

1141
00:50:13,040 --> 00:50:14,720
user mode and machine mode

1142
00:50:14,720 --> 00:50:18,480
so you can imagine that if you are

1143
00:50:18,800 --> 00:50:21,599
if your cpu is in machine mode and you

1144
00:50:21,599 --> 00:50:23,760
manage to make it execute codes that you

1145
00:50:23,760 --> 00:50:25,680
control then you suddenly control the

1146
00:50:25,680 --> 00:50:26,000
machine

1147
00:50:26,000 --> 00:50:28,800
mode or if you think about res and these

1148
00:50:28,800 --> 00:50:31,040
if you manage to get the ide to execute

1149
00:50:31,040 --> 00:50:32,079
your

1150
00:50:32,079 --> 00:50:34,160
re code then suddenly you have control

1151
00:50:34,160 --> 00:50:36,720
over the team

1152
00:50:38,400 --> 00:50:41,920
yeah some quick conclusions uh

1153
00:50:41,920 --> 00:50:43,839
we explained to you what is false

1154
00:50:43,839 --> 00:50:46,400
injection we explored various options

1155
00:50:46,400 --> 00:50:49,280
use this to control the program counter

1156
00:50:49,280 --> 00:50:50,480
we showed that the

1157
00:50:50,480 --> 00:50:53,359
two cases we thought would be successful

1158
00:50:53,359 --> 00:50:55,440
before we're actually successful

1159
00:50:55,440 --> 00:50:57,359
i've also got this unexpected result

1160
00:50:57,359 --> 00:50:58,480
where

1161
00:50:58,480 --> 00:51:01,119
we directly control the program counter

1162
00:51:01,119 --> 00:51:01,920
even though

1163
00:51:01,920 --> 00:51:03,440
the program counter register is not

1164
00:51:03,440 --> 00:51:05,599
directly accessible to the instruction

1165
00:51:05,599 --> 00:51:08,880
set architecture uh yeah some future

1166
00:51:08,880 --> 00:51:10,240
work ideas

1167
00:51:10,240 --> 00:51:11,680
by the way if you're interested in this

1168
00:51:11,680 --> 00:51:13,520
we are also always looking for more

1169
00:51:13,520 --> 00:51:15,119
interns so if you're interested in

1170
00:51:15,119 --> 00:51:16,559
researching this kind of stuff please

1171
00:51:16,559 --> 00:51:19,599
get in touch with us

1172
00:51:20,480 --> 00:51:22,319
for example trying to do this with your

1173
00:51:22,319 --> 00:51:24,640
gym for branch instructions

1174
00:51:24,640 --> 00:51:26,559
and yeah we did not really talk about

1175
00:51:26,559 --> 00:51:27,920
countermeasures against this kind of

1176
00:51:27,920 --> 00:51:28,400
attack

1177
00:51:28,400 --> 00:51:32,240
or how you you could protect this but uh

1178
00:51:32,240 --> 00:51:34,480
yeah once you protect it how could you

1179
00:51:34,480 --> 00:51:36,000
circumvent those protection is also

1180
00:51:36,000 --> 00:51:38,880
interesting to look at

1181
00:51:39,040 --> 00:51:41,200
so i tried to rush to the end here so we

1182
00:51:41,200 --> 00:51:43,040
might still have some time for questions

1183
00:51:43,040 --> 00:51:43,760
i'm not sure

1184
00:51:43,760 --> 00:51:46,079
it's already 8 o'clock here on my screen

1185
00:51:46,079 --> 00:51:46,960
so

1186
00:51:46,960 --> 00:51:51,359
i think we even ate into your break

1187
00:51:51,359 --> 00:51:54,480
uh thank you so much niels and praveen

1188
00:51:54,480 --> 00:51:54,800
uh

1189
00:51:54,800 --> 00:51:58,000
there was one question asked uh

1190
00:51:58,000 --> 00:52:05,200
by upper uh is there an alternate way to

1191
00:52:05,200 --> 00:52:08,319
where is that uh

1192
00:52:08,319 --> 00:52:10,480
let's say i'm doing it on actual device

1193
00:52:10,480 --> 00:52:11,839
is there any other way

1194
00:52:11,839 --> 00:52:14,160
from apart from side channel attack in

1195
00:52:14,160 --> 00:52:16,000
order to extract the instructions where

1196
00:52:16,000 --> 00:52:17,680
i want to inject the fall and praveen

1197
00:52:17,680 --> 00:52:19,599
has already answered it

1198
00:52:19,599 --> 00:52:22,800
that there's no other way uh so yeah

1199
00:52:22,800 --> 00:52:24,960
thank you so much niels and praveen for

1200
00:52:24,960 --> 00:52:26,559
this amazing presentation

1201
00:52:26,559 --> 00:52:28,880
friends this presentation is recorded

1202
00:52:28,880 --> 00:52:31,040
and they will be uploaded on our nalcon

1203
00:52:31,040 --> 00:52:32,160
youtube channel

1204
00:52:32,160 --> 00:52:34,000
so you could watch them after we do the

1205
00:52:34,000 --> 00:52:36,640
minor edits of audio and video quality

1206
00:52:36,640 --> 00:52:41,359
uh yeah thank you guys so much

1207
00:52:41,520 --> 00:52:44,839
my pleasure thank you for having us all

1208
00:52:44,839 --> 00:52:47,740
right

1209
00:52:47,740 --> 00:52:50,620
[Music]

