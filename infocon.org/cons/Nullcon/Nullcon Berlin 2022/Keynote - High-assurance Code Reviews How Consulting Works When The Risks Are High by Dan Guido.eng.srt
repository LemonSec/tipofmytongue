1
00:00:03,600 --> 00:00:05,680
hey so while i'm getting set up uh i

2
00:00:05,680 --> 00:00:07,440
just flew in from new york and boy are

3
00:00:07,440 --> 00:00:09,280
my arms tired but

4
00:00:09,280 --> 00:00:10,480
uh my

5
00:00:10,480 --> 00:00:12,400
electric razor

6
00:00:12,400 --> 00:00:14,240
uh decided to stop working on the way

7
00:00:14,240 --> 00:00:16,320
here it has a lock on it which i've

8
00:00:16,320 --> 00:00:18,400
never known it to have and i've never

9
00:00:18,400 --> 00:00:20,320
been able to get it unlocked

10
00:00:20,320 --> 00:00:21,359
so

11
00:00:21,359 --> 00:00:23,119
how many hackers does it take to turn on

12
00:00:23,119 --> 00:00:25,680
my electric razor we're gonna find out

13
00:00:25,680 --> 00:00:26,560
so

14
00:00:26,560 --> 00:00:28,400
if you would like to take a try it is

15
00:00:28,400 --> 00:00:30,080
right up there in the front if you get

16
00:00:30,080 --> 00:00:33,040
it to work i will give you a bag of swag

17
00:00:33,040 --> 00:00:35,040
i'll mail it to you when i get home

18
00:00:35,040 --> 00:00:35,920
um

19
00:00:35,920 --> 00:00:37,680
but seriously it's got one button it

20
00:00:37,680 --> 00:00:39,440
doesn't turn on it's fully charged and

21
00:00:39,440 --> 00:00:41,040
it has a lock icon on it so you can

22
00:00:41,040 --> 00:00:43,280
figure it out

23
00:00:43,280 --> 00:00:46,559
so i decided to have a fun talk

24
00:00:46,559 --> 00:00:49,280
originally i wanted to speak about

25
00:00:49,280 --> 00:00:50,879
how

26
00:00:50,879 --> 00:00:52,640
our business of trailer bits works or

27
00:00:52,640 --> 00:00:55,280
changes when the risks get high

28
00:00:55,280 --> 00:00:56,640
but

29
00:00:56,640 --> 00:00:58,399
um over time it kind of evolved this

30
00:00:58,399 --> 00:00:59,680
talk of well

31
00:00:59,680 --> 00:01:01,039
it seems that some of these things are a

32
00:01:01,039 --> 00:01:02,719
bit easier on one side of the fence than

33
00:01:02,719 --> 00:01:04,000
they are on the other

34
00:01:04,000 --> 00:01:06,720
and i wanted to explain why that is

35
00:01:06,720 --> 00:01:08,640
so the title of the talk today is what

36
00:01:08,640 --> 00:01:10,479
the blockchain got right

37
00:01:10,479 --> 00:01:13,360
no really uh this is a field that

38
00:01:13,360 --> 00:01:14,640
shallow bit has been working in for

39
00:01:14,640 --> 00:01:16,159
quite a number of years and we find it

40
00:01:16,159 --> 00:01:17,600
exciting because the consequences are

41
00:01:17,600 --> 00:01:19,920
high people legitimately lose hundreds

42
00:01:19,920 --> 00:01:21,439
of billions of dollars because of simple

43
00:01:21,439 --> 00:01:23,280
coding mistakes they make in little

44
00:01:23,280 --> 00:01:25,360
things called smart contracts

45
00:01:25,360 --> 00:01:27,680
and there is a widespread ecosystem of

46
00:01:27,680 --> 00:01:29,520
tools and knowledge and techniques that

47
00:01:29,520 --> 00:01:31,439
have been applied to make some of these

48
00:01:31,439 --> 00:01:33,920
things not all of these things secure in

49
00:01:33,920 --> 00:01:36,159
a way that i have never seen

50
00:01:36,159 --> 00:01:39,360
on regular software

51
00:01:39,439 --> 00:01:41,439
so a little bit about drill bits uh

52
00:01:41,439 --> 00:01:43,040
we're a 10 year old software security

53
00:01:43,040 --> 00:01:45,040
research and development firm uh we work

54
00:01:45,040 --> 00:01:48,240
in a couple of uh really neat fields um

55
00:01:48,240 --> 00:01:49,759
we do things with

56
00:01:49,759 --> 00:01:51,520
uh cryptography modern cryptography

57
00:01:51,520 --> 00:01:53,759
things like um multiparty computations

58
00:01:53,759 --> 00:01:55,840
zero knowledge proofs we do uh high

59
00:01:55,840 --> 00:01:58,000
insurance software and like satellites

60
00:01:58,000 --> 00:02:00,240
trains and airplanes we do work on cloud

61
00:02:00,240 --> 00:02:01,600
native software

62
00:02:01,600 --> 00:02:04,479
uh that run multi-billion dollar unicorn

63
00:02:04,479 --> 00:02:06,479
tech startups uh and we do work in

64
00:02:06,479 --> 00:02:08,399
blockchain security for the reasons that

65
00:02:08,399 --> 00:02:10,000
i mentioned before

66
00:02:10,000 --> 00:02:12,239
um we build software for people they

67
00:02:12,239 --> 00:02:14,319
hire us to write prototypes for security

68
00:02:14,319 --> 00:02:16,080
tools and security products

69
00:02:16,080 --> 00:02:17,120
um

70
00:02:17,120 --> 00:02:19,840
we uh we audit software we find security

71
00:02:19,840 --> 00:02:21,440
vulnerabilities and weaknesses and help

72
00:02:21,440 --> 00:02:23,680
people write better code and then we

73
00:02:23,680 --> 00:02:25,440
also do fundamental research we end up

74
00:02:25,440 --> 00:02:28,160
getting contracts with darpa the army

75
00:02:28,160 --> 00:02:31,040
the air force the navy to fundamentally

76
00:02:31,040 --> 00:02:33,200
advance the field of computer science

77
00:02:33,200 --> 00:02:35,280
and write tools and develop techniques

78
00:02:35,280 --> 00:02:38,400
that can make software better

79
00:02:38,400 --> 00:02:39,840
all of these end up combining really

80
00:02:39,840 --> 00:02:40,720
well

81
00:02:40,720 --> 00:02:42,400
in this weird blockchain space which

82
00:02:42,400 --> 00:02:44,160
you'll heard why

83
00:02:44,160 --> 00:02:47,680
so ethereum if you don't know

84
00:02:47,680 --> 00:02:50,160
ethereum is a system that lets you write

85
00:02:50,160 --> 00:02:51,599
smart contracts

86
00:02:51,599 --> 00:02:53,280
uh there are these little autonomous

87
00:02:53,280 --> 00:02:56,160
finance bots that receive transactions

88
00:02:56,160 --> 00:02:58,159
and they manipulate global state that's

89
00:02:58,159 --> 00:03:00,080
essentially what they are

90
00:03:00,080 --> 00:03:01,440
so

91
00:03:01,440 --> 00:03:04,319
it has a bit of a reputation right uh

92
00:03:04,319 --> 00:03:06,480
there are tiny little programs that

93
00:03:06,480 --> 00:03:08,319
evolve in consensus you can do really

94
00:03:08,319 --> 00:03:10,159
complex financial activities with them

95
00:03:10,159 --> 00:03:12,480
like uh create tokens and do credit

96
00:03:12,480 --> 00:03:14,239
default swaps and you can integrate them

97
00:03:14,239 --> 00:03:15,840
into browsers

98
00:03:15,840 --> 00:03:17,200
but they're built with the shittiest

99
00:03:17,200 --> 00:03:18,640
version of javascript that you could

100
00:03:18,640 --> 00:03:20,480
ever design

101
00:03:20,480 --> 00:03:22,640
um and the community itself is not so

102
00:03:22,640 --> 00:03:24,000
into security

103
00:03:24,000 --> 00:03:26,319
so most the time they get hacked and

104
00:03:26,319 --> 00:03:28,560
it's for huge amounts of money

105
00:03:28,560 --> 00:03:30,000
so you can see this is a quote from a

106
00:03:30,000 --> 00:03:31,440
team that got hacked

107
00:03:31,440 --> 00:03:33,360
uh and they they asked you know hey why

108
00:03:33,360 --> 00:03:34,799
did you get hacked like what did you do

109
00:03:34,799 --> 00:03:36,480
to not get hacked and their answers well

110
00:03:36,480 --> 00:03:38,239
you know a month ago

111
00:03:38,239 --> 00:03:39,760
i asked my team member to reach out to

112
00:03:39,760 --> 00:03:41,840
somebody for auditing but we uh

113
00:03:41,840 --> 00:03:44,080
kind of forgot like as we approach

114
00:03:44,080 --> 00:03:46,000
launch and we push back the date a few

115
00:03:46,000 --> 00:03:47,519
times it just never really popped into

116
00:03:47,519 --> 00:03:48,560
our head and

117
00:03:48,560 --> 00:03:50,480
we never audited so we just kind of

118
00:03:50,480 --> 00:03:51,760
forgot and then we got hacked we lost

119
00:03:51,760 --> 00:03:53,120
all our money it's like that's the

120
00:03:53,120 --> 00:03:54,879
starting point right like this is the

121
00:03:54,879 --> 00:03:57,920
field that you're all reading about

122
00:03:57,920 --> 00:03:59,200
um

123
00:03:59,200 --> 00:04:00,560
internally you know the way that this

124
00:04:00,560 --> 00:04:02,159
stuff works

125
00:04:02,159 --> 00:04:04,000
is that it's a it's a shared global

126
00:04:04,000 --> 00:04:06,080
computer right so there are people

127
00:04:06,080 --> 00:04:08,560
with the ability to send inputs to

128
00:04:08,560 --> 00:04:10,319
contracts which are

129
00:04:10,319 --> 00:04:12,560
finance plots on the right

130
00:04:12,560 --> 00:04:14,319
and the bots are only different because

131
00:04:14,319 --> 00:04:15,599
they have code processing the

132
00:04:15,599 --> 00:04:17,918
transaction where the people just have a

133
00:04:17,918 --> 00:04:19,358
human

134
00:04:19,358 --> 00:04:20,798
clicking the buttons

135
00:04:20,798 --> 00:04:22,320
um the neat things about it are that you

136
00:04:22,320 --> 00:04:24,080
can see every transaction that happens

137
00:04:24,080 --> 00:04:26,479
the whole computer thing is transparent

138
00:04:26,479 --> 00:04:27,680
and the other neat thing is that you can

139
00:04:27,680 --> 00:04:29,280
send input

140
00:04:29,280 --> 00:04:32,080
from a person's wallet to any finance

141
00:04:32,080 --> 00:04:33,759
bot anywhere

142
00:04:33,759 --> 00:04:35,360
and there's like nothing that anyone can

143
00:04:35,360 --> 00:04:36,639
do to stop

144
00:04:36,639 --> 00:04:38,240
any contractor account

145
00:04:38,240 --> 00:04:39,759
it's very fun

146
00:04:39,759 --> 00:04:40,479
um

147
00:04:40,479 --> 00:04:42,560
the whole the finance bots the program

148
00:04:42,560 --> 00:04:45,040
this language called solidity uh which

149
00:04:45,040 --> 00:04:47,199
is targeted for like javascript

150
00:04:47,199 --> 00:04:49,600
developers that started out with node or

151
00:04:49,600 --> 00:04:51,360
or web developers

152
00:04:51,360 --> 00:04:54,080
um because the field is really desperate

153
00:04:54,080 --> 00:04:56,000
for developers developers developers and

154
00:04:56,000 --> 00:04:57,680
that seemed to be the easiest way to get

155
00:04:57,680 --> 00:04:59,199
them

156
00:04:59,199 --> 00:05:00,639
um it's only a few years old first

157
00:05:00,639 --> 00:05:02,320
languages like sequels plus so solidity

158
00:05:02,320 --> 00:05:03,919
came around when ethereum did ethereum

159
00:05:03,919 --> 00:05:08,560
was 20 13 14. i can't remember

160
00:05:08,560 --> 00:05:09,680
so there are

161
00:05:09,680 --> 00:05:11,280
languages like cpus plus or whatever

162
00:05:11,280 --> 00:05:14,160
that have been around for 40 years

163
00:05:14,160 --> 00:05:15,280
uh but

164
00:05:15,280 --> 00:05:16,240
they

165
00:05:16,240 --> 00:05:18,240
it it

166
00:05:18,240 --> 00:05:20,639
solidity has kind of like

167
00:05:20,639 --> 00:05:23,280
taken a lot of modern learnings about uh

168
00:05:23,280 --> 00:05:25,919
security even versus a language like c

169
00:05:25,919 --> 00:05:27,759
and throwing them out the window

170
00:05:27,759 --> 00:05:28,880
um

171
00:05:28,880 --> 00:05:31,199
like they unexpectedly change the order

172
00:05:31,199 --> 00:05:34,160
of operations right like the the ability

173
00:05:34,160 --> 00:05:36,080
to take like two numbers and add them

174
00:05:36,080 --> 00:05:38,479
together or whatever like that is

175
00:05:38,479 --> 00:05:39,680
different

176
00:05:39,680 --> 00:05:41,919
in solidity than it is in every other

177
00:05:41,919 --> 00:05:43,360
computer language you have ever learned

178
00:05:43,360 --> 00:05:44,240
to code

179
00:05:44,240 --> 00:05:45,600
i don't know why

180
00:05:45,600 --> 00:05:48,479
uh but solidity as a whole is kind of a

181
00:05:48,479 --> 00:05:50,960
language that has evolved

182
00:05:50,960 --> 00:05:53,440
rather than one that has been designed

183
00:05:53,440 --> 00:05:55,280
um it doesn't really have a good sense

184
00:05:55,280 --> 00:05:56,880
of like where it's where it is and where

185
00:05:56,880 --> 00:05:58,639
it's going it's just like

186
00:05:58,639 --> 00:06:01,280
got cobbled together

187
00:06:01,280 --> 00:06:02,319
um

188
00:06:02,319 --> 00:06:04,720
and if you think that was bad right

189
00:06:04,720 --> 00:06:06,080
it actually is worse than what i'm

190
00:06:06,080 --> 00:06:08,639
describing so here are like two little

191
00:06:08,639 --> 00:06:10,880
code snippets that i like to use to give

192
00:06:10,880 --> 00:06:12,400
an example of why this language is so

193
00:06:12,400 --> 00:06:15,120
bad so the the for loop

194
00:06:15,120 --> 00:06:16,400
on the top

195
00:06:16,400 --> 00:06:18,840
uh overflows if

196
00:06:18,840 --> 00:06:21,360
i the foo has any greater than 32

197
00:06:21,360 --> 00:06:22,319
elements

198
00:06:22,319 --> 00:06:25,600
uh that's because var gets declared as

199
00:06:25,600 --> 00:06:26,800
eight bits

200
00:06:26,800 --> 00:06:28,880
uh so don't use var when you declare a

201
00:06:28,880 --> 00:06:30,960
specific type uh or else you will have

202
00:06:30,960 --> 00:06:32,479
catastrophic issues for seemingly

203
00:06:32,479 --> 00:06:33,919
perfect code

204
00:06:33,919 --> 00:06:35,360
and then the one on the bottom is what

205
00:06:35,360 --> 00:06:36,960
the compiler produces when you try to

206
00:06:36,960 --> 00:06:37,680
use

207
00:06:37,680 --> 00:06:38,800
the number

208
00:06:38,800 --> 00:06:40,560
uh

209
00:06:40,560 --> 00:06:41,520
uh

210
00:06:41,520 --> 00:06:43,680
whenever you try to use like um

211
00:06:43,680 --> 00:06:45,840
zero or something it just takes like

212
00:06:45,840 --> 00:06:48,160
zero and exponentiates up to 256 for

213
00:06:48,160 --> 00:06:50,479
like absolutely no reason at all

214
00:06:50,479 --> 00:06:52,560
um so a regular compiler would obviously

215
00:06:52,560 --> 00:06:54,440
just optimize those things out

216
00:06:54,440 --> 00:06:56,560
instantaneously and just give you the

217
00:06:56,560 --> 00:06:58,319
value that you're looking for but you

218
00:06:58,319 --> 00:06:59,280
know we're dealing with billions of

219
00:06:59,280 --> 00:07:00,960
dollars here so of course the compiler

220
00:07:00,960 --> 00:07:03,039
does not do that

221
00:07:03,039 --> 00:07:05,039
there's no consequences whatsoever for a

222
00:07:05,039 --> 00:07:07,759
poorly functioning compiler

223
00:07:07,759 --> 00:07:09,919
and the language itself i i kind of

224
00:07:09,919 --> 00:07:11,840
alluded to this but they've managed to

225
00:07:11,840 --> 00:07:14,880
reinvent every vulnerability class that

226
00:07:14,880 --> 00:07:16,479
has been eliminated

227
00:07:16,479 --> 00:07:18,160
from modern languages

228
00:07:18,160 --> 00:07:20,240
no older references are exploitable

229
00:07:20,240 --> 00:07:22,400
conditions in this language there is no

230
00:07:22,400 --> 00:07:23,919
other language invented in the last 10

231
00:07:23,919 --> 00:07:26,080
years that has exploitable null

232
00:07:26,080 --> 00:07:27,360
dereferences

233
00:07:27,360 --> 00:07:29,599
right so an older reference that's when

234
00:07:29,599 --> 00:07:31,680
you access like what's at zero and what

235
00:07:31,680 --> 00:07:33,280
happens to be at zero is the owner

236
00:07:33,280 --> 00:07:34,960
information for contract so you can do

237
00:07:34,960 --> 00:07:36,319
an older reference you can change the

238
00:07:36,319 --> 00:07:38,400
owner of the contract cash it out so

239
00:07:38,400 --> 00:07:40,000
it's not only exploitable but it's

240
00:07:40,000 --> 00:07:42,080
maximally exploitable so you can steal

241
00:07:42,080 --> 00:07:43,520
all the money

242
00:07:43,520 --> 00:07:45,039
based on that

243
00:07:45,039 --> 00:07:48,479
so it's just completely psychotic right

244
00:07:48,479 --> 00:07:49,360
okay

245
00:07:49,360 --> 00:07:51,520
but let me drag you back down to earth

246
00:07:51,520 --> 00:07:52,800
uh

247
00:07:52,800 --> 00:07:55,039
the expectations here are that the field

248
00:07:55,039 --> 00:07:57,440
will be littered with easy bugs that

249
00:07:57,440 --> 00:07:59,039
analysis of this would be really tricky

250
00:07:59,039 --> 00:08:00,639
it's this weird arcane language there's

251
00:08:00,639 --> 00:08:02,639
this goofy stack machine thing

252
00:08:02,639 --> 00:08:03,919
um you know the language doesn't make

253
00:08:03,919 --> 00:08:06,319
any sense so confidence in these systems

254
00:08:06,319 --> 00:08:08,080
will be impossible right that's the

255
00:08:08,080 --> 00:08:10,639
expectation when you talk to security

256
00:08:10,639 --> 00:08:12,319
engineers everybody always says well if

257
00:08:12,319 --> 00:08:13,680
we could just fix the languages and the

258
00:08:13,680 --> 00:08:15,599
compilers and the frameworks there

259
00:08:15,599 --> 00:08:17,759
wouldn't be any foot guns for us to step

260
00:08:17,759 --> 00:08:20,720
on and all our code would be secure

261
00:08:20,720 --> 00:08:21,599
but

262
00:08:21,599 --> 00:08:23,840
the reality is that it's actually far

263
00:08:23,840 --> 00:08:26,160
different than that i encounter some of

264
00:08:26,160 --> 00:08:28,000
the most secure actually not the most

265
00:08:28,000 --> 00:08:31,120
secure code that i have in my career

266
00:08:31,120 --> 00:08:33,679
while reviewing solidity

267
00:08:33,679 --> 00:08:36,399
and it's insane because in

268
00:08:36,399 --> 00:08:37,679
despite

269
00:08:37,679 --> 00:08:39,919
all of the extraordinarily insecure

270
00:08:39,919 --> 00:08:41,919
compilers and languages and frameworks

271
00:08:41,919 --> 00:08:43,360
of all the foundation upon which

272
00:08:43,360 --> 00:08:45,839
everything is built is trash

273
00:08:45,839 --> 00:08:48,000
but the code comes out as inherently

274
00:08:48,000 --> 00:08:51,040
testable so they fix it and post

275
00:08:51,040 --> 00:08:53,360
and with that extremely testable code we

276
00:08:53,360 --> 00:08:54,880
get clients of ours that come in the

277
00:08:54,880 --> 00:08:57,360
door with high coverage property test

278
00:08:57,360 --> 00:08:58,399
suites

279
00:08:58,399 --> 00:09:00,640
with symbolic execution rigorously

280
00:09:00,640 --> 00:09:03,440
applied to an entire code base there is

281
00:09:03,440 --> 00:09:06,480
even a robust network of suppliers for

282
00:09:06,480 --> 00:09:09,040
symbolic execution as a service there's

283
00:09:09,040 --> 00:09:10,720
like six different vendors that you can

284
00:09:10,720 --> 00:09:12,320
choose between

285
00:09:12,320 --> 00:09:13,920
that is not something you can do when

286
00:09:13,920 --> 00:09:15,519
you're developing software on any other

287
00:09:15,519 --> 00:09:16,480
language

288
00:09:16,480 --> 00:09:17,839
right

289
00:09:17,839 --> 00:09:19,600
so

290
00:09:19,600 --> 00:09:21,680
this

291
00:09:21,680 --> 00:09:22,640
um

292
00:09:22,640 --> 00:09:24,000
you know having everybody come in with a

293
00:09:24,000 --> 00:09:26,000
suite of correctness tests having

294
00:09:26,000 --> 00:09:27,279
everybody

295
00:09:27,279 --> 00:09:30,720
already adopted rigorous static analysis

296
00:09:30,720 --> 00:09:33,360
um having everybody having adopted

297
00:09:33,360 --> 00:09:35,440
property testing that is kind of what we

298
00:09:35,440 --> 00:09:37,200
want the rest of the industry to look at

299
00:09:37,200 --> 00:09:39,600
so despite all of these terrible awful

300
00:09:39,600 --> 00:09:42,399
parts of ethereum there's a lot here

301
00:09:42,399 --> 00:09:44,080
that we actually want to copy that we

302
00:09:44,080 --> 00:09:45,760
want to understand how it evolved so

303
00:09:45,760 --> 00:09:47,279
that we can hopefully replicate it in

304
00:09:47,279 --> 00:09:50,000
other places

305
00:09:50,000 --> 00:09:51,360
um

306
00:09:51,360 --> 00:09:52,240
now

307
00:09:52,240 --> 00:09:53,519
like

308
00:09:53,519 --> 00:09:55,200
you could ask why and i think a lot of

309
00:09:55,200 --> 00:09:56,720
people will give you very naive answers

310
00:09:56,720 --> 00:09:59,040
why they can say oh code is law

311
00:09:59,040 --> 00:10:01,040
that like uh you know you need to be

312
00:10:01,040 --> 00:10:03,120
right the first time and

313
00:10:03,120 --> 00:10:04,800
uh there's no recourse if you're hacked

314
00:10:04,800 --> 00:10:07,200
and like that's fine but i don't think

315
00:10:07,200 --> 00:10:09,440
that's the case that's not what what

316
00:10:09,440 --> 00:10:11,279
created the system that i'm that i'm

317
00:10:11,279 --> 00:10:12,320
reviewing

318
00:10:12,320 --> 00:10:13,760
um people also said that because it's

319
00:10:13,760 --> 00:10:16,720
worth a lot of money that it it's it

320
00:10:16,720 --> 00:10:18,320
evolved in this way that it's inherently

321
00:10:18,320 --> 00:10:19,839
testable that lots of resources have

322
00:10:19,839 --> 00:10:22,320
been spent securing it but you know

323
00:10:22,320 --> 00:10:24,160
iphones are in a billion people's

324
00:10:24,160 --> 00:10:25,920
pockets across the globe and manage

325
00:10:25,920 --> 00:10:27,760
extraordinarily sensitive information on

326
00:10:27,760 --> 00:10:29,920
behalf of all of you apple has invested

327
00:10:29,920 --> 00:10:32,240
billions of dollars in making them

328
00:10:32,240 --> 00:10:35,120
secure but they are much much less so

329
00:10:35,120 --> 00:10:37,360
than a good smart contract so there's a

330
00:10:37,360 --> 00:10:39,279
lot of systems that are out there that

331
00:10:39,279 --> 00:10:41,040
actually do have more money invested

332
00:10:41,040 --> 00:10:43,440
that carry more risk but that end up in

333
00:10:43,440 --> 00:10:44,800
a worse state

334
00:10:44,800 --> 00:10:46,880
so the outcomes here for the small

335
00:10:46,880 --> 00:10:48,480
amount of money that actually has been

336
00:10:48,480 --> 00:10:50,640
applied to make them safe are actually

337
00:10:50,640 --> 00:10:52,959
phenomenally good

338
00:10:52,959 --> 00:10:54,240
um

339
00:10:54,240 --> 00:10:56,160
so

340
00:10:56,160 --> 00:10:58,560
uh the reason why i

341
00:10:58,560 --> 00:10:59,839
i don't know if anybody has heard this

342
00:10:59,839 --> 00:11:01,120
joke but there's there's this old joke

343
00:11:01,120 --> 00:11:02,800
about a dairy farmer who's trying to

344
00:11:02,800 --> 00:11:04,720
keep up with the agri conglomerate down

345
00:11:04,720 --> 00:11:06,320
the road and he asks a physicist for

346
00:11:06,320 --> 00:11:08,480
help physicist goes back to his lab and

347
00:11:08,480 --> 00:11:09,120
he

348
00:11:09,120 --> 00:11:10,720
works really hard he comes back weeks

349
00:11:10,720 --> 00:11:12,720
later and says he has a solution

350
00:11:12,720 --> 00:11:15,040
but it only works on spherical cows in a

351
00:11:15,040 --> 00:11:16,480
vacuum

352
00:11:16,480 --> 00:11:18,720
right because that's how physicists are

353
00:11:18,720 --> 00:11:19,920
um

354
00:11:19,920 --> 00:11:21,920
that is generally how reading papers

355
00:11:21,920 --> 00:11:24,959
from like acm ccss work out when you

356
00:11:24,959 --> 00:11:28,079
read these academic ivory tower papers

357
00:11:28,079 --> 00:11:29,920
they're all dealing with spherical cows

358
00:11:29,920 --> 00:11:31,519
they always deal with like

359
00:11:31,519 --> 00:11:34,560
core utils right like every single damn

360
00:11:34,560 --> 00:11:36,880
paper has found all the vulnerabilities

361
00:11:36,880 --> 00:11:39,760
that exist in the ls command right

362
00:11:39,760 --> 00:11:41,120
wonderful

363
00:11:41,120 --> 00:11:42,399
um

364
00:11:42,399 --> 00:11:45,440
but the weird thing is that on aetherium

365
00:11:45,440 --> 00:11:48,800
they only support spherical cows that is

366
00:11:48,800 --> 00:11:50,399
everything you deal with everything you

367
00:11:50,399 --> 00:11:52,720
deal with is a spherical cow

368
00:11:52,720 --> 00:11:55,200
so in reality it turns into this field

369
00:11:55,200 --> 00:11:57,040
where um

370
00:11:57,040 --> 00:11:58,240
the

371
00:11:58,240 --> 00:12:00,320
spherical cows the extremely limited run

372
00:12:00,320 --> 00:12:01,279
times

373
00:12:01,279 --> 00:12:03,600
are the perfect opportunity to apply

374
00:12:03,600 --> 00:12:06,160
software tested research

375
00:12:06,160 --> 00:12:08,079
so the rubber meets the road in this

376
00:12:08,079 --> 00:12:12,399
field in a way unlike any other

377
00:12:12,399 --> 00:12:14,480
uh it's

378
00:12:14,480 --> 00:12:16,800
yeah it's really weird

379
00:12:16,800 --> 00:12:19,519
okay so let me go backwards a little bit

380
00:12:19,519 --> 00:12:20,480
we'll do a little computer science

381
00:12:20,480 --> 00:12:21,440
lesson

382
00:12:21,440 --> 00:12:23,120
um

383
00:12:23,120 --> 00:12:24,480
there's some really contentious stuff in

384
00:12:24,480 --> 00:12:26,160
this section but we will have a

385
00:12:26,160 --> 00:12:28,320
nerdfight about it later at the bar uh

386
00:12:28,320 --> 00:12:30,800
it is a keynote so chill

387
00:12:30,800 --> 00:12:32,000
[Music]

388
00:12:32,000 --> 00:12:34,320
what is a program all right abstract

389
00:12:34,320 --> 00:12:35,680
what is a program

390
00:12:35,680 --> 00:12:38,000
so uh a program

391
00:12:38,000 --> 00:12:40,320
is essentially like

392
00:12:40,320 --> 00:12:42,320
well let's not even say that i'll try to

393
00:12:42,320 --> 00:12:44,079
avoid the harshest of fights here but

394
00:12:44,079 --> 00:12:45,440
basically

395
00:12:45,440 --> 00:12:47,120
input changes the way a program behaves

396
00:12:47,120 --> 00:12:48,639
there's some input that comes in which

397
00:12:48,639 --> 00:12:49,600
i've

398
00:12:49,600 --> 00:12:51,920
defined as this little grid uh those are

399
00:12:51,920 --> 00:12:53,680
all the different potential inputs that

400
00:12:53,680 --> 00:12:55,360
can go in the red one is the one that

401
00:12:55,360 --> 00:12:57,519
we've chosen and then it hits the state

402
00:12:57,519 --> 00:12:59,760
machine where stuff bounces around or

403
00:12:59,760 --> 00:13:02,399
not and then it exits right that is a

404
00:13:02,399 --> 00:13:03,920
program to me

405
00:13:03,920 --> 00:13:05,120
um

406
00:13:05,120 --> 00:13:06,959
so the input state could be a lot of

407
00:13:06,959 --> 00:13:08,000
different things it could be like

408
00:13:08,000 --> 00:13:09,360
standard and it could be networks it

409
00:13:09,360 --> 00:13:10,720
could be um

410
00:13:10,720 --> 00:13:12,720
uh you know whatever different kinds of

411
00:13:12,720 --> 00:13:14,880
input um

412
00:13:14,880 --> 00:13:16,560
and maybe the program stops and maybe

413
00:13:16,560 --> 00:13:18,000
doesn't maybe it gets stuck in a little

414
00:13:18,000 --> 00:13:18,800
loop

415
00:13:18,800 --> 00:13:20,480
uh but most of the time let's just say

416
00:13:20,480 --> 00:13:22,079
false

417
00:13:22,079 --> 00:13:22,959
so

418
00:13:22,959 --> 00:13:24,720
in that case

419
00:13:24,720 --> 00:13:27,200
um if you wanted to then as simply

420
00:13:27,200 --> 00:13:28,720
define security security is the

421
00:13:28,720 --> 00:13:30,639
combination of two things

422
00:13:30,639 --> 00:13:31,600
it's

423
00:13:31,600 --> 00:13:34,639
say what

424
00:13:34,639 --> 00:13:36,240
oh crap

425
00:13:36,240 --> 00:13:38,079
[Music]

426
00:13:38,079 --> 00:13:40,638
shut that off

427
00:13:42,399 --> 00:13:44,240
thank you

428
00:13:44,240 --> 00:13:45,519
um

429
00:13:45,519 --> 00:13:47,279
so security's really combination of two

430
00:13:47,279 --> 00:13:49,120
things you're trying to find uh the

431
00:13:49,120 --> 00:13:51,360
states that are bad and the inputs that

432
00:13:51,360 --> 00:13:53,760
cause them that is it that is security

433
00:13:53,760 --> 00:13:55,760
in this in this um

434
00:13:55,760 --> 00:13:57,279
version of things

435
00:13:57,279 --> 00:13:58,480
uh

436
00:13:58,480 --> 00:14:00,160
for instance like an assert will tell

437
00:14:00,160 --> 00:14:02,480
you that you encounter something bad but

438
00:14:02,480 --> 00:14:04,320
it won't tell you the input that

439
00:14:04,320 --> 00:14:06,399
reaches it right so

440
00:14:06,399 --> 00:14:08,240
as um

441
00:14:08,240 --> 00:14:10,480
kind of uh we have constrained time here

442
00:14:10,480 --> 00:14:12,399
uh let's only dig into number one we're

443
00:14:12,399 --> 00:14:14,240
gonna talk about inputs because inputs

444
00:14:14,240 --> 00:14:15,600
are something that typically an after

445
00:14:15,600 --> 00:14:18,320
the fact security engineer can control

446
00:14:18,320 --> 00:14:20,079
whereas usually as a security engineer

447
00:14:20,079 --> 00:14:21,839
you can't go in and like

448
00:14:21,839 --> 00:14:23,600
rewrite the whole program to figure out

449
00:14:23,600 --> 00:14:26,000
and change the way that it handles state

450
00:14:26,000 --> 00:14:28,399
but you can usually

451
00:14:28,399 --> 00:14:30,079
test it for input which is why things

452
00:14:30,079 --> 00:14:33,199
like buzzing are such a big deal

453
00:14:33,199 --> 00:14:36,079
so again simplified uh this is kind of

454
00:14:36,079 --> 00:14:38,320
what testing looks like in this simple

455
00:14:38,320 --> 00:14:39,519
simplification of security and

456
00:14:39,519 --> 00:14:42,000
simplification programs on the left

457
00:14:42,000 --> 00:14:44,399
we've got like unit testing and

458
00:14:44,399 --> 00:14:46,560
uh fuzzing buzzing and like other kinds

459
00:14:46,560 --> 00:14:48,560
of testing where you pop out holes in

460
00:14:48,560 --> 00:14:50,639
the input as fast as you can possibly do

461
00:14:50,639 --> 00:14:51,440
that

462
00:14:51,440 --> 00:14:53,600
um so that would be things like

463
00:14:53,600 --> 00:14:56,959
uh or rather in the unrestricted case

464
00:14:56,959 --> 00:14:58,399
that's kind of like where a program

465
00:14:58,399 --> 00:15:00,720
starts is you might have some unit tests

466
00:15:00,720 --> 00:15:03,120
they exercise a few of the inputs uh

467
00:15:03,120 --> 00:15:04,880
sometimes there are unexpected inputs

468
00:15:04,880 --> 00:15:07,040
that are off the place that you expect

469
00:15:07,040 --> 00:15:08,800
inputs to come from like environmental

470
00:15:08,800 --> 00:15:11,040
stuff sometimes forget

471
00:15:11,040 --> 00:15:13,279
uh system calls and can sometimes be

472
00:15:13,279 --> 00:15:14,560
controllable

473
00:15:14,560 --> 00:15:16,000
those sorts of things

474
00:15:16,000 --> 00:15:17,440
um and that's what you're dealing with

475
00:15:17,440 --> 00:15:19,680
when you're given a program and

476
00:15:19,680 --> 00:15:21,600
told to make it secure

477
00:15:21,600 --> 00:15:23,120
on the other hand

478
00:15:23,120 --> 00:15:24,639
there are two techniques that you've got

479
00:15:24,639 --> 00:15:27,600
to secure this right option one is you

480
00:15:27,600 --> 00:15:30,320
can reduce the size of allowable input

481
00:15:30,320 --> 00:15:31,920
uh so those are things like having a

482
00:15:31,920 --> 00:15:33,839
type language versus static one that

483
00:15:33,839 --> 00:15:35,519
means that there's a lot of less kinds

484
00:15:35,519 --> 00:15:36,800
of input that can be given to your

485
00:15:36,800 --> 00:15:39,440
program or you can delete code or you

486
00:15:39,440 --> 00:15:40,480
could

487
00:15:40,480 --> 00:15:42,800
separate privileges you could carve out

488
00:15:42,800 --> 00:15:45,040
huge amounts of code and lock it inside

489
00:15:45,040 --> 00:15:46,240
of a sandbox somewhere that's

490
00:15:46,240 --> 00:15:48,399
unreachable from the outside of the

491
00:15:48,399 --> 00:15:49,519
program

492
00:15:49,519 --> 00:15:51,199
on the other hand

493
00:15:51,199 --> 00:15:53,040
we've got you could test your input and

494
00:15:53,040 --> 00:15:54,639
this is what most people fall back to

495
00:15:54,639 --> 00:15:56,240
because they don't have the ability to

496
00:15:56,240 --> 00:15:57,920
radically change the way a program works

497
00:15:57,920 --> 00:16:00,320
when they are doing an audit of it

498
00:16:00,320 --> 00:16:01,360
so

499
00:16:01,360 --> 00:16:03,040
you might write unit tests that pop out

500
00:16:03,040 --> 00:16:05,360
individual boxes you might write fuzz

501
00:16:05,360 --> 00:16:07,440
tests that populate large sections of it

502
00:16:07,440 --> 00:16:09,680
randomly or you might write

503
00:16:09,680 --> 00:16:11,040
formal tests

504
00:16:11,040 --> 00:16:12,560
you might use techniques like symbolic

505
00:16:12,560 --> 00:16:15,199
execution that will wipe out an entire

506
00:16:15,199 --> 00:16:17,839
row or a column or quadrant and make it

507
00:16:17,839 --> 00:16:20,160
all red

508
00:16:20,160 --> 00:16:22,560
so side note mitigations don't fix code

509
00:16:22,560 --> 00:16:24,240
they just limit the impact of failure if

510
00:16:24,240 --> 00:16:25,920
you're asking where those live

511
00:16:25,920 --> 00:16:27,440
uh but

512
00:16:27,440 --> 00:16:28,959
with this in mind let's talk a little

513
00:16:28,959 --> 00:16:30,959
bit deeper

514
00:16:30,959 --> 00:16:32,480
so there's a maturity process that i

515
00:16:32,480 --> 00:16:33,759
think people go through when they write

516
00:16:33,759 --> 00:16:36,800
software the first step is they get this

517
00:16:36,800 --> 00:16:40,160
very like young kid college guy kind of

518
00:16:40,160 --> 00:16:42,079
episode about code or actually this is

519
00:16:42,079 --> 00:16:43,519
really the pointy haired boss version

520
00:16:43,519 --> 00:16:44,480
too

521
00:16:44,480 --> 00:16:46,480
uh where they want to write secure code

522
00:16:46,480 --> 00:16:47,680
so they say well we're going to train

523
00:16:47,680 --> 00:16:49,199
all our developers we're going gonna do

524
00:16:49,199 --> 00:16:51,279
tons of code reviews and like everyone's

525
00:16:51,279 --> 00:16:52,800
gonna be the smartest person on the team

526
00:16:52,800 --> 00:16:54,720
or ever created and we're gonna just

527
00:16:54,720 --> 00:16:56,800
understand tons about c plus boston we

528
00:16:56,800 --> 00:16:58,720
just won't write any bugs because we try

529
00:16:58,720 --> 00:17:00,480
really hard that's basically what it

530
00:17:00,480 --> 00:17:02,880
comes down to and it absolutely does not

531
00:17:02,880 --> 00:17:05,119
work it's it's kind of like this have

532
00:17:05,119 --> 00:17:06,959
your existing programmers work harder in

533
00:17:06,959 --> 00:17:09,119
the same amount of time like computers

534
00:17:09,119 --> 00:17:11,359
are extraordinarily complex machines and

535
00:17:11,359 --> 00:17:13,679
the ability for a single human to even

536
00:17:13,679 --> 00:17:15,280
manage all the operations going on in

537
00:17:15,280 --> 00:17:16,959
their head for what they're writing is

538
00:17:16,959 --> 00:17:21,039
very limited so um it doesn't work right

539
00:17:21,039 --> 00:17:23,359
phase one is well maybe we should test a

540
00:17:23,359 --> 00:17:24,640
few things like what do we want the

541
00:17:24,640 --> 00:17:27,359
program to do let's make it do that and

542
00:17:27,359 --> 00:17:29,360
see if the outcomes are what we wanted

543
00:17:29,360 --> 00:17:31,280
and that's kind of unit testing

544
00:17:31,280 --> 00:17:32,960
um so they have the input space there's

545
00:17:32,960 --> 00:17:34,880
some points on the grid and the unit

546
00:17:34,880 --> 00:17:37,280
tests only test things that developers

547
00:17:37,280 --> 00:17:39,600
know what they might not know like

548
00:17:39,600 --> 00:17:40,880
there's not

549
00:17:40,880 --> 00:17:42,720
uh that many of them compared to what

550
00:17:42,720 --> 00:17:44,160
the program can do

551
00:17:44,160 --> 00:17:46,320
so developers are kind of blind to what

552
00:17:46,320 --> 00:17:47,600
they don't know

553
00:17:47,600 --> 00:17:49,360
uh they're only testing things that they

554
00:17:49,360 --> 00:17:50,799
know to test

555
00:17:50,799 --> 00:17:52,160
um

556
00:17:52,160 --> 00:17:54,400
so this is kind of like

557
00:17:54,400 --> 00:17:56,799
the better part of most software shops

558
00:17:56,799 --> 00:17:58,880
if you are at a developer conference

559
00:17:58,880 --> 00:18:00,799
then a point of pride might be like hey

560
00:18:00,799 --> 00:18:02,400
like how are you testing your software

561
00:18:02,400 --> 00:18:04,799
like how much coverage do you have and

562
00:18:04,799 --> 00:18:06,400
developers will talk to you as a point

563
00:18:06,400 --> 00:18:08,960
of private i have 80 coverage and it's

564
00:18:08,960 --> 00:18:11,039
like so wonderful that my job does this

565
00:18:11,039 --> 00:18:12,720
they'll put it on a job advertisement

566
00:18:12,720 --> 00:18:14,960
like if you apply for a job they'll say

567
00:18:14,960 --> 00:18:18,080
benefits has tests right like that's how

568
00:18:18,080 --> 00:18:19,760
important this stuff is to like regular

569
00:18:19,760 --> 00:18:22,320
people writing regular code

570
00:18:22,320 --> 00:18:24,799
um but but like for obvious reasons

571
00:18:24,799 --> 00:18:26,960
asking a developer to enumerate all the

572
00:18:26,960 --> 00:18:29,039
bugs in the program and then write tests

573
00:18:29,039 --> 00:18:30,960
for them is not a good way to write your

574
00:18:30,960 --> 00:18:33,440
software

575
00:18:33,440 --> 00:18:35,120
so then you've got people that progress

576
00:18:35,120 --> 00:18:36,559
to phase two which is fuzzing they're

577
00:18:36,559 --> 00:18:38,000
like huh

578
00:18:38,000 --> 00:18:39,919
so um

579
00:18:39,919 --> 00:18:41,520
everyone that uses these they say

580
00:18:41,520 --> 00:18:43,520
they're amazing right i've never talked

581
00:18:43,520 --> 00:18:45,280
to a person if you give a developer afl

582
00:18:45,280 --> 00:18:47,280
and let them use it for five minutes

583
00:18:47,280 --> 00:18:49,440
nobody ever comes back and says i tried

584
00:18:49,440 --> 00:18:50,799
these and they sucked

585
00:18:50,799 --> 00:18:52,640
right they always come back and they say

586
00:18:52,640 --> 00:18:55,520
our lord and savior afl like we will now

587
00:18:55,520 --> 00:18:57,039
bow to this program that i have

588
00:18:57,039 --> 00:18:58,080
discovered

589
00:18:58,080 --> 00:19:00,320
is extraordinarily useful once they get

590
00:19:00,320 --> 00:19:01,120
here

591
00:19:01,120 --> 00:19:02,400
um it's also something that's getting a

592
00:19:02,400 --> 00:19:04,720
lot more acceptance by academics they've

593
00:19:04,720 --> 00:19:05,919
realized like hey these things get

594
00:19:05,919 --> 00:19:08,000
picked up so you can see like 30

595
00:19:08,000 --> 00:19:10,320
different versions of academic papers to

596
00:19:10,320 --> 00:19:12,559
try to optimize the test generation

597
00:19:12,559 --> 00:19:14,640
process for afl right like those are

598
00:19:14,640 --> 00:19:17,440
very popular nowadays

599
00:19:17,440 --> 00:19:19,039
um

600
00:19:19,039 --> 00:19:20,480
and then you've got the

601
00:19:20,480 --> 00:19:23,200
end game which is to test every input it

602
00:19:23,200 --> 00:19:24,960
doesn't give you perfectly correct

603
00:19:24,960 --> 00:19:26,720
software and you have to ask who

604
00:19:26,720 --> 00:19:29,360
verifies the verifier but you could just

605
00:19:29,360 --> 00:19:31,440
not be verifying uh all the inputs

606
00:19:31,440 --> 00:19:32,480
because you didn't realize what the

607
00:19:32,480 --> 00:19:34,640
total space of the input was right so

608
00:19:34,640 --> 00:19:36,640
beyond um

609
00:19:36,640 --> 00:19:39,840
uh these like limitations of the testing

610
00:19:39,840 --> 00:19:41,600
techniques and beyond like a broken

611
00:19:41,600 --> 00:19:43,840
verification tool speed sometimes you

612
00:19:43,840 --> 00:19:45,679
just get inputs that exist outside the

613
00:19:45,679 --> 00:19:47,520
space of what you expect so you still

614
00:19:47,520 --> 00:19:49,679
find bugs that's a little thing floating

615
00:19:49,679 --> 00:19:51,679
on the corner but it's still pretty good

616
00:19:51,679 --> 00:19:53,679
right it's strictly better than not

617
00:19:53,679 --> 00:19:56,320
doing anything obviously we've got far

618
00:19:56,320 --> 00:19:57,919
better coverage than any previous stage

619
00:19:57,919 --> 00:19:59,840
so this is a goal this is a place to

620
00:19:59,840 --> 00:20:01,360
work towards but

621
00:20:01,360 --> 00:20:03,360
um most people reject it as impractical

622
00:20:03,360 --> 00:20:04,799
right like i don't know of a lot of

623
00:20:04,799 --> 00:20:07,520
hackers on the flip side that would tell

624
00:20:07,520 --> 00:20:09,360
you that oh yeah like i predominantly

625
00:20:09,360 --> 00:20:11,120
use symbolic execution or i

626
00:20:11,120 --> 00:20:12,400
predominantly use abstract

627
00:20:12,400 --> 00:20:13,679
interpretation or like whatever

628
00:20:13,679 --> 00:20:15,840
technique

629
00:20:15,840 --> 00:20:17,840
um so today

630
00:20:17,840 --> 00:20:19,520
the state of the industry is that most

631
00:20:19,520 --> 00:20:21,200
people are at phase zero

632
00:20:21,200 --> 00:20:23,120
uh the people at phase one are bragging

633
00:20:23,120 --> 00:20:24,720
about it

634
00:20:24,720 --> 00:20:28,640
uh the people at phase three are

635
00:20:28,640 --> 00:20:30,799
spotted across the industry but it's not

636
00:20:30,799 --> 00:20:32,000
consistent

637
00:20:32,000 --> 00:20:33,200
at trailer bits we did a really

638
00:20:33,200 --> 00:20:35,039
interesting study where we resurrected

639
00:20:35,039 --> 00:20:37,360
the first available fuzzer ever made

640
00:20:37,360 --> 00:20:39,039
from 1989

641
00:20:39,039 --> 00:20:42,480
uh it fuzzed a bunch of linux programs

642
00:20:42,480 --> 00:20:45,760
and we got that fuzzer working again in

643
00:20:45,760 --> 00:20:48,400
uh 2019 so 30 years later

644
00:20:48,400 --> 00:20:50,159
and then we resurrected the code that

645
00:20:50,159 --> 00:20:52,240
was fuzzed in 1999 because a lot of that

646
00:20:52,240 --> 00:20:54,320
stuff is still present in modern linux

647
00:20:54,320 --> 00:20:56,799
and we ran the fuzzer again

648
00:20:56,799 --> 00:20:59,440
let me tell you how many bugs we found

649
00:20:59,440 --> 00:21:02,480
right we actually redid that for uh

650
00:21:02,480 --> 00:21:05,840
microsoft we took uh a famous microsoft

651
00:21:05,840 --> 00:21:07,440
fuzzer from

652
00:21:07,440 --> 00:21:09,520
uh what was it 1999

653
00:21:09,520 --> 00:21:11,760
and then we re-ran that on the current

654
00:21:11,760 --> 00:21:13,280
modern version of windows at the time i

655
00:21:13,280 --> 00:21:15,760
think it was windows other seven or ten

656
00:21:15,760 --> 00:21:18,480
and uh still finds bugs right so even in

657
00:21:18,480 --> 00:21:20,480
an extraordinarily rigorous shop like

658
00:21:20,480 --> 00:21:23,600
microsoft that's fully adopted in sdlc

659
00:21:23,600 --> 00:21:25,200
and applies fuzzing on every single

660
00:21:25,200 --> 00:21:26,320
little code increment that all the

661
00:21:26,320 --> 00:21:27,600
developers make

662
00:21:27,600 --> 00:21:28,400
um

663
00:21:28,400 --> 00:21:30,320
not good enough right like they are they

664
00:21:30,320 --> 00:21:33,200
are not applying it consistently so

665
00:21:33,200 --> 00:21:34,960
that brings you to phase three

666
00:21:34,960 --> 00:21:37,440
which is usually just disregarded as

667
00:21:37,440 --> 00:21:40,960
wildly impractical and nobody ever tries

668
00:21:40,960 --> 00:21:43,200
um

669
00:21:43,440 --> 00:21:45,840
now there's a reason for that

670
00:21:45,840 --> 00:21:48,640
um and the reasons for that are

671
00:21:48,640 --> 00:21:50,799
actually easy to identify

672
00:21:50,799 --> 00:21:52,480
um

673
00:21:52,480 --> 00:21:54,400
so why are we stuck the reason why we're

674
00:21:54,400 --> 00:21:56,320
stuck is that developers don't create

675
00:21:56,320 --> 00:21:58,400
testable programs

676
00:21:58,400 --> 00:22:01,039
yet the testing tools we have require

677
00:22:01,039 --> 00:22:02,640
them to be

678
00:22:02,640 --> 00:22:05,039
so all the programs that you want to use

679
00:22:05,039 --> 00:22:06,480
um

680
00:22:06,480 --> 00:22:09,120
like uh let's say

681
00:22:09,120 --> 00:22:11,120
manticore we have a symbolic execution

682
00:22:11,120 --> 00:22:14,000
toolkit that allows you to

683
00:22:14,000 --> 00:22:16,799
rigorously test software but um it can't

684
00:22:16,799 --> 00:22:18,880
model real system calls right that's

685
00:22:18,880 --> 00:22:20,400
something that i wrote

686
00:22:20,400 --> 00:22:22,000
like i can't figure out how to do you

687
00:22:22,000 --> 00:22:22,960
name

688
00:22:22,960 --> 00:22:24,880
the nice thing about blockchain software

689
00:22:24,880 --> 00:22:27,520
is that you have to make a testable by

690
00:22:27,520 --> 00:22:29,360
design so regular software is part of

691
00:22:29,360 --> 00:22:30,720
the testable

692
00:22:30,720 --> 00:22:32,880
therefore most of the testing tools just

693
00:22:32,880 --> 00:22:34,400
don't work

694
00:22:34,400 --> 00:22:36,320
so like there's a couple reasons why

695
00:22:36,320 --> 00:22:38,320
this happens so unit tests

696
00:22:38,320 --> 00:22:40,159
a lot of times when we look at programs

697
00:22:40,159 --> 00:22:41,360
that are written in like traditional

698
00:22:41,360 --> 00:22:42,400
languages

699
00:22:42,400 --> 00:22:44,080
you get a unit test but the unit test

700
00:22:44,080 --> 00:22:45,039
has like

701
00:22:45,039 --> 00:22:46,799
two-thirds of the code and the file

702
00:22:46,799 --> 00:22:48,080
creating some kind of contrived

703
00:22:48,080 --> 00:22:49,919
environment to set it up

704
00:22:49,919 --> 00:22:51,600
that's an indication that software is

705
00:22:51,600 --> 00:22:53,360
not really testable

706
00:22:53,360 --> 00:22:54,320
on the other hand there's lots of

707
00:22:54,320 --> 00:22:55,760
functions that have side effects that

708
00:22:55,760 --> 00:22:57,840
change how other functions work so if

709
00:22:57,840 --> 00:22:59,039
you have something where you can kind of

710
00:22:59,039 --> 00:23:00,480
prime the pump and you send in a few

711
00:23:00,480 --> 00:23:02,640
network packets and it changes the

712
00:23:02,640 --> 00:23:05,039
internal state that the program is in

713
00:23:05,039 --> 00:23:06,400
you're going to get different results

714
00:23:06,400 --> 00:23:08,320
testing that than the program that

715
00:23:08,320 --> 00:23:09,919
wasn't primed

716
00:23:09,919 --> 00:23:12,080
that global mutable state and the fact

717
00:23:12,080 --> 00:23:14,080
that these things are moving targets and

718
00:23:14,080 --> 00:23:15,760
have changing dependencies changing

719
00:23:15,760 --> 00:23:17,440
runtime environments changing operating

720
00:23:17,440 --> 00:23:19,360
systems

721
00:23:19,360 --> 00:23:22,240
make it a moving target to hit even when

722
00:23:22,240 --> 00:23:24,960
it's not a production application

723
00:23:24,960 --> 00:23:26,960
so at a high level uh you have really

724
00:23:26,960 --> 00:23:29,120
bad abstraction boundaries

725
00:23:29,120 --> 00:23:32,320
let me change this uh

726
00:23:32,320 --> 00:23:33,840
i can't see what i'm what i'm talking

727
00:23:33,840 --> 00:23:36,240
about

728
00:23:36,240 --> 00:23:38,640
there we go

729
00:23:38,640 --> 00:23:41,120
um so at a high level you have uh really

730
00:23:41,120 --> 00:23:43,520
bad abstraction boundaries um most

731
00:23:43,520 --> 00:23:45,679
people are like

732
00:23:45,679 --> 00:23:48,840
like maybe it's uh

733
00:23:48,840 --> 00:23:51,919
um yeah so the unix philosophy lost

734
00:23:51,919 --> 00:23:54,000
links philosophy run uh

735
00:23:54,000 --> 00:23:55,840
functional code isn't really a thing

736
00:23:55,840 --> 00:23:57,120
people aren't writing pure functions

737
00:23:57,120 --> 00:23:59,120
they're writing object-oriented code

738
00:23:59,120 --> 00:24:00,880
um people aren't really breaking

739
00:24:00,880 --> 00:24:02,799
programs into smaller ones

740
00:24:02,799 --> 00:24:04,559
uh but if you do that

741
00:24:04,559 --> 00:24:06,240
if you have smaller programs then you

742
00:24:06,240 --> 00:24:07,760
can turn integration tests into unit

743
00:24:07,760 --> 00:24:09,200
tests you can turn

744
00:24:09,200 --> 00:24:11,919
a dumb buzzer into a property-based

745
00:24:11,919 --> 00:24:14,640
testing suite if you can take a large

746
00:24:14,640 --> 00:24:16,559
program and break it down

747
00:24:16,559 --> 00:24:18,480
and clearly identify the connections

748
00:24:18,480 --> 00:24:19,919
between those different components then

749
00:24:19,919 --> 00:24:22,159
you can start to do things like um

750
00:24:22,159 --> 00:24:25,039
slightly less impossible verification

751
00:24:25,039 --> 00:24:26,480
um so

752
00:24:26,480 --> 00:24:28,159
at its heart kind of this global mutable

753
00:24:28,159 --> 00:24:29,919
state problem and the complexity of

754
00:24:29,919 --> 00:24:32,080
interactions between components is the

755
00:24:32,080 --> 00:24:35,039
root of all evil here

756
00:24:35,200 --> 00:24:36,640
the other problem that we have is that

757
00:24:36,640 --> 00:24:38,000
software isn't generally made to be

758
00:24:38,000 --> 00:24:40,400
reproducible i'm not reproducible in

759
00:24:40,400 --> 00:24:43,200
terms of like uh when i compile the code

760
00:24:43,200 --> 00:24:44,080
it's

761
00:24:44,080 --> 00:24:46,000
exactly identical and then i can do

762
00:24:46,000 --> 00:24:47,520
these like uh

763
00:24:47,520 --> 00:24:49,279
supposedly find the back doors that the

764
00:24:49,279 --> 00:24:50,720
bad guys are inserting not that kind of

765
00:24:50,720 --> 00:24:52,159
reproducible

766
00:24:52,159 --> 00:24:53,360
um

767
00:24:53,360 --> 00:24:54,559
but more that

768
00:24:54,559 --> 00:24:55,360
uh

769
00:24:55,360 --> 00:24:56,720
i can't tell you how many times i've

770
00:24:56,720 --> 00:24:58,000
been on an audit where i've been given a

771
00:24:58,000 --> 00:24:59,279
code base

772
00:24:59,279 --> 00:25:01,120
and they don't even expect that i'm

773
00:25:01,120 --> 00:25:02,559
going to figure out how to build it

774
00:25:02,559 --> 00:25:04,480
right like the build system is created

775
00:25:04,480 --> 00:25:06,640
by some guy in like a dark corner of the

776
00:25:06,640 --> 00:25:09,039
room that manages this arcane build

777
00:25:09,039 --> 00:25:10,960
system with all these special commands

778
00:25:10,960 --> 00:25:13,200
like a 30 page pdf that you have to go

779
00:25:13,200 --> 00:25:14,559
through to produce this exquisite

780
00:25:14,559 --> 00:25:16,080
software artifact that works for that

781
00:25:16,080 --> 00:25:18,080
guy's machine and then they tar ball

782
00:25:18,080 --> 00:25:19,760
that up and ship it

783
00:25:19,760 --> 00:25:21,440
um

784
00:25:21,440 --> 00:25:22,320
so

785
00:25:22,320 --> 00:25:24,640
docker has only really become a thing in

786
00:25:24,640 --> 00:25:26,480
recent history and it's not widely

787
00:25:26,480 --> 00:25:29,279
adopted yet i don't think given the

788
00:25:29,279 --> 00:25:32,400
number of pieces of code that i've seen

789
00:25:32,400 --> 00:25:34,240
in general builds are a mess

790
00:25:34,240 --> 00:25:36,159
so we outsource all this logic to really

791
00:25:36,159 --> 00:25:37,279
unpredictable environments we're

792
00:25:37,279 --> 00:25:39,520
deploying to different operating systems

793
00:25:39,520 --> 00:25:41,600
there's no version dependency uh

794
00:25:41,600 --> 00:25:42,559
tracking

795
00:25:42,559 --> 00:25:44,320
um even if you're doing something that's

796
00:25:44,320 --> 00:25:46,000
more declarative like people have these

797
00:25:46,000 --> 00:25:47,520
manifests where

798
00:25:47,520 --> 00:25:50,000
uh like cargo or whatever can select the

799
00:25:50,000 --> 00:25:51,039
version

800
00:25:51,039 --> 00:25:52,799
um still people have like lots of

801
00:25:52,799 --> 00:25:54,480
unlocked dependencies this is where you

802
00:25:54,480 --> 00:25:56,400
see in javascript world people get hit

803
00:25:56,400 --> 00:25:59,200
by like shift left and all that junk

804
00:25:59,200 --> 00:26:00,400
um

805
00:26:00,400 --> 00:26:02,320
and then network calls uh like any kind

806
00:26:02,320 --> 00:26:04,480
of interaction with the user ends up

807
00:26:04,480 --> 00:26:06,400
changing that state which then prevents

808
00:26:06,400 --> 00:26:07,919
you from rigorously testing that

809
00:26:07,919 --> 00:26:09,120
application

810
00:26:09,120 --> 00:26:10,960
uh because it's been it's been primed

811
00:26:10,960 --> 00:26:12,480
somehow

812
00:26:12,480 --> 00:26:14,240
um really good example here we have a

813
00:26:14,240 --> 00:26:16,720
tool called uh krf

814
00:26:16,720 --> 00:26:18,720
uh i believe it's called the kernel

815
00:26:18,720 --> 00:26:20,720
rootkit fuzzer i forget what it's called

816
00:26:20,720 --> 00:26:24,799
but we wrote krf um it just uh munges

817
00:26:24,799 --> 00:26:27,440
the output of system calls to your

818
00:26:27,440 --> 00:26:28,400
program

819
00:26:28,400 --> 00:26:30,000
and i cannot tell you the number of

820
00:26:30,000 --> 00:26:32,640
programs we've killed that we've

821
00:26:32,640 --> 00:26:34,400
exploited or that we've

822
00:26:34,400 --> 00:26:37,600
broken somehow by by doing that right

823
00:26:37,600 --> 00:26:38,640
so

824
00:26:38,640 --> 00:26:40,480
a lot of this stuff is just like not

825
00:26:40,480 --> 00:26:42,320
reproducible and it doesn't behave the

826
00:26:42,320 --> 00:26:45,678
same under these different conditions

827
00:26:46,559 --> 00:26:47,919
uh and the last thing is that the input

828
00:26:47,919 --> 00:26:50,000
space is huge so programmers don't

829
00:26:50,000 --> 00:26:52,159
really know what changes stuff later in

830
00:26:52,159 --> 00:26:54,080
the program um

831
00:26:54,080 --> 00:26:57,039
they're not uh

832
00:26:57,279 --> 00:26:58,480
yeah they expect everything to be

833
00:26:58,480 --> 00:27:00,480
referentially transparent but like if i

834
00:27:00,480 --> 00:27:03,600
evaluate f of x then i always get y

835
00:27:03,600 --> 00:27:06,320
but that is very frequently not the case

836
00:27:06,320 --> 00:27:07,919
uh they assume that a system call always

837
00:27:07,919 --> 00:27:10,080
returns as expected but sometimes

838
00:27:10,080 --> 00:27:11,760
somebody's running prf

839
00:27:11,760 --> 00:27:14,640
uh so if you're

840
00:27:16,400 --> 00:27:18,640
yeah so another really fun one is that

841
00:27:18,640 --> 00:27:20,799
if you're in like computer science 101

842
00:27:20,799 --> 00:27:22,320
and you have an algorithm with like 10

843
00:27:22,320 --> 00:27:23,760
different nodes and you make a type with

844
00:27:23,760 --> 00:27:25,520
a label for each node

845
00:27:25,520 --> 00:27:26,640
then

846
00:27:26,640 --> 00:27:28,080
some people make their node id as a

847
00:27:28,080 --> 00:27:30,080
string type and now you have white space

848
00:27:30,080 --> 00:27:31,600
bugs

849
00:27:31,600 --> 00:27:33,919
so this over reliance on dynamic input

850
00:27:33,919 --> 00:27:36,000
and not statically typed input

851
00:27:36,000 --> 00:27:39,120
vastly explodes the input space into all

852
00:27:39,120 --> 00:27:40,880
kinds of things that you would not

853
00:27:40,880 --> 00:27:42,799
expect could be sent to your program

854
00:27:42,799 --> 00:27:44,399
that you now have to deal with so

855
00:27:44,399 --> 00:27:45,840
there's not really an effort to make

856
00:27:45,840 --> 00:27:48,559
input space manageable to even

857
00:27:48,559 --> 00:27:50,720
adequately test it on the part of most

858
00:27:50,720 --> 00:27:52,000
software engineers writing those

859
00:27:52,000 --> 00:27:54,000
software

860
00:27:54,000 --> 00:27:55,840
so yeah i would like to forget that the

861
00:27:55,840 --> 00:27:57,840
nulls exist i would like to

862
00:27:57,840 --> 00:28:00,880
not see code that is extremely typed

863
00:28:00,880 --> 00:28:03,679
um just pervasively across the entire

864
00:28:03,679 --> 00:28:05,360
ecosystem

865
00:28:05,360 --> 00:28:07,440
list and tuples are really nice but in

866
00:28:07,440 --> 00:28:09,360
fact they sabotage the ability for your

867
00:28:09,360 --> 00:28:12,158
card to be secure

868
00:28:12,960 --> 00:28:14,960
so we try to do

869
00:28:14,960 --> 00:28:17,039
research at trilibits like

870
00:28:17,039 --> 00:28:19,600
we try to use papers uh we try to apply

871
00:28:19,600 --> 00:28:20,960
them to software

872
00:28:20,960 --> 00:28:22,960
but it's pretty tough for us like we're

873
00:28:22,960 --> 00:28:24,720
willing to tune stuff up like we would

874
00:28:24,720 --> 00:28:26,159
write a makefile we were at our own

875
00:28:26,159 --> 00:28:28,000
compatibility layer we will

876
00:28:28,000 --> 00:28:28,799
um

877
00:28:28,799 --> 00:28:31,440
like try to do the minimum possible to

878
00:28:31,440 --> 00:28:33,440
get the stuff to work but

879
00:28:33,440 --> 00:28:35,120
papers are not designed for software

880
00:28:35,120 --> 00:28:37,200
that works for real at best they work on

881
00:28:37,200 --> 00:28:39,760
core utils uh which is not what comes in

882
00:28:39,760 --> 00:28:42,640
our door for us to audit if you had

883
00:28:42,640 --> 00:28:45,760
questions um and being able to reproduce

884
00:28:45,760 --> 00:28:47,360
the results on software we work with is

885
00:28:47,360 --> 00:28:50,479
just not happening

886
00:28:50,640 --> 00:28:51,440
um

887
00:28:51,440 --> 00:28:53,440
uh yes and we have a really good there

888
00:28:53,440 --> 00:28:55,120
is a really good blog post we have how

889
00:28:55,120 --> 00:28:56,960
to spot good fuzzing research where even

890
00:28:56,960 --> 00:28:59,200
the minor improvements that people make

891
00:28:59,200 --> 00:29:01,679
to things like afl that already exist

892
00:29:01,679 --> 00:29:03,360
are not framed correctly and

893
00:29:03,360 --> 00:29:04,960
misrepresented

894
00:29:04,960 --> 00:29:07,039
so we have a great summary of a paper

895
00:29:07,039 --> 00:29:08,480
from a former employee called how to

896
00:29:08,480 --> 00:29:10,399
spock for fuzzing research that walks

897
00:29:10,399 --> 00:29:12,399
through kind of the minimum bar required

898
00:29:12,399 --> 00:29:13,919
to say that your fuzzer is better than

899
00:29:13,919 --> 00:29:16,399
somebody else's and when you empirically

900
00:29:16,399 --> 00:29:18,720
evaluate that against all the papers

901
00:29:18,720 --> 00:29:20,720
that are out there so in a review of 32

902
00:29:20,720 --> 00:29:22,559
000 papers there's like one that passes

903
00:29:22,559 --> 00:29:24,720
the bar

904
00:29:24,720 --> 00:29:25,840
so we don't even know what we're trying

905
00:29:25,840 --> 00:29:28,320
to improve

906
00:29:29,039 --> 00:29:31,679
so end result uh we can't speak to the

907
00:29:31,679 --> 00:29:33,039
safety properties of any code that we

908
00:29:33,039 --> 00:29:34,960
review um and we can't produce any

909
00:29:34,960 --> 00:29:36,159
evidence that it's safe against some

910
00:29:36,159 --> 00:29:38,640
class of bug we are kind of just stuck

911
00:29:38,640 --> 00:29:40,159
uh because of this because of these poor

912
00:29:40,159 --> 00:29:41,760
abstraction boundaries because the input

913
00:29:41,760 --> 00:29:44,080
space is huge uh because the software is

914
00:29:44,080 --> 00:29:46,720
not reproducible we are stuck in this

915
00:29:46,720 --> 00:29:48,640
endless cycle of well let's just pull

916
00:29:48,640 --> 00:29:51,120
some some bugs out of the hat and report

917
00:29:51,120 --> 00:29:52,960
them to the client and they got there 20

918
00:29:52,960 --> 00:29:55,039
bugs for this audit so they'll be happy

919
00:29:55,039 --> 00:29:56,880
and we can come see them next year but

920
00:29:56,880 --> 00:29:58,399
what does that mean about the software

921
00:29:58,399 --> 00:30:00,080
that they've reviewed or that i've

922
00:30:00,080 --> 00:30:01,279
reviewed what is that what does that

923
00:30:01,279 --> 00:30:02,880
give them does it mean they're safe does

924
00:30:02,880 --> 00:30:04,960
it mean they're not exposed to a certain

925
00:30:04,960 --> 00:30:07,520
class of issue does it mean that uh the

926
00:30:07,520 --> 00:30:09,039
software won't fail under x and y

927
00:30:09,039 --> 00:30:10,399
condition like no we don't know what

928
00:30:10,399 --> 00:30:12,159
that means we just know that it's

929
00:30:12,159 --> 00:30:14,720
incrementally safer than it was before

930
00:30:14,720 --> 00:30:16,240
not that it is actually safe for any

931
00:30:16,240 --> 00:30:18,320
intended purpose

932
00:30:18,320 --> 00:30:20,080
so the assumption is the code has bad

933
00:30:20,080 --> 00:30:22,720
bugs so we don't know where

934
00:30:22,720 --> 00:30:25,679
which brings us to the blockchain

935
00:30:25,679 --> 00:30:26,799
um

936
00:30:26,799 --> 00:30:28,799
so with that as the state of software we

937
00:30:28,799 --> 00:30:30,320
can kind of look at blockchain for a

938
00:30:30,320 --> 00:30:32,159
glimpse of the future

939
00:30:32,159 --> 00:30:34,080
right it's this weird kind of

940
00:30:34,080 --> 00:30:36,320
engineering that literally does not

941
00:30:36,320 --> 00:30:37,520
support

942
00:30:37,520 --> 00:30:39,919
the obstacles we've encountered

943
00:30:39,919 --> 00:30:41,039
in

944
00:30:41,039 --> 00:30:43,200
other software

945
00:30:43,200 --> 00:30:46,760
and i need to drove

946
00:30:55,279 --> 00:30:56,880
so essentially the question here is if

947
00:30:56,880 --> 00:30:59,679
the people at acm ccss win

948
00:30:59,679 --> 00:31:01,120
what do they get

949
00:31:01,120 --> 00:31:03,919
like what does workflows look like when

950
00:31:03,919 --> 00:31:07,120
you're able to apply research easily

951
00:31:07,120 --> 00:31:09,600
when you can test programs and try these

952
00:31:09,600 --> 00:31:12,399
techniques with no effort

953
00:31:12,399 --> 00:31:13,360
um

954
00:31:13,360 --> 00:31:14,960
blockchain ends up being a really good

955
00:31:14,960 --> 00:31:16,880
test case for all these different

956
00:31:16,880 --> 00:31:19,279
software testing research methodologies

957
00:31:19,279 --> 00:31:21,360
and the clear question is if

958
00:31:21,360 --> 00:31:23,200
brown cows make chocolate milk produced

959
00:31:23,200 --> 00:31:26,840
or cows have difficult

960
00:31:32,960 --> 00:31:34,080
okay

961
00:31:34,080 --> 00:31:36,320
so

962
00:31:36,580 --> 00:31:38,240
[Music]

963
00:31:38,240 --> 00:31:40,880
okay great

964
00:31:42,000 --> 00:31:43,600
so on a smart contract it's weird

965
00:31:43,600 --> 00:31:45,039
because this

966
00:31:45,039 --> 00:31:46,559
complexity these poor abstraction

967
00:31:46,559 --> 00:31:49,200
boundaries massive input space these

968
00:31:49,200 --> 00:31:51,360
uh these issues stand in the way of us

969
00:31:51,360 --> 00:31:53,840
creating testable software on

970
00:31:53,840 --> 00:31:56,880
um regular code they they they actually

971
00:31:56,880 --> 00:31:58,640
have incentives against that and that is

972
00:31:58,640 --> 00:32:00,159
where the incentives matter not that

973
00:32:00,159 --> 00:32:03,039
code is law the incentive

974
00:32:03,039 --> 00:32:04,799
is that it costs money to make code size

975
00:32:04,799 --> 00:32:06,960
big it costs money to process large

976
00:32:06,960 --> 00:32:08,720
inputs so you have this

977
00:32:08,720 --> 00:32:11,519
incentive to produce compact programs on

978
00:32:11,519 --> 00:32:14,080
the right that's the visual disassembly

979
00:32:14,080 --> 00:32:15,840
from a tool we wrote called ethersplay

980
00:32:15,840 --> 00:32:17,440
that's a smart contract that's how much

981
00:32:17,440 --> 00:32:18,960
code you're reviewing

982
00:32:18,960 --> 00:32:20,720
um every single state change is a

983
00:32:20,720 --> 00:32:22,480
transaction so the abstraction

984
00:32:22,480 --> 00:32:25,440
boundaries are extremely clearly defined

985
00:32:25,440 --> 00:32:26,240
and

986
00:32:26,240 --> 00:32:28,720
you have to pay for every single little

987
00:32:28,720 --> 00:32:30,399
object that you use

988
00:32:30,399 --> 00:32:31,840
uh so

989
00:32:31,840 --> 00:32:33,760
oh and because you have to pay to even

990
00:32:33,760 --> 00:32:36,159
execute code you have to terminate so

991
00:32:36,159 --> 00:32:37,120
you don't have to worry about getting

992
00:32:37,120 --> 00:32:38,640
caught in a loop somewhere like at some

993
00:32:38,640 --> 00:32:41,440
point smart contracts end which is crazy

994
00:32:41,440 --> 00:32:43,519
so this whole class of issues that you

995
00:32:43,519 --> 00:32:45,200
learned as like you know

996
00:32:45,200 --> 00:32:47,840
little dan and 19 year old like computer

997
00:32:47,840 --> 00:32:50,159
science 102 about the halting problem or

998
00:32:50,159 --> 00:32:52,080
whatever just screw it not important

999
00:32:52,080 --> 00:32:56,279
right you've solved it with gas

1000
00:32:56,399 --> 00:32:58,799
uh so these abstraction boundaries like

1001
00:32:58,799 --> 00:33:01,840
i said they're very very um

1002
00:33:01,840 --> 00:33:04,080
uh well-defined and all the software

1003
00:33:04,080 --> 00:33:05,919
runs in a completely homogeneous

1004
00:33:05,919 --> 00:33:07,760
environment there is one blockchain

1005
00:33:07,760 --> 00:33:09,600
everyone shares it you don't need to

1006
00:33:09,600 --> 00:33:10,960
figure out if your dependencies

1007
00:33:10,960 --> 00:33:12,720
correctly match production you don't

1008
00:33:12,720 --> 00:33:14,399
need to worry about the operating system

1009
00:33:14,399 --> 00:33:15,919
you don't need to worry about your build

1010
00:33:15,919 --> 00:33:16,880
system

1011
00:33:16,880 --> 00:33:19,360
everything runs on the same blockchain

1012
00:33:19,360 --> 00:33:20,559
so

1013
00:33:20,559 --> 00:33:21,919
anytime there are state updates you're

1014
00:33:21,919 --> 00:33:24,000
using transaction data and it's really

1015
00:33:24,000 --> 00:33:24,960
small

1016
00:33:24,960 --> 00:33:26,720
the state variables that process it on

1017
00:33:26,720 --> 00:33:28,240
the side of the smart contract are also

1018
00:33:28,240 --> 00:33:31,120
tiny they're usually like less than 10.

1019
00:33:31,120 --> 00:33:32,640
and the approximate number is to kind of

1020
00:33:32,640 --> 00:33:34,159
demonstrate scale as you're dealing with

1021
00:33:34,159 --> 00:33:35,840
hundreds of bytes or thousands of

1022
00:33:35,840 --> 00:33:37,760
instructions and if you're doing that

1023
00:33:37,760 --> 00:33:39,120
all of a sudden these heavyweight

1024
00:33:39,120 --> 00:33:41,360
analysis techniques are possible you can

1025
00:33:41,360 --> 00:33:43,679
use symbolic execution everywhere when

1026
00:33:43,679 --> 00:33:44,960
you're only dealing with programs that

1027
00:33:44,960 --> 00:33:48,799
are a thousand instructions long

1028
00:33:49,200 --> 00:33:50,640
so from a back of the envelope math

1029
00:33:50,640 --> 00:33:52,720
perspective they're in a great place to

1030
00:33:52,720 --> 00:33:54,559
start

1031
00:33:54,559 --> 00:33:56,640
um and this leads to weird results that

1032
00:33:56,640 --> 00:33:58,159
you wouldn't expect like me starting in

1033
00:33:58,159 --> 00:33:59,679
the field a couple years ago i would not

1034
00:33:59,679 --> 00:34:01,840
expect that symbolic execution is quite

1035
00:34:01,840 --> 00:34:03,519
possibly the most common analysis

1036
00:34:03,519 --> 00:34:04,960
technique in the space

1037
00:34:04,960 --> 00:34:06,159
and that there's widespread

1038
00:34:06,159 --> 00:34:07,440
understanding of it on the part of

1039
00:34:07,440 --> 00:34:09,599
software developers writing tests for

1040
00:34:09,599 --> 00:34:11,679
code just like wacky right

1041
00:34:11,679 --> 00:34:13,520
uh even writing the symbolic execution

1042
00:34:13,520 --> 00:34:15,839
engine is easy it's a weekend project

1043
00:34:15,839 --> 00:34:18,399
like a lot of people maybe um

1044
00:34:18,399 --> 00:34:20,399
took on these ridiculous challenges as a

1045
00:34:20,399 --> 00:34:21,918
college student they try to write like a

1046
00:34:21,918 --> 00:34:23,918
brain interpreter over a weekend

1047
00:34:23,918 --> 00:34:24,960
and there's only a handful of

1048
00:34:24,960 --> 00:34:26,879
instructions for that except they're all

1049
00:34:26,879 --> 00:34:29,199
white spaces uh

1050
00:34:29,199 --> 00:34:30,719
but it's easy right

1051
00:34:30,719 --> 00:34:31,839
um

1052
00:34:31,839 --> 00:34:33,199
and then you're like oh wow that was

1053
00:34:33,199 --> 00:34:34,879
really fun symbolic execution's really

1054
00:34:34,879 --> 00:34:36,079
powerful i'm gonna try and write this

1055
00:34:36,079 --> 00:34:38,239
for x86 and you try to do it you

1056
00:34:38,239 --> 00:34:40,239
immediately fall on your face

1057
00:34:40,239 --> 00:34:42,239
because x86 is extraordinarily

1058
00:34:42,239 --> 00:34:43,760
complicated and it'll take you like

1059
00:34:43,760 --> 00:34:45,199
years to write a really good one which

1060
00:34:45,199 --> 00:34:46,960
we have done right like us and anger and

1061
00:34:46,960 --> 00:34:48,639
a few other folks have spent

1062
00:34:48,639 --> 00:34:50,960
extraordinary effort trying to perfect

1063
00:34:50,960 --> 00:34:55,040
these exquisite symbolic uh uh uh

1064
00:34:55,040 --> 00:34:57,119
symbolic virtual machines that process

1065
00:34:57,119 --> 00:35:00,160
languages as complicated as x86 but evm

1066
00:35:00,160 --> 00:35:01,920
the ethereum virtual machine is still

1067
00:35:01,920 --> 00:35:03,839
something you can kind of do a weekend

1068
00:35:03,839 --> 00:35:05,920
um there are less instructions

1069
00:35:05,920 --> 00:35:08,320
uh there are less side effects it's like

1070
00:35:08,320 --> 00:35:09,599
something that you can kind of just whip

1071
00:35:09,599 --> 00:35:11,359
together and it actually works and like

1072
00:35:11,359 --> 00:35:13,520
you can use it to find real bugs

1073
00:35:13,520 --> 00:35:16,320
um and it's not that hard to use uh when

1074
00:35:16,320 --> 00:35:17,839
it comes down to it we've seen amateur

1075
00:35:17,839 --> 00:35:19,599
developers take advantage of symbolic

1076
00:35:19,599 --> 00:35:20,720
execution

1077
00:35:20,720 --> 00:35:23,040
uh in ways that i would never expect a

1078
00:35:23,040 --> 00:35:25,599
developer on like a web application or a

1079
00:35:25,599 --> 00:35:27,680
compiled code application to do

1080
00:35:27,680 --> 00:35:29,680
um so of course like experts can do more

1081
00:35:29,680 --> 00:35:31,760
with it there's more that i or trail of

1082
00:35:31,760 --> 00:35:33,599
bits can do with some with smog

1083
00:35:33,599 --> 00:35:35,760
execution than like a random person

1084
00:35:35,760 --> 00:35:37,920
picked it up yesterday but still it's

1085
00:35:37,920 --> 00:35:40,160
really cool

1086
00:35:40,160 --> 00:35:42,480
um

1087
00:35:43,200 --> 00:35:45,920
yeah uh oh yeah and in this field too

1088
00:35:45,920 --> 00:35:47,280
it's also wacky there are there are

1089
00:35:47,280 --> 00:35:48,320
places you can go where you can just

1090
00:35:48,320 --> 00:35:49,839
copy and paste code into like a web

1091
00:35:49,839 --> 00:35:51,520
application press enter

1092
00:35:51,520 --> 00:35:53,760
and the syntax will run on the back end

1093
00:35:53,760 --> 00:35:55,119
and just like give you results right

1094
00:35:55,119 --> 00:35:58,880
again so just like this is bizarro world

1095
00:35:58,880 --> 00:36:01,839
uh fuzzing is also exceptionally popular

1096
00:36:01,839 --> 00:36:03,280
across the space

1097
00:36:03,280 --> 00:36:04,079
um

1098
00:36:04,079 --> 00:36:06,560
in the right environment uh the correct

1099
00:36:06,560 --> 00:36:08,480
option can be easier right these these

1100
00:36:08,480 --> 00:36:10,240
kind of testing techniques

1101
00:36:10,240 --> 00:36:12,240
are widespread because they are easy to

1102
00:36:12,240 --> 00:36:14,240
use um

1103
00:36:14,240 --> 00:36:15,920
the hardest part about writing a fuzzer

1104
00:36:15,920 --> 00:36:17,359
in this environment is being able to

1105
00:36:17,359 --> 00:36:20,000
execute the code you have to in general

1106
00:36:20,000 --> 00:36:21,920
all the fuzzers that i'm aware of for

1107
00:36:21,920 --> 00:36:24,320
ethereum have a built-in virtual machine

1108
00:36:24,320 --> 00:36:27,440
a built-in edm that emulates the code so

1109
00:36:27,440 --> 00:36:29,359
they deploy internally to themselves run

1110
00:36:29,359 --> 00:36:30,079
it

1111
00:36:30,079 --> 00:36:31,599
and the hardest part is actually just

1112
00:36:31,599 --> 00:36:33,440
finding where the errors are in a normal

1113
00:36:33,440 --> 00:36:35,119
program finding an error is easy right

1114
00:36:35,119 --> 00:36:36,480
like what does an error look like a c

1115
00:36:36,480 --> 00:36:39,960
plus plus program

1116
00:36:40,079 --> 00:36:41,200
segfall

1117
00:36:41,200 --> 00:36:43,200
easy right what does an error look like

1118
00:36:43,200 --> 00:36:45,760
in a smart contract

1119
00:36:45,760 --> 00:36:47,119
 if i know

1120
00:36:47,119 --> 00:36:49,359
uh like you have to figure out what the

1121
00:36:49,359 --> 00:36:51,440
program actually was intended to do

1122
00:36:51,440 --> 00:36:52,640
and then

1123
00:36:52,640 --> 00:36:54,960
identify those cases so the hard part is

1124
00:36:54,960 --> 00:36:56,720
actually writing these invariants or

1125
00:36:56,720 --> 00:36:58,720
these specs or properties that you're

1126
00:36:58,720 --> 00:36:59,760
actually

1127
00:36:59,760 --> 00:37:02,320
setting out the buzzer to look for

1128
00:37:02,320 --> 00:37:03,440
um

1129
00:37:03,440 --> 00:37:04,960
so that's kind of limited to your

1130
00:37:04,960 --> 00:37:06,160
knowledge of the system and to the

1131
00:37:06,160 --> 00:37:08,160
documentation that you've been provided

1132
00:37:08,160 --> 00:37:10,240
uh getting uh you know writing some

1133
00:37:10,240 --> 00:37:11,839
detection for when things go wrong is a

1134
00:37:11,839 --> 00:37:14,000
little bit hard but not unsolvable

1135
00:37:14,000 --> 00:37:15,359
uh

1136
00:37:15,359 --> 00:37:16,880
but anyway

1137
00:37:16,880 --> 00:37:18,640
again here when an environment is

1138
00:37:18,640 --> 00:37:20,800
testable it's easier to do the right

1139
00:37:20,800 --> 00:37:23,040
thing so a lot of these tools do exist

1140
00:37:23,040 --> 00:37:24,640
they are quite easy to apply you just

1141
00:37:24,640 --> 00:37:26,079
have to get over the initial hump of

1142
00:37:26,079 --> 00:37:28,160
well what am i trying to find so you

1143
00:37:28,160 --> 00:37:29,839
write some invariance but that ends up

1144
00:37:29,839 --> 00:37:31,359
being a lot better because there are

1145
00:37:31,359 --> 00:37:32,800
actually invariants that you would care

1146
00:37:32,800 --> 00:37:34,880
about a closer defined in sql pulse code

1147
00:37:34,880 --> 00:37:37,359
that go beyond segbaltz but most people

1148
00:37:37,359 --> 00:37:38,960
never make it there everybody usually

1149
00:37:38,960 --> 00:37:40,160
sticks with sick faults because they

1150
00:37:40,160 --> 00:37:42,560
find an ever-increasing and never-ending

1151
00:37:42,560 --> 00:37:44,480
number of them so you never think about

1152
00:37:44,480 --> 00:37:46,640
well what kind of application specific

1153
00:37:46,640 --> 00:37:48,640
fuzz test results might i care about

1154
00:37:48,640 --> 00:37:49,920
it's not a question that enters into

1155
00:37:49,920 --> 00:37:52,880
most security engineers minds

1156
00:37:52,880 --> 00:37:54,000
and then there's static analysis which

1157
00:37:54,000 --> 00:37:55,440
is basically the same as ever it's more

1158
00:37:55,440 --> 00:37:57,040
popular than fuzzing less than symbolic

1159
00:37:57,040 --> 00:37:58,160
execution

1160
00:37:58,160 --> 00:38:02,240
um it is an undergrad class project to

1161
00:38:02,240 --> 00:38:04,640
oh my like yes i have to skip a few

1162
00:38:04,640 --> 00:38:05,599
slides

1163
00:38:05,599 --> 00:38:06,960
uh so

1164
00:38:06,960 --> 00:38:08,880
you could start with your like undergrad

1165
00:38:08,880 --> 00:38:11,359
quality static analyzer that's like grep

1166
00:38:11,359 --> 00:38:12,960
with extra steps

1167
00:38:12,960 --> 00:38:15,839
and as long as you um like

1168
00:38:15,839 --> 00:38:17,440
you could just write some analyses that

1169
00:38:17,440 --> 00:38:19,280
look at rights to state variables and do

1170
00:38:19,280 --> 00:38:21,280
like some really basic data flow and bam

1171
00:38:21,280 --> 00:38:23,359
you've got bugs like that's it it's

1172
00:38:23,359 --> 00:38:24,880
really simple

1173
00:38:24,880 --> 00:38:26,480
uh the hard part here again is writing a

1174
00:38:26,480 --> 00:38:28,079
bunch of heuristics

1175
00:38:28,079 --> 00:38:29,359
so we have done that we've written

1176
00:38:29,359 --> 00:38:31,359
essentially over the last two years half

1177
00:38:31,359 --> 00:38:33,040
of a compiler

1178
00:38:33,040 --> 00:38:35,359
that will take solidity translated to an

1179
00:38:35,359 --> 00:38:37,359
ssa form and then perform extremely

1180
00:38:37,359 --> 00:38:39,520
sophisticated analysis to find hundreds

1181
00:38:39,520 --> 00:38:41,119
of types of bugs

1182
00:38:41,119 --> 00:38:42,720
but again this was the effort of like a

1183
00:38:42,720 --> 00:38:44,320
single person over the period of about a

1184
00:38:44,320 --> 00:38:45,520
year or two

1185
00:38:45,520 --> 00:38:48,240
and we've got this extremely effective

1186
00:38:48,240 --> 00:38:50,480
static analysis toolkit that is unheard

1187
00:38:50,480 --> 00:38:54,960
of for a language that's not absolutely

1188
00:38:54,960 --> 00:38:56,960
um so big picture code correctness tools

1189
00:38:56,960 --> 00:38:58,720
work most places the developer

1190
00:38:58,720 --> 00:39:01,599
experience is basically find bugs

1191
00:39:01,599 --> 00:39:04,240
um and we can find truckloads of issues

1192
00:39:04,240 --> 00:39:05,599
uh so at one point we actually had to

1193
00:39:05,599 --> 00:39:07,280
make a giant spreadsheet like a google

1194
00:39:07,280 --> 00:39:09,040
sheet just to track all the fuzzer

1195
00:39:09,040 --> 00:39:10,480
results that we were finding running

1196
00:39:10,480 --> 00:39:12,079
these tools across all the code on the

1197
00:39:12,079 --> 00:39:14,560
blockchain which is again visible

1198
00:39:14,560 --> 00:39:17,599
uh so i can run my analysis universally

1199
00:39:17,599 --> 00:39:19,119
across the entire ecosystem with the

1200
00:39:19,119 --> 00:39:22,000
press of a button which is also nuts

1201
00:39:22,000 --> 00:39:23,760
um so generally you know when to when

1202
00:39:23,760 --> 00:39:26,079
developers uh become aware of these

1203
00:39:26,079 --> 00:39:27,680
tools when i present at blockchain

1204
00:39:27,680 --> 00:39:28,800
conferences

1205
00:39:28,800 --> 00:39:30,480
they close telegram because that's what

1206
00:39:30,480 --> 00:39:32,320
blockchain developers use

1207
00:39:32,320 --> 00:39:33,839
uh and they run the tools during our

1208
00:39:33,839 --> 00:39:35,280
presentations about it and come up to me

1209
00:39:35,280 --> 00:39:36,880
afterwards and say i found a bug before

1210
00:39:36,880 --> 00:39:38,560
your presentation was over

1211
00:39:38,560 --> 00:39:39,920
right

1212
00:39:39,920 --> 00:39:41,440
um

1213
00:39:41,440 --> 00:39:43,280
so uh

1214
00:39:43,280 --> 00:39:45,280
the neat thing about this is that

1215
00:39:45,280 --> 00:39:47,440
people who are taking it seriously are

1216
00:39:47,440 --> 00:39:50,240
getting really really good

1217
00:39:50,240 --> 00:39:52,640
um we have people come to us with these

1218
00:39:52,640 --> 00:39:55,680
high coverage symbolic test suites

1219
00:39:55,680 --> 00:39:56,400
that

1220
00:39:56,400 --> 00:39:59,040
cover just a vast amount more

1221
00:39:59,040 --> 00:40:01,040
state space than any traditional

1222
00:40:01,040 --> 00:40:02,640
software

1223
00:40:02,640 --> 00:40:04,640
company ever has

1224
00:40:04,640 --> 00:40:08,079
we had gemiini as a great example like i

1225
00:40:08,079 --> 00:40:09,520
can't say they will never be hacked but

1226
00:40:09,520 --> 00:40:10,960
they have invested

1227
00:40:10,960 --> 00:40:13,599
the right things to make sure that the

1228
00:40:13,599 --> 00:40:15,200
billions of dollars they manage in a

1229
00:40:15,200 --> 00:40:17,520
smart contract won't show up on

1230
00:40:17,520 --> 00:40:20,400
uh web3 is going great by molly white

1231
00:40:20,400 --> 00:40:22,079
right

1232
00:40:22,079 --> 00:40:24,640
and um the level of verification that

1233
00:40:24,640 --> 00:40:26,560
you see on that kind of code is the same

1234
00:40:26,560 --> 00:40:28,400
level of verification you see on

1235
00:40:28,400 --> 00:40:30,720
software running a satellite of somebody

1236
00:40:30,720 --> 00:40:33,280
making a cryptographic library and it's

1237
00:40:33,280 --> 00:40:36,000
it's respectable

1238
00:40:36,000 --> 00:40:37,440
um

1239
00:40:37,440 --> 00:40:39,280
so

1240
00:40:39,280 --> 00:40:41,359
this is the money shot

1241
00:40:41,359 --> 00:40:43,280
uh smart contracts are actually the

1242
00:40:43,280 --> 00:40:45,280
ideal way to develop software

1243
00:40:45,280 --> 00:40:49,359
for many different versions of ideal

1244
00:40:49,680 --> 00:40:51,440
um

1245
00:40:51,440 --> 00:40:54,079
so now i'm gonna have to skip a session

1246
00:40:54,079 --> 00:40:55,520
because i didn't practice this talk or

1247
00:40:55,520 --> 00:40:56,720
time it

1248
00:40:56,720 --> 00:40:58,720
uh

1249
00:40:58,720 --> 00:40:59,520
so

1250
00:40:59,520 --> 00:41:00,800
i'll just give you the cheat sheet a

1251
00:41:00,800 --> 00:41:02,079
little bit about how trail of bits

1252
00:41:02,079 --> 00:41:03,440
approach these things because obviously

1253
00:41:03,440 --> 00:41:05,119
like we work in blockchain software i

1254
00:41:05,119 --> 00:41:06,960
work in regular software too people hire

1255
00:41:06,960 --> 00:41:08,560
me to do audits of software that are not

1256
00:41:08,560 --> 00:41:10,319
solidity thank god

1257
00:41:10,319 --> 00:41:11,599
um

1258
00:41:11,599 --> 00:41:12,640
but

1259
00:41:12,640 --> 00:41:14,720
we have to have a process that produces

1260
00:41:14,720 --> 00:41:17,359
these more uniform and more rigorous

1261
00:41:17,359 --> 00:41:18,960
results

1262
00:41:18,960 --> 00:41:20,800
because i don't like to test software

1263
00:41:20,800 --> 00:41:22,480
the old way i don't want to just stick

1264
00:41:22,480 --> 00:41:24,079
my hand in the bucket pull out a bunch

1265
00:41:24,079 --> 00:41:26,160
of bugs and show the client like hey

1266
00:41:26,160 --> 00:41:28,160
this is wonderful i found 20 bugs and

1267
00:41:28,160 --> 00:41:29,440
they're like what does that mean for me

1268
00:41:29,440 --> 00:41:30,880
and i said i don't know

1269
00:41:30,880 --> 00:41:32,720
there's probably 20 more like see you

1270
00:41:32,720 --> 00:41:35,040
next year like that sucks i don't want

1271
00:41:35,040 --> 00:41:36,079
to do that

1272
00:41:36,079 --> 00:41:37,359
so

1273
00:41:37,359 --> 00:41:38,960
a lot of what we do is we find that the

1274
00:41:38,960 --> 00:41:41,520
most important barrier to overcome

1275
00:41:41,520 --> 00:41:43,680
is the reproducibility part

1276
00:41:43,680 --> 00:41:46,520
as an auditor i will spend sometimes

1277
00:41:46,520 --> 00:41:49,280
extraordinary effort to make builds

1278
00:41:49,280 --> 00:41:51,359
reproducible reproducible to me means

1279
00:41:51,359 --> 00:41:52,319
something different than i think the

1280
00:41:52,319 --> 00:41:54,079
rest of the industry means but like i

1281
00:41:54,079 --> 00:41:55,440
want to build the damn software i want

1282
00:41:55,440 --> 00:41:57,359
to build on a modern compiler i want to

1283
00:41:57,359 --> 00:41:59,040
build it with a build system that i can

1284
00:41:59,040 --> 00:42:00,160
instrument

1285
00:42:00,160 --> 00:42:02,480
and i want to run the i want the ability

1286
00:42:02,480 --> 00:42:04,800
to routinely and comprehensively and

1287
00:42:04,800 --> 00:42:06,480
repeatedly run these more rigorous

1288
00:42:06,480 --> 00:42:08,720
analyses to drop out bugs i wanted to

1289
00:42:08,720 --> 00:42:10,400
run on a modern compiler i wanted to run

1290
00:42:10,400 --> 00:42:13,280
an emulated environment i wanted to run

1291
00:42:13,280 --> 00:42:15,280
uh like for example we haven't talked

1292
00:42:15,280 --> 00:42:17,119
about this much but zoom hired us back

1293
00:42:17,119 --> 00:42:19,599
in april 2020 when they were having some

1294
00:42:19,599 --> 00:42:20,640
issues

1295
00:42:20,640 --> 00:42:22,960
and when we got in to work with them i

1296
00:42:22,960 --> 00:42:24,240
had a team of eight people that were

1297
00:42:24,240 --> 00:42:26,400
ready to work for three months to find

1298
00:42:26,400 --> 00:42:28,640
bugs in their software the very first

1299
00:42:28,640 --> 00:42:31,200
thing we did is we rewrote their entire

1300
00:42:31,200 --> 00:42:33,520
build system for their entire code base

1301
00:42:33,520 --> 00:42:35,040
from scratch

1302
00:42:35,040 --> 00:42:36,240
in two weeks

1303
00:42:36,240 --> 00:42:38,079
and then i let everybody go audit it for

1304
00:42:38,079 --> 00:42:40,319
code because i wanted the ability to do

1305
00:42:40,319 --> 00:42:43,280
things like asan i wanted llvms compiler

1306
00:42:43,280 --> 00:42:45,599
analyses i wanted lib buzzer to be

1307
00:42:45,599 --> 00:42:47,599
available to me because those allow me

1308
00:42:47,599 --> 00:42:50,640
to produce measurable outcomes

1309
00:42:50,640 --> 00:42:52,800
uh instead of just

1310
00:42:52,800 --> 00:42:54,319
essentially like we could have easily

1311
00:42:54,319 --> 00:42:56,400
started that engagement not done that

1312
00:42:56,400 --> 00:42:59,200
precursor step and then just

1313
00:42:59,200 --> 00:43:00,880
found bugs from all over the place

1314
00:43:00,880 --> 00:43:02,480
forever and they would have thought our

1315
00:43:02,480 --> 00:43:04,720
productivity was insane but in this case

1316
00:43:04,720 --> 00:43:07,599
we help them help us help themselves

1317
00:43:07,599 --> 00:43:09,200
because now you empowered every other

1318
00:43:09,200 --> 00:43:11,520
developer on the entire development team

1319
00:43:11,520 --> 00:43:13,440
to use those analyses

1320
00:43:13,440 --> 00:43:15,200
and once you kind of lock in the state

1321
00:43:15,200 --> 00:43:16,960
that you'd like with some of llvm's

1322
00:43:16,960 --> 00:43:18,800
tools you can make sure they're not back

1323
00:43:18,800 --> 00:43:21,599
sliding with new commits

1324
00:43:21,599 --> 00:43:23,440
so once we have those build systems

1325
00:43:23,440 --> 00:43:25,359
rewritten trailer bits also has a

1326
00:43:25,359 --> 00:43:28,560
monumental proprietary code base of

1327
00:43:28,560 --> 00:43:30,400
uh bug classes that only we know about

1328
00:43:30,400 --> 00:43:33,200
yeah surprise i i share a lot but i

1329
00:43:33,200 --> 00:43:36,079
don't share everything um so we have

1330
00:43:36,079 --> 00:43:38,720
uh sem grip analyses we have codeql

1331
00:43:38,720 --> 00:43:42,319
analyses we have uh slither analyses

1332
00:43:42,319 --> 00:43:43,440
that

1333
00:43:43,440 --> 00:43:45,040
we are kind of incubating internally

1334
00:43:45,040 --> 00:43:46,240
that we've discovered from past

1335
00:43:46,240 --> 00:43:47,560
assessments that we can apply

1336
00:43:47,560 --> 00:43:49,920
instantaneously to know that code base

1337
00:43:49,920 --> 00:43:52,079
is not affected by flaws that we've

1338
00:43:52,079 --> 00:43:54,480
already discovered before

1339
00:43:54,480 --> 00:43:55,520
um

1340
00:43:55,520 --> 00:43:57,200
and then as a last resort soundgrip is

1341
00:43:57,200 --> 00:43:58,079
amazing because it doesn't need

1342
00:43:58,079 --> 00:44:00,319
buildable source so if i can't get that

1343
00:44:00,319 --> 00:44:02,319
build system working that's my my go-to

1344
00:44:02,319 --> 00:44:03,280
tool

1345
00:44:03,280 --> 00:44:05,280
uh and then we go through this process

1346
00:44:05,280 --> 00:44:07,119
where there are two steps now instead of

1347
00:44:07,119 --> 00:44:08,800
just doing a manual audit

1348
00:44:08,800 --> 00:44:10,640
we have another team of people that are

1349
00:44:10,640 --> 00:44:12,800
dedicated to reading documentation to

1350
00:44:12,800 --> 00:44:15,280
interviewing developers to reading code

1351
00:44:15,280 --> 00:44:17,599
to extract out security properties

1352
00:44:17,599 --> 00:44:20,079
encoding them in a tool that finds them

1353
00:44:20,079 --> 00:44:22,079
programmatically and then committing

1354
00:44:22,079 --> 00:44:23,520
that to the code base during the

1355
00:44:23,520 --> 00:44:25,599
engagement so that the outcome of a

1356
00:44:25,599 --> 00:44:28,160
project you're getting

1357
00:44:28,160 --> 00:44:30,240
invariants of programmatic tests you're

1358
00:44:30,240 --> 00:44:31,200
getting

1359
00:44:31,200 --> 00:44:32,960
um property tests that cover more

1360
00:44:32,960 --> 00:44:34,800
sometimes all possible inputs for a

1361
00:44:34,800 --> 00:44:36,800
given scenario you're getting negative

1362
00:44:36,800 --> 00:44:38,640
tests that don't depend on any

1363
00:44:38,640 --> 00:44:40,160
hard-coded value

1364
00:44:40,160 --> 00:44:41,280
um

1365
00:44:41,280 --> 00:44:43,040
and you're defining new failure modes

1366
00:44:43,040 --> 00:44:44,720
for fuzzers and systemic executors based

1367
00:44:44,720 --> 00:44:46,240
on what the developer actually believes

1368
00:44:46,240 --> 00:44:48,960
should be true about the program

1369
00:44:48,960 --> 00:44:50,480
so security properties can then get

1370
00:44:50,480 --> 00:44:51,760
tested on every commit we have a whole

1371
00:44:51,760 --> 00:44:53,920
bunch of github actions

1372
00:44:53,920 --> 00:44:55,680
that allow people to take advantage of

1373
00:44:55,680 --> 00:44:56,960
these that we've published on the github

1374
00:44:56,960 --> 00:44:59,760
marketplace but when we do audits that's

1375
00:44:59,760 --> 00:45:01,760
the end of them is

1376
00:45:01,760 --> 00:45:03,200
take the code we've given you install

1377
00:45:03,200 --> 00:45:05,440
the action run it forever block the

1378
00:45:05,440 --> 00:45:08,720
build if anybody breaks it

1379
00:45:08,720 --> 00:45:10,160
um and we're going to skip the case

1380
00:45:10,160 --> 00:45:12,480
studies

1381
00:45:13,440 --> 00:45:14,800
okay so

1382
00:45:14,800 --> 00:45:16,319
three slides left i know a little bit

1383
00:45:16,319 --> 00:45:17,440
over time

1384
00:45:17,440 --> 00:45:19,359
uh so languages are getting better so

1385
00:45:19,359 --> 00:45:20,720
there's some bright spots here right

1386
00:45:20,720 --> 00:45:21,599
like

1387
00:45:21,599 --> 00:45:23,280
when i look at is

1388
00:45:23,280 --> 00:45:25,119
traditionals i hate saying it this way

1389
00:45:25,119 --> 00:45:27,680
but it's traditional security um on a

1390
00:45:27,680 --> 00:45:28,800
path to

1391
00:45:28,800 --> 00:45:30,800
better itself and the answer is kind of

1392
00:45:30,800 --> 00:45:32,640
yes i see a couple of bright spots that

1393
00:45:32,640 --> 00:45:34,560
i'm optimistic about where i won't be

1394
00:45:34,560 --> 00:45:36,000
solving the same problem three years

1395
00:45:36,000 --> 00:45:37,839
from now that i am today

1396
00:45:37,839 --> 00:45:38,880
uh

1397
00:45:38,880 --> 00:45:41,119
dynamic types are dying

1398
00:45:41,119 --> 00:45:42,800
um if you take a look at the program at

1399
00:45:42,800 --> 00:45:44,880
the languages that are popular that

1400
00:45:44,880 --> 00:45:46,560
developers want to use they are

1401
00:45:46,560 --> 00:45:49,440
basically all statically typed which is

1402
00:45:49,440 --> 00:45:51,119
amazing right because i think a lot of

1403
00:45:51,119 --> 00:45:53,040
the dynamically typed ones are usually

1404
00:45:53,040 --> 00:45:55,040
marketed as like beginner friendly but

1405
00:45:55,040 --> 00:45:56,480
even the ones that are really beginner

1406
00:45:56,480 --> 00:45:58,000
for like python or whatever python's

1407
00:45:58,000 --> 00:45:59,599
getting types right like there are

1408
00:45:59,599 --> 00:46:01,599
systems now that layer them on people

1409
00:46:01,599 --> 00:46:03,599
have realized they're important

1410
00:46:03,599 --> 00:46:05,040
um and people have also started to

1411
00:46:05,040 --> 00:46:06,319
realize that

1412
00:46:06,319 --> 00:46:08,319
uh it's easier to write code when you

1413
00:46:08,319 --> 00:46:09,839
actually care about pure functions when

1414
00:46:09,839 --> 00:46:10,880
you're not

1415
00:46:10,880 --> 00:46:12,800
trying to manage all the incredible side

1416
00:46:12,800 --> 00:46:14,560
effects from running a piece of code

1417
00:46:14,560 --> 00:46:16,960
you're gonna write a pure function

1418
00:46:16,960 --> 00:46:18,079
um

1419
00:46:18,079 --> 00:46:20,160
so uh and package managers are getting

1420
00:46:20,160 --> 00:46:22,880
reproducible things like um nyx os and

1421
00:46:22,880 --> 00:46:26,960
cargo and uh virtual env and docker

1422
00:46:26,960 --> 00:46:28,560
are now much more popular today than

1423
00:46:28,560 --> 00:46:30,400
they were in the past which makes my job

1424
00:46:30,400 --> 00:46:32,560
so much easier

1425
00:46:32,560 --> 00:46:34,800
uh so here's the

1426
00:46:34,800 --> 00:46:37,359
you know the actual data uh that's from

1427
00:46:37,359 --> 00:46:39,280
stack overflows developer survey from

1428
00:46:39,280 --> 00:46:41,359
about like three or four months ago all

1429
00:46:41,359 --> 00:46:43,599
the popular ones typed all the other

1430
00:46:43,599 --> 00:46:45,200
ones not

1431
00:46:45,200 --> 00:46:46,000
um

1432
00:46:46,000 --> 00:46:47,599
so that's kind of the shift in the

1433
00:46:47,599 --> 00:46:48,960
market that you're seeing that that

1434
00:46:48,960 --> 00:46:50,319
shows that actually maybe we're gonna

1435
00:46:50,319 --> 00:46:52,800
have an easier job a few years from now

1436
00:46:52,800 --> 00:46:55,280
um and yeah reproducible environments so

1437
00:46:55,280 --> 00:46:57,520
like being able to deploy is nice uh

1438
00:46:57,520 --> 00:46:59,520
like i don't want to depend on a 30 page

1439
00:46:59,520 --> 00:47:01,280
pdf written by a guy that's never seen

1440
00:47:01,280 --> 00:47:03,200
the light of day to compile a piece of

1441
00:47:03,200 --> 00:47:05,280
software and now i don't have to because

1442
00:47:05,280 --> 00:47:06,720
i have github workflows and i have

1443
00:47:06,720 --> 00:47:07,680
docker

1444
00:47:07,680 --> 00:47:11,839
and i have virtual env and like

1445
00:47:11,839 --> 00:47:13,280
always kind of hoping that somebody

1446
00:47:13,280 --> 00:47:15,200
shows up in my client queue with nixos

1447
00:47:15,200 --> 00:47:17,119
as a package manager

1448
00:47:17,119 --> 00:47:19,280
when it works it doesn't just help me it

1449
00:47:19,280 --> 00:47:21,280
also helps their developers it helps

1450
00:47:21,280 --> 00:47:23,440
their qa and it helps their production

1451
00:47:23,440 --> 00:47:25,680
so there's more than just security that

1452
00:47:25,680 --> 00:47:27,599
is pushing things in this direction it

1453
00:47:27,599 --> 00:47:29,359
is not just us in this room that can be

1454
00:47:29,359 --> 00:47:30,960
loud about hey declarative package

1455
00:47:30,960 --> 00:47:32,960
managers developers want them too

1456
00:47:32,960 --> 00:47:34,960
there's a uh

1457
00:47:34,960 --> 00:47:37,119
symbiosis there's like overlapping needs

1458
00:47:37,119 --> 00:47:39,440
here that are being satisfied by

1459
00:47:39,440 --> 00:47:42,319
something that benefits everyone

1460
00:47:42,319 --> 00:47:44,319
and the one like weird thing is second

1461
00:47:44,319 --> 00:47:46,480
last slide the one weird thing

1462
00:47:46,480 --> 00:47:48,640
that i see that could change a lot is

1463
00:47:48,640 --> 00:47:50,000
wasp

1464
00:47:50,000 --> 00:47:51,040
when i think about a lot of the

1465
00:47:51,040 --> 00:47:52,640
properties that ethereum has that are

1466
00:47:52,640 --> 00:47:55,280
beneficial i see many of them reproduced

1467
00:47:55,280 --> 00:47:56,960
in wasm

1468
00:47:56,960 --> 00:47:58,640
it doesn't have undefined behavior kind

1469
00:47:58,640 --> 00:47:59,839
of if you're not dealing with floating

1470
00:47:59,839 --> 00:48:00,800
point

1471
00:48:00,800 --> 00:48:02,800
it limits external interfaces makes them

1472
00:48:02,800 --> 00:48:04,480
easier to test

1473
00:48:04,480 --> 00:48:06,000
and it has smaller self-contained

1474
00:48:06,000 --> 00:48:08,240
programs that are easier to run

1475
00:48:08,240 --> 00:48:10,160
um so you can kind of think of wasm as

1476
00:48:10,160 --> 00:48:11,760
like a well-specified virtual machine

1477
00:48:11,760 --> 00:48:14,079
with safe defaults if this becomes more

1478
00:48:14,079 --> 00:48:16,319
popular which i hope it does then we can

1479
00:48:16,319 --> 00:48:17,760
unlock a lot of these benefits of

1480
00:48:17,760 --> 00:48:20,000
software testing research in the kind of

1481
00:48:20,000 --> 00:48:23,040
software that all of us run all the time

1482
00:48:23,040 --> 00:48:23,920
um

1483
00:48:23,920 --> 00:48:26,559
so that is it uh i have some references

1484
00:48:26,559 --> 00:48:28,880
here for some of our blockchain work we

1485
00:48:28,880 --> 00:48:30,640
it's so like offensive that we took it

1486
00:48:30,640 --> 00:48:32,319
out into a separate github repository

1487
00:48:32,319 --> 00:48:33,760
called critic

1488
00:48:33,760 --> 00:48:35,119
some people don't even like to look at

1489
00:48:35,119 --> 00:48:36,000
it

1490
00:48:36,000 --> 00:48:38,000
but our blog has great research on

1491
00:48:38,000 --> 00:48:40,400
applied software security testing uh our

1492
00:48:40,400 --> 00:48:42,640
publications repositories and archive of

1493
00:48:42,640 --> 00:48:45,599
all the talks like this we've ever given

1494
00:48:45,599 --> 00:48:47,280
and obviously we're looking for people

1495
00:48:47,280 --> 00:48:48,880
that want to join us on this on this

1496
00:48:48,880 --> 00:48:50,720
journey so if you're tired of just

1497
00:48:50,720 --> 00:48:52,559
kicking applications really hard and

1498
00:48:52,559 --> 00:48:54,000
like beating it up with your fists and

1499
00:48:54,000 --> 00:48:55,440
being happy with it you'd like to use

1500
00:48:55,440 --> 00:48:56,240
some

1501
00:48:56,240 --> 00:48:58,400
uh you know knowledge from the future to

1502
00:48:58,400 --> 00:49:01,040
test things then come work for me uh

1503
00:49:01,040 --> 00:49:02,880
because we have lots of software that we

1504
00:49:02,880 --> 00:49:04,800
apply research to

1505
00:49:04,800 --> 00:49:06,960
in a way that you wouldn't expect

1506
00:49:06,960 --> 00:49:08,319
um

1507
00:49:08,319 --> 00:49:09,680
and that's it so email me if you've got

1508
00:49:09,680 --> 00:49:13,960
any questions thank you for having me

