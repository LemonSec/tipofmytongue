1
00:00:03,840 --> 00:00:06,399
um as we're already running a bit late

2
00:00:06,399 --> 00:00:10,160
i'm going to try to keep it short but

3
00:00:10,160 --> 00:00:11,840
now we want to go on

4
00:00:11,840 --> 00:00:14,320
talking about some fuzzing as

5
00:00:14,320 --> 00:00:15,599
dan already

6
00:00:15,599 --> 00:00:18,560
touched on and he i think already uh

7
00:00:18,560 --> 00:00:20,320
brought up some of the very interesting

8
00:00:20,320 --> 00:00:22,240
issues that also came up for our work

9
00:00:22,240 --> 00:00:24,160
and also the

10
00:00:24,160 --> 00:00:25,920
problems that we are tackling because of

11
00:00:25,920 --> 00:00:28,560
those um observations for example what

12
00:00:28,560 --> 00:00:30,800
he was talking about is that we kind of

13
00:00:30,800 --> 00:00:34,079
need systems to be uh easily fast

14
00:00:34,079 --> 00:00:36,239
testable for in order for us to be able

15
00:00:36,239 --> 00:00:38,239
to test them and the other thing that he

16
00:00:38,239 --> 00:00:40,719
said is that there are different kinds

17
00:00:40,719 --> 00:00:43,200
of input types that we have we're gonna

18
00:00:43,200 --> 00:00:45,039
talk about i'm pretty different ones

19
00:00:45,039 --> 00:00:47,120
that you might be interested or then you

20
00:00:47,120 --> 00:00:49,120
might be expecting or

21
00:00:49,120 --> 00:00:51,920
then you might know yourself uh in here

22
00:00:51,920 --> 00:00:54,160
and which are very interesting from from

23
00:00:54,160 --> 00:00:57,600
my point of view which i have

24
00:00:57,600 --> 00:01:00,239
put some research into so this talk is

25
00:01:00,239 --> 00:01:02,079
called password automating and scaling

26
00:01:02,079 --> 00:01:03,840
fuzzing for firmware

27
00:01:03,840 --> 00:01:04,640
and

28
00:01:04,640 --> 00:01:06,240
this talk in a nutshell is going to be

29
00:01:06,240 --> 00:01:08,159
something like this and so we want to

30
00:01:08,159 --> 00:01:10,159
take in some firmware from

31
00:01:10,159 --> 00:01:11,840
binaries that

32
00:01:11,840 --> 00:01:13,360
come for

33
00:01:13,360 --> 00:01:15,119
iot

34
00:01:15,119 --> 00:01:16,880
platforms or little small embedded

35
00:01:16,880 --> 00:01:18,720
systems which are just a bit smaller

36
00:01:18,720 --> 00:01:20,479
than what you would expect and have a

37
00:01:20,479 --> 00:01:22,560
bit of a different format than what you

38
00:01:22,560 --> 00:01:24,640
would normally be used to and then we

39
00:01:24,640 --> 00:01:26,960
put this kind of trimmer into

40
00:01:26,960 --> 00:01:29,200
the clouds and there is a lot of things

41
00:01:29,200 --> 00:01:31,360
going on um but we will get into this

42
00:01:31,360 --> 00:01:33,119
later and then we want to get bugs out

43
00:01:33,119 --> 00:01:36,240
of it and this talk is about um how how

44
00:01:36,240 --> 00:01:38,400
can we achieve this and shed some light

45
00:01:38,400 --> 00:01:42,880
on this so first of all who are we uh we

46
00:01:42,880 --> 00:01:45,280
in quotation marks here for the moment

47
00:01:45,280 --> 00:01:48,320
as i get into my name is toby i'm a phd

48
00:01:48,320 --> 00:01:51,200
student at roy university beaufort i'm

49
00:01:51,200 --> 00:01:53,520
also a ctf player ponton participant

50
00:01:53,520 --> 00:01:55,759
before and i'm interested in binary

51
00:01:55,759 --> 00:01:57,759
exploitation and reverse engineering in

52
00:01:57,759 --> 00:01:59,600
my

53
00:01:59,600 --> 00:02:01,920
research i'm focusing on firmware here

54
00:02:01,920 --> 00:02:05,200
normally margot also wanted to

55
00:02:05,200 --> 00:02:07,759
join us here but he sadly cannot due to

56
00:02:07,759 --> 00:02:09,360
covet reasons but he's recovering

57
00:02:09,360 --> 00:02:11,520
quickly and he's also sending his

58
00:02:11,520 --> 00:02:13,440
students

59
00:02:13,440 --> 00:02:15,920
all right first of all let's understand

60
00:02:15,920 --> 00:02:17,920
a bit about systems that we are going to

61
00:02:17,920 --> 00:02:21,840
talk about today um embedded systems so

62
00:02:21,840 --> 00:02:23,520
what do we understand by embedded

63
00:02:23,520 --> 00:02:25,840
systems a lot of you might think about

64
00:02:25,840 --> 00:02:27,440
something like a router

65
00:02:27,440 --> 00:02:29,760
that they have at home anything that's

66
00:02:29,760 --> 00:02:32,160
kind of close to what they're using and

67
00:02:32,160 --> 00:02:34,959
those systems what they do is

68
00:02:34,959 --> 00:02:37,360
they run linux a lot and sometimes so

69
00:02:37,360 --> 00:02:38,879
most of the time it's a bit of a boil

70
00:02:38,879 --> 00:02:41,040
down linux in the form of a busy box or

71
00:02:41,040 --> 00:02:44,319
so but then we figure out um this type

72
00:02:44,319 --> 00:02:46,959
of embedded system is not the only one

73
00:02:46,959 --> 00:02:47,760
and

74
00:02:47,760 --> 00:02:49,360
there are a lot of other systems out

75
00:02:49,360 --> 00:02:53,519
there with very different properties

76
00:02:55,680 --> 00:02:57,360
as we can see here we have different

77
00:02:57,360 --> 00:02:59,040
types of embedded systems

78
00:02:59,040 --> 00:03:01,280
some plcs here which you would find in a

79
00:03:01,280 --> 00:03:04,159
factory deployment or an ecu which you

80
00:03:04,159 --> 00:03:06,640
would find in a car then finally on the

81
00:03:06,640 --> 00:03:08,640
further right you find some home

82
00:03:08,640 --> 00:03:10,640
automation appliances which get smaller

83
00:03:10,640 --> 00:03:12,720
and smaller uh what all these devices

84
00:03:12,720 --> 00:03:14,239
have in common that they usually do not

85
00:03:14,239 --> 00:03:16,000
run any limits so they are very hard to

86
00:03:16,000 --> 00:03:16,959
kind of

87
00:03:16,959 --> 00:03:18,879
grab your hand on but we still want to

88
00:03:18,879 --> 00:03:20,879
have some

89
00:03:20,879 --> 00:03:23,280
security analysis of these as well

90
00:03:23,280 --> 00:03:26,640
and we'll get into why this is a bit

91
00:03:26,640 --> 00:03:29,200
tricky to do and how different ways that

92
00:03:29,200 --> 00:03:31,840
we could go about doing that and

93
00:03:31,840 --> 00:03:34,159
analyzing them so first of all in order

94
00:03:34,159 --> 00:03:36,400
to do this we want to understand how do

95
00:03:36,400 --> 00:03:38,319
these systems actually talk

96
00:03:38,319 --> 00:03:40,319
to the hardware around it because if we

97
00:03:40,319 --> 00:03:42,239
do not have a linux system

98
00:03:42,239 --> 00:03:44,720
kind of the hardware still has to be

99
00:03:44,720 --> 00:03:46,959
talking to be spoken to by the firmware

100
00:03:46,959 --> 00:03:48,799
and we cannot just have a linux syscall

101
00:03:48,799 --> 00:03:50,640
and then have a read or something that

102
00:03:50,640 --> 00:03:52,239
we can get our inputs we do not have a

103
00:03:52,239 --> 00:03:54,159
file system things like that what do we

104
00:03:54,159 --> 00:03:56,640
do in this scenario and as it turns out

105
00:03:56,640 --> 00:03:58,879
we have three main ways of communication

106
00:03:58,879 --> 00:04:02,239
between the firmware image and then

107
00:04:02,239 --> 00:04:04,640
the hardware that's surrounding it and

108
00:04:04,640 --> 00:04:06,560
one of these is called memory mapped

109
00:04:06,560 --> 00:04:09,280
input and outputs or mmio for short and

110
00:04:09,280 --> 00:04:11,760
what this is basically doing it's the

111
00:04:11,760 --> 00:04:14,239
magic memory region which doesn't really

112
00:04:14,239 --> 00:04:17,199
represent any ram as you would

113
00:04:17,199 --> 00:04:19,120
see it in a normal

114
00:04:19,120 --> 00:04:21,199
computer if you have just ram memory you

115
00:04:21,199 --> 00:04:23,040
write something in you read it out and

116
00:04:23,040 --> 00:04:24,720
you get back whatever you got but

117
00:04:24,720 --> 00:04:26,639
instead what is behind this is an actual

118
00:04:26,639 --> 00:04:28,400
device and it's talking to you and

119
00:04:28,400 --> 00:04:30,400
depending on whether you do a read on

120
00:04:30,400 --> 00:04:33,280
this magic memory region or you do a

121
00:04:33,280 --> 00:04:35,199
write you can either find something out

122
00:04:35,199 --> 00:04:37,440
about the state or read some data out of

123
00:04:37,440 --> 00:04:39,680
this peripheral or

124
00:04:39,680 --> 00:04:42,320
you can put some configuration and this

125
00:04:42,320 --> 00:04:45,280
very much depends on how this mio is

126
00:04:45,280 --> 00:04:46,800
laid out but we'll talk about this in a

127
00:04:46,800 --> 00:04:48,800
bit the second

128
00:04:48,800 --> 00:04:51,120
mechanism which we have at our disposal

129
00:04:51,120 --> 00:04:52,639
for talking between firmware and

130
00:04:52,639 --> 00:04:54,479
hardware is interrupts and this is

131
00:04:54,479 --> 00:04:55,919
basically a doorbell sign where the

132
00:04:55,919 --> 00:04:57,360
hardware can tell the firmware okay

133
00:04:57,360 --> 00:04:59,440
buddy i have something going on please

134
00:04:59,440 --> 00:05:01,680
check on me and what's happening in the

135
00:05:01,680 --> 00:05:03,039
firmware then is often that you have

136
00:05:03,039 --> 00:05:06,880
something that's called a an interrupt

137
00:05:06,880 --> 00:05:09,199
handler and the input handler will check

138
00:05:09,199 --> 00:05:12,160
on the device using mmi oh and see okay

139
00:05:12,160 --> 00:05:13,759
what's going on do i have a new network

140
00:05:13,759 --> 00:05:15,919
packet coming and nothing segment

141
00:05:15,919 --> 00:05:17,759
and then we have the third kind of

142
00:05:17,759 --> 00:05:19,759
mechanism which is called direct memory

143
00:05:19,759 --> 00:05:23,520
access or dma for short and here we have

144
00:05:23,520 --> 00:05:25,199
some communication mechanism for high

145
00:05:25,199 --> 00:05:27,680
throughput scenarios where we have

146
00:05:27,680 --> 00:05:29,360
something like an ethernet card which

147
00:05:29,360 --> 00:05:32,880
has to run very rapidly or um usb or

148
00:05:32,880 --> 00:05:35,199
things like that and in these cases what

149
00:05:35,199 --> 00:05:36,400
the firmware and the hardware do is

150
00:05:36,400 --> 00:05:38,000
basically

151
00:05:38,000 --> 00:05:40,400
they unify on a

152
00:05:40,400 --> 00:05:42,320
memory region which they want to talk

153
00:05:42,320 --> 00:05:44,080
through and then they can both

154
00:05:44,080 --> 00:05:46,479
simultaneously read and write to this

155
00:05:46,479 --> 00:05:48,400
memory region and then of course for

156
00:05:48,400 --> 00:05:50,080
example if the

157
00:05:50,080 --> 00:05:52,080
if a device wanted to send something

158
00:05:52,080 --> 00:05:53,600
like an ethernet frame and make it

159
00:05:53,600 --> 00:05:55,280
available to the firmware it could just

160
00:05:55,280 --> 00:05:56,880
write something into an ethernet frame

161
00:05:56,880 --> 00:05:59,520
buffer and then give a an interrupt and

162
00:05:59,520 --> 00:06:01,199
then the camera knows okay now i can

163
00:06:01,199 --> 00:06:03,360
access this directly without having to

164
00:06:03,360 --> 00:06:04,960
use mio to like

165
00:06:04,960 --> 00:06:07,680
phenically read out every bias one after

166
00:06:07,680 --> 00:06:08,639
the other

167
00:06:08,639 --> 00:06:10,319
and this is what

168
00:06:10,319 --> 00:06:12,560
a reading input would look like for us

169
00:06:12,560 --> 00:06:14,800
from a normal like buzzing perspective

170
00:06:14,800 --> 00:06:17,120
for example we have a get char so we

171
00:06:17,120 --> 00:06:19,360
want to read a single byte

172
00:06:19,360 --> 00:06:22,000
of user input and this is pretty

173
00:06:22,000 --> 00:06:23,680
straightforward in linux what we can do

174
00:06:23,680 --> 00:06:25,840
is just have a resource call

175
00:06:25,840 --> 00:06:27,600
pass in standards

176
00:06:27,600 --> 00:06:29,600
in as the file descriptor 0 and then

177
00:06:29,600 --> 00:06:31,600
just get our value back and return it

178
00:06:31,600 --> 00:06:33,600
from the function however if we look at

179
00:06:33,600 --> 00:06:35,919
the same thing now for

180
00:06:35,919 --> 00:06:37,919
the serial interface of an embedded

181
00:06:37,919 --> 00:06:40,160
controller for example this would look

182
00:06:40,160 --> 00:06:42,479
much more complex in this case and we

183
00:06:42,479 --> 00:06:45,039
can see that we have already

184
00:06:45,039 --> 00:06:46,880
talked about some mio and here we can

185
00:06:46,880 --> 00:06:48,400
see that three different mmi oh

186
00:06:48,400 --> 00:06:50,560
registers are actually involved in

187
00:06:50,560 --> 00:06:52,479
reading this and so it's much more

188
00:06:52,479 --> 00:06:54,479
involved to do and we have some talking

189
00:06:54,479 --> 00:06:56,479
to the hardware to do in here as well

190
00:06:56,479 --> 00:06:58,479
and we'll go into what exactly this is

191
00:06:58,479 --> 00:06:59,440
doing

192
00:06:59,440 --> 00:07:00,639
in a bit

193
00:07:00,639 --> 00:07:02,639
but let's skip this for now

194
00:07:02,639 --> 00:07:05,120
so with these kind of um

195
00:07:05,120 --> 00:07:07,199
basic things out of the way then we want

196
00:07:07,199 --> 00:07:10,000
to go to rehosting and first of all um

197
00:07:10,000 --> 00:07:12,720
we want to define what rios thing is so

198
00:07:12,720 --> 00:07:14,319
i just read it out here it's the

199
00:07:14,319 --> 00:07:16,319
automatic creation of virtual execution

200
00:07:16,319 --> 00:07:18,160
environments for embedded firmware so

201
00:07:18,160 --> 00:07:19,280
what we

202
00:07:19,280 --> 00:07:21,199
basically want to do we want to take

203
00:07:21,199 --> 00:07:23,120
some piece of firmware out of the device

204
00:07:23,120 --> 00:07:24,560
and run it somewhere on the general

205
00:07:24,560 --> 00:07:26,720
purpose system for example an emulator

206
00:07:26,720 --> 00:07:29,280
something like that and

207
00:07:29,280 --> 00:07:31,520
and there are many reasons for this uh

208
00:07:31,520 --> 00:07:33,360
for why we would want to do this and we

209
00:07:33,360 --> 00:07:35,199
could go into all of these details and

210
00:07:35,199 --> 00:07:36,880
we actually wrote the paper about it

211
00:07:36,880 --> 00:07:39,360
remember i'm dabbling in some academia

212
00:07:39,360 --> 00:07:41,520
but we do not want to do it here instead

213
00:07:41,520 --> 00:07:42,639
we want to

214
00:07:42,639 --> 00:07:44,960
take it down to something a bit more

215
00:07:44,960 --> 00:07:47,120
streamlined and maybe easy to understand

216
00:07:47,120 --> 00:07:48,960
and also the main reason quite frankly

217
00:07:48,960 --> 00:07:50,720
why we want to do this so on the one

218
00:07:50,720 --> 00:07:52,319
hand we have those smart things

219
00:07:52,319 --> 00:07:54,639
so-called smart things such as a

220
00:07:54,639 --> 00:07:56,720
lightning bulb or

221
00:07:56,720 --> 00:07:59,599
a temperature sensor and these things we

222
00:07:59,599 --> 00:08:01,520
do not really get an ssh shell onto

223
00:08:01,520 --> 00:08:03,599
there we cannot deploy afl and then just

224
00:08:03,599 --> 00:08:06,479
run some some binary on there we have to

225
00:08:06,479 --> 00:08:08,000
have a

226
00:08:08,000 --> 00:08:09,599
bare metal

227
00:08:09,599 --> 00:08:11,520
system which just doesn't allow us

228
00:08:11,520 --> 00:08:14,319
anything uh in the traditional means and

229
00:08:14,319 --> 00:08:17,199
um they are very slow as well so i just

230
00:08:17,199 --> 00:08:19,840
got told uh outside here that somebody

231
00:08:19,840 --> 00:08:21,440
actually tried to pass test the router

232
00:08:21,440 --> 00:08:22,800
for example and that the chip was

233
00:08:22,800 --> 00:08:25,520
actually like brown afterwards so that's

234
00:08:25,520 --> 00:08:27,919
very cool to hear so maybe we also

235
00:08:27,919 --> 00:08:30,879
don't want to like blow these things up

236
00:08:30,879 --> 00:08:33,039
in the first place and if we turn to

237
00:08:33,039 --> 00:08:35,120
something more powerful like like cloud

238
00:08:35,120 --> 00:08:37,200
computation then we can just deploy it

239
00:08:37,200 --> 00:08:38,719
on a massive scale and whenever we get

240
00:08:38,719 --> 00:08:40,880
it into an emulator and actually are

241
00:08:40,880 --> 00:08:43,440
able to do this then um

242
00:08:43,440 --> 00:08:45,279
we can get buzzing to

243
00:08:45,279 --> 00:08:46,320
um

244
00:08:46,320 --> 00:08:49,200
to a very potent level here

245
00:08:49,200 --> 00:08:51,519
all right so with these things you might

246
00:08:51,519 --> 00:08:53,760
say okay toby you already set it we have

247
00:08:53,760 --> 00:08:56,560
an emulator we have the cloud uh we can

248
00:08:56,560 --> 00:08:59,920
just combine this right so we just take

249
00:08:59,920 --> 00:09:01,440
the emulator that we already have it's

250
00:09:01,440 --> 00:09:02,560
very good

251
00:09:02,560 --> 00:09:05,279
it's scalable and it's a community

252
00:09:05,279 --> 00:09:07,360
project which is developed and very

253
00:09:07,360 --> 00:09:09,120
mature why can't we just plug the

254
00:09:09,120 --> 00:09:12,000
firmware into qa move and then just do

255
00:09:12,000 --> 00:09:13,839
some fuzzing on this put some cloud

256
00:09:13,839 --> 00:09:15,279
service behind it and the box will

257
00:09:15,279 --> 00:09:17,200
follow eventually right

258
00:09:17,200 --> 00:09:19,279
but there sadly is a bit of a challenge

259
00:09:19,279 --> 00:09:21,760
with this and this challenge is

260
00:09:21,760 --> 00:09:24,480
mainly uh

261
00:09:24,480 --> 00:09:26,800
consisting of the complexity of hardware

262
00:09:26,800 --> 00:09:28,720
devices that we have faced and so if we

263
00:09:28,720 --> 00:09:30,640
think about the different vendors that

264
00:09:30,640 --> 00:09:31,519
would

265
00:09:31,519 --> 00:09:33,279
prevent or

266
00:09:33,279 --> 00:09:36,480
offer some device like this uh every one

267
00:09:36,480 --> 00:09:38,160
of those vendors will

268
00:09:38,160 --> 00:09:40,000
have different devices that they offer

269
00:09:40,000 --> 00:09:41,440
and then for every device we have

270
00:09:41,440 --> 00:09:43,920
different peripherals it wants to have

271
00:09:43,920 --> 00:09:45,600
timers it wants to have a serial

272
00:09:45,600 --> 00:09:48,080
interface it wants to talk via wi-fi and

273
00:09:48,080 --> 00:09:49,680
things like that so we have all these

274
00:09:49,680 --> 00:09:51,279
different peripherals and then

275
00:09:51,279 --> 00:09:53,120
afterwards each peripheral also has

276
00:09:53,120 --> 00:09:55,279
different memory registers and this kind

277
00:09:55,279 --> 00:09:57,760
of multiplies up and if we kind of see

278
00:09:57,760 --> 00:09:59,839
what this entails in the documentation

279
00:09:59,839 --> 00:10:01,680
which we sometimes have available not

280
00:10:01,680 --> 00:10:04,079
always then we can see it the details

281
00:10:04,079 --> 00:10:06,160
are not really important here but we can

282
00:10:06,160 --> 00:10:08,640
see that there are device regions and

283
00:10:08,640 --> 00:10:10,880
each device region has a peripheral

284
00:10:10,880 --> 00:10:12,880
region and each and then which we do not

285
00:10:12,880 --> 00:10:14,320
even see here it's different on my o

286
00:10:14,320 --> 00:10:17,440
register so kind of explodes and

287
00:10:17,440 --> 00:10:19,600
some of these devices are fully

288
00:10:19,600 --> 00:10:22,079
implemented if we look at some system

289
00:10:22,079 --> 00:10:24,720
for example a very well established one

290
00:10:24,720 --> 00:10:26,240
like in raspberry pi we have a full

291
00:10:26,240 --> 00:10:27,920
implementation of all these registers

292
00:10:27,920 --> 00:10:30,160
but it's a huge amount of work and so if

293
00:10:30,160 --> 00:10:31,600
we think about that we have all these

294
00:10:31,600 --> 00:10:34,560
small little devices which do not uh

295
00:10:34,560 --> 00:10:36,800
really are not really covered by this

296
00:10:36,800 --> 00:10:38,160
then we might not even find an

297
00:10:38,160 --> 00:10:40,880
implementation in something like um and

298
00:10:40,880 --> 00:10:43,600
um then what makes it kind of worse is

299
00:10:43,600 --> 00:10:45,200
that a lot of cases we do not even have

300
00:10:45,200 --> 00:10:46,959
documentation so even if we wanted to

301
00:10:46,959 --> 00:10:48,560
comb through like a thousand page

302
00:10:48,560 --> 00:10:50,079
document which describes all these

303
00:10:50,079 --> 00:10:52,399
things then we couldn't do it even if we

304
00:10:52,399 --> 00:10:54,160
wanted if we don't have documentation in

305
00:10:54,160 --> 00:10:56,399
the first place so this kind of begs the

306
00:10:56,399 --> 00:10:57,839
question we have so many devices and we

307
00:10:57,839 --> 00:10:59,920
want to secure the firmware that is

308
00:10:59,920 --> 00:11:01,440
running on them and it's very hard to

309
00:11:01,440 --> 00:11:03,839
analyze them so how can we automate

310
00:11:03,839 --> 00:11:07,680
emulating these systems uh in the end

311
00:11:07,680 --> 00:11:09,200
and as it turns out different people

312
00:11:09,200 --> 00:11:11,279
have looked at this problem before and

313
00:11:11,279 --> 00:11:13,279
how can we kind of model this hardware

314
00:11:13,279 --> 00:11:15,200
for systems that are not quite linux

315
00:11:15,200 --> 00:11:17,120
like systems and we cannot use any

316
00:11:17,120 --> 00:11:19,279
abstractions um that we are used to and

317
00:11:19,279 --> 00:11:21,519
cannot really apply the tools that we

318
00:11:21,519 --> 00:11:23,839
are used to as well and which have also

319
00:11:23,839 --> 00:11:27,120
proven very reliable sources of

320
00:11:27,120 --> 00:11:28,560
of finding

321
00:11:28,560 --> 00:11:30,240
and so one of the first things that i

322
00:11:30,240 --> 00:11:32,480
would like to mention here is uh what's

323
00:11:32,480 --> 00:11:34,079
is called pretender so what they

324
00:11:34,079 --> 00:11:36,079
basically try is to take a piece of

325
00:11:36,079 --> 00:11:38,079
hardware run it and take some traces

326
00:11:38,079 --> 00:11:40,480
from it and then try to understand based

327
00:11:40,480 --> 00:11:41,839
on the trace that we have seen and that

328
00:11:41,839 --> 00:11:44,560
we know are valid can we figure out how

329
00:11:44,560 --> 00:11:46,720
the hardware behavior works and then

330
00:11:46,720 --> 00:11:48,959
people took it a bit further with ps4m

331
00:11:48,959 --> 00:11:51,040
and part emu where you take it in a

332
00:11:51,040 --> 00:11:53,440
fully like virtual domain you do not use

333
00:11:53,440 --> 00:11:56,160
any hardware anymore but you uh see what

334
00:11:56,160 --> 00:11:57,920
the excess patterns are in something

335
00:11:57,920 --> 00:11:59,760
like ua moon but cream without actual

336
00:11:59,760 --> 00:12:02,480
devices and then you kind of monitor

337
00:12:02,480 --> 00:12:04,320
what communication is going on and then

338
00:12:04,320 --> 00:12:07,279
you may be able to derive from these

339
00:12:07,279 --> 00:12:09,279
excess patterns what the behavior should

340
00:12:09,279 --> 00:12:11,120
be and then people

341
00:12:11,120 --> 00:12:12,399
even further

342
00:12:12,399 --> 00:12:14,000
where we use some

343
00:12:14,000 --> 00:12:16,399
program analysis techniques um like

344
00:12:16,399 --> 00:12:18,959
symbolic execution and to do this kind

345
00:12:18,959 --> 00:12:20,720
of modeling for us so whenever we have

346
00:12:20,720 --> 00:12:23,360
an excess can we figure it out by

347
00:12:23,360 --> 00:12:25,279
analyzing this success and then seeing

348
00:12:25,279 --> 00:12:27,120
okay does the code tell us something

349
00:12:27,120 --> 00:12:30,079
about what we suppose to do

350
00:12:30,079 --> 00:12:31,839
and then of course we're in 2022 and we

351
00:12:31,839 --> 00:12:33,519
have password and this is kind of the

352
00:12:33,519 --> 00:12:35,519
prototype that we want to talk about and

353
00:12:35,519 --> 00:12:38,800
the work that i've been performing

354
00:12:38,800 --> 00:12:40,720
um all right

355
00:12:40,720 --> 00:12:43,120
so further rehosting via the fuzz

356
00:12:43,120 --> 00:12:45,519
envelope so let's recap for a bit uh

357
00:12:45,519 --> 00:12:48,240
what have these previous works done uh

358
00:12:48,240 --> 00:12:50,160
on a kind of

359
00:12:50,160 --> 00:12:51,040
um

360
00:12:51,040 --> 00:12:54,079
broader level so these uh

361
00:12:54,079 --> 00:12:55,839
these prototypes have looked at this

362
00:12:55,839 --> 00:12:57,760
problem in a two-step way so first of

363
00:12:57,760 --> 00:12:59,120
all what we want to do is we take a

364
00:12:59,120 --> 00:13:00,880
piece of firmware and then we re-host it

365
00:13:00,880 --> 00:13:02,800
so that we can run it in an emulator

366
00:13:02,800 --> 00:13:05,200
then afterwards we can put a fuzzer to

367
00:13:05,200 --> 00:13:08,720
it and have the father do the security

368
00:13:08,720 --> 00:13:11,440
auditing for us and um our

369
00:13:11,440 --> 00:13:13,120
the question kind of that's begging here

370
00:13:13,120 --> 00:13:14,880
is can we also integrate the father from

371
00:13:14,880 --> 00:13:16,240
the star can we not treat it as a

372
00:13:16,240 --> 00:13:19,440
two-way process but i have the father in

373
00:13:19,440 --> 00:13:20,639
the

374
00:13:20,639 --> 00:13:23,519
in the loop um directly

375
00:13:23,519 --> 00:13:26,639
so the idea behind this would be that

376
00:13:26,639 --> 00:13:28,560
modern fuzzers are already very good at

377
00:13:28,560 --> 00:13:30,480
kind of identifying what is useful for

378
00:13:30,480 --> 00:13:32,000
programs so we can take something like

379
00:13:32,000 --> 00:13:34,320
coverage feedback and whenever we find

380
00:13:34,320 --> 00:13:36,880
coverage feedback within a

381
00:13:36,880 --> 00:13:38,880
program then something is likely or an

382
00:13:38,880 --> 00:13:41,519
input is likely to be useful for it and

383
00:13:41,519 --> 00:13:43,120
the idea here is can we have used this

384
00:13:43,120 --> 00:13:44,959
for modeling as well can we just have

385
00:13:44,959 --> 00:13:48,160
the fuzzer do the heavy work for us and

386
00:13:48,160 --> 00:13:50,720
and do this but this again if we think

387
00:13:50,720 --> 00:13:54,959
about this a bit more it has some issues

388
00:13:54,959 --> 00:13:57,360
concerned with it and the first thing is

389
00:13:57,360 --> 00:13:58,160
that

390
00:13:58,160 --> 00:14:00,800
while not fully random puzzles

391
00:14:00,800 --> 00:14:03,680
still rely on a lot of uh like rolling a

392
00:14:03,680 --> 00:14:05,920
dice basically if you look at the source

393
00:14:05,920 --> 00:14:07,680
code of afl or

394
00:14:07,680 --> 00:14:10,560
plus it's not quite 100 random but um

395
00:14:10,560 --> 00:14:12,240
the mutations

396
00:14:12,240 --> 00:14:15,440
try to modify it in a lot of ways and

397
00:14:15,440 --> 00:14:17,440
what comes out is

398
00:14:17,440 --> 00:14:19,600
more or less a random behavior and then

399
00:14:19,600 --> 00:14:20,800
um

400
00:14:20,800 --> 00:14:22,399
this makes it very hard if you have a

401
00:14:22,399 --> 00:14:24,320
lot of choices to kind of find the right

402
00:14:24,320 --> 00:14:26,320
thing in the first place and firmware

403
00:14:26,320 --> 00:14:28,800
makes it a bit harder still because as

404
00:14:28,800 --> 00:14:32,160
we will see there is a lot of low level

405
00:14:32,160 --> 00:14:34,079
like firmware and hardware chatter going

406
00:14:34,079 --> 00:14:35,760
on which kind of explodes the state

407
00:14:35,760 --> 00:14:37,839
space a lot which is kind of needlessly

408
00:14:37,839 --> 00:14:40,720
so and i will see what this means here

409
00:14:40,720 --> 00:14:43,440
so let's look at code example and what

410
00:14:43,440 --> 00:14:45,760
you can see on the left side it's a

411
00:14:45,760 --> 00:14:47,760
function called perform and then on the

412
00:14:47,760 --> 00:14:49,199
right side we have the control flow

413
00:14:49,199 --> 00:14:51,040
graph or cfg

414
00:14:51,040 --> 00:14:52,880
that represents the different path

415
00:14:52,880 --> 00:14:54,800
through it so what we can see is that we

416
00:14:54,800 --> 00:14:57,120
have an mio operation

417
00:14:57,120 --> 00:14:59,040
register which is curate so the firmware

418
00:14:59,040 --> 00:15:01,600
will look okay what kind of operation

419
00:15:01,600 --> 00:15:03,680
does the hardware want to do or what

420
00:15:03,680 --> 00:15:06,399
state is it in how should i behave based

421
00:15:06,399 --> 00:15:08,079
on that and

422
00:15:08,079 --> 00:15:10,560
depending on what operation comes in we

423
00:15:10,560 --> 00:15:13,120
can step through this and see okay if we

424
00:15:13,120 --> 00:15:14,800
do the d4 case it would do some

425
00:15:14,800 --> 00:15:18,000
housekeeping within uh with some

426
00:15:18,000 --> 00:15:20,240
coverage here assigned to it then we

427
00:15:20,240 --> 00:15:22,000
come to the b case and there is some

428
00:15:22,000 --> 00:15:24,000
special handling to it depending on the

429
00:15:24,000 --> 00:15:25,680
status of its special then there's some

430
00:15:25,680 --> 00:15:27,440
special handling and otherwise we have

431
00:15:27,440 --> 00:15:29,759
the default one so we can step through

432
00:15:29,759 --> 00:15:31,120
this as well

433
00:15:31,120 --> 00:15:31,839
so

434
00:15:31,839 --> 00:15:33,600
as we said the idea is to kind of

435
00:15:33,600 --> 00:15:35,360
involve the puzzler in here so what do

436
00:15:35,360 --> 00:15:38,480
we do if or how does this look like in

437
00:15:38,480 --> 00:15:41,360
case the fuzzer is choosing some values

438
00:15:41,360 --> 00:15:43,040
for us and as i said there is some

439
00:15:43,040 --> 00:15:45,600
randomness in here so we can kind of say

440
00:15:45,600 --> 00:15:48,320
okay we just pick some values it's not

441
00:15:48,320 --> 00:15:50,720
quite random in the normal case but we

442
00:15:50,720 --> 00:15:52,560
just pick some random values here and

443
00:15:52,560 --> 00:15:54,560
then we can see okay what kind of fixed

444
00:15:54,560 --> 00:15:56,639
degree it gets and we can highlight them

445
00:15:56,639 --> 00:16:00,079
here and then plot them in this coverage

446
00:16:00,079 --> 00:16:01,519
here and

447
00:16:01,519 --> 00:16:04,000
the greener or the more dark green

448
00:16:04,000 --> 00:16:06,079
coverage i know it is the more it was

449
00:16:06,079 --> 00:16:08,079
visited and as we can see we have some

450
00:16:08,079 --> 00:16:10,800
parts of this coverage not even

451
00:16:10,800 --> 00:16:12,399
occurring at all and this might be

452
00:16:12,399 --> 00:16:14,639
problematic in case we have a bug hiding

453
00:16:14,639 --> 00:16:16,560
in some special case for example we do

454
00:16:16,560 --> 00:16:18,639
not get any coverage out of here

455
00:16:18,639 --> 00:16:21,199
so this kind of asks the question or

456
00:16:21,199 --> 00:16:22,720
brings up this

457
00:16:22,720 --> 00:16:24,639
idea of the paradox of choice so on the

458
00:16:24,639 --> 00:16:26,240
one hand we want to give the fuzzer all

459
00:16:26,240 --> 00:16:28,320
the flexibility in the world we do not

460
00:16:28,320 --> 00:16:30,560
take away any parts because especially

461
00:16:30,560 --> 00:16:31,519
the

462
00:16:31,519 --> 00:16:34,079
specific or special paths could contain

463
00:16:34,079 --> 00:16:36,320
bugs as well but at the same time if we

464
00:16:36,320 --> 00:16:38,320
give it too big of a search space then

465
00:16:38,320 --> 00:16:40,160
we cannot really do anything and the

466
00:16:40,160 --> 00:16:41,680
question or the puzzle will not be able

467
00:16:41,680 --> 00:16:44,880
to find them and the question here is

468
00:16:44,880 --> 00:16:47,279
can we reduce these available choices a

469
00:16:47,279 --> 00:16:49,759
bit and this is where a little toby on

470
00:16:49,759 --> 00:16:52,240
the start of the academic work started

471
00:16:52,240 --> 00:16:55,839
going on the internet looking for some

472
00:16:55,839 --> 00:16:57,920
some quotes for inspiration and the

473
00:16:57,920 --> 00:16:59,600
first one that he found was look for

474
00:16:59,600 --> 00:17:02,000
chances to take the less covered pass

475
00:17:02,000 --> 00:17:04,079
and we had a second from the same author

476
00:17:04,079 --> 00:17:04,959
uh

477
00:17:04,959 --> 00:17:07,520
we do not still or yet know who it was

478
00:17:07,520 --> 00:17:09,599
it was you will regret the paths you

479
00:17:09,599 --> 00:17:10,720
didn't cover

480
00:17:10,720 --> 00:17:14,160
and then at the end also a keep it

481
00:17:14,160 --> 00:17:16,720
simple stupid and as it turns out was

482
00:17:16,720 --> 00:17:18,559
already called our lord and savior by

483
00:17:18,559 --> 00:17:20,640
then before in the keynotes because of

484
00:17:20,640 --> 00:17:23,760
course afl the little fuzzing uh

485
00:17:23,760 --> 00:17:26,319
american fuzzy love and this kind of got

486
00:17:26,319 --> 00:17:28,960
me thinking so you have keep it simple

487
00:17:28,960 --> 00:17:30,400
stupid so

488
00:17:30,400 --> 00:17:32,640
can't we kind of make this live of the

489
00:17:32,640 --> 00:17:35,039
further easier just make it simpler and

490
00:17:35,039 --> 00:17:36,559
this is where kind of the idea stems

491
00:17:36,559 --> 00:17:39,120
from and we can look at what this

492
00:17:39,120 --> 00:17:41,440
entails and looking at this code again

493
00:17:41,440 --> 00:17:43,600
um so if we look at this code as we went

494
00:17:43,600 --> 00:17:44,799
through it was

495
00:17:44,799 --> 00:17:48,320
a case a case b and d4 k's kind of

496
00:17:48,320 --> 00:17:50,240
scenario so what the fuzzer should kind

497
00:17:50,240 --> 00:17:51,200
of be

498
00:17:51,200 --> 00:17:53,120
aware of is that there are three choices

499
00:17:53,120 --> 00:17:55,360
we do not really have a big search space

500
00:17:55,360 --> 00:17:57,120
we have just three choices based on our

501
00:17:57,120 --> 00:17:59,039
mmio and what if we change this

502
00:17:59,039 --> 00:18:01,280
representation for uh the little bunny a

503
00:18:01,280 --> 00:18:03,679
bit here and then we just spray out the

504
00:18:03,679 --> 00:18:05,919
ones which do not matter so we just have

505
00:18:05,919 --> 00:18:08,000
a b and c and b is the representative

506
00:18:08,000 --> 00:18:10,559
for the default case here and if we i

507
00:18:10,559 --> 00:18:12,880
just let the puzzle choose between one

508
00:18:12,880 --> 00:18:14,480
of these three

509
00:18:14,480 --> 00:18:16,559
options now what we can do is go through

510
00:18:16,559 --> 00:18:19,360
the same scenarios again and then we get

511
00:18:19,360 --> 00:18:23,039
a and b here and then we get two or a

512
00:18:23,039 --> 00:18:24,559
and default and then we get to the b

513
00:18:24,559 --> 00:18:27,200
case and what is interesting is that we

514
00:18:27,200 --> 00:18:29,039
have the same kind of situation here as

515
00:18:29,039 --> 00:18:31,280
well we can kind of nest this idea so

516
00:18:31,280 --> 00:18:32,559
here we have an

517
00:18:32,559 --> 00:18:35,120
another if else statement depending on

518
00:18:35,120 --> 00:18:37,280
whether we want to status the special

519
00:18:37,280 --> 00:18:39,840
case or not the special case and this is

520
00:18:39,840 --> 00:18:41,200
again just a

521
00:18:41,200 --> 00:18:42,799
choice between special and not special

522
00:18:42,799 --> 00:18:44,480
so what do we give the father if we

523
00:18:44,480 --> 00:18:46,400
could find a some modeling approach

524
00:18:46,400 --> 00:18:48,160
which just gave us one of these two

525
00:18:48,160 --> 00:18:50,480
choices we could just have the father

526
00:18:50,480 --> 00:18:52,640
choose the one or the other and the

527
00:18:52,640 --> 00:18:54,559
interesting thing is that now it's much

528
00:18:54,559 --> 00:18:56,240
easier for the fuzzer to find all these

529
00:18:56,240 --> 00:18:59,360
different um coverage parts and this

530
00:18:59,360 --> 00:19:00,880
allows us

531
00:19:00,880 --> 00:19:03,600
to find bugs mainly

532
00:19:03,600 --> 00:19:06,240
all right this brings us to the modeling

533
00:19:06,240 --> 00:19:07,679
component of

534
00:19:07,679 --> 00:19:08,960
fuzzwear and the different models and

535
00:19:08,960 --> 00:19:10,559
this it turns out we have already seen

536
00:19:10,559 --> 00:19:12,160
one so this is what we call the set

537
00:19:12,160 --> 00:19:14,320
model it's um

538
00:19:14,320 --> 00:19:15,840
it just gives the fuzzer

539
00:19:15,840 --> 00:19:17,600
precomputes the set of choices and then

540
00:19:17,600 --> 00:19:19,600
the father can just choose between them

541
00:19:19,600 --> 00:19:21,679
uh based on some fighter filing input

542
00:19:21,679 --> 00:19:23,760
for example and uh let's complete this

543
00:19:23,760 --> 00:19:25,440
picture of it so we have some more

544
00:19:25,440 --> 00:19:27,520
models in here um

545
00:19:27,520 --> 00:19:29,679
so let's look at this serial getc

546
00:19:29,679 --> 00:19:31,600
function again and so i go through these

547
00:19:31,600 --> 00:19:33,760
different lines a bit more detail so

548
00:19:33,760 --> 00:19:35,600
here what we can see is that first of

549
00:19:35,600 --> 00:19:37,440
all the firmware has to make sure that

550
00:19:37,440 --> 00:19:39,120
the hardware actually has some data

551
00:19:39,120 --> 00:19:41,440
available so it stays in a busy loop

552
00:19:41,440 --> 00:19:43,440
until this data is available and it will

553
00:19:43,440 --> 00:19:44,880
actually get stuck in this busy loop

554
00:19:44,880 --> 00:19:47,280
until the data is available and

555
00:19:47,280 --> 00:19:49,440
in case we want to do fuzzing it's clear

556
00:19:49,440 --> 00:19:51,120
we do not want to get stuck in any loops

557
00:19:51,120 --> 00:19:53,280
we just want to go on so what we do here

558
00:19:53,280 --> 00:19:55,280
is apply what we call a constant model

559
00:19:55,280 --> 00:19:58,000
and just have the excess return it has

560
00:19:58,000 --> 00:19:59,919
data if we can show by some analysis

561
00:19:59,919 --> 00:20:02,240
that this is just

562
00:20:02,240 --> 00:20:03,760
being stuck in the loop without anything

563
00:20:03,760 --> 00:20:06,320
happening then we can safely just assign

564
00:20:06,320 --> 00:20:08,159
the constant value and not have to

565
00:20:08,159 --> 00:20:10,159
involve the puzzle so this in this case

566
00:20:10,159 --> 00:20:11,679
we make it really simple for the puzzle

567
00:20:11,679 --> 00:20:13,120
because it doesn't have to do anything

568
00:20:13,120 --> 00:20:15,360
in this case and the interesting thing

569
00:20:15,360 --> 00:20:16,480
here is that

570
00:20:16,480 --> 00:20:18,559
we have an a four byte access before so

571
00:20:18,559 --> 00:20:20,000
the father would have given us 4 bytes

572
00:20:20,000 --> 00:20:21,679
but now we have just 0 because we can

573
00:20:21,679 --> 00:20:23,679
handle it by ourselves

574
00:20:23,679 --> 00:20:26,000
and this kind of applies to

575
00:20:26,000 --> 00:20:27,280
the seconds

576
00:20:27,280 --> 00:20:29,520
here as well what we have here is that

577
00:20:29,520 --> 00:20:31,440
we have a gpio value which represents

578
00:20:31,440 --> 00:20:33,120
something like an led lighting up and

579
00:20:33,120 --> 00:20:35,679
indicating uh some activity on this huge

580
00:20:35,679 --> 00:20:38,240
interface for example and

581
00:20:38,240 --> 00:20:39,840
this is what we

582
00:20:39,840 --> 00:20:41,840
what we can see here is that

583
00:20:41,840 --> 00:20:44,320
this hardware value is first read then

584
00:20:44,320 --> 00:20:46,080
modified and written back and everything

585
00:20:46,080 --> 00:20:48,080
kind of stays in the hardware domain so

586
00:20:48,080 --> 00:20:49,840
we do not really care about this because

587
00:20:49,840 --> 00:20:52,240
the firmware doesn't take anything into

588
00:20:52,240 --> 00:20:54,159
account in its logic if we can show this

589
00:20:54,159 --> 00:20:56,720
again we can just uh

590
00:20:56,720 --> 00:20:59,280
keep this as a normal memory access here

591
00:20:59,280 --> 00:21:00,799
we call this ambassador model so

592
00:21:00,799 --> 00:21:02,480
whenever the humor writes something and

593
00:21:02,480 --> 00:21:04,240
reads it back it gets the same value and

594
00:21:04,240 --> 00:21:05,919
the puzzle still doesn't have to be

595
00:21:05,919 --> 00:21:07,360
involved in here

596
00:21:07,360 --> 00:21:08,799
and then finally we have this data

597
00:21:08,799 --> 00:21:10,320
access we see we have a four by eight

598
00:21:10,320 --> 00:21:12,400
excess first but then we are masking off

599
00:21:12,400 --> 00:21:15,039
only one byte so we only have to um have

600
00:21:15,039 --> 00:21:17,200
the father give us one instead of four

601
00:21:17,200 --> 00:21:19,120
kind of if we summarize this we can

602
00:21:19,120 --> 00:21:21,120
reduce the input

603
00:21:21,120 --> 00:21:23,120
space by uh quite a bit because the

604
00:21:23,120 --> 00:21:25,600
buzzer before it had to deal with all

605
00:21:25,600 --> 00:21:26,799
these different things and without

606
00:21:26,799 --> 00:21:28,799
changing the program logic we can just

607
00:21:28,799 --> 00:21:30,640
reduce it by over 90

608
00:21:30,640 --> 00:21:33,679
and um kind of what we had have now is

609
00:21:33,679 --> 00:21:35,520
we have a function which takes one byte

610
00:21:35,520 --> 00:21:36,960
of input and just takes one byte of

611
00:21:36,960 --> 00:21:38,559
fuzzing input as well so it's very

612
00:21:38,559 --> 00:21:40,559
familiar to the fuzzer now as it would

613
00:21:40,559 --> 00:21:44,240
look like in a linux system for example

614
00:21:44,240 --> 00:21:47,200
all right if we put this together in a

615
00:21:47,200 --> 00:21:50,000
little diagram here we have the

616
00:21:50,000 --> 00:21:52,480
um the full system overview so in the

617
00:21:52,480 --> 00:21:54,159
middle if you're not familiar

618
00:21:54,159 --> 00:21:55,840
with it it's

619
00:21:55,840 --> 00:21:58,000
the emulator called unicorn engine and

620
00:21:58,000 --> 00:22:01,679
what it gives you is um basically

621
00:22:01,679 --> 00:22:03,280
instruction execution without any

622
00:22:03,280 --> 00:22:05,039
hardware components around it so it's a

623
00:22:05,039 --> 00:22:07,760
stripped version of qa and at its core

624
00:22:07,760 --> 00:22:09,520
and what it's doing is just

625
00:22:09,520 --> 00:22:11,200
executing the swimmer image and then

626
00:22:11,200 --> 00:22:12,960
whenever there is any hardware excesses

627
00:22:12,960 --> 00:22:15,280
it just forwards it to the puzzle again

628
00:22:15,280 --> 00:22:17,039
and then if we see any hardware access

629
00:22:17,039 --> 00:22:19,039
which we have not seen before what we

630
00:22:19,039 --> 00:22:20,799
can do is have

631
00:22:20,799 --> 00:22:22,880
symbolic execution in this case our

632
00:22:22,880 --> 00:22:24,799
modeling components perform some

633
00:22:24,799 --> 00:22:26,720
analysis and see whether we can fit one

634
00:22:26,720 --> 00:22:28,480
of these models which we have seen

635
00:22:28,480 --> 00:22:29,679
before

636
00:22:29,679 --> 00:22:30,559
and

637
00:22:30,559 --> 00:22:32,240
this kind of gets

638
00:22:32,240 --> 00:22:34,000
fed back into the emulator while it's

639
00:22:34,000 --> 00:22:36,159
running and then it can afterwards

640
00:22:36,159 --> 00:22:37,280
handle

641
00:22:37,280 --> 00:22:39,039
some of the excesses transparently or

642
00:22:39,039 --> 00:22:41,440
boil them down and it's kind of a loop

643
00:22:41,440 --> 00:22:44,240
going on as soon as long as we have more

644
00:22:44,240 --> 00:22:46,159
mio registers or kind of hardware

645
00:22:46,159 --> 00:22:48,320
interfacing that has not been previously

646
00:22:48,320 --> 00:22:49,280
discovered

647
00:22:49,280 --> 00:22:50,880
and what we

648
00:22:50,880 --> 00:22:53,520
did is that we wrote in kind of complex

649
00:22:53,520 --> 00:22:55,039
prototype for this

650
00:22:55,039 --> 00:22:57,360
it's about 10 000 lines of source code

651
00:22:57,360 --> 00:23:00,639
and it's also available

652
00:23:01,360 --> 00:23:04,080
so with this of course let's get further

653
00:23:04,080 --> 00:23:05,360
and

654
00:23:05,360 --> 00:23:07,200
what is important for fuzzing is

655
00:23:07,200 --> 00:23:09,120
obviously and as an academic especially

656
00:23:09,120 --> 00:23:11,120
to have very novel ideas about how to go

657
00:23:11,120 --> 00:23:13,679
about fuzzing so having to set up

658
00:23:13,679 --> 00:23:15,360
something and then fuzzing something and

659
00:23:15,360 --> 00:23:16,880
how towards preaching precious is

660
00:23:16,880 --> 00:23:18,400
something that nobody would ever have

661
00:23:18,400 --> 00:23:21,120
come up before with before so

662
00:23:21,120 --> 00:23:23,280
we in the academia are all about giving

663
00:23:23,280 --> 00:23:25,520
some novel ideas to everybody right so

664
00:23:25,520 --> 00:23:28,080
uh that's uh what we did here no of

665
00:23:28,080 --> 00:23:30,640
course uh what we at least do is that we

666
00:23:30,640 --> 00:23:33,039
supply some um

667
00:23:33,039 --> 00:23:35,280
utilities for what we already know is

668
00:23:35,280 --> 00:23:37,840
required to do this housing workflow and

669
00:23:37,840 --> 00:23:40,480
without like going into these

670
00:23:40,480 --> 00:23:42,960
right now in just theory let's look at

671
00:23:42,960 --> 00:23:44,799
some examples here

672
00:23:44,799 --> 00:23:47,840
and i have a little demo

673
00:23:47,840 --> 00:23:49,760
prepared so what does it look like to

674
00:23:49,760 --> 00:23:52,080
use fastback so first of all we want to

675
00:23:52,080 --> 00:23:54,559
do a work on password so we are actually

676
00:23:54,559 --> 00:23:56,640
in the virtual environment to use it and

677
00:23:56,640 --> 00:23:58,799
then we want to configure

678
00:23:58,799 --> 00:24:01,520
um setup configuration for the binary

679
00:24:01,520 --> 00:24:04,159
file using power gen config and then we

680
00:24:04,159 --> 00:24:06,960
can see we have some configuration files

681
00:24:06,960 --> 00:24:09,360
created and i can now use the pipeline

682
00:24:09,360 --> 00:24:12,719
component to do some fuzzing

683
00:24:15,919 --> 00:24:18,159
so after some setup what we can see that

684
00:24:18,159 --> 00:24:20,400
as we would expect we have some um some

685
00:24:20,400 --> 00:24:22,400
coverage coming in some translation

686
00:24:22,400 --> 00:24:24,720
blocks or basic blocks being discovered

687
00:24:24,720 --> 00:24:26,159
and what we can see afterwards is that

688
00:24:26,159 --> 00:24:29,279
we also have some models being created

689
00:24:29,279 --> 00:24:31,279
and so this is the the modeling

690
00:24:31,279 --> 00:24:32,559
component feeding back some

691
00:24:32,559 --> 00:24:34,720
configuration snippets to

692
00:24:34,720 --> 00:24:36,960
the emulator which is then consumed by

693
00:24:36,960 --> 00:24:39,440
the emulator to set it up for for a more

694
00:24:39,440 --> 00:24:42,000
efficient um workflow

695
00:24:42,000 --> 00:24:43,919
and then if we wait for a little bit

696
00:24:43,919 --> 00:24:44,720
more

697
00:24:44,720 --> 00:24:46,240
we find some more coverage afterwards

698
00:24:46,240 --> 00:24:48,159
this would be expected and this is where

699
00:24:48,159 --> 00:24:50,720
we can also stop the puzzle for the

700
00:24:50,720 --> 00:24:52,720
um purpose of this demonstration then we

701
00:24:52,720 --> 00:24:54,720
can see we have a password project

702
00:24:54,720 --> 00:24:56,400
directory which contains all these

703
00:24:56,400 --> 00:24:58,320
results from

704
00:24:58,320 --> 00:25:02,240
and here we can query the red curve

705
00:25:02,240 --> 00:25:04,000
so that we can see

706
00:25:04,000 --> 00:25:05,360
what kind of functions have we already

707
00:25:05,360 --> 00:25:08,400
covered and we can also replay an input

708
00:25:08,400 --> 00:25:10,400
based on coverage here

709
00:25:10,400 --> 00:25:13,840
and get the behavior of it

710
00:25:13,840 --> 00:25:15,760
second thing that we can kind of look at

711
00:25:15,760 --> 00:25:19,039
is a is the the models that were created

712
00:25:19,039 --> 00:25:22,600
themselves and you can see in the mio

713
00:25:22,600 --> 00:25:25,039
config.yml we have different ones of

714
00:25:25,039 --> 00:25:26,880
these uh models are constant

715
00:25:26,880 --> 00:25:28,240
pass-through there's a set model in

716
00:25:28,240 --> 00:25:29,600
there as well

717
00:25:29,600 --> 00:25:31,840
and so on so and then of course if we

718
00:25:31,840 --> 00:25:33,840
have run this for a bit longer time and

719
00:25:33,840 --> 00:25:36,559
not only 30 seconds we can go into a

720
00:25:36,559 --> 00:25:38,000
project which has run for a little bit

721
00:25:38,000 --> 00:25:39,600
longer time and went through some

722
00:25:39,600 --> 00:25:41,440
configuration updates and then we found

723
00:25:41,440 --> 00:25:43,279
some crashes for example then we can

724
00:25:43,279 --> 00:25:45,360
also replay and analyze these pressures

725
00:25:45,360 --> 00:25:47,520
afterwards and look at what the behavior

726
00:25:47,520 --> 00:25:50,000
is and then we can see here

727
00:25:50,000 --> 00:25:52,240
that we have the refresh state and then

728
00:25:52,240 --> 00:25:54,080
can see what the reason for it was in

729
00:25:54,080 --> 00:25:55,679
this case we can see it's a bit of a

730
00:25:55,679 --> 00:25:57,840
messed up pc so and this is a stack

731
00:25:57,840 --> 00:26:00,000
based buffer flow in this example but

732
00:26:00,000 --> 00:26:02,559
we're not going to go into this exactly

733
00:26:02,559 --> 00:26:05,039
okay this is that for the demo

734
00:26:05,039 --> 00:26:06,720
and um

735
00:26:06,720 --> 00:26:08,480
let's go and look for some bugs that we

736
00:26:08,480 --> 00:26:09,679
found with it

737
00:26:09,679 --> 00:26:11,440
so first of all it's important what kind

738
00:26:11,440 --> 00:26:13,360
of system did we choose in the first

739
00:26:13,360 --> 00:26:15,200
place and

740
00:26:15,200 --> 00:26:16,559
as it turns out what we found

741
00:26:16,559 --> 00:26:18,799
interesting is kind of the

742
00:26:18,799 --> 00:26:20,880
systems which other firmware uses

743
00:26:20,880 --> 00:26:23,440
afterwards to build upon and then have

744
00:26:23,440 --> 00:26:25,919
some embedded operating systems which

745
00:26:25,919 --> 00:26:28,240
come with a network stack um which then

746
00:26:28,240 --> 00:26:30,240
allow small power devices to be

747
00:26:30,240 --> 00:26:32,400
connected and these are

748
00:26:32,400 --> 00:26:34,640
implementations

749
00:26:34,640 --> 00:26:36,320
of such operating systems which are

750
00:26:36,320 --> 00:26:39,200
connectivity driven so sapphire rts and

751
00:26:39,200 --> 00:26:42,080
then contiki ng on the other end and it

752
00:26:42,080 --> 00:26:43,760
comes with a lot of

753
00:26:43,760 --> 00:26:45,520
connectivity features something like

754
00:26:45,520 --> 00:26:48,640
bluetooth energy wi-fi 6 lowpan

755
00:26:48,640 --> 00:26:50,080
different companies are behind this

756
00:26:50,080 --> 00:26:51,840
because they are interested in having a

757
00:26:51,840 --> 00:26:54,080
joint core of a high quality software of

758
00:26:54,080 --> 00:26:56,240
course and they also have a security

759
00:26:56,240 --> 00:26:58,159
development life cycle and the team was

760
00:26:58,159 --> 00:27:00,400
is also very cool to work with so great

761
00:27:00,400 --> 00:27:02,400
projects uh both of them and we found

762
00:27:02,400 --> 00:27:03,679
some bugs in here and we want to

763
00:27:03,679 --> 00:27:05,760
actually look at those and

764
00:27:05,760 --> 00:27:08,080
as we kind of go into all these bugs in

765
00:27:08,080 --> 00:27:10,640
detail we want to frame them in the

766
00:27:10,640 --> 00:27:12,799
terms of famous last words or what the

767
00:27:12,799 --> 00:27:14,240
firmware assumption could have been just

768
00:27:14,240 --> 00:27:16,799
before this kind of issue record so the

769
00:27:16,799 --> 00:27:18,640
very first one let's start with this it

770
00:27:18,640 --> 00:27:20,720
says these two objects will never be the

771
00:27:20,720 --> 00:27:22,799
same which kind of resulted in one of

772
00:27:22,799 --> 00:27:24,640
the bugs which we have then we have a

773
00:27:24,640 --> 00:27:26,880
second one we know something about

774
00:27:26,880 --> 00:27:28,480
something like a data structure or so in

775
00:27:28,480 --> 00:27:30,480
the program and we can just do that

776
00:27:30,480 --> 00:27:32,640
right we can optimize our algorithm to

777
00:27:32,640 --> 00:27:35,200
do just that work on these assumptions

778
00:27:35,200 --> 00:27:37,279
and make everything run

779
00:27:37,279 --> 00:27:40,880
very fast for example this also

780
00:27:40,880 --> 00:27:42,480
resulted in some bugs and then we have

781
00:27:42,480 --> 00:27:44,320
somebody else we surely have initialized

782
00:27:44,320 --> 00:27:47,520
this so we'll surely initialize this

783
00:27:47,520 --> 00:27:50,240
and if especially across api boundaries

784
00:27:50,240 --> 00:27:52,159
if you find something like this it it's

785
00:27:52,159 --> 00:27:54,240
very very much lends itself to box and

786
00:27:54,240 --> 00:27:56,240
then does anybody have an idea of what

787
00:27:56,240 --> 00:28:00,399
kind of category could be there as well

788
00:28:00,880 --> 00:28:02,880
it has to do with something that i think

789
00:28:02,880 --> 00:28:04,880
a lot of people have seen before

790
00:28:04,880 --> 00:28:07,919
this length can never be smaller than

791
00:28:07,919 --> 00:28:10,000
it was there was actually something that

792
00:28:10,000 --> 00:28:11,200
accorded a lot and then there is the

793
00:28:11,200 --> 00:28:13,360
king's category of course this length

794
00:28:13,360 --> 00:28:15,360
can never be larger than so anything

795
00:28:15,360 --> 00:28:17,760
with missing bounce checks and one of

796
00:28:17,760 --> 00:28:19,039
these um

797
00:28:19,039 --> 00:28:21,760
bugs that i uh that we encountered i

798
00:28:21,760 --> 00:28:23,120
would like to spotlight a little bit

799
00:28:23,120 --> 00:28:25,279
here and this uh accordion the six

800
00:28:25,279 --> 00:28:27,600
lowpan fragment reassembly and uh for

801
00:28:27,600 --> 00:28:29,919
some context six lowpan is kind of the

802
00:28:29,919 --> 00:28:32,240
the way that um smart

803
00:28:32,240 --> 00:28:34,480
and constrained devices can

804
00:28:34,480 --> 00:28:37,520
use to talk ipv6 to each other so what

805
00:28:37,520 --> 00:28:39,520
they can do send they can send small

806
00:28:39,520 --> 00:28:41,520
frames over the over the air but they

807
00:28:41,520 --> 00:28:43,600
are pretty small so what you have to do

808
00:28:43,600 --> 00:28:45,840
is to plug different fragments together

809
00:28:45,840 --> 00:28:48,240
so you can have a full ipv6 packet and

810
00:28:48,240 --> 00:28:49,840
so what the standard says is that you

811
00:28:49,840 --> 00:28:52,240
have kind of a track one uh fragment and

812
00:28:52,240 --> 00:28:54,880
then fragment n fragments so one is the

813
00:28:54,880 --> 00:28:56,880
first and then the follow-up frames and

814
00:28:56,880 --> 00:28:58,799
as everything goes over the air you

815
00:28:58,799 --> 00:29:01,039
cannot really rely on something to come

816
00:29:01,039 --> 00:29:02,960
in in a specific order so what you have

817
00:29:02,960 --> 00:29:05,600
to do is just um you take everything in

818
00:29:05,600 --> 00:29:07,520
and then have to reorder it afterwards

819
00:29:07,520 --> 00:29:08,720
and so then

820
00:29:08,720 --> 00:29:11,279
it's kind of a good thought to have we

821
00:29:11,279 --> 00:29:12,960
already have a pre-sorted list right we

822
00:29:12,960 --> 00:29:14,799
have a freight one so it's always at the

823
00:29:14,799 --> 00:29:16,480
beginning so what we're doing is not

824
00:29:16,480 --> 00:29:17,679
really sorting a list but we are

825
00:29:17,679 --> 00:29:19,360
starting a list with the first element

826
00:29:19,360 --> 00:29:21,760
already in fixed place and we can just

827
00:29:21,760 --> 00:29:23,279
assume that the first element just

828
00:29:23,279 --> 00:29:25,679
doesn't change and it turns out if you

829
00:29:25,679 --> 00:29:29,039
generate an algorithm for this and do

830
00:29:29,039 --> 00:29:32,000
the sorting what comes out at the end

831
00:29:32,000 --> 00:29:33,919
is an infinite data structure it's a

832
00:29:33,919 --> 00:29:36,320
ring instead of something that's finite

833
00:29:36,320 --> 00:29:38,159
and now you have an assumption about

834
00:29:38,159 --> 00:29:40,399
something being finite data structure

835
00:29:40,399 --> 00:29:42,480
and you start working on this this is

836
00:29:42,480 --> 00:29:44,640
where things get a bit weird here um

837
00:29:44,640 --> 00:29:46,960
because you what you have to do in six

838
00:29:46,960 --> 00:29:48,000
lowpan

839
00:29:48,000 --> 00:29:49,760
in order to put together the fragment

840
00:29:49,760 --> 00:29:51,120
data is that you have to strip the

841
00:29:51,120 --> 00:29:52,960
fragment headers from all of these

842
00:29:52,960 --> 00:29:55,360
different fragments and you opt to do it

843
00:29:55,360 --> 00:29:57,279
once but you can do it once by just

844
00:29:57,279 --> 00:29:59,600
going through this finite list of course

845
00:29:59,600 --> 00:30:01,279
and if it's a ring afterwards it's no

846
00:30:01,279 --> 00:30:03,440
longer finite so you turn it into an

847
00:30:03,440 --> 00:30:05,440
infinite header removal packets get

848
00:30:05,440 --> 00:30:07,039
smaller and smaller over time the

849
00:30:07,039 --> 00:30:09,279
integer of the size just gets negative

850
00:30:09,279 --> 00:30:11,039
you have a really big mem copy and then

851
00:30:11,039 --> 00:30:12,640
the firmware is not really happy about

852
00:30:12,640 --> 00:30:14,240
what comes afterwards

853
00:30:14,240 --> 00:30:15,360
and

854
00:30:15,360 --> 00:30:18,559
the actual crash

855
00:30:18,559 --> 00:30:20,799
triaging here was a very interesting

856
00:30:20,799 --> 00:30:22,720
process i find this quite interesting

857
00:30:22,720 --> 00:30:24,640
because i am sure i have looked at this

858
00:30:24,640 --> 00:30:27,120
kind of functionality before and just to

859
00:30:27,120 --> 00:30:28,720
understand kind of what is going on in

860
00:30:28,720 --> 00:30:29,760
the

861
00:30:29,760 --> 00:30:31,360
network layer and

862
00:30:31,360 --> 00:30:33,360
i'm sure i've missed this kind of bug

863
00:30:33,360 --> 00:30:34,960
here and

864
00:30:34,960 --> 00:30:37,360
the the triaging process was pretty uh

865
00:30:37,360 --> 00:30:39,200
involved and i tried to

866
00:30:39,200 --> 00:30:41,039
try running this with marius and telling

867
00:30:41,039 --> 00:30:42,960
him about it but it

868
00:30:42,960 --> 00:30:45,200
was kind of resulting in

869
00:30:45,200 --> 00:30:47,360
this scenario and he

870
00:30:47,360 --> 00:30:49,279
said okay maybe we should not go into

871
00:30:49,279 --> 00:30:50,640
all these details so i'm scaring you

872
00:30:50,640 --> 00:30:52,559
these details here

873
00:30:52,559 --> 00:30:53,919
but instead we want to get to some

874
00:30:53,919 --> 00:30:56,559
closing thoughts and first of all of

875
00:30:56,559 --> 00:30:58,159
course what are the boundaries of what

876
00:30:58,159 --> 00:31:00,399
we can do or what we want to do here as

877
00:31:00,399 --> 00:31:02,640
well and so first of all it's a research

878
00:31:02,640 --> 00:31:04,720
prototype we have implemented for arm

879
00:31:04,720 --> 00:31:06,320
products and we are working on extending

880
00:31:06,320 --> 00:31:08,640
it but for the moment it's uh working on

881
00:31:08,640 --> 00:31:10,799
a very popular platform but obviously it

882
00:31:10,799 --> 00:31:13,200
doesn't cover all of them

883
00:31:13,200 --> 00:31:15,600
and then there are also special cases in

884
00:31:15,600 --> 00:31:19,840
perma which we are just not this

885
00:31:20,159 --> 00:31:21,600
this way of

886
00:31:21,600 --> 00:31:23,519
looking at this mio modeling does not

887
00:31:23,519 --> 00:31:26,080
really cover because vma is just a

888
00:31:26,080 --> 00:31:27,360
different beast it's an interesting

889
00:31:27,360 --> 00:31:28,880
problem but something that we do not

890
00:31:28,880 --> 00:31:30,640
really cover here and also if we have

891
00:31:30,640 --> 00:31:32,480
some very specific assumptions about

892
00:31:32,480 --> 00:31:34,240
timings um

893
00:31:34,240 --> 00:31:36,080
then things can get messed up as well

894
00:31:36,080 --> 00:31:38,559
for example the um

895
00:31:38,559 --> 00:31:40,559
the emulator tries to make things go as

896
00:31:40,559 --> 00:31:42,159
quickly as possible of course but then

897
00:31:42,159 --> 00:31:44,480
at some points for example if you wait

898
00:31:44,480 --> 00:31:46,320
for some initialization or you are sure

899
00:31:46,320 --> 00:31:48,159
some device takes for a bit longer time

900
00:31:48,159 --> 00:31:50,559
we may not always scale the timing in a

901
00:31:50,559 --> 00:31:52,320
correct manner so that things can come

902
00:31:52,320 --> 00:31:54,159
too early logically or maybe even too

903
00:31:54,159 --> 00:31:55,039
late

904
00:31:55,039 --> 00:31:57,919
so if we have situations like this

905
00:31:57,919 --> 00:32:00,880
some modifications are required and then

906
00:32:00,880 --> 00:32:02,720
of course there's a bit of common sense

907
00:32:02,720 --> 00:32:04,960
in here so in case you have a linux

908
00:32:04,960 --> 00:32:06,000
system

909
00:32:06,000 --> 00:32:07,760
and you can use what tools you have

910
00:32:07,760 --> 00:32:09,919
already available just use the tools you

911
00:32:09,919 --> 00:32:11,679
have already available so and that

912
00:32:11,679 --> 00:32:13,279
should work

913
00:32:13,279 --> 00:32:15,200
and and then finally one thing i would

914
00:32:15,200 --> 00:32:16,720
like a vision of mine that i would like

915
00:32:16,720 --> 00:32:18,799
you to take home it has to do a little

916
00:32:18,799 --> 00:32:21,360
bit uh has to do something with the bug

917
00:32:21,360 --> 00:32:23,840
with the duck and uh here it goes if we

918
00:32:23,840 --> 00:32:26,159
want to convince firmer to walk like

919
00:32:26,159 --> 00:32:28,080
possible software and then also quite

920
00:32:28,080 --> 00:32:30,720
like possible software then we might

921
00:32:30,720 --> 00:32:33,120
someday be able to actually give the

922
00:32:33,120 --> 00:32:34,399
tools to the

923
00:32:34,399 --> 00:32:37,840
embedded firmware development guys to

924
00:32:37,840 --> 00:32:40,240
to do the fuzzing themselves and find

925
00:32:40,240 --> 00:32:41,919
all these bugs so we don't have to do it

926
00:32:41,919 --> 00:32:43,519
for them because currently we do not

927
00:32:43,519 --> 00:32:45,279
really supply them with the tools to be

928
00:32:45,279 --> 00:32:47,360
able to do it but if we can do this we

929
00:32:47,360 --> 00:32:49,200
can find a lot of bugs in the process

930
00:32:49,200 --> 00:32:51,039
and with this thought i would like to

931
00:32:51,039 --> 00:32:53,360
thank you for the attention and

932
00:32:53,360 --> 00:32:56,360
questions

933
00:33:06,799 --> 00:33:09,799
yep

934
00:33:15,200 --> 00:33:16,000
test

935
00:33:16,000 --> 00:33:17,919
so if i understand correctly you drop in

936
00:33:17,919 --> 00:33:19,039
the firmware that you have no

937
00:33:19,039 --> 00:33:20,880
pre-assumptions about

938
00:33:20,880 --> 00:33:23,120
and then it will automatically find out

939
00:33:23,120 --> 00:33:26,399
what hardware mmi oh it does but how do

940
00:33:26,399 --> 00:33:28,960
you deal with stuff that actually

941
00:33:28,960 --> 00:33:31,519
changes like for example if we take a

942
00:33:31,519 --> 00:33:33,120
game boy for example and we have like

943
00:33:33,120 --> 00:33:34,640
bank switching so you're right to an

944
00:33:34,640 --> 00:33:37,039
address and that changes ram completely

945
00:33:37,039 --> 00:33:39,279
or as a more recent example we set up

946
00:33:39,279 --> 00:33:41,279
page tables which does virtual memory

947
00:33:41,279 --> 00:33:44,000
how do you detect these kind of things

948
00:33:44,000 --> 00:33:46,640
um so currently um this prototype

949
00:33:46,640 --> 00:33:48,399
doesn't do

950
00:33:48,399 --> 00:33:50,080
these things on the architecture level

951
00:33:50,080 --> 00:33:51,840
which are kind of

952
00:33:51,840 --> 00:33:53,840
baked into the core of the architecture

953
00:33:53,840 --> 00:33:56,159
so what we for example implement is the

954
00:33:56,159 --> 00:33:58,320
the interrupt controller so

955
00:33:58,320 --> 00:33:59,440
for

956
00:33:59,440 --> 00:34:01,120
enabling and setting

957
00:34:01,120 --> 00:34:03,919
priorities for interrupts we still give

958
00:34:03,919 --> 00:34:05,039
this

959
00:34:05,039 --> 00:34:07,039
architecture level completes

960
00:34:07,039 --> 00:34:08,399
architectural components and this

961
00:34:08,399 --> 00:34:10,719
functionality and have this

962
00:34:10,719 --> 00:34:13,119
done by the emulator itself so what we

963
00:34:13,119 --> 00:34:15,679
can do then is that we can if we know

964
00:34:15,679 --> 00:34:16,879
the

965
00:34:16,879 --> 00:34:20,000
architecture on a very broad scale then

966
00:34:20,000 --> 00:34:22,560
we can create an emulator which

967
00:34:22,560 --> 00:34:24,320
has these core components in it

968
00:34:24,320 --> 00:34:25,520
something which

969
00:34:25,520 --> 00:34:27,520
the architecture cannot do without and

970
00:34:27,520 --> 00:34:29,440
would have these represented by that and

971
00:34:29,440 --> 00:34:31,839
then the modeling of the mmio afterwards

972
00:34:31,839 --> 00:34:34,800
would be something done by other models

973
00:34:34,800 --> 00:34:36,719
so you could adjust some of these things

974
00:34:36,719 --> 00:34:39,359
by hand for the emulator

975
00:34:39,359 --> 00:34:41,599
you would create

976
00:34:41,599 --> 00:34:43,679
this these core components once for

977
00:34:43,679 --> 00:34:46,239
example for the

978
00:34:46,239 --> 00:34:49,040
interrupt controlling and so on and then

979
00:34:49,040 --> 00:34:51,440
do this to fast test any

980
00:34:51,440 --> 00:34:53,760
component which is

981
00:34:53,760 --> 00:34:55,199
working on on this kind of base

982
00:34:55,199 --> 00:34:59,799
architecture yes okay thank you

983
00:35:09,280 --> 00:35:10,880
and

984
00:35:10,880 --> 00:35:12,079
regarding

985
00:35:12,079 --> 00:35:13,040
the

986
00:35:13,040 --> 00:35:14,839
differences uh

987
00:35:14,839 --> 00:35:17,839
between piece of hardware and interfaces

988
00:35:17,839 --> 00:35:20,800
uh i saw uh that you have kind of

989
00:35:20,800 --> 00:35:23,119
profiles uh

990
00:35:23,119 --> 00:35:24,160
based

991
00:35:24,160 --> 00:35:27,280
yeah that will uh use profiles where you

992
00:35:27,280 --> 00:35:29,680
can take from the orientation

993
00:35:29,680 --> 00:35:32,480
their addresses uh and

994
00:35:32,480 --> 00:35:35,119
in this way right

995
00:35:35,119 --> 00:35:37,200
yeah what you do to set the the base

996
00:35:37,200 --> 00:35:39,359
emulation up is that you supply some

997
00:35:39,359 --> 00:35:42,160
base memory ranges in that case that you

998
00:35:42,160 --> 00:35:43,839
um kind of tell it okay where can you

999
00:35:43,839 --> 00:35:45,440
expect hardware accessories to be and

1000
00:35:45,440 --> 00:35:47,760
then where can you expect some ram to be

1001
00:35:47,760 --> 00:35:49,200
and where's the code loaded this is kind

1002
00:35:49,200 --> 00:35:51,599
of the base assumption that you need to

1003
00:35:51,599 --> 00:35:53,359
know where are things based quite

1004
00:35:53,359 --> 00:35:54,880
roughly not

1005
00:35:54,880 --> 00:35:57,440
um you do not need to know where some my

1006
00:35:57,440 --> 00:35:59,839
origins are or any ranges like this um

1007
00:35:59,839 --> 00:36:02,079
but you have to know the broad memory

1008
00:36:02,079 --> 00:36:04,400
range where things could occur and then

1009
00:36:04,400 --> 00:36:07,359
i listen for these successes

1010
00:36:07,359 --> 00:36:11,280
okay you know um i i was asking uh uh

1011
00:36:11,280 --> 00:36:13,119
more specifically if

1012
00:36:13,119 --> 00:36:15,760
you're uh providing uh

1013
00:36:15,760 --> 00:36:18,000
addresses for specific

1014
00:36:18,000 --> 00:36:19,839
uh interfaces

1015
00:36:19,839 --> 00:36:23,359
uh yeah okay okay thank you

1016
00:36:23,359 --> 00:36:25,680
we can also talk about this afterwards

1017
00:36:25,680 --> 00:36:27,119
if i have not understood your question

1018
00:36:27,119 --> 00:36:28,720
correctly that's very fine i'm sure it's

1019
00:36:28,720 --> 00:36:30,240
a good one so

1020
00:36:30,240 --> 00:36:32,320
hey thanks for your talk group never uh

1021
00:36:32,320 --> 00:36:34,560
disappoints um

1022
00:36:34,560 --> 00:36:36,400
maybe i didn't get that right but

1023
00:36:36,400 --> 00:36:37,760
how do you

1024
00:36:37,760 --> 00:36:39,839
create the constraints for your model is

1025
00:36:39,839 --> 00:36:41,839
this manual work or is this being

1026
00:36:41,839 --> 00:36:44,640
computed with like i didn't i didn't um

1027
00:36:44,640 --> 00:36:46,400
explain the one symbol on the right

1028
00:36:46,400 --> 00:36:48,800
which is was the symbol for anger and it

1029
00:36:48,800 --> 00:36:51,119
was maybe it was implicit from my side

1030
00:36:51,119 --> 00:36:52,720
but it's it's do not make symbolic

1031
00:36:52,720 --> 00:36:54,960
execution okay i think kind of in the in

1032
00:36:54,960 --> 00:36:56,960
the context of we taking a snapshot of

1033
00:36:56,960 --> 00:36:58,880
what's going on in the emulator and then

1034
00:36:58,880 --> 00:37:00,880
just look at this very specific

1035
00:37:00,880 --> 00:37:02,960
excess and just have to step a couple of

1036
00:37:02,960 --> 00:37:04,960
times to not kind of run through

1037
00:37:04,960 --> 00:37:07,440
completely automated yeah this is yeah

1038
00:37:07,440 --> 00:37:09,599
which we also saw with the in the demo

1039
00:37:09,599 --> 00:37:11,520
where the these models caught up it was

1040
00:37:11,520 --> 00:37:14,640
also an automated process

1041
00:37:15,440 --> 00:37:19,359
would uh modeling not be uh useful by uh

1042
00:37:19,359 --> 00:37:22,160
non-firmware software

1043
00:37:22,160 --> 00:37:24,079
yeah i think this is also a very good

1044
00:37:24,079 --> 00:37:25,839
question i haven't always said that but

1045
00:37:25,839 --> 00:37:28,400
these questions were really good um and

1046
00:37:28,400 --> 00:37:29,359
valid

1047
00:37:29,359 --> 00:37:31,359
this one is actually something which we

1048
00:37:31,359 --> 00:37:33,359
could also

1049
00:37:33,359 --> 00:37:35,440
apply in non-firmware

1050
00:37:35,440 --> 00:37:38,400
environments the the bit different or

1051
00:37:38,400 --> 00:37:41,040
the kind of difference here is that for

1052
00:37:41,040 --> 00:37:42,880
mio access what we have is an excess

1053
00:37:42,880 --> 00:37:45,280
which is very local and very short-lived

1054
00:37:45,280 --> 00:37:47,200
so we have one mmo access to a register

1055
00:37:47,200 --> 00:37:49,040
we use it this operation for example and

1056
00:37:49,040 --> 00:37:50,960
then discard the value afterwards so

1057
00:37:50,960 --> 00:37:53,359
what we can do is we can do the analysis

1058
00:37:53,359 --> 00:37:55,839
in a very confined space so we don't

1059
00:37:55,839 --> 00:37:57,359
just have to look at this one function

1060
00:37:57,359 --> 00:37:59,359
or some basic blocks of this this

1061
00:37:59,359 --> 00:38:01,520
function to see what it does

1062
00:38:01,520 --> 00:38:04,400
what we could also do for um software in

1063
00:38:04,400 --> 00:38:07,440
the non-perma space is that we

1064
00:38:07,440 --> 00:38:09,680
have this type of model as well and then

1065
00:38:09,680 --> 00:38:12,400
fix some values in place for example or

1066
00:38:12,400 --> 00:38:14,000
have some

1067
00:38:14,000 --> 00:38:15,839
some kind of grammar description maybe

1068
00:38:15,839 --> 00:38:17,440
coming out of this modeling that we say

1069
00:38:17,440 --> 00:38:19,839
okay this this field can either be that

1070
00:38:19,839 --> 00:38:21,520
or the other one and then we have the

1071
00:38:21,520 --> 00:38:23,119
fuzzer just give us some input and then

1072
00:38:23,119 --> 00:38:25,119
we look at these fields and then based

1073
00:38:25,119 --> 00:38:26,880
on what the puzzle gives us we insert

1074
00:38:26,880 --> 00:38:28,720
the right choice and kind of do the same

1075
00:38:28,720 --> 00:38:31,440
modeling maybe in place of where the

1076
00:38:31,440 --> 00:38:33,839
input starts being fed in or maybe in

1077
00:38:33,839 --> 00:38:34,960
the place of

1078
00:38:34,960 --> 00:38:36,560
the fuzzing process itself where we

1079
00:38:36,560 --> 00:38:38,880
inject some code or like uh

1080
00:38:38,880 --> 00:38:40,960
some listeners or things like that i

1081
00:38:40,960 --> 00:38:42,640
could see that yeah it just has a bit

1082
00:38:42,640 --> 00:38:44,400
more um

1083
00:38:44,400 --> 00:38:46,880
it's not that natural to to do it in

1084
00:38:46,880 --> 00:38:48,960
that case because it just has a more it

1085
00:38:48,960 --> 00:38:50,560
has a broader frame you have to trace

1086
00:38:50,560 --> 00:38:52,560
the data for a longer time but in

1087
00:38:52,560 --> 00:38:57,560
general this is yeah so it's a good idea

1088
00:39:00,000 --> 00:39:01,839
right i think there are no further

1089
00:39:01,839 --> 00:39:03,119
questions if you have any questions we

1090
00:39:03,119 --> 00:39:05,040
can talk outside as well so thank you

1091
00:39:05,040 --> 00:39:09,160
again and have a good break

