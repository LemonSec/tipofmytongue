1
00:00:03,439 --> 00:00:06,399
you missed it

2
00:00:04,400 --> 00:00:08,480
thank you very much uh so this is like

3
00:00:06,399 --> 00:00:08,960
my first knuckle i'm very happy to be

4
00:00:08,480 --> 00:00:11,440
here

5
00:00:08,960 --> 00:00:12,000
so thank you for having me here uh so

6
00:00:11,440 --> 00:00:14,080
let's

7
00:00:12,000 --> 00:00:15,360
jump right into the talk if it's

8
00:00:14,080 --> 00:00:17,199
possible

9
00:00:15,360 --> 00:00:18,400
dimming the lights would be great

10
00:00:17,199 --> 00:00:20,000
because uh

11
00:00:18,400 --> 00:00:21,359
a you can see the slides better and

12
00:00:20,000 --> 00:00:22,800
beams still a bit hanging over from the

13
00:00:21,359 --> 00:00:24,720
party yesterday

14
00:00:22,800 --> 00:00:26,560
well all right let's jump right in so

15
00:00:24,720 --> 00:00:28,960
it's a new heap exploitation from kernel

16
00:00:26,560 --> 00:00:32,159
back to kernel control

17
00:00:28,960 --> 00:00:34,079
so the topics of this talk are a brief

18
00:00:32,159 --> 00:00:37,679
introduction into xnu

19
00:00:34,079 --> 00:00:40,719
um a brief introduction into mock ports

20
00:00:37,680 --> 00:00:43,760
and heap zones like kellogg and zelock

21
00:00:40,719 --> 00:00:44,000
and then i will talk about treadmill

22
00:00:43,760 --> 00:00:47,440
which

23
00:00:44,000 --> 00:00:48,399
is my exploit for a buck and then i will

24
00:00:47,440 --> 00:00:51,680
walk you through

25
00:00:48,399 --> 00:00:53,840
vintax and ventex which are two exploits

26
00:00:51,680 --> 00:00:55,600
for a different bug

27
00:00:53,840 --> 00:00:57,199
by the way slides will be available

28
00:00:55,600 --> 00:00:59,680
later so

29
00:00:57,199 --> 00:01:02,160
you can reread them so goal of this talk

30
00:00:59,680 --> 00:01:03,920
is introduce you to some aspects of xnu

31
00:01:02,160 --> 00:01:06,000
and get a general idea how to go for

32
00:01:03,920 --> 00:01:08,080
exploitation present real world

33
00:01:06,000 --> 00:01:10,080
techniques like real world exploits and

34
00:01:08,080 --> 00:01:12,880
walk you through these exploits

35
00:01:10,080 --> 00:01:14,640
uh so not goal of this talk is to every

36
00:01:12,880 --> 00:01:16,479
understand every single aspect of x and

37
00:01:14,640 --> 00:01:18,479
you mentioned in this talk

38
00:01:16,479 --> 00:01:20,320
because i only scratch the surface

39
00:01:18,479 --> 00:01:22,159
myself and you also don't need to

40
00:01:20,320 --> 00:01:24,559
understand every single line of code in

41
00:01:22,159 --> 00:01:24,880
the exploits or what i show you here

42
00:01:24,560 --> 00:01:26,240
just

43
00:01:24,880 --> 00:01:28,399
try to understand the general idea

44
00:01:26,240 --> 00:01:29,920
behind it and if you can't read it or

45
00:01:28,400 --> 00:01:33,360
i'm not sure what it's about

46
00:01:29,920 --> 00:01:36,000
just don't like get lost in the details

47
00:01:33,360 --> 00:01:37,840
focus on the general thing idea and it's

48
00:01:36,000 --> 00:01:39,600
good so i only read on reverse xnew

49
00:01:37,840 --> 00:01:41,600
enough to make this exploit work so

50
00:01:39,600 --> 00:01:42,720
some information presented here is good

51
00:01:41,600 --> 00:01:45,439
enough to explain

52
00:01:42,720 --> 00:01:47,200
why it works but it may not be 100

53
00:01:45,439 --> 00:01:48,559
accurate in terms of it may work

54
00:01:47,200 --> 00:01:50,399
slightly different but like

55
00:01:48,560 --> 00:01:52,479
this simplification is good enough so

56
00:01:50,399 --> 00:01:53,600
some things might be oversimplified so

57
00:01:52,479 --> 00:01:56,240
keep that in mind

58
00:01:53,600 --> 00:01:57,600
but in my opinion this is the way to uh

59
00:01:56,240 --> 00:01:59,280
go for exploitation

60
00:01:57,600 --> 00:02:00,960
it's like it's a time benefit trade-off

61
00:01:59,280 --> 00:02:02,880
if you make an assumption this could

62
00:02:00,960 --> 00:02:04,320
work that way then you test it works

63
00:02:02,880 --> 00:02:06,320
good enough doesn't really matter if it

64
00:02:04,320 --> 00:02:09,519
actually works like that but if like

65
00:02:06,320 --> 00:02:12,640
you got your stuff to work that's good

66
00:02:09,520 --> 00:02:14,800
uh so another disclaimer uh yeah if you

67
00:02:12,640 --> 00:02:17,279
can't follow some things that's fine

68
00:02:14,800 --> 00:02:19,360
don't get lost follow the bigger picture

69
00:02:17,280 --> 00:02:21,599
uh for furnishing i recommend rereading

70
00:02:19,360 --> 00:02:22,400
the exploit source code and the slides

71
00:02:21,599 --> 00:02:25,679
if you care

72
00:02:22,400 --> 00:02:27,560
so mac ports this part is mostly taken

73
00:02:25,680 --> 00:02:31,599
from the blog post from block

74
00:02:27,560 --> 00:02:34,000
360.cn what is a mac port

75
00:02:31,599 --> 00:02:36,000
macport is a one-way transmission

76
00:02:34,000 --> 00:02:38,720
channel for mac messages

77
00:02:36,000 --> 00:02:41,200
there is a single receiver and there can

78
00:02:38,720 --> 00:02:43,359
be one or multiple senders

79
00:02:41,200 --> 00:02:46,640
so in the kernel these are represented

80
00:02:43,360 --> 00:02:50,239
as ipc port structures

81
00:02:46,640 --> 00:02:53,679
so right to the mock ports are stored

82
00:02:50,239 --> 00:02:55,519
in a independent process ipc table so

83
00:02:53,680 --> 00:02:58,480
every process knows

84
00:02:55,519 --> 00:02:58,879
what send or receive rights it has to

85
00:02:58,480 --> 00:03:01,280
what

86
00:02:58,879 --> 00:03:01,280
ports

87
00:03:01,920 --> 00:03:05,280
so these are used for interprocess

88
00:03:03,440 --> 00:03:08,560
communication and

89
00:03:05,280 --> 00:03:11,120
tasks as they're called in mach which

90
00:03:08,560 --> 00:03:12,080
like represent the process are

91
00:03:11,120 --> 00:03:15,760
represented as

92
00:03:12,080 --> 00:03:17,120
mock ports so every task has a port and

93
00:03:15,760 --> 00:03:19,518
a handle to it

94
00:03:17,120 --> 00:03:20,720
send rights to a task port means full

95
00:03:19,519 --> 00:03:23,040
control over the task

96
00:03:20,720 --> 00:03:25,519
because these are special so you can

97
00:03:23,040 --> 00:03:27,040
like send messages or like use the api

98
00:03:25,519 --> 00:03:28,799
to read and write memory

99
00:03:27,040 --> 00:03:30,798
create and control threads you can

100
00:03:28,799 --> 00:03:32,239
handle exceptions and much more so a

101
00:03:30,799 --> 00:03:33,840
send right to a task

102
00:03:32,239 --> 00:03:35,680
means you have full control over the

103
00:03:33,840 --> 00:03:38,799
task

104
00:03:35,680 --> 00:03:39,519
tfp0 is short for tasks for pit zero so

105
00:03:38,799 --> 00:03:41,840
the goal

106
00:03:39,519 --> 00:03:42,720
is to get a send right to the kernel

107
00:03:41,840 --> 00:03:44,239
task port

108
00:03:42,720 --> 00:03:45,760
this will allow you to read and write

109
00:03:44,239 --> 00:03:46,000
memory this is what we want to achieve

110
00:03:45,760 --> 00:03:48,720
with

111
00:03:46,000 --> 00:03:48,720
our exploits

112
00:03:49,760 --> 00:03:53,920
so uh let's talk a little bit about heap

113
00:03:52,400 --> 00:03:57,360
sounds because we're gonna do

114
00:03:53,920 --> 00:04:00,640
a lot with the heap so there's

115
00:03:57,360 --> 00:04:02,159
zalox so the kernel heap is divided into

116
00:04:00,640 --> 00:04:04,798
so-called zones

117
00:04:02,159 --> 00:04:05,519
and each zone kind of like allocates

118
00:04:04,799 --> 00:04:09,360
pages

119
00:04:05,519 --> 00:04:10,000
and pages can be and zones can split

120
00:04:09,360 --> 00:04:12,720
pages

121
00:04:10,000 --> 00:04:13,680
up to allow sub-allocations of smaller

122
00:04:12,720 --> 00:04:15,840
size

123
00:04:13,680 --> 00:04:18,160
so there's like a wrapper there's like

124
00:04:15,840 --> 00:04:19,840
different zones for example catalog 16

125
00:04:18,160 --> 00:04:22,960
that's the name of his own

126
00:04:19,839 --> 00:04:25,280
it divides a page into 16 byte chunks

127
00:04:22,960 --> 00:04:28,880
and these can be allocated individually

128
00:04:25,280 --> 00:04:31,520
so this is managed by kellogg

129
00:04:28,880 --> 00:04:32,960
important thing to note here zones are

130
00:04:31,520 --> 00:04:35,919
garbage collected so

131
00:04:32,960 --> 00:04:37,599
freeing all catalog elements in the page

132
00:04:35,919 --> 00:04:39,919
does not guarantee the page

133
00:04:37,600 --> 00:04:41,840
being freed from the zone so we need to

134
00:04:39,919 --> 00:04:43,680
keep that in mind when exploiting

135
00:04:41,840 --> 00:04:47,198
[Music]

136
00:04:43,680 --> 00:04:49,759
catalog is a wrapper for zalok

137
00:04:47,199 --> 00:04:51,040
it manages multiple zones so as a

138
00:04:49,759 --> 00:04:52,720
programmer you just call

139
00:04:51,040 --> 00:04:54,880
catalog and the size and it gives you

140
00:04:52,720 --> 00:04:57,280
back memory but internally what it does

141
00:04:54,880 --> 00:04:58,560
it figures out in which zone to place

142
00:04:57,280 --> 00:05:02,080
the allocation

143
00:04:58,560 --> 00:05:04,160
and then like give allocate the memory

144
00:05:02,080 --> 00:05:05,758
so the thing with kellogg is when you're

145
00:05:04,160 --> 00:05:07,199
freeing the memory you need to remember

146
00:05:05,759 --> 00:05:10,479
the size of it so it

147
00:05:07,199 --> 00:05:13,280
like frees back into the correct zone so

148
00:05:10,479 --> 00:05:16,560
when passing k3 just the pointer and the

149
00:05:13,280 --> 00:05:19,840
size you allocated it with

150
00:05:16,560 --> 00:05:23,199
and this already brings us to our first

151
00:05:19,840 --> 00:05:26,799
bug so this is taken from the blog post

152
00:05:23,199 --> 00:05:29,520
written by luca moreau

153
00:05:26,800 --> 00:05:30,080
i call i dubbed my exploit treadmill but

154
00:05:29,520 --> 00:05:34,000
they

155
00:05:30,080 --> 00:05:37,198
add up the bug lightspeed and basically

156
00:05:34,000 --> 00:05:38,560
what what's the buck about so very brief

157
00:05:37,199 --> 00:05:41,840
introduction in the back

158
00:05:38,560 --> 00:05:45,680
there's a thing like a function called

159
00:05:41,840 --> 00:05:48,400
lio listio and this thing can be called

160
00:05:45,680 --> 00:05:50,400
in two modes basically synchronously and

161
00:05:48,400 --> 00:05:53,198
asynchronously

162
00:05:50,400 --> 00:05:54,400
so for the synchronous way it would go

163
00:05:53,199 --> 00:05:57,520
get user input

164
00:05:54,400 --> 00:05:58,239
do stuff and at the end checks uh one if

165
00:05:57,520 --> 00:06:02,240
condition

166
00:05:58,240 --> 00:06:05,280
and if i o context ios it is zero

167
00:06:02,240 --> 00:06:08,080
free uh io contacts and then freeing the

168
00:06:05,280 --> 00:06:10,758
object for the asynchronous path

169
00:06:08,080 --> 00:06:12,639
similar get user input do something

170
00:06:10,759 --> 00:06:15,919
asynchronously but then

171
00:06:12,639 --> 00:06:19,039
check the condition and if io issued a 0

172
00:06:15,919 --> 00:06:20,159
free the thing so the issue here is that

173
00:06:19,039 --> 00:06:23,440
the asynchronous

174
00:06:20,160 --> 00:06:25,919
function might call free um

175
00:06:23,440 --> 00:06:27,199
and if that happens then we have a

176
00:06:25,919 --> 00:06:29,440
double free because then the

177
00:06:27,199 --> 00:06:31,840
asynchronous function freeze it

178
00:06:29,440 --> 00:06:35,840
and like this function freeze it up as

179
00:06:31,840 --> 00:06:38,880
well if the condition is satisfied

180
00:06:35,840 --> 00:06:40,799
um so

181
00:06:38,880 --> 00:06:42,000
how can we trigger that we call

182
00:06:40,800 --> 00:06:45,039
lyolistio

183
00:06:42,000 --> 00:06:46,080
in asynchronous mode we hope for the

184
00:06:45,039 --> 00:06:49,039
workers threat

185
00:06:46,080 --> 00:06:50,080
to finish before the thread that spawned

186
00:06:49,039 --> 00:06:53,039
the thing

187
00:06:50,080 --> 00:06:53,758
uh reaches the statement where it checks

188
00:06:53,039 --> 00:06:56,800
if the

189
00:06:53,759 --> 00:06:59,039
uh contact io issue is zero um

190
00:06:56,800 --> 00:07:00,080
then that thing gets freed we reallocate

191
00:06:59,039 --> 00:07:02,719
it with the

192
00:07:00,080 --> 00:07:04,240
uh second word set to zero to satisfy

193
00:07:02,720 --> 00:07:05,919
that condition and then the buffer get

194
00:07:04,240 --> 00:07:09,039
freed again

195
00:07:05,919 --> 00:07:09,680
so on this block they provided a part to

196
00:07:09,039 --> 00:07:12,159
trigger it

197
00:07:09,680 --> 00:07:12,800
so that's very simple thread one

198
00:07:12,160 --> 00:07:14,840
basically

199
00:07:12,800 --> 00:07:16,160
in a loop calls that function

200
00:07:14,840 --> 00:07:18,719
asynchronously

201
00:07:16,160 --> 00:07:21,840
thread two does like a syscall to

202
00:07:18,720 --> 00:07:24,720
allocate the catalog 16 buffer

203
00:07:21,840 --> 00:07:25,919
with uh the word set to zero which they

204
00:07:24,720 --> 00:07:28,960
do internally with the

205
00:07:25,919 --> 00:07:30,639
uh with the paul call and that's just

206
00:07:28,960 --> 00:07:32,719
kernel panics your device

207
00:07:30,639 --> 00:07:34,720
so this is like my starting point where

208
00:07:32,720 --> 00:07:38,720
i started

209
00:07:34,720 --> 00:07:39,280
so the exploit plan us turn this double

210
00:07:38,720 --> 00:07:42,160
free

211
00:07:39,280 --> 00:07:42,960
into use after free and you want to

212
00:07:42,160 --> 00:07:46,319
overlap

213
00:07:42,960 --> 00:07:48,400
the useful object with control data

214
00:07:46,319 --> 00:07:50,720
you want to use the fake object to get

215
00:07:48,400 --> 00:07:53,198
the kernel slide and get the kernel read

216
00:07:50,720 --> 00:07:55,440
write and finally manage to somehow get

217
00:07:53,199 --> 00:07:58,000
a send right to the kernel task port

218
00:07:55,440 --> 00:08:00,800
which is like get tasks for bit zero

219
00:07:58,000 --> 00:08:03,360
which is our total goal of the exploits

220
00:08:00,800 --> 00:08:04,160
so uh i talked to you little lilo and he

221
00:08:03,360 --> 00:08:06,639
suggested

222
00:08:04,160 --> 00:08:08,080
to spray out of blind mac messages for

223
00:08:06,639 --> 00:08:11,120
exploitation

224
00:08:08,080 --> 00:08:13,120
so i'm gonna talk a bit more about mock

225
00:08:11,120 --> 00:08:14,560
messages to understand what's happening

226
00:08:13,120 --> 00:08:17,360
here

227
00:08:14,560 --> 00:08:18,240
so you can send a mock message to a mock

228
00:08:17,360 --> 00:08:21,680
port

229
00:08:18,240 --> 00:08:22,479
right the sender does not need a port to

230
00:08:21,680 --> 00:08:25,280
identify

231
00:08:22,479 --> 00:08:26,000
like you don't need to say hey i'm this

232
00:08:25,280 --> 00:08:28,719
the issue with

233
00:08:26,000 --> 00:08:30,720
here is that i usually want to use that

234
00:08:28,720 --> 00:08:32,800
to call an api in a different process

235
00:08:30,720 --> 00:08:35,039
but you usually want to have a response

236
00:08:32,799 --> 00:08:35,919
so what's being done here when sending

237
00:08:35,039 --> 00:08:38,559
the message

238
00:08:35,919 --> 00:08:39,039
you append to the message ascend once

239
00:08:38,559 --> 00:08:42,319
right

240
00:08:39,039 --> 00:08:45,040
to import the other process controls so

241
00:08:42,320 --> 00:08:46,800
the process you call into has the send

242
00:08:45,040 --> 00:08:49,839
once right and he can reply

243
00:08:46,800 --> 00:08:52,000
with the message exactly once um it

244
00:08:49,839 --> 00:08:55,440
optionally can send more ports

245
00:08:52,000 --> 00:08:57,920
when i say sending ports in reality is

246
00:08:55,440 --> 00:08:58,560
send a right to a port and this right

247
00:08:57,920 --> 00:09:01,920
can be

248
00:08:58,560 --> 00:09:04,319
a receipt right or ascend right

249
00:09:01,920 --> 00:09:05,360
there's actually more than that you have

250
00:09:04,320 --> 00:09:08,000
like

251
00:09:05,360 --> 00:09:10,320
different types you can say i have this

252
00:09:08,000 --> 00:09:12,320
port i give this send right to you i can

253
00:09:10,320 --> 00:09:15,360
give you a send once right

254
00:09:12,320 --> 00:09:17,440
i can move or receive right um

255
00:09:15,360 --> 00:09:18,959
you can copy send right so there's like

256
00:09:17,440 --> 00:09:20,640
you have a send right and me have a send

257
00:09:18,959 --> 00:09:22,000
right but you cannot move uh you cannot

258
00:09:20,640 --> 00:09:23,279
copy your receipt right

259
00:09:22,000 --> 00:09:25,279
because remember there can be only one

260
00:09:23,279 --> 00:09:26,959
receiver but you can like have a port

261
00:09:25,279 --> 00:09:30,000
and move it over to someone else and he

262
00:09:26,959 --> 00:09:33,599
kind of owns it now

263
00:09:30,000 --> 00:09:37,760
so um ports

264
00:09:33,600 --> 00:09:40,720
can be sent in line and out of line

265
00:09:37,760 --> 00:09:42,800
so if you recall zones mock messages and

266
00:09:40,720 --> 00:09:44,640
mock ports they have dedicated heap

267
00:09:42,800 --> 00:09:47,760
zones for that which means

268
00:09:44,640 --> 00:09:50,160
in that zone only mock ports live only

269
00:09:47,760 --> 00:09:53,360
they can be allocated in that zone

270
00:09:50,160 --> 00:09:56,480
but mock message out of line buffer

271
00:09:53,360 --> 00:09:58,399
goes into a car lock zone and in catalog

272
00:09:56,480 --> 00:10:00,720
lots of things can be allocated like

273
00:09:58,399 --> 00:10:02,480
generally

274
00:10:00,720 --> 00:10:04,560
everything you'd use like milo fornica

275
00:10:02,480 --> 00:10:06,480
only is kellogg so if it falls into

276
00:10:04,560 --> 00:10:07,920
catalog zone we can potentially allocate

277
00:10:06,480 --> 00:10:09,839
something useful

278
00:10:07,920 --> 00:10:11,920
to show you the difference at the left

279
00:10:09,839 --> 00:10:13,920
we have an inline message so we have the

280
00:10:11,920 --> 00:10:16,479
header the body and i send like

281
00:10:13,920 --> 00:10:18,560
port descriptors three port descriptors

282
00:10:16,480 --> 00:10:20,480
in line and it's like kind of

283
00:10:18,560 --> 00:10:22,000
pointers at the time it gets through

284
00:10:20,480 --> 00:10:24,959
kernel which point

285
00:10:22,000 --> 00:10:25,440
to a mockboard versus an out of line you

286
00:10:24,959 --> 00:10:28,239
have the

287
00:10:25,440 --> 00:10:30,240
header the body and you say i'm sending

288
00:10:28,240 --> 00:10:33,200
these out of line so that thing

289
00:10:30,240 --> 00:10:34,800
contains a pointer to a catalog buffer

290
00:10:33,200 --> 00:10:38,240
and the catalog buffer

291
00:10:34,800 --> 00:10:40,880
just has pointers to the port

292
00:10:38,240 --> 00:10:43,360
and these this catalog buffer um this is

293
00:10:40,880 --> 00:10:46,079
the one we're gonna target

294
00:10:43,360 --> 00:10:47,360
so when sending mock messages with two

295
00:10:46,079 --> 00:10:50,800
out-of-line ports

296
00:10:47,360 --> 00:10:53,279
on 64-bit devices two pointers

297
00:10:50,800 --> 00:10:55,439
eight bytes it's 16 bytes so that goes

298
00:10:53,279 --> 00:10:57,680
into the catalog 16 zone

299
00:10:55,440 --> 00:10:58,560
we can set the first port to be machport

300
00:10:57,680 --> 00:11:01,120
now which

301
00:10:58,560 --> 00:11:03,439
nulls the first pointer so the first

302
00:11:01,120 --> 00:11:05,360
keyword is zero and that satisfies the

303
00:11:03,440 --> 00:11:06,560
condition relocate buffer with second

304
00:11:05,360 --> 00:11:09,040
word set to zero

305
00:11:06,560 --> 00:11:10,800
it's actually like uh second four bytes

306
00:11:09,040 --> 00:11:12,000
zero so all right we satisfy that

307
00:11:10,800 --> 00:11:15,519
condition

308
00:11:12,000 --> 00:11:20,160
and the second chord is a centroid

309
00:11:15,519 --> 00:11:22,800
to uh to just some port

310
00:11:20,160 --> 00:11:24,160
so what we're doing we have two threads

311
00:11:22,800 --> 00:11:27,040
uh one thread triggers

312
00:11:24,160 --> 00:11:27,680
lyo list style double free bug and the

313
00:11:27,040 --> 00:11:30,719
other

314
00:11:27,680 --> 00:11:32,479
continuously spray out-of-line ports

315
00:11:30,720 --> 00:11:33,760
keep sending messages with out-of-line

316
00:11:32,480 --> 00:11:36,000
ports uh

317
00:11:33,760 --> 00:11:36,880
let's say ox 4000 for no particular

318
00:11:36,000 --> 00:11:38,640
reason you

319
00:11:36,880 --> 00:11:40,320
for for things like that you just like

320
00:11:38,640 --> 00:11:43,279
generally trial and error and figure out

321
00:11:40,320 --> 00:11:44,640
what the best number is

322
00:11:43,279 --> 00:11:47,920
so essentially how it looks like in

323
00:11:44,640 --> 00:11:49,439
memory mock message gets allocated

324
00:11:47,920 --> 00:11:51,519
then the out-of-line buffer get

325
00:11:49,440 --> 00:11:54,000
allocated we keep sending more

326
00:11:51,519 --> 00:11:55,440
messages get allocated more out-of-line

327
00:11:54,000 --> 00:11:57,440
buffers get allocated

328
00:11:55,440 --> 00:11:59,920
and at some point when you allocate a

329
00:11:57,440 --> 00:12:04,399
mock message

330
00:11:59,920 --> 00:12:06,560
a lio object is allocated in catalog 16

331
00:12:04,399 --> 00:12:08,959
and then it's freed because the

332
00:12:06,560 --> 00:12:11,439
asynchronous thread finishes

333
00:12:08,959 --> 00:12:13,199
but then because of the message we send

334
00:12:11,440 --> 00:12:15,360
we reuse the same buffer like the

335
00:12:13,200 --> 00:12:16,560
allocations happens to fall into the

336
00:12:15,360 --> 00:12:20,160
same slot

337
00:12:16,560 --> 00:12:23,439
and the um ol buffer is there where uh

338
00:12:20,160 --> 00:12:26,800
lyo listio lived but because of the

339
00:12:23,440 --> 00:12:28,480
bug that uh memory is freed again so we

340
00:12:26,800 --> 00:12:30,319
have like a dangling pointer but if you

341
00:12:28,480 --> 00:12:31,920
keep spraying messages

342
00:12:30,320 --> 00:12:33,519
what happens is we allocate more

343
00:12:31,920 --> 00:12:36,560
messages and

344
00:12:33,519 --> 00:12:38,240
more uh out-of-line allocations so

345
00:12:36,560 --> 00:12:40,160
if you like keep doing that at some

346
00:12:38,240 --> 00:12:43,440
point we have two messages

347
00:12:40,160 --> 00:12:45,839
pointing to the same buffer

348
00:12:43,440 --> 00:12:47,360
uh so a different view of that is kind

349
00:12:45,839 --> 00:12:50,320
of like that so if you

350
00:12:47,360 --> 00:12:51,279
have a port and you send a send right to

351
00:12:50,320 --> 00:12:54,560
itself

352
00:12:51,279 --> 00:12:56,560
you can uh like check the handles

353
00:12:54,560 --> 00:12:58,638
you compare the one you're receiving the

354
00:12:56,560 --> 00:13:00,560
message on and the actual

355
00:12:58,639 --> 00:13:02,720
handle you received if it's the same

356
00:13:00,560 --> 00:13:04,719
then we have like the situation

357
00:13:02,720 --> 00:13:06,160
on the left where it's like one one or

358
00:13:04,720 --> 00:13:08,399
two two or something like that so you

359
00:13:06,160 --> 00:13:10,560
receive them in order

360
00:13:08,399 --> 00:13:12,000
and expect the first port and the

361
00:13:10,560 --> 00:13:13,760
message to be mocked or not because

362
00:13:12,000 --> 00:13:16,720
that's what we send it to

363
00:13:13,760 --> 00:13:17,439
and we expect the second port to be the

364
00:13:16,720 --> 00:13:19,360
same one

365
00:13:17,440 --> 00:13:20,800
as we receive on because they have like

366
00:13:19,360 --> 00:13:21,519
the same handle because this is one we

367
00:13:20,800 --> 00:13:24,079
send

368
00:13:21,519 --> 00:13:25,120
this is true for all but for the one

369
00:13:24,079 --> 00:13:28,319
where it overlapped

370
00:13:25,120 --> 00:13:30,240
because the letter um message

371
00:13:28,320 --> 00:13:32,079
overrode the earlier one so if we

372
00:13:30,240 --> 00:13:36,160
receive on port 3

373
00:13:32,079 --> 00:13:39,120
we will get back the handle four and

374
00:13:36,160 --> 00:13:40,079
uh since they get freed when we receive

375
00:13:39,120 --> 00:13:43,199
them

376
00:13:40,079 --> 00:13:43,839
um handle four will now have a dangling

377
00:13:43,199 --> 00:13:47,199
pointer

378
00:13:43,839 --> 00:13:50,480
pointing to something that's freed um

379
00:13:47,199 --> 00:13:53,760
so the next stage of this is

380
00:13:50,480 --> 00:13:56,880
every time we receive uh a message

381
00:13:53,760 --> 00:13:58,399
potentially this could be uh our target

382
00:13:56,880 --> 00:13:59,279
message the one where the backlight

383
00:13:58,399 --> 00:14:01,040
gripped

384
00:13:59,279 --> 00:14:03,279
so every time we received we're gonna

385
00:14:01,040 --> 00:14:06,880
spray os data objects to

386
00:14:03,279 --> 00:14:10,000
again reallocate that heap

387
00:14:06,880 --> 00:14:11,600
heap region so this time i set the

388
00:14:10,000 --> 00:14:14,880
second 8 bytes to 0

389
00:14:11,600 --> 00:14:16,000
to make sure like just for debugging and

390
00:14:14,880 --> 00:14:19,360
the first byte

391
00:14:16,000 --> 00:14:21,920
is a pointer to your mock port

392
00:14:19,360 --> 00:14:23,120
so when you now like you know that the

393
00:14:21,920 --> 00:14:25,040
handle 4

394
00:14:23,120 --> 00:14:26,800
has a dangling pointer which like

395
00:14:25,040 --> 00:14:28,959
potentially got reallocated and then

396
00:14:26,800 --> 00:14:35,120
when you receive on handle four

397
00:14:28,959 --> 00:14:37,119
it will get a handle to our fake port

398
00:14:35,120 --> 00:14:39,839
and this is good because now we have a

399
00:14:37,120 --> 00:14:42,639
handle to a port we control

400
00:14:39,839 --> 00:14:44,320
um yeah receive the mac messages where

401
00:14:42,639 --> 00:14:45,760
you're out of line buffer point of point

402
00:14:44,320 --> 00:14:47,839
server control data we get a poor

403
00:14:45,760 --> 00:14:49,839
descriptor to our fake port

404
00:14:47,839 --> 00:14:51,279
so here in this particular exploit i use

405
00:14:49,839 --> 00:14:54,399
an iphone 5s which

406
00:14:51,279 --> 00:14:56,720
does not have pan um

407
00:14:54,399 --> 00:14:59,040
so pan is privileged access never which

408
00:14:56,720 --> 00:15:01,199
is like s-map on x86

409
00:14:59,040 --> 00:15:02,800
um so this protection is not in place so

410
00:15:01,199 --> 00:15:04,399
i can just spray user space

411
00:15:02,800 --> 00:15:06,560
pointers and i can de-reference them

412
00:15:04,399 --> 00:15:08,720
from kernel mode uh so i put the

413
00:15:06,560 --> 00:15:09,839
the the port and user space and did

414
00:15:08,720 --> 00:15:12,639
exactly that

415
00:15:09,839 --> 00:15:14,399
and having like this you can pretty much

416
00:15:12,639 --> 00:15:17,440
just copy and paste vortex

417
00:15:14,399 --> 00:15:19,760
like vortex by zuza uh he like

418
00:15:17,440 --> 00:15:20,480
laid it out and after having like this

419
00:15:19,760 --> 00:15:23,120
primitive

420
00:15:20,480 --> 00:15:25,040
you just go there i will go into detail

421
00:15:23,120 --> 00:15:27,600
what like all of these steps means when

422
00:15:25,040 --> 00:15:29,680
talking about later exploits

423
00:15:27,600 --> 00:15:31,519
basically just real quick you leak a

424
00:15:29,680 --> 00:15:34,719
heap pointer to real court

425
00:15:31,519 --> 00:15:36,320
you keep leaking pointers and then you

426
00:15:34,720 --> 00:15:39,600
build a read primitive

427
00:15:36,320 --> 00:15:40,639
using uh get pit for task same as like

428
00:15:39,600 --> 00:15:44,160
the previous

429
00:15:40,639 --> 00:15:45,120
ios talk mentioned you leak the kslr

430
00:15:44,160 --> 00:15:47,759
slide

431
00:15:45,120 --> 00:15:48,399
build the k call primitive on devices

432
00:15:47,759 --> 00:15:50,160
where you can

433
00:15:48,399 --> 00:15:52,560
like know what pack it's more difficult

434
00:15:50,160 --> 00:15:54,399
but back then it was super easy

435
00:15:52,560 --> 00:15:56,319
k call also gives you okay right because

436
00:15:54,399 --> 00:15:57,360
you can jump to a gadget which does a

437
00:15:56,320 --> 00:16:00,320
store

438
00:15:57,360 --> 00:16:02,560
and yeah that's kind of where to go um

439
00:16:00,320 --> 00:16:03,600
the issue here if you like just try copy

440
00:16:02,560 --> 00:16:06,959
and pasting that

441
00:16:03,600 --> 00:16:10,320
and the part from vortex is that here

442
00:16:06,959 --> 00:16:12,800
we spray send rights to a port

443
00:16:10,320 --> 00:16:13,839
and not a receive right but for vortex

444
00:16:12,800 --> 00:16:17,040
we actually need

445
00:16:13,839 --> 00:16:17,440
to get a receive right because we need

446
00:16:17,040 --> 00:16:20,160
that

447
00:16:17,440 --> 00:16:21,199
for doing registering that notification

448
00:16:20,160 --> 00:16:22,639
and we can't like

449
00:16:21,199 --> 00:16:24,479
call that function without having a

450
00:16:22,639 --> 00:16:27,199
receive right to the port

451
00:16:24,480 --> 00:16:28,160
um so we way we do it is we receive on

452
00:16:27,199 --> 00:16:30,079
the port

453
00:16:28,160 --> 00:16:32,399
and expect to be to receive the same

454
00:16:30,079 --> 00:16:34,800
handle we can't do that for

455
00:16:32,399 --> 00:16:36,079
receive right because like we can't have

456
00:16:34,800 --> 00:16:38,399
two receive rights and if we

457
00:16:36,079 --> 00:16:40,160
send away our receive right we cannot

458
00:16:38,399 --> 00:16:41,920
receive messages anymore

459
00:16:40,160 --> 00:16:44,160
but the solution to this is like quite

460
00:16:41,920 --> 00:16:46,479
simple just keep two lists

461
00:16:44,160 --> 00:16:48,240
one list for where you receive the

462
00:16:46,480 --> 00:16:50,639
actual message on and a different

463
00:16:48,240 --> 00:16:51,519
list where you give away the receive

464
00:16:50,639 --> 00:16:54,560
right

465
00:16:51,519 --> 00:16:56,240
um and for the one where we give away

466
00:16:54,560 --> 00:16:58,160
the receive right we actually also

467
00:16:56,240 --> 00:16:59,920
need to keep the centroid to the port

468
00:16:58,160 --> 00:17:01,759
just that the port keeps the handle so

469
00:16:59,920 --> 00:17:03,759
we can recognize it later

470
00:17:01,759 --> 00:17:05,599
so before it looks like this so starting

471
00:17:03,759 --> 00:17:08,160
from the green mark message

472
00:17:05,599 --> 00:17:09,918
gets sent to the blue mark port it

473
00:17:08,160 --> 00:17:12,000
contains an out of line buffer

474
00:17:09,919 --> 00:17:13,839
which also points to the mark board so

475
00:17:12,000 --> 00:17:16,400
when we receive it we check

476
00:17:13,839 --> 00:17:17,119
if the p thing that we received is like

477
00:17:16,400 --> 00:17:20,559
port

478
00:17:17,119 --> 00:17:23,839
one pretty much after we change it

479
00:17:20,559 --> 00:17:26,559
we receive like on port

480
00:17:23,839 --> 00:17:28,960
one index i like we keep two lists send

481
00:17:26,559 --> 00:17:29,440
a message over and we expect it to be

482
00:17:28,960 --> 00:17:32,880
port

483
00:17:29,440 --> 00:17:35,919
two in x i and if it's a different one

484
00:17:32,880 --> 00:17:39,200
then we found an overlapping thing

485
00:17:35,919 --> 00:17:42,320
so if you want to go with pan um

486
00:17:39,200 --> 00:17:45,039
you would like spray first

487
00:17:42,320 --> 00:17:45,678
like get the setup but then instead of

488
00:17:45,039 --> 00:17:47,679
spraying

489
00:17:45,679 --> 00:17:49,840
user space pointers you would continue

490
00:17:47,679 --> 00:17:52,000
and receive the other message

491
00:17:49,840 --> 00:17:53,360
so the buffer gets freed again and you

492
00:17:52,000 --> 00:17:56,559
won't reallocate

493
00:17:53,360 --> 00:17:57,600
again with the real mark ports now then

494
00:17:56,559 --> 00:18:00,399
you have

495
00:17:57,600 --> 00:18:02,399
um a real pointer and then you can use

496
00:18:00,400 --> 00:18:04,480
your hours data primitive

497
00:18:02,400 --> 00:18:06,400
to read back the pointer and then you

498
00:18:04,480 --> 00:18:09,679
can leak the pointer

499
00:18:06,400 --> 00:18:12,080
um increase it by i don't know

500
00:18:09,679 --> 00:18:12,960
some page size and increase it by 64

501
00:18:12,080 --> 00:18:15,280
pages

502
00:18:12,960 --> 00:18:17,120
and then you have a rough idea where uh

503
00:18:15,280 --> 00:18:17,918
in heap some allocations will be

504
00:18:17,120 --> 00:18:20,080
happening

505
00:18:17,919 --> 00:18:21,200
you try to spray there and put the fake

506
00:18:20,080 --> 00:18:22,720
pointer there

507
00:18:21,200 --> 00:18:24,880
um i don't want to go too much into

508
00:18:22,720 --> 00:18:26,840
detail with that but like for maybe for

509
00:18:24,880 --> 00:18:30,720
re-reading the slides

510
00:18:26,840 --> 00:18:32,959
um yeah a pan less version was chosen

511
00:18:30,720 --> 00:18:35,200
because catalog 16 is very noisy so

512
00:18:32,960 --> 00:18:37,440
every time you do a reallocation

513
00:18:35,200 --> 00:18:39,280
if you don't actually allocate the slot

514
00:18:37,440 --> 00:18:40,880
but something others takes that slot

515
00:18:39,280 --> 00:18:42,639
your device will panic

516
00:18:40,880 --> 00:18:43,919
so and there's a lot of allocation

517
00:18:42,640 --> 00:18:45,760
happening so if you want to go for the

518
00:18:43,919 --> 00:18:47,440
painful version of this exploit that's

519
00:18:45,760 --> 00:18:50,559
left as an exercise to the reader but

520
00:18:47,440 --> 00:18:52,960
like it is as painful as it sounds

521
00:18:50,559 --> 00:18:53,678
uh spawning and suspending threats might

522
00:18:52,960 --> 00:18:56,000
help to

523
00:18:53,679 --> 00:18:57,520
resi to increase the success rate just

524
00:18:56,000 --> 00:19:00,400
run your own experiments

525
00:18:57,520 --> 00:19:02,720
also real quick um there's been a pan

526
00:19:00,400 --> 00:19:03,200
bypass by zigza basically what allows it

527
00:19:02,720 --> 00:19:06,720
to do

528
00:19:03,200 --> 00:19:07,600
is to have a read only page in user

529
00:19:06,720 --> 00:19:10,160
space

530
00:19:07,600 --> 00:19:12,159
and have the kernel like being able to

531
00:19:10,160 --> 00:19:15,039
dereference and read from it

532
00:19:12,160 --> 00:19:16,480
uh even with pan the issue here is that

533
00:19:15,039 --> 00:19:18,080
the kernel actually can't

534
00:19:16,480 --> 00:19:20,799
write to it due to the nature of this

535
00:19:18,080 --> 00:19:22,960
bug so it's not as trivial to

536
00:19:20,799 --> 00:19:24,720
use that with the primitive because we

537
00:19:22,960 --> 00:19:26,240
actually need to write to these ports

538
00:19:24,720 --> 00:19:27,760
but maybe you can figure out something

539
00:19:26,240 --> 00:19:30,880
with that just wanted to show

540
00:19:27,760 --> 00:19:33,039
that's the thing um let's jump into the

541
00:19:30,880 --> 00:19:36,240
next box so this was also taken from

542
00:19:33,039 --> 00:19:39,520
block 360 ccn

543
00:19:36,240 --> 00:19:41,679
and it's the ipc voucher used after free

544
00:19:39,520 --> 00:19:44,960
or maybe you know it from me in beards

545
00:19:41,679 --> 00:19:47,120
uh vulture swap um

546
00:19:44,960 --> 00:19:48,960
so basically this is the code and make

547
00:19:47,120 --> 00:19:52,000
um it has a bug

548
00:19:48,960 --> 00:19:55,120
it's pretty hard like it's not obvious

549
00:19:52,000 --> 00:19:56,799
to see what the bug is the problem is in

550
00:19:55,120 --> 00:19:58,719
assumptions that are made around that

551
00:19:56,799 --> 00:20:01,520
thing so mark

552
00:19:58,720 --> 00:20:03,039
is mark interf mick mick is mark

553
00:20:01,520 --> 00:20:04,400
interface generator

554
00:20:03,039 --> 00:20:06,320
it's too complex to cover in this

555
00:20:04,400 --> 00:20:07,440
presentation i have no clue how it works

556
00:20:06,320 --> 00:20:10,000
because it's like

557
00:20:07,440 --> 00:20:11,840
a bunch of like printfs that generate

558
00:20:10,000 --> 00:20:15,200
your c code

559
00:20:11,840 --> 00:20:16,799
from dev files and basically what gives

560
00:20:15,200 --> 00:20:19,600
you it's like an easy to use

561
00:20:16,799 --> 00:20:20,559
functions which use mac api integer hood

562
00:20:19,600 --> 00:20:22,559
say you have like

563
00:20:20,559 --> 00:20:24,639
two processes you want to like kind of

564
00:20:22,559 --> 00:20:25,039
run a server and they communicate over

565
00:20:24,640 --> 00:20:26,640
mock

566
00:20:25,039 --> 00:20:28,480
to being able to call a function in

567
00:20:26,640 --> 00:20:31,120
there you can use that

568
00:20:28,480 --> 00:20:31,520
uh so when drawing my experiments i was

569
00:20:31,120 --> 00:20:34,000
like

570
00:20:31,520 --> 00:20:36,080
trying things out so i talked to zuguza

571
00:20:34,000 --> 00:20:36,880
he sent me this piece of code he was

572
00:20:36,080 --> 00:20:39,678
like

573
00:20:36,880 --> 00:20:41,200
these uh what's that like five six lines

574
00:20:39,679 --> 00:20:42,240
of code and he was like yeah it's super

575
00:20:41,200 --> 00:20:45,360
easy just run

576
00:20:42,240 --> 00:20:48,799
make code staff and then you get

577
00:20:45,360 --> 00:20:50,520
holy like a lot of code so how much

578
00:20:48,799 --> 00:20:53,918
code is that it's like

579
00:20:50,520 --> 00:20:56,799
822 lines generated for you

580
00:20:53,919 --> 00:20:57,200
just from like these five lines of code

581
00:20:56,799 --> 00:21:00,080
so

582
00:20:57,200 --> 00:21:01,120
it generates a lot of code it's very

583
00:21:00,080 --> 00:21:04,639
complex

584
00:21:01,120 --> 00:21:05,918
so the thing is it has a set of rules

585
00:21:04,640 --> 00:21:08,000
and assumptions

586
00:21:05,919 --> 00:21:08,920
and things break when these assumptions

587
00:21:08,000 --> 00:21:10,000
are in

588
00:21:08,920 --> 00:21:11,919
[Applause]

589
00:21:10,000 --> 00:21:14,400
invalidated and this is what happened

590
00:21:11,919 --> 00:21:16,240
here it's not due to the code but it was

591
00:21:14,400 --> 00:21:18,240
the code was doing something

592
00:21:16,240 --> 00:21:19,919
which broke assumptions built around

593
00:21:18,240 --> 00:21:21,600
mick but

594
00:21:19,919 --> 00:21:23,440
i really don't want to focus on mick

595
00:21:21,600 --> 00:21:24,320
let's just jump into the park because

596
00:21:23,440 --> 00:21:26,559
this is

597
00:21:24,320 --> 00:21:28,158
as much as i like looked into make just

598
00:21:26,559 --> 00:21:31,360
for this presentation

599
00:21:28,159 --> 00:21:33,200
so sorry my bad tweeted this screenshot

600
00:21:31,360 --> 00:21:35,120
it's actually a screenshot so i can

601
00:21:33,200 --> 00:21:36,640
uh not make it like bigger or better

602
00:21:35,120 --> 00:21:39,360
readable but that's fine

603
00:21:36,640 --> 00:21:40,640
so this is what i used to um to get

604
00:21:39,360 --> 00:21:44,000
started i typed it on

605
00:21:40,640 --> 00:21:47,200
on my um run run in xcode run

606
00:21:44,000 --> 00:21:49,840
it and it crashes perfect for me

607
00:21:47,200 --> 00:21:51,360
so let's examine this code if you can't

608
00:21:49,840 --> 00:21:52,000
read it that's fine don't worry about it

609
00:21:51,360 --> 00:21:54,719
basically

610
00:21:52,000 --> 00:21:55,600
we have four primitives which this part

611
00:21:54,720 --> 00:21:58,080
gives us

612
00:21:55,600 --> 00:21:59,520
we can create vouchers like we can

613
00:21:58,080 --> 00:22:02,639
allocate them

614
00:21:59,520 --> 00:22:03,120
we can register voucher to a thread all

615
00:22:02,640 --> 00:22:06,559
right

616
00:22:03,120 --> 00:22:08,719
cool we can free voucher by using this

617
00:22:06,559 --> 00:22:10,320
buck by decrement reference and use

618
00:22:08,720 --> 00:22:12,720
reference counting internally

619
00:22:10,320 --> 00:22:13,840
and we can somehow access the dangling

620
00:22:12,720 --> 00:22:16,640
voucher

621
00:22:13,840 --> 00:22:18,720
this is all we need to get started so

622
00:22:16,640 --> 00:22:21,440
the expectation plan for this

623
00:22:18,720 --> 00:22:23,600
is get a dangling voucher pointer so

624
00:22:21,440 --> 00:22:26,799
just unlock the voucher and drop

625
00:22:23,600 --> 00:22:28,399
to drop an extra reference um then

626
00:22:26,799 --> 00:22:31,039
somehow release the page

627
00:22:28,400 --> 00:22:31,600
from the voucher zone re-allocate the

628
00:22:31,039 --> 00:22:34,158
page

629
00:22:31,600 --> 00:22:35,600
in a zone and fill it with control data

630
00:22:34,159 --> 00:22:36,159
because remember there's like different

631
00:22:35,600 --> 00:22:38,240
zones

632
00:22:36,159 --> 00:22:39,360
and if a page belongs to one zone you

633
00:22:38,240 --> 00:22:42,799
can't unlock

634
00:22:39,360 --> 00:22:43,600
other data in it a leak pointer to a

635
00:22:42,799 --> 00:22:46,480
real ipc

636
00:22:43,600 --> 00:22:48,959
port modify the pointer craft fake port

637
00:22:46,480 --> 00:22:50,880
and kernel and get a carry primitive

638
00:22:48,960 --> 00:22:52,480
right sounds easy enough all right let's

639
00:22:50,880 --> 00:22:53,200
see how we do that so for the wintex

640
00:22:52,480 --> 00:22:56,159
exploit

641
00:22:53,200 --> 00:22:57,679
we're doing is following this is memory

642
00:22:56,159 --> 00:23:00,880
that's your ram

643
00:22:57,679 --> 00:23:03,200
memory is divided into pages

644
00:23:00,880 --> 00:23:04,559
all right good enough some pages are

645
00:23:03,200 --> 00:23:07,039
already allocated

646
00:23:04,559 --> 00:23:08,720
and sometimes there's like holes in it

647
00:23:07,039 --> 00:23:09,679
because like it's not consecutively

648
00:23:08,720 --> 00:23:11,280
allocated

649
00:23:09,679 --> 00:23:13,520
we don't really know the state but we

650
00:23:11,280 --> 00:23:14,720
assume we have some kind of state like

651
00:23:13,520 --> 00:23:17,679
this

652
00:23:14,720 --> 00:23:20,240
um so what i'm starting to do is i'm

653
00:23:17,679 --> 00:23:22,640
starting to allocate vouchers

654
00:23:20,240 --> 00:23:24,080
i'm calling them gc vouchers but really

655
00:23:22,640 --> 00:23:26,640
i just like call an api

656
00:23:24,080 --> 00:23:28,559
to know they're allocated in the kernel

657
00:23:26,640 --> 00:23:29,280
so we allocate these so called gc

658
00:23:28,559 --> 00:23:32,000
vouchers

659
00:23:29,280 --> 00:23:32,639
starts filling the holes and then we

660
00:23:32,000 --> 00:23:35,280
allocate

661
00:23:32,640 --> 00:23:37,200
the before vouchers the main purpose of

662
00:23:35,280 --> 00:23:37,918
them is to fill the holes so we can

663
00:23:37,200 --> 00:23:40,240
assume

664
00:23:37,919 --> 00:23:42,480
starting from now we have like linear

665
00:23:40,240 --> 00:23:44,240
continuous space and we hope it's like

666
00:23:42,480 --> 00:23:46,320
that

667
00:23:44,240 --> 00:23:47,919
before vouchers don't necessarily fill

668
00:23:46,320 --> 00:23:51,120
up the full page so we can have

669
00:23:47,919 --> 00:23:54,240
something like this so

670
00:23:51,120 --> 00:23:56,239
then we allocate our target voucher this

671
00:23:54,240 --> 00:23:57,120
is the one we're going like use the back

672
00:23:56,240 --> 00:23:59,440
on

673
00:23:57,120 --> 00:24:01,360
and after that we allocate after

674
00:23:59,440 --> 00:24:01,840
vouchers because what we need to make

675
00:24:01,360 --> 00:24:04,879
sure

676
00:24:01,840 --> 00:24:07,600
is that all allocations in this

677
00:24:04,880 --> 00:24:09,360
page belong to us we can't have that

678
00:24:07,600 --> 00:24:11,279
another process allocate something so we

679
00:24:09,360 --> 00:24:14,959
hope this is the setup

680
00:24:11,279 --> 00:24:16,880
um we allocate more after vouchers

681
00:24:14,960 --> 00:24:19,279
so when dropping an extra reference on

682
00:24:16,880 --> 00:24:20,720
the target voucher it gets freed so you

683
00:24:19,279 --> 00:24:23,279
see it's black

684
00:24:20,720 --> 00:24:24,480
now what we're gonna do is we free all

685
00:24:23,279 --> 00:24:26,720
the four vouchers

686
00:24:24,480 --> 00:24:28,480
and all after roaches by just freeing

687
00:24:26,720 --> 00:24:30,720
them they're probably still

688
00:24:28,480 --> 00:24:32,320
in the vulture zone because as i

689
00:24:30,720 --> 00:24:34,159
mentioned before these things are

690
00:24:32,320 --> 00:24:35,918
garbage collected so just freeing every

691
00:24:34,159 --> 00:24:38,080
element doesn't mean we release the zone

692
00:24:35,919 --> 00:24:41,039
and we need to zone to be released

693
00:24:38,080 --> 00:24:43,279
like we need to release the page so now

694
00:24:41,039 --> 00:24:46,400
the gc vouchers come in place

695
00:24:43,279 --> 00:24:48,799
we free the gc vouchers to have them

696
00:24:46,400 --> 00:24:50,400
a at the very top of the free list in

697
00:24:48,799 --> 00:24:52,080
case there is such a thing

698
00:24:50,400 --> 00:24:53,600
as a free list which i'm which i don't

699
00:24:52,080 --> 00:24:56,320
know and b

700
00:24:53,600 --> 00:24:57,199
they also hopefully like at lower

701
00:24:56,320 --> 00:24:59,120
addresses

702
00:24:57,200 --> 00:25:00,960
and memory as everything else so these

703
00:24:59,120 --> 00:25:03,520
are the two assumptions i make

704
00:25:00,960 --> 00:25:04,799
so so the assumption is then when i do

705
00:25:03,520 --> 00:25:07,200
an allocation next

706
00:25:04,799 --> 00:25:10,000
hopefully it will be one of the gc

707
00:25:07,200 --> 00:25:12,240
vouchers slots reused

708
00:25:10,000 --> 00:25:14,000
now we trigger a garbage collection to

709
00:25:12,240 --> 00:25:16,720
release unused pages but

710
00:25:14,000 --> 00:25:17,600
how exactly do we do that well we can

711
00:25:16,720 --> 00:25:20,159
slowly

712
00:25:17,600 --> 00:25:21,439
allocate vouchers and each time we

713
00:25:20,159 --> 00:25:24,720
allocate a voucher

714
00:25:21,440 --> 00:25:26,240
we measure the time so when we see a

715
00:25:24,720 --> 00:25:30,880
peak in time

716
00:25:26,240 --> 00:25:30,880
we can use that as information that um

717
00:25:31,279 --> 00:25:35,440
that the garbage collection did its job

718
00:25:33,760 --> 00:25:38,320
and the pages got freed

719
00:25:35,440 --> 00:25:40,080
quick note here if you have another huge

720
00:25:38,320 --> 00:25:42,158
time peak that could mean that you

721
00:25:40,080 --> 00:25:44,639
actually allocated more pages

722
00:25:42,159 --> 00:25:46,080
which you don't want but basically using

723
00:25:44,640 --> 00:25:47,440
this timing side channel

724
00:25:46,080 --> 00:25:48,960
you can figure out when the garbage

725
00:25:47,440 --> 00:25:50,960
collection did its thing and stop

726
00:25:48,960 --> 00:25:54,240
allocating

727
00:25:50,960 --> 00:25:56,240
now we spray control data and hope

728
00:25:54,240 --> 00:25:59,679
it will fall into the same page where

729
00:25:56,240 --> 00:25:59,679
our voucher was

730
00:25:59,840 --> 00:26:03,279
we released the unused gc vouchers

731
00:26:01,600 --> 00:26:05,199
because we don't care anymore and we

732
00:26:03,279 --> 00:26:08,640
don't want like memory pressure because

733
00:26:05,200 --> 00:26:08,640
there's no swap on ios

734
00:26:08,799 --> 00:26:12,879
now we read back the dangly vulture and

735
00:26:10,960 --> 00:26:14,559
the thing with the vouchers is

736
00:26:12,880 --> 00:26:16,799
they have like a field like it's a

737
00:26:14,559 --> 00:26:19,760
struct and if it's zero

738
00:26:16,799 --> 00:26:21,360
like null which we can uh force we just

739
00:26:19,760 --> 00:26:23,760
spray like zero

740
00:26:21,360 --> 00:26:24,799
and it reads it back it says hey there's

741
00:26:23,760 --> 00:26:27,120
no like port

742
00:26:24,799 --> 00:26:29,120
so i will allocate one for you and store

743
00:26:27,120 --> 00:26:29,760
the pointer in there so by reading it

744
00:26:29,120 --> 00:26:31,760
back

745
00:26:29,760 --> 00:26:34,559
it makes a new allocation and stores the

746
00:26:31,760 --> 00:26:36,879
pointer in there

747
00:26:34,559 --> 00:26:38,320
so by reading back the os data we

748
00:26:36,880 --> 00:26:40,559
actually leak the pointer

749
00:26:38,320 --> 00:26:41,600
and the dangling voucher can fall into

750
00:26:40,559 --> 00:26:44,879
several

751
00:26:41,600 --> 00:26:46,959
places uh can either be all page or new

752
00:26:44,880 --> 00:26:50,159
page here i just assume

753
00:26:46,960 --> 00:26:52,240
it's like behind our things it really

754
00:26:50,159 --> 00:26:54,960
doesn't matter we could like increase

755
00:26:52,240 --> 00:26:57,120
likelihood of also spraying ports but

756
00:26:54,960 --> 00:27:00,240
here i just assume it's like that

757
00:26:57,120 --> 00:27:02,399
um and go from here

758
00:27:00,240 --> 00:27:04,880
so this is the setup we have right now

759
00:27:02,400 --> 00:27:07,200
we have a heap

760
00:27:04,880 --> 00:27:08,320
pointer to a real port so we know where

761
00:27:07,200 --> 00:27:10,640
this pt

762
00:27:08,320 --> 00:27:13,039
thing is what we're going to do is we

763
00:27:10,640 --> 00:27:17,440
allocate more ports

764
00:27:13,039 --> 00:27:17,919
so next we want to increment the pointer

765
00:27:17,440 --> 00:27:21,200
by

766
00:27:17,919 --> 00:27:24,720
enough pages and align it

767
00:27:21,200 --> 00:27:25,600
to a start of a page um this is done by

768
00:27:24,720 --> 00:27:28,080
uh

769
00:27:25,600 --> 00:27:29,918
freeing like freeing the os data and

770
00:27:28,080 --> 00:27:31,840
reallocating back and hope it falls into

771
00:27:29,919 --> 00:27:33,120
the same slot this is how we like modify

772
00:27:31,840 --> 00:27:37,120
the data in the

773
00:27:33,120 --> 00:27:40,559
vt thing so i then we hope it points to

774
00:27:37,120 --> 00:27:43,840
the start of an unused unallocated page

775
00:27:40,559 --> 00:27:46,000
then we allocate more data but this time

776
00:27:43,840 --> 00:27:47,279
fake ports and we hope that the pointer

777
00:27:46,000 --> 00:27:51,360
we sprayed before

778
00:27:47,279 --> 00:27:54,320
now points on this fake port

779
00:27:51,360 --> 00:27:56,879
from here let's take a look how vortex

780
00:27:54,320 --> 00:27:59,918
does carry so having a fake

781
00:27:56,880 --> 00:28:00,720
port pointing to a fake task which

782
00:27:59,919 --> 00:28:04,159
resides

783
00:28:00,720 --> 00:28:07,360
in the same data buffer that's the way

784
00:28:04,159 --> 00:28:11,279
vortex does it then we use the fake task

785
00:28:07,360 --> 00:28:12,158
the task bsd info member to overlap with

786
00:28:11,279 --> 00:28:15,520
the fake ports

787
00:28:12,159 --> 00:28:18,240
context member because we can use

788
00:28:15,520 --> 00:28:20,399
pit for task to dereference that field

789
00:28:18,240 --> 00:28:24,880
and read 32-bit

790
00:28:20,399 --> 00:28:27,520
and we can use an api port set context

791
00:28:24,880 --> 00:28:29,520
to modify this context so we can from

792
00:28:27,520 --> 00:28:30,000
user space called one function to set a

793
00:28:29,520 --> 00:28:31,600
pointer

794
00:28:30,000 --> 00:28:33,039
and call the other function to read from

795
00:28:31,600 --> 00:28:35,120
it pretty convenient

796
00:28:33,039 --> 00:28:36,799
the issue here is that for setting the

797
00:28:35,120 --> 00:28:39,039
context we need a receive

798
00:28:36,799 --> 00:28:40,960
write which we don't have here and

799
00:28:39,039 --> 00:28:42,640
unlike the exploit before where we can

800
00:28:40,960 --> 00:28:43,279
like do some trickery to actually

801
00:28:42,640 --> 00:28:46,080
receive

802
00:28:43,279 --> 00:28:48,080
uh receive right we can't do due to the

803
00:28:46,080 --> 00:28:49,678
nature of how vouchers work we don't get

804
00:28:48,080 --> 00:28:51,120
a receipt right so we gotta live with

805
00:28:49,679 --> 00:28:53,200
the scent right

806
00:28:51,120 --> 00:28:54,479
i need to figure out something else what

807
00:28:53,200 --> 00:28:57,840
we can do is

808
00:28:54,480 --> 00:29:01,039
we make the fake port k object

809
00:28:57,840 --> 00:29:03,840
overlap with the real ipc port

810
00:29:01,039 --> 00:29:05,600
where we do have the receive write we

811
00:29:03,840 --> 00:29:08,720
can then on these ports

812
00:29:05,600 --> 00:29:10,080
set the context member and do the same

813
00:29:08,720 --> 00:29:12,320
trick again

814
00:29:10,080 --> 00:29:13,199
there's just one constraint when like

815
00:29:12,320 --> 00:29:14,799
pointing that

816
00:29:13,200 --> 00:29:17,200
to arbitrary data we need to make sure

817
00:29:14,799 --> 00:29:21,760
that the reference count is not zero

818
00:29:17,200 --> 00:29:23,600
um let's see if we can satisfy that so

819
00:29:21,760 --> 00:29:25,200
what we do here like all the ports we

820
00:29:23,600 --> 00:29:27,600
sprayed we actually spread

821
00:29:25,200 --> 00:29:29,520
receive rights because we don't need to

822
00:29:27,600 --> 00:29:31,678
oh we sprayed ports where we do have

823
00:29:29,520 --> 00:29:33,918
receive rights to them

824
00:29:31,679 --> 00:29:35,039
so this is how the ports look like in

825
00:29:33,919 --> 00:29:38,159
the page

826
00:29:35,039 --> 00:29:41,039
or just one page so this huge struct

827
00:29:38,159 --> 00:29:41,360
is like the k port t it's not taken from

828
00:29:41,039 --> 00:29:43,360
the

829
00:29:41,360 --> 00:29:45,600
uh x new source code but it's like the

830
00:29:43,360 --> 00:29:48,158
one we just implemented so it's

831
00:29:45,600 --> 00:29:50,240
sizes and fields everything match

832
00:29:48,159 --> 00:29:54,320
basically we have like one field

833
00:29:50,240 --> 00:29:57,760
which is ipcontext which is about here

834
00:29:54,320 --> 00:29:58,559
if we take the k task which is the other

835
00:29:57,760 --> 00:30:01,520
thing

836
00:29:58,559 --> 00:30:03,120
and make sure that these two overlap we

837
00:30:01,520 --> 00:30:05,120
have something like that so we would

838
00:30:03,120 --> 00:30:07,279
point there so these two align

839
00:30:05,120 --> 00:30:08,158
and overlap now we need to make sure

840
00:30:07,279 --> 00:30:10,559
that the reference

841
00:30:08,159 --> 00:30:11,279
count is non-zero so this actually

842
00:30:10,559 --> 00:30:14,320
overlaps

843
00:30:11,279 --> 00:30:18,000
with way different port with the

844
00:30:14,320 --> 00:30:20,320
ip requests uh field

845
00:30:18,000 --> 00:30:21,360
we need to make sure this is non-zero

846
00:30:20,320 --> 00:30:24,240
and here

847
00:30:21,360 --> 00:30:25,840
every value works okay test reference uh

848
00:30:24,240 --> 00:30:28,399
refcount overlaps with

849
00:30:25,840 --> 00:30:29,760
iprequest to get a valid ref count and

850
00:30:28,399 --> 00:30:33,360
ios 11

851
00:30:29,760 --> 00:30:35,760
ip request needs to be um zero

852
00:30:33,360 --> 00:30:37,520
nonzero so any pointer value like

853
00:30:35,760 --> 00:30:40,720
anything non-zero is fine

854
00:30:37,520 --> 00:30:44,158
we can do ip requests on all

855
00:30:40,720 --> 00:30:46,559
on all spray ports we can

856
00:30:44,159 --> 00:30:48,080
just port set attributes and it will

857
00:30:46,559 --> 00:30:51,600
cause an allocation

858
00:30:48,080 --> 00:30:54,960
and store a pointer there

859
00:30:51,600 --> 00:30:56,559
so for the vintex k-read we just

860
00:30:54,960 --> 00:30:58,080
uh if you can't read it don't worry but

861
00:30:56,559 --> 00:31:00,320
i think it should be readable right

862
00:30:58,080 --> 00:31:01,360
so macport set attributes on every port

863
00:31:00,320 --> 00:31:05,200
we sprayed

864
00:31:01,360 --> 00:31:06,639
and then we can pit for task to read

865
00:31:05,200 --> 00:31:10,080
back

866
00:31:06,640 --> 00:31:11,519
um fake port points to fake tasks with

867
00:31:10,080 --> 00:31:15,199
overlaps with real port

868
00:31:11,519 --> 00:31:18,320
yeah because we already know the

869
00:31:15,200 --> 00:31:21,120
pointer of a real port the one we

870
00:31:18,320 --> 00:31:23,439
uh leaked at the very first stage and

871
00:31:21,120 --> 00:31:26,559
then if we just subtract the size

872
00:31:23,440 --> 00:31:29,600
we get a different one and then

873
00:31:26,559 --> 00:31:32,080
that's good enough now we can k

874
00:31:29,600 --> 00:31:32,879
read right set a pointer with port set

875
00:31:32,080 --> 00:31:36,000
context

876
00:31:32,880 --> 00:31:36,799
for all the ports and then use pit for

877
00:31:36,000 --> 00:31:38,880
tasks to read it

878
00:31:36,799 --> 00:31:40,158
so this is actually quite slow because

879
00:31:38,880 --> 00:31:42,320
since we don't know which

880
00:31:40,159 --> 00:31:44,080
port exactly is the one overlapping we

881
00:31:42,320 --> 00:31:47,039
need to set that thing on all ports

882
00:31:44,080 --> 00:31:47,760
before we can do a four byte read now we

883
00:31:47,039 --> 00:31:51,120
got

884
00:31:47,760 --> 00:31:54,399
k read and a pointer to a real port

885
00:31:51,120 --> 00:31:57,439
with receive right and we can proceed uh

886
00:31:54,399 --> 00:32:00,959
with vortex to leak it key space

887
00:31:57,440 --> 00:32:04,000
self task io surface root user client

888
00:32:00,960 --> 00:32:05,919
the port the c plus plus object

889
00:32:04,000 --> 00:32:08,080
and the v table and then going through

890
00:32:05,919 --> 00:32:10,720
the v table we can

891
00:32:08,080 --> 00:32:11,840
leak the kernel base as already

892
00:32:10,720 --> 00:32:15,519
presented in the

893
00:32:11,840 --> 00:32:19,120
jailbreak talk before basically you just

894
00:32:15,519 --> 00:32:20,799
have this allocation um and you

895
00:32:19,120 --> 00:32:22,158
leak up the pointers there's like a

896
00:32:20,799 --> 00:32:24,320
hierarchy of pointers

897
00:32:22,159 --> 00:32:26,080
one object saying i belong to this i

898
00:32:24,320 --> 00:32:28,320
belong to this so the port belongs to

899
00:32:26,080 --> 00:32:30,480
the space the space belongs to the task

900
00:32:28,320 --> 00:32:31,840
if you know where the task is you can

901
00:32:30,480 --> 00:32:34,159
call an api

902
00:32:31,840 --> 00:32:36,720
as saying uh markboard registers with

903
00:32:34,159 --> 00:32:37,440
which writes a pointer into that task

904
00:32:36,720 --> 00:32:39,279
struct

905
00:32:37,440 --> 00:32:40,559
from there you just read in an offset

906
00:32:39,279 --> 00:32:43,679
get that pointer

907
00:32:40,559 --> 00:32:44,158
so you leave the um port of an iokit

908
00:32:43,679 --> 00:32:46,960
object

909
00:32:44,159 --> 00:32:47,760
that one has a port to a c plus object

910
00:32:46,960 --> 00:32:50,640
that has a v

911
00:32:47,760 --> 00:32:51,360
table and reading v table it points into

912
00:32:50,640 --> 00:32:53,440
the kernel

913
00:32:51,360 --> 00:32:54,639
text segment and from there you can just

914
00:32:53,440 --> 00:32:57,919
keep reading until you

915
00:32:54,640 --> 00:33:01,039
find the kernel header and that's it

916
00:32:57,919 --> 00:33:03,679
so ventex ios 12

917
00:33:01,039 --> 00:33:04,320
added the ref mitigations so always ref

918
00:33:03,679 --> 00:33:07,679
count t

919
00:33:04,320 --> 00:33:11,760
a load range is from one to uh

920
00:33:07,679 --> 00:33:15,440
o x 0 f ffff so we have seven um

921
00:33:11,760 --> 00:33:15,679
seven f's not eight uh if the ref count

922
00:33:15,440 --> 00:33:19,120
is

923
00:33:15,679 --> 00:33:22,559
outside of this range um it just panics

924
00:33:19,120 --> 00:33:23,439
so if we overlap with the upper part of

925
00:33:22,559 --> 00:33:27,039
the pointer

926
00:33:23,440 --> 00:33:30,080
it will always panic and in the lower

927
00:33:27,039 --> 00:33:32,399
half of the pointer it will uh

928
00:33:30,080 --> 00:33:34,399
panic in some cases and if we do lots of

929
00:33:32,399 --> 00:33:34,879
allocations and the virtual address

930
00:33:34,399 --> 00:33:37,120
grows

931
00:33:34,880 --> 00:33:39,600
then it's very likely that panics and

932
00:33:37,120 --> 00:33:41,360
since we do have a lot of allocations

933
00:33:39,600 --> 00:33:43,600
we just assume that like we can't do

934
00:33:41,360 --> 00:33:45,678
here also there's another reason why you

935
00:33:43,600 --> 00:33:46,399
want to move away from this overlapping

936
00:33:45,679 --> 00:33:48,960
technique

937
00:33:46,399 --> 00:33:50,959
because if like apple changes or struck

938
00:33:48,960 --> 00:33:52,720
to introduce a new field or something

939
00:33:50,960 --> 00:33:57,039
and all of that falls apart

940
00:33:52,720 --> 00:34:00,399
so it's like really uh really hacky

941
00:33:57,039 --> 00:34:03,600
so uh bassett used a different approach

942
00:34:00,399 --> 00:34:05,678
with his exploit so he used pipes

943
00:34:03,600 --> 00:34:08,000
so after he released his exploit i was

944
00:34:05,679 --> 00:34:10,399
like hey pipes are really cool

945
00:34:08,000 --> 00:34:11,520
so i was like all right let's use pipes

946
00:34:10,399 --> 00:34:14,000
we want to um

947
00:34:11,520 --> 00:34:16,320
move from vintex to ventex which is just

948
00:34:14,000 --> 00:34:17,280
the same exploit by fios 12 for that

949
00:34:16,320 --> 00:34:18,879
thing changed

950
00:34:17,280 --> 00:34:21,359
we're gonna put the fake port and the

951
00:34:18,879 --> 00:34:24,719
fake task and a pipe buffer instead of

952
00:34:21,359 --> 00:34:26,960
os data that allows us to safely read

953
00:34:24,719 --> 00:34:28,719
and write that buffer without having to

954
00:34:26,960 --> 00:34:31,199
worry of reallocating it

955
00:34:28,719 --> 00:34:32,839
we don't need the port set context hack

956
00:34:31,199 --> 00:34:34,638
anymore because reads and writes are

957
00:34:32,839 --> 00:34:36,719
safe

958
00:34:34,639 --> 00:34:38,480
so how does it actually work posix

959
00:34:36,719 --> 00:34:39,359
programs as you know use file

960
00:34:38,480 --> 00:34:42,399
descriptors

961
00:34:39,359 --> 00:34:45,520
default ones as cdn sd out scdr

962
00:34:42,399 --> 00:34:47,520
pipes give you an input and an

963
00:34:45,520 --> 00:34:50,079
output descriptor for reading and

964
00:34:47,520 --> 00:34:51,759
writing so you write into the writing

965
00:34:50,079 --> 00:34:53,520
and and you can read from the reading

966
00:34:51,760 --> 00:34:55,919
end and then you have

967
00:34:53,520 --> 00:34:57,359
two types of pipes you have the blocking

968
00:34:55,918 --> 00:35:00,799
pipe like the default one

969
00:34:57,359 --> 00:35:02,799
uh you the right call stalls until

970
00:35:00,800 --> 00:35:04,240
you read the data and you have the

971
00:35:02,800 --> 00:35:06,880
non-blocking pipes so

972
00:35:04,240 --> 00:35:08,399
the right finishes and it stores the

973
00:35:06,880 --> 00:35:12,000
data in the pipe

974
00:35:08,400 --> 00:35:15,680
and then you can later read it back

975
00:35:12,000 --> 00:35:18,880
locking read it just go through

976
00:35:15,680 --> 00:35:21,919
non-blocking you're right it's in there

977
00:35:18,880 --> 00:35:23,839
if you write more data then you idle

978
00:35:21,920 --> 00:35:25,599
it's still there and then you can read

979
00:35:23,839 --> 00:35:28,240
it

980
00:35:25,599 --> 00:35:29,599
so non-blocking pipe allocates a buffer

981
00:35:28,240 --> 00:35:30,560
in the kernel which is big enough to

982
00:35:29,599 --> 00:35:33,040
hold the data

983
00:35:30,560 --> 00:35:34,000
this allows to make a controlled size

984
00:35:33,040 --> 00:35:36,000
allocation

985
00:35:34,000 --> 00:35:38,560
by writing data in the buffer like if

986
00:35:36,000 --> 00:35:41,680
you write little data a small location

987
00:35:38,560 --> 00:35:43,520
more data a bigger location reading data

988
00:35:41,680 --> 00:35:45,200
just read it back from the pipe and how

989
00:35:43,520 --> 00:35:46,880
do you modify it well you read it first

990
00:35:45,200 --> 00:35:48,640
then you write it back in and it will

991
00:35:46,880 --> 00:35:51,760
stay in the same slot as long as you

992
00:35:48,640 --> 00:35:51,759
don't change the size

993
00:35:51,839 --> 00:35:58,640
so back to step 11 of wintex we have

994
00:35:55,440 --> 00:36:00,400
a heap pointer to a real port now

995
00:35:58,640 --> 00:36:02,480
this is also until here it's the same

996
00:36:00,400 --> 00:36:06,160
step for ventex

997
00:36:02,480 --> 00:36:09,599
now we increase uh the

998
00:36:06,160 --> 00:36:11,759
pointer by enough pages align it and now

999
00:36:09,599 --> 00:36:12,560
the difference is that we spray pipe

1000
00:36:11,760 --> 00:36:15,119
buffers

1001
00:36:12,560 --> 00:36:16,960
with fake ports so you can see the red

1002
00:36:15,119 --> 00:36:20,240
thing there is the fake port

1003
00:36:16,960 --> 00:36:24,880
and the fake port points to a fake task

1004
00:36:20,240 --> 00:36:24,879
which resides into the same pipe buffer

1005
00:36:25,359 --> 00:36:29,598
so k read now read the buffer data from

1006
00:36:28,560 --> 00:36:32,320
the pipe

1007
00:36:29,599 --> 00:36:34,800
modify that pointer write it back into

1008
00:36:32,320 --> 00:36:36,240
the pipe and use pit for task so this is

1009
00:36:34,800 --> 00:36:39,280
a pretty solid

1010
00:36:36,240 --> 00:36:41,919
way of kernel read

1011
00:36:39,280 --> 00:36:42,400
what next well we have controlled fake

1012
00:36:41,920 --> 00:36:45,440
port

1013
00:36:42,400 --> 00:36:47,760
we have a carried primitive um

1014
00:36:45,440 --> 00:36:49,359
and we have the kslr slide as i already

1015
00:36:47,760 --> 00:36:51,680
showed you before how to get it what we

1016
00:36:49,359 --> 00:36:53,200
want is a proper kernel task

1017
00:36:51,680 --> 00:36:56,078
and what we're going to do is we're

1018
00:36:53,200 --> 00:36:59,118
going to continue vortex style

1019
00:36:56,079 --> 00:37:01,839
we're going to read the kernel

1020
00:36:59,119 --> 00:37:03,440
zone map address so it's in the data

1021
00:37:01,839 --> 00:37:05,119
segment once you know the slides you

1022
00:37:03,440 --> 00:37:06,160
just read a data segment and you get a

1023
00:37:05,119 --> 00:37:09,839
pointer

1024
00:37:06,160 --> 00:37:11,598
you update the fake tasks zone map

1025
00:37:09,839 --> 00:37:13,200
um we didn't need to do this before

1026
00:37:11,599 --> 00:37:15,839
because before we really only cared

1027
00:37:13,200 --> 00:37:17,598
about like two fields like ref count and

1028
00:37:15,839 --> 00:37:19,839
uh the point we want to read from but

1029
00:37:17,599 --> 00:37:23,040
now you put in like a map so that thing

1030
00:37:19,839 --> 00:37:26,240
actually belongs to map so then

1031
00:37:23,040 --> 00:37:30,240
we can use that fake port fake task

1032
00:37:26,240 --> 00:37:31,118
to remap that memory we're using to user

1033
00:37:30,240 --> 00:37:34,000
space there's

1034
00:37:31,119 --> 00:37:35,839
a mock vm remap and now we like shared

1035
00:37:34,000 --> 00:37:37,040
mapping between kernel space and user

1036
00:37:35,839 --> 00:37:39,520
space

1037
00:37:37,040 --> 00:37:41,279
that's not support for ventex since our

1038
00:37:39,520 --> 00:37:42,880
reading and writing primitive inside

1039
00:37:41,280 --> 00:37:45,440
that buffer is already

1040
00:37:42,880 --> 00:37:46,400
safe but like it's important for vintex

1041
00:37:45,440 --> 00:37:49,520
because for wintex

1042
00:37:46,400 --> 00:37:51,440
every time we would need to do uh

1043
00:37:49,520 --> 00:37:54,000
like it was slow we had to do like this

1044
00:37:51,440 --> 00:37:54,640
hacky thing and so vortex did it like

1045
00:37:54,000 --> 00:37:56,160
that way

1046
00:37:54,640 --> 00:37:58,400
just remap it and then you can just

1047
00:37:56,160 --> 00:38:00,960
write to it

1048
00:37:58,400 --> 00:38:01,520
so next we're gonna dump the v table uh

1049
00:38:00,960 --> 00:38:05,040
the

1050
00:38:01,520 --> 00:38:06,640
full v table of i o root i o surface

1051
00:38:05,040 --> 00:38:10,240
root user client

1052
00:38:06,640 --> 00:38:12,480
in our fake port we change the type to

1053
00:38:10,240 --> 00:38:15,598
iokit object so it was a fake

1054
00:38:12,480 --> 00:38:16,400
task before and now it's a fake iokit

1055
00:38:15,599 --> 00:38:19,599
object

1056
00:38:16,400 --> 00:38:22,480
so why do we do that well um the port

1057
00:38:19,599 --> 00:38:23,839
has a pointer like object so we set the

1058
00:38:22,480 --> 00:38:27,040
object pointer to

1059
00:38:23,839 --> 00:38:30,078
uh point to our fake c plus

1060
00:38:27,040 --> 00:38:33,119
object and that fake c plus plus object

1061
00:38:30,079 --> 00:38:36,400
points into our fake v table

1062
00:38:33,119 --> 00:38:37,839
so in that fake me table we modified one

1063
00:38:36,400 --> 00:38:41,359
pointer to create

1064
00:38:37,839 --> 00:38:43,759
a kernel called primitive so

1065
00:38:41,359 --> 00:38:44,640
by using the i o connect trap six

1066
00:38:43,760 --> 00:38:47,280
function

1067
00:38:44,640 --> 00:38:49,040
we can jump to what like we put into the

1068
00:38:47,280 --> 00:38:49,839
pointer and we control arguments like

1069
00:38:49,040 --> 00:38:52,000
with some

1070
00:38:49,839 --> 00:38:54,640
some hex we can like do a kernel call

1071
00:38:52,000 --> 00:38:56,960
primitive from this

1072
00:38:54,640 --> 00:38:58,319
um and yeah we just continue from here

1073
00:38:56,960 --> 00:38:59,680
vortex cell there's a really good

1074
00:38:58,320 --> 00:39:01,599
write-up on vortex

1075
00:38:59,680 --> 00:39:03,440
so you should read it if you haven't

1076
00:39:01,599 --> 00:39:05,520
basically what we're going to do is we

1077
00:39:03,440 --> 00:39:08,160
replace the process credentials

1078
00:39:05,520 --> 00:39:08,800
with the kernel credentials that will

1079
00:39:08,160 --> 00:39:12,640
allow us

1080
00:39:08,800 --> 00:39:14,320
to call set uid0 set your id 0 like

1081
00:39:12,640 --> 00:39:15,920
calling it that way has the advantage

1082
00:39:14,320 --> 00:39:19,359
that it also updates

1083
00:39:15,920 --> 00:39:22,240
mock tasks like internal mock stuff

1084
00:39:19,359 --> 00:39:24,560
and this allows us to get the privileged

1085
00:39:22,240 --> 00:39:26,799
mock host port

1086
00:39:24,560 --> 00:39:29,200
why do we need that basically for easier

1087
00:39:26,800 --> 00:39:31,920
retrieval of the kernel port later

1088
00:39:29,200 --> 00:39:33,359
basically we find the kernel task like

1089
00:39:31,920 --> 00:39:34,480
the real one

1090
00:39:33,359 --> 00:39:37,359
in the kernel because we have the

1091
00:39:34,480 --> 00:39:38,079
current read we remap the kernel task to

1092
00:39:37,359 --> 00:39:39,839
different

1093
00:39:38,079 --> 00:39:42,960
virtual address within the kernel this

1094
00:39:39,839 --> 00:39:45,440
is done to bypass some mitigation

1095
00:39:42,960 --> 00:39:46,000
where they block certain apis from being

1096
00:39:45,440 --> 00:39:47,680
used

1097
00:39:46,000 --> 00:39:49,359
with the kernel task port but like

1098
00:39:47,680 --> 00:39:51,440
remapping it is a different pointer

1099
00:39:49,359 --> 00:39:54,480
pointer compare doesn't work anymore

1100
00:39:51,440 --> 00:39:56,640
and we're good to use those

1101
00:39:54,480 --> 00:39:58,400
so we have like this remapped kernel

1102
00:39:56,640 --> 00:40:01,118
task and then we

1103
00:39:58,400 --> 00:40:01,839
store the cloned kernel task a pointer

1104
00:40:01,119 --> 00:40:05,440
into

1105
00:40:01,839 --> 00:40:08,480
uh an array hosts special ports so now

1106
00:40:05,440 --> 00:40:10,319
every root process uh i think you do

1107
00:40:08,480 --> 00:40:11,359
need an entitlement get tasked low

1108
00:40:10,319 --> 00:40:13,119
entitlement

1109
00:40:11,359 --> 00:40:15,440
if you root and have that entitlement

1110
00:40:13,119 --> 00:40:17,839
you can call host special ports

1111
00:40:15,440 --> 00:40:18,800
index four and it will give you back a

1112
00:40:17,839 --> 00:40:22,078
kernel port

1113
00:40:18,800 --> 00:40:24,079
a centroid to kernel port um after this

1114
00:40:22,079 --> 00:40:25,200
we we like pretty much done just clean

1115
00:40:24,079 --> 00:40:28,720
up the exploit

1116
00:40:25,200 --> 00:40:31,919
and we achieved our total goal so

1117
00:40:28,720 --> 00:40:34,959
to conclude this uh we introduced you to

1118
00:40:31,920 --> 00:40:37,200
xnew heap zones a bit of zealock and

1119
00:40:34,960 --> 00:40:39,520
kellogg talked about heap exploitation

1120
00:40:37,200 --> 00:40:42,160
techniques and strategies

1121
00:40:39,520 --> 00:40:43,920
introduced you to mark ports and

1122
00:40:42,160 --> 00:40:45,359
outlined its importance for kernel

1123
00:40:43,920 --> 00:40:48,720
exploitation if you want to go

1124
00:40:45,359 --> 00:40:51,440
into ios or x a new exploitations

1125
00:40:48,720 --> 00:40:52,000
markport is the way to go there's a

1126
00:40:51,440 --> 00:40:54,720
quote by

1127
00:40:52,000 --> 00:40:55,599
a friend was like every time apple

1128
00:40:54,720 --> 00:40:58,720
introduces

1129
00:40:55,599 --> 00:41:00,319
a new mitigation there is a mock api to

1130
00:40:58,720 --> 00:41:02,240
bypass it most likely

1131
00:41:00,319 --> 00:41:03,599
so keep that in mind if you're looking

1132
00:41:02,240 --> 00:41:05,598
at new stuff

1133
00:41:03,599 --> 00:41:07,599
um yeah we had a full walkthrough of

1134
00:41:05,599 --> 00:41:10,880
three kernel exploits for two

1135
00:41:07,599 --> 00:41:14,160
kernel heap bucks on pro tip always

1136
00:41:10,880 --> 00:41:16,880
turn your um primitive

1137
00:41:14,160 --> 00:41:18,839
into use after free and type confusion

1138
00:41:16,880 --> 00:41:20,960
if you can i know like with the newer

1139
00:41:18,839 --> 00:41:23,119
processes

1140
00:41:20,960 --> 00:41:25,599
with park point authentication codes it

1141
00:41:23,119 --> 00:41:29,520
might not be possible but surprisingly

1142
00:41:25,599 --> 00:41:32,319
the uh out of bounds timestamp exploit

1143
00:41:29,520 --> 00:41:34,079
it replaces a pointer and that works on

1144
00:41:32,319 --> 00:41:36,800
park devices so

1145
00:41:34,079 --> 00:41:38,160
just use use after three type confusion

1146
00:41:36,800 --> 00:41:41,920
replace pointerable

1147
00:41:38,160 --> 00:41:44,560
fake fake mockport and you're good to go

1148
00:41:41,920 --> 00:41:46,960
for better understanding you can re-read

1149
00:41:44,560 --> 00:41:50,400
treadmill vintax and ventex

1150
00:41:46,960 --> 00:41:52,960
and yeah slides will be available

1151
00:41:50,400 --> 00:41:54,160
um i'll tweet a link and probably knock

1152
00:41:52,960 --> 00:41:56,400
on will tweet

1153
00:41:54,160 --> 00:41:59,598
something and now we have time for

1154
00:41:56,400 --> 00:41:59,599
questions thank you very much for

1155
00:42:00,839 --> 00:42:03,839
listening

1156
00:42:06,800 --> 00:42:10,079
so are there any questions

1157
00:42:11,090 --> 00:42:15,760
[Music]

1158
00:42:12,960 --> 00:42:17,359
probably a lot of information variation

1159
00:42:15,760 --> 00:42:20,079
time so need to

1160
00:42:17,359 --> 00:42:21,119
think through yeah you can talk to me

1161
00:42:20,079 --> 00:42:30,400
also later i'm

1162
00:42:21,119 --> 00:42:33,599
i'm available today so just catch up

1163
00:42:30,400 --> 00:42:35,280
quick one uh do these techniques work on

1164
00:42:33,599 --> 00:42:37,920
mac os as well because you are

1165
00:42:35,280 --> 00:42:38,640
trying to get tasks for pid on mac os as

1166
00:42:37,920 --> 00:42:41,760
well and with

1167
00:42:38,640 --> 00:42:42,480
sip uh you're kind of denied that how

1168
00:42:41,760 --> 00:42:43,599
would

1169
00:42:42,480 --> 00:42:46,240
do you have any techniques that could

1170
00:42:43,599 --> 00:42:48,160
like bypass so

1171
00:42:46,240 --> 00:42:49,439
the the thing presented here it also

1172
00:42:48,160 --> 00:42:51,200
works

1173
00:42:49,440 --> 00:42:53,839
because yeah like you use the low level

1174
00:42:51,200 --> 00:42:56,078
api um

1175
00:42:53,839 --> 00:42:57,200
the goal is to get a send right to a

1176
00:42:56,079 --> 00:42:59,359
taskboard right

1177
00:42:57,200 --> 00:43:00,720
yes send right to the kernel task port

1178
00:42:59,359 --> 00:43:03,598
and using this remap

1179
00:43:00,720 --> 00:43:04,560
trick it's actually so the kernel

1180
00:43:03,599 --> 00:43:07,760
there's a check

1181
00:43:04,560 --> 00:43:09,520
there's uh apis for it like reading and

1182
00:43:07,760 --> 00:43:11,200
writing kernel memory and they check we

1183
00:43:09,520 --> 00:43:12,640
don't allow that for the kernel task

1184
00:43:11,200 --> 00:43:14,399
port but if you remap it

1185
00:43:12,640 --> 00:43:16,078
you bypass that check and then it still

1186
00:43:14,400 --> 00:43:19,680
works it works on

1187
00:43:16,079 --> 00:43:21,920
mac on ios these exploits uh vortex have

1188
00:43:19,680 --> 00:43:25,680
been ported also to the apple watch

1189
00:43:21,920 --> 00:43:27,520
and ventex the updated was not by me but

1190
00:43:25,680 --> 00:43:29,680
by someone else also ported to the apple

1191
00:43:27,520 --> 00:43:31,280
watch so basically yeah extending that's

1192
00:43:29,680 --> 00:43:33,680
why the talk is actually new not just

1193
00:43:31,280 --> 00:43:33,680
ios

1194
00:43:35,599 --> 00:43:39,200
i think there was another question

1195
00:43:37,040 --> 00:43:40,480
somewhere here

1196
00:43:39,200 --> 00:43:43,669
okay

1197
00:43:40,480 --> 00:43:43,670
[Music]

1198
00:43:44,880 --> 00:43:53,760
okay thank you sir thank you

