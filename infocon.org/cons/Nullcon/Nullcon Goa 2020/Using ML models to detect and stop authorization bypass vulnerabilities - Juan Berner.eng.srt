1
00:00:04,120 --> 00:00:09,469
hi so welcome everyone my name is Adisa

2
00:00:07,819 --> 00:00:11,090
stocky stretch against the reviewers

3
00:00:09,469 --> 00:00:12,559
using machine learning models to detect

4
00:00:11,090 --> 00:00:23,810
and stop authorization by possible

5
00:00:12,559 --> 00:00:27,019
narratives yes this is me I'm on burner

6
00:00:23,810 --> 00:00:29,990
there's my Twitter and my blog post I'm

7
00:00:27,019 --> 00:00:31,880
a CVT lead developer looking at calm and

8
00:00:29,990 --> 00:00:33,580
also working as a team lead managing one

9
00:00:31,880 --> 00:00:35,839
of the application security teams I

10
00:00:33,580 --> 00:00:38,239
usually work with application or

11
00:00:35,840 --> 00:00:39,890
infrastructure projects and part where

12
00:00:38,240 --> 00:00:43,610
these are research done on the

13
00:00:39,890 --> 00:00:45,560
application space so this is a bit of

14
00:00:43,610 --> 00:00:47,750
the overview of the talk I will be

15
00:00:45,560 --> 00:00:49,670
talking a little Outworld I do ours and

16
00:00:47,750 --> 00:00:52,010
our authorization bypass communities

17
00:00:49,670 --> 00:00:54,580
then how we can prevent them and also

18
00:00:52,010 --> 00:00:57,470
why prevention is not enough also

19
00:00:54,580 --> 00:00:59,239
afterwards about how can we detect these

20
00:00:57,470 --> 00:01:04,158
attacks and block against them and

21
00:00:59,240 --> 00:01:06,800
finally if we have enough time a demo so

22
00:01:04,159 --> 00:01:08,240
yes I do are so it stands for insecure

23
00:01:06,800 --> 00:01:11,450
direct object reference

24
00:01:08,240 --> 00:01:13,280
it's very commonplace for MIT and it's

25
00:01:11,450 --> 00:01:15,500
incredibly risky in particular because

26
00:01:13,280 --> 00:01:17,420
of the lack of technical skill need to

27
00:01:15,500 --> 00:01:19,400
exploit it there are some cases where

28
00:01:17,420 --> 00:01:21,680
you might want to do things like a blind

29
00:01:19,400 --> 00:01:23,840
IDR which is more technically difficult

30
00:01:21,680 --> 00:01:25,610
but in many cases were checking out

31
00:01:23,840 --> 00:01:27,290
something like in this image where you

32
00:01:25,610 --> 00:01:29,990
might have somebody requesting a

33
00:01:27,290 --> 00:01:33,340
resource for user 1,000 and then people

34
00:01:29,990 --> 00:01:38,949
can they can go and go to access other

35
00:01:33,340 --> 00:01:42,230
users resources like 1,001 1,002 and

36
00:01:38,950 --> 00:01:44,840
this is also very much alive in unity so

37
00:01:42,230 --> 00:01:46,460
this is actively exploitive in the wild

38
00:01:44,840 --> 00:01:48,320
there's a lot of bounties for these

39
00:01:46,460 --> 00:01:50,539
minorities this is not going to be so

40
00:01:48,320 --> 00:01:53,449
much out how to find them as an attacker

41
00:01:50,540 --> 00:01:58,729
but how to actually defend against them

42
00:01:53,450 --> 00:02:00,560
from the defense perspective now just to

43
00:01:58,729 --> 00:02:02,810
cover there are other types of bypass

44
00:02:00,560 --> 00:02:04,940
communities that this type of detection

45
00:02:02,810 --> 00:02:08,239
I'm going to talk about protection a

46
00:02:04,940 --> 00:02:09,940
also covers so while I do art can be

47
00:02:08,239 --> 00:02:12,590
consumed some kind of horizontal

48
00:02:09,940 --> 00:02:14,579
authorization bypass because you're

49
00:02:12,590 --> 00:02:16,170
accessing somebody else's resources it

50
00:02:14,580 --> 00:02:20,010
be also a case that you might have an

51
00:02:16,170 --> 00:02:21,480
authority on bypass taxes higher level

52
00:02:20,010 --> 00:02:23,760
our physician resource like an

53
00:02:21,480 --> 00:02:26,670
administrator account or cases that

54
00:02:23,760 --> 00:02:29,190
you're just avoiding controls so for

55
00:02:26,670 --> 00:02:30,959
example if you are able to add on end

56
00:02:29,190 --> 00:02:33,390
points which are not supposed to happen

57
00:02:30,960 --> 00:02:37,020
before some kind of check like being

58
00:02:33,390 --> 00:02:38,790
able to add a phone number for an SMS

59
00:02:37,020 --> 00:02:40,470
before you actually pass to a failure

60
00:02:38,790 --> 00:02:43,049
allowing you to just add a phone number

61
00:02:40,470 --> 00:02:47,400
and then pass to a PHA making two FA

62
00:02:43,050 --> 00:02:48,870
redundant now when I started looking to

63
00:02:47,400 --> 00:02:50,430
this I start trying to map all the

64
00:02:48,870 --> 00:02:52,740
different ways that this kind of

65
00:02:50,430 --> 00:02:54,900
narratives could be added so in some

66
00:02:52,740 --> 00:02:57,180
cases you might have an endpoint which

67
00:02:54,900 --> 00:02:58,860
has an authorization check but then the

68
00:02:57,180 --> 00:03:02,550
endpoint might fail or somebody might

69
00:02:58,860 --> 00:03:05,070
skip that check so going there just it's

70
00:03:02,550 --> 00:03:07,140
the red part are like attacks and the

71
00:03:05,070 --> 00:03:09,359
blue part are detections and the darker

72
00:03:07,140 --> 00:03:10,470
blue are conditions the point here is

73
00:03:09,360 --> 00:03:13,470
that there are a lot of different ways

74
00:03:10,470 --> 00:03:15,359
you can add these majorities but there

75
00:03:13,470 --> 00:03:18,840
are overlaps on how you can detect them

76
00:03:15,360 --> 00:03:20,280
and prevent against them so go into

77
00:03:18,840 --> 00:03:22,560
detail on some of them because there are

78
00:03:20,280 --> 00:03:24,480
plenty but for example it might be a

79
00:03:22,560 --> 00:03:27,180
situation where a condition is ignoring

80
00:03:24,480 --> 00:03:29,130
a check so in this particular code we

81
00:03:27,180 --> 00:03:31,680
had some check off is the user logged in

82
00:03:29,130 --> 00:03:34,680
this is Ingo and then there's an error

83
00:03:31,680 --> 00:03:36,239
check of okay Candace user access the

84
00:03:34,680 --> 00:03:38,519
resources of the user who they're

85
00:03:36,239 --> 00:03:40,250
requesting now there might be condition

86
00:03:38,519 --> 00:03:43,769
that allows you to ignore the

87
00:03:40,250 --> 00:03:45,989
authorization check and in that case you

88
00:03:43,769 --> 00:03:48,930
are actually executing the same check

89
00:03:45,989 --> 00:03:50,459
but you might ignore the result this

90
00:03:48,930 --> 00:03:51,840
might happen if somebody changes the

91
00:03:50,459 --> 00:03:53,850
boolean logic for the authorization

92
00:03:51,840 --> 00:03:55,680
check and there you have like the

93
00:03:53,850 --> 00:03:58,320
decision tree of how this can happen

94
00:03:55,680 --> 00:04:00,780
because there are some check in the

95
00:03:58,320 --> 00:04:03,329
endpoint and it happens but it does not

96
00:04:00,780 --> 00:04:07,290
succeed but yet you're still giving back

97
00:04:03,330 --> 00:04:10,620
the resource a different situation is

98
00:04:07,290 --> 00:04:12,900
when you might skip the check altogether

99
00:04:10,620 --> 00:04:14,880
so for example there might be condition

100
00:04:12,900 --> 00:04:17,640
that allows you to skip fun enough we

101
00:04:14,880 --> 00:04:20,159
just had a talk previously where one of

102
00:04:17,640 --> 00:04:23,370
the minorities was exactly this there

103
00:04:20,160 --> 00:04:25,830
was a situation where there was a check

104
00:04:23,370 --> 00:04:26,980
for the path and if the path matches a

105
00:04:25,830 --> 00:04:29,409
particular RA

106
00:04:26,980 --> 00:04:31,630
particular string then you might

107
00:04:29,410 --> 00:04:33,360
actually ignore a check to see if

108
00:04:31,630 --> 00:04:37,150
somebody can access a resource or not

109
00:04:33,360 --> 00:04:39,880
and here comes a bit of the part of the

110
00:04:37,150 --> 00:04:41,620
rage here to IVRS because it's very hard

111
00:04:39,880 --> 00:04:43,420
to attack them and this is one of the

112
00:04:41,620 --> 00:04:46,030
particular case for this when there

113
00:04:43,420 --> 00:04:48,010
might not be a check at all so somebody

114
00:04:46,030 --> 00:04:49,840
creates an endpoint that gives you back

115
00:04:48,010 --> 00:04:51,610
credit card information in this case

116
00:04:49,840 --> 00:04:53,890
information it's only for friends and

117
00:04:51,610 --> 00:04:55,780
they just forget to add a party word

118
00:04:53,890 --> 00:04:57,490
check for this and in this situation

119
00:04:55,780 --> 00:04:59,890
even doing code review you will not

120
00:04:57,490 --> 00:05:03,880
realize if this is actually something

121
00:04:59,890 --> 00:05:05,830
that should have a check or not so I

122
00:05:03,880 --> 00:05:07,300
have to hear that what we are doing we

123
00:05:05,830 --> 00:05:09,190
have to assume bypass communities and in

124
00:05:07,300 --> 00:05:11,620
particular ideas where you references a

125
00:05:09,190 --> 00:05:13,420
particular object and that's where the

126
00:05:11,620 --> 00:05:15,880
direct object reference part comes in

127
00:05:13,420 --> 00:05:18,550
but can we prevent against them we can

128
00:05:15,880 --> 00:05:20,980
do some stuff to prevent it at least at

129
00:05:18,550 --> 00:05:22,930
that layer like for example enforcing

130
00:05:20,980 --> 00:05:24,940
random identifiers so you can adjust

131
00:05:22,930 --> 00:05:26,650
guess the user ID in the previous

132
00:05:24,940 --> 00:05:30,250
example will be very hard if it was like

133
00:05:26,650 --> 00:05:32,890
a 30 character string each different

134
00:05:30,250 --> 00:05:35,320
user then you can do access control

135
00:05:32,890 --> 00:05:39,099
through the models you static

136
00:05:35,320 --> 00:05:41,200
application security testing but usually

137
00:05:39,100 --> 00:05:44,440
the issue is good is it enough and

138
00:05:41,200 --> 00:05:48,219
that's where detection usually comes in

139
00:05:44,440 --> 00:05:50,260
as another layer of defense in depth but

140
00:05:48,220 --> 00:05:52,450
the current ways that we have to detect

141
00:05:50,260 --> 00:05:55,180
these kind of attacks are very limited

142
00:05:52,450 --> 00:05:58,030
from the detection space so you might

143
00:05:55,180 --> 00:05:59,590
have the enumeration where you realize

144
00:05:58,030 --> 00:06:01,989
some is going through different users

145
00:05:59,590 --> 00:06:03,489
and you might add rate limiting which is

146
00:06:01,990 --> 00:06:06,040
basically I will be checked after a

147
00:06:03,490 --> 00:06:07,930
threshold and then block the attack then

148
00:06:06,040 --> 00:06:10,300
you might have hard-coded rules for this

149
00:06:07,930 --> 00:06:12,100
but usually the big difference here is

150
00:06:10,300 --> 00:06:14,680
that you're looking at attempts and not

151
00:06:12,100 --> 00:06:16,390
actual success of exploitation which can

152
00:06:14,680 --> 00:06:18,370
lead to teams getting a lot of alert

153
00:06:16,390 --> 00:06:20,890
they don't know what's going on they

154
00:06:18,370 --> 00:06:23,740
don't know how to act upon them and they

155
00:06:20,890 --> 00:06:26,229
can't really realize somebody has stolen

156
00:06:23,740 --> 00:06:29,950
data or not and that usually leads to

157
00:06:26,230 --> 00:06:32,440
alert fatigue from teams now how I got

158
00:06:29,950 --> 00:06:35,620
into this was basically around this kind

159
00:06:32,440 --> 00:06:37,540
of stopping the process of wacom all

160
00:06:35,620 --> 00:06:40,300
because after working on implementing

161
00:06:37,540 --> 00:06:40,630
our woth the big issue was this kind of

162
00:06:40,300 --> 00:06:42,040
attack

163
00:06:40,630 --> 00:06:44,080
and there was a team which was

164
00:06:42,040 --> 00:06:46,300
implementing this kind of assertion

165
00:06:44,080 --> 00:06:47,680
checks out of an so every time they

166
00:06:46,300 --> 00:06:50,380
would find some kind of all foreign

167
00:06:47,680 --> 00:06:53,500
check they would recreate that out of an

168
00:06:50,380 --> 00:06:56,350
and that was very slow process involved

169
00:06:53,500 --> 00:06:58,030
a lot of code reviews case-by-case basis

170
00:06:56,350 --> 00:06:59,920
and it was evident it would not scale

171
00:06:58,030 --> 00:07:01,900
because we had humans looking at code

172
00:06:59,920 --> 00:07:04,830
and trying to understand what was the 13

173
00:07:01,900 --> 00:07:07,479
check nil and implementing it afterwards

174
00:07:04,830 --> 00:07:09,190
so the idea was okay how can I we

175
00:07:07,480 --> 00:07:12,730
actually detect this in a scalable way

176
00:07:09,190 --> 00:07:14,680
so I start looking at at this problem at

177
00:07:12,730 --> 00:07:17,440
its core so it's a classification

178
00:07:14,680 --> 00:07:19,750
problem so we need to classify thirteen

179
00:07:17,440 --> 00:07:21,550
checks are needed or not or what's the

180
00:07:19,750 --> 00:07:23,590
result to run them the application

181
00:07:21,550 --> 00:07:26,410
currently uses the context to be able to

182
00:07:23,590 --> 00:07:28,719
classify it and this assertion flows

183
00:07:26,410 --> 00:07:30,970
constantly change so if even if you do

184
00:07:28,720 --> 00:07:32,740
it hard-coded a one by one you will

185
00:07:30,970 --> 00:07:37,630
never adapt to how quickly an

186
00:07:32,740 --> 00:07:39,160
application can change so here it's the

187
00:07:37,630 --> 00:07:41,590
question of how can we improve from this

188
00:07:39,160 --> 00:07:42,910
current situation so for one we can

189
00:07:41,590 --> 00:07:45,520
really understand the request flow

190
00:07:42,910 --> 00:07:47,440
what's going on on each request we can

191
00:07:45,520 --> 00:07:49,240
try to go from the possibility of

192
00:07:47,440 --> 00:07:52,030
exploitation that most current detection

193
00:07:49,240 --> 00:07:54,280
tools do to actual exploitation attempts

194
00:07:52,030 --> 00:07:56,260
so we actually know and we alert someone

195
00:07:54,280 --> 00:07:59,169
when we have a bonny ability being

196
00:07:56,260 --> 00:08:01,270
exploited and in this way we could try

197
00:07:59,170 --> 00:08:03,190
to either imitate or predict what the

198
00:08:01,270 --> 00:08:04,930
physician is doing but in a generic way

199
00:08:03,190 --> 00:08:06,219
so you don't need too hard call it or

200
00:08:04,930 --> 00:08:11,380
change it every time the application

201
00:08:06,220 --> 00:08:13,120
changes so what you need to do is first

202
00:08:11,380 --> 00:08:15,340
of all you need to really understand the

203
00:08:13,120 --> 00:08:16,570
context of your request so when your web

204
00:08:15,340 --> 00:08:18,700
application comes and somebody's trying

205
00:08:16,570 --> 00:08:20,650
to access a resource you need to have

206
00:08:18,700 --> 00:08:23,020
information about what the request is

207
00:08:20,650 --> 00:08:25,270
doing and what's the context around that

208
00:08:23,020 --> 00:08:27,250
particular requests then you would want

209
00:08:25,270 --> 00:08:29,740
to ensure that the authorization logic

210
00:08:27,250 --> 00:08:32,110
is centralized in a way that you can

211
00:08:29,740 --> 00:08:34,810
depend on this kind of metadata being

212
00:08:32,110 --> 00:08:37,690
added and you might want to predict a

213
00:08:34,809 --> 00:08:40,270
result based on the context so to make

214
00:08:37,690 --> 00:08:42,010
it a bit more visual when reading here

215
00:08:40,270 --> 00:08:44,890
with machine learning models you would

216
00:08:42,010 --> 00:08:47,230
want to have some kind of a series of

217
00:08:44,890 --> 00:08:49,390
requests which will happen you will get

218
00:08:47,230 --> 00:08:51,250
the data from the request and then

219
00:08:49,390 --> 00:08:53,449
you'll pry this a model and you will

220
00:08:51,250 --> 00:08:55,580
train it based on the context

221
00:08:53,450 --> 00:08:57,530
the request and the authorization result

222
00:08:55,580 --> 00:09:00,380
so for a part where context of our

223
00:08:57,530 --> 00:09:03,439
request did they request fail or the a13

224
00:09:00,380 --> 00:09:05,120
result fail or succeed and afterwards on

225
00:09:03,440 --> 00:09:08,270
the prediction side you would want to be

226
00:09:05,120 --> 00:09:10,130
able to again push to the small hey this

227
00:09:08,270 --> 00:09:11,240
new request has happened there's this

228
00:09:10,130 --> 00:09:13,280
part where context

229
00:09:11,240 --> 00:09:14,750
this was the authorization result the

230
00:09:13,280 --> 00:09:17,060
mall without looking at the association

231
00:09:14,750 --> 00:09:18,890
result it's going to predict I think

232
00:09:17,060 --> 00:09:21,560
that this should have been a failed or

233
00:09:18,890 --> 00:09:23,810
successful authorization result and then

234
00:09:21,560 --> 00:09:26,390
compare if they comparison that's not

235
00:09:23,810 --> 00:09:28,939
much then you can say something is going

236
00:09:26,390 --> 00:09:31,310
wrong and the key part here is that you

237
00:09:28,940 --> 00:09:33,170
don't cure in at least in my case you

238
00:09:31,310 --> 00:09:35,479
might not care if the an authorization

239
00:09:33,170 --> 00:09:37,790
check is harder than it should but you

240
00:09:35,480 --> 00:09:39,440
really care if you predicted that there

241
00:09:37,790 --> 00:09:41,300
should have been an assertion check and

242
00:09:39,440 --> 00:09:45,050
you are not jingle forestation check

243
00:09:41,300 --> 00:09:47,599
happen so first let's start with the

244
00:09:45,050 --> 00:09:50,839
context part so at the left i have a

245
00:09:47,600 --> 00:09:54,170
typical nginx a access log and at the

246
00:09:50,840 --> 00:09:57,410
right what I have as a log of my request

247
00:09:54,170 --> 00:09:58,849
so usually I had a lot of context on the

248
00:09:57,410 --> 00:10:01,250
request so you have authorization

249
00:09:58,850 --> 00:10:03,440
results at the top some database

250
00:10:01,250 --> 00:10:05,480
activity which might be API calls if

251
00:10:03,440 --> 00:10:09,770
this was a talking with a service and

252
00:10:05,480 --> 00:10:11,780
information on the response then we have

253
00:10:09,770 --> 00:10:13,880
the authorization information here you

254
00:10:11,780 --> 00:10:16,189
might have a library a sidecar or an

255
00:10:13,880 --> 00:10:17,990
agent and you're basically ensuring that

256
00:10:16,190 --> 00:10:23,300
authorization checks happen but they

257
00:10:17,990 --> 00:10:24,920
also add data to the request key point

258
00:10:23,300 --> 00:10:26,810
here is some of the challenges of this

259
00:10:24,920 --> 00:10:28,880
first of all centralizing of our session

260
00:10:26,810 --> 00:10:30,319
checks this means that not everybody's

261
00:10:28,880 --> 00:10:32,120
implementing their own authorization

262
00:10:30,320 --> 00:10:33,830
libraries but also ensures that you are

263
00:10:32,120 --> 00:10:36,110
getting the context that you need to be

264
00:10:33,830 --> 00:10:37,580
able to predict these attacks and also

265
00:10:36,110 --> 00:10:40,760
the applications might not behave as

266
00:10:37,580 --> 00:10:43,580
expected so for example you might have a

267
00:10:40,760 --> 00:10:46,130
api's and you might say okay I can trust

268
00:10:43,580 --> 00:10:51,800
your status code as a success or failure

269
00:10:46,130 --> 00:10:53,360
but really depends on each API now on

270
00:10:51,800 --> 00:10:55,189
collecting the signals from the request

271
00:10:53,360 --> 00:10:57,080
as I showed before there's performance

272
00:10:55,190 --> 00:11:00,260
information interaction with services

273
00:10:57,080 --> 00:11:01,790
like cache databases or pies or faces

274
00:11:00,260 --> 00:11:02,970
authentication information that you

275
00:11:01,790 --> 00:11:05,670
might use

276
00:11:02,970 --> 00:11:07,380
and here I have some examples of this

277
00:11:05,670 --> 00:11:09,630
request so at the left you have a

278
00:11:07,380 --> 00:11:11,400
successful authorization and the right

279
00:11:09,630 --> 00:11:13,680
you have a fail authorization and

280
00:11:11,400 --> 00:11:15,360
there's a lot of data there which I will

281
00:11:13,680 --> 00:11:17,760
go a bit deeper but you can start using

282
00:11:15,360 --> 00:11:19,620
this data to without look without

283
00:11:17,760 --> 00:11:21,990
looking at the top part just by yourself

284
00:11:19,620 --> 00:11:23,130
you could start predicting ok this is

285
00:11:21,990 --> 00:11:26,790
what I would have expected the

286
00:11:23,130 --> 00:11:29,130
authorization result to be so these are

287
00:11:26,790 --> 00:11:31,230
a bit more clear so in this case you can

288
00:11:29,130 --> 00:11:33,240
see that for a fail of the recession

289
00:11:31,230 --> 00:11:35,670
which is a zero the number of data it

290
00:11:33,240 --> 00:11:37,950
calls is lower than for successful which

291
00:11:35,670 --> 00:11:39,870
makes sense because if it succeeds then

292
00:11:37,950 --> 00:11:41,370
we are actually getting the data back if

293
00:11:39,870 --> 00:11:46,410
it doesn't succeed we are returning the

294
00:11:41,370 --> 00:11:48,630
data now how can we use this data so one

295
00:11:46,410 --> 00:11:50,910
of the supervised learning modes that

296
00:11:48,630 --> 00:11:52,710
you can use is decision trees this

297
00:11:50,910 --> 00:11:54,630
allows you to create this kind of rules

298
00:11:52,710 --> 00:11:56,640
based on the data so that your system

299
00:11:54,630 --> 00:11:59,760
can learn from the amount of data you

300
00:11:56,640 --> 00:12:02,160
have some issues here is that you want

301
00:11:59,760 --> 00:12:04,050
to avoid overfitting and there are

302
00:12:02,160 --> 00:12:06,270
solutions to this such as random forests

303
00:12:04,050 --> 00:12:08,280
or gradient boosting machines which are

304
00:12:06,270 --> 00:12:09,810
moss which are built from decision trees

305
00:12:08,280 --> 00:12:12,800
in different ways running forests in

306
00:12:09,810 --> 00:12:15,329
parallel when boosting one by another

307
00:12:12,800 --> 00:12:18,209
sequentially but in the end they allow

308
00:12:15,330 --> 00:12:20,250
you to reduce the overfitting and give

309
00:12:18,210 --> 00:12:23,670
you a better model they adapt to new

310
00:12:20,250 --> 00:12:25,320
environments so let's say that we have

311
00:12:23,670 --> 00:12:27,930
this data and we want to be able to

312
00:12:25,320 --> 00:12:31,440
predict if there's a successful or fail

313
00:12:27,930 --> 00:12:33,329
a authentication so we would be using

314
00:12:31,440 --> 00:12:35,460
for example random forests which will

315
00:12:33,330 --> 00:12:37,590
create small trees which are we are

316
00:12:35,460 --> 00:12:39,330
going to assemble so for example one

317
00:12:37,590 --> 00:12:43,950
tree might say that if you have less

318
00:12:39,330 --> 00:12:46,530
than three operations then if that's the

319
00:12:43,950 --> 00:12:47,730
case it might mean that you actually

320
00:12:46,530 --> 00:12:50,430
failure ization

321
00:12:47,730 --> 00:12:51,960
a check or it's active and it might use

322
00:12:50,430 --> 00:12:56,280
a lot of them to make a decision

323
00:12:51,960 --> 00:12:59,339
afterwards now it's there's a limitation

324
00:12:56,280 --> 00:13:01,199
here what happens if you always request

325
00:12:59,339 --> 00:13:03,210
data before actually making a

326
00:13:01,200 --> 00:13:05,910
forestation check in that case for

327
00:13:03,210 --> 00:13:08,430
example I call it pre load you might get

328
00:13:05,910 --> 00:13:09,810
the data first which is strange but not

329
00:13:08,430 --> 00:13:11,910
unheard of I have seen in plenty of

330
00:13:09,810 --> 00:13:13,380
times and then you actually do a check

331
00:13:11,910 --> 00:13:14,969
and decide to turn it send back

332
00:13:13,380 --> 00:13:17,139
information out

333
00:13:14,970 --> 00:13:18,639
in this case what will happen is that

334
00:13:17,139 --> 00:13:20,829
the mall is not going to be much better

335
00:13:18,639 --> 00:13:23,860
than a coin flip we are going to be in a

336
00:13:20,829 --> 00:13:25,809
situation where you are basically just

337
00:13:23,860 --> 00:13:28,119
guessing because it's the same amount of

338
00:13:25,809 --> 00:13:29,709
data requested and unless you have other

339
00:13:28,119 --> 00:13:32,259
features that you can use for this

340
00:13:29,709 --> 00:13:33,910
you're not going to be very good at

341
00:13:32,259 --> 00:13:37,119
predicting if this was a failed or

342
00:13:33,910 --> 00:13:39,939
successful authorization check so that's

343
00:13:37,119 --> 00:13:42,519
where the approach I just showed doesn't

344
00:13:39,939 --> 00:13:44,740
pan out anymore but we can actually

345
00:13:42,519 --> 00:13:47,050
overcome this by adding more features to

346
00:13:44,740 --> 00:13:50,019
my our data so up to now we were using

347
00:13:47,050 --> 00:13:52,540
features which are just signals of the

348
00:13:50,019 --> 00:13:54,699
vaccine information API calls database

349
00:13:52,540 --> 00:13:56,019
checks information even the wall clock

350
00:13:54,699 --> 00:13:57,969
although it's not a great feature for

351
00:13:56,019 --> 00:13:59,800
this case but information of the request

352
00:13:57,970 --> 00:14:02,649
but what if we could use information

353
00:13:59,800 --> 00:14:05,050
from the response itself so in that case

354
00:14:02,649 --> 00:14:07,209
we might go okay I will use the content

355
00:14:05,050 --> 00:14:09,128
size so if it's a larger content it

356
00:14:07,209 --> 00:14:12,128
means I'm returning data if it's a small

357
00:14:09,129 --> 00:14:14,050
content I'm not if you do that then you

358
00:14:12,129 --> 00:14:15,910
have an issue of API system ID which

359
00:14:14,050 --> 00:14:18,189
return you the same amount of content

360
00:14:15,910 --> 00:14:19,689
you just with a failed message and when

361
00:14:18,189 --> 00:14:21,639
it's a successful message they might

362
00:14:19,689 --> 00:14:25,660
return you they they with a good

363
00:14:21,639 --> 00:14:27,249
information but like in this case there

364
00:14:25,660 --> 00:14:28,990
might be some patterns that you could

365
00:14:27,249 --> 00:14:31,480
see and that machine learning moss will

366
00:14:28,990 --> 00:14:33,819
also learn so for example when it fails

367
00:14:31,480 --> 00:14:36,249
in it's always sending a link right user

368
00:14:33,819 --> 00:14:37,748
not allowed message ID when successfully

369
00:14:36,249 --> 00:14:40,870
sending some other information like

370
00:14:37,749 --> 00:14:42,879
create your name or buy your graphic now

371
00:14:40,870 --> 00:14:45,189
there is an issue with this we might say

372
00:14:42,879 --> 00:14:47,499
okay let's just pump all the data and

373
00:14:45,189 --> 00:14:49,360
learn from this but you might not want

374
00:14:47,499 --> 00:14:51,069
to do this directly because this might

375
00:14:49,360 --> 00:14:52,629
be information of your users you might

376
00:14:51,069 --> 00:14:54,429
want to protect it in some cases might

377
00:14:52,629 --> 00:14:56,920
be even credit card information that

378
00:14:54,429 --> 00:14:58,389
you're returning in our cases it might

379
00:14:56,920 --> 00:15:00,069
be compressed so that's something you

380
00:14:58,389 --> 00:15:02,920
deal with this depending where you're

381
00:15:00,069 --> 00:15:05,290
consuming this data and it will also can

382
00:15:02,920 --> 00:15:07,120
change a lot so for example if you have

383
00:15:05,290 --> 00:15:09,160
translation services for every single

384
00:15:07,120 --> 00:15:10,990
language your content will return like

385
00:15:09,160 --> 00:15:12,730
the key names not going to be biography

386
00:15:10,990 --> 00:15:13,690
it's going to be by arif in a different

387
00:15:12,730 --> 00:15:15,580
language

388
00:15:13,690 --> 00:15:17,140
a good part with that is that as long as

389
00:15:15,580 --> 00:15:18,550
you have enough data and a good

390
00:15:17,140 --> 00:15:20,319
distribution of your users you will

391
00:15:18,550 --> 00:15:23,020
still be able to learn from these

392
00:15:20,320 --> 00:15:24,820
differences but on the content itself

393
00:15:23,020 --> 00:15:27,640
you might not want to use the content by

394
00:15:24,820 --> 00:15:30,640
itself so for let's start looking at how

395
00:15:27,640 --> 00:15:33,610
we could anonymize this content I came

396
00:15:30,640 --> 00:15:35,680
up into two more other all solutions but

397
00:15:33,610 --> 00:15:37,780
the best ones I saw one was around

398
00:15:35,680 --> 00:15:39,699
context-free or piecewise hashing which

399
00:15:37,780 --> 00:15:41,319
I will explain what it is and the other

400
00:15:39,700 --> 00:15:43,090
one is something I just called partial

401
00:15:41,320 --> 00:15:47,830
hashing but you could just consider it

402
00:15:43,090 --> 00:15:50,170
caching so first on context we were

403
00:15:47,830 --> 00:15:52,090
piecewise hashing these are very cool a

404
00:15:50,170 --> 00:15:54,880
hashing algorithm or fast hashing

405
00:15:52,090 --> 00:15:57,070
algorithm which allows you to from

406
00:15:54,880 --> 00:15:59,020
instead of just waiting normal hash

407
00:15:57,070 --> 00:16:01,150
which if you change a single bit it

408
00:15:59,020 --> 00:16:03,460
might change the whole hash if you

409
00:16:01,150 --> 00:16:06,240
change part of the whatever you're

410
00:16:03,460 --> 00:16:09,580
hashing it will only change whatever

411
00:16:06,240 --> 00:16:13,090
local part you are changing so this was

412
00:16:09,580 --> 00:16:14,950
introduced a I knew exactly when but to

413
00:16:13,090 --> 00:16:17,200
deal with malware and to be able to find

414
00:16:14,950 --> 00:16:20,200
a malware that might change part of

415
00:16:17,200 --> 00:16:22,510
itself and to be able to identify it

416
00:16:20,200 --> 00:16:24,610
through a hash in this case for example

417
00:16:22,510 --> 00:16:26,950
you can see that the first string they

418
00:16:24,610 --> 00:16:29,290
what changes is just adding smarts but

419
00:16:26,950 --> 00:16:31,090
since this is looking at context and

420
00:16:29,290 --> 00:16:34,839
finding a delimiter which is the work

421
00:16:31,090 --> 00:16:36,490
the word cut it can only change one part

422
00:16:34,840 --> 00:16:40,690
of the fashion of the whole hash and

423
00:16:36,490 --> 00:16:42,520
it's going to be useful for us so for

424
00:16:40,690 --> 00:16:45,220
example if we have a whole HTML website

425
00:16:42,520 --> 00:16:46,990
we can create these kind of hashes which

426
00:16:45,220 --> 00:16:49,090
are going to change only on the

427
00:16:46,990 --> 00:16:51,850
different part which the website or the

428
00:16:49,090 --> 00:16:54,040
HTML changes if you remove the content

429
00:16:51,850 --> 00:16:56,830
itself you might only get the structure

430
00:16:54,040 --> 00:16:58,900
of the chain HTML tags as long as this

431
00:16:56,830 --> 00:17:01,180
is not randomized you can get a pretty

432
00:16:58,900 --> 00:17:05,230
good a picture of what's going on

433
00:17:01,180 --> 00:17:06,760
without accessing the content itself so

434
00:17:05,230 --> 00:17:08,230
when I was looking to this I started

435
00:17:06,760 --> 00:17:10,089
trying to find okay how can you do these

436
00:17:08,230 --> 00:17:12,040
differences going through text

437
00:17:10,089 --> 00:17:13,990
differences but I realized this could

438
00:17:12,040 --> 00:17:16,750
also be done as an image classification

439
00:17:13,990 --> 00:17:18,130
problem if you get every single of one

440
00:17:16,750 --> 00:17:20,859
of the characters on the hash

441
00:17:18,130 --> 00:17:22,390
transforming some kind of color then you

442
00:17:20,859 --> 00:17:24,609
can start seeing some patterns in this

443
00:17:22,390 --> 00:17:26,569
case is just a failure and success one

444
00:17:24,609 --> 00:17:28,758
of the changes is of course

445
00:17:26,569 --> 00:17:31,039
response size but our our the different

446
00:17:28,759 --> 00:17:35,450
colors which are displayed and similar

447
00:17:31,039 --> 00:17:37,970
results have similar colors now I try to

448
00:17:35,450 --> 00:17:39,740
find a way to really have a very good

449
00:17:37,970 --> 00:17:41,389
prediction around this so I start with

450
00:17:39,740 --> 00:17:44,389
normal machinery models like in

451
00:17:41,389 --> 00:17:46,459
regression and SPMS then try some

452
00:17:44,389 --> 00:17:48,918
unsupervised most like clustering and

453
00:17:46,460 --> 00:17:50,450
what really showed promise was using

454
00:17:48,919 --> 00:17:52,730
something called convolutional neural

455
00:17:50,450 --> 00:17:55,190
networks which is used a lot for image

456
00:17:52,730 --> 00:17:58,130
classification but in the end it didn't

457
00:17:55,190 --> 00:18:01,039
have the accuracy I wanted I was aiming

458
00:17:58,130 --> 00:18:03,169
for no false positives or pretty much no

459
00:18:01,039 --> 00:18:05,210
false positives and this tool was quite

460
00:18:03,169 --> 00:18:07,100
hard because taking it as an image

461
00:18:05,210 --> 00:18:09,620
specification it's not exactly perfect

462
00:18:07,100 --> 00:18:11,209
but in some cases were other most and

463
00:18:09,620 --> 00:18:14,959
might not work it may be the best

464
00:18:11,210 --> 00:18:18,320
approach there so the second approach I

465
00:18:14,960 --> 00:18:21,080
went for was around the pre hush or the

466
00:18:18,320 --> 00:18:24,320
partial hush so if we get the same data

467
00:18:21,080 --> 00:18:26,029
either HTML or JSON and we start trying

468
00:18:24,320 --> 00:18:28,399
to create one with hashes of the data

469
00:18:26,029 --> 00:18:29,899
and in this case since I don't care so

470
00:18:28,399 --> 00:18:32,299
much all collisions I could even get

471
00:18:29,899 --> 00:18:33,979
partial part of that hash of course the

472
00:18:32,299 --> 00:18:36,139
hash would be salted and they thought it

473
00:18:33,980 --> 00:18:37,759
would be secret but this will allow you

474
00:18:36,139 --> 00:18:39,769
to start getting some information of the

475
00:18:37,759 --> 00:18:41,929
data even if you don't know like the

476
00:18:39,769 --> 00:18:43,820
name biography or somebody's called

477
00:18:41,929 --> 00:18:46,970
Ashley you might still be able to use

478
00:18:43,820 --> 00:18:49,370
that information for a for learning

479
00:18:46,970 --> 00:18:50,990
because they what you would will be

480
00:18:49,370 --> 00:18:53,149
looking would be patterns are there

481
00:18:50,990 --> 00:18:55,100
particular words that appear more and if

482
00:18:53,149 --> 00:18:57,139
you don't know the word just getting a

483
00:18:55,100 --> 00:19:01,129
hash which might have collisions is

484
00:18:57,139 --> 00:19:03,199
going us so in this case is a random

485
00:19:01,129 --> 00:19:05,269
forest I started using writing booster

486
00:19:03,200 --> 00:19:07,370
machines so when most machines will

487
00:19:05,269 --> 00:19:09,350
allow you to create this different small

488
00:19:07,370 --> 00:19:11,600
trees which might learn them for example

489
00:19:09,350 --> 00:19:12,830
a party where hash if it's missing it

490
00:19:11,600 --> 00:19:14,990
means that there's a correct

491
00:19:12,830 --> 00:19:17,149
authorization and a different hash if

492
00:19:14,990 --> 00:19:18,950
it's there it means it was a fail of

493
00:19:17,149 --> 00:19:20,570
rescission so without having the actual

494
00:19:18,950 --> 00:19:23,149
data or knowing that a word says

495
00:19:20,570 --> 00:19:24,860
incorrect a login it learns from it

496
00:19:23,149 --> 00:19:30,049
based on the amount of data that has

497
00:19:24,860 --> 00:19:32,539
been fed to the machine or model now up

498
00:19:30,049 --> 00:19:35,600
to here we have covered two different

499
00:19:32,539 --> 00:19:37,700
situations one situation was around okay

500
00:19:35,600 --> 00:19:39,529
how can we use back in signals and the

501
00:19:37,700 --> 00:19:40,670
other situation is how we can use the

502
00:19:39,529 --> 00:19:42,680
information of the

503
00:19:40,670 --> 00:19:44,690
but in both cases we had something which

504
00:19:42,680 --> 00:19:47,060
was key which was the actual

505
00:19:44,690 --> 00:19:49,550
authorization information so we were

506
00:19:47,060 --> 00:19:51,770
able to say based on the context I can

507
00:19:49,550 --> 00:19:54,770
predict if this was a successful or

508
00:19:51,770 --> 00:19:57,530
failed authorization attempt so that if

509
00:19:54,770 --> 00:19:59,600
for some reason I see that I'm returning

510
00:19:57,530 --> 00:20:02,389
content that looks like you passed an

511
00:19:59,600 --> 00:20:03,590
authorization check but you did not pass

512
00:20:02,390 --> 00:20:05,690
the Hawthorne check or that

513
00:20:03,590 --> 00:20:07,490
authorization check is missing then I

514
00:20:05,690 --> 00:20:09,350
have learned okay either there was an

515
00:20:07,490 --> 00:20:10,910
anomaly because I was expecting this

516
00:20:09,350 --> 00:20:13,040
this particular check of you can access

517
00:20:10,910 --> 00:20:15,650
a resource and it's not there like in

518
00:20:13,040 --> 00:20:17,450
the second example I showed or I will

519
00:20:15,650 --> 00:20:20,540
see a difference I see that there was a

520
00:20:17,450 --> 00:20:22,610
failure on your access but I return you

521
00:20:20,540 --> 00:20:24,860
the information or I saw enough queries

522
00:20:22,610 --> 00:20:26,510
to do this so that all information we

523
00:20:24,860 --> 00:20:27,979
learned from the context but what

524
00:20:26,510 --> 00:20:30,050
happens when we don't have an

525
00:20:27,980 --> 00:20:31,670
information is in the third case so

526
00:20:30,050 --> 00:20:33,889
that's the most tricky one because in

527
00:20:31,670 --> 00:20:35,990
this case we're actually trying to go

528
00:20:33,890 --> 00:20:39,050
and find out should somebody have added

529
00:20:35,990 --> 00:20:40,760
an assertion check here and there was no

530
00:20:39,050 --> 00:20:43,310
information for us to learn but we do

531
00:20:40,760 --> 00:20:46,160
have other information so just to

532
00:20:43,310 --> 00:20:48,530
mention a small detail before I was

533
00:20:46,160 --> 00:20:50,690
looking at different models and each

534
00:20:48,530 --> 00:20:53,120
were trained on each particular endpoint

535
00:20:50,690 --> 00:20:55,280
learning by apart let's say slash

536
00:20:53,120 --> 00:20:57,020
logging in this case I'm going to be

537
00:20:55,280 --> 00:20:58,730
looking at all the information from all

538
00:20:57,020 --> 00:21:00,980
the endpoints so every single endpoint

539
00:20:58,730 --> 00:21:03,230
and learning so what are we going to

540
00:21:00,980 --> 00:21:06,440
learn so in this case we had a message

541
00:21:03,230 --> 00:21:09,050
for friends a endpoint and there was no

542
00:21:06,440 --> 00:21:11,720
exception check but we did have a

543
00:21:09,050 --> 00:21:14,510
request for information in this case for

544
00:21:11,720 --> 00:21:15,830
example on the table user the call

545
00:21:14,510 --> 00:21:18,110
message for friends we will return the

546
00:21:15,830 --> 00:21:20,060
information even better I didn't do it

547
00:21:18,110 --> 00:21:21,649
for this example or demo but you could

548
00:21:20,060 --> 00:21:23,600
actually check is this a column that

549
00:21:21,650 --> 00:21:25,970
doesn't refer to the part super users

550
00:21:23,600 --> 00:21:27,709
and the same way it could be with API

551
00:21:25,970 --> 00:21:31,730
calls what API calls information you're

552
00:21:27,710 --> 00:21:33,920
accessing so here again I went with

553
00:21:31,730 --> 00:21:37,450
random first but the interesting part

554
00:21:33,920 --> 00:21:39,560
here is that this can become very deep a

555
00:21:37,450 --> 00:21:42,440
decision trees because what you are

556
00:21:39,560 --> 00:21:44,690
trying to learn now is based on

557
00:21:42,440 --> 00:21:47,420
information that the request god what I

558
00:21:44,690 --> 00:21:50,060
have expected there to be an authority

559
00:21:47,420 --> 00:21:52,370
session check so if I'm getting a I'm

560
00:21:50,060 --> 00:21:53,340
user a and request information from user

561
00:21:52,370 --> 00:21:54,989
B

562
00:21:53,340 --> 00:21:56,908
based on the behavior of all the other

563
00:21:54,990 --> 00:21:58,440
end points and the part where we

564
00:21:56,909 --> 00:22:00,749
resource and requesting like for example

565
00:21:58,440 --> 00:22:02,279
this message for friend columns or it

566
00:22:00,749 --> 00:22:04,649
could be some column which has pride

567
00:22:02,279 --> 00:22:06,539
information is this an end point that

568
00:22:04,649 --> 00:22:07,860
usually has enough force in check or

569
00:22:06,539 --> 00:22:10,289
it's an end point that doesn't have

570
00:22:07,860 --> 00:22:12,240
enough flotation check so for example US

571
00:22:10,289 --> 00:22:14,190
Fed at public columns if you had a

572
00:22:12,240 --> 00:22:16,259
decision tree they would find ok it's

573
00:22:14,190 --> 00:22:17,850
this part where column never has an

574
00:22:16,259 --> 00:22:20,039
association check but there might be

575
00:22:17,850 --> 00:22:22,320
another column or a combination of

576
00:22:20,039 --> 00:22:23,730
columns which do have this kind of

577
00:22:22,320 --> 00:22:29,309
checks and that's what you want to learn

578
00:22:23,730 --> 00:22:32,580
from this now up to here we had to build

579
00:22:29,309 --> 00:22:35,070
these models now you can either do it as

580
00:22:32,580 --> 00:22:37,769
a very large model or you can have

581
00:22:35,070 --> 00:22:40,139
separate models in my particular case

582
00:22:37,769 --> 00:22:42,330
for the first two situations I said to

583
00:22:40,139 --> 00:22:44,939
go with for two were models for each

584
00:22:42,330 --> 00:22:47,428
part where end point and also for each

585
00:22:44,940 --> 00:22:50,190
particular authorization path by a

586
00:22:47,429 --> 00:22:53,610
physician path I mean in this example

587
00:22:50,190 --> 00:22:56,009
how does the flow go of a request until

588
00:22:53,610 --> 00:22:57,990
you are actually returning something to

589
00:22:56,009 --> 00:22:59,580
a user so for example it could be that

590
00:22:57,990 --> 00:23:02,039
the user gets logged in and that's a

591
00:22:59,580 --> 00:23:03,720
failure request finish there there or

592
00:23:02,039 --> 00:23:07,379
it's a success and in that case it might

593
00:23:03,720 --> 00:23:10,080
fail or it might succeed on the use user

594
00:23:07,379 --> 00:23:12,389
current user check so each of these

595
00:23:10,080 --> 00:23:14,158
cases are actually splitting your data

596
00:23:12,389 --> 00:23:16,799
into smaller subsections

597
00:23:14,159 --> 00:23:19,169
and they explain you about a particular

598
00:23:16,799 --> 00:23:20,879
flow what is the behavior of that

599
00:23:19,169 --> 00:23:23,519
particular flow so in this part we're

600
00:23:20,879 --> 00:23:26,219
behavior in this particular flow are you

601
00:23:23,519 --> 00:23:26,999
when users fail are they requesting data

602
00:23:26,220 --> 00:23:28,440
from a database

603
00:23:26,999 --> 00:23:31,279
are they not requesting data from a

604
00:23:28,440 --> 00:23:33,509
disease and this helps on the second

605
00:23:31,279 --> 00:23:36,480
condition I showed of the skip check

606
00:23:33,509 --> 00:23:38,460
because if we go back to example you'll

607
00:23:36,480 --> 00:23:40,830
expect that if you even if we talk of

608
00:23:38,460 --> 00:23:42,720
the example of the image path you

609
00:23:40,830 --> 00:23:45,658
expected if you are going to access

610
00:23:42,720 --> 00:23:47,879
ICICI a CGI resource and there was a

611
00:23:45,659 --> 00:23:51,090
failure are there was a skip on the

612
00:23:47,879 --> 00:23:53,759
authorization check so it was not done

613
00:23:51,090 --> 00:23:55,860
at all you would see for this particular

614
00:23:53,759 --> 00:24:00,090
path which might have been

615
00:23:55,860 --> 00:24:01,169
let's say is user existing not not

616
00:24:00,090 --> 00:24:03,209
checking anything else from

617
00:24:01,170 --> 00:24:05,970
authorization fail you might say oh

618
00:24:03,210 --> 00:24:07,559
we're actually executing a CGI so I

619
00:24:05,970 --> 00:24:10,080
would be an anomaly that your model can

620
00:24:07,559 --> 00:24:12,690
learn so there's the benefit of doing

621
00:24:10,080 --> 00:24:14,370
production path that you can cater for

622
00:24:12,690 --> 00:24:16,380
this anomalies that might not have been

623
00:24:14,370 --> 00:24:18,299
learned and that would mean one of two

624
00:24:16,380 --> 00:24:19,799
things either this is a new behavior

625
00:24:18,299 --> 00:24:22,200
which might happen when you are rolling

626
00:24:19,799 --> 00:24:24,480
a new application not when you have the

627
00:24:22,200 --> 00:24:27,450
same code for one year or even one week

628
00:24:24,480 --> 00:24:31,350
or this might be someone exploiting a

629
00:24:27,450 --> 00:24:34,679
vulnerability so now on the training

630
00:24:31,350 --> 00:24:37,290
part one key part here is that you want

631
00:24:34,679 --> 00:24:39,960
to make it as representative as possible

632
00:24:37,290 --> 00:24:41,879
so depending on the size of your website

633
00:24:39,960 --> 00:24:43,950
or application you might get a lot more

634
00:24:41,880 --> 00:24:46,080
data or you might have be very

635
00:24:43,950 --> 00:24:48,179
constrained on the data but if for

636
00:24:46,080 --> 00:24:50,460
example you have multiple users of

637
00:24:48,179 --> 00:24:51,990
multiple countries and there's one

638
00:24:50,460 --> 00:24:53,700
country which is more active one part

639
00:24:51,990 --> 00:24:57,990
where our what a single hour of the day

640
00:24:53,700 --> 00:24:59,850
might not be enough there is no rule on

641
00:24:57,990 --> 00:25:01,770
how much time you will have to depend on

642
00:24:59,850 --> 00:25:03,540
your data but the key part is that you

643
00:25:01,770 --> 00:25:05,700
just focus on making it representative

644
00:25:03,540 --> 00:25:07,320
and one thing you can do is just start

645
00:25:05,700 --> 00:25:09,179
watching for errors and once those

646
00:25:07,320 --> 00:25:11,010
errors start disappearing you might say

647
00:25:09,179 --> 00:25:13,590
okay my mole has learned enough at this

648
00:25:11,010 --> 00:25:15,419
point then you might want to start going

649
00:25:13,590 --> 00:25:17,699
from the alerting to blocking to

650
00:25:15,419 --> 00:25:19,950
detecting anomalies so you don't want to

651
00:25:17,700 --> 00:25:22,080
start from blocking at the start and in

652
00:25:19,950 --> 00:25:24,330
some cases as the one I showed for

653
00:25:22,080 --> 00:25:26,070
detecting a columns which should have an

654
00:25:24,330 --> 00:25:29,970
authorization path you might want to

655
00:25:26,070 --> 00:25:32,040
start with alerting only then you might

656
00:25:29,970 --> 00:25:33,990
want to adapt to new versions of the

657
00:25:32,040 --> 00:25:35,190
logic as they are introduced so for

658
00:25:33,990 --> 00:25:36,809
example every time that somebody is

659
00:25:35,190 --> 00:25:38,400
running out a new application they say

660
00:25:36,809 --> 00:25:40,500
they are deploying some new continue

661
00:25:38,400 --> 00:25:42,870
image you might want to pick up on these

662
00:25:40,500 --> 00:25:44,580
changes and try to start training a new

663
00:25:42,870 --> 00:25:45,178
model based on this new version of the

664
00:25:44,580 --> 00:25:46,949
application

665
00:25:45,179 --> 00:25:48,419
so if somebody changes on a forestation

666
00:25:46,950 --> 00:25:50,220
path we're not going to be blocking

667
00:25:48,419 --> 00:25:52,950
normal users you are actually adapting

668
00:25:50,220 --> 00:25:54,330
to okay this is the new normal of course

669
00:25:52,950 --> 00:25:56,820
there's the danger here that somebody

670
00:25:54,330 --> 00:25:58,799
might be exploiting the new reality

671
00:25:56,820 --> 00:26:00,450
exactly in the first seconds that is

672
00:25:58,799 --> 00:26:02,790
released which should appear

673
00:26:00,450 --> 00:26:04,410
synonymously it shouldn't be a constant

674
00:26:02,790 --> 00:26:05,428
behavior and you should be able to

675
00:26:04,410 --> 00:26:07,950
detect against it

676
00:26:05,429 --> 00:26:09,450
or worst case at least the risk as me we

677
00:26:07,950 --> 00:26:11,730
used to this particular

678
00:26:09,450 --> 00:26:14,340
moment in time for code which was not

679
00:26:11,730 --> 00:26:16,769
present in the past and finally around

680
00:26:14,340 --> 00:26:18,360
online training that's also a nice

681
00:26:16,769 --> 00:26:20,970
possibility it cannot be done with all

682
00:26:18,360 --> 00:26:22,379
the models it shops some of the problems

683
00:26:20,970 --> 00:26:24,600
for example if you are training neural

684
00:26:22,380 --> 00:26:26,970
networks on the actual content of the

685
00:26:24,600 --> 00:26:28,860
response on the same web server let's

686
00:26:26,970 --> 00:26:30,450
say in a parallel way you might not have

687
00:26:28,860 --> 00:26:31,709
to worry about encrypting the data or

688
00:26:30,450 --> 00:26:33,179
hashing the data because it's going to

689
00:26:31,710 --> 00:26:38,010
be compressed as part of the new

690
00:26:33,179 --> 00:26:39,840
bindings of the neural network now up to

691
00:26:38,010 --> 00:26:41,760
this part we are calling on how to train

692
00:26:39,840 --> 00:26:44,340
the model let's say we now have those

693
00:26:41,760 --> 00:26:46,320
models available first of all you can

694
00:26:44,340 --> 00:26:47,760
detect it by out of an so you're

695
00:26:46,320 --> 00:26:50,039
collecting all this context information

696
00:26:47,760 --> 00:26:53,970
I showed before and then you are

697
00:26:50,039 --> 00:26:55,980
executing these checks by replying this

698
00:26:53,970 --> 00:26:57,779
information to the models and checking

699
00:26:55,980 --> 00:27:00,480
what the models predicted again against

700
00:26:57,779 --> 00:27:01,700
what the request set the key part here

701
00:27:00,480 --> 00:27:04,919
that you want to avoid alert fatigue

702
00:27:01,700 --> 00:27:07,769
this is my nice thing about this from

703
00:27:04,919 --> 00:27:09,179
this perspective the the logic and what

704
00:27:07,769 --> 00:27:11,309
happens in this kind of decision trees

705
00:27:09,179 --> 00:27:13,440
is very fixed so applications don't

706
00:27:11,309 --> 00:27:16,289
usually change the amount of database

707
00:27:13,440 --> 00:27:18,690
calls they do without doing a rollout so

708
00:27:16,289 --> 00:27:21,899
that means that the the threshold for

709
00:27:18,690 --> 00:27:23,730
errors is very small and then unblocking

710
00:27:21,899 --> 00:27:25,709
it really depends on how you want to do

711
00:27:23,730 --> 00:27:27,539
it I have spoke in the past on how you

712
00:27:25,710 --> 00:27:29,850
can do have with a blocking

713
00:27:27,539 --> 00:27:32,370
architectures but in this case and for

714
00:27:29,850 --> 00:27:34,080
demo I just did with an inline model

715
00:27:32,370 --> 00:27:36,989
which means that every single request

716
00:27:34,080 --> 00:27:39,570
I'm actually before sending it back to

717
00:27:36,990 --> 00:27:41,700
you sure I'm giving it to the model to

718
00:27:39,570 --> 00:27:43,500
check the information the context does

719
00:27:41,700 --> 00:27:45,480
it look exactly to what you were

720
00:27:43,500 --> 00:27:48,630
predicting if not do not return the

721
00:27:45,480 --> 00:27:50,010
information and one more comment because

722
00:27:48,630 --> 00:27:52,860
I didn't have a lot of time to cover

723
00:27:50,010 --> 00:27:55,350
this part but the same things I'm

724
00:27:52,860 --> 00:27:56,850
talking about from the grid perspective

725
00:27:55,350 --> 00:27:59,459
like reading databases you could

726
00:27:56,850 --> 00:28:01,439
implement it on the right perspective so

727
00:27:59,460 --> 00:28:03,720
for example there is a paper from

728
00:28:01,440 --> 00:28:05,519
facebook on environment detection that

729
00:28:03,720 --> 00:28:08,970
they did using their graph the toys and

730
00:28:05,519 --> 00:28:10,380
one thing they do is they try to in a

731
00:28:08,970 --> 00:28:12,690
very different way but they tried to

732
00:28:10,380 --> 00:28:14,330
replicate origin checks so not predict

733
00:28:12,690 --> 00:28:16,740
them that actually run them again

734
00:28:14,330 --> 00:28:19,350
before their graph data if I remember

735
00:28:16,740 --> 00:28:21,029
correctly in a way we're not going to do

736
00:28:19,350 --> 00:28:22,740
that but what you can do is you can hook

737
00:28:21,029 --> 00:28:25,830
into the right calls

738
00:28:22,740 --> 00:28:28,860
so even if it's a service call - HTTP

739
00:28:25,830 --> 00:28:31,110
service or write a database and execute

740
00:28:28,860 --> 00:28:33,000
the same logic at this point collect all

741
00:28:31,110 --> 00:28:35,789
the context of the request and compare

742
00:28:33,000 --> 00:28:37,799
that context to your prediction before I

743
00:28:35,789 --> 00:28:40,289
write and decide is this what I expected

744
00:28:37,799 --> 00:28:43,230
or not so for example if you're writing

745
00:28:40,289 --> 00:28:44,789
to a particular table you could check ok

746
00:28:43,230 --> 00:28:50,520
I expected to have this authorization

747
00:28:44,789 --> 00:28:53,039
check to succeed or to have it at all so

748
00:28:50,520 --> 00:28:55,200
now I will try to do a demo basically

749
00:28:53,039 --> 00:28:59,490
for the demo what I did was I repurposed

750
00:28:55,200 --> 00:29:01,890
for my had added a idor street then

751
00:28:59,490 --> 00:29:03,559
created 10,000 random users and started

752
00:29:01,890 --> 00:29:05,970
having them interactions with each other

753
00:29:03,559 --> 00:29:08,668
so I could actually build the models and

754
00:29:05,970 --> 00:29:23,039
then I could add them for the blocking

755
00:29:08,669 --> 00:29:28,799
part so let's see for that I will I will

756
00:29:23,039 --> 00:29:33,090
go to website oh of course

757
00:29:28,799 --> 00:29:38,580
yeah how it you so I built a domain for

758
00:29:33,090 --> 00:29:40,799
this so this a normal website is very

759
00:29:38,580 --> 00:29:43,559
small forum where you can go and you can

760
00:29:40,799 --> 00:29:47,429
get some post and then you can

761
00:29:43,559 --> 00:29:53,700
accelerate so in this case I will just

762
00:29:47,429 --> 00:29:59,909
grab a random user like this one and I

763
00:29:53,700 --> 00:30:02,279
can log in as the user of course it's a

764
00:29:59,909 --> 00:30:05,789
very simple password but it's fine and

765
00:30:02,279 --> 00:30:09,990
now what I'm going to do is I will also

766
00:30:05,789 --> 00:30:13,350
grab another user so first as the normal

767
00:30:09,990 --> 00:30:15,419
user I will go to my profile and check

768
00:30:13,350 --> 00:30:17,730
my information okay everything's there

769
00:30:15,419 --> 00:30:19,289
but what if I try to do an ID are so

770
00:30:17,730 --> 00:30:24,149
we'll try to access based on the Eastern

771
00:30:19,289 --> 00:30:28,860
name so now which doesn't work fine

772
00:30:24,149 --> 00:30:32,750
they're also important check but if we

773
00:30:28,860 --> 00:30:32,750
add the ignore auth parameter

774
00:30:37,009 --> 00:30:44,340
okay now it works now we got a message

775
00:30:41,190 --> 00:30:49,559
below basically because I will say I

776
00:30:44,340 --> 00:30:50,939
have the detection mode on for this so

777
00:30:49,559 --> 00:30:52,710
they're basically there was a model

778
00:30:50,940 --> 00:30:53,970
which was running and that mole checked

779
00:30:52,710 --> 00:30:57,389
hey

780
00:30:53,970 --> 00:31:01,440
he stays the prediction I had and if not

781
00:30:57,389 --> 00:31:12,119
the prediction would be oh wait I will

782
00:31:01,440 --> 00:31:14,429
try to put this up here so Bob let's go

783
00:31:12,119 --> 00:31:31,709
through it I will just contain connect

784
00:31:14,429 --> 00:31:35,179
to my container and we'll check the

785
00:31:31,710 --> 00:31:35,179
locks so you can see the information

786
00:31:35,840 --> 00:31:41,189
that just happened so as I showed before

787
00:31:38,399 --> 00:31:44,549
the in the logs here we had just one

788
00:31:41,190 --> 00:31:47,399
request to the other user and the

789
00:31:44,549 --> 00:31:50,039
operation failed yet we were able to get

790
00:31:47,399 --> 00:31:51,629
all this information and that's why the

791
00:31:50,039 --> 00:31:53,220
mole actually learned from it it

792
00:31:51,629 --> 00:31:54,590
realized okay this was not what I

793
00:31:53,220 --> 00:32:00,840
expected

794
00:31:54,590 --> 00:32:15,149
so for example if I now change the mall

795
00:32:00,840 --> 00:32:19,230
a multi-block okay well this was not

796
00:32:15,149 --> 00:32:21,590
expected but I can just change it for

797
00:32:19,230 --> 00:32:21,590
our toys

798
00:32:28,010 --> 00:32:35,790
so now if we go to our website anything

799
00:32:33,000 --> 00:32:36,960
works yes it doesn't work anymore so

800
00:32:35,790 --> 00:32:40,550
you're not getting a date anymore

801
00:32:36,960 --> 00:32:42,600
basically what's going on here is that

802
00:32:40,550 --> 00:32:45,960
based on this information

803
00:32:42,600 --> 00:32:47,730
now the model executed check this and

804
00:32:45,960 --> 00:32:50,580
realized okay this was not what I

805
00:32:47,730 --> 00:32:52,230
expected so if we compare before this

806
00:32:50,580 --> 00:32:56,399
was the previous one when we were not

807
00:32:52,230 --> 00:32:58,230
adding the ignore of a check so just by

808
00:32:56,400 --> 00:33:01,170
looking at the request it also failed

809
00:32:58,230 --> 00:33:03,930
but it's obvious that we did not execute

810
00:33:01,170 --> 00:33:05,670
the data the requests that we wanted so

811
00:33:03,930 --> 00:33:08,220
from here you can realize that this

812
00:33:05,670 --> 00:33:11,460
context and in a way if you think about

813
00:33:08,220 --> 00:33:13,260
the key note how we talked about the

814
00:33:11,460 --> 00:33:15,630
different organizations and they used a

815
00:33:13,260 --> 00:33:18,210
metadata we're using the metadata of our

816
00:33:15,630 --> 00:33:19,950
request to learn from them and to

817
00:33:18,210 --> 00:33:21,840
predict what should happen what do we

818
00:33:19,950 --> 00:33:23,550
want it to happen and the key part with

819
00:33:21,840 --> 00:33:25,980
this authorization bypass annuities so

820
00:33:23,550 --> 00:33:28,590
it could be with an ITR or it could be

821
00:33:25,980 --> 00:33:33,480
with something like a vertical privilege

822
00:33:28,590 --> 00:33:35,459
a bypass they always have some sort some

823
00:33:33,480 --> 00:33:37,200
connection to a context so if you are

824
00:33:35,460 --> 00:33:39,930
able to access as a normal user a

825
00:33:37,200 --> 00:33:42,450
resource of an admin and your login

826
00:33:39,930 --> 00:33:45,210
information of is this user and admin or

827
00:33:42,450 --> 00:33:47,160
not you will realize we have a user with

828
00:33:45,210 --> 00:33:48,870
Apertura security clearance which is

829
00:33:47,160 --> 00:33:51,030
accessing a resource where every single

830
00:33:48,870 --> 00:33:53,489
user that access always had a higher

831
00:33:51,030 --> 00:33:55,830
security clearance so in a way you can

832
00:33:53,490 --> 00:33:58,290
treat this as an anomaly detection or a

833
00:33:55,830 --> 00:34:00,600
basic way of just blocking whatever is

834
00:33:58,290 --> 00:34:11,820
not expected so you're enforcing learned

835
00:34:00,600 --> 00:34:15,549
behavior from the application so

836
00:34:11,820 --> 00:34:17,560
some general notes and as I mentioned

837
00:34:15,550 --> 00:34:18,820
before you can use a single model but

838
00:34:17,560 --> 00:34:20,770
you should take into account your

839
00:34:18,820 --> 00:34:21,100
environment if it makes more sense or

840
00:34:20,770 --> 00:34:24,639
not

841
00:34:21,100 --> 00:34:26,710
then is a technical flaws that can lead

842
00:34:24,639 --> 00:34:29,109
to authorization by past priorities is

843
00:34:26,710 --> 00:34:30,550
going to allow you to be able to detect

844
00:34:29,110 --> 00:34:32,530
this anomalies but also learn a lot

845
00:34:30,550 --> 00:34:35,050
about your context and your application

846
00:34:32,530 --> 00:34:37,240
because this really helps you map how

847
00:34:35,050 --> 00:34:40,240
your application works the different

848
00:34:37,239 --> 00:34:41,469
ways it might behave and you know these

849
00:34:40,239 --> 00:34:43,060
information that most people even

850
00:34:41,469 --> 00:34:44,620
developers will not fully understand of

851
00:34:43,060 --> 00:34:46,090
the product especially if it's a product

852
00:34:44,620 --> 00:34:49,210
has been hacked on by different people

853
00:34:46,090 --> 00:34:52,030
over and over again and I mentioned on

854
00:34:49,210 --> 00:34:53,850
the API status code and as a general

855
00:34:52,030 --> 00:34:56,260
note what I would take from this is that

856
00:34:53,850 --> 00:34:57,940
we have a lot of information our request

857
00:34:56,260 --> 00:35:01,330
it's not normal for people to actually

858
00:34:57,940 --> 00:35:03,460
use it but very valuable and if there's

859
00:35:01,330 --> 00:35:05,590
something that machinery moles excel at

860
00:35:03,460 --> 00:35:08,020
is by getting a lot of information and

861
00:35:05,590 --> 00:35:10,570
learning from it and if you think about

862
00:35:08,020 --> 00:35:12,430
all of our security in a teasing

863
00:35:10,570 --> 00:35:14,380
application security what we're trying

864
00:35:12,430 --> 00:35:16,569
to achieve is the applications continue

865
00:35:14,380 --> 00:35:19,690
to behave as we expect them to behave

866
00:35:16,570 --> 00:35:21,850
and most cases this is going to be in

867
00:35:19,690 --> 00:35:23,350
the correct way of behaving or the

868
00:35:21,850 --> 00:35:24,940
normal way of behaving so that's

869
00:35:23,350 --> 00:35:26,140
information that you can leverage to be

870
00:35:24,940 --> 00:35:27,880
able to detect it's not just

871
00:35:26,140 --> 00:35:31,720
authorization bypass but the other types

872
00:35:27,880 --> 00:35:33,430
of vulnerabilities so yeah you can find

873
00:35:31,720 --> 00:35:36,669
me in Twitter and if I have any

874
00:35:33,430 --> 00:35:39,100
questions it's a good moment our just on

875
00:35:36,670 --> 00:35:41,490
me or find me somewhere so yeah thank

876
00:35:39,100 --> 00:35:41,490
you very much

