1
00:00:03,470 --> 00:00:11,430
so everyone thanks for coming her

2
00:00:06,019 --> 00:00:14,220
impression and I'm a PhD student at

3
00:00:11,430 --> 00:00:15,330
Dartmouth if you go to a lot of hacker

4
00:00:14,220 --> 00:00:18,259
conferences you would have heard of

5
00:00:15,330 --> 00:00:21,240
Soviet brothers they work with him and

6
00:00:18,259 --> 00:00:24,150
being an academician I work more I

7
00:00:21,240 --> 00:00:26,519
present most of my work at academic

8
00:00:24,150 --> 00:00:28,829
conferences and not so many hacker

9
00:00:26,519 --> 00:00:32,269
conferences so this is actually only my

10
00:00:28,829 --> 00:00:34,170
second hacker conference talk and I

11
00:00:32,270 --> 00:00:36,000
generally work in like language

12
00:00:34,170 --> 00:00:39,000
theoretic security as the title says non

13
00:00:36,000 --> 00:00:41,129
SEC and I also work on fine-grained

14
00:00:39,000 --> 00:00:47,399
access control policies for elf binaries

15
00:00:41,129 --> 00:00:49,649
and that's my Twitter handle first just

16
00:00:47,399 --> 00:00:53,850
a bunch of acknowledgments someone paid

17
00:00:49,649 --> 00:00:55,440
for my trip and some of this some of the

18
00:00:53,850 --> 00:00:56,879
work that I'm presenting is going to

19
00:00:55,440 --> 00:01:00,780
appear in like a book chapter and

20
00:00:56,879 --> 00:01:04,050
Conference proceedings soon and I work

21
00:01:00,780 --> 00:01:06,630
with a bunch of people awesome people so

22
00:01:04,050 --> 00:01:10,020
thanks to all of them in this talk I'm

23
00:01:06,630 --> 00:01:12,030
going to quickly summarize why parsers

24
00:01:10,020 --> 00:01:14,220
are important and I'm going to speak

25
00:01:12,030 --> 00:01:16,680
about what lansac is what lang stick is

26
00:01:14,220 --> 00:01:18,570
all about and I'm going to talk about a

27
00:01:16,680 --> 00:01:19,980
library that we built which is called

28
00:01:18,570 --> 00:01:22,289
hammer which is a parser Combinator

29
00:01:19,980 --> 00:01:24,540
toolkit and then I'm going to talk about

30
00:01:22,290 --> 00:01:27,720
how we applied our technique of Lang SEC

31
00:01:24,540 --> 00:01:30,960
to IOT protocols application layer IT

32
00:01:27,720 --> 00:01:35,010
protocols and I'm gonna I'm gonna like

33
00:01:30,960 --> 00:01:37,320
show you some code I'm usually worried

34
00:01:35,010 --> 00:01:40,170
of worried about demo guards not being

35
00:01:37,320 --> 00:01:43,529
happy on this day so I have snippets of

36
00:01:40,170 --> 00:01:44,850
code and I'll also show you some tests

37
00:01:43,530 --> 00:01:46,650
that we wrote and how we go about

38
00:01:44,850 --> 00:01:47,479
testing our parsers to make sure that

39
00:01:46,650 --> 00:01:52,380
they're good

40
00:01:47,480 --> 00:01:54,960
so first parsers and security so this is

41
00:01:52,380 --> 00:01:56,640
the story of how passes actually parser

42
00:01:54,960 --> 00:01:58,110
Combinator toolkits and how long sake

43
00:01:56,640 --> 00:02:01,560
has a field actually came about being

44
00:01:58,110 --> 00:02:04,740
and where I go to school Dartmouth is a

45
00:02:01,560 --> 00:02:09,149
very cold and very cold and icy place

46
00:02:04,740 --> 00:02:11,280
and the motor of the state is live free

47
00:02:09,149 --> 00:02:13,620
or die and we just call it live freeze

48
00:02:11,280 --> 00:02:15,930
and die because that's what happens

49
00:02:13,620 --> 00:02:20,909
every day and

50
00:02:15,930 --> 00:02:23,790
long ago in a galaxy far far away not

51
00:02:20,909 --> 00:02:28,230
that long ago only around 20 2011 that's

52
00:02:23,790 --> 00:02:30,689
when that's when my lab actually came

53
00:02:28,230 --> 00:02:33,179
about it came they created this field a

54
00:02:30,689 --> 00:02:35,819
blank check and on people like really

55
00:02:33,180 --> 00:02:40,019
wrote very bad good and people still do

56
00:02:35,819 --> 00:02:41,849
so parsers are traditionally the front

57
00:02:40,019 --> 00:02:43,439
line of any application like a parser is

58
00:02:41,849 --> 00:02:45,000
the part of the application that

59
00:02:43,439 --> 00:02:51,000
actually receives the input and make

60
00:02:45,000 --> 00:02:53,879
sure that it's good and and parses are

61
00:02:51,000 --> 00:02:55,500
dangerous because they can if you have a

62
00:02:53,879 --> 00:02:57,030
bug in your parser then that's like a

63
00:02:55,500 --> 00:02:59,549
gateway to the rest of your program and

64
00:02:57,030 --> 00:03:01,079
a parser has to ensure that all your

65
00:02:59,549 --> 00:03:02,909
preconditions for your protocol are

66
00:03:01,079 --> 00:03:05,010
match like your protocol has a bunch of

67
00:03:02,909 --> 00:03:07,459
syntax it has to verify each and every

68
00:03:05,010 --> 00:03:10,679
of the syntax are right and verified and

69
00:03:07,459 --> 00:03:12,269
a parser is also a gateway as I said

70
00:03:10,680 --> 00:03:13,889
earlier it's a gateway to an attacker in

71
00:03:12,269 --> 00:03:15,719
attacker if they are aware of what

72
00:03:13,889 --> 00:03:17,730
parser bugs there are like if an

73
00:03:15,719 --> 00:03:19,978
attacker passes it and knows that for

74
00:03:17,730 --> 00:03:21,988
what inputs your program can crash then

75
00:03:19,979 --> 00:03:23,310
an attacker can actually use this

76
00:03:21,989 --> 00:03:27,180
particular passer as an engine of

77
00:03:23,310 --> 00:03:28,889
computation most of our our ideas over

78
00:03:27,180 --> 00:03:30,510
here stem from formal language theory

79
00:03:28,889 --> 00:03:34,169
and I'll give you a brief brief primer

80
00:03:30,510 --> 00:03:36,209
to that soon and so parser code so what

81
00:03:34,169 --> 00:03:39,299
we say is that parser code should look

82
00:03:36,209 --> 00:03:42,389
like the grammar so any protocol has a

83
00:03:39,299 --> 00:03:44,759
grammar and formal specification and the

84
00:03:42,389 --> 00:03:46,259
parser should stem and look exactly like

85
00:03:44,759 --> 00:03:48,259
that grammar that was written in the

86
00:03:46,259 --> 00:03:49,978
specification and quite often

87
00:03:48,259 --> 00:03:52,679
specifications don't have a clear-cut

88
00:03:49,979 --> 00:03:54,419
grammar they have only long pages of

89
00:03:52,680 --> 00:03:57,620
verbose text thousands and thousand

90
00:03:54,419 --> 00:04:00,479
pages quite quite often and you sort of

91
00:03:57,620 --> 00:04:02,009
as parser writers like we sort of have

92
00:04:00,479 --> 00:04:07,919
to go through these thousands of pages

93
00:04:02,009 --> 00:04:09,839
and extract the grammar out and so as

94
00:04:07,919 --> 00:04:11,849
you see in this diagram it's not super

95
00:04:09,840 --> 00:04:14,939
clear I apologize for that I didn't

96
00:04:11,849 --> 00:04:16,639
anticipate this but so what you can see

97
00:04:14,939 --> 00:04:18,918
in this diagram is basically this that

98
00:04:16,639 --> 00:04:21,090
your program you write a program

99
00:04:18,918 --> 00:04:24,330
expecting only a certain set of inputs

100
00:04:21,089 --> 00:04:26,580
and any attacker or anyone for that

101
00:04:24,330 --> 00:04:29,250
matter can send your program a bunch of

102
00:04:26,580 --> 00:04:29,878
any input any garbage input so how does

103
00:04:29,250 --> 00:04:31,619
your

104
00:04:29,879 --> 00:04:33,360
actually make sure that your program

105
00:04:31,619 --> 00:04:35,520
only accepts the certain set of input

106
00:04:33,360 --> 00:04:38,279
sanitization is not really enough you

107
00:04:35,520 --> 00:04:41,039
need to have a foolproof parser or a

108
00:04:38,279 --> 00:04:42,808
bulletproof faster if I may that can

109
00:04:41,039 --> 00:04:45,149
like make sure that your program only

110
00:04:42,809 --> 00:04:47,849
accepts the expected set of inputs and

111
00:04:45,149 --> 00:04:50,569
rejects all the unexpected set of inputs

112
00:04:47,849 --> 00:04:52,679
so what can really go wrong and parsing

113
00:04:50,569 --> 00:04:54,270
object boundaries in messages could

114
00:04:52,679 --> 00:04:58,469
overlap like you could have messages

115
00:04:54,270 --> 00:05:00,659
where the the boundaries for fields in

116
00:04:58,469 --> 00:05:03,330
your packet format is not very clear and

117
00:05:00,659 --> 00:05:06,300
you could have objects embedded in other

118
00:05:03,330 --> 00:05:07,948
objects that you could have two

119
00:05:06,300 --> 00:05:10,379
particular values that need to be equal

120
00:05:07,949 --> 00:05:13,229
and they don't end up being equal you

121
00:05:10,379 --> 00:05:15,839
could have preconditions and all these

122
00:05:13,229 --> 00:05:17,998
sort of lead to unpredictable behavior

123
00:05:15,839 --> 00:05:20,879
and hence lead to buffer overflow as

124
00:05:17,999 --> 00:05:21,990
memory corruptions exploitation and most

125
00:05:20,879 --> 00:05:25,229
of the popular attacks that you could

126
00:05:21,990 --> 00:05:28,019
have heard of now I will actually go

127
00:05:25,229 --> 00:05:30,869
into some examples of some parser bugs

128
00:05:28,019 --> 00:05:33,209
that were really famous one important

129
00:05:30,869 --> 00:05:34,860
one is the heartbleed bug where the

130
00:05:33,209 --> 00:05:38,849
linked fields weren't really validated

131
00:05:34,860 --> 00:05:41,249
and that led to buffer over reads and

132
00:05:38,849 --> 00:05:42,839
what really happened there was that they

133
00:05:41,249 --> 00:05:46,379
were they were using pointer arithmetic

134
00:05:42,839 --> 00:05:48,959
and that didn't really go super well so

135
00:05:46,379 --> 00:05:51,389
when you yeah I go into a depth a bit

136
00:05:48,959 --> 00:05:54,689
later in email um so the etherium de or

137
00:05:51,389 --> 00:05:57,300
disaster was another huge bug where they

138
00:05:54,689 --> 00:05:59,039
were using recursion and it's not really

139
00:05:57,300 --> 00:06:00,959
that create when you actually have to

140
00:05:59,039 --> 00:06:02,759
run the code to know what really happens

141
00:06:00,959 --> 00:06:05,279
you don't have any idea what's really

142
00:06:02,759 --> 00:06:07,409
happening and you have to run it and it

143
00:06:05,279 --> 00:06:09,289
just recursos and it cost them a lot

144
00:06:07,409 --> 00:06:11,849
they had to do a hard fork and stuff so

145
00:06:09,289 --> 00:06:13,589
yeah um

146
00:06:11,849 --> 00:06:15,149
Ruby on Rails sort of had this very

147
00:06:13,589 --> 00:06:18,199
interesting bug where they were using

148
00:06:15,149 --> 00:06:20,550
the eval call and they just ended up

149
00:06:18,199 --> 00:06:23,219
basically just running the yamen input

150
00:06:20,550 --> 00:06:25,499
through it and they were sanitizing the

151
00:06:23,219 --> 00:06:27,869
ml input to convert it to something that

152
00:06:25,499 --> 00:06:31,439
they could actually read and it did not

153
00:06:27,869 --> 00:06:33,389
go well and it was a really popular Ruby

154
00:06:31,439 --> 00:06:36,509
on Rails bug and he got really famous

155
00:06:33,389 --> 00:06:39,509
and it was called Ruby off phrase

156
00:06:36,509 --> 00:06:41,969
and the these bugs actually translate to

157
00:06:39,509 --> 00:06:43,229
the IOT world as well we were looking

158
00:06:41,969 --> 00:06:44,969
while we were actually working on this

159
00:06:43,229 --> 00:06:47,789
project we were looking at CBL is to

160
00:06:44,969 --> 00:06:49,289
like see if these IOT protocols that we

161
00:06:47,789 --> 00:06:51,719
were looking at the application layer

162
00:06:49,289 --> 00:06:54,240
ones like were they actually exploited

163
00:06:51,719 --> 00:06:57,058
not so much but then they were still

164
00:06:54,240 --> 00:06:59,159
alarming there were a significant number

165
00:06:57,059 --> 00:07:02,339
of vulnerabilities and they were looking

166
00:06:59,159 --> 00:07:04,770
at one important one from IBM on the IBM

167
00:07:02,339 --> 00:07:07,589
insight where this was basically a

168
00:07:04,770 --> 00:07:09,419
crafted packet that could that would

169
00:07:07,589 --> 00:07:14,580
force the server to like continuously be

170
00:07:09,419 --> 00:07:16,979
restarted this brings me to what what

171
00:07:14,580 --> 00:07:19,139
passing and protocol antipatterns we are

172
00:07:16,979 --> 00:07:22,349
talking about here so shorten parsers

173
00:07:19,139 --> 00:07:24,300
have parsing and code that is intermixed

174
00:07:22,349 --> 00:07:26,490
and they are not demarcated so your

175
00:07:24,300 --> 00:07:28,770
program sort of has to first validate

176
00:07:26,490 --> 00:07:32,159
your entire input that's what we are

177
00:07:28,770 --> 00:07:33,419
preaching over here and your shotgun

178
00:07:32,159 --> 00:07:36,029
parser is something where your

179
00:07:33,419 --> 00:07:37,710
validation and the processing logic is

180
00:07:36,029 --> 00:07:40,710
like intermixed and it's not demarcated

181
00:07:37,710 --> 00:07:42,659
very clearly and sometimes you have

182
00:07:40,710 --> 00:07:45,239
programs that have languages that use

183
00:07:42,659 --> 00:07:48,599
input languages that are more complex

184
00:07:45,240 --> 00:07:49,979
than context-free or regular like

185
00:07:48,599 --> 00:07:50,789
contacts etcetera or even sometimes

186
00:07:49,979 --> 00:07:53,490
turing-complete

187
00:07:50,789 --> 00:07:55,949
so in these cases it becomes really hard

188
00:07:53,490 --> 00:07:58,189
to parse it because if it's still

189
00:07:55,949 --> 00:08:00,930
incomplete it's not like decidable and

190
00:07:58,189 --> 00:08:04,620
you cannot prove equivalence if it's not

191
00:08:00,930 --> 00:08:06,330
regular or context-free and partial

192
00:08:04,620 --> 00:08:08,249
differentials are another anti pattern

193
00:08:06,330 --> 00:08:10,438
where you have two passes like let's say

194
00:08:08,249 --> 00:08:12,479
your client and a server that implement

195
00:08:10,439 --> 00:08:14,459
the exact same protocol you want to make

196
00:08:12,479 --> 00:08:16,109
sure that the client and the server both

197
00:08:14,459 --> 00:08:17,819
have the exact same parser and you can

198
00:08:16,110 --> 00:08:20,069
prove that they are both equivalent if

199
00:08:17,819 --> 00:08:23,189
you cannot which is what led to like the

200
00:08:20,069 --> 00:08:25,229
Android master key bug where the the C++

201
00:08:23,189 --> 00:08:26,669
on the Java implementations like one of

202
00:08:25,229 --> 00:08:28,889
them was using at your end one of them

203
00:08:26,669 --> 00:08:31,799
was using an int and you you really

204
00:08:28,889 --> 00:08:35,729
can't prove equal and so here and like

205
00:08:31,800 --> 00:08:37,469
the the PKI certificates where the

206
00:08:35,729 --> 00:08:39,750
client interprets the certificate in one

207
00:08:37,469 --> 00:08:42,599
way and the server interprets it another

208
00:08:39,750 --> 00:08:44,219
way so those those are examples of

209
00:08:42,599 --> 00:08:47,519
passer differentials and that is also

210
00:08:44,219 --> 00:08:48,600
one of the route one of the one of the

211
00:08:47,519 --> 00:08:51,319
anti patterns that we are addressing

212
00:08:48,600 --> 00:08:51,319
through lan check

213
00:08:52,040 --> 00:08:57,329
so this is an anti-pattern in a c

214
00:08:54,450 --> 00:08:58,830
program in c parsers where there's there

215
00:08:57,330 --> 00:09:00,150
is a lot of parser at it matter that

216
00:08:58,830 --> 00:09:02,400
there's a lot of pointer arithmetic that

217
00:09:00,150 --> 00:09:04,800
is used and to step through variable

218
00:09:02,400 --> 00:09:06,839
length pointer arithmetic sarn't really

219
00:09:04,800 --> 00:09:09,029
the best idea as we saw in the

220
00:09:06,839 --> 00:09:13,440
heartbleed bug as well it doesn't really

221
00:09:09,029 --> 00:09:16,350
end up very well if so being an academic

222
00:09:13,440 --> 00:09:18,510
I sort of I'm forced to put a bunch of

223
00:09:16,350 --> 00:09:22,290
geeky symbols it's okay if you don't

224
00:09:18,510 --> 00:09:23,970
understand this so everything that I

225
00:09:22,290 --> 00:09:25,829
told you before this like anti patterns

226
00:09:23,970 --> 00:09:27,570
can actually be formalized in this

227
00:09:25,830 --> 00:09:29,460
particular way so we have three

228
00:09:27,570 --> 00:09:31,830
different operations here so there is

229
00:09:29,460 --> 00:09:33,300
the interpretation equivalence there's

230
00:09:31,830 --> 00:09:34,920
an interpretation uncertainty but that's

231
00:09:33,300 --> 00:09:37,069
the question mark and then there's the

232
00:09:34,920 --> 00:09:39,300
interpretation in equivalence so

233
00:09:37,070 --> 00:09:40,770
basically all this equation is saying is

234
00:09:39,300 --> 00:09:42,779
that the the left hand side is the

235
00:09:40,770 --> 00:09:46,439
predicate and the right hand side is

236
00:09:42,779 --> 00:09:49,529
like a bunch of a bunch of interpreters

237
00:09:46,440 --> 00:09:52,140
so for example in the second line where

238
00:09:49,529 --> 00:09:54,480
I have P and I have the uncertainty

239
00:09:52,140 --> 00:09:57,689
interpretation so they're all it means

240
00:09:54,480 --> 00:10:00,420
is that there is a predicate and a 1 to

241
00:09:57,690 --> 00:10:02,580
a K actually interpreted differently

242
00:10:00,420 --> 00:10:04,709
or they don't know if it's actually

243
00:10:02,580 --> 00:10:08,220
certain I'll explain this with an

244
00:10:04,709 --> 00:10:10,650
example so if you have a language L that

245
00:10:08,220 --> 00:10:12,779
is known to be decidable then you have

246
00:10:10,650 --> 00:10:15,270
an Oracle or and you have the designer

247
00:10:12,779 --> 00:10:16,680
of a protocol who basically do not who

248
00:10:15,270 --> 00:10:19,560
are uncertain that this particular

249
00:10:16,680 --> 00:10:21,239
language is decidable so as I said it

250
00:10:19,560 --> 00:10:24,529
like this is just academic jargon you

251
00:10:21,240 --> 00:10:26,880
don't have to completely understand this

252
00:10:24,529 --> 00:10:29,459
to actually describe this in a better

253
00:10:26,880 --> 00:10:32,220
diagram so we basically have three

254
00:10:29,459 --> 00:10:35,250
particular three three people involved

255
00:10:32,220 --> 00:10:37,230
in this particular anti-pattern analysis

256
00:10:35,250 --> 00:10:39,480
so we have a designer we have an oracle

257
00:10:37,230 --> 00:10:42,180
who always speaks the truth and we have

258
00:10:39,480 --> 00:10:43,709
an implementer so basically the idea is

259
00:10:42,180 --> 00:10:45,900
that the implementer and the designer

260
00:10:43,709 --> 00:10:47,670
the design if the implementer is

261
00:10:45,900 --> 00:10:49,829
basically designed implementing the

262
00:10:47,670 --> 00:10:51,180
design protocol and the implementer and

263
00:10:49,830 --> 00:10:53,610
the designer both believe that the

264
00:10:51,180 --> 00:10:56,130
specification is decidable or the

265
00:10:53,610 --> 00:10:58,560
protocol is decidable and the oracle

266
00:10:56,130 --> 00:11:00,329
knows that in reality it's not so this

267
00:10:58,560 --> 00:11:02,839
leads to some so that's why we have an

268
00:11:00,329 --> 00:11:04,939
in equivalence operation here so in PR

269
00:11:02,840 --> 00:11:07,010
the truth and what the designer or the

270
00:11:04,940 --> 00:11:10,310
implementer thinks the thing are like

271
00:11:07,010 --> 00:11:14,120
actually incorrect or not equal or both

272
00:11:10,310 --> 00:11:17,630
interpreted differently so this brings

273
00:11:14,120 --> 00:11:19,070
me to what the lansac viewpoint is so

274
00:11:17,630 --> 00:11:22,220
the lines of your point is this that we

275
00:11:19,070 --> 00:11:24,260
want apply formal language theory to to

276
00:11:22,220 --> 00:11:25,670
implement these parcels so when we are

277
00:11:24,260 --> 00:11:27,439
implementing a parser we are taking into

278
00:11:25,670 --> 00:11:30,349
account the formal specification of the

279
00:11:27,440 --> 00:11:32,870
formal grammar of the protocol and the

280
00:11:30,350 --> 00:11:34,880
whole goal is to prevent the recurring

281
00:11:32,870 --> 00:11:35,180
programmer errors that that I spoke

282
00:11:34,880 --> 00:11:38,630
about

283
00:11:35,180 --> 00:11:40,790
while motivating the problem so it's

284
00:11:38,630 --> 00:11:43,310
it's not a guaranteed foolproof solution

285
00:11:40,790 --> 00:11:45,410
but it does improve the code quality and

286
00:11:43,310 --> 00:11:51,560
makes it more readable and it helps you

287
00:11:45,410 --> 00:11:55,959
avoid a lot of these recurring issues so

288
00:11:51,560 --> 00:11:55,959
like basically identify this product

289
00:12:17,430 --> 00:12:24,420
so okay coming back so long sake are

290
00:12:22,350 --> 00:12:27,810
using to face a bunch of problematic

291
00:12:24,420 --> 00:12:30,630
syntax and features and the way you

292
00:12:27,810 --> 00:12:32,729
implement a parser using lang sake it

293
00:12:30,630 --> 00:12:34,380
points out when the specification of the

294
00:12:32,730 --> 00:12:36,660
protocol is actually ambiguous and

295
00:12:34,380 --> 00:12:39,420
programmers disagree in the protocol

296
00:12:36,660 --> 00:12:41,160
implementation or specification and the

297
00:12:39,420 --> 00:12:43,349
validity if the validity check is too

298
00:12:41,160 --> 00:12:45,180
hard to perform then the protocol should

299
00:12:43,350 --> 00:12:46,470
probably be simplified like there are a

300
00:12:45,180 --> 00:12:49,680
few protocols that we have worked with

301
00:12:46,470 --> 00:12:50,970
in the SCADA powered side where these

302
00:12:49,680 --> 00:12:52,260
suggested that the protocol should be

303
00:12:50,970 --> 00:12:55,650
simplified for example there's this

304
00:12:52,260 --> 00:12:57,450
protocol called dnp3 the the the

305
00:12:55,650 --> 00:13:00,540
specification was just too hard to get

306
00:12:57,450 --> 00:13:03,600
right by all programmers so we pointed

307
00:13:00,540 --> 00:13:05,219
this out and like a bunch of colleagues

308
00:13:03,600 --> 00:13:09,020
actually worked on fuzzing a bunch of

309
00:13:05,220 --> 00:13:11,430
these devices to identify these bugs and

310
00:13:09,020 --> 00:13:14,370
another issue is that there's too much

311
00:13:11,430 --> 00:13:15,900
context needed to judge if object is

312
00:13:14,370 --> 00:13:18,900
actually valid or invalid that means

313
00:13:15,900 --> 00:13:20,490
that there's a protocol state machine

314
00:13:18,900 --> 00:13:22,199
also like the protocol itself has a

315
00:13:20,490 --> 00:13:24,270
state machine like for example in TCP

316
00:13:22,200 --> 00:13:26,280
you send a syn you receive a syn ACK and

317
00:13:24,270 --> 00:13:27,630
you send an AK so input in this

318
00:13:26,280 --> 00:13:29,730
particular state machine you sort of

319
00:13:27,630 --> 00:13:31,500
need to know in which state you are and

320
00:13:29,730 --> 00:13:33,120
if the packet that you are receiving

321
00:13:31,500 --> 00:13:35,520
right now is valid with respect to the

322
00:13:33,120 --> 00:13:37,140
state also it's not just the syntax but

323
00:13:35,520 --> 00:13:39,600
it's also the overall state machine of

324
00:13:37,140 --> 00:13:41,189
the protocol itself so if your state

325
00:13:39,600 --> 00:13:43,860
machine of the protocol is also

326
00:13:41,190 --> 00:13:45,750
incredibly complex then it makes parsing

327
00:13:43,860 --> 00:13:49,170
also incredibly hard and you need a lot

328
00:13:45,750 --> 00:13:51,300
of context to actually judge if if the

329
00:13:49,170 --> 00:13:52,709
packet is actually valid and several

330
00:13:51,300 --> 00:13:55,199
sources of truth that would mean that

331
00:13:52,710 --> 00:13:57,690
you don't have just one one global

332
00:13:55,200 --> 00:13:59,010
syntax or one global specification you

333
00:13:57,690 --> 00:14:03,570
actually need to read from a lot of

334
00:13:59,010 --> 00:14:05,340
other places most protocols like most

335
00:14:03,570 --> 00:14:07,950
proprietary protocols have a bunch of

336
00:14:05,340 --> 00:14:10,350
documents half of them being deprecated

337
00:14:07,950 --> 00:14:12,390
and so on so it makes it really hard to

338
00:14:10,350 --> 00:14:19,380
build a parser for like such proprietary

339
00:14:12,390 --> 00:14:21,360
protocols so for people at the back who

340
00:14:19,380 --> 00:14:23,340
probably can't see this let me just

341
00:14:21,360 --> 00:14:25,350
explain so this is the Chomsky hierarchy

342
00:14:23,340 --> 00:14:27,720
if you have taken a formal language

343
00:14:25,350 --> 00:14:29,960
Theory class on automata you should

344
00:14:27,720 --> 00:14:33,380
probably have come across this

345
00:14:29,960 --> 00:14:35,930
but just to recap the innermost is the

346
00:14:33,380 --> 00:14:37,939
regular grammar the one right outside it

347
00:14:35,930 --> 00:14:39,709
is deterministic context-free this is

348
00:14:37,940 --> 00:14:41,240
non deterministic context-free this is

349
00:14:39,710 --> 00:14:43,040
context-sensitive and this is the

350
00:14:41,240 --> 00:14:45,680
dueling machine so over here what

351
00:14:43,040 --> 00:14:47,360
happens is that formally speaking only

352
00:14:45,680 --> 00:14:49,040
if your language is deterministic

353
00:14:47,360 --> 00:14:51,290
pushdown automata or context-free

354
00:14:49,040 --> 00:14:54,050
grammar or regular you can actually

355
00:14:51,290 --> 00:14:55,040
prove that your passes are equal and so

356
00:14:54,050 --> 00:14:57,349
if you have two parses that you

357
00:14:55,040 --> 00:15:00,349
implement if your language does not fall

358
00:14:57,350 --> 00:15:01,850
within these two levels then you cannot

359
00:15:00,350 --> 00:15:03,500
really prove that your parses are

360
00:15:01,850 --> 00:15:04,730
equivalent you cannot prove that two

361
00:15:03,500 --> 00:15:07,790
implementations of your protocol are

362
00:15:04,730 --> 00:15:10,940
equivalent and at the same time if your

363
00:15:07,790 --> 00:15:11,689
protocol if your specification is to a

364
00:15:10,940 --> 00:15:12,890
certain machine

365
00:15:11,690 --> 00:15:15,290
if your protocol is the Turing machine

366
00:15:12,890 --> 00:15:18,110
then if your protocol needs a tearing

367
00:15:15,290 --> 00:15:20,390
machine to validate your input then it's

368
00:15:18,110 --> 00:15:22,760
not really decidable there's the problem

369
00:15:20,390 --> 00:15:24,439
of the there's the halting problem so

370
00:15:22,760 --> 00:15:27,200
you don't really know if it's actually

371
00:15:24,440 --> 00:15:29,030
decidable so you definitely want to stay

372
00:15:27,200 --> 00:15:31,550
within the context-sensitive boundary

373
00:15:29,030 --> 00:15:33,199
but ideally speaking if you want to have

374
00:15:31,550 --> 00:15:35,390
two implementations that actually are

375
00:15:33,200 --> 00:15:36,710
equivalent or right and you want to have

376
00:15:35,390 --> 00:15:38,689
some good features you want to prove

377
00:15:36,710 --> 00:15:40,370
then you should definitely have your

378
00:15:38,690 --> 00:15:45,080
input language in this particular area

379
00:15:40,370 --> 00:15:48,050
so this is how we actually this is the

380
00:15:45,080 --> 00:15:49,880
overall Lang sake primitive so it's like

381
00:15:48,050 --> 00:15:51,890
you have an input you have a parser

382
00:15:49,880 --> 00:15:53,210
there the parser is essentially or

383
00:15:51,890 --> 00:15:55,640
decider for the input language the

384
00:15:53,210 --> 00:15:58,160
parser says that the input that it got

385
00:15:55,640 --> 00:15:59,420
was like valid or invalid and if it's

386
00:15:58,160 --> 00:16:00,230
valid it will give back a whole

387
00:15:59,420 --> 00:16:02,120
powerstrips

388
00:16:00,230 --> 00:16:06,950
if not then it will just reject the

389
00:16:02,120 --> 00:16:08,210
input and and then the input gets passed

390
00:16:06,950 --> 00:16:12,470
on to the rest of the program they'll

391
00:16:08,210 --> 00:16:14,150
actually processes the logic so how do

392
00:16:12,470 --> 00:16:17,510
we actually do this we start with the

393
00:16:14,150 --> 00:16:19,250
grammar we basically read the entire

394
00:16:17,510 --> 00:16:21,500
specification and extract the grammar

395
00:16:19,250 --> 00:16:23,570
from it and if the protocol comes

396
00:16:21,500 --> 00:16:25,760
without a grammar or the specification

397
00:16:23,570 --> 00:16:27,830
does not have a grammar then you still

398
00:16:25,760 --> 00:16:29,090
have to read the entire 2,000 3,000 page

399
00:16:27,830 --> 00:16:31,490
specification and come up with the

400
00:16:29,090 --> 00:16:32,990
grammar we had to do this for an

401
00:16:31,490 --> 00:16:35,990
incredible number of power grid

402
00:16:32,990 --> 00:16:38,990
protocols in the past before we got into

403
00:16:35,990 --> 00:16:40,790
the whole IOT space and the parser

404
00:16:38,990 --> 00:16:42,940
essentially looks exactly like grammar

405
00:16:40,790 --> 00:16:44,290
and another

406
00:16:42,940 --> 00:16:46,330
one thing to keep in mind is that you

407
00:16:44,290 --> 00:16:48,280
don't start any processing or you don't

408
00:16:46,330 --> 00:16:50,260
start any sanitization or anything with

409
00:16:48,280 --> 00:16:58,089
the input unless you completely verify

410
00:16:50,260 --> 00:17:00,300
that the input is valid so so these are

411
00:16:58,090 --> 00:17:03,610
some principles that Lang set follows

412
00:17:00,300 --> 00:17:06,129
so you're valid or expected syntax must

413
00:17:03,610 --> 00:17:07,329
be clear from the parser code and your

414
00:17:06,130 --> 00:17:10,030
parser code should be completely

415
00:17:07,329 --> 00:17:13,448
distinct your code must read exactly

416
00:17:10,030 --> 00:17:15,819
like a specification your code must

417
00:17:13,449 --> 00:17:17,350
accept all the so every syntax element

418
00:17:15,819 --> 00:17:19,060
in your code like every small piece of

419
00:17:17,349 --> 00:17:20,740
your parser should be incrementally

420
00:17:19,060 --> 00:17:24,069
testable and it should have a good

421
00:17:20,740 --> 00:17:26,230
testing hygiene and you're the tool kit

422
00:17:24,069 --> 00:17:28,810
itself which is what I mentioned earlier

423
00:17:26,230 --> 00:17:31,270
called hammer it should discourage

424
00:17:28,810 --> 00:17:33,850
troublesome syntax so we do need some

425
00:17:31,270 --> 00:17:36,070
sort of a tool kit that can enforce

426
00:17:33,850 --> 00:17:40,870
these principles that we are reaching

427
00:17:36,070 --> 00:17:44,320
out here so parser combinators were

428
00:17:40,870 --> 00:17:46,689
initially built for haskell but it's

429
00:17:44,320 --> 00:17:48,700
it's a really neat tool to have or to

430
00:17:46,690 --> 00:17:52,000
know to use and the tool that we built

431
00:17:48,700 --> 00:17:53,770
is written in c and c++ but we do have

432
00:17:52,000 --> 00:17:57,400
bindings for a lot of other languages

433
00:17:53,770 --> 00:17:59,350
and we have a bunch of parsing

434
00:17:57,400 --> 00:18:00,640
backgrounds that we use and this

435
00:17:59,350 --> 00:18:03,429
particular library is freely available

436
00:18:00,640 --> 00:18:06,640
and it has a very neat documentation so

437
00:18:03,430 --> 00:18:10,870
I would definitely encourage you to give

438
00:18:06,640 --> 00:18:14,740
it a try and try validating your input

439
00:18:10,870 --> 00:18:16,270
using it and the code looks exactly the

440
00:18:14,740 --> 00:18:18,940
grammar I've told that a bunch of times

441
00:18:16,270 --> 00:18:20,320
and for in this particular example you

442
00:18:18,940 --> 00:18:22,780
can see that if you have a sequence

443
00:18:20,320 --> 00:18:24,429
number that's exactly four bits long you

444
00:18:22,780 --> 00:18:26,620
can actually do that it doesn't have to

445
00:18:24,430 --> 00:18:28,360
have byte boundaries or eight byte

446
00:18:26,620 --> 00:18:32,379
boundaries that's not how that's not

447
00:18:28,360 --> 00:18:35,409
really necessary here and you have you

448
00:18:32,380 --> 00:18:38,710
have like primitives which are like bits

449
00:18:35,410 --> 00:18:40,180
bytes and EWTN's and so on and then you

450
00:18:38,710 --> 00:18:42,520
also have combinators which are like

451
00:18:40,180 --> 00:18:44,950
choices or many or sequences though like

452
00:18:42,520 --> 00:18:46,330
actually group them and you can also

453
00:18:44,950 --> 00:18:47,770
differ we have and we have a pretty

454
00:18:46,330 --> 00:18:49,810
decent API to implement your own

455
00:18:47,770 --> 00:18:52,470
combinators although I don't think it's

456
00:18:49,810 --> 00:18:54,639
necessary but you could if you wanted to

457
00:18:52,470 --> 00:18:57,039
this is a

458
00:18:54,640 --> 00:18:58,450
larger table that's describing some of

459
00:18:57,039 --> 00:19:00,429
the primitives that we have so we have

460
00:18:58,450 --> 00:19:02,289
primitives for characters for the

461
00:19:00,429 --> 00:19:05,529
text-based protocols so you could have

462
00:19:02,289 --> 00:19:07,510
character ranges as well these inputs do

463
00:19:05,529 --> 00:19:10,450
not essentially have to be in ASCII they

464
00:19:07,510 --> 00:19:13,750
could be they are you could actually

465
00:19:10,450 --> 00:19:16,330
have them in hex that's also valid and

466
00:19:13,750 --> 00:19:19,210
then we have different different

467
00:19:16,330 --> 00:19:21,399
combinators for you ain´t or int and we

468
00:19:19,210 --> 00:19:24,640
also have them ranging from 8 to 64 bits

469
00:19:21,399 --> 00:19:26,260
and we also have an integer range that

470
00:19:24,640 --> 00:19:29,380
you could specify then we have a

471
00:19:26,260 --> 00:19:31,000
sequence where you have a sequence or so

472
00:19:29,380 --> 00:19:33,159
like a sequence is really important and

473
00:19:31,000 --> 00:19:35,169
it's really something that we have to

474
00:19:33,159 --> 00:19:37,750
use a lot because when we are converting

475
00:19:35,169 --> 00:19:40,779
like a packet format to a specification

476
00:19:37,750 --> 00:19:42,370
it's really important to have something

477
00:19:40,779 --> 00:19:43,799
that can actually grow combinators one

478
00:19:42,370 --> 00:19:45,789
after the other

479
00:19:43,799 --> 00:19:47,260
then there's the many which is

480
00:19:45,789 --> 00:19:49,950
essentially a clean star which is

481
00:19:47,260 --> 00:19:52,870
basically this that it will run the

482
00:19:49,950 --> 00:19:55,210
Combinator that you provide inside it n

483
00:19:52,870 --> 00:19:57,250
number of times there's no maximum

484
00:19:55,210 --> 00:20:01,779
number for n because a clean star is

485
00:19:57,250 --> 00:20:03,870
just till infinity and there's the

486
00:20:01,779 --> 00:20:06,730
optional field which will basically

487
00:20:03,870 --> 00:20:08,229
check if the character a exists if it

488
00:20:06,730 --> 00:20:13,779
doesn't then it will just ignore it and

489
00:20:08,230 --> 00:20:15,159
moron so let's talk about some

490
00:20:13,779 --> 00:20:16,600
background that's required to actually

491
00:20:15,159 --> 00:20:18,610
understand how we build a parser which

492
00:20:16,600 --> 00:20:20,678
is understanding what application

493
00:20:18,610 --> 00:20:24,219
protocols we are using and why we chose

494
00:20:20,679 --> 00:20:25,690
them so the the important of the the

495
00:20:24,220 --> 00:20:28,450
three big application layer protocols

496
00:20:25,690 --> 00:20:30,789
that we chose were mqtt XMPP and AMQP

497
00:20:28,450 --> 00:20:34,149
it's primarily because our oil and gas

498
00:20:30,789 --> 00:20:37,179
industry partners are using MQTT and

499
00:20:34,149 --> 00:20:39,789
XMPP a lot in the US and they also want

500
00:20:37,179 --> 00:20:41,049
to eventually scale to AMQP because a

501
00:20:39,789 --> 00:20:45,010
lot of cloud providers are already

502
00:20:41,049 --> 00:20:47,110
offering it the MQTT protocol is like

503
00:20:45,010 --> 00:20:49,179
really widely deployed and there are

504
00:20:47,110 --> 00:20:51,309
some very glaring choices that have been

505
00:20:49,179 --> 00:20:54,100
made in the protocol for example the

506
00:20:51,309 --> 00:20:55,510
subscription to the pound sign if you

507
00:20:54,100 --> 00:20:58,750
subscribe to it you can basically get

508
00:20:55,510 --> 00:21:00,610
all the packets from the server and the

509
00:20:58,750 --> 00:21:03,279
protocol is publish/subscribe and you

510
00:21:00,610 --> 00:21:05,320
cannot really figure out who the sender

511
00:21:03,279 --> 00:21:07,760
is without accessing the logs on the

512
00:21:05,320 --> 00:21:10,820
server and TLS is not in

513
00:21:07,760 --> 00:21:12,950
by the specification it's optional these

514
00:21:10,820 --> 00:21:15,110
are some really weird choices that these

515
00:21:12,950 --> 00:21:17,390
de protocol has made I can understand

516
00:21:15,110 --> 00:21:19,129
that because it's essentially targeted

517
00:21:17,390 --> 00:21:21,620
towards really lightweight devices that

518
00:21:19,130 --> 00:21:25,790
cannot do much processing is especially

519
00:21:21,620 --> 00:21:31,659
not crypto by crypto I mean cryptography

520
00:21:25,790 --> 00:21:34,070
not not cryptocurrencies the real crypto

521
00:21:31,660 --> 00:21:37,450
this is this is how the packet format

522
00:21:34,070 --> 00:21:39,560
looks like there's a header there's a

523
00:21:37,450 --> 00:21:41,860
desert remaining length which is the

524
00:21:39,560 --> 00:21:43,850
actual payload and sorry that's the

525
00:21:41,860 --> 00:21:45,469
there's the number of bytes that are

526
00:21:43,850 --> 00:21:46,969
remaining after that so this particular

527
00:21:45,470 --> 00:21:48,380
length field does not take into

528
00:21:46,970 --> 00:21:51,320
consideration what's there before that

529
00:21:48,380 --> 00:21:53,240
and it can range from 1 to 4 bytes in

530
00:21:51,320 --> 00:21:55,669
length and then there's the payload that

531
00:21:53,240 --> 00:21:57,800
follows it and the payload is basically

532
00:21:55,670 --> 00:22:00,770
dependent on the length field before

533
00:21:57,800 --> 00:22:04,010
that the other protocol that we looked

534
00:22:00,770 --> 00:22:06,139
at is XMPP which is XML based and the

535
00:22:04,010 --> 00:22:09,500
specification has been worked over like

536
00:22:06,140 --> 00:22:11,210
over decades so it's a really robust

537
00:22:09,500 --> 00:22:13,790
specification it was used for chart

538
00:22:11,210 --> 00:22:15,680
earlier and that's why I like people

539
00:22:13,790 --> 00:22:19,730
think that it's really good to use and

540
00:22:15,680 --> 00:22:21,950
the specification does enforce TLS and

541
00:22:19,730 --> 00:22:25,640
it also has some really neat features

542
00:22:21,950 --> 00:22:26,720
like authentication and binding but both

543
00:22:25,640 --> 00:22:29,090
are actually optional in the

544
00:22:26,720 --> 00:22:31,270
specification but like in our

545
00:22:29,090 --> 00:22:33,500
implementation we do enforce them and

546
00:22:31,270 --> 00:22:35,210
there have been a lot of security

547
00:22:33,500 --> 00:22:38,060
enhancements that have been suggested to

548
00:22:35,210 --> 00:22:40,430
Inc XMPP and impunity for that matter

549
00:22:38,060 --> 00:22:43,639
but they don't really talk about these

550
00:22:40,430 --> 00:22:45,080
stuff that we are talking about here so

551
00:22:43,640 --> 00:22:47,990
this is how a packet looks like as I

552
00:22:45,080 --> 00:22:51,139
mentioned earlier it's exempt its XML

553
00:22:47,990 --> 00:22:54,350
based so if you notice over here the

554
00:22:51,140 --> 00:22:57,620
field that follows after the username is

555
00:22:54,350 --> 00:22:59,570
actually the the ID that is bound so you

556
00:22:57,620 --> 00:23:01,489
can have the same username that's logged

557
00:22:59,570 --> 00:23:04,100
onto a server through multiple binding

558
00:23:01,490 --> 00:23:05,390
IDs and the packets will get out it -

559
00:23:04,100 --> 00:23:06,919
exactly

560
00:23:05,390 --> 00:23:08,630
so for example if you are logged into

561
00:23:06,920 --> 00:23:12,440
the same server from your phone and from

562
00:23:08,630 --> 00:23:13,940
your laptop if you send it to just the

563
00:23:12,440 --> 00:23:15,320
username it would go it will get

564
00:23:13,940 --> 00:23:16,640
broadcast out to everyone but then if

565
00:23:15,320 --> 00:23:18,530
you want to send it only to your laptop

566
00:23:16,640 --> 00:23:20,950
then you can also specify that in the

567
00:23:18,530 --> 00:23:20,950
binding ID

568
00:23:21,320 --> 00:23:25,668
and QP is like a protocol that is built

569
00:23:23,600 --> 00:23:29,500
as an improvement to impute ET and it

570
00:23:25,669 --> 00:23:29,500
has a bunch of additional features and

571
00:23:29,679 --> 00:23:36,200
when I was scanning short on there are

572
00:23:32,299 --> 00:23:37,970
like or there's almost a million AMQP

573
00:23:36,200 --> 00:23:39,710
brokers that are running but of course

574
00:23:37,970 --> 00:23:42,529
most of them are not implementations

575
00:23:39,710 --> 00:23:45,080
that are empowering IOT it's more of a

576
00:23:42,529 --> 00:23:47,269
message passing protocol so it's quite

577
00:23:45,080 --> 00:23:48,590
popular it's gaining a lot of traction I

578
00:23:47,269 --> 00:23:52,909
mean it has already gained a lot of

579
00:23:48,590 --> 00:23:54,980
traction and the people in the oil and

580
00:23:52,909 --> 00:23:57,169
gas industry think that this is really

581
00:23:54,980 --> 00:23:59,090
useful because in the oil and gas

582
00:23:57,169 --> 00:24:00,710
industry they primarily use Ethernet

583
00:23:59,090 --> 00:24:05,059
cables to connect they don't use like

584
00:24:00,710 --> 00:24:06,350
wireless communications that much so so

585
00:24:05,059 --> 00:24:08,120
at least over there like they think

586
00:24:06,350 --> 00:24:10,668
that's such a reliable bandwidth and

587
00:24:08,120 --> 00:24:12,168
connectivity is like really useful so

588
00:24:10,669 --> 00:24:16,190
what they're like AMQP becomes really

589
00:24:12,169 --> 00:24:18,620
useful um I just wanted to show you what

590
00:24:16,190 --> 00:24:20,000
sort of messages exists in mqp so there

591
00:24:18,620 --> 00:24:24,469
is a connection there's a connection

592
00:24:20,000 --> 00:24:25,610
tune open and so on so this this this

593
00:24:24,470 --> 00:24:27,590
particular diagram will give you an

594
00:24:25,610 --> 00:24:29,508
intuition of what the protocol state

595
00:24:27,590 --> 00:24:30,799
machine should look like and how you can

596
00:24:29,509 --> 00:24:33,080
actually extract a protocol state

597
00:24:30,799 --> 00:24:35,450
machine again this particular thing is

598
00:24:33,080 --> 00:24:37,039
not super clear from the specification

599
00:24:35,450 --> 00:24:38,240
of the MQB protocol itself it's

600
00:24:37,039 --> 00:24:40,158
something that you have to manually

601
00:24:38,240 --> 00:24:45,129
extract after reading through the

602
00:24:40,159 --> 00:24:48,169
specification so let's look at some code

603
00:24:45,129 --> 00:24:52,009
so so far we have we've implemented it

604
00:24:48,169 --> 00:24:55,129
for a lot of protocols and the ones that

605
00:24:52,009 --> 00:24:58,340
we are most proud of the dnp3 c37 and

606
00:24:55,129 --> 00:25:00,620
our iot implementations so the dnp3 NC

607
00:24:58,340 --> 00:25:02,840
37 dot one-minute our SCADA protocols

608
00:25:00,620 --> 00:25:07,989
and those implementations were written

609
00:25:02,840 --> 00:25:10,610
in C and C++ for for various reasons and

610
00:25:07,990 --> 00:25:12,620
the the AMQP implementation that we

611
00:25:10,610 --> 00:25:16,340
worked on like it was written in Python

612
00:25:12,620 --> 00:25:18,549
2.7 and the XMPP and infinity

613
00:25:16,340 --> 00:25:20,689
implementations were written in Ruby so

614
00:25:18,549 --> 00:25:22,460
there are two important components that

615
00:25:20,690 --> 00:25:24,379
we need to actually start building these

616
00:25:22,460 --> 00:25:27,049
passes so first of all we need to know

617
00:25:24,379 --> 00:25:28,309
all the protocol syntax and we also need

618
00:25:27,049 --> 00:25:30,889
to know the overall protocol state

619
00:25:28,309 --> 00:25:32,990
machine so for XMPP how we went about it

620
00:25:30,889 --> 00:25:35,030
was that we had a protocol state machine

621
00:25:32,990 --> 00:25:38,210
and for each state in the state machine

622
00:25:35,030 --> 00:25:39,710
we had a parser that was running it had

623
00:25:38,210 --> 00:25:41,750
a specific parser for that particular

624
00:25:39,710 --> 00:25:43,670
state so once you move from state to

625
00:25:41,750 --> 00:25:47,900
state you had a separate parser for it

626
00:25:43,670 --> 00:25:50,600
and the XMPP implementation specifically

627
00:25:47,900 --> 00:25:53,720
was written in ruby so we used a gem to

628
00:25:50,600 --> 00:25:56,719
actually enable us to enable us to do

629
00:25:53,720 --> 00:25:59,030
the state machine work and we used our

630
00:25:56,720 --> 00:26:02,270
hammer library to actually implement the

631
00:25:59,030 --> 00:26:04,639
parsers itself so this is an example of

632
00:26:02,270 --> 00:26:07,070
how the state machine looks so you can

633
00:26:04,640 --> 00:26:09,230
you can specify a bunch of pre and post

634
00:26:07,070 --> 00:26:10,669
conditions for the transitions and you

635
00:26:09,230 --> 00:26:14,690
can have a bunch of transitions that are

636
00:26:10,670 --> 00:26:17,180
basically events and basically when the

637
00:26:14,690 --> 00:26:22,220
when the transitions occur or parsers

638
00:26:17,180 --> 00:26:24,440
get triggered every time and this is how

639
00:26:22,220 --> 00:26:30,710
the grammar itself translates again I

640
00:26:24,440 --> 00:26:32,900
apologize for the lack of clarity so you

641
00:26:30,710 --> 00:26:35,030
can see over here that you specify the

642
00:26:32,900 --> 00:26:38,150
hex symbol for white spaces double

643
00:26:35,030 --> 00:26:40,580
quotes new lines and so on so you build

644
00:26:38,150 --> 00:26:44,030
ground up and eventually when you have

645
00:26:40,580 --> 00:26:46,350
the entire stream so you have a stream

646
00:26:44,030 --> 00:26:49,520
open tag that takes a sequence

647
00:26:46,350 --> 00:26:49,520
[Music]

648
00:27:28,230 --> 00:27:32,490
which is the UNT 8 of the type and then

649
00:27:31,019 --> 00:27:34,649
you have 2 bytes for the channel which

650
00:27:32,490 --> 00:27:36,960
translates to you in 16 and then you

651
00:27:34,649 --> 00:27:39,539
have 4 bytes for the size which is over

652
00:27:36,960 --> 00:27:41,429
here I get to the and right after and

653
00:27:39,539 --> 00:27:44,039
then you have a sequence of the class

654
00:27:41,429 --> 00:27:46,110
method and a bunch of arguments that are

655
00:27:44,039 --> 00:27:48,269
optional features and then you have an

656
00:27:46,110 --> 00:27:51,029
end frame that is just a C II which is

657
00:27:48,269 --> 00:27:52,649
fixed as per the protocol so this is how

658
00:27:51,029 --> 00:27:54,809
you when you have a packet format it

659
00:27:52,649 --> 00:27:56,309
translates exactly to a parser so this

660
00:27:54,809 --> 00:27:58,620
whole thing would recognize the parser

661
00:27:56,309 --> 00:28:01,529
now coming back to the iron field over

662
00:27:58,620 --> 00:28:03,658
here so there's there's a need for us to

663
00:28:01,529 --> 00:28:05,610
actually read this particular size field

664
00:28:03,659 --> 00:28:08,039
and then make sure that the rest of the

665
00:28:05,610 --> 00:28:09,928
packet is actually that length so that's

666
00:28:08,039 --> 00:28:12,899
why we have an and Combinator which

667
00:28:09,929 --> 00:28:15,149
would actually not not move the parser

668
00:28:12,899 --> 00:28:16,559
pointer past this particular field but

669
00:28:15,149 --> 00:28:19,768
it would consume everything that is

670
00:28:16,559 --> 00:28:22,110
there inside but the the the pointer is

671
00:28:19,769 --> 00:28:24,240
still over here the pointer is still

672
00:28:22,110 --> 00:28:27,479
before that particular iron is executed

673
00:28:24,240 --> 00:28:29,610
so that's why we have to like recognize

674
00:28:27,480 --> 00:28:31,019
size again after that this this

675
00:28:29,610 --> 00:28:33,178
particular Combinator would only make

676
00:28:31,019 --> 00:28:39,690
sure that the length is valid towards

677
00:28:33,179 --> 00:28:41,190
the till the end basically um so as I

678
00:28:39,690 --> 00:28:42,840
mentioned earlier that this is another

679
00:28:41,190 --> 00:28:45,480
protocol that we are actually fairly

680
00:28:42,840 --> 00:28:47,370
proud of and this was one protocol for

681
00:28:45,480 --> 00:28:49,740
which like Lang SEC actually got a lot

682
00:28:47,370 --> 00:28:53,158
of recognition so over here this is the

683
00:28:49,740 --> 00:28:55,710
dnp3 protocol as you can see again like

684
00:28:53,159 --> 00:28:57,419
so this is this is the byte these are

685
00:28:55,710 --> 00:29:00,000
the raw bytes that you see on the wire

686
00:28:57,419 --> 00:29:02,220
and you can see how these bytes actually

687
00:29:00,000 --> 00:29:03,570
translate exactly to code so here I'm

688
00:29:02,220 --> 00:29:05,159
introducing another Combinator called

689
00:29:03,570 --> 00:29:09,750
the token which would basically take the

690
00:29:05,159 --> 00:29:11,610
entire string as it is and then the

691
00:29:09,750 --> 00:29:14,070
length is actually validated over here

692
00:29:11,610 --> 00:29:15,840
in the attr bull which would basically

693
00:29:14,070 --> 00:29:17,490
return a true or false and there's a

694
00:29:15,840 --> 00:29:21,029
method that does the validation which is

695
00:29:17,490 --> 00:29:23,940
validate CRC and there's a validate

696
00:29:21,029 --> 00:29:27,149
length as well towards the end so attr

697
00:29:23,940 --> 00:29:30,240
bull can basically run a method to do a

698
00:29:27,149 --> 00:29:32,070
bunch of validation on your program and

699
00:29:30,240 --> 00:29:33,990
this particular dnp3 implementation is

700
00:29:32,070 --> 00:29:38,460
fully open source and you can definitely

701
00:29:33,990 --> 00:29:41,910
go take a look um so how do we actually

702
00:29:38,460 --> 00:29:43,830
validate these partials that we build so

703
00:29:41,910 --> 00:29:46,860
one important metric that we use is the

704
00:29:43,830 --> 00:29:48,300
timing analysis to make sure that we we

705
00:29:46,860 --> 00:29:50,909
meet the latency requirements of the

706
00:29:48,300 --> 00:29:53,520
protocol itself and we also write a

707
00:29:50,910 --> 00:29:56,820
bunch of unit test case based on CVS

708
00:29:53,520 --> 00:29:59,160
that we see and we also fast our parsers

709
00:29:56,820 --> 00:30:01,620
to make sure that they don't they don't

710
00:29:59,160 --> 00:30:04,560
accept input that we don't that it

711
00:30:01,620 --> 00:30:07,379
shouldn't talking about performance like

712
00:30:04,560 --> 00:30:08,790
we were running them at Asbury pies we

713
00:30:07,380 --> 00:30:11,520
did eventually run them on more

714
00:30:08,790 --> 00:30:14,820
constrained devices but that data is not

715
00:30:11,520 --> 00:30:16,700
yet available to us so on a raspberry pi

716
00:30:14,820 --> 00:30:19,080
we saw that it was in the order of

717
00:30:16,700 --> 00:30:21,780
microseconds for us for the MQTT

718
00:30:19,080 --> 00:30:23,399
protocol and it was in the order of a

719
00:30:21,780 --> 00:30:27,629
few few seconds on the constraint

720
00:30:23,400 --> 00:30:29,880
devices and we also saw that the lines

721
00:30:27,630 --> 00:30:31,320
of code was very reasonable so think

722
00:30:29,880 --> 00:30:33,660
about this particular benefit that you

723
00:30:31,320 --> 00:30:37,110
have of actually making sure that the

724
00:30:33,660 --> 00:30:39,900
packets are fully valid and the lines of

725
00:30:37,110 --> 00:30:41,520
course as code is still like under 50 so

726
00:30:39,900 --> 00:30:43,670
it's not that much of a programmer

727
00:30:41,520 --> 00:30:45,420
effort to actually ask a programmers to

728
00:30:43,670 --> 00:30:49,230
implement these passes in this

729
00:30:45,420 --> 00:30:52,020
particular way and we have we did the

730
00:30:49,230 --> 00:30:54,150
same analysis for MQTT as well where we

731
00:30:52,020 --> 00:30:55,290
found that the CPU time that was

732
00:30:54,150 --> 00:30:56,820
consumed that our power source or

733
00:30:55,290 --> 00:30:59,399
consuming was still in the order of

734
00:30:56,820 --> 00:31:01,610
microseconds and the lines of code were

735
00:30:59,400 --> 00:31:01,610
mass

736
00:31:20,230 --> 00:31:28,640
parser validation and we also first okay

737
00:31:26,360 --> 00:31:32,620
now i'm louder and we also first it the

738
00:31:28,640 --> 00:31:36,140
first our implementations using AFL and

739
00:31:32,620 --> 00:31:37,820
you can see that there were no crashes

740
00:31:36,140 --> 00:31:42,650
and there were very few hands as well

741
00:31:37,820 --> 00:31:45,230
over a period of 24 hours um so this is

742
00:31:42,650 --> 00:31:49,970
another tool that we built which was to

743
00:31:45,230 --> 00:31:51,890
generate some so i believe that most of

744
00:31:49,970 --> 00:31:53,500
us know about know-how fastening works

745
00:31:51,890 --> 00:31:56,360
but I'll still give you a primer so

746
00:31:53,500 --> 00:31:58,130
fuzzing essentially it takes some seed

747
00:31:56,360 --> 00:32:00,800
input which is like a bunch of valid

748
00:31:58,130 --> 00:32:02,929
bunch of valid packets and then it

749
00:32:00,800 --> 00:32:06,620
basically mutates those packets to

750
00:32:02,929 --> 00:32:08,210
generate to basically generate test

751
00:32:06,620 --> 00:32:11,360
cases to actually run your core-drobe

752
00:32:08,210 --> 00:32:15,770
and even if you don't actually give it a

753
00:32:11,360 --> 00:32:17,389
seed it will keep mutating from null but

754
00:32:15,770 --> 00:32:20,590
your your passing technique will

755
00:32:17,390 --> 00:32:23,780
essentially work better when you have

756
00:32:20,590 --> 00:32:28,159
when you have some seed as given as

757
00:32:23,780 --> 00:32:30,399
input and in in our particular example

758
00:32:28,160 --> 00:32:34,850
so in this particular tool that we built

759
00:32:30,400 --> 00:32:36,380
called Hagee we were like using using

760
00:32:34,850 --> 00:32:38,330
the context-free grammars or the parser

761
00:32:36,380 --> 00:32:40,580
Combinator's as a specification and

762
00:32:38,330 --> 00:32:42,800
providing that as an input to this

763
00:32:40,580 --> 00:32:45,290
particular fuzzing tool and our first

764
00:32:42,800 --> 00:32:48,710
tool was essentially only generating all

765
00:32:45,290 --> 00:32:50,210
the valid set of input and we were valid

766
00:32:48,710 --> 00:32:52,010
set of input based on the specification

767
00:32:50,210 --> 00:32:54,380
there was already given and we

768
00:32:52,010 --> 00:32:58,879
essentially fed all this input to Lib

769
00:32:54,380 --> 00:33:01,160
phaser and live was a ram mutated all

770
00:32:58,880 --> 00:33:05,179
these seeds and ran it through the

771
00:33:01,160 --> 00:33:08,420
import so working with Lib father was

772
00:33:05,179 --> 00:33:11,300
interesting for us primarily because we

773
00:33:08,420 --> 00:33:14,260
had collaborators were actually building

774
00:33:11,300 --> 00:33:14,260
this tool and

775
00:33:15,400 --> 00:33:20,150
essentially lopressor does not require a

776
00:33:17,990 --> 00:33:23,000
main method it only requires a target

777
00:33:20,150 --> 00:33:25,610
method which actually takes a data

778
00:33:23,000 --> 00:33:28,610
pointer and it also takes the size of

779
00:33:25,610 --> 00:33:30,889
the input and you basically call your

780
00:33:28,610 --> 00:33:36,260
method over here and it takes these two

781
00:33:30,890 --> 00:33:39,950
arguments and V V essentially converted

782
00:33:36,260 --> 00:33:41,540
our hammer implementations to be so that

783
00:33:39,950 --> 00:33:44,120
we will be able to facet using lip

784
00:33:41,540 --> 00:33:47,510
phaser and where you have a parser input

785
00:33:44,120 --> 00:33:50,989
and then you have it takes two arguments

786
00:33:47,510 --> 00:33:53,060
the same as lip fursat itself and it

787
00:33:50,990 --> 00:33:56,000
basically runs this particular check so

788
00:33:53,060 --> 00:33:57,560
H underscore pass will actually run this

789
00:33:56,000 --> 00:34:00,230
particular data through this particular

790
00:33:57,560 --> 00:34:02,960
parser and the size is also specified so

791
00:34:00,230 --> 00:34:06,290
that it doesn't overshoot the pointer

792
00:34:02,960 --> 00:34:08,360
and then if the result is valid which is

793
00:34:06,290 --> 00:34:10,429
like it's not null we perform a bunch of

794
00:34:08,360 --> 00:34:11,840
actions so this particular method if the

795
00:34:10,429 --> 00:34:14,239
parser is written in this particular way

796
00:34:11,840 --> 00:34:17,030
we can actually provide it as an input

797
00:34:14,239 --> 00:34:19,159
to provide it as an input to live

798
00:34:17,030 --> 00:34:22,190
further itself to fuzz our

799
00:34:19,159 --> 00:34:23,480
implementations and compiling with luffa

800
00:34:22,190 --> 00:34:27,800
so this is something you can again look

801
00:34:23,480 --> 00:34:30,219
up on the tutorial and you basically you

802
00:34:27,800 --> 00:34:32,650
have to use clan with lymph vessel and

803
00:34:30,219 --> 00:34:35,839
you provide a bunch of sanitized

804
00:34:32,650 --> 00:34:38,090
arguments and this particular last one

805
00:34:35,840 --> 00:34:40,490
that you see L hammer and the pkg config

806
00:34:38,090 --> 00:34:46,310
is something that that's how you provide

807
00:34:40,489 --> 00:34:48,229
the path to our hammer library and yeah

808
00:34:46,310 --> 00:34:50,719
then you just run you compiler and you

809
00:34:48,230 --> 00:34:55,210
run and you see a bunch of failed cases

810
00:34:50,719 --> 00:34:58,100
or you see a bunch of sig V's and so on

811
00:34:55,210 --> 00:35:01,610
so that brings me to some concluding

812
00:34:58,100 --> 00:35:04,490
remarks so liesecke is not a way for you

813
00:35:01,610 --> 00:35:05,780
to like be completely sure you cannot be

814
00:35:04,490 --> 00:35:07,790
completely sure you have to face your

815
00:35:05,780 --> 00:35:09,740
program you have to for the good hygiene

816
00:35:07,790 --> 00:35:11,330
but at the end of the day Lansing does

817
00:35:09,740 --> 00:35:13,910
provide our discipline roadmap for

818
00:35:11,330 --> 00:35:15,950
success there's some really exciting

819
00:35:13,910 --> 00:35:16,790
work in the language space that's coming

820
00:35:15,950 --> 00:35:18,770
up soon

821
00:35:16,790 --> 00:35:20,960
there's the DARPA safe Doc's program

822
00:35:18,770 --> 00:35:22,940
that's coming up and then we are also

823
00:35:20,960 --> 00:35:23,190
building a parser generator that's on

824
00:35:22,940 --> 00:35:26,329
top of

825
00:35:23,190 --> 00:35:26,329
[Music]

826
00:36:19,130 --> 00:36:30,030
yeah yeah yeah so you do need to know

827
00:36:28,500 --> 00:36:31,740
the entire protocol to write the parser

828
00:36:30,030 --> 00:36:34,380
but for dnp3 we have one available

829
00:36:31,740 --> 00:36:36,240
already so we have an entire

830
00:36:34,380 --> 00:36:38,100
implementation of dnp3 and it's open

831
00:36:36,240 --> 00:36:39,509
source and it's available and it also

832
00:36:38,100 --> 00:36:46,860
withstood like some state-of-the-art

833
00:36:39,510 --> 00:36:54,480
fuzzing techniques like ages yeah yes

834
00:36:46,860 --> 00:36:58,440
you can both we have implementations of

835
00:36:54,480 --> 00:36:59,790
both and we to implement the application

836
00:36:58,440 --> 00:37:02,580
not just the application layer we also

837
00:36:59,790 --> 00:37:07,529
implement the data link and the IP layer

838
00:37:02,580 --> 00:37:09,480
of the mp3 packets yes it is black box

839
00:37:07,530 --> 00:37:12,180
but we also use ages which is white box

840
00:37:09,480 --> 00:37:16,230
if you know about ages it's a tool built

841
00:37:12,180 --> 00:37:16,740
by Adam Sistrunk Adam preen and Chris

842
00:37:16,230 --> 00:37:19,770
cistern

843
00:37:16,740 --> 00:37:22,439
so that particular tool is white box so

844
00:37:19,770 --> 00:37:24,060
we also use that technique to make sure

845
00:37:22,440 --> 00:37:36,480
that our implementation was correct and

846
00:37:24,060 --> 00:37:37,860
good yeah it's not super different but

847
00:37:36,480 --> 00:37:40,080
we wanted something that would take a

848
00:37:37,860 --> 00:37:41,670
parser Combinator input because that's

849
00:37:40,080 --> 00:37:44,279
the tool that we were using we wanted to

850
00:37:41,670 --> 00:37:45,270
provide our phaser with valid inputs

851
00:37:44,280 --> 00:37:47,850
that were generated from the

852
00:37:45,270 --> 00:37:49,410
specification that we have so that's why

853
00:37:47,850 --> 00:37:52,140
we went with this approach it's not

854
00:37:49,410 --> 00:37:53,609
super different but we wanted to use

855
00:37:52,140 --> 00:38:16,190
this approach because we want it to go

856
00:37:53,610 --> 00:38:16,190
from a parser Combinator to a phaser I

857
00:38:16,580 --> 00:38:29,420
didn't really get a question from here

858
00:38:18,600 --> 00:38:29,420
Peter yeah yeah

859
00:38:46,820 --> 00:38:54,240
okay so it's it's actually unrelated to

860
00:38:51,330 --> 00:38:56,220
that so it's like what you're saying is

861
00:38:54,240 --> 00:38:59,459
like a parser for a programming language

862
00:38:56,220 --> 00:39:02,279
itself and what what I'm I'm advocating

863
00:38:59,460 --> 00:39:04,550
for is a parser for an input language so

864
00:39:02,280 --> 00:39:07,320
for example when you have a program like

865
00:39:04,550 --> 00:39:09,420
let's say an amputee client that

866
00:39:07,320 --> 00:39:12,150
basically sends a message to the server

867
00:39:09,420 --> 00:39:14,040
and it receives a message back so when

868
00:39:12,150 --> 00:39:16,050
the program receives a message back you

869
00:39:14,040 --> 00:39:17,670
receive it on a socket and then you

870
00:39:16,050 --> 00:39:18,960
basically do some processing or you do

871
00:39:17,670 --> 00:39:22,020
something to the input and then you

872
00:39:18,960 --> 00:39:23,310
start so you first see the input and you

873
00:39:22,020 --> 00:39:25,980
want to make sure that it's valid and

874
00:39:23,310 --> 00:39:28,770
then you start basically extracting data

875
00:39:25,980 --> 00:39:30,150
out of the input right so by a parser

876
00:39:28,770 --> 00:39:34,980
for an input language I'm advocating

877
00:39:30,150 --> 00:39:37,290
that the the the bulletproof field that

878
00:39:34,980 --> 00:39:39,720
you have that it sees and make sure that

879
00:39:37,290 --> 00:39:41,370
the input is valid is what the parser is

880
00:39:39,720 --> 00:39:56,459
and it should be extracted from the

881
00:39:41,370 --> 00:39:59,400
formal specification yeah yeah yeah it

882
00:39:56,460 --> 00:40:00,810
can so the question was cannot be used

883
00:39:59,400 --> 00:40:04,050
with rest api is yeah of course

884
00:40:00,810 --> 00:40:06,779
so the the assumption here is that the

885
00:40:04,050 --> 00:40:08,610
rest API libraries that we use do follow

886
00:40:06,780 --> 00:40:10,710
good hygiene for validating the input

887
00:40:08,610 --> 00:40:12,270
and that's not always true so you could

888
00:40:10,710 --> 00:40:15,510
follow this particular approach to make

889
00:40:12,270 --> 00:40:17,790
sure that your REST API the library that

890
00:40:15,510 --> 00:40:19,350
you used to provide REST API is actually

891
00:40:17,790 --> 00:40:24,150
validates the input and make sure it's

892
00:40:19,350 --> 00:40:26,160
correct yeah we have said we have

893
00:40:24,150 --> 00:40:28,260
support we don't have it for JavaScript

894
00:40:26,160 --> 00:40:33,149
yet but we do have it for Java Python

895
00:40:28,260 --> 00:40:36,170
Ruby dotnet also and apart from C and

896
00:40:33,150 --> 00:40:36,170
C++ and Python

897
00:40:45,310 --> 00:40:57,660
[Music]

898
00:40:48,200 --> 00:40:59,549
so you need to yeah yeah so you you do

899
00:40:57,660 --> 00:41:01,618
not need to specify it in s and syntax

900
00:40:59,550 --> 00:41:03,599
but you need to specify in the parser

901
00:41:01,619 --> 00:41:06,960
Combinator syntax which is very similar

902
00:41:03,599 --> 00:41:09,210
to a SN syntax so the thing is that a SN

903
00:41:06,960 --> 00:41:11,369
code generators in the past have had a

904
00:41:09,210 --> 00:41:12,869
lot of under British themselves right so

905
00:41:11,369 --> 00:41:15,119
that's why we didn't want to go the SN

906
00:41:12,869 --> 00:41:17,670
where because a SN has been used to like

907
00:41:15,119 --> 00:41:19,980
extract cryptographic programs and

908
00:41:17,670 --> 00:41:21,359
cryptographic libraries and they have

909
00:41:19,980 --> 00:41:23,220
seen a lot of vulnerabilities in the

910
00:41:21,359 --> 00:41:25,049
past so we didn't want to go in the s

911
00:41:23,220 --> 00:41:31,848
and one direction and we chose our own

912
00:41:25,050 --> 00:41:34,500
posture dominated syntax that's it

913
00:41:31,849 --> 00:41:36,599
thank you everyone this is my contact

914
00:41:34,500 --> 00:41:38,700
information do you shoot out an email if

915
00:41:36,599 --> 00:41:41,850
you have any more questions thank you

916
00:41:38,700 --> 00:41:41,850
[Applause]

