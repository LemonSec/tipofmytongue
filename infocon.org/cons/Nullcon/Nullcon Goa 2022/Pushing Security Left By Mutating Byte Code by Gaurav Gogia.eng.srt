1
00:00:04,700 --> 00:00:08,160
hello uh good afternoon everyone

2
00:00:08,160 --> 00:00:10,500
so as she has already described my name

3
00:00:10,500 --> 00:00:12,420
is gaurav and I work in tenable a little

4
00:00:12,420 --> 00:00:14,219
bit more about me I like watching anime

5
00:00:14,219 --> 00:00:15,900
and I like uh exploring different

6
00:00:15,900 --> 00:00:19,680
Cuisines so the so the lunch and

7
00:00:19,680 --> 00:00:21,180
breakfast here was really fantastic I

8
00:00:21,180 --> 00:00:23,100
got to try many different things this

9
00:00:23,100 --> 00:00:25,439
was so that was that was really amazing

10
00:00:25,439 --> 00:00:28,320
also the previous talks which which I'll

11
00:00:28,320 --> 00:00:32,220
be referencing in my in my in my

12
00:00:32,220 --> 00:00:35,040
upcoming slides so let's just uh let's

13
00:00:35,040 --> 00:00:37,020
just continue right and a little bit

14
00:00:37,020 --> 00:00:39,960
more about me uh uh but I do a little

15
00:00:39,960 --> 00:00:42,300
bit of I do devsecops at tenable so it's

16
00:00:42,300 --> 00:00:44,399
mostly adverse emulation and then

17
00:00:44,399 --> 00:00:46,739
writing signatures essentially policy

18
00:00:46,739 --> 00:00:49,160
has code

19
00:00:49,200 --> 00:00:52,559
so for this specific talk the agenda is

20
00:00:52,559 --> 00:00:55,860
what is mutant so mutant is is a

21
00:00:55,860 --> 00:00:57,899
programming language we'll see about it

22
00:00:57,899 --> 00:00:59,160
we'll talk about it we'll have a live

23
00:00:59,160 --> 00:01:00,539
demo and

24
00:01:00,539 --> 00:01:02,879
maybe a little bit of live coding

25
00:01:02,879 --> 00:01:05,580
what does it do and where where are we

26
00:01:05,580 --> 00:01:07,680
lagging right now I mean within the

27
00:01:07,680 --> 00:01:09,540
mutants context

28
00:01:09,540 --> 00:01:11,700
what does the future hold what do we do

29
00:01:11,700 --> 00:01:14,400
what do we want to do after this like

30
00:01:14,400 --> 00:01:18,140
what more can we add to it

31
00:01:19,520 --> 00:01:21,960
so as I said

32
00:01:21,960 --> 00:01:23,640
um through mutant I wanted to push

33
00:01:23,640 --> 00:01:27,060
security completely to the left

34
00:01:27,060 --> 00:01:29,340
by pushing left I mean pushing it left

35
00:01:29,340 --> 00:01:31,619
in terms of software development life

36
00:01:31,619 --> 00:01:33,180
cycle

37
00:01:33,180 --> 00:01:36,420
so from from the left well from your

38
00:01:36,420 --> 00:01:38,700
perspective this is left right

39
00:01:38,700 --> 00:01:40,200
from from the left

40
00:01:40,200 --> 00:01:43,079
it's uh we start designing the software

41
00:01:43,079 --> 00:01:44,939
whatever we want to build and then we

42
00:01:44,939 --> 00:01:47,460
build it and then we deploy it with we

43
00:01:47,460 --> 00:01:50,280
test it and then it goes into production

44
00:01:50,280 --> 00:01:52,740
traditionally through runtime security

45
00:01:52,740 --> 00:01:55,680
we check okay maybe through bug Bounty

46
00:01:55,680 --> 00:01:57,899
programs we find out XYZ application has

47
00:01:57,899 --> 00:02:00,060
ABC vulnerability maybe it maybe it is

48
00:02:00,060 --> 00:02:02,040
vulnerable to xss or maybe something

49
00:02:02,040 --> 00:02:04,079
else then if we have to mitigate it we

50
00:02:04,079 --> 00:02:05,820
have to go all the way back

51
00:02:05,820 --> 00:02:08,160
and then we have to fix it this takes a

52
00:02:08,160 --> 00:02:11,160
lot of time and time is money

53
00:02:11,160 --> 00:02:13,920
so here I want to push security so far

54
00:02:13,920 --> 00:02:15,360
to the left that the developer does not

55
00:02:15,360 --> 00:02:16,739
have to worry about it they only need to

56
00:02:16,739 --> 00:02:19,020
write the business logic how do I do it

57
00:02:19,020 --> 00:02:20,580
and let's see

58
00:02:20,580 --> 00:02:22,680
so

59
00:02:22,680 --> 00:02:26,099
I essentially try to add encryption at

60
00:02:26,099 --> 00:02:28,560
the compile time and the runtime but

61
00:02:28,560 --> 00:02:30,180
we'll get to those features

62
00:02:30,180 --> 00:02:31,860
other features include cross compilation

63
00:02:31,860 --> 00:02:33,480
constant obfuscation

64
00:02:33,480 --> 00:02:35,819
and instead of just talking about it

65
00:02:35,819 --> 00:02:39,260
let's just see how it all works

66
00:02:39,300 --> 00:02:41,640
so we have some sample code but it

67
00:02:41,640 --> 00:02:44,839
started something more basic

68
00:02:45,240 --> 00:02:48,399
[Music]

69
00:02:53,660 --> 00:02:56,580
if you want to write something in mutant

70
00:02:56,580 --> 00:02:58,800
you can simply use the use in the

71
00:02:58,800 --> 00:03:01,019
inbuilt function ports and you can

72
00:03:01,019 --> 00:03:03,800
compile it here

73
00:03:08,400 --> 00:03:11,099
and it generates

74
00:03:11,099 --> 00:03:15,599
a bicode now I like to call it the debug

75
00:03:15,599 --> 00:03:17,879
version of our company of our compiled

76
00:03:17,879 --> 00:03:19,099
uh

77
00:03:19,099 --> 00:03:22,200
of I'd like to call it a different I

78
00:03:22,200 --> 00:03:23,819
like to call it a different version of

79
00:03:23,819 --> 00:03:25,140
our source code

80
00:03:25,140 --> 00:03:27,239
because essentially you you still need

81
00:03:27,239 --> 00:03:28,739
the mutant to be installed here it's

82
00:03:28,739 --> 00:03:31,860
going to run the mutant virtual machine

83
00:03:31,860 --> 00:03:33,980
right

84
00:03:36,480 --> 00:03:39,060
it runs you can you can simply copy it

85
00:03:39,060 --> 00:03:40,799
over to the virtual machine it will work

86
00:03:40,799 --> 00:03:43,040
there

87
00:04:00,180 --> 00:04:01,920
okay so while the while the virtual

88
00:04:01,920 --> 00:04:03,180
machine starts

89
00:04:03,180 --> 00:04:04,799
I want to talk about constant

90
00:04:04,799 --> 00:04:07,760
obfuscation here

91
00:04:10,140 --> 00:04:12,840
when I say constant obfuscation I am

92
00:04:12,840 --> 00:04:15,060
talking about

93
00:04:15,060 --> 00:04:17,760
these

94
00:04:17,760 --> 00:04:22,159
whatever data you add in your variables

95
00:04:27,240 --> 00:04:29,400
this is your constant

96
00:04:29,400 --> 00:04:31,620
is it is it is it visible or should I

97
00:04:31,620 --> 00:04:33,479
increase the font

98
00:04:33,479 --> 00:04:35,460
okay

99
00:04:35,460 --> 00:04:38,160
uh in the back is it visible okay okay

100
00:04:38,160 --> 00:04:41,000
great thank you

101
00:04:49,080 --> 00:04:51,320
now

102
00:04:51,320 --> 00:04:53,639
I think it would be a better idea if we

103
00:04:53,639 --> 00:04:55,320
just move forward with a with a better

104
00:04:55,320 --> 00:05:00,500
example in this case let's just call it

105
00:05:10,320 --> 00:05:12,860
right

106
00:05:13,020 --> 00:05:15,300
and now I'm going to demo cross

107
00:05:15,300 --> 00:05:17,900
compilation

108
00:05:22,139 --> 00:05:24,300
so if I want to build for Windows

109
00:05:24,300 --> 00:05:26,100
because right now I'm on Windows I don't

110
00:05:26,100 --> 00:05:27,900
need to specify any other options we

111
00:05:27,900 --> 00:05:29,280
just need to give it a release command

112
00:05:29,280 --> 00:05:31,919
and and our source code file which is

113
00:05:31,919 --> 00:05:35,060
Vault dot mut

114
00:05:35,400 --> 00:05:36,780
it will take a couple of seconds to

115
00:05:36,780 --> 00:05:38,400
generate our uh

116
00:05:38,400 --> 00:05:40,979
file compile file and it's here

117
00:05:40,979 --> 00:05:44,479
let's see if it really works

118
00:05:52,740 --> 00:05:55,979
and it indeed works

119
00:05:55,979 --> 00:05:59,360
but is it really of course it is a pe32

120
00:05:59,360 --> 00:06:03,419
executable but we can always verify

121
00:06:03,419 --> 00:06:07,698
so here the WSL can help me

122
00:06:12,360 --> 00:06:14,419
successfully generated a PE 32

123
00:06:14,419 --> 00:06:16,860
executable because we are on Windows but

124
00:06:16,860 --> 00:06:20,520
we can always generate an elf file

125
00:06:20,520 --> 00:06:23,220
all we have to do is specify which

126
00:06:23,220 --> 00:06:26,720
operating system we need to use

127
00:06:32,639 --> 00:06:35,660
and it's done

128
00:06:38,699 --> 00:06:44,580
we have generated an else binary

129
00:06:47,759 --> 00:06:50,100
now when I talk about cross compilation

130
00:06:50,100 --> 00:06:51,060
here

131
00:06:51,060 --> 00:06:53,940
as I mentioned either we can generate a

132
00:06:53,940 --> 00:06:55,139
byte code

133
00:06:55,139 --> 00:06:58,020
or we can generate a release binary we

134
00:06:58,020 --> 00:07:00,060
just saw all these right

135
00:07:00,060 --> 00:07:02,280
you can you can come you can compile the

136
00:07:02,280 --> 00:07:05,299
just Vault file

137
00:07:12,960 --> 00:07:14,100
and

138
00:07:14,100 --> 00:07:16,680
this is the byte code that you get here

139
00:07:16,680 --> 00:07:19,199
you you get our header mut and the

140
00:07:19,199 --> 00:07:20,940
footer a and t

141
00:07:20,940 --> 00:07:23,400
this help us in identifying that this is

142
00:07:23,400 --> 00:07:26,160
indeed a mutant compiled byte code

143
00:07:26,160 --> 00:07:29,220
bytecode object file we can generate a

144
00:07:29,220 --> 00:07:30,419
release binary as well just like we

145
00:07:30,419 --> 00:07:33,120
noticed but we can also generate a

146
00:07:33,120 --> 00:07:34,680
bytecode object file

147
00:07:34,680 --> 00:07:37,020
try to think of it as something that you

148
00:07:37,020 --> 00:07:40,860
would do with Java right Java runs runs

149
00:07:40,860 --> 00:07:44,099
in jvm and mute entrance in MVM Java

150
00:07:44,099 --> 00:07:45,840
virtual machine mute and virtual machine

151
00:07:45,840 --> 00:07:48,660
also why do I call it mutant because I'm

152
00:07:48,660 --> 00:07:53,240
mutating the byte code in one time

153
00:07:54,300 --> 00:07:56,759
this part you see right here this is

154
00:07:56,759 --> 00:07:59,099
your this is this is all of your byte

155
00:07:59,099 --> 00:08:01,979
code this is the compiled byte code

156
00:08:01,979 --> 00:08:04,860
while this section is just the hash it's

157
00:08:04,860 --> 00:08:08,840
for in it's to verify in integrity

158
00:08:10,680 --> 00:08:13,440
but maybe we want to see whether it

159
00:08:13,440 --> 00:08:14,940
really works or not does enter into

160
00:08:14,940 --> 00:08:17,639
Integrity checks and really work here so

161
00:08:17,639 --> 00:08:19,860
I'll try to modify this bytecode object

162
00:08:19,860 --> 00:08:21,419
file a little bit

163
00:08:21,419 --> 00:08:24,258
and let's see

164
00:08:25,020 --> 00:08:28,140
[Music]

165
00:08:33,260 --> 00:08:35,700
so it cannot identify the file because

166
00:08:35,700 --> 00:08:38,099
we have tampered with the file

167
00:08:38,099 --> 00:08:41,399
and if I restart the changes that I made

168
00:08:41,399 --> 00:08:44,479
it works just fine

169
00:08:50,880 --> 00:08:52,320
of course we can also generate the

170
00:08:52,320 --> 00:08:54,180
executable binary we have already seen

171
00:08:54,180 --> 00:08:55,740
that it can generate a binary for

172
00:08:55,740 --> 00:08:58,740
Windows but it can it can and it also it

173
00:08:58,740 --> 00:09:00,180
can also generate a binary file Linux

174
00:09:00,180 --> 00:09:02,339
but it can also work on your Android

175
00:09:02,339 --> 00:09:04,620
devices but do the Android devices use

176
00:09:04,620 --> 00:09:08,160
they run on Linux and and most and a lot

177
00:09:08,160 --> 00:09:11,540
of devices might use

178
00:09:11,600 --> 00:09:14,820
architecture maybe um 64 maybe um 32

179
00:09:14,820 --> 00:09:18,360
some of them may use AMD 64 but let's

180
00:09:18,360 --> 00:09:20,640
try compiling it for r

181
00:09:20,640 --> 00:09:23,640
m64.

182
00:09:49,860 --> 00:09:52,080
and as you can see we have indeed

183
00:09:52,080 --> 00:09:56,120
generated an arm executable here

184
00:09:56,339 --> 00:09:58,560
so this is a cross compilation part how

185
00:09:58,560 --> 00:10:00,240
you can cross compile from Windows to

186
00:10:00,240 --> 00:10:01,980
Linux of course it will work vice versa

187
00:10:01,980 --> 00:10:03,720
as well if you use mutant on Linux you

188
00:10:03,720 --> 00:10:05,940
can compile it for Windows or Mac or

189
00:10:05,940 --> 00:10:09,060
Android or essentially you can compile

190
00:10:09,060 --> 00:10:11,040
it from from any machine to any Target

191
00:10:11,040 --> 00:10:13,399
machine

192
00:10:19,680 --> 00:10:23,160
constant of obfuscation now this is

193
00:10:23,160 --> 00:10:25,380
something where we need to debug a

194
00:10:25,380 --> 00:10:27,959
little bit to see what's going on and

195
00:10:27,959 --> 00:10:29,700
here I will try to explain what I meant

196
00:10:29,700 --> 00:10:32,880
by a debug or a debug debug mode in

197
00:10:32,880 --> 00:10:34,860
mutant now you can either have a release

198
00:10:34,860 --> 00:10:37,320
binary which is a self-contained with

199
00:10:37,320 --> 00:10:39,060
with the runtime and everything of a

200
00:10:39,060 --> 00:10:41,160
self package binary you can send it

201
00:10:41,160 --> 00:10:42,540
anywhere you can use it anyway it's just

202
00:10:42,540 --> 00:10:43,980
it's just a binary it's just a compa

203
00:10:43,980 --> 00:10:45,779
it's just an executable file

204
00:10:45,779 --> 00:10:48,240
or you can have a debug file that is

205
00:10:48,240 --> 00:10:50,279
that's that object file now that object

206
00:10:50,279 --> 00:10:52,380
file is dependent upon mutant

207
00:10:52,380 --> 00:10:54,420
it needs some mutant version virtual

208
00:10:54,420 --> 00:10:57,240
machine so you need uh so you you need

209
00:10:57,240 --> 00:10:59,279
Newton to be installed there for that

210
00:10:59,279 --> 00:11:00,120
one

211
00:11:00,120 --> 00:11:01,980
release binaries don't need it because

212
00:11:01,980 --> 00:11:05,040
they are self-contained and they contain

213
00:11:05,040 --> 00:11:06,839
the mutant version motion inside of them

214
00:11:06,839 --> 00:11:09,680
it's just like how

215
00:11:09,680 --> 00:11:11,820
dotnet.net code generates their

216
00:11:11,820 --> 00:11:14,700
self-contained single binaries they

217
00:11:14,700 --> 00:11:17,579
package they package the dot net runtime

218
00:11:17,579 --> 00:11:20,700
within the by necessary generating or go

219
00:11:20,700 --> 00:11:22,980
does something does something uh similar

220
00:11:22,980 --> 00:11:25,800
they pack and it packages the runtime

221
00:11:25,800 --> 00:11:29,120
within within the binaries

222
00:11:34,680 --> 00:11:38,279
is this part visible uh where my mouse

223
00:11:38,279 --> 00:11:39,540
pointer is because this might be a

224
00:11:39,540 --> 00:11:41,519
little bit too small and I cannot really

225
00:11:41,519 --> 00:11:44,720
change the size here

226
00:11:48,060 --> 00:11:50,160
so let's try to debug it let me see if

227
00:11:50,160 --> 00:11:53,480
we have it okay we have it here

228
00:12:01,860 --> 00:12:04,140
so this demo actually explains two

229
00:12:04,140 --> 00:12:06,839
things first will be a constant

230
00:12:06,839 --> 00:12:08,399
obfuscation and second will be the

231
00:12:08,399 --> 00:12:11,040
runtime and encryption we have this is

232
00:12:11,040 --> 00:12:12,420
compile time encryption this is

233
00:12:12,420 --> 00:12:13,980
encrypted by code

234
00:12:13,980 --> 00:12:17,279
right but when we read it it first the

235
00:12:17,279 --> 00:12:19,440
first the entire compiled bytecode and

236
00:12:19,440 --> 00:12:21,839
gets decrypted and then individual

237
00:12:21,839 --> 00:12:23,579
instructions have to be decrypted only

238
00:12:23,579 --> 00:12:25,320
when they have to be used

239
00:12:25,320 --> 00:12:28,680
and we'll see how that works

240
00:12:28,680 --> 00:12:31,260
so right as I said I already mentioned

241
00:12:31,260 --> 00:12:33,360
uh this compile time encryption we have

242
00:12:33,360 --> 00:12:35,519
compiled our object on code and this is

243
00:12:35,519 --> 00:12:37,800
right here this is a compiled compiled

244
00:12:37,800 --> 00:12:40,579
encrypted bytecode

245
00:12:41,040 --> 00:12:43,680
as for runtime runtime instructions

246
00:12:43,680 --> 00:12:45,839
runtime encryption individual

247
00:12:45,839 --> 00:12:48,180
instructions or rather individual byte

248
00:12:48,180 --> 00:12:49,260
code

249
00:12:49,260 --> 00:12:50,820
um so a little bit of theory here what

250
00:12:50,820 --> 00:12:53,519
I'm trying to do is we have think of it

251
00:12:53,519 --> 00:12:55,800
as three uh link officer think of them

252
00:12:55,800 --> 00:12:57,899
as three states that you have

253
00:12:57,899 --> 00:13:00,959
first is pre-execution State second is

254
00:13:00,959 --> 00:13:04,380
during execution or execute execution

255
00:13:04,380 --> 00:13:06,959
State and the third is post execution

256
00:13:06,959 --> 00:13:08,339
state

257
00:13:08,339 --> 00:13:10,680
so first you have the pre-execution

258
00:13:10,680 --> 00:13:12,060
state here

259
00:13:12,060 --> 00:13:14,940
the instruction is encrypted then you go

260
00:13:14,940 --> 00:13:16,860
to the next and next state

261
00:13:16,860 --> 00:13:20,040
it's the execution state right now byte

262
00:13:20,040 --> 00:13:22,019
code has to run or the instruction has

263
00:13:22,019 --> 00:13:25,079
to run so when it has to run it's it

264
00:13:25,079 --> 00:13:26,579
needs to be decrypted so it gets

265
00:13:26,579 --> 00:13:28,800
decrypted when it's done doing its part

266
00:13:28,800 --> 00:13:30,959
when it when we have received the data

267
00:13:30,959 --> 00:13:33,000
open whatever we have to do when it's

268
00:13:33,000 --> 00:13:35,220
done executing we could we go to the

269
00:13:35,220 --> 00:13:37,320
Post execution State doing the post

270
00:13:37,320 --> 00:13:40,139
execution state it gets encrypted again

271
00:13:40,139 --> 00:13:43,260
and we'll see all this will will debug

272
00:13:43,260 --> 00:13:45,660
our program because we want to see how

273
00:13:45,660 --> 00:13:47,820
exactly that virtual machine is working

274
00:13:47,820 --> 00:13:49,740
we want to see the internals obviously

275
00:13:49,740 --> 00:13:52,620
this is an open source project so and so

276
00:13:52,620 --> 00:13:54,720
everyone will be able to see it also

277
00:13:54,720 --> 00:13:56,519
just a side note um

278
00:13:56,519 --> 00:13:59,519
uh so I was speaking to one of the

279
00:13:59,519 --> 00:14:02,220
speakers before and uh they explained it

280
00:14:02,220 --> 00:14:05,700
to me that this is this is how the newer

281
00:14:05,700 --> 00:14:07,680
works if you have heard of them so

282
00:14:07,680 --> 00:14:09,779
denevo adds anti-temper anti-anti

283
00:14:09,779 --> 00:14:12,000
privacy technology to games it's very

284
00:14:12,000 --> 00:14:14,760
all closed Source very proprietary so

285
00:14:14,760 --> 00:14:18,240
this is uh the new work the newer Works

286
00:14:18,240 --> 00:14:19,920
in a similar way they are constantly

287
00:14:19,920 --> 00:14:22,019
encrypted encrypting and decrypting

288
00:14:22,019 --> 00:14:24,120
instructions that go to the

289
00:14:24,120 --> 00:14:27,420
uh CPU so it becomes harder for someone

290
00:14:27,420 --> 00:14:29,519
to reverse engineer the games here it

291
00:14:29,519 --> 00:14:31,260
becomes harder for reverse into reverse

292
00:14:31,260 --> 00:14:33,240
engineer any applications written in

293
00:14:33,240 --> 00:14:35,660
mutant

294
00:15:03,199 --> 00:15:06,060
we get the instruction we decrypt it we

295
00:15:06,060 --> 00:15:07,860
get the op code out of it

296
00:15:07,860 --> 00:15:11,160
and then we encrypt it again

297
00:15:11,160 --> 00:15:13,740
this is to ensure that if you need the

298
00:15:13,740 --> 00:15:16,740
op code that is only that that can only

299
00:15:16,740 --> 00:15:18,779
that should only be done during the

300
00:15:18,779 --> 00:15:20,760
decrypted state so

301
00:15:20,760 --> 00:15:22,500
this should only affect maybe a couple

302
00:15:22,500 --> 00:15:25,519
of clock Cycles

303
00:15:31,380 --> 00:15:34,199
every time I I push an object onto the

304
00:15:34,199 --> 00:15:37,320
stack it is it has to be encrypted

305
00:15:37,320 --> 00:15:39,480
now the stack will contain our compiled

306
00:15:39,480 --> 00:15:42,899
functions our constants well I call

307
00:15:42,899 --> 00:15:45,240
these variables constants because that

308
00:15:45,240 --> 00:15:48,720
because as long as during the current

309
00:15:48,720 --> 00:15:51,480
execution phase that specific variables

310
00:15:51,480 --> 00:15:54,480
data does not change it only changes in

311
00:15:54,480 --> 00:15:57,120
us in a different execution context so

312
00:15:57,120 --> 00:16:00,660
think of these constants as uh constants

313
00:16:00,660 --> 00:16:02,519
to be

314
00:16:02,519 --> 00:16:05,639
scoped by time or or the or the

315
00:16:05,639 --> 00:16:08,540
execution context

316
00:16:10,079 --> 00:16:12,660
and let's see what constants do we have

317
00:16:12,660 --> 00:16:14,940
or I think we are still adding them to

318
00:16:14,940 --> 00:16:17,300
the stack

319
00:16:17,880 --> 00:16:20,060
foreign

320
00:16:24,560 --> 00:16:27,800
function here

321
00:16:31,019 --> 00:16:33,540
while all the constants are encrypted

322
00:16:33,540 --> 00:16:34,800
objects

323
00:16:34,800 --> 00:16:38,579
I hope this yeah it looks visible enough

324
00:16:38,579 --> 00:16:41,399
all of these constants are encrypted we

325
00:16:41,399 --> 00:16:43,320
are in memory this is running right now

326
00:16:43,320 --> 00:16:45,420
we are not in the disk this is all in

327
00:16:45,420 --> 00:16:47,220
all in the memory

328
00:16:47,220 --> 00:16:49,380
we'll see a better example other than

329
00:16:49,380 --> 00:16:52,040
this debugging

330
00:17:12,359 --> 00:17:16,260
let's compile it again for Linux for

331
00:17:16,260 --> 00:17:18,900
Linux AMD 64 and let me just remove that

332
00:17:18,900 --> 00:17:21,179
file because I'm going to copy to the

333
00:17:21,179 --> 00:17:22,679
virtual machine where I'm going to run

334
00:17:22,679 --> 00:17:24,860
it

335
00:17:33,419 --> 00:17:35,660
foreign

336
00:17:41,760 --> 00:17:44,760
file

337
00:17:55,860 --> 00:17:59,400
also just for fun and let's see if it

338
00:17:59,400 --> 00:18:01,919
has the hard coded credentials or not we

339
00:18:01,919 --> 00:18:04,140
have a situation where we want to get

340
00:18:04,140 --> 00:18:06,539
get in somewhere right and the secret is

341
00:18:06,539 --> 00:18:09,240
circuit is 42 because the answer to life

342
00:18:09,240 --> 00:18:12,440
is apparently 42.

343
00:18:24,600 --> 00:18:26,600
um

344
00:18:28,820 --> 00:18:31,380
so we could not find it because well

345
00:18:31,380 --> 00:18:33,240
it's encrypted so therefore we could not

346
00:18:33,240 --> 00:18:35,340
find it within the strings in in that

347
00:18:35,340 --> 00:18:36,360
binary

348
00:18:36,360 --> 00:18:38,940
right now it's on disk so this verifies

349
00:18:38,940 --> 00:18:41,039
that yes compile time encryption works

350
00:18:41,039 --> 00:18:43,200
but we want to see this in memory so

351
00:18:43,200 --> 00:18:45,000
let's go over to our into our virtual

352
00:18:45,000 --> 00:18:46,980
machine and we will copy it there we'll

353
00:18:46,980 --> 00:18:49,799
capture memory and out of that uh

354
00:18:49,799 --> 00:18:51,840
captured memory we'll see whether

355
00:18:51,840 --> 00:18:53,460
whether we are able to find the secret

356
00:18:53,460 --> 00:18:55,740
is 42 or not

357
00:18:55,740 --> 00:18:58,260
also I got this idea of capturing memory

358
00:18:58,260 --> 00:19:00,840
from from one of the speakers here so

359
00:19:00,840 --> 00:19:02,220
um what I'm trying to say is this is an

360
00:19:02,220 --> 00:19:04,140
amazing conference and and some of the

361
00:19:04,140 --> 00:19:07,200
some of the ideas and uh that I got like

362
00:19:07,200 --> 00:19:10,200
how how better I can do how else I can

363
00:19:10,200 --> 00:19:13,320
test mutant came came from or came from

364
00:19:13,320 --> 00:19:15,960
talking to people so it will be a great

365
00:19:15,960 --> 00:19:18,600
it will be great so it's one of uh so

366
00:19:18,600 --> 00:19:20,400
it's one of the perks of networking here

367
00:19:20,400 --> 00:19:22,799
you get many amazing ideas and let's see

368
00:19:22,799 --> 00:19:25,520
how it holds up

369
00:19:25,919 --> 00:19:30,320
so we can copy it from here and

370
00:19:57,900 --> 00:20:01,700
we'll need two terminal windows

371
00:20:02,700 --> 00:20:04,820
okay

372
00:20:13,380 --> 00:20:15,900
let's make sure it's executable and then

373
00:20:15,900 --> 00:20:18,059
let's run it

374
00:20:18,059 --> 00:20:20,580
so this program is running right now and

375
00:20:20,580 --> 00:20:23,539
I'm going to capture memory

376
00:20:24,780 --> 00:20:27,360
I'm using avml it's a Microsoft

377
00:20:27,360 --> 00:20:30,360
Microsoft project uh so you don't have

378
00:20:30,360 --> 00:20:32,100
to compile a kernel module to capture

379
00:20:32,100 --> 00:20:34,200
memory it's really easy it's written

380
00:20:34,200 --> 00:20:36,120
interest it's amazing uh do check it out

381
00:20:36,120 --> 00:20:39,500
if you are interested in memory for n6

382
00:20:41,580 --> 00:20:43,080
and it's going to take a couple of

383
00:20:43,080 --> 00:20:45,360
seconds to capture all the ram that we

384
00:20:45,360 --> 00:20:48,799
have here and it's done

385
00:20:52,380 --> 00:20:54,059
since I was using root I have to change

386
00:20:54,059 --> 00:20:57,799
the ownership so I can access this file

387
00:20:59,400 --> 00:21:03,080
and let's grab all the strings

388
00:21:10,880 --> 00:21:12,780
it's going to take a couple of seconds

389
00:21:12,780 --> 00:21:14,580
it's like 2GB of memory that's going

390
00:21:14,580 --> 00:21:16,260
going through

391
00:21:16,260 --> 00:21:19,160
foreign

392
00:21:21,740 --> 00:21:24,299
string file and it's done now so we're

393
00:21:24,299 --> 00:21:27,500
going to get grab through it

394
00:21:35,400 --> 00:21:37,620
let's verify that this is indeed the

395
00:21:37,620 --> 00:21:40,440
string we should be looking for

396
00:21:40,440 --> 00:21:44,280
and it is if it is 42 let's see if we

397
00:21:44,280 --> 00:21:45,900
can find it

398
00:21:45,900 --> 00:21:48,240
and apparently we cannot it's not it is

399
00:21:48,240 --> 00:21:49,980
not here we could not find it find it in

400
00:21:49,980 --> 00:21:53,280
the memory down so this ensures that

401
00:21:53,280 --> 00:21:55,860
when the program is running

402
00:21:55,860 --> 00:21:58,679
the memory within the memory those

403
00:21:58,679 --> 00:22:01,140
instructions constants all the data is

404
00:22:01,140 --> 00:22:03,179
still encrypted that's the reason we

405
00:22:03,179 --> 00:22:06,059
cannot read it but this is but this

406
00:22:06,059 --> 00:22:08,760
doesn't explain anything yet right maybe

407
00:22:08,760 --> 00:22:10,440
I don't know how to capture the memory

408
00:22:10,440 --> 00:22:13,020
or maybe maybe this is simply not not

409
00:22:13,020 --> 00:22:14,880
the correct way for analysis which is

410
00:22:14,880 --> 00:22:16,919
why we need to Benchmark our results we

411
00:22:16,919 --> 00:22:18,960
need something to compare it with so I'm

412
00:22:18,960 --> 00:22:20,700
going to compare compare it with a C

413
00:22:20,700 --> 00:22:23,299
plus plus program

414
00:22:24,240 --> 00:22:26,640
but first let's verify whether this

415
00:22:26,640 --> 00:22:28,620
executable file really is working or not

416
00:22:28,620 --> 00:22:30,720
maybe it's some well-formed executable

417
00:22:30,720 --> 00:22:32,580
file maybe mutant does not create a

418
00:22:32,580 --> 00:22:35,840
correct executable file

419
00:22:36,840 --> 00:22:40,639
so I just need to copy this from here

420
00:22:40,919 --> 00:22:43,080
okay it looks like it it is creating a

421
00:22:43,080 --> 00:22:44,640
correct executive file it is working

422
00:22:44,640 --> 00:22:47,120
just fine

423
00:22:50,460 --> 00:22:52,799
so before we compile our C plus plus

424
00:22:52,799 --> 00:22:56,159
program let's see how it looks like

425
00:22:56,159 --> 00:22:58,500
very simple very standard program also

426
00:22:58,500 --> 00:23:02,480
we need to remove this

427
00:23:13,919 --> 00:23:15,539
this needs to be changed so it matches

428
00:23:15,539 --> 00:23:17,880
with matches with the same state credit

429
00:23:17,880 --> 00:23:21,179
is 42.

430
00:23:22,740 --> 00:23:25,260
now I understand that all of you who are

431
00:23:25,260 --> 00:23:27,600
watching this uh talk right now must

432
00:23:27,600 --> 00:23:29,820
make ranging upon the fact that why am I

433
00:23:29,820 --> 00:23:32,640
hard coding credentials Sometimes some

434
00:23:32,640 --> 00:23:34,679
developers may not be aware of this

435
00:23:34,679 --> 00:23:36,480
sometimes they just think okay no one is

436
00:23:36,480 --> 00:23:38,940
going to enter my uh trusted zone no one

437
00:23:38,940 --> 00:23:42,600
is going to no one is going to uh read

438
00:23:42,600 --> 00:23:44,220
this and read the server code because

439
00:23:44,220 --> 00:23:46,020
it's behind a bunch of firewalls and

440
00:23:46,020 --> 00:23:49,020
everything but what if uh whatever

441
00:23:49,020 --> 00:23:51,780
lapses have what is lapses happens what

442
00:23:51,780 --> 00:23:53,340
if

443
00:23:53,340 --> 00:23:57,120
um lock bit happens but if what if the

444
00:23:57,120 --> 00:23:59,460
data what if the data gets leaked or

445
00:23:59,460 --> 00:24:01,260
what if LastPass happens you remember

446
00:24:01,260 --> 00:24:03,840
that there are a lot of their source

447
00:24:03,840 --> 00:24:06,240
code was stolen or

448
00:24:06,240 --> 00:24:08,580
in in this scenario at least your

449
00:24:08,580 --> 00:24:11,280
binaries will be protected against the

450
00:24:11,280 --> 00:24:13,980
against reverse engineering attempts to

451
00:24:13,980 --> 00:24:16,080
some extent it's not a perfect solution

452
00:24:16,080 --> 00:24:17,700
someone will obviously figure out a way

453
00:24:17,700 --> 00:24:20,000
to practice

454
00:24:23,820 --> 00:24:25,679
okay so now that we have modified our C

455
00:24:25,679 --> 00:24:29,059
plus plus code let's compile it

456
00:24:36,600 --> 00:24:38,720
okay and I am going to run strings here

457
00:24:38,720 --> 00:24:41,600
just to show you whether we can find

458
00:24:41,600 --> 00:24:44,580
anything out of the compiled C plus plus

459
00:24:44,580 --> 00:24:46,879
file

460
00:24:52,200 --> 00:24:54,380
foreign

461
00:24:57,919 --> 00:25:00,419
hard-coded string is there in C plus

462
00:25:00,419 --> 00:25:02,700
file even in the executable file as I

463
00:25:02,700 --> 00:25:04,980
showed you before if you if you try to

464
00:25:04,980 --> 00:25:06,780
find the string within the mutant

465
00:25:06,780 --> 00:25:09,179
executable file which we can do it right

466
00:25:09,179 --> 00:25:11,480
here

467
00:25:19,440 --> 00:25:21,120
we won't be able to find it because it's

468
00:25:21,120 --> 00:25:23,340
all encrypted in well in compile time

469
00:25:23,340 --> 00:25:26,640
and run time as we saw before

470
00:25:26,640 --> 00:25:28,500
so let's run this program and capture

471
00:25:28,500 --> 00:25:30,980
memory again

472
00:25:45,799 --> 00:25:48,720
and it's going to take up okay that was

473
00:25:48,720 --> 00:25:50,220
passed

474
00:25:50,220 --> 00:25:52,080
now I just need to take change the

475
00:25:52,080 --> 00:25:54,439
ownership

476
00:25:57,539 --> 00:26:00,120
and let's find all the strings

477
00:26:00,120 --> 00:26:02,360
foreign

478
00:26:14,299 --> 00:26:17,159
so it takes some time for it to get all

479
00:26:17,159 --> 00:26:19,260
the Springs out of it okay now we have

480
00:26:19,260 --> 00:26:21,720
the strings so let's see if we can find

481
00:26:21,720 --> 00:26:24,320
it and yes

482
00:26:24,960 --> 00:26:27,240
this is uh this is where I believe

483
00:26:27,240 --> 00:26:30,419
mutant works better because within run

484
00:26:30,419 --> 00:26:32,760
time we were not able to find we were

485
00:26:32,760 --> 00:26:35,220
not able to to find secret s42 string

486
00:26:35,220 --> 00:26:37,380
which was our hard-coded credential

487
00:26:37,380 --> 00:26:39,539
obviously if I capture the memory again

488
00:26:39,539 --> 00:26:42,179
and I run the and I run the mutant

489
00:26:42,179 --> 00:26:43,740
compiled binary will still find the

490
00:26:43,740 --> 00:26:46,140
string because because when we run up

491
00:26:46,140 --> 00:26:48,000
when we're running the program it's not

492
00:26:48,000 --> 00:26:51,720
just it's it's not just the it's not

493
00:26:51,720 --> 00:26:53,700
just a memory occupied by mutant there

494
00:26:53,700 --> 00:26:56,100
are other programs like this wall cpp1

495
00:26:56,100 --> 00:26:58,020
so I'll have to reset the virtual

496
00:26:58,020 --> 00:26:59,460
machine for this but I hope you get the

497
00:26:59,460 --> 00:27:01,679
gist of it like like how the runtime and

498
00:27:01,679 --> 00:27:03,000
the compile time encryption is being

499
00:27:03,000 --> 00:27:05,779
enforced here

500
00:27:06,779 --> 00:27:09,539
but this is still not perfect

501
00:27:09,539 --> 00:27:11,760
this is a POC it works things are

502
00:27:11,760 --> 00:27:13,020
working here

503
00:27:13,020 --> 00:27:14,880
still not perfect there are some

504
00:27:14,880 --> 00:27:19,039
limitations and let's see what those are

505
00:27:19,440 --> 00:27:21,600
now the key generation algorithm is

506
00:27:21,600 --> 00:27:24,360
deterministic also it is open source so

507
00:27:24,360 --> 00:27:25,679
anyone can just read how it's going to

508
00:27:25,679 --> 00:27:28,320
how it's working but even if Newton was

509
00:27:28,320 --> 00:27:30,720
closed Source someone dedicated enough

510
00:27:30,720 --> 00:27:34,020
could could could figure out how the key

511
00:27:34,020 --> 00:27:36,419
is being generated and when they figure

512
00:27:36,419 --> 00:27:37,980
out how this key generation is working

513
00:27:37,980 --> 00:27:40,380
they will essentially bypass all the

514
00:27:40,380 --> 00:27:43,320
bypass all the security because in in

515
00:27:43,320 --> 00:27:46,980
mutant security here is it's it's it

516
00:27:46,980 --> 00:27:48,960
Banks totally on obfuscation and

517
00:27:48,960 --> 00:27:51,539
encryption that's all there is to it

518
00:27:51,539 --> 00:27:55,020
however things can be improved we can

519
00:27:55,020 --> 00:27:57,720
add bytecode compression we can we can

520
00:27:57,720 --> 00:28:00,419
we can have uh so right now the all the

521
00:28:00,419 --> 00:28:02,299
constants and all the uh and all the

522
00:28:02,299 --> 00:28:07,580
stack is currently static in a way

523
00:28:08,760 --> 00:28:10,980
but but we can do better there we can we

524
00:28:10,980 --> 00:28:12,900
can make them more Dynamic but that's

525
00:28:12,900 --> 00:28:15,419
something we can discuss later it's uh

526
00:28:15,419 --> 00:28:17,400
community of adoption is not that great

527
00:28:17,400 --> 00:28:19,320
because it's not really a direct plug-in

528
00:28:19,320 --> 00:28:23,279
for llvm jvm CLR just yet many things

529
00:28:23,279 --> 00:28:25,799
needs to be improved here and then and

530
00:28:25,799 --> 00:28:27,900
then maybe we can figure out how to

531
00:28:27,900 --> 00:28:30,419
ingest other binaries and others so and

532
00:28:30,419 --> 00:28:32,279
other programming languages so that you

533
00:28:32,279 --> 00:28:34,140
don't have to use mutant programming

534
00:28:34,140 --> 00:28:35,760
language essential you don't have to

535
00:28:35,760 --> 00:28:37,500
change your text tag just to get this

536
00:28:37,500 --> 00:28:40,140
level of security also obviously this is

537
00:28:40,140 --> 00:28:41,760
not battle tested I have only tested it

538
00:28:41,760 --> 00:28:43,919
on on my own machine maybe with a couple

539
00:28:43,919 --> 00:28:45,059
of friends

540
00:28:45,059 --> 00:28:47,580
but it's not 100 interested it's not

541
00:28:47,580 --> 00:28:50,159
tested on some really complex uh uh

542
00:28:50,159 --> 00:28:52,919
critical software or it doesn't because

543
00:28:52,919 --> 00:28:54,419
it didn't because I don't really have

544
00:28:54,419 --> 00:28:56,760
many people using it so a lot of testing

545
00:28:56,760 --> 00:28:57,960
needs to be done maybe there's some side

546
00:28:57,960 --> 00:29:00,000
Channel attack someone can uh someone

547
00:29:00,000 --> 00:29:02,159
can get grab the value from CPU cache or

548
00:29:02,159 --> 00:29:04,500
someone can do someone can figure some

549
00:29:04,500 --> 00:29:06,299
other ways how to get the data from the

550
00:29:06,299 --> 00:29:08,100
memory those protections still need to

551
00:29:08,100 --> 00:29:09,720
be added

552
00:29:09,720 --> 00:29:12,480
what's next we are doing code uh support

553
00:29:12,480 --> 00:29:14,960
we add uh

554
00:29:14,960 --> 00:29:17,880
byte code compression and we add a

555
00:29:17,880 --> 00:29:20,039
ripple to the to the website we have a

556
00:29:20,039 --> 00:29:21,419
website here it's just that you cannot

557
00:29:21,419 --> 00:29:23,399
you cannot directly run mutant code

558
00:29:23,399 --> 00:29:26,220
there but in future you will be able to

559
00:29:26,220 --> 00:29:28,260
also it's open source as I mentioned

560
00:29:28,260 --> 00:29:29,520
before you can just head over to this

561
00:29:29,520 --> 00:29:32,039
link you can try it out anytime clone it

562
00:29:32,039 --> 00:29:35,220
Fork it use however you would like to

563
00:29:35,220 --> 00:29:37,980
and let's connect uh this is my username

564
00:29:37,980 --> 00:29:39,899
for GitHub and Linkedin

565
00:29:39,899 --> 00:29:43,140
and if you have any questions uh I'll be

566
00:29:43,140 --> 00:29:45,720
happy to take them

567
00:29:45,720 --> 00:29:48,260
yes

568
00:29:55,799 --> 00:29:58,799
hello

569
00:30:01,460 --> 00:30:04,559
hi very nice talk about uh

570
00:30:04,559 --> 00:30:06,960
virtualization for code protection right

571
00:30:06,960 --> 00:30:09,840
so why would I use a different language

572
00:30:09,840 --> 00:30:12,000
while I can use VM protect or the

573
00:30:12,000 --> 00:30:13,500
meta-like software so we can directly

574
00:30:13,500 --> 00:30:14,940
convert my code into a virtualization

575
00:30:14,940 --> 00:30:17,100
score

576
00:30:17,100 --> 00:30:20,580
right so what I'm trying to as of this

577
00:30:20,580 --> 00:30:21,419
moment

578
00:30:21,419 --> 00:30:23,700
I wouldn't want anyone to use mute and

579
00:30:23,700 --> 00:30:25,320
it's it's a it's an academic project

580
00:30:25,320 --> 00:30:27,539
it's it's like an infancy

581
00:30:27,539 --> 00:30:30,679
but in future

582
00:30:30,919 --> 00:30:34,440
I would like a mutant adoption when it's

583
00:30:34,440 --> 00:30:36,360
more facial fact reason and so the

584
00:30:36,360 --> 00:30:38,640
reason I'm trying to do provide here is

585
00:30:38,640 --> 00:30:39,779
that let's say you're writing an

586
00:30:39,779 --> 00:30:41,460
application Java or something

587
00:30:41,460 --> 00:30:43,620
you should not be relying on many

588
00:30:43,620 --> 00:30:45,179
different uh Technologies many different

589
00:30:45,179 --> 00:30:47,940
tools to to figure out to how to harden

590
00:30:47,940 --> 00:30:50,100
it sometimes people write assembly code

591
00:30:50,100 --> 00:30:51,720
by hand sometimes they use different

592
00:30:51,720 --> 00:30:53,820
types of Packers Packers can be detected

593
00:30:53,820 --> 00:30:55,880
by can be can be picked up by

594
00:30:55,880 --> 00:30:59,100
anti-malware engines I want to bake and

595
00:30:59,100 --> 00:31:00,899
make the security inside of the language

596
00:31:00,899 --> 00:31:03,720
yeah but like uh if you heard about VM

597
00:31:03,720 --> 00:31:05,580
protect and femide like softwares which

598
00:31:05,580 --> 00:31:06,899
are protectors and which use

599
00:31:06,899 --> 00:31:08,640
virtualization code as a protection for

600
00:31:08,640 --> 00:31:10,860
code security which is the similar

601
00:31:10,860 --> 00:31:13,320
concept you are saying here so what it

602
00:31:13,320 --> 00:31:16,320
does is it will actually compile the x86

603
00:31:16,320 --> 00:31:18,480
byte code or r64 byte code and compile

604
00:31:18,480 --> 00:31:20,399
into their virtualization code and they

605
00:31:20,399 --> 00:31:23,159
are uh they are like very mature engines

606
00:31:23,159 --> 00:31:28,260
so why won't I uh make my uh code same

607
00:31:28,260 --> 00:31:30,539
and then use the VM protector themata

608
00:31:30,539 --> 00:31:32,039
which are like metal tested and

609
00:31:32,039 --> 00:31:33,899
everything else

610
00:31:33,899 --> 00:31:36,419
right that's a great question and I need

611
00:31:36,419 --> 00:31:38,820
to check those Technologies because uh

612
00:31:38,820 --> 00:31:40,679
unfortunately I have not heard of them

613
00:31:40,679 --> 00:31:41,580
before

614
00:31:41,580 --> 00:31:43,500
second question is uh you were talking

615
00:31:43,500 --> 00:31:46,140
about uh that you can uh convert the

616
00:31:46,140 --> 00:31:48,539
code from the applications javaselr.net

617
00:31:48,539 --> 00:31:50,640
or llvm plugins so that you can convert

618
00:31:50,640 --> 00:31:52,500
the code so any plannings how you will

619
00:31:52,500 --> 00:31:54,659
do that because uh the current research

620
00:31:54,659 --> 00:31:55,799
in the de-virtualization and

621
00:31:55,799 --> 00:31:58,200
virtualization code is uh is like the D

622
00:31:58,200 --> 00:31:59,640
virtual agent part is very hard because

623
00:31:59,640 --> 00:32:01,860
of the code path and the CFG patterns

624
00:32:01,860 --> 00:32:04,140
right so anything which you have thought

625
00:32:04,140 --> 00:32:06,240
about that how you you will convert the

626
00:32:06,240 --> 00:32:08,880
uh you know x86 code into your own

627
00:32:08,880 --> 00:32:11,399
virtual machine byte code or vice versa

628
00:32:11,399 --> 00:32:13,740
so for now I'm only planning uh in the

629
00:32:13,740 --> 00:32:17,100
beginning I'm only planning to Target uh

630
00:32:17,100 --> 00:32:20,820
say llvm or jvm and then and make a sort

631
00:32:20,820 --> 00:32:23,940
of plug-in for them I don't want uh in

632
00:32:23,940 --> 00:32:25,380
the beginning a beginning I don't want

633
00:32:25,380 --> 00:32:29,520
to take the already compiled uh binary

634
00:32:29,520 --> 00:32:31,740
and then try to add security to it that

635
00:32:31,740 --> 00:32:34,440
will be really complicated yeah yeah so

636
00:32:34,440 --> 00:32:37,320
yeah yeah okay got the answer thank you

637
00:32:37,320 --> 00:32:39,539
thank you

638
00:32:39,539 --> 00:32:42,320
anyways

639
00:32:47,640 --> 00:32:49,679
yeah thanks a lot for this amazing talk

640
00:32:49,679 --> 00:32:51,899
thank you what will be the runtime like

641
00:32:51,899 --> 00:32:53,580
overhead if we are encrypting and

642
00:32:53,580 --> 00:32:56,100
decrypting uh our code

643
00:32:56,100 --> 00:32:58,679
sorry I could not hear you what will be

644
00:32:58,679 --> 00:33:00,480
the run time over it like time overhead

645
00:33:00,480 --> 00:33:02,039
that we are spending during decryption

646
00:33:02,039 --> 00:33:04,500
and encryption right that

647
00:33:04,500 --> 00:33:06,539
that's a great question

648
00:33:06,539 --> 00:33:09,360
connecting it so overhead right here

649
00:33:09,360 --> 00:33:13,559
should be minimal it's just xor and ixor

650
00:33:13,559 --> 00:33:15,539
the individual instructions it happens

651
00:33:15,539 --> 00:33:17,340
in like one or two clock Cycles Max

652
00:33:17,340 --> 00:33:19,500
there's not much overhead there because

653
00:33:19,500 --> 00:33:21,480
so you are not really like encrypting

654
00:33:21,480 --> 00:33:23,519
with some keys or all that

655
00:33:23,519 --> 00:33:27,299
xor by definition should be the perfect

656
00:33:27,299 --> 00:33:30,120
encryption as long as we we can see we

657
00:33:30,120 --> 00:33:33,080
can find the the perfectly

658
00:33:33,080 --> 00:33:35,039
randomized key

659
00:33:35,039 --> 00:33:38,159
now while I do not claim that I have a

660
00:33:38,159 --> 00:33:40,260
perfectly randomized key I believe the

661
00:33:40,260 --> 00:33:42,779
size of instructions are small enough to

662
00:33:42,779 --> 00:33:45,720
generate a good enough randomized key so

663
00:33:45,720 --> 00:33:47,460
I don't have to use a very complex

664
00:33:47,460 --> 00:33:49,860
encryption algorithm here

665
00:33:49,860 --> 00:33:51,600
okay yeah but so if you are using only

666
00:33:51,600 --> 00:33:55,019
xor like for a hacker like or anyone who

667
00:33:55,019 --> 00:33:57,059
wants to be like decrypt it it will be

668
00:33:57,059 --> 00:33:58,440
quite easy right you just have to

669
00:33:58,440 --> 00:34:00,419
perform same operation xor and you will

670
00:34:00,419 --> 00:34:02,640
get the original op code yeah it's just

671
00:34:02,640 --> 00:34:04,740
like um you can just perform you can

672
00:34:04,740 --> 00:34:06,600
just run AES again if you have the key

673
00:34:06,600 --> 00:34:08,639
so here you can just run extra again if

674
00:34:08,639 --> 00:34:10,379
you have the key so it's just like any

675
00:34:10,379 --> 00:34:11,599
other uh

676
00:34:11,599 --> 00:34:14,040
encryption algorithm you have the key

677
00:34:14,040 --> 00:34:16,859
you you run it and you can just equip

678
00:34:16,859 --> 00:34:19,800
whatever encrypted content was okay so

679
00:34:19,800 --> 00:34:21,719
where are you storing this key then

680
00:34:21,719 --> 00:34:24,659
I generate this key on the Fly

681
00:34:24,659 --> 00:34:27,060
this will be a longer conversation if I

682
00:34:27,060 --> 00:34:28,859
try to explain if I explain another key

683
00:34:28,859 --> 00:34:30,899
generation process here I try not to

684
00:34:30,899 --> 00:34:33,060
store it anymore okay sure sure got it

685
00:34:33,060 --> 00:34:35,299
thanks

686
00:34:38,159 --> 00:34:40,980
uh again thanks for the talk and uh I

687
00:34:40,980 --> 00:34:42,780
really enjoyed your description of how

688
00:34:42,780 --> 00:34:45,719
your uh obfuscating the binary so I

689
00:34:45,719 --> 00:34:48,960
guess uh one question I had was that how

690
00:34:48,960 --> 00:34:50,339
bloated are these binaries that you're

691
00:34:50,339 --> 00:34:52,080
generating

692
00:34:52,080 --> 00:34:54,119
um and a follow-on for that would be

693
00:34:54,119 --> 00:34:55,918
could you like just show the binary

694
00:34:55,918 --> 00:34:58,200
actually uh especially the one for Linux

695
00:34:58,200 --> 00:35:00,900
is it identical to the one on Windows I

696
00:35:00,900 --> 00:35:03,000
would think not right okay so let's see

697
00:35:03,000 --> 00:35:04,500
what's the size difference between these

698
00:35:04,500 --> 00:35:06,780
binaries uh no I'm just asking you for

699
00:35:06,780 --> 00:35:07,920
the size difference I don't want you to

700
00:35:07,920 --> 00:35:10,920
show it but then uh I wanted to see what

701
00:35:10,920 --> 00:35:12,960
the binary on Linux look like like could

702
00:35:12,960 --> 00:35:15,300
you do a hex dump and show it to us

703
00:35:15,300 --> 00:35:19,040
sure yeah thanks

704
00:35:37,740 --> 00:35:42,359
this is a pretty much loaded binary

705
00:35:42,359 --> 00:35:45,180
so it's it's like 30 MB in size

706
00:35:45,180 --> 00:35:47,099
this is one of the problems that I need

707
00:35:47,099 --> 00:35:49,460
to address

708
00:35:50,460 --> 00:35:52,980
so it is in scope and in future the

709
00:35:52,980 --> 00:35:55,800
binary size won't be so big uh the

710
00:35:55,800 --> 00:35:58,619
binary size ranges from 30 to 30.1 or 2

711
00:35:58,619 --> 00:36:01,619
MB between all the platforms

712
00:36:01,619 --> 00:36:04,619
uh is it an X binary is it an else

713
00:36:04,619 --> 00:36:07,079
binary yes yes it is an else binary okay

714
00:36:07,079 --> 00:36:10,700
uh okay cool

715
00:36:11,160 --> 00:36:13,879
anyone else

716
00:36:17,640 --> 00:36:20,940
can we use uh other golang libraries

717
00:36:20,940 --> 00:36:24,300
here since you're compiling uh using

718
00:36:24,300 --> 00:36:26,040
golang right

719
00:36:26,040 --> 00:36:29,820
um so like HTTP can use http

720
00:36:29,820 --> 00:36:33,180
right now uh the the features include

721
00:36:33,180 --> 00:36:34,980
very very uh the features include user

722
00:36:34,980 --> 00:36:36,900
defined functions some complex data

723
00:36:36,900 --> 00:36:39,380
types like arrays you can have hash maps

724
00:36:39,380 --> 00:36:42,240
and some user interaction using a

725
00:36:42,240 --> 00:36:44,099
console input output

726
00:36:44,099 --> 00:36:46,079
as of this moment I haven't figured out

727
00:36:46,079 --> 00:36:48,660
a way to sit into securely perform to

728
00:36:48,660 --> 00:36:51,960
perform disk i o operations or

729
00:36:51,960 --> 00:36:54,540
um or HTTP requests or networking

730
00:36:54,540 --> 00:36:57,240
operations this is uh this is a more uh

731
00:36:57,240 --> 00:37:00,960
this is this is a more future uh feature

732
00:37:00,960 --> 00:37:02,460
but if you are interested in

733
00:37:02,460 --> 00:37:04,140
contributing I'll be happy to talk about

734
00:37:04,140 --> 00:37:07,380
it sure thanks

735
00:37:07,380 --> 00:37:10,040
everyone else

736
00:37:11,280 --> 00:37:14,180
I think we're good

737
00:37:15,480 --> 00:37:18,839
wait so thank you and uh special thanks

738
00:37:18,839 --> 00:37:20,820
to my professor this uh this was my

739
00:37:20,820 --> 00:37:22,680
academic project uh during my Master's

740
00:37:22,680 --> 00:37:23,579
thesis

741
00:37:23,579 --> 00:37:25,260
uh other than that thank you to the

742
00:37:25,260 --> 00:37:27,240
nullcon team for organizing it this is a

743
00:37:27,240 --> 00:37:29,160
great event and thanks to you for

744
00:37:29,160 --> 00:37:30,540
listening and for all these questions

745
00:37:30,540 --> 00:37:33,240
this really gives me perspective around

746
00:37:33,240 --> 00:37:36,119
what what more I can do here so thank

747
00:37:36,119 --> 00:37:39,119
you thanks thanks to you gaurav for the

748
00:37:39,119 --> 00:37:41,720
wonderful job

