1
00:00:03,060 --> 00:00:05,580
thank you so much uh we are very very

2
00:00:05,580 --> 00:00:07,620
happy to be here a big thanks for

3
00:00:07,620 --> 00:00:09,240
everybody who is here attending our

4
00:00:09,240 --> 00:00:11,340
presentation and of course the nalcon

5
00:00:11,340 --> 00:00:14,099
team for making this possible

6
00:00:14,099 --> 00:00:16,560
um all right let's get started I guess

7
00:00:16,560 --> 00:00:19,140
we've already introduced uh maybe just a

8
00:00:19,140 --> 00:00:21,779
few words on what we are working on so

9
00:00:21,779 --> 00:00:23,820
both of us are working on Android

10
00:00:23,820 --> 00:00:26,220
security embedded devices thing as well

11
00:00:26,220 --> 00:00:28,260
as blockchain

12
00:00:28,260 --> 00:00:31,260
um so before I start the talk I want to

13
00:00:31,260 --> 00:00:35,040
bring attention to Kernel Security and

14
00:00:35,040 --> 00:00:37,079
why is it important for all of us not

15
00:00:37,079 --> 00:00:39,660
only for security researchers the main

16
00:00:39,660 --> 00:00:41,700
reason is because critical current Linux

17
00:00:41,700 --> 00:00:43,680
kernel vulnerabilities are happening

18
00:00:43,680 --> 00:00:46,320
they are being published every once in a

19
00:00:46,320 --> 00:00:48,059
while for example there was one

20
00:00:48,059 --> 00:00:50,219
privileged escalation vulnerability in

21
00:00:50,219 --> 00:00:52,320
March this year and also a critical

22
00:00:52,320 --> 00:00:54,480
remote takeover vulnerability in last

23
00:00:54,480 --> 00:00:57,660
November so let's continue as an example

24
00:00:57,660 --> 00:01:00,539
with the second vulnerability and let's

25
00:01:00,539 --> 00:01:03,239
ask a warm-up question which is how old

26
00:01:03,239 --> 00:01:05,820
is your smart TV I'm asking this

27
00:01:05,820 --> 00:01:08,159
question because it is very much

28
00:01:08,159 --> 00:01:10,260
expected that if you buy a smart TV now

29
00:01:10,260 --> 00:01:12,960
you might as well use it for 8 years 10

30
00:01:12,960 --> 00:01:15,720
years or later on but these more TVs

31
00:01:15,720 --> 00:01:17,700
after maybe four years might not receive

32
00:01:17,700 --> 00:01:19,920
security updates anymore and this is a

33
00:01:19,920 --> 00:01:21,420
problem to you because then You're

34
00:01:21,420 --> 00:01:23,700
vulnerable to all the bugs that are

35
00:01:23,700 --> 00:01:25,799
reported after that and that are

36
00:01:25,799 --> 00:01:28,860
actually being researched on so we have

37
00:01:28,860 --> 00:01:31,439
a case study here this is the privilege

38
00:01:31,439 --> 00:01:33,060
escalation vulnerability that I

39
00:01:33,060 --> 00:01:34,939
mentioned in the previous slide also

40
00:01:34,939 --> 00:01:39,479
call known as dirty pipe so it was only

41
00:01:39,479 --> 00:01:41,280
published in this March but it's

42
00:01:41,280 --> 00:01:44,040
believed to be existing in the last six

43
00:01:44,040 --> 00:01:46,740
years this is very similar to a CV that

44
00:01:46,740 --> 00:01:49,380
was released in 2016. now what are the

45
00:01:49,380 --> 00:01:51,720
complications the complications is that

46
00:01:51,720 --> 00:01:54,000
the patch to this vulnerability is only

47
00:01:54,000 --> 00:01:56,520
available to Linux kernel versions 5 to

48
00:01:56,520 --> 00:01:59,600
16 11 5 15 25

49
00:01:59,600 --> 00:02:03,600
5102 but there are many old systems that

50
00:02:03,600 --> 00:02:05,820
run on other curdles at the moment your

51
00:02:05,820 --> 00:02:08,399
smart TV might be one of them and these

52
00:02:08,399 --> 00:02:10,080
are very vulnerable to this

53
00:02:10,080 --> 00:02:12,599
vulnerability unless the device vendor

54
00:02:12,599 --> 00:02:14,700
is applying a manual patch by

55
00:02:14,700 --> 00:02:16,440
backboarding but this is often very

56
00:02:16,440 --> 00:02:19,020
cumbersome and it's not performed so

57
00:02:19,020 --> 00:02:20,760
let's get started with our presentation

58
00:02:20,760 --> 00:02:22,440
now that you understand why you should

59
00:02:22,440 --> 00:02:24,260
care about the Linux Kernel Security

60
00:02:24,260 --> 00:02:27,360
First of all we will tell you a bit more

61
00:02:27,360 --> 00:02:29,340
about the problems in the Linux kernel

62
00:02:29,340 --> 00:02:31,920
patching then we will tell you what are

63
00:02:31,920 --> 00:02:34,140
the typical problems in kernel lifecycle

64
00:02:34,140 --> 00:02:36,660
management then finally we will

65
00:02:36,660 --> 00:02:38,940
introduce kernel petrolyzer which is a

66
00:02:38,940 --> 00:02:40,739
tool that we just released today for

67
00:02:40,739 --> 00:02:43,319
nalcon so we are really hoping that you

68
00:02:43,319 --> 00:02:45,120
will try our tool and give us feedback

69
00:02:45,120 --> 00:02:46,980
and we will follow up with the details

70
00:02:46,980 --> 00:02:49,319
soon in this presentation and finally we

71
00:02:49,319 --> 00:02:51,660
will continue with the conclusion and

72
00:02:51,660 --> 00:02:53,099
the key takeaways

73
00:02:53,099 --> 00:02:56,040
so let's get started kernel patching is

74
00:02:56,040 --> 00:02:58,140
a complex problem and as you can see

75
00:02:58,140 --> 00:03:00,060
there are many parties involved in it

76
00:03:00,060 --> 00:03:02,580
for example first of all there is the

77
00:03:02,580 --> 00:03:05,580
Linux Upstream kernel on kernel.org that

78
00:03:05,580 --> 00:03:07,680
every device kernel is based on this

79
00:03:07,680 --> 00:03:09,300
doesn't have to be long term supported

80
00:03:09,300 --> 00:03:11,040
although we will explain why it is

81
00:03:11,040 --> 00:03:13,620
considered best practice then if you

82
00:03:13,620 --> 00:03:16,319
have an Android Android based device

83
00:03:16,319 --> 00:03:18,300
then you also have to import Patches

84
00:03:18,300 --> 00:03:20,580
from the Android command kernel and then

85
00:03:20,580 --> 00:03:22,620
of course your device runs in a chipset

86
00:03:22,620 --> 00:03:25,319
and the the kernel also has to be

87
00:03:25,319 --> 00:03:27,659
specific to the chips that that you're

88
00:03:27,659 --> 00:03:29,459
running on that comes from the chipset

89
00:03:29,459 --> 00:03:31,680
vendor and finally you have your device

90
00:03:31,680 --> 00:03:34,080
kernel that is actually running the

91
00:03:34,080 --> 00:03:36,120
device and here you are you have

92
00:03:36,120 --> 00:03:38,640
additional customizations device drivers

93
00:03:38,640 --> 00:03:40,680
Etc and basically when you're patching

94
00:03:40,680 --> 00:03:42,599
your device you have to consider all the

95
00:03:42,599 --> 00:03:43,980
patches from all these different

96
00:03:43,980 --> 00:03:46,019
repositories to make sure that your

97
00:03:46,019 --> 00:03:47,940
device is secure

98
00:03:47,940 --> 00:03:50,159
um so as you can see there are multiple

99
00:03:50,159 --> 00:03:52,319
parties involving involving kernel

100
00:03:52,319 --> 00:03:54,540
patching and it also brings some kind of

101
00:03:54,540 --> 00:03:57,480
unique challenges so as you can see

102
00:03:57,480 --> 00:03:59,040
first the patch is available in the

103
00:03:59,040 --> 00:04:01,099
Linux upstream or AOSP common

104
00:04:01,099 --> 00:04:03,780
repositories for Android then the

105
00:04:03,780 --> 00:04:05,640
chipset vendor also provides an update

106
00:04:05,640 --> 00:04:07,680
specific to the chipset and then finally

107
00:04:07,680 --> 00:04:10,140
as a device vendor you update according

108
00:04:10,140 --> 00:04:11,640
to the drivers and your your

109
00:04:11,640 --> 00:04:13,860
customization and finally you're ready

110
00:04:13,860 --> 00:04:15,959
to push out your security update or your

111
00:04:15,959 --> 00:04:18,000
cellular operator as your client does it

112
00:04:18,000 --> 00:04:21,000
but it brings some challenges so for

113
00:04:21,000 --> 00:04:23,460
example this is also something that we

114
00:04:23,460 --> 00:04:26,340
we see during our security audits but

115
00:04:26,340 --> 00:04:27,780
this is also something that people are

116
00:04:27,780 --> 00:04:29,699
researching for example there is a paper

117
00:04:29,699 --> 00:04:31,740
that we linked here from Zhang zhen from

118
00:04:31,740 --> 00:04:34,680
last year which basically found that

119
00:04:34,680 --> 00:04:37,020
many devices

120
00:04:37,020 --> 00:04:40,080
for many patches actually these patches

121
00:04:40,080 --> 00:04:42,000
don't reach the end user devices when

122
00:04:42,000 --> 00:04:43,740
they are published only a few months

123
00:04:43,740 --> 00:04:45,360
later and this leaves the device is

124
00:04:45,360 --> 00:04:47,639
vulnerable to these bugs in the meantime

125
00:04:47,639 --> 00:04:50,520
and another critical issue is that if

126
00:04:50,520 --> 00:04:52,320
you're a device kernel vendor or if

127
00:04:52,320 --> 00:04:54,120
you're a cellular operator or even an

128
00:04:54,120 --> 00:04:57,300
end user you often don't know which

129
00:04:57,300 --> 00:04:58,919
patches should have been applied to your

130
00:04:58,919 --> 00:05:01,560
device and you don't know whether these

131
00:05:01,560 --> 00:05:03,419
patches were actually applied

132
00:05:03,419 --> 00:05:07,080
just to be more specific and and to show

133
00:05:07,080 --> 00:05:09,840
you what volume we are talking about so

134
00:05:09,840 --> 00:05:12,840
this is a statistics from the kernel

135
00:05:12,840 --> 00:05:14,520
vulnerabilities that were released in

136
00:05:14,520 --> 00:05:16,740
the first half of this year as you can

137
00:05:16,740 --> 00:05:19,639
see there are all almost

138
00:05:19,639 --> 00:05:22,440
130 of them so quite a lot and imagine

139
00:05:22,440 --> 00:05:24,180
that if you're a device vendor you have

140
00:05:24,180 --> 00:05:27,300
to patch maybe all of them and one other

141
00:05:27,300 --> 00:05:29,880
interesting factor is that 80 81 out of

142
00:05:29,880 --> 00:05:31,620
them are actually ability to Qualcomm

143
00:05:31,620 --> 00:05:33,900
components which are also handled by

144
00:05:33,900 --> 00:05:36,120
their own disclosure process which means

145
00:05:36,120 --> 00:05:37,860
that it's the patching process is even

146
00:05:37,860 --> 00:05:39,900
more complicated than what we just

147
00:05:39,900 --> 00:05:42,660
talked about in the previous slide

148
00:05:42,660 --> 00:05:43,199
um

149
00:05:43,199 --> 00:05:46,139
and then I've came to the most critical

150
00:05:46,139 --> 00:05:48,000
problem in kernel patching which is

151
00:05:48,000 --> 00:05:50,759
fragmentation by fragmentation remains

152
00:05:50,759 --> 00:05:52,800
we mean that nearly all embedded devices

153
00:05:52,800 --> 00:05:55,380
have custom kernels why because you have

154
00:05:55,380 --> 00:05:57,419
a custom use case custom Hardware

155
00:05:57,419 --> 00:06:00,360
specification and a custom Hardware

156
00:06:00,360 --> 00:06:03,000
drivers and this is why security

157
00:06:03,000 --> 00:06:05,039
batteries also require a lot of manual

158
00:06:05,039 --> 00:06:07,740
work and each of the security patches

159
00:06:07,740 --> 00:06:09,539
need to be blackboarded manually to the

160
00:06:09,539 --> 00:06:11,699
device kernel that is a lot of work and

161
00:06:11,699 --> 00:06:13,560
this is why also long-term supported

162
00:06:13,560 --> 00:06:16,139
updates from the mainline kernel is

163
00:06:16,139 --> 00:06:18,900
often really hard to merge and sometimes

164
00:06:18,900 --> 00:06:20,699
it's also omitted when when it's not

165
00:06:20,699 --> 00:06:22,860
possible for the device vendor and from

166
00:06:22,860 --> 00:06:24,419
the opposite side as well it's really

167
00:06:24,419 --> 00:06:26,220
hard to contribute custom changes back

168
00:06:26,220 --> 00:06:29,639
to Upstream Linux and as a as a result a

169
00:06:29,639 --> 00:06:32,100
lot of kernels ran on already a lot of

170
00:06:32,100 --> 00:06:33,780
devices run on already older kernels

171
00:06:33,780 --> 00:06:36,120
that are at least 18 months old

172
00:06:36,120 --> 00:06:39,180
now as a bit of a lookout I can already

173
00:06:39,180 --> 00:06:42,120
tell you how we envision that automation

174
00:06:42,120 --> 00:06:45,060
can improve fetching processes so for

175
00:06:45,060 --> 00:06:46,979
example if you're a maintainer you want

176
00:06:46,979 --> 00:06:48,720
to make sure that you only apply the

177
00:06:48,720 --> 00:06:50,160
patches that are relevant to the device

178
00:06:50,160 --> 00:06:52,560
so you don't waste your effort on

179
00:06:52,560 --> 00:06:54,240
patches that are actually not

180
00:06:54,240 --> 00:06:56,340
exploitable because you don't even have

181
00:06:56,340 --> 00:06:58,080
the components which are affected by the

182
00:06:58,080 --> 00:06:59,819
patch and of course you want to make

183
00:06:59,819 --> 00:07:01,080
sure that you apply all the security

184
00:07:01,080 --> 00:07:03,000
effects that are actually relevant to

185
00:07:03,000 --> 00:07:05,699
you so basically we have a couple of

186
00:07:05,699 --> 00:07:08,160
questions here that our tool logic is

187
00:07:08,160 --> 00:07:10,620
also following the first is is the

188
00:07:10,620 --> 00:07:13,139
vulnerability applicable to the the use

189
00:07:13,139 --> 00:07:16,560
kernel version well if yes then is the

190
00:07:16,560 --> 00:07:19,560
component present in the kernel that is

191
00:07:19,560 --> 00:07:21,599
affected by the vulnerability and

192
00:07:21,599 --> 00:07:24,240
finally also very important if this

193
00:07:24,240 --> 00:07:26,460
affected component is actually enabled

194
00:07:26,460 --> 00:07:28,620
in the kernel config because if not you

195
00:07:28,620 --> 00:07:30,720
don't need to spend a word on that and

196
00:07:30,720 --> 00:07:32,220
find and also a very important question

197
00:07:32,220 --> 00:07:33,960
whether the patch can be applied to set

198
00:07:33,960 --> 00:07:35,520
component this is due to your

199
00:07:35,520 --> 00:07:37,680
customization so it might be that you

200
00:07:37,680 --> 00:07:39,180
already completely changed the code in

201
00:07:39,180 --> 00:07:41,099
this component that you enabled you

202
00:07:41,099 --> 00:07:42,660
might need to think of a custom patch

203
00:07:42,660 --> 00:07:44,639
solution or you decide that you're not

204
00:07:44,639 --> 00:07:46,199
vulnerable to this but this usually

205
00:07:46,199 --> 00:07:48,900
involves a manual process regardless of

206
00:07:48,900 --> 00:07:51,180
automation or not and finally of course

207
00:07:51,180 --> 00:07:52,560
you want to know whether all the

208
00:07:52,560 --> 00:07:55,199
applicable patches were applied or not

209
00:07:55,199 --> 00:07:57,360
so let's continue on the Kernel

210
00:07:57,360 --> 00:07:59,039
lifecycle management

211
00:07:59,039 --> 00:08:01,639
first of all I want to talk about

212
00:08:01,639 --> 00:08:04,860
the main problems of device vendors so

213
00:08:04,860 --> 00:08:07,680
we identified four critical arrays the

214
00:08:07,680 --> 00:08:09,300
first one is determining the life cycle

215
00:08:09,300 --> 00:08:11,039
and the support time frame for security

216
00:08:11,039 --> 00:08:13,319
patches the second is some legal

217
00:08:13,319 --> 00:08:15,360
requirements the third one which is

218
00:08:15,360 --> 00:08:17,460
crucial choosing a Linux kernel version

219
00:08:17,460 --> 00:08:19,199
that supports the maintenance plan that

220
00:08:19,199 --> 00:08:21,599
you have and finally you also have to

221
00:08:21,599 --> 00:08:23,099
align the kernel version and support

222
00:08:23,099 --> 00:08:25,020
right time frame video chipset vendor

223
00:08:25,020 --> 00:08:27,000
and of course you cannot just choose any

224
00:08:27,000 --> 00:08:29,580
chipset vendor because this is highly

225
00:08:29,580 --> 00:08:31,199
dependent on your device's Hardware

226
00:08:31,199 --> 00:08:33,599
Stacks so let's jump into the first

227
00:08:33,599 --> 00:08:34,640
topic

228
00:08:34,640 --> 00:08:38,279
so as I already I already mentioned many

229
00:08:38,279 --> 00:08:40,260
embedded devices have a way longer

230
00:08:40,260 --> 00:08:42,659
expected life than smartphones which is

231
00:08:42,659 --> 00:08:44,760
generally set to two to four but for

232
00:08:44,760 --> 00:08:46,440
example if you have a smart TV you have

233
00:08:46,440 --> 00:08:48,959
maybe 10 years maybe 15 or if you have a

234
00:08:48,959 --> 00:08:51,420
car at least 15 years

235
00:08:51,420 --> 00:08:54,060
so device vendors have to juggle a lot

236
00:08:54,060 --> 00:08:56,580
of different requirements and also some

237
00:08:56,580 --> 00:08:58,560
problems when they want to set a support

238
00:08:58,560 --> 00:09:00,779
time frame first of all as we mentioned

239
00:09:00,779 --> 00:09:02,220
there are legal requirements for

240
00:09:02,220 --> 00:09:04,200
patching there are client expectations

241
00:09:04,200 --> 00:09:06,060
for patching especially by cellular

242
00:09:06,060 --> 00:09:09,000
operators there is fragmentation as a

243
00:09:09,000 --> 00:09:10,680
device vendor you don't have only one

244
00:09:10,680 --> 00:09:12,480
device but you have probably hundreds of

245
00:09:12,480 --> 00:09:15,000
different devices and you you need to

246
00:09:15,000 --> 00:09:15,860
support

247
00:09:15,860 --> 00:09:18,600
them with security updates for many

248
00:09:18,600 --> 00:09:20,760
years and not just one but all of them

249
00:09:20,760 --> 00:09:23,880
and then there are also problems when a

250
00:09:23,880 --> 00:09:25,440
kernel version is fixed by a chipset

251
00:09:25,440 --> 00:09:27,480
vendor and maybe run out of support

252
00:09:27,480 --> 00:09:30,300
during the device's lifetime and in this

253
00:09:30,300 --> 00:09:31,800
case you also have to continue

254
00:09:31,800 --> 00:09:34,740
supporting it with a higher effort and

255
00:09:34,740 --> 00:09:36,959
then a short

256
00:09:36,959 --> 00:09:39,240
consideration on the legal requirements

257
00:09:39,240 --> 00:09:42,120
this is relatively new for example I'm

258
00:09:42,120 --> 00:09:44,459
bringing Europe as a example because we

259
00:09:44,459 --> 00:09:46,440
come from Germany there was an EU

260
00:09:46,440 --> 00:09:49,320
legislation in 2019 which made immediate

261
00:09:49,320 --> 00:09:51,660
mandatory for our device testers the

262
00:09:51,660 --> 00:09:53,880
device vendors basically two things

263
00:09:53,880 --> 00:09:57,000
first of all vendors need to ensure that

264
00:09:57,000 --> 00:09:59,580
end users are aware of the support time

265
00:09:59,580 --> 00:10:01,620
frame and also the security of this

266
00:10:01,620 --> 00:10:04,019
schedule and the second point is that

267
00:10:04,019 --> 00:10:06,000
each divide must be given a security

268
00:10:06,000 --> 00:10:08,040
updates in accordance with the expected

269
00:10:08,040 --> 00:10:10,320
lifetime which may or may not be

270
00:10:10,320 --> 00:10:14,100
happening at the moment and just to show

271
00:10:14,100 --> 00:10:16,800
you how recent business company

272
00:10:16,800 --> 00:10:19,740
countries are also very slow to adapt to

273
00:10:19,740 --> 00:10:22,500
these rules for example in for Germany

274
00:10:22,500 --> 00:10:24,420
it took three years to start enforcing

275
00:10:24,420 --> 00:10:26,519
this which means that basically they

276
00:10:26,519 --> 00:10:29,399
made it effective in this year

277
00:10:29,399 --> 00:10:32,339
so now I'm giving the word to Jacob who

278
00:10:32,339 --> 00:10:34,740
will continue explaining why is it

279
00:10:34,740 --> 00:10:36,420
important to choose the kernel version

280
00:10:36,420 --> 00:10:38,640
right

281
00:10:38,640 --> 00:10:40,440
from the point of view of a device

282
00:10:40,440 --> 00:10:43,019
vendor the first step for in Touching

283
00:10:43,019 --> 00:10:44,880
advice is to decide which characters we

284
00:10:44,880 --> 00:10:47,760
are using and it is always preferable to

285
00:10:47,760 --> 00:10:50,700
use an ATS version but it is always

286
00:10:50,700 --> 00:10:52,800
preferable to get an LTS version which

287
00:10:52,800 --> 00:10:54,779
will get a couple of years of security

288
00:10:54,779 --> 00:10:57,000
sub support from Upstream so from web

289
00:10:57,000 --> 00:10:59,399
stream Linux scanner repositories who

290
00:10:59,399 --> 00:11:01,620
are from the Google AOSP repositories if

291
00:11:01,620 --> 00:11:03,540
it is an Android based device

292
00:11:03,540 --> 00:11:06,540
and in some cases it may also be

293
00:11:06,540 --> 00:11:09,180
necessary to do a major version upgrade

294
00:11:09,180 --> 00:11:10,980
of a kernel within the lifetime of a

295
00:11:10,980 --> 00:11:14,160
device in order to fulfill the lifetime

296
00:11:14,160 --> 00:11:17,700
requirements for patching and and what

297
00:11:17,700 --> 00:11:19,920
should in any case be avoided it's using

298
00:11:19,920 --> 00:11:22,200
an undeported calendar version to us on

299
00:11:22,200 --> 00:11:24,060
QR version which is not an ATS version

300
00:11:24,060 --> 00:11:27,360
it will be out of support pretty soon so

301
00:11:27,360 --> 00:11:29,160
this should be avoided because it is

302
00:11:29,160 --> 00:11:31,320
very hard to backward oil pending

303
00:11:31,320 --> 00:11:33,720
security patches to a non-supported kind

304
00:11:33,720 --> 00:11:35,519
of version especially since many patches

305
00:11:35,519 --> 00:11:38,600
are just not available

306
00:11:39,839 --> 00:11:42,600
so let's look look at the options we

307
00:11:42,600 --> 00:11:44,279
have for the device vendor from the

308
00:11:44,279 --> 00:11:46,860
Upstream Linux the kind of developers we

309
00:11:46,860 --> 00:11:49,200
have several ATS versions We have

310
00:11:49,200 --> 00:11:51,540
currently supported version 4.9 for the

311
00:11:51,540 --> 00:11:54,660
19 5.4 and 5.10

312
00:11:54,660 --> 00:11:57,300
and we can see the device the lifetime

313
00:11:57,300 --> 00:12:00,120
of this version so the latest version

314
00:12:00,120 --> 00:12:01,940
you can get at the moment will be

315
00:12:01,940 --> 00:12:05,459
supported just until December 2026 so

316
00:12:05,459 --> 00:12:07,200
this may not be long enough for your

317
00:12:07,200 --> 00:12:08,640
device especially if you're updating

318
00:12:08,640 --> 00:12:10,800
something like a smart TV or even

319
00:12:10,800 --> 00:12:13,500
Automotive components which may be a lot

320
00:12:13,500 --> 00:12:15,300
maybe in operation during the lifetime

321
00:12:15,300 --> 00:12:16,920
of our car

322
00:12:16,920 --> 00:12:20,459
and apart from the Linux options Android

323
00:12:20,459 --> 00:12:22,500
comment kernel and and for Android

324
00:12:22,500 --> 00:12:24,899
Google as a policy that one given

325
00:12:24,899 --> 00:12:26,820
Android version supports a free latest

326
00:12:26,820 --> 00:12:29,820
scanner version supported by aosd

327
00:12:29,820 --> 00:12:32,040
so if there is an option to upgrade

328
00:12:32,040 --> 00:12:33,779
either Android operating system without

329
00:12:33,779 --> 00:12:36,720
upgrading the kernel but still after a

330
00:12:36,720 --> 00:12:38,399
couple of upgrades you either need to

331
00:12:38,399 --> 00:12:40,860
upgrade your kernel and lately Google

332
00:12:40,860 --> 00:12:44,279
has spent is making efforts to improve

333
00:12:44,279 --> 00:12:46,440
both the situation by enforcing vendors

334
00:12:46,440 --> 00:12:49,320
to support a generic cutter image so you

335
00:12:49,320 --> 00:12:51,600
have one generic kind of image coming

336
00:12:51,600 --> 00:12:54,180
from Google and it will load some custom

337
00:12:54,180 --> 00:12:57,540
modules from conveyors citizenship

338
00:12:57,540 --> 00:12:59,820
vendor or from the device vendor but the

339
00:12:59,820 --> 00:13:01,380
main card is coming from Google and can

340
00:13:01,380 --> 00:13:04,200
be upgraded by Google

341
00:13:04,200 --> 00:13:07,380
so let's let's look at the situation if

342
00:13:07,380 --> 00:13:09,720
we can't find a candle version which is

343
00:13:09,720 --> 00:13:11,579
supported for the full lifetime of a

344
00:13:11,579 --> 00:13:14,339
device in that case you will have to

345
00:13:14,339 --> 00:13:16,139
upgrade to a newer version during the

346
00:13:16,139 --> 00:13:18,420
lifetime of a device and this is very

347
00:13:18,420 --> 00:13:20,100
hard to do without support of which of

348
00:13:20,100 --> 00:13:22,139
the render so in some cases it is

349
00:13:22,139 --> 00:13:24,060
possible to do that without without

350
00:13:24,060 --> 00:13:26,100
explicit support from the chipset vendor

351
00:13:26,100 --> 00:13:28,320
but in many cases it is also completely

352
00:13:28,320 --> 00:13:31,260
impossible for example if if the Chicago

353
00:13:31,260 --> 00:13:32,880
provided private trip that vendor

354
00:13:32,880 --> 00:13:35,519
contains some some or close to us

355
00:13:35,519 --> 00:13:37,980
components or binary blocks which only

356
00:13:37,980 --> 00:13:39,779
support one specific current version and

357
00:13:39,779 --> 00:13:41,220
if a chipset vendor is not failing to

358
00:13:41,220 --> 00:13:43,139
upgrade that there's little you can do

359
00:13:43,139 --> 00:13:45,420
to us they'll support that device

360
00:13:45,420 --> 00:13:47,579
and unfortunately check that vendors are

361
00:13:47,579 --> 00:13:49,200
sometimes reluctant to provide security

362
00:13:49,200 --> 00:13:51,899
upgrades for older chipsets which are

363
00:13:51,899 --> 00:13:54,180
already out of mass production and don't

364
00:13:54,180 --> 00:13:55,920
bring them any more money

365
00:13:55,920 --> 00:13:57,959
and due to these complications in many

366
00:13:57,959 --> 00:14:00,600
cases a major record version upgrade is

367
00:14:00,600 --> 00:14:03,420
not performed and which makes it

368
00:14:03,420 --> 00:14:05,639
effectively impossible for to actually

369
00:14:05,639 --> 00:14:07,620
apply all security upgrades to devices

370
00:14:07,620 --> 00:14:09,839
and with this wonderful reason why many

371
00:14:09,839 --> 00:14:12,480
devices in use today do not have all

372
00:14:12,480 --> 00:14:13,980
security upgrades which should be

373
00:14:13,980 --> 00:14:16,139
applied

374
00:14:16,139 --> 00:14:18,480
so let's talk a bit more about the

375
00:14:18,480 --> 00:14:20,399
effort required for patching unsupported

376
00:14:20,399 --> 00:14:24,000
cargo versions so you have some upgrades

377
00:14:24,000 --> 00:14:26,459
from some security patches from apps in

378
00:14:26,459 --> 00:14:28,620
Linux you may have some Android specific

379
00:14:28,620 --> 00:14:30,959
security upgrades from Google you have

380
00:14:30,959 --> 00:14:32,760
some security upgrades for chipset

381
00:14:32,760 --> 00:14:34,380
specific components from your chipset

382
00:14:34,380 --> 00:14:36,420
vendor and you may also have some device

383
00:14:36,420 --> 00:14:39,720
specific drivers for your device and all

384
00:14:39,720 --> 00:14:41,160
of these components may have security

385
00:14:41,160 --> 00:14:43,139
vulnerabilities and may need patching

386
00:14:43,139 --> 00:14:45,779
and you have to backward all the patches

387
00:14:45,779 --> 00:14:48,360
to your device and backboarding patches

388
00:14:48,360 --> 00:14:50,579
can be a very complex process because it

389
00:14:50,579 --> 00:14:52,199
needs a lot of understanding of

390
00:14:52,199 --> 00:14:54,720
vulnerability and other understanding of

391
00:14:54,720 --> 00:14:56,699
the component being patched

392
00:14:56,699 --> 00:14:57,720
okay

393
00:14:57,720 --> 00:14:59,600
so

394
00:14:59,600 --> 00:15:02,399
so you have so the best way to deliver

395
00:15:02,399 --> 00:15:04,680
this is to talk to your chipset vendor

396
00:15:04,680 --> 00:15:05,940
at the time you are designing your

397
00:15:05,940 --> 00:15:08,459
device and choosing a project set and

398
00:15:08,459 --> 00:15:10,260
you should first of all clarify the

399
00:15:10,260 --> 00:15:12,360
requirements you have so for example the

400
00:15:12,360 --> 00:15:15,120
requirement can could be a patching for

401
00:15:15,120 --> 00:15:17,459
five years and running a supported in

402
00:15:17,459 --> 00:15:19,380
Australia version for five years and

403
00:15:19,380 --> 00:15:22,260
this may lead to a good situation where

404
00:15:22,260 --> 00:15:24,540
you're you know you have to upgrade to a

405
00:15:24,540 --> 00:15:26,160
new ideas current version during the

406
00:15:26,160 --> 00:15:28,139
lifetime of the device and you should

407
00:15:28,139 --> 00:15:30,480
agree on that with the chipset vendors

408
00:15:30,480 --> 00:15:31,560
or whether the chipset vendor is

409
00:15:31,560 --> 00:15:34,320
responsible for actually providing an

410
00:15:34,320 --> 00:15:36,660
upgrade to a new LTS current version

411
00:15:36,660 --> 00:15:39,120
and in some cases it's a trip that

412
00:15:39,120 --> 00:15:41,279
render may not agree to that and this

413
00:15:41,279 --> 00:15:43,019
means that the chipset does not fulfill

414
00:15:43,019 --> 00:15:44,820
your environment so the security

415
00:15:44,820 --> 00:15:46,680
patching is pretty much as important as

416
00:15:46,680 --> 00:15:48,420
the hardware specifications of a chipset

417
00:15:48,420 --> 00:15:50,339
and you may be in a situation where you

418
00:15:50,339 --> 00:15:52,100
have to choose a different chipset

419
00:15:52,100 --> 00:15:54,660
through it your required level of

420
00:15:54,660 --> 00:15:56,519
security patching

421
00:15:56,519 --> 00:15:59,459
and as a last resort you can also as a

422
00:15:59,459 --> 00:16:01,139
backpoint patches without support for a

423
00:16:01,139 --> 00:16:02,820
chipset render but this should be

424
00:16:02,820 --> 00:16:06,240
avoided if that is at all possible

425
00:16:06,240 --> 00:16:09,060
so let's talk about what we are doing to

426
00:16:09,060 --> 00:16:11,339
improve the situation we have

427
00:16:11,339 --> 00:16:13,380
implemented some automatic analysis tool

428
00:16:13,380 --> 00:16:16,279
called Career virtualizer and it allows

429
00:16:16,279 --> 00:16:19,279
allows analyzing one car resource code 3

430
00:16:19,279 --> 00:16:21,959
and see which patches have been applied

431
00:16:21,959 --> 00:16:24,000
and which patches may have been missed

432
00:16:24,000 --> 00:16:26,459
and there are two different positions so

433
00:16:26,459 --> 00:16:28,680
you can look at this problem one is the

434
00:16:28,680 --> 00:16:30,600
position of the device outer drawer that

435
00:16:30,600 --> 00:16:33,959
is for example us so we are often often

436
00:16:33,959 --> 00:16:36,540
get getting a task to to review the

437
00:16:36,540 --> 00:16:38,220
security of an embedded device or an

438
00:16:38,220 --> 00:16:40,680
android-based device for a customer so

439
00:16:40,680 --> 00:16:42,180
in many cases the customer attack

440
00:16:42,180 --> 00:16:45,000
operate to us which are buying devices

441
00:16:45,000 --> 00:16:46,680
from third party vendors and want to

442
00:16:46,680 --> 00:16:49,259
make sure available devices reach the

443
00:16:49,259 --> 00:16:51,000
security requirements

444
00:16:51,000 --> 00:16:53,339
but also some some device vendors also

445
00:16:53,339 --> 00:16:55,019
ask us to test the security of their

446
00:16:55,019 --> 00:16:56,759
devices

447
00:16:56,759 --> 00:17:00,180
and so we are getting a lot of canners

448
00:17:00,180 --> 00:17:02,160
source code trees and you have to check

449
00:17:02,160 --> 00:17:04,619
if they are actually patched or not and

450
00:17:04,619 --> 00:17:06,540
it was clicked quickly here to ask that

451
00:17:06,540 --> 00:17:08,339
to invest manually for a large number of

452
00:17:08,339 --> 00:17:12,179
devices is Not Practical and so we had

453
00:17:12,179 --> 00:17:14,040
to add some automation to deal with this

454
00:17:14,040 --> 00:17:16,260
problem and automatically analyze the

455
00:17:16,260 --> 00:17:18,540
patch status but you can add a few other

456
00:17:18,540 --> 00:17:20,880
problems on this from the side of a

457
00:17:20,880 --> 00:17:23,459
device vendor so as a device vendor you

458
00:17:23,459 --> 00:17:24,780
may have a large number of different

459
00:17:24,780 --> 00:17:27,299
devices to report the devices may be

460
00:17:27,299 --> 00:17:30,059
running different kernel versions and

461
00:17:30,059 --> 00:17:32,040
you may have a lot of a lot of car

462
00:17:32,040 --> 00:17:34,740
developers in your team and it is very

463
00:17:34,740 --> 00:17:37,679
hard to confirm or verify that all of

464
00:17:37,679 --> 00:17:38,760
the patches that should have been

465
00:17:38,760 --> 00:17:41,220
applied have actually been applied and

466
00:17:41,220 --> 00:17:42,780
our tool can also help the device

467
00:17:42,780 --> 00:17:45,179
vendors to find gaps in their patching

468
00:17:45,179 --> 00:17:48,240
process and improve situations for their

469
00:17:48,240 --> 00:17:49,380
devices

470
00:17:49,380 --> 00:17:51,299
so let's take a look at how we are doing

471
00:17:51,299 --> 00:17:52,380
it

472
00:17:52,380 --> 00:17:55,740
first of all right we need to find a

473
00:17:55,740 --> 00:17:57,780
database of a security vulnerabilities

474
00:17:57,780 --> 00:18:00,360
and Patch commits over each security

475
00:18:00,360 --> 00:18:03,240
vulnerability we we collects one

476
00:18:03,240 --> 00:18:05,700
Whatever get commits which are patient

477
00:18:05,700 --> 00:18:07,140
vulnerability

478
00:18:07,140 --> 00:18:09,840
and we are filing the finding that from

479
00:18:09,840 --> 00:18:11,940
public good repository from a couple of

480
00:18:11,940 --> 00:18:13,380
different sources

481
00:18:13,380 --> 00:18:16,140
and when we run our analysis logic to

482
00:18:16,140 --> 00:18:17,820
find out whether it hatch is applied or

483
00:18:17,820 --> 00:18:20,039
not so the easiest way to check if a

484
00:18:20,039 --> 00:18:22,860
patch is applied or notice to try if you

485
00:18:22,860 --> 00:18:25,440
can apply the patch if you can apply the

486
00:18:25,440 --> 00:18:27,419
patch and you cannot revert the patch

487
00:18:27,419 --> 00:18:29,520
you can be pretty sure that web patch is

488
00:18:29,520 --> 00:18:31,799
missing but if you can revert the patch

489
00:18:31,799 --> 00:18:34,020
and you can't apply the patch you know

490
00:18:34,020 --> 00:18:35,580
that the patches already applied and

491
00:18:35,580 --> 00:18:38,039
everything is fine

492
00:18:38,039 --> 00:18:40,080
and additionally to that we have an

493
00:18:40,080 --> 00:18:42,299
optional step to instrument the build

494
00:18:42,299 --> 00:18:45,240
system so that we find out which part of

495
00:18:45,240 --> 00:18:46,559
the kernel which files in the

496
00:18:46,559 --> 00:18:49,080
character's country I actually compiled

497
00:18:49,080 --> 00:18:50,760
for a given device for a different given

498
00:18:50,760 --> 00:18:53,580
kernel configuration and this allows us

499
00:18:53,580 --> 00:18:55,559
to ignore patches which are just not

500
00:18:55,559 --> 00:18:57,480
relevant to the device because their

501
00:18:57,480 --> 00:18:59,460
patch trials are not compiled in into my

502
00:18:59,460 --> 00:19:01,260
currently

503
00:19:01,260 --> 00:19:03,360
and we have also spent a lot of time in

504
00:19:03,360 --> 00:19:05,520
optimizing the courses so that the

505
00:19:05,520 --> 00:19:08,100
analysis is running fast and and now we

506
00:19:08,100 --> 00:19:09,720
have reached a point where where we can

507
00:19:09,720 --> 00:19:12,000
run an analysis in less than one minute

508
00:19:12,000 --> 00:19:14,419
for hundreds of cves

509
00:19:14,419 --> 00:19:17,280
so first of all let's take a look at the

510
00:19:17,280 --> 00:19:19,980
process of finding the finding the

511
00:19:19,980 --> 00:19:22,200
difference it is so we take first of all

512
00:19:22,200 --> 00:19:23,520
we have to find the vulnerabilities

513
00:19:23,520 --> 00:19:25,799
remains out of it is the Android

514
00:19:25,799 --> 00:19:27,480
security bulletin which is released

515
00:19:27,480 --> 00:19:29,100
every month by Google

516
00:19:29,100 --> 00:19:31,200
and it typically contains a number of

517
00:19:31,200 --> 00:19:34,260
counter patches and for their own we can

518
00:19:34,260 --> 00:19:36,299
try to find commits for

519
00:19:36,299 --> 00:19:38,640
forever for the vulnerabilities or

520
00:19:38,640 --> 00:19:40,679
commits pattern availability

521
00:19:40,679 --> 00:19:43,380
and for each commit we will we look into

522
00:19:43,380 --> 00:19:45,120
the good repository and check out the

523
00:19:45,120 --> 00:19:47,820
make file and and get the candid version

524
00:19:47,820 --> 00:19:50,400
because you need to know which commit

525
00:19:50,400 --> 00:19:51,960
which patch is for which kind of version

526
00:19:51,960 --> 00:19:53,880
so that we if you have several patches

527
00:19:53,880 --> 00:19:55,919
for example vulnerability we can choose

528
00:19:55,919 --> 00:19:58,500
the closest matching color version

529
00:19:58,500 --> 00:20:00,000
and

530
00:20:00,000 --> 00:20:02,520
then when we have a look for our commits

531
00:20:02,520 --> 00:20:04,740
in different git repository from

532
00:20:04,740 --> 00:20:06,419
different sources such as the Upstream

533
00:20:06,419 --> 00:20:08,760
kit from from Linux where Google Android

534
00:20:08,760 --> 00:20:12,480
git repositories sends them and other

535
00:20:12,480 --> 00:20:14,940
some some repositories from Qualcomm

536
00:20:14,940 --> 00:20:18,299
code or for Chrome specific patches and

537
00:20:18,299 --> 00:20:20,460
we look for the commits we match the

538
00:20:20,460 --> 00:20:22,500
commitment vulnerabilities based on

539
00:20:22,500 --> 00:20:24,780
information in the commits or sometimes

540
00:20:24,780 --> 00:20:26,880
we find a cve ID and we get commit

541
00:20:26,880 --> 00:20:29,039
message quite more often we find an

542
00:20:29,039 --> 00:20:31,320
Android bug idea which can be collated

543
00:20:31,320 --> 00:20:33,059
via a professor we have one via the

544
00:20:33,059 --> 00:20:35,039
Android security button and we find that

545
00:20:35,039 --> 00:20:36,860
and we could commit message

546
00:20:36,860 --> 00:20:39,900
specific purchase we find a qccr

547
00:20:39,900 --> 00:20:42,419
identifier at welcome change request in

548
00:20:42,419 --> 00:20:46,500
the commit message and as of once we

549
00:20:46,500 --> 00:20:48,960
have found one commit for it we often

550
00:20:48,960 --> 00:20:51,000
find a change idea and if we find a

551
00:20:51,000 --> 00:20:53,039
different commit with the same change

552
00:20:53,039 --> 00:20:55,380
ideally if it's pretty much always means

553
00:20:55,380 --> 00:20:57,059
that recommit contains which is same

554
00:20:57,059 --> 00:20:58,980
change threads just for a slightly

555
00:20:58,980 --> 00:21:01,440
different kind of version of events

556
00:21:01,440 --> 00:21:03,660
so we can use that information to

557
00:21:03,660 --> 00:21:05,000
collect which

558
00:21:05,000 --> 00:21:08,160
commits are for which vulnerabilities

559
00:21:08,160 --> 00:21:09,900
and then we can use these commits for

560
00:21:09,900 --> 00:21:12,179
our testing if a patch is applied or not

561
00:21:12,179 --> 00:21:14,700
so let's take a look at it we first try

562
00:21:14,700 --> 00:21:16,559
if attached can be applied which was

563
00:21:16,559 --> 00:21:18,960
called trivia testing and when the other

564
00:21:18,960 --> 00:21:21,419
type of patch can be reverted in some

565
00:21:21,419 --> 00:21:23,520
very rare cases whether the same patch

566
00:21:23,520 --> 00:21:24,840
can be applied but it can also be

567
00:21:24,840 --> 00:21:27,179
reverted that is typically because the

568
00:21:27,179 --> 00:21:29,640
file contains similar sections with the

569
00:21:29,640 --> 00:21:32,280
same context lines and then webhatch

570
00:21:32,280 --> 00:21:34,380
testing is not very reliable so we can't

571
00:21:34,380 --> 00:21:36,900
really deliver a patch is applied or not

572
00:21:36,900 --> 00:21:38,840
in an automated way

573
00:21:38,840 --> 00:21:41,640
but in in most cases we have a clear

574
00:21:41,640 --> 00:21:43,740
indication based on this test if a batch

575
00:21:43,740 --> 00:21:45,539
can be applied or inverted

576
00:21:45,539 --> 00:21:47,460
and although in some cases we have a

577
00:21:47,460 --> 00:21:48,840
situation motor patch cannot be a

578
00:21:48,840 --> 00:21:51,600
guidance cannot be reverted

579
00:21:51,600 --> 00:21:54,120
and in that case we are using a second

580
00:21:54,120 --> 00:21:56,700
another step so we are looking at the

581
00:21:56,700 --> 00:21:58,860
git history of the files being patched

582
00:21:58,860 --> 00:22:01,679
and we are using replicate block hash so

583
00:22:01,679 --> 00:22:03,419
basically a hash of a file we are

584
00:22:03,419 --> 00:22:04,320
testing

585
00:22:04,320 --> 00:22:06,419
and see if we find it anywhere and make

586
00:22:06,419 --> 00:22:09,480
it history before or after the Patch and

587
00:22:09,480 --> 00:22:10,980
if you add some other changes in between

588
00:22:10,980 --> 00:22:13,080
which maker make it impossible to apply

589
00:22:13,080 --> 00:22:15,240
the patch or the virtual patch directly

590
00:22:15,240 --> 00:22:17,400
you can still say that this patch

591
00:22:17,400 --> 00:22:19,860
matches the version long after

592
00:22:19,860 --> 00:22:21,840
a patch has been applied and in that

593
00:22:21,840 --> 00:22:24,720
case we know it is patched or if it if I

594
00:22:24,720 --> 00:22:26,400
match the version long before the patch

595
00:22:26,400 --> 00:22:28,559
was applied we know the patch is not

596
00:22:28,559 --> 00:22:30,960
applied to this curler

597
00:22:30,960 --> 00:22:33,059
so this is where my visit with our main

598
00:22:33,059 --> 00:22:35,039
steps how we are testing whether one

599
00:22:35,039 --> 00:22:37,860
patch is applied or not

600
00:22:37,860 --> 00:22:40,500
and in order to do this and this is in

601
00:22:40,500 --> 00:22:42,720
an efficient way we also have I have

602
00:22:42,720 --> 00:22:44,640
spent quite some time in optimizing the

603
00:22:44,640 --> 00:22:46,440
process so we have introduced some

604
00:22:46,440 --> 00:22:48,299
database based caching

605
00:22:48,299 --> 00:22:50,640
so for example for a git repository is

606
00:22:50,640 --> 00:22:53,940
it is pretty easy to Traverse it from

607
00:22:53,940 --> 00:22:55,679
one commit to a parent commits and then

608
00:22:55,679 --> 00:22:58,140
to referrifying permits and so on but it

609
00:22:58,140 --> 00:23:00,419
is very hard to Traverse it in the other

610
00:23:00,419 --> 00:23:03,059
direction so to find oil commits based

611
00:23:03,059 --> 00:23:05,340
on one given commit because we get the

612
00:23:05,340 --> 00:23:06,960
other structures that was just not made

613
00:23:06,960 --> 00:23:09,000
for it and so we implemented some

614
00:23:09,000 --> 00:23:11,820
database based caching using MySQL to

615
00:23:11,820 --> 00:23:14,899
speed up this process

616
00:23:15,559 --> 00:23:18,179
some results of apply and reversion

617
00:23:18,179 --> 00:23:21,480
tests and the other sample computation

618
00:23:21,480 --> 00:23:24,840
so if we look at look up the file

619
00:23:24,840 --> 00:23:28,799
where file com get blog hash we have to

620
00:23:28,799 --> 00:23:31,200
calculate if I get blockage of file and

621
00:23:31,200 --> 00:23:33,720
in many cases we end up calculating with

622
00:23:33,720 --> 00:23:36,059
needing the same drop Edge for the same

623
00:23:36,059 --> 00:23:38,460
file multiple times for different CVS

624
00:23:38,460 --> 00:23:41,159
being tested and so we pre-computed so

625
00:23:41,159 --> 00:23:43,620
in the beginning of analysis we are we

626
00:23:43,620 --> 00:23:45,480
are calculating the hash of every file

627
00:23:45,480 --> 00:23:47,520
and when caching that so we don't have

628
00:23:47,520 --> 00:23:49,620
to repeat it over and over again for the

629
00:23:49,620 --> 00:23:50,640
same file

630
00:23:50,640 --> 00:23:53,039
and Transplant rotates the parallelizing

631
00:23:53,039 --> 00:23:54,600
the process using the python

632
00:23:54,600 --> 00:23:57,000
multi-processing module which is the

633
00:23:57,000 --> 00:24:00,200
most efficient way to make it

634
00:24:00,200 --> 00:24:03,179
protocolize python programs efficiently

635
00:24:03,179 --> 00:24:06,240
and we are doing it by testing different

636
00:24:06,240 --> 00:24:08,820
CVS on different worker processes and

637
00:24:08,820 --> 00:24:10,799
ways provide sufficient parallelization

638
00:24:10,799 --> 00:24:13,380
since we typically have hundreds of CVS

639
00:24:13,380 --> 00:24:16,500
to be tested and been normally something

640
00:24:16,500 --> 00:24:18,480
like 32 worker processes on a large

641
00:24:18,480 --> 00:24:21,720
machine so having more than 32 web

642
00:24:21,720 --> 00:24:23,820
processes that doesn't actually speed it

643
00:24:23,820 --> 00:24:25,580
up anymore because of some overhead

644
00:24:25,580 --> 00:24:29,100
Soviet by default we are using using the

645
00:24:29,100 --> 00:24:31,200
number of CPU cores available but with a

646
00:24:31,200 --> 00:24:33,559
maximum of 32

647
00:24:33,559 --> 00:24:37,080
and once we have done that this we can

648
00:24:37,080 --> 00:24:39,419
also do some some server testing for

649
00:24:39,419 --> 00:24:42,360
false positives so we have implemented

650
00:24:42,360 --> 00:24:45,419
the build system by introducing some

651
00:24:45,419 --> 00:24:47,460
running directives into every single

652
00:24:47,460 --> 00:24:50,100
file being compiled to into C files into

653
00:24:50,100 --> 00:24:52,919
SMP files and into header files

654
00:24:52,919 --> 00:24:54,900
and then after introducing these run

655
00:24:54,900 --> 00:24:57,059
messages we are running the build system

656
00:24:57,059 --> 00:24:59,760
and connecting with datelog which

657
00:24:59,760 --> 00:25:02,640
contains thousands of one messages

658
00:25:02,640 --> 00:25:04,559
and when we can correlate with running

659
00:25:04,559 --> 00:25:07,020
messages with the files and all the

660
00:25:07,020 --> 00:25:08,640
files being touched being used by the

661
00:25:08,640 --> 00:25:11,159
build system that can be collected and

662
00:25:11,159 --> 00:25:13,679
then we can explicitly exclude patches

663
00:25:13,679 --> 00:25:15,659
which only patch files which are not

664
00:25:15,659 --> 00:25:17,640
even built for this device and this

665
00:25:17,640 --> 00:25:19,260
helps us filtering out some false

666
00:25:19,260 --> 00:25:21,480
positives and additionally to write the

667
00:25:21,480 --> 00:25:23,820
ideas for architecture so we have we

668
00:25:23,820 --> 00:25:25,559
have quite a lot of patches which only

669
00:25:25,559 --> 00:25:28,740
affect specific architectures or chipset

670
00:25:28,740 --> 00:25:30,779
vendors so for example we have patches

671
00:25:30,779 --> 00:25:32,460
specific or Qualcomm there's no need to

672
00:25:32,460 --> 00:25:34,980
test that when when another media record

673
00:25:34,980 --> 00:25:37,860
or we have patches which affect x86 only

674
00:25:37,860 --> 00:25:40,860
there's no need to test that when when a

675
00:25:40,860 --> 00:25:42,179
nursing required for an armed by

676
00:25:42,179 --> 00:25:45,120
smartphone so we can filter out quad

677
00:25:45,120 --> 00:25:46,919
samples positives for patches which are

678
00:25:46,919 --> 00:25:48,900
technically speaking not applied but

679
00:25:48,900 --> 00:25:50,820
which just don't matter for the device

680
00:25:50,820 --> 00:25:53,460
being tested so it is not strictly

681
00:25:53,460 --> 00:25:56,159
necessary to apply this patches

682
00:25:56,159 --> 00:25:58,860
and we have an announcement we have

683
00:25:58,860 --> 00:26:01,080
released it publicly today that is

684
00:26:01,080 --> 00:26:02,700
available on Docker Hub you can find the

685
00:26:02,700 --> 00:26:03,900
url here

686
00:26:03,900 --> 00:26:06,600
and we will either push it out on GitHub

687
00:26:06,600 --> 00:26:08,700
very soon with the build information

688
00:26:08,700 --> 00:26:12,120
feature I have just talked about

689
00:26:12,120 --> 00:26:15,720
so so you can now start using our tool

690
00:26:15,720 --> 00:26:18,360
via Docker and analyzing your own query

691
00:26:18,360 --> 00:26:20,279
whether you are a device vendor a

692
00:26:20,279 --> 00:26:22,980
security tester for embedded devices it

693
00:26:22,980 --> 00:26:25,740
is it is now very easy to just run run

694
00:26:25,740 --> 00:26:28,320
with logic and test test I can result

695
00:26:28,320 --> 00:26:31,200
quickly for Miss patches and improve the

696
00:26:31,200 --> 00:26:32,460
pageant starters

697
00:26:32,460 --> 00:26:36,500
so let's come to our demo

698
00:26:44,600 --> 00:26:47,220
running the demo we are pulling it from

699
00:26:47,220 --> 00:26:49,559
Docker Hub it will normally take quite a

700
00:26:49,559 --> 00:26:51,840
bit more time because it is something

701
00:26:51,840 --> 00:26:55,380
like 10 or 15 gigabytes to download but

702
00:26:55,380 --> 00:26:57,059
we have already downloaded it before the

703
00:26:57,059 --> 00:26:59,520
demo to speed up the process and now we

704
00:26:59,520 --> 00:27:01,140
are running we are starting the analysis

705
00:27:01,140 --> 00:27:03,360
so it is just one single Docker run

706
00:27:03,360 --> 00:27:06,000
command you need one volume per meter

707
00:27:06,000 --> 00:27:08,039
one shared folder which is shared

708
00:27:08,039 --> 00:27:09,419
between the host system and the docker

709
00:27:09,419 --> 00:27:11,100
container it's the current working

710
00:27:11,100 --> 00:27:15,120
directory and when we specify that hold

711
00:27:15,120 --> 00:27:17,940
parameter for the Android 300 First Code

712
00:27:17,940 --> 00:27:20,720
will be tested

713
00:27:22,400 --> 00:27:25,459
[Music]

714
00:27:32,900 --> 00:27:34,980
you have to move it to the other screen

715
00:27:34,980 --> 00:27:38,059
we have a presenter mode

716
00:27:38,820 --> 00:27:41,159
the head with the center mode or can you

717
00:27:41,159 --> 00:27:43,820
move into everything

718
00:27:46,919 --> 00:27:49,919
foreign

719
00:28:16,159 --> 00:28:18,840
yeah so sorry for issues so we have

720
00:28:18,840 --> 00:28:21,840
already put yeah we are just starting

721
00:28:21,840 --> 00:28:24,240
from the beginning so so we are the

722
00:28:24,240 --> 00:28:26,279
first step is to pull the image from

723
00:28:26,279 --> 00:28:29,220
Docker Hub so in a when you are doing it

724
00:28:29,220 --> 00:28:31,140
it takes more time because you have to

725
00:28:31,140 --> 00:28:32,279
download something like 10 or 15

726
00:28:32,279 --> 00:28:34,860
gigabytes and then the next step is to

727
00:28:34,860 --> 00:28:36,539
run the analysis

728
00:28:36,539 --> 00:28:39,360
so here you see the comment you need a

729
00:28:39,360 --> 00:28:41,700
shared directory with a few minutes V

730
00:28:41,700 --> 00:28:43,940
parameter of docker

731
00:28:43,940 --> 00:28:46,500
needs to be tested need to be below the

732
00:28:46,500 --> 00:28:48,659
directory you have to specify a name

733
00:28:48,659 --> 00:28:50,460
which will then be a part of analysis

734
00:28:50,460 --> 00:28:53,460
results and your other need need the

735
00:28:53,460 --> 00:28:55,260
architecture in that case we are testing

736
00:28:55,260 --> 00:28:59,460
and a recent kernel from Google from the

737
00:28:59,460 --> 00:29:02,580
Google Android kernel and

738
00:29:02,580 --> 00:29:05,279
and for their architecture I'm 64 which

739
00:29:05,279 --> 00:29:07,620
is used by modern smartphones and you

740
00:29:07,620 --> 00:29:08,880
also need to specify the output

741
00:29:08,880 --> 00:29:11,039
directory the analysis within the end

742
00:29:11,039 --> 00:29:13,620
show and write one extra file with

743
00:29:13,620 --> 00:29:15,600
results and press one Json file if you

744
00:29:15,600 --> 00:29:17,580
want to analyze it manually or write

745
00:29:17,580 --> 00:29:19,799
your own tools based on that

746
00:29:19,799 --> 00:29:22,279
so now the analysis is running

747
00:29:22,279 --> 00:29:24,779
it will load some

748
00:29:24,779 --> 00:29:27,720
load some data and fairness

749
00:29:27,720 --> 00:29:30,960
if I take a couple of seconds spin it

750
00:29:30,960 --> 00:29:33,360
play computer blockages from the files

751
00:29:33,360 --> 00:29:35,959
being tested

752
00:29:37,279 --> 00:29:39,299
processes and actually testing the

753
00:29:39,299 --> 00:29:40,440
series

754
00:29:40,440 --> 00:29:42,240
to be tested

755
00:29:42,240 --> 00:29:43,799
and it will take about half a minute

756
00:29:43,799 --> 00:29:47,059
until we have the results

757
00:29:51,679 --> 00:29:54,960
okay now we have saved the results and

758
00:29:54,960 --> 00:29:56,700
Regina we now open the extra sheet

759
00:29:56,700 --> 00:29:59,539
generated with it

760
00:30:01,100 --> 00:30:05,100
so here here we see this he has busy

761
00:30:05,100 --> 00:30:07,039
with address most of the order patches

762
00:30:07,039 --> 00:30:09,720
from a couple of years ago are just not

763
00:30:09,720 --> 00:30:11,460
affected because we have a pretty recent

764
00:30:11,460 --> 00:30:14,159
candle and and if a vulnerability is

765
00:30:14,159 --> 00:30:16,320
already patched in the base can release

766
00:30:16,320 --> 00:30:18,659
for a kernel version where there's no

767
00:30:18,659 --> 00:30:20,460
need to attach it in any kind of based

768
00:30:20,460 --> 00:30:22,679
on that so it is not affected

769
00:30:22,679 --> 00:30:24,840
and when I've been scrolling down to a

770
00:30:24,840 --> 00:30:27,059
more reason vulnerabilities we see a

771
00:30:27,059 --> 00:30:28,799
couple of cases where the test failed

772
00:30:28,799 --> 00:30:30,840
because our analysis logic is not

773
00:30:30,840 --> 00:30:33,360
perfect but it also said shows many

774
00:30:33,360 --> 00:30:34,980
cases where a patch has indeed been

775
00:30:34,980 --> 00:30:36,120
applied

776
00:30:36,120 --> 00:30:39,360
and as expected for a reason Google to

777
00:30:39,360 --> 00:30:42,419
handle or with all the patches have been

778
00:30:42,419 --> 00:30:45,360
applied and this is quite expected

779
00:30:45,360 --> 00:30:47,399
because Google is very good at patching

780
00:30:47,399 --> 00:30:49,500
their Android account resource codes

781
00:30:49,500 --> 00:30:52,159
please

782
00:30:54,899 --> 00:30:56,159
yeah

783
00:30:56,159 --> 00:31:00,480
all right then I hope you will get the

784
00:31:00,480 --> 00:31:02,460
chance to try it on your own and

785
00:31:02,460 --> 00:31:05,100
feedback is very much welcome so let us

786
00:31:05,100 --> 00:31:07,440
know how you like it if you have any

787
00:31:07,440 --> 00:31:10,020
problems we will try to solve that and

788
00:31:10,020 --> 00:31:11,340
now I would like to conclude the

789
00:31:11,340 --> 00:31:13,919
presentation with some key takeaways so

790
00:31:13,919 --> 00:31:15,960
first of all we discuss automation a lot

791
00:31:15,960 --> 00:31:18,659
and of course it's great and we believe

792
00:31:18,659 --> 00:31:20,940
this will really help the ecosystem but

793
00:31:20,940 --> 00:31:22,799
it has its limitations and it doesn't

794
00:31:22,799 --> 00:31:24,480
solve all the problems in the Linux

795
00:31:24,480 --> 00:31:26,880
control ecosystem for example it doesn't

796
00:31:26,880 --> 00:31:29,279
solve fragmentation I already mentioned

797
00:31:29,279 --> 00:31:31,320
that many device vendors have a lot of

798
00:31:31,320 --> 00:31:34,140
devices that need to maintain and in

799
00:31:34,140 --> 00:31:35,340
this case this they might just

800
00:31:35,340 --> 00:31:37,440
prioritize the higher end devices that

801
00:31:37,440 --> 00:31:39,179
they sell for a higher price while

802
00:31:39,179 --> 00:31:40,740
neglecting the lower end devices

803
00:31:40,740 --> 00:31:44,100
unfortunately it will also not resolve

804
00:31:44,100 --> 00:31:46,919
the security support for certain cases

805
00:31:46,919 --> 00:31:49,740
because right now it's still very much

806
00:31:49,740 --> 00:31:51,659
not mandated and often too short

807
00:31:51,659 --> 00:31:54,380
compared to the actual time

808
00:31:54,380 --> 00:31:57,840
of life of the device but we believe

809
00:31:57,840 --> 00:32:00,600
that it can solve other other parts of

810
00:32:00,600 --> 00:32:02,880
the development process and we have a

811
00:32:02,880 --> 00:32:05,820
few suggestions so first of all

812
00:32:05,820 --> 00:32:07,980
automation could be used to improve the

813
00:32:07,980 --> 00:32:10,440
patching process during development and

814
00:32:10,440 --> 00:32:12,899
this flowchart that you see here is

815
00:32:12,899 --> 00:32:14,880
exactly the same questions that we asked

816
00:32:14,880 --> 00:32:16,919
earlier during the presentation and

817
00:32:16,919 --> 00:32:19,980
basically uh kernel developers while

818
00:32:19,980 --> 00:32:23,100
patching in the next uh to meet the next

819
00:32:23,100 --> 00:32:25,200
security update deadline they could use

820
00:32:25,200 --> 00:32:26,940
our tool to ensure that they applied

821
00:32:26,940 --> 00:32:29,880
order patches now Jakob mentioned that

822
00:32:29,880 --> 00:32:32,039
kernel petrolyzer automatically applies

823
00:32:32,039 --> 00:32:35,100
sketches as part of the analysis So in

824
00:32:35,100 --> 00:32:37,140
theory this could be also enhanced to

825
00:32:37,140 --> 00:32:38,820
actually start patching in an automated

826
00:32:38,820 --> 00:32:41,640
way however we personally did not test

827
00:32:41,640 --> 00:32:44,159
it and we did not further investigate it

828
00:32:44,159 --> 00:32:45,720
but this is a subject for future

829
00:32:45,720 --> 00:32:47,779
research that we might want to explore

830
00:32:47,779 --> 00:32:51,059
secondly it might be useful for as a

831
00:32:51,059 --> 00:32:53,039
sanity check for device vendors so after

832
00:32:53,039 --> 00:32:55,140
you prepare the security update that you

833
00:32:55,140 --> 00:32:57,720
want to push out you could basically

834
00:32:57,720 --> 00:32:59,820
execute kernel bachelyzer to find out

835
00:32:59,820 --> 00:33:01,620
whether there were any CVS that you

836
00:33:01,620 --> 00:33:03,840
missed that you still need to patch and

837
00:33:03,840 --> 00:33:05,760
we have a side note here the Linux run

838
00:33:05,760 --> 00:33:08,840
has a GPR license which basically

839
00:33:08,840 --> 00:33:12,539
requires device vendors to disclose the

840
00:33:12,539 --> 00:33:15,179
kernel source code publicly however we

841
00:33:15,179 --> 00:33:17,580
saw it during our auditing of admitted

842
00:33:17,580 --> 00:33:19,919
devices and also we know from cellular

843
00:33:19,919 --> 00:33:22,320
operators that this is not not often the

844
00:33:22,320 --> 00:33:24,899
case and device vendors simply failed to

845
00:33:24,899 --> 00:33:26,940
comply with this and do not disclose the

846
00:33:26,940 --> 00:33:29,460
kernel source code however if the device

847
00:33:29,460 --> 00:33:31,740
vendors themselves have this tool which

848
00:33:31,740 --> 00:33:33,720
is now available they can themselves

849
00:33:33,720 --> 00:33:36,179
perform a sanity check or as an internal

850
00:33:36,179 --> 00:33:38,460
verification which might help ensuring

851
00:33:38,460 --> 00:33:40,799
the security of the ecosystem and

852
00:33:40,799 --> 00:33:42,120
finally as I already mentioned

853
00:33:42,120 --> 00:33:44,580
verification is increasingly important

854
00:33:44,580 --> 00:33:46,679
and it's not it's necessary to ensure

855
00:33:46,679 --> 00:33:49,919
security and as a security company we

856
00:33:49,919 --> 00:33:52,080
are doing that for partners we are

857
00:33:52,080 --> 00:33:54,000
running kernel bachelorizer in our

858
00:33:54,000 --> 00:33:56,880
device testing assessments and of course

859
00:33:56,880 --> 00:33:59,340
for the end users and for the operators

860
00:33:59,340 --> 00:34:01,860
external verification is great but also

861
00:34:01,860 --> 00:34:04,080
internal verification by devices vendors

862
00:34:04,080 --> 00:34:05,340
is already improving the current

863
00:34:05,340 --> 00:34:07,140
situation

864
00:34:07,140 --> 00:34:09,659
so this was the closing part of my

865
00:34:09,659 --> 00:34:11,699
presentation with an optimistic note I

866
00:34:11,699 --> 00:34:13,260
hope you enjoyed it and if you have any

867
00:34:13,260 --> 00:34:16,460
questions please let us know

868
00:34:19,918 --> 00:34:22,879
do we have any questions

869
00:34:26,159 --> 00:34:29,219
thanks a lot for your talk I have

870
00:34:29,219 --> 00:34:30,980
several questions first

871
00:34:30,980 --> 00:34:34,080
Linux Linus Torvalds and Greg horror

872
00:34:34,080 --> 00:34:36,659
Hartman say that there there are no

873
00:34:36,659 --> 00:34:39,540
vulnerabilities and all fixes are just

874
00:34:39,540 --> 00:34:44,040
maybe security fixes so they recommend

875
00:34:44,040 --> 00:34:46,739
um follow the stable

876
00:34:46,739 --> 00:34:51,540
uh tree and take and vendors should take

877
00:34:51,540 --> 00:34:53,460
all the patches from stable

878
00:34:53,460 --> 00:34:55,980
and is it possible

879
00:34:55,980 --> 00:34:58,859
or applicable to to your tool to follow

880
00:34:58,859 --> 00:35:01,200
all the stable patches which are coming

881
00:35:01,200 --> 00:35:04,440
because maybe there are some fixes which

882
00:35:04,440 --> 00:35:07,200
didn't get cve but they are security

883
00:35:07,200 --> 00:35:09,720
issues

884
00:35:09,720 --> 00:35:11,700
at the moment we are only testing

885
00:35:11,700 --> 00:35:13,320
vulnerabilities which have been

886
00:35:13,320 --> 00:35:16,440
published with which have a cve ID but

887
00:35:16,440 --> 00:35:18,180
of course the same analysis logic could

888
00:35:18,180 --> 00:35:20,579
be adapted to be used for oil patches

889
00:35:20,579 --> 00:35:23,520
getting patches applied over to one of

890
00:35:23,520 --> 00:35:26,420
the ideas candidates

891
00:35:26,820 --> 00:35:30,800
okay thanks and another question

892
00:35:30,800 --> 00:35:34,940
I know some vendors especially for

893
00:35:34,940 --> 00:35:39,240
Android phones they don't provide the

894
00:35:39,240 --> 00:35:42,000
git repository of the kernel they just

895
00:35:42,000 --> 00:35:43,400
give it

896
00:35:43,400 --> 00:35:46,260
archive with all the source code and so

897
00:35:46,260 --> 00:35:50,220
on so the idea of trying to apply and

898
00:35:50,220 --> 00:35:53,040
revert page doesn't work for that right

899
00:35:53,040 --> 00:35:55,440
yes it works for that and and the

900
00:35:55,440 --> 00:35:57,300
automated tool will not even check for

901
00:35:57,300 --> 00:35:59,760
the git history even if it is available

902
00:35:59,760 --> 00:36:03,240
okay and uh I have a friend

903
00:36:03,240 --> 00:36:04,400
um

904
00:36:04,400 --> 00:36:08,400
his project is CV Hound it is the

905
00:36:08,400 --> 00:36:11,640
project which tests a Linux kernel for

906
00:36:11,640 --> 00:36:13,980
vulnerabilities vulnerability fixes and

907
00:36:13,980 --> 00:36:17,839
it uses the Continental uh semantic

908
00:36:17,839 --> 00:36:21,900
Checker it is like the tool for creating

909
00:36:21,900 --> 00:36:24,960
a automatic batches for Linux kernel and

910
00:36:24,960 --> 00:36:28,500
so on so he writes the descriptions of

911
00:36:28,500 --> 00:36:30,839
the fixes of vulnerabilities in this

912
00:36:30,839 --> 00:36:33,060
semantic grip and just searches for that

913
00:36:33,060 --> 00:36:35,460
maybe it is an idea for you not just

914
00:36:35,460 --> 00:36:39,839
patches but somehow semantic search the

915
00:36:39,839 --> 00:36:41,640
source code of the Linux kernel for the

916
00:36:41,640 --> 00:36:44,040
fix of the vulnerability

917
00:36:44,040 --> 00:36:46,020
yeah we haven't looked into this

918
00:36:46,020 --> 00:36:48,839
semantic search so far that until now we

919
00:36:48,839 --> 00:36:50,520
have just used for patches available in

920
00:36:50,520 --> 00:36:52,920
Android or not

921
00:36:52,920 --> 00:36:56,240
thank you very much thanks for

922
00:36:57,140 --> 00:36:59,280
anyone else

923
00:36:59,280 --> 00:37:02,000
any questions

924
00:37:06,119 --> 00:37:08,579
hi uh great presentation thanks for this

925
00:37:08,579 --> 00:37:11,280
uh my question was that uh from the

926
00:37:11,280 --> 00:37:12,960
command line where do you mention that

927
00:37:12,960 --> 00:37:16,079
which uh SSC vendor it is actually like

928
00:37:16,079 --> 00:37:18,359
where do you get all the patches from

929
00:37:18,359 --> 00:37:21,359
specific to the device

930
00:37:21,359 --> 00:37:23,220
look at that

931
00:37:23,220 --> 00:37:25,920
uh sorry can you repeat the question uh

932
00:37:25,920 --> 00:37:28,380
so basically if a chipset is from

933
00:37:28,380 --> 00:37:30,240
Qualcomm they need to comply with the

934
00:37:30,240 --> 00:37:32,160
Qualcomm patches where do you mention

935
00:37:32,160 --> 00:37:34,859
that in your tool like you need to get

936
00:37:34,859 --> 00:37:37,859
the Qualcomm patches as well right

937
00:37:37,859 --> 00:37:40,140
so when we test for a Qualcomm specific

938
00:37:40,140 --> 00:37:42,240
patch we don't really specify it within

939
00:37:42,240 --> 00:37:44,700
the tool but if you see which CVS are

940
00:37:44,700 --> 00:37:46,560
tested for you can then search for them

941
00:37:46,560 --> 00:37:48,180
and see whether this is a Qualcomm

942
00:37:48,180 --> 00:37:50,220
specific patch or or other chipset

943
00:37:50,220 --> 00:37:53,040
vendor or it is generic kernel

944
00:37:53,040 --> 00:37:56,640
okay thank you

945
00:37:56,640 --> 00:37:59,160
anyone else okay last call for any

946
00:37:59,160 --> 00:38:01,320
questions

947
00:38:01,320 --> 00:38:04,040
thank you

948
00:38:06,540 --> 00:38:07,740
all right thanks again

949
00:38:07,740 --> 00:38:09,060
[Applause]

950
00:38:09,060 --> 00:38:12,130
[Music]

