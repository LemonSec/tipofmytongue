1
00:00:03,020 --> 00:00:06,299
yeah uh hello I'm very excited to be

2
00:00:06,299 --> 00:00:07,799
here at nalcon

3
00:00:07,799 --> 00:00:11,480
um first time here in this conference

4
00:00:12,179 --> 00:00:14,880
um yeah so I guess while people finish

5
00:00:14,880 --> 00:00:18,660
entering the room will start uh

6
00:00:18,660 --> 00:00:20,880
kind of thing so like

7
00:00:20,880 --> 00:00:23,100
basically

8
00:00:23,100 --> 00:00:25,859
um what I'm gonna talk about today is

9
00:00:25,859 --> 00:00:28,560
Android security or Android

10
00:00:28,560 --> 00:00:31,460
vulnerability research

11
00:00:31,460 --> 00:00:34,920
I'm gonna explain basically describe

12
00:00:34,920 --> 00:00:36,960
some sort of vulnerability that I found

13
00:00:36,960 --> 00:00:40,980
and an exploit I wrote for it which I

14
00:00:40,980 --> 00:00:42,120
don't know how many of you follow

15
00:00:42,120 --> 00:00:44,760
closely the Android exploitation world

16
00:00:44,760 --> 00:00:47,579
but I feel it's a bit unique in a way

17
00:00:47,579 --> 00:00:50,100
because I'm using an Android component

18
00:00:50,100 --> 00:00:52,800
that is called the trust Zone

19
00:00:52,800 --> 00:00:56,640
in order to exploit the kernel which

20
00:00:56,640 --> 00:01:00,480
yeah I just thought it's kind of nice

21
00:01:00,480 --> 00:01:03,719
um so before I go into the details a

22
00:01:03,719 --> 00:01:05,280
little bit about me

23
00:01:05,280 --> 00:01:09,180
I started my uh kind of career in cyber

24
00:01:09,180 --> 00:01:12,119
security in the Israeli military I did a

25
00:01:12,119 --> 00:01:13,380
few

26
00:01:13,380 --> 00:01:15,420
a few um

27
00:01:15,420 --> 00:01:17,820
I worked a few years in a vulnerability

28
00:01:17,820 --> 00:01:20,340
researcher in a company called Imperium

29
00:01:20,340 --> 00:01:22,619
I did actually just finish about a year

30
00:01:22,619 --> 00:01:24,240
year and a half stint in something that

31
00:01:24,240 --> 00:01:26,759
was not cyber security and I pretty much

32
00:01:26,759 --> 00:01:29,580
will go back to cyber security next

33
00:01:29,580 --> 00:01:31,740
and also maybe one more fun fact about

34
00:01:31,740 --> 00:01:33,600
me that this is my first time with

35
00:01:33,600 --> 00:01:35,820
nalcon but definitely not my first time

36
00:01:35,820 --> 00:01:39,060
in India I've traveled like multiple

37
00:01:39,060 --> 00:01:41,640
times spending maybe overall about six

38
00:01:41,640 --> 00:01:43,860
or seven months in India and I think

39
00:01:43,860 --> 00:01:45,960
like covering maybe nine or ten States

40
00:01:45,960 --> 00:01:47,880
uh and Counting

41
00:01:47,880 --> 00:01:49,619
so yeah

42
00:01:49,619 --> 00:01:54,000
okay so let's go into the the details so

43
00:01:54,000 --> 00:01:56,759
what will I talk about today

44
00:01:56,759 --> 00:02:01,079
so maybe a good place to point out that

45
00:02:01,079 --> 00:02:03,119
I I'm never sure how to completely

46
00:02:03,119 --> 00:02:04,979
structure these exploit talks because

47
00:02:04,979 --> 00:02:06,960
you as an audience like you're kind of

48
00:02:06,960 --> 00:02:09,060
expected to delve very quickly and very

49
00:02:09,060 --> 00:02:11,459
deep into some very technical details

50
00:02:11,459 --> 00:02:14,280
I'm trying to do it gradually so

51
00:02:14,280 --> 00:02:17,400
I'll start with some brief background

52
00:02:17,400 --> 00:02:20,340
information about what the trust zone is

53
00:02:20,340 --> 00:02:22,620
because I don't know everyone's

54
00:02:22,620 --> 00:02:24,000
background here

55
00:02:24,000 --> 00:02:26,840
I will go then into more details about

56
00:02:26,840 --> 00:02:30,360
the communication protocol around the

57
00:02:30,360 --> 00:02:31,980
Qualcomm trust Zone

58
00:02:31,980 --> 00:02:34,680
because you will see that there is where

59
00:02:34,680 --> 00:02:37,500
the vulnerability is so we'll have to

60
00:02:37,500 --> 00:02:39,540
explain some more technical details

61
00:02:39,540 --> 00:02:41,220
around there

62
00:02:41,220 --> 00:02:44,040
I will often of course describe the

63
00:02:44,040 --> 00:02:45,720
vulnerability that I found

64
00:02:45,720 --> 00:02:48,180
yeah that part I imagine would be quite

65
00:02:48,180 --> 00:02:49,680
short because it's basically describing

66
00:02:49,680 --> 00:02:50,819
a bug

67
00:02:50,819 --> 00:02:55,379
and the longer part will be the

68
00:02:55,379 --> 00:02:58,200
exploit which I guess like every

69
00:02:58,200 --> 00:03:00,060
vulnerability and exploit the exploit is

70
00:03:00,060 --> 00:03:03,300
always complicated and unfortunately I

71
00:03:03,300 --> 00:03:05,280
won't even have time to cover every tiny

72
00:03:05,280 --> 00:03:07,680
detail of the exploit because it does

73
00:03:07,680 --> 00:03:10,140
just doesn't fit in a talk like this

74
00:03:10,140 --> 00:03:12,780
but all I can say is that I am planning

75
00:03:12,780 --> 00:03:14,519
to release very soon probably in the

76
00:03:14,519 --> 00:03:16,560
next few days

77
00:03:16,560 --> 00:03:20,459
um both uh blog posts describing

78
00:03:20,459 --> 00:03:23,400
my research with the full details and

79
00:03:23,400 --> 00:03:25,620
even the source code so if you want to

80
00:03:25,620 --> 00:03:27,300
see everything all the tiny details that

81
00:03:27,300 --> 00:03:29,220
I kind of skip here sometimes

82
00:03:29,220 --> 00:03:31,200
you will be able to see them

83
00:03:31,200 --> 00:03:33,599
and yeah and then I'll finish with some

84
00:03:33,599 --> 00:03:36,120
takeaways from this research which I

85
00:03:36,120 --> 00:03:38,040
think are interesting and and even

86
00:03:38,040 --> 00:03:40,140
though that what I find that this

87
00:03:40,140 --> 00:03:41,580
exploit and vulnerability are a bit

88
00:03:41,580 --> 00:03:43,680
unique compared to other Expos I still

89
00:03:43,680 --> 00:03:44,879
think

90
00:03:44,879 --> 00:03:46,980
um talking about them in connection with

91
00:03:46,980 --> 00:03:49,200
other Android and general exploitation

92
00:03:49,200 --> 00:03:51,000
techniques and mitigations

93
00:03:51,000 --> 00:03:54,239
I I do think it's interesting

94
00:03:54,239 --> 00:03:55,680
um yeah I say that people are still

95
00:03:55,680 --> 00:03:59,599
entering so maybe I'll wait a moment

96
00:04:00,239 --> 00:04:03,480
uh yeah so

97
00:04:03,480 --> 00:04:06,180
yeah let's start with some

98
00:04:06,180 --> 00:04:08,819
brief overview about what the the trust

99
00:04:08,819 --> 00:04:09,840
zone is

100
00:04:09,840 --> 00:04:11,879
so for those who don't know maybe if you

101
00:04:11,879 --> 00:04:13,200
haven't really worked or looked into

102
00:04:13,200 --> 00:04:14,819
Android before

103
00:04:14,819 --> 00:04:16,380
basically

104
00:04:16,380 --> 00:04:19,500
in in Android in every Android phone you

105
00:04:19,500 --> 00:04:21,720
have alongside the Android operating

106
00:04:21,720 --> 00:04:22,860
system

107
00:04:22,860 --> 00:04:25,680
you have another operating system that

108
00:04:25,680 --> 00:04:27,419
is called the trust Zone which is

109
00:04:27,419 --> 00:04:29,220
basically higher privilege operating

110
00:04:29,220 --> 00:04:30,419
system

111
00:04:30,419 --> 00:04:32,880
it is used for mostly things around

112
00:04:32,880 --> 00:04:35,759
cryptography like for example DRM right

113
00:04:35,759 --> 00:04:37,560
so you'd have like Netflix and they send

114
00:04:37,560 --> 00:04:38,400
you

115
00:04:38,400 --> 00:04:41,220
encrypted video file but you still want

116
00:04:41,220 --> 00:04:44,699
to play it on your device so the

117
00:04:44,699 --> 00:04:46,800
um the component that has access to

118
00:04:46,800 --> 00:04:48,660
their raw keys to decrypt that media is

119
00:04:48,660 --> 00:04:51,300
the trust Zone and only the trust Zone

120
00:04:51,300 --> 00:04:53,460
Can Play that video on the device and in

121
00:04:53,460 --> 00:04:55,199
this way Android is not accessible to

122
00:04:55,199 --> 00:04:57,500
the Keys directly

123
00:04:57,500 --> 00:05:01,560
so as I said it is like in this way in

124
00:05:01,560 --> 00:05:03,540
this separation of

125
00:05:03,540 --> 00:05:06,360
components it is higher privileged

126
00:05:06,360 --> 00:05:08,040
so really more privileged than Android

127
00:05:08,040 --> 00:05:09,960
kernel more privileged than kind of

128
00:05:09,960 --> 00:05:13,199
anything in Android and what I think is

129
00:05:13,199 --> 00:05:16,440
interesting here is that it is closed

130
00:05:16,440 --> 00:05:18,419
Source or like it's almost always closed

131
00:05:18,419 --> 00:05:19,380
source

132
00:05:19,380 --> 00:05:22,259
and then if you think about it you have

133
00:05:22,259 --> 00:05:23,759
on your phones

134
00:05:23,759 --> 00:05:26,400
some higher some other operating system

135
00:05:26,400 --> 00:05:28,740
like full operating system which is like

136
00:05:28,740 --> 00:05:30,780
higher privilege and unlike Android

137
00:05:30,780 --> 00:05:33,000
which is mostly open source this one is

138
00:05:33,000 --> 00:05:34,759
completely closed source

139
00:05:34,759 --> 00:05:37,680
and yeah I think for me that was like

140
00:05:37,680 --> 00:05:39,240
the first kind of motivation of doing

141
00:05:39,240 --> 00:05:42,660
this research because I just thought

142
00:05:42,660 --> 00:05:44,580
that it would be interesting to look

143
00:05:44,580 --> 00:05:47,280
into this probably also a good time to

144
00:05:47,280 --> 00:05:49,380
point out that what I'm presenting here

145
00:05:49,380 --> 00:05:52,380
I just did on my free time right I I

146
00:05:52,380 --> 00:05:54,360
talked about my experience before but

147
00:05:54,360 --> 00:05:56,460
this was kind of just stuff that

148
00:05:56,460 --> 00:05:58,020
interested me to look into and I

149
00:05:58,020 --> 00:05:59,639
happened to find this and exploit this

150
00:05:59,639 --> 00:06:01,560
so I'm not coming here with any secret

151
00:06:01,560 --> 00:06:03,300
agenda

152
00:06:03,300 --> 00:06:06,360
so yeah okay so this is Android trust

153
00:06:06,360 --> 00:06:07,139
Zone

154
00:06:07,139 --> 00:06:10,139
so what about the I mentioned in the

155
00:06:10,139 --> 00:06:11,580
title of the talk right the Qualcomm

156
00:06:11,580 --> 00:06:14,460
trust Zone and the truth is that in

157
00:06:14,460 --> 00:06:15,479
Android

158
00:06:15,479 --> 00:06:19,020
every chipset vendor which the main ones

159
00:06:19,020 --> 00:06:21,660
would be a Qualcomm Samsung Huawei and

160
00:06:21,660 --> 00:06:23,400
mediatek

161
00:06:23,400 --> 00:06:26,580
they kind of implement their own or not

162
00:06:26,580 --> 00:06:28,500
kind of they Implement their own trust

163
00:06:28,500 --> 00:06:30,660
Zone and I mentioned the trust Zone

164
00:06:30,660 --> 00:06:33,660
isn't is its own operating system so you

165
00:06:33,660 --> 00:06:36,000
have just different operating systems

166
00:06:36,000 --> 00:06:37,380
completely different between each

167
00:06:37,380 --> 00:06:40,380
chipset vendor so I did my research on

168
00:06:40,380 --> 00:06:42,139
Qualcomm

169
00:06:42,139 --> 00:06:46,020
uh which they call their trust on QC or

170
00:06:46,020 --> 00:06:48,600
QT you can find in some places I think

171
00:06:48,600 --> 00:06:50,220
someone in Qualcomm told me that they

172
00:06:50,220 --> 00:06:52,259
renamed it once the QT for marketing

173
00:06:52,259 --> 00:06:54,300
reasons that I don't understand

174
00:06:54,300 --> 00:06:56,280
I'm still going to use QC just because

175
00:06:56,280 --> 00:06:58,020
that's what I'm used to

176
00:06:58,020 --> 00:07:00,720
and this is also the slide where I try

177
00:07:00,720 --> 00:07:03,000
to kind of show that Qualcomm has a big

178
00:07:03,000 --> 00:07:05,100
deal of a market share I'm not I don't

179
00:07:05,100 --> 00:07:06,780
think it's the best I really couldn't

180
00:07:06,780 --> 00:07:10,139
find that good data but like like this

181
00:07:10,139 --> 00:07:12,360
but like the bottom line that

182
00:07:12,360 --> 00:07:14,100
really really especially if you look at

183
00:07:14,100 --> 00:07:16,560
like high-end Android phones Qualcomm by

184
00:07:16,560 --> 00:07:18,720
far has the the biggest market share

185
00:07:18,720 --> 00:07:22,680
so interesting to research and then I

186
00:07:22,680 --> 00:07:25,199
said okay so we have this higher

187
00:07:25,199 --> 00:07:27,720
privileged operating system running

188
00:07:27,720 --> 00:07:30,419
alongside Android and each chipset has

189
00:07:30,419 --> 00:07:33,960
their own so what prior research has

190
00:07:33,960 --> 00:07:37,919
been done into this Qualcomm one and the

191
00:07:37,919 --> 00:07:39,240
truth is that

192
00:07:39,240 --> 00:07:41,639
personally I feel that this research has

193
00:07:41,639 --> 00:07:45,539
researched into QC is kind of fair

194
00:07:45,539 --> 00:07:48,120
um there was a very thorough set of blog

195
00:07:48,120 --> 00:07:50,699
posts by Galvin yamini but they're kind

196
00:07:50,699 --> 00:07:53,360
of old by now the last one was in 2016.

197
00:07:53,360 --> 00:07:57,720
and since then it's I honestly I always

198
00:07:57,720 --> 00:07:59,639
try to find other public research at

199
00:07:59,639 --> 00:08:02,099
least and it's very very rare to find

200
00:08:02,099 --> 00:08:04,020
which I guess in a way was also a

201
00:08:04,020 --> 00:08:06,180
motivation for me to do this Research

202
00:08:06,180 --> 00:08:08,520
into Qualcomm trust Zone

203
00:08:08,520 --> 00:08:11,419
so yeah

204
00:08:12,900 --> 00:08:15,780
so sorry if it's a bit of an

205
00:08:15,780 --> 00:08:18,360
intimidating slide this is kind of the

206
00:08:18,360 --> 00:08:20,160
general idea of what the trash zone is

207
00:08:20,160 --> 00:08:22,139
like I said you have this other

208
00:08:22,139 --> 00:08:24,000
operating system

209
00:08:24,000 --> 00:08:26,460
that is called like the secure world so

210
00:08:26,460 --> 00:08:28,379
it's like running with higher privileges

211
00:08:28,379 --> 00:08:30,780
but this is something you'll find if you

212
00:08:30,780 --> 00:08:32,339
ever saw a presentation about trust and

213
00:08:32,339 --> 00:08:34,679
most chances you saw something like this

214
00:08:34,679 --> 00:08:37,080
if I narrow the components here to the

215
00:08:37,080 --> 00:08:39,719
relevant parts to my talk it looks like

216
00:08:39,719 --> 00:08:40,799
this

217
00:08:40,799 --> 00:08:44,580
and basically if you think about it we

218
00:08:44,580 --> 00:08:46,320
have this higher privilege operating

219
00:08:46,320 --> 00:08:48,060
system right or like I gave the example

220
00:08:48,060 --> 00:08:51,240
of DRM so we want to play encrypted

221
00:08:51,240 --> 00:08:53,940
media but the encrypted media is still

222
00:08:53,940 --> 00:08:56,100
would still be in the Android user mode

223
00:08:56,100 --> 00:08:58,680
process right so it needs this API to

224
00:08:58,680 --> 00:09:02,300
communicate with the DRM

225
00:09:02,300 --> 00:09:04,580
code basically

226
00:09:04,580 --> 00:09:07,620
and so this communication kind of goes

227
00:09:07,620 --> 00:09:09,980
over a multiple layer as it's shown here

228
00:09:09,980 --> 00:09:13,019
the probably good to remember some terms

229
00:09:13,019 --> 00:09:14,760
here like for example the user mode

230
00:09:14,760 --> 00:09:16,440
process on the trust Zone side is called

231
00:09:16,440 --> 00:09:18,180
the trustlet

232
00:09:18,180 --> 00:09:20,820
so I'm going to use this word a lot and

233
00:09:20,820 --> 00:09:22,800
and then on the Android side for this

234
00:09:22,800 --> 00:09:24,360
communication

235
00:09:24,360 --> 00:09:27,779
a kernel module that is called QC com is

236
00:09:27,779 --> 00:09:29,940
used so let's say an Android user mode

237
00:09:29,940 --> 00:09:32,940
process wants to send a command to the

238
00:09:32,940 --> 00:09:34,980
to a translate it would send a command

239
00:09:34,980 --> 00:09:37,620
to this kernel module and this is a this

240
00:09:37,620 --> 00:09:39,060
is the car model basically does

241
00:09:39,060 --> 00:09:41,279
everything that is needed to be done on

242
00:09:41,279 --> 00:09:43,820
the Linux kernel side

243
00:09:43,820 --> 00:09:48,240
so Yeah just they I think the QC comment

244
00:09:48,240 --> 00:09:50,580
translator Awards I'm gonna repeat quite

245
00:09:50,580 --> 00:09:53,700
a lot and of course QC so yeah

246
00:09:53,700 --> 00:09:56,580
okay so this is basically the the

247
00:09:56,580 --> 00:09:58,860
Qualcomm trust Zone

248
00:09:58,860 --> 00:10:00,560
um yeah I'll go into a bit more

249
00:10:00,560 --> 00:10:02,760
technical details

250
00:10:02,760 --> 00:10:06,260
maybe before that I do want to preface

251
00:10:06,260 --> 00:10:10,860
my uh talk a little bit so like

252
00:10:10,860 --> 00:10:13,320
just like full disclosure this is not

253
00:10:13,320 --> 00:10:15,240
like a complete full root vulnerability

254
00:10:15,240 --> 00:10:17,940
because you would need access to the QC

255
00:10:17,940 --> 00:10:20,160
com kernel model which uh traditionally

256
00:10:20,160 --> 00:10:23,820
is not accessible by regular apps I can

257
00:10:23,820 --> 00:10:25,740
say I have in the past also released an

258
00:10:25,740 --> 00:10:28,200
exploit to to get access to this kernel

259
00:10:28,200 --> 00:10:30,959
model but but yeah I so like I'm not

260
00:10:30,959 --> 00:10:33,120
coming here to basically show oh look at

261
00:10:33,120 --> 00:10:34,740
this amazing vulnerability like it's

262
00:10:34,740 --> 00:10:36,600
gonna you can hack all devices with it

263
00:10:36,600 --> 00:10:39,000
it's more like I'm talking about kind of

264
00:10:39,000 --> 00:10:40,500
different and unique exploitation

265
00:10:40,500 --> 00:10:43,440
techniques and their implications in

266
00:10:43,440 --> 00:10:45,600
general to Android security

267
00:10:45,600 --> 00:10:47,760
and of course this would only work on

268
00:10:47,760 --> 00:10:49,920
Qualcomm devices because yeah it's about

269
00:10:49,920 --> 00:10:52,380
the Qualcomm trust Zone but then on the

270
00:10:52,380 --> 00:10:53,459
other hand

271
00:10:53,459 --> 00:10:55,980
I do think this exploit is very powerful

272
00:10:55,980 --> 00:10:57,720
in its own way and why I think it's

273
00:10:57,720 --> 00:10:59,339
interesting for exploitation techniques

274
00:10:59,339 --> 00:11:00,240
because

275
00:11:00,240 --> 00:11:02,640
you'll see that this is a super

276
00:11:02,640 --> 00:11:05,579
basically 100 reliable exploit which is

277
00:11:05,579 --> 00:11:08,040
I think I feel a bit rare sometimes that

278
00:11:08,040 --> 00:11:10,620
now in Android current exploitation and

279
00:11:10,620 --> 00:11:12,540
not only is that the extra that I wrote

280
00:11:12,540 --> 00:11:15,839
is able to basically exploit all devices

281
00:11:15,839 --> 00:11:17,820
and versions and builds that I tried

282
00:11:17,820 --> 00:11:20,220
without needing adaptation per device

283
00:11:20,220 --> 00:11:22,320
and build which I also think is quite

284
00:11:22,320 --> 00:11:24,660
rare these days

285
00:11:24,660 --> 00:11:27,180
so okay let's go into some technical

286
00:11:27,180 --> 00:11:30,420
details and I'll start with describing

287
00:11:30,420 --> 00:11:32,339
kind of the memory access model here

288
00:11:32,339 --> 00:11:36,180
with the with QC uh Qualcomm trust Zone

289
00:11:36,180 --> 00:11:39,420
so one very important thing to remember

290
00:11:39,420 --> 00:11:41,880
is that QC Works in physical memory

291
00:11:41,880 --> 00:11:45,060
addresses not like not virtual

292
00:11:45,060 --> 00:11:48,180
so yeah just important to remember

293
00:11:48,180 --> 00:11:50,940
and but then the way it works because I

294
00:11:50,940 --> 00:11:52,440
mentioned that QC is kind of more

295
00:11:52,440 --> 00:11:54,920
privileged than the Linux kernel

296
00:11:54,920 --> 00:11:57,779
and basically I'll I guess I'll use

297
00:11:57,779 --> 00:12:00,540
diagrams to show it a bit better so like

298
00:12:00,540 --> 00:12:03,240
let's this would be the physical memory

299
00:12:03,240 --> 00:12:06,540
layout right I mean and if we think

300
00:12:06,540 --> 00:12:08,820
about normal operating systems you would

301
00:12:08,820 --> 00:12:10,920
have like the kernel accessible to to

302
00:12:10,920 --> 00:12:12,839
everything to all physical memory and

303
00:12:12,839 --> 00:12:14,579
each user remote process would carve out

304
00:12:14,579 --> 00:12:16,560
some parts of this physical memory to

305
00:12:16,560 --> 00:12:18,600
only be accessible to it

306
00:12:18,600 --> 00:12:21,120
but now if you add the trust Zone

307
00:12:21,120 --> 00:12:23,700
we see that we also have some region of

308
00:12:23,700 --> 00:12:25,680
physical memory that is used as secure

309
00:12:25,680 --> 00:12:28,200
memory and the Linux kernel can't access

310
00:12:28,200 --> 00:12:29,100
it

311
00:12:29,100 --> 00:12:31,320
the the QC kernel on the other hand can

312
00:12:31,320 --> 00:12:32,959
access everything

313
00:12:32,959 --> 00:12:36,180
and it in turn limits the user mode

314
00:12:36,180 --> 00:12:38,279
processors on the QC side the translates

315
00:12:38,279 --> 00:12:41,519
to only very small regions of their own

316
00:12:41,519 --> 00:12:42,959
memory

317
00:12:42,959 --> 00:12:45,300
but now there comes the question oh but

318
00:12:45,300 --> 00:12:47,220
we want this translate to communicate

319
00:12:47,220 --> 00:12:49,820
with the Android user mode process

320
00:12:49,820 --> 00:12:52,500
an idea we want this communication to be

321
00:12:52,500 --> 00:12:54,300
kind of efficient and not copy memory

322
00:12:54,300 --> 00:12:57,600
all over so is there there should be a

323
00:12:57,600 --> 00:12:59,160
way for them to share memory just for

324
00:12:59,160 --> 00:13:00,839
this communication

325
00:13:00,839 --> 00:13:04,079
so I'll go into that and I'll try to do

326
00:13:04,079 --> 00:13:06,420
it gradually so I'll talk about the

327
00:13:06,420 --> 00:13:08,339
components and first I'll basically I'll

328
00:13:08,339 --> 00:13:10,079
talk about all the components involved

329
00:13:10,079 --> 00:13:12,480
other than QC com other than what

330
00:13:12,480 --> 00:13:14,820
happens between the user mode process

331
00:13:14,820 --> 00:13:17,279
and the Linux kernel and I'll then go

332
00:13:17,279 --> 00:13:19,200
into that mostly also because that's

333
00:13:19,200 --> 00:13:21,060
where the vulnerability is so I'll

334
00:13:21,060 --> 00:13:22,740
finish with that

335
00:13:22,740 --> 00:13:24,180
so

336
00:13:24,180 --> 00:13:26,220
yeah let's talk about this communication

337
00:13:26,220 --> 00:13:28,139
between the normal world to the secure

338
00:13:28,139 --> 00:13:30,180
World I'll start with how it's the kind

339
00:13:30,180 --> 00:13:31,620
of the simple version and it will get

340
00:13:31,620 --> 00:13:33,180
more complicated

341
00:13:33,180 --> 00:13:35,880
so basically when normal World wants to

342
00:13:35,880 --> 00:13:38,100
send a command like the Android

343
00:13:38,100 --> 00:13:40,019
operating system wants to send a command

344
00:13:40,019 --> 00:13:42,180
to the trust Zone to a translate it

345
00:13:42,180 --> 00:13:44,420
sends something called SMC

346
00:13:44,420 --> 00:13:47,940
and I'll perhaps again maybe diagrams

347
00:13:47,940 --> 00:13:50,519
will show it a bit better so let's say I

348
00:13:50,519 --> 00:13:52,079
want to send a command again it's some

349
00:13:52,079 --> 00:13:55,019
sort of IPC RPC mechanism where you have

350
00:13:55,019 --> 00:13:56,639
an input buffer and you expect an output

351
00:13:56,639 --> 00:13:58,800
buffer so in this example I have my

352
00:13:58,800 --> 00:14:00,420
input buffer right I already wrote it to

353
00:14:00,420 --> 00:14:01,560
memory

354
00:14:01,560 --> 00:14:04,740
and now I want to send the command so I

355
00:14:04,740 --> 00:14:07,980
send this SMC and this SMC has basically

356
00:14:07,980 --> 00:14:11,040
two pointers to two buffers like each

357
00:14:11,040 --> 00:14:13,800
with an address and size

358
00:14:13,800 --> 00:14:15,420
um one is where the input is already

359
00:14:15,420 --> 00:14:17,940
written to so and another is where the

360
00:14:17,940 --> 00:14:19,740
output should be written to

361
00:14:19,740 --> 00:14:22,860
and then what the QC kernel does is that

362
00:14:22,860 --> 00:14:25,860
it kind of opens a window right it gives

363
00:14:25,860 --> 00:14:28,079
the translate access to this area of

364
00:14:28,079 --> 00:14:30,779
memory and the translate in turn can if

365
00:14:30,779 --> 00:14:33,360
it's DRM can I don't know decrypt

366
00:14:33,360 --> 00:14:36,600
encrypt whatever and with the

367
00:14:36,600 --> 00:14:38,700
data from the input and write the data

368
00:14:38,700 --> 00:14:41,279
to the output and from here on the

369
00:14:41,279 --> 00:14:43,199
because again this is normal memory

370
00:14:43,199 --> 00:14:46,199
right so the normal world the Android

371
00:14:46,199 --> 00:14:48,120
operating system Linux kernel is

372
00:14:48,120 --> 00:14:50,100
accessible to the output and can just

373
00:14:50,100 --> 00:14:52,139
read it

374
00:14:52,139 --> 00:14:53,820
yeah

375
00:14:53,820 --> 00:14:57,420
but it gets more complicated than that

376
00:14:57,420 --> 00:15:00,240
this was yeah kind of simple

377
00:15:00,240 --> 00:15:03,480
but let's say

378
00:15:03,480 --> 00:15:05,820
um there's a lot of input data or we

379
00:15:05,820 --> 00:15:07,440
want to have some input slash output

380
00:15:07,440 --> 00:15:10,740
data and we want to give the translate a

381
00:15:10,740 --> 00:15:12,060
bunch of different data in different

382
00:15:12,060 --> 00:15:14,180
places around physical memory

383
00:15:14,180 --> 00:15:18,660
and so this basically yeah this

384
00:15:18,660 --> 00:15:20,279
communication protocol supports also

385
00:15:20,279 --> 00:15:21,300
that

386
00:15:21,300 --> 00:15:24,000
and the way it's done that's where it

387
00:15:24,000 --> 00:15:25,860
really gets more complicated that input

388
00:15:25,860 --> 00:15:27,959
buffer that until now only contains raw

389
00:15:27,959 --> 00:15:30,660
data now can only can also contain

390
00:15:30,660 --> 00:15:32,459
pointers to other parts of physical

391
00:15:32,459 --> 00:15:33,959
memory

392
00:15:33,959 --> 00:15:36,360
and yeah it gets more complicated right

393
00:15:36,360 --> 00:15:37,980
because the trustless would also need to

394
00:15:37,980 --> 00:15:39,660
be accessible to to those parts of

395
00:15:39,660 --> 00:15:41,220
physical memory that are being pointed

396
00:15:41,220 --> 00:15:44,639
to and the way it works is that each SMC

397
00:15:44,639 --> 00:15:48,540
can also contain up to for what I kind

398
00:15:48,540 --> 00:15:50,339
of call whitelist entries

399
00:15:50,339 --> 00:15:53,639
that tell basically the QC kernel which

400
00:15:53,639 --> 00:15:55,680
other parts of physical memory the

401
00:15:55,680 --> 00:15:58,740
translate needs to have white listed

402
00:15:58,740 --> 00:16:01,260
so yeah I'll show it with the diagram so

403
00:16:01,260 --> 00:16:03,360
again for example we have now we have

404
00:16:03,360 --> 00:16:06,660
this input buffer and but now it has

405
00:16:06,660 --> 00:16:09,180
this input buffer contains the physical

406
00:16:09,180 --> 00:16:11,459
address basically a pointer to some

407
00:16:11,459 --> 00:16:13,860
somewhere else in physical memory

408
00:16:13,860 --> 00:16:16,260
so we still have this SMC right with an

409
00:16:16,260 --> 00:16:18,959
input and output but now this SMC would

410
00:16:18,959 --> 00:16:20,940
also contain a white list entry

411
00:16:20,940 --> 00:16:23,339
and we look into how this white list

412
00:16:23,339 --> 00:16:25,440
whitelisting mechanism works

413
00:16:25,440 --> 00:16:28,920
and let's say for our example the data

414
00:16:28,920 --> 00:16:30,480
being pointed into is the physical

415
00:16:30,480 --> 00:16:33,480
address that we've so

416
00:16:33,480 --> 00:16:35,579
yeah let's take a look now because this

417
00:16:35,579 --> 00:16:38,040
is interesting about the actual bytes

418
00:16:38,040 --> 00:16:39,540
basically the input buffer this is like

419
00:16:39,540 --> 00:16:41,880
an example and if you look really

420
00:16:41,880 --> 00:16:44,699
closely you can see that four bytes into

421
00:16:44,699 --> 00:16:48,360
the buffer we we have the address right

422
00:16:48,360 --> 00:16:51,540
so this is that beef but now like how

423
00:16:51,540 --> 00:16:53,940
does the whitelist entry looks like you

424
00:16:53,940 --> 00:16:55,380
would expect kind of the simple answer

425
00:16:55,380 --> 00:16:56,820
would be oh so we'll write this enter

426
00:16:56,820 --> 00:16:58,740
would just be like address dead beef and

427
00:16:58,740 --> 00:17:01,380
size whatever and then that buffer is

428
00:17:01,380 --> 00:17:03,660
whitelisted but it's not like that

429
00:17:03,660 --> 00:17:06,839
so the size is there but instead of

430
00:17:06,839 --> 00:17:09,480
having the address it has an offset and

431
00:17:09,480 --> 00:17:11,880
what this offset is basically is offset

432
00:17:11,880 --> 00:17:14,699
into the input buffer of where uh the

433
00:17:14,699 --> 00:17:17,220
address to be whitelisted is so here

434
00:17:17,220 --> 00:17:19,799
it's at four right so what the QC kernel

435
00:17:19,799 --> 00:17:21,540
does here it would with the whitelist

436
00:17:21,540 --> 00:17:24,000
entry go in this example four bytes into

437
00:17:24,000 --> 00:17:25,740
the input buffer with the address there

438
00:17:25,740 --> 00:17:28,079
and nowhere to White list from

439
00:17:28,079 --> 00:17:32,700
and yeah this is a bit of perhaps over

440
00:17:32,700 --> 00:17:34,620
complication perhaps some optimization

441
00:17:34,620 --> 00:17:38,160
to save memory uh to save duplication of

442
00:17:38,160 --> 00:17:40,020
data I'm not entirely sure why Qualcomm

443
00:17:40,020 --> 00:17:42,780
did this but that's how it works

444
00:17:42,780 --> 00:17:46,020
and and yeah I'm from here as I said so

445
00:17:46,020 --> 00:17:48,179
now the translate is accessible both to

446
00:17:48,179 --> 00:17:50,220
what where the input and output buffer

447
00:17:50,220 --> 00:17:53,039
but also to this new other buffer that

448
00:17:53,039 --> 00:17:55,020
is being pointed to from the input

449
00:17:55,020 --> 00:17:56,460
buffer

450
00:17:56,460 --> 00:18:01,020
yeah so this is how it works basically I

451
00:18:01,020 --> 00:18:03,120
said right like this is how it works for

452
00:18:03,120 --> 00:18:05,640
all the components from Linux kernel QC

453
00:18:05,640 --> 00:18:08,460
kernel and translate but how does the

454
00:18:08,460 --> 00:18:10,260
Android user mode process start this

455
00:18:10,260 --> 00:18:11,820
right like it's the actually the

456
00:18:11,820 --> 00:18:13,140
component that starts this whole thing

457
00:18:13,140 --> 00:18:15,179
that sends a command

458
00:18:15,179 --> 00:18:17,820
so of course I said it uses the QC com

459
00:18:17,820 --> 00:18:19,260
kernel module

460
00:18:19,260 --> 00:18:22,500
and for this it uses something uh Linus

461
00:18:22,500 --> 00:18:25,559
kernel mechanism that is called ion

462
00:18:25,559 --> 00:18:27,900
it's something that I feel if you read

463
00:18:27,900 --> 00:18:30,660
some Android kernel uh public research

464
00:18:30,660 --> 00:18:32,460
at least about Android kernel exploits

465
00:18:32,460 --> 00:18:34,380
before you might have noticed like they

466
00:18:34,380 --> 00:18:37,140
kind of appear a lot in this exploit the

467
00:18:37,140 --> 00:18:39,660
ion buffers and

468
00:18:39,660 --> 00:18:41,580
there are some complications of what it

469
00:18:41,580 --> 00:18:43,740
is I'll kind of narrow it into only the

470
00:18:43,740 --> 00:18:45,120
relevant parts to the talk which is

471
00:18:45,120 --> 00:18:47,220
basically it's a buffer that a user mode

472
00:18:47,220 --> 00:18:49,200
process can allocate from you can ask

473
00:18:49,200 --> 00:18:51,360
the kernel to allocate and it receives

474
00:18:51,360 --> 00:18:53,280
back some file descriptor that it can

475
00:18:53,280 --> 00:18:56,820
then M up into its own memory space to

476
00:18:56,820 --> 00:18:59,940
read and write data to that buffer and

477
00:18:59,940 --> 00:19:01,799
the important thing to remember that all

478
00:19:01,799 --> 00:19:03,480
this shared memory that I talked about

479
00:19:03,480 --> 00:19:06,600
before all memory shared between

480
00:19:06,600 --> 00:19:09,480
um normal world and the qcn threat and

481
00:19:09,480 --> 00:19:10,559
secure world

482
00:19:10,559 --> 00:19:13,500
is on this ion buffers all of it

483
00:19:13,500 --> 00:19:16,320
so let's say I'm an Android user mode

484
00:19:16,320 --> 00:19:18,179
process and I want to send a command to

485
00:19:18,179 --> 00:19:19,500
a Translate

486
00:19:19,500 --> 00:19:21,780
what I would do is first I allocate this

487
00:19:21,780 --> 00:19:24,960
ion buffer right and I write the input

488
00:19:24,960 --> 00:19:26,580
data into it

489
00:19:26,580 --> 00:19:29,460
and then I send it to the QC compernel

490
00:19:29,460 --> 00:19:33,840
model via an iotl and that I octl

491
00:19:33,840 --> 00:19:36,600
contains then the file descriptor

492
00:19:36,600 --> 00:19:38,700
of that ion buffer

493
00:19:38,700 --> 00:19:42,360
as well as offsets into that ion buffer

494
00:19:42,360 --> 00:19:44,400
of where I wrote the input buffer into

495
00:19:44,400 --> 00:19:46,679
and where the output buffer should be

496
00:19:46,679 --> 00:19:47,820
written into

497
00:19:47,820 --> 00:19:50,220
and from then on we saw it before right

498
00:19:50,220 --> 00:19:52,140
it goes to the Linux kernel to use the

499
00:19:52,140 --> 00:19:54,240
kernel translate and I talked about how

500
00:19:54,240 --> 00:19:55,620
it works

501
00:19:55,620 --> 00:19:57,120
but

502
00:19:57,120 --> 00:20:00,059
then this there's like I mentioned this

503
00:20:00,059 --> 00:20:02,760
more complicated uh way of doing it

504
00:20:02,760 --> 00:20:05,820
right with pointers and that's yeah

505
00:20:05,820 --> 00:20:07,200
that's where it gets more complicated

506
00:20:07,200 --> 00:20:09,419
because this Android user mode process

507
00:20:09,419 --> 00:20:12,120
needs to have a way to point from the

508
00:20:12,120 --> 00:20:14,820
input buffer to other buffers again

509
00:20:14,820 --> 00:20:16,740
other ion buffers

510
00:20:16,740 --> 00:20:19,559
and but like I mentioned that it's all

511
00:20:19,559 --> 00:20:21,000
on physical addresses right and of

512
00:20:21,000 --> 00:20:22,260
course the user mode process doesn't

513
00:20:22,260 --> 00:20:23,760
know the physical addresses that it

514
00:20:23,760 --> 00:20:25,080
needs to point to

515
00:20:25,080 --> 00:20:27,600
so what it does is that in each ioctl

516
00:20:27,600 --> 00:20:30,299
other than the the main ion file

517
00:20:30,299 --> 00:20:32,039
descriptors you can

518
00:20:32,039 --> 00:20:33,600
add that has the input and output

519
00:20:33,600 --> 00:20:36,059
buffers you can also add up to four

520
00:20:36,059 --> 00:20:38,820
extra ion file descriptors

521
00:20:38,820 --> 00:20:42,120
each one of them alongside an offset and

522
00:20:42,120 --> 00:20:44,760
this kind of tells the the kernel where

523
00:20:44,760 --> 00:20:46,500
the kernel then writes the physical

524
00:20:46,500 --> 00:20:48,720
address there and I'll show how it works

525
00:20:48,720 --> 00:20:51,059
so like if you remember the the input

526
00:20:51,059 --> 00:20:53,160
buffer I talked about before

527
00:20:53,160 --> 00:20:55,980
so like in this example this is how it

528
00:20:55,980 --> 00:20:58,500
would look like before the ioctl how the

529
00:20:58,500 --> 00:21:00,059
user mode what the data the user mode

530
00:21:00,059 --> 00:21:02,160
process wrote there and if you look

531
00:21:02,160 --> 00:21:04,020
closely you see that the address that is

532
00:21:04,020 --> 00:21:05,640
not there because the user mode process

533
00:21:05,640 --> 00:21:07,919
doesn't know what physical address the

534
00:21:07,919 --> 00:21:09,840
ion buffer is at

535
00:21:09,840 --> 00:21:11,520
all it knows is where it wants the

536
00:21:11,520 --> 00:21:13,980
address to be written to so it attaches

537
00:21:13,980 --> 00:21:15,840
this IR file descriptor with an offset

538
00:21:15,840 --> 00:21:18,960
of four and then it's the Kernel's job

539
00:21:18,960 --> 00:21:21,840
to basically go there and and write the

540
00:21:21,840 --> 00:21:24,120
the physical address

541
00:21:24,120 --> 00:21:26,340
and now this looks the same as before

542
00:21:26,340 --> 00:21:28,440
and basically what the kernel does is

543
00:21:28,440 --> 00:21:30,299
kind of it converts right from that iron

544
00:21:30,299 --> 00:21:32,159
file descriptor to a whitelist entry

545
00:21:32,159 --> 00:21:34,380
because the offset is the same and the

546
00:21:34,380 --> 00:21:36,000
kernel knows the size of the ion buffer

547
00:21:36,000 --> 00:21:37,380
as well so it just adds that to the

548
00:21:37,380 --> 00:21:38,700
white list entry

549
00:21:38,700 --> 00:21:41,820
and yeah so from then on WE again I

550
00:21:41,820 --> 00:21:44,899
talked about how it works

551
00:21:44,940 --> 00:21:48,480
um okay so these were like I guess some

552
00:21:48,480 --> 00:21:51,780
complicated technical information

553
00:21:51,780 --> 00:21:54,000
um but this is this is the background

554
00:21:54,000 --> 00:21:56,039
they needed to explain about the

555
00:21:56,039 --> 00:21:59,460
vulnerability uh maybe if you could see

556
00:21:59,460 --> 00:22:01,200
maybe if you think really well right now

557
00:22:01,200 --> 00:22:03,120
I know it's super hard probably super

558
00:22:03,120 --> 00:22:04,799
hard but like in theory you have like

559
00:22:04,799 --> 00:22:06,960
kind of the details to to know what the

560
00:22:06,960 --> 00:22:09,740
vulnerability is

561
00:22:10,740 --> 00:22:12,539
all right

562
00:22:12,539 --> 00:22:14,400
so like

563
00:22:14,400 --> 00:22:16,500
I guess of course there may be the main

564
00:22:16,500 --> 00:22:18,179
the first idea that pops out is like oh

565
00:22:18,179 --> 00:22:19,679
I have this offset it's supposed to be

566
00:22:19,679 --> 00:22:21,360
written into a buffer maybe there's a

567
00:22:21,360 --> 00:22:24,120
buffer overflow if I give a two

568
00:22:24,120 --> 00:22:26,640
two big offset or something and I think

569
00:22:26,640 --> 00:22:28,860
this was actually a cve a few years ago

570
00:22:28,860 --> 00:22:30,240
or something like the vulnerabilities

571
00:22:30,240 --> 00:22:32,580
were there but this is kind of simple

572
00:22:32,580 --> 00:22:34,380
one right

573
00:22:34,380 --> 00:22:35,820
um this is actually a bit more

574
00:22:35,820 --> 00:22:37,320
complicated

575
00:22:37,320 --> 00:22:39,600
so but it's still something about using

576
00:22:39,600 --> 00:22:41,340
these offsets right like the offsets you

577
00:22:41,340 --> 00:22:43,679
can give a different ion file

578
00:22:43,679 --> 00:22:47,220
descriptors in the ioctl so like

579
00:22:47,220 --> 00:22:49,200
if we think about it right so we saw

580
00:22:49,200 --> 00:22:52,320
every physical address is 8 bytes

581
00:22:52,320 --> 00:22:55,320
but like what if we give offsets that

582
00:22:55,320 --> 00:22:59,280
make these addresses overlap each other

583
00:22:59,280 --> 00:23:00,539
so

584
00:23:00,539 --> 00:23:02,940
yeah let's look at it right let's say I

585
00:23:02,940 --> 00:23:05,280
take the same uh same thing as before

586
00:23:05,280 --> 00:23:07,740
this time even same ion file descriptor

587
00:23:07,740 --> 00:23:10,980
to deadbeat but this time I also

588
00:23:10,980 --> 00:23:11,760
um

589
00:23:11,760 --> 00:23:14,100
I'll provide another like another one

590
00:23:14,100 --> 00:23:16,320
with the same a same file descriptor but

591
00:23:16,320 --> 00:23:17,880
with offset of eight

592
00:23:17,880 --> 00:23:20,280
so we saw how it works here right like

593
00:23:20,280 --> 00:23:22,380
the address deadbeat is written here but

594
00:23:22,380 --> 00:23:25,080
then when the kernel once writes the

595
00:23:25,080 --> 00:23:29,220
second one to here so it looks like this

596
00:23:29,220 --> 00:23:31,679
um and then if we look at the whitelist

597
00:23:31,679 --> 00:23:34,679
entries which are then this right and

598
00:23:34,679 --> 00:23:37,020
especially what the first one points to

599
00:23:37,020 --> 00:23:39,659
it now points to that beef that beef

600
00:23:39,659 --> 00:23:42,240
instead of just deadly and and of course

601
00:23:42,240 --> 00:23:44,580
this is just like a random example but

602
00:23:44,580 --> 00:23:47,220
let's let's say in our example that dead

603
00:23:47,220 --> 00:23:49,320
beef was just right there ion buffer

604
00:23:49,320 --> 00:23:51,360
that we as a user mode process should

605
00:23:51,360 --> 00:23:53,100
have had full permissions to read and

606
00:23:53,100 --> 00:23:55,380
write to but that that with that beef is

607
00:23:55,380 --> 00:23:57,360
this super important kernel memory

608
00:23:57,360 --> 00:23:58,080
address

609
00:23:58,080 --> 00:24:00,480
uh at this point the translate will be

610
00:24:00,480 --> 00:24:02,580
accessible to that and we could send

611
00:24:02,580 --> 00:24:04,080
commands to the translate in order to

612
00:24:04,080 --> 00:24:06,360
modify memory there

613
00:24:06,360 --> 00:24:09,840
uh yeah so this is basically the

614
00:24:09,840 --> 00:24:12,480
vulnerability right like I this this

615
00:24:12,480 --> 00:24:15,000
whole complex mechanism of I get the

616
00:24:15,000 --> 00:24:16,440
translate from user and what I get the

617
00:24:16,440 --> 00:24:18,179
translate to have access to some other

618
00:24:18,179 --> 00:24:20,580
memory that I'm not accessible to and

619
00:24:20,580 --> 00:24:22,320
then I would be able to send it commands

620
00:24:22,320 --> 00:24:25,020
to modify that memory

621
00:24:25,020 --> 00:24:27,440
um so yeah that's the vulnerability

622
00:24:27,440 --> 00:24:30,480
maybe one thing I should also note is

623
00:24:30,480 --> 00:24:32,100
that if you look closer there was some

624
00:24:32,100 --> 00:24:34,020
side effect here right if you can see

625
00:24:34,020 --> 00:24:35,400
there's like by the end there there's

626
00:24:35,400 --> 00:24:36,860
like FeFe

627
00:24:36,860 --> 00:24:40,260
that this second second overlapping kind

628
00:24:40,260 --> 00:24:44,940
of uh yeah uh zeroed so ideally to

629
00:24:44,940 --> 00:24:46,380
trigger this vulnerability I would want

630
00:24:46,380 --> 00:24:49,799
to avoid side effects and

631
00:24:49,799 --> 00:24:53,280
I did kind of figure out this so

632
00:24:53,280 --> 00:24:54,480
basically

633
00:24:54,480 --> 00:24:56,880
if I extend if you extend the size of

634
00:24:56,880 --> 00:24:59,159
the input buffer the translate no

635
00:24:59,159 --> 00:25:00,900
component cares like that there's more

636
00:25:00,900 --> 00:25:02,340
data the translate will just stop

637
00:25:02,340 --> 00:25:04,860
reading after a few bytes after if you

638
00:25:04,860 --> 00:25:06,840
just ignore what it doesn't need

639
00:25:06,840 --> 00:25:09,360
so what you can do is basically do all

640
00:25:09,360 --> 00:25:11,640
this address overlapping thing

641
00:25:11,640 --> 00:25:13,860
in the end like add more data to the

642
00:25:13,860 --> 00:25:15,600
input buffer do this whole overlapping

643
00:25:15,600 --> 00:25:17,100
thing in the end like here I push

644
00:25:17,100 --> 00:25:19,500
everything hex 20 bytes forward

645
00:25:19,500 --> 00:25:22,260
and if I know what physical address then

646
00:25:22,260 --> 00:25:25,140
I want to modify I can just hard code it

647
00:25:25,140 --> 00:25:26,220
the

648
00:25:26,220 --> 00:25:28,980
Metro slot will access it this I this

649
00:25:28,980 --> 00:25:30,900
example I could even then modify that

650
00:25:30,900 --> 00:25:35,039
beef dead FFF and it would work

651
00:25:35,039 --> 00:25:38,100
so okay so I have a vulnerability

652
00:25:38,100 --> 00:25:40,440
and now the question is how do I exploit

653
00:25:40,440 --> 00:25:41,880
it

654
00:25:41,880 --> 00:25:44,580
and okay this this is nice right like

655
00:25:44,580 --> 00:25:47,220
okay but but I said it's a very random

656
00:25:47,220 --> 00:25:48,960
example Dead with two dead with dead

657
00:25:48,960 --> 00:25:51,360
beef usually memory layouts would not be

658
00:25:51,360 --> 00:25:53,460
that nice I can't just like do something

659
00:25:53,460 --> 00:25:55,080
that simple to access a very important

660
00:25:55,080 --> 00:25:56,340
memory

661
00:25:56,340 --> 00:25:58,500
I would and then I was thinking maybe I

662
00:25:58,500 --> 00:26:00,120
can shape how can I shape different

663
00:26:00,120 --> 00:26:01,860
physical addresses to construct a

664
00:26:01,860 --> 00:26:04,559
meaningful new physical address but it's

665
00:26:04,559 --> 00:26:07,020
also like with complicated remember I

666
00:26:07,020 --> 00:26:08,700
have this limitation of up to four iron

667
00:26:08,700 --> 00:26:11,039
buffers player or ioctl

668
00:26:11,039 --> 00:26:13,440
and I basically wanted to turn this into

669
00:26:13,440 --> 00:26:16,080
like a full kernel read write primitive

670
00:26:16,080 --> 00:26:18,179
so what I did is basically I read more

671
00:26:18,179 --> 00:26:20,460
of the code and I figured that there is

672
00:26:20,460 --> 00:26:22,679
one more detail that I kind of forgot

673
00:26:22,679 --> 00:26:24,539
about when I was doing this research and

674
00:26:24,539 --> 00:26:27,600
now I intentionally omitted before and I

675
00:26:27,600 --> 00:26:29,880
haven't discussed and this detail is

676
00:26:29,880 --> 00:26:31,820
that if you think about it actually

677
00:26:31,820 --> 00:26:35,760
memory in physical space doesn't have to

678
00:26:35,760 --> 00:26:36,960
be contiguous

679
00:26:36,960 --> 00:26:39,179
and all I've been talking about is

680
00:26:39,179 --> 00:26:42,299
contiguous memory in physical space

681
00:26:42,299 --> 00:26:44,400
technically right this is basic

682
00:26:44,400 --> 00:26:47,460
operating operating system stuff only it

683
00:26:47,460 --> 00:26:48,960
only needs to be contiguous in virtual

684
00:26:48,960 --> 00:26:51,179
memory and if we look at the diagram

685
00:26:51,179 --> 00:26:52,440
right like

686
00:26:52,440 --> 00:26:55,260
like all I need is the contingencies in

687
00:26:55,260 --> 00:26:57,360
virtual memory that's why one of the

688
00:26:57,360 --> 00:26:59,820
reasons we have virtual memory and let's

689
00:26:59,820 --> 00:27:02,760
say we actually got an ion buffer that

690
00:27:02,760 --> 00:27:04,620
has non-contiguous physical memory like

691
00:27:04,620 --> 00:27:06,179
how would the white listing work then

692
00:27:06,179 --> 00:27:08,159
right you can just whitelist a single

693
00:27:08,159 --> 00:27:09,779
buffer in physical memory

694
00:27:09,779 --> 00:27:12,960
so for this example let's say we have

695
00:27:12,960 --> 00:27:14,940
these two buffers in physical memory now

696
00:27:14,940 --> 00:27:17,039
with these addresses

697
00:27:17,039 --> 00:27:19,320
and let's look how this works and this

698
00:27:19,320 --> 00:27:21,720
is where it gets even more complicated

699
00:27:21,720 --> 00:27:24,000
so now we have this non-contiguous ion

700
00:27:24,000 --> 00:27:26,580
and it points here and what the kernel

701
00:27:26,580 --> 00:27:29,039
then writes is something that looks like

702
00:27:29,039 --> 00:27:32,220
this it's a lot of bytes and if we look

703
00:27:32,220 --> 00:27:33,659
into it closely we see that it's

704
00:27:33,659 --> 00:27:36,480
basically an array and each entry in the

705
00:27:36,480 --> 00:27:38,880
array like for example this the first

706
00:27:38,880 --> 00:27:41,100
entry is the first buffer right it has

707
00:27:41,100 --> 00:27:43,679
both the address and the size and then

708
00:27:43,679 --> 00:27:46,020
the second entry is the second buffer it

709
00:27:46,020 --> 00:27:48,659
has both the address and the size

710
00:27:48,659 --> 00:27:50,700
so now it accused the camera basically

711
00:27:50,700 --> 00:27:53,100
knows to White list everything according

712
00:27:53,100 --> 00:27:54,380
to this array

713
00:27:54,380 --> 00:27:57,240
and now the whitelist entry also it has

714
00:27:57,240 --> 00:27:58,919
like some flag there that is turned on

715
00:27:58,919 --> 00:28:00,419
that tells QC kernel oh this is

716
00:28:00,419 --> 00:28:03,480
non-contiguous and then the QC kernel

717
00:28:03,480 --> 00:28:06,000
knows that instead of what used to be

718
00:28:06,000 --> 00:28:07,799
size right there was field there of size

719
00:28:07,799 --> 00:28:09,240
in the whitest country now it's count

720
00:28:09,240 --> 00:28:11,940
because basically the count of

721
00:28:11,940 --> 00:28:14,520
of entries in this array

722
00:28:14,520 --> 00:28:18,539
and yeah so now Jessica kernel knows how

723
00:28:18,539 --> 00:28:20,039
it works and it whitelists everything

724
00:28:20,039 --> 00:28:22,559
according to this and yeah this is how

725
00:28:22,559 --> 00:28:24,980
it works

726
00:28:25,820 --> 00:28:29,940
and if you think about it this is quite

727
00:28:29,940 --> 00:28:32,700
interesting because

728
00:28:32,700 --> 00:28:34,740
like

729
00:28:34,740 --> 00:28:36,840
basically I was talking about

730
00:28:36,840 --> 00:28:39,120
overlapping addresses right

731
00:28:39,120 --> 00:28:41,400
but if you think about it this this way

732
00:28:41,400 --> 00:28:43,200
I have the size in the input buffer as

733
00:28:43,200 --> 00:28:45,720
well so what happens is that by

734
00:28:45,720 --> 00:28:49,020
overlapping data now I not I can more

735
00:28:49,020 --> 00:28:50,640
than just control the address I can also

736
00:28:50,640 --> 00:28:53,340
control the size that is whitelisted

737
00:28:53,340 --> 00:28:56,159
which is very good and now I was like

738
00:28:56,159 --> 00:28:58,140
okay this is this is cool and I was

739
00:28:58,140 --> 00:28:59,580
thinking okay so what what do I want to

740
00:28:59,580 --> 00:29:01,200
rightly straight let's say I can make

741
00:29:01,200 --> 00:29:04,020
this huge buffer whitelisted and and why

742
00:29:04,020 --> 00:29:05,940
not just flightless the whole Linux

743
00:29:05,940 --> 00:29:07,260
scanner memory

744
00:29:07,260 --> 00:29:10,260
like if I could why not and

745
00:29:10,260 --> 00:29:13,140
I looked into it there is a pseudophile

746
00:29:13,140 --> 00:29:15,120
in Linux that kind of tells you how the

747
00:29:15,120 --> 00:29:17,039
physical memory sorry how the physical

748
00:29:17,039 --> 00:29:18,840
memory layout looks like

749
00:29:18,840 --> 00:29:21,779
and I was like okay so so this is what I

750
00:29:21,779 --> 00:29:24,059
I want to White list

751
00:29:24,059 --> 00:29:25,500
um good to know

752
00:29:25,500 --> 00:29:28,500
and so yeah then I was I started to

753
00:29:28,500 --> 00:29:30,240
think so so how do I whitelist this

754
00:29:30,240 --> 00:29:31,140
thing

755
00:29:31,140 --> 00:29:34,140
and and a good a good thing to to

756
00:29:34,140 --> 00:29:36,179
remember is again we are talking about

757
00:29:36,179 --> 00:29:38,520
physical memory physical memory is not

758
00:29:38,520 --> 00:29:40,559
randomized I know every time it would be

759
00:29:40,559 --> 00:29:42,179
the same I know what addresses it would

760
00:29:42,179 --> 00:29:45,000
be at more than that like even the the

761
00:29:45,000 --> 00:29:48,179
start address it's more of an Linux arm

762
00:29:48,179 --> 00:29:50,399
architecture thing like in all devices

763
00:29:50,399 --> 00:29:51,960
that I looked at the big the start

764
00:29:51,960 --> 00:29:54,480
address was even always the same

765
00:29:54,480 --> 00:29:56,640
um yeah way more predictable and easy

766
00:29:56,640 --> 00:29:58,919
than virtual addresses

767
00:29:58,919 --> 00:30:02,460
so yeah so unfortunately

768
00:30:02,460 --> 00:30:05,580
this is the part that I kind of have to

769
00:30:05,580 --> 00:30:07,620
kind of skip some details because it

770
00:30:07,620 --> 00:30:10,200
does get more more complicated and you

771
00:30:10,200 --> 00:30:13,200
know how it is going to explode you like

772
00:30:13,200 --> 00:30:16,080
you kind of construct this mechanism in

773
00:30:16,080 --> 00:30:18,059
order to corrupt data in a certain way

774
00:30:18,059 --> 00:30:19,919
that then is crafted in another way and

775
00:30:19,919 --> 00:30:21,360
then you kind of construct all your

776
00:30:21,360 --> 00:30:22,860
bytes to look in the way that you want

777
00:30:22,860 --> 00:30:23,820
them to look

778
00:30:23,820 --> 00:30:26,760
and again I you're welcome if you want

779
00:30:26,760 --> 00:30:28,320
to like follow me on Twitter because I

780
00:30:28,320 --> 00:30:30,059
will release the source code for this

781
00:30:30,059 --> 00:30:31,380
exploit

782
00:30:31,380 --> 00:30:33,299
so you can see exactly exactly how it

783
00:30:33,299 --> 00:30:35,940
works but this time I'll cover it very

784
00:30:35,940 --> 00:30:39,960
shortly so basically as I said I now

785
00:30:39,960 --> 00:30:42,480
have this option to my overlapping data

786
00:30:42,480 --> 00:30:44,460
to control both the address and the size

787
00:30:44,460 --> 00:30:45,720
that is being

788
00:30:45,720 --> 00:30:47,159
white crystal

789
00:30:47,159 --> 00:30:49,620
so the mechanism the technique that I

790
00:30:49,620 --> 00:30:52,980
came up with is to kind of do it and and

791
00:30:52,980 --> 00:30:55,860
by overlapping data to whitelist

792
00:30:55,860 --> 00:30:57,480
everything from zero because it's kind

793
00:30:57,480 --> 00:30:59,580
of easier to zero an address

794
00:30:59,580 --> 00:31:02,940
so from zero up until and the size of it

795
00:31:02,940 --> 00:31:05,840
would be something that I know for sure

796
00:31:05,840 --> 00:31:09,360
is after kernel memory

797
00:31:09,360 --> 00:31:11,220
in physical layout

798
00:31:11,220 --> 00:31:14,520
so again let's kind of I'll show it here

799
00:31:14,520 --> 00:31:16,260
I have this technique it uses kind of

800
00:31:16,260 --> 00:31:18,899
three iron file descriptors I have this

801
00:31:18,899 --> 00:31:21,500
non-contiguous one like we saw before

802
00:31:21,500 --> 00:31:24,840
and then all I need to know is that this

803
00:31:24,840 --> 00:31:25,620
one

804
00:31:25,620 --> 00:31:28,020
is contiguous and this address is is

805
00:31:28,020 --> 00:31:31,500
after the kernel memory I mean again a

806
00:31:31,500 --> 00:31:33,240
lot of overlapping with bytes and stuff

807
00:31:33,240 --> 00:31:35,640
and so I write it here and I overlap

808
00:31:35,640 --> 00:31:37,260
some more things to zero the the address

809
00:31:37,260 --> 00:31:40,320
and really the most interesting thing is

810
00:31:40,320 --> 00:31:42,659
that like the first whitelist entry that

811
00:31:42,659 --> 00:31:45,059
I end up with and really the the first

812
00:31:45,059 --> 00:31:47,940
entry in the array which is from address

813
00:31:47,940 --> 00:31:51,419
zero to this address that this Fe

814
00:31:51,419 --> 00:31:52,980
address that I know for sure is after

815
00:31:52,980 --> 00:31:54,720
kernel memory

816
00:31:54,720 --> 00:31:58,440
so this was really nice because

817
00:31:58,440 --> 00:32:01,740
I was very excited I was like like this

818
00:32:01,740 --> 00:32:02,940
is what I wanted this should be like

819
00:32:02,940 --> 00:32:04,799
this should be it right like I got the

820
00:32:04,799 --> 00:32:07,980
the faux kernel memory whitelisted

821
00:32:07,980 --> 00:32:09,960
I can just disappointed I can just I

822
00:32:09,960 --> 00:32:11,520
just all I need is just find some

823
00:32:11,520 --> 00:32:13,440
command I can send to a trustlet that

824
00:32:13,440 --> 00:32:15,120
will have a pointer to some data that I

825
00:32:15,120 --> 00:32:16,860
want to modify right should we should be

826
00:32:16,860 --> 00:32:18,080
easy

827
00:32:18,080 --> 00:32:21,559
and it was not easy

828
00:32:21,559 --> 00:32:24,840
so basically translates don't really

829
00:32:24,840 --> 00:32:27,120
have that simple functionality and I

830
00:32:27,120 --> 00:32:28,919
have to do a lot of reversing and the

831
00:32:28,919 --> 00:32:31,320
choices that I reversed a lot a lot I

832
00:32:31,320 --> 00:32:33,539
translate that is called y Divine that

833
00:32:33,539 --> 00:32:36,960
deals with DRM and the challenge there

834
00:32:36,960 --> 00:32:38,940
was mostly because it actually has a lot

835
00:32:38,940 --> 00:32:40,980
of functionality but even just

836
00:32:40,980 --> 00:32:42,720
activating the normal functionality

837
00:32:42,720 --> 00:32:44,520
right I didn't intend to exploit to any

838
00:32:44,520 --> 00:32:46,679
vulnerability there even just using

839
00:32:46,679 --> 00:32:48,659
normal functionality there is quite

840
00:32:48,659 --> 00:32:50,520
tough you need to go through a lot of

841
00:32:50,520 --> 00:32:54,120
like apis and stuff to make it work and

842
00:32:54,120 --> 00:32:56,640
it took me some quite a lot of reversing

843
00:32:56,640 --> 00:32:59,220
work to to do it and unfortunately again

844
00:32:59,220 --> 00:33:00,899
I don't really have the time to talk

845
00:33:00,899 --> 00:33:02,700
about everything I think I can maybe

846
00:33:02,700 --> 00:33:04,380
make a whole presentation just about

847
00:33:04,380 --> 00:33:05,399
that

848
00:33:05,399 --> 00:33:08,640
but eventually I did manage to activate

849
00:33:08,640 --> 00:33:12,059
some functionality which is basically

850
00:33:12,059 --> 00:33:14,100
um like two different uh functionalities

851
00:33:14,100 --> 00:33:16,740
one for encrypt and one for decrypt but

852
00:33:16,740 --> 00:33:18,600
what I know about them is that they both

853
00:33:18,600 --> 00:33:21,539
would use the same symmetrical key

854
00:33:21,539 --> 00:33:24,120
and and if you think about it if you can

855
00:33:24,120 --> 00:33:26,340
encrypt and then decrypt the memory

856
00:33:26,340 --> 00:33:28,679
using the same symmetrical key it's

857
00:33:28,679 --> 00:33:30,960
basically equals copy right it's like

858
00:33:30,960 --> 00:33:34,200
just a harder weight but to do copy so

859
00:33:34,200 --> 00:33:37,019
yeah this is enough to copy memory from

860
00:33:37,019 --> 00:33:40,080
one place to another and now finally

861
00:33:40,080 --> 00:33:41,700
after I had this

862
00:33:41,700 --> 00:33:45,600
I I basically had arbitrary read and

863
00:33:45,600 --> 00:33:48,419
write right because I had copy from

864
00:33:48,419 --> 00:33:49,980
addresses that I control from one

865
00:33:49,980 --> 00:33:51,659
address to another address I have the

866
00:33:51,659 --> 00:33:53,399
whole kernel memory right listed so the

867
00:33:53,399 --> 00:33:56,519
trust that can access these addresses so

868
00:33:56,519 --> 00:33:58,080
I can just send the commands to the

869
00:33:58,080 --> 00:34:01,200
translate and we get read write copy

870
00:34:01,200 --> 00:34:03,659
anything from some address to some other

871
00:34:03,659 --> 00:34:06,179
memory that I can read or write other

872
00:34:06,179 --> 00:34:07,620
way around

873
00:34:07,620 --> 00:34:11,099
so this was amazing and finally I had

874
00:34:11,099 --> 00:34:13,679
like a full working exploit I looked up

875
00:34:13,679 --> 00:34:15,119
like for example what was the physical

876
00:34:15,119 --> 00:34:16,320
address

877
00:34:16,320 --> 00:34:19,139
of the symbol that decides if SC Linux

878
00:34:19,139 --> 00:34:20,399
is on or off

879
00:34:20,399 --> 00:34:22,859
I change it to zero and SC Linux was

880
00:34:22,859 --> 00:34:24,060
disabled

881
00:34:24,060 --> 00:34:25,619
so amazing

882
00:34:25,619 --> 00:34:28,440
but then I thought this is actually a

883
00:34:28,440 --> 00:34:30,060
pretty strong primitive like read and

884
00:34:30,060 --> 00:34:32,580
write on physical memory what if I don't

885
00:34:32,580 --> 00:34:34,320
need to look up for every build the

886
00:34:34,320 --> 00:34:36,839
physical address that I want to modify

887
00:34:36,839 --> 00:34:40,320
and for this I used a mechanism in the

888
00:34:40,320 --> 00:34:43,080
Linux kernel that is called kl's themes

889
00:34:43,080 --> 00:34:46,080
basically it keeps track in memory of

890
00:34:46,080 --> 00:34:48,300
where what addresses are of all the

891
00:34:48,300 --> 00:34:51,839
symbols and I wrote some code that kind

892
00:34:51,839 --> 00:34:54,060
of scans through the whole kernel memory

893
00:34:54,060 --> 00:34:55,500
to find this

894
00:34:55,500 --> 00:34:56,940
to find what something that looks like

895
00:34:56,940 --> 00:34:59,880
it parachute and this way I was able to

896
00:34:59,880 --> 00:35:02,640
yeah know the addresses of it's simple I

897
00:35:02,640 --> 00:35:06,060
want to modify and by this point this my

898
00:35:06,060 --> 00:35:09,060
exploit worked on all devices and

899
00:35:09,060 --> 00:35:10,500
versions that I traded on which was

900
00:35:10,500 --> 00:35:12,240
super cool without needing any

901
00:35:12,240 --> 00:35:14,520
adaptations disable the cylinders and

902
00:35:14,520 --> 00:35:15,599
all of them

903
00:35:15,599 --> 00:35:18,180
which yeah I think is really really nice

904
00:35:18,180 --> 00:35:21,839
so yeah that that's the exploit

905
00:35:21,839 --> 00:35:24,119
um if you lost me at some point maybe

906
00:35:24,119 --> 00:35:26,460
that's where it gets a bit a little bit

907
00:35:26,460 --> 00:35:28,920
less technical back

908
00:35:28,920 --> 00:35:30,420
um yeah I'll talk about some some

909
00:35:30,420 --> 00:35:32,460
takeaways from my research and how does

910
00:35:32,460 --> 00:35:34,740
it compare to other Android and kernel

911
00:35:34,740 --> 00:35:36,180
exploitation

912
00:35:36,180 --> 00:35:37,980
so

913
00:35:37,980 --> 00:35:41,400
why is this exploit powerful and I think

914
00:35:41,400 --> 00:35:43,500
the the first thing is that again it's

915
00:35:43,500 --> 00:35:45,480
super reliable which is already a bit

916
00:35:45,480 --> 00:35:46,920
weird I think in kernel exploitation

917
00:35:46,920 --> 00:35:48,660
especially with Android

918
00:35:48,660 --> 00:35:50,940
and if you think about it I never

919
00:35:50,940 --> 00:35:52,500
actually encountered any security

920
00:35:52,500 --> 00:35:54,900
mitigation exploiting it right like

921
00:35:54,900 --> 00:35:57,240
first of all it is what is called like

922
00:35:57,240 --> 00:36:00,420
database which I also think is quite a

923
00:36:00,420 --> 00:36:01,980
trend in Android kernel exploitation

924
00:36:01,980 --> 00:36:03,780
which is basically says okay so we have

925
00:36:03,780 --> 00:36:05,640
all these mitigations that deal with

926
00:36:05,640 --> 00:36:07,800
code executions but if you want to

927
00:36:07,800 --> 00:36:09,240
exploit something all we need is just to

928
00:36:09,240 --> 00:36:10,920
modify the data right we don't have to

929
00:36:10,920 --> 00:36:12,900
run a Shell Code or a Rob if we don't

930
00:36:12,900 --> 00:36:14,820
like it's just like a way to get things

931
00:36:14,820 --> 00:36:16,560
done but if we can just modify the data

932
00:36:16,560 --> 00:36:18,960
get our give ourselves root we one can

933
00:36:18,960 --> 00:36:20,160
also just do that

934
00:36:20,160 --> 00:36:22,680
so that already kind of ignores a lot of

935
00:36:22,680 --> 00:36:24,720
mitigations but then like for example

936
00:36:24,720 --> 00:36:26,640
one mitigation that a lot of exploits

937
00:36:26,640 --> 00:36:28,859
have to deal with is like aslr right but

938
00:36:28,859 --> 00:36:31,040
but I worked on physical memory

939
00:36:31,040 --> 00:36:33,599
addresses are not randomized there so no

940
00:36:33,599 --> 00:36:37,140
aslr and and even of course I can't say

941
00:36:37,140 --> 00:36:38,640
I fully tested it because you don't

942
00:36:38,640 --> 00:36:41,520
really have Qualcomm devices with mte

943
00:36:41,520 --> 00:36:44,520
but it is this mitigation that people I

944
00:36:44,520 --> 00:36:45,839
feel in the security world love to

945
00:36:45,839 --> 00:36:47,460
discuss this like kind of future

946
00:36:47,460 --> 00:36:49,800
mitigation memory tagging and if you

947
00:36:49,800 --> 00:36:51,780
think about it also this mitigation is

948
00:36:51,780 --> 00:36:54,660
in Virtual space So in theory this

949
00:36:54,660 --> 00:36:57,480
exploit should also work with empty

950
00:36:57,480 --> 00:37:00,000
and yeah I guess the other nice thing is

951
00:37:00,000 --> 00:37:01,680
that like I don't need to adapt this

952
00:37:01,680 --> 00:37:04,800
exploit like pair build which is also

953
00:37:04,800 --> 00:37:05,640
nice

954
00:37:05,640 --> 00:37:08,339
so yeah

955
00:37:08,339 --> 00:37:09,119
um

956
00:37:09,119 --> 00:37:11,220
so then I looked I also looked I was

957
00:37:11,220 --> 00:37:13,320
curious like so what other exploits they

958
00:37:13,320 --> 00:37:15,540
are in the Android world with related to

959
00:37:15,540 --> 00:37:17,880
physical addresses the ones I found were

960
00:37:17,880 --> 00:37:19,440
all around the GPU

961
00:37:19,440 --> 00:37:21,300
uh only the last one he actually

962
00:37:21,300 --> 00:37:23,040
completed it to a full exploit the first

963
00:37:23,040 --> 00:37:25,079
two it was more like POC of changing

964
00:37:25,079 --> 00:37:28,440
some uh data in the kernel memory and

965
00:37:28,440 --> 00:37:30,660
was enough for them

966
00:37:30,660 --> 00:37:32,940
says that I think maybe this will become

967
00:37:32,940 --> 00:37:34,380
a bit more of a trend especially

968
00:37:34,380 --> 00:37:36,720
mitigations get stronger if Mt is ever

969
00:37:36,720 --> 00:37:38,339
fully fully introduced and becomes a

970
00:37:38,339 --> 00:37:39,660
mainstream thing

971
00:37:39,660 --> 00:37:42,119
so yeah I think it's interesting this is

972
00:37:42,119 --> 00:37:43,859
what I think it's really interesting I

973
00:37:43,859 --> 00:37:46,320
even found like this analysis from

974
00:37:46,320 --> 00:37:49,800
Project zero of some vulnerability of

975
00:37:49,800 --> 00:37:52,440
some exploit they found in the wild but

976
00:37:52,440 --> 00:37:53,940
they didn't have the exploit and then

977
00:37:53,940 --> 00:37:55,740
they were kind of analyzing so what

978
00:37:55,740 --> 00:37:57,480
could be done to mitigate this even we

979
00:37:57,480 --> 00:37:59,339
didn't really know how the exploit or

980
00:37:59,339 --> 00:38:01,980
they just had the vulnerability and what

981
00:38:01,980 --> 00:38:04,680
they say there is like oh if if like

982
00:38:04,680 --> 00:38:06,420
it's a classical memory corruption then

983
00:38:06,420 --> 00:38:08,400
probably like memory tagging would

984
00:38:08,400 --> 00:38:11,099
mitigate this but it was in the GPU this

985
00:38:11,099 --> 00:38:13,200
vulnerability so then they say oh but if

986
00:38:13,200 --> 00:38:15,720
if it's like granting arbitrary physical

987
00:38:15,720 --> 00:38:17,640
memory redrive then basically to

988
00:38:17,640 --> 00:38:19,740
mitigate this we would require further

989
00:38:19,740 --> 00:38:21,599
study which I guess is another word to

990
00:38:21,599 --> 00:38:23,940
say that there's no really good idea of

991
00:38:23,940 --> 00:38:25,940
what to mitigate it

992
00:38:25,940 --> 00:38:28,800
so yeah

993
00:38:28,800 --> 00:38:31,440
um some are takeaways that I think is

994
00:38:31,440 --> 00:38:33,119
interesting is like again like I said I

995
00:38:33,119 --> 00:38:34,920
think Research into QC is relatively

996
00:38:34,920 --> 00:38:36,119
rare

997
00:38:36,119 --> 00:38:37,740
I

998
00:38:37,740 --> 00:38:40,500
like like I said like so like

999
00:38:40,500 --> 00:38:42,660
I said that QC is closed source and

1000
00:38:42,660 --> 00:38:44,640
while QC com the kernel module is in the

1001
00:38:44,640 --> 00:38:47,520
Linux kernel so it's open source for me

1002
00:38:47,520 --> 00:38:49,020
to really do this research I had to

1003
00:38:49,020 --> 00:38:51,780
reverse uh some parts in QC because it's

1004
00:38:51,780 --> 00:38:53,880
a communication protocol and honestly

1005
00:38:53,880 --> 00:38:55,440
the open source part is kind of

1006
00:38:55,440 --> 00:38:57,180
undocumented well it's kind of hard to

1007
00:38:57,180 --> 00:38:58,440
tell what some of the stuff there are

1008
00:38:58,440 --> 00:38:59,160
doing

1009
00:38:59,160 --> 00:39:02,280
so I feel that the reverse reversing was

1010
00:39:02,280 --> 00:39:03,900
very useful here and I hope that maybe

1011
00:39:03,900 --> 00:39:06,060
in this research I always able to shed

1012
00:39:06,060 --> 00:39:07,920
some light in this on this communication

1013
00:39:07,920 --> 00:39:09,000
protocol

1014
00:39:09,000 --> 00:39:11,339
and if any of you would ever want to

1015
00:39:11,339 --> 00:39:13,200
research something like this I hope it

1016
00:39:13,200 --> 00:39:16,260
might have been interesting for you

1017
00:39:16,260 --> 00:39:20,880
so yeah I I think that like maybe even I

1018
00:39:20,880 --> 00:39:23,040
really don't think I like I would find

1019
00:39:23,040 --> 00:39:24,720
this vulnerability without reversing

1020
00:39:24,720 --> 00:39:26,640
also the closed source side even though

1021
00:39:26,640 --> 00:39:28,440
technically if you think about it the

1022
00:39:28,440 --> 00:39:31,200
bug the vulnerability was only on the

1023
00:39:31,200 --> 00:39:33,599
open source size site right the missing

1024
00:39:33,599 --> 00:39:36,000
check was there the closer size did

1025
00:39:36,000 --> 00:39:38,760
everything right

1026
00:39:38,760 --> 00:39:41,400
so that's pretty much it I'll finish

1027
00:39:41,400 --> 00:39:44,520
with one slide about the back the

1028
00:39:44,520 --> 00:39:46,140
timeline of the report and the

1029
00:39:46,140 --> 00:39:48,420
disclosure I don't know if I have too

1030
00:39:48,420 --> 00:39:49,560
much to say about that it's just like I

1031
00:39:49,560 --> 00:39:51,780
usually get asked about it so if you're

1032
00:39:51,780 --> 00:39:53,400
curious about

1033
00:39:53,400 --> 00:39:56,880
how it went this this is how it went

1034
00:39:56,880 --> 00:40:01,880
um so yeah uh that's that's it

1035
00:40:02,020 --> 00:40:09,780
[Applause]

1036
00:40:09,780 --> 00:40:12,119
does anyone have any questions

1037
00:40:12,119 --> 00:40:14,720
Alex

1038
00:40:21,240 --> 00:40:23,099
thanks for a nice talk

1039
00:40:23,099 --> 00:40:26,520
um is it really possible in some use

1040
00:40:26,520 --> 00:40:27,660
case

1041
00:40:27,660 --> 00:40:29,700
for this device to be available for the

1042
00:40:29,700 --> 00:40:32,520
unprivileged user space this bug was

1043
00:40:32,520 --> 00:40:35,460
considered as vulnerability by Google so

1044
00:40:35,460 --> 00:40:39,300
maybe it is possible for some device for

1045
00:40:39,300 --> 00:40:42,500
some application to get access to this

1046
00:40:42,500 --> 00:40:46,560
dfpuc as you said to the kernel model

1047
00:40:46,560 --> 00:40:49,500
yeah this kernel interface I mean

1048
00:40:49,500 --> 00:40:51,420
traditionally I mean two things first

1049
00:40:51,420 --> 00:40:53,460
you never know because Qualcomm is a

1050
00:40:53,460 --> 00:40:55,440
chipset vendor right and they give their

1051
00:40:55,440 --> 00:40:57,180
stuff to oems and you never know what

1052
00:40:57,180 --> 00:40:59,280
oems do with it

1053
00:40:59,280 --> 00:41:01,560
um the how they structure their access

1054
00:41:01,560 --> 00:41:04,020
model and everything and and like I said

1055
00:41:04,020 --> 00:41:05,760
traditionally you do have some like

1056
00:41:05,760 --> 00:41:07,800
Services running in Android user mode

1057
00:41:07,800 --> 00:41:11,460
that have this through access to to this

1058
00:41:11,460 --> 00:41:13,859
kernel model and and the traditional way

1059
00:41:13,859 --> 00:41:16,680
would be that an app would send a like

1060
00:41:16,680 --> 00:41:18,359
some requests to this service and the

1061
00:41:18,359 --> 00:41:21,119
service would send the ioctl I did like

1062
00:41:21,119 --> 00:41:23,760
if you if you look like if you Google

1063
00:41:23,760 --> 00:41:25,380
um I guess my name or you look in my

1064
00:41:25,380 --> 00:41:27,119
Twitter you can see that in the past I

1065
00:41:27,119 --> 00:41:28,859
also published an exploit in one of

1066
00:41:28,859 --> 00:41:30,960
these services that basically gives you

1067
00:41:30,960 --> 00:41:34,079
access to this uh to this kernel module

1068
00:41:34,079 --> 00:41:36,240
so in a way you could like chain them

1069
00:41:36,240 --> 00:41:38,520
together and to have like a full root

1070
00:41:38,520 --> 00:41:40,560
vulnerability so yeah

1071
00:41:40,560 --> 00:41:43,740
nice and um the second question I didn't

1072
00:41:43,740 --> 00:41:49,020
get uh why this kernel ioc deal allowed

1073
00:41:49,020 --> 00:41:52,980
to set specific addresses in the kernel

1074
00:41:52,980 --> 00:41:55,920
space from this user space application

1075
00:41:55,920 --> 00:41:59,940
so it looked like it didn't filter the

1076
00:41:59,940 --> 00:42:02,099
valid and validate the addresses with

1077
00:42:02,099 --> 00:42:06,359
which we provide so okay once again

1078
00:42:06,359 --> 00:42:08,099
um because this part is like really it's

1079
00:42:08,099 --> 00:42:09,720
kind of hard I feel sometimes to

1080
00:42:09,720 --> 00:42:11,400
understand so

1081
00:42:11,400 --> 00:42:12,900
basically

1082
00:42:12,900 --> 00:42:15,359
the all the user mode does is provide

1083
00:42:15,359 --> 00:42:17,280
offsets right it doesn't

1084
00:42:17,280 --> 00:42:20,040
even if you if s me as a user mode right

1085
00:42:20,040 --> 00:42:21,660
because in the translate on each side

1086
00:42:21,660 --> 00:42:23,280
would know okay four bytes into the

1087
00:42:23,280 --> 00:42:24,900
buffer I should have the pointer I

1088
00:42:24,900 --> 00:42:25,920
should have an address there the

1089
00:42:25,920 --> 00:42:27,000
Translate

1090
00:42:27,000 --> 00:42:29,640
if me as a user space processor just

1091
00:42:29,640 --> 00:42:32,099
write directly an address there the

1092
00:42:32,099 --> 00:42:33,720
translate will not be able to access it

1093
00:42:33,720 --> 00:42:35,339
right if I just write the physical

1094
00:42:35,339 --> 00:42:37,740
address directly it will not be able to

1095
00:42:37,740 --> 00:42:39,359
access because that's like the whole

1096
00:42:39,359 --> 00:42:41,400
white listing mechanism I could try it

1097
00:42:41,400 --> 00:42:43,619
will just fail that's why this mechanism

1098
00:42:43,619 --> 00:42:45,480
exists and the only way I can make the

1099
00:42:45,480 --> 00:42:48,300
trust that have access to it is kind of

1100
00:42:48,300 --> 00:42:50,460
by letting the kernel know because the

1101
00:42:50,460 --> 00:42:52,320
kernel is also the one that writes the

1102
00:42:52,320 --> 00:42:54,359
address there but also the one that

1103
00:42:54,359 --> 00:42:56,640
builds the whitelist entries but to send

1104
00:42:56,640 --> 00:42:58,920
to QC kernel and me as using what

1105
00:42:58,920 --> 00:43:00,960
process I don't really have control too

1106
00:43:00,960 --> 00:43:02,520
much about a little but not too much

1107
00:43:02,520 --> 00:43:05,819
about the whitelist entries so I I can't

1108
00:43:05,819 --> 00:43:08,339
really just write whatever the only way

1109
00:43:08,339 --> 00:43:09,960
I can really write whatever address I

1110
00:43:09,960 --> 00:43:12,060
want to there is if I first exploit this

1111
00:43:12,060 --> 00:43:13,619
whole like I showed here with address

1112
00:43:13,619 --> 00:43:15,420
overlapping and stuff to make that whole

1113
00:43:15,420 --> 00:43:17,700
memory whitelisted but by default the

1114
00:43:17,700 --> 00:43:19,740
translate is just not accessible to most

1115
00:43:19,740 --> 00:43:21,599
most I just like to basically all

1116
00:43:21,599 --> 00:43:23,760
addresses I would want to to write there

1117
00:43:23,760 --> 00:43:27,660
so it's like yeah so this bug can be

1118
00:43:27,660 --> 00:43:30,859
called logic bug actually I mean

1119
00:43:30,859 --> 00:43:33,359
I would still consider it is some

1120
00:43:33,359 --> 00:43:34,740
corruption

1121
00:43:34,740 --> 00:43:36,300
um because I still like end up corrupt

1122
00:43:36,300 --> 00:43:39,060
like the missing check was that they

1123
00:43:39,060 --> 00:43:41,160
just forgot I don't know I would

1124
00:43:41,160 --> 00:43:43,380
classify maybe some sort of a mix

1125
00:43:43,380 --> 00:43:45,119
between them yeah because there was like

1126
00:43:45,119 --> 00:43:46,619
it's not like you know classic buffer

1127
00:43:46,619 --> 00:43:48,060
overflow use of the free all of this

1128
00:43:48,060 --> 00:43:49,800
stuff it's but it's like Corruption of

1129
00:43:49,800 --> 00:43:52,140
this like internal protocol structure

1130
00:43:52,140 --> 00:43:54,660
that they just the the fix for this was

1131
00:43:54,660 --> 00:43:55,560
that

1132
00:43:55,560 --> 00:43:58,020
they they added a check to make sure

1133
00:43:58,020 --> 00:44:00,960
that no data can overlap other data from

1134
00:44:00,960 --> 00:44:03,540
this stuff but like so it's like some

1135
00:44:03,540 --> 00:44:04,980
sort of corruption but not the classic

1136
00:44:04,980 --> 00:44:06,780
corruption that you'd usually have in

1137
00:44:06,780 --> 00:44:09,240
yeah in the sort of exploits nice thank

1138
00:44:09,240 --> 00:44:11,359
you

