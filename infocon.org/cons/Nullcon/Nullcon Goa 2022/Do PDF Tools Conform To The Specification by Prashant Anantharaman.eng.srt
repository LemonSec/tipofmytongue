1
00:00:03,540 --> 00:00:05,100
all right

2
00:00:05,100 --> 00:00:07,919
uh hi everyone let's get started

3
00:00:07,919 --> 00:00:10,920
can those of you at the at that end hear

4
00:00:10,920 --> 00:00:13,259
me okay

5
00:00:13,259 --> 00:00:16,980
cool whatever on this side it's all good

6
00:00:16,980 --> 00:00:19,920
Okay cool so let's get started uh I'm

7
00:00:19,920 --> 00:00:21,660
Prashant Ramen

8
00:00:21,660 --> 00:00:24,840
and uh a little bit about myself

9
00:00:24,840 --> 00:00:27,720
um uh I recently started as a senior

10
00:00:27,720 --> 00:00:29,539
security researcher at North Industries

11
00:00:29,539 --> 00:00:32,759
which is a security research and

12
00:00:32,759 --> 00:00:35,219
consulting company that mostly does work

13
00:00:35,219 --> 00:00:39,300
for the uh for the US government and uh

14
00:00:39,300 --> 00:00:41,280
We've also recently started looking a

15
00:00:41,280 --> 00:00:43,379
bit deeper into uh industrial control

16
00:00:43,379 --> 00:00:45,660
system security so if that's something

17
00:00:45,660 --> 00:00:47,219
that you guys do then you should come

18
00:00:47,219 --> 00:00:50,280
and talk to me so I currently reside in

19
00:00:50,280 --> 00:00:53,399
Boston Massachusetts and uh but I'm

20
00:00:53,399 --> 00:00:55,500
originally from Chennai and that's where

21
00:00:55,500 --> 00:00:58,559
I did my undergrad and stuff and uh I

22
00:00:58,559 --> 00:01:00,300
recently finished my PhD from Dartmouth

23
00:01:00,300 --> 00:01:03,600
as the host told me or told you guys and

24
00:01:03,600 --> 00:01:05,700
uh I worked with Sean Smith and Sergey

25
00:01:05,700 --> 00:01:09,600
brought us for my PhD and uh these are

26
00:01:09,600 --> 00:01:11,580
my broad interests I'm broadly

27
00:01:11,580 --> 00:01:13,920
interested in formal verification file

28
00:01:13,920 --> 00:01:16,740
formats weird machines parcel exploits

29
00:01:16,740 --> 00:01:21,119
all of those nice stuff so uh yeah but

30
00:01:21,119 --> 00:01:23,640
in this talk I'm going to be presenting

31
00:01:23,640 --> 00:01:27,659
something from my PhD work so I would

32
00:01:27,659 --> 00:01:30,180
really like to thank them and my

33
00:01:30,180 --> 00:01:32,119
collaborators as at SRI International

34
00:01:32,119 --> 00:01:35,820
and also at PDF Association because this

35
00:01:35,820 --> 00:01:38,820
has worked on PDF so then of course we

36
00:01:38,820 --> 00:01:40,680
had to have PDF Association in the loop

37
00:01:40,680 --> 00:01:43,259
because they maintain the spec and of

38
00:01:43,259 --> 00:01:46,020
course the funding agency

39
00:01:46,020 --> 00:01:49,860
so uh I guess why would anyone even

40
00:01:49,860 --> 00:01:52,320
bother checking if PDF files conform to

41
00:01:52,320 --> 00:01:54,899
the spec right so the real reason is

42
00:01:54,899 --> 00:01:57,780
just that why not of course people are

43
00:01:57,780 --> 00:01:59,880
doing things wrong the short answer to

44
00:01:59,880 --> 00:02:02,159
that title of my talk is of course no

45
00:02:02,159 --> 00:02:05,759
right if you guys didn't know so uh so

46
00:02:05,759 --> 00:02:08,160
when you think about why PDFs the the

47
00:02:08,160 --> 00:02:10,258
first thing that comes to mind is a

48
00:02:10,258 --> 00:02:11,580
conversation that I hired with my

49
00:02:11,580 --> 00:02:15,180
advisor who happens to be Russian so any

50
00:02:15,180 --> 00:02:16,920
conversation always starts off with a

51
00:02:16,920 --> 00:02:18,780
long Russian story or a rant about

52
00:02:18,780 --> 00:02:21,540
Soviet Russia and then he was like

53
00:02:21,540 --> 00:02:23,700
lately we've been thinking about PDFs

54
00:02:23,700 --> 00:02:25,800
have you thought about it because how do

55
00:02:25,800 --> 00:02:27,780
you even write a parser to validate PDF

56
00:02:27,780 --> 00:02:30,360
files to ensure that any PDF file that

57
00:02:30,360 --> 00:02:32,220
you're consuming is fully valid

58
00:02:32,220 --> 00:02:35,819
and I was like huh don't they embed like

59
00:02:35,819 --> 00:02:38,040
several several other formats starting

60
00:02:38,040 --> 00:02:40,080
from images to literally everything

61
00:02:40,080 --> 00:02:43,379
under the roof like you can embed pretty

62
00:02:43,379 --> 00:02:45,239
much anything inside a PDF file right so

63
00:02:45,239 --> 00:02:48,060
then why would anyone even want to do it

64
00:02:48,060 --> 00:02:51,000
but often if something goes wrong if

65
00:02:51,000 --> 00:02:53,760
there is an exploit a crafted file it is

66
00:02:53,760 --> 00:02:56,280
a Microsoft Word document or a PDF file

67
00:02:56,280 --> 00:02:58,680
of sorts that triggers a vulnerability

68
00:02:58,680 --> 00:03:01,920
so it is always one of these three but

69
00:03:01,920 --> 00:03:04,260
then in this talk I'm talking about just

70
00:03:04,260 --> 00:03:06,599
PDFs

71
00:03:06,599 --> 00:03:08,400
so ah

72
00:03:08,400 --> 00:03:11,040
has anyone over here actually used a

73
00:03:11,040 --> 00:03:14,340
text extraction tool on a PDF file

74
00:03:14,340 --> 00:03:17,580
anyway not OCR plain text extraction

75
00:03:17,580 --> 00:03:19,200
tool

76
00:03:19,200 --> 00:03:22,440
cool so let me actually show you three

77
00:03:22,440 --> 00:03:25,620
of them and their output on the exact

78
00:03:25,620 --> 00:03:28,680
same file and let's see if you spot

79
00:03:28,680 --> 00:03:31,739
something interesting right so I'm I'm

80
00:03:31,739 --> 00:03:33,180
guessing you can see this because it's

81
00:03:33,180 --> 00:03:36,000
pretty big and clear so uh

82
00:03:36,000 --> 00:03:38,220
there are three tools that I'm using

83
00:03:38,220 --> 00:03:42,180
over here uh PDF to text and then pdf2

84
00:03:42,180 --> 00:03:44,700
text Dot Pi which happens to be from PDF

85
00:03:44,700 --> 00:03:47,159
Miner and then go script which happens

86
00:03:47,159 --> 00:03:49,260
to be from your tool so then these are

87
00:03:49,260 --> 00:03:51,120
the three broad files these are the

88
00:03:51,120 --> 00:03:54,060
three files I'm gonna test and uh let me

89
00:03:54,060 --> 00:03:57,840
just quickly show you the uh the file as

90
00:03:57,840 --> 00:04:00,840
well just so that you know uh what to

91
00:04:00,840 --> 00:04:01,980
expect

92
00:04:01,980 --> 00:04:07,260
so it's a sec file uh I collected this

93
00:04:07,260 --> 00:04:09,480
file from common crawl so it's totally

94
00:04:09,480 --> 00:04:11,519
okay don't worry about the names and

95
00:04:11,519 --> 00:04:15,120
stuff uh it was from common crawl so uh

96
00:04:15,120 --> 00:04:17,639
you see that there are tables and it's

97
00:04:17,639 --> 00:04:19,560
basically just two pages right

98
00:04:19,560 --> 00:04:23,520
so you just expect similar text to

99
00:04:23,520 --> 00:04:24,419
appear

100
00:04:24,419 --> 00:04:28,620
and now let me just uh

101
00:04:28,620 --> 00:04:30,660
show you what the three outputs look

102
00:04:30,660 --> 00:04:31,560
like

103
00:04:31,560 --> 00:04:35,040
so the one to the left most is uh go

104
00:04:35,040 --> 00:04:37,800
script the one in the middle is a PDF

105
00:04:37,800 --> 00:04:40,259
Miner and the one to the right is PDF to

106
00:04:40,259 --> 00:04:41,400
text

107
00:04:41,400 --> 00:04:44,460
do any of them look like the actual file

108
00:04:44,460 --> 00:04:46,740
I would think that go script looks the

109
00:04:46,740 --> 00:04:49,020
closest to what was in the actual file

110
00:04:49,020 --> 00:04:50,580
but

111
00:04:50,580 --> 00:04:53,280
PDF Miner looks far away like there's no

112
00:04:53,280 --> 00:04:55,440
white spaces it's all fully disappeared

113
00:04:55,440 --> 00:04:59,759
uh PDF to text is close enough but it's

114
00:04:59,759 --> 00:05:02,400
still not really there so

115
00:05:02,400 --> 00:05:04,580
what what am I really trying to say here

116
00:05:04,580 --> 00:05:06,960
these three tools are supposed to rule

117
00:05:06,960 --> 00:05:08,759
the exact same task

118
00:05:08,759 --> 00:05:11,100
they read the exact same spec they've

119
00:05:11,100 --> 00:05:14,340
all read PDF 1.7 spec although PDF 2.0

120
00:05:14,340 --> 00:05:15,600
is the latest one they've all

121
00:05:15,600 --> 00:05:19,080
implemented PDF 1.7 but somehow when you

122
00:05:19,080 --> 00:05:21,840
actually look at the output they're all

123
00:05:21,840 --> 00:05:22,860
different

124
00:05:22,860 --> 00:05:26,180
how the hell is this okay

125
00:05:28,500 --> 00:05:31,800
yeah so uh I guess this is where I

126
00:05:31,800 --> 00:05:33,600
introduce what language theoretic

127
00:05:33,600 --> 00:05:35,639
security which is the area I work on is

128
00:05:35,639 --> 00:05:38,820
uh which is also known as langsek and in

129
00:05:38,820 --> 00:05:40,380
my talk I'll also be giving you an

130
00:05:40,380 --> 00:05:44,160
overview of uh of a PDF file format how

131
00:05:44,160 --> 00:05:46,139
a PDF file looks what struck what

132
00:05:46,139 --> 00:05:48,360
structure does it follow and I'll also

133
00:05:48,360 --> 00:05:50,340
be talking about the tool that I built

134
00:05:50,340 --> 00:05:54,419
called Sparta and PDF fixer which uh

135
00:05:54,419 --> 00:05:56,639
which sort of fixes these uh commonly

136
00:05:56,639 --> 00:06:00,080
seen bugs in PDF files

137
00:06:00,120 --> 00:06:04,139
so to motivate the problem of why why do

138
00:06:04,139 --> 00:06:07,259
we even have a field of a subfield of

139
00:06:07,259 --> 00:06:08,639
security called language theoretic

140
00:06:08,639 --> 00:06:11,940
security uh it comes down to it all

141
00:06:11,940 --> 00:06:14,639
started sometime around hardblade 2014.

142
00:06:14,639 --> 00:06:17,880
when uh there were a host of

143
00:06:17,880 --> 00:06:21,060
vulnerabilities in openssl and uh this

144
00:06:21,060 --> 00:06:24,120
was a real issue because uh to just

145
00:06:24,120 --> 00:06:27,000
describe it in short to those who don't

146
00:06:27,000 --> 00:06:29,639
know about hard bleed uh the heart the

147
00:06:29,639 --> 00:06:32,220
open SSL protocol has a particular

148
00:06:32,220 --> 00:06:35,100
feature called a heartbeat where uh what

149
00:06:35,100 --> 00:06:37,979
happens is that you you can keep a

150
00:06:37,979 --> 00:06:40,139
connection alive so you can send a

151
00:06:40,139 --> 00:06:40,919
message

152
00:06:40,919 --> 00:06:42,539
stating how many characters you're

153
00:06:42,539 --> 00:06:45,900
sending and then you receive that

154
00:06:45,900 --> 00:06:48,840
identical identical message back so it's

155
00:06:48,840 --> 00:06:51,360
basically an echo server of sorts so you

156
00:06:51,360 --> 00:06:53,100
are basically sending in this example

157
00:06:53,100 --> 00:06:54,539
you're sending you're saying that you're

158
00:06:54,539 --> 00:06:56,639
going to send six letters and the string

159
00:06:56,639 --> 00:06:59,699
potato and then you expect the server to

160
00:06:59,699 --> 00:07:02,039
return that exact string

161
00:07:02,039 --> 00:07:04,979
but what in practice happened was that

162
00:07:04,979 --> 00:07:07,620
there was no check between how many

163
00:07:07,620 --> 00:07:09,120
characters you were sending and how many

164
00:07:09,120 --> 00:07:10,560
characters you said you were gonna say

165
00:07:10,560 --> 00:07:13,020
assign so for example you can say that

166
00:07:13,020 --> 00:07:15,240
you're gonna send uh send 500 characters

167
00:07:15,240 --> 00:07:17,940
but end up sending just three and then

168
00:07:17,940 --> 00:07:20,759
what does the server do uh a very

169
00:07:20,759 --> 00:07:22,500
intuitive answer is that of course the

170
00:07:22,500 --> 00:07:23,880
server should have rejected it this is

171
00:07:23,880 --> 00:07:26,520
such a dumb bug but in practice that

172
00:07:26,520 --> 00:07:28,919
didn't happen and that sort of raises a

173
00:07:28,919 --> 00:07:31,800
deeper question do people actually fully

174
00:07:31,800 --> 00:07:34,560
validate input that they consume is the

175
00:07:34,560 --> 00:07:36,000
real question here

176
00:07:36,000 --> 00:07:38,520
and it's something similar that we saw

177
00:07:38,520 --> 00:07:40,560
in this particular bug of Pegasus that

178
00:07:40,560 --> 00:07:42,599
was called forced entry and this was

179
00:07:42,599 --> 00:07:46,139
also exposed uh in 2021 where uh the

180
00:07:46,139 --> 00:07:48,599
attacker used PDF files that were

181
00:07:48,599 --> 00:07:51,479
disguised as GIF images so they were PD

182
00:07:51,479 --> 00:07:53,940
so and they sent it to a PDF Library a

183
00:07:53,940 --> 00:07:55,500
PDF Library should have directly

184
00:07:55,500 --> 00:07:58,740
rejected a file that was a gif file and

185
00:07:58,740 --> 00:08:01,979
not a PDF file but it didn't so again

186
00:08:01,979 --> 00:08:04,080
the same question why not actually

187
00:08:04,080 --> 00:08:07,740
properly validate why can't you validate

188
00:08:07,740 --> 00:08:10,919
so any system that actually accepts

189
00:08:10,919 --> 00:08:13,680
input we know that we test it against

190
00:08:13,680 --> 00:08:15,539
all the expected input or at least a

191
00:08:15,539 --> 00:08:17,639
subset of expected input but we don't

192
00:08:17,639 --> 00:08:20,400
really test it across all possible

193
00:08:20,400 --> 00:08:22,440
inputs

194
00:08:22,440 --> 00:08:24,180
often we don't know what what is going

195
00:08:24,180 --> 00:08:26,039
to happen because you can't

196
00:08:26,039 --> 00:08:27,780
theoretically test for all possible

197
00:08:27,780 --> 00:08:30,180
input and often we use tools like

198
00:08:30,180 --> 00:08:32,520
fuzzing that will explore a search space

199
00:08:32,520 --> 00:08:34,620
but it's not going to get everything for

200
00:08:34,620 --> 00:08:36,659
my verification you can use but then

201
00:08:36,659 --> 00:08:39,179
what will happen is that you you have

202
00:08:39,179 --> 00:08:40,860
some preconditions and you're just

203
00:08:40,860 --> 00:08:43,200
checking within those bounds you're not

204
00:08:43,200 --> 00:08:46,440
really exploring everything possible

205
00:08:46,440 --> 00:08:50,399
so the parser is really the uh what

206
00:08:50,399 --> 00:08:52,620
stands between invalid input and the

207
00:08:52,620 --> 00:08:54,660
rest of your program so your parser is

208
00:08:54,660 --> 00:08:57,000
going to take unstructured input of any

209
00:08:57,000 --> 00:08:59,519
sort and validate it and then transform

210
00:08:59,519 --> 00:09:00,959
it into something that the rest of your

211
00:09:00,959 --> 00:09:03,000
program can consume so those are called

212
00:09:03,000 --> 00:09:05,700
well-typed or structured objects and

213
00:09:05,700 --> 00:09:08,339
improper input validation is really one

214
00:09:08,339 --> 00:09:10,200
of the most common weaknesses that we

215
00:09:10,200 --> 00:09:12,980
keep seeing in the miter databases and

216
00:09:12,980 --> 00:09:15,540
Incorrect and insufficient parsers are

217
00:09:15,540 --> 00:09:17,279
what lead to vulnerabilities which is

218
00:09:17,279 --> 00:09:19,320
why I was saying that the parser is

219
00:09:19,320 --> 00:09:22,680
really what stands between you and

220
00:09:22,680 --> 00:09:24,600
invalid input and hence you have to pay

221
00:09:24,600 --> 00:09:26,940
a lot of attention to it

222
00:09:26,940 --> 00:09:29,820
and you might think that if I use a

223
00:09:29,820 --> 00:09:32,220
memory safe language why do I care right

224
00:09:32,220 --> 00:09:33,899
but there is another class of

225
00:09:33,899 --> 00:09:35,640
vulnerabilities called the parser

226
00:09:35,640 --> 00:09:37,860
differentials for example what I just

227
00:09:37,860 --> 00:09:40,680
showed you where the same parser is

228
00:09:40,680 --> 00:09:42,779
consuming the say uh sorry different

229
00:09:42,779 --> 00:09:45,300
parsers are consuming the same PDF file

230
00:09:45,300 --> 00:09:46,860
but they output three completely

231
00:09:46,860 --> 00:09:49,620
different things so uh that's not okay

232
00:09:49,620 --> 00:09:52,560
right because uh we have seen in the

233
00:09:52,560 --> 00:09:54,480
past that parser differentials can lead

234
00:09:54,480 --> 00:09:56,700
to really really serious issues for

235
00:09:56,700 --> 00:09:58,620
example in this particular case that I

236
00:09:58,620 --> 00:10:01,560
have on the slide uh Dan Kaminsky Lin

237
00:10:01,560 --> 00:10:03,480
Sassaman and Meredith Patterson in 2010

238
00:10:03,480 --> 00:10:06,839
they uh they demonstrated that if you

239
00:10:06,839 --> 00:10:08,760
just put a simple null character in

240
00:10:08,760 --> 00:10:11,940
between of uh in within a URL uh

241
00:10:11,940 --> 00:10:14,580
different x509 parsers or certificate

242
00:10:14,580 --> 00:10:16,500
parsers get tricked into doing different

243
00:10:16,500 --> 00:10:17,399
things

244
00:10:17,399 --> 00:10:19,560
and interestingly two of these three

245
00:10:19,560 --> 00:10:21,720
outputs that I have over here were

246
00:10:21,720 --> 00:10:24,180
within the same Library the same library

247
00:10:24,180 --> 00:10:26,279
has two different parsers for the same

248
00:10:26,279 --> 00:10:28,500
thing and then they both have different

249
00:10:28,500 --> 00:10:29,640
outputs

250
00:10:29,640 --> 00:10:31,260
if you are doing the same thing why do

251
00:10:31,260 --> 00:10:33,839
you have to implement it twice

252
00:10:33,839 --> 00:10:36,660
so yeah basically the idea is that it

253
00:10:36,660 --> 00:10:39,480
should have the same output and iOS had

254
00:10:39,480 --> 00:10:41,040
a very similar issue where they had

255
00:10:41,040 --> 00:10:43,260
three different XML parsers they had

256
00:10:43,260 --> 00:10:45,300
actually four but three of them had

257
00:10:45,300 --> 00:10:49,640
issues in how they read comments and uh

258
00:10:49,640 --> 00:10:52,920
XML was really how they do uh this thing

259
00:10:52,920 --> 00:10:54,660
called entitlements which is behind

260
00:10:54,660 --> 00:10:58,320
their entire iOS permissioning system

261
00:10:58,320 --> 00:11:01,200
so uh the idea here is that an adversary

262
00:11:01,200 --> 00:11:05,040
can really craft a permission where uh

263
00:11:05,040 --> 00:11:07,680
one one parser sees that it's a comment

264
00:11:07,680 --> 00:11:09,540
whereas another sees that it's a

265
00:11:09,540 --> 00:11:12,120
legitimate permission so you can trick

266
00:11:12,120 --> 00:11:14,399
the user into seeing something whereas

267
00:11:14,399 --> 00:11:16,440
the actual permission underneath is com

268
00:11:16,440 --> 00:11:18,660
something completely different

269
00:11:18,660 --> 00:11:22,079
so for those of you who who have taken

270
00:11:22,079 --> 00:11:24,839
like a formal language Theory course uh

271
00:11:24,839 --> 00:11:26,660
and know about Turing machines and such

272
00:11:26,660 --> 00:11:29,399
uh checking the equivalence of these

273
00:11:29,399 --> 00:11:33,360
parsers right is uh is is undecidable if

274
00:11:33,360 --> 00:11:36,060
you go beyond a certain uh language

275
00:11:36,060 --> 00:11:39,360
class in the Chomsky hierarchy so it it

276
00:11:39,360 --> 00:11:41,640
really cannot be done and which is why

277
00:11:41,640 --> 00:11:43,800
you really need to stay within the

278
00:11:43,800 --> 00:11:45,240
deterministic context-free or the

279
00:11:45,240 --> 00:11:47,220
regular boundary you can't really do

280
00:11:47,220 --> 00:11:48,540
that in PDF

281
00:11:48,540 --> 00:11:51,360
uh but in in practice at least for

282
00:11:51,360 --> 00:11:52,860
networking protocols this is something

283
00:11:52,860 --> 00:11:55,680
that you should strive for

284
00:11:55,680 --> 00:11:58,019
so what really is language theoretic

285
00:11:58,019 --> 00:12:00,180
security and why am I talking so much

286
00:12:00,180 --> 00:12:03,660
about it on and on so uh the the the

287
00:12:03,660 --> 00:12:06,720
motivation behind it is that offensive

288
00:12:06,720 --> 00:12:09,420
research and defensive research are sort

289
00:12:09,420 --> 00:12:11,640
of go hand in hand and defense is

290
00:12:11,640 --> 00:12:14,100
offenseless child and so language

291
00:12:14,100 --> 00:12:15,779
theoretic security sort of takes

292
00:12:15,779 --> 00:12:18,240
inspiration from both defensive and

293
00:12:18,240 --> 00:12:20,940
offensive security as well as formal

294
00:12:20,940 --> 00:12:22,980
language Theory like the result that I

295
00:12:22,980 --> 00:12:26,100
just showed you where uh uh where you

296
00:12:26,100 --> 00:12:27,540
cannot really show equivalence of two

297
00:12:27,540 --> 00:12:29,220
parsers is something that's really

298
00:12:29,220 --> 00:12:31,380
important uh when you're writing your

299
00:12:31,380 --> 00:12:33,720
own parser and hence parser toolkits

300
00:12:33,720 --> 00:12:35,399
also need to know and have knowledge of

301
00:12:35,399 --> 00:12:37,940
these issues

302
00:12:37,980 --> 00:12:41,880
so uh let me just boil down to uh What

303
00:12:41,880 --> 00:12:44,040
uh what are the core principles behind

304
00:12:44,040 --> 00:12:45,120
line sec

305
00:12:45,120 --> 00:12:48,000
so the basic ideas are that you need to

306
00:12:48,000 --> 00:12:49,800
fully recognize your input before

307
00:12:49,800 --> 00:12:52,500
operating on them and all input that the

308
00:12:52,500 --> 00:12:54,240
rest of your program is going to consume

309
00:12:54,240 --> 00:12:56,180
has to be fully recognized and validated

310
00:12:56,180 --> 00:12:59,880
and uh any input that is even mildly

311
00:12:59,880 --> 00:13:01,800
malformed you have to reject you cannot

312
00:13:01,800 --> 00:13:04,740
be super permissive if there are reasons

313
00:13:04,740 --> 00:13:05,940
that you have to do that you need to

314
00:13:05,940 --> 00:13:08,399
update the spec and make the spec more

315
00:13:08,399 --> 00:13:10,139
permissive in the first place and not

316
00:13:10,139 --> 00:13:12,660
just make your your implementation

317
00:13:12,660 --> 00:13:14,120
violate the spec

318
00:13:14,120 --> 00:13:16,380
you need to keep the input language as

319
00:13:16,380 --> 00:13:17,639
simple as possible you shouldn't

320
00:13:17,639 --> 00:13:19,920
complicate it too much because sometimes

321
00:13:19,920 --> 00:13:21,899
that's the place where vulnerabilities

322
00:13:21,899 --> 00:13:24,480
even stem because things like weird

323
00:13:24,480 --> 00:13:26,459
machines if you guys have heard of that

324
00:13:26,459 --> 00:13:28,920
concept stem from the fact that you have

325
00:13:28,920 --> 00:13:32,040
a very complex input format

326
00:13:32,040 --> 00:13:34,079
the third is something that

327
00:13:34,079 --> 00:13:36,180
practitioners really can Implement even

328
00:13:36,180 --> 00:13:38,880
today which is that you really need to

329
00:13:38,880 --> 00:13:42,420
separate your parcel from the code uh a

330
00:13:42,420 --> 00:13:44,940
lot of people who do uh who do pen

331
00:13:44,940 --> 00:13:48,240
testing as well as security audits uh

332
00:13:48,240 --> 00:13:50,700
attach this that the parser is really

333
00:13:50,700 --> 00:13:52,560
where you want to find vulnerabilities

334
00:13:52,560 --> 00:13:55,260
and you often will end up finding it and

335
00:13:55,260 --> 00:13:57,120
hence if you actually separate the

336
00:13:57,120 --> 00:13:58,560
parser entirely from the rest of the

337
00:13:58,560 --> 00:14:02,519
code base you can essentially ensure

338
00:14:02,519 --> 00:14:06,240
that the uh you're looking at the right

339
00:14:06,240 --> 00:14:08,160
place and you you you're looking at only

340
00:14:08,160 --> 00:14:10,200
the parser at that point when you mix

341
00:14:10,200 --> 00:14:12,240
everything it's very difficult to know

342
00:14:12,240 --> 00:14:13,920
which portion of it is the parser and

343
00:14:13,920 --> 00:14:16,560
which is actually operating on the code

344
00:14:16,560 --> 00:14:17,820
I don't know

345
00:14:17,820 --> 00:14:20,399
so to actually describe the same

346
00:14:20,399 --> 00:14:22,320
Concepts in a language that hackers

347
00:14:22,320 --> 00:14:24,480
understand

348
00:14:24,480 --> 00:14:26,760
full recognition before processing

349
00:14:26,760 --> 00:14:28,620
computational equivalence for all

350
00:14:28,620 --> 00:14:31,440
protocol endpoints uh which also applies

351
00:14:31,440 --> 00:14:34,920
for file formats and network protocols

352
00:14:34,920 --> 00:14:37,500
we need to stop weird machines and no

353
00:14:37,500 --> 00:14:41,120
more Turing complete input languages

354
00:14:47,880 --> 00:14:49,980
uh the place where the Lancaster

355
00:14:49,980 --> 00:14:51,720
Paradigm comes in is the input

356
00:14:51,720 --> 00:14:54,480
validation layer M over here which is

357
00:14:54,480 --> 00:14:56,959
basically trying to uh

358
00:14:56,959 --> 00:15:00,060
validate the Lang the the in any input

359
00:15:00,060 --> 00:15:02,519
that's going through and rejects the set

360
00:15:02,519 --> 00:15:05,220
of possible inputs and separates it from

361
00:15:05,220 --> 00:15:08,540
these set of expected inputs

362
00:15:10,260 --> 00:15:11,880
sorry

363
00:15:11,880 --> 00:15:13,680
so uh

364
00:15:13,680 --> 00:15:16,320
you might be wondering all this was nice

365
00:15:16,320 --> 00:15:19,139
in theory I'm preaching something this

366
00:15:19,139 --> 00:15:21,000
is nice how do you really do this in

367
00:15:21,000 --> 00:15:23,940
practice so in practice you can use two

368
00:15:23,940 --> 00:15:26,940
tools uh two families of tools actually

369
00:15:26,940 --> 00:15:29,899
one is called parser combinators

370
00:15:29,899 --> 00:15:32,579
and what they do is that they Implement

371
00:15:32,579 --> 00:15:35,100
code that looks like grammar so you can

372
00:15:35,100 --> 00:15:36,920
have a formal grammar or a specification

373
00:15:36,920 --> 00:15:39,839
and the a parser combinator toolkit

374
00:15:39,839 --> 00:15:43,199
actually allows you to describe a format

375
00:15:43,199 --> 00:15:45,300
just like you would in a grammar

376
00:15:45,300 --> 00:15:48,420
so uh what you see over here is an

377
00:15:48,420 --> 00:15:51,720
example of a DNS specification where you

378
00:15:51,720 --> 00:15:54,779
start with an ID field

379
00:15:54,779 --> 00:15:58,560
which is 16 bits or two bytes and Then

380
00:15:58,560 --> 00:16:01,860
followed by uh followed by one bit and

381
00:16:01,860 --> 00:16:04,680
four bits and so on the H underscore

382
00:16:04,680 --> 00:16:08,760
un16 is of course a 16-bit unsigned

383
00:16:08,760 --> 00:16:12,600
integer and uh so yeah basically you can

384
00:16:12,600 --> 00:16:15,180
append everything into a large sequence

385
00:16:15,180 --> 00:16:16,940
operation

386
00:16:16,940 --> 00:16:20,100
and uh another another Paradigm that you

387
00:16:20,100 --> 00:16:22,560
can follow is that of data description

388
00:16:22,560 --> 00:16:25,079
languages where what you are doing

389
00:16:25,079 --> 00:16:28,079
instead is your generating code from a

390
00:16:28,079 --> 00:16:31,320
grammar specification and uh kaitai is

391
00:16:31,320 --> 00:16:33,779
an example of one and that's the example

392
00:16:33,779 --> 00:16:36,120
that I have on the right which uses yaml

393
00:16:36,120 --> 00:16:38,820
syntax you can use something like dftl

394
00:16:38,820 --> 00:16:42,120
which uses xmls xsd syntax

395
00:16:42,120 --> 00:16:44,940
and uh kaita is the one that actually

396
00:16:44,940 --> 00:16:47,759
generates tons and tons of uh generates

397
00:16:47,759 --> 00:16:49,139
code in tons of programming languages

398
00:16:49,139 --> 00:16:51,779
and that's certainly a very cool project

399
00:16:51,779 --> 00:16:55,579
that I really encourage you to check out

400
00:16:56,240 --> 00:16:59,160
and uh what do I mean by it looks

401
00:16:59,160 --> 00:17:01,500
exactly like the specification right uh

402
00:17:01,500 --> 00:17:05,160
this is what the DNS RFC message format

403
00:17:05,160 --> 00:17:07,679
looks like and you can see clearly that

404
00:17:07,679 --> 00:17:10,199
you have an ID followed by a QR followed

405
00:17:10,199 --> 00:17:12,179
by an OP code and everything else so

406
00:17:12,179 --> 00:17:14,880
then you would see that uh all of these

407
00:17:14,880 --> 00:17:19,260
three sort of match clearly and uh it's

408
00:17:19,260 --> 00:17:20,939
basically the same thing implemented in

409
00:17:20,939 --> 00:17:22,980
Hammer as well as in kaitai the only

410
00:17:22,980 --> 00:17:24,839
difference in kaitai is that they have

411
00:17:24,839 --> 00:17:28,260
defined a separate type for flags and

412
00:17:28,260 --> 00:17:31,080
all of these get uh basically compressed

413
00:17:31,080 --> 00:17:33,918
into that one type

414
00:17:35,880 --> 00:17:39,720
so uh that was hopefully a quick uh

415
00:17:39,720 --> 00:17:41,760
langsek introduction and now I'm

416
00:17:41,760 --> 00:17:44,039
actually going to move on to PDFs and

417
00:17:44,039 --> 00:17:47,539
how a PDF file actually looks

418
00:17:52,620 --> 00:17:56,640
so uh the PDF spec the latest one is

419
00:17:56,640 --> 00:18:00,419
from 2017 or 2020 depending on uh when

420
00:18:00,419 --> 00:18:02,880
you bought it so there is a PDF 2.0

421
00:18:02,880 --> 00:18:05,700
specification from ISO and that's right

422
00:18:05,700 --> 00:18:09,299
now like 971 pages long uh you can ask

423
00:18:09,299 --> 00:18:12,360
me did I read all of it probably not I

424
00:18:12,360 --> 00:18:16,020
read most of it because I had to uh

425
00:18:16,020 --> 00:18:19,200
uh what you see on the right is a a

426
00:18:19,200 --> 00:18:22,740
poster from uh korkami or anjal bertini

427
00:18:22,740 --> 00:18:25,740
where uh that sort of describes what a

428
00:18:25,740 --> 00:18:27,360
PDF file looks like

429
00:18:27,360 --> 00:18:29,820
so who of you have actually looked in

430
00:18:29,820 --> 00:18:32,640
binary what a PDF file looks like

431
00:18:32,640 --> 00:18:34,740
anyone

432
00:18:34,740 --> 00:18:37,260
one wow okay

433
00:18:37,260 --> 00:18:40,980
there's more nice so uh

434
00:18:40,980 --> 00:18:44,160
what you see on the right is what a PDF

435
00:18:44,160 --> 00:18:46,919
file is and there's basically a header

436
00:18:46,919 --> 00:18:49,260
which specifies what the version is

437
00:18:49,260 --> 00:18:54,059
which can range from 1.0 to 2.0 and

438
00:18:54,059 --> 00:18:55,500
there are a few numbers that are skipped

439
00:18:55,500 --> 00:18:57,660
in between but that's broadly what the

440
00:18:57,660 --> 00:19:00,059
range is and then there are objects

441
00:19:00,059 --> 00:19:02,940
inside the PDF file and then there is a

442
00:19:02,940 --> 00:19:05,460
trailer which has a certain syntax and

443
00:19:05,460 --> 00:19:07,559
there are some fields that are mandatory

444
00:19:07,559 --> 00:19:09,240
some fields that are optional

445
00:19:09,240 --> 00:19:10,500
so

446
00:19:10,500 --> 00:19:13,260
how would you really parse this file

447
00:19:13,260 --> 00:19:16,860
uh because the trailer is what says

448
00:19:16,860 --> 00:19:19,020
where the cross reference table is the

449
00:19:19,020 --> 00:19:21,900
crop cross reference table is a table

450
00:19:21,900 --> 00:19:24,179
that says where all the other objects

451
00:19:24,179 --> 00:19:27,120
are so it's basically an index and

452
00:19:27,120 --> 00:19:29,059
because that's at the bottom of the file

453
00:19:29,059 --> 00:19:31,620
and the location of the cross reference

454
00:19:31,620 --> 00:19:34,440
table is stored in the trailer you have

455
00:19:34,440 --> 00:19:36,240
to start reading the files right from

456
00:19:36,240 --> 00:19:39,000
the bottom so you parse of parse a PDF

457
00:19:39,000 --> 00:19:41,640
file from the bottom and you read these

458
00:19:41,640 --> 00:19:45,240
values and then you have to jump to

459
00:19:45,240 --> 00:19:47,460
those values and read the uh and then

460
00:19:47,460 --> 00:19:49,320
read the objects individually

461
00:19:49,320 --> 00:19:51,960
so ah

462
00:19:51,960 --> 00:19:54,720
yeah so that's the diagram that you have

463
00:19:54,720 --> 00:19:56,640
over here where you start with the

464
00:19:56,640 --> 00:19:58,799
trailer then move to the root and then

465
00:19:58,799 --> 00:20:00,600
you start traversing the individual

466
00:20:00,600 --> 00:20:01,740
pages

467
00:20:01,740 --> 00:20:04,679
there is this one really special object

468
00:20:04,679 --> 00:20:06,840
which is also called a root or a catalog

469
00:20:06,840 --> 00:20:09,419
object which is really special because

470
00:20:09,419 --> 00:20:11,700
that's what contains a lot of metadata

471
00:20:11,700 --> 00:20:14,820
and a lot of interesting information and

472
00:20:14,820 --> 00:20:18,419
uh the specification says that it has to

473
00:20:18,419 --> 00:20:21,600
con it can contain up to 33 keys but

474
00:20:21,600 --> 00:20:23,520
there are only like two or three that

475
00:20:23,520 --> 00:20:26,039
are mandatory and most of them are just

476
00:20:26,039 --> 00:20:28,799
optional keys

477
00:20:28,799 --> 00:20:33,660
so uh let me quickly show you what a PDF

478
00:20:33,660 --> 00:20:37,740
file may look like uh

479
00:20:44,160 --> 00:20:48,480
right so as I described earlier uh

480
00:20:48,480 --> 00:20:51,360
it starts off with a header right at the

481
00:20:51,360 --> 00:20:53,640
top which is the version number and then

482
00:20:53,640 --> 00:20:57,120
you have a bunch of objects so uh one

483
00:20:57,120 --> 00:20:59,100
zero object is basically the object

484
00:20:59,100 --> 00:21:01,380
number generation number and then just

485
00:21:01,380 --> 00:21:03,720
the keyword object and it ends with an

486
00:21:03,720 --> 00:21:06,500
end option tag

487
00:21:06,500 --> 00:21:10,320
you may ask what these characters are

488
00:21:10,320 --> 00:21:11,880
this greater than greater than less than

489
00:21:11,880 --> 00:21:15,179
less than uh before the after the object

490
00:21:15,179 --> 00:21:17,880
before the end option and those denot

491
00:21:17,880 --> 00:21:20,580
basically a dictionary objective so PDF

492
00:21:20,580 --> 00:21:23,460
contains dictionaries arrays and a lot

493
00:21:23,460 --> 00:21:26,179
of other types

494
00:21:30,659 --> 00:21:33,900
yeah so uh you'll see that there are

495
00:21:33,900 --> 00:21:36,240
several of these and then the most

496
00:21:36,240 --> 00:21:37,740
interesting one that I wanted to show

497
00:21:37,740 --> 00:21:40,620
you was the trailer so the trailer is

498
00:21:40,620 --> 00:21:42,620
also a dictionary

499
00:21:42,620 --> 00:21:45,960
uh that's denoted by these signs and

500
00:21:45,960 --> 00:21:47,880
then there are two keys over here which

501
00:21:47,880 --> 00:21:50,640
is the root and the size right

502
00:21:50,640 --> 00:21:54,419
uh the root so the keys are denoted by a

503
00:21:54,419 --> 00:21:57,120
slash sign which uh so this particular

504
00:21:57,120 --> 00:21:59,820
type is called name type and PDF and the

505
00:21:59,820 --> 00:22:02,760
root is uh basically just the name or

506
00:22:02,760 --> 00:22:04,260
one of the keys of the dictionary and

507
00:22:04,260 --> 00:22:05,940
then size is the other key

508
00:22:05,940 --> 00:22:08,880
and uh this is basically an indirect

509
00:22:08,880 --> 00:22:12,480
reference that means an object called 1

510
00:22:12,480 --> 00:22:15,000
0 exists somewhere else in this file so

511
00:22:15,000 --> 00:22:16,919
it's basically saying that root is the

512
00:22:16,919 --> 00:22:20,100
object 1 0 and then size is just the

513
00:22:20,100 --> 00:22:22,080
number five

514
00:22:22,080 --> 00:22:26,580
so now let me uh actually show you what

515
00:22:26,580 --> 00:22:27,960
the specs is

516
00:22:27,960 --> 00:22:30,960
so there is uh interestingly there is a

517
00:22:30,960 --> 00:22:33,480
machine readable version of the spec and

518
00:22:33,480 --> 00:22:36,360
it's available on this link of the PDF

519
00:22:36,360 --> 00:22:40,140
Association and uh what I particularly

520
00:22:40,140 --> 00:22:42,480
wanted to show you was the file trailer

521
00:22:42,480 --> 00:22:44,460
because that's what I just showed you

522
00:22:44,460 --> 00:22:47,280
and if you recall what I just showed you

523
00:22:47,280 --> 00:22:50,820
there was a size key and a root key and

524
00:22:50,820 --> 00:22:54,240
those other two specified as required in

525
00:22:54,240 --> 00:22:55,640
the spec

526
00:22:55,640 --> 00:22:59,220
and pretty much everything else so the

527
00:22:59,220 --> 00:23:02,159
ID is required in certain situations we

528
00:23:02,159 --> 00:23:04,559
clearly do not have a version 2.0 we had

529
00:23:04,559 --> 00:23:07,380
a version 1.1 and everything else is

530
00:23:07,380 --> 00:23:10,460
pretty much just optional

531
00:23:15,179 --> 00:23:18,299
cool uh so that hopefully was

532
00:23:18,299 --> 00:23:20,820
interesting and uh

533
00:23:20,820 --> 00:23:23,220
and shows you how the our LinkedIn Dom

534
00:23:23,220 --> 00:23:26,280
actually matches to the spec uh the Dom

535
00:23:26,280 --> 00:23:30,260
is entirely in uh

536
00:23:30,480 --> 00:23:33,000
uh Dom stands for document object model

537
00:23:33,000 --> 00:23:36,600
and that that is entirely in tsv files

538
00:23:36,600 --> 00:23:39,299
there are totally 515 for version 2.0

539
00:23:39,299 --> 00:23:41,880
and it contains a lot of rows and a lot

540
00:23:41,880 --> 00:23:43,440
of columns

541
00:23:43,440 --> 00:23:45,900
uh what links are over here are the most

542
00:23:45,900 --> 00:23:48,179
interesting thing because they are user

543
00:23:48,179 --> 00:23:49,860
defined types that correspond to another

544
00:23:49,860 --> 00:23:51,960
file so there's another file that's

545
00:23:51,960 --> 00:23:55,280
going to contain more information

546
00:23:58,620 --> 00:24:00,740
everything

547
00:24:00,740 --> 00:24:04,799
yeah so uh let me now describe a little

548
00:24:04,799 --> 00:24:07,320
bit about the partially project and

549
00:24:07,320 --> 00:24:09,179
Sparta the tool that I'm here to talk to

550
00:24:09,179 --> 00:24:09,960
you about

551
00:24:09,960 --> 00:24:12,780
so the parsley project is basically a

552
00:24:12,780 --> 00:24:17,640
entire rust uh system where we are uh

553
00:24:17,640 --> 00:24:20,039
where we are checking syntax checking a

554
00:24:20,039 --> 00:24:22,740
file and then applying types to it and

555
00:24:22,740 --> 00:24:27,120
then extracting text or transforming it

556
00:24:27,120 --> 00:24:31,080
so uh what do I really mean by the uh

557
00:24:31,080 --> 00:24:33,240
generate rust score right so then we are

558
00:24:33,240 --> 00:24:35,940
basically taking the tsp files

559
00:24:35,940 --> 00:24:39,840
and then we uh generate we we have an

560
00:24:39,840 --> 00:24:42,120
API and we generate code that

561
00:24:42,120 --> 00:24:44,520
corresponds to that API

562
00:24:44,520 --> 00:24:47,159
and our type Checker essentially does a

563
00:24:47,159 --> 00:24:48,720
breadth first search starting from the

564
00:24:48,720 --> 00:24:51,559
catalog dictionary

565
00:24:57,840 --> 00:25:02,460
yeah so uh the Dom validator so the this

566
00:25:02,460 --> 00:25:05,100
part are checking tool itself contains a

567
00:25:05,100 --> 00:25:07,260
validator because we wanted to First

568
00:25:07,260 --> 00:25:09,659
make sure that the the tsv files

569
00:25:09,659 --> 00:25:11,940
themselves are valid and what we found

570
00:25:11,940 --> 00:25:13,679
was that when we compute these stack

571
00:25:13,679 --> 00:25:16,559
dependencies because you have uh

572
00:25:16,559 --> 00:25:18,900
pointers and links right within the spec

573
00:25:18,900 --> 00:25:20,159
itself

574
00:25:20,159 --> 00:25:22,200
we found that there were several

575
00:25:22,200 --> 00:25:24,120
inconsistencies that we had to report to

576
00:25:24,120 --> 00:25:27,659
the PDF Association and uh only then we

577
00:25:27,659 --> 00:25:29,640
were able only once those were fixed we

578
00:25:29,640 --> 00:25:30,840
were actually able to generate

579
00:25:30,840 --> 00:25:34,140
error-free rust code

580
00:25:34,140 --> 00:25:36,960
and uh here is actually an example of

581
00:25:36,960 --> 00:25:38,880
what the type Checker API itself looks

582
00:25:38,880 --> 00:25:42,419
like uh so you have uh basically

583
00:25:42,419 --> 00:25:44,820
dictionary required keys or optional

584
00:25:44,820 --> 00:25:47,760
keys on the right and then we enforce

585
00:25:47,760 --> 00:25:50,039
the specifications that are present

586
00:25:50,039 --> 00:25:53,159
in the Arlington Dome

587
00:25:53,159 --> 00:25:58,820
so uh yeah let me show you what the

588
00:26:14,760 --> 00:26:17,940
yeah so here's what the catalog

589
00:26:17,940 --> 00:26:20,940
dictionary type looks like uh so

590
00:26:20,940 --> 00:26:23,159
essentially it contains a bunch of

591
00:26:23,159 --> 00:26:25,679
assignments that are right at the bottom

592
00:26:25,679 --> 00:26:29,159
of the file and then uh we have

593
00:26:29,159 --> 00:26:32,659
individual declarations here

594
00:26:33,179 --> 00:26:35,400
the second argument over here which is

595
00:26:35,400 --> 00:26:37,200
true or false

596
00:26:37,200 --> 00:26:39,360
denotes whether it's going to be an

597
00:26:39,360 --> 00:26:41,100
indirect reference or a direct reference

598
00:26:41,100 --> 00:26:43,260
so what I mean by an indirect reference

599
00:26:43,260 --> 00:26:44,820
is that the object is going to be

600
00:26:44,820 --> 00:26:47,580
somewhere else and if this value is set

601
00:26:47,580 --> 00:26:49,320
to true that means that this particular

602
00:26:49,320 --> 00:26:52,620
object is going to be somewhere else and

603
00:26:52,620 --> 00:26:55,620
uh we basically uh so the optional key

604
00:26:55,620 --> 00:26:58,440
over here the opt key specifies whether

605
00:26:58,440 --> 00:27:00,179
this particular key is going to be

606
00:27:00,179 --> 00:27:02,640
optional or mandatory and this is how we

607
00:27:02,640 --> 00:27:06,419
actually Define a large dictionary like

608
00:27:06,419 --> 00:27:08,220
a catalog dictionary because that's the

609
00:27:08,220 --> 00:27:12,000
one that has like 33 keys or something

610
00:27:12,000 --> 00:27:13,620
yep

611
00:27:13,620 --> 00:27:15,779
uh

612
00:27:15,779 --> 00:27:18,779
yeah so uh

613
00:27:18,779 --> 00:27:21,059
we when we when we actually ran this

614
00:27:21,059 --> 00:27:24,240
tool right we found several issues that

615
00:27:24,240 --> 00:27:26,340
were really common my goal in this talk

616
00:27:26,340 --> 00:27:29,100
is to not name and shame people because

617
00:27:29,100 --> 00:27:32,039
that's already been done and we've

618
00:27:32,039 --> 00:27:33,840
reached out to them and told them to fix

619
00:27:33,840 --> 00:27:36,720
things uh and often what ends up

620
00:27:36,720 --> 00:27:38,940
happening is that the spec is weakened

621
00:27:38,940 --> 00:27:41,400
to accommodate some big players who may

622
00:27:41,400 --> 00:27:43,980
have made these mistakes so that's why

623
00:27:43,980 --> 00:27:46,320
you see on the outcome column quite

624
00:27:46,320 --> 00:27:48,539
often the specification was fixed

625
00:27:48,539 --> 00:27:51,179
because some big players violated the

626
00:27:51,179 --> 00:27:53,580
spec it's very difficult to fix it now

627
00:27:53,580 --> 00:27:55,980
because there are several files in in

628
00:27:55,980 --> 00:27:58,380
the wild already so it's not going to

629
00:27:58,380 --> 00:28:01,559
happen uh one thing that's of particular

630
00:28:01,559 --> 00:28:04,559
interest over here is the uh page tree

631
00:28:04,559 --> 00:28:08,760
node Keys missing so I'll get to that in

632
00:28:08,760 --> 00:28:11,039
the next slide but before that uh there

633
00:28:11,039 --> 00:28:14,100
is the language key as well and uh the

634
00:28:14,100 --> 00:28:15,960
language key is a key that's present in

635
00:28:15,960 --> 00:28:17,820
the catalog dictionary and it's very

636
00:28:17,820 --> 00:28:20,880
extensively used because it specifies

637
00:28:20,880 --> 00:28:22,500
what language the file is supposed to

638
00:28:22,500 --> 00:28:23,419
follow

639
00:28:23,419 --> 00:28:25,500
and the reason I say that that's

640
00:28:25,500 --> 00:28:27,120
important is because without knowing

641
00:28:27,120 --> 00:28:28,679
what language it is how do you extract

642
00:28:28,679 --> 00:28:31,919
text because sometimes the language

643
00:28:31,919 --> 00:28:33,600
might be a right to left language or a

644
00:28:33,600 --> 00:28:35,460
top-down language and you really need to

645
00:28:35,460 --> 00:28:37,500
know what language it is before you can

646
00:28:37,500 --> 00:28:40,100
extract text

647
00:28:40,340 --> 00:28:42,960
so the reason I said that the page three

648
00:28:42,960 --> 00:28:46,440
node nodes are quite interesting is uh

649
00:28:46,440 --> 00:28:49,200
the spec right so the spec says that

650
00:28:49,200 --> 00:28:51,240
there are three keys that are required

651
00:28:51,240 --> 00:28:54,240
and the parent key except in the root

652
00:28:54,240 --> 00:28:56,820
node it's not it's not permitted in the

653
00:28:56,820 --> 00:28:58,860
root node but any other time it's

654
00:28:58,860 --> 00:29:01,500
required so the type key the kids key

655
00:29:01,500 --> 00:29:03,659
and the count key and what you see on

656
00:29:03,659 --> 00:29:07,260
the left is a file that's is an object

657
00:29:07,260 --> 00:29:09,360
that's from a real file where you can

658
00:29:09,360 --> 00:29:11,340
clearly see that one of these keys are

659
00:29:11,340 --> 00:29:13,140
not present

660
00:29:13,140 --> 00:29:15,659
and you might think that what's the big

661
00:29:15,659 --> 00:29:17,760
deal right why should I it's such an

662
00:29:17,760 --> 00:29:19,919
easy thing to fix let me actually show

663
00:29:19,919 --> 00:29:22,640
you a file right

664
00:29:25,200 --> 00:29:30,600
uh so I'm just gonna call uh our PDF

665
00:29:30,600 --> 00:29:33,480
printer which is the tool that uh that

666
00:29:33,480 --> 00:29:36,419
actually uh that actually type checks

667
00:29:36,419 --> 00:29:40,640
the file and uh

668
00:29:42,000 --> 00:29:44,760
and you'll see that we found a missing

669
00:29:44,760 --> 00:29:47,399
count key and it's at a certain location

670
00:29:47,399 --> 00:29:49,320
74e

671
00:29:49,320 --> 00:29:53,340
so I'm just gonna uh open that open this

672
00:29:53,340 --> 00:29:55,080
file and show you that particular

673
00:29:55,080 --> 00:29:57,600
location and show you this uh key

674
00:29:57,600 --> 00:30:00,020
missing

675
00:30:03,960 --> 00:30:06,539
yeah so you see that it only has has a

676
00:30:06,539 --> 00:30:08,460
kids object a kids key and a type key

677
00:30:08,460 --> 00:30:12,000
and hence uh the type Checker was right

678
00:30:12,000 --> 00:30:14,279
and finding that this this this file is

679
00:30:14,279 --> 00:30:17,580
invalid but is it really invalid like

680
00:30:17,580 --> 00:30:19,620
you're again thinking this is such a

681
00:30:19,620 --> 00:30:21,600
small bug it should

682
00:30:21,600 --> 00:30:25,039
yeah don't open

683
00:30:26,760 --> 00:30:28,799
um so

684
00:30:28,799 --> 00:30:31,080
we also have a version of this

685
00:30:31,080 --> 00:30:33,899
particular type Checker that fixes bugs

686
00:30:33,899 --> 00:30:37,500
uh inline and then writes the fixed PDF

687
00:30:37,500 --> 00:30:41,100
to a separate uh separate location

688
00:30:41,100 --> 00:30:43,860
but of course we fix only certain issues

689
00:30:43,860 --> 00:30:47,418
like these Keys missing

690
00:30:51,840 --> 00:30:53,700
and we run it again in the fixed mode

691
00:30:53,700 --> 00:30:56,820
and again we find something else

692
00:30:56,820 --> 00:30:58,679
so uh

693
00:30:58,679 --> 00:31:03,080
yeah this time it's the same file

694
00:31:07,260 --> 00:31:10,380
yeah so it's basically a page object and

695
00:31:10,380 --> 00:31:12,899
again the the parent key is missing in

696
00:31:12,899 --> 00:31:14,880
this one and the parent key is actually

697
00:31:14,880 --> 00:31:18,299
mandatory in a page object so again the

698
00:31:18,299 --> 00:31:20,520
error is correct and the file is invalid

699
00:31:20,520 --> 00:31:22,620
in that sense but

700
00:31:22,620 --> 00:31:24,539
the most interesting thing here is of

701
00:31:24,539 --> 00:31:26,700
course were we able to successfully fix

702
00:31:26,700 --> 00:31:30,240
it and it writes a file in its current

703
00:31:30,240 --> 00:31:33,480
state to on this particular path and

704
00:31:33,480 --> 00:31:36,600
when you open it you can read a lot of

705
00:31:36,600 --> 00:31:38,640
these things

706
00:31:38,640 --> 00:31:41,399
so yeah we we were able to successfully

707
00:31:41,399 --> 00:31:45,600
fix it and uh to just show you some text

708
00:31:45,600 --> 00:31:49,200
from the file you would see that this

709
00:31:49,200 --> 00:31:52,740
particular object 2 0 OBS it's called

710
00:31:52,740 --> 00:31:54,179
the info dictionary or the information

711
00:31:54,179 --> 00:31:57,179
dictionary and that reveals the name of

712
00:31:57,179 --> 00:32:00,960
the person like s-o-p-h-i-a

713
00:32:00,960 --> 00:32:03,840
so yeah you can technically see some

714
00:32:03,840 --> 00:32:05,340
metadata from the info dictionary

715
00:32:05,340 --> 00:32:08,100
including the title of the uh the the

716
00:32:08,100 --> 00:32:09,780
PDF and other things

717
00:32:09,780 --> 00:32:12,240
[Music]

718
00:32:12,240 --> 00:32:13,440
yeah

719
00:32:13,440 --> 00:32:16,320
so yeah it's the same file and we were

720
00:32:16,320 --> 00:32:19,080
able to successfully fix it because we

721
00:32:19,080 --> 00:32:21,000
we look for this particular bug and we

722
00:32:21,000 --> 00:32:24,260
fixed it right

723
00:32:26,159 --> 00:32:29,100
so yeah uh that was the demo of the type

724
00:32:29,100 --> 00:32:33,179
Checker and uh us fixing it uh we we did

725
00:32:33,179 --> 00:32:35,159
actually evaluate it on another large

726
00:32:35,159 --> 00:32:37,500
data set actually we collected a bunch

727
00:32:37,500 --> 00:32:40,620
of data from uh archive uh three months

728
00:32:40,620 --> 00:32:42,960
actually almost and uh

729
00:32:42,960 --> 00:32:45,960
it was over 100 gigabytes of files and

730
00:32:45,960 --> 00:32:48,559
there were certain types of type errors

731
00:32:48,559 --> 00:32:52,020
that seemed to occur a lot in latex

732
00:32:52,020 --> 00:32:54,960
files and latex seems to be doing fonts

733
00:32:54,960 --> 00:32:57,419
absolutely terribly

734
00:32:57,419 --> 00:33:00,840
but uh more commonly when you look at a

735
00:33:00,840 --> 00:33:03,059
million files from common crawl the most

736
00:33:03,059 --> 00:33:05,039
common bugs that we end up seeing are

737
00:33:05,039 --> 00:33:06,600
incorrect language Keys which are

738
00:33:06,600 --> 00:33:09,720
terrible for text extraction page three

739
00:33:09,720 --> 00:33:11,820
node errors because they cannot be

740
00:33:11,820 --> 00:33:13,860
rendered at all so there are 20K files

741
00:33:13,860 --> 00:33:16,320
that most other tools might think are

742
00:33:16,320 --> 00:33:19,320
fully valid but most tools there are a

743
00:33:19,320 --> 00:33:20,640
lot of tools that can't even render

744
00:33:20,640 --> 00:33:23,159
these files and then of course page more

745
00:33:23,159 --> 00:33:25,320
keys which denote whether it's two

746
00:33:25,320 --> 00:33:28,019
column one column those type of things

747
00:33:28,019 --> 00:33:30,179
and null references are another thing

748
00:33:30,179 --> 00:33:32,640
where you have a reference to a certain

749
00:33:32,640 --> 00:33:34,320
object but the object doesn't exist in

750
00:33:34,320 --> 00:33:36,000
your file at all and even that's

751
00:33:36,000 --> 00:33:38,460
something that's really common uh again

752
00:33:38,460 --> 00:33:39,960
as I mentioned earlier I don't want to

753
00:33:39,960 --> 00:33:43,200
name and shame companies or tools that

754
00:33:43,200 --> 00:33:45,600
actually commit these errors but latex

755
00:33:45,600 --> 00:33:49,140
tools definitely do a lot of these

756
00:33:49,140 --> 00:33:52,679
so yeah uh to actually fix these bugs we

757
00:33:52,679 --> 00:33:56,220
have an engine where we read a set of

758
00:33:56,220 --> 00:33:58,320
these uh reducer rules that that's what

759
00:33:58,320 --> 00:34:01,620
we call it reducer and we apply these

760
00:34:01,620 --> 00:34:03,240
transformations to an intermediate

761
00:34:03,240 --> 00:34:07,140
language that we have and then we we

762
00:34:07,140 --> 00:34:09,418
actually write the modified IR that we

763
00:34:09,418 --> 00:34:12,119
have using a serializer and we produce a

764
00:34:12,119 --> 00:34:14,699
transform PDF file that's canonicalized

765
00:34:14,699 --> 00:34:17,159
and that's simplified and has only one

766
00:34:17,159 --> 00:34:19,859
cross reference table so technically a

767
00:34:19,859 --> 00:34:21,780
PDF file can have many cross reference

768
00:34:21,780 --> 00:34:23,820
tables with links and we are trying to

769
00:34:23,820 --> 00:34:25,679
simplify that as well

770
00:34:25,679 --> 00:34:28,918
all right so yeah uh this was one thing

771
00:34:28,918 --> 00:34:31,139
that I just showed you that we can

772
00:34:31,139 --> 00:34:33,060
actually fix as a set of our reducer

773
00:34:33,060 --> 00:34:35,280
rules we have a lot of other rules as

774
00:34:35,280 --> 00:34:38,219
well uh for example if there are some of

775
00:34:38,219 --> 00:34:40,020
the font keys that are missing we can

776
00:34:40,020 --> 00:34:42,980
fix those as well

777
00:34:43,320 --> 00:34:45,719
so yeah when would you even want to use

778
00:34:45,719 --> 00:34:48,418
such a tool uh if you want to normalize

779
00:34:48,418 --> 00:34:51,480
PDFs uh and there are certain bugs that

780
00:34:51,480 --> 00:34:52,918
are causing differentials you want to

781
00:34:52,918 --> 00:34:54,960
normalize it you can do this if you want

782
00:34:54,960 --> 00:34:56,940
to redact some information

783
00:34:56,940 --> 00:34:58,920
uh as I showed you the info dictionary

784
00:34:58,920 --> 00:35:01,680
contains operating system versions uh

785
00:35:01,680 --> 00:35:04,020
creation tools that were used author

786
00:35:04,020 --> 00:35:04,859
names

787
00:35:04,859 --> 00:35:07,320
and uh what we do is we actually redact

788
00:35:07,320 --> 00:35:09,780
all of that from the info dictionary

789
00:35:09,780 --> 00:35:12,240
and another thing that I actually did

790
00:35:12,240 --> 00:35:14,280
was I was also able to generate a file

791
00:35:14,280 --> 00:35:16,440
that causes the denial of service attack

792
00:35:16,440 --> 00:35:19,500
in mutual by creating a certain Loop in

793
00:35:19,500 --> 00:35:22,880
the catalog dictionary

794
00:35:23,220 --> 00:35:25,920
so yeah uh we are using the machine

795
00:35:25,920 --> 00:35:27,720
readable spec but of course there is

796
00:35:27,720 --> 00:35:30,900
some resistance to incorporating this in

797
00:35:30,900 --> 00:35:33,980
public tools

798
00:35:34,560 --> 00:35:37,680
but uh there is a push to use machine

799
00:35:37,680 --> 00:35:40,500
readable specs such as dfdl and kaitai

800
00:35:40,500 --> 00:35:43,020
in The Wire where you want to write the

801
00:35:43,020 --> 00:35:45,060
entire specification in a data

802
00:35:45,060 --> 00:35:47,160
description language but there is some

803
00:35:47,160 --> 00:35:49,859
resistance to this obviously because uh

804
00:35:49,859 --> 00:35:51,839
dftl and kaitaia are not powerful enough

805
00:35:51,839 --> 00:35:55,619
to even represent something like PDF PDF

806
00:35:55,619 --> 00:35:56,940
is so complex that you can't even

807
00:35:56,940 --> 00:35:59,640
represent most of the things in PDF uh

808
00:35:59,640 --> 00:36:02,280
uh in in a language like dftl or Kai

809
00:36:02,280 --> 00:36:03,240
type

810
00:36:03,240 --> 00:36:05,520
so we don't need some new languages that

811
00:36:05,520 --> 00:36:09,240
can capture the complexities of of a PDF

812
00:36:09,240 --> 00:36:11,040
file format

813
00:36:11,040 --> 00:36:12,599
so yeah

814
00:36:12,599 --> 00:36:16,440
uh PDFs in the wild are crazy uh PDF

815
00:36:16,440 --> 00:36:19,200
spec and what PDF processors do are

816
00:36:19,200 --> 00:36:22,859
completely different and uh so yeah that

817
00:36:22,859 --> 00:36:24,960
was my talk

818
00:36:24,960 --> 00:36:27,090
thank you thank you for listening

819
00:36:27,090 --> 00:36:31,800
[Applause]

820
00:36:31,800 --> 00:36:34,740
hello do we have any questions

821
00:36:34,740 --> 00:36:37,098
foreign

822
00:36:37,260 --> 00:36:39,599
that was amazing I just wanted to know

823
00:36:39,599 --> 00:36:41,520
the results of the 40 000 files you

824
00:36:41,520 --> 00:36:44,700
shortlisted I can't hear you properly is

825
00:36:44,700 --> 00:36:46,680
it audible now yeah yeah okay I wanted

826
00:36:46,680 --> 00:36:48,839
to know the results of the 40 000 files

827
00:36:48,839 --> 00:36:50,760
the sample you took what was the output

828
00:36:50,760 --> 00:36:52,980
of that were you able to fix all of them

829
00:36:52,980 --> 00:36:56,280
no so uh the thing is that most of these

830
00:36:56,280 --> 00:36:58,500
files were of course vetted by archive

831
00:36:58,500 --> 00:37:00,720
itself so archive actually Compares most

832
00:37:00,720 --> 00:37:01,920
of them

833
00:37:01,920 --> 00:37:04,619
so most of them did not need any fixing

834
00:37:04,619 --> 00:37:07,260
and uh these were type errors that we

835
00:37:07,260 --> 00:37:08,700
were absolutely not able to fix because

836
00:37:08,700 --> 00:37:11,339
we had never even seen them uh because

837
00:37:11,339 --> 00:37:14,220
this was a very uh we it's we

838
00:37:14,220 --> 00:37:16,079
technically over sampled latex files

839
00:37:16,079 --> 00:37:18,000
right so then this was not something

840
00:37:18,000 --> 00:37:19,260
that we were able to fix at all

841
00:37:19,260 --> 00:37:21,780
automatically so if we talk about the

842
00:37:21,780 --> 00:37:24,780
percentage you were able to fix from the

843
00:37:24,780 --> 00:37:27,660
right set of this 40 000 what would that

844
00:37:27,660 --> 00:37:29,880
percentage be

845
00:37:29,880 --> 00:37:31,800
the thing is most of them didn't need to

846
00:37:31,800 --> 00:37:35,579
be fixed in case of archive but uh I

847
00:37:35,579 --> 00:37:37,260
don't have that exact number I can get

848
00:37:37,260 --> 00:37:40,880
back to you on that okay thanks

849
00:37:40,920 --> 00:37:43,940
any more questions

850
00:37:51,960 --> 00:37:53,820
hello sir hi

851
00:37:53,820 --> 00:37:56,760
what about PDF injections

852
00:37:56,760 --> 00:37:59,280
uh what type of PDF engine like

853
00:37:59,280 --> 00:38:01,800
inserting JavaScript like alert submit

854
00:38:01,800 --> 00:38:03,119
form

855
00:38:03,119 --> 00:38:05,339
yeah so

856
00:38:05,339 --> 00:38:09,000
they are there and I those those are

857
00:38:09,000 --> 00:38:10,740
usually completely valid in the spec

858
00:38:10,740 --> 00:38:13,320
right how to exploit it sorry how to

859
00:38:13,320 --> 00:38:14,520
exploit it

860
00:38:14,520 --> 00:38:17,900
how to exploit what from P4 to P1 P2

861
00:38:17,900 --> 00:38:19,980
yeah right

862
00:38:19,980 --> 00:38:21,420
so

863
00:38:21,420 --> 00:38:23,339
the thing is that

864
00:38:23,339 --> 00:38:25,980
you can put arbitrary JavaScript inside

865
00:38:25,980 --> 00:38:29,280
a PDF file and uh

866
00:38:29,280 --> 00:38:32,160
how to exploit it or even

867
00:38:32,160 --> 00:38:35,099
do we prevent it was not something that

868
00:38:35,099 --> 00:38:37,619
we were interested in doing because we

869
00:38:37,619 --> 00:38:40,079
were trying to enforce the spec

870
00:38:40,079 --> 00:38:42,180
and so we are saying that you can do it

871
00:38:42,180 --> 00:38:46,700
yes of course thank you yeah

872
00:38:46,820 --> 00:38:49,140
how do you think we can make a strong

873
00:38:49,140 --> 00:38:50,280
spec

874
00:38:50,280 --> 00:38:54,540
like uh sorry yeah how do you think we

875
00:38:54,540 --> 00:38:56,220
can make a strong spec do we need to

876
00:38:56,220 --> 00:38:58,140
hide the language until it has a perfect

877
00:38:58,140 --> 00:39:00,780
spec or what do you think is better

878
00:39:00,780 --> 00:39:04,320
so there is the thing that I

879
00:39:04,320 --> 00:39:06,960
my personal opinion would be that yes

880
00:39:06,960 --> 00:39:09,540
you have to start uh making things

881
00:39:09,540 --> 00:39:11,700
stricter you have to name and shame

882
00:39:11,700 --> 00:39:13,440
people you have to force people to use

883
00:39:13,440 --> 00:39:16,200
the machine readable version of the spec

884
00:39:16,200 --> 00:39:18,240
but there is the other side which I

885
00:39:18,240 --> 00:39:19,859
understand in market economics here and

886
00:39:19,859 --> 00:39:22,859
it's not going to happen so what's going

887
00:39:22,859 --> 00:39:25,920
to continue to happen is that uh big

888
00:39:25,920 --> 00:39:27,540
players will continue to make mistakes

889
00:39:27,540 --> 00:39:29,579
in new features

890
00:39:29,579 --> 00:39:32,160
and then we'll keep reverting back the

891
00:39:32,160 --> 00:39:34,440
spec we'll keep making the spec weak

892
00:39:34,440 --> 00:39:36,300
weaker and weaker to accommodate all the

893
00:39:36,300 --> 00:39:38,820
mistakes that others are making

894
00:39:38,820 --> 00:39:40,079
yeah

895
00:39:40,079 --> 00:39:43,640
does anyone else have any questions

896
00:39:43,980 --> 00:39:46,440
so have you taken a look at my PDF a

897
00:39:46,440 --> 00:39:48,960
specification for alka Evolution and

898
00:39:48,960 --> 00:39:50,640
it's a situation they are significantly

899
00:39:50,640 --> 00:39:52,980
better when for normal PDF it's much

900
00:39:52,980 --> 00:39:56,640
better because PDF a was written with

901
00:39:56,640 --> 00:39:58,020
the whole goal of making it machine

902
00:39:58,020 --> 00:40:01,800
readable but uh some ongoing work is

903
00:40:01,800 --> 00:40:03,420
actually understanding what percentage

904
00:40:03,420 --> 00:40:05,160
of files in the wild or even PDF a

905
00:40:05,160 --> 00:40:07,980
compliant and it's less than a percent

906
00:40:07,980 --> 00:40:12,900
like so pdfa is so strict that it's less

907
00:40:12,900 --> 00:40:14,640
than a percent of files that would be

908
00:40:14,640 --> 00:40:16,740
compliant with that strict version of

909
00:40:16,740 --> 00:40:17,880
the specification

910
00:40:17,880 --> 00:40:20,300
yeah

911
00:40:20,820 --> 00:40:23,520
any more questions

912
00:40:23,520 --> 00:40:25,940
I think

913
00:40:25,980 --> 00:40:28,680
cool thank you all and uh if you still

914
00:40:28,680 --> 00:40:30,000
have some questions you can come and

915
00:40:30,000 --> 00:40:32,460
find me one more question yeah sure like

916
00:40:32,460 --> 00:40:34,800
where we can know more about langzek

917
00:40:34,800 --> 00:40:38,520
sorry language yeah uh you're saying you

918
00:40:38,520 --> 00:40:41,640
want to know more uh there is a website

919
00:40:41,640 --> 00:40:44,280
called langstec.org and you can go there

920
00:40:44,280 --> 00:40:48,540
and see some seminal papers and uh there

921
00:40:48,540 --> 00:40:50,520
is a grad program at Dartmouth where I

922
00:40:50,520 --> 00:40:52,859
did my PhD and they are looking for PhD

923
00:40:52,859 --> 00:40:55,200
students so if you are interested then

924
00:40:55,200 --> 00:40:57,300
and if you are interested in card school

925
00:40:57,300 --> 00:41:01,099
you should apply yeah thanks

926
00:41:01,920 --> 00:41:04,440
yep thank you all and you can come and

927
00:41:04,440 --> 00:41:06,619
find me somewhere grabbing some coffee

928
00:41:06,619 --> 00:41:09,680
yep see you all bye

929
00:41:09,680 --> 00:41:13,569
[Applause]

