1
00:00:03,020 --> 00:00:05,700
hello everyone

2
00:00:05,700 --> 00:00:07,859
thanks for the introduction yes my name

3
00:00:07,859 --> 00:00:10,260
is Alexander papov and I will tell you

4
00:00:10,260 --> 00:00:14,460
how I met fuchsia operating system

5
00:00:14,460 --> 00:00:17,400
I'm a Linux kernel developer since 2013

6
00:00:17,400 --> 00:00:19,859
and I'm security research at positive

7
00:00:19,859 --> 00:00:21,779
Technologies I gave talks at many

8
00:00:21,779 --> 00:00:24,240
security and developer conferences and

9
00:00:24,240 --> 00:00:27,180
I'm really happy to be here at nalcon

10
00:00:27,180 --> 00:00:29,640
and share the results of my research

11
00:00:29,640 --> 00:00:31,800
with you okay

12
00:00:31,800 --> 00:00:34,680
the plan of the talk first I will give

13
00:00:34,680 --> 00:00:36,719
the overview what is future operating

14
00:00:36,719 --> 00:00:40,440
system and about it I will tell about

15
00:00:40,440 --> 00:00:42,899
its security architecture

16
00:00:42,899 --> 00:00:44,879
I will show how to build this operating

17
00:00:44,879 --> 00:00:48,300
system and I will tell about the Zircon

18
00:00:48,300 --> 00:00:49,940
micro kernel

19
00:00:49,940 --> 00:00:53,219
which is a part of fuchsia

20
00:00:53,219 --> 00:00:56,280
and then I will describe my exploit

21
00:00:56,280 --> 00:00:57,920
development experiments

22
00:00:57,920 --> 00:01:00,719
for that silicon micro kernel and show

23
00:01:00,719 --> 00:01:02,280
the exploit demo

24
00:01:02,280 --> 00:01:05,280
big plans so let's go

25
00:01:05,280 --> 00:01:08,820
fuchsia it is a general purpose open

26
00:01:08,820 --> 00:01:10,979
source operating system it was created

27
00:01:10,979 --> 00:01:15,840
in Google approximately six uh years ago

28
00:01:15,840 --> 00:01:18,900
and it is mainly developed for iot

29
00:01:18,900 --> 00:01:22,439
smartphones PCS so the ecosystem of

30
00:01:22,439 --> 00:01:24,420
connected devices

31
00:01:24,420 --> 00:01:28,200
and in December 2020 Google decided to

32
00:01:28,200 --> 00:01:31,080
open Future for contributors not only

33
00:01:31,080 --> 00:01:32,360
from Google

34
00:01:32,360 --> 00:01:35,280
and later they officially released

35
00:01:35,280 --> 00:01:38,100
fuchsia as a operating system of their

36
00:01:38,100 --> 00:01:41,520
nest Hub device which is the device

37
00:01:41,520 --> 00:01:44,280
which controls Smart Home

38
00:01:44,280 --> 00:01:47,700
and this operating system is under

39
00:01:47,700 --> 00:01:51,180
active development and securities one of

40
00:01:51,180 --> 00:01:54,899
the goals of future Developers

41
00:01:54,899 --> 00:01:56,460
and

42
00:01:56,460 --> 00:01:59,640
it is based on the micro kernel it is

43
00:01:59,640 --> 00:02:02,659
called silicon it is written in C plus

44
00:02:02,659 --> 00:02:05,880
and compared to the Linux kernel which

45
00:02:05,880 --> 00:02:07,799
is a monolithic kernel cerecon

46
00:02:07,799 --> 00:02:11,340
implements less services

47
00:02:11,340 --> 00:02:13,560
it implements inter-process

48
00:02:13,560 --> 00:02:14,879
communication memory management

49
00:02:14,879 --> 00:02:17,459
scheduler and Process Management and

50
00:02:17,459 --> 00:02:19,860
other things like networking file

51
00:02:19,860 --> 00:02:22,680
systems device drivers are moved to the

52
00:02:22,680 --> 00:02:24,660
user space

53
00:02:24,660 --> 00:02:25,800
um

54
00:02:25,800 --> 00:02:30,780
and I see several aspects in future

55
00:02:30,780 --> 00:02:33,060
security architecture which make the

56
00:02:33,060 --> 00:02:35,099
system an interesting Target for the

57
00:02:35,099 --> 00:02:37,500
security research and I want to tell

58
00:02:37,500 --> 00:02:40,080
about them first of all what's

59
00:02:40,080 --> 00:02:42,180
interesting fuchsia doesn't have the

60
00:02:42,180 --> 00:02:43,800
concept of a user

61
00:02:43,800 --> 00:02:46,500
instead it is a capability based system

62
00:02:46,500 --> 00:02:49,980
so the kernel resources are given to the

63
00:02:49,980 --> 00:02:51,239
applications

64
00:02:51,239 --> 00:02:53,519
which have the corresponding

65
00:02:53,519 --> 00:02:56,760
capabilities and the main idea is to

66
00:02:56,760 --> 00:02:57,980
have

67
00:02:57,980 --> 00:03:01,980
to have list capabilities for each

68
00:03:01,980 --> 00:03:05,099
application to do the job

69
00:03:05,099 --> 00:03:08,220
that is important for the security

70
00:03:08,220 --> 00:03:10,440
architecture because the concept of

71
00:03:10,440 --> 00:03:12,540
local privilege escalation which we have

72
00:03:12,540 --> 00:03:15,000
for the Linux kernel doesn't work for

73
00:03:15,000 --> 00:03:17,640
future because there is no root user and

74
00:03:17,640 --> 00:03:21,720
like in Linux kernel we can execute the

75
00:03:21,720 --> 00:03:24,959
code AS unprivileged user exploit the

76
00:03:24,959 --> 00:03:27,680
vulnerability in the kernel and

77
00:03:27,680 --> 00:03:30,720
become root here in future it doesn't

78
00:03:30,720 --> 00:03:33,239
work and we need to find some other

79
00:03:33,239 --> 00:03:35,720
approach

80
00:03:35,879 --> 00:03:39,200
second interesting aspect I only already

81
00:03:39,200 --> 00:03:42,599
mentioned it fuchsia is based on the

82
00:03:42,599 --> 00:03:46,140
micro kernel and it has

83
00:03:46,140 --> 00:03:48,480
a smaller kernel attack surface compared

84
00:03:48,480 --> 00:03:50,879
to monolithic kernels

85
00:03:50,879 --> 00:03:53,340
at the same time fuchsia developers

86
00:03:53,340 --> 00:03:56,159
don't have a goal to make it the

87
00:03:56,159 --> 00:03:59,879
Terracon really minimal so this micro

88
00:03:59,879 --> 00:04:03,780
kernel has over 170 system calls quite a

89
00:04:03,780 --> 00:04:06,420
lot compared to other typical micro

90
00:04:06,420 --> 00:04:07,620
kernels

91
00:04:07,620 --> 00:04:11,900
so it is a complex Target

92
00:04:12,420 --> 00:04:16,798
the third thing is that fuchsia provides

93
00:04:16,798 --> 00:04:19,858
very rich sandboxing mechanisms for the

94
00:04:19,858 --> 00:04:21,298
applications applications in the future

95
00:04:21,298 --> 00:04:23,940
are called components and each component

96
00:04:23,940 --> 00:04:26,780
run in uh

97
00:04:26,780 --> 00:04:28,979
separate sandbox

98
00:04:28,979 --> 00:04:32,040
and there is even no Global file system

99
00:04:32,040 --> 00:04:35,580
in future so every application works in

100
00:04:35,580 --> 00:04:38,460
a local namespace and all inter-process

101
00:04:38,460 --> 00:04:40,199
communication between the applications

102
00:04:40,199 --> 00:04:44,940
must be explicitly declared so obviously

103
00:04:44,940 --> 00:04:48,560
this design decision makes user space

104
00:04:48,560 --> 00:04:52,759
security better and isolate

105
00:04:52,759 --> 00:04:55,139
components or applications from each

106
00:04:55,139 --> 00:04:58,020
other at the same time I think uh this

107
00:04:58,020 --> 00:05:00,600
design decision makes silicon micro

108
00:05:00,600 --> 00:05:04,139
kernel very attractive gold Target for

109
00:05:04,139 --> 00:05:06,000
the attacker

110
00:05:06,000 --> 00:05:08,759
the last very interesting aspect is that

111
00:05:08,759 --> 00:05:11,400
fusch has very unusual scheme of

112
00:05:11,400 --> 00:05:14,639
software delivering

113
00:05:14,639 --> 00:05:16,919
um their components in the system are

114
00:05:16,919 --> 00:05:20,940
identified by URLs and when you want to

115
00:05:20,940 --> 00:05:22,940
execute some application of the system

116
00:05:22,940 --> 00:05:27,500
you specify this URL and the software is

117
00:05:27,500 --> 00:05:30,720
downloaded to the system on demand so

118
00:05:30,720 --> 00:05:32,699
the idea here is to make software

119
00:05:32,699 --> 00:05:35,160
packages always up to date when you

120
00:05:35,160 --> 00:05:37,919
start them just like the web pages when

121
00:05:37,919 --> 00:05:40,620
you open it you see the current contents

122
00:05:40,620 --> 00:05:43,139
the same ID is here

123
00:05:43,139 --> 00:05:47,539
and all this for uh

124
00:05:47,539 --> 00:05:50,699
architecture decisions make fuchsia very

125
00:05:50,699 --> 00:05:52,740
interesting research Target

126
00:05:52,740 --> 00:05:55,620
at least for me

127
00:05:55,620 --> 00:05:59,039
some some words how to build it

128
00:05:59,039 --> 00:06:02,400
it is very easy fuchsia has a very good

129
00:06:02,400 --> 00:06:06,060
step-by-step tutorial

130
00:06:06,120 --> 00:06:12,000
how to build it and it works very well

131
00:06:12,000 --> 00:06:14,460
and you even don't need a special

132
00:06:14,460 --> 00:06:16,740
Hardware to run fuchsia

133
00:06:16,740 --> 00:06:20,460
you can start it in the emulator which

134
00:06:20,460 --> 00:06:23,340
is a fork of Android emulator

135
00:06:23,340 --> 00:06:26,460
and I also want to mention that future

136
00:06:26,460 --> 00:06:29,940
supports only two architectures x8664

137
00:06:29,940 --> 00:06:33,539
and arm 64. so

138
00:06:33,539 --> 00:06:35,100
um

139
00:06:35,100 --> 00:06:37,560
you can try it on these two

140
00:06:37,560 --> 00:06:40,020
architectures

141
00:06:40,020 --> 00:06:43,259
creating a component is a toy component

142
00:06:43,259 --> 00:06:45,180
for the system is quite easy as well

143
00:06:45,180 --> 00:06:48,180
there is a command which creates a

144
00:06:48,180 --> 00:06:49,380
template

145
00:06:49,380 --> 00:06:52,680
for for the application and here my toy

146
00:06:52,680 --> 00:06:55,380
application wants to print hello to the

147
00:06:55,380 --> 00:06:57,380
system log

148
00:06:57,380 --> 00:07:02,160
and to to run it I need to specify the

149
00:07:02,160 --> 00:07:05,639
Manifest that

150
00:07:05,639 --> 00:07:09,060
this application wants to bring print

151
00:07:09,060 --> 00:07:12,120
something to system logs that's why I

152
00:07:12,120 --> 00:07:14,100
specified

153
00:07:14,100 --> 00:07:15,840
logging in the Manifest of the

154
00:07:15,840 --> 00:07:16,979
application

155
00:07:16,979 --> 00:07:18,900
so all the capabilities of the

156
00:07:18,900 --> 00:07:22,259
applications must be explicitly declared

157
00:07:22,259 --> 00:07:24,840
and building fuchsia with a new

158
00:07:24,840 --> 00:07:27,900
component to build it uh just we just

159
00:07:27,900 --> 00:07:30,660
need to add a parameter to the build

160
00:07:30,660 --> 00:07:34,319
command but running it uh

161
00:07:34,319 --> 00:07:37,860
on the system is a bit more complex it

162
00:07:37,860 --> 00:07:41,099
needs four steps and I will show it on

163
00:07:41,099 --> 00:07:42,660
this screenshot

164
00:07:42,660 --> 00:07:45,660
in the first terminal we need to start

165
00:07:45,660 --> 00:07:50,340
the emulator it is terminal number one

166
00:07:50,340 --> 00:07:53,160
this one in the second terminal we need

167
00:07:53,160 --> 00:07:55,740
to start the

168
00:07:55,740 --> 00:07:58,620
so-called package publishing server it

169
00:07:58,620 --> 00:08:00,599
is the software which will provide

170
00:08:00,599 --> 00:08:01,919
future

171
00:08:01,919 --> 00:08:06,020
um their software packages in the third

172
00:08:06,020 --> 00:08:11,099
terminal I opened the system logs and in

173
00:08:11,099 --> 00:08:13,199
the fourth terminal I asked fuchsia

174
00:08:13,199 --> 00:08:15,780
please run my application with this URL

175
00:08:15,780 --> 00:08:19,139
and and then I got the

176
00:08:19,139 --> 00:08:23,039
uh hello in the third terminal so

177
00:08:23,039 --> 00:08:25,979
because of this uh

178
00:08:25,979 --> 00:08:29,639
software delivery scheme it is it looks

179
00:08:29,639 --> 00:08:31,560
quite complex

180
00:08:31,560 --> 00:08:33,599
it has four connected devices

181
00:08:33,599 --> 00:08:36,419
now about the micro kernel Circle micro

182
00:08:36,419 --> 00:08:39,000
kernel as I said is written in C plus it

183
00:08:39,000 --> 00:08:42,120
is a part of fusion source code and to

184
00:08:42,120 --> 00:08:44,640
develop this micro kernel you need to

185
00:08:44,640 --> 00:08:48,899
run this system in the qm KVM

186
00:08:48,899 --> 00:08:52,800
debugging it very similar to the

187
00:08:52,800 --> 00:08:55,560
experience of debugging the Linux kernel

188
00:08:55,560 --> 00:08:58,100
and you start koyamo

189
00:08:58,100 --> 00:09:02,220
with a single virtual CPU for better

190
00:09:02,220 --> 00:09:03,779
debugging experience

191
00:09:03,779 --> 00:09:05,480
and

192
00:09:05,480 --> 00:09:08,959
to do single stepping I usually disable

193
00:09:08,959 --> 00:09:12,839
KVM hardware virtualization otherwise on

194
00:09:12,839 --> 00:09:15,360
every single step your debugger always

195
00:09:15,360 --> 00:09:17,820
gets into interrupt timer interrupt

196
00:09:17,820 --> 00:09:20,640
Handler so that's why if I need single

197
00:09:20,640 --> 00:09:23,459
stepping I I use this trick and just

198
00:09:23,459 --> 00:09:26,580
attach the GDP client to the GDB server

199
00:09:26,580 --> 00:09:29,339
and it looks like that very similar to

200
00:09:29,339 --> 00:09:31,560
the Linux kernel debugging in the first

201
00:09:31,560 --> 00:09:35,459
terminal we have the qmo running with

202
00:09:35,459 --> 00:09:38,279
fusion and in the second terminal we

203
00:09:38,279 --> 00:09:41,459
have GDP client connected to the GDB

204
00:09:41,459 --> 00:09:44,600
server in qmo

205
00:09:44,600 --> 00:09:49,019
and uh for every successful security

206
00:09:49,019 --> 00:09:53,160
search of C plus plus code we need some

207
00:09:53,160 --> 00:09:55,100
detector

208
00:09:55,100 --> 00:09:58,640
which reveals the memory corruption box

209
00:09:58,640 --> 00:10:01,980
and for C and C plus plus

210
00:10:01,980 --> 00:10:05,160
for the operating system kernels the

211
00:10:05,160 --> 00:10:07,800
research detector it is kassan Kernel

212
00:10:07,800 --> 00:10:11,160
address sanitizer it can detect out of

213
00:10:11,160 --> 00:10:13,380
bounds accesses use after three memory

214
00:10:13,380 --> 00:10:15,320
Corruptions in the runtime

215
00:10:15,320 --> 00:10:18,660
and the future supports uh building

216
00:10:18,660 --> 00:10:23,160
silicon with with cassan you just need a

217
00:10:23,160 --> 00:10:26,640
extra argument for the build command

218
00:10:26,640 --> 00:10:30,300
and I wanted to test it to test kernel

219
00:10:30,300 --> 00:10:32,839
address sanitizer I added a synthetic

220
00:10:32,839 --> 00:10:36,660
silicon bug in the code which implements

221
00:10:36,660 --> 00:10:39,660
the kernel timers

222
00:10:39,660 --> 00:10:40,820
here

223
00:10:40,820 --> 00:10:46,380
if I set if the the timer is set to the

224
00:10:46,380 --> 00:10:49,980
deadline which ending with the Elite

225
00:10:49,980 --> 00:10:50,940
numbers

226
00:10:50,940 --> 00:10:53,339
but then when timer fire

227
00:10:53,339 --> 00:10:57,540
and then line is met in timer fire the

228
00:10:57,540 --> 00:11:01,260
memory of the object is is the freed

229
00:11:01,260 --> 00:11:03,980
regardless of the

230
00:11:03,980 --> 00:11:07,320
reference counter so it is a bug

231
00:11:07,320 --> 00:11:10,380
and I wanted to hit this bug in my toy

232
00:11:10,380 --> 00:11:12,600
application to see how the memory

233
00:11:12,600 --> 00:11:15,660
corruption is detected to do that I

234
00:11:15,660 --> 00:11:17,880
simply created a timer set it to the

235
00:11:17,880 --> 00:11:20,940
deadline ending for the magic numbers

236
00:11:20,940 --> 00:11:24,660
and waited when the timer is fired and

237
00:11:24,660 --> 00:11:27,600
then when I called ZX timer cancel

238
00:11:27,600 --> 00:11:30,980
uh the micro kernel

239
00:11:30,980 --> 00:11:34,260
they referenced the freed memory so it

240
00:11:34,260 --> 00:11:36,600
is use after free bug and the kernel

241
00:11:36,600 --> 00:11:39,140
address sanitizer detected that

242
00:11:39,140 --> 00:11:44,459
Zircon kernel got panic and I saw such a

243
00:11:44,459 --> 00:11:47,700
beautiful report in the kernel log so

244
00:11:47,700 --> 00:11:50,640
nice at this point I understood that I

245
00:11:50,640 --> 00:11:52,579
have everything for successful

246
00:11:52,579 --> 00:11:55,140
vulnerability of successful security

247
00:11:55,140 --> 00:11:57,300
research on this system

248
00:11:57,300 --> 00:12:01,680
and I had a goal to develop a proof of

249
00:12:01,680 --> 00:12:03,620
concept exploit for some

250
00:12:03,620 --> 00:12:06,120
circum bug

251
00:12:06,120 --> 00:12:10,680
and the simplest way to find such a bug

252
00:12:10,680 --> 00:12:14,579
in the in the kernel operating system

253
00:12:14,579 --> 00:12:17,579
kernel is fuzzing and there is a great

254
00:12:17,579 --> 00:12:19,320
kernel father

255
00:12:19,320 --> 00:12:21,839
which is coverage guided it is called

256
00:12:21,839 --> 00:12:24,240
ciscollar I like this project and people

257
00:12:24,240 --> 00:12:27,000
who develop it very much I use this

258
00:12:27,000 --> 00:12:30,540
color for Linux kernel for many years

259
00:12:30,540 --> 00:12:33,060
and I decided and ciscollar

260
00:12:33,060 --> 00:12:35,120
documentation says that it supports

261
00:12:35,120 --> 00:12:39,899
fuzzing future so I built a circle with

262
00:12:39,899 --> 00:12:41,899
kernel address sanitizer and decided to

263
00:12:41,899 --> 00:12:44,220
fuzz it

264
00:12:44,220 --> 00:12:47,040
but unfortunately I got troubles uh

265
00:12:47,040 --> 00:12:49,440
caused by this unusual software delivery

266
00:12:49,440 --> 00:12:53,579
scheme on on fuchsia actually for

267
00:12:53,579 --> 00:12:56,100
fuzzing future image must have the sys

268
00:12:56,100 --> 00:12:58,920
executor binary it is it should be a

269
00:12:58,920 --> 00:13:02,880
part of fuzzing virtual machine and it

270
00:13:02,880 --> 00:13:04,800
actually executes the advising input on

271
00:13:04,800 --> 00:13:06,959
the virtual machine but I failed to

272
00:13:06,959 --> 00:13:09,680
build fuchsia with this component uh

273
00:13:09,680 --> 00:13:11,880
then I

274
00:13:11,880 --> 00:13:13,560
later I

275
00:13:13,560 --> 00:13:15,360
found out that

276
00:13:15,360 --> 00:13:17,700
fuchsia was integrated with the spoiler

277
00:13:17,700 --> 00:13:20,100
once a point in time in 2020 but it was

278
00:13:20,100 --> 00:13:24,180
then broken and forgotten and so on I

279
00:13:24,180 --> 00:13:29,040
put some effort to reintegrate them

280
00:13:29,040 --> 00:13:31,260
um but I felt

281
00:13:31,260 --> 00:13:34,380
without any success and I found the

282
00:13:34,380 --> 00:13:36,380
context of the developers who

283
00:13:36,380 --> 00:13:38,880
contributed to this functionality I

284
00:13:38,880 --> 00:13:40,860
wrote them email describing technical

285
00:13:40,860 --> 00:13:42,720
details so the bug but didn't get any

286
00:13:42,720 --> 00:13:45,120
reply spending more time on future build

287
00:13:45,120 --> 00:13:47,279
system was

288
00:13:47,279 --> 00:13:48,660
upsetting me

289
00:13:48,660 --> 00:13:52,320
and at this point I understood that I

290
00:13:52,320 --> 00:13:54,720
need to decide on further research

291
00:13:54,720 --> 00:13:58,579
strategy it was a hard moment

292
00:13:58,579 --> 00:14:00,899
without fuzzing successfully

293
00:14:00,899 --> 00:14:03,300
vulnerability Discovery in operating

294
00:14:03,300 --> 00:14:05,519
system kernel requires first good

295
00:14:05,519 --> 00:14:07,800
knowledge of the code base second deep

296
00:14:07,800 --> 00:14:09,420
understanding of the attack surface

297
00:14:09,420 --> 00:14:11,459
obviously I didn't have that for future

298
00:14:11,459 --> 00:14:13,380
because it was my first experience with

299
00:14:13,380 --> 00:14:16,740
this system and did I want to spend a

300
00:14:16,740 --> 00:14:19,560
lot of time to learn it for this first

301
00:14:19,560 --> 00:14:20,820
research

302
00:14:20,820 --> 00:14:22,500
perhaps not

303
00:14:22,500 --> 00:14:25,320
first because committing large resources

304
00:14:25,320 --> 00:14:27,959
to First familiarity with the system is

305
00:14:27,959 --> 00:14:32,000
not really reasonable and second fuchsia

306
00:14:32,000 --> 00:14:34,680
appeared to be less production ready

307
00:14:34,680 --> 00:14:37,440
than I expected

308
00:14:37,440 --> 00:14:41,060
so I was just like this night standing

309
00:14:41,060 --> 00:14:45,300
in front of the stone where various

310
00:14:45,300 --> 00:14:48,240
different bed options are listed the

311
00:14:48,240 --> 00:14:51,779
thinking what what to choose

312
00:14:51,779 --> 00:14:54,660
and I decided not to be greedy and

313
00:14:54,660 --> 00:14:57,540
postpone the zero day Discovery for

314
00:14:57,540 --> 00:14:59,720
silicon and try to

315
00:14:59,720 --> 00:15:03,839
exploit this the synthetic back which I

316
00:15:03,839 --> 00:15:07,620
created to test kernel address sanitizer

317
00:15:07,620 --> 00:15:09,959
and ultimately it was a very good

318
00:15:09,959 --> 00:15:12,420
decision because first it gave me quite

319
00:15:12,420 --> 00:15:15,779
quick results and second I found other

320
00:15:15,779 --> 00:15:19,440
interesting bugs in Zircon along the way

321
00:15:19,440 --> 00:15:22,320
so now I will tell how I exploited this

322
00:15:22,320 --> 00:15:25,199
synthetic buck and what happened next

323
00:15:25,199 --> 00:15:28,920
the exploit strategy for exploiting this

324
00:15:28,920 --> 00:15:31,320
user to free on timer dispatcher was

325
00:15:31,320 --> 00:15:34,440
quite simple first I needed hip spraying

326
00:15:34,440 --> 00:15:37,380
primitive to override the 3D object with

327
00:15:37,380 --> 00:15:39,899
their controlled data then I needed to

328
00:15:39,899 --> 00:15:42,380
choose the data for this object to make

329
00:15:42,380 --> 00:15:45,000
circontimer code work abnormally in

330
00:15:45,000 --> 00:15:47,399
other words I needed to turn the micro

331
00:15:47,399 --> 00:15:49,740
kernel into weird machine which in

332
00:15:49,740 --> 00:15:52,500
parallel executes the normal instruction

333
00:15:52,500 --> 00:15:56,399
in the code and in parallel executes the

334
00:15:56,399 --> 00:15:59,100
actions which attackers controls

335
00:15:59,100 --> 00:16:01,079
it is called this concept is called

336
00:16:01,079 --> 00:16:02,940
weird machine I like it very much so

337
00:16:02,940 --> 00:16:04,680
from

338
00:16:04,680 --> 00:16:07,560
using this weird machine I needed to get

339
00:16:07,560 --> 00:16:11,579
control over future over the future OS

340
00:16:11,579 --> 00:16:13,920
and the first

341
00:16:13,920 --> 00:16:16,860
part was keep spraying what is it

342
00:16:16,860 --> 00:16:19,260
um hip spraying is such activity in the

343
00:16:19,260 --> 00:16:22,440
user space which made the kernel which

344
00:16:22,440 --> 00:16:24,680
is available for unprivileged

345
00:16:24,680 --> 00:16:27,360
applications which make the kernel

346
00:16:27,360 --> 00:16:30,120
allocate a new object at the place of

347
00:16:30,120 --> 00:16:32,160
the freed object and this new object

348
00:16:32,160 --> 00:16:34,880
should contain the Control Data

349
00:16:34,880 --> 00:16:38,759
moreover this data should come from the

350
00:16:38,759 --> 00:16:40,139
user space

351
00:16:40,139 --> 00:16:43,139
and when the freed object with new data

352
00:16:43,139 --> 00:16:44,959
is used

353
00:16:44,959 --> 00:16:47,100
the kernel

354
00:16:47,100 --> 00:16:50,820
turns into this word weird machine

355
00:16:50,820 --> 00:16:53,699
and from Mike's exploit development

356
00:16:53,699 --> 00:16:56,399
experiments from the Linux kernel on you

357
00:16:56,399 --> 00:17:00,360
that usually Linux kernel hip sprain is

358
00:17:00,360 --> 00:17:02,519
based on the inter-process communication

359
00:17:02,519 --> 00:17:07,559
why first of all basic IPC for Linux are

360
00:17:07,559 --> 00:17:10,140
available for unprivileged programs nice

361
00:17:10,140 --> 00:17:13,260
second some inter-process Communication

362
00:17:13,260 --> 00:17:16,140
in Linux allow setting the data size for

363
00:17:16,140 --> 00:17:18,959
a transfer and that gives the actual

364
00:17:18,959 --> 00:17:21,900
control over the allocator behavior I

365
00:17:21,900 --> 00:17:24,660
can put the new object at the place of

366
00:17:24,660 --> 00:17:25,859
the 3D object

367
00:17:25,859 --> 00:17:28,919
moreover IPC usually transfer diet data

368
00:17:28,919 --> 00:17:33,120
so it is good because the Control Data

369
00:17:33,120 --> 00:17:36,059
from the attackers user space

370
00:17:36,059 --> 00:17:39,240
go to the freed object

371
00:17:39,240 --> 00:17:41,760
that was the reasons why I started to

372
00:17:41,760 --> 00:17:45,600
learn future IPC to find the hip

373
00:17:45,600 --> 00:17:47,700
spraying exploit primitive

374
00:17:47,700 --> 00:17:52,440
and I found that I found a silicon V4

375
00:17:52,440 --> 00:17:55,799
it is created with zetix before create

376
00:17:55,799 --> 00:18:00,000
system call and if I create

377
00:18:00,000 --> 00:18:03,480
several FIFA dispatchers as I needed

378
00:18:03,480 --> 00:18:05,840
with the needed size one of them

379
00:18:05,840 --> 00:18:08,580
overwrites my free time and dispatcher

380
00:18:08,580 --> 00:18:09,419
object

381
00:18:09,419 --> 00:18:12,840
that is very good I I got the ability to

382
00:18:12,840 --> 00:18:16,020
change the timer dispatcher contents

383
00:18:16,020 --> 00:18:19,020
with the control data but which data

384
00:18:19,020 --> 00:18:22,799
should I use to to mount a further

385
00:18:22,799 --> 00:18:24,179
attack

386
00:18:24,179 --> 00:18:26,880
to understand that I started to learn

387
00:18:26,880 --> 00:18:29,340
the C plus plus object Anatomy I needed

388
00:18:29,340 --> 00:18:32,960
to understand how time it dispatcher is

389
00:18:32,960 --> 00:18:35,299
organized inside

390
00:18:35,299 --> 00:18:38,940
and compared to the Linux kernex

391
00:18:38,940 --> 00:18:41,460
experience it was much more complicated

392
00:18:41,460 --> 00:18:45,960
in Linux for their kernel object we have

393
00:18:45,960 --> 00:18:48,539
C structures and if the object has some

394
00:18:48,539 --> 00:18:51,240
method it is a function pointer in a c

395
00:18:51,240 --> 00:18:54,960
structure very simple and explicit but

396
00:18:54,960 --> 00:18:57,740
for C plus plus object their internal

397
00:18:57,740 --> 00:19:00,179
anatomy is much more complex I tried

398
00:19:00,179 --> 00:19:03,059
different tools to understand how this

399
00:19:03,059 --> 00:19:05,160
complex timer dispatcher is organized

400
00:19:05,160 --> 00:19:07,620
inside but I failed and I just said I

401
00:19:07,620 --> 00:19:09,600
don't care I decided not to care about

402
00:19:09,600 --> 00:19:13,260
it and I tried this

403
00:19:13,260 --> 00:19:16,500
I would call Minesweeper approach blind

404
00:19:16,500 --> 00:19:18,900
blind practice instead I feel the timer

405
00:19:18,900 --> 00:19:21,240
dispatcher with zero bytes

406
00:19:21,240 --> 00:19:24,480
and started to crash and crush and crush

407
00:19:24,480 --> 00:19:27,660
the Silicon micro kernel with my proof

408
00:19:27,660 --> 00:19:30,299
of concept exploit and uh with a

409
00:19:30,299 --> 00:19:33,900
debugger I started to find

410
00:19:33,900 --> 00:19:36,600
which bytes in the hip spring I need to

411
00:19:36,600 --> 00:19:41,520
to set to proceed in the micro kernel

412
00:19:41,520 --> 00:19:44,580
and execution and avoid crashes at and

413
00:19:44,580 --> 00:19:47,100
at some point I got a very promising

414
00:19:47,100 --> 00:19:50,039
circum crash uh they're congression in

415
00:19:50,039 --> 00:19:51,960
this C plus plus

416
00:19:51,960 --> 00:19:53,400
dark magic

417
00:19:53,400 --> 00:19:55,820
here

418
00:19:55,820 --> 00:19:59,160
there is the get type public method

419
00:19:59,160 --> 00:20:01,260
which is called for the timer dispatcher

420
00:20:01,260 --> 00:20:04,559
object and this public method is

421
00:20:04,559 --> 00:20:08,160
referenced with the c plus v table

422
00:20:08,160 --> 00:20:12,299
the pointer to this virtual table

423
00:20:12,299 --> 00:20:14,640
is stored at the beginning of the object

424
00:20:14,640 --> 00:20:18,120
and I got the new uh null pointer the

425
00:20:18,120 --> 00:20:21,539
reference when this V table was used by

426
00:20:21,539 --> 00:20:24,120
the micro kernel and I thought that it

427
00:20:24,120 --> 00:20:26,880
is excellent for control flow hijacking

428
00:20:26,880 --> 00:20:31,260
so very good kernel crash very promising

429
00:20:31,260 --> 00:20:34,919
but for control flow hijacking in the

430
00:20:34,919 --> 00:20:37,740
operating system kernel I need to know

431
00:20:37,740 --> 00:20:42,000
the addresses of Kernel symbols but we

432
00:20:42,000 --> 00:20:44,720
have the kernel address layouts uh

433
00:20:44,720 --> 00:20:47,400
kernel address basically out

434
00:20:47,400 --> 00:20:49,200
randomization kslr

435
00:20:49,200 --> 00:20:52,340
it is the security feature

436
00:20:52,340 --> 00:20:55,020
which makes the kernel

437
00:20:55,020 --> 00:20:58,980
be located at the random offset in the

438
00:20:58,980 --> 00:21:02,160
virtual memory on every boot so on every

439
00:21:02,160 --> 00:21:05,340
single boot I initially don't know where

440
00:21:05,340 --> 00:21:08,100
the kernel symbols are like are located

441
00:21:08,100 --> 00:21:10,860
and I needed to bypass that somehow I

442
00:21:10,860 --> 00:21:13,980
needed to know this Chrysler offset

443
00:21:13,980 --> 00:21:16,799
secret value

444
00:21:16,799 --> 00:21:21,419
and I decided to try the trick which I

445
00:21:21,419 --> 00:21:23,460
used for one of my proof of concept

446
00:21:23,460 --> 00:21:25,740
displays for the Linux kernel

447
00:21:25,740 --> 00:21:29,100
I tried uh in in that uh

448
00:21:29,100 --> 00:21:32,460
in that research I used the kernel log

449
00:21:32,460 --> 00:21:35,760
to extract the information

450
00:21:35,760 --> 00:21:39,720
which can reveal the castle offset and a

451
00:21:39,720 --> 00:21:42,059
fuchsia kernel look also has security

452
00:21:42,059 --> 00:21:44,280
sensitive information as well and I

453
00:21:44,280 --> 00:21:46,740
decided to do this trick same trick but

454
00:21:46,740 --> 00:21:48,299
for future

455
00:21:48,299 --> 00:21:50,520
this time

456
00:21:50,520 --> 00:21:55,919
and I decided to try to open the kernel

457
00:21:55,919 --> 00:21:59,100
log from my exploit application in

458
00:21:59,100 --> 00:22:03,360
future for that I specify this string in

459
00:22:03,360 --> 00:22:05,640
the Manifest created a channel connected

460
00:22:05,640 --> 00:22:09,000
to a special service in future with

461
00:22:09,000 --> 00:22:11,159
special protocol trying to open the

462
00:22:11,159 --> 00:22:14,159
kernel log and I failed because the

463
00:22:14,159 --> 00:22:16,260
access wasn't denied

464
00:22:16,260 --> 00:22:18,659
because obviously my component didn't

465
00:22:18,659 --> 00:22:20,580
have their required capabilities so

466
00:22:20,580 --> 00:22:22,500
that's how fuchsia

467
00:22:22,500 --> 00:22:23,720
um

468
00:22:23,720 --> 00:22:27,539
capabilities really work so that was

469
00:22:27,539 --> 00:22:29,400
correct behavior in a way

470
00:22:29,400 --> 00:22:33,960
but I certainly found the system call

471
00:22:33,960 --> 00:22:36,960
which allows to get access to the kernel

472
00:22:36,960 --> 00:22:37,980
log

473
00:22:37,980 --> 00:22:42,419
and it has their parameter the argument

474
00:22:42,419 --> 00:22:45,299
the resource and to open the kernel look

475
00:22:45,299 --> 00:22:48,360
I needed a zetix resource kind root

476
00:22:48,360 --> 00:22:50,580
special resource which my application

477
00:22:50,580 --> 00:22:51,900
didn't have

478
00:22:51,900 --> 00:22:53,720
but

479
00:22:53,720 --> 00:23:00,120
just to try my luck I call this system

480
00:23:00,120 --> 00:23:03,600
call with zeroid resource and somehow I

481
00:23:03,600 --> 00:23:06,120
managed to get the kernel look but why I

482
00:23:06,120 --> 00:23:08,820
started to look at the circuit and it

483
00:23:08,820 --> 00:23:11,280
was a hilarious Security check in this

484
00:23:11,280 --> 00:23:14,820
code just look we call validate resource

485
00:23:14,820 --> 00:23:18,000
only if the resource is not invalided so

486
00:23:18,000 --> 00:23:21,419
not new not now it is like at the

487
00:23:21,419 --> 00:23:24,059
passport control you you come and

488
00:23:24,059 --> 00:23:26,460
policeman says okay give me your

489
00:23:26,460 --> 00:23:30,000
password for the check and you say I

490
00:23:30,000 --> 00:23:32,659
don't have a password and the policeman

491
00:23:32,659 --> 00:23:36,179
replies okay just pass it is fine so

492
00:23:36,179 --> 00:23:38,280
this code works like that

493
00:23:38,280 --> 00:23:39,919
I

494
00:23:39,919 --> 00:23:43,500
feel the security issue to Future bug

495
00:23:43,500 --> 00:23:44,640
tracker

496
00:23:44,640 --> 00:23:47,880
and the developers approved that it is a

497
00:23:47,880 --> 00:23:52,440
security issue the the this code is uh

498
00:23:52,440 --> 00:23:55,200
is buggy and they assigned

499
00:23:55,200 --> 00:23:59,880
their cve for this issue but anyway

500
00:23:59,880 --> 00:24:02,280
um reading the kernel log for fuchsia

501
00:24:02,280 --> 00:24:05,820
was not a problem anymore and in my book

502
00:24:05,820 --> 00:24:08,220
exploit I extracted some kernel pointers

503
00:24:08,220 --> 00:24:10,500
from the kernel log and then I realized

504
00:24:10,500 --> 00:24:13,380
they somehow they are the same on the

505
00:24:13,380 --> 00:24:16,620
each boot turned out that kslr is

506
00:24:16,620 --> 00:24:18,000
mentioned in the kernel code but doesn't

507
00:24:18,000 --> 00:24:18,840
work

508
00:24:18,840 --> 00:24:23,400
uh for future and that was another

509
00:24:23,400 --> 00:24:25,919
security issue which I filled in future

510
00:24:25,919 --> 00:24:28,500
bug tracker and the developers said okay

511
00:24:28,500 --> 00:24:31,140
we know this issue it is fine it's not

512
00:24:31,140 --> 00:24:34,039
ready yet

513
00:24:34,380 --> 00:24:39,360
um anyway I knew at this point the that

514
00:24:39,360 --> 00:24:41,780
I can in my

515
00:24:41,780 --> 00:24:45,659
exploit for control for hijack I can use

516
00:24:45,659 --> 00:24:49,080
the point original pointers from the

517
00:24:49,080 --> 00:24:50,100
binary

518
00:24:50,100 --> 00:24:51,860
foreign

519
00:24:51,860 --> 00:24:55,440
to look how the table is organized

520
00:24:55,440 --> 00:24:58,380
inside how it works that that is what

521
00:24:58,380 --> 00:25:00,240
the debugger shows for the timer

522
00:25:00,240 --> 00:25:02,340
dispatcher virtual table

523
00:25:02,340 --> 00:25:04,919
you can see here some values which

524
00:25:04,919 --> 00:25:07,799
definitely not kernel pointers

525
00:25:07,799 --> 00:25:11,100
and to understand how the kernel use it

526
00:25:11,100 --> 00:25:14,760
uses such values I started to look at

527
00:25:14,760 --> 00:25:17,659
the code which it uses but

528
00:25:17,659 --> 00:25:20,700
I didn't I didn't manage to understand

529
00:25:20,700 --> 00:25:22,860
anything from the C plus plus dark magic

530
00:25:22,860 --> 00:25:26,120
so I just opened the assembly and it was

531
00:25:26,120 --> 00:25:29,340
much more much more simple and plain

532
00:25:29,340 --> 00:25:30,659
here

533
00:25:30,659 --> 00:25:32,600
we can see that

534
00:25:32,600 --> 00:25:36,900
this value from the V table is sine

535
00:25:36,900 --> 00:25:41,279
extended from 3 30 T to bit source to

536
00:25:41,279 --> 00:25:44,940
64-bit destination and then add it to

537
00:25:44,940 --> 00:25:48,419
the address of the V table so it is some

538
00:25:48,419 --> 00:25:49,860
kind of upset

539
00:25:49,860 --> 00:25:53,760
when they are added their

540
00:25:53,760 --> 00:25:55,200
um the

541
00:25:55,200 --> 00:25:57,720
register

542
00:25:57,720 --> 00:26:01,740
starts to have the pointer of this type

543
00:26:01,740 --> 00:26:04,740
get type public method of the timer

544
00:26:04,740 --> 00:26:08,580
dispatcher so in my exploit I needed to

545
00:26:08,580 --> 00:26:12,419
reverse this logic to to make kernel

546
00:26:12,419 --> 00:26:13,799
execute my

547
00:26:13,799 --> 00:26:16,200
function which I want

548
00:26:16,200 --> 00:26:19,380
and then at this point I started to

549
00:26:19,380 --> 00:26:23,960
think where to put this fake V table

550
00:26:23,960 --> 00:26:28,140
there the most simple answer is to put

551
00:26:28,140 --> 00:26:31,860
it in my user space address space of the

552
00:26:31,860 --> 00:26:35,820
exploit but Zircon on x8664 supports SM

553
00:26:35,820 --> 00:26:38,880
AP which is supervisor mode access

554
00:26:38,880 --> 00:26:41,279
prevention it is a hardware feature

555
00:26:41,279 --> 00:26:42,440
which

556
00:26:42,440 --> 00:26:46,140
protects from the referencing the user

557
00:26:46,140 --> 00:26:49,220
space pointer from the kernel space so

558
00:26:49,220 --> 00:26:52,500
placing the fake table in the user face

559
00:26:52,500 --> 00:26:55,200
was not possible with this feature for

560
00:26:55,200 --> 00:26:59,059
the Linux kernel I usually bypass smap

561
00:26:59,059 --> 00:27:01,919
by placing the payload in the kernel

562
00:27:01,919 --> 00:27:05,520
space at some known address where my

563
00:27:05,520 --> 00:27:08,460
user space and contents

564
00:27:08,460 --> 00:27:12,360
a data are placed and I could do the

565
00:27:12,360 --> 00:27:15,500
same for the future or I could use

566
00:27:15,500 --> 00:27:17,820
re-implement the red to deer attack

567
00:27:17,820 --> 00:27:20,460
because fuchsia like the Linus kernel

568
00:27:20,460 --> 00:27:23,520
has so-called Fizz map mapping

569
00:27:23,520 --> 00:27:26,159
but for this first time I decided okay

570
00:27:26,159 --> 00:27:28,380
it is too complex for the first research

571
00:27:28,380 --> 00:27:31,320
I I just disabled SM AP and smep in

572
00:27:31,320 --> 00:27:34,679
cuermo and uh for this experiment I

573
00:27:34,679 --> 00:27:36,480
placed the fake V table in the user

574
00:27:36,480 --> 00:27:38,220
space

575
00:27:38,220 --> 00:27:42,480
and implemented this logic which I

576
00:27:42,480 --> 00:27:43,919
showed you in the kernel

577
00:27:43,919 --> 00:27:48,059
here for the table

578
00:27:48,059 --> 00:27:49,100
um

579
00:27:49,100 --> 00:27:53,820
value I subtracted the evitable pointer

580
00:27:53,820 --> 00:27:58,080
from the function pointer address of the

581
00:27:58,080 --> 00:28:00,059
function which I want to call the kernel

582
00:28:00,059 --> 00:28:02,900
to call it is my phone function from the

583
00:28:02,900 --> 00:28:06,299
exploit so I subtracted the V table

584
00:28:06,299 --> 00:28:09,299
pointer and when the kernel

585
00:28:09,299 --> 00:28:13,100
implements the V table handle logic it

586
00:28:13,100 --> 00:28:15,900
it adds the V table pointer to this

587
00:28:15,900 --> 00:28:18,720
value and then calls my Pawn function

588
00:28:18,720 --> 00:28:21,419
just like I want for control for a

589
00:28:21,419 --> 00:28:22,380
hijack

590
00:28:22,380 --> 00:28:25,559
nice so at this point I achieved the

591
00:28:25,559 --> 00:28:29,340
ability to uh to do code execution in

592
00:28:29,340 --> 00:28:32,340
the micro kernel but what what should I

593
00:28:32,340 --> 00:28:34,020
do to get

594
00:28:34,020 --> 00:28:37,460
um the control over the system

595
00:28:37,620 --> 00:28:41,220
um my first thought uh was to create

596
00:28:41,220 --> 00:28:43,620
this fake resource which I already

597
00:28:43,620 --> 00:28:46,980
mentioned special uh superpower Source

598
00:28:46,980 --> 00:28:47,940
but

599
00:28:47,940 --> 00:28:50,520
um actually sircon doesn't use it

600
00:28:50,520 --> 00:28:53,039
that much in the source code so I didn't

601
00:28:53,039 --> 00:28:55,500
manage to do anything uh useful with

602
00:28:55,500 --> 00:28:59,220
this resource and I understood the very

603
00:28:59,220 --> 00:29:01,880
important point

604
00:29:02,179 --> 00:29:06,299
about the micro Kernel Security that to

605
00:29:06,299 --> 00:29:11,159
prev to to make privilege escalation you

606
00:29:11,159 --> 00:29:13,380
in the micro kernel you need to attack

607
00:29:13,380 --> 00:29:15,480
the inter-process communication

608
00:29:15,480 --> 00:29:19,080
because there is no some

609
00:29:19,080 --> 00:29:21,500
super user

610
00:29:21,500 --> 00:29:24,860
entity in the micro kernel

611
00:29:24,860 --> 00:29:27,720
in future

612
00:29:27,720 --> 00:29:30,779
so I returned to learning about future

613
00:29:30,779 --> 00:29:32,960
user space and it was

614
00:29:32,960 --> 00:29:36,120
messing boring I'm a kernel developer

615
00:29:36,120 --> 00:29:39,840
but suddenly I got the idea and what

616
00:29:39,840 --> 00:29:41,940
about planting a root kit into the micro

617
00:29:41,940 --> 00:29:43,799
kernel it's much more interesting than

618
00:29:43,799 --> 00:29:45,140
the user space

619
00:29:45,140 --> 00:29:49,260
I start to learn how ciscals are

620
00:29:49,260 --> 00:29:51,240
implemented in future

621
00:29:51,240 --> 00:29:55,200
and like uh in the Linux kernel Circle

622
00:29:55,200 --> 00:29:57,360
has the assist call table

623
00:29:57,360 --> 00:30:00,260
it is the

624
00:30:00,260 --> 00:30:03,600
the part of the memory which stores the

625
00:30:03,600 --> 00:30:05,460
function pointers

626
00:30:05,460 --> 00:30:09,200
to the Cisco handlers and there is a

627
00:30:09,200 --> 00:30:15,000
x8660x xc66 call function which jumps to

628
00:30:15,000 --> 00:30:19,320
the to the Handler corresponding to the

629
00:30:19,320 --> 00:30:22,860
Cisco number so very similar uh to the

630
00:30:22,860 --> 00:30:26,100
Linux kernels is called implementation

631
00:30:26,100 --> 00:30:29,039
and I tried to overwrite this Cisco

632
00:30:29,039 --> 00:30:29,820
table

633
00:30:29,820 --> 00:30:34,399
with a very old school classics

634
00:30:34,399 --> 00:30:38,820
trick so I reset the right protect beat

635
00:30:38,820 --> 00:30:42,240
from the cr0 register which allowed me

636
00:30:42,240 --> 00:30:45,480
to write any memory in the system and I

637
00:30:45,480 --> 00:30:48,240
over written The Cisco table in it

638
00:30:48,240 --> 00:30:50,220
worked

639
00:30:50,220 --> 00:30:52,340
so uh

640
00:30:52,340 --> 00:30:56,100
I had everything for planting a rootkit

641
00:30:56,100 --> 00:30:58,380
in the micro kernel and I started to

642
00:30:58,380 --> 00:31:01,980
think how to implement the rootkit hook

643
00:31:01,980 --> 00:31:04,440
um usually in Linux kernel root kits it

644
00:31:04,440 --> 00:31:06,899
is not a problem

645
00:31:06,899 --> 00:31:09,360
because the Linux kernel rootkit is

646
00:31:09,360 --> 00:31:11,820
usually a kernel module so you can just

647
00:31:11,820 --> 00:31:15,059
use the function in this kernel module

648
00:31:15,059 --> 00:31:16,200
as a hook

649
00:31:16,200 --> 00:31:19,559
and it is simple but here for fuchsia I

650
00:31:19,559 --> 00:31:21,720
was planting rootkit from the user space

651
00:31:21,720 --> 00:31:25,860
and I was not able to use the user space

652
00:31:25,860 --> 00:31:27,980
functions at as hooks

653
00:31:27,980 --> 00:31:30,600
for my rootkit

654
00:31:30,600 --> 00:31:35,279
and I got the idea to turn a part of

655
00:31:35,279 --> 00:31:37,620
silicon code in into the hook

656
00:31:37,620 --> 00:31:41,640
and my first candidate for overwriting

657
00:31:41,640 --> 00:31:44,059
was this function assert fail message

658
00:31:44,059 --> 00:31:46,860
these functions drove me nuts during the

659
00:31:46,860 --> 00:31:50,340
exploit development because so many um

660
00:31:50,340 --> 00:31:55,380
assertions are around in in Silicon

661
00:31:55,380 --> 00:31:57,899
micro kernel and I was very happy to

662
00:31:57,899 --> 00:32:00,360
override this function

663
00:32:00,360 --> 00:32:01,080
um

664
00:32:01,080 --> 00:32:04,679
first I I want to tell about the hook I

665
00:32:04,679 --> 00:32:08,039
wanted to Simply print a message into

666
00:32:08,039 --> 00:32:11,880
the kernel look so in my hook which

667
00:32:11,880 --> 00:32:14,760
works instead of the system should work

668
00:32:14,760 --> 00:32:17,520
instead of the system call First you can

669
00:32:17,520 --> 00:32:19,799
see in blue I

670
00:32:19,799 --> 00:32:23,580
save the registers push it onto the

671
00:32:23,580 --> 00:32:27,360
kernel stack then I prepare the

672
00:32:27,360 --> 00:32:29,880
silicon printf call

673
00:32:29,880 --> 00:32:31,260
it

674
00:32:31,260 --> 00:32:34,380
and here you can see that I prepared the

675
00:32:34,380 --> 00:32:38,520
string which I want to print and put it

676
00:32:38,520 --> 00:32:42,539
just after the my hook code plus one

677
00:32:42,539 --> 00:32:45,059
byte remember this one byte I will tell

678
00:32:45,059 --> 00:32:45,980
you

679
00:32:45,980 --> 00:32:50,220
why it is here very soon then I uh

680
00:32:50,220 --> 00:32:52,860
restore the state of the register and

681
00:32:52,860 --> 00:32:54,779
call the original system call I wanted

682
00:32:54,779 --> 00:32:55,980
to

683
00:32:55,980 --> 00:32:59,100
hook the process create system call very

684
00:32:59,100 --> 00:33:01,559
interesting Cisco in the future

685
00:33:01,559 --> 00:33:05,340
and that is how I planted the rootkit

686
00:33:05,340 --> 00:33:06,179
um

687
00:33:06,179 --> 00:33:09,059
you remember about this one byte it is

688
00:33:09,059 --> 00:33:12,480
how I disabled the assertions in Fusion

689
00:33:12,480 --> 00:33:17,640
I first of all wrote C3 value at the

690
00:33:17,640 --> 00:33:20,640
first byte of this function this C3

691
00:33:20,640 --> 00:33:24,360
means return so any further assertion in

692
00:33:24,360 --> 00:33:26,700
Zircon just returns immediately

693
00:33:26,700 --> 00:33:32,700
after this red instruction I copied the

694
00:33:32,700 --> 00:33:36,480
code of my hook which I just showed you

695
00:33:36,480 --> 00:33:38,940
and then after the hook I copied the

696
00:33:38,940 --> 00:33:42,000
message which I wanted to print to the

697
00:33:42,000 --> 00:33:43,380
kernel log

698
00:33:43,380 --> 00:33:47,220
rootkit hook this call number 102 roses

699
00:33:47,220 --> 00:33:50,640
Creed so on every call to process create

700
00:33:50,640 --> 00:33:53,880
fuchsia will print this message to the

701
00:33:53,880 --> 00:33:55,679
kernel log

702
00:33:55,679 --> 00:33:59,580
and finally to plant the rootkit I

703
00:33:59,580 --> 00:34:03,080
overrode the item number

704
00:34:03,080 --> 00:34:06,779
102 in the Cisco table

705
00:34:06,779 --> 00:34:11,699
and this item should point to our

706
00:34:11,699 --> 00:34:14,399
overwritten function plus one byte so at

707
00:34:14,399 --> 00:34:17,940
the beginning of my hook code

708
00:34:17,940 --> 00:34:20,399
and now I will show the exploit demo how

709
00:34:20,399 --> 00:34:22,819
it worked

710
00:34:29,760 --> 00:34:31,379
okay

711
00:34:31,379 --> 00:34:33,659
here you can see that I started the log

712
00:34:33,659 --> 00:34:36,659
listener which will show that I executed

713
00:34:36,659 --> 00:34:39,060
the exploit the exploit is executed and

714
00:34:39,060 --> 00:34:41,219
rootkit is planted

715
00:34:41,219 --> 00:34:48,199
yeah now in fuchsia uh I oh sorry

716
00:34:54,300 --> 00:34:58,760
yeah I said

717
00:35:01,800 --> 00:35:03,180
yeah

718
00:35:03,180 --> 00:35:04,619
um

719
00:35:04,619 --> 00:35:08,760
now after after the rootkit worked I

720
00:35:08,760 --> 00:35:13,140
said I I call the youname command

721
00:35:13,140 --> 00:35:16,800
which will show that it is the Silicon

722
00:35:16,800 --> 00:35:19,920
kernel and this you name triggered my

723
00:35:19,920 --> 00:35:23,099
hooks of the rootkit now I will show

724
00:35:23,099 --> 00:35:26,820
that in the log

725
00:35:26,820 --> 00:35:28,920
oh

726
00:35:28,920 --> 00:35:32,240
strange sorry

727
00:35:43,440 --> 00:35:48,380
yeah grab for rootkit and we see that

728
00:35:48,720 --> 00:35:51,000
the you name command

729
00:35:51,000 --> 00:35:54,839
provoked two rootkit hooks and

730
00:35:54,839 --> 00:35:57,619
it worked

731
00:35:58,859 --> 00:36:00,960
now the conclusion

732
00:36:00,960 --> 00:36:03,240
that is how I met the future operating

733
00:36:03,240 --> 00:36:06,540
system and its silicon micro kernel that

734
00:36:06,540 --> 00:36:09,079
was very interesting because

735
00:36:09,079 --> 00:36:12,839
I'm a Linux kernel hacker and this micro

736
00:36:12,839 --> 00:36:14,820
kernel was very new experiments

737
00:36:14,820 --> 00:36:18,780
experience for me and I wanted to try my

738
00:36:18,780 --> 00:36:21,660
kernel hacking skills against this

739
00:36:21,660 --> 00:36:24,420
system for a long time I'm glad that I

740
00:36:24,420 --> 00:36:26,520
had this opportunity

741
00:36:26,520 --> 00:36:28,740
and uh I followed the responsible

742
00:36:28,740 --> 00:36:30,180
disclosure process for the Discover

743
00:36:30,180 --> 00:36:33,359
security issues and

744
00:36:33,359 --> 00:36:36,300
I believe it is one of the first public

745
00:36:36,300 --> 00:36:38,940
researchers on future operating system

746
00:36:38,940 --> 00:36:40,920
security and I think it is valuable

747
00:36:40,920 --> 00:36:43,440
because this work shows some practical

748
00:36:43,440 --> 00:36:46,140
aspects of micro kernel vulnerability

749
00:36:46,140 --> 00:36:48,780
exploitation and defense and I really

750
00:36:48,780 --> 00:36:51,619
hope that this will inspire you

751
00:36:51,619 --> 00:36:54,960
to do some kernel hacking and of course

752
00:36:54,960 --> 00:36:57,480
I wish you a good conference and

753
00:36:57,480 --> 00:37:00,680
friendly conversations

754
00:37:05,960 --> 00:37:10,160
uh any questions

755
00:37:11,940 --> 00:37:15,619
could you use a mic

756
00:37:22,500 --> 00:37:25,200
um the question is about the GDP for

757
00:37:25,200 --> 00:37:29,700
future so uh GDB client is ATT attached

758
00:37:29,700 --> 00:37:32,339
to the GDB server which is provided by

759
00:37:32,339 --> 00:37:35,940
qamo yeah yeah so you don't need ADP

760
00:37:35,940 --> 00:37:37,980
over there no I I need I don't need

761
00:37:37,980 --> 00:37:40,680
anything in the kernel uh silicon kernel

762
00:37:40,680 --> 00:37:44,339
to have it debugged yes it is provided

763
00:37:44,339 --> 00:37:47,339
just by kuemo and nothing is needed in

764
00:37:47,339 --> 00:37:49,320
the Silicon micro kernel

765
00:37:49,320 --> 00:37:51,960
so uh uh had you tried putting uh

766
00:37:51,960 --> 00:37:54,960
calling uh your fake V table from how do

767
00:37:54,960 --> 00:37:57,480
you speak in the mic thank you so have

768
00:37:57,480 --> 00:37:59,460
you thought of calling your fake wheat

769
00:37:59,460 --> 00:38:02,520
table uh from ctar or detour function

770
00:38:02,520 --> 00:38:05,400
uh sorry could you repeat this so did

771
00:38:05,400 --> 00:38:08,280
you try calling the your fake V table

772
00:38:08,280 --> 00:38:10,980
that you wanted to invoke from sitar or

773
00:38:10,980 --> 00:38:12,000
detour

774
00:38:12,000 --> 00:38:15,420
uh you mean from the debugger or no from

775
00:38:15,420 --> 00:38:17,160
the ctar or detour function so whenever

776
00:38:17,160 --> 00:38:18,599
the function is being allocated you have

777
00:38:18,599 --> 00:38:21,180
setar just to lay the space for the

778
00:38:21,180 --> 00:38:23,640
function or detour which cleans up it's

779
00:38:23,640 --> 00:38:25,619
like allocator and

780
00:38:25,619 --> 00:38:28,740
a Destructor just in that uh sorry I

781
00:38:28,740 --> 00:38:30,839
didn't get the question really but I

782
00:38:30,839 --> 00:38:34,619
will repeat about the table trick so the

783
00:38:34,619 --> 00:38:38,040
visual table is at the beginning of the

784
00:38:38,040 --> 00:38:41,520
uh at the time is a special object and I

785
00:38:41,520 --> 00:38:43,680
overwrote the object and I created a

786
00:38:43,680 --> 00:38:47,820
fake table for that and this table was

787
00:38:47,820 --> 00:38:51,240
placed in the user space so I had the

788
00:38:51,240 --> 00:38:53,099
object with a pointer to the user space

789
00:38:53,099 --> 00:38:57,540
and uh this in this paper table I

790
00:38:57,540 --> 00:39:00,660
created the address to my user space

791
00:39:00,660 --> 00:39:02,700
function which I want the kernel to call

792
00:39:02,700 --> 00:39:06,300
my shell code so the table fake the idea

793
00:39:06,300 --> 00:39:08,640
of fake retailable was to make the

794
00:39:08,640 --> 00:39:10,500
kernel to call my shell code from the

795
00:39:10,500 --> 00:39:13,500
user space yes

796
00:39:13,500 --> 00:39:15,500
um

797
00:39:26,480 --> 00:39:28,800
sorry I

798
00:39:28,800 --> 00:39:31,020
um can't comment on that

799
00:39:31,020 --> 00:39:36,259
maybe we will check it later yeah

800
00:39:42,300 --> 00:39:45,619
anyone from this room

801
00:39:46,400 --> 00:39:48,599
while you are thinking about the

802
00:39:48,599 --> 00:39:50,579
questions I will show you bonus slides

803
00:39:50,579 --> 00:39:53,220
what happened next I have a couple of

804
00:39:53,220 --> 00:39:57,599
minutes for that yep uh so in May this

805
00:39:57,599 --> 00:39:59,940
year I published the article

806
00:39:59,940 --> 00:40:03,660
and uh sometime after that future

807
00:40:03,660 --> 00:40:05,880
security engineering manager from Google

808
00:40:05,880 --> 00:40:08,760
approached me and asked for a call with

809
00:40:08,760 --> 00:40:11,339
Google and it was a very interesting

810
00:40:11,339 --> 00:40:14,760
conversation with them they thanked for

811
00:40:14,760 --> 00:40:16,980
This research and I asked a lot of

812
00:40:16,980 --> 00:40:18,960
questions about future security

813
00:40:18,960 --> 00:40:22,320
architecture and what I really liked

814
00:40:22,320 --> 00:40:24,119
um the future security engineering

815
00:40:24,119 --> 00:40:26,099
manager told that he would attack Zircon

816
00:40:26,099 --> 00:40:28,440
the same way as I did but at the last

817
00:40:28,440 --> 00:40:30,300
step he would attack the capability

818
00:40:30,300 --> 00:40:33,180
transfer or try to achieve the

819
00:40:33,180 --> 00:40:35,640
persistence across reboots so changing

820
00:40:35,640 --> 00:40:39,500
the kernel image and save

821
00:40:39,500 --> 00:40:42,540
the attack activity after the reboot

822
00:40:42,540 --> 00:40:44,040
rebooting the system

823
00:40:44,040 --> 00:40:46,380
it was funny they made the call

824
00:40:46,380 --> 00:40:49,140
recording but later they refused to

825
00:40:49,140 --> 00:40:50,760
share it with me I don't know why

826
00:40:50,760 --> 00:40:52,500
strange

827
00:40:52,500 --> 00:40:53,400
um

828
00:40:53,400 --> 00:40:56,520
then later in August future developers

829
00:40:56,520 --> 00:40:59,099
contacted me and said that this is color

830
00:40:59,099 --> 00:41:02,339
integration that was previously broken

831
00:41:02,339 --> 00:41:05,460
is fixed so now you can search for

832
00:41:05,460 --> 00:41:07,200
vulnerabilities in the future moreover

833
00:41:07,200 --> 00:41:10,220
later several days ago Google Google

834
00:41:10,220 --> 00:41:13,380
announced an open source software

835
00:41:13,380 --> 00:41:15,720
vulnerability rewards program

836
00:41:15,720 --> 00:41:20,040
so they play they pay Bounty for their

837
00:41:20,040 --> 00:41:22,380
vulnerabilities discovered in the open

838
00:41:22,380 --> 00:41:25,380
source and reported and future operating

839
00:41:25,380 --> 00:41:26,940
system is in scope

840
00:41:26,940 --> 00:41:29,579
so now it is even more interesting

841
00:41:29,579 --> 00:41:32,540
Target for the research

842
00:41:36,060 --> 00:41:40,160
yeah maybe maybe questions

843
00:41:45,119 --> 00:41:49,079
okay thank you very much and uh again

844
00:41:49,079 --> 00:41:53,420
wish you a great conference thank you

