1
00:00:02,879 --> 00:00:06,000
everything else okay we're gonna present

2
00:00:06,000 --> 00:00:06,899
today

3
00:00:06,899 --> 00:00:09,059
um the talk jailbreaking iOS and the

4
00:00:09,059 --> 00:00:12,320
post-apocalyptic age

5
00:00:13,440 --> 00:00:15,240
just for reference the ages of

6
00:00:15,240 --> 00:00:17,820
jailbreaking are defined as this

7
00:00:17,820 --> 00:00:20,340
um iOS 124 is the Golden Age where we

8
00:00:20,340 --> 00:00:23,060
had like lots of blue Chromebooks iOS

9
00:00:23,060 --> 00:00:25,859
529 was the Industrial Age where the

10
00:00:25,859 --> 00:00:29,039
rise of the user land came and then

11
00:00:29,039 --> 00:00:30,920
starting from IOS 10 we have the

12
00:00:30,920 --> 00:00:33,120
post-apocalyptic age with lots of

13
00:00:33,120 --> 00:00:36,540
mitigation making our lives miserable

14
00:00:36,540 --> 00:00:38,540
um

15
00:00:38,760 --> 00:00:41,700
jailbreaking in a nutshell consists of

16
00:00:41,700 --> 00:00:43,920
the following things first you somehow

17
00:00:43,920 --> 00:00:46,980
want to get a bug you want to exploit

18
00:00:46,980 --> 00:00:49,739
the bug you want to get an unstable

19
00:00:49,739 --> 00:00:52,980
kernel read kernel right and something

20
00:00:52,980 --> 00:00:54,120
like that

21
00:00:54,120 --> 00:00:56,940
in this presentation we already start

22
00:00:56,940 --> 00:00:59,520
with an existing exploit we will skip

23
00:00:59,520 --> 00:01:01,260
over all the exploits and just do Post

24
00:01:01,260 --> 00:01:03,059
exploitation

25
00:01:03,059 --> 00:01:05,400
so what you want to do is you want to

26
00:01:05,400 --> 00:01:08,159
have a stable kernel read and write so

27
00:01:08,159 --> 00:01:10,200
we assume that the initial read write we

28
00:01:10,200 --> 00:01:12,540
have is unstable we want to make it

29
00:01:12,540 --> 00:01:15,180
available to other processes we want to

30
00:01:15,180 --> 00:01:18,240
do privilege escalation so usually we

31
00:01:18,240 --> 00:01:20,100
start with the sandbox process so we

32
00:01:20,100 --> 00:01:21,540
want to escape the sandbox and become

33
00:01:21,540 --> 00:01:23,880
rude we want to bypass code signing

34
00:01:23,880 --> 00:01:25,860
enforcement do system-wide code

35
00:01:25,860 --> 00:01:27,360
injection because this is essentially

36
00:01:27,360 --> 00:01:29,520
what the tweaks are and optionally you

37
00:01:29,520 --> 00:01:31,619
also want to read write to the root file

38
00:01:31,619 --> 00:01:32,939
system

39
00:01:32,939 --> 00:01:35,340
so we will start here with getting a

40
00:01:35,340 --> 00:01:37,380
stable kernel read write and making it

41
00:01:37,380 --> 00:01:38,820
persistent because you would think it's

42
00:01:38,820 --> 00:01:41,759
trivial but it's not anymore

43
00:01:41,759 --> 00:01:45,360
so a bit of background so the xmu kernel

44
00:01:45,360 --> 00:01:48,540
has this um Marxist call like the Marcus

45
00:01:48,540 --> 00:01:51,540
its own sub system and it has this is

46
00:01:51,540 --> 00:01:54,479
called task for pit which gives you a

47
00:01:54,479 --> 00:01:57,540
Port task for an arbitrary process and

48
00:01:57,540 --> 00:01:59,280
if you own that

49
00:01:59,280 --> 00:02:02,520
um task port to that process you

50
00:02:02,520 --> 00:02:04,079
essentially own the process because

51
00:02:04,079 --> 00:02:07,140
there are apis available for reading

52
00:02:07,140 --> 00:02:08,940
memory writing memory controlling

53
00:02:08,940 --> 00:02:12,000
threads so the pit0 on the system is the

54
00:02:12,000 --> 00:02:14,640
kernel itself and if you get a task port

55
00:02:14,640 --> 00:02:17,160
to the kernel you can use these apis to

56
00:02:17,160 --> 00:02:20,160
read and write kernel memory essentially

57
00:02:20,160 --> 00:02:22,680
so for kernel read and write prior to

58
00:02:22,680 --> 00:02:25,739
iOS 8 or iPhone 6 what you would do is

59
00:02:25,739 --> 00:02:28,020
you would patch the kernel there's

60
00:02:28,020 --> 00:02:30,180
essentially checks saying if you call

61
00:02:30,180 --> 00:02:33,000
this API task for bit 0 would say hey is

62
00:02:33,000 --> 00:02:34,560
it put zero

63
00:02:34,560 --> 00:02:36,239
um don't allow it so you would just

64
00:02:36,239 --> 00:02:37,860
patch the check and then you can call

65
00:02:37,860 --> 00:02:39,840
the API it would give you a port to the

66
00:02:39,840 --> 00:02:42,180
kernel you can use apis to read and

67
00:02:42,180 --> 00:02:45,599
write kernel memory from user space

68
00:02:45,599 --> 00:02:47,400
easy as that

69
00:02:47,400 --> 00:02:50,819
starting from IOS 9 and the iPhone 5S

70
00:02:50,819 --> 00:02:52,800
Hardware Apple introduced kernel patch

71
00:02:52,800 --> 00:02:55,379
protection also commonly called kpp and

72
00:02:55,379 --> 00:02:57,540
that prevents from kernel being patched

73
00:02:57,540 --> 00:03:00,239
so the kernel text and the constata

74
00:03:00,239 --> 00:03:02,700
segment is protected so there is this

75
00:03:02,700 --> 00:03:05,340
kpp code which runs the neo3 which is at

76
00:03:05,340 --> 00:03:08,220
higher privilege level and it repeatedly

77
00:03:08,220 --> 00:03:10,140
checks the kernel if it's modified and

78
00:03:10,140 --> 00:03:11,760
if it detects the Chrome being modified

79
00:03:11,760 --> 00:03:13,800
it will Panic so we can no longer patch

80
00:03:13,800 --> 00:03:16,800
the kernel but luckily there has been a

81
00:03:16,800 --> 00:03:20,519
public kpp bypass dropped and the kernel

82
00:03:20,519 --> 00:03:22,260
can be patched again and it's like a

83
00:03:22,260 --> 00:03:24,420
fundamental issue so we can try to work

84
00:03:24,420 --> 00:03:26,159
around but it's like a fundamental thing

85
00:03:26,159 --> 00:03:29,760
so so it's going to be hard to fix

86
00:03:29,760 --> 00:03:32,459
so with that bypass you can again do the

87
00:03:32,459 --> 00:03:35,099
same thing from earlier patch the kernel

88
00:03:35,099 --> 00:03:38,459
codes and not that and that works up to

89
00:03:38,459 --> 00:03:42,599
iOS 10 to 1 and the iPhone 6s

90
00:03:42,599 --> 00:03:45,599
starting with the iPhone 7 Apple stepped

91
00:03:45,599 --> 00:03:48,180
up its game again they introduced ktrr

92
00:03:48,180 --> 00:03:50,519
which stands for kernel text read only

93
00:03:50,519 --> 00:03:52,980
region this is a hardware mitigation in

94
00:03:52,980 --> 00:03:55,560
the iPhone 7 which replaces the old

95
00:03:55,560 --> 00:03:58,500
style kpp basically it is a dedicated

96
00:03:58,500 --> 00:04:00,840
Hardware memory controller which locks

97
00:04:00,840 --> 00:04:04,019
down kernel memory and if you try to

98
00:04:04,019 --> 00:04:06,000
write it it will block this right at

99
00:04:06,000 --> 00:04:07,500
Hardware level so you can no longer

100
00:04:07,500 --> 00:04:10,860
write to the kernel area and there is a

101
00:04:10,860 --> 00:04:13,680
second thing which is um

102
00:04:13,680 --> 00:04:16,978
you cannot execute code outside of that

103
00:04:16,978 --> 00:04:19,680
area because only code inside that area

104
00:04:19,680 --> 00:04:22,560
will be executable

105
00:04:22,560 --> 00:04:24,540
so more info on that on my other

106
00:04:24,540 --> 00:04:26,460
presentation jailbreaking iOS which is

107
00:04:26,460 --> 00:04:29,100
kind of now the part two

108
00:04:29,100 --> 00:04:31,979
a bit more of background so Apple has

109
00:04:31,979 --> 00:04:34,259
this thing called host special ports so

110
00:04:34,259 --> 00:04:36,419
basically the Chrono provides special

111
00:04:36,419 --> 00:04:40,440
ports for the user Land by basically the

112
00:04:40,440 --> 00:04:44,400
system Daemon uh launched the registers

113
00:04:44,400 --> 00:04:47,160
um several things or itself so an app

114
00:04:47,160 --> 00:04:49,440
can use these apis to get the port to

115
00:04:49,440 --> 00:04:52,500
launch the which is then used for IPC

116
00:04:52,500 --> 00:04:55,080
interprocess communication and so

117
00:04:55,080 --> 00:04:57,060
there's like special predefined ports

118
00:04:57,060 --> 00:05:00,979
which a process can grab

119
00:05:01,020 --> 00:05:03,360
so how do we use that for kernel read

120
00:05:03,360 --> 00:05:06,600
and write well uh on up to iOS 10 to 1

121
00:05:06,600 --> 00:05:08,820
and iPhone 7 we can get the kernel task

122
00:05:08,820 --> 00:05:11,040
through the exploit and instead of

123
00:05:11,040 --> 00:05:13,020
patching the kernel text we will just

124
00:05:13,020 --> 00:05:15,240
write it to the data segment where the

125
00:05:15,240 --> 00:05:17,400
whole special ports are stored and we

126
00:05:17,400 --> 00:05:19,680
use an unused slot in this case Port

127
00:05:19,680 --> 00:05:21,780
four and then username code can call

128
00:05:21,780 --> 00:05:23,759
house get special Port which will again

129
00:05:23,759 --> 00:05:26,160
return a task code to the kernel which

130
00:05:26,160 --> 00:05:28,320
is equivalent to task for pet zero and

131
00:05:28,320 --> 00:05:30,120
then again we can use the apis to read

132
00:05:30,120 --> 00:05:33,120
and write kernel memory

133
00:05:33,120 --> 00:05:35,940
that worked up until I was sent 3 where

134
00:05:35,940 --> 00:05:37,380
Apple will introduced a pointer check

135
00:05:37,380 --> 00:05:40,800
basically if you have this port you

136
00:05:40,800 --> 00:05:43,740
would call Mark VM read Mark VM write

137
00:05:43,740 --> 00:05:47,160
and several apis so these apis introduce

138
00:05:47,160 --> 00:05:49,979
a pointer check and if they check okay

139
00:05:49,979 --> 00:05:52,800
is the passport the kernel port and if

140
00:05:52,800 --> 00:05:54,960
yes we just deny it and we don't allow

141
00:05:54,960 --> 00:05:56,400
reading on writing

142
00:05:56,400 --> 00:05:59,400
so getting the kernel task for now is

143
00:05:59,400 --> 00:06:01,740
kind of useless because we can't use the

144
00:06:01,740 --> 00:06:03,180
apis anymore

145
00:06:03,180 --> 00:06:04,740
right

146
00:06:04,740 --> 00:06:08,039
well they didn't really think about how

147
00:06:08,039 --> 00:06:09,840
virtual memory works because what you

148
00:06:09,840 --> 00:06:12,539
can do is sure the kernel app writes a

149
00:06:12,539 --> 00:06:14,880
virtual memory but if you remap that

150
00:06:14,880 --> 00:06:17,580
virtual memory to a different virtual

151
00:06:17,580 --> 00:06:20,039
memory address both pointing to the same

152
00:06:20,039 --> 00:06:22,860
physical memory the pointer is a

153
00:06:22,860 --> 00:06:25,139
different value so this simple pointer

154
00:06:25,139 --> 00:06:27,660
compare doesn't trigger anymore so what

155
00:06:27,660 --> 00:06:30,240
we do is we get the task board we remap

156
00:06:30,240 --> 00:06:32,039
it on a different virtual address and

157
00:06:32,039 --> 00:06:34,199
use that remap thing and that we put

158
00:06:34,199 --> 00:06:37,440
into whole special Port 4 and then if we

159
00:06:37,440 --> 00:06:40,020
call again host get special.4 we can

160
00:06:40,020 --> 00:06:43,139
again use get a task board and now this

161
00:06:43,139 --> 00:06:45,539
one we can use with the kernel uh read

162
00:06:45,539 --> 00:06:48,600
and write apis using Mark VM reads back

163
00:06:48,600 --> 00:06:49,979
I'm right

164
00:06:49,979 --> 00:06:52,500
so starting in iOS 13 the kernel

165
00:06:52,500 --> 00:06:53,819
allocations are split into different

166
00:06:53,819 --> 00:06:56,699
zones and different allocation types go

167
00:06:56,699 --> 00:06:58,500
to their dedicated Zone and test

168
00:06:58,500 --> 00:06:59,819
structures need to be in a certain

169
00:06:59,819 --> 00:07:02,639
allocation Zone which are different than

170
00:07:02,639 --> 00:07:05,100
mac VM apis so if you access something

171
00:07:05,100 --> 00:07:07,020
in the wrong Zone it causes a kernel

172
00:07:07,020 --> 00:07:09,120
panic so what that means is that the

173
00:07:09,120 --> 00:07:11,100
simple rematch technique does not work

174
00:07:11,100 --> 00:07:12,120
anymore

175
00:07:12,120 --> 00:07:14,300
there are two bypasses for this in iOS

176
00:07:14,300 --> 00:07:17,880
13. so prior to 13.5 you could allocate

177
00:07:17,880 --> 00:07:20,340
kernel memory and copy the kernel task

178
00:07:20,340 --> 00:07:22,919
to the new page it can actually modify

179
00:07:22,919 --> 00:07:26,160
the Zone type in for the page and set it

180
00:07:26,160 --> 00:07:28,199
to be a task page

181
00:07:28,199 --> 00:07:31,500
now they fixed this in 13.6 but you can

182
00:07:31,500 --> 00:07:33,419
still like sort of use a different

183
00:07:33,419 --> 00:07:36,000
technique in 13.7 where you create a

184
00:07:36,000 --> 00:07:38,340
corpse task assign the kernel map to the

185
00:07:38,340 --> 00:07:40,919
corpse and you mark it as active

186
00:07:40,919 --> 00:07:43,259
and then you map this fake task to host

187
00:07:43,259 --> 00:07:45,060
special part 4 and you can still use

188
00:07:45,060 --> 00:07:49,220
mock VM apis for kernel read write

189
00:07:49,560 --> 00:07:52,680
so later Apple introduced pack

190
00:07:52,680 --> 00:07:54,840
Point authentication codes which is an

191
00:07:54,840 --> 00:07:57,900
arm of the A3 Hardware extension which

192
00:07:57,900 --> 00:08:00,300
is similar to Max message authentication

193
00:08:00,300 --> 00:08:02,759
codes you may know from cryptography but

194
00:08:02,759 --> 00:08:05,099
for pointers what it does it protects

195
00:08:05,099 --> 00:08:08,460
data in memory in relation to a context

196
00:08:08,460 --> 00:08:11,039
with a secret key so these are the three

197
00:08:11,039 --> 00:08:13,020
main key points so what you can protect

198
00:08:13,020 --> 00:08:15,720
here is return values stack pointers

199
00:08:15,720 --> 00:08:18,060
function pointers V tables and data

200
00:08:18,060 --> 00:08:20,759
pointers you can also protect structured

201
00:08:20,759 --> 00:08:22,919
context by hashing the individual values

202
00:08:22,919 --> 00:08:25,080
in the struct and then finally signing

203
00:08:25,080 --> 00:08:29,460
the the hash with the pack this is also

204
00:08:29,460 --> 00:08:33,120
what Apple does in iOS so context also

205
00:08:33,120 --> 00:08:34,200
contains

206
00:08:34,200 --> 00:08:34,799
um

207
00:08:34,799 --> 00:08:37,200
a structure address and type info so

208
00:08:37,200 --> 00:08:38,940
it's also a protection against type

209
00:08:38,940 --> 00:08:42,020
confusion sometimes

210
00:08:42,419 --> 00:08:44,640
starting in iOS 14 Apple has hardened

211
00:08:44,640 --> 00:08:47,100
packed so it protects tasks hosts Port

212
00:08:47,100 --> 00:08:49,140
structures it also prevents calling the

213
00:08:49,140 --> 00:08:51,420
remap functioned kernel this is called

214
00:08:51,420 --> 00:08:53,100
and they are did something called page

215
00:08:53,100 --> 00:08:54,839
protection layer which protects writing

216
00:08:54,839 --> 00:08:56,339
to the kernel map

217
00:08:56,339 --> 00:08:57,839
there are also pointer checks against

218
00:08:57,839 --> 00:08:59,880
the kernel map and Zone require has been

219
00:08:59,880 --> 00:09:02,700
extended to pmap

220
00:09:02,700 --> 00:09:05,640
so how do we do kernel read write in RS

221
00:09:05,640 --> 00:09:08,519
14 and up to 15 1 1 and potentially even

222
00:09:08,519 --> 00:09:11,220
further so basically I came up with this

223
00:09:11,220 --> 00:09:15,120
Library which I call kernel RW so in

224
00:09:15,120 --> 00:09:17,339
order to initialize this you need an

225
00:09:17,339 --> 00:09:19,560
early kernel read which can be which

226
00:09:19,560 --> 00:09:21,000
should be stable

227
00:09:21,000 --> 00:09:22,800
um because we need to read a couple of

228
00:09:22,800 --> 00:09:26,100
things one eight by kernel ride which

229
00:09:26,100 --> 00:09:28,080
can be unstable because we just need one

230
00:09:28,080 --> 00:09:29,399
single right

231
00:09:29,399 --> 00:09:32,160
and then we need to have an info leak of

232
00:09:32,160 --> 00:09:34,380
the current task structure so basically

233
00:09:34,380 --> 00:09:36,000
what it does it allocates two Mark

234
00:09:36,000 --> 00:09:38,880
boards one I call report and one I call

235
00:09:38,880 --> 00:09:39,839
right port

236
00:09:39,839 --> 00:09:42,420
and an i o surface object with a surface

237
00:09:42,420 --> 00:09:45,240
so basically it retrieves the address of

238
00:09:45,240 --> 00:09:47,399
these ports through the initial info

239
00:09:47,399 --> 00:09:51,240
leak and the surface location in surface

240
00:09:51,240 --> 00:09:53,820
clients array so what that then does we

241
00:09:53,820 --> 00:09:56,700
write we use the right to replace the

242
00:09:56,700 --> 00:09:59,279
surface in the array with the address of

243
00:09:59,279 --> 00:10:02,399
report IP context and IP context is a

244
00:10:02,399 --> 00:10:04,019
field in the structure internal memory

245
00:10:04,019 --> 00:10:06,839
which we can set from user space

246
00:10:06,839 --> 00:10:10,440
so for the K read we can do 32-bit reads

247
00:10:10,440 --> 00:10:12,899
by setting the context which we can set

248
00:10:12,899 --> 00:10:15,180
from user space to the port to whatever

249
00:10:15,180 --> 00:10:17,459
we want to read and then we call IO

250
00:10:17,459 --> 00:10:20,700
connect call method 8 on that surface to

251
00:10:20,700 --> 00:10:23,519
read four bytes and this is equal to the

252
00:10:23,519 --> 00:10:28,080
method gets ycb CR Matrix so this is

253
00:10:28,080 --> 00:10:30,899
like some IO surface stuff the right

254
00:10:30,899 --> 00:10:33,540
Works similar we set the context of read

255
00:10:33,540 --> 00:10:35,880
port to the address of right Port which

256
00:10:35,880 --> 00:10:38,880
we also leads so we set the context of

257
00:10:38,880 --> 00:10:40,680
right port to wherever we want to write

258
00:10:40,680 --> 00:10:43,080
in the kernel and then we call a

259
00:10:43,080 --> 00:10:45,839
different method IO connect call method

260
00:10:45,839 --> 00:10:49,079
33 on that surface again to write eight

261
00:10:49,079 --> 00:10:52,219
bytes of Kernel memory

262
00:10:52,320 --> 00:10:54,240
um this technique requires a cleanup

263
00:10:54,240 --> 00:10:56,339
before the process exits because if you

264
00:10:56,339 --> 00:10:58,440
don't clean up then the kernel will will

265
00:10:58,440 --> 00:11:01,800
panic but to restore that you use a

266
00:11:01,800 --> 00:11:04,019
single eight byte right in the clients

267
00:11:04,019 --> 00:11:05,579
array you can use this very same right

268
00:11:05,579 --> 00:11:08,640
you have here to clean it up if you want

269
00:11:08,640 --> 00:11:11,519
to hand over this kernel retry primitive

270
00:11:11,519 --> 00:11:14,459
uh we also implemented a handoff

271
00:11:14,459 --> 00:11:17,100
procedure so we use Smart ports for

272
00:11:17,100 --> 00:11:20,160
inter-process communication and then we

273
00:11:20,160 --> 00:11:22,500
use the available primitive to retrieve

274
00:11:22,500 --> 00:11:24,300
kernel addresses and perform the initial

275
00:11:24,300 --> 00:11:26,120
right from the

276
00:11:26,120 --> 00:11:28,620
donor process and then from the target

277
00:11:28,620 --> 00:11:31,560
process they can it's like armed and

278
00:11:31,560 --> 00:11:33,959
then they can use the read write and we

279
00:11:33,959 --> 00:11:35,940
also transfer the original uh address

280
00:11:35,940 --> 00:11:38,399
back so the target then can also clean

281
00:11:38,399 --> 00:11:40,680
up after itself

282
00:11:40,680 --> 00:11:43,500
so this primitive needs to be passed

283
00:11:43,500 --> 00:11:45,360
around and on its own it's not

284
00:11:45,360 --> 00:11:48,120
persistent and it dies on process assets

285
00:11:48,120 --> 00:11:50,339
and you actually should be cleaning it

286
00:11:50,339 --> 00:11:52,320
up before the process exits so the

287
00:11:52,320 --> 00:11:53,940
jailbreak eventually passes that

288
00:11:53,940 --> 00:11:55,560
primitive to

289
00:11:55,560 --> 00:11:58,560
um a launch D and launch the holds onto

290
00:11:58,560 --> 00:12:00,540
the raw Primitives and other processes

291
00:12:00,540 --> 00:12:02,399
can talk to launch D for kernel read

292
00:12:02,399 --> 00:12:05,760
write via a library exposed lib kernel

293
00:12:05,760 --> 00:12:08,339
RW

294
00:12:08,339 --> 00:12:10,320
um yeah so for jailbreaking in a

295
00:12:10,320 --> 00:12:11,640
nutshell

296
00:12:11,640 --> 00:12:12,839
um we

297
00:12:12,839 --> 00:12:15,000
figured out the first thing which is get

298
00:12:15,000 --> 00:12:17,459
a stable kernel read write so the next

299
00:12:17,459 --> 00:12:19,500
thing we're going to talk about is the

300
00:12:19,500 --> 00:12:21,120
privilege escalation

301
00:12:21,120 --> 00:12:23,760
which is we want to get the ability to

302
00:12:23,760 --> 00:12:25,380
spawn processes which we can't inside

303
00:12:25,380 --> 00:12:28,100
the samples and we want to be root

304
00:12:28,100 --> 00:12:31,320
so if you don't know how the xmu looks

305
00:12:31,320 --> 00:12:34,440
like this is exactly how xnu is was

306
00:12:34,440 --> 00:12:38,700
designed it consists of a BSD of Mac

307
00:12:38,700 --> 00:12:40,980
parts and iok it part which groups

308
00:12:40,980 --> 00:12:42,540
everything together so it just doesn't

309
00:12:42,540 --> 00:12:44,639
fall apart

310
00:12:44,639 --> 00:12:45,660
um

311
00:12:45,660 --> 00:12:46,860
yeah

312
00:12:46,860 --> 00:12:49,680
so first a little more of the background

313
00:12:49,680 --> 00:12:54,360
so there's this BSD task proc which is

314
00:12:54,360 --> 00:12:57,540
each task has abs the prop structure in

315
00:12:57,540 --> 00:12:59,760
the kernel and proc structure manages

316
00:12:59,760 --> 00:13:02,160
resources and permissions of a process

317
00:13:02,160 --> 00:13:05,339
so each proc structure has the u-cut

318
00:13:05,339 --> 00:13:06,779
structure now we wonder okay what is

319
00:13:06,779 --> 00:13:08,279
this eukaryotic structure the ukrit

320
00:13:08,279 --> 00:13:10,980
structure handles process credentials

321
00:13:10,980 --> 00:13:13,440
and manages user accounts for processes

322
00:13:13,440 --> 00:13:16,079
and among others contains the user ID

323
00:13:16,079 --> 00:13:19,800
and the group ID uida GD and it has also

324
00:13:19,800 --> 00:13:23,880
a Mac F label structure for amfi and

325
00:13:23,880 --> 00:13:24,959
sandbox

326
00:13:24,959 --> 00:13:29,220
so what exactly is this macf this is

327
00:13:29,220 --> 00:13:31,680
mandatory Access Control framework which

328
00:13:31,680 --> 00:13:34,320
was introduced in FreeBSD it hooks

329
00:13:34,320 --> 00:13:37,320
across it are it is hooks across the

330
00:13:37,320 --> 00:13:39,600
kernel which allow restricting

331
00:13:39,600 --> 00:13:42,420
permissions through these policies

332
00:13:42,420 --> 00:13:45,480
despite being rude so you can have a

333
00:13:45,480 --> 00:13:47,820
kernel system-wide policy so not even

334
00:13:47,820 --> 00:13:50,339
root can do several things and this is

335
00:13:50,339 --> 00:13:53,339
enforced by the kernel so amfi which is

336
00:13:53,339 --> 00:13:55,260
Apple mobile file integrity and sandbox

337
00:13:55,260 --> 00:13:58,079
register Mac F policy hooks

338
00:13:58,079 --> 00:14:02,180
and we need to kind of work around them

339
00:14:02,760 --> 00:14:07,500
so prior to iOS uh 11 so including up to

340
00:14:07,500 --> 00:14:10,139
iOS 10 sandbox enroute what you could do

341
00:14:10,139 --> 00:14:13,560
is set our own uh prox eucrate pointer

342
00:14:13,560 --> 00:14:16,560
and change it to be the kernels you cred

343
00:14:16,560 --> 00:14:17,940
pointer

344
00:14:17,940 --> 00:14:19,860
um sandbox has a hard-coded check to not

345
00:14:19,860 --> 00:14:22,500
enforce anything on the Kernel so having

346
00:14:22,500 --> 00:14:24,660
kernel Kratz um

347
00:14:24,660 --> 00:14:27,000
skips all the sandbox and it already

348
00:14:27,000 --> 00:14:28,800
grants root permission so having the

349
00:14:28,800 --> 00:14:30,360
kernel ukrat you're already rude and

350
00:14:30,360 --> 00:14:31,740
you're already on Sandbox and you're

351
00:14:31,740 --> 00:14:34,440
done so technically this works up to

352
00:14:34,440 --> 00:14:38,160
Iris 13 but I got crippled in iOS 11

353
00:14:38,160 --> 00:14:40,980
because if you try that in iOS 11 and

354
00:14:40,980 --> 00:14:43,800
then replace the pointer and try calling

355
00:14:43,800 --> 00:14:46,199
some apis the current will Panic by

356
00:14:46,199 --> 00:14:50,160
sandbox uh text saying Shenanigans so

357
00:14:50,160 --> 00:14:53,399
you need to kind of work around that

358
00:14:53,399 --> 00:14:55,560
in iOS 13 they implemented some

359
00:14:55,560 --> 00:14:56,880
mitigations

360
00:14:56,880 --> 00:14:59,040
however we don't necessarily need the

361
00:14:59,040 --> 00:15:02,160
kernel you cred and we can just copy the

362
00:15:02,160 --> 00:15:04,800
CR label to escape sandbox

363
00:15:04,800 --> 00:15:07,139
we're now on Sandbox but we still have

364
00:15:07,139 --> 00:15:10,199
our the mobile user to get root we can

365
00:15:10,199 --> 00:15:12,720
call set uid 0. however it has a check

366
00:15:12,720 --> 00:15:16,139
if ruid uid or svuid match

367
00:15:16,139 --> 00:15:18,240
attaching the ruid would cause problems

368
00:15:18,240 --> 00:15:19,860
even though it would immediately give us

369
00:15:19,860 --> 00:15:22,560
root as ukrits could be reused and this

370
00:15:22,560 --> 00:15:24,300
could Elevate random processes on the

371
00:15:24,300 --> 00:15:25,500
system

372
00:15:25,500 --> 00:15:28,440
however we can patch svuid to zero and

373
00:15:28,440 --> 00:15:30,839
we can call set uid Twice first to

374
00:15:30,839 --> 00:15:32,579
update the uid and the second time to

375
00:15:32,579 --> 00:15:34,139
update euid

376
00:15:34,139 --> 00:15:37,680
and now we're root and I was 14 however

377
00:15:37,680 --> 00:15:39,420
they implemented data pack which

378
00:15:39,420 --> 00:15:41,880
protects a bunch of pointers and struck

379
00:15:41,880 --> 00:15:43,680
members with pack

380
00:15:43,680 --> 00:15:45,779
CR label is now protected with Pac

381
00:15:45,779 --> 00:15:49,800
however this contains a l pointer array

382
00:15:49,800 --> 00:15:51,779
with pointers to various mock F policies

383
00:15:51,779 --> 00:15:55,680
the MP policy is array zero and sandbox

384
00:15:55,680 --> 00:15:56,760
is

385
00:15:56,760 --> 00:15:58,980
the first policy

386
00:15:58,980 --> 00:16:01,620
and iOS 14 does allow setting pack

387
00:16:01,620 --> 00:16:04,079
pointers to null and setting this to

388
00:16:04,079 --> 00:16:07,620
null Escape sandbox similar to iOS 13.

389
00:16:07,620 --> 00:16:10,440
now in I was 15 they implemented some

390
00:16:10,440 --> 00:16:13,740
more data packs so they protected just

391
00:16:13,740 --> 00:16:16,079
this pointer against nulling trust me we

392
00:16:16,079 --> 00:16:17,820
checked like they only protected two

393
00:16:17,820 --> 00:16:21,300
pointers for this and the upper bits of

394
00:16:21,300 --> 00:16:23,160
a null pointer now require a pack

395
00:16:23,160 --> 00:16:25,740
signature

396
00:16:25,740 --> 00:16:28,920
so is15 sandbox bypass

397
00:16:28,920 --> 00:16:31,860
um coming soon we have it working

398
00:16:31,860 --> 00:16:33,980
um

399
00:16:34,079 --> 00:16:36,420
all right that clears on the road map

400
00:16:36,420 --> 00:16:38,399
for the privilege escalation part so we

401
00:16:38,399 --> 00:16:40,019
know how we can escape sandbox and how

402
00:16:40,019 --> 00:16:43,459
to become root next up is

403
00:16:43,459 --> 00:16:45,839
bypassing cold sightening enforcement

404
00:16:45,839 --> 00:16:47,940
because otherwise we can only run Apple

405
00:16:47,940 --> 00:16:49,440
constant code you know we don't want

406
00:16:49,440 --> 00:16:50,220
that

407
00:16:50,220 --> 00:16:54,060
so up until the iPhone 6s we can simply

408
00:16:54,060 --> 00:16:56,339
patch the kernel like there like even

409
00:16:56,339 --> 00:16:58,500
with the kpp bypass and Theory at least

410
00:16:58,500 --> 00:17:01,320
we um patch the kernel and we can make

411
00:17:01,320 --> 00:17:03,660
it treat every binary as being in trust

412
00:17:03,660 --> 00:17:05,699
cache which is saying hey I am an apple

413
00:17:05,699 --> 00:17:08,520
binary I'm fine I can run there's minor

414
00:17:08,520 --> 00:17:10,260
differences in patching between before

415
00:17:10,260 --> 00:17:13,140
is 11 and lighter than iOS 12 but it's

416
00:17:13,140 --> 00:17:14,819
the same idea

417
00:17:14,819 --> 00:17:18,119
um on iPhone 7 however a ktrr prevents

418
00:17:18,119 --> 00:17:19,799
kernel from being patched and we need to

419
00:17:19,799 --> 00:17:22,380
figure out something else

420
00:17:22,380 --> 00:17:23,699
so

421
00:17:23,699 --> 00:17:24,959
yeah

422
00:17:24,959 --> 00:17:27,480
so MV contains trust caches static and

423
00:17:27,480 --> 00:17:29,460
dynamic and these static trust caches

424
00:17:29,460 --> 00:17:32,400
are for binaries built into iOS these

425
00:17:32,400 --> 00:17:34,740
are chip with the ipsw and or for stock

426
00:17:34,740 --> 00:17:37,140
binders Dynamic trust caches are used

427
00:17:37,140 --> 00:17:39,419
for xcode debug and therefore binaries

428
00:17:39,419 --> 00:17:42,240
that are required for debugging

429
00:17:42,240 --> 00:17:44,580
calling a kernel function allows loading

430
00:17:44,580 --> 00:17:46,320
new trust caches to Mark a set of

431
00:17:46,320 --> 00:17:49,020
binaries as trusted we use this on

432
00:17:49,020 --> 00:17:51,660
electron Chimera for iOS 11 and 12 for

433
00:17:51,660 --> 00:17:54,600
jailbreak bundle binaries on iPhone 10s

434
00:17:54,600 --> 00:17:56,220
and newer this does require a pack

435
00:17:56,220 --> 00:17:58,679
bypass to call the functions and it's

436
00:17:58,679 --> 00:18:00,360
only really usable for a limited number

437
00:18:00,360 --> 00:18:02,880
of trust caches as we could run out of

438
00:18:02,880 --> 00:18:04,740
Kernel memory

439
00:18:04,740 --> 00:18:07,500
we have a theory for bypassing on iPhone

440
00:18:07,500 --> 00:18:09,660
10 and lower which you've not tested yet

441
00:18:09,660 --> 00:18:12,000
but it should work so you can load a

442
00:18:12,000 --> 00:18:13,559
large dynamic trust cache with some

443
00:18:13,559 --> 00:18:15,480
placeholder hashes

444
00:18:15,480 --> 00:18:17,760
and have a demon like jailbreak D to

445
00:18:17,760 --> 00:18:19,559
complete the hashes before each binary

446
00:18:19,559 --> 00:18:22,140
runs if the hash is not in kernel memory

447
00:18:22,140 --> 00:18:24,179
we can write it to the placeholder slots

448
00:18:24,179 --> 00:18:26,940
in the trust cache

449
00:18:26,940 --> 00:18:29,460
now on the iPhone 10s and up we can

450
00:18:29,460 --> 00:18:31,919
apply a similar Theory as it has load

451
00:18:31,919 --> 00:18:34,320
and unload trustcast functions so we

452
00:18:34,320 --> 00:18:35,940
first loaded Dynamic trust cache with

453
00:18:35,940 --> 00:18:38,520
jailbreak based binaries and before each

454
00:18:38,520 --> 00:18:40,500
binary runs the Opera D can compute the

455
00:18:40,500 --> 00:18:42,660
hash it loads a trust cache for the

456
00:18:42,660 --> 00:18:44,940
binary and then it unloads a trust cache

457
00:18:44,940 --> 00:18:47,820
after it runs and the code signature is

458
00:18:47,820 --> 00:18:50,520
now cached for feature runs on the

459
00:18:50,520 --> 00:18:54,000
v-node now this unload function might

460
00:18:54,000 --> 00:18:56,280
not exist on a11 or lower but we've

461
00:18:56,280 --> 00:18:58,320
never really tested it because you can

462
00:18:58,320 --> 00:19:02,000
just write to the trust cache

463
00:19:02,640 --> 00:19:06,480
now here's a bypass for iOS 11 and below

464
00:19:06,480 --> 00:19:09,000
so amphi calls MPD and user space for

465
00:19:09,000 --> 00:19:10,799
binaries not in trust cache as long as

466
00:19:10,799 --> 00:19:12,780
it contain any signature

467
00:19:12,780 --> 00:19:15,660
MPD calls Mis validate code signature

468
00:19:15,660 --> 00:19:17,039
and copy info

469
00:19:17,039 --> 00:19:19,440
we could load the daylib into MPD to

470
00:19:19,440 --> 00:19:21,720
pass this function to zero and compute a

471
00:19:21,720 --> 00:19:24,179
CD cache this dialog can be loaded into

472
00:19:24,179 --> 00:19:25,620
trust cache which you can write to

473
00:19:25,620 --> 00:19:27,179
Kernel memory

474
00:19:27,179 --> 00:19:29,280
MPD then returns that the binary is

475
00:19:29,280 --> 00:19:31,740
trusted and the binary runs

476
00:19:31,740 --> 00:19:33,600
this technique has been deployed in

477
00:19:33,600 --> 00:19:36,179
Mount fertile triple fetch liver iOS and

478
00:19:36,179 --> 00:19:38,100
Elektra

479
00:19:38,100 --> 00:19:40,500
however in iOS 12 they added this thing

480
00:19:40,500 --> 00:19:43,080
called core Trust an amphi calls

481
00:19:43,080 --> 00:19:45,059
cortress for binary is not in the trust

482
00:19:45,059 --> 00:19:48,000
cache before it even gets to MVD so

483
00:19:48,000 --> 00:19:50,400
Court Trust relies requires a valid

484
00:19:50,400 --> 00:19:51,900
signature that change all the way back

485
00:19:51,900 --> 00:19:52,860
to Apple

486
00:19:52,860 --> 00:19:55,620
MPD doesn't even get called if the core

487
00:19:55,620 --> 00:19:58,440
trust validation fails and MPD verifies

488
00:19:58,440 --> 00:20:00,360
certificate expiry and provisioning

489
00:20:00,360 --> 00:20:02,820
profiles

490
00:20:02,820 --> 00:20:05,400
now on the iPhone 10s and up page

491
00:20:05,400 --> 00:20:08,039
protection layer was a mitigation that

492
00:20:08,039 --> 00:20:09,960
was introduced which protects certain

493
00:20:09,960 --> 00:20:12,900
data segments and Page Maps and only the

494
00:20:12,900 --> 00:20:14,880
PPL text section of the kernel can write

495
00:20:14,880 --> 00:20:16,860
to these protected regions and it must

496
00:20:16,860 --> 00:20:18,720
call the trampoline functions to change

497
00:20:18,720 --> 00:20:21,120
the CPU state to enter PPL it's kind of

498
00:20:21,120 --> 00:20:24,419
like a micro kernel with syscalls in L1

499
00:20:24,419 --> 00:20:26,520
both of them are an eel one but it's

500
00:20:26,520 --> 00:20:28,679
like a separate CPU State and Pac

501
00:20:28,679 --> 00:20:30,539
prevents the attacker from calling set

502
00:20:30,539 --> 00:20:32,160
functions

503
00:20:32,160 --> 00:20:34,860
team FCS is another part of PPL which

504
00:20:34,860 --> 00:20:36,900
holds the trust cache and validated code

505
00:20:36,900 --> 00:20:40,020
signature blocks there are distinguished

506
00:20:40,020 --> 00:20:42,539
trust levels so tl1 is for App Store

507
00:20:42,539 --> 00:20:44,700
binaries and side loaded binaries so

508
00:20:44,700 --> 00:20:47,580
anything Allowed by MPD tl2 and 3 are

509
00:20:47,580 --> 00:20:49,740
trust caches so developer disk images

510
00:20:49,740 --> 00:20:52,860
and iOS built-in binaries tl1 libraries

511
00:20:52,860 --> 00:20:54,960
cannot be loaded into higher trust

512
00:20:54,960 --> 00:20:57,360
binaries so this kind of prevents

513
00:20:57,360 --> 00:20:59,100
third-party dialogues from loading into

514
00:20:59,100 --> 00:21:01,639
MPD

515
00:21:01,740 --> 00:21:03,360
now there's a thing called the code

516
00:21:03,360 --> 00:21:06,240
signing v-node cache so when amphi gets

517
00:21:06,240 --> 00:21:09,120
called it calls UBC CS blob ad which

518
00:21:09,120 --> 00:21:11,400
tries loading a kernel a code signature

519
00:21:11,400 --> 00:21:13,799
for a binary the kernel maintains a

520
00:21:13,799 --> 00:21:16,080
cache of CF blocks for each V node so V

521
00:21:16,080 --> 00:21:18,360
node is a representation of a file in

522
00:21:18,360 --> 00:21:20,820
the kernel and the Cs blob is the kernel

523
00:21:20,820 --> 00:21:22,620
representation of a code signature and

524
00:21:22,620 --> 00:21:24,660
empty doesn't get called if a v node

525
00:21:24,660 --> 00:21:28,020
already has a code signature attached

526
00:21:28,020 --> 00:21:30,299
Now for iOS 12 and Below where we have

527
00:21:30,299 --> 00:21:33,000
kxx jailbreak D can get called before

528
00:21:33,000 --> 00:21:35,100
binary runs if the signature wasn't

529
00:21:35,100 --> 00:21:37,380
loaded we write to its v-node cache and

530
00:21:37,380 --> 00:21:40,080
we do this by replicating UBC CS bulb

531
00:21:40,080 --> 00:21:40,860
add

532
00:21:40,860 --> 00:21:42,960
so we've patch the code signature to add

533
00:21:42,960 --> 00:21:44,760
arbitrary entitlements before running

534
00:21:44,760 --> 00:21:47,280
the binary and we can call ppls to

535
00:21:47,280 --> 00:21:49,860
register the code signature this bypass

536
00:21:49,860 --> 00:21:52,679
is all of enthy including contrast

537
00:21:52,679 --> 00:21:55,380
and as for changing the code signature

538
00:21:55,380 --> 00:21:57,720
of system binaries that changes its hash

539
00:21:57,720 --> 00:21:59,640
which also demotes its trust level so

540
00:21:59,640 --> 00:22:01,559
you can eject into it

541
00:22:01,559 --> 00:22:03,840
this has been deployed in the Chimera

542
00:22:03,840 --> 00:22:06,000
jailbreak

543
00:22:06,000 --> 00:22:10,320
now on iOS 14 and Below without kxec you

544
00:22:10,320 --> 00:22:12,360
can use a similar technique where

545
00:22:12,360 --> 00:22:14,340
jailbreak D gets called before the

546
00:22:14,340 --> 00:22:17,820
binary runs and we can sign the binary

547
00:22:17,820 --> 00:22:19,860
with a free expired developer

548
00:22:19,860 --> 00:22:22,380
certificate and the reason for this is

549
00:22:22,380 --> 00:22:24,900
that change back to Apple so it passes

550
00:22:24,900 --> 00:22:27,419
core Trust in this process we can also

551
00:22:27,419 --> 00:22:30,480
add arbitrary entitlements and we then

552
00:22:30,480 --> 00:22:33,179
call this syscall to add a signature to

553
00:22:33,179 --> 00:22:34,320
the kernel

554
00:22:34,320 --> 00:22:37,200
it loads the signature passes contrast

555
00:22:37,200 --> 00:22:39,960
validation and then if the MPD check

556
00:22:39,960 --> 00:22:41,880
passes the signature is attached to V

557
00:22:41,880 --> 00:22:42,960
node

558
00:22:42,960 --> 00:22:44,880
MP does not get called again with the

559
00:22:44,880 --> 00:22:47,940
binary runs as is in cash this has been

560
00:22:47,940 --> 00:22:50,340
deployed in Odyssey and taurine

561
00:22:50,340 --> 00:22:52,980
now mv's D still needs to pass the check

562
00:22:52,980 --> 00:22:55,380
so how do we do that

563
00:22:55,380 --> 00:22:57,840
remember that we can't load a die-lib

564
00:22:57,840 --> 00:22:59,400
into MPD

565
00:22:59,400 --> 00:23:01,919
so we use a different technique where we

566
00:23:01,919 --> 00:23:04,919
get the test part of MPD which I'll as

567
00:23:04,919 --> 00:23:07,140
you saw earlier basically makes its own

568
00:23:07,140 --> 00:23:09,659
MPD it can read and write to his memory

569
00:23:09,659 --> 00:23:12,179
we register an exception Port so we're

570
00:23:12,179 --> 00:23:14,340
the debugger now we corrupt a pointer

571
00:23:14,340 --> 00:23:16,559
for Ms validate code signature and copy

572
00:23:16,559 --> 00:23:19,080
info the next time MPD is called it

573
00:23:19,080 --> 00:23:21,240
crashes we cache the exception message

574
00:23:21,240 --> 00:23:23,100
and read the binary file link from the

575
00:23:23,100 --> 00:23:24,900
CPU registers

576
00:23:24,900 --> 00:23:27,179
then we can write the CD hash to the

577
00:23:27,179 --> 00:23:29,400
memory and continue program flow as a

578
00:23:29,400 --> 00:23:32,039
validation passed

579
00:23:32,039 --> 00:23:34,620
now how do we get the task port

580
00:23:34,620 --> 00:23:36,840
to get the task for MP requires either

581
00:23:36,840 --> 00:23:38,820
the local process to have task for pit

582
00:23:38,820 --> 00:23:40,919
allow or the target process to have get

583
00:23:40,919 --> 00:23:42,600
task allow

584
00:23:42,600 --> 00:23:44,880
now the ukred CR label contains the

585
00:23:44,880 --> 00:23:47,700
empty slot with entitlements and

586
00:23:47,700 --> 00:23:50,340
on iOS 13 and Below we can steal the

587
00:23:50,340 --> 00:23:52,919
entitlement of an arbitrary process

588
00:23:52,919 --> 00:23:56,220
for example bin PS

589
00:23:56,220 --> 00:23:58,220
foreign

590
00:23:58,220 --> 00:24:01,320
however this label pointer is protected

591
00:24:01,320 --> 00:24:02,340
with pack

592
00:24:02,340 --> 00:24:05,460
however this pointer is an OS dictionary

593
00:24:05,460 --> 00:24:08,460
which is generated from the xmlp list

594
00:24:08,460 --> 00:24:10,799
now this is protected by Pac but it

595
00:24:10,799 --> 00:24:12,360
contains keys and values which are not

596
00:24:12,360 --> 00:24:13,919
protected by pack

597
00:24:13,919 --> 00:24:16,140
and we can overwrite these keys and

598
00:24:16,140 --> 00:24:17,640
values in kernel memory to replace

599
00:24:17,640 --> 00:24:19,200
entitlements with ones we need from

600
00:24:19,200 --> 00:24:21,600
other processes for example we can still

601
00:24:21,600 --> 00:24:24,720
grab task for pit allow from NPS

602
00:24:24,720 --> 00:24:28,380
and we can still get the task part

603
00:24:28,380 --> 00:24:30,600
however we're still not done yet for

604
00:24:30,600 --> 00:24:33,000
hours 14. so they added this thing

605
00:24:33,000 --> 00:24:34,740
called user land pack

606
00:24:34,740 --> 00:24:38,640
and and I was 14 they changed they pack

607
00:24:38,640 --> 00:24:41,280
keys to depend on the origin for example

608
00:24:41,280 --> 00:24:43,620
platform binaries have one set of keys

609
00:24:43,620 --> 00:24:45,720
except for a webkit and iMessage Plus

610
00:24:45,720 --> 00:24:46,799
store

611
00:24:46,799 --> 00:24:49,440
or it's based off the team ID for

612
00:24:49,440 --> 00:24:51,960
third-party binaries like load

613
00:24:51,960 --> 00:24:54,000
and when you launch the jailbreak app it

614
00:24:54,000 --> 00:24:56,100
is not initially a platform binary so

615
00:24:56,100 --> 00:24:58,559
the pet keys don't match MPD

616
00:24:58,559 --> 00:25:01,440
and we can't sign pointers to manipulate

617
00:25:01,440 --> 00:25:03,059
the process state

618
00:25:03,059 --> 00:25:05,520
since the pecky doesn't match

619
00:25:05,520 --> 00:25:08,340
now Apple accidentally documented this

620
00:25:08,340 --> 00:25:11,039
for us they put this on GitHub and they

621
00:25:11,039 --> 00:25:12,480
pulled it later

622
00:25:12,480 --> 00:25:13,140
um

623
00:25:13,140 --> 00:25:15,720
so as it says the user face process keys

624
00:25:15,720 --> 00:25:18,539
are in the job field struct

625
00:25:18,539 --> 00:25:20,940
we can copy this from fvd in the kernel

626
00:25:20,940 --> 00:25:24,360
to overwrite our threads key

627
00:25:24,360 --> 00:25:26,340
however changing the pack keys of a

628
00:25:26,340 --> 00:25:28,080
running thread will cause it to crash if

629
00:25:28,080 --> 00:25:31,320
it caused any other C functions the god

630
00:25:31,320 --> 00:25:34,020
pointers are assigned with the a key so

631
00:25:34,020 --> 00:25:36,179
we do control what runs on our threads

632
00:25:36,179 --> 00:25:37,980
so we can craft a signing Oracle in

633
00:25:37,980 --> 00:25:41,940
assembly that doesn't rely on live C

634
00:25:41,940 --> 00:25:45,240
and there is a signing Oracle now it

635
00:25:45,240 --> 00:25:46,980
turns out there is a mock API that could

636
00:25:46,980 --> 00:25:48,840
have done this a lot simpler this was

637
00:25:48,840 --> 00:25:51,539
kind of like I was more preoccupied with

638
00:25:51,539 --> 00:25:53,640
whether I could I didn't think if I

639
00:25:53,640 --> 00:25:55,320
should do this

640
00:25:55,320 --> 00:25:56,400
um

641
00:25:56,400 --> 00:26:00,480
but anyways so now we can patch MPD up

642
00:26:00,480 --> 00:26:03,120
to iOS 14.

643
00:26:03,120 --> 00:26:05,460
and I was 15 they added this thing

644
00:26:05,460 --> 00:26:06,960
called OS entitlements where they

645
00:26:06,960 --> 00:26:09,299
switched from the XML dictionary to Der

646
00:26:09,299 --> 00:26:12,179
entitlements the ER is backed by a new

647
00:26:12,179 --> 00:26:13,919
OS entitlements object in the kernel

648
00:26:13,919 --> 00:26:16,140
which is in the closed Source amphi text

649
00:26:16,140 --> 00:26:18,120
it is protected by pack

650
00:26:18,120 --> 00:26:19,799
so the way it works is they have a hash

651
00:26:19,799 --> 00:26:22,260
for the entire blob so you can't really

652
00:26:22,260 --> 00:26:25,080
change anything in it

653
00:26:25,080 --> 00:26:28,860
so is 15 MP bypass coming soon

654
00:26:28,860 --> 00:26:30,779
um you can see we have SSH running here

655
00:26:30,779 --> 00:26:32,210
already

656
00:26:32,210 --> 00:26:33,440
[Music]

657
00:26:33,440 --> 00:26:36,179
and that is bypassing code sign

658
00:26:36,179 --> 00:26:38,659
enforcement

659
00:26:39,419 --> 00:26:41,039
I'm going to list a system-wide code

660
00:26:41,039 --> 00:26:42,779
injection so why would you want

661
00:26:42,779 --> 00:26:44,760
system-wide code injection well the

662
00:26:44,760 --> 00:26:46,440
lowest users to install modifications

663
00:26:46,440 --> 00:26:49,440
tweaks to the system gives endless

664
00:26:49,440 --> 00:26:51,779
customization last custom icons custom

665
00:26:51,779 --> 00:26:53,700
whatever and it's essential your

666
00:26:53,700 --> 00:26:56,100
jailbreak right so the requirements for

667
00:26:56,100 --> 00:26:57,960
system-wide code injection is to load

668
00:26:57,960 --> 00:27:00,120
custom code in the process on loading

669
00:27:00,120 --> 00:27:02,159
must be able to modify text segment

670
00:27:02,159 --> 00:27:05,400
loosen the sandbox restriction to load

671
00:27:05,400 --> 00:27:08,820
assets and read preferences so again on

672
00:27:08,820 --> 00:27:11,460
iPhone before iPhones XS we can easily

673
00:27:11,460 --> 00:27:14,039
patch the kernel so we patch out the

674
00:27:14,039 --> 00:27:16,500
sandbox Mac F hooks to not have the

675
00:27:16,500 --> 00:27:18,659
sandbox Supply anymore and we patch

676
00:27:18,659 --> 00:27:21,360
checks and VM folds to not invalidate

677
00:27:21,360 --> 00:27:24,840
the um code design code pages so the

678
00:27:24,840 --> 00:27:26,340
kernel still thinks it called Pages

679
00:27:26,340 --> 00:27:27,720
assigned

680
00:27:27,720 --> 00:27:30,539
how do you how demons get spawned on iOS

681
00:27:30,539 --> 00:27:33,179
well launch key is the pit one it is

682
00:27:33,179 --> 00:27:35,520
equivalent to any D or system geonenix

683
00:27:35,520 --> 00:27:37,980
systems it calls posix spawn to execute

684
00:27:37,980 --> 00:27:40,380
demons and even if on the home screen on

685
00:27:40,380 --> 00:27:42,799
springboard you tap on an app

686
00:27:42,799 --> 00:27:44,940
springboard doesn't actually launch them

687
00:27:44,940 --> 00:27:47,220
but it talks launched in launch they

688
00:27:47,220 --> 00:27:49,799
actually executes them similar to Demons

689
00:27:49,799 --> 00:27:51,140
so

690
00:27:51,140 --> 00:27:54,659
we're laying custom code you um so the

691
00:27:54,659 --> 00:27:57,179
yld is the dynamic Linker on iOS and Mac

692
00:27:57,179 --> 00:28:01,080
OS and there are environment variables

693
00:28:01,080 --> 00:28:03,720
like dual V insert libraries and if that

694
00:28:03,720 --> 00:28:05,880
is set the world you will load the

695
00:28:05,880 --> 00:28:09,000
libraries on launch it does require the

696
00:28:09,000 --> 00:28:11,520
get task below entitlement on the binary

697
00:28:11,520 --> 00:28:13,500
that we're running but we can have that

698
00:28:13,500 --> 00:28:15,659
have a kernel patch which just sets that

699
00:28:15,659 --> 00:28:18,539
for all the binaries

700
00:28:18,539 --> 00:28:21,900
so we load the dialog into launch D

701
00:28:21,900 --> 00:28:23,700
using the taskbar that we already have

702
00:28:23,700 --> 00:28:26,700
we hope posix spawn and add an

703
00:28:26,700 --> 00:28:29,039
environment variable to all the newly

704
00:28:29,039 --> 00:28:31,799
spawned processes and the dild in the

705
00:28:31,799 --> 00:28:33,600
new process loads the requested binary

706
00:28:33,600 --> 00:28:35,460
so we have system-wide code injection

707
00:28:35,460 --> 00:28:38,760
complete for the iPhone 6s very simple

708
00:28:38,760 --> 00:28:41,520
with kernel patches

709
00:28:41,520 --> 00:28:44,760
on iPhone 7 where we have kernel code

710
00:28:44,760 --> 00:28:46,380
execution we have to apply different

711
00:28:46,380 --> 00:28:48,000
technique

712
00:28:48,000 --> 00:28:49,080
so

713
00:28:49,080 --> 00:28:50,880
first we need to load the dialog into

714
00:28:50,880 --> 00:28:53,640
launch D which we can do with the trust

715
00:28:53,640 --> 00:28:57,120
cache we then use the task port to hook

716
00:28:57,120 --> 00:28:58,740
posix Bond

717
00:28:58,740 --> 00:29:02,100
however the new process doesn't load due

718
00:29:02,100 --> 00:29:03,779
to the lack of code signing so remember

719
00:29:03,779 --> 00:29:06,360
core trust yeah that's going to stop us

720
00:29:06,360 --> 00:29:08,279
here

721
00:29:08,279 --> 00:29:11,000
now cartridge as you explained before

722
00:29:11,000 --> 00:29:14,220
prevents loading binaries

723
00:29:14,220 --> 00:29:16,620
however or

724
00:29:16,620 --> 00:29:19,200
our jailbreak D can load code signatures

725
00:29:19,200 --> 00:29:21,659
so we just add a call to load the code

726
00:29:21,659 --> 00:29:23,820
signature before the binary runs

727
00:29:23,820 --> 00:29:25,980
and dld in the new process then loads

728
00:29:25,980 --> 00:29:28,020
your Crystal Library

729
00:29:28,020 --> 00:29:30,419
now what about the other processes so

730
00:29:30,419 --> 00:29:32,220
other processes can call posix spawn

731
00:29:32,220 --> 00:29:34,679
Fork exact system Etc

732
00:29:34,679 --> 00:29:36,720
however most of these just wrap around

733
00:29:36,720 --> 00:29:38,940
posix spawn are exact except can be

734
00:29:38,940 --> 00:29:40,799
hooked and redirected to posix spawn

735
00:29:40,799 --> 00:29:43,260
with the set exec attribute

736
00:29:43,260 --> 00:29:45,720
so this will make posix bond behave a

737
00:29:45,720 --> 00:29:47,159
lot like xsec

738
00:29:47,159 --> 00:29:49,559
Kazakhstan can now be hooked similar to

739
00:29:49,559 --> 00:29:51,659
logitee with another dial-up and the

740
00:29:51,659 --> 00:29:54,480
injection is system-wide

741
00:29:54,480 --> 00:29:56,700
however code signing is still enforced

742
00:29:56,700 --> 00:29:58,559
as so far all we've done is load custom

743
00:29:58,559 --> 00:30:00,840
code signatures so you can't modify

744
00:30:00,840 --> 00:30:04,799
arbitrary process text or can we

745
00:30:04,799 --> 00:30:06,840
so debugging through xcode does require

746
00:30:06,840 --> 00:30:09,059
modifying text to set breakpoints for

747
00:30:09,059 --> 00:30:11,580
ldb this is guarded by get task allow

748
00:30:11,580 --> 00:30:13,559
but we already have the entitlement so

749
00:30:13,559 --> 00:30:16,140
why does the process still crash because

750
00:30:16,140 --> 00:30:18,659
a process must be marked as debugged so

751
00:30:18,659 --> 00:30:20,520
there's a CS debug plug in the kernel

752
00:30:20,520 --> 00:30:22,200
and we can just write that to Kernel

753
00:30:22,200 --> 00:30:24,720
memory and it marks it

754
00:30:24,720 --> 00:30:27,059
so dialogue is now loaded into all

755
00:30:27,059 --> 00:30:28,980
processes that call jailbreak D on

756
00:30:28,980 --> 00:30:32,100
launch jobic D adds the Cs debug plugin

757
00:30:32,100 --> 00:30:36,059
kernel and the prices can now patch text

758
00:30:36,059 --> 00:30:37,620
however we still have an issue with

759
00:30:37,620 --> 00:30:39,659
sandbox so tweets still need to be able

760
00:30:39,659 --> 00:30:42,059
to read certain app certain directories

761
00:30:42,059 --> 00:30:44,520
from the app sandbox sandbox supports

762
00:30:44,520 --> 00:30:46,320
adding extensions via syscall if

763
00:30:46,320 --> 00:30:48,659
provided in an appropriate token this

764
00:30:48,659 --> 00:30:50,220
token can be generated outside of

765
00:30:50,220 --> 00:30:52,440
sandbox by calling sandbox extension

766
00:30:52,440 --> 00:30:54,899
issue file which can be passed by an

767
00:30:54,899 --> 00:30:56,399
environment variable to our injected

768
00:30:56,399 --> 00:30:58,140
Daemon from launch d

769
00:30:58,140 --> 00:31:00,840
the stylive then calls sandbox extension

770
00:31:00,840 --> 00:31:02,580
consumed with our token

771
00:31:02,580 --> 00:31:05,100
this then grants additional directories

772
00:31:05,100 --> 00:31:08,399
this is supposed API in iOS and Mac OS

773
00:31:08,399 --> 00:31:11,399
it's not a kernel for vulnerability or

774
00:31:11,399 --> 00:31:15,779
anything this is like a documented API

775
00:31:15,779 --> 00:31:18,360
so we add these steps to our dilib and

776
00:31:18,360 --> 00:31:20,059
now we have

777
00:31:20,059 --> 00:31:22,260
system-wide code injection all the way

778
00:31:22,260 --> 00:31:24,419
up to iPhone 7.

779
00:31:24,419 --> 00:31:26,520
and the iPhone 10.

780
00:31:26,520 --> 00:31:28,559
so what about the iPhone 10s and up

781
00:31:28,559 --> 00:31:31,679
without kxx

782
00:31:31,679 --> 00:31:34,200
so we try to load the dilem into launch

783
00:31:34,200 --> 00:31:37,440
D but the dial-up is not in trust cached

784
00:31:37,440 --> 00:31:39,120
oops

785
00:31:39,120 --> 00:31:40,080
um

786
00:31:40,080 --> 00:31:42,539
now remember pack which prevents calling

787
00:31:42,539 --> 00:31:44,640
kernel function and

788
00:31:44,640 --> 00:31:47,760
the PPL also prevents tl1 binaries from

789
00:31:47,760 --> 00:31:50,279
injecting into tl2 or three and long C

790
00:31:50,279 --> 00:31:52,260
is tl3

791
00:31:52,260 --> 00:31:54,960
remember how we passed MPD earlier where

792
00:31:54,960 --> 00:31:56,940
we debug it

793
00:31:56,940 --> 00:31:58,559
we pretty much do the same thing but

794
00:31:58,559 --> 00:32:00,659
with podicspawn and we load the code

795
00:32:00,659 --> 00:32:02,760
signatures

796
00:32:02,760 --> 00:32:04,620
there's some pitfalls to this approach

797
00:32:04,620 --> 00:32:07,200
however jumping D must be alive to debug

798
00:32:07,200 --> 00:32:09,419
launch C and if jopy D crashes that

799
00:32:09,419 --> 00:32:11,039
means launch date crashes and if launch

800
00:32:11,039 --> 00:32:12,600
D crashes that means the current will

801
00:32:12,600 --> 00:32:13,559
panic

802
00:32:13,559 --> 00:32:16,080
iOS also has this horrible habit of

803
00:32:16,080 --> 00:32:18,240
killing random Notch deep non-launchy

804
00:32:18,240 --> 00:32:20,100
processes if the device is low on memory

805
00:32:20,100 --> 00:32:22,440
so it's not as stable as loading a

806
00:32:22,440 --> 00:32:24,179
dialogue into launch d

807
00:32:24,179 --> 00:32:28,080
so can we load a dialogue

808
00:32:28,080 --> 00:32:30,240
we need to somehow demote launch these

809
00:32:30,240 --> 00:32:32,640
trust level but the trust level is

810
00:32:32,640 --> 00:32:35,460
behind PPL so jobick D can demote the

811
00:32:35,460 --> 00:32:37,380
trust level of newly spawned binaries by

812
00:32:37,380 --> 00:32:39,659
modifying its signature though we

813
00:32:39,659 --> 00:32:42,899
somehow need to respawn launch d

814
00:32:42,899 --> 00:32:45,539
in iOS 9 Apple added this feature called

815
00:32:45,539 --> 00:32:48,480
user space reboots which you can call on

816
00:32:48,480 --> 00:32:51,120
iOS 9 or on Mac OS by calling launch CTL

817
00:32:51,120 --> 00:32:53,460
reboot user space however this can run

818
00:32:53,460 --> 00:32:55,380
automatically overnight if the iOS

819
00:32:55,380 --> 00:32:57,659
device is low on RAM this essentially

820
00:32:57,659 --> 00:33:00,240
stops all demons largely then re-sex

821
00:33:00,240 --> 00:33:02,580
itself and the new launch D starts

822
00:33:02,580 --> 00:33:04,980
demons again

823
00:33:04,980 --> 00:33:07,559
so you can't inject dilebs into launch d

824
00:33:07,559 --> 00:33:09,360
as its trust level isn't demoted until

825
00:33:09,360 --> 00:33:11,820
user space reboot and we can debug

826
00:33:11,820 --> 00:33:14,039
launch d as all demons are dead during a

827
00:33:14,039 --> 00:33:17,279
user space reboot or can we

828
00:33:17,279 --> 00:33:19,320
now remember the code sign Vino cash

829
00:33:19,320 --> 00:33:21,539
that as long as we have a code signature

830
00:33:21,539 --> 00:33:24,779
attached it remains cached

831
00:33:24,779 --> 00:33:27,179
so we cache the code signature of deal

832
00:33:27,179 --> 00:33:29,279
book binaries and launch D in The V node

833
00:33:29,279 --> 00:33:31,200
by calling jailbreak D we can then

834
00:33:31,200 --> 00:33:33,360
double fork and exec to spawn a second

835
00:33:33,360 --> 00:33:36,299
jailbreak D instance which is detached

836
00:33:36,299 --> 00:33:38,519
from last year or nity so it's not a

837
00:33:38,519 --> 00:33:41,100
Daemon we can temporarily debug launch D

838
00:33:41,100 --> 00:33:43,980
to then get things kick-started we

839
00:33:43,980 --> 00:33:46,140
politely ask launch D to use a space

840
00:33:46,140 --> 00:33:48,600
reboot which kills MPD in the first

841
00:33:48,600 --> 00:33:51,179
jailbreak D instance however the second

842
00:33:51,179 --> 00:33:53,279
detached instance is still alive and

843
00:33:53,279 --> 00:33:55,679
debugging launch D and our cut

844
00:33:55,679 --> 00:33:57,840
signatures are into Cash

845
00:33:57,840 --> 00:34:00,240
so launch D then accepts itself and the

846
00:34:00,240 --> 00:34:02,159
detached jailbreak D can inject the

847
00:34:02,159 --> 00:34:04,260
environment variable into the New Logic

848
00:34:04,260 --> 00:34:06,840
D and the new launch D is now demoted

849
00:34:06,840 --> 00:34:09,300
with our dialog loaded and the second

850
00:34:09,300 --> 00:34:12,440
instance can now exit

851
00:34:13,320 --> 00:34:15,839
so now launch D is demoted by a user

852
00:34:15,839 --> 00:34:19,199
space reboot we can load a die load

853
00:34:19,199 --> 00:34:22,020
however jailbreak D is not running yet

854
00:34:22,020 --> 00:34:24,239
that's an easy fix however we just have

855
00:34:24,239 --> 00:34:26,520
the dial of telology to restart MPD

856
00:34:26,520 --> 00:34:29,699
empty debilitate and jailbreak D so so

857
00:34:29,699 --> 00:34:32,960
code signing is killed again

858
00:34:33,719 --> 00:34:36,540
so as for modifying text and arbitrary

859
00:34:36,540 --> 00:34:38,639
process we can reuse the same method

860
00:34:38,639 --> 00:34:41,460
from before where we add CSD bug to the

861
00:34:41,460 --> 00:34:43,320
kernel as you can see there's no

862
00:34:43,320 --> 00:34:45,780
difference from earlier

863
00:34:45,780 --> 00:34:47,820
to loosen sandbox restrictions we

864
00:34:47,820 --> 00:34:50,099
essentially do the same thing as earlier

865
00:34:50,099 --> 00:34:52,260
however there's an elephant in the room

866
00:34:52,260 --> 00:34:54,599
coming up next side so this only works

867
00:34:54,599 --> 00:34:58,020
up to iOS 13 so far as we forgot about

868
00:34:58,020 --> 00:35:00,420
kernel read write

869
00:35:00,420 --> 00:35:03,240
as this primitive dies on process exit

870
00:35:03,240 --> 00:35:05,940
and we just restarted launch d

871
00:35:05,940 --> 00:35:10,680
and we didn't pass it to launch the yet

872
00:35:10,680 --> 00:35:12,480
so the way we get around this is the

873
00:35:12,480 --> 00:35:14,579
jailbreak passes kernel read write to

874
00:35:14,579 --> 00:35:17,220
the detached jailbreak D instance on the

875
00:35:17,220 --> 00:35:19,560
double Fork exec and when the new launch

876
00:35:19,560 --> 00:35:22,220
D starts the detached jailbreak D passes

877
00:35:22,220 --> 00:35:24,480
passes kernel read write to launch the

878
00:35:24,480 --> 00:35:28,040
essentially like a hot potato

879
00:35:28,140 --> 00:35:30,839
and this demoted launch D can

880
00:35:30,839 --> 00:35:33,599
still user space reboot so how do we

881
00:35:33,599 --> 00:35:36,859
persist kernel read write

882
00:35:36,900 --> 00:35:38,880
so after the first user space reboot

883
00:35:38,880 --> 00:35:40,380
launched the hold on to Kernel read

884
00:35:40,380 --> 00:35:43,800
write MP debilitate and jailbreak D in

885
00:35:43,800 --> 00:35:45,660
demon form can talk to launch C to do

886
00:35:45,660 --> 00:35:46,920
kernel read write

887
00:35:46,920 --> 00:35:49,020
last you can call posix spawn on the

888
00:35:49,020 --> 00:35:50,640
next user space reboot with the exact

889
00:35:50,640 --> 00:35:52,260
attribute

890
00:35:52,260 --> 00:35:53,520
in this

891
00:35:53,520 --> 00:35:56,339
on this hook we can to cause it we can

892
00:35:56,339 --> 00:35:58,440
spawn a new temporarily detached launch

893
00:35:58,440 --> 00:36:00,540
jobic D again before lost the exact

894
00:36:00,540 --> 00:36:03,660
itself and kernel read write can then be

895
00:36:03,660 --> 00:36:05,520
passed to the new launch D once it's

896
00:36:05,520 --> 00:36:07,920
relaunched

897
00:36:07,920 --> 00:36:10,220
foreign

898
00:36:15,380 --> 00:36:19,680
up shell so we have optionally

899
00:36:19,680 --> 00:36:21,119
um remounts or read and write to the

900
00:36:21,119 --> 00:36:23,339
root file system but I think we're out

901
00:36:23,339 --> 00:36:25,619
of time or do we have

902
00:36:25,619 --> 00:36:29,240
a couple like five to ten minutes

903
00:36:29,700 --> 00:36:32,640
it's okay okay so I guess we have some

904
00:36:32,640 --> 00:36:36,300
bonus slides well so reader writes to

905
00:36:36,300 --> 00:36:39,720
the root file system before iOS 14 so

906
00:36:39,720 --> 00:36:43,020
iOS ships with a read-only root file

907
00:36:43,020 --> 00:36:44,300
system

908
00:36:44,300 --> 00:36:48,060
prior to iOS 7 you can simply remount it

909
00:36:48,060 --> 00:36:50,820
in read and write and that's it be done

910
00:36:50,820 --> 00:36:53,040
with it but um

911
00:36:53,040 --> 00:36:56,099
starting with iOS 7 and Mac OS 10 15 or

912
00:36:56,099 --> 00:36:58,440
higher they use a read-only root system

913
00:36:58,440 --> 00:37:01,800
and that is also enforced in the kernel

914
00:37:01,800 --> 00:37:03,359
General

915
00:37:03,359 --> 00:37:06,359
provide a read while old file system for

916
00:37:06,359 --> 00:37:08,640
users and tweaks and files to place on

917
00:37:08,640 --> 00:37:12,300
so how do we deal with that with up to

918
00:37:12,300 --> 00:37:16,140
iOS 112 well what the iPhone 6s this is

919
00:37:16,140 --> 00:37:17,700
where we still can patch the kernel so

920
00:37:17,700 --> 00:37:19,859
if we patch the kernel we just patch the

921
00:37:19,859 --> 00:37:21,660
mount function and then we still allow

922
00:37:21,660 --> 00:37:25,200
it to remount as read write

923
00:37:25,200 --> 00:37:27,599
uh for me anyways we can no longer patch

924
00:37:27,599 --> 00:37:29,460
the kernel what we can do is so

925
00:37:29,460 --> 00:37:31,200
basically Mount has a check to prevent

926
00:37:31,200 --> 00:37:33,180
remounting the root file system so if

927
00:37:33,180 --> 00:37:35,400
the thing that we Mount has this flag

928
00:37:35,400 --> 00:37:38,700
root FS or MNT root of as flag in the

929
00:37:38,700 --> 00:37:40,859
kernel it says okay no you cannot remote

930
00:37:40,859 --> 00:37:43,380
what we can do in the data structure of

931
00:37:43,380 --> 00:37:46,500
that node we can unset the flag call

932
00:37:46,500 --> 00:37:49,260
mount on it and then just reset the flag

933
00:37:49,260 --> 00:37:51,540
back into the kernel and then at the

934
00:37:51,540 --> 00:37:53,339
time what we call Mount

935
00:37:53,339 --> 00:37:55,140
um it's not actually the root file

936
00:37:55,140 --> 00:37:58,440
system so we bypass that check

937
00:37:58,440 --> 00:38:01,920
in iOS 11.3 they added apfs snapshots

938
00:38:01,920 --> 00:38:03,359
where the root file system is now

939
00:38:03,359 --> 00:38:05,700
mounted from a snapshot under the hood

940
00:38:05,700 --> 00:38:08,820
snapshots are used in Time Machine

941
00:38:08,820 --> 00:38:11,460
backups and they're inherently

942
00:38:11,460 --> 00:38:13,260
unmodifiable

943
00:38:13,260 --> 00:38:15,420
we need to mount the live file system

944
00:38:15,420 --> 00:38:18,119
however not the snapshots

945
00:38:18,119 --> 00:38:21,839
up to the iPhone 7 on iOS 11 we find the

946
00:38:21,839 --> 00:38:25,619
v-node for the raw disk we then follow

947
00:38:25,619 --> 00:38:28,200
the pointers like Ruby node Mount and

948
00:38:28,200 --> 00:38:29,760
then the

949
00:38:29,760 --> 00:38:30,420
um

950
00:38:30,420 --> 00:38:33,780
the v-node pointer and we unset the flag

951
00:38:33,780 --> 00:38:35,520
that specifies that it's in use or

952
00:38:35,520 --> 00:38:36,900
mounted already

953
00:38:36,900 --> 00:38:38,940
we can temporarily Mount the live file

954
00:38:38,940 --> 00:38:40,980
system to another directory rename the

955
00:38:40,980 --> 00:38:43,200
root fs and reboot

956
00:38:43,200 --> 00:38:45,060
on the subsequent reboot the live file

957
00:38:45,060 --> 00:38:48,720
system then gets mounted as read-only

958
00:38:48,720 --> 00:38:50,520
now that the live file system is mounted

959
00:38:50,520 --> 00:38:52,560
we can reapply the same technique from

960
00:38:52,560 --> 00:38:57,060
earlier where we unset the root FS flag

961
00:38:57,060 --> 00:39:00,359
in iOS 12 however they set a flag on the

962
00:39:00,359 --> 00:39:02,040
snapshot in kernel memory so we can't

963
00:39:02,040 --> 00:39:05,700
just rename it anymore or can we

964
00:39:05,700 --> 00:39:07,980
so remember how we mounted the library

965
00:39:07,980 --> 00:39:10,320
FS to another directory we get the V

966
00:39:10,320 --> 00:39:12,180
node of the temporary directory and the

967
00:39:12,180 --> 00:39:14,040
snapshot V node is on the cache V node

968
00:39:14,040 --> 00:39:15,480
list for the new mount

969
00:39:15,480 --> 00:39:18,060
this flag lifts on the v-node's v data

970
00:39:18,060 --> 00:39:20,460
which is the processing specific data we

971
00:39:20,460 --> 00:39:22,320
can simply unset the flag rename the

972
00:39:22,320 --> 00:39:24,599
root file system and reboot on the

973
00:39:24,599 --> 00:39:26,460
subsequent reboot the live file system

974
00:39:26,460 --> 00:39:29,160
then gets mounted again

975
00:39:29,160 --> 00:39:33,859
so this technique works up to iOS 14.

976
00:39:34,020 --> 00:39:37,200
however in iOS 15 they added a sneeled a

977
00:39:37,200 --> 00:39:40,200
sealed snapshot where the apfs the files

978
00:39:40,200 --> 00:39:42,480
snapshot is sealed and like it was in

979
00:39:42,480 --> 00:39:45,300
Big Sur Iris 15 ensures that the live FS

980
00:39:45,300 --> 00:39:47,339
is never mounted so we can rename the

981
00:39:47,339 --> 00:39:49,040
snapshot by the device will boot loop

982
00:39:49,040 --> 00:39:51,540
unfortunately the jailbreak app runs a

983
00:39:51,540 --> 00:39:54,000
little too late to deal with this so we

984
00:39:54,000 --> 00:39:56,160
might have to live without the read

985
00:39:56,160 --> 00:39:57,960
write real file system

986
00:39:57,960 --> 00:40:00,180
however we can simply place our files

987
00:40:00,180 --> 00:40:03,300
elsewhere such as the data volume

988
00:40:03,300 --> 00:40:06,660
and that's our bonus slides

989
00:40:06,660 --> 00:40:08,940
so at this point congrats you're now

990
00:40:08,940 --> 00:40:11,400
jailbroken you can untie your bootstrap

991
00:40:11,400 --> 00:40:13,800
with useful binaries on iOS 14 and lower

992
00:40:13,800 --> 00:40:15,540
this can go to the root file system on

993
00:40:15,540 --> 00:40:18,000
iOS 15 this can go somewhere else

994
00:40:18,000 --> 00:40:20,220
and you can call launch services to

995
00:40:20,220 --> 00:40:22,500
spawn an SSH server or to register a new

996
00:40:22,500 --> 00:40:26,720
app and your device is now jailbroken

997
00:40:32,880 --> 00:40:35,099
you can just skip this

998
00:40:35,099 --> 00:40:36,900
yeah

999
00:40:36,900 --> 00:40:40,680
I was 15 eta's son so there's tweaks

1000
00:40:40,680 --> 00:40:43,680
hello

1001
00:40:46,260 --> 00:40:49,520
so do we have any questions

1002
00:40:51,720 --> 00:40:54,618
where to start

1003
00:41:08,660 --> 00:41:11,339
the question is that all of this is very

1004
00:41:11,339 --> 00:41:13,560
good but lot of things just firstly over

1005
00:41:13,560 --> 00:41:16,680
the head being honest but if somebody

1006
00:41:16,680 --> 00:41:18,839
wants to start in the io security and

1007
00:41:18,839 --> 00:41:21,420
wants to delve into this research field

1008
00:41:21,420 --> 00:41:24,000
how can and where the person can start

1009
00:41:24,000 --> 00:41:26,640
what resources or things you know he can

1010
00:41:26,640 --> 00:41:28,859
leverage so I guess it depends on what

1011
00:41:28,859 --> 00:41:31,140
you want to do if you want to do like

1012
00:41:31,140 --> 00:41:33,180
vulnerability research I think you can

1013
00:41:33,180 --> 00:41:36,060
still do that like find parts exploit

1014
00:41:36,060 --> 00:41:38,940
box sure there's a lot of mitigations

1015
00:41:38,940 --> 00:41:41,880
and things you need to work around if

1016
00:41:41,880 --> 00:41:44,520
you want to work on jailbreak I guess

1017
00:41:44,520 --> 00:41:46,320
you're two ways so there's too much

1018
00:41:46,320 --> 00:41:47,820
going on

1019
00:41:47,820 --> 00:41:49,800
it's it's gonna be hard

1020
00:41:49,800 --> 00:41:53,040
okay but trust me I'm dreading the iOS

1021
00:41:53,040 --> 00:41:54,480
15 slides that we're gonna have to make

1022
00:41:54,480 --> 00:41:57,260
for next time

1023
00:41:57,720 --> 00:41:59,960
okay

1024
00:41:59,960 --> 00:42:03,380
any more questions

1025
00:42:10,619 --> 00:42:14,400
thanks for the talk uh I see that at

1026
00:42:14,400 --> 00:42:16,020
previous slide you wanted to say

1027
00:42:16,020 --> 00:42:18,119
something about future could you

1028
00:42:18,119 --> 00:42:21,540
elaborate on that hi this is current so

1029
00:42:21,540 --> 00:42:23,940
uh what do you think about the future of

1030
00:42:23,940 --> 00:42:27,480
jailbreaks or will they be possible or

1031
00:42:27,480 --> 00:42:31,380
one day it will stop

1032
00:42:31,380 --> 00:42:34,380
because it's hard to say like it gets

1033
00:42:34,380 --> 00:42:37,260
harder and harder and as you see all the

1034
00:42:37,260 --> 00:42:40,020
things that we can earlier we can patch

1035
00:42:40,020 --> 00:42:42,300
the kernel and be done with it and now

1036
00:42:42,300 --> 00:42:44,040
we actually need to play by the rules

1037
00:42:44,040 --> 00:42:46,640
and work around over every single

1038
00:42:46,640 --> 00:42:49,020
mitigation and there's just more and

1039
00:42:49,020 --> 00:42:51,480
more coming of course it will be easy to

1040
00:42:51,480 --> 00:42:53,579
say sure we can always find a way around

1041
00:42:53,579 --> 00:42:55,560
or at some point it's going to stop but

1042
00:42:55,560 --> 00:42:58,200
the truth is you never know right maybe

1043
00:42:58,200 --> 00:43:00,060
somebody comes up but the really clever

1044
00:43:00,060 --> 00:43:02,640
mitigation but then somebody finds a

1045
00:43:02,640 --> 00:43:06,119
bypass or doesn't you don't really know

1046
00:43:06,119 --> 00:43:10,079
and and uh you for the jailbreakers I

1047
00:43:10,079 --> 00:43:12,359
understand you always need arbitrary

1048
00:43:12,359 --> 00:43:15,119
read write so like data only attack

1049
00:43:15,119 --> 00:43:18,660
right now to to be able to bypass all

1050
00:43:18,660 --> 00:43:21,420
the mitigations uh and change the image

1051
00:43:21,420 --> 00:43:23,220
right

1052
00:43:23,220 --> 00:43:25,140
so for jailbreaking what you want to do

1053
00:43:25,140 --> 00:43:27,300
is you want to load tweaks you want to

1054
00:43:27,300 --> 00:43:29,220
customize your device you want to load

1055
00:43:29,220 --> 00:43:32,700
your own code into user process and this

1056
00:43:32,700 --> 00:43:35,579
is like the problem we started like

1057
00:43:35,579 --> 00:43:37,920
probably eight months ago or even

1058
00:43:37,920 --> 00:43:40,440
earlier with the colonel read writes and

1059
00:43:40,440 --> 00:43:42,599
we already had Colonel read rights and

1060
00:43:42,599 --> 00:43:46,140
that does not help us much to get to

1061
00:43:46,140 --> 00:43:49,319
modify uh user space code and this is

1062
00:43:49,319 --> 00:43:51,000
where all the tricky things come in

1063
00:43:51,000 --> 00:43:53,940
because if you just want to like

1064
00:43:53,940 --> 00:43:56,099
I don't know steal some data or just

1065
00:43:56,099 --> 00:43:58,380
modify kernel whatever the data thing

1066
00:43:58,380 --> 00:44:00,599
you can do but if you want to do the

1067
00:44:00,599 --> 00:44:02,460
jailbreaking for these kind of things

1068
00:44:02,460 --> 00:44:06,180
this is becoming increasingly harder

1069
00:44:06,180 --> 00:44:08,819
is there anything stronger than

1070
00:44:08,819 --> 00:44:13,099
arbitrary read write that could help you

1071
00:44:13,260 --> 00:44:15,660
can you imagine some some exploit

1072
00:44:15,660 --> 00:44:17,940
primitive that can help you better than

1073
00:44:17,940 --> 00:44:20,040
arbitrary read write yes

1074
00:44:20,040 --> 00:44:22,140
um if we have a pack bypass for example

1075
00:44:22,140 --> 00:44:24,180
then you can arbitrarily call functions

1076
00:44:24,180 --> 00:44:26,460
in the kernel or if you have a PPL

1077
00:44:26,460 --> 00:44:28,680
bypass at that point you can just

1078
00:44:28,680 --> 00:44:30,839
overwrite whatever Apple marks is read

1079
00:44:30,839 --> 00:44:33,859
only in data

1080
00:44:33,900 --> 00:44:36,240
or having uh Apple's private keys to

1081
00:44:36,240 --> 00:44:38,119
sign your code for help

1082
00:44:38,119 --> 00:44:41,660
okay and there was a research about

1083
00:44:41,660 --> 00:44:45,180
some side Channel attack leaking in the

1084
00:44:45,180 --> 00:44:50,040
back signature thing like that was it so

1085
00:44:50,040 --> 00:44:52,020
um I guess maybe we can chat afterwards

1086
00:44:52,020 --> 00:44:54,839
oh okay okay so maybe side channels will

1087
00:44:54,839 --> 00:44:57,420
help somehow

1088
00:44:57,420 --> 00:44:59,520
really good side Channel might

1089
00:44:59,520 --> 00:45:00,960
notice that you might not be able to

1090
00:45:00,960 --> 00:45:02,760
deploy so it might work for one device

1091
00:45:02,760 --> 00:45:04,260
but it's not going to be something you

1092
00:45:04,260 --> 00:45:06,240
can just review yeah it should be very

1093
00:45:06,240 --> 00:45:08,280
very stable right

1094
00:45:08,280 --> 00:45:11,359
thanks thanks a lot

1095
00:45:12,079 --> 00:45:14,880
more questions you have a lot of

1096
00:45:14,880 --> 00:45:17,280
questions well

1097
00:45:17,280 --> 00:45:17,900
yeah

1098
00:45:17,900 --> 00:45:21,540
uh very good presentation uh I wanted to

1099
00:45:21,540 --> 00:45:24,000
ask like uh in this Samsung or the Linux

1100
00:45:24,000 --> 00:45:26,160
kernels we have the hyper hypervisor

1101
00:45:26,160 --> 00:45:28,260
based uh you know security mitigations

1102
00:45:28,260 --> 00:45:29,760
like in the knocks you can see the

1103
00:45:29,760 --> 00:45:31,980
Samsung logs so is there anything like

1104
00:45:31,980 --> 00:45:34,740
that in the iOS or in the future if uh

1105
00:45:34,740 --> 00:45:37,260
anything like that will come uh there

1106
00:45:37,260 --> 00:45:39,599
was a thing in the past for iOS

1107
00:45:39,599 --> 00:45:42,540
um if I go back um kpp was originally

1108
00:45:42,540 --> 00:45:45,900
implemented as a hypervisor in a higher

1109
00:45:45,900 --> 00:45:48,420
trust level however that has time of

1110
00:45:48,420 --> 00:45:50,400
check time of use issues so it doesn't

1111
00:45:50,400 --> 00:45:52,740
really work that well and Apple has as

1112
00:45:52,740 --> 00:45:54,420
results started moving stuff into the

1113
00:45:54,420 --> 00:45:56,579
Silicon as you can see with KTR and pack

1114
00:45:56,579 --> 00:45:58,200
and PPL

1115
00:45:58,200 --> 00:46:00,839
they didn't go with it right later on

1116
00:46:00,839 --> 00:46:02,460
they didn't develop it the hyper was a

1117
00:46:02,460 --> 00:46:03,839
part of the mitigations

1118
00:46:03,839 --> 00:46:06,300
right I'm sorry can you repeat that so

1119
00:46:06,300 --> 00:46:08,400
they didn't actually go with it the

1120
00:46:08,400 --> 00:46:09,839
hyper hypervisor based security

1121
00:46:09,839 --> 00:46:12,119
mitigations right they just dropped it

1122
00:46:12,119 --> 00:46:14,760
no they are not using the hypervisor

1123
00:46:14,760 --> 00:46:17,099
anymore because it was inherently flawed

1124
00:46:17,099 --> 00:46:19,260
so they started baking the medications

1125
00:46:19,260 --> 00:46:23,280
into their silicon sure yeah thank you

1126
00:46:23,280 --> 00:46:25,740
more questions

1127
00:46:25,740 --> 00:46:28,399
anyone

1128
00:46:29,700 --> 00:46:32,339
last call

1129
00:46:32,339 --> 00:46:35,819
or some more questions then thanks again

1130
00:46:35,819 --> 00:46:38,900
thanks to you man

