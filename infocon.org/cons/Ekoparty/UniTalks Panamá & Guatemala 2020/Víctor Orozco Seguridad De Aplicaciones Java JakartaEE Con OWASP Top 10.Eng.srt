1
00:00:00,000 --> 00:00:04,529
hello and welcome to this talk that is part of copar and 2020

2
00:00:04,529 --> 00:00:09,269
 specifically security university cox in this talk today

3
00:00:09,269 --> 00:00:13,500
 We will explore some of the basic principles for securing applications in

4
00:00:13,500 --> 00:00:18,359
 specifically calls business applications which are probably and at

5
00:00:18,359 --> 00:00:24,510
 today the most common use of java as a programming language with this talk

6
00:00:24,510 --> 00:00:29,130
 you will have the opportunity to explore what are the most common mistakes

7
00:00:29,130 --> 00:00:34,290
 common when creating web and back-end applications ksenia and some tips

8
00:00:34,290 --> 00:00:38,969
 easy to solve them correctly and increase by at least one

9
00:00:38,969 --> 00:00:45,410
 minimum the security of our information systems then this time

10
00:00:45,410 --> 00:00:51,300
 we are going to confront the flame specifications that are common to many

11
00:00:51,300 --> 00:00:57,419
 frameworks which in this case are java and eventually yakarta versus some of

12
00:00:57,420 --> 00:01:02,450
 the elements of the tortel nail in which we have the list of

13
00:01:02,450 --> 00:01:07,310
 most common vulnerabilities that are exploited by attackers in most

14
00:01:07,310 --> 00:01:12,920
 of the applications that are placed on the internet however we have to have

15
00:01:12,920 --> 00:01:17,240
 quite clear that different from some other parts of the ecosystem in

16
00:01:17,240 --> 00:01:22,250
 there is no longer a generic framework to protect our applications so

17
00:01:22,250 --> 00:01:27,680
 so much so there is no concept of 360 security but rather the security of our

18
00:01:27,680 --> 00:01:32,600
 application generally depends on us making good use of the

19
00:01:32,600 --> 00:01:38,839
 programming principles with already good dependency selection principles

20
00:01:38,840 --> 00:01:42,950
 update dependencies and that we manage to balance, on the one hand, the

21
00:01:42,950 --> 00:01:47,060
 need that we are solving the business need and on the other the

22
00:01:47,060 --> 00:01:52,250
 technology taking into account that most of the time the security of a

23
00:01:52,250 --> 00:01:56,840
 system although it should be a functional or mandatory requirement

24
00:01:56,840 --> 00:02:01,940
 many companies do not consider it this way due to budgetary reasons due to

25
00:02:01,940 --> 00:02:06,470
 ignorance even and especially in ecosystems as already goes

26
00:02:06,470 --> 00:02:11,540
 Security is usually a relatively complex issue because there are n

27
00:02:11,540 --> 00:02:17,179
 ways to do the same under different frameworks then when we

28
00:02:17,180 --> 00:02:22,070
 presents us with a requirement such as encryption, digital signatures, authentication and

29
00:02:22,070 --> 00:02:26,630
 authorization to see some of us have to understand that these

30
00:02:26,630 --> 00:02:31,070
 requirements have a whole theoretical basis to implement them and that the

31
00:02:31,070 --> 00:02:36,650
 frameworks are just the tools by which we implement these

32
00:02:36,650 --> 00:02:40,459
 measures now well what I'm going to do is a

33
00:02:40,459 --> 00:02:44,950
 warning first of all these from this demo is a demo

34
00:02:44,950 --> 00:02:50,929
 100% mine in other words is what I have seen in development I am in in

35
00:02:50,930 --> 00:02:56,510
 teams you make now should take it as a starting point or as

36
00:02:56,510 --> 00:03:02,090
 the minimum that they must cover and my objective is to inform what they are

37
00:03:02,090 --> 00:03:07,340
 the most common vulnerabilities report some easy techniques for

38
00:03:07,340 --> 00:03:12,890
 prevent them and give you the responsibility to implement these

39
00:03:12,890 --> 00:03:19,109
 or even more security mechanisms now well if we analyze the

40
00:03:19,110 --> 00:03:25,670
 top-10 of waters does not really vary much year with him and

41
00:03:25,670 --> 00:03:30,410
 what they collect are the most common vulnerabilities that you

42
00:03:30,410 --> 00:03:35,840
 they will find in web applications and if they review the history of several years they will

43
00:03:35,840 --> 00:03:42,710
 they will realize that sometimes they change their position but we see again and again

44
00:03:42,710 --> 00:03:47,030
 and again the same vulnerabilities in the applications are some are

45
00:03:47,030 --> 00:03:52,550
 relatively easy to attack as for example write the injection and we will

46
00:03:52,550 --> 00:03:56,690
 do a demo if you want to know a little more about it

47
00:03:56,690 --> 00:04:02,540
 can visit directly on the site of sheets with more details of how you are

48
00:04:02,540 --> 00:04:06,829
 vulnerabilities do occur and some additional tips for you to

49
00:04:06,830 --> 00:04:12,170
 create your own security schemes in essence today we will try to

50
00:04:12,170 --> 00:04:17,180
 demonstrate how sql injection attacks occur and how we prevent them and

51
00:04:17,180 --> 00:04:21,529
 how through specs like jakarta

52
00:04:21,529 --> 00:04:27,460
 and theoretical sub and eclipse micro profile and security doublets we can

53
00:04:27,460 --> 00:04:32,799
 to these controls that allow us to at least increase confidentiality

54
00:04:32,800 --> 00:04:40,000
 integrity and availability of our applications then we continue I will

55
00:04:40,000 --> 00:04:46,349
 switch screens so we can exemplify most in live port

56
00:04:46,750 --> 00:04:51,400
 at this moment we have just gone to full screen and we are going to

57
00:04:51,400 --> 00:04:55,960
 explore the structure of this project this project in java is a project that

58
00:04:55,960 --> 00:05:01,710
 he intentionally has some bad practices at the time he is

59
00:05:01,710 --> 00:05:06,700
 implement security mechanisms and it is a business project that is quite

60
00:05:06,700 --> 00:05:10,719
 similar to what you would do with a traditional monolithic application or

61
00:05:10,720 --> 00:05:15,640
 even an application based on microservices the application starts

62
00:05:15,640 --> 00:05:19,870
 then with the definition of a model to which we are going to add some

63
00:05:19,870 --> 00:05:24,850
 decorations that are needed such as mapping from properties to

64
00:05:24,850 --> 00:05:32,340
 columns in which I have author and phrases the general idea is that through 1 rm

65
00:05:32,340 --> 00:05:39,729
 specifically 1 rm that implements the jp spec to I can

66
00:05:39,729 --> 00:05:46,849
 query a database then generally once

67
00:05:46,849 --> 00:05:50,960
 we have defined the mappings from relational databases to

68
00:05:50,960 --> 00:05:56,568
 objects in java we expose them to the rest of the stack through repositories of

69
00:05:56,569 --> 00:06:01,639
 according to the philosophy of domain driven design where we solve problems

70
00:06:01,639 --> 00:06:06,800
 splitting domains is something quite common in java in the repository us

71
00:06:06,800 --> 00:06:10,819
 then we have all the data access operations from operations

72
00:06:10,819 --> 00:06:16,940
 simple creation update search for haiti and deletion as well

73
00:06:16,940 --> 00:06:21,919
 as complex queries and here we have the first vulnerability within the

74
00:06:21,919 --> 00:06:29,690
 uas 'top ten' in this vulnerability instead of using correct mechanisms

75
00:06:29,690 --> 00:06:34,250
 to set the parameters in queries what we are doing is a

76
00:06:34,250 --> 00:06:40,340
 concatenation and although it seems very easy this is the number one error at the moment

77
00:06:40,340 --> 00:06:47,080
 to protect business applications we leave open towards sql injection

78
00:06:47,080 --> 00:06:54,248
 we are going to demonstrate then this effect additionally I also have a

79
00:06:54,249 --> 00:07:00,429
 controller and in controller are mapping operations from http

80
00:07:00,429 --> 00:07:04,958
 towards the code in java then there is lookup that will

81
00:07:04,959 --> 00:07:09,999
 correspond to the search by parameters in url creation through the

82
00:07:09,999 --> 00:07:15,249
 put verb update through post verb and deletion through

83
00:07:15,249 --> 00:07:21,219
 verb delete then they are operations and at this time the application is

84
00:07:21,219 --> 00:07:27,620
 is open to the outside so I proceed to compile

85
00:07:27,620 --> 00:07:32,479
 and once it's compiled then I'm going to run it to test its

86
00:07:32,479 --> 00:07:37,940
 operation and we are going to prepare a window with postman off screen to

87
00:07:37,940 --> 00:07:41,350
 be able to make inquiries

88
00:07:42,190 --> 00:07:47,380
 it seems like the compilation is ok so you ran it directly for

89
00:07:47,380 --> 00:07:51,270
 it finds its own port similar to what is done in

90
00:07:51,270 --> 00:07:58,159
 microservices and in about ten seconds we should already have the application

91
00:07:59,100 --> 00:08:04,290
 so the scenario I'm playing looks a lot like the

92
00:08:04,290 --> 00:08:09,390
 classic scenarios for creating applications in microservices in the

93
00:08:09,390 --> 00:08:15,180
 which we would have for example clients in android clients sp.a in angular or react

94
00:08:15,180 --> 00:08:21,470
 for our application then we say http two diagonal diagonal dots

95
00:08:21,470 --> 00:08:30,139
 localhost 80-81 which is the port where it is running and we say data

96
00:08:30,139 --> 00:08:33,009
 freixes

97
00:08:33,340 --> 00:08:39,700
 so if everything goes well when executing data freixes I should be able

98
00:08:39,700 --> 00:08:46,630
 consult the application now well if we analyze what is happening in

99
00:08:46,630 --> 00:08:52,180
 the application I have then that my repository receives a parameter from the

100
00:08:52,180 --> 00:08:58,089
 controller and right now I'm literally injecting it without considerations

101
00:08:58,090 --> 00:09:04,950
 additional in my like parameter which implies that I for example could do

102
00:09:04,950 --> 00:09:10,250
 where author is the same

103
00:09:10,250 --> 00:09:16,140
 the sql wild-card and let's test the execution

104
00:09:16,140 --> 00:09:23,640
 so I actually got an empty listing but it is an empty listing on a

105
00:09:23,640 --> 00:09:28,860
 query then select face notice that in my query originally you only have

106
00:09:28,860 --> 00:09:34,950
 author and this author is working fine to test with some

107
00:09:34,950 --> 00:09:41,370
 data then I will persist demo data which I take advantage of the url change

108
00:09:41,370 --> 00:09:47,160
 the verb that I am going to send to the server and I establish that what we are going to

109
00:09:47,160 --> 00:09:52,709
 send is an object in jason format which is basically text where I will have

110
00:09:52,710 --> 00:09:57,960
 some phrases from afar then we could have for example a phrase from

111
00:09:57,960 --> 00:10:00,620
 richard stallman

112
00:10:01,510 --> 00:10:05,880
 where say for example frames

113
00:10:08,800 --> 00:10:15,760
 join now and share the software

114
00:10:17,000 --> 00:10:24,460
 It is created, then we will create a second sentence by Victor Orozco

115
00:10:24,630 --> 00:10:31,899
 this application already works I'm going home

116
00:10:32,780 --> 00:10:39,770
 and if we test our search we have that both are already persisted within the

117
00:10:39,770 --> 00:10:44,930
 rms and the back end is already delivering them to me so that I can process the

118
00:10:44,930 --> 00:10:49,729
 data now well here it seems that the application is fine so if I send

119
00:10:49,730 --> 00:10:54,889
 for example the victor parameter and even effort

120
00:10:54,889 --> 00:11:00,040
 the wildcard directly from the url

121
00:11:02,150 --> 00:11:08,030
 I only get victor orozco but if for example I place a second

122
00:11:08,030 --> 00:11:15,370
 phrase of I prefer to md on a video

123
00:11:16,810 --> 00:11:23,140
 now I have two sentences and I can run the query all fine it seems that it is

124
00:11:23,140 --> 00:11:28,390
 The parameter is working a little weird but if it is functional and we go

125
00:11:28,390 --> 00:11:33,490
 then to the sql injection notice that one of the first errors that I

126
00:11:33,490 --> 00:11:40,630
 I have in this application is that I can arbitrarily insert

127
00:11:40,630 --> 00:11:47,600
 special characters and these special characters are not being checked in

128
00:11:47,600 --> 00:11:52,320
 no stage of implementation which implies that

129
00:11:52,320 --> 00:11:57,030
 once I know what the structure of the application is, we could

130
00:11:57,030 --> 00:12:03,760
 cause an error to introspect the database

131
00:12:03,760 --> 00:12:10,540
 I get the error and as the service is not configured to hide its

132
00:12:10,540 --> 00:12:16,569
 errors I already get what the sql is and it says well I know that it is consulting a

133
00:12:16,570 --> 00:12:21,040
 author field and if I cross that information with what has existed I know that also

134
00:12:21,040 --> 00:12:24,569
 there is a description field

135
00:12:26,080 --> 00:12:30,240
 so right now I just introspect the database

136
00:12:30,240 --> 00:12:35,830
 taking advantage of the fact that exceptions are still being thrown to the front-end and from

137
00:12:35,830 --> 00:12:41,170
 according to the structure that I already obtained in the previous query I begin to know

138
00:12:41,170 --> 00:12:46,569
 what are my old base tables generally sql injection is part

139
00:12:46,570 --> 00:12:51,040
 trial and error against systems that are not protected then we will

140
00:12:51,040 --> 00:12:56,199
 write it correctly we will then write the query again

141
00:12:56,200 --> 00:13:00,439
 about victor where he says this application already works

142
00:13:00,439 --> 00:13:06,439
 i go home and i prefer md over nvidia so i literally just go

143
00:13:06,439 --> 00:13:13,569
 complete in jp ql the query is a frame point

144
00:13:15,970 --> 00:13:18,629
 like

145
00:13:20,180 --> 00:13:27,160
 and we can pass for example I am going to do the test on emelec which is something

146
00:13:27,160 --> 00:13:34,329
 it is relatively easy to test if I am able to fill in and add a field

147
00:13:34,329 --> 00:13:38,349
 which originally was not in the query I am already being able to

148
00:13:38,350 --> 00:13:46,240
 inject via sql and notice that indeed though

149
00:13:46,240 --> 00:13:52,360
 Originally Freis was not in the query, I could add it to

150
00:13:52,360 --> 00:13:58,720
 through sql injection and if we see the log effectively the application managed

151
00:13:58,720 --> 00:14:05,410
 partial the query now what would be the correct way to do it than ever with

152
00:14:05,410 --> 00:14:12,069
 here we have and always use parameterized queries because when

153
00:14:12,070 --> 00:14:15,910
 we force through programming that the query is

154
00:14:15,910 --> 00:14:21,939
 To parameterize we have to set the parameters through methods like set

155
00:14:21,940 --> 00:14:27,490
 to enter what implies that they will be pre-analyzed and above all the most

156
00:14:27,490 --> 00:14:36,340
 important sanitized to avoid persistence and sql queries and on

157
00:14:36,340 --> 00:14:41,440
 all sql injection in case it is not what we want then we will wait

158
00:14:41,440 --> 00:14:47,710
 a bit in which this starts and without altering my query I am going to

159
00:14:47,710 --> 00:14:53,670
 compare the old logo versus the new logo

160
00:14:57,649 --> 00:15:02,899
 then he returned to the application and without changing anything, waiting for the

161
00:15:02,899 --> 00:15:06,069
 sanitization function

162
00:15:08,110 --> 00:15:12,860
 at this moment it is empty

163
00:15:12,860 --> 00:15:19,820
 but the parameter that I launch is no longer being interpreted as a

164
00:15:19,820 --> 00:15:26,690
 sql statement but is interpreted as normal text and the scheduler

165
00:15:26,690 --> 00:15:32,210
 query execution already applied skating so I can't force to query

166
00:15:32,210 --> 00:15:37,430
 on fields that do not previously belong to you then with the simple fact

167
00:15:37,430 --> 00:15:44,270
 to be used to enter sanit I made the query however I could add a

168
00:15:44,270 --> 00:15:48,710
 additional protection criterion and that is what I am accepting characters for

169
00:15:48,710 --> 00:15:52,700
 special and what I want are search criteria and we can do that

170
00:15:52,700 --> 00:15:59,330
 do through bing validation then for example the author field i

171
00:15:59,330 --> 00:16:04,640
 you could set a business rule via a regex in the

172
00:16:04,640 --> 00:16:10,720
 which I can place, for example, that an ex king is validated and that he only accepts

173
00:16:10,720 --> 00:16:16,220
 alphanumeric characters at the time I made the query then I would say

174
00:16:16,220 --> 00:16:21,920
 that I want them to be accepted from one or more characters but that

175
00:16:21,920 --> 00:16:27,649
 these characters are only alphanumeric characters and any

176
00:16:27,649 --> 00:16:34,880
 another special character has been removed by the time I do the

177
00:16:34,880 --> 00:16:41,120
 application settings then if I cast special characters no longer

178
00:16:41,120 --> 00:16:47,270
 it should even get to it rdbms but bing validation works like

179
00:16:47,270 --> 00:16:52,970
 a first defense mechanism between malicious intentions and this is

180
00:16:52,970 --> 00:16:56,750
 especially important if I am exposing to tread rest with micro

181
00:16:56,750 --> 00:17:02,120
 services because this would guarantee me that I am cleaning from the input the

182
00:17:02,120 --> 00:17:06,760
 possible sql injection queries and intents

183
00:17:06,760 --> 00:17:13,300
 at this moment it is already enabled and go from obtaining the data to avoiding the

184
00:17:13,300 --> 00:17:21,599
 interpretation of the injected school simply reject the query with a

185
00:17:21,599 --> 00:17:30,270
 error 400 and this error 400 basically what it is telling me is from the

186
00:17:30,270 --> 00:17:37,590
 when the application executes, it does not allow the arrival towards the backend

187
00:17:37,590 --> 00:17:43,860
 It seems that it was paralyzed, I'm going to go back to presentation mode

188
00:17:43,860 --> 00:17:49,740
 running it again, this application has the peculiarity that it restarts

189
00:17:49,740 --> 00:17:57,799
 the database with each execution then I proceed to open the terminal

190
00:18:02,150 --> 00:18:07,239
 because I have my terminal and ran so that everything is fine

191
00:18:07,239 --> 00:18:14,250
 then recapitulating the fact that we put the expression

192
00:18:14,250 --> 00:18:21,210
 regular now does not allow special characters to be inserted within the

193
00:18:21,210 --> 00:18:26,340
 app and I'm going to test persistence again

194
00:18:26,340 --> 00:18:33,090
 or that everything seems to be fine, he continued to receive the 400 error and here

195
00:18:33,090 --> 00:18:42,169
 for example, victor orozco persists and we could put a kermit frog

196
00:18:49,460 --> 00:18:54,240
 man I can't think of anything I don't remember anything about the muppets

197
00:18:54,240 --> 00:19:00,360
 persists again so my sql injection is already rejected from the

198
00:19:00,360 --> 00:19:05,790
 input notice that the sql logs are still generated and if now I look for the

199
00:19:05,790 --> 00:19:08,149
 Author

200
00:19:08,530 --> 00:19:11,580
 kermit the frog

201
00:19:16,070 --> 00:19:19,300
 let's block subway

202
00:19:21,760 --> 00:19:26,560
 we are going to persist because the alphanumeric forgot to include the space

203
00:19:26,560 --> 00:19:31,470
 so we have one for carmen and while armen works then

204
00:19:31,470 --> 00:19:39,149
 we get the phrase homo man but if we return to the query it is bing

205
00:19:39,149 --> 00:19:44,518
 validation the one that rejects the existence of special characters accepts

206
00:19:44,519 --> 00:19:49,529
 only the alphanumeric characters and as you saw my regex even

207
00:19:49,529 --> 00:19:55,379
 I reject the spaces and so technically I can't write a

208
00:19:55,379 --> 00:20:01,250
 query so complex as to inject a value that neck

209
00:20:01,250 --> 00:20:05,560
 so this would be a first defense mechanism that we configure

210
00:20:05,560 --> 00:20:11,570
 adequately the defenses of our application using and preventing

211
00:20:11,570 --> 00:20:17,419
 sql injection and validating the inputs with fine validation however we can

212
00:20:17,420 --> 00:20:22,070
 do more protection and as we realized at this time the app and is

213
00:20:22,070 --> 00:20:29,750
 open yet I cannot protect it against unauthorized access so I will

214
00:20:29,750 --> 00:20:35,120
 move on to protect the application using the java standard

215
00:20:35,120 --> 00:20:40,129
 inside it under the security mechanism to protect applications

216
00:20:40,130 --> 00:20:44,720
 business is a plague bolt type mechanism which means it can

217
00:20:44,720 --> 00:20:49,730
 have different authentication mechanisms and at this time by

218
00:20:49,730 --> 00:20:54,590
 For example, I decided that micro profile jay double ting is going to be the mechanism of

219
00:20:54,590 --> 00:21:00,110
 authentication I will work it from jason web tokens and my application will

220
00:21:00,110 --> 00:21:07,879
 have two roles called web and mobile once the roles are established then

221
00:21:07,880 --> 00:21:14,900
 I can granularly control who can work in my application could

222
00:21:14,900 --> 00:21:17,320
 for example

223
00:21:17,700 --> 00:21:24,400
 limit the only query role to be the mobile application or everyone

224
00:21:24,400 --> 00:21:27,710
 those users who have in the mobile role

225
00:21:27,710 --> 00:21:34,880
 while all the methods that mutate can only be worked with the role

226
00:21:34,880 --> 00:21:39,110
 web then when I said at the beginning of the presentation that the

227
00:21:39,110 --> 00:21:44,719
 java security is beige authentication role I meant that we have

228
00:21:44,720 --> 00:21:49,340
 have to combine an authorization mechanism that provides a credential

229
00:21:49,340 --> 00:21:54,889
 that credential carries the information of what role is any role belongs to a

230
00:21:54,890 --> 00:22:02,420
 user and the backend without implementing is that more complicated or schemes

231
00:22:02,420 --> 00:22:06,950
 own allows me to make these validations with what objective with the

232
00:22:06,950 --> 00:22:13,550
 goal that I can create a safe application now well for

233
00:22:13,550 --> 00:22:18,740
 then configure the validation of the touch we will use a second

234
00:22:18,740 --> 00:22:23,660
 element and this element is going to be a token provider which I have outside

235
00:22:23,660 --> 00:22:27,630
 screen one of the principles to create

236
00:22:27,630 --> 00:22:32,970
 applications with microservices is that these applications with microservices

237
00:22:32,970 --> 00:22:38,790
 are distributed and the mechanisms for generating sessions and validation by

238
00:22:38,790 --> 00:22:44,310
 authorization are not always in the same application for example here I

239
00:22:44,310 --> 00:22:50,879
 I have an app that generates security tokens and these security touches

240
00:22:50,880 --> 00:22:57,330
 instead of implementing them manually I use a secure store with encryption

241
00:22:57,330 --> 00:23:02,939
 own here for example I am using to exemplify a ring of a

242
00:23:02,940 --> 00:23:07,410
 application server in which a ring named burger is established

243
00:23:07,410 --> 00:23:12,420
 land and within burgenland I currently have two users, one

244
00:23:12,420 --> 00:23:18,390
 named ronald with web group and one named quin with mobile group

245
00:23:18,390 --> 00:23:22,950
 then once the app is public

246
00:23:22,950 --> 00:23:29,730
 I can try to get the credentials and we communicate to localhost

247
00:23:29,730 --> 00:23:34,880
 88 bar

248
00:23:34,880 --> 00:23:38,890
 microsatellite provider rest authentication

249
00:23:38,890 --> 00:23:44,470
 then for what purpose the token provider is going to perform all the

250
00:23:44,470 --> 00:23:50,140
 Necessary verifications to validate that the user exists in the ring and if

251
00:23:50,140 --> 00:23:56,830
 the user exists, he will provide me with a portable credential, that is, a jason

252
00:23:56,830 --> 00:24:02,470
 web token that carries all my login information like this is a

253
00:24:02,470 --> 00:24:06,830
 demo application your password is text 1 2 3

254
00:24:06,830 --> 00:24:13,480
 and I have to change the verb ago post then I got a tap

255
00:24:13,480 --> 00:24:19,120
 if I independently analyze the token something that will be interesting is

256
00:24:19,120 --> 00:24:25,238
 that we see the content that was generated by the provider

257
00:24:25,239 --> 00:24:30,229
 generally token providers are separate from our applications and

258
00:24:30,229 --> 00:24:35,599
 We could use a third-party provider but the important thing is that this

259
00:24:35,599 --> 00:24:41,599
 provider in addition to indicating my who is the user or the soviet in this case skin

260
00:24:41,599 --> 00:24:47,299
 It also tells me which roles it belongs to, which in this case is the mobile role and in

261
00:24:47,299 --> 00:24:53,330
 relation to my application who would have the possibility to persist data but not

262
00:24:53,330 --> 00:24:58,129
 to consult them while ronald who has the web role would have the possibility

263
00:24:58,129 --> 00:25:04,129
 to persist that data but not to perform the queries by the schema of

264
00:25:04,129 --> 00:25:10,620
 security that I have defined in addition to this within the scheme of

265
00:25:10,620 --> 00:25:16,270
 verification of digital signatures I can establish that the verification

266
00:25:16,270 --> 00:25:22,750
 automatic is done only for a particular server or gisbert and for this

267
00:25:22,750 --> 00:25:28,120
 verification is successful the ishares called at this time burger point

268
00:25:28,120 --> 00:25:34,360
 9 nick dotcom has to match my micro service and no other visuals

269
00:25:34,360 --> 00:25:40,120
 could enter with which I gain exclusivity with my application in addition to

270
00:25:40,120 --> 00:25:46,870
 this token verifiers usually work through key schemes

271
00:25:46,870 --> 00:25:54,668
 public and private and in the client that accepts the tokens I only need

272
00:25:54,669 --> 00:26:01,270
 the public party to verify the authenticity of the key and the provider

273
00:26:01,270 --> 00:26:07,418
 is the one who has the private key to generate those tokens with what I could

274
00:26:07,419 --> 00:26:12,010
 distribute the public key to miami consumers and I

275
00:26:12,010 --> 00:26:16,690
 as the credential generator keep the private part then

276
00:26:16,690 --> 00:26:22,090
 as this token generator is an external system i replace the key

277
00:26:22,090 --> 00:26:27,030
 public that I have in the example with

278
00:26:27,480 --> 00:26:33,870
 a new version in public and point p then add a mechanism of

279
00:26:33,870 --> 00:26:39,389
 verification that accepts two roles web and mobile and in a granular way I just

280
00:26:39,390 --> 00:26:44,190
 define the permissions in each of the parts of the application then I will

281
00:26:44,190 --> 00:26:50,630
 proceed to compile and see if my security mechanism is functional

282
00:26:51,490 --> 00:26:58,599
 then we execute and this takes 12 10 seconds

283
00:26:58,599 --> 00:27:00,958
 approximately

284
00:27:07,830 --> 00:27:13,879
 although it seems that the album is ready

285
00:27:13,880 --> 00:27:20,240
 then the moment my parents go to a state of protection if I

286
00:27:20,240 --> 00:27:25,580
 I check again instead of giving me empty I should already get a code

287
00:27:25,580 --> 00:27:33,949
 I do not have authorization, we are going to test and it actually tells me a 401 code in

288
00:27:33,950 --> 00:27:38,420
 which was verified that I do not carry a token and since I do not carry an identity token

289
00:27:38,420 --> 00:27:44,270
 any request that leads to freixes does not work and if for example I try

290
00:27:44,270 --> 00:27:50,119
 persist again get this code 401 again

291
00:27:50,119 --> 00:27:57,678
 what comes next let us remember that zinc again has the role we are going to

292
00:27:57,679 --> 00:28:01,719
 see it here that I forgot

293
00:28:02,029 --> 00:28:10,470
 who has the mobile role then we will have the right to only work

294
00:28:10,470 --> 00:28:15,570
 on methods that are annotated with rolls

295
00:28:15,570 --> 00:28:21,260
 to move as in this case the query methods

296
00:28:21,260 --> 00:28:27,020
 and if I try to persist with whose credential are we going to place it in

297
00:28:27,020 --> 00:28:29,650
 vigor touch

298
00:28:31,330 --> 00:28:36,399
 notice that my error changes to 400 or not because even if I authenticate

299
00:28:36,400 --> 00:28:42,310
 correctly I do not have the privileges and I did not receive authorization is prohibited

300
00:28:42,310 --> 00:28:48,750
 that resource so I have to change the user and to be able to persist

301
00:28:48,750 --> 00:28:54,830
 I then need a user with the correct role the web role

302
00:28:54,830 --> 00:28:59,149
 replacement again it's my turn

303
00:28:59,350 --> 00:29:08,270
 persist and got back to 201 but if you tried to use this same touch for

304
00:29:08,270 --> 00:29:14,470
 the role and the security scheme that I just designed

305
00:29:15,030 --> 00:29:22,440
 now I get 403 so my security is already working with roles with the

306
00:29:22,440 --> 00:29:28,050
 mechanisms of the container and if for example it tries to be the query of the

307
00:29:28,050 --> 00:29:31,340
 frog that really with kings

308
00:29:32,450 --> 00:29:36,130
 let's check if everything is ok

309
00:29:39,340 --> 00:29:42,419
 allows only

310
00:29:43,389 --> 00:29:51,639
 I already get the phrase so this is a little in a little demo of

311
00:29:51,639 --> 00:29:56,649
 the various mechanisms that exist to protect applications in java let's proceed

312
00:29:56,649 --> 00:30:00,839
 then at the end of the talk

313
00:30:05,240 --> 00:30:10,190
 During this presentation we review some of the easier mechanisms

314
00:30:10,190 --> 00:30:14,390
 to protect our app by reminding you that our goal is

315
00:30:14,390 --> 00:30:20,750
 protect it from the top 10 water errors what are these injection errors

316
00:30:20,750 --> 00:30:25,790
 sql injection dependency broken authentication and mismanagement

317
00:30:25,790 --> 00:30:32,350
 of sessions exposure of sensitive data broken access controls

318
00:30:32,350 --> 00:30:37,040
 misconfigurations are performed incorrectly and use

319
00:30:37,040 --> 00:30:42,230
 components with known vulnerabilities in the case of xml external

320
00:30:42,230 --> 00:30:48,800
 entities that would be, let's say so, reserved for all those

321
00:30:48,800 --> 00:30:54,310
 systems that are currently relying on

322
00:30:55,260 --> 00:30:58,600
 d [Music]

323
00:30:58,600 --> 00:31:06,010
 that are depending on services in those services in jacques w is the case

324
00:31:06,010 --> 00:31:10,000
 of created and site scripting would need a client part and in the case of

325
00:31:10,000 --> 00:31:13,539
 insufficient monitoring we already realized that this is not a problem

326
00:31:13,539 --> 00:31:18,929
 as long as we use the appropriate mechanisms

327
00:31:19,460 --> 00:31:26,870
 so what did we do first we demonstrated sql injection we understood

328
00:31:26,870 --> 00:31:30,469
 that common problems and causes are usually string concatenation

329
00:31:30,470 --> 00:31:35,299
 in sql which allowed me to send malicious data to applications

330
00:31:35,299 --> 00:31:39,289
 manipulate data stores that although it was simple if I managed to make them and scale

331
00:31:39,289 --> 00:31:44,840
 privileges that is suggested to avoid this error never and never with k have

332
00:31:44,840 --> 00:31:50,059
 parameters is something so simple but that at the moment that you decide

333
00:31:50,059 --> 00:31:55,668
 use mechanisms with established parameters and that are advantageous when

334
00:31:55,669 --> 00:32:02,090
 use sanitation they can avoid sql injection if they don't use a rm or

335
00:32:02,090 --> 00:32:06,470
 they want to have a manual control of how this process of sanitas and zinc is done

336
00:32:06,470 --> 00:32:11,350
 they can patch it with ip page as houas is on foot

337
00:32:11,350 --> 00:32:16,209
 and both jp a and jota of simple times support sunny singh as standard

338
00:32:16,210 --> 00:32:20,710
 by not concatenating and comfort they realized if I added beam validation to my

339
00:32:20,710 --> 00:32:27,250
 parameter that parameter no longer even reaches the repository, much less the

340
00:32:27,250 --> 00:32:32,559
 relational database manager is rejected immediately then

341
00:32:32,559 --> 00:32:38,559
 We went from having an agreement and dangerous to an agreement and sanitizing is more code for

342
00:32:38,559 --> 00:32:42,668
 of course but it is not something representative and the advantages that

343
00:32:42,669 --> 00:32:47,059
 we have is that it is an easy way to protect our application

344
00:32:47,059 --> 00:32:52,070
 In the case of sessions, one of the most common problems is that we do not have

345
00:32:52,070 --> 00:32:56,600
 policies we do not have adequate training on the platform and the

346
00:32:56,600 --> 00:33:02,149
 poor training on a platform makes us try to implement our

347
00:33:02,149 --> 00:33:07,158
 own security mechanism and that is usually a fairly common error in

348
00:33:07,159 --> 00:33:11,779
 Beginning programmers then some tips to consider

349
00:33:11,779 --> 00:33:19,039
 to preserve the sessions is that first of all we force https me in

350
00:33:19,039 --> 00:33:23,809
 the demos I used http because it is a micro service but in a

351
00:33:23,809 --> 00:33:28,668
 real scenario that micro service should be placed behind a proxy with

352
00:33:28,669 --> 00:33:34,100
 https certificates and even with an api gateway we have to use

353
00:33:34,100 --> 00:33:38,509
 adequately the life cycles of the platform and today it is already possible

354
00:33:38,509 --> 00:33:44,960
 bypass the server session cache then we can trust that by increasing

355
00:33:44,960 --> 00:33:49,759
 the server capacity by simply not having cache we improve the

356
00:33:49,759 --> 00:33:55,129
 availability of our application as noted I did not implement the

357
00:33:55,129 --> 00:34:02,570
 I manually understood the mechanism and implemented it through a

358
00:34:02,570 --> 00:34:09,739
 declarative model with annotations and above all it is not being exposed if the

359
00:34:09,739 --> 00:34:15,229
 user is valid or do not notice that the errors returned by my application

360
00:34:15,230 --> 00:34:21,980
 They were always generic 401, you just simply don't have authorization.

361
00:34:21,980 --> 00:34:27,649
 I say if the user exists if the user is missing a comma is missing an n though

362
00:34:27,649 --> 00:34:34,520
 do not believe it, there are systems that suggest that there is another user who looks like

363
00:34:34,520 --> 00:34:40,129
 what you're trying to log in and that's lousy practice then

364
00:34:40,129 --> 00:34:45,440
 How can we force https as I said we can place an app and gateway or a

365
00:34:45,440 --> 00:34:49,789
 reverse proxy and if your application is a traditional application then

366
00:34:49,789 --> 00:34:54,409
 we can also force it through the web xml file

367
00:34:54,409 --> 00:34:59,240
 where we can set patterns so that these patterns are only

368
00:34:59,240 --> 00:35:04,430
 to 2 by the server via https on this line

369
00:35:04,430 --> 00:35:09,350
 then I activate instead of implementing my own mechanism

370
00:35:09,350 --> 00:35:13,819
 authentication I knew that micro profile jet d'eau blood and it is a good mechanism

371
00:35:13,820 --> 00:35:19,070
 authentication for microservices that works in two parts a provider of

372
00:35:19,070 --> 00:35:24,350
 tokens that control a private key and a consumer that is my micro service

373
00:35:24,350 --> 00:35:29,720
 which has the public key with using the correct rules on the micro

374
00:35:29,720 --> 00:35:34,640
 service being the isr and the public key I automatically protected my

375
00:35:34,640 --> 00:35:40,910
 application use strong encryption because by standard micro encryption

376
00:35:40,910 --> 00:35:47,450
 double tea profile is a strong cipher and this enables me to

377
00:35:47,450 --> 00:35:53,419
 session is portable and if I add https to that I would be protecting in a better way

378
00:35:53,420 --> 00:35:58,340
 my application session regarding esports sensitivity

379
00:35:58,340 --> 00:36:03,080
 it is more or less along that line when we have data exposure

380
00:36:03,080 --> 00:36:07,670
 sensitive is because we are saving data without encryption we have data with

381
00:36:07,670 --> 00:36:12,830
 weak encryption or own encryption we are transmitting credentials via http and

382
00:36:12,830 --> 00:36:17,540
 we are passing full exceptions to front-end as given

383
00:36:17,540 --> 00:36:21,470
 count when the full exception was being passed because it was allowing

384
00:36:21,470 --> 00:36:26,330
 sql injection automatically started to understand the application logic

385
00:36:26,330 --> 00:36:31,549
 you could even add an additional mechanism to prevent the spread of

386
00:36:31,550 --> 00:36:38,360
 exceptions but a practical algorithm to resolve this vulnerability would be

387
00:36:38,360 --> 00:36:43,310
 identify sensitive data with a check list avoid encryption in two days i

388
00:36:43,310 --> 00:36:48,890
 use private public encryption keys were never transmitted but each

389
00:36:48,890 --> 00:36:54,109
 of the members of the architecture had both the public and private and dvd to

390
00:36:54,110 --> 00:36:58,160
 limit data storage and sensitive in general I can not be

391
00:36:58,160 --> 00:37:02,089
 victim of a vulnerability if I don't even have the data I know

392
00:37:02,090 --> 00:37:08,030
 considered delicate in the case of broke in access control is generally

393
00:37:08,030 --> 00:37:12,680
 quite similar to sensor management this occurs because it implemented solutions

394
00:37:12,680 --> 00:37:19,040
 manuals versus full frameworks the manual tends to be a problem in the

395
00:37:19,040 --> 00:37:23,420
 moment that I protect applications and if I add to that a lack of policies where

396
00:37:23,420 --> 00:37:28,430
 have roles because it is not the same authentication versus authorization this

397
00:37:28,430 --> 00:37:34,339
 it would allow me to escalate privileges as this error is corrected again we must

398
00:37:34,340 --> 00:37:40,280
 force https with some mechanism and define if we are going to work with a

399
00:37:40,280 --> 00:37:45,320
 airbag schematic like the one I showed you in the airbag source code

400
00:37:45,320 --> 00:37:49,430
 I can avoid privilege escalation because in addition to protecting

401
00:37:49,430 --> 00:37:54,410
 against unauthorized access when using roles and policies

402
00:37:54,410 --> 00:37:58,240
 correct I can then prevent a user

403
00:37:58,240 --> 00:38:03,350
 beginner access for example advanced resources or even root

404
00:38:03,350 --> 00:38:07,759
 what should I do? I should understand the general model of j

405
00:38:07,760 --> 00:38:13,730
 s that is the basis of other models such as spring security lottery r and that is the

406
00:38:13,730 --> 00:38:19,160
 which is used by default in java n 8 and micro profile and double useful

407
00:38:19,160 --> 00:38:23,390
 the annotations are the same and it is basically the same model a plug to

408
00:38:23,390 --> 00:38:27,920
 authentic ball aitor that allows me to validate from different roles in

409
00:38:27,920 --> 00:38:32,260
 different components of the architecture

410
00:38:34,350 --> 00:38:40,410
 in the same way a good idea would be for example that we protect our apis

411
00:38:40,410 --> 00:38:46,319
 against courtesy in other words that when we publish the app and we

412
00:38:46,320 --> 00:38:51,600
 Let's make sure that it can only be consulted from authorized domains

413
00:38:51,600 --> 00:38:55,589
 then a bad practice that is observed a lot when implementing

414
00:38:55,590 --> 00:39:02,010
 app and seniat is that the programmers leave the apis open so that they receive

415
00:39:02,010 --> 00:39:07,200
 requests from any source when actually an app and it should be just

416
00:39:07,200 --> 00:39:13,109
 support for a front-end application within a domain controlled by the

417
00:39:13,110 --> 00:39:18,940
 implementation as we implement it and in the form of

418
00:39:18,940 --> 00:39:25,450
 summarize a normal en point through the standard security model in java and

419
00:39:25,450 --> 00:39:30,339
 without implementing our model but depending on the facilities it gives us

420
00:39:30,339 --> 00:39:35,259
 the execution environment we then implement a in paint with privileges

421
00:39:35,260 --> 00:39:39,910
 airbag or in other words role beige authentication control and thus

422
00:39:39,910 --> 00:39:45,009
 we can control granularly and minimize the privileges that

423
00:39:45,010 --> 00:39:50,500
 can have an app according to the role that the user presents

424
00:39:50,500 --> 00:39:57,310
 Likewise, a fairly common error is that the security configuration is not

425
00:39:57,310 --> 00:40:01,900
 properly performs some things that need to be reviewed and this is already out of

426
00:40:01,900 --> 00:40:06,820
 show we should never use application server configuration

427
00:40:06,820 --> 00:40:11,200
 default because the default setting is a setting for

428
00:40:11,200 --> 00:40:17,410
 developers that facilitates the analysis, validations and execution we must

429
00:40:17,410 --> 00:40:22,690
 always consider manufacturers guidelines for putting that software on

430
00:40:22,690 --> 00:40:27,460
 production we also have to consider that not due to the fact that

431
00:40:27,460 --> 00:40:31,360
 deploy in linux we already have guaranteed security but

432
00:40:31,360 --> 00:40:35,620
 we have to improve security at the time we deploy for example

433
00:40:35,620 --> 00:40:43,109
 analyze our containers in docker to analyze different implementations

434
00:40:43,109 --> 00:40:50,430
 to analyze then how security can be improved and what we avoid in a way

435
00:40:50,430 --> 00:40:55,649
 general is to have a relaxed setup again what should be

436
00:40:55,650 --> 00:41:00,450
 our check list let's always configure the target operating system

437
00:41:00,450 --> 00:41:04,410
 we must protect and update our router in other words try to

438
00:41:04,410 --> 00:41:09,299
 always use the latest supported version of java as virtual machine and

439
00:41:09,299 --> 00:41:13,859
 of the execution environment that we are using basic things like firewall

440
00:41:13,859 --> 00:41:18,089
 here it also helps us to have good role policies' bases authentication and

441
00:41:18,089 --> 00:41:23,460
 Above all, let's avoid self-signed certificates in uncontrolled environments that

442
00:41:23,460 --> 00:41:29,369
 it is basically any environment that is not development also we have to

443
00:41:29,369 --> 00:41:33,900
 a good guy at least to reduce the attack surface would be that

444
00:41:33,900 --> 00:41:38,369
 Let's use a server type law like server jrr

445
00:41:38,369 --> 00:41:43,859
 because they do not bring the extras focused on desktop java and if what we are

446
00:41:43,859 --> 00:41:47,880
 doing is placing microservices, it also does not make sense that we have the

447
00:41:47,880 --> 00:41:52,350
 extras for aw swing printing if we don't have the

448
00:41:52,350 --> 00:41:59,279
 minimum to execute and from now on there are nine that is going to be modular this is

449
00:41:59,280 --> 00:42:04,050
 even easier and we can include only the modules we need at the moment

450
00:42:04,050 --> 00:42:10,010
 to deploy in the case of unsafe realization

451
00:42:10,010 --> 00:42:16,370
 generally the common problems and causes is that there are no validations and

452
00:42:16,370 --> 00:42:20,920
 also that we make our own frameworks and do not depend on

453
00:42:20,920 --> 00:42:25,670
 out-of-context secure implementations serialization is not

454
00:42:25,670 --> 00:42:29,630
 rather than transforming an object from a textual representation to a

455
00:42:29,630 --> 00:42:33,800
 binary representation and from a binary representation to a

456
00:42:33,800 --> 00:42:39,350
 textual representation in the case of the desired serialization this vector of

457
00:42:39,350 --> 00:42:45,560
 attack can be exploited, for example, to introduce programs such as text that

458
00:42:45,560 --> 00:42:51,320
 at the moment they are carried out, they reach memory and later could be

459
00:42:51,320 --> 00:42:57,260
 things as simple as evaluating whether it is not worth running a

460
00:42:57,260 --> 00:43:02,180
 ready and tested framework that usually have the same sanitization steps and

461
00:43:02,180 --> 00:43:06,589
 avoid at all costs that they can inject special characters more than necessary

462
00:43:06,590 --> 00:43:11,480
 as with bing validation I could place it at url level but also

463
00:43:11,480 --> 00:43:16,280
 You can place at the property level of an object and always sanitize the

464
00:43:16,280 --> 00:43:19,910
 entries are not evaluated these programs or in

465
00:43:19,910 --> 00:43:24,200
 other words that the code that is loaded in memory does not become a

466
00:43:24,200 --> 00:43:29,839
 executable program now well one that I did not comment but it is

467
00:43:29,839 --> 00:43:34,000
 relatively easy to patch is to use components with

468
00:43:34,000 --> 00:43:39,259
 known vulnerabilities basically because a common cause of this

469
00:43:39,259 --> 00:43:43,160
 vulnerability is that it is difficult to keep up with and follow up on

470
00:43:43,160 --> 00:43:48,200
 launches of our platforms in other words if there is no investment in

471
00:43:48,200 --> 00:43:53,089
 development we could be using very new or very old frameworks and not

472
00:43:53,089 --> 00:43:57,319
 be following the release notes which general suggestions are

473
00:43:57,319 --> 00:44:01,670
 they can give here always update the application server or the micro

474
00:44:01,670 --> 00:44:05,900
 framework according to the launch calendar subscribe to the mailing

475
00:44:05,900 --> 00:44:10,339
 list and forums and above all they can use static analysis services

476
00:44:10,339 --> 00:44:15,769
 such as sonar or services of type git cox security and bean trade either with premises

477
00:44:15,769 --> 00:44:20,500
 or in the cloud when you activate these services it is analyzed

478
00:44:20,500 --> 00:44:25,069
 automatically the status of your dependencies and if they have any

479
00:44:25,069 --> 00:44:30,769
 reported vulnerability github git lab and even integration servers

480
00:44:30,769 --> 00:44:33,348
 continue you can let them know that for example I

481
00:44:33,349 --> 00:44:39,619
 had a dangerous dependency that has a security and automatically

482
00:44:39,619 --> 00:44:45,769
 generate the pull request to make the library from 5.7 to 7.9 is a resource

483
00:44:45,769 --> 00:44:50,720
 easy to integrate know and place them within your projects

484
00:44:50,720 --> 00:44:55,879
 so what were we trying to show we combined that originally

485
00:44:55,880 --> 00:45:00,650
 we had broken outs because we did not have authentication we did not have access control

486
00:45:00,650 --> 00:45:06,230
 and there was security mix configuration because basically it was an open path to

487
00:45:06,230 --> 00:45:09,619
 Sometimes there is just no security because people think they are not going to

488
00:45:09,619 --> 00:45:14,900
 attack and it is especially serious today in 2020 because we are basically in a

489
00:45:14,900 --> 00:45:19,280
 world of rich plugins everyone wants to make applications with react

490
00:45:19,280 --> 00:45:24,160
 konex belges combo and the bacanes that we offer to these applications

491
00:45:24,160 --> 00:45:29,720
 should be safe because although there are validations in the ritz client those

492
00:45:29,720 --> 00:45:34,009
 validations are honestly not meaningful they are easy to skip if

493
00:45:34,010 --> 00:45:39,109
 we reverse engineer the mini cado code in javascript and it's even more

494
00:45:39,109 --> 00:45:44,540
 important that the package is always protected suggestions check

495
00:45:44,540 --> 00:45:48,710
 any auto generated code any tutorial that is downloaded on the internet or

496
00:45:48,710 --> 00:45:53,660
 copy from this cover flow and program in night out mode or in other words and

497
00:45:53,660 --> 00:45:57,440
 as in the firewalls close all your apis

498
00:45:57,440 --> 00:46:02,780
 are closed then if they start to open only the minimum necessary so that

499
00:46:02,780 --> 00:46:08,839
 your application works so we had a demo and if you want to see this

500
00:46:08,839 --> 00:46:13,670
 more detailed code can find the token provider amy gateway is a

501
00:46:13,670 --> 00:46:17,089
 demo token provider obviously has demo keys

502
00:46:17,089 --> 00:46:23,240
 and the app and protected in its final state inside also michetti then by

503
00:46:23,240 --> 00:46:27,589
 It has been an honor for me to participate in this series of university talks.

504
00:46:27,589 --> 00:46:31,578
 I appreciate your attention if you made it to the end and sincerely I am

505
00:46:31,579 --> 00:46:34,910
 speaking from the past because many of these talks were produced with

506
00:46:34,910 --> 00:46:40,250
 before then greetings until the future and remember it is just as

507
00:46:40,250 --> 00:46:44,510
 the availability of a system is important that your confidentiality and

508
00:46:44,510 --> 00:46:50,380
 integrity then you can follow me on twitter and see you until next time

