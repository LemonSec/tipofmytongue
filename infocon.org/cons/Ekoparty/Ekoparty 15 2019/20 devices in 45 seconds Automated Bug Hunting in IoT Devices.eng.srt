1
00:00:00,030 --> 00:00:08,178
Ryan Spurs Sophie Antoine 20 devices in

2
00:00:04,890 --> 00:00:11,518
45 seconds how to make back hunting an

3
00:00:08,179 --> 00:00:13,740
IOT devices we cover program analysis

4
00:00:11,519 --> 00:00:15,509
for vulnerability discovery demo

5
00:00:13,740 --> 00:00:18,690
straining how to find new and

6
00:00:15,509 --> 00:00:21,779
prayerfully now backs across 20 I Oh T

7
00:00:18,690 --> 00:00:24,029
devices and he'll turning arguments are

8
00:00:21,779 --> 00:00:26,340
research attendees will receive an

9
00:00:24,029 --> 00:00:28,740
understanding of challenge of analyzing

10
00:00:26,340 --> 00:00:40,379
finger and backless patterns for memory

11
00:00:28,740 --> 00:00:44,420
corruption much for having me today

12
00:00:40,379 --> 00:00:47,010
hello we'll try that again

13
00:00:44,420 --> 00:00:49,590
I'm excited to be here today and I'm

14
00:00:47,010 --> 00:00:52,829
gonna be speaking about a theme hacking

15
00:00:49,590 --> 00:00:54,960
20 devices in 45 seconds but that's just

16
00:00:52,829 --> 00:00:58,050
meant to be a flashy term and we'll do

17
00:00:54,960 --> 00:01:00,390
it don't worry but it's really about how

18
00:00:58,050 --> 00:01:02,699
do we automate a bug hunting in IOT

19
00:01:00,390 --> 00:01:07,110
devices both to make our lives easier as

20
00:01:02,699 --> 00:01:08,729
attackers and defenders today we're

21
00:01:07,110 --> 00:01:11,010
gonna talk through the fundamentals of

22
00:01:08,729 --> 00:01:12,689
program analysis as it applies for

23
00:01:11,010 --> 00:01:14,640
vulnerability discovery I'll give a

24
00:01:12,689 --> 00:01:16,979
little background on past work in the

25
00:01:14,640 --> 00:01:18,869
field motivate why we want to use

26
00:01:16,979 --> 00:01:21,600
automation instead of drinking a lot of

27
00:01:18,869 --> 00:01:24,570
energy drinks and sitting around for 12

28
00:01:21,600 --> 00:01:26,250
hours a day talk about some of the road

29
00:01:24,570 --> 00:01:29,158
bumps some of the challenges in

30
00:01:26,250 --> 00:01:31,680
automating analysis and talk about why

31
00:01:29,159 --> 00:01:34,979
that's different in IOT systems from

32
00:01:31,680 --> 00:01:36,930
other systems then we'll go through how

33
00:01:34,979 --> 00:01:38,729
we've done some work to improve the

34
00:01:36,930 --> 00:01:40,890
publicly available tools in this space

35
00:01:38,729 --> 00:01:42,899
and then actually let's do the 20

36
00:01:40,890 --> 00:01:45,720
devices in 45 seconds then we'll apply

37
00:01:42,899 --> 00:01:49,290
the tooling to find some bugs we'll go

38
00:01:45,720 --> 00:01:52,259
through those and talk through them so

39
00:01:49,290 --> 00:01:54,270
as background for myself I'm a low-level

40
00:01:52,259 --> 00:01:57,990
hardware and firmware our reverse

41
00:01:54,270 --> 00:02:00,990
engineer my focus for a long time was on

42
00:01:57,990 --> 00:02:03,149
802 15 4 and ZigBee systems I maintained

43
00:02:00,990 --> 00:02:05,729
some of the open source frameworks that

44
00:02:03,149 --> 00:02:07,350
people used to assess those so don't

45
00:02:05,729 --> 00:02:10,378
send me any bug tickets here we'll all

46
00:02:07,350 --> 00:02:12,000
be drinking tonight but but later I've

47
00:02:10,378 --> 00:02:13,500
had the pleasure of speaking a number of

48
00:02:12,000 --> 00:02:15,000
conferences but I'm super excited

49
00:02:13,500 --> 00:02:17,340
to be here this has been one of the most

50
00:02:15,000 --> 00:02:19,290
fun conferences so far and unless you

51
00:02:17,340 --> 00:02:22,940
guys throw a lot of tomatoes at me it

52
00:02:19,290 --> 00:02:28,170
will continue to be a fun conference I

53
00:02:22,940 --> 00:02:38,670
am the CEO and feel free to flow I can

54
00:02:28,170 --> 00:02:40,649
dodge no comprendo espanol so I'm the

55
00:02:38,670 --> 00:02:43,170
CEO and the lead of firmware analysis of

56
00:02:40,650 --> 00:02:45,810
the company called pilot security we do

57
00:02:43,170 --> 00:02:48,559
automated firmware analysis to find bugs

58
00:02:45,810 --> 00:02:50,610
in these types of devices and I'm also

59
00:02:48,560 --> 00:02:51,930
privileged to be one of the partners at

60
00:02:50,610 --> 00:02:54,530
river loop security where we do

61
00:02:51,930 --> 00:02:58,320
consulting services along these lines

62
00:02:54,530 --> 00:03:01,290
Sofia my speak Sofia

63
00:02:58,320 --> 00:03:05,340
who's not able to be prickly here today

64
00:03:01,290 --> 00:03:06,810
she apologizes is my co-author on this

65
00:03:05,340 --> 00:03:09,600
presentation and did a lot of the work

66
00:03:06,810 --> 00:03:12,150
for it so credit to her her thesis was

67
00:03:09,600 --> 00:03:14,850
in exploiting CPU side channels back

68
00:03:12,150 --> 00:03:17,130
before we knew that spectra in meltdown

69
00:03:14,850 --> 00:03:20,489
were big things and she leads our

70
00:03:17,130 --> 00:03:22,650
automated analysis at pilot security so

71
00:03:20,489 --> 00:03:25,049
today let's talk through and sort of put

72
00:03:22,650 --> 00:03:26,940
this in context in these type of

73
00:03:25,049 --> 00:03:28,830
embedded devices there's the hardware

74
00:03:26,940 --> 00:03:31,140
the physical plastic casing that looks

75
00:03:28,830 --> 00:03:32,850
nice and shiny the circuit boards and

76
00:03:31,140 --> 00:03:34,829
all of that and there's the firmware

77
00:03:32,850 --> 00:03:37,739
whether that's the code that the vendor

78
00:03:34,830 --> 00:03:39,510
wrote or libraries that they got or any

79
00:03:37,739 --> 00:03:42,180
other code that's gluing together the

80
00:03:39,510 --> 00:03:45,239
actual logic there and then last but not

81
00:03:42,180 --> 00:03:47,190
least often there's a back-end right

82
00:03:45,239 --> 00:03:48,930
these are Internet of Things devices

83
00:03:47,190 --> 00:03:51,510
after the fact they are connected to

84
00:03:48,930 --> 00:03:54,780
something maybe that's providing a user

85
00:03:51,510 --> 00:03:56,548
interface driving a mobile app etc but

86
00:03:54,780 --> 00:04:00,600
today we're gonna be focusing on the

87
00:03:56,549 --> 00:04:02,970
firmware so how do people deal with this

88
00:04:00,600 --> 00:04:04,620
today and many of you know these and

89
00:04:02,970 --> 00:04:06,959
know many more approaches than we have

90
00:04:04,620 --> 00:04:08,579
time to go through so first of all one

91
00:04:06,959 --> 00:04:11,160
approach is to network scan the device

92
00:04:08,579 --> 00:04:12,870
treat it like a network asset we're

93
00:04:11,160 --> 00:04:14,450
gonna end map it we're gonna start going

94
00:04:12,870 --> 00:04:17,250
through the services that are listening

95
00:04:14,450 --> 00:04:20,310
well although when you google for

96
00:04:17,250 --> 00:04:22,800
network pen testing and find stock art

97
00:04:20,310 --> 00:04:24,960
they appear parently think that all you

98
00:04:22,800 --> 00:04:27,780
have to do is put a laptop on top of a

99
00:04:24,960 --> 00:04:30,090
box of donuts it's much more calm

100
00:04:27,780 --> 00:04:32,309
located than that right especially on

101
00:04:30,090 --> 00:04:34,590
embedded we're often hampered by

102
00:04:32,310 --> 00:04:37,320
unstable network services that fall over

103
00:04:34,590 --> 00:04:40,169
when we scan them and then we're also

104
00:04:37,320 --> 00:04:42,810
limited at just looking at the exposed

105
00:04:40,169 --> 00:04:46,139
network services we missed all of these

106
00:04:42,810 --> 00:04:48,360
other important attack vectors including

107
00:04:46,139 --> 00:04:50,310
a lot of these devices call out to their

108
00:04:48,360 --> 00:04:52,320
servers instead of in right by the time

109
00:04:50,310 --> 00:04:55,230
you take an IOT device and put it inside

110
00:04:52,320 --> 00:04:57,030
an airplane fuselage it's no longer

111
00:04:55,230 --> 00:05:00,020
something that has all of its ports

112
00:04:57,030 --> 00:05:02,340
available for you to easily assess

113
00:05:00,020 --> 00:05:04,260
another approach is doing manual

114
00:05:02,340 --> 00:05:05,880
firmware analysis there's great

115
00:05:04,260 --> 00:05:07,830
open-source tools I'm sure many of you

116
00:05:05,880 --> 00:05:10,020
have used some things like bin wok that

117
00:05:07,830 --> 00:05:12,539
can help you extract out of a firmware

118
00:05:10,020 --> 00:05:14,280
image a file system and then we'll go

119
00:05:12,540 --> 00:05:16,710
through those and look for outdated

120
00:05:14,280 --> 00:05:19,109
versions hard-coded passwords all the

121
00:05:16,710 --> 00:05:20,940
stuff that you find and probably pick

122
00:05:19,110 --> 00:05:23,700
out some binaries as well to reverse

123
00:05:20,940 --> 00:05:26,310
engineer but as some of you may have

124
00:05:23,700 --> 00:05:28,200
found out or deal with on a daily basis

125
00:05:26,310 --> 00:05:30,180
for some of us right this can quickly

126
00:05:28,200 --> 00:05:32,430
become a lot more complex somebody

127
00:05:30,180 --> 00:05:34,979
changed the file system binary format a

128
00:05:32,430 --> 00:05:37,110
little bit there's a lot of important

129
00:05:34,979 --> 00:05:38,969
items outside the file system that you

130
00:05:37,110 --> 00:05:42,060
need to look at in the kernel and the

131
00:05:38,970 --> 00:05:44,130
bootloader and then outdated libraries

132
00:05:42,060 --> 00:05:45,720
are often statically compiled in and

133
00:05:44,130 --> 00:05:47,580
it's not gonna just stick out like a

134
00:05:45,720 --> 00:05:48,930
sore thumb alright so there's a lot of

135
00:05:47,580 --> 00:05:52,229
struggles here but it's still an

136
00:05:48,930 --> 00:05:54,240
important tool and lastly we could

137
00:05:52,229 --> 00:05:55,830
physically probe the device right get

138
00:05:54,240 --> 00:05:58,979
out the soldering iron maybe use some

139
00:05:55,830 --> 00:06:02,219
open-source tools JTAG and new things to

140
00:05:58,979 --> 00:06:04,530
find serial ports maybe listen to the

141
00:06:02,220 --> 00:06:06,690
radio frequencies interact with those

142
00:06:04,530 --> 00:06:08,789
but number one obviously we need

143
00:06:06,690 --> 00:06:10,650
physical devices right as you saw some

144
00:06:08,789 --> 00:06:14,070
of the talks yesterday and earlier today

145
00:06:10,650 --> 00:06:15,960
we're using this is the basic low cost

146
00:06:14,070 --> 00:06:18,090
tools the things that you may deal with

147
00:06:15,960 --> 00:06:20,280
you know good fed app emote yardstick

148
00:06:18,090 --> 00:06:23,159
they're great for what they were made to

149
00:06:20,280 --> 00:06:25,469
do but quickly you know somewhat

150
00:06:23,160 --> 00:06:28,740
different devices or security on the

151
00:06:25,470 --> 00:06:31,440
devices can compose to sort of break

152
00:06:28,740 --> 00:06:33,390
those hacker tools and we can only test

153
00:06:31,440 --> 00:06:36,030
again some avenues right these expose

154
00:06:33,390 --> 00:06:37,469
debug poised so today we're not going to

155
00:06:36,030 --> 00:06:39,510
be talking about any of those right

156
00:06:37,470 --> 00:06:41,330
we're going to be talking about how do

157
00:06:39,510 --> 00:06:44,560
we use programming

158
00:06:41,330 --> 00:06:47,270
to help us go through the firmware so

159
00:06:44,560 --> 00:06:48,800
first of all to give some foundations

160
00:06:47,270 --> 00:06:52,460
here I want to talk about bug class

161
00:06:48,800 --> 00:06:54,979
patterns the good news is firmware on

162
00:06:52,460 --> 00:06:58,940
IOT devices has the problem of the early

163
00:06:54,979 --> 00:07:00,919
2000s right these do not have the modern

164
00:06:58,940 --> 00:07:04,069
exploit mitigations that Adrienne talked

165
00:07:00,919 --> 00:07:05,900
about there's no you know they're full

166
00:07:04,069 --> 00:07:08,900
of stack buffer overflows we'll get to

167
00:07:05,900 --> 00:07:11,719
plenty of those later constant size

168
00:07:08,900 --> 00:07:13,609
buffers unchecked boundaries basically

169
00:07:11,720 --> 00:07:15,379
we should be happy if we're wearing in a

170
00:07:13,610 --> 00:07:17,780
black hat right there's limitless

171
00:07:15,379 --> 00:07:21,289
possibilities some things we may look

172
00:07:17,780 --> 00:07:23,119
for our indicators like stir coffee mem

173
00:07:21,289 --> 00:07:25,250
copy things that could be used in a

174
00:07:23,120 --> 00:07:28,219
vulnerable way but those alone are not

175
00:07:25,250 --> 00:07:30,169
enough to be an issue right those could

176
00:07:28,219 --> 00:07:33,590
be used totally safely copying a

177
00:07:30,169 --> 00:07:35,840
constant and then of course we have

178
00:07:33,590 --> 00:07:38,179
coming in externally provided input and

179
00:07:35,840 --> 00:07:41,810
whether or not it has bounds checking is

180
00:07:38,180 --> 00:07:44,150
another indicator so the objective of

181
00:07:41,810 --> 00:07:46,900
taking bug class patterns into program

182
00:07:44,150 --> 00:07:49,159
analysis is to encode these in a way

183
00:07:46,900 --> 00:07:51,138
encode our knowledge as reverse

184
00:07:49,159 --> 00:07:53,060
engineers and vulnerability researchers

185
00:07:51,139 --> 00:07:55,699
into something that the computer can do

186
00:07:53,060 --> 00:07:57,770
for us so all of those bugs that we

187
00:07:55,699 --> 00:08:00,889
talked about right are really I would

188
00:07:57,770 --> 00:08:04,068
argue to operations they're reads and

189
00:08:00,889 --> 00:08:06,830
their rights and if we deconstruct these

190
00:08:04,069 --> 00:08:09,529
bugs if we take them down to a level of

191
00:08:06,830 --> 00:08:11,359
abstraction we can then express them in

192
00:08:09,529 --> 00:08:13,789
terms of reads and writes put together

193
00:08:11,360 --> 00:08:16,969
and if we do that successfully which is

194
00:08:13,789 --> 00:08:19,279
not always easy we can express these

195
00:08:16,969 --> 00:08:22,190
vulnerable neural properties of a

196
00:08:19,279 --> 00:08:24,110
program in an intermediate language so

197
00:08:22,190 --> 00:08:27,979
we can fully embrace the weirdness of

198
00:08:24,110 --> 00:08:30,710
these bugs so let's take a look at an

199
00:08:27,979 --> 00:08:34,698
example here right we have you know your

200
00:08:30,710 --> 00:08:37,519
intro to hacking main function where we

201
00:08:34,698 --> 00:08:39,588
have a constant size buffer right that's

202
00:08:37,519 --> 00:08:42,560
been allocated on the stack we're gonna

203
00:08:39,589 --> 00:08:45,920
read in some pleasantly unbounded user

204
00:08:42,559 --> 00:08:47,959
input and we're going to write that to

205
00:08:45,920 --> 00:08:51,229
the stack using in this case store a

206
00:08:47,959 --> 00:08:53,719
copy now for the sake of doing this at

207
00:08:51,230 --> 00:08:55,190
scale one thing that most people doing

208
00:08:53,720 --> 00:08:57,640
program analysis do is

209
00:08:55,190 --> 00:09:00,880
they abstract away the details inside

210
00:08:57,640 --> 00:09:03,290
you know Lipsy functions like stir copy

211
00:09:00,880 --> 00:09:06,860
so that we don't have to dig through all

212
00:09:03,290 --> 00:09:08,390
of that that assembly code and by though

213
00:09:06,860 --> 00:09:10,190
you know by the time we've gotten to

214
00:09:08,390 --> 00:09:13,270
step three we've written the input to

215
00:09:10,190 --> 00:09:15,470
the stack we get our buffer overflow and

216
00:09:13,270 --> 00:09:17,420
you know this is the type of thing that

217
00:09:15,470 --> 00:09:20,920
we want to find automatically at scale

218
00:09:17,420 --> 00:09:24,079
especially when it's this simple so

219
00:09:20,920 --> 00:09:28,250
let's define briefly what sources and

220
00:09:24,080 --> 00:09:30,460
sinks are first of all a source is where

221
00:09:28,250 --> 00:09:33,320
external input comes into the program

222
00:09:30,460 --> 00:09:35,420
what is this operation that we know we

223
00:09:33,320 --> 00:09:37,580
can control or an attacker can control

224
00:09:35,420 --> 00:09:38,959
like receiving Network data right this

225
00:09:37,580 --> 00:09:41,690
is the receive function the read

226
00:09:38,960 --> 00:09:43,490
function whatever it is and this is

227
00:09:41,690 --> 00:09:48,260
important because it helps us filter out

228
00:09:43,490 --> 00:09:49,970
unreachable bugs secondly the definition

229
00:09:48,260 --> 00:09:51,860
of a sink is where does the external

230
00:09:49,970 --> 00:09:54,650
input get processed or written to memory

231
00:09:51,860 --> 00:09:56,720
where does that write happen in this

232
00:09:54,650 --> 00:10:01,240
case we're going to use these two also

233
00:09:56,720 --> 00:10:01,240
filter out unreachable vulnerabilities

234
00:10:01,450 --> 00:10:06,500
so before we go any further there's some

235
00:10:04,280 --> 00:10:08,900
great past work that I would not be

236
00:10:06,500 --> 00:10:10,400
doing it justice to skip over so first

237
00:10:08,900 --> 00:10:12,530
of all from those you saw the title of

238
00:10:10,400 --> 00:10:15,620
the talk it is deliberately a play on

239
00:10:12,530 --> 00:10:18,260
this talk from Def Con 22 that a lot of

240
00:10:15,620 --> 00:10:21,170
our friends gave called hack all the

241
00:10:18,260 --> 00:10:23,510
things 20 devices in 45 minutes and they

242
00:10:21,170 --> 00:10:26,900
like I have a counter counting down from

243
00:10:23,510 --> 00:10:29,630
45 minutes but I'm not going to I you

244
00:10:26,900 --> 00:10:32,060
know neither talk took only 45 minutes

245
00:10:29,630 --> 00:10:33,980
to find all the bugs what I was going

246
00:10:32,060 --> 00:10:35,930
for today is showing you how we can

247
00:10:33,980 --> 00:10:38,750
automate a lot of this work so instead

248
00:10:35,930 --> 00:10:40,579
of weeks or months of analysis how can

249
00:10:38,750 --> 00:10:44,230
we show how the computer can do the

250
00:10:40,580 --> 00:10:46,640
heavy work for us and run very quickly

251
00:10:44,230 --> 00:10:49,040
there's also a number of good resources

252
00:10:46,640 --> 00:10:50,689
on program analysis for those of you who

253
00:10:49,040 --> 00:10:53,329
want to follow up and read more about

254
00:10:50,690 --> 00:10:54,470
this these are some references that you

255
00:10:53,330 --> 00:10:56,780
may find interesting

256
00:10:54,470 --> 00:10:59,360
everything from role forces recon talk

257
00:10:56,780 --> 00:11:01,069
to a number that Sophia have given to if

258
00:10:59,360 --> 00:11:03,589
you want to pour through a master's

259
00:11:01,070 --> 00:11:07,270
thesis Shawn healings thesis has some

260
00:11:03,589 --> 00:11:07,270
great material on this

261
00:11:07,459 --> 00:11:11,540
then there's of course a lot of tools

262
00:11:08,959 --> 00:11:14,420
like we've probably all used right on

263
00:11:11,540 --> 00:11:16,849
the left hand side is source code

264
00:11:14,420 --> 00:11:19,429
analysis tools anything from a source

265
00:11:16,850 --> 00:11:22,639
code analyzer to things that can do

266
00:11:19,429 --> 00:11:25,999
fuzzing based on source code may be

267
00:11:22,639 --> 00:11:27,559
things like LLVM compiler that I'll talk

268
00:11:25,999 --> 00:11:30,019
more about in a second that can look for

269
00:11:27,559 --> 00:11:32,240
bugs and then on the right binary

270
00:11:30,019 --> 00:11:34,699
analysis tooling whether that's dynamic

271
00:11:32,240 --> 00:11:36,589
or static so there are a lot of tools

272
00:11:34,699 --> 00:11:40,219
out there and let's drill in a little

273
00:11:36,589 --> 00:11:43,730
bit first to how compilers work as

274
00:11:40,220 --> 00:11:46,369
program analysis tools first of all LLVM

275
00:11:43,730 --> 00:11:48,829
lifting via clang is great and you know

276
00:11:46,369 --> 00:11:50,660
from the developers side if any of us

277
00:11:48,829 --> 00:11:52,399
are running product security programs we

278
00:11:50,660 --> 00:11:56,600
probably should be looking at how can we

279
00:11:52,399 --> 00:11:58,819
get our teams to use this right if you

280
00:11:56,600 --> 00:12:01,309
start compiling through claying there's

281
00:11:58,819 --> 00:12:02,599
a lot of built-in security checks that

282
00:12:01,309 --> 00:12:05,629
can run on the intermediate

283
00:12:02,600 --> 00:12:08,389
representation to find a lot of things

284
00:12:05,629 --> 00:12:10,339
however is a compiler as reverse

285
00:12:08,389 --> 00:12:13,129
engineers who just have the binaries we

286
00:12:10,339 --> 00:12:15,799
need a lifter so it's maybe not the best

287
00:12:13,129 --> 00:12:18,769
tool for looking at binaries some tools

288
00:12:15,799 --> 00:12:20,929
like maxima have worked to lift from

289
00:12:18,769 --> 00:12:24,559
compiled binaries into this intermediate

290
00:12:20,929 --> 00:12:26,600
representation but unfortunately this

291
00:12:24,559 --> 00:12:28,670
often produces a massive output you may

292
00:12:26,600 --> 00:12:30,920
not get all the benefit right again it's

293
00:12:28,670 --> 00:12:33,079
a compiler it expects to have rich type

294
00:12:30,920 --> 00:12:35,899
information that we don't have when

295
00:12:33,079 --> 00:12:38,689
we're coming from the assembly code so

296
00:12:35,899 --> 00:12:41,709
using tools like binary ninja can help

297
00:12:38,689 --> 00:12:44,029
lift from assembly to a intermediate

298
00:12:41,709 --> 00:12:46,998
representation similar but different

299
00:12:44,029 --> 00:12:48,679
from LLVM when we work on this

300
00:12:46,999 --> 00:12:51,619
intermediate language and sometimes

301
00:12:48,679 --> 00:12:53,499
you'll hear me talk about it as ml IL or

302
00:12:51,619 --> 00:12:57,709
medium level intermediate intermediate

303
00:12:53,499 --> 00:13:00,049
language in this talk we can run our

304
00:12:57,709 --> 00:13:02,599
analysis there there's also a number of

305
00:13:00,049 --> 00:13:04,579
other tools Ida Deidre they have

306
00:13:02,600 --> 00:13:08,959
different limitations from the price to

307
00:13:04,579 --> 00:13:10,969
the UI to where they're made to you know

308
00:13:08,959 --> 00:13:14,209
the Ghidorah for example doesn't have a

309
00:13:10,970 --> 00:13:16,040
native single static assignment form

310
00:13:14,209 --> 00:13:17,649
which can be really helpful for program

311
00:13:16,040 --> 00:13:20,990
analysis

312
00:13:17,649 --> 00:13:23,480
so why automation

313
00:13:20,990 --> 00:13:25,220
well we all enjoy keeping our jobs and

314
00:13:23,480 --> 00:13:28,910
probably many of us by billing by the

315
00:13:25,220 --> 00:13:30,980
hour however that won't scale right so

316
00:13:28,910 --> 00:13:33,140
we have some source code analysis tools

317
00:13:30,980 --> 00:13:35,930
today they're good at finding issues

318
00:13:33,140 --> 00:13:37,850
maybe like command injection but it's

319
00:13:35,930 --> 00:13:40,339
tougher especially in embedded devices

320
00:13:37,850 --> 00:13:42,890
to find two other important types of

321
00:13:40,340 --> 00:13:44,870
issues first of all when a binary

322
00:13:42,890 --> 00:13:47,270
library that somebody has compiled in

323
00:13:44,870 --> 00:13:50,210
introduces the issues think of a

324
00:13:47,270 --> 00:13:52,040
hardware abstraction layer or library

325
00:13:50,210 --> 00:13:53,780
that's given to you by a chip vendor

326
00:13:52,040 --> 00:13:55,400
you're going to go ahead and compile

327
00:13:53,780 --> 00:13:57,770
this in you may not have the source code

328
00:13:55,400 --> 00:14:00,490
but you still want to analyze it to see

329
00:13:57,770 --> 00:14:02,930
what types of issues it may introduce

330
00:14:00,490 --> 00:14:04,760
likewise there's a lot of issues that

331
00:14:02,930 --> 00:14:08,000
may get introduced during compilation

332
00:14:04,760 --> 00:14:09,770
right the classic example here is memset

333
00:14:08,000 --> 00:14:11,900
you're clearing out your crypto buffer

334
00:14:09,770 --> 00:14:14,210
your zero izing that out and the

335
00:14:11,900 --> 00:14:16,970
compiler says hey you don't need that

336
00:14:14,210 --> 00:14:18,260
right why bother and so this is

337
00:14:16,970 --> 00:14:20,540
something that we can see when we

338
00:14:18,260 --> 00:14:23,840
analyze the binary but doesn't show up

339
00:14:20,540 --> 00:14:25,969
it well in a source code analysis lastly

340
00:14:23,840 --> 00:14:27,950
and I'd love to see a show of hands here

341
00:14:25,970 --> 00:14:29,750
how many people have heard from their

342
00:14:27,950 --> 00:14:32,450
development teams if you work at a

343
00:14:29,750 --> 00:14:35,420
product security company or work doing

344
00:14:32,450 --> 00:14:37,400
product security at a company hey your

345
00:14:35,420 --> 00:14:39,740
source code analysis gives me so many

346
00:14:37,400 --> 00:14:41,750
false positives I hate it I never want

347
00:14:39,740 --> 00:14:44,210
to see it again this isn't even code

348
00:14:41,750 --> 00:14:45,830
that's in the product anyone anyone

349
00:14:44,210 --> 00:14:49,040
heard that wait

350
00:14:45,830 --> 00:14:52,250
developers only complain in the US come

351
00:14:49,040 --> 00:14:55,069
on okay thank you so you know things

352
00:14:52,250 --> 00:14:57,530
that get compiled out do 2-pound defines

353
00:14:55,070 --> 00:14:59,150
are things that again we can target the

354
00:14:57,530 --> 00:15:03,680
analysis we're looking at when we look

355
00:14:59,150 --> 00:15:05,660
in the binary form so this is the

356
00:15:03,680 --> 00:15:08,719
classic slide that a marketing person

357
00:15:05,660 --> 00:15:11,089
put up right it's a scary number there's

358
00:15:08,720 --> 00:15:14,540
a lot of devices out there and there's

359
00:15:11,090 --> 00:15:16,970
not enough of us but joking aside right

360
00:15:14,540 --> 00:15:20,170
if you have 15 billion devices coming

361
00:15:16,970 --> 00:15:23,150
online between now and 2020 - and

362
00:15:20,170 --> 00:15:25,099
allegedly 1.8 million cyber security

363
00:15:23,150 --> 00:15:27,740
positions unfilled and the numbers on

364
00:15:25,100 --> 00:15:31,130
this vary from like none to 4 million

365
00:15:27,740 --> 00:15:32,540
depending on who you ask this is you

366
00:15:31,130 --> 00:15:34,610
know one of the reasons why I'm

367
00:15:32,540 --> 00:15:36,949
passionate about finding

368
00:15:34,610 --> 00:15:40,670
ways to automate also because I'm lazy

369
00:15:36,950 --> 00:15:42,829
so what is this automation trying to do

370
00:15:40,670 --> 00:15:45,199
right it's trying to find issues before

371
00:15:42,829 --> 00:15:47,719
they can cause harm even if all of us

372
00:15:45,200 --> 00:15:49,670
were busy 24 hours a day and we had

373
00:15:47,720 --> 00:15:51,740
enough people to audit every IOT or

374
00:15:49,670 --> 00:15:54,140
embedded product or every project in

375
00:15:51,740 --> 00:15:56,899
general before it went out there's still

376
00:15:54,140 --> 00:15:58,819
some issues first of all the cost of

377
00:15:56,899 --> 00:16:01,880
fixing the bugs we find is

378
00:15:58,820 --> 00:16:03,410
demonstratively much higher when it's

379
00:16:01,880 --> 00:16:04,970
closer to the release right when it's

380
00:16:03,410 --> 00:16:07,660
farther from when the bug was introduced

381
00:16:04,970 --> 00:16:10,100
it's more expensive takes longer as more

382
00:16:07,660 --> 00:16:13,219
more things have to get changed to fix

383
00:16:10,100 --> 00:16:15,500
it and lastly if we can find it earlier

384
00:16:13,220 --> 00:16:17,420
there's a lot higher likelihood that

385
00:16:15,500 --> 00:16:19,160
more percentage of the bugs are going to

386
00:16:17,420 --> 00:16:22,310
get fixed before we ship it to our

387
00:16:19,160 --> 00:16:26,839
customers so how can we push finding it

388
00:16:22,310 --> 00:16:29,180
left of shift of ship one example is

389
00:16:26,839 --> 00:16:30,950
things like github does internally now

390
00:16:29,180 --> 00:16:33,199
right where they're saying hey you have

391
00:16:30,950 --> 00:16:34,640
some node.js code we're pretty good at

392
00:16:33,200 --> 00:16:36,230
knowing when somebody reports a

393
00:16:34,640 --> 00:16:38,720
vulnerability we're gonna send you an

394
00:16:36,230 --> 00:16:41,000
email telling you a vulnerable code that

395
00:16:38,720 --> 00:16:43,459
is great for some ecosystems with

396
00:16:41,000 --> 00:16:45,500
well-defined package management they can

397
00:16:43,459 --> 00:16:47,390
be scanned for and that's the type of

398
00:16:45,500 --> 00:16:49,820
thing we're trying to find and apply to

399
00:16:47,390 --> 00:16:51,709
more types of ecosystems specifically

400
00:16:49,820 --> 00:16:54,170
embedded where if we had a package

401
00:16:51,709 --> 00:16:57,680
manager for embedded if Yocto was well

402
00:16:54,170 --> 00:16:59,839
used we'd all be a lot happier the

403
00:16:57,680 --> 00:17:03,649
second thing is that we need to have

404
00:16:59,839 --> 00:17:05,299
thoroughness in large code bases myself

405
00:17:03,649 --> 00:17:07,369
tonight argue probably most of us as

406
00:17:05,299 --> 00:17:09,439
human researchers aren't perfect if we

407
00:17:07,369 --> 00:17:12,770
get a control flow graph that looks like

408
00:17:09,439 --> 00:17:14,750
that frankly good luck right

409
00:17:12,770 --> 00:17:17,780
good luck thinking that we're going to

410
00:17:14,750 --> 00:17:21,079
be sharp enough well rested enough and

411
00:17:17,780 --> 00:17:23,329
have the patience frankly to check every

412
00:17:21,079 --> 00:17:27,020
potentially vulnerable code path in that

413
00:17:23,329 --> 00:17:28,399
function and that's a real one so we

414
00:17:27,020 --> 00:17:30,470
need to make sure the checks good

415
00:17:28,400 --> 00:17:33,260
so in program analysis we're trying to

416
00:17:30,470 --> 00:17:34,580
encode an expert researchers methods so

417
00:17:33,260 --> 00:17:35,540
that the computer can run this in

418
00:17:34,580 --> 00:17:38,870
multiple iterations

419
00:17:35,540 --> 00:17:41,059
I choked aleppo Don things about Monster

420
00:17:38,870 --> 00:17:43,580
energy drinks because this is how Sofia

421
00:17:41,059 --> 00:17:46,700
finds bugs and she's not here to defend

422
00:17:43,580 --> 00:17:48,090
herself for this methodology for her own

423
00:17:46,700 --> 00:17:51,559
health we

424
00:17:48,090 --> 00:17:53,580
need to have program analysis techniques

425
00:17:51,559 --> 00:17:55,500
but let's see what are some of the

426
00:17:53,580 --> 00:17:59,520
challenges are right it's not all just

427
00:17:55,500 --> 00:18:01,409
the promised land so first of all the

428
00:17:59,520 --> 00:18:03,809
question is can we apply techniques that

429
00:18:01,409 --> 00:18:06,179
we've used in traditional computation to

430
00:18:03,809 --> 00:18:09,000
solve these issues in embedded and the

431
00:18:06,179 --> 00:18:11,010
answer is definitely very first of all

432
00:18:09,000 --> 00:18:13,590
in traditional computation and I use

433
00:18:11,010 --> 00:18:16,770
that as a general word for web apps

434
00:18:13,590 --> 00:18:18,990
kernels etc there's been a growing

435
00:18:16,770 --> 00:18:20,668
adoption of typesafe languages or

436
00:18:18,990 --> 00:18:24,390
language extensions that can reduce

437
00:18:20,669 --> 00:18:26,880
basic memory errors in embedded we have

438
00:18:24,390 --> 00:18:29,010
yet to adopt things like well tested

439
00:18:26,880 --> 00:18:34,490
techniques that Microsoft adopted in the

440
00:18:29,010 --> 00:18:37,049
early 2000s to ban unsafe function calls

441
00:18:34,490 --> 00:18:39,450
likewise there in traditional

442
00:18:37,049 --> 00:18:42,629
computation there's well optimized tools

443
00:18:39,450 --> 00:18:46,080
for static analysis but an embedded it's

444
00:18:42,630 --> 00:18:48,090
been lagging behind in some reasons at

445
00:18:46,080 --> 00:18:50,760
least some of the reason has been due to

446
00:18:48,090 --> 00:18:53,010
a lack of good processor support for the

447
00:18:50,760 --> 00:18:55,470
variations of architectures that we have

448
00:18:53,010 --> 00:18:57,270
but now tools like binary ninja and

449
00:18:55,470 --> 00:19:00,360
Ghidorah are really helping catch that

450
00:18:57,270 --> 00:19:02,279
up in traditional computation you might

451
00:19:00,360 --> 00:19:03,899
give your developers source code

452
00:19:02,279 --> 00:19:05,340
analysis tools some of them may

453
00:19:03,899 --> 00:19:07,620
integrate into their development

454
00:19:05,340 --> 00:19:11,699
environments and highlight the bug right

455
00:19:07,620 --> 00:19:13,860
as they type the code but in embedded

456
00:19:11,700 --> 00:19:15,720
firmware not only is there widely

457
00:19:13,860 --> 00:19:17,760
divergent development environments

458
00:19:15,720 --> 00:19:20,909
because every single microcontroller

459
00:19:17,760 --> 00:19:23,309
company gives you a different IDE but

460
00:19:20,909 --> 00:19:24,990
also there's a lot higher frequency I

461
00:19:23,309 --> 00:19:29,100
would argue of taking in binary

462
00:19:24,990 --> 00:19:31,440
libraries and lastly in traditional

463
00:19:29,100 --> 00:19:33,059
computation we have well used automated

464
00:19:31,440 --> 00:19:34,620
fuzzing Suites whether it's the big

465
00:19:33,059 --> 00:19:36,600
companies or whether it's things that

466
00:19:34,620 --> 00:19:38,610
people apply individually all have

467
00:19:36,600 --> 00:19:40,459
harnesses or often have harnesses that

468
00:19:38,610 --> 00:19:43,949
are fuzzing for security vulnerabilities

469
00:19:40,460 --> 00:19:46,169
but in embedded this is tougher right we

470
00:19:43,950 --> 00:19:48,240
have Hardware interrupt handlers we have

471
00:19:46,169 --> 00:19:50,429
custom chipsets and board layouts that

472
00:19:48,240 --> 00:19:53,130
require instrumentation this raises the

473
00:19:50,429 --> 00:19:56,490
barrier to entry so to answer a question

474
00:19:53,130 --> 00:19:58,470
yes we can apply these things but it's

475
00:19:56,490 --> 00:20:01,150
non-trivial to implement we can't just

476
00:19:58,470 --> 00:20:03,790
port or use the existing tools

477
00:20:01,150 --> 00:20:05,500
but we can apply techniques we can take

478
00:20:03,790 --> 00:20:08,590
static analysis to screen for bug

479
00:20:05,500 --> 00:20:10,840
glasses like we'll be showing today we

480
00:20:08,590 --> 00:20:13,840
can use emulation or partial emulation

481
00:20:10,840 --> 00:20:15,820
to drive and support some fuzzing we can

482
00:20:13,840 --> 00:20:19,629
use techniques like satisfiability

483
00:20:15,820 --> 00:20:21,879
solving to figure out some cases in the

484
00:20:19,630 --> 00:20:23,620
control flow and importantly we should

485
00:20:21,880 --> 00:20:27,760
be integrating into the development

486
00:20:23,620 --> 00:20:29,830
cycle right so just like a shop is you

487
00:20:27,760 --> 00:20:32,080
know using continuous integration to

488
00:20:29,830 --> 00:20:34,990
build it send it to QA and get it back

489
00:20:32,080 --> 00:20:37,480
so - if we automate it instead of having

490
00:20:34,990 --> 00:20:39,040
us on the receiving end we can't I can't

491
00:20:37,480 --> 00:20:41,710
turn around in ten minutes and give you

492
00:20:39,040 --> 00:20:43,899
results or in 45 seconds but an

493
00:20:41,710 --> 00:20:45,460
automated program analysis can give some

494
00:20:43,900 --> 00:20:48,100
of that feedback in the build process

495
00:20:45,460 --> 00:20:49,840
right to the developer hopefully meaning

496
00:20:48,100 --> 00:20:52,449
they actually implement it and ship more

497
00:20:49,840 --> 00:20:54,699
secure code so the reason I've been

498
00:20:52,450 --> 00:20:57,070
focusing on and researching this frankly

499
00:20:54,700 --> 00:20:59,740
for the past few years is because my

500
00:20:57,070 --> 00:21:01,750
objectives are let the computer do the

501
00:20:59,740 --> 00:21:04,120
majority and the majority of issues let

502
00:21:01,750 --> 00:21:07,000
us focus on the more interesting things

503
00:21:04,120 --> 00:21:10,409
and overall let's help our customers by

504
00:21:07,000 --> 00:21:13,120
catching issues before they cause harm

505
00:21:10,410 --> 00:21:15,580
but another challenge is determining bug

506
00:21:13,120 --> 00:21:17,439
efficacy and I'm gonna go through three

507
00:21:15,580 --> 00:21:21,159
specific technical areas where this

508
00:21:17,440 --> 00:21:22,660
rears an ugly head first of all how do

509
00:21:21,160 --> 00:21:24,130
we encode these read and write

510
00:21:22,660 --> 00:21:25,390
primitives right I said you can just

511
00:21:24,130 --> 00:21:27,370
simplify them to read and write

512
00:21:25,390 --> 00:21:30,790
primitives well now I'm here to tell you

513
00:21:27,370 --> 00:21:32,559
it's not that simple for example in some

514
00:21:30,790 --> 00:21:36,520
of the vulnerabilities that I'll cover

515
00:21:32,559 --> 00:21:39,850
in a moment tend a router manufacturer

516
00:21:36,520 --> 00:21:42,460
has this call due system command it's a

517
00:21:39,850 --> 00:21:44,980
dynamically linked library that they

518
00:21:42,460 --> 00:21:48,190
bring in that basically calls system

519
00:21:44,980 --> 00:21:49,780
vulnerably under the hood but because

520
00:21:48,190 --> 00:21:51,370
this is a class of dynamically linked

521
00:21:49,780 --> 00:21:53,678
library into a different program that

522
00:21:51,370 --> 00:21:56,709
you're analyzing stuff like this can add

523
00:21:53,679 --> 00:21:59,950
a complexity to encoding the sinks that

524
00:21:56,710 --> 00:22:02,350
we talked about likewise information

525
00:21:59,950 --> 00:22:05,320
flow analysis I'll dive more into this

526
00:22:02,350 --> 00:22:07,540
and an example in a second but this is

527
00:22:05,320 --> 00:22:09,189
basically making sure how do we know

528
00:22:07,540 --> 00:22:10,960
that the variable one function is

529
00:22:09,190 --> 00:22:12,610
touching how does the computer realize

530
00:22:10,960 --> 00:22:14,590
that's the same one that's being used in

531
00:22:12,610 --> 00:22:18,439
the different context

532
00:22:14,590 --> 00:22:21,949
and lastly variable range recovery this

533
00:22:18,440 --> 00:22:24,289
is important because for example if

534
00:22:21,950 --> 00:22:25,970
something does a length check and then

535
00:22:24,289 --> 00:22:27,860
it's used in a way that would only be

536
00:22:25,970 --> 00:22:30,259
vulnerable if the length is over a

537
00:22:27,860 --> 00:22:31,639
certain boundary we need to understand

538
00:22:30,259 --> 00:22:34,100
that the computer needs to understand

539
00:22:31,639 --> 00:22:36,289
that in the program analysis one way to

540
00:22:34,100 --> 00:22:39,830
do this is to do symbolic execution on

541
00:22:36,289 --> 00:22:44,619
everything that is unlikely to work and

542
00:22:39,830 --> 00:22:46,970
it certainly won't work in 45 seconds so

543
00:22:44,619 --> 00:22:48,889
let's look at an example of where we

544
00:22:46,970 --> 00:22:50,720
have to do a range recovery if we take

545
00:22:48,889 --> 00:22:52,998
that same vulnerable program from

546
00:22:50,720 --> 00:22:54,110
earlier and now we add the code in blue

547
00:22:52,999 --> 00:22:56,539
right

548
00:22:54,110 --> 00:23:00,049
so still maybe not the best rate in code

549
00:22:56,539 --> 00:23:03,110
but let's let's go with it we are now

550
00:23:00,049 --> 00:23:05,418
checking that the input is if it's over

551
00:23:03,110 --> 00:23:07,729
a hundred bytes we're going to air out

552
00:23:05,419 --> 00:23:09,619
and we won't do the vulnerable copy into

553
00:23:07,730 --> 00:23:11,629
the buffer so we have this base

554
00:23:09,619 --> 00:23:14,480
assumption that store copy does a memory

555
00:23:11,629 --> 00:23:17,449
write the right length is the length of

556
00:23:14,480 --> 00:23:20,629
the source buffer to store copy but now

557
00:23:17,450 --> 00:23:23,179
we've added this check in blue and now

558
00:23:20,629 --> 00:23:25,519
we need to understand a few more things

559
00:23:23,179 --> 00:23:27,740
in our program analysis first of all we

560
00:23:25,519 --> 00:23:30,860
need to know the size of the destination

561
00:23:27,740 --> 00:23:32,570
buffer and secondly we need to know what

562
00:23:30,860 --> 00:23:35,779
we've bounded the length of the source

563
00:23:32,570 --> 00:23:37,460
buffer in this case input two now the

564
00:23:35,779 --> 00:23:39,350
exact techniques for this would be a

565
00:23:37,460 --> 00:23:41,509
whole talk in its own right and so I'm

566
00:23:39,350 --> 00:23:43,519
not going to dive into it here but I do

567
00:23:41,509 --> 00:23:47,450
want to raise it as something that we

568
00:23:43,519 --> 00:23:49,580
have to overcome when doing this so now

569
00:23:47,450 --> 00:23:50,840
let's talk about two issues that we ran

570
00:23:49,580 --> 00:23:53,299
into when preparing for this

571
00:23:50,840 --> 00:23:55,580
presentation and how we're going about

572
00:23:53,299 --> 00:23:58,009
fixing them and making that so others

573
00:23:55,580 --> 00:24:00,110
don't run into it as well so the first

574
00:23:58,009 --> 00:24:03,259
for those of you who have done reverse

575
00:24:00,110 --> 00:24:04,519
engineering on binaries you probably

576
00:24:03,259 --> 00:24:07,490
know that they lead to their own

577
00:24:04,519 --> 00:24:09,440
challenges in this case binary ninja was

578
00:24:07,490 --> 00:24:11,480
not able to find the main function and

579
00:24:09,440 --> 00:24:12,980
when it couldn't find that it really

580
00:24:11,480 --> 00:24:15,649
didn't find any other function so

581
00:24:12,980 --> 00:24:17,210
nothing had any vulnerabilities well

582
00:24:15,649 --> 00:24:20,090
that was a red flag because they

583
00:24:17,210 --> 00:24:21,919
obviously had vulnerabilities so what we

584
00:24:20,090 --> 00:24:24,470
wanted to do here was figure out what

585
00:24:21,919 --> 00:24:26,509
was going on and our technique for this

586
00:24:24,470 --> 00:24:27,680
we're saying yes it's MIPS because this

587
00:24:26,509 --> 00:24:30,500
is where the issue was happening

588
00:24:27,680 --> 00:24:33,320
we're gonna find this meu lib see this

589
00:24:30,500 --> 00:24:34,850
function the entry point we're going to

590
00:24:33,320 --> 00:24:38,120
extract the first argument and

591
00:24:34,850 --> 00:24:40,159
dereference it and then grab those four

592
00:24:38,120 --> 00:24:42,129
bytes then we'll do a sanity check to

593
00:24:40,160 --> 00:24:45,020
see okay this is a function preamble

594
00:24:42,130 --> 00:24:46,340
we'll set that as a function and then we

595
00:24:45,020 --> 00:24:47,090
analyze the whole thing which is

596
00:24:46,340 --> 00:24:49,820
expensive

597
00:24:47,090 --> 00:24:51,830
luckily the binary ninja teams great and

598
00:24:49,820 --> 00:24:53,570
after we found and gave them this patch

599
00:24:51,830 --> 00:24:55,399
they've now put it in so if you're on a

600
00:24:53,570 --> 00:24:59,689
recent version you should not run into

601
00:24:55,400 --> 00:25:02,270
this issue if so blame them another is

602
00:24:59,690 --> 00:25:04,910
going back to that topic I talked about

603
00:25:02,270 --> 00:25:07,810
earlier with memory references this is

604
00:25:04,910 --> 00:25:10,160
an example of how we have an issue

605
00:25:07,810 --> 00:25:11,960
understanding what goes into system

606
00:25:10,160 --> 00:25:14,360
right so in this case system is the

607
00:25:11,960 --> 00:25:16,250
vulnerable sink and we want to

608
00:25:14,360 --> 00:25:19,580
understand if the attacker could control

609
00:25:16,250 --> 00:25:22,340
data going into it well what's happening

610
00:25:19,580 --> 00:25:25,040
here is a variable is being assigned

611
00:25:22,340 --> 00:25:27,020
based on a stack address reference then

612
00:25:25,040 --> 00:25:30,879
data gets copied into it in this case

613
00:25:27,020 --> 00:25:33,590
through s printf and then that same

614
00:25:30,880 --> 00:25:35,750
stack address reference is used to set a

615
00:25:33,590 --> 00:25:37,730
different variable which is what's

616
00:25:35,750 --> 00:25:39,050
passed in the system as humans we look

617
00:25:37,730 --> 00:25:40,160
at this and all of you are nodding and

618
00:25:39,050 --> 00:25:42,320
being like yeah I don't know why the

619
00:25:40,160 --> 00:25:44,030
computer can't follow this this clearly

620
00:25:42,320 --> 00:25:47,179
is the same thing it's being set by

621
00:25:44,030 --> 00:25:49,370
constants not an issue but this is very

622
00:25:47,180 --> 00:25:53,960
difficult to generically trace from a

623
00:25:49,370 --> 00:25:55,729
program analysis standpoint okay we've

624
00:25:53,960 --> 00:25:57,770
gotten through the background of program

625
00:25:55,730 --> 00:25:59,480
analysis I'm sorry that not everyone is

626
00:25:57,770 --> 00:26:00,470
coding it up at this point but I'd be

627
00:25:59,480 --> 00:26:02,060
happy to talk with anyone

628
00:26:00,470 --> 00:26:04,310
afterwards who's interested in diving

629
00:26:02,060 --> 00:26:08,210
more into that but now let's go through

630
00:26:04,310 --> 00:26:10,399
some examples right I have a thing

631
00:26:08,210 --> 00:26:13,100
against live demos so I have taken the

632
00:26:10,400 --> 00:26:15,170
liberty of having the 45 seconds elapsed

633
00:26:13,100 --> 00:26:17,379
earlier today and then taking

634
00:26:15,170 --> 00:26:20,030
screenshots and putting them in here

635
00:26:17,380 --> 00:26:22,460
because me zooming around my computer

636
00:26:20,030 --> 00:26:24,950
screen while standing behind a desk is

637
00:26:22,460 --> 00:26:26,570
certainly less fun than me me standing

638
00:26:24,950 --> 00:26:30,500
up here where you can wear them within

639
00:26:26,570 --> 00:26:32,000
range of your Tomatoes so let's go

640
00:26:30,500 --> 00:26:34,250
through some examples we're going to go

641
00:26:32,000 --> 00:26:36,140
through 20 devices we picked these by

642
00:26:34,250 --> 00:26:38,900
looking at various lists of what we're

643
00:26:36,140 --> 00:26:40,670
popular device is and different markets

644
00:26:38,900 --> 00:26:41,330
and then to be honest with you the

645
00:26:40,670 --> 00:26:45,020
toughest

646
00:26:41,330 --> 00:26:57,490
because I was invited to give this talk

647
00:26:45,020 --> 00:26:57,490
oh you don't want to see that re oh

648
00:27:00,790 --> 00:27:04,120
that's fun huh

649
00:27:04,600 --> 00:27:11,139
loading loading who hit the internet on

650
00:27:08,990 --> 00:27:11,140
me

651
00:27:18,110 --> 00:27:25,129
okay sorry about that so talking through

652
00:27:23,330 --> 00:27:27,470
these devices the one of the toughest

653
00:27:25,130 --> 00:27:29,600
part was I was asked to give this talk

654
00:27:27,470 --> 00:27:31,580
about two months ago we give people

655
00:27:29,600 --> 00:27:34,010
three months notice before releasing new

656
00:27:31,580 --> 00:27:35,840
bugs on stage against their targets

657
00:27:34,010 --> 00:27:38,299
so the toughest thing was five big

658
00:27:35,840 --> 00:27:40,129
majority of devices the LD that we could

659
00:27:38,299 --> 00:27:41,929
find automatically and then figuring out

660
00:27:40,130 --> 00:27:44,630
if somebody had manually found those in

661
00:27:41,929 --> 00:27:46,880
the past so that I did not feel bad or

662
00:27:44,630 --> 00:27:49,909
get yelled at for releasing them here

663
00:27:46,880 --> 00:27:51,740
now the last four don't fall into that

664
00:27:49,909 --> 00:27:53,899
group so that's fine we'll just leave

665
00:27:51,740 --> 00:27:57,019
out the exact memory addresses and no

666
00:27:53,899 --> 00:27:58,699
one will figure it out so first of all

667
00:27:57,019 --> 00:28:00,289
to start it off this is a tender router

668
00:27:58,700 --> 00:28:02,269
and we're gonna go pretty fast through

669
00:28:00,289 --> 00:28:04,730
this right so we're gonna look at this

670
00:28:02,269 --> 00:28:06,889
one on how the HTTP requests are

671
00:28:04,730 --> 00:28:08,149
processed and the great thing is I

672
00:28:06,889 --> 00:28:10,699
figured we'll start with this one

673
00:28:08,149 --> 00:28:13,418
because it has an awesome feature in its

674
00:28:10,700 --> 00:28:16,669
product literature it has an T hacking

675
00:28:13,419 --> 00:28:17,690
and I thought well that definitely means

676
00:28:16,669 --> 00:28:20,690
we're not gonna find anything

677
00:28:17,690 --> 00:28:23,630
automatically so here's what we found

678
00:28:20,690 --> 00:28:26,659
automatically web requests came through

679
00:28:23,630 --> 00:28:28,669
and get processed first by a this HT DB

680
00:28:26,659 --> 00:28:30,769
D right it's gonna read the users data

681
00:28:28,669 --> 00:28:33,110
from the socket and then it passes it

682
00:28:30,769 --> 00:28:35,389
off to app data center which parses and

683
00:28:33,110 --> 00:28:37,668
uses the data well the first thing one

684
00:28:35,389 --> 00:28:40,129
that I saw popping up was this write a

685
00:28:37,669 --> 00:28:40,880
vulnerable system call let's dive into

686
00:28:40,130 --> 00:28:43,309
what that is

687
00:28:40,880 --> 00:28:46,010
ah don't worry is nobody was reported

688
00:28:43,309 --> 00:28:47,870
but unpatched it was actually reported

689
00:28:46,010 --> 00:28:50,059
on a different device from this vendor

690
00:28:47,870 --> 00:28:52,219
but through program analysis we were

691
00:28:50,059 --> 00:28:55,000
able to quickly see that it was also

692
00:28:52,220 --> 00:28:58,490
available on this model of device and

693
00:28:55,000 --> 00:29:01,639
what it actually is is the inside

694
00:28:58,490 --> 00:29:03,860
they're handling for USB injection which

695
00:29:01,639 --> 00:29:08,000
obviously has to be available over the

696
00:29:03,860 --> 00:29:10,729
web it copies in some data and an

697
00:29:08,000 --> 00:29:13,159
unbounded form unsanitized as puts in

698
00:29:10,730 --> 00:29:15,649
call system on it great typical command

699
00:29:13,159 --> 00:29:18,470
injection hint none of these are gonna

700
00:29:15,649 --> 00:29:20,449
be thrilling right what's interesting is

701
00:29:18,470 --> 00:29:23,539
that we can find them automatically okay

702
00:29:20,450 --> 00:29:26,510
on the next device on tenders AC 5

703
00:29:23,539 --> 00:29:28,399
device again similar binaries one looks

704
00:29:26,510 --> 00:29:30,649
a little different this case as a format

705
00:29:28,399 --> 00:29:31,729
string vulnerability what this actually

706
00:29:30,649 --> 00:29:34,639
is is that

707
00:29:31,730 --> 00:29:37,970
it's reading in a parameter from the

708
00:29:34,640 --> 00:29:39,560
HTTP web request and it's using this as

709
00:29:37,970 --> 00:29:41,750
the format string so you could do

710
00:29:39,560 --> 00:29:44,870
percent n or percent P your typical

711
00:29:41,750 --> 00:29:47,270
format string types of attacks to

712
00:29:44,870 --> 00:29:49,010
control the stack okay let's go

713
00:29:47,270 --> 00:29:51,680
appreciate some stack buffer overflows

714
00:29:49,010 --> 00:29:54,560
will stay on tended to start in this

715
00:29:51,680 --> 00:29:55,820
device it's their AC 18 device and at

716
00:29:54,560 --> 00:29:57,530
this memory address and don't worry the

717
00:29:55,820 --> 00:30:00,500
only one I'm just closing is the one

718
00:29:57,530 --> 00:30:03,379
I've highlighted and this is the one

719
00:30:00,500 --> 00:30:07,430
that again has been disclosed previously

720
00:30:03,380 --> 00:30:10,430
they're reading in the SSID field that

721
00:30:07,430 --> 00:30:13,340
somebody sat through a webform and does

722
00:30:10,430 --> 00:30:17,630
a store copy into a fixed size buffer of

723
00:30:13,340 --> 00:30:19,639
hex 40 off of that this can be triggered

724
00:30:17,630 --> 00:30:27,200
via this very complex exploit that you

725
00:30:19,640 --> 00:30:29,060
see here yep so on AC 15 another one

726
00:30:27,200 --> 00:30:31,670
from this family of quality devices

727
00:30:29,060 --> 00:30:34,460
another store copy what this comes out

728
00:30:31,670 --> 00:30:37,220
to be is this time they read in this

729
00:30:34,460 --> 00:30:39,500
idea of where they should bind their MAC

730
00:30:37,220 --> 00:30:41,000
address to some IP now what's

731
00:30:39,500 --> 00:30:42,500
interesting here is think back to this

732
00:30:41,000 --> 00:30:45,950
grid that I showed you earlier that

733
00:30:42,500 --> 00:30:48,980
control flow graph of so many devices or

734
00:30:45,950 --> 00:30:51,320
so many points in a program if somebody

735
00:30:48,980 --> 00:30:53,060
manually finds an exploit they're likely

736
00:30:51,320 --> 00:30:55,040
to find it in one place you don't need a

737
00:30:53,060 --> 00:30:57,590
second one even if you report it to the

738
00:30:55,040 --> 00:30:59,420
vendor it's incumbent I think most would

739
00:30:57,590 --> 00:31:01,280
argue on the vendor to find all the

740
00:30:59,420 --> 00:31:04,130
places the same exploit technique hits

741
00:31:01,280 --> 00:31:05,540
and in this case basically any field

742
00:31:04,130 --> 00:31:07,760
that you can submit to this web

743
00:31:05,540 --> 00:31:10,340
application has a store copy buffer

744
00:31:07,760 --> 00:31:12,550
overflow so program analysis is patient

745
00:31:10,340 --> 00:31:15,709
enough to find all of them for you and

746
00:31:12,550 --> 00:31:19,100
again can be triggered via a slightly

747
00:31:15,710 --> 00:31:23,690
more complex vulnerability this time you

748
00:31:19,100 --> 00:31:25,459
need to provide two arguments finding

749
00:31:23,690 --> 00:31:28,700
another one in another in this time in

750
00:31:25,460 --> 00:31:31,640
device number five AC 9 it's the NTP

751
00:31:28,700 --> 00:31:35,900
server field on this device that is

752
00:31:31,640 --> 00:31:37,310
vulnerable so ok let's give that a break

753
00:31:35,900 --> 00:31:39,140
let's go look at some more command

754
00:31:37,310 --> 00:31:39,980
injections we'll stay on them for a

755
00:31:39,140 --> 00:31:42,050
little while longer

756
00:31:39,980 --> 00:31:44,180
remember how I said earlier some of the

757
00:31:42,050 --> 00:31:45,800
issues are trying to find a sync on a

758
00:31:44,180 --> 00:31:48,260
device when it's

759
00:31:45,800 --> 00:31:50,540
this is that one right where do system

760
00:31:48,260 --> 00:31:53,629
command is where the vulnerable function

761
00:31:50,540 --> 00:31:55,420
is in this case let's see what's going

762
00:31:53,630 --> 00:31:58,100
on they're taking in a MAC address

763
00:31:55,420 --> 00:32:00,650
passing it down this can be attacked

764
00:31:58,100 --> 00:32:02,928
sophia wrote up a a really complex

765
00:32:00,650 --> 00:32:04,910
proof-of-concept here where you have to

766
00:32:02,929 --> 00:32:10,429
add a semicolon before you on your

767
00:32:04,910 --> 00:32:11,840
command looking at a c7 now let's see

768
00:32:10,429 --> 00:32:14,240
what we have here we have another

769
00:32:11,840 --> 00:32:15,830
command injection through another

770
00:32:14,240 --> 00:32:17,990
function where the device name is

771
00:32:15,830 --> 00:32:20,030
vulnerable are we getting the feeling

772
00:32:17,990 --> 00:32:23,420
here that tenda may not be what i

773
00:32:20,030 --> 00:32:25,030
install in my house okay let's give them

774
00:32:23,420 --> 00:32:27,290
a break let's go look at some other

775
00:32:25,030 --> 00:32:29,570
vendors because this is certainly not

776
00:32:27,290 --> 00:32:32,090
limited to one let's look at some more

777
00:32:29,570 --> 00:32:37,040
command injections in this case and a

778
00:32:32,090 --> 00:32:40,280
d-link modem I know a router in this

779
00:32:37,040 --> 00:32:43,670
case it has this boa constrictor or

780
00:32:40,280 --> 00:32:45,860
whatever binary they has system called

781
00:32:43,670 --> 00:32:48,320
at this address in this case it's

782
00:32:45,860 --> 00:32:50,659
reading in a command and kindly

783
00:32:48,320 --> 00:32:53,270
processing it for you directly in the

784
00:32:50,660 --> 00:32:57,410
system through s printf the nice thing

785
00:32:53,270 --> 00:32:58,910
is it logs out what you did now a bonus

786
00:32:57,410 --> 00:32:59,900
is that I want to throw in write

787
00:32:58,910 --> 00:33:01,640
everything we're talking about is

788
00:32:59,900 --> 00:33:03,290
program analysis but I don't want to

789
00:33:01,640 --> 00:33:05,390
give the impression that the only thing

790
00:33:03,290 --> 00:33:07,879
we can find automatically is things like

791
00:33:05,390 --> 00:33:10,250
store copies or command injections

792
00:33:07,880 --> 00:33:11,750
another example of things that we don't

793
00:33:10,250 --> 00:33:13,820
want to look for as humans at least I

794
00:33:11,750 --> 00:33:16,460
don't or things like hard coded

795
00:33:13,820 --> 00:33:19,070
passwords right we're you know running

796
00:33:16,460 --> 00:33:21,220
grep or looking at Etsy password on

797
00:33:19,070 --> 00:33:23,960
every device you SS gets boring

798
00:33:21,220 --> 00:33:25,960
remembering exactly which ones md5 and

799
00:33:23,960 --> 00:33:27,830
not in the encoding is annoying so

800
00:33:25,960 --> 00:33:30,440
additional things we can find on that

801
00:33:27,830 --> 00:33:34,669
device ok let's go back to command

802
00:33:30,440 --> 00:33:36,980
injections on the d-link der 816 they

803
00:33:34,670 --> 00:33:38,900
use the go ahead which is an open source

804
00:33:36,980 --> 00:33:41,570
web server open source and commercially

805
00:33:38,900 --> 00:33:43,550
available web server and in this case it

806
00:33:41,570 --> 00:33:47,000
takes in a command through an ASP

807
00:33:43,550 --> 00:33:50,600
handler and passes it down again to

808
00:33:47,000 --> 00:33:52,100
system why not let's look at wall way

809
00:33:50,600 --> 00:33:53,980
knowing for some of the most secure

810
00:33:52,100 --> 00:33:57,350
devices available on the market today

811
00:33:53,980 --> 00:34:01,280
there UPnP binary universal plug and

812
00:33:57,350 --> 00:34:03,260
play or the the network service as

813
00:34:01,280 --> 00:34:06,379
they're calling down in the system at

814
00:34:03,260 --> 00:34:09,230
this address in this case they decode

815
00:34:06,380 --> 00:34:11,330
some user provided input from an XML

816
00:34:09,230 --> 00:34:14,540
node and pass it right down the system

817
00:34:11,330 --> 00:34:17,600
again this was found manually in 2017

818
00:34:14,540 --> 00:34:19,340
but most of the work in finding these is

819
00:34:17,600 --> 00:34:21,080
not finding them it's figuring out if

820
00:34:19,340 --> 00:34:23,300
somebody else had previously found them

821
00:34:21,080 --> 00:34:29,929
given as I'm sure you all know CVE

822
00:34:23,300 --> 00:34:33,649
entries are really well written Asus has

823
00:34:29,929 --> 00:34:35,690
an httpd server as well that we get a

824
00:34:33,649 --> 00:34:37,909
hit on through the automated analysis

825
00:34:35,690 --> 00:34:40,250
that system is is being called at this

826
00:34:37,909 --> 00:34:43,700
address and if we look at what that is

827
00:34:40,250 --> 00:34:46,310
is taking in an email form through

828
00:34:43,699 --> 00:34:49,368
something and passing it down the system

829
00:34:46,310 --> 00:34:51,560
in this case you can't use a semicolon

830
00:34:49,369 --> 00:34:55,909
you have to have to use a pipe character

831
00:34:51,560 --> 00:34:58,460
so very advanced exploitation ubiquity

832
00:34:55,909 --> 00:35:00,109
makes a product and I include this one

833
00:34:58,460 --> 00:35:02,359
here just to show that it's not always

834
00:35:00,109 --> 00:35:05,119
system right we need to be aware of all

835
00:35:02,359 --> 00:35:10,210
of the different sinks in this case exec

836
00:35:05,119 --> 00:35:12,950
L that's again a vulnerable function

837
00:35:10,210 --> 00:35:14,869
okay let's so take a look now at some

838
00:35:12,950 --> 00:35:17,169
stack buffer overflows I've warned you

839
00:35:14,869 --> 00:35:20,750
all out on command injections

840
00:35:17,170 --> 00:35:24,500
let's hit another tp-link device in this

841
00:35:20,750 --> 00:35:26,960
case again they have a web server it

842
00:35:24,500 --> 00:35:29,420
calls ster copy the data coming into

843
00:35:26,960 --> 00:35:31,700
that came from how they take in an IP

844
00:35:29,420 --> 00:35:34,300
address through a web form this was

845
00:35:31,700 --> 00:35:38,060
found manually earlier this year and

846
00:35:34,300 --> 00:35:41,420
reported in an Asus device let's hit a

847
00:35:38,060 --> 00:35:44,450
few of those against ur copy in this

848
00:35:41,420 --> 00:35:46,520
case takes through a CGI binary that

849
00:35:44,450 --> 00:35:50,080
takes the username passes it right down

850
00:35:46,520 --> 00:35:53,330
copies it into an unbounded buffer

851
00:35:50,080 --> 00:35:57,680
another Asus device slightly different

852
00:35:53,330 --> 00:35:59,509
h2 DB binary in this case they do the

853
00:35:57,680 --> 00:36:01,609
buffer overflow not through store copy

854
00:35:59,510 --> 00:36:04,780
but through s printf right because this

855
00:36:01,609 --> 00:36:09,750
can also copy off the edge of a

856
00:36:04,780 --> 00:36:11,760
statically allocated stack buffer okay

857
00:36:09,750 --> 00:36:13,260
let's look at a few I think just a few

858
00:36:11,760 --> 00:36:15,270
more examples let's look at an example

859
00:36:13,260 --> 00:36:17,760
of a controlled format string like we

860
00:36:15,270 --> 00:36:22,410
touched on it first with tenda this time

861
00:36:17,760 --> 00:36:26,220
in tp-link this is an R 600 VPN device

862
00:36:22,410 --> 00:36:32,129
and we can just to see that this V print

863
00:36:26,220 --> 00:36:34,080
VF print F call here is a format string

864
00:36:32,130 --> 00:36:37,859
in this case that the attacker can

865
00:36:34,080 --> 00:36:40,130
control through I forget exactly here I

866
00:36:37,859 --> 00:36:44,840
think it's another email address field

867
00:36:40,130 --> 00:36:46,920
that is used like a format string okay

868
00:36:44,840 --> 00:36:49,080
now for the ones that I will

869
00:36:46,920 --> 00:36:51,090
purposefully omit the actual memory

870
00:36:49,080 --> 00:36:55,430
addresses from I'll just tell you the

871
00:36:51,090 --> 00:36:59,280
binaries so law of you IP camera as a

872
00:36:55,430 --> 00:37:00,868
binary called exact system command one

873
00:36:59,280 --> 00:37:04,400
might think this is where you might look

874
00:37:00,869 --> 00:37:06,960
for a command injection you are correct

875
00:37:04,400 --> 00:37:08,670
we disclosed this earlier this month

876
00:37:06,960 --> 00:37:10,170
still haven't gotten a response back

877
00:37:08,670 --> 00:37:13,920
from the vendor we'll continue to follow

878
00:37:10,170 --> 00:37:17,369
up on another I believe this is another

879
00:37:13,920 --> 00:37:19,680
camera if you're gonna have hard-coded

880
00:37:17,369 --> 00:37:21,780
passwords which I'd argue you should not

881
00:37:19,680 --> 00:37:24,569
do you definitely should at least salt

882
00:37:21,780 --> 00:37:26,430
them and in this case we see that the

883
00:37:24,570 --> 00:37:28,380
automated analysis can call it out

884
00:37:26,430 --> 00:37:32,009
because there's no salt being used

885
00:37:28,380 --> 00:37:35,670
we finished disclosing that one on this

886
00:37:32,010 --> 00:37:38,760
commercial DVR used to wreak record

887
00:37:35,670 --> 00:37:42,140
security cameras there was a blog post

888
00:37:38,760 --> 00:37:46,680
that was never formally reported in 2013

889
00:37:42,140 --> 00:37:49,080
there they released a patch in summer of

890
00:37:46,680 --> 00:37:50,879
2018 that specifically says in the

891
00:37:49,080 --> 00:37:52,710
release notes that it's there to

892
00:37:50,880 --> 00:37:59,940
mitigate a large number of security

893
00:37:52,710 --> 00:38:01,380
vulnerabilities yeah no I still have not

894
00:37:59,940 --> 00:38:04,170
heard back from them on those technical

895
00:38:01,380 --> 00:38:07,349
details that we sent over on Linksys

896
00:38:04,170 --> 00:38:10,109
camera the file dot cgi handler was

897
00:38:07,349 --> 00:38:12,810
previously reported to be reachable and

898
00:38:10,109 --> 00:38:15,390
allow for file access but automated

899
00:38:12,810 --> 00:38:21,270
analysis also quickly was able to flag

900
00:38:15,390 --> 00:38:22,589
that it had command injection as well so

901
00:38:21,270 --> 00:38:24,180
I've gone through those in rapid

902
00:38:22,590 --> 00:38:26,610
succession I'd be happy to talk to

903
00:38:24,180 --> 00:38:28,700
anyone about more details about how one

904
00:38:26,610 --> 00:38:31,860
of those is found the actual math behind

905
00:38:28,700 --> 00:38:34,430
the processing or any other topic you

906
00:38:31,860 --> 00:38:36,420
want thank you so much for having me

907
00:38:34,430 --> 00:38:37,950
it's been a great time to be at this

908
00:38:36,420 --> 00:38:39,510
conference and thank you for being so

909
00:38:37,950 --> 00:38:41,790
welcoming and putting up with my

910
00:38:39,510 --> 00:38:44,910
absolutely terrible Spanish I will work

911
00:38:41,790 --> 00:38:46,529
on it I promise for next year I'm happy

912
00:38:44,910 --> 00:38:49,259
to take any questions it looks like we

913
00:38:46,530 --> 00:38:51,660
have a few minutes remaining or let you

914
00:38:49,260 --> 00:38:54,600
get on to closing and drinking at

915
00:38:51,660 --> 00:39:05,750
closing ceremonies

916
00:38:54,600 --> 00:39:09,808
[Applause]

917
00:39:05,750 --> 00:39:10,890
all right thanks Oh somebody's not

918
00:39:09,809 --> 00:39:17,460
letting me off that easily

919
00:39:10,890 --> 00:39:19,980
Oh Ryan thank you for being here uh you

920
00:39:17,460 --> 00:39:21,710
kind of clear that what you're using for

921
00:39:19,980 --> 00:39:24,750
things like you're doing different

922
00:39:21,710 --> 00:39:26,460
functions but why are you doing to find

923
00:39:24,750 --> 00:39:28,079
the source are you like doing model out

924
00:39:26,460 --> 00:39:32,220
it you find like the different potential

925
00:39:28,079 --> 00:39:35,609
source for your data flow analysis yeah

926
00:39:32,220 --> 00:39:38,220
in this case in the examples we showed

927
00:39:35,609 --> 00:39:40,529
today we're not pegging on specific

928
00:39:38,220 --> 00:39:42,868
sources but instead we could covering

929
00:39:40,530 --> 00:39:45,990
control flow back up from the sink and

930
00:39:42,869 --> 00:39:48,299
seeing if we are able to concretize the

931
00:39:45,990 --> 00:39:50,640
parameters to the sink and if we're not

932
00:39:48,299 --> 00:39:52,020
able to concretize them we don't know

933
00:39:50,640 --> 00:39:54,660
that they came from something that is

934
00:39:52,020 --> 00:39:58,470
safe then we'll flag it for a human to

935
00:39:54,660 --> 00:40:00,270
look at but absolutely to your point and

936
00:39:58,470 --> 00:40:02,609
in some other tooling I didn't show

937
00:40:00,270 --> 00:40:05,849
today we also look for specific sources

938
00:40:02,609 --> 00:40:07,710
and in fact how we pick which binaries

939
00:40:05,849 --> 00:40:09,180
to look at out of the whole file system

940
00:40:07,710 --> 00:40:11,579
right these have hundreds of binaries

941
00:40:09,180 --> 00:40:14,009
you want to know a few things which ones

942
00:40:11,579 --> 00:40:15,690
are actually being run and we do a lot

943
00:40:14,010 --> 00:40:17,609
of analysis to figure that out but also

944
00:40:15,690 --> 00:40:19,980
which of those then bind on a network

945
00:40:17,609 --> 00:40:22,259
interface so that you pick ones that are

946
00:40:19,980 --> 00:40:27,990
more likely to have attacker controlled

947
00:40:22,260 --> 00:40:30,180
input hey what's up how you ever

948
00:40:27,990 --> 00:40:35,250
considered to take a look into ICS

949
00:40:30,180 --> 00:40:36,990
devices yeah absolutely yeah and it on

950
00:40:35,250 --> 00:40:39,900
those that are embedded Linux focused

951
00:40:36,990 --> 00:40:42,169
this works well as as well okay cool

952
00:40:39,900 --> 00:40:42,170
thank you

953
00:40:48,650 --> 00:40:53,650
okay thank you very much

954
00:40:50,870 --> 00:40:53,650
have a great rest of the day

955
00:40:56,520 --> 00:40:58,580
you

