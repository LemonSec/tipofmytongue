1
00:00:02,000 --> 00:00:06,960
alex matrosova

2
00:00:03,679 --> 00:00:07,839
philip lebedev jagor vasilenko and andre

3
00:00:06,960 --> 00:00:11,440
glabunets

4
00:00:07,839 --> 00:00:13,120
present static analyst vassal recovered

5
00:00:11,440 --> 00:00:16,400
of service function called

6
00:00:13,120 --> 00:00:19,439
type information in i

7
00:00:16,400 --> 00:00:23,119
f i find word

8
00:00:19,439 --> 00:00:26,080
reversing u e f i find word

9
00:00:23,119 --> 00:00:26,640
requires a lot of background and

10
00:00:26,080 --> 00:00:29,519
knowledge

11
00:00:26,640 --> 00:00:30,640
about fine word and understanding of

12
00:00:29,519 --> 00:00:34,800
hardware before

13
00:00:30,640 --> 00:00:37,440
you can start hunting for moonlit rivals

14
00:00:34,800 --> 00:00:39,160
with this new tool you can automatically

15
00:00:37,440 --> 00:00:43,360
recover surveys called an

16
00:00:39,160 --> 00:00:47,120
afi type info so that unfinger code

17
00:00:43,360 --> 00:00:47,120
looks like your original source

18
00:00:51,600 --> 00:00:57,199
hello echapatti and it's a big pleasure

19
00:00:55,039 --> 00:01:00,719
for us for presenting on this

20
00:00:57,199 --> 00:01:02,960
pawndemic edition so i think uh

21
00:01:00,719 --> 00:01:05,519
it's very important to support the

22
00:01:02,960 --> 00:01:08,080
conferences in these difficult times

23
00:01:05,519 --> 00:01:09,200
and it's not my first time on echo party

24
00:01:08,080 --> 00:01:11,439
and i always

25
00:01:09,200 --> 00:01:12,400
appreciate very advanced technical

26
00:01:11,439 --> 00:01:15,520
audience here

27
00:01:12,400 --> 00:01:17,200
it's why we decide to present about our

28
00:01:15,520 --> 00:01:20,158
efi explorer tool

29
00:01:17,200 --> 00:01:20,799
exactly on echopath and our talk is

30
00:01:20,159 --> 00:01:24,720
actually

31
00:01:20,799 --> 00:01:27,119
about different static analysis

32
00:01:24,720 --> 00:01:28,000
techniques for recover the type

33
00:01:27,119 --> 00:01:30,880
information

34
00:01:28,000 --> 00:01:31,680
and service function calls from ufi

35
00:01:30,880 --> 00:01:33,679
firmware

36
00:01:31,680 --> 00:01:35,680
and i want to introduce you if i explore

37
00:01:33,680 --> 00:01:38,400
our teammates igor vasilenko

38
00:01:35,680 --> 00:01:41,200
philip lebedev andrey labunet and myself

39
00:01:38,400 --> 00:01:43,439
alex matrosso

40
00:01:41,200 --> 00:01:44,320
so motivation of this research it's been

41
00:01:43,439 --> 00:01:47,758
pretty simple

42
00:01:44,320 --> 00:01:49,758
we basically all of us are working on

43
00:01:47,759 --> 00:01:52,000
ufi reverse engineering for quite a

44
00:01:49,759 --> 00:01:52,720
while and we notice that it's not a lot

45
00:01:52,000 --> 00:01:55,759
of

46
00:01:52,720 --> 00:01:58,000
automation tools available on the public

47
00:01:55,759 --> 00:01:58,880
so it is of course very good plugins

48
00:01:58,000 --> 00:02:01,520
available

49
00:01:58,880 --> 00:02:02,880
but unfortunately they mostly support

50
00:02:01,520 --> 00:02:05,679
one single function

51
00:02:02,880 --> 00:02:07,439
implemented on particular pro uh plugin

52
00:02:05,680 --> 00:02:08,000
and it's solving just one problem we

53
00:02:07,439 --> 00:02:11,038
don't find

54
00:02:08,000 --> 00:02:12,640
combination combination of all tools we

55
00:02:11,038 --> 00:02:15,119
needed in one set

56
00:02:12,640 --> 00:02:17,359
and also most of these plugins not

57
00:02:15,120 --> 00:02:20,480
supported for a year so really

58
00:02:17,360 --> 00:02:22,959
and of course it's hard to

59
00:02:20,480 --> 00:02:24,720
use a new version of ida pro and other

60
00:02:22,959 --> 00:02:28,160
servers engineering tools

61
00:02:24,720 --> 00:02:30,720
it's why we basically uh focus on

62
00:02:28,160 --> 00:02:34,079
developing our own to benefit

63
00:02:30,720 --> 00:02:34,720
us and not only us we focused on benefit

64
00:02:34,080 --> 00:02:37,680
for

65
00:02:34,720 --> 00:02:38,560
all the reverse engineering community to

66
00:02:37,680 --> 00:02:41,280
provide them

67
00:02:38,560 --> 00:02:43,519
help your tool which we will be making

68
00:02:41,280 --> 00:02:46,800
you fire reverse engineering hazard

69
00:02:43,519 --> 00:02:48,560
but why it is important to have a ufi

70
00:02:46,800 --> 00:02:52,160
reverse engineering tool

71
00:02:48,560 --> 00:02:54,080
and why you need to uh focus on ufi

72
00:02:52,160 --> 00:02:55,200
firmware various engineering last year

73
00:02:54,080 --> 00:02:58,080
i've been presented

74
00:02:55,200 --> 00:02:59,359
knot on akapati about the advanced

75
00:02:58,080 --> 00:03:02,159
threats evolution

76
00:02:59,360 --> 00:03:02,959
and researchers arm race where i've been

77
00:03:02,159 --> 00:03:05,440
focused

78
00:03:02,959 --> 00:03:07,840
on many different topics and why

79
00:03:05,440 --> 00:03:09,599
persistent vectors will be focused in

80
00:03:07,840 --> 00:03:10,159
the future and actually already focus it

81
00:03:09,599 --> 00:03:12,959
now

82
00:03:10,159 --> 00:03:15,920
on the firmware and hardware more than

83
00:03:12,959 --> 00:03:19,040
operating system level

84
00:03:15,920 --> 00:03:21,920
basically other side of this

85
00:03:19,040 --> 00:03:22,959
it is a supply chain problem on ufi

86
00:03:21,920 --> 00:03:26,000
ecosystem

87
00:03:22,959 --> 00:03:29,280
where we have a multiple vendors and

88
00:03:26,000 --> 00:03:30,799
also frameworks like phoenix inside and

89
00:03:29,280 --> 00:03:33,760
american mega trends

90
00:03:30,799 --> 00:03:35,680
where basically this vendors develop

91
00:03:33,760 --> 00:03:37,599
kind of like universal framework

92
00:03:35,680 --> 00:03:38,720
it's get customized by device

93
00:03:37,599 --> 00:03:41,280
manufacturers

94
00:03:38,720 --> 00:03:42,239
or original equipment manufacturers like

95
00:03:41,280 --> 00:03:45,360
dell lenovo

96
00:03:42,239 --> 00:03:46,000
and hp but in the end they contribute

97
00:03:45,360 --> 00:03:48,480
less than 10

98
00:03:46,000 --> 00:03:50,640
percent of the code base and most of the

99
00:03:48,480 --> 00:03:54,959
code it is intel reference called

100
00:03:50,640 --> 00:03:57,679
edk2 or amd if it's amd based platform

101
00:03:54,959 --> 00:03:59,599
other big part of this code is the

102
00:03:57,680 --> 00:04:01,200
framework from phoenix inside an

103
00:03:59,599 --> 00:04:04,399
american mega trends

104
00:04:01,200 --> 00:04:09,040
and we need to understand actually and

105
00:04:04,400 --> 00:04:11,920
go deep deep on vulnerability hunting

106
00:04:09,040 --> 00:04:14,480
to understand how these issues can

107
00:04:11,920 --> 00:04:16,959
affect different platforms and

108
00:04:14,480 --> 00:04:18,399
basically what the coverage are and what

109
00:04:16,959 --> 00:04:21,040
is the exact impact

110
00:04:18,399 --> 00:04:22,479
it where we need advanced reverse

111
00:04:21,040 --> 00:04:25,600
engineering tools

112
00:04:22,479 --> 00:04:28,400
and basically we need to investigate

113
00:04:25,600 --> 00:04:29,680
how the impact with the persistent

114
00:04:28,400 --> 00:04:32,880
vectors affect

115
00:04:29,680 --> 00:04:35,040
modern platforms but unfortunately

116
00:04:32,880 --> 00:04:36,719
i would say the classification of the

117
00:04:35,040 --> 00:04:38,639
firmware corruption attacks and

118
00:04:36,720 --> 00:04:40,800
persistent vectors it's not really

119
00:04:38,639 --> 00:04:41,600
correct on current meter attack

120
00:04:40,800 --> 00:04:44,479
framework

121
00:04:41,600 --> 00:04:46,160
because it's mostly focused you need to

122
00:04:44,479 --> 00:04:49,360
check the integrity

123
00:04:46,160 --> 00:04:52,400
but the integrity doesn't mean

124
00:04:49,360 --> 00:04:53,919
much about actual impact so if the

125
00:04:52,400 --> 00:04:55,840
integrity is broken

126
00:04:53,919 --> 00:04:58,479
you don't have the full visibility on

127
00:04:55,840 --> 00:04:59,840
the impact and you can't understand what

128
00:04:58,479 --> 00:05:01,758
exactly happens

129
00:04:59,840 --> 00:05:03,520
for that you need to go deep with

130
00:05:01,759 --> 00:05:06,800
reverse engineering tools

131
00:05:03,520 --> 00:05:10,080
and basically understand

132
00:05:06,800 --> 00:05:11,199
what's the actual problem uh the

133
00:05:10,080 --> 00:05:14,320
mitigations

134
00:05:11,199 --> 00:05:15,600
uh provided from os privileges to

135
00:05:14,320 --> 00:05:17,759
reducing some

136
00:05:15,600 --> 00:05:19,919
drivers and other things it's actually

137
00:05:17,759 --> 00:05:20,240
not equal with the firmware privileges

138
00:05:19,919 --> 00:05:22,400
which

139
00:05:20,240 --> 00:05:24,000
i would say don't solve much problem

140
00:05:22,400 --> 00:05:26,239
there you can block

141
00:05:24,000 --> 00:05:27,039
something on the operating system level

142
00:05:26,240 --> 00:05:29,120
but

143
00:05:27,039 --> 00:05:33,360
for the firmware and hardware world

144
00:05:29,120 --> 00:05:37,680
physical attack vectors it's quite huge

145
00:05:33,360 --> 00:05:39,840
updates coming from some vendor sources

146
00:05:37,680 --> 00:05:42,320
but who proves this vendor source is

147
00:05:39,840 --> 00:05:42,320
secure

148
00:05:43,680 --> 00:05:48,720
so basically we trust too much

149
00:05:46,720 --> 00:05:50,080
everything which is coming from the

150
00:05:48,720 --> 00:05:52,400
signing source

151
00:05:50,080 --> 00:05:54,400
right so we have a binary blob which is

152
00:05:52,400 --> 00:05:57,280
signed by trusted vendor

153
00:05:54,400 --> 00:05:59,359
and we trusted by default i would say

154
00:05:57,280 --> 00:06:02,719
antivirus industry in the past

155
00:05:59,360 --> 00:06:05,199
probably uh during last 15 years

156
00:06:02,720 --> 00:06:06,160
learned hard lessons about the sign of

157
00:06:05,199 --> 00:06:09,280
binaries and

158
00:06:06,160 --> 00:06:09,600
trust but why we don't rethink the same

159
00:06:09,280 --> 00:06:12,159
thing

160
00:06:09,600 --> 00:06:13,280
about the firmware problems basically we

161
00:06:12,160 --> 00:06:15,919
blindly trust

162
00:06:13,280 --> 00:06:17,758
anything which is come from trusted

163
00:06:15,919 --> 00:06:20,318
source and sign it right

164
00:06:17,759 --> 00:06:22,240
and it's create a lot of circumstances

165
00:06:20,319 --> 00:06:26,240
and concerns

166
00:06:22,240 --> 00:06:29,039
or basically go over and dig on it so

167
00:06:26,240 --> 00:06:30,160
it's why we start working on efi

168
00:06:29,039 --> 00:06:32,240
explorer

169
00:06:30,160 --> 00:06:33,360
think about this simplifying

170
00:06:32,240 --> 00:06:36,400
reconstruction

171
00:06:33,360 --> 00:06:39,199
you fi specific types and protocols

172
00:06:36,400 --> 00:06:39,840
with efi analyzer we create unified

173
00:06:39,199 --> 00:06:42,080
loader

174
00:06:39,840 --> 00:06:44,080
which is basically try to load the whole

175
00:06:42,080 --> 00:06:47,120
firmware image and rebuild all the

176
00:06:44,080 --> 00:06:50,639
dependencies between different drivers

177
00:06:47,120 --> 00:06:54,639
as example you have the protocol called

178
00:06:50,639 --> 00:06:54,639
the protocol let's say it's kind of like

179
00:06:56,160 --> 00:07:00,400
same thing as a api function in

180
00:06:59,039 --> 00:07:03,599
operating system

181
00:07:00,400 --> 00:07:05,359
binaries and when api call

182
00:07:03,599 --> 00:07:07,280
happens it doesn't mean the

183
00:07:05,360 --> 00:07:09,919
implementation of this protocol

184
00:07:07,280 --> 00:07:11,440
implemented as the same one binary but

185
00:07:09,919 --> 00:07:14,000
you need to find this

186
00:07:11,440 --> 00:07:15,840
binary where this protocol is

187
00:07:14,000 --> 00:07:16,560
implemented to understand the full

188
00:07:15,840 --> 00:07:19,280
workflow

189
00:07:16,560 --> 00:07:21,199
for security feature or something so

190
00:07:19,280 --> 00:07:23,758
it's why these cross references

191
00:07:21,199 --> 00:07:25,599
on the whole firmware image make a lot

192
00:07:23,759 --> 00:07:28,319
of sense

193
00:07:25,599 --> 00:07:30,000
and where where actually if i explorer

194
00:07:28,319 --> 00:07:33,919
stand for

195
00:07:30,000 --> 00:07:37,039
and last last thing we basically develop

196
00:07:33,919 --> 00:07:40,960
kind of like vulnerability

197
00:07:37,039 --> 00:07:43,360
analysis patterns uh with um

198
00:07:40,960 --> 00:07:44,638
with ufi specifics and power of the

199
00:07:43,360 --> 00:07:48,000
static analysis

200
00:07:44,639 --> 00:07:51,440
and we call it vulcan so basically

201
00:07:48,000 --> 00:07:52,080
our vision to turn ufi into the white

202
00:07:51,440 --> 00:07:55,120
box

203
00:07:52,080 --> 00:07:58,400
uh of course like white box uh

204
00:07:55,120 --> 00:08:00,639
it's very powerful word but at least we

205
00:07:58,400 --> 00:08:02,479
try to make it as a white box

206
00:08:00,639 --> 00:08:05,199
simpler as a white box for reverse

207
00:08:02,479 --> 00:08:08,479
engineering okay

208
00:08:05,199 --> 00:08:12,080
so and here is our architecture of

209
00:08:08,479 --> 00:08:13,520
efi explorer analyzer and you can see a

210
00:08:12,080 --> 00:08:16,719
lot of different

211
00:08:13,520 --> 00:08:20,080
features is implemented and yigor

212
00:08:16,720 --> 00:08:20,080
will be continued on it

213
00:08:22,240 --> 00:08:28,080
hello everyone i want to tell you about

214
00:08:24,560 --> 00:08:30,720
df explorer code analyzer

215
00:08:28,080 --> 00:08:33,679
in uefi firmware images data type

216
00:08:30,720 --> 00:08:35,519
information plays a very important role

217
00:08:33,679 --> 00:08:38,000
with all the type information applied

218
00:08:35,519 --> 00:08:39,760
correctly you can do a verified quality

219
00:08:38,000 --> 00:08:42,399
static analysis

220
00:08:39,760 --> 00:08:44,159
let's take a look at a simple example

221
00:08:42,399 --> 00:08:45,040
the first figure shows part of the code

222
00:08:44,159 --> 00:08:48,319
of some function

223
00:08:45,040 --> 00:08:50,079
re5 without any processing the second

224
00:08:48,320 --> 00:08:52,320
figure shows the same code snippet when

225
00:08:50,080 --> 00:08:55,360
casting a global variable to if i system

226
00:08:52,320 --> 00:08:57,040
table data type with pointer

227
00:08:55,360 --> 00:08:59,200
you can see that simple casting of a

228
00:08:57,040 --> 00:09:02,640
global variable to the required type

229
00:08:59,200 --> 00:09:02,640
make the code much clearer

230
00:09:04,640 --> 00:09:09,600
my system table is one of the basic data

231
00:09:06,959 --> 00:09:12,319
structures used in uefi

232
00:09:09,600 --> 00:09:14,160
the file system payments to the good

233
00:09:12,320 --> 00:09:16,880
services runtime services

234
00:09:14,160 --> 00:09:18,959
and other important fields the slide

235
00:09:16,880 --> 00:09:21,920
shows a list of basic data structures to

236
00:09:18,959 --> 00:09:23,760
which you convert global variables

237
00:09:21,920 --> 00:09:24,880
automatic search for global variables

238
00:09:23,760 --> 00:09:26,399
with these types

239
00:09:24,880 --> 00:09:28,959
is the starting point for further

240
00:09:26,399 --> 00:09:28,959
analysis

241
00:09:30,000 --> 00:09:34,240
a huge advantage when analyzing ufi

242
00:09:32,399 --> 00:09:36,399
drivers with either pro

243
00:09:34,240 --> 00:09:39,360
is that ida pro has default type library

244
00:09:36,399 --> 00:09:41,440
specifically for uefi drives

245
00:09:39,360 --> 00:09:44,080
they are contained in the ufi and 2fi

246
00:09:41,440 --> 00:09:47,600
6014 files

247
00:09:44,080 --> 00:09:50,399
this slides on the types from edk2

248
00:09:47,600 --> 00:09:52,320
consider that almost all vendors use dk2

249
00:09:50,399 --> 00:09:53,920
to develop their firmware

250
00:09:52,320 --> 00:09:57,680
these two files should be enough to

251
00:09:53,920 --> 00:09:57,680
analyze most v5 firmware

252
00:09:58,399 --> 00:10:01,839
currently we have a number of methods to

253
00:10:00,160 --> 00:10:02,880
search for different types of global

254
00:10:01,839 --> 00:10:04,640
variables

255
00:10:02,880 --> 00:10:06,480
some of them are very specific and more

256
00:10:04,640 --> 00:10:08,720
complex than others

257
00:10:06,480 --> 00:10:09,760
so let's now go into details about all

258
00:10:08,720 --> 00:10:12,079
methods

259
00:10:09,760 --> 00:10:13,920
instead i will focus on one technique

260
00:10:12,079 --> 00:10:17,120
that we use to find the global variables

261
00:10:13,920 --> 00:10:19,199
jst gps and jrt

262
00:10:17,120 --> 00:10:21,760
for each wifi driver's entry point is

263
00:10:19,200 --> 00:10:24,240
the model entry point function

264
00:10:21,760 --> 00:10:26,319
for drivers such as dicks or smm the

265
00:10:24,240 --> 00:10:28,640
arguments of to this function are image

266
00:10:26,320 --> 00:10:31,360
handle and system table

267
00:10:28,640 --> 00:10:31,760
in some cases such an entry point look

268
00:10:31,360 --> 00:10:35,440
like

269
00:10:31,760 --> 00:10:37,760
one shown on the figure

270
00:10:35,440 --> 00:10:39,680
this is a simplified example we can

271
00:10:37,760 --> 00:10:41,760
analyze the entry point and define four

272
00:10:39,680 --> 00:10:42,959
global variables at once from the input

273
00:10:41,760 --> 00:10:44,959
data

274
00:10:42,959 --> 00:10:46,239
but there are also more complex examples

275
00:10:44,959 --> 00:10:49,119
that are much common

276
00:10:46,240 --> 00:10:50,800
in the practice the figure shows one of

277
00:10:49,120 --> 00:10:53,120
them

278
00:10:50,800 --> 00:10:54,800
in this case the analysis of the entry

279
00:10:53,120 --> 00:10:57,600
point does not provide us with any

280
00:10:54,800 --> 00:11:00,560
important information

281
00:10:57,600 --> 00:11:02,320
how to solve this problem in general

282
00:11:00,560 --> 00:11:05,439
let's start by looking for the global

283
00:11:02,320 --> 00:11:08,399
variables gbs and jit

284
00:11:05,440 --> 00:11:10,320
as noted earlier pointers to the e5 boot

285
00:11:08,399 --> 00:11:11,120
service ascentifier and time services

286
00:11:10,320 --> 00:11:13,120
tables

287
00:11:11,120 --> 00:11:15,839
are contained in the fi system table

288
00:11:13,120 --> 00:11:15,839
structure

289
00:11:16,320 --> 00:11:20,560
the slide shows a section of code on

290
00:11:18,240 --> 00:11:23,040
which the global variables gbs and jti

291
00:11:20,560 --> 00:11:24,959
initialized

292
00:11:23,040 --> 00:11:27,279
for clarity this code has already been

293
00:11:24,959 --> 00:11:30,399
analyzed using f explorer

294
00:11:27,279 --> 00:11:32,560
to find gbs and sd global variables

295
00:11:30,399 --> 00:11:35,760
for 64 bit drivers you need to look for

296
00:11:32,560 --> 00:11:38,000
the instruction set shown in this slide

297
00:11:35,760 --> 00:11:40,839
at this stage we have learned how to

298
00:11:38,000 --> 00:11:43,839
find all the global variables gps and

299
00:11:40,839 --> 00:11:43,839
git

300
00:11:44,000 --> 00:11:48,480
to find the gst variable additionally

301
00:11:46,640 --> 00:11:51,040
you need to find the instructions shown

302
00:11:48,480 --> 00:11:51,040
on the screen

303
00:11:52,320 --> 00:11:55,839
keep in mind that we should search for

304
00:11:54,160 --> 00:11:57,519
those instructions since the code that

305
00:11:55,839 --> 00:12:01,120
precedes the instructions for filling in

306
00:11:57,519 --> 00:12:03,040
the register with gps and git address

307
00:12:01,120 --> 00:12:05,519
having analyze the entire driver code in

308
00:12:03,040 --> 00:12:08,959
this way you can find several global

309
00:12:05,519 --> 00:12:10,880
variables jst gps and git at once

310
00:12:08,959 --> 00:12:12,719
our plugin automatically has global

311
00:12:10,880 --> 00:12:14,880
variables to the desired type

312
00:12:12,720 --> 00:12:16,720
which makes the code readable the

313
00:12:14,880 --> 00:12:18,959
example shows the main idea of how we

314
00:12:16,720 --> 00:12:20,880
search those global variables

315
00:12:18,959 --> 00:12:22,839
actual methods are slightly more complex

316
00:12:20,880 --> 00:12:24,000
and there are many edge cases we handle

317
00:12:22,839 --> 00:12:26,079
separately

318
00:12:24,000 --> 00:12:30,320
for more details feel free to take a

319
00:12:26,079 --> 00:12:30,319
look at source code in the repository

320
00:12:30,639 --> 00:12:34,720
our plugin can find boot services

321
00:12:32,639 --> 00:12:36,959
runtime services as smart services and

322
00:12:34,720 --> 00:12:40,000
bi services

323
00:12:36,959 --> 00:12:41,680
the figure shows the search result

324
00:12:40,000 --> 00:12:44,000
the search for each type of services

325
00:12:41,680 --> 00:12:47,199
stimuli let's take a look at it using

326
00:12:44,000 --> 00:12:47,200
boot services example

327
00:12:47,360 --> 00:12:51,680
consider the code snippet shown in the

328
00:12:49,040 --> 00:12:53,439
figure suppose we have already defined

329
00:12:51,680 --> 00:12:55,760
the global variables gps

330
00:12:53,440 --> 00:12:56,720
as shown in the previous step and want

331
00:12:55,760 --> 00:12:58,399
to understand

332
00:12:56,720 --> 00:13:01,200
which of service causes made to a

333
00:12:58,399 --> 00:13:02,959
specific address

334
00:13:01,200 --> 00:13:07,839
the rust register contains the base

335
00:13:02,959 --> 00:13:07,839
address of efi boot services structure

336
00:13:08,079 --> 00:13:12,479
accordingly the create event service is

337
00:13:10,560 --> 00:13:15,839
located at the address rex plus

338
00:13:12,480 --> 00:13:16,720
plus 50 h since it is located i said 50

339
00:13:15,839 --> 00:13:21,839
age

340
00:13:16,720 --> 00:13:21,839
attracted good services structure

341
00:13:22,320 --> 00:13:26,320
based on this principle we search for

342
00:13:24,560 --> 00:13:29,839
all good services

343
00:13:26,320 --> 00:13:32,000
the algorithm is shown on the slide

344
00:13:29,839 --> 00:13:35,839
this is what tf explorer does to find

345
00:13:32,000 --> 00:13:35,839
good services calls

346
00:13:37,600 --> 00:13:41,199
the first figure shows the code snippet

347
00:13:39,519 --> 00:13:42,240
from the example after the plugin is

348
00:13:41,199 --> 00:13:44,079
running

349
00:13:42,240 --> 00:13:46,079
the second figure shows the same code in

350
00:13:44,079 --> 00:13:47,920
the compiler

351
00:13:46,079 --> 00:13:50,000
wix the minds algorithm for finding

352
00:13:47,920 --> 00:13:50,959
services calls using the example of boot

353
00:13:50,000 --> 00:13:53,040
services

354
00:13:50,959 --> 00:13:54,880
in the case of runtime services smm

355
00:13:53,040 --> 00:13:57,599
services pi services

356
00:13:54,880 --> 00:13:59,439
the algorithm is similar some edge cases

357
00:13:57,600 --> 00:14:01,839
are not been handled at the moment

358
00:13:59,440 --> 00:14:04,000
but very aware of their existence for

359
00:14:01,839 --> 00:14:06,959
example passing control to a service via

360
00:14:04,000 --> 00:14:06,959
jump instruction

361
00:14:09,279 --> 00:14:13,600
another feature of yet explorer is to

362
00:14:11,279 --> 00:14:15,120
recognize the five protocols associated

363
00:14:13,600 --> 00:14:16,880
with boot services and the cement

364
00:14:15,120 --> 00:14:18,639
services

365
00:14:16,880 --> 00:14:20,720
the f5 protocol consists of an

366
00:14:18,639 --> 00:14:23,680
identifier for the whole grid

367
00:14:20,720 --> 00:14:25,760
and the protocol interface structure

368
00:14:23,680 --> 00:14:28,479
there are some services in uefi designed

369
00:14:25,760 --> 00:14:30,399
to work with protocols

370
00:14:28,480 --> 00:14:32,880
the slide shows a list of such services

371
00:14:30,399 --> 00:14:35,120
from e5 good service incentivized mem

372
00:14:32,880 --> 00:14:36,880
system table

373
00:14:35,120 --> 00:14:38,639
suppose you have already found such

374
00:14:36,880 --> 00:14:42,240
sources in the code of the driver been

375
00:14:38,639 --> 00:14:42,240
analyzed as described in the previous

376
00:14:42,839 --> 00:14:46,320
step

377
00:14:44,720 --> 00:14:47,760
let's look at the call to the locate

378
00:14:46,320 --> 00:14:50,560
protocol service

379
00:14:47,760 --> 00:14:52,000
which is shown in the figure the first

380
00:14:50,560 --> 00:14:53,760
argument to this function is the

381
00:14:52,000 --> 00:14:56,000
protocol we need to locate

382
00:14:53,760 --> 00:14:57,680
and the third argument is the protocol

383
00:14:56,000 --> 00:14:59,839
interface

384
00:14:57,680 --> 00:15:01,680
there are some similarities here with

385
00:14:59,839 --> 00:15:04,079
the corvette class object function from

386
00:15:01,680 --> 00:15:05,839
the component object model

387
00:15:04,079 --> 00:15:07,199
from the input parameters to zlata

388
00:15:05,839 --> 00:15:09,120
protocol function

389
00:15:07,199 --> 00:15:11,519
we can easily get the variable of the

390
00:15:09,120 --> 00:15:13,360
protocol grid entry

391
00:15:11,519 --> 00:15:15,360
then using the grid we can understand

392
00:15:13,360 --> 00:15:17,519
what kind of protocol it is

393
00:15:15,360 --> 00:15:20,160
to do this we look for the given grid in

394
00:15:17,519 --> 00:15:22,480
the prepared dictionary of grids

395
00:15:20,160 --> 00:15:23,839
we move this dictionary to grid json

396
00:15:22,480 --> 00:15:25,839
file

397
00:15:23,839 --> 00:15:27,760
if the grid is found we give the

398
00:15:25,839 --> 00:15:29,600
protocol a name and put it in the list

399
00:15:27,760 --> 00:15:31,199
of found protocols

400
00:15:29,600 --> 00:15:33,440
if the grid is not found in our

401
00:15:31,199 --> 00:15:37,120
dictionary we consider it proprietary

402
00:15:33,440 --> 00:15:37,120
and called proprietary protocol

403
00:15:38,160 --> 00:15:42,160
we perform similar actions with each of

404
00:15:40,480 --> 00:15:43,920
the listed services

405
00:15:42,160 --> 00:15:45,360
the only difference is in which

406
00:15:43,920 --> 00:15:46,319
arguments the protocol will lead to the

407
00:15:45,360 --> 00:15:48,240
past

408
00:15:46,320 --> 00:15:49,839
as a result we get another window ef

409
00:15:48,240 --> 00:15:51,920
explorer protocols

410
00:15:49,839 --> 00:15:53,920
which contains all protocols grids and

411
00:15:51,920 --> 00:15:54,880
names services that work with this

412
00:15:53,920 --> 00:15:56,160
product cost

413
00:15:54,880 --> 00:15:59,839
as well as the addresses of the

414
00:15:56,160 --> 00:16:02,399
protocols grids in the data segment

415
00:15:59,839 --> 00:16:04,160
identifying protocols is very useful

416
00:16:02,399 --> 00:16:05,440
feature to understand cross references

417
00:16:04,160 --> 00:16:09,040
between different

418
00:16:05,440 --> 00:16:10,720
uefi executables about the

419
00:16:09,040 --> 00:16:12,480
course we can understand in which driver

420
00:16:10,720 --> 00:16:14,560
a particular protocol was installed

421
00:16:12,480 --> 00:16:16,800
using the installed protocol interface

422
00:16:14,560 --> 00:16:17,680
or install multiple protocol interfaces

423
00:16:16,800 --> 00:16:19,599
services

424
00:16:17,680 --> 00:16:21,680
and in which drivers the same protocol

425
00:16:19,600 --> 00:16:24,320
was obtained using the locate protocol

426
00:16:21,680 --> 00:16:26,160
open protocol service this will help us

427
00:16:24,320 --> 00:16:28,560
to trace the sequence of execution of

428
00:16:26,160 --> 00:16:31,199
the uefi drivers

429
00:16:28,560 --> 00:16:33,199
guides and uefi very important we have

430
00:16:31,199 --> 00:16:34,880
already covered how guides are used in

431
00:16:33,199 --> 00:16:36,800
identifying protocols

432
00:16:34,880 --> 00:16:39,519
but in fact they are used when working

433
00:16:36,800 --> 00:16:42,719
with many things in uefi

434
00:16:39,519 --> 00:16:44,720
with advanced variables images and so on

435
00:16:42,720 --> 00:16:46,480
this is why ef explorer has a feature to

436
00:16:44,720 --> 00:16:48,320
search for buildsum on local and global

437
00:16:46,480 --> 00:16:49,920
variables

438
00:16:48,320 --> 00:16:52,160
the stretch is carried out using the

439
00:16:49,920 --> 00:16:53,920
same dictionary from with json

440
00:16:52,160 --> 00:16:56,000
it is located in a separate file for

441
00:16:53,920 --> 00:16:58,160
better extensibility

442
00:16:56,000 --> 00:17:00,000
as a result of the plug-in walk all

443
00:16:58,160 --> 00:17:01,439
found grids will be renamed and placed

444
00:17:00,000 --> 00:17:05,439
in a separate window

445
00:17:01,440 --> 00:17:06,400
as on a slide i partially talked about

446
00:17:05,439 --> 00:17:08,319
the features and the

447
00:17:06,400 --> 00:17:09,760
internal structure of the af explorer

448
00:17:08,319 --> 00:17:11,359
analyzer section

449
00:17:09,760 --> 00:17:13,520
you can see everything that i have not

450
00:17:11,359 --> 00:17:16,079
told the first one

451
00:17:13,520 --> 00:17:17,439
now i will hand out to philly who will

452
00:17:16,079 --> 00:17:19,599
tell you about the loader

453
00:17:17,439 --> 00:17:22,160
what is it how it works and why it's so

454
00:17:19,599 --> 00:17:22,159
important

455
00:17:27,599 --> 00:17:34,000
hi everyone my name is philip

456
00:17:31,440 --> 00:17:36,640
and i'm very happy to introduce the

457
00:17:34,000 --> 00:17:39,039
second part of the efi explorer

458
00:17:36,640 --> 00:17:46,640
which is responsible to load and analyze

459
00:17:39,039 --> 00:17:48,879
the all firmware

460
00:17:46,640 --> 00:17:50,400
but first of all uh let me just share a

461
00:17:48,880 --> 00:17:51,520
few thoughts about the wifi firmware

462
00:17:50,400 --> 00:17:53,440
rails engineer

463
00:17:51,520 --> 00:17:54,960
exactly how the wi-fi firmware rarest

464
00:17:53,440 --> 00:17:56,799
engineering looks like

465
00:17:54,960 --> 00:17:58,640
everybody know that the common e5

466
00:17:56,799 --> 00:18:01,760
firmware steps for everything

467
00:17:58,640 --> 00:18:02,799
are next firstly oe5 firmware is loaded

468
00:18:01,760 --> 00:18:04,640
into the wi-fi

469
00:18:02,799 --> 00:18:06,400
tool or another kind of software which

470
00:18:04,640 --> 00:18:09,600
is responsible to parse and

471
00:18:06,400 --> 00:18:11,360
iterate through dick synthesis mem dixie

472
00:18:09,600 --> 00:18:13,360
combined drivers etc

473
00:18:11,360 --> 00:18:15,120
then the security experts chooses which

474
00:18:13,360 --> 00:18:16,080
driver is more interesting to

475
00:18:15,120 --> 00:18:18,959
investigate

476
00:18:16,080 --> 00:18:21,360
and extract it and then the extracted

477
00:18:18,960 --> 00:18:23,760
driver is loaded into the either pro or

478
00:18:21,360 --> 00:18:23,760
jitra

479
00:18:26,480 --> 00:18:31,919
but let's imagine if the

480
00:18:29,840 --> 00:18:32,959
whole image can be loaded and

481
00:18:31,919 --> 00:18:35,679
investigated

482
00:18:32,960 --> 00:18:36,880
as a single binary like dropping the old

483
00:18:35,679 --> 00:18:43,840
wifi firmware

484
00:18:36,880 --> 00:18:43,840
into the id pro instance and reverse it

485
00:18:45,919 --> 00:18:51,360
actually this idea is not no is not new

486
00:18:49,440 --> 00:18:53,200
and was implemented in the project named

487
00:18:51,360 --> 00:18:55,439
jidra firmware utilities

488
00:18:53,200 --> 00:18:57,760
which is very cool but unfortunately

489
00:18:55,440 --> 00:18:59,440
such loader exists only for jitra and

490
00:18:57,760 --> 00:19:01,760
there is no possibility to create

491
00:18:59,440 --> 00:19:03,679
data code references between different

492
00:19:01,760 --> 00:19:05,200
drivers but it's very important because

493
00:19:03,679 --> 00:19:06,400
there are so many interactions and

494
00:19:05,200 --> 00:19:08,320
dependencies between

495
00:19:06,400 --> 00:19:10,160
different drivers for example like

496
00:19:08,320 --> 00:19:11,678
already mentioned we fi protocols

497
00:19:10,160 --> 00:19:13,440
registration locating

498
00:19:11,679 --> 00:19:16,160
which are very important during firmware

499
00:19:13,440 --> 00:19:16,160
investigation

500
00:19:18,960 --> 00:19:22,400
and now i would like to introduce the

501
00:19:21,520 --> 00:19:25,600
core features

502
00:19:22,400 --> 00:19:27,120
of efex loader which is responsible to

503
00:19:25,600 --> 00:19:29,600
simplify the way of

504
00:19:27,120 --> 00:19:31,039
wifi firmware reverse engineer effects

505
00:19:29,600 --> 00:19:33,439
loader as it says is an

506
00:19:31,039 --> 00:19:34,160
id pro loader model which makes possible

507
00:19:33,440 --> 00:19:37,120
to load

508
00:19:34,160 --> 00:19:38,720
each 64 bit wifi driver into single

509
00:19:37,120 --> 00:19:41,199
either database

510
00:19:38,720 --> 00:19:42,480
current version of efx loader uses ofi

511
00:19:41,200 --> 00:19:44,240
tool parser engine

512
00:19:42,480 --> 00:19:46,000
which handles all your five parsing

513
00:19:44,240 --> 00:19:47,679
routines and

514
00:19:46,000 --> 00:19:50,480
each expert can easily navigate within

515
00:19:47,679 --> 00:19:51,760
the old wifi firmware and investigate

516
00:19:50,480 --> 00:19:53,600
each wifi driver

517
00:19:51,760 --> 00:19:55,360
if you close look on the slide you can

518
00:19:53,600 --> 00:19:56,399
see that each driver is located in

519
00:19:55,360 --> 00:19:58,879
separate section

520
00:19:56,400 --> 00:20:00,880
with data and code embedded so we can

521
00:19:58,880 --> 00:20:06,320
easily negate from drive to driver and

522
00:20:00,880 --> 00:20:09,360
make references between them

523
00:20:06,320 --> 00:20:09,678
by the way it's very important to notice

524
00:20:09,360 --> 00:20:12,320
that

525
00:20:09,679 --> 00:20:13,120
the fx loader identifies each driver

526
00:20:12,320 --> 00:20:15,280
entry point

527
00:20:13,120 --> 00:20:20,559
that provides a choice for an expert

528
00:20:15,280 --> 00:20:23,918
where to start reverse engineering

529
00:20:20,559 --> 00:20:24,559
but the most suddenly significant

530
00:20:23,919 --> 00:20:27,360
feature

531
00:20:24,559 --> 00:20:29,039
is that most of efe explorer features

532
00:20:27,360 --> 00:20:31,520
are supported by a load

533
00:20:29,039 --> 00:20:32,559
so qualify structures like boot services

534
00:20:31,520 --> 00:20:34,400
runtime services

535
00:20:32,559 --> 00:20:35,600
well known that preparatory protocols

536
00:20:34,400 --> 00:20:39,440
can be identified

537
00:20:35,600 --> 00:20:39,439
within the all firmware

538
00:20:40,240 --> 00:20:44,960
and now let's talk about a bit more

539
00:20:43,039 --> 00:20:47,600
about the protocols registration

540
00:20:44,960 --> 00:20:49,440
and usage as i said before protocols are

541
00:20:47,600 --> 00:20:50,879
key objects which are processed during

542
00:20:49,440 --> 00:20:53,120
firmware execution

543
00:20:50,880 --> 00:20:54,880
and there is a well-known case when some

544
00:20:53,120 --> 00:20:58,080
particles are registered

545
00:20:54,880 --> 00:21:00,559
and used in different drivers the old

546
00:20:58,080 --> 00:21:03,120
way of protocol interface identification

547
00:21:00,559 --> 00:21:05,760
is to iterate through list of drivers

548
00:21:03,120 --> 00:21:08,158
and find out which one one is used for

549
00:21:05,760 --> 00:21:09,120
registration or which one used for the

550
00:21:08,159 --> 00:21:11,679
locating

551
00:21:09,120 --> 00:21:13,840
but the new way is just to trigger efa

552
00:21:11,679 --> 00:21:15,440
explorer on the full wi-fi image

553
00:21:13,840 --> 00:21:18,080
and navigate from the address of

554
00:21:15,440 --> 00:21:19,679
registration and the address of usage

555
00:21:18,080 --> 00:21:22,158
and now i would like to show you how it

556
00:21:19,679 --> 00:21:22,159
looks like

557
00:21:22,960 --> 00:21:28,320
consider we got a next feature as

558
00:21:26,400 --> 00:21:30,000
far as we know that efi explorer

559
00:21:28,320 --> 00:21:31,280
constructs a table of services

560
00:21:30,000 --> 00:21:33,200
which can be executed within the

561
00:21:31,280 --> 00:21:35,918
firmware it's easy to see

562
00:21:33,200 --> 00:21:38,480
on this slide that some preparatory

563
00:21:35,919 --> 00:21:38,480
protocol

564
00:21:38,640 --> 00:21:42,799
grid used for installing in locating

565
00:21:40,720 --> 00:21:44,400
protocol for example in this slide is

566
00:21:42,799 --> 00:21:46,960
marked by blue color

567
00:21:44,400 --> 00:21:47,600
the grid with protocol which is

568
00:21:46,960 --> 00:21:51,760
installing

569
00:21:47,600 --> 00:21:54,719
interface and one which is bellow him

570
00:21:51,760 --> 00:21:56,799
below it it's just located protocol but

571
00:21:54,720 --> 00:21:58,400
if we look closely on the left column we

572
00:21:56,799 --> 00:22:00,960
can identify that the

573
00:21:58,400 --> 00:22:01,520
addresses of each reference are pretty

574
00:22:00,960 --> 00:22:04,240
different

575
00:22:01,520 --> 00:22:05,039
so it closely look like it's different

576
00:22:04,240 --> 00:22:08,159
drivers

577
00:22:05,039 --> 00:22:09,200
using the same protocol and let's

578
00:22:08,159 --> 00:22:12,559
navigate to the

579
00:22:09,200 --> 00:22:14,880
each of these references and according

580
00:22:12,559 --> 00:22:14,879
to the

581
00:22:15,200 --> 00:22:21,919
next picture uh we can

582
00:22:18,720 --> 00:22:23,360
defy define this protocol used by two

583
00:22:21,919 --> 00:22:26,640
drivers

584
00:22:23,360 --> 00:22:29,199
all of them are based on the amd uh name

585
00:22:26,640 --> 00:22:31,039
so we can easily identify that there are

586
00:22:29,200 --> 00:22:31,600
pretty different two drivers but using

587
00:22:31,039 --> 00:22:34,559
the

588
00:22:31,600 --> 00:22:35,439
uh single protocol single grid protocol

589
00:22:34,559 --> 00:22:38,559
and now

590
00:22:35,440 --> 00:22:41,360
let's just go further and identify

591
00:22:38,559 --> 00:22:44,158
which interface is used for the

592
00:22:41,360 --> 00:22:44,158
registration

593
00:22:47,679 --> 00:22:52,640
when we locate to driver where install

594
00:22:50,640 --> 00:22:54,720
protocol interface is triggered

595
00:22:52,640 --> 00:22:56,559
the global variable passes function

596
00:22:54,720 --> 00:22:58,720
points to the interface

597
00:22:56,559 --> 00:22:59,600
that means that protocol interface is

598
00:22:58,720 --> 00:23:02,320
identified

599
00:22:59,600 --> 00:23:04,399
it can be used like reference when we

600
00:23:02,320 --> 00:23:07,520
look at the another driver locates

601
00:23:04,400 --> 00:23:08,080
by this grid and on the next picture we

602
00:23:07,520 --> 00:23:11,200
can

603
00:23:08,080 --> 00:23:22,799
identify the global variable well this

604
00:23:11,200 --> 00:23:25,840
uh keyword is points to

605
00:23:22,799 --> 00:23:28,240
yes on this picture we can find out the

606
00:23:25,840 --> 00:23:28,959
the exactly the same reference and

607
00:23:28,240 --> 00:23:32,080
information

608
00:23:28,960 --> 00:23:33,520
about the interface

609
00:23:32,080 --> 00:23:35,520
but now i would like to continue with

610
00:23:33,520 --> 00:23:37,520
the more interesting

611
00:23:35,520 --> 00:23:40,879
features like vulnerability discovery

612
00:23:37,520 --> 00:23:43,520
using the efix loader plus efi explorer

613
00:23:40,880 --> 00:23:45,679
and now i would like to talk about the

614
00:23:43,520 --> 00:23:47,279
more close about the smm clouds

615
00:23:45,679 --> 00:23:50,880
identification

616
00:23:47,279 --> 00:23:51,360
if every firmware security experts know

617
00:23:50,880 --> 00:23:54,640
that this

618
00:23:51,360 --> 00:23:54,959
my handler is a place where smm clouds

619
00:23:54,640 --> 00:23:58,159
might

620
00:23:54,960 --> 00:24:01,360
cure but let's just remind to

621
00:23:58,159 --> 00:24:04,799
each other uh how the

622
00:24:01,360 --> 00:24:07,918
smm cloud exploitation looks like

623
00:24:04,799 --> 00:24:09,679
assume we got a a simple example

624
00:24:07,919 --> 00:24:11,360
like presented on the slide when we got

625
00:24:09,679 --> 00:24:14,000
a runtime service

626
00:24:11,360 --> 00:24:16,840
get variable which is triggered within

627
00:24:14,000 --> 00:24:19,840
the smi

628
00:24:16,840 --> 00:24:19,840
handler

629
00:24:20,159 --> 00:24:23,840
that means that the attacker with root

630
00:24:23,120 --> 00:24:25,918
access

631
00:24:23,840 --> 00:24:27,840
can run malicious code with sms

632
00:24:25,919 --> 00:24:29,600
privileges to achieve that

633
00:24:27,840 --> 00:24:31,279
that is necessary to identify the

634
00:24:29,600 --> 00:24:33,600
runtime services address

635
00:24:31,279 --> 00:24:34,720
it's pretty easy with the help of edk

636
00:24:33,600 --> 00:24:36,719
shell and

637
00:24:34,720 --> 00:24:38,559
command memory which just brings

638
00:24:36,720 --> 00:24:41,039
information about the system table

639
00:24:38,559 --> 00:24:44,158
address runtime services boot services

640
00:24:41,039 --> 00:24:45,919
and etc and usually unfortunately such

641
00:24:44,159 --> 00:24:46,799
address are not changed across the

642
00:24:45,919 --> 00:24:48,880
system reboots

643
00:24:46,799 --> 00:24:51,279
so the attacker can store the address

644
00:24:48,880 --> 00:24:54,000
value and use it during the exploit

645
00:24:51,279 --> 00:24:54,000
development

646
00:24:55,200 --> 00:24:58,480
everybody knows about the cheapsick

647
00:24:56,720 --> 00:25:00,720
framework is a big help

648
00:24:58,480 --> 00:25:02,640
in exploitation and proof of concept

649
00:25:00,720 --> 00:25:05,039
development writing tasks

650
00:25:02,640 --> 00:25:06,080
so to write an exploit or the proof of

651
00:25:05,039 --> 00:25:09,360
concept the

652
00:25:06,080 --> 00:25:11,600
attacker needs to two things first one

653
00:25:09,360 --> 00:25:12,399
is to prepare memory region with a shell

654
00:25:11,600 --> 00:25:14,959
code

655
00:25:12,400 --> 00:25:16,320
and the second one is to override get

656
00:25:14,960 --> 00:25:18,000
variable runtime service

657
00:25:16,320 --> 00:25:19,600
by the shell code but we need to keep in

658
00:25:18,000 --> 00:25:21,919
mind that the address of the

659
00:25:19,600 --> 00:25:22,879
get viable android time services already

660
00:25:21,919 --> 00:25:25,520
known so make

661
00:25:22,880 --> 00:25:27,679
you can just keep close look on the

662
00:25:25,520 --> 00:25:31,440
slide you find out the address

663
00:25:27,679 --> 00:25:33,840
and we get a plus 40 hex 48 just

664
00:25:31,440 --> 00:25:35,279
to point to the get variable so we're

665
00:25:33,840 --> 00:25:37,840
writing

666
00:25:35,279 --> 00:25:40,240
where we overwrite the address by our

667
00:25:37,840 --> 00:25:42,879
shell code

668
00:25:40,240 --> 00:25:43,600
and the last step and the final step is

669
00:25:42,880 --> 00:25:46,159
just to

670
00:25:43,600 --> 00:25:48,000
trigger smi handle followed by the

671
00:25:46,159 --> 00:25:50,480
malicious get variable function

672
00:25:48,000 --> 00:25:52,240
and finally we can say that attacker

673
00:25:50,480 --> 00:25:53,360
will achieve the smm privilege

674
00:25:52,240 --> 00:25:56,720
escalation with

675
00:25:53,360 --> 00:25:58,639
code execution

676
00:25:56,720 --> 00:26:00,559
and now i would like to talk about the

677
00:25:58,640 --> 00:26:02,640
how such cases can be easily

678
00:26:00,559 --> 00:26:05,520
uh identified and investigated with the

679
00:26:02,640 --> 00:26:07,600
help of efe explorer and the fx loader

680
00:26:05,520 --> 00:26:09,440
we introduced the semi-automatic way of

681
00:26:07,600 --> 00:26:11,520
a cement allows identification

682
00:26:09,440 --> 00:26:12,559
within the all firmware using static

683
00:26:11,520 --> 00:26:15,918
analysis

684
00:26:12,559 --> 00:26:17,360
since fx loader can trigger ef explorer

685
00:26:15,919 --> 00:26:19,840
analysis routines

686
00:26:17,360 --> 00:26:21,840
it's possible to identify different

687
00:26:19,840 --> 00:26:25,840
runtime boot services executing

688
00:26:21,840 --> 00:26:29,039
within the smm

689
00:26:25,840 --> 00:26:30,080
let's just remind how this my handle can

690
00:26:29,039 --> 00:26:32,720
be registered

691
00:26:30,080 --> 00:26:33,439
on this slide we can find out the efi

692
00:26:32,720 --> 00:26:35,440
sms

693
00:26:33,440 --> 00:26:37,520
dispatch protocol registration which

694
00:26:35,440 --> 00:26:39,600
gathered two functions like register

695
00:26:37,520 --> 00:26:41,279
and unregister so we can easily just

696
00:26:39,600 --> 00:26:42,959
iterate through the code base of the

697
00:26:41,279 --> 00:26:45,520
file firmware and identify

698
00:26:42,960 --> 00:26:46,720
each place where register function is

699
00:26:45,520 --> 00:26:48,720
called

700
00:26:46,720 --> 00:26:50,320
and now let's look at the disassembled

701
00:26:48,720 --> 00:26:52,799
view of the

702
00:26:50,320 --> 00:26:56,000
uh how how this function can be

703
00:26:52,799 --> 00:26:59,039
triggered within the wi-fi firmware

704
00:26:56,000 --> 00:27:02,240
on the next picture we can find out

705
00:26:59,039 --> 00:27:04,960
that the register rdx

706
00:27:02,240 --> 00:27:06,559
can be used for the storing the smi

707
00:27:04,960 --> 00:27:09,919
handler

708
00:27:06,559 --> 00:27:13,120
smi handler uh pointer

709
00:27:09,919 --> 00:27:14,480
so if we just collecting the air dx

710
00:27:13,120 --> 00:27:18,000
value

711
00:27:14,480 --> 00:27:20,480
we can store the address

712
00:27:18,000 --> 00:27:22,480
and just collect it into the database

713
00:27:20,480 --> 00:27:25,679
just marking that this function

714
00:27:22,480 --> 00:27:25,679
is as my handler

715
00:27:31,200 --> 00:27:35,520
yes it looks by this view so we got a

716
00:27:34,000 --> 00:27:38,880
rdx

717
00:27:35,520 --> 00:27:42,879
and now we can just make a close

718
00:27:38,880 --> 00:27:44,720
look at the decompiled view where the

719
00:27:42,880 --> 00:27:48,320
we can find out that the second argument

720
00:27:44,720 --> 00:27:51,200
is indeed as my handler pointer

721
00:27:48,320 --> 00:27:52,000
right yes and yes it's called register

722
00:27:51,200 --> 00:27:55,760
function

723
00:27:52,000 --> 00:27:59,200
so and now i would like to introduce

724
00:27:55,760 --> 00:28:00,840
how this can be collected during efi

725
00:27:59,200 --> 00:28:03,679
explorer

726
00:28:00,840 --> 00:28:05,600
execution on the left side we got a

727
00:28:03,679 --> 00:28:07,440
i'm we're just triggering the efi

728
00:28:05,600 --> 00:28:10,639
explorer when the

729
00:28:07,440 --> 00:28:11,600
if when the wii fi firmware is already

730
00:28:10,640 --> 00:28:14,000
loaded

731
00:28:11,600 --> 00:28:16,080
into the i i the database just

732
00:28:14,000 --> 00:28:18,320
triggering the efi explorer

733
00:28:16,080 --> 00:28:20,080
plugin and on the right side we can can

734
00:28:18,320 --> 00:28:23,760
see just produce the table

735
00:28:20,080 --> 00:28:26,799
with the enumerated smi handlers

736
00:28:23,760 --> 00:28:29,760
so now i would like to introduce the

737
00:28:26,799 --> 00:28:31,279
small demo which shows how it's pretty

738
00:28:29,760 --> 00:28:34,158
easy to identify

739
00:28:31,279 --> 00:28:35,679
using the if i explore smm call-outs so

740
00:28:34,159 --> 00:28:38,559
now we're just doing the similar thing

741
00:28:35,679 --> 00:28:40,799
we just identified the smi handlers and

742
00:28:38,559 --> 00:28:42,879
find out the similar bug when the gate

743
00:28:40,799 --> 00:28:43,600
variable just triggered within smi

744
00:28:42,880 --> 00:28:46,480
handler

745
00:28:43,600 --> 00:28:48,080
and we can mark it like smm cloud so we

746
00:28:46,480 --> 00:28:50,159
just used for about

747
00:28:48,080 --> 00:28:52,080
how much i guess about the three seconds

748
00:28:50,159 --> 00:28:54,559
four seconds to identify the bug

749
00:28:52,080 --> 00:28:57,039
and the firmware when we just looked it

750
00:28:54,559 --> 00:29:00,080
it's something like was there

751
00:28:57,039 --> 00:29:00,720
pretty fresh and it may be just a zero

752
00:29:00,080 --> 00:29:03,279
day

753
00:29:00,720 --> 00:29:04,559
on the previous demo yes and about the

754
00:29:03,279 --> 00:29:07,600
limitations

755
00:29:04,559 --> 00:29:08,000
uh there are two key limitations which

756
00:29:07,600 --> 00:29:10,399
we'll

757
00:29:08,000 --> 00:29:12,399
try to resolve in the future first one

758
00:29:10,399 --> 00:29:14,959
is that the fx loader does not support

759
00:29:12,399 --> 00:29:18,158
ve and 32 bits drivers

760
00:29:14,960 --> 00:29:20,320
and they may cure some rare fail false

761
00:29:18,159 --> 00:29:23,520
positive references when the driver

762
00:29:20,320 --> 00:29:25,439
got a fixed base address but on the next

763
00:29:23,520 --> 00:29:28,320
i will show you how we'll try to resolve

764
00:29:25,440 --> 00:29:28,320
this in the future

765
00:29:28,559 --> 00:29:34,320
and about our future plans

766
00:29:31,600 --> 00:29:35,279
yes first we need to add the 32-bit

767
00:29:34,320 --> 00:29:37,439
binaries

768
00:29:35,279 --> 00:29:39,200
maybe we just can convert them from set

769
00:29:37,440 --> 00:29:42,720
to beast to 64

770
00:29:39,200 --> 00:29:45,679
or just to ask user to select from

771
00:29:42,720 --> 00:29:46,720
32 bits to 64. it all depends on the

772
00:29:45,679 --> 00:29:49,279
community

773
00:29:46,720 --> 00:29:51,520
the second point we will add the relocks

774
00:29:49,279 --> 00:29:52,559
relocation section patching which can

775
00:29:51,520 --> 00:29:55,120
resolve the

776
00:29:52,559 --> 00:29:56,559
issues when the driver got a fixed

777
00:29:55,120 --> 00:29:58,959
image-based address

778
00:29:56,559 --> 00:30:00,240
and i would like to add two more

779
00:29:58,960 --> 00:30:03,200
features like

780
00:30:00,240 --> 00:30:04,000
embedding and variables into the id

781
00:30:03,200 --> 00:30:06,320
database

782
00:30:04,000 --> 00:30:07,039
just to make references between the

783
00:30:06,320 --> 00:30:10,158
dixie

784
00:30:07,039 --> 00:30:13,440
between the drivers and and variables

785
00:30:10,159 --> 00:30:14,080
just to to investigate the code base

786
00:30:13,440 --> 00:30:16,320
when

787
00:30:14,080 --> 00:30:18,000
maybe some kind of security issues when

788
00:30:16,320 --> 00:30:21,678
driver got a wrong

789
00:30:18,000 --> 00:30:24,960
uh wrong handling there and variables

790
00:30:21,679 --> 00:30:25,360
and next one try it statically to match

791
00:30:24,960 --> 00:30:28,240
this

792
00:30:25,360 --> 00:30:28,719
my numbers and this handlers in static

793
00:30:28,240 --> 00:30:31,679
way

794
00:30:28,720 --> 00:30:33,120
so it can really simplify the way of to

795
00:30:31,679 --> 00:30:35,679
write the proof of concept

796
00:30:33,120 --> 00:30:37,840
or exploit template without access to

797
00:30:35,679 --> 00:30:39,840
the real device

798
00:30:37,840 --> 00:30:40,879
and now i would like to give a flaw to

799
00:30:39,840 --> 00:30:43,678
the andrew

800
00:30:40,880 --> 00:30:43,679
with his topic

801
00:30:45,120 --> 00:30:49,279
hello so now that we know how to

802
00:30:47,919 --> 00:30:51,919
basically do

803
00:30:49,279 --> 00:30:53,919
the fundamental analysis and to

804
00:30:51,919 --> 00:30:55,279
understand how firmware works with the

805
00:30:53,919 --> 00:30:57,760
context of the

806
00:30:55,279 --> 00:30:59,440
of the whole image the next question is

807
00:30:57,760 --> 00:31:05,840
to understand how good

808
00:30:59,440 --> 00:31:05,840
efi explorer is at doing its job

809
00:31:06,080 --> 00:31:09,678
and on the next slide you can see that

810
00:31:08,720 --> 00:31:11,840
there are some

811
00:31:09,679 --> 00:31:14,000
basic really most important

812
00:31:11,840 --> 00:31:15,600
functionalities by the efi explorer it's

813
00:31:14,000 --> 00:31:17,519
recovery of global variables system

814
00:31:15,600 --> 00:31:19,918
goals and protocol grids

815
00:31:17,519 --> 00:31:21,760
so let's evaluate them but before we

816
00:31:19,919 --> 00:31:23,919
jump to evaluation

817
00:31:21,760 --> 00:31:26,480
let's ask ourselves what has what are

818
00:31:23,919 --> 00:31:29,840
the most important things about uefi

819
00:31:26,480 --> 00:31:32,000
firmware compared to the reverse

820
00:31:29,840 --> 00:31:34,639
engineer in general and static analysis

821
00:31:32,000 --> 00:31:36,159
in general well there are at least a few

822
00:31:34,640 --> 00:31:40,000
points we found to understand

823
00:31:36,159 --> 00:31:43,360
first there is um on the

824
00:31:40,000 --> 00:31:46,880
previous slide i will probably explain

825
00:31:43,360 --> 00:31:51,840
a little bit more that the

826
00:31:46,880 --> 00:31:51,840
ufi firmware code base is mostly

827
00:31:51,919 --> 00:31:55,679
mostly kind of unchanged it's shipped

828
00:31:54,399 --> 00:31:57,600
with the

829
00:31:55,679 --> 00:31:59,919
very limited number of compilers and

830
00:31:57,600 --> 00:32:01,918
options also there is very limited

831
00:31:59,919 --> 00:32:04,320
number of vendors because the ecosystem

832
00:32:01,919 --> 00:32:06,000
itself is very tight and there is

833
00:32:04,320 --> 00:32:07,678
a lot of dependency on hardware

834
00:32:06,000 --> 00:32:10,080
manufacturers and

835
00:32:07,679 --> 00:32:10,880
as you know there is not so many of them

836
00:32:10,080 --> 00:32:12,559
so there is

837
00:32:10,880 --> 00:32:14,480
a little bit harder to get into that

838
00:32:12,559 --> 00:32:15,519
game and so the code bases are

839
00:32:14,480 --> 00:32:18,480
predictable

840
00:32:15,519 --> 00:32:21,039
as as alex said there is a lot of

841
00:32:18,480 --> 00:32:23,760
reference code and a lot of edk

842
00:32:21,039 --> 00:32:25,360
in the vendorship firmware and there are

843
00:32:23,760 --> 00:32:28,399
other things

844
00:32:25,360 --> 00:32:29,279
one of them is for example that uh well

845
00:32:28,399 --> 00:32:32,080
obviously

846
00:32:29,279 --> 00:32:33,039
disassembly is important to uh to

847
00:32:32,080 --> 00:32:35,519
annotate

848
00:32:33,039 --> 00:32:37,840
even if we found a good way to translate

849
00:32:35,519 --> 00:32:39,840
it to some intermediate form

850
00:32:37,840 --> 00:32:40,959
well the explanation for that is pretty

851
00:32:39,840 --> 00:32:43,918
straight forward

852
00:32:40,960 --> 00:32:46,000
the code runs close to machine so

853
00:32:43,919 --> 00:32:47,760
machine machine code is important

854
00:32:46,000 --> 00:32:49,279
in particular register specifics and

855
00:32:47,760 --> 00:32:50,480
instructions is important for the boot

856
00:32:49,279 --> 00:32:52,880
stage

857
00:32:50,480 --> 00:32:55,039
okay now how do we judge correctness of

858
00:32:52,880 --> 00:32:56,240
the automated ufi analysis with those

859
00:32:55,039 --> 00:32:59,279
assumptions

860
00:32:56,240 --> 00:33:02,559
and on the next slide there will be some

861
00:32:59,279 --> 00:33:02,559
more information about that

862
00:33:04,880 --> 00:33:08,320
basically there is a whole range of

863
00:33:07,679 --> 00:33:11,120
powerful

864
00:33:08,320 --> 00:33:13,840
and rich methods of let's say logical

865
00:33:11,120 --> 00:33:16,479
reasoning about ufi code

866
00:33:13,840 --> 00:33:17,600
we found that in this particular

867
00:33:16,480 --> 00:33:20,159
situation this

868
00:33:17,600 --> 00:33:21,760
might not be the first most optimal

869
00:33:20,159 --> 00:33:24,080
choice and we decided

870
00:33:21,760 --> 00:33:26,640
to treat if i explore object recognition

871
00:33:24,080 --> 00:33:29,360
is just a probabilistic algorithm

872
00:33:26,640 --> 00:33:30,559
so that can recognize object with some

873
00:33:29,360 --> 00:33:32,240
probability

874
00:33:30,559 --> 00:33:35,440
then we evaluate it with statistical

875
00:33:32,240 --> 00:33:37,760
methods on a data set of ufi binaries

876
00:33:35,440 --> 00:33:39,600
so more precisely it's it's about

877
00:33:37,760 --> 00:33:40,158
collecting data it's about collecting

878
00:33:39,600 --> 00:33:42,240
labels

879
00:33:40,159 --> 00:33:43,200
and it's about picking up the metrics

880
00:33:42,240 --> 00:33:46,640
and

881
00:33:43,200 --> 00:33:50,240
finding proper summary statistics

882
00:33:46,640 --> 00:33:50,240
so let's walk through our approach in

883
00:33:50,840 --> 00:33:53,840
detail

884
00:33:54,640 --> 00:33:57,679
let's talk about data

885
00:34:05,120 --> 00:34:10,480
so if we talk about data sets uh data

886
00:34:08,000 --> 00:34:12,239
set is a set of ufi binaries uefi

887
00:34:10,480 --> 00:34:14,639
modules compiled from

888
00:34:12,239 --> 00:34:17,279
from something this data set should

889
00:34:14,639 --> 00:34:19,200
approximate verify firmware in the wild

890
00:34:17,280 --> 00:34:20,960
it should be as close as possible to

891
00:34:19,199 --> 00:34:23,678
what people reverse engine air

892
00:34:20,960 --> 00:34:24,720
in reality so that code compilation and

893
00:34:23,679 --> 00:34:27,520
linking options

894
00:34:24,719 --> 00:34:29,199
and shared code usage and code pattern

895
00:34:27,520 --> 00:34:31,599
distribution and distribution of system

896
00:34:29,199 --> 00:34:33,678
calls should be as close

897
00:34:31,599 --> 00:34:34,960
to reality as possible but most

898
00:34:33,679 --> 00:34:37,280
importantly

899
00:34:34,960 --> 00:34:38,320
the data should have ground tooth labels

900
00:34:37,280 --> 00:34:42,240
remember

901
00:34:38,320 --> 00:34:45,200
uefi is kind of a black box ish so that

902
00:34:42,239 --> 00:34:46,839
it's everything not a lot of code is

903
00:34:45,199 --> 00:34:49,439
shipped as a source

904
00:34:46,839 --> 00:34:51,359
so those

905
00:34:49,440 --> 00:34:53,359
those conditions and those constraints

906
00:34:51,359 --> 00:34:54,399
and also our desire to be transparent

907
00:34:53,359 --> 00:34:57,359
and opened

908
00:34:54,399 --> 00:34:59,040
an open in our measurement narrowed down

909
00:34:57,359 --> 00:35:01,119
the search to pretty much

910
00:34:59,040 --> 00:35:03,599
small amount of known open source

911
00:35:01,119 --> 00:35:04,960
projects etk2 udk and core boot and

912
00:35:03,599 --> 00:35:07,440
similar things

913
00:35:04,960 --> 00:35:08,800
their default tool chains are pretty

914
00:35:07,440 --> 00:35:10,880
close to what vendors use

915
00:35:08,800 --> 00:35:12,160
and also you can take different versions

916
00:35:10,880 --> 00:35:16,320
and different branches

917
00:35:12,160 --> 00:35:17,839
cut them and obtained obtain all samples

918
00:35:16,320 --> 00:35:21,760
so our initial measurements are

919
00:35:17,839 --> 00:35:23,279
currently done on a 186 edk2 models for

920
00:35:21,760 --> 00:35:30,720
x86 architecture

921
00:35:23,280 --> 00:35:32,480
but of course it's just a start

922
00:35:30,720 --> 00:35:35,118
now let's talk about labels that's more

923
00:35:32,480 --> 00:35:35,119
interesting thing

924
00:35:40,000 --> 00:35:44,400
basically labels are something which

925
00:35:42,720 --> 00:35:46,319
tells us that the object

926
00:35:44,400 --> 00:35:49,760
we want to recognize the object we

927
00:35:46,320 --> 00:35:51,760
recover located at a particular offset

928
00:35:49,760 --> 00:35:54,000
one straightforward way is to get debug

929
00:35:51,760 --> 00:35:56,640
symbols that's pretty clear

930
00:35:54,000 --> 00:35:57,839
but that method does not allow us to get

931
00:35:56,640 --> 00:35:59,920
a granular

932
00:35:57,839 --> 00:36:01,119
understanding where the say function

933
00:35:59,920 --> 00:36:02,800
pointers are

934
00:36:01,119 --> 00:36:04,240
or at least we have not found the

935
00:36:02,800 --> 00:36:07,040
weightlift

936
00:36:04,240 --> 00:36:08,959
at this point uh one trick with using

937
00:36:07,040 --> 00:36:09,759
debug symbols is that we just load it

938
00:36:08,960 --> 00:36:12,720
into ida

939
00:36:09,760 --> 00:36:15,040
and avoid some dependency on say a

940
00:36:12,720 --> 00:36:18,240
proprietary format such as pdb

941
00:36:15,040 --> 00:36:19,040
and let's just let ida do do all the

942
00:36:18,240 --> 00:36:21,279
heavy lifting

943
00:36:19,040 --> 00:36:22,960
then we use ida to extract all locations

944
00:36:21,280 --> 00:36:25,520
of global variables

945
00:36:22,960 --> 00:36:27,440
and then usify explorer run it on the

946
00:36:25,520 --> 00:36:28,160
same binary with debug without debug

947
00:36:27,440 --> 00:36:30,960
symbols

948
00:36:28,160 --> 00:36:32,799
compare and give the result all good

949
00:36:30,960 --> 00:36:35,440
there are some disadvantages

950
00:36:32,800 --> 00:36:36,400
it's most importantly as i said

951
00:36:35,440 --> 00:36:38,560
locations of

952
00:36:36,400 --> 00:36:40,720
function pointers are unclear and it's

953
00:36:38,560 --> 00:36:43,520
also not fully transparent

954
00:36:40,720 --> 00:36:44,480
whether debug symbols actually affects

955
00:36:43,520 --> 00:36:48,240
the code general

956
00:36:44,480 --> 00:36:51,359
generation in any way so that it biases

957
00:36:48,240 --> 00:36:53,359
or changes our data set in any ways we

958
00:36:51,359 --> 00:36:57,680
could not anticipate

959
00:36:53,359 --> 00:36:57,680
there's a second way we we found

960
00:37:03,119 --> 00:37:06,400
it's basically asking the compiler to

961
00:37:05,040 --> 00:37:08,480
generate assembler listing

962
00:37:06,400 --> 00:37:10,240
to annotate it with a source code and

963
00:37:08,480 --> 00:37:13,200
then use this annotation

964
00:37:10,240 --> 00:37:15,040
in order to map objects the desired

965
00:37:13,200 --> 00:37:19,919
objects we want to recover

966
00:37:15,040 --> 00:37:22,800
to a particular offset also pretty clear

967
00:37:19,920 --> 00:37:23,280
but we found that line annotations even

968
00:37:22,800 --> 00:37:25,359
though

969
00:37:23,280 --> 00:37:27,280
generated by the compiler are also

970
00:37:25,359 --> 00:37:30,319
sometimes incorrect

971
00:37:27,280 --> 00:37:31,280
and also uh write an assembly assembly

972
00:37:30,320 --> 00:37:33,839
listing parser

973
00:37:31,280 --> 00:37:34,880
kind of brings a interesting chiconic

974
00:37:33,839 --> 00:37:37,359
problem because

975
00:37:34,880 --> 00:37:39,119
the near perfect label generation can

976
00:37:37,359 --> 00:37:40,720
also have bugs and now we have to figure

977
00:37:39,119 --> 00:37:41,680
out whether our labeling system is

978
00:37:40,720 --> 00:37:44,160
correct

979
00:37:41,680 --> 00:37:46,399
but anyway that that method works for us

980
00:37:44,160 --> 00:37:48,319
in practice

981
00:37:46,400 --> 00:37:50,079
okay and finally let's talk about how we

982
00:37:48,320 --> 00:37:53,200
give the results calculate the metrics

983
00:37:50,079 --> 00:37:54,560
and pick the summary statistics metrics

984
00:37:53,200 --> 00:37:56,160
the goal of them is to reflect the

985
00:37:54,560 --> 00:37:59,040
overall goodness of analysis

986
00:37:56,160 --> 00:38:00,879
basically how do different types of

987
00:37:59,040 --> 00:38:02,880
objects affect the measurement

988
00:38:00,880 --> 00:38:04,000
well we found it reasonable to measure

989
00:38:02,880 --> 00:38:06,560
each group separately

990
00:38:04,000 --> 00:38:08,480
so we measure recognition of global

991
00:38:06,560 --> 00:38:11,759
tables recognition of the

992
00:38:08,480 --> 00:38:14,880
system calls and protocol grids why

993
00:38:11,760 --> 00:38:18,160
well there are a few points but

994
00:38:14,880 --> 00:38:20,480
i found one most beautiful it is that

995
00:38:18,160 --> 00:38:22,078
some objects are proxies for recovery of

996
00:38:20,480 --> 00:38:26,079
other objects

997
00:38:22,079 --> 00:38:28,320
so uh think about recognition of service

998
00:38:26,079 --> 00:38:29,520
service call protocol related service

999
00:38:28,320 --> 00:38:31,839
call after your

1000
00:38:29,520 --> 00:38:34,160
uv explorer finds the service call it

1001
00:38:31,839 --> 00:38:36,240
marks a protocol grid as an argument

1002
00:38:34,160 --> 00:38:38,240
and only after that that protocol grid

1003
00:38:36,240 --> 00:38:41,040
is considered recognized

1004
00:38:38,240 --> 00:38:42,560
now that number of those protocol grids

1005
00:38:41,040 --> 00:38:46,640
is a kind of approximatric

1006
00:38:42,560 --> 00:38:48,480
for the recovery of boot services calls

1007
00:38:46,640 --> 00:38:50,480
we have two metrics basically

1008
00:38:48,480 --> 00:38:54,000
cross-referencing those two metrics

1009
00:38:50,480 --> 00:38:56,560
lets us infer some additional insights

1010
00:38:54,000 --> 00:38:58,400
for example we we now know how exactly

1011
00:38:56,560 --> 00:39:01,520
our labeling system works and

1012
00:38:58,400 --> 00:39:03,440
whether it's correct or incorrect

1013
00:39:01,520 --> 00:39:07,440
but okay let's jump to most important

1014
00:39:03,440 --> 00:39:07,440
question what metrics works best for our

1015
00:39:12,839 --> 00:39:16,160
case

1016
00:39:14,240 --> 00:39:18,160
so we use a precision and recall which

1017
00:39:16,160 --> 00:39:20,960
shows performance for common ufi

1018
00:39:18,160 --> 00:39:23,118
binaries and also false positive rate

1019
00:39:20,960 --> 00:39:24,400
now how how do we average the results

1020
00:39:23,119 --> 00:39:26,960
well we found that just

1021
00:39:24,400 --> 00:39:28,800
taking the average and weighted average

1022
00:39:26,960 --> 00:39:29,920
of precision and recall is good for

1023
00:39:28,800 --> 00:39:32,160
start

1024
00:39:29,920 --> 00:39:34,160
just as a reminder precision shows the

1025
00:39:32,160 --> 00:39:37,279
probability that the recovered object

1026
00:39:34,160 --> 00:39:40,000
is actually actually exist in that place

1027
00:39:37,280 --> 00:39:41,680
and recall is the chances that all

1028
00:39:40,000 --> 00:39:43,040
recovered objects which are actually

1029
00:39:41,680 --> 00:39:44,960
located in the binary

1030
00:39:43,040 --> 00:39:47,440
will be recovered by the if i explore

1031
00:39:44,960 --> 00:39:47,440
algorithm

1032
00:39:47,839 --> 00:39:50,960
let's talk about the

1033
00:39:54,839 --> 00:39:57,839
results

1034
00:40:01,280 --> 00:40:04,720
this is basically our current

1035
00:40:02,640 --> 00:40:08,319
measurements most important thing

1036
00:40:04,720 --> 00:40:09,759
is that our efi explorer surprisingly

1037
00:40:08,319 --> 00:40:12,160
works pretty well

1038
00:40:09,760 --> 00:40:13,839
it is able to recognize a lot of objects

1039
00:40:12,160 --> 00:40:16,240
with high precision which means

1040
00:40:13,839 --> 00:40:17,839
that if it recognizes an object it

1041
00:40:16,240 --> 00:40:20,078
likely exists

1042
00:40:17,839 --> 00:40:23,279
recall is slightly less for all objects

1043
00:40:20,079 --> 00:40:26,480
so manual work is still required

1044
00:40:23,280 --> 00:40:28,480
but when we uh when you get some um

1045
00:40:26,480 --> 00:40:30,319
some summary statistic or some average

1046
00:40:28,480 --> 00:40:32,560
number the next question is

1047
00:40:30,319 --> 00:40:35,680
okay what's what's behind it is what's

1048
00:40:32,560 --> 00:40:35,680
the distribution behind it

1049
00:40:37,839 --> 00:40:41,839
this slide shows not necessarily the

1050
00:40:39,599 --> 00:40:42,880
distribution but the way we understand

1051
00:40:41,839 --> 00:40:44,880
what is

1052
00:40:42,880 --> 00:40:47,280
behind this precision and recall numbers

1053
00:40:44,880 --> 00:40:52,720
we just sort precision

1054
00:40:47,280 --> 00:40:54,400
for each module and show um

1055
00:40:52,720 --> 00:40:56,720
showed blue area which shows all the

1056
00:40:54,400 --> 00:40:59,520
modules which have perfect precision

1057
00:40:56,720 --> 00:41:00,720
and on the left where there is an orange

1058
00:40:59,520 --> 00:41:02,640
area there are modules

1059
00:41:00,720 --> 00:41:04,319
which kind of do not perform well in

1060
00:41:02,640 --> 00:41:05,920
terms of precision

1061
00:41:04,319 --> 00:41:08,319
this particular way of looking at the

1062
00:41:05,920 --> 00:41:10,800
situation helps us to debug

1063
00:41:08,319 --> 00:41:12,079
what is the most common problem with

1064
00:41:10,800 --> 00:41:14,720
with those models and

1065
00:41:12,079 --> 00:41:16,640
what is the most common problem with the

1066
00:41:14,720 --> 00:41:17,439
analysis we face so if we fix it and

1067
00:41:16,640 --> 00:41:22,400
improve our

1068
00:41:17,440 --> 00:41:22,400
algorithm the same is with recall

1069
00:41:27,839 --> 00:41:35,839
yeah we can go to the next slide

1070
00:41:37,680 --> 00:41:41,040
basically let's try to summarize the

1071
00:41:39,440 --> 00:41:42,800
results as i said

1072
00:41:41,040 --> 00:41:44,319
if explorer is very good at finding

1073
00:41:42,800 --> 00:41:47,920
location

1074
00:41:44,319 --> 00:41:50,400
of objects and when it finds them it's

1075
00:41:47,920 --> 00:41:52,400
very likely that the object is valid

1076
00:41:50,400 --> 00:41:53,599
it's better at finding global variables

1077
00:41:52,400 --> 00:41:55,520
it's a little bit

1078
00:41:53,599 --> 00:41:57,839
worse at finding function pointers in

1079
00:41:55,520 --> 00:42:00,319
protocol grids

1080
00:41:57,839 --> 00:42:01,839
you can see that the precision from from

1081
00:42:00,319 --> 00:42:04,240
the fact that the precision and recall

1082
00:42:01,839 --> 00:42:06,000
for global tables is slightly larger

1083
00:42:04,240 --> 00:42:07,279
than for function pointers in protocol

1084
00:42:06,000 --> 00:42:09,920
grids

1085
00:42:07,280 --> 00:42:09,920
next if

1086
00:42:10,960 --> 00:42:13,520
basically

1087
00:42:14,000 --> 00:42:17,839
if the labeling system goes

1088
00:42:18,480 --> 00:42:21,680
is slightly unpredictable it becomes

1089
00:42:20,720 --> 00:42:24,078
harder

1090
00:42:21,680 --> 00:42:24,720
in our case we found that surprisingly

1091
00:42:24,079 --> 00:42:27,680
the label

1092
00:42:24,720 --> 00:42:28,720
granular labeling system for objects

1093
00:42:27,680 --> 00:42:31,040
namely for

1094
00:42:28,720 --> 00:42:32,160
service calls and for protocols is

1095
00:42:31,040 --> 00:42:34,880
actually quite hard

1096
00:42:32,160 --> 00:42:37,279
even though we have full control over

1097
00:42:34,880 --> 00:42:39,520
over the code over its generation

1098
00:42:37,280 --> 00:42:40,960
even with the source code for example

1099
00:42:39,520 --> 00:42:41,759
protocol and non-protocol build

1100
00:42:40,960 --> 00:42:43,839
ambiguity

1101
00:42:41,760 --> 00:42:46,079
takes a little bit of additional

1102
00:42:43,839 --> 00:42:48,720
whitelist and blacklisting and a lot of

1103
00:42:46,079 --> 00:42:50,319
case per case adjustments and of course

1104
00:42:48,720 --> 00:42:51,520
manual work is still needed to complete

1105
00:42:50,319 --> 00:42:54,560
annotations

1106
00:42:51,520 --> 00:42:55,839
but that's how all plugins work so our

1107
00:42:54,560 --> 00:42:58,960
fee explorer

1108
00:42:55,839 --> 00:43:00,078
saves a lot of time by finding most most

1109
00:42:58,960 --> 00:43:02,160
of the objects

1110
00:43:00,079 --> 00:43:03,440
and since the precision is pretty high

1111
00:43:02,160 --> 00:43:05,920
those objects are valid

1112
00:43:03,440 --> 00:43:07,359
what's left is just to verify what's

1113
00:43:05,920 --> 00:43:10,400
what's

1114
00:43:07,359 --> 00:43:12,480
what else is in the binary and

1115
00:43:10,400 --> 00:43:14,079
finally we are working to release this

1116
00:43:12,480 --> 00:43:17,760
evaluation system

1117
00:43:14,079 --> 00:43:20,720
in a stable state let's go to conclusion

1118
00:43:17,760 --> 00:43:21,440
our main point is that it's actually

1119
00:43:20,720 --> 00:43:23,839
right time

1120
00:43:21,440 --> 00:43:25,440
for a much broader audience to look into

1121
00:43:23,839 --> 00:43:28,078
the ufi threats

1122
00:43:25,440 --> 00:43:28,800
i mean broader more than a selected

1123
00:43:28,079 --> 00:43:31,920
number of

1124
00:43:28,800 --> 00:43:32,720
very smart and talented uefi uh and

1125
00:43:31,920 --> 00:43:36,480
firmware

1126
00:43:32,720 --> 00:43:39,439
reverse engineers as it's

1127
00:43:36,480 --> 00:43:40,480
i mean it's not complete mystery what is

1128
00:43:39,440 --> 00:43:42,960
inside the efi

1129
00:43:40,480 --> 00:43:44,400
you can reverse it but when it comes to

1130
00:43:42,960 --> 00:43:46,000
the threats you have five threats and

1131
00:43:44,400 --> 00:43:48,319
potential implants

1132
00:43:46,000 --> 00:43:49,920
i would say god knows what's there and

1133
00:43:48,319 --> 00:43:52,160
it's interesting and it's the right time

1134
00:43:49,920 --> 00:43:54,480
to look into that

1135
00:43:52,160 --> 00:43:56,480
rfi explorer helps to do that from a

1136
00:43:54,480 --> 00:43:58,880
static analysis perspective

1137
00:43:56,480 --> 00:43:59,520
next point is that well-tuned heuristics

1138
00:43:58,880 --> 00:44:02,400
actually

1139
00:43:59,520 --> 00:44:05,040
work surprisingly well for efi including

1140
00:44:02,400 --> 00:44:07,839
automated vulnerability finding

1141
00:44:05,040 --> 00:44:09,920
analyzing binaries in a similar context

1142
00:44:07,839 --> 00:44:12,400
altogether for the whole binary

1143
00:44:09,920 --> 00:44:14,000
for the whole firmware image is tricky

1144
00:44:12,400 --> 00:44:15,440
takes a lot of time but it's really

1145
00:44:14,000 --> 00:44:17,520
worth it

1146
00:44:15,440 --> 00:44:20,079
also thanks to some early smart

1147
00:44:17,520 --> 00:44:21,280
decisions our plugin is blazing fast and

1148
00:44:20,079 --> 00:44:23,440
very scalable

1149
00:44:21,280 --> 00:44:25,359
so if i recall for some cases you can

1150
00:44:23,440 --> 00:44:26,079
analyze the whole firmware image

1151
00:44:25,359 --> 00:44:28,000
including

1152
00:44:26,079 --> 00:44:29,359
all of analysis in a matter of few

1153
00:44:28,000 --> 00:44:32,880
seconds

1154
00:44:29,359 --> 00:44:34,078
um the to our knowledge this is the

1155
00:44:32,880 --> 00:44:37,599
first ufi

1156
00:44:34,079 --> 00:44:40,560
reverse engineering tool where we

1157
00:44:37,599 --> 00:44:41,680
rigorously evaluated analysis quality we

1158
00:44:40,560 --> 00:44:44,560
tried to do our best

1159
00:44:41,680 --> 00:44:46,000
but maybe it's not perfect at that time

1160
00:44:44,560 --> 00:44:47,359
let us know if you like it and we'll

1161
00:44:46,000 --> 00:44:50,640
definitely release

1162
00:44:47,359 --> 00:44:52,640
more transparent and more open way to do

1163
00:44:50,640 --> 00:44:54,720
that so that you can have reproducible

1164
00:44:52,640 --> 00:44:57,520
results

1165
00:44:54,720 --> 00:44:59,839
and finally i would say that security

1166
00:44:57,520 --> 00:45:02,960
research of bios and especially its

1167
00:44:59,839 --> 00:45:05,279
automated firmware reversing is

1168
00:45:02,960 --> 00:45:07,040
goes for pretty long at least the first

1169
00:45:05,280 --> 00:45:10,240
paper i remember

1170
00:45:07,040 --> 00:45:13,520
goes back to 15 years maybe there are

1171
00:45:10,240 --> 00:45:15,200
some early research so a lot of good

1172
00:45:13,520 --> 00:45:17,599
ideas are already there

1173
00:45:15,200 --> 00:45:19,118
we just try try to make it a little bit

1174
00:45:17,599 --> 00:45:20,960
better

1175
00:45:19,119 --> 00:45:22,880
by combining all the ideas and

1176
00:45:20,960 --> 00:45:25,920
presenting some of our own ideas

1177
00:45:22,880 --> 00:45:27,760
in a single place and basically helping

1178
00:45:25,920 --> 00:45:29,359
the community

1179
00:45:27,760 --> 00:45:32,240
if you have an idea or if you want to

1180
00:45:29,359 --> 00:45:36,480
expect to inspect our code in detail or

1181
00:45:32,240 --> 00:45:39,520
anything feel free to go to our github

1182
00:45:36,480 --> 00:45:39,920
and i also want to have uh to specially

1183
00:45:39,520 --> 00:45:42,079
thank

1184
00:45:39,920 --> 00:45:43,119
our contributors our contributor role

1185
00:45:42,079 --> 00:45:46,560
roles

1186
00:45:43,119 --> 00:45:49,520
for uh code for the contribution

1187
00:45:46,560 --> 00:45:51,520
and for very insightful and deep

1188
00:45:49,520 --> 00:45:54,560
suggestions and discussion

1189
00:45:51,520 --> 00:46:01,839
thank you rolf and thank you all for

1190
00:45:54,560 --> 00:46:01,839
your time and for your attention

1191
00:46:08,240 --> 00:46:15,839
thank you erica party it was great and

1192
00:46:11,280 --> 00:46:15,839
yeah so see you next year

