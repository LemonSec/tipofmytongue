1
00:00:03,760 --> 00:00:08,879
song young

2
00:00:04,640 --> 00:00:11,920
song presents deep dive into art

3
00:00:08,880 --> 00:00:13,200
android runtime for dynamic binary

4
00:00:11,920 --> 00:00:16,000
analysis

5
00:00:13,200 --> 00:00:18,480
this talk proposed a new technique to

6
00:00:16,000 --> 00:00:22,240
quickly and effectively analyze the app

7
00:00:18,480 --> 00:00:25,119
by modifying the a-r-t

8
00:00:22,240 --> 00:00:27,198
it shows an environment in which an

9
00:00:25,119 --> 00:00:30,720
attacker can still code

10
00:00:27,199 --> 00:00:33,920
interface parameters return value

11
00:00:30,720 --> 00:00:34,960
fields and stack trace of a function

12
00:00:33,920 --> 00:00:39,040
execute

13
00:00:34,960 --> 00:00:45,360
with using a debugger of surfing tools

14
00:00:39,040 --> 00:00:47,680
in real time

15
00:00:45,360 --> 00:00:48,559
hi nice to meet you everyone uh my name

16
00:00:47,680 --> 00:00:51,680
is hanyan song

17
00:00:48,559 --> 00:00:54,239
i work at the fsi of south korea

18
00:00:51,680 --> 00:00:57,039
the fsa is responsible for the security

19
00:00:54,239 --> 00:00:59,120
of korean financial security

20
00:00:57,039 --> 00:01:00,320
and i'm researching mobile security at

21
00:00:59,120 --> 00:01:02,879
fsi

22
00:01:00,320 --> 00:01:04,559
and i do penetration testing for korean

23
00:01:02,879 --> 00:01:06,560
company

24
00:01:04,559 --> 00:01:07,840
i have experience speaking at several

25
00:01:06,560 --> 00:01:11,119
international security

26
00:01:07,840 --> 00:01:13,840
conferences in europe and

27
00:01:11,119 --> 00:01:13,840
asia

28
00:01:14,799 --> 00:01:19,119
today i'd like to analyze how android

29
00:01:17,439 --> 00:01:22,240
runtime works in detail

30
00:01:19,119 --> 00:01:23,920
and based on the analysis research i'm

31
00:01:22,240 --> 00:01:26,080
going to propose a technique

32
00:01:23,920 --> 00:01:27,200
to analyze the app easily and

33
00:01:26,080 --> 00:01:31,280
effectively

34
00:01:27,200 --> 00:01:31,280
by customizing the entry runtime

35
00:01:31,759 --> 00:01:35,280
first of all i want to explain why i

36
00:01:34,240 --> 00:01:40,158
became

37
00:01:35,280 --> 00:01:42,640
interested in the android runtime and

38
00:01:40,159 --> 00:01:43,280
analyzing mobile app is very important

39
00:01:42,640 --> 00:01:45,840
process

40
00:01:43,280 --> 00:01:48,079
for those who work in mobile security

41
00:01:45,840 --> 00:01:51,600
like a mobile analyst

42
00:01:48,079 --> 00:01:52,240
or hackers this is because it's possible

43
00:01:51,600 --> 00:01:56,000
to get

44
00:01:52,240 --> 00:01:58,960
a clear idea of how marvel works or

45
00:01:56,000 --> 00:02:00,240
find vulnerability in your mobile apps

46
00:01:58,960 --> 00:02:05,119
only when

47
00:02:00,240 --> 00:02:05,119
when proper analysis is done beforehand

48
00:02:06,320 --> 00:02:10,560
there are two main ways to analyze

49
00:02:08,720 --> 00:02:13,120
mobile app

50
00:02:10,560 --> 00:02:14,560
first you can analyze the app if it

51
00:02:13,120 --> 00:02:17,920
exists as your file

52
00:02:14,560 --> 00:02:18,879
in general in android bytecode can be

53
00:02:17,920 --> 00:02:21,200
converted

54
00:02:18,879 --> 00:02:22,239
converted back to the original java

55
00:02:21,200 --> 00:02:24,879
source code

56
00:02:22,239 --> 00:02:26,400
using open source tool such as a texture

57
00:02:24,879 --> 00:02:29,599
jar

58
00:02:26,400 --> 00:02:30,560
another way is to analyze the app while

59
00:02:29,599 --> 00:02:34,560
the file

60
00:02:30,560 --> 00:02:36,879
is executed and loaded in memory

61
00:02:34,560 --> 00:02:37,760
there is a dynamic analysis tool called

62
00:02:36,879 --> 00:02:39,840
frida

63
00:02:37,760 --> 00:02:41,040
that can analyze the app during the

64
00:02:39,840 --> 00:02:44,000
runtime

65
00:02:41,040 --> 00:02:44,400
florida is very high web framework and

66
00:02:44,000 --> 00:02:47,440
it's

67
00:02:44,400 --> 00:02:48,800
used by almost all security researchers

68
00:02:47,440 --> 00:02:51,359
today

69
00:02:48,800 --> 00:02:52,800
so application that handles sensitive

70
00:02:51,360 --> 00:02:56,560
information

71
00:02:52,800 --> 00:02:58,800
such as banking gaming

72
00:02:56,560 --> 00:02:59,920
and healthcare also to the security

73
00:02:58,800 --> 00:03:02,000
technique

74
00:02:59,920 --> 00:03:03,040
to protect themselves from their

75
00:03:02,000 --> 00:03:08,480
analysis and

76
00:03:03,040 --> 00:03:11,599
attack we call this technique rasp

77
00:03:08,480 --> 00:03:14,959
runtime application server protection

78
00:03:11,599 --> 00:03:18,000
many secret companies develop rasp

79
00:03:14,959 --> 00:03:20,720
make it as module and share it and

80
00:03:18,000 --> 00:03:21,440
most of apps with sensitive information

81
00:03:20,720 --> 00:03:24,799
are

82
00:03:21,440 --> 00:03:25,120
actually using the module this technique

83
00:03:24,799 --> 00:03:27,120
check

84
00:03:25,120 --> 00:03:28,159
not only whether the os has been

85
00:03:27,120 --> 00:03:30,959
tempered

86
00:03:28,159 --> 00:03:32,720
but they also encrypted transmit or

87
00:03:30,959 --> 00:03:35,280
receive data

88
00:03:32,720 --> 00:03:37,040
in addition to that they detect and

89
00:03:35,280 --> 00:03:42,080
block the

90
00:03:37,040 --> 00:03:42,079
attacker from accessing the memory area

91
00:03:42,959 --> 00:03:47,599
so if you try to analyze analyze an app

92
00:03:46,720 --> 00:03:51,440
protected by

93
00:03:47,599 --> 00:03:53,439
rasp you will be detected and blocked as

94
00:03:51,440 --> 00:03:55,760
shown in the picture here

95
00:03:53,439 --> 00:03:58,720
this top picture shown the process of

96
00:03:55,760 --> 00:04:02,239
decompiling to original java source code

97
00:03:58,720 --> 00:04:04,640
using text which are since the

98
00:04:02,239 --> 00:04:05,760
app is protected by anti-decompile

99
00:04:04,640 --> 00:04:08,000
technique

100
00:04:05,760 --> 00:04:11,040
you are in trouble with convert it back

101
00:04:08,000 --> 00:04:13,519
to the original java source code

102
00:04:11,040 --> 00:04:14,560
the bottom picture here shown warning

103
00:04:13,519 --> 00:04:17,840
message

104
00:04:14,560 --> 00:04:18,959
generated when it detects and detected

105
00:04:17,839 --> 00:04:21,279
running in

106
00:04:18,959 --> 00:04:22,320
uh in a root environment or any

107
00:04:21,279 --> 00:04:28,080
attempted

108
00:04:22,320 --> 00:04:32,320
attempted dynamic analysis using frida

109
00:04:28,080 --> 00:04:35,840
so can we bypass rasp

110
00:04:32,320 --> 00:04:39,199
of course in my thought there does not

111
00:04:35,840 --> 00:04:41,679
exist 100 of security but

112
00:04:39,199 --> 00:04:43,600
what i want is automated and effective

113
00:04:41,680 --> 00:04:46,320
and fast method

114
00:04:43,600 --> 00:04:47,520
however security modules are difficult

115
00:04:46,320 --> 00:04:49,919
to bypass

116
00:04:47,520 --> 00:04:51,359
because they are applied in multi-ways

117
00:04:49,919 --> 00:04:54,400
technique

118
00:04:51,360 --> 00:04:58,400
so what's the problem the problem is

119
00:04:54,400 --> 00:04:59,919
time they also know that the rasp cannot

120
00:04:58,400 --> 00:05:03,679
define the completely

121
00:04:59,919 --> 00:05:05,198
attacker the purpose of the purpose of

122
00:05:03,680 --> 00:05:07,840
the rasp

123
00:05:05,199 --> 00:05:08,880
is to annoy the attacker as much as

124
00:05:07,840 --> 00:05:10,799
possible

125
00:05:08,880 --> 00:05:12,080
and increase the time required for the

126
00:05:10,800 --> 00:05:14,800
attack

127
00:05:12,080 --> 00:05:15,520
there is no perfect mechanism and we are

128
00:05:14,800 --> 00:05:18,560
in state

129
00:05:15,520 --> 00:05:20,400
continue have to fight i want to get

130
00:05:18,560 --> 00:05:22,160
i want to get away from the endless

131
00:05:20,400 --> 00:05:25,919
fight between protection

132
00:05:22,160 --> 00:05:29,120
and bypass just like tom and jerry

133
00:05:25,919 --> 00:05:30,479
so over the past few years i have i have

134
00:05:29,120 --> 00:05:32,720
been thinking about

135
00:05:30,479 --> 00:05:33,840
how to analyze the app easily and

136
00:05:32,720 --> 00:05:39,039
effectively

137
00:05:33,840 --> 00:05:41,599
without being detected by rasp

138
00:05:39,039 --> 00:05:43,360
then i found the two paper published in

139
00:05:41,600 --> 00:05:47,680
using 2010

140
00:05:43,360 --> 00:05:50,000
and amc 2016.

141
00:05:47,680 --> 00:05:52,080
the main subject of paper were about

142
00:05:50,000 --> 00:05:54,800
developing a framework that can

143
00:05:52,080 --> 00:05:56,159
dynamically nearly analyze app by

144
00:05:54,800 --> 00:05:59,199
modifying the runtime of

145
00:05:56,160 --> 00:06:02,000
android it was very interesting as

146
00:05:59,199 --> 00:06:02,880
it modified the os to create the

147
00:06:02,000 --> 00:06:06,080
environment for

148
00:06:02,880 --> 00:06:09,199
analysis but uh

149
00:06:06,080 --> 00:06:11,599
the the advantage of technique was that

150
00:06:09,199 --> 00:06:13,199
app could not be analyzed without

151
00:06:11,600 --> 00:06:16,560
directx the

152
00:06:13,199 --> 00:06:20,479
app apps executable file or memory

153
00:06:16,560 --> 00:06:20,960
but unfortunately the paper were written

154
00:06:20,479 --> 00:06:24,560
for

155
00:06:20,960 --> 00:06:25,599
all the androids so i had to analyze the

156
00:06:24,560 --> 00:06:29,360
new runtime in

157
00:06:25,600 --> 00:06:29,360
android 10 in detail

158
00:06:30,080 --> 00:06:37,599
so i shipped my focus from application

159
00:06:33,600 --> 00:06:40,639
to android os itself and

160
00:06:37,600 --> 00:06:44,080
there is corner and platform

161
00:06:40,639 --> 00:06:45,600
in the past few years i started analyze

162
00:06:44,080 --> 00:06:49,440
the android source code

163
00:06:45,600 --> 00:06:52,479
and develop the custom os

164
00:06:49,440 --> 00:06:55,199
so i ended up building an android os by

165
00:06:52,479 --> 00:06:57,680
customizing the corner and platform

166
00:06:55,199 --> 00:06:58,560
the oss built-in functions such as

167
00:06:57,680 --> 00:07:02,400
backdoor for

168
00:06:58,560 --> 00:07:05,599
privilege escalation sc linux bypass

169
00:07:02,400 --> 00:07:06,318
say protein bypass android verify boot

170
00:07:05,599 --> 00:07:10,159
bypass

171
00:07:06,319 --> 00:07:10,160
and corner memory access driver

172
00:07:10,400 --> 00:07:13,440
i don't think i can cover all of these

173
00:07:12,880 --> 00:07:17,520
today

174
00:07:13,440 --> 00:07:20,240
due to the limit time so in this session

175
00:07:17,520 --> 00:07:22,880
i will focus on presenting how customize

176
00:07:20,240 --> 00:07:27,919
the runtime

177
00:07:22,880 --> 00:07:27,919
for the dynamic analysis of application

178
00:07:28,000 --> 00:07:35,120
ait's abbreviation for android runtime

179
00:07:32,000 --> 00:07:37,919
ait can be called the heart of android

180
00:07:35,120 --> 00:07:39,280
and the player keyword in loading up

181
00:07:37,919 --> 00:07:41,680
binary

182
00:07:39,280 --> 00:07:42,559
application memory management and

183
00:07:41,680 --> 00:07:45,680
execution

184
00:07:42,560 --> 00:07:48,240
and optimization however it

185
00:07:45,680 --> 00:07:49,840
is not easy to analyze in deep how the

186
00:07:48,240 --> 00:07:53,919
runtime works

187
00:07:49,840 --> 00:07:56,638
in the rest restless version of android

188
00:07:53,919 --> 00:07:57,280
this is because the size of code is huge

189
00:07:56,639 --> 00:08:01,039
about

190
00:07:57,280 --> 00:08:01,919
150 gigabyte and various techniques

191
00:08:01,039 --> 00:08:05,520
compiling

192
00:08:01,919 --> 00:08:06,560
profiling and optimization are also

193
00:08:05,520 --> 00:08:09,520
applied to

194
00:08:06,560 --> 00:08:10,479
apply to the rest version of aert in

195
00:08:09,520 --> 00:08:12,878
addition

196
00:08:10,479 --> 00:08:15,599
since google has changed changed the

197
00:08:12,879 --> 00:08:16,720
android runtime drastically each time a

198
00:08:15,599 --> 00:08:19,599
new version of

199
00:08:16,720 --> 00:08:20,720
android is released to optimize the

200
00:08:19,599 --> 00:08:23,199
performance

201
00:08:20,720 --> 00:08:25,039
storage usage and the system of data

202
00:08:23,199 --> 00:08:27,680
webs

203
00:08:25,039 --> 00:08:28,400
how is structured and how it operates

204
00:08:27,680 --> 00:08:32,000
are different

205
00:08:28,400 --> 00:08:32,000
from each runtime version

206
00:08:32,958 --> 00:08:39,119
however since all bytecode of app

207
00:08:36,320 --> 00:08:40,159
is interpreted and executed through the

208
00:08:39,120 --> 00:08:43,360
art

209
00:08:40,159 --> 00:08:46,560
if the attacker understands how exactly

210
00:08:43,360 --> 00:08:47,360
the app works on art all necessary

211
00:08:46,560 --> 00:08:50,959
information

212
00:08:47,360 --> 00:08:54,640
can be stolen in real time to analyze

213
00:08:50,959 --> 00:08:54,959
the app in this speaking therefore aim

214
00:08:54,640 --> 00:08:58,640
to

215
00:08:54,959 --> 00:09:01,518
analyze android 10 aart in detail

216
00:08:58,640 --> 00:09:02,560
i propose a new technique to quickly and

217
00:09:01,519 --> 00:09:06,240
effectively

218
00:09:02,560 --> 00:09:09,439
analyze the app by modifying the alt

219
00:09:06,240 --> 00:09:12,640
to divide from the the existing app

220
00:09:09,440 --> 00:09:15,839
analysis method

221
00:09:12,640 --> 00:09:19,199
this technique is not detected by rasp

222
00:09:15,839 --> 00:09:21,600
and enable dynamic analysis of

223
00:09:19,200 --> 00:09:24,080
all the function executed through the

224
00:09:21,600 --> 00:09:27,279
ait

225
00:09:24,080 --> 00:09:29,839
and i also develop a developer framework

226
00:09:27,279 --> 00:09:32,880
in which an attacker can still code

227
00:09:29,839 --> 00:09:35,839
interface parameters return value

228
00:09:32,880 --> 00:09:36,560
field and stack trace of running

229
00:09:35,839 --> 00:09:39,200
function

230
00:09:36,560 --> 00:09:42,079
in the real time without using debugger

231
00:09:39,200 --> 00:09:42,080
or hooking tool

232
00:09:42,959 --> 00:09:49,279
let's take a right let's take a look at

233
00:09:46,240 --> 00:09:52,720
how android runtime has changed

234
00:09:49,279 --> 00:09:52,720
from version to version

235
00:09:53,600 --> 00:09:57,440
first when we talk about java in java

236
00:09:55,920 --> 00:10:00,079
virtual machine

237
00:09:57,440 --> 00:10:01,680
an android application written in java

238
00:10:00,080 --> 00:10:04,880
language for dynamic

239
00:10:01,680 --> 00:10:06,319
develop for developer productivity and

240
00:10:04,880 --> 00:10:09,519
code mobility

241
00:10:06,320 --> 00:10:11,440
on desktop and server environment a java

242
00:10:09,519 --> 00:10:14,480
program is compiled to the java

243
00:10:11,440 --> 00:10:15,839
byte code which is an intermediate

244
00:10:14,480 --> 00:10:19,120
representation

245
00:10:15,839 --> 00:10:21,200
for java virtual machine

246
00:10:19,120 --> 00:10:23,839
java virtual machine run the java byte

247
00:10:21,200 --> 00:10:25,040
code the java byte code is based on the

248
00:10:23,839 --> 00:10:28,320
stack based

249
00:10:25,040 --> 00:10:30,640
based introduction however since the

250
00:10:28,320 --> 00:10:33,920
performance of stack based

251
00:10:30,640 --> 00:10:37,120
java bytecode on resource-related

252
00:10:33,920 --> 00:10:40,160
mobile device is pure poor

253
00:10:37,120 --> 00:10:42,959
due to slow interpretation

254
00:10:40,160 --> 00:10:44,160
so android researchers have created new

255
00:10:42,959 --> 00:10:47,518
bytecode set

256
00:10:44,160 --> 00:10:50,160
which is a diabetic byte code for uh

257
00:10:47,519 --> 00:10:51,839
for diabetic virtual machine to improve

258
00:10:50,160 --> 00:10:55,839
the performance of android

259
00:10:51,839 --> 00:10:56,640
application in contrast to java byte

260
00:10:55,839 --> 00:10:59,680
code

261
00:10:56,640 --> 00:11:02,399
the uh the direct byte code is based on

262
00:10:59,680 --> 00:11:04,399
register based instruction set therefore

263
00:11:02,399 --> 00:11:09,200
it can reduce the code size

264
00:11:04,399 --> 00:11:09,200
and the running time in mobile device

265
00:11:10,079 --> 00:11:14,000
until android pro and earlier there was

266
00:11:12,959 --> 00:11:16,560
only interpreter

267
00:11:14,000 --> 00:11:17,920
in direct virtual machine every time you

268
00:11:16,560 --> 00:11:20,160
run the app

269
00:11:17,920 --> 00:11:21,760
the interpreter converts all bytecode

270
00:11:20,160 --> 00:11:24,719
into native code

271
00:11:21,760 --> 00:11:27,360
a slowdown apps on startup startup

272
00:11:24,720 --> 00:11:29,839
timeshow battery

273
00:11:27,360 --> 00:11:30,800
in order to in order to boost up the

274
00:11:29,839 --> 00:11:33,440
performance

275
00:11:30,800 --> 00:11:34,640
just in time compiler was introduced in

276
00:11:33,440 --> 00:11:37,760
android pro

277
00:11:34,640 --> 00:11:40,800
on derby virtual machine

278
00:11:37,760 --> 00:11:43,920
just in time compiler cache the code

279
00:11:40,800 --> 00:11:45,680
while generating the native code at the

280
00:11:43,920 --> 00:11:49,439
time of execution

281
00:11:45,680 --> 00:11:51,439
to prevent to prevent to the repeated

282
00:11:49,440 --> 00:11:54,720
generated of native code

283
00:11:51,440 --> 00:11:57,360
for each time of the same function call

284
00:11:54,720 --> 00:11:57,920
as pre-contrary as frequently used

285
00:11:57,360 --> 00:12:01,200
functions

286
00:11:57,920 --> 00:12:04,079
are executed with the native code

287
00:12:01,200 --> 00:12:06,320
that was created in advance the

288
00:12:04,079 --> 00:12:09,279
performance has increased

289
00:12:06,320 --> 00:12:11,040
this code however consume amount or

290
00:12:09,279 --> 00:12:14,000
mountain memory

291
00:12:11,040 --> 00:12:15,279
the runtime structure where jit and

292
00:12:14,000 --> 00:12:18,240
interpreter

293
00:12:15,279 --> 00:12:20,560
were in place had not changed for a

294
00:12:18,240 --> 00:12:20,560
while

295
00:12:21,839 --> 00:12:25,760
the conventional approach result in very

296
00:12:24,560 --> 00:12:28,079
well performance

297
00:12:25,760 --> 00:12:30,480
when compared to the compiled language

298
00:12:28,079 --> 00:12:33,680
like xi and xiplus plus

299
00:12:30,480 --> 00:12:34,880
as a result slow and space constrained

300
00:12:33,680 --> 00:12:37,199
computing device

301
00:12:34,880 --> 00:12:38,320
have tended not to include the virtual

302
00:12:37,200 --> 00:12:42,320
machine

303
00:12:38,320 --> 00:12:44,560
so android kitkat so in android kitkat

304
00:12:42,320 --> 00:12:48,320
google introduced a new runtime

305
00:12:44,560 --> 00:12:51,839
alt in android kitkat art

306
00:12:48,320 --> 00:12:55,680
was experimentally available

307
00:12:51,839 --> 00:12:57,680
starting from android lollipop in 2015

308
00:12:55,680 --> 00:12:59,040
google decided to replace diabetic

309
00:12:57,680 --> 00:13:02,800
virtual machine

310
00:12:59,040 --> 00:13:07,599
and made the ait as a departure on time

311
00:13:02,800 --> 00:13:11,040
to improve the runtime performance

312
00:13:07,600 --> 00:13:13,680
ait adopted ahead of time compile

313
00:13:11,040 --> 00:13:15,279
compilation strategy instead of

314
00:13:13,680 --> 00:13:19,359
interpretation

315
00:13:15,279 --> 00:13:22,560
ait provider compiler called x2080

316
00:13:19,360 --> 00:13:25,680
the dedex 280 will directly compile the

317
00:13:22,560 --> 00:13:28,319
compiled export into native code

318
00:13:25,680 --> 00:13:30,319
during the app installation and then

319
00:13:28,320 --> 00:13:33,839
stored as an

320
00:13:30,320 --> 00:13:38,000
aot file the result is essentially

321
00:13:33,839 --> 00:13:41,199
an er file that that that is then

322
00:13:38,000 --> 00:13:44,160
executed natively so

323
00:13:41,199 --> 00:13:46,639
instead of having bytecode that that is

324
00:13:44,160 --> 00:13:50,480
interpreted by virtual machine

325
00:13:46,639 --> 00:13:53,839
it has native code that can be executed

326
00:13:50,480 --> 00:13:54,160
natively by by the processor this is uh

327
00:13:53,839 --> 00:13:57,199
this

328
00:13:54,160 --> 00:13:59,680
is called the aot compilation but

329
00:13:57,199 --> 00:14:00,880
main different uh main difference is

330
00:13:59,680 --> 00:14:03,839
that art

331
00:14:00,880 --> 00:14:05,040
pre-compiled everything but direct

332
00:14:03,839 --> 00:14:07,680
virtual machine use

333
00:14:05,040 --> 00:14:08,959
heuristic to detect the code that run

334
00:14:07,680 --> 00:14:13,040
most often

335
00:14:08,959 --> 00:14:17,279
and only compile a subset of bytecode

336
00:14:13,040 --> 00:14:19,760
during the execution

337
00:14:17,279 --> 00:14:21,360
and another difference between uh

338
00:14:19,760 --> 00:14:24,240
another difference between

339
00:14:21,360 --> 00:14:25,680
the the old diabetic virtual machine and

340
00:14:24,240 --> 00:14:28,959
art

341
00:14:25,680 --> 00:14:31,920
was the performance as all as

342
00:14:28,959 --> 00:14:32,160
all the execution code of app were run

343
00:14:31,920 --> 00:14:34,880
as

344
00:14:32,160 --> 00:14:37,439
native code the startup speed was

345
00:14:34,880 --> 00:14:39,920
improved compared to the bytecode

346
00:14:37,440 --> 00:14:40,639
in addition to that every time you ran

347
00:14:39,920 --> 00:14:42,800
the app

348
00:14:40,639 --> 00:14:44,399
it didn't use the interpreter but it

349
00:14:42,800 --> 00:14:47,680
called the native code

350
00:14:44,399 --> 00:14:49,680
and it resulted in reducing battery

351
00:14:47,680 --> 00:14:53,040
consumption

352
00:14:49,680 --> 00:14:53,680
since jit wasn't used anymore the memory

353
00:14:53,040 --> 00:14:56,240
usage

354
00:14:53,680 --> 00:14:58,479
was also reduced because it didn't keep

355
00:14:56,240 --> 00:15:03,279
the code caching memory

356
00:14:58,480 --> 00:15:06,480
and and and of the aot compilation

357
00:15:03,279 --> 00:15:08,720
the dex208 compiler can perform multiple

358
00:15:06,480 --> 00:15:13,839
passes for optimization

359
00:15:08,720 --> 00:15:18,320
to achieve better performance

360
00:15:13,839 --> 00:15:21,120
but it uh it lost as much as it gained

361
00:15:18,320 --> 00:15:22,959
the big the biggest problem was it took

362
00:15:21,120 --> 00:15:25,920
too much time to install

363
00:15:22,959 --> 00:15:27,359
it and it took too much time to update

364
00:15:25,920 --> 00:15:31,360
the system

365
00:15:27,360 --> 00:15:33,120
via ota eventually by compiling orbit

366
00:15:31,360 --> 00:15:35,920
code to native code

367
00:15:33,120 --> 00:15:37,040
at install time it gained the app's

368
00:15:35,920 --> 00:15:40,079
performance

369
00:15:37,040 --> 00:15:41,680
however it required much more time to

370
00:15:40,079 --> 00:15:45,359
update app and system

371
00:15:41,680 --> 00:15:45,758
and more storage too then is it really

372
00:15:45,360 --> 00:15:48,480
the

373
00:15:45,759 --> 00:15:48,959
best compile or byte code into native

374
00:15:48,480 --> 00:15:52,560
code

375
00:15:48,959 --> 00:15:54,880
at app insert time we need to first

376
00:15:52,560 --> 00:15:55,599
understand the usage pattern of a mobile

377
00:15:54,880 --> 00:15:59,120
user

378
00:15:55,600 --> 00:16:02,160
in fact we don't use all of the menu in

379
00:15:59,120 --> 00:16:04,639
in the app for example

380
00:16:02,160 --> 00:16:06,639
i use a mobile banking app there are

381
00:16:04,639 --> 00:16:08,399
there are a lot of financial related

382
00:16:06,639 --> 00:16:11,440
menu india

383
00:16:08,399 --> 00:16:14,959
and i just i use just two

384
00:16:11,440 --> 00:16:17,759
first i check how much is in my account

385
00:16:14,959 --> 00:16:18,479
second i transfer money from from the

386
00:16:17,759 --> 00:16:22,079
account

387
00:16:18,480 --> 00:16:25,360
that's it all there are so many

388
00:16:22,079 --> 00:16:27,758
menu in the app i use only two feature

389
00:16:25,360 --> 00:16:29,279
then you don't re uh you don't really

390
00:16:27,759 --> 00:16:33,839
need to compile everything

391
00:16:29,279 --> 00:16:36,800
wasting your time and and storage

392
00:16:33,839 --> 00:16:38,240
or all you need is to selectively

393
00:16:36,800 --> 00:16:42,719
compile the code

394
00:16:38,240 --> 00:16:42,720
that are frequently used by the user

395
00:16:44,160 --> 00:16:50,800
so in android 7 google was reintroduced

396
00:16:47,839 --> 00:16:51,040
just in time compiler there was remove

397
00:16:50,800 --> 00:16:54,560
in

398
00:16:51,040 --> 00:16:55,279
android 5. the justin time compiler

399
00:16:54,560 --> 00:16:58,800
complements

400
00:16:55,279 --> 00:17:02,480
aud compiler and helpful improvement in

401
00:16:58,800 --> 00:17:04,799
help improve runtime performance

402
00:17:02,480 --> 00:17:07,120
and they removed the byte code compiling

403
00:17:04,799 --> 00:17:10,240
step in aot compilation

404
00:17:07,119 --> 00:17:14,719
during the app installation so

405
00:17:10,240 --> 00:17:14,720
when will the aot compiler start working

406
00:17:15,520 --> 00:17:20,240
google introduced a new technique called

407
00:17:17,760 --> 00:17:23,039
profile guide optimization

408
00:17:20,240 --> 00:17:24,480
during the app installation the aot

409
00:17:23,039 --> 00:17:27,679
compiler doesn't

410
00:17:24,480 --> 00:17:28,880
does not operate and uh and the app

411
00:17:27,679 --> 00:17:32,000
isn't

412
00:17:28,880 --> 00:17:35,120
app is not installed immediately as byte

413
00:17:32,000 --> 00:17:37,440
code or when you use the app

414
00:17:35,120 --> 00:17:38,639
the byte code is executed using the

415
00:17:37,440 --> 00:17:41,520
interpreter

416
00:17:38,640 --> 00:17:44,000
and it counts how many times each

417
00:17:41,520 --> 00:17:47,440
individual function is called

418
00:17:44,000 --> 00:17:48,799
called at execution time as the number

419
00:17:47,440 --> 00:17:51,039
of execution

420
00:17:48,799 --> 00:17:52,000
increases it divides the state of

421
00:17:51,039 --> 00:17:55,360
function from

422
00:17:52,000 --> 00:17:58,480
cold to warm and finally hot

423
00:17:55,360 --> 00:18:01,280
once the state of function becomes warm

424
00:17:58,480 --> 00:18:02,400
the profiling is profiling info is

425
00:18:01,280 --> 00:18:05,840
created to the

426
00:18:02,400 --> 00:18:06,559
grid to record the information such as

427
00:18:05,840 --> 00:18:09,600
the number of

428
00:18:06,559 --> 00:18:13,120
execution then save in the

429
00:18:09,600 --> 00:18:15,600
uh save in the mobile device

430
00:18:13,120 --> 00:18:16,879
when you don't use your phone or when

431
00:18:15,600 --> 00:18:19,760
you charge it

432
00:18:16,880 --> 00:18:21,280
based on uh based on the profiling input

433
00:18:19,760 --> 00:18:24,240
the profile service

434
00:18:21,280 --> 00:18:25,360
use aot2 compile the bytecode into

435
00:18:24,240 --> 00:18:28,400
native code

436
00:18:25,360 --> 00:18:31,678
and store it and once the

437
00:18:28,400 --> 00:18:33,919
state of the function which is hot

438
00:18:31,679 --> 00:18:35,280
the byte code is compiled into the

439
00:18:33,919 --> 00:18:38,320
native code by

440
00:18:35,280 --> 00:18:39,120
just in time compiler and store it in

441
00:18:38,320 --> 00:18:42,799
memory

442
00:18:39,120 --> 00:18:45,760
as a cache i explained earlier

443
00:18:42,799 --> 00:18:47,918
that the old compilation method convert

444
00:18:45,760 --> 00:18:51,520
or byte code into native code

445
00:18:47,919 --> 00:18:52,480
and store regardless of of the usage

446
00:18:51,520 --> 00:18:54,960
pattern

447
00:18:52,480 --> 00:18:56,000
it really slow down and update an

448
00:18:54,960 --> 00:19:00,000
installation

449
00:18:56,000 --> 00:19:00,000
and require more space

450
00:19:01,600 --> 00:19:04,639
but now we have profile guide

451
00:19:03,360 --> 00:19:07,520
optimization

452
00:19:04,640 --> 00:19:10,320
that selectively creates a native code

453
00:19:07,520 --> 00:19:12,799
for the feature frequently used

454
00:19:10,320 --> 00:19:14,399
profile guide optimization already

455
00:19:12,799 --> 00:19:18,160
android runtime to help

456
00:19:14,400 --> 00:19:21,360
improve improve on apps performance

457
00:19:18,160 --> 00:19:24,400
by building a profile of a hard code and

458
00:19:21,360 --> 00:19:27,520
focusing each optimization

459
00:19:24,400 --> 00:19:29,840
this widget too big improvement while

460
00:19:27,520 --> 00:19:33,120
reducing the traditional memory

461
00:19:29,840 --> 00:19:36,240
and the storage impact of our

462
00:19:33,120 --> 00:19:38,479
fully compiled air it seemed

463
00:19:36,240 --> 00:19:40,559
we found the perfect balance between app

464
00:19:38,480 --> 00:19:44,720
speed storage usage

465
00:19:40,559 --> 00:19:47,440
and updated time however on project 3

466
00:19:44,720 --> 00:19:48,799
this method turned out to bring another

467
00:19:47,440 --> 00:19:53,840
problem

468
00:19:48,799 --> 00:19:53,840
so what is the problem here

469
00:19:54,480 --> 00:20:00,960
however app runs slowly at first range

470
00:19:58,160 --> 00:20:03,360
because profile guide optimization rely

471
00:20:00,960 --> 00:20:06,720
on device to optimize them

472
00:20:03,360 --> 00:20:09,439
based on this code profile in idle time

473
00:20:06,720 --> 00:20:10,480
which means it could be a few days

474
00:20:09,440 --> 00:20:14,559
before

475
00:20:10,480 --> 00:20:14,559
before the app to run faster

476
00:20:15,360 --> 00:20:20,000
to solve the problem of slow execution

477
00:20:19,200 --> 00:20:23,200
at first launch

478
00:20:20,000 --> 00:20:24,400
of app google introduced the cloud-based

479
00:20:23,200 --> 00:20:27,679
profile technique

480
00:20:24,400 --> 00:20:31,039
in android 9. as shown in figure

481
00:20:27,679 --> 00:20:34,559
the profile information of app greatly

482
00:20:31,039 --> 00:20:36,080
created on each user's device is almost

483
00:20:34,559 --> 00:20:39,120
uploaded to the cloud

484
00:20:36,080 --> 00:20:42,320
server in the cloud server most

485
00:20:39,120 --> 00:20:44,158
apps are share a good amount amount of

486
00:20:42,320 --> 00:20:47,360
code profile information

487
00:20:44,159 --> 00:20:50,960
that are used across across different

488
00:20:47,360 --> 00:20:54,158
users and the device and this can be

489
00:20:50,960 --> 00:20:56,880
globally optimized for everyone

490
00:20:54,159 --> 00:20:58,400
the initial user's device can create a

491
00:20:56,880 --> 00:21:02,080
profile information

492
00:20:58,400 --> 00:21:04,400
for rest of the user space so the

493
00:21:02,080 --> 00:21:06,799
following users can optimize the app

494
00:21:04,400 --> 00:21:09,840
after aot compilation

495
00:21:06,799 --> 00:21:14,400
using cloud-based profile data

496
00:21:09,840 --> 00:21:14,399
at the time of app insert installation

497
00:21:15,520 --> 00:21:21,840
this slide showed the whole process of

498
00:21:18,559 --> 00:21:24,879
how apps are compiled and executed in

499
00:21:21,840 --> 00:21:28,080
android android 10 first

500
00:21:24,880 --> 00:21:30,559
when you try to insert the app apk file

501
00:21:28,080 --> 00:21:33,760
is downloaded to your mobile device

502
00:21:30,559 --> 00:21:35,678
along with the optimized profile data as

503
00:21:33,760 --> 00:21:37,919
described earlier

504
00:21:35,679 --> 00:21:39,280
during the installation the profile

505
00:21:37,919 --> 00:21:42,480
information is used

506
00:21:39,280 --> 00:21:44,879
used by aot compiler to selectively

507
00:21:42,480 --> 00:21:48,080
compile the byte code into aot

508
00:21:44,880 --> 00:21:51,840
code for the function

509
00:21:48,080 --> 00:21:55,039
that are commonly used by user

510
00:21:51,840 --> 00:21:57,678
second when you executed the app

511
00:21:55,039 --> 00:21:59,600
ai detects whether the code of the

512
00:21:57,679 --> 00:22:03,280
running method is compiled

513
00:21:59,600 --> 00:22:04,399
or not if the code is already compiled

514
00:22:03,280 --> 00:22:08,000
by

515
00:22:04,400 --> 00:22:11,360
chip or aot it directly called the

516
00:22:08,000 --> 00:22:12,720
code loaded in memory and executed

517
00:22:11,360 --> 00:22:15,840
immediately

518
00:22:12,720 --> 00:22:17,280
if this code is still bytecode the

519
00:22:15,840 --> 00:22:19,199
interpreter executed

520
00:22:17,280 --> 00:22:20,399
and increase the method execution

521
00:22:19,200 --> 00:22:23,280
counter

522
00:22:20,400 --> 00:22:25,039
if the counter of of the method can

523
00:22:23,280 --> 00:22:27,918
continue to increase

524
00:22:25,039 --> 00:22:28,640
and it become warm state the profile

525
00:22:27,919 --> 00:22:31,840
information

526
00:22:28,640 --> 00:22:35,440
such as a number of method execution is

527
00:22:31,840 --> 00:22:37,760
saved in the device as your file

528
00:22:35,440 --> 00:22:40,000
while you are not using the phone but

529
00:22:37,760 --> 00:22:42,559
just charging overnight

530
00:22:40,000 --> 00:22:43,200
the service company the service compiled

531
00:22:42,559 --> 00:22:46,240
the one

532
00:22:43,200 --> 00:22:49,520
method using the aot compiler

533
00:22:46,240 --> 00:22:52,960
and save it save it in file as your

534
00:22:49,520 --> 00:22:56,639
aud code next time the method will be

535
00:22:52,960 --> 00:23:00,080
executed right away as aot code

536
00:22:56,640 --> 00:23:01,039
from from the beginning and if the

537
00:23:00,080 --> 00:23:03,280
counter keeps

538
00:23:01,039 --> 00:23:04,480
increasing and it finally becomes the

539
00:23:03,280 --> 00:23:07,520
hot state

540
00:23:04,480 --> 00:23:10,400
the method is compiled in real time by

541
00:23:07,520 --> 00:23:14,320
just the entire compiler

542
00:23:10,400 --> 00:23:17,200
and the story uh sorry the memory as a

543
00:23:14,320 --> 00:23:17,760
code cache then the code loaded in

544
00:23:17,200 --> 00:23:20,960
memory

545
00:23:17,760 --> 00:23:23,840
is executed and as soon as a

546
00:23:20,960 --> 00:23:23,840
function is called

547
00:23:25,280 --> 00:23:32,639
as you see here art has various state

548
00:23:28,320 --> 00:23:34,639
state of code and complex structure

549
00:23:32,640 --> 00:23:35,760
where the apps are optimized and

550
00:23:34,640 --> 00:23:39,280
executed

551
00:23:35,760 --> 00:23:42,559
based on the pattern of individual and

552
00:23:39,280 --> 00:23:42,559
entire user base

553
00:23:43,679 --> 00:23:47,200
okay now i'd like to take a closer look

554
00:23:46,799 --> 00:23:50,400
at

555
00:23:47,200 --> 00:23:52,400
the android runtime at code repair

556
00:23:50,400 --> 00:23:54,480
based on that i'm going to propose your

557
00:23:52,400 --> 00:23:55,039
technique to analyze the execution of

558
00:23:54,480 --> 00:23:58,880
app

559
00:23:55,039 --> 00:23:58,879
through the ait customization

560
00:23:59,200 --> 00:24:04,240
as we saw earlier there are three types

561
00:24:02,320 --> 00:24:08,080
of code

562
00:24:04,240 --> 00:24:13,200
in ait the basic text byte code

563
00:24:08,080 --> 00:24:16,320
and compile the aot code and jit code

564
00:24:13,200 --> 00:24:18,720
aot code and byte code are saved in file

565
00:24:16,320 --> 00:24:20,399
while cheat code exists in memory as

566
00:24:18,720 --> 00:24:22,880
cache code

567
00:24:20,400 --> 00:24:25,279
in mobile device there are three files

568
00:24:22,880 --> 00:24:28,240
in in application directory

569
00:24:25,279 --> 00:24:30,159
that sort iot code and byte code

570
00:24:28,240 --> 00:24:33,039
information

571
00:24:30,159 --> 00:24:33,600
the first one is base ait the file

572
00:24:33,039 --> 00:24:36,400
contains

573
00:24:33,600 --> 00:24:37,279
ait internal web representation of some

574
00:24:36,400 --> 00:24:40,880
strings

575
00:24:37,279 --> 00:24:43,840
and currencies rest in in the apk

576
00:24:40,880 --> 00:24:45,120
used to boost up boost to application

577
00:24:43,840 --> 00:24:48,559
startup

578
00:24:45,120 --> 00:24:49,039
the second one is base odx5 the file

579
00:24:48,559 --> 00:24:52,960
contains

580
00:24:49,039 --> 00:24:55,760
aot compile code for method in apk

581
00:24:52,960 --> 00:24:56,640
the rest one is base breedex file this

582
00:24:55,760 --> 00:25:00,480
file contains

583
00:24:56,640 --> 00:25:01,120
redux code of apk with some additional

584
00:25:00,480 --> 00:25:06,720
meta

585
00:25:01,120 --> 00:25:06,719
metadata to speed up the verification

586
00:25:07,279 --> 00:25:10,720
this file can be dumped to desk byte

587
00:25:09,919 --> 00:25:14,320
code and

588
00:25:10,720 --> 00:25:17,200
aot code using the oat dump module

589
00:25:14,320 --> 00:25:17,760
this feature shows the result of dumping

590
00:25:17,200 --> 00:25:21,120
the

591
00:25:17,760 --> 00:25:24,320
base odex file stored in store in the

592
00:25:21,120 --> 00:25:24,320
application directory

593
00:25:25,919 --> 00:25:28,960
if we look at the first line in blue

594
00:25:28,320 --> 00:25:31,918
there is

595
00:25:28,960 --> 00:25:33,120
any function as your first method in in

596
00:25:31,919 --> 00:25:36,559
the class

597
00:25:33,120 --> 00:25:37,760
and the name is uh com applier internal

598
00:25:36,559 --> 00:25:40,158
ac

599
00:25:37,760 --> 00:25:43,440
this inner function exists in two

600
00:25:40,159 --> 00:25:46,400
different form

601
00:25:43,440 --> 00:25:47,520
the part written as a dax code is a

602
00:25:46,400 --> 00:25:50,240
bytecode of

603
00:25:47,520 --> 00:25:50,240
any function

604
00:25:50,799 --> 00:25:55,120
the second part written as code is

605
00:25:53,760 --> 00:25:58,000
compiled code

606
00:25:55,120 --> 00:25:58,959
which was converted from converted from

607
00:25:58,000 --> 00:26:02,240
byte code by

608
00:25:58,960 --> 00:26:05,200
aot compiler and

609
00:26:02,240 --> 00:26:06,159
if we look at the other part you can see

610
00:26:05,200 --> 00:26:10,000
any function

611
00:26:06,159 --> 00:26:13,200
in class com airfryer internal t

612
00:26:10,000 --> 00:26:16,240
uh t dollar one

613
00:26:13,200 --> 00:26:19,360
this function has a dash code

614
00:26:16,240 --> 00:26:23,679
but uh the uh but the chord area just

615
00:26:19,360 --> 00:26:27,600
shows no code it is no compiled code but

616
00:26:23,679 --> 00:26:30,640
it exists only as a byte code

617
00:26:27,600 --> 00:26:33,678
so what does this mean even

618
00:26:30,640 --> 00:26:37,039
even if the function is converted

619
00:26:33,679 --> 00:26:38,159
and saved into the compiled code by aot

620
00:26:37,039 --> 00:26:41,200
compiler

621
00:26:38,159 --> 00:26:43,200
the byte code is saved anyway this

622
00:26:41,200 --> 00:26:44,880
is because the original byte code is

623
00:26:43,200 --> 00:26:48,240
used when the debugging

624
00:26:44,880 --> 00:26:53,440
is required or art is updated to

625
00:26:48,240 --> 00:26:56,799
reoptimize the code in india

626
00:26:53,440 --> 00:26:59,440
if so let's take a look at how byte code

627
00:26:56,799 --> 00:27:03,840
and aot code are loaded into memory

628
00:26:59,440 --> 00:27:04,880
by alt each code is linked to a8 method

629
00:27:03,840 --> 00:27:07,918
object

630
00:27:04,880 --> 00:27:12,400
through the classwinker the a

631
00:27:07,919 --> 00:27:15,440
uart method object is an instantiated

632
00:27:12,400 --> 00:27:18,960
object in the form of c plus plus

633
00:27:15,440 --> 00:27:21,279
class to execute each method within the

634
00:27:18,960 --> 00:27:24,159
java class on art

635
00:27:21,279 --> 00:27:24,880
base odx file contains the oat code and

636
00:27:24,159 --> 00:27:28,080
the

637
00:27:24,880 --> 00:27:30,720
base bidx file contains the byte code

638
00:27:28,080 --> 00:27:34,158
when the app is executed each file is

639
00:27:30,720 --> 00:27:36,960
loaded into memory by runtime

640
00:27:34,159 --> 00:27:37,279
this is a simple simplified picture of

641
00:27:36,960 --> 00:27:40,399
how

642
00:27:37,279 --> 00:27:44,480
oat and byte code are linked to

643
00:27:40,399 --> 00:27:47,520
the ait method object inside the ait

644
00:27:44,480 --> 00:27:48,240
through the class rinker before the

645
00:27:47,520 --> 00:27:51,200
execution

646
00:27:48,240 --> 00:27:52,640
all methods in india are linked to the

647
00:27:51,200 --> 00:27:56,159
execution code

648
00:27:52,640 --> 00:27:58,720
as a art method object

649
00:27:56,159 --> 00:28:01,760
the class wrinkle called the function

650
00:27:58,720 --> 00:28:04,880
set entry point from key compiled code

651
00:28:01,760 --> 00:28:06,000
to assign and assign the address of aut

652
00:28:04,880 --> 00:28:08,960
code

653
00:28:06,000 --> 00:28:10,159
to entry point from key compiled code

654
00:28:08,960 --> 00:28:13,760
variable

655
00:28:10,159 --> 00:28:16,000
of ait method object

656
00:28:13,760 --> 00:28:17,039
and by calling set decline class

657
00:28:16,000 --> 00:28:19,360
function

658
00:28:17,039 --> 00:28:20,640
text cache is assigned to the declaring

659
00:28:19,360 --> 00:28:24,240
class variable

660
00:28:20,640 --> 00:28:26,720
of ait method object now we can call the

661
00:28:24,240 --> 00:28:30,159
byte code through the text cache

662
00:28:26,720 --> 00:28:32,080
in short all function executed by art

663
00:28:30,159 --> 00:28:35,279
are loaded into each

664
00:28:32,080 --> 00:28:38,399
ait method object we can execute

665
00:28:35,279 --> 00:28:42,080
any function through this object

666
00:28:38,399 --> 00:28:44,639
and as we saw earlier as we saw here

667
00:28:42,080 --> 00:28:46,000
there is more than one on one type of

668
00:28:44,640 --> 00:28:49,520
one type of code

669
00:28:46,000 --> 00:28:50,080
we want to execute so we need to call

670
00:28:49,520 --> 00:28:52,559
different

671
00:28:50,080 --> 00:28:54,879
type of code for byte code and compiled

672
00:28:52,559 --> 00:28:54,879
code

673
00:28:55,360 --> 00:28:59,520
as shown in the picture one main

674
00:28:57,520 --> 00:29:02,080
function consists of

675
00:28:59,520 --> 00:29:02,639
several sub function and its sole

676
00:29:02,080 --> 00:29:05,199
function

677
00:29:02,640 --> 00:29:06,880
also consists of several several small

678
00:29:05,200 --> 00:29:09,840
sub functions

679
00:29:06,880 --> 00:29:10,640
let's take a look at the step of core

680
00:29:09,840 --> 00:29:16,240
and

681
00:29:10,640 --> 00:29:20,000
execute the sub function232

682
00:29:16,240 --> 00:29:24,559
main function subfunction2 so function23

683
00:29:20,000 --> 00:29:27,440
so function232 are called in order that

684
00:29:24,559 --> 00:29:28,639
each function exists particularly as a

685
00:29:27,440 --> 00:29:32,240
byte code

686
00:29:28,640 --> 00:29:34,799
and particularly as compiled code

687
00:29:32,240 --> 00:29:36,559
because of that we need to call compiled

688
00:29:34,799 --> 00:29:39,679
code from bytecode

689
00:29:36,559 --> 00:29:42,480
and bytecode from compiled code

690
00:29:39,679 --> 00:29:45,919
this cross code from different code make

691
00:29:42,480 --> 00:29:48,480
a erg structure more complicated

692
00:29:45,919 --> 00:29:51,279
so let's see how ait cross calls the

693
00:29:48,480 --> 00:29:53,679
different code

694
00:29:51,279 --> 00:29:55,279
the first code execution is start from

695
00:29:53,679 --> 00:29:57,919
ait method

696
00:29:55,279 --> 00:30:01,360
this is because the aeit method object

697
00:29:57,919 --> 00:30:04,000
has both byte code and compiled code

698
00:30:01,360 --> 00:30:05,039
if the function exists as a compiled

699
00:30:04,000 --> 00:30:08,080
code

700
00:30:05,039 --> 00:30:08,399
ait message directory invoke the code

701
00:30:08,080 --> 00:30:11,678
and

702
00:30:08,399 --> 00:30:12,399
execute it if the compiled code doesn't

703
00:30:11,679 --> 00:30:16,320
exist

704
00:30:12,399 --> 00:30:20,320
in doesn't exist the interpreter is used

705
00:30:16,320 --> 00:30:23,200
to execute the byte code of function

706
00:30:20,320 --> 00:30:24,559
and after execution of the point typo

707
00:30:23,200 --> 00:30:26,960
function

708
00:30:24,559 --> 00:30:29,120
the compiled code called the interpreter

709
00:30:26,960 --> 00:30:31,039
or vice versa

710
00:30:29,120 --> 00:30:33,039
sometimes the interpreter called the

711
00:30:31,039 --> 00:30:35,158
interpreter again

712
00:30:33,039 --> 00:30:36,399
in this way state change occur

713
00:30:35,159 --> 00:30:40,159
accordingly

714
00:30:36,399 --> 00:30:40,158
within the ait structure

715
00:30:40,799 --> 00:30:45,918
this is a code flow that analyzed the

716
00:30:43,360 --> 00:30:49,360
execution process in art

717
00:30:45,919 --> 00:30:53,360
here compile code called the byte code

718
00:30:49,360 --> 00:30:58,399
and byte code called the compiled code

719
00:30:53,360 --> 00:30:58,399
and byte code also called the byte code

720
00:30:58,559 --> 00:31:02,080
i think it may not be easy to understand

721
00:31:01,120 --> 00:31:04,639
the whole process

722
00:31:02,080 --> 00:31:06,720
at once but if you focus on the code

723
00:31:04,640 --> 00:31:09,919
execution aspect

724
00:31:06,720 --> 00:31:13,600
there are two parts in in horror picture

725
00:31:09,919 --> 00:31:16,240
where code is executed

726
00:31:13,600 --> 00:31:18,799
the first part is compiled code which

727
00:31:16,240 --> 00:31:22,159
called ait quick inbox stop function

728
00:31:18,799 --> 00:31:23,918
through the invoke function in ait

729
00:31:22,159 --> 00:31:26,399
method

730
00:31:23,919 --> 00:31:26,960
this when this function invoke the x

731
00:31:26,399 --> 00:31:30,799
invoke

732
00:31:26,960 --> 00:31:30,799
and execute the compiled code

733
00:31:31,039 --> 00:31:37,760
the second part is byte code which call

734
00:31:34,559 --> 00:31:40,639
xq2m trp inpl or

735
00:31:37,760 --> 00:31:41,440
execute switch impl function through the

736
00:31:40,640 --> 00:31:44,880
interpreter

737
00:31:41,440 --> 00:31:45,200
execution function this function convert

738
00:31:44,880 --> 00:31:49,200
to

739
00:31:45,200 --> 00:31:51,360
bytecode into native code and execute it

740
00:31:49,200 --> 00:31:54,799
all the information required to execute

741
00:31:51,360 --> 00:31:57,439
the app go through the dg2 part

742
00:31:54,799 --> 00:31:59,519
the information contain contains

743
00:31:57,440 --> 00:32:02,880
parameter and return value

744
00:31:59,519 --> 00:32:03,600
the code course tag and so on in other

745
00:32:02,880 --> 00:32:06,320
words

746
00:32:03,600 --> 00:32:08,559
if we watch the ait method inbox and

747
00:32:06,320 --> 00:32:10,639
interpreter execute function

748
00:32:08,559 --> 00:32:12,639
you can trace all code running on

749
00:32:10,640 --> 00:32:16,640
android

750
00:32:12,640 --> 00:32:19,679
is it very possible however

751
00:32:16,640 --> 00:32:20,640
there was one missing piece that we

752
00:32:19,679 --> 00:32:24,399
could not see

753
00:32:20,640 --> 00:32:28,159
uh in flow in in the flow

754
00:32:24,399 --> 00:32:30,000
what is that there's the process

755
00:32:28,159 --> 00:32:31,679
by which compile code called the

756
00:32:30,000 --> 00:32:34,960
compiled code

757
00:32:31,679 --> 00:32:38,880
so why is this corner show shown

758
00:32:34,960 --> 00:32:41,200
in this picture i'd like to go back

759
00:32:38,880 --> 00:32:42,559
and remind you how compiled code is

760
00:32:41,200 --> 00:32:45,279
called

761
00:32:42,559 --> 00:32:46,559
as i explained before ait me so the

762
00:32:45,279 --> 00:32:50,080
inbox call

763
00:32:46,559 --> 00:32:51,360
ait quick inbox soft function to execute

764
00:32:50,080 --> 00:32:54,559
the compiled code by

765
00:32:51,360 --> 00:32:56,000
invoke the code loaded in memory let's

766
00:32:54,559 --> 00:32:58,559
dig into more about

767
00:32:56,000 --> 00:32:58,559
this part

768
00:32:59,200 --> 00:33:02,480
the inbox function of the ait method

769
00:33:02,000 --> 00:33:04,480
class

770
00:33:02,480 --> 00:33:06,960
called the ai to kick inbox stop

771
00:33:04,480 --> 00:33:06,960
function

772
00:33:07,360 --> 00:33:11,039
the ait quick inbox sub function is

773
00:33:10,080 --> 00:33:14,559
written in

774
00:33:11,039 --> 00:33:15,279
arm assembly code to push to boost the

775
00:33:14,559 --> 00:33:18,320
execution

776
00:33:15,279 --> 00:33:21,200
speed this function has

777
00:33:18,320 --> 00:33:23,439
address address of target function to be

778
00:33:21,200 --> 00:33:26,159
invoked and executed

779
00:33:23,440 --> 00:33:28,159
this picture shows the code to get the

780
00:33:26,159 --> 00:33:31,919
address of the function

781
00:33:28,159 --> 00:33:33,840
to be executed this part contain the

782
00:33:31,919 --> 00:33:37,039
address of the variable

783
00:33:33,840 --> 00:33:39,600
and three point from key compiled code

784
00:33:37,039 --> 00:33:40,799
and this variable contain the address of

785
00:33:39,600 --> 00:33:43,918
compiled code

786
00:33:40,799 --> 00:33:45,120
for executing function put this address

787
00:33:43,919 --> 00:33:47,919
into x9

788
00:33:45,120 --> 00:33:50,799
and directly called the compiled code

789
00:33:47,919 --> 00:33:54,080
using branch instruction

790
00:33:50,799 --> 00:33:56,559
let's call this compile code a

791
00:33:54,080 --> 00:33:57,600
then a direct recorded address of next

792
00:33:56,559 --> 00:34:00,960
function b

793
00:33:57,600 --> 00:34:02,799
which is in compiled code again b

794
00:34:00,960 --> 00:34:04,960
directly called address of the next

795
00:34:02,799 --> 00:34:07,760
function c

796
00:34:04,960 --> 00:34:08,639
which also exists on compiled code

797
00:34:07,760 --> 00:34:12,079
unlike

798
00:34:08,639 --> 00:34:14,399
unlike core structure we saw before

799
00:34:12,079 --> 00:34:15,359
you can see the direct call from memory

800
00:34:14,399 --> 00:34:17,440
to memory

801
00:34:15,359 --> 00:34:19,359
when combined code called another

802
00:34:17,440 --> 00:34:22,399
compiled code

803
00:34:19,359 --> 00:34:25,279
if this is if this is the case

804
00:34:22,399 --> 00:34:27,918
it's impossible to trace the code when

805
00:34:25,280 --> 00:34:28,800
compiled code is executed from compiled

806
00:34:27,918 --> 00:34:32,000
code

807
00:34:28,800 --> 00:34:32,800
in addition since compiled code has been

808
00:34:32,000 --> 00:34:36,000
optimized

809
00:34:32,800 --> 00:34:38,960
a lot compared to existing java code

810
00:34:36,000 --> 00:34:39,679
it's tricky to extract the original code

811
00:34:38,960 --> 00:34:42,879
even if

812
00:34:39,679 --> 00:34:45,679
you access the compiled code so

813
00:34:42,879 --> 00:34:46,799
what i did is to change the code

814
00:34:45,679 --> 00:34:49,040
structure

815
00:34:46,800 --> 00:34:51,119
so the byte code always called the

816
00:34:49,040 --> 00:34:54,719
instead compiled code

817
00:34:51,119 --> 00:34:54,720
for for the target function

818
00:34:55,119 --> 00:34:58,960
so i change the ait method inbox

819
00:34:58,160 --> 00:35:02,000
function

820
00:34:58,960 --> 00:35:04,560
to stop executing compiled code

821
00:35:02,000 --> 00:35:06,240
and instead of instead use your

822
00:35:04,560 --> 00:35:10,240
interpreter to execute

823
00:35:06,240 --> 00:35:13,040
bytecode in this method

824
00:35:10,240 --> 00:35:14,640
the ait method inbox function to execute

825
00:35:13,040 --> 00:35:20,400
the compiled code

826
00:35:14,640 --> 00:35:20,400
in the in the exist flow is not called

827
00:35:23,119 --> 00:35:27,200
instead it forced to always provide code

828
00:35:26,320 --> 00:35:30,720
using the

829
00:35:27,200 --> 00:35:34,078
interpreter this allows you to trace the

830
00:35:30,720 --> 00:35:36,560
flow or function because they are

831
00:35:34,079 --> 00:35:37,599
executed using the interpreter

832
00:35:36,560 --> 00:35:39,920
furthermore

833
00:35:37,599 --> 00:35:42,400
you can get original code more easily

834
00:35:39,920 --> 00:35:46,240
because execution code you are getting

835
00:35:42,400 --> 00:35:49,839
in getting is smart code format

836
00:35:46,240 --> 00:35:52,319
for this propose i customize ait

837
00:35:49,839 --> 00:35:52,960
to display all information by adding a

838
00:35:52,320 --> 00:35:56,800
trace

839
00:35:52,960 --> 00:36:01,680
feature to two function ait

840
00:35:56,800 --> 00:36:01,680
method in book and interpreter execute

841
00:36:02,560 --> 00:36:06,960
as shown here no matter whether there is

842
00:36:05,599 --> 00:36:09,520
a compiled code

843
00:36:06,960 --> 00:36:10,560
for the function to be executed in ait

844
00:36:09,520 --> 00:36:14,880
method

845
00:36:10,560 --> 00:36:14,880
it will eventually call byte code

846
00:36:15,119 --> 00:36:22,320
this figure is is a table comparing

847
00:36:18,320 --> 00:36:24,960
the stack trace before and after the

848
00:36:22,320 --> 00:36:26,079
core flow change in ait with the

849
00:36:24,960 --> 00:36:29,760
technique introduced

850
00:36:26,079 --> 00:36:33,119
this in this speaking this

851
00:36:29,760 --> 00:36:36,000
figure is divided into two wizard

852
00:36:33,119 --> 00:36:38,079
the above is a stack trace result before

853
00:36:36,000 --> 00:36:40,560
changing the core structure

854
00:36:38,079 --> 00:36:41,520
and the bottom is the result of stack

855
00:36:40,560 --> 00:36:44,799
trace

856
00:36:41,520 --> 00:36:46,960
after the change before the change

857
00:36:44,800 --> 00:36:48,079
from before the change function that

858
00:36:46,960 --> 00:36:51,280
exists as a

859
00:36:48,079 --> 00:36:54,240
compiled code or called from function

860
00:36:51,280 --> 00:36:54,720
that exists as a compiled code in this

861
00:36:54,240 --> 00:36:56,720
case

862
00:36:54,720 --> 00:36:58,640
it was this chapter introduced a

863
00:36:56,720 --> 00:37:03,759
framework developed with

864
00:36:58,640 --> 00:37:03,759
with the previously described technique

865
00:37:04,079 --> 00:37:09,119
as i shown you earlier

866
00:37:07,119 --> 00:37:11,440
the code has been added to the

867
00:37:09,119 --> 00:37:14,800
customized ait

868
00:37:11,440 --> 00:37:15,359
to give you trace work since the

869
00:37:14,800 --> 00:37:19,200
function

870
00:37:15,359 --> 00:37:22,640
running in ait generated huge data

871
00:37:19,200 --> 00:37:26,960
i need i need a wave filter out

872
00:37:22,640 --> 00:37:30,000
out of data for effective analysis

873
00:37:26,960 --> 00:37:30,880
so i add a configuration file to specify

874
00:37:30,000 --> 00:37:36,400
the information

875
00:37:30,880 --> 00:37:38,880
that i want to to trace from ait

876
00:37:36,400 --> 00:37:41,839
this show the structure of of the

877
00:37:38,880 --> 00:37:44,880
computation file

878
00:37:41,839 --> 00:37:48,240
the first fact is to set the uid

879
00:37:44,880 --> 00:37:52,000
for your analysis you need this you need

880
00:37:48,240 --> 00:37:55,359
to specify the uid of of application you

881
00:37:52,000 --> 00:37:55,359
want to analyze here

882
00:37:56,000 --> 00:37:59,040
second there is an option to output

883
00:37:58,560 --> 00:38:01,440
basic

884
00:37:59,040 --> 00:38:02,640
information of of the function to be

885
00:38:01,440 --> 00:38:05,839
traced

886
00:38:02,640 --> 00:38:08,160
if it is set to y it displays the

887
00:38:05,839 --> 00:38:12,960
information of the target function

888
00:38:08,160 --> 00:38:12,960
such as argument return value and field

889
00:38:13,440 --> 00:38:19,119
so that this is an option to display the

890
00:38:17,200 --> 00:38:22,240
course tag information

891
00:38:19,119 --> 00:38:23,440
of the function to be traced if it is

892
00:38:22,240 --> 00:38:25,839
set to y

893
00:38:23,440 --> 00:38:28,800
it shows you crosstalk information of

894
00:38:25,839 --> 00:38:28,799
the target function

895
00:38:30,000 --> 00:38:34,560
the display code dump option toggle the

896
00:38:32,720 --> 00:38:37,520
output of the code

897
00:38:34,560 --> 00:38:38,560
from the function you trace if you set

898
00:38:37,520 --> 00:38:41,359
it to y

899
00:38:38,560 --> 00:38:43,440
then the smart code is printed for the

900
00:38:41,359 --> 00:38:46,000
target function

901
00:38:43,440 --> 00:38:48,720
lastly there are two options including

902
00:38:46,000 --> 00:38:52,079
an exclude

903
00:38:48,720 --> 00:38:55,279
if we want to track a surface function

904
00:38:52,079 --> 00:38:55,839
put the name here in include then all

905
00:38:55,280 --> 00:38:58,839
function

906
00:38:55,839 --> 00:39:00,799
that contain the string will be

907
00:38:58,839 --> 00:39:02,799
displayed

908
00:39:00,800 --> 00:39:04,640
and if we want to remove the some

909
00:39:02,800 --> 00:39:08,400
unnecessary function

910
00:39:04,640 --> 00:39:10,960
from the output surface file the keyword

911
00:39:08,400 --> 00:39:12,839
in exclude then the matching the

912
00:39:10,960 --> 00:39:18,079
function

913
00:39:12,839 --> 00:39:18,078
er function will not be printed

914
00:39:18,880 --> 00:39:23,359
okay what are please start demo

915
00:39:27,359 --> 00:39:31,200
right is the ubuntu console screen and

916
00:39:30,720 --> 00:39:42,720
the web

917
00:39:31,200 --> 00:39:45,439
is phone mirroring screen the app

918
00:39:42,720 --> 00:39:46,078
uh to be another wise is a centender

919
00:39:45,440 --> 00:39:48,640
used in

920
00:39:46,079 --> 00:39:49,839
argentina first open the configuration

921
00:39:48,640 --> 00:39:53,200
file

922
00:39:49,839 --> 00:39:56,320
on my mobile device uh as explained

923
00:39:53,200 --> 00:39:58,799
in previously chapter here here is a

924
00:39:56,320 --> 00:40:03,040
target wid stack trace option

925
00:39:58,800 --> 00:40:03,040
called dump option and so on

926
00:40:04,720 --> 00:40:25,839
first we get the uid of target app

927
00:40:10,240 --> 00:40:25,839
uid 10 16 8

928
00:40:30,000 --> 00:40:36,480
if you written cha uh hashish

929
00:40:33,280 --> 00:40:39,839
in front of it three times the option

930
00:40:36,480 --> 00:40:39,839
does not work

931
00:40:51,440 --> 00:40:58,079
okay start to app

932
00:40:54,480 --> 00:41:02,400
first we get the uh you can see

933
00:40:58,079 --> 00:41:05,359
all the function executed in art

934
00:41:02,400 --> 00:41:06,160
too many functions are executed you

935
00:41:05,359 --> 00:41:08,880
cannot

936
00:41:06,160 --> 00:41:09,520
you can save it as a rogue and otherwise

937
00:41:08,880 --> 00:41:12,640
the

938
00:41:09,520 --> 00:41:12,640
it later

939
00:41:17,359 --> 00:41:24,160
you can see all functions

940
00:41:20,720 --> 00:41:35,839
executed in art there are

941
00:41:24,160 --> 00:41:35,839
so many functions

942
00:42:00,839 --> 00:42:03,839
uh

943
00:42:48,400 --> 00:42:50,960
second

944
00:42:51,440 --> 00:42:58,880
we will add an option to remove

945
00:42:54,560 --> 00:43:02,960
the deport android function you will

946
00:42:58,880 --> 00:43:02,960
you will only see the custom function

947
00:43:04,800 --> 00:43:11,280
so i

948
00:43:08,079 --> 00:43:14,640
exclude excluded the

949
00:43:11,280 --> 00:43:17,280
android default function and start

950
00:43:14,640 --> 00:43:17,279
it again

951
00:43:21,280 --> 00:43:24,560
the amount of function displayed is much

952
00:43:23,920 --> 00:43:27,839
smaller

953
00:43:24,560 --> 00:43:27,839
than before

954
00:44:07,200 --> 00:44:13,919
and i try to choose you a few of

955
00:44:09,520 --> 00:44:13,920
function that you want to analyze in

956
00:44:20,839 --> 00:44:27,680
detail

957
00:44:22,640 --> 00:44:27,680
first i select com indra function

958
00:44:31,200 --> 00:44:35,680
you only need to insert a partition

959
00:44:33,839 --> 00:44:38,960
string of the function name

960
00:44:35,680 --> 00:44:38,960
to be analyzed

961
00:44:43,200 --> 00:45:05,839
second function ar consontander

962
00:44:47,040 --> 00:45:05,839
function copy and paste

963
00:45:06,560 --> 00:45:19,839
and i search the other function

964
00:45:59,040 --> 00:46:04,400
i find the com flyer function

965
00:46:05,440 --> 00:46:15,839
and copy and paste to

966
00:46:17,599 --> 00:46:29,839
choose your field of function that you

967
00:46:20,079 --> 00:46:29,839
want to analyze in detail

968
00:46:30,880 --> 00:46:43,839
and i try to run the app again

969
00:46:49,040 --> 00:46:57,839
you can only check the execution of the

970
00:46:51,760 --> 00:46:57,839
target function

971
00:47:03,839 --> 00:47:24,400
then i try to set the aig

972
00:47:06,880 --> 00:47:27,280
option to why

973
00:47:24,400 --> 00:47:29,520
now you can see the argument and the

974
00:47:27,280 --> 00:47:32,400
written value

975
00:47:29,520 --> 00:47:33,520
number one and two are fourth and second

976
00:47:32,400 --> 00:47:38,400
parameter

977
00:47:33,520 --> 00:47:41,680
and r is the written value

978
00:47:38,400 --> 00:47:42,079
you can see all the information you can

979
00:47:41,680 --> 00:47:45,118
see

980
00:47:42,079 --> 00:47:53,839
the you can see all

981
00:47:45,119 --> 00:47:53,839
important information really easily

982
00:48:24,000 --> 00:48:29,119
let's take a closer look at the encrypt

983
00:48:26,720 --> 00:48:29,118
function

984
00:48:32,160 --> 00:48:35,839
copy the encrypt function

985
00:49:53,040 --> 00:49:58,800
i target the encrypt function

986
00:49:56,559 --> 00:50:00,640
let's take a closer look at the encrypt

987
00:49:58,800 --> 00:50:05,440
function

988
00:50:00,640 --> 00:50:05,440
then set the code dump option y

989
00:50:08,880 --> 00:50:15,520
set the code down function to

990
00:50:12,400 --> 00:50:27,839
y you can see

991
00:50:15,520 --> 00:50:27,839
small code of target function method

992
00:50:36,880 --> 00:50:41,760
you can see a small code of target

993
00:50:38,839 --> 00:50:55,839
method

994
00:50:41,760 --> 00:50:55,839
in real time

995
00:51:24,079 --> 00:51:37,839
then i try to set the

996
00:51:27,119 --> 00:51:37,839
stack trace option 2y

997
00:51:40,640 --> 00:51:43,440
i started

998
00:51:44,319 --> 00:51:48,800
now you can see stack trace of target

999
00:51:47,440 --> 00:51:51,839
method

1000
00:51:48,800 --> 00:51:51,839
in real time

1001
00:52:13,920 --> 00:52:19,839
okay walter please finish the demo

1002
00:52:16,839 --> 00:52:19,839
please

1003
00:52:20,400 --> 00:52:22,880
thank you

1004
00:52:26,880 --> 00:52:32,640
in conclusion i developed a new analysis

1005
00:52:29,920 --> 00:52:35,040
environment by analyzing

1006
00:52:32,640 --> 00:52:36,879
and modifying the modifying the

1007
00:52:35,040 --> 00:52:39,359
structure of ait

1008
00:52:36,880 --> 00:52:40,720
this method is very easy and effective

1009
00:52:39,359 --> 00:52:43,520
and powerful

1010
00:52:40,720 --> 00:52:46,399
thank you for listening if you any if

1011
00:52:43,520 --> 00:53:01,839
you have any question please contact us

1012
00:52:46,400 --> 00:53:01,839
on twitter thank you

1013
00:53:06,640 --> 00:53:08,720
you

