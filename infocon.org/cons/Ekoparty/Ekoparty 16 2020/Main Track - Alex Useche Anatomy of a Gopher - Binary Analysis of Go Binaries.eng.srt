1
00:00:05,440 --> 00:00:10,559
alex suseche presents

2
00:00:07,279 --> 00:00:14,400
anatomy of a gopher binary analysis of

3
00:00:10,559 --> 00:00:17,840
go binaries go is everywhere these days

4
00:00:14,400 --> 00:00:20,640
because go is awesome it's no

5
00:00:17,840 --> 00:00:21,039
common to find gold binaries embedded

6
00:00:20,640 --> 00:00:24,400
it's

7
00:00:21,039 --> 00:00:27,279
iot edge computing devices

8
00:00:24,400 --> 00:00:27,840
and web assembly application we will

9
00:00:27,279 --> 00:00:30,400
show

10
00:00:27,840 --> 00:00:30,880
you what makes a goal binary different

11
00:00:30,400 --> 00:00:34,719
from

12
00:00:30,880 --> 00:00:37,200
a c binary and how rewards engineers

13
00:00:34,719 --> 00:00:39,840
conducts a binary analysis of go

14
00:00:37,200 --> 00:00:39,840
application

15
00:00:43,280 --> 00:00:49,360
hi my name is or alex use and i am going

16
00:00:46,800 --> 00:00:50,239
to talk today about anatomy of a gopher

17
00:00:49,360 --> 00:00:52,640
uh we're gonna

18
00:00:50,239 --> 00:00:54,320
be talking a bunch about go some

19
00:00:52,640 --> 00:00:58,160
exciting things about

20
00:00:54,320 --> 00:01:01,680
uh binary analysis of uh gold binaries

21
00:00:58,160 --> 00:01:04,158
um so first let's go ahead and uh

22
00:01:01,680 --> 00:01:06,799
um introduce myself should be really

23
00:01:04,159 --> 00:01:09,600
quickly it's uh my name is hexapunk

24
00:01:06,799 --> 00:01:11,760
uh or i go by hexapunk uh my official

25
00:01:09,600 --> 00:01:12,479
name is alex suzette i am a security

26
00:01:11,760 --> 00:01:15,439
engineer

27
00:01:12,479 --> 00:01:17,360
at trello bits here in the united states

28
00:01:15,439 --> 00:01:18,000
i previously worked as an application

29
00:01:17,360 --> 00:01:20,880
security

30
00:01:18,000 --> 00:01:21,759
penetration tester where i was focusing

31
00:01:20,880 --> 00:01:25,839
on iot

32
00:01:21,759 --> 00:01:28,000
and mobile penetration tests primarily

33
00:01:25,840 --> 00:01:29,280
before that i was a software developer

34
00:01:28,000 --> 00:01:32,240
working on several different

35
00:01:29,280 --> 00:01:35,439
technologies i was consulting doing

36
00:01:32,240 --> 00:01:36,240
javascript c-sharp python all kinds of

37
00:01:35,439 --> 00:01:39,520
stuff

38
00:01:36,240 --> 00:01:41,039
i'm also a big go aficionado go is

39
00:01:39,520 --> 00:01:42,640
probably my favorite language but i'm

40
00:01:41,040 --> 00:01:44,720
also a rust fan

41
00:01:42,640 --> 00:01:46,560
it's a very cool like watch as well and

42
00:01:44,720 --> 00:01:49,840
i love messing with binaries

43
00:01:46,560 --> 00:01:52,000
code things like that uh and i'm also a

44
00:01:49,840 --> 00:01:57,360
father and husband

45
00:01:52,000 --> 00:01:57,360
so let's continue let's get on to this

46
00:01:58,799 --> 00:02:02,479
so what is this about uh we're gonna

47
00:02:01,520 --> 00:02:04,479
talk about

48
00:02:02,479 --> 00:02:06,320
what makes a go binary different than a

49
00:02:04,479 --> 00:02:08,560
c or c plus plus binary

50
00:02:06,320 --> 00:02:10,478
will also be identifying techniques for

51
00:02:08,560 --> 00:02:13,760
conducting binary analysis

52
00:02:10,479 --> 00:02:15,120
of combinaries um in order to do this

53
00:02:13,760 --> 00:02:17,599
we'll identify some

54
00:02:15,120 --> 00:02:18,879
common concur uh concurrency patterns in

55
00:02:17,599 --> 00:02:21,440
global aries

56
00:02:18,879 --> 00:02:22,720
uh and how you can identify those when

57
00:02:21,440 --> 00:02:25,760
you are reversing

58
00:02:22,720 --> 00:02:27,760
uh go binary we'll be using go

59
00:02:25,760 --> 00:02:29,679
tools go native tools to make your

60
00:02:27,760 --> 00:02:30,879
analysis more effective so we'll learn

61
00:02:29,680 --> 00:02:32,959
how to use that

62
00:02:30,879 --> 00:02:34,959
in combination with whatever other

63
00:02:32,959 --> 00:02:36,319
reverse engineering tools you're used to

64
00:02:34,959 --> 00:02:38,080
using

65
00:02:36,319 --> 00:02:39,760
i'm going to assume a little bit of a go

66
00:02:38,080 --> 00:02:41,200
knowledge however i'm going to try to

67
00:02:39,760 --> 00:02:44,480
explain as much as possible

68
00:02:41,200 --> 00:02:46,480
so that uh hopefully nobody that has

69
00:02:44,480 --> 00:02:48,399
maybe you have done reverse engineering

70
00:02:46,480 --> 00:02:49,920
before but you haven't worked with a go

71
00:02:48,400 --> 00:02:53,120
binaries gobinaries

72
00:02:49,920 --> 00:02:56,958
hopefully this talk will make sense to

73
00:02:53,120 --> 00:02:58,640
everyone all right so let's start with

74
00:02:56,959 --> 00:03:03,440
some basics

75
00:02:58,640 --> 00:03:05,040
about as in regards to go binaries so

76
00:03:03,440 --> 00:03:07,280
one thing that's useful to understand

77
00:03:05,040 --> 00:03:09,200
it's the basics of the go assembler

78
00:03:07,280 --> 00:03:11,440
the go assembler is based on the input

79
00:03:09,200 --> 00:03:14,159
style of the plan 9 assembler

80
00:03:11,440 --> 00:03:15,359
it takes is guidance from the plan 9

81
00:03:14,159 --> 00:03:18,239
assembler

82
00:03:15,360 --> 00:03:19,760
it also works on a semi instruction set

83
00:03:18,239 --> 00:03:20,720
and we'll see what that means in just a

84
00:03:19,760 --> 00:03:23,518
moment

85
00:03:20,720 --> 00:03:24,720
the output for the go assembler might

86
00:03:23,519 --> 00:03:27,840
not always be a direct

87
00:03:24,720 --> 00:03:29,519
representation of the machine code so

88
00:03:27,840 --> 00:03:31,760
for instance you might see a move

89
00:03:29,519 --> 00:03:34,080
instruction uh which

90
00:03:31,760 --> 00:03:34,798
in actuality might be a load instruction

91
00:03:34,080 --> 00:03:36,720
right

92
00:03:34,799 --> 00:03:39,040
it also introduces a set of pseudo

93
00:03:36,720 --> 00:03:40,319
registers and we'll see what that means

94
00:03:39,040 --> 00:03:42,400
in just a moment as well

95
00:03:40,319 --> 00:03:44,159
and introduces a set of directives used

96
00:03:42,400 --> 00:03:45,519
by the gyris collector

97
00:03:44,159 --> 00:03:47,440
uh we'll talk a little bit about that

98
00:03:45,519 --> 00:03:50,799
but won't be focusing on that point

99
00:03:47,440 --> 00:03:54,079
uh too much so go

100
00:03:50,799 --> 00:03:56,239
sudo registers the uh as i mentioned the

101
00:03:54,080 --> 00:03:58,560
go assembly introduces this set of

102
00:03:56,239 --> 00:04:00,879
ghost pseudo registers if you're using

103
00:03:58,560 --> 00:04:01,519
go native tools to see the disassemble

104
00:04:00,879 --> 00:04:05,200
code

105
00:04:01,519 --> 00:04:07,120
uh particularly uh go to obj dump

106
00:04:05,200 --> 00:04:08,560
and i'll explain how to use that in a

107
00:04:07,120 --> 00:04:10,480
moment uh

108
00:04:08,560 --> 00:04:11,920
the output is gonna look like this like

109
00:04:10,480 --> 00:04:14,560
this image on the right

110
00:04:11,920 --> 00:04:15,200
and you might see some uh registers that

111
00:04:14,560 --> 00:04:18,079
depending

112
00:04:15,200 --> 00:04:20,079
on how extensive your experiences

113
00:04:18,079 --> 00:04:22,000
reverse engineering binaries

114
00:04:20,079 --> 00:04:23,600
you might not have seen in the past one

115
00:04:22,000 --> 00:04:26,960
of them is the frame pointer

116
00:04:23,600 --> 00:04:29,280
which uh just basically is used to uh

117
00:04:26,960 --> 00:04:30,320
as a reference point for arguments and

118
00:04:29,280 --> 00:04:34,000
locals

119
00:04:30,320 --> 00:04:34,880
uh a pc uh pc which stands for program

120
00:04:34,000 --> 00:04:37,759
counter

121
00:04:34,880 --> 00:04:38,639
sp for the static base pointer uh this

122
00:04:37,759 --> 00:04:40,000
is uh

123
00:04:38,639 --> 00:04:41,919
going to be similar if you have worked

124
00:04:40,000 --> 00:04:46,880
with uh meps mips

125
00:04:41,919 --> 00:04:49,758
binaries you might be familiar with a gp

126
00:04:46,880 --> 00:04:51,919
register right and this is used to name

127
00:04:49,759 --> 00:04:52,560
global functions or data based on memory

128
00:04:51,919 --> 00:04:56,000
origin

129
00:04:52,560 --> 00:04:58,160
so for instance right here um let's just

130
00:04:56,000 --> 00:04:59,280
sorry about that so right here if we see

131
00:04:58,160 --> 00:05:01,919
the uh

132
00:04:59,280 --> 00:05:02,960
a call to runtime new proc and we see in

133
00:05:01,919 --> 00:05:05,359
parentheses as

134
00:05:02,960 --> 00:05:06,239
b uh what this means is basically what

135
00:05:05,360 --> 00:05:08,320
just uh

136
00:05:06,240 --> 00:05:10,000
the assembler is just saying hey i call

137
00:05:08,320 --> 00:05:12,080
the runtime new proc function

138
00:05:10,000 --> 00:05:13,919
which is the function name runtime new

139
00:05:12,080 --> 00:05:16,639
proc as an address in memory i said it's

140
00:05:13,919 --> 00:05:19,520
direct to address and memory

141
00:05:16,639 --> 00:05:22,240
so uh then you might see that you will

142
00:05:19,520 --> 00:05:24,639
definitely see the sp

143
00:05:22,240 --> 00:05:26,720
register which is just if you're

144
00:05:24,639 --> 00:05:28,560
equivalent to rsp if you're working on

145
00:05:26,720 --> 00:05:30,160
x64 architecture

146
00:05:28,560 --> 00:05:33,199
um it just points to the top of the

147
00:05:30,160 --> 00:05:35,520
stack uh bp which is your base pointer

148
00:05:33,199 --> 00:05:36,639
and same as rbp if you again if you're

149
00:05:35,520 --> 00:05:39,758
working with uh

150
00:05:36,639 --> 00:05:40,160
if you're more familiar with x64 and

151
00:05:39,759 --> 00:05:43,759
then

152
00:05:40,160 --> 00:05:47,039
the xo register which is just a full 16

153
00:05:43,759 --> 00:05:50,240
16 byte register

154
00:05:47,039 --> 00:05:51,680
so tooling um as i mentioned the output

155
00:05:50,240 --> 00:05:54,479
that we saw earlier that's

156
00:05:51,680 --> 00:05:54,800
using this go with natives tool called

157
00:05:54,479 --> 00:05:57,520
go

158
00:05:54,800 --> 00:05:59,600
to obj dump so obviously you want to

159
00:05:57,520 --> 00:06:01,758
start by picking an re tool

160
00:05:59,600 --> 00:06:03,039
you can use binary ninja i am a fan of

161
00:06:01,759 --> 00:06:06,240
rodare

162
00:06:03,039 --> 00:06:08,240
and you can use uh git drab

163
00:06:06,240 --> 00:06:09,759
whatever your favorite uh reverse

164
00:06:08,240 --> 00:06:12,479
engineering tool might be

165
00:06:09,759 --> 00:06:13,039
now when working with companies as i

166
00:06:12,479 --> 00:06:15,359
mentioned

167
00:06:13,039 --> 00:06:17,440
you are gonna what you wanna use uh in

168
00:06:15,360 --> 00:06:20,960
particular go to obj dom

169
00:06:17,440 --> 00:06:22,080
so google has all this set of finance

170
00:06:20,960 --> 00:06:25,039
tools that

171
00:06:22,080 --> 00:06:26,080
it can be a lot of fun to play with one

172
00:06:25,039 --> 00:06:28,240
of them is just

173
00:06:26,080 --> 00:06:29,919
an implementation of obj dom that makes

174
00:06:28,240 --> 00:06:32,960
it very easy to disassemble

175
00:06:29,919 --> 00:06:35,359
particular functions and kind of on this

176
00:06:32,960 --> 00:06:37,599
allows you to understand your goal

177
00:06:35,360 --> 00:06:40,479
program at a low level

178
00:06:37,600 --> 00:06:42,319
um with go to obj dump and that's

179
00:06:40,479 --> 00:06:44,080
exactly how you will type it go to obj

180
00:06:42,319 --> 00:06:47,840
dump then you will use the attack

181
00:06:44,080 --> 00:06:49,198
uppercase s to print uh codeline numbers

182
00:06:47,840 --> 00:06:52,080
um

183
00:06:49,199 --> 00:06:53,440
basically uh you will see the output and

184
00:06:52,080 --> 00:06:55,440
you will see the line number that

185
00:06:53,440 --> 00:06:56,719
corresponds to different statements in

186
00:06:55,440 --> 00:06:59,599
your assembly code

187
00:06:56,720 --> 00:07:00,800
so that's very helpful if you use a

188
00:06:59,599 --> 00:07:02,560
lowercase s

189
00:07:00,800 --> 00:07:04,560
you can specify a function so if you

190
00:07:02,560 --> 00:07:06,080
just want to disassemble as particular

191
00:07:04,560 --> 00:07:07,120
particular function you just pass it

192
00:07:06,080 --> 00:07:08,880
that flag

193
00:07:07,120 --> 00:07:10,639
and this is going to be helpful

194
00:07:08,880 --> 00:07:13,440
particularly the

195
00:07:10,639 --> 00:07:15,680
uh the uppercase s it's going to be

196
00:07:13,440 --> 00:07:19,120
helpful for grouping a set of statements

197
00:07:15,680 --> 00:07:21,360
assembly statements to lines of code so

198
00:07:19,120 --> 00:07:23,520
this is going to be extremely handy when

199
00:07:21,360 --> 00:07:26,800
working with go binaries

200
00:07:23,520 --> 00:07:27,599
the native output for go to obj dom it's

201
00:07:26,800 --> 00:07:30,319
going to print

202
00:07:27,599 --> 00:07:30,960
left to right instructions so kind of

203
00:07:30,319 --> 00:07:34,240
like think

204
00:07:30,960 --> 00:07:36,880
think about uh the syntax of uh

205
00:07:34,240 --> 00:07:38,880
att syntax so where it's left to write

206
00:07:36,880 --> 00:07:42,080
left to right instructions

207
00:07:38,880 --> 00:07:42,800
um this is obviously not an option for

208
00:07:42,080 --> 00:07:46,878
stripped

209
00:07:42,800 --> 00:07:49,360
uh elf binaries however

210
00:07:46,879 --> 00:07:50,560
this is usually works with stripped

211
00:07:49,360 --> 00:07:54,080
macro binaries

212
00:07:50,560 --> 00:07:55,440
because you can rely on the dynamic

213
00:07:54,080 --> 00:07:57,440
symbols

214
00:07:55,440 --> 00:07:59,599
for you to be able to see function names

215
00:07:57,440 --> 00:08:02,160
etc

216
00:07:59,599 --> 00:08:03,120
so why uh and i'm going to continue

217
00:08:02,160 --> 00:08:06,240
harpering on this

218
00:08:03,120 --> 00:08:07,520
point why do you want to use go tools so

219
00:08:06,240 --> 00:08:09,919
go to obj dump

220
00:08:07,520 --> 00:08:12,719
and we pass the lowercase s and we want

221
00:08:09,919 --> 00:08:15,840
to disassemble the function main main

222
00:08:12,720 --> 00:08:17,520
so this is the uh the the main function

223
00:08:15,840 --> 00:08:19,280
in your go program and we pass it the

224
00:08:17,520 --> 00:08:21,680
upper case uh

225
00:08:19,280 --> 00:08:22,318
option goldbend this is uh uppercase

226
00:08:21,680 --> 00:08:24,800
option

227
00:08:22,319 --> 00:08:26,560
s which basically points the uh or

228
00:08:24,800 --> 00:08:28,080
prints the line numbers

229
00:08:26,560 --> 00:08:30,319
and this is the button name of the

230
00:08:28,080 --> 00:08:34,240
binary so

231
00:08:30,319 --> 00:08:37,360
um as you see here we have the output of

232
00:08:34,240 --> 00:08:40,000
main and what we get on the left

233
00:08:37,360 --> 00:08:41,680
is the line numbers and again this is

234
00:08:40,000 --> 00:08:44,480
very helpful because

235
00:08:41,679 --> 00:08:47,519
here we know that all these statements

236
00:08:44,480 --> 00:08:49,600
correspond to one line of code

237
00:08:47,519 --> 00:08:50,560
and if you are learning to reverse

238
00:08:49,600 --> 00:08:53,360
engineer

239
00:08:50,560 --> 00:08:54,399
from scratch this is also very helpful

240
00:08:53,360 --> 00:08:57,920
because

241
00:08:54,399 --> 00:09:00,560
you can write some code compile it

242
00:08:57,920 --> 00:09:01,040
and then disassemble it using go to obj

243
00:09:00,560 --> 00:09:04,160
dump

244
00:09:01,040 --> 00:09:08,640
and you can see that match between

245
00:09:04,160 --> 00:09:12,719
lines of code to a particular statement

246
00:09:08,640 --> 00:09:16,480
in your output and this is a comparison

247
00:09:12,720 --> 00:09:18,959
uh with uh what you get with our radare

248
00:09:16,480 --> 00:09:21,040
so here we're just telling that diary to

249
00:09:18,959 --> 00:09:23,199
disassemble the function main

250
00:09:21,040 --> 00:09:24,719
so it's going to look very similar

251
00:09:23,200 --> 00:09:25,200
except that we're going to see some of

252
00:09:24,720 --> 00:09:27,839
those

253
00:09:25,200 --> 00:09:29,839
pseudo registers but again for the most

254
00:09:27,839 --> 00:09:33,600
part if you are used to working with

255
00:09:29,839 --> 00:09:36,480
x86 x64 uh binaries then

256
00:09:33,600 --> 00:09:39,120
uh it should be pretty easy so for

257
00:09:36,480 --> 00:09:41,600
instance right here we have the uh

258
00:09:39,120 --> 00:09:43,360
sp uh the stack pointer a pseudo

259
00:09:41,600 --> 00:09:46,320
register which corresponds to

260
00:09:43,360 --> 00:09:48,480
rsp and then we have that difference

261
00:09:46,320 --> 00:09:51,839
where the statements are left to right

262
00:09:48,480 --> 00:09:55,279
as opposed to the intel syntax

263
00:09:51,839 --> 00:09:55,279
that we see down below

264
00:09:55,440 --> 00:10:02,720
so uh since object since go 1.15

265
00:09:59,680 --> 00:10:06,399
uh the output it's a lot

266
00:10:02,720 --> 00:10:07,040
a little bit nicer for um for go to obj

267
00:10:06,399 --> 00:10:10,240
dump

268
00:10:07,040 --> 00:10:13,439
and go 1.15 got released

269
00:10:10,240 --> 00:10:15,680
early august i believe and

270
00:10:13,440 --> 00:10:16,480
instead of line numbers we get specific

271
00:10:15,680 --> 00:10:19,839
statements

272
00:10:16,480 --> 00:10:20,800
that are specific line codes are

273
00:10:19,839 --> 00:10:24,399
actually printed

274
00:10:20,800 --> 00:10:25,760
in your disassembly so for the most part

275
00:10:24,399 --> 00:10:27,920
it does a pretty good job

276
00:10:25,760 --> 00:10:29,680
uh right here we have uh uh we're

277
00:10:27,920 --> 00:10:31,760
opening a

278
00:10:29,680 --> 00:10:33,599
connection and we're using the net

279
00:10:31,760 --> 00:10:36,480
package and listening on port

280
00:10:33,600 --> 00:10:37,279
1984 uh here we're calling the fur and

281
00:10:36,480 --> 00:10:39,200
then we see

282
00:10:37,279 --> 00:10:41,040
all the lines of all the disassembly

283
00:10:39,200 --> 00:10:41,760
that corresponds to that particular line

284
00:10:41,040 --> 00:10:44,560
of code

285
00:10:41,760 --> 00:10:47,120
so this is again super helpful and not

286
00:10:44,560 --> 00:10:49,518
only disassembling uh gold binaries

287
00:10:47,120 --> 00:10:50,480
a lot of good binaries but also in

288
00:10:49,519 --> 00:10:54,800
allowing you to

289
00:10:50,480 --> 00:10:54,800
learn to reverse engineer

290
00:10:55,600 --> 00:11:03,360
so another nice feature that go 1.15 now

291
00:11:00,000 --> 00:11:06,320
has as far as its usage of go to

292
00:11:03,360 --> 00:11:07,519
object dump is that if you pass it they

293
00:11:06,320 --> 00:11:10,640
can do flag

294
00:11:07,519 --> 00:11:11,519
so gnu you are also going to see the

295
00:11:10,640 --> 00:11:13,120
corresponding

296
00:11:11,519 --> 00:11:14,800
so you see the pseudo registers but then

297
00:11:13,120 --> 00:11:17,040
you also see the

298
00:11:14,800 --> 00:11:19,920
new output you can use syntax output on

299
00:11:17,040 --> 00:11:22,000
the right using att6 syntax

300
00:11:19,920 --> 00:11:24,079
um that's also very helpful uh for

301
00:11:22,000 --> 00:11:27,040
comparing your output with what you

302
00:11:24,079 --> 00:11:28,319
uh with your so you will see your output

303
00:11:27,040 --> 00:11:30,240
with go obj dump

304
00:11:28,320 --> 00:11:32,160
and can compare with the output that you

305
00:11:30,240 --> 00:11:35,360
might get from your favorite

306
00:11:32,160 --> 00:11:38,399
reverse engineering tool

307
00:11:35,360 --> 00:11:40,480
so strings this is a slide why

308
00:11:38,399 --> 00:11:41,519
because looking for strings is one of

309
00:11:40,480 --> 00:11:43,040
the first steps

310
00:11:41,519 --> 00:11:45,040
or looking for interesting string

311
00:11:43,040 --> 00:11:45,760
strings is one of the first steps that

312
00:11:45,040 --> 00:11:49,439
you

313
00:11:45,760 --> 00:11:52,319
you people usually take on when

314
00:11:49,440 --> 00:11:54,240
conducting reverse uh or analysis of

315
00:11:52,320 --> 00:11:55,360
gold binaries or any binary for that

316
00:11:54,240 --> 00:11:57,920
matter

317
00:11:55,360 --> 00:11:59,680
so there's something interesting about

318
00:11:57,920 --> 00:12:03,439
go by narrating strings

319
00:11:59,680 --> 00:12:07,359
so this is a radari and we are trying to

320
00:12:03,440 --> 00:12:10,560
print uh or to grab uh rather

321
00:12:07,360 --> 00:12:11,360
lines of code or in the binary we're

322
00:12:10,560 --> 00:12:14,000
trying to grab

323
00:12:11,360 --> 00:12:15,760
for up and looking for the word human in

324
00:12:14,000 --> 00:12:18,079
this case we're passing that iz

325
00:12:15,760 --> 00:12:19,439
which in the case of radari uh is asking

326
00:12:18,079 --> 00:12:21,680
it's telling radar hey

327
00:12:19,440 --> 00:12:23,360
go look in the text section for any

328
00:12:21,680 --> 00:12:26,719
mention of the word human

329
00:12:23,360 --> 00:12:28,560
and we get nothing uh if we look for

330
00:12:26,720 --> 00:12:30,000
strings in the entire binary by passing

331
00:12:28,560 --> 00:12:34,160
in the double z flag

332
00:12:30,000 --> 00:12:36,720
then we uh indeed see some input output

333
00:12:34,160 --> 00:12:38,480
um and then that's going to be similar

334
00:12:36,720 --> 00:12:41,040
if you use this other tool

335
00:12:38,480 --> 00:12:42,000
that's part of the radare uh toolchain

336
00:12:41,040 --> 00:12:44,160
rabbin2

337
00:12:42,000 --> 00:12:45,600
so again nothing on when looking for

338
00:12:44,160 --> 00:12:47,920
strings in the text section

339
00:12:45,600 --> 00:12:50,079
and then we get this when looking for

340
00:12:47,920 --> 00:12:52,000
strings an entire binary

341
00:12:50,079 --> 00:12:54,160
uh if we see the output in the tool

342
00:12:52,000 --> 00:12:54,959
itself uh when actually looking in a

343
00:12:54,160 --> 00:12:57,199
function

344
00:12:54,959 --> 00:12:58,959
then we see uh for instance right here

345
00:12:57,200 --> 00:13:02,160
we see an interesting string

346
00:12:58,959 --> 00:13:02,880
which is a constant in the binary in the

347
00:13:02,160 --> 00:13:05,040
in the code

348
00:13:02,880 --> 00:13:06,720
uh it's called it's abit nadir it's just

349
00:13:05,040 --> 00:13:09,839
a name

350
00:13:06,720 --> 00:13:12,560
and in this case it's we

351
00:13:09,839 --> 00:13:14,320
we see that it's kind of grouped

352
00:13:12,560 --> 00:13:15,279
together with these older strings that

353
00:13:14,320 --> 00:13:17,680
have nothing to do

354
00:13:15,279 --> 00:13:18,320
with what was in the code so nothing

355
00:13:17,680 --> 00:13:21,040
interesting

356
00:13:18,320 --> 00:13:21,360
or nothing of interest to us necessarily

357
00:13:21,040 --> 00:13:24,240
so

358
00:13:21,360 --> 00:13:24,639
why is that that's because go does not

359
00:13:24,240 --> 00:13:26,720
store

360
00:13:24,639 --> 00:13:29,440
null terminated strings it actually

361
00:13:26,720 --> 00:13:32,160
clumped it together in the text section

362
00:13:29,440 --> 00:13:34,240
so because of that it makes it pretty

363
00:13:32,160 --> 00:13:36,319
difficult to look for strings

364
00:13:34,240 --> 00:13:38,079
in the binary so this is going to be

365
00:13:36,320 --> 00:13:39,839
different than c and c plus plus binary

366
00:13:38,079 --> 00:13:42,560
is where strings are not terminated and

367
00:13:39,839 --> 00:13:42,560
you can actually

368
00:13:42,880 --> 00:13:46,800
get a nicer output when looking for

369
00:13:44,720 --> 00:13:48,720
grappling for strings

370
00:13:46,800 --> 00:13:50,000
go uses a separate table with string

371
00:13:48,720 --> 00:13:53,199
length information

372
00:13:50,000 --> 00:13:56,240
um looks for that uh clump

373
00:13:53,199 --> 00:13:58,079
of strings in the text section it uses

374
00:13:56,240 --> 00:14:00,240
the table with the string length

375
00:13:58,079 --> 00:14:02,719
information and that way knows

376
00:14:00,240 --> 00:14:04,000
uh when the string begins and when the

377
00:14:02,720 --> 00:14:06,079
string ends

378
00:14:04,000 --> 00:14:07,839
um this is great but it can be difficult

379
00:14:06,079 --> 00:14:10,959
to find cross references

380
00:14:07,839 --> 00:14:13,279
uh for by reverse engineers so

381
00:14:10,959 --> 00:14:14,399
um for instance you might have to rely

382
00:14:13,279 --> 00:14:16,800
on additional tools

383
00:14:14,399 --> 00:14:18,800
so for instance if using rodare you can

384
00:14:16,800 --> 00:14:19,839
use this particular tool which is very

385
00:14:18,800 --> 00:14:22,719
helpful

386
00:14:19,839 --> 00:14:24,959
in kind of making that process for

387
00:14:22,720 --> 00:14:28,240
looking for strings a little bit easier

388
00:14:24,959 --> 00:14:31,518
because it's actually looking for that

389
00:14:28,240 --> 00:14:32,560
blob of text and trying to make better

390
00:14:31,519 --> 00:14:35,600
sense out of

391
00:14:32,560 --> 00:14:37,279
what's uh found there um

392
00:14:35,600 --> 00:14:38,639
so anytime that you're searching for

393
00:14:37,279 --> 00:14:40,399
strings uh

394
00:14:38,639 --> 00:14:42,480
whatever you tool that you're using for

395
00:14:40,399 --> 00:14:43,920
reverse engineering i go binary

396
00:14:42,480 --> 00:14:48,399
make sure to search for strings in the

397
00:14:43,920 --> 00:14:48,399
entire binary not just the text section

398
00:14:49,279 --> 00:14:54,560
okay functions so functions are pretty

399
00:14:52,639 --> 00:14:57,839
easy to find in gold binaries

400
00:14:54,560 --> 00:14:58,399
um this is going to be just as cc as

401
00:14:57,839 --> 00:15:00,560
finding

402
00:14:58,399 --> 00:15:01,760
strings on a c or c plus plus binary

403
00:15:00,560 --> 00:15:04,800
that doesn't have

404
00:15:01,760 --> 00:15:05,680
strip symbols now um there's something

405
00:15:04,800 --> 00:15:08,880
interesting

406
00:15:05,680 --> 00:15:10,239
um as far as understanding or matching

407
00:15:08,880 --> 00:15:13,439
the syntax of go

408
00:15:10,240 --> 00:15:15,839
code for declaration of functions

409
00:15:13,440 --> 00:15:18,320
to what you will see in the output of

410
00:15:15,839 --> 00:15:20,800
your reverse engineering tool

411
00:15:18,320 --> 00:15:22,079
so this is a package the package is

412
00:15:20,800 --> 00:15:23,839
called debugger

413
00:15:22,079 --> 00:15:26,560
and here we're declaring a structure

414
00:15:23,839 --> 00:15:28,240
called debugger with an uppercase

415
00:15:26,560 --> 00:15:30,239
in go if it is declared with an

416
00:15:28,240 --> 00:15:33,199
uppercase that means that we

417
00:15:30,240 --> 00:15:34,800
are exporting and that debugger making a

418
00:15:33,199 --> 00:15:36,399
structure and making it available to

419
00:15:34,800 --> 00:15:39,758
other

420
00:15:36,399 --> 00:15:41,279
packages then we call a function call or

421
00:15:39,759 --> 00:15:44,240
create a method

422
00:15:41,279 --> 00:15:45,360
that's actually for the debugger

423
00:15:44,240 --> 00:15:48,000
structure

424
00:15:45,360 --> 00:15:48,959
called start target here we're declaring

425
00:15:48,000 --> 00:15:52,399
the uh

426
00:15:48,959 --> 00:15:54,000
the receiver which is a pointer to add

427
00:15:52,399 --> 00:15:57,680
the blogger structure

428
00:15:54,000 --> 00:15:58,800
so how does that look in your reverse

429
00:15:57,680 --> 00:16:00,719
engineering tools

430
00:15:58,800 --> 00:16:03,680
well it usually has this function this

431
00:16:00,720 --> 00:16:07,120
syntax so you will see package.function

432
00:16:03,680 --> 00:16:09,519
or package.the receiver structure

433
00:16:07,120 --> 00:16:11,680
dot the name of the method and if you're

434
00:16:09,519 --> 00:16:12,959
using radare 2 usually the syntax is

435
00:16:11,680 --> 00:16:14,719
going to look like this

436
00:16:12,959 --> 00:16:16,079
package dot underscore underscore

437
00:16:14,720 --> 00:16:18,720
receiver structure

438
00:16:16,079 --> 00:16:21,279
underscore underscore method now keep in

439
00:16:18,720 --> 00:16:25,600
mind if you haven't worked with go much

440
00:16:21,279 --> 00:16:26,720
usually the uh methods that are exported

441
00:16:25,600 --> 00:16:29,360
methods and structures

442
00:16:26,720 --> 00:16:30,160
are exported uh start with an upper case

443
00:16:29,360 --> 00:16:34,160
so they

444
00:16:30,160 --> 00:16:37,040
um and then the ones that do not

445
00:16:34,160 --> 00:16:38,560
are not exported start with a lower case

446
00:16:37,040 --> 00:16:42,000
so here we have the output

447
00:16:38,560 --> 00:16:43,119
we're looking for uh the functions on a

448
00:16:42,000 --> 00:16:45,519
particular package

449
00:16:43,120 --> 00:16:47,279
in this case the debugger package we see

450
00:16:45,519 --> 00:16:48,959
the long string that corresponds to the

451
00:16:47,279 --> 00:16:52,240
package this is the package for

452
00:16:48,959 --> 00:16:53,040
code that i have written before and then

453
00:16:52,240 --> 00:16:54,800
we see

454
00:16:53,040 --> 00:16:56,719
uh underscore underscore debugger this

455
00:16:54,800 --> 00:17:01,120
is the structure right here

456
00:16:56,720 --> 00:17:04,400
and then underscore dot the name of the

457
00:17:01,120 --> 00:17:07,919
method um so

458
00:17:04,400 --> 00:17:08,319
that's the typical um syntax that you

459
00:17:07,919 --> 00:17:09,760
will

460
00:17:08,319 --> 00:17:11,599
need to look for when looking for a

461
00:17:09,760 --> 00:17:14,160
particular uh function

462
00:17:11,599 --> 00:17:15,918
and you and that's how you will match uh

463
00:17:14,160 --> 00:17:16,720
whether a function is a standalone

464
00:17:15,919 --> 00:17:19,760
function

465
00:17:16,720 --> 00:17:22,240
or the if it is a method and it has a

466
00:17:19,760 --> 00:17:22,240
receiver

467
00:17:23,199 --> 00:17:28,559
so uh pretty simple again this is uh

468
00:17:26,240 --> 00:17:29,760
the output for a particular function in

469
00:17:28,559 --> 00:17:32,879
uh radari

470
00:17:29,760 --> 00:17:33,679
and then we have the here's the package

471
00:17:32,880 --> 00:17:37,919
name

472
00:17:33,679 --> 00:17:39,840
github wire repairs gcd gcd api

473
00:17:37,919 --> 00:17:42,799
then we have the name of the structure

474
00:17:39,840 --> 00:17:44,959
and the function enable

475
00:17:42,799 --> 00:17:46,799
so this is the the name of the structure

476
00:17:44,960 --> 00:17:48,080
is going to be the receiver and enable

477
00:17:46,799 --> 00:17:52,080
is the name of the

478
00:17:48,080 --> 00:17:52,080
function pretty simple

479
00:17:52,320 --> 00:17:55,918
if you are interested in looking for c

480
00:17:54,160 --> 00:17:56,799
go functions why would you do that

481
00:17:55,919 --> 00:17:59,120
because

482
00:17:56,799 --> 00:18:00,720
you are likely to find or more likely to

483
00:17:59,120 --> 00:18:03,600
find vulnerabilities

484
00:18:00,720 --> 00:18:05,600
because they are using c code within or

485
00:18:03,600 --> 00:18:06,240
the developer was using c code within

486
00:18:05,600 --> 00:18:09,439
their go

487
00:18:06,240 --> 00:18:11,120
code using the sql package so

488
00:18:09,440 --> 00:18:12,880
this is actually pretty simple you just

489
00:18:11,120 --> 00:18:15,439
have to look for syntax like this

490
00:18:12,880 --> 00:18:16,080
in this case it's underscore c func uh

491
00:18:15,440 --> 00:18:19,919
with a

492
00:18:16,080 --> 00:18:23,439
uppercase c and now we'll actually print

493
00:18:19,919 --> 00:18:26,080
um the form the c functions that

494
00:18:23,440 --> 00:18:26,840
are in the binary but it will also

495
00:18:26,080 --> 00:18:29,918
include

496
00:18:26,840 --> 00:18:30,799
non-custom c functions so for instance

497
00:18:29,919 --> 00:18:33,679
in this case

498
00:18:30,799 --> 00:18:35,760
i created a function called grid and

499
00:18:33,679 --> 00:18:36,960
inside that function i'm calling the c

500
00:18:35,760 --> 00:18:40,160
function free the c

501
00:18:36,960 --> 00:18:42,000
functions c string i'm calling malloc

502
00:18:40,160 --> 00:18:43,600
and all those functions are shown there

503
00:18:42,000 --> 00:18:44,320
even though they are not the standalone

504
00:18:43,600 --> 00:18:46,399
functions

505
00:18:44,320 --> 00:18:47,520
um or there are no custom functions that

506
00:18:46,400 --> 00:18:49,840
i wrote

507
00:18:47,520 --> 00:18:51,120
because they are used within or inside

508
00:18:49,840 --> 00:18:52,879
the grid function you

509
00:18:51,120 --> 00:18:54,479
should also see them in the output and

510
00:18:52,880 --> 00:18:56,320
that should help

511
00:18:54,480 --> 00:18:57,840
should be really helpful uh if you are

512
00:18:56,320 --> 00:19:01,678
looking for specific

513
00:18:57,840 --> 00:19:03,120
c vulnerabilities in your go binaries

514
00:19:01,679 --> 00:19:05,840
so let's learn a little bit about

515
00:19:03,120 --> 00:19:08,879
conventions now

516
00:19:05,840 --> 00:19:11,360
okay so the stack stacks in prolog

517
00:19:08,880 --> 00:19:12,559
so let's understand what makes a

518
00:19:11,360 --> 00:19:15,120
prologue

519
00:19:12,559 --> 00:19:16,639
and stack handling in go banaries

520
00:19:15,120 --> 00:19:18,959
different than that of

521
00:19:16,640 --> 00:19:21,520
c and c plus plus binaries so go

522
00:19:18,960 --> 00:19:25,039
routines have a small stacks by default

523
00:19:21,520 --> 00:19:28,879
uh usually 2048 bytes

524
00:19:25,039 --> 00:19:30,480
um in the stack and what happens is go

525
00:19:28,880 --> 00:19:32,080
routines at the beginning of the

526
00:19:30,480 --> 00:19:36,000
function uh

527
00:19:32,080 --> 00:19:37,678
have a check for a function in the uh

528
00:19:36,000 --> 00:19:40,080
epilogue so at the bottom of the

529
00:19:37,679 --> 00:19:42,919
function you will typically find

530
00:19:40,080 --> 00:19:45,120
after the return statement a call to

531
00:19:42,919 --> 00:19:47,919
sim.runtime.more stack

532
00:19:45,120 --> 00:19:48,479
um so what's actually happened is that

533
00:19:47,919 --> 00:19:50,559
go

534
00:19:48,480 --> 00:19:52,000
cannot be sure that a function will grow

535
00:19:50,559 --> 00:19:54,639
the stack

536
00:19:52,000 --> 00:19:56,640
this is because the stacks a go routine

537
00:19:54,640 --> 00:19:58,840
might call itself recursively

538
00:19:56,640 --> 00:20:00,160
and because gold routines by nature are

539
00:19:58,840 --> 00:20:04,240
non-deterministic

540
00:20:00,160 --> 00:20:06,880
so go cannot be sure that hey uh this

541
00:20:04,240 --> 00:20:09,520
function it's gonna grow the stack so or

542
00:20:06,880 --> 00:20:12,559
maya go the stack so what it does then

543
00:20:09,520 --> 00:20:15,840
is it comparison stack pointer against

544
00:20:12,559 --> 00:20:19,440
uh this um a

545
00:20:15,840 --> 00:20:22,158
pointer called g uh called stackguard

546
00:20:19,440 --> 00:20:23,840
that's to check for overflows right so

547
00:20:22,159 --> 00:20:25,919
it needs to conduct that checked

548
00:20:23,840 --> 00:20:27,600
every time that the code routine is

549
00:20:25,919 --> 00:20:30,400
called and

550
00:20:27,600 --> 00:20:30,879
as long as it's not sure that it the uh

551
00:20:30,400 --> 00:20:32,880
in

552
00:20:30,880 --> 00:20:35,120
this particular instance the stack will

553
00:20:32,880 --> 00:20:38,559
be outgrown it's going to call

554
00:20:35,120 --> 00:20:40,559
runtime more stack and what runtime

555
00:20:38,559 --> 00:20:41,918
more stack is going to do it's going to

556
00:20:40,559 --> 00:20:44,320
grow the stack

557
00:20:41,919 --> 00:20:46,080
by powershot 2 and then all the pointers

558
00:20:44,320 --> 00:20:48,399
on the stack are going to be updated

559
00:20:46,080 --> 00:20:49,280
as the stack grows and this is gonna

560
00:20:48,400 --> 00:20:52,159
keep happening

561
00:20:49,280 --> 00:20:54,000
until uh there's sufficient uh space in

562
00:20:52,159 --> 00:20:56,640
the stack for the go routine to run

563
00:20:54,000 --> 00:20:58,720
and then uh it's gonna actually run the

564
00:20:56,640 --> 00:21:00,320
statements and the particular function

565
00:20:58,720 --> 00:21:02,559
so again it's gonna be pretty different

566
00:21:00,320 --> 00:21:04,639
than uh what it is

567
00:21:02,559 --> 00:21:05,600
very different than c and c plus plus

568
00:21:04,640 --> 00:21:08,320
binaries

569
00:21:05,600 --> 00:21:08,719
uh you are actually uh more likely to

570
00:21:08,320 --> 00:21:10,879
see

571
00:21:08,720 --> 00:21:12,559
that this uh type of situation right

572
00:21:10,880 --> 00:21:15,520
here where we're

573
00:21:12,559 --> 00:21:17,120
doing a comparison with the stack guard

574
00:21:15,520 --> 00:21:20,158
and

575
00:21:17,120 --> 00:21:23,120
we are calling runtime the more stack

576
00:21:20,159 --> 00:21:24,960
as necessary if you want to experiment

577
00:21:23,120 --> 00:21:26,879
with this and kind of learn a little bit

578
00:21:24,960 --> 00:21:30,320
more about how it goes stacks

579
00:21:26,880 --> 00:21:33,120
or handles uh stacks you can uh

580
00:21:30,320 --> 00:21:35,200
start adding gold no split the prick or

581
00:21:33,120 --> 00:21:37,678
the pragma at the top of your functions

582
00:21:35,200 --> 00:21:39,600
and that will actually tell the runtime

583
00:21:37,679 --> 00:21:42,480
to

584
00:21:39,600 --> 00:21:43,520
avoid making this uh more stack called

585
00:21:42,480 --> 00:21:46,960
so i

586
00:21:43,520 --> 00:21:48,240
avoid doing stack splitting um

587
00:21:46,960 --> 00:21:49,919
so it's something interesting to play

588
00:21:48,240 --> 00:21:51,760
with if you want to do conduct more

589
00:21:49,919 --> 00:21:54,960
research and understand how

590
00:21:51,760 --> 00:21:58,158
the stack grows and shrinks in the uh

591
00:21:54,960 --> 00:22:00,720
go binaries so calling conventions

592
00:21:58,159 --> 00:22:02,320
um pretty simple um but it's gonna be

593
00:22:00,720 --> 00:22:04,080
this is gonna be different than cnc plus

594
00:22:02,320 --> 00:22:05,039
plus and that return values are placed

595
00:22:04,080 --> 00:22:07,120
in the stack

596
00:22:05,039 --> 00:22:08,879
as opposed to see where return values

597
00:22:07,120 --> 00:22:12,479
are placed in registers

598
00:22:08,880 --> 00:22:14,960
so for instance right here we have a uh

599
00:22:12,480 --> 00:22:16,000
function that is about to return and we

600
00:22:14,960 --> 00:22:18,240
are placing

601
00:22:16,000 --> 00:22:19,360
this value the value zero which in this

602
00:22:18,240 --> 00:22:21,840
case is for

603
00:22:19,360 --> 00:22:22,559
uh temporarily states it's supposed to

604
00:22:21,840 --> 00:22:26,399
mean false

605
00:22:22,559 --> 00:22:30,480
uh into the stack and then

606
00:22:26,400 --> 00:22:32,320
we restore the stack before returning

607
00:22:30,480 --> 00:22:34,720
arguments are also moved to the stack

608
00:22:32,320 --> 00:22:35,520
rather than registers before calling a

609
00:22:34,720 --> 00:22:37,600
function

610
00:22:35,520 --> 00:22:38,720
again different than c and c plus plus

611
00:22:37,600 --> 00:22:41,399
binaries

612
00:22:38,720 --> 00:22:43,280
in this case we see a function called

613
00:22:41,400 --> 00:22:45,679
simdomain.check password

614
00:22:43,280 --> 00:22:46,960
and we're only passing in a string and

615
00:22:45,679 --> 00:22:50,880
because it is a string

616
00:22:46,960 --> 00:22:53,200
uh we a string and go consists of the

617
00:22:50,880 --> 00:22:54,080
string value and the length information

618
00:22:53,200 --> 00:22:56,799
so

619
00:22:54,080 --> 00:22:58,639
uh those are these two that's two these

620
00:22:56,799 --> 00:23:00,799
two values that we are passing to the

621
00:22:58,640 --> 00:23:04,000
stack before we call check password

622
00:23:00,799 --> 00:23:05,200
so again values and return arguments and

623
00:23:04,000 --> 00:23:08,240
return values are

624
00:23:05,200 --> 00:23:11,280
passed in the stack not in the uh

625
00:23:08,240 --> 00:23:13,440
in registers now

626
00:23:11,280 --> 00:23:14,320
um this is uh one thing that's going to

627
00:23:13,440 --> 00:23:16,080
be key

628
00:23:14,320 --> 00:23:17,918
to working with gold binaries is

629
00:23:16,080 --> 00:23:19,600
identifying the underlying

630
00:23:17,919 --> 00:23:21,360
language constructs so understand

631
00:23:19,600 --> 00:23:23,360
understanding go internals small

632
00:23:21,360 --> 00:23:26,639
specifically

633
00:23:23,360 --> 00:23:29,600
so this is going to be

634
00:23:26,640 --> 00:23:31,440
very useful because particularly if you

635
00:23:29,600 --> 00:23:33,120
are working with macro binaries

636
00:23:31,440 --> 00:23:35,520
stripping function names is not going to

637
00:23:33,120 --> 00:23:40,399
be very easy

638
00:23:35,520 --> 00:23:44,080
at least not using the standard go tools

639
00:23:40,400 --> 00:23:45,600
so you can usually use this uh opacity

640
00:23:44,080 --> 00:23:47,918
when you're building a golban area you

641
00:23:45,600 --> 00:23:49,199
can pass it this flags so ld flags and

642
00:23:47,919 --> 00:23:52,240
you pass the tag x

643
00:23:49,200 --> 00:23:53,279
and type w to strip binary to strip

644
00:23:52,240 --> 00:23:55,679
symbols but it

645
00:23:53,279 --> 00:23:56,400
typically only strips the dwarf symbols

646
00:23:55,679 --> 00:23:58,720
to sim

647
00:23:56,400 --> 00:23:59,760
symbols table so it helps to become

648
00:23:58,720 --> 00:24:04,080
familiar

649
00:23:59,760 --> 00:24:05,760
with uh the uh go internal functions

650
00:24:04,080 --> 00:24:07,918
because you are likely to see a lot of

651
00:24:05,760 --> 00:24:08,879
those uh because this is a high level

652
00:24:07,919 --> 00:24:12,320
language

653
00:24:08,880 --> 00:24:15,440
and it relies on a lot of uh underlying

654
00:24:12,320 --> 00:24:17,120
functions uh go internal functions that

655
00:24:15,440 --> 00:24:18,000
are gonna become very helpful when

656
00:24:17,120 --> 00:24:21,120
you're trying to understand

657
00:24:18,000 --> 00:24:24,080
what a particular function is doing so

658
00:24:21,120 --> 00:24:25,760
uh and by the way if you wanna uh strip

659
00:24:24,080 --> 00:24:26,639
a gold binary one this is a great tool

660
00:24:25,760 --> 00:24:28,240
upx

661
00:24:26,640 --> 00:24:30,799
uh it's gonna shrink your banana

662
00:24:28,240 --> 00:24:32,480
significantly and it's one of the

663
00:24:30,799 --> 00:24:34,400
tools that i've seen that's that that's

664
00:24:32,480 --> 00:24:36,000
one of the best jobs in uh

665
00:24:34,400 --> 00:24:39,039
shrinking not only string can i go

666
00:24:36,000 --> 00:24:42,080
binary but also stripping

667
00:24:39,039 --> 00:24:43,760
symbols so back to this it helps to

668
00:24:42,080 --> 00:24:45,678
become familiar with the common

669
00:24:43,760 --> 00:24:48,480
functions from the following package

670
00:24:45,679 --> 00:24:50,000
in the goal uh runtime under all the go

671
00:24:48,480 --> 00:24:53,200
internal

672
00:24:50,000 --> 00:24:56,640
library so source runtime source io

673
00:24:53,200 --> 00:24:59,279
source net source os

674
00:24:56,640 --> 00:25:00,880
understanding different functions are

675
00:24:59,279 --> 00:25:01,360
part of these packages it's going to be

676
00:25:00,880 --> 00:25:02,960
key

677
00:25:01,360 --> 00:25:05,120
in allowing you to understand what's

678
00:25:02,960 --> 00:25:06,640
happening in go binaries particularly

679
00:25:05,120 --> 00:25:09,360
when you're trying to identify

680
00:25:06,640 --> 00:25:10,799
things like uh asynchronous calls or

681
00:25:09,360 --> 00:25:13,120
synchronous code so

682
00:25:10,799 --> 00:25:14,480
go routines deferred functions and

683
00:25:13,120 --> 00:25:16,799
things like that

684
00:25:14,480 --> 00:25:18,159
so this is the key or this is key to

685
00:25:16,799 --> 00:25:20,400
reversing go

686
00:25:18,159 --> 00:25:23,039
concurrent code and pointer operations

687
00:25:20,400 --> 00:25:23,039
in particular

688
00:25:24,080 --> 00:25:28,080
so let's see an example so for instance

689
00:25:27,279 --> 00:25:30,880
right here we

690
00:25:28,080 --> 00:25:31,918
have a function called draft copy and

691
00:25:30,880 --> 00:25:35,039
we're passing it a

692
00:25:31,919 --> 00:25:37,120
pointer to a student structure in this

693
00:25:35,039 --> 00:25:40,240
case where we're dereferencing

694
00:25:37,120 --> 00:25:43,279
the receiver which in this case is a

695
00:25:40,240 --> 00:25:44,320
pointer to the student structure and we

696
00:25:43,279 --> 00:25:48,159
are assigning it

697
00:25:44,320 --> 00:25:49,439
the student this the student object that

698
00:25:48,159 --> 00:25:52,880
was passed to this function

699
00:25:49,440 --> 00:25:54,720
right so what's happening here uh if we

700
00:25:52,880 --> 00:25:56,880
disassemble this

701
00:25:54,720 --> 00:25:58,240
we're to get something like this and at

702
00:25:56,880 --> 00:26:00,559
the bottom or

703
00:25:58,240 --> 00:26:01,919
in as you start looking at the code

704
00:26:00,559 --> 00:26:05,440
you're going to see this function called

705
00:26:01,919 --> 00:26:06,880
sim runtime.typed man move if you look

706
00:26:05,440 --> 00:26:10,880
at the documentation for

707
00:26:06,880 --> 00:26:12,880
type memo move you're going to see this

708
00:26:10,880 --> 00:26:15,039
and this is on the source runtime and

709
00:26:12,880 --> 00:26:18,159
barrier and it tells us that

710
00:26:15,039 --> 00:26:20,158
uh there is a potential race here um

711
00:26:18,159 --> 00:26:22,080
so this is already very interesting for

712
00:26:20,159 --> 00:26:25,120
us especially if you're looking for

713
00:26:22,080 --> 00:26:28,879
interesting bugs in a gold banary right

714
00:26:25,120 --> 00:26:30,959
it tells us let's go back to that um

715
00:26:28,880 --> 00:26:33,039
so it tells us there's a array here and

716
00:26:30,960 --> 00:26:33,520
another thing that's interesting is that

717
00:26:33,039 --> 00:26:36,559
the

718
00:26:33,520 --> 00:26:39,679
source pointer it declares as an

719
00:26:36,559 --> 00:26:43,600
unsafe pointer so what might happen then

720
00:26:39,679 --> 00:26:46,799
is that the uh the the source

721
00:26:43,600 --> 00:26:48,158
pointer might be a change before this is

722
00:26:46,799 --> 00:26:50,000
completed

723
00:26:48,159 --> 00:26:52,240
let's take a look back at this function

724
00:26:50,000 --> 00:26:54,240
one more time actually

725
00:26:52,240 --> 00:26:56,320
but what's actually happening here is

726
00:26:54,240 --> 00:26:57,039
that uh we're trying to do this

727
00:26:56,320 --> 00:27:00,399
assignment

728
00:26:57,039 --> 00:27:04,400
right and then go first is uh

729
00:27:00,400 --> 00:27:07,200
calls a type move to see if uh or or

730
00:27:04,400 --> 00:27:07,520
calls runtime right barrier i'm sorry to

731
00:27:07,200 --> 00:27:10,799
see

732
00:27:07,520 --> 00:27:13,039
if the garbage collector is busy uh

733
00:27:10,799 --> 00:27:14,720
to see if the garbage collector is able

734
00:27:13,039 --> 00:27:15,120
to if it isn't obese it's going to see

735
00:27:14,720 --> 00:27:17,600
if

736
00:27:15,120 --> 00:27:18,158
the right if the garbage collector can

737
00:27:17,600 --> 00:27:20,959
actually do

738
00:27:18,159 --> 00:27:21,200
the assignment itself if not it's going

739
00:27:20,960 --> 00:27:23,120
to

740
00:27:21,200 --> 00:27:24,320
do the assignment as it does it here

741
00:27:23,120 --> 00:27:28,158
right

742
00:27:24,320 --> 00:27:31,039
and if otherwise it's going to call

743
00:27:28,159 --> 00:27:32,640
type name move so the garbage collector

744
00:27:31,039 --> 00:27:36,080
can actually do

745
00:27:32,640 --> 00:27:38,399
that assignment so

746
00:27:36,080 --> 00:27:39,439
that's something that uh to me i think

747
00:27:38,399 --> 00:27:42,000
it's very interesting

748
00:27:39,440 --> 00:27:43,200
uh and something that allows you to sort

749
00:27:42,000 --> 00:27:46,320
of identify

750
00:27:43,200 --> 00:27:50,399
uh potential conditions where i raise

751
00:27:46,320 --> 00:27:50,399
uh risk condition might occur

752
00:27:51,039 --> 00:27:56,960
now um this is another instance where

753
00:27:54,799 --> 00:27:58,480
learning about go internal functions

754
00:27:56,960 --> 00:28:00,320
becomes very useful when reverse

755
00:27:58,480 --> 00:28:02,080
engineering goal binaries and that's

756
00:28:00,320 --> 00:28:03,039
when identifying go routines for

757
00:28:02,080 --> 00:28:04,480
instance

758
00:28:03,039 --> 00:28:06,158
so right here i'm calling all these

759
00:28:04,480 --> 00:28:07,440
functions and go routines and this

760
00:28:06,159 --> 00:28:09,360
probably just

761
00:28:07,440 --> 00:28:11,520
this program probably ends before it

762
00:28:09,360 --> 00:28:14,719
prints anything useful or it shows

763
00:28:11,520 --> 00:28:17,360
it does anything useful so

764
00:28:14,720 --> 00:28:18,240
in this case we are passing it uh we're

765
00:28:17,360 --> 00:28:21,199
calling core

766
00:28:18,240 --> 00:28:22,720
uh copy println we're passing at the

767
00:28:21,200 --> 00:28:25,440
argument test

768
00:28:22,720 --> 00:28:28,120
so what happens in the uh under the code

769
00:28:25,440 --> 00:28:30,559
is that this function called

770
00:28:28,120 --> 00:28:32,320
sim.runtime.newproc is called if you

771
00:28:30,559 --> 00:28:34,320
look at the documentation for that it

772
00:28:32,320 --> 00:28:36,158
tells us that it creates a new running

773
00:28:34,320 --> 00:28:39,760
function with a particular

774
00:28:36,159 --> 00:28:45,120
uh byte size that spices an argument

775
00:28:39,760 --> 00:28:46,879
uh it puts it on the queue for the uh

776
00:28:45,120 --> 00:28:48,158
it puts it in the key and then wrong uh

777
00:28:46,880 --> 00:28:51,520
go go start

778
00:28:48,159 --> 00:28:54,640
running it as um

779
00:28:51,520 --> 00:28:58,000
in the way in whichever way the schedule

780
00:28:54,640 --> 00:28:59,440
scheduler sees convenient so uh

781
00:28:58,000 --> 00:29:01,039
in this case we're passing on the string

782
00:28:59,440 --> 00:29:03,840
test so we're passing it

783
00:29:01,039 --> 00:29:04,799
at the uh the size of the argument uh as

784
00:29:03,840 --> 00:29:07,840
i stated here

785
00:29:04,799 --> 00:29:08,879
uh which is uh four uh bytes and then we

786
00:29:07,840 --> 00:29:12,158
pass it the

787
00:29:08,880 --> 00:29:14,480
uh um uh

788
00:29:12,159 --> 00:29:15,840
the value that we're interested in

789
00:29:14,480 --> 00:29:16,880
passing it to that particular goal

790
00:29:15,840 --> 00:29:19,760
function

791
00:29:16,880 --> 00:29:22,080
uh our goal routine same thing here

792
00:29:19,760 --> 00:29:25,360
we're passing it uh just an integer

793
00:29:22,080 --> 00:29:26,639
uh here we're passing it a uh a string

794
00:29:25,360 --> 00:29:29,840
of go first which is

795
00:29:26,640 --> 00:29:32,559
seven bytes long um

796
00:29:29,840 --> 00:29:33,120
here is a test race with no arguments so

797
00:29:32,559 --> 00:29:35,200
that's

798
00:29:33,120 --> 00:29:38,239
zero arguments that were passing in the

799
00:29:35,200 --> 00:29:39,520
stack and then uh tests on safe with a

800
00:29:38,240 --> 00:29:41,840
three byte length

801
00:29:39,520 --> 00:29:41,840
string

802
00:29:44,000 --> 00:29:49,520
so uh this is just something interesting

803
00:29:47,360 --> 00:29:50,719
in how the output is going to look if

804
00:29:49,520 --> 00:29:52,799
you're using go

805
00:29:50,720 --> 00:29:54,640
obj dump so the previous screen was

806
00:29:52,799 --> 00:29:58,000
showing the output in rodare

807
00:29:54,640 --> 00:30:00,320
this is objdump and it's actually again

808
00:29:58,000 --> 00:30:01,760
going to be a little bit different in

809
00:30:00,320 --> 00:30:02,799
this case it's going to be in this case

810
00:30:01,760 --> 00:30:06,559
it's going to be rip

811
00:30:02,799 --> 00:30:09,200
relative and in this case we see

812
00:30:06,559 --> 00:30:10,799
another call to new proc and we're

813
00:30:09,200 --> 00:30:14,000
actually passing it the effective

814
00:30:10,799 --> 00:30:16,000
address of the function itself and it's

815
00:30:14,000 --> 00:30:18,000
going to be relative to that static

816
00:30:16,000 --> 00:30:19,360
static base pointer that we mentioned

817
00:30:18,000 --> 00:30:23,039
earlier so it's just

818
00:30:19,360 --> 00:30:26,399
something interesting to note

819
00:30:23,039 --> 00:30:26,799
so what to look for as far as matching

820
00:30:26,399 --> 00:30:30,239
or

821
00:30:26,799 --> 00:30:32,158
looking for go internal functions

822
00:30:30,240 --> 00:30:33,679
to understand what's happening in your

823
00:30:32,159 --> 00:30:36,960
go binary so

824
00:30:33,679 --> 00:30:40,240
if you are interested in

825
00:30:36,960 --> 00:30:42,720
identifying concurrency functions or

826
00:30:40,240 --> 00:30:43,440
concurrency processes you will look for

827
00:30:42,720 --> 00:30:46,399
calls to

828
00:30:43,440 --> 00:30:47,120
sim runtime new stat new object make

829
00:30:46,399 --> 00:30:50,080
change for

830
00:30:47,120 --> 00:30:51,760
creating channels weight group for

831
00:30:50,080 --> 00:30:54,240
passing um

832
00:30:51,760 --> 00:30:55,200
go routines to a white group differ

833
00:30:54,240 --> 00:30:57,679
brock stack

834
00:30:55,200 --> 00:30:59,440
different return anything that has to do

835
00:30:57,679 --> 00:31:02,080
with sigo you will look for

836
00:30:59,440 --> 00:31:03,200
this particular syntax c go underscore

837
00:31:02,080 --> 00:31:06,080
the name of the function

838
00:31:03,200 --> 00:31:06,480
or c func if you are interested in

839
00:31:06,080 --> 00:31:09,360
seeing

840
00:31:06,480 --> 00:31:10,559
uh how the uh or functions that are

841
00:31:09,360 --> 00:31:13,360
being handled by

842
00:31:10,559 --> 00:31:14,399
or where the garbage collector is

843
00:31:13,360 --> 00:31:15,918
involved in the

844
00:31:14,399 --> 00:31:18,080
running of a particular function you

845
00:31:15,919 --> 00:31:22,799
will look for functions like

846
00:31:18,080 --> 00:31:22,799
runtime dot gc barrier and

847
00:31:23,360 --> 00:31:26,799
in runtime type move as we saw earlier

848
00:31:26,000 --> 00:31:29,120
so

849
00:31:26,799 --> 00:31:30,480
in essence the key here is to read the

850
00:31:29,120 --> 00:31:32,080
manual right

851
00:31:30,480 --> 00:31:33,679
if you get more the more familiar you

852
00:31:32,080 --> 00:31:35,279
become with that going journals

853
00:31:33,679 --> 00:31:37,919
the better you will be able to

854
00:31:35,279 --> 00:31:41,279
understand um

855
00:31:37,919 --> 00:31:44,320
reversed uh binary code or reversed

856
00:31:41,279 --> 00:31:47,120
banner uh gold binaries

857
00:31:44,320 --> 00:31:49,360
so go error handling go error handling

858
00:31:47,120 --> 00:31:52,000
is super clumsy and manual

859
00:31:49,360 --> 00:31:53,199
uh so this is something that's uh can be

860
00:31:52,000 --> 00:31:55,279
interesting when you

861
00:31:53,200 --> 00:31:57,120
are looking at go binary so we're

862
00:31:55,279 --> 00:31:58,240
looking for bucks it is worth taking the

863
00:31:57,120 --> 00:32:01,600
time to identify

864
00:31:58,240 --> 00:32:04,720
missing error handling logic so

865
00:32:01,600 --> 00:32:07,199
to identify missing error handling logic

866
00:32:04,720 --> 00:32:07,919
the first step will be to identify what

867
00:32:07,200 --> 00:32:11,200
look

868
00:32:07,919 --> 00:32:13,600
what error logic

869
00:32:11,200 --> 00:32:15,440
looks like typically in go and in

870
00:32:13,600 --> 00:32:18,719
particular in a reversed uh

871
00:32:15,440 --> 00:32:20,480
file not reverse binary so the first

872
00:32:18,720 --> 00:32:22,960
step is to understand that error

873
00:32:20,480 --> 00:32:25,360
in go it's an interface so an

874
00:32:22,960 --> 00:32:27,120
interfacing goal consists of a pointer

875
00:32:25,360 --> 00:32:28,240
to a v table which contains the

876
00:32:27,120 --> 00:32:30,639
functions and that

877
00:32:28,240 --> 00:32:32,159
uh function pointers that point to the

878
00:32:30,640 --> 00:32:35,279
virtual functions

879
00:32:32,159 --> 00:32:36,000
and a value pointer so what does that

880
00:32:35,279 --> 00:32:39,360
look like

881
00:32:36,000 --> 00:32:42,559
it looks like this so typically in go

882
00:32:39,360 --> 00:32:44,479
you are likely to see this a bunch this

883
00:32:42,559 --> 00:32:46,559
is how

884
00:32:44,480 --> 00:32:49,039
most of the times or one of the most

885
00:32:46,559 --> 00:32:51,360
common ways to handle errors in go so

886
00:32:49,039 --> 00:32:54,320
you call a function module.set options

887
00:32:51,360 --> 00:32:55,439
which returns an error then we do a

888
00:32:54,320 --> 00:32:58,639
manual check

889
00:32:55,440 --> 00:33:01,600
to see a or explicit check to

890
00:32:58,640 --> 00:33:02,240
to check whether the error uh was nil or

891
00:33:01,600 --> 00:33:04,959
not

892
00:33:02,240 --> 00:33:06,880
if it is not nil then we return the

893
00:33:04,960 --> 00:33:08,720
error we have an error we have to return

894
00:33:06,880 --> 00:33:10,320
it or we print it or we do whatever we

895
00:33:08,720 --> 00:33:11,919
need to do with error but this

896
00:33:10,320 --> 00:33:14,000
particular check right here it's going

897
00:33:11,919 --> 00:33:17,200
to be very common

898
00:33:14,000 --> 00:33:20,799
so how does that look like in go well

899
00:33:17,200 --> 00:33:24,240
uh here we're calling set model options

900
00:33:20,799 --> 00:33:25,200
which in this case returns an error and

901
00:33:24,240 --> 00:33:27,039
because again

902
00:33:25,200 --> 00:33:29,200
argue return values are passed in the

903
00:33:27,039 --> 00:33:31,440
stack so we're grabbing the

904
00:33:29,200 --> 00:33:32,399
uh the error objects which again

905
00:33:31,440 --> 00:33:35,279
consists of the v

906
00:33:32,399 --> 00:33:36,080
table pointer or the table to the b

907
00:33:35,279 --> 00:33:38,799
table

908
00:33:36,080 --> 00:33:39,840
and then the value um then we are

909
00:33:38,799 --> 00:33:43,760
checking whether

910
00:33:39,840 --> 00:33:47,840
the uh the the pointer to the table is

911
00:33:43,760 --> 00:33:51,120
uh null and if it's not then we continue

912
00:33:47,840 --> 00:33:53,120
uh otherwise we return so

913
00:33:51,120 --> 00:33:54,639
identifying this type of construct again

914
00:33:53,120 --> 00:33:57,360
because it's something that's so common

915
00:33:54,640 --> 00:33:57,760
in go code it's going to be very useful

916
00:33:57,360 --> 00:34:00,000
um

917
00:33:57,760 --> 00:34:04,158
it's particular if you want to again

918
00:34:00,000 --> 00:34:04,159
identify missing error handling logic

919
00:34:04,880 --> 00:34:08,399
so great that's uh that's sort of the

920
00:34:07,519 --> 00:34:09,918
basics and

921
00:34:08,399 --> 00:34:11,918
some of the most important points that

922
00:34:09,918 --> 00:34:15,118
you need to keep in mind when going

923
00:34:11,918 --> 00:34:17,279
or when reverse engineering go banaries

924
00:34:15,119 --> 00:34:18,960
now let's say that you are hopefully

925
00:34:17,280 --> 00:34:20,159
this picked your interest and you want

926
00:34:18,960 --> 00:34:22,480
to research uh

927
00:34:20,159 --> 00:34:24,639
go a little bit more obviously the first

928
00:34:22,480 --> 00:34:28,240
step is to write more go

929
00:34:24,639 --> 00:34:31,440
write google this is a compile your

930
00:34:28,239 --> 00:34:32,959
your code disassemble it see what's

931
00:34:31,440 --> 00:34:34,560
interesting in your output

932
00:34:32,960 --> 00:34:36,879
start playing with some practice uh

933
00:34:34,560 --> 00:34:39,040
there's some neat documentation online

934
00:34:36,879 --> 00:34:41,839
as far as a go fragments because there's

935
00:34:39,040 --> 00:34:42,639
uh you can um influence the behavior of

936
00:34:41,839 --> 00:34:44,799
the compiler

937
00:34:42,639 --> 00:34:46,079
in several interesting ways so for

938
00:34:44,800 --> 00:34:48,159
instance you can call

939
00:34:46,079 --> 00:34:50,639
go no split if you want to make sure

940
00:34:48,159 --> 00:34:53,359
that your functions do not get optimized

941
00:34:50,639 --> 00:34:54,879
out of the code of the assembly

942
00:34:53,359 --> 00:34:58,960
disassemble code

943
00:34:54,879 --> 00:35:00,960
uh go no inline um sorry

944
00:34:58,960 --> 00:35:02,160
the the the previous mention of that

945
00:35:00,960 --> 00:35:04,160
that

946
00:35:02,160 --> 00:35:05,200
it's for go no inline if you want to

947
00:35:04,160 --> 00:35:08,720
avoid your

948
00:35:05,200 --> 00:35:11,919
functions from being optimized out

949
00:35:08,720 --> 00:35:12,720
go into split if you want to prevent go

950
00:35:11,920 --> 00:35:16,079
from doing

951
00:35:12,720 --> 00:35:19,919
that stack guard check that i mentioned

952
00:35:16,079 --> 00:35:22,800
earlier you can also go and download

953
00:35:19,920 --> 00:35:23,920
a or clone go to your computer look at

954
00:35:22,800 --> 00:35:27,119
the go code

955
00:35:23,920 --> 00:35:29,839
and there is a variable in

956
00:35:27,119 --> 00:35:31,200
source runtime stack.go that's called

957
00:35:29,839 --> 00:35:33,040
stackdebug

958
00:35:31,200 --> 00:35:35,759
and it's set to zero you can set it to

959
00:35:33,040 --> 00:35:38,880
one and then use your custom

960
00:35:35,760 --> 00:35:42,240
go uh compilgo binary to

961
00:35:38,880 --> 00:35:44,640
run your or to compile your code

962
00:35:42,240 --> 00:35:46,399
and then that way you will see uh this

963
00:35:44,640 --> 00:35:48,720
interesting debugging messages

964
00:35:46,400 --> 00:35:50,160
when the stack is growing and shrinking

965
00:35:48,720 --> 00:35:52,160
so that's something interesting to look

966
00:35:50,160 --> 00:35:55,118
at if you are interested in doing go

967
00:35:52,160 --> 00:35:56,240
more go research you can also go use go

968
00:35:55,119 --> 00:35:58,480
bill with a

969
00:35:56,240 --> 00:35:59,279
flag amp to print optimization decisions

970
00:35:58,480 --> 00:36:01,200
so let's say

971
00:35:59,280 --> 00:36:02,720
you are you wrote a function that's

972
00:36:01,200 --> 00:36:04,720
supposed to have a defer

973
00:36:02,720 --> 00:36:05,839
uh call but you don't see that there

974
00:36:04,720 --> 00:36:08,160
maybe uh

975
00:36:05,839 --> 00:36:09,200
one thing to do is to pas to build it

976
00:36:08,160 --> 00:36:12,480
with the

977
00:36:09,200 --> 00:36:14,319
m flag to see if um

978
00:36:12,480 --> 00:36:16,800
what optimization decisions were made by

979
00:36:14,320 --> 00:36:18,160
go that might have resulted in you not

980
00:36:16,800 --> 00:36:20,480
seeing the code that you were expected

981
00:36:18,160 --> 00:36:23,759
to see in the disassemble code

982
00:36:20,480 --> 00:36:26,880
you can also use a codebug gc trace

983
00:36:23,760 --> 00:36:28,160
before uh running your binaries to

984
00:36:26,880 --> 00:36:31,520
better understand what

985
00:36:28,160 --> 00:36:32,560
the go garbage collector is actually

986
00:36:31,520 --> 00:36:34,640
doing

987
00:36:32,560 --> 00:36:35,680
so you will see some interesting traces

988
00:36:34,640 --> 00:36:37,359
as far as

989
00:36:35,680 --> 00:36:38,720
when the garbage collector is coming

990
00:36:37,359 --> 00:36:40,799
into play

991
00:36:38,720 --> 00:36:42,560
you can also use tools like go fast and

992
00:36:40,800 --> 00:36:45,680
go sec

993
00:36:42,560 --> 00:36:48,799
to check for uh box in your go

994
00:36:45,680 --> 00:36:52,078
code so

995
00:36:48,800 --> 00:36:54,480
let's wrap up so the uh one main thing

996
00:36:52,079 --> 00:36:56,800
that i want you to

997
00:36:54,480 --> 00:36:58,640
take home with us is to combine gold

998
00:36:56,800 --> 00:37:00,079
tools with your favorite reverse

999
00:36:58,640 --> 00:37:01,839
engineering tools

1000
00:37:00,079 --> 00:37:03,280
so go tools are very interesting and a

1001
00:37:01,839 --> 00:37:06,000
lot of fun to play with

1002
00:37:03,280 --> 00:37:07,040
so make sure to uh leverage those as you

1003
00:37:06,000 --> 00:37:10,320
are conducting reverse

1004
00:37:07,040 --> 00:37:12,160
engineering of global aries finding

1005
00:37:10,320 --> 00:37:13,599
close references strings can be a bit

1006
00:37:12,160 --> 00:37:15,839
tedious however there are

1007
00:37:13,599 --> 00:37:17,040
tools that make the process a little bit

1008
00:37:15,839 --> 00:37:19,359
easier

1009
00:37:17,040 --> 00:37:21,440
uh also familiarize yourself with go

1010
00:37:19,359 --> 00:37:24,078
internals this is key

1011
00:37:21,440 --> 00:37:25,200
and also familiarize yourself with uh

1012
00:37:24,079 --> 00:37:27,599
how the

1013
00:37:25,200 --> 00:37:28,960
go scheduler works how the car garbage

1014
00:37:27,599 --> 00:37:30,240
collector works and go

1015
00:37:28,960 --> 00:37:32,160
this is actually going to be very

1016
00:37:30,240 --> 00:37:32,799
helpful not only your reversing you

1017
00:37:32,160 --> 00:37:35,200
really

1018
00:37:32,800 --> 00:37:37,359
understand then go banaries that you are

1019
00:37:35,200 --> 00:37:38,560
reversing engineering but also

1020
00:37:37,359 --> 00:37:41,279
if you are interested in finding

1021
00:37:38,560 --> 00:37:44,799
vulnerabilities in go code

1022
00:37:41,280 --> 00:37:46,560
um so looking for bugs uh one big thing

1023
00:37:44,800 --> 00:37:47,599
is i looking for race condition bugs

1024
00:37:46,560 --> 00:37:50,880
those are huge in

1025
00:37:47,599 --> 00:37:51,440
uh in go and also looking for on handle

1026
00:37:50,880 --> 00:37:54,480
errors

1027
00:37:51,440 --> 00:37:55,520
uh and looking for uh vulnerabilities

1028
00:37:54,480 --> 00:37:58,800
that you will typically see

1029
00:37:55,520 --> 00:38:00,079
in c uh but that in this case you will

1030
00:37:58,800 --> 00:38:01,920
see in um

1031
00:38:00,079 --> 00:38:04,480
seagull functions that are embedded in

1032
00:38:01,920 --> 00:38:08,079
the go code

1033
00:38:04,480 --> 00:38:09,920
so uh that is it for me

1034
00:38:08,079 --> 00:38:11,440
i'll be available to answer any

1035
00:38:09,920 --> 00:38:12,960
questions that you guys might have

1036
00:38:11,440 --> 00:38:16,480
hopefully this was

1037
00:38:12,960 --> 00:38:19,839
helpful and that's it

1038
00:38:16,480 --> 00:38:19,839
thank you and have a good day everybody

1039
00:38:32,160 --> 00:38:34,240
you

