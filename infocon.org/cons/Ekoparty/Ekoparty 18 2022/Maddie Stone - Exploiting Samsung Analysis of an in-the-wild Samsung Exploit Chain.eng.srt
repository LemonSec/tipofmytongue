1
00:00:05,380 --> 00:00:09,530
[Music]

2
00:00:20,900 --> 00:00:22,750
thank you

3
00:00:22,750 --> 00:00:30,420
[Music]

4
00:00:30,420 --> 00:00:31,570
foreign

5
00:00:31,570 --> 00:00:37,240
[Applause]

6
00:00:49,630 --> 00:00:52,100
[Laughter]

7
00:00:52,100 --> 00:00:54,719
that's all I got

8
00:00:54,719 --> 00:00:57,899
um hi I'm Maddie Stone and this talk is

9
00:00:57,899 --> 00:01:00,059
all about a Samsung in the wild exploit

10
00:01:00,059 --> 00:01:01,140
chain

11
00:01:01,140 --> 00:01:04,979
so as I said that's my name that's me

12
00:01:04,979 --> 00:01:06,900
um I am a security researcher at Google

13
00:01:06,900 --> 00:01:09,840
project zero and we are a team of

14
00:01:09,840 --> 00:01:12,180
offensive security researchers so the

15
00:01:12,180 --> 00:01:13,860
majority of our team is focused on

16
00:01:13,860 --> 00:01:16,619
vulnerability research exploit Dev to

17
00:01:16,619 --> 00:01:19,140
show what are attackers likely doing to

18
00:01:19,140 --> 00:01:20,820
find the same bugs

19
00:01:20,820 --> 00:01:23,580
Etc but my role is focusing instead

20
00:01:23,580 --> 00:01:26,700
first off on the zero day exploits that

21
00:01:26,700 --> 00:01:29,460
are actively exploited in the wild so

22
00:01:29,460 --> 00:01:31,380
the ones that the attackers are actually

23
00:01:31,380 --> 00:01:33,360
using not the ones that they could

24
00:01:33,360 --> 00:01:35,939
hypothetically be using and as a

25
00:01:35,939 --> 00:01:38,759
refresher a zero day vulnerability or a

26
00:01:38,759 --> 00:01:40,380
zero day exploit are those

27
00:01:40,380 --> 00:01:42,840
vulnerabilities that Defenders don't yet

28
00:01:42,840 --> 00:01:45,360
know about so there's not the patches

29
00:01:45,360 --> 00:01:48,000
available for them we don't realize

30
00:01:48,000 --> 00:01:49,320
there's a hole there that could be

31
00:01:49,320 --> 00:01:51,479
exploited only those attackers know

32
00:01:51,479 --> 00:01:54,240
about the hole so that's what I focus on

33
00:01:54,240 --> 00:01:56,579
on a day-to-day basis

34
00:01:56,579 --> 00:01:59,939
and so my whole role and my job and goal

35
00:01:59,939 --> 00:02:02,460
is we learn from all of these zero days

36
00:02:02,460 --> 00:02:04,979
that are discovered in the wild that are

37
00:02:04,979 --> 00:02:07,560
detected and make sure that we learn as

38
00:02:07,560 --> 00:02:09,899
much as possible from them in order to

39
00:02:09,899 --> 00:02:11,819
make it harder for the attackers to come

40
00:02:11,819 --> 00:02:14,280
back write another zero day and use it

41
00:02:14,280 --> 00:02:16,260
against folks

42
00:02:16,260 --> 00:02:17,840
so that's what this talk is about

43
00:02:17,840 --> 00:02:21,180
specifically it's about a sample that

44
00:02:21,180 --> 00:02:24,660
was found in the wild which involved

45
00:02:24,660 --> 00:02:26,879
which targeted Samsung devices and

46
00:02:26,879 --> 00:02:28,980
involved zero days

47
00:02:28,980 --> 00:02:32,640
so this sample was obtained by the

48
00:02:32,640 --> 00:02:35,160
Google threat analysis group

49
00:02:35,160 --> 00:02:40,080
um and they attributed this sample to a

50
00:02:40,080 --> 00:02:42,000
surveillance vendor commercial

51
00:02:42,000 --> 00:02:44,340
surveillance vendor so this sample in

52
00:02:44,340 --> 00:02:47,459
particular was a native library for an

53
00:02:47,459 --> 00:02:50,400
Android app and it involved three

54
00:02:50,400 --> 00:02:52,920
different zero day vulnerabilities that

55
00:02:52,920 --> 00:02:54,480
were zero day at the time of the

56
00:02:54,480 --> 00:02:57,060
discovery of the sample the sample was

57
00:02:57,060 --> 00:03:00,060
discovered during a testing phase or

58
00:03:00,060 --> 00:03:03,120
during a texting practice so we did not

59
00:03:03,120 --> 00:03:06,480
we were not able to see or study the

60
00:03:06,480 --> 00:03:08,940
whole chain from start to finish this

61
00:03:08,940 --> 00:03:11,700
sample is also from late 2020 so that's

62
00:03:11,700 --> 00:03:13,739
an important thing to keep in mind when

63
00:03:13,739 --> 00:03:15,780
we sort of evaluate the state of the art

64
00:03:15,780 --> 00:03:19,980
what was vulnerable what was not Etc

65
00:03:19,980 --> 00:03:22,500
so let's walk through what we're going

66
00:03:22,500 --> 00:03:25,099
to cover in this sample we did not

67
00:03:25,099 --> 00:03:28,200
include or we did not there is not the

68
00:03:28,200 --> 00:03:30,599
initial attack Vector included in this

69
00:03:30,599 --> 00:03:33,480
sample so the sample is a native library

70
00:03:33,480 --> 00:03:35,040
that would run within an Android

71
00:03:35,040 --> 00:03:37,500
application so that means that the

72
00:03:37,500 --> 00:03:39,480
initial attack Vector could have been

73
00:03:39,480 --> 00:03:42,840
some vulnerability in a common app where

74
00:03:42,840 --> 00:03:44,459
they knew they could then load this

75
00:03:44,459 --> 00:03:47,280
library to run or it could have been

76
00:03:47,280 --> 00:03:49,440
something like campaigns we saw earlier

77
00:03:49,440 --> 00:03:52,140
this year where attackers were able to

78
00:03:52,140 --> 00:03:55,140
have apps install installed on their

79
00:03:55,140 --> 00:03:58,379
targets phones but either way we know

80
00:03:58,379 --> 00:04:00,900
that we're starting in sort of the the

81
00:04:00,900 --> 00:04:04,019
least privileged app context which is

82
00:04:04,019 --> 00:04:07,019
called untrusted app so that's where our

83
00:04:07,019 --> 00:04:09,780
exploit we're analyzing starts from

84
00:04:09,780 --> 00:04:11,519
so the first thing it does once it's

85
00:04:11,519 --> 00:04:13,680
running and loaded in this untrusted app

86
00:04:13,680 --> 00:04:15,239
context is it's going to use a

87
00:04:15,239 --> 00:04:17,880
vulnerability to get arbitrary file

88
00:04:17,880 --> 00:04:19,680
system read or write

89
00:04:19,680 --> 00:04:21,478
then it's going to figure out how to

90
00:04:21,478 --> 00:04:25,139
load its next stage in a more privileged

91
00:04:25,139 --> 00:04:27,060
than untrusted app more privileged

92
00:04:27,060 --> 00:04:28,020
contest

93
00:04:28,020 --> 00:04:29,759
a system app

94
00:04:29,759 --> 00:04:30,840
then we're going to use another

95
00:04:30,840 --> 00:04:33,419
vulnerability to leak information from

96
00:04:33,419 --> 00:04:35,040
the kernel

97
00:04:35,040 --> 00:04:37,259
finally we have a privileged escalation

98
00:04:37,259 --> 00:04:39,660
through the display Processing Unit

99
00:04:39,660 --> 00:04:41,100
driver

100
00:04:41,100 --> 00:04:42,720
and whoa then we're going to talk about

101
00:04:42,720 --> 00:04:44,639
how it got root from there so we have a

102
00:04:44,639 --> 00:04:47,100
lot to cover in 15 minutes

103
00:04:47,100 --> 00:04:48,360
um all three of these vulnerabilities

104
00:04:48,360 --> 00:04:51,000
were patched in March 2021 and the

105
00:04:51,000 --> 00:04:55,080
Samsung March 2020 2021 release

106
00:04:55,080 --> 00:04:57,120
um yeah

107
00:04:57,120 --> 00:04:58,860
so the devices that were targeted with

108
00:04:58,860 --> 00:05:00,860
this chain were specifically Samsung

109
00:05:00,860 --> 00:05:03,720
exynos devices so if you're not aware

110
00:05:03,720 --> 00:05:05,759
Samsung devices sort of run on two

111
00:05:05,759 --> 00:05:08,160
different CPUs devices sold

112
00:05:08,160 --> 00:05:10,080
predominantly in the United States and

113
00:05:10,080 --> 00:05:11,820
China as along with a handful of other

114
00:05:11,820 --> 00:05:15,600
countries run Qualcomm CPUs whereas the

115
00:05:15,600 --> 00:05:17,220
rest of the world largely runs on the

116
00:05:17,220 --> 00:05:20,820
Samsung in-house developed chip the

117
00:05:20,820 --> 00:05:23,220
exynos specifically this chain could

118
00:05:23,220 --> 00:05:25,740
only target those exynos devices because

119
00:05:25,740 --> 00:05:28,259
vulnerability 2 is triggered using the

120
00:05:28,259 --> 00:05:31,080
GPO the GPU driver that is specific to

121
00:05:31,080 --> 00:05:33,539
the exynos chips and vulnerability three

122
00:05:33,539 --> 00:05:35,400
is specifically in the driver that only

123
00:05:35,400 --> 00:05:38,759
runs on these exynos and lastly it

124
00:05:38,759 --> 00:05:41,400
targeted phones running kernel versions

125
00:05:41,400 --> 00:05:45,240
4.14 and so in late 2020 when these were

126
00:05:45,240 --> 00:05:47,699
zero day and the sample was found this

127
00:05:47,699 --> 00:05:49,020
would have included phones like the

128
00:05:49,020 --> 00:05:53,039
mid-tier A50 A51 along with the flagship

129
00:05:53,039 --> 00:05:55,139
S10

130
00:05:55,139 --> 00:05:56,400
so

131
00:05:56,400 --> 00:05:58,199
why did I think this was interesting

132
00:05:58,199 --> 00:06:00,479
enough to share about this sample

133
00:06:00,479 --> 00:06:02,280
first off I think anything in the wild

134
00:06:02,280 --> 00:06:04,199
is generally pretty interesting there

135
00:06:04,199 --> 00:06:06,120
aren't a huge number of those samples

136
00:06:06,120 --> 00:06:08,520
that we get to discover and get a ground

137
00:06:08,520 --> 00:06:10,800
truth of what our attackers actually

138
00:06:10,800 --> 00:06:13,800
doing versus what do we think attackers

139
00:06:13,800 --> 00:06:16,080
are doing so that first off

140
00:06:16,080 --> 00:06:18,479
but secondly all three of these

141
00:06:18,479 --> 00:06:20,220
vulnerabilities are in manufacture

142
00:06:20,220 --> 00:06:22,199
specific components

143
00:06:22,199 --> 00:06:24,419
as Android vulnerability researchers

144
00:06:24,419 --> 00:06:26,460
this is talked about but it doesn't tend

145
00:06:26,460 --> 00:06:29,280
to be the focus of a lot of

146
00:06:29,280 --> 00:06:30,660
vulnerability research who are

147
00:06:30,660 --> 00:06:33,419
publishing blog posts generally just

148
00:06:33,419 --> 00:06:35,039
because then your exploit will be

149
00:06:35,039 --> 00:06:37,620
specific to the manufacturer so instead

150
00:06:37,620 --> 00:06:41,639
the Upstream Linux kernel the AOSP is

151
00:06:41,639 --> 00:06:45,060
what tends to get a lot of the looks and

152
00:06:45,060 --> 00:06:47,520
research done so that's interesting here

153
00:06:47,520 --> 00:06:50,400
and also as you'll see our first

154
00:06:50,400 --> 00:06:52,319
vulnerability we're going to cover is

155
00:06:52,319 --> 00:06:54,840
sort of the foundation of this whole

156
00:06:54,840 --> 00:06:57,000
exploit chain and it's in a Java

157
00:06:57,000 --> 00:06:58,740
component which is interesting because

158
00:06:58,740 --> 00:07:00,780
vulnerability researchers were usually

159
00:07:00,780 --> 00:07:03,900
focused on memory corruption bugs which

160
00:07:03,900 --> 00:07:06,900
will exist in compiled code

161
00:07:06,900 --> 00:07:09,240
so let's jump into it here is our first

162
00:07:09,240 --> 00:07:11,039
vulnerability as I said it was patched

163
00:07:11,039 --> 00:07:14,039
in March 2021 and it is a arbitrary file

164
00:07:14,039 --> 00:07:18,660
system read and write via a clipboard

165
00:07:18,660 --> 00:07:21,720
so this yellow box the one in the bottom

166
00:07:21,720 --> 00:07:25,080
left is the one that we are starting in

167
00:07:25,080 --> 00:07:27,000
so we're running in our untrusted app

168
00:07:27,000 --> 00:07:28,800
context

169
00:07:28,800 --> 00:07:31,139
and before we jump into this we need to

170
00:07:31,139 --> 00:07:33,000
understand a little bit about what our

171
00:07:33,000 --> 00:07:36,479
content providers in Android so they are

172
00:07:36,479 --> 00:07:39,539
a component that basically allows for

173
00:07:39,539 --> 00:07:42,300
the storage and system-wide access of

174
00:07:42,300 --> 00:07:45,060
data because Android has sandboxes that

175
00:07:45,060 --> 00:07:46,979
you know tries to separate data from

176
00:07:46,979 --> 00:07:49,319
each other so the content providers is

177
00:07:49,319 --> 00:07:54,419
what says let's one app contact or see

178
00:07:54,419 --> 00:07:56,699
your contacts because that's stored in a

179
00:07:56,699 --> 00:07:59,400
separate context provider and so this

180
00:07:59,400 --> 00:08:01,380
data is stored in you know sort of like

181
00:08:01,380 --> 00:08:03,419
sqlite tables

182
00:08:03,419 --> 00:08:06,660
and a key aspect of it is that according

183
00:08:06,660 --> 00:08:08,940
to spec content providers are required

184
00:08:08,940 --> 00:08:11,940
to implement these six abstract methods

185
00:08:11,940 --> 00:08:14,819
the first five the all of them except

186
00:08:14,819 --> 00:08:17,160
oncreate are called by a client who

187
00:08:17,160 --> 00:08:20,660
wants access to the data

188
00:08:20,699 --> 00:08:22,080
the other key thing to note about

189
00:08:22,080 --> 00:08:26,580
content providers is that by default all

190
00:08:26,580 --> 00:08:29,639
applications can read from or write to

191
00:08:29,639 --> 00:08:31,979
your content provider even if the

192
00:08:31,979 --> 00:08:34,140
underlying data is private

193
00:08:34,140 --> 00:08:37,200
so when you create a content provider if

194
00:08:37,200 --> 00:08:38,640
you do not go through the necessary

195
00:08:38,640 --> 00:08:40,860
steps for Access Control and permissions

196
00:08:40,860 --> 00:08:43,500
it is going to be device accessible

197
00:08:43,500 --> 00:08:44,940
across the board

198
00:08:44,940 --> 00:08:47,640
usually these permissions will be set

199
00:08:47,640 --> 00:08:50,160
via the app's manifest file

200
00:08:50,160 --> 00:08:52,260
where they can set you need this

201
00:08:52,260 --> 00:08:55,260
permission to read or write Etc

202
00:08:55,260 --> 00:08:57,899
but this is where our bug comes in

203
00:08:57,899 --> 00:08:59,640
our content provider doesn't actually

204
00:08:59,640 --> 00:09:02,820
exist inside of an app it's running

205
00:09:02,820 --> 00:09:05,459
within this server or the system server

206
00:09:05,459 --> 00:09:07,440
which is a jar file

207
00:09:07,440 --> 00:09:09,660
so it's required to do all of its own

208
00:09:09,660 --> 00:09:12,959
Access Control

209
00:09:13,019 --> 00:09:15,480
one more foundational step before we can

210
00:09:15,480 --> 00:09:17,580
really get into it is Android file

211
00:09:17,580 --> 00:09:19,920
permissions so Android uses a

212
00:09:19,920 --> 00:09:22,440
combination of Linux file permissions

213
00:09:22,440 --> 00:09:24,899
you know read write execute along with

214
00:09:24,899 --> 00:09:27,720
SC Linux and so the system user on

215
00:09:27,720 --> 00:09:30,120
Android devices is the most privileged

216
00:09:30,120 --> 00:09:32,640
user on the device besides root

217
00:09:32,640 --> 00:09:35,700
and the system server SE Linux context

218
00:09:35,700 --> 00:09:38,640
is very privileged because it manages a

219
00:09:38,640 --> 00:09:40,560
whole bunch of services critical to your

220
00:09:40,560 --> 00:09:42,839
device think of connecting to Wi-Fi

221
00:09:42,839 --> 00:09:45,600
location stuff so it has to be

222
00:09:45,600 --> 00:09:47,399
privileged to do all of that

223
00:09:47,399 --> 00:09:49,440
and so one thing to keep in mind as

224
00:09:49,440 --> 00:09:50,940
we're talking about a lot of access

225
00:09:50,940 --> 00:09:52,740
stuff through that throughout this

226
00:09:52,740 --> 00:09:55,320
presentation is that to have access to

227
00:09:55,320 --> 00:09:58,320
something a component needs both the

228
00:09:58,320 --> 00:10:01,140
requisite Linux file permissions as well

229
00:10:01,140 --> 00:10:05,640
as be in an accessible SC Linux context

230
00:10:05,640 --> 00:10:08,339
so in our case this clipboard provider

231
00:10:08,339 --> 00:10:11,459
which is a custom Edition by Samsung

232
00:10:11,459 --> 00:10:13,980
um runs within this privileged system

233
00:10:13,980 --> 00:10:17,700
server so here are some of the variables

234
00:10:17,700 --> 00:10:20,700
associated with it we have the database

235
00:10:20,700 --> 00:10:23,700
name clipboard image the table name the

236
00:10:23,700 --> 00:10:26,160
URL to access the content provider and

237
00:10:26,160 --> 00:10:27,480
then the table

238
00:10:27,480 --> 00:10:30,240
and the key part of this that sets us up

239
00:10:30,240 --> 00:10:32,399
for this arbitrary file system read and

240
00:10:32,399 --> 00:10:34,740
write is the name of this column here

241
00:10:34,740 --> 00:10:36,779
underscore data

242
00:10:36,779 --> 00:10:40,200
because underscore data is a special

243
00:10:40,200 --> 00:10:42,120
sort of nomenclature and means something

244
00:10:42,120 --> 00:10:44,399
specific in these Android content

245
00:10:44,399 --> 00:10:47,820
providers it allows direct access to

246
00:10:47,820 --> 00:10:51,300
files on the file system so if you have

247
00:10:51,300 --> 00:10:55,079
a path in a column named underscore data

248
00:10:55,079 --> 00:10:57,060
then you can use this helper function

249
00:10:57,060 --> 00:11:00,240
open file helper to directly open it

250
00:11:00,240 --> 00:11:02,100
without having to work with all of these

251
00:11:02,100 --> 00:11:06,000
underlying operating system internals

252
00:11:06,000 --> 00:11:10,740
so this is the insert method within the

253
00:11:10,740 --> 00:11:14,700
Samsung clipboard provider provider

254
00:11:14,700 --> 00:11:17,820
and what I would like you to note is

255
00:11:17,820 --> 00:11:20,579
there is insert and then the function

256
00:11:20,579 --> 00:11:23,519
just runs it just runs insert there is

257
00:11:23,519 --> 00:11:26,579
no access checking before that first

258
00:11:26,579 --> 00:11:27,899
insert call

259
00:11:27,899 --> 00:11:30,060
and because this is not an app and

260
00:11:30,060 --> 00:11:32,160
doesn't have a manifest that means

261
00:11:32,160 --> 00:11:34,200
there's no access checking at all

262
00:11:34,200 --> 00:11:37,440
because it would require some sort of

263
00:11:37,440 --> 00:11:38,700
vetting at the beginning of this

264
00:11:38,700 --> 00:11:42,500
function for there to be any

265
00:11:42,779 --> 00:11:44,700
so this is how you trigger the

266
00:11:44,700 --> 00:11:47,579
vulnerability so what our exploit did or

267
00:11:47,579 --> 00:11:50,100
not my exploit the exploit analysis I'm

268
00:11:50,100 --> 00:11:51,480
probably going to mess that up and say

269
00:11:51,480 --> 00:11:53,700
that a lot it's going to get me in

270
00:11:53,700 --> 00:11:55,140
trouble here

271
00:11:55,140 --> 00:11:57,600
um is first we need to create the

272
00:11:57,600 --> 00:12:00,300
content values and so this is just you

273
00:12:00,300 --> 00:12:01,860
know the Java object that's going to say

274
00:12:01,860 --> 00:12:04,980
hey I want to put this value associated

275
00:12:04,980 --> 00:12:07,980
with this column or key so in this case

276
00:12:07,980 --> 00:12:10,260
there is the column the underscore data

277
00:12:10,260 --> 00:12:12,600
a special one and then this file path

278
00:12:12,600 --> 00:12:16,079
data system users xero new file bin

279
00:12:16,079 --> 00:12:19,860
then we have the URI to this special

280
00:12:19,860 --> 00:12:22,500
clipboard provider

281
00:12:22,500 --> 00:12:25,019
and then we call insert so we are adding

282
00:12:25,019 --> 00:12:28,079
this new value to the table saying this

283
00:12:28,079 --> 00:12:31,380
custom file path goes in as data and

284
00:12:31,380 --> 00:12:35,220
then we receive back a URI that points

285
00:12:35,220 --> 00:12:37,200
directly to that row

286
00:12:37,200 --> 00:12:39,959
that new URI

287
00:12:39,959 --> 00:12:41,519
is the only thing that needs to be

288
00:12:41,519 --> 00:12:43,740
passed to open file descriptor

289
00:12:43,740 --> 00:12:46,079
with whatever mode you want to run in to

290
00:12:46,079 --> 00:12:48,120
then receive back a parcel file

291
00:12:48,120 --> 00:12:50,480
descriptor which is a Java object

292
00:12:50,480 --> 00:12:53,820
for whatever path you put in there and

293
00:12:53,820 --> 00:12:55,320
finally then

294
00:12:55,320 --> 00:12:57,660
a parcel file descriptor defines a

295
00:12:57,660 --> 00:13:00,180
function or method called get FD so you

296
00:13:00,180 --> 00:13:03,180
can get back the raw file descriptor

297
00:13:03,180 --> 00:13:05,279
so pretty straightforward using that

298
00:13:05,279 --> 00:13:07,500
underscore data column

299
00:13:07,500 --> 00:13:10,200
but how do they use this so they

300
00:13:10,200 --> 00:13:11,940
ultimately use this vulnerability four

301
00:13:11,940 --> 00:13:14,700
times throughout this exploit the first

302
00:13:14,700 --> 00:13:16,800
time here was to drop the stage to

303
00:13:16,800 --> 00:13:19,920
exploit and so we drop it at this path

304
00:13:19,920 --> 00:13:23,160
the dropped elf at that path will now

305
00:13:23,160 --> 00:13:27,600
have a SC Linux context of of user

306
00:13:27,600 --> 00:13:30,720
system data file so the key here is that

307
00:13:30,720 --> 00:13:33,660
apps do not have access to create or

308
00:13:33,660 --> 00:13:36,600
open those files but system server did

309
00:13:36,600 --> 00:13:39,959
so the exploit proxied that create and

310
00:13:39,959 --> 00:13:42,240
open functionality to through the

311
00:13:42,240 --> 00:13:44,940
privilege system server process got back

312
00:13:44,940 --> 00:13:46,980
a raw file descriptor and then they were

313
00:13:46,980 --> 00:13:51,360
able to read and write to that file

314
00:13:51,360 --> 00:13:53,279
so how was this bug fixed

315
00:13:53,279 --> 00:13:54,899
basically just adding an access check

316
00:13:54,899 --> 00:13:56,220
they added this check at the very

317
00:13:56,220 --> 00:13:57,779
beginning of the function that says what

318
00:13:57,779 --> 00:14:00,540
uid is calling me and they verified that

319
00:14:00,540 --> 00:14:02,399
anything that is calling this function

320
00:14:02,399 --> 00:14:06,200
is also already running a system

321
00:14:06,779 --> 00:14:10,800
so we now have our stage 2 elf on the

322
00:14:10,800 --> 00:14:13,260
file system but how do we load it we're

323
00:14:13,260 --> 00:14:15,120
still running in this unprivileged

324
00:14:15,120 --> 00:14:17,279
context but we want to start running in

325
00:14:17,279 --> 00:14:19,079
a more privileged one

326
00:14:19,079 --> 00:14:22,560
so this dropped as a background this

327
00:14:22,560 --> 00:14:25,220
drop file is another app native library

328
00:14:25,220 --> 00:14:27,540
and we know that because its starting

329
00:14:27,540 --> 00:14:30,300
point is a function called jni on load

330
00:14:30,300 --> 00:14:32,700
which is a built-in aspect of java

331
00:14:32,700 --> 00:14:34,320
native libraries

332
00:14:34,320 --> 00:14:36,720
and so the exploit ends up using this

333
00:14:36,720 --> 00:14:39,420
app that's pre-installed on Samsung

334
00:14:39,420 --> 00:14:42,360
phones called Samsung text to speech to

335
00:14:42,360 --> 00:14:45,959
load and execute stage number two

336
00:14:45,959 --> 00:14:48,360
so the Samsung Text-to-Speech app is a

337
00:14:48,360 --> 00:14:49,980
system app running on all Samsung

338
00:14:49,980 --> 00:14:52,139
devices it's pre-installed part of the

339
00:14:52,139 --> 00:14:56,100
system image and it is not quite as

340
00:14:56,100 --> 00:14:58,320
privileged as system server but is still

341
00:14:58,320 --> 00:15:00,060
much more privileged than the untrusted

342
00:15:00,060 --> 00:15:02,040
app context we're running in it's

343
00:15:02,040 --> 00:15:05,040
running as a system app and so there

344
00:15:05,040 --> 00:15:06,740
were many versions of this application

345
00:15:06,740 --> 00:15:10,320
that would read a settings file

346
00:15:10,320 --> 00:15:13,560
of this application and then just load

347
00:15:13,560 --> 00:15:16,680
whatever native or whatever path was

348
00:15:16,680 --> 00:15:18,660
there in the settings so the exploit

349
00:15:18,660 --> 00:15:20,639
took advantage of that because they had

350
00:15:20,639 --> 00:15:23,339
this first clipboard vulnerability that

351
00:15:23,339 --> 00:15:25,440
allowed them to write and read to

352
00:15:25,440 --> 00:15:27,779
arbitrary files on the file system

353
00:15:27,779 --> 00:15:30,420
so by changing that they were able to

354
00:15:30,420 --> 00:15:32,760
get their stage 2 Library past a

355
00:15:32,760 --> 00:15:35,100
system.load which would load it and

356
00:15:35,100 --> 00:15:37,620
begin executing jni onload

357
00:15:37,620 --> 00:15:39,120
so what this looked like is actually

358
00:15:39,120 --> 00:15:41,100
pretty straightforward they ended up

359
00:15:41,100 --> 00:15:42,899
using the clipboard vulnerability to

360
00:15:42,899 --> 00:15:44,639
write it to two different settings files

361
00:15:44,639 --> 00:15:46,560
because the path was slightly different

362
00:15:46,560 --> 00:15:49,740
based on the device version so the user

363
00:15:49,740 --> 00:15:51,300
de so many people have thought that

364
00:15:51,300 --> 00:15:53,399
meant it was targeting German users it

365
00:15:53,399 --> 00:15:55,940
does not de stands for device encrypted

366
00:15:55,940 --> 00:16:00,300
so just to clear that up off the bat so

367
00:16:00,300 --> 00:16:02,399
it wrote to both of these files just in

368
00:16:02,399 --> 00:16:04,620
case instead of checking which version

369
00:16:04,620 --> 00:16:07,260
it was running on and it just changed in

370
00:16:07,260 --> 00:16:09,839
the XML file this highlighted bit of

371
00:16:09,839 --> 00:16:12,060
what is your engine path and it changed

372
00:16:12,060 --> 00:16:13,920
it to their stage two

373
00:16:13,920 --> 00:16:15,899
so now we're executing as a more

374
00:16:15,899 --> 00:16:17,579
privileged system app

375
00:16:17,579 --> 00:16:20,040
and this is when they jump into the next

376
00:16:20,040 --> 00:16:21,899
two vulnerabilities the first of one

377
00:16:21,899 --> 00:16:25,579
being kernel information leak

378
00:16:26,160 --> 00:16:28,199
so what they're going to leak is the

379
00:16:28,199 --> 00:16:30,540
task struct address and assist call

380
00:16:30,540 --> 00:16:32,760
table address the task struct address

381
00:16:32,760 --> 00:16:36,540
will be used to access the address limit

382
00:16:36,540 --> 00:16:39,300
um member of the test truck because the

383
00:16:39,300 --> 00:16:41,279
adder limit is important for the kernels

384
00:16:41,279 --> 00:16:43,079
functioning and will be how they end up

385
00:16:43,079 --> 00:16:44,880
getting arbitrary kernel read and write

386
00:16:44,880 --> 00:16:47,339
the syscall table address they used to

387
00:16:47,339 --> 00:16:50,459
break k-a-f-l-r

388
00:16:50,820 --> 00:16:53,040
and basically all they do for this info

389
00:16:53,040 --> 00:16:56,100
leak is abuse a worn on worn on Macros

390
00:16:56,100 --> 00:16:58,139
are used in the Linux kernel to debug

391
00:16:58,139 --> 00:16:59,940
kernel failures and because they're

392
00:16:59,940 --> 00:17:01,980
supposed to only be used for kernel

393
00:17:01,980 --> 00:17:04,559
failures they include a whole lot of

394
00:17:04,559 --> 00:17:06,780
information in their logging when

395
00:17:06,780 --> 00:17:08,880
they're hit including a full back Trace

396
00:17:08,880 --> 00:17:12,780
which included stack contents

397
00:17:12,780 --> 00:17:14,880
so this is the worn on that they were

398
00:17:14,880 --> 00:17:17,160
abusing in the exploit this is a

399
00:17:17,160 --> 00:17:21,240
function within the Mali GPU driver the

400
00:17:21,240 --> 00:17:23,760
Mali GPU is one of the generally two

401
00:17:23,760 --> 00:17:26,819
common GPU drivers that are used in the

402
00:17:26,819 --> 00:17:29,580
Android ecosystem and so there was this

403
00:17:29,580 --> 00:17:31,980
worn on right here

404
00:17:31,980 --> 00:17:34,320
so basically what this is is this is an

405
00:17:34,320 --> 00:17:37,440
eye octal call and if the ioctal is

406
00:17:37,440 --> 00:17:39,660
passed an invalid command number one

407
00:17:39,660 --> 00:17:41,280
that doesn't actually exist within the

408
00:17:41,280 --> 00:17:44,460
driver then we hit the worn on

409
00:17:44,460 --> 00:17:46,500
so this is all they had to do to trigger

410
00:17:46,500 --> 00:17:49,140
that is they get a file descriptor

411
00:17:49,140 --> 00:17:52,080
handle to that specific ioctal driver

412
00:17:52,080 --> 00:17:54,780
and then they pass in this invalid

413
00:17:54,780 --> 00:17:58,200
command and now they've hit the worn on

414
00:17:58,200 --> 00:18:00,840
after hitting worn on a few different

415
00:18:00,840 --> 00:18:02,880
times to make sure you got the good logs

416
00:18:02,880 --> 00:18:06,660
they then turn on a bug report

417
00:18:06,660 --> 00:18:07,919
um oops

418
00:18:07,919 --> 00:18:10,559
so they end up calling these to set

419
00:18:10,559 --> 00:18:13,679
build properties for First a full bug

420
00:18:13,679 --> 00:18:15,600
report from dump State and then they use

421
00:18:15,600 --> 00:18:18,559
CTL start to initiate the bug report

422
00:18:18,559 --> 00:18:21,720
ctl.start property looks in this the

423
00:18:21,720 --> 00:18:25,980
operating systems init to try and find a

424
00:18:25,980 --> 00:18:27,900
service and start

425
00:18:27,900 --> 00:18:29,760
so this was a little funny because we're

426
00:18:29,760 --> 00:18:32,100
running in a system app context

427
00:18:32,100 --> 00:18:35,100
at least on AOSP you know the Baseline

428
00:18:35,100 --> 00:18:38,160
open source version of Android

429
00:18:38,160 --> 00:18:41,340
apps can't call CTL start because it is

430
00:18:41,340 --> 00:18:43,500
a basic sort of aspect of the

431
00:18:43,500 --> 00:18:45,480
initializing services within the

432
00:18:45,480 --> 00:18:46,980
operating system

433
00:18:46,980 --> 00:18:51,240
so I ran SC search on the device to see

434
00:18:51,240 --> 00:18:54,480
huh how is this able to do it and lo and

435
00:18:54,480 --> 00:18:56,940
behold there was a whole lot more access

436
00:18:56,940 --> 00:19:00,419
to this CTL start property than what I

437
00:19:00,419 --> 00:19:03,059
was expecting and so including system

438
00:19:03,059 --> 00:19:07,140
app did in fact have permission to start

439
00:19:07,140 --> 00:19:09,179
and set the property and that was how

440
00:19:09,179 --> 00:19:11,640
the exploit was able to initiate a bug

441
00:19:11,640 --> 00:19:13,880
report

442
00:19:14,220 --> 00:19:16,679
so then I opened up dump state which is

443
00:19:16,679 --> 00:19:18,600
the binary that this bug report service

444
00:19:18,600 --> 00:19:21,120
would call dumpstate is an aspect of

445
00:19:21,120 --> 00:19:24,480
AOSP but it had been modified as a part

446
00:19:24,480 --> 00:19:27,480
of this Samsung device specifically for

447
00:19:27,480 --> 00:19:29,100
this line right here at the beginning of

448
00:19:29,100 --> 00:19:31,200
the dump State function which

449
00:19:31,200 --> 00:19:34,020
copied all of the contents from proc

450
00:19:34,020 --> 00:19:38,160
seclog to this file datalog seclog.log

451
00:19:38,160 --> 00:19:40,440
proc seclog is also a special

452
00:19:40,440 --> 00:19:42,559
customization for

453
00:19:42,559 --> 00:19:45,660
Samsung devices that have more sensitive

454
00:19:45,660 --> 00:19:49,740
security logs and usually apps would not

455
00:19:49,740 --> 00:19:51,600
be able to access contents like K

456
00:19:51,600 --> 00:19:53,940
message which is where things like worn

457
00:19:53,940 --> 00:19:57,179
on are usually lobbed but through proc

458
00:19:57,179 --> 00:20:00,240
seclog to data log seclog they did get

459
00:20:00,240 --> 00:20:01,440
access

460
00:20:01,440 --> 00:20:03,960
and so specifically here this was an

461
00:20:03,960 --> 00:20:06,840
example of the back Trace printed or

462
00:20:06,840 --> 00:20:09,360
logged whenever the worn on was hit

463
00:20:09,360 --> 00:20:12,600
we have in this raw stack contents our

464
00:20:12,600 --> 00:20:14,340
test struck address as well as assist

465
00:20:14,340 --> 00:20:16,740
call table address and so the exploit

466
00:20:16,740 --> 00:20:18,600
had hard-coded knowing that it was

467
00:20:18,600 --> 00:20:24,480
looking for the values at b60 and BC 0.

468
00:20:24,480 --> 00:20:26,820
so how did Samsung fix this first

469
00:20:26,820 --> 00:20:29,400
dumpstate no longer writes to seclog log

470
00:20:29,400 --> 00:20:31,140
log because the other thing was this

471
00:20:31,140 --> 00:20:35,299
seclog log had very permissive SE Linux

472
00:20:35,299 --> 00:20:37,679
permissions so that apps could widely

473
00:20:37,679 --> 00:20:40,740
read it they also removed this bug

474
00:20:40,740 --> 00:20:43,500
report service from dumpstate.rc because

475
00:20:43,500 --> 00:20:45,600
this service was a customization not

476
00:20:45,600 --> 00:20:49,260
found in as OSP but there also had been

477
00:20:49,260 --> 00:20:51,720
changes made in Upstream components that

478
00:20:51,720 --> 00:20:53,280
would prevent this type of vulnerability

479
00:20:53,280 --> 00:20:55,380
in the future so the first one had been

480
00:20:55,380 --> 00:20:59,100
in February 2020 arm Who develops the

481
00:20:59,100 --> 00:21:01,559
Mali GPU driver changed that warn on we

482
00:21:01,559 --> 00:21:05,039
were looking to a PR worn which is a

483
00:21:05,039 --> 00:21:07,860
much more appropriate sort of function

484
00:21:07,860 --> 00:21:10,200
or macro to have there because it does

485
00:21:10,200 --> 00:21:13,860
not print a full back trace and secondly

486
00:21:13,860 --> 00:21:17,039
in April 2020 Linux did remove printing

487
00:21:17,039 --> 00:21:19,799
the raw stacked contents in back traces

488
00:21:19,799 --> 00:21:23,340
for arm64 because they realized like

489
00:21:23,340 --> 00:21:25,620
this is sensitive and doesn't have a

490
00:21:25,620 --> 00:21:29,959
huge amount of actionable info

491
00:21:30,240 --> 00:21:32,700
now we get to our previous

492
00:21:32,700 --> 00:21:35,039
so along with the other two this was

493
00:21:35,039 --> 00:21:38,720
also patched in March 2021

494
00:21:39,900 --> 00:21:43,020
so here we are we're still running as

495
00:21:43,020 --> 00:21:46,799
our system app content context but we've

496
00:21:46,799 --> 00:21:48,659
linked two pieces of information from

497
00:21:48,659 --> 00:21:49,740
the kernel

498
00:21:49,740 --> 00:21:51,900
what now

499
00:21:51,900 --> 00:21:54,000
so the vulnerability is a use after free

500
00:21:54,000 --> 00:21:55,940
of the file struct

501
00:21:55,940 --> 00:21:59,100
and specifically it is in Samsung's

502
00:21:59,100 --> 00:22:01,080
version of a driver for the display

503
00:22:01,080 --> 00:22:03,720
Processing Unit which they called in an

504
00:22:03,720 --> 00:22:06,179
upstream commit Decon to Stanford

505
00:22:06,179 --> 00:22:09,299
display and enhancement controller is

506
00:22:09,299 --> 00:22:11,760
the new IP and exynos 7 sock for

507
00:22:11,760 --> 00:22:13,919
generating video signals using pixel

508
00:22:13,919 --> 00:22:15,780
data so that's what we're looking at

509
00:22:15,780 --> 00:22:17,600
that's where this use after free exists

510
00:22:17,600 --> 00:22:21,059
and so this use after free will be

511
00:22:21,059 --> 00:22:23,700
triggered again through an eye-octal in

512
00:22:23,700 --> 00:22:26,700
the Decon driver but first the exploit

513
00:22:26,700 --> 00:22:28,860
needs a file descriptor to be able to

514
00:22:28,860 --> 00:22:31,980
call an eye optyl on that driver and

515
00:22:31,980 --> 00:22:34,400
that's not as straightforward as a sound

516
00:22:34,400 --> 00:22:37,200
because the full path for this driver

517
00:22:37,200 --> 00:22:39,900
can live in many different places so

518
00:22:39,900 --> 00:22:42,659
what the exploit didn't know is that the

519
00:22:42,659 --> 00:22:46,799
path would include Graphics slash fb0 in

520
00:22:46,799 --> 00:22:49,140
the path but that leaves a whole lot of

521
00:22:49,140 --> 00:22:50,460
different options

522
00:22:50,460 --> 00:22:53,640
so instead to figure it out they've made

523
00:22:53,640 --> 00:22:55,260
a three-step approach

524
00:22:55,260 --> 00:22:57,600
first they wanted to find the paid of

525
00:22:57,600 --> 00:22:59,760
the process that's running that driver

526
00:22:59,760 --> 00:23:02,460
or find a pit of a process that they

527
00:23:02,460 --> 00:23:04,260
knew would be running that driver in

528
00:23:04,260 --> 00:23:06,179
this case that's the graphics composer

529
00:23:06,179 --> 00:23:07,919
process which is the Hardware's

530
00:23:07,919 --> 00:23:10,620
abstraction layer on Android devices for

531
00:23:10,620 --> 00:23:12,059
the graphics

532
00:23:12,059 --> 00:23:14,460
then they it once they find that PID

533
00:23:14,460 --> 00:23:16,500
they iterate through the processes file

534
00:23:16,500 --> 00:23:18,780
the script or table and using read link

535
00:23:18,780 --> 00:23:21,120
to find any of the full paths for each

536
00:23:21,120 --> 00:23:23,880
file descriptor that is open in that

537
00:23:23,880 --> 00:23:26,520
process and then finally they will use

538
00:23:26,520 --> 00:23:28,860
our vulnerability number one to open the

539
00:23:28,860 --> 00:23:31,020
FD again

540
00:23:31,020 --> 00:23:34,080
so first how do they find the PID so

541
00:23:34,080 --> 00:23:36,000
they actually connected to log reader

542
00:23:36,000 --> 00:23:37,380
which is one of the basic sort of

543
00:23:37,380 --> 00:23:39,600
Android operating systems that sort of

544
00:23:39,600 --> 00:23:42,539
you know controls logcat in a way so

545
00:23:42,539 --> 00:23:44,700
that's what it's similar to and so they

546
00:23:44,700 --> 00:23:47,340
connect to a socket via there say they

547
00:23:47,340 --> 00:23:49,320
want you know a whole bunch of logs

548
00:23:49,320 --> 00:23:51,120
including the system logs and the Crash

549
00:23:51,120 --> 00:23:54,299
logs and then they just wait and read

550
00:23:54,299 --> 00:23:57,120
and look for the term display

551
00:23:57,120 --> 00:23:59,400
and when they find the term display at

552
00:23:59,400 --> 00:24:01,020
the beginning of a logging message they

553
00:24:01,020 --> 00:24:03,720
then look at what PID was printed along

554
00:24:03,720 --> 00:24:05,580
with that term and that's how they find

555
00:24:05,580 --> 00:24:08,820
the PID of the graphics composer process

556
00:24:08,820 --> 00:24:10,980
so now we have a PID which means we can

557
00:24:10,980 --> 00:24:14,940
iterate through proc PID FD table and so

558
00:24:14,940 --> 00:24:16,740
they literally start at the beginning

559
00:24:16,740 --> 00:24:20,340
and open up each one called read link on

560
00:24:20,340 --> 00:24:23,340
it to see what the full path is check if

561
00:24:23,340 --> 00:24:26,880
that full path contains graphic fb0 once

562
00:24:26,880 --> 00:24:28,559
they found it that was the path they

563
00:24:28,559 --> 00:24:31,559
would then use with vulnerability number

564
00:24:31,559 --> 00:24:34,080
one to open a file descriptor to that

565
00:24:34,080 --> 00:24:38,960
path which is the Decon display driver

566
00:24:39,179 --> 00:24:42,059
so the use after free was also a pretty

567
00:24:42,059 --> 00:24:44,460
common pattern that we have seen amongst

568
00:24:44,460 --> 00:24:46,559
Colonel drivers before

569
00:24:46,559 --> 00:24:50,340
so first the driver required acquires a

570
00:24:50,340 --> 00:24:53,700
file descriptor an FD for a fence we

571
00:24:53,700 --> 00:24:54,720
don't really need to know all about

572
00:24:54,720 --> 00:24:57,299
fence internals but the basics is is

573
00:24:57,299 --> 00:25:00,059
that a fence is used in kernel drivers

574
00:25:00,059 --> 00:25:02,520
for sharing buffers and synchronizing

575
00:25:02,520 --> 00:25:04,320
access between different drivers or

576
00:25:04,320 --> 00:25:05,700
processes

577
00:25:05,700 --> 00:25:09,059
so first it's going to acquire that FD

578
00:25:09,059 --> 00:25:12,179
and then it's going to associate that FD

579
00:25:12,179 --> 00:25:14,940
with a file struct in this case it's

580
00:25:14,940 --> 00:25:17,940
sync file in the file pointer member of

581
00:25:17,940 --> 00:25:19,679
that

582
00:25:19,679 --> 00:25:21,480
then the driver is going to call FD

583
00:25:21,480 --> 00:25:22,620
install

584
00:25:22,620 --> 00:25:26,419
FD install makes a file descriptor

585
00:25:26,419 --> 00:25:29,940
accessible from user space so before we

586
00:25:29,940 --> 00:25:32,220
were just sort of access all operating

587
00:25:32,220 --> 00:25:34,500
in the kernel so now the driver has said

588
00:25:34,500 --> 00:25:37,320
hey userspace you can do operations on

589
00:25:37,320 --> 00:25:39,539
this FD now too

590
00:25:39,539 --> 00:25:42,299
and when FD install is called it

591
00:25:42,299 --> 00:25:44,760
transfers the ownership of the reference

592
00:25:44,760 --> 00:25:47,039
to the FD table

593
00:25:47,039 --> 00:25:49,799
so in this case if the driver had the

594
00:25:49,799 --> 00:25:51,600
only reference to the file struck that

595
00:25:51,600 --> 00:25:53,820
it's associating here and passes it to

596
00:25:53,820 --> 00:25:55,380
the FD table

597
00:25:55,380 --> 00:25:58,679
and user oh I'm jumping ahead and the

598
00:25:58,679 --> 00:26:00,779
user calls close

599
00:26:00,779 --> 00:26:04,559
then that closes the only reference or

600
00:26:04,559 --> 00:26:07,320
freeze closes the only reference on that

601
00:26:07,320 --> 00:26:11,700
file struct in the file struct is freed

602
00:26:11,700 --> 00:26:14,279
but the driver does not realize that and

603
00:26:14,279 --> 00:26:16,520
assume that that file strict is still

604
00:26:16,520 --> 00:26:19,919
accessible and legitimate and will

605
00:26:19,919 --> 00:26:21,840
continue to access it and that's how we

606
00:26:21,840 --> 00:26:24,600
got our use after free

607
00:26:24,600 --> 00:26:26,700
so specifically in this case looking at

608
00:26:26,700 --> 00:26:28,500
the code from the driver we have this

609
00:26:28,500 --> 00:26:31,440
function Decon set when config which is

610
00:26:31,440 --> 00:26:33,960
accessible via an eye-optal so the first

611
00:26:33,960 --> 00:26:35,520
thing it does in this highlighted

612
00:26:35,520 --> 00:26:38,520
portion is it calls deconcreate fence

613
00:26:38,520 --> 00:26:40,500
which is going to acquire that file

614
00:26:40,500 --> 00:26:43,140
descriptor for us and assign it to

615
00:26:43,140 --> 00:26:44,940
retired fence so I know it might not

616
00:26:44,940 --> 00:26:47,760
sound like it if you haven't but retire

617
00:26:47,760 --> 00:26:51,539
fence is actually the file descriptor

618
00:26:51,539 --> 00:26:53,820
then we're going to call FD install so

619
00:26:53,820 --> 00:26:56,279
we're saying hey you can associate

620
00:26:56,279 --> 00:26:59,640
retire fence FD with this file pointer

621
00:26:59,640 --> 00:27:02,159
in the sync file struct

622
00:27:02,159 --> 00:27:03,960
or yeah

623
00:27:03,960 --> 00:27:05,820
and then we call deconcreate release

624
00:27:05,820 --> 00:27:09,419
fences with that same sync file

625
00:27:09,419 --> 00:27:10,700
and

626
00:27:10,700 --> 00:27:15,360
sync Decon create release fences will

627
00:27:15,360 --> 00:27:18,000
acquire its own FD and assign that to

628
00:27:18,000 --> 00:27:19,919
relfits

629
00:27:19,919 --> 00:27:23,220
and then it calls FD install this time

630
00:27:23,220 --> 00:27:24,600
though they do take an additional

631
00:27:24,600 --> 00:27:26,880
reference out using that git file but

632
00:27:26,880 --> 00:27:28,799
they're using that same file pointer

633
00:27:28,799 --> 00:27:31,919
again the one that was just freed by

634
00:27:31,919 --> 00:27:33,659
user space

635
00:27:33,659 --> 00:27:36,720
so at the end of the concept Wing config

636
00:27:36,720 --> 00:27:40,320
we have two fds retire fence which is

637
00:27:40,320 --> 00:27:42,299
the closed FD that pointed to our free

638
00:27:42,299 --> 00:27:46,020
file struct and Rel fence which is an

639
00:27:46,020 --> 00:27:47,940
open FD with an additional reference

640
00:27:47,940 --> 00:27:51,240
taken on it but still to our freed file

641
00:27:51,240 --> 00:27:54,779
struct so that's our use after free

642
00:27:54,779 --> 00:27:57,120
so the exploit strategy of that use

643
00:27:57,120 --> 00:28:00,659
after free that was taken was that we're

644
00:28:00,659 --> 00:28:03,539
gonna or the exploit replaces the freed

645
00:28:03,539 --> 00:28:05,820
file struct with a newly controlled file

646
00:28:05,820 --> 00:28:07,740
stuff you know one that they fake and

647
00:28:07,740 --> 00:28:10,140
create and set different members of

648
00:28:10,140 --> 00:28:12,120
they're going to set the private data

649
00:28:12,120 --> 00:28:14,279
member that's within that file struct to

650
00:28:14,279 --> 00:28:15,960
point to the adder limit

651
00:28:15,960 --> 00:28:19,260
we're going to then use signal FD to

652
00:28:19,260 --> 00:28:21,120
modify the adder limit and that's how

653
00:28:21,120 --> 00:28:23,279
it's going to gain arbitrary kernel read

654
00:28:23,279 --> 00:28:25,559
and write so that's the overview of what

655
00:28:25,559 --> 00:28:27,059
we're about to cover now I'm going to

656
00:28:27,059 --> 00:28:28,559
get into the details of what that means

657
00:28:28,559 --> 00:28:31,020
and what it looks like in this case

658
00:28:31,020 --> 00:28:33,120
so to back up what is the adder limit

659
00:28:33,120 --> 00:28:35,279
it's the address limit as I said before

660
00:28:35,279 --> 00:28:36,900
it's a part of that member of the task

661
00:28:36,900 --> 00:28:41,220
truck and it sets what is user space or

662
00:28:41,220 --> 00:28:43,679
user space is able to write to any

663
00:28:43,679 --> 00:28:46,260
address below the adder limit so when

664
00:28:46,260 --> 00:28:49,200
we're in user space you know that's

665
00:28:49,200 --> 00:28:51,059
usually user DS

666
00:28:51,059 --> 00:28:54,419
which is set to seven ffff

667
00:28:54,419 --> 00:28:57,539
for arm 64. and then for kernel it's set

668
00:28:57,539 --> 00:29:00,120
to negative one here being you know the

669
00:29:00,120 --> 00:29:01,860
highest value so the kernel should have

670
00:29:01,860 --> 00:29:04,879
access across the board

671
00:29:05,159 --> 00:29:07,320
signal FD which we're going to use to

672
00:29:07,320 --> 00:29:11,039
write that outer limit is a syscall

673
00:29:11,039 --> 00:29:13,200
um that usually is for creating a file

674
00:29:13,200 --> 00:29:15,240
descriptor if you want to Monitor and

675
00:29:15,240 --> 00:29:16,799
accept different signals that are being

676
00:29:16,799 --> 00:29:19,020
sent to your process

677
00:29:19,020 --> 00:29:21,360
and but the key here is that we're not

678
00:29:21,360 --> 00:29:25,200
actually going to open it on and ask it

679
00:29:25,200 --> 00:29:27,659
to open a new file descriptor we're

680
00:29:27,659 --> 00:29:29,880
going to call this on one of these fake

681
00:29:29,880 --> 00:29:31,500
ones that we create

682
00:29:31,500 --> 00:29:33,600
and when that happens it only updates

683
00:29:33,600 --> 00:29:35,880
the eight byte mask

684
00:29:35,880 --> 00:29:39,659
oh yes see I really emphasize that

685
00:29:39,659 --> 00:29:43,200
so this is the signal FD function from

686
00:29:43,200 --> 00:29:46,620
this kernel and the key Point here first

687
00:29:46,620 --> 00:29:49,919
is that the syscall expects you to pass

688
00:29:49,919 --> 00:29:53,419
a mask of the signals you want to accept

689
00:29:53,419 --> 00:29:56,640
but the kernel stores masks as the

690
00:29:56,640 --> 00:29:59,760
signals that should be blocked so if

691
00:29:59,760 --> 00:30:02,039
you're first say using this later on

692
00:30:02,039 --> 00:30:05,039
just keep in mind that first it will

693
00:30:05,039 --> 00:30:07,860
mask out the Sig Hill and the six stop

694
00:30:07,860 --> 00:30:11,039
bits but then it's an inverse so when we

695
00:30:11,039 --> 00:30:14,539
want to have negative one or ffff

696
00:30:14,539 --> 00:30:17,039
written to the address limit we will

697
00:30:17,039 --> 00:30:19,440
actually pass zero into the signal FD

698
00:30:19,440 --> 00:30:23,279
because of this flipping

699
00:30:23,279 --> 00:30:26,399
then there is this Branch where if you

700
00:30:26,399 --> 00:30:28,140
pass in a file descriptor of negative

701
00:30:28,140 --> 00:30:30,840
one you're telling it to open up a new

702
00:30:30,840 --> 00:30:32,820
file descriptor and create a signal FD

703
00:30:32,820 --> 00:30:35,399
file descriptor but we're going to

704
00:30:35,399 --> 00:30:38,700
follow this else Branch here

705
00:30:38,700 --> 00:30:42,179
so first off a part of this signal FD is

706
00:30:42,179 --> 00:30:45,440
it has this struct signal FD context CTX

707
00:30:45,440 --> 00:30:48,659
CTX is a pointer to a signal FD context

708
00:30:48,659 --> 00:30:51,419
struct which only has one member which

709
00:30:51,419 --> 00:30:54,299
is the Sig mask which six set T is also

710
00:30:54,299 --> 00:30:55,799
an unsigned long

711
00:30:55,799 --> 00:30:58,020
to keep in mind so we're going to set

712
00:30:58,020 --> 00:31:00,960
that to our private data member of the

713
00:31:00,960 --> 00:31:04,500
of the file struct for the FD that is

714
00:31:04,500 --> 00:31:07,200
passed into the syscall

715
00:31:07,200 --> 00:31:09,899
the man page says that whenever you use

716
00:31:09,899 --> 00:31:12,360
signal FD and you're going to specify

717
00:31:12,360 --> 00:31:14,700
your own file descriptor but it must be

718
00:31:14,700 --> 00:31:19,320
a an existing and valid signal FD file

719
00:31:19,320 --> 00:31:21,600
descriptor the only check for that is

720
00:31:21,600 --> 00:31:24,120
checking if the F member of the file

721
00:31:24,120 --> 00:31:27,600
struct equals signal FDF Ops so that is

722
00:31:27,600 --> 00:31:29,039
something we can get around with our

723
00:31:29,039 --> 00:31:31,500
fake dropped

724
00:31:31,500 --> 00:31:34,679
lastly this is where we do our right so

725
00:31:34,679 --> 00:31:37,679
we're going to set the context Sig mask

726
00:31:37,679 --> 00:31:40,799
Into the Now knotted mass that was

727
00:31:40,799 --> 00:31:42,779
passed into signal FD

728
00:31:42,779 --> 00:31:46,020
but because we set context to the

729
00:31:46,020 --> 00:31:48,659
private data this is equivalent to us

730
00:31:48,659 --> 00:31:52,080
saying file private data Sig mask

731
00:31:52,080 --> 00:31:54,840
equals Sig mask

732
00:31:54,840 --> 00:31:57,299
which we will get to in a minute here of

733
00:31:57,299 --> 00:32:00,600
why that's interesting so these are the

734
00:32:00,600 --> 00:32:03,260
different members set in the

735
00:32:03,260 --> 00:32:05,460
exploits fake file strikes that they

736
00:32:05,460 --> 00:32:07,320
sprayed all over the Heap to get their

737
00:32:07,320 --> 00:32:10,440
replacement the first one wasn't really

738
00:32:10,440 --> 00:32:12,179
used I think they were just using it for

739
00:32:12,179 --> 00:32:14,220
maybe identifying their own file structs

740
00:32:14,220 --> 00:32:16,260
the second one is we're using the

741
00:32:16,260 --> 00:32:18,840
syscall table to calculate signal FD

742
00:32:18,840 --> 00:32:21,600
epops so that we can pass that check we

743
00:32:21,600 --> 00:32:22,860
just talked about

744
00:32:22,860 --> 00:32:26,399
then they use 7f as a reference count

745
00:32:26,399 --> 00:32:28,679
and that's basically being used to

746
00:32:28,679 --> 00:32:30,860
identify when they have successfully

747
00:32:30,860 --> 00:32:34,380
replaced the freed object

748
00:32:34,380 --> 00:32:35,700
um unfortunately there was not enough

749
00:32:35,700 --> 00:32:37,200
time to get into this but there will be

750
00:32:37,200 --> 00:32:39,000
a blog post published later this week if

751
00:32:39,000 --> 00:32:40,559
you're interested in the internals of

752
00:32:40,559 --> 00:32:42,419
the Heap spray and how they do the

753
00:32:42,419 --> 00:32:43,500
replacement

754
00:32:43,500 --> 00:32:46,020
and then finally they set private data

755
00:32:46,020 --> 00:32:48,600
to at our limit pointer

756
00:32:48,600 --> 00:32:52,080
oh okay I forgot

757
00:32:52,080 --> 00:32:55,919
so since now private data equals the at

758
00:32:55,919 --> 00:32:57,480
our limit pointer

759
00:32:57,480 --> 00:33:01,080
that means that when signal FD updates

760
00:33:01,080 --> 00:33:03,899
the Sig mask we're actually overwriting

761
00:33:03,899 --> 00:33:07,500
the outer limit so we have this pretty

762
00:33:07,500 --> 00:33:09,960
strong primitive now or the exploit does

763
00:33:09,960 --> 00:33:15,299
of a repeatable stable right to the

764
00:33:15,299 --> 00:33:17,100
address limit

765
00:33:17,100 --> 00:33:19,500
but not so fast it's not done we can't

766
00:33:19,500 --> 00:33:21,480
just say great we have arbitrary kernel

767
00:33:21,480 --> 00:33:23,519
read write done because there have been

768
00:33:23,519 --> 00:33:27,059
two mitigations added to Armed CPUs and

769
00:33:27,059 --> 00:33:29,700
most modern Android devices now use the

770
00:33:29,700 --> 00:33:31,919
rv8 CPUs which include these exploit

771
00:33:31,919 --> 00:33:34,620
mitigations called user access override

772
00:33:34,620 --> 00:33:38,000
and privilege access never uao and pan

773
00:33:38,000 --> 00:33:41,720
so pan protects against the kernel

774
00:33:41,720 --> 00:33:44,880
accessing direct directly accessing user

775
00:33:44,880 --> 00:33:46,140
space memory

776
00:33:46,140 --> 00:33:50,039
whereas user access override works with

777
00:33:50,039 --> 00:33:52,159
pan by

778
00:33:52,159 --> 00:33:55,080
allowing unprivileged load and store

779
00:33:55,080 --> 00:33:58,260
instructions to act as privilege load

780
00:33:58,260 --> 00:34:00,539
and store instructions when the uao bit

781
00:34:00,539 --> 00:34:02,580
is set we'll talk about what this looks

782
00:34:02,580 --> 00:34:05,039
like in practice now

783
00:34:05,039 --> 00:34:07,140
so this is an example kernel write

784
00:34:07,140 --> 00:34:09,300
function that myself and Jana horn used

785
00:34:09,300 --> 00:34:13,619
in an Android exploit from 2019.

786
00:34:13,619 --> 00:34:16,500
and so the way that before uao and pan

787
00:34:16,500 --> 00:34:18,300
that you could do this arbitrary kernel

788
00:34:18,300 --> 00:34:21,239
read and write is you open up a pair of

789
00:34:21,239 --> 00:34:22,260
pipes

790
00:34:22,260 --> 00:34:24,239
to do a kernel write for example you

791
00:34:24,239 --> 00:34:27,179
would write the address of the buffer of

792
00:34:27,179 --> 00:34:28,679
the content you wanted right written

793
00:34:28,679 --> 00:34:31,260
into the kernel to one end of it and you

794
00:34:31,260 --> 00:34:34,020
would read it into the into the kernel

795
00:34:34,020 --> 00:34:35,940
address that you wanted to write to on

796
00:34:35,940 --> 00:34:37,139
the other end

797
00:34:37,139 --> 00:34:39,599
so the reason why this no longer works

798
00:34:39,599 --> 00:34:43,080
is first if pan is enabled because at

799
00:34:43,080 --> 00:34:45,300
our limit is set to Kernel DS

800
00:34:45,300 --> 00:34:49,440
then we cannot do this right because its

801
00:34:49,440 --> 00:34:51,839
buff is in user space memory and

802
00:34:51,839 --> 00:34:54,560
privileged access never permit

803
00:34:54,560 --> 00:34:57,480
prevents the direct access to user space

804
00:34:57,480 --> 00:35:00,660
memory but let's say we set kernel DS to

805
00:35:00,660 --> 00:35:02,400
something else so pan wouldn't be on

806
00:35:02,400 --> 00:35:05,900
that's when uao comes into play

807
00:35:05,900 --> 00:35:11,460
uao will not be set if kernel DS doesn't

808
00:35:11,460 --> 00:35:13,500
equal or if the outer limit does not

809
00:35:13,500 --> 00:35:16,079
equal kernel DS so then this call will

810
00:35:16,079 --> 00:35:17,700
fail because we're trying to access

811
00:35:17,700 --> 00:35:21,420
kernel memory with unprivileged load and

812
00:35:21,420 --> 00:35:24,359
store instructions

813
00:35:24,359 --> 00:35:26,940
so this is what the exploit did

814
00:35:26,940 --> 00:35:28,920
basically they just switched the outer

815
00:35:28,920 --> 00:35:30,960
limit back and forth between user DS and

816
00:35:30,960 --> 00:35:34,140
kernel DS so I don't really call this a

817
00:35:34,140 --> 00:35:35,820
bypass because they're just working

818
00:35:35,820 --> 00:35:38,579
within the way uao and pan are supposed

819
00:35:38,579 --> 00:35:42,240
to work so walking through this

820
00:35:42,240 --> 00:35:44,700
first we have two rights to one end of

821
00:35:44,700 --> 00:35:47,160
the buffer it's the buffer we want to

822
00:35:47,160 --> 00:35:49,859
write into the kernel as well as a

823
00:35:49,859 --> 00:35:52,380
pointer to the user yes value

824
00:35:52,380 --> 00:35:54,660
then it cause this function set at our

825
00:35:54,660 --> 00:35:57,420
limit to Kernel DS which sends a signal

826
00:35:57,420 --> 00:35:59,640
to another process in the exploit to

827
00:35:59,640 --> 00:36:02,060
tell to do the whole signal FD

828
00:36:02,060 --> 00:36:04,560
process to send the adder limit to

829
00:36:04,560 --> 00:36:05,880
Kernel DS

830
00:36:05,880 --> 00:36:07,680
it then does a little bit of a sleep in

831
00:36:07,680 --> 00:36:09,660
there to wait to make sure that that set

832
00:36:09,660 --> 00:36:12,300
occurs and then it can move on to the

833
00:36:12,300 --> 00:36:15,780
Reeds so now that we're in kernel DS it

834
00:36:15,780 --> 00:36:17,460
will read the contents from the other

835
00:36:17,460 --> 00:36:19,740
end of the pipe into the kernel address

836
00:36:19,740 --> 00:36:22,920
and now it's done it's kernel right

837
00:36:22,920 --> 00:36:25,500
and so it will then set everything back

838
00:36:25,500 --> 00:36:27,420
to user DS so that it always enters

839
00:36:27,420 --> 00:36:30,000
these functions as user DS reading back

840
00:36:30,000 --> 00:36:32,660
to that pointer

841
00:36:32,880 --> 00:36:35,400
so I think this is especially really

842
00:36:35,400 --> 00:36:37,619
interesting just because yeah they

843
00:36:37,619 --> 00:36:40,680
didn't need a bypass for ual or pan

844
00:36:40,680 --> 00:36:43,079
because it the Primitive was so strong

845
00:36:43,079 --> 00:36:45,540
for the outer limit that it just sort of

846
00:36:45,540 --> 00:36:48,240
works exactly with uao and pan toggling

847
00:36:48,240 --> 00:36:50,339
that Adder limit back and forth they

848
00:36:50,339 --> 00:36:52,440
didn't have to use set FS which is

849
00:36:52,440 --> 00:36:54,599
usually the function that folks will use

850
00:36:54,599 --> 00:36:57,660
to change the adder limit and but set FS

851
00:36:57,660 --> 00:36:59,880
includes mitigations of like making sure

852
00:36:59,880 --> 00:37:01,680
that

853
00:37:01,680 --> 00:37:02,400
um

854
00:37:02,400 --> 00:37:05,339
that at our limit is set back to a user

855
00:37:05,339 --> 00:37:07,260
space address when returning to user

856
00:37:07,260 --> 00:37:09,420
space and things like that so the the

857
00:37:09,420 --> 00:37:11,640
Primitive that they got really is what

858
00:37:11,640 --> 00:37:14,220
enabled them to get around uao and pan

859
00:37:14,220 --> 00:37:18,500
without really having to bypass anything

860
00:37:18,599 --> 00:37:21,599
post-exploitation

861
00:37:21,900 --> 00:37:24,599
so they've gotten their arbitrary kernel

862
00:37:24,599 --> 00:37:27,300
read and write what do they do to root

863
00:37:27,300 --> 00:37:29,400
honestly it's pretty boring

864
00:37:29,400 --> 00:37:31,859
they follow exactly what we've seen many

865
00:37:31,859 --> 00:37:34,980
many Android exploits do for years is

866
00:37:34,980 --> 00:37:36,599
they overwrite the current processes

867
00:37:36,599 --> 00:37:40,200
cred struct to get root privileges and

868
00:37:40,200 --> 00:37:42,119
then they overwrite the current SC Linux

869
00:37:42,119 --> 00:37:44,640
context to voldi where Vol D is the

870
00:37:44,640 --> 00:37:47,579
volume Daemon and while it is a user

871
00:37:47,579 --> 00:37:50,760
space process even in Android's

872
00:37:50,760 --> 00:37:52,500
documentation of sort of security

873
00:37:52,500 --> 00:37:54,480
boundaries they treat it as if it's

874
00:37:54,480 --> 00:37:58,560
kernel because it has a lot of access

875
00:37:58,560 --> 00:38:01,200
um unfortunately this sample did not

876
00:38:01,200 --> 00:38:03,599
include the final payloaded implant but

877
00:38:03,599 --> 00:38:07,320
based on it being attributed or believed

878
00:38:07,320 --> 00:38:08,400
to be associated with a commercial

879
00:38:08,400 --> 00:38:10,680
surveillance vendor I'm guessing it

880
00:38:10,680 --> 00:38:12,980
would likely look like the surveillance

881
00:38:12,980 --> 00:38:16,320
spyware that has been we've been seeing

882
00:38:16,320 --> 00:38:19,619
over and over again

883
00:38:19,619 --> 00:38:21,900
so final thoughts

884
00:38:21,900 --> 00:38:23,160
first

885
00:38:23,160 --> 00:38:26,040
I think as much as we can see and talk

886
00:38:26,040 --> 00:38:28,140
about and publish about these real world

887
00:38:28,140 --> 00:38:30,780
examples of what attackers are doing is

888
00:38:30,780 --> 00:38:33,060
really important because it helps us

889
00:38:33,060 --> 00:38:36,180
know as Defenders where what is the best

890
00:38:36,180 --> 00:38:39,660
return on investment in terms of

891
00:38:39,660 --> 00:38:40,260
um

892
00:38:40,260 --> 00:38:42,780
where we want to put resources is it

893
00:38:42,780 --> 00:38:44,460
different fuzzing are there attack

894
00:38:44,460 --> 00:38:47,339
surfaces that are being exploited that

895
00:38:47,339 --> 00:38:50,640
maybe we need to focus on more are there

896
00:38:50,640 --> 00:38:53,760
are mitigations that are not holding up

897
00:38:53,760 --> 00:38:56,099
and need changes to them and things like

898
00:38:56,099 --> 00:38:58,859
that so I think this is important in

899
00:38:58,859 --> 00:39:00,000
that way

900
00:39:00,000 --> 00:39:01,200
but

901
00:39:01,200 --> 00:39:04,920
Earth and of those considerations of the

902
00:39:04,920 --> 00:39:07,380
real world Tucker to me some of the most

903
00:39:07,380 --> 00:39:10,140
notable is the example of

904
00:39:10,140 --> 00:39:12,420
only targeting manufactured specific

905
00:39:12,420 --> 00:39:15,119
components this is what we generally

906
00:39:15,119 --> 00:39:17,339
assumed was happening this is what we've

907
00:39:17,339 --> 00:39:19,200
heard anecdotally especially with the

908
00:39:19,200 --> 00:39:21,300
increase in fragmentation across the

909
00:39:21,300 --> 00:39:23,460
Android ecosystem but it's always good

910
00:39:23,460 --> 00:39:26,940
to have that tangible example and in

911
00:39:26,940 --> 00:39:29,820
this case also seeing that two out of

912
00:39:29,820 --> 00:39:32,700
the three bugs are logic bugs there's

913
00:39:32,700 --> 00:39:34,740
been so much focus on memory corruption

914
00:39:34,740 --> 00:39:36,720
which I think is rightly so like memory

915
00:39:36,720 --> 00:39:39,839
corruption is largely how all of the

916
00:39:39,839 --> 00:39:41,940
zero days are happening right now you

917
00:39:41,940 --> 00:39:45,060
know I think it was like 67 last year

918
00:39:45,060 --> 00:39:47,339
but it's important to remember that we

919
00:39:47,339 --> 00:39:48,780
can't just say hey write everything in

920
00:39:48,780 --> 00:39:50,640
memory safe languages and things are

921
00:39:50,640 --> 00:39:52,320
done from there

922
00:39:52,320 --> 00:39:55,320
lastly remembering that Java components

923
00:39:55,320 --> 00:39:59,000
are really good attack surface

924
00:40:00,119 --> 00:40:02,520
but overall a lot of times when people

925
00:40:02,520 --> 00:40:04,260
write about in the wild exploits and

926
00:40:04,260 --> 00:40:05,880
zero days they're like most

927
00:40:05,880 --> 00:40:08,960
sophisticated ever great attacker like

928
00:40:08,960 --> 00:40:11,640
mind-boggling amazing

929
00:40:11,640 --> 00:40:14,460
but really this exploit's pretty man

930
00:40:14,460 --> 00:40:16,200
it's using a lot of techniques that

931
00:40:16,200 --> 00:40:18,599
we've seen in public work before

932
00:40:18,599 --> 00:40:21,420
none of the vulnerabilities were all

933
00:40:21,420 --> 00:40:22,800
that awesome

934
00:40:22,800 --> 00:40:24,900
and that comes back to us as attackers

935
00:40:24,900 --> 00:40:27,859
because

936
00:40:27,859 --> 00:40:32,060
attackers are having success with meh

937
00:40:32,060 --> 00:40:35,820
types of exploits and so even if we

938
00:40:35,820 --> 00:40:37,859
readjust our mind to oh this was found

939
00:40:37,859 --> 00:40:41,640
in zero day two years ago still even in

940
00:40:41,640 --> 00:40:43,079
that concept

941
00:40:43,079 --> 00:40:45,960
even in that context these techniques

942
00:40:45,960 --> 00:40:50,000
weren't were in use long before that

943
00:40:50,579 --> 00:40:52,800
and this also highlights to me another

944
00:40:52,800 --> 00:40:54,780
thing to keep in mind is transparency

945
00:40:54,780 --> 00:40:56,820
around these in the wild

946
00:40:56,820 --> 00:40:58,740
um zero days and it is something I have

947
00:40:58,740 --> 00:41:00,780
been talking about many many times over

948
00:41:00,780 --> 00:41:02,339
and over for the last few years of

949
00:41:02,339 --> 00:41:05,220
studying these because knowing what zero

950
00:41:05,220 --> 00:41:06,960
days are being actively exploited and

951
00:41:06,960 --> 00:41:09,359
knowing the exploit techniques are in

952
00:41:09,359 --> 00:41:11,579
use is how we can really then make

953
00:41:11,579 --> 00:41:13,619
decisions of what types of steps to take

954
00:41:13,619 --> 00:41:16,079
next so for example performing root

955
00:41:16,079 --> 00:41:18,540
cause analysis to figure out what bugs

956
00:41:18,540 --> 00:41:21,300
are the attackers going after performing

957
00:41:21,300 --> 00:41:23,160
variant analysis to see are there

958
00:41:23,160 --> 00:41:24,839
additional bugs that the attackers

959
00:41:24,839 --> 00:41:26,940
likely know about that the vendor only

960
00:41:26,940 --> 00:41:28,440
fixed one of

961
00:41:28,440 --> 00:41:30,420
doing patch analysis to see if the

962
00:41:30,420 --> 00:41:32,520
patches are actually sufficient what

963
00:41:32,520 --> 00:41:34,079
types of detection techniques should we

964
00:41:34,079 --> 00:41:36,000
invest in that may actually work because

965
00:41:36,000 --> 00:41:38,040
the testing zero days is hard when

966
00:41:38,040 --> 00:41:39,300
you're trying to detect something you

967
00:41:39,300 --> 00:41:40,859
don't know what it looks like

968
00:41:40,859 --> 00:41:42,420
lastly

969
00:41:42,420 --> 00:41:44,280
it's not the end of the game when you

970
00:41:44,280 --> 00:41:46,619
patch a vulnerability a vulnerability is

971
00:41:46,619 --> 00:41:49,260
only useful if you can exploit it so

972
00:41:49,260 --> 00:41:50,940
looking at exploit techniques how could

973
00:41:50,940 --> 00:41:52,500
you block that and make sure they have

974
00:41:52,500 --> 00:41:54,599
to come up with a new one instead of

975
00:41:54,599 --> 00:41:56,160
being able to plug and play with a new

976
00:41:56,160 --> 00:41:58,619
vulnerability and other hardening and

977
00:41:58,619 --> 00:42:00,839
systemic improvements

978
00:42:00,839 --> 00:42:05,400
and so all of that uh oh I think I lost

979
00:42:05,400 --> 00:42:07,740
one oh I meant to say it somewhere else

980
00:42:07,740 --> 00:42:09,660
oh it was in the mess section we can go

981
00:42:09,660 --> 00:42:11,760
back to meh

982
00:42:11,760 --> 00:42:14,339
um one thing that was interesting about

983
00:42:14,339 --> 00:42:16,440
this exploit as well and especially

984
00:42:16,440 --> 00:42:19,680
focusing on the Java components is that

985
00:42:19,680 --> 00:42:21,720
they probably could have written this

986
00:42:21,720 --> 00:42:23,940
exploit to only have to depend on that

987
00:42:23,940 --> 00:42:25,560
first clipboard bug

988
00:42:25,560 --> 00:42:29,579
that had system server arbitrary file

989
00:42:29,579 --> 00:42:34,020
um file system access and so maybe they

990
00:42:34,020 --> 00:42:35,820
didn't because they had this other other

991
00:42:35,820 --> 00:42:38,520
infrastructure expecting kernel read and

992
00:42:38,520 --> 00:42:40,380
write or something for the payload

993
00:42:40,380 --> 00:42:43,020
but that really highlights to me how it

994
00:42:43,020 --> 00:42:44,700
may be very worthwhile to do more

995
00:42:44,700 --> 00:42:46,500
looking at these custom components and

996
00:42:46,500 --> 00:42:48,540
things like system server

997
00:42:48,540 --> 00:42:49,859
um even when they're Java and you're

998
00:42:49,859 --> 00:42:51,119
thinking there's not going to be Memory

999
00:42:51,119 --> 00:42:53,160
corruption because

1000
00:42:53,160 --> 00:42:55,800
yeah there's probably more they're

1001
00:42:55,800 --> 00:42:56,940
probably could have been some pretty

1002
00:42:56,940 --> 00:42:59,160
interesting ways to just leverage that

1003
00:42:59,160 --> 00:43:00,720
single vulnerability

1004
00:43:00,720 --> 00:43:03,500
um to meet their goal

1005
00:43:03,839 --> 00:43:06,720
and yeah so my goal is always to try and

1006
00:43:06,720 --> 00:43:09,000
learn from these zero days and I'm

1007
00:43:09,000 --> 00:43:12,300
always happy to chat and talk about zero

1008
00:43:12,300 --> 00:43:15,420
days on and on and on so I'm at Maddie

1009
00:43:15,420 --> 00:43:18,180
stone at Twitter or we have this email

1010
00:43:18,180 --> 00:43:19,220
address

1011
00:43:19,220 --> 00:43:22,680
for things and I keep a public tracking

1012
00:43:22,680 --> 00:43:24,420
spreadsheet of zero days in the wild as

1013
00:43:24,420 --> 00:43:27,119
well as we have a private not private

1014
00:43:27,119 --> 00:43:30,180
public repository of root cause analyzes

1015
00:43:30,180 --> 00:43:32,819
for that we're trying to cover all the

1016
00:43:32,819 --> 00:43:34,740
in the wild zero days but there tend to

1017
00:43:34,740 --> 00:43:36,300
be a lot more than there used to be when

1018
00:43:36,300 --> 00:43:37,819
I started that goal of covering them all

1019
00:43:37,819 --> 00:43:41,520
so yeah we also accept pull requests and

1020
00:43:41,520 --> 00:43:45,079
that's it thank you any questions

1021
00:43:45,180 --> 00:43:48,180
Guerrero

1022
00:43:49,820 --> 00:43:53,329
[Applause]

1023
00:44:08,880 --> 00:44:11,660
Savi

1024
00:44:13,560 --> 00:44:15,060
question

1025
00:44:15,060 --> 00:44:18,440
yes oh okay

1026
00:44:18,780 --> 00:44:22,260
so from what you described it seems that

1027
00:44:22,260 --> 00:44:23,480
this

1028
00:44:23,480 --> 00:44:26,280
exploit or the chain of exploits or the

1029
00:44:26,280 --> 00:44:31,099
overall program it's a quite reliable

1030
00:44:31,099 --> 00:44:35,160
meaning it works all the time so it's a

1031
00:44:35,160 --> 00:44:36,780
hundred percent reliability it doesn't

1032
00:44:36,780 --> 00:44:40,859
depend on uh but there's a uh user after

1033
00:44:40,859 --> 00:44:43,980
free maybe but it doesn't

1034
00:44:43,980 --> 00:44:45,900
the mitigations the current mitigations

1035
00:44:45,900 --> 00:44:49,319
do not seem to have made any dent

1036
00:44:49,319 --> 00:44:51,420
all right is it do you have any

1037
00:44:51,420 --> 00:44:53,339
reliability

1038
00:44:53,339 --> 00:44:55,800
um considerations or numbers or metrics

1039
00:44:55,800 --> 00:44:57,480
about this

1040
00:44:57,480 --> 00:44:59,040
um

1041
00:44:59,040 --> 00:45:01,880
so the question is are there

1042
00:45:01,880 --> 00:45:04,680
do you think or have you measure if this

1043
00:45:04,680 --> 00:45:07,380
exploit worked all the time 100 each

1044
00:45:07,380 --> 00:45:09,480
time you run it

1045
00:45:09,480 --> 00:45:11,599
um

1046
00:45:11,700 --> 00:45:14,220
I do not have metrics I do believe it

1047
00:45:14,220 --> 00:45:16,260
would be pretty reliable because each of

1048
00:45:16,260 --> 00:45:18,420
the pieces of it as long as you know

1049
00:45:18,420 --> 00:45:21,000
it's the right versions of the device

1050
00:45:21,000 --> 00:45:23,160
um were pretty reliable vulnerabilities

1051
00:45:23,160 --> 00:45:25,140
and of itself the clipboard right is

1052
00:45:25,140 --> 00:45:27,740
going to work every single time

1053
00:45:27,740 --> 00:45:30,359
the loading the exploit which wasn't a

1054
00:45:30,359 --> 00:45:31,800
vulnerability but loading it being a

1055
00:45:31,800 --> 00:45:33,540
Samsung app like that's straightforward

1056
00:45:33,540 --> 00:45:35,880
the kernel leak might be the one place

1057
00:45:35,880 --> 00:45:37,440
where you have to do it a few times but

1058
00:45:37,440 --> 00:45:39,180
there's not really then an issue with

1059
00:45:39,180 --> 00:45:40,800
running it a few different times because

1060
00:45:40,800 --> 00:45:43,260
it's not like you're going to crash the

1061
00:45:43,260 --> 00:45:45,420
device from that and then it seems like

1062
00:45:45,420 --> 00:45:48,420
the use after free was pretty stable as

1063
00:45:48,420 --> 00:45:49,319
well

1064
00:45:49,319 --> 00:45:51,420
thank you

1065
00:45:51,420 --> 00:45:53,760
hi congratulations for a fantastic talk

1066
00:45:53,760 --> 00:45:55,380
it's really honor to have someone from

1067
00:45:55,380 --> 00:45:57,300
Project Studio here Echo party so please

1068
00:45:57,300 --> 00:45:59,160
keep click keep coming and my question

1069
00:45:59,160 --> 00:46:00,000
is

1070
00:46:00,000 --> 00:46:03,060
um you just um basically like burn a

1071
00:46:03,060 --> 00:46:04,440
full exploit chain from a surveillance

1072
00:46:04,440 --> 00:46:06,720
webinar which is fantastic but what are

1073
00:46:06,720 --> 00:46:08,099
your thoughts about doing the exact same

1074
00:46:08,099 --> 00:46:10,520
thing maybe for the US government

1075
00:46:10,520 --> 00:46:14,160
[Laughter]

1076
00:46:14,160 --> 00:46:16,560
um I do not know when we see exploit

1077
00:46:16,560 --> 00:46:19,800
samples you don't know if there are bugs

1078
00:46:19,800 --> 00:46:22,260
in something they're being exploited I'm

1079
00:46:22,260 --> 00:46:24,300
gonna get them fixed

1080
00:46:24,300 --> 00:46:26,960
thank you

1081
00:46:29,359 --> 00:46:33,359
thank y'all

