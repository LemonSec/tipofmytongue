1
00:00:06,359 --> 00:00:09,359
foreign

2
00:00:12,330 --> 00:00:17,369
[Applause]

3
00:00:28,500 --> 00:00:30,539
get there

4
00:00:30,539 --> 00:00:32,660
um

5
00:00:34,260 --> 00:00:36,800
foreign

6
00:00:39,800 --> 00:00:42,600
okay uh I think you can start can I

7
00:00:42,600 --> 00:00:43,379
start

8
00:00:43,379 --> 00:00:45,960
okay okay uh hello my name is Jose

9
00:00:45,960 --> 00:00:48,899
elevator I'm going to presenting uh as

10
00:00:48,899 --> 00:00:51,120
akslr we're gonna be using tail Branch

11
00:00:51,120 --> 00:00:54,600
predictors to bypass aslr

12
00:00:54,600 --> 00:00:55,860
um well

13
00:00:55,860 --> 00:00:58,680
first I'll do introduction what is ESR

14
00:00:58,680 --> 00:01:02,100
it's the acronyms for address basically

15
00:01:02,100 --> 00:01:04,260
after randomization so basically when

16
00:01:04,260 --> 00:01:07,560
you have a program you compile it and uh

17
00:01:07,560 --> 00:01:10,200
on the first execution it changes the

18
00:01:10,200 --> 00:01:11,640
address of the functions that you are

19
00:01:11,640 --> 00:01:14,220
running this is a mitigation to prevent

20
00:01:14,220 --> 00:01:15,299
a

21
00:01:15,299 --> 00:01:18,920
attacks from of a memory corruption

22
00:01:18,920 --> 00:01:21,780
so in in this talk we're going to

23
00:01:21,780 --> 00:01:23,720
present a way to bypass

24
00:01:23,720 --> 00:01:27,360
SLR in I believe

25
00:01:27,360 --> 00:01:30,060
almost any case if you have a big enough

26
00:01:30,060 --> 00:01:32,040
program

27
00:01:32,040 --> 00:01:35,280
so I'm Jose Oliveira I'm a cyber

28
00:01:35,280 --> 00:01:36,979
security consultant at Price security

29
00:01:36,979 --> 00:01:39,780
I'm also a former CTF player on the app

30
00:01:39,780 --> 00:01:42,420
quality team I'm a member of a security

31
00:01:42,420 --> 00:01:44,759
incidental Response Group at a federal

32
00:01:44,759 --> 00:01:46,740
University of Rio De Janeiro and I'm

33
00:01:46,740 --> 00:01:49,140
also finishing my graduation at the

34
00:01:49,140 --> 00:01:50,899
cemetery University

35
00:01:50,899 --> 00:01:53,520
there is my Twitter you can find me

36
00:01:53,520 --> 00:01:55,439
there if you have any questions later on

37
00:01:55,439 --> 00:01:58,500
or if you want to talk about something

38
00:01:58,500 --> 00:02:03,360
uh about the stock uh so about our

39
00:02:03,360 --> 00:02:05,700
agenda uh we're going to talking about

40
00:02:05,700 --> 00:02:07,740
uh this is going to mainly be a review

41
00:02:07,740 --> 00:02:09,780
of uh some Core Concepts of computer

42
00:02:09,780 --> 00:02:11,760
architectures uh we'll talk about the

43
00:02:11,760 --> 00:02:13,860
CBO pipelines then move on to Branch

44
00:02:13,860 --> 00:02:15,540
predictors

45
00:02:15,540 --> 00:02:16,260
um

46
00:02:16,260 --> 00:02:18,300
take a look with some examples of a

47
00:02:18,300 --> 00:02:20,520
sectional attacks we're going to review

48
00:02:20,520 --> 00:02:24,780
a spectria text too because this is

49
00:02:24,780 --> 00:02:26,940
actually a Spectra attack we're going to

50
00:02:26,940 --> 00:02:29,400
review some other papers that uh do

51
00:02:29,400 --> 00:02:32,099
similar stuff we have a jump over AIS

52
00:02:32,099 --> 00:02:34,739
aslr and then finally you're going to

53
00:02:34,739 --> 00:02:38,220
present our novel attack is akslr that

54
00:02:38,220 --> 00:02:40,500
allows fullway SLR bypass and this fast

55
00:02:40,500 --> 00:02:44,160
and has few requirements to execute it

56
00:02:44,160 --> 00:02:49,400
all right this is also a zero day okay

57
00:02:49,920 --> 00:02:52,019
well let's talk about pipeline what's

58
00:02:52,019 --> 00:02:54,720
the idea of a pipeline uh let's take for

59
00:02:54,720 --> 00:02:57,300
example a restaurant if you have only

60
00:02:57,300 --> 00:02:59,700
one people working in a restaurant well

61
00:02:59,700 --> 00:03:02,099
usually it takes one client uh takes the

62
00:03:02,099 --> 00:03:04,620
order go moves to the kitchen then start

63
00:03:04,620 --> 00:03:06,780
to prepare the the Mew and then goes

64
00:03:06,780 --> 00:03:09,120
there to serve the other people when you

65
00:03:09,120 --> 00:03:12,900
have a a pipeline it allows to do a

66
00:03:12,900 --> 00:03:15,300
parallel production of of something so

67
00:03:15,300 --> 00:03:17,099
we have a waiter that goes there takes

68
00:03:17,099 --> 00:03:19,680
their order and moves on to the to the

69
00:03:19,680 --> 00:03:21,720
kitchen that prepares the Mew and then

70
00:03:21,720 --> 00:03:23,940
other guy goes there and deliver the

71
00:03:23,940 --> 00:03:27,780
foods so we divide the task in multiple

72
00:03:27,780 --> 00:03:30,060
stages that allows to uh better

73
00:03:30,060 --> 00:03:33,360
efficiency of of the testing uh but we

74
00:03:33,360 --> 00:03:36,780
have a a a challenge when working with

75
00:03:36,780 --> 00:03:41,879
uh with pipelines is that uh usually uh

76
00:03:41,879 --> 00:03:43,560
the work that you're doing doesn't

77
00:03:43,560 --> 00:03:45,720
depend on the previous work that was

78
00:03:45,720 --> 00:03:48,000
done for example we don't have a

79
00:03:48,000 --> 00:03:51,000
workload dependency uh

80
00:03:51,000 --> 00:03:54,299
so this was the the schema that uh I

81
00:03:54,299 --> 00:03:56,459
talked about we have a waiter that takes

82
00:03:56,459 --> 00:03:59,340
order then moves to the cashier that

83
00:03:59,340 --> 00:04:01,200
would decode the order and send to the

84
00:04:01,200 --> 00:04:03,959
kitchen for example uh and finally the

85
00:04:03,959 --> 00:04:06,540
chef is going to cook the meal so for

86
00:04:06,540 --> 00:04:08,280
example when we have a a full restaurant

87
00:04:08,280 --> 00:04:11,220
at most times for example on the psycho

88
00:04:11,220 --> 00:04:13,080
tree there there's going to be three

89
00:04:13,080 --> 00:04:15,780
people working at the same time so they

90
00:04:15,780 --> 00:04:18,120
can finally work at some much more rates

91
00:04:18,120 --> 00:04:21,500
if there was only one people working on

92
00:04:21,500 --> 00:04:25,080
wait we're gonna get into the CPUs this

93
00:04:25,080 --> 00:04:27,900
is just an analogy for that uh what's

94
00:04:27,900 --> 00:04:30,000
the problem usually when you're at a

95
00:04:30,000 --> 00:04:32,280
restaurant uh no one goes there in the

96
00:04:32,280 --> 00:04:33,240
order

97
00:04:33,240 --> 00:04:35,759
um a conditional

98
00:04:35,759 --> 00:04:38,639
a conditional meal for example if a guy

99
00:04:38,639 --> 00:04:41,100
enters the restaurant and say well uh if

100
00:04:41,100 --> 00:04:43,680
that client there uh

101
00:04:43,680 --> 00:04:46,620
that client there ordered a beef as a

102
00:04:46,620 --> 00:04:47,419
steak

103
00:04:47,419 --> 00:04:51,540
if that status comes uh burnt I want a

104
00:04:51,540 --> 00:04:54,360
beer order I want a spaghetti

105
00:04:54,360 --> 00:04:57,600
well what the waiter should do now uh

106
00:04:57,600 --> 00:05:01,080
should it wait for the the steak to get

107
00:05:01,080 --> 00:05:04,259
ready and check if it's burnt or not

108
00:05:04,259 --> 00:05:06,180
um that was a that's a possibility but

109
00:05:06,180 --> 00:05:10,259
uh it also takes longer for the uh for

110
00:05:10,259 --> 00:05:12,960
the whole meal to get prepared so

111
00:05:12,960 --> 00:05:15,900
the waiter can do something like for

112
00:05:15,900 --> 00:05:18,780
example well I know the stake will come

113
00:05:18,780 --> 00:05:21,360
okay so I've already started doing the

114
00:05:21,360 --> 00:05:24,240
spaghetti and then I can deliver those

115
00:05:24,240 --> 00:05:27,360
both both meals at the same time and uh

116
00:05:27,360 --> 00:05:30,300
that's will be much faster than just

117
00:05:30,300 --> 00:05:32,220
waiting for the stick to get on

118
00:05:32,220 --> 00:05:36,000
but what if the stakey gets burned in

119
00:05:36,000 --> 00:05:38,580
the process well then I must throw the

120
00:05:38,580 --> 00:05:40,620
spaghetti out on trash and deliver the

121
00:05:40,620 --> 00:05:44,220
beer for the guy that requested it

122
00:05:44,220 --> 00:05:49,020
that's what I call a speculative waiter

123
00:05:49,020 --> 00:05:51,960
uh it's going to try to predict what's

124
00:05:51,960 --> 00:05:54,300
going to happen with the mule that gets

125
00:05:54,300 --> 00:05:57,600
requested and uh acting accordingly so

126
00:05:57,600 --> 00:06:00,900
it will send the spaghetti order to the

127
00:06:00,900 --> 00:06:03,020
kitchen

128
00:06:03,539 --> 00:06:07,020
uh and for example uh here is a an

129
00:06:07,020 --> 00:06:09,900
example that well the chef is also it

130
00:06:09,900 --> 00:06:12,600
has to cook the stick the steak and

131
00:06:12,600 --> 00:06:15,120
check if it's okay and then at the same

132
00:06:15,120 --> 00:06:18,180
time the spaghetti can also be uh

133
00:06:18,180 --> 00:06:20,000
foreign

134
00:06:20,000 --> 00:06:23,639
so we have like a few things doing at

135
00:06:23,639 --> 00:06:25,800
the same time

136
00:06:25,800 --> 00:06:28,740
but one of that is not exactly sure if

137
00:06:28,740 --> 00:06:32,759
it's gonna to be used later

138
00:06:32,759 --> 00:06:34,680
and uh

139
00:06:34,680 --> 00:06:36,479
well

140
00:06:36,479 --> 00:06:39,120
let's suppose let's make a the following

141
00:06:39,120 --> 00:06:40,759
scenario

142
00:06:40,759 --> 00:06:43,259
I'm also a Tucker that I want to know

143
00:06:43,259 --> 00:06:47,160
for example if the waiter uh

144
00:06:47,160 --> 00:06:51,800
crooked spaghetti by accident or not

145
00:06:51,800 --> 00:06:55,800
I can order a spaghetti and uh I will

146
00:06:55,800 --> 00:06:58,139
check the time for example I know that

147
00:06:58,139 --> 00:07:00,840
spaghetti usually takes uh 30 minutes to

148
00:07:00,840 --> 00:07:05,460
to be ready but if it took a 15 minutes

149
00:07:05,460 --> 00:07:09,539
I know that uh for example with the the

150
00:07:09,539 --> 00:07:12,120
ingredients must be moved out from the

151
00:07:12,120 --> 00:07:13,819
3G and that the spaghetti will come

152
00:07:13,819 --> 00:07:18,240
earlier so I can uh kind of infer if the

153
00:07:18,240 --> 00:07:22,199
if the waiter mispredicted the the meal

154
00:07:22,199 --> 00:07:25,139
so this is a kind of analogy for how

155
00:07:25,139 --> 00:07:27,720
this modern CPU Works uh here we have a

156
00:07:27,720 --> 00:07:29,880
example of a fat unity and the code and

157
00:07:29,880 --> 00:07:31,620
the execute unit

158
00:07:31,620 --> 00:07:34,319
the fetch will be responsible for taking

159
00:07:34,319 --> 00:07:37,199
instructions from the main memory that

160
00:07:37,199 --> 00:07:39,599
remember is usually slow

161
00:07:39,599 --> 00:07:41,460
uh

162
00:07:41,460 --> 00:07:43,560
the decodual

163
00:07:43,560 --> 00:07:45,720
they call them in a nice way that uh the

164
00:07:45,720 --> 00:07:47,160
uni the execution units can understand

165
00:07:47,160 --> 00:07:50,400
and the execution annuities will just

166
00:07:50,400 --> 00:07:52,680
run the actual instructions

167
00:07:52,680 --> 00:07:55,860
so for example we have here a jump not

168
00:07:55,860 --> 00:07:59,180
zero instruction uh the blue one

169
00:07:59,180 --> 00:08:02,699
uh the fetch Unity right now it needs to

170
00:08:02,699 --> 00:08:06,660
take a decision will because the effect

171
00:08:06,660 --> 00:08:08,819
units don't know the the exact value of

172
00:08:08,819 --> 00:08:11,400
the flag registers right here uh it

173
00:08:11,400 --> 00:08:14,400
depends on the execution of the rng1

174
00:08:14,400 --> 00:08:17,880
instruction the let's add there so it

175
00:08:17,880 --> 00:08:20,280
must already know what this next

176
00:08:20,280 --> 00:08:21,840
instruction is so it will make a

177
00:08:21,840 --> 00:08:24,960
speculation uh that's on the purple

178
00:08:24,960 --> 00:08:27,479
and later that speculation must be

179
00:08:27,479 --> 00:08:29,819
checked if it was correct or not and if

180
00:08:29,819 --> 00:08:31,740
it was it's okay you can move on to the

181
00:08:31,740 --> 00:08:33,599
execution flow otherwise you need to

182
00:08:33,599 --> 00:08:35,219
discard all the

183
00:08:35,219 --> 00:08:37,458
all the

184
00:08:37,458 --> 00:08:40,020
values that you get from the execution

185
00:08:40,020 --> 00:08:41,820
the wrong structure

186
00:08:41,820 --> 00:08:44,760
and for example right here we have the

187
00:08:44,760 --> 00:08:47,100
the RNG instruction taking a long of

188
00:08:47,100 --> 00:08:49,620
time because it uses memory for example

189
00:08:49,620 --> 00:08:53,160
at the same time that I'm executing the

190
00:08:53,160 --> 00:08:55,380
purple one that's maybe should never be

191
00:08:55,380 --> 00:08:56,600
executed before

192
00:08:56,600 --> 00:08:59,339
the only problem is that the processors

193
00:08:59,339 --> 00:09:02,640
the processor cannot discard the the

194
00:09:02,640 --> 00:09:05,459
effects of the purple execution

195
00:09:05,459 --> 00:09:11,459
exactly well you can uh obviously not

196
00:09:11,459 --> 00:09:15,120
uh use the value written DL but for

197
00:09:15,120 --> 00:09:18,120
example the RDX pointer there is going

198
00:09:18,120 --> 00:09:20,399
to be moved on to the cache and that

199
00:09:20,399 --> 00:09:25,380
says a pretty uh perceptible change for

200
00:09:25,380 --> 00:09:28,080
an attacker

201
00:09:28,080 --> 00:09:31,500
okay that previous CPUs was a

202
00:09:31,500 --> 00:09:33,240
simplification this one is much more

203
00:09:33,240 --> 00:09:36,899
accurate uh it's I took the image from

204
00:09:36,899 --> 00:09:39,720
the Meltdown paper you can take a look

205
00:09:39,720 --> 00:09:42,360
at that it has a fat unit just like

206
00:09:42,360 --> 00:09:46,440
before it has a decode Unity a kiwi for

207
00:09:46,440 --> 00:09:50,339
instructions and they do a pretty smart

208
00:09:50,339 --> 00:09:52,860
thing that is instructional Jordan so

209
00:09:52,860 --> 00:09:55,019
the modern CPU they execute instructions

210
00:09:55,019 --> 00:09:58,980
out of order for example well

211
00:09:58,980 --> 00:10:02,300
back into the kitchen analogy

212
00:10:02,300 --> 00:10:05,519
for example if some guy orders for

213
00:10:05,519 --> 00:10:09,240
example a salad but he's on the end of

214
00:10:09,240 --> 00:10:13,140
the the kiwi but uh all the stoves are

215
00:10:13,140 --> 00:10:14,399
being used right now because they're

216
00:10:14,399 --> 00:10:17,880
cooking food uh the the chef can take

217
00:10:17,880 --> 00:10:19,620
the request from the last guy and start

218
00:10:19,620 --> 00:10:21,600
making the salad because the other units

219
00:10:21,600 --> 00:10:24,720
that are occupied occupated so that's

220
00:10:24,720 --> 00:10:28,740
just is is that similar what a CPU does

221
00:10:28,740 --> 00:10:30,959
uh

222
00:10:30,959 --> 00:10:33,060
instruction really ordinary and then

223
00:10:33,060 --> 00:10:34,560
finally they have a scheduling execution

224
00:10:34,560 --> 00:10:37,399
whether it's all that

225
00:10:37,399 --> 00:10:40,380
so let's talk about a branch prediction

226
00:10:40,380 --> 00:10:43,680
that is uh what should I do when I don't

227
00:10:43,680 --> 00:10:45,480
know what the next instruction gonna be

228
00:10:45,480 --> 00:10:47,459
uh the front end of the CPU the

229
00:10:47,459 --> 00:10:49,140
frontenders of the CPU sometimes don't

230
00:10:49,140 --> 00:10:50,820
know what's the next instruction they

231
00:10:50,820 --> 00:10:55,040
they should uh they should uh fetch

232
00:10:55,040 --> 00:10:57,120
uh well

233
00:10:57,120 --> 00:11:00,120
for example when you have a a call like

234
00:11:00,120 --> 00:11:02,640
that one uh when you have an indirect

235
00:11:02,640 --> 00:11:05,820
pointer right there on the RDI there's

236
00:11:05,820 --> 00:11:08,220
gonna be a special uh

237
00:11:08,220 --> 00:11:11,339
cache-like structure inside the CPU that

238
00:11:11,339 --> 00:11:13,500
helps the front end of the CPU to

239
00:11:13,500 --> 00:11:15,060
predict what's the next instruction is

240
00:11:15,060 --> 00:11:16,860
going to be so for example after

241
00:11:16,860 --> 00:11:18,660
executing the call

242
00:11:18,660 --> 00:11:21,180
the the CPU does a hash with the address

243
00:11:21,180 --> 00:11:22,980
and also the history of the last

244
00:11:22,980 --> 00:11:25,620
branches that's not important right now

245
00:11:25,620 --> 00:11:27,060
we're going to see later how it works

246
00:11:27,060 --> 00:11:29,279
and then it's a

247
00:11:29,279 --> 00:11:32,220
queries this cache-like structure to

248
00:11:32,220 --> 00:11:34,200
know what's the predicted address right

249
00:11:34,200 --> 00:11:37,260
there so the idea is that if I have a

250
00:11:37,260 --> 00:11:39,260
call in that place

251
00:11:39,260 --> 00:11:42,180
the next call on that base will also be

252
00:11:42,180 --> 00:11:45,420
to the same value so this is the

253
00:11:45,420 --> 00:11:47,279
mechanism that he uses to do the this

254
00:11:47,279 --> 00:11:49,440
kind of predictions at least on this

255
00:11:49,440 --> 00:11:51,600
type of instructions the indirect calls

256
00:11:51,600 --> 00:11:53,220
and jumps

257
00:11:53,220 --> 00:11:54,320
um

258
00:11:54,320 --> 00:11:57,600
this is actually the the mechanism that

259
00:11:57,600 --> 00:12:00,180
works for computing the this previous

260
00:12:00,180 --> 00:12:03,360
text right here this is the tag that uh

261
00:12:03,360 --> 00:12:06,899
is going to be used in here oops uh and

262
00:12:06,899 --> 00:12:09,540
here's the the mechanism for doing that

263
00:12:09,540 --> 00:12:11,519
kind of prediction uh you're gonna

264
00:12:11,519 --> 00:12:13,320
ignore the direct Branch predictor right

265
00:12:13,320 --> 00:12:15,860
now we're gonna only take a look to the

266
00:12:15,860 --> 00:12:18,779
indirect one uh

267
00:12:18,779 --> 00:12:21,480
forget that I don't have I have here

268
00:12:21,480 --> 00:12:23,700
where it is forget this this thing here

269
00:12:23,700 --> 00:12:25,680
we're only going to take a look at uh

270
00:12:25,680 --> 00:12:30,060
these two ones okay so first we have a a

271
00:12:30,060 --> 00:12:32,640
branch user buffer that uh it's kind of

272
00:12:32,640 --> 00:12:35,000
taking a hash of the

273
00:12:35,000 --> 00:12:39,540
last executed instructions uh that

274
00:12:39,540 --> 00:12:40,980
change for control flow for example a

275
00:12:40,980 --> 00:12:42,720
for Loop a for Loop writes on the

276
00:12:42,720 --> 00:12:44,519
branches or buffer

277
00:12:44,519 --> 00:12:47,339
um and that's a generates a hash we're

278
00:12:47,339 --> 00:12:50,040
using also the The Source address and

279
00:12:50,040 --> 00:12:52,579
when I first took a look at this diagram

280
00:12:52,579 --> 00:12:55,440
I saw a very interesting interesting

281
00:12:55,440 --> 00:12:59,100
thing uh right here we have a

282
00:12:59,100 --> 00:13:02,040
uh a component that where's the the

283
00:13:02,040 --> 00:13:03,779
pointer that predicts to a full address

284
00:13:03,779 --> 00:13:08,339
of 64 bits but it only uses 12 less

285
00:13:08,339 --> 00:13:11,040
significant bits as a entry for this

286
00:13:11,040 --> 00:13:12,959
thing and right here if you're going to

287
00:13:12,959 --> 00:13:16,620
take a look it only uses four to 19. so

288
00:13:16,620 --> 00:13:18,060
basically

289
00:13:18,060 --> 00:13:21,720
uh it's a component that takes the first

290
00:13:21,720 --> 00:13:24,600
20 bits as entry and predicts to the

291
00:13:24,600 --> 00:13:27,420
full 64 bit address and I was thinking

292
00:13:27,420 --> 00:13:28,339
well

293
00:13:28,339 --> 00:13:32,700
uh this may be a mechanism for breaking

294
00:13:32,700 --> 00:13:35,040
SLR

295
00:13:35,040 --> 00:13:37,880
uh

296
00:13:37,880 --> 00:13:41,220
this other projector here it's user for

297
00:13:41,220 --> 00:13:43,380
example when instructions data do not

298
00:13:43,380 --> 00:13:45,540
make a memory reference for example call

299
00:13:45,540 --> 00:13:48,600
array area X right there no the the

300
00:13:48,600 --> 00:13:52,440
first one ah where it is

301
00:13:52,440 --> 00:13:53,639
oh

302
00:13:53,639 --> 00:13:56,279
right here this one yeah there was

303
00:13:56,279 --> 00:13:58,200
another paper that uh used this

304
00:13:58,200 --> 00:14:02,600
predictor to also crack eslr but it only

305
00:14:02,600 --> 00:14:04,920
discovers the first half of the the

306
00:14:04,920 --> 00:14:07,800
address because the address is predicted

307
00:14:07,800 --> 00:14:11,839
to the 32-bit destinations only

308
00:14:11,839 --> 00:14:15,720
so this one can pretty um Can leak the

309
00:14:15,720 --> 00:14:17,639
entire address

310
00:14:17,639 --> 00:14:20,100
uh so let's then take a look at side

311
00:14:20,100 --> 00:14:22,980
Channel attacks uh how do I discover the

312
00:14:22,980 --> 00:14:25,620
the micro architectural states of the

313
00:14:25,620 --> 00:14:28,860
the stuffs when the CPU is speculating

314
00:14:28,860 --> 00:14:31,139
so we have this

315
00:14:31,139 --> 00:14:33,959
um kind of this is inside a function

316
00:14:33,959 --> 00:14:35,399
there

317
00:14:35,399 --> 00:14:37,740
um that's called a probe and receives an

318
00:14:37,740 --> 00:14:38,700
address

319
00:14:38,700 --> 00:14:41,339
and it does a thing called the flush

320
00:14:41,339 --> 00:14:44,459
reload attack that discovers if an

321
00:14:44,459 --> 00:14:46,620
address is on present on Cache or if

322
00:14:46,620 --> 00:14:49,500
it's only on Main memory it does this by

323
00:14:49,500 --> 00:14:51,180
checking the time that it took to access

324
00:14:51,180 --> 00:14:54,120
that address right there we have a read

325
00:14:54,120 --> 00:14:57,600
cssc read test you see uh it's the read

326
00:14:57,600 --> 00:14:59,880
timestamp counter it's an instruction

327
00:14:59,880 --> 00:15:02,339
that takes the internal clock of the CPU

328
00:15:02,339 --> 00:15:06,000
that gets updated each clock cycle

329
00:15:06,000 --> 00:15:08,339
um and uh moves to another register that

330
00:15:08,339 --> 00:15:11,339
you can use it later we also have the

331
00:15:11,339 --> 00:15:14,160
the reads of the pointer there and then

332
00:15:14,160 --> 00:15:16,139
we read the internal clock again and we

333
00:15:16,139 --> 00:15:18,120
use an instruction called CL flush that

334
00:15:18,120 --> 00:15:21,600
allow us to evict a cache a cache line

335
00:15:21,600 --> 00:15:24,420
from the cache well so it's basically

336
00:15:24,420 --> 00:15:27,899
after this read the data is no longer on

337
00:15:27,899 --> 00:15:29,399
the cache

338
00:15:29,399 --> 00:15:31,440
um the fencing elephants instructions

339
00:15:31,440 --> 00:15:34,139
are just because uh as I said before the

340
00:15:34,139 --> 00:15:36,300
CPU likes to reorder instruction

341
00:15:36,300 --> 00:15:38,579
software code and sometimes these

342
00:15:38,579 --> 00:15:41,000
effects can be noticeable for example

343
00:15:41,000 --> 00:15:44,820
the CPU can take the the last

344
00:15:44,820 --> 00:15:47,160
instruction for reading the the clock

345
00:15:47,160 --> 00:15:48,959
and moved on to the first and then I get

346
00:15:48,959 --> 00:15:52,680
a negative value it looks insane yeah so

347
00:15:52,680 --> 00:15:56,040
this is how I I checked the time that

348
00:15:56,040 --> 00:15:58,440
the address takes to get from the memory

349
00:15:58,440 --> 00:16:00,839
to the CPU and if you plot that into a

350
00:16:00,839 --> 00:16:05,459
graph uh that is my CPU and uh what I

351
00:16:05,459 --> 00:16:07,680
did it was I I took the the function

352
00:16:07,680 --> 00:16:10,560
from the last slide and uh half of the

353
00:16:10,560 --> 00:16:14,100
times I tried to to probe the time of a

354
00:16:14,100 --> 00:16:16,199
cache at the value that are on the on

355
00:16:16,199 --> 00:16:18,899
the green and half of the time trying to

356
00:16:18,899 --> 00:16:21,779
probe a address that was not cached and

357
00:16:21,779 --> 00:16:24,180
you can see that it's a pretty

358
00:16:24,180 --> 00:16:26,880
significant difference and uh well you

359
00:16:26,880 --> 00:16:28,980
as attacker if you want to discover if a

360
00:16:28,980 --> 00:16:32,040
data is present only on on the uh on the

361
00:16:32,040 --> 00:16:34,440
main memory you could draw a threshold

362
00:16:34,440 --> 00:16:36,300
here in the middle

363
00:16:36,300 --> 00:16:39,839
there and you say well below that

364
00:16:39,839 --> 00:16:42,779
everything is on Cache above that uh

365
00:16:42,779 --> 00:16:44,639
it's present on the main memory so

366
00:16:44,639 --> 00:16:46,680
that's how we discover if a data is

367
00:16:46,680 --> 00:16:49,680
cached on the on the CPU or not

368
00:16:49,680 --> 00:16:54,660
uh well this is a spectrophy two V1 V1

369
00:16:54,660 --> 00:16:57,959
uh example that I did as a challenge for

370
00:16:57,959 --> 00:17:03,899
pump between 2021 uh I well okay I'll

371
00:17:03,899 --> 00:17:07,400
give us some time to to read this

372
00:17:11,880 --> 00:17:13,559
okay

373
00:17:13,559 --> 00:17:15,380
understand what is going to happen here

374
00:17:15,380 --> 00:17:18,540
uh we have two flags the the first one

375
00:17:18,540 --> 00:17:21,119
is kind of trivial to to get it the

376
00:17:21,119 --> 00:17:24,119
other one not so much uh and we receive

377
00:17:24,119 --> 00:17:27,839
a x value coming from the the network

378
00:17:27,839 --> 00:17:28,740
um

379
00:17:28,740 --> 00:17:30,840
well the attacker has control over the x

380
00:17:30,840 --> 00:17:33,960
value so right here we do some

381
00:17:33,960 --> 00:17:36,539
arithmetics if it is and we're basically

382
00:17:36,539 --> 00:17:39,480
getting well what's a bit of the flag do

383
00:17:39,480 --> 00:17:41,460
you want

384
00:17:41,460 --> 00:17:43,740
um and right and I'm selecting that beat

385
00:17:43,740 --> 00:17:45,960
that you want and checking well the beat

386
00:17:45,960 --> 00:17:48,480
is one if the beat is one I call uh get

387
00:17:48,480 --> 00:17:51,500
him if the Bit Zero I don't do nothing

388
00:17:51,500 --> 00:17:54,900
uh in this challenge an attacker can

389
00:17:54,900 --> 00:17:58,140
execute code on the same computer but it

390
00:17:58,140 --> 00:18:00,840
cannot interact more than just sending

391
00:18:00,840 --> 00:18:04,380
the x value so how can it leak the

392
00:18:04,380 --> 00:18:05,700
entire flag

393
00:18:05,700 --> 00:18:09,360
uh the idea is for the first part uh

394
00:18:09,360 --> 00:18:12,360
right here for that's what the exploit

395
00:18:12,360 --> 00:18:14,520
looks like

396
00:18:14,520 --> 00:18:17,360
uh

397
00:18:18,780 --> 00:18:20,760
for the first part I'll move back to

398
00:18:20,760 --> 00:18:22,440
here for the first part you don't need

399
00:18:22,440 --> 00:18:24,780
to to do nothing special with the with

400
00:18:24,780 --> 00:18:26,580
this bound check this bound check will

401
00:18:26,580 --> 00:18:29,120
always return true for the first flag

402
00:18:29,120 --> 00:18:32,220
and this will get evaluated the idea is

403
00:18:32,220 --> 00:18:34,520
if a process running on the SIM card

404
00:18:34,520 --> 00:18:36,600
executes the gets everything function

405
00:18:36,600 --> 00:18:39,720
that's present on the libc the other

406
00:18:39,720 --> 00:18:42,179
process that's also running on the on

407
00:18:42,179 --> 00:18:44,460
the same car not exactly on the SIM card

408
00:18:44,460 --> 00:18:47,900
can be on the other car for this part

409
00:18:47,900 --> 00:18:50,700
the execution of the other process also

410
00:18:50,700 --> 00:18:53,220
get faster so if the if this program

411
00:18:53,220 --> 00:18:55,620
here runs getting and then me as

412
00:18:55,620 --> 00:18:58,080
attacker run get him I know that uh by

413
00:18:58,080 --> 00:19:00,900
the time it took to execute it uh that

414
00:19:00,900 --> 00:19:03,480
the beat was one and then I can leak the

415
00:19:03,480 --> 00:19:05,780
first part of the flag

416
00:19:05,780 --> 00:19:08,820
the idea of the of a spec review one is

417
00:19:08,820 --> 00:19:11,820
that I can manipulate the CPU in order

418
00:19:11,820 --> 00:19:15,720
to do funny things with the execution

419
00:19:15,720 --> 00:19:17,700
flow for example right here we have a

420
00:19:17,700 --> 00:19:19,380
conditional structure we learned that

421
00:19:19,380 --> 00:19:21,299
conditional instructions uh they tend to

422
00:19:21,299 --> 00:19:23,160
be speculated by the CPU

423
00:19:23,160 --> 00:19:24,360
so

424
00:19:24,360 --> 00:19:27,059
uh there's a special kind of predictor

425
00:19:27,059 --> 00:19:28,679
that's what's not shown on the previous

426
00:19:28,679 --> 00:19:30,059
light but

427
00:19:30,059 --> 00:19:33,299
um right here if you set uh this Branch

428
00:19:33,299 --> 00:19:36,240
here to execute multiple times the CPU

429
00:19:36,240 --> 00:19:37,620
will believe that the next time they

430
00:19:37,620 --> 00:19:39,539
need to go to the branch it'll also be

431
00:19:39,539 --> 00:19:41,880
executed so what you can do you can pass

432
00:19:41,880 --> 00:19:45,480
out offset the x value here zero zero

433
00:19:45,480 --> 00:19:47,880
zero zero zero this guy is executing

434
00:19:47,880 --> 00:19:49,980
these instructions are executing and

435
00:19:49,980 --> 00:19:52,620
then you go to like a 100 it should not

436
00:19:52,620 --> 00:19:54,480
execute but we'll execute because the

437
00:19:54,480 --> 00:19:57,299
CPU is trained for executing that that

438
00:19:57,299 --> 00:20:00,480
range and that's how you you bypass this

439
00:20:00,480 --> 00:20:02,039
bound check and get the value of stuff

440
00:20:02,039 --> 00:20:04,260
like that's what I do here uh I send

441
00:20:04,260 --> 00:20:08,280
Like A 333 multiple times uh then I have

442
00:20:08,280 --> 00:20:10,200
this evicted that uh I'll talk about

443
00:20:10,200 --> 00:20:11,460
later

444
00:20:11,460 --> 00:20:14,160
um then we send the actual bit that I

445
00:20:14,160 --> 00:20:16,260
want to read from the flag and then I do

446
00:20:16,260 --> 00:20:18,240
a flash reloads attack that uses that

447
00:20:18,240 --> 00:20:21,200
probably function there

448
00:20:22,380 --> 00:20:25,440
and then I can leak the entire flag

449
00:20:25,440 --> 00:20:28,080
well uh let's move on to the version two

450
00:20:28,080 --> 00:20:30,720
of the the attack uh these attacks they

451
00:20:30,720 --> 00:20:32,280
are

452
00:20:32,280 --> 00:20:37,919
pretty old they're from like a 12 no uh

453
00:20:37,919 --> 00:20:40,740
uh 20 2018 I think

454
00:20:40,740 --> 00:20:44,340
um but uh many many

455
00:20:44,340 --> 00:20:46,500
new versions of the exploits are being

456
00:20:46,500 --> 00:20:48,000
discovered

457
00:20:48,000 --> 00:20:51,960
uh nowadays so what's the idea of a spec

458
00:20:51,960 --> 00:20:55,320
review we have uh to be we have to meet

459
00:20:55,320 --> 00:20:57,600
some requirements they need to the both

460
00:20:57,600 --> 00:20:59,580
programs should need to execute on the

461
00:20:59,580 --> 00:21:01,860
same uh on the same context same context

462
00:21:01,860 --> 00:21:05,220
no on the same core that can be for

463
00:21:05,220 --> 00:21:07,919
example a hyper hyper threat thing and

464
00:21:07,919 --> 00:21:10,140
you have a contact say is equation on

465
00:21:10,140 --> 00:21:12,059
thread zero and context Beyond thread

466
00:21:12,059 --> 00:21:14,580
one and they need to find a branch

467
00:21:14,580 --> 00:21:15,960
targets buffer Collision the branch

468
00:21:15,960 --> 00:21:17,400
targets buffer Collision is what I was

469
00:21:17,400 --> 00:21:19,559
saying with the slides there in the

470
00:21:19,559 --> 00:21:21,240
beginning that we need to make that hash

471
00:21:21,240 --> 00:21:24,840
function uh collided this thing here and

472
00:21:24,840 --> 00:21:27,120
then I can do a a funny stuff for

473
00:21:27,120 --> 00:21:30,299
example context B that in this case is a

474
00:21:30,299 --> 00:21:32,900
legitimate user is calling a function

475
00:21:32,900 --> 00:21:35,700
but it's a context a is also calling a

476
00:21:35,700 --> 00:21:37,620
function and they are in a similar

477
00:21:37,620 --> 00:21:40,320
address right here and the context B

478
00:21:40,320 --> 00:21:43,500
then will mispredict to the to the

479
00:21:43,500 --> 00:21:44,520
address

480
00:21:44,520 --> 00:21:47,700
set by context C so we say that the

481
00:21:47,700 --> 00:21:50,520
context a can poison the the branch

482
00:21:50,520 --> 00:21:53,360
predictor buffer enforce a misprediction

483
00:21:53,360 --> 00:21:56,340
on this call on the context B and then

484
00:21:56,340 --> 00:21:59,640
the uh I think called the Spectra Gadget

485
00:21:59,640 --> 00:22:01,919
will be executed and the Spectrum Gadget

486
00:22:01,919 --> 00:22:04,620
is nothing but nothing more than a piece

487
00:22:04,620 --> 00:22:07,860
of code that gets a secret and puts that

488
00:22:07,860 --> 00:22:09,539
secret into a side channel for example

489
00:22:09,539 --> 00:22:13,520
as a scene with getting the example

490
00:22:13,520 --> 00:22:16,500
so we discovered that then we can

491
00:22:16,500 --> 00:22:18,419
actually call a function without a

492
00:22:18,419 --> 00:22:21,360
calling a function so we trick the CPU

493
00:22:21,360 --> 00:22:23,100
to calling I think that it was never

494
00:22:23,100 --> 00:22:25,679
meant to be called in the first place

495
00:22:25,679 --> 00:22:28,200
uh other requirements for this kind of

496
00:22:28,200 --> 00:22:30,659
attack but no longer more is a

497
00:22:30,659 --> 00:22:32,400
requirement is that you need to have the

498
00:22:32,400 --> 00:22:35,100
address of uh of a gadgets right here

499
00:22:35,100 --> 00:22:36,720
for example if this whole program is

500
00:22:36,720 --> 00:22:40,080
randomized we don't know where the the

501
00:22:40,080 --> 00:22:42,059
function a should be to match the

502
00:22:42,059 --> 00:22:44,159
context B and jump to this to this

503
00:22:44,159 --> 00:22:48,120
address so many places were was uh where

504
00:22:48,120 --> 00:22:50,580
it's saying that uh eslr was a

505
00:22:50,580 --> 00:22:52,580
mitigation for spectrum

506
00:22:52,580 --> 00:22:56,460
for spec review but uh in this talk

507
00:22:56,460 --> 00:22:58,980
we're gonna see that no specific V2 is

508
00:22:58,980 --> 00:23:02,580
also a mechanism for bypassing aslr and

509
00:23:02,580 --> 00:23:04,620
then we can make a chain that we use

510
00:23:04,620 --> 00:23:07,799
spec V2 for Bay passing by passing aslr

511
00:23:07,799 --> 00:23:10,500
and then to exploiting uh the the spec

512
00:23:10,500 --> 00:23:12,679
review

513
00:23:12,919 --> 00:23:16,559
so take a look a quick in previews aslr

514
00:23:16,559 --> 00:23:19,500
attacks this is another paper that was

515
00:23:19,500 --> 00:23:22,980
published a about exploiting brain

516
00:23:22,980 --> 00:23:25,260
targets buffer but it was published

517
00:23:25,260 --> 00:23:29,159
before spec tree came out so it uh the

518
00:23:29,159 --> 00:23:31,200
guys that wrote the paper doesn't know

519
00:23:31,200 --> 00:23:33,000
about the uh the impacts of

520
00:23:33,000 --> 00:23:35,820
mispredicting to other address

521
00:23:35,820 --> 00:23:39,059
so it was user first to leak a kslr that

522
00:23:39,059 --> 00:23:42,480
is Kernel address randomization it works

523
00:23:42,480 --> 00:23:45,360
pretty fast for for Cano but I also

524
00:23:45,360 --> 00:23:49,559
worked for leaking user to user ASR but

525
00:23:49,559 --> 00:23:52,620
at a rate of about a 100 address being

526
00:23:52,620 --> 00:23:54,600
tested per second which is pretty slow

527
00:23:54,600 --> 00:23:57,960
if you check that uh ASL randomizes like

528
00:23:57,960 --> 00:23:59,659
uh I don't know

529
00:23:59,659 --> 00:24:03,559
uh uh

530
00:24:04,440 --> 00:24:05,940
12 to

531
00:24:05,940 --> 00:24:08,340
40 beats I don't know that's a lot of

532
00:24:08,340 --> 00:24:10,799
address that gives a like a two

533
00:24:10,799 --> 00:24:14,159
terabytes of address that can be

534
00:24:14,159 --> 00:24:16,500
that's where you when when the program

535
00:24:16,500 --> 00:24:19,980
can be uh and it only leaks the first

536
00:24:19,980 --> 00:24:22,140
half of the of the audience because this

537
00:24:22,140 --> 00:24:24,780
mechanism of prediction it cannot uh get

538
00:24:24,780 --> 00:24:27,620
the full 64-bit destination

539
00:24:27,620 --> 00:24:31,200
so let's take an example for our proof

540
00:24:31,200 --> 00:24:34,020
of concept for a ZK SLR well it's pretty

541
00:24:34,020 --> 00:24:37,320
simple the requirements are minimal we

542
00:24:37,320 --> 00:24:38,520
have right here

543
00:24:38,520 --> 00:24:41,820
um a function that does nothing we have

544
00:24:41,820 --> 00:24:44,280
a print for the this pointer that's be

545
00:24:44,280 --> 00:24:47,220
going to be randomized because of SLR we

546
00:24:47,220 --> 00:24:50,760
have a for Loop that will well it's kind

547
00:24:50,760 --> 00:24:53,640
of shooting but uh

548
00:24:53,640 --> 00:24:56,220
it helps us to know what value is going

549
00:24:56,220 --> 00:24:57,539
to be present on the branch history

550
00:24:57,539 --> 00:25:00,419
buffer uh it's not necessary to be here

551
00:25:00,419 --> 00:25:02,760
because you can just debug the the

552
00:25:02,760 --> 00:25:04,200
process that you are attacking and

553
00:25:04,200 --> 00:25:07,080
checking uh not debugging because it's

554
00:25:07,080 --> 00:25:09,120
going to be randomizer but uh you can

555
00:25:09,120 --> 00:25:11,000
check the patterns of the latest uh

556
00:25:11,000 --> 00:25:13,799
control flow instructions that change

557
00:25:13,799 --> 00:25:15,240
the

558
00:25:15,240 --> 00:25:17,760
the branch user buffer okay and we're

559
00:25:17,760 --> 00:25:19,440
going to call the quota pointer there

560
00:25:19,440 --> 00:25:21,539
that's going to give us an indirect call

561
00:25:21,539 --> 00:25:25,380
so the actual the only requirements to

562
00:25:25,380 --> 00:25:27,659
have an indirect call right there

563
00:25:27,659 --> 00:25:30,480
uh and you know the 12 leases

564
00:25:30,480 --> 00:25:31,919
significant cvps because they are not

565
00:25:31,919 --> 00:25:35,400
randomized uh uh and we test our attack

566
00:25:35,400 --> 00:25:38,400
in all Intel processors that we found on

567
00:25:38,400 --> 00:25:39,419
Google Cloud

568
00:25:39,419 --> 00:25:44,159
that's mean uh 12 generation two three

569
00:25:44,159 --> 00:25:47,340
four five six seven we don't know what

570
00:25:47,340 --> 00:25:50,159
happened on the 18 or 9 and it works on

571
00:25:50,159 --> 00:25:53,279
them but we have not tested on any more

572
00:25:53,279 --> 00:25:55,380
CPUs and we're gonna see that it's

573
00:25:55,380 --> 00:25:58,559
pretty fast uh we initially call it the

574
00:25:58,559 --> 00:26:00,620
reverse Spectrum Branch Target injection

575
00:26:00,620 --> 00:26:03,720
because it will kind of the whole idea

576
00:26:03,720 --> 00:26:06,539
of this exploit is that in usual

577
00:26:06,539 --> 00:26:09,179
enormous Factory you are trying to

578
00:26:09,179 --> 00:26:12,659
poison uh the the victim program and

579
00:26:12,659 --> 00:26:14,640
forcing you to execute something

580
00:26:14,640 --> 00:26:17,159
in our attack we are letting the victim

581
00:26:17,159 --> 00:26:19,980
attackers using Factory to then later

582
00:26:19,980 --> 00:26:22,320
recover the address that we're executing

583
00:26:22,320 --> 00:26:23,820
when mispredicting

584
00:26:23,820 --> 00:26:25,799
this is the whole idea we're doing a

585
00:26:25,799 --> 00:26:28,100
reverse respectry

586
00:26:28,100 --> 00:26:31,140
so this is what uh the memory looks like

587
00:26:31,140 --> 00:26:34,260
on uh in our attack we have a victim of

588
00:26:34,260 --> 00:26:36,980
context running right here uh it has a

589
00:26:36,980 --> 00:26:40,799
randomized address because of ASR and is

590
00:26:40,799 --> 00:26:42,960
calling constantly this function to here

591
00:26:42,960 --> 00:26:45,480
and this creates a branch targets buffer

592
00:26:45,480 --> 00:26:48,900
poisoning for our code with this address

593
00:26:48,900 --> 00:26:52,140
as a Target and then when we place a a

594
00:26:52,140 --> 00:26:54,120
column instruction on the similar

595
00:26:54,120 --> 00:26:55,919
address not exactly the same it

596
00:26:55,919 --> 00:26:58,799
mispredicted to or think here called

597
00:26:58,799 --> 00:27:00,960
leak Gadget that is responsible to

598
00:27:00,960 --> 00:27:03,299
telling us hey I'm executing at this

599
00:27:03,299 --> 00:27:06,539
address it does that using another

600
00:27:06,539 --> 00:27:09,179
auxiliary variable that is there and it

601
00:27:09,179 --> 00:27:12,360
adds access this variable and then this

602
00:27:12,360 --> 00:27:14,039
is a side Channel attack that allow us

603
00:27:14,039 --> 00:27:16,919
to recover the address being executed so

604
00:27:16,919 --> 00:27:18,960
let's take a look into what is this leak

605
00:27:18,960 --> 00:27:20,460
Gadget

606
00:27:20,460 --> 00:27:23,520
well uh this gadget receives two

607
00:27:23,520 --> 00:27:26,880
arguments uh one is on uh CL register

608
00:27:26,880 --> 00:27:29,100
and the other one is the actual probate

609
00:27:29,100 --> 00:27:31,380
there we're gonna see how later how

610
00:27:31,380 --> 00:27:33,480
we're going to pass Arguments for a

611
00:27:33,480 --> 00:27:37,200
function that we never call it okay it's

612
00:27:37,200 --> 00:27:39,600
kind of strange saying that uh but let's

613
00:27:39,600 --> 00:27:41,460
take a look at what it does

614
00:27:41,460 --> 00:27:43,500
we take the current address and move

615
00:27:43,500 --> 00:27:46,919
into area X then we select one of those

616
00:27:46,919 --> 00:27:51,000
bits uh uh chosen by the CLL argument

617
00:27:51,000 --> 00:27:53,520
we make an end to make sure that it's

618
00:27:53,520 --> 00:27:55,080
the only video present on the register

619
00:27:55,080 --> 00:27:59,460
and the multiplied by 4096 or shift to

620
00:27:59,460 --> 00:28:02,940
left 12. uh and then we added uh and

621
00:28:02,940 --> 00:28:05,940
then we access probably at position 0 or

622
00:28:05,940 --> 00:28:07,500
4096.

623
00:28:07,500 --> 00:28:10,260
uh for yeah

624
00:28:10,260 --> 00:28:14,000
uh and then we recover the uh

625
00:28:14,000 --> 00:28:17,220
using aside Channel we check oh what's

626
00:28:17,220 --> 00:28:18,919
the the the

627
00:28:18,919 --> 00:28:22,620
position zero was the position of 40 96

628
00:28:22,620 --> 00:28:24,720
that was accessed

629
00:28:24,720 --> 00:28:28,200
so that's the idea the idea is gonna we

630
00:28:28,200 --> 00:28:30,000
have a victim code right there we're

631
00:28:30,000 --> 00:28:34,140
gonna try to mimic uh the last uh the

632
00:28:34,140 --> 00:28:35,580
last instructions that right to the

633
00:28:35,580 --> 00:28:37,200
branches or buffer for example that for

634
00:28:37,200 --> 00:28:39,360
Loop will try to mimic it there and then

635
00:28:39,360 --> 00:28:42,179
we're gonna place a a call or a jump at

636
00:28:42,179 --> 00:28:44,279
the same address the idea is that uh

637
00:28:44,279 --> 00:28:45,960
this one is going to call this address

638
00:28:45,960 --> 00:28:47,700
right here and this one is we're going

639
00:28:47,700 --> 00:28:49,500
to mispredict to the same address and

640
00:28:49,500 --> 00:28:51,299
then we're gonna place our leak Gadget

641
00:28:51,299 --> 00:28:53,658
there

642
00:28:53,880 --> 00:28:55,980
so what's the challenge with this kind

643
00:28:55,980 --> 00:28:59,000
of exploits well I told you that uh

644
00:28:59,000 --> 00:29:03,000
the whole range of aslr that is from

645
00:29:03,000 --> 00:29:05,580
this address to this one uh if you make

646
00:29:05,580 --> 00:29:08,159
the the the countries it's going to be

647
00:29:08,159 --> 00:29:10,740
two terabytes of a memory we don't have

648
00:29:10,740 --> 00:29:12,360
two terabytes of memory for working with

649
00:29:12,360 --> 00:29:15,419
uh usually the the computers only have

650
00:29:15,419 --> 00:29:18,480
like a four or eight or 16

651
00:29:18,480 --> 00:29:20,580
um but we need to place this in all

652
00:29:20,580 --> 00:29:23,580
positions so what can you do first we

653
00:29:23,580 --> 00:29:25,740
can use a copy and write

654
00:29:25,740 --> 00:29:30,360
uh it's uh um I think used for reducing

655
00:29:30,360 --> 00:29:32,520
the the space that you use for on the

656
00:29:32,520 --> 00:29:35,580
physical memory by if you have for

657
00:29:35,580 --> 00:29:37,980
example uh the Liberty the lip C is a is

658
00:29:37,980 --> 00:29:40,620
a great example many programs use LBC uh

659
00:29:40,620 --> 00:29:42,899
so and they use the same exact version

660
00:29:42,899 --> 00:29:45,720
of EBC but um

661
00:29:45,720 --> 00:29:47,760
the operations the operational system

662
00:29:47,760 --> 00:29:50,520
says that well uh the process must have

663
00:29:50,520 --> 00:29:52,200
isolated memory

664
00:29:52,200 --> 00:29:54,179
because it's otherwise you could just

665
00:29:54,179 --> 00:29:57,000
read from the process that that won't be

666
00:29:57,000 --> 00:29:58,679
pretty smart

667
00:29:58,679 --> 00:30:01,559
um but the operational system also allow

668
00:30:01,559 --> 00:30:04,559
us to do copyright or that means I can

669
00:30:04,559 --> 00:30:07,679
have only one uh copy of the Liberty on

670
00:30:07,679 --> 00:30:09,240
the physical memory and then have

671
00:30:09,240 --> 00:30:12,659
multiple pointers uh pointing to the to

672
00:30:12,659 --> 00:30:16,080
that address so well in this case you

673
00:30:16,080 --> 00:30:19,740
could use for example uh in order to to

674
00:30:19,740 --> 00:30:21,419
load two terabytes of virtual memory

675
00:30:21,419 --> 00:30:24,179
create a file with like a one gigabyte

676
00:30:24,179 --> 00:30:27,299
and then trying to map that file and

677
00:30:27,299 --> 00:30:30,059
then you can really have a two terabytes

678
00:30:30,059 --> 00:30:31,799
of memory in our process

679
00:30:31,799 --> 00:30:34,679
but we don't work with that because I I

680
00:30:34,679 --> 00:30:36,539
tried that uh the first time it didn't

681
00:30:36,539 --> 00:30:38,580
work I don't know exactly why I think

682
00:30:38,580 --> 00:30:41,820
that many page entry zone or process

683
00:30:41,820 --> 00:30:44,640
kind of doesn't work and then

684
00:30:44,640 --> 00:30:47,220
uh we try something a little different

685
00:30:47,220 --> 00:30:50,880
we only load uh one slice of a gigabyte

686
00:30:50,880 --> 00:30:53,399
of one gigabyte and then we use the

687
00:30:53,399 --> 00:30:55,980
Cisco of remap to change the virtual

688
00:30:55,980 --> 00:30:58,679
address of that position so therefore we

689
00:30:58,679 --> 00:31:02,460
can try to test many uh

690
00:31:02,460 --> 00:31:05,159
um we can test it one slice of one

691
00:31:05,159 --> 00:31:06,840
gigabyte per time and then move it on to

692
00:31:06,840 --> 00:31:09,000
the next slide next slides and then you

693
00:31:09,000 --> 00:31:13,260
have like a try to uh two thousand times

694
00:31:13,260 --> 00:31:15,960
it's also pretty fast other challenges

695
00:31:15,960 --> 00:31:19,080
that we we encounter on the on the

696
00:31:19,080 --> 00:31:21,720
exploiting is that uh in order to

697
00:31:21,720 --> 00:31:23,580
execute an address it needs to be

698
00:31:23,580 --> 00:31:25,620
present on the tlb that is the

699
00:31:25,620 --> 00:31:28,080
translation look outside buffer uh it's

700
00:31:28,080 --> 00:31:30,899
uh also a cache-like structure that

701
00:31:30,899 --> 00:31:34,020
stores the translations for the virtual

702
00:31:34,020 --> 00:31:35,399
address that you're trying to access on

703
00:31:35,399 --> 00:31:39,240
uh the problem is that with those leak

704
00:31:39,240 --> 00:31:42,539
gadgets there uh they're not they're

705
00:31:42,539 --> 00:31:45,059
never going to get executed so the

706
00:31:45,059 --> 00:31:48,360
address will never be on the tlb so how

707
00:31:48,360 --> 00:31:52,080
can we put them on the tlb or what are

708
00:31:52,080 --> 00:31:54,600
you gonna do they said Televisa

709
00:31:54,600 --> 00:31:57,179
um it's very limited in how much of

710
00:31:57,179 --> 00:32:00,480
stuff you can put there and the doing a

711
00:32:00,480 --> 00:32:04,740
page Walker is slow so because it's you

712
00:32:04,740 --> 00:32:06,659
have to read from a pointer of change to

713
00:32:06,659 --> 00:32:09,600
in order to calculate the the fiscal

714
00:32:09,600 --> 00:32:12,659
address so the the gadgets will never be

715
00:32:12,659 --> 00:32:16,320
called because uh the page walk is low

716
00:32:16,320 --> 00:32:19,500
and then the speculation

717
00:32:19,500 --> 00:32:22,140
um the speculation gets corrected before

718
00:32:22,140 --> 00:32:24,840
calling the gadget so one idea you have

719
00:32:24,840 --> 00:32:28,320
is to increase the speculation window

720
00:32:28,320 --> 00:32:29,760
so

721
00:32:29,760 --> 00:32:32,899
instead of just having a call uh

722
00:32:32,899 --> 00:32:35,700
brackets area X for example we're going

723
00:32:35,700 --> 00:32:38,580
to have a pointer chain that is going to

724
00:32:38,580 --> 00:32:42,480
have multiple pointers there and finally

725
00:32:42,480 --> 00:32:43,919
on the last one we're going to do the

726
00:32:43,919 --> 00:32:46,679
call we also tried to play for

727
00:32:46,679 --> 00:32:48,840
transparency with your pages thinking

728
00:32:48,840 --> 00:32:51,720
that you decrease the the the pressure

729
00:32:51,720 --> 00:32:55,320
on the tlb but what saved us was out of

730
00:32:55,320 --> 00:32:59,100
order execution because this is what no

731
00:32:59,100 --> 00:33:01,919
next one this is what uh the the

732
00:33:01,919 --> 00:33:04,440
frontiens delivers to the rest of the

733
00:33:04,440 --> 00:33:07,140
pipeline well you can see there uh we

734
00:33:07,140 --> 00:33:08,640
have a pointer chain

735
00:33:08,640 --> 00:33:11,520
and finally uh we have the check that is

736
00:33:11,520 --> 00:33:14,100
actually I I jump right there

737
00:33:14,100 --> 00:33:16,559
um and it also delivers these

738
00:33:16,559 --> 00:33:18,899
instructions that gets speculated but

739
00:33:18,899 --> 00:33:21,720
when getting into the reorder buff

740
00:33:21,720 --> 00:33:24,960
buffer uh what the other buffers see is

741
00:33:24,960 --> 00:33:26,460
that we have a huge dependency of

742
00:33:26,460 --> 00:33:27,779
instructions that take too much time

743
00:33:27,779 --> 00:33:31,100
over here and they have some uh internal

744
00:33:31,100 --> 00:33:34,500
execution units available on the CPU and

745
00:33:34,500 --> 00:33:37,740
this this block here can be executed and

746
00:33:37,740 --> 00:33:39,179
then what's actually going to be

747
00:33:39,179 --> 00:33:42,840
executed is this finger so we have the

748
00:33:42,840 --> 00:33:45,059
the loading of the arguments then start

749
00:33:45,059 --> 00:33:47,519
to reading the pointer chain we executed

750
00:33:47,519 --> 00:33:51,360
out of order uh or gets that speculated

751
00:33:51,360 --> 00:33:54,779
and it runs before even doing the the

752
00:33:54,779 --> 00:33:57,360
actual call so we learned to how to call

753
00:33:57,360 --> 00:34:00,360
uh a function without calling a function

754
00:34:00,360 --> 00:34:02,340
and the before even calling your

755
00:34:02,340 --> 00:34:03,860
function

756
00:34:03,860 --> 00:34:08,580
uh so this also this is our results we

757
00:34:08,580 --> 00:34:11,159
have exploiting working for hours Intel

758
00:34:11,159 --> 00:34:14,280
CPUs for N1 and 2. it takes less than 10

759
00:34:14,280 --> 00:34:16,159
seconds per execution

760
00:34:16,159 --> 00:34:19,940
recovers all Beats randomized by eslr

761
00:34:19,940 --> 00:34:23,159
if you if you force this this time here

762
00:34:23,159 --> 00:34:27,000
you ah well oh okay uh you get up to one

763
00:34:27,000 --> 00:34:28,859
trillion of address that's the bicep per

764
00:34:28,859 --> 00:34:32,760
second but uh it's on the it's more like

765
00:34:32,760 --> 00:34:36,418
a a hundred billions per second we also

766
00:34:36,418 --> 00:34:40,320
do it on a generation 10 CPU that it has

767
00:34:40,320 --> 00:34:42,839
a mitigation called a single tragic

768
00:34:42,839 --> 00:34:45,119
Branch prediction that says oh okay you

769
00:34:45,119 --> 00:34:47,520
have a prediction unit for one thread

770
00:34:47,520 --> 00:34:50,339
and one for another and the idea is that

771
00:34:50,339 --> 00:34:52,859
uh it will be more difficult to exploit

772
00:34:52,859 --> 00:34:56,520
Spectra V2 across uh threads but we

773
00:34:56,520 --> 00:34:57,720
don't care about that so we're just

774
00:34:57,720 --> 00:34:59,940
sleep and allow the scheduler to to

775
00:34:59,940 --> 00:35:01,560
place the victim on the same thread that

776
00:35:01,560 --> 00:35:04,020
we're working on

777
00:35:04,020 --> 00:35:06,080
well how about mitigations

778
00:35:06,080 --> 00:35:08,580
we the great problem is how do we

779
00:35:08,580 --> 00:35:10,859
mitigate Spectra V2 no one's know yet uh

780
00:35:10,859 --> 00:35:14,040
there's a mitigation available uh for of

781
00:35:14,040 --> 00:35:17,160
that can be done in in Cairo uh it's

782
00:35:17,160 --> 00:35:19,380
also available for

783
00:35:19,380 --> 00:35:22,079
no I I mean it's already implemented uh

784
00:35:22,079 --> 00:35:24,060
I believe it's a indirect Branch

785
00:35:24,060 --> 00:35:27,119
predictor barrier that is uh the CPU

786
00:35:27,119 --> 00:35:29,640
allows for a special instruction

787
00:35:29,640 --> 00:35:32,160
um to flush the predictional units there

788
00:35:32,160 --> 00:35:35,280
and then it should mitigate the Spectrum

789
00:35:35,280 --> 00:35:38,280
but it's disabled by default because you

790
00:35:38,280 --> 00:35:39,200
need to

791
00:35:39,200 --> 00:35:41,700
do as this call in your process to to

792
00:35:41,700 --> 00:35:43,400
enable it

793
00:35:43,400 --> 00:35:45,960
the other mitigation is the hardware

794
00:35:45,960 --> 00:35:48,060
mitigation that you can limit the the

795
00:35:48,060 --> 00:35:51,240
amounts of of a bits predicted for

796
00:35:51,240 --> 00:35:53,339
example and they do it on direct

797
00:35:53,339 --> 00:35:57,359
predictor uh it only predicts to the 32

798
00:35:57,359 --> 00:36:00,599
least significant bits so that kind of

799
00:36:00,599 --> 00:36:03,540
uh reduced impact of an attack like this

800
00:36:03,540 --> 00:36:07,800
but it also implies on on having a

801
00:36:07,800 --> 00:36:09,720
some problems with performance I I

802
00:36:09,720 --> 00:36:11,339
believe

803
00:36:11,339 --> 00:36:14,099
and uh likes right now it's time for the

804
00:36:14,099 --> 00:36:16,820
live demo

805
00:36:17,579 --> 00:36:23,700
okay uh okay so we're setting the victim

806
00:36:23,700 --> 00:36:27,240
to run on the car one

807
00:36:27,240 --> 00:36:29,220
that's their address that's randomizer

808
00:36:29,220 --> 00:36:31,619
you can see that uh

809
00:36:31,619 --> 00:36:34,680
each time executed it's randomizer

810
00:36:34,680 --> 00:36:38,460
and then we're gonna do our attacker

811
00:36:38,460 --> 00:36:42,140
oh I'll get into that

812
00:36:43,619 --> 00:36:45,900
oh it works

813
00:36:45,900 --> 00:36:48,680
this address

814
00:36:49,680 --> 00:36:53,000
is equal to this address

815
00:36:53,870 --> 00:37:02,409
[Applause]

816
00:37:02,820 --> 00:37:05,359
oops

817
00:37:06,540 --> 00:37:09,119
blah blah blah I had a video about I

818
00:37:09,119 --> 00:37:10,560
don't need that

819
00:37:10,560 --> 00:37:13,700
uh oh

820
00:37:13,740 --> 00:37:15,180
questions

821
00:37:15,180 --> 00:37:17,280
I I promise I call the review I still

822
00:37:17,280 --> 00:37:19,560
have eight minutes left so

823
00:37:19,560 --> 00:37:21,540
I will open for questions and then you

824
00:37:21,540 --> 00:37:24,420
can move on to the code review uh that's

825
00:37:24,420 --> 00:37:26,880
my Twitter blah blah

826
00:37:26,880 --> 00:37:28,560
questions and go to review I will open

827
00:37:28,560 --> 00:37:32,960
it we can do it simultaneously

828
00:37:33,060 --> 00:37:35,040
uh

829
00:37:35,040 --> 00:37:37,800
I lied a little bit about the the victim

830
00:37:37,800 --> 00:37:40,800
code we kind of hard coded the for Loop

831
00:37:40,800 --> 00:37:44,220
and the and the call but it's still a

832
00:37:44,220 --> 00:37:45,380
for Loop

833
00:37:45,380 --> 00:37:48,839
and it's still a call

834
00:37:48,839 --> 00:37:52,020
oh yeah but I was having some trouble

835
00:37:52,020 --> 00:37:53,460
with aligning the instructions because

836
00:37:53,460 --> 00:37:55,200
the compiler was giving me like a call

837
00:37:55,200 --> 00:37:57,839
uh every P plus blah blah blah blah blah

838
00:37:57,839 --> 00:38:00,420
that instructions has uh I believe you

839
00:38:00,420 --> 00:38:03,060
eight bytes and the call that I was

840
00:38:03,060 --> 00:38:05,160
using on the other process was only two

841
00:38:05,160 --> 00:38:07,800
and we have some trouble aligning those

842
00:38:07,800 --> 00:38:09,960
but it should work you can try it at

843
00:38:09,960 --> 00:38:12,140
home

844
00:38:12,960 --> 00:38:16,440
oh you have a question yeah uh yes so

845
00:38:16,440 --> 00:38:19,260
you're forcing another process that's

846
00:38:19,260 --> 00:38:23,280
already looping to load into the cache

847
00:38:23,280 --> 00:38:25,500
the address that you're trying to leak I

848
00:38:25,500 --> 00:38:27,240
guess my question would be is how its

849
00:38:27,240 --> 00:38:29,700
height of a loop does the victim process

850
00:38:29,700 --> 00:38:33,180
have to be executed again uh either we

851
00:38:33,180 --> 00:38:35,339
tested it doesn't need to be a loop uh

852
00:38:35,339 --> 00:38:37,980
it only needs to execute one time

853
00:38:37,980 --> 00:38:41,460
uh we tried like uh the attacker

854
00:38:41,460 --> 00:38:44,820
signaling the the victimic process to to

855
00:38:44,820 --> 00:38:47,640
execute it and it also worked we just

856
00:38:47,640 --> 00:38:49,920
need to have a little bit of a problem

857
00:38:49,920 --> 00:38:51,619
with um

858
00:38:51,619 --> 00:38:55,079
uh like a scheduling give it time it to

859
00:38:55,079 --> 00:38:58,859
the signal to be handled and uh and it

860
00:38:58,859 --> 00:39:01,079
gets executed there but it doesn't need

861
00:39:01,079 --> 00:39:04,140
to be a wire Loop like this one

862
00:39:04,140 --> 00:39:06,780
well I I guess uh so like in a real

863
00:39:06,780 --> 00:39:08,820
world attack can you maybe

864
00:39:08,820 --> 00:39:12,300
um have you used this against like a a

865
00:39:12,300 --> 00:39:14,160
service or a privileged process or

866
00:39:14,160 --> 00:39:17,760
something that no not yet okay okay

867
00:39:17,760 --> 00:39:19,440
thanks

868
00:39:19,440 --> 00:39:22,440
if someone has any more questions uh

869
00:39:22,440 --> 00:39:24,720
take on pass to the model there are some

870
00:39:24,720 --> 00:39:28,920
Griffin or I can pass and give them a

871
00:39:28,920 --> 00:39:31,040
girlfriend

872
00:39:32,820 --> 00:39:34,560
no one no

873
00:39:34,560 --> 00:39:38,579
uh can we do the code review yes okay

874
00:39:38,579 --> 00:39:42,680
well let's go to the uh no no no no okay

875
00:39:42,680 --> 00:39:46,879
uh this is the

876
00:39:46,980 --> 00:39:48,660
function of that programmer that we're

877
00:39:48,660 --> 00:39:50,400
trying to mimic

878
00:39:50,400 --> 00:39:51,300
um

879
00:39:51,300 --> 00:39:54,540
right here we have the for Loop

880
00:39:54,540 --> 00:39:57,480
right here we have the call and we

881
00:39:57,480 --> 00:40:01,140
created a gadget sheet that it's this

882
00:40:01,140 --> 00:40:03,660
thing called Gadget clone that is

883
00:40:03,660 --> 00:40:05,760
actually these instructions right here

884
00:40:05,760 --> 00:40:08,339
we have our pointer chain that works on

885
00:40:08,339 --> 00:40:13,579
like you have just three three pointers

886
00:40:13,579 --> 00:40:16,920
uh have the same for Loop here and what

887
00:40:16,920 --> 00:40:20,160
you're gonna do we have a an RDI pointer

888
00:40:20,160 --> 00:40:22,320
very similar to the to the one on the

889
00:40:22,320 --> 00:40:24,359
victim we have our probe array right

890
00:40:24,359 --> 00:40:26,940
here we have a pointer chain here they

891
00:40:26,940 --> 00:40:29,280
need to be spaced because uh otherwise

892
00:40:29,280 --> 00:40:32,040
you have some issues like trying to

893
00:40:32,040 --> 00:40:34,200
access a probe array and also accessing

894
00:40:34,200 --> 00:40:35,700
the pointer chain because they are

895
00:40:35,700 --> 00:40:37,380
nearing their memory

896
00:40:37,380 --> 00:40:41,640
I have already nothing some helpers for

897
00:40:41,640 --> 00:40:44,940
other other functions have the probe

898
00:40:44,940 --> 00:40:47,119
here

899
00:40:47,160 --> 00:40:47,940
um

900
00:40:47,940 --> 00:40:49,740
it's the same function that I showed on

901
00:40:49,740 --> 00:40:52,920
the slides it also it only gets a A Time

902
00:40:52,920 --> 00:40:55,220
form

903
00:40:55,859 --> 00:40:58,440
a time of address in the memory we have

904
00:40:58,440 --> 00:41:00,599
the call Gadget here

905
00:41:00,599 --> 00:41:03,960
there's only gets the a few Arguments

906
00:41:03,960 --> 00:41:06,839
for example the the size of the loop uh

907
00:41:06,839 --> 00:41:09,300
the index of the bit that we're trying

908
00:41:09,300 --> 00:41:13,260
to leak from the rip uh it passes the

909
00:41:13,260 --> 00:41:16,560
property here in the destination the the

910
00:41:16,560 --> 00:41:18,420
pointer for the pointer for the the

911
00:41:18,420 --> 00:41:21,480
nothing function there uh and then is it

912
00:41:21,480 --> 00:41:25,020
executes this gadget clone okay

913
00:41:25,020 --> 00:41:28,260
this is how we call the the the the

914
00:41:28,260 --> 00:41:30,540
gadgets

915
00:41:30,540 --> 00:41:32,700
um we have a function called disclosure

916
00:41:32,700 --> 00:41:34,980
uh I'm pretty bad at naming functions

917
00:41:34,980 --> 00:41:38,880
yeah we just flush the pointer chain uh

918
00:41:38,880 --> 00:41:41,820
flush also the the ldi pointer use this

919
00:41:41,820 --> 00:41:43,980
CPU ID that is a special instruction

920
00:41:43,980 --> 00:41:45,960
that is usually for

921
00:41:45,960 --> 00:41:48,420
well it does many stuffs and because it

922
00:41:48,420 --> 00:41:50,520
do many stuffs people use it as a

923
00:41:50,520 --> 00:41:53,339
serializing structure it uh ensures that

924
00:41:53,339 --> 00:41:56,339
the flushes are actually uh executed and

925
00:41:56,339 --> 00:41:58,680
not doing something funny out of order

926
00:41:58,680 --> 00:42:02,099
and then called Gadget uh passing the

927
00:42:02,099 --> 00:42:04,920
the source of

928
00:42:04,920 --> 00:42:07,079
of the colder returns executing the

929
00:42:07,079 --> 00:42:08,280
index

930
00:42:08,280 --> 00:42:11,220
finally have the leak address

931
00:42:11,220 --> 00:42:13,200
this is our leaky gadgets this is the

932
00:42:13,200 --> 00:42:15,020
thing that you saw in the slide

933
00:42:15,020 --> 00:42:17,880
we have a auxiliary variable for caching

934
00:42:17,880 --> 00:42:21,380
blah blah blah blah

935
00:42:21,380 --> 00:42:24,480
where we start to mapping uh all the

936
00:42:24,480 --> 00:42:28,079
possible well I told you before that um

937
00:42:28,079 --> 00:42:31,500
you need to match the 20 least

938
00:42:31,500 --> 00:42:33,839
significative bits of the source address

939
00:42:33,839 --> 00:42:35,520
in order to have a brain targets work

940
00:42:35,520 --> 00:42:37,020
for Collision so that's what we're going

941
00:42:37,020 --> 00:42:40,619
to do here we're gonna map all the well

942
00:42:40,619 --> 00:42:43,440
if you have a 20 bits 12 are not

943
00:42:43,440 --> 00:42:46,079
randomized it remains eight bits we

944
00:42:46,079 --> 00:42:48,480
match all the possible positions for

945
00:42:48,480 --> 00:42:52,079
this one uh and they all be going to be

946
00:42:52,079 --> 00:42:53,640
here in the source page

947
00:42:53,640 --> 00:42:55,920
then we set up our pointer chain

948
00:42:55,920 --> 00:42:57,540
uh

949
00:42:57,540 --> 00:43:00,900
this one is a a little hack it's uh one

950
00:43:00,900 --> 00:43:03,060
gigabytes page that I created just

951
00:43:03,060 --> 00:43:04,859
because it's faster to load it it's

952
00:43:04,859 --> 00:43:08,220
created uh here it only takes our leaky

953
00:43:08,220 --> 00:43:10,319
gadgets are there and the part is on

954
00:43:10,319 --> 00:43:12,060
these offset

955
00:43:12,060 --> 00:43:14,280
um and then you write it that many times

956
00:43:14,280 --> 00:43:17,400
into file that is one gigabyte I believe

957
00:43:17,400 --> 00:43:19,140
you can also do it too if a normal mm

958
00:43:19,140 --> 00:43:21,540
app and just copy the the results but I

959
00:43:21,540 --> 00:43:25,140
was not having a lot of luck there uh we

960
00:43:25,140 --> 00:43:27,800
are making sure that the the the

961
00:43:27,800 --> 00:43:30,260
destinations are present in the memory

962
00:43:30,260 --> 00:43:33,660
or if in cash better

963
00:43:33,660 --> 00:43:36,839
and then we start to moving that uh

964
00:43:36,839 --> 00:43:39,240
window of one gigabytes across all the

965
00:43:39,240 --> 00:43:41,040
possible destinations using a memory

966
00:43:41,040 --> 00:43:42,780
remap

967
00:43:42,780 --> 00:43:45,720
um I have a funny Prince there

968
00:43:45,720 --> 00:43:48,300
and then we'll do the uh all the the

969
00:43:48,300 --> 00:43:50,220
calls we have a calling that disclosure

970
00:43:50,220 --> 00:43:52,800
function that's a uh

971
00:43:52,800 --> 00:43:54,680
calls

972
00:43:54,680 --> 00:43:57,560
this thing here

973
00:43:57,560 --> 00:44:00,480
this thing

974
00:44:00,480 --> 00:44:01,560
well

975
00:44:01,560 --> 00:44:04,740
it enters on this address but uh we we

976
00:44:04,740 --> 00:44:07,740
Brute Force these two this byte here so

977
00:44:07,740 --> 00:44:09,300
it goes through all possibilities and

978
00:44:09,300 --> 00:44:10,920
that ensures that we're going to have a

979
00:44:10,920 --> 00:44:14,300
branch targets buffer Collision

980
00:44:15,000 --> 00:44:18,660
so then we later uh probe this the the

981
00:44:18,660 --> 00:44:20,400
probably array and then we're gonna

982
00:44:20,400 --> 00:44:23,819
check well once you want fast if T1 is

983
00:44:23,819 --> 00:44:27,240
fast then a bit to zero uh if T2 is

984
00:44:27,240 --> 00:44:29,640
faster than I beat this one and I put it

985
00:44:29,640 --> 00:44:33,420
on this variable then we do a slip to

986
00:44:33,420 --> 00:44:36,720
allow the the process to execute

987
00:44:36,720 --> 00:44:39,180
blah blah blah blah the other stuff just

988
00:44:39,180 --> 00:44:42,480
gets the time that I took to execution

989
00:44:42,480 --> 00:44:44,640
let's try again

990
00:44:44,640 --> 00:44:48,020
let's try again with another address

991
00:44:52,920 --> 00:44:54,660
sometimes it doesn't work it's normal

992
00:44:54,660 --> 00:44:57,300
but it's working fine

993
00:44:57,300 --> 00:44:59,940
uh I think our time is over

994
00:44:59,940 --> 00:45:03,119
uh any more adopts uh questions no yes

995
00:45:03,119 --> 00:45:05,579
if there's more questions

996
00:45:05,579 --> 00:45:07,920
no more questions

997
00:45:07,920 --> 00:45:11,339
well so then we are going to give a big

998
00:45:11,339 --> 00:45:13,240
clap to our friend Jose

999
00:45:13,240 --> 00:45:27,160
[Applause]

