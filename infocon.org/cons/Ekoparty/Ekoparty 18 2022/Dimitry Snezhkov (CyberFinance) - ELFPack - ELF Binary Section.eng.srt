1
00:00:00,060 --> 00:00:02,359
foreign

2
00:00:07,320 --> 00:00:09,790
[Applause]

3
00:00:09,790 --> 00:00:12,860
[Music]

4
00:00:32,780 --> 00:00:36,719
the conversation is going to be about

5
00:00:36,719 --> 00:00:37,980
um elves

6
00:00:37,980 --> 00:00:40,860
not the nice Christmas elves but the

7
00:00:40,860 --> 00:00:43,320
very very vicious and malicious elves

8
00:00:43,320 --> 00:00:46,200
that red teams used to to help

9
00:00:46,200 --> 00:00:47,879
themselves

10
00:00:47,879 --> 00:00:51,420
um who am I my name is Dimitri I work

11
00:00:51,420 --> 00:00:54,059
for IBM X-Force you can find me at

12
00:00:54,059 --> 00:00:55,140
Twitter

13
00:00:55,140 --> 00:00:55,860
um

14
00:00:55,860 --> 00:00:58,079
I'm currently with research doing

15
00:00:58,079 --> 00:01:00,180
offense and defense research but

16
00:01:00,180 --> 00:01:01,340
previously

17
00:01:01,340 --> 00:01:04,199
mostly red team operation malware work

18
00:01:04,199 --> 00:01:06,740
Unix Administration

19
00:01:06,740 --> 00:01:09,420
app development and so on and so forth

20
00:01:09,420 --> 00:01:12,659
so hopefully we can kind of talk through

21
00:01:12,659 --> 00:01:14,820
different sites to to help the red team

22
00:01:14,820 --> 00:01:17,060
win

23
00:01:17,060 --> 00:01:21,240
bubbles so agenda is we're going to take

24
00:01:21,240 --> 00:01:23,159
this talk from the writing perspective

25
00:01:23,159 --> 00:01:26,520
red team on Linux failed miserable we

26
00:01:26,520 --> 00:01:29,400
did this uh engagement a few months ago

27
00:01:29,400 --> 00:01:31,680
I should say a year ago

28
00:01:31,680 --> 00:01:35,180
um and uh we were in an environment that

29
00:01:35,180 --> 00:01:37,380
essentially did not allow us to move

30
00:01:37,380 --> 00:01:39,720
very much we'll talk more in details

31
00:01:39,720 --> 00:01:41,400
what that environment actually entails

32
00:01:41,400 --> 00:01:44,820
and how we overcame the deficiencies and

33
00:01:44,820 --> 00:01:46,439
were able to actually succeed in a way

34
00:01:46,439 --> 00:01:48,600
but this talk is really from that

35
00:01:48,600 --> 00:01:51,000
perspective uh red team failing and then

36
00:01:51,000 --> 00:01:53,640
trying to achieve the dominance

37
00:01:53,640 --> 00:01:55,560
but more specifically

38
00:01:55,560 --> 00:01:58,560
at the payload delivery uh failed right

39
00:01:58,560 --> 00:02:01,200
we could not bring a lot of things in we

40
00:02:01,200 --> 00:02:03,479
could not establish the foothold and

41
00:02:03,479 --> 00:02:06,000
persistence and

42
00:02:06,000 --> 00:02:08,220
um essentially everything sort of rolled

43
00:02:08,220 --> 00:02:10,380
down from there the environment did not

44
00:02:10,380 --> 00:02:13,640
allow us to Pivot in a lot of ways

45
00:02:13,640 --> 00:02:16,560
we went back to

46
00:02:16,560 --> 00:02:18,840
a joint board and started thinking what

47
00:02:18,840 --> 00:02:20,879
we can do about it right and so this

48
00:02:20,879 --> 00:02:22,080
evolution

49
00:02:22,080 --> 00:02:24,660
of how we overcame the challenges

50
00:02:24,660 --> 00:02:27,780
through uh various ways of payload

51
00:02:27,780 --> 00:02:29,840
delivery in Linux

52
00:02:29,840 --> 00:02:32,459
that's what we're going to talk about

53
00:02:32,459 --> 00:02:35,400
and then the idea that came through when

54
00:02:35,400 --> 00:02:37,560
we started looking at ways to overcome

55
00:02:37,560 --> 00:02:40,140
those challenges is how we can actually

56
00:02:40,140 --> 00:02:43,620
use elf sections to help our cause

57
00:02:43,620 --> 00:02:45,780
kind of moved with that with that flow

58
00:02:45,780 --> 00:02:48,540
we came up with a technique called elf

59
00:02:48,540 --> 00:02:50,700
section docking obviously not by

60
00:02:50,700 --> 00:02:52,560
ourselves we used a lot of Open Source

61
00:02:52,560 --> 00:02:55,019
ideas and some of the tools you're going

62
00:02:55,019 --> 00:02:57,239
to see here but essentially the

63
00:02:57,239 --> 00:02:59,280
culmination of it we were able to

64
00:02:59,280 --> 00:03:02,640
achieve our agenda and uh not only that

65
00:03:02,640 --> 00:03:06,120
but we also had a way to

66
00:03:06,120 --> 00:03:09,360
uh persist for the Long Haul the

67
00:03:09,360 --> 00:03:11,879
detection was not was rendered useless

68
00:03:11,879 --> 00:03:14,099
for us and so that was our goal that was

69
00:03:14,099 --> 00:03:16,140
our immediate goal right

70
00:03:16,140 --> 00:03:18,300
but then

71
00:03:18,300 --> 00:03:21,060
um analysis of the detection of the blue

72
00:03:21,060 --> 00:03:24,000
team right and how we can help them to

73
00:03:24,000 --> 00:03:27,480
achieve uh more introspection into what

74
00:03:27,480 --> 00:03:31,379
we did so the evasion and then

75
00:03:31,379 --> 00:03:33,540
um the detection of what we did and how

76
00:03:33,540 --> 00:03:35,819
The Blue Team actually got the tools to

77
00:03:35,819 --> 00:03:37,379
detect us

78
00:03:37,379 --> 00:03:39,720
and then uh the last but not least is

79
00:03:39,720 --> 00:03:42,599
the elf pack demo right uh the elf pack

80
00:03:42,599 --> 00:03:45,780
is the structure this Factory that we've

81
00:03:45,780 --> 00:03:48,659
created to to solve that cause

82
00:03:48,659 --> 00:03:50,099
all right

83
00:03:50,099 --> 00:03:54,120
first why Linux and why Linux malware I

84
00:03:54,120 --> 00:03:56,159
can give you two reasons

85
00:03:56,159 --> 00:03:58,019
um the first reason is kind of dry

86
00:03:58,019 --> 00:04:01,080
statistical uh is because it's prevalent

87
00:04:01,080 --> 00:04:05,040
in a cloud right if we are to work for

88
00:04:05,040 --> 00:04:08,220
our customers and we were to uh achieve

89
00:04:08,220 --> 00:04:09,720
our dominance in the cloud we should

90
00:04:09,720 --> 00:04:11,220
work with Linux

91
00:04:11,220 --> 00:04:14,840
now uh cross strike and Trend Micro

92
00:04:14,840 --> 00:04:17,519
provided some statistics into what Linux

93
00:04:17,519 --> 00:04:20,519
malware right right now is it used to be

94
00:04:20,519 --> 00:04:22,380
that you know there's a lot of

95
00:04:22,380 --> 00:04:25,020
ransomware that was on there right now

96
00:04:25,020 --> 00:04:27,180
due to decentralization we're moving to

97
00:04:27,180 --> 00:04:30,720
uh coin miners right and uh also the

98
00:04:30,720 --> 00:04:32,820
data that lives on Linux is important

99
00:04:32,820 --> 00:04:35,520
because you have databases running on it

100
00:04:35,520 --> 00:04:37,620
you have middleware running on it a

101
00:04:37,620 --> 00:04:39,120
bunch of banks around Linux and the

102
00:04:39,120 --> 00:04:41,639
cloud right now and so for our course

103
00:04:41,639 --> 00:04:43,620
because we were doing

104
00:04:43,620 --> 00:04:46,199
um such a work it was important for us

105
00:04:46,199 --> 00:04:49,380
right but the real reason that we care

106
00:04:49,380 --> 00:04:51,660
about is that we have a hard truth

107
00:04:51,660 --> 00:04:53,820
reality we are on Linux and we can't uh

108
00:04:53,820 --> 00:04:56,220
do anything with it right so that's our

109
00:04:56,220 --> 00:05:00,300
reason this is the industry reason

110
00:05:00,300 --> 00:05:04,860
so let's talk about uh the failures uh

111
00:05:04,860 --> 00:05:07,560
usually and many of you probably are

112
00:05:07,560 --> 00:05:10,080
familiar when the red team deploys they

113
00:05:10,080 --> 00:05:12,000
have an objective a goal to achieve

114
00:05:12,000 --> 00:05:14,300
right whether to get to a customer data

115
00:05:14,300 --> 00:05:18,240
maybe uh get some dominance on computing

116
00:05:18,240 --> 00:05:20,699
power uh establish the foothold and

117
00:05:20,699 --> 00:05:23,280
maybe uh pivot out into some very

118
00:05:23,280 --> 00:05:25,680
sensitive areas of the company

119
00:05:25,680 --> 00:05:27,720
but the thing to think of it is

120
00:05:27,720 --> 00:05:30,000
everything kind of starts with the first

121
00:05:30,000 --> 00:05:32,940
payload you can deliver it via phishing

122
00:05:32,940 --> 00:05:36,479
or you can do uh you know whatever ways

123
00:05:36,479 --> 00:05:39,360
you end up being on the inside this is

124
00:05:39,360 --> 00:05:42,180
not uh this is not trivial in a lot of

125
00:05:42,180 --> 00:05:43,500
ways right

126
00:05:43,500 --> 00:05:44,820
so

127
00:05:44,820 --> 00:05:46,860
speaking specifically of the Linux

128
00:05:46,860 --> 00:05:50,400
system we had a scenario where we had

129
00:05:50,400 --> 00:05:52,680
a really large environment of Linux but

130
00:05:52,680 --> 00:05:54,900
we had hardened host a jump host that

131
00:05:54,900 --> 00:05:57,060
you need to get onto and then fend out

132
00:05:57,060 --> 00:05:58,860
to the system and that presented the

133
00:05:58,860 --> 00:05:59,699
problem

134
00:05:59,699 --> 00:06:03,120
the hosts were hardened a lot of tools

135
00:06:03,120 --> 00:06:05,300
were removed from from them

136
00:06:05,300 --> 00:06:07,800
including obviously compilers

137
00:06:07,800 --> 00:06:10,139
interpreters were not there python was

138
00:06:10,139 --> 00:06:12,000
not there

139
00:06:12,000 --> 00:06:14,340
um we couldn't drop executables we got

140
00:06:14,340 --> 00:06:15,780
detected

141
00:06:15,780 --> 00:06:17,880
if anybody works in the red team they

142
00:06:17,880 --> 00:06:21,180
know that a cat only has maybe three

143
00:06:21,180 --> 00:06:24,120
lives we lost two lives already by

144
00:06:24,120 --> 00:06:27,419
essentially not able to drop the payload

145
00:06:27,419 --> 00:06:30,000
on it got detected got a knock from a

146
00:06:30,000 --> 00:06:31,440
blue team say hey what are you guys

147
00:06:31,440 --> 00:06:34,380
doing all right failure means going back

148
00:06:34,380 --> 00:06:36,840
to the drawing board so executables were

149
00:06:36,840 --> 00:06:39,180
detected by Static detection

150
00:06:39,180 --> 00:06:41,400
we try to pack it

151
00:06:41,400 --> 00:06:43,580
I did not go

152
00:06:43,580 --> 00:06:46,740
they after the fact we've learned that

153
00:06:46,740 --> 00:06:48,900
they had both static and dynamic

154
00:06:48,900 --> 00:06:51,000
detection on the unwrap of the

155
00:06:51,000 --> 00:06:53,400
executable so that that side of the

156
00:06:53,400 --> 00:06:54,960
window

157
00:06:54,960 --> 00:06:58,560
um we try to bring Frozen binaries we

158
00:06:58,560 --> 00:07:00,900
needed to bring for example impacket

159
00:07:00,900 --> 00:07:04,740
that's a python toolkit and you know the

160
00:07:04,740 --> 00:07:07,979
horrors are working with uh you know

161
00:07:07,979 --> 00:07:11,539
impacted and Frozen form uh you know

162
00:07:11,539 --> 00:07:15,120
especially with absence of python

163
00:07:15,120 --> 00:07:17,100
interpreter and system was was really a

164
00:07:17,100 --> 00:07:19,620
challenge so we tried that

165
00:07:19,620 --> 00:07:22,380
we got detected on temporary files on

166
00:07:22,380 --> 00:07:26,699
reps when when frozen binary runs the

167
00:07:26,699 --> 00:07:28,560
payload gets dropped into temp directory

168
00:07:28,560 --> 00:07:30,479
done right

169
00:07:30,479 --> 00:07:31,800
and then

170
00:07:31,800 --> 00:07:34,800
um the other challenge is that all that

171
00:07:34,800 --> 00:07:37,380
needs to be done with uh in memory right

172
00:07:37,380 --> 00:07:39,180
because we do not want to use the

173
00:07:39,180 --> 00:07:43,080
temporary directory and uh then we are

174
00:07:43,080 --> 00:07:45,419
going also against the research talked

175
00:07:45,419 --> 00:07:47,940
about ebpf this was exactly the scenario

176
00:07:47,940 --> 00:07:51,419
where we had to go against ebpf based

177
00:07:51,419 --> 00:07:54,840
EDR so all that was on that host

178
00:07:54,840 --> 00:07:56,580
that we needed to get through because

179
00:07:56,580 --> 00:07:58,800
after that there is a

180
00:07:58,800 --> 00:08:02,699
greener pastures let's just say

181
00:08:02,699 --> 00:08:04,380
so

182
00:08:04,380 --> 00:08:07,199
I'm going to kind of walk through

183
00:08:07,199 --> 00:08:10,139
this engagement as a series of thoughts

184
00:08:10,139 --> 00:08:14,160
right a failure uh a cause and effect

185
00:08:14,160 --> 00:08:15,960
and then the result and how we went

186
00:08:15,960 --> 00:08:17,580
through this I think it will be

187
00:08:17,580 --> 00:08:19,259
beneficial to kind of walk through the

188
00:08:19,259 --> 00:08:22,500
Chain of Thought uh to getting to the

189
00:08:22,500 --> 00:08:25,280
solution so

190
00:08:25,440 --> 00:08:28,139
um naturally we had limited set of tools

191
00:08:28,139 --> 00:08:30,539
ready for this engagement right we

192
00:08:30,539 --> 00:08:32,640
obviously could build more but but the

193
00:08:32,640 --> 00:08:35,099
timeline timeline was not there

194
00:08:35,099 --> 00:08:37,679
so strategically from 30 000 foot

195
00:08:37,679 --> 00:08:40,740
overview you can have payload delivery

196
00:08:40,740 --> 00:08:42,659
in two ways you can either have a

197
00:08:42,659 --> 00:08:46,260
dynamic delivery your standard uh you

198
00:08:46,260 --> 00:08:48,060
know you have a Stager that is very

199
00:08:48,060 --> 00:08:50,820
small that doesn't do much then possibly

200
00:08:50,820 --> 00:08:52,920
you go out on the network connect to

201
00:08:52,920 --> 00:08:56,100
your C2 bring the another stage uh

202
00:08:56,100 --> 00:08:58,920
somehow launch it up execute it and on

203
00:08:58,920 --> 00:09:00,480
and on and on you go

204
00:09:00,480 --> 00:09:02,760
you know hopefully to the very end where

205
00:09:02,760 --> 00:09:05,339
the actual payload you need happens to

206
00:09:05,339 --> 00:09:08,040
be running on the system

207
00:09:08,040 --> 00:09:10,500
um Dynamic is about 70 of the time in

208
00:09:10,500 --> 00:09:13,680
our in our cases right because you have

209
00:09:13,680 --> 00:09:14,839
this

210
00:09:14,839 --> 00:09:19,140
you have this gap between what EDR knows

211
00:09:19,140 --> 00:09:21,420
on the system as a stage and what it

212
00:09:21,420 --> 00:09:23,700
knows as a final product right when

213
00:09:23,700 --> 00:09:24,779
things run

214
00:09:24,779 --> 00:09:28,440
the static part is for very specific uh

215
00:09:28,440 --> 00:09:30,959
engagements for very specific reasons

216
00:09:30,959 --> 00:09:34,260
right when we say Okay Dynamic fails the

217
00:09:34,260 --> 00:09:36,540
loader is signatureable right it's

218
00:09:36,540 --> 00:09:39,899
everybody kind of knows whether it's uh

219
00:09:39,899 --> 00:09:42,180
an interpreter or maybe it's cobal

220
00:09:42,180 --> 00:09:43,800
strike or something like that

221
00:09:43,800 --> 00:09:45,600
but the static you can do a lot of

222
00:09:45,600 --> 00:09:47,820
different ways you can actually stretch

223
00:09:47,820 --> 00:09:50,459
the binary you can introduce a different

224
00:09:50,459 --> 00:09:52,980
entropy in the binary and so that static

225
00:09:52,980 --> 00:09:55,140
gets deployed there but the problem is

226
00:09:55,140 --> 00:09:58,380
it does only one thing right if you

227
00:09:58,380 --> 00:10:01,680
deploy that bundle in a static scenario

228
00:10:01,680 --> 00:10:04,740
uh you have detonation dependencies

229
00:10:04,740 --> 00:10:07,200
python is not there some compiler is not

230
00:10:07,200 --> 00:10:09,839
there maybe the ellipse is even you know

231
00:10:09,839 --> 00:10:11,339
augmented with something else we don't

232
00:10:11,339 --> 00:10:14,399
know right we can't really build static

233
00:10:14,399 --> 00:10:17,040
environment static payload outside of

234
00:10:17,040 --> 00:10:19,320
the company or we couldn't in this case

235
00:10:19,320 --> 00:10:21,779
and make sure it's 100 working on our

236
00:10:21,779 --> 00:10:22,800
side

237
00:10:22,800 --> 00:10:25,440
so the environment is the issue too

238
00:10:25,440 --> 00:10:27,779
and then Long Haul activation what do

239
00:10:27,779 --> 00:10:29,160
you do with the static thing it can only

240
00:10:29,160 --> 00:10:31,440
do one or two things right you need more

241
00:10:31,440 --> 00:10:35,519
functionality that sometimes uh uh is a

242
00:10:35,519 --> 00:10:39,660
um is an issue plus the uh you can't do

243
00:10:39,660 --> 00:10:42,300
a lot of a lot of dynamic things there

244
00:10:42,300 --> 00:10:43,800
as well

245
00:10:43,800 --> 00:10:45,899
and last but not least and we're gonna

246
00:10:45,899 --> 00:10:48,420
actually see the reason for it is the

247
00:10:48,420 --> 00:10:50,160
coupling variance when you compile your

248
00:10:50,160 --> 00:10:52,680
static payload uh everything is known

249
00:10:52,680 --> 00:10:55,680
about it right there are no sort of

250
00:10:55,680 --> 00:10:58,860
dependency for uh for evaluation what it

251
00:10:58,860 --> 00:11:01,079
does in a lot of ways

252
00:11:01,079 --> 00:11:03,660
that's it so uh so that that was the

253
00:11:03,660 --> 00:11:06,540
issue for us we wanted to do Dynamic but

254
00:11:06,540 --> 00:11:08,339
we couldn't do Dynamic we wanted to do

255
00:11:08,339 --> 00:11:10,320
static we couldn't do static so what do

256
00:11:10,320 --> 00:11:12,420
we do

257
00:11:12,420 --> 00:11:15,180
what if there is some hybrid approach

258
00:11:15,180 --> 00:11:19,260
what if we take the pluses from uh for

259
00:11:19,260 --> 00:11:22,380
example Dynamic side and apply it to the

260
00:11:22,380 --> 00:11:26,820
static or vice versa so we decided that

261
00:11:26,820 --> 00:11:30,320
from the dynamic side the plus would be

262
00:11:30,320 --> 00:11:32,579
the last chance of detection if it's

263
00:11:32,579 --> 00:11:35,220
small or somehow abstracted from already

264
00:11:35,220 --> 00:11:37,459
known binaries right

265
00:11:37,459 --> 00:11:40,700
Dynamic is also having more flexibility

266
00:11:40,700 --> 00:11:44,279
but the undesired static State Trace

267
00:11:44,279 --> 00:11:48,180
that we need to remove is the um you

268
00:11:48,180 --> 00:11:50,820
know the close coupled loader for the

269
00:11:50,820 --> 00:11:53,339
elf binary it's a greater size if you

270
00:11:53,339 --> 00:11:55,620
want to do everything in one thing and

271
00:11:55,620 --> 00:11:57,240
then it also has more chances of

272
00:11:57,240 --> 00:11:58,740
detection because

273
00:11:58,740 --> 00:12:00,540
everything is sort of known about the

274
00:12:00,540 --> 00:12:02,579
static side

275
00:12:02,579 --> 00:12:04,680
thinking through why static is out of

276
00:12:04,680 --> 00:12:06,360
favor is because of that all these

277
00:12:06,360 --> 00:12:08,579
minuses let's match them up together

278
00:12:08,579 --> 00:12:12,120
right can we improve static delivery

279
00:12:12,120 --> 00:12:14,519
it seems on the first case it's not

280
00:12:14,519 --> 00:12:16,320
possible Right you either do dynamic or

281
00:12:16,320 --> 00:12:19,380
you do static but can we actually uh try

282
00:12:19,380 --> 00:12:22,860
to try to solve this issue

283
00:12:22,860 --> 00:12:24,839
went back to the drawing board start

284
00:12:24,839 --> 00:12:28,380
thinking what are we doing wrong we

285
00:12:28,380 --> 00:12:30,660
when the static route because Dynamic

286
00:12:30,660 --> 00:12:32,519
was shut down the static was the way to

287
00:12:32,519 --> 00:12:34,320
go for us

288
00:12:34,320 --> 00:12:38,100
um first mistake was okay we place the

289
00:12:38,100 --> 00:12:41,880
uh the payload buffer uh we pay we we

290
00:12:41,880 --> 00:12:44,279
place the payload into a buffer that is

291
00:12:44,279 --> 00:12:46,560
in the data section right so when you

292
00:12:46,560 --> 00:12:49,019
compile something everything is in the

293
00:12:49,019 --> 00:12:51,600
data section you can inspect it uh and

294
00:12:51,600 --> 00:12:54,360
you can deliver that binary it's it's

295
00:12:54,360 --> 00:12:58,079
very transparent so every every single

296
00:12:58,079 --> 00:12:59,940
attempt that we tried I've you know got

297
00:12:59,940 --> 00:13:01,860
picked up by that uh you know linear

298
00:13:01,860 --> 00:13:04,380
buffer and we were done

299
00:13:04,380 --> 00:13:07,800
the other idea was to say okay well if

300
00:13:07,800 --> 00:13:09,660
you're going and inspecting the data

301
00:13:09,660 --> 00:13:11,700
buffers uh are you also going and

302
00:13:11,700 --> 00:13:14,160
inspecting these sections what's in the

303
00:13:14,160 --> 00:13:16,320
section right in the previous talk we

304
00:13:16,320 --> 00:13:19,560
talked we saw the bind section uh for

305
00:13:19,560 --> 00:13:22,079
ebbf a similar thing can be done

306
00:13:22,079 --> 00:13:25,139
manually with elf binary so you can

307
00:13:25,139 --> 00:13:28,019
basically say here's a code

308
00:13:28,019 --> 00:13:30,779
um you can say okay we'll place that

309
00:13:30,779 --> 00:13:32,459
stack or that's

310
00:13:32,459 --> 00:13:36,060
um that that buffer with a payload into

311
00:13:36,060 --> 00:13:38,639
a specific session section compile it

312
00:13:38,639 --> 00:13:41,040
and then somehow reach to it and

313
00:13:41,040 --> 00:13:43,980
retrieve it right you can do mem copy

314
00:13:43,980 --> 00:13:46,560
from your from your hosting

315
00:13:46,560 --> 00:13:47,160
um

316
00:13:47,160 --> 00:13:49,200
uh executable and reach out to the

317
00:13:49,200 --> 00:13:51,180
address of of your buffer in a different

318
00:13:51,180 --> 00:13:54,600
section retrieve it in your goal right

319
00:13:54,600 --> 00:13:56,839
that did not work

320
00:13:56,839 --> 00:13:59,459
another thing we tried was all right

321
00:13:59,459 --> 00:14:01,260
well if you're not if if you're not

322
00:14:01,260 --> 00:14:03,240
doing it on the compiler level maybe

323
00:14:03,240 --> 00:14:06,000
something to do with the compiler let's

324
00:14:06,000 --> 00:14:07,980
go down to assembly and basically say

325
00:14:07,980 --> 00:14:10,500
okay well take the binary the payload

326
00:14:10,500 --> 00:14:13,500
let's just say Metasploit right stuff it

327
00:14:13,500 --> 00:14:16,800
into a section but do it through um

328
00:14:16,800 --> 00:14:18,779
um the binary inclusion

329
00:14:18,779 --> 00:14:20,940
so should accomplish the same way only

330
00:14:20,940 --> 00:14:23,100
you do not have the linking through the

331
00:14:23,100 --> 00:14:25,320
compiler you just have a direct uh

332
00:14:25,320 --> 00:14:27,120
derived placement there

333
00:14:27,120 --> 00:14:29,820
retrieval and code is very similar to uh

334
00:14:29,820 --> 00:14:31,920
to previously you find a memory location

335
00:14:31,920 --> 00:14:34,380
and you go

336
00:14:34,380 --> 00:14:37,500
all right that did not work

337
00:14:37,500 --> 00:14:40,740
okay so all right let's go deeper into

338
00:14:40,740 --> 00:14:43,260
assembly let's just write everything out

339
00:14:43,260 --> 00:14:46,079
let's just do inline C code with

340
00:14:46,079 --> 00:14:48,420
assembling let's just Define the the

341
00:14:48,420 --> 00:14:50,519
section with prog bits that it needs to

342
00:14:50,519 --> 00:14:52,380
get into the memory load it into the

343
00:14:52,380 --> 00:14:53,639
memory

344
00:14:53,639 --> 00:14:58,199
and uh we use the a package from a

345
00:14:58,199 --> 00:15:00,839
different open source package to do that

346
00:15:00,839 --> 00:15:02,839
uh to try to do exactly the same thing

347
00:15:02,839 --> 00:15:05,040
basically we're trying to find out what

348
00:15:05,040 --> 00:15:07,740
kills us we have no way of knowing we do

349
00:15:07,740 --> 00:15:10,199
not have access to the EDR console we do

350
00:15:10,199 --> 00:15:11,880
not have any feedback we just basically

351
00:15:11,880 --> 00:15:13,620
get a knock on the you know on the door

352
00:15:13,620 --> 00:15:15,120
say Hey guys you're still here we

353
00:15:15,120 --> 00:15:16,860
already know you're here

354
00:15:16,860 --> 00:15:20,180
all right so that didn't work

355
00:15:20,180 --> 00:15:22,560
uh really really going back to the

356
00:15:22,560 --> 00:15:24,660
drawing board starting sourcing the

357
00:15:24,660 --> 00:15:25,980
ideas

358
00:15:25,980 --> 00:15:28,560
um start looking at the elf format

359
00:15:28,560 --> 00:15:32,060
start thinking okay

360
00:15:32,160 --> 00:15:36,120
here's what uh elf uh really real binary

361
00:15:36,120 --> 00:15:39,720
really is a bunch of sections on a disk

362
00:15:39,720 --> 00:15:41,820
right that somehow gets into the

363
00:15:41,820 --> 00:15:44,040
segments onto the memory it's not always

364
00:15:44,040 --> 00:15:47,040
one for one some things are loaded some

365
00:15:47,040 --> 00:15:49,380
things are not some things are staying

366
00:15:49,380 --> 00:15:51,600
on a disk to describe the executable you

367
00:15:51,600 --> 00:15:53,760
can strip it all out but what really

368
00:15:53,760 --> 00:15:57,839
goes on right and what we

369
00:15:57,839 --> 00:16:00,680
found out is that

370
00:16:00,680 --> 00:16:04,500
operating system loader the ld.so when

371
00:16:04,500 --> 00:16:06,360
it loads the elf

372
00:16:06,360 --> 00:16:08,339
it doesn't actually load all the

373
00:16:08,339 --> 00:16:10,800
sections into the memory right it's

374
00:16:10,800 --> 00:16:12,839
governed by the flags called PT load

375
00:16:12,839 --> 00:16:16,019
right you basically say Okay I want this

376
00:16:16,019 --> 00:16:17,760
section to be loaded into the memory

377
00:16:17,760 --> 00:16:20,000
because it contains something useful

378
00:16:20,000 --> 00:16:22,380
compiler abstracts all of it from you

379
00:16:22,380 --> 00:16:27,000
right but since we need to do more we

380
00:16:27,000 --> 00:16:28,500
say all right well why don't we take

381
00:16:28,500 --> 00:16:31,019
advantage of that trade that uh

382
00:16:31,019 --> 00:16:32,940
operating system doesn't always load all

383
00:16:32,940 --> 00:16:35,279
the sections

384
00:16:35,279 --> 00:16:36,660
okay

385
00:16:36,660 --> 00:16:41,100
a real issue upon a multitude of hours

386
00:16:41,100 --> 00:16:43,740
of uh kind of trial and error is that

387
00:16:43,740 --> 00:16:46,139
we're betrayed by the compiler

388
00:16:46,139 --> 00:16:48,740
the compiler actually is not our friend

389
00:16:48,740 --> 00:16:53,040
uh because it we do not control what it

390
00:16:53,040 --> 00:16:54,959
places into the binary we do not control

391
00:16:54,959 --> 00:16:57,540
how it links all the sections and we do

392
00:16:57,540 --> 00:17:00,420
not control how the load your LD data so

393
00:17:00,420 --> 00:17:03,300
we'll see the binary compiler does its

394
00:17:03,300 --> 00:17:05,400
own thing it needs to get a program

395
00:17:05,400 --> 00:17:08,160
loaded right and that's its main purpose

396
00:17:08,160 --> 00:17:10,380
but it's not our friend

397
00:17:10,380 --> 00:17:13,619
okay so let's go through the ways of how

398
00:17:13,619 --> 00:17:15,359
it's not our friend

399
00:17:15,359 --> 00:17:19,020
uh we already mentioned that PT load is

400
00:17:19,020 --> 00:17:21,780
is not our friend because once it's in

401
00:17:21,780 --> 00:17:24,059
memory it gets inspected right the way

402
00:17:24,059 --> 00:17:27,240
EDR works on the unwrap it kind of goes

403
00:17:27,240 --> 00:17:29,100
through the memory and says okay I see

404
00:17:29,100 --> 00:17:31,860
some uh some interesting things even

405
00:17:31,860 --> 00:17:34,679
though you've modified the uh the flags

406
00:17:34,679 --> 00:17:37,200
on the section read write execute you

407
00:17:37,200 --> 00:17:39,600
remove the the write and execute then

408
00:17:39,600 --> 00:17:42,419
you added one I still detect you all

409
00:17:42,419 --> 00:17:43,500
right fine

410
00:17:43,500 --> 00:17:47,220
what do we do forego the compiler forego

411
00:17:47,220 --> 00:17:49,080
the linking but then the question

412
00:17:49,080 --> 00:17:50,400
becomes

413
00:17:50,400 --> 00:17:53,460
how do we construct this binary

414
00:17:53,460 --> 00:17:55,200
okay

415
00:17:55,200 --> 00:17:58,500
the path to constructing such binary uh

416
00:17:58,500 --> 00:18:00,380
the answer to that or at least the hint

417
00:18:00,380 --> 00:18:04,500
was right there right because

418
00:18:04,500 --> 00:18:07,020
the operating system loader does not

419
00:18:07,020 --> 00:18:09,419
load all the sections

420
00:18:09,419 --> 00:18:11,760
what are the sections and what types of

421
00:18:11,760 --> 00:18:14,100
the sections that it doesn't load

422
00:18:14,100 --> 00:18:16,679
and one of it is sht node for example

423
00:18:16,679 --> 00:18:19,020
right it's something that every

424
00:18:19,020 --> 00:18:21,419
executable on Linux well almost every

425
00:18:21,419 --> 00:18:23,520
executable on Linux has it just

426
00:18:23,520 --> 00:18:25,799
basically has a structure where it says

427
00:18:25,799 --> 00:18:27,480
all right it was compiled in such a way

428
00:18:27,480 --> 00:18:31,440
here's the ABI version maybe some

429
00:18:31,440 --> 00:18:33,660
licensing version things like this

430
00:18:33,660 --> 00:18:35,280
something that is being used by the

431
00:18:35,280 --> 00:18:38,520
compiler but not necessarily part of the

432
00:18:38,520 --> 00:18:40,799
execution itself

433
00:18:40,799 --> 00:18:44,220
okay so let's try let's go with that

434
00:18:44,220 --> 00:18:47,340
here we basically say all right well not

435
00:18:47,340 --> 00:18:49,080
only that it doesn't load into the

436
00:18:49,080 --> 00:18:51,539
memory directly but it has a very

437
00:18:51,539 --> 00:18:54,480
convenient structure of Records

438
00:18:54,480 --> 00:18:56,280
structure of Records means we can

439
00:18:56,280 --> 00:18:58,200
actually do multiple

440
00:18:58,200 --> 00:19:00,360
payloads we can do store multiple

441
00:19:00,360 --> 00:19:03,840
disparate addressable kind of bins of

442
00:19:03,840 --> 00:19:05,220
data in it

443
00:19:05,220 --> 00:19:07,919
that's useful maybe we can Implement

444
00:19:07,919 --> 00:19:11,039
something that will help with with what

445
00:19:11,039 --> 00:19:13,799
we're trying to do okay

446
00:19:13,799 --> 00:19:15,660
Okay so

447
00:19:15,660 --> 00:19:18,840
if the compiler is not our

448
00:19:18,840 --> 00:19:20,880
friend

449
00:19:20,880 --> 00:19:23,340
then how do we make sure we can actually

450
00:19:23,340 --> 00:19:25,620
decouple the payload from the executable

451
00:19:25,620 --> 00:19:27,000
itself

452
00:19:27,000 --> 00:19:29,700
so so far the ideas are

453
00:19:29,700 --> 00:19:32,940
to create a dormant section in an Elf

454
00:19:32,940 --> 00:19:35,820
image it's dormant it's not loaded right

455
00:19:35,820 --> 00:19:37,679
it doesn't have prog bits it doesn't

456
00:19:37,679 --> 00:19:40,500
have PT load in it it's just sitting

457
00:19:40,500 --> 00:19:41,580
there it's

458
00:19:41,580 --> 00:19:43,260
dormant

459
00:19:43,260 --> 00:19:45,900
don't load it in memory by the operating

460
00:19:45,900 --> 00:19:48,419
system loader check

461
00:19:48,419 --> 00:19:51,059
but then how do we find it how do we

462
00:19:51,059 --> 00:19:54,120
address it right the plus side is that

463
00:19:54,120 --> 00:19:56,640
we've we've decoupled where the payload

464
00:19:56,640 --> 00:19:59,340
lives from the actual loader but it

465
00:19:59,340 --> 00:20:01,380
needs to talk to it somehow

466
00:20:01,380 --> 00:20:04,260
okay and the issue is if we compile it

467
00:20:04,260 --> 00:20:06,000
there's going to be still tight coupling

468
00:20:06,000 --> 00:20:08,880
of the memory address to the section to

469
00:20:08,880 --> 00:20:11,820
the payload or a set of payloads

470
00:20:11,820 --> 00:20:13,080
okay

471
00:20:13,080 --> 00:20:15,900
so what we do we basically say all right

472
00:20:15,900 --> 00:20:18,000
let's let's run with it let's stuff our

473
00:20:18,000 --> 00:20:21,360
payload into a node section leave it be

474
00:20:21,360 --> 00:20:24,600
we'll solve The Next Step later

475
00:20:24,600 --> 00:20:25,620
foreign

476
00:20:25,620 --> 00:20:29,700
so we now want to create uh an elf

477
00:20:29,700 --> 00:20:31,860
section that is outside of the loader

478
00:20:31,860 --> 00:20:33,299
loader

479
00:20:33,299 --> 00:20:35,700
cannot be operating system loader it has

480
00:20:35,700 --> 00:20:38,220
to be our loader that basically says go

481
00:20:38,220 --> 00:20:41,280
to this section find it load it up and

482
00:20:41,280 --> 00:20:44,400
do whatever you want okay

483
00:20:44,400 --> 00:20:46,740
how do we do this you don't have any

484
00:20:46,740 --> 00:20:49,140
tools I mean you do have tools in your

485
00:20:49,140 --> 00:20:50,700
lab you do have tools on the red side

486
00:20:50,700 --> 00:20:52,679
but you don't have any tools on the blue

487
00:20:52,679 --> 00:20:53,880
side

488
00:20:53,880 --> 00:20:55,740
how do you how do you actually

489
00:20:55,740 --> 00:20:57,179
instrument that

490
00:20:57,179 --> 00:20:59,880
well if we go back to the structure of

491
00:20:59,880 --> 00:21:03,960
the elf every section is delineated

492
00:21:03,960 --> 00:21:07,020
right by a memory address there's a map

493
00:21:07,020 --> 00:21:08,880
that basically says that's where it

494
00:21:08,880 --> 00:21:11,580
starts here's the size of it and you can

495
00:21:11,580 --> 00:21:14,820
calculate where it ends

496
00:21:14,820 --> 00:21:16,980
the offsets can be calculated directly

497
00:21:16,980 --> 00:21:20,539
if you have a map of it okay so why not

498
00:21:20,539 --> 00:21:24,900
have a agnostic binary

499
00:21:24,900 --> 00:21:26,520
the loader

500
00:21:26,520 --> 00:21:30,179
have a section somewhere in its own

501
00:21:30,179 --> 00:21:32,760
binary somewhere else in the binary and

502
00:21:32,760 --> 00:21:34,679
you basically attach it at the binary

503
00:21:34,679 --> 00:21:37,620
level not the API but basically at the

504
00:21:37,620 --> 00:21:40,440
offset right we teach the loader how to

505
00:21:40,440 --> 00:21:43,620
find a load is foreign data section it

506
00:21:43,620 --> 00:21:45,780
doesn't know anything about it it knows

507
00:21:45,780 --> 00:21:47,400
how to load it but it doesn't know

508
00:21:47,400 --> 00:21:48,840
anything about where it's loading it

509
00:21:48,840 --> 00:21:49,799
from

510
00:21:49,799 --> 00:21:52,140
so this is the docking part where you

511
00:21:52,140 --> 00:21:55,440
basically say hey loader you binary

512
00:21:55,440 --> 00:21:57,600
hey the section that is a standalone

513
00:21:57,600 --> 00:22:00,480
section with a payload just attached to

514
00:22:00,480 --> 00:22:03,900
itself it's sort of like a virus if you

515
00:22:03,900 --> 00:22:07,380
want to call it that way but we'll see

516
00:22:07,380 --> 00:22:09,179
how it's actually done

517
00:22:09,179 --> 00:22:10,799
okay

518
00:22:10,799 --> 00:22:13,919
so what are the advantages of the

519
00:22:13,919 --> 00:22:16,080
compiler is the problem and we need to

520
00:22:16,080 --> 00:22:18,600
decouple the payloads and yet we also

521
00:22:18,600 --> 00:22:21,240
need to avoid the operand system loader

522
00:22:21,240 --> 00:22:25,260
so now if we're compiling uh code into a

523
00:22:25,260 --> 00:22:28,039
section not attached to the executable

524
00:22:28,039 --> 00:22:30,720
compiling a loader a standalone

525
00:22:30,720 --> 00:22:33,360
executable and then

526
00:22:33,360 --> 00:22:37,520
we are uh we're gaining not only

527
00:22:37,520 --> 00:22:41,179
separation of two binaries but we also

528
00:22:41,179 --> 00:22:45,539
executing uh the loader without

529
00:22:45,539 --> 00:22:47,280
knowledge of what is going to be

530
00:22:47,280 --> 00:22:49,980
executing so if loader appears on the

531
00:22:49,980 --> 00:22:52,799
system and defense picks it up all it is

532
00:22:52,799 --> 00:22:54,659
is just basically a pointer to something

533
00:22:54,659 --> 00:22:56,159
it needs to load but it doesn't have any

534
00:22:56,159 --> 00:22:59,400
Trace to what it's loading right so it's

535
00:22:59,400 --> 00:23:01,200
kind of dynamic but it's really static

536
00:23:01,200 --> 00:23:03,000
because we are not reaching anywhere

537
00:23:03,000 --> 00:23:05,340
else we're not using other executables

538
00:23:05,340 --> 00:23:07,919
we are basically using the section but

539
00:23:07,919 --> 00:23:09,419
the loader doesn't know any anything

540
00:23:09,419 --> 00:23:11,280
about the section except for where to

541
00:23:11,280 --> 00:23:14,820
find it right okay so that that gives us

542
00:23:14,820 --> 00:23:16,320
a really really good

543
00:23:16,320 --> 00:23:19,980
um sort of pointer into uh

544
00:23:19,980 --> 00:23:23,340
into not using the API which is

545
00:23:23,340 --> 00:23:26,220
available through the compiler but use

546
00:23:26,220 --> 00:23:29,580
the ABI the binary interface that works

547
00:23:29,580 --> 00:23:32,159
inside of the elf

548
00:23:32,159 --> 00:23:35,340
um at this at the binary section level

549
00:23:35,340 --> 00:23:37,080
it's a little complex but we'll go

550
00:23:37,080 --> 00:23:40,679
through the details and demo uh for sure

551
00:23:40,679 --> 00:23:44,039
I would like to just point out at the at

552
00:23:44,039 --> 00:23:46,080
the bottom with where it says the C is

553
00:23:46,080 --> 00:23:49,799
the C code so we're not moving we're

554
00:23:49,799 --> 00:23:52,140
moving from C code into something that

555
00:23:52,140 --> 00:23:55,799
is um is is basically

556
00:23:55,799 --> 00:23:56,460
um

557
00:23:56,460 --> 00:23:57,840
oops

558
00:23:57,840 --> 00:24:00,059
too far

559
00:24:00,059 --> 00:24:02,700
okay so on the bottom we are not

560
00:24:02,700 --> 00:24:04,080
compiling C code we're basically

561
00:24:04,080 --> 00:24:05,520
attaching the binary

562
00:24:05,520 --> 00:24:10,080
that's our hybrid unit of payload

563
00:24:10,080 --> 00:24:13,760
carrying capacity okay

564
00:24:15,720 --> 00:24:17,700
what is binary compatibility a section

565
00:24:17,700 --> 00:24:19,260
level

566
00:24:19,260 --> 00:24:21,240
we have the injector

567
00:24:21,240 --> 00:24:23,460
we have the loader

568
00:24:23,460 --> 00:24:27,600
and we have uh somewhere a section a

569
00:24:27,600 --> 00:24:29,220
section can be attached to the loader

570
00:24:29,220 --> 00:24:31,799
itself right but the loader doesn't know

571
00:24:31,799 --> 00:24:33,360
anything about it just knows that it

572
00:24:33,360 --> 00:24:34,740
needs to go somewhere in the disk and

573
00:24:34,740 --> 00:24:37,799
lifts it up right so so we start looking

574
00:24:37,799 --> 00:24:41,039
at the system where the system is split

575
00:24:41,039 --> 00:24:44,520
in between creating a loader creating a

576
00:24:44,520 --> 00:24:45,600
payload

577
00:24:45,600 --> 00:24:48,299
and delivering it all in one executable

578
00:24:48,299 --> 00:24:50,340
but the sections do not know about each

579
00:24:50,340 --> 00:24:52,520
other

580
00:24:53,039 --> 00:24:55,559
what do we get static elf loader it's

581
00:24:55,559 --> 00:24:58,500
Standalone it doesn't have payloads

582
00:24:58,500 --> 00:25:00,900
it has generic mechanisms to load

583
00:25:00,900 --> 00:25:02,820
sections on demand

584
00:25:02,820 --> 00:25:05,280
and bootstrap the payload from it

585
00:25:05,280 --> 00:25:07,799
the the key understanding here is the

586
00:25:07,799 --> 00:25:09,360
elf loader doesn't know anything about

587
00:25:09,360 --> 00:25:12,120
what it does it doesn't need to change

588
00:25:12,120 --> 00:25:16,440
uh what it has it doesn't need to change

589
00:25:16,440 --> 00:25:20,460
any permissions on the uh memory section

590
00:25:20,460 --> 00:25:22,740
it doesn't need to manage any kind of

591
00:25:22,740 --> 00:25:24,960
dependency through the code all it needs

592
00:25:24,960 --> 00:25:27,720
to do is say Okay somewhere in my binary

593
00:25:27,720 --> 00:25:29,100
somewhere

594
00:25:29,100 --> 00:25:32,940
I am going to go and load something and

595
00:25:32,940 --> 00:25:34,200
then I'm going to give it to somebody

596
00:25:34,200 --> 00:25:36,960
else that's somebody else is coming as a

597
00:25:36,960 --> 00:25:40,679
later stage but so far we have this

598
00:25:40,679 --> 00:25:42,779
static loader that is agnostic to the

599
00:25:42,779 --> 00:25:43,919
payload

600
00:25:43,919 --> 00:25:46,200
the sectional payload the payload is

601
00:25:46,200 --> 00:25:48,299
inside of that section is created

602
00:25:48,299 --> 00:25:51,179
separately in a lab or on the red side

603
00:25:51,179 --> 00:25:53,340
it can also be created at the company

604
00:25:53,340 --> 00:25:54,419
side

605
00:25:54,419 --> 00:25:56,940
provided there is a compiler but we're

606
00:25:56,940 --> 00:26:00,419
not taking this into account here

607
00:26:00,419 --> 00:26:02,940
sectional payload is docked to the

608
00:26:02,940 --> 00:26:05,520
loader itself at the binary level not a

609
00:26:05,520 --> 00:26:07,020
compilation level

610
00:26:07,020 --> 00:26:10,260
and it can be reduct right if you have

611
00:26:10,260 --> 00:26:12,299
another payload you take one out Place

612
00:26:12,299 --> 00:26:14,220
one another one in

613
00:26:14,220 --> 00:26:16,799
so you achieve better dormancy control

614
00:26:16,799 --> 00:26:19,799
what if you deploy something and then

615
00:26:19,799 --> 00:26:21,539
you need to stay dormant for a month

616
00:26:21,539 --> 00:26:24,720
right you basically can have a table of

617
00:26:24,720 --> 00:26:26,940
contents for different payloads when

618
00:26:26,940 --> 00:26:28,260
they need to trigger and how they need

619
00:26:28,260 --> 00:26:30,659
to trigger and you don't need to use the

620
00:26:30,659 --> 00:26:32,400
dynamic fetch from the uh from the

621
00:26:32,400 --> 00:26:34,580
network

622
00:26:36,240 --> 00:26:38,400
another thing that we needed to fix

623
00:26:38,400 --> 00:26:41,220
remember we talked about the uh

624
00:26:41,220 --> 00:26:43,380
packed executables we needed to bring

625
00:26:43,380 --> 00:26:45,659
impact it because it's it had the tools

626
00:26:45,659 --> 00:26:46,919
that we needed

627
00:26:46,919 --> 00:26:49,860
however Frozen binaries are almost

628
00:26:49,860 --> 00:26:51,600
impossible to work with because of the

629
00:26:51,600 --> 00:26:53,539
dependencies if you need to

630
00:26:53,539 --> 00:26:55,860
achieve a little bit more than just the

631
00:26:55,860 --> 00:26:57,840
default run right

632
00:26:57,840 --> 00:27:01,320
so by making multiple sections with

633
00:27:01,320 --> 00:27:03,840
payloads or stuffing multiple payloads

634
00:27:03,840 --> 00:27:08,039
in that sht node records we can have

635
00:27:08,039 --> 00:27:10,799
packing without using upx for example

636
00:27:10,799 --> 00:27:12,480
we're not without using any kind of

637
00:27:12,480 --> 00:27:15,179
compression and without creating the

638
00:27:15,179 --> 00:27:16,860
temporary files when you're actually

639
00:27:16,860 --> 00:27:19,260
trying to go and find that sectional

640
00:27:19,260 --> 00:27:20,340
payload

641
00:27:20,340 --> 00:27:23,760
so docking allows us to do that sort of

642
00:27:23,760 --> 00:27:27,059
alternative way of kind of packing

643
00:27:27,059 --> 00:27:30,419
um multiple executables into one image

644
00:27:30,419 --> 00:27:32,940
and over no overhead right you don't

645
00:27:32,940 --> 00:27:36,299
need to do any kind of compression on it

646
00:27:36,299 --> 00:27:38,220
in-memory options we'll talk about in

647
00:27:38,220 --> 00:27:40,760
memory options that it gets us

648
00:27:40,760 --> 00:27:45,120
and really it still is a correct uh elf

649
00:27:45,120 --> 00:27:47,159
executable it runs it does what it needs

650
00:27:47,159 --> 00:27:49,559
to do and uh we're basically solving our

651
00:27:49,559 --> 00:27:52,740
multiple problems here

652
00:27:52,740 --> 00:27:54,720
here's the kicker here's the injector

653
00:27:54,720 --> 00:27:56,700
bonus the injector that

654
00:27:56,700 --> 00:27:57,419
um

655
00:27:57,419 --> 00:27:59,820
has this section in it

656
00:27:59,820 --> 00:28:02,279
what's it to say that I cannot have two

657
00:28:02,279 --> 00:28:05,159
injectors on the system and one injector

658
00:28:05,159 --> 00:28:07,679
can take Section from another binary and

659
00:28:07,679 --> 00:28:08,880
run it

660
00:28:08,880 --> 00:28:11,760
so EGR cannot chase that kind of stuff

661
00:28:11,760 --> 00:28:15,600
you cannot you our job as red team is to

662
00:28:15,600 --> 00:28:17,880
break the dependency of the flow of

663
00:28:17,880 --> 00:28:19,860
detection right and this is one way of

664
00:28:19,860 --> 00:28:22,860
doing it by saying all right not only

665
00:28:22,860 --> 00:28:24,960
I'm allowed to find my own section

666
00:28:24,960 --> 00:28:27,360
loaded up and you know there's no trace

667
00:28:27,360 --> 00:28:29,340
of what I'm doing but I can actually

668
00:28:29,340 --> 00:28:31,260
find another executable that somebody

669
00:28:31,260 --> 00:28:33,720
else brought in grab section out of it

670
00:28:33,720 --> 00:28:36,240
and do the same thing so now you're

671
00:28:36,240 --> 00:28:38,460
actually multi-processing right you're

672
00:28:38,460 --> 00:28:42,240
you're doing or yeah your your EDR needs

673
00:28:42,240 --> 00:28:43,860
to trace multiple processes to be able

674
00:28:43,860 --> 00:28:46,140
to see what what people are doing

675
00:28:46,140 --> 00:28:48,539
actually not even the process is a

676
00:28:48,539 --> 00:28:52,020
static static file in a disk

677
00:28:52,020 --> 00:28:53,340
okay

678
00:28:53,340 --> 00:28:55,799
all that culminates into elf pack

679
00:28:55,799 --> 00:28:57,960
Factory right

680
00:28:57,960 --> 00:29:00,120
some of it is done on the red side some

681
00:29:00,120 --> 00:29:02,460
of it is done on the blue side uh we're

682
00:29:02,460 --> 00:29:05,159
using injectors freely we're marrying

683
00:29:05,159 --> 00:29:09,000
key uh sections to different injectors

684
00:29:09,000 --> 00:29:12,179
and we basically deploy this whole cake

685
00:29:12,179 --> 00:29:15,600
to that uh hardened host and say eat it

686
00:29:15,600 --> 00:29:18,480
all right go try to detect that go go

687
00:29:18,480 --> 00:29:21,240
through your BPF controls go see what

688
00:29:21,240 --> 00:29:23,880
I'm doing the BPF Challenge and BPF

689
00:29:23,880 --> 00:29:26,039
fight is going to come next slide but

690
00:29:26,039 --> 00:29:29,220
essentially we split it into various

691
00:29:29,220 --> 00:29:32,460
things but they kind of work together

692
00:29:32,460 --> 00:29:33,720
okay

693
00:29:33,720 --> 00:29:36,720
the last issue is the fileless execution

694
00:29:36,720 --> 00:29:39,360
in memory on wrap okay

695
00:29:39,360 --> 00:29:42,299
now nobody tells us how the EDR works

696
00:29:42,299 --> 00:29:44,159
there right we somehow need to figure

697
00:29:44,159 --> 00:29:46,980
that out and one of the reasons we were

698
00:29:46,980 --> 00:29:50,039
failing once we got everything on it was

699
00:29:50,039 --> 00:29:53,520
because the launch itself was was

700
00:29:53,520 --> 00:29:57,120
detected right first we went with the

701
00:29:57,120 --> 00:29:59,640
option b which is the system mfdcreate

702
00:29:59,640 --> 00:30:01,500
it's a very

703
00:30:01,500 --> 00:30:04,440
I mean it's uh it's widely known as

704
00:30:04,440 --> 00:30:07,760
being used for fileless execution but

705
00:30:07,760 --> 00:30:10,200
what's a what's a poor man to do right

706
00:30:10,200 --> 00:30:12,299
the poor man needs to try so we tried

707
00:30:12,299 --> 00:30:15,440
that uh we did this with the lib reflect

708
00:30:15,440 --> 00:30:17,940
we essentially said okay here's the

709
00:30:17,940 --> 00:30:20,399
loader go find your section and then

710
00:30:20,399 --> 00:30:23,600
load it up into the memory uh directly

711
00:30:23,600 --> 00:30:26,580
uh got detected they said okay guys you

712
00:30:26,580 --> 00:30:28,679
can't do anything else here's your memfd

713
00:30:28,679 --> 00:30:31,500
Trace from BPF right here's your log

714
00:30:31,500 --> 00:30:33,840
okay so

715
00:30:33,840 --> 00:30:36,919
the real issue came with uh exactly

716
00:30:36,919 --> 00:30:41,240
exactly is this system call that allows

717
00:30:41,240 --> 00:30:44,399
Elf binaries or executables and Linux to

718
00:30:44,399 --> 00:30:46,500
actually exist as a process launch it up

719
00:30:46,500 --> 00:30:49,320
whether you are the loader or the system

720
00:30:49,320 --> 00:30:51,299
is the loader you still need to call it

721
00:30:51,299 --> 00:30:54,140
exact so you can actually build the uh

722
00:30:54,140 --> 00:30:57,480
the process and and launch it up

723
00:30:57,480 --> 00:31:02,640
so our last job was to to do away kill

724
00:31:02,640 --> 00:31:05,340
the exact ve how do we do this

725
00:31:05,340 --> 00:31:07,320
well we went with the option A which is

726
00:31:07,320 --> 00:31:10,620
the user user land exec right in the

727
00:31:10,620 --> 00:31:14,580
windows it can be thought uh of as a

728
00:31:14,580 --> 00:31:16,260
process hollowing right where you

729
00:31:16,260 --> 00:31:19,260
overlay your image on top of the running

730
00:31:19,260 --> 00:31:22,320
process and then you basically become

731
00:31:22,320 --> 00:31:24,779
somebody else or they become you

732
00:31:24,779 --> 00:31:26,520
so

733
00:31:26,520 --> 00:31:30,360
uh user user land exact is a really good

734
00:31:30,360 --> 00:31:33,419
thing it only is used for one specific

735
00:31:33,419 --> 00:31:35,580
issue to Overlay your own image with

736
00:31:35,580 --> 00:31:38,640
somebody else and go go do things there

737
00:31:38,640 --> 00:31:41,520
are trade-offs and downside for for both

738
00:31:41,520 --> 00:31:44,159
obviously system MFD creators is a lot

739
00:31:44,159 --> 00:31:45,480
more

740
00:31:45,480 --> 00:31:49,260
um detectable right but user land

741
00:31:49,260 --> 00:31:51,059
exactly only gives you one shot right

742
00:31:51,059 --> 00:31:52,919
you can spawn other processes because

743
00:31:52,919 --> 00:31:54,960
you you essentially overlaid yourself

744
00:31:54,960 --> 00:31:57,779
you can go back you can revert any error

745
00:31:57,779 --> 00:31:59,760
in your code kills you but we took a

746
00:31:59,760 --> 00:32:02,340
shot right we took a shot and by the way

747
00:32:02,340 --> 00:32:04,500
and you can't demonize itself when it

748
00:32:04,500 --> 00:32:06,840
launches so for a long persistence you

749
00:32:06,840 --> 00:32:08,940
have to use other things to

750
00:32:08,940 --> 00:32:11,700
to become a demon if you want to but for

751
00:32:11,700 --> 00:32:13,440
our intents and purposes use relent

752
00:32:13,440 --> 00:32:14,820
exact work

753
00:32:14,820 --> 00:32:17,700
we'll see how it gets detected and how

754
00:32:17,700 --> 00:32:20,700
it doesn't get detected

755
00:32:20,700 --> 00:32:24,240
so the static side what

756
00:32:24,240 --> 00:32:27,000
um what the defense saw

757
00:32:27,000 --> 00:32:31,020
the top part of the slide is we've taken

758
00:32:31,020 --> 00:32:35,460
uh msf metal which is the Linux payload

759
00:32:35,460 --> 00:32:37,399
for Metasploit

760
00:32:37,399 --> 00:32:41,159
and give it to the blue team they said

761
00:32:41,159 --> 00:32:43,620
okay well here's the bin walk you're

762
00:32:43,620 --> 00:32:45,840
completely matching towards our

763
00:32:45,840 --> 00:32:48,179
non-signature you're failing right

764
00:32:48,179 --> 00:32:51,260
the section payload done with elf pack

765
00:32:51,260 --> 00:32:56,220
on the same msf metal shows you that

766
00:32:56,220 --> 00:32:56,940
much

767
00:32:56,940 --> 00:32:59,039
and the less I don't know if you can see

768
00:32:59,039 --> 00:33:01,500
well but the last two lane lines on that

769
00:33:01,500 --> 00:33:04,620
is only my debugging to know that I'm

770
00:33:04,620 --> 00:33:06,360
actually running and to show the uh the

771
00:33:06,360 --> 00:33:08,520
blue team that is actually in executable

772
00:33:08,520 --> 00:33:10,799
right so essentially all you're saying

773
00:33:10,799 --> 00:33:13,860
all you're seeing is minimization of the

774
00:33:13,860 --> 00:33:16,500
signature between uh you know for the

775
00:33:16,500 --> 00:33:19,080
static uh for the static side to detect

776
00:33:19,080 --> 00:33:21,019
uh either the

777
00:33:21,019 --> 00:33:23,399
verbatim metal that gets deployed versus

778
00:33:23,399 --> 00:33:26,220
the elf packed one

779
00:33:26,220 --> 00:33:28,919
and uh the other thing the dynamic side

780
00:33:28,919 --> 00:33:32,159
uh you know the defense also was not

781
00:33:32,159 --> 00:33:35,519
sleeping on the uh uh on the dynamic

782
00:33:35,519 --> 00:33:38,399
side so they've created signatures for

783
00:33:38,399 --> 00:33:40,860
us right and Standalone payload for

784
00:33:40,860 --> 00:33:42,960
metal gives a signature that is quite

785
00:33:42,960 --> 00:33:45,299
different from a section pane load so

786
00:33:45,299 --> 00:33:47,340
you take the same metal and you elf

787
00:33:47,340 --> 00:33:48,360
packet

788
00:33:48,360 --> 00:33:51,659
turn it into intersection Chase it all

789
00:33:51,659 --> 00:33:54,360
you know however you need to do it then

790
00:33:54,360 --> 00:33:56,399
you deploy it and if they rely on

791
00:33:56,399 --> 00:33:58,500
Behavior which not a lot of edrs do but

792
00:33:58,500 --> 00:34:00,779
let's say they do they still have have a

793
00:34:00,779 --> 00:34:02,519
different match right so that was a win

794
00:34:02,519 --> 00:34:04,880
for us

795
00:34:05,399 --> 00:34:08,879
okay and then uh you also have

796
00:34:08,879 --> 00:34:09,780
um

797
00:34:09,780 --> 00:34:12,659
kind of you know description of

798
00:34:12,659 --> 00:34:14,940
first wave after the engagement we've

799
00:34:14,940 --> 00:34:18,418
created a uh signatures for for the elf

800
00:34:18,418 --> 00:34:20,460
bag give it to to the defender so now

801
00:34:20,460 --> 00:34:23,339
they can actually do signatures on that

802
00:34:23,339 --> 00:34:26,040
um but then we in turn also found out

803
00:34:26,040 --> 00:34:28,020
how they were doing the filtering they

804
00:34:28,020 --> 00:34:31,080
took uh Center memfd open and obviously

805
00:34:31,080 --> 00:34:34,800
uh or enter an exit for MFD that's how

806
00:34:34,800 --> 00:34:37,199
we got killed on version B right on the

807
00:34:37,199 --> 00:34:40,379
MFD create and they also tracked every

808
00:34:40,379 --> 00:34:42,300
single CIS exact like every single thing

809
00:34:42,300 --> 00:34:44,699
that gets executed on this on this host

810
00:34:44,699 --> 00:34:48,480
was uh was essentially

811
00:34:48,480 --> 00:34:51,599
um checked so we solved

812
00:34:51,599 --> 00:34:54,659
the exact result of the delivery we saw

813
00:34:54,659 --> 00:35:00,839
the uh bypass for uh BPF we've solved um

814
00:35:00,839 --> 00:35:04,859
uh linking right what else

815
00:35:04,859 --> 00:35:08,540
let's take a look at what we did

816
00:35:15,599 --> 00:35:18,359
okay I'm gonna try to walk through uh

817
00:35:18,359 --> 00:35:20,579
the screen is a little busy right but

818
00:35:20,579 --> 00:35:23,940
essentially is divided into just for the

819
00:35:23,940 --> 00:35:26,160
demo purposes divided into multiple

820
00:35:26,160 --> 00:35:28,760
screens you see the victim machine

821
00:35:28,760 --> 00:35:32,220
you've got the uh metasploid payload

822
00:35:32,220 --> 00:35:33,540
server listening on the background

823
00:35:33,540 --> 00:35:34,500
somewhere

824
00:35:34,500 --> 00:35:36,960
and you've got a couple of screen for

825
00:35:36,960 --> 00:35:40,560
BPF ndara rules right how they detect

826
00:35:40,560 --> 00:35:44,099
and then the triage code that needs to

827
00:35:44,099 --> 00:35:46,619
detect it and you know let's just go

828
00:35:46,619 --> 00:35:48,980
through that

829
00:35:52,200 --> 00:35:54,960
so on the bottom we're basically uh

830
00:35:54,960 --> 00:35:55,980
running

831
00:35:55,980 --> 00:35:59,460
that whole Factory for pre-built elf

832
00:35:59,460 --> 00:36:00,420
packing

833
00:36:00,420 --> 00:36:03,300
and the argument to it is we did some

834
00:36:03,300 --> 00:36:05,579
other things like we xored the the

835
00:36:05,579 --> 00:36:08,640
payload we extort the records in sht

836
00:36:08,640 --> 00:36:10,980
node we gave it a key just to be sure

837
00:36:10,980 --> 00:36:12,359
and Save

838
00:36:12,359 --> 00:36:15,980
so that's what we're going to do here

839
00:36:17,040 --> 00:36:20,099
okay so that's uh there's a payload

840
00:36:20,099 --> 00:36:22,400
server

841
00:36:28,140 --> 00:36:30,119
do I have any sessions hopefully we get

842
00:36:30,119 --> 00:36:32,540
sessions

843
00:36:32,760 --> 00:36:35,520
so let's go over the um the loading so

844
00:36:35,520 --> 00:36:38,460
we have the elf pack the packer that

845
00:36:38,460 --> 00:36:41,400
takes the loader agnostic to what it

846
00:36:41,400 --> 00:36:43,560
payload is right

847
00:36:43,560 --> 00:36:49,140
and then it takes the metal binary

848
00:36:50,460 --> 00:36:54,119
out of all this it creates a cradle

849
00:36:54,119 --> 00:36:56,220
or first stage however you want to call

850
00:36:56,220 --> 00:36:58,980
it right that that that's the thing that

851
00:36:58,980 --> 00:37:01,140
gets deployed to uh to the victim

852
00:37:01,140 --> 00:37:03,680
machine here

853
00:37:06,660 --> 00:37:09,140
okay

854
00:37:09,240 --> 00:37:11,520
then what we're doing we're sticking it

855
00:37:11,520 --> 00:37:13,320
into a buffer

856
00:37:13,320 --> 00:37:16,320
which mimics what a lot of Linux systems

857
00:37:16,320 --> 00:37:19,140
have they have this node new buff where

858
00:37:19,140 --> 00:37:22,260
they have the uh description of the API

859
00:37:22,260 --> 00:37:26,280
maybe licensing you know lib C

860
00:37:26,280 --> 00:37:29,700
things usually it's not very big but we

861
00:37:29,700 --> 00:37:32,820
make it big by sticking things in it we

862
00:37:32,820 --> 00:37:36,599
are instructing it which type of

863
00:37:36,599 --> 00:37:38,940
section is going to be

864
00:37:38,940 --> 00:37:41,460
right and then something that we did on

865
00:37:41,460 --> 00:37:42,920
top of it that's

866
00:37:42,920 --> 00:37:45,599
the xoring and then we give it a key

867
00:37:45,599 --> 00:37:48,000
right pretty straightforward

868
00:37:48,000 --> 00:37:50,160
just for static analysis

869
00:37:50,160 --> 00:37:53,640
okay and then we have so so in this

870
00:37:53,640 --> 00:37:55,859
Factory we have options to either do

871
00:37:55,859 --> 00:37:59,339
memfd or do user exec or maybe do

872
00:37:59,339 --> 00:38:02,460
demonization backgrounding whatever the

873
00:38:02,460 --> 00:38:05,160
case may be and also passing arguments

874
00:38:05,160 --> 00:38:07,619
to uh to our payload let's say metal can

875
00:38:07,619 --> 00:38:10,920
have its own arguments that it kind of

876
00:38:10,920 --> 00:38:12,660
needs to

877
00:38:12,660 --> 00:38:13,200
um

878
00:38:13,200 --> 00:38:16,560
work with so anyway this is all kind of

879
00:38:16,560 --> 00:38:18,780
part of that factory that um

880
00:38:18,780 --> 00:38:21,599
that's working some of it is done in the

881
00:38:21,599 --> 00:38:23,820
lab but just for for the sake of time we

882
00:38:23,820 --> 00:38:27,800
kind of did it in one place

883
00:38:30,180 --> 00:38:32,339
okay so let's load and bootstrap the

884
00:38:32,339 --> 00:38:34,700
implant

885
00:38:35,579 --> 00:38:38,700
we've launched it with um memfd right

886
00:38:38,700 --> 00:38:42,379
we're going to see the detection for it

887
00:38:46,320 --> 00:38:47,940
first the Callback of course everybody

888
00:38:47,940 --> 00:38:51,560
likes to to see a session

889
00:38:52,200 --> 00:38:54,660
all right we've got the session on it

890
00:38:54,660 --> 00:38:56,880
make sure that

891
00:38:56,880 --> 00:38:59,720
it's working

892
00:39:06,480 --> 00:39:08,700
it's working meaning that it's a viable

893
00:39:08,700 --> 00:39:11,240
elf

894
00:39:11,339 --> 00:39:13,800
so kinase

895
00:39:13,800 --> 00:39:15,480
gives you the process table and then

896
00:39:15,480 --> 00:39:17,339
we're going back and try to relaunch

897
00:39:17,339 --> 00:39:18,800
with

898
00:39:18,800 --> 00:39:21,839
user exec

899
00:39:21,839 --> 00:39:25,279
let's see what it does next

900
00:39:28,680 --> 00:39:30,900
okay so for detection

901
00:39:30,900 --> 00:39:32,820
I want to show you

902
00:39:32,820 --> 00:39:35,640
the code that they've used for BPF or

903
00:39:35,640 --> 00:39:38,220
ebpf in this case right it's it's a

904
00:39:38,220 --> 00:39:39,900
description file where they say all

905
00:39:39,900 --> 00:39:41,880
right every time you see

906
00:39:41,880 --> 00:39:45,900
uh mem assist Center exec or use ucsys

907
00:39:45,900 --> 00:39:49,140
enter MMD create uh alert on it this is

908
00:39:49,140 --> 00:39:52,020
a trivial rule but essentially the ER

909
00:39:52,020 --> 00:39:54,000
Builds on it and then does something

910
00:39:54,000 --> 00:39:56,099
else with it but detection part is what

911
00:39:56,099 --> 00:39:57,359
they've used

912
00:39:57,359 --> 00:40:00,960
as a contrived example here right so

913
00:40:00,960 --> 00:40:04,040
that's what has been killing us here

914
00:40:04,040 --> 00:40:07,560
now we're deploying this BPF Trace so

915
00:40:07,560 --> 00:40:09,420
we're taking rules and we're saying all

916
00:40:09,420 --> 00:40:12,599
right we're going to act as an EDR

917
00:40:12,599 --> 00:40:15,060
attaching five Pros five five things

918
00:40:15,060 --> 00:40:16,400
that it needs to do

919
00:40:16,400 --> 00:40:21,740
relaunching our thing with user exec

920
00:40:23,579 --> 00:40:25,220
okay

921
00:40:25,220 --> 00:40:28,320
going back to to the thing and what we

922
00:40:28,320 --> 00:40:30,540
see is that the execution of things to

923
00:40:30,540 --> 00:40:32,520
build it right

924
00:40:32,520 --> 00:40:34,560
we're just showing this for as an

925
00:40:34,560 --> 00:40:36,300
example this will never happen on the

926
00:40:36,300 --> 00:40:37,920
victim side but it will just happen in

927
00:40:37,920 --> 00:40:41,579
the lab is that elf pack loader Stager

928
00:40:41,579 --> 00:40:43,800
and where it needs to do and this is the

929
00:40:43,800 --> 00:40:46,020
execution of the

930
00:40:46,020 --> 00:40:48,599
of the actual cradle and the only system

931
00:40:48,599 --> 00:40:50,280
call that it

932
00:40:50,280 --> 00:40:52,619
has is the host name the hostname is

933
00:40:52,619 --> 00:40:54,300
coming from metal because it needs to go

934
00:40:54,300 --> 00:40:56,160
out and grab something right so

935
00:40:56,160 --> 00:40:58,260
essentially no exact

936
00:40:58,260 --> 00:41:01,859
no memfd enter just a basic host name

937
00:41:01,859 --> 00:41:03,960
and even if you recompile metal you can

938
00:41:03,960 --> 00:41:05,940
probably stick an IP in it and we'll

939
00:41:05,940 --> 00:41:09,240
never call that okay so

940
00:41:09,240 --> 00:41:12,300
was clean for us from that perspective

941
00:41:12,300 --> 00:41:15,720
right no detection on it we were able to

942
00:41:15,720 --> 00:41:18,180
do it on the uh on the host with no

943
00:41:18,180 --> 00:41:20,820
compilers no interpreters

944
00:41:20,820 --> 00:41:25,339
um heavy tracing of our activities

945
00:41:25,500 --> 00:41:28,140
uh yeah and again it's a viable session

946
00:41:28,140 --> 00:41:30,180
where we're looking at it and and for

947
00:41:30,180 --> 00:41:31,800
those who are interested we're just

948
00:41:31,800 --> 00:41:33,540
showing you the

949
00:41:33,540 --> 00:41:36,060
um the yard rules you can actually take

950
00:41:36,060 --> 00:41:38,460
the UR rules and start detecting that

951
00:41:38,460 --> 00:41:39,720
sort of

952
00:41:39,720 --> 00:41:40,500
um

953
00:41:40,500 --> 00:41:41,880
uh

954
00:41:41,880 --> 00:41:44,160
technique right

955
00:41:44,160 --> 00:41:46,859
you basically say okay well maybe I can

956
00:41:46,859 --> 00:41:49,320
inspect the session section and maybe if

957
00:41:49,320 --> 00:41:52,079
it's larger than x bytes maybe there's a

958
00:41:52,079 --> 00:41:55,440
payload in it right because sht node

959
00:41:55,440 --> 00:41:57,720
should never have any any data it's very

960
00:41:57,720 --> 00:41:59,460
rare than it does

961
00:41:59,460 --> 00:42:02,099
but here it is right

962
00:42:02,099 --> 00:42:04,920
so you can prototype productize it if

963
00:42:04,920 --> 00:42:09,200
you write your EDR and you can use that

964
00:42:09,420 --> 00:42:12,000
it's kind of shows the size of it the

965
00:42:12,000 --> 00:42:14,780
content of it

966
00:42:19,520 --> 00:42:23,760
and last but not least

967
00:42:23,760 --> 00:42:26,339
Yara rules for detection of this doesn't

968
00:42:26,339 --> 00:42:28,740
work right off uh right off the bat you

969
00:42:28,740 --> 00:42:30,480
can't use config file you have to write

970
00:42:30,480 --> 00:42:32,280
code for Yara to do this because it

971
00:42:32,280 --> 00:42:35,400
reaches inside of the elf section and it

972
00:42:35,400 --> 00:42:37,560
actually does some heuristics on it so

973
00:42:37,560 --> 00:42:39,720
that goes is also posted

974
00:42:39,720 --> 00:42:42,359
on GitHub you you're welcome to take it

975
00:42:42,359 --> 00:42:44,040
and if you run

976
00:42:44,040 --> 00:42:44,880
um

977
00:42:44,880 --> 00:42:47,040
uh your custom detection then you can do

978
00:42:47,040 --> 00:42:48,780
that all right

979
00:42:48,780 --> 00:42:51,960
so what are the takeaways

980
00:42:51,960 --> 00:42:53,579
aside from the fact that we were

981
00:42:53,579 --> 00:42:56,339
successful finally right we got our

982
00:42:56,339 --> 00:43:00,240
our little uh presence in the in the uh

983
00:43:00,240 --> 00:43:02,160
in a Bastion host the jump host and

984
00:43:02,160 --> 00:43:04,440
we're able to go out to to the entire

985
00:43:04,440 --> 00:43:07,319
space of Linux and get good things for

986
00:43:07,319 --> 00:43:09,660
the customer right but the real thing is

987
00:43:09,660 --> 00:43:12,240
that you can create hybrid approach

988
00:43:12,240 --> 00:43:16,380
between uh static and dynamic by using a

989
00:43:16,380 --> 00:43:18,839
section as a unit of payload right you

990
00:43:18,839 --> 00:43:20,579
can high payload in sections you can

991
00:43:20,579 --> 00:43:21,839
actually make

992
00:43:21,839 --> 00:43:23,700
uh section

993
00:43:23,700 --> 00:43:26,160
loader agnostic from from the actual

994
00:43:26,160 --> 00:43:29,579
payload right and thereby you break the

995
00:43:29,579 --> 00:43:32,280
kind of rules of how tracing it happens

996
00:43:32,280 --> 00:43:34,260
right there are no memory addresses to

997
00:43:34,260 --> 00:43:36,839
go by basically reads its own image

998
00:43:36,839 --> 00:43:40,740
finds an offset reads off of it then you

999
00:43:40,740 --> 00:43:43,680
forego the API completely you work on

1000
00:43:43,680 --> 00:43:46,440
the ABI level your section gets binary

1001
00:43:46,440 --> 00:43:48,359
attached to its own loader if you want

1002
00:43:48,359 --> 00:43:50,160
to

1003
00:43:50,160 --> 00:43:53,700
and then you can also

1004
00:43:53,700 --> 00:43:55,859
um overcome the limitation of Packers

1005
00:43:55,859 --> 00:43:57,720
right you don't need to do compression

1006
00:43:57,720 --> 00:43:59,760
you don't need to do temporary file

1007
00:43:59,760 --> 00:44:01,500
systems you don't need to do any of that

1008
00:44:01,500 --> 00:44:03,900
all you have to do is basically create a

1009
00:44:03,900 --> 00:44:06,180
roster of payloads in your sections and

1010
00:44:06,180 --> 00:44:08,339
notify the loader

1011
00:44:08,339 --> 00:44:11,040
what to load and then how to load

1012
00:44:11,040 --> 00:44:13,740
whether using user exec or using the

1013
00:44:13,740 --> 00:44:16,619
mfdfu if you so choose

1014
00:44:16,619 --> 00:44:18,720
for those of you who are on the

1015
00:44:18,720 --> 00:44:21,540
defensive side we provided you with ar

1016
00:44:21,540 --> 00:44:23,220
rules the

1017
00:44:23,220 --> 00:44:24,839
um how we would

1018
00:44:24,839 --> 00:44:26,760
kind of detect that obviously you can

1019
00:44:26,760 --> 00:44:29,160
critically look at it and say hey that

1020
00:44:29,160 --> 00:44:31,800
needs to be improved of course but

1021
00:44:31,800 --> 00:44:33,960
um it's a it's a it's a race right you

1022
00:44:33,960 --> 00:44:35,880
you will be able to detect will be able

1023
00:44:35,880 --> 00:44:37,260
to overcome

1024
00:44:37,260 --> 00:44:38,819
and then

1025
00:44:38,819 --> 00:44:41,520
um deeper packing encryption is all

1026
00:44:41,520 --> 00:44:42,960
going to be in the product version of it

1027
00:44:42,960 --> 00:44:45,180
obviously right because things are

1028
00:44:45,180 --> 00:44:46,520
moving forward

1029
00:44:46,520 --> 00:44:49,140
uh last but not least now you can use

1030
00:44:49,140 --> 00:44:50,760
factories to borrow sections from

1031
00:44:50,760 --> 00:44:53,339
different executables on disk and you

1032
00:44:53,339 --> 00:44:54,900
should be able to solve for that issue

1033
00:44:54,900 --> 00:44:57,060
as well

1034
00:44:57,060 --> 00:44:59,520
the code is on GitHub

1035
00:44:59,520 --> 00:45:01,859
you can access it

1036
00:45:01,859 --> 00:45:05,220
and play with it modify it it's MIT you

1037
00:45:05,220 --> 00:45:06,839
know it's free for all we don't have any

1038
00:45:06,839 --> 00:45:08,460
rights for it

1039
00:45:08,460 --> 00:45:10,680
we just developed it for you for you

1040
00:45:10,680 --> 00:45:12,420
guys for for our needs and hopefully

1041
00:45:12,420 --> 00:45:14,940
it'll be useful for you and with that I

1042
00:45:14,940 --> 00:45:17,280
want to say thank you guys says and if

1043
00:45:17,280 --> 00:45:19,140
you have any questions I'm here to

1044
00:45:19,140 --> 00:45:21,560
answer them

