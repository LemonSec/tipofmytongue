1
00:00:01,880 --> 00:00:06,010
[Music]

2
00:00:14,480 --> 00:00:17,719
thank you

3
00:00:25,380 --> 00:00:27,779
can you hear me fine I think so

4
00:00:27,779 --> 00:00:31,260
so my name is Damiano melotti and today

5
00:00:31,260 --> 00:00:33,719
I'm going to talk a bit about our work

6
00:00:33,719 --> 00:00:37,079
on the titanium chip a security chip in

7
00:00:37,079 --> 00:00:40,160
Google pixel devices

8
00:00:40,160 --> 00:00:43,620
uh so This research was conducted mainly

9
00:00:43,620 --> 00:00:45,600
by me uh

10
00:00:45,600 --> 00:00:47,940
uh I am a security researcher at quarex

11
00:00:47,940 --> 00:00:50,820
lab uh mostly working on a low-level

12
00:00:50,820 --> 00:00:53,940
Android projects but I would not be here

13
00:00:53,940 --> 00:00:56,340
without the contribution of uh

14
00:00:56,340 --> 00:01:01,680
Maxim who is my tech lead and uh also in

15
00:01:01,680 --> 00:01:04,500
my team working in embedded software

16
00:01:04,500 --> 00:01:10,500
security so uh big up we got for him

17
00:01:10,500 --> 00:01:13,500
um and we we are about to to dive into

18
00:01:13,500 --> 00:01:16,680
uh a component that was introduced

19
00:01:16,680 --> 00:01:18,420
fairly recently in Google pixel devices

20
00:01:18,420 --> 00:01:21,420
which is this titanium chip and

21
00:01:21,420 --> 00:01:23,939
um in short this is a chip that

22
00:01:23,939 --> 00:01:25,680
implements some critical security

23
00:01:25,680 --> 00:01:28,920
features for the security model of pixel

24
00:01:28,920 --> 00:01:31,560
devices it was present from Pixel 3 to 5

25
00:01:31,560 --> 00:01:34,560
now from Pixel 6 there's a new iteration

26
00:01:34,560 --> 00:01:37,259
that is the Titan M2 where we're gonna

27
00:01:37,259 --> 00:01:39,720
talk about the titanium today

28
00:01:39,720 --> 00:01:42,360
um the idea is that with the separate

29
00:01:42,360 --> 00:01:45,659
chip you can have improved protection

30
00:01:45,659 --> 00:01:49,200
against the hardware level attacks side

31
00:01:49,200 --> 00:01:52,380
Channel and and so on uh which is a bit

32
00:01:52,380 --> 00:01:54,240
of the reason why it was it was

33
00:01:54,240 --> 00:01:56,520
introduced

34
00:01:56,520 --> 00:01:59,340
um so it is a chip based on uh cortex

35
00:01:59,340 --> 00:02:04,259
and three uh so arm architecture and it

36
00:02:04,259 --> 00:02:07,020
is running a closed Source OS but that

37
00:02:07,020 --> 00:02:09,419
is heavily inspired from EC which is

38
00:02:09,419 --> 00:02:11,220
instead open source and it is an

39
00:02:11,220 --> 00:02:14,760
operating system that can be seen uh in

40
00:02:14,760 --> 00:02:17,940
embedded controllers for uh Chromebooks

41
00:02:17,940 --> 00:02:19,500
mostly

42
00:02:19,500 --> 00:02:22,140
um the nice part of this firmware is

43
00:02:22,140 --> 00:02:25,200
that it is really simple uh there is no

44
00:02:25,200 --> 00:02:27,840
Dynamic allocation and the memory layout

45
00:02:27,840 --> 00:02:29,700
is static

46
00:02:29,700 --> 00:02:33,120
um there are different tasks that can be

47
00:02:33,120 --> 00:02:36,200
seen a bit as independent executioner

48
00:02:36,200 --> 00:02:39,120
dependent programs that perform certain

49
00:02:39,120 --> 00:02:41,940
features and then it communicates with

50
00:02:41,940 --> 00:02:44,640
the main OS through the SPI bus while

51
00:02:44,640 --> 00:02:48,180
the uart is used only for uh debugging

52
00:02:48,180 --> 00:02:50,519
and it doesn't get to to the Android

53
00:02:50,519 --> 00:02:53,519
interface

54
00:02:53,519 --> 00:02:54,239
um

55
00:02:54,239 --> 00:02:55,980
this is not the first time we talk about

56
00:02:55,980 --> 00:02:59,940
this chip in the last year we gave a

57
00:02:59,940 --> 00:03:03,180
first public talk about about it where

58
00:03:03,180 --> 00:03:06,660
we kind of started the researching and

59
00:03:06,660 --> 00:03:09,180
and getting familiar with with the chip

60
00:03:09,180 --> 00:03:13,019
that was this new and not not so not so

61
00:03:13,019 --> 00:03:14,480
known to the community

62
00:03:14,480 --> 00:03:17,159
and kind of to wrap up what we already

63
00:03:17,159 --> 00:03:18,300
did

64
00:03:18,300 --> 00:03:20,760
we started from reverse engineering of

65
00:03:20,760 --> 00:03:23,700
the firmer the firmware can be found on

66
00:03:23,700 --> 00:03:25,200
the Android file system it's not

67
00:03:25,200 --> 00:03:27,120
encrypted or obfuscated you can start

68
00:03:27,120 --> 00:03:30,120
reversing immediately and we kind of get

69
00:03:30,120 --> 00:03:32,879
got our hands dirty while

70
00:03:32,879 --> 00:03:34,760
um doing some reverse engineering

71
00:03:34,760 --> 00:03:38,040
uh we also developed some tools to

72
00:03:38,040 --> 00:03:41,040
interact with the chip at a software and

73
00:03:41,040 --> 00:03:44,940
Hardware level and uh we ended up also

74
00:03:44,940 --> 00:03:48,780
soldering stuff on the actual board to

75
00:03:48,780 --> 00:03:50,400
perform a hardware man in the middle

76
00:03:50,400 --> 00:03:52,739
this is something that was useful to

77
00:03:52,739 --> 00:03:55,140
intercept and communicate with the chip

78
00:03:55,140 --> 00:03:57,560
in all the phases of

79
00:03:57,560 --> 00:04:01,400
the function of a phone but here the

80
00:04:01,400 --> 00:04:04,680
shutout goes to uh Phil to then a

81
00:04:04,680 --> 00:04:07,319
colleague of mine who made some crazy

82
00:04:07,319 --> 00:04:12,119
stuff with with the hardware work

83
00:04:12,540 --> 00:04:15,599
um we of course uh wanted to find some

84
00:04:15,599 --> 00:04:17,220
vulnerabilities and in the end we did

85
00:04:17,220 --> 00:04:19,500
find a few of them

86
00:04:19,500 --> 00:04:22,440
the most remarkable is the second one

87
00:04:22,440 --> 00:04:25,139
you see in this slide it uh it is a

88
00:04:25,139 --> 00:04:27,660
downgrade vulnerability that allowed us

89
00:04:27,660 --> 00:04:31,919
to flash any firmware uh of also older

90
00:04:31,919 --> 00:04:35,220
versions uh in the in the chip and

91
00:04:35,220 --> 00:04:37,860
thanks to that we could uh roll back to

92
00:04:37,860 --> 00:04:41,160
a vulnerable version and exploit a

93
00:04:41,160 --> 00:04:43,139
vulnerability that was already passed in

94
00:04:43,139 --> 00:04:46,440
the newest ones to write the first code

95
00:04:46,440 --> 00:04:48,120
execution exploit in the chip so this

96
00:04:48,120 --> 00:04:50,880
was this is the old uh the old stuff

97
00:04:50,880 --> 00:04:54,540
that we did and it was wrapped up in uh

98
00:04:54,540 --> 00:04:58,220
I'm putting a link here to a talk we did

99
00:04:58,220 --> 00:05:02,280
but today I want to kind of give an a

100
00:05:02,280 --> 00:05:04,740
further angle to This research project

101
00:05:04,740 --> 00:05:08,280
and show how we try to do vulnerability

102
00:05:08,280 --> 00:05:10,880
research on this kind of Target

103
00:05:10,880 --> 00:05:13,259
and when I say vulnerability research

104
00:05:13,259 --> 00:05:16,919
what we mostly did was fuzzing which is

105
00:05:16,919 --> 00:05:20,580
uh turns out to be pretty useful even in

106
00:05:20,580 --> 00:05:22,759
these situations

107
00:05:22,759 --> 00:05:25,320
in different different settings that we

108
00:05:25,320 --> 00:05:27,360
will discuss a little bit and then we'll

109
00:05:27,360 --> 00:05:29,580
dive into one vulnerability that we

110
00:05:29,580 --> 00:05:33,000
found that gave us the chance to obtain

111
00:05:33,000 --> 00:05:35,460
a code execution again on the chip this

112
00:05:35,460 --> 00:05:39,739
time of course using this zero day

113
00:05:40,320 --> 00:05:43,560
um before starting Let's uh have a look

114
00:05:43,560 --> 00:05:45,539
a bit on the attack surface that is

115
00:05:45,539 --> 00:05:48,660
available when uh trying to approach the

116
00:05:48,660 --> 00:05:50,639
titanium so in this slide I try to

117
00:05:50,639 --> 00:05:53,880
summarize a bit how uh Android and the

118
00:05:53,880 --> 00:05:56,460
chip communicate you have

119
00:05:56,460 --> 00:05:59,340
um several hals Hardware obstruction

120
00:05:59,340 --> 00:06:03,479
layers that send Proto buff encoded

121
00:06:03,479 --> 00:06:05,880
messages to the demon which is the one

122
00:06:05,880 --> 00:06:08,699
who talks to the driver and goes uh to

123
00:06:08,699 --> 00:06:11,900
the chip through the SPI the SPI

124
00:06:11,900 --> 00:06:15,660
bus so when trying to approach the

125
00:06:15,660 --> 00:06:18,900
surface of this uh of this target what

126
00:06:18,900 --> 00:06:21,120
one can try to do is

127
00:06:21,120 --> 00:06:23,639
try to bypass the demon and talk

128
00:06:23,639 --> 00:06:25,979
directly with the driver and this is

129
00:06:25,979 --> 00:06:28,740
what we did with a

130
00:06:28,740 --> 00:06:31,139
a binary that we call the NOS client

131
00:06:31,139 --> 00:06:33,720
this was a custom client to talk

132
00:06:33,720 --> 00:06:36,120
directly with the driver

133
00:06:36,120 --> 00:06:38,880
um bypassing the the whole system and

134
00:06:38,880 --> 00:06:41,300
this was the base for the first type of

135
00:06:41,300 --> 00:06:43,500
research vulnerability research that we

136
00:06:43,500 --> 00:06:45,300
did which was Black Box Black Box

137
00:06:45,300 --> 00:06:46,979
fuzzing

138
00:06:46,979 --> 00:06:49,680
so when I say black box what I mean is

139
00:06:49,680 --> 00:06:51,900
the classical situation where you only

140
00:06:51,900 --> 00:06:54,960
have a channel to communicate with what

141
00:06:54,960 --> 00:06:57,600
you are trying to to test and then only

142
00:06:57,600 --> 00:06:59,759
a way to tell if something happened

143
00:06:59,759 --> 00:07:02,460
without any further visibility over

144
00:07:02,460 --> 00:07:04,940
what's going on in the target

145
00:07:04,940 --> 00:07:08,580
uh in our case uh we have the channel

146
00:07:08,580 --> 00:07:11,819
That is given by uh NOS client this

147
00:07:11,819 --> 00:07:14,940
binary we we developed uh we know the

148
00:07:14,940 --> 00:07:16,620
format of the messages thanks to the

149
00:07:16,620 --> 00:07:19,199
open source uh protobuf definitions so

150
00:07:19,199 --> 00:07:21,660
we can use them to mutate with lip

151
00:07:21,660 --> 00:07:25,199
protobuf mutator and then based on a

152
00:07:25,199 --> 00:07:27,660
return code that is the signal that

153
00:07:27,660 --> 00:07:30,479
tells us whether the chip is is crashing

154
00:07:30,479 --> 00:07:31,979
or not

155
00:07:31,979 --> 00:07:32,580
um

156
00:07:32,580 --> 00:07:35,460
we start from an empty uh from a corpus

157
00:07:35,460 --> 00:07:37,819
made of empty messages with some

158
00:07:37,819 --> 00:07:41,460
particular fields that were set thanks

159
00:07:41,460 --> 00:07:44,280
to some sniffing done with freedom this

160
00:07:44,280 --> 00:07:47,220
is not rocket science and

161
00:07:47,220 --> 00:07:48,060
um

162
00:07:48,060 --> 00:07:50,400
uh on the on the return code that we

163
00:07:50,400 --> 00:07:53,280
check uh in this slide you can find the

164
00:07:53,280 --> 00:07:56,479
uh the uh

165
00:07:56,479 --> 00:07:59,160
that uh defines the different return

166
00:07:59,160 --> 00:08:00,960
codes and in particular we are

167
00:08:00,960 --> 00:08:02,819
interested in any return codes that are

168
00:08:02,819 --> 00:08:07,080
uh bigger than two uh this is because uh

169
00:08:07,080 --> 00:08:10,259
two it means error internal turns out

170
00:08:10,259 --> 00:08:11,580
this is what happens when the chip

171
00:08:11,580 --> 00:08:14,160
crashes but all the others are also sort

172
00:08:14,160 --> 00:08:15,960
of interesting

173
00:08:15,960 --> 00:08:20,639
so we run this uh further on the on this

174
00:08:20,639 --> 00:08:23,280
setting first on an old firmware that we

175
00:08:23,280 --> 00:08:26,220
knew had quite a few bugs and we found

176
00:08:26,220 --> 00:08:28,199
uh we found most of them including the

177
00:08:28,199 --> 00:08:31,039
one we exploited earlier if you remember

178
00:08:31,039 --> 00:08:35,339
to to get code execution uh thanks to

179
00:08:35,339 --> 00:08:37,620
the rollback we also repeated the

180
00:08:37,620 --> 00:08:39,479
research on the latest filmer at the

181
00:08:39,479 --> 00:08:43,159
time but we only found uh

182
00:08:43,159 --> 00:08:45,779
two in fact at nude pointer the

183
00:08:45,779 --> 00:08:48,000
references that turn out to be in the

184
00:08:48,000 --> 00:08:51,420
same function uh which were causing a

185
00:08:51,420 --> 00:08:52,920
crash on the chip but were not

186
00:08:52,920 --> 00:08:55,260
considered serious enough to be

187
00:08:55,260 --> 00:08:57,420
considered vulnerabilities uh by Google

188
00:08:57,420 --> 00:08:59,100
when we reported them

189
00:08:59,100 --> 00:09:00,899
but all these came after a few minutes

190
00:09:00,899 --> 00:09:04,320
of fuzzing which kind of takes us to the

191
00:09:04,320 --> 00:09:05,360
main

192
00:09:05,360 --> 00:09:10,140
pros and cons of this approach and uh of

193
00:09:10,140 --> 00:09:12,540
course the pros go in the direction of

194
00:09:12,540 --> 00:09:15,000
finding bugs so if we can find bugs it

195
00:09:15,000 --> 00:09:17,040
means the approach is interesting and at

196
00:09:17,040 --> 00:09:19,440
the end of the day we did so that's nice

197
00:09:19,440 --> 00:09:21,779
and of course when a bug is found in

198
00:09:21,779 --> 00:09:24,180
this approach you immediately also have

199
00:09:24,180 --> 00:09:26,040
a proof of concept because of the

200
00:09:26,040 --> 00:09:30,420
practicality of a black box buzzing it

201
00:09:30,420 --> 00:09:34,200
is also fairly easy to mount but the

202
00:09:34,200 --> 00:09:37,700
main issue is that we are probably only

203
00:09:37,700 --> 00:09:39,720
scratching the surface we are only

204
00:09:39,720 --> 00:09:41,959
hitting shallow states of the target

205
00:09:41,959 --> 00:09:44,580
which means we are not really getting

206
00:09:44,580 --> 00:09:48,060
over some of the superficial checks most

207
00:09:48,060 --> 00:09:49,680
likely because we have no visibility

208
00:09:49,680 --> 00:09:52,440
over what is going on on the targets

209
00:09:52,440 --> 00:09:54,839
that's the main drawback and that's also

210
00:09:54,839 --> 00:09:56,519
the main reason why we wanted to try

211
00:09:56,519 --> 00:09:58,440
something different and by something

212
00:09:58,440 --> 00:10:01,380
different I mean the emulation based

213
00:10:01,380 --> 00:10:04,320
approaches so once we know how the

214
00:10:04,320 --> 00:10:08,100
operating system works and how we can

215
00:10:08,100 --> 00:10:09,779
set it up

216
00:10:09,779 --> 00:10:13,140
uh also leaking memory thanks to the

217
00:10:13,140 --> 00:10:16,800
read primitive that we built upon the

218
00:10:16,800 --> 00:10:18,899
the code execution exploit on the Node

219
00:10:18,899 --> 00:10:21,180
version of the firmware what we can do

220
00:10:21,180 --> 00:10:25,140
is put all together and mount an

221
00:10:25,140 --> 00:10:26,720
emulator so

222
00:10:26,720 --> 00:10:30,120
control the execution of the firmware by

223
00:10:30,120 --> 00:10:33,779
rehosting it in in an emulator and then

224
00:10:33,779 --> 00:10:37,080
use this as the starting point for a

225
00:10:37,080 --> 00:10:38,640
different advising approach where we

226
00:10:38,640 --> 00:10:42,600
have visibility over what is uh going on

227
00:10:42,600 --> 00:10:46,260
to emulate titanium we ended up choosing

228
00:10:46,260 --> 00:10:48,480
unicorn there are quite a few Frameworks

229
00:10:48,480 --> 00:10:51,480
out there but unicorn was for sure the

230
00:10:51,480 --> 00:10:56,100
easiest to use it is based on qimo but

231
00:10:56,100 --> 00:10:58,339
it only emulates the CPU so you don't

232
00:10:58,339 --> 00:11:01,260
achieve a full system emulation you just

233
00:11:01,260 --> 00:11:02,940
give it a starting point and end point

234
00:11:02,940 --> 00:11:07,440
and uh after setting up the memory it

235
00:11:07,440 --> 00:11:09,300
will take care of emulating instruction

236
00:11:09,300 --> 00:11:12,300
by instruction but the probably best

237
00:11:12,300 --> 00:11:14,640
part about using unicorn is that it

238
00:11:14,640 --> 00:11:16,740
integrates really well with AFL plus

239
00:11:16,740 --> 00:11:17,839
plus

240
00:11:17,839 --> 00:11:20,459
uh which I'm sure most of you are

241
00:11:20,459 --> 00:11:23,579
already familiar with it's uh one of the

242
00:11:23,579 --> 00:11:26,060
most famous uh fathers

243
00:11:26,060 --> 00:11:29,579
and with its unicorn mode you can

244
00:11:29,579 --> 00:11:31,560
basically fuzz anything that can be

245
00:11:31,560 --> 00:11:35,100
emulated with unicorn uh all you need is

246
00:11:35,100 --> 00:11:37,860
a a callback to place the input at the

247
00:11:37,860 --> 00:11:40,680
right at the right address in memory and

248
00:11:40,680 --> 00:11:43,620
uh AFL will crash detect crashes when

249
00:11:43,620 --> 00:11:45,899
unicorn crashes

250
00:11:45,899 --> 00:11:48,839
um on top of that we can also use custom

251
00:11:48,839 --> 00:11:52,800
mutators this is a feature of AFL which

252
00:11:52,800 --> 00:11:55,079
makes it even more interesting when it

253
00:11:55,079 --> 00:11:58,079
comes to fuzzing and leveraging some

254
00:11:58,079 --> 00:12:02,220
sort of grammar which is this case

255
00:12:02,220 --> 00:12:05,640
so we can again rely on leave protobuf

256
00:12:05,640 --> 00:12:10,260
mutator to embed to mutate using the

257
00:12:10,260 --> 00:12:12,839
grammar that we have and

258
00:12:12,839 --> 00:12:13,560
um

259
00:12:13,560 --> 00:12:16,380
we only need to as I said provide an

260
00:12:16,380 --> 00:12:18,060
entry point and an exit point for our

261
00:12:18,060 --> 00:12:21,839
father and we focused mostly on two of

262
00:12:21,839 --> 00:12:24,540
the of of the tasks which are identity

263
00:12:24,540 --> 00:12:26,459
and and Key Master you don't need to

264
00:12:26,459 --> 00:12:28,140
know specifically what they do but they

265
00:12:28,140 --> 00:12:30,959
are the larger ones that are present in

266
00:12:30,959 --> 00:12:33,720
the system and where it's there's a

267
00:12:33,720 --> 00:12:37,680
little bit more of the bug prone code we

268
00:12:37,680 --> 00:12:39,300
also fast another one that is called

269
00:12:39,300 --> 00:12:42,240
Weaver but that was particularly small

270
00:12:42,240 --> 00:12:46,560
so of course we try to to cover uh the

271
00:12:46,560 --> 00:12:50,459
the larger the larger code portion

272
00:12:50,459 --> 00:12:53,220
um and as I uh we did before can we

273
00:12:53,220 --> 00:12:55,800
still find some bugs that we know are

274
00:12:55,800 --> 00:12:58,320
there before trying to find some news

275
00:12:58,320 --> 00:13:00,600
and the answer is yes

276
00:13:00,600 --> 00:13:03,000
we can find the same bugs we found with

277
00:13:03,000 --> 00:13:08,040
the black box approach but uh we miss at

278
00:13:08,040 --> 00:13:10,920
least one and that's uh what takes me to

279
00:13:10,920 --> 00:13:13,620
also the disadvantages of emulation

280
00:13:13,620 --> 00:13:17,160
based approaches because like we know

281
00:13:17,160 --> 00:13:20,399
there is almost never a free lunch and

282
00:13:20,399 --> 00:13:22,800
when trying to emulate code from a

283
00:13:22,800 --> 00:13:23,940
hardware

284
00:13:23,940 --> 00:13:28,200
um uh from from code that is so close to

285
00:13:28,200 --> 00:13:31,440
the hardware it is really difficult to

286
00:13:31,440 --> 00:13:34,740
deal with a hardware dependency and code

287
00:13:34,740 --> 00:13:38,399
that is uh impossible to be emulated so

288
00:13:38,399 --> 00:13:40,920
we need a lot of hooks which means

289
00:13:40,920 --> 00:13:42,720
essentially you know that that function

290
00:13:42,720 --> 00:13:45,779
will try to read some value that nobody

291
00:13:45,779 --> 00:13:48,240
will ever set so we cannot execute it we

292
00:13:48,240 --> 00:13:50,300
cannot emulate it

293
00:13:50,300 --> 00:13:53,700
this means that the portion of code we

294
00:13:53,700 --> 00:13:58,500
cover also has some limitations and we

295
00:13:58,500 --> 00:14:00,540
are also not entirely sure of being able

296
00:14:00,540 --> 00:14:03,000
to detect every single bug that we will

297
00:14:03,000 --> 00:14:04,920
that we will

298
00:14:04,920 --> 00:14:08,720
be able to reach because unicorn is

299
00:14:08,720 --> 00:14:11,279
doesn't present any particular

300
00:14:11,279 --> 00:14:13,620
instrumentation and

301
00:14:13,620 --> 00:14:15,899
in page overflows or off by ones are

302
00:14:15,899 --> 00:14:18,779
still tricky to detect and the final

303
00:14:18,779 --> 00:14:21,540
point is that is a bit of our choice no

304
00:14:21,540 --> 00:14:24,480
I said unicorn doesn't offer full system

305
00:14:24,480 --> 00:14:26,639
emulation and that's what we want but of

306
00:14:26,639 --> 00:14:30,300
course this means that we are also not

307
00:14:30,300 --> 00:14:32,700
covering parts of the firmware that have

308
00:14:32,700 --> 00:14:35,160
to deal for example with the scheduler

309
00:14:35,160 --> 00:14:39,360
or and this is actually a problem

310
00:14:39,360 --> 00:14:41,820
because the one bug we couldn't find

311
00:14:41,820 --> 00:14:43,920
again was in the scheduler and we were

312
00:14:43,920 --> 00:14:48,480
not we were not really testing that code

313
00:14:48,480 --> 00:14:51,899
but what really makes simulation-based

314
00:14:51,899 --> 00:14:54,360
approaches effective is that we can

315
00:14:54,360 --> 00:14:57,240
tweak it uh we can tweak the emulator in

316
00:14:57,240 --> 00:14:59,779
several different ways making it uh

317
00:14:59,779 --> 00:15:02,639
making it have some custom checks that

318
00:15:02,639 --> 00:15:04,800
it wouldn't have in a normal uh

319
00:15:04,800 --> 00:15:07,380
situation so we can identify some

320
00:15:07,380 --> 00:15:10,380
patterns for bugs we can for example try

321
00:15:10,380 --> 00:15:14,040
to follow mem copy calls trying to to

322
00:15:14,040 --> 00:15:16,620
catch the case where we end up reading

323
00:15:16,620 --> 00:15:19,019
the memory in some addresses that we

324
00:15:19,019 --> 00:15:22,260
shouldn't be reading or we can use

325
00:15:22,260 --> 00:15:25,320
symbolic execution when we get stuck and

326
00:15:25,320 --> 00:15:27,540
we want to try to to break some

327
00:15:27,540 --> 00:15:28,880
constraints

328
00:15:28,880 --> 00:15:31,740
that a normal father wouldn't be able to

329
00:15:31,740 --> 00:15:33,600
to cover this is these are all things

330
00:15:33,600 --> 00:15:36,180
that become possible once you have an

331
00:15:36,180 --> 00:15:38,220
emulator while in Black Box setting it's

332
00:15:38,220 --> 00:15:40,199
it's impossible to achieve anything like

333
00:15:40,199 --> 00:15:41,699
that

334
00:15:41,699 --> 00:15:43,079
um at the same time

335
00:15:43,079 --> 00:15:45,839
at some point everything comes at the

336
00:15:45,839 --> 00:15:47,940
cost so if you have a lot of hooks your

337
00:15:47,940 --> 00:15:51,000
emulator will be slower and slower

338
00:15:51,000 --> 00:15:53,100
um and there is always a trade-off

339
00:15:53,100 --> 00:15:54,839
between how much you reverse engineer

340
00:15:54,839 --> 00:15:57,300
and the customize your tools and how

341
00:15:57,300 --> 00:15:59,060
much you can actually let your father

342
00:15:59,060 --> 00:16:02,880
run and discover things

343
00:16:02,880 --> 00:16:06,720
but uh let's now dive into one specific

344
00:16:06,720 --> 00:16:09,959
bug that we found using emulation based

345
00:16:09,959 --> 00:16:12,720
fuzzing and how we actually exploited it

346
00:16:12,720 --> 00:16:15,720
this is a bug that appears in a function

347
00:16:15,720 --> 00:16:18,959
that parses key parameter objects we

348
00:16:18,959 --> 00:16:20,760
find these objects in quite a few

349
00:16:20,760 --> 00:16:24,360
messages in the key master task and it

350
00:16:24,360 --> 00:16:26,940
is an out of bounds right of exactly one

351
00:16:26,940 --> 00:16:30,500
byte that can be set to exactly one

352
00:16:30,500 --> 00:16:33,180
with some constraints on where this

353
00:16:33,180 --> 00:16:36,000
right can happen so at first when when

354
00:16:36,000 --> 00:16:37,980
we found this black we thought it would

355
00:16:37,980 --> 00:16:41,220
be a kind of minor issue something that

356
00:16:41,220 --> 00:16:43,320
cannot really be exploited but let me

357
00:16:43,320 --> 00:16:46,500
drive you through the code so on the

358
00:16:46,500 --> 00:16:49,259
left side you can see the assembly view

359
00:16:49,259 --> 00:16:51,660
on the right the the compiled one

360
00:16:51,660 --> 00:16:54,060
and the vulnerable instruction is this

361
00:16:54,060 --> 00:16:57,779
store byte instruction where

362
00:16:57,779 --> 00:17:00,779
um we are writing one byte out of bound

363
00:17:00,779 --> 00:17:03,779
now uh as you can see the value in R1

364
00:17:03,779 --> 00:17:07,140
will be one so we are writing one uh

365
00:17:07,140 --> 00:17:09,559
byte to exactly one

366
00:17:09,559 --> 00:17:12,599
uh but there is an offset that has to go

367
00:17:12,599 --> 00:17:14,880
through some checks and this offset

368
00:17:14,880 --> 00:17:16,980
let's let's do these checks together so

369
00:17:16,980 --> 00:17:21,480
we have a standard 32-bit value which

370
00:17:21,480 --> 00:17:23,760
first of all is must so we only care

371
00:17:23,760 --> 00:17:27,359
about the least significant byte

372
00:17:27,359 --> 00:17:31,520
this least significant byte has to be

373
00:17:31,520 --> 00:17:34,380
smaller than smaller than or equal four

374
00:17:34,380 --> 00:17:38,220
uh to bypass this uh

375
00:17:38,220 --> 00:17:41,580
um this if condition and there is also a

376
00:17:41,580 --> 00:17:44,460
somewhat more complicated uh bitwise

377
00:17:44,460 --> 00:17:46,679
operation let's not go into the details

378
00:17:46,679 --> 00:17:48,840
but trust me here the values we can have

379
00:17:48,840 --> 00:17:51,900
here uh the values we can we can have

380
00:17:51,900 --> 00:17:56,160
here are only 0 2 and 4 which means that

381
00:17:56,160 --> 00:17:59,700
we can set this offset to any value but

382
00:17:59,700 --> 00:18:02,760
the least significant byte needs to be 0

383
00:18:02,760 --> 00:18:06,179
2 or 4. which kind of limits where we

384
00:18:06,179 --> 00:18:09,360
can write uh quite a lot

385
00:18:09,360 --> 00:18:12,059
however what can we do with this

386
00:18:12,059 --> 00:18:14,220
um we can reach the vulnerable code as I

387
00:18:14,220 --> 00:18:17,700
said in many different ways because this

388
00:18:17,700 --> 00:18:21,000
type and this function is called from

389
00:18:21,000 --> 00:18:23,640
many different commands because many

390
00:18:23,640 --> 00:18:26,160
different comments have to decode that

391
00:18:26,160 --> 00:18:26,960
field

392
00:18:26,960 --> 00:18:29,580
this gives us different base addresses

393
00:18:29,580 --> 00:18:31,740
where we will be able to do this out of

394
00:18:31,740 --> 00:18:35,160
bound right and if you remember at the

395
00:18:35,160 --> 00:18:37,200
beginning I said that the memory of

396
00:18:37,200 --> 00:18:39,419
titanium is completely static which

397
00:18:39,419 --> 00:18:41,460
means everything will always be at the

398
00:18:41,460 --> 00:18:45,539
same place so one byte can be enough if

399
00:18:45,539 --> 00:18:47,640
you can write that one byte at the right

400
00:18:47,640 --> 00:18:50,940
place that can be enough to achieve

401
00:18:50,940 --> 00:18:54,299
interesting uh interesting results

402
00:18:54,299 --> 00:18:57,179
so what we did was okay let's try to

403
00:18:57,179 --> 00:19:00,360
generate always using the emulator all

404
00:19:00,360 --> 00:19:02,580
the possible addresses that we can reach

405
00:19:02,580 --> 00:19:05,700
with this primitive and then let's

406
00:19:05,700 --> 00:19:08,760
highlight them in our disassembler to

407
00:19:08,760 --> 00:19:11,640
see uh where if we find anything that

408
00:19:11,640 --> 00:19:13,380
seems to be interesting

409
00:19:13,380 --> 00:19:15,960
and it turns out that at some point we

410
00:19:15,960 --> 00:19:18,480
can write one byte in a structure in

411
00:19:18,480 --> 00:19:20,760
memory that we call the key master SPI

412
00:19:20,760 --> 00:19:23,820
data this is just the name we gave it's

413
00:19:23,820 --> 00:19:26,340
probably not accurate but the point is

414
00:19:26,340 --> 00:19:30,480
that we can write one byte in a field

415
00:19:30,480 --> 00:19:34,380
that contains the address where incoming

416
00:19:34,380 --> 00:19:38,760
requests are stored so this uh this

417
00:19:38,760 --> 00:19:40,679
structure to give you a bit more context

418
00:19:40,679 --> 00:19:43,679
is uh holding information about SPI

419
00:19:43,679 --> 00:19:46,620
exchanges between uh Android and the

420
00:19:46,620 --> 00:19:49,200
titanium so this is the way the two

421
00:19:49,200 --> 00:19:51,660
communicate we have this structure for

422
00:19:51,660 --> 00:19:53,820
each one of the tasks so we have the one

423
00:19:53,820 --> 00:19:56,100
for Key Master the one for identity the

424
00:19:56,100 --> 00:19:59,340
one for AVB and so on

425
00:19:59,340 --> 00:20:02,240
and the point here is that one field

426
00:20:02,240 --> 00:20:05,039
tells the titanium where it should store

427
00:20:05,039 --> 00:20:08,520
an incoming request so we can make it

428
00:20:08,520 --> 00:20:14,940
become from 190 to C8 to 101 C8 so as

429
00:20:14,940 --> 00:20:17,700
you can see requests will be stored

430
00:20:17,700 --> 00:20:20,700
quite different quite far from where

431
00:20:20,700 --> 00:20:23,820
they would be supposed to be stored

432
00:20:23,820 --> 00:20:25,740
and that was the moment where we

433
00:20:25,740 --> 00:20:28,860
understood we could uh have some fun

434
00:20:28,860 --> 00:20:31,799
but first let me take a step back and

435
00:20:31,799 --> 00:20:35,640
remind you about the situation that we

436
00:20:35,640 --> 00:20:38,100
are facing so we found the bug with the

437
00:20:38,100 --> 00:20:41,700
emulator so we know that the bug can be

438
00:20:41,700 --> 00:20:43,200
there but we are not entirely sure

439
00:20:43,200 --> 00:20:45,240
because we are always dealing with

440
00:20:45,240 --> 00:20:49,200
emulated code and when we try to do the

441
00:20:49,200 --> 00:20:52,140
same thing on the real device all we can

442
00:20:52,140 --> 00:20:54,900
have is a client to send our messages

443
00:20:54,900 --> 00:20:58,440
NOS client we have a return code that

444
00:20:58,440 --> 00:20:59,780
comes from

445
00:20:59,780 --> 00:21:03,360
the library that we are using and if the

446
00:21:03,360 --> 00:21:05,520
command success is successful we also

447
00:21:05,520 --> 00:21:08,700
have a response but that's it that's all

448
00:21:08,700 --> 00:21:11,160
we have so we don't have a debugger we

449
00:21:11,160 --> 00:21:14,760
don't have any Trace if we cause a crash

450
00:21:14,760 --> 00:21:17,640
um so thinking about writing and exploit

451
00:21:17,640 --> 00:21:21,000
is basically impossible or extremely

452
00:21:21,000 --> 00:21:23,160
challenging so

453
00:21:23,160 --> 00:21:24,960
if you remember at the beginning I

454
00:21:24,960 --> 00:21:27,960
mentioned there was this uart interface

455
00:21:27,960 --> 00:21:32,220
that the titanium was using so the thing

456
00:21:32,220 --> 00:21:35,039
is we ended up having to solder two

457
00:21:35,039 --> 00:21:37,500
wires into the

458
00:21:37,500 --> 00:21:40,080
um into the motherboard of the titanium

459
00:21:40,080 --> 00:21:42,140
of the pixel device

460
00:21:42,140 --> 00:21:45,840
those two wires let us access on the

461
00:21:45,840 --> 00:21:48,299
hardware level the uart of the titanium

462
00:21:48,299 --> 00:21:51,000
chip and gave us access to a simple

463
00:21:51,000 --> 00:21:54,059
console that is uh really not that

464
00:21:54,059 --> 00:21:56,100
interesting it allows really basic

465
00:21:56,100 --> 00:21:58,440
interaction with the chip things like

466
00:21:58,440 --> 00:22:01,620
asking for the version of the firmware

467
00:22:01,620 --> 00:22:02,960
or

468
00:22:02,960 --> 00:22:05,880
statistics and stuff like that but this

469
00:22:05,880 --> 00:22:08,460
is the place where logs are printed when

470
00:22:08,460 --> 00:22:11,340
the chip is printing something so if at

471
00:22:11,340 --> 00:22:12,600
some point of the firmware the chip

472
00:22:12,600 --> 00:22:15,539
wants to do a printf this is the place

473
00:22:15,539 --> 00:22:16,700
where

474
00:22:16,700 --> 00:22:21,179
where logs will end up being written so

475
00:22:21,179 --> 00:22:23,760
what we did was okay now that we have

476
00:22:23,760 --> 00:22:27,179
access to this debugging interface let's

477
00:22:27,179 --> 00:22:31,200
just try to uh once we have overwritten

478
00:22:31,200 --> 00:22:33,720
the address of requests let's try to

479
00:22:33,720 --> 00:22:35,640
send the bigger and bigger and bigger

480
00:22:35,640 --> 00:22:38,640
messages to see what happens uh so now

481
00:22:38,640 --> 00:22:43,799
we write in 0x 1 0 1 C8 we write bigger

482
00:22:43,799 --> 00:22:45,900
and bigger messages to see what happens

483
00:22:45,900 --> 00:22:48,659
and at some points we understand that

484
00:22:48,659 --> 00:22:51,900
the chip starts crashing so something

485
00:22:51,900 --> 00:22:54,480
must be happening

486
00:22:54,480 --> 00:22:56,460
um we noticed this thanks to the uart

487
00:22:56,460 --> 00:22:59,880
interface again so what if we try to put

488
00:22:59,880 --> 00:23:01,980
a valid address at the end of our

489
00:23:01,980 --> 00:23:04,440
payload at the moment where the chip

490
00:23:04,440 --> 00:23:06,480
crashes

491
00:23:06,480 --> 00:23:09,720
and what turns out to to happen is that

492
00:23:09,720 --> 00:23:13,799
we get uh sorry we get some logs in the

493
00:23:13,799 --> 00:23:16,679
in the uart so this is where the uart

494
00:23:16,679 --> 00:23:18,179
comes helpful when you are debugging

495
00:23:18,179 --> 00:23:20,280
your exploit you can always try to jump

496
00:23:20,280 --> 00:23:23,340
to some function then print uh some code

497
00:23:23,340 --> 00:23:27,059
and in the uart if you see uh if you see

498
00:23:27,059 --> 00:23:30,000
that print uh that those logs being

499
00:23:30,000 --> 00:23:32,280
printed it means you were able to

500
00:23:32,280 --> 00:23:35,039
trigger that specific function so now

501
00:23:35,039 --> 00:23:36,900
that we have our logs it means that we

502
00:23:36,900 --> 00:23:39,659
have code execution in that uh Point

503
00:23:39,659 --> 00:23:43,559
that's quite nice but uh now what first

504
00:23:43,559 --> 00:23:45,360
of all what is going on because we were

505
00:23:45,360 --> 00:23:47,580
writing junk and at some point we jump

506
00:23:47,580 --> 00:23:48,960
to some function

507
00:23:48,960 --> 00:23:51,419
so our guess is that we are actually

508
00:23:51,419 --> 00:23:53,580
overwriting a return address that was

509
00:23:53,580 --> 00:23:56,820
pushed to the stack

510
00:23:56,820 --> 00:23:59,220
and then a function wants to to jump

511
00:23:59,220 --> 00:24:03,000
back uh to its color and it turns out to

512
00:24:03,000 --> 00:24:06,179
go into a function that we decided that

513
00:24:06,179 --> 00:24:09,120
we wrote but from now on getting a

514
00:24:09,120 --> 00:24:11,220
proper attack mounted is far from

515
00:24:11,220 --> 00:24:12,960
trivial because the stack is not

516
00:24:12,960 --> 00:24:15,600
executable and we don't have space to

517
00:24:15,600 --> 00:24:18,179
write our option directory where we

518
00:24:18,179 --> 00:24:21,059
start having a code execution

519
00:24:21,059 --> 00:24:22,700
so we need to

520
00:24:22,700 --> 00:24:25,880
do what is known as the stack pivoting

521
00:24:25,880 --> 00:24:28,620
but this is usually done by decreasing

522
00:24:28,620 --> 00:24:30,900
the stack pointer or putting a new value

523
00:24:30,900 --> 00:24:34,500
in it we only have one Gadget however to

524
00:24:34,500 --> 00:24:35,580
do that

525
00:24:35,580 --> 00:24:38,100
this is it it's a bit complicated but

526
00:24:38,100 --> 00:24:40,260
what I want you to focus on is that we

527
00:24:40,260 --> 00:24:42,720
will only be able to jump uh to move the

528
00:24:42,720 --> 00:24:47,400
stack pointer away from Xerox 20 bytes

529
00:24:47,400 --> 00:24:49,679
from where we actually get to run this

530
00:24:49,679 --> 00:24:53,520
gadget so this is uh not much but what

531
00:24:53,520 --> 00:24:55,799
can you do this is the only thing we can

532
00:24:55,799 --> 00:24:58,580
do and so we ended up

533
00:24:58,580 --> 00:25:01,039
doing something that was

534
00:25:01,039 --> 00:25:04,020
a bit crazy some may say but that's the

535
00:25:04,020 --> 00:25:06,600
only way I could we could find our space

536
00:25:06,600 --> 00:25:09,419
so we would call this gadget multiple

537
00:25:09,419 --> 00:25:13,200
times moving away from the point where

538
00:25:13,200 --> 00:25:17,940
we started of 0x20 every time so we go

539
00:25:17,940 --> 00:25:20,880
up and up and up

540
00:25:20,880 --> 00:25:24,240
um and yes writing some helper values in

541
00:25:24,240 --> 00:25:27,000
another place to be able to run this

542
00:25:27,000 --> 00:25:29,700
this gadget because of the load

543
00:25:29,700 --> 00:25:31,260
instructions that are present in the

544
00:25:31,260 --> 00:25:34,679
gadget so once we managed to move our

545
00:25:34,679 --> 00:25:37,940
stack pointer away from uh the beginning

546
00:25:37,940 --> 00:25:42,659
the second stage uh we now we are over

547
00:25:42,659 --> 00:25:44,940
there with our execution and the second

548
00:25:44,940 --> 00:25:46,039
stage

549
00:25:46,039 --> 00:25:48,900
uh now we can finally do something

550
00:25:48,900 --> 00:25:51,659
interesting with our exploit now that we

551
00:25:51,659 --> 00:25:54,539
have the space to do it but we are still

552
00:25:54,539 --> 00:25:56,700
running in a context that is a bit

553
00:25:56,700 --> 00:26:00,360
unknown uh if you remember we were

554
00:26:00,360 --> 00:26:02,340
overwriting a function address in a

555
00:26:02,340 --> 00:26:04,799
point that we are not really sure uh

556
00:26:04,799 --> 00:26:09,299
which tasks or we which uh which uh in

557
00:26:09,299 --> 00:26:12,419
context it is running on so basically we

558
00:26:12,419 --> 00:26:14,640
want to have code execution from a

559
00:26:14,640 --> 00:26:16,860
command Handler to be able to send some

560
00:26:16,860 --> 00:26:18,779
results back to Android

561
00:26:18,779 --> 00:26:21,299
and uh the thing is that these command

562
00:26:21,299 --> 00:26:24,419
handlers are written in uh RAM so

563
00:26:24,419 --> 00:26:27,960
basically we can try to uh override

564
00:26:27,960 --> 00:26:30,559
these command handlers that are in Ram

565
00:26:30,559 --> 00:26:34,679
then make the new Handler jump to

566
00:26:34,679 --> 00:26:37,020
somewhere we control and that's where

567
00:26:37,020 --> 00:26:39,299
we're going to be able to write our code

568
00:26:39,299 --> 00:26:43,020
to have the full exploit running because

569
00:26:43,020 --> 00:26:45,900
there we will be running in the context

570
00:26:45,900 --> 00:26:48,480
of the command Handler

571
00:26:48,480 --> 00:26:50,460
so then we will be able to trigger this

572
00:26:50,460 --> 00:26:52,820
with a second command and

573
00:26:52,820 --> 00:26:55,679
complete our exploit

574
00:26:55,679 --> 00:26:58,679
all of this needs to happen uh in the

575
00:26:58,679 --> 00:27:00,900
space that you see over there making

576
00:27:00,900 --> 00:27:03,120
sure not to overwrite the gadgets we

577
00:27:03,120 --> 00:27:06,120
needed to jump on uh the stack so this

578
00:27:06,120 --> 00:27:10,559
is a bit of a an exercise of a return

579
00:27:10,559 --> 00:27:13,500
oriented programming while trying to

580
00:27:13,500 --> 00:27:16,080
avoid the certain addresses that we

581
00:27:16,080 --> 00:27:18,240
wrote before

582
00:27:18,240 --> 00:27:20,700
but at the end of the day we managed we

583
00:27:20,700 --> 00:27:22,620
managed to do it we managed to overwrite

584
00:27:22,620 --> 00:27:23,760
uh

585
00:27:23,760 --> 00:27:25,559
uh the pointer of one command the

586
00:27:25,559 --> 00:27:27,360
specific it's called destroy attestation

587
00:27:27,360 --> 00:27:29,940
IDs but it's not important we you can

588
00:27:29,940 --> 00:27:33,240
choose any any of them uh and from there

589
00:27:33,240 --> 00:27:37,500
we are able to uh move away from

590
00:27:37,500 --> 00:27:39,779
um the context the the stack of the

591
00:27:39,779 --> 00:27:43,820
command Handler and write our uh final

592
00:27:43,820 --> 00:27:48,240
our final payload elsewhere in the stock

593
00:27:48,240 --> 00:27:50,279
where we are able to have all the space

594
00:27:50,279 --> 00:27:51,980
we need and

595
00:27:51,980 --> 00:27:55,080
and complete our exploit

596
00:27:55,080 --> 00:27:58,799
so uh once we are here it's everything

597
00:27:58,799 --> 00:28:01,380
is aligned uh to complete to complete

598
00:28:01,380 --> 00:28:03,960
the exploit as I said all we need to do

599
00:28:03,960 --> 00:28:05,220
is

600
00:28:05,220 --> 00:28:06,200
um

601
00:28:06,200 --> 00:28:09,840
well do the uh complete the attack as we

602
00:28:09,840 --> 00:28:12,120
want and the thing that makes most sense

603
00:28:12,120 --> 00:28:13,799
when uh attacking something like the

604
00:28:13,799 --> 00:28:16,440
titanium is uh trying to exfiltrate

605
00:28:16,440 --> 00:28:20,340
memory secrets so what we do is uh we

606
00:28:20,340 --> 00:28:23,580
jump to mem copy with some arguments

607
00:28:23,580 --> 00:28:26,100
that we choose to be able to leak

608
00:28:26,100 --> 00:28:27,960
arbitrary memory

609
00:28:27,960 --> 00:28:29,840
in the memory of the chip

610
00:28:29,840 --> 00:28:34,320
this time doing it with a zero day so we

611
00:28:34,320 --> 00:28:38,100
are able to leak uh the secrets that are

612
00:28:38,100 --> 00:28:39,779
kept by

613
00:28:39,779 --> 00:28:41,779
um by the Chip

614
00:28:41,779 --> 00:28:45,620
And practically achieve some uh some

615
00:28:45,620 --> 00:28:48,960
damage let's say to the security model

616
00:28:48,960 --> 00:28:52,140
of of uh of the pixel so let me give you

617
00:28:52,140 --> 00:28:54,120
a concrete example

618
00:28:54,120 --> 00:28:56,039
um and that is in the context of

619
00:28:56,039 --> 00:28:59,760
strongbox keys so strongbox is the

620
00:28:59,760 --> 00:29:03,140
harder backed version of of keystore

621
00:29:03,140 --> 00:29:05,520
basically it is the highest level of

622
00:29:05,520 --> 00:29:08,159
Security for Android cryptographic Keys

623
00:29:08,159 --> 00:29:11,460
these keys are not stored anywhere in

624
00:29:11,460 --> 00:29:13,799
plain text are stored encrypted in the

625
00:29:13,799 --> 00:29:15,659
Android file system and they can only be

626
00:29:15,659 --> 00:29:18,539
used by the Titan M that will decrypt

627
00:29:18,539 --> 00:29:21,120
the keys and use them to perform the key

628
00:29:21,120 --> 00:29:23,640
operation that is requested so this is

629
00:29:23,640 --> 00:29:25,679
the highest level of security for keys

630
00:29:25,679 --> 00:29:29,779
in Android and can and we actually

631
00:29:29,779 --> 00:29:32,760
defeated with the exploit that we have

632
00:29:32,760 --> 00:29:35,520
the answer is yes of course otherwise I

633
00:29:35,520 --> 00:29:37,100
wouldn't be presenting it

634
00:29:37,100 --> 00:29:39,120
but how

635
00:29:39,120 --> 00:29:42,120
the way we can interact with strongbox

636
00:29:42,120 --> 00:29:45,120
keys and perform crypto operations is

637
00:29:45,120 --> 00:29:47,940
with three commands begin operation

638
00:29:47,940 --> 00:29:50,820
update operation and finish up finish

639
00:29:50,820 --> 00:29:54,059
operation now what can we do

640
00:29:54,059 --> 00:29:57,840
with the begin operation we send our key

641
00:29:57,840 --> 00:29:59,640
and let's say we want to do an

642
00:29:59,640 --> 00:30:02,779
encryption so we send our key and

643
00:30:02,779 --> 00:30:06,600
our plain text we say okay please

644
00:30:06,600 --> 00:30:08,880
titanium can you can you do can you

645
00:30:08,880 --> 00:30:12,840
encrypt this uh text with this key and

646
00:30:12,840 --> 00:30:14,880
data name will say of course I will

647
00:30:14,880 --> 00:30:17,940
decrypt the key put it in a fixed

648
00:30:17,940 --> 00:30:21,600
address and then uh use it to perform

649
00:30:21,600 --> 00:30:24,659
the operation so maybe you can already

650
00:30:24,659 --> 00:30:27,720
see where I'm going since the key is

651
00:30:27,720 --> 00:30:31,020
decrypted in a fixed address what we can

652
00:30:31,020 --> 00:30:33,899
do is get a

653
00:30:33,899 --> 00:30:37,260
the key blobs or the encrypted key from

654
00:30:37,260 --> 00:30:39,120
the Android file system

655
00:30:39,120 --> 00:30:42,120
Forge a begin operational request so we

656
00:30:42,120 --> 00:30:43,980
will tell titanium can you please use

657
00:30:43,980 --> 00:30:46,380
this key to perform this crypto

658
00:30:46,380 --> 00:30:50,460
operation and then instead of sending

659
00:30:50,460 --> 00:30:52,740
update and finish operation to actually

660
00:30:52,740 --> 00:30:55,559
perform the crypto operation we

661
00:30:55,559 --> 00:30:59,039
requested we run our exploit to read the

662
00:30:59,039 --> 00:31:02,820
memory from the fixed address where the

663
00:31:02,820 --> 00:31:06,419
key is is placed so we finally extract

664
00:31:06,419 --> 00:31:08,779
the key that is

665
00:31:08,779 --> 00:31:12,539
protected by the Titan and defeating the

666
00:31:12,539 --> 00:31:15,539
strongest level of security for uh

667
00:31:15,539 --> 00:31:18,360
cryptographic keys

668
00:31:18,360 --> 00:31:20,399
the only conditions to be able to run

669
00:31:20,399 --> 00:31:23,580
this attack is to be already root in the

670
00:31:23,580 --> 00:31:26,399
phone uh so of course this can be done

671
00:31:26,399 --> 00:31:29,220
on a rooted phone or with some kernel

672
00:31:29,220 --> 00:31:33,000
exploit which by the way is uh perfectly

673
00:31:33,000 --> 00:31:35,820
within the security model of the pixel

674
00:31:35,820 --> 00:31:38,580
uh of pixel smartphones the idea is that

675
00:31:38,580 --> 00:31:40,620
you have something like the Titan M to

676
00:31:40,620 --> 00:31:42,539
be able to protect from a kernel that is

677
00:31:42,539 --> 00:31:45,480
potentially already compromised so you

678
00:31:45,480 --> 00:31:47,940
have to be rude somehow and you have to

679
00:31:47,940 --> 00:31:50,279
have access to the key blobs to send it

680
00:31:50,279 --> 00:31:52,559
to the titanium so either of being

681
00:31:52,559 --> 00:31:54,539
instead of being root you can always

682
00:31:54,539 --> 00:31:57,539
have direct access access on the on the

683
00:31:57,539 --> 00:31:59,880
hardware or you have to be able to

684
00:31:59,880 --> 00:32:03,059
bypass a file based encryption the

685
00:32:03,059 --> 00:32:05,399
easiest way is to be in the kernel

686
00:32:05,399 --> 00:32:07,200
basically

687
00:32:07,200 --> 00:32:10,200
now uh this bug has been passed so it's

688
00:32:10,200 --> 00:32:13,919
not present anymore uh fortunately but I

689
00:32:13,919 --> 00:32:16,440
want to just spend a minute on one

690
00:32:16,440 --> 00:32:19,020
potential mitigation that is uh present

691
00:32:19,020 --> 00:32:22,260
in uh that is available and uh that

692
00:32:22,260 --> 00:32:24,779
would make this attack Impossible uh

693
00:32:24,779 --> 00:32:27,120
this doesn't seem to be really

694
00:32:27,120 --> 00:32:31,380
that much used uh in uh in strongbox use

695
00:32:31,380 --> 00:32:34,440
cases but I think it's still worth a

696
00:32:34,440 --> 00:32:37,200
little discussion which is the creation

697
00:32:37,200 --> 00:32:40,799
of authentication bound keys so the idea

698
00:32:40,799 --> 00:32:43,140
is that you can when generating a

699
00:32:43,140 --> 00:32:45,620
strongbox key you can

700
00:32:45,620 --> 00:32:48,960
add an extra line to

701
00:32:48,960 --> 00:32:49,559
um

702
00:32:49,559 --> 00:32:53,659
ask the key to only be used under

703
00:32:53,659 --> 00:32:56,580
authentication so whenever the user will

704
00:32:56,580 --> 00:32:57,960
want to perform a cryptographic

705
00:32:57,960 --> 00:33:00,240
operation with that key the user will

706
00:33:00,240 --> 00:33:02,340
have to go through some authentication

707
00:33:02,340 --> 00:33:04,500
other via Biometrics or with an

708
00:33:04,500 --> 00:33:07,380
authentication factor and this will add

709
00:33:07,380 --> 00:33:10,500
an extra field in the begin operation

710
00:33:10,500 --> 00:33:13,399
request that we cannot Forge we cannot

711
00:33:13,399 --> 00:33:17,039
access in any way so we if one key is

712
00:33:17,039 --> 00:33:19,620
authentication protected we cannot leak

713
00:33:19,620 --> 00:33:23,580
it using the exploit that I showed

714
00:33:23,580 --> 00:33:24,600
earlier

715
00:33:24,600 --> 00:33:26,220
so this is an interesting mitigation

716
00:33:26,220 --> 00:33:28,799
that however is kind of impacting the

717
00:33:28,799 --> 00:33:30,480
usability of that key because if every

718
00:33:30,480 --> 00:33:32,460
time you want to encrypt something you

719
00:33:32,460 --> 00:33:35,700
have to authenticate it is a bit of a

720
00:33:35,700 --> 00:33:39,899
hurdle to the final user

721
00:33:39,899 --> 00:33:41,940
so

722
00:33:41,940 --> 00:33:45,120
um let's just wrap up with some

723
00:33:45,120 --> 00:33:48,360
conclusions the titanium was an

724
00:33:48,360 --> 00:33:49,620
interesting Target for us because

725
00:33:49,620 --> 00:33:54,779
despite being so hard to despite being

726
00:33:54,779 --> 00:33:56,880
so hard to interact with it it still

727
00:33:56,880 --> 00:34:00,080
offers a number of different approaches

728
00:34:00,080 --> 00:34:02,640
to try to perform vulnerability research

729
00:34:02,640 --> 00:34:04,039
on it

730
00:34:04,039 --> 00:34:06,720
with black box fuzzing you can try to

731
00:34:06,720 --> 00:34:09,179
get the surface bugs so it's easy to

732
00:34:09,179 --> 00:34:12,540
mount a fuzzer and see what you can what

733
00:34:12,540 --> 00:34:15,599
you can find while with emulation based

734
00:34:15,599 --> 00:34:17,580
there is a little bit more work required

735
00:34:17,580 --> 00:34:21,300
but there you can get more interesting

736
00:34:21,300 --> 00:34:24,000
results by having more visibility over

737
00:34:24,000 --> 00:34:27,060
the targets the idea is that you can

738
00:34:27,060 --> 00:34:28,980
also play with both approaches depending

739
00:34:28,980 --> 00:34:31,199
on the time frame that you can allocate

740
00:34:31,199 --> 00:34:34,139
for a specific task and these two

741
00:34:34,139 --> 00:34:36,839
approaches are extremely portable they

742
00:34:36,839 --> 00:34:39,179
work for any similar Target which is a

743
00:34:39,179 --> 00:34:41,040
little bit of the reason also why we

744
00:34:41,040 --> 00:34:42,780
want to share these results

745
00:34:42,780 --> 00:34:45,060
we managed to find an interesting zero

746
00:34:45,060 --> 00:34:47,699
day that gave us a code execution

747
00:34:47,699 --> 00:34:50,099
exploit on the chip it was quite a right

748
00:34:50,099 --> 00:34:52,980
to exploit it but at the end of the day

749
00:34:52,980 --> 00:34:57,740
we can leak any memory region in the

750
00:34:57,740 --> 00:34:59,700
Chip's memory

751
00:34:59,700 --> 00:35:03,180
which allows to break some of the

752
00:35:03,180 --> 00:35:06,200
security properties of the chip such as

753
00:35:06,200 --> 00:35:10,200
the protection given by strongbox keys

754
00:35:10,200 --> 00:35:13,260
so this is it you can find all the

755
00:35:13,260 --> 00:35:17,640
resources uh on our GitHub repository as

756
00:35:17,640 --> 00:35:19,200
well as in a blog post where we went

757
00:35:19,200 --> 00:35:22,200
over uh all the little details of the

758
00:35:22,200 --> 00:35:25,260
exploitation which I realized can be a

759
00:35:25,260 --> 00:35:27,960
little bit confusing in a few minutes of

760
00:35:27,960 --> 00:35:29,339
of presentation

761
00:35:29,339 --> 00:35:31,440
and that's it thank you very much and

762
00:35:31,440 --> 00:35:34,579
I'm happy to take any questions

763
00:35:35,339 --> 00:35:37,820
see

