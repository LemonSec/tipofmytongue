1
00:00:26,720 --> 00:00:30,480
welcome to Barnabas to Echo party

2
00:00:30,480 --> 00:00:33,480
foreign

3
00:00:51,559 --> 00:00:54,719
security and today we are gonna see some

4
00:00:54,719 --> 00:00:57,059
techniques that can be used in the

5
00:00:57,059 --> 00:00:59,340
exploitation of pool overflows in the

6
00:00:59,340 --> 00:01:02,340
windows segment Heap

7
00:01:02,340 --> 00:01:05,099
so the agenda for today

8
00:01:05,099 --> 00:01:08,100
we are gonna start with some background

9
00:01:08,100 --> 00:01:11,820
information and then we are going to get

10
00:01:11,820 --> 00:01:13,860
into the actual exploitation techniques

11
00:01:13,860 --> 00:01:16,020
finally we are going to conclude with

12
00:01:16,020 --> 00:01:18,420
some tools that can be used for

13
00:01:18,420 --> 00:01:22,259
debugging uh the windows segment hip

14
00:01:22,259 --> 00:01:25,259
internals

15
00:01:26,400 --> 00:01:27,780
just a quick overview of the

16
00:01:27,780 --> 00:01:29,100
capabilities that are going to get

17
00:01:29,100 --> 00:01:32,700
provided by the technology

18
00:01:32,700 --> 00:01:36,180
so the minimum required overflow size is

19
00:01:36,180 --> 00:01:38,340
going to be three bytes

20
00:01:38,340 --> 00:01:40,820
as we can see there there are no

21
00:01:40,820 --> 00:01:43,320
requirements on the actual overflow data

22
00:01:43,320 --> 00:01:45,240
so the Overflow data can be completed

23
00:01:45,240 --> 00:01:49,560
random and that will not affect the the

24
00:01:49,560 --> 00:01:53,399
success rate of the uh of using the

25
00:01:53,399 --> 00:01:55,159
techniques

26
00:01:55,159 --> 00:01:58,680
hip grooming is not easy but as we can

27
00:01:58,680 --> 00:02:00,780
see later on it's not going to be

28
00:02:00,780 --> 00:02:02,579
difficult either

29
00:02:02,579 --> 00:02:05,040
there is no dependence on the dynamic

30
00:02:05,040 --> 00:02:07,200
plural side and the techniques are

31
00:02:07,200 --> 00:02:10,220
applicable in different implementations

32
00:02:10,220 --> 00:02:14,280
of the windows segment hip

33
00:02:14,280 --> 00:02:17,580
we forgot now we are gonna have a high

34
00:02:17,580 --> 00:02:21,660
level overview of the flow and dynamic

35
00:02:21,660 --> 00:02:24,300
memory request flow dynamic memory

36
00:02:24,300 --> 00:02:26,400
request is going to take and that's

37
00:02:26,400 --> 00:02:29,220
going to be useful to to see the

38
00:02:29,220 --> 00:02:31,459
different entities involved

39
00:02:31,459 --> 00:02:34,020
when serving a dynamic memory request

40
00:02:34,020 --> 00:02:36,480
and we are going to see where different

41
00:02:36,480 --> 00:02:40,819
method that may come up and how we can

42
00:02:40,819 --> 00:02:44,040
Target those metal bit

43
00:02:44,040 --> 00:02:48,239
so we have a client that needs some

44
00:02:48,239 --> 00:02:51,000
memory it puts forward a request

45
00:02:51,000 --> 00:02:54,420
that Quest goes to the genetic Handler

46
00:02:54,420 --> 00:02:57,540
the generic Handler is

47
00:02:57,540 --> 00:03:00,500
is responsible for implementing

48
00:03:00,500 --> 00:03:02,700
functionalities provided by the kernel

49
00:03:02,700 --> 00:03:05,640
when it comes to dynamic memory

50
00:03:05,640 --> 00:03:08,640
like for example quota management and to

51
00:03:08,640 --> 00:03:11,340
implement those functionalities it

52
00:03:11,340 --> 00:03:14,099
requires some metadata which can be

53
00:03:14,099 --> 00:03:15,720
either be embedded within the chunk

54
00:03:15,720 --> 00:03:17,519
itself normally at the beginning of the

55
00:03:17,519 --> 00:03:20,940
chunk or that can be stored outside the

56
00:03:20,940 --> 00:03:24,440
Chunk in a separate space

57
00:03:24,659 --> 00:03:27,360
uh but the generic Handler doesn't

58
00:03:27,360 --> 00:03:30,019
manage any memory so to actually have

59
00:03:30,019 --> 00:03:33,300
the chunk allocated it will have to

60
00:03:33,300 --> 00:03:35,340
forward the request to one of the second

61
00:03:35,340 --> 00:03:37,379
level allocators

62
00:03:37,379 --> 00:03:39,840
and as we can see there are a couple of

63
00:03:39,840 --> 00:03:41,700
them so

64
00:03:41,700 --> 00:03:43,319
uh

65
00:03:43,319 --> 00:03:45,659
in order for the generic hundred to Peak

66
00:03:45,659 --> 00:03:47,940
to which second level allocator is going

67
00:03:47,940 --> 00:03:50,340
to focus the request the primary

68
00:03:50,340 --> 00:03:55,440
criteria is the request size so let's

69
00:03:55,440 --> 00:03:58,019
say the LF allocator is responsible for

70
00:03:58,019 --> 00:04:00,720
a specific request size range the vs

71
00:04:00,720 --> 00:04:02,519
allocator for a different range and so

72
00:04:02,519 --> 00:04:03,540
on

73
00:04:03,540 --> 00:04:06,180
so now we are in the second level

74
00:04:06,180 --> 00:04:10,019
locators and here you can think of each

75
00:04:10,019 --> 00:04:11,840
of these allocators

76
00:04:11,840 --> 00:04:14,580
conceptually to be similar with let's

77
00:04:14,580 --> 00:04:17,579
say malloc so they they get a big chunk

78
00:04:17,579 --> 00:04:20,399
in memory of memory and they manage that

79
00:04:20,399 --> 00:04:23,160
chunk and use it to serve potentially

80
00:04:23,160 --> 00:04:27,780
smaller size requests so here we assume

81
00:04:27,780 --> 00:04:29,100
that the request goes to the vs

82
00:04:29,100 --> 00:04:31,520
allocator

83
00:04:32,720 --> 00:04:36,240
request size and finds a chunk that's

84
00:04:36,240 --> 00:04:40,080
suitable to serve that request so we see

85
00:04:40,080 --> 00:04:42,540
that is helper here found the chunk it

86
00:04:42,540 --> 00:04:44,160
returned the chunk back to the generic

87
00:04:44,160 --> 00:04:45,060
Handler

88
00:04:45,060 --> 00:04:47,639
the genetic Handler added its own

89
00:04:47,639 --> 00:04:51,240
metadata to the chunk and returned that

90
00:04:51,240 --> 00:04:54,120
chunk back to the client

91
00:04:54,120 --> 00:04:57,060
it's noted that neither the client nor

92
00:04:57,060 --> 00:04:59,040
the generic Handler are necessarily

93
00:04:59,040 --> 00:05:02,220
aware of the method that are used by the

94
00:05:02,220 --> 00:05:04,919
upper layer functions

95
00:05:04,919 --> 00:05:06,960
so here we see that chunk returned to

96
00:05:06,960 --> 00:05:09,780
the client and as you can see it can

97
00:05:09,780 --> 00:05:12,660
have at least two different kinds of

98
00:05:12,660 --> 00:05:15,540
metadata it can have the generic 100

99
00:05:15,540 --> 00:05:18,120
million data and it can also have the vs

100
00:05:18,120 --> 00:05:21,000
allocator melendezvous in this talk we

101
00:05:21,000 --> 00:05:23,100
are gonna focus on the and we are going

102
00:05:23,100 --> 00:05:26,039
to Target the vs allocator metadata but

103
00:05:26,039 --> 00:05:29,039
it's noted that previous work in the

104
00:05:29,039 --> 00:05:31,580
windows exploitation targeted

105
00:05:31,580 --> 00:05:34,440
their generated man data

106
00:05:34,440 --> 00:05:36,600
and if you haven't checked it already

107
00:05:36,600 --> 00:05:38,759
have a look at the work done by

108
00:05:38,759 --> 00:05:41,220
quarantine buy it and Paul farrello

109
00:05:41,220 --> 00:05:42,840
hopefully I haven't butchered their

110
00:05:42,840 --> 00:05:46,080
names too much but they they did a great

111
00:05:46,080 --> 00:05:48,479
work documenting the segment Cube

112
00:05:48,479 --> 00:05:52,139
internals as well as exploitation

113
00:05:52,139 --> 00:05:54,240
techniques

114
00:05:54,240 --> 00:05:57,660
that Target those uh as we said the

115
00:05:57,660 --> 00:06:00,120
generic handles metadata

116
00:06:00,120 --> 00:06:02,220
so now we are going to get into the vs

117
00:06:02,220 --> 00:06:04,620
allocator internals

118
00:06:04,620 --> 00:06:08,360
and here we can see the sizes

119
00:06:08,360 --> 00:06:11,699
which the engineering Handler uses to

120
00:06:11,699 --> 00:06:14,160
forgot the request to the vs allocator

121
00:06:14,160 --> 00:06:17,240
and we can see that the VSR local

122
00:06:17,240 --> 00:06:19,740
internal mode is responsible for a quite

123
00:06:19,740 --> 00:06:21,600
wide range of requests

124
00:06:21,600 --> 00:06:24,900
and it's noted that along with the LFA

125
00:06:24,900 --> 00:06:30,620
allocator are the two most commonly used

126
00:06:30,620 --> 00:06:35,039
allocators in the windows segment Cube

127
00:06:35,039 --> 00:06:37,440
so now we're gonna see the possible

128
00:06:37,440 --> 00:06:38,900
chunk States

129
00:06:38,900 --> 00:06:42,300
so when a chunk a chunk that belongs to

130
00:06:42,300 --> 00:06:44,960
the vs allocator can be

131
00:06:44,960 --> 00:06:48,000
in either of the two states either freed

132
00:06:48,000 --> 00:06:51,479
or used and depending on its state it

133
00:06:51,479 --> 00:06:53,759
will have different metadata associated

134
00:06:53,759 --> 00:06:55,440
with it

135
00:06:55,440 --> 00:06:59,160
so now let's see they use chunk States

136
00:06:59,160 --> 00:07:02,639
and we say that the chunk is used when

137
00:07:02,639 --> 00:07:06,000
has been allocated to a client and

138
00:07:06,000 --> 00:07:09,300
it had and the client having uh the

139
00:07:09,300 --> 00:07:11,520
allocated that chunk those chunks are

140
00:07:11,520 --> 00:07:14,699
headed with uh the header shown

141
00:07:14,699 --> 00:07:18,539
in the slide here and we can see also uh

142
00:07:18,539 --> 00:07:20,099
its fields

143
00:07:20,099 --> 00:07:23,000
and from those fields uh our primary

144
00:07:23,000 --> 00:07:25,259
field of interest is going to be the

145
00:07:25,259 --> 00:07:28,800
sizes field since that field is going to

146
00:07:28,800 --> 00:07:31,620
be the target of the Overflow part of

147
00:07:31,620 --> 00:07:33,680
part of that field

148
00:07:33,680 --> 00:07:38,039
and so here we can see the structure of

149
00:07:38,039 --> 00:07:40,740
the sizes field

150
00:07:40,740 --> 00:07:44,819
and among those subfields of the sizes

151
00:07:44,819 --> 00:07:48,120
we are gonna Target the memory cost and

152
00:07:48,120 --> 00:07:52,020
the unsafe size with the Overflow

153
00:07:52,020 --> 00:07:55,020
it's not as bad the sizes field is is

154
00:07:55,020 --> 00:07:58,259
encoded in memory so regardless of the

155
00:07:58,259 --> 00:08:02,220
initial values of the subfields stored

156
00:08:02,220 --> 00:08:04,400
within the resizes field

157
00:08:04,400 --> 00:08:06,539
all their values are going to be

158
00:08:06,539 --> 00:08:09,680
randomized at the end

159
00:08:10,919 --> 00:08:12,780
so here we see the fields we are going

160
00:08:12,780 --> 00:08:14,699
to Target with the Overflow and we have

161
00:08:14,699 --> 00:08:16,380
the memory cost

162
00:08:16,380 --> 00:08:19,680
the normal cost is the number of pages

163
00:08:19,680 --> 00:08:24,060
occupied by a chunk excluding the page

164
00:08:24,060 --> 00:08:27,780
where it's headers lied to

165
00:08:27,780 --> 00:08:30,360
and

166
00:08:30,360 --> 00:08:32,458
this header this field is not

167
00:08:32,458 --> 00:08:33,779
particularly important for the attack

168
00:08:33,779 --> 00:08:35,940
but it just happens to be along the way

169
00:08:35,940 --> 00:08:39,299
of the Overflow path so we just see its

170
00:08:39,299 --> 00:08:42,120
use just to understand that we are not

171
00:08:42,120 --> 00:08:45,720
corrupting any important state of the

172
00:08:45,720 --> 00:08:48,240
the allocator but this field is noted

173
00:08:48,240 --> 00:08:49,920
that it can be it can potentially be

174
00:08:49,920 --> 00:08:52,680
used for the mitigations

175
00:08:52,680 --> 00:08:55,620
and next we have the unsafe size and and

176
00:08:55,620 --> 00:08:57,480
this is going to be the primary target

177
00:08:57,480 --> 00:08:59,459
of of the attacks we are going to

178
00:08:59,459 --> 00:09:01,260
describe later on

179
00:09:01,260 --> 00:09:03,600
uh and this field holds essentially the

180
00:09:03,600 --> 00:09:05,940
size of the chunk divided by 16 and is

181
00:09:05,940 --> 00:09:09,060
divided by 16 because uh the BS

182
00:09:09,060 --> 00:09:11,580
allocator hands out chunks

183
00:09:11,580 --> 00:09:13,740
and uh

184
00:09:13,740 --> 00:09:18,000
it has it has them aligned to 16 bytes

185
00:09:18,000 --> 00:09:20,899
boundaries

186
00:09:21,000 --> 00:09:24,360
next we have the free chunks uh of the

187
00:09:24,360 --> 00:09:28,140
vs allocator and he had a chance that uh

188
00:09:28,140 --> 00:09:31,260
we say that the Chinese fruit when the

189
00:09:31,260 --> 00:09:34,200
client has called the allocation apis

190
00:09:34,200 --> 00:09:37,320
and that China has been free it has been

191
00:09:37,320 --> 00:09:38,459
freed

192
00:09:38,459 --> 00:09:41,700
it can be in either of the three states

193
00:09:41,700 --> 00:09:43,680
release here it can be either part of

194
00:09:43,680 --> 00:09:46,140
the dynamic look outside the delay free

195
00:09:46,140 --> 00:09:50,580
list or be part of the free chunk tree

196
00:09:50,580 --> 00:09:53,040
it's noted that for the purpose of this

197
00:09:53,040 --> 00:09:54,779
talk we are going to focus on the free

198
00:09:54,779 --> 00:09:55,920
chunk three

199
00:09:55,920 --> 00:09:58,200
since that's going to be the state of

200
00:09:58,200 --> 00:09:59,839
the chunks that we are going to attack

201
00:09:59,839 --> 00:10:02,880
but uh

202
00:10:02,880 --> 00:10:07,080
if people want to get a closer look into

203
00:10:07,080 --> 00:10:09,060
the internals of the dynamic look at the

204
00:10:09,060 --> 00:10:12,360
delay free list you can have a look at

205
00:10:12,360 --> 00:10:14,459
the associated blog post where we go

206
00:10:14,459 --> 00:10:19,220
into more details uh on how those

207
00:10:19,220 --> 00:10:23,339
mechanisms are implemented

208
00:10:23,339 --> 00:10:26,279
so the future this is a primary

209
00:10:26,279 --> 00:10:29,100
structure used by the VSR locator to

210
00:10:29,100 --> 00:10:32,720
manage its chunks it's a red black tree

211
00:10:32,720 --> 00:10:36,360
and the chunks that belong to the to

212
00:10:36,360 --> 00:10:40,260
this red black tree are headed with the

213
00:10:40,260 --> 00:10:42,600
structure shown here the hip vs chunk

214
00:10:42,600 --> 00:10:44,760
free header

215
00:10:44,760 --> 00:10:47,279
and we can see the fields of this

216
00:10:47,279 --> 00:10:48,779
structure

217
00:10:48,779 --> 00:10:51,899
and we can see the first field is a

218
00:10:51,899 --> 00:10:57,240
field that overlaps with the use chunk

219
00:10:57,240 --> 00:10:59,339
and essentially this field is going is

220
00:10:59,339 --> 00:11:02,220
going to be the sizes field we we've

221
00:11:02,220 --> 00:11:06,360
seen previously on the used chunk

222
00:11:06,360 --> 00:11:09,440
after that we have the note

223
00:11:09,440 --> 00:11:14,399
field which is used to maintain the red

224
00:11:14,399 --> 00:11:17,660
black tree it's a classic note

225
00:11:17,660 --> 00:11:21,480
uh filled with we can see the left right

226
00:11:21,480 --> 00:11:25,200
and parent subfields

227
00:11:26,399 --> 00:11:28,200
now we are going to get into the

228
00:11:28,200 --> 00:11:30,800
allocation and the allocation processes

229
00:11:30,800 --> 00:11:35,040
related with the future

230
00:11:35,040 --> 00:11:36,899
and we can start with the allocation

231
00:11:36,899 --> 00:11:39,360
process that in the allocation process

232
00:11:39,360 --> 00:11:41,339
so when there is a request to the

233
00:11:41,339 --> 00:11:43,339
allocated chunk

234
00:11:43,339 --> 00:11:46,260
we are gonna first run the quality

235
00:11:46,260 --> 00:11:48,660
procedure and here we are gonna see the

236
00:11:48,660 --> 00:11:51,839
adjacent chunks of the requested chunk

237
00:11:51,839 --> 00:11:54,060
for the allocation

238
00:11:54,060 --> 00:11:56,160
we are going to have we are gonna see if

239
00:11:56,160 --> 00:11:58,200
it suggests and chunks are already freed

240
00:11:58,200 --> 00:12:00,000
and if they are already freed they are

241
00:12:00,000 --> 00:12:02,880
gonna get merged with the with the

242
00:12:02,880 --> 00:12:05,760
actual Target of the the allocation and

243
00:12:05,760 --> 00:12:08,040
the potentially merged chunk is gonna

244
00:12:08,040 --> 00:12:10,860
get added to the three chunk tree which

245
00:12:10,860 --> 00:12:12,540
is the red black tree structure we

246
00:12:12,540 --> 00:12:16,200
previously uh discussed and we can see a

247
00:12:16,200 --> 00:12:18,380
diagram here that shows

248
00:12:18,380 --> 00:12:22,740
uh how the how this coalescing might

249
00:12:22,740 --> 00:12:25,459
work in practice

250
00:12:25,560 --> 00:12:29,640
this is our location process and it's

251
00:12:29,640 --> 00:12:32,160
easier to just see the diagram so we

252
00:12:32,160 --> 00:12:35,040
have a request for a particular size

253
00:12:35,040 --> 00:12:37,019
that request goes to the vs allocator

254
00:12:37,019 --> 00:12:39,839
maybe it's allocator adjusts the request

255
00:12:39,839 --> 00:12:43,620
size to account for its own metadata so

256
00:12:43,620 --> 00:12:45,779
here we can see that it added 16 bytes

257
00:12:45,779 --> 00:12:50,639
and the new adjust set size is 400 in

258
00:12:50,639 --> 00:12:53,579
HEX bytes after having the adjusted size

259
00:12:53,579 --> 00:12:56,720
the piece are located

260
00:12:56,720 --> 00:13:00,060
iterates the free Chantry using a best

261
00:13:00,060 --> 00:13:02,820
fit strategy and tries to find the chunk

262
00:13:02,820 --> 00:13:06,120
that's suitable to say is the most

263
00:13:06,120 --> 00:13:07,980
suitable to serve that particular

264
00:13:07,980 --> 00:13:11,519
request in this example you can see that

265
00:13:11,519 --> 00:13:15,139
the 900 chunk was the one that

266
00:13:15,139 --> 00:13:18,360
was picked and was selected to serve

267
00:13:18,360 --> 00:13:19,560
that request

268
00:13:19,560 --> 00:13:21,420
and

269
00:13:21,420 --> 00:13:24,560
next the allocator is going to check if

270
00:13:24,560 --> 00:13:27,720
this identified chunk is bigger than the

271
00:13:27,720 --> 00:13:29,579
chunk that was actually done the size

272
00:13:29,579 --> 00:13:31,980
that was actually requested

273
00:13:31,980 --> 00:13:34,019
and if it's bigger than the actual

274
00:13:34,019 --> 00:13:36,540
request size is going to go through the

275
00:13:36,540 --> 00:13:38,220
splitting phase and the splitting phase

276
00:13:38,220 --> 00:13:40,579
we are essentially going to break apart

277
00:13:40,579 --> 00:13:43,740
uh the identified changing two the first

278
00:13:43,740 --> 00:13:47,060
part is going to

279
00:13:47,060 --> 00:13:51,240
get used to serve the actual request and

280
00:13:51,240 --> 00:13:53,459
the second part what we call here the

281
00:13:53,459 --> 00:13:56,279
reminder chunk is going to get added

282
00:13:56,279 --> 00:14:00,180
back to the free chunk tree to end it's

283
00:14:00,180 --> 00:14:02,579
gonna get used potentially used in

284
00:14:02,579 --> 00:14:05,760
future requests

285
00:14:05,760 --> 00:14:09,360
so just to drive it home we have to see

286
00:14:09,360 --> 00:14:12,000
the same scenarios before but we have

287
00:14:12,000 --> 00:14:14,639
now changed a little bit the the state

288
00:14:14,639 --> 00:14:16,079
of the red black tree

289
00:14:16,079 --> 00:14:18,600
we change some notes from the tree so

290
00:14:18,600 --> 00:14:20,700
again we have a request of three of zero

291
00:14:20,700 --> 00:14:23,880
size we adjusted that size we have 400

292
00:14:23,880 --> 00:14:26,040
size adjusted size

293
00:14:26,040 --> 00:14:30,480
and we now we want to see which chunk is

294
00:14:30,480 --> 00:14:33,540
going to get used to serve that request

295
00:14:33,540 --> 00:14:35,760
so we're going to give it a couple of

296
00:14:35,760 --> 00:14:37,800
seconds which channel do you think is

297
00:14:37,800 --> 00:14:41,420
going to get used to serve that request

298
00:14:45,079 --> 00:14:51,300
so anybody picked chunk with size 0x200

299
00:14:51,600 --> 00:14:53,519
raise your hands

300
00:14:53,519 --> 00:14:56,220
so fortunately there are no hands raised

301
00:14:56,220 --> 00:14:59,100
otherwise we may have to prematurely end

302
00:14:59,100 --> 00:15:00,540
the presentation

303
00:15:00,540 --> 00:15:02,279
but

304
00:15:02,279 --> 00:15:06,660
if you picked a chunk with size 400

305
00:15:06,660 --> 00:15:10,740
then that's gonna be wrong as well but

306
00:15:10,740 --> 00:15:13,860
that was a reasonable uh choice

307
00:15:13,860 --> 00:15:16,620
and the correct the China is going to

308
00:15:16,620 --> 00:15:18,899
get picked is gonna be the chiangle size

309
00:15:18,899 --> 00:15:21,839
500 and we can see that this then it's

310
00:15:21,839 --> 00:15:23,519
gonna go through the splitting phase the

311
00:15:23,519 --> 00:15:25,620
fs400 bytes are going to get returned to

312
00:15:25,620 --> 00:15:28,139
the to the client and the other part is

313
00:15:28,139 --> 00:15:29,579
going to get added back to the free

314
00:15:29,579 --> 00:15:31,440
Chantry

315
00:15:31,440 --> 00:15:34,740
but why did we pick the 500 chunk since

316
00:15:34,740 --> 00:15:36,800
we had in the three

317
00:15:36,800 --> 00:15:41,160
uh the 400 chunk which was the exact uh

318
00:15:41,160 --> 00:15:44,220
request size and the reason for that is

319
00:15:44,220 --> 00:15:47,459
uh two optimizations found in the

320
00:15:47,459 --> 00:15:49,079
current mode implementation of the of

321
00:15:49,079 --> 00:15:51,839
the segment Heap which are enabled with

322
00:15:51,839 --> 00:15:54,779
the page align large shallux flag and

323
00:15:54,779 --> 00:15:57,360
those two optimizations are first the

324
00:15:57,360 --> 00:16:00,440
allocator is designed to efficiently

325
00:16:00,440 --> 00:16:03,120
allocate chunks that are bigger than a

326
00:16:03,120 --> 00:16:05,100
page and have those chunks be page

327
00:16:05,100 --> 00:16:06,060
aligned

328
00:16:06,060 --> 00:16:09,000
and second it's designed to maximize the

329
00:16:09,000 --> 00:16:11,899
memory that can be decommitted

330
00:16:11,899 --> 00:16:14,639
for the chunks that are part of the free

331
00:16:14,639 --> 00:16:16,320
Chantry

332
00:16:16,320 --> 00:16:18,480
I'm going to more details into how the

333
00:16:18,480 --> 00:16:21,420
first optimization is implemented and we

334
00:16:21,420 --> 00:16:23,760
can see that in order to have those

335
00:16:23,760 --> 00:16:25,740
chunks be page aligned

336
00:16:25,740 --> 00:16:27,600
they are located or follows a simple

337
00:16:27,600 --> 00:16:30,120
rule and that rule is that only chunks

338
00:16:30,120 --> 00:16:33,420
that are that started page offset f is

339
00:16:33,420 --> 00:16:36,139
zero can be

340
00:16:36,139 --> 00:16:40,079
can be crossing the boundaries of a page

341
00:16:40,079 --> 00:16:43,560
all the other chunks have to be confined

342
00:16:43,560 --> 00:16:46,079
with it within a single page and this

343
00:16:46,079 --> 00:16:47,540
design decision

344
00:16:47,540 --> 00:16:50,160
affects both the allocation and the

345
00:16:50,160 --> 00:16:52,800
allocation processes in the allocation

346
00:16:52,800 --> 00:16:55,259
process if you recall with we mentioned

347
00:16:55,259 --> 00:16:58,740
the quality procedure where we might we

348
00:16:58,740 --> 00:17:00,899
might end up with a merged chunk

349
00:17:00,899 --> 00:17:04,199
that chunk is gonna get checked to see

350
00:17:04,199 --> 00:17:06,720
if it's indeed following the rule we

351
00:17:06,720 --> 00:17:09,059
mentioned before so that Chuck is going

352
00:17:09,059 --> 00:17:11,760
to get checked to see if it starts if

353
00:17:11,760 --> 00:17:13,199
it's close if it's crossing the page

354
00:17:13,199 --> 00:17:16,199
boundaries and if it does and it doesn't

355
00:17:16,199 --> 00:17:18,059
start at page offset f is zero it's

356
00:17:18,059 --> 00:17:20,099
gonna get split and we can see this

357
00:17:20,099 --> 00:17:22,559
process in the diagram below we are a

358
00:17:22,559 --> 00:17:23,880
Chinese close to the page but that is

359
00:17:23,880 --> 00:17:25,740
but does it start at the page of setup

360
00:17:25,740 --> 00:17:29,720
is zero and the first part of that chunk

361
00:17:29,720 --> 00:17:33,240
uh is split and we can see that it's

362
00:17:33,240 --> 00:17:34,679
confined within a single page and the

363
00:17:34,679 --> 00:17:36,840
second part is crossing the page but

364
00:17:36,840 --> 00:17:39,480
that is and it starts a page of set f is

365
00:17:39,480 --> 00:17:42,840
zero and we have the same uh something

366
00:17:42,840 --> 00:17:45,480
similar happen in the allocation process

367
00:17:45,480 --> 00:17:48,480
in now in the splitting procedure where

368
00:17:48,480 --> 00:17:51,120
we we might end up with the as we said

369
00:17:51,120 --> 00:17:53,400
before we might end up with a reminder

370
00:17:53,400 --> 00:17:56,340
chunk that reminds the chunk is gonna

371
00:17:56,340 --> 00:17:59,580
get checked again and see if it follows

372
00:17:59,580 --> 00:18:01,200
a

373
00:18:01,200 --> 00:18:06,120
the rule we have mentioned before

374
00:18:07,740 --> 00:18:11,160
but why do we say that why did they pick

375
00:18:11,160 --> 00:18:13,500
the offset fe0

376
00:18:13,500 --> 00:18:15,960
since we know that they use chunk here

377
00:18:15,960 --> 00:18:18,240
that is 16 bytes if we start the chunk

378
00:18:18,240 --> 00:18:21,539
at page of set f is 0 then

379
00:18:21,539 --> 00:18:24,419
the user did how the chunk are going to

380
00:18:24,419 --> 00:18:27,419
be placed at page offset ff0

381
00:18:27,419 --> 00:18:30,539
so that kind of Beats the the purpose of

382
00:18:30,539 --> 00:18:32,520
implementing this optimization which was

383
00:18:32,520 --> 00:18:35,220
supposed to have the chunk be page

384
00:18:35,220 --> 00:18:36,780
aligned

385
00:18:36,780 --> 00:18:39,660
and there is on why they picked the page

386
00:18:39,660 --> 00:18:43,500
of F0 is related with the second

387
00:18:43,500 --> 00:18:45,780
optimization where we said that it's

388
00:18:45,780 --> 00:18:47,580
designed to maximize the memory that can

389
00:18:47,580 --> 00:18:49,020
be decommitted

390
00:18:49,020 --> 00:18:52,679
and they do this

391
00:18:52,679 --> 00:18:54,960
this optimization is implemented by

392
00:18:54,960 --> 00:18:58,200
adding an extra 16 bytes to the chunks

393
00:18:58,200 --> 00:19:01,380
as padding to the chunks that start a

394
00:19:01,380 --> 00:19:04,080
page offset f is zero

395
00:19:04,080 --> 00:19:07,140
so now at page of set f is zero we are

396
00:19:07,140 --> 00:19:10,740
going to have the used used header

397
00:19:10,740 --> 00:19:14,039
use chunk headers and at page offset ff0

398
00:19:14,039 --> 00:19:15,960
we are going to have the padding so the

399
00:19:15,960 --> 00:19:18,240
users uh

400
00:19:18,240 --> 00:19:20,400
so the user data portion of the chunk

401
00:19:20,400 --> 00:19:24,179
now is going to be page aligned but why

402
00:19:24,179 --> 00:19:27,480
is this uh useful in maximizing the

403
00:19:27,480 --> 00:19:30,120
memory we had the commit so on the left

404
00:19:30,120 --> 00:19:32,240
diagram we see

405
00:19:32,240 --> 00:19:34,740
a chunk

406
00:19:34,740 --> 00:19:37,919
so we see the scenario in case we didn't

407
00:19:37,919 --> 00:19:40,919
have this extra padding so if we started

408
00:19:40,919 --> 00:19:44,160
the changa page of set ff0 then after

409
00:19:44,160 --> 00:19:46,799
the chunk got freed

410
00:19:46,799 --> 00:19:50,340
it's friction headers which is 32 bytes

411
00:19:50,340 --> 00:19:54,240
would have crossed the page boundaries

412
00:19:54,240 --> 00:19:57,320
and it's also noted that when

413
00:19:57,320 --> 00:20:01,740
a page contains chunk headers then it

414
00:20:01,740 --> 00:20:03,600
cannot be decommitted

415
00:20:03,600 --> 00:20:06,480
so here because we have headers in both

416
00:20:06,480 --> 00:20:09,360
Pages both the previous and the both the

417
00:20:09,360 --> 00:20:12,660
previous page of X and at pagex then

418
00:20:12,660 --> 00:20:14,580
none of those pages can be the committed

419
00:20:14,580 --> 00:20:18,000
but now with the extra padding which you

420
00:20:18,000 --> 00:20:21,960
can see on the right diagram we can see

421
00:20:21,960 --> 00:20:24,840
that the whole free chunk header can fit

422
00:20:24,840 --> 00:20:27,960
within a single page so now we can free

423
00:20:27,960 --> 00:20:31,140
the page right after that

424
00:20:31,140 --> 00:20:34,020
and this is implemented this extra

425
00:20:34,020 --> 00:20:38,280
padding is implemented by

426
00:20:38,280 --> 00:20:41,460
now adding an extra step during the

427
00:20:41,460 --> 00:20:44,280
process where we adjust the request size

428
00:20:44,280 --> 00:20:47,100
before iterating the free chunk tree and

429
00:20:47,100 --> 00:20:49,380
we can see that now we are we add an

430
00:20:49,380 --> 00:20:53,820
extra 16 bytes so now the size that the

431
00:20:53,820 --> 00:20:56,640
adjusted request size is going to be 410

432
00:20:56,640 --> 00:21:00,000
and now makes more sense why we picked

433
00:21:00,000 --> 00:21:02,340
the 500 chunk

434
00:21:02,340 --> 00:21:05,539
uh so now now that we have a chunk uh

435
00:21:05,539 --> 00:21:08,280
identified the 500 chunk the the

436
00:21:08,280 --> 00:21:10,500
allocator is going to check if it starts

437
00:21:10,500 --> 00:21:12,780
a page offset f is zero

438
00:21:12,780 --> 00:21:15,720
and in this case we assume that it has a

439
00:21:15,720 --> 00:21:17,760
start at that offset so that it turn

440
00:21:17,760 --> 00:21:20,600
chunk size is going to be

441
00:21:20,600 --> 00:21:27,000
uh is going to be 400 bytes

442
00:21:27,080 --> 00:21:29,520
and it's gonna get split like and then

443
00:21:29,520 --> 00:21:30,720
the reminder of the challenge is going

444
00:21:30,720 --> 00:21:31,980
to get added back to the free chant

445
00:21:31,980 --> 00:21:33,600
cream

446
00:21:33,600 --> 00:21:36,179
but it's not that if the chunk if the

447
00:21:36,179 --> 00:21:38,280
500 chunk was starting at page offset f

448
00:21:38,280 --> 00:21:40,679
is zero then the return chunk size will

449
00:21:40,679 --> 00:21:44,039
have been 410.

450
00:21:44,940 --> 00:21:47,880
so that's uh the background information

451
00:21:47,880 --> 00:21:50,159
that we are going to use here we see a

452
00:21:50,159 --> 00:21:55,140
summary with the different sizes uh

453
00:21:55,140 --> 00:21:57,600
uh the different chunk sizes and how

454
00:21:57,600 --> 00:22:01,320
those sizes uh

455
00:22:01,320 --> 00:22:04,799
map to different characteristics found

456
00:22:04,799 --> 00:22:07,080
in both the generic Handler and the vs

457
00:22:07,080 --> 00:22:09,059
allocator this slide is useful for

458
00:22:09,059 --> 00:22:11,039
reference it's not particularly

459
00:22:11,039 --> 00:22:16,260
important to discuss any further for now

460
00:22:16,260 --> 00:22:17,880
now we're gonna get into the

461
00:22:17,880 --> 00:22:20,280
exploitation techniques we are going to

462
00:22:20,280 --> 00:22:22,320
start with the terminology

463
00:22:22,320 --> 00:22:25,440
so we have the vulnerable chunk what we

464
00:22:25,440 --> 00:22:27,679
call the vulnerable chunk and this chunk

465
00:22:27,679 --> 00:22:31,559
is a chunk of dynamic memory allocated

466
00:22:31,559 --> 00:22:35,100
to a program which has a vulnerability

467
00:22:35,100 --> 00:22:39,120
and we can trigger that vulnerability to

468
00:22:39,120 --> 00:22:41,760
have this buffer overflowed and we can

469
00:22:41,760 --> 00:22:45,960
see it's a very simplistic code pattern

470
00:22:45,960 --> 00:22:49,140
where we have an allocation of of a

471
00:22:49,140 --> 00:22:51,720
buffer with size 200 and we attempt to

472
00:22:51,720 --> 00:22:54,539
write to write buffer to that buffer

473
00:22:54,539 --> 00:22:57,140
their target size

474
00:22:57,140 --> 00:23:00,360
303 and it's not that the numbers are

475
00:23:00,360 --> 00:23:03,240
used there cool it's very likely

476
00:23:03,240 --> 00:23:06,120
it's very likely to be exploitable with

477
00:23:06,120 --> 00:23:07,500
the techniques we are going to discuss

478
00:23:07,500 --> 00:23:09,299
now

479
00:23:09,299 --> 00:23:11,820
next we have the Bruce Banner chunk and

480
00:23:11,820 --> 00:23:13,980
before explain explaining the Bruce

481
00:23:13,980 --> 00:23:16,200
Banner chunk it's noted that some

482
00:23:16,200 --> 00:23:18,179
references in the terminology are gonna

483
00:23:18,179 --> 00:23:21,059
use uh uh some references for From The

484
00:23:21,059 --> 00:23:22,140
Heart movie

485
00:23:22,140 --> 00:23:25,140
easier

486
00:23:25,559 --> 00:23:28,440
oh yeah so now we have the Bruce Banner

487
00:23:28,440 --> 00:23:31,740
chunk and this chunk is uh changa is

488
00:23:31,740 --> 00:23:35,340
close in the vicinity of the vulnerable

489
00:23:35,340 --> 00:23:37,559
chunk here we see its adjacent to that

490
00:23:37,559 --> 00:23:39,299
chunk and it's the Chunk we are gonna

491
00:23:39,299 --> 00:23:41,400
Target with the Overflow and more

492
00:23:41,400 --> 00:23:44,520
precisely we are going to Target the vs

493
00:23:44,520 --> 00:23:48,419
header of that chunk

494
00:23:48,419 --> 00:23:50,700
if the middle diagram now

495
00:23:50,700 --> 00:23:54,120
we have it's the state we are after the

496
00:23:54,120 --> 00:23:55,140
Overflow

497
00:23:55,140 --> 00:23:59,480
and we can see that uh

498
00:23:59,840 --> 00:24:03,000
after overflowing the vs header of the

499
00:24:03,000 --> 00:24:07,440
BB chunk and mutating its size we turn

500
00:24:07,440 --> 00:24:10,400
it we turn it into a mutant chunk

501
00:24:10,400 --> 00:24:14,039
and this chunk is the goal is to have

502
00:24:14,039 --> 00:24:16,559
this chunk being bigger than the actual

503
00:24:16,559 --> 00:24:19,320
size of them being chunk of them Bruce

504
00:24:19,320 --> 00:24:20,940
Banner chunk which we are going to call

505
00:24:20,940 --> 00:24:22,980
bbchang from now on

506
00:24:22,980 --> 00:24:25,740
uh

507
00:24:25,740 --> 00:24:27,840
yeah so

508
00:24:27,840 --> 00:24:31,940
now we have the muta Chunk in the future

509
00:24:31,940 --> 00:24:35,820
and we we can issue now a request to the

510
00:24:35,820 --> 00:24:37,919
allocator and have the allocator pick

511
00:24:37,919 --> 00:24:40,320
the chunk uh from that from the future

512
00:24:40,320 --> 00:24:41,940
entry

513
00:24:41,940 --> 00:24:44,520
and have it allocate the overlapping

514
00:24:44,520 --> 00:24:46,980
chunk and the goal of the overlapping

515
00:24:46,980 --> 00:24:50,400
chunk is to capture that size we managed

516
00:24:50,400 --> 00:24:53,039
to extend the mutation with

517
00:24:53,039 --> 00:24:54,679
and

518
00:24:54,679 --> 00:24:58,280
with that extra

519
00:24:58,380 --> 00:25:01,260
with that additional let's say size that

520
00:25:01,260 --> 00:25:03,120
the overlapping check is going to have

521
00:25:03,120 --> 00:25:06,059
compared with the actual size of the

522
00:25:06,059 --> 00:25:08,460
bimby chunk then we are going to be able

523
00:25:08,460 --> 00:25:10,740
to override part

524
00:25:10,740 --> 00:25:13,860
of the ovarian chunk and the operating

525
00:25:13,860 --> 00:25:16,200
chunk is going to be the target of the

526
00:25:16,200 --> 00:25:19,440
attack is going to be the Chunk we are

527
00:25:19,440 --> 00:25:20,520
going to use

528
00:25:20,520 --> 00:25:23,880
to override its headers and try to build

529
00:25:23,880 --> 00:25:26,340
our primitive for a simple pullover flow

530
00:25:26,340 --> 00:25:29,779
to something stronger

531
00:25:30,179 --> 00:25:31,679
so

532
00:25:31,679 --> 00:25:33,900
now we are gonna see some genetic

533
00:25:33,900 --> 00:25:36,600
Concepts that we are going to use to we

534
00:25:36,600 --> 00:25:39,140
are going to use for the attack

535
00:25:39,140 --> 00:25:42,840
and some reliability tools that are

536
00:25:42,840 --> 00:25:44,460
going to be useful to successfully

537
00:25:44,460 --> 00:25:46,980
execute the techniques and we are going

538
00:25:46,980 --> 00:25:49,380
to start with defense chunks and

539
00:25:49,380 --> 00:25:51,620
different chunks are chunks we are gonna

540
00:25:51,620 --> 00:25:55,740
inject into the free Chantry

541
00:25:55,740 --> 00:25:57,960
in order to maximize the probability

542
00:25:57,960 --> 00:26:00,480
that we are going to be the first

543
00:26:00,480 --> 00:26:02,659
to

544
00:26:02,659 --> 00:26:05,640
have access to the mutant Chunk in order

545
00:26:05,640 --> 00:26:08,700
to allocate the overlapping chunk so we

546
00:26:08,700 --> 00:26:10,799
don't want some random request after

547
00:26:10,799 --> 00:26:13,620
placing the mutant chunk into the into

548
00:26:13,620 --> 00:26:16,260
the friction tree we don't want some

549
00:26:16,260 --> 00:26:18,200
random request

550
00:26:18,200 --> 00:26:21,480
using that Newton chunk to serve their

551
00:26:21,480 --> 00:26:24,659
own chunks

552
00:26:25,980 --> 00:26:29,520
so let's see let's see the diagram here

553
00:26:29,520 --> 00:26:31,919
so on the leftmost diagram

554
00:26:31,919 --> 00:26:34,740
we see we have a random request over 4

555
00:26:34,740 --> 00:26:38,580
000 bytes and the allocator is gonna use

556
00:26:38,580 --> 00:26:40,500
the mutant chunk because it's the most

557
00:26:40,500 --> 00:26:43,320
it's the most suitable chunk to serve

558
00:26:43,320 --> 00:26:45,918
that request

559
00:26:47,340 --> 00:26:50,940
in the middle diagram we we see the

560
00:26:50,940 --> 00:26:54,360
state of the free Chantry after ejecting

561
00:26:54,360 --> 00:26:57,480
the fence chunk and here again

562
00:26:57,480 --> 00:26:59,700
if we receive the same request of 4 000

563
00:26:59,700 --> 00:27:01,679
bytes then

564
00:27:01,679 --> 00:27:04,260
the allocator is going to pick the fence

565
00:27:04,260 --> 00:27:06,480
chunk and do not the mutant chain so we

566
00:27:06,480 --> 00:27:07,740
managed to

567
00:27:07,740 --> 00:27:10,380
to keep the let's say in a sense the the

568
00:27:10,380 --> 00:27:13,380
mutant chunk safe and in the rightmost

569
00:27:13,380 --> 00:27:16,440
diagram we see

570
00:27:16,440 --> 00:27:18,000
where

571
00:27:18,000 --> 00:27:20,880
we see that by requesting a size a chunk

572
00:27:20,880 --> 00:27:23,880
with size 7000 bytes we can actually

573
00:27:23,880 --> 00:27:28,620
make the allocator uh give us the the

574
00:27:28,620 --> 00:27:30,659
mutant chunk

575
00:27:30,659 --> 00:27:33,600
and in order to success for this uh

576
00:27:33,600 --> 00:27:36,299
let's say tool to success to increase

577
00:27:36,299 --> 00:27:38,039
let's say the success rate of this

578
00:27:38,039 --> 00:27:39,480
technique

579
00:27:39,480 --> 00:27:42,120
we have to pick the appropriate fence

580
00:27:42,120 --> 00:27:44,940
chunk size so in a sense we have to kind

581
00:27:44,940 --> 00:27:48,000
of know which is the maximum expected

582
00:27:48,000 --> 00:27:49,860
request size for a particular time

583
00:27:49,860 --> 00:27:52,559
period so now let's say if we know that

584
00:27:52,559 --> 00:27:55,260
size is for 4000 bytes we need to pick a

585
00:27:55,260 --> 00:27:57,900
fence chunk that's slightly bigger than

586
00:27:57,900 --> 00:28:00,059
that or at least bigger than that and

587
00:28:00,059 --> 00:28:01,919
here we see that we have picked a fence

588
00:28:01,919 --> 00:28:05,760
chunk of size 6K bytes and that should

589
00:28:05,760 --> 00:28:08,039
allow us to have access to the mutant

590
00:28:08,039 --> 00:28:11,220
chunk On Demand by recommending by

591
00:28:11,220 --> 00:28:14,820
requesting a chunk size with size bigger

592
00:28:14,820 --> 00:28:18,539
than the the defense chunk

593
00:28:18,539 --> 00:28:20,880
and how can we

594
00:28:20,880 --> 00:28:23,820
find the appropriate defense fan chunks

595
00:28:23,820 --> 00:28:26,580
we can see here the simple and deep

596
00:28:26,580 --> 00:28:30,000
trade script which can be used to let's

597
00:28:30,000 --> 00:28:34,260
say sample the sizes that go to the vs

598
00:28:34,260 --> 00:28:37,620
allocator and from there we can find the

599
00:28:37,620 --> 00:28:40,919
appropriate sizes

600
00:28:40,919 --> 00:28:43,020
next we have the Trap chunks and the

601
00:28:43,020 --> 00:28:44,900
trap chunks are

602
00:28:44,900 --> 00:28:48,600
relayed mostly to the to the face to the

603
00:28:48,600 --> 00:28:50,640
face after the allocation of the

604
00:28:50,640 --> 00:28:53,159
overlapping chunk so after injecting the

605
00:28:53,159 --> 00:28:55,320
fence chunk and after allocating the

606
00:28:55,320 --> 00:28:57,600
overlapping chunk

607
00:28:57,600 --> 00:28:58,740
um

608
00:28:58,740 --> 00:29:01,919
and in this phase and after after

609
00:29:01,919 --> 00:29:04,679
allocating the overlapping chunk

610
00:29:04,679 --> 00:29:06,659
the allocator is going to split as if

611
00:29:06,659 --> 00:29:09,500
you recall during the allocation process

612
00:29:09,500 --> 00:29:12,059
the allocator is gonna split the

613
00:29:12,059 --> 00:29:13,620
identified chunks so the alcater is

614
00:29:13,620 --> 00:29:15,600
going to get the mutant chunk is going

615
00:29:15,600 --> 00:29:18,059
to use it to serve the overlapping chunk

616
00:29:18,059 --> 00:29:20,520
and it's going to split apart if it's

617
00:29:20,520 --> 00:29:24,379
bigger than the size of the

618
00:29:24,980 --> 00:29:27,539
if it's bigger than the overlapping

619
00:29:27,539 --> 00:29:30,000
chunk and insert that reminder chunk to

620
00:29:30,000 --> 00:29:32,700
the free chunk tree so we want using

621
00:29:32,700 --> 00:29:34,740
those trap chunks to minimize the

622
00:29:34,740 --> 00:29:36,480
probability that they remind their

623
00:29:36,480 --> 00:29:39,620
mutant chunk is gonna

624
00:29:39,620 --> 00:29:42,899
get used to serve some requests because

625
00:29:42,899 --> 00:29:45,720
if it gets if it gets used to server

626
00:29:45,720 --> 00:29:48,840
requests then it means that it might we

627
00:29:48,840 --> 00:29:51,480
might corrupt some memory that doesn't

628
00:29:51,480 --> 00:29:53,700
belong to us

629
00:29:53,700 --> 00:29:57,419
uh and how we pick sizes for Club chunks

630
00:29:57,419 --> 00:29:59,820
it's simpler than the fence chunks we

631
00:29:59,820 --> 00:30:01,919
just inject the allocator with different

632
00:30:01,919 --> 00:30:06,779
sizes and this should have this approach

633
00:30:06,779 --> 00:30:08,039
work

634
00:30:08,039 --> 00:30:12,539
and now our grassy it's important to

635
00:30:12,539 --> 00:30:16,580
to describe the states the

636
00:30:16,580 --> 00:30:20,460
the Bruce Banner chunks are gonna have

637
00:30:20,460 --> 00:30:22,260
before the Overflow

638
00:30:22,260 --> 00:30:24,779
and before the Overflow the Bruce Banner

639
00:30:24,779 --> 00:30:26,640
chunks can be in two different states

640
00:30:26,640 --> 00:30:29,159
there can be other fruit they can better

641
00:30:29,159 --> 00:30:32,460
be used or fruit and freed within the

642
00:30:32,460 --> 00:30:34,140
the fridge entry

643
00:30:34,140 --> 00:30:36,120
and in this talk we are going to focus

644
00:30:36,120 --> 00:30:38,700
on the we're gonna describe our example

645
00:30:38,700 --> 00:30:41,240
are going to be based on the

646
00:30:41,240 --> 00:30:44,340
allocated when the Bruce Banner channel

647
00:30:44,340 --> 00:30:46,640
is going to be allocated

648
00:30:46,640 --> 00:30:49,380
but the other two attacks are also

649
00:30:49,380 --> 00:30:53,159
viable options so in the allocated chunk

650
00:30:53,159 --> 00:30:54,980
attack

651
00:30:54,980 --> 00:30:59,460
where it's where is we assume that the

652
00:30:59,460 --> 00:31:02,279
bimby chunk is going to be allocated

653
00:31:02,279 --> 00:31:05,760
so we trigger the Overflow

654
00:31:05,760 --> 00:31:09,120
and then with we deallocate then bimby

655
00:31:09,120 --> 00:31:11,820
chunk so after delegating the BB chunk

656
00:31:11,820 --> 00:31:14,520
the overflowed BB chunk size is going to

657
00:31:14,520 --> 00:31:17,460
get used to be added to the free Chantry

658
00:31:17,460 --> 00:31:19,679
and this should cause the transformation

659
00:31:19,679 --> 00:31:22,740
of the BB chunk to what we call here

660
00:31:22,740 --> 00:31:24,980
mutant chunk and then we can use

661
00:31:24,980 --> 00:31:28,260
appropriate request size to allocate

662
00:31:28,260 --> 00:31:30,899
the overlapping chunk

663
00:31:30,899 --> 00:31:33,600
and that should conclude a it's fairly

664
00:31:33,600 --> 00:31:36,299
simple this methodology the other two

665
00:31:36,299 --> 00:31:40,620
attacks assume that the BB chunk are is

666
00:31:40,620 --> 00:31:42,720
already freed and we are essentially

667
00:31:42,720 --> 00:31:45,740
corrupting uh the red block 3 nodes

668
00:31:45,740 --> 00:31:48,240
directly but we are not going to focus

669
00:31:48,240 --> 00:31:50,760
on those attacks here

670
00:31:50,760 --> 00:31:54,179
but it's noted that if uh in the blog

671
00:31:54,179 --> 00:31:55,740
post in the associate blog post which is

672
00:31:55,740 --> 00:31:56,820
going to provided at the end of the

673
00:31:56,820 --> 00:32:00,720
presentation we go into more details in

674
00:32:00,720 --> 00:32:03,480
all three of those attacks

675
00:32:03,480 --> 00:32:07,740
so now just a quick summary our goal is

676
00:32:07,740 --> 00:32:09,840
to override

677
00:32:09,840 --> 00:32:13,380
the size field of the bimby chunk and

678
00:32:13,380 --> 00:32:15,240
make it look like it's bigger than it

679
00:32:15,240 --> 00:32:16,980
actually is

680
00:32:16,980 --> 00:32:21,480
and allocate based on that chunk the on

681
00:32:21,480 --> 00:32:23,220
that let's say corrupted chunk bigger

682
00:32:23,220 --> 00:32:24,720
chunk I look at the overlapping chunk

683
00:32:24,720 --> 00:32:28,580
and have the operating chunk

684
00:32:28,580 --> 00:32:31,620
manipulated with our own data but the

685
00:32:31,620 --> 00:32:35,840
challenge here is that the size field is

686
00:32:35,840 --> 00:32:38,640
randomized because of the encoding we

687
00:32:38,640 --> 00:32:40,799
discussed at the beginning so what that

688
00:32:40,799 --> 00:32:43,260
means is that regardless of the

689
00:32:43,260 --> 00:32:46,380
actual size of a chunk it's encoded

690
00:32:46,380 --> 00:32:50,460
value is going to be completely random

691
00:32:50,460 --> 00:32:52,919
and the same stands true

692
00:32:52,919 --> 00:32:55,860
for if we take the other way around so

693
00:32:55,860 --> 00:32:58,320
if we override with a specific let's say

694
00:32:58,320 --> 00:33:01,140
size the encoded size then the coded

695
00:33:01,140 --> 00:33:04,020
size is again going to be random a

696
00:33:04,020 --> 00:33:07,440
random value and it's two aspects of the

697
00:33:07,440 --> 00:33:10,080
two sides of the same coin and what that

698
00:33:10,080 --> 00:33:14,279
means for for our scenario is that after

699
00:33:14,279 --> 00:33:16,799
corrupting the size of the BB Chunk we

700
00:33:16,799 --> 00:33:18,600
won't be able to know

701
00:33:18,600 --> 00:33:21,600
the size of the mutant chunk and that's

702
00:33:21,600 --> 00:33:23,159
problematic because

703
00:33:23,159 --> 00:33:26,360
if there is a big chunk in memory

704
00:33:26,360 --> 00:33:28,799
corrupted big chunk memory the allocator

705
00:33:28,799 --> 00:33:31,260
might use a chunk to serve a random

706
00:33:31,260 --> 00:33:34,140
requests and we might corrupt memory

707
00:33:34,140 --> 00:33:37,140
belonging to other processes and that's

708
00:33:37,140 --> 00:33:40,880
that's not we are gonna

709
00:33:40,880 --> 00:33:43,380
corrupt the system

710
00:33:43,380 --> 00:33:46,019
so now let's see some how we can

711
00:33:46,019 --> 00:33:48,299
approach this problem and we're gonna

712
00:33:48,299 --> 00:33:50,279
start with the LSB technique what we

713
00:33:50,279 --> 00:33:53,100
call the LSB technique and here we are

714
00:33:53,100 --> 00:33:54,899
going to override the least significant

715
00:33:54,899 --> 00:33:59,220
byte of the BB chunk and manipulate the

716
00:33:59,220 --> 00:34:03,059
Heap in such way so as

717
00:34:03,059 --> 00:34:05,340
after the Overflow and after creating

718
00:34:05,340 --> 00:34:07,740
the mutant chunk the mutant chunk is

719
00:34:07,740 --> 00:34:10,379
going to be limited within a control

720
00:34:10,379 --> 00:34:13,320
area so even though we are not going to

721
00:34:13,320 --> 00:34:16,020
be able to know its actual size we are

722
00:34:16,020 --> 00:34:19,739
gonna know that uh it's gonna fall

723
00:34:19,739 --> 00:34:22,980
within an area that's under our control

724
00:34:22,980 --> 00:34:25,619
and how we can achieve that

725
00:34:25,619 --> 00:34:27,839
uh

726
00:34:27,839 --> 00:34:30,960
a key element to to run this technique

727
00:34:30,960 --> 00:34:33,780
is to pick the appropriate bimby chunk

728
00:34:33,780 --> 00:34:34,739
size

729
00:34:34,739 --> 00:34:37,260
and two requirements we have for the BB

730
00:34:37,260 --> 00:34:40,020
chunk is first it has to be bigger than

731
00:34:40,020 --> 00:34:45,119
a page and second it has to its end has

732
00:34:45,119 --> 00:34:47,399
to be as close as possible to the

733
00:34:47,399 --> 00:34:50,280
beginning of its final page which we can

734
00:34:50,280 --> 00:34:54,599
see in the green circle and here in this

735
00:34:54,599 --> 00:34:59,040
case it's a page of set 0x20 from the

736
00:34:59,040 --> 00:35:02,960
beginning of its last page

737
00:35:02,960 --> 00:35:06,720
and why are those requirements important

738
00:35:06,720 --> 00:35:09,960
we have to keep in mind two two things

739
00:35:09,960 --> 00:35:11,640
first

740
00:35:11,640 --> 00:35:13,920
chunks that are bigger than a page which

741
00:35:13,920 --> 00:35:16,200
is our first requirement those chunks

742
00:35:16,200 --> 00:35:18,960
start at page of set f is zero remember

743
00:35:18,960 --> 00:35:21,540
the page alignment optimization

744
00:35:21,540 --> 00:35:25,079
and second after the Overflow the least

745
00:35:25,079 --> 00:35:27,780
significant byte of the

746
00:35:27,780 --> 00:35:31,200
uh of the BB chunk is going to become

747
00:35:31,200 --> 00:35:32,660
randomized

748
00:35:32,660 --> 00:35:37,079
and the resulting Newton chunk can have

749
00:35:37,079 --> 00:35:41,220
the sizes shown in the blue circle

750
00:35:41,220 --> 00:35:44,339
and what what if you if we combine those

751
00:35:44,339 --> 00:35:45,540
two together

752
00:35:45,540 --> 00:35:49,440
uh we can see that the the mutant chunk

753
00:35:49,440 --> 00:35:51,720
even though we don't know its size it's

754
00:35:51,720 --> 00:35:54,359
gonna fall somewhere between the page

755
00:35:54,359 --> 00:35:57,240
boundary X and Page boundary X plus one

756
00:35:57,240 --> 00:36:00,799
which is controlled by us

757
00:36:02,700 --> 00:36:04,980
so in the middle diagram we see the

758
00:36:04,980 --> 00:36:07,800
state we have after the Overflow so we

759
00:36:07,800 --> 00:36:09,960
have converted the BB chain to a mutant

760
00:36:09,960 --> 00:36:12,300
chunk and we can see that the least

761
00:36:12,300 --> 00:36:14,180
significant byte

762
00:36:14,180 --> 00:36:17,760
randomized into the value 5D

763
00:36:17,760 --> 00:36:21,060
it's not that the original value was of

764
00:36:21,060 --> 00:36:23,099
the BB chain was four

765
00:36:23,099 --> 00:36:25,800
and what that means is that we have

766
00:36:25,800 --> 00:36:28,200
managed to successfully extend the the

767
00:36:28,200 --> 00:36:32,700
mutant chunk beyond the limits of the

768
00:36:32,700 --> 00:36:35,760
original BB chunk size

769
00:36:35,760 --> 00:36:37,680
and by the way the numbers we have used

770
00:36:37,680 --> 00:36:41,040
here are actual numbers from a system it

771
00:36:41,040 --> 00:36:43,380
wasn't like it was a it's it's not like

772
00:36:43,380 --> 00:36:46,220
my own numbers

773
00:36:46,220 --> 00:36:50,599
uh use just to illustrate this example

774
00:36:50,599 --> 00:36:54,800
and at the final diagram we see

775
00:36:54,800 --> 00:36:58,380
the allocation of the overlapping chunk

776
00:36:58,380 --> 00:37:00,960
so as we said before the mutant Chang is

777
00:37:00,960 --> 00:37:03,720
going to be now in the in the future and

778
00:37:03,720 --> 00:37:06,000
we just request a size big enough to

779
00:37:06,000 --> 00:37:08,280
have the overlapping chanca located

780
00:37:08,280 --> 00:37:09,920
and

781
00:37:09,920 --> 00:37:14,220
override part of the overwritten chunk

782
00:37:14,220 --> 00:37:16,980
so that's a high level that's a high

783
00:37:16,980 --> 00:37:20,180
level overview of the attack

784
00:37:20,180 --> 00:37:23,700
and okay and in theory it looks like it

785
00:37:23,700 --> 00:37:27,540
should work fine but does it require uh

786
00:37:27,540 --> 00:37:31,200
stars to be aligned or page aligned

787
00:37:31,200 --> 00:37:34,619
and it's not exactly like like that and

788
00:37:34,619 --> 00:37:36,599
we will see here for example a simple

789
00:37:36,599 --> 00:37:39,480
approach that can be used for creating

790
00:37:39,480 --> 00:37:41,940
those all those satisfying all those

791
00:37:41,940 --> 00:37:44,220
requirements at least for the kernel

792
00:37:44,220 --> 00:37:46,980
mode implementation of the segment Heap

793
00:37:46,980 --> 00:37:49,740
so we start with the pimpy chanka

794
00:37:49,740 --> 00:37:51,060
location

795
00:37:51,060 --> 00:37:54,000
and it's not that even though we use

796
00:37:54,000 --> 00:37:55,520
specific numbers

797
00:37:55,520 --> 00:37:59,460
in this uh methodology methodology here

798
00:37:59,460 --> 00:38:01,440
the

799
00:38:01,440 --> 00:38:03,420
the approach we use here can be

800
00:38:03,420 --> 00:38:09,480
generalized to create and uh and use it

801
00:38:09,480 --> 00:38:12,420
for different sizes so as we said we

802
00:38:12,420 --> 00:38:14,160
start with the allocation of the Bibi

803
00:38:14,160 --> 00:38:16,680
chunk of the BB chunks and we create a

804
00:38:16,680 --> 00:38:19,079
bunch of let's say co40 chunks which was

805
00:38:19,079 --> 00:38:21,480
the size used in the previous example

806
00:38:21,480 --> 00:38:25,700
and it's not that that uh

807
00:38:26,300 --> 00:38:29,400
when the friction please iterated to

808
00:38:29,400 --> 00:38:31,680
find the suitable chunk for a particular

809
00:38:31,680 --> 00:38:35,040
request if it can't find a chunk within

810
00:38:35,040 --> 00:38:37,680
the friction three that's uh big enough

811
00:38:37,680 --> 00:38:39,960
to satisfy the request then it's gonna

812
00:38:39,960 --> 00:38:43,859
locate a big chunk of memory and it's

813
00:38:43,859 --> 00:38:47,280
gonna use that chunk to

814
00:38:47,280 --> 00:38:49,800
serve the request

815
00:38:49,800 --> 00:38:52,260
and the reminder of that chunk is going

816
00:38:52,260 --> 00:38:53,820
to get added back to the friction tree

817
00:38:53,820 --> 00:38:57,119
so if we keep that this in mind and and

818
00:38:57,119 --> 00:39:00,060
keep that keep in mind that

819
00:39:00,060 --> 00:39:02,820
we have the page optimization in place

820
00:39:02,820 --> 00:39:05,460
and that the commute optimization then

821
00:39:05,460 --> 00:39:07,320
that's gonna result into some good news

822
00:39:07,320 --> 00:39:08,460
for us

823
00:39:08,460 --> 00:39:12,720
and those good news is that we get uh

824
00:39:12,720 --> 00:39:16,260
left with the diagram shown here at uh

825
00:39:16,260 --> 00:39:17,940
on the top

826
00:39:17,940 --> 00:39:19,980
and we can see that we have the BB chunk

827
00:39:19,980 --> 00:39:22,440
allocated to us which was the request

828
00:39:22,440 --> 00:39:25,800
size and the Arches and chunks of the BB

829
00:39:25,800 --> 00:39:30,839
chunk are going to be freed and be added

830
00:39:30,839 --> 00:39:33,900
to the free chunk tree and if we compare

831
00:39:33,900 --> 00:39:36,119
the top diagram with the bottom diagram

832
00:39:36,119 --> 00:39:39,300
we can see that we are very close to the

833
00:39:39,300 --> 00:39:42,260
diagram required to run

834
00:39:42,260 --> 00:39:45,599
the LSB attack

835
00:39:45,599 --> 00:39:49,140
and so what's left now is to allocate

836
00:39:49,140 --> 00:39:52,980
and capture those arches and free chunks

837
00:39:52,980 --> 00:39:57,200
and we can complete the attack

838
00:39:57,320 --> 00:40:00,720
so now let's see how we can recover the

839
00:40:00,720 --> 00:40:03,900
operating chunk and we can see that

840
00:40:03,900 --> 00:40:07,260
it's the free chunk size is uh with size

841
00:40:07,260 --> 00:40:08,940
fc0

842
00:40:08,940 --> 00:40:11,160
so to capture that Chunk we have to take

843
00:40:11,160 --> 00:40:14,940
into account the vs allocator headers

844
00:40:14,940 --> 00:40:16,800
then generic hundred headers and the

845
00:40:16,800 --> 00:40:19,500
padding and if we request a child with

846
00:40:19,500 --> 00:40:22,140
size f90 we should be able to capture

847
00:40:22,140 --> 00:40:23,520
this chunk

848
00:40:23,520 --> 00:40:28,160
next we have the vulnerable chunk uh

849
00:40:28,160 --> 00:40:31,680
recovery and here it's a bit more

850
00:40:31,680 --> 00:40:33,599
challenging because

851
00:40:33,599 --> 00:40:36,119
the vulnerable chunk size with which is

852
00:40:36,119 --> 00:40:38,579
the the adjacent chunk of the BB chunk

853
00:40:38,579 --> 00:40:41,400
is gonna have a specific size and it's

854
00:40:41,400 --> 00:40:44,280
more it's it's more likely to it's very

855
00:40:44,280 --> 00:40:47,460
likely to be smaller than the size we

856
00:40:47,460 --> 00:40:51,540
have through our hip manipulation which

857
00:40:51,540 --> 00:40:56,460
is fb0 in this case so

858
00:40:56,460 --> 00:40:59,820
how can we create an adjacent chunk to

859
00:40:59,820 --> 00:41:01,440
then bimby chunk that's going to be the

860
00:41:01,440 --> 00:41:04,020
target's vulnerable chunk size

861
00:41:04,020 --> 00:41:06,540
to do that we can see that that the

862
00:41:06,540 --> 00:41:08,520
title of this step hints to the solution

863
00:41:08,520 --> 00:41:10,920
and we are we're gonna carve the

864
00:41:10,920 --> 00:41:13,380
vulnerable chunk of that potentially

865
00:41:13,380 --> 00:41:16,320
bigger uh

866
00:41:16,320 --> 00:41:22,140
uh super chunk adjacent to the uh

867
00:41:22,140 --> 00:41:24,500
bimbi Chang

868
00:41:24,500 --> 00:41:28,320
so how we can do this carving

869
00:41:28,320 --> 00:41:29,820
so

870
00:41:29,820 --> 00:41:32,400
we have to remember that the vs

871
00:41:32,400 --> 00:41:34,880
allocator

872
00:41:35,760 --> 00:41:38,940
is the future using a best feed strategy

873
00:41:38,940 --> 00:41:41,820
and it all showed us the splitting

874
00:41:41,820 --> 00:41:45,540
process where it the reminder chunk of

875
00:41:45,540 --> 00:41:47,339
the identified chunk is added back to

876
00:41:47,339 --> 00:41:49,260
the free chunk tree so if we keep those

877
00:41:49,260 --> 00:41:52,920
two in mind we can create what we call

878
00:41:52,920 --> 00:41:56,880
here a different splitting rounds and

879
00:41:56,880 --> 00:41:59,339
then goal in each splitting round is to

880
00:41:59,339 --> 00:42:01,980
create a specific request size that's

881
00:42:01,980 --> 00:42:04,920
going to result in a particular reminder

882
00:42:04,920 --> 00:42:06,300
chunk size

883
00:42:06,300 --> 00:42:08,940
and at the end of our splitting rounds

884
00:42:08,940 --> 00:42:12,320
our goal is to get as close as possible

885
00:42:12,320 --> 00:42:15,900
to the Target vulnerable chunk size and

886
00:42:15,900 --> 00:42:18,060
by the end of the final round we should

887
00:42:18,060 --> 00:42:20,760
have the target vulnerable trans size

888
00:42:20,760 --> 00:42:23,520
and here we picked one one as as

889
00:42:23,520 --> 00:42:25,099
vulnerable chunk size

890
00:42:25,099 --> 00:42:27,839
390 but it's noted that this approach

891
00:42:27,839 --> 00:42:29,540
can be used

892
00:42:29,540 --> 00:42:34,380
to carve most a lot of different uh

893
00:42:34,380 --> 00:42:37,260
vulnerable chunk sizes

894
00:42:37,260 --> 00:42:40,380
so after this step we are left with a

895
00:42:40,380 --> 00:42:43,680
bunch of chunks with size 390 to the

896
00:42:43,680 --> 00:42:44,880
three chunk tree

897
00:42:44,880 --> 00:42:48,480
and we can just to clean up some noise

898
00:42:48,480 --> 00:42:51,320
create some uh

899
00:42:51,320 --> 00:42:55,020
temporary quest with size of 390 and

900
00:42:55,020 --> 00:42:57,599
then we can trigger the allocation of

901
00:42:57,599 --> 00:42:59,220
the vulnerable chunk

902
00:42:59,220 --> 00:43:00,960
after triggering the allocation of the

903
00:43:00,960 --> 00:43:03,240
one in our Chunk we go to step 5 which

904
00:43:03,240 --> 00:43:06,000
is the injection of the free Chantry

905
00:43:06,000 --> 00:43:07,740
with fence chunks

906
00:43:07,740 --> 00:43:10,880
and then we configure the Overflow

907
00:43:10,880 --> 00:43:15,119
and and free the bimby chunk so at this

908
00:43:15,119 --> 00:43:17,760
point we should get we should have the

909
00:43:17,760 --> 00:43:19,619
mutant chunk into the free chunk tree

910
00:43:19,619 --> 00:43:22,319
and now to actually allocate the

911
00:43:22,319 --> 00:43:27,060
overlapping Chunk we can request the

912
00:43:27,060 --> 00:43:30,480
a chunk size slightly bigger than the

913
00:43:30,480 --> 00:43:33,000
fence chunk and we should be able to

914
00:43:33,000 --> 00:43:36,359
capture the over overlapping chunk and

915
00:43:36,359 --> 00:43:39,900
this concludes this technique

916
00:43:39,900 --> 00:43:42,839
uh next we have the MSB technique which

917
00:43:42,839 --> 00:43:45,839
is uh in a sense the brother of the LSB

918
00:43:45,839 --> 00:43:46,980
technique

919
00:43:46,980 --> 00:43:50,040
and as we said before the LSB techniques

920
00:43:50,040 --> 00:43:52,260
the LSB technique targets the least

921
00:43:52,260 --> 00:43:55,980
significant bite of the BB chunk and the

922
00:43:55,980 --> 00:43:58,680
goal is to cage the mutant chunk and

923
00:43:58,680 --> 00:44:01,440
have it fall into a control area

924
00:44:01,440 --> 00:44:04,440
here we are going to take the opposite

925
00:44:04,440 --> 00:44:06,780
direction we are going to overflow both

926
00:44:06,780 --> 00:44:09,900
bytes of the BB chunk and we are going

927
00:44:09,900 --> 00:44:11,880
to manipulate the hip layout and the hip

928
00:44:11,880 --> 00:44:15,980
state in order to make a

929
00:44:15,980 --> 00:44:18,359
that chunk

930
00:44:18,359 --> 00:44:20,640
inaccessible or at least to minimize the

931
00:44:20,640 --> 00:44:22,200
probability that that chain is going to

932
00:44:22,200 --> 00:44:24,240
use for random requests and at the same

933
00:44:24,240 --> 00:44:25,980
time maximize the probability that is

934
00:44:25,980 --> 00:44:28,920
going to get used by US in order to be

935
00:44:28,920 --> 00:44:31,319
able to allocate the overlapping chunk

936
00:44:31,319 --> 00:44:33,900
so in a sense we are gonna release the

937
00:44:33,900 --> 00:44:36,180
mutant chunk into a remote area

938
00:44:36,180 --> 00:44:38,099
and we are going to make it difficult

939
00:44:38,099 --> 00:44:41,520
for people to come in contact with our

940
00:44:41,520 --> 00:44:44,160
mutant chunk and we can see Hulk here in

941
00:44:44,160 --> 00:44:45,560
an island

942
00:44:45,560 --> 00:44:48,240
which supposedly may make it more

943
00:44:48,240 --> 00:44:49,920
difficult for people to come in contact

944
00:44:49,920 --> 00:44:51,780
with him

945
00:44:51,780 --> 00:44:54,540
and the challenge here as we said we are

946
00:44:54,540 --> 00:44:56,839
going to end up with a huge mutant chunk

947
00:44:56,839 --> 00:45:01,380
and given our goals which are to

948
00:45:01,380 --> 00:45:03,180
maximize the probability that we're

949
00:45:03,180 --> 00:45:06,720
going to be the first to to use that

950
00:45:06,720 --> 00:45:10,020
much from the future and minimize the

951
00:45:10,020 --> 00:45:11,579
probability that they remind their

952
00:45:11,579 --> 00:45:13,099
mutant chunk

953
00:45:13,099 --> 00:45:16,680
is going to remain unused and get buried

954
00:45:16,680 --> 00:45:19,380
in the future tree uh

955
00:45:19,380 --> 00:45:22,560
if we recall from our reliability tools

956
00:45:22,560 --> 00:45:25,920
we can use the French chunks and the top

957
00:45:25,920 --> 00:45:28,319
chunks and we will be able to make this

958
00:45:28,319 --> 00:45:32,700
approach work in practice and

959
00:45:32,819 --> 00:45:35,359
after finishing the attack is important

960
00:45:35,359 --> 00:45:40,099
to clean up the hip since

961
00:45:40,099 --> 00:45:41,660
our

962
00:45:41,660 --> 00:45:44,339
reliability tools have

963
00:45:44,339 --> 00:45:47,940
some sort of expiration time

964
00:45:47,940 --> 00:45:50,460
given enough request they are eventually

965
00:45:50,460 --> 00:45:53,660
gonna fail

966
00:45:53,880 --> 00:45:56,700
here we see a quick diagram of the MSB

967
00:45:56,700 --> 00:45:59,339
approach and the middle diagram we see

968
00:45:59,339 --> 00:46:01,680
that we end up with a huge mutant chunk

969
00:46:01,680 --> 00:46:05,460
that could potentially cross the memory

970
00:46:05,460 --> 00:46:08,040
that belongs to different processes and

971
00:46:08,040 --> 00:46:11,640
if that memory get used to allocate some

972
00:46:11,640 --> 00:46:14,760
chunks is going to corrupt that memory

973
00:46:14,760 --> 00:46:18,020
that doesn't belong to us

974
00:46:18,359 --> 00:46:19,980
so that's it

975
00:46:19,980 --> 00:46:22,740
now we are going to see some tools

976
00:46:22,740 --> 00:46:25,800
so along with this talk we have released

977
00:46:25,800 --> 00:46:28,079
a wind debugger JavaScript extension

978
00:46:28,079 --> 00:46:30,920
that aims to export different

979
00:46:30,920 --> 00:46:35,400
internal structures used by the vs the

980
00:46:35,400 --> 00:46:38,040
the second hip allocators

981
00:46:38,040 --> 00:46:40,619
for example we can see that we can

982
00:46:40,619 --> 00:46:42,960
export all the chunks that are part of

983
00:46:42,960 --> 00:46:45,780
the free chunk tree which fall within a

984
00:46:45,780 --> 00:46:47,660
specific size range

985
00:46:47,660 --> 00:46:49,440
finally

986
00:46:49,440 --> 00:46:52,760
the pull command is not behaving very

987
00:46:52,760 --> 00:46:56,339
nicely within the kernel mode segment

988
00:46:56,339 --> 00:47:00,119
hip so for a good alternative check out

989
00:47:00,119 --> 00:47:03,500
the extension created by yarten shafir

990
00:47:03,500 --> 00:47:06,480
called pool View

991
00:47:06,480 --> 00:47:08,819
here are some references made throughout

992
00:47:08,819 --> 00:47:10,500
the presentation and we can see the blog

993
00:47:10,500 --> 00:47:14,300
post and also the

994
00:47:14,300 --> 00:47:16,800
uh they're going to be debugger

995
00:47:16,800 --> 00:47:18,180
extension

996
00:47:18,180 --> 00:47:21,960
and that's all thanks for listening and

997
00:47:21,960 --> 00:47:24,859
we can take any questions

998
00:47:24,859 --> 00:47:28,160
if there are

999
00:47:31,440 --> 00:47:33,440
um

1000
00:47:35,280 --> 00:47:38,960
thank you for your presentation

