1
00:00:03,140 --> 00:00:07,290
[Music]

2
00:00:15,920 --> 00:00:19,380
yeah nice

3
00:00:19,380 --> 00:00:22,859
thank you welcome to my talk about a

4
00:00:22,859 --> 00:00:26,039
Race Against Time how to exploit race

5
00:00:26,039 --> 00:00:29,480
condition in web applications

6
00:00:29,699 --> 00:00:31,679
before I start with my talk I want to

7
00:00:31,679 --> 00:00:34,739
say a few few words about me my name is

8
00:00:34,739 --> 00:00:37,920
yavan I work as a senior application

9
00:00:37,920 --> 00:00:40,620
security specialist at Sage

10
00:00:40,620 --> 00:00:43,440
and in my day-to-day job I support

11
00:00:43,440 --> 00:00:46,140
software engineering teams securing the

12
00:00:46,140 --> 00:00:48,780
software development life cycle

13
00:00:48,780 --> 00:00:51,920
integrating tools shifting security left

14
00:00:51,920 --> 00:00:56,300
and giving recommendations for

15
00:00:56,300 --> 00:00:58,500
vulnerabilities that we receive from

16
00:00:58,500 --> 00:01:00,300
different sources like bug Bounty pen

17
00:01:00,300 --> 00:01:03,120
tests or from our tools I have a

18
00:01:03,120 --> 00:01:05,459
background in penetration testing mostly

19
00:01:05,459 --> 00:01:08,100
web applications and on the side I'm

20
00:01:08,100 --> 00:01:10,680
lecturing secure Kodi secure coding at

21
00:01:10,680 --> 00:01:13,740
the dhbw Velocity in Germany I have a

22
00:01:13,740 --> 00:01:16,020
master in it Securities management and

23
00:01:16,020 --> 00:01:18,659
most of the research I'm presenting you

24
00:01:18,659 --> 00:01:21,299
today is was part of my Master's

25
00:01:21,299 --> 00:01:23,040
dissertation

26
00:01:23,040 --> 00:01:27,240
I love open source projects so I'm

27
00:01:27,240 --> 00:01:29,460
a big contributor to different type of

28
00:01:29,460 --> 00:01:32,580
projects for example over step but I

29
00:01:32,580 --> 00:01:34,220
also have my own

30
00:01:34,220 --> 00:01:36,360
projects on GitHub like vulnerability

31
00:01:36,360 --> 00:01:38,700
vulnerability scanners and of course you

32
00:01:38,700 --> 00:01:41,720
can find me on Twitter

33
00:01:42,000 --> 00:01:47,159
so the agenda today uh first Theory what

34
00:01:47,159 --> 00:01:50,460
are race conditions we will look at some

35
00:01:50,460 --> 00:01:52,740
examples from The Real World

36
00:01:52,740 --> 00:01:55,500
then I will show you a vulnerable PHP

37
00:01:55,500 --> 00:01:58,380
code snippet we will see if you are able

38
00:01:58,380 --> 00:02:00,360
to spot the race condition vulnerability

39
00:02:00,360 --> 00:02:02,280
in there

40
00:02:02,280 --> 00:02:06,000
um next uh there is a i implemented a

41
00:02:06,000 --> 00:02:08,399
vulnerable web application so we can try

42
00:02:08,399 --> 00:02:10,318
out different race condition

43
00:02:10,318 --> 00:02:12,239
vulnerabilities

44
00:02:12,239 --> 00:02:13,620
um from different attack scenarios

45
00:02:13,620 --> 00:02:16,980
inspired by real world examples and I

46
00:02:16,980 --> 00:02:19,080
also tested

47
00:02:19,080 --> 00:02:21,300
this vulnerable web application with our

48
00:02:21,300 --> 00:02:23,220
secure software development and the

49
00:02:23,220 --> 00:02:25,739
development life cycle practices like

50
00:02:25,739 --> 00:02:27,720
static code analysis Dynamic security

51
00:02:27,720 --> 00:02:30,660
testing and yeah I will show you some

52
00:02:30,660 --> 00:02:34,620
results from that and then we will take

53
00:02:34,620 --> 00:02:37,379
a look at some attack tools how we can

54
00:02:37,379 --> 00:02:39,020
exploit race condition vulnerabilities

55
00:02:39,020 --> 00:02:41,660
I've implemented my own

56
00:02:41,660 --> 00:02:45,000
attack tool based on the research and

57
00:02:45,000 --> 00:02:46,739
but we also will look at the current

58
00:02:46,739 --> 00:02:48,780
Attack 2 landscape what's out there what

59
00:02:48,780 --> 00:02:51,599
we can use and then I will show you the

60
00:02:51,599 --> 00:02:54,060
research results how we can improve the

61
00:02:54,060 --> 00:02:56,700
exploitability and the reliability of

62
00:02:56,700 --> 00:02:59,280
our testing tools

63
00:02:59,280 --> 00:03:01,860
yeah and this will be shown in the live

64
00:03:01,860 --> 00:03:06,440
demo and some finally a conclusion

65
00:03:06,780 --> 00:03:09,120
to the theory so what are race

66
00:03:09,120 --> 00:03:11,280
conditions the first statement here is

67
00:03:11,280 --> 00:03:13,739
from the overus website

68
00:03:13,739 --> 00:03:14,459
um

69
00:03:14,459 --> 00:03:16,800
and what I want to highlight on this one

70
00:03:16,800 --> 00:03:20,459
is the last sentences uh race conditions

71
00:03:20,459 --> 00:03:22,800
by the nature are very difficult to test

72
00:03:22,800 --> 00:03:25,680
for and I could underline this sentence

73
00:03:25,680 --> 00:03:27,720
very very often

74
00:03:27,720 --> 00:03:30,060
um it's very difficult to exploit

75
00:03:30,060 --> 00:03:33,659
sometimes you only find them by accident

76
00:03:33,659 --> 00:03:38,040
and miter mentioned on there also they

77
00:03:38,040 --> 00:03:41,159
mentioned uh it's a research Gap still

78
00:03:41,159 --> 00:03:44,159
and um yeah but it I didn't explain you

79
00:03:44,159 --> 00:03:46,019
what's the race condition so again what

80
00:03:46,019 --> 00:03:48,060
is the race condition so a race

81
00:03:48,060 --> 00:03:50,280
condition is when you have multiple

82
00:03:50,280 --> 00:03:52,920
processes threads accessing the same

83
00:03:52,920 --> 00:03:55,019
shared resource could be the shared

84
00:03:55,019 --> 00:03:58,379
resources the database

85
00:03:58,379 --> 00:04:02,280
a file or something and yeah a race

86
00:04:02,280 --> 00:04:04,920
condition is when you access this data

87
00:04:04,920 --> 00:04:07,440
with multiple processes and then you

88
00:04:07,440 --> 00:04:09,900
have unintended resource unintended

89
00:04:09,900 --> 00:04:12,480
states by some overlapping of these

90
00:04:12,480 --> 00:04:14,819
processes

91
00:04:14,819 --> 00:04:18,358
so in case of web applications uh we

92
00:04:18,358 --> 00:04:20,880
might need multiple HTTP requests as

93
00:04:20,880 --> 00:04:23,120
accessing the same

94
00:04:23,120 --> 00:04:25,500
function yeah

95
00:04:25,500 --> 00:04:27,360
and running the same code

96
00:04:27,360 --> 00:04:30,240
so knock knock race condition race

97
00:04:30,240 --> 00:04:32,100
condition race condition voice there

98
00:04:32,100 --> 00:04:33,360
that's a common joke about race

99
00:04:33,360 --> 00:04:35,699
conditions and it's a good example how

100
00:04:35,699 --> 00:04:38,160
they work like we have one thread doing

101
00:04:38,160 --> 00:04:40,860
the the print of knock knock who is

102
00:04:40,860 --> 00:04:42,540
there and then we have another thread

103
00:04:42,540 --> 00:04:45,419
jumping in and saying print line race

104
00:04:45,419 --> 00:04:46,860
condition race condition race condition

105
00:04:46,860 --> 00:04:49,500
and so there there's a small

106
00:04:49,500 --> 00:04:52,620
time delay between the first print knock

107
00:04:52,620 --> 00:04:54,419
knock and who is there and then another

108
00:04:54,419 --> 00:04:57,000
thread kicks in and prints these

109
00:04:57,000 --> 00:05:00,560
statements so one example

110
00:05:01,320 --> 00:05:02,940
why do we need to care about race

111
00:05:02,940 --> 00:05:04,560
conditions

112
00:05:04,560 --> 00:05:05,699
um what's

113
00:05:05,699 --> 00:05:08,460
what could go wrong with our application

114
00:05:08,460 --> 00:05:10,080
so

115
00:05:10,080 --> 00:05:13,380
um in general you can say any action on

116
00:05:13,380 --> 00:05:15,660
your web application in your business

117
00:05:15,660 --> 00:05:19,500
logic value which is only allowed a

118
00:05:19,500 --> 00:05:21,300
limited number of times

119
00:05:21,300 --> 00:05:23,580
so this would be for example if you have

120
00:05:23,580 --> 00:05:25,860
a Brute Force mechanisms in place which

121
00:05:25,860 --> 00:05:28,199
only allows you to log in uh try look

122
00:05:28,199 --> 00:05:31,800
five times per minute or something so a

123
00:05:31,800 --> 00:05:34,259
race condition uh vulnerability yeah you

124
00:05:34,259 --> 00:05:36,120
could try to bypass that that rate limit

125
00:05:36,120 --> 00:05:39,000
for The Brute Force but also another

126
00:05:39,000 --> 00:05:41,580
example is overdraw over drawing limits

127
00:05:41,580 --> 00:05:44,460
in your bank account for example if you

128
00:05:44,460 --> 00:05:47,400
can't go below zero uh

129
00:05:47,400 --> 00:05:49,500
dollars in your bank account

130
00:05:49,500 --> 00:05:52,680
and yeah if with Verizon condition

131
00:05:52,680 --> 00:05:54,840
vulnerability you could try to overspend

132
00:05:54,840 --> 00:05:57,240
that amount in your bank account

133
00:05:57,240 --> 00:06:00,960
another example is multiple voting like

134
00:06:00,960 --> 00:06:03,620
an online service but also in the

135
00:06:03,620 --> 00:06:07,380
Twitter feed for example from one user

136
00:06:07,380 --> 00:06:09,660
you can only submit one like

137
00:06:09,660 --> 00:06:11,759
on a Twitter feed but the race condition

138
00:06:11,759 --> 00:06:14,039
vulnerability would allow you to submit

139
00:06:14,039 --> 00:06:17,479
multiple likes from one user ID

140
00:06:17,479 --> 00:06:20,340
actually that's a real example from

141
00:06:20,340 --> 00:06:22,740
Twitter they have been vulnerable to

142
00:06:22,740 --> 00:06:24,479
race condition will be vulnerabilities

143
00:06:24,479 --> 00:06:27,080
in that like feature of the feed

144
00:06:27,080 --> 00:06:30,120
multiple execution of transfers

145
00:06:30,120 --> 00:06:33,120
um generating from coupon or codes or

146
00:06:33,120 --> 00:06:34,740
vouchers

147
00:06:34,740 --> 00:06:37,319
um can be both generating multiple

148
00:06:37,319 --> 00:06:40,979
vouchers or using a voucher mode in one

149
00:06:40,979 --> 00:06:43,979
time would be and also finally one

150
00:06:43,979 --> 00:06:44,960
example

151
00:06:44,960 --> 00:06:47,520
anti-cross anti-crossite which is 43

152
00:06:47,520 --> 00:06:49,860
tokens they are designed to be only used

153
00:06:49,860 --> 00:06:51,000
once

154
00:06:51,000 --> 00:06:54,060
and so if you are able to reuse them

155
00:06:54,060 --> 00:06:55,680
with a rate of condition vulnerability

156
00:06:55,680 --> 00:06:58,380
yeah this would be also one scenario but

157
00:06:58,380 --> 00:07:00,600
there are more

158
00:07:00,600 --> 00:07:04,319
and I brought you those examples how

159
00:07:04,319 --> 00:07:06,300
race conditions

160
00:07:06,300 --> 00:07:10,259
can can be very critical so these are

161
00:07:10,259 --> 00:07:14,699
two reports from 2021 where two from two

162
00:07:14,699 --> 00:07:17,100
different researchers I want to show you

163
00:07:17,100 --> 00:07:18,840
the back Bounty payout was very very

164
00:07:18,840 --> 00:07:21,599
high so just the first one uh the back

165
00:07:21,599 --> 00:07:24,479
Bounty was fifty thousand dollars for a

166
00:07:24,479 --> 00:07:26,699
potential account Takeover in Microsoft

167
00:07:26,699 --> 00:07:28,740
the same research should have found the

168
00:07:28,740 --> 00:07:31,440
same vulnerability also in Instagram and

169
00:07:31,440 --> 00:07:34,560
he was able to bypass the Brute Force

170
00:07:34,560 --> 00:07:37,020
protection for reset password codes

171
00:07:37,020 --> 00:07:39,539
which then allowed to bypass

172
00:07:39,539 --> 00:07:41,520
multi-factor orification so that's a

173
00:07:41,520 --> 00:07:45,000
very critical one and the other one also

174
00:07:45,000 --> 00:07:49,680
uh also similar in AWS Cognito where

175
00:07:49,680 --> 00:07:56,060
also the reset uh code was uh vulnerable

176
00:07:56,160 --> 00:07:59,280
I created a list of different bug Bounty

177
00:07:59,280 --> 00:08:01,199
reports and uh

178
00:08:01,199 --> 00:08:04,259
just to read those reports to get

179
00:08:04,259 --> 00:08:07,560
knowledge about what tools these testers

180
00:08:07,560 --> 00:08:10,740
used or these researchers those hackers

181
00:08:10,740 --> 00:08:12,000
used

182
00:08:12,000 --> 00:08:14,280
um and what's the what the payout was

183
00:08:14,280 --> 00:08:16,680
the Bounty and

184
00:08:16,680 --> 00:08:19,740
um on and what I what

185
00:08:19,740 --> 00:08:23,639
um I noticed is that for example if one

186
00:08:23,639 --> 00:08:25,919
application or one application is

187
00:08:25,919 --> 00:08:27,360
vulnerable to a race condition

188
00:08:27,360 --> 00:08:30,060
vulnerability there's a high chance that

189
00:08:30,060 --> 00:08:31,680
there are more than only one so for

190
00:08:31,680 --> 00:08:33,719
example hacker one the back Bounty

191
00:08:33,719 --> 00:08:36,958
platform they had themselves uh six race

192
00:08:36,958 --> 00:08:39,599
conditions vulnerabilities Shopify free

193
00:08:39,599 --> 00:08:42,719
so so if you find one there might be

194
00:08:42,719 --> 00:08:45,680
more and this gives us some ideas about

195
00:08:45,680 --> 00:08:47,820
how the nature of a race condition

196
00:08:47,820 --> 00:08:49,380
vulnerability because it might be

197
00:08:49,380 --> 00:08:52,019
something related to the development

198
00:08:52,019 --> 00:08:54,560
language we use how we write our code

199
00:08:54,560 --> 00:08:57,979
things like that

200
00:08:58,440 --> 00:09:01,140
um now to the coding example Can you

201
00:09:01,140 --> 00:09:04,080
spot the race condition here one example

202
00:09:04,080 --> 00:09:06,839
from from PHP

203
00:09:06,839 --> 00:09:10,560
um here we have only seven lines of code

204
00:09:10,560 --> 00:09:12,480
but there's a raised condition in there

205
00:09:12,480 --> 00:09:13,920
and

206
00:09:13,920 --> 00:09:16,800
it's one of the code Snippets you find

207
00:09:16,800 --> 00:09:19,860
really similar on stack Overflow or on

208
00:09:19,860 --> 00:09:23,640
on the official PHP docs and what I

209
00:09:23,640 --> 00:09:25,560
think is very concerning about this one

210
00:09:25,560 --> 00:09:28,260
yeah that's actually that's a real real

211
00:09:28,260 --> 00:09:29,519
examples

212
00:09:29,519 --> 00:09:31,860
from from stack Overflow and if you copy

213
00:09:31,860 --> 00:09:34,440
them into your application then you are

214
00:09:34,440 --> 00:09:37,860
by by default by uh vulnerable to this

215
00:09:37,860 --> 00:09:40,080
type of attack so

216
00:09:40,080 --> 00:09:42,839
yeah this code what does this do is um

217
00:09:42,839 --> 00:09:45,839
there is a like a withdrawal function

218
00:09:45,839 --> 00:09:49,279
um that you have to

219
00:09:49,279 --> 00:09:53,160
table users you have a column credit and

220
00:09:53,160 --> 00:09:55,500
then in line four you are checking is

221
00:09:55,500 --> 00:09:59,700
the my credit enough can I withdraw the

222
00:09:59,700 --> 00:10:02,580
amount of money then you removed it in

223
00:10:02,580 --> 00:10:04,560
line four that amount of money from your

224
00:10:04,560 --> 00:10:06,360
credit and finally in line six you

225
00:10:06,360 --> 00:10:09,300
update your table users and with the new

226
00:10:09,300 --> 00:10:11,580
credits like yeah withdrawal money

227
00:10:11,580 --> 00:10:15,000
function from a bank account and

228
00:10:15,000 --> 00:10:17,580
um yeah that's what we see between line

229
00:10:17,580 --> 00:10:19,440
two and line six

230
00:10:19,440 --> 00:10:23,240
there is a potential time delay

231
00:10:23,240 --> 00:10:25,860
depends how long this code takes to

232
00:10:25,860 --> 00:10:28,740
execute and we call this we call this

233
00:10:28,740 --> 00:10:30,240
erase window

234
00:10:30,240 --> 00:10:34,260
so this is a very very short time delay

235
00:10:34,260 --> 00:10:37,260
and what could happen is that another

236
00:10:37,260 --> 00:10:40,860
thread jumps in like another HTTP

237
00:10:40,860 --> 00:10:43,740
request calling the same function that

238
00:10:43,740 --> 00:10:45,600
we see here

239
00:10:45,600 --> 00:10:48,779
and this needs this the title of the

240
00:10:48,779 --> 00:10:51,240
presentation is erased Against Time so

241
00:10:51,240 --> 00:10:52,800
it's all about timing with race

242
00:10:52,800 --> 00:10:55,380
conditions and this needs to be this

243
00:10:55,380 --> 00:10:58,140
Auto thread needs to be

244
00:10:58,140 --> 00:11:01,320
um started before the first thread

245
00:11:01,320 --> 00:11:02,660
finished

246
00:11:02,660 --> 00:11:05,519
execution so it the another thread needs

247
00:11:05,519 --> 00:11:07,740
to be started before line six is being

248
00:11:07,740 --> 00:11:10,680
executed in the first fret

249
00:11:10,680 --> 00:11:12,300
so um

250
00:11:12,300 --> 00:11:14,339
yeah that's that's the race condition

251
00:11:14,339 --> 00:11:17,480
this example

252
00:11:21,480 --> 00:11:24,899
good so now a few examples how we could

253
00:11:24,899 --> 00:11:28,860
fix this race conditions in the code

254
00:11:28,860 --> 00:11:33,360
um I I just show you three examples but

255
00:11:33,360 --> 00:11:35,399
especially for PHP there are more

256
00:11:35,399 --> 00:11:37,380
techniques that we could use but these

257
00:11:37,380 --> 00:11:39,660
are General it works for nearly every

258
00:11:39,660 --> 00:11:41,519
coding language

259
00:11:41,519 --> 00:11:44,579
so the most obvious one is a locking

260
00:11:44,579 --> 00:11:46,140
before line two and the unlock after

261
00:11:46,140 --> 00:11:48,060
line six

262
00:11:48,060 --> 00:11:50,339
um so many means no other thread could

263
00:11:50,339 --> 00:11:52,500
work on the same data set

264
00:11:52,500 --> 00:11:54,180
at the same time

265
00:11:54,180 --> 00:11:57,660
another one which I also see have seen

266
00:11:57,660 --> 00:12:00,839
in practice this fix was

267
00:12:00,839 --> 00:12:03,180
um the second one append the condition

268
00:12:03,180 --> 00:12:06,200
to the update statement where we check

269
00:12:06,200 --> 00:12:08,820
before we update the credit with the new

270
00:12:08,820 --> 00:12:11,279
amount of money we check is the credit

271
00:12:11,279 --> 00:12:13,920
still the same did it change in the

272
00:12:13,920 --> 00:12:16,320
meantime which would mean if this one is

273
00:12:16,320 --> 00:12:18,420
uh if the credit got changed by another

274
00:12:18,420 --> 00:12:21,420
process in the meantime it would uh yeah

275
00:12:21,420 --> 00:12:23,760
just not execute the update statement so

276
00:12:23,760 --> 00:12:26,279
it's kind of a Fail-Safe solution it's

277
00:12:26,279 --> 00:12:28,440
not good I would not recommend it but it

278
00:12:28,440 --> 00:12:31,079
works if you have to write a hot fix

279
00:12:31,079 --> 00:12:32,360
somewhere

280
00:12:32,360 --> 00:12:35,700
another option is to use the select for

281
00:12:35,700 --> 00:12:38,880
update statement if this is possible

282
00:12:38,880 --> 00:12:42,660
so um depends on what type of SQL

283
00:12:42,660 --> 00:12:45,420
statements you are using in this this in

284
00:12:45,420 --> 00:12:47,100
this this case it would work you could

285
00:12:47,100 --> 00:12:49,980
write every everything into one SQL

286
00:12:49,980 --> 00:12:51,899
statement then we don't have a time

287
00:12:51,899 --> 00:12:54,360
delay in our code between those

288
00:12:54,360 --> 00:12:56,040
executions

289
00:12:56,040 --> 00:12:57,600
um but it's not always possible for

290
00:12:57,600 --> 00:12:59,820
example if you work with uh could be

291
00:12:59,820 --> 00:13:01,740
other scenarios like it doesn't need to

292
00:13:01,740 --> 00:13:03,720
be first to select and then update it

293
00:13:03,720 --> 00:13:05,700
could be select and then insert or

294
00:13:05,700 --> 00:13:08,100
something else so we can't always uh

295
00:13:08,100 --> 00:13:10,620
combine everything into one SQL

296
00:13:10,620 --> 00:13:12,480
statement

297
00:13:12,480 --> 00:13:15,260
foreign

298
00:13:16,200 --> 00:13:19,200
application

299
00:13:21,000 --> 00:13:23,160
so I've implemented free attack

300
00:13:23,160 --> 00:13:25,740
scenarios like mentioned inspired by

301
00:13:25,740 --> 00:13:28,260
real world examples into a web

302
00:13:28,260 --> 00:13:31,440
application and we are going to exploit

303
00:13:31,440 --> 00:13:33,180
these

304
00:13:33,180 --> 00:13:35,639
race condition vulnerabilities and the

305
00:13:35,639 --> 00:13:38,040
first challenge is the bank transfer the

306
00:13:38,040 --> 00:13:39,959
withdrawal money like the code we just

307
00:13:39,959 --> 00:13:42,720
seen it's not a lot not not a much line

308
00:13:42,720 --> 00:13:46,680
of code here the Second Challenge is the

309
00:13:46,680 --> 00:13:48,180
one inspired by the Twitter feed

310
00:13:48,180 --> 00:13:50,160
vulnerability where you were able to

311
00:13:50,160 --> 00:13:52,680
submit a like multiple times

312
00:13:52,680 --> 00:13:55,920
and the last one also from the examples

313
00:13:55,920 --> 00:13:57,660
logging in using a two-factor

314
00:13:57,660 --> 00:14:00,360
authentication like bypassing the Brute

315
00:14:00,360 --> 00:14:04,100
Force mechanism over there

316
00:14:05,040 --> 00:14:08,160
so uh everything I'm showing you is open

317
00:14:08,160 --> 00:14:10,139
source and GitHub also this web

318
00:14:10,139 --> 00:14:13,560
application you see on the left side on

319
00:14:13,560 --> 00:14:14,519
the screen

320
00:14:14,519 --> 00:14:17,399
it's a it's a small web application with

321
00:14:17,399 --> 00:14:18,839
free challenges all these three

322
00:14:18,839 --> 00:14:20,700
challenges are vulnerable to this race

323
00:14:20,700 --> 00:14:24,180
condition vulnerability and it uses a

324
00:14:24,180 --> 00:14:26,779
default Maria DB and PHP configuration

325
00:14:26,779 --> 00:14:29,639
you can use the docker compose template

326
00:14:29,639 --> 00:14:32,940
to to start it and it's yeah it's

327
00:14:32,940 --> 00:14:35,160
everything by default you see the

328
00:14:35,160 --> 00:14:36,480
versions everything running on the

329
00:14:36,480 --> 00:14:40,380
latest versions and you can try the

330
00:14:40,380 --> 00:14:41,880
different attack tools on this web

331
00:14:41,880 --> 00:14:44,360
application

332
00:14:46,019 --> 00:14:47,120
foreign

333
00:14:47,120 --> 00:14:49,860
so I mentioned my job title in the

334
00:14:49,860 --> 00:14:51,779
beginning I'm an application security

335
00:14:51,779 --> 00:14:55,139
specialist and I try really hard I I

336
00:14:55,139 --> 00:14:58,260
tried everything I can do to protect my

337
00:14:58,260 --> 00:15:01,139
vulnerable web application so I do

338
00:15:01,139 --> 00:15:03,120
usually ideally my day-to-day job with

339
00:15:03,120 --> 00:15:06,959
web application firewall start tools

340
00:15:06,959 --> 00:15:10,380
Dynamic application security testing I

341
00:15:10,380 --> 00:15:13,440
tried very very hard and even runtime

342
00:15:13,440 --> 00:15:16,139
application sales protection agents I

343
00:15:16,139 --> 00:15:17,459
installed everything on this level

344
00:15:17,459 --> 00:15:20,660
application and still you are able to

345
00:15:20,660 --> 00:15:22,500
exploit those race condition

346
00:15:22,500 --> 00:15:26,519
vulnerabilities there so on the left

347
00:15:26,519 --> 00:15:30,180
side you can see uh I did run a static

348
00:15:30,180 --> 00:15:31,680
code analysis

349
00:15:31,680 --> 00:15:34,620
um of that code it contained all the

350
00:15:34,620 --> 00:15:36,660
free challenges all the free vulnerable

351
00:15:36,660 --> 00:15:40,320
examples and it just starts tool did not

352
00:15:40,320 --> 00:15:42,660
find the vulnerability it found two

353
00:15:42,660 --> 00:15:45,240
other vulnerabilities a hard-coded

354
00:15:45,240 --> 00:15:49,079
secret of course so

355
00:15:49,320 --> 00:15:50,459
but not the race condition

356
00:15:50,459 --> 00:15:53,459
vulnerabilities but the vendors they

357
00:15:53,459 --> 00:15:55,620
they claim they they say they support

358
00:15:55,620 --> 00:15:57,300
finding race condition vulnerabilities

359
00:15:57,300 --> 00:16:01,920
in PHP but it did not found those

360
00:16:01,920 --> 00:16:05,459
um so I yeah I just a bit concerning and

361
00:16:05,459 --> 00:16:08,100
it shows that it shows that the miter is

362
00:16:08,100 --> 00:16:10,260
a bit right about this mentioning the

363
00:16:10,260 --> 00:16:11,699
research Gap and there could be

364
00:16:11,699 --> 00:16:14,339
something done helping us to protect

365
00:16:14,339 --> 00:16:16,019
against race condition vulnerabilities

366
00:16:16,019 --> 00:16:18,680
as well

367
00:16:21,000 --> 00:16:23,940
now to the attack tool

368
00:16:23,940 --> 00:16:27,060
so before I show you the attack tool

369
00:16:27,060 --> 00:16:29,519
that I've developed uh I want to mention

370
00:16:29,519 --> 00:16:31,620
the existing tool set there

371
00:16:31,620 --> 00:16:35,459
uh so I analyzed all of them went

372
00:16:35,459 --> 00:16:37,079
through all the code of them to see how

373
00:16:37,079 --> 00:16:39,660
they work in the back and yeah there's

374
00:16:39,660 --> 00:16:42,120
RC exploit raise the web race Pawn

375
00:16:42,120 --> 00:16:45,060
security racer which is like a browser

376
00:16:45,060 --> 00:16:46,860
add-on that you can use and then sense

377
00:16:46,860 --> 00:16:49,740
the request from the client side of

378
00:16:49,740 --> 00:16:52,199
course the most famous one uh most

379
00:16:52,199 --> 00:16:55,920
common one turbo Intruder which most

380
00:16:55,920 --> 00:16:57,600
used to exploit race condition

381
00:16:57,600 --> 00:17:00,360
vulnerabilities and I noticed that like

382
00:17:00,360 --> 00:17:03,480
two different ways how they work

383
00:17:03,480 --> 00:17:06,480
um two types of how they send parallel

384
00:17:06,480 --> 00:17:09,000
requests so when it when we want to

385
00:17:09,000 --> 00:17:10,559
explore the race condition vulnerability

386
00:17:10,559 --> 00:17:14,160
we need to be very fast in sending

387
00:17:14,160 --> 00:17:17,099
requests there needs to be very short

388
00:17:17,099 --> 00:17:20,459
time delay between each request so there

389
00:17:20,459 --> 00:17:22,919
are two ways how they achieve this like

390
00:17:22,919 --> 00:17:25,679
the first one is the parallel uh where

391
00:17:25,679 --> 00:17:28,439
each HTTP request has its own connection

392
00:17:28,439 --> 00:17:31,260
and they often use the trick it's called

393
00:17:31,260 --> 00:17:34,679
the last despite zinc and they they

394
00:17:34,679 --> 00:17:36,840
pre-load a lot of requests

395
00:17:36,840 --> 00:17:40,380
but they don't send the last byte so all

396
00:17:40,380 --> 00:17:42,419
the requests are pre-loaded and then

397
00:17:42,419 --> 00:17:44,640
they send the last bytes of the that

398
00:17:44,640 --> 00:17:47,940
HTTP request uh a bit delayed and then

399
00:17:47,940 --> 00:17:50,280
all the requests are processed at the

400
00:17:50,280 --> 00:17:52,440
same time and that's how you can achieve

401
00:17:52,440 --> 00:17:54,299
a very short time delay but also the

402
00:17:54,299 --> 00:17:57,000
other option is also good use the

403
00:17:57,000 --> 00:17:59,940
pipeline that you glue multiple HTTP

404
00:17:59,940 --> 00:18:02,960
requests into one TCP frame

405
00:18:02,960 --> 00:18:06,000
and finally I want to mention curl

406
00:18:06,000 --> 00:18:08,400
because I saw a lot of bug Bounty

407
00:18:08,400 --> 00:18:10,740
reports on hacker one just using curl

408
00:18:10,740 --> 00:18:13,140
and what they did is just chaining some

409
00:18:13,140 --> 00:18:16,200
curly requests with the end operator

410
00:18:16,200 --> 00:18:19,200
together and it's not the best option

411
00:18:19,200 --> 00:18:20,820
you can do I think this is one of the

412
00:18:20,820 --> 00:18:23,160
worst performance uh you can do but it

413
00:18:23,160 --> 00:18:26,220
worked if it can work if the um

414
00:18:26,220 --> 00:18:28,380
time window you are trying to exploit is

415
00:18:28,380 --> 00:18:29,460
very big

416
00:18:29,460 --> 00:18:34,200
but it's not really a real reliably so

417
00:18:34,200 --> 00:18:37,559
um yeah in 2019 uh girl introduced the

418
00:18:37,559 --> 00:18:40,320
feature it's called minus parallel or

419
00:18:40,320 --> 00:18:43,620
minus flag which improves this a lot so

420
00:18:43,620 --> 00:18:44,880
um if you want to exploit race

421
00:18:44,880 --> 00:18:47,280
conditions you can even use Curl to do

422
00:18:47,280 --> 00:18:49,380
this uh just using the minus parallel

423
00:18:49,380 --> 00:18:52,140
flag so yeah I haven't seen it yet in

424
00:18:52,140 --> 00:18:55,799
news but it should work

425
00:18:55,799 --> 00:18:58,140
so now to propose the tech to

426
00:18:58,140 --> 00:19:00,840
architecture so this is the tool I've

427
00:19:00,840 --> 00:19:03,660
developed based on This research uh it's

428
00:19:03,660 --> 00:19:05,940
it works a bit different from what we

429
00:19:05,940 --> 00:19:09,240
we've seen existing so what I wanted to

430
00:19:09,240 --> 00:19:10,799
change is

431
00:19:10,799 --> 00:19:13,500
um the main differences that now I have

432
00:19:13,500 --> 00:19:16,140
a race between infrastructure

433
00:19:16,140 --> 00:19:16,740
um

434
00:19:16,740 --> 00:19:18,780
with multiple servers

435
00:19:18,780 --> 00:19:21,660
and I have a distributed approach which

436
00:19:21,660 --> 00:19:23,820
means I use multiple servers to send the

437
00:19:23,820 --> 00:19:26,700
requests at the same time and with that

438
00:19:26,700 --> 00:19:30,059
I have a better a shorter time delay

439
00:19:30,059 --> 00:19:32,700
between each request being processed in

440
00:19:32,700 --> 00:19:35,460
the application so let's start from the

441
00:19:35,460 --> 00:19:38,580
beginning so the first step is you have

442
00:19:38,580 --> 00:19:40,140
your process like a browse add-in and

443
00:19:40,140 --> 00:19:43,500
then you enable the monitoring you

444
00:19:43,500 --> 00:19:45,240
select the request which you want to

445
00:19:45,240 --> 00:19:47,940
intercept so there's a Interceptor

446
00:19:47,940 --> 00:19:50,220
running and then you say okay this API

447
00:19:50,220 --> 00:19:52,799
call for example the API call which is

448
00:19:52,799 --> 00:19:54,980
submitting the like on the Twitter feed

449
00:19:54,980 --> 00:19:57,720
this one I want to attack this one I

450
00:19:57,720 --> 00:20:01,860
want to format this now this uh

451
00:20:01,860 --> 00:20:04,440
we are the second step I want to forward

452
00:20:04,440 --> 00:20:06,720
this request to my race dispatcher on

453
00:20:06,720 --> 00:20:08,520
the race routine infrastructure

454
00:20:08,520 --> 00:20:11,700
and then uh this dispatcher is

455
00:20:11,700 --> 00:20:13,440
forwarding this request to the other

456
00:20:13,440 --> 00:20:16,679
servers which we created and then all

457
00:20:16,679 --> 00:20:19,200
the servers are running this HTTP

458
00:20:19,200 --> 00:20:21,120
request at the same time hitting the

459
00:20:21,120 --> 00:20:24,480
target uh and with a very short time

460
00:20:24,480 --> 00:20:27,799
window between each request

461
00:20:31,140 --> 00:20:34,260
yeah the research here the some stats

462
00:20:34,260 --> 00:20:36,539
that I created is um

463
00:20:36,539 --> 00:20:37,740
first

464
00:20:37,740 --> 00:20:41,760
uh yeah each each thought means

465
00:20:41,760 --> 00:20:44,160
one request being processed on the

466
00:20:44,160 --> 00:20:48,179
Target Target and the red color is one

467
00:20:48,179 --> 00:20:50,100
server and the B the blue color is the

468
00:20:50,100 --> 00:20:51,840
second server so you see there's the

469
00:20:51,840 --> 00:20:53,640
overlap between those

470
00:20:53,640 --> 00:20:57,780
um requests and in average there was a

471
00:20:57,780 --> 00:21:01,520
time lapse between each HTTP request of

472
00:21:01,520 --> 00:21:05,100
1.92 milliseconds which I think is a

473
00:21:05,100 --> 00:21:07,440
very good outcome when we think about

474
00:21:07,440 --> 00:21:10,440
the first code example I showed you in

475
00:21:10,440 --> 00:21:13,620
PHP uh this is this average time

476
00:21:13,620 --> 00:21:16,799
something like this needs to process and

477
00:21:16,799 --> 00:21:19,200
for example it's not only the time your

478
00:21:19,200 --> 00:21:21,960
PHP code needs to process it's also

479
00:21:21,960 --> 00:21:24,299
about the SQL query you're running like

480
00:21:24,299 --> 00:21:27,539
if the update statement is taking a more

481
00:21:27,539 --> 00:21:30,360
than four milliseconds then you are you

482
00:21:30,360 --> 00:21:32,640
already know that you can exploit this

483
00:21:32,640 --> 00:21:35,220
so this race window is big enough to be

484
00:21:35,220 --> 00:21:37,760
exploited

485
00:21:37,880 --> 00:21:39,960
and also

486
00:21:39,960 --> 00:21:41,820
um I want to mention the better

487
00:21:41,820 --> 00:21:45,360
indicator of success so because a lot of

488
00:21:45,360 --> 00:21:47,880
um when talking about race conditions

489
00:21:47,880 --> 00:21:49,740
um sometimes you can compare the

490
00:21:49,740 --> 00:21:52,860
requests per second your tool can do but

491
00:21:52,860 --> 00:21:54,900
it it's not a good indicator because

492
00:21:54,900 --> 00:21:57,360
what really matters is the the time

493
00:21:57,360 --> 00:22:00,419
window in the code so you need to make

494
00:22:00,419 --> 00:22:02,760
sure that you have a very short time

495
00:22:02,760 --> 00:22:04,679
window in the code and it it doesn't

496
00:22:04,679 --> 00:22:07,200
matter how many requests you can send

497
00:22:07,200 --> 00:22:08,880
from your tool we do not we're not

498
00:22:08,880 --> 00:22:10,919
trying to run a denial of service attack

499
00:22:10,919 --> 00:22:13,559
we we're trying to be very fast and

500
00:22:13,559 --> 00:22:18,020
finding a small time Gap

501
00:22:18,419 --> 00:22:21,539
uh yeah so how can we increase our

502
00:22:21,539 --> 00:22:24,539
chances here uh so we in general we have

503
00:22:24,539 --> 00:22:27,539
two goals like increasing the

504
00:22:27,539 --> 00:22:29,520
reliability

505
00:22:29,520 --> 00:22:31,380
um where you have the very very short

506
00:22:31,380 --> 00:22:33,840
time race window in the in the code

507
00:22:33,840 --> 00:22:35,520
itself

508
00:22:35,520 --> 00:22:37,500
so you need a very short processing time

509
00:22:37,500 --> 00:22:40,679
of your HTTP request on the Target and

510
00:22:40,679 --> 00:22:42,960
the other goal you can have is that you

511
00:22:42,960 --> 00:22:45,419
want to increase your gain the more

512
00:22:45,419 --> 00:22:48,059
requests you can send within the race

513
00:22:48,059 --> 00:22:51,539
window the more exploit Yeah the more

514
00:22:51,539 --> 00:22:54,659
you can gain from this benefit like more

515
00:22:54,659 --> 00:22:56,580
likes on a Twitter feed from your own

516
00:22:56,580 --> 00:22:59,520
users but also more transactions like if

517
00:22:59,520 --> 00:23:01,679
you withdraw money uh below your bank

518
00:23:01,679 --> 00:23:04,380
account spend limit you can execute more

519
00:23:04,380 --> 00:23:06,659
such withdrawals

520
00:23:06,659 --> 00:23:10,440
and uh yeah you can increase also the

521
00:23:10,440 --> 00:23:12,200
chance of this successful exploitation

522
00:23:12,200 --> 00:23:15,780
by uh using diff multiple IP addresses

523
00:23:15,780 --> 00:23:17,700
there's also the what this new tool

524
00:23:17,700 --> 00:23:20,640
offers like um having multiple

525
00:23:20,640 --> 00:23:22,679
pre-addresses by your race server

526
00:23:22,679 --> 00:23:25,260
infrastructure where you can bypass

527
00:23:25,260 --> 00:23:29,039
um the some rate limits and

528
00:23:29,039 --> 00:23:32,340
also um if you have if you try to attack

529
00:23:32,340 --> 00:23:34,500
if you're a Target is using a load

530
00:23:34,500 --> 00:23:36,539
balancer for example some sticky

531
00:23:36,539 --> 00:23:38,520
sessions just some cookies you can

532
00:23:38,520 --> 00:23:41,100
influence maybe then you can really try

533
00:23:41,100 --> 00:23:45,480
to use two different servers to land on

534
00:23:45,480 --> 00:23:48,120
different server pools which then also

535
00:23:48,120 --> 00:23:49,980
increase the chance of a successful

536
00:23:49,980 --> 00:23:52,380
exploitation and of course the data

537
00:23:52,380 --> 00:23:54,419
center using using a data center or

538
00:23:54,419 --> 00:23:57,000
something for sending those parallel

539
00:23:57,000 --> 00:23:59,159
requests so that's why we moved this

540
00:23:59,159 --> 00:24:02,520
attack tool into uh on the hosting

541
00:24:02,520 --> 00:24:03,960
environment and not running this from

542
00:24:03,960 --> 00:24:07,559
our personal computer and you it's also

543
00:24:07,559 --> 00:24:09,840
benefiting us as if it decreased the

544
00:24:09,840 --> 00:24:11,580
distance between the Target or in the

545
00:24:11,580 --> 00:24:13,500
attacking server maybe we can choose to

546
00:24:13,500 --> 00:24:16,919
run or host our attack in the same data

547
00:24:16,919 --> 00:24:20,039
center in AWS that's possible so yeah we

548
00:24:20,039 --> 00:24:21,480
can run it from everywhere we can deploy

549
00:24:21,480 --> 00:24:23,179
it to everywhere

550
00:24:23,179 --> 00:24:26,700
additional techniques to increase the

551
00:24:26,700 --> 00:24:28,799
exploitability of race conditions you

552
00:24:28,799 --> 00:24:31,500
can slow down the target with

553
00:24:31,500 --> 00:24:33,480
application denial of service technique

554
00:24:33,480 --> 00:24:36,539
like you can try to run a search query

555
00:24:36,539 --> 00:24:37,860
in that application if there is

556
00:24:37,860 --> 00:24:40,140
something you can try to do this and

557
00:24:40,140 --> 00:24:43,380
keep the database busy

558
00:24:43,380 --> 00:24:45,179
um yeah it's because this this increases

559
00:24:45,179 --> 00:24:47,400
a lot your chances of exploiting I've

560
00:24:47,400 --> 00:24:51,240
seen this in practice and you can also

561
00:24:51,240 --> 00:24:54,059
monitor the target you can select a very

562
00:24:54,059 --> 00:24:55,980
busy time frame with heavy user time

563
00:24:55,980 --> 00:24:58,740
where you know the server is currently

564
00:24:58,740 --> 00:25:01,980
very slow and then you have bigger time

565
00:25:01,980 --> 00:25:04,440
Windows uh to for your successful

566
00:25:04,440 --> 00:25:07,100
exploitation

567
00:25:07,620 --> 00:25:11,418
now it's time for a demo

568
00:25:12,780 --> 00:25:16,620
so um on the on the left side

569
00:25:16,620 --> 00:25:18,120
no on the right side we see the

570
00:25:18,120 --> 00:25:21,000
application uh it's um

571
00:25:21,000 --> 00:25:22,860
with the free challenges and we are

572
00:25:22,860 --> 00:25:25,140
going to exploit the second one with the

573
00:25:25,140 --> 00:25:28,140
um uh pole vaults or with the lag

574
00:25:28,140 --> 00:25:30,900
indication and what I've opened is I'm

575
00:25:30,900 --> 00:25:33,000
using here Firefox and I've started the

576
00:25:33,000 --> 00:25:35,159
browser ad in the HTTP request

577
00:25:35,159 --> 00:25:37,980
Interceptor and I'm start saying it

578
00:25:37,980 --> 00:25:41,279
start intercepting

579
00:25:42,179 --> 00:25:43,140
foreign

580
00:25:43,140 --> 00:25:46,919
and then I go to the application I click

581
00:25:46,919 --> 00:25:51,240
to on the action to uh like a feed

582
00:25:51,240 --> 00:25:53,880
and then I say proceeds with the request

583
00:25:53,880 --> 00:25:56,100
and the next step is to forward that

584
00:25:56,100 --> 00:25:58,620
request now so now I'm clicking on raise

585
00:25:58,620 --> 00:26:02,179
it which means I'm forwarding it to my

586
00:26:02,179 --> 00:26:05,520
raised dispatcher which is then using a

587
00:26:05,520 --> 00:26:07,559
list of servers so you see there's a

588
00:26:07,559 --> 00:26:09,779
column with free server so now I'm using

589
00:26:09,779 --> 00:26:11,940
all these three servers to to run this

590
00:26:11,940 --> 00:26:14,820
attack uh all servers are running these

591
00:26:14,820 --> 00:26:17,880
those HTTP requests at the same time and

592
00:26:17,880 --> 00:26:20,340
the payload is also this HTTP request we

593
00:26:20,340 --> 00:26:23,159
just selected from the Interceptor from

594
00:26:23,159 --> 00:26:25,440
the browser add-on and we also can some

595
00:26:25,440 --> 00:26:27,419
some configuration like how many

596
00:26:27,419 --> 00:26:30,179
requests we want per connection or do we

597
00:26:30,179 --> 00:26:31,919
want it to be repeated on the on the

598
00:26:31,919 --> 00:26:33,000
server

599
00:26:33,000 --> 00:26:37,400
so now we click on raise it

600
00:26:42,779 --> 00:26:45,779
and it should have worked so now we are

601
00:26:45,779 --> 00:26:48,120
going back to the application we saw

602
00:26:48,120 --> 00:26:50,640
that it was executed from our raised to

603
00:26:50,640 --> 00:26:53,640
fetcher now I'm stopping the HTTP

604
00:26:53,640 --> 00:26:57,600
intercepting and what we see now in the

605
00:26:57,600 --> 00:27:00,960
in the application

606
00:27:00,960 --> 00:27:03,779
there are now four new likes from the

607
00:27:03,779 --> 00:27:05,220
user ID

608
00:27:05,220 --> 00:27:08,580
free and we should have been only able

609
00:27:08,580 --> 00:27:12,659
to submit the like once so this was the

610
00:27:12,659 --> 00:27:15,120
condition we bypassed exploiting this

611
00:27:15,120 --> 00:27:16,860
race condition

612
00:27:16,860 --> 00:27:21,080
and now we are going to test this

613
00:27:21,600 --> 00:27:26,460
so I opened the reload application to

614
00:27:26,460 --> 00:27:28,260
see all the likes

615
00:27:28,260 --> 00:27:30,419
and then I try to submit another like

616
00:27:30,419 --> 00:27:33,000
from the user ID free and then it tells

617
00:27:33,000 --> 00:27:35,279
me there's one print method uh saying

618
00:27:35,279 --> 00:27:37,620
already like can't like twice so I can't

619
00:27:37,620 --> 00:27:39,659
exploit this erase condition any further

620
00:27:39,659 --> 00:27:42,360
I I yeah like the condition the business

621
00:27:42,360 --> 00:27:46,459
logic blocking me is working

622
00:27:49,080 --> 00:27:51,179
good

623
00:27:51,179 --> 00:27:54,539
there's also over step integration

624
00:27:54,539 --> 00:27:57,000
um which you can use to generate API

625
00:27:57,000 --> 00:27:59,760
commands so what I showed you from using

626
00:27:59,760 --> 00:28:02,460
the browser from intercepting the

627
00:28:02,460 --> 00:28:04,500
request there is also possible to be

628
00:28:04,500 --> 00:28:07,260
automated in your security test so

629
00:28:07,260 --> 00:28:09,960
because we saw there's a lack of

630
00:28:09,960 --> 00:28:10,559
um

631
00:28:10,559 --> 00:28:13,980
supporting tools and in dust or in SAS

632
00:28:13,980 --> 00:28:16,440
we might need to create our own our own

633
00:28:16,440 --> 00:28:19,380
security test so we could integrate them

634
00:28:19,380 --> 00:28:21,539
there but also this is also helpful when

635
00:28:21,539 --> 00:28:23,340
you want to do manual testing as part of

636
00:28:23,340 --> 00:28:24,779
bug boundary research or the penetration

637
00:28:24,779 --> 00:28:28,559
testing you can use over step and select

638
00:28:28,559 --> 00:28:30,840
the HTTP request over there and

639
00:28:30,840 --> 00:28:33,720
forward it to to erase routine

640
00:28:33,720 --> 00:28:35,700
infrastructure to exploit it

641
00:28:35,700 --> 00:28:40,880
so it could be automated in testing

642
00:28:41,360 --> 00:28:44,820
so let's wrap this up with some some

643
00:28:44,820 --> 00:28:47,100
conclusions

644
00:28:47,100 --> 00:28:49,279
foreign

645
00:28:49,940 --> 00:28:54,179
for race conditions it needs a very good

646
00:28:54,179 --> 00:28:56,880
understanding of your business logic

647
00:28:56,880 --> 00:28:59,640
it's something automated tool is

648
00:28:59,640 --> 00:29:02,400
difficult to find so it's one of the

649
00:29:02,400 --> 00:29:04,440
reasons why we

650
00:29:04,440 --> 00:29:07,020
we still need a penetration test that's

651
00:29:07,020 --> 00:29:10,980
something we can't automate that good we

652
00:29:10,980 --> 00:29:13,020
have checked security practices that's

653
00:29:13,020 --> 00:29:15,659
us that that did not help to to find

654
00:29:15,659 --> 00:29:17,159
those vulnerabilities

655
00:29:17,159 --> 00:29:19,440
and also what you can do is perform

656
00:29:19,440 --> 00:29:23,399
refuse using modeling language but also

657
00:29:23,399 --> 00:29:26,580
code reviews with a focus on concurrent

658
00:29:26,580 --> 00:29:29,360
architectures

659
00:29:29,399 --> 00:29:31,799
in general also improve the

660
00:29:31,799 --> 00:29:34,679
discoverability spread awareness about

661
00:29:34,679 --> 00:29:36,779
this type of vulnerability we are always

662
00:29:36,779 --> 00:29:40,559
talking about over top 10 but more than

663
00:29:40,559 --> 00:29:42,960
just over top 10 and especially with

664
00:29:42,960 --> 00:29:44,760
race conditions

665
00:29:44,760 --> 00:29:45,480
um

666
00:29:45,480 --> 00:29:47,340
included in your pen testing and Bug

667
00:29:47,340 --> 00:29:50,640
Bounty scope because that's what those

668
00:29:50,640 --> 00:29:52,679
things are for to find such

669
00:29:52,679 --> 00:29:55,980
vulnerabilities and what we often see in

670
00:29:55,980 --> 00:29:58,039
bug Bounty policies or

671
00:29:58,039 --> 00:30:01,679
that denial of service is excluded that

672
00:30:01,679 --> 00:30:03,659
you are not allowed to run a denial of

673
00:30:03,659 --> 00:30:05,700
service attacks on on the other

674
00:30:05,700 --> 00:30:09,120
vulnerabilities and I I want if you run

675
00:30:09,120 --> 00:30:10,820
a bug Bounty program on everything

676
00:30:10,820 --> 00:30:13,200
explicitly allow testing for race

677
00:30:13,200 --> 00:30:16,740
conditions so researchers know that they

678
00:30:16,740 --> 00:30:18,480
can test for this one

679
00:30:18,480 --> 00:30:20,640
and of course you can integrate such

680
00:30:20,640 --> 00:30:21,720
testing for race condition

681
00:30:21,720 --> 00:30:23,100
vulnerabilities in your end-to-end

682
00:30:23,100 --> 00:30:25,559
security test and I think still

683
00:30:25,559 --> 00:30:28,320
mentioned by Mitra is is a research Gap

684
00:30:28,320 --> 00:30:31,520
we can do more about this I I expected

685
00:30:31,520 --> 00:30:34,980
some coding some solutions some vendors

686
00:30:34,980 --> 00:30:37,380
like static code analysts that they are

687
00:30:37,380 --> 00:30:40,320
able to find such vulnerabilities and

688
00:30:40,320 --> 00:30:43,200
they did not so I think there can be

689
00:30:43,200 --> 00:30:47,100
something done and then and finally use

690
00:30:47,100 --> 00:30:49,860
a distributed eye attack architecture

691
00:30:49,860 --> 00:30:52,320
like the one I showed you the proposed

692
00:30:52,320 --> 00:30:55,620
tool is on GitHub uh you can install it

693
00:30:55,620 --> 00:30:57,419
in your browser works like a browsing

694
00:30:57,419 --> 00:30:59,520
extension you just need to set up this

695
00:30:59,520 --> 00:31:03,539
additional exploiting infrastructure and

696
00:31:03,539 --> 00:31:06,720
yeah we can say it's a Race Against Time

697
00:31:06,720 --> 00:31:09,360
and not the race against uh the number

698
00:31:09,360 --> 00:31:12,480
of requests per seconds so we want we

699
00:31:12,480 --> 00:31:13,740
don't want to

700
00:31:13,740 --> 00:31:16,320
run a denial of service attack we we

701
00:31:16,320 --> 00:31:19,620
only need a few successful requests just

702
00:31:19,620 --> 00:31:22,860
a very very short time delay race window

703
00:31:22,860 --> 00:31:25,679
between them and yes that's that's why

704
00:31:25,679 --> 00:31:27,840
it's a Race Against Time

705
00:31:27,840 --> 00:31:30,240
so you you will find some reference here

706
00:31:30,240 --> 00:31:33,000
if you want to look something up

707
00:31:33,000 --> 00:31:36,179
um but that's it for from my side thank

708
00:31:36,179 --> 00:31:38,940
you very much and I'm happy to take any

709
00:31:38,940 --> 00:31:41,340
questions you can find me also on

710
00:31:41,340 --> 00:31:43,500
Twitter on LinkedIn but maybe we have

711
00:31:43,500 --> 00:31:46,900
also now time for some questions here

712
00:31:46,900 --> 00:31:51,619
[Applause]

