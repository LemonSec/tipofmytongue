1
00:00:01,020 --> 00:00:03,680
foreign

2
00:00:18,270 --> 00:00:27,089
[Music]

3
00:00:37,800 --> 00:00:41,520
okay in this time

4
00:00:41,520 --> 00:00:44,940
let's see hey yes

5
00:00:44,940 --> 00:00:47,540
thank you

6
00:00:50,340 --> 00:00:52,879
hello

7
00:01:01,199 --> 00:01:02,820
everybody

8
00:01:02,820 --> 00:01:05,280
is it

9
00:01:05,280 --> 00:01:06,600
is the mic on

10
00:01:06,600 --> 00:01:09,420
okay perfect

11
00:01:09,420 --> 00:01:13,260
uh my name is Claudio Theodore rescu I

12
00:01:13,260 --> 00:01:16,280
represent binary and this is my talk

13
00:01:16,280 --> 00:01:19,680
blasting event driven Cornucopia with my

14
00:01:19,680 --> 00:01:23,479
colleagues Andrea nigor

15
00:01:25,920 --> 00:01:30,360
so what is wmi wmi stands for Windows

16
00:01:30,360 --> 00:01:32,040
management instrumentation and it is

17
00:01:32,040 --> 00:01:34,740
used to manage Enterprise devices both

18
00:01:34,740 --> 00:01:36,840
locally and remotely

19
00:01:36,840 --> 00:01:38,280
uh

20
00:01:38,280 --> 00:01:40,939
various tools enterprise

21
00:01:40,939 --> 00:01:43,560
software endpoint Solutions are

22
00:01:43,560 --> 00:01:46,020
leveraging wmi to get performance

23
00:01:46,020 --> 00:01:48,720
monitoring and device

24
00:01:48,720 --> 00:01:50,939
device uh

25
00:01:50,939 --> 00:01:54,540
Telemetry get gather Gathering and use

26
00:01:54,540 --> 00:01:57,420
this to invoke a little bit about the

27
00:01:57,420 --> 00:01:59,600
security posture of the of the device

28
00:01:59,600 --> 00:02:02,040
but as we'll see through the

29
00:02:02,040 --> 00:02:05,280
presentation uh this uh wmi is very

30
00:02:05,280 --> 00:02:08,520
easily uh attacked and bypassed and

31
00:02:08,520 --> 00:02:11,160
disabled disabling this will blind all

32
00:02:11,160 --> 00:02:13,080
the Security Solutions that rely on such

33
00:02:13,080 --> 00:02:15,540
Telemetry and this is very important

34
00:02:15,540 --> 00:02:17,700
topic because as a security researchers

35
00:02:17,700 --> 00:02:19,980
we need to know about this and also make

36
00:02:19,980 --> 00:02:22,980
sure we understand the the risks that we

37
00:02:22,980 --> 00:02:25,680
have by allowing this type of attacks to

38
00:02:25,680 --> 00:02:27,420
go unnoticed

39
00:02:27,420 --> 00:02:31,200
so a binary team myself

40
00:02:31,200 --> 00:02:34,680
Claudio Toyota Esco with Andrei and Igor

41
00:02:34,680 --> 00:02:36,540
unfortunately Andrea Nicor couldn't be

42
00:02:36,540 --> 00:02:39,300
here but their role in in this research

43
00:02:39,300 --> 00:02:42,319
was instrumental

44
00:02:42,660 --> 00:02:45,599
so let's go a little bit in the agenda

45
00:02:45,599 --> 00:02:47,760
of this talk so we'll talk a little bit

46
00:02:47,760 --> 00:02:49,140
about the Windows management

47
00:02:49,140 --> 00:02:50,879
instrumentation

48
00:02:50,879 --> 00:02:52,800
about the architecture and features

49
00:02:52,800 --> 00:02:56,099
touch on some of the forensics on wmi

50
00:02:56,099 --> 00:02:59,819
also link the wmi and how is it used in

51
00:02:59,819 --> 00:03:03,540
the firmware to do policy orchestration

52
00:03:03,540 --> 00:03:05,879
then we move to the the part that is

53
00:03:05,879 --> 00:03:08,519
more interesting for the attackers we'll

54
00:03:08,519 --> 00:03:11,340
go and see how wmi used in the wild to

55
00:03:11,340 --> 00:03:14,400
do evil introducing a wmi threat uh

56
00:03:14,400 --> 00:03:15,780
threat model

57
00:03:15,780 --> 00:03:18,480
a template of attack which is very very

58
00:03:18,480 --> 00:03:20,159
easy very easy to implement and it

59
00:03:20,159 --> 00:03:22,739
applies to most of the uh the attacks

60
00:03:22,739 --> 00:03:25,260
that will uh will present today and then

61
00:03:25,260 --> 00:03:27,900
we'll present for for Echo party will

62
00:03:27,900 --> 00:03:30,540
present four new attacks on wmi service

63
00:03:30,540 --> 00:03:31,860
data

64
00:03:31,860 --> 00:03:35,099
with demos we'll switch to another type

65
00:03:35,099 --> 00:03:37,519
of attack on LPC communication channels

66
00:03:37,519 --> 00:03:40,260
uh and it will present a user mode

67
00:03:40,260 --> 00:03:42,659
attack and a kernel mode attack plus a

68
00:03:42,659 --> 00:03:43,860
demo

69
00:03:43,860 --> 00:03:46,680
so let's move forward

70
00:03:46,680 --> 00:03:49,980
so the architecture so wmi actually is

71
00:03:49,980 --> 00:03:51,780
the windows implementation of two

72
00:03:51,780 --> 00:03:54,480
standards the wbm which is a web-based

73
00:03:54,480 --> 00:03:57,120
Enterprise management and cim which is

74
00:03:57,120 --> 00:04:00,659
the common information model so wmi it's

75
00:04:00,659 --> 00:04:02,760
available in all Windows operating

76
00:04:02,760 --> 00:04:04,739
system from since the Inception and it

77
00:04:04,739 --> 00:04:08,299
offers a standardized way to

78
00:04:08,299 --> 00:04:12,000
consume and produce events uh as uh

79
00:04:12,000 --> 00:04:16,339
using com interfaces so in short wmi

80
00:04:16,339 --> 00:04:19,500
architecture consists of uh actually

81
00:04:19,500 --> 00:04:22,580
Implement wmi implements the structuring

82
00:04:22,580 --> 00:04:25,320
querying and transmitting of double Mi

83
00:04:25,320 --> 00:04:28,139
data which is represented as wmi objects

84
00:04:28,139 --> 00:04:30,600
and as part of the WM architecture we

85
00:04:30,600 --> 00:04:32,580
have the providers which provide device

86
00:04:32,580 --> 00:04:33,979
Telemetry

87
00:04:33,979 --> 00:04:36,720
using com interfaces that implemented as

88
00:04:36,720 --> 00:04:38,940
a com dlls

89
00:04:38,940 --> 00:04:41,040
uh then we have the consumers that

90
00:04:41,040 --> 00:04:43,560
consume those uh those uh that device

91
00:04:43,560 --> 00:04:47,160
Telemetry produced by providers uh and

92
00:04:47,160 --> 00:04:51,199
one of the very used

93
00:04:51,660 --> 00:04:53,940
client is the Powershell that can be

94
00:04:53,940 --> 00:04:56,880
used to interact with wmi both locally

95
00:04:56,880 --> 00:05:02,360
and remotely next we have the uh Sim

96
00:05:02,360 --> 00:05:07,280
standard consisting on of

97
00:05:07,740 --> 00:05:11,160
of the query language which is wql to

98
00:05:11,160 --> 00:05:14,580
filter events uh the repository the cim

99
00:05:14,580 --> 00:05:17,240
repository that contains the

100
00:05:17,240 --> 00:05:19,440
class definitions the namespace

101
00:05:19,440 --> 00:05:21,540
definition as well as persistent wmi

102
00:05:21,540 --> 00:05:24,060
objects and then we have the move format

103
00:05:24,060 --> 00:05:27,300
which is an object oriented uh language

104
00:05:27,300 --> 00:05:31,080
to be to be able to extend to specify WM

105
00:05:31,080 --> 00:05:33,060
artifacts to be able to extend the

106
00:05:33,060 --> 00:05:36,900
standard and uh to remotely connect and

107
00:05:36,900 --> 00:05:38,940
transmit the

108
00:05:38,940 --> 00:05:42,960
W transmitter receive wmi data uh winner

109
00:05:42,960 --> 00:05:46,080
win RM or decom can be leveraged and

110
00:05:46,080 --> 00:05:48,240
last but not the list is the wmi service

111
00:05:48,240 --> 00:05:52,139
which is implemented as a as we see host

112
00:05:52,139 --> 00:05:55,620
the service dll in the net svcs group

113
00:05:55,620 --> 00:05:59,160
called winmgmt

114
00:06:00,660 --> 00:06:04,740
so wmi providers as we uh as we I

115
00:06:04,740 --> 00:06:06,600
mentioned they are implemented as com

116
00:06:06,600 --> 00:06:11,060
dlls another each com interface it's

117
00:06:11,060 --> 00:06:15,300
identified by a class ID with uh the

118
00:06:15,300 --> 00:06:18,000
information related to to the com dll

119
00:06:18,000 --> 00:06:22,259
into the registry uh and as you can see

120
00:06:22,259 --> 00:06:24,780
there are more than four thousand even

121
00:06:24,780 --> 00:06:28,020
four thousand wmi providers in Windows

122
00:06:28,020 --> 00:06:31,560
11 covering a lot of device components

123
00:06:31,560 --> 00:06:37,280
such as the ones in the in the table

124
00:06:37,740 --> 00:06:40,979
then one of the benefits of double Mi is

125
00:06:40,979 --> 00:06:43,259
the ability to act on events that cover

126
00:06:43,259 --> 00:06:47,400
nearly any uh any operating system event

127
00:06:47,400 --> 00:06:51,000
another great feature of of wmi is the

128
00:06:51,000 --> 00:06:53,520
ability to register permanent event

129
00:06:53,520 --> 00:06:56,940
subscriptions that survive reboots which

130
00:06:56,940 --> 00:06:58,860
is uh

131
00:06:58,860 --> 00:07:01,259
something that is used in in the Wild by

132
00:07:01,259 --> 00:07:04,139
attackers to obtain persistence on the

133
00:07:04,139 --> 00:07:06,780
device there are two types of events

134
00:07:06,780 --> 00:07:08,940
intrinsic events and extrinsic events

135
00:07:08,940 --> 00:07:11,039
I'll not go into detail so I leave this

136
00:07:11,039 --> 00:07:14,539
definition as a reference

137
00:07:14,539 --> 00:07:17,580
wmi filters it's an instance of the

138
00:07:17,580 --> 00:07:20,280
underscore underscore double event uh

139
00:07:20,280 --> 00:07:22,199
double my event filter is an instance of

140
00:07:22,199 --> 00:07:24,240
the underscore underscore event filter

141
00:07:24,240 --> 00:07:29,340
uh standard class uh that specify which

142
00:07:29,340 --> 00:07:30,360
um

143
00:07:30,360 --> 00:07:34,020
which event should be uh sent to the

144
00:07:34,020 --> 00:07:35,460
bound consumer

145
00:07:35,460 --> 00:07:39,000
so the the main uh the main class

146
00:07:39,000 --> 00:07:42,180
properties for an event filter are event

147
00:07:42,180 --> 00:07:44,039
namespace the namespace where it

148
00:07:44,039 --> 00:07:46,740
operates the query language mostly wql

149
00:07:46,740 --> 00:07:48,960
and the query itself that specifies

150
00:07:48,960 --> 00:07:51,120
which which are the events and when

151
00:07:51,120 --> 00:07:53,400
should they should be uh when should

152
00:07:53,400 --> 00:07:54,960
they should be sent to the bound

153
00:07:54,960 --> 00:07:59,940
consumer and uh a simple example of the

154
00:07:59,940 --> 00:08:04,259
syntax of the wql it's very very close

155
00:08:04,259 --> 00:08:08,819
to SQL queries and two examples one for

156
00:08:08,819 --> 00:08:12,960
uh for a filter that for a intrinsic

157
00:08:12,960 --> 00:08:15,259
events that

158
00:08:15,259 --> 00:08:18,000
triggers whenever notepad exe is

159
00:08:18,000 --> 00:08:20,460
launched and the second is an example of

160
00:08:20,460 --> 00:08:23,160
a filter for extrinsic events that

161
00:08:23,160 --> 00:08:25,379
detects uh

162
00:08:25,379 --> 00:08:28,740
detects persistence via the Run registry

163
00:08:28,740 --> 00:08:30,840
value

164
00:08:30,840 --> 00:08:32,760
next

165
00:08:32,760 --> 00:08:35,458
so w my consumers

166
00:08:35,458 --> 00:08:37,260
we specify

167
00:08:37,260 --> 00:08:40,559
they are linked to the event filters and

168
00:08:40,559 --> 00:08:42,839
what they do they they perform the

169
00:08:42,839 --> 00:08:45,600
action whenever the filter is has

170
00:08:45,600 --> 00:08:49,260
triggered and in the standard cim

171
00:08:49,260 --> 00:08:53,100
standard they are defined five standard

172
00:08:53,100 --> 00:08:54,839
event consumers

173
00:08:54,839 --> 00:08:58,519
to do basic things like save to a log

174
00:08:58,519 --> 00:09:03,720
run command lines or scripts then send

175
00:09:03,720 --> 00:09:06,540
notifications and we mentioned about

176
00:09:06,540 --> 00:09:08,240
persistent event

177
00:09:08,240 --> 00:09:10,399
persistent event

178
00:09:10,399 --> 00:09:13,800
registration and how it's implemented

179
00:09:13,800 --> 00:09:15,360
create a filter

180
00:09:15,360 --> 00:09:18,000
to specify what is the field the event

181
00:09:18,000 --> 00:09:19,860
you you want to trigger on

182
00:09:19,860 --> 00:09:22,200
create a consumer to specify the action

183
00:09:22,200 --> 00:09:24,720
that you need to take when a filter has

184
00:09:24,720 --> 00:09:27,600
triggered and then bind them together in

185
00:09:27,600 --> 00:09:33,260
a instance of filter to Consumer binding

186
00:09:34,200 --> 00:09:38,360
perfect let's go to forensics now

187
00:09:38,880 --> 00:09:42,839
so WM repository or cim repository you

188
00:09:42,839 --> 00:09:46,380
can use it you can use both terms the

189
00:09:46,380 --> 00:09:48,779
location is found in the registry and

190
00:09:48,779 --> 00:09:52,980
consists of three types of files

191
00:09:52,980 --> 00:09:56,459
index BTR objects that data and mapping

192
00:09:56,459 --> 00:10:00,779
that map in the in this repository I

193
00:10:00,779 --> 00:10:03,000
mentioned before but uh it was

194
00:10:03,000 --> 00:10:04,440
mentioning again

195
00:10:04,440 --> 00:10:06,959
the class definitions the namespace

196
00:10:06,959 --> 00:10:09,420
definitions with their qualifiers and

197
00:10:09,420 --> 00:10:12,000
properties as well as persistent objects

198
00:10:12,000 --> 00:10:14,580
are stored and it's important to be able

199
00:10:14,580 --> 00:10:16,380
to parse this because there is a lot of

200
00:10:16,380 --> 00:10:18,180
information

201
00:10:18,180 --> 00:10:20,459
that you can use from there one of them

202
00:10:20,459 --> 00:10:22,800
being the the permanent uh event

203
00:10:22,800 --> 00:10:24,000
subscription

204
00:10:24,000 --> 00:10:27,180
which attackers can use it as a way to

205
00:10:27,180 --> 00:10:28,740
persist

206
00:10:28,740 --> 00:10:32,339
so yeah as part of flair team I reverse

207
00:10:32,339 --> 00:10:36,420
the the format of the of the

208
00:10:36,420 --> 00:10:39,420
um cim repository and wrote some tools

209
00:10:39,420 --> 00:10:42,540
to forensically parse this uh this

210
00:10:42,540 --> 00:10:45,360
database with my good friends uh Willie

211
00:10:45,360 --> 00:10:48,980
Valentin and Matt Graber

212
00:10:49,140 --> 00:10:51,360
the links are in there so let's go a

213
00:10:51,360 --> 00:10:53,459
little bit into some details about the

214
00:10:53,459 --> 00:10:55,380
forensics so I said there are three

215
00:10:55,380 --> 00:10:58,260
types of files index BTR mapping that

216
00:10:58,260 --> 00:11:01,200
map on object that data so index BTR is

217
00:11:01,200 --> 00:11:04,880
a B3 implementation that consists of

218
00:11:04,880 --> 00:11:07,140
search strings

219
00:11:07,140 --> 00:11:10,200
so in order to

220
00:11:10,200 --> 00:11:12,779
Parts a certain uh to to find a certain

221
00:11:12,779 --> 00:11:14,760
the data for a certain instant of a

222
00:11:14,760 --> 00:11:17,220
certain object you have to first uh

223
00:11:17,220 --> 00:11:19,980
create the search

224
00:11:19,980 --> 00:11:23,220
string which is created by uh by

225
00:11:23,220 --> 00:11:25,320
concatenating the identifier for the

226
00:11:25,320 --> 00:11:27,600
namespace the clock the identifier for

227
00:11:27,600 --> 00:11:30,600
the class and the identifier for the for

228
00:11:30,600 --> 00:11:35,459
the instance uh as a hint uh the index

229
00:11:35,459 --> 00:11:37,079
identifier is just the hash of the name

230
00:11:37,079 --> 00:11:39,360
of the class namespace and the instance

231
00:11:39,360 --> 00:11:40,680
itself

232
00:11:40,680 --> 00:11:44,880
using that search string the B3 is

233
00:11:44,880 --> 00:11:48,120
searched on the the record for the in

234
00:11:48,120 --> 00:11:50,220
for the for the index from the index is

235
00:11:50,220 --> 00:11:53,160
identified uh first there are two

236
00:11:53,160 --> 00:11:54,839
numbers three numbers in there the first

237
00:11:54,839 --> 00:11:56,940
one is The Logical number of the actual

238
00:11:56,940 --> 00:12:00,480
data in object that data for the for the

239
00:12:00,480 --> 00:12:02,040
particular instance the second one is

240
00:12:02,040 --> 00:12:04,260
the record ID and the third one is the

241
00:12:04,260 --> 00:12:05,519
size

242
00:12:05,519 --> 00:12:08,399
next uh mapping the map is used because

243
00:12:08,399 --> 00:12:11,100
the logical page number needs to be

244
00:12:11,100 --> 00:12:12,980
translated into its physical

245
00:12:12,980 --> 00:12:15,600
correspondent so mapping map for that

246
00:12:15,600 --> 00:12:19,380
reason consists of uh two d words array

247
00:12:19,380 --> 00:12:21,240
one for the object that data and one for

248
00:12:21,240 --> 00:12:24,000
the index.btr that contains this

249
00:12:24,000 --> 00:12:26,940
translation mapping so the The Logical

250
00:12:26,940 --> 00:12:28,740
page number actually represents the

251
00:12:28,740 --> 00:12:30,720
index in the array and the value of that

252
00:12:30,720 --> 00:12:32,880
index is the physical number physical

253
00:12:32,880 --> 00:12:34,860
page number so now that we have the

254
00:12:34,860 --> 00:12:36,839
physical page number we can go in the

255
00:12:36,839 --> 00:12:39,060
object date that data get the offset of

256
00:12:39,060 --> 00:12:41,160
the page because the page has a certain

257
00:12:41,160 --> 00:12:42,720
size

258
00:12:42,720 --> 00:12:45,779
now we have the page offset we iterate

259
00:12:45,779 --> 00:12:47,880
through the page through the record in

260
00:12:47,880 --> 00:12:50,100
that page to identify the the record

261
00:12:50,100 --> 00:12:52,220
would identifier from the index record

262
00:12:52,220 --> 00:12:55,320
once we find it we are we validate that

263
00:12:55,320 --> 00:12:58,800
they have the same size and once the

264
00:12:58,800 --> 00:13:01,860
same size is validated then we have our

265
00:13:01,860 --> 00:13:03,839
record and then we can we can parse the

266
00:13:03,839 --> 00:13:07,860
uh parse the wmi object properties

267
00:13:07,860 --> 00:13:10,800
next uh the same thing applies for the

268
00:13:10,800 --> 00:13:13,560
parsing the index BTR because uh the

269
00:13:13,560 --> 00:13:15,779
pointers to the next because I I said

270
00:13:15,779 --> 00:13:17,940
it's it's a B3 the pointer to the next

271
00:13:17,940 --> 00:13:19,100
uh

272
00:13:19,100 --> 00:13:21,779
nodes in the in the B3 are actually

273
00:13:21,779 --> 00:13:25,579
specified as logical page numbers

274
00:13:26,880 --> 00:13:29,700
so with this in mind knowing how to

275
00:13:29,700 --> 00:13:32,339
parse the database looking into a on a

276
00:13:32,339 --> 00:13:34,139
Lenovo system

277
00:13:34,139 --> 00:13:38,820
um into the root that wmi namespace we

278
00:13:38,820 --> 00:13:41,100
have a list of functions that starts

279
00:13:41,100 --> 00:13:43,560
with the Lenovo underscore prefix and if

280
00:13:43,560 --> 00:13:45,420
we look there are some

281
00:13:45,420 --> 00:13:48,839
classes with very distinctive names

282
00:13:48,839 --> 00:13:52,500
such as Lenovo biosetting Lenovo set bio

283
00:13:52,500 --> 00:13:55,680
setting Lenovo set BIOS password if we

284
00:13:55,680 --> 00:13:57,839
look at the definition of the set Lenovo

285
00:13:57,839 --> 00:14:01,079
bio setting on the right we see that it

286
00:14:01,079 --> 00:14:05,040
has four properties and one which picks

287
00:14:05,040 --> 00:14:06,480
our attention is the current setting

288
00:14:06,480 --> 00:14:08,940
property

289
00:14:08,940 --> 00:14:11,399
looking into the database for persistent

290
00:14:11,399 --> 00:14:13,079
objects

291
00:14:13,079 --> 00:14:15,180
of this type

292
00:14:15,180 --> 00:14:18,060
leads to empty results which means

293
00:14:18,060 --> 00:14:19,920
these are not persistent objects these

294
00:14:19,920 --> 00:14:22,019
are the dynamic objects that are

295
00:14:22,019 --> 00:14:25,920
generated on a fly by a wmi provider

296
00:14:25,920 --> 00:14:27,720
that is implemented by the vendor by

297
00:14:27,720 --> 00:14:28,800
Lenovo

298
00:14:28,800 --> 00:14:31,440
so for that we can switch to Powershell

299
00:14:31,440 --> 00:14:33,480
use Powershell to actually get the

300
00:14:33,480 --> 00:14:37,139
non-empty instances of the wmi current

301
00:14:37,139 --> 00:14:40,680
Uh current setting that W my BIOS

302
00:14:40,680 --> 00:14:43,260
setting current setting property

303
00:14:43,260 --> 00:14:45,720
so this is

304
00:14:45,720 --> 00:14:48,839
one of such instance and if we go a

305
00:14:48,839 --> 00:14:51,660
little bit magnifying on it we see that

306
00:14:51,660 --> 00:14:55,079
there's some some bios related settings

307
00:14:55,079 --> 00:14:57,779
such as uh trusted text trusted

308
00:14:57,779 --> 00:15:02,040
execution uh bios update and the TPM

309
00:15:02,040 --> 00:15:04,620
type type

310
00:15:04,620 --> 00:15:08,160
settings so which means

311
00:15:08,160 --> 00:15:12,079
we can alter this from the user land

312
00:15:13,500 --> 00:15:16,440
I mentioned the Lenovo underscore set

313
00:15:16,440 --> 00:15:19,860
bios setting that's exactly the class

314
00:15:19,860 --> 00:15:21,899
that can be used to alter these

315
00:15:21,899 --> 00:15:25,940
functions these settings

316
00:15:28,139 --> 00:15:29,339
so

317
00:15:29,339 --> 00:15:32,040
in short

318
00:15:32,040 --> 00:15:35,160
Lenovo provided the interface below the

319
00:15:35,160 --> 00:15:37,199
operating system in the firmware so that

320
00:15:37,199 --> 00:15:40,019
the the provider the the Lenovo provider

321
00:15:40,019 --> 00:15:43,380
the wmi provider can talk to to be able

322
00:15:43,380 --> 00:15:47,000
to read and alter this these settings

323
00:15:47,220 --> 00:15:48,300
so

324
00:15:48,300 --> 00:15:50,180
from the management

325
00:15:50,180 --> 00:15:53,339
perspective or for setting uh easily

326
00:15:53,339 --> 00:15:55,680
setting the BIOS policy orchestration

327
00:15:55,680 --> 00:15:58,500
this is great but uh

328
00:15:58,500 --> 00:16:00,779
exposing such functionality in the user

329
00:16:00,779 --> 00:16:02,760
land

330
00:16:02,760 --> 00:16:04,980
it's a little bit tricky so and this is

331
00:16:04,980 --> 00:16:06,720
and this is why

332
00:16:06,720 --> 00:16:10,860
so in September 2022

333
00:16:10,860 --> 00:16:13,860
a Lenovo vulnerab advisory has been

334
00:16:13,860 --> 00:16:15,180
issued

335
00:16:15,180 --> 00:16:19,380
and we have an update that has two

336
00:16:19,380 --> 00:16:23,279
um CVS that Identify two vulnerabilities

337
00:16:23,279 --> 00:16:25,860
in the SMI Implement SMI handle

338
00:16:25,860 --> 00:16:28,440
implementation of that interface below

339
00:16:28,440 --> 00:16:32,779
the operating system that the W my

340
00:16:33,060 --> 00:16:35,519
provider is leveraging

341
00:16:35,519 --> 00:16:38,639
so one it's uh it's a buffer overflow

342
00:16:38,639 --> 00:16:41,759
and the other one is a information

343
00:16:41,759 --> 00:16:45,480
leakage and if you notice there the SMI

344
00:16:45,480 --> 00:16:49,139
it's set bios pass or smihandler so this

345
00:16:49,139 --> 00:16:51,600
is the Handler that provides the

346
00:16:51,600 --> 00:16:52,980
implementation

347
00:16:52,980 --> 00:16:55,139
which the

348
00:16:55,139 --> 00:16:57,180
Lenovo underscore set BIOS password

349
00:16:57,180 --> 00:17:01,259
class instance is operating via the

350
00:17:01,259 --> 00:17:04,380
win32 provider the provider that Lenovo

351
00:17:04,380 --> 00:17:07,380
provide

352
00:17:07,439 --> 00:17:09,119
so

353
00:17:09,119 --> 00:17:12,599
this is one reason to pay attention to

354
00:17:12,599 --> 00:17:14,640
this type of things and

355
00:17:14,640 --> 00:17:16,980
it's good to have usability it's good to

356
00:17:16,980 --> 00:17:19,859
be to to be able to easily manage your

357
00:17:19,859 --> 00:17:22,500
your Enterprise but understand the risk

358
00:17:22,500 --> 00:17:25,020
of doing that

359
00:17:25,020 --> 00:17:27,839
another class 132 bios is part of the

360
00:17:27,839 --> 00:17:29,580
standard you can get basic information

361
00:17:29,580 --> 00:17:33,240
about the system

362
00:17:33,240 --> 00:17:35,820
so you can get information about who is

363
00:17:35,820 --> 00:17:38,580
your manufacturer of the device uh the

364
00:17:38,580 --> 00:17:40,799
serial number and then the the bias

365
00:17:40,799 --> 00:17:42,980
version

366
00:17:52,260 --> 00:17:55,679
so double am I used by both Defenders

367
00:17:55,679 --> 00:17:59,340
and attackers and because it offers a

368
00:17:59,340 --> 00:18:02,580
great visibility at the device level to

369
00:18:02,580 --> 00:18:06,960
a lot of endpoint Solutions but it all

370
00:18:06,960 --> 00:18:10,020
it provides also a great living of the

371
00:18:10,020 --> 00:18:12,780
land infrastructure to execute malicious

372
00:18:12,780 --> 00:18:15,120
attacks and this is a list of uh

373
00:18:15,120 --> 00:18:17,720
comprehensive lists of ways how to use

374
00:18:17,720 --> 00:18:22,919
wmi to do evil but to do it better it's

375
00:18:22,919 --> 00:18:25,860
just was I thought that it's much easier

376
00:18:25,860 --> 00:18:27,419
to give you an example

377
00:18:27,419 --> 00:18:28,860
so

378
00:18:28,860 --> 00:18:31,200
this is actually

379
00:18:31,200 --> 00:18:33,539
close to something that happened in the

380
00:18:33,539 --> 00:18:36,720
in the wild remember that the fire I

381
00:18:36,720 --> 00:18:41,160
named this uh C daddy the uh the malware

382
00:18:41,160 --> 00:18:44,039
so pretty much it was a persistence via

383
00:18:44,039 --> 00:18:45,660
wmi

384
00:18:45,660 --> 00:18:50,600
the trigger was supposed to execute

385
00:18:50,600 --> 00:18:55,200
and execute the the bound consumer

386
00:18:55,200 --> 00:18:58,860
between uh 240 seconds to 300 seconds

387
00:18:58,860 --> 00:19:02,160
after the system power up

388
00:19:02,160 --> 00:19:04,559
and what was executed so it was executed

389
00:19:04,559 --> 00:19:06,900
the Powershell command with an encoded

390
00:19:06,900 --> 00:19:07,740
um

391
00:19:07,740 --> 00:19:10,080
command

392
00:19:10,080 --> 00:19:12,059
and after decoding it

393
00:19:12,059 --> 00:19:13,200
it

394
00:19:13,200 --> 00:19:15,480
invoke it was executing invoke

395
00:19:15,480 --> 00:19:18,299
expression

396
00:19:18,299 --> 00:19:20,880
by executing the script that is stored

397
00:19:20,880 --> 00:19:23,280
in the description

398
00:19:23,280 --> 00:19:27,379
property of the option class

399
00:19:27,419 --> 00:19:29,100
going forward

400
00:19:29,100 --> 00:19:31,260
we have the evil class double my evil

401
00:19:31,260 --> 00:19:34,100
class in the in the cimv2 namespace

402
00:19:34,100 --> 00:19:38,059
which has two string

403
00:19:38,400 --> 00:19:40,080
properties name and description

404
00:19:40,080 --> 00:19:43,440
description is the one that contains the

405
00:19:43,440 --> 00:19:46,260
script that is run through the consumer

406
00:19:46,260 --> 00:19:48,620
and looking a little bit over the the

407
00:19:48,620 --> 00:19:52,980
script we just see that it extracts the

408
00:19:52,980 --> 00:19:54,919
second stage from the name

409
00:19:54,919 --> 00:19:59,640
base64 decoded store it to a to a file

410
00:19:59,640 --> 00:20:02,220
location in the in the configuration so

411
00:20:02,220 --> 00:20:06,740
this is a c Windows 6 wealth 64 UAV tray

412
00:20:06,740 --> 00:20:09,960
app.exe and then launch it

413
00:20:09,960 --> 00:20:12,900
so we saw that we have persistence data

414
00:20:12,900 --> 00:20:15,240
storage through the wmic option class

415
00:20:15,240 --> 00:20:18,539
and then execution

416
00:20:18,539 --> 00:20:21,679
it's a full cycle

417
00:20:22,140 --> 00:20:24,960
so now let's go in the into the meat of

418
00:20:24,960 --> 00:20:28,260
the discussion the thread model so the

419
00:20:28,260 --> 00:20:30,419
wmi thread model that we proposed

420
00:20:30,419 --> 00:20:34,140
consists of several several items the

421
00:20:34,140 --> 00:20:37,440
windows windows service communicating

422
00:20:37,440 --> 00:20:39,020
with uh

423
00:20:39,020 --> 00:20:43,440
providers and and clients via alpc ports

424
00:20:43,440 --> 00:20:46,559
Advanced LPC ports then we have the wmi

425
00:20:46,559 --> 00:20:49,380
files on on disk the con the

426
00:20:49,380 --> 00:20:51,900
configuration in the registry and also

427
00:20:51,900 --> 00:20:54,419
the wmi data in the in the address space

428
00:20:54,419 --> 00:20:56,940
of Windows service

429
00:20:56,940 --> 00:21:00,900
So based on that we have

430
00:21:00,900 --> 00:21:05,340
bucketed these attacks into five uh big

431
00:21:05,340 --> 00:21:07,799
groups the first one is Attack on the

432
00:21:07,799 --> 00:21:11,940
inside wmi inside the data in the the

433
00:21:11,940 --> 00:21:16,320
text on the data inside the wmi service

434
00:21:16,320 --> 00:21:19,580
process the next is the attacks on wmi

435
00:21:19,580 --> 00:21:24,059
uh alpc Community connections third is

436
00:21:24,059 --> 00:21:26,700
the one on files and registry

437
00:21:26,700 --> 00:21:28,380
information

438
00:21:28,380 --> 00:21:31,260
fourth and fifth is the sandboxing of w

439
00:21:31,260 --> 00:21:34,880
mice service both using a user

440
00:21:34,880 --> 00:21:39,380
mode attack and a kernel mode attack

441
00:21:41,220 --> 00:21:44,100
as black hat I presented several attacks

442
00:21:44,100 --> 00:21:47,220
on on the first and last uh three

443
00:21:47,220 --> 00:21:48,539
buckets

444
00:21:48,539 --> 00:21:52,620
then a labscon I touched on

445
00:21:52,620 --> 00:21:55,380
more attacks of data inside the wmi

446
00:21:55,380 --> 00:21:58,500
process and against the wmi pipe

447
00:21:58,500 --> 00:21:59,880
connections

448
00:21:59,880 --> 00:22:03,059
and for Echo party I'll go further into

449
00:22:03,059 --> 00:22:07,260
into the research and present four

450
00:22:07,260 --> 00:22:09,539
new attacks on data inside the double my

451
00:22:09,539 --> 00:22:12,539
process and uh and to uh one more attack

452
00:22:12,539 --> 00:22:16,200
on the pipe connections

453
00:22:16,200 --> 00:22:20,159
so why those attacks are so dangerous is

454
00:22:20,159 --> 00:22:22,980
because these attacks are in there since

455
00:22:22,980 --> 00:22:24,659
the Inception since the first version of

456
00:22:24,659 --> 00:22:26,039
the wmi

457
00:22:26,039 --> 00:22:29,280
wmi has not been created and the wmi

458
00:22:29,280 --> 00:22:31,080
service is not has not been created with

459
00:22:31,080 --> 00:22:33,000
Security First in mind and the double my

460
00:22:33,000 --> 00:22:34,460
service is not considered a critical

461
00:22:34,460 --> 00:22:37,140
critical app

462
00:22:37,140 --> 00:22:41,400
and the problem is like nobody can

463
00:22:41,400 --> 00:22:45,419
detect those uh those uh alterations of

464
00:22:45,419 --> 00:22:48,000
the address space of Windows service 32

465
00:22:48,000 --> 00:22:51,179
there are no security alerts

466
00:22:51,179 --> 00:22:52,919
another thing is

467
00:22:52,919 --> 00:22:55,020
these attacks are executed from the user

468
00:22:55,020 --> 00:22:57,120
land with the same privileges as the wmi

469
00:22:57,120 --> 00:22:59,360
service

470
00:22:59,400 --> 00:23:00,960
and uh

471
00:23:00,960 --> 00:23:03,600
one of the most important one why is

472
00:23:03,600 --> 00:23:05,640
this so dangerous because this is not

473
00:23:05,640 --> 00:23:06,900
viewed

474
00:23:06,900 --> 00:23:09,539
as a vulnerability this these are

475
00:23:09,539 --> 00:23:12,320
architectural flaws

476
00:23:12,320 --> 00:23:15,900
wmi has not been implemented

477
00:23:15,900 --> 00:23:19,740
to be used in security products wmi had

478
00:23:19,740 --> 00:23:22,640
the only purpose of wmi is just to offer

479
00:23:22,640 --> 00:23:27,799
visibility into the device telemetry

480
00:23:30,480 --> 00:23:34,440
so let me present a template on

481
00:23:34,440 --> 00:23:38,039
attacking wmi data so

482
00:23:38,039 --> 00:23:40,559
pretty much there is a wmidll that is

483
00:23:40,559 --> 00:23:42,620
loaded into the pros address space of

484
00:23:42,620 --> 00:23:44,580
wmi service

485
00:23:44,580 --> 00:23:46,980
usually you have a global flag that is

486
00:23:46,980 --> 00:23:49,860
initialized to its default value in the

487
00:23:49,860 --> 00:23:52,260
init function it is set to the the value

488
00:23:52,260 --> 00:23:55,260
that you need to be in each initialized

489
00:23:55,260 --> 00:23:56,159
to

490
00:23:56,159 --> 00:23:58,980
and when a new wmi connection request or

491
00:23:58,980 --> 00:24:01,559
for adding a new filter or the wmi event

492
00:24:01,559 --> 00:24:04,799
some dispatch routine is called

493
00:24:04,799 --> 00:24:08,340
the global flag is checked if it has the

494
00:24:08,340 --> 00:24:09,419
right value

495
00:24:09,419 --> 00:24:11,640
then

496
00:24:11,640 --> 00:24:14,640
the the event is processed and success

497
00:24:14,640 --> 00:24:18,179
is returned if not then the event is

498
00:24:18,179 --> 00:24:20,820
dropped and then another a certain error

499
00:24:20,820 --> 00:24:24,240
code is returned so an attacker can

500
00:24:24,240 --> 00:24:26,900
find the address of the global flag

501
00:24:26,900 --> 00:24:30,059
patch that flag

502
00:24:30,059 --> 00:24:33,480
so that in the dispatch the error branch

503
00:24:33,480 --> 00:24:34,880
is taken

504
00:24:34,880 --> 00:24:38,100
is returned very simple

505
00:24:38,100 --> 00:24:41,280
way of attacking it

506
00:24:41,280 --> 00:24:45,080
so this is the list of

507
00:24:46,140 --> 00:24:48,960
Flags available in these dlls that are

508
00:24:48,960 --> 00:24:50,400
loaded into the double my process

509
00:24:50,400 --> 00:24:52,740
address space

510
00:24:52,740 --> 00:24:58,039
we presented this six at the blackhead

511
00:24:58,260 --> 00:25:00,840
the next two at labscon

512
00:25:00,840 --> 00:25:03,059
and the following four

513
00:25:03,059 --> 00:25:06,000
will be presenting details today and

514
00:25:06,000 --> 00:25:08,159
show some demos on how to

515
00:25:08,159 --> 00:25:09,960
um

516
00:25:09,960 --> 00:25:14,059
how to attack wmi and blinded

517
00:25:14,280 --> 00:25:16,200
so let's start with the first first one

518
00:25:16,200 --> 00:25:19,620
it's the a pointer to EAC route member

519
00:25:19,620 --> 00:25:22,440
of the city repository uh function C

520
00:25:22,440 --> 00:25:26,340
repository class in wbm core

521
00:25:26,340 --> 00:25:28,799
so as you can see one of the LL wmr core

522
00:25:28,799 --> 00:25:31,260
dll is loaded it is set to null

523
00:25:31,260 --> 00:25:34,159
the pointer is set to null in the init

524
00:25:34,159 --> 00:25:37,980
it is set to the output parameter from

525
00:25:37,980 --> 00:25:39,539
the logon function

526
00:25:39,539 --> 00:25:41,820
and in the shutdown it is released and

527
00:25:41,820 --> 00:25:45,840
set to back to the to zero

528
00:25:45,840 --> 00:25:48,779
and then when a new wmi connection comes

529
00:25:48,779 --> 00:25:49,380
in

530
00:25:49,380 --> 00:25:52,200
we have this uh

531
00:25:52,200 --> 00:25:54,900
call stack and the last one is open yes

532
00:25:54,900 --> 00:25:57,500
ESS

533
00:25:57,500 --> 00:26:01,380
function which will take a look

534
00:26:01,380 --> 00:26:04,440
it's a simple check to save the the

535
00:26:04,440 --> 00:26:07,440
pointer is not null

536
00:26:07,440 --> 00:26:10,080
if it's not null then it's return no

537
00:26:10,080 --> 00:26:13,080
error if it's null it means it returns a

538
00:26:13,080 --> 00:26:16,860
critical error so a clear attack find

539
00:26:16,860 --> 00:26:19,980
the address of the pesc route

540
00:26:19,980 --> 00:26:24,419
set the value to zero in the address so

541
00:26:24,419 --> 00:26:26,640
that open escns

542
00:26:26,640 --> 00:26:29,640
takes the error branch and returns

543
00:26:29,640 --> 00:26:32,520
critical error so

544
00:26:32,520 --> 00:26:34,260
what's happening

545
00:26:34,260 --> 00:26:37,380
after the attack new wmi clients cannot

546
00:26:37,380 --> 00:26:39,600
be started

547
00:26:39,600 --> 00:26:42,419
and the error is always wmae critical

548
00:26:42,419 --> 00:26:44,520
error

549
00:26:44,520 --> 00:26:48,260
so now let's see the first

550
00:26:49,320 --> 00:26:52,158
demo

551
00:27:02,880 --> 00:27:05,760
so we have the latest windows 11.

552
00:27:05,760 --> 00:27:08,940
WM test is a tool that you can use to

553
00:27:08,940 --> 00:27:10,799
interrogate wmi

554
00:27:10,799 --> 00:27:12,720
so right now we're getting the instances

555
00:27:12,720 --> 00:27:18,080
of wm32 processes and their handles

556
00:27:19,860 --> 00:27:23,959
and we're running our attacker app

557
00:27:24,960 --> 00:27:28,020
and then just run this attack that I

558
00:27:28,020 --> 00:27:29,520
described

559
00:27:29,520 --> 00:27:32,520
and you can see there we found the

560
00:27:32,520 --> 00:27:34,860
address of the ESC root we set it to

561
00:27:34,860 --> 00:27:36,779
zero

562
00:27:36,779 --> 00:27:40,279
and then we're trying to run

563
00:27:42,059 --> 00:27:46,320
again wanna test and we have the error

564
00:27:46,320 --> 00:27:51,200
critical error exactly as described

565
00:28:02,820 --> 00:28:05,520
next the P ARB

566
00:28:05,520 --> 00:28:10,559
same same template this is again a

567
00:28:10,559 --> 00:28:15,480
pointer in the cwmi arbitrator class

568
00:28:15,480 --> 00:28:18,240
in the initialize function function

569
00:28:18,240 --> 00:28:21,179
The Constructor is called and then set

570
00:28:21,179 --> 00:28:24,779
set that to uh so this is not c c

571
00:28:24,779 --> 00:28:28,500
language it's it's it's just uh a pseudo

572
00:28:28,500 --> 00:28:30,059
code

573
00:28:30,059 --> 00:28:31,919
from the decompilation

574
00:28:31,919 --> 00:28:35,340
so so we set in the by by calling the

575
00:28:35,340 --> 00:28:38,880
Constructor in initialize class then in

576
00:28:38,880 --> 00:28:41,220
the shutdown it is released and set to

577
00:28:41,220 --> 00:28:42,720
null back

578
00:28:42,720 --> 00:28:44,580
the same thing when a new connection

579
00:28:44,580 --> 00:28:45,659
comes

580
00:28:45,659 --> 00:28:47,640
we have this

581
00:28:47,640 --> 00:28:50,220
call stack the last two the universal

582
00:28:50,220 --> 00:28:52,559
collect which connect which calls the

583
00:28:52,559 --> 00:28:57,059
create instance if we look at them

584
00:28:57,059 --> 00:28:59,059
going backwards in the create instance

585
00:28:59,059 --> 00:29:02,520
the uh the pointer is checked if it's

586
00:29:02,520 --> 00:29:05,940
not set which is when which means when

587
00:29:05,940 --> 00:29:09,539
it's null it returns zero going up

588
00:29:09,539 --> 00:29:12,240
into the universal collect instance is

589
00:29:12,240 --> 00:29:14,220
zero then it's going and returning out

590
00:29:14,220 --> 00:29:16,740
of memory error same thing

591
00:29:16,740 --> 00:29:20,159
new clients cannot connect to to the

592
00:29:20,159 --> 00:29:21,840
service and then

593
00:29:21,840 --> 00:29:24,299
the the current clients

594
00:29:24,299 --> 00:29:26,279
still

595
00:29:26,279 --> 00:29:27,960
can receive events

596
00:29:27,960 --> 00:29:30,659
but the targeted uh the target you want

597
00:29:30,659 --> 00:29:33,080
cannot

598
00:29:33,240 --> 00:29:35,720
next

599
00:29:36,539 --> 00:29:39,200
demo

600
00:29:57,840 --> 00:29:59,279
so now we are getting the running

601
00:29:59,279 --> 00:30:01,380
services

602
00:30:01,380 --> 00:30:03,360
everything goes fine in the latest

603
00:30:03,360 --> 00:30:06,480
version we're running our attacker app

604
00:30:06,480 --> 00:30:09,960
and then go over this

605
00:30:09,960 --> 00:30:14,100
PR disable again where I find it in

606
00:30:14,100 --> 00:30:18,059
memory and set that pointer to zero

607
00:30:18,059 --> 00:30:21,419
and let's see what

608
00:30:21,419 --> 00:30:22,799
happens now

609
00:30:22,799 --> 00:30:26,600
we'll get out of memory error

610
00:30:32,820 --> 00:30:35,418
foreign

611
00:30:39,500 --> 00:30:44,100
flag offline in the CD wbam install

612
00:30:44,100 --> 00:30:46,580
object

613
00:30:46,860 --> 00:30:50,460
so when the dll is loaded

614
00:30:50,460 --> 00:30:52,740
it's set to false

615
00:30:52,740 --> 00:30:54,539
there is a function

616
00:30:54,539 --> 00:30:58,620
mem there is a member method in the CBM

617
00:30:58,620 --> 00:31:03,000
cwm install object to set that flag to

618
00:31:03,000 --> 00:31:06,539
the uh based on the input

619
00:31:06,539 --> 00:31:09,299
when a new double Michael connection

620
00:31:09,299 --> 00:31:12,000
comes in we have this call stack and the

621
00:31:12,000 --> 00:31:14,700
last one is go get class

622
00:31:14,700 --> 00:31:17,880
object if we look at it

623
00:31:17,880 --> 00:31:20,700
very simple one just check if it's not

624
00:31:20,700 --> 00:31:21,600
set

625
00:31:21,600 --> 00:31:24,539
if it if you are not offline then you go

626
00:31:24,539 --> 00:31:27,000
and do some processing if it's if you

627
00:31:27,000 --> 00:31:28,080
are offline

628
00:31:28,080 --> 00:31:30,799
then send this

629
00:31:30,799 --> 00:31:34,860
wwbam if failed genetic error so

630
00:31:34,860 --> 00:31:37,679
the attack is obvious find the address

631
00:31:37,679 --> 00:31:42,059
of MB offline and set it to true

632
00:31:42,059 --> 00:31:45,899
and uh the results are presented same

633
00:31:45,899 --> 00:31:47,460
same results

634
00:31:47,460 --> 00:31:49,620
previous running wmi clients continue

635
00:31:49,620 --> 00:31:50,820
receiving

636
00:31:50,820 --> 00:31:52,620
new clients cannot

637
00:31:52,620 --> 00:31:56,539
connect to the wmi service

638
00:31:56,940 --> 00:31:59,659
next one

639
00:32:13,380 --> 00:32:16,320
you can start using the

640
00:32:16,320 --> 00:32:20,059
wbm tester app

641
00:32:25,020 --> 00:32:29,960
running the our attacker app

642
00:32:33,419 --> 00:32:36,360
finding the address of MB offline

643
00:32:36,360 --> 00:32:39,860
and setting it to true

644
00:32:41,580 --> 00:32:43,740
and as expected

645
00:32:43,740 --> 00:32:47,360
we get the genetic failure

646
00:32:59,539 --> 00:33:03,799
next attack it's the global value

647
00:33:03,799 --> 00:33:06,000
gtls context

648
00:33:06,000 --> 00:33:08,039
in the when this in the initialize

649
00:33:08,039 --> 00:33:11,039
function when wbam ESS

650
00:33:11,039 --> 00:33:14,340
uh is is uh loaded into the address

651
00:33:14,340 --> 00:33:17,220
space of wmi service this function is

652
00:33:17,220 --> 00:33:19,559
called tlsr log

653
00:33:19,559 --> 00:33:23,159
is set into into into this uh

654
00:33:23,159 --> 00:33:25,740
the word file d word and represents the

655
00:33:25,740 --> 00:33:29,220
index to the TLs for the thread for the

656
00:33:29,220 --> 00:33:31,320
current thread uh

657
00:33:31,320 --> 00:33:34,080
if it's not if it's -1 then there is a

658
00:33:34,080 --> 00:33:36,600
failure in the destructor uh the TLs

659
00:33:36,600 --> 00:33:39,480
free is used to um

660
00:33:39,480 --> 00:33:42,380
to free the

661
00:33:42,659 --> 00:33:46,100
the TLs storage

662
00:33:47,279 --> 00:33:51,899
so one of the new wmi callback

663
00:33:51,899 --> 00:33:55,140
request to to be installed comes in we

664
00:33:55,140 --> 00:33:58,500
have this uh call stack and then let's

665
00:33:58,500 --> 00:34:01,440
focus on the last three uh

666
00:34:01,440 --> 00:34:04,080
functions in the AP in in the in that

667
00:34:04,080 --> 00:34:06,779
list the last one it's it's the the C

668
00:34:06,779 --> 00:34:08,940
implementation uh C plus plus

669
00:34:08,940 --> 00:34:11,820
implementation to the TLs so it's a

670
00:34:11,820 --> 00:34:14,760
wrapper around the TLs apis so as you

671
00:34:14,760 --> 00:34:17,040
can see that get actually calls the the

672
00:34:17,040 --> 00:34:20,940
get value TLS get value API uh when it's

673
00:34:20,940 --> 00:34:24,359
if if the the index is uh the global

674
00:34:24,359 --> 00:34:27,540
index is uh equal with -1 which means

675
00:34:27,540 --> 00:34:30,480
it's not set then uh zero is returned

676
00:34:30,480 --> 00:34:32,879
and then going backwards to the color

677
00:34:32,879 --> 00:34:35,399
function in the get current ESS thread

678
00:34:35,399 --> 00:34:36,300
object

679
00:34:36,300 --> 00:34:38,580
the the value of the object returned

680
00:34:38,580 --> 00:34:40,980
from the get function is checked if it's

681
00:34:40,980 --> 00:34:43,859
not zero then additional processing is

682
00:34:43,859 --> 00:34:47,159
happening v0 it's returned to the caller

683
00:34:47,159 --> 00:34:50,339
the prepared current ESS thread object

684
00:34:50,339 --> 00:34:54,060
so when it's if it's zero

685
00:34:54,060 --> 00:34:56,520
if it's not if it's not zero then it's

686
00:34:56,520 --> 00:34:58,380
doing some more processing if it's zero

687
00:34:58,380 --> 00:35:03,060
we get the uh out of memory error again

688
00:35:03,060 --> 00:35:06,440
so let's move

689
00:35:06,540 --> 00:35:10,380
to yet another demo

690
00:35:24,480 --> 00:35:27,300
so we also wrote Our

691
00:35:27,300 --> 00:35:30,000
application to receive events

692
00:35:30,000 --> 00:35:32,940
so we are getting every uh launch up

693
00:35:32,940 --> 00:35:37,200
launch process and display to the com to

694
00:35:37,200 --> 00:35:39,480
the command prompt

695
00:35:39,480 --> 00:35:42,780
and then you can see we have Notepad

696
00:35:42,780 --> 00:35:47,839
and I must paint processes logged

697
00:35:51,780 --> 00:35:53,900
and we're running our

698
00:35:53,900 --> 00:35:57,079
attacker app

699
00:36:04,560 --> 00:36:06,540
found a global

700
00:36:06,540 --> 00:36:09,060
the address for the global

701
00:36:09,060 --> 00:36:13,380
TLS context and then change it to -1

702
00:36:13,380 --> 00:36:16,020
and now you cannot install a callback

703
00:36:16,020 --> 00:36:18,320
anymore

704
00:36:31,859 --> 00:36:33,359
next

705
00:36:33,359 --> 00:36:36,359
now we're going into attacks on wmi

706
00:36:36,359 --> 00:36:39,900
against the alpc channels

707
00:36:39,900 --> 00:36:42,420
so the user mode

708
00:36:42,420 --> 00:36:45,599
so this is describing the the

709
00:36:45,599 --> 00:36:49,380
communication on llpc channels so uh

710
00:36:49,380 --> 00:36:51,839
there is another PC channels between the

711
00:36:51,839 --> 00:36:55,020
service exe and the uh wind energy

712
00:36:55,020 --> 00:36:59,460
service the the wmi service that

713
00:36:59,460 --> 00:37:03,300
connection connection uh it's a it's a

714
00:37:03,300 --> 00:37:06,359
name connection uh Port called a net SVC

715
00:37:06,359 --> 00:37:09,060
and then the the wmi service

716
00:37:09,060 --> 00:37:12,900
communicates with the with the wmi uh

717
00:37:12,900 --> 00:37:15,660
clients via the same type of alp6

718
00:37:15,660 --> 00:37:17,760
channels the only difference it's the

719
00:37:17,760 --> 00:37:19,500
the connection Port is different it's

720
00:37:19,500 --> 00:37:23,339
RPC control backslash OS star so it

721
00:37:23,339 --> 00:37:28,980
starts with all star all a prefix so

722
00:37:28,980 --> 00:37:31,260
the events are exchanged between

723
00:37:31,260 --> 00:37:33,839
providers and clients via these alpc

724
00:37:33,839 --> 00:37:36,259
channels

725
00:37:36,960 --> 00:37:40,020
so a simple attack first we can attack

726
00:37:40,020 --> 00:37:43,740
the client the client handle on the WWI

727
00:37:43,740 --> 00:37:44,880
client side

728
00:37:44,880 --> 00:37:48,240
which means the targeted client

729
00:37:48,240 --> 00:37:50,579
cannot communicate anymore with the

730
00:37:50,579 --> 00:37:53,460
service so you cannot receive events

731
00:37:53,460 --> 00:37:54,660
anymore

732
00:37:54,660 --> 00:37:57,119
the client can reestablish the

733
00:37:57,119 --> 00:37:59,940
connection or relaunch itself but the

734
00:37:59,940 --> 00:38:02,700
attacking attacking app can act as a

735
00:38:02,700 --> 00:38:05,579
watchdog and close the that handle on

736
00:38:05,579 --> 00:38:07,859
the clan side every time

737
00:38:07,859 --> 00:38:09,480
same with that

738
00:38:09,480 --> 00:38:12,720
can be applied from the

739
00:38:12,720 --> 00:38:14,940
server side

740
00:38:14,940 --> 00:38:17,160
so instead of closing the the

741
00:38:17,160 --> 00:38:20,700
client-side handle of the alpc port we

742
00:38:20,700 --> 00:38:24,599
closing the servers server LPC Port

743
00:38:24,599 --> 00:38:31,260
handle which is in the uh wmi service so

744
00:38:31,260 --> 00:38:34,320
the same attack but now

745
00:38:34,320 --> 00:38:38,460
no client can connect to the wmi service

746
00:38:38,460 --> 00:38:41,640
then the only thing uh it can be done

747
00:38:41,640 --> 00:38:44,820
is just to restart the wmi service so

748
00:38:44,820 --> 00:38:47,220
that new connections can start but again

749
00:38:47,220 --> 00:38:50,339
the uh attacker app can act as a

750
00:38:50,339 --> 00:38:53,099
watchdog watch these handles and then

751
00:38:53,099 --> 00:38:54,780
close them whenever they become

752
00:38:54,780 --> 00:38:57,020
available

753
00:38:59,220 --> 00:39:01,140
and uh

754
00:39:01,140 --> 00:39:04,260
now moving to the kernel mode so we have

755
00:39:04,260 --> 00:39:07,140
uh kind of the same on the on the user

756
00:39:07,140 --> 00:39:11,280
user space same same approach

757
00:39:11,280 --> 00:39:13,980
um and we have an app application

758
00:39:13,980 --> 00:39:16,440
attacker application

759
00:39:16,440 --> 00:39:19,500
on the Kernel side we have the alpc port

760
00:39:19,500 --> 00:39:21,359
kernel structures

761
00:39:21,359 --> 00:39:25,260
which uh through the owner process know

762
00:39:25,260 --> 00:39:29,220
the e-process of the client that to

763
00:39:29,220 --> 00:39:32,339
which this alpc port belongs to

764
00:39:32,339 --> 00:39:34,800
so an attack

765
00:39:34,800 --> 00:39:38,099
is just the attacker app installs a a

766
00:39:38,099 --> 00:39:40,260
driver

767
00:39:40,260 --> 00:39:42,060
that uh

768
00:39:42,060 --> 00:39:44,099
through the owner process

769
00:39:44,099 --> 00:39:47,000
you can pinpoint the targeted

770
00:39:47,000 --> 00:39:51,180
double my client through the e-process

771
00:39:51,180 --> 00:39:52,980
and the attack consists of zeroing out

772
00:39:52,980 --> 00:39:55,560
the completion port

773
00:39:55,560 --> 00:39:59,339
so the wmi consumer stops receiving

774
00:39:59,339 --> 00:40:02,180
new events

775
00:40:03,119 --> 00:40:06,380
so let's see and

776
00:40:13,980 --> 00:40:18,020
demo on this this is the last demo

777
00:40:19,320 --> 00:40:22,940
again windows 11.

778
00:40:23,520 --> 00:40:26,420
latest version

779
00:40:33,000 --> 00:40:36,079
we launched the

780
00:40:37,380 --> 00:40:40,440
client W my client

781
00:40:40,440 --> 00:40:43,579
to receive events

782
00:40:58,859 --> 00:41:03,078
and show that WM test has been launched

783
00:41:03,540 --> 00:41:07,079
by running the attacker app

784
00:41:07,079 --> 00:41:10,500
and then disable the server side

785
00:41:10,500 --> 00:41:13,640
alpc port

786
00:41:19,320 --> 00:41:23,220
so as you can see no logging into the

787
00:41:23,220 --> 00:41:25,859
so the client doesn't receive any events

788
00:41:25,859 --> 00:41:26,640
anymore

789
00:41:26,640 --> 00:41:28,440
new clients

790
00:41:28,440 --> 00:41:30,540
you cannot connect to the

791
00:41:30,540 --> 00:41:34,520
wmi service to receive events

792
00:41:36,260 --> 00:41:39,780
so this is the error

793
00:41:39,780 --> 00:41:41,760
you cannot establish a remote procedure

794
00:41:41,760 --> 00:41:43,940
call

795
00:41:55,980 --> 00:42:00,680
so now a conclusion

796
00:42:00,780 --> 00:42:02,579
the whole talk the purpose of the talk

797
00:42:02,579 --> 00:42:05,160
was just to raise awareness

798
00:42:05,160 --> 00:42:08,339
so people that or or companies that are

799
00:42:08,339 --> 00:42:11,280
using wmi as a sole source

800
00:42:11,280 --> 00:42:14,339
for getting device Telemetry are aware

801
00:42:14,339 --> 00:42:16,680
of these limitations and how easy is to

802
00:42:16,680 --> 00:42:19,440
attack uh wmi

803
00:42:19,440 --> 00:42:22,560
and the thing is that

804
00:42:22,560 --> 00:42:26,099
15 to 20 methods of disabling

805
00:42:26,099 --> 00:42:28,800
wmi that I presented

806
00:42:28,800 --> 00:42:32,520
none of them issue any security alerts

807
00:42:32,520 --> 00:42:35,040
and most of them are just as you saw

808
00:42:35,040 --> 00:42:37,200
based on a template like one bit change

809
00:42:37,200 --> 00:42:39,439
attack

810
00:42:39,900 --> 00:42:42,839
and this is because there is an

811
00:42:42,839 --> 00:42:45,900
architectural decision that was made

812
00:42:45,900 --> 00:42:49,560
long time ago about wmi

813
00:42:49,560 --> 00:42:53,099
only the purpose of wmi was to just be

814
00:42:53,099 --> 00:42:55,500
used for the device Telemetry not to be

815
00:42:55,500 --> 00:42:59,099
not to offer information

816
00:42:59,099 --> 00:43:00,839
to uh

817
00:43:00,839 --> 00:43:03,780
this decision making information to to

818
00:43:03,780 --> 00:43:07,619
uh security uh endpoint Solutions

819
00:43:07,619 --> 00:43:12,079
so as a conclusion

820
00:43:12,119 --> 00:43:15,480
use this Telemetry but make sure that it

821
00:43:15,480 --> 00:43:18,140
the the wmi has not been tampered with

822
00:43:18,140 --> 00:43:22,260
and another conclusion is just

823
00:43:22,260 --> 00:43:26,460
this all the attacks that I I presented

824
00:43:26,460 --> 00:43:28,440
can start from the firmware which is a

825
00:43:28,440 --> 00:43:30,240
big plan a big blind spot for the

826
00:43:30,240 --> 00:43:32,660
industry

827
00:43:36,780 --> 00:43:38,860
thank you very much

828
00:43:38,860 --> 00:43:47,619
[Applause]

829
00:43:59,280 --> 00:44:02,119
no questions

830
00:44:02,160 --> 00:44:05,839
ah okay come

831
00:44:13,079 --> 00:44:15,839
can you please talk a bit about which

832
00:44:15,839 --> 00:44:18,540
type of thread actors are using this

833
00:44:18,540 --> 00:44:20,040
type of techniques

834
00:44:20,040 --> 00:44:23,640
uh threat actors you mean yeah

835
00:44:23,640 --> 00:44:25,079
um we didn't see anything in the wild

836
00:44:25,079 --> 00:44:27,420
like from from the from the things that

837
00:44:27,420 --> 00:44:29,520
we presented we didn't see anything in

838
00:44:29,520 --> 00:44:30,720
the wild yet

839
00:44:30,720 --> 00:44:32,339
uh

840
00:44:32,339 --> 00:44:34,619
there's some hints so actually to get

841
00:44:34,619 --> 00:44:37,200
back uh backtrack a bit

842
00:44:37,200 --> 00:44:41,460
we've started with our research with etw

843
00:44:41,460 --> 00:44:43,680
first and present ways how to disable

844
00:44:43,680 --> 00:44:47,099
edw and that etw is more mostly used by

845
00:44:47,099 --> 00:44:49,079
you know the Windows Defender and other

846
00:44:49,079 --> 00:44:51,060
endpoint solutions to actually get

847
00:44:51,060 --> 00:44:53,940
threat threat intelligence through

848
00:44:53,940 --> 00:44:57,060
through their sessions so

849
00:44:57,060 --> 00:44:59,880
we notice something related to the the

850
00:44:59,880 --> 00:45:02,339
talk that we had last year in in uh

851
00:45:02,339 --> 00:45:06,140
black at Europe

852
00:45:06,619 --> 00:45:09,240
back to your question we didn't see any

853
00:45:09,240 --> 00:45:12,060
uh any attacks on wmi yet

854
00:45:12,060 --> 00:45:14,660
thank you

855
00:45:15,780 --> 00:45:18,119
more questions

856
00:45:18,119 --> 00:45:20,599
no

857
00:45:20,700 --> 00:45:22,160
okay

858
00:45:22,160 --> 00:45:24,640
thank you very much again

859
00:45:24,640 --> 00:45:31,560
[Applause]

