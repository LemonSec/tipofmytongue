1
00:00:02,560 --> 00:00:04,160
hello everyone and welcome to sleight of

2
00:00:04,160 --> 00:00:06,399
arm demystifying intel houdini my name

3
00:00:06,399 --> 00:00:08,080
is brian and i'll be discussing intel's

4
00:00:08,080 --> 00:00:10,880
houdini binary translator so what it is

5
00:00:10,880 --> 00:00:12,799
where it's used how it works security

6
00:00:12,799 --> 00:00:14,799
concerns and recommendations

7
00:00:14,799 --> 00:00:16,800
uh before that a quick little bit about

8
00:00:16,800 --> 00:00:19,840
myself i studied uh that's me i studied

9
00:00:19,840 --> 00:00:21,199
electrical engineering at the cooper

10
00:00:21,199 --> 00:00:22,640
union and i'm currently a security

11
00:00:22,640 --> 00:00:24,960
consultant with the ncc group where

12
00:00:24,960 --> 00:00:26,160
lately i've been performing a lot of

13
00:00:26,160 --> 00:00:28,240
android pen tests and sometimes even

14
00:00:28,240 --> 00:00:30,480
android malware analysis

15
00:00:30,480 --> 00:00:32,079
besides that i like to build random bits

16
00:00:32,079 --> 00:00:33,360
of hardware

17
00:00:33,360 --> 00:00:35,200
as well as reverse engineering low-level

18
00:00:35,200 --> 00:00:37,360
stuff that other people build both

19
00:00:37,360 --> 00:00:39,360
hardware and software

20
00:00:39,360 --> 00:00:41,680
and with that let's get started right

21
00:00:41,680 --> 00:00:42,640
onto

22
00:00:42,640 --> 00:00:44,399
android

23
00:00:44,399 --> 00:00:46,480
so

24
00:00:46,480 --> 00:00:48,000
android is one of the largest operating

25
00:00:48,000 --> 00:00:49,760
systems powering about seventy percent

26
00:00:49,760 --> 00:00:52,079
of the mobile devices in the world

27
00:00:52,079 --> 00:00:54,239
and most of you know that you can write

28
00:00:54,239 --> 00:00:56,480
applications for android using java and

29
00:00:56,480 --> 00:00:59,199
now kotlin as well as c and c plus for

30
00:00:59,199 --> 00:01:01,199
native applications using the native

31
00:01:01,199 --> 00:01:02,960
development kit

32
00:01:02,960 --> 00:01:04,159
um

33
00:01:04,159 --> 00:01:05,920
android was originally designed and

34
00:01:05,920 --> 00:01:08,400
built for armed devices but google later

35
00:01:08,400 --> 00:01:11,280
added support for x86 and just to note

36
00:01:11,280 --> 00:01:12,880
there has been unofficial support for

37
00:01:12,880 --> 00:01:15,119
x86 before that as well such as the

38
00:01:15,119 --> 00:01:17,360
android x36 project

39
00:01:17,360 --> 00:01:19,840
um continuing on this background on

40
00:01:19,840 --> 00:01:22,000
android um

41
00:01:22,000 --> 00:01:23,600
so there have been several devices on

42
00:01:23,600 --> 00:01:27,040
x86 running android but

43
00:01:27,040 --> 00:01:29,439
now there are mainly two

44
00:01:29,439 --> 00:01:32,479
and those are x86 chromebooks and x86

45
00:01:32,479 --> 00:01:34,320
hosts running commercial android

46
00:01:34,320 --> 00:01:35,920
emulators

47
00:01:35,920 --> 00:01:37,920
however apps still generally lack

48
00:01:37,920 --> 00:01:41,520
support for x86 and that's because

49
00:01:41,520 --> 00:01:42,720
arm is the

50
00:01:42,720 --> 00:01:44,720
was and is the primary hardware platform

51
00:01:44,720 --> 00:01:45,920
for android

52
00:01:45,920 --> 00:01:47,439
in fact if you have native components in

53
00:01:47,439 --> 00:01:49,520
your app the play store only requires

54
00:01:49,520 --> 00:01:52,399
the arm builds

55
00:01:52,640 --> 00:01:54,799
and due to this many native applications

56
00:01:54,799 --> 00:01:57,680
don't end up containing x86 binaries

57
00:01:57,680 --> 00:01:59,680
only arm

58
00:01:59,680 --> 00:02:00,399
so

59
00:02:00,399 --> 00:02:02,479
the question is how can these x86

60
00:02:02,479 --> 00:02:04,240
android devices run

61
00:02:04,240 --> 00:02:05,920
those apps that only contain arm

62
00:02:05,920 --> 00:02:07,680
binaries

63
00:02:07,680 --> 00:02:09,119
and this is where i'd like to introduce

64
00:02:09,119 --> 00:02:14,080
you to houdini the topic of this talk

65
00:02:14,400 --> 00:02:16,560
houdini is intel's proprietary binary

66
00:02:16,560 --> 00:02:18,879
translator that allows x86 devices to

67
00:02:18,879 --> 00:02:21,200
run armed binaries

68
00:02:21,200 --> 00:02:23,280
it was co-created with google as it was

69
00:02:23,280 --> 00:02:24,959
designed to be run with android native

70
00:02:24,959 --> 00:02:26,720
bridge which we'll talk about in a

71
00:02:26,720 --> 00:02:28,080
second

72
00:02:28,080 --> 00:02:30,160
it's a mysterious black box we don't

73
00:02:30,160 --> 00:02:32,000
know how it works and there doesn't seem

74
00:02:32,000 --> 00:02:35,280
to be any real documentation on it

75
00:02:35,280 --> 00:02:37,120
some vendors may be trying to hide that

76
00:02:37,120 --> 00:02:38,959
they're using it

77
00:02:38,959 --> 00:02:40,480
we may or not

78
00:02:40,480 --> 00:02:43,519
may or may not talk about that and

79
00:02:43,519 --> 00:02:46,879
they are three variants as you see

80
00:02:46,879 --> 00:02:48,720
um

81
00:02:48,720 --> 00:02:52,000
and so houdini where is it yeast it's

82
00:02:52,000 --> 00:02:54,160
used in physical hardware

83
00:02:54,160 --> 00:02:56,640
such as the x86

84
00:02:56,640 --> 00:02:58,720
based phones which we don't see much

85
00:02:58,720 --> 00:03:01,840
anymore and x86 chromebooks which is

86
00:03:01,840 --> 00:03:03,599
actually how we were

87
00:03:03,599 --> 00:03:05,840
able to get the binaries

88
00:03:05,840 --> 00:03:07,280
it's also used in some commercial

89
00:03:07,280 --> 00:03:08,560
emulators

90
00:03:08,560 --> 00:03:10,319
and there is also the android x86

91
00:03:10,319 --> 00:03:11,680
project which can be run on a real

92
00:03:11,680 --> 00:03:14,959
device or in an emulator

93
00:03:15,840 --> 00:03:19,599
so how does it work um it's it's

94
00:03:19,599 --> 00:03:21,920
basically an interpreter for

95
00:03:21,920 --> 00:03:23,599
arm instructions

96
00:03:23,599 --> 00:03:25,840
there's a loop reading the arm up codes

97
00:03:25,840 --> 00:03:27,519
and produces the corresponding behavior

98
00:03:27,519 --> 00:03:29,040
in x86

99
00:03:29,040 --> 00:03:30,879
i do want to point out that it does not

100
00:03:30,879 --> 00:03:34,000
jit it doesn't translate and output x86

101
00:03:34,000 --> 00:03:35,280
instructions

102
00:03:35,280 --> 00:03:37,519
it it just reads the arm code and then

103
00:03:37,519 --> 00:03:39,840
runs

104
00:03:39,840 --> 00:03:42,319
emulates the behavior

105
00:03:42,319 --> 00:03:44,879
there are two main components houdini

106
00:03:44,879 --> 00:03:48,000
and le podini the first of which

107
00:03:48,000 --> 00:03:49,599
just called houdini

108
00:03:49,599 --> 00:03:50,720
runs

109
00:03:50,720 --> 00:03:52,720
arm executable

110
00:03:52,720 --> 00:03:54,720
it runs arm executables yeah both

111
00:03:54,720 --> 00:03:57,439
statically and dynamically linked

112
00:03:57,439 --> 00:03:59,120
when running dynamically linked

113
00:03:59,120 --> 00:04:00,959
executables it uses its own set of

114
00:04:00,959 --> 00:04:03,439
pre-compiled libraries for

115
00:04:03,439 --> 00:04:06,640
arm android in addition to the x86

116
00:04:06,640 --> 00:04:10,480
libraries needed by houdini itself

117
00:04:10,480 --> 00:04:12,080
we can see below that the machine i'm

118
00:04:12,080 --> 00:04:14,319
running on is an x86 machine that's

119
00:04:14,319 --> 00:04:16,238
actually from the chromebook

120
00:04:16,238 --> 00:04:19,839
um you can see uh i-686 x86 machine

121
00:04:19,839 --> 00:04:21,918
and the the binary we're trying to run

122
00:04:21,918 --> 00:04:24,000
is a 32-bit arm

123
00:04:24,000 --> 00:04:25,600
but when i just run it when i try to run

124
00:04:25,600 --> 00:04:27,440
it it just works fine hello static

125
00:04:27,440 --> 00:04:28,880
printout hello world

126
00:04:28,880 --> 00:04:31,280
classic

127
00:04:31,280 --> 00:04:32,720
some of you may have noticed that i've

128
00:04:32,720 --> 00:04:34,479
just executed the binary directly

129
00:04:34,479 --> 00:04:36,400
without invoking houdini

130
00:04:36,400 --> 00:04:37,120
so

131
00:04:37,120 --> 00:04:38,479
you might be asking where does houdini

132
00:04:38,479 --> 00:04:39,759
come from

133
00:04:39,759 --> 00:04:41,680
and this is actually a feature of the

134
00:04:41,680 --> 00:04:44,720
linux kernel called uh bin format misc

135
00:04:44,720 --> 00:04:46,000
and if you aren't familiar with it

136
00:04:46,000 --> 00:04:48,800
here's a really quick explanation

137
00:04:48,800 --> 00:04:50,720
uh miscellaneous binary format is a

138
00:04:50,720 --> 00:04:52,000
linux kernel feature that lets you

139
00:04:52,000 --> 00:04:53,680
basically register interpreters for

140
00:04:53,680 --> 00:04:56,320
custom binary formats kind of similar to

141
00:04:56,320 --> 00:04:57,280
how a

142
00:04:57,280 --> 00:05:00,560
span works in bash or python programs

143
00:05:00,560 --> 00:05:02,639
but on the kernel side kind of

144
00:05:02,639 --> 00:05:05,600
and in this case our custom binary

145
00:05:05,600 --> 00:05:08,320
format is on arm alph

146
00:05:08,320 --> 00:05:09,759
so we see that there are entries

147
00:05:09,759 --> 00:05:11,840
registered for static and dynamic arm

148
00:05:11,840 --> 00:05:13,840
elf binaries

149
00:05:13,840 --> 00:05:15,360
and those are the corresponding magic

150
00:05:15,360 --> 00:05:16,320
bytes

151
00:05:16,320 --> 00:05:18,960
and the interpreter is set to system bin

152
00:05:18,960 --> 00:05:20,560
houdini

153
00:05:20,560 --> 00:05:23,039
so in other words when i run dot slash

154
00:05:23,039 --> 00:05:25,759
hello it becomes

155
00:05:25,759 --> 00:05:28,160
uh well it compares the magic bytes and

156
00:05:28,160 --> 00:05:30,639
if it matches it becomes system bin

157
00:05:30,639 --> 00:05:33,199
houdini dot slash hello

158
00:05:33,199 --> 00:05:35,440
so that's how the executable houdini is

159
00:05:35,440 --> 00:05:37,919
used so let's take a look at the second

160
00:05:37,919 --> 00:05:39,520
component

161
00:05:39,520 --> 00:05:41,039
liphoudini.so

162
00:05:41,039 --> 00:05:42,400
which you could probably guess by the

163
00:05:42,400 --> 00:05:44,960
name is a shared object

164
00:05:44,960 --> 00:05:47,120
it is a shared object for x86 and it's

165
00:05:47,120 --> 00:05:49,680
used to load other shared objects built

166
00:05:49,680 --> 00:05:51,840
for arm

167
00:05:51,840 --> 00:05:53,919
so this is the part where it's designed

168
00:05:53,919 --> 00:05:56,000
to be used with android native bridge so

169
00:05:56,000 --> 00:05:58,880
let's talk about that

170
00:05:59,600 --> 00:06:01,360
android native bridge

171
00:06:01,360 --> 00:06:03,520
is what allows this binary translation

172
00:06:03,520 --> 00:06:06,080
to work on the android side it is part

173
00:06:06,080 --> 00:06:08,080
of the android runtime and is the main

174
00:06:08,080 --> 00:06:09,919
interface between android and lip

175
00:06:09,919 --> 00:06:11,280
houdini

176
00:06:11,280 --> 00:06:12,800
so the android native bridge is the

177
00:06:12,800 --> 00:06:14,479
interface and you could think of le

178
00:06:14,479 --> 00:06:16,000
pertini as the

179
00:06:16,000 --> 00:06:17,280
implementation

180
00:06:17,280 --> 00:06:19,759
of that interface on the

181
00:06:19,759 --> 00:06:23,039
binary translation side

182
00:06:23,039 --> 00:06:26,000
so given that i want to point out that

183
00:06:26,000 --> 00:06:27,520
while it might have been designed with

184
00:06:27,520 --> 00:06:31,039
specifically arm and lipodini in mind

185
00:06:31,039 --> 00:06:33,280
the interface that native bridge

186
00:06:33,280 --> 00:06:35,600
provides can be used to implement other

187
00:06:35,600 --> 00:06:37,759
processor architectures for example nips

188
00:06:37,759 --> 00:06:38,880
on arm

189
00:06:38,880 --> 00:06:41,600
i just thought that was kind of cool

190
00:06:41,600 --> 00:06:44,880
but um delving deeper into native bridge

191
00:06:44,880 --> 00:06:46,400
i mentioned it's part of the android

192
00:06:46,400 --> 00:06:49,520
runtime so it is initialized on boot

193
00:06:49,520 --> 00:06:51,680
and during initialization it checks that

194
00:06:51,680 --> 00:06:55,120
system property rod vm native bridge

195
00:06:55,120 --> 00:06:57,280
if it's zero it native bridge is

196
00:06:57,280 --> 00:06:59,759
disabled but in our case it's set to

197
00:06:59,759 --> 00:07:01,360
lipodini

198
00:07:01,360 --> 00:07:04,160
which points to the library file that

199
00:07:04,160 --> 00:07:06,960
implements native bridge

200
00:07:06,960 --> 00:07:08,960
and it's we'll look for that in the

201
00:07:08,960 --> 00:07:11,758
library pads

202
00:07:14,400 --> 00:07:15,759
if you actually take a look at android

203
00:07:15,759 --> 00:07:19,280
x86 project it um

204
00:07:19,280 --> 00:07:20,639
it seems like they use their own

205
00:07:20,639 --> 00:07:22,560
implementation of native bridge

206
00:07:22,560 --> 00:07:24,880
uh called libmb.so

207
00:07:24,880 --> 00:07:26,960
but it's when you take a closer look

208
00:07:26,960 --> 00:07:28,880
it's actually a wrapper thin wrapper

209
00:07:28,880 --> 00:07:30,800
around lipodini it just causes the

210
00:07:30,800 --> 00:07:33,440
poudini functions

211
00:07:33,440 --> 00:07:35,360
and native bridge defines interface with

212
00:07:35,360 --> 00:07:37,680
two callbacks native bridge runtime

213
00:07:37,680 --> 00:07:40,479
callbacks and native bridge callbacks

214
00:07:40,479 --> 00:07:43,199
and before i get into that

215
00:07:43,199 --> 00:07:45,599
i really have to quickly explain java

216
00:07:45,599 --> 00:07:47,440
native interfaces because they use

217
00:07:47,440 --> 00:07:51,360
heavily they use jni really heavily so

218
00:07:51,360 --> 00:07:54,240
quickly java native interface is the

219
00:07:54,240 --> 00:07:56,240
foreign function interface that enables

220
00:07:56,240 --> 00:07:57,440
our

221
00:07:57,440 --> 00:07:59,759
our jvm code the java code to interact

222
00:07:59,759 --> 00:08:02,560
with the native code and vice versa

223
00:08:02,560 --> 00:08:05,680
so actually this is this jni stuff is

224
00:08:05,680 --> 00:08:08,720
part of java and not specific to android

225
00:08:08,720 --> 00:08:10,400
so it would be much easier to find

226
00:08:10,400 --> 00:08:13,199
information on it

227
00:08:13,199 --> 00:08:14,960
and

228
00:08:14,960 --> 00:08:16,160
when

229
00:08:16,160 --> 00:08:19,919
when the java vm jvm calls uh

230
00:08:19,919 --> 00:08:22,879
a jni compatible native code

231
00:08:22,879 --> 00:08:27,000
it provides a

232
00:08:27,039 --> 00:08:30,160
a uh pointer to a struct jniom and this

233
00:08:30,160 --> 00:08:32,880
jnim basically contains it is basically

234
00:08:32,880 --> 00:08:34,320
a bag of function pointers that can be

235
00:08:34,320 --> 00:08:38,399
used to perform low-level jvm reflection

236
00:08:38,399 --> 00:08:40,399
and it's shown on the right uh the jni

237
00:08:40,399 --> 00:08:42,559
instruct and some of the examples shown

238
00:08:42,559 --> 00:08:45,680
here are you know allocating new objects

239
00:08:45,680 --> 00:08:47,440
calling methods getting some object

240
00:08:47,440 --> 00:08:49,200
fields and such

241
00:08:49,200 --> 00:08:51,680
um so yeah a pointer to this struct will

242
00:08:51,680 --> 00:08:54,240
be passed to our native code as a first

243
00:08:54,240 --> 00:08:56,480
argument

244
00:08:56,480 --> 00:08:58,240
so that our native code if they wanted

245
00:08:58,240 --> 00:09:00,320
to interact with the java world or call

246
00:09:00,320 --> 00:09:03,360
methods or get objects it could

247
00:09:03,360 --> 00:09:05,279
do it using that way

248
00:09:05,279 --> 00:09:06,800
so

249
00:09:06,800 --> 00:09:08,399
back to the native bridge called native

250
00:09:08,399 --> 00:09:10,480
bridge callback interfaces

251
00:09:10,480 --> 00:09:12,720
the first one was called uh native

252
00:09:12,720 --> 00:09:14,399
bridge runtime callbacks

253
00:09:14,399 --> 00:09:16,720
and it's it's passed from our native

254
00:09:16,720 --> 00:09:19,760
bridge on the android side to lippoudini

255
00:09:19,760 --> 00:09:22,160
so that lip houdini can call other

256
00:09:22,160 --> 00:09:24,880
native functions in

257
00:09:24,880 --> 00:09:27,760
uh native bridge slash android

258
00:09:27,760 --> 00:09:29,680
um and it's it's as simple as three

259
00:09:29,680 --> 00:09:31,120
things got met the short you get native

260
00:09:31,120 --> 00:09:33,519
method count get native methods

261
00:09:33,519 --> 00:09:35,519
and that is i think from the android

262
00:09:35,519 --> 00:09:37,839
source

263
00:09:38,080 --> 00:09:41,040
the second more interesting struct is

264
00:09:41,040 --> 00:09:42,000
called

265
00:09:42,000 --> 00:09:44,399
the native bridge callbacks and it is

266
00:09:44,399 --> 00:09:46,320
basically the opposite it provides a way

267
00:09:46,320 --> 00:09:47,839
for a native bridge

268
00:09:47,839 --> 00:09:49,120
on the our android side to call

269
00:09:49,120 --> 00:09:51,760
functions in le houdini

270
00:09:51,760 --> 00:09:52,880
and

271
00:09:52,880 --> 00:09:54,880
there is like a handful of

272
00:09:54,880 --> 00:09:56,080
function pointers in there but i think

273
00:09:56,080 --> 00:09:57,680
the most interesting are

274
00:09:57,680 --> 00:09:59,040
initialize

275
00:09:59,040 --> 00:10:01,360
load library which is similar to dl open

276
00:10:01,360 --> 00:10:03,120
and get trampoline which works similar

277
00:10:03,120 --> 00:10:06,399
to similarly to a dl sim which i'll get

278
00:10:06,399 --> 00:10:08,399
to in a bit

279
00:10:08,399 --> 00:10:10,399
and this struct is actually provided by

280
00:10:10,399 --> 00:10:12,640
lipodini via the exported symbol native

281
00:10:12,640 --> 00:10:15,279
bridge itf and we can see that by doing

282
00:10:15,279 --> 00:10:17,600
object dump

283
00:10:17,600 --> 00:10:20,160
and when you look at it in gaija

284
00:10:20,160 --> 00:10:22,240
you see the actual bytes the function

285
00:10:22,240 --> 00:10:24,000
pointers

286
00:10:24,000 --> 00:10:26,240
right

287
00:10:27,279 --> 00:10:29,519
right so i've kind of just thrown a lot

288
00:10:29,519 --> 00:10:31,680
of pieces at you

289
00:10:31,680 --> 00:10:33,519
and i'm now going to try my best to

290
00:10:33,519 --> 00:10:37,600
explain how all of this comes together

291
00:10:37,600 --> 00:10:39,519
here we go

292
00:10:39,519 --> 00:10:41,360
so this is on a regular arm device

293
00:10:41,360 --> 00:10:42,880
trying to run an application that

294
00:10:42,880 --> 00:10:46,240
contains native arm native code this is

295
00:10:46,240 --> 00:10:48,560
a normal situation you know your phone

296
00:10:48,560 --> 00:10:50,079
um

297
00:10:50,079 --> 00:10:52,880
you launch your app and your app

298
00:10:52,880 --> 00:10:55,760
has code something like system.load

299
00:10:55,760 --> 00:10:57,519
library or load

300
00:10:57,519 --> 00:10:59,760
so the that triggers the android runtime

301
00:10:59,760 --> 00:11:01,360
to dl open our

302
00:11:01,360 --> 00:11:02,320
native

303
00:11:02,320 --> 00:11:05,519
native library lib native.so

304
00:11:05,519 --> 00:11:07,760
and then when the our java code wants to

305
00:11:07,760 --> 00:11:09,920
call it it first does a dlcim which

306
00:11:09,920 --> 00:11:11,600
returns a function pointer to our native

307
00:11:11,600 --> 00:11:14,160
code and then jumps to it and the

308
00:11:14,160 --> 00:11:16,000
android runtime

309
00:11:16,000 --> 00:11:18,640
passes in uh

310
00:11:18,640 --> 00:11:19,440
the

311
00:11:19,440 --> 00:11:21,440
pointer to jnim

312
00:11:21,440 --> 00:11:25,040
when it does the actual function call

313
00:11:25,040 --> 00:11:28,560
now this gets a lot more complicated

314
00:11:28,560 --> 00:11:30,160
with

315
00:11:30,160 --> 00:11:32,160
native bridge enabled and with lipoutini

316
00:11:32,160 --> 00:11:33,519
on x86

317
00:11:33,519 --> 00:11:34,320
so

318
00:11:34,320 --> 00:11:36,320
this is what it starts off with

319
00:11:36,320 --> 00:11:38,399
so remember

320
00:11:38,399 --> 00:11:41,440
native bridge is initialized on boot so

321
00:11:41,440 --> 00:11:43,839
on boot before anything happens um if it

322
00:11:43,839 --> 00:11:45,760
sees that uh native bridge is enabled it

323
00:11:45,760 --> 00:11:48,000
opens the implementation library in our

324
00:11:48,000 --> 00:11:50,959
case lippoudini.so and

325
00:11:50,959 --> 00:11:53,839
note that the top two boxes are x86

326
00:11:53,839 --> 00:11:56,880
and the bottom one is our tart like our

327
00:11:56,880 --> 00:11:58,959
native arm code that we want to run on

328
00:11:58,959 --> 00:12:01,200
our x86 machine

329
00:12:01,200 --> 00:12:02,079
so

330
00:12:02,079 --> 00:12:03,760
yeah our android runtime on

331
00:12:03,760 --> 00:12:05,839
initialization calls the l open and

332
00:12:05,839 --> 00:12:07,839
loads our lip houdini and then it does a

333
00:12:07,839 --> 00:12:09,600
dl sim for that

334
00:12:09,600 --> 00:12:11,760
data bridge callback struct

335
00:12:11,760 --> 00:12:13,920
and calls initialize which isn't shown

336
00:12:13,920 --> 00:12:15,519
in the diagram

337
00:12:15,519 --> 00:12:17,040
all right and then the android finishes

338
00:12:17,040 --> 00:12:18,880
booting up and then you launch your app

339
00:12:18,880 --> 00:12:20,480
and the application once again does

340
00:12:20,480 --> 00:12:23,839
something like system.load library

341
00:12:23,839 --> 00:12:25,680
this time though because native bridge

342
00:12:25,680 --> 00:12:27,360
is enabled

343
00:12:27,360 --> 00:12:30,560
and it's x86 we can't just do dl-open on

344
00:12:30,560 --> 00:12:31,760
our arm

345
00:12:31,760 --> 00:12:33,680
native library

346
00:12:33,680 --> 00:12:36,639
and native bridge knows to

347
00:12:36,639 --> 00:12:38,320
um

348
00:12:38,320 --> 00:12:40,800
call lupudini's load library function

349
00:12:40,800 --> 00:12:44,000
from that native bridge callback extract

350
00:12:44,000 --> 00:12:46,320
and load the load library function acts

351
00:12:46,320 --> 00:12:48,160
similar to dl open

352
00:12:48,160 --> 00:12:51,440
and that italy will load a

353
00:12:51,440 --> 00:12:53,839
it will load the actual native library

354
00:12:53,839 --> 00:12:55,680
in the in memory

355
00:12:55,680 --> 00:12:58,000
and give you a handle

356
00:12:58,000 --> 00:12:59,440
um

357
00:12:59,440 --> 00:13:00,399
right

358
00:13:00,399 --> 00:13:02,880
we can call dl open because um it won't

359
00:13:02,880 --> 00:13:06,160
let you not like uh load uh

360
00:13:06,160 --> 00:13:07,760
a library of a different architecture

361
00:13:07,760 --> 00:13:08,959
like it will give you an error or

362
00:13:08,959 --> 00:13:10,240
something like architecture that

363
00:13:10,240 --> 00:13:12,880
mismatch or something like that

364
00:13:12,880 --> 00:13:15,279
so when the in our application code now

365
00:13:15,279 --> 00:13:17,839
once you actually get jump

366
00:13:17,839 --> 00:13:20,800
jump to the code native code

367
00:13:20,800 --> 00:13:22,720
we can't do a dlc sim for the same

368
00:13:22,720 --> 00:13:24,639
reason it will give us

369
00:13:24,639 --> 00:13:27,040
architecture mismatch and also if it

370
00:13:27,040 --> 00:13:28,480
actually gave us the function pointer

371
00:13:28,480 --> 00:13:30,880
into our native code

372
00:13:30,880 --> 00:13:32,720
it will be the function will contain a

373
00:13:32,720 --> 00:13:34,560
bunch of arm instructions

374
00:13:34,560 --> 00:13:36,399
which our x86 processors cannot

375
00:13:36,399 --> 00:13:37,519
understand

376
00:13:37,519 --> 00:13:39,760
so what get trampoline does is it

377
00:13:39,760 --> 00:13:40,959
actually gives

378
00:13:40,959 --> 00:13:43,120
a function pointer to a little stub

379
00:13:43,120 --> 00:13:46,160
inside of our interpreter

380
00:13:46,160 --> 00:13:47,680
so that when we

381
00:13:47,680 --> 00:13:49,760
call that interpreter

382
00:13:49,760 --> 00:13:50,959
the

383
00:13:50,959 --> 00:13:52,880
the interpreter starts running our

384
00:13:52,880 --> 00:13:54,639
native code

385
00:13:54,639 --> 00:13:56,880
that part is

386
00:13:56,880 --> 00:13:58,480
yeah

387
00:13:58,480 --> 00:14:01,040
but we have one last part that i have to

388
00:14:01,040 --> 00:14:03,360
explain which is the jni m

389
00:14:03,360 --> 00:14:06,000
structure um not only is do we have to

390
00:14:06,000 --> 00:14:07,680
um

391
00:14:07,680 --> 00:14:10,240
so for the same reason we can't uh just

392
00:14:10,240 --> 00:14:12,000
get the function pointer to our arm

393
00:14:12,000 --> 00:14:13,199
native code

394
00:14:13,199 --> 00:14:16,480
uh we can't pass our jnim which is full

395
00:14:16,480 --> 00:14:20,959
of x86 functions on into our native code

396
00:14:20,959 --> 00:14:22,880
our arm code

397
00:14:22,880 --> 00:14:26,160
so basically we can't do that

398
00:14:26,480 --> 00:14:28,480
so

399
00:14:28,480 --> 00:14:30,480
what lipoudini it does is it actually

400
00:14:30,480 --> 00:14:32,959
remembers where the jni that was passed

401
00:14:32,959 --> 00:14:34,480
in where it was

402
00:14:34,480 --> 00:14:37,279
and then it creates its own fake jana m

403
00:14:37,279 --> 00:14:38,320
structure

404
00:14:38,320 --> 00:14:40,800
filled with arm function pointers

405
00:14:40,800 --> 00:14:44,000
and it uses that to pass to our arm

406
00:14:44,000 --> 00:14:45,760
native code

407
00:14:45,760 --> 00:14:46,880
um

408
00:14:46,880 --> 00:14:49,680
so yeah so actually the

409
00:14:49,680 --> 00:14:52,079
when you try to call the

410
00:14:52,079 --> 00:14:54,399
use any of the jni functions

411
00:14:54,399 --> 00:14:55,839
from that struct

412
00:14:55,839 --> 00:14:58,880
um the actual function will just

413
00:14:58,880 --> 00:15:00,639
uh have

414
00:15:00,639 --> 00:15:01,680
um

415
00:15:01,680 --> 00:15:02,880
trap instrument it will actually have

416
00:15:02,880 --> 00:15:04,800
syscall instructions which will be

417
00:15:04,800 --> 00:15:07,040
interpreted by our

418
00:15:07,040 --> 00:15:09,920
interpreter inside of lupidini and

419
00:15:09,920 --> 00:15:12,320
depending on the syscall number uh

420
00:15:12,320 --> 00:15:15,440
libridini knows which

421
00:15:15,440 --> 00:15:18,240
x86 jni function pointer function to

422
00:15:18,240 --> 00:15:20,399
call

423
00:15:20,399 --> 00:15:22,720
yeah

424
00:15:22,880 --> 00:15:24,399
this part is probably one of the most

425
00:15:24,399 --> 00:15:27,120
confusing parts to explain

426
00:15:27,120 --> 00:15:29,519
and understand

427
00:15:29,519 --> 00:15:32,240
so continuing continuing on let's delve

428
00:15:32,240 --> 00:15:34,399
now delve deeper into the le podini of

429
00:15:34,399 --> 00:15:36,399
different components inside of the

430
00:15:36,399 --> 00:15:37,440
houdini

431
00:15:37,440 --> 00:15:38,839
so first up is

432
00:15:38,839 --> 00:15:42,079
memory it is a dual architecture user

433
00:15:42,079 --> 00:15:45,120
lan so it

434
00:15:45,680 --> 00:15:48,720
it loads both arm and x86

435
00:15:48,720 --> 00:15:50,320
binaries

436
00:15:50,320 --> 00:15:51,920
uh i'm going to combine the second third

437
00:15:51,920 --> 00:15:53,360
builder point shared virtual address

438
00:15:53,360 --> 00:15:55,680
space and real world view of memory that

439
00:15:55,680 --> 00:15:57,759
just basically means uh they share an

440
00:15:57,759 --> 00:15:59,600
address space

441
00:15:59,600 --> 00:16:01,519
uh there's no like magic translation

442
00:16:01,519 --> 00:16:04,079
between like arm memory address and x86

443
00:16:04,079 --> 00:16:06,079
memory address they're just all in the

444
00:16:06,079 --> 00:16:06,839
same

445
00:16:06,839 --> 00:16:10,000
memory and the arm

446
00:16:10,000 --> 00:16:12,639
yeah has its own separate allocation for

447
00:16:12,639 --> 00:16:13,920
stack

448
00:16:13,920 --> 00:16:15,519
and just to show you some examples this

449
00:16:15,519 --> 00:16:17,040
is a snippet from the one of the

450
00:16:17,040 --> 00:16:19,279
processes memory map

451
00:16:19,279 --> 00:16:20,800
of an application

452
00:16:20,800 --> 00:16:23,759
with libertini and native bridge enabled

453
00:16:23,759 --> 00:16:26,000
um we could see our native library

454
00:16:26,000 --> 00:16:28,399
loaded in here as as well as our lip

455
00:16:28,399 --> 00:16:31,759
houdini on the bottom

456
00:16:31,759 --> 00:16:35,839
these are the arm libraries mapped in

457
00:16:35,839 --> 00:16:37,120
you can tell by

458
00:16:37,120 --> 00:16:40,639
slash vendor slash lib slash arm

459
00:16:40,639 --> 00:16:43,920
slash nb native bridge

460
00:16:48,560 --> 00:16:51,600
you can see uh there's both arm and x86

461
00:16:51,600 --> 00:16:54,160
versions of lipsy loaded in

462
00:16:54,160 --> 00:16:57,440
and there are some anonymous pages of

463
00:16:57,440 --> 00:16:59,199
anonymous pages you use internally by

464
00:16:59,199 --> 00:17:00,560
lippertini

465
00:17:00,560 --> 00:17:02,959
uh one or more of these will be the arm

466
00:17:02,959 --> 00:17:04,559
stack

467
00:17:04,559 --> 00:17:07,520
so moving on the actual execution loop

468
00:17:07,520 --> 00:17:09,119
so i mentioned earlier it's it's

469
00:17:09,119 --> 00:17:10,959
basically a switch statement inside a

470
00:17:10,959 --> 00:17:12,240
while loop

471
00:17:12,240 --> 00:17:14,240
this screenshot shows the portion where

472
00:17:14,240 --> 00:17:15,599
the interpreter reads the arm

473
00:17:15,599 --> 00:17:16,720
instruction

474
00:17:16,720 --> 00:17:18,319
and jumps to the proper instruction

475
00:17:18,319 --> 00:17:19,919
handler depending on which instruction

476
00:17:19,919 --> 00:17:21,199
it is

477
00:17:21,199 --> 00:17:22,559
you can see my comments on the right but

478
00:17:22,559 --> 00:17:24,000
i will have a c equivalent code on the

479
00:17:24,000 --> 00:17:25,280
next slide

480
00:17:25,280 --> 00:17:29,360
so this is the fetch the code dispatch

481
00:17:29,600 --> 00:17:30,960
so

482
00:17:30,960 --> 00:17:34,240
that code from before

483
00:17:34,240 --> 00:17:36,000
so it reads the next instruction from

484
00:17:36,000 --> 00:17:37,039
the

485
00:17:37,039 --> 00:17:38,640
it gets the current program counter from

486
00:17:38,640 --> 00:17:39,440
the

487
00:17:39,440 --> 00:17:41,919
processor state data structure

488
00:17:41,919 --> 00:17:43,679
which we'll discuss later

489
00:17:43,679 --> 00:17:45,440
so from the processor state data

490
00:17:45,440 --> 00:17:46,880
structure we get the current program

491
00:17:46,880 --> 00:17:49,120
counter and it loads the act next

492
00:17:49,120 --> 00:17:52,559
instruction into uh into this variable

493
00:17:52,559 --> 00:17:54,799
um the condition code which i think in

494
00:17:54,799 --> 00:17:56,559
arm is the eight most significant bits

495
00:17:56,559 --> 00:17:59,520
of the instruction for arm

496
00:17:59,520 --> 00:18:01,679
so those eight bits are checked to see

497
00:18:01,679 --> 00:18:03,039
whether the instructions should be

498
00:18:03,039 --> 00:18:05,120
executed or not

499
00:18:05,120 --> 00:18:07,360
um and once it determines that the

500
00:18:07,360 --> 00:18:09,280
current instruction should run

501
00:18:09,280 --> 00:18:12,000
it combines the bits 20 to 27 and 47 to

502
00:18:12,000 --> 00:18:15,200
form an entry index into the this

503
00:18:15,200 --> 00:18:17,039
instructure handle table

504
00:18:17,039 --> 00:18:18,799
shown on the right which is filled with

505
00:18:18,799 --> 00:18:20,080
function pointers to different

506
00:18:20,080 --> 00:18:23,120
instruction handlers

507
00:18:23,840 --> 00:18:24,960
so

508
00:18:24,960 --> 00:18:26,559
for example

509
00:18:26,559 --> 00:18:29,679
for the instruction move r0 r1 it you

510
00:18:29,679 --> 00:18:31,679
know there's a calculation and we get an

511
00:18:31,679 --> 00:18:34,400
entry index of um

512
00:18:34,400 --> 00:18:36,000
0x181

513
00:18:36,000 --> 00:18:38,880
to get the actual um byte offset

514
00:18:38,880 --> 00:18:41,679
uh each entry is for

515
00:18:41,679 --> 00:18:44,160
four bytes long so you multiply by four

516
00:18:44,160 --> 00:18:46,000
you get 0x684

517
00:18:46,000 --> 00:18:48,000
and you uh when we add it to the

518
00:18:48,000 --> 00:18:50,400
instruction table base

519
00:18:50,400 --> 00:18:54,640
um we get 0x4 bc 044

520
00:18:54,640 --> 00:18:56,720
and that looks like that

521
00:18:56,720 --> 00:18:58,960
um you can see on the left the address

522
00:18:58,960 --> 00:19:00,880
and the function pointer instruction

523
00:19:00,880 --> 00:19:02,880
move one i just

524
00:19:02,880 --> 00:19:04,640
named it that and

525
00:19:04,640 --> 00:19:07,120
on the right side you can see the

526
00:19:07,120 --> 00:19:11,280
the not entirely correct

527
00:19:12,000 --> 00:19:12,880
code

528
00:19:12,880 --> 00:19:14,960
this is assembly

529
00:19:14,960 --> 00:19:19,039
decode the compiled code i guess

530
00:19:19,039 --> 00:19:21,600
decompile yeah

531
00:19:21,600 --> 00:19:23,039
yeah you can see

532
00:19:23,039 --> 00:19:24,960
you can see on the right side that we we

533
00:19:24,960 --> 00:19:26,480
are seeing some registers being moved

534
00:19:26,480 --> 00:19:28,160
around and shifted

535
00:19:28,160 --> 00:19:29,280
um

536
00:19:29,280 --> 00:19:31,440
but the important thing is that it takes

537
00:19:31,440 --> 00:19:33,200
into every instruction handler takes in

538
00:19:33,200 --> 00:19:35,200
two parameters the first one is the

539
00:19:35,200 --> 00:19:37,120
instruction itself so the handle can

540
00:19:37,120 --> 00:19:39,039
handle a function could pull out all the

541
00:19:39,039 --> 00:19:41,679
operands up um stuff like that

542
00:19:41,679 --> 00:19:44,400
and the second argument is the pointer

543
00:19:44,400 --> 00:19:47,919
to the current processor state

544
00:19:48,160 --> 00:19:50,320
so

545
00:19:50,480 --> 00:19:52,480
the processor state struct keeps track

546
00:19:52,480 --> 00:19:54,799
of the arm processor state

547
00:19:54,799 --> 00:19:56,720
fairly simple

548
00:19:56,720 --> 00:19:58,559
mainly there is the

549
00:19:58,559 --> 00:20:00,080
registers

550
00:20:00,080 --> 00:20:02,640
which contain stuff as such as the

551
00:20:02,640 --> 00:20:04,480
program counter and the stack pointer

552
00:20:04,480 --> 00:20:06,880
and the general purpose registers

553
00:20:06,880 --> 00:20:08,159
and there is another field in the

554
00:20:08,159 --> 00:20:10,480
processor state that

555
00:20:10,480 --> 00:20:11,919
tells you whether it is currently in

556
00:20:11,919 --> 00:20:13,679
thumb mode or not

557
00:20:13,679 --> 00:20:15,120
there is many other fields in there

558
00:20:15,120 --> 00:20:16,000
which

559
00:20:16,000 --> 00:20:17,200
i couldn't really figure out what

560
00:20:17,200 --> 00:20:19,120
they're all being used for

561
00:20:19,120 --> 00:20:21,360
but once you know where the struct is

562
00:20:21,360 --> 00:20:24,240
you could kind of read and or write from

563
00:20:24,240 --> 00:20:26,720
it from both arm and x86 side because

564
00:20:26,720 --> 00:20:29,120
they have the same same

565
00:20:29,120 --> 00:20:30,320
uh

566
00:20:30,320 --> 00:20:32,080
memory view

567
00:20:32,080 --> 00:20:33,919
and they're in the same memory uh

568
00:20:33,919 --> 00:20:35,919
address space

569
00:20:35,919 --> 00:20:36,799
and

570
00:20:36,799 --> 00:20:38,000
this

571
00:20:38,000 --> 00:20:41,039
there was an issue with this where

572
00:20:41,039 --> 00:20:42,880
every time across boots and every time

573
00:20:42,880 --> 00:20:45,039
you relaunch an app or anything it would

574
00:20:45,039 --> 00:20:47,440
be at a hard-coded fixed address at that

575
00:20:47,440 --> 00:20:48,880
specific address

576
00:20:48,880 --> 00:20:51,200
they have fixed it now

577
00:20:51,200 --> 00:20:52,559
um

578
00:20:52,559 --> 00:20:55,360
but yeah that that you know is a

579
00:20:55,360 --> 00:20:56,880
problem because you could just write to

580
00:20:56,880 --> 00:20:59,760
it and change the execution state of the

581
00:20:59,760 --> 00:21:00,960
arm

582
00:21:00,960 --> 00:21:03,360
emulation

583
00:21:03,360 --> 00:21:05,919
um so next thing we took a look at was

584
00:21:05,919 --> 00:21:07,760
the syscalls

585
00:21:07,760 --> 00:21:09,280
how do they handle syscalls they're

586
00:21:09,280 --> 00:21:10,880
handled pretty much the same way going

587
00:21:10,880 --> 00:21:12,960
through the instruction handler table

588
00:21:12,960 --> 00:21:15,440
except that in the actual cisco handler

589
00:21:15,440 --> 00:21:16,400
function

590
00:21:16,400 --> 00:21:18,559
it doesn't make any it doesn't actually

591
00:21:18,559 --> 00:21:20,159
make any sense calls it just sets the

592
00:21:20,159 --> 00:21:23,440
cisco number in the processor state

593
00:21:23,440 --> 00:21:25,600
from here

594
00:21:25,600 --> 00:21:28,400
the unsigned in svc number

595
00:21:28,400 --> 00:21:30,400
it just sets that number and then

596
00:21:30,400 --> 00:21:32,480
returns and then all the syscalls are

597
00:21:32,480 --> 00:21:35,520
handled further down the execution loop

598
00:21:35,520 --> 00:21:36,880
and there is a giant function that

599
00:21:36,880 --> 00:21:38,960
performs different syscalls based on

600
00:21:38,960 --> 00:21:41,039
that value

601
00:21:41,039 --> 00:21:42,559
most of them

602
00:21:42,559 --> 00:21:43,919
are just simple wrappers or

603
00:21:43,919 --> 00:21:46,159
pass-throughs with some conversions for

604
00:21:46,159 --> 00:21:48,480
example the open syscall and that's not

605
00:21:48,480 --> 00:21:50,720
really architecture dependent so you

606
00:21:50,720 --> 00:21:52,640
might have to move around the registers

607
00:21:52,640 --> 00:21:54,559
to get in the format the

608
00:21:54,559 --> 00:21:56,080
different format

609
00:21:56,080 --> 00:21:57,039
but

610
00:21:57,039 --> 00:21:59,440
it's just a wrapper to call the actual

611
00:21:59,440 --> 00:22:01,360
open syscall but

612
00:22:01,360 --> 00:22:03,600
some other syscalls do more complicated

613
00:22:03,600 --> 00:22:04,559
things

614
00:22:04,559 --> 00:22:07,600
um specifically we were interested in

615
00:22:07,600 --> 00:22:10,000
the clone syscall

616
00:22:10,000 --> 00:22:12,559
so we want to see how fork slash clone

617
00:22:12,559 --> 00:22:13,840
was handled

618
00:22:13,840 --> 00:22:16,559
fork was included because nowadays when

619
00:22:16,559 --> 00:22:18,960
you call fork it actually uses calls the

620
00:22:18,960 --> 00:22:21,520
lipsy fork which in turn performs a

621
00:22:21,520 --> 00:22:23,760
clone syscall

622
00:22:23,760 --> 00:22:24,720
clone

623
00:22:24,720 --> 00:22:26,960
stood out it was interesting because one

624
00:22:26,960 --> 00:22:28,159
of its required

625
00:22:28,159 --> 00:22:32,480
arguments is a child stack pointer

626
00:22:32,480 --> 00:22:34,320
and that child stack pointer you you

627
00:22:34,320 --> 00:22:36,320
create you allocate some address

628
00:22:36,320 --> 00:22:38,000
and then you push

629
00:22:38,000 --> 00:22:40,080
a return address to the top of that

630
00:22:40,080 --> 00:22:42,480
stack and then you pass the pointer to

631
00:22:42,480 --> 00:22:43,679
that stack

632
00:22:43,679 --> 00:22:44,880
to clone

633
00:22:44,880 --> 00:22:47,120
and

634
00:22:47,200 --> 00:22:49,440
that new child stack will become the

635
00:22:49,440 --> 00:22:51,280
stack of the child when

636
00:22:51,280 --> 00:22:54,799
clone you know clones the process

637
00:22:54,799 --> 00:22:57,600
um and this was interesting because um

638
00:22:57,600 --> 00:22:59,600
from arm we were passing a child stack

639
00:22:59,600 --> 00:23:01,679
with the return address pointing to our

640
00:23:01,679 --> 00:23:03,039
arm code

641
00:23:03,039 --> 00:23:05,200
so we were wondering how houdini handles

642
00:23:05,200 --> 00:23:06,080
that

643
00:23:06,080 --> 00:23:08,400
um turns out houdini re-implements it it

644
00:23:08,400 --> 00:23:10,799
creates a new rwx page and passes that

645
00:23:10,799 --> 00:23:12,000
instead

646
00:23:12,000 --> 00:23:14,000
and then it handles the parent and the

647
00:23:14,000 --> 00:23:15,360
child logic

648
00:23:15,360 --> 00:23:16,559
and then

649
00:23:16,559 --> 00:23:18,240
yeah

650
00:23:18,240 --> 00:23:20,400
it got a little uh

651
00:23:20,400 --> 00:23:21,679
fuzzy

652
00:23:21,679 --> 00:23:23,360
but it just re-implements the whole

653
00:23:23,360 --> 00:23:24,799
thing

654
00:23:24,799 --> 00:23:26,000
um

655
00:23:26,000 --> 00:23:27,120
yeah right

656
00:23:27,120 --> 00:23:29,440
so now that we have some ideas on how it

657
00:23:29,440 --> 00:23:30,480
works

658
00:23:30,480 --> 00:23:31,840
internally

659
00:23:31,840 --> 00:23:34,000
let's um try to get some of the fun

660
00:23:34,000 --> 00:23:34,880
stuff

661
00:23:34,880 --> 00:23:36,880
so i was thinking like if you were an

662
00:23:36,880 --> 00:23:39,840
app or uh sure

663
00:23:40,159 --> 00:23:41,679
well are there ways you can know whether

664
00:23:41,679 --> 00:23:44,159
you're running on a real device or

665
00:23:44,159 --> 00:23:46,000
a device with lipodini

666
00:23:46,000 --> 00:23:48,080
so we're talking about detection

667
00:23:48,080 --> 00:23:50,720
we came up with a couple ways um one of

668
00:23:50,720 --> 00:23:53,279
them is

669
00:23:53,840 --> 00:23:55,760
we build an arm native app right and we

670
00:23:55,760 --> 00:23:58,320
could check the host architecture

671
00:23:58,320 --> 00:24:00,640
uh either via java's

672
00:24:00,640 --> 00:24:02,799
os arch system property or via reading

673
00:24:02,799 --> 00:24:06,720
the proxy pew info because if you if you

674
00:24:06,720 --> 00:24:10,080
built an armed native application

675
00:24:10,080 --> 00:24:12,000
but the

676
00:24:12,000 --> 00:24:13,200
and it's running

677
00:24:13,200 --> 00:24:15,200
but if it's

678
00:24:15,200 --> 00:24:16,960
its actual uh

679
00:24:16,960 --> 00:24:19,520
architecture is x86 it there's a high

680
00:24:19,520 --> 00:24:22,000
chance you're running on the laprodini

681
00:24:22,000 --> 00:24:23,840
but turns out you actually can't use

682
00:24:23,840 --> 00:24:26,080
this method because houdini hides those

683
00:24:26,080 --> 00:24:28,559
when you do a system.getpropertyos arch

684
00:24:28,559 --> 00:24:31,039
it will say rmb7l

685
00:24:31,039 --> 00:24:33,360
and when you try to read a cat proc cpu

686
00:24:33,360 --> 00:24:34,240
info

687
00:24:34,240 --> 00:24:36,720
it will say arm as well

688
00:24:36,720 --> 00:24:38,559
although you might be able to tell

689
00:24:38,559 --> 00:24:39,919
because

690
00:24:39,919 --> 00:24:41,440
those two answers came from the same

691
00:24:41,440 --> 00:24:44,159
machine uh one says rnv7l the other one

692
00:24:44,159 --> 00:24:46,880
says rnv8 ar64

693
00:24:46,880 --> 00:24:49,520
and hardware says placeholder serial

694
00:24:49,520 --> 00:24:51,039
number is zero

695
00:24:51,039 --> 00:24:52,240
uh

696
00:24:52,240 --> 00:24:53,600
yeah

697
00:24:53,600 --> 00:24:55,360
so

698
00:24:55,360 --> 00:24:58,559
next method was checking the memory map

699
00:24:58,559 --> 00:25:01,039
via reading proc self maps

700
00:25:01,039 --> 00:25:02,000
or

701
00:25:02,000 --> 00:25:04,159
seeing if both the arm

702
00:25:04,159 --> 00:25:08,799
and x86 shared libraries are loaded in

703
00:25:08,799 --> 00:25:11,200
this is a okay method but we think the

704
00:25:11,200 --> 00:25:12,799
best ways

705
00:25:12,799 --> 00:25:14,799
would be the ones that are hard to

706
00:25:14,799 --> 00:25:16,559
detect themselves

707
00:25:16,559 --> 00:25:17,840
like

708
00:25:17,840 --> 00:25:19,760
quiet detection

709
00:25:19,760 --> 00:25:21,520
so best implementation is one that

710
00:25:21,520 --> 00:25:24,159
issues no otherwise discernible syscalls

711
00:25:24,159 --> 00:25:25,919
and

712
00:25:25,919 --> 00:25:28,640
the method we came up with was using the

713
00:25:28,640 --> 00:25:31,520
jnim magic pointer detection

714
00:25:31,520 --> 00:25:33,600
um

715
00:25:33,600 --> 00:25:36,159
right so if you're on a real device

716
00:25:36,159 --> 00:25:39,039
uh when we get the jnim function pointer

717
00:25:39,039 --> 00:25:40,720
those function pointers would contain

718
00:25:40,720 --> 00:25:43,600
real arm instructions

719
00:25:43,600 --> 00:25:46,000
but on their lapudini those function

720
00:25:46,000 --> 00:25:47,520
pointers would be just cisco

721
00:25:47,520 --> 00:25:50,080
instructions

722
00:25:50,480 --> 00:25:52,400
and that may be one of the ways you

723
00:25:52,400 --> 00:25:54,080
could tell whether you're running inside

724
00:25:54,080 --> 00:25:56,640
the podini or not

725
00:25:56,640 --> 00:25:58,960
the second thing we could talk about is

726
00:25:58,960 --> 00:26:01,679
possibly escaping to x86 now your

727
00:26:01,679 --> 00:26:03,039
application

728
00:26:03,039 --> 00:26:05,200
doesn't know

729
00:26:05,200 --> 00:26:06,799
or your native application thinks it's

730
00:26:06,799 --> 00:26:09,120
running an arm

731
00:26:09,120 --> 00:26:10,960
now whether you're running on a real arm

732
00:26:10,960 --> 00:26:14,320
device or x86 device with arm

733
00:26:14,320 --> 00:26:15,919
uh with lipodini

734
00:26:15,919 --> 00:26:17,840
um you could tell using the detection

735
00:26:17,840 --> 00:26:19,760
method but once we detect that we're

736
00:26:19,760 --> 00:26:21,279
like um

737
00:26:21,279 --> 00:26:22,799
once we detect that we're running inside

738
00:26:22,799 --> 00:26:26,960
of houdini can we escape to x86

739
00:26:26,960 --> 00:26:28,960
of course there's you know we we're

740
00:26:28,960 --> 00:26:30,720
running our code so we could always just

741
00:26:30,720 --> 00:26:33,279
call like and protect and overwrite code

742
00:26:33,279 --> 00:26:34,880
to memory

743
00:26:34,880 --> 00:26:36,880
but again this isn't very subtle

744
00:26:36,880 --> 00:26:39,360
and also like any decent analysis tool

745
00:26:39,360 --> 00:26:41,679
would probably flag us immediately

746
00:26:41,679 --> 00:26:42,720
um

747
00:26:42,720 --> 00:26:43,919
so the

748
00:26:43,919 --> 00:26:45,919
uh we could also figure out trying to

749
00:26:45,919 --> 00:26:48,080
find where the x86 stack is so we could

750
00:26:48,080 --> 00:26:50,240
collaborate the stack with raw payloads

751
00:26:50,240 --> 00:26:53,679
and have it jump to somewhere

752
00:26:53,679 --> 00:26:56,159
but that's also a lot more annoying

753
00:26:56,159 --> 00:26:57,600
and

754
00:26:57,600 --> 00:26:58,880
you know i'm just going to say it there

755
00:26:58,880 --> 00:27:01,600
there's just a bunch of rwx pages laying

756
00:27:01,600 --> 00:27:03,120
around

757
00:27:03,120 --> 00:27:05,279
which you could just write code to and

758
00:27:05,279 --> 00:27:06,640
jump to

759
00:27:06,640 --> 00:27:08,880
you could write x86 instruction to them

760
00:27:08,880 --> 00:27:10,640
and then

761
00:27:10,640 --> 00:27:11,840
jump to it well you won't be able to

762
00:27:11,840 --> 00:27:15,918
jump here from from the arm side

763
00:27:18,240 --> 00:27:20,399
so just to point out what some of these

764
00:27:20,399 --> 00:27:24,080
pages are used for um

765
00:27:24,080 --> 00:27:27,840
that's that's where the jnim uh

766
00:27:27,840 --> 00:27:29,440
structure lives

767
00:27:29,440 --> 00:27:32,080
uh that's where the arm stack is

768
00:27:32,080 --> 00:27:33,039
you know

769
00:27:33,039 --> 00:27:34,640
um but yeah

770
00:27:34,640 --> 00:27:37,039
there is are the rx pages in on the x86

771
00:27:37,039 --> 00:27:39,760
side which there shouldn't be

772
00:27:39,760 --> 00:27:40,640
um

773
00:27:40,640 --> 00:27:42,799
so what about getting like

774
00:27:42,799 --> 00:27:44,720
like side channel code execution on arm

775
00:27:44,720 --> 00:27:45,600
side

776
00:27:45,600 --> 00:27:47,279
um

777
00:27:47,279 --> 00:27:50,000
turns out the nx bit

778
00:27:50,000 --> 00:27:53,520
is ignored entirely by houdini

779
00:27:53,520 --> 00:27:55,600
not that this behavior is correct but if

780
00:27:55,600 --> 00:27:56,720
you think about it it kind of makes

781
00:27:56,720 --> 00:27:57,919
sense

782
00:27:57,919 --> 00:27:59,760
houdini is an interpreter for arm

783
00:27:59,760 --> 00:28:01,600
instruction

784
00:28:01,600 --> 00:28:03,840
and the arm up codes are data now if

785
00:28:03,840 --> 00:28:07,520
houdini could read it it will run it

786
00:28:08,000 --> 00:28:09,760
so this means you could just write code

787
00:28:09,760 --> 00:28:13,039
anywhere and jump to it

788
00:28:13,200 --> 00:28:14,399
don't think i need to say much more

789
00:28:14,399 --> 00:28:16,559
about it and to to show you i have this

790
00:28:16,559 --> 00:28:18,320
little program

791
00:28:18,320 --> 00:28:19,919
uh

792
00:28:19,919 --> 00:28:21,919
right um i just

793
00:28:21,919 --> 00:28:23,600
allocate some

794
00:28:23,600 --> 00:28:26,799
memory on the buffer code 512 initialize

795
00:28:26,799 --> 00:28:28,880
it with zero i write two things in there

796
00:28:28,880 --> 00:28:30,799
they're um

797
00:28:30,799 --> 00:28:33,120
their arm instructions for adding one

798
00:28:33,120 --> 00:28:34,880
and then returning

799
00:28:34,880 --> 00:28:37,679
and i cast through a function and i

800
00:28:37,679 --> 00:28:38,720
called him

801
00:28:38,720 --> 00:28:39,679
normally

802
00:28:39,679 --> 00:28:41,840
that on a real hardware would cause a

803
00:28:41,840 --> 00:28:43,200
seg fault

804
00:28:43,200 --> 00:28:44,960
jumping on like

805
00:28:44,960 --> 00:28:46,640
jumping to stack

806
00:28:46,640 --> 00:28:49,760
but here we see that it just ran fine

807
00:28:49,760 --> 00:28:52,960
this is also on the chromebook

808
00:28:53,919 --> 00:28:55,279
actually the first iteration of this

809
00:28:55,279 --> 00:28:59,120
code i actually had the uh

810
00:28:59,120 --> 00:29:01,679
int code buffer outside of the main so

811
00:29:01,679 --> 00:29:04,240
it wasn't like

812
00:29:04,240 --> 00:29:08,240
not on the stack and that also ran fine

813
00:29:11,200 --> 00:29:13,520
demos i i'm not sure if i'll have time

814
00:29:13,520 --> 00:29:14,799
for demos

815
00:29:14,799 --> 00:29:17,440
um but let's talk about

816
00:29:17,440 --> 00:29:19,360
if you're a malware you

817
00:29:19,360 --> 00:29:21,120
don't wanna

818
00:29:21,120 --> 00:29:23,360
you wanna avoid detection

819
00:29:23,360 --> 00:29:24,840
and

820
00:29:24,840 --> 00:29:27,279
analysis and to

821
00:29:27,279 --> 00:29:29,200
do that one way would be to just hide

822
00:29:29,200 --> 00:29:31,360
yourself when you know when you think

823
00:29:31,360 --> 00:29:32,399
you're being

824
00:29:32,399 --> 00:29:34,640
you're under analysis

825
00:29:34,640 --> 00:29:36,399
um and

826
00:29:36,399 --> 00:29:37,919
you know we know that applications are

827
00:29:37,919 --> 00:29:39,600
often run in sandbox environments for

828
00:29:39,600 --> 00:29:41,120
analysis

829
00:29:41,120 --> 00:29:42,559
this is done in

830
00:29:42,559 --> 00:29:44,799
this is mainly done in one of three ways

831
00:29:44,799 --> 00:29:46,559
the first of which is running them on

832
00:29:46,559 --> 00:29:48,240
actual devices

833
00:29:48,240 --> 00:29:50,480
which

834
00:29:51,039 --> 00:29:52,399
this will give the most realistic

835
00:29:52,399 --> 00:29:54,720
behaviors but it's also hard to do on a

836
00:29:54,720 --> 00:29:56,640
large scale and also often very hard to

837
00:29:56,640 --> 00:29:58,320
instrument

838
00:29:58,320 --> 00:30:00,159
the next option is fully virtualized

839
00:30:00,159 --> 00:30:01,919
environments like camu

840
00:30:01,919 --> 00:30:03,679
but these also have somewhat of a

841
00:30:03,679 --> 00:30:05,120
performance overhead since they will be

842
00:30:05,120 --> 00:30:08,320
emulating the entire hardware

843
00:30:08,320 --> 00:30:11,120
and that brings us to our third option

844
00:30:11,120 --> 00:30:13,840
android emulators which runs x86 android

845
00:30:13,840 --> 00:30:16,080
but uses technology like houdini to run

846
00:30:16,080 --> 00:30:17,919
arm application

847
00:30:17,919 --> 00:30:19,520
this has the least overhead as it would

848
00:30:19,520 --> 00:30:22,640
only emulate parts of the applications

849
00:30:22,640 --> 00:30:24,720
so

850
00:30:24,720 --> 00:30:26,159
a malware

851
00:30:26,159 --> 00:30:27,760
could

852
00:30:27,760 --> 00:30:29,520
use one of the detection methods that we

853
00:30:29,520 --> 00:30:31,520
mentioned earlier to figure out whether

854
00:30:31,520 --> 00:30:32,640
it's running

855
00:30:32,640 --> 00:30:34,799
with or without houdini

856
00:30:34,799 --> 00:30:36,080
then it might be possible for the

857
00:30:36,080 --> 00:30:37,840
malware to act benevolently when it

858
00:30:37,840 --> 00:30:40,159
thinks it's under analysis and then show

859
00:30:40,159 --> 00:30:42,240
malicious behaviors when liprodini is

860
00:30:42,240 --> 00:30:44,960
not present

861
00:30:45,039 --> 00:30:46,000
right

862
00:30:46,000 --> 00:30:48,240
what about the other way around

863
00:30:48,240 --> 00:30:50,640
we could also prefer malicious actions

864
00:30:50,640 --> 00:30:53,919
only only when houdini is present

865
00:30:53,919 --> 00:30:55,760
abusing the knowledge of its internals

866
00:30:55,760 --> 00:30:57,760
to further obfuscate itself

867
00:30:57,760 --> 00:30:59,200
um

868
00:30:59,200 --> 00:31:01,279
right let's say we could overwrite the

869
00:31:01,279 --> 00:31:02,840
processor state

870
00:31:02,840 --> 00:31:04,559
to

871
00:31:04,559 --> 00:31:06,320
do some things that the

872
00:31:06,320 --> 00:31:07,840
analysis tool

873
00:31:07,840 --> 00:31:09,360
doesn't

874
00:31:09,360 --> 00:31:12,959
know how to understand

875
00:31:13,840 --> 00:31:16,080
well given all that malware talk

876
00:31:16,080 --> 00:31:18,480
our recommendations to uh

877
00:31:18,480 --> 00:31:21,760
vendors and platforms um

878
00:31:21,760 --> 00:31:24,159
and how to not write an emulator so

879
00:31:24,159 --> 00:31:25,679
firstly we should not map things to

880
00:31:25,679 --> 00:31:27,600
deterministic addresses especially

881
00:31:27,600 --> 00:31:28,799
important data structures like the

882
00:31:28,799 --> 00:31:30,720
processor stay struck

883
00:31:30,720 --> 00:31:33,679
which has been fixed by intel

884
00:31:33,679 --> 00:31:35,039
um

885
00:31:35,039 --> 00:31:37,440
the second recommendation is drop the

886
00:31:37,440 --> 00:31:39,919
unnecessary rwx pages

887
00:31:39,919 --> 00:31:41,840
if you really need them

888
00:31:41,840 --> 00:31:44,480
perform a better uh perform fine grain

889
00:31:44,480 --> 00:31:46,880
page computer control and this kind of

890
00:31:46,880 --> 00:31:50,159
leads to the next one

891
00:31:50,480 --> 00:31:52,399
we could implement

892
00:31:52,399 --> 00:31:55,120
so on the houdini side houdini ignored

893
00:31:55,120 --> 00:31:56,720
the nx bit

894
00:31:56,720 --> 00:31:58,720
don't do that would be my security

895
00:31:58,720 --> 00:32:02,559
advice do not ignore the nx bid which

896
00:32:02,559 --> 00:32:04,399
tells you whether you can execute or not

897
00:32:04,399 --> 00:32:07,200
execute in this memory

898
00:32:07,200 --> 00:32:09,039
so we understand checking page

899
00:32:09,039 --> 00:32:11,039
permission every instruction

900
00:32:11,039 --> 00:32:12,880
would incur significant overhead so

901
00:32:12,880 --> 00:32:14,240
instead we just keep track of the

902
00:32:14,240 --> 00:32:16,480
mappings and permissions in process kind

903
00:32:16,480 --> 00:32:18,880
of like page tables

904
00:32:18,880 --> 00:32:20,320
and only perform checks if an

905
00:32:20,320 --> 00:32:23,200
instruction is

906
00:32:23,200 --> 00:32:25,519
you know going across the page boundary

907
00:32:25,519 --> 00:32:27,760
or jumping somewhere

908
00:32:27,760 --> 00:32:28,960
which would

909
00:32:28,960 --> 00:32:31,679
reduce the uh performance overhead

910
00:32:31,679 --> 00:32:32,559
um

911
00:32:32,559 --> 00:32:34,480
but actually because you're basically

912
00:32:34,480 --> 00:32:35,600
taking a

913
00:32:35,600 --> 00:32:37,679
building a user line page table you use

914
00:32:37,679 --> 00:32:40,000
virtualization um which is our

915
00:32:40,000 --> 00:32:44,480
recommendation which would solve well

916
00:32:44,480 --> 00:32:47,519
yeah use virtualization and

917
00:32:47,519 --> 00:32:50,000
use aslr to protect sensitive data

918
00:32:50,000 --> 00:32:51,600
structures

919
00:32:51,600 --> 00:32:55,039
um so speaking of the ezram page table

920
00:32:55,039 --> 00:32:57,200
this is some of the ways we think

921
00:32:57,200 --> 00:32:58,720
can be done

922
00:32:58,720 --> 00:33:02,080
trust only the text sections unload and

923
00:33:02,080 --> 00:33:03,919
check

924
00:33:03,919 --> 00:33:06,880
the page mappings

925
00:33:07,200 --> 00:33:09,600
every time a new page has been added

926
00:33:09,600 --> 00:33:13,439
or we could just um

927
00:33:14,640 --> 00:33:16,159
you know

928
00:33:16,159 --> 00:33:19,200
a libradini has hooks for all the

929
00:33:19,200 --> 00:33:22,080
syscalls so instrument those memory

930
00:33:22,080 --> 00:33:23,840
mapping related syscalls to track page

931
00:33:23,840 --> 00:33:26,159
permissions

932
00:33:26,159 --> 00:33:28,080
and actually the ideal solution combines

933
00:33:28,080 --> 00:33:30,720
two and three with the checking the proc

934
00:33:30,720 --> 00:33:33,279
self maps for as a catch-all and this

935
00:33:33,279 --> 00:33:36,080
would actually enable dynamic

936
00:33:36,080 --> 00:33:38,640
loading via open and it will support

937
00:33:38,640 --> 00:33:40,799
legitimate jet ting

938
00:33:40,799 --> 00:33:42,480
um and

939
00:33:42,480 --> 00:33:45,279
making sure to remove the pages uh when

940
00:33:45,279 --> 00:33:46,320
jet is

941
00:33:46,320 --> 00:33:47,600
finished

942
00:33:47,600 --> 00:33:49,360
um

943
00:33:49,360 --> 00:33:51,679
right and of course this data structure

944
00:33:51,679 --> 00:33:53,120
uh should be

945
00:33:53,120 --> 00:33:55,039
heavily protected

946
00:33:55,039 --> 00:33:56,320
um

947
00:33:56,320 --> 00:33:57,600
writable only when being updated

948
00:33:57,600 --> 00:33:58,880
surrounded by guard pages and not

949
00:33:58,880 --> 00:34:01,519
accessible to arm etc

950
00:34:01,519 --> 00:34:04,399
and for uh people doing analysis on

951
00:34:04,399 --> 00:34:07,519
applications um you should also run

952
00:34:07,519 --> 00:34:09,839
these apps through les paudini and

953
00:34:09,839 --> 00:34:11,599
dynamic analysis

954
00:34:11,599 --> 00:34:12,879
instead of just trying out random

955
00:34:12,879 --> 00:34:14,800
hardware or

956
00:34:14,800 --> 00:34:16,560
on a vm

957
00:34:16,560 --> 00:34:18,079
or like a

958
00:34:18,079 --> 00:34:21,119
full camera environment uh

959
00:34:21,119 --> 00:34:23,199
you should also do a static analysis to

960
00:34:23,199 --> 00:34:24,800
look for access to

961
00:34:24,800 --> 00:34:27,040
weird houdini read write execute pages

962
00:34:27,040 --> 00:34:29,040
or any attempt to execute from

963
00:34:29,040 --> 00:34:31,679
non-executable pages because houdini

964
00:34:31,679 --> 00:34:34,560
allows that allowed this

965
00:34:34,560 --> 00:34:36,639
and also because of our

966
00:34:36,639 --> 00:34:39,040
jnim detection method

967
00:34:39,040 --> 00:34:40,719
uh

968
00:34:40,719 --> 00:34:41,839
you should also look for anything

969
00:34:41,839 --> 00:34:45,280
scanning the jnim function pointers

970
00:34:45,280 --> 00:34:46,159
so

971
00:34:46,159 --> 00:34:48,159
this brings us to our conclusion uh

972
00:34:48,159 --> 00:34:49,520
houdini introduces number security

973
00:34:49,520 --> 00:34:53,119
weaknesses into process using it um they

974
00:34:53,119 --> 00:34:55,839
weaken both the security of the arm and

975
00:34:55,839 --> 00:34:58,480
the x86 code

976
00:34:58,480 --> 00:34:59,599
and

977
00:34:59,599 --> 00:35:01,200
i think that

978
00:35:01,200 --> 00:35:03,359
the fact that this houdini is not well

979
00:35:03,359 --> 00:35:05,119
documented publicly nor easily

980
00:35:05,119 --> 00:35:06,320
accessible

981
00:35:06,320 --> 00:35:07,920
has something to do with

982
00:35:07,920 --> 00:35:09,920
these ish

983
00:35:09,920 --> 00:35:11,839
these issues which could have been found

984
00:35:11,839 --> 00:35:12,960
earlier

985
00:35:12,960 --> 00:35:14,839
through

986
00:35:14,839 --> 00:35:17,440
research and this is our disclosure

987
00:35:17,440 --> 00:35:20,800
timeline uh we

988
00:35:20,800 --> 00:35:22,800
uh sent the first set of findings to

989
00:35:22,800 --> 00:35:24,640
intel they probably um

990
00:35:24,640 --> 00:35:27,040
acknowledged it and fixed it provided us

991
00:35:27,040 --> 00:35:28,400
an update

992
00:35:28,400 --> 00:35:30,880
and for the seconds we we also provide

993
00:35:30,880 --> 00:35:33,839
them a second set of findings and

994
00:35:33,839 --> 00:35:36,720
they were happy to let us know that the

995
00:35:36,720 --> 00:35:39,359
new version is now available

996
00:35:39,359 --> 00:35:40,880
if you're an oem

997
00:35:40,880 --> 00:35:42,960
you can find patches

998
00:35:42,960 --> 00:35:45,599
new versions of these

999
00:35:45,599 --> 00:35:46,880
i guess

1000
00:35:46,880 --> 00:35:49,280
and a big special thanks to jeff

1001
00:35:49,280 --> 00:35:51,280
uh for mentoring and helping develop the

1002
00:35:51,280 --> 00:35:53,280
methodology jennifer being all the

1003
00:35:53,280 --> 00:35:55,040
support and research and like amazing

1004
00:35:55,040 --> 00:35:56,800
feedback and

1005
00:35:56,800 --> 00:35:58,640
effie for basically bootstrapping this

1006
00:35:58,640 --> 00:36:01,040
research and with that uh thanks

1007
00:36:01,040 --> 00:36:02,960
everyone for joining and i think we are

1008
00:36:02,960 --> 00:36:06,920
at q a right

