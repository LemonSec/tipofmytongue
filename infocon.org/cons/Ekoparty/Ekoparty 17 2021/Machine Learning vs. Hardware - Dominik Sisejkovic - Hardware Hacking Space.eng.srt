1
00:00:00,240 --> 00:00:02,080
hello everyone my name is dominic

2
00:00:02,080 --> 00:00:03,520
shishaikovic and i'm a research

3
00:00:03,520 --> 00:00:05,200
assistant and chief engineer at the

4
00:00:05,200 --> 00:00:06,560
chair for software for systems on

5
00:00:06,560 --> 00:00:09,519
silicon at the rwth ahmed university in

6
00:00:09,519 --> 00:00:11,440
germany and i'm happy to tell you today

7
00:00:11,440 --> 00:00:14,080
a little bit about the topic of machine

8
00:00:14,080 --> 00:00:15,440
learning versus hardware integrity

9
00:00:15,440 --> 00:00:17,920
protection who will prevail so let's

10
00:00:17,920 --> 00:00:19,600
start with the motivation

11
00:00:19,600 --> 00:00:21,600
as you might already know nowadays the

12
00:00:21,600 --> 00:00:23,519
integrated circuit supply chain has a

13
00:00:23,519 --> 00:00:25,519
very globalized nature

14
00:00:25,519 --> 00:00:27,199
which means that many different third

15
00:00:27,199 --> 00:00:29,199
parties are actually involved in both

16
00:00:29,199 --> 00:00:31,359
the design and fabrication steps of

17
00:00:31,359 --> 00:00:33,920
actual hardware this has unfortunately

18
00:00:33,920 --> 00:00:34,960
led

19
00:00:34,960 --> 00:00:37,360
to a loss of trust and assurance between

20
00:00:37,360 --> 00:00:40,079
the involved parties and of course this

21
00:00:40,079 --> 00:00:41,680
has then resulted

22
00:00:41,680 --> 00:00:43,920
in potential security issues one of

23
00:00:43,920 --> 00:00:46,480
which is a very serious one that we know

24
00:00:46,480 --> 00:00:48,559
as hardware trojans so what are hardware

25
00:00:48,559 --> 00:00:50,559
trojans hydrotrojans can basically be

26
00:00:50,559 --> 00:00:52,800
defined as malicious design

27
00:00:52,800 --> 00:00:54,879
modifications which are injected into

28
00:00:54,879 --> 00:00:56,480
the hardware during design or

29
00:00:56,480 --> 00:00:58,480
fabrication steps

30
00:00:58,480 --> 00:01:01,520
and these malicious design modifications

31
00:01:01,520 --> 00:01:03,760
can actually lead to rise attack vectors

32
00:01:03,760 --> 00:01:06,240
typically we consider attacks such as

33
00:01:06,240 --> 00:01:07,920
information leakage or performance

34
00:01:07,920 --> 00:01:10,960
degradation or for example also a denial

35
00:01:10,960 --> 00:01:12,479
of service attack

36
00:01:12,479 --> 00:01:14,880
obviously if we place hardware trojans

37
00:01:14,880 --> 00:01:17,040
into the right scenario they can

38
00:01:17,040 --> 00:01:18,880
actually lead to very very dangerous

39
00:01:18,880 --> 00:01:21,200
situations for example you could imagine

40
00:01:21,200 --> 00:01:23,280
a denial of service attack hardware

41
00:01:23,280 --> 00:01:25,840
trojan which is placed deeply within a

42
00:01:25,840 --> 00:01:28,000
processor design which is a common

43
00:01:28,000 --> 00:01:30,159
component in many different many

44
00:01:30,159 --> 00:01:31,520
different

45
00:01:31,520 --> 00:01:32,799
modern uh

46
00:01:32,799 --> 00:01:34,720
vehicles and obviously in

47
00:01:34,720 --> 00:01:36,400
a moving vehicle a denial of service

48
00:01:36,400 --> 00:01:38,720
attack can actually result in a

49
00:01:38,720 --> 00:01:40,240
dangerous

50
00:01:40,240 --> 00:01:42,079
dangerous consequences

51
00:01:42,079 --> 00:01:44,079
so the very important question today

52
00:01:44,079 --> 00:01:46,240
that we have is how can we actually deal

53
00:01:46,240 --> 00:01:48,320
with hardware trojans well one way to

54
00:01:48,320 --> 00:01:50,479
deal with hardware trojans is to try to

55
00:01:50,479 --> 00:01:51,840
detect them

56
00:01:51,840 --> 00:01:53,840
however as it turns out detecting

57
00:01:53,840 --> 00:01:55,840
hardware trojans is in principle very

58
00:01:55,840 --> 00:01:59,200
very difficult because it is very uh

59
00:01:59,200 --> 00:02:01,280
complex it's a complex task to actually

60
00:02:01,280 --> 00:02:03,600
come up with a detection method that is

61
00:02:03,600 --> 00:02:06,880
able to efficiently detect all kinds of

62
00:02:06,880 --> 00:02:09,758
hardware trojans or many design levels

63
00:02:09,758 --> 00:02:11,920
hence detection at this point in time is

64
00:02:11,920 --> 00:02:13,200
still

65
00:02:13,200 --> 00:02:14,560
developing and it's still very

66
00:02:14,560 --> 00:02:17,760
inefficient so the second option to deal

67
00:02:17,760 --> 00:02:19,840
with hardware trojans is actually to try

68
00:02:19,840 --> 00:02:22,160
to prevent them by design and that is

69
00:02:22,160 --> 00:02:23,840
also something that i've been working on

70
00:02:23,840 --> 00:02:25,920
in the last couple of years

71
00:02:25,920 --> 00:02:28,239
and actually a lot of

72
00:02:28,239 --> 00:02:29,760
research has been done

73
00:02:29,760 --> 00:02:32,319
for more than a decade to develop

74
00:02:32,319 --> 00:02:34,160
different techniques to prevent hardware

75
00:02:34,160 --> 00:02:38,720
trojan insertion among other objectives

76
00:02:38,720 --> 00:02:41,120
so let's take a quick look at

77
00:02:41,120 --> 00:02:42,160
the

78
00:02:42,160 --> 00:02:44,160
untrusted integrated circuit supply

79
00:02:44,160 --> 00:02:46,480
chain to understand a little bit better

80
00:02:46,480 --> 00:02:48,720
where things could potentially go wrong

81
00:02:48,720 --> 00:02:51,440
so here you can see a very abstract view

82
00:02:51,440 --> 00:02:53,680
of the ic supply chain at the beginning

83
00:02:53,680 --> 00:02:57,599
of course we have some specification

84
00:02:57,599 --> 00:03:00,000
of the developed of the to be developed

85
00:03:00,000 --> 00:03:01,280
hardware

86
00:03:01,280 --> 00:03:03,440
and based on this specification uh given

87
00:03:03,440 --> 00:03:06,480
rtl design is compiled this rtl design

88
00:03:06,480 --> 00:03:08,400
then goes through different steps which

89
00:03:08,400 --> 00:03:11,120
includes logic synthesis and physical

90
00:03:11,120 --> 00:03:14,400
design steps afterwards the designed

91
00:03:14,400 --> 00:03:16,959
chip ends up being transferred to the

92
00:03:16,959 --> 00:03:19,120
fabrication where it's put into silicon

93
00:03:19,120 --> 00:03:21,280
and the silicon chip is afterwards

94
00:03:21,280 --> 00:03:24,080
packaged and assembled and finally

95
00:03:24,080 --> 00:03:25,360
distributed

96
00:03:25,360 --> 00:03:27,599
and integrated in many different

97
00:03:27,599 --> 00:03:29,840
devices

98
00:03:29,840 --> 00:03:32,319
so this particular ic supply chain

99
00:03:32,319 --> 00:03:34,319
typically what we consider as the window

100
00:03:34,319 --> 00:03:35,920
of vulnerability where things could

101
00:03:35,920 --> 00:03:37,920
potentially go wrong is

102
00:03:37,920 --> 00:03:39,840
the following one so the red box here

103
00:03:39,840 --> 00:03:41,840
shown on the slide

104
00:03:41,840 --> 00:03:42,959
where

105
00:03:42,959 --> 00:03:45,599
which includes the physical design and

106
00:03:45,599 --> 00:03:47,360
the fabrication so why the physical

107
00:03:47,360 --> 00:03:49,680
design and the fabrication

108
00:03:49,680 --> 00:03:50,560
well

109
00:03:50,560 --> 00:03:52,400
as i mentioned at the beginning we

110
00:03:52,400 --> 00:03:54,720
always considered third parties as

111
00:03:54,720 --> 00:03:56,720
untrusted entities so entities which

112
00:03:56,720 --> 00:03:58,159
could potentially

113
00:03:58,159 --> 00:04:00,799
change the design and as it turns out

114
00:04:00,799 --> 00:04:02,879
most protection mechanisms that we know

115
00:04:02,879 --> 00:04:05,920
of today actually perform or execute are

116
00:04:05,920 --> 00:04:08,319
executed on the gate level so which

117
00:04:08,319 --> 00:04:10,159
means that everything after this gate

118
00:04:10,159 --> 00:04:12,959
level could potentially be protected but

119
00:04:12,959 --> 00:04:15,840
not before hence

120
00:04:15,840 --> 00:04:18,160
in in many different scenarios many

121
00:04:18,160 --> 00:04:19,918
different companies especially those

122
00:04:19,918 --> 00:04:21,358
which don't really have so much

123
00:04:21,358 --> 00:04:23,360
experience so much knowledge to perform

124
00:04:23,360 --> 00:04:25,360
for example physical design have to

125
00:04:25,360 --> 00:04:28,720
outsource outsource this step uh to an

126
00:04:28,720 --> 00:04:30,960
external design house and as i say as i

127
00:04:30,960 --> 00:04:33,680
say external that basically means uh it

128
00:04:33,680 --> 00:04:37,520
could be an untrusted uh entity

129
00:04:37,520 --> 00:04:39,280
okay so if you consider the physical

130
00:04:39,280 --> 00:04:42,320
design and the fabrication these are our

131
00:04:42,320 --> 00:04:44,320
malicious entities and in the rest of

132
00:04:44,320 --> 00:04:46,560
the slides when i say malicious entity

133
00:04:46,560 --> 00:04:48,320
it could be any of these

134
00:04:48,320 --> 00:04:50,639
two within this one a window of

135
00:04:50,639 --> 00:04:52,960
vulnerability and that is exactly the

136
00:04:52,960 --> 00:04:54,800
place where a hardware trojan could

137
00:04:54,800 --> 00:04:57,440
potentially be injected

138
00:04:57,440 --> 00:04:58,800
okay so

139
00:04:58,800 --> 00:05:01,039
now we've learned where things could go

140
00:05:01,039 --> 00:05:03,360
wrong in this integrated circuit supply

141
00:05:03,360 --> 00:05:05,360
chain so let's take a look at what kind

142
00:05:05,360 --> 00:05:07,280
of hardware trojans we could actually

143
00:05:07,280 --> 00:05:10,560
potentially protect against

144
00:05:10,560 --> 00:05:12,400
so in principle there are two types of

145
00:05:12,400 --> 00:05:14,000
hardware options and here on the slide

146
00:05:14,000 --> 00:05:16,000
we will consider a very very simple

147
00:05:16,000 --> 00:05:17,039
example

148
00:05:17,039 --> 00:05:19,600
so when the malicious entity becomes

149
00:05:19,600 --> 00:05:21,759
receives our design so it's at the

150
00:05:21,759 --> 00:05:23,280
beginning it's basically an unknown

151
00:05:23,280 --> 00:05:26,000
design so there is no reason for us for

152
00:05:26,000 --> 00:05:27,600
the original designer to tell the

153
00:05:27,600 --> 00:05:30,080
external design house or the foundry

154
00:05:30,080 --> 00:05:32,800
what the chip is used for right that's

155
00:05:32,800 --> 00:05:35,280
not really important for the fabrication

156
00:05:35,280 --> 00:05:36,479
step

157
00:05:36,479 --> 00:05:37,680
um so the

158
00:05:37,680 --> 00:05:38,960
so the malicious entity actually

159
00:05:38,960 --> 00:05:41,360
receives an unknown design and this

160
00:05:41,360 --> 00:05:43,120
unknown design

161
00:05:43,120 --> 00:05:46,080
uh can be in principle infected by

162
00:05:46,080 --> 00:05:48,080
hardware trojan without any need to

163
00:05:48,080 --> 00:05:50,160
perform reverse engineering and reverse

164
00:05:50,160 --> 00:05:52,320
engineering in the sense means that the

165
00:05:52,320 --> 00:05:54,639
attacker doesn't have to understand the

166
00:05:54,639 --> 00:05:56,479
functionality understand the structure

167
00:05:56,479 --> 00:05:58,720
or even the use case of this hardware

168
00:05:58,720 --> 00:06:00,720
that is going to be produced

169
00:06:00,720 --> 00:06:02,639
and in this design

170
00:06:02,639 --> 00:06:04,960
independent scenario the trojan which is

171
00:06:04,960 --> 00:06:06,400
design independent

172
00:06:06,400 --> 00:06:09,120
can be very easily injected so here you

173
00:06:09,120 --> 00:06:11,360
see a small example of a

174
00:06:11,360 --> 00:06:12,720
hardware trojan

175
00:06:12,720 --> 00:06:16,000
with the typical components of

176
00:06:16,000 --> 00:06:18,080
of trojans that we know of

177
00:06:18,080 --> 00:06:19,520
so typically there are two components of

178
00:06:19,520 --> 00:06:21,680
a hydrotrojan one is the trigger

179
00:06:21,680 --> 00:06:23,759
and one is the payload the trigger

180
00:06:23,759 --> 00:06:26,400
basically is a component

181
00:06:26,400 --> 00:06:28,880
which listens to some signals or to some

182
00:06:28,880 --> 00:06:32,720
state in the circuit and once it detects

183
00:06:32,720 --> 00:06:34,880
the activation sequence it actually

184
00:06:34,880 --> 00:06:36,240
tells

185
00:06:36,240 --> 00:06:38,639
the the payload to

186
00:06:38,639 --> 00:06:40,800
execute the malicious functionality so

187
00:06:40,800 --> 00:06:43,199
the payload then actually performs some

188
00:06:43,199 --> 00:06:45,360
change in the circuit which can result

189
00:06:45,360 --> 00:06:47,600
in the rise attack vectors

190
00:06:47,600 --> 00:06:50,000
however in this um scenario where we

191
00:06:50,000 --> 00:06:52,160
consider that the malicious entity does

192
00:06:52,160 --> 00:06:54,400
not have to perform any kind of reverse

193
00:06:54,400 --> 00:06:55,599
engineering

194
00:06:55,599 --> 00:06:56,479
this

195
00:06:56,479 --> 00:06:59,039
trojan can be implanted basically like a

196
00:06:59,039 --> 00:07:01,919
random fault so you can just pick any

197
00:07:01,919 --> 00:07:03,919
location in the circuit insert any form

198
00:07:03,919 --> 00:07:06,080
of hardware trojan and kind of hope for

199
00:07:06,080 --> 00:07:07,919
the for the best or basically hope for

200
00:07:07,919 --> 00:07:10,000
the worst in terms of the attacker

201
00:07:10,000 --> 00:07:12,400
however this will uh probably result in

202
00:07:12,400 --> 00:07:14,560
an unknown attack in an unknown

203
00:07:14,560 --> 00:07:16,400
environment so the impact of such a

204
00:07:16,400 --> 00:07:18,880
hardware trojan will probably probably

205
00:07:18,880 --> 00:07:20,720
be not

206
00:07:20,720 --> 00:07:22,880
not as high and the probability that we

207
00:07:22,880 --> 00:07:26,560
will detect such a fault is uh is in in

208
00:07:26,560 --> 00:07:29,039
turn increased because it might lead to

209
00:07:29,039 --> 00:07:32,800
a very very obvious fault

210
00:07:32,800 --> 00:07:34,960
and unfortunately these hardware trojans

211
00:07:34,960 --> 00:07:36,800
are in principle something we cannot

212
00:07:36,800 --> 00:07:38,720
protect against because they can always

213
00:07:38,720 --> 00:07:41,199
be injected into the design since no

214
00:07:41,199 --> 00:07:43,520
real effort is required by the malicious

215
00:07:43,520 --> 00:07:44,400
entity

216
00:07:44,400 --> 00:07:46,000
so the second type of hardware trojan

217
00:07:46,000 --> 00:07:47,919
that we actually consider protecting

218
00:07:47,919 --> 00:07:50,160
against are design dependent hardware

219
00:07:50,160 --> 00:07:52,000
trojans so these are hardware trojans

220
00:07:52,000 --> 00:07:53,759
where the designers of the sorry the

221
00:07:53,759 --> 00:07:55,199
malicious entity

222
00:07:55,199 --> 00:07:57,120
actually has to perform some form of

223
00:07:57,120 --> 00:08:00,560
reverse engineering and in that case

224
00:08:00,560 --> 00:08:02,800
the the same trojan that is shown here

225
00:08:02,800 --> 00:08:04,240
on the slide

226
00:08:04,240 --> 00:08:06,560
must be meticulously placed in a very

227
00:08:06,560 --> 00:08:09,599
specific position in the circuit

228
00:08:09,599 --> 00:08:12,000
such that a predictable and controllable

229
00:08:12,000 --> 00:08:12,879
attack

230
00:08:12,879 --> 00:08:15,360
is performed in a known environment and

231
00:08:15,360 --> 00:08:16,400
obviously

232
00:08:16,400 --> 00:08:18,720
this this effort that is required by the

233
00:08:18,720 --> 00:08:21,199
malicious entity in turn

234
00:08:21,199 --> 00:08:24,319
can be paid off in terms of a very

235
00:08:24,319 --> 00:08:26,400
high impact attack

236
00:08:26,400 --> 00:08:28,160
but these design dependent trojans are

237
00:08:28,160 --> 00:08:30,080
in principle something that we can

238
00:08:30,080 --> 00:08:32,799
protect against so why well as you can

239
00:08:32,799 --> 00:08:33,919
see

240
00:08:33,919 --> 00:08:36,320
there is a specific effort by the entity

241
00:08:36,320 --> 00:08:38,719
in terms of reverse engineering which is

242
00:08:38,719 --> 00:08:41,440
required to perform the insertion so the

243
00:08:41,440 --> 00:08:43,519
key word here is reverse engineering so

244
00:08:43,519 --> 00:08:45,120
we need to increase the complexity of

245
00:08:45,120 --> 00:08:47,200
reverse engineering

246
00:08:47,200 --> 00:08:50,560
uh to actually be able to protect

247
00:08:50,560 --> 00:08:52,640
against such trojans

248
00:08:52,640 --> 00:08:54,399
okay

249
00:08:54,399 --> 00:08:55,440
so

250
00:08:55,440 --> 00:08:56,959
keeping this in mind that reverse

251
00:08:56,959 --> 00:08:58,880
engineering is kind of the key player in

252
00:08:58,880 --> 00:09:00,800
this process

253
00:09:00,800 --> 00:09:02,800
we basically can come up

254
00:09:02,800 --> 00:09:06,080
with with with a way to protect against

255
00:09:06,080 --> 00:09:08,160
the insertion so typically if we don't

256
00:09:08,160 --> 00:09:11,440
have any kind of protection mechanisms

257
00:09:11,440 --> 00:09:13,040
where

258
00:09:13,040 --> 00:09:14,480
in the scenario where we consider

259
00:09:14,480 --> 00:09:16,080
meaningful controllable and design

260
00:09:16,080 --> 00:09:19,120
specific hardware trojan insertion

261
00:09:19,120 --> 00:09:20,480
then the reverse engineering flow

262
00:09:20,480 --> 00:09:22,000
typically looks like that so at the

263
00:09:22,000 --> 00:09:23,440
beginning we have this reverse

264
00:09:23,440 --> 00:09:25,040
engineering and reverse engineering is a

265
00:09:25,040 --> 00:09:25,839
very

266
00:09:25,839 --> 00:09:27,920
very large term it's a very big

267
00:09:27,920 --> 00:09:30,000
word but in principle uh what we

268
00:09:30,000 --> 00:09:32,160
consider reverse engineering is the

269
00:09:32,160 --> 00:09:33,440
process of

270
00:09:33,440 --> 00:09:36,399
uh or two steps so the four one is to

271
00:09:36,399 --> 00:09:39,440
actually come back to a design

272
00:09:39,440 --> 00:09:41,680
format such as a netlist where we can

273
00:09:41,680 --> 00:09:43,519
actually operate on

274
00:09:43,519 --> 00:09:45,600
and second is actually to identify all

275
00:09:45,600 --> 00:09:46,959
the different components and the

276
00:09:46,959 --> 00:09:49,920
functionality of this netlist because

277
00:09:49,920 --> 00:09:51,519
this functionality and this knowledge

278
00:09:51,519 --> 00:09:53,200
about the different components can

279
00:09:53,200 --> 00:09:55,839
actually be utilized to define a very

280
00:09:55,839 --> 00:09:58,160
impactful hardware trojan

281
00:09:58,160 --> 00:10:00,959
and that is the flow that we need to

282
00:10:00,959 --> 00:10:02,880
to prevent or which

283
00:10:02,880 --> 00:10:05,120
basically complexity we need to increase

284
00:10:05,120 --> 00:10:07,440
and that's exactly where we want to

285
00:10:07,440 --> 00:10:09,440
operate on so we want to imply different

286
00:10:09,440 --> 00:10:11,680
hardware design protection schemes such

287
00:10:11,680 --> 00:10:13,920
as that whatever comes afterwards

288
00:10:13,920 --> 00:10:15,519
it becomes more difficult for the

289
00:10:15,519 --> 00:10:18,160
attacker and remember that we have this

290
00:10:18,160 --> 00:10:20,240
window vulnerability which is often

291
00:10:20,240 --> 00:10:22,399
given in three to six months so there is

292
00:10:22,399 --> 00:10:24,480
a limited time window where potentially

293
00:10:24,480 --> 00:10:27,040
something could go wrong

294
00:10:27,040 --> 00:10:29,040
okay so in terms of design protection

295
00:10:29,040 --> 00:10:30,399
methodologies there have been many

296
00:10:30,399 --> 00:10:34,079
proposals and one of this proposals

297
00:10:34,079 --> 00:10:36,000
is actually logic locking so logic

298
00:10:36,000 --> 00:10:37,040
clocking

299
00:10:37,040 --> 00:10:39,120
also sometimes known as logic

300
00:10:39,120 --> 00:10:40,560
obfuscation

301
00:10:40,560 --> 00:10:43,200
or logic encryption even even is a very

302
00:10:43,200 --> 00:10:44,720
popular counter measure for hardware

303
00:10:44,720 --> 00:10:47,120
trojans and in principle it can help

304
00:10:47,120 --> 00:10:50,160
with ip protection as well so how does

305
00:10:50,160 --> 00:10:52,240
logic locking actually work

306
00:10:52,240 --> 00:10:54,800
so logic locking actually what typically

307
00:10:54,800 --> 00:10:56,399
works on

308
00:10:56,399 --> 00:10:58,399
on a gate level net list so it works on

309
00:10:58,399 --> 00:11:00,959
a gate level

310
00:11:00,959 --> 00:11:02,560
such as the one here shown on the left

311
00:11:02,560 --> 00:11:04,880
hand side where we have an original

312
00:11:04,880 --> 00:11:07,440
circuit given in the typical gate level

313
00:11:07,440 --> 00:11:08,959
netflix format

314
00:11:08,959 --> 00:11:11,040
and what logic logging tries to perform

315
00:11:11,040 --> 00:11:11,680
is

316
00:11:11,680 --> 00:11:14,959
it inserts different changes so it

317
00:11:14,959 --> 00:11:16,480
performs different changes on the

318
00:11:16,480 --> 00:11:19,279
original circuit by implying or

319
00:11:19,279 --> 00:11:21,120
inserting injecting

320
00:11:21,120 --> 00:11:23,600
new gates which we typically

321
00:11:23,600 --> 00:11:26,240
call key gates because they are

322
00:11:26,240 --> 00:11:28,959
connected to a set of key inputs and

323
00:11:28,959 --> 00:11:31,040
that's exactly the key point of logic

324
00:11:31,040 --> 00:11:33,680
clocking so since the change the the

325
00:11:33,680 --> 00:11:35,040
original circuit has been changed

326
00:11:35,040 --> 00:11:36,880
through the inclusion of new

327
00:11:36,880 --> 00:11:38,640
functionality or through the inclusion

328
00:11:38,640 --> 00:11:41,440
of changed changes that actually are

329
00:11:41,440 --> 00:11:44,160
bound to a secret key

330
00:11:44,160 --> 00:11:46,720
the locked circuit now becomes dependent

331
00:11:46,720 --> 00:11:49,040
on this secret key which we do not have

332
00:11:49,040 --> 00:11:50,959
to share and which we shouldn't share

333
00:11:50,959 --> 00:11:51,920
with

334
00:11:51,920 --> 00:11:54,399
the malicious entities

335
00:11:54,399 --> 00:11:56,160
and this has a profound effect now for

336
00:11:56,160 --> 00:11:58,560
the hardware trojan insertion because

337
00:11:58,560 --> 00:12:01,440
the the malicious entity actually has to

338
00:12:01,440 --> 00:12:04,079
uh figure out the correct key the value

339
00:12:04,079 --> 00:12:07,040
of the key uh to be able to reverse

340
00:12:07,040 --> 00:12:09,440
engineer the circuit and go back to the

341
00:12:09,440 --> 00:12:11,680
original one so this is very a very

342
00:12:11,680 --> 00:12:13,920
important step because only once we have

343
00:12:13,920 --> 00:12:15,600
the original circuit we can actually

344
00:12:15,600 --> 00:12:16,880
perform

345
00:12:16,880 --> 00:12:19,040
the insertion of design dependent

346
00:12:19,040 --> 00:12:20,959
hardware trojans and that basically

347
00:12:20,959 --> 00:12:22,240
means that the

348
00:12:22,240 --> 00:12:24,079
engineering effort to perform reverse

349
00:12:24,079 --> 00:12:26,160
engineering is now increased and that's

350
00:12:26,160 --> 00:12:28,160
what we wanted to achieve at the very

351
00:12:28,160 --> 00:12:30,560
beginning and in terms of logic clocking

352
00:12:30,560 --> 00:12:32,240
there has been a tremendous amount of

353
00:12:32,240 --> 00:12:35,519
work in the last more than a decade

354
00:12:35,519 --> 00:12:38,079
with many many scheme proposals with

355
00:12:38,079 --> 00:12:40,399
many attacks

356
00:12:40,399 --> 00:12:42,399
and in principle we will not focus on

357
00:12:42,399 --> 00:12:44,240
all of them today we will just

358
00:12:44,240 --> 00:12:46,160
take a very small snapshot of the

359
00:12:46,160 --> 00:12:47,680
attacks which are relevant to machine

360
00:12:47,680 --> 00:12:48,880
learning

361
00:12:48,880 --> 00:12:50,880
but before we do so it is very important

362
00:12:50,880 --> 00:12:52,639
for you to understand what the actual

363
00:12:52,639 --> 00:12:55,279
tech model is in terms of logic locking

364
00:12:55,279 --> 00:12:57,519
and in terms of this technology

365
00:12:57,519 --> 00:12:59,040
so typically we assume that the

366
00:12:59,040 --> 00:13:01,279
malicious entity so the attacker has the

367
00:13:01,279 --> 00:13:03,519
following capabilities

368
00:13:03,519 --> 00:13:06,480
so the attacker is able to access the

369
00:13:06,480 --> 00:13:08,240
locked gate level net list which is of

370
00:13:08,240 --> 00:13:10,959
course a given one because um yeah if

371
00:13:10,959 --> 00:13:13,600
the malicious entity is the design house

372
00:13:13,600 --> 00:13:15,360
they will receive the net list and form

373
00:13:15,360 --> 00:13:17,920
of the locked gate level net list

374
00:13:17,920 --> 00:13:19,600
if it's the

375
00:13:19,600 --> 00:13:21,680
the foundry they will receive the locked

376
00:13:21,680 --> 00:13:24,320
basically gds2

377
00:13:24,320 --> 00:13:26,639
format of the of the design but in both

378
00:13:26,639 --> 00:13:29,040
cases it is possible to go back to

379
00:13:29,040 --> 00:13:30,639
higher abstraction levels such as the

380
00:13:30,639 --> 00:13:33,120
net list or maybe even higher than that

381
00:13:33,120 --> 00:13:34,880
so that's

382
00:13:34,880 --> 00:13:36,399
that's an assumption that we of course

383
00:13:36,399 --> 00:13:37,360
have to

384
00:13:37,360 --> 00:13:39,519
have to make the second assumption

385
00:13:39,519 --> 00:13:42,079
within the attack model is the fact

386
00:13:42,079 --> 00:13:43,199
that

387
00:13:43,199 --> 00:13:45,760
the attacker is able to distinguish

388
00:13:45,760 --> 00:13:48,160
between regular and key inputs so the

389
00:13:48,160 --> 00:13:49,680
attacker is able for example in this

390
00:13:49,680 --> 00:13:51,760
netlist here on the right

391
00:13:51,760 --> 00:13:54,000
to understand that these are primary

392
00:13:54,000 --> 00:13:55,680
inputs so the original inputs of the

393
00:13:55,680 --> 00:13:57,120
circuit and these

394
00:13:57,120 --> 00:14:00,480
are in this case this is the

395
00:14:00,480 --> 00:14:02,800
the edit key input

396
00:14:02,800 --> 00:14:04,720
um of course this

397
00:14:04,720 --> 00:14:06,480
the the scheme so the locking scheme

398
00:14:06,480 --> 00:14:08,560
should be clever enough such that even

399
00:14:08,560 --> 00:14:11,199
if the attacker knows this uh he cannot

400
00:14:11,199 --> 00:14:13,600
simply remove what has been added to the

401
00:14:13,600 --> 00:14:15,920
original circuit or how the circuit has

402
00:14:15,920 --> 00:14:18,000
been changed this is a very

403
00:14:18,000 --> 00:14:19,519
yeah very

404
00:14:19,519 --> 00:14:21,279
big challenge that we have today but i

405
00:14:21,279 --> 00:14:23,040
will go into that in a second

406
00:14:23,040 --> 00:14:26,000
and finally the third assumption is

407
00:14:26,000 --> 00:14:29,199
the access to an activated oracle ic so

408
00:14:29,199 --> 00:14:30,880
this image here basically represents

409
00:14:30,880 --> 00:14:32,560
this activated ic

410
00:14:32,560 --> 00:14:34,800
what does it mean well it means that the

411
00:14:34,800 --> 00:14:37,040
attacker in principle could

412
00:14:37,040 --> 00:14:39,199
go and simply buy a copy of the

413
00:14:39,199 --> 00:14:41,199
activated chip

414
00:14:41,199 --> 00:14:42,800
which has already been produced from the

415
00:14:42,800 --> 00:14:44,959
market

416
00:14:44,959 --> 00:14:47,760
and this obviously only makes sense and

417
00:14:47,760 --> 00:14:48,480
in

418
00:14:48,480 --> 00:14:50,399
a scenario where we have multiple

419
00:14:50,399 --> 00:14:52,720
batches multiple production rounds of

420
00:14:52,720 --> 00:14:55,440
the same chip and the chip of course is

421
00:14:55,440 --> 00:14:57,440
in that case already activated because

422
00:14:57,440 --> 00:14:59,920
the designer the trusted entity

423
00:14:59,920 --> 00:15:02,880
can activate the chip once the locked

424
00:15:02,880 --> 00:15:05,760
locked design has been fabricated and

425
00:15:05,760 --> 00:15:08,720
returned back to the original design

426
00:15:08,720 --> 00:15:11,360
and using this third assumption

427
00:15:11,360 --> 00:15:14,320
we can actually divide all attacks into

428
00:15:14,320 --> 00:15:16,720
two classes so the first class is the

429
00:15:16,720 --> 00:15:18,560
class of oracle guided attacks and the

430
00:15:18,560 --> 00:15:20,880
second one is the class of oracle less

431
00:15:20,880 --> 00:15:23,279
attacks here oracle guided basically

432
00:15:23,279 --> 00:15:25,440
means that the

433
00:15:25,440 --> 00:15:28,800
oracle so the activated ic is available

434
00:15:28,800 --> 00:15:31,680
this is as i mentioned uh often the case

435
00:15:31,680 --> 00:15:33,680
in a high volume production so a

436
00:15:33,680 --> 00:15:35,360
production where we produce many many

437
00:15:35,360 --> 00:15:36,959
different chips in many batches in many

438
00:15:36,959 --> 00:15:38,800
production rounds

439
00:15:38,800 --> 00:15:40,720
and in that case the attacker could

440
00:15:40,720 --> 00:15:43,040
simply buy a copy of that chip on the

441
00:15:43,040 --> 00:15:45,120
market and then try to use it as an

442
00:15:45,120 --> 00:15:47,759
oracle so to to be able to put some

443
00:15:47,759 --> 00:15:50,720
input patterns read out the right output

444
00:15:50,720 --> 00:15:53,120
values and then use it as an oracle to

445
00:15:53,120 --> 00:15:55,839
actually figure out what the correct key

446
00:15:55,839 --> 00:15:58,000
could be this assumes of course that you

447
00:15:58,000 --> 00:16:00,639
cannot simply read out the key from the

448
00:16:00,639 --> 00:16:03,199
from the chip but that's maybe a story

449
00:16:03,199 --> 00:16:05,040
for another time

450
00:16:05,040 --> 00:16:06,839
the second type so the oracle less

451
00:16:06,839 --> 00:16:09,519
attacks are attacks where the oracle is

452
00:16:09,519 --> 00:16:10,959
not available

453
00:16:10,959 --> 00:16:13,199
this is also in our view a more

454
00:16:13,199 --> 00:16:14,639
realistic one

455
00:16:14,639 --> 00:16:17,120
so more realistic attack scenario and

456
00:16:17,120 --> 00:16:18,880
it's typically

457
00:16:18,880 --> 00:16:21,519
deployed in a low volume sorry low

458
00:16:21,519 --> 00:16:24,160
volume uh production a low volume

459
00:16:24,160 --> 00:16:26,320
production basically means that only a

460
00:16:26,320 --> 00:16:28,720
few chips are produced or very little

461
00:16:28,720 --> 00:16:31,519
rounds in very uh yeah a small number of

462
00:16:31,519 --> 00:16:32,560
rounds

463
00:16:32,560 --> 00:16:35,199
of chips and it's these chips are

464
00:16:35,199 --> 00:16:37,040
actually deployed in a high security

465
00:16:37,040 --> 00:16:39,440
scenario which means that everyone can

466
00:16:39,440 --> 00:16:42,480
simply buy a chip on the market but it's

467
00:16:42,480 --> 00:16:46,639
actually very hard to acquire a copy

468
00:16:46,639 --> 00:16:48,639
okay and using this attack model and

469
00:16:48,639 --> 00:16:51,040
this classification

470
00:16:51,040 --> 00:16:54,079
a tremendous amount of of proposals have

471
00:16:54,079 --> 00:16:55,600
been done in literature both on the

472
00:16:55,600 --> 00:16:58,959
schemes and the attacks side so in terms

473
00:16:58,959 --> 00:17:01,199
of schemes as i mentioned

474
00:17:01,199 --> 00:17:03,519
many many proposals have been done with

475
00:17:03,519 --> 00:17:06,000
many different functionalities from xor

476
00:17:06,000 --> 00:17:08,240
gates and or gates

477
00:17:08,240 --> 00:17:09,839
functionality stripping diverse

478
00:17:09,839 --> 00:17:11,919
combinations of those so the details

479
00:17:11,919 --> 00:17:13,919
here are actually not important for this

480
00:17:13,919 --> 00:17:15,599
for this talk

481
00:17:15,599 --> 00:17:17,919
as well as many different attacks have

482
00:17:17,919 --> 00:17:20,160
been applied as well from functional

483
00:17:20,160 --> 00:17:22,079
structural side channel attacks and

484
00:17:22,079 --> 00:17:24,079
diverse combinations of those

485
00:17:24,079 --> 00:17:25,520
two

486
00:17:25,520 --> 00:17:29,039
and what we are looking into in the last

487
00:17:29,039 --> 00:17:30,400
what we have been looking into in the

488
00:17:30,400 --> 00:17:33,600
last couple of years is okay so across

489
00:17:33,600 --> 00:17:35,280
all these schemes and across all these

490
00:17:35,280 --> 00:17:39,280
attacks that we already have seen

491
00:17:39,280 --> 00:17:41,760
what is actually the impact of

492
00:17:41,760 --> 00:17:44,400
machine learning so nowadays we have

493
00:17:44,400 --> 00:17:47,440
access to easy-to-use and very efficient

494
00:17:47,440 --> 00:17:48,880
machine learning

495
00:17:48,880 --> 00:17:51,440
algorithms we have dedicated hardware

496
00:17:51,440 --> 00:17:53,280
for that it's very easy nowadays for

497
00:17:53,280 --> 00:17:56,000
anyone basically to use

498
00:17:56,000 --> 00:17:58,240
very efficient and very powerful machine

499
00:17:58,240 --> 00:18:00,640
learning models so can we utilize

500
00:18:00,640 --> 00:18:03,120
actually machine learning

501
00:18:03,120 --> 00:18:05,440
for maybe breaking logic locking or

502
00:18:05,440 --> 00:18:07,760
trying to improve it so that's a very

503
00:18:07,760 --> 00:18:09,039
interesting question that we see

504
00:18:09,039 --> 00:18:12,240
nowadays in the research community

505
00:18:12,240 --> 00:18:14,960
and it seems like it's opening up a new

506
00:18:14,960 --> 00:18:18,080
wave of logic locking

507
00:18:18,080 --> 00:18:20,720
logic locking design

508
00:18:20,720 --> 00:18:22,080
okay

509
00:18:22,080 --> 00:18:23,120
so

510
00:18:23,120 --> 00:18:25,679
considering that we have now all these

511
00:18:25,679 --> 00:18:26,960
different kinds of machine learning

512
00:18:26,960 --> 00:18:29,039
models the very big question is okay

513
00:18:29,039 --> 00:18:30,720
what can be actually exploited by

514
00:18:30,720 --> 00:18:32,480
machine learning in terms of logic

515
00:18:32,480 --> 00:18:33,600
clocking

516
00:18:33,600 --> 00:18:34,400
well

517
00:18:34,400 --> 00:18:35,840
in principle there are two things that

518
00:18:35,840 --> 00:18:37,679
could be exploited

519
00:18:37,679 --> 00:18:39,760
so if we consider the netlist which is

520
00:18:39,760 --> 00:18:41,679
provided so the log netlist which is

521
00:18:41,679 --> 00:18:43,919
available to the attacker

522
00:18:43,919 --> 00:18:45,919
a machine learning model could try to

523
00:18:45,919 --> 00:18:48,640
analyze the structure of the netlist

524
00:18:48,640 --> 00:18:51,440
that is associated to the key

525
00:18:51,440 --> 00:18:52,640
input

526
00:18:52,640 --> 00:18:55,600
so if the structure can be found and it

527
00:18:55,600 --> 00:18:58,400
can be found because if you remember the

528
00:18:58,400 --> 00:19:00,720
uh one of the assumptions was that the

529
00:19:00,720 --> 00:19:03,760
key input input is uh identifiable for

530
00:19:03,760 --> 00:19:04,880
the attacker

531
00:19:04,880 --> 00:19:06,240
then the attacker could in principle

532
00:19:06,240 --> 00:19:09,200
track this key input and try to extract

533
00:19:09,200 --> 00:19:11,919
a part of the netlist or some

534
00:19:11,919 --> 00:19:14,880
subnet list that is somewhat associated

535
00:19:14,880 --> 00:19:17,360
to this key input and then the question

536
00:19:17,360 --> 00:19:19,120
is okay if i have many many different

537
00:19:19,120 --> 00:19:21,679
samples of such

538
00:19:21,679 --> 00:19:22,720
of such

539
00:19:22,720 --> 00:19:24,640
sub graphs which are associated to a

540
00:19:24,640 --> 00:19:25,600
single

541
00:19:25,600 --> 00:19:27,600
to a specific key input and key input

542
00:19:27,600 --> 00:19:28,720
value

543
00:19:28,720 --> 00:19:31,360
potentially i could actually learn

544
00:19:31,360 --> 00:19:34,640
if i see such an unknown subgraph

545
00:19:34,640 --> 00:19:37,679
i could learn to predict what kind of

546
00:19:37,679 --> 00:19:39,679
key input value

547
00:19:39,679 --> 00:19:41,919
should be associated with that sub graph

548
00:19:41,919 --> 00:19:44,799
so that's one way to do it so we can try

549
00:19:44,799 --> 00:19:46,960
to associate structure with the key or

550
00:19:46,960 --> 00:19:49,840
with the key value the second approach

551
00:19:49,840 --> 00:19:52,160
is in terms of an oracle guided attack

552
00:19:52,160 --> 00:19:53,600
so where the oracle actually is actually

553
00:19:53,600 --> 00:19:55,280
provided

554
00:19:55,280 --> 00:19:57,200
if i have an activated ic i could

555
00:19:57,200 --> 00:19:59,520
potentially try to associate the input

556
00:19:59,520 --> 00:20:01,600
output behavior with the key so if i

557
00:20:01,600 --> 00:20:03,679
have an oracle on my desk and i can

558
00:20:03,679 --> 00:20:05,280
actually set some inputs and read some

559
00:20:05,280 --> 00:20:07,280
outputs maybe i can utilize this

560
00:20:07,280 --> 00:20:08,880
behavior

561
00:20:08,880 --> 00:20:10,799
and check whether i can figure out or

562
00:20:10,799 --> 00:20:12,320
whether the machine learning algorithm

563
00:20:12,320 --> 00:20:14,159
could figure out what key should be

564
00:20:14,159 --> 00:20:16,720
given here on the left hand side so

565
00:20:16,720 --> 00:20:19,440
to the actual netlist such that the

566
00:20:19,440 --> 00:20:22,640
input and output behavior is preserved

567
00:20:22,640 --> 00:20:23,840
um

568
00:20:23,840 --> 00:20:26,559
when comparing to to the oracle

569
00:20:26,559 --> 00:20:28,960
and using this uh these two two worlds

570
00:20:28,960 --> 00:20:30,880
so this structural and functional or

571
00:20:30,880 --> 00:20:32,480
behavioral uh

572
00:20:32,480 --> 00:20:35,039
description of the of the of the

573
00:20:35,039 --> 00:20:37,520
locked design we can actually develop

574
00:20:37,520 --> 00:20:39,919
many different machine learning uh

575
00:20:39,919 --> 00:20:42,799
attacks so let's uh let's consider a few

576
00:20:42,799 --> 00:20:45,200
of those which are um

577
00:20:45,200 --> 00:20:46,960
which are well known at the moment in

578
00:20:46,960 --> 00:20:48,559
the scientific community

579
00:20:48,559 --> 00:20:50,720
so in terms of oracle less attack so a

580
00:20:50,720 --> 00:20:52,559
text where the oracle is not provided

581
00:20:52,559 --> 00:20:55,200
but only the netlist is provided one of

582
00:20:55,200 --> 00:20:57,919
the first texts in this uh this

583
00:20:57,919 --> 00:21:00,720
class is known as sale and here you can

584
00:21:00,720 --> 00:21:02,799
also later take a look at

585
00:21:02,799 --> 00:21:05,520
at the papers if you're interested

586
00:21:05,520 --> 00:21:08,159
so how does sale actually work so sale

587
00:21:08,159 --> 00:21:10,320
takes as input the target net list so

588
00:21:10,320 --> 00:21:12,080
that's the locked net list which is

589
00:21:12,080 --> 00:21:14,400
provided to the

590
00:21:14,400 --> 00:21:16,320
malicious entity without providing of

591
00:21:16,320 --> 00:21:18,559
course the correct key it's just the

592
00:21:18,559 --> 00:21:19,840
locknet list

593
00:21:19,840 --> 00:21:22,080
and what sail tries to do is uh it

594
00:21:22,080 --> 00:21:24,400
extracts the localities so localities

595
00:21:24,400 --> 00:21:26,159
are basically these sub-graphs which are

596
00:21:26,159 --> 00:21:28,400
associated to a key input

597
00:21:28,400 --> 00:21:31,039
and then it tries to predict whether the

598
00:21:31,039 --> 00:21:33,120
synthesis process so the logic synthesis

599
00:21:33,120 --> 00:21:36,240
process has implied any form of change

600
00:21:36,240 --> 00:21:38,880
into the locked design so why is this

601
00:21:38,880 --> 00:21:42,000
important well when we consider a very

602
00:21:42,000 --> 00:21:44,159
simple logic locking scheme which

603
00:21:44,159 --> 00:21:46,400
inserts for example

604
00:21:46,400 --> 00:21:49,039
xor gates and x nor gates so you can

605
00:21:49,039 --> 00:21:50,000
simply

606
00:21:50,000 --> 00:21:51,360
think of

607
00:21:51,360 --> 00:21:53,919
the simple scheme which inserts an xor

608
00:21:53,919 --> 00:21:57,360
gate which is coupled to a key input

609
00:21:57,360 --> 00:21:59,200
and the other input is simply a selected

610
00:21:59,200 --> 00:22:01,679
randomly selected input from a sorry

611
00:22:01,679 --> 00:22:03,919
randomly selected wire from the design

612
00:22:03,919 --> 00:22:06,320
and it simply buffers that value so if

613
00:22:06,320 --> 00:22:08,159
the correct key is provided then this

614
00:22:08,159 --> 00:22:10,559
value will be equivalent it will be

615
00:22:10,559 --> 00:22:12,799
always preserved and in terms of the xor

616
00:22:12,799 --> 00:22:15,200
gate it should be of course a zero and

617
00:22:15,200 --> 00:22:17,679
in terms of an x nor gate it should be a

618
00:22:17,679 --> 00:22:19,600
one then this value is actually buffered

619
00:22:19,600 --> 00:22:22,000
within the chip however if the wrong key

620
00:22:22,000 --> 00:22:24,480
is provided then of course the design

621
00:22:24,480 --> 00:22:25,520
will

622
00:22:25,520 --> 00:22:28,480
not perform as intended

623
00:22:28,480 --> 00:22:31,039
as originally intended

624
00:22:31,039 --> 00:22:34,559
so once such an exo external scheme is

625
00:22:34,559 --> 00:22:36,640
deployed on the log design typically we

626
00:22:36,640 --> 00:22:38,320
have to perform another round of logic

627
00:22:38,320 --> 00:22:41,039
synthesis to integrate everything into

628
00:22:41,039 --> 00:22:42,720
the lock design and to make sure that

629
00:22:42,720 --> 00:22:43,679
these

630
00:22:43,679 --> 00:22:46,240
hexoic and xnor gates are actually

631
00:22:46,240 --> 00:22:48,320
blurred away so that they are actually

632
00:22:48,320 --> 00:22:49,679
merged into

633
00:22:49,679 --> 00:22:50,640
the

634
00:22:50,640 --> 00:22:51,840
the circuit

635
00:22:51,840 --> 00:22:54,480
and the sail attack has noticed that

636
00:22:54,480 --> 00:22:56,240
it is possible to actually

637
00:22:56,240 --> 00:22:59,200
design a machine learning model which

638
00:22:59,200 --> 00:23:02,080
can learn to reverse this process to

639
00:23:02,080 --> 00:23:04,400
reverse the synthesis process

640
00:23:04,400 --> 00:23:06,480
which means that it can predict the

641
00:23:06,480 --> 00:23:09,039
locality which has been there before

642
00:23:09,039 --> 00:23:11,039
another round of logic synthesis has

643
00:23:11,039 --> 00:23:12,240
been performed

644
00:23:12,240 --> 00:23:13,600
and if that is possible for this

645
00:23:13,600 --> 00:23:16,240
specific scheme of xoxon based logic

646
00:23:16,240 --> 00:23:17,600
blocking it is

647
00:23:17,600 --> 00:23:20,960
relatively easy then to predict the key

648
00:23:20,960 --> 00:23:22,559
um so basically sale tries to

649
00:23:22,559 --> 00:23:25,120
reconstruct pre-resynthesis designs or

650
00:23:25,120 --> 00:23:26,640
in other words it tries to figure out

651
00:23:26,640 --> 00:23:28,640
how did the blocked ic look like before

652
00:23:28,640 --> 00:23:30,000
a synthesis

653
00:23:30,000 --> 00:23:32,320
another attack that we developed here at

654
00:23:32,320 --> 00:23:35,039
my institute is called snapshot

655
00:23:35,039 --> 00:23:36,799
it works in a very similar fashion

656
00:23:36,799 --> 00:23:38,799
however we have realized there is no

657
00:23:38,799 --> 00:23:40,720
really need to develop a machine

658
00:23:40,720 --> 00:23:43,279
learning model that can do or that can

659
00:23:43,279 --> 00:23:45,600
reconstruct the netlist before a

660
00:23:45,600 --> 00:23:47,600
synthesis but we can actually look at

661
00:23:47,600 --> 00:23:49,760
these localities at these key associated

662
00:23:49,760 --> 00:23:52,400
localities after the resentences process

663
00:23:52,400 --> 00:23:54,640
and immediately try to

664
00:23:54,640 --> 00:23:56,640
match it or match them with the correct

665
00:23:56,640 --> 00:23:58,720
key value so sale is actually more

666
00:23:58,720 --> 00:24:00,559
powerful in that sense

667
00:24:00,559 --> 00:24:02,480
and it actually tries to answer the

668
00:24:02,480 --> 00:24:05,279
question which key bit is expected for a

669
00:24:05,279 --> 00:24:07,200
given local structure so it tries to

670
00:24:07,200 --> 00:24:08,640
learn local

671
00:24:08,640 --> 00:24:10,799
hardware structural patterns

672
00:24:10,799 --> 00:24:12,480
a third attack that has been developed

673
00:24:12,480 --> 00:24:13,760
in this domain

674
00:24:13,760 --> 00:24:15,840
is known as gnn unlock

675
00:24:15,840 --> 00:24:18,880
it's also very interesting attack it

676
00:24:18,880 --> 00:24:19,760
uses

677
00:24:19,760 --> 00:24:21,440
as the name suggests

678
00:24:21,440 --> 00:24:23,360
graph neural networks

679
00:24:23,360 --> 00:24:25,760
and in comparison to to sale and

680
00:24:25,760 --> 00:24:27,919
snapshot it actually doesn't try to

681
00:24:27,919 --> 00:24:29,760
predict the key value but it actually

682
00:24:29,760 --> 00:24:32,720
tries to predict

683
00:24:32,720 --> 00:24:35,120
if whether a specific node that is

684
00:24:35,120 --> 00:24:37,760
currently being evaluated is part of the

685
00:24:37,760 --> 00:24:41,200
original design or whether it's part of

686
00:24:41,200 --> 00:24:42,559
the

687
00:24:42,559 --> 00:24:44,960
locking circuitry so what has been added

688
00:24:44,960 --> 00:24:46,720
so in that sense it's it tries to

689
00:24:46,720 --> 00:24:48,880
identify the lock

690
00:24:48,880 --> 00:24:50,480
yeah the locked key gate so the key

691
00:24:50,480 --> 00:24:51,919
gates that have been inserted into the

692
00:24:51,919 --> 00:24:54,159
design and basically remove them so it's

693
00:24:54,159 --> 00:24:56,400
a very interesting attack as well so in

694
00:24:56,400 --> 00:24:58,799
that case it tries to answer the

695
00:24:58,799 --> 00:25:00,720
question is a node really part of the

696
00:25:00,720 --> 00:25:03,440
locking circuitry or the original design

697
00:25:03,440 --> 00:25:05,039
and the fact that these attacks actually

698
00:25:05,039 --> 00:25:07,919
work quite well but somewhere between 70

699
00:25:07,919 --> 00:25:10,480
to even up to 100 percent of the correct

700
00:25:10,480 --> 00:25:14,080
key or the nodes can be identified

701
00:25:14,080 --> 00:25:16,240
well that tells us that all the effort

702
00:25:16,240 --> 00:25:18,240
that we have seen in the last 10 years

703
00:25:18,240 --> 00:25:19,760
in this domain

704
00:25:19,760 --> 00:25:22,720
have actually missed this very important

705
00:25:22,720 --> 00:25:25,679
question they have missed the fact

706
00:25:25,679 --> 00:25:27,120
that the key

707
00:25:27,120 --> 00:25:28,720
is still associate or the key value is

708
00:25:28,720 --> 00:25:30,640
still associated with

709
00:25:30,640 --> 00:25:32,559
uh with some structural aspects of the

710
00:25:32,559 --> 00:25:34,320
circuit and that is something we have to

711
00:25:34,320 --> 00:25:36,080
work on so that's something we have to

712
00:25:36,080 --> 00:25:37,840
try to fix

713
00:25:37,840 --> 00:25:39,840
okay so these were oracle less attacks

714
00:25:39,840 --> 00:25:42,640
and as you can see they mostly focus on

715
00:25:42,640 --> 00:25:45,039
structural aspects of

716
00:25:45,039 --> 00:25:46,960
of logic locking circuits to try to

717
00:25:46,960 --> 00:25:49,600
deduce something about the correctness

718
00:25:49,600 --> 00:25:52,080
of the of the key itself

719
00:25:52,080 --> 00:25:53,840
in terms of oracle guided attacks i will

720
00:25:53,840 --> 00:25:56,880
just mention a few of those as well

721
00:25:56,880 --> 00:26:01,679
so one of the first attacks which uses

722
00:26:02,400 --> 00:26:04,159
which uses machine learning based models

723
00:26:04,159 --> 00:26:07,840
for key retrieval is known as surf

724
00:26:07,840 --> 00:26:10,080
some recent ones are as well gen unlock

725
00:26:10,080 --> 00:26:10,880
and

726
00:26:10,880 --> 00:26:13,360
the pso attack i will not go into too

727
00:26:13,360 --> 00:26:15,679
many details but basically the the idea

728
00:26:15,679 --> 00:26:18,480
of these attacks is that we can use the

729
00:26:18,480 --> 00:26:22,159
oracle so the uh correct io mapping

730
00:26:22,159 --> 00:26:25,039
and the netlist to try to refine the key

731
00:26:25,039 --> 00:26:27,520
based on some output behavior so the big

732
00:26:27,520 --> 00:26:28,960
question that these attacks try to

733
00:26:28,960 --> 00:26:31,919
answer is how does a change in the key

734
00:26:31,919 --> 00:26:33,919
impact the correctness of the output so

735
00:26:33,919 --> 00:26:35,840
basically what the attacker can do is it

736
00:26:35,840 --> 00:26:38,559
he can try to

737
00:26:38,559 --> 00:26:40,880
do to change the key inputs so the key

738
00:26:40,880 --> 00:26:42,880
values of the key inputs in the target

739
00:26:42,880 --> 00:26:44,880
netlist

740
00:26:44,880 --> 00:26:47,600
and use the oracle to guide this process

741
00:26:47,600 --> 00:26:49,360
and in terms of surf it is a very

742
00:26:49,360 --> 00:26:52,400
custom-made heuristic optimization

743
00:26:52,400 --> 00:26:54,640
with simple bit flips and then

744
00:26:54,640 --> 00:26:56,720
the the behavior of the target netlist

745
00:26:56,720 --> 00:26:58,400
is compared to the oracle

746
00:26:58,400 --> 00:27:00,960
or in terms of uh gen unlock and pso

747
00:27:00,960 --> 00:27:03,600
attack yeah gen unlock is using a

748
00:27:03,600 --> 00:27:05,520
genetic algorithm for this process while

749
00:27:05,520 --> 00:27:07,679
pso is using a particles form

750
00:27:07,679 --> 00:27:09,679
optimization algorithm so these two are

751
00:27:09,679 --> 00:27:11,919
actually coming from the domain of soft

752
00:27:11,919 --> 00:27:14,960
computing or evolutionary computation

753
00:27:14,960 --> 00:27:17,760
to to actually optimize this

754
00:27:17,760 --> 00:27:18,640
this

755
00:27:18,640 --> 00:27:21,679
search process and as it turns out they

756
00:27:21,679 --> 00:27:23,919
actually work quite well

757
00:27:23,919 --> 00:27:25,679
too which means there is a clear

758
00:27:25,679 --> 00:27:27,360
correlation between

759
00:27:27,360 --> 00:27:28,559
the

760
00:27:28,559 --> 00:27:30,720
the core key value and

761
00:27:30,720 --> 00:27:33,120
the behavior of the chip

762
00:27:33,120 --> 00:27:35,360
and that is something we can have to

763
00:27:35,360 --> 00:27:37,440
resolve otherwise as soon as long as

764
00:27:37,440 --> 00:27:39,120
there is an association as long as there

765
00:27:39,120 --> 00:27:42,080
is a correlation it is possible uh to

766
00:27:42,080 --> 00:27:44,399
perform such an optimism optimization

767
00:27:44,399 --> 00:27:47,120
sorry such a heuristical search

768
00:27:47,120 --> 00:27:50,559
for for the key

769
00:27:50,559 --> 00:27:53,279
okay so we have seen some oracle uh less

770
00:27:53,279 --> 00:27:54,880
attacks we have seen some oracle guided

771
00:27:54,880 --> 00:27:56,799
attacks in machine learning

772
00:27:56,799 --> 00:27:59,039
so an interesting question is of course

773
00:27:59,039 --> 00:28:02,080
how can we try to prevent such attacks

774
00:28:02,080 --> 00:28:05,039
well as it turns out so far there is not

775
00:28:05,039 --> 00:28:07,360
much we can we can really do because

776
00:28:07,360 --> 00:28:09,919
only a few solutions or a handful of

777
00:28:09,919 --> 00:28:11,279
solutions have been proposed in

778
00:28:11,279 --> 00:28:13,440
literature that target machine learning

779
00:28:13,440 --> 00:28:15,039
based attacks

780
00:28:15,039 --> 00:28:17,440
one of them is also dmax so that's one

781
00:28:17,440 --> 00:28:19,600
that we developed in my chair as well if

782
00:28:19,600 --> 00:28:21,520
you are interested all the papers are

783
00:28:21,520 --> 00:28:23,360
listed below

784
00:28:23,360 --> 00:28:25,919
so how do these

785
00:28:25,919 --> 00:28:27,279
schemes actually work so we are

786
00:28:27,279 --> 00:28:29,679
considering dmax unsale and sorrow so

787
00:28:29,679 --> 00:28:31,840
these are ones one of the new ones which

788
00:28:31,840 --> 00:28:34,559
tried to resolve this machine learning

789
00:28:34,559 --> 00:28:37,200
attacks on logic blocking

790
00:28:37,200 --> 00:28:39,279
obviously due to timing limitations i

791
00:28:39,279 --> 00:28:40,960
will not go into details but the very

792
00:28:40,960 --> 00:28:43,279
simple idea is as follows

793
00:28:43,279 --> 00:28:47,520
so we need to be able to

794
00:28:47,520 --> 00:28:50,399
create equal local changes for both key

795
00:28:50,399 --> 00:28:53,039
values that basically means that any

796
00:28:53,039 --> 00:28:54,720
attack that tries to

797
00:28:54,720 --> 00:28:57,120
associate give a given

798
00:28:57,120 --> 00:28:59,760
graph of the net list with a core key

799
00:28:59,760 --> 00:29:02,799
must encounter a very confusing training

800
00:29:02,799 --> 00:29:05,520
set in order to to fail in the

801
00:29:05,520 --> 00:29:07,360
prediction

802
00:29:07,360 --> 00:29:09,200
and this is obviously the case if we

803
00:29:09,200 --> 00:29:11,120
have two local changes which are

804
00:29:11,120 --> 00:29:12,960
equivalent in structure

805
00:29:12,960 --> 00:29:15,600
but which are both associated with

806
00:29:15,600 --> 00:29:18,240
different key values and in practice you

807
00:29:18,240 --> 00:29:20,480
can just imagine having two images for

808
00:29:20,480 --> 00:29:23,520
example where both images are labeled

809
00:29:23,520 --> 00:29:25,120
where one image is labeled with the key

810
00:29:25,120 --> 00:29:27,039
value 0 and one is labeled with the key

811
00:29:27,039 --> 00:29:29,440
value 1. obviously in that case it is

812
00:29:29,440 --> 00:29:31,679
very very difficult for the machine

813
00:29:31,679 --> 00:29:32,960
learning model to make a correct

814
00:29:32,960 --> 00:29:34,640
prediction because at the end of the day

815
00:29:34,640 --> 00:29:36,720
it's just a random choice

816
00:29:36,720 --> 00:29:39,120
another option to

817
00:29:39,120 --> 00:29:40,960
to try to prevent machine learning

818
00:29:40,960 --> 00:29:43,039
attacks is by decoupling the key value

819
00:29:43,039 --> 00:29:44,720
from the local change which means

820
00:29:44,720 --> 00:29:46,480
whatever we are implying whatever we are

821
00:29:46,480 --> 00:29:48,320
changing in the circuit should not

822
00:29:48,320 --> 00:29:51,200
depend on the key value in that in the

823
00:29:51,200 --> 00:29:52,640
structural sense

824
00:29:52,640 --> 00:29:55,200
that is for example how dmax is actually

825
00:29:55,200 --> 00:29:57,279
working

826
00:29:57,279 --> 00:29:58,640
and another aspect is of course

827
00:29:58,640 --> 00:30:00,880
randomness we need to be we need to

828
00:30:00,880 --> 00:30:03,919
apply randomness in terms of uh

829
00:30:03,919 --> 00:30:06,080
how we perform the change in the locked

830
00:30:06,080 --> 00:30:08,000
net list and of course where we perform

831
00:30:08,000 --> 00:30:09,919
the change in the log net list and if we

832
00:30:09,919 --> 00:30:11,679
can actually uh

833
00:30:11,679 --> 00:30:14,080
come up with a scheme that

834
00:30:14,080 --> 00:30:15,840
makes sure that all these requirements

835
00:30:15,840 --> 00:30:18,000
are fulfilled then a machine learning

836
00:30:18,000 --> 00:30:20,080
model will most likely fail in

837
00:30:20,080 --> 00:30:22,799
predicting the correct correct value

838
00:30:22,799 --> 00:30:23,919
however

839
00:30:23,919 --> 00:30:25,840
we still have another open challenge and

840
00:30:25,840 --> 00:30:27,120
that is

841
00:30:27,120 --> 00:30:28,640
a very very interesting question

842
00:30:28,640 --> 00:30:31,440
actually so even if we lock all these

843
00:30:31,440 --> 00:30:32,720
circuits

844
00:30:32,720 --> 00:30:35,360
a question remains is the question that

845
00:30:35,360 --> 00:30:37,200
remains is can we still guess the

846
00:30:37,200 --> 00:30:38,720
hardware or basically the circuit

847
00:30:38,720 --> 00:30:40,480
functionality regardless of the

848
00:30:40,480 --> 00:30:43,039
protection mechanism so how much change

849
00:30:43,039 --> 00:30:44,960
do we actually have to imply such that a

850
00:30:44,960 --> 00:30:48,399
malicious entity is maybe not able to

851
00:30:48,399 --> 00:30:51,279
detect what the circuit really does so

852
00:30:51,279 --> 00:30:52,720
what the functionality of the of the

853
00:30:52,720 --> 00:30:54,880
circuit really is and of course

854
00:30:54,880 --> 00:30:56,480
in long term this could be also a

855
00:30:56,480 --> 00:30:58,559
machine learning uh model that tries to

856
00:30:58,559 --> 00:31:00,480
automatically deduce the functionality

857
00:31:00,480 --> 00:31:03,039
but that's still an open open question

858
00:31:03,039 --> 00:31:05,760
so to finalize my talk

859
00:31:05,760 --> 00:31:07,600
we are very sure that machine learning

860
00:31:07,600 --> 00:31:10,640
in all its forms will be a key player uh

861
00:31:10,640 --> 00:31:13,200
in in the following years and both the

862
00:31:13,200 --> 00:31:15,120
security evaluation of logic locking as

863
00:31:15,120 --> 00:31:17,440
well as the design of next generation

864
00:31:17,440 --> 00:31:19,600
schemes so we are very much looking

865
00:31:19,600 --> 00:31:22,640
forward to this ml era of logic locking

866
00:31:22,640 --> 00:31:24,480
where machine learning is actually

867
00:31:24,480 --> 00:31:26,960
playing against hardware protection so

868
00:31:26,960 --> 00:31:29,279
thanks a lot for listening in

869
00:31:29,279 --> 00:31:30,960
and if there are any questions i'm happy

870
00:31:30,960 --> 00:31:33,840
to to answer

