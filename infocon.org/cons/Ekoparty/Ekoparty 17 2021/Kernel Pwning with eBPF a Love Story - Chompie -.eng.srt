1
00:00:04,319 --> 00:00:06,000
hi

2
00:00:06,000 --> 00:00:09,120
uh okay so this is the talk

3
00:00:09,120 --> 00:00:10,559
uh colonel

4
00:00:10,559 --> 00:00:14,000
pawning with ebpf a love story or hockey

5
00:00:14,000 --> 00:00:17,400
and cardinal

6
00:00:25,439 --> 00:00:27,840
i'm the lead security researcher at

7
00:00:27,840 --> 00:00:29,119
grapple

8
00:00:29,119 --> 00:00:31,599
i focus on vulnerability research

9
00:00:31,599 --> 00:00:33,680
exploit development reverse engineering

10
00:00:33,680 --> 00:00:35,520
and offensive security

11
00:00:35,520 --> 00:00:38,640
tools and techniques

12
00:00:39,120 --> 00:00:41,280
we use this research to improve

13
00:00:41,280 --> 00:00:43,520
detection in defense

14
00:00:43,520 --> 00:00:44,399
and

15
00:00:44,399 --> 00:00:46,079
if you're interested i release new

16
00:00:46,079 --> 00:00:48,800
research exploits and blog posts on my

17
00:00:48,800 --> 00:00:50,640
twitter and github

18
00:00:50,640 --> 00:00:53,920
i speak english spanish italian and i'm

19
00:00:53,920 --> 00:00:56,160
learning chinese

20
00:00:56,160 --> 00:00:58,480
i'm going to give the presentation

21
00:00:58,480 --> 00:01:00,960
presentation in english

22
00:01:00,960 --> 00:01:01,920
for

23
00:01:01,920 --> 00:01:04,559
for simplicity but if you would like to

24
00:01:04,559 --> 00:01:07,759
uh ask questions

25
00:01:09,520 --> 00:01:13,000
perfect is

26
00:01:17,040 --> 00:01:19,520
so that's about me

27
00:01:19,520 --> 00:01:20,400
um

28
00:01:20,400 --> 00:01:23,759
so let's do a little primer on what ebpf

29
00:01:23,759 --> 00:01:27,040
exactly is so originally

30
00:01:27,040 --> 00:01:28,400
ebpf

31
00:01:28,400 --> 00:01:30,400
stands for extended berkeley packet

32
00:01:30,400 --> 00:01:31,600
filter

33
00:01:31,600 --> 00:01:34,240
and it was originally just berkeley

34
00:01:34,240 --> 00:01:36,400
packet filter and it was created to do

35
00:01:36,400 --> 00:01:39,600
packet filtering directly in the kernel

36
00:01:39,600 --> 00:01:41,119
was later

37
00:01:41,119 --> 00:01:43,439
recoded and redesigned into extended

38
00:01:43,439 --> 00:01:44,720
ebpf

39
00:01:44,720 --> 00:01:46,159
and

40
00:01:46,159 --> 00:01:49,200
simply what it does is it allows you to

41
00:01:49,200 --> 00:01:52,079
run kernel code without loading a local

42
00:01:52,079 --> 00:01:54,079
kernel module

43
00:01:54,079 --> 00:01:57,039
basically a driver

44
00:01:59,040 --> 00:02:01,840
why is it used

45
00:02:02,000 --> 00:02:04,240
it

46
00:02:04,479 --> 00:02:06,719
it's better because developers don't

47
00:02:06,719 --> 00:02:10,080
need to know how to develop kernel code

48
00:02:10,080 --> 00:02:11,200
so

49
00:02:11,200 --> 00:02:14,720
there's a subsection of developers that

50
00:02:14,720 --> 00:02:17,360
only write kernel code and

51
00:02:17,360 --> 00:02:19,280
it kind of

52
00:02:19,280 --> 00:02:21,040
is its own separate thing

53
00:02:21,040 --> 00:02:24,319
um and

54
00:02:24,319 --> 00:02:27,920
maybe intimidating to some developers or

55
00:02:27,920 --> 00:02:30,000
don't want to bother with it it's easier

56
00:02:30,000 --> 00:02:32,959
to write ebpf programs and there's some

57
00:02:32,959 --> 00:02:35,760
performance advantages to run things

58
00:02:35,760 --> 00:02:37,840
directly in the kernel

59
00:02:37,840 --> 00:02:42,400
modern hardware is now kind of

60
00:02:44,000 --> 00:02:45,760
designed to

61
00:02:45,760 --> 00:02:48,400
optimize asynchronous programming

62
00:02:48,400 --> 00:02:49,840
and

63
00:02:49,840 --> 00:02:52,000
so there's performance increases and

64
00:02:52,000 --> 00:02:54,000
it's a safe way

65
00:02:54,000 --> 00:02:58,480
safe way to run kernel code presumably

66
00:02:58,480 --> 00:03:00,720
what is it used for uh

67
00:03:00,720 --> 00:03:03,599
many things you can use it to trade for

68
00:03:03,599 --> 00:03:05,519
tracing debugging

69
00:03:05,519 --> 00:03:07,760
instrumentation such as like hooking

70
00:03:07,760 --> 00:03:09,360
syscalls to see

71
00:03:09,360 --> 00:03:11,200
what comes out of them and of course

72
00:03:11,200 --> 00:03:13,360
packet capture filtering which was the

73
00:03:13,360 --> 00:03:15,280
original intended use

74
00:03:15,280 --> 00:03:18,239
um even writing root kits it's actually

75
00:03:18,239 --> 00:03:20,480
kind of fun and interesting to write

76
00:03:20,480 --> 00:03:23,040
root kits with for ebpf there was a

77
00:03:23,040 --> 00:03:24,319
couple of

78
00:03:24,319 --> 00:03:26,239
uh really interesting def con talks

79
00:03:26,239 --> 00:03:27,200
about

80
00:03:27,200 --> 00:03:29,680
using ebpf to write root kits

81
00:03:29,680 --> 00:03:32,319
presuming that you have root access to

82
00:03:32,319 --> 00:03:34,720
begin with

83
00:03:34,720 --> 00:03:37,599
it's a nice feature

84
00:03:37,920 --> 00:03:40,080
one other thing

85
00:03:40,080 --> 00:03:41,519
somebody asked me

86
00:03:41,519 --> 00:03:42,959
recently

87
00:03:42,959 --> 00:03:46,480
what are like modern use cases of ebpf

88
00:03:46,480 --> 00:03:49,599
i think netflix has

89
00:03:49,599 --> 00:03:51,599
started to use eppf

90
00:03:51,599 --> 00:03:53,519
in there

91
00:03:53,519 --> 00:03:55,280
to run their programs directly in the

92
00:03:55,280 --> 00:03:56,239
kernel

93
00:03:56,239 --> 00:03:57,519
and

94
00:03:57,519 --> 00:04:00,400
quite recently sysmon for linux has been

95
00:04:00,400 --> 00:04:02,159
released and i believe

96
00:04:02,159 --> 00:04:04,000
they are using evpf

97
00:04:04,000 --> 00:04:05,360
um

98
00:04:05,360 --> 00:04:06,959
although i haven't gotten a chance to

99
00:04:06,959 --> 00:04:09,040
look at their source code so those are

100
00:04:09,040 --> 00:04:11,360
some like

101
00:04:11,360 --> 00:04:15,439
concrete examples of how evpf is used in

102
00:04:15,439 --> 00:04:16,798
current

103
00:04:16,798 --> 00:04:20,560
modern use technology

104
00:04:20,639 --> 00:04:22,320
so how does it work

105
00:04:22,320 --> 00:04:24,880
so first the developer begins by writing

106
00:04:24,880 --> 00:04:27,040
an ebpf program in a higher level

107
00:04:27,040 --> 00:04:29,600
language um

108
00:04:29,600 --> 00:04:31,360
usually in a

109
00:04:31,360 --> 00:04:33,440
simplified version of c

110
00:04:33,440 --> 00:04:35,840
or python

111
00:04:35,840 --> 00:04:36,960
there are

112
00:04:36,960 --> 00:04:39,280
you know competing tool chains

113
00:04:39,280 --> 00:04:42,000
that are coming out um probably the most

114
00:04:42,000 --> 00:04:44,720
popular is bcc

115
00:04:44,720 --> 00:04:46,800
which will compile

116
00:04:46,800 --> 00:04:48,639
the higher level

117
00:04:48,639 --> 00:04:51,040
program into bytecode

118
00:04:51,040 --> 00:04:53,520
and the bytecode is a simple instruction

119
00:04:53,520 --> 00:04:56,479
set it's very similar to x86

120
00:04:56,479 --> 00:04:59,840
um it utilizes 12 registers one stack

121
00:04:59,840 --> 00:05:02,479
register and one auxiliary for strategy

122
00:05:02,479 --> 00:05:04,960
checks and it has an implicit program

123
00:05:04,960 --> 00:05:07,359
counter

124
00:05:08,400 --> 00:05:11,199
so once the bytecode is compiled the

125
00:05:11,199 --> 00:05:13,039
user mode application will load the

126
00:05:13,039 --> 00:05:16,000
bytecode in the kernel using a ebpf

127
00:05:16,000 --> 00:05:18,560
syscall so it'll have the

128
00:05:18,560 --> 00:05:20,160
you know some buffer

129
00:05:20,160 --> 00:05:22,479
with the bytecode instructions and it

130
00:05:22,479 --> 00:05:25,199
will pass that buffer into

131
00:05:25,199 --> 00:05:28,880
um the kernel using a bpf cisco

132
00:05:28,880 --> 00:05:32,160
at that point um the ebpf verifier will

133
00:05:32,160 --> 00:05:34,080
perform checks on the bytecode and make

134
00:05:34,080 --> 00:05:35,759
sure it's safe

135
00:05:35,759 --> 00:05:37,280
and if the checks are

136
00:05:37,280 --> 00:05:39,680
passed the byte code is

137
00:05:39,680 --> 00:05:42,080
uh jit compiled into the native

138
00:05:42,080 --> 00:05:44,160
instruction set depending on the

139
00:05:44,160 --> 00:05:45,440
architecture

140
00:05:45,440 --> 00:05:46,320
um

141
00:05:46,320 --> 00:05:48,160
that's running

142
00:05:48,160 --> 00:05:49,199
or

143
00:05:49,199 --> 00:05:51,600
this depends on a kernel configuration

144
00:05:51,600 --> 00:05:52,560
so

145
00:05:52,560 --> 00:05:54,880
if the kernel configuration specifies

146
00:05:54,880 --> 00:05:57,520
that ebpf should be jit compiled it'll

147
00:05:57,520 --> 00:05:59,919
be j-compiled if not then the ebpf

148
00:05:59,919 --> 00:06:01,199
interpreter

149
00:06:01,199 --> 00:06:02,319
will

150
00:06:02,319 --> 00:06:03,280
run

151
00:06:03,280 --> 00:06:05,840
interpret and run the

152
00:06:05,840 --> 00:06:08,000
um at each specific time it's supposed

153
00:06:08,000 --> 00:06:11,360
to run but usually the default is to

154
00:06:11,360 --> 00:06:14,479
compile um that's usually enabled in in

155
00:06:14,479 --> 00:06:18,880
most um linux distributions

156
00:06:19,199 --> 00:06:20,560
um

157
00:06:20,560 --> 00:06:23,199
okay so after that uh the application

158
00:06:23,199 --> 00:06:26,319
will attach the program to a hook point

159
00:06:26,319 --> 00:06:27,440
um

160
00:06:27,440 --> 00:06:29,120
where upon

161
00:06:29,120 --> 00:06:32,319
an event the program will run it's event

162
00:06:32,319 --> 00:06:35,680
based execution

163
00:06:35,680 --> 00:06:37,840
in particular we're kind of interested

164
00:06:37,840 --> 00:06:38,880
in where

165
00:06:38,880 --> 00:06:41,440
unprivileged users are allowed to run

166
00:06:41,440 --> 00:06:43,600
evf programs

167
00:06:43,600 --> 00:06:45,919
and whether they are or not depends on

168
00:06:45,919 --> 00:06:48,639
the assist control knob unprivileged ppf

169
00:06:48,639 --> 00:06:49,840
disabled

170
00:06:49,840 --> 00:06:51,039
um

171
00:06:51,039 --> 00:06:52,720
privileged users are limited to where

172
00:06:52,720 --> 00:06:54,720
their program can hook so

173
00:06:54,720 --> 00:06:57,919
they can't really hook uh

174
00:06:57,919 --> 00:06:59,520
syscalls or

175
00:06:59,520 --> 00:07:01,199
anywhere they want they

176
00:07:01,199 --> 00:07:03,680
they're mostly limited to

177
00:07:03,680 --> 00:07:08,400
a socket that the user itself owns

178
00:07:08,400 --> 00:07:11,520
and to interact with the ebpf program

179
00:07:11,520 --> 00:07:13,360
the application

180
00:07:13,360 --> 00:07:16,000
can interact with it giving input or

181
00:07:16,000 --> 00:07:19,199
receiving output with ebpf maths and

182
00:07:19,199 --> 00:07:20,800
helper functions

183
00:07:20,800 --> 00:07:25,199
um so this is kind of how uh

184
00:07:25,199 --> 00:07:27,120
uh asynchronous

185
00:07:27,120 --> 00:07:28,720
programming model

186
00:07:28,720 --> 00:07:31,120
uh will come in so

187
00:07:31,120 --> 00:07:33,520
the current of the ebpf program will run

188
00:07:33,520 --> 00:07:34,639
in the kernel

189
00:07:34,639 --> 00:07:36,960
will do its thing and the user mode

190
00:07:36,960 --> 00:07:38,639
program

191
00:07:38,639 --> 00:07:41,280
at its leisure can check in and get

192
00:07:41,280 --> 00:07:42,479
results

193
00:07:42,479 --> 00:07:45,759
or give uh change its input

194
00:07:45,759 --> 00:07:47,199
to uh

195
00:07:47,199 --> 00:07:48,879
the program

196
00:07:48,879 --> 00:07:50,160
when it sees

197
00:07:50,160 --> 00:07:52,240
fit but the kernel program will run

198
00:07:52,240 --> 00:07:54,800
independently

199
00:07:54,800 --> 00:07:58,240
um so a little bit more about evpf maps

200
00:07:58,240 --> 00:08:00,080
which is how the user mode application

201
00:08:00,080 --> 00:08:02,240
will interact with the program

202
00:08:02,240 --> 00:08:04,800
it's a generic key value store with an

203
00:08:04,800 --> 00:08:07,360
arbitrary data structure some examples

204
00:08:07,360 --> 00:08:08,639
are arrays

205
00:08:08,639 --> 00:08:10,560
stacks cues

206
00:08:10,560 --> 00:08:12,720
very simple data structures that are

207
00:08:12,720 --> 00:08:15,199
available and it's defined

208
00:08:15,199 --> 00:08:17,599
by five attributes type

209
00:08:17,599 --> 00:08:21,039
key size which is the value of the

210
00:08:21,039 --> 00:08:22,800
key value store

211
00:08:22,800 --> 00:08:25,599
the value size the size of the value the

212
00:08:25,599 --> 00:08:26,960
max entry

213
00:08:26,960 --> 00:08:29,759
basically defines the size of the map

214
00:08:29,759 --> 00:08:32,640
and map flags which

215
00:08:32,640 --> 00:08:35,200
give you the ability to

216
00:08:35,200 --> 00:08:37,200
change a little bit about how the map

217
00:08:37,200 --> 00:08:39,360
behaves

218
00:08:39,360 --> 00:08:41,919
this is a diagram that my colleague

219
00:08:41,919 --> 00:08:43,279
andrea

220
00:08:43,279 --> 00:08:45,040
helped me create

221
00:08:45,040 --> 00:08:47,760
as you can see it's divided between user

222
00:08:47,760 --> 00:08:49,760
space and kernel space

223
00:08:49,760 --> 00:08:51,440
the tool chain

224
00:08:51,440 --> 00:08:54,240
compiles the ebpf program to bite code

225
00:08:54,240 --> 00:08:55,680
in user space

226
00:08:55,680 --> 00:08:57,200
the process that will actually do the

227
00:08:57,200 --> 00:08:58,240
loading

228
00:08:58,240 --> 00:09:00,320
has the bytecode and some buffer which

229
00:09:00,320 --> 00:09:01,680
will pass it

230
00:09:01,680 --> 00:09:04,800
via ebpfciscall into the verifier

231
00:09:04,800 --> 00:09:06,880
the verifier will check it

232
00:09:06,880 --> 00:09:10,080
if it passes will jit compile it

233
00:09:10,080 --> 00:09:11,760
then the

234
00:09:11,760 --> 00:09:13,120
user

235
00:09:13,120 --> 00:09:15,600
user mode application will attach it to

236
00:09:15,600 --> 00:09:17,839
a hook point

237
00:09:17,839 --> 00:09:20,240
and the ebpf jit runner or the

238
00:09:20,240 --> 00:09:24,000
interpreter will actually run the native

239
00:09:24,000 --> 00:09:26,720
or interpreted instructions upon some

240
00:09:26,720 --> 00:09:27,680
event

241
00:09:27,680 --> 00:09:30,880
depending on the on the um

242
00:09:30,880 --> 00:09:32,320
hook point

243
00:09:32,320 --> 00:09:34,160
and so the user

244
00:09:34,160 --> 00:09:35,120
space

245
00:09:35,120 --> 00:09:37,120
application process

246
00:09:37,120 --> 00:09:39,519
can interact with the program

247
00:09:39,519 --> 00:09:43,200
using uh again evp of syscalls

248
00:09:43,200 --> 00:09:44,080
um

249
00:09:44,080 --> 00:09:45,120
to

250
00:09:45,120 --> 00:09:48,399
change and receive values in the map

251
00:09:48,399 --> 00:09:50,959
so we'll do i o with the ebf program in

252
00:09:50,959 --> 00:09:53,439
the kernel

253
00:09:54,080 --> 00:09:57,440
so the interesting thing is so we're

254
00:09:57,440 --> 00:10:01,200
looking at this from a perspective of

255
00:10:01,200 --> 00:10:02,160
uh

256
00:10:02,160 --> 00:10:05,120
me which i am an exploit developer

257
00:10:05,120 --> 00:10:07,680
the most interesting thing to me is

258
00:10:07,680 --> 00:10:09,519
what is the attack surface

259
00:10:09,519 --> 00:10:11,279
how can we look at

260
00:10:11,279 --> 00:10:13,920
and prod the weak points in this

261
00:10:13,920 --> 00:10:16,560
technology if you're allowing

262
00:10:16,560 --> 00:10:18,640
unprivileged users who run code in the

263
00:10:18,640 --> 00:10:19,680
kernel

264
00:10:19,680 --> 00:10:20,959
even though you

265
00:10:20,959 --> 00:10:23,519
are sandboxing and giving severe

266
00:10:23,519 --> 00:10:25,200
limitations

267
00:10:25,200 --> 00:10:26,390
there has to be some

268
00:10:26,390 --> 00:10:27,920
[Music]

269
00:10:27,920 --> 00:10:29,519
place where you can try to find

270
00:10:29,519 --> 00:10:31,440
vulnerabilities

271
00:10:31,440 --> 00:10:33,279
the first one that um

272
00:10:33,279 --> 00:10:35,040
seemed obvious to me when i first

273
00:10:35,040 --> 00:10:37,040
started looking at this

274
00:10:37,040 --> 00:10:40,640
um was the ebpf verifier which is the

275
00:10:40,640 --> 00:10:43,040
thing that actually analyzes

276
00:10:43,040 --> 00:10:44,640
the program that you're trying to load

277
00:10:44,640 --> 00:10:46,880
in the kernel and determines whether

278
00:10:46,880 --> 00:10:48,720
it's safe or not

279
00:10:48,720 --> 00:10:50,560
so you can use vulnerabilities in the

280
00:10:50,560 --> 00:10:52,720
verifier code to trick the kernel into

281
00:10:52,720 --> 00:10:55,440
loading unsafe bytecode

282
00:10:55,440 --> 00:10:58,000
and they usually present as arithmetic

283
00:10:58,000 --> 00:11:02,399
and logic errors another one um is in

284
00:11:02,399 --> 00:11:05,040
the ebpf jet compiler itself

285
00:11:05,040 --> 00:11:06,079
um

286
00:11:06,079 --> 00:11:07,600
mistakes in how

287
00:11:07,600 --> 00:11:10,480
the evpf by code is compiled into the

288
00:11:10,480 --> 00:11:12,839
native architecture

289
00:11:12,839 --> 00:11:15,440
uh assembly language

290
00:11:15,440 --> 00:11:16,560
um

291
00:11:16,560 --> 00:11:19,120
and i will get into examples of each of

292
00:11:19,120 --> 00:11:20,000
these

293
00:11:20,000 --> 00:11:21,839
um in a minute

294
00:11:21,839 --> 00:11:23,600
and as well as

295
00:11:23,600 --> 00:11:26,320
separate from the actual evpf code is

296
00:11:26,320 --> 00:11:28,480
using ebf programs as an exploit

297
00:11:28,480 --> 00:11:30,399
primitive so even though there's not

298
00:11:30,399 --> 00:11:33,839
vulnerabilities in ebef itself ebpf

299
00:11:33,839 --> 00:11:36,480
can be used

300
00:11:36,480 --> 00:11:39,040
to leverage other exploits in the linux

301
00:11:39,040 --> 00:11:40,399
kernel

302
00:11:40,399 --> 00:11:42,880
as a primitive i will also

303
00:11:42,880 --> 00:11:44,079
um

304
00:11:44,079 --> 00:11:46,720
give an example of one that's happened

305
00:11:46,720 --> 00:11:48,880
before in recent time within the last

306
00:11:48,880 --> 00:11:51,279
couple of months too

307
00:11:51,279 --> 00:11:54,480
um so attacks how has evpf been used in

308
00:11:54,480 --> 00:11:56,720
modern exploits so

309
00:11:56,720 --> 00:12:01,160
in particular in the ebpf verifier cve

310
00:12:01,160 --> 00:12:02,880
2021-3490

311
00:12:02,880 --> 00:12:03,920
um

312
00:12:03,920 --> 00:12:05,760
using register brown tracking to trick

313
00:12:05,760 --> 00:12:07,360
the verifier into thinking register

314
00:12:07,360 --> 00:12:10,480
contains a constant value of 0 to gain a

315
00:12:10,480 --> 00:12:13,839
kernel read write primitive

316
00:12:14,240 --> 00:12:18,079
in the case of the ebpf jet compiler

317
00:12:18,079 --> 00:12:20,240
our recent vulnerability the jig

318
00:12:20,240 --> 00:12:23,519
compiler inaccurately calculated branch

319
00:12:23,519 --> 00:12:26,959
displacements so this was used to hijack

320
00:12:26,959 --> 00:12:28,480
control flow

321
00:12:28,480 --> 00:12:29,760
um

322
00:12:29,760 --> 00:12:34,000
of the program so it passed all the evpf

323
00:12:34,000 --> 00:12:35,839
verifier attacks

324
00:12:35,839 --> 00:12:40,000
but the way the bike code was compiled

325
00:12:40,000 --> 00:12:42,320
what um

326
00:12:42,320 --> 00:12:44,000
there was a

327
00:12:44,000 --> 00:12:47,120
a mistake in it so

328
00:12:47,120 --> 00:12:50,079
even though the program

329
00:12:50,079 --> 00:12:53,279
was supposed to branch to another place

330
00:12:53,279 --> 00:12:54,399
in the

331
00:12:54,399 --> 00:12:56,240
assembly it

332
00:12:56,240 --> 00:12:59,600
went to another so the uh

333
00:12:59,600 --> 00:13:02,320
the verifier didn't account for

334
00:13:02,320 --> 00:13:04,480
jumping to further down and so then you

335
00:13:04,480 --> 00:13:05,360
could

336
00:13:05,360 --> 00:13:08,880
trick the verifier into thinking

337
00:13:08,880 --> 00:13:11,279
something was happening when it wasn't

338
00:13:11,279 --> 00:13:12,320
um

339
00:13:12,320 --> 00:13:15,680
and using ebpf as an exploit primitive

340
00:13:15,680 --> 00:13:18,639
a great example of this was qualis

341
00:13:18,639 --> 00:13:22,160
using um cv 2021

342
00:13:22,160 --> 00:13:26,399
support uh 39909 sequoia which is just a

343
00:13:26,399 --> 00:13:28,320
memory corruption vulnerability and file

344
00:13:28,320 --> 00:13:29,279
system

345
00:13:29,279 --> 00:13:31,360
um and they actually use this to

346
00:13:31,360 --> 00:13:34,079
overwrite ebpf by code that already made

347
00:13:34,079 --> 00:13:36,000
it past the verifier check so it was

348
00:13:36,000 --> 00:13:37,040
like

349
00:13:37,040 --> 00:13:39,680
technically correct

350
00:13:39,680 --> 00:13:40,800
um

351
00:13:40,800 --> 00:13:44,079
or a valid ebpf program but like it was

352
00:13:44,079 --> 00:13:47,120
later overwritten

353
00:13:47,199 --> 00:13:48,480
to

354
00:13:48,480 --> 00:13:50,480
other instruction set or other

355
00:13:50,480 --> 00:13:51,760
instructions

356
00:13:51,760 --> 00:13:53,680
um

357
00:13:53,680 --> 00:13:56,399
when that happened

358
00:13:56,399 --> 00:13:58,720
uh they were able to gain a read write

359
00:13:58,720 --> 00:13:59,920
primitive

360
00:13:59,920 --> 00:14:02,320
because it made it past the the verifier

361
00:14:02,320 --> 00:14:03,680
step and

362
00:14:03,680 --> 00:14:06,959
other memory corruption vulnerability

363
00:14:06,959 --> 00:14:09,760
overwrote that

364
00:14:09,839 --> 00:14:12,240
so the ebpf verifier enforces these

365
00:14:12,240 --> 00:14:14,480
general rules

366
00:14:14,480 --> 00:14:16,720
no back edges loops are unreachable

367
00:14:16,720 --> 00:14:18,720
obstructions

368
00:14:18,720 --> 00:14:21,199
no pointer comparisons and

369
00:14:21,199 --> 00:14:22,880
the only pointer arithmetic that's

370
00:14:22,880 --> 00:14:25,600
allowed is with scalar registers and in

371
00:14:25,600 --> 00:14:27,600
this case scalar registers are defined

372
00:14:27,600 --> 00:14:29,519
as registers that do not contain a

373
00:14:29,519 --> 00:14:30,480
pointer

374
00:14:30,480 --> 00:14:32,079
so like a

375
00:14:32,079 --> 00:14:34,560
a scalar value

376
00:14:34,560 --> 00:14:37,279
and pointers cannot point outside of the

377
00:14:37,279 --> 00:14:39,440
bounds of an evpf map which is like a

378
00:14:39,440 --> 00:14:41,600
predefined

379
00:14:41,600 --> 00:14:44,560
area of memory that you use to do i o

380
00:14:44,560 --> 00:14:47,519
with a user space application

381
00:14:47,519 --> 00:14:50,320
and pointers can't be stored in a map or

382
00:14:50,320 --> 00:14:52,160
as a return value

383
00:14:52,160 --> 00:14:53,839
because that would leak kernel memory

384
00:14:53,839 --> 00:14:54,959
addresses

385
00:14:54,959 --> 00:14:58,160
and that's not allowed particularly if

386
00:14:58,160 --> 00:15:01,360
it's an unprivileged user

387
00:15:01,600 --> 00:15:04,320
um so one of the important aspects of

388
00:15:04,320 --> 00:15:08,079
the ebpf verifier is range tracking

389
00:15:08,079 --> 00:15:11,360
so the verifier will track the bounds

390
00:15:11,360 --> 00:15:15,040
for each register in each execution path

391
00:15:15,040 --> 00:15:18,720
and it has 64-bit and 32-bit hundred

392
00:15:18,720 --> 00:15:21,040
pounds for counterparts for each so

393
00:15:21,040 --> 00:15:22,160
it'll attack

394
00:15:22,160 --> 00:15:26,240
the minimum unsigned integer value the

395
00:15:26,240 --> 00:15:30,560
maximum maximum inside integer value

396
00:15:30,560 --> 00:15:33,920
um and the same for signed

397
00:15:33,920 --> 00:15:35,360
it also will

398
00:15:35,360 --> 00:15:37,600
store information

399
00:15:37,600 --> 00:15:38,480
in a

400
00:15:38,480 --> 00:15:41,199
field called a structure called var off

401
00:15:41,199 --> 00:15:43,040
which is a t num structure that contains

402
00:15:43,040 --> 00:15:44,480
information about

403
00:15:44,480 --> 00:15:46,480
which of the bits of the register are

404
00:15:46,480 --> 00:15:50,480
known or unknown during static analysis

405
00:15:50,480 --> 00:15:54,639
um so if you can kind of imagine

406
00:15:56,480 --> 00:15:58,079
through various

407
00:15:58,079 --> 00:16:01,199
flows of logic you can kind of

408
00:16:01,199 --> 00:16:04,240
gleam information about like

409
00:16:04,240 --> 00:16:05,839
what are the

410
00:16:05,839 --> 00:16:08,000
constraints of what the value of some

411
00:16:08,000 --> 00:16:09,600
constant

412
00:16:09,600 --> 00:16:11,120
register

413
00:16:11,120 --> 00:16:14,240
um and so then those are updated in this

414
00:16:14,240 --> 00:16:16,560
structure called var off which is tnm

415
00:16:16,560 --> 00:16:18,399
structure that i'll cover

416
00:16:18,399 --> 00:16:20,560
shortly

417
00:16:20,560 --> 00:16:22,720
so it contains two 64

418
00:16:22,720 --> 00:16:25,519
bit fields mask and value

419
00:16:25,519 --> 00:16:28,000
both can be interpreted as big vectors

420
00:16:28,000 --> 00:16:30,560
if a bit is set in mask the value of

421
00:16:30,560 --> 00:16:32,560
that bit is unknown

422
00:16:32,560 --> 00:16:34,560
and if the bit isn't set then the value

423
00:16:34,560 --> 00:16:36,399
is known and the known value is

424
00:16:36,399 --> 00:16:40,720
contained in the value field

425
00:16:40,720 --> 00:16:43,360
an example is if we have a register

426
00:16:43,360 --> 00:16:45,600
where the lower 32 bits are known to be

427
00:16:45,600 --> 00:16:48,880
one and the upper 32 bits are known

428
00:16:48,880 --> 00:16:52,480
then far off for the upper 32 bits

429
00:16:52,480 --> 00:16:54,079
will all be set because they're all

430
00:16:54,079 --> 00:16:57,199
unknown and the lower 32 bits will be

431
00:16:57,199 --> 00:16:58,880
set to

432
00:16:58,880 --> 00:17:00,480
equal to 3.

433
00:17:00,480 --> 00:17:01,440
um

434
00:17:01,440 --> 00:17:02,800
so

435
00:17:02,800 --> 00:17:06,079
uh the lower 32 bits of mask are all on

436
00:17:06,079 --> 00:17:09,280
set because we know all of the 32 bits

437
00:17:09,280 --> 00:17:12,959
of the the lower 32 bits

438
00:17:13,199 --> 00:17:15,439
another thing that ebpf firefighter does

439
00:17:15,439 --> 00:17:16,160
is

440
00:17:16,160 --> 00:17:19,280
alu sanutation which supplements the

441
00:17:19,280 --> 00:17:21,679
static range tracking um

442
00:17:21,679 --> 00:17:24,720
so we have some idea of what is going to

443
00:17:24,720 --> 00:17:28,079
happen during static analysis but it's

444
00:17:28,079 --> 00:17:31,039
patching in instructions to do dynamic

445
00:17:31,039 --> 00:17:33,039
checks during execution

446
00:17:33,039 --> 00:17:35,919
uh to make sure that the actual during

447
00:17:35,919 --> 00:17:39,120
run time the values of this register

448
00:17:39,120 --> 00:17:41,039
stay within what

449
00:17:41,039 --> 00:17:43,120
the verifier thinks

450
00:17:43,120 --> 00:17:44,799
they're going to be

451
00:17:44,799 --> 00:17:48,160
um so an alu limit represents the

452
00:17:48,160 --> 00:17:49,919
maximum absolute value that could be

453
00:17:49,919 --> 00:17:52,160
added or subtracted to a pointer before

454
00:17:52,160 --> 00:17:54,480
crossing the bounds of a map so getting

455
00:17:54,480 --> 00:17:57,120
into memory that um

456
00:17:57,120 --> 00:17:59,200
they shouldn't be getting into

457
00:17:59,200 --> 00:18:01,200
and so how the limit is calculated has

458
00:18:01,200 --> 00:18:03,760
changed over time so very recently

459
00:18:03,760 --> 00:18:06,799
it's been drastically changed um one

460
00:18:06,799 --> 00:18:08,960
interesting thing is is that uh this

461
00:18:08,960 --> 00:18:13,840
vulnerability cve 2020 27171

462
00:18:13,840 --> 00:18:16,160
basically rendered alu sanitation

463
00:18:16,160 --> 00:18:18,799
useless for a very long time and it went

464
00:18:18,799 --> 00:18:20,880
unnoticed even though

465
00:18:20,880 --> 00:18:22,320
there were several

466
00:18:22,320 --> 00:18:25,600
public evpf exploits that leveraged

467
00:18:25,600 --> 00:18:27,120
leveraged it and

468
00:18:27,120 --> 00:18:29,280
no one really noticed that alu

469
00:18:29,280 --> 00:18:31,120
sanitation

470
00:18:31,120 --> 00:18:34,160
did wasn't working um until

471
00:18:34,160 --> 00:18:36,480
may of this year so just a few months

472
00:18:36,480 --> 00:18:38,400
ago

473
00:18:38,400 --> 00:18:42,080
okay so now i'm going to cover cve 2021

474
00:18:42,080 --> 00:18:43,840
3490

475
00:18:43,840 --> 00:18:45,280
which is the

476
00:18:45,280 --> 00:18:49,600
vulnerability that i exploited to

477
00:18:50,080 --> 00:18:50,880
do

478
00:18:50,880 --> 00:18:52,640
privilege escalation

479
00:18:52,640 --> 00:18:56,320
on many uh distributions of linux

480
00:18:56,320 --> 00:18:57,760
i thought it was kind of interesting

481
00:18:57,760 --> 00:19:00,640
because it wasn't an arithmetic error or

482
00:19:00,640 --> 00:19:02,320
like a bounce competing error it was

483
00:19:02,320 --> 00:19:04,240
actually a logic bug

484
00:19:04,240 --> 00:19:05,280
um

485
00:19:05,280 --> 00:19:07,120
the way that it worked was the value of

486
00:19:07,120 --> 00:19:10,880
far off wasn't updated after 32-bit and

487
00:19:10,880 --> 00:19:12,000
xor

488
00:19:12,000 --> 00:19:15,280
and or instructions if the upper 32-bits

489
00:19:15,280 --> 00:19:17,679
of the registers were unknown

490
00:19:17,679 --> 00:19:18,559
um

491
00:19:18,559 --> 00:19:20,720
this allowed the track bounds of the

492
00:19:20,720 --> 00:19:23,440
destination register of that operation

493
00:19:23,440 --> 00:19:27,360
to become invalid or corrupted

494
00:19:28,240 --> 00:19:30,000
so here is

495
00:19:30,000 --> 00:19:33,760
a screenshot of the offending code

496
00:19:33,760 --> 00:19:36,400
and the comment here is that if you

497
00:19:36,400 --> 00:19:37,520
assume

498
00:19:37,520 --> 00:19:38,880
um

499
00:19:38,880 --> 00:19:41,919
if the source and destination register

500
00:19:41,919 --> 00:19:43,760
values are known

501
00:19:43,760 --> 00:19:46,080
then don't update

502
00:19:46,080 --> 00:19:47,919
the um

503
00:19:47,919 --> 00:19:50,080
the destination register

504
00:19:50,080 --> 00:19:53,679
um and the problem here is is that um

505
00:19:53,679 --> 00:19:57,039
how source known and destination known

506
00:19:57,039 --> 00:20:00,000
are computed in the 32-pip case

507
00:20:00,000 --> 00:20:02,640
um only compares

508
00:20:02,640 --> 00:20:03,600
um

509
00:20:03,600 --> 00:20:07,520
the 32-bit register however

510
00:20:07,520 --> 00:20:10,480
it says here assuming scalar 64 min max

511
00:20:10,480 --> 00:20:12,000
will be called so it's safe to skip

512
00:20:12,000 --> 00:20:13,440
updating

513
00:20:13,440 --> 00:20:16,640
scalar 64 min max will only update the

514
00:20:16,640 --> 00:20:19,520
registers if the entire 64-bits are

515
00:20:19,520 --> 00:20:20,720
known

516
00:20:20,720 --> 00:20:23,760
in this case only the lower 32 bits are

517
00:20:23,760 --> 00:20:24,720
known

518
00:20:24,720 --> 00:20:25,840
so

519
00:20:25,840 --> 00:20:29,120
once you compute the new bounds

520
00:20:29,120 --> 00:20:32,880
they become corrupted because

521
00:20:32,880 --> 00:20:34,880
they didn't become updated after this

522
00:20:34,880 --> 00:20:37,440
operation

523
00:20:37,520 --> 00:20:40,000
so how do we trigger this bug

524
00:20:40,000 --> 00:20:42,720
we need to prepare two registers

525
00:20:42,720 --> 00:20:45,600
uh one register the first one

526
00:20:45,600 --> 00:20:47,679
all 64 bits are known

527
00:20:47,679 --> 00:20:51,039
and the register is equal to

528
00:20:51,039 --> 00:20:52,480
this value

529
00:20:52,480 --> 00:20:53,679
um

530
00:20:53,679 --> 00:20:56,799
so bar of rf.mask

531
00:20:56,799 --> 00:20:57,679
is

532
00:20:57,679 --> 00:21:02,080
0 because we know all 64 bits and bar of

533
00:21:02,080 --> 00:21:04,159
dot value is equal to

534
00:21:04,159 --> 00:21:07,039
the actual value of the register

535
00:21:07,039 --> 00:21:08,080
and

536
00:21:08,080 --> 00:21:11,039
r2 the lower 32 bits are known and equal

537
00:21:11,039 --> 00:21:13,600
to 1 and the upper 32 bits are known so

538
00:21:13,600 --> 00:21:16,960
the upper 32 bits of far off dot mask

539
00:21:16,960 --> 00:21:18,480
are all set

540
00:21:18,480 --> 00:21:20,880
and the lower 32 bits are equal to the

541
00:21:20,880 --> 00:21:24,000
actual value which is one

542
00:21:24,640 --> 00:21:27,039
so to trigger this bug we perform an and

543
00:21:27,039 --> 00:21:29,200
operation on the two registers

544
00:21:29,200 --> 00:21:30,960
and the destination register should be

545
00:21:30,960 --> 00:21:32,960
the one with the unknown

546
00:21:32,960 --> 00:21:35,039
uh upper 32 bits

547
00:21:35,039 --> 00:21:37,120
so

548
00:21:37,120 --> 00:21:38,320
this is the

549
00:21:38,320 --> 00:21:41,039
the instruction the bpf and instruction

550
00:21:41,039 --> 00:21:43,120
and the destination register is we're

551
00:21:43,120 --> 00:21:46,559
going to call it the exploit register

552
00:21:46,559 --> 00:21:49,600
the result is corrupting 32-bit bounds

553
00:21:49,600 --> 00:21:51,919
when you see the the minimum value is

554
00:21:51,919 --> 00:21:54,400
equal to one and the maximum value is

555
00:21:54,400 --> 00:21:57,039
equal to zero so we know that these are

556
00:21:57,039 --> 00:21:59,120
corrupted because the minimum value is

557
00:21:59,120 --> 00:22:01,200
greater than the maximum value

558
00:22:01,200 --> 00:22:02,960
and the true value of the register at

559
00:22:02,960 --> 00:22:04,159
runtime

560
00:22:04,159 --> 00:22:08,240
will be zero during our exploit

561
00:22:08,240 --> 00:22:11,360
um so the verifier will check all paths

562
00:22:11,360 --> 00:22:13,360
for execution

563
00:22:13,360 --> 00:22:15,919
and some are removed for optimization

564
00:22:15,919 --> 00:22:17,760
for example jump conditional paths are

565
00:22:17,760 --> 00:22:19,919
trimmed by checking minimum

566
00:22:19,919 --> 00:22:22,640
maximum bounds so if you can imagine

567
00:22:22,640 --> 00:22:24,320
um if you have like a greater than or

568
00:22:24,320 --> 00:22:27,280
equal to operation you can kind of

569
00:22:27,280 --> 00:22:28,559
eliminate

570
00:22:28,559 --> 00:22:29,360
uh

571
00:22:29,360 --> 00:22:32,159
a lot of those paths if you kind if you

572
00:22:32,159 --> 00:22:33,520
already have

573
00:22:33,520 --> 00:22:36,159
information about the bounds

574
00:22:36,159 --> 00:22:38,480
of the register and what their possible

575
00:22:38,480 --> 00:22:41,120
values can be

576
00:22:41,120 --> 00:22:43,919
so this is just a quick screenshot of

577
00:22:43,919 --> 00:22:45,440
the function

578
00:22:45,440 --> 00:22:47,280
it will just k uh

579
00:22:47,280 --> 00:22:49,039
just looking at the case of greater than

580
00:22:49,039 --> 00:22:50,480
or equal to

581
00:22:50,480 --> 00:22:53,280
um so it's just looking at the u32

582
00:22:53,280 --> 00:22:54,960
minimum value

583
00:22:54,960 --> 00:22:56,480
and if it is

584
00:22:56,480 --> 00:22:58,720
it returns true and if not it returns

585
00:22:58,720 --> 00:22:59,679
false

586
00:22:59,679 --> 00:23:01,919
so in that case

587
00:23:01,919 --> 00:23:03,840
if the branch is not taken we can just

588
00:23:03,840 --> 00:23:08,199
like completely eliminate it

589
00:23:08,480 --> 00:23:11,360
so i was able to use this bug without

590
00:23:11,360 --> 00:23:12,960
doing anything else just other than

591
00:23:12,960 --> 00:23:14,720
triggering it to

592
00:23:14,720 --> 00:23:16,640
cause dos

593
00:23:16,640 --> 00:23:18,480
so remember the value of our exploit

594
00:23:18,480 --> 00:23:20,960
register will be zero at runtime

595
00:23:20,960 --> 00:23:23,200
so if we do a 32-bit

596
00:23:23,200 --> 00:23:24,240
uh

597
00:23:24,240 --> 00:23:26,960
register comparison conditional

598
00:23:26,960 --> 00:23:27,919
um

599
00:23:27,919 --> 00:23:30,000
the program counter will jump five

600
00:23:30,000 --> 00:23:32,640
instructions if the lower 32-bits of the

601
00:23:32,640 --> 00:23:34,480
exploit register is greater than or

602
00:23:34,480 --> 00:23:35,760
equal to one

603
00:23:35,760 --> 00:23:37,679
even though the value of the register

604
00:23:37,679 --> 00:23:39,600
will be zero

605
00:23:39,600 --> 00:23:42,559
since we have corrupted bounds meaning

606
00:23:42,559 --> 00:23:44,800
that the minimum value is equal to one

607
00:23:44,800 --> 00:23:46,880
[Music]

608
00:23:46,880 --> 00:23:49,360
the verify will think that the program

609
00:23:49,360 --> 00:23:51,440
is going to evaluate to true every

610
00:23:51,440 --> 00:23:53,600
single time even though in this case

611
00:23:53,600 --> 00:23:56,080
it's going to evaluate false

612
00:23:56,080 --> 00:23:57,760
this will allow us to put whatever

613
00:23:57,760 --> 00:24:00,080
instructions we want in the false path

614
00:24:00,080 --> 00:24:02,240
and the verifier

615
00:24:02,240 --> 00:24:04,640
won't reject us it won't check to see if

616
00:24:04,640 --> 00:24:07,039
that path is safe or if we're following

617
00:24:07,039 --> 00:24:10,159
the rules during that path

618
00:24:10,159 --> 00:24:12,000
unfortunately

619
00:24:12,000 --> 00:24:14,880
um the verifier will patch

620
00:24:14,880 --> 00:24:17,279
the the dead branch

621
00:24:17,279 --> 00:24:19,520
path thinking well it's not going to be

622
00:24:19,520 --> 00:24:22,000
taken anyway so we can just patch these

623
00:24:22,000 --> 00:24:23,760
instructions with whatever and it

624
00:24:23,760 --> 00:24:25,679
actually patches the instruction for the

625
00:24:25,679 --> 00:24:26,799
jump back

626
00:24:26,799 --> 00:24:28,720
one instruction

627
00:24:28,720 --> 00:24:31,679
so if this path is hit it will keep

628
00:24:31,679 --> 00:24:34,320
jumping back one instruction

629
00:24:34,320 --> 00:24:35,200
and

630
00:24:35,200 --> 00:24:37,120
cause an into the loop because it keeps

631
00:24:37,120 --> 00:24:38,960
jumping back one evaluating the

632
00:24:38,960 --> 00:24:41,679
conditional jumping back on back one

633
00:24:41,679 --> 00:24:43,919
over and over and over again

634
00:24:43,919 --> 00:24:46,320
so we can cause a dos by launching many

635
00:24:46,320 --> 00:24:48,400
instances of the exploit and lock up all

636
00:24:48,400 --> 00:24:49,840
of the available kernel threads

637
00:24:49,840 --> 00:24:51,039
depending on

638
00:24:51,039 --> 00:24:52,880
how many are available

639
00:24:52,880 --> 00:24:53,919
and

640
00:24:53,919 --> 00:24:57,760
you know hardware conditions

641
00:24:58,000 --> 00:25:00,960
okay so that we were able to cause a dos

642
00:25:00,960 --> 00:25:01,840
um

643
00:25:01,840 --> 00:25:04,080
now we want to actually leverage the bug

644
00:25:04,080 --> 00:25:06,960
for lpe

645
00:25:07,440 --> 00:25:09,520
we need to create a primitive

646
00:25:09,520 --> 00:25:11,679
to create um to be able to do

647
00:25:11,679 --> 00:25:13,600
out-of-bound read writes

648
00:25:13,600 --> 00:25:17,600
and ultimately arbitrary rewrite

649
00:25:18,159 --> 00:25:20,799
so if we add if we do an operation to

650
00:25:20,799 --> 00:25:22,159
add one

651
00:25:22,159 --> 00:25:24,159
to the exploit register that will add

652
00:25:24,159 --> 00:25:26,480
one to both of our bounds

653
00:25:26,480 --> 00:25:28,159
so the register had a random value of

654
00:25:28,159 --> 00:25:32,159
one are zero initially now it'll be one

655
00:25:32,159 --> 00:25:34,320
uh so the bounds are updated for each

656
00:25:34,320 --> 00:25:36,720
branch after a conditional jump

657
00:25:36,720 --> 00:25:38,159
and we can use this to manipulate the

658
00:25:38,159 --> 00:25:39,760
bounds of a register

659
00:25:39,760 --> 00:25:41,600
with all of the bits unknown so this is

660
00:25:41,600 --> 00:25:43,120
a new register

661
00:25:43,120 --> 00:25:45,600
that we're going to use

662
00:25:45,600 --> 00:25:47,679
to manipulate our exploit register the

663
00:25:47,679 --> 00:25:50,080
one that leverage the bug

664
00:25:50,080 --> 00:25:52,480
and the true branch of this instruction

665
00:25:52,480 --> 00:25:53,919
so jump

666
00:25:53,919 --> 00:25:55,679
if less than or equal

667
00:25:55,679 --> 00:25:58,159
if the register is less than or equal to

668
00:25:58,159 --> 00:25:58,960
1

669
00:25:58,960 --> 00:26:01,600
then the lower 32 bits of the register

670
00:26:01,600 --> 00:26:04,400
must be less than or equal to 1.

671
00:26:04,400 --> 00:26:07,039
um so even though the

672
00:26:07,039 --> 00:26:11,760
the least significant bit is unknown um

673
00:26:11,760 --> 00:26:14,080
its bounds are

674
00:26:14,080 --> 00:26:16,720
between zero and one the verifier knows

675
00:26:16,720 --> 00:26:18,320
this

676
00:26:18,320 --> 00:26:20,480
so our exploit register has a minimum

677
00:26:20,480 --> 00:26:22,559
value of two and a maximum value of one

678
00:26:22,559 --> 00:26:24,640
those are the corrupted bounds

679
00:26:24,640 --> 00:26:27,039
uh if we add it to our construction

680
00:26:27,039 --> 00:26:29,200
constructed register that we just made

681
00:26:29,200 --> 00:26:31,120
that has a minimum value of zero and a

682
00:26:31,120 --> 00:26:33,520
maximum value of one

683
00:26:33,520 --> 00:26:35,840
we add those together the verifier will

684
00:26:35,840 --> 00:26:37,360
add those bounds to create the new

685
00:26:37,360 --> 00:26:38,480
bounds

686
00:26:38,480 --> 00:26:39,440
um

687
00:26:39,440 --> 00:26:42,000
our exploit register now has a minimum

688
00:26:42,000 --> 00:26:43,440
value of two

689
00:26:43,440 --> 00:26:46,000
and a maximum value of two as well so

690
00:26:46,000 --> 00:26:48,640
since the min and max bounds are the

691
00:26:48,640 --> 00:26:50,559
same it will update

692
00:26:50,559 --> 00:26:53,840
the registered knowing that it must have

693
00:26:53,840 --> 00:26:55,760
a constant value of 2

694
00:26:55,760 --> 00:26:56,960
even though

695
00:26:56,960 --> 00:27:00,559
it's actually 1 during the runtime case

696
00:27:00,559 --> 00:27:03,200
so all that's left to do is to perform a

697
00:27:03,200 --> 00:27:05,200
simple and operation

698
00:27:05,200 --> 00:27:09,120
we know that uh ending two and one

699
00:27:09,120 --> 00:27:11,679
will result in zero and the verifier of

700
00:27:11,679 --> 00:27:13,360
course knows this two

701
00:27:13,360 --> 00:27:15,600
um but in actuality

702
00:27:15,600 --> 00:27:17,520
we're ending one and one

703
00:27:17,520 --> 00:27:18,399
so

704
00:27:18,399 --> 00:27:20,240
we have a value of one where the

705
00:27:20,240 --> 00:27:21,679
verifier

706
00:27:21,679 --> 00:27:22,960
thinks it's

707
00:27:22,960 --> 00:27:24,720
um zero

708
00:27:24,720 --> 00:27:27,440
so verifier thinks it's zero we actually

709
00:27:27,440 --> 00:27:29,440
have a runtime value of one

710
00:27:29,440 --> 00:27:31,120
so now we have a register that we can

711
00:27:31,120 --> 00:27:34,559
multiply add subtract whatever but the

712
00:27:34,559 --> 00:27:36,399
verifier thinks that

713
00:27:36,399 --> 00:27:38,320
the value is zero so we can use it to do

714
00:27:38,320 --> 00:27:41,360
pointer arithmetic and

715
00:27:41,360 --> 00:27:44,000
access memory that's outside the bounds

716
00:27:44,000 --> 00:27:46,640
that we're limited to

717
00:27:46,640 --> 00:27:49,120
okay so the first thing we need to do is

718
00:27:49,120 --> 00:27:51,600
create an information link

719
00:27:51,600 --> 00:27:53,440
uh this is actually easy we don't need

720
00:27:53,440 --> 00:27:54,399
to

721
00:27:54,399 --> 00:27:57,120
use our register primitive at all we can

722
00:27:57,120 --> 00:27:59,840
just uh use the bug itself

723
00:27:59,840 --> 00:28:00,880
um

724
00:28:00,880 --> 00:28:04,159
if you look at the if conditional

725
00:28:04,159 --> 00:28:06,720
so if the register is known

726
00:28:06,720 --> 00:28:07,679
and

727
00:28:07,679 --> 00:28:09,919
the

728
00:28:10,159 --> 00:28:12,480
minimum value is greater than the

729
00:28:12,480 --> 00:28:15,039
maximum value which is in the case of

730
00:28:15,039 --> 00:28:17,039
this bug because the bounds are

731
00:28:17,039 --> 00:28:18,480
corrupted and the minimum value is

732
00:28:18,480 --> 00:28:20,480
greater than the maximum value it kind

733
00:28:20,480 --> 00:28:22,640
of knows okay something got messed up

734
00:28:22,640 --> 00:28:23,840
here

735
00:28:23,840 --> 00:28:25,600
marks the register unknown

736
00:28:25,600 --> 00:28:28,320
but if you actually happen to have

737
00:28:28,320 --> 00:28:29,760
um

738
00:28:29,760 --> 00:28:32,480
a pointer in that register

739
00:28:32,480 --> 00:28:33,279
uh

740
00:28:33,279 --> 00:28:35,360
marking the register unknown

741
00:28:35,360 --> 00:28:38,320
means that now you can store

742
00:28:38,320 --> 00:28:40,640
the value of that register in a map

743
00:28:40,640 --> 00:28:42,640
remember that you're not allowed to

744
00:28:42,640 --> 00:28:46,240
store pointers to maps

745
00:28:46,240 --> 00:28:49,279
in an ebpf map because user space has

746
00:28:49,279 --> 00:28:50,960
access to it so you would be leaking

747
00:28:50,960 --> 00:28:52,799
kernel memory

748
00:28:52,799 --> 00:28:54,720
but in this case

749
00:28:54,720 --> 00:28:57,760
since the register is marked as unknown

750
00:28:57,760 --> 00:28:59,120
um

751
00:28:59,120 --> 00:29:00,799
the verifier doesn't know that there's

752
00:29:00,799 --> 00:29:05,360
an actual kernel pointer there so we can

753
00:29:05,360 --> 00:29:07,200
get our information leak just by

754
00:29:07,200 --> 00:29:08,640
leveraging the bug and not doing

755
00:29:08,640 --> 00:29:10,840
anything fancy

756
00:29:10,840 --> 00:29:14,000
um and so we get our initial information

757
00:29:14,000 --> 00:29:17,440
link to break kslr

758
00:29:18,799 --> 00:29:20,799
so an evpf map

759
00:29:20,799 --> 00:29:23,679
um as i said earlier this is what user

760
00:29:23,679 --> 00:29:25,919
space uses to interact with the ebbf

761
00:29:25,919 --> 00:29:28,880
current uh program running in the kernel

762
00:29:28,880 --> 00:29:31,600
has a is represented by a bpf map

763
00:29:31,600 --> 00:29:35,200
structure which has various fields

764
00:29:35,200 --> 00:29:37,039
the ones are in of interest are going to

765
00:29:37,039 --> 00:29:39,679
be ops and btf which are the first and

766
00:29:39,679 --> 00:29:44,000
last one that we see here on the screen

767
00:29:44,080 --> 00:29:46,240
um okay so from there we have an info

768
00:29:46,240 --> 00:29:50,080
oblique how do we achieve arbitrary read

769
00:29:50,080 --> 00:29:51,840
so as i said before a

770
00:29:51,840 --> 00:29:54,399
bpf map is represented by a bpf map

771
00:29:54,399 --> 00:29:55,600
structure

772
00:29:55,600 --> 00:29:56,399
which

773
00:29:56,399 --> 00:29:58,720
the last field that we saw on the screen

774
00:29:58,720 --> 00:30:02,320
is a struct vtf

775
00:30:02,320 --> 00:30:04,799
if we set the field

776
00:30:04,799 --> 00:30:06,799
of map

777
00:30:06,799 --> 00:30:10,000
btf as the address we want to read

778
00:30:10,000 --> 00:30:13,279
uh we're able to get a four byte read

779
00:30:13,279 --> 00:30:16,799
primitive at an arbitrary address

780
00:30:16,799 --> 00:30:18,240
if you see here

781
00:30:18,240 --> 00:30:19,440
um

782
00:30:19,440 --> 00:30:22,559
uh this is like a snippet of what gets

783
00:30:22,559 --> 00:30:24,720
executed executed

784
00:30:24,720 --> 00:30:25,679
uh

785
00:30:25,679 --> 00:30:28,480
when you call the btf

786
00:30:28,480 --> 00:30:31,520
obj get info fd command using ebpf

787
00:30:31,520 --> 00:30:33,919
helper functions

788
00:30:33,919 --> 00:30:35,120
so

789
00:30:35,120 --> 00:30:37,919
btf underscore id

790
00:30:37,919 --> 00:30:40,480
gets dereference uh dereferences the

791
00:30:40,480 --> 00:30:43,840
memory at map btf id

792
00:30:43,840 --> 00:30:44,640
so

793
00:30:44,640 --> 00:30:47,440
if you overwrite what's at btf

794
00:30:47,440 --> 00:30:49,919
field it will dereference an arbitrary

795
00:30:49,919 --> 00:30:53,279
address and memory

796
00:30:53,279 --> 00:30:54,640
so that's our

797
00:30:54,640 --> 00:30:57,039
our read primitive

798
00:30:57,039 --> 00:31:00,159
our right primitive is going to be

799
00:31:00,159 --> 00:31:02,799
um a little different so

800
00:31:02,799 --> 00:31:04,640
btf ops

801
00:31:04,640 --> 00:31:05,600
um

802
00:31:05,600 --> 00:31:06,880
if you remember

803
00:31:06,880 --> 00:31:07,919
um

804
00:31:07,919 --> 00:31:10,799
a bpf map

805
00:31:10,799 --> 00:31:13,200
has the first struck uh first field is

806
00:31:13,200 --> 00:31:15,919
ops which is like a table of

807
00:31:15,919 --> 00:31:18,000
map operations that you can do when you

808
00:31:18,000 --> 00:31:19,840
call

809
00:31:19,840 --> 00:31:21,600
helper functions

810
00:31:21,600 --> 00:31:25,440
so if we overwrite this table we can

811
00:31:25,440 --> 00:31:26,799
we have

812
00:31:26,799 --> 00:31:29,440
control over the program counter by

813
00:31:29,440 --> 00:31:30,880
overwriting

814
00:31:30,880 --> 00:31:33,360
the function addresses

815
00:31:33,360 --> 00:31:34,880
in the structure

816
00:31:34,880 --> 00:31:37,360
however

817
00:31:37,840 --> 00:31:40,159
the way that these helper functions are

818
00:31:40,159 --> 00:31:42,559
called the first argument is always

819
00:31:42,559 --> 00:31:46,399
going to be a pointer to a bpf maps

820
00:31:46,399 --> 00:31:48,240
structure itself

821
00:31:48,240 --> 00:31:49,120
so

822
00:31:49,120 --> 00:31:49,919
we're

823
00:31:49,919 --> 00:31:53,360
really better off changing the type of

824
00:31:53,360 --> 00:31:55,600
using the map operations

825
00:31:55,600 --> 00:31:57,519
functions itself because it knows how to

826
00:31:57,519 --> 00:31:58,640
interpret

827
00:31:58,640 --> 00:31:59,760
uh

828
00:31:59,760 --> 00:32:01,840
that pointer instead of like

829
00:32:01,840 --> 00:32:04,399
i don't know using some other

830
00:32:04,399 --> 00:32:05,919
completely different

831
00:32:05,919 --> 00:32:07,279
um

832
00:32:07,279 --> 00:32:09,679
kernel function which

833
00:32:09,679 --> 00:32:11,600
is not going to know how to handle the

834
00:32:11,600 --> 00:32:12,559
first

835
00:32:12,559 --> 00:32:15,440
parameter as an ebpf map and will

836
00:32:15,440 --> 00:32:18,080
cause probably cause problems

837
00:32:18,080 --> 00:32:19,600
um

838
00:32:19,600 --> 00:32:21,919
so the way we do this is we first want

839
00:32:21,919 --> 00:32:24,240
to change the type of map from an array

840
00:32:24,240 --> 00:32:27,519
to a stack the reason is is because

841
00:32:27,519 --> 00:32:29,679
we're able to call map push element

842
00:32:29,679 --> 00:32:32,159
which is only available

843
00:32:32,159 --> 00:32:36,559
if the type of the ebpf map is a stack

844
00:32:36,640 --> 00:32:39,120
type stat it has the data structure of a

845
00:32:39,120 --> 00:32:41,440
stack

846
00:32:41,440 --> 00:32:44,080
and then because we have out of bounds

847
00:32:44,080 --> 00:32:47,039
read writes in the evpf map structure

848
00:32:47,039 --> 00:32:48,159
itself

849
00:32:48,159 --> 00:32:49,039
um

850
00:32:49,039 --> 00:32:51,279
we can overwrite this with

851
00:32:51,279 --> 00:32:54,559
uh an arraymap function

852
00:32:54,559 --> 00:32:57,360
called map get next key

853
00:32:57,360 --> 00:32:59,679
um so this gives us control over the

854
00:32:59,679 --> 00:33:02,480
actual parameters that get passed to

855
00:33:02,480 --> 00:33:03,760
this function

856
00:33:03,760 --> 00:33:06,399
um so even though we are able to call

857
00:33:06,399 --> 00:33:09,120
map gets next key by leaving

858
00:33:09,120 --> 00:33:11,840
the map the type map as array which we

859
00:33:11,840 --> 00:33:14,640
originally did

860
00:33:14,640 --> 00:33:16,559
we wouldn't have control over the key

861
00:33:16,559 --> 00:33:18,320
parameters

862
00:33:18,320 --> 00:33:20,799
but if we change it to map get next key

863
00:33:20,799 --> 00:33:23,039
we can because we have control over the

864
00:33:23,039 --> 00:33:25,120
flag parameter

865
00:33:25,120 --> 00:33:26,960
and we can see here

866
00:33:26,960 --> 00:33:30,399
the flac parameter

867
00:33:31,120 --> 00:33:35,360
we are able to actually overwrite

868
00:33:35,360 --> 00:33:38,399
what's pointed to as next

869
00:33:38,399 --> 00:33:41,600
our next key which is the last parameter

870
00:33:41,600 --> 00:33:44,960
uh supposed to be flags as index plus

871
00:33:44,960 --> 00:33:47,039
one

872
00:33:47,039 --> 00:33:50,480
so we get an arbitrary right primitive

873
00:33:50,480 --> 00:33:52,799
in that way

874
00:33:52,799 --> 00:33:54,799
so we're able to

875
00:33:54,799 --> 00:33:56,080
arbitrarily

876
00:33:56,080 --> 00:33:58,880
arbitrarily read 4 bytes

877
00:33:58,880 --> 00:34:00,159
and

878
00:34:00,159 --> 00:34:03,200
arbitrarily write 4 bytes

879
00:34:03,200 --> 00:34:05,120
so

880
00:34:05,120 --> 00:34:08,000
uh that gives us enough to do lp

881
00:34:08,000 --> 00:34:08,879
um

882
00:34:08,879 --> 00:34:11,440
it's pretty straightforward from here

883
00:34:11,440 --> 00:34:12,239
uh

884
00:34:12,239 --> 00:34:14,560
we use the arbitrary read primitive to

885
00:34:14,560 --> 00:34:16,320
find the current thread's tax rack

886
00:34:16,320 --> 00:34:18,719
address um and get the address of the

887
00:34:18,719 --> 00:34:21,599
credential structure we overwrite

888
00:34:21,599 --> 00:34:23,440
the id to zero

889
00:34:23,440 --> 00:34:24,800
um

890
00:34:24,800 --> 00:34:27,839
i kind of glossed over this a little bit

891
00:34:27,839 --> 00:34:31,040
but there is code to do

892
00:34:31,040 --> 00:34:33,599
everything

893
00:34:33,599 --> 00:34:35,280
on my github

894
00:34:35,280 --> 00:34:36,480
um

895
00:34:36,480 --> 00:34:39,520
and if we have time

896
00:34:39,520 --> 00:34:43,199
i'll do a demo which i think we can

897
00:34:43,199 --> 00:34:44,480
uh

898
00:34:44,480 --> 00:34:47,359
here and so this is the demo of

899
00:34:47,359 --> 00:34:48,399
the

900
00:34:48,399 --> 00:34:51,839
actual exploit happening

901
00:34:53,280 --> 00:34:55,520
and you can kind of see the steps that i

902
00:34:55,520 --> 00:34:58,759
just covered

903
00:35:05,359 --> 00:35:08,078
and there you go

904
00:35:09,680 --> 00:35:13,160
so that happened

905
00:35:16,000 --> 00:35:17,200
okay

906
00:35:17,200 --> 00:35:19,200
um so if you're interested in the code

907
00:35:19,200 --> 00:35:20,640
it's there

908
00:35:20,640 --> 00:35:23,520
um and so let's talk about new

909
00:35:23,520 --> 00:35:26,240
mitigations

910
00:35:26,240 --> 00:35:28,839
oh sorry

911
00:35:28,839 --> 00:35:31,520
sorry the next youtube video played all

912
00:35:31,520 --> 00:35:33,839
right let's talk about new mitigations

913
00:35:33,839 --> 00:35:37,520
and ale sanitation that kind of prevent

914
00:35:37,520 --> 00:35:39,440
this type of attack from happening now

915
00:35:39,440 --> 00:35:42,000
which they're very recently introduced

916
00:35:42,000 --> 00:35:42,960
like

917
00:35:42,960 --> 00:35:44,640
it's not something that has been really

918
00:35:44,640 --> 00:35:45,599
just

919
00:35:45,599 --> 00:35:48,560
discussed at length

920
00:35:49,040 --> 00:35:51,119
previously the alu limit and if you

921
00:35:51,119 --> 00:35:54,320
remember it's a way to do dynamic checks

922
00:35:54,320 --> 00:35:56,640
during runtime um

923
00:35:56,640 --> 00:35:58,800
not static so it's like checking to see

924
00:35:58,800 --> 00:36:01,359
hey we thought during static analysis

925
00:36:01,359 --> 00:36:03,599
this register was supposed to be between

926
00:36:03,599 --> 00:36:05,440
these values

927
00:36:05,440 --> 00:36:07,200
uh let's check to see if that's actually

928
00:36:07,200 --> 00:36:08,800
true

929
00:36:08,800 --> 00:36:10,720
um the way that it's computed is

930
00:36:10,720 --> 00:36:13,280
different so before it depended on the

931
00:36:13,280 --> 00:36:16,400
position of the map register um so if

932
00:36:16,400 --> 00:36:18,000
you had some

933
00:36:18,000 --> 00:36:20,079
uh pointer to a map

934
00:36:20,079 --> 00:36:22,800
um and the verifier knew okay we just

935
00:36:22,800 --> 00:36:23,839
added

936
00:36:23,839 --> 00:36:26,640
you know 100 bytes to it so we're 100

937
00:36:26,640 --> 00:36:30,160
bytes into the map we can only go 100

938
00:36:30,160 --> 00:36:32,960
bytes more if the map size is 200

939
00:36:32,960 --> 00:36:35,440
this is different it's using the bounds

940
00:36:35,440 --> 00:36:38,480
of the offset register so we're adding

941
00:36:38,480 --> 00:36:41,040
the value of this register that is

942
00:36:41,040 --> 00:36:44,320
supposed to be between zero and one or

943
00:36:44,320 --> 00:36:45,839
zero and it's supposed to just be the

944
00:36:45,839 --> 00:36:47,359
value of zero

945
00:36:47,359 --> 00:36:49,200
it's going to use

946
00:36:49,200 --> 00:36:50,480
um

947
00:36:50,480 --> 00:36:52,400
the bounds of the offset register now

948
00:36:52,400 --> 00:36:56,480
which is much more effective because

949
00:36:56,480 --> 00:36:58,320
if you find some vulnerability in the

950
00:36:58,320 --> 00:37:00,560
verifier

951
00:37:00,560 --> 00:37:04,320
where it doesn't actually calculate

952
00:37:04,320 --> 00:37:07,040
the bounds of the offset register

953
00:37:07,040 --> 00:37:09,200
you can just keep vlog

954
00:37:09,200 --> 00:37:10,800
keep triggering that vulnerability over

955
00:37:10,800 --> 00:37:13,440
and over and basically get unlimited

956
00:37:13,440 --> 00:37:15,280
uh amounts of

957
00:37:15,280 --> 00:37:16,160
um

958
00:37:16,160 --> 00:37:18,480
out of bounds but now it's using the

959
00:37:18,480 --> 00:37:20,400
bounds of the offer set register so if

960
00:37:20,400 --> 00:37:23,280
we thought that the offset register was

961
00:37:23,280 --> 00:37:26,079
supposed to be between the values

962
00:37:26,079 --> 00:37:30,000
remember originally of zero and zero

963
00:37:30,000 --> 00:37:31,520
because if the verifier thought the

964
00:37:31,520 --> 00:37:34,320
register was supposed to be zero if the

965
00:37:34,320 --> 00:37:37,200
offset register isn't zero

966
00:37:37,200 --> 00:37:39,280
then the operation is going to be nulled

967
00:37:39,280 --> 00:37:40,880
it's not going to happen

968
00:37:40,880 --> 00:37:43,839
um so it will totally kill

969
00:37:43,839 --> 00:37:44,880
um

970
00:37:44,880 --> 00:37:46,240
this type of

971
00:37:46,240 --> 00:37:48,640
uh exploit strategy

972
00:37:48,640 --> 00:37:51,599
additionally not only uh

973
00:37:51,599 --> 00:37:54,720
not only it does it apply to

974
00:37:54,720 --> 00:37:56,079
um

975
00:37:56,079 --> 00:37:59,599
situations where the offset register

976
00:37:59,599 --> 00:38:00,560
uh

977
00:38:00,560 --> 00:38:02,320
the offset register bounds but if the

978
00:38:02,320 --> 00:38:04,960
offset register is known to be constant

979
00:38:04,960 --> 00:38:05,920
it will

980
00:38:05,920 --> 00:38:08,960
it will patch the actual instruction

981
00:38:08,960 --> 00:38:12,240
uh to use the constant value instead of

982
00:38:12,240 --> 00:38:14,560
using a register at all

983
00:38:14,560 --> 00:38:16,720
so if it knows the register is supposed

984
00:38:16,720 --> 00:38:20,000
to be zero the instruction will go from

985
00:38:20,000 --> 00:38:21,040
add

986
00:38:21,040 --> 00:38:24,480
this register to this other register

987
00:38:24,480 --> 00:38:28,000
it will go from that to adding zero to

988
00:38:28,000 --> 00:38:29,440
the edge of the register so it

989
00:38:29,440 --> 00:38:31,440
completely removes

990
00:38:31,440 --> 00:38:34,400
uh the dynamic part of it so it'll just

991
00:38:34,400 --> 00:38:36,560
add the immediate value of zero to the

992
00:38:36,560 --> 00:38:38,480
register instead of the other register

993
00:38:38,480 --> 00:38:40,640
because we don't trust what's actually

994
00:38:40,640 --> 00:38:42,720
in the register anymore and this was

995
00:38:42,720 --> 00:38:45,839
done to respect uh speculative attacks

996
00:38:45,839 --> 00:38:49,200
but it also serves as a purpose to

997
00:38:49,200 --> 00:38:51,359
kill uh exploit

998
00:38:51,359 --> 00:38:54,400
um exploits using verifying or verifier

999
00:38:54,400 --> 00:38:56,160
vulnerabilities not that they're

1000
00:38:56,160 --> 00:38:58,480
completely dead but it really does

1001
00:38:58,480 --> 00:39:00,960
hinder them so if that makes sense

1002
00:39:00,960 --> 00:39:03,599
instead of adding register 1 to register

1003
00:39:03,599 --> 00:39:06,400
2 if you know that the value of register

1004
00:39:06,400 --> 00:39:09,839
2 is 0 the instruction now becomes

1005
00:39:09,839 --> 00:39:13,599
add register 1 to 0. so

1006
00:39:13,599 --> 00:39:15,359
no chance of fooling

1007
00:39:15,359 --> 00:39:17,119
there

1008
00:39:17,119 --> 00:39:19,280
so can we still exploit the ebpf

1009
00:39:19,280 --> 00:39:20,640
verifier

1010
00:39:20,640 --> 00:39:22,960
it's more difficult but not impossible

1011
00:39:22,960 --> 00:39:25,520
there could be vulnerabilities in how

1012
00:39:25,520 --> 00:39:27,760
the patching code actually calculates

1013
00:39:27,760 --> 00:39:29,280
the bounds

1014
00:39:29,280 --> 00:39:32,800
the evpr verifier code is very complex

1015
00:39:32,800 --> 00:39:34,640
and how it computes paths and where to

1016
00:39:34,640 --> 00:39:35,599
patch

1017
00:39:35,599 --> 00:39:38,160
um which paths are speculative and which

1018
00:39:38,160 --> 00:39:40,079
are not you can trick them into thinking

1019
00:39:40,079 --> 00:39:42,320
well we don't need to actually patch

1020
00:39:42,320 --> 00:39:43,520
this path

1021
00:39:43,520 --> 00:39:46,079
um there's error you can find

1022
00:39:46,079 --> 00:39:47,760
vulnerabilities in errors when computing

1023
00:39:47,760 --> 00:39:50,160
the leu alu limit

1024
00:39:50,160 --> 00:39:51,040
um

1025
00:39:51,040 --> 00:39:52,079
and if you can't find any

1026
00:39:52,079 --> 00:39:54,000
vulnerabilities there there's always the

1027
00:39:54,000 --> 00:39:55,520
vulnerabilities in the jit compiler

1028
00:39:55,520 --> 00:39:57,839
which people have started to attack now

1029
00:39:57,839 --> 00:39:58,800
um

1030
00:39:58,800 --> 00:40:00,720
and there's possibilities in every

1031
00:40:00,720 --> 00:40:02,720
architecture because every

1032
00:40:02,720 --> 00:40:04,640
uh architecture is going to have its own

1033
00:40:04,640 --> 00:40:07,839
compiler and as uh i talked about

1034
00:40:07,839 --> 00:40:09,680
earlier

1035
00:40:09,680 --> 00:40:11,200
um

1036
00:40:11,200 --> 00:40:12,800
there was the vulnerability that i

1037
00:40:12,800 --> 00:40:15,760
talked about earlier there was uh

1038
00:40:15,760 --> 00:40:18,720
errors in how branch uh

1039
00:40:18,720 --> 00:40:22,160
branch uh jumps were calculated and so

1040
00:40:22,160 --> 00:40:24,800
that was just for x8464

1041
00:40:24,800 --> 00:40:28,480
x86 64. um but there's still a whole

1042
00:40:28,480 --> 00:40:30,319
other slew of architectures that there's

1043
00:40:30,319 --> 00:40:32,640
probably vulnerabilities in

1044
00:40:32,640 --> 00:40:35,760
how things are jib compiled so those are

1045
00:40:35,760 --> 00:40:38,000
places to look

1046
00:40:38,000 --> 00:40:40,480
um and future medications for better

1047
00:40:40,480 --> 00:40:42,240
security just my personal

1048
00:40:42,240 --> 00:40:43,760
recommendations

1049
00:40:43,760 --> 00:40:46,800
throughout the process of this research

1050
00:40:46,800 --> 00:40:49,520
verify our vulnerabilities can still

1051
00:40:49,520 --> 00:40:50,800
triply cause

1052
00:40:50,800 --> 00:40:53,680
trivially caused denial of service

1053
00:40:53,680 --> 00:40:54,480
um

1054
00:40:54,480 --> 00:40:58,160
so just as an experiment i decided to re

1055
00:40:58,160 --> 00:40:59,839
unpatch the

1056
00:40:59,839 --> 00:41:00,880
patch for

1057
00:41:00,880 --> 00:41:03,359
the vulnerability that we just exploited

1058
00:41:03,359 --> 00:41:06,480
um to see if i could still cause dos and

1059
00:41:06,480 --> 00:41:08,800
you can and the reason is is because

1060
00:41:08,800 --> 00:41:11,040
dead branches are patched with a jump

1061
00:41:11,040 --> 00:41:13,040
back one instruction

1062
00:41:13,040 --> 00:41:15,599
um which will cause an infinite loop and

1063
00:41:15,599 --> 00:41:19,280
lock up a kernel hood if you

1064
00:41:19,280 --> 00:41:21,680
were to patch those dead branches with

1065
00:41:21,680 --> 00:41:23,760
exit instructions instead

1066
00:41:23,760 --> 00:41:24,880
um

1067
00:41:24,880 --> 00:41:26,880
then the program would just terminate

1068
00:41:26,880 --> 00:41:29,680
and and free up that threat instead of

1069
00:41:29,680 --> 00:41:32,960
causing it to execute insolently

1070
00:41:32,960 --> 00:41:35,760
and uh another future mitigation that i

1071
00:41:35,760 --> 00:41:37,599
would recommend personally

1072
00:41:37,599 --> 00:41:40,960
is the ebpf bytecode buffer to be marked

1073
00:41:40,960 --> 00:41:42,240
read only

1074
00:41:42,240 --> 00:41:45,280
during and after verification

1075
00:41:45,280 --> 00:41:46,400
um

1076
00:41:46,400 --> 00:41:49,440
until jit compilation is complete

1077
00:41:49,440 --> 00:41:52,480
um so this would prevent uh evp from

1078
00:41:52,480 --> 00:41:54,640
being used in an exploit primitive for

1079
00:41:54,640 --> 00:41:57,200
other memory corruption vulnerabilities

1080
00:41:57,200 --> 00:41:59,760
like we saw and um

1081
00:41:59,760 --> 00:42:00,960
the qualis

1082
00:42:00,960 --> 00:42:02,960
exploit where they

1083
00:42:02,960 --> 00:42:04,720
were able to use a memory corruption

1084
00:42:04,720 --> 00:42:07,119
vulnerability to overwrite an ebpf

1085
00:42:07,119 --> 00:42:09,839
program buffer with new instructions

1086
00:42:09,839 --> 00:42:12,240
after it had been

1087
00:42:12,240 --> 00:42:15,040
verified by the verifier

1088
00:42:15,040 --> 00:42:18,480
we still would need some way to in um to

1089
00:42:18,480 --> 00:42:21,040
incorporate bite patching so if you uh

1090
00:42:21,040 --> 00:42:25,440
mark the buffer as read only um

1091
00:42:25,440 --> 00:42:27,280
you're not able to like

1092
00:42:27,280 --> 00:42:30,560
do dynamic patching to it um so you

1093
00:42:30,560 --> 00:42:32,480
would need like at the end to be able to

1094
00:42:32,480 --> 00:42:35,040
consolidate like what new instructions

1095
00:42:35,040 --> 00:42:36,480
or what instructions you want to

1096
00:42:36,480 --> 00:42:38,480
overwrite and patch with to the

1097
00:42:38,480 --> 00:42:40,319
read-only buffer but

1098
00:42:40,319 --> 00:42:41,280
you know

1099
00:42:41,280 --> 00:42:44,000
i think it's still probably possible

1100
00:42:44,000 --> 00:42:46,720
and there's a solution to that and

1101
00:42:46,720 --> 00:42:47,920
until then

1102
00:42:47,920 --> 00:42:50,640
ebpf

1103
00:42:50,800 --> 00:42:55,599
is a really good candidate to use as

1104
00:42:55,599 --> 00:42:57,599
an exploit primitive even if you find a

1105
00:42:57,599 --> 00:42:59,440
vulnerability that is in completely

1106
00:42:59,440 --> 00:43:00,319
different

1107
00:43:00,319 --> 00:43:03,200
part of the kernel

1108
00:43:03,599 --> 00:43:07,119
okay so now it's time for questions um

1109
00:43:07,119 --> 00:43:10,400
my blog post is at grapplesecurity.com

1110
00:43:10,400 --> 00:43:13,280
which gets into more in depth about each

1111
00:43:13,280 --> 00:43:15,280
part of the exploit process you can

1112
00:43:15,280 --> 00:43:17,760
follow me on twitter uh my handle is the

1113
00:43:17,760 --> 00:43:21,280
same uh twitter github and email

1114
00:43:21,280 --> 00:43:22,240
um

1115
00:43:22,240 --> 00:43:24,640
and yeah that's all i have

1116
00:43:24,640 --> 00:43:27,839
thank you

