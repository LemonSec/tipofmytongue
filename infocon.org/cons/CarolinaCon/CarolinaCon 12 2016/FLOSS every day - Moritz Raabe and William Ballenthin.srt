1
00:00:00,000 --> 00:00:07,529
thanks to the introduction with it here

2
00:00:07,529 --> 00:00:24,080
alright so you're thinking caps here we
are going now check on your chair we are

3
00:00:24,080 --> 00:00:30,000
now for you alright guys see it all
right actually just so file for you we

4
00:00:30,000 --> 00:00:38,989
want to know is this thing malicious
alright 10 is this thing less here's the

5
00:00:38,989 --> 00:00:44,500
hash from this house can anyone tell
those files malicious or not anyone may

6
00:00:44,500 --> 00:00:48,000
be well I this is a good example is
empty file can't really tell by how

7
00:00:48,000 --> 00:00:48,960
about this one

8
00:00:48,960 --> 00:00:53,910
what are we doing when you get them our
sample made by hash or an unknown binary

9
00:00:53,910 --> 00:00:57,370
sample my house deciding whether it's
good or better not right

10
00:00:57,370 --> 00:01:03,050
first thing we do is really not the best
clicker I'm sorry virustotal alright

11
00:01:03,050 --> 00:01:06,050
unfortunate for this one sample here
we're not seeing any results

12
00:01:06,860 --> 00:01:11,150
that's making me think well maybe this
is perhaps some kind of custom binary

13
00:01:11,150 --> 00:01:14,930
target of my organization or maybe it's
the newest version of Windows Update

14
00:01:14,930 --> 00:01:19,810
that was just put out moments go to
Firestone right all right don't know

15
00:01:19,810 --> 00:01:24,400
what to do their next thing I do a pro
hopefully not cause that makes my eyes

16
00:01:24,400 --> 00:01:28,060
bleed I don't want to do that yet next
thing I probably do is run strings on it

17
00:01:28,060 --> 00:01:33,820
I used I moved my basic static analysis
techniques from my most general tools to

18
00:01:33,820 --> 00:01:36,258
my most specific in order to save time
and effort

19
00:01:36,259 --> 00:01:40,350
alright run some strings on it here's
the output here doesn't tell me very

20
00:01:40,350 --> 00:01:44,619
much sorry I see the PE file header I
see some other sections that another

21
00:01:44,619 --> 00:01:48,460
strange that they look fairly legit
standards section names here we have

22
00:01:48,460 --> 00:01:52,669
tech section are data data section as I
kinda scroll through here I don't see

23
00:01:52,670 --> 00:01:56,689
anything that stands out things I would
be looking for are suspicious file names

24
00:01:56,689 --> 00:02:01,079
or network indicators that I could look
up on various Internet resources like no

25
00:02:01,079 --> 00:02:04,360
means I can look at the the red stars
things like that

26
00:02:04,360 --> 00:02:07,250
use that type of information to the side
of files good or bad or not

27
00:02:07,250 --> 00:02:11,900
unfortunately this topic here there's
just nothing for me to look at I don't

28
00:02:11,900 --> 00:02:12,550
know yet

29
00:02:12,550 --> 00:02:17,270
right I can continue on my analysis here
using more and more advanced tools I can

30
00:02:17,270 --> 00:02:21,100
look at the PE file format look at the
imports exports and you some of my

31
00:02:21,100 --> 00:02:24,790
background and experience decide whether
I think this file is malicious or not if

32
00:02:24,790 --> 00:02:28,620
it's Melissa's I can do additional
analysis on it but if i dont know im in

33
00:02:28,620 --> 00:02:31,970
this kind of quagmire don't yet know
what to do I can't go back to my client

34
00:02:31,970 --> 00:02:36,280
my boss and say hey you got a problem
right so what do I have to do well if I

35
00:02:36,280 --> 00:02:39,550
know how to use either perot or when
back I can open it up and uses advanced

36
00:02:39,550 --> 00:02:43,620
techniques but again though she was kind
of shocked if I don't know how to use

37
00:02:43,620 --> 00:02:49,070
those tools because they're going to use
if I don't know how to use those tools I

38
00:02:49,070 --> 00:02:52,070
have to deal with annoying
reverse-engineer they often smell bad

39
00:02:52,070 --> 00:02:56,530
they speak funny they listen to weird
dubstep music right there kind of

40
00:02:56,530 --> 00:02:58,530
annoying to deal with a lot of money

41
00:02:58,530 --> 00:03:02,170
access to one and again this is not a
good situation to be in

42
00:03:02,170 --> 00:03:05,850
we want to create our partners fast as
possible and decide at the earliest

43
00:03:05,850 --> 00:03:11,420
possible moment whether or not to file
is malicious or not the approach our

44
00:03:11,420 --> 00:03:15,790
tackling today here is with these
strings and in particular obfuscated its

45
00:03:15,790 --> 00:03:19,170
drinks we're hearing introduced it to
all loss which automatically d

46
00:03:19,170 --> 00:03:23,929
obfuscates encoded strings within
malware binaries using some pretty

47
00:03:23,930 --> 00:03:26,530
interesting advanced techniques that
we're going to get into that's the

48
00:03:26,530 --> 00:03:30,950
overview of our presentation here stick
with us here are some good stuff

49
00:03:30,950 --> 00:03:35,010
background again my name is willie
Ballentine I'm gonna fire I flair team

50
00:03:35,010 --> 00:03:39,310
or a small team of engineers we do most
of the power that comes into the entire

51
00:03:39,310 --> 00:03:44,190
fire organization we have a pretty good
grasp of what's out there but like

52
00:03:44,190 --> 00:03:48,470
probably many of you I'm pretty lazy I
like to rather play computer games

53
00:03:48,470 --> 00:03:51,680
listen to music and doing my job right
so I'm trying to make my job easy and

54
00:03:51,680 --> 00:03:55,070
fast as possible and cheapest for my
customers that's what we're talking

55
00:03:55,070 --> 00:03:58,350
about

56
00:03:58,350 --> 00:04:08,430
I am Arts on the floor team I like
traveling and when I travel laugh ideas

57
00:04:08,430 --> 00:04:22,650
like developing this lost all so we
always knew malware and everyone is

58
00:04:22,650 --> 00:04:32,909
familiar with the Packers so others and
even when I software often does is to

59
00:04:32,910 --> 00:04:41,150
hide or compressed go up you skated and
that way so you don't get to see the

60
00:04:41,150 --> 00:04:42,429
actual

61
00:04:42,430 --> 00:04:46,950
imports the regular stuff you would
expect from binary you get this package

62
00:04:46,950 --> 00:04:54,659
file and before the marathon runs and
unpacks itself and then you get to see

63
00:04:54,660 --> 00:05:02,940
all the good stuff what we often see is
that this is not so common for more

64
00:05:02,940 --> 00:05:07,530
targeted malware because it's pretty
easy to detect once there's only one

65
00:05:07,530 --> 00:05:13,900
Imports just their original protect or
something like that to unpack it's

66
00:05:13,900 --> 00:05:22,289
pretty easy even for common antivirus
software to flag as militias so I

67
00:05:22,290 --> 00:05:29,350
already gave away this answer now so you
don't have to give it to me now what we

68
00:05:29,350 --> 00:05:34,920
often see though is that strings and
resources are encoded and obvious gated

69
00:05:34,920 --> 00:05:42,220
because that's still something that
doesn't give away too much harm and

70
00:05:42,220 --> 00:05:47,190
detection standpoint but it hides the
intent of the malware and it makes it

71
00:05:47,190 --> 00:05:56,160
harder for an analyst to find out what
this file to us so we on this executable

72
00:05:56,160 --> 00:06:02,700
has obvious gated strings and wants to
use it

73
00:06:02,700 --> 00:06:09,568
yup your skates them uses them as good
either happened once the program starts

74
00:06:09,569 --> 00:06:14,800
right at the beginning or the whole for
every string or you just do it

75
00:06:14,800 --> 00:06:19,969
immediately before use that specific
string we gonna go into a example a

76
00:06:19,969 --> 00:06:26,819
little bit to make this more clear and
then after that you can read obligated

77
00:06:26,819 --> 00:06:34,509
again what strings would be interesting
to for this intense specifically we're

78
00:06:34,509 --> 00:06:40,389
looking at command-and-control server
addresses domains IP addresses which

79
00:06:40,389 --> 00:06:46,649
already give away a large sample from a
detection standpoint once we have those

80
00:06:46,649 --> 00:06:53,300
those strings domain names we can look
at our environment for communication to

81
00:06:53,300 --> 00:06:59,279
those if we have registered keys and
file names from strings so we can find

82
00:06:59,279 --> 00:07:05,319
other samples and our environment and
from the dynamic employees we can tell

83
00:07:05,319 --> 00:07:23,089
what does matter is roughly doing maybe
so this is the goods like in the middle

84
00:07:23,089 --> 00:07:28,439
in the middle between completely packing
the file and just having everything

85
00:07:28,439 --> 00:07:34,699
sitting over there which can be easily
analyzed so file appears normal by that

86
00:07:34,699 --> 00:07:41,909
we mean imports their kids it might be
signed using a valid or stolen

87
00:07:41,909 --> 00:07:48,248
certificate it's everything was normal
but you can't tell anything from the

88
00:07:48,249 --> 00:07:56,110
streaks so I'll do my office actually do
with us this is an example source code a

89
00:07:56,110 --> 00:08:05,159
very useful program results the hostname
and return 0 and 14 compiled and look at

90
00:08:05,159 --> 00:08:10,430
the strings we we get everything racing
clear picture you can see it as a call

91
00:08:10,430 --> 00:08:13,360
to ghettos by name and receive

92
00:08:13,360 --> 00:08:19,750
the domain name you can then use this
again to find traffic to malicious

93
00:08:19,750 --> 00:08:26,710
domains and other activity and I never
heard so as I'm out there one thing you

94
00:08:26,710 --> 00:08:33,390
could do is write this little decoding
function which ex source every every

95
00:08:33,390 --> 00:08:40,078
character string and then you just put
the obvious gated version into your

96
00:08:40,078 --> 00:08:50,010
source code so instead of having the
cleartext domain name there you have an

97
00:08:50,010 --> 00:08:54,899
encoded version and then your own
strengths as an analyst on this and you

98
00:08:54,899 --> 00:09:01,320
can tell ok to use as a guest house by
name but doesn't appear to be a valid

99
00:09:01,320 --> 00:09:06,850
domain name or anything of interest in
me and even if you could tell this

100
00:09:06,850 --> 00:09:13,640
string might be encoded you have no idea
how it's and Cody and how you can get to

101
00:09:13,640 --> 00:09:25,540
the original string ways to do this
branch of implementations one way would

102
00:09:25,540 --> 00:09:35,579
be to 4 offers a way to do this you can
transfer the source code just run like a

103
00:09:35,579 --> 00:09:43,050
savvy or a wk on ads transfer the source
code from the cleartext replace every

104
00:09:43,050 --> 00:09:47,010
string by the current version and then
do something we just saw in this example

105
00:09:47,010 --> 00:09:53,170
could also do it on the preprocessor
levels by using macros or during

106
00:09:53,170 --> 00:10:00,420
compilation time example using clang and
from a complexity standpoint it's it can

107
00:10:00,420 --> 00:10:04,030
range from just a simple XOR or you
could have

108
00:10:04,030 --> 00:10:11,270
and I C four groups for every purse
strings with a different key is just to

109
00:10:11,270 --> 00:10:18,560
give you an idea is a million ways to do
this and it's very hard for 11 analysts

110
00:10:18,560 --> 00:10:28,160
to do this and realize analyze
everything over and over again for those

111
00:10:28,160 --> 00:10:31,980
people out there have you dealt with
before that does this kind of technique

112
00:10:31,980 --> 00:10:36,820
is as familiar to you as a friend now ok
it's a lot of naughty heads this is

113
00:10:36,820 --> 00:10:40,700
something I see on a multiple times per
week when I'm reverse engineering this

114
00:10:40,700 --> 00:10:46,640
is not some theoretical attack this is
what I see every single we okay so it's

115
00:10:46,640 --> 00:10:50,030
extremely common there's a million ways
to do and that's what maurice was saying

116
00:10:50,030 --> 00:10:55,620
so any time that we can win even a
fraction of those samples receiving a

117
00:10:55,620 --> 00:10:58,760
lot of time and we're solving real-world
problems so that that's kind of a

118
00:10:58,760 --> 00:11:02,580
motivation here this is something that's
extremely it's not a theoretical attack

119
00:11:02,580 --> 00:11:10,190
so it's annoying to reverse engineer we
know most of the times I know that's why

120
00:11:10,190 --> 00:11:15,110
this militias but we need to find those
indicators for network analysis and no

121
00:11:15,110 --> 00:11:21,420
space analysis and it's also annoying
for forensic analyst just is looking at

122
00:11:21,420 --> 00:11:29,329
the spa statically using strings tools
and it forces them to involve other

123
00:11:29,330 --> 00:11:35,050
experienced reverse engineers I have an
expert system developed for millions of

124
00:11:35,050 --> 00:11:41,130
dollars and we're trying to make this
happen elsewhere released this

125
00:11:41,130 --> 00:11:51,420
open-source tool for free so how to
reverse engineer sexually how do I go

126
00:11:51,420 --> 00:11:56,689
about learning functions decoding
strains that obvious skated and malware

127
00:11:56,690 --> 00:12:04,400
one thing you can do you can debug the
program adds to its termination point so

128
00:12:04,400 --> 00:12:06,079
before everything gets

129
00:12:06,080 --> 00:12:12,030
removed from memory and then you done
the strings that are still in memory you

130
00:12:12,030 --> 00:12:16,050
compare those to the strings he had
before running string statically and

131
00:12:16,050 --> 00:12:20,560
sometimes you get away from that most
often though drinks I'm not really

132
00:12:20,560 --> 00:12:27,609
exhaust stack strings for example you
have strings that get dynamically

133
00:12:27,610 --> 00:12:34,970
allocated and freed the program i knows
what he's doing or she's doing or if

134
00:12:34,970 --> 00:12:38,440
their strengths that reopen skated after
using them

135
00:12:38,440 --> 00:12:45,580
example forced extra innings we the
player team already provided to offer

136
00:12:45,580 --> 00:12:52,990
this hour now get up it's just you
create those strings during runtime on

137
00:12:52,990 --> 00:12:58,910
the stack and they never gets a memory
but at the at the point of the program

138
00:12:58,910 --> 00:13:05,730
termination you probably won't see them
that's an issue another way to find

139
00:13:05,730 --> 00:13:12,820
those strings you can find the recording
function tonight a pro analysis take

140
00:13:12,820 --> 00:13:17,260
some time to find those functions and
then you run the the program's decoding

141
00:13:17,260 --> 00:13:23,560
function on all the arguments so all the
obvious case brings you try to run the

142
00:13:23,560 --> 00:13:30,150
actual code is most correct thing to do
would you don't have to write code

143
00:13:30,150 --> 00:13:35,150
yourself but the problem is it's very
hard to find all the arguments and

144
00:13:35,150 --> 00:13:40,770
instruct them over it does do this for
every ad said they had 20 encourages

145
00:13:40,770 --> 00:13:47,050
strings and you have to instructed to do
this very annoying and even worse if the

146
00:13:47,050 --> 00:13:51,829
recording function is in lines into the
binary and

147
00:13:51,830 --> 00:14:00,260
the difficulty was up a lot last thing
we do was very flexible way

148
00:14:00,260 --> 00:14:05,760
re-employment the decoding algorithm and
Python or you go to a scripting language

149
00:14:05,760 --> 00:14:17,420
of choice and apply this to every
destructive skated later you find it's

150
00:14:17,420 --> 00:14:23,550
very tedious to do this takes a couple
of hours and it has to be done over and

151
00:14:23,550 --> 00:14:28,160
over for everybody you find so even if
they just change the saying how a single

152
00:14:28,160 --> 00:14:35,589
character in the in the key you have to
be implemented again and very annoying

153
00:14:35,590 --> 00:14:43,630
so we go plus second guess what we're
here to talk about today like what

154
00:14:43,630 --> 00:14:47,640
problem are we trying to solve right
like let's see if we can find a way to

155
00:14:47,640 --> 00:14:52,319
automate the extraction of these otha
skated strings so that on a weekly basis

156
00:14:52,320 --> 00:14:57,280
I don't have to sit there and read
implement our authors code in Python to

157
00:14:57,280 --> 00:15:02,100
extract these strings just such a
tedious process I really enjoyed it when

158
00:15:02,100 --> 00:15:05,280
I was a junior reverse engineer I
thought that I was like doing really

159
00:15:05,280 --> 00:15:09,339
good work and I was but then I like the
5th time I did I was like I'm so sick

160
00:15:09,340 --> 00:15:13,280
and tired of this and now at this point
I'm unlike my 500 sample and I still

161
00:15:13,280 --> 00:15:16,079
can't reuse much of my code because
every single sample basically has a

162
00:15:16,080 --> 00:15:18,940
different set of configurations a
different set of arguments that it

163
00:15:18,940 --> 00:15:24,430
passes the routine a different way of
setting up the stack details I don't

164
00:15:24,430 --> 00:15:28,020
want to concern myself with let's find a
way to automate that so what we've got

165
00:15:28,020 --> 00:15:33,829
here today is los losses while AP's
office gated strings all very it's a

166
00:15:33,830 --> 00:15:37,170
tool that's going to help us and we're
gonna give it to you here today for free

167
00:15:37,170 --> 00:15:44,040
it's not yet under cares alright so for
us is a simple to use to what I mean by

168
00:15:44,040 --> 00:15:49,290
this is if you know how to run strings
dot exe you know how to use a loss this

169
00:15:49,290 --> 00:15:51,020
is good right

170
00:15:51,020 --> 00:15:56,770
it also takes a lot of hard work that's
come from his brain my brain I thought

171
00:15:56,770 --> 00:15:59,750
about a lot of these encoder teens who
is married to come up with some pretty

172
00:15:59,750 --> 00:16:02,610
interesting salutes illusions about how
you can automate this

173
00:16:02,610 --> 00:16:06,410
techniques so you don't even have to
think about this again alright it's

174
00:16:06,410 --> 00:16:09,630
going to solve many of them our samples
out there it's not going to solve all of

175
00:16:09,630 --> 00:16:13,420
them but if it solves eighty percent
even 50% we're saving a lot of time so

176
00:16:13,420 --> 00:16:18,740
let's talk about these techniques
alright going into a little more detail

177
00:16:18,740 --> 00:16:23,140
about how easy is this thing to use the
first thing i wana and right now we just

178
00:16:23,140 --> 00:16:27,779
pushed it an hour to go to get hope it's
not just a Python script that you

179
00:16:27,779 --> 00:16:31,160
download and then saw a bunch of
dependencies for and like wonder why

180
00:16:31,160 --> 00:16:32,269
it's not working

181
00:16:32,269 --> 00:16:36,880
know we packaged it up for least Windows
and Mac and this is not makin' sorry

182
00:16:36,880 --> 00:16:41,000
that's what we haven't done Linux
Windows because we don't have a

183
00:16:41,000 --> 00:16:44,040
stand-alone executables you go to get
help right now you don't let a single

184
00:16:44,040 --> 00:16:48,370
exe you run it with arguments it works
if you want to hop on the Python code

185
00:16:48,370 --> 00:16:51,850
are surely welcome to its pure Python
it's easy to hack on understand what's

186
00:16:51,850 --> 00:16:55,529
going on there that's very easy to do
but if you want to run it is ready to go

187
00:16:55,529 --> 00:17:02,519
out there and get on get home made uses
some of these advanced analysis

188
00:17:02,519 --> 00:17:05,609
techniques and we're going to talk about
these a lot more details next coming

189
00:17:05,609 --> 00:17:12,079
next couple slides but some of the major
takeaways are uses solely static

190
00:17:12,079 --> 00:17:16,428
analysis techniques now why is this
important why don't you mention this how

191
00:17:16,429 --> 00:17:20,299
many guys have malware sandboxes out
there and the rest of you guys should go

192
00:17:20,299 --> 00:17:24,089
by fire i right now this is not the
point of the top right you can spend

193
00:17:24,089 --> 00:17:28,319
tens or hundreds of thousands of dollars
on technology is you can spend 20 40 50

194
00:17:28,319 --> 00:17:31,730
hours building a virtual machine with
all your tools in it that you can run

195
00:17:31,730 --> 00:17:34,380
routes that doesn't connect to the
internet and other exploit the rest of

196
00:17:34,380 --> 00:17:38,850
your network do all these crazy things
that's been ordered to do things

197
00:17:38,850 --> 00:17:43,580
dynamically right now are dynamically we
can actually execute on the CPU and

198
00:17:43,580 --> 00:17:47,770
watch what it's doing we're doing
everything statically so we have

199
00:17:47,770 --> 00:17:51,799
complete control of an hour and unless
there's some kind of crazy 0 day and

200
00:17:51,799 --> 00:17:55,690
pipe which I really hope doesn't happen
we basically don't have to worry about

201
00:17:55,690 --> 00:17:59,919
compromising our analysis system so
that's nice it makes it very easy to use

202
00:17:59,919 --> 00:18:08,990
on many systems and again will be taken
to the technique here all right let's

203
00:18:08,990 --> 00:18:10,680
dig into how this thing works well

204
00:18:10,680 --> 00:18:17,420
what did we achieve here essentially
what lost us is a starts with a set of

205
00:18:17,420 --> 00:18:22,050
heuristics that process the entire
executable look at all the functions

206
00:18:22,050 --> 00:18:26,230
basic blocks instructions and it ranks
those functions to figure out which one

207
00:18:26,230 --> 00:18:30,260
of these functions as most likely to be
a decoder 18 this is probably the most

208
00:18:30,260 --> 00:18:34,320
one-to-one correlation between what's in
my head and where he said and what's in

209
00:18:34,320 --> 00:18:37,830
the code there we used our experience
but we have most commonly seen an hour

210
00:18:37,830 --> 00:18:42,909
to identify proteins that we translated
that into Python code and that's what we

211
00:18:42,910 --> 00:18:49,020
use to find the Hurricanes once we find
Dakota routines we actually just emulate

212
00:18:49,020 --> 00:18:52,580
those decoding your teens using all the
data that the party in the mouth where

213
00:18:52,580 --> 00:18:58,490
to do the decoding for us we don't have
to remember we don't have to dynamically

214
00:18:58,490 --> 00:19:02,970
is a debugger anything like that we just
really the code using a fake virtual CPU

215
00:19:02,970 --> 00:19:07,780
and look at the effects of the Mau are
as it attempts to execute the code in

216
00:19:07,780 --> 00:19:11,920
function once we've emulated those
Dakota functions we can simply look at

217
00:19:11,920 --> 00:19:17,260
the virtual state of that memory we can
look for strings in those effects of the

218
00:19:17,260 --> 00:19:22,860
instructions if we find anything we can
dump them out it works really well so

219
00:19:22,860 --> 00:19:27,350
the first step as well as we go into
this a little more detail is to analyze

220
00:19:27,350 --> 00:19:33,090
the binary on a high level we look for
all the functions as a tool called the

221
00:19:33,090 --> 00:19:38,550
SEC to do this this is essentially a
scriptable instance of IDA Pro that's

222
00:19:38,550 --> 00:19:44,620
free wi-fi it's a great to up there so
used to identify all the functions are

223
00:19:44,620 --> 00:19:48,409
used herein sticks to process those
functions and identify the decoder

224
00:19:48,410 --> 00:19:52,680
chance once we know which are the
decoding routines we look for references

225
00:19:52,680 --> 00:19:56,960
to those decoding with routines we
figure out where in the mouth where is

226
00:19:56,960 --> 00:20:02,600
the author intending to call the
decoding are seen as when we know when

227
00:20:02,600 --> 00:20:06,810
we just have to look around in that same
area to find the data that needs to be

228
00:20:06,810 --> 00:20:11,139
to code it the stuff that if we were to
just run strings on the executable we

229
00:20:11,140 --> 00:20:14,600
just get gibberish we won't find
anything but that's the day that we need

230
00:20:14,600 --> 00:20:20,610
to isolate a fired because of the
arguments to the decoding return once

231
00:20:20,610 --> 00:20:23,959
we've found us things we can take
snapshots of the CPU are doing something

232
00:20:23,960 --> 00:20:28,310
later on in the background here found
the arguments then once we we know what

233
00:20:28,310 --> 00:20:31,409
those arguments are we can actually pass
them and emulate that decoding routine

234
00:20:31,410 --> 00:20:37,350
and a virtual CPO we're doing it in this
virtual CPU we have complete control

235
00:20:37,350 --> 00:20:40,889
over every instruction that's being
executed and how the CPU handles that

236
00:20:40,890 --> 00:20:45,150
now of course as part of cases here
unlike what happens if you divide by

237
00:20:45,150 --> 00:20:49,810
zero or something like that we know are
things like that most of the time that

238
00:20:49,810 --> 00:20:55,800
works really really well I'm you later
these decoder teens to their completion

239
00:20:55,800 --> 00:21:02,620
for example when the routine it's a
return statement or maybe all the 28th

240
00:21:02,620 --> 00:21:06,320
minute loop and once we've execute its
800,000 instructions we say that's

241
00:21:06,320 --> 00:21:10,139
enough we look at what the effects of
that Cody routine are we can run that

242
00:21:10,140 --> 00:21:16,710
the classical strings on it to jump out
what we need but kinda makes sense yeah

243
00:21:16,710 --> 00:21:17,660
it works great

244
00:21:17,660 --> 00:21:24,900
really excited but they're still here as
I mentioned we just told him if you are

245
00:21:24,900 --> 00:21:29,050
a Python developer if you do reverse
engineering or enjoy this kind of

246
00:21:29,050 --> 00:21:31,840
understanding of his work this is a
great tool to get started with your

247
00:21:31,840 --> 00:21:34,179
business free on our side and get help

248
00:21:34,180 --> 00:21:38,430
it's been in development for like 10 or
12 years it has a long history behind it

249
00:21:38,430 --> 00:21:44,410
was popularly as it should be some of
the cool parts of it are that it allows

250
00:21:44,410 --> 00:21:47,690
you to do basically all the analysis
that I have photos in a script away

251
00:21:47,690 --> 00:21:52,670
again finding functions cross references
strings data code all these kind of

252
00:21:52,670 --> 00:21:54,470
things easy to pull out

253
00:21:54,470 --> 00:21:59,280
programmatically as you I we don't use
it here I think that has built into it

254
00:21:59,280 --> 00:22:03,690
symbolic effect an analyzer code any
later deep over all these things packets

255
00:22:03,690 --> 00:22:08,760
and 20 Python it's a great package
that's what we use for doing the control

256
00:22:08,760 --> 00:22:15,960
flow analysis identifying functions
earlier we have to identify the coding

257
00:22:15,960 --> 00:22:21,690
region we use the plugin based system to
implement heuristics to find these a

258
00:22:21,690 --> 00:22:25,510
chance and we use a plug-in base system
because this is the number one place

259
00:22:25,510 --> 00:22:29,970
where Fox right now currently fails at a
place that are most commonly felt right

260
00:22:29,970 --> 00:22:32,800
now is it just not finding the correct
decoding routine

261
00:22:32,800 --> 00:22:36,720
that may be identified men compared some
other short function that has a lot of

262
00:22:36,720 --> 00:22:40,910
loops to it and thinks maybe that's a
decoder chance that we have a plug-in

263
00:22:40,910 --> 00:22:44,620
base system allows us to easily extend
flossing quickly fix bugs to identify

264
00:22:44,620 --> 00:22:47,679
more of those decoding routines

265
00:22:47,680 --> 00:22:53,460
the takeaways here is that we could
emulate every single function in the

266
00:22:53,460 --> 00:22:57,450
entire binary and do a great job and I
would be the perfect solution but that

267
00:22:57,450 --> 00:23:00,950
might take awhile I take five or ten
minutes to do all that work so by using

268
00:23:00,950 --> 00:23:05,100
these heuristics and more precisely
identifying the decoding the chance we

269
00:23:05,100 --> 00:23:08,899
can actually achieve higher performance
but if we have a false positive not a

270
00:23:08,900 --> 00:23:13,750
big deal so the take away from that is
that is extensible system effective

271
00:23:13,750 --> 00:23:20,970
barely a system but again we have a lot
of flexibility in terms of graphics I

272
00:23:20,970 --> 00:23:28,200
was found to be really effective far for
instance the next line here is an

273
00:23:28,200 --> 00:23:33,330
example of a core part of a single
Dakota routine right as a screenshot

274
00:23:33,330 --> 00:23:38,980
Pride a pro at a single basic block a
couple of maybe 15 assembly instructions

275
00:23:38,980 --> 00:23:41,970
here and the one that really catches my
eye is right in the middle there there's

276
00:23:41,970 --> 00:23:48,680
an ex or instruction it's a non-zero XRX
soaring with i think is staticy doing

277
00:23:48,680 --> 00:23:54,800
we're using the hex a small bite 72 X or
everybody in an array we kind of loop

278
00:23:54,800 --> 00:23:59,570
three is one of those bites and
operation we also do some chefs so one

279
00:23:59,570 --> 00:24:02,659
thing that our heuristics identify
that's a weird kind of back story don't

280
00:24:02,660 --> 00:24:06,900
see that a normal code and I think we
see another interesting feature here is

281
00:24:06,900 --> 00:24:12,920
a tight loop when we get to the bottom
of this basic block there's a branch one

282
00:24:12,920 --> 00:24:17,530
case falls through the other one jumps
around and goes to the same basic block

283
00:24:17,530 --> 00:24:18,690
over and over and over again

284
00:24:18,690 --> 00:24:22,960
really really fast this a tight loop and
this indicates to us kind of area and

285
00:24:22,960 --> 00:24:26,660
quickly through in Iraq user features we
find really interesting and help us

286
00:24:26,660 --> 00:24:27,570
identify

287
00:24:27,570 --> 00:24:36,669
once we found her chance our goal is
again to emulate them ok so we have this

288
00:24:36,670 --> 00:24:42,220
very effective virtual CPU and memory
system and what we can say is okay

289
00:24:42,220 --> 00:24:45,220
here's some day to hear the arguments
this one function

290
00:24:45,220 --> 00:24:51,220
tell me what the effects are on the
system after say 10,000 instructions or

291
00:24:51,220 --> 00:24:54,080
really every time I had a call
instruction pause for a moment

292
00:24:54,080 --> 00:24:57,439
tell me what the state of the system is
a point in time and allow me to do my

293
00:24:57,440 --> 00:25:01,630
analysis continue on executing so that's
what we're doing they're alright that's

294
00:25:01,630 --> 00:25:05,400
our goal in order to do this effectively
we need to know what the argument

295
00:25:05,400 --> 00:25:10,390
started the decoding function so we need
to do a bit more analysis on the binary

296
00:25:10,390 --> 00:25:15,539
and that is to extract the arguments I
might be passed to the Dakota Regina

297
00:25:15,539 --> 00:25:20,158
mention this earlier the way we do this
is essentially tu brute force emulate

298
00:25:20,159 --> 00:25:25,250
higher binary emulate every single
instruction at every single basic block

299
00:25:25,250 --> 00:25:29,179
and there is we do this as we're
exploring all the code in order to find

300
00:25:29,179 --> 00:25:36,980
all the possible arguments to every
decoding routine call ok call to a known

301
00:25:36,980 --> 00:25:41,030
decoding 14 which is what we found in
during the heuristic stage we take a

302
00:25:41,030 --> 00:25:46,980
snapshot of the CPU and registers and
memory at that point in time from that

303
00:25:46,980 --> 00:25:52,020
snapshot extract the arguments to the
function like a snapshot VMware

304
00:25:52,020 --> 00:25:55,330
Workstation it allows us to jump back
and forth to different places in the

305
00:25:55,330 --> 00:25:57,918
program at different states

306
00:25:57,919 --> 00:26:04,120
example of a real quick as we can be
emulating here instruction by

307
00:26:04,120 --> 00:26:08,489
instruction seeing what its effects of
the suits on the system which one of

308
00:26:08,490 --> 00:26:11,630
these instructions so we had the test
instruction we have a branch here

309
00:26:11,630 --> 00:26:14,950
because we are brands have two
possibilities YCP you may go next

310
00:26:15,880 --> 00:26:20,320
so we take a snapshot at this point of
the memory and register state we can now

311
00:26:20,320 --> 00:26:25,309
pick one of the branch destinations
continued emulating their we do the XOR

312
00:26:25,309 --> 00:26:28,539
here and now we have another branch
instruction so we can take another snap

313
00:26:28,539 --> 00:26:32,440
shot at this point how to make sure
we're brute force and we're covering

314
00:26:32,440 --> 00:26:36,320
every possible basic block we revert to
a previous snapshot and go down the

315
00:26:36,320 --> 00:26:41,879
other branch and we in this way we kind
of rough first analyze all the possible

316
00:26:41,880 --> 00:26:46,440
place basic blocks and when we come to
call instruction we can say where are we

317
00:26:46,440 --> 00:26:51,240
about to jump is this a call to a
decoding 14 if it is let's make sure we

318
00:26:51,240 --> 00:26:54,760
extract the arguments that would be
passed to the decoding routine so we can

319
00:26:54,760 --> 00:26:57,929
subsequently emulate widows argument

320
00:26:57,929 --> 00:27:08,950
does that make sense at this point I
know I mentioned a couple of times we do

321
00:27:08,950 --> 00:27:12,840
the emulation about that routine many
many times once for each set of

322
00:27:12,840 --> 00:27:16,789
arguments we expect the decoding 14 to
have some effect on the state of the

323
00:27:16,789 --> 00:27:22,259
memory right if it's changing all the
bites in Iraq weekend if the state of

324
00:27:22,259 --> 00:27:26,499
the seat of the memory before the Dakota
routine after the decoding routine and

325
00:27:26,499 --> 00:27:30,649
look for fights and memory that have
changed during that routine pretty quick

326
00:27:30,649 --> 00:27:34,610
operation once we know that bites that
are differing we can just run strings is

327
00:27:34,610 --> 00:27:38,309
different but it's and now we see what
has been decoded within that function

328
00:27:38,309 --> 00:27:46,700
that also makes sense it's pretty
effective right time for demo here

329
00:27:46,700 --> 00:27:49,700
definitely gonna work

330
00:28:00,890 --> 00:28:05,150
although I just talked to his what we'd
be doing manually and ibuprofen windbag

331
00:28:05,150 --> 00:28:10,730
on a weekly basis it was painful enough
for me to try to explain it to you and

332
00:28:10,730 --> 00:28:14,390
words up here let alone do it every
other day this is why we're trying to

333
00:28:14,390 --> 00:28:17,390
automate it

334
00:28:27,020 --> 00:28:50,920
and i cant really useful here so pull it
up in like the Evo you don't get the

335
00:28:50,920 --> 00:28:58,460
imports UNC ok it has a bunch of input
normal imports you know cornel 32 normal

336
00:28:58,460 --> 00:29:02,950
things maybe it is signed by someone and
video you don't know if it's stolen

337
00:29:02,950 --> 00:29:06,040
certificate or not don't really know if
it's good or bad

338
00:29:15,580 --> 00:29:23,270
so no running + first thing it does it's
running it through mystics to find these

339
00:29:23,270 --> 00:29:28,230
decoding functions and right now we
analyze the top 10 so this is the

340
00:29:28,230 --> 00:29:37,550
listing of top 10 functions plus think
possibly recording functions and then we

341
00:29:37,550 --> 00:29:43,540
emulate those with the identified
arguments against the year for this

342
00:29:43,540 --> 00:29:49,860
function and actually found thirty
strings so we get some information is

343
00:29:49,860 --> 00:29:52,860
almost certain to remain here

344
00:29:54,550 --> 00:30:01,750
stuff looks looks interesting analysis
there's an URL and as more strings

345
00:30:01,750 --> 00:30:13,170
giving us space indicators and filenames
anything I've used to us so that's one

346
00:30:13,170 --> 00:30:16,029
example

347
00:30:16,029 --> 00:30:25,840
the whole file and analyzing every
function you can also tell it's just

348
00:30:25,840 --> 00:30:34,129
locate a specific function that you
identified in a pro or whatever tool and

349
00:30:34,129 --> 00:30:39,889
you can just find all the arguments for
that function and specifically analyzed

350
00:30:39,889 --> 00:30:48,330
those things about was pretty quick for
this one because it's only looking at

351
00:30:48,330 --> 00:30:52,379
eight strings again

352
00:30:53,169 --> 00:30:57,639
useful out porridge and another
dimension and yet but those encoded

353
00:30:57,639 --> 00:31:03,330
strings anomaly much more valuable than
just regular strings you find once you

354
00:31:03,330 --> 00:31:08,718
get something out of this ok somebody
tried to actively hide these strings so

355
00:31:08,719 --> 00:31:18,849
they must be of some value names names
in for a legit program if you're in a

356
00:31:18,849 --> 00:31:22,089
legit program through floss how many
strings would you expect to see any

357
00:31:22,089 --> 00:31:26,989
output probably 05 why does a legit
program have to hide any strings

358
00:31:26,989 --> 00:31:31,749
whatsoever so simply seeing it somehow
put here might be an indicator to you

359
00:31:31,749 --> 00:31:34,749
something special going on

360
00:31:43,770 --> 00:31:55,690
yeah and you will get some some good
network-based indicators using Twitter

361
00:31:55,690 --> 00:32:08,520
as the c2 server basically and we get
aidid fields and URL parameter and 11

362
00:32:08,520 --> 00:32:16,610
seconds to run it so it's tough to go
catch when you type of plan on their

363
00:32:16,610 --> 00:32:22,350
loss to see them out there and see you
just gave him results like that that's

364
00:32:22,350 --> 00:32:26,540
our goal here I've been to a number of
conferences before I've been to a lot of

365
00:32:26,540 --> 00:32:30,190
really interesting talks and a lot of
times at the end of the talk to guys

366
00:32:30,190 --> 00:32:34,350
basically talking about the girl is
talking about I mean it's cool tool I

367
00:32:34,350 --> 00:32:38,770
think you guys should use it I'm excited
to use it I go down on it I find I get

368
00:32:38,770 --> 00:32:43,360
how about the co-pilot on Windows get
all these other libraries and then I try

369
00:32:43,360 --> 00:32:46,719
to use it doesn't work after talked
about it

370
00:32:46,720 --> 00:32:51,050
painful that is so one of our goals here
was to get something what will work

371
00:32:51,050 --> 00:32:54,250
something I'm gonna call you know it
could really save some time and some of

372
00:32:54,250 --> 00:32:58,810
our jobs right but we also on a package
for you guys to use right now so when I

373
00:32:58,810 --> 00:33:02,310
mentioned earlier we package it a
stand-alone executables thereon get how

374
00:33:02,310 --> 00:33:07,080
this instant download them are you that
right for our talk that's an extra of

375
00:33:07,080 --> 00:33:11,310
them there's no more insulation to it he
won't install it manually

376
00:33:11,310 --> 00:33:15,960
can you can use it right now so I don't
know I mean I'm pretty excited about

377
00:33:15,960 --> 00:33:18,450
that back I'm going to be using
executables even though I do out the

378
00:33:18,450 --> 00:33:31,560
source of myself so at this point I hope
we've kind of understand your questions

379
00:33:31,560 --> 00:33:35,659
ready and we just about at the end here
why you might want to take a look at the

380
00:33:35,660 --> 00:33:39,670
store right one it's easy to use and
incorporate some fairly advanced

381
00:33:39,670 --> 00:33:43,340
techniques simulation heuristics binary
code analysis that maybe not are you

382
00:33:43,340 --> 00:33:46,929
familiar with maybe you are you just
don't wanna do them again are you doing

383
00:33:46,930 --> 00:33:52,650
your sleep you don't waste time on it
last modified a lot of those techniques

384
00:33:52,650 --> 00:33:57,230
makes it easy for use them it's pure
Python / you want to happen it's easy to

385
00:33:57,230 --> 00:34:01,750
mess around with our happy to
incorporate your changes adding new

386
00:34:01,750 --> 00:34:06,080
plugins identify more decoding are teens
is going to be easy and we can't wait to

387
00:34:06,080 --> 00:34:09,480
get those incorporated in so I do hope
you contribute there but we will know

388
00:34:09,480 --> 00:34:13,360
that right now our goal is not to solve
every single encoded string out there

389
00:34:13,360 --> 00:34:18,560
now where we know that's a losing battle
I mean if we're double what about all

390
00:34:18,560 --> 00:34:21,870
where it's an IRA probably former own
company

391
00:34:21,870 --> 00:34:25,168
get some PC funding for millions of
dollars a link to this very day job but

392
00:34:25,168 --> 00:34:30,810
like 80 percent solution again is such
so good for us we can save so much times

393
00:34:30,810 --> 00:34:34,659
my users want to all that this is what
we're going to try to do not solve every

394
00:34:34,659 --> 00:34:47,669
possible strengths of the general case
sometime there from here in a bit if you

395
00:34:47,668 --> 00:34:51,279
want snapshot it hurts

396
00:34:54,290 --> 00:35:08,890
frontier slimy answer your question I
was using Ubuntu i sat out the piled

397
00:35:08,890 --> 00:35:14,580
into compliance dollar I expected to
work on most distributions for that

398
00:35:14,580 --> 00:35:18,750
sentiment binary now it's your Python so
it should really run on HPUX or any

399
00:35:18,750 --> 00:35:24,640
other operating system you want to stand
on binary was not tested should run on

400
00:35:24,640 --> 00:35:27,640
Linux having trouble let us know

401
00:35:29,150 --> 00:35:33,410
alright the next one over on this side

402
00:35:48,210 --> 00:35:54,450
some interesting things going on in the
questionnaire one is there are cases

403
00:35:54,450 --> 00:36:00,779
where they still cannot work right for
us to provably extract every strength is

404
00:36:00,780 --> 00:36:04,050
impossible right that's the halting
problem we cannot tell if we've

405
00:36:04,050 --> 00:36:07,290
extracted all the strings without
executing it to completion

406
00:36:08,750 --> 00:36:12,210
computer science tells us we cannot do
it for a possible circumstance I'm not

407
00:36:12,210 --> 00:36:16,530
gonna try we're gonna do the most common
case so if there's nowhere that has a

408
00:36:16,530 --> 00:36:20,109
sequence of calls to various different
functions that have to be called a

409
00:36:20,109 --> 00:36:25,670
specific order can't do that but most
malware authors don't use that technique

410
00:36:25,670 --> 00:36:31,390
they use one of the techniques described
earlier macro C C Tyler plugins source

411
00:36:31,390 --> 00:36:34,690
code transformation now the other thing
that you can imagine what this malware

412
00:36:34,690 --> 00:36:38,080
has multiple different deals that are
loaded into memory and uses may delegate

413
00:36:38,080 --> 00:36:43,750
stuff on our program not only runs an
executable exe it also run a deal else

414
00:36:43,750 --> 00:36:48,080
right deal else are composed of
functions basic blocks instructions to

415
00:36:48,080 --> 00:36:52,460
pass that single DLL and not the whole
ecosystems single DLL and it can still

416
00:36:52,460 --> 00:36:57,130
do the same analysis can still identify
the owner teens extract the strings so I

417
00:36:57,130 --> 00:37:02,000
expect that will prolly work that
situation I'm just gonna switch back to

418
00:37:02,000 --> 00:37:05,000
the download link here so

419
00:37:15,810 --> 00:37:23,130
totally yes if there are if you can
share them with us we'd love to take a

420
00:37:23,130 --> 00:37:29,350
look at them after and we didn't care
about them or if you have houses here

421
00:37:29,350 --> 00:37:35,089
with the virus total for whatever reason
there but yes if you find symbol that

422
00:37:35,090 --> 00:37:38,780
don't work for some reason we like 30 so
that we may come back and say this is

423
00:37:38,780 --> 00:37:42,010
too complex there's you can easily do it
for you

424
00:37:42,010 --> 00:37:46,410
forward to mention let's try to patch it
and get it working for you as well we'd

425
00:37:46,410 --> 00:37:49,430
love if it finds people that don't work
tomorrow way

426
00:38:00,600 --> 00:38:03,950
right so good question here about like
what happens if we actually do have a

427
00:38:03,950 --> 00:38:11,220
pack sample with UPS or any other
packers what is the deal I talking to

428
00:38:11,220 --> 00:38:14,830
work very well right there still is
really gonna work well if we have files

429
00:38:14,830 --> 00:38:21,560
that are not already packed but use only
string obfuscation techniques ok so

430
00:38:21,560 --> 00:38:25,930
we're not really able to effectively
simulate the unpacking phase and that

431
00:38:25,930 --> 00:38:30,819
continue to analyze strictly dealing
with an hour that tries to pretend that

432
00:38:30,820 --> 00:38:36,190
it's delicious by not talking itself but
again hiding those critical resources

433
00:38:36,190 --> 00:38:44,270
often strings were able to manually on
packet and optical memory something like

434
00:38:44,270 --> 00:38:47,640
that then you can go to the system and
it should work just fine

435
00:38:47,640 --> 00:39:02,810
Italy of the next hour so if you do

436
00:39:04,760 --> 00:39:06,930
trap

437
00:39:06,930 --> 00:39:14,109
alright you want to know more about
packing a meter or not about power

438
00:39:14,109 --> 00:39:30,819
analysis and this guy does let's keep
our samples does support analysis of

439
00:39:30,819 --> 00:39:40,420
armed analyzing the code and also I
armed emulations support was recently

440
00:39:40,420 --> 00:39:46,430
emerged and for some months so a lot of
this analysis should translate over

441
00:39:46,430 --> 00:39:52,540
forearm by Darius but again I don't have
enough players to practice on so I don't

442
00:39:52,540 --> 00:39:58,339
know it deftly feasible I'd love to do
that research as well

443
00:40:13,060 --> 00:40:27,830
if you have to do is an extra option you
pass the strings to get it done Chinese

444
00:40:27,830 --> 00:40:32,970
strings or Russian strings whatever I'm
not familiar with that option I don't

445
00:40:32,970 --> 00:40:35,810
really know how you approach it I think
we could find a solution we can find a

446
00:40:35,810 --> 00:40:40,070
way to extract chinese dreams are only
Russian we might have to have a

447
00:40:40,070 --> 00:40:44,140
dictionary in there that has a list of
all the valid characters but off the top

448
00:40:44,140 --> 00:40:49,040
of my head I'm not familiar with the
library that he does this have to work

449
00:40:49,040 --> 00:40:52,040
on that

450
00:40:58,589 --> 00:41:01,640
generally

451
00:41:01,640 --> 00:41:07,670
I think that's that's a great
counterpoint so there would that be

452
00:41:07,670 --> 00:41:18,349
value to this point I don't think we're
cutting into the people's times yet so

453
00:41:18,349 --> 00:41:22,779
if you have more questions will answer
them but also if you another beer feel

454
00:41:22,779 --> 00:41:25,609
free to grab one and will check in on
the next presentation as well

