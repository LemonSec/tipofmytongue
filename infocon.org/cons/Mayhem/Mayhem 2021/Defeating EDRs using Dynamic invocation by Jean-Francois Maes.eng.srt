1
00:00:01,439 --> 00:00:03,679
hello and welcome

2
00:00:03,679 --> 00:00:05,759
thank you for taking some time out of

3
00:00:05,759 --> 00:00:07,680
your schedule to be with me

4
00:00:07,680 --> 00:00:11,040
here today and letting me talk about

5
00:00:11,040 --> 00:00:13,120
well a framework that i really really

6
00:00:13,120 --> 00:00:14,799
like and i really really

7
00:00:14,799 --> 00:00:17,600
enjoy using it's called the invoke which

8
00:00:17,600 --> 00:00:19,520
stands for dynamic invoke

9
00:00:19,520 --> 00:00:21,279
and it's an open source framework

10
00:00:21,279 --> 00:00:24,160
created by the rover in c-sharp

11
00:00:24,160 --> 00:00:26,640
and it's designed to help red team

12
00:00:26,640 --> 00:00:28,000
operators

13
00:00:28,000 --> 00:00:30,560
advance their trade crafts a bit to the

14
00:00:30,560 --> 00:00:31,359
next level

15
00:00:31,359 --> 00:00:34,079
a bit more uh like real threat actors

16
00:00:34,079 --> 00:00:35,520
would

17
00:00:35,520 --> 00:00:37,600
uh one of the many benefits of the

18
00:00:37,600 --> 00:00:39,440
invoke is that it has the capabilities

19
00:00:39,440 --> 00:00:41,920
to actually try and defeat edrs at least

20
00:00:41,920 --> 00:00:42,640
from a

21
00:00:42,640 --> 00:00:45,280
user land perspective so unhooking the

22
00:00:45,280 --> 00:00:47,120
user land hooks

23
00:00:47,120 --> 00:00:49,120
people that are familiar with edrs know

24
00:00:49,120 --> 00:00:50,879
that most edrs also have

25
00:00:50,879 --> 00:00:54,239
kernel callbacks the thing there is

26
00:00:54,239 --> 00:00:56,559
it's kind of hard to to defeat kernel

27
00:00:56,559 --> 00:00:58,559
callbacks from from user modes

28
00:00:58,559 --> 00:01:00,640
it's a bit out of scope of this topic

29
00:01:00,640 --> 00:01:02,559
with the out of scope of this talk

30
00:01:02,559 --> 00:01:05,840
so i'm just going to zoom in on the the

31
00:01:05,840 --> 00:01:07,760
user land perspective of etrs and how

32
00:01:07,760 --> 00:01:09,520
you can potentially defeat them using

33
00:01:09,520 --> 00:01:13,600
the invoke so a little bit about me

34
00:01:13,600 --> 00:01:16,080
i am joffrey suamas i'm actually a

35
00:01:16,080 --> 00:01:18,000
senior red teamer at inviso

36
00:01:18,000 --> 00:01:20,159
where i'm also the technical driver of

37
00:01:20,159 --> 00:01:22,400
all things red so i oversee a bit of the

38
00:01:22,400 --> 00:01:25,280
technical side of the red team at inviso

39
00:01:25,280 --> 00:01:26,880
i decide which tools we

40
00:01:26,880 --> 00:01:29,680
use and which ones we develop i am also

41
00:01:29,680 --> 00:01:31,040
the creator of red team's

42
00:01:31,040 --> 00:01:34,159
red team tips which is a help website

43
00:01:34,159 --> 00:01:36,079
for red teamers where i occasionally

44
00:01:36,079 --> 00:01:38,640
post nice snippets and nice tips

45
00:01:38,640 --> 00:01:41,680
some blog posts as well since a few

46
00:01:41,680 --> 00:01:43,040
months i'm also the host

47
00:01:43,040 --> 00:01:45,200
of the voices of infosec podcasts this

48
00:01:45,200 --> 00:01:46,560
podcast is designed

49
00:01:46,560 --> 00:01:49,439
and tailored for people to well enjoy

50
00:01:49,439 --> 00:01:50,159
listening to

51
00:01:50,159 --> 00:01:52,640
in first place and to help people

52
00:01:52,640 --> 00:01:54,960
transition into infosec

53
00:01:54,960 --> 00:01:57,520
i'm also the contributor of the sans sec

54
00:01:57,520 --> 00:01:58,560
560

55
00:01:58,560 --> 00:02:02,960
and sans sec 699 where i'm actually also

56
00:02:02,960 --> 00:02:05,520
a candidate instructor for the 699 so

57
00:02:05,520 --> 00:02:06,960
that's very nice as well

58
00:02:06,960 --> 00:02:08,959
and i'm also a big devourer of chicken

59
00:02:08,959 --> 00:02:10,878
and other proteins i'm a strong believer

60
00:02:10,878 --> 00:02:12,640
of a hashtag red team fit

61
00:02:12,640 --> 00:02:16,879
so there you go so what's on our agenda

62
00:02:16,879 --> 00:02:17,599
for today

63
00:02:17,599 --> 00:02:19,760
first i'm going to talk about well i'm

64
00:02:19,760 --> 00:02:20,720
going to take you

65
00:02:20,720 --> 00:02:23,120
to a trip down memory lane i'm going to

66
00:02:23,120 --> 00:02:25,599
give a small win32 api primer because

67
00:02:25,599 --> 00:02:26,879
you'll have to understand

68
00:02:26,879 --> 00:02:29,040
how the windows api works in order to

69
00:02:29,040 --> 00:02:31,040
fully understand what dnvo can do for

70
00:02:31,040 --> 00:02:31,680
you

71
00:02:31,680 --> 00:02:33,920
i'm also going to talk a bit about edrs

72
00:02:33,920 --> 00:02:36,080
and whether or not they are malware i

73
00:02:36,080 --> 00:02:37,920
occasionally like to joke that edrs are

74
00:02:37,920 --> 00:02:39,840
malware themselves

75
00:02:39,840 --> 00:02:42,080
we're going to create their own edr

76
00:02:42,080 --> 00:02:43,840
because i don't want to

77
00:02:43,840 --> 00:02:47,040
bypass any high reputable vendors

78
00:02:47,040 --> 00:02:48,400
in this stock i don't want to piss

79
00:02:48,400 --> 00:02:50,879
anyone off so i decided to

80
00:02:50,879 --> 00:02:53,680
to create my own edr well it's largely

81
00:02:53,680 --> 00:02:54,720
based

82
00:02:54,720 --> 00:02:57,040
on a project that ethical chaos actually

83
00:02:57,040 --> 00:02:58,720
posted on github but more about that

84
00:02:58,720 --> 00:02:59,680
later

85
00:02:59,680 --> 00:03:01,360
we're also going to talk about messing

86
00:03:01,360 --> 00:03:03,440
with creation flags in order to twert

87
00:03:03,440 --> 00:03:04,319
edrs

88
00:03:04,319 --> 00:03:07,120
um we'll give with the invoke primer

89
00:03:07,120 --> 00:03:08,879
going to talk about manual mapping

90
00:03:08,879 --> 00:03:11,360
and syscalls so that's uh what's on the

91
00:03:11,360 --> 00:03:12,720
menu for today

92
00:03:12,720 --> 00:03:15,760
so let's dive in so let's talk a bit

93
00:03:15,760 --> 00:03:16,159
about

94
00:03:16,159 --> 00:03:18,159
pen testing and when i say pen testing

95
00:03:18,159 --> 00:03:19,680
in the context of this talk

96
00:03:19,680 --> 00:03:22,000
i'm talking about well infrastructure

97
00:03:22,000 --> 00:03:22,959
pen testing

98
00:03:22,959 --> 00:03:25,840
and quote unquote red teaming depends on

99
00:03:25,840 --> 00:03:29,040
your optics of what you call a red team

100
00:03:29,040 --> 00:03:31,840
so back in the early days this was even

101
00:03:31,840 --> 00:03:35,280
before i started pen testing myself

102
00:03:35,280 --> 00:03:37,519
well things tended to be a lot easier

103
00:03:37,519 --> 00:03:38,959
than they are today

104
00:03:38,959 --> 00:03:42,080
um back then you could just run

105
00:03:42,080 --> 00:03:43,200
metasploit

106
00:03:43,200 --> 00:03:47,120
a meterpreter session you didn't have to

107
00:03:47,120 --> 00:03:50,400
mess with uh signatures or you didn't

108
00:03:50,400 --> 00:03:52,560
have to encode anything you could just

109
00:03:52,560 --> 00:03:55,439
drop it to disk even and run it and you

110
00:03:55,439 --> 00:03:57,360
you would spawn a meterpreter shell

111
00:03:57,360 --> 00:03:59,040
because well let's face it the

112
00:03:59,040 --> 00:04:00,799
antiviruses and well

113
00:04:00,799 --> 00:04:03,280
edrs but i don't think edrs were a thing

114
00:04:03,280 --> 00:04:04,239
back then

115
00:04:04,239 --> 00:04:06,400
just weren't as good as they are now

116
00:04:06,400 --> 00:04:08,239
which kind of makes sense right it's a

117
00:04:08,239 --> 00:04:09,920
good thing that edrs and

118
00:04:09,920 --> 00:04:12,560
antiviruses are evolving over time but

119
00:04:12,560 --> 00:04:14,319
that also means that we

120
00:04:14,319 --> 00:04:16,639
as a the offensive point of view have to

121
00:04:16,639 --> 00:04:18,320
evolve with

122
00:04:18,320 --> 00:04:21,120
them because otherwise well if we don't

123
00:04:21,120 --> 00:04:23,040
have the capabilities to defeat the

124
00:04:23,040 --> 00:04:24,880
antivirus or the edr then

125
00:04:24,880 --> 00:04:27,919
there's not really much well much left

126
00:04:27,919 --> 00:04:29,520
to be done which would be very nice but

127
00:04:29,520 --> 00:04:31,280
unfortunately that's not the case edrs

128
00:04:31,280 --> 00:04:32,560
are not foolproof

129
00:04:32,560 --> 00:04:35,600
antiviruses are not foolproof either um

130
00:04:35,600 --> 00:04:38,960
so yeah there you go things started to

131
00:04:38,960 --> 00:04:39,600
get

132
00:04:39,600 --> 00:04:41,199
a little bit better from a defensive

133
00:04:41,199 --> 00:04:44,720
point of view when omni became a thing

134
00:04:44,720 --> 00:04:46,960
so that's a that's really really nice

135
00:04:46,960 --> 00:04:48,720
thing that microsoft developed it's open

136
00:04:48,720 --> 00:04:50,080
source it's uh

137
00:04:50,080 --> 00:04:52,240
well it's not completely open source per

138
00:04:52,240 --> 00:04:54,000
se because well it's microsoft

139
00:04:54,000 --> 00:04:56,720
it's definitely closed source but at

140
00:04:56,720 --> 00:04:57,759
least they made it

141
00:04:57,759 --> 00:04:59,680
vendor agnostic and they exposed some

142
00:04:59,680 --> 00:05:01,120
apis which are

143
00:05:01,120 --> 00:05:02,800
quite well documented in the microsoft

144
00:05:02,800 --> 00:05:04,639
documentation so any

145
00:05:04,639 --> 00:05:07,199
antivirus or edr solution can actually

146
00:05:07,199 --> 00:05:08,000
tap into

147
00:05:08,000 --> 00:05:11,520
amsi which is quite nice a lot of the

148
00:05:11,520 --> 00:05:15,039
well-known edr's and antiviruses do so

149
00:05:15,039 --> 00:05:17,919
but contrary to popular belief not all

150
00:05:17,919 --> 00:05:20,000
antiviruses or edrs do that

151
00:05:20,000 --> 00:05:22,560
so if you have an environment if you run

152
00:05:22,560 --> 00:05:24,720
an environment where your antivirus

153
00:05:24,720 --> 00:05:27,199
or your edr product is not leveraging

154
00:05:27,199 --> 00:05:28,240
amsi

155
00:05:28,240 --> 00:05:30,160
you should question whether or not you

156
00:05:30,160 --> 00:05:31,680
have the right product in hand i'm not

157
00:05:31,680 --> 00:05:32,639
going to

158
00:05:32,639 --> 00:05:35,360
down talk any vendors or anything but

159
00:05:35,360 --> 00:05:37,280
given the fact that umc is completely

160
00:05:37,280 --> 00:05:38,720
free

161
00:05:38,720 --> 00:05:41,280
the apis are well documented you should

162
00:05:41,280 --> 00:05:42,560
ask yourself the question

163
00:05:42,560 --> 00:05:44,720
if your solution defensive solution is

164
00:05:44,720 --> 00:05:47,039
not benefiting from that

165
00:05:47,039 --> 00:05:49,360
why they don't want to do that because

166
00:05:49,360 --> 00:05:52,560
well it's it's a very nice thing to have

167
00:05:52,560 --> 00:05:54,880
unfortunately omc is definitely not

168
00:05:54,880 --> 00:05:56,000
without uh

169
00:05:56,000 --> 00:05:58,639
its downfalls or without its blind spots

170
00:05:58,639 --> 00:06:00,400
um i don't know how many of you know

171
00:06:00,400 --> 00:06:02,720
about mc.fail which is a project that

172
00:06:02,720 --> 00:06:03,520
flank vic

173
00:06:03,520 --> 00:06:06,560
actually uh released yeah a couple of

174
00:06:06,560 --> 00:06:08,880
months ago maybe even a year ago now

175
00:06:08,880 --> 00:06:11,759
it just is a website that gives you a

176
00:06:11,759 --> 00:06:14,240
one click button for for an mc bypass

177
00:06:14,240 --> 00:06:16,160
and as you can see here in the slides as

178
00:06:16,160 --> 00:06:18,720
well you can bypass mc in about

179
00:06:18,720 --> 00:06:21,360
five to six lines and and run run your

180
00:06:21,360 --> 00:06:22,960
malicious code anyway

181
00:06:22,960 --> 00:06:25,039
but at least it provides you the first

182
00:06:25,039 --> 00:06:27,840
layer of defense it uh it towards

183
00:06:27,840 --> 00:06:30,720
a lot of the script kitties so to speak

184
00:06:30,720 --> 00:06:31,199
so

185
00:06:31,199 --> 00:06:33,440
at least it's not as easy anymore like

186
00:06:33,440 --> 00:06:35,759
just running a metal split meter reader

187
00:06:35,759 --> 00:06:38,160
out of the box without doing any

188
00:06:38,160 --> 00:06:40,319
modifications to it or without bypassing

189
00:06:40,319 --> 00:06:43,680
mc first so that's already a big win

190
00:06:43,680 --> 00:06:45,600
so that made it a bit harder for us but

191
00:06:45,600 --> 00:06:46,720
what really

192
00:06:46,720 --> 00:06:49,360
took the cake is well the rise of the

193
00:06:49,360 --> 00:06:51,199
the edr so you have your sentinel one

194
00:06:51,199 --> 00:06:52,639
you have your crowd strike

195
00:06:52,639 --> 00:06:55,440
your defender atp or defender for

196
00:06:55,440 --> 00:06:56,800
endpoint

197
00:06:56,800 --> 00:06:59,280
you gotta have a bhd and microsoft

198
00:06:59,280 --> 00:07:01,199
licensing in order to keep up with

199
00:07:01,199 --> 00:07:03,440
all the rebranding and of course there

200
00:07:03,440 --> 00:07:04,960
are countless others these are just some

201
00:07:04,960 --> 00:07:06,080
examples

202
00:07:06,080 --> 00:07:09,360
um so yeah these things made our lives

203
00:07:09,360 --> 00:07:10,400
even

204
00:07:10,400 --> 00:07:12,000
harder from an offensive point of view

205
00:07:12,000 --> 00:07:13,680
because now you don't have to

206
00:07:13,680 --> 00:07:15,680
just deal with amc now you have kernel

207
00:07:15,680 --> 00:07:17,120
callbacks as well you have

208
00:07:17,120 --> 00:07:20,319
inline hooks as well and on top of the

209
00:07:20,319 --> 00:07:21,680
edr framework

210
00:07:21,680 --> 00:07:23,919
uh a framework on top of the edr

211
00:07:23,919 --> 00:07:25,919
software you have other things as well

212
00:07:25,919 --> 00:07:27,919
to take into consideration such as

213
00:07:27,919 --> 00:07:29,759
app locker exploit guard attack surface

214
00:07:29,759 --> 00:07:31,840
reduction and many many many

215
00:07:31,840 --> 00:07:35,280
more other things so life

216
00:07:35,280 --> 00:07:38,639
for a pen tester or a red teamer becomes

217
00:07:38,639 --> 00:07:40,240
harder over the time which is a very

218
00:07:40,240 --> 00:07:42,639
good thing unfortunately

219
00:07:42,639 --> 00:07:46,240
even edrs are still not foolproof

220
00:07:46,240 --> 00:07:47,680
they get better over time as well

221
00:07:47,680 --> 00:07:48,800
because there's a lot of machine

222
00:07:48,800 --> 00:07:49,599
learning

223
00:07:49,599 --> 00:07:51,680
going on in the back end and a lot of

224
00:07:51,680 --> 00:07:54,160
well cloud integration nowadays as well

225
00:07:54,160 --> 00:07:57,120
but until that day comes that they are

226
00:07:57,120 --> 00:07:58,080
undefeatable

227
00:07:58,080 --> 00:08:01,599
which might still be quite a long time

228
00:08:01,599 --> 00:08:04,639
uh yeah bypasses still exists and that's

229
00:08:04,639 --> 00:08:07,840
what i'm going to talk about today

230
00:08:07,840 --> 00:08:11,520
so first before i'm actually going to

231
00:08:11,520 --> 00:08:12,080
talk about

232
00:08:12,080 --> 00:08:14,400
bypasses i need to talk to you all about

233
00:08:14,400 --> 00:08:15,759
the windows api

234
00:08:15,759 --> 00:08:19,520
which is win32 api so the windows

235
00:08:19,520 --> 00:08:20,479
operating system

236
00:08:20,479 --> 00:08:22,879
exposes apis in order for applications

237
00:08:22,879 --> 00:08:23,599
to interact

238
00:08:23,599 --> 00:08:25,440
with the operating system i guess that

239
00:08:25,440 --> 00:08:26,960
makes sense for most of you

240
00:08:26,960 --> 00:08:29,440
the windows api also forms a bridge from

241
00:08:29,440 --> 00:08:31,440
userland to kernel land

242
00:08:31,440 --> 00:08:34,719
with the famous ntdl.dll as the lowest

243
00:08:34,719 --> 00:08:37,760
level reachable from userland i'm going

244
00:08:37,760 --> 00:08:38,599
to talk about

245
00:08:38,599 --> 00:08:42,080
ntdll.dll in a second so the the really

246
00:08:42,080 --> 00:08:44,640
important takeaway of this slide

247
00:08:44,640 --> 00:08:47,040
is that you'll have to understand that

248
00:08:47,040 --> 00:08:48,880
everything that interacts with your

249
00:08:48,880 --> 00:08:50,000
operating system

250
00:08:50,000 --> 00:08:53,760
in the back ends docs or uses or

251
00:08:53,760 --> 00:08:54,480
leverages

252
00:08:54,480 --> 00:08:57,839
these win32 apis even um

253
00:08:57,839 --> 00:09:00,000
for for the people that are a bit less

254
00:09:00,000 --> 00:09:01,920
experienced in in the pen testing filter

255
00:09:01,920 --> 00:09:03,120
the red teaming field

256
00:09:03,120 --> 00:09:05,279
you know like metasploit or shell codes

257
00:09:05,279 --> 00:09:06,959
doesn't matter which shell codes

258
00:09:06,959 --> 00:09:09,279
well they still have to leverage these

259
00:09:09,279 --> 00:09:11,519
apis in order to operate

260
00:09:11,519 --> 00:09:13,040
successfully in order to interact with

261
00:09:13,040 --> 00:09:15,120
the operating system so that's a really

262
00:09:15,120 --> 00:09:16,480
important takeaway that you have to

263
00:09:16,480 --> 00:09:17,360
understand

264
00:09:17,360 --> 00:09:19,839
that the win32 api is very very

265
00:09:19,839 --> 00:09:21,920
important both from an offensive and

266
00:09:21,920 --> 00:09:24,959
defensive perspective

267
00:09:24,959 --> 00:09:27,600
so let's talk about some of the naughty

268
00:09:27,600 --> 00:09:28,160
stuff

269
00:09:28,160 --> 00:09:31,279
you can do with the win32 api and for

270
00:09:31,279 --> 00:09:32,720
this slide i took

271
00:09:32,720 --> 00:09:35,760
the classic dll injection as an example

272
00:09:35,760 --> 00:09:39,440
so there are about four or five win322

273
00:09:39,440 --> 00:09:42,000
api calls that are uh

274
00:09:42,000 --> 00:09:44,800
important here for your most basic

275
00:09:44,800 --> 00:09:47,360
vanilla classic dll injection there are

276
00:09:47,360 --> 00:09:48,240
other ways of

277
00:09:48,240 --> 00:09:50,800
injecting dlls or even shellcode but

278
00:09:50,800 --> 00:09:51,600
just like the

279
00:09:51,600 --> 00:09:53,760
the most basic point of view actually

280
00:09:53,760 --> 00:09:55,040
relies on the following

281
00:09:55,040 --> 00:09:58,480
api calls which is virtual unlock to

282
00:09:58,480 --> 00:10:01,440
allocate new memory into a process

283
00:10:01,440 --> 00:10:03,120
virtual protect to change the memory

284
00:10:03,120 --> 00:10:04,000
permission so you can

285
00:10:04,000 --> 00:10:07,040
actually write something to that memory

286
00:10:07,040 --> 00:10:08,959
write process memory well of course

287
00:10:08,959 --> 00:10:11,279
that's to write data to your newly

288
00:10:11,279 --> 00:10:12,800
created memory

289
00:10:12,800 --> 00:10:14,959
and create remote threads which will

290
00:10:14,959 --> 00:10:16,880
create a new thread into the address

291
00:10:16,880 --> 00:10:18,480
space of the process

292
00:10:18,480 --> 00:10:21,440
and actually launch your uh well

293
00:10:21,440 --> 00:10:23,839
malicious code so to say

294
00:10:23,839 --> 00:10:26,800
so as you can see dll injection highly

295
00:10:26,800 --> 00:10:27,440
leverages

296
00:10:27,440 --> 00:10:31,040
the swin32 api as well

297
00:10:31,040 --> 00:10:33,040
so as a rule of thumb this is very

298
00:10:33,040 --> 00:10:34,720
important to understand as well you want

299
00:10:34,720 --> 00:10:36,800
to stick as close to the kernel

300
00:10:36,800 --> 00:10:40,000
as possible so that means that for

301
00:10:40,000 --> 00:10:41,760
example the api calls that i just

302
00:10:41,760 --> 00:10:43,519
mentioned in the previous slide

303
00:10:43,519 --> 00:10:46,600
were all api calls that live in kernel

304
00:10:46,600 --> 00:10:48,959
32.dll

305
00:10:48,959 --> 00:10:51,200
and some of you might know and to those

306
00:10:51,200 --> 00:10:52,160
that don't know

307
00:10:52,160 --> 00:10:53,600
well now you know because i'm going to

308
00:10:53,600 --> 00:10:55,600
explain it to you

309
00:10:55,600 --> 00:10:58,640
every high tier api call so every module

310
00:10:58,640 --> 00:11:00,720
that gets loaded into a process

311
00:11:00,720 --> 00:11:03,360
actually calls the ntdll.tll at some

312
00:11:03,360 --> 00:11:03,920
point

313
00:11:03,920 --> 00:11:06,160
because ntdl.dll is as i already

314
00:11:06,160 --> 00:11:07,120
mentioned

315
00:11:07,120 --> 00:11:09,200
the bridge between user land and kernel

316
00:11:09,200 --> 00:11:10,880
land so it means that

317
00:11:10,880 --> 00:11:13,760
kernel 32 for example virtual unlock the

318
00:11:13,760 --> 00:11:15,120
virtual allocal

319
00:11:15,120 --> 00:11:18,079
will actually call the nt equivalent in

320
00:11:18,079 --> 00:11:18,959
the background

321
00:11:18,959 --> 00:11:21,200
and you'll see that in just a minute a

322
00:11:21,200 --> 00:11:22,480
very nice read as well

323
00:11:22,480 --> 00:11:24,079
if you are interested in this kind of

324
00:11:24,079 --> 00:11:26,000
stuff is actually by

325
00:11:26,000 --> 00:11:29,440
rasta mouse the the link is referenced

326
00:11:29,440 --> 00:11:31,120
in the slides and the slides will be

327
00:11:31,120 --> 00:11:31,519
made

328
00:11:31,519 --> 00:11:34,160
publicly available as well so don't

329
00:11:34,160 --> 00:11:35,839
worry about that if you

330
00:11:35,839 --> 00:11:38,800
couldn't get the url from just watching

331
00:11:38,800 --> 00:11:41,279
this talk

332
00:11:41,360 --> 00:11:44,480
so let's just take a very uh simple

333
00:11:44,480 --> 00:11:47,519
example loader as you can see here i

334
00:11:47,519 --> 00:11:49,920
this is not the invoke this is just

335
00:11:49,920 --> 00:11:51,839
platform invocation i will talk about

336
00:11:51,839 --> 00:11:52,639
the differences

337
00:11:52,639 --> 00:11:54,560
in just a minute but here you can

338
00:11:54,560 --> 00:11:56,600
definitely see that i'm importing kernel

339
00:11:56,600 --> 00:11:57,920
32dlo

340
00:11:57,920 --> 00:12:01,360
in my code actually uh specifically

341
00:12:01,360 --> 00:12:03,279
calling the create process a

342
00:12:03,279 --> 00:12:05,600
the virtual unlock x the right process

343
00:12:05,600 --> 00:12:06,320
memory

344
00:12:06,320 --> 00:12:08,959
and the create remote threat api calls

345
00:12:08,959 --> 00:12:10,720
so those are the api calls that i

346
00:12:10,720 --> 00:12:11,200
actually

347
00:12:11,200 --> 00:12:14,320
imported manually into my c sharp codes

348
00:12:14,320 --> 00:12:16,399
and then i'm just leveraging them into

349
00:12:16,399 --> 00:12:18,480
the uh into the main

350
00:12:18,480 --> 00:12:20,560
um well the main function the entry

351
00:12:20,560 --> 00:12:22,000
point of my application

352
00:12:22,000 --> 00:12:24,959
to actually spawn a new process and to

353
00:12:24,959 --> 00:12:26,959
copy my shellcode into the new process

354
00:12:26,959 --> 00:12:29,600
and create a threat

355
00:12:29,600 --> 00:12:31,440
so what would that look like well it's

356
00:12:31,440 --> 00:12:33,600
actually fairly simple if i create

357
00:12:33,600 --> 00:12:36,720
this uh if i launch my demo basic loader

358
00:12:36,720 --> 00:12:38,160
and i give it an arbitrary

359
00:12:38,160 --> 00:12:40,320
value for example notepad i'm actually

360
00:12:40,320 --> 00:12:43,440
going to spawn a new notepad

361
00:12:43,440 --> 00:12:45,440
i'm actually going to hit some keys hit

362
00:12:45,440 --> 00:12:47,040
a key to allocate memory hit the key to

363
00:12:47,040 --> 00:12:48,000
write memory

364
00:12:48,000 --> 00:12:49,680
hit a key to create a thread and launch

365
00:12:49,680 --> 00:12:51,360
or shellcode and

366
00:12:51,360 --> 00:12:53,600
when i align when i hit the last key

367
00:12:53,600 --> 00:12:54,399
actually this

368
00:12:54,399 --> 00:12:58,079
evil payload message box will show up

369
00:12:58,079 --> 00:13:00,079
and what it's interesting here as well

370
00:13:00,079 --> 00:13:02,399
is if you look at process hacker

371
00:13:02,399 --> 00:13:05,120
this is a very nice tell that something

372
00:13:05,120 --> 00:13:06,079
malicious is going

373
00:13:06,079 --> 00:13:09,200
on is actually i created in the basic

374
00:13:09,200 --> 00:13:10,560
loader i'm using

375
00:13:10,560 --> 00:13:12,959
read write execute permissions so if you

376
00:13:12,959 --> 00:13:15,680
would inspect that process tree

377
00:13:15,680 --> 00:13:18,079
uh in process hacker and look at the the

378
00:13:18,079 --> 00:13:18,720
loaded

379
00:13:18,720 --> 00:13:20,959
modules into the memory you'll actually

380
00:13:20,959 --> 00:13:23,200
see that there's now a new page created

381
00:13:23,200 --> 00:13:26,320
about four kilobytes big which is read

382
00:13:26,320 --> 00:13:28,720
write execute and it's the only

383
00:13:28,720 --> 00:13:31,839
read write execute page in the entire

384
00:13:31,839 --> 00:13:34,399
memory of that process so if i would

385
00:13:34,399 --> 00:13:36,320
open that up you'll actually see

386
00:13:36,320 --> 00:13:38,800
that this is indeed a message box

387
00:13:38,800 --> 00:13:40,079
payload because you can see it in the

388
00:13:40,079 --> 00:13:41,040
hex dump

389
00:13:41,040 --> 00:13:42,760
as you can see here evil

390
00:13:42,760 --> 00:13:44,079
payload.messagebox

391
00:13:44,079 --> 00:13:45,519
it's actually the message box that i'm

392
00:13:45,519 --> 00:13:48,399
going to uh to spawn as you can see here

393
00:13:48,399 --> 00:13:51,040
so that's a very nice style in my

394
00:13:51,040 --> 00:13:52,480
opinion and something to

395
00:13:52,480 --> 00:13:55,199
well to note if you're a defender to

396
00:13:55,199 --> 00:13:56,000
actually

397
00:13:56,000 --> 00:13:57,680
look at this kind of stuff and that's

398
00:13:57,680 --> 00:14:00,000
exactly what an edr will do as well

399
00:14:00,000 --> 00:14:02,959
if an edr sees read write execute into

400
00:14:02,959 --> 00:14:04,320
an application

401
00:14:04,320 --> 00:14:06,079
it might actually already send out an

402
00:14:06,079 --> 00:14:07,760
alert because this is not something you

403
00:14:07,760 --> 00:14:08,160
see

404
00:14:08,160 --> 00:14:10,880
in a typical behavior this typically

405
00:14:10,880 --> 00:14:13,920
doesn't happen that often

406
00:14:14,320 --> 00:14:16,480
and just so you can see that i'm not

407
00:14:16,480 --> 00:14:17,760
lying there's actually

408
00:14:17,760 --> 00:14:21,519
a very nice free tool as well called api

409
00:14:21,519 --> 00:14:22,720
monitor

410
00:14:22,720 --> 00:14:25,680
which can actually monitor the api calls

411
00:14:25,680 --> 00:14:27,920
that a specific process is making

412
00:14:27,920 --> 00:14:30,000
so here i attached it actually to my

413
00:14:30,000 --> 00:14:31,440
demo basic loader to

414
00:14:31,440 --> 00:14:33,279
check what the hell is going on in the

415
00:14:33,279 --> 00:14:35,519
background as you can see here

416
00:14:35,519 --> 00:14:38,000
clr.dll which is actually the uh well

417
00:14:38,000 --> 00:14:39,519
the the process

418
00:14:39,519 --> 00:14:43,199
that is actually loading or net assembly

419
00:14:43,199 --> 00:14:46,160
is calling virtual alloc x which is a

420
00:14:46,160 --> 00:14:47,519
kernel 32 call

421
00:14:47,519 --> 00:14:50,079
but as you can see in the call tree into

422
00:14:50,079 --> 00:14:50,639
allocate

423
00:14:50,639 --> 00:14:52,880
virtual memory is actually being called

424
00:14:52,880 --> 00:14:54,079
an nt

425
00:14:54,079 --> 00:14:57,519
if you see nt this typically means that

426
00:14:57,519 --> 00:14:59,600
that function that exported function

427
00:14:59,600 --> 00:15:00,880
lives in ntdl

428
00:15:00,880 --> 00:15:04,320
dll so that's what i meant

429
00:15:04,320 --> 00:15:08,720
with higher process trees and actually

430
00:15:08,720 --> 00:15:10,959
trying to stay as close to kernel level

431
00:15:10,959 --> 00:15:12,160
as possible

432
00:15:12,160 --> 00:15:15,680
because as you can see kernel 32 api

433
00:15:15,680 --> 00:15:16,240
calls

434
00:15:16,240 --> 00:15:19,600
are reliant on ntdl.dll anyway

435
00:15:19,600 --> 00:15:22,240
so from an offensive point of view it

436
00:15:22,240 --> 00:15:23,680
makes sense to

437
00:15:23,680 --> 00:15:26,079
call nt dll.tl exported functions

438
00:15:26,079 --> 00:15:27,040
directly

439
00:15:27,040 --> 00:15:28,720
because it doesn't really make sense to

440
00:15:28,720 --> 00:15:31,519
go higher up because from a

441
00:15:31,519 --> 00:15:34,800
defensive point of view edrs will check

442
00:15:34,800 --> 00:15:38,079
the ntdl dll why because well it makes

443
00:15:38,079 --> 00:15:39,519
life easier for them

444
00:15:39,519 --> 00:15:42,399
because every single higher tiered model

445
00:15:42,399 --> 00:15:43,279
will actually call

446
00:15:43,279 --> 00:15:45,839
ntd level dll anyway so from a

447
00:15:45,839 --> 00:15:47,360
performance point of view

448
00:15:47,360 --> 00:15:49,920
if you just hook all the ntd level dll

449
00:15:49,920 --> 00:15:50,480
calls

450
00:15:50,480 --> 00:15:52,880
which by the way doesn't happen each edr

451
00:15:52,880 --> 00:15:54,480
vendor only

452
00:15:54,480 --> 00:15:57,040
hooks very specific functions but

453
00:15:57,040 --> 00:15:59,040
imagine for the sake of argument

454
00:15:59,040 --> 00:16:02,160
that an etr would hook all ntdl dll

455
00:16:02,160 --> 00:16:03,519
calls well that means that

456
00:16:03,519 --> 00:16:05,600
anything that is higher up in the

457
00:16:05,600 --> 00:16:07,920
hierarchy will actually end up calling

458
00:16:07,920 --> 00:16:10,240
into dll.dll anyway which provides

459
00:16:10,240 --> 00:16:12,720
full visibility into the edr to check

460
00:16:12,720 --> 00:16:13,600
whether or not

461
00:16:13,600 --> 00:16:15,759
your api calls are malicious or not i'm

462
00:16:15,759 --> 00:16:18,240
hoping that makes sense

463
00:16:18,240 --> 00:16:21,440
so let's take a look at what the basic

464
00:16:21,440 --> 00:16:22,480
loader does

465
00:16:22,480 --> 00:16:24,560
you already saw it in the slide but i'm

466
00:16:24,560 --> 00:16:26,480
going to give a small demo

467
00:16:26,480 --> 00:16:29,279
anyway just so you can see how it works

468
00:16:29,279 --> 00:16:32,000
in real life

469
00:16:32,000 --> 00:16:35,120
so this is just my my basic box

470
00:16:35,120 --> 00:16:38,079
i'm going to launch powershell real

471
00:16:38,079 --> 00:16:39,440
quick

472
00:16:39,440 --> 00:16:42,639
i'm just going to spawn that basic

473
00:16:42,639 --> 00:16:43,519
loader

474
00:16:43,519 --> 00:16:46,240
as you can see notepad so a notepad

475
00:16:46,240 --> 00:16:48,480
actually popped up on my screen

476
00:16:48,480 --> 00:16:50,720
the process id is one seven one five two

477
00:16:50,720 --> 00:16:53,279
if i would check that in process hacker

478
00:16:53,279 --> 00:16:56,399
uh one seven one five two you'll see

479
00:16:56,399 --> 00:16:58,720
that notepad is indeed there

480
00:16:58,720 --> 00:17:00,560
it says hit a key to allocate memory so

481
00:17:00,560 --> 00:17:02,320
i'm going to do that

482
00:17:02,320 --> 00:17:03,920
hit a key to write memory i'm going to

483
00:17:03,920 --> 00:17:06,400
do that as well hit a key to

484
00:17:06,400 --> 00:17:09,039
launch a thread and a shell code well if

485
00:17:09,039 --> 00:17:09,520
i do

486
00:17:09,520 --> 00:17:12,480
that then there should be a message box

487
00:17:12,480 --> 00:17:13,119
popping up

488
00:17:13,119 --> 00:17:15,599
and it does saying evo payload so that

489
00:17:15,599 --> 00:17:17,280
means that our process injection

490
00:17:17,280 --> 00:17:18,640
actually works

491
00:17:18,640 --> 00:17:20,559
or shellcode injection actually works

492
00:17:20,559 --> 00:17:23,359
and the message box pops up

493
00:17:23,359 --> 00:17:26,720
so that's the first demo if i kill

494
00:17:26,720 --> 00:17:29,280
the message box it'll actually kill my

495
00:17:29,280 --> 00:17:30,880
parent process as well

496
00:17:30,880 --> 00:17:34,400
because i i used metasploit uh msf

497
00:17:34,400 --> 00:17:36,960
venom to create the message box payload

498
00:17:36,960 --> 00:17:39,120
and i didn't define an exit function

499
00:17:39,120 --> 00:17:42,000
which means that if i kill the the shell

500
00:17:42,000 --> 00:17:43,360
code i'm going to kill the parent

501
00:17:43,360 --> 00:17:45,120
process as well which is not very object

502
00:17:45,120 --> 00:17:47,440
safe but well it's a demo anyway

503
00:17:47,440 --> 00:17:48,640
so it doesn't really matter at this

504
00:17:48,640 --> 00:17:50,960
point

505
00:17:51,360 --> 00:17:55,280
all right so what's so special about ntd

506
00:17:55,280 --> 00:17:56,880
allowable dll well

507
00:17:56,880 --> 00:17:59,280
nd functions are essentially cisco

508
00:17:59,280 --> 00:18:00,960
wrappers and they will always have the

509
00:18:00,960 --> 00:18:02,799
same skeleton assembly

510
00:18:02,799 --> 00:18:06,080
which basically means moving r10 into

511
00:18:06,080 --> 00:18:07,679
rcx

512
00:18:07,679 --> 00:18:11,039
and then actually pushing

513
00:18:11,039 --> 00:18:14,400
a syscall into eix so the cisco

514
00:18:14,400 --> 00:18:16,960
here for in the allocate virtual memory

515
00:18:16,960 --> 00:18:18,640
is 18h

516
00:18:18,640 --> 00:18:20,799
but this is where it gets interesting

517
00:18:20,799 --> 00:18:22,080
because

518
00:18:22,080 --> 00:18:25,039
these syscall numbers are not the same

519
00:18:25,039 --> 00:18:25,600
um

520
00:18:25,600 --> 00:18:28,720
on all operating system

521
00:18:28,720 --> 00:18:32,400
versions so for example in this case

522
00:18:32,400 --> 00:18:34,160
it's windows 10

523
00:18:34,160 --> 00:18:36,160
so in windows 10 anti-allocate virtual

524
00:18:36,160 --> 00:18:37,440
memory

525
00:18:37,440 --> 00:18:40,880
is 18h which stands for 18 hexadecimal

526
00:18:40,880 --> 00:18:44,160
but for example on windows xp it could

527
00:18:44,160 --> 00:18:46,799
be a completely different hex value

528
00:18:46,799 --> 00:18:49,200
so you can already imagine from an

529
00:18:49,200 --> 00:18:51,200
offensive point of view it's kind of a

530
00:18:51,200 --> 00:18:53,919
pain if you need to hard code these

531
00:18:53,919 --> 00:18:55,200
syscalls

532
00:18:55,200 --> 00:18:57,280
into your offensive tradecraft because

533
00:18:57,280 --> 00:18:58,720
it depends

534
00:18:58,720 --> 00:19:01,520
whether or not you're on the windows 10

535
00:19:01,520 --> 00:19:02,880
when there is xp

536
00:19:02,880 --> 00:19:06,160
windows server 2008 windows server 2012

537
00:19:06,160 --> 00:19:07,440
and so on and so on

538
00:19:07,440 --> 00:19:10,400
so these numbers tend to change based on

539
00:19:10,400 --> 00:19:12,240
the operating system version

540
00:19:12,240 --> 00:19:16,240
so you'll have to have a check somehow

541
00:19:16,240 --> 00:19:18,960
to to see on which operating system you

542
00:19:18,960 --> 00:19:19,280
are

543
00:19:19,280 --> 00:19:22,320
so statically

544
00:19:22,320 --> 00:19:25,120
using syscalls is kind of a pain because

545
00:19:25,120 --> 00:19:27,520
it depends on your operating system

546
00:19:27,520 --> 00:19:29,280
and for uh luckily for us and

547
00:19:29,280 --> 00:19:31,120
unfortunate for defenders

548
00:19:31,120 --> 00:19:33,120
there's a better way to do this and

549
00:19:33,120 --> 00:19:34,160
that's to actually

550
00:19:34,160 --> 00:19:36,640
resolve the system goals dynamically and

551
00:19:36,640 --> 00:19:37,919
that's something that the info

552
00:19:37,919 --> 00:19:40,480
can do for us i'm going to talk about

553
00:19:40,480 --> 00:19:43,360
that in just a minute

554
00:19:43,360 --> 00:19:47,360
so why do i say that edrs are malware

555
00:19:47,360 --> 00:19:47,919
well

556
00:19:47,919 --> 00:19:51,280
it's actually fairly simple

557
00:19:51,280 --> 00:19:54,799
it's because most edrs if not all edrs

558
00:19:54,799 --> 00:19:58,480
actually leverage the same win32 api

559
00:19:58,480 --> 00:20:00,080
calls like malware would do

560
00:20:00,080 --> 00:20:03,360
in order to inject their own dlls into

561
00:20:03,360 --> 00:20:06,240
spawn processes and the reason why they

562
00:20:06,240 --> 00:20:07,039
have to do that

563
00:20:07,039 --> 00:20:09,600
is because well they need to well from a

564
00:20:09,600 --> 00:20:11,440
user land perspective they need to hook

565
00:20:11,440 --> 00:20:13,440
user functions so they have to inject

566
00:20:13,440 --> 00:20:15,520
their dll at some point

567
00:20:15,520 --> 00:20:18,559
into the process so you can actually uh

568
00:20:18,559 --> 00:20:20,320
well so they can actually see what's

569
00:20:20,320 --> 00:20:22,559
going on from user land

570
00:20:22,559 --> 00:20:24,320
so that's why i'm saying that edrs are

571
00:20:24,320 --> 00:20:26,400
malware they're just

572
00:20:26,400 --> 00:20:32,080
uh vendor approved marvelers so to speak

573
00:20:32,559 --> 00:20:35,760
so how most edrs work from using land

574
00:20:35,760 --> 00:20:36,240
hooking

575
00:20:36,240 --> 00:20:38,480
this is most is very important there

576
00:20:38,480 --> 00:20:40,640
because not all edrs rely on user land

577
00:20:40,640 --> 00:20:41,919
hooks but

578
00:20:41,919 --> 00:20:45,600
most of them do so in this slide you can

579
00:20:45,600 --> 00:20:46,159
actually see

580
00:20:46,159 --> 00:20:49,600
two examples you'll see an example of a

581
00:20:49,600 --> 00:20:51,360
regular function prototype of

582
00:20:51,360 --> 00:20:53,039
anti-allocate virtual memory

583
00:20:53,039 --> 00:20:56,080
as you can see it follows the same

584
00:20:56,080 --> 00:20:58,799
syntax the same skeleton assembly code

585
00:20:58,799 --> 00:21:00,640
as the ntdll function like you would

586
00:21:00,640 --> 00:21:02,159
expect so the r10

587
00:21:02,159 --> 00:21:06,159
rcx ax 18h your cisco and your return

588
00:21:06,159 --> 00:21:06,880
value

589
00:21:06,880 --> 00:21:09,760
but if you look at the second function

590
00:21:09,760 --> 00:21:11,200
prototype which is also

591
00:21:11,200 --> 00:21:13,440
anti-allocated virtual memory you'll see

592
00:21:13,440 --> 00:21:15,440
something completely different here

593
00:21:15,440 --> 00:21:17,840
you'll see that you're actually jumping

594
00:21:17,840 --> 00:21:18,640
into a new

595
00:21:18,640 --> 00:21:20,400
memory space and if you would follow

596
00:21:20,400 --> 00:21:22,159
that memory space you'll actually end up

597
00:21:22,159 --> 00:21:24,400
into the dll of an edr

598
00:21:24,400 --> 00:21:27,600
so you can see that these functions

599
00:21:27,600 --> 00:21:29,440
are definitely not doing the same thing

600
00:21:29,440 --> 00:21:30,799
even though they

601
00:21:30,799 --> 00:21:33,679
are the same thing that's because edr's

602
00:21:33,679 --> 00:21:35,039
divert

603
00:21:35,039 --> 00:21:38,240
your execution flow into their own dll

604
00:21:38,240 --> 00:21:39,280
to do some

605
00:21:39,280 --> 00:21:41,840
arbitrary checks and then have a

606
00:21:41,840 --> 00:21:43,440
decision tree whether or not they will

607
00:21:43,440 --> 00:21:44,000
allow you

608
00:21:44,000 --> 00:21:47,120
to make that api call or not if you're

609
00:21:47,120 --> 00:21:50,159
allowed you'll actually return to the uh

610
00:21:50,159 --> 00:21:52,880
to the normal function and nothing will

611
00:21:52,880 --> 00:21:54,720
happen from a user point of view because

612
00:21:54,720 --> 00:21:55,200
well

613
00:21:55,200 --> 00:21:57,600
it just follows the same flow like you

614
00:21:57,600 --> 00:21:59,840
would expect

615
00:21:59,840 --> 00:22:03,039
however if the edr deems you to be

616
00:22:03,039 --> 00:22:03,919
malicious

617
00:22:03,919 --> 00:22:06,720
uh your your well your api call will be

618
00:22:06,720 --> 00:22:08,640
blocked at that point and the edr will

619
00:22:08,640 --> 00:22:10,480
send out an alert

620
00:22:10,480 --> 00:22:13,600
i hope that makes sense for everyone

621
00:22:13,600 --> 00:22:16,799
so i already actually gave the answer uh

622
00:22:16,799 --> 00:22:19,280
but i'm going to ask the question anyway

623
00:22:19,280 --> 00:22:20,159
what happens

624
00:22:20,159 --> 00:22:21,919
from an offensive point of view if you

625
00:22:21,919 --> 00:22:23,280
create a loader

626
00:22:23,280 --> 00:22:26,480
that actually calls ntdll.dll when your

627
00:22:26,480 --> 00:22:27,200
edr

628
00:22:27,200 --> 00:22:31,039
hooks kernel 32.dll

629
00:22:31,039 --> 00:22:33,520
i'm going to give you a few seconds to

630
00:22:33,520 --> 00:22:35,440
to think about that

631
00:22:35,440 --> 00:22:38,640
unfortunately this is a pre-recorded

632
00:22:38,640 --> 00:22:41,280
stream so i i don't have the the chat or

633
00:22:41,280 --> 00:22:42,559
the audience with me

634
00:22:42,559 --> 00:22:45,760
at time of recording but i hope it makes

635
00:22:45,760 --> 00:22:47,280
sense for most of you if you paid

636
00:22:47,280 --> 00:22:49,280
attention to what i'm saying

637
00:22:49,280 --> 00:22:51,840
that if your edr would hook kernel 32

638
00:22:51,840 --> 00:22:55,120
not dll and you call ntdl.dll directly

639
00:22:55,120 --> 00:22:57,679
you would actually bypass the edr hooks

640
00:22:57,679 --> 00:22:58,799
because you're hooking

641
00:22:58,799 --> 00:23:00,799
at a level above you and you're actually

642
00:23:00,799 --> 00:23:02,559
calling something below that

643
00:23:02,559 --> 00:23:05,600
so you would be um well the edr would be

644
00:23:05,600 --> 00:23:08,240
blind to your winter to do api call

645
00:23:08,240 --> 00:23:10,559
hope that makes sense i'm going to make

646
00:23:10,559 --> 00:23:11,280
it even

647
00:23:11,280 --> 00:23:15,280
more obvious so it really makes a lot of

648
00:23:15,280 --> 00:23:16,320
sense

649
00:23:16,320 --> 00:23:20,159
imagine this very stupid example

650
00:23:20,159 --> 00:23:22,960
so you have a function called hooked

651
00:23:22,960 --> 00:23:24,320
function

652
00:23:24,320 --> 00:23:25,840
and imagine from an offensive point of

653
00:23:25,840 --> 00:23:27,600
view that you know

654
00:23:27,600 --> 00:23:30,320
exactly how it's implemented so you know

655
00:23:30,320 --> 00:23:32,320
exactly the codes to follow

656
00:23:32,320 --> 00:23:35,120
in this case it's just uh well a print

657
00:23:35,120 --> 00:23:36,240
to your outs

658
00:23:36,240 --> 00:23:39,919
to your std out saying either cool stuff

659
00:23:39,919 --> 00:23:42,640
well if you would create another

660
00:23:42,640 --> 00:23:43,279
function

661
00:23:43,279 --> 00:23:44,960
and you would call it another name for

662
00:23:44,960 --> 00:23:47,600
example clone of hooked function

663
00:23:47,600 --> 00:23:49,279
and you copy paste the function

664
00:23:49,279 --> 00:23:50,799
prototype in there so

665
00:23:50,799 --> 00:23:53,279
exactly the same thing either cool stuff

666
00:23:53,279 --> 00:23:54,400
well guess what

667
00:23:54,400 --> 00:23:57,279
if you would call the hooked function

668
00:23:57,279 --> 00:23:58,559
you would do cool stuff

669
00:23:58,559 --> 00:24:01,039
but if you would call your new function

670
00:24:01,039 --> 00:24:01,760
in this case

671
00:24:01,760 --> 00:24:03,919
clone of hooked function you would do

672
00:24:03,919 --> 00:24:05,760
exactly the same thing

673
00:24:05,760 --> 00:24:09,520
so that is a bit how using cisco's

674
00:24:09,520 --> 00:24:12,240
work you're going to create a new

675
00:24:12,240 --> 00:24:13,440
function prototype

676
00:24:13,440 --> 00:24:17,200
using direct syscalls in order to avoid

677
00:24:17,200 --> 00:24:20,320
using the hooked function but the

678
00:24:20,320 --> 00:24:22,320
syscall function you created is going to

679
00:24:22,320 --> 00:24:22,640
do

680
00:24:22,640 --> 00:24:25,039
exactly the same thing so it's going to

681
00:24:25,039 --> 00:24:28,000
work but it's going to bypass the edr

682
00:24:28,000 --> 00:24:32,320
i hope that makes sense so

683
00:24:32,320 --> 00:24:35,360
how can we check uh if this

684
00:24:35,360 --> 00:24:38,080
theory does make sense well thank god

685
00:24:38,080 --> 00:24:40,080
for ethical chaos because he actually

686
00:24:40,080 --> 00:24:42,400
created very nice blog posts

687
00:24:42,400 --> 00:24:45,840
um called creating an edr and bypassing

688
00:24:45,840 --> 00:24:47,679
it or something along those lines

689
00:24:47,679 --> 00:24:49,760
and he open sourced the edr that he

690
00:24:49,760 --> 00:24:50,960
created

691
00:24:50,960 --> 00:24:54,400
it's called silent strike it's a bit of

692
00:24:54,400 --> 00:24:54,960
a

693
00:24:54,960 --> 00:24:57,360
joke to a very popular command and

694
00:24:57,360 --> 00:24:59,679
control framework

695
00:24:59,679 --> 00:25:02,799
so silent strike is there it's on github

696
00:25:02,799 --> 00:25:05,840
and well i basically took his code

697
00:25:05,840 --> 00:25:08,480
and i just um well created some some new

698
00:25:08,480 --> 00:25:09,600
hooks as well

699
00:25:09,600 --> 00:25:13,039
in order to detect and prevent

700
00:25:13,039 --> 00:25:16,080
the basic vanilla shellcode injection

701
00:25:16,080 --> 00:25:18,080
like my basic loader was uh

702
00:25:18,080 --> 00:25:21,840
was doing but i'm hooking on the

703
00:25:21,840 --> 00:25:26,159
ntdl calls in this uh in this edr demo

704
00:25:26,159 --> 00:25:29,200
so my basic loader which was using

705
00:25:29,200 --> 00:25:30,880
kernel 32 calls

706
00:25:30,880 --> 00:25:33,279
is actually going to get spotted by this

707
00:25:33,279 --> 00:25:35,679
edr

708
00:25:35,919 --> 00:25:38,000
and that is exactly what you can see in

709
00:25:38,000 --> 00:25:38,960
this slide

710
00:25:38,960 --> 00:25:42,880
so here i have a listener

711
00:25:42,880 --> 00:25:45,600
that is listening for my my demo loader

712
00:25:45,600 --> 00:25:46,480
basically

713
00:25:46,480 --> 00:25:48,799
it's going to inject the silent strike

714
00:25:48,799 --> 00:25:50,559
dll into that loader

715
00:25:50,559 --> 00:25:53,919
and it's going to hook on the functions

716
00:25:53,919 --> 00:25:56,159
um the allocate virtual memory right

717
00:25:56,159 --> 00:25:58,159
virtual memory and create remote thread

718
00:25:58,159 --> 00:26:00,000
as you can see here if i hit the keys

719
00:26:00,000 --> 00:26:01,360
now you'll actually

720
00:26:01,360 --> 00:26:04,400
see a message box showing up saying oh

721
00:26:04,400 --> 00:26:06,720
yeah you got detected and actually at

722
00:26:06,720 --> 00:26:08,640
the point where i'm going to create the

723
00:26:08,640 --> 00:26:09,440
new thread

724
00:26:09,440 --> 00:26:11,279
i'm actually just going to kill the

725
00:26:11,279 --> 00:26:12,720
process entirely

726
00:26:12,720 --> 00:26:14,880
which means that my message box will now

727
00:26:14,880 --> 00:26:16,320
not show up anymore

728
00:26:16,320 --> 00:26:18,159
and i can see that here as well in the

729
00:26:18,159 --> 00:26:20,000
process hacker if i would check the

730
00:26:20,000 --> 00:26:21,760
loaded modules for my

731
00:26:21,760 --> 00:26:24,559
demo you'll see that silent striker dll

732
00:26:24,559 --> 00:26:25,919
does get injected

733
00:26:25,919 --> 00:26:29,200
and that places the user line hooks

734
00:26:29,200 --> 00:26:31,919
so you'll see that indeed my uh my

735
00:26:31,919 --> 00:26:34,159
loader doesn't work anymore because the

736
00:26:34,159 --> 00:26:38,640
edr now blocks it

737
00:26:38,640 --> 00:26:42,400
so let's show that real quick in a demo

738
00:26:42,400 --> 00:26:42,880
again

739
00:26:42,880 --> 00:26:44,720
here i'm going to need two powershell

740
00:26:44,720 --> 00:26:47,200
prompts one is an administrator

741
00:26:47,200 --> 00:26:51,200
and one is a regular user the first one

742
00:26:51,200 --> 00:26:54,240
is basically just a listener

743
00:26:54,240 --> 00:26:57,520
for my demo process so i the edr silent

744
00:26:57,520 --> 00:27:00,559
strike getting checked into it

745
00:27:00,559 --> 00:27:04,559
so now i'm listening from my demo.exe

746
00:27:04,559 --> 00:27:07,279
to spawn and i'm going to do that right

747
00:27:07,279 --> 00:27:09,120
here

748
00:27:09,120 --> 00:27:12,080
again the notepad pops up i'm going to

749
00:27:12,080 --> 00:27:14,400
minimize notepad and you can see

750
00:27:14,400 --> 00:27:17,240
injecting process with dll

751
00:27:17,240 --> 00:27:18,880
silentstrike.they allow

752
00:27:18,880 --> 00:27:20,960
so if i would now open up process hacker

753
00:27:20,960 --> 00:27:22,559
again

754
00:27:22,559 --> 00:27:26,559
and i check two one five four zero

755
00:27:26,559 --> 00:27:29,919
which is demo.exe i check the loaded

756
00:27:29,919 --> 00:27:30,559
modules

757
00:27:30,559 --> 00:27:33,039
i should see silent strike in there yeah

758
00:27:33,039 --> 00:27:34,720
exactly it is

759
00:27:34,720 --> 00:27:36,799
so now if i hit that key to allocate

760
00:27:36,799 --> 00:27:38,080
memory you'll see

761
00:27:38,080 --> 00:27:40,640
the message box coming saying custom edi

762
00:27:40,640 --> 00:27:42,240
are powered by educalchaos

763
00:27:42,240 --> 00:27:44,640
allocating read write execute memory are

764
00:27:44,640 --> 00:27:46,480
we detected so

765
00:27:46,480 --> 00:27:48,960
it basically means that the edr actually

766
00:27:48,960 --> 00:27:51,039
hooked my kernel 32 function

767
00:27:51,039 --> 00:27:53,200
checked whether or not i'm trying to um

768
00:27:53,200 --> 00:27:54,080
well use

769
00:27:54,080 --> 00:27:57,279
read write execute and well i do

770
00:27:57,279 --> 00:27:59,200
so it's actually popping up this message

771
00:27:59,200 --> 00:28:01,360
box in this case it's just a message box

772
00:28:01,360 --> 00:28:02,000
but a real

773
00:28:02,000 --> 00:28:03,760
edr would just send out an alert of

774
00:28:03,760 --> 00:28:05,039
course without

775
00:28:05,039 --> 00:28:07,120
doing this very obvious thing that uh

776
00:28:07,120 --> 00:28:08,240
that an attacker got

777
00:28:08,240 --> 00:28:11,520
detected so if i press ok i now

778
00:28:11,520 --> 00:28:14,559
hit the key to write memory

779
00:28:14,559 --> 00:28:16,960
writing memory so i get detected once

780
00:28:16,960 --> 00:28:18,240
again

781
00:28:18,240 --> 00:28:19,760
and now hitting the key to create a

782
00:28:19,760 --> 00:28:21,679
thread and launch or shellcode if i

783
00:28:21,679 --> 00:28:23,279
would hit that now

784
00:28:23,279 --> 00:28:25,200
now it says okay that does it i'm not

785
00:28:25,200 --> 00:28:26,960
going to let you create a new thread i'm

786
00:28:26,960 --> 00:28:28,799
killing your process now so basically

787
00:28:28,799 --> 00:28:30,559
this is a giant cockblock

788
00:28:30,559 --> 00:28:33,200
um preventing me from actually spawning

789
00:28:33,200 --> 00:28:34,320
that message box

790
00:28:34,320 --> 00:28:37,200
so if i do okay now you'll see that the

791
00:28:37,200 --> 00:28:38,240
demo.exe

792
00:28:38,240 --> 00:28:40,960
actually got killed completely and just

793
00:28:40,960 --> 00:28:42,799
my notepad remains but no

794
00:28:42,799 --> 00:28:45,440
message box actually popped up so my

795
00:28:45,440 --> 00:28:47,840
payload did not get executed

796
00:28:47,840 --> 00:28:51,039
so that is how an edr uh basically works

797
00:28:51,039 --> 00:28:53,279
in a nutshell obviously there are

798
00:28:53,279 --> 00:28:55,600
way more things to consider but this is

799
00:28:55,600 --> 00:28:57,760
just a very high level view of how edrs

800
00:28:57,760 --> 00:28:59,760
potentially work

801
00:28:59,760 --> 00:29:02,880
now there was for a very small

802
00:29:02,880 --> 00:29:05,840
point in time something really cool you

803
00:29:05,840 --> 00:29:07,120
could do

804
00:29:07,120 --> 00:29:09,440
and it's actually messing with creation

805
00:29:09,440 --> 00:29:10,320
flags

806
00:29:10,320 --> 00:29:12,640
so there's a very cool thing that you

807
00:29:12,640 --> 00:29:13,440
can do

808
00:29:13,440 --> 00:29:16,320
called process creation migration

809
00:29:16,320 --> 00:29:17,360
policies

810
00:29:17,360 --> 00:29:19,520
and one of those migration policies was

811
00:29:19,520 --> 00:29:21,000
actually to block

812
00:29:21,000 --> 00:29:23,919
non-microsoft binaries from injecting

813
00:29:23,919 --> 00:29:25,440
into your process

814
00:29:25,440 --> 00:29:28,480
so basically that means in layman terms

815
00:29:28,480 --> 00:29:31,120
that from that point on if your process

816
00:29:31,120 --> 00:29:32,320
is created with those

817
00:29:32,320 --> 00:29:35,279
process creation flags you now prevent

818
00:29:35,279 --> 00:29:35,840
any

819
00:29:35,840 --> 00:29:38,720
dll that is not microsoft signed to

820
00:29:38,720 --> 00:29:39,279
inject

821
00:29:39,279 --> 00:29:42,640
into your new process so that means that

822
00:29:42,640 --> 00:29:45,039
if an edr vendor

823
00:29:45,039 --> 00:29:48,880
did not have the dll signed by microsoft

824
00:29:48,880 --> 00:29:50,880
you would effectively prevent them from

825
00:29:50,880 --> 00:29:54,080
injecting into your process

826
00:29:54,080 --> 00:29:57,279
luckily for defenders luckily for

827
00:29:57,279 --> 00:29:58,799
defenders

828
00:29:58,799 --> 00:30:02,240
edr vendors caught on to that microsoft

829
00:30:02,240 --> 00:30:03,679
got on to that as well

830
00:30:03,679 --> 00:30:05,600
and microsoft started handing out

831
00:30:05,600 --> 00:30:08,159
intermediate certificates to edr vendors

832
00:30:08,159 --> 00:30:10,640
so their dlls are now microsoft signed

833
00:30:10,640 --> 00:30:12,720
but as you can see here

834
00:30:12,720 --> 00:30:14,559
in this slide you can see uh the

835
00:30:14,559 --> 00:30:16,880
downloader or the demo loader excuse me

836
00:30:16,880 --> 00:30:18,480
with and without creation select

837
00:30:18,480 --> 00:30:20,320
shenanigans so as you can see here

838
00:30:20,320 --> 00:30:23,200
this is just my demo.exe without any

839
00:30:23,200 --> 00:30:25,840
special mitigation policies

840
00:30:25,840 --> 00:30:28,880
if you can see it here it basically says

841
00:30:28,880 --> 00:30:32,159
signature restricted store only so

842
00:30:32,159 --> 00:30:35,360
that means that from now on only

843
00:30:35,360 --> 00:30:38,559
microsoft signed dlls can inject into

844
00:30:38,559 --> 00:30:40,960
the process

845
00:30:40,960 --> 00:30:44,640
and how do you do that well from a csr

846
00:30:44,640 --> 00:30:46,799
perspective it's a bit harder to do

847
00:30:46,799 --> 00:30:49,279
because you'll have to do some managed

848
00:30:49,279 --> 00:30:51,600
to unmanaged memory gymnastics

849
00:30:51,600 --> 00:30:54,640
you have to interrupt between c plus and

850
00:30:54,640 --> 00:30:57,679
c sharp so if you're not that

851
00:30:57,679 --> 00:31:00,640
familiar with c or c plus plus this

852
00:31:00,640 --> 00:31:02,960
could be a bit daunting at first but i

853
00:31:02,960 --> 00:31:04,080
guarantee you

854
00:31:04,080 --> 00:31:06,480
if we just look at some some examples on

855
00:31:06,480 --> 00:31:07,440
github

856
00:31:07,440 --> 00:31:10,240
you actually get a hang of it quite soon

857
00:31:10,240 --> 00:31:10,559
quite

858
00:31:10,559 --> 00:31:13,440
fast and you'll learn how to do this

859
00:31:13,440 --> 00:31:14,320
very very

860
00:31:14,320 --> 00:31:16,960
very very fast so if you do this

861
00:31:16,960 --> 00:31:18,720
correctly you actually prevent

862
00:31:18,720 --> 00:31:20,799
the silence strike in this case because

863
00:31:20,799 --> 00:31:23,200
well it's not an official edr so i don't

864
00:31:23,200 --> 00:31:25,120
have the microsoft certificate

865
00:31:25,120 --> 00:31:27,200
uh you're going to prevent silent strike

866
00:31:27,200 --> 00:31:28,320
uh to inject

867
00:31:28,320 --> 00:31:31,440
into the uh well the demo loader

868
00:31:31,440 --> 00:31:33,919
which basically means that uh well you

869
00:31:33,919 --> 00:31:35,519
actually evade the edr because you

870
00:31:35,519 --> 00:31:37,440
prevent the edr from injecting into your

871
00:31:37,440 --> 00:31:40,640
process in the first place

872
00:31:41,200 --> 00:31:43,200
so as you can see here uh this is the

873
00:31:43,200 --> 00:31:44,559
actual create

874
00:31:44,559 --> 00:31:47,360
process call it has extended startup

875
00:31:47,360 --> 00:31:48,399
info present

876
00:31:48,399 --> 00:31:50,880
because the mitigation flags are

877
00:31:50,880 --> 00:31:51,440
actually

878
00:31:51,440 --> 00:31:53,679
only able to being set in the extended

879
00:31:53,679 --> 00:31:55,600
startup info so that's why you need

880
00:31:55,600 --> 00:31:58,320
that specific process creation flag in

881
00:31:58,320 --> 00:31:59,200
there

882
00:31:59,200 --> 00:32:02,640
in order to actually use uh well

883
00:32:02,640 --> 00:32:05,919
startup info extended uh to actually

884
00:32:05,919 --> 00:32:08,559
have that litigation policy present

885
00:32:08,559 --> 00:32:11,039
and if you see it from an edr point of

886
00:32:11,039 --> 00:32:11,760
view

887
00:32:11,760 --> 00:32:14,240
you actually see that the edr says well

888
00:32:14,240 --> 00:32:16,320
hey no problem man i'm injecting the

889
00:32:16,320 --> 00:32:17,360
process

890
00:32:17,360 --> 00:32:20,720
um into silent strike into the demo

891
00:32:20,720 --> 00:32:23,039
but in reality this is not the case and

892
00:32:23,039 --> 00:32:25,360
even if you would give process hacker

893
00:32:25,360 --> 00:32:28,080
a bit of time you'll actually see that

894
00:32:28,080 --> 00:32:30,000
process hacker itself

895
00:32:30,000 --> 00:32:32,159
also can't create a module information

896
00:32:32,159 --> 00:32:34,399
anymore because the protection conflicts

897
00:32:34,399 --> 00:32:36,720
um the requested bytes so it means

898
00:32:36,720 --> 00:32:38,240
because process hacker itself is not

899
00:32:38,240 --> 00:32:39,679
microsoft signed you're actually

900
00:32:39,679 --> 00:32:41,840
preventing process hacker from injecting

901
00:32:41,840 --> 00:32:43,919
into the binary as well which means that

902
00:32:43,919 --> 00:32:45,120
you now lose the

903
00:32:45,120 --> 00:32:46,640
the nice overview that process hacker

904
00:32:46,640 --> 00:32:49,039
has as well so it's kind of funny

905
00:32:49,039 --> 00:32:51,519
i created a small demo called demo

906
00:32:51,519 --> 00:32:52,799
malware protect

907
00:32:52,799 --> 00:32:55,679
which basically gives me an arbitrary

908
00:32:55,679 --> 00:32:56,720
parent process

909
00:32:56,720 --> 00:32:58,880
in this case explorer so it's using

910
00:32:58,880 --> 00:33:00,960
parent id spoofing that's another common

911
00:33:00,960 --> 00:33:01,519
trick

912
00:33:01,519 --> 00:33:03,840
that adversaries and red teamers alike

913
00:33:03,840 --> 00:33:04,640
tend to

914
00:33:04,640 --> 00:33:06,880
tend to use in order to break parent

915
00:33:06,880 --> 00:33:09,279
child's detections

916
00:33:09,279 --> 00:33:12,480
which is very very powerful which is

917
00:33:12,480 --> 00:33:12,880
also

918
00:33:12,880 --> 00:33:14,720
part of the extended startup information

919
00:33:14,720 --> 00:33:16,080
by the way it's the same uh

920
00:33:16,080 --> 00:33:17,760
the same structure that is capable of

921
00:33:17,760 --> 00:33:20,240
doing that so i have the explorer as a

922
00:33:20,240 --> 00:33:23,519
parent process i'm launching my demo.exe

923
00:33:23,519 --> 00:33:26,880
but my demo.exe now is protected with

924
00:33:26,880 --> 00:33:28,559
that mitigation policy

925
00:33:28,559 --> 00:33:30,880
and you'll actually see that silent

926
00:33:30,880 --> 00:33:31,600
strike is

927
00:33:31,600 --> 00:33:35,039
not injected into the demo.exe even

928
00:33:35,039 --> 00:33:35,360
though

929
00:33:35,360 --> 00:33:38,399
it's falsely assumes that it is

930
00:33:38,399 --> 00:33:41,679
i can execute my payload regardless

931
00:33:41,679 --> 00:33:45,039
so that's quite nice

932
00:33:48,960 --> 00:33:52,240
so now i'm going to use my malware

933
00:33:52,240 --> 00:33:54,799
protect

934
00:33:56,799 --> 00:34:00,080
wrapper around my loader

935
00:34:00,080 --> 00:34:02,799
to prevent silent strike from injecting

936
00:34:02,799 --> 00:34:03,679
into it

937
00:34:03,679 --> 00:34:07,840
so i'm going to start my listener first

938
00:34:09,359 --> 00:34:13,040
so demo.exe i'm now going to use

939
00:34:13,040 --> 00:34:15,599
mobile protect to actually spawn that

940
00:34:15,599 --> 00:34:18,560
demo.exe

941
00:34:19,040 --> 00:34:21,760
as you can see here i'm using explorer

942
00:34:21,760 --> 00:34:23,679
as a parent process

943
00:34:23,679 --> 00:34:26,960
demo.exe and circuit will be notepad

944
00:34:26,960 --> 00:34:30,800
if i launch that you'll see that indeed

945
00:34:30,800 --> 00:34:33,679
my demo.exe spawn notepad and i'm going

946
00:34:33,679 --> 00:34:36,000
to show you that

947
00:34:36,000 --> 00:34:38,639
here as well

948
00:34:40,480 --> 00:34:44,800
so demo.exe if i look here

949
00:34:44,800 --> 00:34:47,119
you see that the parent is explore.exe

950
00:34:47,119 --> 00:34:47,839
obviously this

951
00:34:47,839 --> 00:34:49,280
isn't true because we spawned it from

952
00:34:49,280 --> 00:34:50,879
powershell so that's the parent id

953
00:34:50,879 --> 00:34:51,760
spoofing

954
00:34:51,760 --> 00:34:53,839
you see that the signature is restricted

955
00:34:53,839 --> 00:34:56,480
to stall only

956
00:34:56,480 --> 00:34:59,760
and it means that now if i look here it

957
00:34:59,760 --> 00:35:00,400
says

958
00:35:00,400 --> 00:35:04,240
demo is injected with silent strike but

959
00:35:04,240 --> 00:35:04,800
if we

960
00:35:04,800 --> 00:35:07,839
verify that by checking

961
00:35:07,839 --> 00:35:11,760
the modules

962
00:35:11,760 --> 00:35:15,040
i don't see sound strike anywhere

963
00:35:15,040 --> 00:35:16,800
no silence strike even though it says

964
00:35:16,800 --> 00:35:18,960
that it did inject into it

965
00:35:18,960 --> 00:35:21,359
so for now hit my keys i don't see any

966
00:35:21,359 --> 00:35:23,200
pop-ups

967
00:35:23,200 --> 00:35:27,598
but i do get my payload executed once

968
00:35:28,839 --> 00:35:31,839
again

969
00:35:34,880 --> 00:35:37,599
as i already mentioned vendors got on to

970
00:35:37,599 --> 00:35:38,160
this trick

971
00:35:38,160 --> 00:35:41,520
quite quickly uh you can see here from a

972
00:35:41,520 --> 00:35:43,599
tweet from sector 7

973
00:35:43,599 --> 00:35:46,480
that falcon loads perfectly with block

974
00:35:46,480 --> 00:35:48,960
dlls enabled and hooks into dll

975
00:35:48,960 --> 00:35:50,640
well that's because it's signed by

976
00:35:50,640 --> 00:35:52,400
microsoft so no wonder this doesn't

977
00:35:52,400 --> 00:35:52,880
prevent

978
00:35:52,880 --> 00:35:56,000
edr injection so if you would check

979
00:35:56,000 --> 00:35:58,720
this for example is a from mcafee you'll

980
00:35:58,720 --> 00:36:00,720
see that there is indeed an intermediate

981
00:36:00,720 --> 00:36:02,480
certificate there from microsoft

982
00:36:02,480 --> 00:36:06,720
so that uh epmpthe.dll

983
00:36:06,720 --> 00:36:09,040
would get injected but here's the kicker

984
00:36:09,040 --> 00:36:10,000
though

985
00:36:10,000 --> 00:36:14,079
that mcafee edr process

986
00:36:14,079 --> 00:36:17,200
uh also has a dll called atp

987
00:36:17,200 --> 00:36:21,040
mzguard and that is not

988
00:36:21,040 --> 00:36:22,960
uh including that intermediate

989
00:36:22,960 --> 00:36:26,160
certificate so that would mean that only

990
00:36:26,160 --> 00:36:28,960
parts of the edr would get injected and

991
00:36:28,960 --> 00:36:29,920
other parts that

992
00:36:29,920 --> 00:36:32,160
don't have that microsoft intermediate

993
00:36:32,160 --> 00:36:33,119
certificate

994
00:36:33,119 --> 00:36:36,320
would not so that's quite

995
00:36:36,320 --> 00:36:40,160
nice to know however most popular edr

996
00:36:40,160 --> 00:36:41,040
vendors

997
00:36:41,040 --> 00:36:43,440
have all their their dlls that need to

998
00:36:43,440 --> 00:36:44,240
get injected

999
00:36:44,240 --> 00:36:46,320
signed by this uh well intermediate

1000
00:36:46,320 --> 00:36:48,160
microsoft policy

1001
00:36:48,160 --> 00:36:50,000
so that would completely negate that

1002
00:36:50,000 --> 00:36:51,440
mitigation flag

1003
00:36:51,440 --> 00:36:53,040
so that's back to the drawing board from

1004
00:36:53,040 --> 00:36:54,640
an offensive point of view it was fun

1005
00:36:54,640 --> 00:36:56,880
while it lasted unfortunately it didn't

1006
00:36:56,880 --> 00:36:57,280
last

1007
00:36:57,280 --> 00:37:01,040
that long and here is where it gets

1008
00:37:01,040 --> 00:37:03,200
interesting because here is where the

1009
00:37:03,200 --> 00:37:05,440
invokes start to shine

1010
00:37:05,440 --> 00:37:08,320
so dot net provides a mechanism called

1011
00:37:08,320 --> 00:37:10,240
platform invoke or p invoke that's a

1012
00:37:10,240 --> 00:37:10,880
terminal

1013
00:37:10,880 --> 00:37:13,440
already mentioned during the talk that

1014
00:37:13,440 --> 00:37:14,000
allows

1015
00:37:14,000 --> 00:37:16,880
net applications to access data and apis

1016
00:37:16,880 --> 00:37:18,720
in unmanaged libraries

1017
00:37:18,720 --> 00:37:21,359
or dlls so that's the common way of

1018
00:37:21,359 --> 00:37:22,720
doing things that's how most

1019
00:37:22,720 --> 00:37:25,599
developers uh do that so they actually

1020
00:37:25,599 --> 00:37:26,000
use

1021
00:37:26,000 --> 00:37:28,880
b invoke in order to include dlls uh

1022
00:37:28,880 --> 00:37:29,839
into their

1023
00:37:29,839 --> 00:37:32,480
c sharp code so they can use those api

1024
00:37:32,480 --> 00:37:34,880
calls from those dlls

1025
00:37:34,880 --> 00:37:38,160
but by using b invoke you actually have

1026
00:37:38,160 --> 00:37:40,000
some disadvantages as well

1027
00:37:40,000 --> 00:37:43,280
because well for example the um

1028
00:37:43,280 --> 00:37:45,920
export address table would actually the

1029
00:37:45,920 --> 00:37:47,599
import address table excuse me would

1030
00:37:47,599 --> 00:37:49,520
actually have the reference

1031
00:37:49,520 --> 00:37:52,480
to your imported addresses so that makes

1032
00:37:52,480 --> 00:37:53,440
it um

1033
00:37:53,440 --> 00:37:56,240
easy for uh well reverse engineers to

1034
00:37:56,240 --> 00:37:56,560
just

1035
00:37:56,560 --> 00:37:58,640
check your import address table and they

1036
00:37:58,640 --> 00:38:00,079
would definitely see

1037
00:38:00,079 --> 00:38:01,920
like create remote thread that's already

1038
00:38:01,920 --> 00:38:03,680
quite a red flag because that's not

1039
00:38:03,680 --> 00:38:04,720
something

1040
00:38:04,720 --> 00:38:08,480
a lot of processes need to use

1041
00:38:08,480 --> 00:38:11,440
in actual behavior non-malicious

1042
00:38:11,440 --> 00:38:12,160
behavior

1043
00:38:12,160 --> 00:38:13,920
so they would just have to inspect your

1044
00:38:13,920 --> 00:38:16,000
eit and they would see that

1045
00:38:16,000 --> 00:38:18,079
you're doing some fishy things so that's

1046
00:38:18,079 --> 00:38:19,119
already uh

1047
00:38:19,119 --> 00:38:22,480
a towel and well as i already mentioned

1048
00:38:22,480 --> 00:38:26,960
uh avs and edrs can actually hook those

1049
00:38:26,960 --> 00:38:28,800
apicals as well

1050
00:38:28,800 --> 00:38:31,599
so you would get detected on the same

1051
00:38:31,599 --> 00:38:32,400
fashion

1052
00:38:32,400 --> 00:38:34,800
like the first like the second demo

1053
00:38:34,800 --> 00:38:35,760
where i

1054
00:38:35,760 --> 00:38:38,880
used my silent strike edr

1055
00:38:38,880 --> 00:38:41,359
to actually detect my basic loader so

1056
00:38:41,359 --> 00:38:43,839
that makes sense for a p invoke as well

1057
00:38:43,839 --> 00:38:45,520
so those are the disadvantages of b

1058
00:38:45,520 --> 00:38:48,240
invoke so why would you use the invoke

1059
00:38:48,240 --> 00:38:50,160
then well it's actually fairly simple

1060
00:38:50,160 --> 00:38:53,200
is because now api imports get resolved

1061
00:38:53,200 --> 00:38:55,119
dynamically so that means that there's

1062
00:38:55,119 --> 00:38:56,560
no um

1063
00:38:56,560 --> 00:38:59,839
well there's no mention anymore of any

1064
00:38:59,839 --> 00:39:01,280
apis that get imported

1065
00:39:01,280 --> 00:39:03,440
in your import address table there's

1066
00:39:03,440 --> 00:39:05,920
also functionality to evade hooks using

1067
00:39:05,920 --> 00:39:08,640
manual mapping using deception even and

1068
00:39:08,640 --> 00:39:10,640
syscalls i'm only going to talk about

1069
00:39:10,640 --> 00:39:12,240
manual mapping and syscalls in this

1070
00:39:12,240 --> 00:39:12,800
stock

1071
00:39:12,800 --> 00:39:14,720
because otherwise i would overshoot my

1072
00:39:14,720 --> 00:39:16,320
window

1073
00:39:16,320 --> 00:39:18,640
and it has function prototypes already

1074
00:39:18,640 --> 00:39:20,480
built in for a lot of the api

1075
00:39:20,480 --> 00:39:22,560
calls that we commonly use in offensive

1076
00:39:22,560 --> 00:39:23,520
tradecraft

1077
00:39:23,520 --> 00:39:26,480
so we can be lazy we don't have to

1078
00:39:26,480 --> 00:39:27,280
manually

1079
00:39:27,280 --> 00:39:31,119
imports or manually um well specify

1080
00:39:31,119 --> 00:39:32,960
those function signatures anymore

1081
00:39:32,960 --> 00:39:34,320
because they're already baked

1082
00:39:34,320 --> 00:39:37,359
into the uh d invoke framework so that

1083
00:39:37,359 --> 00:39:38,160
makes it

1084
00:39:38,160 --> 00:39:40,079
something that we can leverage as we're

1085
00:39:40,079 --> 00:39:42,079
if you're pretty lazy and let's be

1086
00:39:42,079 --> 00:39:43,040
honest

1087
00:39:43,040 --> 00:39:45,839
we are all a bit lazy i think um at

1088
00:39:45,839 --> 00:39:46,240
least

1089
00:39:46,240 --> 00:39:49,119
if i can make my life easier by using a

1090
00:39:49,119 --> 00:39:51,119
library or using a framework i

1091
00:39:51,119 --> 00:39:53,599
sure as hell would do so uh it's not

1092
00:39:53,599 --> 00:39:54,160
really

1093
00:39:54,160 --> 00:39:57,599
that feasible or that um well

1094
00:39:57,599 --> 00:40:01,040
that expected to actually reinvent the

1095
00:40:01,040 --> 00:40:01,839
wheel

1096
00:40:01,839 --> 00:40:04,319
so that's why i tend to use libraries

1097
00:40:04,319 --> 00:40:07,920
and frameworks as much as i can

1098
00:40:08,000 --> 00:40:10,400
so let's talk about or let's give a d

1099
00:40:10,400 --> 00:40:12,400
invoke primer for just a second

1100
00:40:12,400 --> 00:40:15,520
so it has a nougat package uh which is a

1101
00:40:15,520 --> 00:40:16,000
bit of

1102
00:40:16,000 --> 00:40:18,480
the package manager for uh for net

1103
00:40:18,480 --> 00:40:19,359
basically

1104
00:40:19,359 --> 00:40:21,839
but the nugget package unfortunately

1105
00:40:21,839 --> 00:40:24,079
gets flagged by defender nowadays

1106
00:40:24,079 --> 00:40:26,240
but you can just import the source code

1107
00:40:26,240 --> 00:40:28,319
which is downloadable on github anyway

1108
00:40:28,319 --> 00:40:29,520
and you can just manually

1109
00:40:29,520 --> 00:40:31,760
import that into your project and that

1110
00:40:31,760 --> 00:40:33,680
is not flagged by defender yet

1111
00:40:33,680 --> 00:40:36,480
it has built-in injection apis for

1112
00:40:36,480 --> 00:40:38,319
process injection so you don't even have

1113
00:40:38,319 --> 00:40:39,440
to

1114
00:40:39,440 --> 00:40:41,599
uh well have to try hard with your

1115
00:40:41,599 --> 00:40:43,040
rejection anymore either

1116
00:40:43,040 --> 00:40:45,839
it has a just a very simple dnf dot

1117
00:40:45,839 --> 00:40:46,880
inject

1118
00:40:46,880 --> 00:40:49,200
api call to actually do the process

1119
00:40:49,200 --> 00:40:51,040
injection for you

1120
00:40:51,040 --> 00:40:53,760
it is capable of resolving api calls in

1121
00:40:53,760 --> 00:40:55,359
three ways so you have the

1122
00:40:55,359 --> 00:40:57,200
standard way of doing things much like b

1123
00:40:57,200 --> 00:40:58,960
invoke would you have your

1124
00:40:58,960 --> 00:41:01,680
manual mapping which is well mapping a

1125
00:41:01,680 --> 00:41:02,319
module

1126
00:41:02,319 --> 00:41:04,240
manually into the dll i'm going to talk

1127
00:41:04,240 --> 00:41:05,680
about that in just a minute

1128
00:41:05,680 --> 00:41:07,760
i have overload mapping and the overload

1129
00:41:07,760 --> 00:41:09,920
mapping is a bit of the deception

1130
00:41:09,920 --> 00:41:11,839
kind of thing which is a bit out of

1131
00:41:11,839 --> 00:41:13,119
scope of this stock

1132
00:41:13,119 --> 00:41:16,400
so that's quite nice

1133
00:41:17,680 --> 00:41:19,839
so let us talk about manual mapping

1134
00:41:19,839 --> 00:41:21,359
because i actually addressed it a few

1135
00:41:21,359 --> 00:41:23,359
times already during this talk

1136
00:41:23,359 --> 00:41:26,000
so what is manual mapping well let's

1137
00:41:26,000 --> 00:41:27,680
first take a look at

1138
00:41:27,680 --> 00:41:30,800
regular how regular processes behave

1139
00:41:30,800 --> 00:41:33,119
so every process has a virtual address

1140
00:41:33,119 --> 00:41:35,040
space in its virtual address space there

1141
00:41:35,040 --> 00:41:35,520
are

1142
00:41:35,520 --> 00:41:39,119
multiple dlls present imagine

1143
00:41:39,119 --> 00:41:41,760
you are malware you want to interact

1144
00:41:41,760 --> 00:41:43,359
with a specific process

1145
00:41:43,359 --> 00:41:46,880
that specific process says kernel 32.dll

1146
00:41:46,880 --> 00:41:49,040
in its virtual address space well you

1147
00:41:49,040 --> 00:41:51,119
could just call the kernel 32

1148
00:41:51,119 --> 00:41:54,640
dll functions of that virtual address

1149
00:41:54,640 --> 00:41:55,599
space

1150
00:41:55,599 --> 00:41:58,640
and well use that

1151
00:41:58,640 --> 00:42:00,240
but the thing there is the drawback

1152
00:42:00,240 --> 00:42:02,319
there is that your edr

1153
00:42:02,319 --> 00:42:04,960
will also have hooks there in this case

1154
00:42:04,960 --> 00:42:07,040
in this slide i'm actually using ntdl as

1155
00:42:07,040 --> 00:42:08,000
an example

1156
00:42:08,000 --> 00:42:10,720
so for example malware is trying to

1157
00:42:10,720 --> 00:42:12,640
allocate memory using anti-allocated

1158
00:42:12,640 --> 00:42:14,160
virtual memory x

1159
00:42:14,160 --> 00:42:16,800
well guess what the edr actually has

1160
00:42:16,800 --> 00:42:17,200
that

1161
00:42:17,200 --> 00:42:19,280
function hooked so that means that

1162
00:42:19,280 --> 00:42:21,040
you'll get spotted when you try to

1163
00:42:21,040 --> 00:42:23,920
use that call um so that's not really

1164
00:42:23,920 --> 00:42:25,680
what you want from an offensive point of

1165
00:42:25,680 --> 00:42:26,560
view

1166
00:42:26,560 --> 00:42:28,640
luckily the rover actually thought about

1167
00:42:28,640 --> 00:42:30,000
that and actually created

1168
00:42:30,000 --> 00:42:32,400
the manual mapping behavior so what that

1169
00:42:32,400 --> 00:42:33,680
basically does

1170
00:42:33,680 --> 00:42:37,359
is while edr vendors tend to do their

1171
00:42:37,359 --> 00:42:37,839
process

1172
00:42:37,839 --> 00:42:40,800
injection so their dll at runtime so

1173
00:42:40,800 --> 00:42:41,760
that basically means

1174
00:42:41,760 --> 00:42:44,400
when your process spawns it will inject

1175
00:42:44,400 --> 00:42:45,839
the dll

1176
00:42:45,839 --> 00:42:49,680
into it and place hooks into the address

1177
00:42:49,680 --> 00:42:51,440
space that is already there

1178
00:42:51,440 --> 00:42:55,040
now manual mapping actually maps

1179
00:42:55,040 --> 00:42:58,720
the uh well the dll that you want to use

1180
00:42:58,720 --> 00:43:01,040
in memory after the process is launched

1181
00:43:01,040 --> 00:43:03,040
which means that it is a completely

1182
00:43:03,040 --> 00:43:03,839
clean

1183
00:43:03,839 --> 00:43:06,960
copy of a dll and is not having those

1184
00:43:06,960 --> 00:43:08,000
edr's

1185
00:43:08,000 --> 00:43:11,280
edr hooks in place so that's pretty cool

1186
00:43:11,280 --> 00:43:14,319
because now your edr is hooking uh

1187
00:43:14,319 --> 00:43:17,200
nt dll.dll which is present at a

1188
00:43:17,200 --> 00:43:18,960
specific memory location in the virtual

1189
00:43:18,960 --> 00:43:20,400
address space

1190
00:43:20,400 --> 00:43:23,400
um but you actually mapped a copy of

1191
00:43:23,400 --> 00:43:24,880
ntdll.dll on

1192
00:43:24,880 --> 00:43:27,920
other virtual address space location

1193
00:43:27,920 --> 00:43:29,359
in the same virtual address space of

1194
00:43:29,359 --> 00:43:30,960
course and you can actually

1195
00:43:30,960 --> 00:43:34,400
leverage that dll instead which is

1196
00:43:34,400 --> 00:43:37,359
completely free of hooks so that's

1197
00:43:37,359 --> 00:43:39,520
pretty nice as well

1198
00:43:39,520 --> 00:43:42,640
so i actually created uh well an edr

1199
00:43:42,640 --> 00:43:43,359
goes br

1200
00:43:43,359 --> 00:43:46,560
which is basically my demo basic loader

1201
00:43:46,560 --> 00:43:48,240
on steroids because now i'm using the

1202
00:43:48,240 --> 00:43:50,800
invoke instead i have

1203
00:43:50,800 --> 00:43:53,119
syscall methods and manual map methods

1204
00:43:53,119 --> 00:43:54,880
as demo

1205
00:43:54,880 --> 00:43:56,560
and for this example i'm actually

1206
00:43:56,560 --> 00:43:59,040
showing you the manual map method

1207
00:43:59,040 --> 00:44:01,440
as you can see here i'm using a parent

1208
00:44:01,440 --> 00:44:02,880
process explorer

1209
00:44:02,880 --> 00:44:05,280
i'm using a notepad as a surrogate and

1210
00:44:05,280 --> 00:44:06,800
i'm actually mentioning that i want to

1211
00:44:06,800 --> 00:44:08,079
use manual mapping

1212
00:44:08,079 --> 00:44:09,680
you can see that i'm actually spawning

1213
00:44:09,680 --> 00:44:11,839
notepad with parent process explorer

1214
00:44:11,839 --> 00:44:15,119
process id is 6608 and if i would check

1215
00:44:15,119 --> 00:44:16,880
the memory under the address you'll

1216
00:44:16,880 --> 00:44:18,560
actually find the manually mapped into

1217
00:44:18,560 --> 00:44:19,760
dll dll

1218
00:44:19,760 --> 00:44:22,240
so if i would compare these memory

1219
00:44:22,240 --> 00:44:24,079
locations you can see that there's are

1220
00:44:24,079 --> 00:44:25,440
definitely not the same

1221
00:44:25,440 --> 00:44:28,480
the first one starts with 0x2d this will

1222
00:44:28,480 --> 00:44:30,319
start with 0x7f

1223
00:44:30,319 --> 00:44:32,880
so they're living in completely separate

1224
00:44:32,880 --> 00:44:34,560
locations within the same virtual

1225
00:44:34,560 --> 00:44:35,359
address space

1226
00:44:35,359 --> 00:44:37,119
but if you would compare the hex dump of

1227
00:44:37,119 --> 00:44:39,119
these two memory locations

1228
00:44:39,119 --> 00:44:40,720
you'll see that it maps one to one

1229
00:44:40,720 --> 00:44:42,240
because it's an exact copy

1230
00:44:42,240 --> 00:44:44,800
however one is actually hooked by the

1231
00:44:44,800 --> 00:44:45,359
edr

1232
00:44:45,359 --> 00:44:47,200
and the other one is not so if i would

1233
00:44:47,200 --> 00:44:48,560
use functions

1234
00:44:48,560 --> 00:44:52,000
from the unhooked or the clean

1235
00:44:52,000 --> 00:44:54,960
edr the clean dll module that basically

1236
00:44:54,960 --> 00:44:56,319
means that i can now

1237
00:44:56,319 --> 00:44:58,000
leverage my malicious code anyway

1238
00:44:58,000 --> 00:45:02,400
without triggering alerts from the edr

1239
00:45:02,839 --> 00:45:05,440
software so

1240
00:45:05,440 --> 00:45:07,280
if you would if you would want to do

1241
00:45:07,280 --> 00:45:08,640
that manually

1242
00:45:08,640 --> 00:45:11,359
it would take you quite a bit of time

1243
00:45:11,359 --> 00:45:13,520
why because you would have to

1244
00:45:13,520 --> 00:45:14,880
well first of all you would have to

1245
00:45:14,880 --> 00:45:16,640
manually map the

1246
00:45:16,640 --> 00:45:19,440
the process so the entity alone in this

1247
00:45:19,440 --> 00:45:20,079
case

1248
00:45:20,079 --> 00:45:22,079
into your virtual address space but you

1249
00:45:22,079 --> 00:45:24,000
will also have to take into account all

1250
00:45:24,000 --> 00:45:25,520
the relocations that you will have to do

1251
00:45:25,520 --> 00:45:26,800
on relative offsets

1252
00:45:26,800 --> 00:45:29,359
in order to call the correct exported

1253
00:45:29,359 --> 00:45:29,920
function

1254
00:45:29,920 --> 00:45:31,680
because now it doesn't live anymore in

1255
00:45:31,680 --> 00:45:33,119
ntdl

1256
00:45:33,119 --> 00:45:35,760
in the right virtual memory for example

1257
00:45:35,760 --> 00:45:36,319
because

1258
00:45:36,319 --> 00:45:38,319
you actually manually mapped it into

1259
00:45:38,319 --> 00:45:40,480
another separate memory address

1260
00:45:40,480 --> 00:45:43,119
so you'd have to manually calculate all

1261
00:45:43,119 --> 00:45:44,480
that stuff

1262
00:45:44,480 --> 00:45:47,040
and luckily for us the invoke does that

1263
00:45:47,040 --> 00:45:48,079
magic for us

1264
00:45:48,079 --> 00:45:50,480
so that's once again a very very nice

1265
00:45:50,480 --> 00:45:52,319
reason why you would want to use

1266
00:45:52,319 --> 00:45:55,440
uh d invoke for manual mapping for

1267
00:45:55,440 --> 00:45:56,079
example

1268
00:45:56,079 --> 00:45:58,640
because it's just a few api calls and it

1269
00:45:58,640 --> 00:46:00,319
does it for you automatically which is

1270
00:46:00,319 --> 00:46:02,560
very very nice it saves you a lot a lot

1271
00:46:02,560 --> 00:46:04,880
of time

1272
00:46:04,880 --> 00:46:06,640
if you can see it here you'll actually

1273
00:46:06,640 --> 00:46:09,520
see that edr goes

1274
00:46:09,520 --> 00:46:12,319
while sudden strike is actually injected

1275
00:46:12,319 --> 00:46:13,440
into the process

1276
00:46:13,440 --> 00:46:15,359
but it doesn't really matter because i'm

1277
00:46:15,359 --> 00:46:17,200
actually using

1278
00:46:17,200 --> 00:46:19,920
a fresh copy of ntd level dealer which

1279
00:46:19,920 --> 00:46:20,800
is not hooked

1280
00:46:20,800 --> 00:46:23,200
by silent strike which means that my evo

1281
00:46:23,200 --> 00:46:24,079
payload

1282
00:46:24,079 --> 00:46:27,520
will run regardless

1283
00:46:27,680 --> 00:46:30,720
so i hope that makes sense for everyone

1284
00:46:30,720 --> 00:46:33,040
so i'm going to give a quick demo once

1285
00:46:33,040 --> 00:46:34,960
again on how you can do this

1286
00:46:34,960 --> 00:46:37,359
with the manual map functionality as i

1287
00:46:37,359 --> 00:46:40,000
already mentioned

1288
00:46:40,400 --> 00:46:42,480
so first of all i'm gonna need once

1289
00:46:42,480 --> 00:46:45,280
again an administrative window

1290
00:46:45,280 --> 00:46:48,400
to inject my silent strike dll into my d

1291
00:46:48,400 --> 00:46:51,119
invoke loader this time

1292
00:46:51,119 --> 00:46:53,500
so what i'm gonna do now is set up the

1293
00:46:53,500 --> 00:46:54,839
[Music]

1294
00:46:54,839 --> 00:46:57,599
listener

1295
00:46:57,599 --> 00:47:00,880
oh that's a mistake needs to

1296
00:47:00,880 --> 00:47:03,040
be

1297
00:47:05,359 --> 00:47:09,200
all right and now if i

1298
00:47:09,200 --> 00:47:12,400
use that edr goes br method

1299
00:47:12,400 --> 00:47:14,800
parent is explorer surrogate this

1300
00:47:14,800 --> 00:47:18,319
notepad using manual map

1301
00:47:18,560 --> 00:47:21,599
you'll see that indeed notepad pops up

1302
00:47:21,599 --> 00:47:24,160
you'll see that it's indeed injected if

1303
00:47:24,160 --> 00:47:25,359
i would

1304
00:47:25,359 --> 00:47:31,359
check it out one five two zero four

1305
00:47:31,760 --> 00:47:34,720
the modules science strike is indeed

1306
00:47:34,720 --> 00:47:36,720
there

1307
00:47:36,720 --> 00:47:40,079
however if i hit my keys you'll see that

1308
00:47:40,079 --> 00:47:42,960
hey my evil palette works you also see

1309
00:47:42,960 --> 00:47:45,040
that

1310
00:47:45,040 --> 00:47:48,480
uh you also see that um process hacker

1311
00:47:48,480 --> 00:47:52,079
can't really deal with the uh

1312
00:47:52,079 --> 00:47:54,160
the uh protection the mitigation

1313
00:47:54,160 --> 00:47:55,280
protection that i have

1314
00:47:55,280 --> 00:47:58,559
on this murder it's quite nice so as you

1315
00:47:58,559 --> 00:47:58,960
saw

1316
00:47:58,960 --> 00:48:01,599
the uh the evil payload definitely still

1317
00:48:01,599 --> 00:48:02,800
triggers even though

1318
00:48:02,800 --> 00:48:05,760
the edr is actually looking for it so

1319
00:48:05,760 --> 00:48:07,839
that's the manual map method

1320
00:48:07,839 --> 00:48:09,200
it's basically the same thing with

1321
00:48:09,200 --> 00:48:12,720
syscalls to be honest

1322
00:48:12,720 --> 00:48:14,400
so what's this calls you're just going

1323
00:48:14,400 --> 00:48:16,400
to use the get syscall stop in order to

1324
00:48:16,400 --> 00:48:18,319
generate this is called dynamically

1325
00:48:18,319 --> 00:48:19,520
so it doesn't really matter which

1326
00:48:19,520 --> 00:48:21,359
operating system version you're on it

1327
00:48:21,359 --> 00:48:21,920
will

1328
00:48:21,920 --> 00:48:25,040
automatically give you the correct uh

1329
00:48:25,040 --> 00:48:27,599
correct version uh it resolves the

1330
00:48:27,599 --> 00:48:30,240
correct syscall number for you

1331
00:48:30,240 --> 00:48:32,640
and using that you'll have exactly the

1332
00:48:32,640 --> 00:48:34,000
same experience

1333
00:48:34,000 --> 00:48:35,839
so instead of using a manual map you'll

1334
00:48:35,839 --> 00:48:37,440
use cisco's instead

1335
00:48:37,440 --> 00:48:39,760
and we'll defeat the edr once again so

1336
00:48:39,760 --> 00:48:41,920
if i would demo that

1337
00:48:41,920 --> 00:48:46,000
it's going to be exactly the same

1338
00:48:46,839 --> 00:48:51,839
so let's use the cisco method

1339
00:48:51,839 --> 00:48:55,440
so once again this got opened

1340
00:48:55,440 --> 00:48:59,200
as you can see it actually injects into

1341
00:48:59,200 --> 00:49:00,240
that once again

1342
00:49:00,240 --> 00:49:03,839
so 22

1343
00:49:05,359 --> 00:49:08,319
silent strike is definitely there if i

1344
00:49:08,319 --> 00:49:10,400
hit my keys

1345
00:49:10,400 --> 00:49:12,240
it doesn't really matter you'll bail out

1346
00:49:12,240 --> 00:49:14,559
it works there you go

1347
00:49:14,559 --> 00:49:18,160
no problem at all so i hope

1348
00:49:18,160 --> 00:49:21,760
you can see the power behind the invoke

1349
00:49:21,760 --> 00:49:24,559
uh i hope you will use it in your

1350
00:49:24,559 --> 00:49:27,280
c-sharp offensive tooling from now on

1351
00:49:27,280 --> 00:49:29,119
and as a closing note i want to say that

1352
00:49:29,119 --> 00:49:31,200
the invoke needs your help

1353
00:49:31,200 --> 00:49:33,520
it's an open source project created by

1354
00:49:33,520 --> 00:49:35,119
the wover as i already mentioned several

1355
00:49:35,119 --> 00:49:35,920
times

1356
00:49:35,920 --> 00:49:38,880
i try to uh to submit pull requests

1357
00:49:38,880 --> 00:49:40,720
every once in a while as well because i

1358
00:49:40,720 --> 00:49:44,240
use the invoke very very often so the

1359
00:49:44,240 --> 00:49:46,960
the goal the dream is to have the entire

1360
00:49:46,960 --> 00:49:48,800
win32 api

1361
00:49:48,800 --> 00:49:51,680
eventually ported to the invoke but as

1362
00:49:51,680 --> 00:49:52,720
you can imagine

1363
00:49:52,720 --> 00:49:55,839
win32 api is quite big and so there's

1364
00:49:55,839 --> 00:49:57,520
definitely still a lot of work to be

1365
00:49:57,520 --> 00:49:58,240
done

1366
00:49:58,240 --> 00:50:00,960
in order to fully port over the api but

1367
00:50:00,960 --> 00:50:03,200
once that's done then it's a just a

1368
00:50:03,200 --> 00:50:05,280
dream came true basically because then

1369
00:50:05,280 --> 00:50:07,359
you can just uh

1370
00:50:07,359 --> 00:50:09,200
code very very rapidly and you don't

1371
00:50:09,200 --> 00:50:10,559
have to worry about

1372
00:50:10,559 --> 00:50:13,520
well manually creating those function

1373
00:50:13,520 --> 00:50:14,880
signatures anymore

1374
00:50:14,880 --> 00:50:17,040
so it's really really cool if we could

1375
00:50:17,040 --> 00:50:18,640
actually get that to work

1376
00:50:18,640 --> 00:50:20,800
so that's why uh this is a call for help

1377
00:50:20,800 --> 00:50:21,920
if you have some time

1378
00:50:21,920 --> 00:50:24,480
if you want to code just sporting over

1379
00:50:24,480 --> 00:50:25,760
some

1380
00:50:25,760 --> 00:50:27,839
some of the uh the c plus plus

1381
00:50:27,839 --> 00:50:29,520
functionality into delegates

1382
00:50:29,520 --> 00:50:32,160
and submitting a pull request very very

1383
00:50:32,160 --> 00:50:35,200
helpful thank you very much

1384
00:50:35,200 --> 00:50:37,040
if there are any questions i'll be

1385
00:50:37,040 --> 00:50:39,200
hanging around

1386
00:50:39,200 --> 00:50:40,960
yeah to answer them basically thank you

1387
00:50:40,960 --> 00:50:42,240
very much for your time

1388
00:50:42,240 --> 00:50:45,680
take care bye

