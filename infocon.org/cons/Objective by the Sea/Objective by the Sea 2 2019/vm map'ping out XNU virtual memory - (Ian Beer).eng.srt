1
00:00:03,950 --> 00:00:06,569
welcome to my talk called here mapping

2
00:00:06,569 --> 00:00:11,099
out there's a new virtual memory so

3
00:00:11,099 --> 00:00:13,560
compared to some other taunts today this

4
00:00:13,560 --> 00:00:15,210
is going to be more like an operating

5
00:00:15,210 --> 00:00:17,369
system internals with a bit of fun today

6
00:00:17,369 --> 00:00:19,590
a few research and maybe some

7
00:00:19,590 --> 00:00:22,829
exploitation at the end it says time but

8
00:00:22,829 --> 00:00:24,900
most of the focus of this talk is going

9
00:00:24,900 --> 00:00:27,119
to be as if a virtual memory internals

10
00:00:27,119 --> 00:00:29,999
and xnu so hopefully if there's like me

11
00:00:29,999 --> 00:00:31,650
from like a forensics background either

12
00:00:31,650 --> 00:00:35,100
this is all very much old news or wait

13
00:00:35,100 --> 00:00:37,470
the interesting there's certainly a lot

14
00:00:37,470 --> 00:00:39,000
of interesting vulnerability research

15
00:00:39,000 --> 00:00:40,530
that can be done in this area and also

16
00:00:40,530 --> 00:00:43,680
just the sort of high-level terrifying

17
00:00:43,680 --> 00:00:48,960
view of the legacy craft that we are

18
00:00:48,960 --> 00:00:53,580
underneath all of my shiny phone so you

19
00:00:53,580 --> 00:00:55,230
can't have any X in you talk without

20
00:00:55,230 --> 00:00:58,650
bigotry slide what is xn you you have on

21
00:00:58,650 --> 00:01:03,780
the left hand side here marks and on the

22
00:01:03,780 --> 00:01:04,319
right hand side

23
00:01:04,319 --> 00:01:06,840
BSD why do these exist next to each

24
00:01:06,840 --> 00:01:09,060
other well they wanted to have it's very

25
00:01:09,060 --> 00:01:12,510
nice old microkernel but this

26
00:01:12,510 --> 00:01:15,390
microkernel can't do things like I can

27
00:01:15,390 --> 00:01:18,780
fire or have a network sack ma just

28
00:01:18,780 --> 00:01:19,860
doesn't have those things

29
00:01:19,860 --> 00:01:24,090
so what Darwin did was take BSD on one

30
00:01:24,090 --> 00:01:26,820
side and not on the other side and sort

31
00:01:26,820 --> 00:01:29,640
of glue them together so actually this

32
00:01:29,640 --> 00:01:32,040
is structure talks which is the

33
00:01:32,040 --> 00:01:35,760
abstraction boy talks for precepts any

34
00:01:35,760 --> 00:01:38,400
module got bullet passed down in the PSD

35
00:01:38,400 --> 00:01:40,590
world it's called a process and

36
00:01:40,590 --> 00:01:42,900
literally they just point to each other

37
00:01:42,900 --> 00:01:46,049
so a mark class has this VSD pig poo

38
00:01:46,049 --> 00:01:48,450
it's a just avoid saga is much doesn't

39
00:01:48,450 --> 00:01:50,250
know anything about nathie and that

40
00:01:50,250 --> 00:01:52,320
points to the striped

41
00:01:52,320 --> 00:01:56,369
croc in the PSP you are vice versa the

42
00:01:56,369 --> 00:01:58,979
PSD bootstrap tasks the start frat

43
00:01:58,979 --> 00:02:02,220
brother as a tar field which points to

44
00:02:02,220 --> 00:02:05,460
the map well this is all irrelevant for

45
00:02:05,460 --> 00:02:07,799
what we ended up rather so they both

46
00:02:07,799 --> 00:02:10,408
have to eat they both have separate

47
00:02:10,408 --> 00:02:12,180
responsibilities in terms of the area of

48
00:02:12,180 --> 00:02:13,990
the system that they manage

49
00:02:13,990 --> 00:02:16,360
so on a much side we had Venus's talked

50
00:02:16,360 --> 00:02:18,550
earlier about the ports and about how

51
00:02:18,550 --> 00:02:20,890
much what names can be difficult to use

52
00:02:20,890 --> 00:02:24,400
and that all lives under this itk states

53
00:02:24,400 --> 00:02:29,470
which is the task per person per cart

54
00:02:29,470 --> 00:02:34,120
way of imagining port names to rights so

55
00:02:34,120 --> 00:02:36,640
it's what goes means is 41 for to do or

56
00:02:36,640 --> 00:02:39,960
whatever important name to struct a

57
00:02:39,960 --> 00:02:44,170
decent port and then here similar

58
00:02:44,170 --> 00:02:46,420
attraction in the ESD world for

59
00:02:46,420 --> 00:02:47,890
thousands ripping others weren't seeing

60
00:02:47,890 --> 00:02:49,840
a transcription numbers which Derek long

61
00:02:49,840 --> 00:02:51,940
a number which is it's an index in your

62
00:02:51,940 --> 00:02:55,330
process table do a file cool subject

63
00:02:55,330 --> 00:02:57,070
which is similar this is a client

64
00:02:57,070 --> 00:03:00,730
attraction level to I can support but

65
00:03:00,730 --> 00:03:03,130
once after you know mark that there's a

66
00:03:03,130 --> 00:03:06,670
threads ESD versus groups and

67
00:03:06,670 --> 00:03:09,040
credentials are ladies want to start and

68
00:03:09,040 --> 00:03:14,640
ma is responsible for me and Matt say

69
00:03:14,640 --> 00:03:17,740
alright Mike Ovitz the virtual memory

70
00:03:17,740 --> 00:03:20,140
manager is done on the much sighs it's

71
00:03:20,140 --> 00:03:24,700
not be exceeds memory interface memory

72
00:03:24,700 --> 00:03:26,920
impaired although you can use the BSD

73
00:03:26,920 --> 00:03:29,460
memory user space memory management

74
00:03:29,460 --> 00:03:33,520
interface to to manage users that use of

75
00:03:33,520 --> 00:03:35,830
memory and its really all implemented on

76
00:03:35,830 --> 00:03:37,630
the market side and if you look at the

77
00:03:37,630 --> 00:03:41,950
bsd Siskel's that you would use to

78
00:03:41,950 --> 00:03:45,970
allocate memory we will just end up

79
00:03:45,970 --> 00:03:49,900
there just quite sure subs which call

80
00:03:49,900 --> 00:03:55,390
over into the ma side of the code

81
00:03:55,390 --> 00:03:59,770
and what's the fundamental thing that

82
00:03:59,770 --> 00:04:02,580
i'm going to talk about message passing

83
00:04:02,580 --> 00:04:04,870
this is this fundamental

84
00:04:04,870 --> 00:04:07,990
microkernel idea and it's important to

85
00:04:07,990 --> 00:04:10,180
point out i OS news

86
00:04:10,180 --> 00:04:12,400
likewise this is not a microkernel in

87
00:04:12,400 --> 00:04:14,890
any way but nevertheless it has the

88
00:04:14,890 --> 00:04:15,870
legacy

89
00:04:15,870 --> 00:04:19,000
background of some of it used to be a

90
00:04:19,000 --> 00:04:19,720
microkernel

91
00:04:19,720 --> 00:04:22,029
so it's drank all this stuff with it

92
00:04:22,029 --> 00:04:24,190
even though whether they actually gained

93
00:04:24,190 --> 00:04:26,340
much benefit from it now

94
00:04:26,340 --> 00:04:28,889
I'm deal with message passing is that

95
00:04:28,889 --> 00:04:30,780
you split out all your functionality and

96
00:04:30,780 --> 00:04:33,479
a different user space processes was the

97
00:04:33,479 --> 00:04:35,669
idea bone and these are all have just

98
00:04:35,669 --> 00:04:37,199
mineral level of courage that they

99
00:04:37,199 --> 00:04:39,410
require and they will talk to each other

100
00:04:39,410 --> 00:04:42,720
by sending you know little over works

101
00:04:42,720 --> 00:04:47,400
with messages lemon and the idea well it

102
00:04:47,400 --> 00:04:49,350
was thought it's probably true that the

103
00:04:49,350 --> 00:04:51,150
media sort of reason that no one ever

104
00:04:51,150 --> 00:04:53,430
took these microkernel architectures

105
00:04:53,430 --> 00:04:56,669
that fire that's there are systems that

106
00:04:56,669 --> 00:05:00,930
do use them but your iPhone it's not a

107
00:05:00,930 --> 00:05:04,650
real micro camera and this is not really

108
00:05:04,650 --> 00:05:06,300
a major performance bottleneck the fact

109
00:05:06,300 --> 00:05:07,979
that you have to copy memories all the

110
00:05:07,979 --> 00:05:11,520
time to make anything happen and so this

111
00:05:11,520 --> 00:05:15,449
talk is about how much use uses virtual

112
00:05:15,449 --> 00:05:18,180
memory tricks to make being able to pass

113
00:05:18,180 --> 00:05:21,810
these mock messages fast and how

114
00:05:21,810 --> 00:05:24,330
actually how it works and it was quite

115
00:05:24,330 --> 00:05:27,770
very cool so we must already mentioned

116
00:05:27,770 --> 00:05:30,330
mock messages I think everyone in the

117
00:05:30,330 --> 00:05:31,889
audience is 43 familiar for enough

118
00:05:31,889 --> 00:05:34,260
messages so we're gonna go very quickly

119
00:05:34,260 --> 00:05:38,630
look at this the fundamental unit of

120
00:05:38,630 --> 00:05:42,930
message in userspace at least is this 24

121
00:05:42,930 --> 00:05:45,900
by structure this is the smallest

122
00:05:45,900 --> 00:05:47,849
possible mock message you can find and

123
00:05:47,849 --> 00:05:50,430
you don't think that we am interested in

124
00:05:50,430 --> 00:05:54,180
here is this single there this is

125
00:05:54,180 --> 00:05:56,340
the complex bit the most significant bit

126
00:05:56,340 --> 00:05:58,770
occurs the b-word and this is gonna tell

127
00:05:58,770 --> 00:06:01,470
us is this message complex so there's

128
00:06:01,470 --> 00:06:05,010
one or simple it's not one if it's

129
00:06:05,010 --> 00:06:08,699
complex then following this heavy

130
00:06:08,699 --> 00:06:10,560
structure in memory because panel is

131
00:06:10,560 --> 00:06:13,190
going to look for another D word called

132
00:06:13,190 --> 00:06:16,380
confusingly body so this is not the body

133
00:06:16,380 --> 00:06:18,270
of the message this is actually a count

134
00:06:18,270 --> 00:06:22,800
of how many structures similar this will

135
00:06:22,800 --> 00:06:25,830
follow before you get to the body so I

136
00:06:25,830 --> 00:06:29,030
guess it's called body for some reason

137
00:06:29,030 --> 00:06:32,639
and then after these these structures

138
00:06:32,639 --> 00:06:37,460
from the actual in line message body

139
00:06:37,700 --> 00:06:40,530
we'll come back to what mark message

140
00:06:40,530 --> 00:06:42,410
house applying descriptor actually is

141
00:06:42,410 --> 00:06:45,270
well we really need to know that in this

142
00:06:45,270 --> 00:06:47,850
message we tell it how big your messages

143
00:06:47,850 --> 00:06:50,790
that's how big the this action entire

144
00:06:50,790 --> 00:06:52,410
butter is you want to talk me into the

145
00:06:52,410 --> 00:06:54,510
camera and then the car like a copy to

146
00:06:54,510 --> 00:06:57,270
the recipient you said where you want to

147
00:06:57,270 --> 00:06:59,700
send the message to in terms of this is

148
00:06:59,700 --> 00:07:01,560
a mock name that you have some kind of

149
00:07:01,560 --> 00:07:03,960
right over and then people take other

150
00:07:03,960 --> 00:07:06,330
ports in there and by convention you can

151
00:07:06,330 --> 00:07:09,660
use the local port to transfer a receive

152
00:07:09,660 --> 00:07:13,110
a very send able writes the morning to a

153
00:07:13,110 --> 00:07:15,750
reply port and there's also about report

154
00:07:15,750 --> 00:07:18,450
which the last time I gave a talk this

155
00:07:18,450 --> 00:07:21,480
was this was undefined what was in there

156
00:07:21,480 --> 00:07:25,410
and a few Mac OS releases ago they about

157
00:07:25,410 --> 00:07:29,850
report in this field so important thing

158
00:07:29,850 --> 00:07:31,860
here is when you send a message this

159
00:07:31,860 --> 00:07:35,190
entire structure and this inline message

160
00:07:35,190 --> 00:07:35,520
body

161
00:07:35,520 --> 00:07:37,500
you basically hundreds of megabytes

162
00:07:37,500 --> 00:07:40,950
that's very unlikely the fine example

163
00:07:40,950 --> 00:07:41,970
there could be hundreds of megabytes but

164
00:07:41,970 --> 00:07:45,140
the system completely supports our and

165
00:07:45,140 --> 00:07:47,190
every time you want to send one of these

166
00:07:47,190 --> 00:07:49,530
messages only to want to use a space

167
00:07:49,530 --> 00:07:53,190
process or cubic are not there's a lot

168
00:07:53,190 --> 00:07:55,020
of memory company that goes on so there

169
00:07:55,020 --> 00:07:57,330
will be a kernel heap allocation made

170
00:07:57,330 --> 00:07:59,490
that's the same size but slightly larger

171
00:07:59,490 --> 00:08:01,260
than this message back that the message

172
00:08:01,260 --> 00:08:03,240
buffer will be copied in from user space

173
00:08:03,240 --> 00:08:06,660
to the kernel processed and then copied

174
00:08:06,660 --> 00:08:12,360
out into user space or recipient and so

175
00:08:12,360 --> 00:08:14,130
yeah there's a lot a lot of memory

176
00:08:14,130 --> 00:08:18,120
copying going on here and back in the

177
00:08:18,120 --> 00:08:19,919
early 80s when this is being written

178
00:08:19,919 --> 00:08:22,440
um memory copying was even slower than

179
00:08:22,440 --> 00:08:26,220
it is now only very slow and so if you

180
00:08:26,220 --> 00:08:28,080
want to make your thing fast you want to

181
00:08:28,080 --> 00:08:30,900
avoid copying these large amount of data

182
00:08:30,900 --> 00:08:33,900
and so how do you avoid copying large

183
00:08:33,900 --> 00:08:36,900
amounts of data you can use virtual

184
00:08:36,900 --> 00:08:39,780
memory magic so to look at this message

185
00:08:39,780 --> 00:08:42,150
here rather than having an enormous

186
00:08:42,150 --> 00:08:44,850
inline message body what you can instead

187
00:08:44,850 --> 00:08:47,850
do is tell the system actually is just

188
00:08:47,850 --> 00:08:49,420
my

189
00:08:49,420 --> 00:08:51,670
virtual memory address of the region of

190
00:08:51,670 --> 00:08:54,010
memory I want to send here's how big it

191
00:08:54,010 --> 00:08:56,800
is here's some flags don't make this

192
00:08:56,800 --> 00:09:02,080
happen for free and specifically what

193
00:09:02,080 --> 00:09:04,840
you want to do is if you set these are

194
00:09:04,840 --> 00:09:07,930
flags here if you set the copy flag to

195
00:09:07,930 --> 00:09:08,680
zero

196
00:09:08,680 --> 00:09:11,590
are you saying I don't want you to make

197
00:09:11,590 --> 00:09:13,690
a copy of this memory for the recipient

198
00:09:13,690 --> 00:09:15,550
in fact what I also want you to do is

199
00:09:15,550 --> 00:09:18,220
not make a copy and deallocate it from

200
00:09:18,220 --> 00:09:20,980
my address space and make sure that the

201
00:09:20,980 --> 00:09:23,770
FGX is page aligned then size and page

202
00:09:23,770 --> 00:09:26,560
align then what the map from the M

203
00:09:26,560 --> 00:09:28,690
subsystem is able to do is actually take

204
00:09:28,690 --> 00:09:31,150
that entire virtual memory region pull

205
00:09:31,150 --> 00:09:34,060
it out of your process and push it

206
00:09:34,060 --> 00:09:36,580
directly into the recipient completely

207
00:09:36,580 --> 00:09:38,380
avoiding you need to actually copy the

208
00:09:38,380 --> 00:09:42,760
contents of all of the pages yeah it's

209
00:09:42,760 --> 00:09:46,420
nothing these bits implies move

210
00:09:46,420 --> 00:09:47,500
semantics

211
00:09:47,500 --> 00:09:49,000
she's apply it to the underlying virtual

212
00:09:49,000 --> 00:09:52,180
memory and the idea is this will be

213
00:09:52,180 --> 00:09:55,960
boxed so that was this look so we need

214
00:09:55,960 --> 00:09:59,350
to look at a little bit of my virtual

215
00:09:59,350 --> 00:10:02,440
memory internals and the kernel managed

216
00:10:02,440 --> 00:10:04,780
data structures that make this work so

217
00:10:04,780 --> 00:10:07,300
as we looked at before this starts task

218
00:10:07,300 --> 00:10:11,490
is the high-level perception of a task

219
00:10:11,490 --> 00:10:14,050
and the time has a virtual memory map

220
00:10:14,050 --> 00:10:17,530
which is a struct VM that you start p.m.

221
00:10:17,530 --> 00:10:22,180
match then contains pointers into a

222
00:10:22,180 --> 00:10:25,690
process linked list of virtual memory

223
00:10:25,690 --> 00:10:29,380
map entries I see you in here sir

224
00:10:29,380 --> 00:10:31,300
these can be either in a linked list or

225
00:10:31,300 --> 00:10:33,730
a red-black tree and essentially the

226
00:10:33,730 --> 00:10:35,110
linked list version is easier to think

227
00:10:35,110 --> 00:10:37,210
about but the red black tree is the one

228
00:10:37,210 --> 00:10:40,180
that's actually used in practice and

229
00:10:40,180 --> 00:10:42,940
really this is just an entry which

230
00:10:42,940 --> 00:10:45,370
covers everything well while it's

231
00:10:45,370 --> 00:10:48,190
virtual memory working memory region in

232
00:10:48,190 --> 00:10:51,220
your task

233
00:10:51,220 --> 00:10:53,730
so for each address that could be

234
00:10:53,730 --> 00:10:57,129
dereferenced okay if the new records

235
00:10:57,129 --> 00:10:59,680
don't as a deep it's covered by one of

236
00:10:59,680 --> 00:11:02,110
the virtual memory map entries in this

237
00:11:02,110 --> 00:11:05,009
mix we're actually read back through

238
00:11:05,009 --> 00:11:08,560
those me and my entries themselves first

239
00:11:08,560 --> 00:11:10,300
contained they're done didn't respond to

240
00:11:10,300 --> 00:11:12,579
see who they're going backwards if you

241
00:11:12,579 --> 00:11:14,860
wanted for example grab all of the

242
00:11:14,860 --> 00:11:17,800
veterinary map entries covering a region

243
00:11:17,800 --> 00:11:19,930
that's spanned by multiples of these you

244
00:11:19,930 --> 00:11:21,310
can start at the first one and

245
00:11:21,310 --> 00:11:23,019
particular in this until you've cracked

246
00:11:23,019 --> 00:11:24,459
all the things that cover the entire

247
00:11:24,459 --> 00:11:27,939
region the heat map that entry then

248
00:11:27,939 --> 00:11:29,709
tells you here's the verb to the dresser

249
00:11:29,709 --> 00:11:33,250
that I represent the start out and I

250
00:11:33,250 --> 00:11:34,959
represent the end on so I'm responsible

251
00:11:34,959 --> 00:11:37,209
for everything in between start and end

252
00:11:37,209 --> 00:11:40,720
and then finally at the end you actually

253
00:11:40,720 --> 00:11:44,410
have the pointers into the object that

254
00:11:44,410 --> 00:11:47,589
actually tells you how to get contents

255
00:11:47,589 --> 00:11:52,389
or the pages and finally what offset in

256
00:11:52,389 --> 00:11:54,730
that object do I start getting my memory

257
00:11:54,730 --> 00:11:59,259
from and then the last of our attraction

258
00:11:59,259 --> 00:12:02,139
we'll look at is what do those objects

259
00:12:02,139 --> 00:12:05,410
themselves look like so it starts off

260
00:12:05,410 --> 00:12:09,579
with this many cue pointer and this then

261
00:12:09,579 --> 00:12:12,069
finally need to point it in to the

262
00:12:12,069 --> 00:12:20,259
linked list of yes of DM pages and there

263
00:12:20,259 --> 00:12:25,269
is one VM page for each physical page of

264
00:12:25,269 --> 00:12:27,279
physical memory that can be allocated

265
00:12:27,279 --> 00:12:32,470
like that so these are then the pages

266
00:12:32,470 --> 00:12:34,329
that are currently resident are you

267
00:12:34,329 --> 00:12:39,550
actually their contents is in RAM for

268
00:12:39,550 --> 00:12:41,079
that object and it's very likely that

269
00:12:41,079 --> 00:12:43,480
the object that's Bob represents far

270
00:12:43,480 --> 00:12:46,689
more memory or has far more contents

271
00:12:46,689 --> 00:12:48,790
then is actually occurring in physical

272
00:12:48,790 --> 00:12:50,709
memory but this is the stuff that's in

273
00:12:50,709 --> 00:12:53,069
physical memory and then these other

274
00:12:53,069 --> 00:12:56,829
three fields here this pager aging

275
00:12:56,829 --> 00:12:59,079
offset pager control are then the way

276
00:12:59,079 --> 00:13:02,319
that you can get to BM object to either

277
00:13:02,319 --> 00:13:04,120
give physical page

278
00:13:04,120 --> 00:13:07,779
back or going request more contents to

279
00:13:07,779 --> 00:13:11,920
put we need their physical pages and

280
00:13:11,920 --> 00:13:14,079
then finally you can also nest these

281
00:13:14,079 --> 00:13:16,180
structures so rather than having a

282
00:13:16,180 --> 00:13:19,089
virtual memory map entry pointing

283
00:13:19,089 --> 00:13:22,329
directly into an object which could be

284
00:13:22,329 --> 00:13:25,089
for example the Earth file you can

285
00:13:25,089 --> 00:13:28,300
instead point into another map and this

286
00:13:28,300 --> 00:13:31,029
way you can nest between processes

287
00:13:31,029 --> 00:13:36,670
different virtual memory max so now that

288
00:13:36,670 --> 00:13:38,230
we've looked at accurately structures

289
00:13:38,230 --> 00:13:39,819
let's look at actually the

290
00:13:39,819 --> 00:13:43,180
implementation of how this optimized new

291
00:13:43,180 --> 00:13:47,620
operation is supposed to work so on the

292
00:13:47,620 --> 00:13:51,309
Left we have a sender task and on the

293
00:13:51,309 --> 00:13:55,540
right we have a receiver task so sender

294
00:13:55,540 --> 00:13:58,959
wants to send a mock message to receiver

295
00:13:58,959 --> 00:14:05,129
and it wants to in that message move

296
00:14:05,129 --> 00:14:08,800
some portion of its subjects face to the

297
00:14:08,800 --> 00:14:13,059
receiver so the way this works and

298
00:14:13,059 --> 00:14:15,040
Selina's already mentioned earlier these

299
00:14:15,040 --> 00:14:18,370
messages in most cases are actually

300
00:14:18,370 --> 00:14:20,920
being infused into the kernel and then

301
00:14:20,920 --> 00:14:23,230
only when we receiver actually tries to

302
00:14:23,230 --> 00:14:25,600
DQ the message will they be copied into

303
00:14:25,600 --> 00:14:29,079
the receiver so actually they cut this

304
00:14:29,079 --> 00:14:31,749
limbo state where they the message is

305
00:14:31,749 --> 00:14:34,629
live in the kernel and so the structure

306
00:14:34,629 --> 00:14:38,050
that's going to contain the near map

307
00:14:38,050 --> 00:14:39,970
entries which we are putting in this

308
00:14:39,970 --> 00:14:42,550
limbo state is called a DM map copy

309
00:14:42,550 --> 00:14:45,160
which is like a VM wrap but it's just

310
00:14:45,160 --> 00:14:48,040
there for containing stuff which is

311
00:14:48,040 --> 00:14:50,350
being copied like be a map entries which

312
00:14:50,350 --> 00:14:52,870
have been spotted around so this is how

313
00:14:52,870 --> 00:14:54,220
it's supposed to work you take your

314
00:14:54,220 --> 00:14:57,220
source in fact object States which is

315
00:14:57,220 --> 00:15:02,050
this big list like that three of virtual

316
00:15:02,050 --> 00:15:04,689
memory map entries we find the start and

317
00:15:04,689 --> 00:15:07,410
end of the region that you want to move

318
00:15:07,410 --> 00:15:10,149
then you move them into the copy and

319
00:15:10,149 --> 00:15:12,730
then later on when the receiver receives

320
00:15:12,730 --> 00:15:17,710
this it walks through their BMI entry

321
00:15:17,710 --> 00:15:20,140
it's where my entry list finds a place

322
00:15:20,140 --> 00:15:23,470
to put them and then copies those

323
00:15:23,470 --> 00:15:26,770
entries one copy the contents of those

324
00:15:26,770 --> 00:15:30,760
VM entry structures into new VM map data

325
00:15:30,760 --> 00:15:33,010
structures in there and so notice that

326
00:15:33,010 --> 00:15:35,320
that's taken some of the collector Jeff

327
00:15:35,320 --> 00:15:37,149
space but this presets on the left the

328
00:15:37,149 --> 00:15:39,279
thing that moved it is the receiver and

329
00:15:39,279 --> 00:15:41,740
at no point anyone have to amend copy

330
00:15:41,740 --> 00:15:44,550
the contents of that memory we get moved

331
00:15:44,550 --> 00:15:47,050
you know one obstruction or a few

332
00:15:47,050 --> 00:15:49,089
abstraction layers higher you just move

333
00:15:49,089 --> 00:15:51,420
the data structures around and magically

334
00:15:51,420 --> 00:15:53,830
you've done the equivalent of my look

335
00:15:53,830 --> 00:15:58,089
and then copy in their target so what's

336
00:15:58,089 --> 00:16:02,010
wrong here well what you have to first

337
00:16:02,010 --> 00:16:06,730
appreciate is that this works or this is

338
00:16:06,730 --> 00:16:08,589
supposed to work because what you're

339
00:16:08,589 --> 00:16:12,010
trying to do is move the merit yeah I'm

340
00:16:12,010 --> 00:16:14,100
not trying to make a copy of the memory

341
00:16:14,100 --> 00:16:16,660
there's this things like copy on writes

342
00:16:16,660 --> 00:16:18,670
which this bug has got nothing to do but

343
00:16:18,670 --> 00:16:22,230
would be a different way of achieving

344
00:16:22,230 --> 00:16:25,720
the same effect or a similar effect ie

345
00:16:25,720 --> 00:16:28,570
no overhead way to copy memory around

346
00:16:28,570 --> 00:16:31,270
but this is not a copy on write style

347
00:16:31,270 --> 00:16:38,500
thing this is so it's important then

348
00:16:38,500 --> 00:16:43,089
that the operation of finding the

349
00:16:43,089 --> 00:16:46,029
correctly and map entries and copying

350
00:16:46,029 --> 00:16:48,970
them into the VM map copy and then

351
00:16:48,970 --> 00:16:51,970
removing them from the cars all needs to

352
00:16:51,970 --> 00:16:56,830
be atomic and we'll see exactly why it

353
00:16:56,830 --> 00:16:58,510
needs to be atomic later on but

354
00:16:58,510 --> 00:17:00,220
hopefully it should be relatively clear

355
00:17:00,220 --> 00:17:01,900
that things are going to go very badly

356
00:17:01,900 --> 00:17:04,959
life it's not atomic so in order to

357
00:17:04,959 --> 00:17:07,619
understand how that might be enforced

358
00:17:07,619 --> 00:17:10,780
you need to understand the ownership

359
00:17:10,780 --> 00:17:12,790
semantics or the lifetime semantics of

360
00:17:12,790 --> 00:17:15,069
all of these objects so these here map

361
00:17:15,069 --> 00:17:19,839
entries are owned by their VN map and

362
00:17:19,839 --> 00:17:23,140
this is enforced by the VM rack lock

363
00:17:23,140 --> 00:17:29,679
field so you can only do everything that

364
00:17:29,679 --> 00:17:31,630
you do with a VM map entry

365
00:17:31,630 --> 00:17:34,360
you must hold the corresponding the M

366
00:17:34,360 --> 00:17:38,200
max luck at all times if you don't hold

367
00:17:38,200 --> 00:17:41,140
that lock then something else to come in

368
00:17:41,140 --> 00:17:44,289
and destroy the VMF entry that you are

369
00:17:44,289 --> 00:17:49,030
currently using yeah and it's almost

370
00:17:49,030 --> 00:17:50,770
certainly very very long is a very bad

371
00:17:50,770 --> 00:17:53,380
way if that doesn't happen and I think

372
00:17:53,380 --> 00:17:56,440
that twice a bug was actually audited by

373
00:17:56,440 --> 00:17:59,020
someone someone audited for that gasify

374
00:17:59,020 --> 00:18:00,700
okay there are many many many places

375
00:18:00,700 --> 00:18:02,470
where it's almost there it's not quite

376
00:18:02,470 --> 00:18:04,870
there they well done the Apple to report

377
00:18:04,870 --> 00:18:08,440
it for that bug Wow it's more subtle

378
00:18:08,440 --> 00:18:08,890
than that

379
00:18:08,890 --> 00:18:12,539
so let's look that's that

380
00:18:12,539 --> 00:18:17,559
how that look is actually used so yeah

381
00:18:17,559 --> 00:18:18,940
on the side I'm locking in the VM

382
00:18:18,940 --> 00:18:21,250
subsystem avoiding kept up to the hard

383
00:18:21,250 --> 00:18:23,980
problem it sort of sit there and it's a

384
00:18:23,980 --> 00:18:26,250
problem so this is their Mac very for

385
00:18:26,250 --> 00:18:29,710
taking the Mian record they're actually

386
00:18:29,710 --> 00:18:33,669
buying BM Mac Mac Mac it's a very long

387
00:18:33,669 --> 00:18:35,710
function what read/write lot of specific

388
00:18:35,710 --> 00:18:38,559
look it doesn't matter what this

389
00:18:38,559 --> 00:18:40,690
actually does but that looks like really

390
00:18:40,690 --> 00:18:42,640
sounded way to take a lock yeah cool

391
00:18:42,640 --> 00:18:44,710
funny thing would lock in it so let's

392
00:18:44,710 --> 00:18:47,980
look at me and Mac unlock yeah Mac I'm

393
00:18:47,980 --> 00:18:50,980
not a slightly more curious looking for

394
00:18:50,980 --> 00:18:53,409
doing the unlock it bumps up this time

395
00:18:53,409 --> 00:18:59,950
stamp counter and then drop the lock and

396
00:18:59,950 --> 00:19:03,640
this is a human executi not really

397
00:19:03,640 --> 00:19:04,840
relevant for the backing and talked

398
00:19:04,840 --> 00:19:08,350
about but very relevant for why none of

399
00:19:08,350 --> 00:19:12,070
this is really fixed so why do we even

400
00:19:12,070 --> 00:19:13,720
have that time stamp counter there and

401
00:19:13,720 --> 00:19:16,390
what's it being useful remember avoiding

402
00:19:16,390 --> 00:19:17,640
dead box is a hard problem

403
00:19:17,640 --> 00:19:21,400
so let's look at an example okay so the

404
00:19:21,400 --> 00:19:25,210
usage of me and map dot when Sam so what

405
00:19:25,210 --> 00:19:28,090
am I do what they hold the lock is make

406
00:19:28,090 --> 00:19:32,549
a local copy of my time travel without

407
00:19:32,549 --> 00:19:39,039
Molotov then drop the lock on the map go

408
00:19:39,039 --> 00:19:43,430
do some stuff a lot on the map again

409
00:19:43,430 --> 00:19:47,420
and then check whether last time stamp

410
00:19:47,420 --> 00:19:50,030
plus one is equal to the current time

411
00:19:50,030 --> 00:19:55,490
stamp and if it's you know reason sir

412
00:19:55,490 --> 00:19:58,040
otherwise continue so what is actually

413
00:19:58,040 --> 00:19:59,960
going on there well really what they're

414
00:19:59,960 --> 00:20:02,930
saying is I'm about to do something here

415
00:20:02,930 --> 00:20:06,770
for which I am NOT for which there may

416
00:20:06,770 --> 00:20:07,610
be deadlocks

417
00:20:07,610 --> 00:20:11,060
or even worse things if I hold the lock

418
00:20:11,060 --> 00:20:13,940
on this map therefore I'm just gonna

419
00:20:13,940 --> 00:20:17,750
drop the lock do some stuff and then I'm

420
00:20:17,750 --> 00:20:20,560
gonna try and check if anyone raced me

421
00:20:20,560 --> 00:20:23,150
and if anyone raised me when they would

422
00:20:23,150 --> 00:20:25,010
have taken the lock and drop the lock

423
00:20:25,010 --> 00:20:27,200
and on dropping a lot they would have

424
00:20:27,200 --> 00:20:31,070
bumped the max time stamp up at which

425
00:20:31,070 --> 00:20:33,680
point I'm going to now have to try to

426
00:20:33,680 --> 00:20:36,950
recover because everything I thought I

427
00:20:36,950 --> 00:20:39,200
knew I can till this point about the

428
00:20:39,200 --> 00:20:41,330
structure of the PM map may no longer be

429
00:20:41,330 --> 00:20:45,170
true so find the edger again it could

430
00:20:45,170 --> 00:20:46,640
have been Kip doctor we unlocked the map

431
00:20:46,640 --> 00:20:51,530
yes you have to go reset everything and

432
00:20:51,530 --> 00:20:53,750
you can think about why this might be so

433
00:20:53,750 --> 00:20:55,910
pervasive well this is the virtual

434
00:20:55,910 --> 00:20:58,850
memory time system and it turns out with

435
00:20:58,850 --> 00:21:00,440
a virtual memory subsystem sometimes

436
00:21:00,440 --> 00:21:03,350
faster allocate virtual memory and it

437
00:21:03,350 --> 00:21:06,050
can't really hold a global lock on

438
00:21:06,050 --> 00:21:08,030
itself while it's trying to put more

439
00:21:08,030 --> 00:21:12,890
memory into it so yeah it's it's not

440
00:21:12,890 --> 00:21:16,910
real without some severe thinking how to

441
00:21:16,910 --> 00:21:19,460
like generically fix this correctly and

442
00:21:19,460 --> 00:21:22,490
this is this construct is everywhere and

443
00:21:22,490 --> 00:21:23,930
so it should be kind of clear where the

444
00:21:23,930 --> 00:21:25,630
bug is gonna be the bug is going to be

445
00:21:25,630 --> 00:21:29,240
well in this window do some stuff will

446
00:21:29,240 --> 00:21:31,160
surprise them back to be unlocked then

447
00:21:31,160 --> 00:21:34,490
did someone race us well okay we

448
00:21:34,490 --> 00:21:36,140
detected that someone raised us so we

449
00:21:36,140 --> 00:21:38,090
need to reset our expectations about the

450
00:21:38,090 --> 00:21:39,830
state of the world and try again and

451
00:21:39,830 --> 00:21:43,340
it's something in this let's reset what

452
00:21:43,340 --> 00:21:44,800
no I don't think we know about the world

453
00:21:44,800 --> 00:21:50,960
the box exactly so we'll look more

454
00:21:50,960 --> 00:21:53,770
accurately don't

455
00:21:54,110 --> 00:21:56,809
a case where they are failing to

456
00:21:56,809 --> 00:21:59,120
accurately reset what they believe the

457
00:21:59,120 --> 00:22:01,580
state of the world should be in regards

458
00:22:01,580 --> 00:22:04,250
to in this case a virtual memory

459
00:22:04,250 --> 00:22:06,049
operation which is supposed to have new

460
00:22:06,049 --> 00:22:11,360
semantics so let's take this task on the

461
00:22:11,360 --> 00:22:15,860
left and we want to send this shaded

462
00:22:15,860 --> 00:22:21,200
region in a VM a copy to another task we

463
00:22:21,200 --> 00:22:28,370
want to send it in so we start with the

464
00:22:28,370 --> 00:22:32,539
being unlocked and we're RBM a copy

465
00:22:32,539 --> 00:22:37,539
object we allocate one VM map entry

466
00:22:37,539 --> 00:22:43,669
hanging off of the copy these me and my

467
00:22:43,669 --> 00:22:45,559
twin trees come from a lock so the

468
00:22:45,559 --> 00:22:51,289
generic kernel zone locator which we

469
00:22:51,289 --> 00:22:53,750
cannot hold me and that lock because we

470
00:22:53,750 --> 00:22:56,630
may well be smoothing this task could

471
00:22:56,630 --> 00:22:58,399
leave the color fast or it could be the

472
00:22:58,399 --> 00:23:00,950
VM map from which that stuff comes so we

473
00:23:00,950 --> 00:23:04,639
can't hold a lot so but we upfront

474
00:23:04,639 --> 00:23:10,580
allocate one VM map entry then we take a

475
00:23:10,580 --> 00:23:14,419
lock on the and we copy the contents

476
00:23:14,419 --> 00:23:19,190
of this first VM map entry into our copy

477
00:23:19,190 --> 00:23:23,659
of the beer map actually and so now we

478
00:23:23,659 --> 00:23:26,149
can't distill there in here and there's

479
00:23:26,149 --> 00:23:29,419
a little present in the VM Maps link

480
00:23:29,419 --> 00:23:32,120
list of near my entries but the lot is

481
00:23:32,120 --> 00:23:34,580
healthy then no one can come in mess

482
00:23:34,580 --> 00:23:39,139
with this then with the locks are

483
00:23:39,139 --> 00:23:41,269
matched we iterate through to the next

484
00:23:41,269 --> 00:23:44,389
being map entry then we watch copy and

485
00:23:44,389 --> 00:23:47,330
if there was one I if we haven't yet

486
00:23:47,330 --> 00:23:50,539
reached the end of the virtual memory

487
00:23:50,539 --> 00:23:53,690
regions we want to copy well we only

488
00:23:53,690 --> 00:23:55,940
allocated upfront on one of these things

489
00:23:55,940 --> 00:23:57,980
and what you're going to need some more

490
00:23:57,980 --> 00:24:00,289
i remember if you need more we need to

491
00:24:00,289 --> 00:24:01,970
drop that look because we can't hold a

492
00:24:01,970 --> 00:24:03,889
lot when we make our talent allocation

493
00:24:03,889 --> 00:24:06,080
so what are you here needs we're going

494
00:24:06,080 --> 00:24:07,300
to call the

495
00:24:07,300 --> 00:24:10,580
we're going to drop the lock we're going

496
00:24:10,580 --> 00:24:13,540
to allocate a new VM map entry onto our

497
00:24:13,540 --> 00:24:17,390
list in the VM map copy then we're going

498
00:24:17,390 --> 00:24:20,150
to click the lock again and then we're

499
00:24:20,150 --> 00:24:23,840
going to see does y 0 2 plus 1 by r

500
00:24:23,840 --> 00:24:28,720
minus there when we drop the lot plus 1

501
00:24:28,720 --> 00:24:31,850
equal the current myanmar times that

502
00:24:31,850 --> 00:24:37,460
did anyone racist only this is not

503
00:24:37,460 --> 00:24:39,230
clearly detecting did anyone like

504
00:24:39,230 --> 00:24:39,980
maliciously

505
00:24:39,980 --> 00:24:42,140
race against us this just means we did

506
00:24:42,140 --> 00:24:43,940
anything else happen which modified the

507
00:24:43,940 --> 00:24:45,980
state of the map and don't think about

508
00:24:45,980 --> 00:24:48,140
what might have happened if it modified

509
00:24:48,140 --> 00:24:49,580
the state of the map for billion times

510
00:24:49,580 --> 00:24:53,990
and the tag that explode that's not the

511
00:24:53,990 --> 00:25:00,260
bug but that is about simply it doesn't

512
00:25:00,260 --> 00:25:02,980
actually at the time if it appears that

513
00:25:02,980 --> 00:25:06,320
either no unlocks happened or all

514
00:25:06,320 --> 00:25:07,880
billion and whatever on what's happened

515
00:25:07,880 --> 00:25:10,430
then we will not reached therefore we

516
00:25:10,430 --> 00:25:13,520
can continue back up to the head of the

517
00:25:13,520 --> 00:25:16,310
loop here we hold the lock we've got a

518
00:25:16,310 --> 00:25:18,290
new VM map entry and we can copy the

519
00:25:18,290 --> 00:25:22,100
contents and move on so the question is

520
00:25:22,100 --> 00:25:24,620
what is the type that doesn't match and

521
00:25:24,620 --> 00:25:26,600
this is the point where we need to reset

522
00:25:26,600 --> 00:25:28,370
our expectations about the state of the

523
00:25:28,370 --> 00:25:29,470
world

524
00:25:29,470 --> 00:25:35,270
well linear map pretty changed and it

525
00:25:35,270 --> 00:25:37,760
could be the case that the me and map

526
00:25:37,760 --> 00:25:40,760
entry for which we had a pointer is has

527
00:25:40,760 --> 00:25:43,100
been freed and that pointer is no longer

528
00:25:43,100 --> 00:25:46,580
valid so we need to go and look up the

529
00:25:46,580 --> 00:25:50,660
VM entry which now covers the remainder

530
00:25:50,660 --> 00:25:53,600
of the budget X region that we have

531
00:25:53,600 --> 00:25:57,020
tried to copy so we do a fresh look up

532
00:25:57,020 --> 00:25:59,600
of the next we're mapping through to

533
00:25:59,600 --> 00:26:02,470
copy and then we continue along the loop

534
00:26:02,470 --> 00:26:04,880
so we take the contents of now this

535
00:26:04,880 --> 00:26:10,130
second purple one here and we copy the

536
00:26:10,130 --> 00:26:12,220
contents of it in to the near map a tree

537
00:26:12,220 --> 00:26:17,480
and repeat all the way down until we've

538
00:26:17,480 --> 00:26:19,890
covered the whole region

539
00:26:19,890 --> 00:26:22,230
and then finally once we've copied all

540
00:26:22,230 --> 00:26:24,330
of the contents over into the Nano map

541
00:26:24,330 --> 00:26:27,600
copy we remove looking at my entries

542
00:26:27,600 --> 00:26:30,270
from the source task and say this is

543
00:26:30,270 --> 00:26:32,070
really than this point into the next

544
00:26:32,070 --> 00:26:35,580
field this one now point a to this one

545
00:26:35,580 --> 00:26:38,130
and this pops back there there's similar

546
00:26:38,130 --> 00:26:39,540
thing in the red black tree that make

547
00:26:39,540 --> 00:26:42,780
them all wake up correctly so what's

548
00:26:42,780 --> 00:26:47,640
wrong yet the problem is this is

549
00:26:47,640 --> 00:26:50,190
supposed to be a completely atomic move

550
00:26:50,190 --> 00:26:55,590
operating if you are an observer of the

551
00:26:55,590 --> 00:26:57,870
VM map you should only ever be able to

552
00:26:57,870 --> 00:27:00,120
see two states we should either see the

553
00:27:00,120 --> 00:27:02,880
whole virtual memory region is in there

554
00:27:02,880 --> 00:27:05,370
in the source or the whole the promoter

555
00:27:05,370 --> 00:27:07,850
region is gone

556
00:27:07,850 --> 00:27:12,299
and if you can ever interact with the

557
00:27:12,299 --> 00:27:17,250
map in intermediate states between those

558
00:27:17,250 --> 00:27:19,290
two when this is no longer an atomic

559
00:27:19,290 --> 00:27:22,320
operation and we will see what is going

560
00:27:22,320 --> 00:27:24,120
to go wrong if it's not a real atomic

561
00:27:24,120 --> 00:27:27,090
operation so let's look at what might

562
00:27:27,090 --> 00:27:30,030
happen because it should be clear that

563
00:27:30,030 --> 00:27:31,260
this is key not so much on the

564
00:27:31,260 --> 00:27:33,450
operations because at some points that

565
00:27:33,450 --> 00:27:42,360
lot goes red and the lock is dropped so

566
00:27:42,360 --> 00:27:45,270
the content doesn't match then it's not

567
00:27:45,270 --> 00:27:47,850
enough to just invalidate this pointer

568
00:27:47,850 --> 00:27:50,910
which points to the next VM at entry to

569
00:27:50,910 --> 00:27:55,730
copy we also have to go back and reset

570
00:27:55,730 --> 00:27:58,380
everything that we've done previously

571
00:27:58,380 --> 00:28:02,910
here so there is someone because we

572
00:28:02,910 --> 00:28:06,299
never removed this where map entry from

573
00:28:06,299 --> 00:28:08,250
the source we only remove that entries

574
00:28:08,250 --> 00:28:11,490
right at the end of the operation so

575
00:28:11,490 --> 00:28:14,220
when we reset the state of the world we

576
00:28:14,220 --> 00:28:17,309
need to reset everything we've done now

577
00:28:17,309 --> 00:28:20,429
that basically what the you can also see

578
00:28:20,429 --> 00:28:21,900
this in the source but it's kind of

579
00:28:21,900 --> 00:28:24,030
clearer here but really it's all us it's

580
00:28:24,030 --> 00:28:27,150
like you need to go back one loop one

581
00:28:27,150 --> 00:28:30,179
nested loop higher so you can't just go

582
00:28:30,179 --> 00:28:33,030
back and fetch this current entry you're

583
00:28:33,030 --> 00:28:33,810
working on

584
00:28:33,810 --> 00:28:35,220
you have to go back and researched all

585
00:28:35,220 --> 00:28:40,050
the entries so what

586
00:28:40,050 --> 00:28:43,320
concretely bad could happen well let's

587
00:28:43,320 --> 00:28:46,290
imagine that while the map is unlocked

588
00:28:46,290 --> 00:28:48,780
so while the market unlocked and one

589
00:28:48,780 --> 00:28:50,970
copy has already been made and we are

590
00:28:50,970 --> 00:28:54,420
busy making a Kellogg zone allocation

591
00:28:54,420 --> 00:28:56,880
for the next near map entry someone else

592
00:28:56,880 --> 00:28:59,550
another thread with access to the VM map

593
00:28:59,550 --> 00:29:03,840
comes along and decides well how about I

594
00:29:03,840 --> 00:29:07,340
also perform and optimize the move

595
00:29:07,340 --> 00:29:11,880
operation at the same time so then

596
00:29:11,880 --> 00:29:14,070
there's going to be this second VM a

597
00:29:14,070 --> 00:29:17,730
copy which again has a VM that entry and

598
00:29:17,730 --> 00:29:19,560
then this second one it's going to start

599
00:29:19,560 --> 00:29:20,970
at the beginning of the virtual address

600
00:29:20,970 --> 00:29:26,340
space see that this great out here map

601
00:29:26,340 --> 00:29:27,870
entry the contents are still intact

602
00:29:27,870 --> 00:29:29,610
because the contents were just copied

603
00:29:29,610 --> 00:29:32,370
into our original being map entry copy

604
00:29:32,370 --> 00:29:34,290
so it's going to copy the contents of

605
00:29:34,290 --> 00:29:37,230
this ones into this second we are map

606
00:29:37,230 --> 00:29:41,810
copy and now they're going to like both

607
00:29:41,810 --> 00:29:44,490
contend on this lock and kind of thrash

608
00:29:44,490 --> 00:29:46,830
around but what you're at to gonna end

609
00:29:46,830 --> 00:29:50,340
up with or to VM map copies that if the

610
00:29:50,340 --> 00:29:52,200
locking works out and actually the

611
00:29:52,200 --> 00:29:53,700
locking pretty much all those lights out

612
00:29:53,700 --> 00:29:58,860
if you correctly for ask the VM map set

613
00:29:58,860 --> 00:30:01,650
up you're going to have to VM map copies

614
00:30:01,650 --> 00:30:04,860
which both believe they are atomic moves

615
00:30:04,860 --> 00:30:06,930
of virtual memory regions where they

616
00:30:06,930 --> 00:30:13,320
both have the same underlying their map

617
00:30:13,320 --> 00:30:16,770
entries which a map to the same yeah map

618
00:30:16,770 --> 00:30:19,860
objects and offsets and we'll see

619
00:30:19,860 --> 00:30:21,870
exactly what there are consequences of

620
00:30:21,870 --> 00:30:24,540
that are in a little bit so how to

621
00:30:24,540 --> 00:30:26,820
actually set something like this up to

622
00:30:26,820 --> 00:30:27,890
do something interesting

623
00:30:27,890 --> 00:30:34,140
so this diagonal set of boxes again is

624
00:30:34,140 --> 00:30:35,820
the virtual address space of your

625
00:30:35,820 --> 00:30:38,730
Christmas this being our lower dress up

626
00:30:38,730 --> 00:30:41,820
to a higher regress and what we're going

627
00:30:41,820 --> 00:30:46,480
to create our active line descriptors

628
00:30:46,480 --> 00:30:48,610
so those are these descriptors which

629
00:30:48,610 --> 00:30:50,080
enable you to take I think with a

630
00:30:50,080 --> 00:30:51,580
virtual memory and put it in a message

631
00:30:51,580 --> 00:30:53,440
and move that and we're going to create

632
00:30:53,440 --> 00:30:55,900
two of them and send them in two

633
00:30:55,900 --> 00:30:58,510
different messages and what the first

634
00:30:58,510 --> 00:31:01,240
one is going to contain this first dark

635
00:31:01,240 --> 00:31:05,020
shaded region and this blue one in the

636
00:31:05,020 --> 00:31:07,929
middle here while I sit there and the

637
00:31:07,929 --> 00:31:12,030
second one it's in an overlap just one

638
00:31:12,030 --> 00:31:14,890
being map entry and continue on like

639
00:31:14,890 --> 00:31:16,240
this so you can see you're going to

640
00:31:16,240 --> 00:31:19,419
create descriptors which overlap by one

641
00:31:19,419 --> 00:31:24,160
being map country and then in two

642
00:31:24,160 --> 00:31:26,230
threads at the same time we're going to

643
00:31:26,230 --> 00:31:31,780
send these messages so in parallel we're

644
00:31:31,780 --> 00:31:33,880
going to get one VMware copy which

645
00:31:33,880 --> 00:31:36,669
contains all of these dark purple ones

646
00:31:36,669 --> 00:31:40,480
and the shaded blue near map poppy and

647
00:31:40,480 --> 00:31:43,059
in the second parallel thread because

648
00:31:43,059 --> 00:31:45,309
the lock keeps getting dropped and we

649
00:31:45,309 --> 00:31:46,929
can do this because they don't correctly

650
00:31:46,929 --> 00:31:49,570
reset the state of the world we are

651
00:31:49,570 --> 00:31:52,720
going to have a VM a copy which starts

652
00:31:52,720 --> 00:31:54,700
with the overlapping region and then

653
00:31:54,700 --> 00:31:56,710
contains a bunch of other game at

654
00:31:56,710 --> 00:31:59,950
entries yeah depends about the actual

655
00:31:59,950 --> 00:32:02,370
structure that I used for the exploit on

656
00:32:02,370 --> 00:32:07,210
my team's bug tracker you have to be a

657
00:32:07,210 --> 00:32:08,919
bit more speedy about I'm certain these

658
00:32:08,919 --> 00:32:12,390
things up but this is ending in the area

659
00:32:12,390 --> 00:32:14,890
and so what it's actually gonna happen

660
00:32:14,890 --> 00:32:17,290
when these two messages get worse needs

661
00:32:17,290 --> 00:32:20,200
well you click the end map and some

662
00:32:20,200 --> 00:32:22,870
contents implies in this case it's an

663
00:32:22,870 --> 00:32:25,299
anonymous object so this is just a way

664
00:32:25,299 --> 00:32:28,299
that you get empty pages of memory that

665
00:32:28,299 --> 00:32:30,610
you can do stuff with that aren't backed

666
00:32:30,610 --> 00:32:33,669
by a file or anything else that you can

667
00:32:33,669 --> 00:32:39,429
in map in geography and so the

668
00:32:39,429 --> 00:32:41,230
consequence of them both pointing to the

669
00:32:41,230 --> 00:32:42,880
same offset is that you're actually

670
00:32:42,880 --> 00:32:45,130
ending up with shared memory I

671
00:32:45,130 --> 00:32:49,059
when this firm might copy gets mapped

672
00:32:49,059 --> 00:32:51,280
into one process then this it's wrapped

673
00:32:51,280 --> 00:32:53,530
into a different process we ended up

674
00:32:53,530 --> 00:32:56,980
both having the same with having a

675
00:32:56,980 --> 00:32:58,740
tree which in the end will

676
00:32:58,740 --> 00:33:00,990
the same physical pages so they

677
00:33:00,990 --> 00:33:03,380
accidentally created shared memory and

678
00:33:03,380 --> 00:33:06,840
we will find a way to turn accidentally

679
00:33:06,840 --> 00:33:08,279
created shared memory for something more

680
00:33:08,279 --> 00:33:10,500
useful so then that's as quickly look at

681
00:33:10,500 --> 00:33:12,690
what is going to happen when these two

682
00:33:12,690 --> 00:33:13,860
messages are received

683
00:33:13,860 --> 00:33:19,919
so first message here will be received

684
00:33:19,919 --> 00:33:22,260
by the task on the list so again all of

685
00:33:22,260 --> 00:33:25,049
these me and my entries go away all of

686
00:33:25,049 --> 00:33:27,059
these here my entries will get swatted

687
00:33:27,059 --> 00:33:28,770
somewhere into this virtual address

688
00:33:28,770 --> 00:33:32,399
space and then of the task on the left

689
00:33:32,399 --> 00:33:34,559
and the tasks on the right will receive

690
00:33:34,559 --> 00:33:37,710
will match this VM a copy into their

691
00:33:37,710 --> 00:33:40,830
address space and they will go in there

692
00:33:40,830 --> 00:33:45,990
and now these parts have a VMware entry

693
00:33:45,990 --> 00:33:49,409
with the same contents which is fine

694
00:33:49,409 --> 00:33:53,940
what means is you have said Mary what

695
00:33:53,940 --> 00:33:55,260
does the shared memory really mean it

696
00:33:55,260 --> 00:33:58,320
means that in this task if I write to

697
00:33:58,320 --> 00:34:01,529
this page which I believe is in an out

698
00:34:01,529 --> 00:34:04,049
of line which is in memory sent to me in

699
00:34:04,049 --> 00:34:05,549
an out of lying descriptor in the mock

700
00:34:05,549 --> 00:34:09,060
message that meant that those change is

701
00:34:09,060 --> 00:34:11,219
going to be visible to the task on the

702
00:34:11,219 --> 00:34:13,109
right whereas the tasks on the right

703
00:34:13,109 --> 00:34:15,869
also believe that it's just received as

704
00:34:15,869 --> 00:34:17,699
well it has received us in now to find

705
00:34:17,699 --> 00:34:19,800
descriptor and it believes that that

706
00:34:19,800 --> 00:34:22,139
memory is immutable because that is what

707
00:34:22,139 --> 00:34:23,790
the doctors say about watching mark

708
00:34:23,790 --> 00:34:28,560
messages so the trick to do something

709
00:34:28,560 --> 00:34:33,389
interesting with this is when we can

710
00:34:33,389 --> 00:34:36,719
send messages to ourself so we create a

711
00:34:36,719 --> 00:34:39,830
crafted out of line descriptor

712
00:34:39,830 --> 00:34:43,619
overlapping region and then we have the

713
00:34:43,619 --> 00:34:45,270
target that we're going to look back in

714
00:34:45,270 --> 00:34:48,810
second and we send one bit of this to

715
00:34:48,810 --> 00:34:51,949
the target then back to ourselves and

716
00:34:51,949 --> 00:34:54,570
what this doughnut is evil is to do is

717
00:34:54,570 --> 00:34:57,900
to read and write to these pages in that

718
00:34:57,900 --> 00:35:00,990
event descriptor while the target is

719
00:35:00,990 --> 00:35:03,690
processing and that's what's there

720
00:35:03,690 --> 00:35:07,230
enable us to do something interesting so

721
00:35:07,230 --> 00:35:09,930
yeah how do we exploit unexpectedly

722
00:35:09,930 --> 00:35:10,930
shared memory

723
00:35:10,930 --> 00:35:13,329
against the client premises that you end

724
00:35:13,329 --> 00:35:17,680
up with there so this breaks the

725
00:35:17,680 --> 00:35:20,380
semantics that well myself just like an

726
00:35:20,380 --> 00:35:22,589
envelope ie

727
00:35:22,589 --> 00:35:25,359
unique a letter in the post you taking

728
00:35:25,359 --> 00:35:26,920
out the envelope and you expect to just

729
00:35:26,920 --> 00:35:29,289
be able to if you read it twice you read

730
00:35:29,289 --> 00:35:31,869
the same thing you don't expect the

731
00:35:31,869 --> 00:35:34,029
contents of it to ever change it's

732
00:35:34,029 --> 00:35:36,029
immutable and this is the guarantee that

733
00:35:36,029 --> 00:35:38,170
mock messages make as well

734
00:35:38,170 --> 00:35:41,650
you are deafening given this as if it

735
00:35:41,650 --> 00:35:44,369
were copied into your address base and

736
00:35:44,369 --> 00:35:46,539
it's supposed to be eating from you that

737
00:35:46,539 --> 00:35:48,339
it wasn't really copied because all this

738
00:35:48,339 --> 00:35:52,650
went to stuff going on behind scene so

739
00:35:52,650 --> 00:35:55,029
we're not learning it there is we need

740
00:35:55,029 --> 00:35:57,910
to find somewhere we're breaking those

741
00:35:57,910 --> 00:35:59,980
semantics by breaking the fact that this

742
00:35:59,980 --> 00:36:02,440
is meant to be immutable actually leads

743
00:36:02,440 --> 00:36:05,260
to something happening that has security

744
00:36:05,260 --> 00:36:09,099
impact in air quotes we'll go quickly

745
00:36:09,099 --> 00:36:12,549
through this is gonna dive into serious

746
00:36:12,549 --> 00:36:14,890
aside what is security in fact quickly

747
00:36:14,890 --> 00:36:17,079
some think about it it's very difficult

748
00:36:17,079 --> 00:36:20,160
to define what security integrity means

749
00:36:20,160 --> 00:36:23,200
memory corruption is the most boring yet

750
00:36:23,200 --> 00:36:24,609
white except the thing with security

751
00:36:24,609 --> 00:36:28,150
impact that's in there is a great deal

752
00:36:28,150 --> 00:36:32,710
of research over decades which in

753
00:36:32,710 --> 00:36:34,960
hopefully have to convince you that if

754
00:36:34,960 --> 00:36:37,059
you can call us we're in this in a very

755
00:36:37,059 --> 00:36:41,829
likely way it is almost always possible

756
00:36:41,829 --> 00:36:43,750
to turn memory corruption in each target

757
00:36:43,750 --> 00:36:45,460
context into the ability to perform

758
00:36:45,460 --> 00:36:47,470
other consistent interactions with the

759
00:36:47,470 --> 00:36:50,170
trust level of the target context are

760
00:36:50,170 --> 00:36:53,039
you memory corruption is always bad but

761
00:36:53,039 --> 00:36:55,210
there are all interesting things you can

762
00:36:55,210 --> 00:36:58,299
do with a primitive like I can suddenly

763
00:36:58,299 --> 00:37:00,549
make memory there's not socially shared

764
00:37:00,549 --> 00:37:02,710
when I we shared memory so you can

765
00:37:02,710 --> 00:37:04,869
imagine things like time of kept time

766
00:37:04,869 --> 00:37:09,210
abuse in signature campaign which exists

767
00:37:09,210 --> 00:37:11,980
everywhere there have been many places

768
00:37:11,980 --> 00:37:17,289
on iOS there any mac OS of things like

769
00:37:17,289 --> 00:37:20,020
that you would then have to find some

770
00:37:20,020 --> 00:37:22,589
place where that's happening on a

771
00:37:22,589 --> 00:37:24,490
deadline on

772
00:37:24,490 --> 00:37:26,020
that sent as an applet line just like

773
00:37:26,020 --> 00:37:29,020
that I didn't find any that interesting

774
00:37:29,020 --> 00:37:30,700
things out you can think of other things

775
00:37:30,700 --> 00:37:34,960
like more time effect I would use in for

776
00:37:34,960 --> 00:37:41,050
example select the validation so NSX PC

777
00:37:41,050 --> 00:37:43,000
I don't reckon over here has ever gone

778
00:37:43,000 --> 00:37:45,369
into the details of NSX PT works this is

779
00:37:45,369 --> 00:37:50,430
a way where you can do kind of very cool

780
00:37:50,430 --> 00:37:53,980
objective-c magical object remoting you

781
00:37:53,980 --> 00:37:56,080
can just call a selector or an object in

782
00:37:56,080 --> 00:37:58,690
your exacts and it actually occurs in

783
00:37:58,690 --> 00:38:00,580
some other versions on the other name

784
00:38:00,580 --> 00:38:02,589
and this really involves like sending a

785
00:38:02,589 --> 00:38:04,839
string like a serialized string

786
00:38:04,839 --> 00:38:06,970
representing to select that to the other

787
00:38:06,970 --> 00:38:08,349
side and saying yeah please call the

788
00:38:08,349 --> 00:38:10,750
selector I have actually look quite deep

789
00:38:10,750 --> 00:38:12,760
this of whether that could be a time

790
00:38:12,760 --> 00:38:13,930
check my keys there and I don't think

791
00:38:13,930 --> 00:38:17,440
there is what 2220 some bytecode

792
00:38:17,440 --> 00:38:21,849
verification and we could the quirky is

793
00:38:21,849 --> 00:38:24,160
not here it's gonna play right that was

794
00:38:24,160 --> 00:38:26,140
for him because that happened pieces of

795
00:38:26,140 --> 00:38:28,750
for example is playstation for exploit

796
00:38:28,750 --> 00:38:32,800
with time technologies in the EP a quite

797
00:38:32,800 --> 00:38:38,970
code on playstation 4 ESD to our color

798
00:38:38,970 --> 00:38:43,119
mac OS via PDF it's far simpler than the

799
00:38:43,119 --> 00:38:45,430
other well you know that could be a

800
00:38:45,430 --> 00:38:47,470
weird alligator that releases the pages

801
00:38:47,470 --> 00:38:51,880
or really still don't but yes I'm boring

802
00:38:51,880 --> 00:38:52,240
I'm lazy

803
00:38:52,240 --> 00:38:54,900
we'll just call for intersection

804
00:38:54,900 --> 00:38:57,450
specifically I also really wants to bog

805
00:38:57,450 --> 00:39:00,490
which we can play more with point

806
00:39:00,490 --> 00:39:04,270
authentication point authentication is

807
00:39:04,270 --> 00:39:05,980
very interesting and that's not really

808
00:39:05,980 --> 00:39:08,230
what the story's about and I think I

809
00:39:08,230 --> 00:39:09,790
will run out of time before we get to

810
00:39:09,790 --> 00:39:10,660
discuss that at all

811
00:39:10,660 --> 00:39:12,040
but if you're interested there's a

812
00:39:12,040 --> 00:39:17,619
public blog post about how you can play

813
00:39:17,619 --> 00:39:21,130
with one aspect of whatever the security

814
00:39:21,130 --> 00:39:22,480
model of point authentication is

815
00:39:22,480 --> 00:39:24,570
supposed to be you can defeat some of it

816
00:39:24,570 --> 00:39:27,670
with so if you did memory demand

817
00:39:27,670 --> 00:39:30,369
reduction so they're doing bugs

818
00:39:30,369 --> 00:39:33,220
similar to the one I've just described

819
00:39:33,220 --> 00:39:34,630
we've been done by other people before

820
00:39:34,630 --> 00:39:36,970
so in 2017

821
00:39:36,970 --> 00:39:41,080
he on our team at Google also found this

822
00:39:41,080 --> 00:39:45,070
Punk Cee presently in 24:56 which led to

823
00:39:45,070 --> 00:39:47,109
a similar style similar kind of contract

824
00:39:47,109 --> 00:39:48,970
well you can end up with unexpected

825
00:39:48,970 --> 00:39:51,490
shared memory the colors in that case

826
00:39:51,490 --> 00:39:54,280
rather than it was a different kind of

827
00:39:54,280 --> 00:39:58,420
trick and you could send out the blind

828
00:39:58,420 --> 00:40:00,760
descriptor where the pages were fact by

829
00:40:00,760 --> 00:40:04,330
a mock memory entry object and then

830
00:40:04,330 --> 00:40:07,030
there was just on fire where you could

831
00:40:07,030 --> 00:40:09,400
actually then bring aid back from the

832
00:40:09,400 --> 00:40:11,320
mock memory entry object but suddenly

833
00:40:11,320 --> 00:40:14,740
you had shared memory again and so he

834
00:40:14,740 --> 00:40:18,640
targeted that construct in Linux PC so

835
00:40:18,640 --> 00:40:21,550
here is the live XP T time I checked and

836
00:40:21,550 --> 00:40:23,740
gives the game great so I just copied

837
00:40:23,740 --> 00:40:27,720
his technique with its exploit so

838
00:40:27,720 --> 00:40:31,599
serialize XP T West bodies xvc I

839
00:40:31,599 --> 00:40:35,500
mentioned NS excuses NSX BC it built on

840
00:40:35,500 --> 00:40:41,490
top of exbc XP T itself is a new ish

841
00:40:41,490 --> 00:40:46,710
kind of its serialization format and

842
00:40:46,710 --> 00:40:51,790
with about 10 or 12 basic types that you

843
00:40:51,790 --> 00:40:53,339
can serialize into my binary message

844
00:40:53,339 --> 00:40:54,849
send it in him

845
00:40:54,849 --> 00:40:56,500
send it everybody into a binding but

846
00:40:56,500 --> 00:40:58,810
first send that a mock message and then

847
00:40:58,810 --> 00:41:01,660
deserialize it on the other side the

848
00:41:01,660 --> 00:41:03,730
idea being to read out key value pairs

849
00:41:03,730 --> 00:41:06,280
of extremist dictionaries different

850
00:41:06,280 --> 00:41:08,980
things so it turns out that when you

851
00:41:08,980 --> 00:41:11,589
read the steriliser if you try to send a

852
00:41:11,589 --> 00:41:14,859
large serialized ecstasy message it will

853
00:41:14,859 --> 00:41:18,010
actually take the bulk of the data and

854
00:41:18,010 --> 00:41:19,900
send it in one of those out of line

855
00:41:19,900 --> 00:41:24,970
descriptors so this means that any of

856
00:41:24,970 --> 00:41:27,430
the XP CDC realization code could be a

857
00:41:27,430 --> 00:41:30,250
target to find an unexpected time of

858
00:41:30,250 --> 00:41:32,080
check time of use because remember these

859
00:41:32,080 --> 00:41:34,420
things aren't bugs these are just

860
00:41:34,420 --> 00:41:37,510
constructs that if you had a bug that

861
00:41:37,510 --> 00:41:40,270
enabled you to make shed memory where it

862
00:41:40,270 --> 00:41:41,800
shouldn't be the new all of these things

863
00:41:41,800 --> 00:41:45,010
become bugs but don't worry there and

864
00:41:45,010 --> 00:41:46,869
that's why none of them have been fixed

865
00:41:46,869 --> 00:41:49,930
because there's nothing to fix if you

866
00:41:49,930 --> 00:41:50,710
think that your

867
00:41:50,710 --> 00:41:52,150
we're going to create one of these

868
00:41:52,150 --> 00:41:56,830
situations again what's going on here

869
00:41:56,830 --> 00:42:00,160
but it's essentially our twelve is

870
00:42:00,160 --> 00:42:03,580
pointing into the descriptor into the

871
00:42:03,580 --> 00:42:05,740
amount of language is now shared what

872
00:42:05,740 --> 00:42:11,830
doing is drilling finding the X 29 to

873
00:42:11,830 --> 00:42:16,750
that value my lock and then getting some

874
00:42:16,750 --> 00:42:23,440
offset in gear and strike up in yeah

875
00:42:23,440 --> 00:42:26,109
that offset X 20 it's stripped copies

876
00:42:26,109 --> 00:42:29,170
from that buffer now this should be and

877
00:42:29,170 --> 00:42:32,440
so basically we only speak our here's

878
00:42:32,440 --> 00:42:36,070
that iOS version and you enjoy the x86

879
00:42:36,070 --> 00:42:37,980
version while it's still relevant

880
00:42:37,980 --> 00:42:43,230
because there this will die sweet

881
00:42:43,380 --> 00:42:47,290
yeah learn entity box and it's all here

882
00:42:47,290 --> 00:42:51,970
so we can also just use x-rays that's

883
00:42:51,970 --> 00:42:54,460
good I mean look at where the fields are

884
00:42:54,460 --> 00:42:56,619
mr. couple so here there's a double

885
00:42:56,619 --> 00:43:00,430
affection and since that if the memory

886
00:43:00,430 --> 00:43:04,240
quantity by this changes then stir copy

887
00:43:04,240 --> 00:43:06,970
is going to strike up the more than we

888
00:43:06,970 --> 00:43:10,859
my logs because this points in so now

889
00:43:10,859 --> 00:43:15,849
unexpectedly shared memory next second

890
00:43:15,849 --> 00:43:17,890
we have a few more in 30 seconds

891
00:43:17,890 --> 00:43:22,119
remaining so I can do maybe two minute

892
00:43:22,119 --> 00:43:23,950
30 second review of how that excellent

893
00:43:23,950 --> 00:43:28,119
actually works so we did crash serialize

894
00:43:28,119 --> 00:43:30,880
ecstasy dictionary that we're going to

895
00:43:30,880 --> 00:43:36,130
send to a tag our target and at the end

896
00:43:36,130 --> 00:43:39,160
of this we have this overlapping being

897
00:43:39,160 --> 00:43:42,040
that country so this first region thing

898
00:43:42,040 --> 00:43:47,109
gets into our target as a serialize the

899
00:43:47,109 --> 00:43:50,109
 object in this region it's gonna

900
00:43:50,109 --> 00:43:54,160
get sent to ourselves so we are going to

901
00:43:54,160 --> 00:43:57,520
end up being able to read and write the

902
00:43:57,520 --> 00:44:00,849
end of the series ecstasy dictionary

903
00:44:00,849 --> 00:44:05,390
while the target is positive

904
00:44:05,390 --> 00:44:08,579
so in the shared memory the structure

905
00:44:08,579 --> 00:44:14,039
very simply we have one byte which is

906
00:44:14,039 --> 00:44:17,309
the posting in null because in actually

907
00:44:17,309 --> 00:44:20,730
see dictionaries the keys which is what

908
00:44:20,730 --> 00:44:22,619
we are targeting for our overflow from

909
00:44:22,619 --> 00:44:26,130
tip that's extra Len malach Circle T are

910
00:44:26,130 --> 00:44:28,710
specially null-terminated so we have

911
00:44:28,710 --> 00:44:32,460
this flipper bite which in a loop we

912
00:44:32,460 --> 00:44:34,470
just really quickly flip between zero

913
00:44:34,470 --> 00:44:38,309
and nonzero the idea being that we're

914
00:44:38,309 --> 00:44:42,780
hoping that think about this right this

915
00:44:42,780 --> 00:44:46,140
strollin will see them null milah and

916
00:44:46,140 --> 00:44:48,329
then the strip copy will not see the

917
00:44:48,329 --> 00:44:53,280
null and so we'll copy after it so we

918
00:44:53,280 --> 00:44:54,990
hope that it gets mapped to be big

919
00:44:54,990 --> 00:44:58,740
enough to contain just this size have

920
00:44:58,740 --> 00:45:01,680
been the copy will have this whole size

921
00:45:01,680 --> 00:45:04,170
and so before that there is some kind of

922
00:45:04,170 --> 00:45:07,079
deep cream the idea being that we can

923
00:45:07,079 --> 00:45:08,760
make something interesting happen over

924
00:45:08,760 --> 00:45:12,660
there at 10 10 10 overview of the heat

925
00:45:12,660 --> 00:45:14,520
grew we're going to set up a structure

926
00:45:14,520 --> 00:45:18,450
on the heap such that the malloc for the

927
00:45:18,450 --> 00:45:22,380
short string fits inside this deck we're

928
00:45:22,380 --> 00:45:24,770
gonna create an heap which has before it

929
00:45:24,770 --> 00:45:29,670
well anywhere before it or after it an

930
00:45:29,670 --> 00:45:33,089
ecstacy array structure it's just after

931
00:45:33,089 --> 00:45:35,760
I undersized buffer it's in a big actual

932
00:45:35,760 --> 00:45:39,390
backing store for that array so that

933
00:45:39,390 --> 00:45:42,180
when we have our bad strip copy mr.

934
00:45:42,180 --> 00:45:45,510
copies but here into the first pointer

935
00:45:45,510 --> 00:45:49,650
in the ecstasy arrays the package movies

936
00:45:49,650 --> 00:45:51,510
that don't post afford the exploit the

937
00:45:51,510 --> 00:45:54,210
next thing isn't a lot more detail so

938
00:45:54,210 --> 00:45:56,520
then what we're going to do in the

939
00:45:56,520 --> 00:45:59,849
senator is just as fast as we can flip

940
00:45:59,849 --> 00:46:03,569
this between 0 1 0 and in the receiver

941
00:46:03,569 --> 00:46:06,539
we hope this is going to happen and if

942
00:46:06,539 --> 00:46:07,490
we're successful

943
00:46:07,490 --> 00:46:10,589
these are XB c object pointers and we're

944
00:46:10,589 --> 00:46:12,690
going to be able to correct the next pc

945
00:46:12,690 --> 00:46:16,250
object pointer and make something

946
00:46:16,520 --> 00:46:19,070
I think I will just skip over the 40

947
00:46:19,070 --> 00:46:32,060
authentication defeat essentially the

948
00:46:32,060 --> 00:46:35,330
high-level overview of the point of

949
00:46:35,330 --> 00:46:37,790
authentication defeat and I hesitate to

950
00:46:37,790 --> 00:46:39,650
call it a defeat because I don't think

951
00:46:39,650 --> 00:46:41,570
this is an intended attacker scenario

952
00:46:41,570 --> 00:46:44,570
for the for authentication you have to

953
00:46:44,570 --> 00:46:47,710
move sets of keys three sets of three

954
00:46:47,710 --> 00:46:50,000
versus two sets of keys we keep them

955
00:46:50,000 --> 00:46:54,050
used to tag pointers and you can tag

956
00:46:54,050 --> 00:46:55,790
whatever pointers you want using these

957
00:46:55,790 --> 00:46:58,760
key keys you have keys in this family

958
00:46:58,760 --> 00:47:01,820
like easing the be family even the be

959
00:47:01,820 --> 00:47:06,080
family are derived from the same traffic

960
00:47:06,080 --> 00:47:10,099
material for piecing in any families

961
00:47:10,099 --> 00:47:12,080
which are insane for graphical terror

962
00:47:12,080 --> 00:47:15,650
for all processes so I can create an

963
00:47:15,650 --> 00:47:17,900
authentication code in my low privileged

964
00:47:17,900 --> 00:47:20,930
user space process for a pointer that

965
00:47:20,930 --> 00:47:23,990
will be valid in a hive for different

966
00:47:23,990 --> 00:47:27,740
privileges for the eighties for the VP I

967
00:47:27,740 --> 00:47:29,480
can't do that because the keys are not

968
00:47:29,480 --> 00:47:34,820
shared so local pretty desolation pact

969
00:47:34,820 --> 00:47:37,220
defeat essentially really just means

970
00:47:37,220 --> 00:47:41,240
like you have to play the part but only

971
00:47:41,240 --> 00:47:44,540
uses pointers which are I can use this

972
00:47:44,540 --> 00:47:46,700
point at which are not educated or only

973
00:47:46,700 --> 00:47:48,230
uses functions which are authenticated

974
00:47:48,230 --> 00:47:51,200
with any family keys which in this

975
00:47:51,200 --> 00:47:54,020
little example here is this pack fires

976
00:47:54,020 --> 00:47:58,460
n/a uses instruction a key with zero

977
00:47:58,460 --> 00:48:01,220
contact family so that doesn't have a

978
00:48:01,220 --> 00:48:09,530
theory backed by a rather than something

979
00:48:09,530 --> 00:48:14,060
that uses beep and it turns out that

980
00:48:14,060 --> 00:48:15,500
it's not too difficult to find some

981
00:48:15,500 --> 00:48:19,490
concepts about them the only mine is a

982
00:48:19,490 --> 00:48:21,920
partner to see object pointer control to

983
00:48:21,920 --> 00:48:24,859
PC control without the BP and a whole

984
00:48:24,859 --> 00:48:27,050
other dog disarray of that server let's

985
00:48:27,050 --> 00:48:29,260
get rid of that I'm

986
00:48:29,260 --> 00:48:31,599
and for some final thoughts about what

987
00:48:31,599 --> 00:48:35,109
just happened so xnu virtual memory code

988
00:48:35,109 --> 00:48:39,099
is very old very very old

989
00:48:39,099 --> 00:48:42,070
I can't generate that I tried to show

990
00:48:42,070 --> 00:48:43,960
very little code but if you did look at

991
00:48:43,960 --> 00:48:45,670
some of the page when you scroll back to

992
00:48:45,670 --> 00:48:51,119
the copyright this is like 1985 so I

993
00:48:51,119 --> 00:48:53,109
discussed publicly many times before

994
00:48:53,109 --> 00:48:55,450
that Paris these are seriously legacy

995
00:48:55,450 --> 00:48:57,550
devices not because this is a 5x but

996
00:48:57,550 --> 00:49:02,920
even like the newer ones extreme legacy

997
00:49:02,920 --> 00:49:04,660
fundamental underlie all of the

998
00:49:04,660 --> 00:49:05,380
shininess

999
00:49:05,380 --> 00:49:09,250
well to me is very old it's really

1000
00:49:09,250 --> 00:49:11,470
horrific Lee complex this might just be

1001
00:49:11,470 --> 00:49:14,859
a necessary construct for a virtual

1002
00:49:14,859 --> 00:49:17,410
memory code but it's really really

1003
00:49:17,410 --> 00:49:20,079
really complicated and hard to read very

1004
00:49:20,079 --> 00:49:21,690
hard to read very hard to reason about

1005
00:49:21,690 --> 00:49:24,130
extremely keen on multi-thousand buying

1006
00:49:24,130 --> 00:49:26,859
functions with like 8 levels of nested

1007
00:49:26,859 --> 00:49:28,599
nests that halfway through just like to

1008
00:49:28,599 --> 00:49:30,700
call themselves again with other flags

1009
00:49:30,700 --> 00:49:33,000
like it's really hard to read and

1010
00:49:33,000 --> 00:49:36,540
critical than every security boundary

1011
00:49:36,540 --> 00:49:40,480
swing decades if anyone understood it ok

1012
00:49:40,480 --> 00:49:43,660
this isn't well is it the kind of folks

1013
00:49:43,660 --> 00:49:45,040
would have almost certainly in bed this

1014
00:49:45,040 --> 00:49:47,200
is definitely low hanging fruit ie it's

1015
00:49:47,200 --> 00:49:51,700
quite easy to come up with here is some

1016
00:49:51,700 --> 00:49:54,130
security guarantee I this move must be

1017
00:49:54,130 --> 00:49:57,010
atomic let's break it find someplace

1018
00:49:57,010 --> 00:49:59,589
that they unlock the map and then try

1019
00:49:59,589 --> 00:50:02,500
and do that well that's unlocked yes so

1020
00:50:02,500 --> 00:50:04,180
you feel free to prove me wrong if you

1021
00:50:04,180 --> 00:50:05,740
understand the whole thing or if you're

1022
00:50:05,740 --> 00:50:07,810
watching the live stream and like are

1023
00:50:07,810 --> 00:50:11,010
the dev wrote this in 1985

1024
00:50:11,010 --> 00:50:12,880
like do you have some things I'd like

1025
00:50:12,880 --> 00:50:18,369
you to explain I'm finding finding the

1026
00:50:18,369 --> 00:50:20,349
remaining or finding the better bugs

1027
00:50:20,349 --> 00:50:24,880
it requires understanding okay now I'm

1028
00:50:24,880 --> 00:50:26,980
gonna other small branch yes you can

1029
00:50:26,980 --> 00:50:28,390
still make a million dollars grepping

1030
00:50:28,390 --> 00:50:30,790
from n copy in iOS and you definitely

1031
00:50:30,790 --> 00:50:34,480
can but virtual memory bugs are more

1032
00:50:34,480 --> 00:50:36,550
complicated than just correcting for

1033
00:50:36,550 --> 00:50:40,450
knowing bad functions okay if it wasn't

1034
00:50:40,450 --> 00:50:41,770
men copy it was a memory

1035
00:50:41,770 --> 00:50:44,590
so maybe they're like apples and grep

1036
00:50:44,590 --> 00:50:46,470
mr. the wrong thing

1037
00:50:46,470 --> 00:50:52,030
yes who refused to be that these suckled

1038
00:50:52,030 --> 00:50:52,930
memory box

1039
00:50:52,930 --> 00:50:55,240
I like you to make for a very long time

1040
00:50:55,240 --> 00:50:58,450
trust your mom luxury 999 all the

1041
00:50:58,450 --> 00:51:00,940
devices going here that was some quick

1042
00:51:00,940 --> 00:51:05,680
well every budget equation confirm that

1043
00:51:05,680 --> 00:51:08,260
quake agree three weeks ago second we

1044
00:51:08,260 --> 00:51:11,260
don't know and luxury devices so I'm

1045
00:51:11,260 --> 00:51:14,140
assistant thank you to Objective C for

1046
00:51:14,140 --> 00:51:16,030
this awesome conference and especially

1047
00:51:16,030 --> 00:51:18,960
to Jonathan Levin and Amit Singh who

1048
00:51:18,960 --> 00:51:22,090
without they're very helpful books they

1049
00:51:22,090 --> 00:51:27,540
sort of walk impossible yeah thank you

