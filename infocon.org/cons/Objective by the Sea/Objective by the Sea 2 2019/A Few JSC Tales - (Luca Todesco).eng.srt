1
00:00:03,550 --> 00:00:08,379
and I knew Calista aka QWERTY or you IOP

2
00:00:08,379 --> 00:00:10,990
and you can finally I'm being an IRC

3
00:00:10,990 --> 00:00:13,869
that cracks by up came in channel chat

4
00:00:13,869 --> 00:00:17,699
or on Twitter at 30 or you I opt and

5
00:00:17,699 --> 00:00:20,200
yeah I've been doing the planet security

6
00:00:20,200 --> 00:00:23,230
research for two years now I own my own

7
00:00:23,230 --> 00:00:27,280
company and supreme leader pages

8
00:00:27,280 --> 00:00:30,610
international research srl most of my

9
00:00:30,610 --> 00:00:31,750
research has been in the creeper

10
00:00:31,750 --> 00:00:34,449
distillation part of things but nowadays

11
00:00:34,449 --> 00:00:36,730
I mostly focus on browser exploitation

12
00:00:36,730 --> 00:00:39,250
and right now my main target is not

13
00:00:39,250 --> 00:00:42,430
required and this book will go to why

14
00:00:42,430 --> 00:00:44,100
that's the case

15
00:00:44,100 --> 00:00:47,050
and so yes this book is about a

16
00:00:47,050 --> 00:00:49,630
fictional character that is trying to

17
00:00:49,630 --> 00:00:51,880
get to destitution on the latest iOS

18
00:00:51,880 --> 00:00:55,600
updates again all these also applies to

19
00:00:55,600 --> 00:00:59,020
make us and our diction chapter began by

20
00:00:59,020 --> 00:01:02,260
exploiting the music there freeze back

21
00:01:02,260 --> 00:01:06,189
when the hips are very still pack but

22
00:01:06,189 --> 00:01:08,740
now more and more litigations at the

23
00:01:08,740 --> 00:01:11,259
England by echo and so we need a fresh

24
00:01:11,259 --> 00:01:15,159
start and the JavaScript or JIT compiler

25
00:01:15,159 --> 00:01:17,770
sing a very good target for something

26
00:01:17,770 --> 00:01:19,319
that would resist and would be

27
00:01:19,319 --> 00:01:23,700
exploitable still even many patrons turn

28
00:01:23,700 --> 00:01:27,549
however obviously more and more features

29
00:01:27,549 --> 00:01:30,399
are being added and so the battle is

30
00:01:30,399 --> 00:01:34,299
still going on and so what is what keep

31
00:01:34,299 --> 00:01:36,759
it well it's apples open source web

32
00:01:36,759 --> 00:01:39,729
browser it powers to about sapphire na

33
00:01:39,729 --> 00:01:42,609
us and so far in my quest I'm Joseph

34
00:01:42,609 --> 00:01:44,889
powers has lost web browser as well as

35
00:01:44,889 --> 00:01:48,759
the ps4 one and it's actually multiple

36
00:01:48,759 --> 00:01:51,999
projects the most important of which are

37
00:01:51,999 --> 00:01:54,579
web for javascript file and that with

38
00:01:54,579 --> 00:01:55,149
yeah

39
00:01:55,149 --> 00:01:59,200
and specifically I'm gonna start

40
00:01:59,200 --> 00:02:02,709
discussing web / which is where our

41
00:02:02,709 --> 00:02:06,329
teacher instructor started history firm

42
00:02:06,329 --> 00:02:09,788
and yes what kurt imel's HTML parsing

43
00:02:09,788 --> 00:02:14,770
the SVG CSS and a lot of the remote

44
00:02:14,770 --> 00:02:15,290
codes

45
00:02:15,290 --> 00:02:17,150
oceans that have been seen in a while

46
00:02:17,150 --> 00:02:21,560
have been bombed either freeze the

47
00:02:21,560 --> 00:02:23,950
reason for this is the Coliseum worker

48
00:02:23,950 --> 00:02:26,689
many many use of their freezer present

49
00:02:26,689 --> 00:02:30,560
look the reference camping nature of the

50
00:02:30,560 --> 00:02:34,340
particulars last one time and yes down

51
00:02:34,340 --> 00:02:36,739
is also very dynamic and so it's very

52
00:02:36,739 --> 00:02:38,870
very easy to run into object life

53
00:02:38,870 --> 00:02:42,019
vanishes so I'm gonna show you an

54
00:02:42,019 --> 00:02:45,109
example of a typical gun bag with some

55
00:02:45,109 --> 00:02:48,609
random bug pulled out of project zero

56
00:02:48,609 --> 00:02:51,290
and we can see that at some point here

57
00:02:51,290 --> 00:02:55,069
we get a pointer to Lancet however no

58
00:02:55,069 --> 00:02:59,239
reference whatsoever is taken and after

59
00:02:59,239 --> 00:03:01,579
a while we run some function which

60
00:03:01,579 --> 00:03:03,799
happens to be able to trigger just go

61
00:03:03,799 --> 00:03:09,290
back and when that happens if you look

62
00:03:09,290 --> 00:03:12,530
at the report of concept code we have

63
00:03:12,530 --> 00:03:16,849
two night handlers and one of them the

64
00:03:16,849 --> 00:03:18,729
selector start running event handler to

65
00:03:18,729 --> 00:03:22,090
actually enters our vulnerable function

66
00:03:22,090 --> 00:03:25,479
and again is my trigger doesn't go back

67
00:03:25,479 --> 00:03:30,079
specifically event handler one which

68
00:03:30,079 --> 00:03:34,760
will change the type of the object which

69
00:03:34,760 --> 00:03:37,280
will invoke this function which actually

70
00:03:37,280 --> 00:03:41,449
ends up freeing the inner text element

71
00:03:41,449 --> 00:03:46,099
object and if we look back in your text

72
00:03:46,099 --> 00:03:48,409
object is a pointer that we have in our

73
00:03:48,409 --> 00:03:51,199
stack frame then we say taking a

74
00:03:51,199 --> 00:03:55,879
reference and so this is sort of the

75
00:03:55,879 --> 00:03:58,189
scenario that happens and any use of

76
00:03:58,189 --> 00:04:04,010
inner text after Kobach has run will be

77
00:04:04,010 --> 00:04:08,810
a user users are free and so yes most

78
00:04:08,810 --> 00:04:11,949
downloads shared this common theme

79
00:04:11,949 --> 00:04:15,970
record to some object is sterling stack

80
00:04:15,970 --> 00:04:18,560
but the reference count is not increased

81
00:04:18,560 --> 00:04:23,270
a tactical bike is able to execute

82
00:04:23,270 --> 00:04:26,120
referee's of such an object prisoner

83
00:04:26,120 --> 00:04:30,289
totally free and upon return use after

84
00:04:30,289 --> 00:04:33,590
free happens again it's really important

85
00:04:33,590 --> 00:04:35,449
to note that reference counted object

86
00:04:35,449 --> 00:04:37,400
here with a keyword there are other

87
00:04:37,400 --> 00:04:40,310
browsers like chrome or edge that do not

88
00:04:40,310 --> 00:04:42,199
use reference counted objects for the

89
00:04:42,199 --> 00:04:47,240
Dom who which are more harmless than web

90
00:04:47,240 --> 00:04:52,370
/ - these circuit attacks and back you

91
00:04:52,370 --> 00:04:55,580
that you could just use the fast man

92
00:04:55,580 --> 00:04:57,949
load a locator for most of those objects

93
00:04:57,949 --> 00:05:02,300
and other than that you will also have a

94
00:05:02,300 --> 00:05:04,340
right bastard packing butter to living

95
00:05:04,340 --> 00:05:07,280
in the fast novelty and those parts are

96
00:05:07,280 --> 00:05:09,470
really convenient replacement because

97
00:05:09,470 --> 00:05:12,650
they allow you to get to read write

98
00:05:12,650 --> 00:05:16,039
access to complete junk from JavaScript

99
00:05:16,039 --> 00:05:19,759
and the standard way of pulling it off

100
00:05:19,759 --> 00:05:22,159
is to replace the freed object with a

101
00:05:22,159 --> 00:05:25,009
narrow gap verb a conductor replace to

102
00:05:25,009 --> 00:05:27,469
be able pointer and you get Araki

103
00:05:27,469 --> 00:05:31,280
control but this will require a prior in

104
00:05:31,280 --> 00:05:36,590
Foley easily and so actually I analyzed

105
00:05:36,590 --> 00:05:38,810
the epoch further and I realize that

106
00:05:38,810 --> 00:05:41,240
sometimes the use after free can

107
00:05:41,240 --> 00:05:42,800
actually leave a dangling pointer to

108
00:05:42,800 --> 00:05:45,710
some C++ object inside some other C++

109
00:05:45,710 --> 00:05:48,289
object and this pointer might actually

110
00:05:48,289 --> 00:05:50,509
represent that Dom object that you can

111
00:05:50,509 --> 00:05:52,430
actually export into the dynastic world

112
00:05:52,430 --> 00:05:55,789
and when you do that what recommends a

113
00:05:55,789 --> 00:05:59,590
Bradford thing that essentially

114
00:05:59,590 --> 00:06:02,000
represents the sequester's object within

115
00:06:02,000 --> 00:06:05,599
the Devastator your emotions and each of

116
00:06:05,599 --> 00:06:08,930
these raptor will have one-to-one

117
00:06:08,930 --> 00:06:11,030
mapping so one object only has one

118
00:06:11,030 --> 00:06:13,639
Raptor and its cash in line in this plus

119
00:06:13,639 --> 00:06:17,120
plus object so the conversion function

120
00:06:17,120 --> 00:06:21,020
which is handled like to say yes can

121
00:06:21,020 --> 00:06:25,639
actually read the data spectrally from

122
00:06:25,639 --> 00:06:28,909
the freed C++ object and return it in

123
00:06:28,909 --> 00:06:31,849
toward a SMG and we can pair down box

124
00:06:31,849 --> 00:06:35,650
into traffic engine box like this

125
00:06:36,230 --> 00:06:39,410
further you can also leave that with

126
00:06:39,410 --> 00:06:41,410
values in many instances at least

127
00:06:41,410 --> 00:06:44,660
because north argument factor objects

128
00:06:44,660 --> 00:06:48,350
used by the p.m. also used being fast

129
00:06:48,350 --> 00:06:51,770
mallet and three batters could also be

130
00:06:51,770 --> 00:06:54,050
in fast mallet and so if you were able

131
00:06:54,050 --> 00:06:56,720
to leak a string object pointer and

132
00:06:56,720 --> 00:06:58,580
correct the length to it you could

133
00:06:58,580 --> 00:07:00,590
actually leak from the past dialogue tip

134
00:07:00,590 --> 00:07:03,140
and that 15 marked argument but for next

135
00:07:03,140 --> 00:07:05,180
door swim after you could leak Avatar

136
00:07:05,180 --> 00:07:07,250
Jays famous and so you can get

137
00:07:07,250 --> 00:07:09,970
JavaScript object pointer top of it and

138
00:07:09,970 --> 00:07:12,710
actually these condition seems unlikely

139
00:07:12,710 --> 00:07:16,160
to be viable to do but many many dumb

140
00:07:16,160 --> 00:07:19,010
objects allow you to leak pointers once

141
00:07:19,010 --> 00:07:23,120
you replace them with our adapter and as

142
00:07:23,120 --> 00:07:26,600
well as increase arbitrarily a control

143
00:07:26,600 --> 00:07:29,570
pointer and I actually did this for a

144
00:07:29,570 --> 00:07:32,360
part don't have a you are AF agonist

145
00:07:32,360 --> 00:07:36,890
HTML document and once you have to

146
00:07:36,890 --> 00:07:39,860
believe to lick object and create a fake

147
00:07:39,860 --> 00:07:42,380
one there is a bit is very nice

148
00:07:42,380 --> 00:07:44,090
technique introduced by following this

149
00:07:44,090 --> 00:07:46,580
practical where if you just create a

150
00:07:46,580 --> 00:07:49,040
fake test object that we presented at a

151
00:07:49,040 --> 00:07:51,530
club right and by just you know putting

152
00:07:51,530 --> 00:07:54,110
a control back in back here planetary

153
00:07:54,110 --> 00:07:56,840
there you can dress pants and a dress

154
00:07:56,840 --> 00:07:58,910
and have fooled with white primitives

155
00:07:58,910 --> 00:08:00,740
from within JavaScript and this was

156
00:08:00,740 --> 00:08:03,200
really really easy to pull off and was a

157
00:08:03,200 --> 00:08:06,890
really really powerful primitive and

158
00:08:06,890 --> 00:08:10,300
once you had a grip right from abilities

159
00:08:10,300 --> 00:08:13,010
you'll be able to just right inside the

160
00:08:13,010 --> 00:08:15,860
JIT area which is nice and sweet right

161
00:08:15,860 --> 00:08:17,600
execute

162
00:08:17,600 --> 00:08:20,000
iOS specifically has menkaure code

163
00:08:20,000 --> 00:08:21,980
signing but these actually bypass sista

164
00:08:21,980 --> 00:08:24,320
and yes okay I'm gonna tech that ready

165
00:08:24,320 --> 00:08:26,390
and just right into it and they would

166
00:08:26,390 --> 00:08:30,260
code excretion however and this is the

167
00:08:30,260 --> 00:08:32,330
CP by the way on that classification is

168
00:08:32,330 --> 00:08:34,669
not present the previous slide actually

169
00:08:34,669 --> 00:08:38,210
still works just fine like us on our us

170
00:08:38,210 --> 00:08:40,580
the heart and widget mapping by

171
00:08:40,580 --> 00:08:42,219
separated into three different regions

172
00:08:42,219 --> 00:08:45,380
which is executable and the other is

173
00:08:45,380 --> 00:08:48,709
writable and the context regrettable

174
00:08:48,709 --> 00:08:53,029
map is only a doctor instead of execute

175
00:08:53,029 --> 00:08:55,519
only piece of code so in order to be

176
00:08:55,519 --> 00:08:59,089
able to access the writable nap you are

177
00:08:59,089 --> 00:09:02,930
first go into that function and this

178
00:09:02,930 --> 00:09:05,839
means a right and your creative is now

179
00:09:05,839 --> 00:09:07,699
sufficient for code execution anymore

180
00:09:07,699 --> 00:09:10,369
and we must use wrap or other techniques

181
00:09:10,369 --> 00:09:13,429
in orbit people said function and yes I

182
00:09:13,429 --> 00:09:16,309
mean it does make it harder to exploit

183
00:09:16,309 --> 00:09:20,329
what keep bugs but not by that much but

184
00:09:20,329 --> 00:09:22,059
still I mean it's pretty sad because

185
00:09:22,059 --> 00:09:25,759
radically disease could be that I am

186
00:09:25,759 --> 00:09:27,379
correct particularly that's not the case

187
00:09:27,379 --> 00:09:30,319
for any device other than I can access

188
00:09:30,319 --> 00:09:32,089
and if not the case for not class

189
00:09:32,089 --> 00:09:35,529
because this is nothing at all

190
00:09:35,529 --> 00:09:38,089
additionally field people or convenient

191
00:09:38,089 --> 00:09:44,179
hangars at what it decided that the tak

192
00:09:44,179 --> 00:09:46,850
array objects and butterflies will be

193
00:09:46,850 --> 00:09:49,069
put in a gear cage which are like a very

194
00:09:49,069 --> 00:09:51,079
large amount of memory that is reserved

195
00:09:51,079 --> 00:09:54,319
only for those and any access read and

196
00:09:54,319 --> 00:09:57,709
write to one of those objects will be

197
00:09:57,709 --> 00:10:01,999
masked so you will or in the bits of PDF

198
00:10:01,999 --> 00:10:05,689
page and so even if you have great

199
00:10:05,689 --> 00:10:07,699
bright and yet one for the vacuum after

200
00:10:07,699 --> 00:10:11,149
that's I mean within an even bigger here

201
00:10:11,149 --> 00:10:14,050
pillage and so this technique is that

202
00:10:14,050 --> 00:10:17,660
again yes only to be a page memory and

203
00:10:17,660 --> 00:10:20,749
butterfly parameters also are caged but

204
00:10:20,749 --> 00:10:23,089
these are alerted which means that we

205
00:10:23,089 --> 00:10:25,189
can actually use butterfly accesses to

206
00:10:25,189 --> 00:10:28,100
gain in the bright steel so every is not

207
00:10:28,100 --> 00:10:30,470
fully controlled but it's still good

208
00:10:30,470 --> 00:10:33,350
enough for most scenarios and Nicolas

209
00:10:33,350 --> 00:10:35,360
Lee actually use this for public eye

210
00:10:35,360 --> 00:10:41,389
from 830 exploit and at some point funny

211
00:10:41,389 --> 00:10:44,059
third poisoning was also used which if I

212
00:10:44,059 --> 00:10:46,160
remember correctly was the stack for

213
00:10:46,160 --> 00:10:48,889
mitigation but it was removed with this

214
00:10:48,889 --> 00:10:50,720
commit and actually I remembered seeing

215
00:10:50,720 --> 00:10:54,350
other to make saying kill it in fire so

216
00:10:54,350 --> 00:10:56,360
I think they were not happy about that

217
00:10:56,360 --> 00:11:01,610
and we just got rid of it initially

218
00:11:01,610 --> 00:11:02,720
machine yet

219
00:11:02,720 --> 00:11:05,600
and these commute is really interesting

220
00:11:05,600 --> 00:11:10,310
to me because they should start furnace

221
00:11:10,310 --> 00:11:19,430
light which means a SLR and yes if you

222
00:11:19,430 --> 00:11:21,200
look at the dates that's mean a year and

223
00:11:21,200 --> 00:11:24,790
a half so for one and a half years the

224
00:11:24,790 --> 00:11:26,810
organization was completely working on

225
00:11:26,810 --> 00:11:32,269
both iOS and Mac OS additionally another

226
00:11:32,269 --> 00:11:34,720
mitigation that was introduced a

227
00:11:34,720 --> 00:11:38,149
separated heaps so every given of the

228
00:11:38,149 --> 00:11:41,149
type in C++ is allocated to its own

229
00:11:41,149 --> 00:11:43,010
sheep and you're not able to confuse

230
00:11:43,010 --> 00:11:45,050
things anywhere so you need to found an

231
00:11:45,050 --> 00:11:47,149
object that's kind of like air enough

232
00:11:47,149 --> 00:11:49,430
reflecting back first still living in

233
00:11:49,430 --> 00:11:51,529
class now look you're still not be able

234
00:11:51,529 --> 00:11:52,930
to use that free place

235
00:11:52,930 --> 00:11:57,620
Sigler's past bump object and so things

236
00:11:57,620 --> 00:12:00,200
get quite tricky here because yes this

237
00:12:00,200 --> 00:12:02,810
prevents years after three bugs from

238
00:12:02,810 --> 00:12:06,800
being exploited in most scenarios and so

239
00:12:06,800 --> 00:12:08,300
theoretically the backpack system

240
00:12:08,300 --> 00:12:11,779
repaired which it's not really true

241
00:12:11,779 --> 00:12:14,779
because you can still exploit some of

242
00:12:14,779 --> 00:12:17,209
the exotic fish but it seems really

243
00:12:17,209 --> 00:12:18,769
difficult to actually pull it out still

244
00:12:18,769 --> 00:12:21,050
and it seems like it's more trouble than

245
00:12:21,050 --> 00:12:23,290
it's worth to keep pressure on it so

246
00:12:23,290 --> 00:12:26,269
have to start again from scratch from

247
00:12:26,269 --> 00:12:30,050
the very basics and this camera focus

248
00:12:30,050 --> 00:12:32,600
and does the curve which is the

249
00:12:32,600 --> 00:12:34,220
JavaScript engine still you develop it

250
00:12:34,220 --> 00:12:38,120
and so my hands work the previous

251
00:12:38,120 --> 00:12:40,699
problem is to just shift the purchase

252
00:12:40,699 --> 00:12:43,640
and the new abilities and I'm going to

253
00:12:43,640 --> 00:12:46,430
show you an example of what that means

254
00:12:46,430 --> 00:12:49,220
and exploitation one of those abilities

255
00:12:49,220 --> 00:12:54,370
which is particularly good and so

256
00:12:54,370 --> 00:12:55,519
javascriptcore

257
00:12:55,519 --> 00:12:58,430
again with elastic ended it has an

258
00:12:58,430 --> 00:13:00,470
interpreter called a lowland and

259
00:13:00,470 --> 00:13:01,940
multiple deities

260
00:13:01,940 --> 00:13:05,180
it's JIT has different properties as

261
00:13:05,180 --> 00:13:07,870
arts compile-time and verticals and

262
00:13:07,870 --> 00:13:10,640
Bayesian how many times are functions

263
00:13:10,640 --> 00:13:12,880
involved we will move for

264
00:13:12,880 --> 00:13:14,740
first interpreter and that the place I'm

265
00:13:14,740 --> 00:13:18,069
going to be fgg went to the FDA object

266
00:13:18,069 --> 00:13:20,620
and every time you go all over the

267
00:13:20,620 --> 00:13:22,600
optimize your code more and more in

268
00:13:22,600 --> 00:13:28,660
native machine code and so we get to our

269
00:13:28,660 --> 00:13:31,389
bug these web was it released fairly

270
00:13:31,389 --> 00:13:34,449
recently every 2019 and it's a register

271
00:13:34,449 --> 00:13:38,649
allocator bug in the fgg compiler it

272
00:13:38,649 --> 00:13:40,360
actually resides in the string that

273
00:13:40,360 --> 00:13:43,199
protected slice jet implementation and

274
00:13:43,199 --> 00:13:47,350
this is introduced as a result of the

275
00:13:47,350 --> 00:13:49,420
Delacorte team trying to shrink the

276
00:13:49,420 --> 00:13:52,480
object size of a string from I think 24

277
00:13:52,480 --> 00:13:55,930
points to 16 so they introduced that

278
00:13:55,930 --> 00:13:57,819
order between a code execution for a

279
00:13:57,819 --> 00:14:01,569
marginal gain in memory consumption and

280
00:14:01,569 --> 00:14:04,060
this bug was found by billet Heath and

281
00:14:04,060 --> 00:14:07,000
direct science only thanks to him for

282
00:14:07,000 --> 00:14:10,569
this and the debug level curve looks

283
00:14:10,569 --> 00:14:14,110
like this is calling the JIT I will be

284
00:14:14,110 --> 00:14:16,750
executed when a function contains a

285
00:14:16,750 --> 00:14:19,029
string slice operation and these will

286
00:14:19,029 --> 00:14:21,610
admit to the making a native machine

287
00:14:21,610 --> 00:14:25,600
code for a specific operation and one

288
00:14:25,600 --> 00:14:27,399
thing to note here is that we have a

289
00:14:27,399 --> 00:14:33,040
conditional branch right there and after

290
00:14:33,040 --> 00:14:37,329
that we have a register allocation but

291
00:14:37,329 --> 00:14:39,279
what is a register location

292
00:14:39,279 --> 00:14:42,639
why is even needed well the JIT code

293
00:14:42,639 --> 00:14:45,490
needs to use register in order for logic

294
00:14:45,490 --> 00:14:47,680
on that native machine all the time and

295
00:14:47,680 --> 00:14:50,829
registers are included research and so

296
00:14:50,829 --> 00:14:52,240
you need to have some sort of algorithm

297
00:14:52,240 --> 00:14:54,699
that fast science registers and I'm

298
00:14:54,699 --> 00:14:56,649
equally and if you run out of registers

299
00:14:56,649 --> 00:14:58,829
you need to scale them to the stack and

300
00:14:58,829 --> 00:15:01,089
when you need them again you have to

301
00:15:01,089 --> 00:15:05,310
fetch them from the stack again and

302
00:15:05,310 --> 00:15:09,250
again we have a register location right

303
00:15:09,250 --> 00:15:11,620
there and potentially we fill those

304
00:15:11,620 --> 00:15:14,009
values to the stack

305
00:15:14,009 --> 00:15:16,990
but we have a conditional branch that's

306
00:15:16,990 --> 00:15:21,880
affirm that and this branch is taken not

307
00:15:21,880 --> 00:15:23,250
like old code

308
00:15:23,250 --> 00:15:29,010
grunting which is kind of an issue

309
00:15:29,010 --> 00:15:31,170
because the greatest a rotator actually

310
00:15:31,170 --> 00:15:33,060
assumes that all elevations have been

311
00:15:33,060 --> 00:15:35,430
unconditionally and the conditional

312
00:15:35,430 --> 00:15:37,590
branch can city allocation and the spill

313
00:15:37,590 --> 00:15:40,110
and if the variable corresponding these

314
00:15:40,110 --> 00:15:42,360
supposedly spilled register is later

315
00:15:42,360 --> 00:15:47,330
used initialize that data as a massage

316
00:15:48,110 --> 00:15:50,580
another thing what does occur is that

317
00:15:50,580 --> 00:15:52,290
unlike locker

318
00:15:52,290 --> 00:15:55,170
it makes heavy use of garbage collection

319
00:15:55,170 --> 00:16:00,390
and most objects on in that super almost

320
00:16:00,390 --> 00:16:04,050
all of them are collected and the GC is

321
00:16:04,050 --> 00:16:06,300
conservative on the stack which means

322
00:16:06,300 --> 00:16:08,700
that once you enter the GC you will

323
00:16:08,700 --> 00:16:11,190
actually mark from the top of the stack

324
00:16:11,190 --> 00:16:14,630
all the way the current stack frame and

325
00:16:14,630 --> 00:16:17,280
what another thing to note is the way

326
00:16:17,280 --> 00:16:19,080
kula function the variable number of

327
00:16:19,080 --> 00:16:21,540
arguments you can create very large

328
00:16:21,540 --> 00:16:24,330
stack frames and by doing these you can

329
00:16:24,330 --> 00:16:26,130
actually store some value very deep into

330
00:16:26,130 --> 00:16:28,980
the stack and when the garbage collector

331
00:16:28,980 --> 00:16:31,650
Browns those values will still be kept

332
00:16:31,650 --> 00:16:32,070
there

333
00:16:32,070 --> 00:16:34,800
but the garbage collector is not gonna

334
00:16:34,800 --> 00:16:37,339
be aware that those values are still

335
00:16:37,339 --> 00:16:40,170
potentially it was circling the iron

336
00:16:40,170 --> 00:16:42,839
it's just random garbage left over from

337
00:16:42,839 --> 00:16:44,490
the stack that should be initialized

338
00:16:44,490 --> 00:16:47,760
later on and all the objects will be

339
00:16:47,760 --> 00:16:51,600
free and so again with our pub we can

340
00:16:51,600 --> 00:16:53,850
actually end up having uninitialized

341
00:16:53,850 --> 00:16:58,860
stack data used as a suggestive marble

342
00:16:58,860 --> 00:17:00,930
or some register that was being used but

343
00:17:00,930 --> 00:17:03,620
that's engine at that point in time

344
00:17:03,620 --> 00:17:07,160
which means that we can bring some value

345
00:17:07,160 --> 00:17:10,140
deep into the stack and so now market

346
00:17:10,140 --> 00:17:11,910
garbage collector back to life

347
00:17:11,910 --> 00:17:14,880
and this gives us you need either for

348
00:17:14,880 --> 00:17:18,060
free in the dalvik code and this is

349
00:17:18,060 --> 00:17:19,699
actually good enough with that

350
00:17:19,699 --> 00:17:23,130
felicitations but it's not when we

351
00:17:23,130 --> 00:17:25,859
better reliable we need to rely on the

352
00:17:25,859 --> 00:17:29,160
heap layout and the garbage collector

353
00:17:29,160 --> 00:17:32,310
run language I mean you can do with very

354
00:17:32,310 --> 00:17:35,710
good reliability but it's not as cool as

355
00:17:35,710 --> 00:17:39,340
don't even when he said and so again the

356
00:17:39,340 --> 00:17:44,169
JIT will say have a variable in register

357
00:17:44,169 --> 00:17:47,399
and we'll put it on the staff but

358
00:17:47,399 --> 00:17:49,840
actually the branch will skip a foot and

359
00:17:49,840 --> 00:17:51,549
it's gonna be initialized track data

360
00:17:51,549 --> 00:17:53,980
however further accesses to that

361
00:17:53,980 --> 00:17:56,710
variable will still be interpreted as

362
00:17:56,710 --> 00:17:59,740
being of that specific type and we can

363
00:17:59,740 --> 00:18:01,779
actually supply the ducks with value of

364
00:18:01,779 --> 00:18:05,580
any other type via the initial I stack

365
00:18:05,580 --> 00:18:08,710
region and that results in type

366
00:18:08,710 --> 00:18:12,940
confusion and so here so exploitation of

367
00:18:12,940 --> 00:18:17,200
such a bug looks like so this is a

368
00:18:17,200 --> 00:18:21,520
function which is gonna be run 10,000

369
00:18:21,520 --> 00:18:23,890
times and after you do that it's only

370
00:18:23,890 --> 00:18:27,279
compatibility SGG and this function

371
00:18:27,279 --> 00:18:28,600
believes I declare in a bunch of

372
00:18:28,600 --> 00:18:31,990
variables and Norway and then it's going

373
00:18:31,990 --> 00:18:34,690
to a lot of access system are try and

374
00:18:34,690 --> 00:18:36,460
every time you do one of those accesses

375
00:18:36,460 --> 00:18:39,789
the stack frame is a large by 8 and by

376
00:18:39,789 --> 00:18:42,850
you this in order to have some space in

377
00:18:42,850 --> 00:18:45,330
case some other code happens to run and

378
00:18:45,330 --> 00:18:47,590
potentially overwrite the value that I

379
00:18:47,590 --> 00:18:53,159
carefully could intersect beforehand and

380
00:18:53,159 --> 00:18:55,809
afterwards we will fetch from the

381
00:18:55,809 --> 00:18:59,590
arguments the value air i1 and we will

382
00:18:59,590 --> 00:19:01,600
put it inside another just object and

383
00:19:01,600 --> 00:19:05,230
when you do this actually the JIT will

384
00:19:05,230 --> 00:19:07,480
have to prove the type of the object in

385
00:19:07,480 --> 00:19:12,190
order to perform infer types and so it

386
00:19:12,190 --> 00:19:18,700
will insert an JIT node they will prove

387
00:19:18,700 --> 00:19:22,090
the objects type in this case I will

388
00:19:22,090 --> 00:19:23,830
compile the function at work there are

389
00:19:23,830 --> 00:19:28,710
only 10,000 times with an unlocked cell

390
00:19:28,710 --> 00:19:34,390
and if you see the earlier I want a view

391
00:19:34,390 --> 00:19:39,630
that can be stored in either side and

392
00:19:39,630 --> 00:19:42,159
then we get to our gullible function

393
00:19:42,159 --> 00:19:45,490
called are vulnerable node and we can

394
00:19:45,490 --> 00:19:46,700
see that we have our

395
00:19:46,700 --> 00:19:49,430
initial jump the jmz right there and

396
00:19:49,430 --> 00:19:52,100
then have the register spilled breaks

397
00:19:52,100 --> 00:19:56,300
and eros I just follow me and of course

398
00:19:56,300 --> 00:19:58,070
I mean if you look at the disassembly

399
00:19:58,070 --> 00:19:59,960
it's really clear what's happening here

400
00:19:59,960 --> 00:20:02,420
the branch actually will skip the

401
00:20:02,420 --> 00:20:04,400
location but will not bail out from the

402
00:20:04,400 --> 00:20:05,450
jig

403
00:20:05,450 --> 00:20:07,610
I said yellow the artist or location and

404
00:20:07,610 --> 00:20:13,490
the spilling never happens following

405
00:20:13,490 --> 00:20:16,730
that we access there I won through the

406
00:20:16,730 --> 00:20:19,910
reference from the object created and we

407
00:20:19,910 --> 00:20:21,620
pass that value to a cold-drink

408
00:20:21,620 --> 00:20:24,080
instructor node and the coaster

409
00:20:24,080 --> 00:20:25,790
constructor Minerva will convert an

410
00:20:25,790 --> 00:20:30,370
object to a string and when you do that

411
00:20:30,370 --> 00:20:34,120
he will type it specifically do not sell

412
00:20:34,120 --> 00:20:36,770
and again we can make a jig thing with a

413
00:20:36,770 --> 00:20:39,950
variable containing some value is for

414
00:20:39,950 --> 00:20:41,630
its specific point in a stack frame but

415
00:20:41,630 --> 00:20:44,060
it isn't and the variable we can prove

416
00:20:44,060 --> 00:20:47,110
to be the value of not cell height and

417
00:20:47,110 --> 00:20:51,380
the proof is for the value which is not

418
00:20:51,380 --> 00:20:54,110
safe to the stack so we have a tactic

419
00:20:54,110 --> 00:20:56,660
check them to use issue here as the

420
00:20:56,660 --> 00:20:58,460
wrong values that we use when accessing

421
00:20:58,460 --> 00:21:02,860
the variable and so we go back to our

422
00:21:02,860 --> 00:21:06,050
get code and the coaster in constructor

423
00:21:06,050 --> 00:21:08,390
know you will again know that the

424
00:21:08,390 --> 00:21:10,220
argument is assumed to be proven to be

425
00:21:10,220 --> 00:21:12,410
not cell because of the prior approved

426
00:21:12,410 --> 00:21:15,920
with it earlier but again we can specify

427
00:21:15,920 --> 00:21:20,480
any value as well as a cell and this is

428
00:21:20,480 --> 00:21:22,010
interesting because of the concept of

429
00:21:22,010 --> 00:21:24,790
side effects so in JavaScript

430
00:21:24,790 --> 00:21:28,130
some operations might involve callbacks

431
00:21:28,130 --> 00:21:31,480
or do some dangerous sort of operation

432
00:21:31,480 --> 00:21:34,280
the code but for the berry that the

433
00:21:34,280 --> 00:21:37,340
nicest scenario here and the most common

434
00:21:37,340 --> 00:21:39,380
of which are history and value of type

435
00:21:39,380 --> 00:21:41,870
conversions and the jiggli to be aware

436
00:21:41,870 --> 00:21:43,880
of when these operations can happen as

437
00:21:43,880 --> 00:21:47,320
they can be observed by a user code and

438
00:21:47,320 --> 00:21:49,970
invalidate state which is assumed not to

439
00:21:49,970 --> 00:21:53,510
change in print EIT nodes and so things

440
00:21:53,510 --> 00:21:54,860
that you can do is like change an

441
00:21:54,860 --> 00:21:56,320
object's type as the

442
00:21:56,320 --> 00:21:59,740
the code is running change and raised in

443
00:21:59,740 --> 00:22:02,799
this emo as the Chico is running and

444
00:22:02,799 --> 00:22:07,480
again all pipe proofs were done well are

445
00:22:07,480 --> 00:22:09,759
still only considered valid as mimic

446
00:22:09,759 --> 00:22:14,250
model for things that duties are now and

447
00:22:14,250 --> 00:22:18,220
additionally some operations might only

448
00:22:18,220 --> 00:22:20,470
go back if their arguments are a

449
00:22:20,470 --> 00:22:23,440
specific type and Coast ring constructor

450
00:22:23,440 --> 00:22:25,809
in our case is very interesting because

451
00:22:25,809 --> 00:22:28,929
it's modeled to only side effect on cell

452
00:22:28,929 --> 00:22:31,690
news and unhide use arguments because

453
00:22:31,690 --> 00:22:33,730
those treat Heights are the types that

454
00:22:33,730 --> 00:22:36,070
represent arbitrary JavaScript objects

455
00:22:36,070 --> 00:22:39,480
and in bill you can redefine to strange

456
00:22:39,480 --> 00:22:43,360
however for not sell use they will still

457
00:22:43,360 --> 00:22:46,809
in up to string and this makes sense

458
00:22:46,809 --> 00:22:49,570
because as it's probably not sell you

459
00:22:49,570 --> 00:22:51,159
can't really find this string and in

460
00:22:51,159 --> 00:22:53,169
order to stream in fermentation of

461
00:22:53,169 --> 00:22:55,269
volumes and integers which are the two

462
00:22:55,269 --> 00:22:57,580
types represented by not cell and

463
00:22:57,580 --> 00:23:02,019
undefined and simple object that are not

464
00:23:02,019 --> 00:23:05,409
impact they cannot really find the

465
00:23:05,409 --> 00:23:07,389
string and so doing to string is not

466
00:23:07,389 --> 00:23:12,039
going to side effect among those and yes

467
00:23:12,039 --> 00:23:14,740
so we are proven that the argument or

468
00:23:14,740 --> 00:23:17,740
coaster constructor level is known side

469
00:23:17,740 --> 00:23:19,990
affecting because it's not not it's not

470
00:23:19,990 --> 00:23:25,179
self however we can redefine to string

471
00:23:25,179 --> 00:23:27,820
and perform arbitrary and other side

472
00:23:27,820 --> 00:23:29,590
effects anyway because we have seen a

473
00:23:29,590 --> 00:23:32,470
different value at runtime and so we

474
00:23:32,470 --> 00:23:35,019
converted a register location back in

475
00:23:35,019 --> 00:23:38,169
twenty fgg a side effect when is not an

476
00:23:38,169 --> 00:23:40,350
issue

477
00:23:40,710 --> 00:23:43,629
this is significant again because the FG

478
00:23:43,629 --> 00:23:45,429
tries to optimize the way will and in

479
00:23:45,429 --> 00:23:49,450
fact checks even the only few operations

480
00:23:49,450 --> 00:23:51,669
can actually change the object type and

481
00:23:51,669 --> 00:23:53,889
if not those Corrections is ever

482
00:23:53,889 --> 00:23:56,440
encountered it can be assumed a fight we

483
00:23:56,440 --> 00:23:59,110
still unchanged and another tactic is

484
00:23:59,110 --> 00:24:04,120
not necessary and yes this is kind of a

485
00:24:04,120 --> 00:24:07,690
doubt that but by imitating object types

486
00:24:07,690 --> 00:24:08,560
you can

487
00:24:08,560 --> 00:24:11,200
arbitrary confusion and so in our

488
00:24:11,200 --> 00:24:14,790
exploit just before the call to strange

489
00:24:14,790 --> 00:24:19,240
constructor we you attach on adults with

490
00:24:19,240 --> 00:24:22,690
array hereby call dr. Brady which is an

491
00:24:22,690 --> 00:24:24,820
array of doubles by doing these access

492
00:24:24,820 --> 00:24:26,470
we actually prove that the array

493
00:24:26,470 --> 00:24:30,930
contains babbles as numbers and

494
00:24:30,930 --> 00:24:34,620
afterwards once we're on earth

495
00:24:34,620 --> 00:24:38,320
Reconstructor node we perform an

496
00:24:38,320 --> 00:24:42,070
unmodeled side-effect and our setup here

497
00:24:42,070 --> 00:24:44,820
actually changes the flow to erase

498
00:24:44,820 --> 00:24:48,370
member in x1 into a JavaScript object

499
00:24:48,370 --> 00:24:51,310
pointer and this actually does a type

500
00:24:51,310 --> 00:24:53,830
conversion from the array of doubles

501
00:24:53,830 --> 00:24:56,370
into an array of those with values and

502
00:24:56,370 --> 00:25:01,830
in DFG this is still assumed to be

503
00:25:01,830 --> 00:25:05,880
double array because no possible type

504
00:25:05,880 --> 00:25:08,170
transition could have happened there

505
00:25:08,170 --> 00:25:15,100
according jetty and do you know that we

506
00:25:15,100 --> 00:25:18,850
start index 1 pointer to an object and

507
00:25:18,850 --> 00:25:23,760
we access it considering to be a double

508
00:25:23,760 --> 00:25:26,620
and so this is actually an address of a

509
00:25:26,620 --> 00:25:28,780
people in fact confusion which allows us

510
00:25:28,780 --> 00:25:32,080
to in Foley and pointer as a double

511
00:25:32,080 --> 00:25:34,540
value and then we can just convert it

512
00:25:34,540 --> 00:25:36,730
into an integer waves in fact arrays and

513
00:25:36,730 --> 00:25:39,400
do integer arithmetic on it and then

514
00:25:39,400 --> 00:25:41,920
store it back inside array still as

515
00:25:41,920 --> 00:25:46,060
double and yes why we knew that we had a

516
00:25:46,060 --> 00:25:48,640
fake object as accessible index one in

517
00:25:48,640 --> 00:25:51,670
our way and this is interesting because

518
00:25:51,670 --> 00:25:53,620
of the specifically have a static object

519
00:25:53,620 --> 00:25:58,060
and so this is how an empty object looks

520
00:25:58,060 --> 00:26:01,600
like just we have a header and then we

521
00:26:01,600 --> 00:26:04,420
have a pointer to a butterfly I'll get

522
00:26:04,420 --> 00:26:06,430
back to what a butterfly is a bit later

523
00:26:06,430 --> 00:26:09,970
actually however if you create an object

524
00:26:09,970 --> 00:26:13,210
with with a value in it and early

525
00:26:13,210 --> 00:26:15,040
evening when you initialize it you'll

526
00:26:15,040 --> 00:26:18,310
actually start in line plus 0x time in

527
00:26:18,310 --> 00:26:22,700
this case and if you take more

528
00:26:22,700 --> 00:26:24,950
they will be all going in the England

529
00:26:24,950 --> 00:26:28,730
cash inside PJs object itself and so in

530
00:26:28,730 --> 00:26:30,980
in this case I put only integers and you

531
00:26:30,980 --> 00:26:34,220
can see the art store do the F F F F at

532
00:26:34,220 --> 00:26:36,170
the top and that actually is a tacky

533
00:26:36,170 --> 00:26:41,510
that marks the integer right and now

534
00:26:41,510 --> 00:26:44,270
instead I create an object and then I

535
00:26:44,270 --> 00:26:46,250
put any moral values then you can see

536
00:26:46,250 --> 00:26:48,890
the funny very bottom of our object

537
00:26:48,890 --> 00:26:50,900
there we have the pointer to the new

538
00:26:50,900 --> 00:26:56,000
object we created then we change it with

539
00:26:56,000 --> 00:26:58,309
a double value there and you can see

540
00:26:58,309 --> 00:27:01,070
that we're gonna have a packed babble

541
00:27:01,070 --> 00:27:04,340
and which changes the bit representation

542
00:27:04,340 --> 00:27:06,650
of the double value in order to mark

543
00:27:06,650 --> 00:27:08,950
that it's a floating point right

544
00:27:08,950 --> 00:27:10,750
[Music]

545
00:27:10,750 --> 00:27:15,200
and yes we have these other created that

546
00:27:15,200 --> 00:27:19,130
part 1 gives us which means that

547
00:27:19,130 --> 00:27:21,740
something like this ends up happening

548
00:27:21,740 --> 00:27:26,600
and these results in a further confusion

549
00:27:26,600 --> 00:27:29,419
every time we access our fake object

550
00:27:29,419 --> 00:27:30,470
between

551
00:27:30,470 --> 00:27:33,799
JSL and attack double as well as pointer

552
00:27:33,799 --> 00:27:36,740
panopticon to the butterfly if they come

553
00:27:36,740 --> 00:27:41,900
to look like this and so in just to dart

554
00:27:41,900 --> 00:27:46,150
now wait I think it just arrived earlier

555
00:27:46,150 --> 00:27:49,490
so I said we can split a fake gif

556
00:27:49,490 --> 00:27:51,830
cylinder taking the count the fact that

557
00:27:51,830 --> 00:27:58,190
it's my tank and then park up confusion

558
00:27:58,190 --> 00:28:00,890
actually routes to that confusion from

559
00:28:00,890 --> 00:28:03,530
the pointer to an object in the pointer

560
00:28:03,530 --> 00:28:07,490
about their plight and butterflies are

561
00:28:07,490 --> 00:28:09,350
objects that look something like this

562
00:28:09,350 --> 00:28:13,100
and so you have an array of values we

563
00:28:13,100 --> 00:28:14,600
started creating an entity object and

564
00:28:14,600 --> 00:28:16,910
then we set an index value as if it's an

565
00:28:16,910 --> 00:28:20,870
inner braid and yes butterfly is created

566
00:28:20,870 --> 00:28:24,580
and the member number 0 we have our one

567
00:28:24,580 --> 00:28:28,640
3.37 value and in JSL header the

568
00:28:28,640 --> 00:28:30,830
indexing type will specify the type of

569
00:28:30,830 --> 00:28:32,870
the objects contained in the butterfly

570
00:28:32,870 --> 00:28:34,820
so in this case we

571
00:28:34,820 --> 00:28:37,700
bable value in the doctor ploy and so

572
00:28:37,700 --> 00:28:40,009
the type of the butterflies immutable

573
00:28:40,009 --> 00:28:43,899
and indexing type of the observable

574
00:28:43,899 --> 00:28:47,210
however now we add another object to

575
00:28:47,210 --> 00:28:49,730
undervalue our butterfly which is

576
00:28:49,730 --> 00:28:52,730
doesn't object and when you do this it

577
00:28:52,730 --> 00:28:55,309
will convert butterfly into a continuous

578
00:28:55,309 --> 00:28:58,159
type butterfly and you will have to tag

579
00:28:58,159 --> 00:29:00,980
the double value previously put and then

580
00:29:00,980 --> 00:29:05,450
put the pointer to object there and I

581
00:29:05,450 --> 00:29:07,580
mean we we have access to of take object

582
00:29:07,580 --> 00:29:10,129
living in a object in my property cash

583
00:29:10,129 --> 00:29:13,610
and actually I mean that alone is enough

584
00:29:13,610 --> 00:29:17,029
for a solid execution but it's very

585
00:29:17,029 --> 00:29:18,710
convenient if you're in business working

586
00:29:18,710 --> 00:29:22,460
exploits you have standard set of

587
00:29:22,460 --> 00:29:25,340
primitives so they can be fun in playing

588
00:29:25,340 --> 00:29:27,169
phase about that or something like that

589
00:29:27,169 --> 00:29:30,559
and those primitives tend to be the

590
00:29:30,559 --> 00:29:33,039
enter stuff and take up two primitives

591
00:29:33,039 --> 00:29:36,289
and I mean you don't have to take Jace

592
00:29:36,289 --> 00:29:38,539
so header and control the indexing type

593
00:29:38,539 --> 00:29:40,639
of to take object as well as the perfect

594
00:29:40,639 --> 00:29:43,870
hunter driving these should be possible

595
00:29:43,870 --> 00:29:47,480
and my idea was to just set the

596
00:29:47,480 --> 00:29:49,279
butterfly pointer which they come to

597
00:29:49,279 --> 00:29:50,470
itself

598
00:29:50,470 --> 00:29:52,759
wanita what what earthly objects is that

599
00:29:52,759 --> 00:29:55,519
the length of the batter by itself is

600
00:29:55,519 --> 00:29:57,710
when we started the negative offset from

601
00:29:57,710 --> 00:30:00,620
the pointer to the butterfly itself and

602
00:30:00,620 --> 00:30:03,169
you to take physical time I have to

603
00:30:03,169 --> 00:30:05,929
shift the fake object by 0 X 18 earlier

604
00:30:05,929 --> 00:30:08,000
in 0 X 10 which is the size of the

605
00:30:08,000 --> 00:30:11,059
object header so we have some space to

606
00:30:11,059 --> 00:30:15,620
control the fake butterfly selector Lent

607
00:30:15,620 --> 00:30:20,179
and bunny planet ok so the layout ends

608
00:30:20,179 --> 00:30:22,149
up looking something like this

609
00:30:22,149 --> 00:30:24,980
and now we put our fake back to reliant

610
00:30:24,980 --> 00:30:27,470
on public land in the container object

611
00:30:27,470 --> 00:30:30,110
as their valid prior to take J cell

612
00:30:30,110 --> 00:30:34,340
header and we also control the innocent

613
00:30:34,340 --> 00:30:37,429
pipe of her fake jxl to be a double pipe

614
00:30:37,429 --> 00:30:41,960
and now we can access our fake object as

615
00:30:41,960 --> 00:30:45,470
an array and all accesses there will

616
00:30:45,470 --> 00:30:47,070
result into a

617
00:30:47,070 --> 00:30:51,230
double value be returned to the script

618
00:30:51,680 --> 00:30:54,900
so yes have you take into consideration

619
00:30:54,900 --> 00:30:57,600
that double itself does not have an tag

620
00:30:57,600 --> 00:30:59,940
but in England objects we will have

621
00:30:59,940 --> 00:31:01,770
attacked as you can see from the

622
00:31:01,770 --> 00:31:03,930
epithets at the very bottom there

623
00:31:03,930 --> 00:31:08,880
and so yes we end up we get Billy to

624
00:31:08,880 --> 00:31:12,750
access the same memory area in two

625
00:31:12,750 --> 00:31:15,060
different ways either as double or as

626
00:31:15,060 --> 00:31:19,680
JSON and with pretty much a perfect pad

627
00:31:19,680 --> 00:31:22,470
confusion sort of scenario that ends up

628
00:31:22,470 --> 00:31:26,100
in giving us a dress up and take up the

629
00:31:26,100 --> 00:31:28,740
critics directly yes our other soft

630
00:31:28,740 --> 00:31:31,530
pretty look something like this and our

631
00:31:31,530 --> 00:31:33,240
fake ones through did look something

632
00:31:33,240 --> 00:31:39,870
like this and yes this is all the wait

633
00:31:39,870 --> 00:31:45,300
until few months ago but now there's an

634
00:31:45,300 --> 00:31:49,080
extra details here once like Ito is that

635
00:31:49,080 --> 00:31:51,660
we do need to take a JSL header and in

636
00:31:51,660 --> 00:31:54,030
order to be able to make a fake JSL

637
00:31:54,030 --> 00:31:57,450
header you need to guess what's what's

638
00:31:57,450 --> 00:31:59,370
called a structure ID which are the

639
00:31:59,370 --> 00:32:01,920
first four bytes of JSL header itself

640
00:32:01,920 --> 00:32:06,270
and an instructor ID will define the

641
00:32:06,270 --> 00:32:09,810
shape of a given object so the kind of

642
00:32:09,810 --> 00:32:13,770
in line participants they kind of for my

643
00:32:13,770 --> 00:32:18,720
details structure IDs are necessary in

644
00:32:18,720 --> 00:32:23,520
order to quickly objects here and so you

645
00:32:23,520 --> 00:32:26,190
strike paper these was accomplished by

646
00:32:26,190 --> 00:32:28,680
just spraying structure IDs but creating

647
00:32:28,680 --> 00:32:30,650
lots of differently shaped objects and

648
00:32:30,650 --> 00:32:34,320
in this specific case that a speaker who

649
00:32:34,320 --> 00:32:36,990
just create sequential restructure IDs

650
00:32:36,990 --> 00:32:40,380
and you can just guess one of those and

651
00:32:40,380 --> 00:32:43,110
you'll be very libel and these what most

652
00:32:43,110 --> 00:32:48,660
job sites do or deep brother because on

653
00:32:48,660 --> 00:32:52,770
Sunday is February taking a day sell a

654
00:32:52,770 --> 00:32:57,480
hell of a lot harder so what they did

655
00:32:57,480 --> 00:33:00,029
they added some entropy bit who

656
00:33:00,029 --> 00:33:03,599
each structure ID and if the entropy

657
00:33:03,599 --> 00:33:06,899
bits are guessed incorrectly then the

658
00:33:06,899 --> 00:33:10,139
JavaScript engines are crash and so you

659
00:33:10,139 --> 00:33:12,749
can just spray and pray anymore

660
00:33:12,749 --> 00:33:15,629
because those 700 debates have big-ass

661
00:33:15,629 --> 00:33:20,070
directive and each set of attributes is

662
00:33:20,070 --> 00:33:22,529
actually specific for each structure

663
00:33:22,529 --> 00:33:26,099
itself so it's not just one value that's

664
00:33:26,099 --> 00:33:30,269
chosen at one time the first anyone

665
00:33:30,269 --> 00:33:32,639
games in every time we create a

666
00:33:32,639 --> 00:33:35,099
different shape object different entropy

667
00:33:35,099 --> 00:33:38,729
bits are going to be used and so yes to

668
00:33:38,729 --> 00:33:41,519
create a struct ID now we also need to

669
00:33:41,519 --> 00:33:43,519
be able to guess 7 and to predict and

670
00:33:43,519 --> 00:33:47,690
till gets this most liquid crashes

671
00:33:47,690 --> 00:33:50,759
operations which will result in crashing

672
00:33:50,759 --> 00:33:52,289
or for instance excessive name

673
00:33:52,289 --> 00:33:56,249
properties garbage collection visits and

674
00:33:56,249 --> 00:33:59,249
will be anything that you can think of

675
00:33:59,249 --> 00:34:01,950
we rely on structure giving valid and

676
00:34:01,950 --> 00:34:04,739
the public strategy for gaining with

677
00:34:04,739 --> 00:34:07,769
right from a set of five fake objects of

678
00:34:07,769 --> 00:34:10,609
take object and address alternatives

679
00:34:10,609 --> 00:34:14,369
uses named property accesses but even if

680
00:34:14,369 --> 00:34:16,168
you didn't not having a balanced

681
00:34:16,168 --> 00:34:18,629
fracture ID will still very very likely

682
00:34:18,629 --> 00:34:23,179
mean a crash when is represented and so

683
00:34:23,179 --> 00:34:26,099
what this means is that this technique

684
00:34:26,099 --> 00:34:27,359
is actually completely dead

685
00:34:27,359 --> 00:34:32,039
theoretically but there are some things

686
00:34:32,039 --> 00:34:34,649
you could possibly do in order to bypass

687
00:34:34,649 --> 00:34:38,719
this to this day and here are some ideas

688
00:34:38,719 --> 00:34:42,899
for generic ways of doing so but so for

689
00:34:42,899 --> 00:34:43,918
instance you could have used

690
00:34:43,918 --> 00:34:45,899
differential behavior between

691
00:34:45,899 --> 00:34:48,889
specialized and no specialized g80 code

692
00:34:48,889 --> 00:34:52,379
for instance in the FD l JT code it is

693
00:34:52,379 --> 00:34:54,839
possible to make use of loop invariant

694
00:34:54,839 --> 00:34:57,809
code motion to move search for Civic

695
00:34:57,809 --> 00:35:01,799
nodes before for instance and

696
00:35:01,799 --> 00:35:04,619
conditional branch or just return and

697
00:35:04,619 --> 00:35:07,799
when the specialized code is brand it's

698
00:35:07,799 --> 00:35:10,829
gonna either just return be nothing or

699
00:35:10,829 --> 00:35:12,240
it's gonna bail out

700
00:35:12,240 --> 00:35:15,540
the interpreter instead because the

701
00:35:15,540 --> 00:35:16,740
structure idea was guessed incorrectly

702
00:35:16,740 --> 00:35:19,349
and the interpreter does not do it

703
00:35:19,349 --> 00:35:22,109
without code motion so that now who'll

704
00:35:22,109 --> 00:35:23,670
never be executed and so you will not

705
00:35:23,670 --> 00:35:25,710
have a crash because you returned their

706
00:35:25,710 --> 00:35:27,780
conditional return will happen before

707
00:35:27,780 --> 00:35:34,490
that and also say Xerox or t1 con

708
00:35:34,490 --> 00:35:36,869
introduced the concept of inferred types

709
00:35:36,869 --> 00:35:39,180
which would also be a feasible because

710
00:35:39,180 --> 00:35:41,130
you can create a real object and then

711
00:35:41,130 --> 00:35:43,710
put a big object inside it and then any

712
00:35:43,710 --> 00:35:46,650
access to the wake of the true the real

713
00:35:46,650 --> 00:35:49,920
object will use a check structure note

714
00:35:49,920 --> 00:35:52,559
on the real object we already proved the

715
00:35:52,559 --> 00:35:54,900
type of the fake object so and so you do

716
00:35:54,900 --> 00:35:56,369
not have to guess the structure ID in

717
00:35:56,369 --> 00:35:59,910
this specific scenario but generic

718
00:35:59,910 --> 00:36:02,730
bypasses for these are possible and they

719
00:36:02,730 --> 00:36:05,339
do exist but we're not gonna talk about

720
00:36:05,339 --> 00:36:08,940
them now but let's think about the bug

721
00:36:08,940 --> 00:36:10,950
we have a hand and see if you can

722
00:36:10,950 --> 00:36:13,470
leverage it for bypassing structure in

723
00:36:13,470 --> 00:36:15,869
the randomization with the bug the city

724
00:36:15,869 --> 00:36:19,290
picnic ok so let's go back real quick

725
00:36:19,290 --> 00:36:24,180
what our bug was we have initialized

726
00:36:24,180 --> 00:36:29,880
stack variable axis here and the g80 can

727
00:36:29,880 --> 00:36:32,520
assume that the type contained in it

728
00:36:32,520 --> 00:36:36,059
stack slot is a very specific but again

729
00:36:36,059 --> 00:36:38,730
specify any other value of any other

730
00:36:38,730 --> 00:36:42,089
type and cause a return a conclusion and

731
00:36:42,089 --> 00:36:45,210
if we look at what the structure ie and

732
00:36:45,210 --> 00:36:48,930
create mitigation actually added well I

733
00:36:48,930 --> 00:36:51,599
mean once you have add ability to read

734
00:36:51,599 --> 00:36:55,230
out of bounds and the JSL heap we can

735
00:36:55,230 --> 00:36:58,079
still we can only structure D and we can

736
00:36:58,079 --> 00:37:00,510
just use that and have this pray and

737
00:37:00,510 --> 00:37:02,790
pray or guess the sudden entropy bits

738
00:37:02,790 --> 00:37:06,359
and an example of how to possibly do

739
00:37:06,359 --> 00:37:08,849
this with our pub could be by using the

740
00:37:08,849 --> 00:37:12,299
getting upset now get by offset is the

741
00:37:12,299 --> 00:37:15,450
g18 node that will fetch an in-line

742
00:37:15,450 --> 00:37:18,920
property value from the object itself

743
00:37:18,920 --> 00:37:22,200
butterfly and it doesn't perform any

744
00:37:22,200 --> 00:37:24,030
sort of bounce jacking just relized

745
00:37:24,030 --> 00:37:27,600
type information being correct however

746
00:37:27,600 --> 00:37:31,290
if I even pet confuse it we will you

747
00:37:31,290 --> 00:37:33,210
know end up being out of boundary and

748
00:37:33,210 --> 00:37:35,730
yes if we prove it had the specific

749
00:37:35,730 --> 00:37:38,460
variable and then use our register

750
00:37:38,460 --> 00:37:41,550
locator but in order to cause yet digit

751
00:37:41,550 --> 00:37:44,670
in each track its value and its type we

752
00:37:44,670 --> 00:37:46,380
can put that number but another type and

753
00:37:46,380 --> 00:37:51,020
or shape in and this is the code that

754
00:37:51,020 --> 00:37:53,880
try to do that and use how it looks like

755
00:37:53,880 --> 00:37:56,160
and so again we'll begin with a lot of

756
00:37:56,160 --> 00:37:58,080
useless every access this just to make

757
00:37:58,080 --> 00:38:01,020
our stack frame very large now we got

758
00:38:01,020 --> 00:38:03,210
hack-proof this time a little different

759
00:38:03,210 --> 00:38:06,980
access and England property on a RI 1

760
00:38:06,980 --> 00:38:11,520
and D F digit will perform the type

761
00:38:11,520 --> 00:38:14,070
check before they get by except now that

762
00:38:14,070 --> 00:38:17,640
is the only put in the first option D

763
00:38:17,640 --> 00:38:20,340
valuable there and then the very bottom

764
00:38:20,340 --> 00:38:22,830
we do another get my assets by factoring

765
00:38:22,830 --> 00:38:27,690
the a value of air i1 and air I one has

766
00:38:27,690 --> 00:38:29,910
a proven record ready from the tag

767
00:38:29,910 --> 00:38:33,330
performing at the beginning here and I

768
00:38:33,330 --> 00:38:36,300
mean no operation Sears side-effect

769
00:38:36,300 --> 00:38:39,360
slicing a string does not set a fact and

770
00:38:39,360 --> 00:38:42,630
so it actually possible to reuse a head

771
00:38:42,630 --> 00:38:50,360
proof and yes actually because of a bug

772
00:38:50,360 --> 00:38:53,400
we can do a get by offset on arbitrarily

773
00:38:53,400 --> 00:38:59,400
tag object now and in this case for

774
00:38:59,400 --> 00:39:02,910
instance it's thinking itself that's the

775
00:39:02,910 --> 00:39:06,600
a value from the JavaScript object out a

776
00:39:06,600 --> 00:39:12,330
like creditor that has six boxer can do

777
00:39:12,330 --> 00:39:15,150
not one two three four as pipe in my

778
00:39:15,150 --> 00:39:17,250
properties and will touch from the last

779
00:39:17,250 --> 00:39:21,000
one the its value and then third another

780
00:39:21,000 --> 00:39:27,770
object on has for in my properties and

781
00:39:27,860 --> 00:39:31,410
by using a bug we can make the gap by

782
00:39:31,410 --> 00:39:34,920
outside node fetch from object that he

783
00:39:34,920 --> 00:39:36,220
thinks it's a one pie

784
00:39:36,220 --> 00:39:38,420
but in Gallup it's the other and these

785
00:39:38,420 --> 00:39:41,960
results in out-of-bounds exercise as the

786
00:39:41,960 --> 00:39:46,640
oj1 object only has 0 X 20 bytes but the

787
00:39:46,640 --> 00:39:47,450
30 bytes

788
00:39:47,450 --> 00:39:51,440
sighs but detaches from Derek's 30 and

789
00:39:51,440 --> 00:39:53,900
so we end up licking that first eight

790
00:39:53,900 --> 00:39:58,609
bytes a bit next objective and is what

791
00:39:58,609 --> 00:40:01,270
it looks like when this is difficult so

792
00:40:01,270 --> 00:40:04,670
we begin with our high proof which is

793
00:40:04,670 --> 00:40:07,430
emitted by the DF digit to prove that

794
00:40:07,430 --> 00:40:10,339
the gap by about by asset node and a RI

795
00:40:10,339 --> 00:40:15,049
one that B is correct and then we'll

796
00:40:15,049 --> 00:40:17,450
take our bug which will end up spilling

797
00:40:17,450 --> 00:40:20,869
to the stack air ax and if you look at

798
00:40:20,869 --> 00:40:23,240
the structure note that was inserted by

799
00:40:23,240 --> 00:40:26,089
DF g jiggler you will see that array x

800
00:40:26,089 --> 00:40:28,490
is the register that holds the air I one

801
00:40:28,490 --> 00:40:30,859
object also

802
00:40:30,859 --> 00:40:35,720
it's supposed to be spilled and then we

803
00:40:35,720 --> 00:40:38,240
have our get back offset on air i one a

804
00:40:38,240 --> 00:40:42,140
prudent type and you can see that type

805
00:40:42,140 --> 00:40:44,869
is proven because there is no check

806
00:40:44,869 --> 00:40:46,670
structure if you compile this code and

807
00:40:46,670 --> 00:40:48,680
go back there is no check structure

808
00:40:48,680 --> 00:40:50,180
there only to check structure there is

809
00:40:50,180 --> 00:40:54,079
going to be used and yes as per the

810
00:40:54,079 --> 00:40:56,119
assembly code these results in

811
00:40:56,119 --> 00:40:59,869
out-of-bounds grading J Selke and this

812
00:40:59,869 --> 00:41:02,599
is actually the code that what the

813
00:41:02,599 --> 00:41:04,490
function here is what's gonna get

814
00:41:04,490 --> 00:41:07,910
optimized and this is the code that will

815
00:41:07,910 --> 00:41:10,430
trigger the accommodation in the correct

816
00:41:10,430 --> 00:41:12,380
way and put the right values on the

817
00:41:12,380 --> 00:41:15,829
stack in order to perform this lesson

818
00:41:15,829 --> 00:41:17,599
factually you saw earlier a copy paste

819
00:41:17,599 --> 00:41:20,180
it twice so you can have two different

820
00:41:20,180 --> 00:41:22,990
functions are identical in every way but

821
00:41:22,990 --> 00:41:25,790
expect different typed objects and a

822
00:41:25,790 --> 00:41:27,500
newbie in order to be able to straight a

823
00:41:27,500 --> 00:41:29,780
stack and a specifically control value

824
00:41:29,780 --> 00:41:32,869
that will contain the boundary on the

825
00:41:32,869 --> 00:41:35,299
other function and you need to have two

826
00:41:35,299 --> 00:41:36,680
different functions for this because if

827
00:41:36,680 --> 00:41:38,569
you do one function and pass two

828
00:41:38,569 --> 00:41:40,819
different types in it we will do a

829
00:41:40,819 --> 00:41:43,609
different kind of optimization and these

830
00:41:43,609 --> 00:41:48,160
will not succeed and this is the result

831
00:41:48,160 --> 00:41:51,859
rounding it down a recent one he built

832
00:41:51,859 --> 00:41:54,680
the buggies and days it's a little work

833
00:41:54,680 --> 00:41:56,779
in the very latest version but you can

834
00:41:56,779 --> 00:41:58,789
see that across different runs the

835
00:41:58,789 --> 00:42:00,739
result is always different and if you

836
00:42:00,739 --> 00:42:02,779
try to run this one others a super

837
00:42:02,779 --> 00:42:04,940
version all those in the elliptical

838
00:42:04,940 --> 00:42:07,609
every single time and that's the

839
00:42:07,609 --> 00:42:10,430
randomization going on here and you can

840
00:42:10,430 --> 00:42:12,739
actually find a full code for the upper

841
00:42:12,739 --> 00:42:17,209
bound with urbanization at this URL here

842
00:42:17,209 --> 00:42:22,309
and so you get the conclusion but

843
00:42:22,309 --> 00:42:25,549
getting code execution on iOS and Mac OS

844
00:42:25,549 --> 00:42:28,519
is tricky as Apple has been very busy

845
00:42:28,519 --> 00:42:30,920
pushing mitigations but given the right

846
00:42:30,920 --> 00:42:32,989
attack surface it is still possible to

847
00:42:32,989 --> 00:42:35,269
find power to enough bugs result in full

848
00:42:35,269 --> 00:42:38,479
compromise and just some engines happen

849
00:42:38,479 --> 00:42:40,339
to be mind-boggling complicated and

850
00:42:40,339 --> 00:42:42,739
there's always gonna be a wage yet

851
00:42:42,739 --> 00:42:45,499
police future in my opinion even with

852
00:42:45,499 --> 00:42:48,499
pack and memory technique and although I

853
00:42:48,499 --> 00:42:50,029
could scientifically

854
00:42:50,029 --> 00:42:52,670
lorikeets Nicholas t-cell you know sleep

855
00:42:52,670 --> 00:42:56,109
it's okay just in case you see for this

856
00:42:56,109 --> 00:43:10,239
so any question - you cut rates for Rica

857
00:43:10,239 --> 00:43:25,699
talk to try to ensure yeah that is the

858
00:43:25,699 --> 00:43:28,969
sort of a route but what what we think

859
00:43:28,969 --> 00:43:31,519
Apple really make in terms of many

860
00:43:31,519 --> 00:43:34,219
issues obviously paxil is the only idea

861
00:43:34,219 --> 00:43:38,469
of where we're next

862
00:43:41,349 --> 00:43:44,769
I'm sorry for that

863
00:43:44,769 --> 00:43:50,599
so specifically in what actually there

864
00:43:50,599 --> 00:43:53,359
are mitigation some can see already in

865
00:43:53,359 --> 00:43:53,990
the

866
00:43:53,990 --> 00:43:59,869
get in the git repo where the they will

867
00:43:59,869 --> 00:44:02,660
use pack in tact arrays as well as

868
00:44:02,660 --> 00:44:06,230
webassembly memory backing buffers which

869
00:44:06,230 --> 00:44:09,110
killed rewrite primitives are currently

870
00:44:09,110 --> 00:44:12,070
being used except for the butterfly one

871
00:44:12,070 --> 00:44:14,960
but as for harder locations and what's

872
00:44:14,960 --> 00:44:18,250
next in evil ecosystem of iOS and

873
00:44:18,250 --> 00:44:22,070
hopefully Mac OS which Apple doesn't

874
00:44:22,070 --> 00:44:25,490
seem to care about as much never having

875
00:44:25,490 --> 00:44:27,860
easy on this one I don't think this year

876
00:44:27,860 --> 00:44:31,130
is gonna be in their CPUs that probably

877
00:44:31,130 --> 00:44:33,500
next the next generation of associates

878
00:44:33,500 --> 00:44:36,950
will have it so we'll see if we are

879
00:44:36,950 --> 00:44:38,869
going to need a new job or it's you know

880
00:44:38,869 --> 00:44:42,050
but we as attackers are gonna need a new

881
00:44:42,050 --> 00:44:45,020
job or a pony and there's also or you

882
00:44:45,020 --> 00:44:50,380
know things are still business zero and

883
00:44:50,380 --> 00:44:52,790
they are incremental be adding

884
00:44:52,790 --> 00:44:54,200
mitigations even with the current

885
00:44:54,200 --> 00:44:56,869
associates that we have specifically

886
00:44:56,869 --> 00:44:59,050
incurred on what they have very powerful

887
00:44:59,050 --> 00:45:01,340
primitives now to implement security

888
00:45:01,340 --> 00:45:04,700
features without needing meaning without

889
00:45:04,700 --> 00:45:06,650
necessarily needing to have in the

890
00:45:06,650 --> 00:45:10,040
silicon in place so I mean we'll see but

891
00:45:10,040 --> 00:45:12,440
never tagging that's the alphanumeric

892
00:45:12,440 --> 00:45:14,900
starts attack cursor as for what the

893
00:45:14,900 --> 00:45:17,380
future holds

