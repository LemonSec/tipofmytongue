1
00:00:00,659 --> 00:00:03,559
bye

2
00:00:08,240 --> 00:00:12,059
Ian needs obviously no introduction and

3
00:00:12,059 --> 00:00:13,920
I'm very excited about this talk

4
00:00:13,920 --> 00:00:16,619
obviously something that's a very

5
00:00:16,619 --> 00:00:18,660
interesting intriguing topic so let's

6
00:00:18,660 --> 00:00:21,060
give Ian a round of applause and over to

7
00:00:21,060 --> 00:00:23,479
you Ian

8
00:00:27,900 --> 00:00:31,019
hi everyone can you hear me yes yes

9
00:00:31,019 --> 00:00:33,360
cool so welcome to my talk uh abusing

10
00:00:33,360 --> 00:00:35,100
iPhone co-processors for privilege

11
00:00:35,100 --> 00:00:37,020
escalation so

12
00:00:37,020 --> 00:00:39,300
um I'm the tech lead of project zero at

13
00:00:39,300 --> 00:00:42,239
Google I've been doing Apple tangential

14
00:00:42,239 --> 00:00:44,160
security research for I guess over a

15
00:00:44,160 --> 00:00:46,020
decade now mostly on the vulnerability

16
00:00:46,020 --> 00:00:48,000
research side so trying to find bugs

17
00:00:48,000 --> 00:00:50,700
before other people find them but more

18
00:00:50,700 --> 00:00:52,800
recently over the last few years getting

19
00:00:52,800 --> 00:00:55,079
more and more involved with in the wild

20
00:00:55,079 --> 00:00:57,480
iPhone exploitation and helping on the

21
00:00:57,480 --> 00:01:00,480
analysis side and so today I want to

22
00:01:00,480 --> 00:01:02,879
share this story which on the face of it

23
00:01:02,879 --> 00:01:05,099
seems kind of run-of-the-mill but then

24
00:01:05,099 --> 00:01:07,500
takes an unexpected twist and I now

25
00:01:07,500 --> 00:01:09,060
realize that the unexpected twist is in

26
00:01:09,060 --> 00:01:11,340
the title of the talk

27
00:01:11,340 --> 00:01:13,799
so anyway Imagine This

28
00:01:13,799 --> 00:01:16,740
you're browsing your favorite website on

29
00:01:16,740 --> 00:01:18,840
your favorite mobile device

30
00:01:18,840 --> 00:01:24,360
and all of a sudden the mobile data

31
00:01:24,360 --> 00:01:27,020
goes down

32
00:01:27,060 --> 00:01:28,439
you can no longer view your favorite

33
00:01:28,439 --> 00:01:30,479
mobile site

34
00:01:30,479 --> 00:01:33,000
and you get a text message

35
00:01:33,000 --> 00:01:35,880
which says something like this

36
00:01:35,880 --> 00:01:38,280
it's time to get connected

37
00:01:38,280 --> 00:01:40,500
to enable data on this device connect to

38
00:01:40,500 --> 00:01:42,540
a Wi-Fi network and head to this link

39
00:01:42,540 --> 00:01:44,820
then select your device follow the

40
00:01:44,820 --> 00:01:47,820
simple steps and you'll be good to go

41
00:01:47,820 --> 00:01:49,799
and here's a link

42
00:01:49,799 --> 00:01:51,960
now I know what everyone in this room is

43
00:01:51,960 --> 00:01:55,799
thinking don't click that link

44
00:01:55,799 --> 00:01:58,640
you click the link

45
00:01:58,860 --> 00:02:01,799
and this is what happens so

46
00:02:01,799 --> 00:02:03,360
this

47
00:02:03,360 --> 00:02:05,939
protocol here Will

48
00:02:05,939 --> 00:02:08,699
enable iTunes to go download and install

49
00:02:08,699 --> 00:02:11,520
this application this app is signed with

50
00:02:11,520 --> 00:02:13,860
an Enterprise certificate so it will run

51
00:02:13,860 --> 00:02:16,739
on your device and this is what it looks

52
00:02:16,739 --> 00:02:18,300
like but you don't care because you

53
00:02:18,300 --> 00:02:20,220
really want to get back on that website

54
00:02:20,220 --> 00:02:24,239
and your mobile data comes back

55
00:02:24,239 --> 00:02:25,980
and you're happy

56
00:02:25,980 --> 00:02:28,319
so it's pretty obvious what's happened

57
00:02:28,319 --> 00:02:30,720
here this is clearly fishing

58
00:02:30,720 --> 00:02:32,819
but there are some really curious

59
00:02:32,819 --> 00:02:36,260
aspects to this phishing attack

60
00:02:36,360 --> 00:02:38,220
we know that fishing works best when

61
00:02:38,220 --> 00:02:40,680
there's believable context around it you

62
00:02:40,680 --> 00:02:43,200
can be more easily tricked into in this

63
00:02:43,200 --> 00:02:44,640
case clicking this very suspicious link

64
00:02:44,640 --> 00:02:46,680
and this is a real story that really

65
00:02:46,680 --> 00:02:49,200
happened and we have a copy of this app

66
00:02:49,200 --> 00:02:51,660
we don't know the text message but this

67
00:02:51,660 --> 00:02:53,519
is a real text message that gets sent by

68
00:02:53,519 --> 00:02:56,519
this particular Network operator

69
00:02:56,519 --> 00:02:57,900
and so there's this curious

70
00:02:57,900 --> 00:03:00,120
juxtaposition here of like

71
00:03:00,120 --> 00:03:01,640
a fairly run-of-the-mill fishing attack

72
00:03:01,640 --> 00:03:04,080
but to create the context for this

73
00:03:04,080 --> 00:03:05,540
phishing attack

74
00:03:05,540 --> 00:03:08,580
required quite high level intervention

75
00:03:08,580 --> 00:03:10,200
here at this case with the network

76
00:03:10,200 --> 00:03:12,540
operator to really disconnect the mobile

77
00:03:12,540 --> 00:03:14,519
data of this target

78
00:03:14,519 --> 00:03:16,500
so there's something kind of strange

79
00:03:16,500 --> 00:03:18,720
going on here and this is just one of

80
00:03:18,720 --> 00:03:21,720
the Curious aspects of this so we don't

81
00:03:21,720 --> 00:03:23,040
have the text message but what we do

82
00:03:23,040 --> 00:03:25,440
have is that app

83
00:03:25,440 --> 00:03:28,860
and so this is Insider you know the

84
00:03:28,860 --> 00:03:31,379
Vodafone imagery there it's not a real

85
00:03:31,379 --> 00:03:33,000
Vodafone app

86
00:03:33,000 --> 00:03:35,220
and like any good developer they're

87
00:03:35,220 --> 00:03:37,860
linking against a bunch of Frameworks so

88
00:03:37,860 --> 00:03:39,599
what's in here

89
00:03:39,599 --> 00:03:43,140
agent dot framework fairly suspicious

90
00:03:43,140 --> 00:03:47,720
sounding framework to come from Vodafone

91
00:03:47,720 --> 00:03:50,280
timewaste dot framework which means

92
00:03:50,280 --> 00:03:51,780
different things to different people in

93
00:03:51,780 --> 00:03:53,280
the audience

94
00:03:53,280 --> 00:03:55,560
there is a there is an old iPhone

95
00:03:55,560 --> 00:03:57,480
jailbreak that used an exploit called

96
00:03:57,480 --> 00:04:01,379
time waste and there's also an exploit

97
00:04:01,379 --> 00:04:03,299
called sock puppet which sounds a bit

98
00:04:03,299 --> 00:04:04,200
like that

99
00:04:04,200 --> 00:04:06,239
and there's an exploit called light

100
00:04:06,239 --> 00:04:10,680
speed like that an injection kit and all

101
00:04:10,680 --> 00:04:12,780
of this other stuff so what's going on

102
00:04:12,780 --> 00:04:14,040
here

103
00:04:14,040 --> 00:04:18,779
well so as I say three of these are just

104
00:04:18,779 --> 00:04:20,820
exploits from GitHub this one is

105
00:04:20,820 --> 00:04:22,740
actually GPL licensed in case anyone

106
00:04:22,740 --> 00:04:25,800
wants to do some copyright work

107
00:04:25,800 --> 00:04:29,460
this is CPU 2019 from someone on my team

108
00:04:29,460 --> 00:04:31,860
project zero

109
00:04:31,860 --> 00:04:34,259
fixed in 2019 and this is all happening

110
00:04:34,259 --> 00:04:36,660
in 2021 so if you were up to date

111
00:04:36,660 --> 00:04:39,000
nothing was going to happen here

112
00:04:39,000 --> 00:04:43,259
this is an even older exploit from 2018

113
00:04:43,259 --> 00:04:46,020
this one is targeting a bug in the apple

114
00:04:46,020 --> 00:04:48,120
video encoder that was discussed at

115
00:04:48,120 --> 00:04:50,880
black hat EU 2020

116
00:04:50,880 --> 00:04:52,800
and there are two more even interest

117
00:04:52,800 --> 00:04:55,560
more interesting ones which at the time

118
00:04:55,560 --> 00:04:57,479
we believe this sample was first found

119
00:04:57,479 --> 00:05:00,540
or was being used these were ode so this

120
00:05:00,540 --> 00:05:03,060
one there's already a great write-up by

121
00:05:03,060 --> 00:05:06,060
sa Amar which is a integer overflow in

122
00:05:06,060 --> 00:05:08,160
IO mobile frame buffer

123
00:05:08,160 --> 00:05:10,680
and this one

124
00:05:10,680 --> 00:05:13,259
is what this talk is about

125
00:05:13,259 --> 00:05:14,580
so

126
00:05:14,580 --> 00:05:17,340
when this

127
00:05:17,340 --> 00:05:19,919
app was first given to me and I threw

128
00:05:19,919 --> 00:05:21,479
all of these different Frameworks in Ida

129
00:05:21,479 --> 00:05:24,240
there are six exploits here and five of

130
00:05:24,240 --> 00:05:25,139
them

131
00:05:25,139 --> 00:05:27,840
all follow a very common similar

132
00:05:27,840 --> 00:05:29,419
structure

133
00:05:29,419 --> 00:05:32,280
where they are clearly exploiting kernel

134
00:05:32,280 --> 00:05:33,900
memory corruption bugs and all go

135
00:05:33,900 --> 00:05:36,720
through the same set of steps

136
00:05:36,720 --> 00:05:39,000
to defeat all of the mitigations that

137
00:05:39,000 --> 00:05:42,360
Linus was talking about earlier but one

138
00:05:42,360 --> 00:05:45,180
of them does not look like the others at

139
00:05:45,180 --> 00:05:47,039
all

140
00:05:47,039 --> 00:05:49,380
um and it also has some other kind of

141
00:05:49,380 --> 00:05:51,780
interesting and very helpful aspects so

142
00:05:51,780 --> 00:05:53,639
something which you may or may not

143
00:05:53,639 --> 00:05:55,979
expect depending on how money in the

144
00:05:55,979 --> 00:05:57,840
wild exploits you've seen

145
00:05:57,840 --> 00:05:59,759
it's full of printf statements telling

146
00:05:59,759 --> 00:06:02,340
you what it's about to do

147
00:06:02,340 --> 00:06:04,919
so for example here failed to prepare

148
00:06:04,919 --> 00:06:07,680
fake V table at some address

149
00:06:07,680 --> 00:06:09,060
but we can learn multiple things from

150
00:06:09,060 --> 00:06:10,440
this error message or from from this

151
00:06:10,440 --> 00:06:11,520
logging message

152
00:06:11,520 --> 00:06:13,320
and the most interesting when I was

153
00:06:13,320 --> 00:06:15,740
first looking at this this happens

154
00:06:15,740 --> 00:06:19,160
extremely early

155
00:06:19,259 --> 00:06:24,259
in the exploit flow in fact so early

156
00:06:24,259 --> 00:06:27,720
that something very different is going

157
00:06:27,720 --> 00:06:30,180
on in this exploit because as you saw

158
00:06:30,180 --> 00:06:33,000
with you saw the extent that Lena's had

159
00:06:33,000 --> 00:06:35,580
to go to earlier in his Fugu talk to get

160
00:06:35,580 --> 00:06:38,160
to the point where he could get PC

161
00:06:38,160 --> 00:06:41,460
control in el1 in the kernel there were

162
00:06:41,460 --> 00:06:45,539
so many steps yet within probably a

163
00:06:45,539 --> 00:06:49,080
dozen lines of code there already have

164
00:06:49,080 --> 00:06:51,360
succeeded or failed to prepare a kernel

165
00:06:51,360 --> 00:06:54,900
V table this just doesn't make sense

166
00:06:54,900 --> 00:06:56,039
if

167
00:06:56,039 --> 00:06:58,080
the next care sort of cryptic message

168
00:06:58,080 --> 00:07:00,479
they say waiting for read write

169
00:07:00,479 --> 00:07:02,160
Primitives

170
00:07:02,160 --> 00:07:03,780
they think well okay there have been

171
00:07:03,780 --> 00:07:05,639
lots and lots of race condition uh

172
00:07:05,639 --> 00:07:07,440
vulnerabilities in xmu maybe there's a

173
00:07:07,440 --> 00:07:10,620
race condition but the code hasn't has

174
00:07:10,620 --> 00:07:12,900
not got the structure indicating that it

175
00:07:12,900 --> 00:07:16,020
would be exploiting a race condition bug

176
00:07:16,020 --> 00:07:18,600
so what's going on

177
00:07:18,600 --> 00:07:20,819
and the last message is the one that

178
00:07:20,819 --> 00:07:23,099
gives us the clues to the path we have

179
00:07:23,099 --> 00:07:25,860
to follow which is unexpected data read

180
00:07:25,860 --> 00:07:28,020
from DCP

181
00:07:28,020 --> 00:07:31,080
and yeah this is the hint that there's

182
00:07:31,080 --> 00:07:32,580
something much more interesting going on

183
00:07:32,580 --> 00:07:33,599
here

184
00:07:33,599 --> 00:07:36,599
so what is the DCP the DCP is the

185
00:07:36,599 --> 00:07:39,120
display co-processor so introduced with

186
00:07:39,120 --> 00:07:43,620
the M1 Max and the iPhone 12 and 13. I'm

187
00:07:43,620 --> 00:07:45,180
subtly looking at the Apple people in

188
00:07:45,180 --> 00:07:46,440
the audience to make sure I get the

189
00:07:46,440 --> 00:07:49,340
versions correct

190
00:07:49,570 --> 00:07:51,660
[Music]

191
00:07:51,660 --> 00:07:54,419
through low level bitmap co-processor so

192
00:07:54,419 --> 00:07:57,060
it sits in between your processor and

193
00:07:57,060 --> 00:07:59,819
the display panel and is doing sort of

194
00:07:59,819 --> 00:08:02,340
the last level stuff before your frame

195
00:08:02,340 --> 00:08:04,620
buffer hits the display so for example

196
00:08:04,620 --> 00:08:08,160
on a mobile device it's talking mipi the

197
00:08:08,160 --> 00:08:10,380
protocol which the panel expects or on

198
00:08:10,380 --> 00:08:13,560
your MacBook it's doing the DisplayPort

199
00:08:13,560 --> 00:08:14,520
stuff

200
00:08:14,520 --> 00:08:17,840
it's doing tons and tons of low level

201
00:08:17,840 --> 00:08:21,300
processing on a separate piece of

202
00:08:21,300 --> 00:08:23,160
silicon in fact we can make that a bit

203
00:08:23,160 --> 00:08:24,840
more visual

204
00:08:24,840 --> 00:08:27,840
so I put this in a in a blog post and

205
00:08:27,840 --> 00:08:30,000
then someone told me that the area I

206
00:08:30,000 --> 00:08:31,800
very confidently highlighted as the

207
00:08:31,800 --> 00:08:33,719
display code processor is not the

208
00:08:33,719 --> 00:08:36,539
display code processor anyway I'm happy

209
00:08:36,539 --> 00:08:38,099
to for someone from Apple to come up and

210
00:08:38,099 --> 00:08:39,899
tell me exactly where it is but for the

211
00:08:39,899 --> 00:08:44,760
purposes of this talk it is there so

212
00:08:44,760 --> 00:08:48,300
and in the sort of 90s 2000s when you

213
00:08:48,300 --> 00:08:49,560
were building your computer that was

214
00:08:49,560 --> 00:08:51,420
this big you could see these different

215
00:08:51,420 --> 00:08:52,980
code processors and you could see the

216
00:08:52,980 --> 00:08:55,080
buses that interconnected them that

217
00:08:55,080 --> 00:08:57,779
interconnect them but now these things

218
00:08:57,779 --> 00:08:59,940
have all been compacted right down so

219
00:08:59,940 --> 00:09:02,060
that this is all happening on one

220
00:09:02,060 --> 00:09:04,440
integrated circuit on one system on a

221
00:09:04,440 --> 00:09:06,560
chip

222
00:09:07,019 --> 00:09:09,560
so

223
00:09:10,680 --> 00:09:13,620
what is actually running on here well we

224
00:09:13,620 --> 00:09:16,380
can actually get the firmware for

225
00:09:16,380 --> 00:09:20,700
this co-processor it's called DCP in the

226
00:09:20,700 --> 00:09:22,200
firmware that's how you know the this is

227
00:09:22,200 --> 00:09:24,000
the name so how you know it's the right

228
00:09:24,000 --> 00:09:26,339
it's the right binary and we can see

229
00:09:26,339 --> 00:09:30,480
it's like 3.7 megabytes

230
00:09:30,480 --> 00:09:32,700
and if we run o tool

231
00:09:32,700 --> 00:09:34,920
like it's a macho binary there's a

232
00:09:34,920 --> 00:09:36,120
little header you have to remove but

233
00:09:36,120 --> 00:09:40,080
it's just uh this is a 64-bit

234
00:09:40,080 --> 00:09:44,100
um arm 64 macro binary

235
00:09:44,100 --> 00:09:46,920
so what is actually in here

236
00:09:46,920 --> 00:09:50,880
so at this point I should point out the

237
00:09:50,880 --> 00:09:53,399
display code processor is not doing tons

238
00:09:53,399 --> 00:09:56,279
of stuff that wasn't happening before so

239
00:09:56,279 --> 00:09:58,380
lots of the functionality this

240
00:09:58,380 --> 00:10:00,120
functionality that previously lived in

241
00:10:00,120 --> 00:10:02,040
this kernel driver which was running in

242
00:10:02,040 --> 00:10:04,920
the kernel called i o mobile frame

243
00:10:04,920 --> 00:10:07,260
buffer all of these things like the

244
00:10:07,260 --> 00:10:09,899
DisplayPort Link Training the mipi

245
00:10:09,899 --> 00:10:12,300
display panel negotiation all of this

246
00:10:12,300 --> 00:10:13,920
stuff had to happen before it happened

247
00:10:13,920 --> 00:10:16,440
in the kernel and now for reasons which

248
00:10:16,440 --> 00:10:18,779
make total engineering sense it's been

249
00:10:18,779 --> 00:10:20,700
moved to a co-processor right it can

250
00:10:20,700 --> 00:10:23,580
happen on a lower performance core more

251
00:10:23,580 --> 00:10:26,880
energy efficient makes total sense

252
00:10:26,880 --> 00:10:28,019
of course

253
00:10:28,019 --> 00:10:30,180
the interesting question is well how do

254
00:10:30,180 --> 00:10:31,800
you do that how do you take all of this

255
00:10:31,800 --> 00:10:34,800
functionality and move it to this code

256
00:10:34,800 --> 00:10:37,080
processor and so here I'm going to

257
00:10:37,080 --> 00:10:39,920
reveal some pretty Secret Apple internal

258
00:10:39,920 --> 00:10:42,480
development secrets for how you would

259
00:10:42,480 --> 00:10:45,360
pour a huge driver to a co-processor

260
00:10:45,360 --> 00:10:47,399
first you would highlight the code you

261
00:10:47,399 --> 00:10:49,380
want to Port across

262
00:10:49,380 --> 00:10:53,220
you use this key combination

263
00:10:53,220 --> 00:10:56,579
to move it onto your go processor and

264
00:10:56,579 --> 00:10:59,339
this is really the case so they've taken

265
00:10:59,339 --> 00:11:02,940
a huge chunk of this existing IO kit C

266
00:11:02,940 --> 00:11:05,640
plus plus driver and moved it into this

267
00:11:05,640 --> 00:11:07,500
brand new world

268
00:11:07,500 --> 00:11:11,700
of rtkit so rtkit is Apple's real-time

269
00:11:11,700 --> 00:11:13,500
operating system

270
00:11:13,500 --> 00:11:15,839
it's I've been here it's incredibly

271
00:11:15,839 --> 00:11:18,600
poorly documented and there's no public

272
00:11:18,600 --> 00:11:20,579
reverse engineering of it I've already

273
00:11:20,579 --> 00:11:22,079
managed to find two people in the

274
00:11:22,079 --> 00:11:23,640
audience who told me that they've spent

275
00:11:23,640 --> 00:11:26,100
incredibly long time reversing this so

276
00:11:26,100 --> 00:11:27,540
if you also have come talk to me

277
00:11:27,540 --> 00:11:30,420
afterwards I've got lots of questions

278
00:11:30,420 --> 00:11:33,360
um but yes there was lots and lots and

279
00:11:33,360 --> 00:11:34,860
lots of reversing that I had to do for

280
00:11:34,860 --> 00:11:36,540
this that I'm going to skip over

281
00:11:36,540 --> 00:11:39,420
but you can see the companion uh blog

282
00:11:39,420 --> 00:11:41,579
post if you want to know all of that

283
00:11:41,579 --> 00:11:44,160
pain but effectively it's custom C plus

284
00:11:44,160 --> 00:11:46,620
plus real-time operating system

285
00:11:46,620 --> 00:11:49,380
and for the purposes of this talk the

286
00:11:49,380 --> 00:11:50,640
things which are most interesting is

287
00:11:50,640 --> 00:11:54,000
that unlike those bigger cores that we

288
00:11:54,000 --> 00:11:57,720
saw earlier on the M1 and the A14 this

289
00:11:57,720 --> 00:12:00,899
one an rtkit has no point of

290
00:12:00,899 --> 00:12:02,519
Authentication

291
00:12:02,519 --> 00:12:04,560
it has no address space layout

292
00:12:04,560 --> 00:12:06,000
randomization

293
00:12:06,000 --> 00:12:09,120
it has predictable Heap addresses and so

294
00:12:09,120 --> 00:12:11,339
you're maybe starting to see how the

295
00:12:11,339 --> 00:12:13,380
dots are going to connect that this

296
00:12:13,380 --> 00:12:15,360
exploit which looked like it really

297
00:12:15,360 --> 00:12:16,980
didn't have to do enough to defeat all

298
00:12:16,980 --> 00:12:18,360
these mitigations

299
00:12:18,360 --> 00:12:20,399
didn't have to do enough to defeat all

300
00:12:20,399 --> 00:12:21,600
these mitigations

301
00:12:21,600 --> 00:12:25,920
and if I were feeling particularly mean

302
00:12:25,920 --> 00:12:28,980
some of you will get this reference but

303
00:12:28,980 --> 00:12:31,140
I should probably move on past that

304
00:12:31,140 --> 00:12:33,720
so obviously there's a little bit more

305
00:12:33,720 --> 00:12:35,940
to it than simply all the mitigations

306
00:12:35,940 --> 00:12:37,860
are broken we can trivially compromise

307
00:12:37,860 --> 00:12:39,060
this thing

308
00:12:39,060 --> 00:12:41,160
so but to understand exactly how it

309
00:12:41,160 --> 00:12:43,260
works we need to look at how this

310
00:12:43,260 --> 00:12:45,620
communication Channel out to this

311
00:12:45,620 --> 00:12:48,420
co-processor works

312
00:12:48,420 --> 00:12:50,339
um and for this you need to know that

313
00:12:50,339 --> 00:12:53,040
they chose this boundary of code to move

314
00:12:53,040 --> 00:12:56,519
is extremely broad so really it's split

315
00:12:56,519 --> 00:12:59,279
at the external method level which is

316
00:12:59,279 --> 00:13:01,639
where you from user space would interact

317
00:13:01,639 --> 00:13:04,980
previously with iron mobile frame buffer

318
00:13:04,980 --> 00:13:08,339
now from user space perspective it looks

319
00:13:08,339 --> 00:13:09,779
like you're still interacting with Iowa

320
00:13:09,779 --> 00:13:11,459
mobile frame buffer but there's another

321
00:13:11,459 --> 00:13:14,040
level going on below it so IO connect

322
00:13:14,040 --> 00:13:16,560
call method is how you would typically

323
00:13:16,560 --> 00:13:19,079
interact with a kernel driver

324
00:13:19,079 --> 00:13:21,300
you this code would generate a Mach

325
00:13:21,300 --> 00:13:23,399
message kind of serialize message buffer

326
00:13:23,399 --> 00:13:25,560
pass it over into the kernel there's

327
00:13:25,560 --> 00:13:27,899
some code there which deserializes that

328
00:13:27,899 --> 00:13:30,540
and the kernel driver user client would

329
00:13:30,540 --> 00:13:32,040
handle it and typically it would just go

330
00:13:32,040 --> 00:13:34,380
right back up into user space

331
00:13:34,380 --> 00:13:36,240
but that's not what happens anymore at

332
00:13:36,240 --> 00:13:38,279
first get serialized in user space

333
00:13:38,279 --> 00:13:40,800
sent down to the kernel deserialized

334
00:13:40,800 --> 00:13:44,579
then re-serialized using this thing

335
00:13:44,579 --> 00:13:48,060
called DCP link RPC which will take

336
00:13:48,060 --> 00:13:50,579
literally the arguments you passed in

337
00:13:50,579 --> 00:13:52,380
user space

338
00:13:52,380 --> 00:13:54,720
serialize them again

339
00:13:54,720 --> 00:13:56,519
and push those over to the display code

340
00:13:56,519 --> 00:13:57,959
processor

341
00:13:57,959 --> 00:14:00,720
they then get processed here and proxy

342
00:14:00,720 --> 00:14:01,920
back up

343
00:14:01,920 --> 00:14:03,360
so we can look at that again with this

344
00:14:03,360 --> 00:14:05,519
model just to emphasize the fact that

345
00:14:05,519 --> 00:14:07,320
this is happening somewhere else maybe

346
00:14:07,320 --> 00:14:09,540
or maybe not exactly there so previously

347
00:14:09,540 --> 00:14:12,540
it was happening here so over here these

348
00:14:12,540 --> 00:14:14,880
oh where's my mouse

349
00:14:14,880 --> 00:14:16,980
these these four areas over here with

350
00:14:16,980 --> 00:14:19,139
the higher performance cores with the

351
00:14:19,139 --> 00:14:21,420
speculative execution bugs these are the

352
00:14:21,420 --> 00:14:23,700
lower performance energy efficient cores

353
00:14:23,700 --> 00:14:24,540
with

354
00:14:24,540 --> 00:14:27,720
fewer speculative execution bugs

355
00:14:27,720 --> 00:14:31,260
and so previously this would all happen

356
00:14:31,260 --> 00:14:32,820
in there all right that's a very high

357
00:14:32,820 --> 00:14:34,680
level way of looking at it but there are

358
00:14:34,680 --> 00:14:36,240
two different at least two different

359
00:14:36,240 --> 00:14:38,820
privilege levels on those CPUs and

360
00:14:38,820 --> 00:14:41,100
you're just flipping between those

361
00:14:41,100 --> 00:14:42,779
but whereas now what's happening it's

362
00:14:42,779 --> 00:14:44,459
you're flipping between those and then

363
00:14:44,459 --> 00:14:45,779
hopping over there

364
00:14:45,779 --> 00:14:47,339
but again that's

365
00:14:47,339 --> 00:14:48,660
not quite right right you're really

366
00:14:48,660 --> 00:14:49,980
flipping over here

367
00:14:49,980 --> 00:14:52,260
coming into the system cache maybe out

368
00:14:52,260 --> 00:14:54,480
to the DDR controller back in and back

369
00:14:54,480 --> 00:14:57,360
up there and that's super important to

370
00:14:57,360 --> 00:14:59,220
dive into in a little bit more detail to

371
00:14:59,220 --> 00:15:01,560
see why there is slightly more going on

372
00:15:01,560 --> 00:15:04,920
to why this vulnerability actually works

373
00:15:04,920 --> 00:15:08,279
so I drew this Arrow between the

374
00:15:08,279 --> 00:15:10,620
between the display code processor and

375
00:15:10,620 --> 00:15:13,139
the DDR controller but this is not

376
00:15:13,139 --> 00:15:15,720
actually really fair the display code

377
00:15:15,720 --> 00:15:17,940
processor doesn't have direct physical

378
00:15:17,940 --> 00:15:20,459
memory access there is actually

379
00:15:20,459 --> 00:15:23,639
something called in apple Pilots a dart

380
00:15:23,639 --> 00:15:25,199
which I wrote I had to write down what

381
00:15:25,199 --> 00:15:27,240
it means device address resolution table

382
00:15:27,240 --> 00:15:29,279
which for those from an Intel background

383
00:15:29,279 --> 00:15:32,579
is like an iommu the arm term would be

384
00:15:32,579 --> 00:15:36,600
smmu so I'll try and do what is an iomu

385
00:15:36,600 --> 00:15:38,279
in 30 seconds

386
00:15:38,279 --> 00:15:40,320
this is your view of physical memory

387
00:15:40,320 --> 00:15:42,420
this is the real physical memory chips

388
00:15:42,420 --> 00:15:44,579
inside your device

389
00:15:44,579 --> 00:15:46,260
and you might have in your user space

390
00:15:46,260 --> 00:15:48,540
task in your process

391
00:15:48,540 --> 00:15:51,300
a view onto some subset of that physical

392
00:15:51,300 --> 00:15:53,579
memory which can be disjoint

393
00:15:53,579 --> 00:15:56,100
so you might have this virtual address

394
00:15:56,100 --> 00:15:58,500
mapping to this physical one like this

395
00:15:58,500 --> 00:16:01,680
and this is implemented in Hardware by a

396
00:16:01,680 --> 00:16:04,579
memory management unit remember mmu

397
00:16:04,579 --> 00:16:07,260
which uses data structures also stored

398
00:16:07,260 --> 00:16:09,300
in some other place in physical memory

399
00:16:09,300 --> 00:16:12,360
well there is an analogous thing which

400
00:16:12,360 --> 00:16:14,459
is also providing a translation for

401
00:16:14,459 --> 00:16:17,040
device physical memory going the other

402
00:16:17,040 --> 00:16:19,680
way so that a device

403
00:16:19,680 --> 00:16:22,380
would use an smmu in arm Parliament to

404
00:16:22,380 --> 00:16:24,660
Dart in apple world

405
00:16:24,660 --> 00:16:26,820
to also perform a similar translation

406
00:16:26,820 --> 00:16:28,800
such that

407
00:16:28,800 --> 00:16:32,100
it can also not necessarily have to have

408
00:16:32,100 --> 00:16:34,980
everything in physical everything

409
00:16:34,980 --> 00:16:36,720
doesn't have to be physically contiguous

410
00:16:36,720 --> 00:16:40,380
but the device can see from the devices

411
00:16:40,380 --> 00:16:42,540
perspective addresses can appear

412
00:16:42,540 --> 00:16:45,000
physically contiguous even there even if

413
00:16:45,000 --> 00:16:46,259
they're perhaps not physically

414
00:16:46,259 --> 00:16:47,579
contiguous

415
00:16:47,579 --> 00:16:51,480
and on some platforms some vendors also

416
00:16:51,480 --> 00:16:53,759
use this as a security boundary and

417
00:16:53,759 --> 00:16:56,519
apple are generally pretty good at also

418
00:16:56,519 --> 00:16:58,199
using

419
00:16:58,199 --> 00:17:01,079
this ability to restrict or control

420
00:17:01,079 --> 00:17:03,420
devices views of physical memory as a

421
00:17:03,420 --> 00:17:05,339
security boundary

422
00:17:05,339 --> 00:17:07,559
um plenty of Android phones

423
00:17:07,559 --> 00:17:11,220
also have this technology but don't

424
00:17:11,220 --> 00:17:13,260
actually use it as a security boundary

425
00:17:13,260 --> 00:17:15,419
and the devices themselves are able to

426
00:17:15,419 --> 00:17:18,599
control their own smmus

427
00:17:18,599 --> 00:17:20,880
but in Apple's case this is a security

428
00:17:20,880 --> 00:17:23,099
boundary

429
00:17:23,099 --> 00:17:26,640
so I gave my extremely hand wavy

430
00:17:26,640 --> 00:17:28,919
explanation earlier of well they just

431
00:17:28,919 --> 00:17:30,900
like copy pasted the driver code and

432
00:17:30,900 --> 00:17:32,820
moved it to the co-processor so but

433
00:17:32,820 --> 00:17:35,700
obviously that's not going to work

434
00:17:35,700 --> 00:17:38,820
so above it they have rtkit providing

435
00:17:38,820 --> 00:17:41,600
the operating system sort of scheduling

436
00:17:41,600 --> 00:17:45,720
message box communication mechanisms but

437
00:17:45,720 --> 00:17:48,480
they also need whether it's also a kind

438
00:17:48,480 --> 00:17:50,880
of major engineering challenge to just

439
00:17:50,880 --> 00:17:53,520
make the code continue to function so

440
00:17:53,520 --> 00:17:56,460
this code originally expected to run in

441
00:17:56,460 --> 00:17:59,400
el1 in the context of the kernel so

442
00:17:59,400 --> 00:18:01,140
that's what the developers had in mind

443
00:18:01,140 --> 00:18:03,299
when they made when they wrote this code

444
00:18:03,299 --> 00:18:06,299
whereas now it's got to work in a

445
00:18:06,299 --> 00:18:08,340
completely different context where as

446
00:18:08,340 --> 00:18:09,419
we've seen

447
00:18:09,419 --> 00:18:13,679
it can't even access physical memory in

448
00:18:13,679 --> 00:18:16,380
the same way it was able to before

449
00:18:16,380 --> 00:18:18,240
so

450
00:18:18,240 --> 00:18:19,980
how do you solve that

451
00:18:19,980 --> 00:18:21,179
well

452
00:18:21,179 --> 00:18:23,640
to see that we need to look in slightly

453
00:18:23,640 --> 00:18:25,679
more detail at exactly how that

454
00:18:25,679 --> 00:18:28,559
Communication channel works

455
00:18:28,559 --> 00:18:30,840
so when you make your external method

456
00:18:30,840 --> 00:18:33,600
call it comes down into the kernel

457
00:18:33,600 --> 00:18:36,299
and then onto the DCP

458
00:18:36,299 --> 00:18:39,840
so there are these IO kit proxy rpcs

459
00:18:39,840 --> 00:18:41,520
which come right from the top down to

460
00:18:41,520 --> 00:18:43,320
the bottom but then there's also a

461
00:18:43,320 --> 00:18:46,440
separate family of rpcs which come up

462
00:18:46,440 --> 00:18:50,580
just one hop which enabled the DCP to

463
00:18:50,580 --> 00:18:54,000
make requests to the kernel

464
00:18:54,000 --> 00:18:58,260
and these are extremely permissive

465
00:18:58,260 --> 00:19:01,160
at least when this sample was found

466
00:19:01,160 --> 00:19:03,860
these effectively mean that the display

467
00:19:03,860 --> 00:19:06,900
co-processor can just request completely

468
00:19:06,900 --> 00:19:11,240
arbitrary mappings to be put into its

469
00:19:11,240 --> 00:19:14,340
smmu table here

470
00:19:14,340 --> 00:19:16,799
which effectively means that the

471
00:19:16,799 --> 00:19:20,460
security properties of the dart in

472
00:19:20,460 --> 00:19:23,460
Apple's case are not actually enforced

473
00:19:23,460 --> 00:19:26,280
once you have code execution

474
00:19:26,280 --> 00:19:29,220
on the display code processor

475
00:19:29,220 --> 00:19:31,500
and this is exactly what this in the

476
00:19:31,500 --> 00:19:33,840
wild exploit was doing it was building

477
00:19:33,840 --> 00:19:37,320
fake objects on the display code

478
00:19:37,320 --> 00:19:39,419
processor that themselves would make

479
00:19:39,419 --> 00:19:42,480
these Cardinal helper rpcs from the

480
00:19:42,480 --> 00:19:44,520
display code processor up to the kernel

481
00:19:44,520 --> 00:19:47,940
and back to the co-processor to map

482
00:19:47,940 --> 00:19:51,120
arbitrary kernel memory such that from

483
00:19:51,120 --> 00:19:53,100
user space they could interact with the

484
00:19:53,100 --> 00:19:55,740
DCP and simply read and write kernel

485
00:19:55,740 --> 00:19:57,840
memory

486
00:19:57,840 --> 00:19:59,820
pretty impressive

487
00:19:59,820 --> 00:20:02,640
so not much time left but we'll quickly

488
00:20:02,640 --> 00:20:03,960
look at what the actual vulnerability

489
00:20:03,960 --> 00:20:06,320
was

490
00:20:07,080 --> 00:20:10,500
the DCP and I O mobile frame buffer have

491
00:20:10,500 --> 00:20:13,860
an enormous amount of functionality and

492
00:20:13,860 --> 00:20:16,080
one of the Myriad of things that they do

493
00:20:16,080 --> 00:20:17,820
is this thing called uniformity

494
00:20:17,820 --> 00:20:19,020
compensation

495
00:20:19,020 --> 00:20:22,140
when the display panel comes from the

496
00:20:22,140 --> 00:20:24,299
factory it is not perfect

497
00:20:24,299 --> 00:20:25,500
for example there might be brightness

498
00:20:25,500 --> 00:20:28,160
discontinuities or color

499
00:20:28,160 --> 00:20:31,380
inconsistencies so it's sort of these

500
00:20:31,380 --> 00:20:33,720
inconsistencies are measured and they

501
00:20:33,720 --> 00:20:38,039
make a data structure like a 2d array

502
00:20:38,039 --> 00:20:42,000
yeah like 2D array with a size

503
00:20:42,000 --> 00:20:45,240
showing where where the inconsistencies

504
00:20:45,240 --> 00:20:47,520
are in the panel such that the gcp can

505
00:20:47,520 --> 00:20:49,260
communicate this to the panel and it can

506
00:20:49,260 --> 00:20:51,720
correct for it and I'm not going to go

507
00:20:51,720 --> 00:20:54,000
into hey Jesus about the bug but yes

508
00:20:54,000 --> 00:20:55,620
it's C plus plus there's memory

509
00:20:55,620 --> 00:20:59,100
corruption and just if you write your

510
00:20:59,100 --> 00:21:00,660
code in C plus plus this is what's going

511
00:21:00,660 --> 00:21:01,679
to happen

512
00:21:01,679 --> 00:21:03,240
I'm not going to cover it in any detail

513
00:21:03,240 --> 00:21:05,940
but go into the companion blog post and

514
00:21:05,940 --> 00:21:08,039
it covers exactly how they manage to

515
00:21:08,039 --> 00:21:09,960
turn this around

516
00:21:09,960 --> 00:21:12,600
the key takeaway is that

517
00:21:12,600 --> 00:21:14,160
this thing doesn't necessarily have new

518
00:21:14,160 --> 00:21:19,080
bugs it just has way way easier exploits

519
00:21:19,080 --> 00:21:21,780
Apple have taken the totally defensible

520
00:21:21,780 --> 00:21:23,460
position that

521
00:21:23,460 --> 00:21:25,500
fixing all the bugs is too hard

522
00:21:25,500 --> 00:21:29,100
and this is this is this is this is fine

523
00:21:29,100 --> 00:21:30,600
and they even said so we're going to

524
00:21:30,600 --> 00:21:33,059
focus on mitigations but the problem

525
00:21:33,059 --> 00:21:35,280
then is that if your mitigations also

526
00:21:35,280 --> 00:21:38,039
regress you're going to have a bad time

527
00:21:38,039 --> 00:21:41,240
and so I have to have a mandatory

528
00:21:41,240 --> 00:21:45,000
picture of an ice bag on the last slide

529
00:21:45,000 --> 00:21:46,860
so today we spoke about the display code

530
00:21:46,860 --> 00:21:49,140
processor they weren't surprising to

531
00:21:49,140 --> 00:21:51,059
learn this is not the only co-processor

532
00:21:51,059 --> 00:21:55,020
more about the always-on processor

533
00:21:55,020 --> 00:21:58,200
or the U1 Ultra wide band or the apple

534
00:21:58,200 --> 00:22:01,020
video decoder or the apple video encoder

535
00:22:01,020 --> 00:22:03,179
or the secure Enclave processor or the

536
00:22:03,179 --> 00:22:05,820
Apple GPU or the neural engine or the

537
00:22:05,820 --> 00:22:07,620
Bluetooth low energy processor or the

538
00:22:07,620 --> 00:22:10,020
Wi-Fi processor or the baseband

539
00:22:10,020 --> 00:22:12,780
so yeah plenty more to do

540
00:22:12,780 --> 00:22:13,690
thank you

541
00:22:13,690 --> 00:22:20,440
[Applause]

542
00:22:20,539 --> 00:22:23,539
thank you

543
00:22:24,120 --> 00:22:26,159
and yeah happy to answer any questions

544
00:22:26,159 --> 00:22:28,980
otherwise just come find me uh I'll be

545
00:22:28,980 --> 00:22:32,000
here until tomorrow

546
00:22:32,760 --> 00:22:35,960
there is a question at the back

547
00:22:41,720 --> 00:22:44,419
okay

548
00:22:44,419 --> 00:22:46,559
they have lots and lots and lots of

549
00:22:46,559 --> 00:22:48,059
different versions of RT kit that run

550
00:22:48,059 --> 00:22:50,580
everywhere like it's the Ed the

551
00:22:50,580 --> 00:22:52,980
operating system that runs on your right

552
00:22:52,980 --> 00:22:55,500
headphone and it also runs on your left

553
00:22:55,500 --> 00:22:56,640
headphone

554
00:22:56,640 --> 00:22:58,620
it runs absolutely everywhere and yeah

555
00:22:58,620 --> 00:23:00,600
lots lots of those code processors run

556
00:23:00,600 --> 00:23:02,220
out exactly which ones

557
00:23:02,220 --> 00:23:04,860
I'm not sure but there are people here

558
00:23:04,860 --> 00:23:06,539
who know

559
00:23:06,539 --> 00:23:08,400
they may or may not identify themselves

560
00:23:08,400 --> 00:23:10,820
to you

561
00:23:12,299 --> 00:23:15,080
oh yes

562
00:23:18,380 --> 00:23:21,780
absolutely and if you look at the tag so

563
00:23:21,780 --> 00:23:23,400
Google's threat analysis group blog post

564
00:23:23,400 --> 00:23:27,120
they go into much more detail about what

565
00:23:27,120 --> 00:23:29,700
they were actually doing with the

566
00:23:29,700 --> 00:23:32,299
implant

567
00:23:41,840 --> 00:23:44,700
and I

568
00:23:44,700 --> 00:23:48,440
said there's another analysis

569
00:23:55,640 --> 00:23:59,640
Japanese medications

570
00:24:09,360 --> 00:24:11,230
you know

571
00:24:11,230 --> 00:24:13,140
[Applause]

572
00:24:13,140 --> 00:24:14,820
I don't know if anyone though certainly

573
00:24:14,820 --> 00:24:16,320
I don't know I'm pretty sure Apple

574
00:24:16,320 --> 00:24:18,720
haven't published any of the what the

575
00:24:18,720 --> 00:24:20,940
performance impact in terms of you know

576
00:24:20,940 --> 00:24:23,520
operations per second or also like

577
00:24:23,520 --> 00:24:26,100
energy cost is to doing things like

578
00:24:26,100 --> 00:24:28,260
point of authentication I have no idea

579
00:24:28,260 --> 00:24:30,900
but I imagine it would be non-trivial

580
00:24:30,900 --> 00:24:32,580
and I think part of the advantage of

581
00:24:32,580 --> 00:24:34,620
moving these things to the lower power

582
00:24:34,620 --> 00:24:37,200
causes specifically to reduce to make

583
00:24:37,200 --> 00:24:38,880
the thing more performant but obviously

584
00:24:38,880 --> 00:24:40,980
there is a trade-off there

585
00:24:40,980 --> 00:24:43,460
so

586
00:24:43,919 --> 00:24:46,400
cool thank you bro

587
00:24:46,400 --> 00:24:53,049
[Applause]

