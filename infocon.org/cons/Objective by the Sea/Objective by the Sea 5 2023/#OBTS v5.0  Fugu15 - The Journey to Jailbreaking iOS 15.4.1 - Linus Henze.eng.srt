1
00:00:00,659 --> 00:00:03,559
bye

2
00:00:07,980 --> 00:00:11,560
a round of applause for blindness

3
00:00:11,560 --> 00:00:14,599
[Applause]

4
00:00:14,599 --> 00:00:17,220
there are four main vulnerabilities so

5
00:00:17,220 --> 00:00:19,020
we have a code signature bypass we have

6
00:00:19,020 --> 00:00:21,060
an arbitrary Chrono read rights we have

7
00:00:21,060 --> 00:00:23,039
a point authentication code bypass and

8
00:00:23,039 --> 00:00:25,140
also a PPL bypass and in the end there

9
00:00:25,140 --> 00:00:28,279
will also be a short demo

10
00:00:28,920 --> 00:00:30,180
let me start with the first

11
00:00:30,180 --> 00:00:32,640
vulnerability named fast path which is a

12
00:00:32,640 --> 00:00:34,020
contrast certificate validation

13
00:00:34,020 --> 00:00:35,160
vulnerability

14
00:00:35,160 --> 00:00:37,620
and this vulnerability is used to gain

15
00:00:37,620 --> 00:00:40,620
initial code execution on the device

16
00:00:40,620 --> 00:00:42,059
now

17
00:00:42,059 --> 00:00:45,840
code signing what is that on iOS so on

18
00:00:45,840 --> 00:00:48,539
iOS all executables that I run must be

19
00:00:48,539 --> 00:00:51,000
code signs and this is enforcing the

20
00:00:51,000 --> 00:00:52,440
Chrono by the Apple mobile file and

21
00:00:52,440 --> 00:00:54,420
circuits Econo extension

22
00:00:54,420 --> 00:00:56,039
there are two main types of code

23
00:00:56,039 --> 00:00:57,660
signatures that you need to know about

24
00:00:57,660 --> 00:00:59,520
the first one is the ad hoc code

25
00:00:59,520 --> 00:01:01,620
signature which just basically means

26
00:01:01,620 --> 00:01:05,580
that you have the code signature in the

27
00:01:05,580 --> 00:01:07,020
application you have the correct format

28
00:01:07,020 --> 00:01:08,460
of the code signature but there is no

29
00:01:08,460 --> 00:01:10,439
actual signer it's just all the

30
00:01:10,439 --> 00:01:11,880
information contained in there that is

31
00:01:11,880 --> 00:01:13,619
required and this is used for the

32
00:01:13,619 --> 00:01:16,140
pre-installed applications and

33
00:01:16,140 --> 00:01:18,540
essentially just the hash of that code

34
00:01:18,540 --> 00:01:20,880
signature plop in the file is known to

35
00:01:20,880 --> 00:01:23,460
the kernel and if the corner sees that

36
00:01:23,460 --> 00:01:25,380
hash then it will automatically allow

37
00:01:25,380 --> 00:01:27,060
execution without doing any further

38
00:01:27,060 --> 00:01:29,880
checks and yeah the other type of

39
00:01:29,880 --> 00:01:32,640
signature are the CMS signatures and

40
00:01:32,640 --> 00:01:34,259
this basically just means that in

41
00:01:34,259 --> 00:01:35,820
addition to containing the code

42
00:01:35,820 --> 00:01:37,920
signature blob we also have a signature

43
00:01:37,920 --> 00:01:41,159
in there using a certificate and

44
00:01:41,159 --> 00:01:42,600
importantly

45
00:01:42,600 --> 00:01:44,280
um yeah a code signature can also

46
00:01:44,280 --> 00:01:46,079
contain entitlements and entitlements is

47
00:01:46,079 --> 00:01:47,820
just a list of permissions that the

48
00:01:47,820 --> 00:01:50,779
application has

49
00:01:51,360 --> 00:01:52,860
now

50
00:01:52,860 --> 00:01:54,299
um yeah how does code signature

51
00:01:54,299 --> 00:01:57,119
validation work so if we assume that we

52
00:01:57,119 --> 00:01:59,759
are using a CMS signature because I mean

53
00:01:59,759 --> 00:02:01,799
ad hoc signatures we can just ignore

54
00:02:01,799 --> 00:02:03,899
them right now because yeah they they

55
00:02:03,899 --> 00:02:05,520
are hard-coded list of signatures that

56
00:02:05,520 --> 00:02:06,840
are trusted so

57
00:02:06,840 --> 00:02:09,538
Let's ignore them and um yeah how does

58
00:02:09,538 --> 00:02:12,239
the CMS signature validation work so if

59
00:02:12,239 --> 00:02:13,800
Apple mobile finds recording notices

60
00:02:13,800 --> 00:02:15,660
that an application does not have an

61
00:02:15,660 --> 00:02:17,520
Epoch signature about a CMS signature

62
00:02:17,520 --> 00:02:20,040
then it will delegate a validation of

63
00:02:20,040 --> 00:02:23,580
the signature to core trust and what

64
00:02:23,580 --> 00:02:25,319
core trust does is it ensures that the

65
00:02:25,319 --> 00:02:28,020
CMS blob itself is valued and that the

66
00:02:28,020 --> 00:02:30,540
hash inside the CMS blob actually

67
00:02:30,540 --> 00:02:33,420
matches the hash of the code signature

68
00:02:33,420 --> 00:02:35,280
afterwards after making sure that

69
00:02:35,280 --> 00:02:37,500
everything is correct it will return

70
00:02:37,500 --> 00:02:39,900
some Flags to a more fine faculty that

71
00:02:39,900 --> 00:02:42,239
indicates the exact certificate type

72
00:02:42,239 --> 00:02:44,400
like for example you can indicate that

73
00:02:44,400 --> 00:02:45,720
it was signed in the application was

74
00:02:45,720 --> 00:02:47,940
signed using a developer certificate or

75
00:02:47,940 --> 00:02:49,200
that it was signed using an app store

76
00:02:49,200 --> 00:02:52,140
certificate and importantly contrast

77
00:02:52,140 --> 00:02:55,680
will return success as long as the CMS

78
00:02:55,680 --> 00:02:59,940
blob looks valued it does not verify the

79
00:02:59,940 --> 00:03:01,080
signup

80
00:03:01,080 --> 00:03:02,940
this in itself is not a vulnerability

81
00:03:02,940 --> 00:03:04,800
simply because

82
00:03:04,800 --> 00:03:05,400
um

83
00:03:05,400 --> 00:03:08,099
yeah like for example on Mac OS if you

84
00:03:08,099 --> 00:03:10,440
run an application it might be assigned

85
00:03:10,440 --> 00:03:13,080
to yeah using an MDM certificate that is

86
00:03:13,080 --> 00:03:14,519
not known to the corner but the

87
00:03:14,519 --> 00:03:16,500
application should be trusted and

88
00:03:16,500 --> 00:03:18,480
nevertheless simply because you manually

89
00:03:18,480 --> 00:03:20,220
trusted that certificate but the Chrono

90
00:03:20,220 --> 00:03:22,860
can't check that so core trust has to

91
00:03:22,860 --> 00:03:25,680
return success even if the signer is not

92
00:03:25,680 --> 00:03:27,360
trusted

93
00:03:27,360 --> 00:03:29,159
what happens afterwards is in apple

94
00:03:29,159 --> 00:03:31,319
mobile fire and circuits if the city

95
00:03:31,319 --> 00:03:33,180
validation fails it will reject the code

96
00:03:33,180 --> 00:03:34,560
signature and the application will not

97
00:03:34,560 --> 00:03:37,739
be allowed to execute and otherwise if

98
00:03:37,739 --> 00:03:40,080
the validation succeeded then the quad

99
00:03:40,080 --> 00:03:42,780
trust Flags will be checked now if the

100
00:03:42,780 --> 00:03:44,700
quartus flags indicate that the binary

101
00:03:44,700 --> 00:03:45,780
was signed using an app store

102
00:03:45,780 --> 00:03:48,000
certificate or for the checks will be

103
00:03:48,000 --> 00:03:50,040
bypassed and the code signature will be

104
00:03:50,040 --> 00:03:51,540
accepted immediately

105
00:03:51,540 --> 00:03:53,220
otherwise the Apple mobile fan security

106
00:03:53,220 --> 00:03:54,840
Daemon which is the user space program

107
00:03:54,840 --> 00:03:58,319
will then have a chance to validate the

108
00:03:58,319 --> 00:04:00,659
code signature and make sure that the

109
00:04:00,659 --> 00:04:02,819
signer is trusted

110
00:04:02,819 --> 00:04:04,860
now I have this

111
00:04:04,860 --> 00:04:07,620
small flowchart that shows how it works

112
00:04:07,620 --> 00:04:11,580
so again we first check the code signal

113
00:04:11,580 --> 00:04:13,260
the hash of the code directory in the

114
00:04:13,260 --> 00:04:14,939
binary if it's in the trust cache it

115
00:04:14,939 --> 00:04:16,440
will accept it otherwise we will perform

116
00:04:16,440 --> 00:04:18,298
a CT validation

117
00:04:18,298 --> 00:04:20,880
evaluation succeeded if not we were

118
00:04:20,880 --> 00:04:22,860
rejected otherwise we get the quadras

119
00:04:22,860 --> 00:04:24,900
flags and if it's absolute science we

120
00:04:24,900 --> 00:04:26,639
accept the code signature and otherwise

121
00:04:26,639 --> 00:04:31,800
we request m5id to do the validation

122
00:04:31,800 --> 00:04:34,139
now what is the vulnerability here the

123
00:04:34,139 --> 00:04:36,720
vulnerability is that we directly take

124
00:04:36,720 --> 00:04:38,160
the core trust flags from the

125
00:04:38,160 --> 00:04:39,360
certificate

126
00:04:39,360 --> 00:04:42,479
and what it means is if there's a

127
00:04:42,479 --> 00:04:43,919
certain object ID present in a

128
00:04:43,919 --> 00:04:46,199
certificate then the flags will be set

129
00:04:46,199 --> 00:04:47,460
accordingly

130
00:04:47,460 --> 00:04:51,120
now if we include the App Store oid in

131
00:04:51,120 --> 00:04:52,800
the certificate then quadrust will

132
00:04:52,800 --> 00:04:54,660
return that the application was signed

133
00:04:54,660 --> 00:04:56,759
using an app store certificate

134
00:04:56,759 --> 00:04:58,440
however

135
00:04:58,440 --> 00:05:00,540
no further checks on the signer are

136
00:05:00,540 --> 00:05:03,060
performed so um

137
00:05:03,060 --> 00:05:06,600
yeah this is really a problem because if

138
00:05:06,600 --> 00:05:08,220
we go back to our flowchart we now see

139
00:05:08,220 --> 00:05:09,000
that

140
00:05:09,000 --> 00:05:11,460
the CTA valid evaluation does not

141
00:05:11,460 --> 00:05:14,280
validate the signer and if the

142
00:05:14,280 --> 00:05:15,960
evaluation succeeds then we get the flex

143
00:05:15,960 --> 00:05:17,400
which is taken directly from the

144
00:05:17,400 --> 00:05:19,680
certificate and we just claim to be an

145
00:05:19,680 --> 00:05:21,600
app store certificate then the code

146
00:05:21,600 --> 00:05:23,400
signature will be immediately accepted

147
00:05:23,400 --> 00:05:26,400
without any further checks

148
00:05:26,400 --> 00:05:28,080
which is how we get the initial code

149
00:05:28,080 --> 00:05:29,520
execution

150
00:05:29,520 --> 00:05:32,460
now how did Apple fix this it's actually

151
00:05:32,460 --> 00:05:35,160
pretty easy they now only return the

152
00:05:35,160 --> 00:05:38,580
flags if the certificate was issued by

153
00:05:38,580 --> 00:05:39,240
Apple

154
00:05:39,240 --> 00:05:42,240
otherwise no flex or Returns the

155
00:05:42,240 --> 00:05:43,919
contrast evaluation will still succeed

156
00:05:43,919 --> 00:05:47,400
but the flex will remain zero and this

157
00:05:47,400 --> 00:05:48,960
vulnerability is actually a regression

158
00:05:48,960 --> 00:05:51,060
because I was 13 and below are not

159
00:05:51,060 --> 00:05:55,520
affected they already do this check

160
00:05:55,800 --> 00:05:59,580
now the next problem is imagine that we

161
00:05:59,580 --> 00:06:01,740
have an app signed using the fast path

162
00:06:01,740 --> 00:06:04,020
vulnerability the problem is how do we

163
00:06:04,020 --> 00:06:06,840
get it on the onto the device and

164
00:06:06,840 --> 00:06:07,500
um

165
00:06:07,500 --> 00:06:09,479
and the problem is we have installed D

166
00:06:09,479 --> 00:06:11,100
which is responsible for app

167
00:06:11,100 --> 00:06:13,800
installation and it does check the code

168
00:06:13,800 --> 00:06:15,539
signature of every app before installing

169
00:06:15,539 --> 00:06:18,000
it and the problem is it is not affected

170
00:06:18,000 --> 00:06:19,800
by this vulnerability because it does a

171
00:06:19,800 --> 00:06:22,680
proper code signature check so we need

172
00:06:22,680 --> 00:06:24,600
another vulnerability

173
00:06:24,600 --> 00:06:26,759
or do we

174
00:06:26,759 --> 00:06:28,500
we can also just

175
00:06:28,500 --> 00:06:32,580
exploit this vulnerability again which

176
00:06:32,580 --> 00:06:35,460
you might note from Fugu 14.

177
00:06:35,460 --> 00:06:37,620
and yeah the patch for this

178
00:06:37,620 --> 00:06:40,500
vulnerability is actually incomplete so

179
00:06:40,500 --> 00:06:42,960
um the thing is it works out of the box

180
00:06:42,960 --> 00:06:45,120
on iOS 15.

181
00:06:45,120 --> 00:06:48,720
and um like the patch they did is just

182
00:06:48,720 --> 00:06:51,479
to make sure that let me first explain

183
00:06:51,479 --> 00:06:52,800
how the vulnerability works so the

184
00:06:52,800 --> 00:06:55,620
vulnerability works by creating a fat

185
00:06:55,620 --> 00:06:58,500
file which contains two executables the

186
00:06:58,500 --> 00:07:00,180
first one is

187
00:07:00,180 --> 00:07:02,880
uh yeah an executive table with a normal

188
00:07:02,880 --> 00:07:04,740
code signature which the device will

189
00:07:04,740 --> 00:07:06,360
accept and the other one is our

190
00:07:06,360 --> 00:07:09,360
executable and we just create that's in

191
00:07:09,360 --> 00:07:11,280
a way that install D will validate the

192
00:07:11,280 --> 00:07:12,900
first application but the kernel will

193
00:07:12,900 --> 00:07:14,940
run the second application and the only

194
00:07:14,940 --> 00:07:17,699
check Apple adults is to make sure that

195
00:07:17,699 --> 00:07:20,039
in the fat file the code signature of

196
00:07:20,039 --> 00:07:22,139
all the executive tables contained in it

197
00:07:22,139 --> 00:07:24,599
have the same team ID and as long as we

198
00:07:24,599 --> 00:07:27,120
make sure that the team ID is the same

199
00:07:27,120 --> 00:07:30,840
yeah we just easily bypass that check

200
00:07:30,840 --> 00:07:33,180
and uh yeah using both vulnerabilities

201
00:07:33,180 --> 00:07:35,160
we then have code execution on the

202
00:07:35,160 --> 00:07:37,020
device

203
00:07:37,020 --> 00:07:39,300
now the next step for every jailbreak is

204
00:07:39,300 --> 00:07:42,780
to get arbitrary Chrono read rights and

205
00:07:42,780 --> 00:07:45,479
yeah for that I'm using the oob PCI one

206
00:07:45,479 --> 00:07:47,759
ability which is vulnerability in PCI

207
00:07:47,759 --> 00:07:49,139
driver kits

208
00:07:49,139 --> 00:07:52,259
and yeah what is driver kit

209
00:07:52,259 --> 00:07:53,220
um

210
00:07:53,220 --> 00:07:56,340
let's just look at what Apple says so

211
00:07:56,340 --> 00:07:58,500
driver kit provides a fully modernized

212
00:07:58,500 --> 00:08:00,660
replacement for i o kit to create device

213
00:08:00,660 --> 00:08:04,080
drivers and additionally what Apple also

214
00:08:04,080 --> 00:08:04,979
says is

215
00:08:04,979 --> 00:08:07,020
system extensions and drivers built with

216
00:08:07,020 --> 00:08:09,240
driver kits running user space where

217
00:08:09,240 --> 00:08:11,160
they can't compromise the security or

218
00:08:11,160 --> 00:08:13,620
stability of Mac OS

219
00:08:13,620 --> 00:08:16,620
you know we'll find out if that's true

220
00:08:16,620 --> 00:08:18,360
but um

221
00:08:18,360 --> 00:08:20,520
yeah just as a small recap what is

222
00:08:20,520 --> 00:08:22,259
driver kit it's a framework for running

223
00:08:22,259 --> 00:08:25,080
drivers in user space and it allows low

224
00:08:25,080 --> 00:08:27,599
level access to devices so you actually

225
00:08:27,599 --> 00:08:30,060
have more permissions than your normal

226
00:08:30,060 --> 00:08:32,099
user space application so that you can

227
00:08:32,099 --> 00:08:36,360
actually directly talk to devices and

228
00:08:36,360 --> 00:08:39,179
yeah these various methods are exposed

229
00:08:39,179 --> 00:08:40,559
to user space and they were never

230
00:08:40,559 --> 00:08:43,679
intended to be used by untrusted codes

231
00:08:43,679 --> 00:08:46,740
but at least driver kit drivers must

232
00:08:46,740 --> 00:08:50,580
have an entitlement so it's not that bad

233
00:08:50,580 --> 00:08:52,019
well except that we have a code

234
00:08:52,019 --> 00:08:54,180
signature bypass and just grant this

235
00:08:54,180 --> 00:08:56,220
entitlements to us so

236
00:08:56,220 --> 00:08:57,899
yeah

237
00:08:57,899 --> 00:09:00,899
now PCI driver kit is

238
00:09:00,899 --> 00:09:02,399
well I mean

239
00:09:02,399 --> 00:09:04,920
drive a kit for PCI devices and it

240
00:09:04,920 --> 00:09:07,440
allows low level access to them like for

241
00:09:07,440 --> 00:09:09,660
example you can just directly read and

242
00:09:09,660 --> 00:09:12,120
write PCI device memory

243
00:09:12,120 --> 00:09:15,120
now all these methods for reading and

244
00:09:15,120 --> 00:09:17,580
writing the memory just take the memory

245
00:09:17,580 --> 00:09:20,640
index to select which of the memory

246
00:09:20,640 --> 00:09:22,620
banks you want to write into they take

247
00:09:22,620 --> 00:09:25,320
an offset and a data parameter

248
00:09:25,320 --> 00:09:28,980
and importantly they take an offset

249
00:09:28,980 --> 00:09:32,100
if we look at one of the functions that

250
00:09:32,100 --> 00:09:34,140
it provides then we will see that it's

251
00:09:34,140 --> 00:09:36,300
actually not too complicated so it

252
00:09:36,300 --> 00:09:38,220
exposes this function which takes the

253
00:09:38,220 --> 00:09:40,680
memory index offset the data parameter

254
00:09:40,680 --> 00:09:44,580
and then it will just get a i o memory

255
00:09:44,580 --> 00:09:46,380
map object

256
00:09:46,380 --> 00:09:48,720
depending on which memory index you

257
00:09:48,720 --> 00:09:49,620
specified

258
00:09:49,620 --> 00:09:52,440
and if that I O memory map object is not

259
00:09:52,440 --> 00:09:55,440
now then it will call mlio writes which

260
00:09:55,440 --> 00:09:58,260
just directly writes to the first point

261
00:09:58,260 --> 00:10:01,500
up has them and uh yeah we just get the

262
00:10:01,500 --> 00:10:03,959
virtual address of the mapping we just

263
00:10:03,959 --> 00:10:07,320
got add the offset to it and we write

264
00:10:07,320 --> 00:10:09,420
the data and we also pass the size of

265
00:10:09,420 --> 00:10:12,060
the data and um

266
00:10:12,060 --> 00:10:13,980
yeah the thing is

267
00:10:13,980 --> 00:10:16,980
the memory Index this one is checked by

268
00:10:16,980 --> 00:10:18,660
a function called memory access because

269
00:10:18,660 --> 00:10:20,399
we have to go through this memory access

270
00:10:20,399 --> 00:10:22,200
function we cannot directly call this

271
00:10:22,200 --> 00:10:23,040
one

272
00:10:23,040 --> 00:10:25,500
but the offset itself is not checked

273
00:10:25,500 --> 00:10:28,500
it's not checked in memory access and so

274
00:10:28,500 --> 00:10:30,420
it's fully attacker controlled and it's

275
00:10:30,420 --> 00:10:33,300
yeah 64 bits and as you can see here

276
00:10:33,300 --> 00:10:36,120
there are no checks to the offset and we

277
00:10:36,120 --> 00:10:38,880
just directly take the virtual address

278
00:10:38,880 --> 00:10:42,180
of that mapping and at the 64-bit offset

279
00:10:42,180 --> 00:10:43,380
tools

280
00:10:43,380 --> 00:10:45,060
there are no checks to make sure that

281
00:10:45,060 --> 00:10:46,920
the offset is actually within our

282
00:10:46,920 --> 00:10:48,839
mapping

283
00:10:48,839 --> 00:10:50,339
now how can we exploit this

284
00:10:50,339 --> 00:10:53,160
vulnerability the thing is for FUBU 15 I

285
00:10:53,160 --> 00:10:55,740
didn't want to use any kind of

286
00:10:55,740 --> 00:10:59,040
memory leak so they're basically two

287
00:10:59,040 --> 00:11:01,200
strategies you could use the first

288
00:11:01,200 --> 00:11:04,620
strategy would be to spray condom memory

289
00:11:04,620 --> 00:11:06,839
and then we could use the out of bounds

290
00:11:06,839 --> 00:11:09,240
access to league and or modify column

291
00:11:09,240 --> 00:11:11,100
pointers the only problem with this

292
00:11:11,100 --> 00:11:14,100
thread with this strategy is that the

293
00:11:14,100 --> 00:11:16,980
ppci device memory is part of the kernel

294
00:11:16,980 --> 00:11:19,440
data map and the data map unfortunately

295
00:11:19,440 --> 00:11:21,180
does not contain any Corner pointers

296
00:11:21,180 --> 00:11:24,360
only user space data and

297
00:11:24,360 --> 00:11:27,480
some device mappings

298
00:11:27,480 --> 00:11:30,839
so I'm using a different strategy here

299
00:11:30,839 --> 00:11:33,320
the thing is if you just repeatedly

300
00:11:33,320 --> 00:11:35,700
perform the out of bounds access and

301
00:11:35,700 --> 00:11:37,860
just write down the addresses you get in

302
00:11:37,860 --> 00:11:39,660
the Panic reports you will notice that

303
00:11:39,660 --> 00:11:41,540
the PCI memory address is actually

304
00:11:41,540 --> 00:11:44,579
deterministic it's like plus minus 128

305
00:11:44,579 --> 00:11:45,959
megabytes

306
00:11:45,959 --> 00:11:48,300
and additionally what we also know is

307
00:11:48,300 --> 00:11:51,000
that in the XNX and new kernel all Ram

308
00:11:51,000 --> 00:11:52,920
is mapped as part of the contiguous

309
00:11:52,920 --> 00:11:54,420
first map

310
00:11:54,420 --> 00:11:56,700
now the first map is located at a random

311
00:11:56,700 --> 00:11:58,620
offset after the corner and this offset

312
00:11:58,620 --> 00:12:01,019
can be up to one gigabyte and the Chrono

313
00:12:01,019 --> 00:12:03,420
load address itself is randomized also

314
00:12:03,420 --> 00:12:05,880
up to one gigabytes which means that we

315
00:12:05,880 --> 00:12:07,740
have two gigabytes of randomization for

316
00:12:07,740 --> 00:12:09,600
the first map but the problem is that

317
00:12:09,600 --> 00:12:11,579
modern iPhones have at least four

318
00:12:11,579 --> 00:12:13,620
gigabytes of RAM

319
00:12:13,620 --> 00:12:16,019
so if we look at the memory layouts and

320
00:12:16,019 --> 00:12:17,519
for example if we have no randomization

321
00:12:17,519 --> 00:12:20,940
we just have to counter directly here at

322
00:12:20,940 --> 00:12:23,279
for example this address please do not

323
00:12:23,279 --> 00:12:25,260
just copy that address it's probably not

324
00:12:25,260 --> 00:12:26,100
correct

325
00:12:26,100 --> 00:12:28,560
just an example and we then I have the

326
00:12:28,560 --> 00:12:30,720
first map directly afterwards

327
00:12:30,720 --> 00:12:33,180
if we assume maximum randomization so

328
00:12:33,180 --> 00:12:35,820
the Chronos randomizable one gigabytes

329
00:12:35,820 --> 00:12:37,620
and the first map is randomized by one

330
00:12:37,620 --> 00:12:39,540
gigabyte as well then the memory layout

331
00:12:39,540 --> 00:12:40,800
looks like this

332
00:12:40,800 --> 00:12:43,680
and if we compare both

333
00:12:43,680 --> 00:12:47,040
like this then we will see that right

334
00:12:47,040 --> 00:12:50,639
here this part there's an overlap

335
00:12:50,639 --> 00:12:52,860
so regardless of what the randomization

336
00:12:52,860 --> 00:12:55,980
value is those addresses are also always

337
00:12:55,980 --> 00:12:58,139
safe to access

338
00:12:58,139 --> 00:13:00,120
simply because there will always be Ram

339
00:13:00,120 --> 00:13:04,079
there and um yeah so we can do is we can

340
00:13:04,079 --> 00:13:05,880
just guess the offset to the first map

341
00:13:05,880 --> 00:13:09,000
from our PCI device memory and then we

342
00:13:09,000 --> 00:13:12,300
can just scan the memory backwards to

343
00:13:12,300 --> 00:13:14,639
find the Buddha structure which is

344
00:13:14,639 --> 00:13:18,300
always right at the start of the ram

345
00:13:18,300 --> 00:13:21,360
and once we found the budoks we already

346
00:13:21,360 --> 00:13:23,519
know a lot about O'Connor so

347
00:13:23,519 --> 00:13:26,339
yeah we can already just find out some

348
00:13:26,339 --> 00:13:28,620
some addresses but

349
00:13:28,620 --> 00:13:31,079
um yeah what you can then do is we can

350
00:13:31,079 --> 00:13:32,820
scan the initial page tables which will

351
00:13:32,820 --> 00:13:35,579
be located directly after the boot arcs

352
00:13:35,579 --> 00:13:38,339
and using these page tables we can find

353
00:13:38,339 --> 00:13:40,800
out exactly where we are within the

354
00:13:40,800 --> 00:13:43,079
first map so we can actually determine

355
00:13:43,079 --> 00:13:44,519
the offset between the start of the

356
00:13:44,519 --> 00:13:46,260
first map and where we are currently

357
00:13:46,260 --> 00:13:49,019
reading and once we have that we can

358
00:13:49,019 --> 00:13:51,180
calculate the distance between our PCI

359
00:13:51,180 --> 00:13:54,720
memory and the start of the first map

360
00:13:54,720 --> 00:13:57,720
additionally what we also know is the

361
00:13:57,720 --> 00:14:00,060
first map is always located at an L2

362
00:14:00,060 --> 00:14:02,760
boundary which means that the first map

363
00:14:02,760 --> 00:14:05,519
starting at rest will have low 25 bits

364
00:14:05,519 --> 00:14:09,300
will always be zero and yeah using a

365
00:14:09,300 --> 00:14:11,399
small calculation that you can see here

366
00:14:11,399 --> 00:14:15,600
we can then just find out the lower 25

367
00:14:15,600 --> 00:14:20,220
bits of our PCI memory simply by taking

368
00:14:20,220 --> 00:14:23,279
the offset between the PCI memory and

369
00:14:23,279 --> 00:14:25,200
our first map and Performing this

370
00:14:25,200 --> 00:14:27,779
calculation and afterwards we can just

371
00:14:27,779 --> 00:14:30,180
scan the entire Ram to find our i o

372
00:14:30,180 --> 00:14:32,399
memory map object we can verify that we

373
00:14:32,399 --> 00:14:33,839
find the correct one by checking the

374
00:14:33,839 --> 00:14:36,360
lower 25 bits and we can also check the

375
00:14:36,360 --> 00:14:39,899
size of the memory map object and yeah

376
00:14:39,899 --> 00:14:43,199
once we found that we know exactly where

377
00:14:43,199 --> 00:14:46,320
our PCI memory is located and we can

378
00:14:46,320 --> 00:14:48,660
also check the re-table of that I O

379
00:14:48,660 --> 00:14:51,180
memory map object and use it to find out

380
00:14:51,180 --> 00:14:53,279
exactly where the Chrono is located and

381
00:14:53,279 --> 00:14:55,380
what the kernel slide is

382
00:14:55,380 --> 00:14:56,760
which means that we now have an

383
00:14:56,760 --> 00:14:59,579
arbitrary read write in the kernel and

384
00:14:59,579 --> 00:15:02,100
also we can already do quite a lot with

385
00:15:02,100 --> 00:15:02,980
that

386
00:15:02,980 --> 00:15:03,420
[Music]

387
00:15:03,420 --> 00:15:04,320
um

388
00:15:04,320 --> 00:15:07,860
on later iOS versions like 15.2 some

389
00:15:07,860 --> 00:15:09,540
mitigations were introduced that

390
00:15:09,540 --> 00:15:12,000
actually make jailbreaking quite hard

391
00:15:12,000 --> 00:15:15,180
so Fugu 15 exploits yet another

392
00:15:15,180 --> 00:15:16,860
vulnerability

393
00:15:16,860 --> 00:15:18,779
this time it's the bad recovery

394
00:15:18,779 --> 00:15:20,519
vulnerability which is a point

395
00:15:20,519 --> 00:15:22,620
authentication called bypass via a

396
00:15:22,620 --> 00:15:24,120
thread fault handlers

397
00:15:24,120 --> 00:15:26,220
and there's a small recap Point

398
00:15:26,220 --> 00:15:28,620
authentication codes what is that it's

399
00:15:28,620 --> 00:15:30,420
just a cryptographic signature for

400
00:15:30,420 --> 00:15:31,980
pointers and it prevents the

401
00:15:31,980 --> 00:15:34,079
modification of critical pointers and

402
00:15:34,079 --> 00:15:36,420
data within the kernel like for example

403
00:15:36,420 --> 00:15:38,279
return addresses that are stored on a

404
00:15:38,279 --> 00:15:39,000
stack

405
00:15:39,000 --> 00:15:41,880
and yeah it's also used to provide

406
00:15:41,880 --> 00:15:44,220
control flow Integrity to prevent an

407
00:15:44,220 --> 00:15:46,139
attacker from redirecting the control

408
00:15:46,139 --> 00:15:49,980
flow and hijacking the PC register

409
00:15:49,980 --> 00:15:53,880
now what I've got Ford handlers

410
00:15:53,880 --> 00:15:55,500
um thread for handlers are a mechanism

411
00:15:55,500 --> 00:15:57,600
to handle expected faults during data

412
00:15:57,600 --> 00:15:58,800
accesses

413
00:15:58,800 --> 00:16:02,459
it allows you to store a pointer in the

414
00:16:02,459 --> 00:16:04,680
threads tract which is signed using part

415
00:16:04,680 --> 00:16:07,920
authentication codes and if a data abort

416
00:16:07,920 --> 00:16:10,139
happens in the corner and this fault

417
00:16:10,139 --> 00:16:11,519
Handler has set when the corner would

418
00:16:11,519 --> 00:16:13,920
jump directly to it

419
00:16:13,920 --> 00:16:16,440
what is this used for this is an example

420
00:16:16,440 --> 00:16:19,440
this is copy in

421
00:16:19,440 --> 00:16:22,019
um I mean it's just a function to copy

422
00:16:22,019 --> 00:16:24,839
some data from a user Space Program to

423
00:16:24,839 --> 00:16:27,600
the kernel and assume that a programmed

424
00:16:27,600 --> 00:16:29,279
as a source call and passes in an

425
00:16:29,279 --> 00:16:31,320
address and the corner now needs to copy

426
00:16:31,320 --> 00:16:33,360
the data from that address and we'll use

427
00:16:33,360 --> 00:16:35,880
for example this copy and function files

428
00:16:35,880 --> 00:16:37,980
and it will first

429
00:16:37,980 --> 00:16:40,079
set the recovery Handler to a function

430
00:16:40,079 --> 00:16:42,420
called copy i o error

431
00:16:42,420 --> 00:16:46,079
and then it would try to load

432
00:16:46,079 --> 00:16:48,720
um the X8 register from the pointer pass

433
00:16:48,720 --> 00:16:50,220
in x0

434
00:16:50,220 --> 00:16:52,259
now if we assume that the user Space

435
00:16:52,259 --> 00:16:54,120
Program passed an entire pointer or

436
00:16:54,120 --> 00:16:56,040
there's no memory there

437
00:16:56,040 --> 00:16:59,579
then a data abort may occur normally

438
00:16:59,579 --> 00:17:02,220
this would cause a panic but because we

439
00:17:02,220 --> 00:17:04,679
expect this data robot to happen the

440
00:17:04,679 --> 00:17:06,900
confidence that jump to copy IO error

441
00:17:06,900 --> 00:17:08,640
which will just make sure that this

442
00:17:08,640 --> 00:17:11,419
function returns an error code

443
00:17:11,419 --> 00:17:14,780
and um

444
00:17:14,939 --> 00:17:17,880
now we actually do have a function that

445
00:17:17,880 --> 00:17:20,099
has a vulnerability it's kind of large

446
00:17:20,099 --> 00:17:21,480
so

447
00:17:21,480 --> 00:17:23,160
um it doesn't even matter what this

448
00:17:23,160 --> 00:17:25,559
function does so I'll just remove all

449
00:17:25,559 --> 00:17:27,419
the uninteresting stuff

450
00:17:27,419 --> 00:17:29,820
and what this function does is it also

451
00:17:29,820 --> 00:17:31,679
sets a recovery Handler

452
00:17:31,679 --> 00:17:33,600
and the recovery Handler is essentially

453
00:17:33,600 --> 00:17:35,340
just this code

454
00:17:35,340 --> 00:17:38,160
and if you look at the code you might

455
00:17:38,160 --> 00:17:39,179
think

456
00:17:39,179 --> 00:17:41,340
where's the vulnerability in here

457
00:17:41,340 --> 00:17:44,640
and um yeah the problem is

458
00:17:44,640 --> 00:17:48,720
this return down here this is a normal

459
00:17:48,720 --> 00:17:50,640
return this is not an authenticated

460
00:17:50,640 --> 00:17:51,780
return

461
00:17:51,780 --> 00:17:54,120
and um usually this wouldn't be a

462
00:17:54,120 --> 00:17:55,860
problem because this function does not

463
00:17:55,860 --> 00:18:00,960
ever change the link register but um we

464
00:18:00,960 --> 00:18:03,059
will soon see that you cannot assume

465
00:18:03,059 --> 00:18:05,280
that the link register is actually

466
00:18:05,280 --> 00:18:08,580
yeah has the value that it should have

467
00:18:08,580 --> 00:18:10,980
and what is the strategy to exploit this

468
00:18:10,980 --> 00:18:13,080
you can actually we can just call this

469
00:18:13,080 --> 00:18:14,220
function

470
00:18:14,220 --> 00:18:17,460
somehow like magpwood Madras will

471
00:18:17,460 --> 00:18:19,919
internally call this function and what

472
00:18:19,919 --> 00:18:22,140
we can do is we can just steal the sign

473
00:18:22,140 --> 00:18:23,820
forward Handler that will be set in our

474
00:18:23,820 --> 00:18:26,280
thread because we have arbitrary colon

475
00:18:26,280 --> 00:18:28,799
read write we can easily just copy these

476
00:18:28,799 --> 00:18:29,640
signs

477
00:18:29,640 --> 00:18:31,260
thread Hunter

478
00:18:31,260 --> 00:18:33,419
and yeah

479
00:18:33,419 --> 00:18:34,980
what we can later do is we can just

480
00:18:34,980 --> 00:18:37,020
restore the fault Handler and then

481
00:18:37,020 --> 00:18:39,299
perform a Cisco and if we now make sure

482
00:18:39,299 --> 00:18:42,120
that data abort happens shortly after we

483
00:18:42,120 --> 00:18:45,480
do the Cisco then most of the registers

484
00:18:45,480 --> 00:18:47,160
will be user controlled because if you

485
00:18:47,160 --> 00:18:50,520
do a syscore every register will be user

486
00:18:50,520 --> 00:18:53,700
controlled except for the stack pointer

487
00:18:53,700 --> 00:18:56,460
now the strategy here is the kernel

488
00:18:56,460 --> 00:18:59,280
accesses the user space register State

489
00:18:59,280 --> 00:19:03,360
before our registers are trashed and the

490
00:19:03,360 --> 00:19:05,280
reason is the Chrono obviously has to

491
00:19:05,280 --> 00:19:08,039
save those registers somewhere and what

492
00:19:08,039 --> 00:19:09,539
we can do is we can just change the

493
00:19:09,539 --> 00:19:12,000
register State pointer in order to force

494
00:19:12,000 --> 00:19:13,880
the data aboard

495
00:19:13,880 --> 00:19:17,100
the only problem is that the kernel must

496
00:19:17,100 --> 00:19:18,600
be able to save the stack pointer

497
00:19:18,600 --> 00:19:20,580
because if it can save the stack pointer

498
00:19:20,580 --> 00:19:23,700
it will continue to use the kernels

499
00:19:23,700 --> 00:19:25,740
stack pointer and will then trigger a

500
00:19:25,740 --> 00:19:28,380
data abort and if the stack pointer is

501
00:19:28,380 --> 00:19:29,940
set to the kernel stack pointer to the

502
00:19:29,940 --> 00:19:32,640
el1 stack pointer then this will always

503
00:19:32,640 --> 00:19:34,860
cause a panic so we need to make sure

504
00:19:34,860 --> 00:19:36,539
that it's able to save the stack pointer

505
00:19:36,539 --> 00:19:40,020
and then switch to the user space stack

506
00:19:40,020 --> 00:19:42,240
which is also used in Chrono mode as the

507
00:19:42,240 --> 00:19:43,620
Chrono stack

508
00:19:43,620 --> 00:19:45,960
but with a different value obviously

509
00:19:45,960 --> 00:19:48,720
so um the solution is we just make sure

510
00:19:48,720 --> 00:19:51,120
that our user space register state is

511
00:19:51,120 --> 00:19:53,400
mapped up to the SP register and

512
00:19:53,400 --> 00:19:55,919
unmapped afterwards

513
00:19:55,919 --> 00:19:57,840
so the Conor is able to save the stack

514
00:19:57,840 --> 00:19:59,160
pointer and if it wants to save other

515
00:19:59,160 --> 00:20:01,380
registers later then it just trigger

516
00:20:01,380 --> 00:20:04,980
data upwards and yeah

517
00:20:04,980 --> 00:20:07,380
now an additional problem is there's a

518
00:20:07,380 --> 00:20:09,780
stacked check actually and when we

519
00:20:09,780 --> 00:20:11,820
trigger the data Awards the stack

520
00:20:11,820 --> 00:20:13,860
pointer will point to the top of the

521
00:20:13,860 --> 00:20:16,200
kernel stack but the problem is that

522
00:20:16,200 --> 00:20:18,660
this check will kill us and if that's

523
00:20:18,660 --> 00:20:19,740
the case

524
00:20:19,740 --> 00:20:21,960
I'm not entirely sure why

525
00:20:21,960 --> 00:20:25,620
they decided to check if the

526
00:20:25,620 --> 00:20:27,240
stack pointer matches the top of the

527
00:20:27,240 --> 00:20:30,179
kernel stack but they do it and this

528
00:20:30,179 --> 00:20:32,640
will actually kill us so what we have to

529
00:20:32,640 --> 00:20:34,679
do is we just

530
00:20:34,679 --> 00:20:37,380
um we relocate the cpu's interrupt stack

531
00:20:37,380 --> 00:20:39,480
to somewhere else make sure that our

532
00:20:39,480 --> 00:20:40,980
stack pointer overlaps with the

533
00:20:40,980 --> 00:20:44,340
interrupt stack and then we can just we

534
00:20:44,340 --> 00:20:47,100
will fail the first check but we will

535
00:20:47,100 --> 00:20:48,840
pass the second one which checks the

536
00:20:48,840 --> 00:20:50,820
interrupt stack pointer

537
00:20:50,820 --> 00:20:53,340
and um

538
00:20:53,340 --> 00:20:55,860
yeah so what we do is we as I said we

539
00:20:55,860 --> 00:20:57,240
replace the corner stack pointer and the

540
00:20:57,240 --> 00:21:00,000
CPUs interrupt stack pointer and

541
00:21:00,000 --> 00:21:01,320
importantly this will not actually

542
00:21:01,320 --> 00:21:03,179
change the cpu's interrupt stack because

543
00:21:03,179 --> 00:21:06,299
that's impossible but it will change the

544
00:21:06,299 --> 00:21:08,280
stack pointer in that data structure and

545
00:21:08,280 --> 00:21:10,980
the kernel will be able to verify it

546
00:21:10,980 --> 00:21:13,620
um yeah and after ensuring that the

547
00:21:13,620 --> 00:21:14,760
counter stack pointer and the CPUs

548
00:21:14,760 --> 00:21:17,039
interrupt stack overlap we will then

549
00:21:17,039 --> 00:21:19,380
pass all the checks we will trigger the

550
00:21:19,380 --> 00:21:23,160
data aboard and we will be at the

551
00:21:23,160 --> 00:21:26,160
recovery Handler right at this code

552
00:21:26,160 --> 00:21:29,220
and the thing is all registers except

553
00:21:29,220 --> 00:21:31,320
for x0

554
00:21:31,320 --> 00:21:34,620
nx1 and the stack pointer I just

555
00:21:34,620 --> 00:21:36,360
completely user space controlled at this

556
00:21:36,360 --> 00:21:39,419
point the other two registers so x0 and

557
00:21:39,419 --> 00:21:41,039
X1 are not controlled simply because the

558
00:21:41,039 --> 00:21:43,799
corner will trash them but uh yeah the

559
00:21:43,799 --> 00:21:45,539
other others are and we just have to

560
00:21:45,539 --> 00:21:48,840
make sure that this first macro which

561
00:21:48,840 --> 00:21:50,940
expands to this and just make sure that

562
00:21:50,940 --> 00:21:53,100
x16 points to somewhere memory location

563
00:21:53,100 --> 00:21:55,620
so that the store succeeds then we'll

564
00:21:55,620 --> 00:21:57,900
trash the x0 register by writing zero to

565
00:21:57,900 --> 00:22:00,600
it and then we will return and this

566
00:22:00,600 --> 00:22:02,220
return is not an authenticated return

567
00:22:02,220 --> 00:22:04,380
which means it will just use the value

568
00:22:04,380 --> 00:22:06,179
in the link register and jump directly

569
00:22:06,179 --> 00:22:08,159
to it

570
00:22:08,159 --> 00:22:09,480
yeah

571
00:22:09,480 --> 00:22:12,600
it's just as I have explained and um so

572
00:22:12,600 --> 00:22:16,140
now we did an unauthenticated return and

573
00:22:16,140 --> 00:22:17,880
um yeah so which means we can jump

574
00:22:17,880 --> 00:22:19,559
wherever we want and we control almost

575
00:22:19,559 --> 00:22:22,080
all registers and using jump oriented

576
00:22:22,080 --> 00:22:23,400
programming or return oriented

577
00:22:23,400 --> 00:22:25,740
programming we can just then turn this

578
00:22:25,740 --> 00:22:28,440
into an arbitrary counter core

579
00:22:28,440 --> 00:22:30,539
and yeah

580
00:22:30,539 --> 00:22:31,980
the thing is

581
00:22:31,980 --> 00:22:34,740
one mitigation is still left

582
00:22:34,740 --> 00:22:37,500
and

583
00:22:37,500 --> 00:22:39,799
I just cannot

584
00:22:39,799 --> 00:22:43,140
submits something without breaking all

585
00:22:43,140 --> 00:22:45,900
the mitigations present in iOS

586
00:22:45,900 --> 00:22:47,340
so

587
00:22:47,340 --> 00:22:49,140
there's yet another vulnerability this

588
00:22:49,140 --> 00:22:51,900
is the last one I promised and it's

589
00:22:51,900 --> 00:22:55,260
called tlb fail which is a PPL bypass

590
00:22:55,260 --> 00:22:57,179
what is PPO PPL is the page protection

591
00:22:57,179 --> 00:23:00,539
layer and it protects signed user space

592
00:23:00,539 --> 00:23:02,760
code and also some kernel data

593
00:23:02,760 --> 00:23:05,640
especially on iOS 15.2 and later from

594
00:23:05,640 --> 00:23:08,580
being modified even by the Chrono

595
00:23:08,580 --> 00:23:10,500
so it's essentially the last line of

596
00:23:10,500 --> 00:23:12,120
defense and it's higher privilege than

597
00:23:12,120 --> 00:23:13,559
the Chrono itself

598
00:23:13,559 --> 00:23:15,480
and um

599
00:23:15,480 --> 00:23:19,500
yeah what PPL also manages are the page

600
00:23:19,500 --> 00:23:22,740
tables because as PPL just prevents the

601
00:23:22,740 --> 00:23:25,559
corner from writing to protected Pages

602
00:23:25,559 --> 00:23:27,299
it has to make sure that the Chrono just

603
00:23:27,299 --> 00:23:29,400
can't modify the page tables itself

604
00:23:29,400 --> 00:23:31,260
because otherwise it could just map the

605
00:23:31,260 --> 00:23:32,760
protected memory

606
00:23:32,760 --> 00:23:34,080
and

607
00:23:34,080 --> 00:23:35,880
um yeah it does provide some functions

608
00:23:35,880 --> 00:23:37,559
to the corner in order to map an unknown

609
00:23:37,559 --> 00:23:40,740
memory but whenever you pass a page that

610
00:23:40,740 --> 00:23:43,080
you want to map then it will obviously

611
00:23:43,080 --> 00:23:44,760
perform some checks to make sure that

612
00:23:44,760 --> 00:23:46,500
you're not trying to map PPL protected

613
00:23:46,500 --> 00:23:48,720
memory

614
00:23:48,720 --> 00:23:51,480
now another feature we have is the

615
00:23:51,480 --> 00:23:53,880
so-called nested page tables they are

616
00:23:53,880 --> 00:23:55,679
used for the DIY D shared cache because

617
00:23:55,679 --> 00:23:57,900
with the yd share cache is a large file

618
00:23:57,900 --> 00:24:00,000
it's mapped into every process and

619
00:24:00,000 --> 00:24:02,039
actually creating page tables for every

620
00:24:02,039 --> 00:24:05,640
process would consume a lot of memory so

621
00:24:05,640 --> 00:24:07,679
what Apple decided to do in status they

622
00:24:07,679 --> 00:24:11,520
nest those page tables and what that

623
00:24:11,520 --> 00:24:14,159
means is if we have an example like this

624
00:24:14,159 --> 00:24:17,400
so we have two applications A and B and

625
00:24:17,400 --> 00:24:18,840
both applications have the level one

626
00:24:18,840 --> 00:24:21,059
table they have a level two table there

627
00:24:21,059 --> 00:24:24,659
but they both map the Dual ID she had

628
00:24:24,659 --> 00:24:28,020
cache and the diva ID chat cache itself

629
00:24:28,020 --> 00:24:29,760
also has its own level one table and

630
00:24:29,760 --> 00:24:31,860
level two table and then it has a level

631
00:24:31,860 --> 00:24:33,960
three tailor which actually points to

632
00:24:33,960 --> 00:24:37,020
the pages in the Dual ID share cache and

633
00:24:37,020 --> 00:24:39,360
instead of applications A and B having

634
00:24:39,360 --> 00:24:41,940
their own level three table they just

635
00:24:41,940 --> 00:24:45,000
share the same level three table which

636
00:24:45,000 --> 00:24:48,000
then points to the page which says

637
00:24:48,000 --> 00:24:51,300
really a lot of memory

638
00:24:51,300 --> 00:24:51,840
[Music]

639
00:24:51,840 --> 00:24:52,559
um

640
00:24:52,559 --> 00:24:55,679
but the thing is if you are having to do

641
00:24:55,679 --> 00:24:57,539
something to do with page tables there's

642
00:24:57,539 --> 00:24:59,400
also a so-called translation look at

643
00:24:59,400 --> 00:25:01,320
site buffer a translation look a site

644
00:25:01,320 --> 00:25:04,020
buffer is essentially just a cache for

645
00:25:04,020 --> 00:25:05,820
virtual to physical address translation

646
00:25:05,820 --> 00:25:08,760
so if you access an address the CPU will

647
00:25:08,760 --> 00:25:09,780
actually have to find out the

648
00:25:09,780 --> 00:25:11,880
corresponding physical address and it

649
00:25:11,880 --> 00:25:14,340
will cache this translation and whenever

650
00:25:14,340 --> 00:25:17,220
you change something in the page tables

651
00:25:17,220 --> 00:25:18,900
you actually have to do a tlb flush

652
00:25:18,900 --> 00:25:21,179
simply to make sure that the CPU does

653
00:25:21,179 --> 00:25:23,700
not use the cached entries anymore and

654
00:25:23,700 --> 00:25:25,860
the thing is these tlb entries may also

655
00:25:25,860 --> 00:25:27,960
have an address space ID and the reason

656
00:25:27,960 --> 00:25:29,820
for that is if you have multiple

657
00:25:29,820 --> 00:25:32,039
applications that map data at the same

658
00:25:32,039 --> 00:25:34,980
address then if you only change the page

659
00:25:34,980 --> 00:25:37,080
tables of one application you also just

660
00:25:37,080 --> 00:25:38,820
want to flush the cache for that

661
00:25:38,820 --> 00:25:41,220
application and not for all the other

662
00:25:41,220 --> 00:25:42,299
applications

663
00:25:42,299 --> 00:25:43,679
now

664
00:25:43,679 --> 00:25:45,960
the slash ring is actually a bit

665
00:25:45,960 --> 00:25:48,240
complicated but what this code

666
00:25:48,240 --> 00:25:52,039
essentially does is it checks if

667
00:25:52,039 --> 00:25:55,020
the page table you're operating on is a

668
00:25:55,020 --> 00:25:57,240
nested page table if it is a nested page

669
00:25:57,240 --> 00:25:59,760
table then what we have to do is we have

670
00:25:59,760 --> 00:26:03,360
to flush all entries regard regardless

671
00:26:03,360 --> 00:26:06,480
of the application address space ID

672
00:26:06,480 --> 00:26:08,700
presents in that entry simply because

673
00:26:08,700 --> 00:26:10,380
those entries are shared between

674
00:26:10,380 --> 00:26:13,020
multiple applications and if we do

675
00:26:13,020 --> 00:26:14,640
changes to the Dubai D shared cache that

676
00:26:14,640 --> 00:26:17,460
we have to flush the cache for all

677
00:26:17,460 --> 00:26:19,559
applications otherwise if it's not a

678
00:26:19,559 --> 00:26:22,020
NASA pmap or not a nested page table

679
00:26:22,020 --> 00:26:25,559
then we can just take the address space

680
00:26:25,559 --> 00:26:28,500
ID and perform a flash based on the

681
00:26:28,500 --> 00:26:31,400
address space ID

682
00:26:31,500 --> 00:26:35,580
now um yeah the question now is what

683
00:26:35,580 --> 00:26:39,679
would happen if we delete a nested entry

684
00:26:39,679 --> 00:26:42,900
through our applications page table

685
00:26:42,900 --> 00:26:46,740
instead of going through the dyld shared

686
00:26:46,740 --> 00:26:49,500
cache page table

687
00:26:49,500 --> 00:26:51,600
what would happen was like if we start

688
00:26:51,600 --> 00:26:53,940
like this so we have two applications

689
00:26:53,940 --> 00:26:57,179
again A and B and we have the debug ID

690
00:26:57,179 --> 00:27:00,720
shut cache here again as you can see the

691
00:27:00,720 --> 00:27:02,760
level three table is again mapped and

692
00:27:02,760 --> 00:27:05,100
divided shared caching both applications

693
00:27:05,100 --> 00:27:08,120
and if we assume that both applications

694
00:27:08,120 --> 00:27:11,039
accessed this page X then the

695
00:27:11,039 --> 00:27:12,299
translation look aside buffer will

696
00:27:12,299 --> 00:27:15,299
contain two entries one for the address

697
00:27:15,299 --> 00:27:18,419
space id1 and for actual space it id2

698
00:27:18,419 --> 00:27:20,640
which corresponds to application a and

699
00:27:20,640 --> 00:27:22,260
application B

700
00:27:22,260 --> 00:27:25,320
and yeah we have both of these cached

701
00:27:25,320 --> 00:27:26,940
entries and

702
00:27:26,940 --> 00:27:29,940
let's assume that we now delete

703
00:27:29,940 --> 00:27:34,580
the mapping to page X not through

704
00:27:34,580 --> 00:27:38,340
cache but through application B what

705
00:27:38,340 --> 00:27:41,100
will happen is the code responsible for

706
00:27:41,100 --> 00:27:43,320
flushing the tlb

707
00:27:43,320 --> 00:27:46,020
but notice that we specified an

708
00:27:46,020 --> 00:27:47,820
application page table

709
00:27:47,820 --> 00:27:50,220
and the

710
00:27:50,220 --> 00:27:52,980
yeah just flush the entry for

711
00:27:52,980 --> 00:27:55,620
application B although it should have

712
00:27:55,620 --> 00:27:58,620
also flushed the entry for application a

713
00:27:58,620 --> 00:28:00,900
which means that application a can

714
00:28:00,900 --> 00:28:02,700
through the translation look a side

715
00:28:02,700 --> 00:28:05,340
buffer still access page X

716
00:28:05,340 --> 00:28:07,559
but this page X now has a rough count of

717
00:28:07,559 --> 00:28:11,400
zero and can be freely reused

718
00:28:11,400 --> 00:28:15,840
and yeah what we can do now is we can

719
00:28:15,840 --> 00:28:20,340
just tell PPL that this page X is now

720
00:28:20,340 --> 00:28:22,200
owned by PPL

721
00:28:22,200 --> 00:28:24,059
and

722
00:28:24,059 --> 00:28:27,539
because the PPR just can't take

723
00:28:27,539 --> 00:28:29,520
arbitrary memory so the coroner actually

724
00:28:29,520 --> 00:28:32,039
has Grand memory to the PPL

725
00:28:32,039 --> 00:28:34,220
and after doing that

726
00:28:34,220 --> 00:28:36,600
we can then

727
00:28:36,600 --> 00:28:39,000
still access this page X through the

728
00:28:39,000 --> 00:28:41,279
sale tlb entry

729
00:28:41,279 --> 00:28:43,500
and yeah so

730
00:28:43,500 --> 00:28:45,720
we just marked this page as being PPL

731
00:28:45,720 --> 00:28:48,539
out and we can still access it through a

732
00:28:48,539 --> 00:28:51,480
translation looks like buffer and we can

733
00:28:51,480 --> 00:28:52,860
force

734
00:28:52,860 --> 00:28:57,779
the PPL to actually reuse page X as a

735
00:28:57,779 --> 00:28:59,520
level 3 page table

736
00:28:59,520 --> 00:29:01,980
now our application a it has this

737
00:29:01,980 --> 00:29:04,380
additional level three page table

738
00:29:04,380 --> 00:29:05,700
but

739
00:29:05,700 --> 00:29:08,760
it can also directly write to the page

740
00:29:08,760 --> 00:29:10,980
table simply because it's still in the

741
00:29:10,980 --> 00:29:12,539
TLP

742
00:29:12,539 --> 00:29:15,840
and what we just do is we

743
00:29:15,840 --> 00:29:19,919
create another entry in page in table

744
00:29:19,919 --> 00:29:24,000
three which Maps our page X and

745
00:29:24,000 --> 00:29:27,120
yeah afterwards we just ignore you can

746
00:29:27,120 --> 00:29:28,919
this doesn't matter if in the

747
00:29:28,919 --> 00:29:30,179
translation looks like buffer if that

748
00:29:30,179 --> 00:29:31,740
entry is flushed at some point because

749
00:29:31,740 --> 00:29:35,039
we now create just created an entry that

750
00:29:35,039 --> 00:29:37,440
points to our level three table and we

751
00:29:37,440 --> 00:29:39,899
can just directly write to our level

752
00:29:39,899 --> 00:29:41,880
three table now and people are

753
00:29:41,880 --> 00:29:43,740
completely bypassed since we can just

754
00:29:43,740 --> 00:29:47,760
map arbitrary PPR protected memory

755
00:29:47,760 --> 00:29:50,039
and yeah so

756
00:29:50,039 --> 00:29:52,440
this is essentially

757
00:29:52,440 --> 00:29:54,419
all of the vulnerabilities and Frugal 15

758
00:29:54,419 --> 00:29:56,399
and the thing is I know you want to see

759
00:29:56,399 --> 00:29:58,799
a demo now

760
00:29:58,799 --> 00:30:01,140
and

761
00:30:01,140 --> 00:30:03,659
this will be partially a live demo

762
00:30:03,659 --> 00:30:06,600
partially not simply because I can't

763
00:30:06,600 --> 00:30:08,880
show the first part it just takes way

764
00:30:08,880 --> 00:30:11,640
too long because yeah the the Wi-Fi in

765
00:30:11,640 --> 00:30:13,740
here is not great

766
00:30:13,740 --> 00:30:14,940
so

767
00:30:14,940 --> 00:30:17,159
um yeah what you will also see here is

768
00:30:17,159 --> 00:30:20,460
how you get the fugu 15 app onto the

769
00:30:20,460 --> 00:30:23,640
device so if I start this

770
00:30:23,640 --> 00:30:26,399
what you can see here is I open Safari

771
00:30:26,399 --> 00:30:29,460
and I go to my website which has this

772
00:30:29,460 --> 00:30:31,140
nice tab here to install Google 15

773
00:30:31,140 --> 00:30:32,460
button

774
00:30:32,460 --> 00:30:34,559
and just tap on it

775
00:30:34,559 --> 00:30:36,740
and you will see a

776
00:30:36,740 --> 00:30:38,520
jetbrackme.pinouten.te would like to

777
00:30:38,520 --> 00:30:41,399
install totally legit developer app

778
00:30:41,399 --> 00:30:42,659
and

779
00:30:42,659 --> 00:30:44,520
um yeah I mean what everyone will do now

780
00:30:44,520 --> 00:30:46,679
is just tap on install

781
00:30:46,679 --> 00:30:48,779
and if we do that

782
00:30:48,779 --> 00:30:52,320
and go back to the home screen then yeah

783
00:30:52,320 --> 00:30:55,380
it will just start downloading and this

784
00:30:55,380 --> 00:30:57,840
unfortunately takes quite a while

785
00:30:57,840 --> 00:31:00,779
because of the slow Wi-Fi

786
00:31:00,779 --> 00:31:04,200
so if we fast forward a bit

787
00:31:04,200 --> 00:31:06,480
then it's installed and what you can see

788
00:31:06,480 --> 00:31:09,360
here is you don't see the Frugal 15 app

789
00:31:09,360 --> 00:31:10,980
but instead you see the Apple developer

790
00:31:10,980 --> 00:31:15,240
app and the reason for that is I need a

791
00:31:15,240 --> 00:31:16,919
validly signed up in order to get full

792
00:31:16,919 --> 00:31:19,440
15 onto the device but I can use the

793
00:31:19,440 --> 00:31:21,899
install D vulnerability to inject FUBU

794
00:31:21,899 --> 00:31:24,000
15 into that signed app

795
00:31:24,000 --> 00:31:26,580
and if we open that

796
00:31:26,580 --> 00:31:29,340
you will see if we will install but just

797
00:31:29,340 --> 00:31:32,820
installs the fugu 15 app onto the device

798
00:31:32,820 --> 00:31:35,760
and automatically opens it then you will

799
00:31:35,760 --> 00:31:37,200
be asked to if you want to remove the

800
00:31:37,200 --> 00:31:39,360
developer app because it's not needed

801
00:31:39,360 --> 00:31:42,299
anymore so just tap on remove

802
00:31:42,299 --> 00:31:46,620
and yeah you can just tap on jailbreak

803
00:31:46,620 --> 00:31:48,720
which takes a few seconds and you get a

804
00:31:48,720 --> 00:31:50,460
success match in the message which means

805
00:31:50,460 --> 00:31:54,539
that I download which is like a small

806
00:31:54,539 --> 00:31:56,299
application that I always include

807
00:31:56,299 --> 00:31:59,399
actually uh yeah

808
00:31:59,399 --> 00:32:02,399
has is now running on the device

809
00:32:02,399 --> 00:32:06,860
and if I now switch back

810
00:32:06,860 --> 00:32:08,760
to

811
00:32:08,760 --> 00:32:12,559
quick time as it's

812
00:32:14,700 --> 00:32:16,740
ah

813
00:32:16,740 --> 00:32:19,799
I just go on

814
00:32:19,799 --> 00:32:22,020
it doesn't matter so what we now have

815
00:32:22,020 --> 00:32:24,840
now here is we have a lock

816
00:32:24,840 --> 00:32:26,760
it just shows everything that we have

817
00:32:26,760 --> 00:32:27,659
done

818
00:32:27,659 --> 00:32:32,159
and um yeah back to the actual device

819
00:32:32,159 --> 00:32:34,140
please oh there we are

820
00:32:34,140 --> 00:32:36,480
so this is my actual device so I can

821
00:32:36,480 --> 00:32:39,179
actually show you like

822
00:32:39,179 --> 00:32:41,880
currently on that device

823
00:32:41,880 --> 00:32:44,460
and we can go back to the home screen

824
00:32:44,460 --> 00:32:46,740
and we now have this

825
00:32:46,740 --> 00:32:50,220
Xiao here

826
00:32:50,220 --> 00:32:52,500
I hope you can read that

827
00:32:52,500 --> 00:32:55,260
so we have the trail here I can just

828
00:32:55,260 --> 00:32:56,880
type in help to see some of the

829
00:32:56,880 --> 00:32:59,640
available commands but there's for

830
00:32:59,640 --> 00:33:02,159
example in K info command to just yeah

831
00:33:02,159 --> 00:33:04,740
show where the kernel is mapped the kind

832
00:33:04,740 --> 00:33:07,799
of Base address there's also an r64

833
00:33:07,799 --> 00:33:11,419
command to read kind of memory

834
00:33:11,419 --> 00:33:13,740
and additionally we can also run

835
00:33:13,740 --> 00:33:16,500
bootstrap

836
00:33:16,500 --> 00:33:18,360
which will install the proclasses

837
00:33:18,360 --> 00:33:20,299
bootstrap onto the device

838
00:33:20,299 --> 00:33:25,200
and if I now run you I cache

839
00:33:25,200 --> 00:33:28,880
minus R2 with spring

840
00:33:28,980 --> 00:33:31,440
and go back to the device

841
00:33:31,440 --> 00:33:34,580
this is my cat by the way

842
00:33:34,860 --> 00:33:37,140
and now we have silio installed and we

843
00:33:37,140 --> 00:33:38,700
can actually open it

844
00:33:38,700 --> 00:33:40,620
and you can tap on allow and yeah we

845
00:33:40,620 --> 00:33:43,019
have a package manager install it on the

846
00:33:43,019 --> 00:33:44,880
device which is you know

847
00:33:44,880 --> 00:33:47,399
basically what every Jailbreaker wants

848
00:33:47,399 --> 00:33:50,120
and yeah

849
00:33:51,299 --> 00:33:53,418
thank you

850
00:33:59,279 --> 00:34:02,159
all right so um yeah you can't install

851
00:34:02,159 --> 00:34:03,919
anything right now simply because

852
00:34:03,919 --> 00:34:07,320
ruthless and um yeah rootless is not

853
00:34:07,320 --> 00:34:10,139
really supported at this point uh and

854
00:34:10,139 --> 00:34:11,699
yeah but

855
00:34:11,699 --> 00:34:14,099
I mean it works

856
00:34:14,099 --> 00:34:17,219
and you uh I can also run just arbitrary

857
00:34:17,219 --> 00:34:19,440
commands like in here like

858
00:34:19,440 --> 00:34:21,020
you know

859
00:34:21,020 --> 00:34:23,219
who am I or

860
00:34:23,219 --> 00:34:26,460
ID so it definitely works

861
00:34:26,460 --> 00:34:28,739
and um

862
00:34:28,739 --> 00:34:31,739
yeah just let me quickly go back to my

863
00:34:31,739 --> 00:34:34,139
presentation and

864
00:34:34,139 --> 00:34:37,820
that's it any questions

865
00:34:46,980 --> 00:34:49,379
um yeah so um

866
00:34:49,379 --> 00:34:52,560
it took me like a couple of months

867
00:34:52,560 --> 00:34:55,679
um for the initial vulnerabilities like

868
00:34:55,679 --> 00:34:57,300
the fast part vulnerability and the OB

869
00:34:57,300 --> 00:35:00,300
PC I want ability for the other two

870
00:35:00,300 --> 00:35:03,000
vulnerabilities yeah to be honest it

871
00:35:03,000 --> 00:35:05,339
took me like two weeks to find them

872
00:35:05,339 --> 00:35:07,619
exploit them because Point

873
00:35:07,619 --> 00:35:10,560
authentication code and PPL bypasses are

874
00:35:10,560 --> 00:35:14,160
not that hard to find to be honest

875
00:35:14,160 --> 00:35:17,240
but yeah

876
00:35:19,590 --> 00:35:22,659
[Applause]

877
00:35:27,260 --> 00:35:30,359
and I know that when I was 16 there was

878
00:35:30,359 --> 00:35:32,760
added some new memory randomization

879
00:35:32,760 --> 00:35:36,900
stuff and the PCI memory Base address is

880
00:35:36,900 --> 00:35:38,880
just randomized more

881
00:35:38,880 --> 00:35:41,400
but um yeah you could probably work

882
00:35:41,400 --> 00:35:44,040
around that by simply leaking a pointer

883
00:35:44,040 --> 00:35:46,520
out yeah

884
00:35:53,040 --> 00:35:55,820
any more questions

