1
00:00:12,880 --> 00:00:13,920
speaker

2
00:00:13,920 --> 00:00:16,400
he's always doing incredible ios

3
00:00:16,400 --> 00:00:19,199
security research uh jonathan levin

4
00:00:19,199 --> 00:00:20,000
who's

5
00:00:20,000 --> 00:00:21,920
one of the top uh security researchers

6
00:00:21,920 --> 00:00:23,359
in the fields always has incredible

7
00:00:23,359 --> 00:00:25,359
things to say about ren which are a

8
00:00:25,359 --> 00:00:27,680
whole fully hundred percent true

9
00:00:27,680 --> 00:00:31,400
so right

10
00:00:42,960 --> 00:00:44,399
that

11
00:00:44,399 --> 00:00:46,320
for the first time the conference is

12
00:00:46,320 --> 00:00:48,399
going to be publicly discussing so round

13
00:00:48,399 --> 00:00:51,600
applause for rent

14
00:00:52,800 --> 00:00:55,520
hello everyone uh my name is uh brandon

15
00:00:55,520 --> 00:00:58,640
azad i work at google project xero and

16
00:00:58,640 --> 00:01:00,320
i'm going to be talking to you about a

17
00:01:00,320 --> 00:01:02,960
research project that i undertook uh

18
00:01:02,960 --> 00:01:05,760
starting uh actually uh almost a year

19
00:01:05,760 --> 00:01:09,920
ago now uh going up to about uh august

20
00:01:09,920 --> 00:01:11,520
of last year

21
00:01:11,520 --> 00:01:13,600
and the basic idea of this project is to

22
00:01:13,600 --> 00:01:16,240
build what i call the debuggable iphone

23
00:01:16,240 --> 00:01:18,640
uh some device which would allow me to

24
00:01:18,640 --> 00:01:21,439
uh get low level debug access to the

25
00:01:21,439 --> 00:01:23,920
iphone and kind of understand what this

26
00:01:23,920 --> 00:01:25,520
project is all about

27
00:01:25,520 --> 00:01:28,159
i need to take you along a uh talking

28
00:01:28,159 --> 00:01:29,439
about something which

29
00:01:29,439 --> 00:01:32,079
usually isn't all that well discussed at

30
00:01:32,079 --> 00:01:34,240
least publicly

31
00:01:34,240 --> 00:01:37,600
so um there's this thing that many uh

32
00:01:37,600 --> 00:01:40,320
ios security researchers most not but

33
00:01:40,320 --> 00:01:42,159
some ios security researchers have

34
00:01:42,159 --> 00:01:45,759
access to uh called uh dev use devices

35
00:01:45,759 --> 00:01:47,920
development iphones um these are

36
00:01:47,920 --> 00:01:49,920
basically special

37
00:01:49,920 --> 00:01:52,159
iphones that have debug capabilities

38
00:01:52,159 --> 00:01:54,399
built into them so things like jtag

39
00:01:54,399 --> 00:01:56,079
serial wire debug

40
00:01:56,079 --> 00:01:58,000
this is not just you know your normal uh

41
00:01:58,000 --> 00:02:00,799
lldb connects to a phone this is like a

42
00:02:00,799 --> 00:02:02,960
special dedicated hardware that's only

43
00:02:02,960 --> 00:02:04,479
supposed to be available to apple

44
00:02:04,479 --> 00:02:06,880
engineers in order to do very low level

45
00:02:06,880 --> 00:02:08,720
debugging of the operating system of the

46
00:02:08,720 --> 00:02:12,160
boot loader um very low level access

47
00:02:12,160 --> 00:02:15,120
so um these devices are not obviously

48
00:02:15,120 --> 00:02:17,360
sold by apple um this is a picture from

49
00:02:17,360 --> 00:02:18,319
a

50
00:02:18,319 --> 00:02:20,560
vice motherboard article

51
00:02:20,560 --> 00:02:22,959
about these devices and people are able

52
00:02:22,959 --> 00:02:25,520
to obtain them uh using various means

53
00:02:25,520 --> 00:02:27,120
and when you have access to them you can

54
00:02:27,120 --> 00:02:30,000
do various low-level analyses device to

55
00:02:30,000 --> 00:02:32,480
find uh vulnerabilities that maybe are

56
00:02:32,480 --> 00:02:35,200
much harder to find if you don't have

57
00:02:35,200 --> 00:02:37,120
this low level debug access to the

58
00:02:37,120 --> 00:02:39,680
operating system

59
00:02:39,680 --> 00:02:42,319
now in order to actually drive uh the

60
00:02:42,319 --> 00:02:44,000
debug hardware on the phone you need a

61
00:02:44,000 --> 00:02:45,760
special type of cable often called a

62
00:02:45,760 --> 00:02:46,800
probe

63
00:02:46,800 --> 00:02:48,800
here is an example of what's called a

64
00:02:48,800 --> 00:02:50,560
kanzi probe

65
00:02:50,560 --> 00:02:52,720
so this has a special lightning

66
00:02:52,720 --> 00:02:54,959
connector on one end uh and then there's

67
00:02:54,959 --> 00:02:56,239
a chunky part in the middle which

68
00:02:56,239 --> 00:02:59,519
contains a controller that drives uh the

69
00:02:59,519 --> 00:03:01,840
interface to the hardware and then on

70
00:03:01,840 --> 00:03:03,680
the other end you have the regular usb

71
00:03:03,680 --> 00:03:05,920
port which you can plug into a laptop

72
00:03:05,920 --> 00:03:08,159
and using special software

73
00:03:08,159 --> 00:03:10,720
you can connect to this probe operate it

74
00:03:10,720 --> 00:03:12,800
and drive the debugging hardware on the

75
00:03:12,800 --> 00:03:14,640
phone to do like break points watch

76
00:03:14,640 --> 00:03:16,840
points on on the phone in the operating

77
00:03:16,840 --> 00:03:19,200
system what have you

78
00:03:19,200 --> 00:03:21,040
um so again these are not cables which

79
00:03:21,040 --> 00:03:22,560
are sold by apple some people are able

80
00:03:22,560 --> 00:03:24,480
to acquire them

81
00:03:24,480 --> 00:03:26,080
and the software that's used to drive

82
00:03:26,080 --> 00:03:28,560
these pros is something called asterisk

83
00:03:28,560 --> 00:03:30,159
this is a piece of apple internal

84
00:03:30,159 --> 00:03:31,120
software

85
00:03:31,120 --> 00:03:33,519
again not uh they don't make this public

86
00:03:33,519 --> 00:03:35,280
this is like leak software that people

87
00:03:35,280 --> 00:03:37,840
are able to obtain um here is an example

88
00:03:37,840 --> 00:03:40,799
of someone using asterisks with a kong

89
00:03:40,799 --> 00:03:43,040
serial wire debug probe

90
00:03:43,040 --> 00:03:45,840
and they have halted execution inside

91
00:03:45,840 --> 00:03:48,319
the bootloader and dumped the 32-bit

92
00:03:48,319 --> 00:03:52,480
register state so let's see

93
00:03:53,040 --> 00:03:55,280
so these registers right here is the

94
00:03:55,280 --> 00:03:57,200
32-bit register state

95
00:03:57,200 --> 00:03:59,200
and you can see that they've saved the

96
00:03:59,200 --> 00:04:01,599
memory contents to this ibm file so

97
00:04:01,599 --> 00:04:03,760
presumably they're dumping iboot in

98
00:04:03,760 --> 00:04:06,959
order to get a decrypted copy of apple's

99
00:04:06,959 --> 00:04:09,439
bootloader for security

100
00:04:09,439 --> 00:04:12,319
vulnerability research

101
00:04:12,319 --> 00:04:13,680
so

102
00:04:13,680 --> 00:04:14,560
i

103
00:04:14,560 --> 00:04:17,440
do not use these depth fuse devices um i

104
00:04:17,440 --> 00:04:19,358
don't have access to them i don't want

105
00:04:19,358 --> 00:04:20,959
to have access to them there are various

106
00:04:20,959 --> 00:04:22,880
complications surrounding them i'm not

107
00:04:22,880 --> 00:04:24,800
going to touch them

108
00:04:24,800 --> 00:04:28,240
but nevertheless it would be really it

109
00:04:28,240 --> 00:04:30,479
would really make my job a lot easier if

110
00:04:30,479 --> 00:04:32,720
i did have access to these devices um

111
00:04:32,720 --> 00:04:34,639
part of my job in project zero is i try

112
00:04:34,639 --> 00:04:36,960
to find uh vulnerabilities in the iphone

113
00:04:36,960 --> 00:04:39,759
and report them to apple uh and having

114
00:04:39,759 --> 00:04:42,080
the kind of lack of debug tooling

115
00:04:42,080 --> 00:04:43,120
available

116
00:04:43,120 --> 00:04:45,040
really makes my job that much harder i

117
00:04:45,040 --> 00:04:47,360
have in some ways a disadvantage to

118
00:04:47,360 --> 00:04:49,360
compare it to people who do have these

119
00:04:49,360 --> 00:04:51,120
debug devices

120
00:04:51,120 --> 00:04:53,120
so that's kind of the motivation for

121
00:04:53,120 --> 00:04:55,600
this project is i wanted to

122
00:04:55,600 --> 00:04:58,720
uh basically find a way to build a

123
00:04:58,720 --> 00:05:01,840
similar capability a debuggable phone

124
00:05:01,840 --> 00:05:03,680
that is totally legit totally off the

125
00:05:03,680 --> 00:05:05,680
shelf that i could use for my day-to-day

126
00:05:05,680 --> 00:05:07,600
work at project zero

127
00:05:07,600 --> 00:05:10,080
so the goal was to build my own home

128
00:05:10,080 --> 00:05:12,400
brewed development phone and i kind of

129
00:05:12,400 --> 00:05:14,320
outlined five capabilities that i really

130
00:05:14,320 --> 00:05:16,880
wanted uh this project to achieve uh

131
00:05:16,880 --> 00:05:19,199
first i wanted the ability for this uh

132
00:05:19,199 --> 00:05:22,000
homebrew dev phone to be able to patch

133
00:05:22,000 --> 00:05:24,000
kernel memory and in particular be able

134
00:05:24,000 --> 00:05:26,320
to patch the executable memory in the

135
00:05:26,320 --> 00:05:28,720
kernel um we'll get back to why this is

136
00:05:28,720 --> 00:05:31,520
actually a hard thing to do uh just very

137
00:05:31,520 --> 00:05:32,560
quickly

138
00:05:32,560 --> 00:05:34,560
um the next feature kind of important

139
00:05:34,560 --> 00:05:36,880
for any you know debugger is the ability

140
00:05:36,880 --> 00:05:39,120
to set breakpoints and watch points

141
00:05:39,120 --> 00:05:41,280
um i wanted it to be possible to use

142
00:05:41,280 --> 00:05:43,280
with off-the-shelf debugging software so

143
00:05:43,280 --> 00:05:46,400
lldb ida pro so you don't have to use

144
00:05:46,400 --> 00:05:48,080
apple internal software like asterisk in

145
00:05:48,080 --> 00:05:49,840
order to operate it that's bad

146
00:05:49,840 --> 00:05:52,560
um i wanted it to be possible to update

147
00:05:52,560 --> 00:05:55,039
the version of ios on the phone so that

148
00:05:55,039 --> 00:05:56,800
i can you know if i'm going to spend six

149
00:05:56,800 --> 00:05:58,639
months investing in this development

150
00:05:58,639 --> 00:06:01,520
project to build a ios kernel debugger i

151
00:06:01,520 --> 00:06:03,360
don't want to only be able to debug one

152
00:06:03,360 --> 00:06:05,120
version of ios i wanted to you know

153
00:06:05,120 --> 00:06:07,280
amortize the development cost across

154
00:06:07,280 --> 00:06:09,280
multiple versions of the operating

155
00:06:09,280 --> 00:06:11,600
system so that might mean finding a

156
00:06:11,600 --> 00:06:13,440
hardware vulnerability that might be

157
00:06:13,440 --> 00:06:15,759
finding a bootloader vulnerability but

158
00:06:15,759 --> 00:06:17,520
basically a kernel vulnerability alone

159
00:06:17,520 --> 00:06:19,120
would not be sufficient because then

160
00:06:19,120 --> 00:06:21,120
once apple patches the kernel bug my

161
00:06:21,120 --> 00:06:24,080
debug capability goes away

162
00:06:24,080 --> 00:06:26,639
and finally um kind of the key part of

163
00:06:26,639 --> 00:06:28,720
this whole project is i wanted to build

164
00:06:28,720 --> 00:06:31,039
this debuggable iphone using only parts

165
00:06:31,039 --> 00:06:33,280
you can get at an apple store so no

166
00:06:33,280 --> 00:06:36,720
specially fused cpus no special

167
00:06:36,720 --> 00:06:39,360
uh debug probes nothing like that so

168
00:06:39,360 --> 00:06:41,759
just you know go into an apple store buy

169
00:06:41,759 --> 00:06:42,880
everything you need there this is

170
00:06:42,880 --> 00:06:45,120
actually a strictly more powerful

171
00:06:45,120 --> 00:06:48,080
capability um everything that i set out

172
00:06:48,080 --> 00:06:50,160
to accomplish in my project is totally

173
00:06:50,160 --> 00:06:52,319
accomplished by uh checkmate and the

174
00:06:52,319 --> 00:06:54,080
checkbrain project and in fact many of

175
00:06:54,080 --> 00:06:58,400
the features that i put into ktrw uh may

176
00:06:58,400 --> 00:07:00,720
make their way into the uh standard

177
00:07:00,720 --> 00:07:03,840
checkbrain uh project itself so um even

178
00:07:03,840 --> 00:07:07,680
though uh this research came out and is

179
00:07:07,680 --> 00:07:09,199
more powerful and i expect future

180
00:07:09,199 --> 00:07:11,039
tooling to be built around this instead

181
00:07:11,039 --> 00:07:13,520
of the capabilities that i found uh this

182
00:07:13,520 --> 00:07:15,599
capability didn't actually exist when i

183
00:07:15,599 --> 00:07:17,280
started my research project so many of

184
00:07:17,280 --> 00:07:19,440
the assumptions that i had going in

185
00:07:19,440 --> 00:07:21,919
no longer hold now but did hold kind of

186
00:07:21,919 --> 00:07:23,520
at the point i was doing this research

187
00:07:23,520 --> 00:07:26,479
so just to clarify that part

188
00:07:26,479 --> 00:07:28,960
all right uh so let's talk about what

189
00:07:28,960 --> 00:07:29,840
makes

190
00:07:29,840 --> 00:07:32,000
kernel debugging on ios really really

191
00:07:32,000 --> 00:07:33,919
difficult right now

192
00:07:33,919 --> 00:07:36,240
and this is this thing called ktrr so if

193
00:07:36,240 --> 00:07:38,400
you remember from a slide earlier what i

194
00:07:38,400 --> 00:07:40,400
wanted out of this debuggable iphone

195
00:07:40,400 --> 00:07:41,680
project

196
00:07:41,680 --> 00:07:43,039
one of the very first things that i

197
00:07:43,039 --> 00:07:44,639
mentioned was the ability to patch

198
00:07:44,639 --> 00:07:46,479
kernel memory and in particular to patch

199
00:07:46,479 --> 00:07:48,720
the kernel's executable code if you can

200
00:07:48,720 --> 00:07:50,240
do that that means that you can you know

201
00:07:50,240 --> 00:07:51,919
run shell code in the kernel and that's

202
00:07:51,919 --> 00:07:53,919
a really useful feature to have for

203
00:07:53,919 --> 00:07:57,360
debugging and analyzing the hardware

204
00:07:57,360 --> 00:07:59,840
and apple has basically done a very good

205
00:07:59,840 --> 00:08:01,199
job trying to make this step in

206
00:08:01,199 --> 00:08:03,360
particular extremely difficult

207
00:08:03,360 --> 00:08:06,000
uh so if you look at the kernel in

208
00:08:06,000 --> 00:08:08,160
memory uh so the actual kernel uh is

209
00:08:08,160 --> 00:08:09,919
often referred to as the kernel cache

210
00:08:09,919 --> 00:08:11,919
because it contains both the kernels

211
00:08:11,919 --> 00:08:13,599
code and all the drivers that are

212
00:08:13,599 --> 00:08:15,520
pre-packaged into it and here you can

213
00:08:15,520 --> 00:08:17,759
see kind of a representation of how it's

214
00:08:17,759 --> 00:08:19,599
laid out in kernel memory and it's

215
00:08:19,599 --> 00:08:20,800
composed of a number of different

216
00:08:20,800 --> 00:08:23,599
segments so you have um you know some

217
00:08:23,599 --> 00:08:26,560
data which needs to be read writable so

218
00:08:26,560 --> 00:08:28,080
you know global variables which get

219
00:08:28,080 --> 00:08:30,720
updated um global pointers lists things

220
00:08:30,720 --> 00:08:33,120
like that so this data is included in

221
00:08:33,120 --> 00:08:34,799
the kernel image

222
00:08:34,799 --> 00:08:36,640
but it does need to be updated uh

223
00:08:36,640 --> 00:08:38,399
dynamically so that has to be your read

224
00:08:38,399 --> 00:08:39,360
write

225
00:08:39,360 --> 00:08:41,039
but there's also a lot of data which

226
00:08:41,039 --> 00:08:42,559
really does not need to be writable at

227
00:08:42,559 --> 00:08:43,679
runtime

228
00:08:43,679 --> 00:08:46,080
so for example we have executable code

229
00:08:46,080 --> 00:08:48,240
it's kind of the most obvious example of

230
00:08:48,240 --> 00:08:49,279
that

231
00:08:49,279 --> 00:08:51,519
um so of course if you can patch the

232
00:08:51,519 --> 00:08:53,200
kernel's executable code that's that's

233
00:08:53,200 --> 00:08:55,920
really bad for a security standpoint

234
00:08:55,920 --> 00:08:57,360
but you also have a number of other

235
00:08:57,360 --> 00:09:00,399
pieces of data which are not uh quite as

236
00:09:00,399 --> 00:09:04,880
critical uh you don't need them to be uh

237
00:09:04,959 --> 00:09:07,518
interesting

238
00:09:10,800 --> 00:09:12,160
so there's a number of other pieces of

239
00:09:12,160 --> 00:09:14,640
data which uh are

240
00:09:14,640 --> 00:09:16,480
uh you know you want them to be read

241
00:09:16,480 --> 00:09:19,440
only but not executable um so you still

242
00:09:19,440 --> 00:09:21,600
want to be able to protect them

243
00:09:21,600 --> 00:09:23,120
but you also want to make sure they

244
00:09:23,120 --> 00:09:24,720
don't get executed so things like

245
00:09:24,720 --> 00:09:26,640
strings no reason to change those

246
00:09:26,640 --> 00:09:28,399
virtual method tables probably should be

247
00:09:28,399 --> 00:09:29,360
const

248
00:09:29,360 --> 00:09:31,360
page tables uh

249
00:09:31,360 --> 00:09:33,120
this section called opinions which is

250
00:09:33,120 --> 00:09:34,640
privileged instructions or protected

251
00:09:34,640 --> 00:09:35,760
instructions

252
00:09:35,760 --> 00:09:37,279
so things like that purchase really

253
00:09:37,279 --> 00:09:40,320
should stay read-only

254
00:09:40,320 --> 00:09:41,600
and so what apple has done is they

255
00:09:41,600 --> 00:09:43,760
implemented a mitigation called ktrr

256
00:09:43,760 --> 00:09:45,600
which is designed to lock down these

257
00:09:45,600 --> 00:09:47,360
read-only segments of the kernel cache

258
00:09:47,360 --> 00:09:49,279
and make sure those segments really do

259
00:09:49,279 --> 00:09:51,519
stay read only if you can only execute

260
00:09:51,519 --> 00:09:53,920
stuff inside of that region

261
00:09:53,920 --> 00:09:55,279
so kind of from a

262
00:09:55,279 --> 00:09:56,959
backing up a little bit

263
00:09:56,959 --> 00:09:59,040
what is ktrr

264
00:09:59,040 --> 00:10:00,480
we think it stands for kernel text

265
00:10:00,480 --> 00:10:03,040
read-only region we don't actually know

266
00:10:03,040 --> 00:10:05,440
and it basically boils down to a really

267
00:10:05,440 --> 00:10:08,079
strong form of write xor execute

268
00:10:08,079 --> 00:10:09,200
protection

269
00:10:09,200 --> 00:10:11,760
um it's implemented in apple a10 cpus

270
00:10:11,760 --> 00:10:12,959
and later

271
00:10:12,959 --> 00:10:14,959
and it provides two pretty strong

272
00:10:14,959 --> 00:10:16,959
guarantees so the first is that all

273
00:10:16,959 --> 00:10:19,600
rights to memory inside of the ktrr

274
00:10:19,600 --> 00:10:22,480
region will fail so that means that the

275
00:10:22,480 --> 00:10:24,560
region that's protected by ktrr is going

276
00:10:24,560 --> 00:10:27,440
to be guaranteed to stay read only

277
00:10:27,440 --> 00:10:29,519
and the second guarantee is that all

278
00:10:29,519 --> 00:10:31,440
instruction fetches from outside of the

279
00:10:31,440 --> 00:10:34,320
ktrr region will also fail so that means

280
00:10:34,320 --> 00:10:36,560
the only memory that you can execute is

281
00:10:36,560 --> 00:10:38,640
that which has been protected by ktro

282
00:10:38,640 --> 00:10:40,640
which is guaranteed to be read only and

283
00:10:40,640 --> 00:10:42,320
kind of the idea is well if the

284
00:10:42,320 --> 00:10:44,240
bootloader has successfully

285
00:10:44,240 --> 00:10:45,839
put the kernel cache into memory

286
00:10:45,839 --> 00:10:47,920
verified the cryptographic signature and

287
00:10:47,920 --> 00:10:49,360
we have you know managed to get the

288
00:10:49,360 --> 00:10:51,120
secure boot chain to boot all the way up

289
00:10:51,120 --> 00:10:52,720
to the point where the kernel is loaded

290
00:10:52,720 --> 00:10:55,120
into memory then ktrr is supposed to

291
00:10:55,120 --> 00:10:57,360
ensure that that integrity remains for

292
00:10:57,360 --> 00:10:59,680
the lifetime of the system so once you

293
00:10:59,680 --> 00:11:01,600
have an iphone that's running you know

294
00:11:01,600 --> 00:11:03,600
that at any future point the kernel has

295
00:11:03,600 --> 00:11:05,600
not been modified it's still the same

296
00:11:05,600 --> 00:11:07,440
one that's been signed by the secure

297
00:11:07,440 --> 00:11:09,200
boot process so it's a really

298
00:11:09,200 --> 00:11:11,360
interesting kind of uh security feature

299
00:11:11,360 --> 00:11:14,079
a really nice nice extension of right x

300
00:11:14,079 --> 00:11:16,320
or execute to kind of extend secure boot

301
00:11:16,320 --> 00:11:17,680
all the way through the lifetime of the

302
00:11:17,680 --> 00:11:19,519
system

303
00:11:19,519 --> 00:11:22,160
so let's look a little bit about how kcr

304
00:11:22,160 --> 00:11:24,240
actually might work under the hood uh

305
00:11:24,240 --> 00:11:26,480
now i don't know how it works

306
00:11:26,480 --> 00:11:28,720
in detail this is kind of my guess and

307
00:11:28,720 --> 00:11:30,720
analysis but it's you know

308
00:11:30,720 --> 00:11:32,880
reasonable enough that it's a plausible

309
00:11:32,880 --> 00:11:34,640
model of how it works

310
00:11:34,640 --> 00:11:37,440
um so here is a simplified diagram of an

311
00:11:37,440 --> 00:11:41,519
a11 cpu which has uh four little cpu

312
00:11:41,519 --> 00:11:44,640
cores and two big cpu cores the um

313
00:11:44,640 --> 00:11:47,360
little purple boxes in there are the uh

314
00:11:47,360 --> 00:11:49,839
mmus so you can see you have some views

315
00:11:49,839 --> 00:11:51,120
one for each core

316
00:11:51,120 --> 00:11:53,200
uh you have the highest level of cache

317
00:11:53,200 --> 00:11:55,519
hierarchy is the lt cache

318
00:11:55,519 --> 00:11:57,440
and then you also have the memory

319
00:11:57,440 --> 00:11:59,279
controller which lies behind the l2

320
00:11:59,279 --> 00:12:02,320
cache and also uh memory controller you

321
00:12:02,320 --> 00:12:05,360
have dram which holds the physical pages

322
00:12:05,360 --> 00:12:08,560
so um the kernel is going to be loaded

323
00:12:08,560 --> 00:12:10,720
contiguously into a certain range of

324
00:12:10,720 --> 00:12:12,000
physical memory

325
00:12:12,000 --> 00:12:14,399
and apple's goal is to basically lock

326
00:12:14,399 --> 00:12:15,200
down

327
00:12:15,200 --> 00:12:17,440
those specific pages of physical memory

328
00:12:17,440 --> 00:12:19,920
with ktrr so this becomes the ktr

329
00:12:19,920 --> 00:12:22,399
protected region

330
00:12:22,399 --> 00:12:24,639
so in order to understand how this

331
00:12:24,639 --> 00:12:26,560
protection is enforced let's zoom in on

332
00:12:26,560 --> 00:12:28,560
a single cpu core

333
00:12:28,560 --> 00:12:30,800
what apple's basically done is add two

334
00:12:30,800 --> 00:12:33,440
registers to the mmu and these registers

335
00:12:33,440 --> 00:12:35,200
are going to point to the beginning and

336
00:12:35,200 --> 00:12:38,320
ending address of the ktrr lockdown

337
00:12:38,320 --> 00:12:39,200
region

338
00:12:39,200 --> 00:12:41,760
and what this allows us to do is the cpu

339
00:12:41,760 --> 00:12:43,519
can now really quickly check whether

340
00:12:43,519 --> 00:12:45,440
each instruction that gets executed is

341
00:12:45,440 --> 00:12:47,360
going to violate the security properties

342
00:12:47,360 --> 00:12:48,720
of ktrr

343
00:12:48,720 --> 00:12:50,560
so for example let's say that the cpu

344
00:12:50,560 --> 00:12:52,720
tries to issue a rate and that right

345
00:12:52,720 --> 00:12:55,760
falls outside of the ktr or region that

346
00:12:55,760 --> 00:12:57,200
is allowed to succeed since it doesn't

347
00:12:57,200 --> 00:12:59,920
violate the ktrr security principles

348
00:12:59,920 --> 00:13:02,240
um if on the other hand there's a right

349
00:13:02,240 --> 00:13:05,440
which hits inside of the ktrr region

350
00:13:05,440 --> 00:13:07,120
then it's very quick for the mmu to

351
00:13:07,120 --> 00:13:08,880
check hey you know this falls inside the

352
00:13:08,880 --> 00:13:10,240
bounds of these two registers so it's

353
00:13:10,240 --> 00:13:12,480
going to deny the right and cause that

354
00:13:12,480 --> 00:13:14,240
instruction which generated the right to

355
00:13:14,240 --> 00:13:15,839
fault

356
00:13:15,839 --> 00:13:18,560
similarly if you try to execute memory

357
00:13:18,560 --> 00:13:21,680
outside of the ktrr region um the mmu

358
00:13:21,680 --> 00:13:23,200
can really quickly see you know hey this

359
00:13:23,200 --> 00:13:25,600
doesn't look valid it's going to fault

360
00:13:25,600 --> 00:13:26,720
and you're not going to be allowed to

361
00:13:26,720 --> 00:13:29,120
execute memory outside of the protected

362
00:13:29,120 --> 00:13:30,959
region

363
00:13:30,959 --> 00:13:32,959
so that's kind of what the new picture

364
00:13:32,959 --> 00:13:36,240
of the cpu looks like with these

365
00:13:36,240 --> 00:13:38,079
additional registers in mmu to kind of

366
00:13:38,079 --> 00:13:41,120
enforce the ktr security properties uh

367
00:13:41,120 --> 00:13:44,399
on the actual cpu cores themselves

368
00:13:44,399 --> 00:13:46,160
but unfortunately this isn't the full

369
00:13:46,160 --> 00:13:48,079
picture for protection and the reason is

370
00:13:48,079 --> 00:13:50,639
because this cpu isn't the only place

371
00:13:50,639 --> 00:13:52,320
that can issue writes to the memory

372
00:13:52,320 --> 00:13:54,240
controller in particular there are a

373
00:13:54,240 --> 00:13:55,839
number of other devices on the system

374
00:13:55,839 --> 00:13:58,240
peripherals like the wi-fi chip

375
00:13:58,240 --> 00:14:00,240
which can also issue writes directly to

376
00:14:00,240 --> 00:14:02,079
the memory controller and they they will

377
00:14:02,079 --> 00:14:03,839
eventually hit dram

378
00:14:03,839 --> 00:14:05,360
so what apple has had to do is they've

379
00:14:05,360 --> 00:14:08,639
added uh regis the lockdown registers to

380
00:14:08,639 --> 00:14:10,160
the amcc

381
00:14:10,160 --> 00:14:12,079
as well so that now the memory

382
00:14:12,079 --> 00:14:13,600
controller knows the beginning and

383
00:14:13,600 --> 00:14:15,680
ending balance of the lockdown region

384
00:14:15,680 --> 00:14:17,519
and any time or write from a peripheral

385
00:14:17,519 --> 00:14:18,880
like let's say someone's compromised

386
00:14:18,880 --> 00:14:22,560
your wi-fi chip and bypassed the i o mmu

387
00:14:22,560 --> 00:14:24,800
they if that manages to hit the memory

388
00:14:24,800 --> 00:14:27,360
controller uh ktrr is still going to be

389
00:14:27,360 --> 00:14:28,800
enforced because the memory controller

390
00:14:28,800 --> 00:14:30,399
will just discard

391
00:14:30,399 --> 00:14:33,440
that right which would otherwise corrupt

392
00:14:33,440 --> 00:14:35,920
the protected region

393
00:14:35,920 --> 00:14:37,680
and this is kind of the complete picture

394
00:14:37,680 --> 00:14:39,360
of the simplified complete picture of

395
00:14:39,360 --> 00:14:42,480
how ktrr has been implemented on the a11

396
00:14:42,480 --> 00:14:45,440
cpus

397
00:14:45,440 --> 00:14:47,680
uh there is one other thing which we

398
00:14:47,680 --> 00:14:50,320
need to address which is that um this

399
00:14:50,320 --> 00:14:52,079
while the systems works very well in

400
00:14:52,079 --> 00:14:54,880
practice there's um a lot of kind of

401
00:14:54,880 --> 00:14:56,399
nuances which need to be handled

402
00:14:56,399 --> 00:14:58,480
correctly in the software

403
00:14:58,480 --> 00:15:00,240
and in particular around what happens

404
00:15:00,240 --> 00:15:02,079
when a core goes to sleep and then wakes

405
00:15:02,079 --> 00:15:05,199
up see when a cpu core goes to sleep

406
00:15:05,199 --> 00:15:06,560
it's going to enter this deep sleep

407
00:15:06,560 --> 00:15:08,959
state and it's going to lose the state

408
00:15:08,959 --> 00:15:10,320
in all of its registers and in

409
00:15:10,320 --> 00:15:12,880
particular the mmu lockdown registers

410
00:15:12,880 --> 00:15:14,880
are going to lose their values

411
00:15:14,880 --> 00:15:17,680
so if ktrr only lasts until the first

412
00:15:17,680 --> 00:15:19,600
time a cpu sleeps that's obviously not

413
00:15:19,600 --> 00:15:21,360
very useful since sleeps happen all the

414
00:15:21,360 --> 00:15:22,320
time

415
00:15:22,320 --> 00:15:24,800
so apple needed to added code apple

416
00:15:24,800 --> 00:15:27,360
needed to add code to make sure that

417
00:15:27,360 --> 00:15:29,759
every time a cpu port wakes from sleep

418
00:15:29,759 --> 00:15:31,759
it re-initializes the registers on the

419
00:15:31,759 --> 00:15:35,440
mmu and re-locks them on ktrl

420
00:15:35,440 --> 00:15:39,040
so the piece of code which xnu executes

421
00:15:39,040 --> 00:15:40,959
when it wakes from sleep is called the

422
00:15:40,959 --> 00:15:42,240
reset vector

423
00:15:42,240 --> 00:15:44,000
it's called low reset vector base in the

424
00:15:44,000 --> 00:15:45,199
source code

425
00:15:45,199 --> 00:15:47,120
and this is basically a

426
00:15:47,120 --> 00:15:48,880
disassembly of the first couple of

427
00:15:48,880 --> 00:15:53,040
instructions in the uh ios 12.4 kernel

428
00:15:53,040 --> 00:15:55,680
cache for the iphone 11 uh sorry iphone

429
00:15:55,680 --> 00:15:56,800
uh eight

430
00:15:56,800 --> 00:15:59,440
uh which uh you can see kind of at the

431
00:15:59,440 --> 00:16:01,120
start you have some initialization code

432
00:16:01,120 --> 00:16:03,120
and pretty soon in uh there's some code

433
00:16:03,120 --> 00:16:04,800
which does lock down

434
00:16:04,800 --> 00:16:06,959
so these two global variables read only

435
00:16:06,959 --> 00:16:09,600
region begin and read only region end

436
00:16:09,600 --> 00:16:10,639
are

437
00:16:10,639 --> 00:16:12,720
variables inside of the locked down

438
00:16:12,720 --> 00:16:15,279
region itself and they contain the

439
00:16:15,279 --> 00:16:17,759
addresses of the beginning and ending of

440
00:16:17,759 --> 00:16:20,800
this lockdown region and what happens is

441
00:16:20,800 --> 00:16:22,800
the reset vector will very quickly read

442
00:16:22,800 --> 00:16:25,360
these values into registers and then

443
00:16:25,360 --> 00:16:28,800
write those values to these special

444
00:16:28,800 --> 00:16:31,839
system registers using msr instructions

445
00:16:31,839 --> 00:16:33,600
and so this is the actual point at which

446
00:16:33,600 --> 00:16:34,399
the

447
00:16:34,399 --> 00:16:36,079
beginning and ending balance on the mmu

448
00:16:36,079 --> 00:16:38,880
are set and established and then that

449
00:16:38,880 --> 00:16:40,639
mmu's locked down to make sure these

450
00:16:40,639 --> 00:16:42,959
register values can't change and kcr is

451
00:16:42,959 --> 00:16:45,519
then enabled

452
00:16:45,519 --> 00:16:47,360
all right so that's kind of an overview

453
00:16:47,360 --> 00:16:50,399
of how ktr works on the iphone and now

454
00:16:50,399 --> 00:16:53,680
let's look at how to break it

455
00:16:53,680 --> 00:16:55,680
uh in order to do that let's first look

456
00:16:55,680 --> 00:16:57,199
at kind of a historical perspective

457
00:16:57,199 --> 00:16:58,800
since this isn't the first time that

458
00:16:58,800 --> 00:17:01,360
people have tried to bypass ktr by any

459
00:17:01,360 --> 00:17:02,480
means

460
00:17:02,480 --> 00:17:05,359
so the first public bypass of ktrr came

461
00:17:05,359 --> 00:17:07,599
in ios 10.1.1

462
00:17:07,599 --> 00:17:10,559
uh which was when luca tedesco found

463
00:17:10,559 --> 00:17:13,280
that apple had accidentally left an

464
00:17:13,280 --> 00:17:16,559
instruction the msr ttbr1 instruction

465
00:17:16,559 --> 00:17:19,280
executable in the kernel cache

466
00:17:19,280 --> 00:17:22,640
the ttbr1 register is used to store the

467
00:17:22,640 --> 00:17:24,959
root of the page table hierarchy for the

468
00:17:24,959 --> 00:17:27,119
kernel's half of the address space

469
00:17:27,119 --> 00:17:29,760
what this means is that um apple

470
00:17:29,760 --> 00:17:32,160
basically left in an instruction which

471
00:17:32,160 --> 00:17:34,400
if you executed it using return oriented

472
00:17:34,400 --> 00:17:36,720
programming would let you

473
00:17:36,720 --> 00:17:39,039
set a new route for your page table

474
00:17:39,039 --> 00:17:41,039
hierarchy and remap the kernel onto

475
00:17:41,039 --> 00:17:42,320
different pages

476
00:17:42,320 --> 00:17:44,240
so this is bad because that basically

477
00:17:44,240 --> 00:17:46,799
means that you know ktr is locking down

478
00:17:46,799 --> 00:17:48,960
a certain set of physical pages but it

479
00:17:48,960 --> 00:17:50,960
doesn't protect any other physical pages

480
00:17:50,960 --> 00:17:52,799
so if you set your kernel to be mapped

481
00:17:52,799 --> 00:17:55,039
onto different physical pages it'll run

482
00:17:55,039 --> 00:17:56,160
just fine

483
00:17:56,160 --> 00:17:58,160
uh and so this is basically what luca

484
00:17:58,160 --> 00:18:01,760
did in his yalu ktrr bypass is he used

485
00:18:01,760 --> 00:18:05,200
that ttbr1 instruction to set a new page

486
00:18:05,200 --> 00:18:06,320
table base

487
00:18:06,320 --> 00:18:08,720
uh and basically you know data in the

488
00:18:08,720 --> 00:18:10,880
kernel which used to be read only is now

489
00:18:10,880 --> 00:18:13,760
writable um it's not a full bypass

490
00:18:13,760 --> 00:18:15,679
because ktrr is actually still

491
00:18:15,679 --> 00:18:18,080
initialized at this point so the right

492
00:18:18,080 --> 00:18:20,160
xor execute protections are still in

493
00:18:20,160 --> 00:18:22,559
place you can't execute new code outside

494
00:18:22,559 --> 00:18:25,600
of the ktr region but the lockdown uh no

495
00:18:25,600 --> 00:18:27,919
longer applies to the read-only data

496
00:18:27,919 --> 00:18:30,080
that has now become rewritable so kind

497
00:18:30,080 --> 00:18:31,919
of graphically what this looks like is

498
00:18:31,919 --> 00:18:33,760
it used to be that all this data was

499
00:18:33,760 --> 00:18:37,120
protected by ktrr and uh by remapping

500
00:18:37,120 --> 00:18:38,720
the kernel you've restricted what's

501
00:18:38,720 --> 00:18:40,720
protected by ktrr to only be the

502
00:18:40,720 --> 00:18:43,120
executable code now things like strings

503
00:18:43,120 --> 00:18:44,799
virtual method tables all of those are

504
00:18:44,799 --> 00:18:48,000
not writable as well

505
00:18:48,400 --> 00:18:51,120
the other interesting bypass for ktrr

506
00:18:51,120 --> 00:18:54,160
came in ios 1112 when ian beer released

507
00:18:54,160 --> 00:18:55,919
a project called build your own ios

508
00:18:55,919 --> 00:18:57,520
kernel debugger this project

509
00:18:57,520 --> 00:18:59,600
unsurprisingly was a large inspiration

510
00:18:59,600 --> 00:19:00,960
for this project

511
00:19:00,960 --> 00:19:03,520
um so ian beer found that the

512
00:19:03,520 --> 00:19:05,760
self-hosted debugging registers

513
00:19:05,760 --> 00:19:07,760
which are part of the arm specification

514
00:19:07,760 --> 00:19:10,480
could actually be enabled on iphones

515
00:19:10,480 --> 00:19:13,120
so um self-hosted debugging is a feature

516
00:19:13,120 --> 00:19:15,120
in the arm architecture which allows a

517
00:19:15,120 --> 00:19:16,400
kernel to

518
00:19:16,400 --> 00:19:18,799
implement a debugger for itself so if

519
00:19:18,799 --> 00:19:21,760
you've ever used like kdp to debug one

520
00:19:21,760 --> 00:19:23,919
macbook with another macbook remotely

521
00:19:23,919 --> 00:19:26,320
over udp um it's kind of a very similar

522
00:19:26,320 --> 00:19:27,919
principle to that the kernel kind of

523
00:19:27,919 --> 00:19:29,840
catches its own exceptions catches its

524
00:19:29,840 --> 00:19:32,240
own uh anytime it falls it catches that

525
00:19:32,240 --> 00:19:34,640
and then it uh farms that out and says

526
00:19:34,640 --> 00:19:37,280
look you know this event has happened uh

527
00:19:37,280 --> 00:19:38,799
we'll let a debugger that the kernel

528
00:19:38,799 --> 00:19:40,960
itself implements handle that and

529
00:19:40,960 --> 00:19:43,120
process decide what actually needs to be

530
00:19:43,120 --> 00:19:44,880
taken accordingly

531
00:19:44,880 --> 00:19:46,559
so what ian found was that it was

532
00:19:46,559 --> 00:19:48,400
actually possible to enable a

533
00:19:48,400 --> 00:19:50,799
self-hosted debug using return oriented

534
00:19:50,799 --> 00:19:53,120
programming to access specific gadgets

535
00:19:53,120 --> 00:19:54,960
which set those registers

536
00:19:54,960 --> 00:19:57,200
and using this he was able to build a

537
00:19:57,200 --> 00:19:59,280
fairly full-featured ios kernel debugger

538
00:19:59,280 --> 00:20:01,120
that supported things like breakpoints

539
00:20:01,120 --> 00:20:03,679
for ios 1112

540
00:20:03,679 --> 00:20:06,400
so it's important to note that ktrr is

541
00:20:06,400 --> 00:20:09,200
actually still fully enabled uh

542
00:20:09,200 --> 00:20:11,200
in this setting so it's not a full

543
00:20:11,200 --> 00:20:13,440
bypass in that sense but it is kind of a

544
00:20:13,440 --> 00:20:15,440
bypassing principle in that you can

545
00:20:15,440 --> 00:20:17,200
execute instructions in arbitrary order

546
00:20:17,200 --> 00:20:18,559
by you know setting a breakpoint

547
00:20:18,559 --> 00:20:20,559
executing single instruction jumping to

548
00:20:20,559 --> 00:20:22,080
another instruction executing that

549
00:20:22,080 --> 00:20:24,720
instruction um so you know the linear

550
00:20:24,720 --> 00:20:26,159
sequence of control flow that is

551
00:20:26,159 --> 00:20:28,559
necessary uh for return oriented

552
00:20:28,559 --> 00:20:30,320
programming that's totally gone you can

553
00:20:30,320 --> 00:20:32,080
execute single instructions all over the

554
00:20:32,080 --> 00:20:34,720
place

555
00:20:34,720 --> 00:20:36,880
so kind of with the understanding of

556
00:20:36,880 --> 00:20:38,720
what the historical

557
00:20:38,720 --> 00:20:41,200
attempts on bypassing ktrr were i

558
00:20:41,200 --> 00:20:43,440
decided to look at how i would bypass it

559
00:20:43,440 --> 00:20:44,480
for this

560
00:20:44,480 --> 00:20:47,039
kernel debuggable iphone project

561
00:20:47,039 --> 00:20:49,679
and i basically identified a number of

562
00:20:49,679 --> 00:20:51,200
different areas which looked promising

563
00:20:51,200 --> 00:20:53,280
and investigated each in turn uh the

564
00:20:53,280 --> 00:20:54,799
first thing i looked for was if there

565
00:20:54,799 --> 00:20:56,960
was a bug in iboot and this particular

566
00:20:56,960 --> 00:20:59,280
in the image for processing code

567
00:20:59,280 --> 00:21:01,120
looked for a month or so and didn't

568
00:21:01,120 --> 00:21:03,039
really find anything interesting

569
00:21:03,039 --> 00:21:04,960
i next looked at you know maybe reading

570
00:21:04,960 --> 00:21:06,559
the arm specification there looks like

571
00:21:06,559 --> 00:21:07,840
there might be some interesting stuff

572
00:21:07,840 --> 00:21:08,880
where if you

573
00:21:08,880 --> 00:21:10,559
uh set page tables in a certain way

574
00:21:10,559 --> 00:21:12,720
maybe you could get tlb entries to

575
00:21:12,720 --> 00:21:14,480
behave really weirdly but that didn't

576
00:21:14,480 --> 00:21:17,520
end up panning out i also looked at some

577
00:21:17,520 --> 00:21:18,480
other

578
00:21:18,480 --> 00:21:20,320
maybe there were ways to corrupt l2

579
00:21:20,320 --> 00:21:21,840
cache entries

580
00:21:21,840 --> 00:21:24,000
by mismanaging state that didn't pan out

581
00:21:24,000 --> 00:21:25,200
either

582
00:21:25,200 --> 00:21:27,039
so nothing that i really looked at

583
00:21:27,039 --> 00:21:28,320
ended up

584
00:21:28,320 --> 00:21:30,880
making uh the system behave in a weird

585
00:21:30,880 --> 00:21:32,640
way that led me to think that you know

586
00:21:32,640 --> 00:21:34,559
maybe there's a way to bypass ktr down

587
00:21:34,559 --> 00:21:37,280
this avenue so i eventually you know

588
00:21:37,280 --> 00:21:38,720
a lot of research didn't pan out so i

589
00:21:38,720 --> 00:21:40,159
kind of put this on the back burner for

590
00:21:40,159 --> 00:21:41,760
a while and didn't really think about it

591
00:21:41,760 --> 00:21:43,360
for a couple months

592
00:21:43,360 --> 00:21:45,840
um but eventually i saw something kind

593
00:21:45,840 --> 00:21:47,840
of interesting which brought this

594
00:21:47,840 --> 00:21:49,760
project back to the forefront which is

595
00:21:49,760 --> 00:21:51,919
that i managed to

596
00:21:51,919 --> 00:21:53,840
get a really weird panic message to

597
00:21:53,840 --> 00:21:55,600
happen on my iphone

598
00:21:55,600 --> 00:21:57,760
so i was playing around with interrupts

599
00:21:57,760 --> 00:22:00,320
and i managed to get a cpu core stuck in

600
00:22:00,320 --> 00:22:01,760
the kernel in an infinite loop with

601
00:22:01,760 --> 00:22:04,080
interrupts disabled um when you get into

602
00:22:04,080 --> 00:22:06,000
this weird state basically you know

603
00:22:06,000 --> 00:22:09,200
nothing can preempt this cpu core um and

604
00:22:09,200 --> 00:22:10,640
make it execute anything else because

605
00:22:10,640 --> 00:22:12,720
interrupts are disabled so the way the

606
00:22:12,720 --> 00:22:14,400
system detects this is it'll say hey

607
00:22:14,400 --> 00:22:15,520
look

608
00:22:15,520 --> 00:22:18,159
cpu core number one hasn't checked in

609
00:22:18,159 --> 00:22:20,320
with the watchdog timer in you know five

610
00:22:20,320 --> 00:22:22,720
seconds so probably it's really stuck in

611
00:22:22,720 --> 00:22:24,400
an infinite loop so we're going to panic

612
00:22:24,400 --> 00:22:25,440
the system

613
00:22:25,440 --> 00:22:26,640
that's exactly what you see in this

614
00:22:26,640 --> 00:22:28,400
panic message it says

615
00:22:28,400 --> 00:22:29,760
panic

616
00:22:29,760 --> 00:22:32,400
watchdog timer timeout cpu 1 failed to

617
00:22:32,400 --> 00:22:34,000
respond

618
00:22:34,000 --> 00:22:35,760
but what caught my eye about this panic

619
00:22:35,760 --> 00:22:36,960
message was actually something a little

620
00:22:36,960 --> 00:22:39,440
bit earlier on which i noticed but not

621
00:22:39,440 --> 00:22:41,520
really paid attention to before it said

622
00:22:41,520 --> 00:22:45,280
attempting to forcibly halt cpu one

623
00:22:45,280 --> 00:22:47,280
uh and this was really interesting to me

624
00:22:47,280 --> 00:22:50,480
because uh forcibly halting a cpu as far

625
00:22:50,480 --> 00:22:52,400
as i was aware there wasn't a way to do

626
00:22:52,400 --> 00:22:55,840
that uh in kind of your standard arm uh

627
00:22:55,840 --> 00:22:57,440
architecture there wasn't like an

628
00:22:57,440 --> 00:22:58,880
instruction that you could execute that

629
00:22:58,880 --> 00:23:01,679
was like uh halt cpu they halt a

630
00:23:01,679 --> 00:23:03,200
different cpu there's no instruction

631
00:23:03,200 --> 00:23:04,720
that does that uh in the arm

632
00:23:04,720 --> 00:23:06,799
architecture so i was like you know this

633
00:23:06,799 --> 00:23:08,159
seems kind of weird i don't really know

634
00:23:08,159 --> 00:23:10,000
how this would be implemented

635
00:23:10,000 --> 00:23:12,080
maybe you know there's some sort of

636
00:23:12,080 --> 00:23:14,720
custom cpu control register involved

637
00:23:14,720 --> 00:23:17,360
accessible via mmio i don't really know

638
00:23:17,360 --> 00:23:18,720
but you know it seemed really

639
00:23:18,720 --> 00:23:20,159
interesting and certainly not something

640
00:23:20,159 --> 00:23:22,080
i've ever seen before so might as well

641
00:23:22,080 --> 00:23:23,919
kind of dig into this and see what there

642
00:23:23,919 --> 00:23:25,360
is there

643
00:23:25,360 --> 00:23:28,080
so in order to do that i pulled up the

644
00:23:28,080 --> 00:23:30,960
most useful uh security research tool

645
00:23:30,960 --> 00:23:32,720
that exists which everyone say it with

646
00:23:32,720 --> 00:23:34,840
me

647
00:23:34,840 --> 00:23:37,520
crap uh so i basically uh grabbed

648
00:23:37,520 --> 00:23:40,080
through the xmu source code and found

649
00:23:40,080 --> 00:23:41,760
this string attempting to forcibly halt

650
00:23:41,760 --> 00:23:43,120
cpu

651
00:23:43,120 --> 00:23:44,640
uh and this really quickly brought me to

652
00:23:44,640 --> 00:23:47,200
this function which was ml debug grab

653
00:23:47,200 --> 00:23:48,480
halt cpu

654
00:23:48,480 --> 00:23:50,720
this function takes the index uh so zero

655
00:23:50,720 --> 00:23:52,640
to five of the cpu core that you're

656
00:23:52,640 --> 00:23:54,880
trying to halt uh and the implementation

657
00:23:54,880 --> 00:23:57,279
is a little bit lower on uh where we

658
00:23:57,279 --> 00:24:00,799
have this volatile uh integer type debug

659
00:24:00,799 --> 00:24:02,159
wrap reg

660
00:24:02,159 --> 00:24:04,480
and the actual act of halting the cpu

661
00:24:04,480 --> 00:24:07,520
core simply consists of writing this

662
00:24:07,520 --> 00:24:10,240
value debug wrap halt to

663
00:24:10,240 --> 00:24:11,200
the

664
00:24:11,200 --> 00:24:14,080
address pointed to by debug rap greg

665
00:24:14,080 --> 00:24:15,760
so this is really interesting uh the

666
00:24:15,760 --> 00:24:17,279
fact that we're dealing with volatile

667
00:24:17,279 --> 00:24:19,039
memory and uh

668
00:24:19,039 --> 00:24:21,520
performing an action simply consists of

669
00:24:21,520 --> 00:24:23,919
doing a single write uh really strongly

670
00:24:23,919 --> 00:24:26,320
suggests that we have some sort of mmio

671
00:24:26,320 --> 00:24:29,360
register here so there's memory maps of

672
00:24:29,360 --> 00:24:31,120
you know memory mapped physical address

673
00:24:31,120 --> 00:24:32,720
and when you issue a right to this

674
00:24:32,720 --> 00:24:35,279
physical address it causes the hardware

675
00:24:35,279 --> 00:24:38,320
to perform an action on your behalf

676
00:24:38,320 --> 00:24:39,840
so this really looked promising as you

677
00:24:39,840 --> 00:24:41,440
know there really looks something

678
00:24:41,440 --> 00:24:42,880
interesting here i haven't seen this

679
00:24:42,880 --> 00:24:44,840
before um and it's kind of the name

680
00:24:44,840 --> 00:24:47,520
itself wrap i don't know what rap stands

681
00:24:47,520 --> 00:24:49,279
for but debug i've heard the name debug

682
00:24:49,279 --> 00:24:51,919
before so it seems worth investigating

683
00:24:51,919 --> 00:24:53,200
um and the other thing which was kind of

684
00:24:53,200 --> 00:24:54,640
interesting and caught my eye was

685
00:24:54,640 --> 00:24:57,360
references to coresight um it seems like

686
00:24:57,360 --> 00:25:00,240
this debug wrap variable

687
00:25:00,240 --> 00:25:04,320
is read off of a per cpu data structure

688
00:25:04,320 --> 00:25:07,360
as part of this coresight base uh array

689
00:25:07,360 --> 00:25:09,679
of pointers so whatever this coresight

690
00:25:09,679 --> 00:25:11,360
is maybe it's kind of the technology

691
00:25:11,360 --> 00:25:13,120
that provides this debug wrap thing i

692
00:25:13,120 --> 00:25:14,960
didn't really know at the time but

693
00:25:14,960 --> 00:25:17,760
definitely seemed worth investigating

694
00:25:17,760 --> 00:25:19,760
um but really the most interesting

695
00:25:19,760 --> 00:25:21,919
feature uh that i found while i was

696
00:25:21,919 --> 00:25:23,840
reading through this code was a function

697
00:25:23,840 --> 00:25:26,000
just a little a few lines down

698
00:25:26,000 --> 00:25:28,480
which was called ml debug wrap halt cpu

699
00:25:28,480 --> 00:25:30,080
with state

700
00:25:30,080 --> 00:25:32,000
so this is a very similar function to ml

701
00:25:32,000 --> 00:25:33,919
debug wrap called cpu

702
00:25:33,919 --> 00:25:35,919
it again takes the index of the cpu you

703
00:25:35,919 --> 00:25:37,520
want to halt

704
00:25:37,520 --> 00:25:39,600
but the main difference between this one

705
00:25:39,600 --> 00:25:41,520
and the old function is that this

706
00:25:41,520 --> 00:25:44,000
function in addition to halting the cpu

707
00:25:44,000 --> 00:25:46,480
also gives you the state of the halted

708
00:25:46,480 --> 00:25:49,039
registers in a

709
00:25:49,039 --> 00:25:51,919
state data structure so it's supposed to

710
00:25:51,919 --> 00:25:53,760
fill out you know

711
00:25:53,760 --> 00:25:56,720
x i contains the numerical value of

712
00:25:56,720 --> 00:25:58,799
register x i at the point that it was

713
00:25:58,799 --> 00:26:00,559
halted um

714
00:26:00,559 --> 00:26:02,159
so really really interesting i didn't

715
00:26:02,159 --> 00:26:03,360
know how this could possibly be

716
00:26:03,360 --> 00:26:05,279
implemented but digging through i kind

717
00:26:05,279 --> 00:26:08,000
of found two interesting points so here

718
00:26:08,000 --> 00:26:10,400
you can see there's another reference to

719
00:26:10,400 --> 00:26:12,320
these memory mapped coresight registers

720
00:26:12,320 --> 00:26:13,760
so that definitely seems like you know

721
00:26:13,760 --> 00:26:17,039
something important to do with coresight

722
00:26:17,039 --> 00:26:18,799
but then the actual implementation of

723
00:26:18,799 --> 00:26:20,159
this function is what's really really

724
00:26:20,159 --> 00:26:22,080
fascinating and so here you can see

725
00:26:22,080 --> 00:26:24,559
there's a loop over uh all the indices

726
00:26:24,559 --> 00:26:26,720
the general purpose registers

727
00:26:26,720 --> 00:26:29,440
and it does uh the the following steps

728
00:26:29,440 --> 00:26:31,600
so the first thing it does is it builds

729
00:26:31,600 --> 00:26:35,039
the numerical op code of this msr debug

730
00:26:35,039 --> 00:26:37,520
dtr xi instruction

731
00:26:37,520 --> 00:26:40,720
so this is so the msr debug dtr xi

732
00:26:40,720 --> 00:26:42,720
instruction is going to move the value

733
00:26:42,720 --> 00:26:44,400
of register xi

734
00:26:44,400 --> 00:26:46,720
into this special system register debug

735
00:26:46,720 --> 00:26:48,159
dtr

736
00:26:48,159 --> 00:26:50,159
but this isn't actually the op code

737
00:26:50,159 --> 00:26:52,000
inside of the code this is building the

738
00:26:52,000 --> 00:26:54,400
numerical value of that op code it's

739
00:26:54,400 --> 00:26:56,480
like building the like number of the

740
00:26:56,480 --> 00:26:57,520
instruction that you would want to

741
00:26:57,520 --> 00:26:58,960
execute but it doesn't actually have

742
00:26:58,960 --> 00:27:01,760
that instruction present in the code

743
00:27:01,760 --> 00:27:03,520
it then passes the

744
00:27:03,520 --> 00:27:05,279
numerical value of that opcode to this

745
00:27:05,279 --> 00:27:06,799
function ml debug graph stuff

746
00:27:06,799 --> 00:27:08,000
instruction

747
00:27:08,000 --> 00:27:09,840
and then afterwards it calls the

748
00:27:09,840 --> 00:27:12,640
function ml debug wrap read dtr to read

749
00:27:12,640 --> 00:27:15,679
the value of debug dtr and it stores

750
00:27:15,679 --> 00:27:18,799
that in the state variable x i

751
00:27:18,799 --> 00:27:20,399
so what this really really strongly

752
00:27:20,399 --> 00:27:23,200
suggests is that the ml debug wrap stuff

753
00:27:23,200 --> 00:27:25,200
instruction function is actually

754
00:27:25,200 --> 00:27:27,200
executing dynamically generated

755
00:27:27,200 --> 00:27:28,640
instructions

756
00:27:28,640 --> 00:27:30,320
and this is really really interesting

757
00:27:30,320 --> 00:27:32,799
because it flies in the face of the ktrr

758
00:27:32,799 --> 00:27:36,559
security model if you think of ktrr as

759
00:27:36,559 --> 00:27:39,760
a way to lock down what instructions can

760
00:27:39,760 --> 00:27:42,080
be executed in apple's kernel such that

761
00:27:42,080 --> 00:27:44,000
only the instructions that are signed by

762
00:27:44,000 --> 00:27:46,240
secure boot those are the only ones that

763
00:27:46,240 --> 00:27:48,240
can be executed well here we have a

764
00:27:48,240 --> 00:27:49,520
function which is just like you know

765
00:27:49,520 --> 00:27:51,279
give me an op code and i'll execute it

766
00:27:51,279 --> 00:27:52,240
for you

767
00:27:52,240 --> 00:27:54,399
so this is really really weird it's very

768
00:27:54,399 --> 00:27:56,880
um unexpected and not something which

769
00:27:56,880 --> 00:27:57,760
you know

770
00:27:57,760 --> 00:28:00,240
makes sense under the ktrr uh security

771
00:28:00,240 --> 00:28:02,000
model so i think you know really

772
00:28:02,000 --> 00:28:03,840
definitely is a very promising avenue

773
00:28:03,840 --> 00:28:06,960
for a ktrr bypass

774
00:28:06,960 --> 00:28:09,279
but just because a piece of code exists

775
00:28:09,279 --> 00:28:11,200
in the xnu kernel doesn't mean that that

776
00:28:11,200 --> 00:28:13,679
code actually works so um the only way

777
00:28:13,679 --> 00:28:16,080
to find out is to actually run the code

778
00:28:16,080 --> 00:28:17,600
and see you know does this function

779
00:28:17,600 --> 00:28:19,120
actually work

780
00:28:19,120 --> 00:28:22,240
so i did an experiment i basically

781
00:28:22,240 --> 00:28:24,240
took an exploit that i'd previously

782
00:28:24,240 --> 00:28:26,320
written a kernel exploit that gave me

783
00:28:26,320 --> 00:28:29,360
the ability to call kernel functions

784
00:28:29,360 --> 00:28:31,679
and i extended it with a bit of code

785
00:28:31,679 --> 00:28:34,480
that would just call this uh kernel

786
00:28:34,480 --> 00:28:36,480
function ml debug wrap call cpu with

787
00:28:36,480 --> 00:28:38,320
state from user space

788
00:28:38,320 --> 00:28:40,559
and uh when i call this kernel function

789
00:28:40,559 --> 00:28:43,120
it's going to pass in the address of uh

790
00:28:43,120 --> 00:28:46,000
some you know internal buffer

791
00:28:46,000 --> 00:28:47,919
and then i would read out the value of

792
00:28:47,919 --> 00:28:49,440
output value of the buffer after the

793
00:28:49,440 --> 00:28:51,520
function returns and dump it to see you

794
00:28:51,520 --> 00:28:53,440
know did it actually look like i halted

795
00:28:53,440 --> 00:28:57,039
a cpu and dumped out his registers

796
00:28:57,039 --> 00:28:59,039
and what i found was somewhat surprising

797
00:28:59,039 --> 00:29:00,720
um but it kind of looked like it did

798
00:29:00,720 --> 00:29:03,600
actually work um so in particular uh the

799
00:29:03,600 --> 00:29:08,000
value of cpsr right there on 6003 z5

800
00:29:08,000 --> 00:29:10,480
really really looks like a valid cpsr

801
00:29:10,480 --> 00:29:13,600
value and in particular looks like a

802
00:29:13,600 --> 00:29:15,840
cpu core that's executing in kernel mode

803
00:29:15,840 --> 00:29:18,240
with interrupts disabled

804
00:29:18,240 --> 00:29:21,200
now um the pc value doesn't really match

805
00:29:21,200 --> 00:29:23,279
a kernel pointer um you would expect the

806
00:29:23,279 --> 00:29:24,799
first couple digits to be all like fff

807
00:29:24,799 --> 00:29:28,559
ffff in that case but it does look a lot

808
00:29:28,559 --> 00:29:30,399
like a physical address

809
00:29:30,399 --> 00:29:32,799
which is kind of wild and so i uh you

810
00:29:32,799 --> 00:29:35,039
know took the kernel slide calculated

811
00:29:35,039 --> 00:29:36,720
what this address would be in static

812
00:29:36,720 --> 00:29:38,720
kernel cache and what i found was that

813
00:29:38,720 --> 00:29:40,399
this is actually the address of an

814
00:29:40,399 --> 00:29:42,880
instruction in the reset vector

815
00:29:42,880 --> 00:29:44,880
what this means is that we've managed to

816
00:29:44,880 --> 00:29:47,760
actually halt execution of a cpu core

817
00:29:47,760 --> 00:29:49,679
inside of the reset vector and in

818
00:29:49,679 --> 00:29:51,760
particular before the mmu has been

819
00:29:51,760 --> 00:29:53,679
turned on

820
00:29:53,679 --> 00:29:56,960
because ktrr only takes effect once the

821
00:29:56,960 --> 00:29:59,200
mmu has been turned on that means we've

822
00:29:59,200 --> 00:30:02,240
managed to halt the cpu before ktrr has

823
00:30:02,240 --> 00:30:03,679
been locked down

824
00:30:03,679 --> 00:30:06,080
so at this point in time after where the

825
00:30:06,080 --> 00:30:08,880
cpu core has been halted kfr is not

826
00:30:08,880 --> 00:30:11,120
blocking us from scribbling all over the

827
00:30:11,120 --> 00:30:13,279
protected memory region so this is

828
00:30:13,279 --> 00:30:14,799
really really cool

829
00:30:14,799 --> 00:30:16,880
um

830
00:30:16,880 --> 00:30:18,720
but so how are we actually going to use

831
00:30:18,720 --> 00:30:21,440
this to bypass ktr it seems really

832
00:30:21,440 --> 00:30:23,440
promising but you know we're not quite

833
00:30:23,440 --> 00:30:25,279
there yet

834
00:30:25,279 --> 00:30:26,799
and really the key to figuring out how

835
00:30:26,799 --> 00:30:28,960
to bypass this and we need to understand

836
00:30:28,960 --> 00:30:30,720
what this coresight thing that we keep

837
00:30:30,720 --> 00:30:33,039
seeing references do is

838
00:30:33,039 --> 00:30:34,720
uh so a little bit of research if you

839
00:30:34,720 --> 00:30:37,200
dive into the arm architecture manual

840
00:30:37,200 --> 00:30:39,360
for rba you'll see there are a number of

841
00:30:39,360 --> 00:30:41,760
references to coresight um in particular

842
00:30:41,760 --> 00:30:43,679
you'll learn that there's a memory

843
00:30:43,679 --> 00:30:46,240
mapped external debug interface

844
00:30:46,240 --> 00:30:48,799
which is basically if you remember uh

845
00:30:48,799 --> 00:30:51,120
ian beers build your own ios terminal

846
00:30:51,120 --> 00:30:52,640
debugger project

847
00:30:52,640 --> 00:30:56,320
ian beer was using the uh

848
00:30:56,320 --> 00:30:59,200
self-hosted debug interface

849
00:30:59,200 --> 00:31:00,080
and

850
00:31:00,080 --> 00:31:01,200
coresight

851
00:31:01,200 --> 00:31:03,600
what we're seeing here is the external

852
00:31:03,600 --> 00:31:05,120
debug interface which is kind of the

853
00:31:05,120 --> 00:31:06,960
memory mapped version of that same

854
00:31:06,960 --> 00:31:09,279
interface so for the most part the same

855
00:31:09,279 --> 00:31:11,600
debugging hardware under the hood um is

856
00:31:11,600 --> 00:31:13,679
just accessed in a different way via

857
00:31:13,679 --> 00:31:16,480
mmio or via an external debug port

858
00:31:16,480 --> 00:31:18,399
rather than by the kernel executing

859
00:31:18,399 --> 00:31:19,840
special instructions to drive the

860
00:31:19,840 --> 00:31:21,679
debugging hardware

861
00:31:21,679 --> 00:31:24,320
so very promising if we can access uh

862
00:31:24,320 --> 00:31:26,159
the same debugging interface that ian

863
00:31:26,159 --> 00:31:29,120
used but via memory mapped i o rather

864
00:31:29,120 --> 00:31:31,200
than by executing special instructions

865
00:31:31,200 --> 00:31:32,799
then it doesn't even matter that apple

866
00:31:32,799 --> 00:31:35,120
has removed the instructions that ian

867
00:31:35,120 --> 00:31:37,120
used in his return areas of programming

868
00:31:37,120 --> 00:31:38,240
so we can

869
00:31:38,240 --> 00:31:40,080
create those same effects just by

870
00:31:40,080 --> 00:31:43,200
writing to memory regions

871
00:31:43,200 --> 00:31:46,159
and definitely this is not by any means

872
00:31:46,159 --> 00:31:48,559
the first time that anyone has used

873
00:31:48,559 --> 00:31:50,480
the external debug interface to do

874
00:31:50,480 --> 00:31:52,240
interesting things violate privilege

875
00:31:52,240 --> 00:31:55,360
barriers uh on systems so at most like

876
00:31:55,360 --> 00:31:57,760
2019 there was a presentation on the

877
00:31:57,760 --> 00:31:59,600
nail gun attack which is a way to

878
00:31:59,600 --> 00:32:00,399
extract

879
00:32:00,399 --> 00:32:02,880
fingerprint data from trust zone on

880
00:32:02,880 --> 00:32:04,480
certain armed devices

881
00:32:04,480 --> 00:32:06,559
um and you know

882
00:32:06,559 --> 00:32:08,720
this is you know clearly demonstrates

883
00:32:08,720 --> 00:32:11,440
that uh using foresight to do stuff like

884
00:32:11,440 --> 00:32:13,279
this of highlight privilege boundaries

885
00:32:13,279 --> 00:32:16,159
is totally totally possible in practice

886
00:32:16,159 --> 00:32:18,399
um and has been done for ages and ages

887
00:32:18,399 --> 00:32:21,039
both publicly and privately

888
00:32:21,039 --> 00:32:23,200
so kind of uh summer summarizing the

889
00:32:23,200 --> 00:32:25,440
coresight external debug interface it's

890
00:32:25,440 --> 00:32:28,240
an on-chip debugging architecture there

891
00:32:28,240 --> 00:32:30,320
are per cpu debug registers which are

892
00:32:30,320 --> 00:32:32,320
accessible via mmio

893
00:32:32,320 --> 00:32:34,000
and it's really extensively documented

894
00:32:34,000 --> 00:32:35,760
in the arm manual so i'm not going to go

895
00:32:35,760 --> 00:32:37,840
into all those details here

896
00:32:37,840 --> 00:32:40,080
but what i will say is that it does give

897
00:32:40,080 --> 00:32:41,760
you all the functionality you would need

898
00:32:41,760 --> 00:32:43,279
to build a thermal debugger including

899
00:32:43,279 --> 00:32:44,880
the ability to set breakpoints and watch

900
00:32:44,880 --> 00:32:46,960
points the ability to execute arbitrary

901
00:32:46,960 --> 00:32:49,679
instructions uh all that kind of stuff

902
00:32:49,679 --> 00:32:52,320
uh and it is in fact the memory mapped

903
00:32:52,320 --> 00:32:54,880
version of the debug registers used in

904
00:32:54,880 --> 00:32:57,039
ian's build your own ios kernel debugger

905
00:32:57,039 --> 00:32:59,440
project so very promising for us to

906
00:32:59,440 --> 00:33:01,519
bypass kprr

907
00:33:01,519 --> 00:33:03,120
the idea that i had

908
00:33:03,120 --> 00:33:05,600
to use the external debug interface was

909
00:33:05,600 --> 00:33:07,840
to basically single step execution of

910
00:33:07,840 --> 00:33:10,000
the reset vector and skip the point at

911
00:33:10,000 --> 00:33:12,000
which ktr is locked down

912
00:33:12,000 --> 00:33:14,000
so hypothetically you could set a

913
00:33:14,000 --> 00:33:15,840
breakpoint at the very beginning of low

914
00:33:15,840 --> 00:33:18,399
reset vector base and just do you know

915
00:33:18,399 --> 00:33:20,559
figure out how to do single stepping uh

916
00:33:20,559 --> 00:33:21,840
and single step through all these

917
00:33:21,840 --> 00:33:23,679
instructions until we get to this

918
00:33:23,679 --> 00:33:25,279
conditional branch instruction right

919
00:33:25,279 --> 00:33:26,399
here

920
00:33:26,399 --> 00:33:28,880
and then you know change the register

921
00:33:28,880 --> 00:33:31,679
state at this exact point to make x 17 0

922
00:33:31,679 --> 00:33:33,600
and then we'll take the branch and skip

923
00:33:33,600 --> 00:33:37,840
over the ktr lockdown code leaving ktrr

924
00:33:37,840 --> 00:33:42,399
uninitialized and unprotected on the mmu

925
00:33:42,399 --> 00:33:43,760
but we don't quite have enough to do

926
00:33:43,760 --> 00:33:45,279
that at this point

927
00:33:45,279 --> 00:33:46,000
we

928
00:33:46,000 --> 00:33:48,240
have the ability to halt the cpu core

929
00:33:48,240 --> 00:33:49,679
and we know that we can execute

930
00:33:49,679 --> 00:33:51,679
instructions on it but we still don't

931
00:33:51,679 --> 00:33:53,840
know how to resume execution after

932
00:33:53,840 --> 00:33:55,919
having halted a cpu and done our

933
00:33:55,919 --> 00:33:58,159
modifications so you know if we manage

934
00:33:58,159 --> 00:34:00,159
to halt the cpu and reset vector that's

935
00:34:00,159 --> 00:34:01,760
still not a ton of use to us and we

936
00:34:01,760 --> 00:34:03,919
can't then like resume execution

937
00:34:03,919 --> 00:34:05,039
afterwards because then we're just going

938
00:34:05,039 --> 00:34:07,600
to be stuck in the reset vector forever

939
00:34:07,600 --> 00:34:09,040
and similarly

940
00:34:09,040 --> 00:34:11,520
we know that we can use one cpu core to

941
00:34:11,520 --> 00:34:13,679
hijack a second cpu core as it's

942
00:34:13,679 --> 00:34:16,399
executing the reset vector but if we

943
00:34:16,399 --> 00:34:18,639
have to do that every single time a cpu

944
00:34:18,639 --> 00:34:20,800
core resets that's kind of a pain like

945
00:34:20,800 --> 00:34:23,679
your cpu cores reset all the time and if

946
00:34:23,679 --> 00:34:25,839
it has to happen every single time like

947
00:34:25,839 --> 00:34:27,918
what happens if all six cpus reset at

948
00:34:27,918 --> 00:34:29,839
the same time then you lose all of your

949
00:34:29,839 --> 00:34:32,800
bypass state and your your uh htr bypass

950
00:34:32,800 --> 00:34:34,639
is gone at that point that would be

951
00:34:34,639 --> 00:34:36,560
really really problematic so ideally

952
00:34:36,560 --> 00:34:38,480
there would be some way to disable cpu

953
00:34:38,480 --> 00:34:40,480
cores for resetting so we only have to

954
00:34:40,480 --> 00:34:43,280
bypass ktrr once uh and then it's just

955
00:34:43,280 --> 00:34:46,079
good to go from that point on

956
00:34:46,079 --> 00:34:48,159
uh and it actually turned out to be not

957
00:34:48,159 --> 00:34:49,679
nearly as difficult as i feared it would

958
00:34:49,679 --> 00:34:51,918
be to find both of these functionalities

959
00:34:51,918 --> 00:34:53,599
so if you remember there was the

960
00:34:53,599 --> 00:34:55,760
coresight external debug interface and

961
00:34:55,760 --> 00:34:57,680
also this debug wrap register which is

962
00:34:57,680 --> 00:35:00,000
the first register that we found um the

963
00:35:00,000 --> 00:35:02,960
debug wrap register is not part of

964
00:35:02,960 --> 00:35:05,280
coresight uh it seems to be some sort of

965
00:35:05,280 --> 00:35:06,800
apple custom thing

966
00:35:06,800 --> 00:35:09,359
and uh is totally undocumented but i

967
00:35:09,359 --> 00:35:11,119
basically just you know did a ton of

968
00:35:11,119 --> 00:35:13,040
experiments just setting random bits in

969
00:35:13,040 --> 00:35:15,200
this register to see what would happen

970
00:35:15,200 --> 00:35:17,440
and just by a sheer dumb luck

971
00:35:17,440 --> 00:35:19,440
all the functionality that we needed to

972
00:35:19,440 --> 00:35:21,599
complete the ktr bypass is

973
00:35:21,599 --> 00:35:23,440
present in these registers so we have

974
00:35:23,440 --> 00:35:25,200
the ability to set

975
00:35:25,200 --> 00:35:28,000
i think it's bit 29 will cause the cpu

976
00:35:28,000 --> 00:35:30,160
to resume and a different bit will cause

977
00:35:30,160 --> 00:35:31,920
it to disable poor resets and then

978
00:35:31,920 --> 00:35:34,880
you're totally set and good to go

979
00:35:34,880 --> 00:35:37,440
so the final ktr bypass basically looks

980
00:35:37,440 --> 00:35:39,760
like um the single step execution until

981
00:35:39,760 --> 00:35:41,839
you get to this branch instruction

982
00:35:41,839 --> 00:35:43,920
and then take the branch to skip hr

983
00:35:43,920 --> 00:35:46,160
lockdown ktr registers never get

984
00:35:46,160 --> 00:35:47,839
initialized

985
00:35:47,839 --> 00:35:49,599
and then your cpu core goes from looking

986
00:35:49,599 --> 00:35:52,240
like this with the uh mmu

987
00:35:52,240 --> 00:35:54,960
kpr registers in green being initialized

988
00:35:54,960 --> 00:35:56,800
all of a sudden being disabled

989
00:35:56,800 --> 00:35:58,320
which means that we now have the ability

990
00:35:58,320 --> 00:36:01,599
to execute kernel shell code

991
00:36:01,920 --> 00:36:03,200
all right so

992
00:36:03,200 --> 00:36:05,920
it's been kind of a whirlwind

993
00:36:05,920 --> 00:36:08,560
thank you thank you

994
00:36:08,880 --> 00:36:10,240
basically in order to build the kernel

995
00:36:10,240 --> 00:36:12,160
debugger the first thing we need to do

996
00:36:12,160 --> 00:36:14,560
is remap the kernel to make it writable

997
00:36:14,560 --> 00:36:16,560
um then we need the to build a

998
00:36:16,560 --> 00:36:18,320
capability to load a kernel extension

999
00:36:18,320 --> 00:36:20,320
since it would be really really sucky to

1000
00:36:20,320 --> 00:36:21,839
implement our entire thermal debugger

1001
00:36:21,839 --> 00:36:23,920
and user space and like do you know back

1002
00:36:23,920 --> 00:36:25,440
and forth to the kernel while the

1003
00:36:25,440 --> 00:36:27,440
debugger is debugging that extreme

1004
00:36:27,440 --> 00:36:29,760
kernel that's a huge pain

1005
00:36:29,760 --> 00:36:30,880
we need to make sure the interrupt

1006
00:36:30,880 --> 00:36:32,640
handling is correct because there's a

1007
00:36:32,640 --> 00:36:34,960
lot of trickiness involved in

1008
00:36:34,960 --> 00:36:36,560
making sure that the

1009
00:36:36,560 --> 00:36:38,640
uh when you're halting cpu cores those

1010
00:36:38,640 --> 00:36:40,800
happen in a very safe way

1011
00:36:40,800 --> 00:36:42,000
we need to establish some sort of

1012
00:36:42,000 --> 00:36:44,640
communication channel between the phone

1013
00:36:44,640 --> 00:36:46,400
that has the debugger running on it and

1014
00:36:46,400 --> 00:36:49,200
your laptop which is running like lldb

1015
00:36:49,200 --> 00:36:50,800
uh and finally we need to implement a

1016
00:36:50,800 --> 00:36:52,880
gdp stub which is capable of receiving

1017
00:36:52,880 --> 00:36:54,960
commands from your computer and driving

1018
00:36:54,960 --> 00:36:58,240
the debugger on the phone

1019
00:36:58,240 --> 00:37:00,560
uh so at the point we are right now

1020
00:37:00,560 --> 00:37:03,760
we've disabled ktr on the mmu but kcr is

1021
00:37:03,760 --> 00:37:05,839
still fully enabled on the memory

1022
00:37:05,839 --> 00:37:07,359
controller

1023
00:37:07,359 --> 00:37:10,079
so what this means is that the pages

1024
00:37:10,079 --> 00:37:12,480
that are still protected by ktrr are

1025
00:37:12,480 --> 00:37:15,040
still read-only we can't yet modify

1026
00:37:15,040 --> 00:37:18,720
those specific physical pages

1027
00:37:18,960 --> 00:37:20,720
this is really problematic because we

1028
00:37:20,720 --> 00:37:22,640
need to be able to modify

1029
00:37:22,640 --> 00:37:24,720
page table permissions in order to make

1030
00:37:24,720 --> 00:37:26,160
our kernel extension which we're going

1031
00:37:26,160 --> 00:37:29,839
to put in the kernel be executable

1032
00:37:29,839 --> 00:37:31,280
because there's no text loading

1033
00:37:31,280 --> 00:37:32,960
functionality that we can use out of the

1034
00:37:32,960 --> 00:37:35,359
box in ios

1035
00:37:35,359 --> 00:37:38,000
and in particular the root page tables

1036
00:37:38,000 --> 00:37:40,640
are in the ktr read-only region uh so

1037
00:37:40,640 --> 00:37:42,560
the root page table hierarchy is still

1038
00:37:42,560 --> 00:37:44,800
read only at this point

1039
00:37:44,800 --> 00:37:46,320
so the way to get around this is just

1040
00:37:46,320 --> 00:37:48,720
like what luca tedesco did

1041
00:37:48,720 --> 00:37:52,400
back in ios 10-1-1 we can remap the

1042
00:37:52,400 --> 00:37:54,800
kernel onto fresh writal pages and set

1043
00:37:54,800 --> 00:37:57,280
ttbr1 to point to the new page tables

1044
00:37:57,280 --> 00:37:59,520
instead

1045
00:37:59,520 --> 00:38:00,240
so

1046
00:38:00,240 --> 00:38:02,079
looking at the system here

1047
00:38:02,079 --> 00:38:04,240
we have ttbr1 points the root of the

1048
00:38:04,240 --> 00:38:06,480
page table hierarchy which is inside of

1049
00:38:06,480 --> 00:38:08,400
the locks down region

1050
00:38:08,400 --> 00:38:11,599
all we do is we copy the contents of

1051
00:38:11,599 --> 00:38:14,240
those locks down pages onto new pages

1052
00:38:14,240 --> 00:38:16,720
and we update ttvr1 to point to the new

1053
00:38:16,720 --> 00:38:19,520
page tables instead and now we can just

1054
00:38:19,520 --> 00:38:22,160
forget that those old pages even existed

1055
00:38:22,160 --> 00:38:23,839
pretend that memory has just been leaked

1056
00:38:23,839 --> 00:38:25,839
and it's gone uh and now our kernel

1057
00:38:25,839 --> 00:38:27,200
appears to be writable from the

1058
00:38:27,200 --> 00:38:30,319
perspective of the kernel

1059
00:38:30,560 --> 00:38:32,000
at this point it's pretty easy to load

1060
00:38:32,000 --> 00:38:33,760
kernel extensions we just allocate some

1061
00:38:33,760 --> 00:38:35,920
memory for the kernel extension uh copy

1062
00:38:35,920 --> 00:38:37,599
in the binary of the kernel extension

1063
00:38:37,599 --> 00:38:39,920
into kernel memory uh dynamically link

1064
00:38:39,920 --> 00:38:42,079
it against the running kernel

1065
00:38:42,079 --> 00:38:43,920
and then modify page table permissions

1066
00:38:43,920 --> 00:38:46,400
to make it executable and finally we can

1067
00:38:46,400 --> 00:38:48,960
call the text start function inside the

1068
00:38:48,960 --> 00:38:52,640
kernel extension to begin it running

1069
00:38:53,040 --> 00:38:54,720
and that's basically it for kernel

1070
00:38:54,720 --> 00:38:56,720
extension loading at this point we can

1071
00:38:56,720 --> 00:38:58,720
begin kind of designing the debugger

1072
00:38:58,720 --> 00:39:00,880
itself and so i settled on a very

1073
00:39:00,880 --> 00:39:03,599
simplistic design um just because it was

1074
00:39:03,599 --> 00:39:05,520
such a huge pain to get this whole

1075
00:39:05,520 --> 00:39:07,839
system working in the first place um i

1076
00:39:07,839 --> 00:39:10,000
basically said you know what screw power

1077
00:39:10,000 --> 00:39:12,160
consumption i'm going to have one core

1078
00:39:12,160 --> 00:39:13,520
which is going to be reserved for the

1079
00:39:13,520 --> 00:39:16,400
debugger itself this is the monitor port

1080
00:39:16,400 --> 00:39:18,720
and then the other five cpu cores on the

1081
00:39:18,720 --> 00:39:20,160
iphone that are left those are going to

1082
00:39:20,160 --> 00:39:22,480
still run xnu as they do normally so

1083
00:39:22,480 --> 00:39:24,400
there is kind of you know remove the

1084
00:39:24,400 --> 00:39:26,560
performance hit from removing one cpu

1085
00:39:26,560 --> 00:39:28,160
core that's reserved solely for the

1086
00:39:28,160 --> 00:39:30,560
debugger but as you can as you will see

1087
00:39:30,560 --> 00:39:32,480
it gets a lot worse than that so don't

1088
00:39:32,480 --> 00:39:34,800
worry about the performance hit there

1089
00:39:34,800 --> 00:39:37,200
um the other five cores are going to run

1090
00:39:37,200 --> 00:39:38,960
xu as they normally do

1091
00:39:38,960 --> 00:39:41,440
and when any of those cores hit a

1092
00:39:41,440 --> 00:39:43,280
breakpoint or a watch point that's going

1093
00:39:43,280 --> 00:39:45,920
to cause that uh debugged core to halt

1094
00:39:45,920 --> 00:39:48,240
and enter what's called debug state uh

1095
00:39:48,240 --> 00:39:50,400
now in debug state it's not going to the

1096
00:39:50,400 --> 00:39:51,920
cpu core isn't going to do anything it's

1097
00:39:51,920 --> 00:39:54,000
just halton and is waiting to receive

1098
00:39:54,000 --> 00:39:56,320
commands from the monitor port so the

1099
00:39:56,320 --> 00:39:58,079
monitor core is going to sit in an

1100
00:39:58,079 --> 00:40:01,040
infinite loop polling for entries from

1101
00:40:01,040 --> 00:40:03,119
the other chords in debug state and when

1102
00:40:03,119 --> 00:40:05,440
it observes that it's going to notify l

1103
00:40:05,440 --> 00:40:07,280
to be that this has happened over some

1104
00:40:07,280 --> 00:40:10,240
as yet unspecified communication channel

1105
00:40:10,240 --> 00:40:12,079
now the result of this design is that

1106
00:40:12,079 --> 00:40:13,920
you have one cpu core which is kind of

1107
00:40:13,920 --> 00:40:15,839
spinning in an infinite loop

1108
00:40:15,839 --> 00:40:18,319
in the kernel with interrupts uh most

1109
00:40:18,319 --> 00:40:20,079
interrupts disabled i think irqs are

1110
00:40:20,079 --> 00:40:22,240
still enabled but um the result of that

1111
00:40:22,240 --> 00:40:24,640
is your phone will get physically hot

1112
00:40:24,640 --> 00:40:28,319
and may burn you so be careful

1113
00:40:29,200 --> 00:40:30,319
so yeah we need some sort of

1114
00:40:30,319 --> 00:40:32,400
communication channel for lldb to

1115
00:40:32,400 --> 00:40:34,400
communicate with the kernel extension

1116
00:40:34,400 --> 00:40:37,359
running on your phone because lld is on

1117
00:40:37,359 --> 00:40:39,040
your laptop

1118
00:40:39,040 --> 00:40:40,640
so i considered a number of different

1119
00:40:40,640 --> 00:40:43,040
communication channels um we've each had

1120
00:40:43,040 --> 00:40:44,960
you know advantages and disadvantages uh

1121
00:40:44,960 --> 00:40:46,720
the advantage for serial is that it's a

1122
00:40:46,720 --> 00:40:49,280
really easy protocol to implement um

1123
00:40:49,280 --> 00:40:50,880
it's really easy to write a serial

1124
00:40:50,880 --> 00:40:52,800
driver for hardware

1125
00:40:52,800 --> 00:40:55,680
now usb i also considered because it's

1126
00:40:55,680 --> 00:40:57,839
extremely fast compared to serial you

1127
00:40:57,839 --> 00:40:59,920
know speed up is orders of magnitude

1128
00:40:59,920 --> 00:41:01,920
better so your debugging session will

1129
00:41:01,920 --> 00:41:03,680
feel much more responsive

1130
00:41:03,680 --> 00:41:06,960
uh wi-fi i consider because it's another

1131
00:41:06,960 --> 00:41:09,040
option not really any advantages that i

1132
00:41:09,040 --> 00:41:10,720
could see besides if the other two

1133
00:41:10,720 --> 00:41:12,480
didn't work out i could potentially do

1134
00:41:12,480 --> 00:41:13,920
wi-fi

1135
00:41:13,920 --> 00:41:15,599
but in the end it was the disadvantages

1136
00:41:15,599 --> 00:41:17,760
which really drove the decision

1137
00:41:17,760 --> 00:41:20,160
so serial is pretty much eliminated

1138
00:41:20,160 --> 00:41:21,760
right off the bat because it requires

1139
00:41:21,760 --> 00:41:23,839
special hardware uh in order to

1140
00:41:23,839 --> 00:41:26,160
communicate using serial to your iphone

1141
00:41:26,160 --> 00:41:29,280
um i did look into uh there are some

1142
00:41:29,280 --> 00:41:32,160
sellers of legitimate uh serial cables

1143
00:41:32,160 --> 00:41:33,599
for the iphone i tried to get those to

1144
00:41:33,599 --> 00:41:35,440
work but nothing really did

1145
00:41:35,440 --> 00:41:37,760
usb is a huge pain because it means you

1146
00:41:37,760 --> 00:41:40,000
have to write a custom usb stack that's

1147
00:41:40,000 --> 00:41:41,839
running inside of your kernel extension

1148
00:41:41,839 --> 00:41:44,960
which is separate from xmu's usb stack

1149
00:41:44,960 --> 00:41:47,680
and i really did not fancy writing a usb

1150
00:41:47,680 --> 00:41:49,520
stock from scratch

1151
00:41:49,520 --> 00:41:51,440
and wi-fi you also have to write your

1152
00:41:51,440 --> 00:41:53,920
own custom wi-fi driver from scratch so

1153
00:41:53,920 --> 00:41:55,839
between those two kind of evils writing

1154
00:41:55,839 --> 00:41:57,680
a custom usb stack was like slightly

1155
00:41:57,680 --> 00:42:00,960
better so i went with that route

1156
00:42:00,960 --> 00:42:03,119
uh now the problem with uh the usb

1157
00:42:03,119 --> 00:42:04,880
controller is that it is actually a

1158
00:42:04,880 --> 00:42:06,960
reasonably well known uh controller it's

1159
00:42:06,960 --> 00:42:08,640
by synopsis it's called the designware

1160
00:42:08,640 --> 00:42:11,920
high speed usb 2.0 on the go controller

1161
00:42:11,920 --> 00:42:13,839
uh however

1162
00:42:13,839 --> 00:42:16,000
the datasheet is actually protected by a

1163
00:42:16,000 --> 00:42:18,400
sign-in wall and i didn't have access to

1164
00:42:18,400 --> 00:42:20,480
it so i had to write a usb stack for

1165
00:42:20,480 --> 00:42:22,240
this hardware without having access to

1166
00:42:22,240 --> 00:42:23,680
an actual data sheet that told me how

1167
00:42:23,680 --> 00:42:25,760
this hardware actually operated

1168
00:42:25,760 --> 00:42:28,400
and there were some open source header

1169
00:42:28,400 --> 00:42:30,000
files describing how to operate this

1170
00:42:30,000 --> 00:42:32,560
hardware but i didn't find during the

1171
00:42:32,560 --> 00:42:34,240
course of this research project i didn't

1172
00:42:34,240 --> 00:42:36,560
find an open source driver

1173
00:42:36,560 --> 00:42:39,440
for operating the synopsis controller in

1174
00:42:39,440 --> 00:42:41,119
device mode which is what you would need

1175
00:42:41,119 --> 00:42:45,520
to do for the iphone so in the end i had

1176
00:42:45,520 --> 00:42:47,599
no data sheet i had header files

1177
00:42:47,599 --> 00:42:49,119
describing you know the offsets of the

1178
00:42:49,119 --> 00:42:50,480
registers and the names the registers

1179
00:42:50,480 --> 00:42:53,440
but that's about it um the best

1180
00:42:53,440 --> 00:42:55,440
implementation of this usb stack that i

1181
00:42:55,440 --> 00:42:58,319
could find was actually uh the secure

1182
00:42:58,319 --> 00:43:00,800
rom for the iphone itself so the secure

1183
00:43:00,800 --> 00:43:02,640
rom is kind of the boot rom for the

1184
00:43:02,640 --> 00:43:04,160
iphone it's the first piece of software

1185
00:43:04,160 --> 00:43:07,200
that starts up uh and you have access to

1186
00:43:07,200 --> 00:43:09,680
the binary forms online like people have

1187
00:43:09,680 --> 00:43:11,680
dumped the secure rom from the iphone

1188
00:43:11,680 --> 00:43:14,800
and post these binaries online publicly

1189
00:43:14,800 --> 00:43:17,280
um so basically i took one of these uh

1190
00:43:17,280 --> 00:43:18,880
dumps that someone had published and i

1191
00:43:18,880 --> 00:43:20,720
reverse engineered it to source uh to

1192
00:43:20,720 --> 00:43:22,160
see you know how does this thing

1193
00:43:22,160 --> 00:43:23,680
actually operate

1194
00:43:23,680 --> 00:43:24,640
that was

1195
00:43:24,640 --> 00:43:27,280
quite painful quite honestly and at the

1196
00:43:27,280 --> 00:43:29,520
end of this process i reversed it close

1197
00:43:29,520 --> 00:43:30,800
enough to source that i could

1198
00:43:30,800 --> 00:43:32,880
re-implement it and see

1199
00:43:32,880 --> 00:43:34,800
and get my iphone to appear to my

1200
00:43:34,800 --> 00:43:39,040
computer as this special ktrw usb device

1201
00:43:39,040 --> 00:43:40,880
well you can see the serial number is

1202
00:43:40,880 --> 00:43:42,160
google project zero so this is

1203
00:43:42,160 --> 00:43:43,680
definitely you know not your normal

1204
00:43:43,680 --> 00:43:47,119
iphone uh usb stack

1205
00:43:47,119 --> 00:43:48,720
uh the final piece of the puzzle is

1206
00:43:48,720 --> 00:43:50,880
implementing the gdp stub it's pretty

1207
00:43:50,880 --> 00:43:52,160
you know straightforward it's a bunch of

1208
00:43:52,160 --> 00:43:54,560
string parsing and driving the debug

1209
00:43:54,560 --> 00:43:55,680
hardware according to the arm

1210
00:43:55,680 --> 00:43:57,680
specification nothing too interesting

1211
00:43:57,680 --> 00:43:58,560
there

1212
00:43:58,560 --> 00:44:00,079
and the end result of that is that i

1213
00:44:00,079 --> 00:44:02,960
could finally connect to my iphone over

1214
00:44:02,960 --> 00:44:05,680
a regular usb cable and debug it in

1215
00:44:05,680 --> 00:44:07,920
kernel with lldb and ida pro and so you

1216
00:44:07,920 --> 00:44:09,359
get this kind of you know debug

1217
00:44:09,359 --> 00:44:11,760
interface and item which is pretty cool

1218
00:44:11,760 --> 00:44:13,839
um yeah

1219
00:44:13,839 --> 00:44:16,319
so let's look at a actual practical

1220
00:44:16,319 --> 00:44:19,760
example of how this works in practice

1221
00:44:19,760 --> 00:44:21,040
so the actual demo i'm going to be

1222
00:44:21,040 --> 00:44:23,440
giving is uh the out of bounds timestamp

1223
00:44:23,440 --> 00:44:26,960
is a kernel bug that i found a while ago

1224
00:44:26,960 --> 00:44:28,880
and wrote an exploit form

1225
00:44:28,880 --> 00:44:31,920
and it affects ios 13.3 and so i'll

1226
00:44:31,920 --> 00:44:35,520
demonstrate how i used ktrw to find this

1227
00:44:35,520 --> 00:44:39,040
vulnerability uh in the first place

1228
00:44:39,040 --> 00:44:40,400
so

1229
00:44:40,400 --> 00:44:41,359
um

1230
00:44:41,359 --> 00:44:42,720
this way i found it was actually

1231
00:44:42,720 --> 00:44:45,920
somewhat roundabout can you read this

1232
00:44:45,920 --> 00:44:47,920
yeah okay cool

1233
00:44:47,920 --> 00:44:50,640
so um there's this function we're in the

1234
00:44:50,640 --> 00:44:54,280
xnu source code in the iokit kernel i o

1235
00:44:54,280 --> 00:44:56,800
memorydescriptor.cpp file i was looking

1236
00:44:56,800 --> 00:44:59,680
for virtual memory bugs and

1237
00:44:59,680 --> 00:45:01,760
i found that there's this piece of code

1238
00:45:01,760 --> 00:45:03,520
in the function io general memory

1239
00:45:03,520 --> 00:45:06,319
descriptor memory reference create and i

1240
00:45:06,319 --> 00:45:08,560
thought oh this this particular piece of

1241
00:45:08,560 --> 00:45:10,960
code looks interesting i wonder if uh

1242
00:45:10,960 --> 00:45:13,760
this code ever has a particular value

1243
00:45:13,760 --> 00:45:14,480
for

1244
00:45:14,480 --> 00:45:16,160
the

1245
00:45:16,160 --> 00:45:18,400
page protections that it's going to pass

1246
00:45:18,400 --> 00:45:20,960
to a later function uh so in particular

1247
00:45:20,960 --> 00:45:22,880
i wanted to know you know at this point

1248
00:45:22,880 --> 00:45:24,720
at the end of this if block

1249
00:45:24,720 --> 00:45:28,400
what is the value of prot right here

1250
00:45:28,400 --> 00:45:30,480
and so uh the way i did this was i said

1251
00:45:30,480 --> 00:45:32,720
okay well i put all this effort into

1252
00:45:32,720 --> 00:45:35,359
building a kernel debugger might as well

1253
00:45:35,359 --> 00:45:37,280
use it to find out you know dynamically

1254
00:45:37,280 --> 00:45:39,680
does this situation ever occur or prop

1255
00:45:39,680 --> 00:45:42,720
has one of these flags like uh map mem

1256
00:45:42,720 --> 00:45:45,200
ledger tag network or map membranes

1257
00:45:45,200 --> 00:45:48,160
included uh do these flags ever end up

1258
00:45:48,160 --> 00:45:49,440
in prod

1259
00:45:49,440 --> 00:45:51,760
um so in order to do that i pulled up

1260
00:45:51,760 --> 00:45:54,319
ida and i located the specific

1261
00:45:54,319 --> 00:45:57,119
instruction that i said you know prop is

1262
00:45:57,119 --> 00:45:58,640
going to be in this variable at this

1263
00:45:58,640 --> 00:46:01,040
particular point um so in the

1264
00:46:01,040 --> 00:46:03,680
decompilation you can see the same code

1265
00:46:03,680 --> 00:46:05,200
as before but

1266
00:46:05,200 --> 00:46:06,880
just decompiles it's still readable to

1267
00:46:06,880 --> 00:46:07,839
people

1268
00:46:07,839 --> 00:46:09,920
yeah okay cool

1269
00:46:09,920 --> 00:46:11,359
so um here you can see again like the

1270
00:46:11,359 --> 00:46:13,520
perchable

1271
00:46:13,520 --> 00:46:16,400
perishable kernel only uh tag network

1272
00:46:16,400 --> 00:46:17,760
skywalk

1273
00:46:17,760 --> 00:46:19,599
um so all the same flags from the source

1274
00:46:19,599 --> 00:46:21,680
but just decompiled in ida because i

1275
00:46:21,680 --> 00:46:23,359
wanted the address of the specific

1276
00:46:23,359 --> 00:46:26,319
instruction uh which i would be using to

1277
00:46:26,319 --> 00:46:28,400
set a breakpoint

1278
00:46:28,400 --> 00:46:31,520
so i will switch over to lldb let's make

1279
00:46:31,520 --> 00:46:34,319
this a little bit bigger

1280
00:46:36,960 --> 00:46:37,920
okay

1281
00:46:37,920 --> 00:46:40,720
so uh here we have a

1282
00:46:40,720 --> 00:46:42,640
session connected to

1283
00:46:42,640 --> 00:46:45,119
this phone i don't have a screen capture

1284
00:46:45,119 --> 00:46:46,800
like samuel did for this phone because

1285
00:46:46,800 --> 00:46:49,040
once the debugger starts running it's

1286
00:46:49,040 --> 00:46:51,359
going to take over the usb hardware

1287
00:46:51,359 --> 00:46:53,040
controller and therefore you can't get

1288
00:46:53,040 --> 00:46:55,040
any data off of the phone onto the

1289
00:46:55,040 --> 00:46:56,880
laptop except if i have my special

1290
00:46:56,880 --> 00:46:59,280
kernel extension and so

1291
00:46:59,280 --> 00:47:01,599
the demo will literally be you know i

1292
00:47:01,599 --> 00:47:03,119
start an app and it disappears so not

1293
00:47:03,119 --> 00:47:05,119
super interesting uh instead i'll try to

1294
00:47:05,119 --> 00:47:06,720
hold up the phone and demonstrate uh

1295
00:47:06,720 --> 00:47:08,240
kind of visually so i apologize if

1296
00:47:08,240 --> 00:47:10,400
that's somewhat less exciting so the

1297
00:47:10,400 --> 00:47:12,319
first step is we're going to launch an

1298
00:47:12,319 --> 00:47:14,880
app which does a kernel exploit which

1299
00:47:14,880 --> 00:47:17,760
should uh give us the ability to uh

1300
00:47:17,760 --> 00:47:19,760
modify kernel memory and call kernel

1301
00:47:19,760 --> 00:47:21,359
functions

1302
00:47:21,359 --> 00:47:24,319
then i'm going to launch the uh kernel

1303
00:47:24,319 --> 00:47:26,640
extension loader application

1304
00:47:26,640 --> 00:47:28,640
uh and that should launch and then we

1305
00:47:28,640 --> 00:47:30,880
should see some output from our

1306
00:47:30,880 --> 00:47:32,480
proxy program so we can see that we

1307
00:47:32,480 --> 00:47:34,960
found a ktrw device and opened the ktrw

1308
00:47:34,960 --> 00:47:36,240
device

1309
00:47:36,240 --> 00:47:39,040
and so now we can connect to it via lldb

1310
00:47:39,040 --> 00:47:42,079
so gdb remote

1311
00:47:42,079 --> 00:47:44,880
all right we have that so we'll continue

1312
00:47:44,880 --> 00:47:46,960
uh so the phone is now running as it

1313
00:47:46,960 --> 00:47:48,400
normally does

1314
00:47:48,400 --> 00:47:50,000
i'm going to actually reconnect so that

1315
00:47:50,000 --> 00:47:52,800
it detects the kernel location

1316
00:47:52,800 --> 00:47:54,160
so we will

1317
00:47:54,160 --> 00:47:56,079
halt and disconnect

1318
00:47:56,079 --> 00:47:58,400
and then

1319
00:47:58,559 --> 00:48:01,359
add dsim

1320
00:48:01,800 --> 00:48:05,960
kc.symbols and

1321
00:48:12,960 --> 00:48:14,960
all right that's much better so now we

1322
00:48:14,960 --> 00:48:17,359
are connected to this phone you can see

1323
00:48:17,359 --> 00:48:19,440
that llcb automatically detected the

1324
00:48:19,440 --> 00:48:22,000
load address of the kernel and the

1325
00:48:22,000 --> 00:48:24,160
kernel uuid and all of that

1326
00:48:24,160 --> 00:48:26,240
and you can see now that we're halted if

1327
00:48:26,240 --> 00:48:27,920
i try to interact with the device it

1328
00:48:27,920 --> 00:48:29,440
doesn't actually move

1329
00:48:29,440 --> 00:48:31,680
you can't do anything like that because

1330
00:48:31,680 --> 00:48:33,599
it's actually halted

1331
00:48:33,599 --> 00:48:36,000
so now we're going to

1332
00:48:36,000 --> 00:48:39,359
i'm going to get the kernel slide

1333
00:48:43,440 --> 00:48:45,359
all right so we have computed the kernel

1334
00:48:45,359 --> 00:48:47,599
slide and now we can compute the address

1335
00:48:47,599 --> 00:48:49,200
of this function

1336
00:48:49,200 --> 00:48:52,960
in kernel memory so take that

1337
00:48:55,119 --> 00:49:00,119
so if i disassemble around this

1338
00:49:03,359 --> 00:49:06,759
oh x4i

1339
00:49:07,040 --> 00:49:09,119
all right so we can see that uh this

1340
00:49:09,119 --> 00:49:13,280
instruction uh d40 lsr wa88 and that

1341
00:49:13,280 --> 00:49:14,319
since back to the exact same

1342
00:49:14,319 --> 00:49:16,240
instructions here so we do have the

1343
00:49:16,240 --> 00:49:17,680
address of this instruction and we can

1344
00:49:17,680 --> 00:49:20,240
now set a breakdown

1345
00:49:20,240 --> 00:49:21,760
and now just to make this process

1346
00:49:21,760 --> 00:49:23,280
somewhat more

1347
00:49:23,280 --> 00:49:25,119
speedy i'm going to also make this a

1348
00:49:25,119 --> 00:49:27,599
conditional breakpoint so that we only

1349
00:49:27,599 --> 00:49:29,119
get the specific back trace that we're

1350
00:49:29,119 --> 00:49:30,400
looking for

1351
00:49:30,400 --> 00:49:32,160
so i've set a breakpoint on this

1352
00:49:32,160 --> 00:49:34,559
instruction and i'm going to continue

1353
00:49:34,559 --> 00:49:36,160
and uh the breakpoint pretty much

1354
00:49:36,160 --> 00:49:38,160
immediately gets hit

1355
00:49:38,160 --> 00:49:41,680
and now we can examine

1356
00:49:42,240 --> 00:49:45,839
w9 to get the value of the flags i saw

1357
00:49:45,839 --> 00:49:47,200
oh this doesn't look like the flag

1358
00:49:47,200 --> 00:49:48,800
values i was expecting

1359
00:49:48,800 --> 00:49:50,240
um but

1360
00:49:50,240 --> 00:49:52,079
uh what i noticed when i did a back

1361
00:49:52,079 --> 00:49:54,000
trace was that the back trace actually

1362
00:49:54,000 --> 00:49:56,319
looked somewhat interesting so i didn't

1363
00:49:56,319 --> 00:49:58,160
actually end up triggering the behavior

1364
00:49:58,160 --> 00:50:00,640
that i wanted but in the back race i saw

1365
00:50:00,640 --> 00:50:02,079
kind of some interesting stuff that i

1366
00:50:02,079 --> 00:50:03,359
hadn't observed before it's like hey

1367
00:50:03,359 --> 00:50:05,040
let's explore around a little bit see

1368
00:50:05,040 --> 00:50:06,960
what's going on here

1369
00:50:06,960 --> 00:50:09,119
so in the backtrace you can see i o user

1370
00:50:09,119 --> 00:50:11,359
client external method so this is an

1371
00:50:11,359 --> 00:50:13,200
external method call

1372
00:50:13,200 --> 00:50:14,160
to

1373
00:50:14,160 --> 00:50:16,960
some sort of kernel driver in particular

1374
00:50:16,960 --> 00:50:19,440
you can see io excel command-q submit

1375
00:50:19,440 --> 00:50:22,640
command buffers so this is in the apple

1376
00:50:22,640 --> 00:50:24,480
graphics accelerator

1377
00:50:24,480 --> 00:50:26,480
drivers there's something called uh

1378
00:50:26,480 --> 00:50:28,480
command buffer which gets submitted to

1379
00:50:28,480 --> 00:50:30,400
the graphics hardware and kind of you

1380
00:50:30,400 --> 00:50:32,319
know working through the back trace i

1381
00:50:32,319 --> 00:50:33,839
saw okay here's where we hit i o general

1382
00:50:33,839 --> 00:50:35,680
memory descriptor let's get to the first

1383
00:50:35,680 --> 00:50:39,359
point that we call out from uh the

1384
00:50:39,359 --> 00:50:41,599
apple graphics to i o buffer memory

1385
00:50:41,599 --> 00:50:43,440
descriptor is right here

1386
00:50:43,440 --> 00:50:47,119
and let's go to that uh in ida

1387
00:50:47,119 --> 00:50:49,119
so we're going to print

1388
00:50:49,119 --> 00:50:51,440
oops

1389
00:50:51,680 --> 00:50:54,079
so we have the unslid address of that

1390
00:50:54,079 --> 00:50:57,119
instruction and go there

1391
00:50:57,119 --> 00:50:58,720
all right so

1392
00:50:58,720 --> 00:51:01,280
you can see that we have just after the

1393
00:51:01,280 --> 00:51:02,800
called i o buffered memory descriptor

1394
00:51:02,800 --> 00:51:04,559
with options and item

1395
00:51:04,559 --> 00:51:07,119
and this is inside of a function agx

1396
00:51:07,119 --> 00:51:08,880
parameter management physical freight

1397
00:51:08,880 --> 00:51:10,720
parameter buffer block so you know every

1398
00:51:10,720 --> 00:51:12,800
time i kind of see a new piece of code i

1399
00:51:12,800 --> 00:51:14,319
like to explore a little bit see what's

1400
00:51:14,319 --> 00:51:16,559
going on around here and it actually

1401
00:51:16,559 --> 00:51:17,839
really quickly caught my eye that you

1402
00:51:17,839 --> 00:51:20,160
know something looks kind of funky

1403
00:51:20,160 --> 00:51:24,800
so we have this uh array which we are uh

1404
00:51:24,800 --> 00:51:26,960
storing this new uh so we're going to

1405
00:51:26,960 --> 00:51:28,880
return uh from io buffer memory

1406
00:51:28,880 --> 00:51:30,800
descriptor we return a

1407
00:51:30,800 --> 00:51:32,480
buffered memory descriptor

1408
00:51:32,480 --> 00:51:34,960
we set that parameter here and if that

1409
00:51:34,960 --> 00:51:37,200
object was successfully allocated we're

1410
00:51:37,200 --> 00:51:40,880
going to store this uh param block fizz

1411
00:51:40,880 --> 00:51:44,000
object inside of this array

1412
00:51:44,000 --> 00:51:46,000
in the agx parameter and between

1413
00:51:46,000 --> 00:51:47,440
physical class

1414
00:51:47,440 --> 00:51:49,839
so this looks kind of sketchy to me

1415
00:51:49,839 --> 00:51:52,400
because this buff md count variable

1416
00:51:52,400 --> 00:51:54,079
which is used as the index

1417
00:51:54,079 --> 00:51:56,160
is you know it's storing sequentially an

1418
00:51:56,160 --> 00:51:58,000
item after an item and updating the

1419
00:51:58,000 --> 00:52:00,079
index each time but there isn't actually

1420
00:52:00,079 --> 00:52:02,240
a check on this index anywhere within

1421
00:52:02,240 --> 00:52:03,839
this function like this is the only

1422
00:52:03,839 --> 00:52:06,559
place that buffermd count is referenced

1423
00:52:06,559 --> 00:52:08,079
if that seemed kind of suspicious to me

1424
00:52:08,079 --> 00:52:09,280
you know like maybe if you get this

1425
00:52:09,280 --> 00:52:11,359
function be called enough times um you

1426
00:52:11,359 --> 00:52:13,359
can overflow this array and write things

1427
00:52:13,359 --> 00:52:15,040
out of bounds in the array

1428
00:52:15,040 --> 00:52:17,520
cool let's see if that actually happens

1429
00:52:17,520 --> 00:52:19,599
so i then kind of worked up the call

1430
00:52:19,599 --> 00:52:23,200
stack uh the next one was here

1431
00:52:23,200 --> 00:52:25,119
which is

1432
00:52:25,119 --> 00:52:29,359
uh unsplit address ending in e58 so i

1433
00:52:29,359 --> 00:52:32,079
went to that address

1434
00:52:32,079 --> 00:52:34,160
and saw okay so here we have the call to

1435
00:52:34,160 --> 00:52:35,760
create parameter buffer block as we

1436
00:52:35,760 --> 00:52:38,319
expect um still no checks on the

1437
00:52:38,319 --> 00:52:40,480
buffermd count variable

1438
00:52:40,480 --> 00:52:42,880
um you looked through all this and kind

1439
00:52:42,880 --> 00:52:44,400
of saw like okay yeah it looks like it's

1440
00:52:44,400 --> 00:52:46,640
usually taking these paths to function

1441
00:52:46,640 --> 00:52:48,800
based on the state of the variables halt

1442
00:52:48,800 --> 00:52:50,880
within the debugger

1443
00:52:50,880 --> 00:52:52,800
um but you know still didn't really look

1444
00:52:52,800 --> 00:52:53,760
like

1445
00:52:53,760 --> 00:52:55,760
there was any checks going on so then i

1446
00:52:55,760 --> 00:52:58,000
went up one more layer to the function i

1447
00:52:58,000 --> 00:52:59,520
called that

1448
00:52:59,520 --> 00:53:00,720
oh man it takes a while to leave the

1449
00:53:00,720 --> 00:53:01,839
pile

1450
00:53:01,839 --> 00:53:04,240
um and saw okay

1451
00:53:04,240 --> 00:53:06,559
here we are ah okay so here we have the

1452
00:53:06,559 --> 00:53:08,400
code which sets the next index and it

1453
00:53:08,400 --> 00:53:10,079
does actually look like it does some

1454
00:53:10,079 --> 00:53:11,520
math to make sure that it's wrapping

1455
00:53:11,520 --> 00:53:13,839
around in the array properly so this

1456
00:53:13,839 --> 00:53:16,079
doesn't actually look like a bug

1457
00:53:16,079 --> 00:53:18,559
so didn't end up finding anything here

1458
00:53:18,559 --> 00:53:20,319
but you know i found this really new

1459
00:53:20,319 --> 00:53:22,559
function it's you know huge a thousand

1460
00:53:22,559 --> 00:53:24,079
lines for a single function ida

1461
00:53:24,079 --> 00:53:26,160
decompilation so might as well take some

1462
00:53:26,160 --> 00:53:29,200
time and explore look what's going on

1463
00:53:29,200 --> 00:53:31,200
um so to do that you go to the top

1464
00:53:31,200 --> 00:53:33,200
function uh set the types of all the

1465
00:53:33,200 --> 00:53:34,800
parameters correctly

1466
00:53:34,800 --> 00:53:36,400
and just see you know how does how does

1467
00:53:36,400 --> 00:53:38,960
control flow through this function

1468
00:53:38,960 --> 00:53:40,960
and uh kind of the first thing that you

1469
00:53:40,960 --> 00:53:43,520
see at the very top of this function

1470
00:53:43,520 --> 00:53:46,559
is uh you know so this uh one of the

1471
00:53:46,559 --> 00:53:48,079
parameters this function is this thing

1472
00:53:48,079 --> 00:53:50,160
that i've called shared kernel command

1473
00:53:50,160 --> 00:53:52,319
uh this is a pointer to memory which is

1474
00:53:52,319 --> 00:53:53,920
shared between user space and the kernel

1475
00:53:53,920 --> 00:53:56,400
so it can be modified at any point

1476
00:53:56,400 --> 00:53:57,680
and you notice that okay if we have

1477
00:53:57,680 --> 00:54:01,839
command type of 1001 then you know we

1478
00:54:01,839 --> 00:54:04,079
return immediately if the command type

1479
00:54:04,079 --> 00:54:06,800
does not equal 1000 then we do process

1480
00:54:06,800 --> 00:54:08,079
segment kernel command different

1481
00:54:08,079 --> 00:54:09,119
function

1482
00:54:09,119 --> 00:54:11,040
and then the whole rest of this function

1483
00:54:11,040 --> 00:54:13,440
all you know thousand plus lines are

1484
00:54:13,440 --> 00:54:17,119
just handling command type uh one ten

1485
00:54:17,119 --> 00:54:19,680
thousand so this looks kind of wild that

1486
00:54:19,680 --> 00:54:21,359
you know there's this many processing

1487
00:54:21,359 --> 00:54:23,040
steps going on so let's see what the

1488
00:54:23,040 --> 00:54:24,720
other processing steps might look like

1489
00:54:24,720 --> 00:54:26,880
you know maybe there are 10 000 other

1490
00:54:26,880 --> 00:54:28,480
thousand line functions which are worth

1491
00:54:28,480 --> 00:54:30,880
looking into for bugs

1492
00:54:30,880 --> 00:54:32,400
and here's where i actually found you

1493
00:54:32,400 --> 00:54:35,119
know this looks extremely problematic uh

1494
00:54:35,119 --> 00:54:37,119
so this is again a shared memory kernel

1495
00:54:37,119 --> 00:54:39,839
command uh and it's doing a check you

1496
00:54:39,839 --> 00:54:41,920
know kernel commands commands type does

1497
00:54:41,920 --> 00:54:43,440
not equal two that is going to do

1498
00:54:43,440 --> 00:54:45,680
handling for commands type of different

1499
00:54:45,680 --> 00:54:47,839
than two and then uh so we're looking

1500
00:54:47,839 --> 00:54:48,640
for

1501
00:54:48,640 --> 00:54:50,319
uh commands type two in particular we'll

1502
00:54:50,319 --> 00:54:52,000
go down to the end of this if statement

1503
00:54:52,000 --> 00:54:54,880
to see the processing for that

1504
00:54:54,880 --> 00:54:57,760
all right so uh here we're processing

1505
00:54:57,760 --> 00:55:00,400
this command from shared memory and says

1506
00:55:00,400 --> 00:55:03,920
okay so for command type 2 which is a

1507
00:55:03,920 --> 00:55:06,000
kio excel kernel command collects

1508
00:55:06,000 --> 00:55:07,599
timestamp

1509
00:55:07,599 --> 00:55:10,480
we expect the command size to be at

1510
00:55:10,480 --> 00:55:12,000
least eight bytes because if it's less

1511
00:55:12,000 --> 00:55:14,000
than or equal to seven bytes we bail out

1512
00:55:14,000 --> 00:55:15,520
with an error message

1513
00:55:15,520 --> 00:55:17,520
all right sounds fair enough what does

1514
00:55:17,520 --> 00:55:19,040
the rest of the thing do if it is at

1515
00:55:19,040 --> 00:55:21,040
least eight bytes well if it is eight

1516
00:55:21,040 --> 00:55:24,240
bytes we're going to uh find

1517
00:55:24,240 --> 00:55:25,680
offset eight

1518
00:55:25,680 --> 00:55:28,079
oops sorry uh we're going to find offset

1519
00:55:28,079 --> 00:55:30,400
eight in the kernel command and we're

1520
00:55:30,400 --> 00:55:33,440
going to write a 64-bit uh output of

1521
00:55:33,440 --> 00:55:37,599
mock absolute time to offset eight

1522
00:55:38,000 --> 00:55:39,520
seems fine right

1523
00:55:39,520 --> 00:55:41,680
if we have eight bytes then right

1524
00:55:41,680 --> 00:55:44,559
starting from offset eight to offset 15.

1525
00:55:44,559 --> 00:55:47,599
totally totally valid

1526
00:55:47,760 --> 00:55:48,799
now so this is actually totally

1527
00:55:48,799 --> 00:55:52,480
problematic um so kernel commands is uh

1528
00:55:52,480 --> 00:55:54,880
imagine that this is the last eight

1529
00:55:54,880 --> 00:55:57,440
bytes on a page of memory

1530
00:55:57,440 --> 00:55:59,839
then writing at offset eight will write

1531
00:55:59,839 --> 00:56:01,680
the first bytes of the subsequent page

1532
00:56:01,680 --> 00:56:02,799
of memory

1533
00:56:02,799 --> 00:56:05,200
so this is actually just looking at just

1534
00:56:05,200 --> 00:56:07,200
these couple lines of code

1535
00:56:07,200 --> 00:56:09,760
very clearly an out of bounds right

1536
00:56:09,760 --> 00:56:10,640
bug

1537
00:56:10,640 --> 00:56:11,760
and

1538
00:56:11,760 --> 00:56:14,799
absolutely you know totally exploitable

1539
00:56:14,799 --> 00:56:17,040
so um yeah not really what i was

1540
00:56:17,040 --> 00:56:18,720
expecting to find when i looked into

1541
00:56:18,720 --> 00:56:21,280
trying to find virtual memory bugs but

1542
00:56:21,280 --> 00:56:22,880
um you know just taking some time to

1543
00:56:22,880 --> 00:56:25,040
explore around you know dynamic analysis

1544
00:56:25,040 --> 00:56:26,880
can give you really really deep call

1545
00:56:26,880 --> 00:56:28,480
stacks um

1546
00:56:28,480 --> 00:56:30,559
you know i would never have been able to

1547
00:56:30,559 --> 00:56:32,319
reverse engineer through this entire

1548
00:56:32,319 --> 00:56:34,640
call stack to get to that point um just

1549
00:56:34,640 --> 00:56:37,200
by myself because it's a pain it's a

1550
00:56:37,200 --> 00:56:39,040
huge amount of code to reverse engineer

1551
00:56:39,040 --> 00:56:40,720
and the dynamic analysis can really help

1552
00:56:40,720 --> 00:56:42,559
you jump right to the interesting points

1553
00:56:42,559 --> 00:56:44,000
you know i know this code is reachable

1554
00:56:44,000 --> 00:56:45,760
because i have a

1555
00:56:45,760 --> 00:56:47,280
live system which is stopped at this

1556
00:56:47,280 --> 00:56:48,640
point in the code

1557
00:56:48,640 --> 00:56:50,799
so yeah it opens up a lot of new attack

1558
00:56:50,799 --> 00:56:52,640
surface that otherwise might not be uh

1559
00:56:52,640 --> 00:56:54,559
reachable

1560
00:56:54,559 --> 00:56:56,480
uh yeah so that's that's kind of my demo

1561
00:56:56,480 --> 00:56:59,599
for how i used ktrw to find the out of

1562
00:56:59,599 --> 00:57:02,720
bounds timestamp bug

1563
00:57:04,480 --> 00:57:06,000
cool

1564
00:57:06,000 --> 00:57:08,799
yeah thank you very much i

1565
00:57:08,799 --> 00:57:11,359
have the project on github it's called

1566
00:57:11,359 --> 00:57:12,400
ktrw

1567
00:57:12,400 --> 00:57:14,960
i also have a blog post that documents

1568
00:57:14,960 --> 00:57:16,240
you know the process that i went through

1569
00:57:16,240 --> 00:57:17,520
to find this bug

1570
00:57:17,520 --> 00:57:20,799
um i will say that you know it's kind of

1571
00:57:20,799 --> 00:57:22,799
not super relevant maybe to a lot of you

1572
00:57:22,799 --> 00:57:26,079
in a mac os security conference um the

1573
00:57:26,079 --> 00:57:28,160
only tie-in that i can really offer is

1574
00:57:28,160 --> 00:57:31,119
you know right now max are running intel

1575
00:57:31,119 --> 00:57:32,880
potentially that may not be the case in

1576
00:57:32,880 --> 00:57:34,559
a couple of years and hopefully it won't

1577
00:57:34,559 --> 00:57:36,640
be this difficult to get early bugging

1578
00:57:36,640 --> 00:57:38,319
on your max in the future

1579
00:57:38,319 --> 00:57:40,559
so i'll leave you with that

1580
00:57:40,559 --> 00:57:44,040
thank you very much

1581
00:57:58,640 --> 00:58:00,720
you

