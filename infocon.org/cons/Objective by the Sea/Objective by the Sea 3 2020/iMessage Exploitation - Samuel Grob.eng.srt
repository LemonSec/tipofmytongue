1
00:00:06,319 --> 00:00:08,400
all right next up we have daniel he is

2
00:00:08,400 --> 00:00:11,280
going to be giving an incredible talk on

3
00:00:11,280 --> 00:00:13,519
imessage exploitation for a treating

4
00:00:13,519 --> 00:00:15,360
topic

5
00:00:15,360 --> 00:00:16,960
welcome a warm

6
00:00:16,960 --> 00:00:19,520
around applause all the way from

7
00:00:19,520 --> 00:00:22,240
switzerland

8
00:00:22,960 --> 00:00:24,720
okay i'm ready cool

9
00:00:24,720 --> 00:00:27,359
um yeah thanks everyone for coming um

10
00:00:27,359 --> 00:00:28,880
having a great time hope you're also

11
00:00:28,880 --> 00:00:31,519
enjoying the conference as much as i am

12
00:00:31,519 --> 00:00:33,200
um yeah i'm going to be talking about

13
00:00:33,200 --> 00:00:35,440
imessage exploitation

14
00:00:35,440 --> 00:00:37,920
um so i guess most of you are

15
00:00:37,920 --> 00:00:39,600
more or less familiar with imessage it

16
00:00:39,600 --> 00:00:41,760
looks like this

17
00:00:41,760 --> 00:00:45,360
it's apple's messaging servers uh what

18
00:00:45,360 --> 00:00:48,000
so in terms of like what you need is uh

19
00:00:48,000 --> 00:00:49,680
just the phone number or the email

20
00:00:49,680 --> 00:00:51,600
address or the apple account

21
00:00:51,600 --> 00:00:54,640
to be able to send messages to someone

22
00:00:54,640 --> 00:00:57,120
um from a security point of view it's

23
00:00:57,120 --> 00:00:58,879
pretty interesting because it's default

24
00:00:58,879 --> 00:01:00,079
enabled

25
00:01:00,079 --> 00:01:03,120
so like any any iphone that's uh

26
00:01:03,120 --> 00:01:04,959
that's registered with an apple account

27
00:01:04,959 --> 00:01:07,200
can be re can be like reached over

28
00:01:07,200 --> 00:01:09,200
imessage it has something listening to

29
00:01:09,200 --> 00:01:12,159
incoming messages uh so this is like

30
00:01:12,159 --> 00:01:14,799
default no interaction attack surface

31
00:01:14,799 --> 00:01:17,600
which makes it super interesting um and

32
00:01:17,600 --> 00:01:20,320
so natalie and me set out to

33
00:01:20,320 --> 00:01:22,080
do some security um

34
00:01:22,080 --> 00:01:24,240
look for security vulnerabilities in it

35
00:01:24,240 --> 00:01:26,640
sometime last year and yeah i'm gonna

36
00:01:26,640 --> 00:01:29,200
talk about what we found

37
00:01:29,200 --> 00:01:30,799
so

38
00:01:30,799 --> 00:01:33,040
in terms of wire format like what

39
00:01:33,040 --> 00:01:34,799
actually gets sent

40
00:01:34,799 --> 00:01:36,799
uh over the network this is how it looks

41
00:01:36,799 --> 00:01:37,759
like

42
00:01:37,759 --> 00:01:39,439
um it's p lists

43
00:01:39,439 --> 00:01:41,360
uh like well this is the like textual

44
00:01:41,360 --> 00:01:43,119
representation but it's really binary p

45
00:01:43,119 --> 00:01:44,880
list that's being sent

46
00:01:44,880 --> 00:01:45,840
um

47
00:01:45,840 --> 00:01:48,399
i guess most of these keys are kind of

48
00:01:48,399 --> 00:01:51,920
mandatory like p is participants

49
00:01:51,920 --> 00:01:54,799
um t is the text content

50
00:01:54,799 --> 00:01:56,640
v is probably conversion

51
00:01:56,640 --> 00:01:58,640
um interestingly there's also some like

52
00:01:58,640 --> 00:02:00,240
xml in there

53
00:02:00,240 --> 00:02:01,280
which

54
00:02:01,280 --> 00:02:03,520
seems to be used like it's not html it

55
00:02:03,520 --> 00:02:06,640
looks like html um it's pretty complex

56
00:02:06,640 --> 00:02:08,720
and it had a couple of bugs in the past

57
00:02:08,720 --> 00:02:11,520
so e and b are found some for example

58
00:02:11,520 --> 00:02:12,560
um

59
00:02:12,560 --> 00:02:14,319
and so now what this means is that this

60
00:02:14,319 --> 00:02:16,800
entire serializer is now zero click

61
00:02:16,800 --> 00:02:18,239
attack surface

62
00:02:18,239 --> 00:02:20,080
because well it's it's included in the p

63
00:02:20,080 --> 00:02:22,400
list and you can send these imessages

64
00:02:22,400 --> 00:02:25,200
to any any phone with an apple account

65
00:02:25,200 --> 00:02:28,080
and it will deserialize these archives

66
00:02:28,080 --> 00:02:28,879
so

67
00:02:28,879 --> 00:02:30,480
when we found that

68
00:02:30,480 --> 00:02:32,480
this looked like the

69
00:02:32,480 --> 00:02:34,480
the biggest attack surface immediately

70
00:02:34,480 --> 00:02:36,800
so we spent pretty much all of our time

71
00:02:36,800 --> 00:02:38,319
looking at this

72
00:02:38,319 --> 00:02:38,600
um

73
00:02:38,600 --> 00:02:40,000
[Music]

74
00:02:40,000 --> 00:02:41,760
yeah again it's a bit more about the

75
00:02:41,760 --> 00:02:44,480
serializer so it does support quite a

76
00:02:44,480 --> 00:02:48,239
lot of things like all the common uh

77
00:02:48,239 --> 00:02:51,360
like uh dictionary area container things

78
00:02:51,360 --> 00:02:53,519
uh it supports some weirdest things like

79
00:02:53,519 --> 00:02:56,640
areas of c-strings also i don't know why

80
00:02:56,640 --> 00:02:57,840
um

81
00:02:57,840 --> 00:03:00,319
it even supports like cyclic references

82
00:03:00,319 --> 00:03:03,760
and we'll get to that in a minute um

83
00:03:03,760 --> 00:03:05,519
and i i would recommend reading

84
00:03:05,519 --> 00:03:07,440
natalie's blog post it's really good on

85
00:03:07,440 --> 00:03:10,080
like this kind of attack surface

86
00:03:10,080 --> 00:03:11,840
and on the bottom here you have some

87
00:03:11,840 --> 00:03:13,840
example code of

88
00:03:13,840 --> 00:03:16,959
how this archiver works from the api

89
00:03:16,959 --> 00:03:18,560
um so

90
00:03:18,560 --> 00:03:21,040
yeah you can restrict like what it will

91
00:03:21,040 --> 00:03:23,200
unarchive so in this case i'm set apart

92
00:03:23,200 --> 00:03:24,959
this is saying like

93
00:03:24,959 --> 00:03:26,799
only allow um

94
00:03:26,799 --> 00:03:28,959
dictionary string state

95
00:03:28,959 --> 00:03:31,440
number and so on um

96
00:03:31,440 --> 00:03:33,599
but it's more complex because actually

97
00:03:33,599 --> 00:03:36,799
it allows sub classes also so this looks

98
00:03:36,799 --> 00:03:38,080
like it would only allow ana's

99
00:03:38,080 --> 00:03:40,319
dictionary but really it also allows

100
00:03:40,319 --> 00:03:41,680
like ns

101
00:03:41,680 --> 00:03:43,280
something something dictionary because

102
00:03:43,280 --> 00:03:46,480
it inherits so like it respects

103
00:03:46,480 --> 00:03:48,640
inheritance hierarchies so the attacks

104
00:03:48,640 --> 00:03:51,040
are much much bigger than

105
00:03:51,040 --> 00:03:53,599
what this would suggest

106
00:03:53,599 --> 00:03:55,120
um

107
00:03:55,120 --> 00:03:57,040
yeah so this is the box we found pretty

108
00:03:57,040 --> 00:03:58,959
much from the left is i don't know 10 or

109
00:03:58,959 --> 00:04:02,879
so um i think they were all

110
00:04:02,879 --> 00:04:04,720
maybe apart from like one or two they

111
00:04:04,720 --> 00:04:07,280
were more than this ns an archival thing

112
00:04:07,280 --> 00:04:09,200
um

113
00:04:09,200 --> 00:04:12,159
the particular bug that i then exploited

114
00:04:12,159 --> 00:04:15,439
is 1917 um just because it looked the

115
00:04:15,439 --> 00:04:16,238
most

116
00:04:16,238 --> 00:04:17,040
the

117
00:04:17,040 --> 00:04:19,440
nicest to exploit i guess

118
00:04:19,440 --> 00:04:21,600
um but i'm fairly certain some of the

119
00:04:21,600 --> 00:04:23,120
others could have been exploited in a

120
00:04:23,120 --> 00:04:24,400
similar way

121
00:04:24,400 --> 00:04:25,280
um

122
00:04:25,280 --> 00:04:28,960
yeah timelines like reported july 29th

123
00:04:28,960 --> 00:04:30,560
the first thing apple did which was

124
00:04:30,560 --> 00:04:32,800
really good um is

125
00:04:32,800 --> 00:04:34,960
with ios 1241

126
00:04:34,960 --> 00:04:37,120
they pushed the mitigation that

127
00:04:37,120 --> 00:04:38,080
kind of

128
00:04:38,080 --> 00:04:40,080
blocks a very large part of this attack

129
00:04:40,080 --> 00:04:41,919
surface in imessage so that there was

130
00:04:41,919 --> 00:04:45,600
really a good move um and this

131
00:04:45,600 --> 00:04:48,639
like this change would have

132
00:04:48,639 --> 00:04:51,440
like made all of our reports non

133
00:04:51,440 --> 00:04:53,360
non-remote issues

134
00:04:53,360 --> 00:04:56,880
um so this was a pretty good thing too

135
00:04:56,880 --> 00:04:58,960
um and then so after that point all of

136
00:04:58,960 --> 00:05:01,120
these parts of this part was only local

137
00:05:01,120 --> 00:05:03,120
attack surface because this

138
00:05:03,120 --> 00:05:05,680
like an archival thing is also used

139
00:05:05,680 --> 00:05:07,360
locally over xbc

140
00:05:07,360 --> 00:05:09,440
um and then it was fully fixed in ios

141
00:05:09,440 --> 00:05:11,440
13.2

142
00:05:11,440 --> 00:05:13,199
right so let's take a look at the bug um

143
00:05:13,199 --> 00:05:15,039
it's kind of interesting it's like a

144
00:05:15,039 --> 00:05:17,600
cool objective c bug

145
00:05:17,600 --> 00:05:19,840
objective c memory corruption bug

146
00:05:19,840 --> 00:05:21,280
uh what

147
00:05:21,280 --> 00:05:23,360
we have to know first is what a shared

148
00:05:23,360 --> 00:05:25,680
key dictionary is uh so it's a subclass

149
00:05:25,680 --> 00:05:27,680
of nsdictionary and that's why it can be

150
00:05:27,680 --> 00:05:29,520
decoded

151
00:05:29,520 --> 00:05:31,120
yeah it's a dictionary so what it's

152
00:05:31,120 --> 00:05:33,280
supposed to do is like map keys to

153
00:05:33,280 --> 00:05:34,400
values

154
00:05:34,400 --> 00:05:35,919
um

155
00:05:35,919 --> 00:05:37,120
so here's

156
00:05:37,120 --> 00:05:38,960
in reality this is objective c right but

157
00:05:38,960 --> 00:05:42,000
i've like made a pseudo code a python in

158
00:05:42,000 --> 00:05:43,520
pseudocode i guess

159
00:05:43,520 --> 00:05:45,919
um so the lookout for the sheet care

160
00:05:45,919 --> 00:05:49,360
dictionary uh it works basically by

161
00:05:49,360 --> 00:05:52,240
using a key set to get an index and then

162
00:05:52,240 --> 00:05:54,960
using that index to index into some area

163
00:05:54,960 --> 00:05:57,280
right so every sheet can share key

164
00:05:57,280 --> 00:06:00,319
dictionary has a values area and a key

165
00:06:00,319 --> 00:06:01,520
set

166
00:06:01,520 --> 00:06:03,520
now the key set is the more interesting

167
00:06:03,520 --> 00:06:05,039
thing

168
00:06:05,039 --> 00:06:07,440
so the lookup is kind of something like

169
00:06:07,440 --> 00:06:09,120
hash the key

170
00:06:09,120 --> 00:06:10,000
um

171
00:06:10,000 --> 00:06:12,639
take that hash and use it as index into

172
00:06:12,639 --> 00:06:15,840
some rank table thing

173
00:06:15,840 --> 00:06:18,080
and then whatever that gives you you set

174
00:06:18,080 --> 00:06:21,360
as an index into a keys array

175
00:06:21,360 --> 00:06:23,360
and then do a key comparison and if that

176
00:06:23,360 --> 00:06:25,440
matches then we have an index

177
00:06:25,440 --> 00:06:27,600
okay

178
00:06:28,000 --> 00:06:28,880
the

179
00:06:28,880 --> 00:06:31,520
the very important invariant here is

180
00:06:31,520 --> 00:06:32,560
that

181
00:06:32,560 --> 00:06:35,360
there's this num key value that says

182
00:06:35,360 --> 00:06:37,840
like how big is the keys area

183
00:06:37,840 --> 00:06:39,759
and this has to be consistent right so

184
00:06:39,759 --> 00:06:42,720
if num key is not not equal to the like

185
00:06:42,720 --> 00:06:44,240
actual length of the keys everything we

186
00:06:44,240 --> 00:06:45,440
have a problem

187
00:06:45,440 --> 00:06:47,360
because then like this

188
00:06:47,360 --> 00:06:49,039
this one line here will just exit out of

189
00:06:49,039 --> 00:06:50,880
box so keep in mind this is really

190
00:06:50,880 --> 00:06:52,639
important num key has to be equal to

191
00:06:52,639 --> 00:06:55,280
keys uh the length of the keys area

192
00:06:55,280 --> 00:06:56,240
um

193
00:06:56,240 --> 00:06:57,840
and then the other interesting thing is

194
00:06:57,840 --> 00:06:59,520
that these key sets actually form a

195
00:06:59,520 --> 00:07:00,720
linked list

196
00:07:00,720 --> 00:07:02,639
i don't really know why but

197
00:07:02,639 --> 00:07:04,479
it has support for like linking multiple

198
00:07:04,479 --> 00:07:06,400
shared key sets together and if the

199
00:07:06,400 --> 00:07:08,880
first key set doesn't have the right key

200
00:07:08,880 --> 00:07:10,880
it can go to the next one

201
00:07:10,880 --> 00:07:13,680
again try to find the key uh and it will

202
00:07:13,680 --> 00:07:15,599
keep doing that until the sub until

203
00:07:15,599 --> 00:07:18,080
there is no more key set in the list

204
00:07:18,080 --> 00:07:18,880
okay

205
00:07:18,880 --> 00:07:21,759
so this is roughly how these things work

206
00:07:21,759 --> 00:07:24,800
let's take a look at the vulnerability

207
00:07:24,800 --> 00:07:26,479
so this is the

208
00:07:26,479 --> 00:07:29,280
decoding code for a shared key set so

209
00:07:29,280 --> 00:07:30,479
this is like

210
00:07:30,479 --> 00:07:32,560
when when you're sending a serialized

211
00:07:32,560 --> 00:07:34,479
shared key set then this code will be

212
00:07:34,479 --> 00:07:36,560
run to de-serialize it

213
00:07:36,560 --> 00:07:38,639
and it looks pretty

214
00:07:38,639 --> 00:07:41,360
pretty decent like it's just taking out

215
00:07:41,360 --> 00:07:43,280
these uh these fields right let's take

216
00:07:43,280 --> 00:07:45,440
about num key it's extracting rank table

217
00:07:45,440 --> 00:07:46,400
and so on

218
00:07:46,400 --> 00:07:49,599
um and then in the first if uh it's it's

219
00:07:49,599 --> 00:07:51,120
checking this invariant right it's

220
00:07:51,120 --> 00:07:53,199
making sure that length the length of

221
00:07:53,199 --> 00:07:55,919
the keys area is equal to numkey uh and

222
00:07:55,919 --> 00:07:58,879
if not it's failing um

223
00:07:58,879 --> 00:07:59,919
and then

224
00:07:59,919 --> 00:08:01,680
the last thing it does it kind of does a

225
00:08:01,680 --> 00:08:03,360
sanity check where it's

226
00:08:03,360 --> 00:08:05,199
making sure that it can look up every

227
00:08:05,199 --> 00:08:07,280
key that it's supposed to contain

228
00:08:07,280 --> 00:08:09,199
right so this is just like yeah making

229
00:08:09,199 --> 00:08:11,520
sure it actually works

230
00:08:11,520 --> 00:08:13,759
so let's see how this is broken so i

231
00:08:13,759 --> 00:08:15,440
have this animation

232
00:08:15,440 --> 00:08:17,680
um we start from an empty shared key set

233
00:08:17,680 --> 00:08:19,599
which is like all zero this is how

234
00:08:19,599 --> 00:08:22,000
objective c allocates stuff it's like

235
00:08:22,000 --> 00:08:24,960
everything is nulled out

236
00:08:24,960 --> 00:08:27,120
and now we start filling it with like we

237
00:08:27,120 --> 00:08:29,280
control all these values um

238
00:08:29,280 --> 00:08:31,520
so we can fill it with whatever so we

239
00:08:31,520 --> 00:08:33,599
fill it with the really large num key

240
00:08:33,599 --> 00:08:34,559
value

241
00:08:34,559 --> 00:08:37,919
um a rank table of size one okay so you

242
00:08:37,919 --> 00:08:39,760
already see like this is this can't be

243
00:08:39,760 --> 00:08:40,559
right

244
00:08:40,559 --> 00:08:43,279
num key and rank table is is

245
00:08:43,279 --> 00:08:45,680
uh well not sorry i'm making things up a

246
00:08:45,680 --> 00:08:47,680
rank table is fine um

247
00:08:47,680 --> 00:08:49,839
keys is what has to be um

248
00:08:49,839 --> 00:08:52,080
what would have to be gigantic right

249
00:08:52,080 --> 00:08:54,399
but let's see what happens

250
00:08:54,399 --> 00:08:55,519
so

251
00:08:55,519 --> 00:08:57,680
next thing we do um

252
00:08:57,680 --> 00:08:59,600
is we we decode a

253
00:08:59,600 --> 00:09:02,320
sub key set right and at this point the

254
00:09:02,320 --> 00:09:04,720
whole process starts over again so again

255
00:09:04,720 --> 00:09:08,480
we like start from the top um we start

256
00:09:08,480 --> 00:09:11,440
decoding this second chair key set

257
00:09:11,440 --> 00:09:14,399
again do this this

258
00:09:14,399 --> 00:09:16,560
and now we make a circle

259
00:09:16,560 --> 00:09:19,519
right so here we say the sub key set of

260
00:09:19,519 --> 00:09:22,080
the second one is actually the first and

261
00:09:22,080 --> 00:09:24,320
now this isn't like supposed to to be

262
00:09:24,320 --> 00:09:26,080
that way um

263
00:09:26,080 --> 00:09:28,880
but it does work so the key archiver has

264
00:09:28,880 --> 00:09:31,920
like logic to handle this um

265
00:09:31,920 --> 00:09:34,800
and so yeah it just like works we have

266
00:09:34,800 --> 00:09:38,320
the cycle now we decode keys

267
00:09:38,320 --> 00:09:40,720
now this is fine right so the second key

268
00:09:40,720 --> 00:09:43,920
set looks kind of okay ish

269
00:09:43,920 --> 00:09:46,160
and now we get here and now we try to

270
00:09:46,160 --> 00:09:50,399
look up all these all these keys

271
00:09:50,399 --> 00:09:52,959
and so in this case the first key we can

272
00:09:52,959 --> 00:09:55,519
we like the lookup fails because like

273
00:09:55,519 --> 00:09:57,839
rank the rank table index is is too big

274
00:09:57,839 --> 00:10:01,279
it like doesn't work uh so it recurses

275
00:10:01,279 --> 00:10:03,200
and it actually goes to the first check

276
00:10:03,200 --> 00:10:06,720
set and tries to look up things there

277
00:10:06,720 --> 00:10:08,079
but at this point

278
00:10:08,079 --> 00:10:09,920
the first check he said isn't fully

279
00:10:09,920 --> 00:10:12,240
initialized like it hasn't reached

280
00:10:12,240 --> 00:10:14,640
the the sanity check it hasn't reached

281
00:10:14,640 --> 00:10:17,120
this first if statement

282
00:10:17,120 --> 00:10:19,200
and so the num key value is completely

283
00:10:19,200 --> 00:10:21,920
controlled uh it has it's not

284
00:10:21,920 --> 00:10:24,800
uh not safety checked um and so in this

285
00:10:24,800 --> 00:10:27,360
case it will actually just like index

286
00:10:27,360 --> 00:10:31,360
with hex 4141 4141 into this keys area

287
00:10:31,360 --> 00:10:33,120
that's not a pointer

288
00:10:33,120 --> 00:10:35,279
and so it will access like completely

289
00:10:35,279 --> 00:10:37,680
controlled memory uh and and do

290
00:10:37,680 --> 00:10:39,040
something with that

291
00:10:39,040 --> 00:10:40,320
and so this is

292
00:10:40,320 --> 00:10:42,959
exactly our vulnerability

293
00:10:42,959 --> 00:10:45,440
um so i have these checkpoints uh just

294
00:10:45,440 --> 00:10:48,160
to like get everyone back to where we

295
00:10:48,160 --> 00:10:49,440
are

296
00:10:49,440 --> 00:10:51,920
so next question is what kind of exploit

297
00:10:51,920 --> 00:10:54,720
primitives does this give us

298
00:10:54,720 --> 00:10:57,440
so again this is the lookup code that i

299
00:10:57,440 --> 00:11:00,720
have shown at the beginning

300
00:11:00,800 --> 00:11:03,360
when we trigger the spark keys the keys

301
00:11:03,360 --> 00:11:05,040
area is null pointer and index is

302
00:11:05,040 --> 00:11:06,160
controlled

303
00:11:06,160 --> 00:11:06,959
um

304
00:11:06,959 --> 00:11:08,720
and so what it's doing is it's well

305
00:11:08,720 --> 00:11:11,519
accessing like an arbitrary address okay

306
00:11:11,519 --> 00:11:13,839
but then it's also gonna treat that as

307
00:11:13,839 --> 00:11:16,720
an objective c object and call methods

308
00:11:16,720 --> 00:11:18,399
on it during the string comparison like

309
00:11:18,399 --> 00:11:20,320
it's gonna call his and a string for

310
00:11:20,320 --> 00:11:22,720
example it's also gonna call dialogue

311
00:11:22,720 --> 00:11:25,839
the destructor on it um and so the

312
00:11:25,839 --> 00:11:28,079
primitive reading we have is like we can

313
00:11:28,079 --> 00:11:30,560
take an arbitrary address and treat that

314
00:11:30,560 --> 00:11:32,399
as an objective c object

315
00:11:32,399 --> 00:11:35,200
and then get some message called on it

316
00:11:35,200 --> 00:11:36,959
right and so

317
00:11:36,959 --> 00:11:39,519
that's it um answer the question now is

318
00:11:39,519 --> 00:11:42,160
well how do we exploit this

319
00:11:42,160 --> 00:11:44,160
so for this we need some objective c

320
00:11:44,160 --> 00:11:45,920
internet which seems pretty fitting for

321
00:11:45,920 --> 00:11:48,560
this conference

322
00:11:48,640 --> 00:11:50,000
so here's some very

323
00:11:50,000 --> 00:11:52,480
simple objective c code is just making

324
00:11:52,480 --> 00:11:55,040
some bob object whatever that is

325
00:11:55,040 --> 00:11:57,440
and then calling a method on it

326
00:11:57,440 --> 00:12:00,639
and so if you do this um

327
00:12:00,639 --> 00:12:02,720
like in memory how it would look like is

328
00:12:02,720 --> 00:12:05,040
you have the bob instance

329
00:12:05,040 --> 00:12:07,519
which is created by the like bob unlock

330
00:12:07,519 --> 00:12:09,600
and init call

331
00:12:09,600 --> 00:12:12,000
and the bob instance has a pointer to

332
00:12:12,000 --> 00:12:14,480
its class so there is a class object in

333
00:12:14,480 --> 00:12:16,560
memory there is a there's one

334
00:12:16,560 --> 00:12:20,240
like bob class in memory um

335
00:12:20,240 --> 00:12:23,040
and the instance points to that with

336
00:12:23,040 --> 00:12:25,120
it's like isa or his air i don't know

337
00:12:25,120 --> 00:12:27,600
how to pronounce it uh field um so

338
00:12:27,600 --> 00:12:29,200
that's pretty much just the point of the

339
00:12:29,200 --> 00:12:30,079
class

340
00:12:30,079 --> 00:12:33,200
and so when um when we call a method on

341
00:12:33,200 --> 00:12:35,600
that instance what the runtime is going

342
00:12:35,600 --> 00:12:39,360
to do is it's going to uh have from the

343
00:12:39,360 --> 00:12:41,440
instance go to the class

344
00:12:41,440 --> 00:12:44,079
and then the class has this method table

345
00:12:44,079 --> 00:12:46,480
and then we're calling do something so

346
00:12:46,480 --> 00:12:48,639
in the method table it looks for the

347
00:12:48,639 --> 00:12:50,959
implementation of do something and if it

348
00:12:50,959 --> 00:12:52,959
finds it it's going to call it if it

349
00:12:52,959 --> 00:12:54,880
doesn't find it it will go to the like

350
00:12:54,880 --> 00:12:56,800
super class and if it still can't find

351
00:12:56,800 --> 00:12:59,040
it it throws an exception

352
00:12:59,040 --> 00:13:00,079
okay

353
00:13:00,079 --> 00:13:00,800
so

354
00:13:00,800 --> 00:13:03,519
some small objective c internals um what

355
00:13:03,519 --> 00:13:07,040
does that mean for our exploit well one

356
00:13:07,040 --> 00:13:09,600
what we want is like gain code execution

357
00:13:09,600 --> 00:13:10,560
so

358
00:13:10,560 --> 00:13:13,200
uh we know that it the runt or the due

359
00:13:13,200 --> 00:13:15,360
to our bug it will call

360
00:13:15,360 --> 00:13:17,279
like objective c methods on something we

361
00:13:17,279 --> 00:13:20,240
control so what we want to do is fake an

362
00:13:20,240 --> 00:13:22,800
objective c object fake an objective c

363
00:13:22,800 --> 00:13:24,959
class and then we can control code

364
00:13:24,959 --> 00:13:27,680
pointers right because if it's called if

365
00:13:27,680 --> 00:13:30,079
it's calling is in a string for example

366
00:13:30,079 --> 00:13:32,160
if we fake all these data structures

367
00:13:32,160 --> 00:13:35,519
it's going to call um or jump to address

368
00:13:35,519 --> 00:13:37,680
three one three three seven zero so

369
00:13:37,680 --> 00:13:39,519
that's gonna be our goal

370
00:13:39,519 --> 00:13:41,519
um

371
00:13:41,519 --> 00:13:43,360
the problem is for that we need a couple

372
00:13:43,360 --> 00:13:45,120
of addresses as you can see here like we

373
00:13:45,120 --> 00:13:46,959
need to put these objects somewhere and

374
00:13:46,959 --> 00:13:50,959
we need to know like code addresses

375
00:13:50,959 --> 00:13:54,000
and here's where aslr comes in

376
00:13:54,000 --> 00:13:55,279
so very

377
00:13:55,279 --> 00:13:59,199
common widely used exploit mitigation

378
00:13:59,199 --> 00:14:00,320
which

379
00:14:00,320 --> 00:14:02,160
randomizes all the addresses in the

380
00:14:02,160 --> 00:14:04,800
process right so before aslr everything

381
00:14:04,800 --> 00:14:06,800
like every library was always mapped at

382
00:14:06,800 --> 00:14:09,600
the same address with asr everything is

383
00:14:09,600 --> 00:14:11,279
now shifted and so we

384
00:14:11,279 --> 00:14:13,199
we don't actually know where anything is

385
00:14:13,199 --> 00:14:15,040
in memory right

386
00:14:15,040 --> 00:14:16,560
um

387
00:14:16,560 --> 00:14:17,839
and so

388
00:14:17,839 --> 00:14:20,720
checkpoint here um the first thing we

389
00:14:20,720 --> 00:14:23,120
now need to do is we need to break aslr

390
00:14:23,120 --> 00:14:25,120
because we need these addresses

391
00:14:25,120 --> 00:14:27,279
to like fake objects and and jump to

392
00:14:27,279 --> 00:14:29,360
code addresses

393
00:14:29,360 --> 00:14:30,639
um

394
00:14:30,639 --> 00:14:32,320
and so here again these are the

395
00:14:32,320 --> 00:14:34,000
addresses we need to know

396
00:14:34,000 --> 00:14:35,519
and we can divide them into two

397
00:14:35,519 --> 00:14:37,120
categories so

398
00:14:37,120 --> 00:14:39,199
one is heap addresses this is where our

399
00:14:39,199 --> 00:14:40,560
objects will live

400
00:14:40,560 --> 00:14:43,199
and the other is library addresses

401
00:14:43,199 --> 00:14:47,199
and we'll deal with both of these now

402
00:14:47,279 --> 00:14:49,199
so the heap address is actually really

403
00:14:49,199 --> 00:14:51,360
easy because there's something called

404
00:14:51,360 --> 00:14:52,720
heap spraying

405
00:14:52,720 --> 00:14:54,000
um

406
00:14:54,000 --> 00:14:55,920
which is like very whole thing in 15

407
00:14:55,920 --> 00:14:58,560
years or so probably older the idea is

408
00:14:58,560 --> 00:15:01,760
very simple just allocate lots of memory

409
00:15:01,760 --> 00:15:04,240
and then eventually like some known

410
00:15:04,240 --> 00:15:06,160
address will contain

411
00:15:06,160 --> 00:15:08,160
the allocated data

412
00:15:08,160 --> 00:15:10,639
so in on the right you can see some code

413
00:15:10,639 --> 00:15:13,760
which should just do that on ios um it

414
00:15:13,760 --> 00:15:16,959
allocates 256 megabytes

415
00:15:16,959 --> 00:15:18,560
um so you can just try running this in

416
00:15:18,560 --> 00:15:20,160
an app it should work

417
00:15:20,160 --> 00:15:22,880
so allocating 256 megabytes of memory

418
00:15:22,880 --> 00:15:25,600
and then this address hex

419
00:15:25,600 --> 00:15:27,680
seven zeros or whatever it is

420
00:15:27,680 --> 00:15:31,839
um does contain the allocated data

421
00:15:31,839 --> 00:15:33,839
so that's pretty easy and now what this

422
00:15:33,839 --> 00:15:36,639
means is we can like spray 256 megabytes

423
00:15:36,639 --> 00:15:37,759
and then we have

424
00:15:37,759 --> 00:15:41,519
our fake objects at this address

425
00:15:41,519 --> 00:15:44,399
okay so this problem is taken care of

426
00:15:44,399 --> 00:15:47,279
um we do have another address which meet

427
00:15:47,279 --> 00:15:49,759
the library addresses

428
00:15:49,759 --> 00:15:51,920
so for that uh some more

429
00:15:51,920 --> 00:15:54,000
ios or mac os internals it's like the

430
00:15:54,000 --> 00:15:56,720
same thing used on both platforms

431
00:15:56,720 --> 00:15:59,199
the dyld share cache

432
00:15:59,199 --> 00:16:01,519
so that's a pre-link blob of

433
00:16:01,519 --> 00:16:03,279
pretty much all the important system

434
00:16:03,279 --> 00:16:06,320
libraries on ios

435
00:16:06,320 --> 00:16:08,480
it's gigantic it's like a gigabyte of

436
00:16:08,480 --> 00:16:10,240
certain size um

437
00:16:10,240 --> 00:16:11,120
and

438
00:16:11,120 --> 00:16:12,639
it has a couple of interesting

439
00:16:12,639 --> 00:16:14,800
properties for uh like security

440
00:16:14,800 --> 00:16:16,000
researchers

441
00:16:16,000 --> 00:16:18,880
so first thing is it's always mapped

442
00:16:18,880 --> 00:16:21,440
between hex one eight seven zeros and

443
00:16:21,440 --> 00:16:24,079
two eight seven zero so there's only a

444
00:16:24,079 --> 00:16:26,399
four gigabyte region in in which the one

445
00:16:26,399 --> 00:16:28,399
gigabyte thing will live

446
00:16:28,399 --> 00:16:30,639
um it's randomized uh the like

447
00:16:30,639 --> 00:16:32,720
granularity of randomization is hex four

448
00:16:32,720 --> 00:16:36,800
thousand um that's large pages on ios

449
00:16:36,800 --> 00:16:38,720
but what's most interesting is it's

450
00:16:38,720 --> 00:16:41,759
actually mapped at the same address in

451
00:16:41,759 --> 00:16:43,120
every process

452
00:16:43,120 --> 00:16:44,639
on the same device

453
00:16:44,639 --> 00:16:47,120
so randomization is per boot and not per

454
00:16:47,120 --> 00:16:49,519
process which means that if we know

455
00:16:49,519 --> 00:16:51,360
where the thing is mapped in one process

456
00:16:51,360 --> 00:16:53,120
we know where it's mapped in all the

457
00:16:53,120 --> 00:16:56,079
others on the same device

458
00:16:56,079 --> 00:16:57,680
so this will be really

459
00:16:57,680 --> 00:16:58,880
important

460
00:16:58,880 --> 00:17:01,519
um so kind of this is how

461
00:17:01,519 --> 00:17:03,600
the situation looks now we're looking

462
00:17:03,600 --> 00:17:05,679
for the shared cache we know it's

463
00:17:05,679 --> 00:17:07,760
between these two addresses and so

464
00:17:07,760 --> 00:17:09,520
really we just need to know this this

465
00:17:09,520 --> 00:17:12,880
offset from the start

466
00:17:12,880 --> 00:17:15,119
um so suppose we had

467
00:17:15,119 --> 00:17:17,280
i hope you can read this suppose we had

468
00:17:17,280 --> 00:17:19,520
this like oracle function uh which we

469
00:17:19,520 --> 00:17:21,280
could give an address and it would tell

470
00:17:21,280 --> 00:17:24,799
us it is it mapped or is it not meant

471
00:17:24,799 --> 00:17:26,640
so just assume we have this we'll see

472
00:17:26,640 --> 00:17:29,440
where it comes from in a second

473
00:17:29,440 --> 00:17:30,799
if we have this

474
00:17:30,799 --> 00:17:31,679
then

475
00:17:31,679 --> 00:17:33,600
we can solve this easily

476
00:17:33,600 --> 00:17:36,400
because then all we all we would do

477
00:17:36,400 --> 00:17:37,679
is like

478
00:17:37,679 --> 00:17:39,760
step linearly

479
00:17:39,760 --> 00:17:41,120
between these two

480
00:17:41,120 --> 00:17:42,640
addresses

481
00:17:42,640 --> 00:17:45,120
and then the first time we find

482
00:17:45,120 --> 00:17:46,880
an address that's mapped then we know we

483
00:17:46,880 --> 00:17:48,640
have found some errors in the shared

484
00:17:48,640 --> 00:17:49,840
cache

485
00:17:49,840 --> 00:17:51,919
and then we just do a binary search and

486
00:17:51,919 --> 00:17:53,679
like figure out where

487
00:17:53,679 --> 00:17:55,360
the start is right

488
00:17:55,360 --> 00:17:56,799
so like

489
00:17:56,799 --> 00:17:58,080
in this case

490
00:17:58,080 --> 00:18:00,480
the linear search would find maybe these

491
00:18:00,480 --> 00:18:02,640
these two addresses that are not mapped

492
00:18:02,640 --> 00:18:04,080
and then we would find the next one that

493
00:18:04,080 --> 00:18:06,320
is mapped uh and then we do a binary

494
00:18:06,320 --> 00:18:08,720
search between the the last that's not

495
00:18:08,720 --> 00:18:10,400
mapped and the mapped one

496
00:18:10,400 --> 00:18:12,840
okay and then we have the the base

497
00:18:12,840 --> 00:18:15,440
address um

498
00:18:15,440 --> 00:18:17,360
so this would be really easy if we had

499
00:18:17,360 --> 00:18:18,880
such an oracle

500
00:18:18,880 --> 00:18:21,919
um question is why or where would we get

501
00:18:21,919 --> 00:18:24,320
this from

502
00:18:24,320 --> 00:18:26,559
and so another high message feature are

503
00:18:26,559 --> 00:18:28,000
really like this is a widespread

504
00:18:28,000 --> 00:18:29,600
messaging feature

505
00:18:29,600 --> 00:18:30,400
um

506
00:18:30,400 --> 00:18:32,960
are these receipts

507
00:18:32,960 --> 00:18:35,039
so there's two kind of receipts there's

508
00:18:35,039 --> 00:18:38,000
delivery receipts and read receipts um

509
00:18:38,000 --> 00:18:39,760
you can kind of see the

510
00:18:39,760 --> 00:18:41,679
yeah if you ever use imessage you can

511
00:18:41,679 --> 00:18:43,760
you probably recognize these message

512
00:18:43,760 --> 00:18:45,200
statuses here

513
00:18:45,200 --> 00:18:46,559
so here i have

514
00:18:46,559 --> 00:18:48,080
three different messages with three

515
00:18:48,080 --> 00:18:51,039
different states the first one was red

516
00:18:51,039 --> 00:18:54,880
the second deliver and desert nothing

517
00:18:54,880 --> 00:18:56,640
and so what that means is for the first

518
00:18:56,640 --> 00:18:58,080
message the

519
00:18:58,080 --> 00:19:00,559
sender got back two receipts um a

520
00:19:00,559 --> 00:19:02,960
delivery and a read receipt

521
00:19:02,960 --> 00:19:04,960
for the second message the sender got

522
00:19:04,960 --> 00:19:07,039
back only a delivery received and for

523
00:19:07,039 --> 00:19:08,799
the third message the sender didn't get

524
00:19:08,799 --> 00:19:11,360
back anything yet

525
00:19:11,360 --> 00:19:12,799
and so this is pretty interesting

526
00:19:12,799 --> 00:19:14,880
because these delivery receipts are sent

527
00:19:14,880 --> 00:19:16,720
automatically

528
00:19:16,720 --> 00:19:19,280
by the receiving device back to the

529
00:19:19,280 --> 00:19:21,678
sender

530
00:19:21,840 --> 00:19:25,039
and so if we look um at when they are

531
00:19:25,039 --> 00:19:27,200
saying it's even more interesting here's

532
00:19:27,200 --> 00:19:29,039
pseudocode for

533
00:19:29,039 --> 00:19:32,080
the handling of imessages in in this one

534
00:19:32,080 --> 00:19:34,160
daemon

535
00:19:34,160 --> 00:19:35,280
and so

536
00:19:35,280 --> 00:19:38,080
like it's pausing the incoming data as a

537
00:19:38,080 --> 00:19:39,760
p-list that we've seen

538
00:19:39,760 --> 00:19:41,840
then it's doing this our unarchiving

539
00:19:41,840 --> 00:19:44,080
this is where our bug would trigger

540
00:19:44,080 --> 00:19:45,679
and only then

541
00:19:45,679 --> 00:19:48,480
is it sending these delivery receipts

542
00:19:48,480 --> 00:19:50,799
and so what this now means is that

543
00:19:50,799 --> 00:19:51,760
if

544
00:19:51,760 --> 00:19:54,160
during the unarchiving we crash

545
00:19:54,160 --> 00:19:57,200
uh we will never see a delivery receipt

546
00:19:57,200 --> 00:19:59,200
and if we don't crash then we'll see a

547
00:19:59,200 --> 00:20:01,200
delivery receipt right so now we have

548
00:20:01,200 --> 00:20:03,039
like this one bit

549
00:20:03,039 --> 00:20:04,880
information coming back did it crash or

550
00:20:04,880 --> 00:20:07,440
did did not crash and this is exactly

551
00:20:07,440 --> 00:20:10,080
what we need for this oracle

552
00:20:10,080 --> 00:20:12,320
okay

553
00:20:13,120 --> 00:20:14,480
so

554
00:20:14,480 --> 00:20:15,280
the

555
00:20:15,280 --> 00:20:18,000
vulnerability that i'm exploiting here

556
00:20:18,000 --> 00:20:18,880
um

557
00:20:18,880 --> 00:20:21,919
it doesn't yield this perfect oracle

558
00:20:21,919 --> 00:20:24,799
function like it doesn't let you ask

559
00:20:24,799 --> 00:20:26,400
is this address mapped or is it not

560
00:20:26,400 --> 00:20:28,320
mapped it lets you ask a different

561
00:20:28,320 --> 00:20:30,400
question something like is it mapped and

562
00:20:30,400 --> 00:20:32,559
if it is mapped is it zero or does it

563
00:20:32,559 --> 00:20:34,400
have some bid set or whatever

564
00:20:34,400 --> 00:20:36,000
um

565
00:20:36,000 --> 00:20:39,120
it still works um but it's a slightly

566
00:20:39,120 --> 00:20:41,919
it's more a bit more complicated but do

567
00:20:41,919 --> 00:20:43,120
check out the blog post if you're

568
00:20:43,120 --> 00:20:44,159
interested

569
00:20:44,159 --> 00:20:46,720
um but yeah the rough idea still works

570
00:20:46,720 --> 00:20:49,039
it's still kind of a binary search thing

571
00:20:49,039 --> 00:20:52,640
and it takes only like 20 to 30 messages

572
00:20:52,640 --> 00:20:53,600
to

573
00:20:53,600 --> 00:20:55,760
do this like probing this binary search

574
00:20:55,760 --> 00:20:56,960
thing and so on

575
00:20:56,960 --> 00:20:59,200
and so it takes less than five minutes

576
00:20:59,200 --> 00:21:00,159
um

577
00:21:00,159 --> 00:21:02,320
you will see it hopefully in the demo

578
00:21:02,320 --> 00:21:03,760
later

579
00:21:03,760 --> 00:21:05,360
right so again this is kind of the

580
00:21:05,360 --> 00:21:07,760
summary of the aslr bypass there's two

581
00:21:07,760 --> 00:21:10,080
phases the linear scan where it just

582
00:21:10,080 --> 00:21:13,679
like goes in 128 or so megabyte steps

583
00:21:13,679 --> 00:21:16,559
until it does get back a delivery seat

584
00:21:16,559 --> 00:21:18,240
where it knows okay i found something

585
00:21:18,240 --> 00:21:20,159
that's mapped and then there's this

586
00:21:20,159 --> 00:21:23,280
binary search phase your cpu feature um

587
00:21:23,280 --> 00:21:24,480
meant to

588
00:21:24,480 --> 00:21:26,720
stop or like at least

589
00:21:26,720 --> 00:21:28,480
make it make

590
00:21:28,480 --> 00:21:31,120
binary exploits more difficult

591
00:21:31,120 --> 00:21:33,679
um the idea is to

592
00:21:33,679 --> 00:21:36,159
store cryptographic signatures in top

593
00:21:36,159 --> 00:21:37,840
bits of a pointer

594
00:21:37,840 --> 00:21:39,760
so you can see the example on the in the

595
00:21:39,760 --> 00:21:41,200
bottom

596
00:21:41,200 --> 00:21:42,640
you start from a

597
00:21:42,640 --> 00:21:45,600
normal code pointer and you realize that

598
00:21:45,600 --> 00:21:48,320
the the top bits are all zero

599
00:21:48,320 --> 00:21:50,320
because there's nothing mapped there

600
00:21:50,320 --> 00:21:51,280
um

601
00:21:51,280 --> 00:21:53,520
then you sign that and you do this like

602
00:21:53,520 --> 00:21:54,720
for example during process

603
00:21:54,720 --> 00:21:56,400
initialization

604
00:21:56,400 --> 00:21:57,440
and then you

605
00:21:57,440 --> 00:21:59,360
so the signing is like computing some

606
00:21:59,360 --> 00:22:01,520
some cryptography signature and then you

607
00:22:01,520 --> 00:22:02,559
store

608
00:22:02,559 --> 00:22:05,280
the signature or like parts of it in the

609
00:22:05,280 --> 00:22:07,200
top bits of the pointer

610
00:22:07,200 --> 00:22:08,799
and then when you actually use this

611
00:22:08,799 --> 00:22:11,200
pointer to jump to some code

612
00:22:11,200 --> 00:22:13,120
you authenticate it

613
00:22:13,120 --> 00:22:14,640
right and so this authentication what it

614
00:22:14,640 --> 00:22:16,960
does is like recompute the signature

615
00:22:16,960 --> 00:22:19,280
compares it with the one in the pointer

616
00:22:19,280 --> 00:22:21,440
and if it doesn't match it will pretty

617
00:22:21,440 --> 00:22:23,760
much just crash your process

618
00:22:23,760 --> 00:22:25,360
um

619
00:22:25,360 --> 00:22:28,080
and so yeah it is used to ensure

620
00:22:28,080 --> 00:22:29,840
more or less control for integrity

621
00:22:29,840 --> 00:22:31,679
currently it can do more it probably

622
00:22:31,679 --> 00:22:34,400
will be used to do more stuff um

623
00:22:34,400 --> 00:22:35,520
and the

624
00:22:35,520 --> 00:22:37,840
yeah the key idea is the attacker

625
00:22:37,840 --> 00:22:40,400
doesn't have the key and so the attacker

626
00:22:40,400 --> 00:22:43,919
can't compute these signatures

627
00:22:43,919 --> 00:22:45,679
brandon did

628
00:22:45,679 --> 00:22:47,360
some really good research into this and

629
00:22:47,360 --> 00:22:50,320
wrote blog posts so if you're interested

630
00:22:50,320 --> 00:22:52,080
go check out those

631
00:22:52,080 --> 00:22:55,039
anyway what we need to know now is we

632
00:22:55,039 --> 00:22:56,320
can't

633
00:22:56,320 --> 00:22:58,640
we're just gonna assume we can fake any

634
00:22:58,640 --> 00:23:00,480
of these code pointers because we don't

635
00:23:00,480 --> 00:23:02,400
have the key

636
00:23:02,400 --> 00:23:03,679
and so

637
00:23:03,679 --> 00:23:06,480
our current exploit attempt or approach

638
00:23:06,480 --> 00:23:08,880
uh doesn't work right

639
00:23:08,880 --> 00:23:10,559
it involves faking a code point that

640
00:23:10,559 --> 00:23:12,400
involves faking these classes which have

641
00:23:12,400 --> 00:23:14,320
code pointed so that doesn't work

642
00:23:14,320 --> 00:23:15,760
because we can't

643
00:23:15,760 --> 00:23:17,840
fake these pointers

644
00:23:17,840 --> 00:23:20,400
so let's go back here um

645
00:23:20,400 --> 00:23:22,960
go back to objective c internals

646
00:23:22,960 --> 00:23:24,400
that's the same slide i showed at the

647
00:23:24,400 --> 00:23:26,000
beginning write the instance pointing to

648
00:23:26,000 --> 00:23:27,039
the class

649
00:23:27,039 --> 00:23:29,280
um what we can do now is take a look at

650
00:23:29,280 --> 00:23:31,520
which of these pointers are assigned and

651
00:23:31,520 --> 00:23:33,039
which ones are not

652
00:23:33,039 --> 00:23:35,200
and so the the code pointers in the

653
00:23:35,200 --> 00:23:37,280
class they are obviously signed

654
00:23:37,280 --> 00:23:40,720
um but what is not signed is the the isa

655
00:23:40,720 --> 00:23:43,120
pointer so the pointer from the instance

656
00:23:43,120 --> 00:23:44,640
to the class

657
00:23:44,640 --> 00:23:47,120
that's still a raw pointer the

658
00:23:47,120 --> 00:23:49,039
i guess the main reason right now is

659
00:23:49,039 --> 00:23:51,039
that this this pointer actually uses the

660
00:23:51,039 --> 00:23:53,039
top bits to store other parts of

661
00:23:53,039 --> 00:23:55,120
information like it stores a ref now

662
00:23:55,120 --> 00:23:57,919
there so it just can't store

663
00:23:57,919 --> 00:23:59,279
this signature

664
00:23:59,279 --> 00:24:01,679
right now

665
00:24:01,919 --> 00:24:03,679
cool so

666
00:24:03,679 --> 00:24:06,080
again the iso point is not protected

667
00:24:06,080 --> 00:24:08,720
what this means is that

668
00:24:08,720 --> 00:24:10,720
while we cannot fake

669
00:24:10,720 --> 00:24:11,919
classes

670
00:24:11,919 --> 00:24:14,080
what we can do is we can still fake

671
00:24:14,080 --> 00:24:16,320
objects and make them like point to

672
00:24:16,320 --> 00:24:18,880
legitimate classes because again this

673
00:24:18,880 --> 00:24:22,400
this is pointer isn't protected um and

674
00:24:22,400 --> 00:24:23,760
so we can

675
00:24:23,760 --> 00:24:26,400
with that get pretty much um like

676
00:24:26,400 --> 00:24:28,960
existing functions or methods called

677
00:24:28,960 --> 00:24:30,880
right because we we will make an

678
00:24:30,880 --> 00:24:32,640
instance of an existing class and so

679
00:24:32,640 --> 00:24:34,240
this class will have correctly signed

680
00:24:34,240 --> 00:24:36,960
pointers uh and so if we call methods on

681
00:24:36,960 --> 00:24:39,200
that fake object it will like

682
00:24:39,200 --> 00:24:42,000
call the the legitimate

683
00:24:42,000 --> 00:24:44,799
objective c code that's in the process

684
00:24:44,799 --> 00:24:47,279
and so for example this lets us call

685
00:24:47,279 --> 00:24:48,880
any dialogue

686
00:24:48,880 --> 00:24:51,840
method in the process

687
00:24:51,840 --> 00:24:54,320
okay so this is where we are

688
00:24:54,320 --> 00:24:56,320
so for the pack bypass right now we can

689
00:24:56,320 --> 00:25:00,480
call dialog on some class

690
00:25:01,279 --> 00:25:03,279
the thing is yeah we can call the other

691
00:25:03,279 --> 00:25:04,960
but what we want to call is some

692
00:25:04,960 --> 00:25:06,080
arbitrary

693
00:25:06,080 --> 00:25:08,080
objective c method right we

694
00:25:08,080 --> 00:25:09,520
want to launch a calculator because

695
00:25:09,520 --> 00:25:12,640
that's what everyone wants to do

696
00:25:12,640 --> 00:25:14,720
and so we really want to do this method

697
00:25:14,720 --> 00:25:16,240
called at the bottom like the ui

698
00:25:16,240 --> 00:25:17,440
application

699
00:25:17,440 --> 00:25:19,520
launch something blah blah blah

700
00:25:19,520 --> 00:25:21,679
so the question is how do we get from

701
00:25:21,679 --> 00:25:23,600
being able to call some dialogue

702
00:25:23,600 --> 00:25:27,279
implementation to calling this

703
00:25:27,840 --> 00:25:31,120
and we need more objective theo tunnels

704
00:25:31,120 --> 00:25:33,919
um there is some really cool class

705
00:25:33,919 --> 00:25:36,559
called ns invocation

706
00:25:36,559 --> 00:25:38,480
it's basically like a bound function

707
00:25:38,480 --> 00:25:40,320
call it lets you

708
00:25:40,320 --> 00:25:42,240
um it's an object that lets you set like

709
00:25:42,240 --> 00:25:45,120
the receiver and the message to call

710
00:25:45,120 --> 00:25:47,679
and then lets you set all the arguments

711
00:25:47,679 --> 00:25:50,720
and once you call the invoke method on

712
00:25:50,720 --> 00:25:52,720
this object it will do this method

713
00:25:52,720 --> 00:25:55,679
called on the on your target right

714
00:25:55,679 --> 00:25:58,000
and so if you wanted to call

715
00:25:58,000 --> 00:25:59,679
this this launch application with

716
00:25:59,679 --> 00:26:03,279
identifier method the ns invocation uh

717
00:26:03,279 --> 00:26:04,960
this thing has an nsa location looks

718
00:26:04,960 --> 00:26:06,880
like that right so you have you make an

719
00:26:06,880 --> 00:26:09,360
msn location object you set the target

720
00:26:09,360 --> 00:26:11,360
you set the method you send some

721
00:26:11,360 --> 00:26:13,520
arguments and then you invoke it

722
00:26:13,520 --> 00:26:14,320
right

723
00:26:14,320 --> 00:26:16,400
so why is this useful

724
00:26:16,400 --> 00:26:18,640
well let's assume um

725
00:26:18,640 --> 00:26:21,039
we have a dialog function that calls

726
00:26:21,039 --> 00:26:24,400
invoke on a controlled ns invocation

727
00:26:24,400 --> 00:26:27,120
if we have that then we could just like

728
00:26:27,120 --> 00:26:29,840
fake another or fake ns invocation and

729
00:26:29,840 --> 00:26:31,760
get its invoke called and then we would

730
00:26:31,760 --> 00:26:33,279
get a completely controlled method

731
00:26:33,279 --> 00:26:34,640
called

732
00:26:34,640 --> 00:26:35,520
um

733
00:26:35,520 --> 00:26:38,000
and so the way to do the way i did it is

734
00:26:38,000 --> 00:26:40,000
i wrote some either python which you can

735
00:26:40,000 --> 00:26:41,039
see here

736
00:26:41,039 --> 00:26:43,039
it's really just these like i don't know

737
00:26:43,039 --> 00:26:45,360
seven or so lines of code

738
00:26:45,360 --> 00:26:46,159
which

739
00:26:46,159 --> 00:26:48,320
find every dialogue implementation in

740
00:26:48,320 --> 00:26:50,400
the process

741
00:26:50,400 --> 00:26:52,400
and then decompile that and so then i

742
00:26:52,400 --> 00:26:54,640
have a like list of i think it's a

743
00:26:54,640 --> 00:26:56,240
couple ten thousand

744
00:26:56,240 --> 00:26:58,720
uh dialogue methods and then i just grab

745
00:26:58,720 --> 00:27:01,279
for invoke in those right

746
00:27:01,279 --> 00:27:04,559
um and this turned up at least one so

747
00:27:04,559 --> 00:27:06,880
here's this mp media picker controller

748
00:27:06,880 --> 00:27:07,840
class

749
00:27:07,840 --> 00:27:09,679
has a dialog

750
00:27:09,679 --> 00:27:11,760
and what it's doing is it's

751
00:27:11,760 --> 00:27:13,440
besides other things it's calling the

752
00:27:13,440 --> 00:27:16,720
invoke method on one of its field fields

753
00:27:16,720 --> 00:27:18,240
and of course since we completely

754
00:27:18,240 --> 00:27:20,080
control this object we control all the

755
00:27:20,080 --> 00:27:23,600
fields and so we can like make field x

756
00:27:23,600 --> 00:27:25,200
350

757
00:27:25,200 --> 00:27:26,880
point to some

758
00:27:26,880 --> 00:27:28,880
uh again completely controlled nsm

759
00:27:28,880 --> 00:27:31,200
location

760
00:27:31,200 --> 00:27:33,840
okay and so this finally lets us now

761
00:27:33,840 --> 00:27:35,840
call uh arbitrary

762
00:27:35,840 --> 00:27:38,880
uh objective c methods through yeah ns

763
00:27:38,880 --> 00:27:41,039
and location

764
00:27:41,039 --> 00:27:44,480
okay what about sandboxing so um we can

765
00:27:44,480 --> 00:27:46,240
run objective c call but are we

766
00:27:46,240 --> 00:27:48,320
sandboxed

767
00:27:48,320 --> 00:27:50,880
so on the right side you see all are the

768
00:27:50,880 --> 00:27:53,520
most important demons

769
00:27:53,520 --> 00:27:56,080
handling imessages it starts

770
00:27:56,080 --> 00:27:59,200
with apsd apple's push services demon

771
00:27:59,200 --> 00:28:01,039
goes to this identity service team and

772
00:28:01,039 --> 00:28:02,080
et cetera

773
00:28:02,080 --> 00:28:04,799
im agent is doing most of the work

774
00:28:04,799 --> 00:28:07,279
and then springboard is showing these

775
00:28:07,279 --> 00:28:09,200
notifications right springboard is like

776
00:28:09,200 --> 00:28:11,919
the main ui process

777
00:28:11,919 --> 00:28:13,840
and those with the red border they are

778
00:28:13,840 --> 00:28:16,000
sandboxed but springbok springboard

779
00:28:16,000 --> 00:28:18,080
isn't like it's a system demon kind of

780
00:28:18,080 --> 00:28:20,000
it's really important it has to do all

781
00:28:20,000 --> 00:28:21,840
kinds of things so it's naturally not

782
00:28:21,840 --> 00:28:22,960
sandbox

783
00:28:22,960 --> 00:28:24,399
um

784
00:28:24,399 --> 00:28:27,760
but interestingly up up until ios 13

785
00:28:27,760 --> 00:28:30,880
this ns unarchiver decoding actually

786
00:28:30,880 --> 00:28:32,880
also happened in springboard

787
00:28:32,880 --> 00:28:34,480
so with any

788
00:28:34,480 --> 00:28:36,559
ns unarchiving bug you could like

789
00:28:36,559 --> 00:28:38,320
trigger it directly outside of the

790
00:28:38,320 --> 00:28:39,360
sandbox

791
00:28:39,360 --> 00:28:41,520
by targeting springboard

792
00:28:41,520 --> 00:28:43,200
and so we don't actually have to deal

793
00:28:43,200 --> 00:28:45,279
with any sample thing yeah because we

794
00:28:45,279 --> 00:28:48,000
can target springboard

795
00:28:48,000 --> 00:28:51,600
as a ios 13 this has changed and this

796
00:28:51,600 --> 00:28:53,840
this one field that was being decoded in

797
00:28:53,840 --> 00:28:57,039
springboard is now decoded in i believe

798
00:28:57,039 --> 00:28:59,200
it's imd persistence agent but i'm not

799
00:28:59,200 --> 00:29:00,480
sure but it is

800
00:29:00,480 --> 00:29:04,159
decoded in the sandbox process

801
00:29:04,559 --> 00:29:07,679
okay um yeah this is where we are pretty

802
00:29:07,679 --> 00:29:09,679
much done now

803
00:29:09,679 --> 00:29:12,399
we have bypass asr we have a way to deal

804
00:29:12,399 --> 00:29:14,640
with pac by like

805
00:29:14,640 --> 00:29:16,880
chaining these objective c method calls

806
00:29:16,880 --> 00:29:19,039
together uh and at the end we end up

807
00:29:19,039 --> 00:29:21,919
with a controlled call to this launch

808
00:29:21,919 --> 00:29:24,080
application with identifier of course we

809
00:29:24,080 --> 00:29:25,919
could do other things but for demo

810
00:29:25,919 --> 00:29:27,279
purposes

811
00:29:27,279 --> 00:29:29,840
this is of course what you do

812
00:29:29,840 --> 00:29:33,360
so let me try to set up my demo

813
00:29:33,360 --> 00:29:35,980
so one second

814
00:29:35,980 --> 00:29:39,069
[Music]

815
00:29:42,159 --> 00:29:45,159
so

816
00:29:57,600 --> 00:29:59,919
right that's me

817
00:29:59,919 --> 00:30:02,880
that's not what i want

818
00:30:04,159 --> 00:30:07,159
okay

819
00:30:10,880 --> 00:30:13,520
hds

820
00:30:17,440 --> 00:30:20,640
cool so that's this this iphone here um

821
00:30:20,640 --> 00:30:21,679
just like

822
00:30:21,679 --> 00:30:24,080
screen capture with quicktime

823
00:30:24,080 --> 00:30:26,960
um let me see so

824
00:30:26,960 --> 00:30:27,760
ah

825
00:30:27,760 --> 00:30:30,159
this microphone is on right yeah perfect

826
00:30:30,159 --> 00:30:31,600
um

827
00:30:31,600 --> 00:30:34,399
right so it is on 12.4 it it is a iphone

828
00:30:34,399 --> 00:30:36,720
10s so one with point authentication

829
00:30:36,720 --> 00:30:39,360
12.4 is the last vulnerable version so

830
00:30:39,360 --> 00:30:40,960
that's like

831
00:30:40,960 --> 00:30:43,440
nine months old by now eight months

832
00:30:43,440 --> 00:30:45,440
um

833
00:30:45,440 --> 00:30:49,559
yeah there's no existing chats

834
00:30:51,600 --> 00:30:53,120
is this big enough by the way i can

835
00:30:53,120 --> 00:30:54,640
increase font size

836
00:30:54,640 --> 00:30:57,919
last row can you read this

837
00:30:59,120 --> 00:31:01,439
bigger

838
00:31:01,919 --> 00:31:05,320
this is

839
00:31:05,760 --> 00:31:07,039
better

840
00:31:07,039 --> 00:31:10,320
yeah cool thanks

841
00:31:12,159 --> 00:31:13,360
okay

842
00:31:13,360 --> 00:31:15,279
so while this runs i can maybe explain a

843
00:31:15,279 --> 00:31:18,240
bit what's going on um yeah so you see

844
00:31:18,240 --> 00:31:21,200
it's like doing this linear

845
00:31:21,200 --> 00:31:23,360
um probing thing like it's starting at

846
00:31:23,360 --> 00:31:25,360
the base address checking if that's

847
00:31:25,360 --> 00:31:28,480
mapped and now i hope you can read it

848
00:31:28,480 --> 00:31:30,480
there it does show these notifications

849
00:31:30,480 --> 00:31:32,399
um popping up now

850
00:31:32,399 --> 00:31:35,039
this is mostly so there is a way to

851
00:31:35,039 --> 00:31:36,399
suppress those

852
00:31:36,399 --> 00:31:38,320
uh but i think it's cool if there's

853
00:31:38,320 --> 00:31:39,840
something showing up

854
00:31:39,840 --> 00:31:42,158
um

855
00:31:42,559 --> 00:31:44,320
yeah what else

856
00:31:44,320 --> 00:31:46,480
so the way this this works it is you

857
00:31:46,480 --> 00:31:49,200
it's using frida um if some of you know

858
00:31:49,200 --> 00:31:51,440
this uh like a hooking framework and

859
00:31:51,440 --> 00:31:53,039
it's hooking into the

860
00:31:53,039 --> 00:31:56,080
the messages app on um on mac os right

861
00:31:56,080 --> 00:31:56,799
so

862
00:31:56,799 --> 00:31:58,640
like what this is doing it's using

863
00:31:58,640 --> 00:32:00,640
applescript to send messages

864
00:32:00,640 --> 00:32:01,919
automatically

865
00:32:01,919 --> 00:32:04,000
and then using a frida hook to replace

866
00:32:04,000 --> 00:32:06,480
these messages with like my

867
00:32:06,480 --> 00:32:08,480
uh my exploit content

868
00:32:08,480 --> 00:32:10,640
um

869
00:32:10,640 --> 00:32:14,159
okay so what happened now is uh it got a

870
00:32:14,159 --> 00:32:15,919
delivery received

871
00:32:15,919 --> 00:32:18,880
when testing this address hex 1d series

872
00:32:18,880 --> 00:32:19,840
there

873
00:32:19,840 --> 00:32:21,360
and so it figured okay that's a valid

874
00:32:21,360 --> 00:32:23,760
address inside the shared cache

875
00:32:23,760 --> 00:32:26,320
and now i figured how many possible base

876
00:32:26,320 --> 00:32:28,399
addresses are there

877
00:32:28,399 --> 00:32:30,159
that would lead to this address being

878
00:32:30,159 --> 00:32:31,600
valid

879
00:32:31,600 --> 00:32:33,840
and now it's starting this

880
00:32:33,840 --> 00:32:36,080
this buyer basically buying research

881
00:32:36,080 --> 00:32:36,960
phase

882
00:32:36,960 --> 00:32:38,960
where it's roughly halving

883
00:32:38,960 --> 00:32:40,640
the number of candidates in every

884
00:32:40,640 --> 00:32:42,880
iteration

885
00:32:42,880 --> 00:32:44,960
uh so it already went down to seventeen

886
00:32:44,960 --> 00:32:48,240
thousand from thirty four thousand

887
00:32:48,240 --> 00:32:51,200
uh maybe another thing um

888
00:32:51,200 --> 00:32:54,320
it is like waiting roughly ten seconds

889
00:32:54,320 --> 00:32:56,880
between each attempt because if you

890
00:32:56,880 --> 00:32:57,919
crash

891
00:32:57,919 --> 00:32:59,200
too often

892
00:32:59,200 --> 00:33:01,679
uh then the daemon will be like rate

893
00:33:01,679 --> 00:33:02,799
limited

894
00:33:02,799 --> 00:33:05,360
right so if you crash like three or two

895
00:33:05,360 --> 00:33:07,519
times within 10 seconds or so then

896
00:33:07,519 --> 00:33:08,960
launched you will actually not

897
00:33:08,960 --> 00:33:10,799
immediately restart the process but it

898
00:33:10,799 --> 00:33:12,240
will take some time

899
00:33:12,240 --> 00:33:13,200
um

900
00:33:13,200 --> 00:33:15,360
but yeah so it just waits 10 seconds and

901
00:33:15,360 --> 00:33:16,399
then

902
00:33:16,399 --> 00:33:18,960
it's it's still pretty fast like it only

903
00:33:18,960 --> 00:33:20,480
takes five minutes

904
00:33:20,480 --> 00:33:22,000
um

905
00:33:22,000 --> 00:33:24,720
anything else

906
00:33:24,720 --> 00:33:26,559
yeah

907
00:33:26,559 --> 00:33:28,240
i guess this this automatically

908
00:33:28,240 --> 00:33:30,320
restarting service problem is really

909
00:33:30,320 --> 00:33:32,399
like one of the key factors that makes

910
00:33:32,399 --> 00:33:34,880
this exploit possible so if

911
00:33:34,880 --> 00:33:36,640
if if

912
00:33:36,640 --> 00:33:38,559
launchd wouldn't just automatically

913
00:33:38,559 --> 00:33:40,320
restart the service again and again and

914
00:33:40,320 --> 00:33:42,640
again then this technique wouldn't

915
00:33:42,640 --> 00:33:44,960
really work but yeah launchd is very

916
00:33:44,960 --> 00:33:49,039
happy to just relaunch it every time

917
00:33:49,039 --> 00:33:51,360
um

918
00:33:51,440 --> 00:33:52,960
see

919
00:33:52,960 --> 00:33:55,600
almost done

920
00:34:00,720 --> 00:34:04,760
do you think apple will add mitigation

921
00:34:04,840 --> 00:34:06,640
[Music]

922
00:34:06,640 --> 00:34:09,280
i hope so but i haven't checked lately

923
00:34:09,280 --> 00:34:11,760
it's kind of hard to to test this

924
00:34:11,760 --> 00:34:13,040
but this is one of my main

925
00:34:13,040 --> 00:34:15,760
recommendations yeah this is also

926
00:34:15,760 --> 00:34:17,918
the same problem it's not it's not an

927
00:34:17,918 --> 00:34:20,639
apple specific problem right like chroma

928
00:34:20,639 --> 00:34:22,719
so they also restart their

929
00:34:22,719 --> 00:34:24,480
their processes

930
00:34:24,480 --> 00:34:27,599
frequently so they're you can do

931
00:34:27,599 --> 00:34:30,159
pull off similar exploits but yeah i do

932
00:34:30,159 --> 00:34:31,760
think it's pretty important to limit

933
00:34:31,760 --> 00:34:32,560
this

934
00:34:32,560 --> 00:34:34,560
okay um so this

935
00:34:34,560 --> 00:34:37,199
worked so it's now saying um yeah shared

936
00:34:37,199 --> 00:34:39,679
cash is mapped at this one address let's

937
00:34:39,679 --> 00:34:41,440
figure that out i haven't stopped the

938
00:34:41,440 --> 00:34:42,639
time but it

939
00:34:42,639 --> 00:34:44,560
can't have been that long

940
00:34:44,560 --> 00:34:46,399
um

941
00:34:46,399 --> 00:34:50,239
i if you're wondering why it says um

942
00:34:50,239 --> 00:34:52,719
if you're wondering why it says 9941

943
00:34:52,719 --> 00:34:54,000
this is some

944
00:34:54,000 --> 00:34:56,079
ios thing if you connect ios to this

945
00:34:56,079 --> 00:34:57,839
quicktime it always puts the time to

946
00:34:57,839 --> 00:35:00,160
this i think it's

947
00:35:00,160 --> 00:35:02,800
uh it's from some from some apple demo

948
00:35:02,800 --> 00:35:05,040
where they put in this code i don't know

949
00:35:05,040 --> 00:35:07,040
um but it is not recorded like it is

950
00:35:07,040 --> 00:35:07,920
actually

951
00:35:07,920 --> 00:35:10,000
happening here

952
00:35:10,000 --> 00:35:11,440
um

953
00:35:11,440 --> 00:35:13,760
yeah so this is now the heap spray

954
00:35:13,760 --> 00:35:16,960
that's going on and it is it is kind of

955
00:35:16,960 --> 00:35:17,839
uh

956
00:35:17,839 --> 00:35:19,520
hacky so

957
00:35:19,520 --> 00:35:20,960
i think if you

958
00:35:20,960 --> 00:35:22,480
were to do this properly you would do

959
00:35:22,480 --> 00:35:24,240
the entire heap spray in one message

960
00:35:24,240 --> 00:35:27,599
which is possible it's just um more

961
00:35:27,599 --> 00:35:30,160
engineering iphone so i didn't didn't do

962
00:35:30,160 --> 00:35:30,960
that

963
00:35:30,960 --> 00:35:32,400
but i think that it would also be more

964
00:35:32,400 --> 00:35:34,800
reliable so there is a small chance this

965
00:35:34,800 --> 00:35:36,079
crashes

966
00:35:36,079 --> 00:35:37,280
um

967
00:35:37,280 --> 00:35:38,480
so far

968
00:35:38,480 --> 00:35:40,240
it has always worked during live demos

969
00:35:40,240 --> 00:35:41,680
but we'll see

970
00:35:41,680 --> 00:35:44,400
we'll see what happens this time

971
00:35:44,400 --> 00:35:47,760
okay let's go

972
00:35:48,000 --> 00:35:50,240
yeah

973
00:35:50,480 --> 00:35:52,880
i should be should be good

974
00:35:52,880 --> 00:35:54,880
it's always freezing like right before

975
00:35:54,880 --> 00:35:58,359
it works yes

976
00:36:05,920 --> 00:36:09,440
okay yeah thanks a lot um

977
00:36:09,520 --> 00:36:11,440
yeah i guess i can take questions off

978
00:36:11,440 --> 00:36:13,839
there any

979
00:36:19,440 --> 00:36:22,160
a big part of this way to reduce

980
00:36:22,160 --> 00:36:24,480
the issue

981
00:36:25,040 --> 00:36:29,920
right so um let me go back to my slides

982
00:36:32,640 --> 00:36:34,560
yeah sure um so the question was i

983
00:36:34,560 --> 00:36:36,160
mentioned that apple

984
00:36:36,160 --> 00:36:39,359
pushed some mitigation in 1241

985
00:36:39,359 --> 00:36:41,440
so what was this mitigation

986
00:36:41,440 --> 00:36:43,760
um

987
00:36:43,760 --> 00:36:46,960
so what i what i mentioned is um when

988
00:36:46,960 --> 00:36:48,800
when you use this ms key to unarchive

989
00:36:48,800 --> 00:36:50,720
and you give it this white list

990
00:36:50,720 --> 00:36:52,800
what actually happens is it will not

991
00:36:52,800 --> 00:36:54,960
just allow these classes but also all

992
00:36:54,960 --> 00:36:57,760
their subclasses so this is exactly the

993
00:36:57,760 --> 00:36:59,359
white list they had an imessage and it

994
00:36:59,359 --> 00:37:00,960
looks like it would only allow these

995
00:37:00,960 --> 00:37:03,119
seven or so classes but really it were

996
00:37:03,119 --> 00:37:04,560
like 50

997
00:37:04,560 --> 00:37:05,359
right

998
00:37:05,359 --> 00:37:07,119
and what apple did is they exactly

999
00:37:07,119 --> 00:37:08,640
prevented this from happening in

1000
00:37:08,640 --> 00:37:10,720
imessage so they put in a new

1001
00:37:10,720 --> 00:37:12,160
decoding mode

1002
00:37:12,160 --> 00:37:14,000
um like strict

1003
00:37:14,000 --> 00:37:15,599
decoding also

1004
00:37:15,599 --> 00:37:17,680
uh which now really just allows these

1005
00:37:17,680 --> 00:37:20,560
seven and not all the like 50 or so

1006
00:37:20,560 --> 00:37:21,920
others

1007
00:37:21,920 --> 00:37:24,240
and all of the the bugs we found all of

1008
00:37:24,240 --> 00:37:26,800
these they were all in subclasses

1009
00:37:26,800 --> 00:37:28,880
and so they would not have worked

1010
00:37:28,880 --> 00:37:31,280
anymore

1011
00:37:31,920 --> 00:37:35,800
you know any other questions

1012
00:38:01,280 --> 00:38:03,200
um so i think the question if i've got

1013
00:38:03,200 --> 00:38:05,040
it right is um

1014
00:38:05,040 --> 00:38:06,640
if there's other

1015
00:38:06,640 --> 00:38:08,880
ns keyed unarchiver attack services that

1016
00:38:08,880 --> 00:38:10,240
we looked at

1017
00:38:10,240 --> 00:38:12,800
besides imessage is that it yeah

1018
00:38:12,800 --> 00:38:14,560
so no not really

1019
00:38:14,560 --> 00:38:17,440
we this was focused on imessage um so we

1020
00:38:17,440 --> 00:38:20,079
only looked at the parts reachable

1021
00:38:20,079 --> 00:38:22,240
like from imessage uh but it is

1022
00:38:22,240 --> 00:38:23,920
absolutely correct this kit an archive

1023
00:38:23,920 --> 00:38:24,640
is

1024
00:38:24,640 --> 00:38:26,640
used heavily throughout

1025
00:38:26,640 --> 00:38:30,400
ios and mac as it's used for like in a

1026
00:38:30,400 --> 00:38:32,400
bit intra process communication and

1027
00:38:32,400 --> 00:38:34,240
inter process communication

1028
00:38:34,240 --> 00:38:35,119
um

1029
00:38:35,119 --> 00:38:37,680
and so there's there's definitely more

1030
00:38:37,680 --> 00:38:39,839
attack service here and also this

1031
00:38:39,839 --> 00:38:42,240
mitigation that i mentioned it seems to

1032
00:38:42,240 --> 00:38:45,440
currently only be used in uh in imessage

1033
00:38:45,440 --> 00:38:46,880
right and not in the other attack

1034
00:38:46,880 --> 00:38:49,119
surfaces maybe they will

1035
00:38:49,119 --> 00:38:50,240
uh

1036
00:38:50,240 --> 00:38:52,560
also apply it there but i

1037
00:38:52,560 --> 00:38:54,160
as far as i can tell it's so far only

1038
00:38:54,160 --> 00:38:56,560
there um so yeah the answer is no we

1039
00:38:56,560 --> 00:38:57,520
haven't

1040
00:38:57,520 --> 00:38:59,760
looked at any other users of this kia

1041
00:38:59,760 --> 00:39:02,079
archibald in that

1042
00:39:02,079 --> 00:39:04,800
okay cool well thank you if you have if

1043
00:39:04,800 --> 00:39:06,640
some more questions do come up feel free

1044
00:39:06,640 --> 00:39:09,520
to hit me up i'll be around

1045
00:39:09,520 --> 00:39:13,160
and thanks for listening

1046
00:39:13,690 --> 00:39:16,860
[Applause]

1047
00:39:22,400 --> 00:39:24,480
you

