1
00:00:04,480 --> 00:00:08,400
so we are going to wrap up the uh

2
00:00:08,400 --> 00:00:09,840
writing afternoon session with my talk

3
00:00:09,840 --> 00:00:12,320
and then one other from from andy um and

4
00:00:12,320 --> 00:00:14,639
so let's let's dive in so aloha and

5
00:00:14,639 --> 00:00:17,600
welcome to my talk so today i'm going to

6
00:00:17,600 --> 00:00:19,279
teach you how to analyze the

7
00:00:19,279 --> 00:00:22,880
anti-analysis logic of m1 malware and as

8
00:00:22,880 --> 00:00:24,240
we can see on the slide i'm roughly

9
00:00:24,240 --> 00:00:26,640
defining m1 malware and that's malicious

10
00:00:26,640 --> 00:00:28,320
code that's been compiled to run

11
00:00:28,320 --> 00:00:31,599
natively on apple's new m1 or arm 64

12
00:00:31,599 --> 00:00:32,960
systems

13
00:00:32,960 --> 00:00:33,840
first we're going to cover some

14
00:00:33,840 --> 00:00:36,239
introductory topics we'll talk about how

15
00:00:36,239 --> 00:00:40,399
to find m1 samples for analysis

16
00:00:40,399 --> 00:00:41,760
however you know once we find those

17
00:00:41,760 --> 00:00:44,000
analysis we will first have to have at

18
00:00:44,000 --> 00:00:46,399
least a foundational understanding of

19
00:00:46,399 --> 00:00:48,800
arm 64. so we'll dive into that and

20
00:00:48,800 --> 00:00:50,960
cover that as well and then once we've

21
00:00:50,960 --> 00:00:52,399
been armed

22
00:00:52,399 --> 00:00:54,640
with that foundational understanding of

23
00:00:54,640 --> 00:00:56,640
this instruction set we're going to dive

24
00:00:56,640 --> 00:00:58,879
into analyzing what was the first

25
00:00:58,879 --> 00:01:01,920
publicly discovered mac m1 malware

26
00:01:01,920 --> 00:01:04,319
sample specifically focusing on its

27
00:01:04,319 --> 00:01:06,640
anti-analysis logic

28
00:01:06,640 --> 00:01:09,760
so let's start with some introductory

29
00:01:09,760 --> 00:01:11,760
concepts some topics

30
00:01:11,760 --> 00:01:13,600
first this is kind of an obvious slide

31
00:01:13,600 --> 00:01:16,080
especially for all of us here it should

32
00:01:16,080 --> 00:01:18,640
be really no surprise that mac's become

33
00:01:18,640 --> 00:01:20,159
are becoming ever more prevalent

34
00:01:20,159 --> 00:01:22,479
especially in the context of the

35
00:01:22,479 --> 00:01:26,000
enterprise and equally unsurprising mac

36
00:01:26,000 --> 00:01:28,880
malware is becoming ever more popular

37
00:01:28,880 --> 00:01:31,600
prominent prevalent as well basically in

38
00:01:31,600 --> 00:01:34,880
lockstep with max growth

39
00:01:34,880 --> 00:01:36,799
now on the next slide we'll dive more

40
00:01:36,799 --> 00:01:39,680
into apple's new chip the m1 but it's

41
00:01:39,680 --> 00:01:41,600
worth pointing out that the argument can

42
00:01:41,600 --> 00:01:44,320
be made that it's really driving the

43
00:01:44,320 --> 00:01:46,640
increased adoption of max it's an

44
00:01:46,640 --> 00:01:49,119
incredible piece of hardware and home

45
00:01:49,119 --> 00:01:51,520
users and enterprise users are taking

46
00:01:51,520 --> 00:01:53,360
note and this point is clearly

47
00:01:53,360 --> 00:01:56,079
articulated by apple ceo as well that

48
00:01:56,079 --> 00:01:59,360
who notes that yes indeed this chip is

49
00:01:59,360 --> 00:02:02,159
driving the growth of the mac platform

50
00:02:02,159 --> 00:02:05,360
so what is m1 well it's also referred to

51
00:02:05,360 --> 00:02:08,479
as apple silicon it's an armed based

52
00:02:08,479 --> 00:02:11,520
system on a chip or a sock a sock simply

53
00:02:11,520 --> 00:02:13,920
means you have a single chip that has

54
00:02:13,920 --> 00:02:17,680
multiple technologies combined all on it

55
00:02:17,680 --> 00:02:20,720
so things like the gpu the cpu dram

56
00:02:20,720 --> 00:02:22,720
which traditionally were disparate parts

57
00:02:22,720 --> 00:02:24,720
now they've been all combined into one

58
00:02:24,720 --> 00:02:26,959
chip which is one of the reasons it's so

59
00:02:26,959 --> 00:02:28,560
efficient

60
00:02:28,560 --> 00:02:30,879
now in the context of this presentation

61
00:02:30,879 --> 00:02:33,760
this talk the most important factor is

62
00:02:33,760 --> 00:02:36,959
that binaries including malware compiled

63
00:02:36,959 --> 00:02:39,920
to run natively on this platform on the

64
00:02:39,920 --> 00:02:43,519
m1 cpu will disassemble into the arm

65
00:02:43,519 --> 00:02:46,160
instruction set versus perhaps the more

66
00:02:46,160 --> 00:02:50,000
familiar intel instruction set

67
00:02:50,000 --> 00:02:51,200
i also want to point out you know you

68
00:02:51,200 --> 00:02:52,959
might be having the question why why do

69
00:02:52,959 --> 00:02:55,040
we need to talk about m1 malware what's

70
00:02:55,040 --> 00:02:56,480
the purpose of this talk why should we

71
00:02:56,480 --> 00:02:59,280
even care well first m1 malware is

72
00:02:59,280 --> 00:03:02,080
inevitable obviously compiling something

73
00:03:02,080 --> 00:03:05,440
to run natively on a platform's cpu

74
00:03:05,440 --> 00:03:07,840
is a no-brainer native code is going to

75
00:03:07,840 --> 00:03:11,360
run faster yes apple has shipped the m1

76
00:03:11,360 --> 00:03:12,959
systems with rosetta which is a

77
00:03:12,959 --> 00:03:15,760
translation technology that can allow

78
00:03:15,760 --> 00:03:19,200
intel binaries to run on mac os systems

79
00:03:19,200 --> 00:03:22,319
even when with the m1 chip but rosetta

80
00:03:22,319 --> 00:03:24,239
has been prone to some

81
00:03:24,239 --> 00:03:25,840
some crashes and there's going to be

82
00:03:25,840 --> 00:03:27,840
some speed penalty

83
00:03:27,840 --> 00:03:29,920
also i did an interesting study where i

84
00:03:29,920 --> 00:03:32,400
took a malware sample that had been

85
00:03:32,400 --> 00:03:35,599
compiled both for intel and m1 or arm 64

86
00:03:35,599 --> 00:03:38,640
systems and uploaded them both to virus

87
00:03:38,640 --> 00:03:40,959
total and found that for the arm-based

88
00:03:40,959 --> 00:03:43,200
detections there was about a 10

89
00:03:43,200 --> 00:03:45,360
drop so this shows that some av

90
00:03:45,360 --> 00:03:49,200
companies have architecturally specific

91
00:03:49,200 --> 00:03:51,360
signatures so as security researchers

92
00:03:51,360 --> 00:03:53,760
this is something we should be aware of

93
00:03:53,760 --> 00:03:55,920
mainly though we need to talk about m1

94
00:03:55,920 --> 00:03:58,640
malware because it's armed based and i

95
00:03:58,640 --> 00:03:59,840
said that means it's going to

96
00:03:59,840 --> 00:04:02,480
disassemble into the arm instruction set

97
00:04:02,480 --> 00:04:04,959
and if we don't understand this newish

98
00:04:04,959 --> 00:04:06,480
instruction set we're not going to be

99
00:04:06,480 --> 00:04:09,120
able to comprehensively analyze these

100
00:04:09,120 --> 00:04:11,519
samples

101
00:04:11,519 --> 00:04:14,000
first though we need to talk about what

102
00:04:14,000 --> 00:04:17,440
an m1 binary is what it looks for how we

103
00:04:17,440 --> 00:04:20,079
can find samples to analyze

104
00:04:20,079 --> 00:04:22,320
turns out it's really not that hard to

105
00:04:22,320 --> 00:04:24,320
detect first it's going to contain arm

106
00:04:24,320 --> 00:04:27,040
64 code obviously

107
00:04:27,040 --> 00:04:29,199
and until m1

108
00:04:29,199 --> 00:04:32,880
is the dominant hardware the majority of

109
00:04:32,880 --> 00:04:35,040
binaries that support m1 code natively

110
00:04:35,040 --> 00:04:37,040
are going to be distributed as universal

111
00:04:37,040 --> 00:04:38,639
binaries you know

112
00:04:38,639 --> 00:04:40,479
universal binaries are simply binaries

113
00:04:40,479 --> 00:04:42,800
that contain multiple architectures so

114
00:04:42,800 --> 00:04:45,680
for example intel and arm basically what

115
00:04:45,680 --> 00:04:48,400
the compiler the linker does is compile

116
00:04:48,400 --> 00:04:50,800
both architectures and then concatenates

117
00:04:50,800 --> 00:04:53,120
both binaries into one file when the

118
00:04:53,120 --> 00:04:55,040
user or when that binary is then

119
00:04:55,040 --> 00:04:57,759
launched on a system the dynamic loader

120
00:04:57,759 --> 00:05:00,720
dyld decides which is the correct

121
00:05:00,720 --> 00:05:02,479
architecture so on an intel system the

122
00:05:02,479 --> 00:05:05,520
intel binary will run on the arm 64 m1

123
00:05:05,520 --> 00:05:08,240
system that one will execute

124
00:05:08,240 --> 00:05:11,120
also we can check the mock o header to

125
00:05:11,120 --> 00:05:13,039
see that indeed these binaries have been

126
00:05:13,039 --> 00:05:15,520
compiled to run on mac os this is

127
00:05:15,520 --> 00:05:18,000
important because ios also supports arm

128
00:05:18,000 --> 00:05:20,240
64. and in this presentation we're

129
00:05:20,240 --> 00:05:24,400
merely interested in m1 malware

130
00:05:24,400 --> 00:05:25,120
so

131
00:05:25,120 --> 00:05:26,560
once i kind of gained an understanding

132
00:05:26,560 --> 00:05:28,800
of what an m1 binary would look for i

133
00:05:28,800 --> 00:05:30,639
decided to go hunting i don't have

134
00:05:30,639 --> 00:05:33,440
access to customer data so really the

135
00:05:33,440 --> 00:05:35,440
only option i have as an independent

136
00:05:35,440 --> 00:05:37,759
security researcher is virustotal and

137
00:05:37,759 --> 00:05:40,160
virustotal really has done a great job

138
00:05:40,160 --> 00:05:42,400
yes collecting a corpus of files but

139
00:05:42,400 --> 00:05:44,479
also making available researchers

140
00:05:44,479 --> 00:05:45,759
account

141
00:05:45,759 --> 00:05:48,320
so here's the search query i used my

142
00:05:48,320 --> 00:05:51,120
goal was to find m1 malware we can see

143
00:05:51,120 --> 00:05:53,600
based on the tags the types i'm looking

144
00:05:53,600 --> 00:05:57,360
for a mock o binary i'm saying type arm

145
00:05:57,360 --> 00:06:00,720
64-bit i'm saying multi-architecture

146
00:06:00,720 --> 00:06:02,400
basically looking for these universal

147
00:06:02,400 --> 00:06:03,600
binaries

148
00:06:03,600 --> 00:06:06,400
using the engine flag saying not ios i'm

149
00:06:06,400 --> 00:06:08,319
only interested in mac binaries and

150
00:06:08,319 --> 00:06:10,479
finally i'm looking for binaries that

151
00:06:10,479 --> 00:06:11,840
have already been flagged by at least

152
00:06:11,840 --> 00:06:14,720
two antivirus products the idea was yes

153
00:06:14,720 --> 00:06:17,280
i might miss some brand new malware but

154
00:06:17,280 --> 00:06:19,199
as we mentioned both malware

155
00:06:19,199 --> 00:06:21,520
malware authors are most likely going to

156
00:06:21,520 --> 00:06:23,840
compile their existing intel malware

157
00:06:23,840 --> 00:06:26,400
into m1 binaries and ship them as

158
00:06:26,400 --> 00:06:28,639
universal binaries so i figured that

159
00:06:28,639 --> 00:06:31,199
existing av signatures would likely flag

160
00:06:31,199 --> 00:06:33,199
that

161
00:06:33,199 --> 00:06:34,880
so i ran the search earlier this year

162
00:06:34,880 --> 00:06:36,319
and it turned up

163
00:06:36,319 --> 00:06:38,319
just a single candidate binary something

164
00:06:38,319 --> 00:06:41,360
named go search 22. as we can see on the

165
00:06:41,360 --> 00:06:44,080
slide it's a universal binary it has

166
00:06:44,080 --> 00:06:46,720
binaries for both arm and intel base

167
00:06:46,720 --> 00:06:49,199
code unsurprising the malware authors

168
00:06:49,199 --> 00:06:50,240
wanted to make sure it could run

169
00:06:50,240 --> 00:06:52,560
natively on both platforms

170
00:06:52,560 --> 00:06:54,960
we can also see that looking at the

171
00:06:54,960 --> 00:06:56,800
the load commands we that it's been

172
00:06:56,800 --> 00:06:58,800
designed specifically to run on mac os

173
00:06:58,800 --> 00:07:01,599
so we now know we have an m1 binary

174
00:07:01,599 --> 00:07:03,199
interestingly enough apple had already

175
00:07:03,199 --> 00:07:05,039
revoked the certificate for this and

176
00:07:05,039 --> 00:07:06,800
some antivirus

177
00:07:06,800 --> 00:07:09,120
engines were already flagging it as as

178
00:07:09,120 --> 00:07:11,599
malware likely on the intel base code

179
00:07:11,599 --> 00:07:13,520
so clearly it's a shady binary and

180
00:07:13,520 --> 00:07:16,160
continued analysis confirmed it was a

181
00:07:16,160 --> 00:07:18,479
variant of the highly pro prolific

182
00:07:18,479 --> 00:07:21,360
parrot malware family

183
00:07:21,360 --> 00:07:22,880
rather awesomely and this is somewhat

184
00:07:22,880 --> 00:07:25,280
tangential i wanted to see how or why

185
00:07:25,280 --> 00:07:27,680
this was submitted to virus total and

186
00:07:27,680 --> 00:07:30,000
based on the api information the

187
00:07:30,000 --> 00:07:32,240
metadata i could see it was submitted to

188
00:07:32,240 --> 00:07:34,400
virus total by a user running one of my

189
00:07:34,400 --> 00:07:36,160
tools knock knock

190
00:07:36,160 --> 00:07:37,919
so knock knock simply enumerates

191
00:07:37,919 --> 00:07:39,840
persistent software that's installed on

192
00:07:39,840 --> 00:07:41,840
the system it integrates with virus

193
00:07:41,840 --> 00:07:44,160
total meaning users can submit for

194
00:07:44,160 --> 00:07:46,479
example files they don't recognize so

195
00:07:46,479 --> 00:07:48,479
what happened was in the last year our

196
00:07:48,479 --> 00:07:50,720
user ran this tool came across this

197
00:07:50,720 --> 00:07:52,800
persistent binary didn't recognize it

198
00:07:52,800 --> 00:07:54,960
and submitted it to virustotal then when

199
00:07:54,960 --> 00:07:57,759
i did my search in january or february i

200
00:07:57,759 --> 00:08:01,360
stumbled across it as well kind of neat

201
00:08:01,360 --> 00:08:03,919
it's also worth pointing out that as

202
00:08:03,919 --> 00:08:07,120
expected since this initial discovery m1

203
00:08:07,120 --> 00:08:09,759
malware continues to abound continues to

204
00:08:09,759 --> 00:08:12,479
proliferate and unfortunately we have

205
00:08:12,479 --> 00:08:15,199
cases where apple has in some cases

206
00:08:15,199 --> 00:08:17,599
inadvertently notarized these samples as

207
00:08:17,599 --> 00:08:20,319
well so it's definitely becoming more of

208
00:08:20,319 --> 00:08:23,039
a problem and as is always the case we

209
00:08:23,039 --> 00:08:25,039
can't fully rely on apple's built-in

210
00:08:25,039 --> 00:08:27,280
security mechanisms

211
00:08:27,280 --> 00:08:29,840
so hooray we found what appears to be

212
00:08:29,840 --> 00:08:32,479
the first instance of m1 malware in the

213
00:08:32,479 --> 00:08:35,599
wild however before we can dive into it

214
00:08:35,599 --> 00:08:37,599
and analyze it we have to gain at least

215
00:08:37,599 --> 00:08:40,159
a foundational understanding of the arm

216
00:08:40,159 --> 00:08:43,039
64 instruction set as this is what this

217
00:08:43,039 --> 00:08:45,440
malware will disassemble into it good

218
00:08:45,440 --> 00:08:46,880
news though we don't have to become

219
00:08:46,880 --> 00:08:49,120
experts once we have some basic

220
00:08:49,120 --> 00:08:50,959
understanding we'll see that this gets

221
00:08:50,959 --> 00:08:54,080
us pretty much as far as we need to go

222
00:08:54,080 --> 00:08:55,839
so i'm going to dive into some reverse

223
00:08:55,839 --> 00:08:58,959
engineering context concepts specific to

224
00:08:58,959 --> 00:09:01,760
some that are specific to arm 64. so

225
00:09:01,760 --> 00:09:03,920
first up let's talk about registers if

226
00:09:03,920 --> 00:09:05,519
you do any reverse engineering you're

227
00:09:05,519 --> 00:09:07,360
well aware that they are essentially

228
00:09:07,360 --> 00:09:10,000
name slots on the cpu i kind of like to

229
00:09:10,000 --> 00:09:12,399
think of them as variables

230
00:09:12,399 --> 00:09:16,560
so arm 64 has 31 64-bit general purpose

231
00:09:16,560 --> 00:09:19,839
registers uncreatively named x0 through

232
00:09:19,839 --> 00:09:21,440
x30

233
00:09:21,440 --> 00:09:25,120
if you want to refer to the lower 32-bit

234
00:09:25,120 --> 00:09:27,760
component of these registers you use the

235
00:09:27,760 --> 00:09:31,200
w prefix so for example w0 refers to the

236
00:09:31,200 --> 00:09:35,200
lower 32 bits of the x0 register

237
00:09:35,200 --> 00:09:37,279
there's also a few dedicated registers

238
00:09:37,279 --> 00:09:39,040
that are worth noting

239
00:09:39,040 --> 00:09:42,480
for example sp is the stack pointer pc

240
00:09:42,480 --> 00:09:44,000
is the program counter or the

241
00:09:44,000 --> 00:09:46,000
instruction pointer and then finally

242
00:09:46,000 --> 00:09:48,240
there's a dedicated virtual register

243
00:09:48,240 --> 00:09:52,160
known as xzr which is always set to zero

244
00:09:52,160 --> 00:09:53,440
there's also some floating point

245
00:09:53,440 --> 00:09:55,279
registers but in the context of malware

246
00:09:55,279 --> 00:09:57,600
analysis those aren't really relevant

247
00:09:57,600 --> 00:10:00,640
and finally we have the p p state entity

248
00:10:00,640 --> 00:10:02,800
which holds condition flags we'll talk

249
00:10:02,800 --> 00:10:05,920
about this more shortly

250
00:10:05,920 --> 00:10:08,240
now during malware analysis you don't

251
00:10:08,240 --> 00:10:10,480
have to understand each and every

252
00:10:10,480 --> 00:10:12,000
assembly instruction right that's just

253
00:10:12,000 --> 00:10:13,440
going to take way too long and that's

254
00:10:13,440 --> 00:10:15,760
often overkill so what you can normally

255
00:10:15,760 --> 00:10:19,600
do is just study the code around api

256
00:10:19,600 --> 00:10:22,160
calls because often this will answer the

257
00:10:22,160 --> 00:10:24,240
questions you seek as a malware analyst

258
00:10:24,240 --> 00:10:25,839
for example you probably want to know

259
00:10:25,839 --> 00:10:27,200
does the malware talk to a command and

260
00:10:27,200 --> 00:10:29,680
control server so you can find the code

261
00:10:29,680 --> 00:10:32,480
that invokes various networking apis and

262
00:10:32,480 --> 00:10:34,160
then look at the values of those

263
00:10:34,160 --> 00:10:36,480
arguments right is it initializing a url

264
00:10:36,480 --> 00:10:38,640
with an embedded hard-coded address of a

265
00:10:38,640 --> 00:10:40,959
command and control server if so hooray

266
00:10:40,959 --> 00:10:42,880
you've just uncovered its command and

267
00:10:42,880 --> 00:10:44,640
control server

268
00:10:44,640 --> 00:10:46,480
so when reverse engineering code there

269
00:10:46,480 --> 00:10:49,760
are specific rules or a protocol that

270
00:10:49,760 --> 00:10:52,399
dictate how arguments are used in the

271
00:10:52,399 --> 00:10:54,959
context of a function or method call

272
00:10:54,959 --> 00:10:56,640
this is articulated in something known

273
00:10:56,640 --> 00:10:59,360
as the abi or the application binary

274
00:10:59,360 --> 00:11:01,040
interface

275
00:11:01,040 --> 00:11:03,040
so knowing these rules helps us for

276
00:11:03,040 --> 00:11:05,360
example to know exactly which arguments

277
00:11:05,360 --> 00:11:08,160
can be found in which registers

278
00:11:08,160 --> 00:11:11,120
in arm 64 the abi dictates that the

279
00:11:11,120 --> 00:11:13,360
first eight arguments will be passed in

280
00:11:13,360 --> 00:11:16,399
registers x0 through x7 if you're coming

281
00:11:16,399 --> 00:11:18,399
from intel this is kind of nice because

282
00:11:18,399 --> 00:11:20,240
in intel the registers are kind of

283
00:11:20,240 --> 00:11:21,839
random right it's like

284
00:11:21,839 --> 00:11:25,839
rdi rsi rdx rcx r8r9 like i have to

285
00:11:25,839 --> 00:11:27,360
write this down because i rarely

286
00:11:27,360 --> 00:11:30,480
remember it arm is just x0 through x7

287
00:11:30,480 --> 00:11:31,920
it's awesome

288
00:11:31,920 --> 00:11:34,240
before entering a function the return

289
00:11:34,240 --> 00:11:36,079
address which is where the cpu will

290
00:11:36,079 --> 00:11:38,320
return to after the function call is

291
00:11:38,320 --> 00:11:41,600
stored in x30 which is also known as the

292
00:11:41,600 --> 00:11:43,440
link register

293
00:11:43,440 --> 00:11:46,560
inside the function the x29 is used as

294
00:11:46,560 --> 00:11:49,120
the frame register or fp

295
00:11:49,120 --> 00:11:50,720
and then finally when the function

296
00:11:50,720 --> 00:11:53,839
returns the result of the function or

297
00:11:53,839 --> 00:11:56,160
method is going to be found in the x0

298
00:11:56,160 --> 00:12:00,160
register unless it's returning a 120 128

299
00:12:00,160 --> 00:12:02,240
bit value it will then use the x1

300
00:12:02,240 --> 00:12:04,560
register as well

301
00:12:04,560 --> 00:12:07,360
all right now on to some arm 64 assembly

302
00:12:07,360 --> 00:12:08,639
instructions

303
00:12:08,639 --> 00:12:12,639
instructions instruct the cpu what to do

304
00:12:12,639 --> 00:12:14,480
instructions start with something we

305
00:12:14,480 --> 00:12:17,600
refer to as a mnemonic which is just a

306
00:12:17,600 --> 00:12:20,079
human readable abbreviation that

307
00:12:20,079 --> 00:12:22,639
articulates what the instruction does so

308
00:12:22,639 --> 00:12:25,839
for example the ad pneumonic is for the

309
00:12:25,839 --> 00:12:28,079
edition instruction really not rocket

310
00:12:28,079 --> 00:12:30,399
scientist

311
00:12:30,399 --> 00:12:32,639
the remaining part of the instruction is

312
00:12:32,639 --> 00:12:35,519
made up of operands and of the operands

313
00:12:35,519 --> 00:12:38,880
there are well three types first up we

314
00:12:38,880 --> 00:12:40,959
have the immediate operand which is

315
00:12:40,959 --> 00:12:44,480
simply a constant something like 42.

316
00:12:44,480 --> 00:12:46,959
a register operand is simply

317
00:12:46,959 --> 00:12:48,880
one of the registers we mentioned for

318
00:12:48,880 --> 00:12:51,360
example x1 x0

319
00:12:51,360 --> 00:12:53,120
and then finally you can also have a

320
00:12:53,120 --> 00:12:56,240
memory operand which is a register value

321
00:12:56,240 --> 00:12:58,560
that points to a memory location so it's

322
00:12:58,560 --> 00:13:00,639
really just a pointer

323
00:13:00,639 --> 00:13:03,200
one thing to note that almost always the

324
00:13:03,200 --> 00:13:05,680
first operand is the destination

325
00:13:05,680 --> 00:13:07,680
register so for example in this

326
00:13:07,680 --> 00:13:09,519
instruction we can see there's an

327
00:13:09,519 --> 00:13:12,079
addition being performed the result of

328
00:13:12,079 --> 00:13:12,800
the

329
00:13:12,800 --> 00:13:15,040
addition is going to be stored in x1 so

330
00:13:15,040 --> 00:13:17,839
it's going to take 42 add it to x0 and

331
00:13:17,839 --> 00:13:19,680
then store it in x1 so you can kind of

332
00:13:19,680 --> 00:13:23,279
read it you know from right to left

333
00:13:23,279 --> 00:13:25,920
we also need to talk about arm's memory

334
00:13:25,920 --> 00:13:28,880
access model because unlike intel arm

335
00:13:28,880 --> 00:13:31,120
separates instructions into those that

336
00:13:31,120 --> 00:13:33,760
can access memory and those that cannot

337
00:13:33,760 --> 00:13:36,000
on intel most instructions can directly

338
00:13:36,000 --> 00:13:38,800
access memory so what happens on arm is

339
00:13:38,800 --> 00:13:40,959
you see an instruction that will load a

340
00:13:40,959 --> 00:13:43,120
value from memory into one of the

341
00:13:43,120 --> 00:13:45,199
general purpose registers

342
00:13:45,199 --> 00:13:47,360
some operations are then performed on

343
00:13:47,360 --> 00:13:49,760
that data in the registered and then

344
00:13:49,760 --> 00:13:51,360
when the program wants to store it back

345
00:13:51,360 --> 00:13:53,440
into memory it executes a dedicated

346
00:13:53,440 --> 00:13:55,600
instruction to do this this is referred

347
00:13:55,600 --> 00:13:58,720
to as a load and store architecture and

348
00:13:58,720 --> 00:14:01,360
this is what again arm uses

349
00:14:01,360 --> 00:14:02,800
let's look a little closer at this

350
00:14:02,800 --> 00:14:04,399
because when reversing malware you'll

351
00:14:04,399 --> 00:14:06,880
see these instructions used a lot

352
00:14:06,880 --> 00:14:10,079
so to load something into memory arm64

353
00:14:10,079 --> 00:14:12,639
makes use of the ldr instruction or one

354
00:14:12,639 --> 00:14:14,240
of its variants

355
00:14:14,240 --> 00:14:16,240
take a look at the example on the slide

356
00:14:16,240 --> 00:14:19,040
as normal the first operand in this case

357
00:14:19,040 --> 00:14:21,600
the x1 register is the destination

358
00:14:21,600 --> 00:14:25,199
register the source register is x0

359
00:14:25,199 --> 00:14:27,600
brackets around it indicated that it's a

360
00:14:27,600 --> 00:14:30,160
memory operand which tells the cpu that

361
00:14:30,160 --> 00:14:32,480
it should dereference that value

362
00:14:32,480 --> 00:14:34,800
and then go there in memory

363
00:14:34,800 --> 00:14:36,480
so with this understanding we know that

364
00:14:36,480 --> 00:14:38,800
this instruction is loading the value

365
00:14:38,800 --> 00:14:41,920
stored in the memory address found in x0

366
00:14:41,920 --> 00:14:44,399
into the x1 register we have the

367
00:14:44,399 --> 00:14:46,160
analogous c statement as well if you're

368
00:14:46,160 --> 00:14:47,839
more comfortable reading something like

369
00:14:47,839 --> 00:14:49,920
c

370
00:14:49,920 --> 00:14:52,399
on the other hand the str or store

371
00:14:52,399 --> 00:14:54,240
instruction will store a value from a

372
00:14:54,240 --> 00:14:56,720
register into memory this instruction is

373
00:14:56,720 --> 00:14:57,680
somewhat

374
00:14:57,680 --> 00:14:59,839
different in the sense that the first

375
00:14:59,839 --> 00:15:02,240
operand is actually the source register

376
00:15:02,240 --> 00:15:04,160
while the second is the destination so

377
00:15:04,160 --> 00:15:05,760
this one you kind of read from left to

378
00:15:05,760 --> 00:15:07,920
right right so it's going to take x1 and

379
00:15:07,920 --> 00:15:11,760
store it into x 0.

380
00:15:11,760 --> 00:15:13,760
now let's look at comparisons you

381
00:15:13,760 --> 00:15:15,440
encounter comparisons a lot especially

382
00:15:15,440 --> 00:15:17,279
when analyzing malware it will

383
00:15:17,279 --> 00:15:19,440
oftentimes do something like query its

384
00:15:19,440 --> 00:15:21,920
environment and then make a comparison

385
00:15:21,920 --> 00:15:24,720
to determine what of two alternate code

386
00:15:24,720 --> 00:15:27,120
paths it should take

387
00:15:27,120 --> 00:15:28,880
here we have the comparison instruction

388
00:15:28,880 --> 00:15:31,600
that compares two operands and then

389
00:15:31,600 --> 00:15:35,600
updates the flag in the p state entity

390
00:15:35,600 --> 00:15:38,000
once these condition flags have been set

391
00:15:38,000 --> 00:15:40,320
for example via the cmp or comparison

392
00:15:40,320 --> 00:15:43,360
instruction subsequent instructions will

393
00:15:43,360 --> 00:15:45,519
then act on these flags using something

394
00:15:45,519 --> 00:15:47,839
called condition codes these codes can

395
00:15:47,839 --> 00:15:50,399
include things like equal not equal less

396
00:15:50,399 --> 00:15:53,120
than greater etc etc so let's take a

397
00:15:53,120 --> 00:15:55,519
closer look at the example on the slide

398
00:15:55,519 --> 00:15:57,920
which contains anti-debugging logic

399
00:15:57,920 --> 00:16:00,720
extracted from a malicious sample

400
00:16:00,720 --> 00:16:03,040
the logic will cause the malware to exit

401
00:16:03,040 --> 00:16:05,199
prematurely if it detects a debugger

402
00:16:05,199 --> 00:16:06,560
basically the malware says i don't want

403
00:16:06,560 --> 00:16:08,399
to keep running if someone like patrick

404
00:16:08,399 --> 00:16:10,160
is debugging me

405
00:16:10,160 --> 00:16:12,000
first we can see there's a compare

406
00:16:12,000 --> 00:16:14,320
instruction checking the return value of

407
00:16:14,320 --> 00:16:17,440
a function named am i being debugged

408
00:16:17,440 --> 00:16:20,079
if the function returns a 1 or a true

409
00:16:20,079 --> 00:16:22,639
meaning the malware is being debugged

410
00:16:22,639 --> 00:16:25,440
the zero flag will be set when the

411
00:16:25,440 --> 00:16:29,040
compare instruction compare w01 is

412
00:16:29,040 --> 00:16:31,199
executed and again remember that the

413
00:16:31,199 --> 00:16:32,880
return value from a function can be

414
00:16:32,880 --> 00:16:36,000
found in x0 or it's lower 32-bit

415
00:16:36,000 --> 00:16:38,240
components w 0.

416
00:16:38,240 --> 00:16:40,560
the next junction extruction we see is a

417
00:16:40,560 --> 00:16:43,519
b-n-e this is a branch not equal

418
00:16:43,519 --> 00:16:45,199
this will skip over the early

419
00:16:45,199 --> 00:16:48,320
termination if and only if the zero flag

420
00:16:48,320 --> 00:16:50,399
wasn't set meaning the function

421
00:16:50,399 --> 00:16:52,560
didn't return one meaning the malware

422
00:16:52,560 --> 00:16:55,519
isn't being debugged otherwise it will

423
00:16:55,519 --> 00:16:58,000
exit and thwart our continued analysis

424
00:16:58,000 --> 00:16:59,199
efforts

425
00:16:59,199 --> 00:17:01,279
and speaking of branching let's take a

426
00:17:01,279 --> 00:17:04,160
closer look at some branch instructions

427
00:17:04,160 --> 00:17:06,799
and variations first noting that branch

428
00:17:06,799 --> 00:17:09,199
instructions are how

429
00:17:09,199 --> 00:17:12,640
arm 64 alters the control of the control

430
00:17:12,640 --> 00:17:14,559
of a program

431
00:17:14,559 --> 00:17:17,520
first we have a b or a br instruction

432
00:17:17,520 --> 00:17:19,839
this is synonymous essentially to a jump

433
00:17:19,839 --> 00:17:22,240
instruction in on the intel platform

434
00:17:22,240 --> 00:17:24,240
give it an address or a register it will

435
00:17:24,240 --> 00:17:25,839
unconditionally jump to that and

436
00:17:25,839 --> 00:17:28,559
continue code execution there

437
00:17:28,559 --> 00:17:30,880
on the last slide we talked about

438
00:17:30,880 --> 00:17:32,559
conditional branch instructions these

439
00:17:32,559 --> 00:17:34,720
are the next type of branch instructions

440
00:17:34,720 --> 00:17:36,960
these will only branch if the condition

441
00:17:36,960 --> 00:17:39,280
is met if the condition is not met it's

442
00:17:39,280 --> 00:17:42,240
essentially a no op and do nothing and

443
00:17:42,240 --> 00:17:44,320
program control will just continue

444
00:17:44,320 --> 00:17:46,000
sequentially

445
00:17:46,000 --> 00:17:49,039
finally we have the bl or blr which is

446
00:17:49,039 --> 00:17:51,280
the branch and link or branch and link

447
00:17:51,280 --> 00:17:53,120
register instruction

448
00:17:53,120 --> 00:17:55,280
and what this first does is stores the

449
00:17:55,280 --> 00:17:57,440
address of the next instruction in the

450
00:17:57,440 --> 00:18:00,000
x30 register which recall is the link

451
00:18:00,000 --> 00:18:02,720
register then it will branch

452
00:18:02,720 --> 00:18:04,799
then when a return instruction is

453
00:18:04,799 --> 00:18:07,280
encountered this will read the value out

454
00:18:07,280 --> 00:18:09,840
of the x30 register and jump back to

455
00:18:09,840 --> 00:18:12,000
that so this is how

456
00:18:12,000 --> 00:18:16,640
arm 64 performs function or method calls

457
00:18:16,640 --> 00:18:18,000
all right so now let's put this into

458
00:18:18,000 --> 00:18:19,280
action and what we're going to do is

459
00:18:19,280 --> 00:18:21,200
we're going to reverse engineer apple's

460
00:18:21,200 --> 00:18:23,679
hello world code if you open xcode and

461
00:18:23,679 --> 00:18:25,919
create a new objective-c project this is

462
00:18:25,919 --> 00:18:28,799
the code that will be generated

463
00:18:28,799 --> 00:18:30,480
on the slide we can see the objective-c

464
00:18:30,480 --> 00:18:32,720
code and on the other side what it looks

465
00:18:32,720 --> 00:18:35,200
like once we disassemble it the arm 64

466
00:18:35,200 --> 00:18:36,320
instructions

467
00:18:36,320 --> 00:18:38,000
one point to know that during the

468
00:18:38,000 --> 00:18:39,200
compilation

469
00:18:39,200 --> 00:18:41,679
process the auto release memory block is

470
00:18:41,679 --> 00:18:44,160
compiled into a call to pool push and

471
00:18:44,160 --> 00:18:46,559
pool pop

472
00:18:46,559 --> 00:18:48,000
so first

473
00:18:48,000 --> 00:18:50,080
at looking at the disassembly we have

474
00:18:50,080 --> 00:18:52,080
the function prolog

475
00:18:52,080 --> 00:18:53,679
generally when analyzing malware you

476
00:18:53,679 --> 00:18:55,360
don't have to worry too much about the

477
00:18:55,360 --> 00:18:57,360
function prologue it simply does things

478
00:18:57,360 --> 00:19:00,559
like make space on the stack for local

479
00:19:00,559 --> 00:19:02,960
variables store registers that need to

480
00:19:02,960 --> 00:19:04,799
be preserved function across a function

481
00:19:04,799 --> 00:19:07,280
call etc etc so we're not going to spend

482
00:19:07,280 --> 00:19:08,799
too much time there

483
00:19:08,799 --> 00:19:10,960
continuing on though we see a call to

484
00:19:10,960 --> 00:19:13,760
the pool push function via the bl

485
00:19:13,760 --> 00:19:15,840
instruction which recall is the branch

486
00:19:15,840 --> 00:19:17,280
and link instruction which is the

487
00:19:17,280 --> 00:19:19,280
instruction to make a function or method

488
00:19:19,280 --> 00:19:20,480
call

489
00:19:20,480 --> 00:19:22,240
remember this function will first store

490
00:19:22,240 --> 00:19:24,640
the address of the very next instruction

491
00:19:24,640 --> 00:19:26,720
so when the function executes a return

492
00:19:26,720 --> 00:19:28,720
program control can continue in the

493
00:19:28,720 --> 00:19:30,559
correct place

494
00:19:30,559 --> 00:19:32,880
now if we read apple's documentation on

495
00:19:32,880 --> 00:19:35,120
this pool push function we can see it

496
00:19:35,120 --> 00:19:38,160
returns a pool object that a later time

497
00:19:38,160 --> 00:19:40,320
must be freed this means the program's

498
00:19:40,320 --> 00:19:43,039
got to store that so if we look a few

499
00:19:43,039 --> 00:19:45,520
instructions down we can see this return

500
00:19:45,520 --> 00:19:47,600
value which recall is going to be in the

501
00:19:47,600 --> 00:19:51,440
x0 register is stored on the stack via

502
00:19:51,440 --> 00:19:53,440
the str instruction which we talked

503
00:19:53,440 --> 00:19:54,799
about earlier

504
00:19:54,799 --> 00:19:56,880
so basically the function is storing

505
00:19:56,880 --> 00:19:59,280
this locally so at a later time it can

506
00:19:59,280 --> 00:20:02,400
re-access it and free it

507
00:20:02,400 --> 00:20:04,559
next up we have the nslog function this

508
00:20:04,559 --> 00:20:06,320
is how you print out something in

509
00:20:06,320 --> 00:20:08,720
objective c again it's invoked via the

510
00:20:08,720 --> 00:20:11,200
bl instruction branch and link and it's

511
00:20:11,200 --> 00:20:13,520
going to print out the hello world

512
00:20:13,520 --> 00:20:14,559
string

513
00:20:14,559 --> 00:20:17,039
now the nslog function takes a parameter

514
00:20:17,039 --> 00:20:19,919
specifically the string to print out and

515
00:20:19,919 --> 00:20:22,559
recall that according to the abi certain

516
00:20:22,559 --> 00:20:24,799
registers have to be initialized with

517
00:20:24,799 --> 00:20:27,039
parameters in the correct order so for a

518
00:20:27,039 --> 00:20:29,520
function that takes one parameter the x

519
00:20:29,520 --> 00:20:31,840
zero register has to be initialized with

520
00:20:31,840 --> 00:20:33,919
this parameter so if we look at the

521
00:20:33,919 --> 00:20:36,720
disassembly we can see x1 being initial

522
00:20:36,720 --> 00:20:39,440
sorry x0 being initialized with the

523
00:20:39,440 --> 00:20:41,760
address of the string to print

524
00:20:41,760 --> 00:20:43,919
the ns log function is then called it

525
00:20:43,919 --> 00:20:46,400
reads the x0 register and prints out our

526
00:20:46,400 --> 00:20:48,400
string

527
00:20:48,400 --> 00:20:50,640
the code now leaves the auto release

528
00:20:50,640 --> 00:20:54,240
pool via a call to the pool pop function

529
00:20:54,240 --> 00:20:55,679
if we read the documentation about this

530
00:20:55,679 --> 00:20:59,440
it expects a pool object to free recall

531
00:20:59,440 --> 00:21:01,679
that this was returned and stored

532
00:21:01,679 --> 00:21:04,240
previously so we can see the disassembly

533
00:21:04,240 --> 00:21:06,960
using the ldr instruction to load the

534
00:21:06,960 --> 00:21:09,840
store stored pool object off the stack

535
00:21:09,840 --> 00:21:12,559
into the x0 register again x0 is where

536
00:21:12,559 --> 00:21:14,559
the first argument is expected it then

537
00:21:14,559 --> 00:21:17,200
makes the function call to free the pool

538
00:21:17,200 --> 00:21:18,640
object

539
00:21:18,640 --> 00:21:21,280
finally we have the function epilog

540
00:21:21,280 --> 00:21:22,559
again in the context of the malware

541
00:21:22,559 --> 00:21:24,240
analysis we don't spend too much time

542
00:21:24,240 --> 00:21:26,960
here basically readjusts the stack

543
00:21:26,960 --> 00:21:29,039
initializes a return value and then

544
00:21:29,039 --> 00:21:31,679
executes the return struction to return

545
00:21:31,679 --> 00:21:34,159
back to the caller

546
00:21:34,159 --> 00:21:36,400
now the good news is

547
00:21:36,400 --> 00:21:38,400
normally we don't have to dive that

548
00:21:38,400 --> 00:21:40,960
deeply into disassembly to under and

549
00:21:40,960 --> 00:21:42,320
understand that many assembly

550
00:21:42,320 --> 00:21:44,880
instructions for two reasons decompilers

551
00:21:44,880 --> 00:21:47,120
now do a pretty good job of taking

552
00:21:47,120 --> 00:21:48,799
disassembled instructions and

553
00:21:48,799 --> 00:21:52,240
reconstructing the logic back into a

554
00:21:52,240 --> 00:21:54,080
representation of higher level language

555
00:21:54,080 --> 00:21:56,559
for example c or objective c so on the

556
00:21:56,559 --> 00:21:58,880
slide we can see i took the decompiled

557
00:21:58,880 --> 00:22:00,559
disassembled code and ran it through a

558
00:22:00,559 --> 00:22:03,039
decompiler and it produced fairly

559
00:22:03,039 --> 00:22:05,760
readable objective-c code a lot more

560
00:22:05,760 --> 00:22:07,760
succinct and probably easier to read

561
00:22:07,760 --> 00:22:09,360
than the arm

562
00:22:09,360 --> 00:22:11,679
64 disassembled instructions

563
00:22:11,679 --> 00:22:12,640
also

564
00:22:12,640 --> 00:22:14,159
if you're doing malware analysis a lot

565
00:22:14,159 --> 00:22:15,679
of times you can lean on dynamic

566
00:22:15,679 --> 00:22:17,440
analysis tools such as file monitors

567
00:22:17,440 --> 00:22:19,760
process monitors and debuggers and those

568
00:22:19,760 --> 00:22:22,000
don't necessarily need to

569
00:22:22,000 --> 00:22:24,000
you don't necessarily have to have that

570
00:22:24,000 --> 00:22:26,080
deep of an understanding especially a

571
00:22:26,080 --> 00:22:27,840
process monitor a file monitor

572
00:22:27,840 --> 00:22:29,760
oftentimes you can simply run a malware

573
00:22:29,760 --> 00:22:32,320
sample and via these monitors ascertain

574
00:22:32,320 --> 00:22:35,919
exactly what it does passively

575
00:22:35,919 --> 00:22:38,240
all right so let's now dive into some

576
00:22:38,240 --> 00:22:41,039
anti-analysis logic i just told you that

577
00:22:41,039 --> 00:22:43,039
you often don't really need to

578
00:22:43,039 --> 00:22:45,360
understand arm 64 or dive into

579
00:22:45,360 --> 00:22:47,440
disassembly that deeply

580
00:22:47,440 --> 00:22:49,360
the one time you have to unfortunately

581
00:22:49,360 --> 00:22:52,159
is when malware leverages anti-analysis

582
00:22:52,159 --> 00:22:55,840
logic malware authors realize the power

583
00:22:55,840 --> 00:22:58,720
of both decompilers and dynamic analysis

584
00:22:58,720 --> 00:23:00,880
tools so what they do is they implement

585
00:23:00,880 --> 00:23:03,600
anti-analysis logic to directly thwart

586
00:23:03,600 --> 00:23:06,320
these tools and our analysis efforts so

587
00:23:06,320 --> 00:23:08,240
for example as we can see here on the

588
00:23:08,240 --> 00:23:11,600
slide if we go run go search 22 that

589
00:23:11,600 --> 00:23:14,000
first publicly discovered instance of m1

590
00:23:14,000 --> 00:23:16,640
malware we can see it just exits and

591
00:23:16,640 --> 00:23:18,000
this is because as we'll see it detects

592
00:23:18,000 --> 00:23:20,080
the debugger and exits this is

593
00:23:20,080 --> 00:23:22,159
problematic because we want to continue

594
00:23:22,159 --> 00:23:23,600
our analysis

595
00:23:23,600 --> 00:23:25,600
so what you have to do is

596
00:23:25,600 --> 00:23:28,320
identify any anti-analysis logic that

597
00:23:28,320 --> 00:23:31,440
the malware implements then bypass that

598
00:23:31,440 --> 00:23:33,440
and once you've identified and bypassed

599
00:23:33,440 --> 00:23:36,000
it you can then fall back to the more

600
00:23:36,000 --> 00:23:38,240
powerful dynamic analysis tools like

601
00:23:38,240 --> 00:23:41,279
your file monitor or process monitor

602
00:23:41,279 --> 00:23:43,360
which don't require that deep of an

603
00:23:43,360 --> 00:23:45,360
understanding of arm 64. but again you

604
00:23:45,360 --> 00:23:46,960
kind of have to get the anti-analysis

605
00:23:46,960 --> 00:23:48,840
logic out of the way

606
00:23:48,840 --> 00:23:51,279
first it's also important to note that

607
00:23:51,279 --> 00:23:53,840
if we load the go search 22 malware the

608
00:23:53,840 --> 00:23:56,320
pirate malware into a disassembler and

609
00:23:56,320 --> 00:23:58,320
try to decompile it it just turns out to

610
00:23:58,320 --> 00:24:00,640
be junk the malware authors have obvious

611
00:24:00,640 --> 00:24:02,559
skated the code i believe they use the

612
00:24:02,559 --> 00:24:05,120
public llvm obvious gator which adds

613
00:24:05,120 --> 00:24:07,200
garbage instructions and spurious

614
00:24:07,200 --> 00:24:10,320
function calls again this is just an

615
00:24:10,320 --> 00:24:12,400
effort to complicate our analysis and

616
00:24:12,400 --> 00:24:15,039
confuse the decompiler so again

617
00:24:15,039 --> 00:24:16,559
unfortunately we have to use the

618
00:24:16,559 --> 00:24:18,720
disassembler and kind of get down and

619
00:24:18,720 --> 00:24:21,760
dirty with arm 64.

620
00:24:21,760 --> 00:24:23,360
so we mentioned that this malware

621
00:24:23,360 --> 00:24:26,159
executes or rather exits if it detects a

622
00:24:26,159 --> 00:24:28,320
debugger we want to be able to continue

623
00:24:28,320 --> 00:24:30,240
debugging the sample to extract all its

624
00:24:30,240 --> 00:24:32,559
secrets and learn exactly what it does

625
00:24:32,559 --> 00:24:34,880
so we have to figure out how it's

626
00:24:34,880 --> 00:24:36,960
detecting this debugger

627
00:24:36,960 --> 00:24:39,279
so reading through the disassembly we

628
00:24:39,279 --> 00:24:42,080
come across these five instructions

629
00:24:42,080 --> 00:24:44,400
first we see four registers are

630
00:24:44,400 --> 00:24:46,799
initialized for four arguments then the

631
00:24:46,799 --> 00:24:49,600
svc or supervisor call instruction is

632
00:24:49,600 --> 00:24:51,679
made i had to google this instruction i

633
00:24:51,679 --> 00:24:53,039
didn't know what it was but luckily

634
00:24:53,039 --> 00:24:56,240
google stack overflow very helpful

635
00:24:56,240 --> 00:24:57,679
if we look at the arguments especially

636
00:24:57,679 --> 00:25:00,080
in the context of this supervisor call

637
00:25:00,080 --> 00:25:03,200
we can see that the hex value 1a maps to

638
00:25:03,200 --> 00:25:06,159
sis p-trace so now we know the program

639
00:25:06,159 --> 00:25:08,480
the malware is invoking the p-trace

640
00:25:08,480 --> 00:25:10,880
system call in the context of the

641
00:25:10,880 --> 00:25:14,720
p-trace system call the value of one f

642
00:25:14,720 --> 00:25:17,919
maps to the pt deny attach flag if we

643
00:25:17,919 --> 00:25:20,240
read up about this flag we see that when

644
00:25:20,240 --> 00:25:22,080
passed to the p trace function this

645
00:25:22,080 --> 00:25:24,720
tells mac os to terminate an application

646
00:25:24,720 --> 00:25:26,799
or a program if it's being actively

647
00:25:26,799 --> 00:25:28,880
debugged and if it's not prevent a

648
00:25:28,880 --> 00:25:32,080
debugger from being attached

649
00:25:32,080 --> 00:25:33,600
so now that we've identified the

650
00:25:33,600 --> 00:25:35,840
anti-debugging logic how do we bypass it

651
00:25:35,840 --> 00:25:38,240
well it turns out it's pretty easy what

652
00:25:38,240 --> 00:25:41,039
we can simply do is set a break point on

653
00:25:41,039 --> 00:25:43,600
this problematic supervisor call

654
00:25:43,600 --> 00:25:45,679
then when our breakpoint is hit the

655
00:25:45,679 --> 00:25:48,240
debugger will halt the execution of the

656
00:25:48,240 --> 00:25:51,600
malware before this call has been made

657
00:25:51,600 --> 00:25:53,919
we can then modify the instruction

658
00:25:53,919 --> 00:25:56,000
pointer to simply skip over the

659
00:25:56,000 --> 00:25:57,840
problematic call

660
00:25:57,840 --> 00:25:59,600
and once we do this we then tell the

661
00:25:59,600 --> 00:26:01,760
malware to continue executing and it's

662
00:26:01,760 --> 00:26:04,080
none the wiser but the problematic

663
00:26:04,080 --> 00:26:07,360
system call has never been made

664
00:26:07,360 --> 00:26:08,840
unfortunately the malware has other

665
00:26:08,840 --> 00:26:11,520
anti-analysis logic it also checks if

666
00:26:11,520 --> 00:26:13,520
it's running on a system that has system

667
00:26:13,520 --> 00:26:15,919
integrity protection disabled often

668
00:26:15,919 --> 00:26:17,679
analysts will turn this off while

669
00:26:17,679 --> 00:26:20,320
analyzing malware so the malware

670
00:26:20,320 --> 00:26:21,919
rightfully has made the assumption that

671
00:26:21,919 --> 00:26:24,240
if it finds system integrity detection

672
00:26:24,240 --> 00:26:25,679
off it's going to exit because it

673
00:26:25,679 --> 00:26:28,240
assumes it's being analyzed

674
00:26:28,240 --> 00:26:29,279
so i'm stepping through this in a

675
00:26:29,279 --> 00:26:30,720
debugger because we've overcome the

676
00:26:30,720 --> 00:26:32,559
anti-debugging logic and it made this

677
00:26:32,559 --> 00:26:35,919
call blr x8 and just bailed and i was

678
00:26:35,919 --> 00:26:38,320
like ah what's it doing here so

679
00:26:38,320 --> 00:26:40,000
unfortunately from the disassembly we

680
00:26:40,000 --> 00:26:41,760
can't figure out exactly what it's doing

681
00:26:41,760 --> 00:26:43,840
but as i mentioned since we overcame the

682
00:26:43,840 --> 00:26:45,919
anti-debugging logic we can poke around

683
00:26:45,919 --> 00:26:47,440
and see what the values of these

684
00:26:47,440 --> 00:26:49,600
registers are so for example we can see

685
00:26:49,600 --> 00:26:52,640
the x8 register holds the obj message

686
00:26:52,640 --> 00:26:54,320
send function

687
00:26:54,320 --> 00:26:56,799
the obj message send function is the

688
00:26:56,799 --> 00:26:59,440
apple api that's executed whenever an

689
00:26:59,440 --> 00:27:02,159
objective-c function call is made apple

690
00:27:02,159 --> 00:27:03,520
documents this so we know what the

691
00:27:03,520 --> 00:27:05,919
values of the arguments should be so we

692
00:27:05,919 --> 00:27:07,840
can print them out in a debugger here we

693
00:27:07,840 --> 00:27:10,320
can see it's an nstask object and it's

694
00:27:10,320 --> 00:27:12,880
invoking the launch method

695
00:27:12,880 --> 00:27:15,679
reading more about the ns task launch

696
00:27:15,679 --> 00:27:19,039
ns task object we can see it has other

697
00:27:19,039 --> 00:27:20,799
instance variables or properties

698
00:27:20,799 --> 00:27:23,120
including a launch path and argument we

699
00:27:23,120 --> 00:27:25,840
can dump these in our debugger

700
00:27:25,840 --> 00:27:27,600
as we can see on the slide via the

701
00:27:27,600 --> 00:27:30,080
arguments it's going to invoke bin sh

702
00:27:30,080 --> 00:27:33,600
passing in the command csr util which is

703
00:27:33,600 --> 00:27:36,480
how you execute a check to see if system

704
00:27:36,480 --> 00:27:38,240
integrity protection is enabled so the

705
00:27:38,240 --> 00:27:40,000
malware is basically delegating out to

706
00:27:40,000 --> 00:27:41,840
the system

707
00:27:41,840 --> 00:27:43,919
we also find that the malware employs

708
00:27:43,919 --> 00:27:46,960
anti-vm logic now our authors rightfully

709
00:27:46,960 --> 00:27:48,640
assume that if the malware finds itself

710
00:27:48,640 --> 00:27:51,039
running in a virtual machine it's likely

711
00:27:51,039 --> 00:27:52,640
being analyzed

712
00:27:52,640 --> 00:27:55,440
it uses the same obsi message send

713
00:27:55,440 --> 00:27:57,440
function but again in a debugger we can

714
00:27:57,440 --> 00:28:00,159
print out the values of both the object

715
00:28:00,159 --> 00:28:02,480
and the method that's being called again

716
00:28:02,480 --> 00:28:04,960
seeing it's an ns task or ns concrete

717
00:28:04,960 --> 00:28:07,279
task object and by looking at the

718
00:28:07,279 --> 00:28:10,240
properties of this second ns task object

719
00:28:10,240 --> 00:28:12,240
we can see that it's executing a large

720
00:28:12,240 --> 00:28:13,679
script that looks for various

721
00:28:13,679 --> 00:28:16,480
virtualization products

722
00:28:16,480 --> 00:28:18,960
so that wraps up the anti-analysis logic

723
00:28:18,960 --> 00:28:21,200
of the malware given an understanding of

724
00:28:21,200 --> 00:28:23,360
the arm 64 instruction set we were able

725
00:28:23,360 --> 00:28:25,520
to identify this logic and then

726
00:28:25,520 --> 00:28:28,159
trivially bypass it by manipulating the

727
00:28:28,159 --> 00:28:31,039
instruction pointer in the debugger once

728
00:28:31,039 --> 00:28:32,880
this analysis has

729
00:28:32,880 --> 00:28:34,799
completed and once the anti-analysis

730
00:28:34,799 --> 00:28:37,360
code has been identified and overcome we

731
00:28:37,360 --> 00:28:40,559
can fall back to the more passive more

732
00:28:40,559 --> 00:28:43,120
powerful dynamic analysis tools like

733
00:28:43,120 --> 00:28:45,039
process monitors and file monitors to

734
00:28:45,039 --> 00:28:47,919
find out what the malware does

735
00:28:47,919 --> 00:28:50,799
so a few takeaways to wrap this up

736
00:28:50,799 --> 00:28:52,960
first we talked about how to hunt for m1

737
00:28:52,960 --> 00:28:55,120
malware if you pop on virustotal and do

738
00:28:55,120 --> 00:28:57,039
that same search query we talked about

739
00:28:57,039 --> 00:28:58,559
you'll find a myriad of new malware

740
00:28:58,559 --> 00:28:59,840
samples that have been compiled to

741
00:28:59,840 --> 00:29:03,279
natively run on apple's new m1 systems

742
00:29:03,279 --> 00:29:05,760
we talked about how to understand arm 64

743
00:29:05,760 --> 00:29:07,360
at least some basics

744
00:29:07,360 --> 00:29:08,640
this should hopefully point you in the

745
00:29:08,640 --> 00:29:10,799
right direction and get you along

746
00:29:10,799 --> 00:29:13,760
becoming a proficient analyst of m64

747
00:29:13,760 --> 00:29:15,039
malware

748
00:29:15,039 --> 00:29:16,960
finally we showed that in the context of

749
00:29:16,960 --> 00:29:19,279
reversing malware oftentimes you really

750
00:29:19,279 --> 00:29:21,200
only have to get that deep into the

751
00:29:21,200 --> 00:29:23,520
instruction set when looking for and

752
00:29:23,520 --> 00:29:26,559
identifying anti-analysis logic

753
00:29:26,559 --> 00:29:28,320
so again the goal is really to arm you

754
00:29:28,320 --> 00:29:30,799
with these topics today to really set

755
00:29:30,799 --> 00:29:32,720
you on the way becoming to becoming a

756
00:29:32,720 --> 00:29:35,039
proficient malware analysis even when

757
00:29:35,039 --> 00:29:37,600
analyzing m1 malware

758
00:29:37,600 --> 00:29:39,600
now of course this is in some ways just

759
00:29:39,600 --> 00:29:42,880
the tip of the proverbial iceberg so if

760
00:29:42,880 --> 00:29:44,480
you're interested in learning more

761
00:29:44,480 --> 00:29:46,480
there's a great book on the topic

762
00:29:46,480 --> 00:29:48,640
there's also some great

763
00:29:48,640 --> 00:29:50,960
online tutorials that have been

764
00:29:50,960 --> 00:29:52,399
mentioned some of the other researchers

765
00:29:52,399 --> 00:29:53,919
i quoted in the slides have some great

766
00:29:53,919 --> 00:29:56,159
blogs some great topics on reverse

767
00:29:56,159 --> 00:29:58,640
engineering and analyzing arm 64

768
00:29:58,640 --> 00:30:01,200
binaries and instructions and

769
00:30:01,200 --> 00:30:04,080
in the context of malware analysis the

770
00:30:04,080 --> 00:30:06,840
book i'm writing also dives into this as

771
00:30:06,840 --> 00:30:08,480
well

772
00:30:08,480 --> 00:30:10,799
yes want to thank the sponsors uh who

773
00:30:10,799 --> 00:30:13,120
sponsor my research in both the talk so

774
00:30:13,120 --> 00:30:15,279
again thank you so much to all of them

775
00:30:15,279 --> 00:30:16,960
uh couldn't do this research in the

776
00:30:16,960 --> 00:30:19,360
conference without them so again big big

777
00:30:19,360 --> 00:30:22,720
mahalo and really yeah now go forth uh

778
00:30:22,720 --> 00:30:24,640
reverse engineer this mac m1 malware

779
00:30:24,640 --> 00:30:26,880
it's here to stay and we need more

780
00:30:26,880 --> 00:30:28,720
researchers pulling it apart to keep the

781
00:30:28,720 --> 00:30:29,440
uh

782
00:30:29,440 --> 00:30:31,600
the attackers on their their toes

783
00:30:31,600 --> 00:30:33,440
so that's a wrap thank you again for

784
00:30:33,440 --> 00:30:35,440
listening to my talk

785
00:30:35,440 --> 00:30:37,279
unfortunately i went slightly over so if

786
00:30:37,279 --> 00:30:39,760
there's any questions hop on the discord

787
00:30:39,760 --> 00:30:40,880
channel or

788
00:30:40,880 --> 00:30:42,480
approach me at the party and we'll talk

789
00:30:42,480 --> 00:30:44,480
nerdy about m1 malware

790
00:30:44,480 --> 00:30:46,010
thanks again

791
00:30:46,010 --> 00:30:52,799
[Applause]

792
00:30:52,799 --> 00:30:54,879
you

