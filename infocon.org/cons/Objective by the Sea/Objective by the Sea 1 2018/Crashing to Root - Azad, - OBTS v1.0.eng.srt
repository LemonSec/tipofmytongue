1
00:00:00,030 --> 00:00:01,439
next up we have Brandon I think

2
00:00:01,439 --> 00:00:03,600
Brandon's our youngest speaker really

3
00:00:03,600 --> 00:00:06,390
excited about his talk not gonna give

4
00:00:06,390 --> 00:00:08,039
away all the details but it's really

5
00:00:08,039 --> 00:00:10,980
neat exploitation stuff he did on iOS

6
00:00:10,980 --> 00:00:14,130
and Mac OS so let's give a round of

7
00:00:14,130 --> 00:00:17,250
applause to Brandon and welcome him to

8
00:00:17,250 --> 00:00:18,660
the first objective by the sea

9
00:00:18,660 --> 00:00:28,140
conference thank you yeah super excited

10
00:00:28,140 --> 00:00:30,240
to be here thank you for sticking around

11
00:00:30,240 --> 00:00:31,830
to the very end

12
00:00:31,830 --> 00:00:33,809
oh yes Patrick's still talking after

13
00:00:33,809 --> 00:00:39,420
itself so sorry about that everyone my

14
00:00:39,420 --> 00:00:40,890
name is Brandon and I'm going to be

15
00:00:40,890 --> 00:00:42,510
talking about how you can elevate

16
00:00:42,510 --> 00:00:45,120
privileges on Mac OS by crashing

17
00:00:45,120 --> 00:00:47,100
maliciously really this work was

18
00:00:47,100 --> 00:00:49,980
originally based on an exploit that I

19
00:00:49,980 --> 00:00:51,660
did on iOS so I'm kind of gonna be

20
00:00:51,660 --> 00:00:54,840
mixing the two a little bit sorry about

21
00:00:54,840 --> 00:00:57,890
that I know it's a Mac OS conference but

22
00:00:57,890 --> 00:01:01,230
okay so first a little bit about me I

23
00:01:01,230 --> 00:01:03,989
was until very recently an independent

24
00:01:03,989 --> 00:01:06,810
security researcher but about three

25
00:01:06,810 --> 00:01:09,060
weeks ago I actually joined project zero

26
00:01:09,060 --> 00:01:10,530
which is Google's applied cyber security

27
00:01:10,530 --> 00:01:13,860
research team so it's kind of a bit

28
00:01:13,860 --> 00:01:16,590
weird since this talk is research I did

29
00:01:16,590 --> 00:01:19,200
before joining project zero so just to

30
00:01:19,200 --> 00:01:21,150
be clear this is all like independent

31
00:01:21,150 --> 00:01:22,950
stuff my payments here do not represent

32
00:01:22,950 --> 00:01:29,040
Google so yeah also I guess I focused a

33
00:01:29,040 --> 00:01:30,930
lot of my security research on Mac OS

34
00:01:30,930 --> 00:01:33,869
and iOS I graduated from Stanford in

35
00:01:33,869 --> 00:01:36,990
2016 and 2017 I was among those who

36
00:01:36,990 --> 00:01:38,759
discovered the original variant of the

37
00:01:38,759 --> 00:01:40,710
Pegasus spywares kernel code execution

38
00:01:40,710 --> 00:01:42,210
vulnerability they were like so many

39
00:01:42,210 --> 00:01:45,119
people who did that and I also developed

40
00:01:45,119 --> 00:01:47,430
some open-source tools including mem

41
00:01:47,430 --> 00:01:49,860
control which is a kernel inspection

42
00:01:49,860 --> 00:01:52,560
tool on device and an Ida Pro toolkit

43
00:01:52,560 --> 00:01:54,420
for analyzing Apple kernel cache files

44
00:01:54,420 --> 00:01:57,780
called Ida kernel cache so what's the

45
00:01:57,780 --> 00:01:59,700
context for this research project why

46
00:01:59,700 --> 00:02:02,130
did I begin looking at crashing well

47
00:02:02,130 --> 00:02:03,180
really it all began when I started

48
00:02:03,180 --> 00:02:05,250
looking at a crash log on the device and

49
00:02:05,250 --> 00:02:06,570
I realize there's a heck of a lot of

50
00:02:06,570 --> 00:02:08,940
information in these crash logs so you

51
00:02:08,940 --> 00:02:10,560
can see there's some general information

52
00:02:10,560 --> 00:02:13,230
about like what is going on we have a

53
00:02:13,230 --> 00:02:13,630
back

54
00:02:13,630 --> 00:02:15,190
trés which is usually symbolic ated

55
00:02:15,190 --> 00:02:17,680
about what the actual crashing thread

56
00:02:17,680 --> 00:02:20,410
stack looks like we have the register

57
00:02:20,410 --> 00:02:21,460
states of the values of all the

58
00:02:21,460 --> 00:02:24,190
registers and even a listing of all the

59
00:02:24,190 --> 00:02:25,780
binaries that have been loaded into your

60
00:02:25,780 --> 00:02:28,210
processes address space and this log is

61
00:02:28,210 --> 00:02:30,610
actually generated on the device so

62
00:02:30,610 --> 00:02:32,230
there's a lot of processing that's going

63
00:02:32,230 --> 00:02:34,510
on to generate this crash log and that

64
00:02:34,510 --> 00:02:35,680
really got me thinking you know if

65
00:02:35,680 --> 00:02:37,360
there's a lot of processing going on

66
00:02:37,360 --> 00:02:39,790
here I wonder if that makes a viable

67
00:02:39,790 --> 00:02:43,780
attack surface so can you like take

68
00:02:43,780 --> 00:02:47,170
advantage of this processing to elevate

69
00:02:47,170 --> 00:02:50,710
privileges or something so more formally

70
00:02:50,710 --> 00:02:53,410
what is this research project we're

71
00:02:53,410 --> 00:02:55,750
gonna be focusing on crash reporting on

72
00:02:55,750 --> 00:02:58,990
Mac OS and iOS and specifically we're

73
00:02:58,990 --> 00:03:01,690
gonna be targeting Mac OS 10 13 5 and

74
00:03:01,690 --> 00:03:05,440
iOS 11 to 6 and our goal is going to

75
00:03:05,440 --> 00:03:07,930
actually be pretty simple first we're

76
00:03:07,930 --> 00:03:09,550
going to try to find a zero-day

77
00:03:09,550 --> 00:03:11,560
vulnerability by looking at the crash

78
00:03:11,560 --> 00:03:13,870
reporting machinery and then we're going

79
00:03:13,870 --> 00:03:15,550
to try to elevate privileges on Mac OS

80
00:03:15,550 --> 00:03:17,710
and after that we're just gonna elevate

81
00:03:17,710 --> 00:03:20,020
privileges on iOS so to see how far we

82
00:03:20,020 --> 00:03:21,940
can go with whatever bugs that we find

83
00:03:21,940 --> 00:03:25,000
and once again why did I kind of start

84
00:03:25,000 --> 00:03:26,680
looking in this research area to begin

85
00:03:26,680 --> 00:03:28,720
with well cuz it seems like kind of an

86
00:03:28,720 --> 00:03:30,910
absurd place to look for bugs like I

87
00:03:30,910 --> 00:03:32,290
don't know about you but I've never seen

88
00:03:32,290 --> 00:03:34,420
an exploit that works by just like

89
00:03:34,420 --> 00:03:36,790
crashing your own process maliciously it

90
00:03:36,790 --> 00:03:38,110
seems kind of like a dumb way to attack

91
00:03:38,110 --> 00:03:39,940
a system so I figured that Apple

92
00:03:39,940 --> 00:03:42,340
probably hasn't given crash reporting

93
00:03:42,340 --> 00:03:44,850
the security auditing it really deserved

94
00:03:44,850 --> 00:03:48,040
ok so before we can actually go into the

95
00:03:48,040 --> 00:03:49,540
bug let's talk a little bit about

96
00:03:49,540 --> 00:03:51,820
inter-process communication which is

97
00:03:51,820 --> 00:03:53,320
really fundamental to understanding

98
00:03:53,320 --> 00:03:55,030
what's going on here

99
00:03:55,030 --> 00:03:58,090
so IPC on mac OS and iOS is based on

100
00:03:58,090 --> 00:04:00,550
mach ports mach ports are reference

101
00:04:00,550 --> 00:04:01,900
counted message queues that are

102
00:04:01,900 --> 00:04:04,180
maintained by the kernel arbitrarily

103
00:04:04,180 --> 00:04:06,130
many processes can send messages to

104
00:04:06,130 --> 00:04:08,830
these queues but only one process at a

105
00:04:08,830 --> 00:04:10,750
time can receive messages out of the

106
00:04:10,750 --> 00:04:13,870
queue and in userspace a mach port is

107
00:04:13,870 --> 00:04:16,959
referenced by a mach port name which is

108
00:04:16,959 --> 00:04:18,880
just a fancy name for an integer which

109
00:04:18,880 --> 00:04:20,920
is like a file descriptor so in the same

110
00:04:20,920 --> 00:04:22,330
way that a file descriptor in user space

111
00:04:22,330 --> 00:04:24,310
is a number which represents a file a

112
00:04:24,310 --> 00:04:27,520
mach port name is just an integer which

113
00:04:27,520 --> 00:04:31,270
presents an infernal mock pork you now

114
00:04:31,270 --> 00:04:32,919
there's also some terminology related to

115
00:04:32,919 --> 00:04:35,349
mock ports the ability to send messages

116
00:04:35,349 --> 00:04:37,090
to a mock port is called a send right

117
00:04:37,090 --> 00:04:38,770
while the ability to receive messages

118
00:04:38,770 --> 00:04:40,960
out of a mock port is called a receive

119
00:04:40,960 --> 00:04:44,020
right all right so now let's talk about

120
00:04:44,020 --> 00:04:46,210
these messages a mock message is

121
00:04:46,210 --> 00:04:47,979
structured data that gets sent to a mock

122
00:04:47,979 --> 00:04:50,560
port it's cute in the kernel until the

123
00:04:50,560 --> 00:04:52,330
owner of the mock pork actually listens

124
00:04:52,330 --> 00:04:54,789
for the message and a mock message can

125
00:04:54,789 --> 00:04:57,280
actually contain arbitrary data as well

126
00:04:57,280 --> 00:04:59,560
as send and receive writes excuse me

127
00:04:59,560 --> 00:05:01,199
send and receive writes to mock ports

128
00:05:01,199 --> 00:05:03,460
what this means is that you can actually

129
00:05:03,460 --> 00:05:06,310
send a send right to a mock port to

130
00:05:06,310 --> 00:05:08,710
another process by embedding the send

131
00:05:08,710 --> 00:05:10,150
right in a mock message that gets

132
00:05:10,150 --> 00:05:12,340
delivered to that other processes so

133
00:05:12,340 --> 00:05:13,930
that other process so basically these

134
00:05:13,930 --> 00:05:15,639
send and receive rights can be

135
00:05:15,639 --> 00:05:17,949
transmitted around other processes over

136
00:05:17,949 --> 00:05:19,569
the vary IPC mechanism which they're

137
00:05:19,569 --> 00:05:23,319
defining which is pretty cool okay so

138
00:05:23,319 --> 00:05:25,449
now let's talk about sub special

139
00:05:25,449 --> 00:05:27,610
varieties of mock ports called tasks and

140
00:05:27,610 --> 00:05:30,879
thread ports now these are special mask

141
00:05:30,879 --> 00:05:32,770
ports which means that the receive write

142
00:05:32,770 --> 00:05:34,960
is actually owned by the kernel so any

143
00:05:34,960 --> 00:05:36,520
messages that you send to these mark

144
00:05:36,520 --> 00:05:37,930
ports don't get received by other

145
00:05:37,930 --> 00:05:40,569
processes they're just processed by the

146
00:05:40,569 --> 00:05:43,690
kernel itself now a task port is a

147
00:05:43,690 --> 00:05:46,419
special port that can be used to control

148
00:05:46,419 --> 00:05:48,520
the corresponding task object and the

149
00:05:48,520 --> 00:05:50,289
task is basically just the mock name for

150
00:05:50,289 --> 00:05:52,810
a process so if you have a task for you

151
00:05:52,810 --> 00:05:55,120
can call functions like mach vm allocate

152
00:05:55,120 --> 00:05:57,729
which will cause the kernel to allocate

153
00:05:57,729 --> 00:06:00,219
virtual memory inside that processes

154
00:06:00,219 --> 00:06:02,979
address space which is a very powerful

155
00:06:02,979 --> 00:06:05,650
kind of like remote control mechanism

156
00:06:05,650 --> 00:06:08,440
for a process and similarly thread ports

157
00:06:08,440 --> 00:06:10,389
allow you to control an individual

158
00:06:10,389 --> 00:06:12,520
thread so for example if you call thread

159
00:06:12,520 --> 00:06:15,039
set state that can be used to set the

160
00:06:15,039 --> 00:06:16,990
values of the registers in a particular

161
00:06:16,990 --> 00:06:20,380
thread all right so we actually just

162
00:06:20,380 --> 00:06:21,969
talked about tasks and thread ports and

163
00:06:21,969 --> 00:06:23,409
I would be amiss if I didn't mention

164
00:06:23,409 --> 00:06:25,330
that there was a rich and long history

165
00:06:25,330 --> 00:06:28,240
of abusive task forts in exploits on

166
00:06:28,240 --> 00:06:30,370
both Mac OS and iOS and that's because

167
00:06:30,370 --> 00:06:32,289
there's a formula for how to go from

168
00:06:32,289 --> 00:06:34,479
holding a task fort to actually taking

169
00:06:34,479 --> 00:06:37,750
control of a process so if you have a

170
00:06:37,750 --> 00:06:41,320
task port you can call mach vm read and

171
00:06:41,320 --> 00:06:43,270
I am right to directly read and write in

172
00:06:43,270 --> 00:06:45,930
the processes memory that's basically it

173
00:06:45,930 --> 00:06:48,670
it's I know apples really made our lives

174
00:06:48,670 --> 00:06:50,350
difficult with this they've like blocked

175
00:06:50,350 --> 00:06:52,300
all the api's and like gated everything

176
00:06:52,300 --> 00:06:55,540
it's really difficult so actually it's a

177
00:06:55,540 --> 00:06:57,220
very important thing to keep in mind if

178
00:06:57,220 --> 00:07:00,070
you have a task fork for a process you

179
00:07:00,070 --> 00:07:01,780
own that process you can directly

180
00:07:01,780 --> 00:07:05,230
control it so let's get back to the

181
00:07:05,230 --> 00:07:07,180
background info now that we've talked

182
00:07:07,180 --> 00:07:08,950
about Mach ports which provide inter

183
00:07:08,950 --> 00:07:10,360
process communication

184
00:07:10,360 --> 00:07:12,610
let's see what Damon's on mac OS and iOS

185
00:07:12,610 --> 00:07:15,430
looked like Mac OS daemons are called

186
00:07:15,430 --> 00:07:17,200
Mach services which means that you

187
00:07:17,200 --> 00:07:18,820
communicate with them by sending

188
00:07:18,820 --> 00:07:22,990
receiving Mach messages that each mock

189
00:07:22,990 --> 00:07:25,390
service is identified by a name so for

190
00:07:25,390 --> 00:07:28,120
example calmed apple core services D is

191
00:07:28,120 --> 00:07:30,700
the name for the core services daemon

192
00:07:30,700 --> 00:07:33,520
and how does a client process actually

193
00:07:33,520 --> 00:07:36,160
gain the ability to talk with a service

194
00:07:36,160 --> 00:07:38,050
well the launch D process which we've

195
00:07:38,050 --> 00:07:39,430
been talking about and some other

196
00:07:39,430 --> 00:07:41,890
presentations actual events all the mock

197
00:07:41,890 --> 00:07:43,960
service on the system so as Michael

198
00:07:43,960 --> 00:07:46,270
mentioned earlier it basically serves

199
00:07:46,270 --> 00:07:48,820
like a DNS server for all of your mock

200
00:07:48,820 --> 00:07:51,160
services you give it a name and launch D

201
00:07:51,160 --> 00:07:52,780
will actually send you a message back

202
00:07:52,780 --> 00:07:56,350
with the services mock port so a client

203
00:07:56,350 --> 00:07:57,580
is going to just send a message to

204
00:07:57,580 --> 00:07:59,080
launch D saying hey I want to talk with

205
00:07:59,080 --> 00:08:00,910
a service and launch it will send a

206
00:08:00,910 --> 00:08:02,950
message back giving you a send right to

207
00:08:02,950 --> 00:08:06,400
the services Mach port all right so

208
00:08:06,400 --> 00:08:07,810
that's basically all the background

209
00:08:07,810 --> 00:08:09,850
information that we're going to need so

210
00:08:09,850 --> 00:08:11,770
as a reminder the focus of this talk is

211
00:08:11,770 --> 00:08:14,620
on crash reporting on Mac OS and our

212
00:08:14,620 --> 00:08:16,920
goal is to find a zero-day vulnerability

213
00:08:16,920 --> 00:08:19,600
elevate privileges on Mac OS and then

214
00:08:19,600 --> 00:08:23,950
elevate privileges on iOS all right so

215
00:08:23,950 --> 00:08:25,900
now let's take a look at crash handling

216
00:08:25,900 --> 00:08:27,580
what is actually going on when a process

217
00:08:27,580 --> 00:08:30,760
crashes well crash handling is based on

218
00:08:30,760 --> 00:08:32,620
mock exceptions which are a

219
00:08:32,620 --> 00:08:35,020
generalization of your traditional BSD

220
00:08:35,020 --> 00:08:37,539
signals so just like there are many

221
00:08:37,539 --> 00:08:39,760
different types of signals SIGINT insig

222
00:08:39,760 --> 00:08:41,590
seg v there are also many different

223
00:08:41,590 --> 00:08:44,470
exception conditions so for example X

224
00:08:44,470 --> 00:08:46,720
bad access is an exception that occurs

225
00:08:46,720 --> 00:08:49,600
on an invalid memory access while X

226
00:08:49,600 --> 00:08:51,580
crash is an exception that occurs when a

227
00:08:51,580 --> 00:08:52,850
process terminates out

228
00:08:52,850 --> 00:08:55,490
Emily and for each of these exception

229
00:08:55,490 --> 00:08:57,680
types you can actually register in the

230
00:08:57,680 --> 00:09:00,259
kernel a mock port to be notified when

231
00:09:00,259 --> 00:09:02,269
an exception occurs and this

232
00:09:02,269 --> 00:09:04,009
notification can actually occur three

233
00:09:04,009 --> 00:09:05,959
levels of granularity so you can

234
00:09:05,959 --> 00:09:07,339
register to be notified when a

235
00:09:07,339 --> 00:09:09,620
particular thread generates an exception

236
00:09:09,620 --> 00:09:12,680
or for when a particular thread in a or

237
00:09:12,680 --> 00:09:14,720
in any thread in a task generates an

238
00:09:14,720 --> 00:09:16,910
exception or you can register to be

239
00:09:16,910 --> 00:09:18,769
notified when any thread on the whole

240
00:09:18,769 --> 00:09:20,449
host generates an exception which is

241
00:09:20,449 --> 00:09:23,149
very very broad ability to receive

242
00:09:23,149 --> 00:09:26,120
exceptions and once an exception does

243
00:09:26,120 --> 00:09:28,279
occur the kernel will basically just

244
00:09:28,279 --> 00:09:30,680
send a mock message containing details

245
00:09:30,680 --> 00:09:32,389
about the exception to the register

246
00:09:32,389 --> 00:09:33,980
exception report which allows you to

247
00:09:33,980 --> 00:09:37,069
process it so how do you actually go

248
00:09:37,069 --> 00:09:40,279
about catching a mock exception you need

249
00:09:40,279 --> 00:09:41,509
to implement an exception handling

250
00:09:41,509 --> 00:09:44,000
service routine which has this prototype

251
00:09:44,000 --> 00:09:46,100
so the exception message will actually

252
00:09:46,100 --> 00:09:48,410
contain the thread and task ports of the

253
00:09:48,410 --> 00:09:50,300
crashing thread as well as other

254
00:09:50,300 --> 00:09:52,790
information about the exception and when

255
00:09:52,790 --> 00:09:53,959
this message is received

256
00:09:53,959 --> 00:09:56,389
it'll be parsed by Auto generated code

257
00:09:56,389 --> 00:09:57,740
and then the contents of the message

258
00:09:57,740 --> 00:09:59,269
will be passed to this function as

259
00:09:59,269 --> 00:10:01,939
parameters now the code that calls this

260
00:10:01,939 --> 00:10:04,160
function is auto generated by MiG which

261
00:10:04,160 --> 00:10:05,810
is a tool that generates mock message

262
00:10:05,810 --> 00:10:08,060
parsing code and the details of make

263
00:10:08,060 --> 00:10:10,100
aren't that important but what is

264
00:10:10,100 --> 00:10:12,380
important is that because this function

265
00:10:12,380 --> 00:10:13,970
is called by MiG there are very

266
00:10:13,970 --> 00:10:15,589
important semantics around the return

267
00:10:15,589 --> 00:10:18,500
value so if this exception handling

268
00:10:18,500 --> 00:10:21,259
function returns success then that

269
00:10:21,259 --> 00:10:23,949
indicates to the MiG code that the

270
00:10:23,949 --> 00:10:26,300
exception was handled and that it'll

271
00:10:26,300 --> 00:10:28,519
tell the kernel to resume the crashing

272
00:10:28,519 --> 00:10:32,480
process however if this function returns

273
00:10:32,480 --> 00:10:35,630
failure then the MiG code that called

274
00:10:35,630 --> 00:10:37,550
this function will deallocate the thread

275
00:10:37,550 --> 00:10:39,199
and task port sent in the message and

276
00:10:39,199 --> 00:10:41,300
then tell the kernel to try the next

277
00:10:41,300 --> 00:10:43,519
exception handler so these semantics

278
00:10:43,519 --> 00:10:45,740
around the D allocation of mock ports on

279
00:10:45,740 --> 00:10:48,199
returning failure are absolutely

280
00:10:48,199 --> 00:10:51,439
critical all right so what does it

281
00:10:51,439 --> 00:10:53,839
ception handling strategy actually look

282
00:10:53,839 --> 00:10:56,240
like so here's a hypothetical example

283
00:10:56,240 --> 00:10:58,699
where our process which is blanket in

284
00:10:58,699 --> 00:11:01,430
blue has a registered exception port 4x

285
00:11:01,430 --> 00:11:04,010
bad access and that port is owned by

286
00:11:04,010 --> 00:11:06,630
this crash handler process in red

287
00:11:06,630 --> 00:11:09,000
so when blanket accesses an invalid

288
00:11:09,000 --> 00:11:11,610
memory address the kernel will check its

289
00:11:11,610 --> 00:11:13,440
exception table and see that there is

290
00:11:13,440 --> 00:11:15,570
indeed a registered exception port for

291
00:11:15,570 --> 00:11:18,540
ex bat access the kernel will then in

292
00:11:18,540 --> 00:11:20,760
queue a mock message containing details

293
00:11:20,760 --> 00:11:23,340
about the exception on the port and when

294
00:11:23,340 --> 00:11:25,200
the crash handler process listens on the

295
00:11:25,200 --> 00:11:27,060
port for new messages it's going to

296
00:11:27,060 --> 00:11:28,710
receive a copy of that message in

297
00:11:28,710 --> 00:11:31,440
userspace and at this point the crash

298
00:11:31,440 --> 00:11:33,870
handler process can use the tasks in

299
00:11:33,870 --> 00:11:35,820
thread ports in the message to inspect

300
00:11:35,820 --> 00:11:39,140
or even to fix up the crashing process

301
00:11:39,140 --> 00:11:42,990
so who is this crash handling process on

302
00:11:42,990 --> 00:11:45,870
iOS it's a binary called report crash

303
00:11:45,870 --> 00:11:47,820
and this one binary is actually

304
00:11:47,820 --> 00:11:49,380
responsible for running two separate

305
00:11:49,380 --> 00:11:51,560
mock services each in its own process

306
00:11:51,560 --> 00:11:54,300
the first and most important is a

307
00:11:54,300 --> 00:11:56,370
service called comm Doppel dot report

308
00:11:56,370 --> 00:11:58,410
crash dot root which for the sake of

309
00:11:58,410 --> 00:11:59,790
brevity I'm just going to call report

310
00:11:59,790 --> 00:12:03,660
crash now this service port is the host

311
00:12:03,660 --> 00:12:05,940
level exception handler for ex crash

312
00:12:05,940 --> 00:12:08,730
exceptions what this means is that this

313
00:12:08,730 --> 00:12:10,530
port is going to receive an exception

314
00:12:10,530 --> 00:12:13,140
message whenever any application on the

315
00:12:13,140 --> 00:12:15,360
device terminates abnormally and then

316
00:12:15,360 --> 00:12:16,560
the exception will be delivered to the

317
00:12:16,560 --> 00:12:18,600
crash in up to the report crash port and

318
00:12:18,600 --> 00:12:20,610
report crash will inspect the process

319
00:12:20,610 --> 00:12:23,760
and generate a crash log the other

320
00:12:23,760 --> 00:12:28,440
service is comm a polluted self which

321
00:12:28,440 --> 00:12:29,940
I'm going to call safety net because

322
00:12:29,940 --> 00:12:32,610
that's its name on iOS and it kind of

323
00:12:32,610 --> 00:12:34,590
makes more sense as a name for reasons

324
00:12:34,590 --> 00:12:37,020
that you'll see so safety net is the

325
00:12:37,020 --> 00:12:39,510
task level exception handler for when

326
00:12:39,510 --> 00:12:42,540
the first service crashes and the whole

327
00:12:42,540 --> 00:12:44,700
reason that safety net exists is so it

328
00:12:44,700 --> 00:12:46,740
avoids a report crash having to handle

329
00:12:46,740 --> 00:12:48,690
its own exception messages so when

330
00:12:48,690 --> 00:12:50,730
report crash crashes it actually has a

331
00:12:50,730 --> 00:12:53,400
safety net so that it doesn't have to

332
00:12:53,400 --> 00:12:54,810
like infinite loop handling its own

333
00:12:54,810 --> 00:12:58,710
exceptions so what makes report crash

334
00:12:58,710 --> 00:13:01,290
worthy of investigation why is this an

335
00:13:01,290 --> 00:13:03,060
interesting target to look for

336
00:13:03,060 --> 00:13:05,430
vulnerabilities in well if you actually

337
00:13:05,430 --> 00:13:07,920
start an instance of report crash you'll

338
00:13:07,920 --> 00:13:10,890
see that it has root privileges and also

339
00:13:10,890 --> 00:13:14,070
it's completely on sandboxed which makes

340
00:13:14,070 --> 00:13:15,810
it a very appealing target because if we

341
00:13:15,810 --> 00:13:17,730
can get code execution inside of report

342
00:13:17,730 --> 00:13:19,440
crash we now have

343
00:13:19,440 --> 00:13:23,220
large amount of privilege so let's talk

344
00:13:23,220 --> 00:13:26,250
about the vulnerability I basically just

345
00:13:26,250 --> 00:13:29,160
opened up report crash in Ida Pro and D

346
00:13:29,160 --> 00:13:30,930
compiled it to look at the exception

347
00:13:30,930 --> 00:13:32,730
handling service routine so remember

348
00:13:32,730 --> 00:13:34,020
this is the function that gets called

349
00:13:34,020 --> 00:13:35,940
whenever an application on the device

350
00:13:35,940 --> 00:13:39,270
crashes and here's the code so this

351
00:13:39,270 --> 00:13:41,640
function gets called by auto-generated

352
00:13:41,640 --> 00:13:44,190
mig code and the thread in task court

353
00:13:44,190 --> 00:13:46,440
parameters here are parsed directly from

354
00:13:46,440 --> 00:13:49,620
the exception message report crash first

355
00:13:49,620 --> 00:13:51,540
is going to set the return value to kern

356
00:13:51,540 --> 00:13:55,050
failure and then if the message was not

357
00:13:55,050 --> 00:13:58,500
sent by the kernel the port sent in the

358
00:13:58,500 --> 00:14:00,120
message are going to be D allocated and

359
00:14:00,120 --> 00:14:02,820
then failure is returned so now this is

360
00:14:02,820 --> 00:14:05,130
a problem because this function is

361
00:14:05,130 --> 00:14:07,380
called by MIG code with very important

362
00:14:07,380 --> 00:14:10,170
semantics on the return value remember

363
00:14:10,170 --> 00:14:13,170
if the return code is failure then the

364
00:14:13,170 --> 00:14:15,150
mig code that called this function is

365
00:14:15,150 --> 00:14:17,160
also going to deallocate those mach

366
00:14:17,160 --> 00:14:19,170
ports and this is really problematic

367
00:14:19,170 --> 00:14:21,750
because mach ports are reference counted

368
00:14:21,750 --> 00:14:23,730
which means that we effectively have

369
00:14:23,730 --> 00:14:25,710
decreased the reference count on those

370
00:14:25,710 --> 00:14:28,470
mach ports to 1 less than report crash

371
00:14:28,470 --> 00:14:31,740
expects and this can effectively lead to

372
00:14:31,740 --> 00:14:34,050
a type of situation almost similar to

373
00:14:34,050 --> 00:14:36,780
use after free accept it's a mach port

374
00:14:36,780 --> 00:14:38,370
use after free rather than on memory

375
00:14:38,370 --> 00:14:41,670
corruption use after free so what does

376
00:14:41,670 --> 00:14:45,300
this process of you mach port use after

377
00:14:45,300 --> 00:14:48,120
free look like this is basically an

378
00:14:48,120 --> 00:14:50,040
attack called mock service impersonation

379
00:14:50,040 --> 00:14:52,830
where we're going to trick a substitute

380
00:14:52,830 --> 00:14:55,620
1 mach port with another and then do

381
00:14:55,620 --> 00:14:58,710
this all without report crash knowing so

382
00:14:58,710 --> 00:15:00,780
to start with a report crash is going to

383
00:15:00,780 --> 00:15:02,430
be talking with some privileged system

384
00:15:02,430 --> 00:15:05,339
service which is in yellow and that so

385
00:15:05,339 --> 00:15:08,280
report crash has a send write to the

386
00:15:08,280 --> 00:15:10,320
privilege service and we're going to try

387
00:15:10,320 --> 00:15:12,210
to use this vulnerability to trick

388
00:15:12,210 --> 00:15:13,740
report crashing and talking with us

389
00:15:13,740 --> 00:15:16,710
instead so first we're going to generate

390
00:15:16,710 --> 00:15:19,170
a malicious exception message where the

391
00:15:19,170 --> 00:15:20,940
thread and task Forks in this message

392
00:15:20,940 --> 00:15:24,060
are not real thread and task ports but

393
00:15:24,060 --> 00:15:25,560
instead are send rights to the mock

394
00:15:25,560 --> 00:15:28,020
service report crash is talking to so

395
00:15:28,020 --> 00:15:30,030
this is a malicious exception message

396
00:15:30,030 --> 00:15:31,650
because this would never be generated

397
00:15:31,650 --> 00:15:32,390
normally

398
00:15:32,390 --> 00:15:34,580
but the colonel is never going to stick

399
00:15:34,580 --> 00:15:36,770
you know regular mock send rights in an

400
00:15:36,770 --> 00:15:38,120
exception message where the threatened

401
00:15:38,120 --> 00:15:40,880
passports are supposed to be but because

402
00:15:40,880 --> 00:15:42,950
we can actually talk to a poor crash

403
00:15:42,950 --> 00:15:45,740
ourselves we can craft this message we

404
00:15:45,740 --> 00:15:48,500
can send it to report crash directly and

405
00:15:48,500 --> 00:15:50,420
then report crash is going to receive

406
00:15:50,420 --> 00:15:52,340
the message and it's going to process it

407
00:15:52,340 --> 00:15:54,230
with the code that we shoot looked at

408
00:15:54,230 --> 00:15:58,220
earlier and now because the message was

409
00:15:58,220 --> 00:16:00,710
not sent by the colonel this means that

410
00:16:00,710 --> 00:16:01,850
the vulnerability is going to be

411
00:16:01,850 --> 00:16:02,390
triggered

412
00:16:02,390 --> 00:16:04,070
so report crash is going to deallocate

413
00:16:04,070 --> 00:16:06,560
the threat and task courts again and

414
00:16:06,560 --> 00:16:07,760
remember these are this is a malicious

415
00:16:07,760 --> 00:16:09,950
exception message so those ports aren't

416
00:16:09,950 --> 00:16:12,200
real threat and task ports and it's

417
00:16:12,200 --> 00:16:13,520
going to drop the reference count to

418
00:16:13,520 --> 00:16:16,130
those ports to zero and then the port is

419
00:16:16,130 --> 00:16:18,650
going to be de-allocated and this is

420
00:16:18,650 --> 00:16:20,390
going to inadvertently free report

421
00:16:20,390 --> 00:16:22,640
crashes send right to the service so

422
00:16:22,640 --> 00:16:24,950
report crash thinks that this port still

423
00:16:24,950 --> 00:16:26,480
refers to the service it was just

424
00:16:26,480 --> 00:16:28,190
talking to but we've used the

425
00:16:28,190 --> 00:16:29,750
vulnerability to drop the reference

426
00:16:29,750 --> 00:16:31,460
count to zero and the port has been

427
00:16:31,460 --> 00:16:33,830
freed all without report crash realizing

428
00:16:33,830 --> 00:16:36,770
it so now what we're going to try to do

429
00:16:36,770 --> 00:16:38,060
is we're going to try to get that port

430
00:16:38,060 --> 00:16:40,940
name reused with a send rights to a port

431
00:16:40,940 --> 00:16:42,530
for which we hold the corresponding

432
00:16:42,530 --> 00:16:44,720
receive right so we're going to generate

433
00:16:44,720 --> 00:16:46,430
a new mock message containing a whole

434
00:16:46,430 --> 00:16:48,320
bunch of mock ports that we own and

435
00:16:48,320 --> 00:16:50,060
we're going to send that message over to

436
00:16:50,060 --> 00:16:52,520
report crash when report crash receives

437
00:16:52,520 --> 00:16:54,530
the message those ports are going to

438
00:16:54,530 --> 00:16:57,080
enter report crashes IPC namespace and

439
00:16:57,080 --> 00:16:59,030
we're going to hopefully have one of

440
00:16:59,030 --> 00:17:01,100
them reuse the name that originally

441
00:17:01,100 --> 00:17:03,500
referred to the service and at this

442
00:17:03,500 --> 00:17:05,449
point report crashing doesn't really

443
00:17:05,449 --> 00:17:07,400
know that the service port was changed

444
00:17:07,400 --> 00:17:09,920
any messages that report crash sends

445
00:17:09,920 --> 00:17:11,599
they're intended for the service are

446
00:17:11,599 --> 00:17:12,920
instead going to be delivered to us

447
00:17:12,920 --> 00:17:15,140
allowing us to man-in-the-middle report

448
00:17:15,140 --> 00:17:18,290
crashes connection with a service and so

449
00:17:18,290 --> 00:17:19,880
for example this could be really useful

450
00:17:19,880 --> 00:17:22,910
if report crash tries to send its own

451
00:17:22,910 --> 00:17:25,280
task port in a message to the service

452
00:17:25,280 --> 00:17:28,069
because we've effectively changed that

453
00:17:28,069 --> 00:17:30,380
mock port to point to us instead of the

454
00:17:30,380 --> 00:17:32,330
original service that message is going

455
00:17:32,330 --> 00:17:34,370
to be delivered to us which means that

456
00:17:34,370 --> 00:17:36,080
we now get a copy of report crash its

457
00:17:36,080 --> 00:17:38,540
task port and because we have a task

458
00:17:38,540 --> 00:17:40,670
fork we can now take control over report

459
00:17:40,670 --> 00:17:44,570
crash so this is a very powerful attack

460
00:17:44,570 --> 00:17:46,100
but exploitation

461
00:17:46,100 --> 00:17:47,990
really depends on being able to find a

462
00:17:47,990 --> 00:17:50,059
useful service to do this man in the

463
00:17:50,059 --> 00:17:52,520
middle on and if we look at all the mach

464
00:17:52,520 --> 00:17:54,590
ports owned by a report crash there

465
00:17:54,590 --> 00:17:56,600
aren't really there really aren't any

466
00:17:56,600 --> 00:18:00,590
useful targets so even though we have a

467
00:18:00,590 --> 00:18:03,530
mach port replacement vulnerability

468
00:18:03,530 --> 00:18:05,809
there aren't any useful ports to do a

469
00:18:05,809 --> 00:18:08,390
man-in-the-middle attack on so like any

470
00:18:08,390 --> 00:18:11,390
good security researcher I gave up and

471
00:18:11,390 --> 00:18:18,530
that's it thank you very much now so I'm

472
00:18:18,530 --> 00:18:19,909
messing with you

473
00:18:19,909 --> 00:18:22,730
I actually it might have ended there I

474
00:18:22,730 --> 00:18:24,350
was all prepared to give up because this

475
00:18:24,350 --> 00:18:26,750
is a completely useless bug but I

476
00:18:26,750 --> 00:18:29,000
actually started reversing launch D for

477
00:18:29,000 --> 00:18:30,590
some completely unrelated security

478
00:18:30,590 --> 00:18:32,299
research and I found something really

479
00:18:32,299 --> 00:18:34,580
surprising which is that for some

480
00:18:34,580 --> 00:18:36,799
mysterious reason launch D also

481
00:18:36,799 --> 00:18:39,460
implements a mock exception Handler and

482
00:18:39,460 --> 00:18:43,309
guess what it has the same bug now I

483
00:18:43,309 --> 00:18:44,750
have some theories as to what

484
00:18:44,750 --> 00:18:46,070
development technique might have led to

485
00:18:46,070 --> 00:18:48,799
this but the end result is basically the

486
00:18:48,799 --> 00:18:50,799
same which is that we can send a

487
00:18:50,799 --> 00:18:53,919
malicious exception message to launch D

488
00:18:53,919 --> 00:18:56,690
specifically of the type X crash and

489
00:18:56,690 --> 00:18:59,059
that's going to cause launch D 2 or D

490
00:18:59,059 --> 00:19:00,830
allocate the threat and task courts in

491
00:19:00,830 --> 00:19:03,679
the message so here's the vulnerable

492
00:19:03,679 --> 00:19:07,250
code but this time from launch D so like

493
00:19:07,250 --> 00:19:08,750
before the threat and task court

494
00:19:08,750 --> 00:19:11,030
parameters are parsed from the exception

495
00:19:11,030 --> 00:19:13,520
message then at the end of the function

496
00:19:13,520 --> 00:19:15,260
the thread and task ports are D

497
00:19:15,260 --> 00:19:17,780
allocated and then for the specific

498
00:19:17,780 --> 00:19:20,630
exception type of X crash failure gets

499
00:19:20,630 --> 00:19:22,340
returned causing those ports to be

500
00:19:22,340 --> 00:19:28,400
gallic ated a second time so launch D is

501
00:19:28,400 --> 00:19:30,590
a much more promising target for an

502
00:19:30,590 --> 00:19:32,480
exploit and the reason for that is

503
00:19:32,480 --> 00:19:35,059
because wash D actually manages mock

504
00:19:35,059 --> 00:19:36,650
ports for the whole rest of the system

505
00:19:36,650 --> 00:19:38,690
which means that there are many more

506
00:19:38,690 --> 00:19:41,960
targets for mock port replacement in

507
00:19:41,960 --> 00:19:44,330
addition to that our mock court

508
00:19:44,330 --> 00:19:46,280
replacement attack is now exponentially

509
00:19:46,280 --> 00:19:48,289
more powerful because not only do we

510
00:19:48,289 --> 00:19:50,659
trick launch D into thinking that we own

511
00:19:50,659 --> 00:19:52,789
the service port but because launch D is

512
00:19:52,789 --> 00:19:55,370
effectively the mock service DNS server

513
00:19:55,370 --> 00:19:56,080
on the

514
00:19:56,080 --> 00:19:58,210
launched these going to tell all the

515
00:19:58,210 --> 00:20:00,039
other processes that we own that service

516
00:20:00,039 --> 00:20:03,010
to which means that we now can do mock

517
00:20:03,010 --> 00:20:05,320
service impersonation against almost any

518
00:20:05,320 --> 00:20:07,269
other process and that process doesn't

519
00:20:07,269 --> 00:20:09,070
need to have this vulnerability in it

520
00:20:09,070 --> 00:20:10,659
because we just trick launch team and

521
00:20:10,659 --> 00:20:12,039
launch new is going to tell everyone

522
00:20:12,039 --> 00:20:14,559
else that we own the service as well so

523
00:20:14,559 --> 00:20:18,250
it's a very nice bug to have so how are

524
00:20:18,250 --> 00:20:20,769
we doing in our overall journey we found

525
00:20:20,769 --> 00:20:22,870
a zero-day vulnerability in launch d and

526
00:20:22,870 --> 00:20:26,580
so that part of our goal is achieved and

527
00:20:26,580 --> 00:20:29,679
this we can use this vulnerability to

528
00:20:29,679 --> 00:20:31,960
free certain mach ports inside of launch

529
00:20:31,960 --> 00:20:35,620
d so at this point we know that we want

530
00:20:35,620 --> 00:20:37,690
to use this primitive to impersonate a

531
00:20:37,690 --> 00:20:40,240
system service and after we do figure

532
00:20:40,240 --> 00:20:41,889
out how to do that we also need to

533
00:20:41,889 --> 00:20:43,450
figure out how we're going to actually

534
00:20:43,450 --> 00:20:45,460
use mock service impersonation to

535
00:20:45,460 --> 00:20:48,970
elevate privileges so let's look at the

536
00:20:48,970 --> 00:20:50,860
first step which is to use this

537
00:20:50,860 --> 00:20:52,870
vulnerability to impersonate mock

538
00:20:52,870 --> 00:20:55,779
services so let's say that we're trying

539
00:20:55,779 --> 00:20:57,940
to impersonate some target service so

540
00:20:57,940 --> 00:20:59,860
that when a new process starts up and

541
00:20:59,860 --> 00:21:02,049
tries to connect to the target launch D

542
00:21:02,049 --> 00:21:05,649
we'll connect them with us instead first

543
00:21:05,649 --> 00:21:08,799
we're going to send a launch D a fake

544
00:21:08,799 --> 00:21:11,710
crash message to free launch D send

545
00:21:11,710 --> 00:21:13,510
right to the target so this is actually

546
00:21:13,510 --> 00:21:16,330
exploiting the vulnerability next we're

547
00:21:16,330 --> 00:21:18,570
going to generate about 500 Mach ports

548
00:21:18,570 --> 00:21:21,010
and then we're going to use those ports

549
00:21:21,010 --> 00:21:23,200
to repeatedly register dummy services

550
00:21:23,200 --> 00:21:24,639
and launch D effectively just like

551
00:21:24,639 --> 00:21:27,010
spraying mock ports into launch DS IPC

552
00:21:27,010 --> 00:21:29,710
namespace until hopefully one of those

553
00:21:29,710 --> 00:21:32,409
ports reuses the port name that we freed

554
00:21:32,409 --> 00:21:35,110
earlier and we can check for success by

555
00:21:35,110 --> 00:21:37,240
just asking launch d hey launch D send

556
00:21:37,240 --> 00:21:39,850
us the target port name once launched he

557
00:21:39,850 --> 00:21:41,470
sends back one of the ports that we

558
00:21:41,470 --> 00:21:43,679
created earlier we know that we've won

559
00:21:43,679 --> 00:21:46,389
and at this point any new process that

560
00:21:46,389 --> 00:21:48,370
starts up and asks launch e to connect

561
00:21:48,370 --> 00:21:49,929
to the target is going to instead be

562
00:21:49,929 --> 00:21:51,909
talking to us allowing us to do our

563
00:21:51,909 --> 00:21:56,230
man-in-the-middle attack so let's now

564
00:21:56,230 --> 00:21:58,059
look at how we can use mock service

565
00:21:58,059 --> 00:22:00,940
impersonation to elevate privileges on

566
00:22:00,940 --> 00:22:04,720
Mac OS so the key to using services

567
00:22:04,720 --> 00:22:06,610
mersa nation well is in choosing the

568
00:22:06,610 --> 00:22:08,919
right service to impersonate so if we're

569
00:22:08,919 --> 00:22:09,940
going to elevate

570
00:22:09,940 --> 00:22:11,830
we might as well aim as high as we

571
00:22:11,830 --> 00:22:14,320
possibly can which is to get code

572
00:22:14,320 --> 00:22:16,600
execution in an unsound boxed root

573
00:22:16,600 --> 00:22:18,790
process with the task for PID allow

574
00:22:18,790 --> 00:22:21,070
entitlement tasks for PID allow if

575
00:22:21,070 --> 00:22:22,900
you're not familiar basically allows you

576
00:22:22,900 --> 00:22:25,450
to call the task for PID system call and

577
00:22:25,450 --> 00:22:27,910
because a task port means you can

578
00:22:27,910 --> 00:22:30,370
control a process if I can call task for

579
00:22:30,370 --> 00:22:32,920
PID I can get the task port to any

580
00:22:32,920 --> 00:22:34,630
process on the system so I can take

581
00:22:34,630 --> 00:22:36,730
control over any process on the system

582
00:22:36,730 --> 00:22:39,670
so if I need any entitlement just inject

583
00:22:39,670 --> 00:22:40,840
code into a process with that

584
00:22:40,840 --> 00:22:42,100
entitlement and you're done

585
00:22:42,100 --> 00:22:44,920
so if you have tasks for PID allow you

586
00:22:44,920 --> 00:22:49,480
own every user space process so this is

587
00:22:49,480 --> 00:22:50,920
the best that we can hope to achieve so

588
00:22:50,920 --> 00:22:52,720
let's try to see if we can actually do

589
00:22:52,720 --> 00:22:54,730
that the easiest approach we can

590
00:22:54,730 --> 00:22:57,280
actually take is the strategy initially

591
00:22:57,280 --> 00:22:59,740
suggested by Ian beer of project zero

592
00:22:59,740 --> 00:23:01,690
which he demonstrated in his mouth

593
00:23:01,690 --> 00:23:04,030
portal exploit which is to find a

594
00:23:04,030 --> 00:23:05,890
service to which a privileged client

595
00:23:05,890 --> 00:23:08,560
sends its task for then use the

596
00:23:08,560 --> 00:23:10,150
vulnerability to impersonate that

597
00:23:10,150 --> 00:23:12,430
service and then trigger the client to

598
00:23:12,430 --> 00:23:14,880
start and man-in-the-middle its requests

599
00:23:14,880 --> 00:23:17,410
then the client is going to think that

600
00:23:17,410 --> 00:23:18,850
it's talking with the original service

601
00:23:18,850 --> 00:23:20,830
and so the client is going to send us

602
00:23:20,830 --> 00:23:23,410
its task fork which then allows us to

603
00:23:23,410 --> 00:23:25,420
take control of the client and then we

604
00:23:25,420 --> 00:23:30,460
now inherit the clients privileges so it

605
00:23:30,460 --> 00:23:33,580
sounds great but if we actually do this

606
00:23:33,580 --> 00:23:36,340
and look in the services that exists on

607
00:23:36,340 --> 00:23:37,900
Mac OS that we can actually impersonate

608
00:23:37,900 --> 00:23:40,210
there are basically only two that looked

609
00:23:40,210 --> 00:23:43,330
very promising fortunately they're

610
00:23:43,330 --> 00:23:44,980
actually great candidates and core

611
00:23:44,980 --> 00:23:47,410
services D is actually a perfect for our

612
00:23:47,410 --> 00:23:50,590
needs because clients will actually send

613
00:23:50,590 --> 00:23:52,540
their task court to court services D and

614
00:23:52,540 --> 00:23:54,310
there are a lot of really privileged

615
00:23:54,310 --> 00:23:56,470
clients so we can just basically

616
00:23:56,470 --> 00:23:58,870
impersonate the service comma pulp core

617
00:23:58,870 --> 00:24:02,110
services core services D which was

618
00:24:02,110 --> 00:24:04,300
actually the same service that was used

619
00:24:04,300 --> 00:24:06,400
in n beers original mac OS exploit code

620
00:24:06,400 --> 00:24:08,920
and it basically just works right out of

621
00:24:08,920 --> 00:24:13,000
the box so core services D again holds

622
00:24:13,000 --> 00:24:15,730
the task ports of all of its clients and

623
00:24:15,730 --> 00:24:17,500
we can actually see a listing of all the

624
00:24:17,500 --> 00:24:19,330
task courts that it holds if you use the

625
00:24:19,330 --> 00:24:23,730
LS NP command so we want to find the

626
00:24:23,730 --> 00:24:25,350
client of course services to you that

627
00:24:25,350 --> 00:24:27,210
has the most privileges and they're

628
00:24:27,210 --> 00:24:29,070
actually two of them right here I don't

629
00:24:29,070 --> 00:24:30,330
know if you can actually see it on the

630
00:24:30,330 --> 00:24:33,539
screen but there's spin dump and sis

631
00:24:33,539 --> 00:24:35,210
diagnose which I've highlighted in red

632
00:24:35,210 --> 00:24:38,220
these are actually tasks for PID allow

633
00:24:38,220 --> 00:24:40,760
entitled so all we have to do is

634
00:24:40,760 --> 00:24:43,740
impersonate course Services D and start

635
00:24:43,740 --> 00:24:45,779
up one of these two processes and then

636
00:24:45,779 --> 00:24:48,600
we'll get sis diagnosis or spin dumps

637
00:24:48,600 --> 00:24:51,090
task port and then we just execute code

638
00:24:51,090 --> 00:24:54,210
inside a task for PID allow process so

639
00:24:54,210 --> 00:24:55,529
that's basically how the exploit works

640
00:24:55,529 --> 00:24:57,870
so first we use the launch the

641
00:24:57,870 --> 00:24:59,220
vulnerability to impersonate core

642
00:24:59,220 --> 00:25:02,970
services D then we trigger cystitis to

643
00:25:02,970 --> 00:25:05,130
start the reason I chose six diagnosis

644
00:25:05,130 --> 00:25:06,389
is basically just because it's easier to

645
00:25:06,389 --> 00:25:10,019
communicate with sis diagnose is going

646
00:25:10,019 --> 00:25:12,570
to want to talk with core services D so

647
00:25:12,570 --> 00:25:13,980
we just man in the middle this is

648
00:25:13,980 --> 00:25:16,080
diagnosis connection because we've now

649
00:25:16,080 --> 00:25:18,720
impersonated core services D and then we

650
00:25:18,720 --> 00:25:21,539
get sis diagnosis task port and then

651
00:25:21,539 --> 00:25:23,519
using that task court execute arbitrary

652
00:25:23,519 --> 00:25:26,220
code with on sand box root tasks for PID

653
00:25:26,220 --> 00:25:28,919
privileges graphically it looks

654
00:25:28,919 --> 00:25:29,730
something like this

655
00:25:29,730 --> 00:25:31,620
so we have launch deeds in the center

656
00:25:31,620 --> 00:25:35,100
with core services D in the blue green

657
00:25:35,100 --> 00:25:37,620
color on the right we have blanket is on

658
00:25:37,620 --> 00:25:38,880
the bottom and left blank is are

659
00:25:38,880 --> 00:25:41,940
attacking process so and the arrow

660
00:25:41,940 --> 00:25:43,980
represents launch D having a send right

661
00:25:43,980 --> 00:25:46,409
to core services D so the first thing

662
00:25:46,409 --> 00:25:47,820
we're going to do as the attacker is

663
00:25:47,820 --> 00:25:50,610
look up for services D in launch T to

664
00:25:50,610 --> 00:25:53,130
get a send right to core services D and

665
00:25:53,130 --> 00:25:55,380
then we're going to attack launch D by

666
00:25:55,380 --> 00:25:57,179
sending a malicious exception message

667
00:25:57,179 --> 00:25:59,250
and get launch DS send right to core

668
00:25:59,250 --> 00:26:02,159
services D to be freed once we freed the

669
00:26:02,159 --> 00:26:03,809
send right we now register a bunch of

670
00:26:03,809 --> 00:26:05,730
dummy mock services and launch team and

671
00:26:05,730 --> 00:26:08,370
get the core services deport name reused

672
00:26:08,370 --> 00:26:11,220
to point to us instead so at this point

673
00:26:11,220 --> 00:26:13,110
we are now men in the middle Inc or

674
00:26:13,110 --> 00:26:15,779
services team so if we trigger assist

675
00:26:15,779 --> 00:26:18,059
diagnosis start sis diagnosis is going

676
00:26:18,059 --> 00:26:20,429
to ask launch D hey who is core services

677
00:26:20,429 --> 00:26:22,380
and launch she's going to reply that we

678
00:26:22,380 --> 00:26:25,409
are core services so now we're directly

679
00:26:25,409 --> 00:26:26,760
in the man in the middle position with

680
00:26:26,760 --> 00:26:27,779
core services D

681
00:26:27,779 --> 00:26:29,700
so when core service when's this

682
00:26:29,700 --> 00:26:31,889
diagnosis tries to send messages to core

683
00:26:31,889 --> 00:26:33,929
services we get to receive them and we

684
00:26:33,929 --> 00:26:35,519
just pass them directly along to core

685
00:26:35,519 --> 00:26:37,650
services and eventually

686
00:26:37,650 --> 00:26:40,290
diagnose is going to descend over its

687
00:26:40,290 --> 00:26:41,730
task fort as the normal communication

688
00:26:41,730 --> 00:26:44,880
protocol with core services which means

689
00:26:44,880 --> 00:26:47,220
that we get that message we use the task

690
00:26:47,220 --> 00:26:49,230
fork to take control over sis diagnose

691
00:26:49,230 --> 00:26:52,980
and now we have elevated privileges so

692
00:26:52,980 --> 00:26:55,520
let's do a quick hopefully quick demo

693
00:26:55,520 --> 00:27:03,450
you never know what these things here we

694
00:27:03,450 --> 00:27:07,110
go so I have my repository here and I

695
00:27:07,110 --> 00:27:09,000
have some shells that base shell scripts

696
00:27:09,000 --> 00:27:10,860
that wrap a binary that does this

697
00:27:10,860 --> 00:27:13,560
technique so launch deep or trap root

698
00:27:13,560 --> 00:27:17,760
shell should hopefully work this is

699
00:27:17,760 --> 00:27:19,200
being tested on the machine that I'm

700
00:27:19,200 --> 00:27:20,700
giving this presentation on I'm not sure

701
00:27:20,700 --> 00:27:22,110
if that's a great idea

702
00:27:22,110 --> 00:27:26,070
okay so the error that we see here is

703
00:27:26,070 --> 00:27:27,690
basically because sis diagnose is

704
00:27:27,690 --> 00:27:29,820
already running on the system

705
00:27:29,820 --> 00:27:32,040
I have not it's possible to workaround

706
00:27:32,040 --> 00:27:33,240
to this restriction but I have not

707
00:27:33,240 --> 00:27:35,220
because I'm not a super huge fan of just

708
00:27:35,220 --> 00:27:37,500
giving completely weaponized exploits

709
00:27:37,500 --> 00:27:40,380
out so basically the way to fix this for

710
00:27:40,380 --> 00:27:41,250
demos just kill it

711
00:27:41,250 --> 00:27:52,110
so pseudo p9 diagnose cool and then so

712
00:27:52,110 --> 00:27:54,000
we freed launch these sender eight core

713
00:27:54,000 --> 00:27:56,790
services and did the impersonation got a

714
00:27:56,790 --> 00:27:59,910
sis diagnose task court and executed

715
00:27:59,910 --> 00:28:02,900
code now we have a root shell

716
00:28:07,190 --> 00:28:11,720
I should probably kill that not a great

717
00:28:11,720 --> 00:28:16,460
idea to have that open alright so that

718
00:28:16,460 --> 00:28:18,350
was nice right it was fun

719
00:28:18,350 --> 00:28:20,330
but didn't it just feel a little bit too

720
00:28:20,330 --> 00:28:23,870
easy to you like we just basically took

721
00:28:23,870 --> 00:28:25,430
stock exploit code we didn't have to do

722
00:28:25,430 --> 00:28:26,660
anything yeah and beer did all the work

723
00:28:26,660 --> 00:28:28,880
so why don't we try to do something like

724
00:28:28,880 --> 00:28:31,820
a little bit harder and the thing that

725
00:28:31,820 --> 00:28:33,980
might be a little bit harder is doing

726
00:28:33,980 --> 00:28:37,400
this whole thing again on iOS and the

727
00:28:37,400 --> 00:28:39,020
reason that iOS is a lot harder is

728
00:28:39,020 --> 00:28:39,800
twofold

729
00:28:39,800 --> 00:28:42,530
first there's a lot more mitigations on

730
00:28:42,530 --> 00:28:44,390
iOS so there's a lot more security

731
00:28:44,390 --> 00:28:45,290
features that we're going to need to

732
00:28:45,290 --> 00:28:48,980
bypass and second the actual exploiting

733
00:28:48,980 --> 00:28:51,200
of this bug is harder because there's

734
00:28:51,200 --> 00:28:52,730
initial security check that we need to

735
00:28:52,730 --> 00:28:55,610
bypass so here's the same code from

736
00:28:55,610 --> 00:28:58,180
launch key but this time in the iOS case

737
00:28:58,180 --> 00:29:00,680
so this is very similar to the Mac OS

738
00:29:00,680 --> 00:29:02,840
version but it's not identical there's

739
00:29:02,840 --> 00:29:05,480
one additional security check so like

740
00:29:05,480 --> 00:29:07,040
before the threading task ports are

741
00:29:07,040 --> 00:29:09,350
parsed from the exception message and

742
00:29:09,350 --> 00:29:10,790
then there's also this check here that

743
00:29:10,790 --> 00:29:13,100
wasn't there before which is some check

744
00:29:13,100 --> 00:29:14,870
on the something called an audit token

745
00:29:14,870 --> 00:29:16,760
and we're gonna have to bypass this to

746
00:29:16,760 --> 00:29:19,190
trigger the bug but once we do bypass it

747
00:29:19,190 --> 00:29:20,870
it's the same as before the threat and

748
00:29:20,870 --> 00:29:23,180
task ports are delegated failure gets

749
00:29:23,180 --> 00:29:24,980
returned for the specific case of ax

750
00:29:24,980 --> 00:29:28,700
crash so how are we actually going to

751
00:29:28,700 --> 00:29:31,340
trigger this bug on iOS because there's

752
00:29:31,340 --> 00:29:32,750
this additional check here that we need

753
00:29:32,750 --> 00:29:33,340
to bypass

754
00:29:33,340 --> 00:29:35,720
well we need to make sure that this if

755
00:29:35,720 --> 00:29:38,210
statement is not taken and this code is

756
00:29:38,210 --> 00:29:39,800
basically launched deep checking that

757
00:29:39,800 --> 00:29:41,480
the exception message was really sent by

758
00:29:41,480 --> 00:29:43,640
the kernel and not some user space

759
00:29:43,640 --> 00:29:46,160
process and this is really problematic

760
00:29:46,160 --> 00:29:49,340
for us because the kernel is only going

761
00:29:49,340 --> 00:29:50,780
to send an exception message when a

762
00:29:50,780 --> 00:29:52,880
process actually crashes we can no

763
00:29:52,880 --> 00:29:54,200
longer just do the thing of just like

764
00:29:54,200 --> 00:29:55,460
sending the message directly to launch

765
00:29:55,460 --> 00:29:58,280
team and if we just try to crash our own

766
00:29:58,280 --> 00:30:00,050
process directly that's not going to

767
00:30:00,050 --> 00:30:01,760
work because the kernel is going to

768
00:30:01,760 --> 00:30:03,920
stick the real threat and task force in

769
00:30:03,920 --> 00:30:05,840
the exception message and what we really

770
00:30:05,840 --> 00:30:07,790
need is for the exception message to

771
00:30:07,790 --> 00:30:09,650
contain the send right that we want to

772
00:30:09,650 --> 00:30:11,330
free inside of launch team that's the

773
00:30:11,330 --> 00:30:12,800
whole premise of sending a malicious

774
00:30:12,800 --> 00:30:13,639
exception

775
00:30:13,639 --> 00:30:17,029
message so at this point exploit ability

776
00:30:17,029 --> 00:30:19,759
on iOS depends entirely on one question

777
00:30:19,759 --> 00:30:22,759
which is can we make the kernel send a

778
00:30:22,759 --> 00:30:25,969
malicious exception message now the

779
00:30:25,969 --> 00:30:28,700
answer isn't obvious but I basically did

780
00:30:28,700 --> 00:30:30,739
some digging on to the deep and dark

781
00:30:30,739 --> 00:30:33,409
corners of xnu and I found that there's

782
00:30:33,409 --> 00:30:35,450
a function called task set special port

783
00:30:35,450 --> 00:30:38,179
which can be used to set a custom send

784
00:30:38,179 --> 00:30:40,190
right for the kernel to use instead of

785
00:30:40,190 --> 00:30:42,789
the true task port in certain situations

786
00:30:42,789 --> 00:30:45,829
including as it turns out when the

787
00:30:45,829 --> 00:30:47,389
kernel generates an exception message

788
00:30:47,389 --> 00:30:50,239
and conveniently there's a parallel API

789
00:30:50,239 --> 00:30:52,369
thread set special port that does the

790
00:30:52,369 --> 00:30:55,159
same thing for threads so at this point

791
00:30:55,159 --> 00:30:58,099
we're basically in business it's

792
00:30:58,099 --> 00:30:59,959
actually not too difficult for us to

793
00:30:59,959 --> 00:31:02,899
trigger this bug on iOS so first we're

794
00:31:02,899 --> 00:31:04,849
going to look up the target service port

795
00:31:04,849 --> 00:31:07,029
that we want to free inside of launch D

796
00:31:07,029 --> 00:31:09,679
then we register launch D to be our

797
00:31:09,679 --> 00:31:12,019
exception handler for X crash exceptions

798
00:31:12,019 --> 00:31:14,690
and then we call these two functions

799
00:31:14,690 --> 00:31:17,659
that we discovered to spoof our kernel

800
00:31:17,659 --> 00:31:20,419
our task and thread port in the

801
00:31:20,419 --> 00:31:23,029
exception message and once we've spoofed

802
00:31:23,029 --> 00:31:24,919
our thread in task ports we just call

803
00:31:24,919 --> 00:31:26,749
abort and this is going to cause the

804
00:31:26,749 --> 00:31:28,879
kernel to send an x crash exception

805
00:31:28,879 --> 00:31:31,249
message which from the first call gets

806
00:31:31,249 --> 00:31:32,929
delivered to launch D and from the

807
00:31:32,929 --> 00:31:35,450
second call contains the spoofed ports

808
00:31:35,450 --> 00:31:38,809
instead of the real ports now all this

809
00:31:38,809 --> 00:31:40,839
is great but it does beg the question

810
00:31:40,839 --> 00:31:43,789
we're calling abort which is going to

811
00:31:43,789 --> 00:31:46,519
like crash our process and we definitely

812
00:31:46,519 --> 00:31:48,739
need to run more code if we're going to

813
00:31:48,739 --> 00:31:51,259
take advantage of the dangling port that

814
00:31:51,259 --> 00:31:52,879
we've just created inside of launch D

815
00:31:52,879 --> 00:31:55,669
and if we try to use the traditional

816
00:31:55,669 --> 00:31:58,099
approach of calling fork or POSIX spawn

817
00:31:58,099 --> 00:32:00,169
to create a sub process this is actually

818
00:32:00,169 --> 00:32:01,849
going to be blocked by the sandbox

819
00:32:01,849 --> 00:32:05,629
profile on iOS so we can't use these

820
00:32:05,629 --> 00:32:07,339
like traditional api's that were aware

821
00:32:07,339 --> 00:32:10,129
of now for a proof-of-concept exploit

822
00:32:10,129 --> 00:32:11,629
you can actually get around this by

823
00:32:11,629 --> 00:32:13,399
using something called app extensions

824
00:32:13,399 --> 00:32:15,109
which if you ever looked inside if

825
00:32:15,109 --> 00:32:17,149
you're like you know finder are sorry

826
00:32:17,149 --> 00:32:19,219
Safari like share window has like some

827
00:32:19,219 --> 00:32:20,779
other app icons in there that's

828
00:32:20,779 --> 00:32:22,369
basically the speaker called

829
00:32:22,369 --> 00:32:24,319
app extensions which allows another

830
00:32:24,319 --> 00:32:26,100
binary to be part of your application

831
00:32:26,100 --> 00:32:28,140
that runs in separate processes so we're

832
00:32:28,140 --> 00:32:29,940
just going to abuse this feature to

833
00:32:29,940 --> 00:32:32,130
allow us to spawn a subprocess which is

834
00:32:32,130 --> 00:32:33,990
going to crash and that's going to allow

835
00:32:33,990 --> 00:32:36,390
our main application to continue running

836
00:32:36,390 --> 00:32:38,220
the exploit after our sub process

837
00:32:38,220 --> 00:32:42,150
crashes so how are you doing on iOS so

838
00:32:42,150 --> 00:32:44,730
far even though it's more complicated we

839
00:32:44,730 --> 00:32:47,820
now know how to trigger the bug and this

840
00:32:47,820 --> 00:32:49,500
is going to be done by actually crashing

841
00:32:49,500 --> 00:32:51,870
maliciously and we can use an app

842
00:32:51,870 --> 00:32:54,000
extension to free ma quartz in launch

843
00:32:54,000 --> 00:32:56,730
key which is going to allow our main

844
00:32:56,730 --> 00:32:58,470
executable payload to continue running

845
00:32:58,470 --> 00:33:00,720
to take advantage of the dangling port

846
00:33:00,720 --> 00:33:02,850
and additionally our service

847
00:33:02,850 --> 00:33:04,679
impersonation strategy from Mac OS

848
00:33:04,679 --> 00:33:07,200
actually still works perfectly on iOS so

849
00:33:07,200 --> 00:33:09,419
we can just transplant like all the code

850
00:33:09,419 --> 00:33:10,590
for Mac OS that did service

851
00:33:10,590 --> 00:33:12,780
impersonation works directly on top of

852
00:33:12,780 --> 00:33:15,750
our new exploitation technique so all

853
00:33:15,750 --> 00:33:17,880
that's really left is to figure out how

854
00:33:17,880 --> 00:33:20,190
to use service impersonation on iOS to

855
00:33:20,190 --> 00:33:23,250
elevate privileges so let's look at a

856
00:33:23,250 --> 00:33:25,440
first attempt how to use service

857
00:33:25,440 --> 00:33:28,200
impersonation elevate privileges so once

858
00:33:28,200 --> 00:33:29,460
again we're going to need to choose the

859
00:33:29,460 --> 00:33:31,650
right service to impersonate to elevate

860
00:33:31,650 --> 00:33:34,440
privileges and unfortunately on iOS is

861
00:33:34,440 --> 00:33:36,419
actually a lot more difficult because

862
00:33:36,419 --> 00:33:39,059
there are no unsane boss troop processes

863
00:33:39,059 --> 00:33:41,490
that send their task ports to a mock

864
00:33:41,490 --> 00:33:44,100
service so using the direct service

865
00:33:44,100 --> 00:33:46,080
impersonation get a task court strategy

866
00:33:46,080 --> 00:33:49,130
actually doesn't work for us nonetheless

867
00:33:49,130 --> 00:33:51,780
even though the traditional approach

868
00:33:51,780 --> 00:33:54,570
doesn't work we actually can devise our

869
00:33:54,570 --> 00:33:58,289
own strategy for gaining a task port

870
00:33:58,289 --> 00:34:00,419
using everything that we already know so

871
00:34:00,419 --> 00:34:04,020
far see exception messages contain tasks

872
00:34:04,020 --> 00:34:07,440
ports and report crash itself is

873
00:34:07,440 --> 00:34:10,800
unsanded and runs as route so why not

874
00:34:10,800 --> 00:34:13,469
impersonate safety net and then trigger

875
00:34:13,469 --> 00:34:17,070
a crash and report crash see report

876
00:34:17,070 --> 00:34:18,989
crash set safety Nats its exception

877
00:34:18,989 --> 00:34:21,210
handler on launch so if we can

878
00:34:21,210 --> 00:34:22,980
impersonate safety net first before

879
00:34:22,980 --> 00:34:25,379
report crash actually starts up then

880
00:34:25,379 --> 00:34:27,090
launch D is going to tell report crash

881
00:34:27,090 --> 00:34:29,639
that we are safety net and so report

882
00:34:29,639 --> 00:34:31,409
crash is going to set us as its

883
00:34:31,409 --> 00:34:34,050
exception handler instead and at this

884
00:34:34,050 --> 00:34:36,179
point we can alpha force report crash

885
00:34:36,179 --> 00:34:38,250
generate an exception for example by

886
00:34:38,250 --> 00:34:39,668
sending a malformed

887
00:34:39,668 --> 00:34:40,690
Mach message that causes an

888
00:34:40,690 --> 00:34:42,668
out-of-bounds read which is really easy

889
00:34:42,668 --> 00:34:44,230
they have like not checked any of this

890
00:34:44,230 --> 00:34:46,809
code for out-of-bounds read issues and

891
00:34:46,809 --> 00:34:48,819
then basically the kernel is just going

892
00:34:48,819 --> 00:34:51,099
to send us report crashes task port an

893
00:34:51,099 --> 00:34:52,780
exception message because we're the

894
00:34:52,780 --> 00:34:54,399
registered exception handlers for report

895
00:34:54,399 --> 00:34:56,679
rash and at this point we just use

896
00:34:56,679 --> 00:34:58,329
report crashes task port execute

897
00:34:58,329 --> 00:35:03,010
arbitrary code now this sounds great but

898
00:35:03,010 --> 00:35:04,990
it actually isn't quite that easy and

899
00:35:04,990 --> 00:35:08,859
the problem is that safety net report

900
00:35:08,859 --> 00:35:10,660
crash set safety net as its exception

901
00:35:10,660 --> 00:35:12,880
handler for ex crash which is not a

902
00:35:12,880 --> 00:35:15,190
recoverable exception type by the time

903
00:35:15,190 --> 00:35:18,460
we get report crashes task fort report

904
00:35:18,460 --> 00:35:20,619
crash is already in process exit and is

905
00:35:20,619 --> 00:35:22,180
no longer going to be scheduled on the

906
00:35:22,180 --> 00:35:25,420
CPU thus there's no way to use report

907
00:35:25,420 --> 00:35:27,670
crashes task 4 to execute code even

908
00:35:27,670 --> 00:35:29,799
though we get the task port we can't

909
00:35:29,799 --> 00:35:32,010
actually do anything useful with it

910
00:35:32,010 --> 00:35:35,049
nonetheless even though we can't use

911
00:35:35,049 --> 00:35:37,319
report crashes task port to execute code

912
00:35:37,319 --> 00:35:40,569
one thing we still can do with it is to

913
00:35:40,569 --> 00:35:42,490
steal mock ports from report crash and

914
00:35:42,490 --> 00:35:44,410
if we go back to the list of report

915
00:35:44,410 --> 00:35:45,700
crashes mock reports from earlier

916
00:35:45,700 --> 00:35:48,040
there's one that really stands out as

917
00:35:48,040 --> 00:35:50,559
being very useful for exploitation which

918
00:35:50,559 --> 00:35:53,079
is this thing called the host report now

919
00:35:53,079 --> 00:35:55,210
the host perf port is another special

920
00:35:55,210 --> 00:35:56,890
mock port which is owned by the kernel

921
00:35:56,890 --> 00:35:59,290
and you need to have this port in order

922
00:35:59,290 --> 00:36:01,839
to call many important system calls so

923
00:36:01,839 --> 00:36:03,400
for example the way that report crash

924
00:36:03,400 --> 00:36:05,680
registers to receive exceptions in all

925
00:36:05,680 --> 00:36:07,839
processes on the system is with a call

926
00:36:07,839 --> 00:36:10,089
to host set exception ports and the host

927
00:36:10,089 --> 00:36:13,329
port must be the first argument so even

928
00:36:13,329 --> 00:36:16,089
though we can't execute code we can use

929
00:36:16,089 --> 00:36:18,460
report crashes task 4 to steal the host

930
00:36:18,460 --> 00:36:20,260
proof port which is going to give us

931
00:36:20,260 --> 00:36:22,839
access to new and exciting system calls

932
00:36:22,839 --> 00:36:25,170
like host set exception reports and

933
00:36:25,170 --> 00:36:27,760
actually if you think about it

934
00:36:27,760 --> 00:36:30,280
host set exception ports Act also gives

935
00:36:30,280 --> 00:36:32,980
us a new way forward which is to set a

936
00:36:32,980 --> 00:36:35,589
new recoverable host level exception

937
00:36:35,589 --> 00:36:37,450
handler and then run our same old

938
00:36:37,450 --> 00:36:40,349
exploit that we just did a second time

939
00:36:40,349 --> 00:36:43,059
so the exploits gonna start off the same

940
00:36:43,059 --> 00:36:44,770
as before we're going to impersonate

941
00:36:44,770 --> 00:36:47,859
safety net trigger crash and trigger a

942
00:36:47,859 --> 00:36:50,170
crash and report crash then we're going

943
00:36:50,170 --> 00:36:51,309
to receive an exception message

944
00:36:51,309 --> 00:36:52,910
containing your port crashes

945
00:36:52,910 --> 00:36:55,610
sport which we then used to extract the

946
00:36:55,610 --> 00:36:58,040
hosts purport once we have the host

947
00:36:58,040 --> 00:36:59,810
birth port we can call host site

948
00:36:59,810 --> 00:37:02,750
exception ports to register ourselves as

949
00:37:02,750 --> 00:37:05,240
the new host level exception handler but

950
00:37:05,240 --> 00:37:07,010
this time for a recoverable exception

951
00:37:07,010 --> 00:37:10,130
type like expat access and then we just

952
00:37:10,130 --> 00:37:12,500
do the same exploit a second time we

953
00:37:12,500 --> 00:37:14,180
trigger a bad memory access and report

954
00:37:14,180 --> 00:37:16,040
crash and receive another exception

955
00:37:16,040 --> 00:37:17,630
message with report crashes task port

956
00:37:17,630 --> 00:37:20,150
and this time because the exception is

957
00:37:20,150 --> 00:37:22,390
recoverable we can just fix up the

958
00:37:22,390 --> 00:37:24,860
report crash that's no longer crashing

959
00:37:24,860 --> 00:37:29,830
and then execute arbitrary code so this

960
00:37:29,830 --> 00:37:32,570
once again this almost works but it's

961
00:37:32,570 --> 00:37:35,930
not quite that easy and actually if you

962
00:37:35,930 --> 00:37:37,430
extract if you do this exploit

963
00:37:37,430 --> 00:37:39,590
extracting the host proof port does work

964
00:37:39,590 --> 00:37:42,590
so we do end up with a host report but

965
00:37:42,590 --> 00:37:44,300
if we try to call host set exception

966
00:37:44,300 --> 00:37:46,910
ports that part actually fails and the

967
00:37:46,910 --> 00:37:49,100
reason for that is host exception ports

968
00:37:49,100 --> 00:37:52,670
is forbidden inside the sandbox so it's

969
00:37:52,670 --> 00:37:54,800
a great idea but we also need a sandbox

970
00:37:54,800 --> 00:37:57,890
escape so how are we going to go forward

971
00:37:57,890 --> 00:38:00,700
we'll just escape the sandbox it's easy

972
00:38:00,700 --> 00:38:02,930
so how are we going to escape the

973
00:38:02,930 --> 00:38:05,510
sandbox well we already have this mock

974
00:38:05,510 --> 00:38:07,520
service impersonation primitive so

975
00:38:07,520 --> 00:38:08,810
rather than trying to find a whole

976
00:38:08,810 --> 00:38:10,640
nother vulnerability let's just reuse

977
00:38:10,640 --> 00:38:12,230
the vulnerabilities that we already have

978
00:38:12,230 --> 00:38:15,110
a second time so once again we're going

979
00:38:15,110 --> 00:38:16,580
to need to find the right service to

980
00:38:16,580 --> 00:38:19,100
impersonate and this time we can

981
00:38:19,100 --> 00:38:21,530
actually use the mock portal strategy

982
00:38:21,530 --> 00:38:23,750
which is to impersonate a service to

983
00:38:23,750 --> 00:38:27,590
which an unsanded task port now this

984
00:38:27,590 --> 00:38:29,450
didn't work for us last time because we

985
00:38:29,450 --> 00:38:37,010
needed to target an unsuitable clients

986
00:38:37,010 --> 00:38:38,900
do exist because this time we don't need

987
00:38:38,900 --> 00:38:41,000
the client to be route we just need it

988
00:38:41,000 --> 00:38:42,770
to be on the sandbox because we just

989
00:38:42,770 --> 00:38:46,130
need the sandbox escape part so

990
00:38:46,130 --> 00:38:50,090
basically I used a very nice technique

991
00:38:50,090 --> 00:38:52,190
of just impersonating every single mock

992
00:38:52,190 --> 00:38:54,560
service on the phone and eventually

993
00:38:54,560 --> 00:38:55,760
found through this brute-force search

994
00:38:55,760 --> 00:38:58,130
that the druid daemon which is

995
00:38:58,130 --> 00:38:59,750
responsible for handling like drag and

996
00:38:59,750 --> 00:39:01,310
drop like when you drag things on your

997
00:39:01,310 --> 00:39:04,730
iPhone screen actually sends its task

998
00:39:04,730 --> 00:39:05,840
fork to

999
00:39:05,840 --> 00:39:08,330
a service called calmed Apple dossier

1000
00:39:08,330 --> 00:39:11,840
render server and the druid process is

1001
00:39:11,840 --> 00:39:14,810
actually on sandboxed so we do have a

1002
00:39:14,810 --> 00:39:17,120
complete sandbox escape which is to

1003
00:39:17,120 --> 00:39:19,400
impersonate see a render server and then

1004
00:39:19,400 --> 00:39:21,860
just trigger druid to start and when

1005
00:39:21,860 --> 00:39:23,690
druid starts up its going to send it to

1006
00:39:23,690 --> 00:39:25,370
task fork to see a render server which

1007
00:39:25,370 --> 00:39:27,590
were impersonating so we get druids task

1008
00:39:27,590 --> 00:39:30,050
court which means we now have arbitrary

1009
00:39:30,050 --> 00:39:32,210
code execution inside of druid which is

1010
00:39:32,210 --> 00:39:34,150
on sandbox

1011
00:39:34,150 --> 00:39:36,530
unfortunately once again it's not

1012
00:39:36,530 --> 00:39:39,080
actually that easy and the reason is

1013
00:39:39,080 --> 00:39:41,480
that apple is added mitigation so if you

1014
00:39:41,480 --> 00:39:42,770
actually look through the source code of

1015
00:39:42,770 --> 00:39:45,470
xnu you'll find there's a new mitigation

1016
00:39:45,470 --> 00:39:47,360
in a function called task conversion

1017
00:39:47,360 --> 00:39:49,700
eval with a comment that says on

1018
00:39:49,700 --> 00:39:52,370
embedded platforms only a platform

1019
00:39:52,370 --> 00:39:54,200
binary can resolve the task fork of

1020
00:39:54,200 --> 00:39:56,600
another platform binary what this means

1021
00:39:56,600 --> 00:40:00,320
concretely is that on iOS we can't use

1022
00:40:00,320 --> 00:40:03,320
the task port of an apple scient process

1023
00:40:03,320 --> 00:40:06,410
to modify it unless our own process is

1024
00:40:06,410 --> 00:40:08,510
also directly signed by apple and

1025
00:40:08,510 --> 00:40:10,700
clearly apple's never going to directly

1026
00:40:10,700 --> 00:40:13,820
sign our exploit code so even though we

1027
00:40:13,820 --> 00:40:16,070
have druids task court we can't actually

1028
00:40:16,070 --> 00:40:19,130
use that task court to modify druid so

1029
00:40:19,130 --> 00:40:20,750
if we go back to the diagram that i

1030
00:40:20,750 --> 00:40:23,570
poked fun of earlier apple's effectively

1031
00:40:23,570 --> 00:40:26,570
blocked us at this step so we can't use

1032
00:40:26,570 --> 00:40:29,000
the task port that we've obtained to

1033
00:40:29,000 --> 00:40:31,430
call mach vm read or monk damn right so

1034
00:40:31,430 --> 00:40:34,100
we can't modify druids memory now this

1035
00:40:34,100 --> 00:40:35,870
seems like a really robust mitigation

1036
00:40:35,870 --> 00:40:37,940
but i was way too far down the rabbit

1037
00:40:37,940 --> 00:40:40,250
hole at this point to give up here so i

1038
00:40:40,250 --> 00:40:42,040
started looking for a way to bypass it

1039
00:40:42,040 --> 00:40:44,330
and it turns out there's actually a

1040
00:40:44,330 --> 00:40:45,980
pretty big loophole which is this

1041
00:40:45,980 --> 00:40:48,500
function task threads so task threads

1042
00:40:48,500 --> 00:40:50,360
returns a list of threads in a

1043
00:40:50,360 --> 00:40:53,210
particular task but it's semantics are

1044
00:40:53,210 --> 00:40:56,360
really really important c task threads

1045
00:40:56,360 --> 00:40:59,380
takes an inspection right to a task and

1046
00:40:59,380 --> 00:41:02,090
inspection rights are not subject to the

1047
00:41:02,090 --> 00:41:04,270
task conversion eval mitigation

1048
00:41:04,270 --> 00:41:07,910
meanwhile task threads returns a list of

1049
00:41:07,910 --> 00:41:10,510
control rights for a tasks threads and

1050
00:41:10,510 --> 00:41:13,640
control rights are also not restricted

1051
00:41:13,640 --> 00:41:15,380
by the mitigation you're there's no

1052
00:41:15,380 --> 00:41:17,380
restriction on a non platform binary

1053
00:41:17,380 --> 00:41:18,950
controlling the thread

1054
00:41:18,950 --> 00:41:21,560
of a platform binary just it's tasks for

1055
00:41:21,560 --> 00:41:24,349
it so while it's nominally true that we

1056
00:41:24,349 --> 00:41:26,240
can't modify druid directly using its

1057
00:41:26,240 --> 00:41:29,599
passport we can call task threads to get

1058
00:41:29,599 --> 00:41:31,460
a thread port and then control that

1059
00:41:31,460 --> 00:41:34,099
threads register values directly so if

1060
00:41:34,099 --> 00:41:35,570
we go back to our diagram from earlier

1061
00:41:35,570 --> 00:41:37,520
all we have to do is to ignore the

1062
00:41:37,520 --> 00:41:40,339
mitigated path altogether and instead

1063
00:41:40,339 --> 00:41:43,099
call task threads which is not protected

1064
00:41:43,099 --> 00:41:45,410
and this is going to give us a thread

1065
00:41:45,410 --> 00:41:47,900
port for one of Druids threads and once

1066
00:41:47,900 --> 00:41:49,940
we have a thread port we can call thread

1067
00:41:49,940 --> 00:41:52,550
set state which is again not protected

1068
00:41:52,550 --> 00:41:58,369
and then we have BC control so we at

1069
00:41:58,369 --> 00:42:00,470
this point now have a complete sandbox

1070
00:42:00,470 --> 00:42:03,470
escape so first we're going to use the

1071
00:42:03,470 --> 00:42:05,329
launch D vulnerability to impersonate CI

1072
00:42:05,329 --> 00:42:07,760
render server then we trigger the druid

1073
00:42:07,760 --> 00:42:10,400
daemon to start druid will send us its

1074
00:42:10,400 --> 00:42:12,680
task port in a mock message intended for

1075
00:42:12,680 --> 00:42:15,530
C a render server and finally we use

1076
00:42:15,530 --> 00:42:17,720
drudes task port along with the task

1077
00:42:17,720 --> 00:42:19,460
threads loophole to execute arbitrary

1078
00:42:19,460 --> 00:42:23,480
code outside the sandbox and so finally

1079
00:42:23,480 --> 00:42:25,869
it's time for the complete iOS exploit

1080
00:42:25,869 --> 00:42:27,859
so first we're going to impersonate

1081
00:42:27,859 --> 00:42:30,349
safety net crash report crash and get

1082
00:42:30,349 --> 00:42:33,200
the host proof port next we impersonate

1083
00:42:33,200 --> 00:42:35,599
C a render server force druid to start

1084
00:42:35,599 --> 00:42:38,349
and get druids task port then we combine

1085
00:42:38,349 --> 00:42:41,060
the host proof port with on sand box

1086
00:42:41,060 --> 00:42:43,400
code execution and inside of druid to

1087
00:42:43,400 --> 00:42:45,500
register ourselves as the new host level

1088
00:42:45,500 --> 00:42:48,890
exception handler for X bad access then

1089
00:42:48,890 --> 00:42:50,690
we trigger a bad memory access inside a

1090
00:42:50,690 --> 00:42:52,609
report crash causing us to receive

1091
00:42:52,609 --> 00:42:54,920
report crashes task or a second time and

1092
00:42:54,920 --> 00:42:57,829
then finally we can now use this task

1093
00:42:57,829 --> 00:43:00,589
port to execute pretory code so

1094
00:43:00,589 --> 00:43:02,200
graphically I think it's a lot clearer

1095
00:43:02,200 --> 00:43:04,940
here all the processes involved a little

1096
00:43:04,940 --> 00:43:07,060
more complicated than the mac OS case

1097
00:43:07,060 --> 00:43:09,530
blanket is our attacking process on the

1098
00:43:09,530 --> 00:43:11,960
bottom that's in blue launch D is in the

1099
00:43:11,960 --> 00:43:14,359
center all the arrows once again

1100
00:43:14,359 --> 00:43:16,430
represent having mock send writes to the

1101
00:43:16,430 --> 00:43:18,800
destination report crashes on the left

1102
00:43:18,800 --> 00:43:20,599
with safety net as this registered

1103
00:43:20,599 --> 00:43:23,030
exception Handler and druid is on the

1104
00:43:23,030 --> 00:43:26,030
right talking with CI render server so

1105
00:43:26,030 --> 00:43:28,130
first we're going to start our crasher

1106
00:43:28,130 --> 00:43:29,690
app extension which is going to register

1107
00:43:29,690 --> 00:43:31,310
launch D as its exception

1108
00:43:31,310 --> 00:43:33,620
handler Forex crash and then it's going

1109
00:43:33,620 --> 00:43:34,700
to crash maliciously

1110
00:43:34,700 --> 00:43:36,710
and this is going to cause launch DS

1111
00:43:36,710 --> 00:43:39,650
send right to safety net to be freed

1112
00:43:39,650 --> 00:43:41,540
we now register a bunch of dummy mock

1113
00:43:41,540 --> 00:43:44,030
services with launch D until one of the

1114
00:43:44,030 --> 00:43:46,880
service ports reuses the safety net port

1115
00:43:46,880 --> 00:43:49,910
name at which point launch D now thinks

1116
00:43:49,910 --> 00:43:53,000
that we are safety net we now we send a

1117
00:43:53,000 --> 00:43:54,860
message to report crash which causes it

1118
00:43:54,860 --> 00:43:57,170
to crash and when report crash starts up

1119
00:43:57,170 --> 00:43:59,330
again it's going to ask launch D hey who

1120
00:43:59,330 --> 00:44:01,430
is safety net and long she's gonna reply

1121
00:44:01,430 --> 00:44:03,620
that we are safety net so report crash

1122
00:44:03,620 --> 00:44:05,210
is going to register us at this

1123
00:44:05,210 --> 00:44:07,820
exception handler we now send another

1124
00:44:07,820 --> 00:44:09,530
message to report crash causing it to

1125
00:44:09,530 --> 00:44:12,050
crash and this time we are the rest or

1126
00:44:12,050 --> 00:44:14,270
exception handler and so we get the

1127
00:44:14,270 --> 00:44:16,310
exception message and that allows us to

1128
00:44:16,310 --> 00:44:18,890
use report crashes task port to extract

1129
00:44:18,890 --> 00:44:21,650
the host proof port and we're just gonna

1130
00:44:21,650 --> 00:44:24,410
save the host / port for later now we're

1131
00:44:24,410 --> 00:44:26,390
going to repeat the same attack against

1132
00:44:26,390 --> 00:44:28,790
CA render server and druid we start up

1133
00:44:28,790 --> 00:44:30,590
our crash or app extension again which

1134
00:44:30,590 --> 00:44:32,120
registers launch gate the deception

1135
00:44:32,120 --> 00:44:33,650
handler and then process maliciously

1136
00:44:33,650 --> 00:44:35,930
causing launch D to free its send right

1137
00:44:35,930 --> 00:44:38,510
to see a render server we now register a

1138
00:44:38,510 --> 00:44:40,100
bunch of dummy mock services with launch

1139
00:44:40,100 --> 00:44:42,680
key and get the ca renders her report

1140
00:44:42,680 --> 00:44:45,230
name reused by port that we own at which

1141
00:44:45,230 --> 00:44:46,790
point launch D now thinks that we are

1142
00:44:46,790 --> 00:44:49,010
see our render server we now send a

1143
00:44:49,010 --> 00:44:50,600
message to Druitt causing it to crash

1144
00:44:50,600 --> 00:44:52,940
and when druid starts up again it's

1145
00:44:52,940 --> 00:44:55,580
going to ask launch D hey who is CI

1146
00:44:55,580 --> 00:44:57,860
render server and launching a reply that

1147
00:44:57,860 --> 00:44:59,990
we are see a render server so druid will

1148
00:44:59,990 --> 00:45:02,180
start talking to us and will send us its

1149
00:45:02,180 --> 00:45:05,630
task fort we now take the task fort and

1150
00:45:05,630 --> 00:45:07,310
use the task threads loophole from

1151
00:45:07,310 --> 00:45:09,410
earlier to get arbitrary code execution

1152
00:45:09,410 --> 00:45:12,020
inside of druid and then we send the

1153
00:45:12,020 --> 00:45:13,550
host proof port over to druid and

1154
00:45:13,550 --> 00:45:16,160
combining host probe with unsound box

1155
00:45:16,160 --> 00:45:18,890
code execution we can now set ourselves

1156
00:45:18,890 --> 00:45:21,110
as the new host level exception handler

1157
00:45:21,110 --> 00:45:23,990
for ex bat access at this point we now

1158
00:45:23,990 --> 00:45:26,210
repeat the first leg of the attack we

1159
00:45:26,210 --> 00:45:28,070
make report crash start up again and

1160
00:45:28,070 --> 00:45:29,900
send it a message causing it to crash

1161
00:45:29,900 --> 00:45:32,360
and this time there is a registered

1162
00:45:32,360 --> 00:45:34,520
exception handler for ex bad access

1163
00:45:34,520 --> 00:45:36,410
which means that we received the

1164
00:45:36,410 --> 00:45:38,390
exception message and we get a copy for

1165
00:45:38,390 --> 00:45:41,000
poor crashes task port and this time the

1166
00:45:41,000 --> 00:45:42,440
exception is recoverable

1167
00:45:42,440 --> 00:45:44,290
so we use the task

1168
00:45:44,290 --> 00:45:46,990
to fix up report crash and then we use

1169
00:45:46,990 --> 00:45:49,380
it to take control of a report crash and

1170
00:45:49,380 --> 00:45:51,580
we can restore the hosts exception

1171
00:45:51,580 --> 00:45:54,340
handler to default now at this point we

1172
00:45:54,340 --> 00:45:56,230
can use report crashes task for PID

1173
00:45:56,230 --> 00:45:58,540
privileges to take control of her launch

1174
00:45:58,540 --> 00:46:00,250
team and once we have control over

1175
00:46:00,250 --> 00:46:02,020
launch D we can fix up the damage that

1176
00:46:02,020 --> 00:46:04,570
we did to launch D by restoring the

1177
00:46:04,570 --> 00:46:06,610
ports that we messed up earlier and then

1178
00:46:06,610 --> 00:46:08,620
finally we can make report crash spawn

1179
00:46:08,620 --> 00:46:10,930
our payload binary with full arbitrary

1180
00:46:10,930 --> 00:46:13,660
privileges and that's how you route an

1181
00:46:13,660 --> 00:46:18,370
iPhone by crashing so I was gonna do an

1182
00:46:18,370 --> 00:46:20,170
iOS demo but I think we don't have that

1183
00:46:20,170 --> 00:46:30,280
much time for it it's not actually that

1184
00:46:30,280 --> 00:46:32,050
exciting you just get a shell I mean

1185
00:46:32,050 --> 00:46:35,680
like everyone seen a shell about this

1186
00:46:35,680 --> 00:46:37,990
I'm going to do the setup now and then

1187
00:46:37,990 --> 00:46:39,730
we can do it at the very end so we can

1188
00:46:39,730 --> 00:46:42,040
get the more important contact content

1189
00:46:42,040 --> 00:46:44,950
first so what are the takeaways from

1190
00:46:44,950 --> 00:46:47,740
this whole research project first I want

1191
00:46:47,740 --> 00:46:48,940
to go over what we've actually achieved

1192
00:46:48,940 --> 00:46:51,250
and since this is the Mac OS conference

1193
00:46:51,250 --> 00:46:53,320
I'm going to focus on the Mac OS side of

1194
00:46:53,320 --> 00:46:54,160
it

1195
00:46:54,160 --> 00:46:56,170
so we've used a vulnerability in launch

1196
00:46:56,170 --> 00:46:58,690
D to take control of an assist on oast

1197
00:46:58,690 --> 00:47:01,300
process which has the task for PID allow

1198
00:47:01,300 --> 00:47:04,480
entitlement and as we've seen we can now

1199
00:47:04,480 --> 00:47:06,310
use this entitlement to take control

1200
00:47:06,310 --> 00:47:10,180
over any process on the system this is a

1201
00:47:10,180 --> 00:47:12,730
complete sit bypass because you have SIF

1202
00:47:12,730 --> 00:47:14,500
entitled processes on the system which

1203
00:47:14,500 --> 00:47:16,750
means you can inject into them and then

1204
00:47:16,750 --> 00:47:20,950
you know where is it now so you can

1205
00:47:20,950 --> 00:47:23,020
inject into processes like Tex D which

1206
00:47:23,020 --> 00:47:24,610
means that you also have arbitrary code

1207
00:47:24,610 --> 00:47:26,380
execution in the kernel which is kind of

1208
00:47:26,380 --> 00:47:27,400
fun

1209
00:47:27,400 --> 00:47:29,740
we basically managed to hop directly

1210
00:47:29,740 --> 00:47:31,930
from an unprivileged user all the way to

1211
00:47:31,930 --> 00:47:34,240
the kernel with one bug in a user space

1212
00:47:34,240 --> 00:47:37,020
process no need to you know bypass

1213
00:47:37,020 --> 00:47:39,820
kernel ASLR or anything like that so

1214
00:47:39,820 --> 00:47:43,660
that's pretty fun also the reason I

1215
00:47:43,660 --> 00:47:45,310
started looking at crash reporting to be

1216
00:47:45,310 --> 00:47:46,870
in with it was because it was an

1217
00:47:46,870 --> 00:47:48,540
unconventional attack surface

1218
00:47:48,540 --> 00:47:50,560
traditional attack surfaces that have

1219
00:47:50,560 --> 00:47:52,270
been used in past exploits have been

1220
00:47:52,270 --> 00:47:54,250
significantly hardened which makes

1221
00:47:54,250 --> 00:47:56,200
unconventional attack services much more

1222
00:47:56,200 --> 00:47:56,849
attractive

1223
00:47:56,849 --> 00:47:59,489
to exploit developers and many areas of

1224
00:47:59,489 --> 00:48:00,960
the operating system really haven't

1225
00:48:00,960 --> 00:48:02,700
received the security auditing that they

1226
00:48:02,700 --> 00:48:04,380
deserve given the huge level of

1227
00:48:04,380 --> 00:48:06,180
privilege that they will grant you if

1228
00:48:06,180 --> 00:48:09,509
you can successfully exploit them so

1229
00:48:09,509 --> 00:48:11,729
before I wrap up there's actually one

1230
00:48:11,729 --> 00:48:14,039
more thing that I want to talk about a

1231
00:48:14,039 --> 00:48:16,559
few years ago some random guy on the

1232
00:48:16,559 --> 00:48:18,660
internet named Patrick tweeted that he

1233
00:48:18,660 --> 00:48:20,660
was rather fond of a particular incident

1234
00:48:20,660 --> 00:48:23,640
this thing called comba Apple dot relist

1235
00:48:23,640 --> 00:48:26,069
on installed at heritable now I haven't

1236
00:48:26,069 --> 00:48:28,019
really seen anyone else extolling the

1237
00:48:28,019 --> 00:48:30,150
virtues of this entitlement so I figured

1238
00:48:30,150 --> 00:48:32,099
I'd give you a quick demo of how nifty

1239
00:48:32,099 --> 00:48:35,069
this thing can be so just like the non

1240
00:48:35,069 --> 00:48:36,989
heritable version the root Lestat

1241
00:48:36,989 --> 00:48:39,150
install dot heritable entitlement allows

1242
00:48:39,150 --> 00:48:41,479
a process to modify sip protected files

1243
00:48:41,479 --> 00:48:44,519
however this entitlement is inherited by

1244
00:48:44,519 --> 00:48:47,489
any child processes that start up and so

1245
00:48:47,489 --> 00:48:49,440
this gave me an idea which is why not

1246
00:48:49,440 --> 00:48:52,229
use tasks for PID to spawn a bash shell

1247
00:48:52,229 --> 00:48:55,650
from inside a protected inside a process

1248
00:48:55,650 --> 00:48:58,229
with this entitlement bash will inherit

1249
00:48:58,229 --> 00:49:00,809
the rootless entitlement and so will all

1250
00:49:00,809 --> 00:49:03,059
the processes that run inside this shell

1251
00:49:03,059 --> 00:49:05,999
and then we effectively get a rootless I

1252
00:49:05,999 --> 00:49:07,650
guess it's more of like a root full

1253
00:49:07,650 --> 00:49:10,489
shell because you unroot 'less anyone

1254
00:49:10,489 --> 00:49:13,259
you basically get a shell where all of

1255
00:49:13,259 --> 00:49:14,999
your sip file system protections are now

1256
00:49:14,999 --> 00:49:16,739
disabled because all the processes

1257
00:49:16,739 --> 00:49:18,569
running inside this context have this

1258
00:49:18,569 --> 00:49:20,039
rootless not installed on heritable

1259
00:49:20,039 --> 00:49:22,440
entitlement and you do all of this

1260
00:49:22,440 --> 00:49:23,940
without any kernel modification

1261
00:49:23,940 --> 00:49:26,910
whatsoever which is like kind of nice so

1262
00:49:26,910 --> 00:49:33,229
let's do a demo of this one here and so

1263
00:49:33,229 --> 00:49:35,940
same thing as before we're going to

1264
00:49:35,940 --> 00:49:40,859
launch launch deep or trap rootless so

1265
00:49:40,859 --> 00:49:44,849
actually before I do that let's do csru

1266
00:49:44,849 --> 00:49:48,950
till status to show that sip is enabled

1267
00:49:48,950 --> 00:49:54,589
sudo su so if we try to like touch

1268
00:49:54,589 --> 00:49:58,529
system exploit we can't do it

1269
00:49:58,529 --> 00:50:01,819
as you'd expect then launch key port Rev

1270
00:50:01,819 --> 00:50:06,210
rootless shell so we exploit the

1271
00:50:06,210 --> 00:50:10,250
vulnerability and we get a root shell

1272
00:50:10,250 --> 00:50:16,060
hopefully come on

1273
00:50:16,480 --> 00:50:19,040
sometimes it takes a while there we go

1274
00:50:19,040 --> 00:50:22,130
okay so now we have a root shell and you

1275
00:50:22,130 --> 00:50:26,330
can see csru till status again we still

1276
00:50:26,330 --> 00:50:28,580
have SIPP enabled but now there's no

1277
00:50:28,580 --> 00:50:29,450
problem at all

1278
00:50:29,450 --> 00:50:34,430
touching system exploit yeah what rule

1279
00:50:34,430 --> 00:50:42,170
is so you can see our exploit file is

1280
00:50:42,170 --> 00:50:45,200
there and we can also now exit the shell

1281
00:50:45,200 --> 00:50:48,290
and sudo again and if we try to remove

1282
00:50:48,290 --> 00:50:54,880
it nope can't do it sorry

1283
00:50:54,880 --> 00:50:58,010
so basically we have a bash shell

1284
00:50:58,010 --> 00:51:00,110
running with this entitlement all the

1285
00:51:00,110 --> 00:51:01,940
sub processes now have this rootless

1286
00:51:01,940 --> 00:51:04,670
entitlement as well so it's basically

1287
00:51:04,670 --> 00:51:07,130
like you know classic mac with no lists

1288
00:51:07,130 --> 00:51:08,960
all in your shell which is kind of nice

1289
00:51:08,960 --> 00:51:11,300
I mean clearly you can do anything you

1290
00:51:11,300 --> 00:51:12,950
want because you already have kernel

1291
00:51:12,950 --> 00:51:15,620
anyway but it's just convenient and kind

1292
00:51:15,620 --> 00:51:16,250
of a neat trick

1293
00:51:16,250 --> 00:51:19,970
so yeah let me get back where's my mouse

1294
00:51:19,970 --> 00:51:24,050
there we are yeah and that's it so thank

1295
00:51:24,050 --> 00:51:27,800
you very much you can find the exploit

1296
00:51:27,800 --> 00:51:29,980
curve

1297
00:51:33,820 --> 00:51:36,470
so the exploit codes on my github you

1298
00:51:36,470 --> 00:51:39,410
can look at it if you want and yeah

1299
00:51:39,410 --> 00:51:47,210
thank you very much so any questions I'm

1300
00:51:47,210 --> 00:51:49,940
not sure if I can comment on that I'm

1301
00:51:49,940 --> 00:51:52,570
not totally sure what the rules are

1302
00:51:52,570 --> 00:51:59,020
about that but yeah thank you thank you

1303
00:51:59,020 --> 00:52:00,650
any other questions

1304
00:52:00,650 --> 00:52:04,640
yeah yes yeah this was patched in July I

1305
00:52:04,640 --> 00:52:12,500
believe so it's been a while the actual

1306
00:52:12,500 --> 00:52:15,140
process was in terming so the question

1307
00:52:15,140 --> 00:52:16,460
was how long did it take to actually

1308
00:52:16,460 --> 00:52:18,740
figure all of this out

1309
00:52:18,740 --> 00:52:20,630
the process was intermingled with a

1310
00:52:20,630 --> 00:52:22,220
bunch of other security research so it's

1311
00:52:22,220 --> 00:52:24,770
not an easy answer because it's hard to

1312
00:52:24,770 --> 00:52:26,270
kind of extract when I was working on

1313
00:52:26,270 --> 00:52:29,089
this versus other stuff the core of the

1314
00:52:29,089 --> 00:52:33,140
exploit on iOS the like strict time

1315
00:52:33,140 --> 00:52:35,810
bounds are from between January and

1316
00:52:35,810 --> 00:52:42,530
April so sometime up to four months the

1317
00:52:42,530 --> 00:52:45,230
Mac OS part of it took almost no time at

1318
00:52:45,230 --> 00:52:45,500
all

1319
00:52:45,500 --> 00:52:46,880
because it was literally just like

1320
00:52:46,880 --> 00:52:49,070
copying in beers old code and like re

1321
00:52:49,070 --> 00:52:53,990
running it with a different bug all

1322
00:52:53,990 --> 00:52:57,440
right any other questions well thank you

1323
00:52:57,440 --> 00:52:58,730
very much

1324
00:52:58,730 --> 00:53:07,170
[Applause]

