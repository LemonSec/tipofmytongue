1
00:00:11,120 --> 00:00:13,360
all right guys so welcome everybody one

2
00:00:13,360 --> 00:00:15,280
more time and our today's talk regarding

3
00:00:15,280 --> 00:00:17,520
marvel development my name is pavel

4
00:00:17,520 --> 00:00:20,000
gordos and today with my friend patrick

5
00:00:20,000 --> 00:00:21,920
cheshko would like to introduce you into

6
00:00:21,920 --> 00:00:23,680
a world of warm album development for

7
00:00:23,680 --> 00:00:26,800
advanced adversary emulation patrick one

8
00:00:26,800 --> 00:00:28,240
word from you

9
00:00:28,240 --> 00:00:32,079
sure so hi everybody uh

10
00:00:32,079 --> 00:00:33,920
some some words about me

11
00:00:33,920 --> 00:00:36,559
so i currently work uh in the purple

12
00:00:36,559 --> 00:00:39,120
team in standard chartered so

13
00:00:39,120 --> 00:00:41,200
in a global bank and we are forming a

14
00:00:41,200 --> 00:00:43,280
property capability there previously i

15
00:00:43,280 --> 00:00:46,640
worked with pablo at deloitte and we did

16
00:00:46,640 --> 00:00:48,800
a lot of red teaming for i think four or

17
00:00:48,800 --> 00:00:51,280
five years

18
00:00:51,280 --> 00:00:53,360
yeah we we we've been working uh

19
00:00:53,360 --> 00:00:55,199
together for a couple of years it's been

20
00:00:55,199 --> 00:00:57,039
a great journey uh we've been we've

21
00:00:57,039 --> 00:00:59,199
gained a lot of knowledge and one of the

22
00:00:59,199 --> 00:01:01,680
main tasks that we have to do was the

23
00:01:01,680 --> 00:01:03,600
rethink so uh when it comes to the

24
00:01:03,600 --> 00:01:05,600
directing one of the essential things

25
00:01:05,600 --> 00:01:07,760
actually contact the custom tools and

26
00:01:07,760 --> 00:01:09,680
custom malware because when you use like

27
00:01:09,680 --> 00:01:11,520
well-known solution of course it will be

28
00:01:11,520 --> 00:01:12,479
obviously

29
00:01:12,479 --> 00:01:14,720
also well known flagged in a multiple

30
00:01:14,720 --> 00:01:16,880
antivirus solutions so we started

31
00:01:16,880 --> 00:01:19,040
developing our own tools and today we

32
00:01:19,040 --> 00:01:20,960
want to share the knowledge with you

33
00:01:20,960 --> 00:01:24,560
so the presentation will consist of four

34
00:01:24,560 --> 00:01:27,439
main steps first first we'd like to talk

35
00:01:27,439 --> 00:01:30,799
with you about how the malware is being

36
00:01:30,799 --> 00:01:32,799
prevented from spreading and running and

37
00:01:32,799 --> 00:01:35,119
how it is detected because obviously you

38
00:01:35,119 --> 00:01:36,720
need to know that once you want to

39
00:01:36,720 --> 00:01:37,680
actually

40
00:01:37,680 --> 00:01:38,880
evade that

41
00:01:38,880 --> 00:01:40,640
second a few words about malware

42
00:01:40,640 --> 00:01:43,200
delivery then some covert loader

43
00:01:43,200 --> 00:01:45,280
architecture overview and we will

44
00:01:45,280 --> 00:01:47,920
develop some malicious loader

45
00:01:47,920 --> 00:01:50,399
and shallow share certain techniques

46
00:01:50,399 --> 00:01:53,280
regarding uh evasions of both antivirus

47
00:01:53,280 --> 00:01:56,719
solutions and malware analytics

48
00:01:56,719 --> 00:01:59,439
yeah so maybe let's start uh start with

49
00:01:59,439 --> 00:02:00,399
that

50
00:02:00,399 --> 00:02:03,119
so when it comes to facing your actually

51
00:02:03,119 --> 00:02:05,439
opponent uh what it will be

52
00:02:05,439 --> 00:02:07,840
first of course those will be antivirus

53
00:02:07,840 --> 00:02:11,120
solutions and edr tools but also you

54
00:02:11,120 --> 00:02:13,440
have to remember that you will be facing

55
00:02:13,440 --> 00:02:16,879
some kind of malware analytics so let's

56
00:02:16,879 --> 00:02:19,040
start from the from the beginning let's

57
00:02:19,040 --> 00:02:21,200
talk briefly about how the antivirus

58
00:02:21,200 --> 00:02:24,160
works so there are like the four main

59
00:02:24,160 --> 00:02:27,280
stages of of each antivirus solution

60
00:02:27,280 --> 00:02:30,720
first one and oldest the simplest one is

61
00:02:30,720 --> 00:02:33,040
the signature based detection so what

62
00:02:33,040 --> 00:02:36,160
the solution do is basically compare

63
00:02:36,160 --> 00:02:38,319
like the checksum or known strings or

64
00:02:38,319 --> 00:02:40,879
node byte sequences with its own word

65
00:02:40,879 --> 00:02:43,840
list so it can it knows that this kind

66
00:02:43,840 --> 00:02:46,080
of file of this file will be malicious

67
00:02:46,080 --> 00:02:48,000
obviously this is like a very basic one

68
00:02:48,000 --> 00:02:50,640
the oldest way the way detection because

69
00:02:50,640 --> 00:02:53,760
you can actually easily bypass that

70
00:02:53,760 --> 00:02:55,840
the second step is the heuristic

71
00:02:55,840 --> 00:02:58,239
detection so we got the static analysis

72
00:02:58,239 --> 00:03:00,879
of application behavior and you also

73
00:03:00,879 --> 00:03:03,519
tried the tools also try to identify

74
00:03:03,519 --> 00:03:05,760
potentially malicious characteristics

75
00:03:05,760 --> 00:03:08,239
and use the of the malicious functions

76
00:03:08,239 --> 00:03:10,480
because some functions are well known to

77
00:03:10,480 --> 00:03:13,280
be used by malware so uh antivirus want

78
00:03:13,280 --> 00:03:15,840
to know if the function is being used we

79
00:03:15,840 --> 00:03:18,560
probably would like to hide them hide

80
00:03:18,560 --> 00:03:19,920
this from them

81
00:03:19,920 --> 00:03:21,200
the third step

82
00:03:21,200 --> 00:03:23,280
the most common one is the sandboxing

83
00:03:23,280 --> 00:03:25,040
sandboxing is basically a running

84
00:03:25,040 --> 00:03:27,440
software or

85
00:03:27,440 --> 00:03:29,760
unknown executable within a controllable

86
00:03:29,760 --> 00:03:33,440
environment and see what actually the uh

87
00:03:33,440 --> 00:03:35,200
software is doing so you can actually

88
00:03:35,200 --> 00:03:38,959
know uh the actions and by doing that

89
00:03:38,959 --> 00:03:41,840
then judge if the file is malicious or

90
00:03:41,840 --> 00:03:44,799
no and there are also some edr specific

91
00:03:44,799 --> 00:03:45,680
uh

92
00:03:45,680 --> 00:03:47,680
functions like function hooking and

93
00:03:47,680 --> 00:03:50,400
memory scanning we'll talk about this uh

94
00:03:50,400 --> 00:03:52,480
in a in a few seconds so those were

95
00:03:52,480 --> 00:03:55,040
those were the tools uh also you have to

96
00:03:55,040 --> 00:03:57,840
remember that you probably want to be

97
00:03:57,840 --> 00:04:00,799
want to somehow address malware

98
00:04:00,799 --> 00:04:02,319
analytics and

99
00:04:02,319 --> 00:04:05,120
the malware analysis which they do so

100
00:04:05,120 --> 00:04:07,040
what they do the first step like like

101
00:04:07,040 --> 00:04:09,040
previously is the static analysis static

102
00:04:09,040 --> 00:04:11,840
analysis is very simple uh just look at

103
00:04:11,840 --> 00:04:14,959
the information in the in a pe ap file

104
00:04:14,959 --> 00:04:16,798
you also can do some source code

105
00:04:16,798 --> 00:04:19,440
recovery analysis so they do that and

106
00:04:19,440 --> 00:04:22,000
they try to judge whether the file is

107
00:04:22,000 --> 00:04:24,880
safe or not then there's some dynamic

108
00:04:24,880 --> 00:04:26,000
analysis

109
00:04:26,000 --> 00:04:28,320
and here you got this analyzing

110
00:04:28,320 --> 00:04:30,720
analyzing of execution flow monitoring

111
00:04:30,720 --> 00:04:32,960
of file system register changes also

112
00:04:32,960 --> 00:04:35,680
file system changes you will you also

113
00:04:35,680 --> 00:04:37,919
want to know what is the network traffic

114
00:04:37,919 --> 00:04:40,720
so we can probably spot some uh

115
00:04:40,720 --> 00:04:42,400
adversary actions

116
00:04:42,400 --> 00:04:44,880
and the first the the last step is that

117
00:04:44,880 --> 00:04:47,919
debugging so um uh those analytics will

118
00:04:47,919 --> 00:04:50,320
do step by step instruction instruction

119
00:04:50,320 --> 00:04:52,400
execution so

120
00:04:52,400 --> 00:04:54,080
uh they know what actually the program

121
00:04:54,080 --> 00:04:56,479
is is doing when when run

122
00:04:56,479 --> 00:04:57,360
and

123
00:04:57,360 --> 00:04:59,360
they want to pro modify the program and

124
00:04:59,360 --> 00:05:00,720
the runtime and

125
00:05:00,720 --> 00:05:03,520
try to extract the hidden data

126
00:05:03,520 --> 00:05:05,759
so this is basically what we will be

127
00:05:05,759 --> 00:05:08,320
facing let's try to do some counter

128
00:05:08,320 --> 00:05:10,880
measures but before doing that we need

129
00:05:10,880 --> 00:05:13,280
to actually deliver the marvel to our

130
00:05:13,280 --> 00:05:15,600
target and i am delivering the talk to

131
00:05:15,600 --> 00:05:18,400
the patrick right now

132
00:05:18,400 --> 00:05:22,560
thanks so a few words about delivering

133
00:05:22,560 --> 00:05:25,919
our is called to the victims for example

134
00:05:25,919 --> 00:05:29,039
via fishing or or

135
00:05:29,039 --> 00:05:31,120
just just doing some some or let's say

136
00:05:31,120 --> 00:05:35,520
writing activities so we often used uh

137
00:05:35,520 --> 00:05:37,360
office documents so

138
00:05:37,360 --> 00:05:39,440
or text of files with macros with

139
00:05:39,440 --> 00:05:42,080
symbolic links and we with some other

140
00:05:42,080 --> 00:05:44,800
stuff like dynamic data exchange or we

141
00:05:44,800 --> 00:05:46,800
can also uh

142
00:05:46,800 --> 00:05:50,000
use some hda files jscripts there are

143
00:05:50,000 --> 00:05:53,600
some some native uh features of windows

144
00:05:53,600 --> 00:05:56,160
or office or other applications that

145
00:05:56,160 --> 00:05:58,720
allow code execution and we just try to

146
00:05:58,720 --> 00:06:01,199
abuse them so for example these visual

147
00:06:01,199 --> 00:06:03,919
basic macros which are

148
00:06:03,919 --> 00:06:06,000
normally used for for some let's say

149
00:06:06,000 --> 00:06:08,960
cell manipulation excel or whatever but

150
00:06:08,960 --> 00:06:10,400
all those

151
00:06:10,400 --> 00:06:11,840
macros or

152
00:06:11,840 --> 00:06:14,240
hda scripts another

153
00:06:14,240 --> 00:06:16,000
allow to

154
00:06:16,000 --> 00:06:18,560
execute some more specific code and

155
00:06:18,560 --> 00:06:21,759
we usually try to to deliver some and

156
00:06:21,759 --> 00:06:23,680
execute some some native code like shell

157
00:06:23,680 --> 00:06:25,919
code using using the macros

158
00:06:25,919 --> 00:06:26,880
or

159
00:06:26,880 --> 00:06:29,520
or other uh

160
00:06:29,520 --> 00:06:32,400
native features so uh let's say we we

161
00:06:32,400 --> 00:06:33,759
have this

162
00:06:33,759 --> 00:06:35,840
excel file with macro and

163
00:06:35,840 --> 00:06:37,120
it

164
00:06:37,120 --> 00:06:38,960
ultimately tries to to

165
00:06:38,960 --> 00:06:41,280
execute some shortcut in memory and what

166
00:06:41,280 --> 00:06:43,120
is this circle so so it's a piece of

167
00:06:43,120 --> 00:06:45,919
code usually used doing for example

168
00:06:45,919 --> 00:06:48,240
binary exploitation so buffer of results

169
00:06:48,240 --> 00:06:50,479
and other stuff so basically it's some

170
00:06:50,479 --> 00:06:52,080
kind of position independent code that

171
00:06:52,080 --> 00:06:54,160
can be executed from wherever place in

172
00:06:54,160 --> 00:06:56,319
memory so it's it must be formed like

173
00:06:56,319 --> 00:06:58,479
that so so

174
00:06:58,479 --> 00:07:00,560
the processor can just jump to the first

175
00:07:00,560 --> 00:07:02,240
pipe or shell code and then execute

176
00:07:02,240 --> 00:07:03,280
everything

177
00:07:03,280 --> 00:07:04,880
and

178
00:07:04,880 --> 00:07:06,880
it uses some some clever techniques to

179
00:07:06,880 --> 00:07:10,000
to find its way around the process

180
00:07:10,000 --> 00:07:11,599
for example locating process manual

181
00:07:11,599 --> 00:07:13,039
block and then

182
00:07:13,039 --> 00:07:16,400
libraries functions

183
00:07:16,400 --> 00:07:18,720
as i said this is a

184
00:07:18,720 --> 00:07:20,479
good material for in normal injections

185
00:07:20,479 --> 00:07:21,919
so we can

186
00:07:21,919 --> 00:07:24,240
execute this in our own process or

187
00:07:24,240 --> 00:07:26,319
inject to some other process using a

188
00:07:26,319 --> 00:07:28,400
variety of techniques

189
00:07:28,400 --> 00:07:29,440
and

190
00:07:29,440 --> 00:07:31,599
well shortcuts are like this a perfect

191
00:07:31,599 --> 00:07:33,280
example of called reflection because

192
00:07:33,280 --> 00:07:36,160
this shortcut can modify itself however

193
00:07:36,160 --> 00:07:39,199
it wants uh by design so these are some

194
00:07:39,199 --> 00:07:43,280
features of shellcode and we often

195
00:07:43,360 --> 00:07:45,280
for example deliver

196
00:07:45,280 --> 00:07:46,400
any

197
00:07:46,400 --> 00:07:48,720
comment and control payloads implants

198
00:07:48,720 --> 00:07:50,160
in the form of shell cult which is

199
00:07:50,160 --> 00:07:53,440
executed from for example vba or jscript

200
00:07:53,440 --> 00:07:56,160
or whatever uh

201
00:07:56,160 --> 00:07:58,240
we're delivering delivering to a victim

202
00:07:58,240 --> 00:08:00,800
and some words about this specific

203
00:08:00,800 --> 00:08:02,800
windows shell code for example we can

204
00:08:02,800 --> 00:08:04,319
generate the simplest one from

205
00:08:04,319 --> 00:08:06,720
metasploit so so

206
00:08:06,720 --> 00:08:09,759
the basic metasploit shortcut is this

207
00:08:09,759 --> 00:08:12,560
reverse shell and it works like that's

208
00:08:12,560 --> 00:08:15,280
also the code is trying to locate

209
00:08:15,280 --> 00:08:17,360
processing by not blocking memory it's

210
00:08:17,360 --> 00:08:21,120
easily accessible then it locates

211
00:08:21,120 --> 00:08:23,360
the kernel 32 library memory because

212
00:08:23,360 --> 00:08:26,160
it's it's loaded in specific place in

213
00:08:26,160 --> 00:08:28,160
memory indicated by

214
00:08:28,160 --> 00:08:30,319
loader data located in process manual

215
00:08:30,319 --> 00:08:32,559
block and then it can

216
00:08:32,559 --> 00:08:34,880
find the specific functions like get

217
00:08:34,880 --> 00:08:37,599
proc address library get module handles

218
00:08:37,599 --> 00:08:38,880
so these functions are used to

219
00:08:38,880 --> 00:08:41,360
dynamically load another deal load and

220
00:08:41,360 --> 00:08:43,519
resolve another function so having those

221
00:08:43,519 --> 00:08:45,760
functions and be being able to call them

222
00:08:45,760 --> 00:08:48,320
we can for example load windows socket

223
00:08:48,320 --> 00:08:49,760
library or

224
00:08:49,760 --> 00:08:52,480
any other library and call some some

225
00:08:52,480 --> 00:08:53,920
other functions and

226
00:08:53,920 --> 00:08:58,160
this reverse shortcut is just

227
00:08:58,160 --> 00:08:59,680
creating a socket

228
00:08:59,680 --> 00:09:02,240
using this windows socket library and

229
00:09:02,240 --> 00:09:04,160
then creating process a new process

230
00:09:04,160 --> 00:09:07,200
command line so cmd or something else

231
00:09:07,200 --> 00:09:09,279
and attaching the standard thing to

232
00:09:09,279 --> 00:09:11,360
output and narrow to this socket so then

233
00:09:11,360 --> 00:09:12,320
there we

234
00:09:12,320 --> 00:09:15,519
we have this this rudimentary reverse

235
00:09:15,519 --> 00:09:17,120
shell

236
00:09:17,120 --> 00:09:20,320
working on just on pure tcp

237
00:09:20,320 --> 00:09:22,320
and this piece of code will obviously uh

238
00:09:22,320 --> 00:09:24,240
will be detected by most likely any

239
00:09:24,240 --> 00:09:26,720
antivirus and our job starts right now

240
00:09:26,720 --> 00:09:29,200
we need to hide it

241
00:09:29,200 --> 00:09:33,200
yes so so the first step is uh

242
00:09:33,200 --> 00:09:34,959
some technique for injection so this

243
00:09:34,959 --> 00:09:37,360
simplest technique to inject circles in

244
00:09:37,360 --> 00:09:39,360
our own process but we will usually

245
00:09:39,360 --> 00:09:41,519
target some other processes but let's

246
00:09:41,519 --> 00:09:43,040
start with with the basics of injecting

247
00:09:43,040 --> 00:09:44,800
in our own process

248
00:09:44,800 --> 00:09:48,560
uh is based on creating some memory

249
00:09:48,560 --> 00:09:50,959
which should be readable and executable

250
00:09:50,959 --> 00:09:52,480
we can

251
00:09:52,480 --> 00:09:54,560
change memory protections however we

252
00:09:54,560 --> 00:09:56,640
like but in this simplest case we just

253
00:09:56,640 --> 00:09:59,120
need to this memory patch to be readable

254
00:09:59,120 --> 00:10:00,560
so we can write the shortcut there and

255
00:10:00,560 --> 00:10:03,040
executable so we can

256
00:10:03,040 --> 00:10:04,640
execute the shell code run the

257
00:10:04,640 --> 00:10:05,920
instructions

258
00:10:05,920 --> 00:10:08,560
and then we can use create thread or

259
00:10:08,560 --> 00:10:10,959
just cast the pointer to a function and

260
00:10:10,959 --> 00:10:13,519
call this so that this is how it works

261
00:10:13,519 --> 00:10:16,640
from from c or stickers plus so

262
00:10:16,640 --> 00:10:17,440
and

263
00:10:17,440 --> 00:10:20,399
those macros and and other

264
00:10:20,399 --> 00:10:22,720
high-level languages usually use those

265
00:10:22,720 --> 00:10:24,240
native apis

266
00:10:24,240 --> 00:10:27,120
like virtual or log create threads etc

267
00:10:27,120 --> 00:10:30,160
to run the shortcut

268
00:10:31,279 --> 00:10:33,839
and uh now let's say a few words about

269
00:10:33,839 --> 00:10:34,880
uh

270
00:10:34,880 --> 00:10:37,519
some some advanced covered loader that

271
00:10:37,519 --> 00:10:39,760
we would be uh

272
00:10:39,760 --> 00:10:41,760
developing in this uh theoretical

273
00:10:41,760 --> 00:10:43,360
exercise so

274
00:10:43,360 --> 00:10:45,440
as we said

275
00:10:45,440 --> 00:10:48,560
we will slaughter will start with basic

276
00:10:48,560 --> 00:10:51,120
memory allocation shell called uh

277
00:10:51,120 --> 00:10:53,120
writing to this memory

278
00:10:53,120 --> 00:10:54,720
in our own process and then triggering

279
00:10:54,720 --> 00:10:56,560
the execution for example with create

280
00:10:56,560 --> 00:10:58,560
thread function

281
00:10:58,560 --> 00:11:01,440
and then we can add some some

282
00:11:01,440 --> 00:11:03,040
runtime routines to decrypt the shell

283
00:11:03,040 --> 00:11:05,600
code so the show called uh doing static

284
00:11:05,600 --> 00:11:08,640
analysis would be encrypted and

285
00:11:08,640 --> 00:11:10,240
not not visible

286
00:11:10,240 --> 00:11:12,000
for defensive solutions so

287
00:11:12,000 --> 00:11:13,839
for example antivirus would be able to

288
00:11:13,839 --> 00:11:15,760
detect what it actually is and then this

289
00:11:15,760 --> 00:11:18,079
would be decrypted during the runtime

290
00:11:18,079 --> 00:11:19,760
and uh

291
00:11:19,760 --> 00:11:23,680
executed so this is some some basic uh

292
00:11:23,680 --> 00:11:25,600
bypass for starter detections then we

293
00:11:25,600 --> 00:11:27,680
can implement some sandbox check to see

294
00:11:27,680 --> 00:11:30,000
if we are being analyzed by some virtual

295
00:11:30,000 --> 00:11:31,120
environment

296
00:11:31,120 --> 00:11:33,519
also some anti-debugging checks for

297
00:11:33,519 --> 00:11:37,040
example to hinder the the job of

298
00:11:37,040 --> 00:11:40,079
manual analyst

299
00:11:40,480 --> 00:11:44,000
then we can add some obfuscation to

300
00:11:44,000 --> 00:11:46,399
to any data that it's sensitive like for

301
00:11:46,399 --> 00:11:48,480
example you know ip addresses or ports

302
00:11:48,480 --> 00:11:52,639
or some user edges that would say our

303
00:11:52,639 --> 00:11:54,560
shell code or our implant is using and

304
00:11:54,560 --> 00:11:56,639
then this data would be obfuscated

305
00:11:56,639 --> 00:11:58,320
during current time so it's hidden from

306
00:11:58,320 --> 00:12:00,720
the static analysis

307
00:12:00,720 --> 00:12:02,000
uh

308
00:12:02,000 --> 00:12:04,720
what we can also do later is

309
00:12:04,720 --> 00:12:06,880
purge the shadow code from so remove

310
00:12:06,880 --> 00:12:09,680
this from memory and for example load it

311
00:12:09,680 --> 00:12:12,719
again after some time

312
00:12:13,360 --> 00:12:15,680
also we can implement

313
00:12:15,680 --> 00:12:16,480
some

314
00:12:16,480 --> 00:12:19,279
anti-debugging features there and to

315
00:12:19,279 --> 00:12:22,320
just regularly remove the

316
00:12:22,320 --> 00:12:23,519
this

317
00:12:23,519 --> 00:12:25,360
shell code or other

318
00:12:25,360 --> 00:12:27,440
important sensitive data from the memory

319
00:12:27,440 --> 00:12:30,160
by writing memory with zeros and

320
00:12:30,160 --> 00:12:31,839
repeating that's for example activating

321
00:12:31,839 --> 00:12:33,760
the shell code when when it's needed

322
00:12:33,760 --> 00:12:36,959
well these are some some advanced uh

323
00:12:36,959 --> 00:12:38,480
features that that

324
00:12:38,480 --> 00:12:42,000
just to give you some idea how we can

325
00:12:42,000 --> 00:12:43,040
develop

326
00:12:43,040 --> 00:12:45,440
such a loader for shortcut or some

327
00:12:45,440 --> 00:12:48,240
implant used for for custom

328
00:12:48,240 --> 00:12:50,000
returning engagements and stuff like

329
00:12:50,000 --> 00:12:50,839
that

330
00:12:50,839 --> 00:12:55,360
and one cool idea i had is to also

331
00:12:55,360 --> 00:12:57,360
crack the decryption keys so

332
00:12:57,360 --> 00:12:59,680
let's say we are encrypting and

333
00:12:59,680 --> 00:13:01,680
decrypting the the shell code or some

334
00:13:01,680 --> 00:13:04,160
other stuff in memory during

335
00:13:04,160 --> 00:13:07,680
our malware runtime so we can either

336
00:13:07,680 --> 00:13:10,639
hard code the key or just try to crack

337
00:13:10,639 --> 00:13:12,959
the key during quantum so

338
00:13:12,959 --> 00:13:15,200
this is some additional

339
00:13:15,200 --> 00:13:18,160
feature and also we can dynamically

340
00:13:18,160 --> 00:13:20,880
resolve functions to hide them from

341
00:13:20,880 --> 00:13:21,839
this

342
00:13:21,839 --> 00:13:24,320
behavioral analysis so for example hide

343
00:13:24,320 --> 00:13:26,720
the importance table and the result

344
00:13:26,720 --> 00:13:29,440
functions uh during contact so the

345
00:13:29,440 --> 00:13:31,360
analyst or antivirus

346
00:13:31,360 --> 00:13:34,560
won't see that we are using some

347
00:13:34,560 --> 00:13:36,240
functions like create

348
00:13:36,240 --> 00:13:39,279
remote thread or other windows apis that

349
00:13:39,279 --> 00:13:41,199
are associated with some malicious

350
00:13:41,199 --> 00:13:43,279
activities like shortcut injection and

351
00:13:43,279 --> 00:13:44,959
also we can

352
00:13:44,959 --> 00:13:47,519
implement some compile time obfuscation

353
00:13:47,519 --> 00:13:49,519
for example with

354
00:13:49,519 --> 00:13:51,519
sql templates or

355
00:13:51,519 --> 00:13:52,959
llvm so

356
00:13:52,959 --> 00:13:55,440
that's a variable topic and more on that

357
00:13:55,440 --> 00:13:57,600
you can find on my blog which will link

358
00:13:57,600 --> 00:13:59,839
at the end of the presentation so

359
00:13:59,839 --> 00:14:01,600
let's go

360
00:14:01,600 --> 00:14:04,240
to some actual implementation

361
00:14:04,240 --> 00:14:06,959
yeah so uh let's try to bypass some

362
00:14:06,959 --> 00:14:09,040
static iocs and these static properties

363
00:14:09,040 --> 00:14:10,959
they include like strings or header

364
00:14:10,959 --> 00:14:13,680
details hashes the data and embedded

365
00:14:13,680 --> 00:14:14,959
resources

366
00:14:14,959 --> 00:14:16,880
this type of data

367
00:14:16,880 --> 00:14:18,480
well actually can be acquired very

368
00:14:18,480 --> 00:14:20,079
quickly because there's simply no need

369
00:14:20,079 --> 00:14:22,079
to run the program in order to see them

370
00:14:22,079 --> 00:14:25,440
so uh we probably would like to address

371
00:14:25,440 --> 00:14:27,519
those and we've

372
00:14:27,519 --> 00:14:30,959
chosen six one is the the hash so each

373
00:14:30,959 --> 00:14:33,120
file has its own hash well you can

374
00:14:33,120 --> 00:14:35,199
calculate the different hashes and this

375
00:14:35,199 --> 00:14:37,519
uh this hash will be unique for this

376
00:14:37,519 --> 00:14:39,440
particular uh

377
00:14:39,440 --> 00:14:42,560
compiled uh version of the software then

378
00:14:42,560 --> 00:14:46,399
you got the strings inside of this

379
00:14:46,399 --> 00:14:48,560
this executable then some static

380
00:14:48,560 --> 00:14:51,519
signatures debug informations important

381
00:14:51,519 --> 00:14:54,399
libraries like dlls and also imported

382
00:14:54,399 --> 00:14:57,519
functions and what will be the com

383
00:14:57,519 --> 00:14:59,680
counter measures for that so you know

384
00:14:59,680 --> 00:15:02,000
for each file when you make a new

385
00:15:02,000 --> 00:15:05,279
compilation you you simply build the uh

386
00:15:05,279 --> 00:15:07,360
the the solution one more time and the

387
00:15:07,360 --> 00:15:09,279
hash is being changed so

388
00:15:09,279 --> 00:15:12,959
uh in order to avoid being

389
00:15:12,959 --> 00:15:14,480
found or

390
00:15:14,480 --> 00:15:16,800
traced by hash just simply you can

391
00:15:16,800 --> 00:15:19,279
recompile the solution for strings and

392
00:15:19,279 --> 00:15:21,120
static signatures you can

393
00:15:21,120 --> 00:15:22,880
use xor encryption this is actually

394
00:15:22,880 --> 00:15:25,040
patrick's favorite

395
00:15:25,040 --> 00:15:27,600
favorite way of doing that uh

396
00:15:27,600 --> 00:15:29,279
for the debug information you need to

397
00:15:29,279 --> 00:15:30,560
jump into the

398
00:15:30,560 --> 00:15:32,160
linker settings probably you have never

399
00:15:32,160 --> 00:15:34,240
done that before but this is actually

400
00:15:34,240 --> 00:15:36,160
kind of useful we'll talk about it in a

401
00:15:36,160 --> 00:15:39,279
second and for the important dlls and

402
00:15:39,279 --> 00:15:42,959
functions you got this api hashing so

403
00:15:42,959 --> 00:15:45,519
let's start from this file hash so if

404
00:15:45,519 --> 00:15:46,560
you

405
00:15:46,560 --> 00:15:47,759
if you know this is actually a

406
00:15:47,759 --> 00:15:49,600
screenshot from a various tools so you

407
00:15:49,600 --> 00:15:52,240
can all upload a file there or you can

408
00:15:52,240 --> 00:15:55,440
also upload just only the uh the hash in

409
00:15:55,440 --> 00:15:57,199
case you don't want to upload the whole

410
00:15:57,199 --> 00:15:59,440
file so by simply making a new

411
00:15:59,440 --> 00:16:01,040
compilation you just

412
00:16:01,040 --> 00:16:02,079
change the

413
00:16:02,079 --> 00:16:04,480
the hash and your program will probably

414
00:16:04,480 --> 00:16:07,600
uh will not be traced that way obviously

415
00:16:07,600 --> 00:16:09,839
it will not uh actually improve the

416
00:16:09,839 --> 00:16:12,399
detection level but we'll talk about it

417
00:16:12,399 --> 00:16:14,720
in um in a second

418
00:16:14,720 --> 00:16:18,320
uh the uh the second step is uh

419
00:16:18,320 --> 00:16:20,320
those are the strings and

420
00:16:20,320 --> 00:16:22,720
pdbs so let's start from the

421
00:16:22,720 --> 00:16:25,279
the pdb so what what this pdb file is

422
00:16:25,279 --> 00:16:28,000
pdb file is a program database file uh

423
00:16:28,000 --> 00:16:32,000
this file is generated when uh pro

424
00:16:32,000 --> 00:16:34,240
program is being compiled to store some

425
00:16:34,240 --> 00:16:36,240
debugging information about this

426
00:16:36,240 --> 00:16:38,240
particular individual build of a program

427
00:16:38,240 --> 00:16:40,480
it may actually store some symbols name

428
00:16:40,480 --> 00:16:42,959
of functions and other information to

429
00:16:42,959 --> 00:16:45,600
assist you with the debugging but we are

430
00:16:45,600 --> 00:16:47,920
interested in that because of the

431
00:16:47,920 --> 00:16:50,160
actually the the file path which will be

432
00:16:50,160 --> 00:16:52,399
embedded in the final executable and

433
00:16:52,399 --> 00:16:54,320
this path will may contain some

434
00:16:54,320 --> 00:16:56,399
sensitive information so in just imagine

435
00:16:56,399 --> 00:16:58,560
some banana developer with well

436
00:16:58,560 --> 00:17:01,040
organized directory of structured names

437
00:17:01,040 --> 00:17:03,040
so this directory can look like the

438
00:17:03,040 --> 00:17:05,599
following so maybe c username then

439
00:17:05,599 --> 00:17:07,760
desktop company name project name and so

440
00:17:07,760 --> 00:17:10,160
on you probably would like to hide it

441
00:17:10,160 --> 00:17:13,919
from uh being analyzed uh also you you

442
00:17:13,919 --> 00:17:15,760
can actually fool the

443
00:17:15,760 --> 00:17:18,480
malware analytics so so you can embed

444
00:17:18,480 --> 00:17:20,880
something uh some something different

445
00:17:20,880 --> 00:17:23,119
something some kind of message for for

446
00:17:23,119 --> 00:17:26,000
them or or whatever

447
00:17:26,000 --> 00:17:30,240
uh those api hashing patrick

448
00:17:30,240 --> 00:17:32,880
so so that's some tricky stuff so uh

449
00:17:32,880 --> 00:17:34,720
here we would uh

450
00:17:34,720 --> 00:17:36,559
try to

451
00:17:36,559 --> 00:17:38,640
resolve the the functions

452
00:17:38,640 --> 00:17:40,320
just like shellcode so by locating them

453
00:17:40,320 --> 00:17:42,880
in memory instead of uh importing using

454
00:17:42,880 --> 00:17:45,440
input others table because when we

455
00:17:45,440 --> 00:17:48,240
compile some executable

456
00:17:48,240 --> 00:17:48,960
uh

457
00:17:48,960 --> 00:17:51,120
then the windows loader needs this

458
00:17:51,120 --> 00:17:52,799
import address able to know which

459
00:17:52,799 --> 00:17:54,880
functions to and which libraries to load

460
00:17:54,880 --> 00:17:56,160
for for this

461
00:17:56,160 --> 00:17:57,840
application to use so for example when

462
00:17:57,840 --> 00:18:00,080
we are writing some some tool that

463
00:18:00,080 --> 00:18:02,480
injects shell code using create thread

464
00:18:02,480 --> 00:18:04,640
virtual lock and some other

465
00:18:04,640 --> 00:18:07,120
suspicious functions these are reflected

466
00:18:07,120 --> 00:18:09,120
in the importance table so

467
00:18:09,120 --> 00:18:10,160
to

468
00:18:10,160 --> 00:18:13,039
bypass that we would

469
00:18:13,039 --> 00:18:14,559
try to implement

470
00:18:14,559 --> 00:18:16,400
this technique used by shortcut so

471
00:18:16,400 --> 00:18:17,919
locating process environment block and

472
00:18:17,919 --> 00:18:20,640
then browsing the the loader data for

473
00:18:20,640 --> 00:18:21,679
specific

474
00:18:21,679 --> 00:18:23,600
libraries and calling the specific

475
00:18:23,600 --> 00:18:26,160
functions to for example load functions

476
00:18:26,160 --> 00:18:27,600
on other function libraries during

477
00:18:27,600 --> 00:18:30,159
runtime so

478
00:18:30,240 --> 00:18:33,120
and about the api hashing we can

479
00:18:33,120 --> 00:18:34,400
calculate

480
00:18:34,400 --> 00:18:35,679
a hash

481
00:18:35,679 --> 00:18:36,799
instead of

482
00:18:36,799 --> 00:18:38,240
storing the name function we can

483
00:18:38,240 --> 00:18:40,240
calculate the hash of function then

484
00:18:40,240 --> 00:18:42,160
browse all the functions for example

485
00:18:42,160 --> 00:18:44,160
from kernel 22 library and find the

486
00:18:44,160 --> 00:18:46,240
specific function by its hash

487
00:18:46,240 --> 00:18:47,120
so

488
00:18:47,120 --> 00:18:49,760
during analysis an analyst want to know

489
00:18:49,760 --> 00:18:52,080
what the first site what functions are

490
00:18:52,080 --> 00:18:54,720
we importing dynamically

491
00:18:54,720 --> 00:18:56,880
and this would be resolved during the

492
00:18:56,880 --> 00:19:00,480
malware execution time

493
00:19:01,360 --> 00:19:03,280
and

494
00:19:03,280 --> 00:19:06,320
again some some

495
00:19:06,799 --> 00:19:09,200
information about about this

496
00:19:09,200 --> 00:19:10,320
shellcode's

497
00:19:10,320 --> 00:19:11,919
bootstrapping technique

498
00:19:11,919 --> 00:19:15,280
so uh how it works with galaxy exactly a

499
00:19:15,280 --> 00:19:17,840
the process manual block address is

500
00:19:17,840 --> 00:19:19,280
located

501
00:19:19,280 --> 00:19:21,280
somewhere relative to the gs register so

502
00:19:21,280 --> 00:19:22,000
it's

503
00:19:22,000 --> 00:19:23,440
very easy to

504
00:19:23,440 --> 00:19:24,720
uh

505
00:19:24,720 --> 00:19:26,960
acquire this address then we browse the

506
00:19:26,960 --> 00:19:28,000
peb

507
00:19:28,000 --> 00:19:30,240
at specific offset it's based on the

508
00:19:30,240 --> 00:19:31,679
architecture so the offsets are

509
00:19:31,679 --> 00:19:34,000
different for 64-bit and 32-bit

510
00:19:34,000 --> 00:19:35,200
architecture

511
00:19:35,200 --> 00:19:36,960
and process and

512
00:19:36,960 --> 00:19:40,400
in this loader data we have some double

513
00:19:40,400 --> 00:19:43,280
linked lists of all loaded modules so

514
00:19:43,280 --> 00:19:45,120
the libraries so for example for every

515
00:19:45,120 --> 00:19:46,160
process

516
00:19:46,160 --> 00:19:48,000
the loaded modules would be the process

517
00:19:48,000 --> 00:19:50,160
itself of the executable itself kernel

518
00:19:50,160 --> 00:19:52,720
32 and dll kernel base and maybe some

519
00:19:52,720 --> 00:19:56,080
some other libraries that are loaded by

520
00:19:56,080 --> 00:19:57,840
by the system loader

521
00:19:57,840 --> 00:19:59,440
by windows loader when the process is

522
00:19:59,440 --> 00:20:00,640
created

523
00:20:00,640 --> 00:20:01,840
and

524
00:20:01,840 --> 00:20:04,840
we can then browse this

525
00:20:04,840 --> 00:20:07,600
this double linked list and there are

526
00:20:07,600 --> 00:20:09,520
some some specific data structures which

527
00:20:09,520 --> 00:20:12,000
describe all the dlls also there is the

528
00:20:12,000 --> 00:20:14,559
name of the dll and address and we can

529
00:20:14,559 --> 00:20:16,240
for example calculate the hash of the

530
00:20:16,240 --> 00:20:17,039
name

531
00:20:17,039 --> 00:20:18,799
find the specific function we need let's

532
00:20:18,799 --> 00:20:21,760
say a create remote thread in current 32

533
00:20:21,760 --> 00:20:24,320
library and then find its address

534
00:20:24,320 --> 00:20:26,240
because it's also stored in this in this

535
00:20:26,240 --> 00:20:28,320
data structure

536
00:20:28,320 --> 00:20:30,559
and

537
00:20:31,120 --> 00:20:32,720
we can also

538
00:20:32,720 --> 00:20:34,880
find the get proc address of library

539
00:20:34,880 --> 00:20:37,360
functions to to load to any other dealer

540
00:20:37,360 --> 00:20:38,640
so

541
00:20:38,640 --> 00:20:39,360
and

542
00:20:39,360 --> 00:20:41,360
those names of the lessons and function

543
00:20:41,360 --> 00:20:43,919
can be also hashed to to find it

544
00:20:43,919 --> 00:20:45,760
dynamically so so that's how the circuit

545
00:20:45,760 --> 00:20:48,000
works

546
00:20:48,000 --> 00:20:50,000
that's how circles work and that's how

547
00:20:50,000 --> 00:20:53,360
we can also hide this stuff from from

548
00:20:53,360 --> 00:20:56,000
our executable using this technique so

549
00:20:56,000 --> 00:20:57,760
here we have some screenshots from from

550
00:20:57,760 --> 00:21:00,880
the windows debugger in the left and

551
00:21:00,880 --> 00:21:03,280
you can see that there are some some

552
00:21:03,280 --> 00:21:05,840
libraries loaded and

553
00:21:05,840 --> 00:21:07,360
it's the information stored in the

554
00:21:07,360 --> 00:21:08,559
processing management block for a

555
00:21:08,559 --> 00:21:11,440
specific process and

556
00:21:11,440 --> 00:21:15,280
for example on the right we see

557
00:21:15,280 --> 00:21:17,919
the dump from kernel 32 library and

558
00:21:17,919 --> 00:21:20,000
those specific functions that that are

559
00:21:20,000 --> 00:21:21,679
stored in the library so we can just

560
00:21:21,679 --> 00:21:24,000
browse them in memory to find them so

561
00:21:24,000 --> 00:21:25,760
when we have address of the library

562
00:21:25,760 --> 00:21:28,000
loaded in memory we can go there and

563
00:21:28,000 --> 00:21:30,000
find the specific functions in the

564
00:21:30,000 --> 00:21:31,840
current 32

565
00:21:31,840 --> 00:21:34,320
in memory and then call those functions

566
00:21:34,320 --> 00:21:36,799
just just like any other function like

567
00:21:36,799 --> 00:21:39,760
in native code

568
00:21:41,520 --> 00:21:43,840
so this is some simple implementation of

569
00:21:43,840 --> 00:21:45,679
this technique we have a simple function

570
00:21:45,679 --> 00:21:48,240
to calculate the hash and then uh some

571
00:21:48,240 --> 00:21:50,159
loop to go through

572
00:21:50,159 --> 00:21:52,559
all the names of uh

573
00:21:52,559 --> 00:21:54,240
functions which are stored in the

574
00:21:54,240 --> 00:21:56,480
library so so it's just a matter of

575
00:21:56,480 --> 00:21:58,799
interpreting the dll

576
00:21:58,799 --> 00:22:01,280
according to the pe format portables

577
00:22:01,280 --> 00:22:02,960
capable and then finding finding the

578
00:22:02,960 --> 00:22:04,880
functions and creating two slashes of

579
00:22:04,880 --> 00:22:06,559
the names and then getting addresses of

580
00:22:06,559 --> 00:22:09,120
functions and calling them so

581
00:22:09,120 --> 00:22:11,360
it's a some code example and all all

582
00:22:11,360 --> 00:22:13,520
those examples and that information you

583
00:22:13,520 --> 00:22:15,919
will be able to find this on my blog so

584
00:22:15,919 --> 00:22:17,440
uh let's go

585
00:22:17,440 --> 00:22:18,720
let's go next

586
00:22:18,720 --> 00:22:21,440
yeah so we have faced the very basic the

587
00:22:21,440 --> 00:22:22,880
very first

588
00:22:22,880 --> 00:22:24,559
method of

589
00:22:24,559 --> 00:22:27,600
detection of the antivirus now uh we'll

590
00:22:27,600 --> 00:22:30,320
try to fool them because uh before

591
00:22:30,320 --> 00:22:32,880
actually allowing the the file to run

592
00:22:32,880 --> 00:22:35,840
antivirus will run the software within a

593
00:22:35,840 --> 00:22:38,640
sandbox and check what are the actually

594
00:22:38,640 --> 00:22:40,640
what the program is doing and we what

595
00:22:40,640 --> 00:22:42,320
we're going to do we probably would like

596
00:22:42,320 --> 00:22:43,039
to

597
00:22:43,039 --> 00:22:46,080
stop the execution when our malware will

598
00:22:46,080 --> 00:22:48,159
detect that it is being launched within

599
00:22:48,159 --> 00:22:49,760
this sandbox

600
00:22:49,760 --> 00:22:52,240
environment just in case to avoid being

601
00:22:52,240 --> 00:22:54,000
being detected

602
00:22:54,000 --> 00:22:56,000
and the very first thing you would like

603
00:22:56,000 --> 00:22:58,240
to do is to check whether this is

604
00:22:58,240 --> 00:23:00,320
actually a virtualized environment where

605
00:23:00,320 --> 00:23:02,000
there are some characteristic things

606
00:23:02,000 --> 00:23:04,720
about the sandboxes obviously those are

607
00:23:04,720 --> 00:23:06,480
simplified environments so you don't

608
00:23:06,480 --> 00:23:09,760
have that much uh information in them so

609
00:23:09,760 --> 00:23:12,000
also there are some limitations both for

610
00:23:12,000 --> 00:23:14,559
hardware and software so

611
00:23:14,559 --> 00:23:16,400
first we can check how many cores of

612
00:23:16,400 --> 00:23:17,520
this

613
00:23:17,520 --> 00:23:19,840
machine

614
00:23:19,840 --> 00:23:22,880
has so and compared to like the certain

615
00:23:22,880 --> 00:23:26,400
amount of or of course probably in 2021

616
00:23:26,400 --> 00:23:28,400
or you once bought a machine with with

617
00:23:28,400 --> 00:23:30,640
two cars on board so this is the the

618
00:23:30,640 --> 00:23:32,240
first thing and actually the second

619
00:23:32,240 --> 00:23:34,799
thing is you can check how many how much

620
00:23:34,799 --> 00:23:36,559
ram memory do you have on this

621
00:23:36,559 --> 00:23:39,520
environment and also if the ram is less

622
00:23:39,520 --> 00:23:42,000
than a desired value you can stop the

623
00:23:42,000 --> 00:23:44,480
execution flow so that

624
00:23:44,480 --> 00:23:47,760
actually the antivirus will probably

625
00:23:47,760 --> 00:23:49,200
won't

626
00:23:49,200 --> 00:23:52,000
flag our file as malicious

627
00:23:52,000 --> 00:23:53,360
also uh

628
00:23:53,360 --> 00:23:56,080
sandboxes cannot allocate so much memory

629
00:23:56,080 --> 00:23:59,200
because they have to work uh very fast

630
00:23:59,200 --> 00:24:00,880
and they cannot slow down the computer

631
00:24:00,880 --> 00:24:02,640
that much so you can

632
00:24:02,640 --> 00:24:06,159
try to allocate a very very big amount

633
00:24:06,159 --> 00:24:08,240
of memory and see what actually happens

634
00:24:08,240 --> 00:24:09,919
maybe then the sandbox will stop

635
00:24:09,919 --> 00:24:11,760
analyzing because

636
00:24:11,760 --> 00:24:14,320
it won't have enough resources and one

637
00:24:14,320 --> 00:24:16,400
funny fact about

638
00:24:16,400 --> 00:24:17,919
also checking some other things as you

639
00:24:17,919 --> 00:24:20,400
can try to load some fake library which

640
00:24:20,400 --> 00:24:23,120
obviously doesn't exist but some boxes

641
00:24:23,120 --> 00:24:24,960
may try to emulate

642
00:24:24,960 --> 00:24:28,000
libraries and in case it somehow exists

643
00:24:28,000 --> 00:24:30,000
you can actually stop the execution flow

644
00:24:30,000 --> 00:24:31,679
because you will know that this is not

645
00:24:31,679 --> 00:24:32,559
the

646
00:24:32,559 --> 00:24:34,960
real real machine

647
00:24:34,960 --> 00:24:36,240
uh

648
00:24:36,240 --> 00:24:37,440
one thing

649
00:24:37,440 --> 00:24:41,279
that also improves the uh our uh chances

650
00:24:41,279 --> 00:24:43,120
of success is to implement

651
00:24:43,120 --> 00:24:45,840
multi-threading because uh

652
00:24:45,840 --> 00:24:47,440
multi-threading environments is

653
00:24:47,440 --> 00:24:50,400
relatively harder to do so when using

654
00:24:50,400 --> 00:24:52,799
multi-threading you probably will have a

655
00:24:52,799 --> 00:24:55,840
less detection detection score

656
00:24:55,840 --> 00:24:57,919
and if you have some extra knowledge

657
00:24:57,919 --> 00:25:00,159
about your targets you can also check

658
00:25:00,159 --> 00:25:02,720
for some uh characteristic information

659
00:25:02,720 --> 00:25:03,840
about the

660
00:25:03,840 --> 00:25:05,440
machine so for example you can check for

661
00:25:05,440 --> 00:25:07,600
the computer name because usually in a

662
00:25:07,600 --> 00:25:09,840
domain environment the computers are

663
00:25:09,840 --> 00:25:13,440
named within a certain

664
00:25:13,440 --> 00:25:16,000
convention like starting with desktop or

665
00:25:16,000 --> 00:25:18,480
l or whatever it is if you have such a

666
00:25:18,480 --> 00:25:19,760
knowledge you can implement it in the

667
00:25:19,760 --> 00:25:22,240
code so the malware will compare the

668
00:25:22,240 --> 00:25:24,640
computer name to uh to what you actually

669
00:25:24,640 --> 00:25:27,039
placed in there and then

670
00:25:27,039 --> 00:25:29,919
it will actually run only on the uh on

671
00:25:29,919 --> 00:25:32,799
the our target also this is uh this is

672
00:25:32,799 --> 00:25:35,120
also useful when it comes to skipping

673
00:25:35,120 --> 00:25:37,679
the the malware analytics because

674
00:25:37,679 --> 00:25:40,000
analytics will also have uh what won't

675
00:25:40,000 --> 00:25:42,480
have that that that the same computer

676
00:25:42,480 --> 00:25:45,360
name same story for uh for user name if

677
00:25:45,360 --> 00:25:48,320
you are facing a certain username you

678
00:25:48,320 --> 00:25:50,400
can also do that one fun fact you can

679
00:25:50,400 --> 00:25:51,279
also

680
00:25:51,279 --> 00:25:53,679
check if the computer is the main joint

681
00:25:53,679 --> 00:25:55,840
because probably we will be facing

682
00:25:55,840 --> 00:25:59,120
domain joined computers and

683
00:25:59,120 --> 00:26:00,799
you can also check

684
00:26:00,799 --> 00:26:03,120
for the connected usb devices because

685
00:26:03,120 --> 00:26:06,000
probably you won't spot a computer with

686
00:26:06,000 --> 00:26:07,120
this

687
00:26:07,120 --> 00:26:09,039
device's

688
00:26:09,039 --> 00:26:11,360
number of zero so if if this is like a

689
00:26:11,360 --> 00:26:14,720
very fresh machine or maybe the sandbox

690
00:26:14,720 --> 00:26:17,679
you probably will have zero in

691
00:26:17,679 --> 00:26:18,799
in there

692
00:26:18,799 --> 00:26:21,440
uh for those of you who have uh

693
00:26:21,440 --> 00:26:24,799
installed some guest additions in any

694
00:26:24,799 --> 00:26:27,120
virtual machine you know that this

695
00:26:27,120 --> 00:26:29,120
guest additions they also add something

696
00:26:29,120 --> 00:26:31,760
some artifacts to both registry and to

697
00:26:31,760 --> 00:26:32,640
the

698
00:26:32,640 --> 00:26:34,640
system files so you can browse through

699
00:26:34,640 --> 00:26:35,360
the

700
00:26:35,360 --> 00:26:37,760
disk all the registry to check for the

701
00:26:37,760 --> 00:26:39,840
certain strings which may be

702
00:26:39,840 --> 00:26:42,240
characteristic for both uh virtual

703
00:26:42,240 --> 00:26:45,279
environment and some some boxes and in

704
00:26:45,279 --> 00:26:47,600
case they are spotted just stop the

705
00:26:47,600 --> 00:26:50,320
execution flow and also you can do the

706
00:26:50,320 --> 00:26:52,320
same for the network devices because the

707
00:26:52,320 --> 00:26:55,360
mac address of this virtual uh

708
00:26:55,360 --> 00:26:58,080
network adapters they're

709
00:26:58,080 --> 00:27:00,480
quite quite common and you can also

710
00:27:00,480 --> 00:27:01,440
check for

711
00:27:01,440 --> 00:27:02,720
for those

712
00:27:02,720 --> 00:27:06,400
and the timer is counting but

713
00:27:06,400 --> 00:27:08,799
but also there's one funny thing about

714
00:27:08,799 --> 00:27:10,159
sleep

715
00:27:10,159 --> 00:27:11,760
you love yeah we don't have much to how

716
00:27:11,760 --> 00:27:13,760
much time left but let's quickly

717
00:27:13,760 --> 00:27:17,200
talk about the time you're conceiving so

718
00:27:17,200 --> 00:27:19,279
we have

719
00:27:19,279 --> 00:27:21,760
some functions like sleep or individual

720
00:27:21,760 --> 00:27:24,159
execution to

721
00:27:24,159 --> 00:27:26,080
delay the execution of our exam

722
00:27:26,080 --> 00:27:28,799
application and we could use this to

723
00:27:28,799 --> 00:27:31,120
just to time out the analysis because

724
00:27:31,120 --> 00:27:32,240
let's say

725
00:27:32,240 --> 00:27:33,360
sandbox

726
00:27:33,360 --> 00:27:35,600
usually have a few minutes allocated for

727
00:27:35,600 --> 00:27:38,000
for sample analysis and

728
00:27:38,000 --> 00:27:40,399
it would be a good idea to just see the

729
00:27:40,399 --> 00:27:42,159
application for like let's say half an

730
00:27:42,159 --> 00:27:44,559
hour and then skip the analysis so what

731
00:27:44,559 --> 00:27:48,080
the sandbox can do is

732
00:27:48,080 --> 00:27:49,039
just

733
00:27:49,039 --> 00:27:51,039
hook the function

734
00:27:51,039 --> 00:27:54,480
and return some some false uh

735
00:27:54,480 --> 00:27:59,200
information about about the time past so

736
00:28:00,080 --> 00:28:02,480
let's say we are uh

737
00:28:02,480 --> 00:28:04,080
sleeping for for

738
00:28:04,080 --> 00:28:05,279
one hour

739
00:28:05,279 --> 00:28:07,440
and the sleep was fast forwarded by by

740
00:28:07,440 --> 00:28:08,799
the sandbox

741
00:28:08,799 --> 00:28:11,039
due to function hugging we think we

742
00:28:11,039 --> 00:28:12,640
could then check

743
00:28:12,640 --> 00:28:13,440
uh

744
00:28:13,440 --> 00:28:14,799
what

745
00:28:14,799 --> 00:28:17,039
amount of time actually passed so if

746
00:28:17,039 --> 00:28:19,279
it's uh less than the one hour we can

747
00:28:19,279 --> 00:28:21,120
assume that it's sandbox

748
00:28:21,120 --> 00:28:23,279
or some some other

749
00:28:23,279 --> 00:28:24,720
fake environment

750
00:28:24,720 --> 00:28:26,880
but the thing is the the function that

751
00:28:26,880 --> 00:28:28,240
is returning

752
00:28:28,240 --> 00:28:30,559
the system up time or

753
00:28:30,559 --> 00:28:32,799
wherever we use to calculate the actual

754
00:28:32,799 --> 00:28:35,840
time all can also be hooked uh to return

755
00:28:35,840 --> 00:28:37,600
the false time

756
00:28:37,600 --> 00:28:39,919
with the

757
00:28:39,919 --> 00:28:42,080
aligned to this fast forward that sleeps

758
00:28:42,080 --> 00:28:44,320
but there's there is another thing we

759
00:28:44,320 --> 00:28:46,000
can do there is some

760
00:28:46,000 --> 00:28:48,720
kernel data structure it's called k user

761
00:28:48,720 --> 00:28:50,799
data and as its

762
00:28:50,799 --> 00:28:53,120
name says it's some kernel data shared

763
00:28:53,120 --> 00:28:55,200
with user and there are

764
00:28:55,200 --> 00:28:57,200
some on this data structure

765
00:28:57,200 --> 00:28:59,360
the actual system up time is located and

766
00:28:59,360 --> 00:29:02,080
this requires some some

767
00:29:02,080 --> 00:29:03,840
gimmicks and

768
00:29:03,840 --> 00:29:05,360
points or mathematics and calculation

769
00:29:05,360 --> 00:29:06,480
but

770
00:29:06,480 --> 00:29:09,279
ultimately we can get the i think it's

771
00:29:09,279 --> 00:29:10,080
most

772
00:29:10,080 --> 00:29:13,440
reliable uh source of the system time

773
00:29:13,440 --> 00:29:15,919
and we can compare this before and after

774
00:29:15,919 --> 00:29:17,840
sleeping to see if the sleep function

775
00:29:17,840 --> 00:29:19,679
was hooked and our

776
00:29:19,679 --> 00:29:23,600
execution delay was fast forwarded

777
00:29:25,039 --> 00:29:26,880
and uh about

778
00:29:26,880 --> 00:29:29,120
some some a few words about function

779
00:29:29,120 --> 00:29:31,919
hooking why it's it's done for example

780
00:29:31,919 --> 00:29:35,200
by some boxes or evrs so to to monitor

781
00:29:35,200 --> 00:29:37,919
my relationship behavior for example to

782
00:29:37,919 --> 00:29:39,679
fast forward i

783
00:29:39,679 --> 00:29:42,000
execution delay attempts or to monitor

784
00:29:42,000 --> 00:29:43,679
some some

785
00:29:43,679 --> 00:29:45,360
suspicious functions that are used for

786
00:29:45,360 --> 00:29:46,640
example

787
00:29:46,640 --> 00:29:49,360
create thread or the lowest level

788
00:29:49,360 --> 00:29:51,440
antiquater idx function this can be

789
00:29:51,440 --> 00:29:53,600
monitored to see

790
00:29:53,600 --> 00:29:55,440
what is

791
00:29:55,440 --> 00:29:56,559
what kind of

792
00:29:56,559 --> 00:29:59,279
threads threads are created in in which

793
00:29:59,279 --> 00:30:01,279
processes for example to decide if it's

794
00:30:01,279 --> 00:30:02,960
something measures or not

795
00:30:02,960 --> 00:30:04,960
or

796
00:30:04,960 --> 00:30:08,720
the anti-radical memory it's used by all

797
00:30:08,720 --> 00:30:11,120
those dumping functions that

798
00:30:11,120 --> 00:30:12,720
for example

799
00:30:12,720 --> 00:30:15,440
this pro program tool it's using that or

800
00:30:15,440 --> 00:30:17,440
some some other custom tools can use

801
00:30:17,440 --> 00:30:18,640
that for example to

802
00:30:18,640 --> 00:30:21,760
dump lsa sets memory so some edr for

803
00:30:21,760 --> 00:30:23,039
example can we can monitor those

804
00:30:23,039 --> 00:30:24,880
functions and just block

805
00:30:24,880 --> 00:30:27,600
the anti-reduction memory call if it's

806
00:30:27,600 --> 00:30:29,840
targeting the lsat process

807
00:30:29,840 --> 00:30:31,919
so

808
00:30:31,919 --> 00:30:33,840
it's some kind of

809
00:30:33,840 --> 00:30:36,640
defensive measure and we can also try to

810
00:30:36,640 --> 00:30:40,399
bypass this so to find hooks we can

811
00:30:40,399 --> 00:30:41,919
find our

812
00:30:41,919 --> 00:30:44,320
functions in the ls loaded memory and

813
00:30:44,320 --> 00:30:46,559
check if they are modified for example

814
00:30:46,559 --> 00:30:48,159
by

815
00:30:48,159 --> 00:30:50,000
checking first instructions or just

816
00:30:50,000 --> 00:30:52,159
comparing them with original development

817
00:30:52,159 --> 00:30:53,919
disk

818
00:30:53,919 --> 00:30:55,679
and also uh

819
00:30:55,679 --> 00:30:57,200
in the same way we can unhook the

820
00:30:57,200 --> 00:30:59,200
function so let's say we have some some

821
00:30:59,200 --> 00:31:00,480
hooked function

822
00:31:00,480 --> 00:31:02,159
and we know it's hooked so the

823
00:31:02,159 --> 00:31:03,519
instructions are modified and the

824
00:31:03,519 --> 00:31:06,320
execution flow is transferred to some

825
00:31:06,320 --> 00:31:08,960
library of some edr tool or wherever

826
00:31:08,960 --> 00:31:11,120
it's loaded in memory

827
00:31:11,120 --> 00:31:13,279
uh we can just

828
00:31:13,279 --> 00:31:15,760
replace the first bytes to restore the

829
00:31:15,760 --> 00:31:17,600
the original

830
00:31:17,600 --> 00:31:19,519
function flow and then call this

831
00:31:19,519 --> 00:31:21,679
function which will be unhooked and this

832
00:31:21,679 --> 00:31:23,919
should help us to bypass those

833
00:31:23,919 --> 00:31:26,159
detections based on function hooking by

834
00:31:26,159 --> 00:31:28,000
sandboxes for edrs

835
00:31:28,000 --> 00:31:30,000
and others

836
00:31:30,000 --> 00:31:32,159
another kind of bypass of function

837
00:31:32,159 --> 00:31:34,799
hooking we can just execute the ciscos

838
00:31:34,799 --> 00:31:37,039
directly so here we have example of

839
00:31:37,039 --> 00:31:40,799
create thread call stack and ultimately

840
00:31:40,799 --> 00:31:42,559
the lowest level

841
00:31:42,559 --> 00:31:45,678
in user space the

842
00:31:47,600 --> 00:31:48,799
and

843
00:31:48,799 --> 00:31:50,720
on the right you see the actual

844
00:31:50,720 --> 00:31:52,480
implementation of this function and it's

845
00:31:52,480 --> 00:31:54,559
just a cisco so it's called specific

846
00:31:54,559 --> 00:31:56,640
processor instruction to transfer the

847
00:31:56,640 --> 00:31:58,799
execution flow to kernel and then the

848
00:31:58,799 --> 00:32:00,799
kernel is is

849
00:32:00,799 --> 00:32:02,799
handling the the thread creation

850
00:32:02,799 --> 00:32:04,720
prosecution and lots of other stuff so

851
00:32:04,720 --> 00:32:06,880
we can just try to

852
00:32:06,880 --> 00:32:10,399
directly call the kernel and bypass

853
00:32:10,399 --> 00:32:12,640
all those hooks if they are implemented

854
00:32:12,640 --> 00:32:13,600
so

855
00:32:13,600 --> 00:32:15,679
to do this

856
00:32:15,679 --> 00:32:17,279
it's it's some

857
00:32:17,279 --> 00:32:19,120
quick tutorial how to do this in c in

858
00:32:19,120 --> 00:32:21,760
assembly so we define the cisco in

859
00:32:21,760 --> 00:32:25,760
assembly then we define the function

860
00:32:25,760 --> 00:32:28,000
in c as an external function which would

861
00:32:28,000 --> 00:32:30,080
be

862
00:32:30,080 --> 00:32:32,960
like imported from disassembly compiled

863
00:32:32,960 --> 00:32:35,919
and the function has to

864
00:32:35,919 --> 00:32:39,279
get all the needed parameters so so

865
00:32:39,279 --> 00:32:41,519
this would be placed on registers in

866
00:32:41,519 --> 00:32:44,320
stock and then after issuing the cisco

867
00:32:44,320 --> 00:32:45,760
calling

868
00:32:45,760 --> 00:32:48,080
this function would actually

869
00:32:48,080 --> 00:32:50,559
invoke the cisco and specific parameters

870
00:32:50,559 --> 00:32:52,399
will be present in the right places and

871
00:32:52,399 --> 00:32:53,600
kernel would

872
00:32:53,600 --> 00:32:55,600
know what to do with this and for

873
00:32:55,600 --> 00:32:57,440
example create this this new thread in

874
00:32:57,440 --> 00:32:58,799
our process

875
00:32:58,799 --> 00:33:01,360
so this would bypass some user land

876
00:33:01,360 --> 00:33:02,640
hooks

877
00:33:02,640 --> 00:33:07,360
put there by edrs or sandboxes

878
00:33:08,640 --> 00:33:12,399
and some anti-debugging

879
00:33:13,120 --> 00:33:15,679
we can implement some

880
00:33:15,679 --> 00:33:18,000
either very trivial or more advanced

881
00:33:18,000 --> 00:33:20,240
checks we will just go through

882
00:33:20,240 --> 00:33:21,600
some of them

883
00:33:21,600 --> 00:33:23,600
and

884
00:33:23,600 --> 00:33:24,960
there is this function is debugger

885
00:33:24,960 --> 00:33:25,919
present

886
00:33:25,919 --> 00:33:26,640
and

887
00:33:26,640 --> 00:33:29,200
obviously it returns the status

888
00:33:29,200 --> 00:33:32,000
unless it's it's modified by analyst

889
00:33:32,000 --> 00:33:33,600
or for example

890
00:33:33,600 --> 00:33:36,559
debuggers also can can

891
00:33:36,559 --> 00:33:38,799
tamper with this data so

892
00:33:38,799 --> 00:33:41,440
to bypass just the simplest debugging we

893
00:33:41,440 --> 00:33:44,640
can we can check this uh

894
00:33:44,640 --> 00:33:47,200
this status of his debugger present or

895
00:33:47,200 --> 00:33:49,760
some other flux because his debugger

896
00:33:49,760 --> 00:33:51,679
present is just checking a big box

897
00:33:51,679 --> 00:33:53,600
flagging process from around the block

898
00:33:53,600 --> 00:33:55,600
and this anti-global flag this the

899
00:33:55,600 --> 00:33:57,519
second flag is also located in process

900
00:33:57,519 --> 00:34:00,399
garment block and it indicates if the

901
00:34:00,399 --> 00:34:03,919
process is debugged or not so to

902
00:34:03,919 --> 00:34:06,720
that just simplest and debugging measure

903
00:34:06,720 --> 00:34:07,519
it's

904
00:34:07,519 --> 00:34:10,800
easy to bypass this but

905
00:34:10,800 --> 00:34:12,800
when we are dealing with some automated

906
00:34:12,800 --> 00:34:15,119
debugging core or i don't know

907
00:34:15,119 --> 00:34:18,639
non-advanced analyst we can just

908
00:34:18,639 --> 00:34:22,000
try to to check those flags and then

909
00:34:22,000 --> 00:34:23,760
if the process is debugged just

910
00:34:23,760 --> 00:34:26,399
terminate it

911
00:34:26,800 --> 00:34:29,839
and some some example of of more

912
00:34:29,839 --> 00:34:32,239
advanced anti-debugging measure

913
00:34:32,239 --> 00:34:34,639
we can implement implement some function

914
00:34:34,639 --> 00:34:36,879
let's say we have this crucial function

915
00:34:36,879 --> 00:34:38,399
and

916
00:34:38,399 --> 00:34:39,839
right after the function implements some

917
00:34:39,839 --> 00:34:41,839
some other function and then

918
00:34:41,839 --> 00:34:44,560
during the runtime try to calculate the

919
00:34:44,560 --> 00:34:47,679
function bytes hash so if we have this

920
00:34:47,679 --> 00:34:49,839
function unmodified in memory the hash

921
00:34:49,839 --> 00:34:50,800
would

922
00:34:50,800 --> 00:34:52,800
have the specific value but for example

923
00:34:52,800 --> 00:34:55,599
if there's a breakpoint placed in this

924
00:34:55,599 --> 00:34:57,599
crucial function of ours

925
00:34:57,599 --> 00:34:58,400
the

926
00:34:58,400 --> 00:35:00,800
hash of the assembly in memory would be

927
00:35:00,800 --> 00:35:03,040
different so we could for example have

928
00:35:03,040 --> 00:35:05,520
another thread running uh regularly

929
00:35:05,520 --> 00:35:06,720
checking the

930
00:35:06,720 --> 00:35:07,760
uh

931
00:35:07,760 --> 00:35:10,160
op codes so assembly and calculating

932
00:35:10,160 --> 00:35:11,280
hash of the assembly of specific

933
00:35:11,280 --> 00:35:13,599
function we are interested in and to see

934
00:35:13,599 --> 00:35:16,079
if it's being modified by for example

935
00:35:16,079 --> 00:35:18,800
some some breakpoint or some other uh

936
00:35:18,800 --> 00:35:21,359
manual tampering by by analyst using

937
00:35:21,359 --> 00:35:23,040
debugger and then for example terminate

938
00:35:23,040 --> 00:35:24,560
the process when we detect such an

939
00:35:24,560 --> 00:35:25,680
activity

940
00:35:25,680 --> 00:35:26,400
so

941
00:35:26,400 --> 00:35:29,280
one of many examples of

942
00:35:29,280 --> 00:35:32,000
some cool and debugging stuff

943
00:35:32,000 --> 00:35:34,320
and also to

944
00:35:34,320 --> 00:35:35,440
make

945
00:35:35,440 --> 00:35:36,640
money well analysis a little bit

946
00:35:36,640 --> 00:35:37,599
difficult

947
00:35:37,599 --> 00:35:40,480
we can implement some

948
00:35:40,480 --> 00:35:41,440
uh

949
00:35:41,440 --> 00:35:43,680
callbacks so there are some asynchronous

950
00:35:43,680 --> 00:35:44,960
functions like

951
00:35:44,960 --> 00:35:46,320
read file

952
00:35:46,320 --> 00:35:48,240
this extend version so

953
00:35:48,240 --> 00:35:49,920
normally read file just work

954
00:35:49,920 --> 00:35:52,160
synchronously and returns the handle to

955
00:35:52,160 --> 00:35:53,680
file when it's

956
00:35:53,680 --> 00:35:55,440
loaded from

957
00:35:55,440 --> 00:35:56,839
red from

958
00:35:56,839 --> 00:36:00,079
specific place and this with fire ex

959
00:36:00,079 --> 00:36:03,040
function it can

960
00:36:03,040 --> 00:36:05,920
be can work asynchronously and then just

961
00:36:05,920 --> 00:36:09,520
monitor us when when the file is

962
00:36:09,520 --> 00:36:12,160
when the file read is finished so in

963
00:36:12,160 --> 00:36:15,359
this piece of code

964
00:36:15,599 --> 00:36:16,480
the

965
00:36:16,480 --> 00:36:18,000
callback my callback function will be

966
00:36:18,000 --> 00:36:20,400
called after the file has been read and

967
00:36:20,400 --> 00:36:22,079
we can implement some some malicious

968
00:36:22,079 --> 00:36:25,680
activity in this callback so when uh

969
00:36:25,680 --> 00:36:28,880
analyst just jumps over the

970
00:36:28,880 --> 00:36:31,119
call to read file

971
00:36:31,119 --> 00:36:33,520
uh the the shell caller wherever we are

972
00:36:33,520 --> 00:36:34,880
executing in this call but would be

973
00:36:34,880 --> 00:36:36,000
executed

974
00:36:36,000 --> 00:36:38,240
somehow in in background so it would be

975
00:36:38,240 --> 00:36:41,359
harder to spot this so an analyst would

976
00:36:41,359 --> 00:36:43,280
need to click

977
00:36:43,280 --> 00:36:45,920
step by step through this uh read file

978
00:36:45,920 --> 00:36:48,800
call to locate this this callback so so

979
00:36:48,800 --> 00:36:50,960
it's it's could have some kind of cool

980
00:36:50,960 --> 00:36:52,400
trick to

981
00:36:52,400 --> 00:36:55,839
hinder with manual analysis

982
00:36:56,400 --> 00:36:59,839
so uh yeah that's that's it and uh we

983
00:36:59,839 --> 00:37:02,000
don't have much time left so maybe let's

984
00:37:02,000 --> 00:37:04,240
go quickly through the other clever

985
00:37:04,240 --> 00:37:06,800
techniques uh so the first one is there

986
00:37:06,800 --> 00:37:08,880
is the parenthetic proofing so

987
00:37:08,880 --> 00:37:11,119
uh this is like the simple uh simple

988
00:37:11,119 --> 00:37:13,359
method to uh

989
00:37:13,359 --> 00:37:14,880
hide the

990
00:37:14,880 --> 00:37:16,960
apparent process in the relation like

991
00:37:16,960 --> 00:37:19,680
the parent child and

992
00:37:19,680 --> 00:37:22,480
you can you can actually uh prove that

993
00:37:22,480 --> 00:37:24,800
in order to hide for example uh block

994
00:37:24,800 --> 00:37:27,119
motors activity like uh

995
00:37:27,119 --> 00:37:28,960
word or excel application starting

996
00:37:28,960 --> 00:37:31,680
powershell you probably uh want to want

997
00:37:31,680 --> 00:37:34,160
to hide that some uh some antivirus and

998
00:37:34,160 --> 00:37:35,839
some monitoring tools have alerts for

999
00:37:35,839 --> 00:37:38,240
that so that's that's kinda useful

1000
00:37:38,240 --> 00:37:40,720
uh also uh we've

1001
00:37:40,720 --> 00:37:42,160
previously we've talked briefly about

1002
00:37:42,160 --> 00:37:44,560
dixor encryption or so you can take it

1003
00:37:44,560 --> 00:37:46,880
to the whole level and you can use some

1004
00:37:46,880 --> 00:37:50,160
advanced uh encryption techniques uh to

1005
00:37:50,160 --> 00:37:51,200
to hide

1006
00:37:51,200 --> 00:37:52,560
data and

1007
00:37:52,560 --> 00:37:53,359
the

1008
00:37:53,359 --> 00:37:55,520
from being

1009
00:37:55,520 --> 00:37:58,800
being decoded and you can also

1010
00:37:58,800 --> 00:38:01,599
encrypt any data before putting it in it

1011
00:38:01,599 --> 00:38:05,520
into the application and then

1012
00:38:05,520 --> 00:38:07,599
just try to brute force that instead of

1013
00:38:07,599 --> 00:38:09,440
hard coding

1014
00:38:09,440 --> 00:38:10,630
a key in the

1015
00:38:10,630 --> 00:38:12,079
[Music]

1016
00:38:12,079 --> 00:38:13,920
in the source code it will make the

1017
00:38:13,920 --> 00:38:16,640
analysis even more difficult uh you can

1018
00:38:16,640 --> 00:38:18,560
also for example build a pipeline if

1019
00:38:18,560 --> 00:38:20,480
which uses the random key for each each

1020
00:38:20,480 --> 00:38:23,119
compilation and this will be a pretty

1021
00:38:23,119 --> 00:38:25,280
pretty much a funny thing

1022
00:38:25,280 --> 00:38:28,000
and the last one is somehow uh

1023
00:38:28,000 --> 00:38:29,760
connected to the sandbox evasion we've

1024
00:38:29,760 --> 00:38:31,839
talked before you can use environmental

1025
00:38:31,839 --> 00:38:34,000
keying so you can target the specific

1026
00:38:34,000 --> 00:38:36,320
organization or even the person uh just

1027
00:38:36,320 --> 00:38:38,079
by just checking and placing some

1028
00:38:38,079 --> 00:38:40,880
conditional statements like uh username

1029
00:38:40,880 --> 00:38:42,800
or computer name

1030
00:38:42,800 --> 00:38:43,839
before the

1031
00:38:43,839 --> 00:38:45,599
first the software is

1032
00:38:45,599 --> 00:38:46,800
executed

1033
00:38:46,800 --> 00:38:49,680
yeah we made we made it in time i guess

1034
00:38:49,680 --> 00:38:52,800
uh so uh so that's that's it what we

1035
00:38:52,800 --> 00:38:54,400
have for you today when

1036
00:38:54,400 --> 00:38:56,240
we encourage you to visit patrick's blog

1037
00:38:56,240 --> 00:38:58,160
there are a couple of more clever

1038
00:38:58,160 --> 00:38:59,280
techniques

1039
00:38:59,280 --> 00:39:00,800
to go through

1040
00:39:00,800 --> 00:39:03,040
so thank you let's let's go back to the

1041
00:39:03,040 --> 00:39:06,040
studio

