1
00:00:09,760 --> 00:00:10,240
okay

2
00:00:10,240 --> 00:00:12,960
so welcome um today i will show you how

3
00:00:12,960 --> 00:00:13,519
to

4
00:00:13,519 --> 00:00:16,880
design and test your own hardware trojan

5
00:00:16,880 --> 00:00:19,680
will do it exploiting a cpu vector for

6
00:00:19,680 --> 00:00:22,320
x86 architecture

7
00:00:22,320 --> 00:00:24,000
um before i will start the show

8
00:00:24,000 --> 00:00:25,359
disclaimer that

9
00:00:25,359 --> 00:00:26,960
the presented work disseminates the

10
00:00:26,960 --> 00:00:28,800
results of my spare time activities

11
00:00:28,800 --> 00:00:30,640
done solely using my own private

12
00:00:30,640 --> 00:00:31,840
resources

13
00:00:31,840 --> 00:00:33,440
therefore the views and opinions

14
00:00:33,440 --> 00:00:34,880
expressed in this presentation

15
00:00:34,880 --> 00:00:36,399
mine and mine only and do not

16
00:00:36,399 --> 00:00:38,239
necessarily reflect the official policy

17
00:00:38,239 --> 00:00:40,559
and position of my employer

18
00:00:40,559 --> 00:00:42,719
examples presented within this work are

19
00:00:42,719 --> 00:00:44,640
only for demonstration proposes and does

20
00:00:44,640 --> 00:00:45,520
not necessarily

21
00:00:45,520 --> 00:00:48,960
reflect real world products so for these

22
00:00:48,960 --> 00:00:51,199
of you we just joined this presentation

23
00:00:51,199 --> 00:00:51,760
or which

24
00:00:51,760 --> 00:00:54,079
uh i never read the description what the

25
00:00:54,079 --> 00:00:55,360
stock will be about

26
00:00:55,360 --> 00:00:58,239
and the stock would like to discuss

27
00:00:58,239 --> 00:01:00,160
three questions which you see right now

28
00:01:00,160 --> 00:01:02,239
um how difficult it is to introduce a

29
00:01:02,239 --> 00:01:04,239
hardware trojan or vector into modern

30
00:01:04,239 --> 00:01:05,600
electronic equipment

31
00:01:05,600 --> 00:01:07,680
how attacker can exploit such threats

32
00:01:07,680 --> 00:01:09,680
and extract your data

33
00:01:09,680 --> 00:01:11,840
and what are principles of work of such

34
00:01:11,840 --> 00:01:12,880
circuits

35
00:01:12,880 --> 00:01:15,200
so if those questions are interesting to

36
00:01:15,200 --> 00:01:16,479
you or you wanted

37
00:01:16,479 --> 00:01:18,159
always to start your adventure with

38
00:01:18,159 --> 00:01:19,920
hardware security

39
00:01:19,920 --> 00:01:22,000
or you just like to refresh your

40
00:01:22,000 --> 00:01:23,439
knowledge with respect to hardware

41
00:01:23,439 --> 00:01:24,799
threats then the stock is

42
00:01:24,799 --> 00:01:28,159
for you i assume that majority of you

43
00:01:28,159 --> 00:01:32,000
never designed or had not so much

44
00:01:32,000 --> 00:01:35,600
experience with uh design of hardware

45
00:01:35,600 --> 00:01:39,439
uh and um so therefore i will introduce

46
00:01:39,439 --> 00:01:41,280
some basics but i also hope that people

47
00:01:41,280 --> 00:01:41,840
which have

48
00:01:41,840 --> 00:01:44,079
experience will find the stock

49
00:01:44,079 --> 00:01:45,040
refreshing we'll

50
00:01:45,040 --> 00:01:47,600
find some things uh which they never

51
00:01:47,600 --> 00:01:49,360
thought about

52
00:01:49,360 --> 00:01:51,920
so um the motivation behind hardware

53
00:01:51,920 --> 00:01:53,200
security

54
00:01:53,200 --> 00:01:56,159
is i think pretty obvious first of all

55
00:01:56,159 --> 00:01:57,040
um

56
00:01:57,040 --> 00:01:59,840
uh the importance of it is confirmed but

57
00:01:59,840 --> 00:02:01,600
by the fact that it's very hot topic in

58
00:02:01,600 --> 00:02:03,280
media there are many discussions

59
00:02:03,280 --> 00:02:05,439
we've got 5g network controversies some

60
00:02:05,439 --> 00:02:07,280
companies were accused

61
00:02:07,280 --> 00:02:09,520
and even the whole institution of

62
00:02:09,520 --> 00:02:10,800
providing

63
00:02:10,800 --> 00:02:12,800
critical infrastructure which could have

64
00:02:12,800 --> 00:02:14,560
potential hardware threats

65
00:02:14,560 --> 00:02:16,560
we've got vulnerabilities in x86

66
00:02:16,560 --> 00:02:17,760
processors

67
00:02:17,760 --> 00:02:20,879
uh for instance a meltdown inspector now

68
00:02:20,879 --> 00:02:22,560
from intel

69
00:02:22,560 --> 00:02:25,280
in october 2018 bloomberg reported that

70
00:02:25,280 --> 00:02:26,160
hardware

71
00:02:26,160 --> 00:02:28,000
trojan could reach almost 30 us

72
00:02:28,000 --> 00:02:29,520
companies including amazon

73
00:02:29,520 --> 00:02:32,879
apple um although never specific

74
00:02:32,879 --> 00:02:35,120
trojan designer chip was presented

75
00:02:35,120 --> 00:02:36,400
public

76
00:02:36,400 --> 00:02:38,800
recently there was massive intel ip data

77
00:02:38,800 --> 00:02:40,720
breach which mentions vector

78
00:02:40,720 --> 00:02:43,519
the context here is still unclear so

79
00:02:43,519 --> 00:02:43,840
some

80
00:02:43,840 --> 00:02:46,480
speculate it's a security vector the

81
00:02:46,480 --> 00:02:48,319
others speculate it's just

82
00:02:48,319 --> 00:02:51,599
some programming structure but still the

83
00:02:51,599 --> 00:02:53,840
fact that this notion is discussed

84
00:02:53,840 --> 00:02:56,560
with regard to intel and leads to very

85
00:02:56,560 --> 00:02:58,080
strong discussions

86
00:02:58,080 --> 00:03:01,360
um uh shows that the topic is important

87
00:03:01,360 --> 00:03:04,720
and also in research in 2008 if you look

88
00:03:04,720 --> 00:03:07,680
uh on google scholar for hardware

89
00:03:07,680 --> 00:03:08,720
georgian design

90
00:03:08,720 --> 00:03:12,239
you will get 6680 results and this

91
00:03:12,239 --> 00:03:13,599
includes patents

92
00:03:13,599 --> 00:03:16,879
in 2019 we have 7160

93
00:03:16,879 --> 00:03:19,360
and until september so until yesterday

94
00:03:19,360 --> 00:03:21,760
we have 6050 already

95
00:03:21,760 --> 00:03:24,959
which uh so so i think the trend is um

96
00:03:24,959 --> 00:03:28,159
um clear it's constantly increasing

97
00:03:28,159 --> 00:03:31,519
there's more and more uh money and and

98
00:03:31,519 --> 00:03:34,400
resources which are directed towards

99
00:03:34,400 --> 00:03:35,120
hardware

100
00:03:35,120 --> 00:03:38,400
uh on the security

101
00:03:38,400 --> 00:03:42,879
and um counter counter measures

102
00:03:42,879 --> 00:03:45,120
but there is still no smoking gun

103
00:03:45,120 --> 00:03:46,640
evidence so there is still

104
00:03:46,640 --> 00:03:49,040
still no direct evidence of such threat

105
00:03:49,040 --> 00:03:51,200
we had some stories

106
00:03:51,200 --> 00:03:52,720
where there was a cryptographic

107
00:03:52,720 --> 00:03:54,959
equipment uh sold

108
00:03:54,959 --> 00:03:59,680
uh which could be um classified as a

109
00:03:59,680 --> 00:04:03,360
vector or trojan however um there is no

110
00:04:03,360 --> 00:04:05,280
cpu back there for instance which can be

111
00:04:05,280 --> 00:04:07,760
publicly analyzed and confirmed

112
00:04:07,760 --> 00:04:10,879
um showing that this uh was

113
00:04:10,879 --> 00:04:14,239
basically this this this was the

114
00:04:14,239 --> 00:04:17,839
and then the malware or or

115
00:04:17,839 --> 00:04:21,199
malicious part of the hardware um

116
00:04:21,199 --> 00:04:23,919
why this like this um there are there

117
00:04:23,919 --> 00:04:24,560
are many

118
00:04:24,560 --> 00:04:27,600
reasons uh it must not necessarily maybe

119
00:04:27,600 --> 00:04:28,320
there are no

120
00:04:28,320 --> 00:04:32,000
real hardware trojans but we must also

121
00:04:32,000 --> 00:04:33,520
account for the fact that hardware

122
00:04:33,520 --> 00:04:34,560
products

123
00:04:34,560 --> 00:04:36,720
are closed source and reverse is very

124
00:04:36,720 --> 00:04:39,440
expensive and sometimes maybe impossible

125
00:04:39,440 --> 00:04:42,160
um there is you can find many talks

126
00:04:42,160 --> 00:04:42,800
about

127
00:04:42,800 --> 00:04:44,800
reverse engineering of integrated

128
00:04:44,800 --> 00:04:46,639
circuits there was also my talk on

129
00:04:46,639 --> 00:04:48,560
confidence

130
00:04:48,560 --> 00:04:51,680
about this topic so um

131
00:04:51,680 --> 00:04:53,759
that's the one reason and the second

132
00:04:53,759 --> 00:04:55,600
selected errors could be used as an

133
00:04:55,600 --> 00:04:58,080
attack vector but still treated as bugs

134
00:04:58,080 --> 00:05:00,880
so this is a notion which will repeat

135
00:05:00,880 --> 00:05:02,400
throughout this talk

136
00:05:02,400 --> 00:05:05,600
um that hardware is extensively tested

137
00:05:05,600 --> 00:05:09,199
and frequently comes the question

138
00:05:09,199 --> 00:05:12,000
if a malicious manufacturer finds a

139
00:05:12,000 --> 00:05:14,400
buckle or vulnerability and

140
00:05:14,400 --> 00:05:16,800
will not patch it is it already a cpu

141
00:05:16,800 --> 00:05:17,600
back there or

142
00:05:17,600 --> 00:05:21,440
still a bug but many asks

143
00:05:21,440 --> 00:05:24,639
if cpu backdoor or hardware trojans are

144
00:05:24,639 --> 00:05:26,240
conspiracy fury

145
00:05:26,240 --> 00:05:28,880
so once again there is no very direct

146
00:05:28,880 --> 00:05:31,440
evidence of application real products

147
00:05:31,440 --> 00:05:33,680
however everyone can check if this

148
00:05:33,680 --> 00:05:35,120
threat is real

149
00:05:35,120 --> 00:05:37,360
and check the fact if it's practically

150
00:05:37,360 --> 00:05:39,280
feasible

151
00:05:39,280 --> 00:05:41,680
so um that's exactly what i will do in

152
00:05:41,680 --> 00:05:43,440
this talk for you

153
00:05:43,440 --> 00:05:46,800
i will focus on practical example so

154
00:05:46,800 --> 00:05:48,800
we all know that we can emulate running

155
00:05:48,800 --> 00:05:50,000
processor and

156
00:05:50,000 --> 00:05:52,000
very good example of such emulator open

157
00:05:52,000 --> 00:05:54,479
source emulator i think the most popular

158
00:05:54,479 --> 00:05:56,960
is camel which this is a description

159
00:05:56,960 --> 00:05:58,000
from wikipedia

160
00:05:58,000 --> 00:05:59,759
emulates the machine's processor through

161
00:05:59,759 --> 00:06:01,680
dynamic binary translation

162
00:06:01,680 --> 00:06:05,039
and provides a set of different hardware

163
00:06:05,039 --> 00:06:07,840
models for the machine so we can with

164
00:06:07,840 --> 00:06:09,280
camo we can emulate

165
00:06:09,280 --> 00:06:11,919
many different uh processors with

166
00:06:11,919 --> 00:06:13,520
different ease architectures

167
00:06:13,520 --> 00:06:17,120
spark arm x86

168
00:06:17,120 --> 00:06:19,360
so if we can emulate running processor

169
00:06:19,360 --> 00:06:21,280
maybe we can also emulate the cpu with

170
00:06:21,280 --> 00:06:22,000
backdoor

171
00:06:22,000 --> 00:06:24,960
and write an exploit for it on regular

172
00:06:24,960 --> 00:06:27,120
operating system like linux

173
00:06:27,120 --> 00:06:28,800
and this will be a goal of today's

174
00:06:28,800 --> 00:06:30,720
presentation so we are limited in time

175
00:06:30,720 --> 00:06:33,039
but i wanted to show you on a very

176
00:06:33,039 --> 00:06:36,080
um simple example

177
00:06:36,080 --> 00:06:37,759
how what's the logic behind such a

178
00:06:37,759 --> 00:06:40,400
hardware trend how it can be exploited

179
00:06:40,400 --> 00:06:42,720
and what what attacker would like to

180
00:06:42,720 --> 00:06:44,080
achieve

181
00:06:44,080 --> 00:06:47,520
so then in order to to do this

182
00:06:47,520 --> 00:06:51,360
so to emulate regular ax x 86 processor

183
00:06:51,360 --> 00:06:54,240
with a back door and we'll use camel

184
00:06:54,240 --> 00:06:55,680
because it's very popular

185
00:06:55,680 --> 00:06:58,400
emulator and we'll use also a linux

186
00:06:58,400 --> 00:06:59,360
kernel

187
00:06:59,360 --> 00:07:02,160
i i use book build road with uh kernel

188
00:07:02,160 --> 00:07:02,800
version 4

189
00:07:02,800 --> 00:07:06,720
of 1.15 but you can easily apply both

190
00:07:06,720 --> 00:07:10,000
on whatever setup you will have

191
00:07:10,000 --> 00:07:12,000
the idea is that i would like to give

192
00:07:12,000 --> 00:07:13,840
everyone a possibility to repeat the

193
00:07:13,840 --> 00:07:14,960
experiment

194
00:07:14,960 --> 00:07:18,319
yx86 there is no particular reason maybe

195
00:07:18,319 --> 00:07:21,199
the one that many of us were or will be

196
00:07:21,199 --> 00:07:22,560
in the future exposed to these

197
00:07:22,560 --> 00:07:24,720
instructions at architecture have seen

198
00:07:24,720 --> 00:07:26,720
assembler uh which is maybe not the

199
00:07:26,720 --> 00:07:28,080
easiest one

200
00:07:28,080 --> 00:07:31,440
or most elegant one but

201
00:07:31,440 --> 00:07:34,319
still very popular and i think it's very

202
00:07:34,319 --> 00:07:36,800
easy to comprehend what will happen

203
00:07:36,800 --> 00:07:39,680
so modification available on my github

204
00:07:39,680 --> 00:07:40,240
if you

205
00:07:40,240 --> 00:07:42,000
would like to repeat the experiments you

206
00:07:42,000 --> 00:07:43,440
are welcome

207
00:07:43,440 --> 00:07:46,240
just download it and try on your own

208
00:07:46,240 --> 00:07:47,840
setups

209
00:07:47,840 --> 00:07:51,120
so this talk will be structured as

210
00:07:51,120 --> 00:07:52,160
follows

211
00:07:52,160 --> 00:07:54,560
i will firstly revise for you security

212
00:07:54,560 --> 00:07:55,360
mechanisms

213
00:07:55,360 --> 00:07:58,319
in modern processors so ring protection

214
00:07:58,319 --> 00:08:00,960
and memory management are main topics

215
00:08:00,960 --> 00:08:02,879
then i will then will together design a

216
00:08:02,879 --> 00:08:04,400
cpu backdoor

217
00:08:04,400 --> 00:08:07,520
and our design will be confirmed by

218
00:08:07,520 --> 00:08:08,400
proof of concept

219
00:08:08,400 --> 00:08:10,960
implementation using camo x86 cpu

220
00:08:10,960 --> 00:08:12,160
emulator

221
00:08:12,160 --> 00:08:15,280
and then we'll design also and exploit

222
00:08:15,280 --> 00:08:17,919
to leverage the os protection mechanism

223
00:08:17,919 --> 00:08:19,520
for modern linux kernels

224
00:08:19,520 --> 00:08:22,080
after this i will show you live demo so

225
00:08:22,080 --> 00:08:24,000
you will see the background

226
00:08:24,000 --> 00:08:25,919
exploit in action and i will conclude

227
00:08:25,919 --> 00:08:27,840
this talk

228
00:08:27,840 --> 00:08:31,120
so there is uh uh there's this

229
00:08:31,120 --> 00:08:34,240
um assumption which is uh

230
00:08:34,240 --> 00:08:37,360
which forms the basis of the security of

231
00:08:37,360 --> 00:08:40,559
almost all modern systems is that

232
00:08:40,559 --> 00:08:42,799
the processor is operating according to

233
00:08:42,799 --> 00:08:44,240
a strict specification

234
00:08:44,240 --> 00:08:47,360
known set of predefined rules so the set

235
00:08:47,360 --> 00:08:48,640
of predefined rules the

236
00:08:48,640 --> 00:08:50,800
most commonly applied set of predefined

237
00:08:50,800 --> 00:08:51,680
rules there were

238
00:08:51,680 --> 00:08:54,240
others before but right now we are using

239
00:08:54,240 --> 00:08:55,200
uh usual

240
00:08:55,200 --> 00:08:57,519
theoretical protection domains called

241
00:08:57,519 --> 00:08:58,800
protection rings

242
00:08:58,800 --> 00:09:01,040
which were introduced already in 70s for

243
00:09:01,040 --> 00:09:03,360
multics this is a unix predecessor so

244
00:09:03,360 --> 00:09:05,120
it's very old

245
00:09:05,120 --> 00:09:07,519
according to this your processor

246
00:09:07,519 --> 00:09:09,680
independently if you are root user

247
00:09:09,680 --> 00:09:12,640
or regular user independently of your

248
00:09:12,640 --> 00:09:14,000
privileges

249
00:09:14,000 --> 00:09:17,600
processor itself runs at at least

250
00:09:17,600 --> 00:09:19,920
two modes of operation hypervisor and

251
00:09:19,920 --> 00:09:20,720
user

252
00:09:20,720 --> 00:09:23,680
in hypervisor mode kernel of your

253
00:09:23,680 --> 00:09:25,519
operating system has access to all

254
00:09:25,519 --> 00:09:27,440
commands and the whole address space

255
00:09:27,440 --> 00:09:30,240
in user mode only a subset of commands

256
00:09:30,240 --> 00:09:31,519
is available

257
00:09:31,519 --> 00:09:33,440
and transition can happen only according

258
00:09:33,440 --> 00:09:36,160
to the predefined set of rules

259
00:09:36,160 --> 00:09:39,360
so if we apply it to x86

260
00:09:39,360 --> 00:09:42,640
x86 is using this theoretical model

261
00:09:42,640 --> 00:09:45,839
and apply it as follows we have

262
00:09:45,839 --> 00:09:48,560
usually four different privileged rings

263
00:09:48,560 --> 00:09:50,640
and they are numbered from zero which is

264
00:09:50,640 --> 00:09:52,800
the most privileged kernel mode to free

265
00:09:52,800 --> 00:09:54,000
which is least privileged

266
00:09:54,000 --> 00:09:57,760
user um there are two intermediate level

267
00:09:57,760 --> 00:10:00,160
levels which were used before and

268
00:10:00,160 --> 00:10:02,160
probably will be used also in the future

269
00:10:02,160 --> 00:10:04,480
but um they are if they are used it's

270
00:10:04,480 --> 00:10:06,720
it's their usage is not frequent and

271
00:10:06,720 --> 00:10:08,399
they are used for drivers

272
00:10:08,399 --> 00:10:12,160
and some virtualization activities

273
00:10:12,160 --> 00:10:15,440
so um processor must start somewhere

274
00:10:15,440 --> 00:10:17,519
information about the current mode

275
00:10:17,519 --> 00:10:19,440
of its operation whether it be kernel

276
00:10:19,440 --> 00:10:21,040
mode or user mode

277
00:10:21,040 --> 00:10:23,920
so um it's stored in the register in the

278
00:10:23,920 --> 00:10:24,720
processor

279
00:10:24,720 --> 00:10:28,560
uh and this value is called current

280
00:10:28,560 --> 00:10:29,200
privilege

281
00:10:29,200 --> 00:10:33,279
level or cpl and there is a very strong

282
00:10:33,279 --> 00:10:34,240
restriction

283
00:10:34,240 --> 00:10:36,399
who and when can change it so you cannot

284
00:10:36,399 --> 00:10:37,920
just write to

285
00:10:37,920 --> 00:10:41,519
to this um register

286
00:10:41,519 --> 00:10:44,640
and change on your self cpl

287
00:10:44,640 --> 00:10:48,000
um a value it's done for you

288
00:10:48,000 --> 00:10:51,200
in hardware whenever certain actions

289
00:10:51,200 --> 00:10:53,200
are uh conducted in your system i will

290
00:10:53,200 --> 00:10:55,279
be talking about those access actions in

291
00:10:55,279 --> 00:10:56,880
a sec

292
00:10:56,880 --> 00:10:58,800
and then the main resources which are

293
00:10:58,800 --> 00:11:00,399
protected are memory

294
00:11:00,399 --> 00:11:02,640
peripherals which are usually also

295
00:11:02,640 --> 00:11:03,519
memory mapped

296
00:11:03,519 --> 00:11:05,279
and the ability to execute certain

297
00:11:05,279 --> 00:11:06,880
machine instructions

298
00:11:06,880 --> 00:11:09,839
although this is this was popular in the

299
00:11:09,839 --> 00:11:11,519
past right now only few

300
00:11:11,519 --> 00:11:16,000
such instructions in x86 these are exist

301
00:11:16,000 --> 00:11:19,680
and let us see how it works on example

302
00:11:19,680 --> 00:11:22,079
of memory management in x86

303
00:11:22,079 --> 00:11:25,279
uh this is how access to the physical

304
00:11:25,279 --> 00:11:26,640
memory is

305
00:11:26,640 --> 00:11:28,560
happening this is obviously simplified

306
00:11:28,560 --> 00:11:30,959
view but you have your own

307
00:11:30,959 --> 00:11:33,440
assembly instructions from assembly

308
00:11:33,440 --> 00:11:35,040
instructions you're getting logical

309
00:11:35,040 --> 00:11:37,120
address which is passed to segmentation

310
00:11:37,120 --> 00:11:38,240
unit which is

311
00:11:38,240 --> 00:11:41,360
getting leaner address for you then you

312
00:11:41,360 --> 00:11:42,399
may have

313
00:11:42,399 --> 00:11:45,519
but you may but it's not a must you may

314
00:11:45,519 --> 00:11:47,519
switch off paging

315
00:11:47,519 --> 00:11:50,240
and at the end you have physical address

316
00:11:50,240 --> 00:11:51,200
which refers to

317
00:11:51,200 --> 00:11:55,200
your ram modules so in a real mode where

318
00:11:55,200 --> 00:11:56,480
there is no protection

319
00:11:56,480 --> 00:11:59,680
active uh you have segment registers

320
00:11:59,680 --> 00:12:01,680
we have six segment registers there's a

321
00:12:01,680 --> 00:12:03,680
code segment data segment stack segment

322
00:12:03,680 --> 00:12:04,399
and three

323
00:12:04,399 --> 00:12:07,760
registers which you can use freely and

324
00:12:07,760 --> 00:12:10,079
you translate your addresses and your

325
00:12:10,079 --> 00:12:11,600
segmentation units

326
00:12:11,600 --> 00:12:13,920
very simply your assembly instruction

327
00:12:13,920 --> 00:12:14,720
deferred

328
00:12:14,720 --> 00:12:17,519
memory address offset and from code

329
00:12:17,519 --> 00:12:19,680
selector register or data selector

330
00:12:19,680 --> 00:12:21,839
you're using the base address

331
00:12:21,839 --> 00:12:25,279
and you get your linear physical address

332
00:12:25,279 --> 00:12:27,360
if we have a protective mode then your

333
00:12:27,360 --> 00:12:29,680
codes

334
00:12:30,399 --> 00:12:32,880
code segment register does not

335
00:12:32,880 --> 00:12:34,160
necessarily

336
00:12:34,160 --> 00:12:36,560
it doesn't have a raw number but it

337
00:12:36,560 --> 00:12:37,360
contains

338
00:12:37,360 --> 00:12:39,279
index into a table of segment

339
00:12:39,279 --> 00:12:40,639
descriptors

340
00:12:40,639 --> 00:12:42,800
and segment descriptor is providing you

341
00:12:42,800 --> 00:12:43,760
a base address

342
00:12:43,760 --> 00:12:47,360
plus it has also a cpl value the current

343
00:12:47,360 --> 00:12:49,839
it stores also a current cpl value of

344
00:12:49,839 --> 00:12:50,720
your

345
00:12:50,720 --> 00:12:55,360
of your um of your processor

346
00:12:55,360 --> 00:12:58,959
so segmentation protection mode

347
00:12:58,959 --> 00:13:02,399
uh um boils down to to what you see

348
00:13:02,399 --> 00:13:04,079
right now on the screen whenever you're

349
00:13:04,079 --> 00:13:05,839
trying to get some data segment for

350
00:13:05,839 --> 00:13:08,160
instance some memory location

351
00:13:08,160 --> 00:13:11,040
you are uh comparing the maximum of your

352
00:13:11,040 --> 00:13:12,000
cpl

353
00:13:12,000 --> 00:13:15,279
and requested privilege level of your

354
00:13:15,279 --> 00:13:16,720
data which you are requested or

355
00:13:16,720 --> 00:13:17,760
instruction

356
00:13:17,760 --> 00:13:22,000
with the scripture privilege level

357
00:13:22,000 --> 00:13:24,800
it's maximum this maximum is simply

358
00:13:24,800 --> 00:13:25,680
because

359
00:13:25,680 --> 00:13:28,480
if you're in a kernel mode you will also

360
00:13:28,480 --> 00:13:29,120
like to

361
00:13:29,120 --> 00:13:32,639
get the get access to the data

362
00:13:32,639 --> 00:13:35,519
segments from users from with lower

363
00:13:35,519 --> 00:13:36,639
privileges

364
00:13:36,639 --> 00:13:40,000
and as you remember you can written

365
00:13:40,000 --> 00:13:42,240
the higher number signifies lower

366
00:13:42,240 --> 00:13:43,199
privilege

367
00:13:43,199 --> 00:13:47,199
level so if this if is true then you can

368
00:13:47,199 --> 00:13:49,680
access the data and if it's false then

369
00:13:49,680 --> 00:13:52,160
you have protection exception

370
00:13:52,160 --> 00:13:54,639
and then the last thing to revise is how

371
00:13:54,639 --> 00:13:56,720
to switch them all so when to switch

372
00:13:56,720 --> 00:13:59,920
when the cpl level is switched

373
00:13:59,920 --> 00:14:01,680
there are three main events when it

374
00:14:01,680 --> 00:14:03,760
happens it's either a fault

375
00:14:03,760 --> 00:14:05,440
it can be a page fault or some other

376
00:14:05,440 --> 00:14:07,839
exception it can be interrupt a keyboard

377
00:14:07,839 --> 00:14:10,079
interrupt or input output finishing or a

378
00:14:10,079 --> 00:14:10,959
drop

379
00:14:10,959 --> 00:14:13,760
system call so you're running uh you're

380
00:14:13,760 --> 00:14:15,360
executing your process then you have

381
00:14:15,360 --> 00:14:16,000
interrupt

382
00:14:16,000 --> 00:14:19,839
there is a trap of this interrupt and um

383
00:14:19,839 --> 00:14:22,959
the cpl is changed there is a code from

384
00:14:22,959 --> 00:14:24,320
the interrupt descriptor

385
00:14:24,320 --> 00:14:27,040
descriptor table which will be executed

386
00:14:27,040 --> 00:14:28,800
then you're going back from interrupt

387
00:14:28,800 --> 00:14:29,440
routine

388
00:14:29,440 --> 00:14:31,360
and you're switching one take once again

389
00:14:31,360 --> 00:14:33,120
your cpl in hardware and you're

390
00:14:33,120 --> 00:14:36,320
executing your process

391
00:14:36,399 --> 00:14:39,440
so after revision we may start designing

392
00:14:39,440 --> 00:14:40,800
our cpu back there

393
00:14:40,800 --> 00:14:43,120
so before we do it we would like to

394
00:14:43,120 --> 00:14:44,079
firstly establish

395
00:14:44,079 --> 00:14:47,279
the goals of our actions so the

396
00:14:47,279 --> 00:14:49,600
our idea is as simple as possible we

397
00:14:49,600 --> 00:14:50,880
would like to increase the

398
00:14:50,880 --> 00:14:53,279
privileges of currently running process

399
00:14:53,279 --> 00:14:54,399
so we are logged in

400
00:14:54,399 --> 00:14:57,199
as a regular user and would like to be

401
00:14:57,199 --> 00:14:57,760
rude

402
00:14:57,760 --> 00:14:59,920
this is a classic approach i don't have

403
00:14:59,920 --> 00:15:01,199
to explain you

404
00:15:01,199 --> 00:15:03,600
what you can do with your roots when you

405
00:15:03,600 --> 00:15:04,639
did it

406
00:15:04,639 --> 00:15:06,800
but this is an approach which was used

407
00:15:06,800 --> 00:15:08,240
in many other exploits

408
00:15:08,240 --> 00:15:11,519
uh targeting kernel and so

409
00:15:11,519 --> 00:15:14,000
how to do it we would like to find a

410
00:15:14,000 --> 00:15:15,760
place in memory where the information

411
00:15:15,760 --> 00:15:18,079
about the current processes start so

412
00:15:18,079 --> 00:15:20,320
process structure and would like to

413
00:15:20,320 --> 00:15:21,920
modify the data

414
00:15:21,920 --> 00:15:25,199
to override them and to be a root

415
00:15:25,199 --> 00:15:27,120
the challenge is that if we'll try to

416
00:15:27,120 --> 00:15:30,560
access kernel memory with this part

417
00:15:30,560 --> 00:15:33,839
with the structure uh exactly what will

418
00:15:33,839 --> 00:15:34,639
happen will

419
00:15:34,639 --> 00:15:38,000
trigger this memory protection

420
00:15:38,000 --> 00:15:41,199
and we'll get a protection error

421
00:15:41,199 --> 00:15:44,240
um on the screen and in

422
00:15:44,240 --> 00:15:47,839
our system will stop us so the solution

423
00:15:47,839 --> 00:15:50,240
would be our backdoor in cpu we should

424
00:15:50,240 --> 00:15:52,160
switch between the modes

425
00:15:52,160 --> 00:15:55,360
so um it will only switch for us in this

426
00:15:55,360 --> 00:15:57,440
example cpl

427
00:15:57,440 --> 00:16:00,240
and uh or other malicious activities

428
00:16:00,240 --> 00:16:02,079
will be done in software so for instance

429
00:16:02,079 --> 00:16:03,759
overriding the privileges of currently

430
00:16:03,759 --> 00:16:04,800
running process

431
00:16:04,800 --> 00:16:06,959
but this is the most likely way in which

432
00:16:06,959 --> 00:16:09,600
hardware threat will be

433
00:16:09,600 --> 00:16:11,519
exploited it's a hardware software

434
00:16:11,519 --> 00:16:13,440
approach where some parts of the attack

435
00:16:13,440 --> 00:16:15,360
are in done in hardware and

436
00:16:15,360 --> 00:16:16,959
the majority will be still done in

437
00:16:16,959 --> 00:16:18,800
software

438
00:16:18,800 --> 00:16:22,399
so after establishing the goals of our

439
00:16:22,399 --> 00:16:23,600
attack we can start to

440
00:16:23,600 --> 00:16:27,199
design our circuit so just as a revision

441
00:16:27,199 --> 00:16:29,920
um hardware trojan or backdoor would be

442
00:16:29,920 --> 00:16:31,680
a function of a hardware component

443
00:16:31,680 --> 00:16:33,839
hidden from the user which can add

444
00:16:33,839 --> 00:16:35,600
remove or modify the functionality of

445
00:16:35,600 --> 00:16:36,000
hardware

446
00:16:36,000 --> 00:16:37,680
component and therefore reduce its

447
00:16:37,680 --> 00:16:40,800
reliability or create a potential threat

448
00:16:40,800 --> 00:16:43,839
so this function of hardware

449
00:16:43,839 --> 00:16:46,079
is built is constructed from two major

450
00:16:46,079 --> 00:16:46,880
components

451
00:16:46,880 --> 00:16:49,040
it's a payload so this is a modification

452
00:16:49,040 --> 00:16:50,959
of a circuit and a trigger

453
00:16:50,959 --> 00:16:52,800
which will be a signal activating the

454
00:16:52,800 --> 00:16:54,959
payload

455
00:16:54,959 --> 00:16:57,839
so in case of our cpu backdoor design as

456
00:16:57,839 --> 00:16:58,800
a payload

457
00:16:58,800 --> 00:17:01,519
we defined already what we like to do we

458
00:17:01,519 --> 00:17:04,640
would like to change the status of a cpl

459
00:17:04,640 --> 00:17:08,079
the trigger must be visible to the user

460
00:17:08,079 --> 00:17:11,679
from from the user space

461
00:17:11,679 --> 00:17:15,199
so the majority of processors

462
00:17:15,199 --> 00:17:18,160
are governed by instruction set

463
00:17:18,160 --> 00:17:20,160
architecture by assembly comments

464
00:17:20,160 --> 00:17:22,160
therefore we'll use as a trigger

465
00:17:22,160 --> 00:17:23,599
obviously

466
00:17:23,599 --> 00:17:26,319
assembler command but we must assure

467
00:17:26,319 --> 00:17:27,760
that the trigger

468
00:17:27,760 --> 00:17:31,360
um is not easy to detect

469
00:17:31,360 --> 00:17:33,440
so we would like to enforce that

470
00:17:33,440 --> 00:17:35,039
activation happens only in

471
00:17:35,039 --> 00:17:37,840
certain uh processor state and it's not

472
00:17:37,840 --> 00:17:39,200
for instance triggered

473
00:17:39,200 --> 00:17:42,559
randomly in our system so the simplest

474
00:17:42,559 --> 00:17:43,200
trigger

475
00:17:43,200 --> 00:17:46,559
use which one could use is to use some

476
00:17:46,559 --> 00:17:48,400
known on a hidden instruction

477
00:17:48,400 --> 00:17:50,720
for instance there is a salt instruction

478
00:17:50,720 --> 00:17:51,840
i i'm using it

479
00:17:51,840 --> 00:17:54,320
here after a look the vlog which work i

480
00:17:54,320 --> 00:17:55,679
can recommend to everyone who is

481
00:17:55,679 --> 00:17:58,080
interested in the

482
00:17:58,080 --> 00:18:01,200
cpu bacter design we are um

483
00:18:01,200 --> 00:18:03,120
this instruction was available from the

484
00:18:03,120 --> 00:18:06,480
beginning of 8086 architecture but only

485
00:18:06,480 --> 00:18:09,440
documented since fencing pro

486
00:18:09,440 --> 00:18:11,840
note that there are in many esa's some

487
00:18:11,840 --> 00:18:13,919
instruction set architecture there are

488
00:18:13,919 --> 00:18:17,679
certain um set of instructions um

489
00:18:17,679 --> 00:18:20,080
which are still empty they are left

490
00:18:20,080 --> 00:18:21,360
empty spaces

491
00:18:21,360 --> 00:18:23,120
if you look also on the intel manual

492
00:18:23,120 --> 00:18:24,720
there are still

493
00:18:24,720 --> 00:18:26,720
empty spaces instructions at

494
00:18:26,720 --> 00:18:28,080
architecture those are for

495
00:18:28,080 --> 00:18:30,080
instructions and hardware accelerators

496
00:18:30,080 --> 00:18:32,160
which may be coming in the future

497
00:18:32,160 --> 00:18:34,080
we are just reserving some ranges for

498
00:18:34,080 --> 00:18:35,520
them so that

499
00:18:35,520 --> 00:18:38,799
we can offer a backward compatibility of

500
00:18:38,799 --> 00:18:40,840
our products

501
00:18:40,840 --> 00:18:44,400
um and not only instruction we need some

502
00:18:44,400 --> 00:18:45,840
instruction which will trigger at the

503
00:18:45,840 --> 00:18:46,960
end the trojan but

504
00:18:46,960 --> 00:18:50,400
maybe it would be good to put some other

505
00:18:50,400 --> 00:18:51,919
additional conditions so to put

506
00:18:51,919 --> 00:18:53,840
processor in a predefined state

507
00:18:53,840 --> 00:18:55,600
this could be specific values of the

508
00:18:55,600 --> 00:18:57,919
register if a processor has some

509
00:18:57,919 --> 00:18:59,840
other sensor for instance temperature we

510
00:18:59,840 --> 00:19:01,520
could use it as well

511
00:19:01,520 --> 00:19:03,039
and then make some conditional

512
00:19:03,039 --> 00:19:04,799
statements so we are not only running

513
00:19:04,799 --> 00:19:06,960
the instructions we selected but also

514
00:19:06,960 --> 00:19:07,440
check

515
00:19:07,440 --> 00:19:10,559
the state of the whole process

516
00:19:10,559 --> 00:19:14,240
so in camel um

517
00:19:14,240 --> 00:19:16,640
there is this a big switch case in

518
00:19:16,640 --> 00:19:17,919
translation c

519
00:19:17,919 --> 00:19:22,720
a file uh where actually the translation

520
00:19:22,720 --> 00:19:26,160
of the specific instruction happens and

521
00:19:26,160 --> 00:19:28,320
this uh translation here you have

522
00:19:28,320 --> 00:19:29,679
functions which are

523
00:19:29,679 --> 00:19:32,160
altering the state of the emulated

524
00:19:32,160 --> 00:19:33,600
processor

525
00:19:33,600 --> 00:19:36,480
so you you see here from the top to down

526
00:19:36,480 --> 00:19:38,880
you have a case then the

527
00:19:38,880 --> 00:19:42,320
hexadecimal and value of a

528
00:19:42,320 --> 00:19:45,440
other return of instruction from the x86

529
00:19:45,440 --> 00:19:46,240
esa

530
00:19:46,240 --> 00:19:48,400
and then the code which is altering the

531
00:19:48,400 --> 00:19:50,840
processor state

532
00:19:50,840 --> 00:19:54,799
so in order to implement our backdoor

533
00:19:54,799 --> 00:19:58,559
we'll just find the salt instruction um

534
00:19:58,559 --> 00:20:00,960
what i did i just commented the part of

535
00:20:00,960 --> 00:20:02,720
the salt instructions which was doing

536
00:20:02,720 --> 00:20:04,400
what salt is supposed to do

537
00:20:04,400 --> 00:20:06,559
and i have added this part which is

538
00:20:06,559 --> 00:20:07,600
actually a trojan

539
00:20:07,600 --> 00:20:10,559
we are just depending on cpl switching

540
00:20:10,559 --> 00:20:12,559
altering between the kernel mode and

541
00:20:12,559 --> 00:20:13,679
user mode

542
00:20:13,679 --> 00:20:15,520
this is just a quick and dirty proof of

543
00:20:15,520 --> 00:20:17,039
concept implementation

544
00:20:17,039 --> 00:20:19,520
you could do it better you could still

545
00:20:19,520 --> 00:20:20,880
leave that the values

546
00:20:20,880 --> 00:20:24,880
the real salk uh code there

547
00:20:24,880 --> 00:20:27,760
uh you could make some conditions as i

548
00:20:27,760 --> 00:20:29,120
was talking about

549
00:20:29,120 --> 00:20:31,200
but it should already give you idea how

550
00:20:31,200 --> 00:20:32,880
complicated it is

551
00:20:32,880 --> 00:20:35,440
to introduce such trojan you have six uh

552
00:20:35,440 --> 00:20:36,880
code lines here

553
00:20:36,880 --> 00:20:39,919
um and and it works so that

554
00:20:39,919 --> 00:20:41,440
circuit implementation circuit

555
00:20:41,440 --> 00:20:43,679
translation would be also very very

556
00:20:43,679 --> 00:20:46,000
simple

557
00:20:46,080 --> 00:20:48,080
but of course you can use more

558
00:20:48,080 --> 00:20:49,840
sophisticated even more sophisticated

559
00:20:49,840 --> 00:20:50,480
triggers

560
00:20:50,480 --> 00:20:53,520
um so for instance um

561
00:20:53,520 --> 00:20:55,360
speculative execution on branch

562
00:20:55,360 --> 00:20:56,640
prediction

563
00:20:56,640 --> 00:20:59,440
so uh if we are doing if our processor

564
00:20:59,440 --> 00:21:01,520
supports branch prediction then

565
00:21:01,520 --> 00:21:03,520
if you have some conditional statements

566
00:21:03,520 --> 00:21:04,640
we can compute

567
00:21:04,640 --> 00:21:07,520
them simultaneously and later discard

568
00:21:07,520 --> 00:21:09,039
one of them

569
00:21:09,039 --> 00:21:11,520
and do the rollback the one which was

570
00:21:11,520 --> 00:21:12,400
never uh

571
00:21:12,400 --> 00:21:16,240
used um so the question is um what

572
00:21:16,240 --> 00:21:18,880
if an attacker would be smart enough to

573
00:21:18,880 --> 00:21:19,440
just

574
00:21:19,440 --> 00:21:21,760
trigger trojan during the speculative

575
00:21:21,760 --> 00:21:22,799
execution

576
00:21:22,799 --> 00:21:24,559
during some speculation of certain

577
00:21:24,559 --> 00:21:26,080
specific code

578
00:21:26,080 --> 00:21:28,240
by executing several instructions one

579
00:21:28,240 --> 00:21:30,159
one after another introducing some state

580
00:21:30,159 --> 00:21:31,280
of the processor

581
00:21:31,280 --> 00:21:34,559
and then rolling and then um

582
00:21:34,559 --> 00:21:37,280
rolling back to the original state um

583
00:21:37,280 --> 00:21:38,559
this is very interesting

584
00:21:38,559 --> 00:21:40,640
because uh we know from spectre and

585
00:21:40,640 --> 00:21:42,320
meltdown that specific

586
00:21:42,320 --> 00:21:45,440
that speculative execution can be tricky

587
00:21:45,440 --> 00:21:47,520
from security point of view can leave

588
00:21:47,520 --> 00:21:49,919
your caches from some with some values

589
00:21:49,919 --> 00:21:51,760
which were

590
00:21:51,760 --> 00:21:54,960
obtained during the speculation so um

591
00:21:54,960 --> 00:21:57,120
such trojan activation can be very

592
00:21:57,120 --> 00:21:58,799
difficult to be found

593
00:21:58,799 --> 00:22:02,000
so all in all combination which you are

594
00:22:02,000 --> 00:22:03,280
using should be rare

595
00:22:03,280 --> 00:22:06,799
in order to make it hard to find

596
00:22:06,799 --> 00:22:09,919
or very rare so it's easy for you to

597
00:22:09,919 --> 00:22:11,120
explain it's a

598
00:22:11,120 --> 00:22:14,639
vulnerability or back

599
00:22:15,360 --> 00:22:17,360
and then we can start designing our

600
00:22:17,360 --> 00:22:19,440
software exploit for linux

601
00:22:19,440 --> 00:22:21,679
so those are the goals of the software

602
00:22:21,679 --> 00:22:24,080
exploit we'll firstly place the cpu in

603
00:22:24,080 --> 00:22:25,600
the desired state

604
00:22:25,600 --> 00:22:27,840
then run our trigger in this case solid

605
00:22:27,840 --> 00:22:28,880
instruction

606
00:22:28,880 --> 00:22:31,120
then we'll inject code and run it in

607
00:22:31,120 --> 00:22:32,080
ring zero

608
00:22:32,080 --> 00:22:34,240
and then preferably one should go back

609
00:22:34,240 --> 00:22:36,159
to ring free in order to leave the same

610
00:22:36,159 --> 00:22:39,679
system in a stable state because if you

611
00:22:39,679 --> 00:22:41,280
are in a ring 0

612
00:22:41,280 --> 00:22:43,760
then whoever programmed the kernel

613
00:22:43,760 --> 00:22:45,200
modules knows that

614
00:22:45,200 --> 00:22:47,200
system calls do not work and it's very

615
00:22:47,200 --> 00:22:48,799
easy to randomly crash

616
00:22:48,799 --> 00:22:52,320
the whole system so in order to do this

617
00:22:52,320 --> 00:22:54,159
we have to firstly find

618
00:22:54,159 --> 00:22:57,520
our kernel data in our gdt

619
00:22:57,520 --> 00:22:59,679
table to be able to load those segments

620
00:22:59,679 --> 00:23:01,840
where kernel keeps its data

621
00:23:01,840 --> 00:23:05,360
so um where to find them

622
00:23:05,360 --> 00:23:08,000
the their placement depend actually on

623
00:23:08,000 --> 00:23:09,120
your distribution

624
00:23:09,120 --> 00:23:10,880
or may depend on your distribution

625
00:23:10,880 --> 00:23:13,919
because um they are defined in code

626
00:23:13,919 --> 00:23:16,159
and as you all know probably the code is

627
00:23:16,159 --> 00:23:17,679
the best documentation

628
00:23:17,679 --> 00:23:20,640
so reading the code here for you you can

629
00:23:20,640 --> 00:23:22,080
find the gdt entry for

630
00:23:22,080 --> 00:23:25,360
kernel is 12 multiplied by a and

631
00:23:25,360 --> 00:23:29,480
by 8. um and it gives you

632
00:23:29,480 --> 00:23:32,480
0x60 and then you can find a data

633
00:23:32,480 --> 00:23:33,039
segment

634
00:23:33,039 --> 00:23:36,080
under 13 and also multiplied by 8

635
00:23:36,080 --> 00:23:39,760
and gives you 0x68 and then

636
00:23:39,760 --> 00:23:43,279
this is our main part main function of

637
00:23:43,279 --> 00:23:43,919
our

638
00:23:43,919 --> 00:23:46,640
exploit we are running our stock

639
00:23:46,640 --> 00:23:48,240
instruction it's 0

640
00:23:48,240 --> 00:23:51,919
x d6 if you recall um the state machine

641
00:23:51,919 --> 00:23:55,039
of our camel then we are

642
00:23:55,039 --> 00:23:57,919
loading our data segment um then we are

643
00:23:57,919 --> 00:23:59,760
loading kernel code segment and we are

644
00:23:59,760 --> 00:24:00,240
making

645
00:24:00,240 --> 00:24:02,799
long long code to a function which will

646
00:24:02,799 --> 00:24:03,840
perform

647
00:24:03,840 --> 00:24:06,400
actual malicious activities for us so in

648
00:24:06,400 --> 00:24:07,520
this case

649
00:24:07,520 --> 00:24:10,400
or probably majority of you have seen

650
00:24:10,400 --> 00:24:11,360
this part

651
00:24:11,360 --> 00:24:14,480
of the exploit in other exploits for

652
00:24:14,480 --> 00:24:16,080
kernel

653
00:24:16,080 --> 00:24:18,400
which were targeting interrupts or

654
00:24:18,400 --> 00:24:19,360
syscalls

655
00:24:19,360 --> 00:24:22,640
uh what we are doing basically we know

656
00:24:22,640 --> 00:24:25,039
our own user and group id

657
00:24:25,039 --> 00:24:26,880
and we go with a pointer through whole

658
00:24:26,880 --> 00:24:28,960
kernel stack from base to the top

659
00:24:28,960 --> 00:24:30,720
to find a place in memory where the

660
00:24:30,720 --> 00:24:32,480
current process information

661
00:24:32,480 --> 00:24:34,640
probably is stored in our case it's a

662
00:24:34,640 --> 00:24:35,760
second attempt

663
00:24:35,760 --> 00:24:37,279
because what we are doing is we are

664
00:24:37,279 --> 00:24:39,120
looking for a piece of memory holding

665
00:24:39,120 --> 00:24:41,200
multiple copies of the current user id

666
00:24:41,200 --> 00:24:42,480
and group id

667
00:24:42,480 --> 00:24:44,799
and if we find such a piece of memory

668
00:24:44,799 --> 00:24:46,320
which we think

669
00:24:46,320 --> 00:24:50,080
is uh containing our process structure

670
00:24:50,080 --> 00:24:52,080
we are overriding it

671
00:24:52,080 --> 00:24:54,400
so and in such a way we have root and we

672
00:24:54,400 --> 00:24:55,279
can return

673
00:24:55,279 --> 00:24:58,400
which is uh byte zero hcb from the

674
00:24:58,400 --> 00:25:02,320
long call to this current function

675
00:25:02,320 --> 00:25:06,240
so the last question

676
00:25:06,240 --> 00:25:08,880
where is uh kernel stock base and the

677
00:25:08,880 --> 00:25:10,320
bottom

678
00:25:10,320 --> 00:25:12,080
we can find it out from from

679
00:25:12,080 --> 00:25:14,320
documentation but obviously it may be

680
00:25:14,320 --> 00:25:15,919
set differently

681
00:25:15,919 --> 00:25:18,159
so uh standard setting for embedded

682
00:25:18,159 --> 00:25:19,279
kernel like we'll

683
00:25:19,279 --> 00:25:21,679
build like like the one using filtered

684
00:25:21,679 --> 00:25:22,559
is zero

685
00:25:22,559 --> 00:25:25,600
xc on zeros for the bottom

686
00:25:25,600 --> 00:25:29,679
and zero except for the top

687
00:25:29,679 --> 00:25:33,120
so now let me show you a live demo

688
00:25:33,120 --> 00:25:36,640
so we have a script which will run for

689
00:25:36,640 --> 00:25:39,840
us um our

690
00:25:39,840 --> 00:25:42,880
compiled image there is nothing uh

691
00:25:42,880 --> 00:25:45,120
special about it it's just a script

692
00:25:45,120 --> 00:25:47,200
which is running our camera with our

693
00:25:47,200 --> 00:25:50,240
image of compiled builder and

694
00:25:50,240 --> 00:25:53,919
of course this uh camo has already

695
00:25:53,919 --> 00:25:57,600
introduced um trojan inside so i will

696
00:25:57,600 --> 00:26:01,200
run i will run

697
00:26:01,200 --> 00:26:04,720
our camel

698
00:26:06,159 --> 00:26:09,120
it will need a second to start then what

699
00:26:09,120 --> 00:26:10,080
we'll do we'll

700
00:26:10,080 --> 00:26:14,559
log in as a regular user as a guest

701
00:26:16,400 --> 00:26:19,840
and we'll try to execute firstly our

702
00:26:19,840 --> 00:26:25,279
um our script which is overriding the

703
00:26:25,279 --> 00:26:28,480
process structure but

704
00:26:28,480 --> 00:26:33,200
without without activated

705
00:26:33,200 --> 00:26:36,480
hardware backdoor and what we'll do next

706
00:26:36,480 --> 00:26:37,039
is we'll

707
00:26:37,039 --> 00:26:39,039
run the same script with activated

708
00:26:39,039 --> 00:26:40,640
hardware vector

709
00:26:40,640 --> 00:26:42,480
and we'll see what will happen so i'm

710
00:26:42,480 --> 00:26:45,840
logging in as a good guest

711
00:26:48,960 --> 00:26:53,520
and then we can see that i'm a guest

712
00:26:53,520 --> 00:26:57,200
um we can also change to check the

713
00:26:57,200 --> 00:26:58,799
version of our kernel

714
00:26:58,799 --> 00:27:02,799
is for 4.15 actually

715
00:27:02,799 --> 00:27:06,640
and we can right now run

716
00:27:06,640 --> 00:27:09,840
our kernel space hack

717
00:27:09,840 --> 00:27:13,360
without switch on trojan

718
00:27:13,360 --> 00:27:15,279
so what you see here is a general

719
00:27:15,279 --> 00:27:17,840
protection

720
00:27:17,840 --> 00:27:21,200
fold turn it's an exception

721
00:27:21,200 --> 00:27:24,080
uh which shows that our coach in kernel

722
00:27:24,080 --> 00:27:25,760
spacecraft was trying to get

723
00:27:25,760 --> 00:27:28,799
a segment which was not uh

724
00:27:28,799 --> 00:27:30,720
which was not allowed to him so we got

725
00:27:30,720 --> 00:27:32,840
segmentation called and we are left with

726
00:27:32,840 --> 00:27:35,600
nothing and now we'll run our cpu back

727
00:27:35,600 --> 00:27:38,080
there as i introduced it to you

728
00:27:38,080 --> 00:27:42,320
by activation result instruction

729
00:27:43,520 --> 00:27:46,720
and then if i will check who am i i have

730
00:27:46,720 --> 00:27:47,360
a root

731
00:27:47,360 --> 00:27:49,679
so my user id is zero and group id is

732
00:27:49,679 --> 00:27:52,320
zero and

733
00:27:52,320 --> 00:27:54,320
and if i will check who am i it will

734
00:27:54,320 --> 00:27:56,399
show me that i'm root

735
00:27:56,399 --> 00:28:02,320
so this is that so that's that easy

736
00:28:02,320 --> 00:28:06,240
i have to switch the presentation

737
00:28:10,559 --> 00:28:17,840
once again okay

738
00:28:29,200 --> 00:28:32,159
so as you may see uh the usage of the

739
00:28:32,159 --> 00:28:34,480
cpu vector is the same as the usage

740
00:28:34,480 --> 00:28:37,279
of any software kernel exploit it just

741
00:28:37,279 --> 00:28:38,559
uh

742
00:28:38,559 --> 00:28:41,039
instead of finding a vulnerability in an

743
00:28:41,039 --> 00:28:43,600
interrupt handle or cisco routine

744
00:28:43,600 --> 00:28:46,559
you have this vulnerability there and

745
00:28:46,559 --> 00:28:48,159
your cpu back there

746
00:28:48,159 --> 00:28:50,880
which is changing simply so processor

747
00:28:50,880 --> 00:28:52,000
state

748
00:28:52,000 --> 00:28:54,240
so everything what happens next data

749
00:28:54,240 --> 00:28:56,480
extraction modification is same as in

750
00:28:56,480 --> 00:28:58,080
case of any other exploit because this

751
00:28:58,080 --> 00:28:59,520
is a frequent question

752
00:28:59,520 --> 00:29:01,840
there's a frequent misconception that

753
00:29:01,840 --> 00:29:04,480
you will get your data also in hardware

754
00:29:04,480 --> 00:29:06,480
there is some magic connection there

755
00:29:06,480 --> 00:29:10,320
must be some magic connection to your

756
00:29:10,320 --> 00:29:12,240
ethernet port which is allowing you to

757
00:29:12,240 --> 00:29:13,360
extract data easier

758
00:29:13,360 --> 00:29:15,440
it must not necessarily be a case it

759
00:29:15,440 --> 00:29:16,399
might just

760
00:29:16,399 --> 00:29:20,080
help to get the route um easier as i

761
00:29:20,080 --> 00:29:21,520
presented to you

762
00:29:21,520 --> 00:29:24,080
so this method is cheaper and faster for

763
00:29:24,080 --> 00:29:25,039
the attacker

764
00:29:25,039 --> 00:29:27,360
because uh kernel security is getting

765
00:29:27,360 --> 00:29:28,799
better and better

766
00:29:28,799 --> 00:29:31,919
uh thanks to you guys uh so there is

767
00:29:31,919 --> 00:29:32,399
lower

768
00:29:32,399 --> 00:29:34,320
number of new exploits start getting the

769
00:29:34,320 --> 00:29:35,520
modern kernel errors

770
00:29:35,520 --> 00:29:38,320
um it's easier to find exploits and

771
00:29:38,320 --> 00:29:40,240
other things right now

772
00:29:40,240 --> 00:29:43,039
um and there is also this philosophical

773
00:29:43,039 --> 00:29:44,399
question which i mentioned at the

774
00:29:44,399 --> 00:29:45,120
beginning

775
00:29:45,120 --> 00:29:48,640
and which is very important for us uh um

776
00:29:48,640 --> 00:29:50,320
there is a big threat for attacker

777
00:29:50,320 --> 00:29:52,559
obviously because by introducing such a

778
00:29:52,559 --> 00:29:53,600
harder threat

779
00:29:53,600 --> 00:29:55,840
um

780
00:29:56,880 --> 00:30:00,320
he is actually um he can get a very high

781
00:30:00,320 --> 00:30:02,480
cost and severe contact peer consul

782
00:30:02,480 --> 00:30:04,320
consequences if this threat is

783
00:30:04,320 --> 00:30:05,760
discovered

784
00:30:05,760 --> 00:30:08,799
uh so um it's

785
00:30:08,799 --> 00:30:11,600
because you cannot modify or change your

786
00:30:11,600 --> 00:30:13,200
hardware component at least

787
00:30:13,200 --> 00:30:16,240
it's very difficult um

788
00:30:16,240 --> 00:30:19,360
after it's introduced to the market so

789
00:30:19,360 --> 00:30:21,360
what you're doing you're testing

790
00:30:21,360 --> 00:30:23,919
extensively your components

791
00:30:23,919 --> 00:30:26,399
and once again what if you find a

792
00:30:26,399 --> 00:30:27,440
specific

793
00:30:27,440 --> 00:30:30,159
bug which is not very not obvious during

794
00:30:30,159 --> 00:30:32,320
your test phase and you just leave it

795
00:30:32,320 --> 00:30:35,120
and question is whether it is already a

796
00:30:35,120 --> 00:30:36,240
cpu

797
00:30:36,240 --> 00:30:39,919
backdoor or still a bug

798
00:30:39,919 --> 00:30:43,200
this is probably um your interpretation

799
00:30:43,200 --> 00:30:44,320
of the customer

800
00:30:44,320 --> 00:30:46,399
but it would be very difficult to um

801
00:30:46,399 --> 00:30:48,159
prove that this was

802
00:30:48,159 --> 00:30:51,440
the case so for it can be a

803
00:30:51,440 --> 00:30:53,600
vulnerability as it can is of meltdown

804
00:30:53,600 --> 00:30:55,679
inspector because there is still no

805
00:30:55,679 --> 00:30:59,679
attack uh presented which was using them

806
00:30:59,679 --> 00:31:03,279
but um but it's still uh difficult to

807
00:31:03,279 --> 00:31:06,080
say to access

808
00:31:06,080 --> 00:31:09,039
so to summarize uh the stock uh what i

809
00:31:09,039 --> 00:31:10,880
wanted to show you is that hardware

810
00:31:10,880 --> 00:31:12,880
threads are technically possible

811
00:31:12,880 --> 00:31:15,200
so it's not a conspiracy theory you can

812
00:31:15,200 --> 00:31:17,200
make your own accident

813
00:31:17,200 --> 00:31:19,519
you can make your own experiments you

814
00:31:19,519 --> 00:31:21,600
can repeat my experiment construct

815
00:31:21,600 --> 00:31:23,279
conduct your own experiments you can do

816
00:31:23,279 --> 00:31:24,880
it in vhdl

817
00:31:24,880 --> 00:31:27,919
um it's it's possible it's possible to

818
00:31:27,919 --> 00:31:30,960
bypass this security

819
00:31:30,960 --> 00:31:32,799
you may think also about situation when

820
00:31:32,799 --> 00:31:34,799
you are not changing the cpl

821
00:31:34,799 --> 00:31:37,440
i use this uh change of the cpl register

822
00:31:37,440 --> 00:31:39,039
because it's the easiest way

823
00:31:39,039 --> 00:31:41,039
we are using existing mechanism but you

824
00:31:41,039 --> 00:31:43,200
could create a hidden mechanism which is

825
00:31:43,200 --> 00:31:45,679
bypassing cpl at certain

826
00:31:45,679 --> 00:31:49,120
situations and then you can see cpl

827
00:31:49,120 --> 00:31:51,200
during the day back but it wouldn't be

828
00:31:51,200 --> 00:31:53,200
possible for you to see this hidden

829
00:31:53,200 --> 00:31:54,559
mechanism

830
00:31:54,559 --> 00:31:57,440
so it's also not difficult to bypass the

831
00:31:57,440 --> 00:31:59,360
hardware security in modern processor

832
00:31:59,360 --> 00:32:01,120
in this case it's only one single

833
00:32:01,120 --> 00:32:02,640
register which you have to

834
00:32:02,640 --> 00:32:06,799
adjust and you can't offer software

835
00:32:06,799 --> 00:32:07,600
protection

836
00:32:07,600 --> 00:32:10,640
so once again software security is based

837
00:32:10,640 --> 00:32:11,120
on an

838
00:32:11,120 --> 00:32:13,919
assumption that you know what is the set

839
00:32:13,919 --> 00:32:15,840
of rules according to which

840
00:32:15,840 --> 00:32:19,039
your processor is working so as soon as

841
00:32:19,039 --> 00:32:20,080
you break

842
00:32:20,080 --> 00:32:22,799
this set of assumptions use this set of

843
00:32:22,799 --> 00:32:23,679
rules

844
00:32:23,679 --> 00:32:26,240
as soon as you alter it you can't offer

845
00:32:26,240 --> 00:32:28,080
software protection as i showed to you

846
00:32:28,080 --> 00:32:29,039
we had a

847
00:32:29,039 --> 00:32:32,159
properly functioning linux kernel with

848
00:32:32,159 --> 00:32:32,960
just because

849
00:32:32,960 --> 00:32:35,840
malfunction of hardware was not able to

850
00:32:35,840 --> 00:32:37,039
protect

851
00:32:37,039 --> 00:32:40,960
the user against our exploit

852
00:32:40,960 --> 00:32:42,880
so therefore in my opinion discussion

853
00:32:42,880 --> 00:32:44,960
about hardware safety is highly relevant

854
00:32:44,960 --> 00:32:46,640
especially in the context of

855
00:32:46,640 --> 00:32:48,640
safety critical and and security

856
00:32:48,640 --> 00:32:50,960
critical infrastructure

857
00:32:50,960 --> 00:32:54,000
um this is uh so so for instance um the

858
00:32:54,000 --> 00:32:55,120
critical telecommunication

859
00:32:55,120 --> 00:32:56,640
infrastructure

860
00:32:56,640 --> 00:33:00,000
why because as if you can't properly

861
00:33:00,000 --> 00:33:01,360
assess

862
00:33:01,360 --> 00:33:05,279
or validate the hardware if you can't

863
00:33:05,279 --> 00:33:07,760
check what's inside of the hardware then

864
00:33:07,760 --> 00:33:09,200
obviously there will be always

865
00:33:09,200 --> 00:33:10,399
dependency between

866
00:33:10,399 --> 00:33:13,279
you and provider and you must also

867
00:33:13,279 --> 00:33:14,159
consider

868
00:33:14,159 --> 00:33:17,279
and a worst case scenario or paranoid

869
00:33:17,279 --> 00:33:20,080
scenario that that he can use or switch

870
00:33:20,080 --> 00:33:22,159
off this infrastructure for you

871
00:33:22,159 --> 00:33:25,360
so just to finish what to do

872
00:33:25,360 --> 00:33:28,000
how to live with hardware threats uh i

873
00:33:28,000 --> 00:33:29,760
would say first of all there is a

874
00:33:29,760 --> 00:33:31,519
need to build skill force in hardware

875
00:33:31,519 --> 00:33:33,840
domain i'm talking about personal

876
00:33:33,840 --> 00:33:35,840
tools for instance there is not that

877
00:33:35,840 --> 00:33:37,279
many fuzzers

878
00:33:37,279 --> 00:33:39,440
so um even software fuzzers which are

879
00:33:39,440 --> 00:33:40,880
allowing you to fuss the whole

880
00:33:40,880 --> 00:33:43,440
is architecture to try every instruction

881
00:33:43,440 --> 00:33:44,880
with every possible

882
00:33:44,880 --> 00:33:47,279
operand it's just a beginning of such

883
00:33:47,279 --> 00:33:48,399
tools

884
00:33:48,399 --> 00:33:50,960
but there are many other research

885
00:33:50,960 --> 00:33:53,360
possibilities in this direction

886
00:33:53,360 --> 00:33:54,799
there would be good also to have

887
00:33:54,799 --> 00:33:56,799
procedures which are allowing

888
00:33:56,799 --> 00:33:59,360
um hardware evaluation of hardware

889
00:33:59,360 --> 00:34:00,000
projects

890
00:34:00,000 --> 00:34:02,880
so uh maybe it can be legislation to

891
00:34:02,880 --> 00:34:04,480
make some parts of the project

892
00:34:04,480 --> 00:34:06,880
products open source critical products

893
00:34:06,880 --> 00:34:08,719
uh also movement towards

894
00:34:08,719 --> 00:34:11,040
open source products would be i would

895
00:34:11,040 --> 00:34:12,639
definitely make attacker lives more

896
00:34:12,639 --> 00:34:14,399
difficult and finally

897
00:34:14,399 --> 00:34:17,119
as always heterogeneous environment so

898
00:34:17,119 --> 00:34:17,839
um

899
00:34:17,839 --> 00:34:20,719
and you can look at our example which we

900
00:34:20,719 --> 00:34:21,918
discussed today

901
00:34:21,918 --> 00:34:24,239
and you can see that i used several

902
00:34:24,239 --> 00:34:26,159
constants which are built in

903
00:34:26,159 --> 00:34:29,679
into the operating into the kernel at

904
00:34:29,679 --> 00:34:31,839
compilation time for instance the

905
00:34:31,839 --> 00:34:33,040
position of the

906
00:34:33,040 --> 00:34:37,199
kernel data segment and the gdt table

907
00:34:37,199 --> 00:34:39,760
uh based on top of the kernel stack as

908
00:34:39,760 --> 00:34:41,359
soon as you change those

909
00:34:41,359 --> 00:34:44,079
values this obviously harder and harder

910
00:34:44,079 --> 00:34:45,760
for attacker to find

911
00:34:45,760 --> 00:34:49,280
um to find uh appropriate spots

912
00:34:49,280 --> 00:34:51,918
also memory address memory randomization

913
00:34:51,918 --> 00:34:53,918
could help but they are still

914
00:34:53,918 --> 00:34:56,399
um attacks against this but definitely

915
00:34:56,399 --> 00:34:57,200
making your

916
00:34:57,200 --> 00:34:59,599
environments more heterogeneous building

917
00:34:59,599 --> 00:35:01,599
your own hardware products even if you

918
00:35:01,599 --> 00:35:04,800
are putting them from multiple different

919
00:35:04,800 --> 00:35:06,560
integrated circuits from multiple

920
00:35:06,560 --> 00:35:07,839
different

921
00:35:07,839 --> 00:35:10,960
providers can give you better security

922
00:35:10,960 --> 00:35:11,920
level

923
00:35:11,920 --> 00:35:14,079
okay thank you very much for your

924
00:35:14,079 --> 00:35:15,680
attention i hope you enjoyed this talk

925
00:35:15,680 --> 00:35:19,279
and i will be happy to answer all your

926
00:35:19,880 --> 00:35:22,880
questions

