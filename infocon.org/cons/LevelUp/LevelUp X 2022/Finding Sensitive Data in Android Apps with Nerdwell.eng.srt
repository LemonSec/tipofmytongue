1
00:00:00,000 --> 00:00:03,000
hey hackers nerdwell here and today

2
00:00:03,000 --> 00:00:04,860
we're going to talk about pulling back

3
00:00:04,860 --> 00:00:07,440
the veil to find sensitive data in

4
00:00:07,440 --> 00:00:09,000
Android apps

5
00:00:09,000 --> 00:00:11,099
some of these techniques will be ones

6
00:00:11,099 --> 00:00:13,200
that you're probably familiar with but

7
00:00:13,200 --> 00:00:15,179
we'll take a look at some new tools that

8
00:00:15,179 --> 00:00:18,119
may streamline your workflow and some of

9
00:00:18,119 --> 00:00:19,800
these techniques may be ones that you're

10
00:00:19,800 --> 00:00:22,320
not familiar with and I hope that you

11
00:00:22,320 --> 00:00:24,300
find them useful and that you're able to

12
00:00:24,300 --> 00:00:27,119
integrate them into your hacker tool kit

13
00:00:27,119 --> 00:00:29,699
of course all the tools and techniques

14
00:00:29,699 --> 00:00:31,619
that we're going to look at today should

15
00:00:31,619 --> 00:00:34,380
only be used to Target apps that you

16
00:00:34,380 --> 00:00:37,920
have explicit permission to hack on

17
00:00:37,920 --> 00:00:40,260
and without further Ado let's get

18
00:00:40,260 --> 00:00:42,480
started one of the key benefits of

19
00:00:42,480 --> 00:00:44,700
working in an Android environment are

20
00:00:44,700 --> 00:00:46,620
the platform level security features

21
00:00:46,620 --> 00:00:49,200
that Android provides so that mobile app

22
00:00:49,200 --> 00:00:51,000
developers and ovm Hardware

23
00:00:51,000 --> 00:00:53,520
manufacturers don't have to reinvent the

24
00:00:53,520 --> 00:00:55,500
wheel every time they want to implement

25
00:00:55,500 --> 00:00:57,239
a security feature that customers have

26
00:00:57,239 --> 00:00:59,100
come to expect

27
00:00:59,100 --> 00:01:00,539
and there are a lot of different

28
00:01:00,539 --> 00:01:02,579
security protections available in the

29
00:01:02,579 --> 00:01:04,619
Android environment but for this talk

30
00:01:04,619 --> 00:01:06,299
we're going to primarily focus on those

31
00:01:06,299 --> 00:01:09,360
that relate to information protection

32
00:01:09,360 --> 00:01:11,100
and when we're talking about information

33
00:01:11,100 --> 00:01:13,799
protection especially in a mobile device

34
00:01:13,799 --> 00:01:16,080
environment we can generally break those

35
00:01:16,080 --> 00:01:18,060
down into two categories

36
00:01:18,060 --> 00:01:20,460
protection at rest and protection in

37
00:01:20,460 --> 00:01:22,619
transit

38
00:01:22,619 --> 00:01:24,840
of course in a mobile environment data

39
00:01:24,840 --> 00:01:26,400
protection at rest is especially

40
00:01:26,400 --> 00:01:28,799
important because our devices are so

41
00:01:28,799 --> 00:01:31,080
small they're easy to lose you might

42
00:01:31,080 --> 00:01:33,780
even set it down walk away and come back

43
00:01:33,780 --> 00:01:36,360
and in the meantime an attacker can

44
00:01:36,360 --> 00:01:39,240
trivially clone your device without you

45
00:01:39,240 --> 00:01:41,340
being in need the wiser

46
00:01:41,340 --> 00:01:43,200
so Android provides whole device

47
00:01:43,200 --> 00:01:45,180
encryption to protect against these

48
00:01:45,180 --> 00:01:46,560
types of attacks

49
00:01:46,560 --> 00:01:49,079
but this does not provide any app level

50
00:01:49,079 --> 00:01:51,479
protection once the device has been

51
00:01:51,479 --> 00:01:53,220
unlocked which is what we're going to

52
00:01:53,220 --> 00:01:55,320
take a look at today

53
00:01:55,320 --> 00:01:57,420
another key security feature that

54
00:01:57,420 --> 00:02:00,360
Android provides for data at rest is per

55
00:02:00,360 --> 00:02:01,979
app isolation

56
00:02:01,979 --> 00:02:05,040
and this is implemented using Linux

57
00:02:05,040 --> 00:02:08,580
users where each app has a user assigned

58
00:02:08,580 --> 00:02:12,060
to it under which it runs and that app

59
00:02:12,060 --> 00:02:15,000
user has its own folder internal to the

60
00:02:15,000 --> 00:02:18,480
device that only it has access to so

61
00:02:18,480 --> 00:02:21,420
application a cannot access application

62
00:02:21,420 --> 00:02:24,620
B's data and vice versa and this is

63
00:02:24,620 --> 00:02:29,099
critical to keeping the scale of a

64
00:02:29,099 --> 00:02:32,400
compromise limited to one app so that if

65
00:02:32,400 --> 00:02:35,400
app a is compromised it cannot access

66
00:02:35,400 --> 00:02:38,840
the data from App B

67
00:02:38,940 --> 00:02:41,459
for data protection and Transit we

68
00:02:41,459 --> 00:02:44,340
generally see this implemented using TLS

69
00:02:44,340 --> 00:02:46,019
to encrypt the traffic

70
00:02:46,019 --> 00:02:48,180
and increasingly we see the use of

71
00:02:48,180 --> 00:02:51,420
certificate pending to require a very

72
00:02:51,420 --> 00:02:53,940
specific certificate to pre be presented

73
00:02:53,940 --> 00:02:57,180
to the mobile app by the backend server

74
00:02:57,180 --> 00:02:59,400
and at a high level the way certificate

75
00:02:59,400 --> 00:03:02,459
pending works is that the app has the

76
00:03:02,459 --> 00:03:04,680
public key of the cert that it expects

77
00:03:04,680 --> 00:03:07,620
to receive from the back end API

78
00:03:07,620 --> 00:03:10,739
and even if the API provides a

79
00:03:10,739 --> 00:03:14,400
certificate that is signed by a trusted

80
00:03:14,400 --> 00:03:17,940
CA if it is not the specific cert that

81
00:03:17,940 --> 00:03:20,220
our app is expecting to see it will

82
00:03:20,220 --> 00:03:22,200
assume that the API is untrusted and

83
00:03:22,200 --> 00:03:24,120
will not allow the connection

84
00:03:24,120 --> 00:03:26,819
of course this poses some problems if we

85
00:03:26,819 --> 00:03:28,500
want to gain a man in the middle

86
00:03:28,500 --> 00:03:31,019
position to intercept the traffic for

87
00:03:31,019 --> 00:03:33,780
bug Bounty purposes and there are a lot

88
00:03:33,780 --> 00:03:35,760
of talks about this but we'll take a

89
00:03:35,760 --> 00:03:38,340
look at some new tools for how we can

90
00:03:38,340 --> 00:03:41,159
quickly remove certificate pending from

91
00:03:41,159 --> 00:03:43,700
apps

92
00:03:44,459 --> 00:03:47,159
before we dig into the technical details

93
00:03:47,159 --> 00:03:50,519
let's take a look at some strategic

94
00:03:50,519 --> 00:03:53,640
level bug Bounty considerations

95
00:03:53,640 --> 00:03:56,220
and at a high level the way I approach

96
00:03:56,220 --> 00:03:59,040
most bug Bounty is that

97
00:03:59,040 --> 00:04:02,340
we as bug bounty hunters are attempting

98
00:04:02,340 --> 00:04:06,360
to find and invalidate assumptions

99
00:04:06,360 --> 00:04:08,760
and I think you could pretty much break

100
00:04:08,760 --> 00:04:11,580
down any vulnerability that you find

101
00:04:11,580 --> 00:04:14,700
to some assumption having been made that

102
00:04:14,700 --> 00:04:17,459
was either erroneous or did not consider

103
00:04:17,459 --> 00:04:20,519
all the possible conditions

104
00:04:20,519 --> 00:04:23,160
and as a hacker we find some set of

105
00:04:23,160 --> 00:04:24,900
conditions that invalidates that

106
00:04:24,900 --> 00:04:28,080
assumption with a security impact

107
00:04:28,080 --> 00:04:30,479
so applying this very high level

108
00:04:30,479 --> 00:04:33,060
approach to mobile apps especially

109
00:04:33,060 --> 00:04:35,520
Android mobile apps

110
00:04:35,520 --> 00:04:37,020
let's take a look at some common

111
00:04:37,020 --> 00:04:38,820
developer assumptions that we might be

112
00:04:38,820 --> 00:04:40,500
able to validate

113
00:04:40,500 --> 00:04:43,919
first and while this seems simple it

114
00:04:43,919 --> 00:04:47,520
surprises me how common this tends to be

115
00:04:47,520 --> 00:04:49,800
sometimes developers assume that the

116
00:04:49,800 --> 00:04:51,900
attacker does not have access to the

117
00:04:51,900 --> 00:04:53,759
application source code

118
00:04:53,759 --> 00:04:56,639
another somewhat common developer

119
00:04:56,639 --> 00:04:58,380
assumption is that an attacker cannot

120
00:04:58,380 --> 00:05:01,500
access private app data and this relates

121
00:05:01,500 --> 00:05:03,840
back to the per app isolation that's

122
00:05:03,840 --> 00:05:07,080
provided by the Android platform level

123
00:05:07,080 --> 00:05:08,880
security features

124
00:05:08,880 --> 00:05:11,580
and this kind of stems from a

125
00:05:11,580 --> 00:05:14,880
misunderstanding of the scope and nature

126
00:05:14,880 --> 00:05:17,340
of the protections and as a bug Bounty

127
00:05:17,340 --> 00:05:19,080
Hunter we will see if there are ways

128
00:05:19,080 --> 00:05:21,960
that we can take advantage of these

129
00:05:21,960 --> 00:05:24,479
misunderstandings to achieve a security

130
00:05:24,479 --> 00:05:26,340
impact

131
00:05:26,340 --> 00:05:29,520
and lastly there tends to be an

132
00:05:29,520 --> 00:05:32,639
assumption that TLS and certificate

133
00:05:32,639 --> 00:05:35,280
pending prevents all men in the middle

134
00:05:35,280 --> 00:05:37,979
attacks such that we are unable to

135
00:05:37,979 --> 00:05:40,139
intercept the traffic as a bug Bounty

136
00:05:40,139 --> 00:05:40,800
Hunter

137
00:05:40,800 --> 00:05:43,320
and so let's take a look at some

138
00:05:43,320 --> 00:05:45,479
possible ways that we can invalidate

139
00:05:45,479 --> 00:05:47,460
these assumptions to achieve a security

140
00:05:47,460 --> 00:05:50,460
impact let's start with the first that

141
00:05:50,460 --> 00:05:52,139
an attacker does not have access to

142
00:05:52,139 --> 00:05:54,360
application source code of course

143
00:05:54,360 --> 00:05:56,699
Android apps for our intents and

144
00:05:56,699 --> 00:06:00,060
purposes are basically specialized Java

145
00:06:00,060 --> 00:06:03,120
apps and there are a number of tools

146
00:06:03,120 --> 00:06:07,199
that enable us to trivially reverse the

147
00:06:07,199 --> 00:06:11,699
Android APK into human readable Java or

148
00:06:11,699 --> 00:06:13,560
kotlin code

149
00:06:13,560 --> 00:06:16,259
and we will take a look at how we can

150
00:06:16,259 --> 00:06:18,720
potentially exploit this to find Secrets

151
00:06:18,720 --> 00:06:21,479
within the app itself

152
00:06:21,479 --> 00:06:24,180
the next assumption is that attackers

153
00:06:24,180 --> 00:06:26,039
cannot access the private application

154
00:06:26,039 --> 00:06:28,680
data for an Android app due to the

155
00:06:28,680 --> 00:06:31,740
platform level per app isolation

156
00:06:31,740 --> 00:06:33,360
security features

157
00:06:33,360 --> 00:06:35,280
and so we're going to take a look at how

158
00:06:35,280 --> 00:06:36,539
we can

159
00:06:36,539 --> 00:06:37,979
augment

160
00:06:37,979 --> 00:06:40,139
any app that we could download from the

161
00:06:40,139 --> 00:06:42,840
Google Play Store to allow us to view

162
00:06:42,840 --> 00:06:46,020
the internal private app data of that

163
00:06:46,020 --> 00:06:48,060
application to see if there are any

164
00:06:48,060 --> 00:06:52,319
secrets within that storage area

165
00:06:52,319 --> 00:06:55,680
next the assumption that TLS and

166
00:06:55,680 --> 00:06:57,660
certificate pending cannot be bypassed

167
00:06:57,660 --> 00:07:00,360
has long been invalidated but we're

168
00:07:00,360 --> 00:07:02,039
going to take a look at some new tools

169
00:07:02,039 --> 00:07:04,620
today that streamline this process

170
00:07:04,620 --> 00:07:07,680
significantly and help reduce the errors

171
00:07:07,680 --> 00:07:10,080
that we might encounter using the old

172
00:07:10,080 --> 00:07:12,479
methods now before we start hacking on

173
00:07:12,479 --> 00:07:15,660
our Android apps we will need some basic

174
00:07:15,660 --> 00:07:18,300
tools both in terms of hardware and

175
00:07:18,300 --> 00:07:19,440
software

176
00:07:19,440 --> 00:07:22,080
so taking a look at the hardware tools

177
00:07:22,080 --> 00:07:24,120
that we're going to need first of course

178
00:07:24,120 --> 00:07:25,680
we're going to need to have a test

179
00:07:25,680 --> 00:07:28,080
Android device and I actually recommend

180
00:07:28,080 --> 00:07:30,720
to have at least two sometimes more

181
00:07:30,720 --> 00:07:33,660
because Angela adapts in many instances

182
00:07:33,660 --> 00:07:35,819
Implement peer-to-peer communication

183
00:07:35,819 --> 00:07:38,880
that of course we will want to test

184
00:07:38,880 --> 00:07:41,039
and sometimes you will actually find

185
00:07:41,039 --> 00:07:42,720
that security features may be

186
00:07:42,720 --> 00:07:45,240
implemented differently or unavailable

187
00:07:45,240 --> 00:07:48,419
altogether between different versions of

188
00:07:48,419 --> 00:07:50,280
the Android OS

189
00:07:50,280 --> 00:07:52,740
so having multiple phones allows us to

190
00:07:52,740 --> 00:07:54,780
test all those different variations

191
00:07:54,780 --> 00:07:57,300
of course that can get rather costly if

192
00:07:57,300 --> 00:08:01,139
you're using new nice fancy phones so I

193
00:08:01,139 --> 00:08:03,120
actually recommend for most Android

194
00:08:03,120 --> 00:08:06,060
packing to use burner phones you can

195
00:08:06,060 --> 00:08:07,800
pick them up from any brick and mortar

196
00:08:07,800 --> 00:08:11,160
store or any online retailer for

197
00:08:11,160 --> 00:08:15,060
generally anywhere from 29 to 45 dollars

198
00:08:15,060 --> 00:08:17,460
so for less than a hundred dollars you

199
00:08:17,460 --> 00:08:21,000
can get two to three phones and test all

200
00:08:21,000 --> 00:08:23,099
the different variations of the apps

201
00:08:23,099 --> 00:08:24,840
that you're targeting

202
00:08:24,840 --> 00:08:27,000
and of course you're going to need a USB

203
00:08:27,000 --> 00:08:28,979
cable to hook this device to your

204
00:08:28,979 --> 00:08:30,660
computer now all the tools that we're

205
00:08:30,660 --> 00:08:32,279
going to take a look at

206
00:08:32,279 --> 00:08:34,620
will run in a Windows environment

207
00:08:34,620 --> 00:08:37,740
however I think you'll find it easier to

208
00:08:37,740 --> 00:08:40,320
work in a macro Linux environment not

209
00:08:40,320 --> 00:08:42,539
only because the prerequisites are

210
00:08:42,539 --> 00:08:44,940
easier to set up in a macro Linux

211
00:08:44,940 --> 00:08:47,459
environment but also the tutorials and

212
00:08:47,459 --> 00:08:49,160
other videos that you'll find online

213
00:08:49,160 --> 00:08:51,959
generally demonstrate using Macs or

214
00:08:51,959 --> 00:08:54,360
Linux PCS and so it'll be a little

215
00:08:54,360 --> 00:08:56,880
easier to follow along if you're using a

216
00:08:56,880 --> 00:08:59,459
Mac or a Linux PC so in terms of the

217
00:08:59,459 --> 00:09:01,320
software that we're going to need to

218
00:09:01,320 --> 00:09:03,779
hack on our Android apps today

219
00:09:03,779 --> 00:09:05,640
some of these may be familiar to you

220
00:09:05,640 --> 00:09:07,260
some may not but we'll take a look at

221
00:09:07,260 --> 00:09:07,980
each

222
00:09:07,980 --> 00:09:10,200
the First Essential tool that we'll need

223
00:09:10,200 --> 00:09:14,459
is the Android development kit and that

224
00:09:14,459 --> 00:09:16,500
includes especially the Android debug

225
00:09:16,500 --> 00:09:19,200
Bridge ADB which will make heavy use of

226
00:09:19,200 --> 00:09:20,580
today

227
00:09:20,580 --> 00:09:23,040
but I recommend to actually get this

228
00:09:23,040 --> 00:09:25,320
through the Android studio and the

229
00:09:25,320 --> 00:09:27,839
reason is in addition to providing you

230
00:09:27,839 --> 00:09:30,540
with all the Android debug kit tools

231
00:09:30,540 --> 00:09:33,720
Android Studio gives you a nice user

232
00:09:33,720 --> 00:09:35,580
interface to interact with some of those

233
00:09:35,580 --> 00:09:38,459
tools and it makes it easy to do things

234
00:09:38,459 --> 00:09:40,800
like take screenshots and take videos

235
00:09:40,800 --> 00:09:43,440
which you will need to do if you do find

236
00:09:43,440 --> 00:09:45,240
a vulnerability and you're writing up

237
00:09:45,240 --> 00:09:47,519
your report you will find those to be

238
00:09:47,519 --> 00:09:50,100
especially helpful but it also allows

239
00:09:50,100 --> 00:09:53,760
you to open up apks and inspect within

240
00:09:53,760 --> 00:09:55,980
them and even make changes to them

241
00:09:55,980 --> 00:09:58,980
and also to build your own Android apps

242
00:09:58,980 --> 00:10:01,980
and I mentioned that because anytime

243
00:10:01,980 --> 00:10:04,019
you're wanting to break something which

244
00:10:04,019 --> 00:10:06,180
as bug bounty hunters that's basically

245
00:10:06,180 --> 00:10:08,580
what we do we're Breakers right

246
00:10:08,580 --> 00:10:11,640
it's easier to break something if you

247
00:10:11,640 --> 00:10:15,540
understand what the maker is facing when

248
00:10:15,540 --> 00:10:17,100
they built that product

249
00:10:17,100 --> 00:10:20,220
for instance if a an Android developer

250
00:10:20,220 --> 00:10:21,959
is going to implement a particular

251
00:10:21,959 --> 00:10:24,720
feature they may encounter some common

252
00:10:24,720 --> 00:10:27,120
pitfalls and there are some common

253
00:10:27,120 --> 00:10:30,060
approaches to overcoming those pitfalls

254
00:10:30,060 --> 00:10:33,000
and as a developer

255
00:10:33,000 --> 00:10:35,220
they may not know all of those options

256
00:10:35,220 --> 00:10:36,959
or they may not Implement them all

257
00:10:36,959 --> 00:10:40,019
correctly as a hacker if you know what

258
00:10:40,019 --> 00:10:42,899
the challenges will be facing an Android

259
00:10:42,899 --> 00:10:45,240
developer and what those potential

260
00:10:45,240 --> 00:10:48,180
options are and potential pitfalls are

261
00:10:48,180 --> 00:10:50,640
then it just gives you that much more

262
00:10:50,640 --> 00:10:53,579
insight to guide your Android hacking

263
00:10:53,579 --> 00:10:55,680
activities so that you can get the

264
00:10:55,680 --> 00:10:58,019
maximum return for the investment of

265
00:10:58,019 --> 00:10:59,820
your time

266
00:10:59,820 --> 00:11:02,459
the next important tool that we'll need

267
00:11:02,459 --> 00:11:05,579
today is a as actually a Java tool it's

268
00:11:05,579 --> 00:11:07,920
called key tool and we're going to be

269
00:11:07,920 --> 00:11:10,980
taking apart and repackaging apks and so

270
00:11:10,980 --> 00:11:13,140
we'll need this to sign them in order to

271
00:11:13,140 --> 00:11:15,540
be able to install them on our mobile

272
00:11:15,540 --> 00:11:17,279
device

273
00:11:17,279 --> 00:11:20,940
along the same lines is a jar file that

274
00:11:20,940 --> 00:11:24,120
is provides APK tool and this basically

275
00:11:24,120 --> 00:11:27,240
lets us quickly and easily de-package

276
00:11:27,240 --> 00:11:29,420
and repackage

277
00:11:29,420 --> 00:11:32,880
apks so that we can reverse them and

278
00:11:32,880 --> 00:11:36,540
make changes to them and then redeploy

279
00:11:36,540 --> 00:11:40,380
we will use the Uber APK signer to

280
00:11:40,380 --> 00:11:42,779
resign our packages in some instances

281
00:11:42,779 --> 00:11:46,620
which will take away some of the mundane

282
00:11:46,620 --> 00:11:48,839
steps we can do this without the Uber

283
00:11:48,839 --> 00:11:52,380
APK signer but the steps are actually a

284
00:11:52,380 --> 00:11:54,600
little bit different from one version of

285
00:11:54,600 --> 00:11:57,660
Android to the next and it can be a

286
00:11:57,660 --> 00:11:59,700
little bit cumbersome and error Chrome

287
00:11:59,700 --> 00:12:02,459
to do it manually so by using this we

288
00:12:02,459 --> 00:12:05,160
get a one-liner that handles all of

289
00:12:05,160 --> 00:12:09,000
those variations for us and lets us

290
00:12:09,000 --> 00:12:11,700
quickly and easily repackage resign our

291
00:12:11,700 --> 00:12:15,480
apks for deployment to our mobile device

292
00:12:15,480 --> 00:12:17,279
and lastly we're going to take a look at

293
00:12:17,279 --> 00:12:20,579
a node.js package called APK middle

294
00:12:20,579 --> 00:12:24,600
which eliminates all the challenges of

295
00:12:24,600 --> 00:12:27,420
removing certificate pending from a

296
00:12:27,420 --> 00:12:29,700
mobile app none of these tools are tools

297
00:12:29,700 --> 00:12:31,200
that I have created they're all created

298
00:12:31,200 --> 00:12:33,240
by other people and we will give

299
00:12:33,240 --> 00:12:35,640
appropriate shout outs as we address

300
00:12:35,640 --> 00:12:39,440
each one so where this demo starts out

301
00:12:39,440 --> 00:12:42,959
is basically let's assume that we have

302
00:12:42,959 --> 00:12:45,300
an app that we have downloaded from the

303
00:12:45,300 --> 00:12:47,399
Google Play Store it's obviously

304
00:12:47,399 --> 00:12:52,139
therefore a release Mode app and we want

305
00:12:52,139 --> 00:12:54,779
to strip certificate pinning let's say

306
00:12:54,779 --> 00:12:57,839
we don't have the APK and we want to

307
00:12:57,839 --> 00:13:00,839
figure out how we can pull the APK strip

308
00:13:00,839 --> 00:13:03,839
certificate pinning and intercept our

309
00:13:03,839 --> 00:13:05,160
traffic

310
00:13:05,160 --> 00:13:08,100
so the first thing we'll want to do is

311
00:13:08,100 --> 00:13:12,600
use ADB shell to run PM list packages

312
00:13:12,600 --> 00:13:14,639
and in this case I know the name of the

313
00:13:14,639 --> 00:13:17,459
app so I grep on that

314
00:13:17,459 --> 00:13:20,820
and what we'll find right here is that

315
00:13:20,820 --> 00:13:24,180
we have the physical path to the APK

316
00:13:24,180 --> 00:13:27,540
that is associated with that app package

317
00:13:27,540 --> 00:13:32,779
so we're going to ADB pull that APK

318
00:13:41,220 --> 00:13:42,839
and then we're actually going to go

319
00:13:42,839 --> 00:13:45,000
ahead and uninstall that app because

320
00:13:45,000 --> 00:13:46,680
we're going to

321
00:13:46,680 --> 00:13:48,720
strip certificate pinning and reinstall

322
00:13:48,720 --> 00:13:51,180
it so we'll have a different APK and if

323
00:13:51,180 --> 00:13:53,220
we don't uninstall it first we will have

324
00:13:53,220 --> 00:13:56,220
a namespace conflict when we do so

325
00:13:56,220 --> 00:13:58,800
so now stripping certificate pinning

326
00:13:58,800 --> 00:14:01,200
with this tool is as easy as running APK

327
00:14:01,200 --> 00:14:04,079
minimum and passing it the base APK that

328
00:14:04,079 --> 00:14:06,540
we just pulled from the device

329
00:14:06,540 --> 00:14:08,700
it's going to run through a series of

330
00:14:08,700 --> 00:14:10,680
steps

331
00:14:10,680 --> 00:14:14,040
we'll wait for that to complete

332
00:14:14,040 --> 00:14:17,279
and when it's done it will output a base

333
00:14:17,279 --> 00:14:21,000
Dash patched dot APK file that we can

334
00:14:21,000 --> 00:14:23,600
redeploy

335
00:15:29,940 --> 00:15:33,540
and now we will simply sideload this to

336
00:15:33,540 --> 00:15:38,000
our mobile device with ADB install

337
00:15:45,779 --> 00:15:48,860
and there we go

338
00:15:48,959 --> 00:15:51,959
so at this point we can configure our

339
00:15:51,959 --> 00:15:55,199
proxy in the Android system settings and

340
00:15:55,199 --> 00:15:57,720
intercept our traffic of course you'll

341
00:15:57,720 --> 00:16:00,420
need to trust your burp certificate and

342
00:16:00,420 --> 00:16:01,980
all that good stuff I'm not going to

343
00:16:01,980 --> 00:16:04,019
cover those steps in this talk just

344
00:16:04,019 --> 00:16:06,240
because they're so well documented we'll

345
00:16:06,240 --> 00:16:08,040
spend our time on some more valuable

346
00:16:08,040 --> 00:16:11,600
stuff I did go ahead and let the app Run

347
00:16:11,600 --> 00:16:15,300
in real time I did not speed that up

348
00:16:15,300 --> 00:16:17,220
just so you could get a feel for how

349
00:16:17,220 --> 00:16:20,279
quick it is to remove certificate

350
00:16:20,279 --> 00:16:22,440
pinning from an app now it used to be

351
00:16:22,440 --> 00:16:25,079
again a rather cumbersome and manual

352
00:16:25,079 --> 00:16:28,500
process and as you saw here it was a

353
00:16:28,500 --> 00:16:29,519
piece of cake

354
00:16:29,519 --> 00:16:32,880
I've also noticed that this tool will

355
00:16:32,880 --> 00:16:35,660
work on

356
00:16:35,660 --> 00:16:40,380
apx APK X Files and I have not

357
00:16:40,380 --> 00:16:42,240
encountered any Android app that it did

358
00:16:42,240 --> 00:16:45,540
not work on so hopefully you will find

359
00:16:45,540 --> 00:16:47,279
that useful and you can integrate it

360
00:16:47,279 --> 00:16:50,100
into your workflow to speed up the

361
00:16:50,100 --> 00:16:54,360
process and automate some of the tasks

362
00:16:54,360 --> 00:16:57,240
next let's take a look at that second

363
00:16:57,240 --> 00:17:00,300
developer assumption that

364
00:17:00,300 --> 00:17:03,180
an attacker does not have access to the

365
00:17:03,180 --> 00:17:05,099
app private data

366
00:17:05,099 --> 00:17:07,679
and this can reveal all sorts of

367
00:17:07,679 --> 00:17:09,720
interesting information

368
00:17:09,720 --> 00:17:12,480
and so to demonstrate this I'm going to

369
00:17:12,480 --> 00:17:16,140
use that same Android POC app that I've

370
00:17:16,140 --> 00:17:19,439
created and basically it just opens up a

371
00:17:19,439 --> 00:17:21,900
web view hits a web page that I'm

372
00:17:21,900 --> 00:17:24,240
hosting and that web page has some very

373
00:17:24,240 --> 00:17:26,939
basic JavaScript that creates a cookie

374
00:17:26,939 --> 00:17:29,460
and the native webview and Android

375
00:17:29,460 --> 00:17:33,299
stores cookies using a sqlite database

376
00:17:33,299 --> 00:17:35,700
in the app's internal storage

377
00:17:35,700 --> 00:17:38,160
and we'll take a look at how we can view

378
00:17:38,160 --> 00:17:39,960
that content

379
00:17:39,960 --> 00:17:41,660
of course that's a very simplified

380
00:17:41,660 --> 00:17:44,820
demonstration but I'll talk about how

381
00:17:44,820 --> 00:17:47,160
that has actually led to some bugs in my

382
00:17:47,160 --> 00:17:49,380
own experience later

383
00:17:49,380 --> 00:17:52,620
but before we go on let's just touch on

384
00:17:52,620 --> 00:17:55,020
one thing and that is when we're talking

385
00:17:55,020 --> 00:17:56,820
about assumptions it's important to

386
00:17:56,820 --> 00:17:59,820
realize that as attackers we can also

387
00:17:59,820 --> 00:18:02,160
make some invalid assumptions

388
00:18:02,160 --> 00:18:05,700
for instance we might assume that we

389
00:18:05,700 --> 00:18:07,740
have access to the application source

390
00:18:07,740 --> 00:18:08,460
code

391
00:18:08,460 --> 00:18:11,580
and we have the ability to intercept all

392
00:18:11,580 --> 00:18:13,919
the traffic using something like APK

393
00:18:13,919 --> 00:18:17,160
minimum to strip certificate pinning and

394
00:18:17,160 --> 00:18:20,520
with those two tools you should be able

395
00:18:20,520 --> 00:18:23,220
to see all the data that the app has

396
00:18:23,220 --> 00:18:25,919
within itself from you know out of the

397
00:18:25,919 --> 00:18:26,880
box

398
00:18:26,880 --> 00:18:29,400
and also any data that it's receiving

399
00:18:29,400 --> 00:18:32,640
from backend server components and with

400
00:18:32,640 --> 00:18:34,320
that you would think that you could see

401
00:18:34,320 --> 00:18:36,480
any sensitive

402
00:18:36,480 --> 00:18:39,480
data or hard-coded keys or tokens and

403
00:18:39,480 --> 00:18:41,700
that kind of thing however there are

404
00:18:41,700 --> 00:18:44,039
definitely some instances in which it's

405
00:18:44,039 --> 00:18:46,679
easy to miss and a couple that come to

406
00:18:46,679 --> 00:18:48,559
mind that I've encountered in the past

407
00:18:48,559 --> 00:18:52,020
are compressed files so sometimes you

408
00:18:52,020 --> 00:18:54,780
will find that data coming from a remote

409
00:18:54,780 --> 00:18:57,539
API endpoint is compressed in a way that

410
00:18:57,539 --> 00:18:59,039
makes it

411
00:18:59,039 --> 00:19:01,679
easy to miss the fact that there's some

412
00:19:01,679 --> 00:19:04,380
sensitive data in there and then also it

413
00:19:04,380 --> 00:19:07,140
may even be encrypted beyond the

414
00:19:07,140 --> 00:19:09,900
transport level encryption provided by

415
00:19:09,900 --> 00:19:13,440
TLS it may be some some encrypted zip

416
00:19:13,440 --> 00:19:17,160
file or something and while it is

417
00:19:17,160 --> 00:19:19,679
theoretically possible that you could

418
00:19:19,679 --> 00:19:22,559
find the key and and decrypt and

419
00:19:22,559 --> 00:19:26,039
uncompress that file to find any secrets

420
00:19:26,039 --> 00:19:28,860
it's easy to miss and so by looking at

421
00:19:28,860 --> 00:19:31,799
the private app data where it sits where

422
00:19:31,799 --> 00:19:34,080
the app is interacting with it as it

423
00:19:34,080 --> 00:19:37,260
runs it just gives us another Avenue to

424
00:19:37,260 --> 00:19:39,240
find some of that information

425
00:19:39,240 --> 00:19:41,880
so what we're going to do here is

426
00:19:41,880 --> 00:19:44,220
basically

427
00:19:44,220 --> 00:19:47,100
launch this app that is running on my

428
00:19:47,100 --> 00:19:50,160
test mobile device and as you'll see it

429
00:19:50,160 --> 00:19:52,620
just opens up a web page

430
00:19:52,620 --> 00:19:55,200
and so what we're going to do is similar

431
00:19:55,200 --> 00:19:58,380
to the previous demo we're going to

432
00:19:58,380 --> 00:20:00,480
assume that this app is one that we have

433
00:20:00,480 --> 00:20:02,100
downloaded from the Google Play Store

434
00:20:02,100 --> 00:20:05,820
and that we don't have the APK that it's

435
00:20:05,820 --> 00:20:08,940
a release build of the app and we want

436
00:20:08,940 --> 00:20:10,080
to

437
00:20:10,080 --> 00:20:12,360
do whatever we need to do to gain access

438
00:20:12,360 --> 00:20:16,320
to the internal app data store

439
00:20:16,320 --> 00:20:18,360
so the first thing we're going to do is

440
00:20:18,360 --> 00:20:21,419
similar to the last demo we're going to

441
00:20:21,419 --> 00:20:24,900
list all the packages on the device and

442
00:20:24,900 --> 00:20:27,059
in this case I know it contains the word

443
00:20:27,059 --> 00:20:30,678
nerdwell so I grab on that

444
00:20:31,799 --> 00:20:33,840
but before I pull it from the device

445
00:20:33,840 --> 00:20:35,640
what I'm going to demonstrate is if we

446
00:20:35,640 --> 00:20:38,100
run ADB shell and get to a shell on the

447
00:20:38,100 --> 00:20:39,299
mobile device

448
00:20:39,299 --> 00:20:42,179
we can run as the name of the package

449
00:20:42,179 --> 00:20:45,539
and what this would do is allow us to

450
00:20:45,539 --> 00:20:48,000
switch to the user context under which

451
00:20:48,000 --> 00:20:50,460
that app runs and then once we're in

452
00:20:50,460 --> 00:20:52,799
that user context we can access that

453
00:20:52,799 --> 00:20:55,500
app's internal application folder

454
00:20:55,500 --> 00:20:58,380
however because this is a release build

455
00:20:58,380 --> 00:21:01,160
of the app we receive this error message

456
00:21:01,160 --> 00:21:04,260
so what we're going to demonstrate is

457
00:21:04,260 --> 00:21:07,559
how we can circumvent that to gain the

458
00:21:07,559 --> 00:21:11,220
access we seek so we will go ahead and

459
00:21:11,220 --> 00:21:14,400
ADB pull our package from where it

460
00:21:14,400 --> 00:21:18,080
physically resides on the mobile device

461
00:21:24,840 --> 00:21:27,240
then we'll uninstall the app because

462
00:21:27,240 --> 00:21:29,640
again we're going to make some changes

463
00:21:29,640 --> 00:21:32,100
to it repackage it and redeploy it and

464
00:21:32,100 --> 00:21:34,559
if we don't uninstall first we'll have

465
00:21:34,559 --> 00:21:36,780
some namespace conflicts when we attempt

466
00:21:36,780 --> 00:21:39,200
to do so

467
00:21:39,780 --> 00:21:45,919
okay so now we will use the APK tool to

468
00:21:45,919 --> 00:21:48,480
decompress that APK

469
00:21:48,480 --> 00:21:52,679
and and reverse it to

470
00:21:52,679 --> 00:21:55,760
editable code

471
00:21:56,039 --> 00:22:00,120
and for this we use the APK tool D

472
00:22:00,120 --> 00:22:02,940
command we specify

473
00:22:02,940 --> 00:22:05,460
the dash o flag which points to the

474
00:22:05,460 --> 00:22:07,380
folder that we want to Output the

475
00:22:07,380 --> 00:22:10,640
contents to and then we specify the

476
00:22:10,640 --> 00:22:13,500
base.apk as the input APK we want to

477
00:22:13,500 --> 00:22:14,400
work with

478
00:22:14,400 --> 00:22:16,980
and so now if we take a look at the

479
00:22:16,980 --> 00:22:19,559
extracted APK folder contents we can see

480
00:22:19,559 --> 00:22:22,260
this is what's inside that APK

481
00:22:22,260 --> 00:22:25,320
so we will in this case we're interested

482
00:22:25,320 --> 00:22:26,900
in editing the

483
00:22:26,900 --> 00:22:30,179
androidmanifest.xml file because

484
00:22:30,179 --> 00:22:34,140
this debuggable equals true flag is what

485
00:22:34,140 --> 00:22:36,299
we want to change

486
00:22:36,299 --> 00:22:37,679
now

487
00:22:37,679 --> 00:22:40,260
in most release build apps you will not

488
00:22:40,260 --> 00:22:43,980
find the debuggable equals true

489
00:22:43,980 --> 00:22:48,080
flag there in the actual android.

490
00:22:48,080 --> 00:22:50,820
androidmanifest.xml file however if it

491
00:22:50,820 --> 00:22:53,760
is not present it defaults to false

492
00:22:53,760 --> 00:22:56,520
I put it in this one just because I

493
00:22:56,520 --> 00:22:58,020
wanted to make it easier for us to

494
00:22:58,020 --> 00:23:00,240
demonstrate but if you were doing this

495
00:23:00,240 --> 00:23:02,039
on a live app that you got off the

496
00:23:02,039 --> 00:23:04,320
Google Play Store basically you would

497
00:23:04,320 --> 00:23:07,380
add that whole debuggable equals

498
00:23:07,380 --> 00:23:09,120
true in quotes

499
00:23:09,120 --> 00:23:11,340
to this file

500
00:23:11,340 --> 00:23:13,559
in this case I just changed false to

501
00:23:13,559 --> 00:23:16,020
True save

502
00:23:16,020 --> 00:23:18,799
the file

503
00:23:20,340 --> 00:23:23,460
and simple as that now

504
00:23:23,460 --> 00:23:27,120
we're going to re-build this package and

505
00:23:27,120 --> 00:23:28,740
redeploy it but to do that we're going

506
00:23:28,740 --> 00:23:30,780
to have to resign it and so we need to

507
00:23:30,780 --> 00:23:34,620
generate a Java key store to do so so

508
00:23:34,620 --> 00:23:37,440
for that we will use the key tool and

509
00:23:37,440 --> 00:23:39,179
we're going to generate the key store

510
00:23:39,179 --> 00:23:40,940
there are a couple

511
00:23:40,940 --> 00:23:43,260
important bits of information that we

512
00:23:43,260 --> 00:23:44,880
provide this command that we're going to

513
00:23:44,880 --> 00:23:47,159
need to reference here in a minute and

514
00:23:47,159 --> 00:23:50,039
that is the physical file which in this

515
00:23:50,039 --> 00:23:53,520
case is resign Dot keystore and then

516
00:23:53,520 --> 00:23:55,799
also the Alias name

517
00:23:55,799 --> 00:23:58,740
so we'll want to remember those and then

518
00:23:58,740 --> 00:24:00,539
it's going to ask us to enter a password

519
00:24:00,539 --> 00:24:02,460
here and obviously we'll need to

520
00:24:02,460 --> 00:24:03,780
remember that because we're going to

521
00:24:03,780 --> 00:24:06,559
have to provide it

522
00:24:07,020 --> 00:24:08,940
at this point we're going to specify

523
00:24:08,940 --> 00:24:10,559
some information

524
00:24:10,559 --> 00:24:13,919
for the cert it we could hit enter enter

525
00:24:13,919 --> 00:24:16,320
and move through here unknown is

526
00:24:16,320 --> 00:24:18,240
perfectly fine for each of these fields

527
00:24:18,240 --> 00:24:20,220
however

528
00:24:20,220 --> 00:24:21,780
on the last

529
00:24:21,780 --> 00:24:24,120
entry here if you just hit enter it

530
00:24:24,120 --> 00:24:25,740
defaults to know and puts you in a loop

531
00:24:25,740 --> 00:24:27,480
so I always just fill them all out

532
00:24:27,480 --> 00:24:29,820
because that forces me to remember to

533
00:24:29,820 --> 00:24:30,900
type yes

534
00:24:30,900 --> 00:24:33,299
okay so now we have our key store

535
00:24:33,299 --> 00:24:34,620
generated

536
00:24:34,620 --> 00:24:36,600
what we're going to do at this point is

537
00:24:36,600 --> 00:24:40,500
Rerun APK tool with the B command to

538
00:24:40,500 --> 00:24:45,539
rebuild our APK from the extracted APK

539
00:24:45,539 --> 00:24:48,059
folder that we were working in

540
00:24:48,059 --> 00:24:51,840
so in this case we specify Dash o for

541
00:24:51,840 --> 00:24:56,220
the output to be the APK name of our new

542
00:24:56,220 --> 00:24:59,880
APK and the input is the extracted APK

543
00:24:59,880 --> 00:25:03,799
folder that we want to build from

544
00:25:05,460 --> 00:25:08,580
okay once that's finished we will use

545
00:25:08,580 --> 00:25:12,059
the Uber APK signer to sign and prepare

546
00:25:12,059 --> 00:25:14,640
this package to be deployed we will

547
00:25:14,640 --> 00:25:18,360
specify as an input our APK file that we

548
00:25:18,360 --> 00:25:20,760
just generated and the keystore that we

549
00:25:20,760 --> 00:25:23,760
generated in the prior step

550
00:25:23,760 --> 00:25:24,840
now

551
00:25:24,840 --> 00:25:27,120
as I mentioned you will need to know the

552
00:25:27,120 --> 00:25:29,220
file name of course and then also the

553
00:25:29,220 --> 00:25:31,740
Alias name and it will prompt us here

554
00:25:31,740 --> 00:25:35,159
for the password so we will type that in

555
00:25:35,159 --> 00:25:38,460
and just like that we have

556
00:25:38,460 --> 00:25:43,740
a patched sign ready to deploy APK so as

557
00:25:43,740 --> 00:25:46,080
you can see here we have three apks the

558
00:25:46,080 --> 00:25:48,240
first is base dot APK that's the

559
00:25:48,240 --> 00:25:50,220
original that we had pulled from the

560
00:25:50,220 --> 00:25:51,480
mobile device

561
00:25:51,480 --> 00:25:53,580
as it was downloaded from the Google

562
00:25:53,580 --> 00:25:55,020
Play Store

563
00:25:55,020 --> 00:25:58,260
the second is dash dash debuggable which

564
00:25:58,260 --> 00:26:00,900
is the one that we created

565
00:26:00,900 --> 00:26:04,620
using APK tool with our modified Android

566
00:26:04,620 --> 00:26:07,799
manifest file that allows us to debug

567
00:26:07,799 --> 00:26:08,820
the app

568
00:26:08,820 --> 00:26:10,919
and lastly is the one that we're

569
00:26:10,919 --> 00:26:13,140
actually going to deploy to device which

570
00:26:13,140 --> 00:26:16,260
is the debugged debuggable aligned and

571
00:26:16,260 --> 00:26:18,059
signed APK

572
00:26:18,059 --> 00:26:21,720
so we can go ahead and install that side

573
00:26:21,720 --> 00:26:23,580
load it by

574
00:26:23,580 --> 00:26:26,539
ADB install

575
00:26:35,340 --> 00:26:39,000
okay so now we will go ahead and rerun

576
00:26:39,000 --> 00:26:41,360
the app

577
00:26:41,400 --> 00:26:43,919
again all it does is open up this page

578
00:26:43,919 --> 00:26:45,720
but what we're going to do is take a

579
00:26:45,720 --> 00:26:47,340
look at

580
00:26:47,340 --> 00:26:49,559
the internal storage and see if we can

581
00:26:49,559 --> 00:26:52,860
access it now so we ADB shell to get to

582
00:26:52,860 --> 00:26:55,559
a shell on the mobile device we use run

583
00:26:55,559 --> 00:26:59,100
as in the app package name to switch

584
00:26:59,100 --> 00:27:01,679
context and as you can see now we can

585
00:27:01,679 --> 00:27:02,820
actually

586
00:27:02,820 --> 00:27:04,799
successfully run this command it

587
00:27:04,799 --> 00:27:07,320
actually puts us into the apps folder to

588
00:27:07,320 --> 00:27:08,580
begin with

589
00:27:08,580 --> 00:27:10,820
and if we take a look

590
00:27:10,820 --> 00:27:14,220
boom this is the internal app data

591
00:27:14,220 --> 00:27:17,640
now as I mentioned before this is a

592
00:27:17,640 --> 00:27:19,559
standard app View

593
00:27:19,559 --> 00:27:21,840
and a cookie is set using some

594
00:27:21,840 --> 00:27:24,419
JavaScript so let's take a look at this

595
00:27:24,419 --> 00:27:27,600
cookies sqlite

596
00:27:27,600 --> 00:27:32,299
file and we're going to dump it with xxd

597
00:27:33,179 --> 00:27:36,299
to view the contents

598
00:27:36,299 --> 00:27:39,120
and again this is running on the Android

599
00:27:39,120 --> 00:27:42,299
device so if we take a look here

600
00:27:42,299 --> 00:27:44,460
looking at the header it's a sqlite

601
00:27:44,460 --> 00:27:47,460
database

602
00:27:49,980 --> 00:27:52,620
and if we scroll through towards the end

603
00:27:52,620 --> 00:27:55,140
we will find

604
00:27:55,140 --> 00:27:58,100
the cookie

605
00:27:58,980 --> 00:28:01,620
value pair

606
00:28:01,620 --> 00:28:03,659
now obviously this is not the most

607
00:28:03,659 --> 00:28:05,220
user-friendly

608
00:28:05,220 --> 00:28:09,000
format to read and if you're going to

609
00:28:09,000 --> 00:28:12,360
try to demonstrate like a POC for report

610
00:28:12,360 --> 00:28:15,960
it can be somewhat cumbersome to to walk

611
00:28:15,960 --> 00:28:18,919
the triager through this whole process

612
00:28:18,919 --> 00:28:20,940
and so

613
00:28:20,940 --> 00:28:24,059
in our next uh demo we're going to take

614
00:28:24,059 --> 00:28:26,580
a look at how we can streamline this but

615
00:28:26,580 --> 00:28:28,980
for this particular use case all we're

616
00:28:28,980 --> 00:28:31,200
demonstrating is this is how you would

617
00:28:31,200 --> 00:28:33,720
take a release build APK from the Google

618
00:28:33,720 --> 00:28:36,600
Play Store and allow yourself to view

619
00:28:36,600 --> 00:28:39,419
all the internal app data

620
00:28:39,419 --> 00:28:40,919
and

621
00:28:40,919 --> 00:28:42,840
you'd be surprised what you might find

622
00:28:42,840 --> 00:28:47,039
anything from Firebase keys that are

623
00:28:47,039 --> 00:28:49,500
improperly secured on the back end

624
00:28:49,500 --> 00:28:53,400
to other cloud services tokens that give

625
00:28:53,400 --> 00:28:55,700
you access to the remote

626
00:28:55,700 --> 00:28:59,340
endpoints servers themselves to other

627
00:28:59,340 --> 00:29:03,539
API keys or potentially unencrypted pii

628
00:29:03,539 --> 00:29:05,419
or Phi

629
00:29:05,419 --> 00:29:09,600
the possibilities are endless and your

630
00:29:09,600 --> 00:29:11,700
mileage may vary from one app to the

631
00:29:11,700 --> 00:29:14,279
other but this gives you a tool that you

632
00:29:14,279 --> 00:29:16,620
can use to explore that data let's take

633
00:29:16,620 --> 00:29:18,419
this a step further

634
00:29:18,419 --> 00:29:21,840
in the last demo We examined how we can

635
00:29:21,840 --> 00:29:25,700
gain access to the internal app data

636
00:29:25,700 --> 00:29:28,980
forearm POC app however we could only

637
00:29:28,980 --> 00:29:31,559
view it in the context of the mobile

638
00:29:31,559 --> 00:29:34,200
device ADB shell itself

639
00:29:34,200 --> 00:29:37,440
and so the tools available to you in ADB

640
00:29:37,440 --> 00:29:39,899
shell are rather limited and while you

641
00:29:39,899 --> 00:29:41,880
can copy some tools over there and run

642
00:29:41,880 --> 00:29:43,500
them because it's simply a Linux

643
00:29:43,500 --> 00:29:45,840
environment there are some issues there

644
00:29:45,840 --> 00:29:48,179
and potential limitations it would be

645
00:29:48,179 --> 00:29:51,059
much easier and much more beneficial to

646
00:29:51,059 --> 00:29:54,419
our hacking workflow if we could pull

647
00:29:54,419 --> 00:29:57,480
that whole folder over to our Mac or

648
00:29:57,480 --> 00:30:00,299
Linux PC and have access to the full

649
00:30:00,299 --> 00:30:03,419
scope of our hacking tools and even

650
00:30:03,419 --> 00:30:07,500
simple Linux tools that may allow us to

651
00:30:07,500 --> 00:30:10,440
more easily extract information or

652
00:30:10,440 --> 00:30:12,840
search the contents of that folder for

653
00:30:12,840 --> 00:30:16,440
sensitive data and so in this demo we're

654
00:30:16,440 --> 00:30:18,360
going to pick up where we left off

655
00:30:18,360 --> 00:30:21,240
and demonstrate what are the challenges

656
00:30:21,240 --> 00:30:22,799
that we might encounter trying to

657
00:30:22,799 --> 00:30:25,440
extract that data and how can we

658
00:30:25,440 --> 00:30:28,620
overcome those challenges

659
00:30:28,620 --> 00:30:32,039
so we're going to start by switching to

660
00:30:32,039 --> 00:30:35,399
the mobile device shell and changing

661
00:30:35,399 --> 00:30:38,279
context to the app user associated with

662
00:30:38,279 --> 00:30:41,039
our POC app

663
00:30:41,039 --> 00:30:43,740
and what we're going to do is see if we

664
00:30:43,740 --> 00:30:46,039
can

665
00:30:46,100 --> 00:30:50,279
make any changes to or view the external

666
00:30:50,279 --> 00:30:52,080
storage of the device which in this case

667
00:30:52,080 --> 00:30:53,760
is SD card

668
00:30:53,760 --> 00:30:56,279
and what we're going to find

669
00:30:56,279 --> 00:30:59,100
is that we're not able to do that so as

670
00:30:59,100 --> 00:31:03,360
the context of the app user

671
00:31:03,360 --> 00:31:06,360
we are unable to copy the contents of

672
00:31:06,360 --> 00:31:08,580
our internal data to our external

673
00:31:08,580 --> 00:31:10,740
storage and I have found this applies

674
00:31:10,740 --> 00:31:13,440
even if the app has the right external

675
00:31:13,440 --> 00:31:15,899
permission

676
00:31:15,899 --> 00:31:18,659
so while we now have access to the data

677
00:31:18,659 --> 00:31:21,179
itself we don't have the ability to copy

678
00:31:21,179 --> 00:31:23,760
it off of the device using simple means

679
00:31:23,760 --> 00:31:27,120
such as placing it on the SD card

680
00:31:27,120 --> 00:31:30,120
and basically what our goal is is to be

681
00:31:30,120 --> 00:31:31,679
able to

682
00:31:31,679 --> 00:31:34,500
access this data in some context other

683
00:31:34,500 --> 00:31:37,980
than the app user itself

684
00:31:37,980 --> 00:31:39,899
which is what we will need to be able to

685
00:31:39,899 --> 00:31:41,640
pull it off the device

686
00:31:41,640 --> 00:31:45,720
so what we can do is in the context of

687
00:31:45,720 --> 00:31:49,320
the user itself we will tar the contents

688
00:31:49,320 --> 00:31:52,440
of the internal app data folder

689
00:31:52,440 --> 00:31:55,620
and we will place that tar file in that

690
00:31:55,620 --> 00:31:57,120
same folder because that's the only

691
00:31:57,120 --> 00:32:00,199
folder we can write to

692
00:32:03,960 --> 00:32:05,520
so

693
00:32:05,520 --> 00:32:08,700
fortunately within ADB shell we do have

694
00:32:08,700 --> 00:32:10,200
access to Tar

695
00:32:10,200 --> 00:32:11,760
so we will go ahead and do that and as

696
00:32:11,760 --> 00:32:12,899
you can see

697
00:32:12,899 --> 00:32:15,779
in that folder is our tar file and I'll

698
00:32:15,779 --> 00:32:18,360
just demonstrate here

699
00:32:18,360 --> 00:32:20,940
the context that we're running in as you

700
00:32:20,940 --> 00:32:22,980
can see is the user associated with the

701
00:32:22,980 --> 00:32:25,559
app and we are in the apps internal

702
00:32:25,559 --> 00:32:26,520
storage

703
00:32:26,520 --> 00:32:29,580
area so let's go ahead and exit out of

704
00:32:29,580 --> 00:32:31,620
ADB shell and now we're going to be back

705
00:32:31,620 --> 00:32:34,320
on our macro Linux PC

706
00:32:34,320 --> 00:32:36,059
so what we're going to do here is a

707
00:32:36,059 --> 00:32:40,380
handy trick we can pass ADB shell the

708
00:32:40,380 --> 00:32:43,679
commands that we want to run on the

709
00:32:43,679 --> 00:32:44,640
device

710
00:32:44,640 --> 00:32:46,679
so in this case we're going to say

711
00:32:46,679 --> 00:32:49,080
launch ADB shell and then once you do

712
00:32:49,080 --> 00:32:52,020
that I want you to run as the nerdwell

713
00:32:52,020 --> 00:32:53,580
POC app

714
00:32:53,580 --> 00:32:55,320
and then

715
00:32:55,320 --> 00:32:57,240
once you're running in the context of

716
00:32:57,240 --> 00:33:00,659
the app user I want you to run xxd which

717
00:33:00,659 --> 00:33:06,840
is the binary data dump of my tar file

718
00:33:06,840 --> 00:33:08,640
go ahead and close the quote and we're

719
00:33:08,640 --> 00:33:10,860
going to pipe that to now this is

720
00:33:10,860 --> 00:33:14,220
running on our Mac or Linux device xxd-r

721
00:33:14,220 --> 00:33:17,299
which reads the contents of xxd output

722
00:33:17,299 --> 00:33:20,220
and we're going to redirect that to a

723
00:33:20,220 --> 00:33:23,100
file on our local machine

724
00:33:23,100 --> 00:33:26,760
so just to kind of simplify and

725
00:33:26,760 --> 00:33:30,899
reiterate exactly what's going on here

726
00:33:30,899 --> 00:33:33,779
the portion highlighted or underlined in

727
00:33:33,779 --> 00:33:36,960
red is running on our Linux device the

728
00:33:36,960 --> 00:33:38,880
portion underlined in green is running

729
00:33:38,880 --> 00:33:41,279
on the Android device

730
00:33:41,279 --> 00:33:44,460
and likewise this last portion in red is

731
00:33:44,460 --> 00:33:47,220
also running on our Linux machine

732
00:33:47,220 --> 00:33:49,080
so what we're doing is we're running ADB

733
00:33:49,080 --> 00:33:52,260
shell on our Linux machine we're passing

734
00:33:52,260 --> 00:33:54,840
it everything in the quotes to tell it

735
00:33:54,840 --> 00:33:58,080
run this on the mobile device and then

736
00:33:58,080 --> 00:34:00,360
we are redirecting the output to

737
00:34:00,360 --> 00:34:01,980
something else running on our Linux

738
00:34:01,980 --> 00:34:02,940
device

739
00:34:02,940 --> 00:34:06,779
and this xxd-r command is helpful It's

740
00:34:06,779 --> 00:34:10,639
relatively new to the xxd tool itself

741
00:34:10,639 --> 00:34:15,000
but what it does is read the output of a

742
00:34:15,000 --> 00:34:17,339
prior xxd command

743
00:34:17,339 --> 00:34:20,159
and redirect it to a file that we

744
00:34:20,159 --> 00:34:21,960
specify so in this case we're going to

745
00:34:21,960 --> 00:34:24,899
redirect to the entire file on our local

746
00:34:24,899 --> 00:34:26,040
machine

747
00:34:26,040 --> 00:34:30,359
and with that we are now able to read

748
00:34:30,359 --> 00:34:34,260
our internal app data as the user that

749
00:34:34,260 --> 00:34:35,520
we need to

750
00:34:35,520 --> 00:34:37,800
and able to write it

751
00:34:37,800 --> 00:34:41,219
as a different user

752
00:34:41,219 --> 00:34:43,440
and so now once we have the file locally

753
00:34:43,440 --> 00:34:45,839
we will simply unturn it

754
00:34:45,839 --> 00:34:48,000
and because tar

755
00:34:48,000 --> 00:34:49,918
keeps the

756
00:34:49,918 --> 00:34:50,659
The

757
00:34:50,659 --> 00:34:53,460
Source folder structure we will have

758
00:34:53,460 --> 00:34:54,780
basically

759
00:34:54,780 --> 00:34:56,639
that structure created within our

760
00:34:56,639 --> 00:34:58,200
current working folder

761
00:34:58,200 --> 00:35:00,960
so what we're going to do now

762
00:35:00,960 --> 00:35:03,060
is demonstrate how this can be

763
00:35:03,060 --> 00:35:06,480
beneficial to us in the prior example we

764
00:35:06,480 --> 00:35:10,200
were able to review the cookies sqlite

765
00:35:10,200 --> 00:35:13,740
database using on device tools like xxd

766
00:35:13,740 --> 00:35:16,320
but it wasn't in a very user-friendly

767
00:35:16,320 --> 00:35:19,140
format and as you might imagine once you

768
00:35:19,140 --> 00:35:21,000
start adding a lot of cookies and a lot

769
00:35:21,000 --> 00:35:22,500
of other information to some of those

770
00:35:22,500 --> 00:35:24,839
files it can get rather tricky and

771
00:35:24,839 --> 00:35:28,380
cumbersome to identify useful

772
00:35:28,380 --> 00:35:32,220
information let alone extract it in in a

773
00:35:32,220 --> 00:35:34,859
repeatable process for a bug Bounty

774
00:35:34,859 --> 00:35:37,020
report and so what we're going to do

775
00:35:37,020 --> 00:35:39,960
here is now that we have the data on our

776
00:35:39,960 --> 00:35:42,300
Linux device we're simply going to use

777
00:35:42,300 --> 00:35:45,660
the tools available to us in this more

778
00:35:45,660 --> 00:35:48,960
powerful environment like Python and the

779
00:35:48,960 --> 00:35:52,440
SQL Lite module to more readily review

780
00:35:52,440 --> 00:35:55,260
the data and so in this case we're going

781
00:35:55,260 --> 00:35:58,079
to open up that cookie

782
00:35:58,079 --> 00:36:01,920
database using simple light module

783
00:36:01,920 --> 00:36:04,740
and just to demonstrate how you might

784
00:36:04,740 --> 00:36:07,380
integrate this into your workflow

785
00:36:07,380 --> 00:36:10,560
let's just say we didn't know the exact

786
00:36:10,560 --> 00:36:13,920
structure of this full of this sqlite

787
00:36:13,920 --> 00:36:15,780
database that we're taking a look at

788
00:36:15,780 --> 00:36:18,960
well what we could do is create a query

789
00:36:18,960 --> 00:36:21,300
to

790
00:36:21,300 --> 00:36:26,880
query the tables the schema of this

791
00:36:26,880 --> 00:36:29,640
sqlite database

792
00:36:29,640 --> 00:36:31,140
so that's what we're doing here we're

793
00:36:31,140 --> 00:36:33,319
gonna

794
00:36:33,720 --> 00:36:36,060
craft our query iterate through the

795
00:36:36,060 --> 00:36:39,000
results and print the tables and here we

796
00:36:39,000 --> 00:36:41,640
go and as you can see

797
00:36:41,640 --> 00:36:45,359
we have one that

798
00:36:45,359 --> 00:36:48,720
table here that includes all the headers

799
00:36:48,720 --> 00:36:52,939
for our cookies table

800
00:36:55,020 --> 00:36:57,540
so now we can see the same data that we

801
00:36:57,540 --> 00:36:59,940
saw before in a much more

802
00:36:59,940 --> 00:37:01,859
usable format

803
00:37:01,859 --> 00:37:06,140
by selecting all from that table

804
00:37:09,540 --> 00:37:11,460
iterate through the results print them

805
00:37:11,460 --> 00:37:13,859
which in this case is one and as you can

806
00:37:13,859 --> 00:37:16,079
see now we have a much more

807
00:37:16,079 --> 00:37:18,660
user-friendly

808
00:37:18,660 --> 00:37:22,339
output of the key value pair

809
00:37:22,980 --> 00:37:27,180
now again this was a demonstrative POC

810
00:37:27,180 --> 00:37:30,480
app that I created just to show how we

811
00:37:30,480 --> 00:37:34,020
would view that internal data however

812
00:37:34,020 --> 00:37:36,540
you can use this to find any sort of

813
00:37:36,540 --> 00:37:39,599
internal data that's used by the app and

814
00:37:39,599 --> 00:37:42,599
even cookie data and local storage data

815
00:37:42,599 --> 00:37:44,820
can lead to some rewardable

816
00:37:44,820 --> 00:37:46,200
vulnerabilities

817
00:37:46,200 --> 00:37:49,140
and so to demonstrate that let me walk

818
00:37:49,140 --> 00:37:51,599
you through how I have used this to

819
00:37:51,599 --> 00:37:55,320
escalate bugs from P5 to P4

820
00:37:55,320 --> 00:37:59,599
to to get a rewardable bounty now

821
00:37:59,599 --> 00:38:01,980
obviously we're shooting for higher than

822
00:38:01,980 --> 00:38:04,800
P4 if we can but this similar techniques

823
00:38:04,800 --> 00:38:07,740
can be used to find everything from p1s

824
00:38:07,740 --> 00:38:14,339
down to p4s so a uh a web app that does

825
00:38:14,339 --> 00:38:17,760
not terminate the user session upon

826
00:38:17,760 --> 00:38:21,119
logout on the server side only is a P5

827
00:38:21,119 --> 00:38:25,200
bug not rewardable however if that token

828
00:38:25,200 --> 00:38:28,020
is also not invalidated on the client

829
00:38:28,020 --> 00:38:31,079
side that's a P4 which is generally

830
00:38:31,079 --> 00:38:32,280
rewardable

831
00:38:32,280 --> 00:38:34,500
it's also a low-hanging fruit and so

832
00:38:34,500 --> 00:38:36,300
almost certainly would be a duplicate

833
00:38:36,300 --> 00:38:40,079
but worth reporting usually similarly

834
00:38:40,079 --> 00:38:43,859
you'll see that a sensitive token stored

835
00:38:43,859 --> 00:38:47,160
in local storage is also a P4

836
00:38:47,160 --> 00:38:50,099
and we'll oftentimes see web apps that

837
00:38:50,099 --> 00:38:52,260
store session tokens in local storage

838
00:38:52,260 --> 00:38:55,200
and that's a P4 and many times Android

839
00:38:55,200 --> 00:38:57,720
apps will use a simple web view to

840
00:38:57,720 --> 00:39:00,000
access a standard web page

841
00:39:00,000 --> 00:39:03,000
and so some of the same bugs that you

842
00:39:03,000 --> 00:39:04,980
would find in the standard web app can

843
00:39:04,980 --> 00:39:08,040
be applicable to an Android mobile app

844
00:39:08,040 --> 00:39:10,920
but the issue you encounter is how do

845
00:39:10,920 --> 00:39:13,859
you demonstrate that the session token

846
00:39:13,859 --> 00:39:16,440
is not invalidated on the client side at

847
00:39:16,440 --> 00:39:19,079
logout if you can't view the internal

848
00:39:19,079 --> 00:39:21,540
data or how do you demonstrate that a

849
00:39:21,540 --> 00:39:23,520
sensitive token is stored in the local

850
00:39:23,520 --> 00:39:27,060
storage on the device unencrypted if you

851
00:39:27,060 --> 00:39:29,940
can't access the device internal the app

852
00:39:29,940 --> 00:39:33,000
internal storage and so what this

853
00:39:33,000 --> 00:39:36,240
technique gives you is a way to

854
00:39:36,240 --> 00:39:39,420
gain exactly that access and in that way

855
00:39:39,420 --> 00:39:44,040
you can escalate a P5 to P4 or

856
00:39:44,040 --> 00:39:45,900
potentially even find some p4s and

857
00:39:45,900 --> 00:39:47,220
higher that you would not be able to

858
00:39:47,220 --> 00:39:48,720
find otherwise

859
00:39:48,720 --> 00:39:51,240
and of course we're looking for for more

860
00:39:51,240 --> 00:39:54,480
fruitful bugs than p4s so what might you

861
00:39:54,480 --> 00:39:57,740
find that can be of more criticality

862
00:39:57,740 --> 00:40:01,320
well in many instances developers know

863
00:40:01,320 --> 00:40:03,660
better than to hard code sensitive

864
00:40:03,660 --> 00:40:05,880
tokens in the APK

865
00:40:05,880 --> 00:40:09,060
and so you may not find them there but

866
00:40:09,060 --> 00:40:12,060
they may have a need for some sort of

867
00:40:12,060 --> 00:40:15,420
token for for a centralized back-end

868
00:40:15,420 --> 00:40:18,240
service and if it's not implemented

869
00:40:18,240 --> 00:40:21,300
correctly that may be a token that is

870
00:40:21,300 --> 00:40:24,839
shared between instances of the app

871
00:40:24,839 --> 00:40:27,420
and so one common bug pattern that I see

872
00:40:27,420 --> 00:40:31,260
is the app will make an API call to a

873
00:40:31,260 --> 00:40:32,160
back end

874
00:40:32,160 --> 00:40:33,560
service

875
00:40:33,560 --> 00:40:36,660
authenticate to that service and receive

876
00:40:36,660 --> 00:40:39,660
some token but that token is not

877
00:40:39,660 --> 00:40:41,940
individual to that instance of the app

878
00:40:41,940 --> 00:40:44,460
it's actually a shared token to some

879
00:40:44,460 --> 00:40:46,560
back-end service and by having that

880
00:40:46,560 --> 00:40:49,260
shared token you gain access to other

881
00:40:49,260 --> 00:40:53,280
users data now again we may be able to

882
00:40:53,280 --> 00:40:56,040
find this likely could see this if we

883
00:40:56,040 --> 00:40:59,160
were reviewing intercepted traffic but

884
00:40:59,160 --> 00:41:01,200
we could also miss it we could simply

885
00:41:01,200 --> 00:41:04,920
not see that request in burp or it could

886
00:41:04,920 --> 00:41:07,380
be obfuscated in some way whether

887
00:41:07,380 --> 00:41:09,800
they're through encryption or

888
00:41:09,800 --> 00:41:13,020
compression and so by being able to view

889
00:41:13,020 --> 00:41:15,720
the internal app data we can see where

890
00:41:15,720 --> 00:41:18,599
the application has written that count

891
00:41:18,599 --> 00:41:21,359
that key down sometimes in its shared

892
00:41:21,359 --> 00:41:23,579
preferences file sometimes just in a

893
00:41:23,579 --> 00:41:25,800
random text file within its internal

894
00:41:25,800 --> 00:41:29,339
storage but because the developer has

895
00:41:29,339 --> 00:41:31,619
the assumption that the attacker cannot

896
00:41:31,619 --> 00:41:34,140
access the internal app data they have

897
00:41:34,140 --> 00:41:36,180
not applied any other security controls

898
00:41:36,180 --> 00:41:39,119
and have simply written that data that

899
00:41:39,119 --> 00:41:42,660
shared token to the storage in clear

900
00:41:42,660 --> 00:41:45,599
text form that you can readily retrieve

901
00:41:45,599 --> 00:41:49,500
and then test with further techniques to

902
00:41:49,500 --> 00:41:50,760
identify

903
00:41:50,760 --> 00:41:54,300
more impactful vulnerabilities

904
00:41:54,300 --> 00:41:57,359
so where can we get some of these tools

905
00:41:57,359 --> 00:42:00,240
again I did not create any of these but

906
00:42:00,240 --> 00:42:02,700
I came across them sometimes through

907
00:42:02,700 --> 00:42:04,859
other talks some of these eyes stumbled

908
00:42:04,859 --> 00:42:07,800
upon but I did not create them so it's

909
00:42:07,800 --> 00:42:09,960
important that we recognize those who

910
00:42:09,960 --> 00:42:11,820
have taken the time to generate these

911
00:42:11,820 --> 00:42:15,300
awesome tools that significantly reduce

912
00:42:15,300 --> 00:42:18,180
the workload for thus us about bounty

913
00:42:18,180 --> 00:42:19,020
hunters

914
00:42:19,020 --> 00:42:21,119
and it will start with Apk middle so

915
00:42:21,119 --> 00:42:24,060
there's a GitHub here at stranded code

916
00:42:24,060 --> 00:42:25,859
and

917
00:42:25,859 --> 00:42:28,680
this is a node.js package so you do need

918
00:42:28,680 --> 00:42:31,920
to have node running obviously and the

919
00:42:31,920 --> 00:42:35,040
the GitHub repo there has a very nice

920
00:42:35,040 --> 00:42:37,200
walk through basically once you have

921
00:42:37,200 --> 00:42:40,579
node and the node package manager npm

922
00:42:40,579 --> 00:42:43,800
installed on your Mac or Linux device

923
00:42:43,800 --> 00:42:45,720
and of course you can do this in Windows

924
00:42:45,720 --> 00:42:49,619
as well you just run npm install APK

925
00:42:49,619 --> 00:42:52,200
minimum and you're set

926
00:42:52,200 --> 00:42:54,480
the others you can get some of these

927
00:42:54,480 --> 00:42:56,520
tools through other means I like to have

928
00:42:56,520 --> 00:42:59,339
them as jar files just because then it's

929
00:42:59,339 --> 00:43:01,740
very portable and easy to upgrade as

930
00:43:01,740 --> 00:43:03,180
they come out with other versions and

931
00:43:03,180 --> 00:43:06,060
stuff and so what I found is these

932
00:43:06,060 --> 00:43:07,819
locations provide

933
00:43:07,819 --> 00:43:11,400
builds of the tools themselves as jars

934
00:43:11,400 --> 00:43:13,140
so that you don't have to mess with any

935
00:43:13,140 --> 00:43:15,119
of that just download the jar

936
00:43:15,119 --> 00:43:18,119
run it with Java and you're set and then

937
00:43:18,119 --> 00:43:21,060
again Android Studio while you don't

938
00:43:21,060 --> 00:43:22,740
necessarily have to have the full

939
00:43:22,740 --> 00:43:25,260
Android Studio package to get the tools

940
00:43:25,260 --> 00:43:28,380
that we needed to perform our tasks

941
00:43:28,380 --> 00:43:30,900
today I highly recommend that you get it

942
00:43:30,900 --> 00:43:33,119
and become familiar with it because it

943
00:43:33,119 --> 00:43:36,240
does provide a lot of other handy UI

944
00:43:36,240 --> 00:43:38,760
features and uh

945
00:43:38,760 --> 00:43:41,280
opens the door for you to start learning

946
00:43:41,280 --> 00:43:43,079
more and more about the Android

947
00:43:43,079 --> 00:43:45,720
environment and creating your own apps

948
00:43:45,720 --> 00:43:48,599
so that you can hack them and understand

949
00:43:48,599 --> 00:43:51,420
what the developers are going through

950
00:43:51,420 --> 00:43:55,020
it's easy to to be

951
00:43:55,020 --> 00:43:57,660
cynical of some of the mistakes that are

952
00:43:57,660 --> 00:44:00,000
made but when you experience the

953
00:44:00,000 --> 00:44:01,619
challenges that the developers are

954
00:44:01,619 --> 00:44:03,960
trying to overcome not only do you gain

955
00:44:03,960 --> 00:44:06,359
a whole new appreciation for how

956
00:44:06,359 --> 00:44:09,060
difficult it can be to implement some of

957
00:44:09,060 --> 00:44:11,339
the security features that we have come

958
00:44:11,339 --> 00:44:14,280
to expect but you also learn what are

959
00:44:14,280 --> 00:44:16,560
some of the common pitfalls that

960
00:44:16,560 --> 00:44:18,720
developers encounter as they Implement

961
00:44:18,720 --> 00:44:21,060
those security features and of course

962
00:44:21,060 --> 00:44:23,579
those translate directly into bug

963
00:44:23,579 --> 00:44:27,660
patterns that we can look for in our

964
00:44:27,660 --> 00:44:30,420
hacking methodology I hope this was

965
00:44:30,420 --> 00:44:33,660
useful to you and I look forward to

966
00:44:33,660 --> 00:44:36,799
talking to you again soon

