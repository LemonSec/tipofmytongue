1
00:00:00,120 --> 00:00:02,940
hey hackers nerdwell here

2
00:00:02,940 --> 00:00:05,160
have you ever noticed that sometimes the

3
00:00:05,160 --> 00:00:07,919
best bugs are hiding in plain sight

4
00:00:07,919 --> 00:00:10,019
well today we're going to take a look at

5
00:00:10,019 --> 00:00:11,760
finding and exploiting hidden

6
00:00:11,760 --> 00:00:14,580
functionality in Windows software by

7
00:00:14,580 --> 00:00:16,500
hacking dlls

8
00:00:16,500 --> 00:00:18,300
before we start hacking Windows

9
00:00:18,300 --> 00:00:20,340
applications it's helpful to have some

10
00:00:20,340 --> 00:00:22,080
background about the patterns and

11
00:00:22,080 --> 00:00:25,080
practices implemented by the developers

12
00:00:25,080 --> 00:00:26,939
of those applications

13
00:00:26,939 --> 00:00:28,920
and many of these patterns and practices

14
00:00:28,920 --> 00:00:31,439
have been developed over the past 30

15
00:00:31,439 --> 00:00:33,780
years and implemented by Microsoft

16
00:00:33,780 --> 00:00:34,980
themselves

17
00:00:34,980 --> 00:00:37,800
in many cases these have driven the

18
00:00:37,800 --> 00:00:40,200
technological advancements available to

19
00:00:40,200 --> 00:00:43,020
developers and the business processes

20
00:00:43,020 --> 00:00:45,480
that developers Implement in their

21
00:00:45,480 --> 00:00:48,180
software development life cycle

22
00:00:48,180 --> 00:00:50,820
a big aspect of development in a

23
00:00:50,820 --> 00:00:53,219
Microsoft environment is code

24
00:00:53,219 --> 00:00:55,980
reusability and extensibility

25
00:00:55,980 --> 00:00:58,860
and the basic premise here is developers

26
00:00:58,860 --> 00:01:01,620
want to write once use many

27
00:01:01,620 --> 00:01:04,440
so if they create some module with a

28
00:01:04,440 --> 00:01:06,900
capability they want to be able to reuse

29
00:01:06,900 --> 00:01:10,260
that module within the same app within

30
00:01:10,260 --> 00:01:13,920
other apps and integrate with customers

31
00:01:13,920 --> 00:01:17,100
vendors Partners all sorts of other

32
00:01:17,100 --> 00:01:20,640
examples but the basic premise is don't

33
00:01:20,640 --> 00:01:22,860
reinvent the wheel write something one

34
00:01:22,860 --> 00:01:26,520
time and reuse it multiple times

35
00:01:26,520 --> 00:01:28,799
another important aspect of development

36
00:01:28,799 --> 00:01:31,439
in a Microsoft environment is the sheer

37
00:01:31,439 --> 00:01:34,380
scale and scope of some of these

38
00:01:34,380 --> 00:01:37,860
applications they're so large that they

39
00:01:37,860 --> 00:01:39,740
require many teams working together

40
00:01:39,740 --> 00:01:42,600
sometimes across continents and time

41
00:01:42,600 --> 00:01:45,360
zones and definitely working under

42
00:01:45,360 --> 00:01:47,280
different timetables

43
00:01:47,280 --> 00:01:50,340
to build individual aspects of the

44
00:01:50,340 --> 00:01:53,700
application independently but then put

45
00:01:53,700 --> 00:01:56,579
those components together to produce a

46
00:01:56,579 --> 00:02:00,000
final product that is cohesive and works

47
00:02:00,000 --> 00:02:01,979
well together

48
00:02:01,979 --> 00:02:04,320
along the same lines

49
00:02:04,320 --> 00:02:07,380
by building a modular application we can

50
00:02:07,380 --> 00:02:09,660
take a modular approach to maintenance

51
00:02:09,660 --> 00:02:12,180
of the application going forward

52
00:02:12,180 --> 00:02:15,060
so if we need to implement a feature

53
00:02:15,060 --> 00:02:17,940
request or some security improvements to

54
00:02:17,940 --> 00:02:21,480
a specific element of an application we

55
00:02:21,480 --> 00:02:23,640
don't want to have to rewrite or rebuild

56
00:02:23,640 --> 00:02:26,040
the entire application it would be

57
00:02:26,040 --> 00:02:27,780
better if we can just work on the

58
00:02:27,780 --> 00:02:29,700
individual components and modules

59
00:02:29,700 --> 00:02:32,040
themselves and then reintegrate those

60
00:02:32,040 --> 00:02:35,040
into the larger hole which is exactly

61
00:02:35,040 --> 00:02:37,020
what we find in most Windows

62
00:02:37,020 --> 00:02:39,300
applications today

63
00:02:39,300 --> 00:02:42,480
lastly another very important aspect of

64
00:02:42,480 --> 00:02:44,879
working in a Microsoft environment is

65
00:02:44,879 --> 00:02:46,620
the ability to integrate with third

66
00:02:46,620 --> 00:02:49,800
parties and a very common example here

67
00:02:49,800 --> 00:02:52,980
is many apps today especially business

68
00:02:52,980 --> 00:02:56,099
line of business type applications will

69
00:02:56,099 --> 00:02:58,860
have some requirement to work with PDFs

70
00:02:58,860 --> 00:03:01,860
even if it's just rendering a PDF or

71
00:03:01,860 --> 00:03:04,379
maybe modifying them and all sorts of

72
00:03:04,379 --> 00:03:06,360
other interactions

73
00:03:06,360 --> 00:03:08,160
the developers don't want to have to

74
00:03:08,160 --> 00:03:10,680
reinvent this capability every time they

75
00:03:10,680 --> 00:03:12,420
develop a new app that needs to work

76
00:03:12,420 --> 00:03:13,800
with PDFs

77
00:03:13,800 --> 00:03:16,800
so third parties have produced libraries

78
00:03:16,800 --> 00:03:19,260
that developers can integrate into their

79
00:03:19,260 --> 00:03:21,840
applications and then redistribute to

80
00:03:21,840 --> 00:03:24,420
the End customer that handles all that

81
00:03:24,420 --> 00:03:26,459
capability for them

82
00:03:26,459 --> 00:03:29,879
the benefits here are first reduced cost

83
00:03:29,879 --> 00:03:32,340
to the End customer because the

84
00:03:32,340 --> 00:03:33,840
developer doesn't have to worry about

85
00:03:33,840 --> 00:03:36,239
creating all that capability

86
00:03:36,239 --> 00:03:39,300
it also reduces the time to bring a

87
00:03:39,300 --> 00:03:41,459
product to Market because the developer

88
00:03:41,459 --> 00:03:44,519
can grab ready built modules and

89
00:03:44,519 --> 00:03:47,040
integrate them into their application

90
00:03:47,040 --> 00:03:49,620
lastly it provides a standardized

91
00:03:49,620 --> 00:03:50,879
interface for a lot of these

92
00:03:50,879 --> 00:03:53,220
capabilities that developers can become

93
00:03:53,220 --> 00:03:56,280
familiar with and then reuse across a

94
00:03:56,280 --> 00:03:59,040
variety of different applications

95
00:03:59,040 --> 00:04:01,860
now while all these different aspects

96
00:04:01,860 --> 00:04:04,500
bring many benefits to the table

97
00:04:04,500 --> 00:04:07,260
they also bring some opportunities for

98
00:04:07,260 --> 00:04:10,080
accidents to happen mistakes to be made

99
00:04:10,080 --> 00:04:13,200
gaps to be present and in each of those

100
00:04:13,200 --> 00:04:15,420
instances we tend to find security

101
00:04:15,420 --> 00:04:18,060
vulnerabilities so as bug bounty hunters

102
00:04:18,060 --> 00:04:20,760
we want to understand how these patterns

103
00:04:20,760 --> 00:04:23,639
and practices impact the final product

104
00:04:23,639 --> 00:04:26,940
and how we can take advantage of that to

105
00:04:26,940 --> 00:04:28,800
find potential vulnerabilities to

106
00:04:28,800 --> 00:04:30,120
exploit

107
00:04:30,120 --> 00:04:34,919
so back in the day when Windows became

108
00:04:34,919 --> 00:04:37,020
the most popular operating system on the

109
00:04:37,020 --> 00:04:39,600
planet it was common to see applications

110
00:04:39,600 --> 00:04:42,419
written in visual C plus

111
00:04:42,419 --> 00:04:45,360
and when we did that they were compiled

112
00:04:45,360 --> 00:04:48,380
into machine code they were the typical

113
00:04:48,380 --> 00:04:50,940
binary executables that we've all come

114
00:04:50,940 --> 00:04:54,180
to expect and that we reverse with

115
00:04:54,180 --> 00:04:58,199
idapro and to really do much with and

116
00:04:58,199 --> 00:05:01,860
and reverse engineer and make binary

117
00:05:01,860 --> 00:05:04,919
patches to them you really had to bring

118
00:05:04,919 --> 00:05:07,860
them down to assembly and work with it

119
00:05:07,860 --> 00:05:10,199
at that level and then rebuild it from

120
00:05:10,199 --> 00:05:12,660
there obviously that's quite a

121
00:05:12,660 --> 00:05:16,380
cumbersome process for the hacker but as

122
00:05:16,380 --> 00:05:18,660
it turns out that was also a rather

123
00:05:18,660 --> 00:05:20,940
cumbersome process for the developers

124
00:05:20,940 --> 00:05:24,000
and users as well

125
00:05:24,000 --> 00:05:28,080
so even in the days of compiled C plus

126
00:05:28,080 --> 00:05:31,500
plus applications we did have the the

127
00:05:31,500 --> 00:05:35,639
concept of modularity code reuse and

128
00:05:35,639 --> 00:05:37,860
dynamic loading of application

129
00:05:37,860 --> 00:05:40,199
capabilities and in a Microsoft

130
00:05:40,199 --> 00:05:42,479
environment this was implemented through

131
00:05:42,479 --> 00:05:45,600
dlls dynamically loaded libraries

132
00:05:45,600 --> 00:05:47,220
and

133
00:05:47,220 --> 00:05:49,680
the way it would work is if you were a

134
00:05:49,680 --> 00:05:52,020
developer and you wanted to use let's

135
00:05:52,020 --> 00:05:54,720
say a third-party PDF Library

136
00:05:54,720 --> 00:05:57,360
you would purchase that library from the

137
00:05:57,360 --> 00:05:58,979
third party they would send you some

138
00:05:58,979 --> 00:06:01,740
dlls you would include them in your

139
00:06:01,740 --> 00:06:04,919
distribution and then in your app you

140
00:06:04,919 --> 00:06:08,280
would specifically call those dlls and

141
00:06:08,280 --> 00:06:10,740
then import functions

142
00:06:10,740 --> 00:06:12,419
from those

143
00:06:12,419 --> 00:06:14,580
dlls that you want to use in your

144
00:06:14,580 --> 00:06:15,720
application

145
00:06:15,720 --> 00:06:19,620
it was a rather manual and explicit

146
00:06:19,620 --> 00:06:22,919
process meaning you needed to

147
00:06:22,919 --> 00:06:27,479
specifically import that module and then

148
00:06:27,479 --> 00:06:30,419
specifically import individual methods

149
00:06:30,419 --> 00:06:33,600
and properties within that library that

150
00:06:33,600 --> 00:06:35,220
you wanted to use within your

151
00:06:35,220 --> 00:06:37,020
application

152
00:06:37,020 --> 00:06:40,800
and while that worked well as time

153
00:06:40,800 --> 00:06:44,780
progressed Microsoft moved to a

154
00:06:44,780 --> 00:06:47,419
interpreted language environment a

155
00:06:47,419 --> 00:06:50,220
just-in-time compiled environment just

156
00:06:50,220 --> 00:06:53,940
like we see with Java and JavaScript and

157
00:06:53,940 --> 00:06:56,520
Python and all these other languages

158
00:06:56,520 --> 00:07:00,300
we got Visual Basic and basically when

159
00:07:00,300 --> 00:07:03,240
you built a Visual Basic app it did not

160
00:07:03,240 --> 00:07:06,740
compile to machine code it compiled to

161
00:07:06,740 --> 00:07:10,319
interpreted intermediary language

162
00:07:10,319 --> 00:07:14,120
and that led to the development of

163
00:07:14,120 --> 00:07:17,100
the.net framework and most of your

164
00:07:17,100 --> 00:07:19,080
applications today in a Microsoft

165
00:07:19,080 --> 00:07:20,960
environment are

166
00:07:20,960 --> 00:07:24,419
primarily.net and so we have multiple

167
00:07:24,419 --> 00:07:26,400
languages the the

168
00:07:26,400 --> 00:07:29,460
scale of variety in terms of different

169
00:07:29,460 --> 00:07:32,580
languages in the.net framework seems to

170
00:07:32,580 --> 00:07:33,900
grow every year

171
00:07:33,900 --> 00:07:37,979
but some of the key languages are Visual

172
00:07:37,979 --> 00:07:40,440
Basic and c-sharp

173
00:07:40,440 --> 00:07:42,660
what's important to remember here is

174
00:07:42,660 --> 00:07:46,139
when you build a net application it does

175
00:07:46,139 --> 00:07:49,440
not compile to machine code it compiles

176
00:07:49,440 --> 00:07:51,720
to an intermediary language

177
00:07:51,720 --> 00:07:54,900
and actually regardless of whether you

178
00:07:54,900 --> 00:08:00,000
wrote it in VB or C sharp the under the

179
00:08:00,000 --> 00:08:03,360
produced intermediary code at the end of

180
00:08:03,360 --> 00:08:05,940
the day is actually the same

181
00:08:05,940 --> 00:08:09,360
so this provides a lot of flexibility it

182
00:08:09,360 --> 00:08:12,060
also provides a lot of interoperability

183
00:08:12,060 --> 00:08:16,380
so I can write a c-sharp app that is

184
00:08:16,380 --> 00:08:19,879
able to leverage modular capabilities

185
00:08:19,879 --> 00:08:24,780
published by a visualbasic.net app

186
00:08:24,780 --> 00:08:27,539
it's also been integrated into

187
00:08:27,539 --> 00:08:30,240
Powershell very heavily to the point

188
00:08:30,240 --> 00:08:33,000
that as I've depicted here you can

189
00:08:33,000 --> 00:08:34,159
actually

190
00:08:34,159 --> 00:08:36,179
invoke.net code

191
00:08:36,179 --> 00:08:40,320
in Powershell and if you care to take

192
00:08:40,320 --> 00:08:43,620
the time you could build an entire GUI

193
00:08:43,620 --> 00:08:45,600
based app

194
00:08:45,600 --> 00:08:48,779
from Powershell command line itself with

195
00:08:48,779 --> 00:08:50,820
all the functionality and capabilities

196
00:08:50,820 --> 00:08:55,800
available to you in C sharp

197
00:08:55,800 --> 00:08:59,100
so that's just a very brief history of

198
00:08:59,100 --> 00:09:04,380
dlls and the progression of programming

199
00:09:04,380 --> 00:09:06,839
languages in a Windows environment

200
00:09:06,839 --> 00:09:09,240
and this is going to play a very big

201
00:09:09,240 --> 00:09:12,540
role in how we target Windows

202
00:09:12,540 --> 00:09:15,240
applications in modern systems talked

203
00:09:15,240 --> 00:09:18,980
about some of the business cases for

204
00:09:18,980 --> 00:09:22,620
using modular approaches to software

205
00:09:22,620 --> 00:09:25,260
development let's take a look at some

206
00:09:25,260 --> 00:09:28,500
specific technical implications of this

207
00:09:28,500 --> 00:09:31,200
approach in modern applications

208
00:09:31,200 --> 00:09:33,180
and when we're doing blood bounty

209
00:09:33,180 --> 00:09:36,120
hunting I generally break the ABS down

210
00:09:36,120 --> 00:09:39,120
into desktop apps and

211
00:09:39,120 --> 00:09:41,160
server-side apps that doesn't

212
00:09:41,160 --> 00:09:43,860
necessarily need to be a web app in most

213
00:09:43,860 --> 00:09:46,620
cases it is but we also see a lot of

214
00:09:46,620 --> 00:09:50,580
times like Network Services TCP UDP

215
00:09:50,580 --> 00:09:51,920
protocol

216
00:09:51,920 --> 00:09:56,180
services but in general those will have

217
00:09:56,180 --> 00:10:00,720
very similar attack surfaces as your

218
00:10:00,720 --> 00:10:02,940
standard web app especially in a

219
00:10:02,940 --> 00:10:05,399
Microsoft environment as we'll see here

220
00:10:05,399 --> 00:10:08,180
in a few minutes they've gone very far

221
00:10:08,180 --> 00:10:13,560
to to standardize the interface that the

222
00:10:13,560 --> 00:10:15,839
developers work with regardless of

223
00:10:15,839 --> 00:10:18,240
whether they are riding a

224
00:10:18,240 --> 00:10:23,760
net TCP app or a traditional IIs hosted

225
00:10:23,760 --> 00:10:26,279
app or a SharePoint app

226
00:10:26,279 --> 00:10:29,640
so looking at desktop apps

227
00:10:29,640 --> 00:10:34,620
one of the big benefits of dlls and in

228
00:10:34,620 --> 00:10:37,920
the net environment dlls of course still

229
00:10:37,920 --> 00:10:40,440
exist but they are referred to as

230
00:10:40,440 --> 00:10:44,519
assemblies so one of the big uses for

231
00:10:44,519 --> 00:10:48,060
desktop apps is the modularity

232
00:10:48,060 --> 00:10:51,300
for homegrown applications the whole PDF

233
00:10:51,300 --> 00:10:55,560
viewer and modification Library

234
00:10:55,560 --> 00:10:58,440
story that we talked about a minute ago

235
00:10:58,440 --> 00:11:02,579
another application for this modularity

236
00:11:02,579 --> 00:11:07,320
in desktop apps is let's say I am a

237
00:11:07,320 --> 00:11:08,399
developer

238
00:11:08,399 --> 00:11:11,160
and I work for a company who has come up

239
00:11:11,160 --> 00:11:15,300
with some whiz-bang new software

240
00:11:15,300 --> 00:11:19,800
and we have developed a core module that

241
00:11:19,800 --> 00:11:21,600
provides this capability

242
00:11:21,600 --> 00:11:24,959
and we've developed one application that

243
00:11:24,959 --> 00:11:28,440
leverages that core functionality but on

244
00:11:28,440 --> 00:11:31,860
our roadmap in our business plan we

245
00:11:31,860 --> 00:11:34,320
intend to develop a whole Suite of apps

246
00:11:34,320 --> 00:11:37,079
that use this core functionality in all

247
00:11:37,079 --> 00:11:39,000
sorts of interesting ways

248
00:11:39,000 --> 00:11:40,820
but of course we don't want to have to

249
00:11:40,820 --> 00:11:44,279
rewrite and reintegrate that core

250
00:11:44,279 --> 00:11:46,680
functionality every time we build a new

251
00:11:46,680 --> 00:11:48,660
app in our suite

252
00:11:48,660 --> 00:11:52,320
so by using this modular approach we can

253
00:11:52,320 --> 00:11:55,260
develop it one time and then

254
00:11:55,260 --> 00:11:58,019
tie it into all of our subsequent apps

255
00:11:58,019 --> 00:12:00,360
in our suite going forward

256
00:12:00,360 --> 00:12:04,380
that also plays into maintenance so as

257
00:12:04,380 --> 00:12:08,399
we grow our suite and move down the road

258
00:12:08,399 --> 00:12:10,019
map and now we have five different

259
00:12:10,019 --> 00:12:12,000
applications that leverage this

260
00:12:12,000 --> 00:12:13,320
capability

261
00:12:13,320 --> 00:12:15,300
if we need to make a change to that core

262
00:12:15,300 --> 00:12:17,760
capability we only need to make it in

263
00:12:17,760 --> 00:12:20,399
one place and then make small changes to

264
00:12:20,399 --> 00:12:23,399
the individual apps to make them

265
00:12:23,399 --> 00:12:26,220
integrate that new capability but we

266
00:12:26,220 --> 00:12:28,440
don't have to redo it five different

267
00:12:28,440 --> 00:12:30,740
times

268
00:12:30,959 --> 00:12:35,760
on the server side we see dlls and the

269
00:12:35,760 --> 00:12:39,560
assemblies are relied heavily upon in

270
00:12:39,560 --> 00:12:42,120
asp.net applications these are your

271
00:12:42,120 --> 00:12:46,440
traditional IIs hosted web apps

272
00:12:46,440 --> 00:12:49,200
and another good example that is

273
00:12:49,200 --> 00:12:52,800
SharePoint SharePoint makes super heavy

274
00:12:52,800 --> 00:12:56,700
use of of assemblies both Microsoft

275
00:12:56,700 --> 00:12:59,279
produced and in many cases third party

276
00:12:59,279 --> 00:13:02,820
produced so in addition to all the

277
00:13:02,820 --> 00:13:04,800
capabilities that SharePoint provides

278
00:13:04,800 --> 00:13:07,560
out of the box you can get add-ons from

279
00:13:07,560 --> 00:13:10,579
Microsoft there's office web services

280
00:13:10,579 --> 00:13:13,920
and then you can even build your own web

281
00:13:13,920 --> 00:13:16,740
parts that integrate directly into

282
00:13:16,740 --> 00:13:18,959
SharePoint and all these different

283
00:13:18,959 --> 00:13:21,019
components are

284
00:13:21,019 --> 00:13:24,779
compiled into dll's referenced as

285
00:13:24,779 --> 00:13:28,079
assemblies in the web server

286
00:13:28,079 --> 00:13:29,339
configuration

287
00:13:29,339 --> 00:13:31,139
and as we're going to see here in a bit

288
00:13:31,139 --> 00:13:35,160
that plays a very big role in exposing

289
00:13:35,160 --> 00:13:37,680
the capabilities of some of these dlls

290
00:13:37,680 --> 00:13:41,880
and assemblies to remote attackers

291
00:13:41,880 --> 00:13:45,420
lastly we will see third-party

292
00:13:45,420 --> 00:13:49,560
middleware vendors often will

293
00:13:49,560 --> 00:13:52,320
use the same approach for server-side

294
00:13:52,320 --> 00:13:54,899
applications that we see in the desktop

295
00:13:54,899 --> 00:13:56,959
applications and that makes sense

296
00:13:56,959 --> 00:13:59,880
basically build something one time

297
00:13:59,880 --> 00:14:02,339
license it and then you can distribute

298
00:14:02,339 --> 00:14:03,660
it to

299
00:14:03,660 --> 00:14:06,360
any number of end customers to integrate

300
00:14:06,360 --> 00:14:08,399
with their platform

301
00:14:08,399 --> 00:14:12,120
likewise the reverse is true if you are

302
00:14:12,120 --> 00:14:15,120
a middleware vendor a business a line of

303
00:14:15,120 --> 00:14:17,459
business application developer

304
00:14:17,459 --> 00:14:20,519
providing server-side software you

305
00:14:20,519 --> 00:14:22,079
likely will want to provide your

306
00:14:22,079 --> 00:14:24,000
customers with the ability to customize

307
00:14:24,000 --> 00:14:26,519
that and so a common way of doing that

308
00:14:26,519 --> 00:14:29,820
is to give your customers the ability to

309
00:14:29,820 --> 00:14:32,880
reference their own custom built

310
00:14:32,880 --> 00:14:35,399
assemblies to

311
00:14:35,399 --> 00:14:38,220
either add on to the capability of your

312
00:14:38,220 --> 00:14:40,639
middleware or

313
00:14:40,639 --> 00:14:45,120
customize the default base behavior of

314
00:14:45,120 --> 00:14:47,160
your application

315
00:14:47,160 --> 00:14:49,800
now that we have some background about

316
00:14:49,800 --> 00:14:52,740
the windows development environment the

317
00:14:52,740 --> 00:14:54,779
patterns and practices that we can

318
00:14:54,779 --> 00:14:56,940
expect our developers to be implementing

319
00:14:56,940 --> 00:14:59,579
and some of the high level technical

320
00:14:59,579 --> 00:15:03,839
aspects of the modular assemblies that

321
00:15:03,839 --> 00:15:06,360
are in place in the windows environment

322
00:15:06,360 --> 00:15:08,760
let's take a look at some of the common

323
00:15:08,760 --> 00:15:11,820
bug patterns that we will encounter and

324
00:15:11,820 --> 00:15:14,540
I think you may recognize many of these

325
00:15:14,540 --> 00:15:18,839
and it's important to realize that what

326
00:15:18,839 --> 00:15:21,240
we see with the Microsoft approach to

327
00:15:21,240 --> 00:15:24,540
modularity is really just their way of

328
00:15:24,540 --> 00:15:28,380
addressing common business needs that

329
00:15:28,380 --> 00:15:31,139
many other vendors have also addressed

330
00:15:31,139 --> 00:15:34,440
in their own ways and because these

331
00:15:34,440 --> 00:15:37,920
relate to business needs we will see

332
00:15:37,920 --> 00:15:40,680
some of the same bug patterns across

333
00:15:40,680 --> 00:15:43,620
different technological implementations

334
00:15:43,620 --> 00:15:46,800
of the same capabilities

335
00:15:46,800 --> 00:15:50,399
so one that we'll see is deprecated code

336
00:15:50,399 --> 00:15:53,880
not being removed from release builds

337
00:15:53,880 --> 00:15:57,000
and the way this usually will go down is

338
00:15:57,000 --> 00:16:01,139
let's say we let's take the example of

339
00:16:01,139 --> 00:16:03,300
the developer who has built some

340
00:16:03,300 --> 00:16:07,160
whiz-bang core application capability

341
00:16:07,160 --> 00:16:12,720
and a suite of five apps that make

342
00:16:12,720 --> 00:16:15,180
specialized use of that new

343
00:16:15,180 --> 00:16:17,040
functionality

344
00:16:17,040 --> 00:16:20,779
well let's say that four of those apps

345
00:16:20,779 --> 00:16:23,339
are done using

346
00:16:23,339 --> 00:16:26,220
some some element we've come up with a

347
00:16:26,220 --> 00:16:29,040
new way of doing something and we've

348
00:16:29,040 --> 00:16:30,839
integrated that into four of the five

349
00:16:30,839 --> 00:16:33,180
apps but the fifth app we haven't gotten

350
00:16:33,180 --> 00:16:36,060
around to it yet and so we need to

351
00:16:36,060 --> 00:16:38,339
maintain backward compatibility

352
00:16:38,339 --> 00:16:40,579
and so

353
00:16:40,579 --> 00:16:44,459
maintaining the premise of code

354
00:16:44,459 --> 00:16:47,100
reusability we don't want to have to

355
00:16:47,100 --> 00:16:51,779
maintain separate modules for one app

356
00:16:51,779 --> 00:16:55,259
versus the other four apps and so we may

357
00:16:55,259 --> 00:16:57,060
go ahead and just keep the old

358
00:16:57,060 --> 00:16:59,940
functionality in the module for the time

359
00:16:59,940 --> 00:17:01,440
being

360
00:17:01,440 --> 00:17:02,820
and

361
00:17:02,820 --> 00:17:04,740
still deploy that module with the other

362
00:17:04,740 --> 00:17:07,160
four apps we're just not referencing

363
00:17:07,160 --> 00:17:10,500
that deprecated code

364
00:17:10,500 --> 00:17:13,859
or so we think it's still there and so

365
00:17:13,859 --> 00:17:16,740
as an attacker our job is to figure out

366
00:17:16,740 --> 00:17:19,439
are there ways that we can still reach

367
00:17:19,439 --> 00:17:21,900
those deprecated code paths in the other

368
00:17:21,900 --> 00:17:24,419
four apps that the developer has not

369
00:17:24,419 --> 00:17:27,079
anticipated

370
00:17:27,179 --> 00:17:30,120
another pattern that we'll see here is

371
00:17:30,120 --> 00:17:32,340
the reverse of that new application

372
00:17:32,340 --> 00:17:34,980
functionality that has been prematurely

373
00:17:34,980 --> 00:17:37,260
included in a release build

374
00:17:37,260 --> 00:17:40,559
so expanding on the prior example

375
00:17:40,559 --> 00:17:43,620
let's say now we want to Target app

376
00:17:43,620 --> 00:17:46,200
number five the one that's on its

377
00:17:46,200 --> 00:17:49,140
Lonesome it has not yet taken advantage

378
00:17:49,140 --> 00:17:50,940
of this new capability

379
00:17:50,940 --> 00:17:54,059
but because we are sticking with one

380
00:17:54,059 --> 00:17:56,700
module one core module for our

381
00:17:56,700 --> 00:17:59,700
application and distributing it with all

382
00:17:59,700 --> 00:18:01,200
five apps

383
00:18:01,200 --> 00:18:03,840
because four of those apps do use the

384
00:18:03,840 --> 00:18:06,000
new capability obviously it needs to be

385
00:18:06,000 --> 00:18:08,820
in the module and so that gets deployed

386
00:18:08,820 --> 00:18:11,400
with app number five and even though app

387
00:18:11,400 --> 00:18:14,100
number five is not actively taking

388
00:18:14,100 --> 00:18:17,039
advantage of that capability the code is

389
00:18:17,039 --> 00:18:21,000
there and so again as as debug Bounty

390
00:18:21,000 --> 00:18:24,360
Hunter our job is to find ways to reach

391
00:18:24,360 --> 00:18:27,179
those code paths and exploit them in

392
00:18:27,179 --> 00:18:29,340
ways that the developers were not

393
00:18:29,340 --> 00:18:31,939
anticipating

394
00:18:33,840 --> 00:18:37,140
another example is inadequate

395
00:18:37,140 --> 00:18:39,720
sanitization of

396
00:18:39,720 --> 00:18:43,380
user input basically as I said many of

397
00:18:43,380 --> 00:18:46,500
these will relate to like standard web

398
00:18:46,500 --> 00:18:50,100
API vulnerabilities and you know you

399
00:18:50,100 --> 00:18:51,780
can't get away from the fact that user

400
00:18:51,780 --> 00:18:54,059
input cannot be trusted

401
00:18:54,059 --> 00:18:57,600
and it's uh become pretty commonplace

402
00:18:57,600 --> 00:19:00,720
for developers to expect malicious code

403
00:19:00,720 --> 00:19:06,480
from web requests and so we tend to see

404
00:19:06,480 --> 00:19:09,900
sanitization in most of those web apps

405
00:19:09,900 --> 00:19:12,900
however developers may be less likely to

406
00:19:12,900 --> 00:19:14,340
expect

407
00:19:14,340 --> 00:19:18,900
malicious input from endpoints or

408
00:19:18,900 --> 00:19:22,200
injection points that are not quite as

409
00:19:22,200 --> 00:19:26,400
easily accessible so your standard user

410
00:19:26,400 --> 00:19:31,620
on the on the desk is not going to

411
00:19:31,620 --> 00:19:34,260
open up dlls and expose all the

412
00:19:34,260 --> 00:19:35,760
different capabilities and start

413
00:19:35,760 --> 00:19:39,960
throwing you know oddly formatted

414
00:19:39,960 --> 00:19:42,840
object structures added just to see how

415
00:19:42,840 --> 00:19:46,260
it behaves and but as hackers that's

416
00:19:46,260 --> 00:19:48,299
exactly what we want to do it's a very

417
00:19:48,299 --> 00:19:50,580
similar process to how we might Target a

418
00:19:50,580 --> 00:19:53,120
web app but we're doing it through

419
00:19:53,120 --> 00:19:58,100
basically a different interface is all

420
00:19:59,039 --> 00:20:01,980
another book pattern that we'll see with

421
00:20:01,980 --> 00:20:04,500
the use of dlls and assemblies in

422
00:20:04,500 --> 00:20:08,160
Windows environments is naive routing of

423
00:20:08,160 --> 00:20:11,100
web app requests and we'll take a look

424
00:20:11,100 --> 00:20:14,360
at some specific examples here shortly

425
00:20:14,360 --> 00:20:17,880
but at a high level

426
00:20:17,880 --> 00:20:21,360
web request routing in a Microsoft

427
00:20:21,360 --> 00:20:23,539
environment is a bit more complicated

428
00:20:23,539 --> 00:20:28,799
than in your traditional Linux uh you

429
00:20:28,799 --> 00:20:31,340
know multi uh

430
00:20:31,340 --> 00:20:36,539
Apache environment or Tomcat or even

431
00:20:36,539 --> 00:20:38,700
um microservices

432
00:20:38,700 --> 00:20:41,700
in those environments generally there is

433
00:20:41,700 --> 00:20:45,000
a clear and relatively statically

434
00:20:45,000 --> 00:20:46,860
defined

435
00:20:46,860 --> 00:20:49,559
set of routes that your requests are

436
00:20:49,559 --> 00:20:50,580
going to take

437
00:20:50,580 --> 00:20:53,820
and you can know with a relative

438
00:20:53,820 --> 00:20:56,940
certainty that if a user provides some

439
00:20:56,940 --> 00:20:59,760
crazy endpoint that it's not going to

440
00:20:59,760 --> 00:21:03,980
reach any executable cut

441
00:21:03,980 --> 00:21:06,720
wanting one exception or the closest

442
00:21:06,720 --> 00:21:09,900
exception to this in that environment

443
00:21:09,900 --> 00:21:11,580
may be like

444
00:21:11,580 --> 00:21:13,860
let's say you know you have all your PHP

445
00:21:13,860 --> 00:21:17,700
files in the in a CGI bin folder so if

446
00:21:17,700 --> 00:21:20,520
you put a new PHP file in that folder it

447
00:21:20,520 --> 00:21:23,460
just inherently will be executable it

448
00:21:23,460 --> 00:21:25,860
could you know bring down your server

449
00:21:25,860 --> 00:21:29,340
however because you can just simply list

450
00:21:29,340 --> 00:21:31,500
the directory contents of that folder

451
00:21:31,500 --> 00:21:34,860
web server admins are more easily able

452
00:21:34,860 --> 00:21:36,419
to identify

453
00:21:36,419 --> 00:21:39,600
malicious changes and inspect those

454
00:21:39,600 --> 00:21:41,460
files themselves because they're just

455
00:21:41,460 --> 00:21:44,100
clear text there's it's scripting based

456
00:21:44,100 --> 00:21:46,320
capabilities

457
00:21:46,320 --> 00:21:50,780
in contrast with a Windows

458
00:21:50,780 --> 00:21:54,000
IIs hosted web app

459
00:21:54,000 --> 00:21:57,780
it may just reference a dll and then to

460
00:21:57,780 --> 00:21:59,940
actually understand what happens when

461
00:21:59,940 --> 00:22:02,159
that dll receives that request you

462
00:22:02,159 --> 00:22:03,539
actually have to kind of crack it open

463
00:22:03,539 --> 00:22:06,299
and dig in there and do things that many

464
00:22:06,299 --> 00:22:08,700
web server admins probably are not

465
00:22:08,700 --> 00:22:11,640
familiar with and so it's that element

466
00:22:11,640 --> 00:22:13,080
of

467
00:22:13,080 --> 00:22:17,760
that lack of visibility that introduces

468
00:22:17,760 --> 00:22:19,500
some potential vulnerabilities that

469
00:22:19,500 --> 00:22:21,780
we'll take a look at

470
00:22:21,780 --> 00:22:23,460
and

471
00:22:23,460 --> 00:22:26,299
you would be shocked the number of

472
00:22:26,299 --> 00:22:29,240
vulnerabilities I have found in Windows

473
00:22:29,240 --> 00:22:32,940
apps that include hard-coded Keys

474
00:22:32,940 --> 00:22:34,980
passwords and tokens

475
00:22:34,980 --> 00:22:37,440
and I'll throw out a couple of generic

476
00:22:37,440 --> 00:22:40,200
examples here

477
00:22:40,200 --> 00:22:43,380
and many of these are implemented in

478
00:22:43,380 --> 00:22:45,480
this modular approach so here's here's

479
00:22:45,480 --> 00:22:47,580
how it can go down let's say I'm a

480
00:22:47,580 --> 00:22:49,679
developer and let's say I'm that

481
00:22:49,679 --> 00:22:51,360
developer with my whizbang core

482
00:22:51,360 --> 00:22:53,820
functionality and my five App Suite of

483
00:22:53,820 --> 00:22:54,900
products

484
00:22:54,900 --> 00:22:57,900
let's say in this core functionality I

485
00:22:57,900 --> 00:23:01,980
have some complicated cryptographic

486
00:23:01,980 --> 00:23:05,340
operations that each of these five apps

487
00:23:05,340 --> 00:23:07,080
needs to take advantage of

488
00:23:07,080 --> 00:23:09,299
and of course I don't want to have to do

489
00:23:09,299 --> 00:23:11,039
that five times I want to write that

490
00:23:11,039 --> 00:23:13,380
difficult code one time put it in a

491
00:23:13,380 --> 00:23:15,659
module redistribute it and so on

492
00:23:15,659 --> 00:23:18,720
however let's say that even though I

493
00:23:18,720 --> 00:23:20,640
only did it one time and I spent my time

494
00:23:20,640 --> 00:23:22,260
on it I still messed it up because

495
00:23:22,260 --> 00:23:26,580
crypto is hard and I hard coded some key

496
00:23:26,580 --> 00:23:29,280
in my code

497
00:23:29,280 --> 00:23:30,659
well now

498
00:23:30,659 --> 00:23:32,580
the very fact that I'm using this

499
00:23:32,580 --> 00:23:35,100
centralized module to distribute this

500
00:23:35,100 --> 00:23:37,080
capability to all five of my apps is

501
00:23:37,080 --> 00:23:39,539
working against me because now all five

502
00:23:39,539 --> 00:23:42,080
of these apps are vulnerable to

503
00:23:42,080 --> 00:23:45,840
exploitation of the same hard-coded key

504
00:23:45,840 --> 00:23:48,120
and that opens the door to all sorts of

505
00:23:48,120 --> 00:23:49,559
possibilities

506
00:23:49,559 --> 00:23:53,340
uh maybe I'm a I'm a user of app one and

507
00:23:53,340 --> 00:23:56,700
because it shares a key with act three

508
00:23:56,700 --> 00:23:59,940
by way of this centralized module I'm

509
00:23:59,940 --> 00:24:02,460
able to access the data from some other

510
00:24:02,460 --> 00:24:04,440
user from some other company using some

511
00:24:04,440 --> 00:24:07,919
other app who has no idea who I am

512
00:24:07,919 --> 00:24:10,080
that's one example

513
00:24:10,080 --> 00:24:12,299
another that I've seen

514
00:24:12,299 --> 00:24:15,840
is it's relatively common for desktop

515
00:24:15,840 --> 00:24:19,200
apps nowadays to host small little web

516
00:24:19,200 --> 00:24:22,200
services for things like mobile app

517
00:24:22,200 --> 00:24:24,120
integration or peer-to-peer

518
00:24:24,120 --> 00:24:25,500
communication

519
00:24:25,500 --> 00:24:29,460
and so a lot of times the nature of this

520
00:24:29,460 --> 00:24:30,740
capability

521
00:24:30,740 --> 00:24:35,039
requires it to be pretty low

522
00:24:35,039 --> 00:24:37,799
low complexity the users who are

523
00:24:37,799 --> 00:24:39,720
interacting with it don't want to type

524
00:24:39,720 --> 00:24:42,059
in Long passwords or potentially don't

525
00:24:42,059 --> 00:24:44,640
want to type in any passwords and so

526
00:24:44,640 --> 00:24:47,760
that's a perfect example of where we

527
00:24:47,760 --> 00:24:51,299
might see some hard-coded passwords

528
00:24:51,299 --> 00:24:52,860
lastly

529
00:24:52,860 --> 00:24:57,299
in the.net framework environment present

530
00:24:57,299 --> 00:24:59,760
in modern Windows environments

531
00:24:59,760 --> 00:25:03,200
what we have is basically an

532
00:25:03,200 --> 00:25:06,659
object-oriented runtime environment

533
00:25:06,659 --> 00:25:11,039
and the idea is you load your dlls which

534
00:25:11,039 --> 00:25:14,940
are assemblies into the system and you

535
00:25:14,940 --> 00:25:17,700
can decide whether you want to load them

536
00:25:17,700 --> 00:25:21,419
at a system-wide level or just keep them

537
00:25:21,419 --> 00:25:23,340
semi-private

538
00:25:23,340 --> 00:25:26,220
but as you may have noticed many of the

539
00:25:26,220 --> 00:25:29,159
benefits of using this modular approach

540
00:25:29,159 --> 00:25:32,880
require you to register your assembly

541
00:25:32,880 --> 00:25:34,980
with the system so that it is available

542
00:25:34,980 --> 00:25:37,559
to any process that wants to take

543
00:25:37,559 --> 00:25:40,700
advantage of the capability

544
00:25:41,039 --> 00:25:44,779
and when it does that it's basically

545
00:25:44,779 --> 00:25:48,299
exposed through object-oriented class

546
00:25:48,299 --> 00:25:50,640
full bases

547
00:25:50,640 --> 00:25:53,580
so if I'm an app who wants to take

548
00:25:53,580 --> 00:25:55,980
advantage of the capability exposed by

549
00:25:55,980 --> 00:25:57,360
your module

550
00:25:57,360 --> 00:25:59,400
I don't need to know the name of your

551
00:25:59,400 --> 00:26:03,299
dll all I need to know is the class the

552
00:26:03,299 --> 00:26:04,320
object

553
00:26:04,320 --> 00:26:08,400
that I want and I just include that in

554
00:26:08,400 --> 00:26:10,860
my app and then windows in the.net

555
00:26:10,860 --> 00:26:12,659
framework takes care of all the

556
00:26:12,659 --> 00:26:16,140
background legwork of figuring out where

557
00:26:16,140 --> 00:26:18,779
that dll resides and loading it into

558
00:26:18,779 --> 00:26:22,520
memory and creating

559
00:26:22,520 --> 00:26:25,679
execution entry points and so on and so

560
00:26:25,679 --> 00:26:27,059
forth

561
00:26:27,059 --> 00:26:29,940
however this also introduces some

562
00:26:29,940 --> 00:26:31,860
interesting attack factors

563
00:26:31,860 --> 00:26:37,020
because similar to insecure Java object

564
00:26:37,020 --> 00:26:38,720
deserialization

565
00:26:38,720 --> 00:26:44,039
many windows apps will instantiate

566
00:26:44,039 --> 00:26:48,059
objects at runtime based on user input

567
00:26:48,059 --> 00:26:50,640
and in fact Microsoft has gone to Great

568
00:26:50,640 --> 00:26:54,299
Lengths to simplify this process for

569
00:26:54,299 --> 00:26:55,559
Developers

570
00:26:55,559 --> 00:26:58,500
the idea from Microsoft's perspective is

571
00:26:58,500 --> 00:27:00,600
they want the developers to be able to

572
00:27:00,600 --> 00:27:02,940
implement some of this standardized

573
00:27:02,940 --> 00:27:05,159
functionality like object

574
00:27:05,159 --> 00:27:06,720
deserialization

575
00:27:06,720 --> 00:27:09,240
with the minimal amount of code

576
00:27:09,240 --> 00:27:11,460
and even the minimal number of clicks

577
00:27:11,460 --> 00:27:14,700
and so when you have a framework in the

578
00:27:14,700 --> 00:27:16,620
background doing a lot of this stuff

579
00:27:16,620 --> 00:27:18,299
automatically

580
00:27:18,299 --> 00:27:21,240
it's inevitable that developers and

581
00:27:21,240 --> 00:27:23,520
server admins are not going to

582
00:27:23,520 --> 00:27:26,520
understand how it works or even when it

583
00:27:26,520 --> 00:27:28,260
is at work

584
00:27:28,260 --> 00:27:30,960
of course as bug bounty hunters that

585
00:27:30,960 --> 00:27:33,720
presents a golden opportunity for us to

586
00:27:33,720 --> 00:27:36,600
take advantage of insecure object

587
00:27:36,600 --> 00:27:39,179
deserialization let's take a look at

588
00:27:39,179 --> 00:27:42,559
some tools that let us peek inside

589
00:27:42,559 --> 00:27:46,140
windows assemblies and executables in

590
00:27:46,140 --> 00:27:49,740
a.net environment to glean some

591
00:27:49,740 --> 00:27:52,980
information and in most cases reverse it

592
00:27:52,980 --> 00:27:54,900
to human readable code

593
00:27:54,900 --> 00:27:58,679
so just to reiterate in the modern.net

594
00:27:58,679 --> 00:28:01,860
framework environment code is not

595
00:28:01,860 --> 00:28:05,940
compiled to machine code at build time

596
00:28:05,940 --> 00:28:07,980
it's compiled into an intermediate

597
00:28:07,980 --> 00:28:10,679
language that is then interpreted by

598
00:28:10,679 --> 00:28:13,559
the.net framework at runtime and then

599
00:28:13,559 --> 00:28:16,080
converted to machine code

600
00:28:16,080 --> 00:28:19,559
what that provides us as attackers is

601
00:28:19,559 --> 00:28:24,919
the ability to trivially reverse any app

602
00:28:24,919 --> 00:28:28,380
any.net app to human readable source

603
00:28:28,380 --> 00:28:29,039
code

604
00:28:29,039 --> 00:28:31,140
whenever we want and there's actually

605
00:28:31,140 --> 00:28:33,120
many tools to do this and in fact

606
00:28:33,120 --> 00:28:36,179
Microsoft themselves have produced a

607
00:28:36,179 --> 00:28:38,460
tool that is widely available it's

608
00:28:38,460 --> 00:28:41,760
called ilspy IL meaning intermediary

609
00:28:41,760 --> 00:28:45,419
language and this actually is available

610
00:28:45,419 --> 00:28:48,179
in the Microsoft store so if you're

611
00:28:48,179 --> 00:28:50,460
running Windows 10 you can just open up

612
00:28:50,460 --> 00:28:53,760
the Microsoft store type in ilspy

613
00:28:53,760 --> 00:28:56,460
it's rated 4.9

614
00:28:56,460 --> 00:29:01,500
and published by Microsoft and basically

615
00:29:01,500 --> 00:29:03,980
it's a very useful tool it lets you

616
00:29:03,980 --> 00:29:09,140
introspect into a dll or an executable

617
00:29:09,140 --> 00:29:12,720
in a Net Framework environment and not

618
00:29:12,720 --> 00:29:16,559
only see the human readable source code

619
00:29:16,559 --> 00:29:20,779
but also the references that an app has

620
00:29:20,779 --> 00:29:24,659
so it can get a little bit tricky to

621
00:29:24,659 --> 00:29:27,240
determine all the different assemblies

622
00:29:27,240 --> 00:29:30,419
that a given application uses

623
00:29:30,419 --> 00:29:32,820
especially when some of those assemblies

624
00:29:32,820 --> 00:29:34,559
are not even contained within that

625
00:29:34,559 --> 00:29:37,980
application's program files folder if

626
00:29:37,980 --> 00:29:40,380
it's registered with the system it'll be

627
00:29:40,380 --> 00:29:42,480
in what they call the global assembly

628
00:29:42,480 --> 00:29:45,360
cache the GAC and that's a system-wide

629
00:29:45,360 --> 00:29:48,899
folder so the only way that you can

630
00:29:48,899 --> 00:29:50,760
really understand all the different

631
00:29:50,760 --> 00:29:52,700
assemblies that an application

632
00:29:52,700 --> 00:29:55,740
references is to use a tool like this

633
00:29:55,740 --> 00:29:58,799
which goes through and identifies all

634
00:29:58,799 --> 00:30:02,580
the class references within that project

635
00:30:02,580 --> 00:30:05,760
and list them here for you and from

636
00:30:05,760 --> 00:30:08,520
there you can drill down and start

637
00:30:08,520 --> 00:30:10,380
finding all sorts of interesting things

638
00:30:10,380 --> 00:30:13,620
and so the way I usually use this tool

639
00:30:13,620 --> 00:30:16,559
is with an application that I don't know

640
00:30:16,559 --> 00:30:17,640
much about

641
00:30:17,640 --> 00:30:20,000
let's say it's a Windows

642
00:30:20,000 --> 00:30:23,159
executable.exe I will open it up in this

643
00:30:23,159 --> 00:30:27,860
app and it will give me basically a map

644
00:30:27,860 --> 00:30:30,419
of all the different

645
00:30:30,419 --> 00:30:32,700
assemblies that are referenced by that

646
00:30:32,700 --> 00:30:34,440
main application

647
00:30:34,440 --> 00:30:39,480
and that drives the rest of my research

648
00:30:39,480 --> 00:30:45,360
now while ilspy is a great tool and it's

649
00:30:45,360 --> 00:30:47,340
free it's from Microsoft it's well

650
00:30:47,340 --> 00:30:48,539
supported

651
00:30:48,539 --> 00:30:52,740
it does have its uh its drawbacks it's

652
00:30:52,740 --> 00:30:55,260
not the most user-friendly in terms of

653
00:30:55,260 --> 00:30:58,020
searching for things through multiple

654
00:30:58,020 --> 00:31:02,299
files and it has a somewhat outdated

655
00:31:02,299 --> 00:31:04,620
user interface

656
00:31:04,620 --> 00:31:07,140
so another tool that I will use is from

657
00:31:07,140 --> 00:31:10,260
a third-party company called jetbrains

658
00:31:10,260 --> 00:31:14,039
and the product is called dot Peak and

659
00:31:14,039 --> 00:31:16,440
this product is actually

660
00:31:16,440 --> 00:31:20,100
designed for developers and it's part of

661
00:31:20,100 --> 00:31:22,620
The Suite you can get all sorts of

662
00:31:22,620 --> 00:31:25,100
different products from jetbrains and

663
00:31:25,100 --> 00:31:27,779
most of them you have to pay for but dot

664
00:31:27,779 --> 00:31:30,240
Peak is one that they offer for free

665
00:31:30,240 --> 00:31:33,659
and it provides some of the same many of

666
00:31:33,659 --> 00:31:37,320
the same capabilities as IL spy but it

667
00:31:37,320 --> 00:31:39,480
provides some additional functionality

668
00:31:39,480 --> 00:31:42,720
and it also provides a more modern user

669
00:31:42,720 --> 00:31:45,539
interface than IL spy

670
00:31:45,539 --> 00:31:49,320
so usually I will use dot Peak for the

671
00:31:49,320 --> 00:31:52,260
actual code review that I want to

672
00:31:52,260 --> 00:31:54,899
perform so when I start to get down to

673
00:31:54,899 --> 00:31:57,059
the nitty-gritty I've identified exactly

674
00:31:57,059 --> 00:32:00,299
which assemblies I want to

675
00:32:00,299 --> 00:32:03,480
dig into I'll open them up in dot Peak

676
00:32:03,480 --> 00:32:06,020
and then go through them line by line

677
00:32:06,020 --> 00:32:09,659
and and it is with this tool that I have

678
00:32:09,659 --> 00:32:13,200
found several instances of hard-coded

679
00:32:13,200 --> 00:32:16,799
keys in a variety of different types of

680
00:32:16,799 --> 00:32:18,360
applications

681
00:32:18,360 --> 00:32:21,360
and you know

682
00:32:21,360 --> 00:32:23,100
there is the argument that you could

683
00:32:23,100 --> 00:32:26,399
just run strings on some of these apps

684
00:32:26,399 --> 00:32:28,860
and see those keys and that's true

685
00:32:28,860 --> 00:32:30,960
however

686
00:32:30,960 --> 00:32:33,360
at least in my experience I don't think

687
00:32:33,360 --> 00:32:34,919
I would have found some of the ones I

688
00:32:34,919 --> 00:32:36,840
found if I had just tried to find them

689
00:32:36,840 --> 00:32:39,799
with strings because they're random

690
00:32:39,799 --> 00:32:43,860
strings of data and when you run strings

691
00:32:43,860 --> 00:32:45,720
on a Windows app you get a whole bunch

692
00:32:45,720 --> 00:32:48,419
of nonsense some of it's you know 25

693
00:32:48,419 --> 00:32:50,580
characters it looks like a password but

694
00:32:50,580 --> 00:32:52,799
it's actually not anything

695
00:32:52,799 --> 00:32:55,380
and that can be very easily confused

696
00:32:55,380 --> 00:32:57,659
with something that looks almost exactly

697
00:32:57,659 --> 00:33:01,200
the same but is actually referenced as a

698
00:33:01,200 --> 00:33:03,179
key inside the code

699
00:33:03,179 --> 00:33:05,880
so being able to look at the actual

700
00:33:05,880 --> 00:33:08,159
source code and see

701
00:33:08,159 --> 00:33:10,679
what the code pads are can take you

702
00:33:10,679 --> 00:33:12,659
right to the place where you will be

703
00:33:12,659 --> 00:33:14,340
able to make sense have the right

704
00:33:14,340 --> 00:33:17,880
contextual data to recognize what is

705
00:33:17,880 --> 00:33:20,220
being used as a hard-coded password or

706
00:33:20,220 --> 00:33:23,940
hard-coded key and what is not so let's

707
00:33:23,940 --> 00:33:27,299
take a quick look at how I use dot peak

708
00:33:27,299 --> 00:33:30,080
in my workflow so we'll do a quick demo

709
00:33:30,080 --> 00:33:33,600
and I will walk you through highlights

710
00:33:33,600 --> 00:33:35,279
one thing that I like about dot Peak

711
00:33:35,279 --> 00:33:38,580
over IL spy is that it actually lets you

712
00:33:38,580 --> 00:33:42,899
add an entire folder to its tree here so

713
00:33:42,899 --> 00:33:44,640
let's say I'm just going to go to my

714
00:33:44,640 --> 00:33:46,580
documents and I've placed some

715
00:33:46,580 --> 00:33:50,340
executables and dlls in this level up

716
00:33:50,340 --> 00:33:53,519
exponent so I'm going to tell it to open

717
00:33:53,519 --> 00:33:55,919
that folder and it's going to identify

718
00:33:55,919 --> 00:34:00,539
all the executables in that folder

719
00:34:00,539 --> 00:34:02,460
and one thing that's very helpful is

720
00:34:02,460 --> 00:34:05,580
actually it will determine if it is

721
00:34:05,580 --> 00:34:09,599
even supported by dot Peak meaning is it

722
00:34:09,599 --> 00:34:13,440
a.net app so let's take a look here I'm

723
00:34:13,440 --> 00:34:15,540
going to go ahead and open up command

724
00:34:15,540 --> 00:34:19,399
prompt and um

725
00:34:28,199 --> 00:34:30,000
so as you can see this is what I have

726
00:34:30,000 --> 00:34:35,060
and I'm just going to run this well

727
00:34:35,639 --> 00:34:37,379
okay we're going to run this executable

728
00:34:37,379 --> 00:34:40,440
this is a little PLC Arrow it is a

729
00:34:40,440 --> 00:34:44,639
visual C plus plus compiled binary and

730
00:34:44,639 --> 00:34:47,460
executable old school and I did that on

731
00:34:47,460 --> 00:34:50,339
purpose it's a command line app

732
00:34:50,339 --> 00:34:53,099
but I did that on purpose so that we can

733
00:34:53,099 --> 00:34:56,159
see when we

734
00:34:56,159 --> 00:34:59,400
pull it up here in

735
00:34:59,400 --> 00:35:02,460
um in dot Peak it gives us basically

736
00:35:02,460 --> 00:35:05,460
some very basic information it reads the

737
00:35:05,460 --> 00:35:08,160
uh the PE header

738
00:35:08,160 --> 00:35:11,118
from the file

739
00:35:12,060 --> 00:35:14,040
but that's about it

740
00:35:14,040 --> 00:35:18,480
and what I find in in the wild is a lot

741
00:35:18,480 --> 00:35:20,400
of applications actually still do

742
00:35:20,400 --> 00:35:22,380
leverage some

743
00:35:22,380 --> 00:35:25,380
old school compiled basically they call

744
00:35:25,380 --> 00:35:29,720
it unmanaged code it's not DOT net code

745
00:35:29,720 --> 00:35:33,720
and many times it will be like some old

746
00:35:33,720 --> 00:35:36,119
third-party library that provides some

747
00:35:36,119 --> 00:35:38,460
capability that that application needs

748
00:35:38,460 --> 00:35:40,800
but hasn't been maintained by the

749
00:35:40,800 --> 00:35:43,800
original vendor and so they basically

750
00:35:43,800 --> 00:35:47,160
are carrying this Legacy code in their

751
00:35:47,160 --> 00:35:50,339
product and this will help us to find

752
00:35:50,339 --> 00:35:53,460
that and so just because dot Peak can't

753
00:35:53,460 --> 00:35:55,619
deal with it doesn't mean we can't

754
00:35:55,619 --> 00:35:57,839
Target it it just means we've got to use

755
00:35:57,839 --> 00:36:00,300
some other tools in this case I would

756
00:36:00,300 --> 00:36:03,660
use Ida Pro reverse that and

757
00:36:03,660 --> 00:36:05,760
see what I can find

758
00:36:05,760 --> 00:36:08,820
I would also go through the managed code

759
00:36:08,820 --> 00:36:11,220
the.net code the stuff that is supported

760
00:36:11,220 --> 00:36:14,040
by dot Peak and find where does it

761
00:36:14,040 --> 00:36:16,740
reference that unmanaged code and how is

762
00:36:16,740 --> 00:36:20,240
it referenced that interaction between

763
00:36:20,240 --> 00:36:23,760
manage.net code and unmanaged old-school

764
00:36:23,760 --> 00:36:27,839
compile code is a perfect Gap to find

765
00:36:27,839 --> 00:36:30,839
very impactful vulnerabilities because

766
00:36:30,839 --> 00:36:33,300
in that old school code you're going to

767
00:36:33,300 --> 00:36:36,119
find things like buffer overflows

768
00:36:36,119 --> 00:36:39,900
uh string format vulnerabilities integer

769
00:36:39,900 --> 00:36:42,119
overflows

770
00:36:42,119 --> 00:36:45,260
all sorts of good stuff

771
00:36:47,339 --> 00:36:50,940
I also put some SharePoint files in here

772
00:36:50,940 --> 00:36:52,320
I had just copied these from a

773
00:36:52,320 --> 00:36:57,260
SharePoint server to demonstrate

774
00:36:57,780 --> 00:36:59,700
so what we'll do is we'll start with

775
00:36:59,700 --> 00:37:02,700
this one so Microsoft SharePoint

776
00:37:02,700 --> 00:37:05,160
provides a basic

777
00:37:05,160 --> 00:37:06,540
search

778
00:37:06,540 --> 00:37:08,760
capability which is implemented by this

779
00:37:08,760 --> 00:37:12,180
library and so if you look at the

780
00:37:12,180 --> 00:37:14,040
configuration the web server

781
00:37:14,040 --> 00:37:15,720
configuration and a Microsoft SharePoint

782
00:37:15,720 --> 00:37:18,420
server you will see that it there's an

783
00:37:18,420 --> 00:37:21,780
endpoint a virtual directory basically

784
00:37:21,780 --> 00:37:24,960
that's mapped to an app that references

785
00:37:24,960 --> 00:37:27,839
this assembly and it references it at

786
00:37:27,839 --> 00:37:29,760
the top level Microsoft or

787
00:37:29,760 --> 00:37:32,760
sharepoint.client.search

788
00:37:33,660 --> 00:37:35,760
and that's where it stops it goes and it

789
00:37:35,760 --> 00:37:37,619
loads this assembly

790
00:37:37,619 --> 00:37:40,619
and that's important because

791
00:37:40,619 --> 00:37:43,680
from that point forward how it handles

792
00:37:43,680 --> 00:37:46,079
the request depends on

793
00:37:46,079 --> 00:37:48,900
how this dll is written

794
00:37:48,900 --> 00:37:51,140
and so as I kind of touched on earlier

795
00:37:51,140 --> 00:37:55,460
in many traditional web applications the

796
00:37:55,460 --> 00:37:58,260
endpoints exposed by the app are

797
00:37:58,260 --> 00:38:00,119
relatively static

798
00:38:00,119 --> 00:38:03,180
in a net application

799
00:38:03,180 --> 00:38:08,099
it references an assembly and then looks

800
00:38:08,099 --> 00:38:11,579
at that assembly to decide okay does the

801
00:38:11,579 --> 00:38:15,180
specific endpoint that the request has

802
00:38:15,180 --> 00:38:18,020
indicated match

803
00:38:18,020 --> 00:38:22,020
a web exposed function method or

804
00:38:22,020 --> 00:38:25,500
property in this assembly

805
00:38:25,500 --> 00:38:28,619
and so it's very Dynamic and so that

806
00:38:28,619 --> 00:38:31,800
opens up the door for let's say a

807
00:38:31,800 --> 00:38:35,099
developer copy paste some code and it

808
00:38:35,099 --> 00:38:37,680
doesn't realize that they've just copied

809
00:38:37,680 --> 00:38:40,200
a very important attribute which makes

810
00:38:40,200 --> 00:38:44,280
that method web accessible and all of a

811
00:38:44,280 --> 00:38:46,859
sudden they've now exposed some backdoor

812
00:38:46,859 --> 00:38:49,500
capability that they did not intend to

813
00:38:49,500 --> 00:38:51,780
and believe it or not I have seen this

814
00:38:51,780 --> 00:38:55,760
in several instances one very common

815
00:38:55,760 --> 00:38:57,839
instant uh

816
00:38:57,839 --> 00:39:01,500
one very common example of this is when

817
00:39:01,500 --> 00:39:04,260
an application needs to implement some

818
00:39:04,260 --> 00:39:06,240
sort of automation

819
00:39:06,240 --> 00:39:10,700
like a bulk import or bulk edit

820
00:39:10,700 --> 00:39:15,780
capability and it needs to be called by

821
00:39:15,780 --> 00:39:17,760
other

822
00:39:17,760 --> 00:39:20,640
scripts and processes and they don't

823
00:39:20,640 --> 00:39:24,060
want to like put a password in a script

824
00:39:24,060 --> 00:39:25,440
for example

825
00:39:25,440 --> 00:39:27,180
and so

826
00:39:27,180 --> 00:39:29,760
they will have the idea of okay well

827
00:39:29,760 --> 00:39:32,339
we'll just make this quote unquote

828
00:39:32,339 --> 00:39:35,960
hidden endpoint that only we know about

829
00:39:35,960 --> 00:39:39,119
and when you call it it provides you

830
00:39:39,119 --> 00:39:42,660
access that other endpoints require you

831
00:39:42,660 --> 00:39:45,119
to have authentication to access but if

832
00:39:45,119 --> 00:39:47,040
you call this specific one

833
00:39:47,040 --> 00:39:50,099
you don't have to authenticate well

834
00:39:50,099 --> 00:39:51,599
because we can go in here and look at

835
00:39:51,599 --> 00:39:54,140
the code we can trivially identify those

836
00:39:54,140 --> 00:39:58,020
now this is a SharePoint dll I have not

837
00:39:58,020 --> 00:39:59,640
found any vulnerabilities in this one

838
00:39:59,640 --> 00:40:02,760
I'm just using it as for demonstrative

839
00:40:02,760 --> 00:40:03,839
purposes

840
00:40:03,839 --> 00:40:08,880
so when you call this query

841
00:40:08,880 --> 00:40:11,839
endpoint

842
00:40:17,220 --> 00:40:19,560
I'm going to pull this up

843
00:40:19,560 --> 00:40:21,900
when you call it

844
00:40:21,900 --> 00:40:25,200
what it does is IIs actually goes in

845
00:40:25,200 --> 00:40:27,900
here opens up the assembly and it looks

846
00:40:27,900 --> 00:40:31,320
for this remote attribute

847
00:40:31,320 --> 00:40:34,920
and so this can be on methods it can

848
00:40:34,920 --> 00:40:38,099
also be on properties and so over here

849
00:40:38,099 --> 00:40:40,680
on the left hand side these little icons

850
00:40:40,680 --> 00:40:42,900
indicate these are methods these icons

851
00:40:42,900 --> 00:40:45,300
indicate their properties so what the

852
00:40:45,300 --> 00:40:46,920
properties mean

853
00:40:46,920 --> 00:40:50,160
by being remote is they have Getters and

854
00:40:50,160 --> 00:40:52,440
Setters and so basically this

855
00:40:52,440 --> 00:40:56,579
corresponds to get and post and so

856
00:40:56,579 --> 00:40:59,700
if it has this little remote

857
00:40:59,700 --> 00:41:01,260
attribute

858
00:41:01,260 --> 00:41:03,720
before that object

859
00:41:03,720 --> 00:41:07,440
or that class member is what it is then

860
00:41:07,440 --> 00:41:10,440
it also has to be public

861
00:41:10,440 --> 00:41:12,720
so these two elements right here

862
00:41:12,720 --> 00:41:13,859
together

863
00:41:13,859 --> 00:41:16,200
make

864
00:41:16,200 --> 00:41:18,180
this

865
00:41:18,180 --> 00:41:21,660
property accessible through the query

866
00:41:21,660 --> 00:41:23,460
interface

867
00:41:23,460 --> 00:41:27,180
using this code forgets this code for

868
00:41:27,180 --> 00:41:31,520
posts and

869
00:41:31,619 --> 00:41:34,859
we can go through the code and enumerate

870
00:41:34,859 --> 00:41:36,599
all the different

871
00:41:36,599 --> 00:41:38,820
ways that we can Target an application

872
00:41:38,820 --> 00:41:42,599
now this being a Microsoft app

873
00:41:42,599 --> 00:41:45,060
these are all publicly documented if you

874
00:41:45,060 --> 00:41:47,400
go to Microsoft's website if you just

875
00:41:47,400 --> 00:41:49,700
Google

876
00:41:50,040 --> 00:41:52,260
it's if you just Google Microsoft a

877
00:41:52,260 --> 00:41:53,820
SharePoint a client that search that

878
00:41:53,820 --> 00:41:56,099
query it will take you straight to a

879
00:41:56,099 --> 00:41:58,740
Microsoft website that says the

880
00:41:58,740 --> 00:42:00,780
Microsoft SharePoint client search query

881
00:42:00,780 --> 00:42:03,599
namespace and it basically provides a

882
00:42:03,599 --> 00:42:06,180
nice listing of all this stuff however

883
00:42:06,180 --> 00:42:09,359
for third-party apps and apps that

884
00:42:09,359 --> 00:42:11,940
you're going to encounter in bug bounty

885
00:42:11,940 --> 00:42:13,859
they very likely do not have that kind

886
00:42:13,859 --> 00:42:14,900
of

887
00:42:14,900 --> 00:42:18,599
documentation and so that's where this

888
00:42:18,599 --> 00:42:20,460
research can be helpful to help you find

889
00:42:20,460 --> 00:42:24,000
basically undocumented backdoor

890
00:42:24,000 --> 00:42:26,760
endpoints that provide sensitive

891
00:42:26,760 --> 00:42:30,359
capability and you had the bonus of you

892
00:42:30,359 --> 00:42:32,579
actually get to see the source code so

893
00:42:32,579 --> 00:42:35,480
not only can you identify potential

894
00:42:35,480 --> 00:42:37,980
endpoints that are undocumented you can

895
00:42:37,980 --> 00:42:41,400
see what they do when you call them

896
00:42:41,400 --> 00:42:44,520
you can't get much better than that

897
00:42:44,520 --> 00:42:47,339
one last thing I'll show or point out

898
00:42:47,339 --> 00:42:51,119
rather is this remote attribute is

899
00:42:51,119 --> 00:42:53,400
actually like a Microsoft internal

900
00:42:53,400 --> 00:42:56,160
attribute they tell developers don't use

901
00:42:56,160 --> 00:43:01,020
that but in.net environments there is a

902
00:43:01,020 --> 00:43:05,339
an equivalent and it says web method so

903
00:43:05,339 --> 00:43:09,000
basically if you open up any assembly

904
00:43:09,000 --> 00:43:11,640
that is used in an asp.net application

905
00:43:11,640 --> 00:43:15,300
you want to be looking for remote in

906
00:43:15,300 --> 00:43:19,319
Brackets or web method in Brackets and

907
00:43:19,319 --> 00:43:22,200
if you see either of those then

908
00:43:22,200 --> 00:43:26,579
odds are that member that class member

909
00:43:26,579 --> 00:43:28,619
is accessible

910
00:43:28,619 --> 00:43:30,180
through

911
00:43:30,180 --> 00:43:36,259
the API the web accessible API

912
00:43:37,800 --> 00:43:40,200
another tool that I find very useful

913
00:43:40,200 --> 00:43:43,560
when I'm doing testing of a Windows

914
00:43:43,560 --> 00:43:46,319
application is netstat

915
00:43:46,319 --> 00:43:48,900
and so as I mentioned before in many

916
00:43:48,900 --> 00:43:52,400
cases desktop client-side applications

917
00:43:52,400 --> 00:43:56,339
are opening Network Services

918
00:43:56,339 --> 00:44:00,000
for various functionality one common

919
00:44:00,000 --> 00:44:03,839
reason is mobile app integration another

920
00:44:03,839 --> 00:44:06,480
is local network peer-to-peer

921
00:44:06,480 --> 00:44:07,619
communication

922
00:44:07,619 --> 00:44:11,640
and so what I'll do is I'll run netstat

923
00:44:11,640 --> 00:44:14,760
once before I do anything with the app

924
00:44:14,760 --> 00:44:16,980
then I will launch the app

925
00:44:16,980 --> 00:44:19,260
and then you know maybe exercise the

926
00:44:19,260 --> 00:44:21,240
different capabilities of it then I'll

927
00:44:21,240 --> 00:44:23,400
run that stat again compare those

928
00:44:23,400 --> 00:44:25,380
snapshots and see if any ports are

929
00:44:25,380 --> 00:44:26,400
opened

930
00:44:26,400 --> 00:44:29,460
uh I when I run that stat in a Windows

931
00:44:29,460 --> 00:44:32,819
environment I do the dash b as in bravo

932
00:44:32,819 --> 00:44:36,000
a n is in Nancy o

933
00:44:36,000 --> 00:44:37,560
Bano

934
00:44:37,560 --> 00:44:41,579
Flags what that shows you is not only

935
00:44:41,579 --> 00:44:44,819
the ports that are open but the actual

936
00:44:44,819 --> 00:44:47,880
executable that is tied to it of course

937
00:44:47,880 --> 00:44:51,060
you need to run this as an administrator

938
00:44:51,060 --> 00:44:53,400
in an elevated command prompt

939
00:44:53,400 --> 00:44:55,980
but in many cases this will tell you

940
00:44:55,980 --> 00:44:59,280
specifically which application is

941
00:44:59,280 --> 00:45:02,220
listening on a given port and from there

942
00:45:02,220 --> 00:45:04,079
I will just run with it I'll open it up

943
00:45:04,079 --> 00:45:07,440
in dot Peak and and walk the different

944
00:45:07,440 --> 00:45:11,400
code pads and find some vulnerabilities

945
00:45:11,400 --> 00:45:13,859
well thanks for joining me today I hope

946
00:45:13,859 --> 00:45:16,740
that was helpful hopefully you got some

947
00:45:16,740 --> 00:45:19,380
new techniques that you can integrate

948
00:45:19,380 --> 00:45:22,079
into your hacker toolkit if you have any

949
00:45:22,079 --> 00:45:24,000
questions please feel free to reach out

950
00:45:24,000 --> 00:45:27,420
you can follow me on Twitter

951
00:45:27,420 --> 00:45:30,500
and happy hacking

