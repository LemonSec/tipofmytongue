1
00:00:00,120 --> 00:00:05,620
thanks everybody for having me to be
talking about Java icrc viola net

2
00:00:05,620 --> 00:00:09,340
realisation but we're not just going to
focus on that we're gonna focus on a

3
00:00:09,340 --> 00:00:13,679
variety of D serialization mechanisms
that are a job and ways that they can be

4
00:00:13,679 --> 00:00:17,840
exploited to achieve our CEO will ignore
anything that is an RCA because you know

5
00:00:17,840 --> 00:00:20,690
what's the point

6
00:00:20,690 --> 00:00:24,530
background on me the photo is there not
to terrorize your children but just for

7
00:00:24,530 --> 00:00:28,300
anybody who look at the slides offline
and wants to terrorize the children I'm

8
00:00:28,300 --> 00:00:32,349
not actually Pentastar or any kind of
security researcher I never have been I

9
00:00:32,348 --> 00:00:35,678
have no training or education or
anything in the field I'm actually a

10
00:00:35,679 --> 00:00:39,719
software engineer and my real
specialities climate forecasting my

11
00:00:39,719 --> 00:00:42,839
claim to fame is that I wrote the
aviation meteorology system for the

12
00:00:42,839 --> 00:00:46,109
southern hemisphere so if you fly
commercial airliner pretty much anywhere

13
00:00:46,109 --> 00:00:49,300
in the southern hemisphere and the pilot
comes in and tells you what the

14
00:00:49,300 --> 00:00:52,328
weather's gonna be when they land I
wrote the system that generates

15
00:00:52,329 --> 00:00:54,420
transmits those messages

16
00:00:54,420 --> 00:00:59,010
qualify me to be a security researcher
so sorry virus series of coincidences

17
00:00:59,010 --> 00:01:04,319
involving China and a stuffed walrus are
wound up leading red hats job security

18
00:01:04,319 --> 00:01:08,460
team for several years spent about five
years focusing on job security all day

19
00:01:08,460 --> 00:01:11,940
every day for the last year and a half
of actually being an engineering manager

20
00:01:11,940 --> 00:01:15,560
for software-defined networking company
funnily enough the two biggest open

21
00:01:15,560 --> 00:01:19,480
source software Defined Networking
packages open daylight no nos written in

22
00:01:19,480 --> 00:01:20,210
Java

23
00:01:20,210 --> 00:01:23,399
the skills came in handy

24
00:01:23,400 --> 00:01:28,160
outline of what we're gonna be talking
about today I won't read it out but

25
00:01:28,160 --> 00:01:31,899
we're gonna start with an explanation of
the different a serialization mechanisms

26
00:01:31,900 --> 00:01:36,460
that are available in Java dig into
various exploits for each of them then

27
00:01:36,460 --> 00:01:40,910
start to dig into some more open
research questions and then kind of some

28
00:01:40,910 --> 00:01:44,060
analysis of things that have gone last
six months issues that people have found

29
00:01:44,060 --> 00:01:52,260
so there's multiple ways that you can
serialize and deserialize use the time D

30
00:01:52,260 --> 00:01:56,860
serialization but I mean serialize and
deserialize Singh data in applications

31
00:01:56,860 --> 00:02:02,770
written in Java one of the most common
is variously realises that use XML as

32
00:02:02,770 --> 00:02:07,199
the data format unfortunately Java has
this affinity for XML which is one of

33
00:02:07,200 --> 00:02:10,530
the many horrible things about as a
programming language probably not the

34
00:02:10,530 --> 00:02:14,350
worst one of the terrible things about
the fact that has such an affinity that

35
00:02:14,350 --> 00:02:19,930
XML is the JSR the specification
libraries for XML pauses mandate that

36
00:02:19,930 --> 00:02:24,680
they must expand general and promoter
entities by default in any document they

37
00:02:24,680 --> 00:02:29,040
pass unless explicitly disabled by the
programa so basically anything that

38
00:02:29,040 --> 00:02:33,780
causes you supplied content you supply
XML content in a job app is vulnerable

39
00:02:33,780 --> 00:02:37,890
to XXII and Xe we won't dig into that
because it doesn't count as Aussie able

40
00:02:37,890 --> 00:02:43,619
to throw it over the fence but there are
various ways that you can get a seat in

41
00:02:43,620 --> 00:02:48,250
the XML serialization implementations
which will look at there's also what I

42
00:02:48,250 --> 00:02:52,350
call native serialization so this is
inbuilt to the programming languages in

43
00:02:52,350 --> 00:02:58,410
the JDK you have a binary data format
which is used and you don't require any

44
00:02:58,410 --> 00:03:01,790
external libraries or dependencies but
the some downsides to that which will

45
00:03:01,790 --> 00:03:06,640
explore then there's the the newer ship
anything new in hip in Java but the

46
00:03:06,640 --> 00:03:12,649
newer ones like cardoso and cryo and
other serialization frameworks a common

47
00:03:12,650 --> 00:03:16,530
thread here is kinda obvious don't
deserialize on trusted user-supplied

48
00:03:16,530 --> 00:03:21,590
input that's a bit of a no-brainer I
think everybody knows that but we're

49
00:03:21,590 --> 00:03:25,380
gonna dig into some details there around
particularly around native serialization

50
00:03:25,380 --> 00:03:30,010
when many people including myself
contended that that was not the case as

51
00:03:30,010 --> 00:03:33,078
the fantastic opportunity if you've ever
seen me speak before something I thought

52
00:03:33,079 --> 00:03:34,470
I was a pompous prick

53
00:03:34,470 --> 00:03:35,760
admit that I was wrong

54
00:03:35,760 --> 00:03:39,379
at the end of this presentation and I
was actually wrong about where the

55
00:03:39,379 --> 00:03:44,429
vulnerability lies in ninety
serialization but we'll start with some

56
00:03:44,430 --> 00:03:50,319
background on the XML deserialization
libraries as a standard for this Jess

57
00:03:50,319 --> 00:03:53,958
after this call Jack's b and the
reference implementation and other

58
00:03:53,959 --> 00:03:57,379
implementations of Jax be as far as I'm
aware don't have any exploitable

59
00:03:57,379 --> 00:04:01,459
vulnerabilities there's none have ever
been publicly reported I've had a fairly

60
00:04:01,459 --> 00:04:05,359
good look at haven't found any so would
a spot close to the side that widely

61
00:04:05,359 --> 00:04:11,019
used they are there are other libraries
that are widely used in a variety of

62
00:04:11,019 --> 00:04:16,608
contexts one of the most common context
is XML REST API frameworks because jobs

63
00:04:16,608 --> 00:04:20,459
got all these building blocks of HTTP
communications library and you've got an

64
00:04:20,459 --> 00:04:24,440
XML parsing library of an XML
serialization library on top of that was

65
00:04:24,440 --> 00:04:28,320
glued them all together with some
abstract transformer being factories and

66
00:04:28,320 --> 00:04:37,400
you've got a REST API framework so so
that's a common usage and two of the the

67
00:04:37,400 --> 00:04:43,479
Xmas realization that commonly used to
XML Dakota and Xtreme now the really

68
00:04:43,479 --> 00:04:46,630
important caveat here which is gonna
have implications later on in the

69
00:04:46,630 --> 00:04:53,590
presentation these XML serialization
libraries don't rely on a unified

70
00:04:53,590 --> 00:04:59,280
implemented by classes job as native
serialization library says that it will

71
00:04:59,280 --> 00:05:03,859
only serialize and deserialize a class
if it implements a special marker

72
00:05:03,860 --> 00:05:09,130
interface called serializable one of the
advantages and disadvantages of XML

73
00:05:09,130 --> 00:05:12,300
libraries is they don't care about this
they will serialize and deserialize

74
00:05:12,300 --> 00:05:16,449
anything you tell them to which is one
of the reasons why people use them

75
00:05:17,510 --> 00:05:22,219
the first one is just a terrible design
it needs to be taken out behind the shed

76
00:05:22,220 --> 00:05:27,820
and put out of its misery there is no
redeeming quality of XML Dakota the idea

77
00:05:27,820 --> 00:05:33,700
is that you give it an XML document that
describes a series of method calls the

78
00:05:33,700 --> 00:05:39,060
result of which will deconstruct will
reconstruct sorry the object and the end

79
00:05:39,060 --> 00:05:44,330
thats d serializing it so if you take a
look at the example here this is an XML

80
00:05:44,330 --> 00:05:50,710
snippet or XML document that's a XML
Dakota format serialized object and what

81
00:05:50,710 --> 00:05:54,969
you tell it to do is say I'm not
instantiate an object that's called the

82
00:05:54,970 --> 00:05:59,180
solve this type of the groovy shell type
and then you say so while you're

83
00:05:59,180 --> 00:06:03,310
instantiating that by the way could you
please run its evaluate method with the

84
00:06:03,310 --> 00:06:07,380
following arguments and it will just
execute that code as part of D

85
00:06:07,380 --> 00:06:11,310
serializing you can literally just embed
code in there and all executed as part

86
00:06:11,310 --> 00:06:12,860
of Dec realizing it

87
00:06:12,860 --> 00:06:17,930
anything that actually uses XML Dakota
to deserialize arbitrary you supplied

88
00:06:17,930 --> 00:06:24,730
content is by default vulnerable to
Aussie so these are all live demos by

89
00:06:24,730 --> 00:06:27,370
the way so that probably gonna go wrong

90
00:06:27,370 --> 00:06:30,370
try

91
00:06:35,220 --> 00:06:38,450
is that text big enough to make a little
bit bigger people to see

92
00:06:44,930 --> 00:06:50,560
ok so does this might work better for
this particular context

93
00:06:55,249 --> 00:07:02,569
so have a look here we have a very
simple restless application and a readme

94
00:07:02,569 --> 00:07:08,959
file that makes exploitation simple but
we've got a vulnerable version of the

95
00:07:08,959 --> 00:07:12,799
restaurant jobs that were using to
compile it and just vote simplify to

96
00:07:12,799 --> 00:07:16,258
make it simple to use the same example
as we did earlier we've also got groovy

97
00:07:16,259 --> 00:07:19,549
on the classpath so that you can
instantiate the groovy shell class

98
00:07:19,549 --> 00:07:22,339
that's actually just for convenience
that you don't need that you can use

99
00:07:22,339 --> 00:07:26,319
process builder anything in the JDK
that's not a necessary condition for

100
00:07:26,319 --> 00:07:32,999
exploitation that's just making it easy
so i'm happy to show these exploits by

101
00:07:32,999 --> 00:07:37,549
the way if anybody wants some so then we
just we've compiled it we just run a

102
00:07:37,549 --> 00:07:41,589
server application here which is just
pointing at a steady pace of a report I

103
00:07:41,589 --> 00:07:54,209
wanted to step is actually necessary so
then we just get this one bigger too

104
00:07:56,760 --> 00:08:02,710
gonna run this command and we were just
making a call to this wrestler

105
00:08:02,710 --> 00:08:07,419
application we're passing in customer
are seeded XML as the the body of the

106
00:08:07,420 --> 00:08:13,650
post and what you see as we pop up
events that's my tax return to see that

107
00:08:13,650 --> 00:08:18,719
so instead of popping Kalka like to pop
even to this is a tribute to Mike

108
00:08:18,720 --> 00:08:22,580
Schoenfeld the guy who taught me job
security before he sold his soul and run

109
00:08:22,580 --> 00:08:25,880
away to work for Oracle was always in
all of his reproduces you always pop

110
00:08:25,880 --> 00:08:32,030
even so I was trying to that so if we
take a look in customer Aussie dollar

111
00:08:32,030 --> 00:08:36,679
XML it's exactly what we saw in the
slides there it's just this XML document

112
00:08:36,679 --> 00:08:40,890
substantiating the groovy shell telling
it to execute evince an upbeat pops

113
00:08:40,890 --> 00:08:45,230
Misuzu possible to arrest endpoint
that's bound to use XML Dakota to

114
00:08:45,230 --> 00:08:49,700
deserialize the content to execute the
code simple

115
00:08:54,900 --> 00:08:57,900
gonna go back and start on me

116
00:09:03,139 --> 00:09:07,600
oK so that's that's XML Dakota and it's
just fundamentally insecure so when I

117
00:09:07,600 --> 00:09:11,069
reported that the rest let rest
framework which is arrest framework that

118
00:09:11,069 --> 00:09:14,910
allows you to plug in arbitrary
serialize and deserialize as you can use

119
00:09:14,910 --> 00:09:18,170
binary serialization you could use
external decoder you can use extreme

120
00:09:18,170 --> 00:09:22,339
whenever you want it's just a utility
knife and explain this to me and they

121
00:09:22,339 --> 00:09:27,739
responded by just removing support for
XML Dakota from the framework that's why

122
00:09:27,739 --> 00:09:31,809
I said no no redeeming qualities extreme
on the other hand does have redeeming

123
00:09:31,809 --> 00:09:34,759
qualities and is used all over the place

124
00:09:34,759 --> 00:09:40,569
spring OXM owner type Nexus ie what's
used to run the canonical Maven Central

125
00:09:40,569 --> 00:09:44,699
repose so you can see where this is
going yes Maven Central was vulnerable

126
00:09:44,699 --> 00:09:51,829
to an authenticator last year's jenkins
et cetera all use extreme to process

127
00:09:51,829 --> 00:09:57,719
under $5 dated you supplied input in
various contexts so if there's a way

128
00:09:57,720 --> 00:10:02,149
that Xtreme can be leveraged to achieve
Aussie a wide range of applications of

129
00:10:02,149 --> 00:10:06,980
vulnerable now one of the cool things
about Xtreme is that it does reflection

130
00:10:06,980 --> 00:10:11,199
based serialization and this is
necessary to support some of the funky

131
00:10:11,199 --> 00:10:15,118
features in Java like dynamic proxies so
there's a little diagram hit you

132
00:10:15,119 --> 00:10:18,679
probably can't see because of the res
that explains what a dynamic proxy is

133
00:10:18,679 --> 00:10:23,589
basically the idea is you have an
interface and then normally you have an

134
00:10:23,589 --> 00:10:28,829
object that directly implements that
interface so when you get the comparable

135
00:10:28,829 --> 00:10:32,959
interface has the compared to method in
it and whatever object implements the

136
00:10:32,959 --> 00:10:36,069
comparable interface has an
implementation of compared to then gets

137
00:10:36,069 --> 00:10:38,009
executed when you run it right

138
00:10:38,009 --> 00:10:41,679
a proxy is where you set up this kind of
facade class where you say yeah I mean

139
00:10:41,679 --> 00:10:46,850
implement the I Comparable interface or
sorry mix up with the comparable in the

140
00:10:46,850 --> 00:10:54,539
face and then and then whenever one of
those members of that interfaces called

141
00:10:54,539 --> 00:11:00,589
I'm going to proxy that call to some
other class i mean that through and do

142
00:11:00,589 --> 00:11:03,589
something else as a result which we'll
get to in a minute

143
00:11:05,649 --> 00:11:12,990
one attacker can do to exploit this this
issue in extreme is provide I serialize

144
00:11:12,990 --> 00:11:17,600
representation of a dynamic proxy class
which implements an interface that the

145
00:11:17,600 --> 00:11:21,949
application might expect now is a cool
trick to this because what you gotta do

146
00:11:21,949 --> 00:11:27,969
is give it AC realized object that's
going to ultimately execute RCE when

147
00:11:27,970 --> 00:11:31,610
some method is called and you've got a
force it to call that method no matter

148
00:11:31,610 --> 00:11:37,339
what so what you do is you see realized
that reset which is a sordid set so all

149
00:11:37,339 --> 00:11:41,769
the members of tree set implement the
comparable in the face and when a tree

150
00:11:41,769 --> 00:11:46,920
said is Dec realized its members need to
be sorted by executing their compared to

151
00:11:46,920 --> 00:11:52,479
method so you give a damn tree set with
a just a strange element in it just for

152
00:11:52,480 --> 00:11:57,689
funsies and in the second element is a
dynamic proxy which uses this invocation

153
00:11:57,689 --> 00:12:02,279
handler called event handler so the
invocation handler is the piece that

154
00:12:02,279 --> 00:12:06,850
says whenever I'm implementing this
interface called comparable whenever any

155
00:12:06,850 --> 00:12:09,920
of the methods on that is called the
matter what their method signature is

156
00:12:09,920 --> 00:12:14,259
with his arguments arguments that is for
the floor I am going to do the following

157
00:12:14,259 --> 00:12:17,589
things in response to that event I'm
gonna do the following thing and in this

158
00:12:17,589 --> 00:12:23,559
case it's constructive process builder
object of events started as soon as the

159
00:12:23,559 --> 00:12:28,980
server receives this she realized XML
snippet deserialize it it compares the

160
00:12:28,980 --> 00:12:33,699
comparable objects in the tree set
comparing the proxy one causes even

161
00:12:33,699 --> 00:12:36,790
still be executed

162
00:12:36,790 --> 00:12:45,120
where could you exploit this for example
Jenkins Jenkins XML API uses Xtreme to

163
00:12:45,120 --> 00:12:48,140
serialize input one of the reasons that
it does so is for this kind of support

164
00:12:48,140 --> 00:12:53,580
of dynamic proxies useful it's actually
you have to squint a little bit to call

165
00:12:53,580 --> 00:12:57,020
is a critical issue in Jenkins because
if you've got Jenkins configured in such

166
00:12:57,020 --> 00:13:00,020
a way that you can hit its XML API

167
00:13:00,600 --> 00:13:05,440
ninety-something percent chance that you
could also just spin up a job should

168
00:13:05,440 --> 00:13:09,130
speed up a job in Jenkins the job is
arbitrary code so you have to have very

169
00:13:09,130 --> 00:13:12,750
specific configuration Jenkins were you
allow people to do certain things in the

170
00:13:12,750 --> 00:13:17,390
XML API but not to create jobs which is
a non standard configuration for the

171
00:13:17,390 --> 00:13:20,870
majority of of deployments are not be
affected but some would say it's

172
00:13:20,870 --> 00:13:24,790
legitimate conflict so let's give you a
live demo that

173
00:13:36,980 --> 00:13:44,320
now cheated on actually already running
Jenkins locally as it takes a little bit

174
00:13:44,320 --> 00:13:51,829
to set up verify that yes I am and if
you have a look at this shell script

175
00:13:51,829 --> 00:13:56,319
that I've got three simple it's just
gonna use coal to make a post to the

176
00:13:56,320 --> 00:14:00,019
Jenkins and point the crowd item
endpoint and then if you take a look at

177
00:14:00,019 --> 00:14:04,209
the document that it's using their input
XML it's very similar to what we saw

178
00:14:04,209 --> 00:14:08,268
earlier instead of having a tree set
you've got a Hudson top-level item which

179
00:14:08,269 --> 00:14:14,480
is which is a similar item that will be
there will be sorted and the same kind

180
00:14:14,480 --> 00:14:22,220
of approach applies here on it even scan
of my screen you can have to take my

181
00:14:22,220 --> 00:14:24,199
word for there it is

182
00:14:24,199 --> 00:14:30,540
evens so that's a simple explanation of
how you can get similar kind of issue in

183
00:14:30,540 --> 00:14:36,889
Jenkins but there's a whole bunch of
other vectors hear anything that's

184
00:14:36,889 --> 00:14:42,079
taking untrusted you supplied content
feeding into Xtreme was potentially

185
00:14:42,079 --> 00:14:46,430
still is vulnerable to this issue now
the way that it was fixed upstream was

186
00:14:46,430 --> 00:14:51,219
by introducing a whitelist and blacklist
and all of the anything that was going

187
00:14:51,220 --> 00:14:57,529
to use this special proxy handler code
dynamic proxy converter was was blocked

188
00:14:57,529 --> 00:15:02,480
by the fault so that's a pretty good
solution in extreme but they took a

189
00:15:02,480 --> 00:15:09,459
while to do it it took them quite some
time to write a patch and get it through

190
00:15:09,459 --> 00:15:13,709
their CI process and we're like this is
critical hello in the interim several

191
00:15:13,709 --> 00:15:17,989
downstream such as Jenkins and also saw
on a type produce their own patches

192
00:15:17,990 --> 00:15:22,130
because Senate at Nexus does the same
thing so there was a period of time at

193
00:15:22,130 --> 00:15:26,439
which Maven Central was exposing this
and so if you can get our senior Maven

194
00:15:26,440 --> 00:15:30,920
Central you can pollute any canonical
jar you want and pollute any app in the

195
00:15:30,920 --> 00:15:37,099
Java ecosystem it's kind of bad back in
2014 I wrote a blog post about this

196
00:15:37,100 --> 00:15:38,120
which is still relevant

197
00:15:38,120 --> 00:15:41,120
there really hasn't been much change the
state of the art since then

198
00:15:44,060 --> 00:15:49,459
ok so that much is mostly background
it's useful information will come back

199
00:15:49,460 --> 00:15:53,040
to it in a minute but I just wanted to
give you that background before we dive

200
00:15:53,040 --> 00:15:54,719
into native

201
00:15:54,720 --> 00:15:58,990
realization of binary disorganization
calling upon the serialization because

202
00:15:58,990 --> 00:16:03,780
it has a binary data format now the
interesting thing about this I I think

203
00:16:03,780 --> 00:16:07,870
fundamentally it doesn't have a terrible
design it makes a lot of sense the way

204
00:16:07,870 --> 00:16:11,000
that that it's implemented and doesn't
have any inherent security

205
00:16:11,000 --> 00:16:15,360
vulnerabilities but the entry point for
security vulnerabilities is the fact

206
00:16:15,360 --> 00:16:20,630
that when you implement the Serializable
interface there are two optional methods

207
00:16:20,630 --> 00:16:23,760
to implement you can just leave it
inherited a fault whatever it doesn't

208
00:16:23,760 --> 00:16:29,480
know or you can implement your own
version we'd resolve comes before read

209
00:16:29,480 --> 00:16:33,650
object because the somewhat cases where
you need to do some things at one point

210
00:16:33,650 --> 00:16:37,470
of the deserialization standardization
other things afterwards I don't

211
00:16:37,470 --> 00:16:42,970
understand that either but anyway if any
class that's on the Java classpath

212
00:16:42,970 --> 00:16:49,630
implements Serializable interface and it
has some code in these read objects a

213
00:16:49,630 --> 00:16:56,200
real object or read resolve methods that
expose some kind of vulnerability then

214
00:16:56,200 --> 00:17:01,150
attackers could trigger it by passing in
C realized instances of those classes so

215
00:17:01,150 --> 00:17:04,690
these two conditions that have to be met
here the first is that an attacker has

216
00:17:04,690 --> 00:17:08,570
to be able to provide arbitrary
serialize content and the second is that

217
00:17:08,569 --> 00:17:12,450
has to be something vulnerable in the
classpath let's start with the first bit

218
00:17:12,450 --> 00:17:20,160
how can an attacker provide content have
a decir realized that there's a range of

219
00:17:20,160 --> 00:17:24,780
ways in which you can use REST API
frameworks like like restless they

220
00:17:24,780 --> 00:17:29,389
actually allow you to use binary
serialization format as the basis for

221
00:17:29,390 --> 00:17:33,680
REST API which is kinda stupid because
of tightly coupled that Java but some

222
00:17:33,680 --> 00:17:34,580
people have done it

223
00:17:34,580 --> 00:17:38,720
other Java communication mechanisms like
Jackson arm I also use it

224
00:17:39,250 --> 00:17:42,890
which again is tightly coupled the Jabba
but those are much more widely deployed

225
00:17:43,790 --> 00:17:48,500
now this is how I first became exposed
to this whole category vulnerability to

226
00:17:48,500 --> 00:17:51,950
call out to Kashi Terada as far as I
know it doesn't really speak english is

227
00:17:51,950 --> 00:17:56,140
never spoken at a security conference I
can't find a picture of him anywhere he

228
00:17:56,140 --> 00:18:00,360
is the most prolific job security
research in the world hands down

229
00:18:01,110 --> 00:18:06,370
absolutely hands down go check out his
research and it's amazing so I got an

230
00:18:06,370 --> 00:18:10,760
email in early 2013 to secular at
redhat.com which was entirely in

231
00:18:10,760 --> 00:18:15,879
Japanese and we had a a policy if you
sent us an email that was not in English

232
00:18:15,880 --> 00:18:19,950
we would not reply because 99% of the
time it was spam or you know we just

233
00:18:19,950 --> 00:18:26,370
couldn't deal with that so so not but I
was looking at a Japanese and then

234
00:18:26,370 --> 00:18:30,979
there's all these Roman character things
in their roads like us

235
00:18:30,980 --> 00:18:38,500
JBoss serialization code executive like
you know what turns out at the Red Hat

236
00:18:38,500 --> 00:18:41,940
Brisbane office by coincidence we had
the documentation translation team there

237
00:18:41,940 --> 00:18:46,070
with i three or four native Japanese
speakers so I went down to the lunchroom

238
00:18:46,070 --> 00:18:50,939
was like hey I got some spare time can
you can you translate this for me into

239
00:18:50,940 --> 00:18:55,800
English and they did that still didn't
make a lot of sense what we had was this

240
00:18:55,800 --> 00:19:01,240
woody proven was that the RichFaces
frameworks in MVC framework for web

241
00:19:01,240 --> 00:19:06,060
applications was using the binary
serialization format to handle state

242
00:19:06,060 --> 00:19:08,720
synchronization so you know how you can
have my client side state and

243
00:19:08,720 --> 00:19:12,450
server-side State University realized
ringtone to match them up though doing

244
00:19:12,450 --> 00:19:16,540
that with with this binary serialization
format that much we figured out pretty

245
00:19:16,540 --> 00:19:21,220
quickly and we thought okay that's
potentially a problem but then he's got

246
00:19:21,220 --> 00:19:25,270
this magic serialized object that has
provided he hasn't told us how we

247
00:19:25,270 --> 00:19:28,750
generated that see realized object but
instead of at least magic's realized

248
00:19:28,750 --> 00:19:33,000
object we could reproduce if you feed
that is the view state into rich faces

249
00:19:33,000 --> 00:19:38,340
at you get us we couldn't figure out how
to get to that in a minute as tough as

250
00:19:38,340 --> 00:19:44,850
to how it actually works so let's do a
proof of concept where I'm actually

251
00:19:44,850 --> 00:19:48,649
going to write the vulnerable class just
to demonstrate how this kind of thing

252
00:19:48,650 --> 00:19:51,650
would work

253
00:20:03,890 --> 00:20:11,800
got this sort of sample application and
what we've got is customer

254
00:20:11,800 --> 00:20:18,360
Joba is a very very simple classic we
set up this customer I got this out of

255
00:20:18,360 --> 00:20:22,729
my I pull this out of a unit test that
was in restless and the guy wrote its

256
00:20:22,730 --> 00:20:26,950
French sensors on the pond something I
can't pronounce it correctly and his

257
00:20:26,950 --> 00:20:34,080
defense and and so you've got this
customer and then we've got a real

258
00:20:34,080 --> 00:20:38,639
object implementation he writes
implements Serializable it has a manual

259
00:20:38,640 --> 00:20:42,920
implementation of the real object method
and in that it sets the name field to be

260
00:20:42,920 --> 00:20:49,140
bad so what we're gonna demonstrated in
this proof of concept is not any

261
00:20:49,140 --> 00:20:53,120
crossing anti-trust boundary is just
when used serialize an instance of this

262
00:20:53,120 --> 00:20:59,229
object with the name is on the point you
deserialize it and it's too bad that

263
00:20:59,230 --> 00:21:02,230
comes out the other side

264
00:21:04,130 --> 00:21:08,790
we've got two versions of the wrestler
job that will illustrate this so the

265
00:21:08,790 --> 00:21:15,139
first one is restless

266
00:21:15,140 --> 00:21:18,140
toward job

267
00:21:40,100 --> 00:21:43,809
persisted

268
00:21:45,460 --> 00:21:48,460
got another one

269
00:21:50,500 --> 00:21:53,560
is what I get for doing live demos
people

270
00:21:58,090 --> 00:22:03,990
yeah I might have to put aboard on this
one that's going to Java C

271
00:22:21,080 --> 00:22:31,320
yes Joba so then was gonna run a client

272
00:22:41,610 --> 00:22:46,159
here's what we see when we deserialize
the object out the other side the name

273
00:22:46,160 --> 00:22:52,650
is drawn bad and the code or postal this
on github but if the client is literally

274
00:22:52,650 --> 00:22:56,770
just making making a call into that I
nothing fancy their chances to

275
00:22:56,770 --> 00:22:59,770
demonstrate the issue

276
00:23:08,379 --> 00:23:11,769
the question then becomes what kind of
issue could actually exist in these

277
00:23:11,769 --> 00:23:14,389
methods that would be slightly more
interesting than that and actually get

278
00:23:14,389 --> 00:23:21,719
you ask for the first example of his
game in 2011 anybody wanna help me with

279
00:23:21,720 --> 00:23:25,690
the pronunciation of this Belgian
gentleman's name I've never had any clue

280
00:23:25,690 --> 00:23:32,240
what the correct pronunciation is now ok
well richard is and he found this

281
00:23:32,240 --> 00:23:35,240
invocation handling in Spring AOP

282
00:23:36,070 --> 00:23:39,350
the really interesting thing is I talked
about event handler in the context of

283
00:23:39,350 --> 00:23:44,219
the Xtreme exploits right now he said
the event handler invocation handler

284
00:23:44,220 --> 00:23:48,490
would allow you to specify the methods
are you could process build arbitrary

285
00:23:48,490 --> 00:23:55,269
code that would be run when any method
the the interface that you're acting as

286
00:23:55,269 --> 00:23:59,369
a proxy for is executed you don't have
to map it to the correct method is a

287
00:23:59,369 --> 00:24:04,360
method is called this code gets executed
but event handle it does not implement

288
00:24:04,360 --> 00:24:10,059
the Serializable interface so it's only
useful for those XML libraries for the

289
00:24:10,059 --> 00:24:12,840
native deserialization library it
doesn't work because it's not

290
00:24:12,840 --> 00:24:17,769
serializable but he found a similar case
in Spring AOP where they was a

291
00:24:17,769 --> 00:24:22,009
serializable invocation handle of that
was that was exposed and a very similar

292
00:24:22,009 --> 00:24:26,529
exploit could be put together was
actually quite a bit more convoluted to

293
00:24:26,529 --> 00:24:33,070
set up the sea realized object graph for
this one has got a really good writeup

294
00:24:33,070 --> 00:24:36,860
because the original author never
actually published an exploit publicly

295
00:24:36,860 --> 00:24:42,719
and so I figured it out and brought it
up and we'll see this exploit used later

296
00:24:42,720 --> 00:24:46,909
on in the presentation that was the
first time of research is pretty

297
00:24:46,909 --> 00:24:51,309
extensively that such an issue was ever
reported at the time there was actually

298
00:24:51,309 --> 00:24:55,830
quite some resistance to assigning it a
CD I D Mark Thomas who's the security

299
00:24:55,830 --> 00:24:58,999
lead for Spring Security lead for the
Apache Software Foundation in the lead

300
00:24:58,999 --> 00:25:04,360
developer tom cat and my arch nemesis
decided that this was not a

301
00:25:04,360 --> 00:25:05,639
vulnerability in spring

302
00:25:05,639 --> 00:25:09,309
this was a vulnerability in whatever
application was D serializing arbitrary

303
00:25:09,309 --> 00:25:11,120
use supplied content

304
00:25:11,120 --> 00:25:17,610
but we'll get to that argument in more
detail sent back to you to Radha and the

305
00:25:17,610 --> 00:25:25,179
mysterious Japanese report what we
eventually figured out after 24 hours

306
00:25:25,180 --> 00:25:30,630
and too much coffee in the precise dose
of whiskey was that the exploit was

307
00:25:30,630 --> 00:25:38,110
actually exploiting a poison so there is
a class in the Commons FileUpload

308
00:25:38,110 --> 00:25:45,159
library which is a common that's used to
handle file uploads oddly enough and it

309
00:25:45,160 --> 00:25:48,050
has a classical disqualified him which
is exactly what it sounds like it's a

310
00:25:48,050 --> 00:25:52,770
representation in memory of a file on
disk so when you deserialize

311
00:25:52,770 --> 00:25:57,450
disqualified him it implements read
object method which actually recreate

312
00:25:57,450 --> 00:26:01,309
the file on disk but of course it
doesn't let you specify the absolute

313
00:26:01,309 --> 00:26:06,059
path to that file that would be
completely insecure a private member of

314
00:26:06,059 --> 00:26:11,399
the class private variable in the class
specifies the temp but the temp file

315
00:26:11,400 --> 00:26:17,660
name is generated by Cody serialization
time so that the attack are provided but

316
00:26:17,660 --> 00:26:22,960
what we found was that the temp could
get a point and no bite at the end of it

317
00:26:22,960 --> 00:26:27,750
and the rest would be truncated when
generating that file URL so you could

318
00:26:27,750 --> 00:26:33,270
just say / paths / to / elder JSP and
then make the body of the files show JSP

319
00:26:33,270 --> 00:26:38,500
and you could uploaded to the server by
having a deserialize it so this raises

320
00:26:38,500 --> 00:26:43,030
the really interesting question how can
you have a poison no but flaw in Java

321
00:26:43,030 --> 00:26:47,178
rap and would love to know if anybody
has any theories as to how that is

322
00:26:47,179 --> 00:26:50,260
possible

323
00:26:50,260 --> 00:26:55,780
ok so Javed has managed memory it did
you know so it doesn't interpret

324
00:26:55,780 --> 00:27:00,129
annulled by as the end of a string it
just interprets it as a Unicode

325
00:27:00,130 --> 00:27:04,390
character but it turns out that actually
the Navy of implementation that it's

326
00:27:04,390 --> 00:27:10,410
ultimately calling in the JDK itself the
C code in the JDK was vulnerable to a

327
00:27:10,410 --> 00:27:16,310
poison pill or so in newer versions of
the JDK I think it's 749 and 18 above

328
00:27:16,310 --> 00:27:21,270
are all patched but if you had a
vulnerable JDK and a vulnerable Commons

329
00:27:21,270 --> 00:27:25,550
FileUpload job on the classpath and an
application that was deserialization

330
00:27:25,550 --> 00:27:30,280
arbitron trusted user input you had
complete hace by virtue of being able to

331
00:27:30,280 --> 00:27:37,180
upload a shell so that could be done for
example using the rest let framework or

332
00:27:37,180 --> 00:27:43,280
any of the other vectors that we just
described how do you solve this kind of

333
00:27:43,280 --> 00:27:47,040
problem or solution of one is obviously
don't to serialize on trusted content

334
00:27:47,040 --> 00:27:51,310
but they're all these cases where you
want to do so and then the second is

335
00:27:51,310 --> 00:27:54,450
what are introduced flaws in real object
andrade resolving this is where I was

336
00:27:54,450 --> 00:27:59,560
wrong cuz I really held on to this point
said well today as of 2013 we had two of

337
00:27:59,560 --> 00:28:03,480
these vulnerabilities and both of them
were kinda stupid issues in the code

338
00:28:03,480 --> 00:28:07,230
that never should have been there to my
contention was that the serialization

339
00:28:07,230 --> 00:28:10,770
design is actually good we just need to
eliminate all the vulnerabilities in the

340
00:28:10,770 --> 00:28:15,490
libraries but thought solution is to do
type checking with look ahead to see

341
00:28:15,490 --> 00:28:19,300
realization or not so serial these
various frameworks for this now the

342
00:28:19,300 --> 00:28:22,430
issue there is that if you try and type
check something after you've

343
00:28:22,430 --> 00:28:25,950
decentralized to check if it's on a
whitelist you've already disorganized

344
00:28:25,950 --> 00:28:30,010
and potentially had a sea of people have
develop mechanisms where you can peek

345
00:28:30,010 --> 00:28:33,910
into the binary data stream determine
the actual type determine if its

346
00:28:33,910 --> 00:28:38,750
implementing a dynamic proxy or not and
then no whitelist or blacklisted before

347
00:28:38,750 --> 00:28:41,450
you decide realize it

348
00:28:41,450 --> 00:28:49,679
the next little research I started doing
was looking at this object mapper called

349
00:28:49,679 --> 00:28:55,380
Daza and dozer is is kind of a type
mapping tools used in any enterprise

350
00:28:55,380 --> 00:29:00,370
integration software will have the
excess demand the Y system and they will

351
00:29:00,370 --> 00:29:04,039
have different objects that represent a
similar thing and you're gonna do a

352
00:29:04,039 --> 00:29:10,519
mapping you might have one airline
system that refers to seat count and

353
00:29:10,519 --> 00:29:13,809
another one that refers to passenger
count and when you are transferred you

354
00:29:13,809 --> 00:29:18,279
know your objects from one to the other
one of us have an XML file that says a

355
00:29:18,279 --> 00:29:22,220
passenger count on that system means
seat count on that system or something

356
00:29:22,220 --> 00:29:27,789
like that and so and so then you can
just dynamically transform objects from

357
00:29:27,789 --> 00:29:33,750
one to the other and it's doing this
using the binary serialization mechanism

358
00:29:33,750 --> 00:29:40,440
so if you can set up the right
conditions you could actually use this

359
00:29:40,440 --> 00:29:45,070
to exploit a similar issue and I went
down this kind of rabbit hole here

360
00:29:45,070 --> 00:29:49,428
because I sort of got lost as they all
got this great 0 day in dozer if only I

361
00:29:49,429 --> 00:29:53,600
can find a class thats serializable

362
00:29:53,600 --> 00:29:56,908
event handlers not and in meets all of
those conditions that we said earlier

363
00:29:56,909 --> 00:30:02,539
that no matter what method is called on
the interface that you implement because

364
00:30:02,539 --> 00:30:06,340
you can't really influence that you get
your arbitrary code called you don't

365
00:30:06,340 --> 00:30:11,908
have to line up to some other condition
in the code after the serialization to

366
00:30:11,909 --> 00:30:15,659
execute a method that happens to map to
a method in interface that you can

367
00:30:15,659 --> 00:30:20,350
pretend to implement with a proxy that's
too hard but in the end what I was

368
00:30:20,350 --> 00:30:24,730
looking for was another universal
invocation handle of vector that could

369
00:30:24,730 --> 00:30:31,990
be used here and I went right back to
his original exploit and said we know

370
00:30:31,990 --> 00:30:36,380
that could could quite possibly be used
to demonstrate this issue and in fact it

371
00:30:36,380 --> 00:30:38,179
did demonstrate this issue

372
00:30:38,179 --> 00:30:44,600
I took of arrows implementation of that
exploit ordered it to to work with those

373
00:30:44,600 --> 00:30:50,279
are and then in the end was able to to
achieve our C so that I will also give

374
00:30:50,279 --> 00:30:53,279
you a demo

375
00:31:05,980 --> 00:31:10,799
put it all into a shell scripts a run
and then I'll talk through everything

376
00:31:10,799 --> 00:31:13,799
that's being done here

377
00:31:17,530 --> 00:31:20,139
ok

378
00:31:20,140 --> 00:31:23,140
if you take a loss

379
00:31:27,690 --> 00:31:33,269
what I do is I create two classes one
that's called the doc soon enough

380
00:31:33,269 --> 00:31:38,899
anybody I have two of them a really long
and then they have a length property and

381
00:31:38,899 --> 00:31:46,989
then you have a corgi which is kind of
fat and so it's gotta gotta with

382
00:31:46,990 --> 00:31:49,990
property and then you set up a

383
00:32:05,779 --> 00:32:10,849
you set up an application that and this
is the instantiation of the object graph

384
00:32:10,849 --> 00:32:15,090
to exploit that spring issue which I'm
not going to talk through its gonna take

385
00:32:15,090 --> 00:32:21,459
all day long but we set up a dozer be
mapping which which maps and says when

386
00:32:21,460 --> 00:32:25,700
you're converting a corgi object into a
dachshund object you take its with

387
00:32:25,700 --> 00:32:29,580
property and you turn it into the
dachshunds length property we then

388
00:32:29,580 --> 00:32:35,899
instantiate this complex payload that
pretends to be a corgi and then when you

389
00:32:35,899 --> 00:32:41,149
finally get its with in order to his
28th the long dog objects and you map it

390
00:32:41,149 --> 00:32:45,570
from the Corgi to the document that
change it's called and you papi events

391
00:32:45,570 --> 00:32:51,739
as a result so yeah this code is already
on github distribute links on on Twitter

392
00:32:51,739 --> 00:32:57,389
at the end but take too long to talk to
her but that's the issue but anyway

393
00:32:57,389 --> 00:33:01,139
there's nothing really new under the Sun
there that's just sayin using this is

394
00:33:01,139 --> 00:33:07,139
another factor to utilize another know
and vulnerability in a serializable

395
00:33:07,139 --> 00:33:13,168
class and other vulnerable invocation
handle all the ones that we saw so far

396
00:33:13,169 --> 00:33:18,299
Commons FileUpload spring is a pretty
common libraries 10 20 30 percent of job

397
00:33:18,299 --> 00:33:21,889
cuts would be using them what if you
could get a vulnerable invocation

398
00:33:21,889 --> 00:33:27,418
handling in the JDK itself then you have
100% guarantee that any application

399
00:33:27,419 --> 00:33:28,159
that's

400
00:33:28,159 --> 00:33:32,289
realizing you supplied content is
vulnerable in Java seven and eight were

401
00:33:32,289 --> 00:33:36,599
the predominant versions there are three
invocation handle is out of an event

402
00:33:36,599 --> 00:33:41,039
handler one of them is called the
competent . invocation handler I was

403
00:33:41,039 --> 00:33:43,908
just forwards get a method that's
completely useless scrubbed it off the

404
00:33:43,909 --> 00:33:47,030
list immediately

405
00:33:47,030 --> 00:33:51,820
the two other ones are potentially
exploitable under certain conditions but

406
00:33:51,820 --> 00:33:56,210
those conditions are so circuitous that
I never bothered kind of reporting this

407
00:33:56,210 --> 00:34:00,240
so here is this is this is basically
zero day here but just bad terrible 02

408
00:34:00,240 --> 00:34:06,820
so the MBean server implication handler
is a proxy to an MBean or manage data

409
00:34:06,820 --> 00:34:11,360
management is deployed object in a job
application server container and a lot

410
00:34:11,360 --> 00:34:14,880
of these job application server
containers have indians deployed by

411
00:34:14,880 --> 00:34:20,400
default the two nasty things like deploy
war files or upload files or delete you

412
00:34:20,400 --> 00:34:25,409
know deployed payloads are so on so step
one you have an exploitable M being

413
00:34:25,409 --> 00:34:29,800
deployed highly likely few looking like
a JBoss WebLogic Server or something

414
00:34:30,370 --> 00:34:34,710
step to you have to specify the correct
JMX URL to get to that

415
00:34:34,710 --> 00:34:40,470
Mb now a lot of the times a JMX oval
actually be bound to localhost onto you

416
00:34:40,469 --> 00:34:44,480
know look back on port 1099 which in and
of itself is under ability but it's

417
00:34:44,480 --> 00:34:48,490
often there in which case you can easily
construct that URL if you don't have

418
00:34:48,489 --> 00:34:53,219
that you can get to it you can construct
a URL using the Java processor speed and

419
00:34:53,219 --> 00:34:56,589
so you could just brute force all
possible bids to get process IDs to get

420
00:34:56,590 --> 00:34:59,260
there that's not so bad

421
00:34:59,260 --> 00:35:03,090
those conditions are annoying but that
would be a cool exploit if it worked in

422
00:35:03,090 --> 00:35:08,330
and of itself the problem here is that
the MBean server invocation handler does

423
00:35:08,330 --> 00:35:12,920
not allow you to say hi I'm going to
create a proxy object that implements

424
00:35:12,920 --> 00:35:18,890
comparable and then when you know
compared to is called any method on that

425
00:35:18,890 --> 00:35:25,160
is called execute my code it says when
method called ABC with arguments of type

426
00:35:25,160 --> 00:35:31,629
X and type why I called then it will
proxy through to that in being with you

427
00:35:31,630 --> 00:35:35,190
know the exact same method named the
exact same method arguments so unless

428
00:35:35,190 --> 00:35:39,100
you can somehow line the thought that
you know off the tee serialization it's

429
00:35:39,100 --> 00:35:44,110
going to make a call to a method
signature on some interface that also

430
00:35:44,110 --> 00:35:48,250
happens to map to the exact same method
signature on an exploitable embankments

431
00:35:48,250 --> 00:35:51,250
deployed

432
00:35:53,850 --> 00:35:58,259
and then remote object invocation
handler is basically the same thing it's

433
00:35:58,260 --> 00:36:04,410
firearm I but has the exact same problem
it's actually easier to to exploit but

434
00:36:04,410 --> 00:36:10,129
again you don't have that ability to say
go for any arbitrary method call to

435
00:36:10,130 --> 00:36:16,040
check on execution so that's kind of
where I stop looking at this for a while

436
00:36:16,040 --> 00:36:20,810
and thought oh well you know maybe
that's as far as we get and then a bunch

437
00:36:20,810 --> 00:36:25,400
of people went further with this towards
the end of last year made a lot of

438
00:36:25,400 --> 00:36:30,220
progress and when you think of that it's
obvious kicking myself and I didn't

439
00:36:30,220 --> 00:36:33,459
realize I was looking for was this like

440
00:36:34,150 --> 00:36:38,250
event handler Sony it's wonderful class
all you need is to be out of serializing

441
00:36:38,250 --> 00:36:42,810
event handler and does all the work for
you really want you need to be added to

442
00:36:42,810 --> 00:36:48,180
serialize an object graph to somewhere
the entry point to that object graph is

443
00:36:48,180 --> 00:36:52,680
a serializable class and then you need
but that object graph can be as deep as

444
00:36:52,680 --> 00:36:57,319
you want we can contain as many subjects
as you want as the spring one does if

445
00:36:57,320 --> 00:37:01,890
you until you finally get to an exit
point that gets URC and this is very

446
00:37:01,890 --> 00:37:06,080
similar to rock training it's properly
oriented programs that are being used

447
00:37:06,080 --> 00:37:09,799
and stuff funds in the room shouts to
him figuring this out in PHP T

448
00:37:09,800 --> 00:37:16,660
serialization before anybody did in Java
Chris for a half hour I'll put together

449
00:37:16,660 --> 00:37:20,379
this fantastic work here which we should
all take a look at it upset Cali where

450
00:37:20,380 --> 00:37:24,720
they they drew the south and they said
you know drawing the analogy to rock

451
00:37:24,720 --> 00:37:29,080
they said these are gadgets these object
graphs that can be that can be exploited

452
00:37:29,080 --> 00:37:36,569
properly oriented programming gadgets so
they found a really cool running Commons

453
00:37:36,570 --> 00:37:40,940
collection Commons collection is really
common is used in pretty much each other

454
00:37:40,940 --> 00:37:44,270
up so this is fantastic

455
00:37:44,270 --> 00:37:48,470
is the patch that sort of Applied now
but it's not properly patch because of

456
00:37:48,470 --> 00:37:51,680
the Apache Software Foundation's
assertion that this is actually a

457
00:37:51,680 --> 00:37:54,950
vulnerability in the deserialization
happen

458
00:37:54,950 --> 00:38:02,180
but they reported for different gadgets
chains that use comments collection and

459
00:38:02,180 --> 00:38:07,160
they also reported to gadget change that
use the groovy shell jobs so at this

460
00:38:07,160 --> 00:38:10,940
point I sort of said you know drop them
I can walk off the stage as a yes how

461
00:38:10,940 --> 00:38:14,579
many other gadgets chains can you find
it's pointless at this point the

462
00:38:14,579 --> 00:38:20,460
vulnerability is if you are deserialize
display content eventually there's gonna

463
00:38:20,460 --> 00:38:23,460
be some kind of gadgets China's
exploitable

464
00:38:24,220 --> 00:38:28,810
security pick this up and said yes all
you need is those input vectors his

465
00:38:28,810 --> 00:38:32,740
input vectors in JBoss WebSphere Jenkins
WebLogic Jenkins once they stole from me

466
00:38:32,740 --> 00:38:43,220
and also stop at this point everybody
that's it

467
00:38:43,220 --> 00:38:47,750
if UD serializing content in job done so
what do we do about it

468
00:38:48,440 --> 00:38:52,920
the dow who put together that I'm
properly oriented programming research

469
00:38:52,920 --> 00:38:56,710
put together a talk with washer cereal
which does two things it did provide

470
00:38:56,710 --> 00:39:01,210
some tools that help you find gadget
chains but it also aggregates them into

471
00:39:01,210 --> 00:39:08,079
exploitable payloads said I think 6071
get up as a defense I mean obviously the

472
00:39:08,079 --> 00:39:12,800
defense's to re- architecture apt to not
use this but for brownfield deployment

473
00:39:12,800 --> 00:39:18,190
so to speak that's not really an option
so one option is the serialization tools

474
00:39:18,190 --> 00:39:22,609
that allow you to type validation before
you trigger an exploitable condition the

475
00:39:22,609 --> 00:39:26,598
several of these now this bundling to
earlier from parents that IBM which is

476
00:39:26,599 --> 00:39:30,930
sort of the canonical work on it but
that was more like a tutorial page and

477
00:39:30,930 --> 00:39:34,839
now not so cereal and serial killer have
come along and implemented frameworks

478
00:39:34,839 --> 00:39:39,078
that do this for you and in particular
the serial killer framework can do it at

479
00:39:39,079 --> 00:39:43,010
runtime you don't necessarily have to
re-write any code in your app was added

480
00:39:43,010 --> 00:39:46,680
to the classpath add some configuration
parameters and it does it run time for

481
00:39:46,680 --> 00:39:47,879
you

482
00:39:47,880 --> 00:39:52,240
future research will more gadgets Modi
serialization vectors I think the Holy

483
00:39:52,240 --> 00:39:56,069
Grail here is a gadget that's entirely
constrained to the JDK because then

484
00:39:56,069 --> 00:39:59,970
you've got no other conditions to be met
every out by definition has the JDK

485
00:39:59,970 --> 00:40:09,730
there was wrong when I was at Red Hot I
had to say and I already so I had the

486
00:40:09,730 --> 00:40:15,670
wonderful ability to assign my own CBA's
which often did so to pick fights with

487
00:40:15,670 --> 00:40:19,119
people and in this case I get to pick a
fight with Mark Thomas from Apache

488
00:40:19,119 --> 00:40:23,890
Software Foundation he wouldn't sign a
CVA for the discrete issues so I did and

489
00:40:23,890 --> 00:40:28,259
i got very angry and I wrote this
official Red Hat blog post is still

490
00:40:28,259 --> 00:40:28,980
there

491
00:40:28,980 --> 00:40:32,630
stating that Red House official position
is that the vulnerability lies both in

492
00:40:32,630 --> 00:40:38,339
the vulnerable class and in the ED
serializing up so I retract my position

493
00:40:38,339 --> 00:40:41,750
I believe that tweet sums it up

494
00:40:46,109 --> 00:40:49,109
any questions

495
00:41:00,170 --> 00:41:01,720
must have been perfect then thank you
very much

