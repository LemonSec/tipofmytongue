1
00:00:00,280 --> 00:00:03,209
welcome everybody good morning while
show

2
00:00:03,209 --> 00:00:06,420
shisha and talked about attacking

3
00:00:06,420 --> 00:00:10,860
a be softer I will attack them from a
different perspective and I will talk

4
00:00:10,860 --> 00:00:15,169
about the taking a be best practices are
the book represent your

5
00:00:15,169 --> 00:00:18,990
as trying to work with the awesome
people at UC Irvine's the problem Tyler

6
00:00:18,990 --> 00:00:20,580
Perry Larson Stephen Crane

7
00:00:20,580 --> 00:00:23,790
Michael fronts and Richard Bartel from

8
00:00:23,790 --> 00:00:27,840
Manion arm if you look at the picture on
this

9
00:00:27,840 --> 00:00:31,060
on his first slide how similar our does
bucks the DC

10
00:00:31,060 --> 00:00:34,060
Rd how many different

11
00:00:34,060 --> 00:00:37,600
families back families DC actually

12
00:00:37,600 --> 00:00:41,079
all those books are the same underlying
back

13
00:00:41,079 --> 00:00:44,260
their chests small genetic variations

14
00:00:44,260 --> 00:00:48,100
are in the codes in the DNA of the book
that lead sir

15
00:00:48,100 --> 00:00:52,260
very different a very different look up
to use dis bucks

16
00:00:52,260 --> 00:00:56,570
and that's exactly what what's happening
is melberg are few families out there

17
00:00:56,570 --> 00:00:59,570
and attackers use manual diverse
application

18
00:00:59,570 --> 00:01:03,530
to have a different forms of detection
and common solution

19
00:01:03,530 --> 00:01:07,810
for Melbourne depictions still rely on
signatures in similarity metrics

20
00:01:07,810 --> 00:01:11,060
and in this talk will see that those
metrics

21
00:01:11,060 --> 00:01:15,090
ants practices are no longer effective
so

22
00:01:15,090 --> 00:01:20,770
the Melbourne landscapers is changing
how many different now for families do

23
00:01:20,770 --> 00:01:22,040
you guys know out there

24
00:01:22,040 --> 00:01:28,110
5 10 how many of those are actually
active at a at a specific point in time

25
00:01:28,110 --> 00:01:31,270
there only very few male her family's

26
00:01:31,270 --> 00:01:34,360
active at anything a point in time and
it's like a big

27
00:01:34,360 --> 00:01:38,659
monoculture out out there and um on the
other hand

28
00:01:38,659 --> 00:01:43,259
there are sour since of variants that
hipster

29
00:01:43,259 --> 00:01:48,119
arm the Melbourne feeds off anti-virus
companies everything always

30
00:01:48,119 --> 00:01:53,600
so all a by companies are actually
overrun by lots and lots of samples

31
00:01:53,600 --> 00:01:57,619
and attackers use different forms of
Packers to hide the actual code

32
00:01:57,619 --> 00:02:01,750
and manually diverse if I to sample was
just a little bit so they can get

33
00:02:01,750 --> 00:02:06,500
biter a anti-virus engine and on the
other hand

34
00:02:06,500 --> 00:02:11,220
it's all about the money right attackers
generate new samples defenders classics

35
00:02:11,220 --> 00:02:12,330
by those samples

36
00:02:12,330 --> 00:02:16,340
and it's just an endless loop the keeps
going and going and usually

37
00:02:16,340 --> 00:02:21,520
as the system is right now attackers are
already at actually can use

38
00:02:21,520 --> 00:02:24,720
very low res a real amount of resources

39
00:02:24,720 --> 00:02:28,680
to generate a lot of reported 80
companies and

40
00:02:28,680 --> 00:02:31,810
I'll argue that is resources that the 80
companies spend

41
00:02:31,810 --> 00:02:35,540
should better be spent for something
else so for example

42
00:02:35,540 --> 00:02:40,099
research it would actually solve the
problem or better security practices

43
00:02:40,099 --> 00:02:44,040
like you seen in the gonna talk before
so

44
00:02:44,040 --> 00:02:47,440
the Melber

45
00:02:47,440 --> 00:02:50,989
distribution is like an ongoing now
ongoing

46
00:02:50,989 --> 00:02:54,760
arms race between attackers and
defenders and it always starts

47
00:02:54,760 --> 00:02:58,810
whereas and you now for instance that is
generated by

48
00:02:58,810 --> 00:03:03,269
by an attacker and it continues the
attacker will distribute and send it out

49
00:03:03,269 --> 00:03:06,700
an attack a bunch of targets continue
move along

50
00:03:06,700 --> 00:03:11,739
and just spread them out as fast as it
goes at one point in time in AB bender

51
00:03:11,739 --> 00:03:15,660
book at the first sample using one of
those feats and distributed to all the

52
00:03:15,660 --> 00:03:16,930
other AB vendors

53
00:03:16,930 --> 00:03:21,980
it might take up to months or years
until they have time to actually

54
00:03:21,980 --> 00:03:23,370
analyzed at sample

55
00:03:23,370 --> 00:03:27,860
and they will do first some automatic
and then some manual analysis of the

56
00:03:27,860 --> 00:03:29,860
tumbling classified at one point in time

57
00:03:29,860 --> 00:03:33,440
then they will update their signatures
send it out

58
00:03:33,440 --> 00:03:36,750
and as soon as the sample is detected by
a bunch of

59
00:03:36,750 --> 00:03:41,400
are a bunch of EV engines detector both
read a verse if I and send out the new

60
00:03:41,400 --> 00:03:42,040
sample

61
00:03:42,040 --> 00:03:46,319
and the game continues its like endless
fun right so

62
00:03:46,319 --> 00:03:49,349
unfortunately defenders are always

63
00:03:49,349 --> 00:03:53,629
in her empty limit its first of all

64
00:03:53,629 --> 00:03:57,269
newly diversified samples are just not
detected by the

65
00:03:57,269 --> 00:04:01,150
I did techniques that are used in
current systems and every time an

66
00:04:01,150 --> 00:04:02,680
attacker read oversee fis

67
00:04:02,680 --> 00:04:06,230
it's basically an you attack and

68
00:04:06,230 --> 00:04:09,590
you have to start the whole up have
touched

69
00:04:09,590 --> 00:04:13,959
have to start the whole spiel again and
just redo it from scratch

70
00:04:13,959 --> 00:04:17,309
also the attacker is has a specific at

71
00:04:17,309 --> 00:04:22,180
you my lover spreads very very fast
updating signatures and distributing

72
00:04:22,180 --> 00:04:26,689
might have worked in the early nineties
but nowadays many can infect

73
00:04:26,689 --> 00:04:29,930
all the computers there on the internet
in the matter of

74
00:04:29,930 --> 00:04:33,819
minutes or hours it just doesn't work
anymore

75
00:04:33,819 --> 00:04:37,499
you need to find other ways to hear are
to protect

76
00:04:37,499 --> 00:04:41,009
up and the defenders usually have to
fight the time lag

77
00:04:41,009 --> 00:04:44,050
between the analysis and yup they did
signatures which

78
00:04:44,050 --> 00:04:47,129
takes a huge amount of time in between

79
00:04:47,129 --> 00:04:50,150
now to question s can we

80
00:04:50,150 --> 00:04:53,339
automate this process AB and

81
00:04:53,339 --> 00:04:57,749
AB vendors notice or have known this for
quite a while now

82
00:04:57,749 --> 00:05:01,339
but you're still locked into these old
practices

83
00:05:01,339 --> 00:05:05,999
just don't want to move along now the
question is from the attacker side

84
00:05:05,999 --> 00:05:10,499
can meet give an additional ensure even
and a higher adds to the attacker

85
00:05:10,499 --> 00:05:13,619
and yes we can so

86
00:05:13,619 --> 00:05:17,069
the core idea is that

87
00:05:17,069 --> 00:05:20,939
the compiler is at the core of and
efficient automation

88
00:05:20,939 --> 00:05:24,610
and we can use a different compiler
techniques to

89
00:05:24,610 --> 00:05:28,889
enable a faster and more sorrow
diversification of in vidor binaries and

90
00:05:28,889 --> 00:05:29,469
then

91
00:05:29,469 --> 00:05:32,729
attacked the system's you in foster

92
00:05:32,729 --> 00:05:37,259
arm in this talk and introducing fully
automatic diversity from elber

93
00:05:37,259 --> 00:05:40,779
and it's basically an additional attack
that sparse

94
00:05:40,779 --> 00:05:45,809
are any similarity based matching and it
should drive the point home that

95
00:05:45,809 --> 00:05:49,949
similarity-based matching is not the
solution it's time to move along

96
00:05:49,949 --> 00:05:53,800
and gets get on better security
practices

97
00:05:53,800 --> 00:05:57,919
arm I'm inherently lazy so I don't want
to

98
00:05:57,919 --> 00:06:03,499
are don't want to run a lot of love code
and a lot of manual work to produce

99
00:06:03,499 --> 00:06:06,710
my huge set of male refineries so I'll

100
00:06:06,710 --> 00:06:11,960
just do some automation right and a
compiler is the perfect place for that

101
00:06:11,960 --> 00:06:15,080
so if you have to source code of a
specific

102
00:06:15,080 --> 00:06:19,520
application we can run it through the
compiler and it usually generates

103
00:06:19,520 --> 00:06:23,580
one single instance of Melber and the
current practices that

104
00:06:23,580 --> 00:06:27,960
attackers used ok the generate the
binary and then run Packers on top of it

105
00:06:27,960 --> 00:06:30,110
to generate individual samples

106
00:06:30,110 --> 00:06:33,159
these Packers are very limited because
it just worked under

107
00:06:33,159 --> 00:06:37,929
on the actual machine coat and the
compiler or regular compiler

108
00:06:37,929 --> 00:06:42,389
always produce the same binary but
you're adding a different achche

109
00:06:42,389 --> 00:06:46,679
you're heading a randomization component
in the compiler and using some flexible

110
00:06:46,679 --> 00:06:50,039
flexibility in the language to produce a
different that

111
00:06:50,039 --> 00:06:54,249
of Melbourne every time you're under
compiler and I will go into more detail

112
00:06:54,249 --> 00:06:57,249
later on in the talk but that's
basically the

113
00:06:57,249 --> 00:07:01,849
overview of to keep that your use so its
compiler base diversification

114
00:07:01,849 --> 00:07:05,649
burn lots of information is available
and you can run a lot of fun stuff on

115
00:07:05,649 --> 00:07:07,289
top of it

116
00:07:07,289 --> 00:07:10,659
so the outline of the talk is as
follows: first

117
00:07:10,659 --> 00:07:14,349
people discuss the state of the art of
Melbourne detection what is actually out

118
00:07:14,349 --> 00:07:16,369
there what is used by the current
machines

119
00:07:16,369 --> 00:07:20,569
then we will introduce now the
diversification is the new threat

120
00:07:20,569 --> 00:07:24,199
an indent quickly talk about some
possible mitigation strategies

121
00:07:24,199 --> 00:07:28,110
or better security practices that could
work on top of that

122
00:07:28,110 --> 00:07:31,990
so what is the state of the art
technology texan

123
00:07:31,990 --> 00:07:35,399
how to be fined now there and how to be
fine teas

124
00:07:35,399 --> 00:07:38,559
ardizzone both its so

125
00:07:38,559 --> 00:07:41,849
we have to know that melberg detection

126
00:07:41,849 --> 00:07:45,059
is inherently limited in three ways:

127
00:07:45,059 --> 00:07:50,110
first the fall performance and AB engine
should not slow down your computer too

128
00:07:50,110 --> 00:07:50,819
much

129
00:07:50,819 --> 00:07:54,479
so it is only a very limited amount of
resources that you can spend

130
00:07:54,479 --> 00:07:59,169
on detecting or 22 see if something is
actually my older or not

131
00:07:59,169 --> 00:08:03,099
on an individual computer second

132
00:08:03,099 --> 00:08:07,099
now for scanning as always limited you
to the precision it he can get

133
00:08:07,099 --> 00:08:11,849
arm based on the similarity metric or
detective Nick picnics

134
00:08:11,849 --> 00:08:14,889
you always run into false positives and
false negatives

135
00:08:14,889 --> 00:08:18,020
false negatives and whole buncha errors
in

136
00:08:18,020 --> 00:08:21,309
it's it's just a pain also

137
00:08:21,309 --> 00:08:25,369
%uh latency as the about the cert
limitation

138
00:08:25,369 --> 00:08:29,429
there's always a very long time lag as
we've seen in the inner circle before

139
00:08:29,429 --> 00:08:33,079
between the initial spratt of another
sample

140
00:08:33,079 --> 00:08:38,699
and the time that actual users machines
are protected from from that Alber

141
00:08:38,699 --> 00:08:42,829
so you look into the three different
ways of

142
00:08:42,829 --> 00:08:46,339
detection mechanisms first the ball

143
00:08:46,339 --> 00:08:50,440
the all this detection mechanism is
signature-based

144
00:08:50,440 --> 00:08:53,790
server using a simple signature to
compare it and if you're wondering by

145
00:08:53,790 --> 00:08:54,420
the way that's

146
00:08:54,420 --> 00:08:58,100
George W signature up there the second
one

147
00:08:58,100 --> 00:09:01,480
is static analysis so you're running
some

148
00:09:01,480 --> 00:09:06,170
analysis on top of the the binary but
you're not executing it

149
00:09:06,170 --> 00:09:09,519
and the third one as some behavioral
based matching

150
00:09:09,519 --> 00:09:13,290
are you running the the binary leader in
a in a sandbox are some other

151
00:09:13,290 --> 00:09:17,699
analysis scheme in public for to extract
additional information out of it

152
00:09:17,699 --> 00:09:21,209
and each of these approaches has its
pros and cons

153
00:09:21,209 --> 00:09:24,589
and we'll look into more detail a little
bit of each have one

154
00:09:24,589 --> 00:09:28,839
first the fall signature-based detection
which is the bread and butter technique

155
00:09:28,839 --> 00:09:29,949
for AV

156
00:09:29,949 --> 00:09:34,589
and it has a lot of advantages to be
honest um

157
00:09:34,589 --> 00:09:37,670
its it is very fast and very

158
00:09:37,670 --> 00:09:42,459
are very ball known in a lot and yet yes
that you compare

159
00:09:42,459 --> 00:09:45,790
the binary against the database known
bad samples

160
00:09:45,790 --> 00:09:49,690
so you have to match a pattern according
like there different kinds of similarity

161
00:09:49,690 --> 00:09:52,970
metrics that they have different
substrings regular expressions or

162
00:09:52,970 --> 00:09:53,930
anything else

163
00:09:53,930 --> 00:09:57,949
but yet you're basically is that you
have a big database of known bad

164
00:09:57,949 --> 00:09:58,730
examples

165
00:09:58,730 --> 00:10:02,199
and your matching the current sample
that you're analyzing against a set of

166
00:10:02,199 --> 00:10:06,629
known bad once

167
00:10:06,629 --> 00:10:11,639
and atlantis's art at it's very very
fast

168
00:10:11,639 --> 00:10:15,470
and it has a very low false positive
rate if you're a little bit clever about

169
00:10:15,470 --> 00:10:17,269
how the encoder signatures

170
00:10:17,269 --> 00:10:21,279
you will have a pretty good match
unfortunately

171
00:10:21,279 --> 00:10:25,910
arm the position is limited to known bad
samples

172
00:10:25,910 --> 00:10:31,310
and are it takes time to to update the
signatures and to spread it and

173
00:10:31,310 --> 00:10:35,430
are there's there's the big latency most

174
00:10:35,430 --> 00:10:39,910
the second analysis technique is static
a binary analysis are setting analysis

175
00:10:39,910 --> 00:10:41,160
based detection

176
00:10:41,160 --> 00:10:44,519
and you search for potentially bad
patterns and

177
00:10:44,519 --> 00:10:48,439
it like API call system calls and it's
like a lot of her sticks that are run on

178
00:10:48,439 --> 00:10:49,459
top of that

179
00:10:49,459 --> 00:10:53,240
arm and you're trying to detect those
statistics on top of it

180
00:10:53,240 --> 00:10:57,939
are defined as its low overhead you can
just run the binary analysis and expect

181
00:10:57,939 --> 00:10:58,199
that

182
00:10:58,199 --> 00:11:02,430
each I calls and then decide if it's
good or bad according to two specific or

183
00:11:02,430 --> 00:11:03,660
not up

184
00:11:03,660 --> 00:11:08,290
a specific score unfortunately you
introduce false positives

185
00:11:08,290 --> 00:11:12,250
along with that technique and there
depending on the

186
00:11:12,250 --> 00:11:17,610
on how precise her stickers it can
actually be quiets quite bad

187
00:11:17,610 --> 00:11:21,089
and also it's based on Bell known her
istics if you're a Melbourne writer you

188
00:11:21,089 --> 00:11:21,860
can try to end

189
00:11:21,860 --> 00:11:25,829
you Bates those respects and and get
around it

190
00:11:25,829 --> 00:11:29,310
and finally behavior-based detection

191
00:11:29,310 --> 00:11:32,720
up which executes a file in some form
and later a virtual machine or or

192
00:11:32,720 --> 00:11:33,870
something like that

193
00:11:33,870 --> 00:11:37,990
arm and detects possible that
modifications on top of it

194
00:11:37,990 --> 00:11:41,639
it's the most precise if

195
00:11:41,639 --> 00:11:45,610
the are if the molar does not tried to
evade detection

196
00:11:45,610 --> 00:11:48,800
ordered the activated emulation or

197
00:11:48,800 --> 00:11:52,560
there some other kind of bug involved
but unfortunately it comes is very high

198
00:11:52,560 --> 00:11:53,620
overhead and

199
00:11:53,620 --> 00:11:58,240
usually you cannot spend that much of of
time on a user's machine to detect that

200
00:11:58,240 --> 00:12:00,310
for every single sample

201
00:12:00,310 --> 00:12:03,550
so to summarize now for protection a

202
00:12:03,550 --> 00:12:06,620
summarize the current practices Miller
detection

203
00:12:06,620 --> 00:12:09,670
there's a large attack surface it's very
hard

204
00:12:09,670 --> 00:12:13,389
to tact and all there's basically an

205
00:12:13,389 --> 00:12:16,959
arms race between manual labor
certification and the actual

206
00:12:16,959 --> 00:12:21,610
AB engines and the signature-based
detection techniques are similar to beat

207
00:12:21,610 --> 00:12:22,399
detection me

208
00:12:22,399 --> 00:12:25,660
techniques already lose precision or

209
00:12:25,660 --> 00:12:29,689
effectiveness against that the mental
diversification

210
00:12:29,689 --> 00:12:34,170
also the defenders have to cope with
very limited amount of resources

211
00:12:34,170 --> 00:12:38,410
for the fall on a target machine up
forty and all others in the lab and to

212
00:12:38,410 --> 00:12:41,519
push out new signatures a small

213
00:12:41,519 --> 00:12:44,779
and there's no perfect solution out
there you girl you'll have false

214
00:12:44,779 --> 00:12:45,490
positives

215
00:12:45,490 --> 00:12:49,959
and/or negatives or a huge performance
impact or all of them together

216
00:12:49,959 --> 00:12:52,999
server already hosts but can meet do

217
00:12:52,999 --> 00:12:56,180
actually worse than that and the look

218
00:12:56,180 --> 00:12:59,550
into Melbourne diversification right now
so

219
00:12:59,550 --> 00:13:03,879
let's move from Packers on the binary
level to the source code level into the

220
00:13:03,879 --> 00:13:04,800
compiler

221
00:13:04,800 --> 00:13:08,870
and will use come %uh automation to
generate millions of Melbourne in

222
00:13:08,870 --> 00:13:12,550
now for binaries there are no longer
similar to each other in an instance

223
00:13:12,550 --> 00:13:16,610
and just just pop them out as fast as
possible

224
00:13:16,610 --> 00:13:21,699
arm and I'll use softer diversification
for dat

225
00:13:21,699 --> 00:13:25,379
their techniques works as follows:
usually our compiler

226
00:13:25,379 --> 00:13:28,889
translates from a high-level language a
low-level language and the compiler

227
00:13:28,889 --> 00:13:31,699
translates between these two formats

228
00:13:31,699 --> 00:13:35,920
arm the language specification defines
the amount of transformations that are

229
00:13:35,920 --> 00:13:36,769
allowed

230
00:13:36,769 --> 00:13:40,829
and many per or most programming
languages XD full art said

231
00:13:40,829 --> 00:13:44,160
undefined behavior and two compilers use
that set

232
00:13:44,160 --> 00:13:48,829
of undefined behavior to actually
optimized application

233
00:13:48,829 --> 00:13:52,610
any good compiler makes a deterministic
best guess

234
00:13:52,610 --> 00:13:55,839
according to what did you but both
roadies

235
00:13:55,839 --> 00:13:59,339
our best practices out of are

236
00:13:59,339 --> 00:14:02,999
removed as best practices and at
randomization in the compiler

237
00:14:02,999 --> 00:14:06,809
and according to the ground in value a
value but just money fine

238
00:14:06,809 --> 00:14:11,230
the compilation process and generate
different binary all the time

239
00:14:11,230 --> 00:14:14,860
and if he for example look into C&C plus
plus

240
00:14:14,860 --> 00:14:19,410
those languages of rest a lot of
liberties that allow changes to the

241
00:14:19,410 --> 00:14:22,689
to the runtime layout and to data
compiled code

242
00:14:22,689 --> 00:14:27,100
so for example we can change the data
layout that's out there

243
00:14:27,100 --> 00:14:30,920
our data structure layout honest
accurate can reorder local variables

244
00:14:30,920 --> 00:14:31,980
understand ac

245
00:14:31,980 --> 00:14:36,600
are we can run simplest keeping dollars
this and reorder structures

246
00:14:36,600 --> 00:14:40,339
across the whole program and so on and
there's there's a lot of stuff we can do

247
00:14:40,339 --> 00:14:44,889
just for today to Leo itself also be can
change the layout for a heap uptick to

248
00:14:44,889 --> 00:14:45,600
beacon

249
00:14:45,600 --> 00:14:49,499
modify all that and it's it's pretty
fancy what we can actually do

250
00:14:49,499 --> 00:14:53,019
and fur coat began even do more than
that

251
00:14:53,019 --> 00:14:56,980
rights %uh for example we can play
around with the register allocator

252
00:14:56,980 --> 00:15:00,639
so began just shuffle the kinda
registers that are used

253
00:15:00,639 --> 00:15:06,490
we can arm starve to register allocator
to produce more spill code and all that

254
00:15:06,490 --> 00:15:10,699
and began to all the fancy stuff so that
any produced code will not look similar

255
00:15:10,699 --> 00:15:11,519
to the

256
00:15:11,519 --> 00:15:15,800
to the are to any other sample

257
00:15:15,800 --> 00:15:18,879
we can change instructions selections
orbiting

258
00:15:18,879 --> 00:15:22,300
even work on a more higher level on the
on the basic block law-abiding

259
00:15:22,300 --> 00:15:26,589
basic blocks leading basic block merging
and just shuffling does basic blocks

260
00:15:26,589 --> 00:15:27,910
around so that we can

261
00:15:27,910 --> 00:15:33,290
maximize the differences between the are
between the different planets

262
00:15:33,290 --> 00:15:37,420
so if we take these concepts from softer
diversification

263
00:15:37,420 --> 00:15:41,180
to Melbourne diversification we see that

264
00:15:41,180 --> 00:15:46,660
are right now we can start off with any
softer diversifying compiler

265
00:15:46,660 --> 00:15:50,410
and liked I just explained softer
diversification ride

266
00:15:50,410 --> 00:15:54,259
their original goal of softer
diversification was to protect

267
00:15:54,259 --> 00:15:57,290
running applications against are against

268
00:15:57,290 --> 00:16:01,949
any exploits said it Jing nynex but you
only work on your local machine

269
00:16:01,949 --> 00:16:05,759
but we can use it for for bad practices
a small

270
00:16:05,759 --> 00:16:10,779
and look into diversify a in compilers
cute for a from elber

271
00:16:10,779 --> 00:16:14,839
forget years degenerate unique binaries
and minimize

272
00:16:14,839 --> 00:16:17,999
common substrings your code or data

273
00:16:17,999 --> 00:16:21,990
across the whole binary said it is no
longer possible to use any kind of

274
00:16:21,990 --> 00:16:23,059
similarity metric

275
00:16:23,059 --> 00:16:26,399
to compare toasters binaries arm

276
00:16:26,399 --> 00:16:29,420
performance over had of the binder did
runs on your machine

277
00:16:29,420 --> 00:16:32,550
is usually not an issue for us if you
don't care if the

278
00:16:32,550 --> 00:16:37,720
compiled my over has 20 percent over had
between different samples

279
00:16:37,720 --> 00:16:40,910
also RB diversify both code and data
lower

280
00:16:40,910 --> 00:16:44,800
layout and look from for maximizing are

281
00:16:44,800 --> 00:16:48,649
differences between individual samples
also

282
00:16:48,649 --> 00:16:51,879
look into static data small you don't
want your

283
00:16:51,879 --> 00:16:54,889
the simple string command giving away
all your secret

284
00:16:54,889 --> 00:16:59,990
our secrets values that use our secret
strings that use

285
00:16:59,990 --> 00:17:03,040
implemented this on top

286
00:17:03,040 --> 00:17:07,289
of lol BM arm

287
00:17:07,289 --> 00:17:11,100
it's fully implemented small changes to
the

288
00:17:11,100 --> 00:17:14,649
code generator code Lee outer

289
00:17:14,649 --> 00:17:18,360
register allocator spectrum the outer
and so on

290
00:17:18,360 --> 00:17:23,049
and also some they'd obfuscation passes
on top of it

291
00:17:23,049 --> 00:17:27,209
arm inputs is actually Elodie embed code

292
00:17:27,209 --> 00:17:30,730
so you're pretty general if it compiles
lol embed code

293
00:17:30,730 --> 00:17:35,669
we can't just generate the a diversified
finally out of it

294
00:17:35,669 --> 00:17:39,340
and spit out as many buyers as possible

295
00:17:39,340 --> 00:17:42,419
arm

296
00:17:42,419 --> 00:17:46,539
but as you know this is the research
product retook the research project

297
00:17:46,539 --> 00:17:49,580
and the code is very messy so as an
academic

298
00:17:49,580 --> 00:17:53,149
and fortunate Canada released the source
code

299
00:17:53,149 --> 00:17:56,309
not just kidding I'm not like any other
academics and

300
00:17:56,309 --> 00:18:00,649
are both just released the source code
on get up and you can just forget of

301
00:18:00,649 --> 00:18:04,750
and try it out for yourself

302
00:18:04,750 --> 00:18:10,370
so implemented all the basic our basic
diversification techniques run on top of

303
00:18:10,370 --> 00:18:12,419
a softer diversifying compiler

304
00:18:12,419 --> 00:18:16,850
and we have a stat a set of static
diversification techniques on top of it

305
00:18:16,850 --> 00:18:17,559
this far

306
00:18:17,559 --> 00:18:22,590
so you can just use it to diversify all
your static data

307
00:18:22,590 --> 00:18:26,840
arm as I said well I have a couple of

308
00:18:26,840 --> 00:18:30,490
help files to to get you started but
some up to

309
00:18:30,490 --> 00:18:34,539
coats and edges are pretty rough and
bill add more diversification techniques

310
00:18:34,539 --> 00:18:35,659
as we go along

311
00:18:35,659 --> 00:18:39,029
and especially for are some kind of
graph-based matching

312
00:18:39,029 --> 00:18:42,260
where you try to extract high-level draw
some pub of

313
00:18:42,260 --> 00:18:45,260
the generate a code you could still use
some

314
00:18:45,260 --> 00:18:48,929
similarity metrics that what's the what
sort that the current

315
00:18:48,929 --> 00:18:52,260
diversification but working on does but
there's a first

316
00:18:52,260 --> 00:18:55,399
first part of the code and you can get
access to it

317
00:18:55,399 --> 00:18:59,450
so let's have a look at similarity
metrics

318
00:18:59,450 --> 00:19:02,510
arm this is a simple graph

319
00:19:02,510 --> 00:19:05,799
of a bunch of programs

320
00:19:05,799 --> 00:19:08,850
used mostly to spec CQ applications

321
00:19:08,850 --> 00:19:11,909
and generated a a bunch of different

322
00:19:11,909 --> 00:19:16,049
are different binaries and compared
those two binary is

323
00:19:16,049 --> 00:19:20,039
which is each other and look and what
kind of the the longest common

324
00:19:20,039 --> 00:19:21,000
substrings

325
00:19:21,000 --> 00:19:25,340
in bytes was between does those
different different binary its

326
00:19:25,340 --> 00:19:31,210
and for most of the binaries we see that
like up did there's basically no

327
00:19:31,210 --> 00:19:35,200
sup sequence that's longer than 20 or so
bytes

328
00:19:35,200 --> 00:19:39,970
and just 20 bytes is usually just a
function prologue or function epilogue

329
00:19:39,970 --> 00:19:41,299
like passing a couple of

330
00:19:41,299 --> 00:19:44,860
are of argument

331
00:19:44,860 --> 00:19:48,659
and those are usually not but signatures
for for your ATV engine

332
00:19:48,659 --> 00:19:52,850
so it's already pretty effective issue
which is comparing the

333
00:19:52,850 --> 00:19:59,850
the files are in a in a very simple way

334
00:20:00,350 --> 00:20:03,789
I hope it in crash

335
00:20:03,789 --> 00:20:08,220
its

336
00:20:08,220 --> 00:20:11,049
poet did crash

337
00:20:11,049 --> 00:20:14,720
all there you go

338
00:20:14,720 --> 00:20:19,950
so the next light was a demo anyway
though just moved over

339
00:20:19,950 --> 00:20:23,950
and see if we can start the are

340
00:20:23,950 --> 00:20:30,450
just a demo in safe with the way we've
seen yesterday that there was usually

341
00:20:30,450 --> 00:20:31,630
work pretty well

342
00:20:31,630 --> 00:20:34,630
in during presentations right so let's

343
00:20:34,630 --> 00:20:39,130
just try our best arm Here I am running
on a

344
00:20:39,130 --> 00:20:42,630
Arbor is simple lower scale

345
00:20:42,630 --> 00:20:46,309
on netbooks so the CPU is not to

346
00:20:46,309 --> 00:20:49,409
not too good let's just look at the

347
00:20:49,409 --> 00:20:52,980
the simple file that we look at arm

348
00:20:52,980 --> 00:20:57,280
and it's a very simple see file are just
to show you the the power of the

349
00:20:57,280 --> 00:21:01,020
statically the diversification of a
bunch of springs me to have a string

350
00:21:01,020 --> 00:21:01,950
copy

351
00:21:01,950 --> 00:21:05,710
and to print that's and we're good to go

352
00:21:05,710 --> 00:21:09,169
right so

353
00:21:09,169 --> 00:21:14,539
if you run it through GCC

354
00:21:14,539 --> 00:21:17,950
we get the binary

355
00:21:17,950 --> 00:21:21,940
and it prints the stuff and Rick good to
go

356
00:21:21,940 --> 00:21:25,210
me look in to

357
00:21:25,210 --> 00:21:30,760
Ste brings

358
00:21:30,760 --> 00:21:36,950
0

359
00:21:36,950 --> 00:21:40,870
and PCB have hello world through bar
arguments that %uh that this would give

360
00:21:40,870 --> 00:21:41,400
it away

361
00:21:41,400 --> 00:21:44,610
so let's just try

362
00:21:44,610 --> 00:21:49,210
to divers who fired for now arm

363
00:21:49,210 --> 00:21:53,620
run it through diversifying compiler and
you have produced

364
00:21:53,620 --> 00:21:57,020
up nice little

365
00:21:57,020 --> 00:22:04,020
little file and if you go down

366
00:22:04,160 --> 00:22:09,809
we see that all the static data

367
00:22:09,809 --> 00:22:15,150
has been are encrypt that using are
magic X or encryption right now

368
00:22:15,150 --> 00:22:18,440
with some random values on the plus side

369
00:22:18,440 --> 00:22:22,720
beaches we can just use any one time pat
and

370
00:22:22,720 --> 00:22:26,890
been ever be start of the compiler

371
00:22:26,890 --> 00:22:31,429
ads description code that just art the
crib to date on the fly

372
00:22:31,429 --> 00:22:36,500
arm and generate the code automatically
and runs that code through the divers if

373
00:22:36,500 --> 00:22:37,789
I compile a small

374
00:22:37,789 --> 00:22:41,250
to change the code layout of that you
might now

375
00:22:41,250 --> 00:22:44,650
wonder what to speed implication s

376
00:22:44,650 --> 00:22:48,830
how fast is that stuff so let's just

377
00:22:48,830 --> 00:22:52,730
run or generate 200 samples Ford is too
simple

378
00:22:52,730 --> 00:22:59,730
simple program and you see it's

379
00:23:03,039 --> 00:23:07,440
it goes up consider it random number
summer out there flying by

380
00:23:07,440 --> 00:23:10,820
yeah it's 65 70 1890

381
00:23:10,820 --> 00:23:14,360
and we've generated hundreds different
binaries

382
00:23:14,360 --> 00:23:18,400
just for the simple 59 c:\program are
its various

383
00:23:18,400 --> 00:23:21,990
fairly fast do you guys want to give me

384
00:23:21,990 --> 00:23:26,070
to random values between one and a
hundred

385
00:23:26,070 --> 00:23:30,720
first number 32

386
00:23:30,720 --> 00:23:37,720
42 29

387
00:23:38,130 --> 00:23:45,130
equal random values

388
00:23:48,740 --> 00:23:51,320
42 and 44

389
00:23:51,320 --> 00:23:57,540
and the Cedars

390
00:23:57,540 --> 00:24:01,660
whole lot of different this between the

391
00:24:01,660 --> 00:24:04,710
the two binary is and that's just for
dirt debris small

392
00:24:04,710 --> 00:24:09,090
simple example even like a spectrum
invocation different thank frames

393
00:24:09,090 --> 00:24:12,420
and use the same optimization settings
and all that

394
00:24:12,420 --> 00:24:15,900
and receded there's just a huge
differences just for that

395
00:24:15,900 --> 00:24:19,060
very very small three line program
that's out there

396
00:24:19,060 --> 00:24:22,180
and if you move down to the

397
00:24:22,180 --> 00:24:26,960
the code %uh to the actual data me see
that the date is very different to you

398
00:24:26,960 --> 00:24:30,100
so you might wonder does it actually
work

399
00:24:30,100 --> 00:24:36,450
let's shirts compile its

400
00:24:36,450 --> 00:24:41,620
and its it's the same

401
00:24:41,620 --> 00:24:48,620
hier so it actually runs now let me try
to recovered a presentation that diet

402
00:24:52,390 --> 00:24:59,390
might as s office crest

403
00:25:00,250 --> 00:25:07,250
trash all the time somebody should
should bust that software to you

404
00:25:33,250 --> 00:25:40,250
no I don't want to recover

405
00:25:42,179 --> 00:25:43,330
and

406
00:25:43,330 --> 00:25:47,510
and that's the team affect right that
does it to you

407
00:25:47,510 --> 00:25:51,120
and we're back

408
00:25:51,120 --> 00:25:56,560
a maybe I should have plucked in these
random presenter that I found here under

409
00:25:56,560 --> 00:26:01,280
on the speaker's desk so we've seen the
demo

410
00:26:01,280 --> 00:26:04,640
it work fairly ball right ago play up
play around with that

411
00:26:04,640 --> 00:26:08,000
its open-source bill at more stuff as we
as we go along

412
00:26:08,000 --> 00:26:11,980
and this was basically the first
scenario that I just Joe

413
00:26:11,980 --> 00:26:15,250
right so we do have a compiler out there
and beaches

414
00:26:15,250 --> 00:26:19,640
use it to spit out as many different
different binary study half

415
00:26:19,640 --> 00:26:23,380
and you've seen it it's pretty fast but
you can

416
00:26:23,380 --> 00:26:27,080
let let it run for half an hour and you
will or you will have a couple of

417
00:26:27,080 --> 00:26:28,150
million examples

418
00:26:28,150 --> 00:26:31,180
the big advantages the beaches run

419
00:26:31,180 --> 00:26:35,960
on the LO embed code therefore a beacon
it is a very quick way to produce

420
00:26:35,960 --> 00:26:36,730
different

421
00:26:36,730 --> 00:26:40,090
are different diversified samples

422
00:26:40,090 --> 00:26:43,780
a second scenario that you look at is

423
00:26:43,780 --> 00:26:50,060
up a self the Bersih fine Melber and
right now does is not fully implement at

424
00:26:50,060 --> 00:26:51,730
but we've played around with it for a
bit

425
00:26:51,730 --> 00:26:55,920
so usually you have your static Melber
binary you send out

426
00:26:55,920 --> 00:26:58,970
to infect or two to run and other
machines

427
00:26:58,970 --> 00:27:03,700
arm not just at an lol game optimization
core on top of it

428
00:27:03,700 --> 00:27:08,980
that is added alongside with the malware
and along with that be at

429
00:27:08,980 --> 00:27:13,870
the Melber up now for a bit code and DLO
DM but cut

430
00:27:13,870 --> 00:27:17,180
so we can use in a milder itself

431
00:27:17,180 --> 00:27:20,630
RB can call the alluvium optimizer that
just

432
00:27:20,630 --> 00:27:23,770
diversifies the bit code and of the
Melbourne

433
00:27:23,770 --> 00:27:27,190
and the lol EMCOR again and produces

434
00:27:27,190 --> 00:27:31,100
new lead over 35 Miller as we go along
and spread from system to system

435
00:27:31,100 --> 00:27:34,150
and basically every time you try the
Doosan

436
00:27:34,150 --> 00:27:38,300
new random value and just goes along and
bull

437
00:27:38,300 --> 00:27:41,480
have our self diversifying Melber that
has

438
00:27:41,480 --> 00:27:45,310
even stronger guarantees than any packer
or stronger bigger change than any

439
00:27:45,310 --> 00:27:46,230
packing gift

440
00:27:46,230 --> 00:27:49,600
arm what kinda

441
00:27:49,600 --> 00:27:54,640
mitigation practices are kind of
mitigation strategies can be follow

442
00:27:54,640 --> 00:27:58,470
well we've seen that any signature-based

443
00:27:58,470 --> 00:28:03,250
protection is basically basically host
to a win

444
00:28:03,250 --> 00:28:07,020
with these 10 10 out of 10 I'm awesome

445
00:28:07,020 --> 00:28:10,980
nice arm so

446
00:28:10,980 --> 00:28:14,240
let's look at what we can do first of
all recede

447
00:28:14,240 --> 00:28:18,480
are one option would be to recover some
high-level semantics from the code

448
00:28:18,480 --> 00:28:19,370
extract some

449
00:28:19,370 --> 00:28:24,170
some deeper behavior on top of it which
is which is very hot

450
00:28:24,170 --> 00:28:28,040
for early heart and will result in yet
another arm race between

451
00:28:28,040 --> 00:28:31,960
arm elber riders and to other defenders

452
00:28:31,960 --> 00:28:36,450
we can do full behavioral analysis which
shoots

453
00:28:36,450 --> 00:28:41,050
orville catch Mallard any point in time
but this is very compute incentive

454
00:28:41,050 --> 00:28:45,380
are intended and you have to to think
about if you actually want to use all

455
00:28:45,380 --> 00:28:46,740
these resources for that

456
00:28:46,740 --> 00:28:49,740
or are prohibited in initial

457
00:28:49,740 --> 00:28:53,180
intrusion and fix the the broken softer
educate user and just

458
00:28:53,180 --> 00:28:56,750
educate them enough so that they don't
run any random suffered

459
00:28:56,750 --> 00:28:59,920
its honor system arm

460
00:28:59,920 --> 00:29:04,940
let's conclude this is an attack talk
after all by the mature to defeat the

461
00:29:04,940 --> 00:29:05,970
solutions for it

462
00:29:05,970 --> 00:29:09,730
um first of all

463
00:29:09,730 --> 00:29:12,760
they were City debates Melber a

464
00:29:12,760 --> 00:29:16,140
Melbourne detection and we have built

465
00:29:16,140 --> 00:29:19,240
a fully automatic ever see fine compiler

466
00:29:19,240 --> 00:29:22,830
that you can run on any mail ranch it's
been out as many samples as you want

467
00:29:22,830 --> 00:29:25,900
are there's no need for Packers anymore

468
00:29:25,900 --> 00:29:30,760
and you can get much higher a much
higher quality pictures using that

469
00:29:30,760 --> 00:29:32,020
diversifying compiler

470
00:29:32,020 --> 00:29:35,680
also we can adopt a new similarity
metrics

471
00:29:35,680 --> 00:29:40,860
as we go along and removing up from an
arms race between

472
00:29:40,860 --> 00:29:44,100
attackers and defenders to an arms race
between

473
00:29:44,100 --> 00:29:47,170
defenders and compiler writers which
gives

474
00:29:47,170 --> 00:29:50,870
attackers much more power because it
scales much better to

475
00:29:50,870 --> 00:29:55,080
to just change the compiler once and
then open source IDE and other people

476
00:29:55,080 --> 00:29:56,250
can use it on top of it

477
00:29:56,250 --> 00:29:59,860
are lessons you can learn a top of that

478
00:29:59,860 --> 00:30:04,020
don't rely on any simple static
similarity metrics

479
00:30:04,020 --> 00:30:07,300
that can to speed are

480
00:30:07,300 --> 00:30:10,670
mitigated with is very simple tactics
arm

481
00:30:10,670 --> 00:30:14,360
move along and get better security
practices in shape

482
00:30:14,360 --> 00:30:17,840
and is that a I would like to are to MI
talk

483
00:30:17,840 --> 00:30:21,810
and ask for any questions that you guys
might have how many pizza

484
00:30:21,810 --> 00:30:25,490
NTP do you think that that Davis
vacation and 2p do you have what you're

485
00:30:25,490 --> 00:30:26,230
with your engine

486
00:30:26,230 --> 00:30:30,270
would you estimate with the 32
reordering town

487
00:30:30,270 --> 00:30:33,870
arm that's a good question I have no
idea

488
00:30:33,870 --> 00:30:37,780
I would see a very huge amount like the
long the program is

489
00:30:37,780 --> 00:30:41,720
like any any like just take a simple if

490
00:30:41,720 --> 00:30:45,180
at any if you can you can swap the if
condition

491
00:30:45,180 --> 00:30:49,220
for for your program or just look at
compiling

492
00:30:49,220 --> 00:30:54,070
a when you compile a simple function are
you can't just change to their

493
00:30:54,070 --> 00:30:57,560
register order it ed anything on
instruction or just

494
00:30:57,560 --> 00:31:02,360
alright instrument and a new shuffling
part and if the

495
00:31:02,360 --> 00:31:06,540
are if you don't get enough bit out of
that you can always at garbage

496
00:31:06,540 --> 00:31:08,190
instructions right

497
00:31:08,190 --> 00:31:12,500
so at the compiler level you can just
taken other application and beef that

498
00:31:12,500 --> 00:31:14,050
our application in today

499
00:31:14,050 --> 00:31:18,100
into the translator code because you
know which registers are currently taken

500
00:31:18,100 --> 00:31:21,380
I too can you can just scale it up as
far as you want

501
00:31:21,380 --> 00:31:24,440
at cast so when a

502
00:31:24,440 --> 00:31:28,000
have a flight Australian did in 2010 VX
class

503
00:31:28,000 --> 00:31:31,730
and in the in the hash other time which
was a fuzzy ash where

504
00:31:31,730 --> 00:31:35,630
the was it was sort of it was resistant

505
00:31:35,630 --> 00:31:40,570
who and certain types of this type up
for authentication metrics to measure

506
00:31:40,570 --> 00:31:43,590
something against is more fuzzy yes

507
00:31:43,590 --> 00:31:46,870
um been diff is actually pretty good at
detecting

508
00:31:46,870 --> 00:31:50,270
our diversification right now arm on the
downside

509
00:31:50,270 --> 00:31:53,360
runs for a couple of minutes for each
binary

510
00:31:53,360 --> 00:31:56,400
so it's just more compute resources that
you spent

511
00:31:56,400 --> 00:32:01,040
in addition to that oMG are looking into
ways how we can defeat that to buy

512
00:32:01,040 --> 00:32:04,240
by changing that a control flow graph
and

513
00:32:04,240 --> 00:32:08,860
are and other things so be running in a
compiler I began at more and more stuff

514
00:32:08,860 --> 00:32:12,300
septet

515
00:32:12,300 --> 00:32:16,670
last question at I saw Michael Francis
work in 2000 8

516
00:32:16,670 --> 00:32:20,860
on does first fck she gets baffles me
just started a nice I got a lot of Dhaka

517
00:32:20,860 --> 00:32:21,580
grants

518
00:32:21,580 --> 00:32:26,830
and I thought this was be used in the
App Store with Apple took to create

519
00:32:26,830 --> 00:32:30,360
unique binaries for every download is
this is a trial not in the App Store

520
00:32:30,360 --> 00:32:33,670
but are I guess it was used in Mozilla
was it

521
00:32:33,670 --> 00:32:36,880
that it was there with his initial use
case to produce a new binary for

522
00:32:36,880 --> 00:32:38,360
everybody that downloaded

523
00:32:38,360 --> 00:32:41,470
just just push the the compilation into
the clout

524
00:32:41,470 --> 00:32:45,000
and then everybody to download the
binary its its own individual binary and

525
00:32:45,000 --> 00:32:47,980
if you find and exploit on your local
version it will not run

526
00:32:47,980 --> 00:32:51,170
on any diversified person somewhere else
on the edit

527
00:32:51,170 --> 00:32:54,410
serbia at the the diversification on top
of it

528
00:32:54,410 --> 00:32:59,210
and if change some some other stuff for
Firdous working

529
00:32:59,210 --> 00:33:03,640
our not to questions the first one being

530
00:33:03,640 --> 00:33:06,770
what is the advantage of this
infrastructure over

531
00:33:06,770 --> 00:33:09,930
the zone BZ mister engine from 2002
which

532
00:33:09,930 --> 00:33:14,390
just takes a binary in them lipset and
and start inserting it'll

533
00:33:14,390 --> 00:33:17,660
and %uh the second question is there's a
tool

534
00:33:17,660 --> 00:33:21,600
built by the University of Denmark that
in 2005 did although instruction

535
00:33:21,600 --> 00:33:24,970
diversification and control-flow
flattening at the same time

536
00:33:24,970 --> 00:33:29,070
hallways you to about it um let's answer
the first question

537
00:33:29,070 --> 00:33:32,130
first arm you're always limited

538
00:33:32,130 --> 00:33:35,970
if you lift from from binary on the are

539
00:33:35,970 --> 00:33:40,760
for example the all that they did ever
suffocation is much much much harder

540
00:33:40,760 --> 00:33:44,720
if you if you just let you can you can
do all the coat the reciprocation

541
00:33:44,720 --> 00:33:48,740
or a lot of the coat diversification by
doing by Nicole that thing

542
00:33:48,740 --> 00:33:53,010
but you will have a very hard time
changing the data structures

543
00:33:53,010 --> 00:33:56,530
arm Ford the second question can you

544
00:33:56,530 --> 00:34:01,270
say going so there's a tool book called
Yabloko Ubuntu researchers at the

545
00:34:01,270 --> 00:34:02,810
University of Kent

546
00:34:02,810 --> 00:34:06,600
and I think it's by now pretty old its
from 2005 06

547
00:34:06,600 --> 00:34:11,090
as modification to gcc that those both
the modification of instruction stream

548
00:34:11,090 --> 00:34:11,930
but also

549
00:34:11,930 --> 00:34:15,630
fully implements control flow flattening
and two all these other things that

550
00:34:15,630 --> 00:34:16,870
would screw any formal

551
00:34:16,870 --> 00:34:20,460
for structural matching house YouTube it

552
00:34:20,460 --> 00:34:25,130
all I'm not too familiar with the other
one so I'll have to look into that

553
00:34:25,130 --> 00:34:29,190
arm II guess for to

554
00:34:29,190 --> 00:34:32,500
today to the data they were suffocation
as well %uh

555
00:34:32,500 --> 00:34:36,199
I'm not sure they do today to
diversification but I mean that's a

556
00:34:36,200 --> 00:34:41,450
what 10 line change arm but you have to
run is keeping dollars is right and and

557
00:34:41,450 --> 00:34:42,150
look for

558
00:34:42,150 --> 00:34:45,940
if your data structures at one point in
time passed into

559
00:34:45,940 --> 00:34:49,500
are into connally to structure into a
system call or anything like that

560
00:34:49,500 --> 00:34:53,150
so it's more than 10 lines the yeah

561
00:34:53,150 --> 00:34:56,310
a opec if the operation will be view

562
00:34:56,310 --> 00:34:59,970
use this against the program like fire I
am at the end of the day

563
00:34:59,970 --> 00:35:03,130
it as the same thing if I had a law
handle

564
00:35:03,130 --> 00:35:06,610
so arm fire I

565
00:35:06,610 --> 00:35:10,510
runs in a are runs your sample in a in a

566
00:35:10,510 --> 00:35:15,750
virtual machine and tries to expect some
behavior arm

567
00:35:15,750 --> 00:35:18,980
forward that kind of protection which is

568
00:35:18,980 --> 00:35:22,510
wait the couple minutes or do random
leader

569
00:35:22,510 --> 00:35:25,710
but really this detection you can at
that on top of it

570
00:35:25,710 --> 00:35:29,070
in the compiler small if you want to or
or aren't as the

571
00:35:29,070 --> 00:35:33,140
a long delay before you run your
malicious activity

572
00:35:33,140 --> 00:35:37,870
IRA's mostly behavioral based detection
and I my question is a

573
00:35:37,870 --> 00:35:41,620
the tourney is looking for behavioral me
not looking for

574
00:35:41,620 --> 00:35:45,600
differences in the binary yep but it
runs with a lot higher

575
00:35:45,600 --> 00:35:49,440
much higher overhead right to spending
more resources into

576
00:35:49,440 --> 00:35:52,970
so eventually you're gonna one goal to
opium optimizer

577
00:35:52,970 --> 00:35:56,410
which has also been diversified Ando

578
00:35:56,410 --> 00:35:59,900
it have you look better with the size of
the binary will be

579
00:35:59,900 --> 00:36:04,320
about time yeah it's the a bookmaker
bites

580
00:36:04,320 --> 00:36:08,360
right new them did you did you have a
chance to

581
00:36:08,360 --> 00:36:12,530
run your staff against the X clamps

582
00:36:12,530 --> 00:36:16,390
okay what I have a try against any
customization engine

583
00:36:16,390 --> 00:36:19,630
the they said would pick up in a
polymorphic malware its and and group

584
00:36:19,630 --> 00:36:20,920
them to see dr.

585
00:36:20,920 --> 00:36:24,860
you you know put up the tree pollen the
branch all beyond all

586
00:36:24,860 --> 00:36:28,960
arm be tried expect such behavior by
doing some

587
00:36:28,960 --> 00:36:32,210
are some

588
00:36:32,210 --> 00:36:36,270
more im inform matching but it wasn't
very effective

589
00:36:36,270 --> 00:36:39,610
okay iight cool occurs or few months ago

590
00:36:39,610 --> 00:36:43,280
some French guys PD's on opens opposite
name

591
00:36:43,280 --> 00:36:46,530
ol million which seemed to

592
00:36:46,530 --> 00:36:51,470
have a lot open at with the opposite so
can you comment on whether

593
00:36:51,470 --> 00:36:54,790
the copy 00 p.m.

594
00:36:54,790 --> 00:37:00,440
what project all well-being know that
they were being a little sufficient

595
00:37:00,440 --> 00:37:03,690
okay all LLVM is also puzzled

596
00:37:03,690 --> 00:37:07,230
I mean do you know about and he really
good I few months ago he doesn't know

597
00:37:07,230 --> 00:37:08,830
what is project cost

598
00:37:08,830 --> 00:37:12,010
so i think thats all over that between
your position that was it

599
00:37:12,010 --> 00:37:15,110
okay it seems to be a pretty hot topic
right um

600
00:37:15,110 --> 00:37:19,270
the there are different diversifying
compilers there's the one

601
00:37:19,270 --> 00:37:22,770
by Michael front stairs art there's one
from

602
00:37:22,770 --> 00:37:25,880
bird you did bergson top of GCC and

603
00:37:25,880 --> 00:37:30,550
are and all that but most diversifying
compare compilers focus on

604
00:37:30,550 --> 00:37:36,070
arm on softer diversification so for
diversification for security purposes

605
00:37:36,070 --> 00:37:39,960
and this kind of spins the you to work
some more attacked based

606
00:37:39,960 --> 00:37:40,270
approach

