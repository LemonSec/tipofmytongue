1
00:00:09,980 --> 00:00:13,430
today I would like to talk about some

2
00:00:11,900 --> 00:00:15,410
work we've done at the University of

3
00:00:13,430 --> 00:00:18,380
Pennsylvania with my colleagues and

4
00:00:15,410 --> 00:00:21,259
mentors but detecting application-layer

5
00:00:18,380 --> 00:00:22,970
genera of service attacks so quick recap

6
00:00:21,259 --> 00:00:24,650
on denial of service attacks it's an

7
00:00:22,970 --> 00:00:26,360
important problem it can be a major

8
00:00:24,650 --> 00:00:28,549
source of revenue loss and it can also

9
00:00:26,360 --> 00:00:31,308
cripple or cyber physical infrastructure

10
00:00:28,550 --> 00:00:33,320
when we need them there is a bunch of

11
00:00:31,309 --> 00:00:35,510
way you can deny service but today I'm

12
00:00:33,320 --> 00:00:37,730
going to focus on those attacks by

13
00:00:35,510 --> 00:00:39,320
resource exhaustion and typically there

14
00:00:37,730 --> 00:00:41,510
are two ways to do this kind of attacks

15
00:00:39,320 --> 00:00:43,130
the first one that you've probably heard

16
00:00:41,510 --> 00:00:45,620
about are the volumetric attacks

17
00:00:43,130 --> 00:00:47,120
symmetric ones basically you have a one

18
00:00:45,620 --> 00:00:48,339
to one ratio of resource consumption

19
00:00:47,120 --> 00:00:51,739
between the attacker and the defender

20
00:00:48,340 --> 00:00:53,510
let's say your link is can tolerate 10

21
00:00:51,740 --> 00:00:56,540
gigabit per seconds I'm going to try to

22
00:00:53,510 --> 00:00:58,129
blast as much to it to you so that you

23
00:00:56,540 --> 00:01:00,350
can only overwhelm and you will not be

24
00:00:58,130 --> 00:01:03,860
able to answer any legitimate requests

25
00:01:00,350 --> 00:01:06,530
now there is a second way to consume

26
00:01:03,860 --> 00:01:09,049
exhaust resource at the defender and

27
00:01:06,530 --> 00:01:10,759
without asymmetric attacks zoos are much

28
00:01:09,049 --> 00:01:13,130
more pernicious and harder to detect

29
00:01:10,759 --> 00:01:15,679
basically they reduce drastically the

30
00:01:13,130 --> 00:01:17,658
ratio in favor of the attacker so that

31
00:01:15,679 --> 00:01:20,109
with much less resources involved I can

32
00:01:17,659 --> 00:01:22,819
force you to consume a lot of resources

33
00:01:20,109 --> 00:01:26,600
so today I'm going to give you a little

34
00:01:22,819 --> 00:01:28,759
bit of background on the attacks and did

35
00:01:26,600 --> 00:01:31,548
use what our goal when we want to detect

36
00:01:28,759 --> 00:01:33,560
that as remember like an effective

37
00:01:31,549 --> 00:01:36,049
mitigation needs an effective detection

38
00:01:33,560 --> 00:01:39,259
steps and I'm going to introduce Finland

39
00:01:36,049 --> 00:01:41,779
which is our architecture to detect

40
00:01:39,259 --> 00:01:42,859
those attacks so let me present you with

41
00:01:41,779 --> 00:01:45,679
a classic example

42
00:01:42,859 --> 00:01:49,279
CLS renegotiation very straight forward

43
00:01:45,679 --> 00:01:51,079
me as a client can ask the server to

44
00:01:49,279 --> 00:01:53,420
renegotiate the share secret so that we

45
00:01:51,079 --> 00:01:54,979
can pursue communication all the crypto

46
00:01:53,420 --> 00:01:57,499
work is going to be done at the server

47
00:01:54,979 --> 00:02:00,170
this can be up to ten times more

48
00:01:57,499 --> 00:02:03,859
computation expensive then for me the

49
00:02:00,170 --> 00:02:05,899
attacker another example what we call

50
00:02:03,859 --> 00:02:07,880
the billion of attacks so those

51
00:02:05,899 --> 00:02:10,068
vulnerabilities are present in any

52
00:02:07,880 --> 00:02:12,590
serialization format which I accept

53
00:02:10,068 --> 00:02:15,049
nested entities and think about a binary

54
00:02:12,590 --> 00:02:17,360
tree right or any tree like at each

55
00:02:15,050 --> 00:02:19,189
layer you have an exponential number of

56
00:02:17,360 --> 00:02:20,960
nodes and you're going to be able to

57
00:02:19,189 --> 00:02:25,430
drive up the computation for the

58
00:02:20,960 --> 00:02:27,890
fender like that so what do we want to

59
00:02:25,430 --> 00:02:29,840
actually mitigate detectives attacks so

60
00:02:27,890 --> 00:02:31,760
you guys have a set of goals what we

61
00:02:29,840 --> 00:02:34,310
really wanted is to have an online

62
00:02:31,760 --> 00:02:37,850
system which worked for all the resource

63
00:02:34,310 --> 00:02:39,470
system wide and cross components to be

64
00:02:37,850 --> 00:02:43,420
able to detect attacks so what does that

65
00:02:39,470 --> 00:02:45,710
mean let's look at the challenge spring

66
00:02:43,420 --> 00:02:48,170
brought by the asymmetric general

67
00:02:45,710 --> 00:02:50,090
service attacks well the first one is

68
00:02:48,170 --> 00:02:52,549
that those attacks are trainable in

69
00:02:50,090 --> 00:02:54,740
strength I can decide for the number of

70
00:02:52,550 --> 00:02:56,690
nested entities I'm gonna put in my XML

71
00:02:54,740 --> 00:02:59,480
document so that your parser will have

72
00:02:56,690 --> 00:03:01,820
to take a certain amount of time to to

73
00:02:59,480 --> 00:03:04,100
pass them so what that means for us is

74
00:03:01,820 --> 00:03:06,440
that we really want per request and

75
00:03:04,100 --> 00:03:10,010
in-flight detection we do not we cannot

76
00:03:06,440 --> 00:03:12,079
tolerate that request is out of the

77
00:03:10,010 --> 00:03:15,010
system to talk to observe that it's at

78
00:03:12,080 --> 00:03:18,200
committed a deed and we cannot just

79
00:03:15,010 --> 00:03:19,760
monitor at the scope of the process for

80
00:03:18,200 --> 00:03:21,950
example because we will not be able to

81
00:03:19,760 --> 00:03:24,560
know what exactly was a critical

82
00:03:21,950 --> 00:03:26,420
vulnerability in our system the second

83
00:03:24,560 --> 00:03:30,830
thing is that those attacks can target

84
00:03:26,420 --> 00:03:34,429
any resources bandwidth memory CPU you

85
00:03:30,830 --> 00:03:35,930
know cache entries so we really wanted a

86
00:03:34,430 --> 00:03:40,310
system which can encompass all the

87
00:03:35,930 --> 00:03:42,200
system resources cert points that Zeus

88
00:03:40,310 --> 00:03:44,390
attacks can cross component boundaries

89
00:03:42,200 --> 00:03:46,940
so assume a system where you have an

90
00:03:44,390 --> 00:03:48,950
HTTP from 10 maybe and some business

91
00:03:46,940 --> 00:03:50,450
logic and the database your request can

92
00:03:48,950 --> 00:03:52,790
be crossing all those different

93
00:03:50,450 --> 00:03:54,560
components and the some of the resource

94
00:03:52,790 --> 00:03:59,150
consumption on all those components can

95
00:03:54,560 --> 00:04:00,620
actually be significant so we wanted to

96
00:03:59,150 --> 00:04:04,550
be able to track requests across those

97
00:04:00,620 --> 00:04:07,670
components and lastly there is an

98
00:04:04,550 --> 00:04:09,230
important point that the attacks can be

99
00:04:07,670 --> 00:04:11,059
embedded in third-party libraries for

100
00:04:09,230 --> 00:04:13,190
example serious renegotiation attack I

101
00:04:11,060 --> 00:04:16,970
am NOT writing my own CSS library

102
00:04:13,190 --> 00:04:19,579
personally I'm importing open SSL and I

103
00:04:16,970 --> 00:04:22,370
can of trusts at open SSL is safe maybe

104
00:04:19,579 --> 00:04:24,469
I should not we I need to be able to

105
00:04:22,370 --> 00:04:28,280
track the resource consumption for this

106
00:04:24,470 --> 00:04:30,560
kind of library stuff so let's let's

107
00:04:28,280 --> 00:04:33,388
have a look and phenomena so what how

108
00:04:30,560 --> 00:04:37,409
did we actually build up this system

109
00:04:33,389 --> 00:04:39,689
to detect those attacks well first the

110
00:04:37,409 --> 00:04:42,719
big outline is that we figured out how

111
00:04:39,689 --> 00:04:45,210
to build a unified system which is doing

112
00:04:42,719 --> 00:04:47,490
basically four big things the first one

113
00:04:45,210 --> 00:04:49,349
is to map application layer semantics to

114
00:04:47,490 --> 00:04:52,379
operating system carriers think about

115
00:04:49,349 --> 00:04:55,650
request racing we need to know that HTTP

116
00:04:52,379 --> 00:05:00,479
requests 120 is being executed by PID

117
00:04:55,650 --> 00:05:02,159
2000 second is that our system allows us

118
00:05:00,479 --> 00:05:04,318
to monitor request consumption in flight

119
00:05:02,159 --> 00:05:05,879
meaning as soon as you've been

120
00:05:04,319 --> 00:05:07,860
allocating memory from malloc for

121
00:05:05,879 --> 00:05:08,719
example we'll be able to account it for

122
00:05:07,860 --> 00:05:11,729
this request

123
00:05:08,719 --> 00:05:13,800
third we are going to build some

124
00:05:11,729 --> 00:05:16,199
legitimate finger print of the

125
00:05:13,800 --> 00:05:18,080
legitimate behavior and based on that

126
00:05:16,199 --> 00:05:20,849
we're gonna make some statistical

127
00:05:18,080 --> 00:05:25,080
analysis to be able to detect the tax on

128
00:05:20,849 --> 00:05:26,909
in line so we use EBP f as a framework

129
00:05:25,080 --> 00:05:29,188
to build both my present manager and

130
00:05:26,909 --> 00:05:31,199
that allow us to have a very unified

131
00:05:29,189 --> 00:05:34,469
system so you can use the same interface

132
00:05:31,199 --> 00:05:36,779
for both this request mapping work this

133
00:05:34,469 --> 00:05:39,659
is a resource monitoring work and this

134
00:05:36,779 --> 00:05:41,669
an immediate detection it gives us the

135
00:05:39,659 --> 00:05:43,620
online properties that we wanted system

136
00:05:41,669 --> 00:05:45,599
wide cross components and very

137
00:05:43,620 --> 00:05:48,000
importantly it's language independent

138
00:05:45,599 --> 00:05:52,800
and this is really really practical as

139
00:05:48,000 --> 00:05:55,379
we will see before after for the phone

140
00:05:52,800 --> 00:05:57,779
automated benefits we bring some machine

141
00:05:55,379 --> 00:06:00,349
learning essence for anomaly detection

142
00:05:57,779 --> 00:06:03,870
which is exploiting this infrastructure

143
00:06:00,349 --> 00:06:06,120
so here are the main components of

144
00:06:03,870 --> 00:06:07,979
Finland so I'd like you to consider a

145
00:06:06,120 --> 00:06:09,659
traditional software stack where you

146
00:06:07,979 --> 00:06:11,849
have an application running on top of

147
00:06:09,659 --> 00:06:14,460
some user space library for example the

148
00:06:11,849 --> 00:06:16,500
Lib C and using some camera space

149
00:06:14,460 --> 00:06:19,500
library to exploit the hardware like

150
00:06:16,500 --> 00:06:22,050
this is very standard so at the

151
00:06:19,500 --> 00:06:24,449
application level we have what we call

152
00:06:22,050 --> 00:06:27,000
request matters the requests mappers are

153
00:06:24,449 --> 00:06:29,219
in charge of as soon as a request is

154
00:06:27,000 --> 00:06:32,389
entering a processing function to map

155
00:06:29,219 --> 00:06:34,710
the request ID to the actual process ID

156
00:06:32,389 --> 00:06:37,110
the single component are the resource

157
00:06:34,710 --> 00:06:39,719
managers the resource managers are going

158
00:06:37,110 --> 00:06:42,389
to each time the Ostrom owns and I will

159
00:06:39,719 --> 00:06:44,279
explain all their Simmons track the the

160
00:06:42,389 --> 00:06:44,889
resource consumption associated with

161
00:06:44,279 --> 00:06:47,530
their invoker

162
00:06:44,889 --> 00:06:49,889
and match it to the request ID on the

163
00:06:47,530 --> 00:06:52,270
elf of which the resource was consumed

164
00:06:49,889 --> 00:06:54,430
served component is an anomaly detection

165
00:06:52,270 --> 00:06:56,889
engine which is going to gather all the

166
00:06:54,430 --> 00:06:59,020
training data train some anomaly

167
00:06:56,889 --> 00:07:02,169
detection model share the parameters

168
00:06:59,020 --> 00:07:04,389
with the resource managers which are

169
00:07:02,169 --> 00:07:06,938
going to become a new MIDI detectors and

170
00:07:04,389 --> 00:07:08,379
that will allow us to perform not only

171
00:07:06,939 --> 00:07:11,409
resource monitoring but anomaly

172
00:07:08,379 --> 00:07:14,099
detection in flight and maintain an

173
00:07:11,409 --> 00:07:17,409
outlier score for each of the requests

174
00:07:14,099 --> 00:07:19,029
so let's step back a little bit and

175
00:07:17,409 --> 00:07:20,379
maybe it's going to be easier to see it

176
00:07:19,029 --> 00:07:22,779
from that perspective what is the

177
00:07:20,379 --> 00:07:26,229
workflow of users using Finland

178
00:07:22,779 --> 00:07:27,819
well first for the request mapping the

179
00:07:26,229 --> 00:07:30,159
best person who can do that is actually

180
00:07:27,819 --> 00:07:31,509
a programmer a programmer is very good

181
00:07:30,159 --> 00:07:33,219
at knowing the application she's been

182
00:07:31,509 --> 00:07:34,960
writing it so she's going to register

183
00:07:33,219 --> 00:07:36,759
the chip processing function of the

184
00:07:34,960 --> 00:07:39,188
application in some configuration file

185
00:07:36,759 --> 00:07:40,900
so assuming that the application is made

186
00:07:39,189 --> 00:07:42,699
of a bunch of threads it has a thread

187
00:07:40,900 --> 00:07:46,060
pool and each of the thread is

188
00:07:42,699 --> 00:07:47,860
performing processing events and so we

189
00:07:46,060 --> 00:07:49,389
need to know the name of that function

190
00:07:47,860 --> 00:07:51,339
so the programmer is going to register

191
00:07:49,389 --> 00:07:54,279
that function into some configuration

192
00:07:51,339 --> 00:07:56,469
file second she's gonna configure some

193
00:07:54,279 --> 00:07:59,110
request mappers template so that the

194
00:07:56,469 --> 00:08:02,199
proper request ID mapping can be

195
00:07:59,110 --> 00:08:04,150
maintained the second part for the

196
00:08:02,199 --> 00:08:06,669
resource ministering is handled by our

197
00:08:04,150 --> 00:08:08,799
service reliability engineer this guy is

198
00:08:06,669 --> 00:08:11,198
very good at operating system and

199
00:08:08,800 --> 00:08:15,069
resource monitoring in those exactly

200
00:08:11,199 --> 00:08:17,560
that for example the scheduler context

201
00:08:15,069 --> 00:08:19,900
switch function is this and this and you

202
00:08:17,560 --> 00:08:21,580
knows exactly how to measure the CPU

203
00:08:19,900 --> 00:08:23,560
time consumed by the previous process

204
00:08:21,580 --> 00:08:26,229
from that function so it's going to

205
00:08:23,560 --> 00:08:27,939
declare all those resource allocation

206
00:08:26,229 --> 00:08:30,128
function that she wants to in the

207
00:08:27,939 --> 00:08:32,919
configuration file and customize some

208
00:08:30,129 --> 00:08:34,930
monitors templates so that for

209
00:08:32,919 --> 00:08:37,779
parameters and values can be mapped to

210
00:08:34,929 --> 00:08:39,598
the request lastly we need a statistic

211
00:08:37,779 --> 00:08:41,948
guru to do an immediate detection and

212
00:08:39,599 --> 00:08:43,750
it's basically going to be about

213
00:08:41,948 --> 00:08:45,579
configuring threshold like a mini

214
00:08:43,750 --> 00:08:50,769
standard deviation away from your normal

215
00:08:45,579 --> 00:08:52,989
behavior you want etc etcetera so I'm

216
00:08:50,769 --> 00:08:55,810
only going to go over a couple of

217
00:08:52,990 --> 00:08:56,680
implementation highlights which are

218
00:08:55,810 --> 00:08:58,270
crucial

219
00:08:56,680 --> 00:09:02,589
or understanding of what release

220
00:08:58,270 --> 00:09:04,810
challenge of Finland so we are using EB

221
00:09:02,589 --> 00:09:07,450
TF to do both requests mappers and

222
00:09:04,810 --> 00:09:10,060
monitors so EB F is a universal in

223
00:09:07,450 --> 00:09:13,779
channel of your domination probably many

224
00:09:10,060 --> 00:09:17,529
of you around here nobody PF it's EB F

225
00:09:13,779 --> 00:09:19,420
is not only a packet filter DPF allows

226
00:09:17,529 --> 00:09:22,390
you to write arbitrary pieces of code

227
00:09:19,420 --> 00:09:24,790
what that allows us to do is that is to

228
00:09:22,390 --> 00:09:26,500
attach those pieces of code to any probe

229
00:09:24,790 --> 00:09:29,980
or trace point in your system

230
00:09:26,500 --> 00:09:32,380
so for request mappers we can have our

231
00:09:29,980 --> 00:09:34,990
request Medina logic associated to our

232
00:09:32,380 --> 00:09:37,560
chip processing function second for

233
00:09:34,990 --> 00:09:40,390
resource managers we can have our

234
00:09:37,560 --> 00:09:42,430
resource both monitoring and anomaly

235
00:09:40,390 --> 00:09:44,470
detection logic attached to for example

236
00:09:42,430 --> 00:09:46,899
malloc so each time malloc is going to

237
00:09:44,470 --> 00:09:49,330
be located I'm gonna be able to get to

238
00:09:46,899 --> 00:09:52,240
grab how many bytes were allocated by

239
00:09:49,330 --> 00:09:53,580
malloc and to account it to for to the

240
00:09:52,240 --> 00:09:57,399
write request

241
00:09:53,580 --> 00:09:59,380
lastly the reason the way we can unify

242
00:09:57,399 --> 00:10:01,690
the system is because maples and

243
00:09:59,380 --> 00:10:03,790
monitors can show that that I flew PDF

244
00:10:01,690 --> 00:10:05,529
maps so we maintain a global view of

245
00:10:03,790 --> 00:10:10,060
each request resource consumption across

246
00:10:05,529 --> 00:10:12,010
the system so the very nice thing and

247
00:10:10,060 --> 00:10:12,729
that way I was so happy to say it's very

248
00:10:12,010 --> 00:10:16,029
practical

249
00:10:12,730 --> 00:10:18,430
we had zero line of code to change to

250
00:10:16,029 --> 00:10:21,040
make a chance to make two new syrup a

251
00:10:18,430 --> 00:10:22,479
tree on the GS as well our roads as a

252
00:10:21,040 --> 00:10:26,860
third system which we described in the

253
00:10:22,480 --> 00:10:29,790
paper because this is after all a diner

254
00:10:26,860 --> 00:10:29,790
instrumentation

255
00:10:30,040 --> 00:10:35,740
however if EPF comes with a bunch of

256
00:10:33,160 --> 00:10:38,230
limitations in order to protect the

257
00:10:35,740 --> 00:10:39,790
kernel seems that israel you love EBP f4

258
00:10:38,230 --> 00:10:41,500
what it allows you to do or you hate it

259
00:10:39,790 --> 00:10:45,099
when you're a security professional for

260
00:10:41,500 --> 00:10:47,050
other reasons so you cannot use loops

261
00:10:45,100 --> 00:10:49,660
you cannot choose floating-point numbers

262
00:10:47,050 --> 00:10:51,699
you have 512 bytes tag for each of your

263
00:10:49,660 --> 00:10:53,500
functions and a bunch of other

264
00:10:51,700 --> 00:10:54,399
limitations but I'm just going to

265
00:10:53,500 --> 00:10:57,579
mention those right now

266
00:10:54,399 --> 00:11:00,399
so let's say that now fine-grained

267
00:10:57,579 --> 00:11:01,959
monitoring is relatively easy but

268
00:11:00,399 --> 00:11:05,470
machine learning is actually very hard

269
00:11:01,959 --> 00:11:07,989
in this constrained environment so how

270
00:11:05,470 --> 00:11:10,250
are we going to detect anomalies well I

271
00:11:07,990 --> 00:11:14,890
think a previous speaker was pretty

272
00:11:10,250 --> 00:11:17,360
about k-means as as a benchmarking tool

273
00:11:14,890 --> 00:11:18,290
we're going to do an immediate detection

274
00:11:17,360 --> 00:11:20,360
using k-means

275
00:11:18,290 --> 00:11:23,569
so here is how you will go to do anomaly

276
00:11:20,360 --> 00:11:26,570
detection using K means you would take a

277
00:11:23,570 --> 00:11:28,490
bunch of requests as a vector in n

278
00:11:26,570 --> 00:11:29,960
dimensions each of those dimension is

279
00:11:28,490 --> 00:11:32,840
going to be a resource so for example I

280
00:11:29,960 --> 00:11:35,000
can have CPU memory as a trap and you're

281
00:11:32,840 --> 00:11:38,240
going to cluster all those requests in

282
00:11:35,000 --> 00:11:40,850
similar groups and what you want to do

283
00:11:38,240 --> 00:11:42,560
is to be able to group the requests

284
00:11:40,850 --> 00:11:46,040
which have a similar behavior in the

285
00:11:42,560 --> 00:11:48,859
resource consumption space together now

286
00:11:46,040 --> 00:11:50,660
once you have you learned that basic

287
00:11:48,860 --> 00:11:52,370
legitimate behavior when you new

288
00:11:50,660 --> 00:11:54,980
requests say for example this blue star

289
00:11:52,370 --> 00:11:56,510
is entering into your system what you're

290
00:11:54,980 --> 00:11:58,910
going to do is to compute the distance

291
00:11:56,510 --> 00:12:00,590
to all of the clusters and say okay well

292
00:11:58,910 --> 00:12:02,689
you look like you're closer to these

293
00:12:00,590 --> 00:12:06,680
clusters sure you probably one of those

294
00:12:02,690 --> 00:12:08,210
type of requests there and maybe based

295
00:12:06,680 --> 00:12:10,250
on some threshold you're going to say

296
00:12:08,210 --> 00:12:12,590
well you're close to this cluster but

297
00:12:10,250 --> 00:12:13,940
you're not that close you're actually

298
00:12:12,590 --> 00:12:17,450
too far away from me so you don't learn

299
00:12:13,940 --> 00:12:19,280
about it or you're not in anime so that

300
00:12:17,450 --> 00:12:20,990
sounds great on paper this is extremely

301
00:12:19,280 --> 00:12:22,730
simple this is probably machine learning

302
00:12:20,990 --> 00:12:25,070
101 it's not even machine learning could

303
00:12:22,730 --> 00:12:27,020
be called statistics from the one anyway

304
00:12:25,070 --> 00:12:28,990
the problem is that all our Greek

305
00:12:27,020 --> 00:12:32,270
mathematicians are like screaming like

306
00:12:28,990 --> 00:12:34,280
wait no loops how are we going to be

307
00:12:32,270 --> 00:12:36,949
able to compute stuff like square roots

308
00:12:34,280 --> 00:12:38,810
for example well because you know the

309
00:12:36,950 --> 00:12:40,940
Babylonians had the nice methods to

310
00:12:38,810 --> 00:12:45,380
estimate chords before but it happens to

311
00:12:40,940 --> 00:12:48,470
be not that precise well for that we

312
00:12:45,380 --> 00:12:50,930
have a very simple solution because our

313
00:12:48,470 --> 00:12:53,360
resource vectors are infinite amount of

314
00:12:50,930 --> 00:12:54,829
dimensions the l1 which is a Manhattan

315
00:12:53,360 --> 00:12:58,040
distance is actually going to be

316
00:12:54,830 --> 00:12:59,300
equivalent to more context norms so

317
00:12:58,040 --> 00:13:02,180
that's how we are going to compute

318
00:12:59,300 --> 00:13:03,880
distances stacking all our vectors

319
00:13:02,180 --> 00:13:05,839
together are all dimensions together

320
00:13:03,880 --> 00:13:07,460
it's a known thing we say well we have

321
00:13:05,840 --> 00:13:10,340
no floats how are we going to do that

322
00:13:07,460 --> 00:13:12,140
again we have to do an approximation

323
00:13:10,340 --> 00:13:12,920
trick which is to use floating-point

324
00:13:12,140 --> 00:13:15,080
arithmetic

325
00:13:12,920 --> 00:13:16,939
think about bit shifting and we're just

326
00:13:15,080 --> 00:13:18,770
going to project all our monitoring data

327
00:13:16,940 --> 00:13:19,720
into a higher dimensional space to

328
00:13:18,770 --> 00:13:23,220
retain an arbiter

329
00:13:19,720 --> 00:13:26,829
a degree of precision on the data and

330
00:13:23,220 --> 00:13:28,449
lastly we have only 512 bytes tax so now

331
00:13:26,829 --> 00:13:31,000
we are going to exploit the property of

332
00:13:28,449 --> 00:13:33,849
k-means which is that it will allow us

333
00:13:31,000 --> 00:13:35,470
to summarize the all fingerprint of the

334
00:13:33,850 --> 00:13:37,470
good behavior in a small amount of

335
00:13:35,470 --> 00:13:40,569
points which are the case and trades

336
00:13:37,470 --> 00:13:43,269
basically K vectors and the way we teach

337
00:13:40,569 --> 00:13:44,709
a is going to be to be a go to the equal

338
00:13:43,269 --> 00:13:47,680
to the number of branches in the

339
00:13:44,709 --> 00:13:50,758
application dag we find that we found

340
00:13:47,680 --> 00:13:53,109
out that for all work load it was a

341
00:13:50,759 --> 00:13:55,240
reasonably good way to map the resource

342
00:13:53,110 --> 00:13:56,649
consumption behavior of the system but

343
00:13:55,240 --> 00:14:01,209
your mileage may vary based on your

344
00:13:56,649 --> 00:14:03,699
applications so to recap all this animal

345
00:14:01,209 --> 00:14:05,920
detection works well you would you know

346
00:14:03,699 --> 00:14:08,019
collect a bunch of data from all the EDF

347
00:14:05,920 --> 00:14:10,000
training maps after adding let them go

348
00:14:08,019 --> 00:14:12,879
for your system for some time your train

349
00:14:10,000 --> 00:14:13,930
came I came in standardized you will do

350
00:14:12,879 --> 00:14:17,620
that in userspace

351
00:14:13,930 --> 00:14:19,779
I should let me further say that but you

352
00:14:17,620 --> 00:14:21,879
know you can access the you can access

353
00:14:19,779 --> 00:14:23,920
this map from user space transparently

354
00:14:21,879 --> 00:14:25,600
for the ebf maps you would share the

355
00:14:23,920 --> 00:14:26,740
parameters with resource managers and

356
00:14:25,600 --> 00:14:30,420
then you will perform an immediate

357
00:14:26,740 --> 00:14:33,490
detection so I'm gonna quickly go over

358
00:14:30,420 --> 00:14:35,680
to point evaluation points that I wanted

359
00:14:33,490 --> 00:14:37,269
to show today the first one is what are

360
00:14:35,680 --> 00:14:39,819
the overheads brought by Finland and the

361
00:14:37,269 --> 00:14:41,559
second one is a small experiment with no

362
00:14:39,819 --> 00:14:43,360
G as we have more experiments in the

363
00:14:41,559 --> 00:14:45,610
paper but I just wanted to pick this one

364
00:14:43,360 --> 00:14:46,990
because I'm running over time a little

365
00:14:45,610 --> 00:14:48,850
bit out of time I'm just going to

366
00:14:46,990 --> 00:14:52,509
highlight two things for Apache we are

367
00:14:48,850 --> 00:14:54,189
just below 12% latency what we did is

368
00:14:52,509 --> 00:14:56,740
just measure the latency of the system

369
00:14:54,189 --> 00:14:58,449
Wiz and wizard our instrumentation what

370
00:14:56,740 --> 00:15:00,279
we observed is that once you paid the

371
00:14:58,449 --> 00:15:02,559
overhead cost for resource monitoring

372
00:15:00,279 --> 00:15:06,309
and the Medi detection comes almost for

373
00:15:02,559 --> 00:15:09,670
free and that's really cool for Nadia's

374
00:15:06,309 --> 00:15:11,680
what we did is we just ran an experiment

375
00:15:09,670 --> 00:15:14,529
with only good traffic which we will use

376
00:15:11,680 --> 00:15:15,878
for training some period of attack and

377
00:15:14,529 --> 00:15:18,160
going back to normal

378
00:15:15,879 --> 00:15:20,079
the load is made of 500 edge its mate

379
00:15:18,160 --> 00:15:23,350
requests per second and we have only one

380
00:15:20,079 --> 00:15:25,089
bad attack which is more than 100 Falls

381
00:15:23,350 --> 00:15:27,129
more expensive than the legitimate

382
00:15:25,089 --> 00:15:29,949
requests for this before the attack

383
00:15:27,129 --> 00:15:32,110
period we want to admit three things the

384
00:15:29,949 --> 00:15:34,510
true positive rate which is how can

385
00:15:32,110 --> 00:15:35,950
can detect all the attack request the

386
00:15:34,510 --> 00:15:39,130
true negative rate which means how

387
00:15:35,950 --> 00:15:41,079
faithful are we when we are alerting you

388
00:15:39,130 --> 00:15:43,180
that the modeun attack and also the

389
00:15:41,079 --> 00:15:46,359
spleen improvement leg how long into the

390
00:15:43,180 --> 00:15:49,180
requests can we detect the attack what

391
00:15:46,360 --> 00:15:52,240
we found out is that basically all the

392
00:15:49,180 --> 00:15:54,880
attack were detected we had a couple

393
00:15:52,240 --> 00:15:56,320
false positive which means at some time

394
00:15:54,880 --> 00:16:00,490
you will be woke up during the night for

395
00:15:56,320 --> 00:16:03,040
nothing but not that much and we were

396
00:16:00,490 --> 00:16:05,110
able for these experiments on medium to

397
00:16:03,040 --> 00:16:08,829
detect attacks less than 10 percents in

398
00:16:05,110 --> 00:16:12,570
zero experience our expected lifetime

399
00:16:08,829 --> 00:16:14,979
and at best less than 5% all right so

400
00:16:12,570 --> 00:16:16,899
I'm going to finish there the key

401
00:16:14,980 --> 00:16:18,519
takeaways and take questions the key

402
00:16:16,899 --> 00:16:20,560
takeaways that we build Finland which is

403
00:16:18,519 --> 00:16:22,959
unified anomaly detection system produce

404
00:16:20,560 --> 00:16:25,119
a symmetric denial of service attack

405
00:16:22,959 --> 00:16:27,089
it's per request and online its system

406
00:16:25,120 --> 00:16:28,779
wise and all cross components

407
00:16:27,089 --> 00:16:30,490
independent of the programming language

408
00:16:28,779 --> 00:16:32,709
and there is a clear separation of

409
00:16:30,490 --> 00:16:43,899
concern for all the actors I'll be happy

410
00:16:32,709 --> 00:16:45,939
to take questions thank you hi i'm eric

411
00:16:43,899 --> 00:16:47,470
ID from the university of utah I really

412
00:16:45,940 --> 00:16:49,390
like this work and one of the one of the

413
00:16:47,470 --> 00:16:53,579
cool things about it is that it can

414
00:16:49,390 --> 00:16:56,110
detect the attack while it's in flight

415
00:16:53,579 --> 00:16:58,719
right and do that with minimal

416
00:16:56,110 --> 00:16:59,290
modifications to the application being

417
00:16:58,720 --> 00:17:01,089
monitored

418
00:16:59,290 --> 00:17:03,399
right but I think this raises a question

419
00:17:01,089 --> 00:17:06,100
about Wow okay so now I know that some

420
00:17:03,399 --> 00:17:06,609
request is malicious what am I gonna do

421
00:17:06,099 --> 00:17:09,129
about it

422
00:17:06,609 --> 00:17:12,639
mm-hmm I mean so yeah my application

423
00:17:09,130 --> 00:17:14,020
isn't so can I do can you can I respond

424
00:17:12,640 --> 00:17:16,870
to it without any changes to the

425
00:17:14,020 --> 00:17:18,699
application so that actually

426
00:17:16,869 --> 00:17:20,290
domestication is very dependent on the

427
00:17:18,699 --> 00:17:21,819
application model one very

428
00:17:20,290 --> 00:17:24,250
straightforward thing that you might be

429
00:17:21,819 --> 00:17:26,290
able to do is to just shut down

430
00:17:24,250 --> 00:17:28,359
terminate the request for example for

431
00:17:26,290 --> 00:17:29,950
slow attack like a slow loris which are

432
00:17:28,359 --> 00:17:31,719
just staying in the background for a

433
00:17:29,950 --> 00:17:33,700
long time once you detect that they are

434
00:17:31,720 --> 00:17:36,040
attack request you can just terminate

435
00:17:33,700 --> 00:17:38,440
them another way it might be to if you

436
00:17:36,040 --> 00:17:40,720
have an event-driven model you could

437
00:17:38,440 --> 00:17:43,150
suspend the thread executing this

438
00:17:40,720 --> 00:17:44,620
request kind of forever and

439
00:17:43,150 --> 00:17:48,180
or implemental resource management

440
00:17:44,620 --> 00:17:54,270
policies that's mitigates

441
00:17:48,180 --> 00:17:56,620
thank you sorry Bakshi from Purdue so

442
00:17:54,270 --> 00:17:59,970
this question is regarding your cross

443
00:17:56,620 --> 00:18:03,790
layer anomaly detection module mm-hmm so

444
00:17:59,970 --> 00:18:06,160
you are aware of these denial of service

445
00:18:03,790 --> 00:18:08,260
attacks which trigger algorithmic

446
00:18:06,160 --> 00:18:10,410
complexity bugs so they always trigger

447
00:18:08,260 --> 00:18:13,120
the worst case execution paths of those

448
00:18:10,410 --> 00:18:15,370
so it's not possible by looking at a

449
00:18:13,120 --> 00:18:17,139
single request or even a few requests to

450
00:18:15,370 --> 00:18:20,199
tell if this is legitimate or not

451
00:18:17,140 --> 00:18:22,510
because that worst case path is indeed a

452
00:18:20,200 --> 00:18:24,610
legitimate request but you can tell it's

453
00:18:22,510 --> 00:18:27,520
it's the denial of service if you see

454
00:18:24,610 --> 00:18:28,959
too many requests of that kind so would

455
00:18:27,520 --> 00:18:32,860
you be able to handle something like

456
00:18:28,960 --> 00:18:35,440
that so I think that's not quite right I

457
00:18:32,860 --> 00:18:37,840
think the problem is indeed when only

458
00:18:35,440 --> 00:18:40,809
one request is going to drive your

459
00:18:37,840 --> 00:18:42,309
resource consumption high what what we

460
00:18:40,809 --> 00:18:45,070
are assuming is that during your

461
00:18:42,309 --> 00:18:47,950
integration cycle you will have profiled

462
00:18:45,070 --> 00:18:49,928
all the expected behavior so that you

463
00:18:47,950 --> 00:18:51,550
know that for your clients the client

464
00:18:49,929 --> 00:18:54,300
base that you're expecting to have the

465
00:18:51,550 --> 00:18:57,340
resource consumption or let's say the

466
00:18:54,300 --> 00:19:00,850
running time of specific algorithm is

467
00:18:57,340 --> 00:19:03,790
going to be on average if you know even

468
00:19:00,850 --> 00:19:06,159
its workers is was cased expected worst

469
00:19:03,790 --> 00:19:08,500
case is going to be X but in reality

470
00:19:06,160 --> 00:19:10,780
like an malicious attacker may find a

471
00:19:08,500 --> 00:19:11,890
way to go further and I'm not talking

472
00:19:10,780 --> 00:19:15,160
about the worst case like the

473
00:19:11,890 --> 00:19:17,770
algorithmic work is worst case of the

474
00:19:15,160 --> 00:19:19,600
wolf function but what you're expecting

475
00:19:17,770 --> 00:19:22,500
to see versus what people are actually

476
00:19:19,600 --> 00:19:25,300
going to do and that's how we base that

477
00:19:22,500 --> 00:19:27,420
that attack so you're also able to take

478
00:19:25,300 --> 00:19:31,629
into account distribution of these

479
00:19:27,420 --> 00:19:34,809
execution times do you mean in the sense

480
00:19:31,630 --> 00:19:37,240
of if you have multiple people trying to

481
00:19:34,809 --> 00:19:39,399
attack you and doing that no we don't

482
00:19:37,240 --> 00:19:41,980
actually and we don't need to because if

483
00:19:39,400 --> 00:19:44,410
you were if you are if you had to

484
00:19:41,980 --> 00:19:45,520
consider there is a unit threshold based

485
00:19:44,410 --> 00:19:48,160
on the many detection is very

486
00:19:45,520 --> 00:19:49,389
straightforward if you're on that side

487
00:19:48,160 --> 00:19:50,860
of the line your body

488
00:19:49,390 --> 00:19:53,830
if you're on that sign you're a good guy

489
00:19:50,860 --> 00:19:55,840
and you don't really care you it could

490
00:19:53,830 --> 00:19:59,590
you allow you to make maybe some smarter

491
00:19:55,840 --> 00:20:00,939
mitigation but not necessarily not

492
00:19:59,590 --> 00:20:08,439
necessarily helps you in terms of

493
00:20:00,940 --> 00:20:12,280
detection hi I'm James Davis from

494
00:20:08,440 --> 00:20:13,780
Virginia Tech so at you snakes security

495
00:20:12,280 --> 00:20:15,760
last year there were two different

496
00:20:13,780 --> 00:20:18,670
systems that were also looking at this

497
00:20:15,760 --> 00:20:21,070
problem one was node cure which I

498
00:20:18,670 --> 00:20:22,510
presented which said let's just kind of

499
00:20:21,070 --> 00:20:24,309
throw time outs of stuff and see if that

500
00:20:22,510 --> 00:20:28,690
works and the other was a work called

501
00:20:24,309 --> 00:20:30,399
rampart rampart which was trying to do a

502
00:20:28,690 --> 00:20:32,260
somewhat more sophisticated thing than I

503
00:20:30,400 --> 00:20:34,240
did which was kind of fingerprinting the

504
00:20:32,260 --> 00:20:35,950
application at a function call level and

505
00:20:34,240 --> 00:20:38,169
kind of learn how much or how expensive

506
00:20:35,950 --> 00:20:39,730
each call would be so I understand that

507
00:20:38,169 --> 00:20:41,679
you're doing things at the kernel level

508
00:20:39,730 --> 00:20:44,169
instead of at the application level but

509
00:20:41,679 --> 00:20:45,309
from a system perspective do you think

510
00:20:44,169 --> 00:20:46,900
you're offering more or different

511
00:20:45,309 --> 00:20:52,059
security guarantees and those other

512
00:20:46,900 --> 00:20:54,220
systems did so I think that actually we

513
00:20:52,059 --> 00:20:57,070
have the cost of generality to pay in

514
00:20:54,220 --> 00:20:59,740
the sense that you could use our system

515
00:20:57,070 --> 00:21:01,840
to do a base layer detection which works

516
00:20:59,740 --> 00:21:03,429
for a bunch of different application but

517
00:21:01,840 --> 00:21:05,980
if you were to actually embed the

518
00:21:03,429 --> 00:21:08,110
diagram project for example to ended the

519
00:21:05,980 --> 00:21:10,750
very deep knowledge of the framework

520
00:21:08,110 --> 00:21:12,580
into the detection and mitigation system

521
00:21:10,750 --> 00:21:14,950
you're probably going to be better off

522
00:21:12,580 --> 00:21:17,260
but the price in terms of programming

523
00:21:14,950 --> 00:21:19,630
effort and management complexity is very

524
00:21:17,260 --> 00:21:21,549
high one of the things that we bring

525
00:21:19,630 --> 00:21:23,500
here is a clear separation of concern as

526
00:21:21,549 --> 00:21:25,780
I was saying so that the people who

527
00:21:23,500 --> 00:21:27,460
write this at the application they just

528
00:21:25,780 --> 00:21:29,590
have to declare the processing pipeline

529
00:21:27,460 --> 00:21:33,100
and the people who are very good at

530
00:21:29,590 --> 00:21:35,770
doing Resource Management can actually

531
00:21:33,100 --> 00:21:36,580
devise the resource managers but does

532
00:21:35,770 --> 00:21:39,070
that answer the question

533
00:21:36,580 --> 00:21:44,520
yeah a little bit yeah okay well we can

534
00:21:39,070 --> 00:21:44,520
take that time to chat Thanks thank you

