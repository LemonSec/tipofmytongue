1
00:00:13,120 --> 00:00:15,679
yeah so i will be talking about bbq

2
00:00:15,679 --> 00:00:18,080
a block based bounded queue

3
00:00:18,080 --> 00:00:19,920
and this is not to be confused with

4
00:00:19,920 --> 00:00:22,080
another term that uses the same acronym

5
00:00:22,080 --> 00:00:24,560
something related with food

6
00:00:24,560 --> 00:00:27,519
so bbq is a is a ring buffer and

7
00:00:27,519 --> 00:00:29,359
for us bounded queues and ring buffers

8
00:00:29,359 --> 00:00:31,840
will be synonyms here and ring buffers

9
00:00:31,840 --> 00:00:33,680
are used for exchanging data for

10
00:00:33,680 --> 00:00:36,559
profiling for

11
00:00:36,800 --> 00:00:38,719
collecting traces for decoupling

12
00:00:38,719 --> 00:00:42,000
components there are many use cases here

13
00:00:42,000 --> 00:00:43,280
and you can find

14
00:00:43,280 --> 00:00:45,280
ring buffers in several parts of the

15
00:00:45,280 --> 00:00:46,640
software stack you can find that in

16
00:00:46,640 --> 00:00:48,960
application layer gold language has that

17
00:00:48,960 --> 00:00:50,640
built in in channels

18
00:00:50,640 --> 00:00:53,360
um any database header spring buffers

19
00:00:53,360 --> 00:00:55,440
operating system linux has several ring

20
00:00:55,440 --> 00:00:57,039
buffer implementations

21
00:00:57,039 --> 00:00:59,359
dpdk has a ring ring buffer

22
00:00:59,359 --> 00:01:02,320
implementation as well of course um

23
00:01:02,320 --> 00:01:05,280
so if this is so common and so well

24
00:01:05,280 --> 00:01:07,119
established and so standard why do we

25
00:01:07,119 --> 00:01:09,040
care about that that's a

26
00:01:09,040 --> 00:01:10,880
good point

27
00:01:10,880 --> 00:01:13,040
well we care because it's everywhere and

28
00:01:13,040 --> 00:01:15,840
uh if it turns out that a ring buffer is

29
00:01:15,840 --> 00:01:18,320
for some reason slow then it's probably

30
00:01:18,320 --> 00:01:19,280
going to affect the performance of

31
00:01:19,280 --> 00:01:20,479
application

32
00:01:20,479 --> 00:01:22,560
and if it turns out the ring buffer is

33
00:01:22,560 --> 00:01:24,320
incorrect then it will probably break

34
00:01:24,320 --> 00:01:26,720
the application as well and to make this

35
00:01:26,720 --> 00:01:28,960
a bit more concrete and more interesting

36
00:01:28,960 --> 00:01:31,040
i'm going to share with you three ring

37
00:01:31,040 --> 00:01:32,560
buffer stories

38
00:01:32,560 --> 00:01:35,200
uh from huawei software development and

39
00:01:35,200 --> 00:01:37,040
these stories we talked with different

40
00:01:37,040 --> 00:01:38,720
teams in huawei that have developed

41
00:01:38,720 --> 00:01:40,320
different products and they were working

42
00:01:40,320 --> 00:01:42,640
with ring buffers and had issues with

43
00:01:42,640 --> 00:01:43,759
them

44
00:01:43,759 --> 00:01:45,840
and these stories actually motivated our

45
00:01:45,840 --> 00:01:48,000
work in this and in this ring buffer

46
00:01:48,000 --> 00:01:50,880
that i will present then afterward

47
00:01:50,880 --> 00:01:53,200
so the first story is about an in-house

48
00:01:53,200 --> 00:01:54,960
operating system

49
00:01:54,960 --> 00:01:56,000
that

50
00:01:56,000 --> 00:01:57,759
got a new tracing tool

51
00:01:57,759 --> 00:02:00,640
so this tracing tool was used to collect

52
00:02:00,640 --> 00:02:02,399
traces of application

53
00:02:02,399 --> 00:02:04,399
and then later could be used then to to

54
00:02:04,399 --> 00:02:07,119
create a profile of the application and

55
00:02:07,119 --> 00:02:09,038
here of course the traces were put in a

56
00:02:09,038 --> 00:02:11,680
ring buffer and the main restriction was

57
00:02:11,680 --> 00:02:14,000
that the reporting of these traces to

58
00:02:14,000 --> 00:02:15,520
the ring buffer so the producer has to

59
00:02:15,520 --> 00:02:17,280
be super fast it should not be affected

60
00:02:17,280 --> 00:02:19,120
by the ring buffer because the

61
00:02:19,120 --> 00:02:20,400
application was supposed to run in

62
00:02:20,400 --> 00:02:21,680
production

63
00:02:21,680 --> 00:02:25,120
and uh well it is running for production

64
00:02:25,120 --> 00:02:28,000
um now the problem is that exactly that

65
00:02:28,000 --> 00:02:30,480
was happening whenever a consumer would

66
00:02:30,480 --> 00:02:31,920
start consuming from the ring buffer the

67
00:02:31,920 --> 00:02:34,400
traces to aggregate them um the

68
00:02:34,400 --> 00:02:36,400
performance of the pro of the producer

69
00:02:36,400 --> 00:02:38,480
would be affected and we would see a

70
00:02:38,480 --> 00:02:41,680
latency spikes or or throughput drops

71
00:02:41,680 --> 00:02:44,400
and that got us to think about what are

72
00:02:44,400 --> 00:02:46,160
the sources of interferences in a ring

73
00:02:46,160 --> 00:02:48,080
buffer so if you think about a ring

74
00:02:48,080 --> 00:02:49,680
buffer it's an array

75
00:02:49,680 --> 00:02:51,840
and it has a few pointers or a few

76
00:02:51,840 --> 00:02:52,959
indices

77
00:02:52,959 --> 00:02:55,120
um this is an abstract version depending

78
00:02:55,120 --> 00:02:56,640
how you implement it you may have more

79
00:02:56,640 --> 00:02:58,800
indices each of these head and tail may

80
00:02:58,800 --> 00:03:01,120
be implemented with two indices

81
00:03:01,120 --> 00:03:03,599
you may protect them with locks or you

82
00:03:03,599 --> 00:03:05,280
may use a lock less algorithm but in

83
00:03:05,280 --> 00:03:06,720
abstract sense this is what a ring

84
00:03:06,720 --> 00:03:08,239
buffer is

85
00:03:08,239 --> 00:03:09,920
and when you have multiple wing cures

86
00:03:09,920 --> 00:03:11,680
multiple producers trying to incur

87
00:03:11,680 --> 00:03:13,760
something they will need to move this

88
00:03:13,760 --> 00:03:14,560
head

89
00:03:14,560 --> 00:03:16,480
and when they move the head

90
00:03:16,480 --> 00:03:18,480
there will be some enqueue enqueue

91
00:03:18,480 --> 00:03:20,319
interference basically contention on

92
00:03:20,319 --> 00:03:21,840
that head

93
00:03:21,840 --> 00:03:25,280
also when um a consumer wants to decue

94
00:03:25,280 --> 00:03:26,319
something

95
00:03:26,319 --> 00:03:28,239
um it needs to compare besides

96
00:03:28,239 --> 00:03:29,440
incrementing the head and moving the

97
00:03:29,440 --> 00:03:30,959
head it needs to compare the head with

98
00:03:30,959 --> 00:03:33,680
the tail sorry instead besides the

99
00:03:33,680 --> 00:03:35,120
incremented detail

100
00:03:35,120 --> 00:03:37,200
it needs to read the head to compare to

101
00:03:37,200 --> 00:03:39,120
see if there is anything to read at all

102
00:03:39,120 --> 00:03:41,440
and there you will have cache misses

103
00:03:41,440 --> 00:03:42,799
and um

104
00:03:42,799 --> 00:03:44,959
that's what we call the enqueue dq

105
00:03:44,959 --> 00:03:46,640
interference

106
00:03:46,640 --> 00:03:48,560
the same thing you can see the other way

107
00:03:48,560 --> 00:03:50,080
around so you can flip this figure and

108
00:03:50,080 --> 00:03:51,680
then mirror it and you're going to see

109
00:03:51,680 --> 00:03:54,239
the same scenario for the dequeuers

110
00:03:54,239 --> 00:03:55,519
but for the presentation i'm going to be

111
00:03:55,519 --> 00:03:57,120
focusing on the inquiry just to simplify

112
00:03:57,120 --> 00:03:58,959
the talk

113
00:03:58,959 --> 00:04:00,959
so what uh current

114
00:04:00,959 --> 00:04:02,560
ring buffers out there do about these

115
00:04:02,560 --> 00:04:04,560
kind of interferences

116
00:04:04,560 --> 00:04:06,799
interest is interesting to see that uh

117
00:04:06,799 --> 00:04:09,200
the nq dq interference is not really

118
00:04:09,200 --> 00:04:11,920
handled so if you we looked into dpdk

119
00:04:11,920 --> 00:04:14,720
ring buffer and linux ring buffer um the

120
00:04:14,720 --> 00:04:17,279
facebook meta follicu which is quite

121
00:04:17,279 --> 00:04:18,720
popular and none of them really do

122
00:04:18,720 --> 00:04:20,478
anything about this interference between

123
00:04:20,478 --> 00:04:22,320
the keywords and the cures and i think

124
00:04:22,320 --> 00:04:24,000
this is this is the main point of the

125
00:04:24,000 --> 00:04:26,400
paper is identifying this and saying hey

126
00:04:26,400 --> 00:04:27,919
actually there is some interference here

127
00:04:27,919 --> 00:04:28,800
that

128
00:04:28,800 --> 00:04:29,919
you may

129
00:04:29,919 --> 00:04:32,080
consider taking care of and we show how

130
00:04:32,080 --> 00:04:34,639
one approach or how to handle that

131
00:04:34,639 --> 00:04:37,120
um another thing is like in queueing q

132
00:04:37,120 --> 00:04:39,360
interferences or dqdq interferences

133
00:04:39,360 --> 00:04:41,120
those are handled by other cues for

134
00:04:41,120 --> 00:04:43,520
example the follicu

135
00:04:43,520 --> 00:04:45,520
when it needs to update the head

136
00:04:45,520 --> 00:04:48,080
um it does not use a compare and swap so

137
00:04:48,080 --> 00:04:49,600
compare swap will

138
00:04:49,600 --> 00:04:50,960
well the hardware will check if the

139
00:04:50,960 --> 00:04:52,960
value is as expected and if only if it

140
00:04:52,960 --> 00:04:55,520
is as expected it will update that value

141
00:04:55,520 --> 00:04:57,600
and um

142
00:04:57,600 --> 00:05:00,080
it can fail so you need to retry

143
00:05:00,080 --> 00:05:01,199
what uh

144
00:05:01,199 --> 00:05:03,120
folique uses that you they use a fetch

145
00:05:03,120 --> 00:05:05,360
an ad so this is an always successful

146
00:05:05,360 --> 00:05:07,680
operation so if multiplying keywords try

147
00:05:07,680 --> 00:05:10,240
to include to to increment the head it

148
00:05:10,240 --> 00:05:11,759
they won't fail they don't don't need to

149
00:05:11,759 --> 00:05:14,800
retry and will be much faster in x86 and

150
00:05:14,800 --> 00:05:16,960
uh on arm as well

151
00:05:16,960 --> 00:05:20,000
now the problem with that is that

152
00:05:20,000 --> 00:05:22,000
first is nice is a good thing but

153
00:05:22,000 --> 00:05:24,160
you could because you cannot control

154
00:05:24,160 --> 00:05:26,400
whether it will increment or not you can

155
00:05:26,400 --> 00:05:28,320
go beyond the tail

156
00:05:28,320 --> 00:05:30,240
and now your ring buffer is in a

157
00:05:30,240 --> 00:05:32,479
slightly inconsistent state so you need

158
00:05:32,479 --> 00:05:34,080
to do something about that

159
00:05:34,080 --> 00:05:37,039
and you have uh two options you can try

160
00:05:37,039 --> 00:05:39,680
to fix that roll back your change but

161
00:05:39,680 --> 00:05:41,199
that's complicated because some other

162
00:05:41,199 --> 00:05:42,720
thread may be trying to increment that

163
00:05:42,720 --> 00:05:44,320
at the same time so you get going to get

164
00:05:44,320 --> 00:05:46,320
messy results with that

165
00:05:46,320 --> 00:05:49,039
another approach what follicle does is

166
00:05:49,039 --> 00:05:52,440
to um

167
00:05:52,800 --> 00:05:53,759
is to

168
00:05:53,759 --> 00:05:56,080
block the the inquirer block the

169
00:05:56,080 --> 00:05:58,479
producer and wait until the consumers

170
00:05:58,479 --> 00:06:00,479
make the the ring buffer consistent

171
00:06:00,479 --> 00:06:01,520
again

172
00:06:01,520 --> 00:06:03,360
the problem is that you need consumers

173
00:06:03,360 --> 00:06:05,280
in the first place

174
00:06:05,280 --> 00:06:07,199
so you may be blocking there the

175
00:06:07,199 --> 00:06:09,520
producers and there is no consumer for a

176
00:06:09,520 --> 00:06:11,039
long time because they are just taking a

177
00:06:11,039 --> 00:06:11,840
nap

178
00:06:11,840 --> 00:06:13,680
and then the producers are waiting for a

179
00:06:13,680 --> 00:06:14,880
long time

180
00:06:14,880 --> 00:06:17,199
so the message here is that fetch and ad

181
00:06:17,199 --> 00:06:18,560
is a good idea to use this kind of

182
00:06:18,560 --> 00:06:19,919
operation but

183
00:06:19,919 --> 00:06:22,639
one needs to take care how to use them

184
00:06:22,639 --> 00:06:24,400
the second story

185
00:06:24,400 --> 00:06:27,280
is about over subscription so there's a

186
00:06:27,280 --> 00:06:29,680
second product that

187
00:06:29,680 --> 00:06:31,440
there's a team building a framework for

188
00:06:31,440 --> 00:06:33,280
mobile devices and

189
00:06:33,280 --> 00:06:34,560
um

190
00:06:34,560 --> 00:06:36,800
well mobile phones or mobile devices you

191
00:06:36,800 --> 00:06:38,800
don't have it at many cores but this

192
00:06:38,800 --> 00:06:40,800
framework has many threats

193
00:06:40,800 --> 00:06:42,639
and there the communication of these

194
00:06:42,639 --> 00:06:44,319
threads is using some sort of channels

195
00:06:44,319 --> 00:06:46,240
or some sort of ring buffers

196
00:06:46,240 --> 00:06:47,440
and

197
00:06:47,440 --> 00:06:48,639
it turns out that the original

198
00:06:48,639 --> 00:06:51,280
implementation they had uh was doing in

199
00:06:51,280 --> 00:06:53,440
order operations i'm going to explain

200
00:06:53,440 --> 00:06:54,639
what that means

201
00:06:54,639 --> 00:06:56,400
but these in-order operations are

202
00:06:56,400 --> 00:06:58,160
extremely bad when you have this over

203
00:06:58,160 --> 00:07:00,000
subscription when you have more threads

204
00:07:00,000 --> 00:07:01,520
than cores

205
00:07:01,520 --> 00:07:03,199
and here you can see a very small ring

206
00:07:03,199 --> 00:07:04,240
buffer

207
00:07:04,240 --> 00:07:06,080
the head now is implemented not as a

208
00:07:06,080 --> 00:07:08,319
single in this index but it's like two

209
00:07:08,319 --> 00:07:10,479
indices and uh because this is a lock

210
00:07:10,479 --> 00:07:12,160
less algorithm

211
00:07:12,160 --> 00:07:14,080
and now uh say that the thread wants to

212
00:07:14,080 --> 00:07:15,680
enqueue something it moves they're

213
00:07:15,680 --> 00:07:17,759
located so that that position is for

214
00:07:17,759 --> 00:07:20,080
that thread now another thread may want

215
00:07:20,080 --> 00:07:22,080
to also produce something and a third

216
00:07:22,080 --> 00:07:23,360
thread may want to produce something so

217
00:07:23,360 --> 00:07:25,840
we always move this dislocated pointer

218
00:07:25,840 --> 00:07:27,039
and then

219
00:07:27,039 --> 00:07:29,360
they may produce concurrently but they

220
00:07:29,360 --> 00:07:31,919
can only commit they can only move the

221
00:07:31,919 --> 00:07:34,560
the produced pointer when they are done

222
00:07:34,560 --> 00:07:36,960
uh what in the order that it was set

223
00:07:36,960 --> 00:07:39,120
there otherwise the consumers may read

224
00:07:39,120 --> 00:07:40,160
garbage

225
00:07:40,160 --> 00:07:42,080
and now um

226
00:07:42,080 --> 00:07:43,840
if you have over subscription and then a

227
00:07:43,840 --> 00:07:45,919
few threads get preempted then you are

228
00:07:45,919 --> 00:07:48,240
in trouble because uh you have created a

229
00:07:48,240 --> 00:07:50,240
kind of dependency a chain of

230
00:07:50,240 --> 00:07:52,080
dependencies and you need to reschedule

231
00:07:52,080 --> 00:07:52,880
these

232
00:07:52,880 --> 00:07:53,680
uh

233
00:07:53,680 --> 00:07:56,080
these threads in the order of the queue

234
00:07:56,080 --> 00:07:58,319
so it doesn't help now rescheduling the

235
00:07:58,319 --> 00:08:00,479
b because the b can although it can

236
00:08:00,479 --> 00:08:02,319
write there but it cannot move the

237
00:08:02,319 --> 00:08:03,440
produced

238
00:08:03,440 --> 00:08:06,240
uh pointer and uh a needs to be

239
00:08:06,240 --> 00:08:08,000
scheduled and then b needs to be

240
00:08:08,000 --> 00:08:10,000
scheduled again in a core and then only

241
00:08:10,000 --> 00:08:13,840
then uh the c can

242
00:08:13,840 --> 00:08:16,479
increment or move the produced so the

243
00:08:16,479 --> 00:08:18,720
message here from this story is that out

244
00:08:18,720 --> 00:08:21,360
of order operations are challenging

245
00:08:21,360 --> 00:08:22,160
sorry

246
00:08:22,160 --> 00:08:23,840
inorder operations are a bad thing out

247
00:08:23,840 --> 00:08:26,400
of order operations are necessary but

248
00:08:26,400 --> 00:08:27,440
challenging

249
00:08:27,440 --> 00:08:29,280
and i'm not going to talk about the

250
00:08:29,280 --> 00:08:31,280
details of how related work do the out

251
00:08:31,280 --> 00:08:34,479
of order operations so in that case that

252
00:08:34,479 --> 00:08:36,320
the threads don't wait

253
00:08:36,320 --> 00:08:38,399
um but i will show you how we do that

254
00:08:38,399 --> 00:08:41,399
later

255
00:08:43,039 --> 00:08:45,839
as a third story

256
00:08:45,839 --> 00:08:48,160
it's about migrating from x86 to arm so

257
00:08:48,160 --> 00:08:49,440
you know that arm is becoming more and

258
00:08:49,440 --> 00:08:53,880
more popular in server scenarios

259
00:08:54,080 --> 00:08:55,839
and there was a product that was stable

260
00:08:55,839 --> 00:08:58,720
for very many years in x86 um running

261
00:08:58,720 --> 00:09:00,160
x86 servers

262
00:09:00,160 --> 00:09:01,680
and there was the need to migrate to arm

263
00:09:01,680 --> 00:09:03,040
servers so huawei has these tyshon

264
00:09:03,040 --> 00:09:04,880
servers that are processors and that was

265
00:09:04,880 --> 00:09:06,320
the target

266
00:09:06,320 --> 00:09:08,640
and internally this this product was

267
00:09:08,640 --> 00:09:12,880
using or is using an old version of dpdk

268
00:09:12,880 --> 00:09:16,240
um that predates the support for arm

269
00:09:16,240 --> 00:09:18,240
and over the years the the product team

270
00:09:18,240 --> 00:09:19,279
there uh

271
00:09:19,279 --> 00:09:21,680
just the application grew and the code

272
00:09:21,680 --> 00:09:23,279
became intertwined with with the ring

273
00:09:23,279 --> 00:09:25,120
buffer so it was not so easy just to

274
00:09:25,120 --> 00:09:26,880
separate both things

275
00:09:26,880 --> 00:09:29,200
and they decided that they would be too

276
00:09:29,200 --> 00:09:30,880
risky to separate the things that just

277
00:09:30,880 --> 00:09:32,480
just let's use it like this we're not

278
00:09:32,480 --> 00:09:35,519
going to upgrade the the dpdk buffer

279
00:09:35,519 --> 00:09:37,600
and the consequence was that they

280
00:09:37,600 --> 00:09:38,959
started having

281
00:09:38,959 --> 00:09:41,360
annoying weak memory model bugs

282
00:09:41,360 --> 00:09:43,839
so with memory bugs so reorderings that

283
00:09:43,839 --> 00:09:46,880
were not there in x86 and you because of

284
00:09:46,880 --> 00:09:48,160
missing fences

285
00:09:48,160 --> 00:09:50,399
and that turned out to be like more than

286
00:09:50,399 --> 00:09:51,440
six

287
00:09:51,440 --> 00:09:54,320
person month uh cost to fix

288
00:09:54,320 --> 00:09:57,040
so the decision of not uh updating

289
00:09:57,040 --> 00:09:58,720
was probably not the best one but in

290
00:09:58,720 --> 00:10:00,240
fact probably they didn't even even

291
00:10:00,240 --> 00:10:02,560
realize that there was a problem so

292
00:10:02,560 --> 00:10:03,839
um

293
00:10:03,839 --> 00:10:06,480
to illustrate for you so just to refresh

294
00:10:06,480 --> 00:10:08,080
your memory regarding weak memory models

295
00:10:08,080 --> 00:10:10,560
so here is a very small piece of code

296
00:10:10,560 --> 00:10:12,240
uh i want to illustrate what a weak

297
00:10:12,240 --> 00:10:13,839
memory model can do

298
00:10:13,839 --> 00:10:16,480
uh for you or against you

299
00:10:16,480 --> 00:10:18,000
in this small example there are two

300
00:10:18,000 --> 00:10:19,440
threads trying to communicate there's

301
00:10:19,440 --> 00:10:20,959
thread one sending a message to thread

302
00:10:20,959 --> 00:10:22,399
two and there are two variables so

303
00:10:22,399 --> 00:10:24,240
thread one writes data and then once

304
00:10:24,240 --> 00:10:25,760
it's done it writes control saying i'm

305
00:10:25,760 --> 00:10:27,519
done with the message thread tool is

306
00:10:27,519 --> 00:10:29,279
waiting for a message and uh once

307
00:10:29,279 --> 00:10:31,120
control set one it reads data and it

308
00:10:31,120 --> 00:10:32,959
asserts the data is one

309
00:10:32,959 --> 00:10:35,839
so i mean it's a simple silly example

310
00:10:35,839 --> 00:10:38,480
but in x86 this will always work as soon

311
00:10:38,480 --> 00:10:40,959
as the control reads the update from as

312
00:10:40,959 --> 00:10:42,399
soon as the thread 2 reads the control

313
00:10:42,399 --> 00:10:44,880
of the control value to be one

314
00:10:44,880 --> 00:10:46,560
then all the previous updates of thread

315
00:10:46,560 --> 00:10:48,480
one will be visible as well because

316
00:10:48,480 --> 00:10:50,640
there is this total store order that is

317
00:10:50,640 --> 00:10:52,640
the memory model of x86

318
00:10:52,640 --> 00:10:54,640
and uh if you have arm or if you have

319
00:10:54,640 --> 00:10:56,240
risk five power

320
00:10:56,240 --> 00:10:58,079
they will the hardware may see that the

321
00:10:58,079 --> 00:10:59,279
date and the control don't have any

322
00:10:59,279 --> 00:11:01,279
address in dependency control dependency

323
00:11:01,279 --> 00:11:03,279
or or any dependency at all and they may

324
00:11:03,279 --> 00:11:05,040
just re reorder the updates and

325
00:11:05,040 --> 00:11:07,600
propagate update the control first so

326
00:11:07,600 --> 00:11:09,360
the thread2 may see control to be one

327
00:11:09,360 --> 00:11:11,760
and then the assertion fails

328
00:11:11,760 --> 00:11:13,360
now the programmer needs to carefully

329
00:11:13,360 --> 00:11:14,640
place a bearer and tell the hardware

330
00:11:14,640 --> 00:11:16,480
please don't reorder these operations i

331
00:11:16,480 --> 00:11:17,680
know that you're going to break my code

332
00:11:17,680 --> 00:11:18,959
if you do this optimization and the

333
00:11:18,959 --> 00:11:20,240
hardware

334
00:11:20,240 --> 00:11:22,640
hopefully do that

335
00:11:22,640 --> 00:11:24,640
so how people are developing for weak

336
00:11:24,640 --> 00:11:27,120
memory models nowadays so there's some

337
00:11:27,120 --> 00:11:29,120
people that think very hard and document

338
00:11:29,120 --> 00:11:30,800
code this is very nice for example the

339
00:11:30,800 --> 00:11:33,600
print k in a ring buffer in linux

340
00:11:33,600 --> 00:11:36,160
has huge pieces of comments uh

341
00:11:36,160 --> 00:11:38,079
explaining exactly which barrier

342
00:11:38,079 --> 00:11:40,640
synchronizes with which bearer and uh

343
00:11:40,640 --> 00:11:42,880
very well thought

344
00:11:42,880 --> 00:11:45,360
but most people do what i was just

345
00:11:45,360 --> 00:11:46,320
mentioning

346
00:11:46,320 --> 00:11:48,560
they don't care that much about it just

347
00:11:48,560 --> 00:11:50,959
see when it happens the problem and then

348
00:11:50,959 --> 00:11:52,959
try to fix it later on

349
00:11:52,959 --> 00:11:56,399
and what we do in our team we try to

350
00:11:56,399 --> 00:11:58,399
use

351
00:11:58,399 --> 00:11:59,839
model checkers

352
00:11:59,839 --> 00:12:02,000
so by now um

353
00:12:02,000 --> 00:12:04,240
2022 there are model checkers that work

354
00:12:04,240 --> 00:12:05,760
with c code you can just give you a

355
00:12:05,760 --> 00:12:07,440
piece of c code and see what would

356
00:12:07,440 --> 00:12:09,440
happen in a weak memory model

357
00:12:09,440 --> 00:12:10,480
and

358
00:12:10,480 --> 00:12:11,920
then you can learn if your code is

359
00:12:11,920 --> 00:12:13,600
robust to that or not and you can place

360
00:12:13,600 --> 00:12:15,839
defenses where they should be and see if

361
00:12:15,839 --> 00:12:17,839
it works so that's uh there are some

362
00:12:17,839 --> 00:12:20,720
open source tools like gmc and dartanian

363
00:12:20,720 --> 00:12:23,440
that is uh they're they're nice

364
00:12:23,440 --> 00:12:25,279
so the contributions of this work are

365
00:12:25,279 --> 00:12:26,079
first

366
00:12:26,079 --> 00:12:29,839
and block based design for um

367
00:12:29,839 --> 00:12:31,040
ring buffers

368
00:12:31,040 --> 00:12:33,200
then our focus in this nq and dq

369
00:12:33,200 --> 00:12:35,040
interference

370
00:12:35,040 --> 00:12:37,440
and support for out of order operations

371
00:12:37,440 --> 00:12:39,760
in a quite simple way

372
00:12:39,760 --> 00:12:41,760
and a verified

373
00:12:41,760 --> 00:12:43,440
for weak memory model verified called

374
00:12:43,440 --> 00:12:45,519
for rickman model in a very pragmatic

375
00:12:45,519 --> 00:12:47,120
way so there are no proofs whatever is

376
00:12:47,120 --> 00:12:48,880
very pragmatic so any engineer can do

377
00:12:48,880 --> 00:12:50,160
that

378
00:12:50,160 --> 00:12:52,959
and bonus features of these uh this dpd

379
00:12:52,959 --> 00:12:55,760
sorry of the barbecue of the bbq

380
00:12:55,760 --> 00:12:58,959
is that um uh it supports several um

381
00:12:58,959 --> 00:13:01,360
scenarios like a single multi-producer

382
00:13:01,360 --> 00:13:03,519
consumer fixed size variable size

383
00:13:03,519 --> 00:13:06,560
entries there is also retry mode retry

384
00:13:06,560 --> 00:13:08,320
new and drop old this means that when

385
00:13:08,320 --> 00:13:10,560
you want to enqueue something uh you may

386
00:13:10,560 --> 00:13:11,760
return

387
00:13:11,760 --> 00:13:13,680
full if the queue is full that's retry

388
00:13:13,680 --> 00:13:16,160
new and the drop alt is overwrites the

389
00:13:16,160 --> 00:13:18,000
oldest entry if the queue is full and

390
00:13:18,000 --> 00:13:19,760
this is useful for example for tracing

391
00:13:19,760 --> 00:13:21,440
you don't want to keep the oldest one

392
00:13:21,440 --> 00:13:23,760
and you just want to update

393
00:13:23,760 --> 00:13:26,079
and we can use uh efficiently atomic

394
00:13:26,079 --> 00:13:29,600
operations like from the arm v8 dot one

395
00:13:29,600 --> 00:13:32,000
the lse instructions uh like fetch and

396
00:13:32,000 --> 00:13:33,760
add and max operations and if you have

397
00:13:33,760 --> 00:13:35,920
mac support you don't even need any cash

398
00:13:35,920 --> 00:13:37,360
in the code which is which is a cool

399
00:13:37,360 --> 00:13:38,880
feature

400
00:13:38,880 --> 00:13:41,440
okay so i told you about motivation i

401
00:13:41,440 --> 00:13:43,440
told you three stories and derived some

402
00:13:43,440 --> 00:13:45,760
challenges out of them and now i'm going

403
00:13:45,760 --> 00:13:48,639
to give you an overview of the bbq

404
00:13:48,639 --> 00:13:52,079
and how it tackles these challenges

405
00:13:52,079 --> 00:13:54,560
the idea is quite simple first

406
00:13:54,560 --> 00:13:56,560
we get this array and then we split it

407
00:13:56,560 --> 00:13:58,800
in blocks

408
00:13:58,800 --> 00:14:00,399
and now

409
00:14:00,399 --> 00:14:02,959
these blocks they have

410
00:14:02,959 --> 00:14:05,839
what we call block tail and block head

411
00:14:05,839 --> 00:14:08,399
and these points to the current

412
00:14:08,399 --> 00:14:10,240
block which the consumers can consume

413
00:14:10,240 --> 00:14:11,839
from and the current block where the

414
00:14:11,839 --> 00:14:13,920
producers can produce

415
00:14:13,920 --> 00:14:16,399
and within each block we have also tiny

416
00:14:16,399 --> 00:14:18,639
little bit metadata that's uh the entry

417
00:14:18,639 --> 00:14:20,160
tail and entry head

418
00:14:20,160 --> 00:14:22,320
so these metadata entry into head is

419
00:14:22,320 --> 00:14:23,839
actually the overhead

420
00:14:23,839 --> 00:14:25,839
in comparison to the original ring

421
00:14:25,839 --> 00:14:27,839
buffer let's say

422
00:14:27,839 --> 00:14:29,680
and these entry tail enter head will say

423
00:14:29,680 --> 00:14:32,160
which elements within that block have

424
00:14:32,160 --> 00:14:35,680
been produced or consumed

425
00:14:35,760 --> 00:14:37,360
that's it basically

426
00:14:37,360 --> 00:14:38,399
um

427
00:14:38,399 --> 00:14:39,680
and how does that help us with

428
00:14:39,680 --> 00:14:41,440
interference well imagine that we have a

429
00:14:41,440 --> 00:14:43,920
lot of loads there is a lot of entries

430
00:14:43,920 --> 00:14:45,680
in the queue the queue is quite large

431
00:14:45,680 --> 00:14:46,639
already

432
00:14:46,639 --> 00:14:48,639
so the producer and consumer will be

433
00:14:48,639 --> 00:14:50,800
working different blocks and exactly

434
00:14:50,800 --> 00:14:52,399
there where you have a lot to do you

435
00:14:52,399 --> 00:14:54,000
don't want to have interference and this

436
00:14:54,000 --> 00:14:56,240
is what this this design gives you if

437
00:14:56,240 --> 00:14:58,240
they are working different blocks then

438
00:14:58,240 --> 00:15:00,240
they will not be reading each other's

439
00:15:00,240 --> 00:15:02,079
variables they will be only reading

440
00:15:02,079 --> 00:15:03,440
inside the block the variables the

441
00:15:03,440 --> 00:15:04,639
entries and there will be no cache

442
00:15:04,639 --> 00:15:07,760
misses to slow them down

443
00:15:07,760 --> 00:15:09,680
only when they move to another block

444
00:15:09,680 --> 00:15:12,079
then they will be reading the block uh

445
00:15:12,079 --> 00:15:13,760
tail and head to compare if there is

446
00:15:13,760 --> 00:15:15,040
anything to do

447
00:15:15,040 --> 00:15:17,199
and there may be cache misses or when

448
00:15:17,199 --> 00:15:18,800
there is little to do and they are in

449
00:15:18,800 --> 00:15:20,720
the same block then they may be stepping

450
00:15:20,720 --> 00:15:22,880
on each other's feet but that's only

451
00:15:22,880 --> 00:15:24,639
when there is already anyway not so much

452
00:15:24,639 --> 00:15:27,519
to do

453
00:15:27,519 --> 00:15:28,880
now regarding in queueing queue

454
00:15:28,880 --> 00:15:30,880
interference we solve that nicely with

455
00:15:30,880 --> 00:15:33,120
the fetch and add operation as as follow

456
00:15:33,120 --> 00:15:35,839
q but we don't need to do anything about

457
00:15:35,839 --> 00:15:38,560
like fixing if we went over the bound

458
00:15:38,560 --> 00:15:40,320
this is a block it's not going to affect

459
00:15:40,320 --> 00:15:42,399
the next block so if you go over the

460
00:15:42,399 --> 00:15:44,560
bound it's fine now the thread just

461
00:15:44,560 --> 00:15:46,240
knows that the block is finished and it

462
00:15:46,240 --> 00:15:47,600
needs to move to the next one and even

463
00:15:47,600 --> 00:15:49,440
if you go way over the bound doesn't

464
00:15:49,440 --> 00:15:50,240
matter

465
00:15:50,240 --> 00:15:52,560
the thread will just move then the block

466
00:15:52,560 --> 00:15:54,079
head to the next block and start

467
00:15:54,079 --> 00:15:56,320
producing in the next next block

468
00:15:56,320 --> 00:15:58,240
and here when you move the block head

469
00:15:58,240 --> 00:16:00,079
that's exactly where we need either a

470
00:16:00,079 --> 00:16:02,560
cast or a max operation that is where

471
00:16:02,560 --> 00:16:04,320
it's a slower slightly slower than a

472
00:16:04,320 --> 00:16:06,320
fetch an ad but that's happened

473
00:16:06,320 --> 00:16:08,560
much more seldom so it's a it's a cool

474
00:16:08,560 --> 00:16:09,839
thing

475
00:16:09,839 --> 00:16:11,199
um

476
00:16:11,199 --> 00:16:13,839
now the last this last part about uh

477
00:16:13,839 --> 00:16:15,279
details of the implant of the of the

478
00:16:15,279 --> 00:16:16,320
algorithm

479
00:16:16,320 --> 00:16:18,480
how we deal with out of order operations

480
00:16:18,480 --> 00:16:20,480
in this slide i have a small legend on

481
00:16:20,480 --> 00:16:22,560
the top there is this arrow which means

482
00:16:22,560 --> 00:16:26,560
the head and we implement it as a single

483
00:16:26,560 --> 00:16:28,720
index called allocated and a counter

484
00:16:28,720 --> 00:16:30,320
called produced

485
00:16:30,320 --> 00:16:32,399
and you can read it as a

486
00:16:32,399 --> 00:16:34,079
that many produced out of that many

487
00:16:34,079 --> 00:16:35,120
located

488
00:16:35,120 --> 00:16:37,279
so let's say that we want three threads

489
00:16:37,279 --> 00:16:38,399
to

490
00:16:38,399 --> 00:16:39,839
produce something

491
00:16:39,839 --> 00:16:41,759
so they will allocate three elements

492
00:16:41,759 --> 00:16:43,519
move this pointer down but only two of

493
00:16:43,519 --> 00:16:46,320
them have finished so they increment the

494
00:16:46,320 --> 00:16:47,759
produce they don't move it's not a

495
00:16:47,759 --> 00:16:49,600
pointer it's a counter and they can

496
00:16:49,600 --> 00:16:51,120
already return this point and they are

497
00:16:51,120 --> 00:16:52,800
done so this is out of order they just

498
00:16:52,800 --> 00:16:54,240
return

499
00:16:54,240 --> 00:16:56,639
and uh let's say the second the second

500
00:16:56,639 --> 00:16:59,279
guy where you have this white uh white

501
00:16:59,279 --> 00:17:01,279
white box there uh just

502
00:17:01,279 --> 00:17:03,279
is just picking a nap

503
00:17:03,279 --> 00:17:04,959
now another inquirer may another

504
00:17:04,959 --> 00:17:06,640
producer may enqueue something and

505
00:17:06,640 --> 00:17:08,240
increments again the

506
00:17:08,240 --> 00:17:10,079
allocated and reproduced

507
00:17:10,079 --> 00:17:11,760
and if it's not enough and there's

508
00:17:11,760 --> 00:17:13,039
another uh

509
00:17:13,039 --> 00:17:15,199
set of producers arriving they may also

510
00:17:15,199 --> 00:17:16,640
allocate in the next one and continue

511
00:17:16,640 --> 00:17:18,240
producing so they won't be blocked they

512
00:17:18,240 --> 00:17:19,760
don't need to wait for anything they can

513
00:17:19,760 --> 00:17:21,839
just continue

514
00:17:21,839 --> 00:17:24,079
but the consumer

515
00:17:24,079 --> 00:17:26,079
cannot consume from that block it has if

516
00:17:26,079 --> 00:17:27,599
it has consumed all the previous blocks

517
00:17:27,599 --> 00:17:31,360
so far it will have to stop at that one

518
00:17:31,360 --> 00:17:33,760
because there is some operation ongoing

519
00:17:33,760 --> 00:17:35,360
and it does not know what to do and the

520
00:17:35,360 --> 00:17:37,280
conditions

521
00:17:37,280 --> 00:17:39,440
so what the what the consumer does it's

522
00:17:39,440 --> 00:17:42,480
written busy so that it's another error

523
00:17:42,480 --> 00:17:44,240
that it can we can give to the user then

524
00:17:44,240 --> 00:17:46,080
the user can decide whether to retry or

525
00:17:46,080 --> 00:17:48,880
to uh preempt the core or preempt the

526
00:17:48,880 --> 00:17:51,039
thread

527
00:17:51,039 --> 00:17:53,760
and the consumer will succeed when the

528
00:17:53,760 --> 00:17:56,160
block is fully full so let's say now

529
00:17:56,160 --> 00:17:57,600
it's full now the the consumer can

530
00:17:57,600 --> 00:17:58,720
consume all of that or multiple

531
00:17:58,720 --> 00:18:00,559
consumers can consume that

532
00:18:00,559 --> 00:18:03,360
or in the second case when the producers

533
00:18:03,360 --> 00:18:04,559
stopped producing anything and they

534
00:18:04,559 --> 00:18:06,080
allocated and the producers are the same

535
00:18:06,080 --> 00:18:08,400
value then this is also safe to consume

536
00:18:08,400 --> 00:18:10,160
and that is also okay

537
00:18:10,160 --> 00:18:12,400
so that's basically how we support out

538
00:18:12,400 --> 00:18:14,799
of order in queues there are many other

539
00:18:14,799 --> 00:18:16,960
cool tricks in the paper i invite you to

540
00:18:16,960 --> 00:18:18,480
take a look in the paper there are

541
00:18:18,480 --> 00:18:20,240
things like uh uh

542
00:18:20,240 --> 00:18:24,480
i i still i still have a one minute

543
00:18:24,480 --> 00:18:25,600
okay okay

544
00:18:25,600 --> 00:18:29,240
okay so uh

545
00:18:30,160 --> 00:18:31,120
yeah so

546
00:18:31,120 --> 00:18:33,039
how do we deal with uh with uh with the

547
00:18:33,039 --> 00:18:34,720
correctness of this code you can imagine

548
00:18:34,720 --> 00:18:35,440
that

549
00:18:35,440 --> 00:18:38,640
the on the left side you have a dpdk so

550
00:18:38,640 --> 00:18:40,799
the pseudo code of dpdk is very short

551
00:18:40,799 --> 00:18:42,559
and on the right side you have a part of

552
00:18:42,559 --> 00:18:45,440
this bbq code which is much longer has

553
00:18:45,440 --> 00:18:47,360
more than 20 uh atomic operations you

554
00:18:47,360 --> 00:18:48,559
need to think about the barriers of that

555
00:18:48,559 --> 00:18:51,200
code is quite complicated

556
00:18:51,200 --> 00:18:52,240
and

557
00:18:52,240 --> 00:18:55,120
so bbq is not so easy to digest

558
00:18:55,120 --> 00:18:57,760
and uh how do we ensure correctness of

559
00:18:57,760 --> 00:19:00,480
this code um we don't

560
00:19:00,480 --> 00:19:02,320
but we increase the confidence that this

561
00:19:02,320 --> 00:19:04,480
code is correct so this is a practical

562
00:19:04,480 --> 00:19:06,559
take on this verification

563
00:19:06,559 --> 00:19:09,120
so we first have done strong tests a

564
00:19:09,120 --> 00:19:11,440
long test sorry a lot of testing and

565
00:19:11,440 --> 00:19:13,840
once the test stopped failing we let it

566
00:19:13,840 --> 00:19:15,679
run for two weeks

567
00:19:15,679 --> 00:19:18,160
uh and then uh meanwhile the engineers

568
00:19:18,160 --> 00:19:20,000
sat down together with a few weak memory

569
00:19:20,000 --> 00:19:21,919
model experts we have and they came up

570
00:19:21,919 --> 00:19:24,320
with a few corner cases like the queue

571
00:19:24,320 --> 00:19:25,760
is full the queue is empty five was

572
00:19:25,760 --> 00:19:27,280
guaranteed to wrap around what happens

573
00:19:27,280 --> 00:19:28,720
when they wrap around and they they

574
00:19:28,720 --> 00:19:30,320
could implement then some tests for the

575
00:19:30,320 --> 00:19:31,520
model checker

576
00:19:31,520 --> 00:19:33,360
they gave the model tracker the c code

577
00:19:33,360 --> 00:19:34,559
to run that

578
00:19:34,559 --> 00:19:35,600
and

579
00:19:35,600 --> 00:19:37,200
they found three bugs that were not

580
00:19:37,200 --> 00:19:39,679
found with the stress testing which is a

581
00:19:39,679 --> 00:19:41,039
sign that

582
00:19:41,039 --> 00:19:42,480
this is useful

583
00:19:42,480 --> 00:19:44,720
and uh it was also reproducible in

584
00:19:44,720 --> 00:19:46,080
hardware so in retrospect it was

585
00:19:46,080 --> 00:19:47,919
possible to to build tests at the test

586
00:19:47,919 --> 00:19:49,200
cases and run that in a hardware and

587
00:19:49,200 --> 00:19:50,640
find harder as well but in retrospect

588
00:19:50,640 --> 00:19:52,960
everything is easy

589
00:19:52,960 --> 00:19:55,520
one minute for my slides of performance

590
00:19:55,520 --> 00:19:56,480
um

591
00:19:56,480 --> 00:19:57,919
so um

592
00:19:57,919 --> 00:19:59,039
the easiest

593
00:19:59,039 --> 00:20:01,440
um setup to see the the in qdq

594
00:20:01,440 --> 00:20:02,880
interference is when you have a single

595
00:20:02,880 --> 00:20:04,320
producer the same consumer and it's also

596
00:20:04,320 --> 00:20:06,880
a very useful setup because many use

597
00:20:06,880 --> 00:20:10,080
cases for that exist we have compared

598
00:20:10,080 --> 00:20:11,600
bbq with five different uh

599
00:20:11,600 --> 00:20:13,520
state-of-the-art bounded

600
00:20:13,520 --> 00:20:15,679
bounded cues and you see with this very

601
00:20:15,679 --> 00:20:17,280
very simple

602
00:20:17,280 --> 00:20:18,480
test case

603
00:20:18,480 --> 00:20:20,480
or this benchmark where you just enqueue

604
00:20:20,480 --> 00:20:22,480
a number and dequeue it there is a huge

605
00:20:22,480 --> 00:20:23,760
performance improvement but it's very

606
00:20:23,760 --> 00:20:26,160
unrealistic but it gives the point that

607
00:20:26,160 --> 00:20:28,080
it's related to the cache misses

608
00:20:28,080 --> 00:20:30,240
so that's the first outcome now if you

609
00:20:30,240 --> 00:20:32,960
get a more complex uh test case

610
00:20:32,960 --> 00:20:35,919
it still gives you uh up to two times

611
00:20:35,919 --> 00:20:37,679
higher performance than foley q which is

612
00:20:37,679 --> 00:20:40,240
an is a good queue out there

613
00:20:40,240 --> 00:20:42,640
also with uh dpdk we have end to end

614
00:20:42,640 --> 00:20:44,559
performance benchmark where we have a

615
00:20:44,559 --> 00:20:45,760
test uh

616
00:20:45,760 --> 00:20:47,440
traffic generator machine connected with

617
00:20:47,440 --> 00:20:48,799
two

618
00:20:48,799 --> 00:20:50,960
network cards to another machine

619
00:20:50,960 --> 00:20:53,679
and there it gives 1.5 the throughput in

620
00:20:53,679 --> 00:20:55,679
an end-to-end performance benchmark by

621
00:20:55,679 --> 00:20:57,039
the pdk

622
00:20:57,039 --> 00:20:59,600
and the last slide for performance

623
00:20:59,600 --> 00:21:01,200
uh we implemented this in java as well

624
00:21:01,200 --> 00:21:02,400
just to see if in another language it

625
00:21:02,400 --> 00:21:03,600
would also work

626
00:21:03,600 --> 00:21:05,440
it works much better than disruptor

627
00:21:05,440 --> 00:21:07,280
which is a famous one in java

628
00:21:07,280 --> 00:21:08,240
like three

629
00:21:08,240 --> 00:21:10,000
million operations per second instead of

630
00:21:10,000 --> 00:21:11,919
less than one

631
00:21:11,919 --> 00:21:14,480
and to conclude the presentation

632
00:21:14,480 --> 00:21:15,440
so i

633
00:21:15,440 --> 00:21:17,919
i presented to you bbq is a novel ring

634
00:21:17,919 --> 00:21:19,280
buffer design

635
00:21:19,280 --> 00:21:21,280
uh which reduces this in qdq

636
00:21:21,280 --> 00:21:23,039
interference also supports the out of

637
00:21:23,039 --> 00:21:24,720
order operations

638
00:21:24,720 --> 00:21:26,640
and we have done model checking of this

639
00:21:26,640 --> 00:21:28,960
code for weak memory models in a very

640
00:21:28,960 --> 00:21:30,400
practical way

641
00:21:30,400 --> 00:21:32,559
and it greatly out of performance

642
00:21:32,559 --> 00:21:35,440
several industrial ring buffers

643
00:21:35,440 --> 00:21:37,039
and i invite you to take a look in the

644
00:21:37,039 --> 00:21:37,919
paper

645
00:21:37,919 --> 00:21:43,000
and now i'm finally done thank you

646
00:21:48,240 --> 00:21:50,320
you

