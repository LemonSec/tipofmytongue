1
00:00:12,960 --> 00:00:14,320
all right thank you very much and thank

2
00:00:14,320 --> 00:00:15,920
you to dan my co-author for all his work

3
00:00:15,920 --> 00:00:16,960
on this too

4
00:00:16,960 --> 00:00:18,320
so i wanted to tell you about this tool

5
00:00:18,320 --> 00:00:19,840
by telling you my favorite episode of

6
00:00:19,840 --> 00:00:21,279
star trek

7
00:00:21,279 --> 00:00:23,279
so here we have captain picard and this

8
00:00:23,279 --> 00:00:25,279
is the one where captain picard is

9
00:00:25,279 --> 00:00:26,880
creating the replicator so he writes

10
00:00:26,880 --> 00:00:28,960
some code for the replicator he adds a

11
00:00:28,960 --> 00:00:30,400
module for t

12
00:00:30,400 --> 00:00:32,479
a header file c file here and now it's

13
00:00:32,479 --> 00:00:34,480
time to compile this code

14
00:00:34,480 --> 00:00:36,880
so he brings up his trusty terminal

15
00:00:36,880 --> 00:00:39,600
types in his compile command

16
00:00:39,600 --> 00:00:41,280
and he's got a program and it works just

17
00:00:41,280 --> 00:00:42,239
fine

18
00:00:42,239 --> 00:00:44,000
so like any piece of software this is

19
00:00:44,000 --> 00:00:46,000
going to grow over time

20
00:00:46,000 --> 00:00:47,520
so we started with just t we're going to

21
00:00:47,520 --> 00:00:49,360
add support for temperature so we had a

22
00:00:49,360 --> 00:00:52,079
temperature module as well

23
00:00:52,079 --> 00:00:55,039
update the replicator to use that module

24
00:00:55,039 --> 00:00:57,440
and it's time to compile again so type

25
00:00:57,440 --> 00:00:59,120
in that command

26
00:00:59,120 --> 00:01:00,719
we've got a program we can run it it

27
00:01:00,719 --> 00:01:01,760
works

28
00:01:01,760 --> 00:01:04,640
so this is fine but what if somebody

29
00:01:04,640 --> 00:01:06,560
else needs to build this software

30
00:01:06,560 --> 00:01:07,840
they don't know that command they might

31
00:01:07,840 --> 00:01:08,960
not remember it you might get

32
00:01:08,960 --> 00:01:10,240
complicated

33
00:01:10,240 --> 00:01:11,760
and so what we really need is a build

34
00:01:11,760 --> 00:01:12,799
system

35
00:01:12,799 --> 00:01:14,320
now i don't think it's going to surprise

36
00:01:14,320 --> 00:01:16,240
any of you to learn that make is still

37
00:01:16,240 --> 00:01:18,159
used in the 24th century

38
00:01:18,159 --> 00:01:20,159
uh and so picard writes this make file

39
00:01:20,159 --> 00:01:22,560
here uh so we've got some wild cards but

40
00:01:22,560 --> 00:01:24,000
it's pretty much the same thing he was

41
00:01:24,000 --> 00:01:26,640
doing before but it's written down now

42
00:01:26,640 --> 00:01:28,479
and now when it's time to build files or

43
00:01:28,479 --> 00:01:30,560
build this program we just run make

44
00:01:30,560 --> 00:01:32,159
instead so we'll add a couple more

45
00:01:32,159 --> 00:01:34,159
modules here so coffee

46
00:01:34,159 --> 00:01:36,240
we run make it runs our compilation

47
00:01:36,240 --> 00:01:37,520
command

48
00:01:37,520 --> 00:01:38,880
we add cake

49
00:01:38,880 --> 00:01:40,960
run make it runs the compilation command

50
00:01:40,960 --> 00:01:43,439
and we can keep on going and compiling

51
00:01:43,439 --> 00:01:46,000
but this has a problem

52
00:01:46,000 --> 00:01:47,600
because every single time we added one

53
00:01:47,600 --> 00:01:49,119
of these files

54
00:01:49,119 --> 00:01:51,520
all we had was this step to run and so

55
00:01:51,520 --> 00:01:53,360
every build was a full build and that

56
00:01:53,360 --> 00:01:55,439
means that as we get a larger and larger

57
00:01:55,439 --> 00:01:57,360
program our build time is going to

58
00:01:57,360 --> 00:01:58,880
increase and that's going to get old if

59
00:01:58,880 --> 00:02:00,240
all you're doing is changing one or two

60
00:02:00,240 --> 00:02:03,040
files here and there

61
00:02:03,040 --> 00:02:04,640
okay so we want a better make file that

62
00:02:04,640 --> 00:02:06,880
lets us do a better job on this build

63
00:02:06,880 --> 00:02:08,479
and so we switched to this complicated

64
00:02:08,479 --> 00:02:10,318
one that breaks out separate targets so

65
00:02:10,318 --> 00:02:12,879
we can do a nice incremental compilation

66
00:02:12,879 --> 00:02:13,920
so

67
00:02:13,920 --> 00:02:15,440
let's go make some changes and see what

68
00:02:15,440 --> 00:02:17,040
that looks like so if we edit

69
00:02:17,040 --> 00:02:18,720
replicator.c

70
00:02:18,720 --> 00:02:20,160
we run make and it's just going to

71
00:02:20,160 --> 00:02:21,840
compile that source file and link

72
00:02:21,840 --> 00:02:24,480
everything together just what we wanted

73
00:02:24,480 --> 00:02:25,920
so we'll make another change here to

74
00:02:25,920 --> 00:02:27,440
temperature

75
00:02:27,440 --> 00:02:28,959
so we've edited this file but

76
00:02:28,959 --> 00:02:31,200
unfortunately we've got a linker error

77
00:02:31,200 --> 00:02:32,879
this time and the reason we have a

78
00:02:32,879 --> 00:02:34,400
linker error

79
00:02:34,400 --> 00:02:36,480
is that there was a bug in our make file

80
00:02:36,480 --> 00:02:38,239
we missed a dependency

81
00:02:38,239 --> 00:02:40,080
so this is really easy to do with make

82
00:02:40,080 --> 00:02:41,519
files

83
00:02:41,519 --> 00:02:43,040
and it tells us about two sort of

84
00:02:43,040 --> 00:02:44,959
important properties of make files or of

85
00:02:44,959 --> 00:02:47,680
any build system that we want to have

86
00:02:47,680 --> 00:02:49,200
all right so build systems need to be

87
00:02:49,200 --> 00:02:51,599
correct and by correct what i mean is

88
00:02:51,599 --> 00:02:53,599
that they don't miss dependencies

89
00:02:53,599 --> 00:02:54,480
because they're going to do the wrong

90
00:02:54,480 --> 00:02:56,000
thing if you do

91
00:02:56,000 --> 00:02:57,360
and your incremental builds are going to

92
00:02:57,360 --> 00:02:58,160
be

93
00:02:58,160 --> 00:02:59,760
consistent with what a full build would

94
00:02:59,760 --> 00:03:00,800
have done you don't want those to be

95
00:03:00,800 --> 00:03:01,920
different from each other that's how you

96
00:03:01,920 --> 00:03:03,280
get bugs

97
00:03:03,280 --> 00:03:05,519
but we also want them to be fast

98
00:03:05,519 --> 00:03:06,720
so they should do as little work as

99
00:03:06,720 --> 00:03:09,360
possible but not less than that

100
00:03:09,360 --> 00:03:11,280
and these two things are in tension with

101
00:03:11,280 --> 00:03:12,560
makefiles

102
00:03:12,560 --> 00:03:13,920
so i'm here to tell you today that there

103
00:03:13,920 --> 00:03:15,920
is a better way to do this

104
00:03:15,920 --> 00:03:18,480
and that better way is riker

105
00:03:18,480 --> 00:03:20,800
so so with riker

106
00:03:20,800 --> 00:03:22,879
what you can do is take your complicated

107
00:03:22,879 --> 00:03:25,040
makefile and throw it away

108
00:03:25,040 --> 00:03:27,040
and write this build specification this

109
00:03:27,040 --> 00:03:29,120
is a riker file it's the exact same

110
00:03:29,120 --> 00:03:30,720
command that picard was typing into his

111
00:03:30,720 --> 00:03:32,319
terminal to build the tool in the first

112
00:03:32,319 --> 00:03:33,840
place

113
00:03:33,840 --> 00:03:36,640
but from this simple build specification

114
00:03:36,640 --> 00:03:38,720
riker can automatically run a fast

115
00:03:38,720 --> 00:03:40,799
incremental build and it's correct

116
00:03:40,799 --> 00:03:44,319
because it doesn't miss dependencies

117
00:03:45,120 --> 00:03:47,120
okay so we we've seen that there are

118
00:03:47,120 --> 00:03:49,120
some problems with make

119
00:03:49,120 --> 00:03:50,560
so that's covered

120
00:03:50,560 --> 00:03:51,920
i'm going to show you next what it looks

121
00:03:51,920 --> 00:03:54,080
like to actually use riker

122
00:03:54,080 --> 00:03:55,680
we'll talk about how riker works once

123
00:03:55,680 --> 00:03:56,959
we've seen that

124
00:03:56,959 --> 00:03:58,560
and i'll show you some of our evaluation

125
00:03:58,560 --> 00:04:01,760
from the paper

126
00:04:01,760 --> 00:04:05,439
okay so first up how do we use riker

127
00:04:05,439 --> 00:04:08,000
so if we go back to picard's example

128
00:04:08,000 --> 00:04:10,799
he's going to use this simple riker file

129
00:04:10,799 --> 00:04:12,080
and we'll bring up the terminal and make

130
00:04:12,080 --> 00:04:12,840
some

131
00:04:12,840 --> 00:04:14,879
changes so

132
00:04:14,879 --> 00:04:16,079
um

133
00:04:16,079 --> 00:04:17,199
sorry we haven't changed anything yet

134
00:04:17,199 --> 00:04:19,600
we're running a full build so when i run

135
00:04:19,600 --> 00:04:21,918
this first riker build

136
00:04:21,918 --> 00:04:23,759
what riker does is it executes the riker

137
00:04:23,759 --> 00:04:24,800
file

138
00:04:24,800 --> 00:04:26,400
and we saw in that riker file there was

139
00:04:26,400 --> 00:04:27,919
this gcc command and so we're going to

140
00:04:27,919 --> 00:04:29,680
run that this all looks very familiar

141
00:04:29,680 --> 00:04:31,040
but that's not actually the end of the

142
00:04:31,040 --> 00:04:33,759
process because gcc is a compiler driver

143
00:04:33,759 --> 00:04:35,520
and it will kick off the c compiler to

144
00:04:35,520 --> 00:04:37,520
generate some assembly the assembler to

145
00:04:37,520 --> 00:04:39,600
turn that into a dot o file and do that

146
00:04:39,600 --> 00:04:41,520
for the next source file and the next

147
00:04:41,520 --> 00:04:44,000
source file and so on and eventually

148
00:04:44,000 --> 00:04:45,440
it's going to link these all together

149
00:04:45,440 --> 00:04:47,680
into the final program and riker sees

150
00:04:47,680 --> 00:04:49,280
all of these executions during that

151
00:04:49,280 --> 00:04:51,520
build

152
00:04:51,520 --> 00:04:53,120
now if we go in and edit a file like

153
00:04:53,120 --> 00:04:54,960
this temperature module that caused the

154
00:04:54,960 --> 00:04:58,240
problem before we run riker again

155
00:04:58,240 --> 00:04:59,520
it's not going to run the whole build

156
00:04:59,520 --> 00:05:00,960
it's just going to compile the source

157
00:05:00,960 --> 00:05:03,040
files that use this header file

158
00:05:03,040 --> 00:05:05,840
so replicator.c and temp.c

159
00:05:05,840 --> 00:05:07,840
and since those change.o files it's

160
00:05:07,840 --> 00:05:09,919
going to link the whole program together

161
00:05:09,919 --> 00:05:11,360
so we're getting nice incremental build

162
00:05:11,360 --> 00:05:13,039
performance out of this

163
00:05:13,039 --> 00:05:14,160
but

164
00:05:14,160 --> 00:05:16,000
how does riker get from that simple

165
00:05:16,000 --> 00:05:17,440
specification

166
00:05:17,440 --> 00:05:19,280
to a nice incremental build that you

167
00:05:19,280 --> 00:05:21,600
didn't have to write down

168
00:05:21,600 --> 00:05:23,120
so that's what we'll talk about next how

169
00:05:23,120 --> 00:05:24,479
riker works

170
00:05:24,479 --> 00:05:26,160
so just at a high level stepping back

171
00:05:26,160 --> 00:05:27,680
from the details

172
00:05:27,680 --> 00:05:29,440
there's sort of three important pieces

173
00:05:29,440 --> 00:05:31,680
of how riker works so the first is that

174
00:05:31,680 --> 00:05:33,360
it's going to run your build script the

175
00:05:33,360 --> 00:05:35,120
specification that you write

176
00:05:35,120 --> 00:05:36,560
and that rekord file i showed you was a

177
00:05:36,560 --> 00:05:38,400
script it can actually be anything

178
00:05:38,400 --> 00:05:39,840
executable you could write a c program

179
00:05:39,840 --> 00:05:41,600
that builds your your program if you

180
00:05:41,600 --> 00:05:43,440
feel like suffering

181
00:05:43,440 --> 00:05:45,759
but while it runs that riker will watch

182
00:05:45,759 --> 00:05:47,919
this execution and observe all of the

183
00:05:47,919 --> 00:05:49,440
system calls that are issued during the

184
00:05:49,440 --> 00:05:50,639
build

185
00:05:50,639 --> 00:05:52,479
and riker takes those system calls and

186
00:05:52,479 --> 00:05:54,560
generates a representation of them in a

187
00:05:54,560 --> 00:05:57,360
language we created called trace ir

188
00:05:57,360 --> 00:05:58,800
and this encodes important information

189
00:05:58,800 --> 00:05:59,919
about how the build worked and we'll

190
00:05:59,919 --> 00:06:02,160
talk about that in a moment

191
00:06:02,160 --> 00:06:04,720
and riker evaluates that trace ir to

192
00:06:04,720 --> 00:06:06,319
update the build and as part of that

193
00:06:06,319 --> 00:06:08,000
evaluation process

194
00:06:08,000 --> 00:06:09,520
some of the commands in the build go

195
00:06:09,520 --> 00:06:11,280
back and re-execute where they are

196
00:06:11,280 --> 00:06:13,520
traced and turned into trace ir again

197
00:06:13,520 --> 00:06:15,919
and again

198
00:06:16,400 --> 00:06:17,919
okay so let's look at the system call

199
00:06:17,919 --> 00:06:20,720
tracing so the build is running along

200
00:06:20,720 --> 00:06:23,199
and riker will capture an exact system

201
00:06:23,199 --> 00:06:24,720
call for example

202
00:06:24,720 --> 00:06:26,880
we do this using p trace to make sure we

203
00:06:26,880 --> 00:06:29,120
catch everything but we use second bpf

204
00:06:29,120 --> 00:06:30,880
to make it a little faster and an

205
00:06:30,880 --> 00:06:32,560
injected library to make it quite a bit

206
00:06:32,560 --> 00:06:33,600
faster

207
00:06:33,600 --> 00:06:36,319
but we don't miss system calls

208
00:06:36,319 --> 00:06:39,120
so when we have an exec ryker denotes

209
00:06:39,120 --> 00:06:40,880
this as a command and so the first

210
00:06:40,880 --> 00:06:42,960
command in our build is this riker file

211
00:06:42,960 --> 00:06:44,479
which i'll show you as this little

212
00:06:44,479 --> 00:06:46,400
circle at the top here

213
00:06:46,400 --> 00:06:48,880
and the record file launches gcc and we

214
00:06:48,880 --> 00:06:50,720
denote the launch with this dotted arrow

215
00:06:50,720 --> 00:06:53,840
connecting the riker file to gcc

216
00:06:53,840 --> 00:06:56,400
and gcc kicks off the first c compiler

217
00:06:56,400 --> 00:06:57,680
so this is where things get interesting

218
00:06:57,680 --> 00:06:59,759
so the c compiler is going to

219
00:06:59,759 --> 00:07:01,599
open and read

220
00:07:01,599 --> 00:07:03,120
a source file

221
00:07:03,120 --> 00:07:05,919
and so we intercept an open system call

222
00:07:05,919 --> 00:07:08,319
that's a reference to a file and so now

223
00:07:08,319 --> 00:07:10,000
we keep track of that file as an input

224
00:07:10,000 --> 00:07:13,280
to the c compiler

225
00:07:13,280 --> 00:07:15,759
and later we create a file by opening it

226
00:07:15,759 --> 00:07:18,160
and writing to it

227
00:07:18,160 --> 00:07:19,440
so this proceeds again with the

228
00:07:19,440 --> 00:07:21,199
assembler the assembly is going to read

229
00:07:21,199 --> 00:07:23,360
that temporary assembly file and write

230
00:07:23,360 --> 00:07:25,440
out to a dot o file

231
00:07:25,440 --> 00:07:27,360
and if we let this build complete many

232
00:07:27,360 --> 00:07:29,120
system calls later

233
00:07:29,120 --> 00:07:30,400
what we end up with is a graph that

234
00:07:30,400 --> 00:07:32,720
looks a little bit like this

235
00:07:32,720 --> 00:07:34,240
so i've left a lot of things off because

236
00:07:34,240 --> 00:07:35,280
real builds are quite a bit more

237
00:07:35,280 --> 00:07:36,800
complicated but these are the big pieces

238
00:07:36,800 --> 00:07:37,919
that matter

239
00:07:37,919 --> 00:07:39,440
and you can think of this as a build

240
00:07:39,440 --> 00:07:40,880
dependence graph and this is something

241
00:07:40,880 --> 00:07:43,039
that people have used in build systems

242
00:07:43,039 --> 00:07:45,039
before it's a lot like what you're

243
00:07:45,039 --> 00:07:46,240
writing down when you write an

244
00:07:46,240 --> 00:07:48,319
incremental makefile but these have some

245
00:07:48,319 --> 00:07:50,400
important problems

246
00:07:50,400 --> 00:07:51,919
so the first one is that intermediate

247
00:07:51,919 --> 00:07:54,080
state is really important

248
00:07:54,080 --> 00:07:57,120
so this temp.s file is the output from

249
00:07:57,120 --> 00:07:59,199
all of the c compilers and the input to

250
00:07:59,199 --> 00:08:01,759
all of the assembler invocations and gcc

251
00:08:01,759 --> 00:08:03,680
actually does this and it's really

252
00:08:03,680 --> 00:08:05,599
important that we know which state that

253
00:08:05,599 --> 00:08:08,080
file was in when each command ran so

254
00:08:08,080 --> 00:08:09,520
that first is shouldn't be seeing the

255
00:08:09,520 --> 00:08:12,080
output from the third c compiler

256
00:08:12,080 --> 00:08:13,919
and the graph doesn't capture any of

257
00:08:13,919 --> 00:08:16,960
that ordering information for us

258
00:08:16,960 --> 00:08:18,879
the next is that there are cycles

259
00:08:18,879 --> 00:08:21,599
so gcc builds even a hello world build

260
00:08:21,599 --> 00:08:23,280
will launch a program called collect2

261
00:08:23,280 --> 00:08:25,680
that runs the linker and it consumes the

262
00:08:25,680 --> 00:08:27,520
output from the linker to decide whether

263
00:08:27,520 --> 00:08:29,440
it needs to run the linker again

264
00:08:29,440 --> 00:08:31,360
and we have this feedback loop and if we

265
00:08:31,360 --> 00:08:32,958
don't know something about the order of

266
00:08:32,958 --> 00:08:34,719
those checks we might find ourselves

267
00:08:34,719 --> 00:08:37,039
executing things indefinitely and so we

268
00:08:37,039 --> 00:08:37,839
have to know something about the

269
00:08:37,839 --> 00:08:39,760
sequencing there

270
00:08:39,760 --> 00:08:41,039
and then the last problem is one that

271
00:08:41,039 --> 00:08:42,320
doesn't appear on the graph at all which

272
00:08:42,320 --> 00:08:44,560
is anti-dependencies so a command can

273
00:08:44,560 --> 00:08:46,640
depend on a file not existing just as

274
00:08:46,640 --> 00:08:48,080
much as it can depend on the contents of

275
00:08:48,080 --> 00:08:50,080
that file and that's an important stage

276
00:08:50,080 --> 00:08:51,519
in any build and we'll see an example of

277
00:08:51,519 --> 00:08:55,040
where that matters later

278
00:08:55,040 --> 00:08:56,720
all right so trace ir the language that

279
00:08:56,720 --> 00:08:58,480
we created for riker solves all of these

280
00:08:58,480 --> 00:08:59,519
problems

281
00:08:59,519 --> 00:09:02,240
so what is trace ir

282
00:09:02,240 --> 00:09:03,680
well we'll go back to

283
00:09:03,680 --> 00:09:05,600
our example in a little bit but traceair

284
00:09:05,600 --> 00:09:08,080
is a language as i mentioned before

285
00:09:08,080 --> 00:09:09,279
and it doesn't have any loops or

286
00:09:09,279 --> 00:09:11,680
branches but we can still execute it

287
00:09:11,680 --> 00:09:13,839
what it records is really two broad

288
00:09:13,839 --> 00:09:16,480
categories of things so tracear keeps

289
00:09:16,480 --> 00:09:18,320
track of the observed system state

290
00:09:18,320 --> 00:09:20,399
during the build so that means file

291
00:09:20,399 --> 00:09:23,120
metadata content directory entries pipe

292
00:09:23,120 --> 00:09:25,120
contents exit codes from commands and

293
00:09:25,120 --> 00:09:26,560
much more

294
00:09:26,560 --> 00:09:27,760
it also

295
00:09:27,760 --> 00:09:30,560
records updates to system state so if a

296
00:09:30,560 --> 00:09:32,320
command changes the file's metadata

297
00:09:32,320 --> 00:09:34,160
rights to its content

298
00:09:34,160 --> 00:09:35,680
updates the contents of a directory by

299
00:09:35,680 --> 00:09:37,519
deleting or adding something

300
00:09:37,519 --> 00:09:39,440
and more all of those are recorded in

301
00:09:39,440 --> 00:09:42,080
trace ir

302
00:09:42,160 --> 00:09:44,480
so if we jump back to our example build

303
00:09:44,480 --> 00:09:46,240
we're running this program

304
00:09:46,240 --> 00:09:48,000
we intercept a system call so in this

305
00:09:48,000 --> 00:09:51,600
case we saw an exec of bin gcc

306
00:09:51,600 --> 00:09:53,600
and the trace ir that comes out of this

307
00:09:53,600 --> 00:09:54,959
that riker generates from that system

308
00:09:54,959 --> 00:09:55,760
call

309
00:09:55,760 --> 00:09:57,200
has a few steps so the first is that it

310
00:09:57,200 --> 00:09:58,880
says oh okay there's a reference to the

311
00:09:58,880 --> 00:10:00,880
bin gcc path

312
00:10:00,880 --> 00:10:01,920
and

313
00:10:01,920 --> 00:10:03,680
that file doesn't exist and so riker

314
00:10:03,680 --> 00:10:05,839
will actually record that there was no

315
00:10:05,839 --> 00:10:07,360
file there and we expect there not to be

316
00:10:07,360 --> 00:10:09,120
a file there if there was that would be

317
00:10:09,120 --> 00:10:11,279
a change

318
00:10:11,279 --> 00:10:12,160
and

319
00:10:12,160 --> 00:10:13,600
the shell is going to continue searching

320
00:10:13,600 --> 00:10:14,880
through your path environment variable

321
00:10:14,880 --> 00:10:16,160
and so the next thing it will do is try

322
00:10:16,160 --> 00:10:18,720
to exec user bin gcc and so there's

323
00:10:18,720 --> 00:10:20,959
another reference to a path and this

324
00:10:20,959 --> 00:10:22,399
time this one exists so we record that

325
00:10:22,399 --> 00:10:24,880
that is a successful reference

326
00:10:24,880 --> 00:10:26,880
once it finds that file it actually

327
00:10:26,880 --> 00:10:29,120
launches a command so trace ir records

328
00:10:29,120 --> 00:10:32,320
the launch of that command in its output

329
00:10:32,320 --> 00:10:34,079
and then the build can proceed

330
00:10:34,079 --> 00:10:36,720
so if we jump ahead a little ways

331
00:10:36,720 --> 00:10:38,560
we can look at where one of our c

332
00:10:38,560 --> 00:10:41,839
compiler steps actually opens a file

333
00:10:41,839 --> 00:10:44,959
so the c compiler will open source1.c in

334
00:10:44,959 --> 00:10:46,800
read-only mode

335
00:10:46,800 --> 00:10:48,480
it expects that to be successful because

336
00:10:48,480 --> 00:10:51,200
that's what we observe during the build

337
00:10:51,200 --> 00:10:52,880
and presumably it's going to read from

338
00:10:52,880 --> 00:10:55,279
this file so there's a read system call

339
00:10:55,279 --> 00:10:57,440
and riker records that interact as a

340
00:10:57,440 --> 00:10:59,360
match content predicate so this is

341
00:10:59,360 --> 00:11:01,120
saying we expect that file to have

342
00:11:01,120 --> 00:11:03,279
content with this hash

343
00:11:03,279 --> 00:11:07,040
so i've abbreviated the hash there

344
00:11:07,200 --> 00:11:09,200
there also writes so sometimes we open a

345
00:11:09,200 --> 00:11:11,120
file for writing and we might create and

346
00:11:11,120 --> 00:11:13,360
truncate the file

347
00:11:13,360 --> 00:11:15,760
so that's a path ref as well to this

348
00:11:15,760 --> 00:11:17,839
temporary assembly file

349
00:11:17,839 --> 00:11:19,360
and it's been annotated as read write

350
00:11:19,360 --> 00:11:20,800
but also that it will create the file if

351
00:11:20,800 --> 00:11:22,640
it doesn't exist or truncate it if it

352
00:11:22,640 --> 00:11:24,480
did

353
00:11:24,480 --> 00:11:26,240
and we expect that to succeed because

354
00:11:26,240 --> 00:11:27,519
most of the time this is going to work

355
00:11:27,519 --> 00:11:28,880
out that's what we'll observe when we

356
00:11:28,880 --> 00:11:30,800
run our build

357
00:11:30,800 --> 00:11:32,240
and once it's been opened when the

358
00:11:32,240 --> 00:11:34,000
command writes to the file a write

359
00:11:34,000 --> 00:11:35,920
creates a dependency on the old content

360
00:11:35,920 --> 00:11:38,079
of the file in this case it was empty

361
00:11:38,079 --> 00:11:40,320
and an update to the new content with a

362
00:11:40,320 --> 00:11:42,640
new hash and you can see here that that

363
00:11:42,640 --> 00:11:44,320
file is actually being cached by riker

364
00:11:44,320 --> 00:11:47,440
that's important later too

365
00:11:47,760 --> 00:11:49,279
so last example of this that i'd like to

366
00:11:49,279 --> 00:11:50,240
show you

367
00:11:50,240 --> 00:11:52,240
is for command interactions

368
00:11:52,240 --> 00:11:52,959
so

369
00:11:52,959 --> 00:11:54,320
when our assembler is finished it's

370
00:11:54,320 --> 00:11:55,920
going to exit we'll say it exits with

371
00:11:55,920 --> 00:11:57,360
exit code 0.

372
00:11:57,360 --> 00:11:59,680
so trace ir has an exit statement in its

373
00:11:59,680 --> 00:12:01,760
language as well

374
00:12:01,760 --> 00:12:03,760
and the parent gcc in this case is

375
00:12:03,760 --> 00:12:06,079
waiting for that command to exit

376
00:12:06,079 --> 00:12:08,880
and it expresses that with a join

377
00:12:08,880 --> 00:12:10,720
but it also sets an expectation about

378
00:12:10,720 --> 00:12:12,639
the exit code of that child process and

379
00:12:12,639 --> 00:12:14,079
so if that were ever to change we would

380
00:12:14,079 --> 00:12:15,600
want to know about it and so trace ir

381
00:12:15,600 --> 00:12:18,639
records that information

382
00:12:19,200 --> 00:12:20,320
okay so we run through this whole

383
00:12:20,320 --> 00:12:22,160
process we generate a bunch of trace ir

384
00:12:22,160 --> 00:12:24,240
for a full build how can we actually use

385
00:12:24,240 --> 00:12:27,200
that to run the next build

386
00:12:27,200 --> 00:12:28,800
that's where the build algorithm comes

387
00:12:28,800 --> 00:12:30,079
in

388
00:12:30,079 --> 00:12:32,480
so as i said trace ir is a language so

389
00:12:32,480 --> 00:12:33,600
what we're going to do with our language

390
00:12:33,600 --> 00:12:35,360
is actually run it or we have a program

391
00:12:35,360 --> 00:12:37,680
in our language we'll run it

392
00:12:37,680 --> 00:12:40,399
so the predicates that are in trace ir

393
00:12:40,399 --> 00:12:42,240
like expect result match content match

394
00:12:42,240 --> 00:12:45,120
metadata those all detect changes that

395
00:12:45,120 --> 00:12:48,320
are observed during the build

396
00:12:48,320 --> 00:12:50,480
and then the state updates like update

397
00:12:50,480 --> 00:12:53,120
content update metadata exit those all

398
00:12:53,120 --> 00:12:54,639
describe the effects of a command

399
00:12:54,639 --> 00:12:56,959
running

400
00:12:58,560 --> 00:13:00,480
so if we jump back to our flawed but

401
00:13:00,480 --> 00:13:02,800
easier to look at graph representation i

402
00:13:02,800 --> 00:13:04,320
like to actually run through what some

403
00:13:04,320 --> 00:13:06,399
changes will do to an incremental build

404
00:13:06,399 --> 00:13:07,760
so let's say for the sake of example

405
00:13:07,760 --> 00:13:11,200
that we've changed source2.c here

406
00:13:11,200 --> 00:13:12,720
so as i said we're going to evaluate the

407
00:13:12,720 --> 00:13:14,560
full trace ir program that we collected

408
00:13:14,560 --> 00:13:16,160
from that first build

409
00:13:16,160 --> 00:13:18,480
and when we do that we'll at some point

410
00:13:18,480 --> 00:13:21,279
reach these pathrefs to source2.c

411
00:13:21,279 --> 00:13:22,399
there's an expectation that that

412
00:13:22,399 --> 00:13:24,240
succeeds and there's a match content

413
00:13:24,240 --> 00:13:25,360
predicate

414
00:13:25,360 --> 00:13:27,519
and this is going to be an observed

415
00:13:27,519 --> 00:13:30,320
change so we know cc1 will see that and

416
00:13:30,320 --> 00:13:31,680
that's important

417
00:13:31,680 --> 00:13:33,839
so now we know that cc1 will observe a

418
00:13:33,839 --> 00:13:35,200
change

419
00:13:35,200 --> 00:13:38,800
so we probably need to run that program

420
00:13:38,800 --> 00:13:40,720
you might think that we could say temp.s

421
00:13:40,720 --> 00:13:42,160
is going to change because we're running

422
00:13:42,160 --> 00:13:44,160
the program that produced it

423
00:13:44,160 --> 00:13:45,680
but actually we don't know anything

424
00:13:45,680 --> 00:13:48,240
about what cc1 is going to do we all

425
00:13:48,240 --> 00:13:49,839
only know what it did the last time we

426
00:13:49,839 --> 00:13:51,360
ran it we make no assumptions about what

427
00:13:51,360 --> 00:13:53,040
it will do the next time and so we're

428
00:13:53,040 --> 00:13:54,480
going to hold off on deciding whether or

429
00:13:54,480 --> 00:13:55,920
not this file has changed until we've

430
00:13:55,920 --> 00:13:58,240
actually seen what cc1 does

431
00:13:58,240 --> 00:13:59,600
so we're not going to propagate our way

432
00:13:59,600 --> 00:14:01,680
down this graph

433
00:14:01,680 --> 00:14:03,680
so we've decided that cc1 needs to run

434
00:14:03,680 --> 00:14:05,279
it sees a change

435
00:14:05,279 --> 00:14:07,600
but we can't actually run cc1 all by

436
00:14:07,600 --> 00:14:08,800
itself

437
00:14:08,800 --> 00:14:10,240
it could depend on output from other

438
00:14:10,240 --> 00:14:11,920
commands that needs to be in place maybe

439
00:14:11,920 --> 00:14:13,199
it's only there during the build and

440
00:14:13,199 --> 00:14:15,680
it's cleaned up afterward or as we see

441
00:14:15,680 --> 00:14:17,920
in this case it needs to put its output

442
00:14:17,920 --> 00:14:20,000
in temp.s before

443
00:14:20,000 --> 00:14:22,399
the second as accesses it not the first

444
00:14:22,399 --> 00:14:24,800
or the third

445
00:14:24,800 --> 00:14:26,720
so that's an important step that we have

446
00:14:26,720 --> 00:14:28,560
to keep track of

447
00:14:28,560 --> 00:14:30,959
so we need to set up for a command to

448
00:14:30,959 --> 00:14:33,199
execute by putting all of its inputs in

449
00:14:33,199 --> 00:14:35,440
place and then once we've executed it we

450
00:14:35,440 --> 00:14:37,680
need to run the rest of the build after

451
00:14:37,680 --> 00:14:39,680
that to understand how those changes in

452
00:14:39,680 --> 00:14:41,600
output affect the build

453
00:14:41,600 --> 00:14:42,880
and we already have a way to do that

454
00:14:42,880 --> 00:14:45,279
that's that's what trace ir is for

455
00:14:45,279 --> 00:14:47,040
so actually our second iteration of this

456
00:14:47,040 --> 00:14:49,040
build we're going to evaluate the entire

457
00:14:49,040 --> 00:14:51,519
trace ir program for the full build with

458
00:14:51,519 --> 00:14:53,760
the exception of cc1 which we will

459
00:14:53,760 --> 00:14:55,360
instead execute

460
00:14:55,360 --> 00:14:57,120
and we'll trace that execution and we're

461
00:14:57,120 --> 00:14:58,959
going to insert that new trace ir into

462
00:14:58,959 --> 00:15:00,880
that the program that describes the full

463
00:15:00,880 --> 00:15:03,120
build

464
00:15:03,600 --> 00:15:05,440
so when that's done

465
00:15:05,440 --> 00:15:09,040
as predicted temp.s is now changed

466
00:15:09,040 --> 00:15:11,279
and because we evaluated the trace ir

467
00:15:11,279 --> 00:15:13,920
after cc1 ran we had a predicate that

468
00:15:13,920 --> 00:15:16,000
didn't check out and we know that as the

469
00:15:16,000 --> 00:15:18,160
second one has observed the change

470
00:15:18,160 --> 00:15:20,240
because of cc one's output

471
00:15:20,240 --> 00:15:21,839
and so

472
00:15:21,839 --> 00:15:23,600
it's important because we kept track of

473
00:15:23,600 --> 00:15:25,120
the order of these interactions in the

474
00:15:25,120 --> 00:15:26,880
trace ir program that we know it was

475
00:15:26,880 --> 00:15:28,880
only the second as that saw that change

476
00:15:28,880 --> 00:15:31,680
the others were unchanged

477
00:15:31,680 --> 00:15:32,959
so we're going to run the full trace ir

478
00:15:32,959 --> 00:15:34,320
program again but this time we'll be

479
00:15:34,320 --> 00:15:36,320
executing as

480
00:15:36,320 --> 00:15:39,120
and the dot o file changes and so we

481
00:15:39,120 --> 00:15:41,440
know we need to run ld

482
00:15:41,440 --> 00:15:42,320
and

483
00:15:42,320 --> 00:15:43,680
so we're going to run the full trace ir

484
00:15:43,680 --> 00:15:45,519
program but we will be executing ld in

485
00:15:45,519 --> 00:15:46,639
this case

486
00:15:46,639 --> 00:15:48,160
and this is where caching is important

487
00:15:48,160 --> 00:15:49,920
so riker has cached these outputs that

488
00:15:49,920 --> 00:15:51,920
were generated by commands that executed

489
00:15:51,920 --> 00:15:54,079
and so it can stage them in at the time

490
00:15:54,079 --> 00:15:55,279
when those commands would have been

491
00:15:55,279 --> 00:15:56,800
executing even though riker didn't

492
00:15:56,800 --> 00:15:58,240
actually run them

493
00:15:58,240 --> 00:16:00,240
and that allows ld to proceed and update

494
00:16:00,240 --> 00:16:01,600
the program

495
00:16:01,600 --> 00:16:03,440
so now we've made it all the way through

496
00:16:03,440 --> 00:16:05,839
the full build trace ir execution and we

497
00:16:05,839 --> 00:16:07,839
didn't detect any new changes so that

498
00:16:07,839 --> 00:16:10,959
means the build is complete

499
00:16:11,440 --> 00:16:13,120
so to just step back and summarize that

500
00:16:13,120 --> 00:16:14,720
at a high level the record build

501
00:16:14,720 --> 00:16:17,519
algorithm is to always run the fill full

502
00:16:17,519 --> 00:16:18,800
build

503
00:16:18,800 --> 00:16:21,199
using recorded trace ir for commands

504
00:16:21,199 --> 00:16:23,519
that haven't observed changes

505
00:16:23,519 --> 00:16:25,360
and directly executing the commands that

506
00:16:25,360 --> 00:16:27,120
do observe those changes

507
00:16:27,120 --> 00:16:28,720
and you just keep doing this until you

508
00:16:28,720 --> 00:16:29,920
get all the way through it without

509
00:16:29,920 --> 00:16:32,240
finding any new changes

510
00:16:32,240 --> 00:16:33,279
i will note that there are some

511
00:16:33,279 --> 00:16:35,040
situations where we run additional

512
00:16:35,040 --> 00:16:36,480
commands but you'll have to see the

513
00:16:36,480 --> 00:16:38,000
paper or ask a question to find out

514
00:16:38,000 --> 00:16:40,480
about those

515
00:16:41,040 --> 00:16:43,759
okay so how how well does reicher work

516
00:16:43,759 --> 00:16:44,800
so

517
00:16:44,800 --> 00:16:46,399
we want to know some important things

518
00:16:46,399 --> 00:16:48,240
about riker's performance but there are

519
00:16:48,240 --> 00:16:50,480
different situations that matter here so

520
00:16:50,480 --> 00:16:52,240
first up is full builds these aren't the

521
00:16:52,240 --> 00:16:54,079
common case but it's the first build

522
00:16:54,079 --> 00:16:55,519
you're going to run it's probably going

523
00:16:55,519 --> 00:16:57,199
to be the one that takes the longest so

524
00:16:57,199 --> 00:16:59,680
how well does riker do on those

525
00:16:59,680 --> 00:17:01,600
we also care about no op builds so these

526
00:17:01,600 --> 00:17:03,759
are builds where nothing actually needs

527
00:17:03,759 --> 00:17:05,520
to run to update the build how quickly

528
00:17:05,520 --> 00:17:07,359
can riker decide that nothing needs to

529
00:17:07,359 --> 00:17:09,039
run i do these a lot myself i'd like

530
00:17:09,039 --> 00:17:11,199
that to not take forever

531
00:17:11,199 --> 00:17:12,319
and then the third one which i'm going

532
00:17:12,319 --> 00:17:14,400
to focus most of my time on here is

533
00:17:14,400 --> 00:17:15,839
incremental build so you've made some

534
00:17:15,839 --> 00:17:17,359
small set of changes

535
00:17:17,359 --> 00:17:18,959
how well can riker do it upgrade

536
00:17:18,959 --> 00:17:20,959
updating that build

537
00:17:20,959 --> 00:17:22,160
doing the minimum amount of work

538
00:17:22,160 --> 00:17:24,559
possible

539
00:17:24,799 --> 00:17:26,480
so if we take a look at our results for

540
00:17:26,480 --> 00:17:27,760
full builds

541
00:17:27,760 --> 00:17:29,520
we have these 14 programs which we built

542
00:17:29,520 --> 00:17:31,520
using riker and what we're doing is

543
00:17:31,520 --> 00:17:33,520
running the entire build with riker's

544
00:17:33,520 --> 00:17:35,440
tracing trace ir generation all of the

545
00:17:35,440 --> 00:17:37,280
various change detection and potential

546
00:17:37,280 --> 00:17:39,520
iteration happening in that build

547
00:17:39,520 --> 00:17:41,200
and you can see that the overhead is

548
00:17:41,200 --> 00:17:42,480
generally low but there are a few

549
00:17:42,480 --> 00:17:43,919
outliers here

550
00:17:43,919 --> 00:17:47,280
so the median overhead is 8.8 percent

551
00:17:47,280 --> 00:17:48,880
and the median additional build time

552
00:17:48,880 --> 00:17:50,000
which is on a different set of

553
00:17:50,000 --> 00:17:52,160
benchmarks is just 1.2 seconds and

554
00:17:52,160 --> 00:17:53,760
that's actually because larger builds

555
00:17:53,760 --> 00:17:56,480
have lower overhead with riker

556
00:17:56,480 --> 00:17:58,240
case in point we have these two outliers

557
00:17:58,240 --> 00:18:00,400
here auto configure utils are kind of

558
00:18:00,400 --> 00:18:02,960
the worst case for riker it does a lot

559
00:18:02,960 --> 00:18:04,720
of tiny compilations and so there's lots

560
00:18:04,720 --> 00:18:06,559
of tracing overhead setting up tracing

561
00:18:06,559 --> 00:18:08,320
for new processes and not a whole lot of

562
00:18:08,320 --> 00:18:09,919
work that happens between those tracing

563
00:18:09,919 --> 00:18:11,440
events

564
00:18:11,440 --> 00:18:14,960
the five longest builds that run are

565
00:18:14,960 --> 00:18:17,120
some of the lowest overhead the largest

566
00:18:17,120 --> 00:18:18,720
of those is protobuf in terms of

567
00:18:18,720 --> 00:18:20,320
overhead that's about eight percent and

568
00:18:20,320 --> 00:18:22,240
the longest running build is llvm and

569
00:18:22,240 --> 00:18:23,840
that only has four percent overhead with

570
00:18:23,840 --> 00:18:25,679
rikers tracing and modeling and all of

571
00:18:25,679 --> 00:18:27,679
that

572
00:18:27,679 --> 00:18:29,679
so we would say this full build overhead

573
00:18:29,679 --> 00:18:31,039
is generally acceptable especially for

574
00:18:31,039 --> 00:18:32,559
these large projects where i think riker

575
00:18:32,559 --> 00:18:35,760
is most likely to be valuable

576
00:18:35,760 --> 00:18:37,760
next up we have no op builds so remember

577
00:18:37,760 --> 00:18:39,280
this is the time it takes to run an

578
00:18:39,280 --> 00:18:40,559
incremental build that doesn't have to

579
00:18:40,559 --> 00:18:42,720
do any actual work

580
00:18:42,720 --> 00:18:43,760
so

581
00:18:43,760 --> 00:18:45,919
the median delay if you're using riker

582
00:18:45,919 --> 00:18:47,760
compared to make on all those projects

583
00:18:47,760 --> 00:18:50,400
is just 162 milliseconds

584
00:18:50,400 --> 00:18:52,320
and the worst case the longest weight

585
00:18:52,320 --> 00:18:54,400
that we have is llvm

586
00:18:54,400 --> 00:18:57,200
so llvm takes 11.3 seconds for riker to

587
00:18:57,200 --> 00:18:58,799
decide nope you didn't change anything

588
00:18:58,799 --> 00:19:00,799
nothing has to happen whereas make takes

589
00:19:00,799 --> 00:19:02,640
4.8 seconds which is quite a bit longer

590
00:19:02,640 --> 00:19:05,600
than mick does for much smaller projects

591
00:19:05,600 --> 00:19:07,679
but there's no tracing happening here so

592
00:19:07,679 --> 00:19:10,000
why does riker actually take longer than

593
00:19:10,000 --> 00:19:10,880
make

594
00:19:10,880 --> 00:19:12,880
so it's not just wasting time in the

595
00:19:12,880 --> 00:19:15,360
holodeck a riker is actually doing more

596
00:19:15,360 --> 00:19:17,280
work than make is

597
00:19:17,280 --> 00:19:19,360
so riker checks all of the build's

598
00:19:19,360 --> 00:19:20,559
dependencies that includes those

599
00:19:20,559 --> 00:19:22,160
anti-dependencies dependencies on the

600
00:19:22,160 --> 00:19:24,480
compiler binaries system includes

601
00:19:24,480 --> 00:19:27,039
libraries configuration scripts all of

602
00:19:27,039 --> 00:19:29,200
that is part of the dependency graph

603
00:19:29,200 --> 00:19:30,400
but make is only going to check the

604
00:19:30,400 --> 00:19:32,720
dependencies that you tell it about and

605
00:19:32,720 --> 00:19:34,240
i have never written a makefile where i

606
00:19:34,240 --> 00:19:35,520
actually included those things even

607
00:19:35,520 --> 00:19:36,960
though they matter and they change how

608
00:19:36,960 --> 00:19:39,840
the build behaves so we're getting

609
00:19:39,840 --> 00:19:41,600
different and more complete behavior out

610
00:19:41,600 --> 00:19:42,799
of this

611
00:19:42,799 --> 00:19:45,360
and so i would say that 162 milliseconds

612
00:19:45,360 --> 00:19:47,600
or even for a big project the extra six

613
00:19:47,600 --> 00:19:52,240
seconds i think that's worth it okay

614
00:19:52,240 --> 00:19:54,880
so moving on to incremental builds

615
00:19:54,880 --> 00:19:57,120
so incremental builds uh are important

616
00:19:57,120 --> 00:19:58,799
but why do we actually want these well

617
00:19:58,799 --> 00:20:01,360
we want to save time

618
00:20:01,360 --> 00:20:03,360
so we're going to try to evaluate how

619
00:20:03,360 --> 00:20:05,200
much time riker can save when compared

620
00:20:05,200 --> 00:20:06,640
to make

621
00:20:06,640 --> 00:20:07,919
the first step in doing that is we have

622
00:20:07,919 --> 00:20:10,480
to actually specify a build to riker so

623
00:20:10,480 --> 00:20:12,000
we'll look at an example in this case

624
00:20:12,000 --> 00:20:13,440
it's redis

625
00:20:13,440 --> 00:20:16,160
so redis has a pretty interesting build

626
00:20:16,160 --> 00:20:17,440
it does something that's common to a lot

627
00:20:17,440 --> 00:20:18,559
of projects

628
00:20:18,559 --> 00:20:19,919
the first thing it does is it generates

629
00:20:19,919 --> 00:20:21,600
a header file that describes the commit

630
00:20:21,600 --> 00:20:24,000
that we're on

631
00:20:24,000 --> 00:20:26,160
it uses some git commands and some pipes

632
00:20:26,160 --> 00:20:27,919
and text filtering

633
00:20:27,919 --> 00:20:29,360
to generate a few or fill in a few

634
00:20:29,360 --> 00:20:31,280
variables in the shell script and it

635
00:20:31,280 --> 00:20:32,640
dumps those out into a header file

636
00:20:32,640 --> 00:20:35,280
that's used later in the build

637
00:20:35,280 --> 00:20:36,640
we set a few compiler flags so we don't

638
00:20:36,640 --> 00:20:38,480
have to type them in every time and then

639
00:20:38,480 --> 00:20:40,480
we have these three compilation commands

640
00:20:40,480 --> 00:20:42,720
and with some minor omissions to make it

641
00:20:42,720 --> 00:20:44,320
fit on the slide this is the complete

642
00:20:44,320 --> 00:20:46,080
build specification for riker or for

643
00:20:46,080 --> 00:20:49,080
redis

644
00:20:50,400 --> 00:20:52,159
so what we want to do is understand

645
00:20:52,159 --> 00:20:53,520
incremental build performance so we need

646
00:20:53,520 --> 00:20:55,360
to have some changes to the project

647
00:20:55,360 --> 00:20:57,440
and we decided to use the actual source

648
00:20:57,440 --> 00:20:59,600
control repositories for these projects

649
00:20:59,600 --> 00:21:00,799
so what we do is we check out the

650
00:21:00,799 --> 00:21:03,760
repository at some older revision

651
00:21:03,760 --> 00:21:05,760
and then we update the build as we

652
00:21:05,760 --> 00:21:07,679
progress over the next 100 commits to

653
00:21:07,679 --> 00:21:09,760
that project

654
00:21:09,760 --> 00:21:10,880
so if we didn't have any kind of

655
00:21:10,880 --> 00:21:12,240
incremental build system when we just

656
00:21:12,240 --> 00:21:14,480
ran full builds all the time we would

657
00:21:14,480 --> 00:21:16,320
have a graph that looks like this that's

658
00:21:16,320 --> 00:21:17,919
not very nice

659
00:21:17,919 --> 00:21:20,159
but if you use redis as make file you

660
00:21:20,159 --> 00:21:21,760
get builds that look like this we've got

661
00:21:21,760 --> 00:21:23,360
some large ones interspersed with a lot

662
00:21:23,360 --> 00:21:25,120
of smaller builds

663
00:21:25,120 --> 00:21:27,760
and over this whole time make is able to

664
00:21:27,760 --> 00:21:29,679
save 29 minutes compared to running the

665
00:21:29,679 --> 00:21:32,880
full build at every one of those commits

666
00:21:32,880 --> 00:21:34,480
and if we look at riker's performance

667
00:21:34,480 --> 00:21:36,000
using that specification i showed you

668
00:21:36,000 --> 00:21:36,960
earlier

669
00:21:36,960 --> 00:21:39,200
we're able to save 26 minutes so it's

670
00:21:39,200 --> 00:21:40,720
not quite as much as make but remember

671
00:21:40,720 --> 00:21:42,080
we're getting a lot more complete

672
00:21:42,080 --> 00:21:44,400
checking for all of that and i think

673
00:21:44,400 --> 00:21:46,000
again three minutes not too high a price

674
00:21:46,000 --> 00:21:48,320
to pay over 100 commits to get that

675
00:21:48,320 --> 00:21:50,320
assured correctness

676
00:21:50,320 --> 00:21:52,640
so we did this for a few other projects

677
00:21:52,640 --> 00:21:55,120
where we specified riker files

678
00:21:55,120 --> 00:21:56,480
and you can see

679
00:21:56,480 --> 00:21:58,720
that riker is often able to match or

680
00:21:58,720 --> 00:22:00,559
nearly match makes incremental build

681
00:22:00,559 --> 00:22:02,720
performance sqlite is obviously a

682
00:22:02,720 --> 00:22:04,320
strange outlier in this case that's

683
00:22:04,320 --> 00:22:05,760
because it has no incremental builds

684
00:22:05,760 --> 00:22:07,360
possible it just concatenates all the

685
00:22:07,360 --> 00:22:10,559
source files together before compiling

686
00:22:10,559 --> 00:22:12,159
but if we leave that one out of the mix

687
00:22:12,159 --> 00:22:13,200
and we look at just the ones where

688
00:22:13,200 --> 00:22:15,039
incremental builds are actually possible

689
00:22:15,039 --> 00:22:17,760
make is able to save 4.16 hours over

690
00:22:17,760 --> 00:22:20,480
these 500 commits

691
00:22:20,480 --> 00:22:22,880
and riker is able to save 3.92 hours of

692
00:22:22,880 --> 00:22:25,280
building time over those 500 commits

693
00:22:25,280 --> 00:22:27,039
so that means we're getting 94 percent

694
00:22:27,039 --> 00:22:29,120
of make savings but there was no manual

695
00:22:29,120 --> 00:22:30,640
effort to specify those incremental

696
00:22:30,640 --> 00:22:32,400
builds and there was no risk of errors

697
00:22:32,400 --> 00:22:35,440
from missed dependencies

698
00:22:35,440 --> 00:22:38,559
so in conclusion

699
00:22:38,559 --> 00:22:40,880
make forces you to choose between simple

700
00:22:40,880 --> 00:22:42,720
build specifications or fast build

701
00:22:42,720 --> 00:22:44,559
specifications and if you choose the

702
00:22:44,559 --> 00:22:46,480
fast one it gets complicated and those

703
00:22:46,480 --> 00:22:50,000
complicated builds are easy to get wrong

704
00:22:50,000 --> 00:22:51,440
the better way to go about things is to

705
00:22:51,440 --> 00:22:52,960
use riker

706
00:22:52,960 --> 00:22:54,720
so riker lets you write simple build

707
00:22:54,720 --> 00:22:57,280
scripts like this record file here

708
00:22:57,280 --> 00:22:59,360
and for that specification you still get

709
00:22:59,360 --> 00:23:01,679
an automatically fast incremental build

710
00:23:01,679 --> 00:23:03,280
that is correct because it has complete

711
00:23:03,280 --> 00:23:05,360
dependencies

712
00:23:05,360 --> 00:23:06,960
so i should say that riker is available

713
00:23:06,960 --> 00:23:09,120
you can go to riker.sh

714
00:23:09,120 --> 00:23:13,158
and thank you for your attention

