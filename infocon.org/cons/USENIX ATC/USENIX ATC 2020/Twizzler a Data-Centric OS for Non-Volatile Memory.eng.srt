1
00:00:13,280 --> 00:00:16,000
hello

2
00:00:14,160 --> 00:00:18,080
my name is daniel bittman let me tell

3
00:00:16,000 --> 00:00:19,600
you about twizzler a new research

4
00:00:18,080 --> 00:00:22,159
operating system designed to

5
00:00:19,600 --> 00:00:25,199
realize the power of unix in a world of

6
00:00:22,160 --> 00:00:27,519
highly shared persistent data structures

7
00:00:25,199 --> 00:00:29,840
twizzler's design is based around our

8
00:00:27,519 --> 00:00:30,639
beliefs for how programs will evolve in

9
00:00:29,840 --> 00:00:33,200
the face of

10
00:00:30,640 --> 00:00:35,600
new bite-addressable non-volatile memory

11
00:00:33,200 --> 00:00:37,840
technologies or nbm

12
00:00:35,600 --> 00:00:39,200
first we believe that nvm will

13
00:00:37,840 --> 00:00:41,520
fundamentally change

14
00:00:39,200 --> 00:00:43,600
our programming models and abstractions

15
00:00:41,520 --> 00:00:45,120
we expect that programs will operate on

16
00:00:43,600 --> 00:00:48,239
in-memory data structures thus

17
00:00:45,120 --> 00:00:50,399
necessitating persistent data references

18
00:00:48,239 --> 00:00:52,160
next we believe that the os needs to

19
00:00:50,399 --> 00:00:54,239
provide pervasive support for

20
00:00:52,160 --> 00:00:55,199
abstractions like persistent pointers in

21
00:00:54,239 --> 00:00:57,760
order to

22
00:00:55,199 --> 00:00:59,760
best enable simpler and more efficient

23
00:00:57,760 --> 00:01:01,599
programs

24
00:00:59,760 --> 00:01:02,960
so let's have a look at some upcoming

25
00:01:01,600 --> 00:01:05,519
hardware trends

26
00:01:02,960 --> 00:01:06,000
nvm is here you can buy it today from

27
00:01:05,519 --> 00:01:07,520
intel

28
00:01:06,000 --> 00:01:10,400
and throw it on the memory bus right

29
00:01:07,520 --> 00:01:12,000
next to your dram this cpu can issue

30
00:01:10,400 --> 00:01:14,560
normal load and store instructions

31
00:01:12,000 --> 00:01:15,520
to it with a latency on the order of

32
00:01:14,560 --> 00:01:17,520
that of dram

33
00:01:15,520 --> 00:01:19,200
which means that we now have a low

34
00:01:17,520 --> 00:01:20,560
latency per system store that

35
00:01:19,200 --> 00:01:23,759
applications can get at

36
00:01:20,560 --> 00:01:25,360
directly moving persistent data up the

37
00:01:23,759 --> 00:01:27,439
storage hierarchy like this

38
00:01:25,360 --> 00:01:29,200
changes the way that applications can

39
00:01:27,439 --> 00:01:31,679
view and operate on data

40
00:01:29,200 --> 00:01:34,400
in fact they must change to take full

41
00:01:31,680 --> 00:01:36,479
advantage of what is being offered

42
00:01:34,400 --> 00:01:37,600
the old way of getting to persistent

43
00:01:36,479 --> 00:01:39,920
data where we would

44
00:01:37,600 --> 00:01:42,079
explicitly load it into volatile memory

45
00:01:39,920 --> 00:01:44,079
deserialize it compute on it

46
00:01:42,079 --> 00:01:46,880
re-serialize it and then explicitly

47
00:01:44,079 --> 00:01:49,199
store it to disk worked okay in the past

48
00:01:46,880 --> 00:01:50,880
disks were slow and the latency of these

49
00:01:49,200 --> 00:01:52,479
operations was hidden

50
00:01:50,880 --> 00:01:54,158
and we had to issue explicit block

51
00:01:52,479 --> 00:01:55,600
stores at some point but

52
00:01:54,159 --> 00:01:57,360
when the latency of the persistent

53
00:01:55,600 --> 00:01:58,719
device is less than that of even a

54
00:01:57,360 --> 00:02:00,560
single system call

55
00:01:58,719 --> 00:02:04,320
we can no longer afford the kernel

56
00:02:00,560 --> 00:02:07,040
interposition involved in explicit i o

57
00:02:04,320 --> 00:02:08,160
we can improve programmability as well

58
00:02:07,040 --> 00:02:10,239
these operations

59
00:02:08,160 --> 00:02:12,480
encompass the lion's share of systems

60
00:02:10,239 --> 00:02:13,440
programming imagine how much useful work

61
00:02:12,480 --> 00:02:16,160
we could get done

62
00:02:13,440 --> 00:02:18,239
if we didn't have to do them imagine how

63
00:02:16,160 --> 00:02:20,319
much time you would save both in program

64
00:02:18,239 --> 00:02:21,680
time but also in programmer time

65
00:02:20,319 --> 00:02:23,519
because we didn't have to worry about

66
00:02:21,680 --> 00:02:25,360
maintaining multiple data formats and

67
00:02:23,520 --> 00:02:27,680
the transformations between them

68
00:02:25,360 --> 00:02:30,000
imagine how much easier data sharing can

69
00:02:27,680 --> 00:02:31,680
be if the data is always in one format

70
00:02:30,000 --> 00:02:33,120
as opposed to constantly moving around

71
00:02:31,680 --> 00:02:35,599
this cycle

72
00:02:33,120 --> 00:02:37,760
persistent memory offers us this world

73
00:02:35,599 --> 00:02:39,518
but only if we take the steps to change

74
00:02:37,760 --> 00:02:41,679
the key abstractions that the os

75
00:02:39,519 --> 00:02:43,440
provides and to change applications to

76
00:02:41,680 --> 00:02:44,400
best take advantage of this new

77
00:02:43,440 --> 00:02:46,239
technology

78
00:02:44,400 --> 00:02:47,840
we need to start treating persistent

79
00:02:46,239 --> 00:02:49,680
data like it's memory

80
00:02:47,840 --> 00:02:50,879
not like it's storage because in this

81
00:02:49,680 --> 00:02:53,120
world it is

82
00:02:50,879 --> 00:02:55,760
memory and don't worry we have a

83
00:02:53,120 --> 00:02:58,000
compatibility story as well

84
00:02:55,760 --> 00:02:58,959
directly accessing persistent in-memory

85
00:02:58,000 --> 00:03:01,920
data structures

86
00:02:58,959 --> 00:03:03,519
has some immediate consequences first

87
00:03:01,920 --> 00:03:04,879
those data structures are persistent

88
00:03:03,519 --> 00:03:05,519
which means we'll need some way of

89
00:03:04,879 --> 00:03:08,159
constructing

90
00:03:05,519 --> 00:03:08,720
long-term data references persistent

91
00:03:08,159 --> 00:03:11,280
data

92
00:03:08,720 --> 00:03:12,480
by definition outlives the actors that

93
00:03:11,280 --> 00:03:14,159
operate on it

94
00:03:12,480 --> 00:03:16,238
either because that data is shared

95
00:03:14,159 --> 00:03:17,760
simultaneously across different programs

96
00:03:16,239 --> 00:03:20,720
or shared across time that is

97
00:03:17,760 --> 00:03:23,280
across invocations of the same program

98
00:03:20,720 --> 00:03:25,040
because persistent data has a lifetime

99
00:03:23,280 --> 00:03:26,879
longer than that of the processes that

100
00:03:25,040 --> 00:03:29,359
create it or operate on it

101
00:03:26,879 --> 00:03:31,280
we cannot store any ephemeral context

102
00:03:29,360 --> 00:03:33,360
associated with those processes

103
00:03:31,280 --> 00:03:35,120
in the persistent data this is a

104
00:03:33,360 --> 00:03:37,519
recurring philosophy

105
00:03:35,120 --> 00:03:38,640
all of the context necessary to

106
00:03:37,519 --> 00:03:41,599
interpret data

107
00:03:38,640 --> 00:03:43,200
needs to be stored with that data let me

108
00:03:41,599 --> 00:03:44,319
describe what i mean by way of an

109
00:03:43,200 --> 00:03:46,319
example

110
00:03:44,319 --> 00:03:48,640
imagine we have some processes observe

111
00:03:46,319 --> 00:03:50,399
process 1 and process 2.

112
00:03:48,640 --> 00:03:52,238
they want to share data but that data

113
00:03:50,400 --> 00:03:53,680
has pointers in it if this data

114
00:03:52,239 --> 00:03:55,519
structure is persistent

115
00:03:53,680 --> 00:03:57,040
i can't just write virtual memory

116
00:03:55,519 --> 00:03:58,799
addresses into it because

117
00:03:57,040 --> 00:04:00,720
virtual memory is by definition

118
00:03:58,799 --> 00:04:01,760
ephemeral it's tied to the creating

119
00:04:00,720 --> 00:04:04,319
process

120
00:04:01,760 --> 00:04:05,200
instead we must store a persistent

121
00:04:04,319 --> 00:04:07,040
pointer

122
00:04:05,200 --> 00:04:08,480
one that is based on a more fundamental

123
00:04:07,040 --> 00:04:10,079
notion of data identity

124
00:04:08,480 --> 00:04:11,760
instead of an ephemeral notion of

125
00:04:10,080 --> 00:04:14,400
location

126
00:04:11,760 --> 00:04:15,040
building an efficient persistent pointer

127
00:04:14,400 --> 00:04:18,720
design

128
00:04:15,040 --> 00:04:18,719
is a key part of our work

129
00:04:18,798 --> 00:04:22,159
the second implication of direct access

130
00:04:21,440 --> 00:04:24,160
to

131
00:04:22,160 --> 00:04:26,160
persistent in-memory data structures is

132
00:04:24,160 --> 00:04:29,040
that the os's responsibilities

133
00:04:26,160 --> 00:04:30,720
drastically change and reduce the low

134
00:04:29,040 --> 00:04:32,720
latency nature of nvm

135
00:04:30,720 --> 00:04:34,479
demands that the kernel no longer be

136
00:04:32,720 --> 00:04:35,440
involved in the persistence path for the

137
00:04:34,479 --> 00:04:37,359
most part

138
00:04:35,440 --> 00:04:38,800
therefore the kernel does not need to

139
00:04:37,360 --> 00:04:40,639
provide services

140
00:04:38,800 --> 00:04:42,000
for mediating access to persistent

141
00:04:40,639 --> 00:04:43,840
storage and therefore

142
00:04:42,000 --> 00:04:45,280
no longer needs to act as mediator for

143
00:04:43,840 --> 00:04:48,320
things like rendezvous

144
00:04:45,280 --> 00:04:49,840
communication or naming the kernel gets

145
00:04:48,320 --> 00:04:52,000
out of the way of user space

146
00:04:49,840 --> 00:04:54,719
and many kernel bypass strategies

147
00:04:52,000 --> 00:04:56,240
naturally fall out of this

148
00:04:54,720 --> 00:04:58,800
an example of removing kernel

149
00:04:56,240 --> 00:05:01,600
abstractions is a process

150
00:04:58,800 --> 00:05:03,280
what is a process a pile of threads a

151
00:05:01,600 --> 00:05:05,280
security role

152
00:05:03,280 --> 00:05:08,080
a virtual address space and a bunch of

153
00:05:05,280 --> 00:05:10,159
kernel state like file descriptors

154
00:05:08,080 --> 00:05:12,880
but if we disconnect the virtual address

155
00:05:10,160 --> 00:05:14,800
space from how applications access data

156
00:05:12,880 --> 00:05:17,120
and we no longer need things like file

157
00:05:14,800 --> 00:05:19,600
descriptors a lot of that kernel state

158
00:05:17,120 --> 00:05:21,360
goes away and we're left with no reason

159
00:05:19,600 --> 00:05:22,320
to couple a bunch of different

160
00:05:21,360 --> 00:05:24,639
abstractions like

161
00:05:22,320 --> 00:05:26,960
threads and security roles into a single

162
00:05:24,639 --> 00:05:28,720
process notion

163
00:05:26,960 --> 00:05:30,960
instead of mediating access to

164
00:05:28,720 --> 00:05:33,039
persistent data the os provides

165
00:05:30,960 --> 00:05:36,000
sufficient support for user space to

166
00:05:33,039 --> 00:05:38,080
manipulate all data as in-memory data

167
00:05:36,000 --> 00:05:40,000
without needing to coordinate on some

168
00:05:38,080 --> 00:05:42,240
ephemeral context

169
00:05:40,000 --> 00:05:44,320
we call an operating system data centric

170
00:05:42,240 --> 00:05:46,560
if it provides this mediation-free

171
00:05:44,320 --> 00:05:48,800
access to data such that that data can

172
00:05:46,560 --> 00:05:49,600
persist that is all of the context

173
00:05:48,800 --> 00:05:51,840
necessary

174
00:05:49,600 --> 00:05:52,800
to interpret the data is stored with the

175
00:05:51,840 --> 00:05:54,960
data

176
00:05:52,800 --> 00:05:56,800
we contrast these two process-centric

177
00:05:54,960 --> 00:05:58,638
operating systems which instead focus on

178
00:05:56,800 --> 00:06:00,000
ephemeral actors as being the primary

179
00:05:58,639 --> 00:06:01,919
abstraction

180
00:06:00,000 --> 00:06:04,479
well what about alternative approaches

181
00:06:01,919 --> 00:06:06,318
well it wouldn't be os research without

182
00:06:04,479 --> 00:06:08,960
talking about posix

183
00:06:06,319 --> 00:06:09,440
the hallmark of posix is kernel-mediated

184
00:06:08,960 --> 00:06:11,758
i o

185
00:06:09,440 --> 00:06:12,719
through explicit i o calls like read and

186
00:06:11,759 --> 00:06:14,160
write

187
00:06:12,720 --> 00:06:16,160
which already fails to meet our

188
00:06:14,160 --> 00:06:16,880
requirements because of the explicit i o

189
00:06:16,160 --> 00:06:19,199
calls

190
00:06:16,880 --> 00:06:21,120
but posix often also ends up forcing the

191
00:06:19,199 --> 00:06:22,400
programmer to think in terms of multiple

192
00:06:21,120 --> 00:06:24,479
data formats

193
00:06:22,400 --> 00:06:25,440
even mmap which does admittedly help the

194
00:06:24,479 --> 00:06:27,120
problem somewhat

195
00:06:25,440 --> 00:06:29,360
requires the programmer to still think

196
00:06:27,120 --> 00:06:32,000
in terms of virtual addresses

197
00:06:29,360 --> 00:06:33,520
we could try layering support for nvm on

198
00:06:32,000 --> 00:06:36,639
top of posix

199
00:06:33,520 --> 00:06:38,400
pmdk is an nvm programming library

200
00:06:36,639 --> 00:06:41,280
which supports persistent pointer

201
00:06:38,400 --> 00:06:43,120
abstractions and runs on top of posix

202
00:06:41,280 --> 00:06:44,960
but it doesn't provide a complete

203
00:06:43,120 --> 00:06:47,440
picture because it requires the

204
00:06:44,960 --> 00:06:50,239
programmer to work both in a posix world

205
00:06:47,440 --> 00:06:52,400
and in an nvm world at the same time

206
00:06:50,240 --> 00:06:54,000
managing the complex interaction of

207
00:06:52,400 --> 00:06:56,080
features between both

208
00:06:54,000 --> 00:06:57,520
an example of this is naming and as

209
00:06:56,080 --> 00:07:00,560
we'll see a little later on

210
00:06:57,520 --> 00:07:02,400
cross machine sharing

211
00:07:00,560 --> 00:07:04,479
twizzler is a point in the bounded

212
00:07:02,400 --> 00:07:05,359
design space of data centric operating

213
00:07:04,479 --> 00:07:08,000
systems

214
00:07:05,360 --> 00:07:09,840
twistler provides low kernel involvement

215
00:07:08,000 --> 00:07:10,400
for applications accessing persistent

216
00:07:09,840 --> 00:07:12,560
data

217
00:07:10,400 --> 00:07:14,400
it provides an efficient and flexible

218
00:07:12,560 --> 00:07:16,080
persistent pointer design

219
00:07:14,400 --> 00:07:17,919
and provides a standard library of

220
00:07:16,080 --> 00:07:20,880
features necessary for effectively

221
00:07:17,919 --> 00:07:22,960
writing nvm-based programs

222
00:07:20,880 --> 00:07:24,560
the execution environment in twizzler is

223
00:07:22,960 --> 00:07:26,400
one in which there is little distinction

224
00:07:24,560 --> 00:07:28,800
between how threads access volatile and

225
00:07:26,400 --> 00:07:30,880
persistent data

226
00:07:28,800 --> 00:07:32,960
memory and twizzler both volatile and

227
00:07:30,880 --> 00:07:34,960
persistent is broken up into objects

228
00:07:32,960 --> 00:07:36,880
where an object is a flat region of

229
00:07:34,960 --> 00:07:38,080
memory containing semantically related

230
00:07:36,880 --> 00:07:40,159
data

231
00:07:38,080 --> 00:07:42,318
the contents of objects can be directly

232
00:07:40,160 --> 00:07:42,960
accessed and manipulated by programs and

233
00:07:42,319 --> 00:07:45,440
is of course

234
00:07:42,960 --> 00:07:47,280
largely application specific objects are

235
00:07:45,440 --> 00:07:50,080
also the unit of access control

236
00:07:47,280 --> 00:07:50,878
in twizzler an example of an object

237
00:07:50,080 --> 00:07:53,120
might be a b

238
00:07:50,879 --> 00:07:54,080
tree but an object could just as easily

239
00:07:53,120 --> 00:07:56,560
have multiple b

240
00:07:54,080 --> 00:07:58,080
trees in it and just as easily a b tree

241
00:07:56,560 --> 00:07:59,520
could be spread across multiple

242
00:07:58,080 --> 00:08:01,199
objects it all depends on how the

243
00:07:59,520 --> 00:08:03,359
application wishes to do things

244
00:08:01,199 --> 00:08:04,800
for example an application might wish to

245
00:08:03,360 --> 00:08:08,160
have different parts of the tree

246
00:08:04,800 --> 00:08:10,080
protected by different access rights

247
00:08:08,160 --> 00:08:13,520
applications in twizzler are supported

248
00:08:10,080 --> 00:08:15,840
by the twizzler standard library lib twz

249
00:08:13,520 --> 00:08:17,120
which acts like a library os similar as

250
00:08:15,840 --> 00:08:19,840
to an exokernel

251
00:08:17,120 --> 00:08:22,479
and provides services for common object

252
00:08:19,840 --> 00:08:24,239
management and manipulation routines

253
00:08:22,479 --> 00:08:25,758
the kernel provides management of

254
00:08:24,240 --> 00:08:28,160
physical resources as well as

255
00:08:25,759 --> 00:08:30,479
multiplexing memory into objects

256
00:08:28,160 --> 00:08:32,959
and providing services for thread

257
00:08:30,479 --> 00:08:34,559
scheduling and thread synchronization

258
00:08:32,958 --> 00:08:36,559
it also acts as the trusted computing

259
00:08:34,559 --> 00:08:38,319
base servicing page faults and security

260
00:08:36,559 --> 00:08:40,478
violations

261
00:08:38,320 --> 00:08:42,959
for compatibility applications linked to

262
00:08:40,479 --> 00:08:44,399
muscle a c library that we modified to

263
00:08:42,958 --> 00:08:46,719
run on twizzler

264
00:08:44,399 --> 00:08:49,040
we changed muscle system calls into

265
00:08:46,720 --> 00:08:52,160
library calls to our library twix which

266
00:08:49,040 --> 00:08:54,880
we wrote to support posix applications

267
00:08:52,160 --> 00:08:57,120
through muscle and twix applications can

268
00:08:54,880 --> 00:08:58,320
operate on objects using posix functions

269
00:08:57,120 --> 00:09:00,800
at the cost of course of

270
00:08:58,320 --> 00:09:02,160
explicit io this is another key

271
00:09:00,800 --> 00:09:04,479
philosophy

272
00:09:02,160 --> 00:09:06,880
applications need to change in order to

273
00:09:04,480 --> 00:09:08,959
take best advantage of nvm

274
00:09:06,880 --> 00:09:10,880
it is these applications that should get

275
00:09:08,959 --> 00:09:13,040
first-class os support

276
00:09:10,880 --> 00:09:14,000
instead of building support for exciting

277
00:09:13,040 --> 00:09:16,399
new hardware

278
00:09:14,000 --> 00:09:18,640
by shoe horning in that support on top

279
00:09:16,399 --> 00:09:20,240
of existing ill-suited interfaces

280
00:09:18,640 --> 00:09:22,080
we provide old software with

281
00:09:20,240 --> 00:09:22,640
compatibility layers and design the

282
00:09:22,080 --> 00:09:25,839
system

283
00:09:22,640 --> 00:09:27,839
for how new applications will be written

284
00:09:25,839 --> 00:09:29,600
okay let's talk about persistent

285
00:09:27,839 --> 00:09:31,640
pointers

286
00:09:29,600 --> 00:09:33,600
in twizzler objects have a unique

287
00:09:31,640 --> 00:09:36,080
128-bit id

288
00:09:33,600 --> 00:09:38,320
right now that id is 128 bits in size

289
00:09:36,080 --> 00:09:40,080
though we could increase it if necessary

290
00:09:38,320 --> 00:09:41,760
to form the kind of identity based

291
00:09:40,080 --> 00:09:44,240
reference that we've been talking about

292
00:09:41,760 --> 00:09:45,760
we could take that object id and combine

293
00:09:44,240 --> 00:09:47,839
it with an offset

294
00:09:45,760 --> 00:09:48,880
and then be able to reference any piece

295
00:09:47,839 --> 00:09:52,160
of data within

296
00:09:48,880 --> 00:09:53,120
any object however just combining the id

297
00:09:52,160 --> 00:09:55,120
with the offset

298
00:09:53,120 --> 00:09:56,640
would dramatically increase pointer size

299
00:09:55,120 --> 00:09:58,160
and therefore have a significant

300
00:09:56,640 --> 00:10:00,399
performance impact

301
00:09:58,160 --> 00:10:01,199
additionally we would limit flexibility

302
00:10:00,399 --> 00:10:02,720
because

303
00:10:01,200 --> 00:10:05,920
application programmers would have to

304
00:10:02,720 --> 00:10:09,839
work entirely within these 128-bit ids

305
00:10:05,920 --> 00:10:11,920
without any possibility of abstraction

306
00:10:09,839 --> 00:10:14,320
so in twizzler we play the classic trick

307
00:10:11,920 --> 00:10:16,800
and add a layer of indirection

308
00:10:14,320 --> 00:10:17,440
every object in twizzler has at a known

309
00:10:16,800 --> 00:10:19,199
location

310
00:10:17,440 --> 00:10:21,519
a data structure called the foreign

311
00:10:19,200 --> 00:10:24,079
object table or fot

312
00:10:21,519 --> 00:10:24,959
this table is an array of fot entries

313
00:10:24,079 --> 00:10:27,359
each containing

314
00:10:24,959 --> 00:10:29,439
the object id of an external reference

315
00:10:27,360 --> 00:10:31,279
from this object

316
00:10:29,440 --> 00:10:32,880
instead of storing a pointer as an

317
00:10:31,279 --> 00:10:35,519
object id and an offset

318
00:10:32,880 --> 00:10:36,399
we store an index into the fot along the

319
00:10:35,519 --> 00:10:39,120
offset

320
00:10:36,399 --> 00:10:40,160
our pointers can now be 64 bits but more

321
00:10:39,120 --> 00:10:42,240
importantly

322
00:10:40,160 --> 00:10:43,680
this indirection opens the door to more

323
00:10:42,240 --> 00:10:46,240
possibilities

324
00:10:43,680 --> 00:10:48,399
in fot entries we can store additional

325
00:10:46,240 --> 00:10:49,600
metadata like protection information or

326
00:10:48,399 --> 00:10:52,000
ref counts

327
00:10:49,600 --> 00:10:53,920
but we can also store names instead of

328
00:10:52,000 --> 00:10:54,880
relying on the file system to handle

329
00:10:53,920 --> 00:10:57,120
naming for us

330
00:10:54,880 --> 00:10:58,880
we get naming through the core pointer

331
00:10:57,120 --> 00:11:00,720
framework of the system

332
00:10:58,880 --> 00:11:02,320
these names can be resolved on pointer

333
00:11:00,720 --> 00:11:04,480
resolution enabling

334
00:11:02,320 --> 00:11:06,320
late binding and allowing programmers to

335
00:11:04,480 --> 00:11:07,279
think in terms of human readable strings

336
00:11:06,320 --> 00:11:10,560
instead of just

337
00:11:07,279 --> 00:11:11,279
object ids let's talk through an fot

338
00:11:10,560 --> 00:11:14,319
example

339
00:11:11,279 --> 00:11:16,079
check out object o here o has an fot

340
00:11:14,320 --> 00:11:18,240
and it has a pointer inside it that

341
00:11:16,079 --> 00:11:20,479
pointer has fot index of one

342
00:11:18,240 --> 00:11:23,200
so we can use that index to index the

343
00:11:20,480 --> 00:11:24,959
fot and get back object id a

344
00:11:23,200 --> 00:11:27,279
we can then use object id a and the

345
00:11:24,959 --> 00:11:28,800
offset to index within that object and

346
00:11:27,279 --> 00:11:31,760
get to the data

347
00:11:28,800 --> 00:11:32,640
in fot entry of zero means that the

348
00:11:31,760 --> 00:11:34,480
pointer is an

349
00:11:32,640 --> 00:11:36,079
internal pointer it references data

350
00:11:34,480 --> 00:11:38,399
within the object itself that the

351
00:11:36,079 --> 00:11:41,839
pointer resides in

352
00:11:38,399 --> 00:11:42,480
i want to stress that the fot is a per

353
00:11:41,839 --> 00:11:45,200
object

354
00:11:42,480 --> 00:11:46,560
and not system-wide data structure this

355
00:11:45,200 --> 00:11:48,880
is a manifestation

356
00:11:46,560 --> 00:11:50,638
of our philosophy that all context

357
00:11:48,880 --> 00:11:53,600
necessary to interpret data

358
00:11:50,639 --> 00:11:55,279
should be stored with that data per

359
00:11:53,600 --> 00:11:58,720
object fots

360
00:11:55,279 --> 00:12:01,839
makes objects self-contained

361
00:11:58,720 --> 00:12:02,959
so consider now pointers and objects

362
00:12:01,839 --> 00:12:05,920
refer to data

363
00:12:02,959 --> 00:12:06,560
via identity and not ephemeral location

364
00:12:05,920 --> 00:12:09,199
and

365
00:12:06,560 --> 00:12:10,959
object ids are large enough to refer to

366
00:12:09,200 --> 00:12:13,839
any object in the world

367
00:12:10,959 --> 00:12:14,319
and objects are self-contained this

368
00:12:13,839 --> 00:12:16,880
means

369
00:12:14,320 --> 00:12:18,800
that i can share objects across machines

370
00:12:16,880 --> 00:12:20,000
not just across processes on a single

371
00:12:18,800 --> 00:12:22,160
machine

372
00:12:20,000 --> 00:12:24,079
if i copy an object from one machine to

373
00:12:22,160 --> 00:12:27,600
another all the pointers

374
00:12:24,079 --> 00:12:28,719
mean the same thing let's contrast this

375
00:12:27,600 --> 00:12:31,839
with pmdk

376
00:12:28,720 --> 00:12:33,680
so in pmdk pointers are stored as an

377
00:12:31,839 --> 00:12:36,079
object id offset pair

378
00:12:33,680 --> 00:12:37,760
where the object id in this case is 64

379
00:12:36,079 --> 00:12:39,920
bits

380
00:12:37,760 --> 00:12:41,839
let's imagine we move an object from one

381
00:12:39,920 --> 00:12:42,319
machine to another well the problem is

382
00:12:41,839 --> 00:12:45,279
that

383
00:12:42,320 --> 00:12:47,519
64 bits is not large enough to ensure no

384
00:12:45,279 --> 00:12:49,839
collision in the object id space

385
00:12:47,519 --> 00:12:50,959
this means that we have to do one of two

386
00:12:49,839 --> 00:12:52,880
things either

387
00:12:50,959 --> 00:12:55,040
we have to coordinate ahead of time on

388
00:12:52,880 --> 00:12:56,000
the object id space which gets harder as

389
00:12:55,040 --> 00:12:58,319
we scale

390
00:12:56,000 --> 00:13:00,639
or two we would have to perform some fix

391
00:12:58,320 --> 00:13:02,480
up operation on the receiving machine

392
00:13:00,639 --> 00:13:04,240
the problem with this is that because

393
00:13:02,480 --> 00:13:07,120
the object ids are stored

394
00:13:04,240 --> 00:13:09,360
inside the pointers the fix-up operation

395
00:13:07,120 --> 00:13:12,079
is necessarily application specific

396
00:13:09,360 --> 00:13:14,000
adding complexity in twizzler we can

397
00:13:12,079 --> 00:13:15,359
avoid both of these we can avoid the

398
00:13:14,000 --> 00:13:17,279
global coordination

399
00:13:15,360 --> 00:13:18,959
and the fix of operation through the use

400
00:13:17,279 --> 00:13:21,279
of indirection

401
00:13:18,959 --> 00:13:23,040
in addition to providing a comprehensive

402
00:13:21,279 --> 00:13:25,200
persistent pointer framework

403
00:13:23,040 --> 00:13:27,360
twistler provides basic services for

404
00:13:25,200 --> 00:13:29,279
coherency and consistency

405
00:13:27,360 --> 00:13:32,079
applications need to be able to write

406
00:13:29,279 --> 00:13:34,560
crash consistent data structures in nvm

407
00:13:32,079 --> 00:13:35,760
but the research is still in flux and so

408
00:13:34,560 --> 00:13:38,000
we wanted to avoid

409
00:13:35,760 --> 00:13:39,040
prematurely prescribing a particular

410
00:13:38,000 --> 00:13:41,279
solution

411
00:13:39,040 --> 00:13:42,399
twizzler does however provide basic

412
00:13:41,279 --> 00:13:45,199
building blocks for

413
00:13:42,399 --> 00:13:45,600
cache line flushes as well as a higher

414
00:13:45,199 --> 00:13:47,680
level

415
00:13:45,600 --> 00:13:49,519
transactional log that can be used to

416
00:13:47,680 --> 00:13:51,920
safely persist data

417
00:13:49,519 --> 00:13:53,120
of course twizzler provides a security

418
00:13:51,920 --> 00:13:56,719
model designed around

419
00:13:53,120 --> 00:13:59,519
nvm briefly the removal of the kernel as

420
00:13:56,720 --> 00:14:00,480
mediator means that the colonel has to

421
00:13:59,519 --> 00:14:03,199
be able to trust

422
00:14:00,480 --> 00:14:03,920
security policy coming from persistent

423
00:14:03,199 --> 00:14:05,599
data

424
00:14:03,920 --> 00:14:07,599
to accomplish this we use

425
00:14:05,600 --> 00:14:10,560
cryptographically signed capabilities to

426
00:14:07,600 --> 00:14:12,399
define security policy and access rights

427
00:14:10,560 --> 00:14:13,599
additionally since the kernel is not

428
00:14:12,399 --> 00:14:16,000
involved in

429
00:14:13,600 --> 00:14:17,120
much of the persistent data access the

430
00:14:16,000 --> 00:14:19,360
kernel uses the

431
00:14:17,120 --> 00:14:21,040
mmu to do much of the security

432
00:14:19,360 --> 00:14:23,519
enforcement of the system

433
00:14:21,040 --> 00:14:24,719
more details on this as well as when

434
00:14:23,519 --> 00:14:26,720
access rights are

435
00:14:24,720 --> 00:14:29,760
bound to threads for example are

436
00:14:26,720 --> 00:14:32,079
available in the paper

437
00:14:29,760 --> 00:14:33,040
implementation is a relatively small

438
00:14:32,079 --> 00:14:35,439
system written in

439
00:14:33,040 --> 00:14:36,319
c and c plus plus the design choices

440
00:14:35,440 --> 00:14:38,240
that we've made

441
00:14:36,320 --> 00:14:39,519
results in a relatively small kernel

442
00:14:38,240 --> 00:14:42,560
that is still capable of

443
00:14:39,519 --> 00:14:44,959
supporting a full user space more design

444
00:14:42,560 --> 00:14:45,920
details for example how we use virtual

445
00:14:44,959 --> 00:14:48,079
memory hardware

446
00:14:45,920 --> 00:14:49,920
are available in the paper twizzler

447
00:14:48,079 --> 00:14:54,000
itself is open source and it is

448
00:14:49,920 --> 00:14:56,000
available right now at twizzler.io

449
00:14:54,000 --> 00:14:58,399
in evaluating twizzler we wanted to

450
00:14:56,000 --> 00:15:01,120
highlight the programmability features

451
00:14:58,399 --> 00:15:03,519
our first goal was to demonstrate the

452
00:15:01,120 --> 00:15:04,959
benefits and simplicity afforded novel

453
00:15:03,519 --> 00:15:07,519
applications

454
00:15:04,959 --> 00:15:08,000
written natively for twizzler our second

455
00:15:07,519 --> 00:15:10,000
goal

456
00:15:08,000 --> 00:15:12,320
was to show that existing applications

457
00:15:10,000 --> 00:15:14,240
can be easily ported to twizzler

458
00:15:12,320 --> 00:15:15,920
i want to stress that our goals are

459
00:15:14,240 --> 00:15:18,399
programmability and not

460
00:15:15,920 --> 00:15:20,160
performance of course advances in

461
00:15:18,399 --> 00:15:22,240
programmability need to come without a

462
00:15:20,160 --> 00:15:24,560
significant performance impact

463
00:15:22,240 --> 00:15:26,160
and of course we do expect to see some

464
00:15:24,560 --> 00:15:28,000
performance improvement

465
00:15:26,160 --> 00:15:30,800
due to the simplification of software

466
00:15:28,000 --> 00:15:33,199
layers that the twizzler model provides

467
00:15:30,800 --> 00:15:34,399
our evaluation consisted of writing a

468
00:15:33,199 --> 00:15:38,079
key value store or

469
00:15:34,399 --> 00:15:40,079
kvs with some nvm focused requirements

470
00:15:38,079 --> 00:15:41,839
and porting sql light to twizzler while

471
00:15:40,079 --> 00:15:43,758
changing its storage backend to use

472
00:15:41,839 --> 00:15:46,000
twizzler abstractions

473
00:15:43,759 --> 00:15:47,600
let's talk about the kvs case study

474
00:15:46,000 --> 00:15:48,959
first before going into the performance

475
00:15:47,600 --> 00:15:52,639
tests

476
00:15:48,959 --> 00:15:54,560
we built a simple kvs in c for twizzler

477
00:15:52,639 --> 00:15:56,160
twizzler's model allowed us a few

478
00:15:54,560 --> 00:15:58,719
convenient simplifying

479
00:15:56,160 --> 00:16:01,279
design choices here first we were able

480
00:15:58,720 --> 00:16:03,360
to hand out direct pointers to data

481
00:16:01,279 --> 00:16:06,000
when performing a lookup instead of

482
00:16:03,360 --> 00:16:07,360
copying the value out to a temporary

483
00:16:06,000 --> 00:16:09,040
we were able to hand out a direct

484
00:16:07,360 --> 00:16:10,880
reference to it because of twizzler's

485
00:16:09,040 --> 00:16:12,719
flexible pointer model

486
00:16:10,880 --> 00:16:14,560
when working with persistent memory

487
00:16:12,720 --> 00:16:17,839
avoiding unnecessary copies

488
00:16:14,560 --> 00:16:20,319
is important and natural second

489
00:16:17,839 --> 00:16:21,759
we separated the index and the data into

490
00:16:20,320 --> 00:16:23,519
multiple objects

491
00:16:21,759 --> 00:16:25,839
twizzler's pointer model allows us to

492
00:16:23,519 --> 00:16:27,360
construct cross-object data references

493
00:16:25,839 --> 00:16:30,079
with no more complexity than

494
00:16:27,360 --> 00:16:32,560
constructing an internal data reference

495
00:16:30,079 --> 00:16:33,758
thus the additional complexity required

496
00:16:32,560 --> 00:16:35,839
by managing

497
00:16:33,759 --> 00:16:37,040
two different name spaces in a single

498
00:16:35,839 --> 00:16:39,199
linear address space

499
00:16:37,040 --> 00:16:40,639
as would be the traditional approach is

500
00:16:39,199 --> 00:16:42,639
no longer justified

501
00:16:40,639 --> 00:16:44,560
this means that for example we could

502
00:16:42,639 --> 00:16:45,120
change the organization of the index

503
00:16:44,560 --> 00:16:47,279
structure

504
00:16:45,120 --> 00:16:50,480
in a factored way without needing to

505
00:16:47,279 --> 00:16:52,720
rethink the global layout

506
00:16:50,480 --> 00:16:54,160
next we extended the requirements of the

507
00:16:52,720 --> 00:16:57,839
kbs to support

508
00:16:54,160 --> 00:16:59,759
access control in twistler this was easy

509
00:16:57,839 --> 00:17:01,839
instead of storing all values in a

510
00:16:59,759 --> 00:17:03,839
single object we store them in

511
00:17:01,839 --> 00:17:05,120
multiple data objects according to

512
00:17:03,839 --> 00:17:07,360
access policy

513
00:17:05,119 --> 00:17:08,159
since cross-object pointers are natural

514
00:17:07,359 --> 00:17:10,159
in twizzler

515
00:17:08,160 --> 00:17:13,199
adding support for this required almost

516
00:17:10,160 --> 00:17:15,199
no modifications to the kvs code

517
00:17:13,199 --> 00:17:16,319
when performing a lookup i may get back

518
00:17:15,199 --> 00:17:18,400
a pointer to data

519
00:17:16,319 --> 00:17:20,639
but if i'm not allowed to see that data

520
00:17:18,400 --> 00:17:23,039
i won't be able to de-reference it

521
00:17:20,640 --> 00:17:24,240
consider the implications here often

522
00:17:23,039 --> 00:17:26,319
security is an

523
00:17:24,240 --> 00:17:28,240
end-to-end thing implemented at the

524
00:17:26,319 --> 00:17:29,600
hardware level the system level and the

525
00:17:28,240 --> 00:17:31,440
application level

526
00:17:29,600 --> 00:17:34,320
sometimes of course this is unavoidable

527
00:17:31,440 --> 00:17:35,600
but what a win it is when an application

528
00:17:34,320 --> 00:17:37,439
can reuse

529
00:17:35,600 --> 00:17:38,959
lower level security features without

530
00:17:37,440 --> 00:17:42,720
having to re-implement them

531
00:17:38,960 --> 00:17:45,120
itself compare this to a unix approach

532
00:17:42,720 --> 00:17:47,360
we implemented a similarly featured kvs

533
00:17:45,120 --> 00:17:48,879
on top of posix interfaces

534
00:17:47,360 --> 00:17:50,639
we found that the extra complexity

535
00:17:48,880 --> 00:17:52,960
involved in managing paths

536
00:17:50,640 --> 00:17:54,640
significantly increased code complexity

537
00:17:52,960 --> 00:17:56,480
because unix doesn't support

538
00:17:54,640 --> 00:17:58,880
a pervasive notion of cross file

539
00:17:56,480 --> 00:18:01,360
references furthermore we weren't easily

540
00:17:58,880 --> 00:18:03,520
able to extend that kvs to support

541
00:18:01,360 --> 00:18:05,280
access control like we did in twizzler

542
00:18:03,520 --> 00:18:07,120
because of the way that mmap works we

543
00:18:05,280 --> 00:18:09,280
would have needed to know ahead of time

544
00:18:07,120 --> 00:18:10,320
all of the accesses to be made or would

545
00:18:09,280 --> 00:18:13,200
have needed to

546
00:18:10,320 --> 00:18:14,000
remap all of the objects on the fly each

547
00:18:13,200 --> 00:18:17,200
adding their own

548
00:18:14,000 --> 00:18:19,440
flavor of complexity for

549
00:18:17,200 --> 00:18:20,480
existing software our goal was to port a

550
00:18:19,440 --> 00:18:24,320
relatively large

551
00:18:20,480 --> 00:18:26,799
application sql lite is a commonly used

552
00:18:24,320 --> 00:18:27,520
local sql implementation with a b tree

553
00:18:26,799 --> 00:18:30,320
based

554
00:18:27,520 --> 00:18:31,200
storage back end we ported sequel light

555
00:18:30,320 --> 00:18:33,360
to twizzler

556
00:18:31,200 --> 00:18:36,240
replacing the b3 storage back end with

557
00:18:33,360 --> 00:18:38,240
twizzler based red black tree code

558
00:18:36,240 --> 00:18:40,000
note that the rest of sql light remained

559
00:18:38,240 --> 00:18:43,679
untouched demonstrating that our

560
00:18:40,000 --> 00:18:45,840
compatibility layers are effective

561
00:18:43,679 --> 00:18:47,120
we ported sqlite to twizzler in two

562
00:18:45,840 --> 00:18:49,199
steps first

563
00:18:47,120 --> 00:18:51,678
we found a port of sql lite that used

564
00:18:49,200 --> 00:18:53,760
lmdb as its storage backend

565
00:18:51,679 --> 00:18:54,720
lmdb stands for the lightning memory map

566
00:18:53,760 --> 00:18:57,600
database

567
00:18:54,720 --> 00:18:58,960
and it uses mmap to access persistent

568
00:18:57,600 --> 00:19:01,918
storage

569
00:18:58,960 --> 00:19:04,880
we took the lmdb port of sqlite and then

570
00:19:01,919 --> 00:19:06,880
we implemented enough of the lmdb api

571
00:19:04,880 --> 00:19:08,960
on top of twizzler abstractions to get

572
00:19:06,880 --> 00:19:11,440
sqlite to run

573
00:19:08,960 --> 00:19:13,280
in this process we discovered that

574
00:19:11,440 --> 00:19:15,280
twizzler's pointer model actually makes

575
00:19:13,280 --> 00:19:15,760
a lot of the interfaces in these kv

576
00:19:15,280 --> 00:19:18,320
stores

577
00:19:15,760 --> 00:19:20,960
obsolete because they were just largely

578
00:19:18,320 --> 00:19:23,120
wrappers around pointer operations

579
00:19:20,960 --> 00:19:24,960
we compared our port of sqlite to

580
00:19:23,120 --> 00:19:26,879
twizzler to three other sqlite

581
00:19:24,960 --> 00:19:29,360
implementations running on linux

582
00:19:26,880 --> 00:19:30,480
the first was unmodified or native

583
00:19:29,360 --> 00:19:34,000
sqlite

584
00:19:30,480 --> 00:19:35,440
the second was sqlite ported to use lmdb

585
00:19:34,000 --> 00:19:38,240
as its storage backend

586
00:19:35,440 --> 00:19:39,840
for the third we took the twizzler lmdb

587
00:19:38,240 --> 00:19:42,559
interface that we wrote

588
00:19:39,840 --> 00:19:44,879
and converted it to use pmdk instead as

589
00:19:42,559 --> 00:19:46,879
its storage backend

590
00:19:44,880 --> 00:19:47,919
all of these tests were run on dell

591
00:19:46,880 --> 00:19:51,039
servers using

592
00:19:47,919 --> 00:19:54,000
real optane dimms our first

593
00:19:51,039 --> 00:19:55,760
experiment used ycsb a common benchmark

594
00:19:54,000 --> 00:19:58,080
to drive the database

595
00:19:55,760 --> 00:19:59,760
this graph shows normalized throughput

596
00:19:58,080 --> 00:20:02,240
so higher is better

597
00:19:59,760 --> 00:20:04,320
we found that twizzler was faster in all

598
00:20:02,240 --> 00:20:05,600
instances while pmdk's implementation

599
00:20:04,320 --> 00:20:07,678
was often slower

600
00:20:05,600 --> 00:20:08,879
of course again performance was not our

601
00:20:07,679 --> 00:20:10,320
primary goal here but

602
00:20:08,880 --> 00:20:13,440
here we see the effects of the

603
00:20:10,320 --> 00:20:15,600
simplification of software layers

604
00:20:13,440 --> 00:20:18,000
for the second experiment we compared

605
00:20:15,600 --> 00:20:18,879
the latency of issuing queries against

606
00:20:18,000 --> 00:20:21,280
an existing

607
00:20:18,880 --> 00:20:22,799
million row database here we see the

608
00:20:21,280 --> 00:20:25,600
results this time we're looking at

609
00:20:22,799 --> 00:20:28,639
normalized latency so lower is better

610
00:20:25,600 --> 00:20:30,639
here pmdk was significantly worse in

611
00:20:28,640 --> 00:20:31,919
almost all tests while twizzler was

612
00:20:30,640 --> 00:20:33,919
similar to the others

613
00:20:31,919 --> 00:20:35,919
note that we're comparing two highly

614
00:20:33,919 --> 00:20:37,840
optimized b3 back-ends to

615
00:20:35,919 --> 00:20:39,440
two fairly straightforward red blacktree

616
00:20:37,840 --> 00:20:41,199
implementations

617
00:20:39,440 --> 00:20:43,120
we attribute the performance difference

618
00:20:41,200 --> 00:20:45,280
between twizzler and pmdk

619
00:20:43,120 --> 00:20:46,320
to twizzler's pointer operations being

620
00:20:45,280 --> 00:20:49,280
more efficient and

621
00:20:46,320 --> 00:20:49,918
also to pmdk's doubling pointers in size

622
00:20:49,280 --> 00:20:51,760
which has

623
00:20:49,919 --> 00:20:53,360
a significant impact on cache

624
00:20:51,760 --> 00:20:55,039
performance and pointer heavy data

625
00:20:53,360 --> 00:20:56,799
structures

626
00:20:55,039 --> 00:20:58,799
twizzler is of course still under

627
00:20:56,799 --> 00:21:00,720
development in many ways but

628
00:20:58,799 --> 00:21:03,200
one of the directions we're most excited

629
00:21:00,720 --> 00:21:05,039
about exploring is placing twizzler into

630
00:21:03,200 --> 00:21:07,520
a distributed environment

631
00:21:05,039 --> 00:21:08,640
the global namespace of object ids can

632
00:21:07,520 --> 00:21:12,158
be truly that

633
00:21:08,640 --> 00:21:14,720
global because twizzler has pointers

634
00:21:12,159 --> 00:21:17,120
based on identity and not location

635
00:21:14,720 --> 00:21:18,880
moving data around a network can be done

636
00:21:17,120 --> 00:21:20,959
much more easily even to the point

637
00:21:18,880 --> 00:21:22,640
where we can easily manifest either

638
00:21:20,960 --> 00:21:24,559
computation or data

639
00:21:22,640 --> 00:21:26,880
wherever they may be needed changing the

640
00:21:24,559 --> 00:21:28,960
focus of distributed programming away

641
00:21:26,880 --> 00:21:30,640
from manually marshaling data around

642
00:21:28,960 --> 00:21:32,240
computers and instead

643
00:21:30,640 --> 00:21:35,520
describing more clearly what the

644
00:21:32,240 --> 00:21:37,919
computation needs to be

645
00:21:35,520 --> 00:21:40,240
we're very excited about twizzler both

646
00:21:37,919 --> 00:21:42,720
in sharing it with all of you but also

647
00:21:40,240 --> 00:21:43,760
in where we can go with it we hope to

648
00:21:42,720 --> 00:21:46,720
have gotten across

649
00:21:43,760 --> 00:21:47,840
three key points in this video first

650
00:21:46,720 --> 00:21:49,679
this technology

651
00:21:47,840 --> 00:21:51,678
is coming and it has the potential to

652
00:21:49,679 --> 00:21:54,000
greatly change our programming models

653
00:21:51,679 --> 00:21:56,080
we want to be ready for that programming

654
00:21:54,000 --> 00:21:58,240
has always been about data

655
00:21:56,080 --> 00:21:59,199
and we have an opportunity now to make

656
00:21:58,240 --> 00:22:02,480
our abstractions

657
00:21:59,200 --> 00:22:03,280
really reflect this second the time for

658
00:22:02,480 --> 00:22:06,320
a new os

659
00:22:03,280 --> 00:22:08,080
is now not just because of nvm but this

660
00:22:06,320 --> 00:22:10,320
greatly accelerates the need

661
00:22:08,080 --> 00:22:11,600
but because new applications built in

662
00:22:10,320 --> 00:22:14,879
new ways deserve

663
00:22:11,600 --> 00:22:16,879
first class os support compatibility is

664
00:22:14,880 --> 00:22:19,200
a vital feature to be sure but

665
00:22:16,880 --> 00:22:20,559
the primary abstractions provided by the

666
00:22:19,200 --> 00:22:24,080
operating system are not

667
00:22:20,559 --> 00:22:26,399
compatibility finally

668
00:22:24,080 --> 00:22:28,158
working with persistent data on nvm

669
00:22:26,400 --> 00:22:29,840
naturally means that we'll be working

670
00:22:28,159 --> 00:22:30,799
with persistent in-memory data

671
00:22:29,840 --> 00:22:32,559
structures

672
00:22:30,799 --> 00:22:34,480
these structures will need ways of

673
00:22:32,559 --> 00:22:37,600
accessing and understanding data

674
00:22:34,480 --> 00:22:38,640
that don't rely on ephemeral context if

675
00:22:37,600 --> 00:22:41,039
we get this right

676
00:22:38,640 --> 00:22:43,039
we have an opportunity to have a fast

677
00:22:41,039 --> 00:22:44,000
but also flexible persistent pointer

678
00:22:43,039 --> 00:22:46,240
implementation

679
00:22:44,000 --> 00:22:49,280
that allows us to open our data up to a

680
00:22:46,240 --> 00:22:52,320
global address space

681
00:22:49,280 --> 00:22:55,520
so this is a new os it's a

682
00:22:52,320 --> 00:22:56,879
rare and risky endeavor but we believe

683
00:22:55,520 --> 00:22:59,600
that it's the right thing

684
00:22:56,880 --> 00:23:00,400
not just for a future with nvm but for

685
00:22:59,600 --> 00:23:03,520
any future

686
00:23:00,400 --> 00:23:05,440
centered on data as the primary citizen

687
00:23:03,520 --> 00:23:07,200
but of course the test of a new os is

688
00:23:05,440 --> 00:23:08,000
how well it supports innovation and how

689
00:23:07,200 --> 00:23:10,080
well it excites

690
00:23:08,000 --> 00:23:13,120
people so we would love it if you read

691
00:23:10,080 --> 00:23:15,120
the paper and gave us feedback

692
00:23:13,120 --> 00:23:17,280
thank you for getting to the end i would

693
00:23:15,120 --> 00:23:20,399
like to quickly thank my co-conspirators

694
00:23:17,280 --> 00:23:21,200
peter pankaj daryl and ethan and my lab

695
00:23:20,400 --> 00:23:24,000
mates for their

696
00:23:21,200 --> 00:23:25,120
unending support we're really excited to

697
00:23:24,000 --> 00:23:37,840
share this work with you

698
00:23:25,120 --> 00:23:37,840
thank you for watching

