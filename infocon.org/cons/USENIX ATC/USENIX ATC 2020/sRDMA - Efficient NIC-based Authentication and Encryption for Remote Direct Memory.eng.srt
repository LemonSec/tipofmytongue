1
00:00:08,000 --> 00:00:10,240
hi everyone

2
00:00:08,800 --> 00:00:12,000
thank you for joining the talk my name

3
00:00:10,240 --> 00:00:13,120
is constantin tarana and today we'll be

4
00:00:12,000 --> 00:00:16,000
talking to you about

5
00:00:13,120 --> 00:00:17,759
s rdma which is our security extension

6
00:00:16,000 --> 00:00:19,439
to remote direct memory access which

7
00:00:17,760 --> 00:00:22,320
enables end-to-end authentication

8
00:00:19,439 --> 00:00:23,920
and encryption srdm is a result of joint

9
00:00:22,320 --> 00:00:24,320
work of scalable parallel computing

10
00:00:23,920 --> 00:00:27,840
cloud

11
00:00:24,320 --> 00:00:29,439
and network security group rdm is a

12
00:00:27,840 --> 00:00:30,080
mechanism which allows one machine to

13
00:00:29,439 --> 00:00:32,000
access memory

14
00:00:30,080 --> 00:00:33,360
of another machine through the network

15
00:00:32,000 --> 00:00:35,280
all these memory accesses

16
00:00:33,360 --> 00:00:36,800
are floated to the network controllers

17
00:00:35,280 --> 00:00:38,640
which enables high bandwidth and low

18
00:00:36,800 --> 00:00:41,919
latency communication

19
00:00:38,640 --> 00:00:44,160
rdm is widely used for hpc and machine

20
00:00:41,920 --> 00:00:47,840
learning workloads

21
00:00:44,160 --> 00:00:50,718
rgm is publicly available right now at

22
00:00:47,840 --> 00:00:51,920
microsoft azure cloud and oracle clouds

23
00:00:50,719 --> 00:00:53,680
and each year

24
00:00:51,920 --> 00:00:55,520
we have more and more systems which make

25
00:00:53,680 --> 00:00:57,840
use of rdma to speed up their

26
00:00:55,520 --> 00:00:59,920
performance

27
00:00:57,840 --> 00:01:02,719
such performance advantage comes at the

28
00:00:59,920 --> 00:01:06,240
cost which actually is paid by security

29
00:01:02,719 --> 00:01:08,799
even in december 2005 it was pointed out

30
00:01:06,240 --> 00:01:11,839
in rfc 4297

31
00:01:08,799 --> 00:01:15,439
that rdma has to support ibc

32
00:01:11,840 --> 00:01:16,560
and tls however in march 2017 when

33
00:01:15,439 --> 00:01:18,960
somebody asked

34
00:01:16,560 --> 00:01:20,159
this question on the melanoc security

35
00:01:18,960 --> 00:01:22,559
forum it was

36
00:01:20,159 --> 00:01:24,840
replied by melanox expert that

37
00:01:22,560 --> 00:01:27,520
infiniband architecture doesn't yet

38
00:01:24,840 --> 00:01:28,240
support security and it's a challenging

39
00:01:27,520 --> 00:01:31,520
problem

40
00:01:28,240 --> 00:01:32,399
and right now in july 2020 ipsec doesn't

41
00:01:31,520 --> 00:01:36,000
still support

42
00:01:32,400 --> 00:01:36,960
rdma traffic one can ask whether we can

43
00:01:36,000 --> 00:01:40,159
use actually

44
00:01:36,960 --> 00:01:42,880
application level security in this case

45
00:01:40,159 --> 00:01:44,479
since rdma completely of loads packet

46
00:01:42,880 --> 00:01:47,039
processing to the network control

47
00:01:44,479 --> 00:01:49,039
controllers cpu is not even involved in

48
00:01:47,040 --> 00:01:53,119
packet processing

49
00:01:49,040 --> 00:01:55,200
and if we use two-sided communication

50
00:01:53,119 --> 00:01:56,640
then packets are also processed by the

51
00:01:55,200 --> 00:01:59,600
network controllers

52
00:01:56,640 --> 00:02:01,439
as a result the message has to be fully

53
00:01:59,600 --> 00:02:04,798
received in order to be processed

54
00:02:01,439 --> 00:02:09,119
and the cpu would spend its cycles on

55
00:02:04,799 --> 00:02:11,840
verifying such messages

56
00:02:09,119 --> 00:02:14,319
that's why we propose srdma which is our

57
00:02:11,840 --> 00:02:16,319
lightweight security extension to rdma

58
00:02:14,319 --> 00:02:17,839
which uses symmetric key cryptography to

59
00:02:16,319 --> 00:02:18,799
provide header authentication packet

60
00:02:17,840 --> 00:02:21,520
authentication

61
00:02:18,800 --> 00:02:23,680
payload encryption and memory protection

62
00:02:21,520 --> 00:02:25,599
srtm may effectively prevent if dropping

63
00:02:23,680 --> 00:02:28,560
spoofing attacks replay attacks and men

64
00:02:25,599 --> 00:02:28,560
in the metal attacks

65
00:02:28,720 --> 00:02:31,920
srdma was designed to be back

66
00:02:30,480 --> 00:02:34,160
completable

67
00:02:31,920 --> 00:02:36,559
and it can be easily adapted by existing

68
00:02:34,160 --> 00:02:38,640
infiniband architecture

69
00:02:36,560 --> 00:02:40,959
from the user perspective we propose new

70
00:02:38,640 --> 00:02:42,958
secure reliably connected viewpair

71
00:02:40,959 --> 00:02:44,000
which requires the user to install

72
00:02:42,959 --> 00:02:47,599
symmetric key

73
00:02:44,000 --> 00:02:50,879
and required level of

74
00:02:47,599 --> 00:02:54,959
required level of protection srd map

75
00:02:50,879 --> 00:02:57,679
supports various security protections

76
00:02:54,959 --> 00:02:59,599
it can be used to enable header

77
00:02:57,680 --> 00:03:02,159
authentication and packet authentication

78
00:02:59,599 --> 00:03:05,359
using hash based message of etk

79
00:03:02,159 --> 00:03:07,599
message authentication code such as sha

80
00:03:05,360 --> 00:03:11,760
or cipher based message authentication

81
00:03:07,599 --> 00:03:14,319
code such as eas or poly1305

82
00:03:11,760 --> 00:03:15,200
in addition srdma supports authenticated

83
00:03:14,319 --> 00:03:16,879
encryption

84
00:03:15,200 --> 00:03:19,839
which provides secrecy to the

85
00:03:16,879 --> 00:03:19,840
communication

86
00:03:20,319 --> 00:03:24,480
right now i'd like to talk about srdma

87
00:03:22,080 --> 00:03:26,879
packet format classical rdma packet

88
00:03:24,480 --> 00:03:30,238
consists of routing header transport

89
00:03:26,879 --> 00:03:33,120
header payload and checksums

90
00:03:30,239 --> 00:03:35,440
ipc usually encapsulates the packets and

91
00:03:33,120 --> 00:03:37,360
it's even discussed right now that ipc

92
00:03:35,440 --> 00:03:39,040
would encapsulate the rdma which means

93
00:03:37,360 --> 00:03:41,360
the devices would need

94
00:03:39,040 --> 00:03:43,040
to be able to process ipsec packets in

95
00:03:41,360 --> 00:03:46,400
order in order to process

96
00:03:43,040 --> 00:03:49,040
rdma packets that's why we think that

97
00:03:46,400 --> 00:03:50,159
security has to be a part of the

98
00:03:49,040 --> 00:03:52,319
protocol

99
00:03:50,159 --> 00:03:55,519
and the its security header has to be

100
00:03:52,319 --> 00:03:57,599
located after the transfer header

101
00:03:55,519 --> 00:04:00,959
as a result this doesn't change any

102
00:03:57,599 --> 00:04:02,640
algorithms how the packets are

103
00:04:00,959 --> 00:04:04,400
processed in terms of routing and

104
00:04:02,640 --> 00:04:07,599
calculation on the checksums

105
00:04:04,400 --> 00:04:10,319
and already the devices can

106
00:04:07,599 --> 00:04:14,159
process and already existing devices can

107
00:04:10,319 --> 00:04:15,760
process such packets

108
00:04:14,159 --> 00:04:17,759
the small change we propose to the

109
00:04:15,760 --> 00:04:19,519
existing transport header is to use

110
00:04:17,759 --> 00:04:21,199
three out of seven reserve bits to

111
00:04:19,519 --> 00:04:23,520
indicate the presence of the secure

112
00:04:21,199 --> 00:04:25,759
header

113
00:04:23,520 --> 00:04:27,440
depending on the value encoded in these

114
00:04:25,759 --> 00:04:30,000
three bits

115
00:04:27,440 --> 00:04:31,840
we encode the size of the secure header

116
00:04:30,000 --> 00:04:32,960
the secure header only contains message

117
00:04:31,840 --> 00:04:35,520
authentication code

118
00:04:32,960 --> 00:04:37,599
and if this three bits has value zero it

119
00:04:35,520 --> 00:04:38,000
means there is no secure header present

120
00:04:37,600 --> 00:04:40,400
which

121
00:04:38,000 --> 00:04:43,440
enables back compatibility with existing

122
00:04:40,400 --> 00:04:45,280
rdma architecture

123
00:04:43,440 --> 00:04:46,800
the message authentication code varies

124
00:04:45,280 --> 00:04:50,080
from 96 bit to

125
00:04:46,800 --> 00:04:50,080
512 bits

126
00:04:50,960 --> 00:04:55,440
another change which would require from

127
00:04:52,639 --> 00:04:57,919
the hardware is

128
00:04:55,440 --> 00:04:59,440
related to the packet sequence number to

129
00:04:57,919 --> 00:05:02,240
provide

130
00:04:59,440 --> 00:05:03,440
protection against replay attacks the

131
00:05:02,240 --> 00:05:04,880
protocol has to

132
00:05:03,440 --> 00:05:06,639
ensure uniqueness of the message

133
00:05:04,880 --> 00:05:09,120
authentication code by

134
00:05:06,639 --> 00:05:11,199
including unique value in computation of

135
00:05:09,120 --> 00:05:13,360
the message authentication codes

136
00:05:11,199 --> 00:05:15,120
ipsec currently used just packets

137
00:05:13,360 --> 00:05:17,280
sequence counter for that

138
00:05:15,120 --> 00:05:19,120
that's why we decided also to reuse

139
00:05:17,280 --> 00:05:21,520
existing packet sequence number from

140
00:05:19,120 --> 00:05:22,560
pin event architecture however this

141
00:05:21,520 --> 00:05:26,880
packet sequence number

142
00:05:22,560 --> 00:05:28,880
adjust 24 bits and if we take existing

143
00:05:26,880 --> 00:05:31,039
network controllers which can eject 200

144
00:05:28,880 --> 00:05:34,479
million packets per seconds

145
00:05:31,039 --> 00:05:37,599
these 24 bit counters gets reduced after

146
00:05:34,479 --> 00:05:38,000
80 milliseconds which means to provide

147
00:05:37,600 --> 00:05:40,240
secure

148
00:05:38,000 --> 00:05:42,080
communication application was required

149
00:05:40,240 --> 00:05:45,280
to re-establish connection

150
00:05:42,080 --> 00:05:47,198
each 80 milliseconds that's why we

151
00:05:45,280 --> 00:05:49,840
proposed to extend this

152
00:05:47,199 --> 00:05:51,680
counselors to 64 bits but we would

153
00:05:49,840 --> 00:05:54,719
extend only the countersunk

154
00:05:51,680 --> 00:05:57,600
end points we would still transmit

155
00:05:54,720 --> 00:05:59,199
24 least significant bits in the packets

156
00:05:57,600 --> 00:06:00,000
since the packet sequence number i

157
00:05:59,199 --> 00:06:02,080
ordered

158
00:06:00,000 --> 00:06:03,759
and get incremented by one for each

159
00:06:02,080 --> 00:06:07,120
packet using just

160
00:06:03,759 --> 00:06:07,759
24 least significant bits we can derive

161
00:06:07,120 --> 00:06:11,680
the full

162
00:06:07,759 --> 00:06:13,120
64-bit counter 64-bit value used

163
00:06:11,680 --> 00:06:15,759
in the computation of the message

164
00:06:13,120 --> 00:06:15,759
authentication

165
00:06:18,080 --> 00:06:24,880
depending on the security code installed

166
00:06:21,600 --> 00:06:26,479
in the connection srdma uses different

167
00:06:24,880 --> 00:06:27,840
algorithms for computation of the

168
00:06:26,479 --> 00:06:30,000
message authentication code

169
00:06:27,840 --> 00:06:32,960
in case of authenticated encryption the

170
00:06:30,000 --> 00:06:34,800
payload will be also encrypted

171
00:06:32,960 --> 00:06:37,359
right now i'd like to talk about the

172
00:06:34,800 --> 00:06:39,440
overheads of srd may compare to the ip6

173
00:06:37,360 --> 00:06:40,800
which is does not exist yet

174
00:06:39,440 --> 00:06:42,479
but it would have the following

175
00:06:40,800 --> 00:06:45,919
overheads

176
00:06:42,479 --> 00:06:46,880
of course in case of as128 when we have

177
00:06:45,919 --> 00:06:49,680
n connections

178
00:06:46,880 --> 00:06:51,199
the both in both for both protocols we

179
00:06:49,680 --> 00:06:52,639
would need to store the key on the

180
00:06:51,199 --> 00:06:55,039
device

181
00:06:52,639 --> 00:06:56,560
which results in 16 but multiplied by n

182
00:06:55,039 --> 00:06:59,599
bytes

183
00:06:56,560 --> 00:07:01,759
however since srdma reuses the existing

184
00:06:59,599 --> 00:07:02,800
counters we would need to only add 10

185
00:07:01,759 --> 00:07:05,199
bytes

186
00:07:02,800 --> 00:07:07,599
to the existing counters in order to

187
00:07:05,199 --> 00:07:07,599
provide

188
00:07:07,919 --> 00:07:11,359
protection against replay attacks ipsec

189
00:07:10,560 --> 00:07:13,840
has its

190
00:07:11,360 --> 00:07:14,960
own counters which would require to use

191
00:07:13,840 --> 00:07:17,919
16 byte

192
00:07:14,960 --> 00:07:18,880
per connection on the network

193
00:07:17,919 --> 00:07:21,919
controllers

194
00:07:18,880 --> 00:07:24,240
finally srdma stores only the message

195
00:07:21,919 --> 00:07:27,039
authentication code in the header which

196
00:07:24,240 --> 00:07:30,560
16 byte for the as128

197
00:07:27,039 --> 00:07:30,960
ipsec header is much larger and this 32

198
00:07:30,560 --> 00:07:34,240
byte

199
00:07:30,960 --> 00:07:36,080
is the really lower bound value

200
00:07:34,240 --> 00:07:38,000
and it doesn't even include the

201
00:07:36,080 --> 00:07:41,039
encapsulation overhead

202
00:07:38,000 --> 00:07:41,039
of the ipcx

203
00:07:41,360 --> 00:07:45,759
since memory is a precious resource for

204
00:07:44,400 --> 00:07:48,638
network controllers we

205
00:07:45,759 --> 00:07:49,599
also want to decrease at this memory

206
00:07:48,639 --> 00:07:52,960
overheads

207
00:07:49,599 --> 00:07:54,319
many work reported that exhaustion of

208
00:07:52,960 --> 00:07:56,479
the memorial network

209
00:07:54,319 --> 00:07:58,319
controllers can significantly degrade

210
00:07:56,479 --> 00:08:00,318
the performance

211
00:07:58,319 --> 00:08:02,080
that's why we decided to use the concept

212
00:08:00,319 --> 00:08:02,800
of protection domain from infiniband

213
00:08:02,080 --> 00:08:05,840
architecture

214
00:08:02,800 --> 00:08:09,360
infiniband architecture proposed

215
00:08:05,840 --> 00:08:11,359
introduces protection domains as a way

216
00:08:09,360 --> 00:08:13,360
of sharing resources between connections

217
00:08:11,360 --> 00:08:15,280
all the connections are created

218
00:08:13,360 --> 00:08:17,599
inside of this protection domains and it

219
00:08:15,280 --> 00:08:21,198
means these connections

220
00:08:17,599 --> 00:08:21,199
can share memory resources

221
00:08:21,360 --> 00:08:24,639
we propose instead of installing

222
00:08:23,120 --> 00:08:27,199
symmetric key per connection

223
00:08:24,639 --> 00:08:28,479
install one symmetric key in the

224
00:08:27,199 --> 00:08:31,440
protection domain

225
00:08:28,479 --> 00:08:32,880
and then all compare level keys will be

226
00:08:31,440 --> 00:08:36,159
derived from this

227
00:08:32,880 --> 00:08:37,599
protection domain level key for the

228
00:08:36,159 --> 00:08:41,279
derivation we would

229
00:08:37,599 --> 00:08:43,279
we use the addresses of the

230
00:08:41,279 --> 00:08:45,120
of the endpoints and it's guaranteed the

231
00:08:43,279 --> 00:08:47,839
two end points will generate

232
00:08:45,120 --> 00:08:49,600
the same symmetric key for qbl q

233
00:08:47,839 --> 00:08:51,920
parallel key

234
00:08:49,600 --> 00:08:52,640
as a result the network controller

235
00:08:51,920 --> 00:08:55,920
doesn't

236
00:08:52,640 --> 00:08:57,439
need to store key for each connection it

237
00:08:55,920 --> 00:09:00,079
can only store the key for the

238
00:08:57,440 --> 00:09:01,440
protection domain and derive the keys of

239
00:09:00,080 --> 00:09:03,680
the couper

240
00:09:01,440 --> 00:09:04,640
for the q pairs on the fly which

241
00:09:03,680 --> 00:09:08,640
significantly

242
00:09:04,640 --> 00:09:11,519
decrease the memory overhead

243
00:09:08,640 --> 00:09:12,399
finally srd may provide extended memory

244
00:09:11,519 --> 00:09:15,440
protection

245
00:09:12,399 --> 00:09:17,120
to the infiniband architecture right now

246
00:09:15,440 --> 00:09:19,200
the protection of the memory is based

247
00:09:17,120 --> 00:09:21,360
on the notion of arches which are just

248
00:09:19,200 --> 00:09:24,480
32-bit values which are transmitted in

249
00:09:21,360 --> 00:09:27,200
the plain text in it packet

250
00:09:24,480 --> 00:09:28,160
so if endpoint a wants to enable memory

251
00:09:27,200 --> 00:09:31,120
access

252
00:09:28,160 --> 00:09:32,160
to the sum endpoint b it would send this

253
00:09:31,120 --> 00:09:35,120
r key value

254
00:09:32,160 --> 00:09:36,640
to the endpoint b however it can share

255
00:09:35,120 --> 00:09:40,080
this key within point c

256
00:09:36,640 --> 00:09:42,080
or network if dropper can see this key

257
00:09:40,080 --> 00:09:45,519
in the packets and gain the access to

258
00:09:42,080 --> 00:09:45,519
the memory of endpoint a

259
00:09:45,760 --> 00:09:49,519
that's why we propose crypto based

260
00:09:47,360 --> 00:09:52,800
memory protection

261
00:09:49,519 --> 00:09:55,839
whose main idea is to provide separate

262
00:09:52,800 --> 00:09:58,719
uh crypto based

263
00:09:55,839 --> 00:10:00,320
uh access keys to the memory regions

264
00:09:58,720 --> 00:10:03,120
which are calculated

265
00:10:00,320 --> 00:10:03,600
from the boundaries of the memory region

266
00:10:03,120 --> 00:10:08,000
you

267
00:10:03,600 --> 00:10:08,000
at the end point would like to access

268
00:10:08,160 --> 00:10:12,079
the position to prove the position of

269
00:10:09,920 --> 00:10:13,760
this key endpoints have to include it

270
00:10:12,079 --> 00:10:15,839
in the calculation of the message

271
00:10:13,760 --> 00:10:18,720
authentication code as a result

272
00:10:15,839 --> 00:10:20,560
srdma does not require any extra message

273
00:10:18,720 --> 00:10:22,560
any extra headers

274
00:10:20,560 --> 00:10:24,399
for enabling this extended memory

275
00:10:22,560 --> 00:10:27,119
protection and existing

276
00:10:24,399 --> 00:10:29,760
field of message authentication code can

277
00:10:27,120 --> 00:10:29,760
be reused

278
00:10:30,880 --> 00:10:33,920
right now i'd like to talk about

279
00:10:32,079 --> 00:10:36,000
implementation of sr gaming

280
00:10:33,920 --> 00:10:37,360
so s rdma was prototyped on a smart nick

281
00:10:36,000 --> 00:10:41,120
from broadcom

282
00:10:37,360 --> 00:10:42,720
uh this was stingray eps 225.

283
00:10:41,120 --> 00:10:45,760
uh this smart thing is equipped with

284
00:10:42,720 --> 00:10:48,959
eight core arm 8072 cpu

285
00:10:45,760 --> 00:10:51,279
and it has 8 gigabytes of dram

286
00:10:48,959 --> 00:10:52,160
we chose the smart nic because it

287
00:10:51,279 --> 00:10:55,200
supports

288
00:10:52,160 --> 00:10:58,480
crypto acceleration

289
00:10:55,200 --> 00:10:59,440
this marking has two ports of 25

290
00:10:58,480 --> 00:11:02,240
gigabits

291
00:10:59,440 --> 00:11:05,360
however for smartening capability only

292
00:11:02,240 --> 00:11:05,360
one port is available

293
00:11:05,519 --> 00:11:09,279
also since we implemented srdma on the

294
00:11:08,640 --> 00:11:12,399
top of

295
00:11:09,279 --> 00:11:15,040
normal rdma connection we had available

296
00:11:12,399 --> 00:11:16,800
only 20.6 gigabits per second so this is

297
00:11:15,040 --> 00:11:20,079
our line rate which we

298
00:11:16,800 --> 00:11:23,599
try to compare with uh so

299
00:11:20,079 --> 00:11:25,760
first we i checked the performance of uh

300
00:11:23,600 --> 00:11:27,200
crypt engine installed in the smartening

301
00:11:25,760 --> 00:11:31,680
and we tried d4

302
00:11:27,200 --> 00:11:34,000
different uh uh encryption algorithms of

303
00:11:31,680 --> 00:11:36,160
use and we used them for authentication

304
00:11:34,000 --> 00:11:38,399
of the memory blocks so we tried three

305
00:11:36,160 --> 00:11:40,560
block sizes 64 bytes

306
00:11:38,399 --> 00:11:42,320
one kilobyte or two kilobytes and we

307
00:11:40,560 --> 00:11:45,040
also tried different number of

308
00:11:42,320 --> 00:11:46,320
threads so as as you can see for the

309
00:11:45,040 --> 00:11:48,240
large blocks

310
00:11:46,320 --> 00:11:50,480
uh we could achieve line rate for all

311
00:11:48,240 --> 00:11:52,720
algorithms using all the frets

312
00:11:50,480 --> 00:11:53,680
and we could actually achieve this line

313
00:11:52,720 --> 00:11:56,320
rate

314
00:11:53,680 --> 00:11:57,439
almost for all algorithms using less

315
00:11:56,320 --> 00:12:00,880
threats

316
00:11:57,440 --> 00:12:02,880
it was a bit harder for smaller blocks

317
00:12:00,880 --> 00:12:04,000
since the hash based algorithms they are

318
00:12:02,880 --> 00:12:06,560
not

319
00:12:04,000 --> 00:12:07,920
uh tuned they were not designed to be

320
00:12:06,560 --> 00:12:10,479
applied to the

321
00:12:07,920 --> 00:12:11,920
small blocks that's why they have really

322
00:12:10,480 --> 00:12:14,880
poor performance

323
00:12:11,920 --> 00:12:16,160
however this is you will see on the next

324
00:12:14,880 --> 00:12:17,760
slide that it's even

325
00:12:16,160 --> 00:12:19,279
it's enough to perform header

326
00:12:17,760 --> 00:12:22,720
authentication but

327
00:12:19,279 --> 00:12:23,279
uh aes or like cipher based algorithms

328
00:12:22,720 --> 00:12:26,320
are

329
00:12:23,279 --> 00:12:29,040
better targeted for small

330
00:12:26,320 --> 00:12:30,560
messages uh that's why actually for

331
00:12:29,040 --> 00:12:33,920
ketervation we use

332
00:12:30,560 --> 00:12:34,479
es algorithm because it was the fastest

333
00:12:33,920 --> 00:12:37,360
one

334
00:12:34,480 --> 00:12:38,160
working with the small sizes for the

335
00:12:37,360 --> 00:12:40,079
blocks of small

336
00:12:38,160 --> 00:12:42,480
small sizes it was the fastest algorithm

337
00:12:40,079 --> 00:12:45,680
which could generate new key from a

338
00:12:42,480 --> 00:12:48,160
master uh

339
00:12:45,680 --> 00:12:49,279
right now i'd like to talk how srdma was

340
00:12:48,160 --> 00:12:50,880
actually implemented

341
00:12:49,279 --> 00:12:52,639
so let's imagine the case when we have

342
00:12:50,880 --> 00:12:55,120
two endpoints we have endpoint a

343
00:12:52,639 --> 00:12:56,000
and end point b each endpoint is

344
00:12:55,120 --> 00:12:59,360
represented by

345
00:12:56,000 --> 00:13:02,720
its host application and its smart d

346
00:12:59,360 --> 00:13:04,800
and to send the message uh

347
00:13:02,720 --> 00:13:05,839
between two hosts so host a wants to

348
00:13:04,800 --> 00:13:07,439
send to messages b

349
00:13:05,839 --> 00:13:09,040
we need to establish overall free

350
00:13:07,440 --> 00:13:10,639
connection first

351
00:13:09,040 --> 00:13:12,399
host has to establish connection with

352
00:13:10,639 --> 00:13:15,040
their smart nic this connection

353
00:13:12,399 --> 00:13:17,440
represents dma connection

354
00:13:15,040 --> 00:13:20,560
and then we establish a connection

355
00:13:17,440 --> 00:13:22,800
between smart nics

356
00:13:20,560 --> 00:13:25,040
uh right now i would like to show how a

357
00:13:22,800 --> 00:13:28,079
secure artimer write can be performed

358
00:13:25,040 --> 00:13:28,959
on our platform so first they'd like to

359
00:13:28,079 --> 00:13:30,399
send a message

360
00:13:28,959 --> 00:13:32,959
write the message to the member of the

361
00:13:30,399 --> 00:13:35,519
host b first it would send it to the

362
00:13:32,959 --> 00:13:37,040
it's marketing smart depending on the

363
00:13:35,519 --> 00:13:41,199
security level installed

364
00:13:37,040 --> 00:13:42,880
it would uh calculate the uh

365
00:13:41,199 --> 00:13:44,479
message authentication code and append

366
00:13:42,880 --> 00:13:47,680
it uh to the

367
00:13:44,480 --> 00:13:51,120
message and then it will send it

368
00:13:47,680 --> 00:13:53,199
to the smart nic of the endpoint b

369
00:13:51,120 --> 00:13:54,320
the smart link would receive it and it

370
00:13:53,199 --> 00:13:57,920
would validate

371
00:13:54,320 --> 00:13:59,680
this uh message of integration code and

372
00:13:57,920 --> 00:14:03,040
if validation was successful

373
00:13:59,680 --> 00:14:06,239
the smart nic will write this

374
00:14:03,040 --> 00:14:09,839
payload to the memory of the host b so

375
00:14:06,240 --> 00:14:12,399
as you can imagine the the latency would

376
00:14:09,839 --> 00:14:12,880
go up compared to the normal case since

377
00:14:12,399 --> 00:14:18,079
we have

378
00:14:12,880 --> 00:14:22,079
three communications to deliver a packet

379
00:14:18,079 --> 00:14:25,199
uh that's why uh so our baseline latency

380
00:14:22,079 --> 00:14:27,839
was uh 9.5 microseconds for half round

381
00:14:25,199 --> 00:14:33,199
trip and the full round trip it was

382
00:14:27,839 --> 00:14:36,480
about 18 uh microseconds

383
00:14:33,199 --> 00:14:38,479
so here i'd like to show you the latency

384
00:14:36,480 --> 00:14:39,839
for the source authentication so for

385
00:14:38,480 --> 00:14:41,760
write and read latency

386
00:14:39,839 --> 00:14:43,519
right we showed the results for half

387
00:14:41,760 --> 00:14:44,560
round trip and for read we show the

388
00:14:43,519 --> 00:14:48,160
results for full

389
00:14:44,560 --> 00:14:50,399
round trip uh so in the basic case so

390
00:14:48,160 --> 00:14:53,120
the basic case is when we just

391
00:14:50,399 --> 00:14:53,440
uh the nick has a key at the just uh add

392
00:14:53,120 --> 00:14:55,760
the

393
00:14:53,440 --> 00:14:57,279
mac and send it to the other side we

394
00:14:55,760 --> 00:14:59,760
could see that for aas

395
00:14:57,279 --> 00:15:01,040
this latency was less than microseconds

396
00:14:59,760 --> 00:15:02,560
and

397
00:15:01,040 --> 00:15:04,399
what is important that this one

398
00:15:02,560 --> 00:15:07,279
microseconds is

399
00:15:04,399 --> 00:15:07,680
uh comprises of two parts first part is

400
00:15:07,279 --> 00:15:10,160
when

401
00:15:07,680 --> 00:15:11,680
we calculate the message authentication

402
00:15:10,160 --> 00:15:13,680
code on the sender

403
00:15:11,680 --> 00:15:15,439
and when we verify this message

404
00:15:13,680 --> 00:15:18,800
authentication code on the receiver so

405
00:15:15,440 --> 00:15:22,240
overall it's 0.2

406
00:15:18,800 --> 00:15:26,079
three microseconds on each sides

407
00:15:22,240 --> 00:15:29,279
to work with the header authentication

408
00:15:26,079 --> 00:15:30,079
uh of course uh hash based algorithms

409
00:15:29,279 --> 00:15:32,480
such as

410
00:15:30,079 --> 00:15:34,399
they had higher latency because as i

411
00:15:32,480 --> 00:15:36,639
mentioned earlier there were not

412
00:15:34,399 --> 00:15:37,759
designed to work with small sizes and

413
00:15:36,639 --> 00:15:42,320
the the

414
00:15:37,759 --> 00:15:42,320
header of the message is quite small

415
00:15:43,120 --> 00:15:47,199
right now i'd like to show results for

416
00:15:45,279 --> 00:15:47,920
the pt protection extended protection

417
00:15:47,199 --> 00:15:50,639
case

418
00:15:47,920 --> 00:15:52,160
so as you remember the pd protection

419
00:15:50,639 --> 00:15:55,360
extended memory protection

420
00:15:52,160 --> 00:15:58,719
requires key derivation and this latency

421
00:15:55,360 --> 00:16:00,800
is actually worst case scenario that's

422
00:15:58,720 --> 00:16:02,720
when the nic doesn't have a key to

423
00:16:00,800 --> 00:16:03,920
immediately to calculate the message

424
00:16:02,720 --> 00:16:06,800
authentication code

425
00:16:03,920 --> 00:16:09,040
so it has to first derive it but in the

426
00:16:06,800 --> 00:16:11,040
real case uh

427
00:16:09,040 --> 00:16:12,319
the smart nick would cache it and we

428
00:16:11,040 --> 00:16:14,800
would expect

429
00:16:12,320 --> 00:16:15,600
the performance as for basic case but

430
00:16:14,800 --> 00:16:18,000
here

431
00:16:15,600 --> 00:16:19,120
this is the latency what if we sender

432
00:16:18,000 --> 00:16:22,000
wants to send it

433
00:16:19,120 --> 00:16:23,920
and its smartnig doesn't have a key in

434
00:16:22,000 --> 00:16:27,120
cache and has to first

435
00:16:23,920 --> 00:16:29,199
derive it to protect the packet

436
00:16:27,120 --> 00:16:30,240
and the receiver as well it cannot

437
00:16:29,199 --> 00:16:32,560
immediately

438
00:16:30,240 --> 00:16:33,839
start verifying the packet the first

439
00:16:32,560 --> 00:16:34,638
need to derive the key and then the

440
00:16:33,839 --> 00:16:37,120
search

441
00:16:34,639 --> 00:16:38,079
verification so in that case the latency

442
00:16:37,120 --> 00:16:41,120
goes

443
00:16:38,079 --> 00:16:43,439
up even higher so with each

444
00:16:41,120 --> 00:16:45,040
process observation adds about one

445
00:16:43,440 --> 00:16:48,160
microsecond

446
00:16:45,040 --> 00:16:51,439
on each side and of course when we

447
00:16:48,160 --> 00:16:54,079
had the experiment when we had uh

448
00:16:51,440 --> 00:16:55,040
both enabled so we need to derive keys

449
00:16:54,079 --> 00:16:57,920
twice

450
00:16:55,040 --> 00:16:58,719
uh the latency even uh went up but i'd

451
00:16:57,920 --> 00:17:01,279
like to

452
00:16:58,720 --> 00:17:02,720
um point out again that this is the

453
00:17:01,279 --> 00:17:07,119
worst case scenario this is

454
00:17:02,720 --> 00:17:07,120
what if the key is not in cache

455
00:17:08,000 --> 00:17:12,000
so we performed a similar experiment but

456
00:17:10,959 --> 00:17:15,120
here we measured

457
00:17:12,000 --> 00:17:17,359
the full packet protection so here we

458
00:17:15,119 --> 00:17:19,678
calculated the message authentication

459
00:17:17,359 --> 00:17:22,799
code over the whole packet

460
00:17:19,679 --> 00:17:25,360
and on the top four lines is

461
00:17:22,799 --> 00:17:25,918
read latency so this is a full round

462
00:17:25,359 --> 00:17:28,399
trip

463
00:17:25,919 --> 00:17:29,679
and for right latency it's half round

464
00:17:28,400 --> 00:17:32,000
trip

465
00:17:29,679 --> 00:17:34,000
since the packet authentication depends

466
00:17:32,000 --> 00:17:35,760
on the payload size we measured this for

467
00:17:34,000 --> 00:17:38,640
different payload sizes

468
00:17:35,760 --> 00:17:40,879
uh starting from 32 bytes up to two

469
00:17:38,640 --> 00:17:43,600
kilobytes

470
00:17:40,880 --> 00:17:44,240
and again we measured and the different

471
00:17:43,600 --> 00:17:47,678
uh

472
00:17:44,240 --> 00:17:50,320
with different features enabled in srdma

473
00:17:47,679 --> 00:17:51,919
and these numbers again for pd

474
00:17:50,320 --> 00:17:54,399
protection extended memory protection

475
00:17:51,919 --> 00:17:57,039
are the worst case scenario so the key

476
00:17:54,400 --> 00:17:58,160
is not cached and if it would there

477
00:17:57,039 --> 00:18:01,520
would be cash

478
00:17:58,160 --> 00:18:03,679
we expect that we would have muslim

479
00:18:01,520 --> 00:18:05,280
uh hits because you never send just one

480
00:18:03,679 --> 00:18:06,799
packet starting from the second packet

481
00:18:05,280 --> 00:18:08,160
the key will be

482
00:18:06,799 --> 00:18:10,000
in cash you would have the same

483
00:18:08,160 --> 00:18:14,720
performance as for

484
00:18:10,000 --> 00:18:17,200
uh basic uh right and reads

485
00:18:14,720 --> 00:18:18,640
so as we can see the like the best

486
00:18:17,200 --> 00:18:22,400
algorithm here

487
00:18:18,640 --> 00:18:25,120
was uh pulley 1305 so it had

488
00:18:22,400 --> 00:18:27,120
the lowest latency for full packet

489
00:18:25,120 --> 00:18:30,879
authentication

490
00:18:27,120 --> 00:18:34,320
and the ais was had a bit

491
00:18:30,880 --> 00:18:36,880
higher latency however when we performed

492
00:18:34,320 --> 00:18:38,559
the experiment with authentication

493
00:18:36,880 --> 00:18:41,360
encryption so in this case

494
00:18:38,559 --> 00:18:42,720
we authenticate the message and we also

495
00:18:41,360 --> 00:18:45,280
replaced the payload

496
00:18:42,720 --> 00:18:46,640
and turned out that eas had better

497
00:18:45,280 --> 00:18:50,080
performance

498
00:18:46,640 --> 00:18:51,200
and we will see the this difference even

499
00:18:50,080 --> 00:18:54,639
more when we

500
00:18:51,200 --> 00:18:56,080
run bandwidth experiments which was a

501
00:18:54,640 --> 00:18:58,960
bit surprising for us

502
00:18:56,080 --> 00:19:00,480
so here we can conclude that for full

503
00:18:58,960 --> 00:19:02,559
message authentication

504
00:19:00,480 --> 00:19:04,160
we think that the best algorithm would

505
00:19:02,559 --> 00:19:07,200
be poly1305

506
00:19:04,160 --> 00:19:08,960
and of course sha 256

507
00:19:07,200 --> 00:19:10,320
had also good performance because it was

508
00:19:08,960 --> 00:19:13,600
applied

509
00:19:10,320 --> 00:19:16,000
to the large

510
00:19:13,600 --> 00:19:16,000
message

511
00:19:17,919 --> 00:19:21,120
but for authenticated encryption we

512
00:19:20,080 --> 00:19:25,840
think that eas

513
00:19:21,120 --> 00:19:25,840
is as the best performance

514
00:19:26,720 --> 00:19:30,720
uh right now i'd like to talk about the

515
00:19:28,400 --> 00:19:31,440
right bandwidth so first of all i'd like

516
00:19:30,720 --> 00:19:34,720
to explain

517
00:19:31,440 --> 00:19:36,640
the this baseline we had so

518
00:19:34,720 --> 00:19:38,000
we took our infrastructure as you

519
00:19:36,640 --> 00:19:40,160
remember we had this free

520
00:19:38,000 --> 00:19:42,080
keeper connections between hospi and

521
00:19:40,160 --> 00:19:44,480
host b to send so we measured

522
00:19:42,080 --> 00:19:45,678
how much bandwidth we can achieve with

523
00:19:44,480 --> 00:19:48,960
this

524
00:19:45,679 --> 00:19:51,600
uh code base without using

525
00:19:48,960 --> 00:19:52,080
any authentication encryption we just

526
00:19:51,600 --> 00:19:54,559
actually

527
00:19:52,080 --> 00:19:56,720
just send the packets from host a plus b

528
00:19:54,559 --> 00:19:58,799
and we do not verify the packets

529
00:19:56,720 --> 00:20:00,160
and turned out if we use just one fret

530
00:19:58,799 --> 00:20:02,400
of our smart nic

531
00:20:00,160 --> 00:20:04,159
we could achieve only about eight

532
00:20:02,400 --> 00:20:07,039
gigabits per second

533
00:20:04,159 --> 00:20:07,520
and we couldn't achieve the full wine

534
00:20:07,039 --> 00:20:10,320
rate

535
00:20:07,520 --> 00:20:11,679
however when we used four frets we could

536
00:20:10,320 --> 00:20:14,320
achieve the full

537
00:20:11,679 --> 00:20:15,840
uh line rate so this black line is

538
00:20:14,320 --> 00:20:16,320
represents the bandwidth we could

539
00:20:15,840 --> 00:20:19,678
achieve

540
00:20:16,320 --> 00:20:21,678
without enabling any uh protection on

541
00:20:19,679 --> 00:20:23,840
the packets

542
00:20:21,679 --> 00:20:26,080
so the basic uh keys protection so the

543
00:20:23,840 --> 00:20:28,240
basic case is like when we have

544
00:20:26,080 --> 00:20:29,760
keys underneath and we can immediately

545
00:20:28,240 --> 00:20:31,520
protect the packets for header

546
00:20:29,760 --> 00:20:32,720
authentication we could achieve land

547
00:20:31,520 --> 00:20:37,440
rate using uh

548
00:20:32,720 --> 00:20:39,520
six frets for all protection codes

549
00:20:37,440 --> 00:20:41,919
for full packet authentication we could

550
00:20:39,520 --> 00:20:45,039
also do this

551
00:20:41,919 --> 00:20:48,480
for all cypher-based algorithms

552
00:20:45,039 --> 00:20:51,280
and only sha 512 could not

553
00:20:48,480 --> 00:20:52,559
achieve it and actually es128 had hard

554
00:20:51,280 --> 00:20:56,240
time achieving the

555
00:20:52,559 --> 00:20:57,440
lane rate for eight frets however when

556
00:20:56,240 --> 00:21:00,159
we switch to the

557
00:20:57,440 --> 00:21:00,880
objective authenticated encryption mode

558
00:21:00,159 --> 00:21:04,240
is

559
00:21:00,880 --> 00:21:07,120
uh beats poly1305 uh algorithm

560
00:21:04,240 --> 00:21:07,840
so which concludes our previous uh

561
00:21:07,120 --> 00:21:11,840
conclusion

562
00:21:07,840 --> 00:21:14,559
uh that as128 is better for

563
00:21:11,840 --> 00:21:17,840
uh authenticated encryption poly135 is

564
00:21:14,559 --> 00:21:17,840
better for packet authentication

565
00:21:18,240 --> 00:21:22,240
then we measured the bandwidth for the

566
00:21:21,200 --> 00:21:23,840
rights

567
00:21:22,240 --> 00:21:26,240
when we have enabled bt protection

568
00:21:23,840 --> 00:21:29,360
extended memory protection again here we

569
00:21:26,240 --> 00:21:31,360
try to express the case like really

570
00:21:29,360 --> 00:21:33,918
worst case scenarios we have

571
00:21:31,360 --> 00:21:35,520
really small cache or somehow each time

572
00:21:33,919 --> 00:21:39,360
we send the message

573
00:21:35,520 --> 00:21:41,360
the the key is not on the underneath and

574
00:21:39,360 --> 00:21:43,360
we need to derive it each time

575
00:21:41,360 --> 00:21:45,120
so we each time we send the message we

576
00:21:43,360 --> 00:21:46,719
have a miss on the sender and the

577
00:21:45,120 --> 00:21:48,959
receiver

578
00:21:46,720 --> 00:21:49,840
so this case we had decreased by 2

579
00:21:48,960 --> 00:21:52,240
gigabits

580
00:21:49,840 --> 00:21:53,918
per second for the all cases but we

581
00:21:52,240 --> 00:21:56,400
still were able to achieve the

582
00:21:53,919 --> 00:21:57,120
rate for header authentication and also

583
00:21:56,400 --> 00:21:59,600
for

584
00:21:57,120 --> 00:22:01,360
some algorithms for packet

585
00:21:59,600 --> 00:22:04,158
authentication

586
00:22:01,360 --> 00:22:05,918
and finally when we enable both and we

587
00:22:04,159 --> 00:22:08,720
had constant misses

588
00:22:05,919 --> 00:22:10,000
the performance got decreased by another

589
00:22:08,720 --> 00:22:11,679
two gigabit

590
00:22:10,000 --> 00:22:15,039
but for header authentication we could

591
00:22:11,679 --> 00:22:15,039
still achieve the line rate

592
00:22:15,200 --> 00:22:19,039
we performed similar experiment for the

593
00:22:17,039 --> 00:22:21,760
read bandwidth uh

594
00:22:19,039 --> 00:22:23,520
for read bandwidth uh our baseline was

595
00:22:21,760 --> 00:22:27,360
even lower

596
00:22:23,520 --> 00:22:28,639
so for no protection installed we could

597
00:22:27,360 --> 00:22:31,760
achieve only 5 gb

598
00:22:28,640 --> 00:22:32,880
per second so it's even slower for the

599
00:22:31,760 --> 00:22:34,720
right case

600
00:22:32,880 --> 00:22:36,240
the main reason for that that read

601
00:22:34,720 --> 00:22:39,280
requests are

602
00:22:36,240 --> 00:22:42,559
more complicated than

603
00:22:39,280 --> 00:22:44,080
than right so in case of read the device

604
00:22:42,559 --> 00:22:47,120
needs special capabilities

605
00:22:44,080 --> 00:22:48,000
and even in existing infiniband you need

606
00:22:47,120 --> 00:22:51,360
to install

607
00:22:48,000 --> 00:22:54,400
the contacts on the initiator and on the

608
00:22:51,360 --> 00:22:56,399
target uh so it's like special slots on

609
00:22:54,400 --> 00:22:58,159
the device where it stores the context

610
00:22:56,400 --> 00:23:01,200
for performing the operation

611
00:22:58,159 --> 00:23:03,440
and we have to actually emulate uh this

612
00:23:01,200 --> 00:23:07,120
in the software of our smartening

613
00:23:03,440 --> 00:23:09,039
so that's why at the maximum

614
00:23:07,120 --> 00:23:10,239
performance we could achieve was about

615
00:23:09,039 --> 00:23:12,000
16 gigabits

616
00:23:10,240 --> 00:23:14,559
and for one thread that was only five

617
00:23:12,000 --> 00:23:14,559
gigabit

618
00:23:14,799 --> 00:23:19,520
uh anyway so we measured the header

619
00:23:17,520 --> 00:23:22,960
authentication backup authentication

620
00:23:19,520 --> 00:23:26,158
and object encryption for this algorithm

621
00:23:22,960 --> 00:23:27,200
and for header authentication we could

622
00:23:26,159 --> 00:23:30,000
achieve land rate

623
00:23:27,200 --> 00:23:31,200
for all algorithms for packet

624
00:23:30,000 --> 00:23:33,679
authentication

625
00:23:31,200 --> 00:23:34,480
we couldn't do that but we had the

626
00:23:33,679 --> 00:23:36,559
algorithms

627
00:23:34,480 --> 00:23:37,840
which were really close achieving the

628
00:23:36,559 --> 00:23:41,200
line rate

629
00:23:37,840 --> 00:23:42,879
so uh again the best one uh here was

630
00:23:41,200 --> 00:23:44,799
pulley 1305

631
00:23:42,880 --> 00:23:46,159
and in the case of authenticated

632
00:23:44,799 --> 00:23:49,840
encryption the best one was

633
00:23:46,159 --> 00:23:51,600
again as128 one thing i forgot to

634
00:23:49,840 --> 00:23:54,879
mention so for read requests

635
00:23:51,600 --> 00:23:57,199
uh we have to perform protection

636
00:23:54,880 --> 00:23:58,880
uh the process of uh protecting

637
00:23:57,200 --> 00:24:01,039
validating backing four times so

638
00:23:58,880 --> 00:24:02,159
in the right keys we have the sender

639
00:24:01,039 --> 00:24:04,158
which

640
00:24:02,159 --> 00:24:06,080
protects the packet and the receiver who

641
00:24:04,159 --> 00:24:08,240
validates so reit

642
00:24:06,080 --> 00:24:10,080
request consists of the full round trip

643
00:24:08,240 --> 00:24:12,960
so we have a

644
00:24:10,080 --> 00:24:15,439
read request which which is protected

645
00:24:12,960 --> 00:24:17,840
then that's get validated by the

646
00:24:15,440 --> 00:24:18,720
destination then destination sends the

647
00:24:17,840 --> 00:24:20,879
results

648
00:24:18,720 --> 00:24:22,559
it protects it sends it to the to the

649
00:24:20,880 --> 00:24:25,600
initiator the initiator

650
00:24:22,559 --> 00:24:27,760
checks uh the validates the

651
00:24:25,600 --> 00:24:31,039
uh the packets it's received so that's

652
00:24:27,760 --> 00:24:33,600
why it's more complicated

653
00:24:31,039 --> 00:24:35,200
so again with right with enable pd

654
00:24:33,600 --> 00:24:35,678
protection extended memory protection

655
00:24:35,200 --> 00:24:37,840
that's

656
00:24:35,679 --> 00:24:40,480
uh the case when the keys are not cached

657
00:24:37,840 --> 00:24:43,520
so that's worst case scenario

658
00:24:40,480 --> 00:24:45,039
and we had similar results as uh for

659
00:24:43,520 --> 00:24:48,799
rights

660
00:24:45,039 --> 00:24:49,679
and uh also quite similar results when

661
00:24:48,799 --> 00:24:53,039
we had

662
00:24:49,679 --> 00:24:54,960
both enabled as we could see

663
00:24:53,039 --> 00:24:56,960
actually we could still even this

664
00:24:54,960 --> 00:24:58,880
enabled all this feature we could still

665
00:24:56,960 --> 00:25:02,240
achieve really high

666
00:24:58,880 --> 00:25:05,200
uh bandwidth using just general purpose

667
00:25:02,240 --> 00:25:06,080
cpu this is like not really powerful arm

668
00:25:05,200 --> 00:25:08,960
cpus

669
00:25:06,080 --> 00:25:10,000
and we expect better results if this

670
00:25:08,960 --> 00:25:14,480
algorithm would be

671
00:25:10,000 --> 00:25:16,559
implemented in the fpgas for example

672
00:25:14,480 --> 00:25:18,400
uh right now right now i'd like to

673
00:25:16,559 --> 00:25:21,678
invite you to read the full paper

674
00:25:18,400 --> 00:25:23,919
so the things i didn't uh explain that

675
00:25:21,679 --> 00:25:27,440
our srdma also supports

676
00:25:23,919 --> 00:25:29,520
uh memory sub delegation based on our

677
00:25:27,440 --> 00:25:31,840
on our extended crypto based memory

678
00:25:29,520 --> 00:25:34,240
protection which allows to

679
00:25:31,840 --> 00:25:36,559
give access to the memory of other

680
00:25:34,240 --> 00:25:39,440
parties in the network

681
00:25:36,559 --> 00:25:41,200
uh in addition we have more detail more

682
00:25:39,440 --> 00:25:43,360
details on the implementation of

683
00:25:41,200 --> 00:25:44,480
s argument and extra experiments for

684
00:25:43,360 --> 00:25:47,039
example we

685
00:25:44,480 --> 00:25:48,960
integrated srtm in the heart kiwi store

686
00:25:47,039 --> 00:25:52,000
and you could see the results of our

687
00:25:48,960 --> 00:25:54,320
experiments in the paper

688
00:25:52,000 --> 00:25:56,080
here i'd like to conclude my talk so i'd

689
00:25:54,320 --> 00:25:57,279
like to remind the desert game we use

690
00:25:56,080 --> 00:25:57,918
lightweight security extension to

691
00:25:57,279 --> 00:26:00,720
argument

692
00:25:57,919 --> 00:26:02,720
so it was designed to have as little as

693
00:26:00,720 --> 00:26:06,000
possible changes to the current protocol

694
00:26:02,720 --> 00:26:10,240
so and it has to be back

695
00:26:06,000 --> 00:26:11,840
compatible in addition we take into

696
00:26:10,240 --> 00:26:13,840
account the memory constraints of the

697
00:26:11,840 --> 00:26:15,678
network controllers and try to reduce it

698
00:26:13,840 --> 00:26:17,039
as much as possible and we think we

699
00:26:15,679 --> 00:26:19,200
achieved it

700
00:26:17,039 --> 00:26:21,039
uh in our implementation and our

701
00:26:19,200 --> 00:26:23,600
evaluations we were limited by

702
00:26:21,039 --> 00:26:25,360
the platform we were using for

703
00:26:23,600 --> 00:26:27,520
prototyping but we

704
00:26:25,360 --> 00:26:28,959
truly believe that srtma can be easily

705
00:26:27,520 --> 00:26:30,960
adapted to the hardware

706
00:26:28,960 --> 00:26:32,640
to achieve even higher bandwidths and

707
00:26:30,960 --> 00:26:35,600
lower latency communication

708
00:26:32,640 --> 00:26:37,360
so if you have any questions please

709
00:26:35,600 --> 00:26:38,719
contact me through the email you can see

710
00:26:37,360 --> 00:26:50,479
on the screen

711
00:26:38,720 --> 00:26:50,480
thank you

