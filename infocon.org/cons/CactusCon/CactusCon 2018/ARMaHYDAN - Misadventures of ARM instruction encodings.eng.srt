1
00:00:00,030 --> 00:00:06,319
okay I'm gonna get started this is about

2
00:00:04,560 --> 00:00:09,030
my adventures or misadventures with

3
00:00:06,319 --> 00:00:11,670
Armand coatings for the assembly

4
00:00:09,030 --> 00:00:15,509
instructions it's a little bit about the

5
00:00:11,670 --> 00:00:16,740
tact but more about the journey so if

6
00:00:15,509 --> 00:00:19,740
anybody knows we have been doing the

7
00:00:16,740 --> 00:00:21,330
ignorant stuff with x86 for a while and

8
00:00:19,740 --> 00:00:24,570
in the back of my mind I kind of want to

9
00:00:21,330 --> 00:00:25,948
experiment with arm but I didn't have a

10
00:00:24,570 --> 00:00:28,140
good starter it was harder for me to

11
00:00:25,949 --> 00:00:29,939
emulate and I didn't really have any arm

12
00:00:28,140 --> 00:00:31,230
devices to be able to really play with

13
00:00:29,939 --> 00:00:33,510
because I wanted to work with bare metal

14
00:00:31,230 --> 00:00:35,940
and then I realized for like years I've

15
00:00:33,510 --> 00:00:37,829
had a Raspberry Pi so that was kind of

16
00:00:35,940 --> 00:00:39,089
my starting to that I didn't know

17
00:00:37,829 --> 00:00:41,309
exactly where to start with learning

18
00:00:39,090 --> 00:00:44,730
assembly for arm because it seemed like

19
00:00:41,309 --> 00:00:46,739
there is less books out there for it but

20
00:00:44,730 --> 00:00:49,019
I've found on the raspberry raspberry pi

21
00:00:46,739 --> 00:00:52,589
forums they're all kind of pointing to

22
00:00:49,020 --> 00:00:55,350
this one resource it's a kind of a ebook

23
00:00:52,590 --> 00:00:58,379
or a website to had a book about

24
00:00:55,350 --> 00:01:00,120
programming for like assembly from arm

25
00:00:58,379 --> 00:01:02,099
and specifically on the Raspberry Pi so

26
00:01:00,120 --> 00:01:05,158
that's something perfect I started there

27
00:01:02,100 --> 00:01:07,110
but the annoying thing is the guy I

28
00:01:05,159 --> 00:01:09,450
thought most assembly books were bad and

29
00:01:07,110 --> 00:01:10,860
I don't want to super criticize people

30
00:01:09,450 --> 00:01:13,700
that much this guy knows what he's

31
00:01:10,860 --> 00:01:17,520
talking about but the approach of

32
00:01:13,700 --> 00:01:19,920
teaching assembly by writing a C and

33
00:01:17,520 --> 00:01:22,048
then compiling it and then disassembling

34
00:01:19,920 --> 00:01:23,820
it to try to illustrate assembly I think

35
00:01:22,049 --> 00:01:26,610
is the worst possible way to teach a

36
00:01:23,820 --> 00:01:28,258
newcomer assembly I know this is a nice

37
00:01:26,610 --> 00:01:29,640
chart I'm not really intending to zoom

38
00:01:28,259 --> 00:01:32,549
in I'm just saying then this is a

39
00:01:29,640 --> 00:01:34,890
screenshot of him writing a seed program

40
00:01:32,549 --> 00:01:36,659
to implement the static then compile it

41
00:01:34,890 --> 00:01:39,509
and then deep compile it it's just the

42
00:01:36,659 --> 00:01:41,340
most confusing way to try to teach so I

43
00:01:39,509 --> 00:01:43,409
kind of skimmed the book I really read

44
00:01:41,340 --> 00:01:45,270
it that detailed and I gave up on trying

45
00:01:43,409 --> 00:01:47,040
to read textbooks or any kind of books

46
00:01:45,270 --> 00:01:49,408
on our and I knew what the real source

47
00:01:47,040 --> 00:01:51,119
of information was going to be like I

48
00:01:49,409 --> 00:01:52,890
already read the entire like all three

49
00:01:51,119 --> 00:01:55,470
volumes of Intel manuals so I thought

50
00:01:52,890 --> 00:01:56,610
I'd find that our manual read that thing

51
00:01:55,470 --> 00:01:58,649
as well

52
00:01:56,610 --> 00:02:00,690
so I read that and at this point I'm not

53
00:01:58,649 --> 00:02:04,050
even at hello world I just read the

54
00:02:00,690 --> 00:02:06,420
manual first and I'm really getting

55
00:02:04,050 --> 00:02:08,160
hyper focused on the machine in coatings

56
00:02:06,420 --> 00:02:09,110
of the assembly instructions because

57
00:02:08,160 --> 00:02:12,060
that's what I do

58
00:02:09,110 --> 00:02:13,800
in fact by then I by the end of this

59
00:02:12,060 --> 00:02:16,320
talk when I even get to the main perfect

60
00:02:13,800 --> 00:02:17,940
concepts of everything I've done even in

61
00:02:16,320 --> 00:02:20,000
the end of my research at this point I

62
00:02:17,940 --> 00:02:23,790
still had not written below world

63
00:02:20,000 --> 00:02:26,670
because it's too high level so this is

64
00:02:23,790 --> 00:02:29,310
just an example of instruction and

65
00:02:26,670 --> 00:02:32,459
assembly instruction for move and in the

66
00:02:29,310 --> 00:02:36,210
bottom is kind of some ASCII text of how

67
00:02:32,460 --> 00:02:38,100
that's encoded in binary so every arm

68
00:02:36,210 --> 00:02:40,530
instruction being 32 bits for this

69
00:02:38,100 --> 00:02:42,030
32-bit architecture with exception of

70
00:02:40,530 --> 00:02:44,700
thumb instructions which I didn't focus

71
00:02:42,030 --> 00:02:46,080
on so you kind of see the fields broken

72
00:02:44,700 --> 00:02:48,000
out like they have four bits or a

73
00:02:46,080 --> 00:02:49,080
condition and you have someone sincere

74
00:02:48,000 --> 00:02:51,030
as that define that it's move

75
00:02:49,080 --> 00:02:53,820
instruction you have your register

76
00:02:51,030 --> 00:02:55,800
fields like art nrm and this kind of

77
00:02:53,820 --> 00:02:57,090
elasticity of ASCII text because I'll

78
00:02:55,800 --> 00:02:58,730
get a little bit graphic lad for this

79
00:02:57,090 --> 00:03:01,410
but this is how it's looking up them all

80
00:02:58,730 --> 00:03:03,420
and the thing that immediately I thought

81
00:03:01,410 --> 00:03:07,170
was interesting about this instruction

82
00:03:03,420 --> 00:03:08,970
and a lot of instructions related is you

83
00:03:07,170 --> 00:03:11,280
see ones and zeros but you also see some

84
00:03:08,970 --> 00:03:14,850
zeros with parentheses around them and

85
00:03:11,280 --> 00:03:16,230
the our manual is very just architecture

86
00:03:14,850 --> 00:03:18,989
in general was very organized

87
00:03:16,230 --> 00:03:21,179
categorical broken down really well

88
00:03:18,989 --> 00:03:23,459
explains what all those one since your

89
00:03:21,180 --> 00:03:26,970
own fields are supposed to be except for

90
00:03:23,459 --> 00:03:29,130
those ones in parentheses TLDR there

91
00:03:26,970 --> 00:03:30,989
don't hear bits but it doesn't go so far

92
00:03:29,130 --> 00:03:32,850
as to say there don't hear bits it's not

93
00:03:30,989 --> 00:03:34,170
like I discovered this myself it was

94
00:03:32,850 --> 00:03:36,780
pretty well known but those bits are

95
00:03:34,170 --> 00:03:39,869
already but I didn't know I wasn't in

96
00:03:36,780 --> 00:03:41,220
touch with our community so I focused on

97
00:03:39,870 --> 00:03:43,200
these don't carrots I wanted to see what

98
00:03:41,220 --> 00:03:46,550
they actually did

99
00:03:43,200 --> 00:03:49,980
but speaking of how I love the army

100
00:03:46,550 --> 00:03:54,650
architecture house broken down down the

101
00:03:49,980 --> 00:03:57,890
road I'm I made this atlas researching

102
00:03:54,650 --> 00:04:01,200
but to show you say there's a

103
00:03:57,890 --> 00:04:02,660
subcategory a split there is conditional

104
00:04:01,200 --> 00:04:05,570
instructions and

105
00:04:02,660 --> 00:04:08,000
instructions and an arm as opposed to

106
00:04:05,570 --> 00:04:10,150
x86 most instructions are all

107
00:04:08,000 --> 00:04:12,950
conditional and not just you know your

108
00:04:10,150 --> 00:04:14,510
jumps and those kind of things pretty

109
00:04:12,950 --> 00:04:17,750
much every instruction is conditional

110
00:04:14,510 --> 00:04:20,120
it's kind of cool but in the conditional

111
00:04:17,750 --> 00:04:22,160
instructions the subcategories of that

112
00:04:20,120 --> 00:04:25,700
are defined by like this two-bit aqua

113
00:04:22,160 --> 00:04:27,020
one field and another one if you follow

114
00:04:25,700 --> 00:04:28,760
this yellow line

115
00:04:27,020 --> 00:04:30,560
kind of over you can go to one of the

116
00:04:28,760 --> 00:04:32,300
subcategories which is a very common one

117
00:04:30,560 --> 00:04:34,370
which is the data processing and

118
00:04:32,300 --> 00:04:35,870
miscellaneous instructions and you can

119
00:04:34,370 --> 00:04:37,700
have a loo subcategories like data

120
00:04:35,870 --> 00:04:39,590
processing with the register data

121
00:04:37,700 --> 00:04:41,900
processing with immediate values and so

122
00:04:39,590 --> 00:04:44,090
on and those are all further defined by

123
00:04:41,900 --> 00:04:45,950
the on and on two fields you see in

124
00:04:44,090 --> 00:04:47,810
green at the top so if we start the

125
00:04:45,950 --> 00:04:50,120
follow of that billet line we'll look at

126
00:04:47,810 --> 00:04:52,040
the register ones over here you have

127
00:04:50,120 --> 00:04:53,300
done a processing register instructions

128
00:04:52,040 --> 00:04:55,970
and I'm going to kind of go down the

129
00:04:53,300 --> 00:04:57,710
line here a little bit and we see kind

130
00:04:55,970 --> 00:05:00,800
of towards the top there's our move

131
00:04:57,710 --> 00:05:02,320
instruction that I had for ASCII text so

132
00:05:00,800 --> 00:05:07,250
that's how I'm going to look at it now

133
00:05:02,320 --> 00:05:09,860
same information but conditions are blue

134
00:05:07,250 --> 00:05:11,720
registers - they're yellow all the

135
00:05:09,860 --> 00:05:17,750
machine stuff the specific instruction

136
00:05:11,720 --> 00:05:21,160
is red and just a further explained kind

137
00:05:17,750 --> 00:05:24,830
of break down into categories for

138
00:05:21,160 --> 00:05:26,090
conditional data instructions they are

139
00:05:24,830 --> 00:05:29,690
all going to start with this is 0 0

140
00:05:26,090 --> 00:05:32,539
machine code and if I were to follow

141
00:05:29,690 --> 00:05:34,370
that now the subcategory all the wastes

142
00:05:32,540 --> 00:05:37,760
of the zero zero and in it an additional

143
00:05:34,370 --> 00:05:40,280
0 so that's kind of how that breaks

144
00:05:37,760 --> 00:05:43,070
apart and then the extra four bits after

145
00:05:40,280 --> 00:05:50,030
that down to wanting to find what actual

146
00:05:43,070 --> 00:05:51,409
instruction sense so another thing again

147
00:05:50,030 --> 00:05:52,940
I'm not going to say minutes it's not

148
00:05:51,410 --> 00:05:56,290
really you don't just stuck in this code

149
00:05:52,940 --> 00:05:59,320
the point is that it's a small script

150
00:05:56,290 --> 00:06:02,330
again before trying to número world I

151
00:05:59,320 --> 00:06:05,169
kind of retrofitted a concept of it a

152
00:06:02,330 --> 00:06:08,139
little bit a while ago called

153
00:06:05,169 --> 00:06:13,639
ml which is just converting

154
00:06:08,139 --> 00:06:16,820
ask me hex in 2l Kampala can L run an

155
00:06:13,639 --> 00:06:18,500
executable program for x86 I had a tool

156
00:06:16,820 --> 00:06:21,080
like that interactively so when it makes

157
00:06:18,500 --> 00:06:22,520
like that for arm and this is the whole

158
00:06:21,080 --> 00:06:25,609
script is pretty simple I mean it's

159
00:06:22,520 --> 00:06:28,010
doing a lot of system calls to bash this

160
00:06:25,610 --> 00:06:30,350
is kind of a example execution of that

161
00:06:28,010 --> 00:06:32,210
simple script is at the top they see me

162
00:06:30,350 --> 00:06:34,250
typing some binary out by hand in the

163
00:06:32,210 --> 00:06:36,200
nightma hit enter and then it tells me

164
00:06:34,250 --> 00:06:39,530
that this instruction is move are one or

165
00:06:36,200 --> 00:06:41,810
two and then below that I type some

166
00:06:39,530 --> 00:06:43,429
binary for what is the same instruction

167
00:06:41,810 --> 00:06:46,520
I just made all those don't care bits

168
00:06:43,430 --> 00:06:48,080
ones and then I noticed that no longer

169
00:06:46,520 --> 00:06:49,969
if it's disassembled is improve

170
00:06:48,080 --> 00:06:52,550
instruction against disassembled is

171
00:06:49,970 --> 00:06:54,680
undefined that doesn't necessarily mean

172
00:06:52,550 --> 00:06:55,910
it's not a move instruction it's just

173
00:06:54,680 --> 00:06:58,490
that this assembler doesn't know what to

174
00:06:55,910 --> 00:06:59,330
do with it but I don't just take it it's

175
00:06:58,490 --> 00:07:02,090
working for it I want to see what

176
00:06:59,330 --> 00:07:03,349
actually happens so my first test is I

177
00:07:02,090 --> 00:07:06,739
start to write an actual assembly

178
00:07:03,350 --> 00:07:08,419
program I start by putting 0 and the

179
00:07:06,740 --> 00:07:10,310
artist or register as a point of

180
00:07:08,419 --> 00:07:12,469
reference just to know that it's

181
00:07:10,310 --> 00:07:15,020
supposed to be 0 at this point and then

182
00:07:12,470 --> 00:07:16,460
I machine code another move instruction

183
00:07:15,020 --> 00:07:19,760
except for the only difference with this

184
00:07:16,460 --> 00:07:22,880
is I'm moving the PC register into r0

185
00:07:19,760 --> 00:07:25,520
and then flipping all that don't care if

186
00:07:22,880 --> 00:07:27,979
it's to want to see if the instruction

187
00:07:25,520 --> 00:07:29,299
actually does something or errors out

188
00:07:27,979 --> 00:07:31,400
I mean it looks undefined but this is

189
00:07:29,300 --> 00:07:36,289
still work that's my first question so

190
00:07:31,400 --> 00:07:40,219
in my TB debugger if we look in here we

191
00:07:36,289 --> 00:07:41,599
see the move R 0 0 immediate instruction

192
00:07:40,220 --> 00:07:43,700
here and then we see an undefined

193
00:07:41,600 --> 00:07:46,850
instruction below it and then it not

194
00:07:43,700 --> 00:07:48,560
from that and in this view not this

195
00:07:46,850 --> 00:07:50,930
showing up as read because it's the next

196
00:07:48,560 --> 00:07:52,520
instruction to be executed meaning at

197
00:07:50,930 --> 00:07:56,000
this point in this stage I've already

198
00:07:52,520 --> 00:07:57,650
executed are undefined instruction so if

199
00:07:56,000 --> 00:07:59,240
it didn't do anything that I mean if it

200
00:07:57,650 --> 00:08:00,979
failed we would have already failed on

201
00:07:59,240 --> 00:08:03,919
its program if it didn't do anything

202
00:08:00,979 --> 00:08:07,219
that ever zero should still be 0 but if

203
00:08:03,919 --> 00:08:09,590
it did do something than our r0 register

204
00:08:07,220 --> 00:08:14,539
should have the PC value which in this

205
00:08:09,590 --> 00:08:17,940
case should be 1 0 0 6 0 so we look up

206
00:08:14,539 --> 00:08:20,490
there our minister

207
00:08:17,940 --> 00:08:22,500
one zero zero six zero so it still works

208
00:08:20,490 --> 00:08:23,760
we can screw those don't hear bits it

209
00:08:22,500 --> 00:08:25,950
doesn't matter what we make them the

210
00:08:23,760 --> 00:08:29,430
instructions still work except for when

211
00:08:25,950 --> 00:08:29,969
you disassemble them they just kind of

212
00:08:29,430 --> 00:08:32,400
cool

213
00:08:29,970 --> 00:08:34,410
so in conclusion with that those bits

214
00:08:32,400 --> 00:08:36,478
couldn't be any damn thing and in this

215
00:08:34,409 --> 00:08:38,728
case but whatever you want in there or

216
00:08:36,479 --> 00:08:40,470
more familiar kinds of things to some of

217
00:08:38,729 --> 00:08:45,710
the people here is you know whatever you

218
00:08:40,470 --> 00:08:48,180
use to put anything in there so

219
00:08:45,710 --> 00:08:50,430
implications if I were to run with this

220
00:08:48,180 --> 00:08:52,199
concept and we're saving a little bit

221
00:08:50,430 --> 00:08:54,449
because we need a statically disassemble

222
00:08:52,200 --> 00:08:55,890
you know maybe all the instructions look

223
00:08:54,450 --> 00:08:57,780
undefined which is confusing

224
00:08:55,890 --> 00:09:00,270
steganography because you can pack

225
00:08:57,780 --> 00:09:01,949
anything in there you know you can pack

226
00:09:00,270 --> 00:09:03,720
information in there as well

227
00:09:01,950 --> 00:09:06,540
now we're signature busting I mean if

228
00:09:03,720 --> 00:09:08,730
it's just hash based it's a quick and

229
00:09:06,540 --> 00:09:10,530
dirty way to change the hashes and maybe

230
00:09:08,730 --> 00:09:22,020
a better exploit development because you

231
00:09:10,530 --> 00:09:24,209
can remove nulls and that's it so the

232
00:09:22,020 --> 00:09:26,880
point about that is that whole process

233
00:09:24,210 --> 00:09:29,790
from noticing that instruction that move

234
00:09:26,880 --> 00:09:31,439
instruction it was probably after that

235
00:09:29,790 --> 00:09:34,589
maybe only 10 to 15 minutes of

236
00:09:31,440 --> 00:09:36,240
experimentation like this like 15

237
00:09:34,590 --> 00:09:39,150
minutes and here I had these these

238
00:09:36,240 --> 00:09:42,210
theories and I see sometimes in our

239
00:09:39,150 --> 00:09:44,520
community it stops there like you see a

240
00:09:42,210 --> 00:09:47,130
cool theory somebody tries to explain it

241
00:09:44,520 --> 00:09:48,630
in a way that Jeremy I mean that like

242
00:09:47,130 --> 00:09:51,300
they've already done that's the percent

243
00:09:48,630 --> 00:09:52,920
of it like they're so cool the problem

244
00:09:51,300 --> 00:09:55,140
is sometimes it doesn't always work out

245
00:09:52,920 --> 00:09:56,370
that way you know you know in theory in

246
00:09:55,140 --> 00:09:59,160
theory in practice are the same but in

247
00:09:56,370 --> 00:10:01,500
practice they're not and sometimes we

248
00:09:59,160 --> 00:10:05,160
get lucky but really without proving it

249
00:10:01,500 --> 00:10:06,810
I just think it's just lazy because I

250
00:10:05,160 --> 00:10:08,730
mean this is happening we have computers

251
00:10:06,810 --> 00:10:11,219
we can test things to just stop that

252
00:10:08,730 --> 00:10:14,730
theory it doesn't make any sense to me I

253
00:10:11,220 --> 00:10:17,220
mean my religion is proof of concept I

254
00:10:14,730 --> 00:10:19,650
get the out the perfect concepts

255
00:10:17,220 --> 00:10:23,570
have really high currency if you don't

256
00:10:19,650 --> 00:10:25,130
have it you don't know so that's kind of

257
00:10:23,570 --> 00:10:27,560
point with that like I made a lot of

258
00:10:25,130 --> 00:10:29,570
bold claims here but I don't know

259
00:10:27,560 --> 00:10:34,250
necessarily if these things are possible

260
00:10:29,570 --> 00:10:38,420
and really even how trivial it is to

261
00:10:34,250 --> 00:10:40,550
implement them so while this this talk

262
00:10:38,420 --> 00:10:43,760
has technical parts to it it's kind of

263
00:10:40,550 --> 00:10:47,979
just a sermon delivery content you know

264
00:10:43,760 --> 00:10:51,550
a little little preachy in that way and

265
00:10:47,980 --> 00:10:54,860
and it's it's more just about process

266
00:10:51,550 --> 00:10:56,449
just the profit process that coming up

267
00:10:54,860 --> 00:10:58,340
with a proof of concept even if it's

268
00:10:56,450 --> 00:11:01,430
something as stupid as manipulating

269
00:10:58,340 --> 00:11:05,840
don't care this the process is hard and

270
00:11:01,430 --> 00:11:08,540
it's worthwhile so the first thing I try

271
00:11:05,840 --> 00:11:10,940
to experiment with was the question can

272
00:11:08,540 --> 00:11:13,069
i define all the instructions that was

273
00:11:10,940 --> 00:11:15,050
kind of the first claim I made you know

274
00:11:13,070 --> 00:11:26,600
in this screenshot can they all look

275
00:11:15,050 --> 00:11:32,030
undefined like that so you can't do with

276
00:11:26,600 --> 00:11:33,500
all of them scroll through every single

277
00:11:32,030 --> 00:11:37,160
instruction and kind of catalog which

278
00:11:33,500 --> 00:11:47,810
ones I don't care which one day so then

279
00:11:37,160 --> 00:11:50,209
my first proof of concept at this point

280
00:11:47,810 --> 00:11:52,280
playing around so I wrote a script that

281
00:11:50,210 --> 00:11:54,680
would go through on iterate through in

282
00:11:52,280 --> 00:11:58,850
every single instruction identify which

283
00:11:54,680 --> 00:12:00,439
one it is and then for them say like a I

284
00:11:58,850 --> 00:12:02,120
don't care a big field of like four

285
00:12:00,440 --> 00:12:04,370
zeros it would just put that last arrow

286
00:12:02,120 --> 00:12:06,020
until one making it undefined and to do

287
00:12:04,370 --> 00:12:08,870
that for every single instruction in a

288
00:12:06,020 --> 00:12:19,939
binary so I tested it out on these are

289
00:12:08,870 --> 00:12:21,740
games were my favorite instructions when

290
00:12:19,940 --> 00:12:23,420
I disassembled it I had some undefined

291
00:12:21,740 --> 00:12:24,920
amounts in there is kind of consistent

292
00:12:23,420 --> 00:12:27,530
with the amount that I expected to be

293
00:12:24,920 --> 00:12:29,329
undefined and it still works though it's

294
00:12:27,530 --> 00:12:32,089
kind of cool that first test was pretty

295
00:12:29,330 --> 00:12:33,240
successful in the theory that if you can

296
00:12:32,090 --> 00:12:36,240
change anything you want

297
00:12:33,240 --> 00:12:39,720
works and now I'm going on some detours

298
00:12:36,240 --> 00:12:42,899
here that I had more questions like that

299
00:12:39,720 --> 00:12:44,430
is a theory of anecdotally but really if

300
00:12:42,899 --> 00:12:45,839
I flip any of those don't care bits

301
00:12:44,430 --> 00:12:49,050
couldn't convert into a different

302
00:12:45,839 --> 00:12:50,490
instruction and really didn't know it

303
00:12:49,050 --> 00:12:54,319
became more clear to me when I made the

304
00:12:50,490 --> 00:12:57,600
arm machinist athletes which as an aside

305
00:12:54,320 --> 00:13:00,779
this this is talking about I broke down

306
00:12:57,600 --> 00:13:03,930
every single instruction in its binary

307
00:13:00,779 --> 00:13:07,709
form so it became visually easier to see

308
00:13:03,930 --> 00:13:09,300
things so now I'm and the first test I

309
00:13:07,709 --> 00:13:11,069
did was a just like we mapped out every

310
00:13:09,300 --> 00:13:12,569
single instruction binary did some fancy

311
00:13:11,070 --> 00:13:17,459
rednecks just to see that stuff didn't

312
00:13:12,570 --> 00:13:19,290
overlap so as a kind of another detour

313
00:13:17,459 --> 00:13:21,619
why are they don't care if it's you know

314
00:13:19,290 --> 00:13:24,839
because you don't really have that x86

315
00:13:21,620 --> 00:13:28,560
part of it is because arm isn't very

316
00:13:24,839 --> 00:13:30,180
fixed my instruction set so you're gonna

317
00:13:28,560 --> 00:13:32,489
have some bits and some instructions

318
00:13:30,180 --> 00:13:33,870
that might not matter and I think these

319
00:13:32,490 --> 00:13:35,040
two instructions go straight up really

320
00:13:33,870 --> 00:13:38,100
well although they're not all like this

321
00:13:35,040 --> 00:13:41,370
but this is consistent to conceptually

322
00:13:38,100 --> 00:13:44,279
with x86 when you come here subtract and

323
00:13:41,370 --> 00:13:46,680
compare instructions subtractive you do

324
00:13:44,279 --> 00:13:48,300
a subtraction but it also has a side

325
00:13:46,680 --> 00:13:51,180
effect of setting some flags like

326
00:13:48,300 --> 00:13:53,430
overflowing and Karie and all that in

327
00:13:51,180 --> 00:13:56,069
this case you're subtracting RM from RN

328
00:13:53,430 --> 00:13:57,810
and historical result and RD the result

329
00:13:56,070 --> 00:13:59,910
of a subtraction is in the Rd register

330
00:13:57,810 --> 00:14:02,399
what compare is like subtract that just

331
00:13:59,910 --> 00:14:04,020
isn't supposed to store the result all

332
00:14:02,399 --> 00:14:06,060
it does is set the flags for the side

333
00:14:04,020 --> 00:14:09,480
effects so that you can feed into logic

334
00:14:06,060 --> 00:14:12,930
for doing additional instructions if you

335
00:14:09,480 --> 00:14:18,870
notice the machine code is is very very

336
00:14:12,930 --> 00:14:20,790
similar if not identical except for like

337
00:14:18,870 --> 00:14:23,520
you know this this born bit field is 0 0

338
00:14:20,790 --> 00:14:26,219
1 0 and this one is 1 0 1 0 sin

339
00:14:23,520 --> 00:14:28,560
difference and then you'll notice that

340
00:14:26,220 --> 00:14:30,870
that the s flag is the thing is supposed

341
00:14:28,560 --> 00:14:32,430
to define if you're trying to set the

342
00:14:30,870 --> 00:14:34,470
flags are not because norm you can

343
00:14:32,430 --> 00:14:36,899
choose whether the flags are not and

344
00:14:34,470 --> 00:14:39,180
subtract that's optional but in compare

345
00:14:36,899 --> 00:14:40,950
it's not optional to hard-code into one

346
00:14:39,180 --> 00:14:42,900
so that's what it's doing it's

347
00:14:40,950 --> 00:14:45,720
definitely always going to be setting

348
00:14:42,900 --> 00:14:47,610
the flags and then we have

349
00:14:45,720 --> 00:14:49,740
this which is for the destination

350
00:14:47,610 --> 00:14:51,269
register because we're not storing it so

351
00:14:49,740 --> 00:14:54,029
that's kind of how that looked it's it

352
00:14:51,269 --> 00:14:55,589
looked similar but being that we don't

353
00:14:54,029 --> 00:14:58,170
hear about the destination or the output

354
00:14:55,589 --> 00:15:00,480
you can put any one or a zero in that

355
00:14:58,170 --> 00:15:03,209
field and it won't change what happens

356
00:15:00,480 --> 00:15:05,040
to the comparator what you can do that

357
00:15:03,209 --> 00:15:08,339
changes what happens to the compare

358
00:15:05,040 --> 00:15:11,129
instruction is if you change the

359
00:15:08,339 --> 00:15:12,779
hard-coding of that one to a zero which

360
00:15:11,129 --> 00:15:14,839
there's no assembly for that it's too

361
00:15:12,779 --> 00:15:17,550
high level if you do it in machine code

362
00:15:14,839 --> 00:15:18,959
this is kind of what it looks like this

363
00:15:17,550 --> 00:15:21,779
is the compare instruction but I have a

364
00:15:18,959 --> 00:15:25,079
zero there instead and if I compare it

365
00:15:21,779 --> 00:15:27,180
and disassembly and disassembles it's

366
00:15:25,079 --> 00:15:28,769
the same thing but the machine code is

367
00:15:27,180 --> 00:15:31,769
slightly different we have a five minute

368
00:15:28,769 --> 00:15:34,560
four here instead and this is me just

369
00:15:31,769 --> 00:15:36,509
assembling it out and you know

370
00:15:34,560 --> 00:15:38,128
assembling linking running and it

371
00:15:36,509 --> 00:15:39,839
actually is an illegal instruction it

372
00:15:38,129 --> 00:15:42,269
doesn't work because it one makes sense

373
00:15:39,839 --> 00:15:43,319
to run it and a compare setting doing

374
00:15:42,269 --> 00:15:47,040
the thing that is supposed to do

375
00:15:43,319 --> 00:15:51,389
anything getting done so quick little

376
00:15:47,040 --> 00:15:54,500
mid presentation demo here what I'm

377
00:15:51,389 --> 00:16:01,410
going to do is do this armwrestling so

378
00:15:54,500 --> 00:16:03,899
playing this I'm gonna do obj don't to

379
00:16:01,410 --> 00:16:06,779
disassemble and what I'm disassembling

380
00:16:03,899 --> 00:16:12,509
is what we did itself I'm just looking

381
00:16:06,779 --> 00:16:17,459
at the assembly for me so section the

382
00:16:12,509 --> 00:16:20,129
first 30 lines of that and there's no

383
00:16:17,459 --> 00:16:22,079
defined instructions this is what it's

384
00:16:20,129 --> 00:16:25,199
supposed to look like so the next thing

385
00:16:22,079 --> 00:16:29,660
I do is I run my tool arm behind I'm

386
00:16:25,199 --> 00:16:29,660
gonna undefined those bits

387
00:16:32,819 --> 00:16:38,849
objdump WTF you know like that all the

388
00:16:36,029 --> 00:16:43,019
instructions so it's going to crunch

389
00:16:38,850 --> 00:16:52,319
through that and when it finishes I'm

390
00:16:43,019 --> 00:16:55,439
gonna have to then make WTF and now I'm

391
00:16:52,319 --> 00:16:57,420
going to run this messed up objdump that

392
00:16:55,439 --> 00:16:58,270
has undefined instructions and I'm going

393
00:16:57,420 --> 00:17:00,660
to do

394
00:16:58,270 --> 00:17:02,589
and I'm gonna run it against itself and

395
00:17:00,660 --> 00:17:05,678
then looking for the first few

396
00:17:02,589 --> 00:17:07,300
instructions of disassembly so I had

397
00:17:05,679 --> 00:17:09,370
this modified version this fucked-up

398
00:17:07,300 --> 00:17:11,709
version of objdump the hassle is not to

399
00:17:09,369 --> 00:17:13,958
find instructions now that still works

400
00:17:11,709 --> 00:17:16,780
and it's running on itself its

401
00:17:13,959 --> 00:17:19,480
disassembling itself and it looks messed

402
00:17:16,780 --> 00:17:21,160
up I just like how amendment that is but

403
00:17:19,480 --> 00:17:23,949
so there's a perfect a perfect concept

404
00:17:21,160 --> 00:17:24,939
or how usually you can define all these

405
00:17:23,949 --> 00:17:30,700
bits and it doesn't change the

406
00:17:24,939 --> 00:17:33,400
functionality instructions so now as a

407
00:17:30,700 --> 00:17:36,340
tangent something that's not as fun as

408
00:17:33,400 --> 00:17:37,900
the research I've been doing so far but

409
00:17:36,340 --> 00:17:41,260
it's still kind of necessary if I want

410
00:17:37,900 --> 00:17:42,340
to progress forward I know I mentioned

411
00:17:41,260 --> 00:17:44,140
that I had a script that kind of

412
00:17:42,340 --> 00:17:46,720
profiles through all instructions and

413
00:17:44,140 --> 00:17:48,429
changes them as they go and I'm smart

414
00:17:46,720 --> 00:17:50,170
enough to short-circuited if you find

415
00:17:48,429 --> 00:17:52,179
that it's such-and-such construction it

416
00:17:50,170 --> 00:17:53,559
modifies it then moves on to the next

417
00:17:52,179 --> 00:17:54,940
instruction it doesn't try to interpret

418
00:17:53,559 --> 00:17:56,678
it was that this instruction isn't this

419
00:17:54,940 --> 00:17:58,210
instruction and so on

420
00:17:56,679 --> 00:17:59,920
but at this point I had to all the

421
00:17:58,210 --> 00:18:01,300
instructions in alphabetical order and

422
00:17:59,920 --> 00:18:03,700
performance wise that's terrible I

423
00:18:01,300 --> 00:18:05,050
really should be doing in those

424
00:18:03,700 --> 00:18:07,570
instructions that are the most common

425
00:18:05,050 --> 00:18:09,940
first for the short-circuiting that

426
00:18:07,570 --> 00:18:12,399
profoundly affects in performance by an

427
00:18:09,940 --> 00:18:14,350
order of magnitude however I don't know

428
00:18:12,400 --> 00:18:16,360
what the most common instructions are

429
00:18:14,350 --> 00:18:18,189
and I don't know any easy list out there

430
00:18:16,360 --> 00:18:20,949
that tells that for me so I had to

431
00:18:18,190 --> 00:18:22,450
figure that out for myself and in this

432
00:18:20,950 --> 00:18:24,340
case I've seen screenshots me this is

433
00:18:22,450 --> 00:18:25,720
just me doing alphabetical this is kind

434
00:18:24,340 --> 00:18:28,899
of an order of instructions as they're

435
00:18:25,720 --> 00:18:31,630
most common which this is legitimate so

436
00:18:28,900 --> 00:18:34,090
what I end up having to do is I write a

437
00:18:31,630 --> 00:18:37,000
script to profile an entire resume an

438
00:18:34,090 --> 00:18:42,129
operating system I go through every

439
00:18:37,000 --> 00:18:43,780
single instruction and I count and being

440
00:18:42,130 --> 00:18:46,390
then at this point I was using my

441
00:18:43,780 --> 00:18:50,830
original Raspberry Pi one be it took

442
00:18:46,390 --> 00:18:53,530
about like days if not like a week but I

443
00:18:50,830 --> 00:18:56,230
finally get my my data and implemented

444
00:18:53,530 --> 00:18:57,990
this script and it's a lot faster but

445
00:18:56,230 --> 00:19:00,730
now to be a little bit even more meta

446
00:18:57,990 --> 00:19:01,960
what about including even

447
00:19:00,730 --> 00:19:03,880
kind of modify instructions that have

448
00:19:01,960 --> 00:19:07,030
don't care bids would it make sense to

449
00:19:03,880 --> 00:19:08,740
add back instructions that don't have no

450
00:19:07,030 --> 00:19:10,990
clear bits even though I'm not modifying

451
00:19:08,740 --> 00:19:12,730
them it will help performance wise for

452
00:19:10,990 --> 00:19:13,870
the short-circuiting because if it's an

453
00:19:12,730 --> 00:19:15,130
instruction that happens the most

454
00:19:13,870 --> 00:19:16,780
frequently whether I'm doing anything

455
00:19:15,130 --> 00:19:18,280
with it or not at least I don't have to

456
00:19:16,780 --> 00:19:19,240
check it against all the instructions I

457
00:19:18,280 --> 00:19:21,090
can just be done with it

458
00:19:19,240 --> 00:19:22,929
but then again if I start adding

459
00:19:21,090 --> 00:19:24,639
instructions that don't have don't care

460
00:19:22,929 --> 00:19:26,590
dates that don't have infrequently that

461
00:19:24,640 --> 00:19:28,210
can hurt performance so I have to do

462
00:19:26,590 --> 00:19:30,070
even more benchmarking to see what that

463
00:19:28,210 --> 00:19:32,350
sweet spot is and this actually took

464
00:19:30,070 --> 00:19:35,740
even longer to figure out than the first

465
00:19:32,350 --> 00:19:38,439
benchmarking point is super super

466
00:19:35,740 --> 00:19:42,250
time-consuming not interesting but still

467
00:19:38,440 --> 00:19:45,820
needs to be done so I had another side

468
00:19:42,250 --> 00:19:47,230
question as a curious person had a lot

469
00:19:45,820 --> 00:19:48,580
of questions and this is this question I

470
00:19:47,230 --> 00:19:50,020
wish I would have got to later even

471
00:19:48,580 --> 00:19:52,540
though it was a necessary question but

472
00:19:50,020 --> 00:19:54,340
at this point it just confused me and I

473
00:19:52,540 --> 00:19:56,500
got back to it later but my question was

474
00:19:54,340 --> 00:20:00,909
in the wild are there actually

475
00:19:56,500 --> 00:20:02,740
instructions in real programs that's not

476
00:20:00,910 --> 00:20:04,330
standard no it's a real question to have

477
00:20:02,740 --> 00:20:07,179
but I really don't want to know

478
00:20:04,330 --> 00:20:09,610
so when I do it I find something out

479
00:20:07,179 --> 00:20:13,929
that surprised me on average all

480
00:20:09,610 --> 00:20:16,120
instructions have 0 to 13 percent rate

481
00:20:13,929 --> 00:20:18,730
of having instructions that have the

482
00:20:16,120 --> 00:20:21,070
don't care it's said not suspect the

483
00:20:18,730 --> 00:20:23,020
manual which is really weird like if

484
00:20:21,070 --> 00:20:24,309
you're thinking about it what what

485
00:20:23,020 --> 00:20:26,710
compiler is actually going to do

486
00:20:24,309 --> 00:20:27,730
assembler or come on what what if some

487
00:20:26,710 --> 00:20:29,440
other is actually going to do that

488
00:20:27,730 --> 00:20:31,000
legitimately and why like this doesn't

489
00:20:29,440 --> 00:20:33,549
make sense why is this occurring and

490
00:20:31,000 --> 00:20:35,169
there is an answer for it but I'll get

491
00:20:33,549 --> 00:20:39,610
to that later but in the back of my head

492
00:20:35,169 --> 00:20:41,200
this is disturbing me a little bit other

493
00:20:39,610 --> 00:20:42,639
assumptions because this is an

494
00:20:41,200 --> 00:20:43,780
assumption we make assumptions when we

495
00:20:42,640 --> 00:20:46,000
have all we have is theory without

496
00:20:43,780 --> 00:20:48,570
testing it is these are a hundred and

497
00:20:46,000 --> 00:20:50,650
forty instructions with don't care bits

498
00:20:48,570 --> 00:20:51,639
can I assume that if I change them

499
00:20:50,650 --> 00:20:53,890
they're all going to show up it's

500
00:20:51,640 --> 00:20:55,419
undefined and really quickly the answer

501
00:20:53,890 --> 00:20:57,490
is no because as I was comparing that

502
00:20:55,419 --> 00:20:59,559
subtract and compare instruction the

503
00:20:57,490 --> 00:21:02,380
disassembly the instructions both showed

504
00:20:59,559 --> 00:21:04,510
up as compare you know it did any show

505
00:21:02,380 --> 00:21:06,880
this undefined so now I have to

506
00:21:04,510 --> 00:21:09,940
catalogue that also time consuming got

507
00:21:06,880 --> 00:21:12,429
to figure out when which instructions I

508
00:21:09,940 --> 00:21:14,019
exploit this way and it wasn't as simple

509
00:21:12,429 --> 00:21:17,679
like some instructions like this first

510
00:21:14,019 --> 00:21:19,809
LD are a car ext instruction I had to

511
00:21:17,679 --> 00:21:20,889
flip all the ones to zero as if I just

512
00:21:19,809 --> 00:21:22,480
flipped a couple of bits they would

513
00:21:20,889 --> 00:21:25,209
still show up as the correct instruction

514
00:21:22,480 --> 00:21:28,059
so I had to flip all those bits some

515
00:21:25,210 --> 00:21:29,710
some instructions would like not to find

516
00:21:28,059 --> 00:21:32,408
it on like the compare or to see MN

517
00:21:29,710 --> 00:21:33,879
instruction no matter what one or what

518
00:21:32,409 --> 00:21:36,429
no matter no matter what series to

519
00:21:33,879 --> 00:21:39,309
change the ones even all of them or some

520
00:21:36,429 --> 00:21:40,779
of them it would never undefined you

521
00:21:39,309 --> 00:21:43,178
know pointing that phrase it wouldn't

522
00:21:40,779 --> 00:21:44,350
different undefined the instruction so

523
00:21:43,179 --> 00:21:46,840
now I have that in the back of my head

524
00:21:44,350 --> 00:21:49,658
which was really demoralizing when I get

525
00:21:46,840 --> 00:21:52,178
to an instruction like Mrs because

526
00:21:49,659 --> 00:21:55,230
there's numerous don't care bits I think

527
00:21:52,179 --> 00:21:58,059
there's about eleven don't care bits so

528
00:21:55,230 --> 00:21:59,860
and really just arbitrarily change even

529
00:21:58,059 --> 00:22:02,379
zero one or one who is zero didn't

530
00:21:59,860 --> 00:22:04,990
define it so now I have to exhaustively

531
00:22:02,379 --> 00:22:06,519
go through every single iteration which

532
00:22:04,990 --> 00:22:09,279
I think before eleven bits is probably

533
00:22:06,519 --> 00:22:11,350
about 2000 different experimentations to

534
00:22:09,279 --> 00:22:13,179
then arrived at the conclusion that no I

535
00:22:11,350 --> 00:22:14,889
can't mine define it and I have a

536
00:22:13,179 --> 00:22:17,889
hundred and forty instructions to check

537
00:22:14,889 --> 00:22:18,490
like this also time-consuming but I'm

538
00:22:17,889 --> 00:22:22,000
thorough

539
00:22:18,490 --> 00:22:23,980
I don't like to stop at just theory and

540
00:22:22,000 --> 00:22:27,190
you know I'm talking mostly about low BJ

541
00:22:23,980 --> 00:22:30,070
dummy maybe radar this where is

542
00:22:27,190 --> 00:22:33,100
disassembling but you know obviously the

543
00:22:30,070 --> 00:22:34,840
disassembler you're using matters too so

544
00:22:33,100 --> 00:22:36,189
we've been seeing those context but you

545
00:22:34,840 --> 00:22:39,189
know what about Ida Pro is that

546
00:22:36,190 --> 00:22:42,820
different and you know I was working

547
00:22:39,190 --> 00:22:44,320
with my my friend average Joe he was you

548
00:22:42,820 --> 00:22:45,570
know the full version of might approach

549
00:22:44,320 --> 00:22:47,320
I sent some samples

550
00:22:45,570 --> 00:22:54,189
checked out what that would look like a

551
00:22:47,320 --> 00:22:55,720
matter Pro on the fascinating but in

552
00:22:54,190 --> 00:23:01,720
practice it works a little bit

553
00:22:55,720 --> 00:23:06,100
differently generally it is disassembled

554
00:23:01,720 --> 00:23:08,259
more instructions it recognizes more the

555
00:23:06,100 --> 00:23:10,990
downside the first instruction it

556
00:23:08,259 --> 00:23:14,080
doesn't understand everything after its

557
00:23:10,990 --> 00:23:16,629
data even valid instructions so I

558
00:23:14,080 --> 00:23:19,769
consider that to be a bit worse with

559
00:23:16,629 --> 00:23:22,350
this assembly so that's going to go into

560
00:23:19,769 --> 00:23:23,850
snow move on to the other claims not

561
00:23:22,350 --> 00:23:25,500
you know making stuff undefined that's

562
00:23:23,850 --> 00:23:28,289
my thing that's kind of the most

563
00:23:25,500 --> 00:23:30,390
interesting thing but we'll get to the

564
00:23:28,289 --> 00:23:32,549
other things like randomizing those bits

565
00:23:30,390 --> 00:23:34,140
which in this case the purpose of it is

566
00:23:32,549 --> 00:23:36,090
to change the hashman so you have the

567
00:23:34,140 --> 00:23:38,070
same program functionally size-wise

568
00:23:36,090 --> 00:23:39,629
instructional eyes but the hashes are

569
00:23:38,070 --> 00:23:41,520
all different and that's kind of cool is

570
00:23:39,630 --> 00:23:43,650
pretty easy to test that is retrofitted

571
00:23:41,520 --> 00:23:45,418
that same arm-wrestle type script and

572
00:23:43,650 --> 00:23:47,460
instead of flipping one bit I just

573
00:23:45,419 --> 00:23:51,410
flipped all of them there in a ramekin

574
00:23:47,460 --> 00:23:54,620
kind of a way it worked out perfectly

575
00:23:51,410 --> 00:24:08,480
you know you have be running the same

576
00:23:54,620 --> 00:24:10,860
time now the claim of steganography

577
00:24:08,480 --> 00:24:13,020
turns out this is the most complicated

578
00:24:10,860 --> 00:24:16,649
thing to pull off and I think in my

579
00:24:13,020 --> 00:24:18,960
opinion the dumbest thing I've talked

580
00:24:16,650 --> 00:24:21,030
about steganography here and there in

581
00:24:18,960 --> 00:24:21,480
other talks but if you don't do it

582
00:24:21,030 --> 00:24:23,580
really well

583
00:24:21,480 --> 00:24:26,309
steganography is just really stupid and

584
00:24:23,580 --> 00:24:29,189
in this case it is really stupid and

585
00:24:26,309 --> 00:24:36,360
very detectable but again I wanted to

586
00:24:29,190 --> 00:24:39,390
run with it as an exercise so I need to

587
00:24:36,360 --> 00:24:41,039
have some metadata to make things more

588
00:24:39,390 --> 00:24:43,289
convenient for the user so I haven't

589
00:24:41,039 --> 00:24:45,480
been a data for how large the file is so

590
00:24:43,289 --> 00:24:48,950
the program itself can know when to stop

591
00:24:45,480 --> 00:24:51,600
carving to define that as a user and

592
00:24:48,950 --> 00:24:54,110
kind of a conceptual way of how this

593
00:24:51,600 --> 00:25:00,418
works is you have some instructions here

594
00:24:54,110 --> 00:25:02,039
like move multiply multiply that's what

595
00:25:00,419 --> 00:25:03,630
it kind of looks like a binary in red

596
00:25:02,039 --> 00:25:05,879
and have your don't care miss here and

597
00:25:03,630 --> 00:25:11,640
then as a sample assembly program cannot

598
00:25:05,880 --> 00:25:14,669
result straining move and sine x Mary

599
00:25:11,640 --> 00:25:16,679
this is that whole program and what I

600
00:25:14,669 --> 00:25:20,400
want to pack into it is the phrase POC

601
00:25:16,679 --> 00:25:21,059
or gtfo and binary capacity so this is

602
00:25:20,400 --> 00:25:22,110
what it looks like

603
00:25:21,059 --> 00:25:24,360
they don't changing those don't

604
00:25:22,110 --> 00:25:27,840
character fields this is interspersed

605
00:25:24,360 --> 00:25:29,100
four bits at a time the text appear gtfo

606
00:25:27,840 --> 00:25:31,080
it doesn't change the functionality of

607
00:25:29,100 --> 00:25:32,399
instructions and a heck stomach that

608
00:25:31,080 --> 00:25:36,840
looks like this so these are all the

609
00:25:32,400 --> 00:25:39,210
changed bikes and that's high-level how

610
00:25:36,840 --> 00:25:44,480
that's working it's really not too

611
00:25:39,210 --> 00:25:46,920
sophisticated so does it work in general

612
00:25:44,480 --> 00:25:48,510
with that metadata in the down I'm

613
00:25:46,920 --> 00:25:57,840
putting in there I can write a script

614
00:25:48,510 --> 00:25:59,160
and check data in there however I

615
00:25:57,840 --> 00:26:02,030
realize at this point I've been doing a

616
00:25:59,160 --> 00:26:05,130
lot of hacking around but I collected a

617
00:26:02,030 --> 00:26:07,920
test run the programs after I finished

618
00:26:05,130 --> 00:26:13,710
stay going down so I might try done real

619
00:26:07,920 --> 00:26:15,030
quick and it signals something up and

620
00:26:13,710 --> 00:26:23,070
this point I don't know what I mean I

621
00:26:15,030 --> 00:26:24,389
haven't done anything that there are

622
00:26:23,070 --> 00:26:26,929
some instructions in there where the

623
00:26:24,390 --> 00:26:29,640
don't care bits are set incorrectly

624
00:26:26,930 --> 00:26:31,380
which I still don't know why so I

625
00:26:29,640 --> 00:26:33,270
decided to kind of investigate that a

626
00:26:31,380 --> 00:26:42,450
little bit hoping that it would answer

627
00:26:33,270 --> 00:26:44,250
my question so I started isolating off

628
00:26:42,450 --> 00:26:48,390
some of those off spec instructions to

629
00:26:44,250 --> 00:26:49,830
try to see the context why like why

630
00:26:48,390 --> 00:26:53,100
there we run when it stretches around

631
00:26:49,830 --> 00:26:54,780
them and then you know correcting the

632
00:26:53,100 --> 00:26:57,990
instruction actually making into spec to

633
00:26:54,780 --> 00:26:59,399
see what would happen and it's way too

634
00:26:57,990 --> 00:27:01,050
turned out that when I made the the

635
00:26:59,400 --> 00:27:03,570
instructions correct

636
00:27:01,050 --> 00:27:06,690
it actually seg faulted that way like if

637
00:27:03,570 --> 00:27:08,070
I went to a default executable and I

638
00:27:06,690 --> 00:27:09,600
changed one of those off spec

639
00:27:08,070 --> 00:27:12,510
instructions to be the correct version

640
00:27:09,600 --> 00:27:14,189
of it that made the program break like

641
00:27:12,510 --> 00:27:16,490
it was an integral that the instruction

642
00:27:14,190 --> 00:27:20,490
had to be wrong for the program to work

643
00:27:16,490 --> 00:27:23,640
so what I did is I used bokken because

644
00:27:20,490 --> 00:27:24,900
it's a good graphical representation of

645
00:27:23,640 --> 00:27:26,790
a disassembly and it gives really

646
00:27:24,900 --> 00:27:29,940
helpful hints said found with those

647
00:27:26,790 --> 00:27:31,649
problem instructions and then I look for

648
00:27:29,940 --> 00:27:33,030
backlink references to that instruction

649
00:27:31,650 --> 00:27:34,440
and I found an instruction that's

650
00:27:33,030 --> 00:27:35,940
referencing it and

651
00:27:34,440 --> 00:27:39,029
was helpful enough to get would comment

652
00:27:35,940 --> 00:27:41,879
saying it was data so in this case I

653
00:27:39,029 --> 00:27:45,450
have data in the dot text section which

654
00:27:41,879 --> 00:27:47,189
is not necessarily weird or problem this

655
00:27:45,450 --> 00:27:48,450
happens you have like jump tables and

656
00:27:47,190 --> 00:27:50,429
stuff like that it's not necessarily

657
00:27:48,450 --> 00:27:51,929
data in the sense like strings are data

658
00:27:50,429 --> 00:27:53,940
these aren't really strings they might

659
00:27:51,929 --> 00:27:55,679
just be memory addresses or something

660
00:27:53,940 --> 00:27:58,049
like that that do what make sense there

661
00:27:55,679 --> 00:28:00,029
belong in a dot text section but they're

662
00:27:58,049 --> 00:28:02,730
not instructions so this kind of makes

663
00:28:00,029 --> 00:28:04,409
sense as to why you have data

664
00:28:02,730 --> 00:28:07,169
instructions in there that disassemble

665
00:28:04,409 --> 00:28:09,149
like instructions by barn and how they

666
00:28:07,169 --> 00:28:12,389
don't care base said differently because

667
00:28:09,149 --> 00:28:18,539
they're not real instructions so that's

668
00:28:12,389 --> 00:28:19,949
a data problem it might be solvable but

669
00:28:18,539 --> 00:28:21,269
it's way more complex than what I'm

670
00:28:19,950 --> 00:28:25,110
doing right now so I'm trying to find

671
00:28:21,269 --> 00:28:28,409
some clever ways to work around that so

672
00:28:25,110 --> 00:28:31,049
I'm gonna do more profiling I want to

673
00:28:28,409 --> 00:28:34,200
see what data instructions are the most

674
00:28:31,049 --> 00:28:35,759
common like I already saw what assembly

675
00:28:34,200 --> 00:28:37,799
instructions of the most common now I'm

676
00:28:35,759 --> 00:28:40,710
gonna do it for data because my hope is

677
00:28:37,799 --> 00:28:42,750
that maybe just luckily some of those

678
00:28:40,710 --> 00:28:44,580
false positive data instructions are

679
00:28:42,750 --> 00:28:46,500
really really common like maybe it's

680
00:28:44,580 --> 00:28:48,240
only one or two and I could just ignore

681
00:28:46,500 --> 00:28:51,360
those type of instructions for my stay

682
00:28:48,240 --> 00:28:54,179
going to be done with that problem turns

683
00:28:51,360 --> 00:28:57,600
out though it wasn't the case it was

684
00:28:54,179 --> 00:28:59,789
fairly evenly distributed I mean there

685
00:28:57,600 --> 00:29:03,000
was like no attempt and I made up maybe

686
00:28:59,789 --> 00:29:04,679
90% of the instruction set but I

687
00:29:03,000 --> 00:29:06,210
couldn't just ignore instructions

688
00:29:04,679 --> 00:29:10,200
outright I had to handle it in a

689
00:29:06,210 --> 00:29:12,299
different way so my idea was maybe to

690
00:29:10,200 --> 00:29:15,570
dynamically blacklist these instructions

691
00:29:12,299 --> 00:29:17,279
like do a first pass of looking at the

692
00:29:15,570 --> 00:29:19,408
whole program and seeing which

693
00:29:17,279 --> 00:29:21,779
instructions were set incorrectly and

694
00:29:19,409 --> 00:29:24,480
then deciding dynamically to blackness

695
00:29:21,779 --> 00:29:26,129
those instructions and then even have to

696
00:29:24,480 --> 00:29:28,440
record it in the metadata because the

697
00:29:26,129 --> 00:29:30,629
program that's extracting it needs to

698
00:29:28,440 --> 00:29:32,639
know which instructions to skip as well

699
00:29:30,629 --> 00:29:33,928
you have to communicate that that's what

700
00:29:32,639 --> 00:29:36,449
I end up doing but then you're thinking

701
00:29:33,929 --> 00:29:37,919
okay that requires more metadata and

702
00:29:36,450 --> 00:29:39,280
what if you're shoving like what if

703
00:29:37,919 --> 00:29:40,540
you're showing that meta done

704
00:29:39,280 --> 00:29:43,330
instructions that are actually data and

705
00:29:40,540 --> 00:29:45,159
then you still have the same problem so

706
00:29:43,330 --> 00:29:47,470
how much my I'm fed it down it is not

707
00:29:45,160 --> 00:29:49,360
going to take and also going to put that

708
00:29:47,470 --> 00:29:52,030
metadata in the very beginning of my

709
00:29:49,360 --> 00:29:54,280
data as to try to reduce the risk even

710
00:29:52,030 --> 00:29:55,690
more and I'm able to get that metadata

711
00:29:54,280 --> 00:29:57,970
into one bite

712
00:29:55,690 --> 00:30:00,190
like literally doing a dynamic blacklist

713
00:29:57,970 --> 00:30:01,840
of the entire instruction set of which

714
00:30:00,190 --> 00:30:04,690
ones which instructions I want to skip

715
00:30:01,840 --> 00:30:08,350
I'm reporting that down in one bite and

716
00:30:04,690 --> 00:30:11,200
this is my reasoning say that the top

717
00:30:08,350 --> 00:30:14,350
three instructions that the false

718
00:30:11,200 --> 00:30:17,770
positive is data are like load our

719
00:30:14,350 --> 00:30:20,490
datastore in a star storage in this case

720
00:30:17,770 --> 00:30:23,590
this is accurate to this is an arbitrary

721
00:30:20,490 --> 00:30:25,510
so if it really is in that order of most

722
00:30:23,590 --> 00:30:29,110
comments at least common if I'm

723
00:30:25,510 --> 00:30:31,510
profiling when I see strh show up I can

724
00:30:29,110 --> 00:30:34,120
kind of safely assume that strd mmm I'll

725
00:30:31,510 --> 00:30:35,830
dr game are also in that blacklist as

726
00:30:34,120 --> 00:30:39,100
well because they're even more common

727
00:30:35,830 --> 00:30:44,080
than strh and that's my logic i only

728
00:30:39,100 --> 00:30:46,149
record the most least common one that it

729
00:30:44,080 --> 00:30:47,770
actually finds and just assume that all

730
00:30:46,150 --> 00:30:49,300
that other more common statistically

731
00:30:47,770 --> 00:30:50,620
instructions are also going to show up

732
00:30:49,300 --> 00:30:53,860
there as well

733
00:30:50,620 --> 00:31:05,649
and that's how I get it into life in

734
00:30:53,860 --> 00:31:08,679
this case I just say but what happened

735
00:31:05,650 --> 00:31:11,620
is did I still if that's still not

736
00:31:08,680 --> 00:31:13,560
enough like if that data destruction

737
00:31:11,620 --> 00:31:17,409
happens to be one of the first

738
00:31:13,560 --> 00:31:21,970
instructions if there's overlap with

739
00:31:17,410 --> 00:31:23,830
those top ten places and fortunately the

740
00:31:21,970 --> 00:31:25,630
top 10 for data instructions in the top

741
00:31:23,830 --> 00:31:29,679
10 for actual instructions with don't

742
00:31:25,630 --> 00:31:31,000
care bits is almost mainly exclusive may

743
00:31:29,680 --> 00:31:35,650
be a lot harder if they weren't they're

744
00:31:31,000 --> 00:31:38,080
the same but I'm thinking in theory is

745
00:31:35,650 --> 00:31:39,660
rare and if it could happen but I really

746
00:31:38,080 --> 00:31:42,570
have I want

747
00:31:39,660 --> 00:31:43,800
against that and it took some research

748
00:31:42,570 --> 00:31:46,260
but I found something that did prove

749
00:31:43,800 --> 00:31:51,659
against that on the raspbian system

750
00:31:46,260 --> 00:31:54,480
these are been GA tool you find here and

751
00:31:51,660 --> 00:31:57,300
I would say the move instruction for the

752
00:31:54,480 --> 00:31:59,100
medium form is one instruction of

753
00:31:57,300 --> 00:32:00,960
overlap like if you look at the top ten

754
00:31:59,100 --> 00:32:04,020
of both those lists the move instruction

755
00:32:00,960 --> 00:32:05,700
is the only instruction shared and this

756
00:32:04,020 --> 00:32:11,550
move instruction comes in really early

757
00:32:05,700 --> 00:32:14,790
on in this binary so this method still

758
00:32:11,550 --> 00:32:16,919
doesn't work it's a rare edge case but I

759
00:32:14,790 --> 00:32:19,290
still want to solve it and the

760
00:32:16,920 --> 00:32:22,710
convoluted edge case is to just detect

761
00:32:19,290 --> 00:32:24,180
the educate America so I know so I can

762
00:32:22,710 --> 00:32:26,450
adjust accordingly with some other

763
00:32:24,180 --> 00:32:29,190
arguments that I have to develop later

764
00:32:26,450 --> 00:32:31,500
there's also false negatives it's like

765
00:32:29,190 --> 00:32:33,720
when I'm broke modeling I might find a

766
00:32:31,500 --> 00:32:35,810
data instruction that just happens to

767
00:32:33,720 --> 00:32:39,030
have the don't care basis set correctly

768
00:32:35,810 --> 00:32:41,159
so that's another problem too it hasn't

769
00:32:39,030 --> 00:32:44,940
come up in practice but that's another

770
00:32:41,160 --> 00:32:46,140
issue so my solution to kind of all

771
00:32:44,940 --> 00:32:48,290
those past problems is to have a

772
00:32:46,140 --> 00:32:50,520
blacklist override like I can actually

773
00:32:48,290 --> 00:32:52,980
manually override that blacklist and

774
00:32:50,520 --> 00:32:54,840
sets a higher threshold so if you know

775
00:32:52,980 --> 00:32:57,450
you stay going in sec : so you can make

776
00:32:54,840 --> 00:32:58,980
that blacklist more aggressive and it

777
00:32:57,450 --> 00:33:00,540
won't say long anymore because you're

778
00:32:58,980 --> 00:33:02,130
skipping over the correct instructions

779
00:33:00,540 --> 00:33:08,180
it's just now you're gonna have less

780
00:33:02,130 --> 00:33:13,470
data space to code data into and then an

781
00:33:08,180 --> 00:33:16,680
education education sometimes hit a

782
00:33:13,470 --> 00:33:25,640
point where were blacklisting so many

783
00:33:16,680 --> 00:33:28,680
instructions that we still say you know

784
00:33:25,640 --> 00:33:32,150
it's it's a small interface but it

785
00:33:28,680 --> 00:33:34,260
happens so in this case all I can say is

786
00:33:32,150 --> 00:33:36,480
if you run the tool

787
00:33:34,260 --> 00:33:39,120
you still get a seg home I guess you

788
00:33:36,480 --> 00:33:44,000
can't say go to that program now this is

789
00:33:39,120 --> 00:33:47,489
a small problem though and then finally

790
00:33:44,000 --> 00:33:48,650
this is noisy if you were to look at a

791
00:33:47,490 --> 00:33:50,570
binary

792
00:33:48,650 --> 00:33:53,720
question well did somebody stay on this

793
00:33:50,570 --> 00:33:54,860
program in this method well you have a

794
00:33:53,720 --> 00:33:56,810
point of reference on what the

795
00:33:54,860 --> 00:33:59,360
instructions are supposed to be looking

796
00:33:56,810 --> 00:34:00,620
like so if it was stay ago all these

797
00:33:59,360 --> 00:34:03,350
bits are going to be changed

798
00:34:00,620 --> 00:34:08,929
so you can with some confidence say this

799
00:34:03,350 --> 00:34:10,759
program I stay go so in this context

800
00:34:08,929 --> 00:34:13,909
this is why I said steganography it's

801
00:34:10,760 --> 00:34:16,580
stupid there's a lot of heuristics I can

802
00:34:13,909 --> 00:34:18,890
do I can just definitely say if these

803
00:34:16,580 --> 00:34:20,299
 don't miss respect then this is

804
00:34:18,889 --> 00:34:22,429
definitely stay ago I can't say that

805
00:34:20,300 --> 00:34:23,450
because there is a range of instructions

806
00:34:22,429 --> 00:34:26,330
that are going to be data that will

807
00:34:23,449 --> 00:34:28,639
throw that off but if the program has

808
00:34:26,330 --> 00:34:30,889
been staying most like name is

809
00:34:28,639 --> 00:34:33,770
significantly higher than that 13% rate

810
00:34:30,889 --> 00:34:36,799
like really just by random luck only

811
00:34:33,770 --> 00:34:38,300
about one in 16 of the don't care mid

812
00:34:36,800 --> 00:34:40,399
fields are going to be normal looking

813
00:34:38,300 --> 00:34:44,929
for instructions that only have four

814
00:34:40,399 --> 00:34:47,418
bits of don't care but you know even

815
00:34:44,929 --> 00:34:49,429
higher so we can look at look at that as

816
00:34:47,418 --> 00:34:52,790
a profile although I would say is a

817
00:34:49,429 --> 00:34:54,740
bench case librarians tend to have way

818
00:34:52,790 --> 00:34:57,259
more than 30% so you got to kind of keep

819
00:34:54,739 --> 00:34:59,870
that in mind as well but there's other

820
00:34:57,260 --> 00:35:01,610
things like I am reporting metadata so

821
00:34:59,870 --> 00:35:03,560
in my stake over the program the

822
00:35:01,610 --> 00:35:06,620
metadata would be larger than zero

823
00:35:03,560 --> 00:35:08,480
obviously and fortunately don't care

824
00:35:06,620 --> 00:35:11,540
bits are typically zeros and a lot of

825
00:35:08,480 --> 00:35:13,550
instructions so if you do see 0s or

826
00:35:11,540 --> 00:35:15,950
metadata then it probably wasn't

827
00:35:13,550 --> 00:35:19,250
staggered you can kind of coordinate

828
00:35:15,950 --> 00:35:22,549
this information also if the metadata

829
00:35:19,250 --> 00:35:25,310
isn't 0 like it's not 0 but it would

830
00:35:22,550 --> 00:35:27,050
seem to indicate that the amount of data

831
00:35:25,310 --> 00:35:28,850
is larger that the programmer even

832
00:35:27,050 --> 00:35:31,010
looking at well then these are just

833
00:35:28,850 --> 00:35:33,140
random ones and zeros very don't care

834
00:35:31,010 --> 00:35:34,760
bits that couldn't mean it's stay go

835
00:35:33,140 --> 00:35:38,060
because you can't pack more data into

836
00:35:34,760 --> 00:35:39,770
less data and then you know our

837
00:35:38,060 --> 00:35:42,110
blacklist information we can correlate

838
00:35:39,770 --> 00:35:44,330
that to we can like actually look to see

839
00:35:42,110 --> 00:35:46,940
how much instructions which should be

840
00:35:44,330 --> 00:35:50,270
blacklisting and compare it to our

841
00:35:46,940 --> 00:35:51,920
actual blacklist in the metadata and you

842
00:35:50,270 --> 00:35:54,230
know we can assume whether or not it

843
00:35:51,920 --> 00:35:56,930
really matches or it combines in that

844
00:35:54,230 --> 00:36:01,850
way in a couple of different contexts

845
00:35:56,930 --> 00:36:05,140
you know also the very last name which

846
00:36:01,850 --> 00:36:09,740
not going to cover too much for reasons

847
00:36:05,140 --> 00:36:11,990
the shellcode part so I can say with

848
00:36:09,740 --> 00:36:16,189
confidence that you can use this method

849
00:36:11,990 --> 00:36:21,169
to remove nulls completely out of some

850
00:36:16,190 --> 00:36:22,820
instructions on the side here I have in

851
00:36:21,170 --> 00:36:24,320
the middle section here we have all

852
00:36:22,820 --> 00:36:25,580
these instructions this is the full list

853
00:36:24,320 --> 00:36:28,790
of instructions you can do this with

854
00:36:25,580 --> 00:36:30,740
other instructions if you can't so we

855
00:36:28,790 --> 00:36:35,259
have the machine code on the side here

856
00:36:30,740 --> 00:36:35,259
all these yellow highlighted nulls or

857
00:36:38,140 --> 00:36:48,920
the corresponding bits and on the right

858
00:36:42,140 --> 00:36:51,319
side here so in theory this does work in

859
00:36:48,920 --> 00:36:53,360
practice I'm not going to say I'm

860
00:36:51,320 --> 00:36:55,850
not exploit developer I haven't tested

861
00:36:53,360 --> 00:36:56,630
it and I think it's a responsible estate

862
00:36:55,850 --> 00:37:01,549
if this is going to help your

863
00:36:56,630 --> 00:37:02,570
exploitation especially since really if

864
00:37:01,550 --> 00:37:05,720
you look into it

865
00:37:02,570 --> 00:37:08,360
Arvin's thumb instructions it's a little

866
00:37:05,720 --> 00:37:11,930
compact encoded in there 16-bit they

867
00:37:08,360 --> 00:37:17,690
tend to usually not have no lights in

868
00:37:11,930 --> 00:37:20,180
them and for the ones that do but again

869
00:37:17,690 --> 00:37:21,770
this isn't my thing so I'm not going to

870
00:37:20,180 --> 00:37:25,100
actually boldly claim that this is going

871
00:37:21,770 --> 00:37:34,300
to help you with exploitation because

872
00:37:25,100 --> 00:37:37,520
that's lazy I'm not a contestant doing

873
00:37:34,300 --> 00:37:39,860
pulling information out of some

874
00:37:37,520 --> 00:37:43,190
executables and by the way and I pulled

875
00:37:39,860 --> 00:37:46,690
apart behind me because it's armed but I

876
00:37:43,190 --> 00:37:50,780
didn't was because decade ago it was

877
00:37:46,690 --> 00:37:55,220
steganography tool written for x86 kind

878
00:37:50,780 --> 00:37:57,770
of similar in concept like say like some

879
00:37:55,220 --> 00:38:02,509
instructions like say Hanks or there's

880
00:37:57,770 --> 00:38:05,560
more than one way to do like X or on the

881
00:38:02,510 --> 00:38:09,200
X DX that's actually

882
00:38:05,560 --> 00:38:10,970
that's exchange but anyway you can

883
00:38:09,200 --> 00:38:13,009
encode it in a couple different ways

884
00:38:10,970 --> 00:38:14,990
they're both found in eilerson

885
00:38:13,010 --> 00:38:19,460
one way but if you were to do

886
00:38:14,990 --> 00:38:21,169
alternating ways and your binary and

887
00:38:19,460 --> 00:38:24,050
that's kind of one of the heuristics

888
00:38:21,170 --> 00:38:25,160
that they sent me my implementations a

889
00:38:24,050 --> 00:38:29,630
lot different but the concept is very

890
00:38:25,160 --> 00:38:32,180
similar so that's why I call this so

891
00:38:29,630 --> 00:38:38,060
let's go ahead and look through this PMC

892
00:38:32,180 --> 00:38:40,490
here so I'm listing when I have in this

893
00:38:38,060 --> 00:38:42,350
directory I have a file called our PLC

894
00:38:40,490 --> 00:38:45,580
I'm running fine line up to see what it

895
00:38:42,350 --> 00:38:45,580
is it looks like an elf executable

896
00:38:45,820 --> 00:38:50,960
executable I'm gonna run it to $20 and

897
00:38:48,970 --> 00:39:01,299
you know it does something it's kind of

898
00:38:50,960 --> 00:39:04,370
dumping like a file so it's okay so now

899
00:39:01,300 --> 00:39:06,500
I'm actually comparing this our POC with

900
00:39:04,370 --> 00:39:09,109
actually business CMP nsv to save

901
00:39:06,500 --> 00:39:12,350
mouthsize but if we check the hashes

902
00:39:09,110 --> 00:39:14,450
against each other 30 economists egg

903
00:39:12,350 --> 00:39:17,000
analysis we see that the hash is hard

904
00:39:14,450 --> 00:39:18,649
different that's cool so we're gonna run

905
00:39:17,000 --> 00:39:21,080
behind against it we're gonna extract

906
00:39:18,650 --> 00:39:32,390
from our POC our output is going to be

907
00:39:21,080 --> 00:39:33,710
mystery so and this is also a program so

908
00:39:32,390 --> 00:39:34,879
we've talked a program inside of a

909
00:39:33,710 --> 00:39:37,520
program that's kind of cool

910
00:39:34,880 --> 00:39:40,400
let's make it executable and it just

911
00:39:37,520 --> 00:39:50,180
says clinics so the comparator you name

912
00:39:40,400 --> 00:39:53,570
and let's go ahead of mystery out sizes

913
00:39:50,180 --> 00:39:55,129
cool right it worked let's prepare the

914
00:39:53,570 --> 00:39:56,540
hashes in that just in case those do

915
00:39:55,130 --> 00:40:00,920
what happens

916
00:39:56,540 --> 00:40:02,720
so we're typing that out or extract any

917
00:40:00,920 --> 00:40:08,060
names you really need to hashes are

918
00:40:02,720 --> 00:40:11,540
different so inception we extract

919
00:40:08,060 --> 00:40:14,270
out of that mystery no doubt and output

920
00:40:11,540 --> 00:40:17,870
that mystery to demo and run file

921
00:40:14,270 --> 00:40:23,840
against an and see it's a

922
00:40:17,870 --> 00:40:25,690
text file so be candid cactus Coola so

923
00:40:23,840 --> 00:40:31,730
that I think that's really cool you can

924
00:40:25,690 --> 00:40:34,570
on multiple layers pack the data and

925
00:40:31,730 --> 00:40:37,370
that's a quick perfect concept for

926
00:40:34,570 --> 00:40:43,300
which I have on github in the last slide

927
00:40:37,370 --> 00:40:45,380
I'll link to that so in conclusion

928
00:40:43,300 --> 00:40:48,950
regardless of you know what this talk

929
00:40:45,380 --> 00:40:50,780
was about are behind messin don't miss

930
00:40:48,950 --> 00:40:53,089
my arm and all that

931
00:40:50,780 --> 00:40:57,230
theories are quick and sexy it's easy

932
00:40:53,090 --> 00:40:59,690
like to do all this work it took a lot

933
00:40:57,230 --> 00:41:01,250
of testing and took a lot of profiling

934
00:40:59,690 --> 00:41:03,230
half which had nothing to do with the

935
00:41:01,250 --> 00:41:05,150
progression mr. babies performance or

936
00:41:03,230 --> 00:41:06,830
answering some questions but those are

937
00:41:05,150 --> 00:41:09,550
really important and crucial as well

938
00:41:06,830 --> 00:41:12,049
that took me like four to five months

939
00:41:09,550 --> 00:41:14,270
but to come up with a theory took me 15

940
00:41:12,050 --> 00:41:17,240
minutes so I wanna give a perspective on

941
00:41:14,270 --> 00:41:18,740
the difference there the process just

942
00:41:17,240 --> 00:41:21,589
takes a lot of work a lot of time and

943
00:41:18,740 --> 00:41:22,850
it's not really that sexy I mean the

944
00:41:21,590 --> 00:41:25,340
majority of this talk might have

945
00:41:22,850 --> 00:41:27,860
actually legitimately been boring but

946
00:41:25,340 --> 00:41:31,000
that's that's an important point I'm

947
00:41:27,860 --> 00:41:33,680
just saying it it's crucial to do it

948
00:41:31,000 --> 00:41:35,750
like there are theoretical fields that

949
00:41:33,680 --> 00:41:38,359
exist and that's okay this isn't one of

950
00:41:35,750 --> 00:41:41,480
them we should just talk about a theory

951
00:41:38,360 --> 00:41:44,230
we should do it so really that the

952
00:41:41,480 --> 00:41:46,580
sermon is if you know how to behave like

953
00:41:44,230 --> 00:41:50,210
and I have a little quote up here I'll

954
00:41:46,580 --> 00:41:52,250
zoom into it but sometimes we have

955
00:41:50,210 --> 00:41:55,670
friends that say things like this and

956
00:41:52,250 --> 00:41:58,100
it's just really really cringey like not

957
00:41:55,670 --> 00:42:02,600
saying they can't do this but shut up

958
00:41:58,100 --> 00:42:05,630
until you do it and this is the actual

959
00:42:02,600 --> 00:42:08,319
end of the talk not a lot of people but

960
00:42:05,630 --> 00:42:08,320
if you have any questions

961
00:42:15,100 --> 00:42:36,650
yeah Joe of course I mean like on a like

962
00:42:33,650 --> 00:42:38,990
batching him he's asking you know if it

963
00:42:36,650 --> 00:42:52,670
can be scripted out are you talking like

964
00:42:38,990 --> 00:42:56,540
a Qing a bunch of in this case as it

965
00:42:52,670 --> 00:43:00,530
stands now and it's open source but it

966
00:42:56,540 --> 00:43:03,640
is limited to an elf executable because

967
00:43:00,530 --> 00:43:06,980
I am doing some pre-processing first to

968
00:43:03,640 --> 00:43:09,020
it it won't actually run if it sees that

969
00:43:06,980 --> 00:43:11,030
it's not an elf executable it actually

970
00:43:09,020 --> 00:43:13,160
does look specifically for the dot text

971
00:43:11,030 --> 00:43:15,260
section and only applies its logic to

972
00:43:13,160 --> 00:43:17,990
that because obviously if it's if it's

973
00:43:15,260 --> 00:43:19,940
like considering the data section is

974
00:43:17,990 --> 00:43:22,180
instructions it's going to it up so

975
00:43:19,940 --> 00:43:24,950
I do have to be very careful about that

976
00:43:22,180 --> 00:43:27,529
however that's just referring this tool

977
00:43:24,950 --> 00:43:31,189
it doesn't mean that you couldn't apply

978
00:43:27,530 --> 00:43:32,780
the same process to shellcode it's just

979
00:43:31,190 --> 00:43:34,640
as tool as it stands doesn't do that but

980
00:43:32,780 --> 00:43:36,440
of course this with shellcode you could

981
00:43:34,640 --> 00:43:38,629
change those don't care bits to anything

982
00:43:36,440 --> 00:43:43,220
you want and it would work the same as

983
00:43:38,630 --> 00:43:45,950
this but no my tool doesn't do that it

984
00:43:43,220 --> 00:43:47,720
doesn't do matching by default but it is

985
00:43:45,950 --> 00:43:49,580
a command with arguments and it's not an

986
00:43:47,720 --> 00:43:51,290
interactive program so you could

987
00:43:49,580 --> 00:43:55,180
probably write a you know a one-liner

988
00:43:51,290 --> 00:43:55,180
that does that it should work

989
00:43:58,460 --> 00:44:03,619
one other thing I described a lot in

990
00:44:02,270 --> 00:44:05,300
different ways as profiling and

991
00:44:03,619 --> 00:44:07,160
researching that are all time-consuming

992
00:44:05,300 --> 00:44:08,240
I didn't literally tell you all of the

993
00:44:07,160 --> 00:44:10,060
things so it was even more

994
00:44:08,240 --> 00:44:12,649
time-consuming that I'm giving away

995
00:44:10,060 --> 00:44:15,470
because I had other random questions

996
00:44:12,650 --> 00:44:18,740
that don't apply to this but I did have

997
00:44:15,470 --> 00:44:21,618
the question how many don't care bits an

998
00:44:18,740 --> 00:44:24,200
elf executables how many don't care bins

999
00:44:21,619 --> 00:44:27,650
total are there

1000
00:44:24,200 --> 00:44:29,450
rasping system I asked that question and

1001
00:44:27,650 --> 00:44:33,050
I profiled it I think this is when I

1002
00:44:29,450 --> 00:44:36,980
when I didn't have my Raspberry Pi 3 B+

1003
00:44:33,050 --> 00:44:39,079
so it took a while maybe two weeks to

1004
00:44:36,980 --> 00:44:42,160
find the answer this question and it was

1005
00:44:39,079 --> 00:44:45,109
something in the word like 500 megabytes

1006
00:44:42,160 --> 00:44:47,390
that's really cool that's like free data

1007
00:44:45,109 --> 00:44:47,990
you know I mean and it's easier said

1008
00:44:47,390 --> 00:44:49,578
than done

1009
00:44:47,990 --> 00:44:51,799
because if you really wanted to like

1010
00:44:49,579 --> 00:44:54,710
store a lot of data and all that and

1011
00:44:51,800 --> 00:44:55,849
have to add more complexity because

1012
00:44:54,710 --> 00:44:57,560
you're going to be splitting that data

1013
00:44:55,849 --> 00:45:00,380
across several executables we gotta

1014
00:44:57,560 --> 00:45:02,029
track that but you know it's kind of

1015
00:45:00,380 --> 00:45:05,210
interesting too as far as like batching

1016
00:45:02,030 --> 00:45:07,910
another kind of application about if you

1017
00:45:05,210 --> 00:45:10,099
wanted to do that I'm in practice I

1018
00:45:07,910 --> 00:45:15,250
don't know so really say it works or

1019
00:45:10,099 --> 00:45:15,250
I've done it or any other questions just

1020
00:45:16,150 --> 00:45:23,020
Jo that sounds like a normal talk for me

1021
00:45:19,750 --> 00:45:23,020
alright thank you

1022
00:45:23,170 --> 00:45:27,760
[Applause]

