1
00:00:02,639 --> 00:00:06,480
hey cactus con alex here again

2
00:00:04,720 --> 00:00:07,919
our next talk is stealing a password

3
00:00:06,480 --> 00:00:09,599
through interpretive dance and other

4
00:00:07,919 --> 00:00:12,399
wild video game hacks

5
00:00:09,599 --> 00:00:14,240
brought to us by dan alt f4 petro who's

6
00:00:12,400 --> 00:00:15,679
a lead researcher bishop fox

7
00:00:14,240 --> 00:00:17,680
and according to him loves to hear

8
00:00:15,679 --> 00:00:18,320
himself talk so if you love to hear him

9
00:00:17,680 --> 00:00:19,840
talk

10
00:00:18,320 --> 00:00:21,760
watch this presentation and then stick

11
00:00:19,840 --> 00:00:22,960
around for a live q a click the link

12
00:00:21,760 --> 00:00:23,840
that pops up on the screen at the end of

13
00:00:22,960 --> 00:00:26,320
the youtube video

14
00:00:23,840 --> 00:00:26,320
and enjoy

15
00:00:28,960 --> 00:00:32,640
hey everybody i'm dan petro uh you might

16
00:00:31,279 --> 00:00:34,559
know me as ultef4

17
00:00:32,640 --> 00:00:36,000
i'm the lead researcher and a long time

18
00:00:34,559 --> 00:00:37,280
pen tester at bishop fox

19
00:00:36,000 --> 00:00:39,040
and today i'm going to show you some

20
00:00:37,280 --> 00:00:41,120
really cool video game hacks

21
00:00:39,040 --> 00:00:42,320
that i found across of various online

22
00:00:41,120 --> 00:00:44,239
super smash brothers

23
00:00:42,320 --> 00:00:45,600
and magic the gathering programs and

24
00:00:44,239 --> 00:00:48,160
libraries

25
00:00:45,600 --> 00:00:49,120
now i play a lot of video games i always

26
00:00:48,160 --> 00:00:50,718
have but

27
00:00:49,120 --> 00:00:52,640
these days is being cooped up inside

28
00:00:50,719 --> 00:00:53,680
even more so in particular

29
00:00:52,640 --> 00:00:56,160
i've been spending a lot of time

30
00:00:53,680 --> 00:00:56,640
programming on some fun side projects

31
00:00:56,160 --> 00:00:58,800
and

32
00:00:56,640 --> 00:01:00,239
you know what computers have this weird

33
00:00:58,800 --> 00:01:02,879
way of breaking around me

34
00:01:00,239 --> 00:01:03,680
uh andrew wilson my old boss and a

35
00:01:02,879 --> 00:01:05,840
former uh

36
00:01:03,680 --> 00:01:07,680
founder of cactus con likes to say that

37
00:01:05,840 --> 00:01:09,600
my methodology for pen testing is just

38
00:01:07,680 --> 00:01:10,320
to be so bad at using computers that

39
00:01:09,600 --> 00:01:13,119
they break

40
00:01:10,320 --> 00:01:14,639
around me which i choose to take as a

41
00:01:13,119 --> 00:01:16,080
compliment

42
00:01:14,640 --> 00:01:17,520
funny enough none of the stuff that

43
00:01:16,080 --> 00:01:17,920
you're going to see in this talk was

44
00:01:17,520 --> 00:01:19,839
from

45
00:01:17,920 --> 00:01:21,040
a bug hunting expedition the

46
00:01:19,840 --> 00:01:22,640
vulnerabilities i'm going to show you

47
00:01:21,040 --> 00:01:25,040
are the result of me just

48
00:01:22,640 --> 00:01:26,560
tinkering with technology and on some

49
00:01:25,040 --> 00:01:28,240
personal side projects

50
00:01:26,560 --> 00:01:30,640
and being unable to do anything other

51
00:01:28,240 --> 00:01:31,439
than come at it from a security oriented

52
00:01:30,640 --> 00:01:33,680
mindset

53
00:01:31,439 --> 00:01:36,240
and i think they're pretty cool so let's

54
00:01:33,680 --> 00:01:36,240
jump into it

55
00:01:36,880 --> 00:01:40,399
the first bug i'm going to show you has

56
00:01:38,159 --> 00:01:42,880
to do with online games of super smash

57
00:01:40,400 --> 00:01:45,680
brothers melee for the nintendo gamecube

58
00:01:42,880 --> 00:01:47,439
melee is a great game and esport i

59
00:01:45,680 --> 00:01:49,520
started playing melee back in the day

60
00:01:47,439 --> 00:01:51,679
the day came out in 2001 i've been

61
00:01:49,520 --> 00:01:52,720
hooked ever since over the years i've

62
00:01:51,680 --> 00:01:54,159
been a player

63
00:01:52,720 --> 00:01:56,320
tournament organizer in the local

64
00:01:54,159 --> 00:01:57,520
phoenix area and these days i help out

65
00:01:56,320 --> 00:01:58,398
with slippy development behind the

66
00:01:57,520 --> 00:02:00,479
scenes but i'm

67
00:01:58,399 --> 00:02:01,439
getting ahead of myself you might be

68
00:02:00,479 --> 00:02:04,719
thinking wait

69
00:02:01,439 --> 00:02:06,158
the nintendo gamecube wasn't that a 20

70
00:02:04,719 --> 00:02:08,639
year old console with

71
00:02:06,159 --> 00:02:09,679
zero internet connectivity what netplay

72
00:02:08,639 --> 00:02:12,000
are you talking about

73
00:02:09,679 --> 00:02:14,400
so let's take a step back for a minute

74
00:02:12,000 --> 00:02:16,160
and talk about that

75
00:02:14,400 --> 00:02:18,560
since around 2015 i've been working on

76
00:02:16,160 --> 00:02:20,879
this project mine called smashbot

77
00:02:18,560 --> 00:02:22,959
it's an ai that plays bayley and aims to

78
00:02:20,879 --> 00:02:24,720
be kind of like a playable task

79
00:02:22,959 --> 00:02:26,400
it's meant to showcase what's possible

80
00:02:24,720 --> 00:02:26,800
in the game at the absolute highest

81
00:02:26,400 --> 00:02:28,879
level

82
00:02:26,800 --> 00:02:30,560
while beating its opponents senseless

83
00:02:28,879 --> 00:02:31,518
they can do things that are possible in

84
00:02:30,560 --> 00:02:34,239
the game but

85
00:02:31,519 --> 00:02:34,800
not realistically performable by humans

86
00:02:34,239 --> 00:02:36,720
like

87
00:02:34,800 --> 00:02:38,319
the infinite wave shine combo that

88
00:02:36,720 --> 00:02:40,080
you're seeing here

89
00:02:38,319 --> 00:02:42,079
people have known theoretically about

90
00:02:40,080 --> 00:02:42,640
this kind of technology for a long time

91
00:02:42,080 --> 00:02:44,800
due to the

92
00:02:42,640 --> 00:02:46,399
great work of tassers like super doodle

93
00:02:44,800 --> 00:02:48,640
man and practical tasks

94
00:02:46,400 --> 00:02:50,160
but those are only in pre-prepared

95
00:02:48,640 --> 00:02:53,518
videos you couldn't actually

96
00:02:50,160 --> 00:02:54,799
play against those like smashbot

97
00:02:53,519 --> 00:02:56,319
so over the years i've been slowly

98
00:02:54,800 --> 00:02:57,040
adding more features and updating its

99
00:02:56,319 --> 00:02:58,720
logic

100
00:02:57,040 --> 00:03:00,640
in fact there's loads of people in the

101
00:02:58,720 --> 00:03:02,720
smash community that know me just as

102
00:03:00,640 --> 00:03:04,000
that smashbot guy and i have no idea

103
00:03:02,720 --> 00:03:06,080
that i'm also a professional

104
00:03:04,000 --> 00:03:08,560
computer hacker i've also been working

105
00:03:06,080 --> 00:03:09,280
on lib melee which is an open api that

106
00:03:08,560 --> 00:03:11,920
you can use

107
00:03:09,280 --> 00:03:13,680
to make your very own melee ai it's

108
00:03:11,920 --> 00:03:15,599
basically all the laborious plumbing

109
00:03:13,680 --> 00:03:18,000
components underneath smashbot

110
00:03:15,599 --> 00:03:18,959
that aren't actually like ai logic

111
00:03:18,000 --> 00:03:20,800
things like

112
00:03:18,959 --> 00:03:22,239
reading the game state and configuring

113
00:03:20,800 --> 00:03:23,920
and setting up a match and

114
00:03:22,239 --> 00:03:26,239
programmatically taking actions on a

115
00:03:23,920 --> 00:03:27,920
virtual controller that sort of thing

116
00:03:26,239 --> 00:03:29,440
there's a bunch of awesome ai

117
00:03:27,920 --> 00:03:31,359
researchers who've also been working on

118
00:03:29,440 --> 00:03:32,400
their very own melee ais using like

119
00:03:31,360 --> 00:03:34,640
neural networks

120
00:03:32,400 --> 00:03:36,000
they're all in early development but if

121
00:03:34,640 --> 00:03:37,119
you're a smasher keep an eye out for

122
00:03:36,000 --> 00:03:38,000
them it's gonna be pretty cool coming

123
00:03:37,120 --> 00:03:40,400
soon

124
00:03:38,000 --> 00:03:41,680
so about a year ago right as the

125
00:03:40,400 --> 00:03:43,040
pandemic was starting i

126
00:03:41,680 --> 00:03:45,120
suddenly found myself with a lot of

127
00:03:43,040 --> 00:03:46,079
spare time at home some of my other

128
00:03:45,120 --> 00:03:48,480
hobbies like

129
00:03:46,080 --> 00:03:49,599
ping pong and magic gathering were no

130
00:03:48,480 --> 00:03:51,840
longer available

131
00:03:49,599 --> 00:03:53,518
so i decided to pick smashbot back up as

132
00:03:51,840 --> 00:03:55,200
a programming project since i

133
00:03:53,519 --> 00:03:57,120
kind of put it down for a year or so at

134
00:03:55,200 --> 00:03:58,958
that point i wanted to add

135
00:03:57,120 --> 00:04:00,720
console support to smashbot meaning

136
00:03:58,959 --> 00:04:02,640
having the bot play directly plugged

137
00:04:00,720 --> 00:04:04,319
into a real physical console

138
00:04:02,640 --> 00:04:06,480
as opposed to an emulator which

139
00:04:04,319 --> 00:04:08,480
eventually led me to slippy

140
00:04:06,480 --> 00:04:09,840
slippy is this wonderful project led by

141
00:04:08,480 --> 00:04:11,840
a developer named fizzy

142
00:04:09,840 --> 00:04:12,959
that is a technology platform that added

143
00:04:11,840 --> 00:04:14,959
a replay system

144
00:04:12,959 --> 00:04:16,478
into the game it was a crazy

145
00:04:14,959 --> 00:04:17,759
breakthrough that made all kinds of new

146
00:04:16,478 --> 00:04:19,918
applications possible

147
00:04:17,759 --> 00:04:20,880
and i immediately recognized how great

148
00:04:19,918 --> 00:04:23,039
the tech would be

149
00:04:20,880 --> 00:04:24,479
and started helping out with development

150
00:04:23,040 --> 00:04:25,120
my intentions at this point were really

151
00:04:24,479 --> 00:04:27,120
just to

152
00:04:25,120 --> 00:04:28,639
add some additional features that bots

153
00:04:27,120 --> 00:04:30,400
like mine were going to need

154
00:04:28,639 --> 00:04:32,080
but then fizzy invited me to the private

155
00:04:30,400 --> 00:04:32,638
beta of a secret project he's been

156
00:04:32,080 --> 00:04:35,039
working on

157
00:04:32,639 --> 00:04:35,919
in the background slippy rollback

158
00:04:35,040 --> 00:04:38,240
netcode

159
00:04:35,919 --> 00:04:40,159
a way of playing nearly lagless online

160
00:04:38,240 --> 00:04:40,800
games just at a time when the community

161
00:04:40,160 --> 00:04:43,520
needed

162
00:04:40,800 --> 00:04:45,280
a good online mode the most so let's

163
00:04:43,520 --> 00:04:48,400
talk a little bit how this netcode works

164
00:04:45,280 --> 00:04:50,479
because it's going to matter for our bug

165
00:04:48,400 --> 00:04:52,159
two players using the dolphin emulator

166
00:04:50,479 --> 00:04:54,320
can play a game of melee on their own

167
00:04:52,160 --> 00:04:56,000
computers independent of one another

168
00:04:54,320 --> 00:04:57,840
that part is easy and it's actually

169
00:04:56,000 --> 00:04:59,600
worked for years it's hooking them up

170
00:04:57,840 --> 00:05:01,919
together that's the hard part

171
00:04:59,600 --> 00:05:03,680
what slippy does is send button presses

172
00:05:01,919 --> 00:05:06,479
called pads for short

173
00:05:03,680 --> 00:05:08,240
short for game pads one of these things

174
00:05:06,479 --> 00:05:09,120
out over the internet to the other

175
00:05:08,240 --> 00:05:11,039
player

176
00:05:09,120 --> 00:05:12,240
so when you press the a button the

177
00:05:11,039 --> 00:05:13,520
button presses

178
00:05:12,240 --> 00:05:15,520
sent out over the internet and

179
00:05:13,520 --> 00:05:17,039
interpreted on the other end as if the

180
00:05:15,520 --> 00:05:18,479
player were sitting there

181
00:05:17,039 --> 00:05:20,639
right next to you plugged into your

182
00:05:18,479 --> 00:05:23,440
console so it's actually not so much an

183
00:05:20,639 --> 00:05:23,759
online gameplay system as much as it is

184
00:05:23,440 --> 00:05:26,000
an

185
00:05:23,759 --> 00:05:27,120
internet connected virtual controller

186
00:05:26,000 --> 00:05:28,639
system

187
00:05:27,120 --> 00:05:30,880
so some things to keep in mind here as

188
00:05:28,639 --> 00:05:32,400
we go forward are that games of online

189
00:05:30,880 --> 00:05:34,240
melee are peer-to-peer

190
00:05:32,400 --> 00:05:36,560
um there's no centralized server

191
00:05:34,240 --> 00:05:37,120
involved and the only communication back

192
00:05:36,560 --> 00:05:40,639
and forth

193
00:05:37,120 --> 00:05:42,400
is pad data these button presses

194
00:05:40,639 --> 00:05:44,080
another critical component to make all

195
00:05:42,400 --> 00:05:45,520
this work and one that was a major

196
00:05:44,080 --> 00:05:48,240
source of engineering effort by

197
00:05:45,520 --> 00:05:49,919
fizzy was to ensure that the gameplay

198
00:05:48,240 --> 00:05:52,080
itself is deterministic

199
00:05:49,919 --> 00:05:54,400
that means given a series of button

200
00:05:52,080 --> 00:05:56,960
presses the game has to behave

201
00:05:54,400 --> 00:05:58,400
the same way every single time if this

202
00:05:56,960 --> 00:05:59,440
isn't true then the two players

203
00:05:58,400 --> 00:06:01,599
desynchronize

204
00:05:59,440 --> 00:06:03,600
that means you start to play two

205
00:06:01,600 --> 00:06:04,400
different games of melee on each end of

206
00:06:03,600 --> 00:06:07,199
the internet

207
00:06:04,400 --> 00:06:08,318
rather than one synchronized one how

208
00:06:07,199 --> 00:06:10,639
could that happen

209
00:06:08,319 --> 00:06:12,720
let me give you an example the character

210
00:06:10,639 --> 00:06:13,600
luigi has this move called the luigi's

211
00:06:12,720 --> 00:06:15,600
cyclone

212
00:06:13,600 --> 00:06:17,919
when you press down b while in the air

213
00:06:15,600 --> 00:06:19,440
luigi fly upwards helping him recover

214
00:06:17,919 --> 00:06:22,000
while offstage

215
00:06:19,440 --> 00:06:23,039
but only if the downbeat is charged to

216
00:06:22,000 --> 00:06:24,960
keep players from just

217
00:06:23,039 --> 00:06:26,479
using the move over and over again and

218
00:06:24,960 --> 00:06:27,198
just kind of flying around in the air

219
00:06:26,479 --> 00:06:28,719
indefinitely

220
00:06:27,199 --> 00:06:30,800
you have to perform the move once on

221
00:06:28,720 --> 00:06:33,120
ground in order to charge it

222
00:06:30,800 --> 00:06:34,560
if you do it uncharged luigi just falls

223
00:06:33,120 --> 00:06:36,479
like a rock

224
00:06:34,560 --> 00:06:38,080
so the game has a variable in memory

225
00:06:36,479 --> 00:06:38,318
that keeps track of whether luigi's down

226
00:06:38,080 --> 00:06:40,960
b

227
00:06:38,319 --> 00:06:42,080
is charged or not the thing is when you

228
00:06:40,960 --> 00:06:43,599
first start a match

229
00:06:42,080 --> 00:06:46,159
the game fails to initialize this

230
00:06:43,600 --> 00:06:47,759
variable to zero it starts out charged

231
00:06:46,160 --> 00:06:49,840
or uncharged depending on the

232
00:06:47,759 --> 00:06:51,360
random contents of this uninitialized

233
00:06:49,840 --> 00:06:52,880
ram

234
00:06:51,360 --> 00:06:54,400
so if you're playing a game with luigi

235
00:06:52,880 --> 00:06:54,880
and you press down b at the start of a

236
00:06:54,400 --> 00:06:56,719
game

237
00:06:54,880 --> 00:06:57,919
you might go flying upwards in the air

238
00:06:56,720 --> 00:06:59,759
on your screen

239
00:06:57,919 --> 00:07:01,280
but on your opponent's screen you could

240
00:06:59,759 --> 00:07:03,199
fall downwards

241
00:07:01,280 --> 00:07:05,119
this is called a dsync since you've

242
00:07:03,199 --> 00:07:06,960
stopped playing one synchronized game of

243
00:07:05,120 --> 00:07:07,840
melee over the internet and now playing

244
00:07:06,960 --> 00:07:10,080
two different

245
00:07:07,840 --> 00:07:11,119
d synchronized games on two different

246
00:07:10,080 --> 00:07:13,599
machines

247
00:07:11,120 --> 00:07:15,440
so luigi's cyclone had to be modified to

248
00:07:13,599 --> 00:07:16,240
never start the game out with a charged

249
00:07:15,440 --> 00:07:18,240
downbeat

250
00:07:16,240 --> 00:07:20,160
sorry luigi players and this is just one

251
00:07:18,240 --> 00:07:23,680
of the many dozens of these desyncs that

252
00:07:20,160 --> 00:07:25,680
slippy's had to deal with over the years

253
00:07:23,680 --> 00:07:27,520
okay so this is where the first bug

254
00:07:25,680 --> 00:07:29,599
starts to come in one that i call

255
00:07:27,520 --> 00:07:31,359
stealing a password through interpretive

256
00:07:29,599 --> 00:07:33,919
dance which by the way

257
00:07:31,360 --> 00:07:36,160
is the second coolest data exfiltration

258
00:07:33,919 --> 00:07:37,840
mechanism that i've built over the years

259
00:07:36,160 --> 00:07:39,840
i can't talk about numbers one through

260
00:07:37,840 --> 00:07:41,119
three but i digress

261
00:07:39,840 --> 00:07:42,560
the the thing that makes slippy's

262
00:07:41,120 --> 00:07:44,240
netcode different and better than

263
00:07:42,560 --> 00:07:46,639
previous netflix implementations

264
00:07:44,240 --> 00:07:48,400
is it uses a rollback system the whole

265
00:07:46,639 --> 00:07:50,240
details on how this works is kind of

266
00:07:48,400 --> 00:07:50,799
complex and i won't totally get into it

267
00:07:50,240 --> 00:07:52,560
here

268
00:07:50,800 --> 00:07:54,160
but the gist is that it seamlessly

269
00:07:52,560 --> 00:07:56,800
handles network lag spikes

270
00:07:54,160 --> 00:07:57,680
by being able to dynamically revert or

271
00:07:56,800 --> 00:07:59,919
roll back

272
00:07:57,680 --> 00:08:01,680
the state of the game when new game pads

273
00:07:59,919 --> 00:08:04,400
come in from your opponent

274
00:08:01,680 --> 00:08:06,639
so suppose that you're playing a game

275
00:08:04,400 --> 00:08:08,719
and then a network lag spike happens

276
00:08:06,639 --> 00:08:10,319
so it's time to process the next frame

277
00:08:08,720 --> 00:08:11,759
of the game but you haven't actually

278
00:08:10,319 --> 00:08:14,080
received the pad

279
00:08:11,759 --> 00:08:15,199
data for your opponent yet how should

280
00:08:14,080 --> 00:08:17,840
you proceed

281
00:08:15,199 --> 00:08:18,639
two ways of handling this are one the

282
00:08:17,840 --> 00:08:20,239
delay

283
00:08:18,639 --> 00:08:22,080
halt the entire game until the

284
00:08:20,240 --> 00:08:24,080
opponent's gamepad gets there

285
00:08:22,080 --> 00:08:26,240
this produces a jarring effect as the

286
00:08:24,080 --> 00:08:26,960
game constantly stops and then starts

287
00:08:26,240 --> 00:08:29,199
again

288
00:08:26,960 --> 00:08:30,719
every time there's a tiny network lag

289
00:08:29,199 --> 00:08:32,959
spike and in practice

290
00:08:30,720 --> 00:08:34,640
it's miserable to play a tiny micro

291
00:08:32,958 --> 00:08:35,679
delays happen constantly throughout the

292
00:08:34,640 --> 00:08:38,559
course of the match

293
00:08:35,679 --> 00:08:40,079
just making it awful strategy number two

294
00:08:38,559 --> 00:08:42,718
is to just keep going

295
00:08:40,080 --> 00:08:44,480
and then roll back later so uh what you

296
00:08:42,719 --> 00:08:45,040
do is you make an assumption about what

297
00:08:44,480 --> 00:08:47,600
the game

298
00:08:45,040 --> 00:08:48,480
uh the opponent's gamepad is going to

299
00:08:47,600 --> 00:08:50,080
likely be

300
00:08:48,480 --> 00:08:51,680
basically just assume that they will

301
00:08:50,080 --> 00:08:53,600
keep pressing the same buttons they

302
00:08:51,680 --> 00:08:55,760
pressed from the last frame

303
00:08:53,600 --> 00:08:57,440
most of the time that's going to be true

304
00:08:55,760 --> 00:09:00,000
and if your guess turns out to be wrong

305
00:08:57,440 --> 00:09:01,519
then you roll back to an earlier state

306
00:09:00,000 --> 00:09:03,040
and then stick the correct the now

307
00:09:01,519 --> 00:09:05,200
correct inputs in there

308
00:09:03,040 --> 00:09:06,399
fast forwarding it up to the present i

309
00:09:05,200 --> 00:09:07,680
know that's a lot to take in

310
00:09:06,399 --> 00:09:09,839
but the end result is that the game

311
00:09:07,680 --> 00:09:11,519
never freezes when there's a network lag

312
00:09:09,839 --> 00:09:13,360
it provides a buttery smooth experience

313
00:09:11,519 --> 00:09:14,720
that frankly just seems like magic

314
00:09:13,360 --> 00:09:16,800
but let's dig further into how this

315
00:09:14,720 --> 00:09:18,480
works at the networking level though

316
00:09:16,800 --> 00:09:19,839
because this whole system is set up to

317
00:09:18,480 --> 00:09:21,920
keep latency as low

318
00:09:19,839 --> 00:09:23,279
as possible as physically possible

319
00:09:21,920 --> 00:09:25,599
between the two players

320
00:09:23,279 --> 00:09:27,120
we can't just use a tcp connection the

321
00:09:25,600 --> 00:09:27,760
fastest way to send packets back and

322
00:09:27,120 --> 00:09:31,040
forth

323
00:09:27,760 --> 00:09:32,720
is raw udp packets in practice melee

324
00:09:31,040 --> 00:09:34,959
uses the enet library for this

325
00:09:32,720 --> 00:09:36,000
and more on e-net later but for now you

326
00:09:34,959 --> 00:09:39,119
can just imagine it as

327
00:09:36,000 --> 00:09:40,800
raw udp packets which it basically is so

328
00:09:39,120 --> 00:09:42,000
this means that each pad is sent out

329
00:09:40,800 --> 00:09:44,399
over the internet

330
00:09:42,000 --> 00:09:46,000
uh also has to come labeled with the

331
00:09:44,399 --> 00:09:47,040
frame in which it's supposed to meant to

332
00:09:46,000 --> 00:09:49,920
apply to

333
00:09:47,040 --> 00:09:51,199
you see udp packets can get lost and

334
00:09:49,920 --> 00:09:52,880
just never arrive

335
00:09:51,200 --> 00:09:54,480
they can come in out of order and just

336
00:09:52,880 --> 00:09:57,360
be routed around the internet in

337
00:09:54,480 --> 00:09:58,240
weird ways so the payload itself has to

338
00:09:57,360 --> 00:10:00,800
describe

339
00:09:58,240 --> 00:10:02,320
how it's meant to be used so your

340
00:10:00,800 --> 00:10:04,719
machine might say something like

341
00:10:02,320 --> 00:10:06,480
hey this is frame number 17 i've pressed

342
00:10:04,720 --> 00:10:07,279
the b button and down on the control

343
00:10:06,480 --> 00:10:09,360
stick

344
00:10:07,279 --> 00:10:10,560
serialize that into some compressed like

345
00:10:09,360 --> 00:10:12,720
binary form of course

346
00:10:10,560 --> 00:10:14,319
and send it out over to your opponent

347
00:10:12,720 --> 00:10:15,839
makes sense

348
00:10:14,320 --> 00:10:17,279
the last little wrinkle in how this

349
00:10:15,839 --> 00:10:19,120
works that you need to understand is an

350
00:10:17,279 --> 00:10:21,360
important efficiency hack

351
00:10:19,120 --> 00:10:24,160
each pad is also sent along with every

352
00:10:21,360 --> 00:10:25,760
other unacknowledged previous pad

353
00:10:24,160 --> 00:10:27,920
melee pad data has a system of

354
00:10:25,760 --> 00:10:29,200
acknowledging receipt data kind of like

355
00:10:27,920 --> 00:10:31,839
how tcp does it

356
00:10:29,200 --> 00:10:33,920
but unlike how tcp would we can't afford

357
00:10:31,839 --> 00:10:35,120
to just sit around and wait on pads when

358
00:10:33,920 --> 00:10:38,000
it's time to send them

359
00:10:35,120 --> 00:10:38,880
so suppose we press a button and send

360
00:10:38,000 --> 00:10:40,640
the pad out

361
00:10:38,880 --> 00:10:43,680
we're playing a game with an opponent

362
00:10:40,640 --> 00:10:46,720
then 16.66 milliseconds go by the

363
00:10:43,680 --> 00:10:48,319
duration of one frame of the game and

364
00:10:46,720 --> 00:10:51,120
it's time to send our next

365
00:10:48,320 --> 00:10:52,880
pad out to the opponent but wait we

366
00:10:51,120 --> 00:10:54,880
never got an acknowledgement that the

367
00:10:52,880 --> 00:10:56,720
last pad was received

368
00:10:54,880 --> 00:10:57,920
it might have gotten lost out on the

369
00:10:56,720 --> 00:11:00,240
open internet

370
00:10:57,920 --> 00:11:01,839
we need to resend it so what we do is we

371
00:11:00,240 --> 00:11:03,920
package the previous pad

372
00:11:01,839 --> 00:11:06,160
along with this one setting them both

373
00:11:03,920 --> 00:11:08,319
together in one packet

374
00:11:06,160 --> 00:11:10,000
this can actually keep accumulating if

375
00:11:08,320 --> 00:11:12,160
pads are never acknowledged

376
00:11:10,000 --> 00:11:14,320
in practice up to a maximum of seven

377
00:11:12,160 --> 00:11:16,160
frames behind

378
00:11:14,320 --> 00:11:18,000
okay so let's take a peek at the code

379
00:11:16,160 --> 00:11:18,800
responsible for reading pad data now

380
00:11:18,000 --> 00:11:21,839
that we know how

381
00:11:18,800 --> 00:11:24,000
all this works this is the on data

382
00:11:21,839 --> 00:11:26,160
function of the slippy netplay class

383
00:11:24,000 --> 00:11:28,240
this is what gets hit and reads the raw

384
00:11:26,160 --> 00:11:30,880
data packets when they come in

385
00:11:28,240 --> 00:11:32,240
so well the code here does is it peels

386
00:11:30,880 --> 00:11:33,439
off some initial values like this

387
00:11:32,240 --> 00:11:35,360
message id here

388
00:11:33,440 --> 00:11:38,480
that tells us what kind of packet this

389
00:11:35,360 --> 00:11:40,160
is and then the the packets frame index

390
00:11:38,480 --> 00:11:41,680
there's some timing logic that isn't

391
00:11:40,160 --> 00:11:43,120
particularly relevant to us

392
00:11:41,680 --> 00:11:44,800
and then if we scroll down just a little

393
00:11:43,120 --> 00:11:46,560
bit we loop over the pads

394
00:11:44,800 --> 00:11:49,040
because again there's potentially

395
00:11:46,560 --> 00:11:51,599
multiple pads inside of this packet

396
00:11:49,040 --> 00:11:53,360
in this section right here the code

397
00:11:51,600 --> 00:11:55,279
queues up the pads that we just read

398
00:11:53,360 --> 00:11:57,279
and sends them to the game as button

399
00:11:55,279 --> 00:11:58,959
press inputs and then sends out an

400
00:11:57,279 --> 00:12:00,560
acknowledged message that we receive

401
00:11:58,959 --> 00:12:03,518
this packet

402
00:12:00,560 --> 00:12:06,160
okay if you want to pause try to see if

403
00:12:03,519 --> 00:12:08,560
you can spot the bug yourself

404
00:12:06,160 --> 00:12:10,000
okay so this packet data variable right

405
00:12:08,560 --> 00:12:12,479
here is the raw pointer to

406
00:12:10,000 --> 00:12:13,920
the memory contents inside the packet we

407
00:12:12,480 --> 00:12:16,480
then iterate over this data

408
00:12:13,920 --> 00:12:17,199
inputs to copy number of times reading

409
00:12:16,480 --> 00:12:19,600
pad data

410
00:12:17,200 --> 00:12:21,600
at the from the buffer at each step the

411
00:12:19,600 --> 00:12:24,160
head frame variable here is just the

412
00:12:21,600 --> 00:12:25,920
last received frame from the opponent

413
00:12:24,160 --> 00:12:27,920
the thing that we're expecting

414
00:12:25,920 --> 00:12:29,920
so for instance a head frame here might

415
00:12:27,920 --> 00:12:30,240
be 10 that means the last packet we got

416
00:12:29,920 --> 00:12:32,479
in

417
00:12:30,240 --> 00:12:34,480
was for frame 10 and now we're expecting

418
00:12:32,480 --> 00:12:35,600
frame 11 or perhaps something higher

419
00:12:34,480 --> 00:12:37,760
because again there could be

420
00:12:35,600 --> 00:12:39,200
multiple pads here so if the frame

421
00:12:37,760 --> 00:12:41,360
variable were 12

422
00:12:39,200 --> 00:12:42,720
we'd loop over the packet twice and read

423
00:12:41,360 --> 00:12:44,480
two pads from the buffer

424
00:12:42,720 --> 00:12:46,240
send them to the game acknowledge them

425
00:12:44,480 --> 00:12:48,320
and be finished

426
00:12:46,240 --> 00:12:50,240
critically though the logic here doesn't

427
00:12:48,320 --> 00:12:52,000
check that the packet actually contains

428
00:12:50,240 --> 00:12:53,760
the data that it claims to

429
00:12:52,000 --> 00:12:55,200
the opponents send a packet with a frame

430
00:12:53,760 --> 00:12:57,279
number of anything

431
00:12:55,200 --> 00:12:58,480
so if you insert some huge value here

432
00:12:57,279 --> 00:13:00,720
something in the billions

433
00:12:58,480 --> 00:13:02,000
your opponent goes haywire reading data

434
00:13:00,720 --> 00:13:02,480
out of the boundaries of the packet

435
00:13:02,000 --> 00:13:04,160
buffer

436
00:13:02,480 --> 00:13:06,000
until it inevitably goes out of bounds

437
00:13:04,160 --> 00:13:09,279
entirely causes a seg fault

438
00:13:06,000 --> 00:13:10,880
and crashes so let's do that

439
00:13:09,279 --> 00:13:12,720
what i built right here is a modified

440
00:13:10,880 --> 00:13:13,920
version of the emulator that will send a

441
00:13:12,720 --> 00:13:15,920
packet to my opponent

442
00:13:13,920 --> 00:13:18,000
claiming to be framed 1 billion anytime

443
00:13:15,920 --> 00:13:19,439
i press up on the d-pad

444
00:13:18,000 --> 00:13:21,440
what happens when i do that is my

445
00:13:19,440 --> 00:13:21,760
opponent's computer sees a packet for

446
00:13:21,440 --> 00:13:23,519
frame

447
00:13:21,760 --> 00:13:24,800
1 billion and assumes that it must

448
00:13:23,519 --> 00:13:28,480
therefore contain

449
00:13:24,800 --> 00:13:31,439
999 million 999 000-ish

450
00:13:28,480 --> 00:13:32,480
pads so it tries to read that many pads

451
00:13:31,440 --> 00:13:35,200
from the buffer

452
00:13:32,480 --> 00:13:48,320
running way over causing a crash check

453
00:13:35,200 --> 00:13:49,839
it out

454
00:13:48,320 --> 00:13:52,320
segfaulting your opponent's game at will

455
00:13:49,839 --> 00:13:53,839
is pretty cool but we can do better

456
00:13:52,320 --> 00:13:55,680
uh what's happening here is a read

457
00:13:53,839 --> 00:13:57,600
overflow into heap data

458
00:13:55,680 --> 00:13:59,519
in particular remember that the process

459
00:13:57,600 --> 00:14:00,800
is trying to read controller pad data

460
00:13:59,519 --> 00:14:02,720
from that buffer

461
00:14:00,800 --> 00:14:03,839
so if we give it a goldilocks overflow

462
00:14:02,720 --> 00:14:06,160
that's not so

463
00:14:03,839 --> 00:14:08,160
long as to seg fault like before we can

464
00:14:06,160 --> 00:14:09,920
trick our opponent into reading random

465
00:14:08,160 --> 00:14:12,160
data off the heap interpreting it as

466
00:14:09,920 --> 00:14:13,680
our own button presses in the game we're

467
00:14:12,160 --> 00:14:15,839
playing together

468
00:14:13,680 --> 00:14:17,439
also in the slippy ecosystem each player

469
00:14:15,839 --> 00:14:19,040
has their own play key

470
00:14:17,440 --> 00:14:21,920
which is basically their account's

471
00:14:19,040 --> 00:14:22,959
password you log into the slippy system

472
00:14:21,920 --> 00:14:24,639
using that key

473
00:14:22,959 --> 00:14:26,079
and if someone were to steal it you

474
00:14:24,639 --> 00:14:28,320
could play under their account

475
00:14:26,079 --> 00:14:29,839
this is read from file when you first

476
00:14:28,320 --> 00:14:30,399
start up the game and to store it onto

477
00:14:29,839 --> 00:14:32,639
the heap

478
00:14:30,399 --> 00:14:34,160
so the opponent's password is basically

479
00:14:32,639 --> 00:14:34,800
there lurking around somewhere on the

480
00:14:34,160 --> 00:14:36,480
heap

481
00:14:34,800 --> 00:14:38,240
waiting to be read so what i'm going to

482
00:14:36,480 --> 00:14:39,279
do here is modify our payload from

483
00:14:38,240 --> 00:14:41,360
before

484
00:14:39,279 --> 00:14:43,040
rather than set the frame index to 1

485
00:14:41,360 --> 00:14:45,279
billion we're just going to increment it

486
00:14:43,040 --> 00:14:48,079
by 10. that means the opponent will read

487
00:14:45,279 --> 00:14:49,199
only nine pads out of bounds keeping it

488
00:14:48,079 --> 00:14:52,160
from seg-faulting

489
00:14:49,199 --> 00:14:53,920
let's see what this looks like here we

490
00:14:52,160 --> 00:14:54,399
are playing an online game of melee

491
00:14:53,920 --> 00:14:56,079
again

492
00:14:54,399 --> 00:14:58,079
the attacker screen is on the right and

493
00:14:56,079 --> 00:14:58,719
the victim screen is on the left every

494
00:14:58,079 --> 00:15:00,239
time i press

495
00:14:58,720 --> 00:15:02,560
up on the d-pad here the payload

496
00:15:00,240 --> 00:15:04,480
launches so as you can see

497
00:15:02,560 --> 00:15:05,920
on the right my character taunts which

498
00:15:04,480 --> 00:15:08,399
is what's supposed to happen

499
00:15:05,920 --> 00:15:09,360
but on the left something random happens

500
00:15:08,399 --> 00:15:11,680
each time

501
00:15:09,360 --> 00:15:13,600
but it's not actually random at all the

502
00:15:11,680 --> 00:15:14,319
actions it takes are arbitrary heap

503
00:15:13,600 --> 00:15:17,360
contents

504
00:15:14,320 --> 00:15:19,360
interpreted as pad data as you can see

505
00:15:17,360 --> 00:15:21,440
here also we've desynchronized

506
00:15:19,360 --> 00:15:22,880
the game is different on each screen but

507
00:15:21,440 --> 00:15:27,839
we're still connected to each other and

508
00:15:22,880 --> 00:15:27,839
sending pads back and forth

509
00:15:28,000 --> 00:15:31,680
all we need now is a way to exfiltrate

510
00:15:29,839 --> 00:15:33,199
this data we need a way to look at those

511
00:15:31,680 --> 00:15:34,638
random movements our character is making

512
00:15:33,199 --> 00:15:36,719
on the opponent's screen

513
00:15:34,639 --> 00:15:38,720
but this is kind of tricky the game is

514
00:15:36,720 --> 00:15:40,480
desynchronized and we can't directly see

515
00:15:38,720 --> 00:15:42,959
our movements our characters taking

516
00:15:40,480 --> 00:15:43,600
on our opponent's screen so while our

517
00:15:42,959 --> 00:15:45,359
character is

518
00:15:43,600 --> 00:15:47,279
moving around randomly on the opponent's

519
00:15:45,360 --> 00:15:48,079
screen disclosing sensitive data in the

520
00:15:47,279 --> 00:15:50,399
process

521
00:15:48,079 --> 00:15:52,560
we can't see it our screen just shows

522
00:15:50,399 --> 00:15:54,880
the character is acting normally

523
00:15:52,560 --> 00:15:55,680
so how do we get the loot there's two

524
00:15:54,880 --> 00:15:59,600
ways

525
00:15:55,680 --> 00:15:59,599
uh first the easy way

526
00:15:59,839 --> 00:16:03,519
remember when i said that i was working

527
00:16:01,519 --> 00:16:04,720
on slippy to put in some features that

528
00:16:03,519 --> 00:16:06,399
smashbot would need

529
00:16:04,720 --> 00:16:08,800
well one of those features was a

530
00:16:06,399 --> 00:16:09,279
spectator mode in order for smashbot to

531
00:16:08,800 --> 00:16:11,920
work

532
00:16:09,279 --> 00:16:12,399
it needs to see the game live as it's

533
00:16:11,920 --> 00:16:14,639
running

534
00:16:12,399 --> 00:16:16,399
which didn't exist at the time this

535
00:16:14,639 --> 00:16:18,480
eventually became the spectator server

536
00:16:16,399 --> 00:16:19,920
that melee tournaments use to broadcast

537
00:16:18,480 --> 00:16:22,639
online games

538
00:16:19,920 --> 00:16:24,399
so the easy way to exploit this would be

539
00:16:22,639 --> 00:16:25,839
to target someone who is broadcasting

540
00:16:24,399 --> 00:16:26,959
such as someone who's playing the

541
00:16:25,839 --> 00:16:28,800
tournament match

542
00:16:26,959 --> 00:16:30,319
you used to be able to see the full list

543
00:16:28,800 --> 00:16:32,479
of broadcasting users just by

544
00:16:30,320 --> 00:16:33,759
logging in right here but today you can

545
00:16:32,480 --> 00:16:36,079
only spectate a match if

546
00:16:33,759 --> 00:16:37,440
both ends have specifically opted in

547
00:16:36,079 --> 00:16:39,199
good security move

548
00:16:37,440 --> 00:16:41,120
but if you're spectating a game of melee

549
00:16:39,199 --> 00:16:42,800
you're sent the full state of the game

550
00:16:41,120 --> 00:16:44,959
from that player's perspective at each

551
00:16:42,800 --> 00:16:47,439
frame of the game including the raw pad

552
00:16:44,959 --> 00:16:49,119
data that we really want

553
00:16:47,440 --> 00:16:51,440
when the game is finished the spectator

554
00:16:49,120 --> 00:16:52,000
client creates an slp replay file that

555
00:16:51,440 --> 00:16:54,320
contains

556
00:16:52,000 --> 00:16:55,040
all the binary data of the match so we

557
00:16:54,320 --> 00:16:56,959
can just

558
00:16:55,040 --> 00:16:58,959
write a little quick python script here

559
00:16:56,959 --> 00:16:59,758
to pull out all the raw pad buffers from

560
00:16:58,959 --> 00:17:03,279
the game

561
00:16:59,759 --> 00:17:05,679
and throw them into a hex file and

562
00:17:03,279 --> 00:17:06,319
voila random heap contents from your

563
00:17:05,679 --> 00:17:10,559
opponent

564
00:17:06,319 --> 00:17:10,559
own what's this a play key

565
00:17:11,760 --> 00:17:16,720
and then there's the hard way

566
00:17:15,039 --> 00:17:18,480
there's one other way of looking at our

567
00:17:16,720 --> 00:17:20,000
opponent's screen of course

568
00:17:18,480 --> 00:17:21,760
loads of people regularly stream

569
00:17:20,000 --> 00:17:23,199
themselves playing games of melee on

570
00:17:21,760 --> 00:17:25,199
twitch.tv

571
00:17:23,199 --> 00:17:26,640
basically every tournament professional

572
00:17:25,199 --> 00:17:28,799
and amateur players stream their

573
00:17:26,640 --> 00:17:31,039
perspective of playing through the event

574
00:17:28,799 --> 00:17:32,639
for others to watch so if we play

575
00:17:31,039 --> 00:17:33,200
against someone publicly streaming like

576
00:17:32,640 --> 00:17:35,840
this

577
00:17:33,200 --> 00:17:36,880
we can launch our exploit like before

578
00:17:35,840 --> 00:17:38,559
only this time

579
00:17:36,880 --> 00:17:40,799
we don't have access to the raw

580
00:17:38,559 --> 00:17:42,399
underlying binary pad buffers

581
00:17:40,799 --> 00:17:44,559
instead we have to infer them from the

582
00:17:42,400 --> 00:17:46,400
video game actions taking place

583
00:17:44,559 --> 00:17:47,678
we have to interpret the interpretive

584
00:17:46,400 --> 00:17:51,280
dance taking place

585
00:17:47,679 --> 00:17:52,320
right on screen each pad takes eight

586
00:17:51,280 --> 00:17:54,480
bytes of memory

587
00:17:52,320 --> 00:17:56,399
they're stored like this there's two

588
00:17:54,480 --> 00:17:59,280
bytes for the digital buttons a

589
00:17:56,400 --> 00:18:00,000
b x y star et cetera there's two bytes

590
00:17:59,280 --> 00:18:03,120
for the two

591
00:18:00,000 --> 00:18:04,080
analog sticks the control sticks uh and

592
00:18:03,120 --> 00:18:06,639
the c sticks

593
00:18:04,080 --> 00:18:08,799
x and y positions then two bytes for the

594
00:18:06,640 --> 00:18:10,720
l and r analog triggers

595
00:18:08,799 --> 00:18:12,799
so each action that takes place each

596
00:18:10,720 --> 00:18:15,280
frame tells us about the eight bytes

597
00:18:12,799 --> 00:18:16,480
in memory there so looking back at our

598
00:18:15,280 --> 00:18:18,960
example earlier

599
00:18:16,480 --> 00:18:20,480
right here our character pauses the game

600
00:18:18,960 --> 00:18:21,360
that means the start button must have

601
00:18:20,480 --> 00:18:22,720
been pressed

602
00:18:21,360 --> 00:18:25,439
but we don't know anything about the

603
00:18:22,720 --> 00:18:26,480
other buttons shortly after a while in

604
00:18:25,440 --> 00:18:28,559
the pause screen

605
00:18:26,480 --> 00:18:30,320
the camera doesn't move that means

606
00:18:28,559 --> 00:18:31,918
during these frames the control stick

607
00:18:30,320 --> 00:18:32,320
and the c-stick weren't being pressed

608
00:18:31,919 --> 00:18:34,080
since

609
00:18:32,320 --> 00:18:35,600
that would move the camera so we know

610
00:18:34,080 --> 00:18:38,799
those were zero

611
00:18:35,600 --> 00:18:39,678
when we unpause we the start button must

612
00:18:38,799 --> 00:18:41,760
have been pressed

613
00:18:39,679 --> 00:18:43,039
followed by a neutral b attack which

614
00:18:41,760 --> 00:18:45,120
means the sticks were

615
00:18:43,039 --> 00:18:47,280
zero again and the b button was pressed

616
00:18:45,120 --> 00:18:49,678
but not any other buttons

617
00:18:47,280 --> 00:18:51,840
so yeah there's not a great way to write

618
00:18:49,679 --> 00:18:53,760
a tool to automate this process

619
00:18:51,840 --> 00:18:55,520
since you need to go frame by frame

620
00:18:53,760 --> 00:18:57,840
through the video on screen

621
00:18:55,520 --> 00:19:00,320
but the data is right there dancing in

622
00:18:57,840 --> 00:19:00,320
front of you

623
00:19:01,760 --> 00:19:04,879
so this is a funny story we fixed this

624
00:19:04,320 --> 00:19:07,600
bug

625
00:19:04,880 --> 00:19:09,200
i wrote some code right here that checks

626
00:19:07,600 --> 00:19:11,120
incoming packets to make sure that they

627
00:19:09,200 --> 00:19:11,919
actually contain the data that it claims

628
00:19:11,120 --> 00:19:13,678
to

629
00:19:11,919 --> 00:19:15,840
simple bounce checking really nothing

630
00:19:13,679 --> 00:19:17,200
fancy i sent out a pull request to the

631
00:19:15,840 --> 00:19:19,520
project for this code

632
00:19:17,200 --> 00:19:22,559
it was merged in and shortly after

633
00:19:19,520 --> 00:19:25,440
pushed out to users in the next release

634
00:19:22,559 --> 00:19:26,879
and then everything broke within minutes

635
00:19:25,440 --> 00:19:28,320
of releasing out to the world we got

636
00:19:26,880 --> 00:19:29,039
widespread reports of games

637
00:19:28,320 --> 00:19:31,120
disconnecting

638
00:19:29,039 --> 00:19:32,960
right when you start we tracked it down

639
00:19:31,120 --> 00:19:34,399
and lo and behold it was my code that

640
00:19:32,960 --> 00:19:37,360
was causing the disconnect

641
00:19:34,400 --> 00:19:38,880
i was astonished the bounce checking was

642
00:19:37,360 --> 00:19:41,199
so simple on the code how could i have

643
00:19:38,880 --> 00:19:42,880
screwed that up

644
00:19:41,200 --> 00:19:44,720
so i dug into it further and discovered

645
00:19:42,880 --> 00:19:46,720
something funny it turns out that my

646
00:19:44,720 --> 00:19:48,480
code was working just fine

647
00:19:46,720 --> 00:19:50,080
what was happening was that when games

648
00:19:48,480 --> 00:19:50,960
first start they don't start out by

649
00:19:50,080 --> 00:19:53,199
sending frame

650
00:19:50,960 --> 00:19:55,120
one the game has a local packet buffer

651
00:19:53,200 --> 00:19:55,600
which i'm not going to go into depth on

652
00:19:55,120 --> 00:19:57,760
here

653
00:19:55,600 --> 00:19:59,600
but it causes the game to start at frame

654
00:19:57,760 --> 00:20:01,440
three or four typically

655
00:19:59,600 --> 00:20:03,120
so whenever a new game would start the

656
00:20:01,440 --> 00:20:04,000
very first frame that it would send out

657
00:20:03,120 --> 00:20:06,799
would be for frame

658
00:20:04,000 --> 00:20:08,960
three but only contain one pad that

659
00:20:06,799 --> 00:20:11,760
means the receiver was expecting it to

660
00:20:08,960 --> 00:20:13,280
contain three pads so my bounce checking

661
00:20:11,760 --> 00:20:14,720
code correctly identified that this

662
00:20:13,280 --> 00:20:16,799
would overflow the packet buffer

663
00:20:14,720 --> 00:20:18,080
and toss it out disconnecting the game

664
00:20:16,799 --> 00:20:19,679
in the process

665
00:20:18,080 --> 00:20:21,120
but this means that this was normal

666
00:20:19,679 --> 00:20:23,679
behavior for sleepy games

667
00:20:21,120 --> 00:20:24,879
almost every game of online rollback uh

668
00:20:23,679 --> 00:20:26,720
netplay for melee

669
00:20:24,880 --> 00:20:28,320
up until this point started out by

670
00:20:26,720 --> 00:20:31,280
overflowing the packet buffer

671
00:20:28,320 --> 00:20:33,039
and reading random heap data as pads but

672
00:20:31,280 --> 00:20:35,918
nobody noticed this up until

673
00:20:33,039 --> 00:20:36,799
uh now because for the first 180ish

674
00:20:35,919 --> 00:20:39,039
frames

675
00:20:36,799 --> 00:20:40,400
uh of the game you can't move you're in

676
00:20:39,039 --> 00:20:40,960
this kind of state where you're waiting

677
00:20:40,400 --> 00:20:43,600
for the

678
00:20:40,960 --> 00:20:45,039
ready go sign to disappear uh so the

679
00:20:43,600 --> 00:20:46,480
game is technically started you're

680
00:20:45,039 --> 00:20:48,320
sending pads back and forth but your

681
00:20:46,480 --> 00:20:50,159
controller doesn't move your character

682
00:20:48,320 --> 00:20:51,520
so the random heap data doesn't cause a

683
00:20:50,159 --> 00:20:53,280
desync

684
00:20:51,520 --> 00:20:54,559
but the overflow does happen and the

685
00:20:53,280 --> 00:20:56,240
data is there

686
00:20:54,559 --> 00:20:59,440
after every game of netplay the game

687
00:20:56,240 --> 00:21:01,200
stores an slp replay file of your match

688
00:20:59,440 --> 00:21:02,720
just like before this contains the raw

689
00:21:01,200 --> 00:21:04,159
pad buffers at each frame

690
00:21:02,720 --> 00:21:06,000
and people like to share these files

691
00:21:04,159 --> 00:21:07,679
around to like show cool matches to

692
00:21:06,000 --> 00:21:10,080
their friends and stuff like that

693
00:21:07,679 --> 00:21:12,240
but each of these files now contain

694
00:21:10,080 --> 00:21:15,120
little bits of potentially sensitive

695
00:21:12,240 --> 00:21:17,120
fragments of your heap so i'm working on

696
00:21:15,120 --> 00:21:19,199
making a scrubbing tool to zero out any

697
00:21:17,120 --> 00:21:20,959
pad data at the start of a replay file

698
00:21:19,200 --> 00:21:22,480
uh just for the first bunch of frames

699
00:21:20,960 --> 00:21:24,400
that way you can run it against your

700
00:21:22,480 --> 00:21:25,120
replay files to make them safe to share

701
00:21:24,400 --> 00:21:27,200
again

702
00:21:25,120 --> 00:21:28,158
also the bounce checking code got

703
00:21:27,200 --> 00:21:30,400
properly fixed

704
00:21:28,159 --> 00:21:32,240
so as to make clients always start

705
00:21:30,400 --> 00:21:36,159
setting from frame one

706
00:21:32,240 --> 00:21:36,159
and that's where the bug stands today

707
00:21:38,320 --> 00:21:41,918
let's circle back into something that i

708
00:21:39,760 --> 00:21:43,760
mentioned earlier the e-net library that

709
00:21:41,919 --> 00:21:44,159
melee uses for sending pads back and

710
00:21:43,760 --> 00:21:46,720
forth

711
00:21:44,159 --> 00:21:48,559
during games last time i talked about it

712
00:21:46,720 --> 00:21:49,679
as raw udp packets but that's not

713
00:21:48,559 --> 00:21:52,158
completely true

714
00:21:49,679 --> 00:21:53,840
let's dig into that first you've got to

715
00:21:52,159 --> 00:21:56,320
understand what e-net does and

716
00:21:53,840 --> 00:21:58,000
just as importantly what it doesn't do

717
00:21:56,320 --> 00:21:59,760
networking is really complicated

718
00:21:58,000 --> 00:22:01,679
and if you let it it'll scope creep way

719
00:21:59,760 --> 00:22:03,520
out of proportion and wind up being an

720
00:22:01,679 --> 00:22:06,080
all-encompassing library that affects

721
00:22:03,520 --> 00:22:07,918
every aspect of the program that use it

722
00:22:06,080 --> 00:22:10,000
so in general enit does actually a great

723
00:22:07,919 --> 00:22:11,520
job of avoiding this trap

724
00:22:10,000 --> 00:22:13,600
it does what it sets out to do and then

725
00:22:11,520 --> 00:22:14,960
stops this is admirable and should be

726
00:22:13,600 --> 00:22:18,158
exactly what you're looking for

727
00:22:14,960 --> 00:22:20,559
in a software library the thing is

728
00:22:18,159 --> 00:22:22,559
games need low latency communication

729
00:22:20,559 --> 00:22:23,280
other metrics of network traffic like

730
00:22:22,559 --> 00:22:26,240
throughput

731
00:22:23,280 --> 00:22:27,678
simply don't matter enet is rather slow

732
00:22:26,240 --> 00:22:28,880
actually if you try sending an entire

733
00:22:27,679 --> 00:22:30,559
gigabyte across

734
00:22:28,880 --> 00:22:32,080
but why would you do that that's not

735
00:22:30,559 --> 00:22:33,760
what it's for uh

736
00:22:32,080 --> 00:22:35,918
it's for sending small pieces of data

737
00:22:33,760 --> 00:22:37,600
like gamepads over the internet with as

738
00:22:35,919 --> 00:22:39,200
little latency as possible with as

739
00:22:37,600 --> 00:22:40,799
little overhead as possible

740
00:22:39,200 --> 00:22:42,159
while maintaining some quality of life

741
00:22:40,799 --> 00:22:43,840
features that you wouldn't want to have

742
00:22:42,159 --> 00:22:45,919
to implement yourself

743
00:22:43,840 --> 00:22:47,439
in particular enet manages the concept

744
00:22:45,919 --> 00:22:49,360
of a connection

745
00:22:47,440 --> 00:22:50,960
despite being in udp which is not

746
00:22:49,360 --> 00:22:53,360
otherwise connection oriented

747
00:22:50,960 --> 00:22:54,159
on its own udp has no connections it's

748
00:22:53,360 --> 00:22:56,080
just individual

749
00:22:54,159 --> 00:22:57,520
packets being sent around with no

750
00:22:56,080 --> 00:22:59,120
guarantees for delivery

751
00:22:57,520 --> 00:23:00,879
so with enet you can tell if the other

752
00:22:59,120 --> 00:23:02,479
end has disconnected from you which is a

753
00:23:00,880 --> 00:23:03,520
thing that games really want to do in

754
00:23:02,480 --> 00:23:05,840
general

755
00:23:03,520 --> 00:23:08,000
it also has an optional reliable mode

756
00:23:05,840 --> 00:23:09,678
that ensures packets actually do arrive

757
00:23:08,000 --> 00:23:11,840
and in the correct order that you sent

758
00:23:09,679 --> 00:23:13,600
them now you might be thinking

759
00:23:11,840 --> 00:23:14,959
why doesn't this guy just use tcp

760
00:23:13,600 --> 00:23:17,039
doesn't he know that tcp

761
00:23:14,960 --> 00:23:19,039
does all that stuff well in a perfect

762
00:23:17,039 --> 00:23:19,840
world where data never gets corrupted in

763
00:23:19,039 --> 00:23:21,600
transit sure

764
00:23:19,840 --> 00:23:22,959
but in that world we wouldn't need

765
00:23:21,600 --> 00:23:24,639
networking protocols

766
00:23:22,960 --> 00:23:26,880
the problem with tcp is how it deals

767
00:23:24,640 --> 00:23:28,720
with a mangled packet tcp waits a

768
00:23:26,880 --> 00:23:31,120
predefined amount of time before

769
00:23:28,720 --> 00:23:33,760
resending any unacknowledged data

770
00:23:31,120 --> 00:23:34,799
and it uses an exponential back off too

771
00:23:33,760 --> 00:23:37,039
so on linux

772
00:23:34,799 --> 00:23:38,000
the first timeout is about uh 200

773
00:23:37,039 --> 00:23:39,520
milliseconds

774
00:23:38,000 --> 00:23:40,960
which means that if you send some data

775
00:23:39,520 --> 00:23:42,400
and it doesn't get acknowledged after

776
00:23:40,960 --> 00:23:45,679
200 milliseconds

777
00:23:42,400 --> 00:23:48,320
it'll resend it 200 milliseconds might

778
00:23:45,679 --> 00:23:51,760
sound fast but melee runs at 60 hertz

779
00:23:48,320 --> 00:23:54,158
meaning a single frame lasts 16.66

780
00:23:51,760 --> 00:23:56,158
milliseconds so if a single pack packet

781
00:23:54,159 --> 00:23:58,240
gets mangled and then needs to be reset

782
00:23:56,159 --> 00:23:59,279
it won't happen for a full 12 frames

783
00:23:58,240 --> 00:24:01,520
that pass by

784
00:23:59,279 --> 00:24:02,480
and if that resend screws up two which

785
00:24:01,520 --> 00:24:04,240
can easily happen

786
00:24:02,480 --> 00:24:06,080
the next reset won't happen for another

787
00:24:04,240 --> 00:24:07,840
400 milliseconds

788
00:24:06,080 --> 00:24:09,600
meanwhile the entire data stream is

789
00:24:07,840 --> 00:24:10,080
ground to a halt while you're waiting

790
00:24:09,600 --> 00:24:12,320
for these

791
00:24:10,080 --> 00:24:13,840
timeouts because tcp has to maintain the

792
00:24:12,320 --> 00:24:15,678
order of the data

793
00:24:13,840 --> 00:24:17,360
so no we don't want to do that if the

794
00:24:15,679 --> 00:24:18,240
pads get lost or mangled we'll just

795
00:24:17,360 --> 00:24:21,279
reset it

796
00:24:18,240 --> 00:24:23,120
next frame like we had before

797
00:24:21,279 --> 00:24:24,720
don't hold up the whole party for it so

798
00:24:23,120 --> 00:24:28,000
if you want low latency communications

799
00:24:24,720 --> 00:24:28,000
tcp is just not for you

800
00:24:29,679 --> 00:24:32,880
okay so like i said enit has this

801
00:24:31,360 --> 00:24:34,639
concept of a connection

802
00:24:32,880 --> 00:24:36,080
established using a three-way handshake

803
00:24:34,640 --> 00:24:37,679
not unlike tcps

804
00:24:36,080 --> 00:24:39,600
and this is where the first e-nut bug

805
00:24:37,679 --> 00:24:41,440
comes in each is small

806
00:24:39,600 --> 00:24:43,840
and that's on purpose it wants to have a

807
00:24:41,440 --> 00:24:46,080
small and predictable memory footprint

808
00:24:43,840 --> 00:24:47,760
e-net doesn't just run on gaming pcs

809
00:24:46,080 --> 00:24:49,760
with gigs of ram to deal with

810
00:24:47,760 --> 00:24:51,039
it has to run on old gaming consoles

811
00:24:49,760 --> 00:24:52,559
like the nintendo wii

812
00:24:51,039 --> 00:24:54,240
and other embedded environments where

813
00:24:52,559 --> 00:24:55,840
memory can be scarce

814
00:24:54,240 --> 00:24:57,279
so what it does is it lets you define

815
00:24:55,840 --> 00:24:58,879
how many peers you want

816
00:24:57,279 --> 00:25:00,720
and then allocates memory for those

817
00:24:58,880 --> 00:25:01,840
peers all at the beginning

818
00:25:00,720 --> 00:25:03,600
so this works pretty well in a

819
00:25:01,840 --> 00:25:04,320
peer-to-peer environment like if you're

820
00:25:03,600 --> 00:25:06,879
playing an

821
00:25:04,320 --> 00:25:07,918
eight-player game you'd assign memory

822
00:25:06,880 --> 00:25:08,880
for seven peers

823
00:25:07,919 --> 00:25:11,120
and then connect to the wall

824
00:25:08,880 --> 00:25:12,960
individually this starts to break down

825
00:25:11,120 --> 00:25:14,639
however once you have a client server

826
00:25:12,960 --> 00:25:17,200
architecture one that can have n

827
00:25:14,640 --> 00:25:18,799
peers for example in the melee ecosystem

828
00:25:17,200 --> 00:25:20,480
there's a matchmaking server that's used

829
00:25:18,799 --> 00:25:22,879
to do nat hole punching

830
00:25:20,480 --> 00:25:23,760
and just general matchmaking things it's

831
00:25:22,880 --> 00:25:26,080
a publix

832
00:25:23,760 --> 00:25:27,360
server that you connect to and queue up

833
00:25:26,080 --> 00:25:29,918
to play and match

834
00:25:27,360 --> 00:25:30,399
and this uses e-net but e-net can only

835
00:25:29,919 --> 00:25:33,840
handle

836
00:25:30,400 --> 00:25:35,919
a hard-coded maximum of 4095

837
00:25:33,840 --> 00:25:37,399
peers which means that if you connect to

838
00:25:35,919 --> 00:25:42,000
any in-app server

839
00:25:37,400 --> 00:25:44,320
4905 times the 496th attempt will

840
00:25:42,000 --> 00:25:46,640
fail because all the peer slots are

841
00:25:44,320 --> 00:25:48,639
taken up and it can't make any more

842
00:25:46,640 --> 00:25:51,039
so causing a denial of surface on the

843
00:25:48,640 --> 00:25:54,640
ser on the server is just as simple as

844
00:25:51,039 --> 00:25:56,480
connecting to it a few thousand times

845
00:25:54,640 --> 00:25:58,000
but it's actually worse than that you

846
00:25:56,480 --> 00:25:59,520
don't need to fully connect to the

847
00:25:58,000 --> 00:26:00,320
server by completing the three-way

848
00:25:59,520 --> 00:26:01,840
handshake

849
00:26:00,320 --> 00:26:03,360
after you send just the first leg of the

850
00:26:01,840 --> 00:26:04,720
connection the server takes up one of

851
00:26:03,360 --> 00:26:05,678
the pier slots while it waits for the

852
00:26:04,720 --> 00:26:07,919
connection to

853
00:26:05,679 --> 00:26:10,159
finish or time out so an attacker can

854
00:26:07,919 --> 00:26:10,720
send an initial connect packet spoofed

855
00:26:10,159 --> 00:26:13,279
to come from

856
00:26:10,720 --> 00:26:14,559
any ip address and take the server down

857
00:26:13,279 --> 00:26:15,200
there's no way to know where the attack

858
00:26:14,559 --> 00:26:16,799
is coming from

859
00:26:15,200 --> 00:26:18,240
there's no way to ban ip addresses of

860
00:26:16,799 --> 00:26:19,760
the attackers there's no way to know

861
00:26:18,240 --> 00:26:21,039
which are the bad requests and which are

862
00:26:19,760 --> 00:26:22,879
your actual users

863
00:26:21,039 --> 00:26:24,080
it's completely untraceable and

864
00:26:22,880 --> 00:26:26,400
unpreventable

865
00:26:24,080 --> 00:26:28,158
as an attack the connections won't

866
00:26:26,400 --> 00:26:29,600
complete but they don't need to

867
00:26:28,159 --> 00:26:31,120
the attacker can just keep sending

868
00:26:29,600 --> 00:26:33,918
initial connect packets to make sure the

869
00:26:31,120 --> 00:26:35,600
peer slots are always taken up

870
00:26:33,919 --> 00:26:37,039
if you're familiar with tcp this is

871
00:26:35,600 --> 00:26:37,600
really no different than a sin flood

872
00:26:37,039 --> 00:26:39,520
attack

873
00:26:37,600 --> 00:26:40,879
so maybe we can learn a lesson from how

874
00:26:39,520 --> 00:26:42,480
tcp deals with it

875
00:26:40,880 --> 00:26:44,480
let's look at what cloud flair has to

876
00:26:42,480 --> 00:26:46,159
say cloudflare is one of the best at

877
00:26:44,480 --> 00:26:47,440
preventing dos attacks and is on the

878
00:26:46,159 --> 00:26:48,799
front line in terms of dealing with it

879
00:26:47,440 --> 00:26:51,120
in the real world

880
00:26:48,799 --> 00:26:53,120
so here's the cloudflare blog describing

881
00:26:51,120 --> 00:26:54,080
how a sin flood attack works and how to

882
00:26:53,120 --> 00:26:57,120
mitigate it

883
00:26:54,080 --> 00:26:58,799
here's a tcp three-way handshake and

884
00:26:57,120 --> 00:27:01,678
right here's the attack so you can see

885
00:26:58,799 --> 00:27:03,760
the attacker sends spoofed syn packets

886
00:27:01,679 --> 00:27:06,000
the first leg of the handshake forcing

887
00:27:03,760 --> 00:27:08,000
the server to spend resources responding

888
00:27:06,000 --> 00:27:09,520
and maintaining half open connections

889
00:27:08,000 --> 00:27:10,400
it's a resource exhaustion problem

890
00:27:09,520 --> 00:27:12,559
basically

891
00:27:10,400 --> 00:27:13,679
exactly the same problem we have in enet

892
00:27:12,559 --> 00:27:15,760
cool so

893
00:27:13,679 --> 00:27:17,360
what does the cloudflare recommend let's

894
00:27:15,760 --> 00:27:20,240
see um

895
00:27:17,360 --> 00:27:20,559
okay increasing the backlog queue all

896
00:27:20,240 --> 00:27:23,360
right

897
00:27:20,559 --> 00:27:24,480
so that's basically get more resources

898
00:27:23,360 --> 00:27:26,959
uh next is

899
00:27:24,480 --> 00:27:27,600
recycling half open connections well

900
00:27:26,960 --> 00:27:29,840
okay

901
00:27:27,600 --> 00:27:31,199
basically use resources efficiently and

902
00:27:29,840 --> 00:27:34,158
get more

903
00:27:31,200 --> 00:27:35,440
then there's uh syn cookies which is

904
00:27:34,159 --> 00:27:38,000
kind of complicated

905
00:27:35,440 --> 00:27:39,440
basically boils down to get more

906
00:27:38,000 --> 00:27:40,640
resources

907
00:27:39,440 --> 00:27:42,880
and that's a major problem with this

908
00:27:40,640 --> 00:27:44,960
tack it doesn't have a great fix

909
00:27:42,880 --> 00:27:46,640
sure having a hard-coded maximum of only

910
00:27:44,960 --> 00:27:48,720
four thousand peers available

911
00:27:46,640 --> 00:27:50,480
makes exploiting it easy but even with a

912
00:27:48,720 --> 00:27:52,320
significant overhaul to how ena does

913
00:27:50,480 --> 00:27:53,039
memory management the attack will still

914
00:27:52,320 --> 00:27:55,520
work

915
00:27:53,039 --> 00:27:57,440
just marginally less effectively so it's

916
00:27:55,520 --> 00:27:58,799
not like tcp ever solved this problem

917
00:27:57,440 --> 00:28:00,880
either

918
00:27:58,799 --> 00:28:02,879
i disclose this and the next issue to

919
00:28:00,880 --> 00:28:04,559
the ener project a few months back but

920
00:28:02,880 --> 00:28:05,120
for this one the reality might very well

921
00:28:04,559 --> 00:28:06,799
be that

922
00:28:05,120 --> 00:28:08,799
a lightweight networking protocol like

923
00:28:06,799 --> 00:28:10,960
enet just isn't suitable for

924
00:28:08,799 --> 00:28:12,399
publicly accessible servers it's really

925
00:28:10,960 --> 00:28:13,600
only tenable in peer-to-peer

926
00:28:12,399 --> 00:28:15,199
applications

927
00:28:13,600 --> 00:28:17,360
so if you're out there running a service

928
00:28:15,200 --> 00:28:18,320
using e-net that's publicly available on

929
00:28:17,360 --> 00:28:21,600
the internet

930
00:28:18,320 --> 00:28:21,600
you might want to reconsider

931
00:28:23,120 --> 00:28:26,959
let's talk about ip spoofing for a

932
00:28:24,799 --> 00:28:28,559
second because it's going to matter

933
00:28:26,960 --> 00:28:30,720
this is lost on a lot of younger

934
00:28:28,559 --> 00:28:32,158
developers especially web developers

935
00:28:30,720 --> 00:28:34,399
since they're just used to this world

936
00:28:32,159 --> 00:28:36,320
where people can't spoof their ip

937
00:28:34,399 --> 00:28:38,000
the web server can track you by your ip

938
00:28:36,320 --> 00:28:39,200
address and potentially ban your ip if

939
00:28:38,000 --> 00:28:40,880
you do something bad

940
00:28:39,200 --> 00:28:42,000
people can use the vpn if they really

941
00:28:40,880 --> 00:28:42,640
want to hide where they're coming from

942
00:28:42,000 --> 00:28:44,240
but they

943
00:28:42,640 --> 00:28:46,000
do actually need to route their traffic

944
00:28:44,240 --> 00:28:48,000
through the vpn for that to work

945
00:28:46,000 --> 00:28:49,600
you can't simply just lie about what i p

946
00:28:48,000 --> 00:28:51,200
address you're coming from

947
00:28:49,600 --> 00:28:53,120
this is not the natural state of

948
00:28:51,200 --> 00:28:55,279
networking on the internet

949
00:28:53,120 --> 00:28:57,439
any packet you send has the source ip

950
00:28:55,279 --> 00:28:58,159
address right there in the data that you

951
00:28:57,440 --> 00:29:00,159
as the attacker

952
00:28:58,159 --> 00:29:01,840
send you can change it to say whatever

953
00:29:00,159 --> 00:29:04,240
you want claiming to be

954
00:29:01,840 --> 00:29:05,120
from wherever you want so why don't

955
00:29:04,240 --> 00:29:07,679
attackers just

956
00:29:05,120 --> 00:29:09,520
simply do that well this is an artifact

957
00:29:07,679 --> 00:29:11,039
of some security provided by the initial

958
00:29:09,520 --> 00:29:13,679
sequence number or

959
00:29:11,039 --> 00:29:14,320
n of the tcp three-way handshake uh the

960
00:29:13,679 --> 00:29:17,600
tcp

961
00:29:14,320 --> 00:29:18,720
handshake has three legs syn synack that

962
00:29:17,600 --> 00:29:20,399
part you knew

963
00:29:18,720 --> 00:29:21,840
but what's maybe less known is that

964
00:29:20,399 --> 00:29:23,840
there's also a negotiation

965
00:29:21,840 --> 00:29:26,080
on what the sequence number is to start

966
00:29:23,840 --> 00:29:27,840
from the sequence number is used for

967
00:29:26,080 --> 00:29:29,439
keeping track of the order of packets

968
00:29:27,840 --> 00:29:31,520
during the byte stream

969
00:29:29,440 --> 00:29:33,440
back in the day tcp servers used to just

970
00:29:31,520 --> 00:29:34,639
start with a sequence number of zero

971
00:29:33,440 --> 00:29:36,480
which is sensible

972
00:29:34,640 --> 00:29:38,159
but that lets attackers blind spoof

973
00:29:36,480 --> 00:29:40,159
their ip address let me show you how

974
00:29:38,159 --> 00:29:41,600
that can happen

975
00:29:40,159 --> 00:29:43,679
suppose you have a web server with an

976
00:29:41,600 --> 00:29:45,918
admin post endpoint that lets you update

977
00:29:43,679 --> 00:29:47,360
back-end code so if an attacker could

978
00:29:45,919 --> 00:29:49,200
make requests to this endpoint

979
00:29:47,360 --> 00:29:50,639
they could upload arbitrary code and

980
00:29:49,200 --> 00:29:53,039
take over the web server

981
00:29:50,640 --> 00:29:55,279
but you've white listed the your ip

982
00:29:53,039 --> 00:29:56,559
address so that only that one ip address

983
00:29:55,279 --> 00:29:58,399
can hit the end point

984
00:29:56,559 --> 00:30:00,000
this sort of thing happens all the time

985
00:29:58,399 --> 00:30:01,760
trust me sensitive administrative

986
00:30:00,000 --> 00:30:02,320
functionality being hidden behind an ip

987
00:30:01,760 --> 00:30:04,960
white list

988
00:30:02,320 --> 00:30:06,000
is super common but now imagine that the

989
00:30:04,960 --> 00:30:09,120
tcp server

990
00:30:06,000 --> 00:30:11,039
uses initial sequence number of zero

991
00:30:09,120 --> 00:30:13,520
what a an attacker can do is send a

992
00:30:11,039 --> 00:30:15,520
spoofed tcp syn packet claiming to come

993
00:30:13,520 --> 00:30:17,600
from the admins ip address

994
00:30:15,520 --> 00:30:19,520
the server then responds to the admin

995
00:30:17,600 --> 00:30:20,959
with a synack packet acknowledging the

996
00:30:19,520 --> 00:30:22,399
first leg of the handshake and

997
00:30:20,960 --> 00:30:24,559
sending an initial sequence number of

998
00:30:22,399 --> 00:30:26,158
zero the attacker can then send a

999
00:30:24,559 --> 00:30:28,799
spoofed ack packet

1000
00:30:26,159 --> 00:30:30,320
for the known sequence number of zero

1001
00:30:28,799 --> 00:30:32,320
the connection is now in place

1002
00:30:30,320 --> 00:30:34,000
as far as the server is concerned it has

1003
00:30:32,320 --> 00:30:35,360
no idea that it's not talking to the

1004
00:30:34,000 --> 00:30:37,120
real administrator

1005
00:30:35,360 --> 00:30:38,479
the attacker can then shove some data

1006
00:30:37,120 --> 00:30:39,120
down the pipe with the spoofed ip

1007
00:30:38,480 --> 00:30:41,760
address

1008
00:30:39,120 --> 00:30:44,320
using this method you can send but not

1009
00:30:41,760 --> 00:30:45,760
receive any data as any arbitrary ip

1010
00:30:44,320 --> 00:30:48,080
address you want

1011
00:30:45,760 --> 00:30:50,080
so what tcp did to prevent this is to

1012
00:30:48,080 --> 00:30:51,199
have the server randomize the initial

1013
00:30:50,080 --> 00:30:53,678
sequence number

1014
00:30:51,200 --> 00:30:54,559
the attacker can send spoofed syn packet

1015
00:30:53,679 --> 00:30:56,480
fine

1016
00:30:54,559 --> 00:30:58,240
the server will respond to the actual

1017
00:30:56,480 --> 00:31:00,159
admin by the way not the attacker

1018
00:30:58,240 --> 00:31:02,159
with a synack packet with a random

1019
00:31:00,159 --> 00:31:04,000
32-bit sequence number

1020
00:31:02,159 --> 00:31:06,080
the attacker now needs to act this

1021
00:31:04,000 --> 00:31:06,880
sequence number but they can't because

1022
00:31:06,080 --> 00:31:08,240
they don't know it

1023
00:31:06,880 --> 00:31:10,159
they don't have any way of knowing what

1024
00:31:08,240 --> 00:31:11,679
sequence number is so they can't

1025
00:31:10,159 --> 00:31:13,440
complete the connection

1026
00:31:11,679 --> 00:31:14,880
okay now let's take a look at some e-net

1027
00:31:13,440 --> 00:31:16,480
packets in wireshark

1028
00:31:14,880 --> 00:31:18,080
this is a capture of me playing some

1029
00:31:16,480 --> 00:31:19,600
melee in particular

1030
00:31:18,080 --> 00:31:21,600
let's check out this packet here at the

1031
00:31:19,600 --> 00:31:22,158
end this is a disconnection request

1032
00:31:21,600 --> 00:31:23,918
packet

1033
00:31:22,159 --> 00:31:26,000
it's what peers send to one another when

1034
00:31:23,919 --> 00:31:27,360
they want to hang up

1035
00:31:26,000 --> 00:31:29,200
there's not too many fields here so

1036
00:31:27,360 --> 00:31:30,959
let's just go through them there's two

1037
00:31:29,200 --> 00:31:32,559
bytes here for a peer id

1038
00:31:30,960 --> 00:31:35,360
it's not shown in wireshark but the

1039
00:31:32,559 --> 00:31:37,360
first four bits are actually four flags

1040
00:31:35,360 --> 00:31:39,199
only 12 bits are used for the peer id

1041
00:31:37,360 --> 00:31:41,600
itself the next two bytes

1042
00:31:39,200 --> 00:31:43,279
are a sent timestamp this is in

1043
00:31:41,600 --> 00:31:43,918
milliseconds from the perspective of the

1044
00:31:43,279 --> 00:31:47,120
sender

1045
00:31:43,919 --> 00:31:49,760
and wraps around pretty quickly next

1046
00:31:47,120 --> 00:31:51,439
is a command which is just one byte this

1047
00:31:49,760 --> 00:31:53,840
is the value to specify that this is a

1048
00:31:51,440 --> 00:31:55,840
disconnection request

1049
00:31:53,840 --> 00:31:57,840
there's a channel id which is a dummy

1050
00:31:55,840 --> 00:31:59,279
value here since it's not used in these

1051
00:31:57,840 --> 00:32:00,559
meta requests

1052
00:31:59,279 --> 00:32:02,320
then there's two bytes which is a

1053
00:32:00,559 --> 00:32:02,879
reliable sequence number which as you

1054
00:32:02,320 --> 00:32:05,039
can see

1055
00:32:02,880 --> 00:32:07,919
starts at zero and monotonically

1056
00:32:05,039 --> 00:32:09,760
increases each message

1057
00:32:07,919 --> 00:32:11,600
you can probably see where this is going

1058
00:32:09,760 --> 00:32:12,799
there's no equivalent to tcp's initial

1059
00:32:11,600 --> 00:32:14,080
sequence number here

1060
00:32:12,799 --> 00:32:16,080
there's nothing that really keeps an

1061
00:32:14,080 --> 00:32:17,760
attacker from spoofing this packet

1062
00:32:16,080 --> 00:32:19,439
so if two people are playing a game

1063
00:32:17,760 --> 00:32:20,879
happily sending packets back and forth

1064
00:32:19,440 --> 00:32:23,039
out on the open internet

1065
00:32:20,880 --> 00:32:23,919
a third party can send a spoofed packet

1066
00:32:23,039 --> 00:32:25,600
to one of them

1067
00:32:23,919 --> 00:32:27,039
claiming to be from the opponent saying

1068
00:32:25,600 --> 00:32:28,879
that they want to disconnect

1069
00:32:27,039 --> 00:32:30,399
killing the game let me show you what

1070
00:32:28,880 --> 00:32:31,919
that looks like

1071
00:32:30,399 --> 00:32:33,518
so what you're looking at here is a game

1072
00:32:31,919 --> 00:32:35,440
of melee netplay between the

1073
00:32:33,519 --> 00:32:36,880
screens here in the middle and the right

1074
00:32:35,440 --> 00:32:38,320
we're just gonna demonstrate a little

1075
00:32:36,880 --> 00:32:39,679
bit that we can move back and forth and

1076
00:32:38,320 --> 00:32:41,600
this is a real playing game

1077
00:32:39,679 --> 00:32:43,120
but then i'm gonna hit the go button on

1078
00:32:41,600 --> 00:32:46,799
an attack screen

1079
00:32:43,120 --> 00:32:46,799
my attack script here on the left

1080
00:32:48,320 --> 00:32:52,480
it's going to flood the network with

1081
00:32:50,240 --> 00:32:53,200
lots of guesses trying to guess the udp

1082
00:32:52,480 --> 00:32:56,240
source port

1083
00:32:53,200 --> 00:32:57,760
udp destination port and peer id of

1084
00:32:56,240 --> 00:32:59,360
one of the peers trying to send a

1085
00:32:57,760 --> 00:33:02,080
disconnection packet

1086
00:32:59,360 --> 00:33:02,080
to the peer

1087
00:33:02,480 --> 00:33:06,080
so you can see that the game is going

1088
00:33:04,240 --> 00:33:11,840
along just fine we're still able to move

1089
00:33:06,080 --> 00:33:11,840
around in synchronization

1090
00:33:14,080 --> 00:33:18,000
oh and then we've disconnected

1091
00:33:19,840 --> 00:33:23,678
you can see here the big red letters

1092
00:33:22,000 --> 00:33:27,120
come up that say disconnected means we

1093
00:33:23,679 --> 00:33:27,120
have disconnected from the other pier

1094
00:33:27,360 --> 00:33:30,320
when talking about spoofing a packet

1095
00:33:28,960 --> 00:33:32,080
like this it's important to keep track

1096
00:33:30,320 --> 00:33:32,879
of what information the attacker needs

1097
00:33:32,080 --> 00:33:34,639
to know

1098
00:33:32,880 --> 00:33:36,799
or guess in order for the attack to

1099
00:33:34,640 --> 00:33:38,640
succeed so let's do that

1100
00:33:36,799 --> 00:33:40,399
first are the ip addresses the attacker

1101
00:33:38,640 --> 00:33:41,440
needs to know the ip address of both

1102
00:33:40,399 --> 00:33:43,039
players involved

1103
00:33:41,440 --> 00:33:45,279
this might sound like a big hurdle at

1104
00:33:43,039 --> 00:33:47,679
first but in practice it's really not

1105
00:33:45,279 --> 00:33:49,279
your ip address is not private games are

1106
00:33:47,679 --> 00:33:50,320
peer-to-peer remember so you disclose

1107
00:33:49,279 --> 00:33:52,240
your ip address to

1108
00:33:50,320 --> 00:33:53,760
everyone you play against and you can

1109
00:33:52,240 --> 00:33:55,279
definitely imagine some nefarious

1110
00:33:53,760 --> 00:33:56,799
players who match up against

1111
00:33:55,279 --> 00:33:58,799
well-known players and keep track of

1112
00:33:56,799 --> 00:33:59,918
their ips for later use but it doesn't

1113
00:33:58,799 --> 00:34:01,679
even take that

1114
00:33:59,919 --> 00:34:04,000
consider the typical melee tournament

1115
00:34:01,679 --> 00:34:05,679
which uses a double elimination bracket

1116
00:34:04,000 --> 00:34:07,679
in the grand finals two players are

1117
00:34:05,679 --> 00:34:08,800
duking it out for who gets first and who

1118
00:34:07,679 --> 00:34:10,079
gets second

1119
00:34:08,800 --> 00:34:11,599
this is the major event of the

1120
00:34:10,079 --> 00:34:13,040
tournament and above all else we

1121
00:34:11,599 --> 00:34:14,079
wouldn't want something bad to happen to

1122
00:34:13,040 --> 00:34:16,159
that game

1123
00:34:14,079 --> 00:34:18,079
but the player who just got knocked out

1124
00:34:16,159 --> 00:34:19,679
prior to this is in third

1125
00:34:18,079 --> 00:34:21,520
and is likely to have been knocked out

1126
00:34:19,679 --> 00:34:22,399
by both of the players that are playing

1127
00:34:21,520 --> 00:34:25,359
in grand finals

1128
00:34:22,399 --> 00:34:25,839
right now meaning they played together

1129
00:34:25,359 --> 00:34:27,279
and

1130
00:34:25,839 --> 00:34:28,879
that player might just have an axe to

1131
00:34:27,280 --> 00:34:31,359
grind with them so a

1132
00:34:28,879 --> 00:34:33,118
salty third place finisher is a very

1133
00:34:31,359 --> 00:34:34,960
legitimate threat scenario for this kind

1134
00:34:33,119 --> 00:34:37,200
of attack they'd have both the means

1135
00:34:34,960 --> 00:34:38,879
and the motive so we assume here that

1136
00:34:37,199 --> 00:34:41,359
the attacker knows both of these ip

1137
00:34:38,879 --> 00:34:43,598
addresses

1138
00:34:41,359 --> 00:34:45,119
next are the udp ports the spoofed

1139
00:34:43,599 --> 00:34:45,839
packet needs to have the correct udp

1140
00:34:45,119 --> 00:34:47,839
source port

1141
00:34:45,839 --> 00:34:49,759
and destination port there's no way to

1142
00:34:47,839 --> 00:34:52,159
know these they have to be guessed

1143
00:34:49,760 --> 00:34:53,760
by default on linux udp transient ports

1144
00:34:52,159 --> 00:34:57,040
are chosen at random between

1145
00:34:53,760 --> 00:35:00,839
32 768 and 60

1146
00:34:57,040 --> 00:35:04,079
999 meaning that we need to guess 28

1147
00:35:00,839 --> 00:35:05,759
231 ports each which would be a lot

1148
00:35:04,079 --> 00:35:08,079
but in practice we don't actually need

1149
00:35:05,760 --> 00:35:09,680
to you see games don't want to use the

1150
00:35:08,079 --> 00:35:11,599
full possible port range

1151
00:35:09,680 --> 00:35:13,200
because then you'd need to white list

1152
00:35:11,599 --> 00:35:14,480
every single one of these in routers for

1153
00:35:13,200 --> 00:35:15,520
a lot of users

1154
00:35:14,480 --> 00:35:17,680
and we wouldn't want to have to

1155
00:35:15,520 --> 00:35:20,240
whitelist every possible tcp or

1156
00:35:17,680 --> 00:35:21,118
udp port so for example melee actually

1157
00:35:20,240 --> 00:35:23,439
just uses

1158
00:35:21,119 --> 00:35:24,560
uh ports forty nine thousand uh through

1159
00:35:23,440 --> 00:35:25,680
fifty one thousand

1160
00:35:24,560 --> 00:35:27,279
so there's only two thousand

1161
00:35:25,680 --> 00:35:29,919
possibilities for each port that we need

1162
00:35:27,280 --> 00:35:32,320
to guess as an attacker

1163
00:35:29,920 --> 00:35:34,000
next are the e-net specific values as it

1164
00:35:32,320 --> 00:35:34,800
turns out the sequence number that we

1165
00:35:34,000 --> 00:35:36,880
saw earlier

1166
00:35:34,800 --> 00:35:38,079
is actually not required to occur in

1167
00:35:36,880 --> 00:35:39,920
sequential order

1168
00:35:38,079 --> 00:35:41,520
if you give a value out of order the

1169
00:35:39,920 --> 00:35:42,960
recipient is just fine with it

1170
00:35:41,520 --> 00:35:44,720
so we don't need to guess that value at

1171
00:35:42,960 --> 00:35:45,200
all my attack script just sets the value

1172
00:35:44,720 --> 00:35:48,078
to 1

1173
00:35:45,200 --> 00:35:49,598
and everything's fine the only value we

1174
00:35:48,079 --> 00:35:50,960
need to guess correctly here is the

1175
00:35:49,599 --> 00:35:53,280
sender's peer id

1176
00:35:50,960 --> 00:35:55,040
like i said earlier this is only 12 bits

1177
00:35:53,280 --> 00:35:57,119
and also isn't randomized

1178
00:35:55,040 --> 00:35:59,119
it's just a sequential-ish number and

1179
00:35:57,119 --> 00:36:02,000
tends to be some low number

1180
00:35:59,119 --> 00:36:02,400
below four for melee games it's almost

1181
00:36:02,000 --> 00:36:05,760
always

1182
00:36:02,400 --> 00:36:06,480
zero or one let's do some quick math

1183
00:36:05,760 --> 00:36:08,720
here then

1184
00:36:06,480 --> 00:36:09,920
we need to guess two thousand udp source

1185
00:36:08,720 --> 00:36:12,879
ports times

1186
00:36:09,920 --> 00:36:14,320
two thousand udp destination ports times

1187
00:36:12,880 --> 00:36:16,079
two peer ids

1188
00:36:14,320 --> 00:36:18,079
that gives us eight million total

1189
00:36:16,079 --> 00:36:19,520
guesses on average though we'll hit the

1190
00:36:18,079 --> 00:36:21,440
right value in the middle

1191
00:36:19,520 --> 00:36:22,880
so let's have this to four million

1192
00:36:21,440 --> 00:36:25,920
guesses that'll take us to do with a

1193
00:36:22,880 --> 00:36:28,720
successful attack in the average case

1194
00:36:25,920 --> 00:36:30,480
each packet is 54 bytes long so that

1195
00:36:28,720 --> 00:36:31,118
means the attack will need on average to

1196
00:36:30,480 --> 00:36:34,880
send

1197
00:36:31,119 --> 00:36:36,160
432 megabytes of data i get 35 megabits

1198
00:36:34,880 --> 00:36:37,520
upload on my home network which would

1199
00:36:36,160 --> 00:36:40,480
take about one and a half minutes of

1200
00:36:37,520 --> 00:36:42,000
attacking to succeed

1201
00:36:40,480 --> 00:36:44,240
of course if you have fiber that speeds

1202
00:36:42,000 --> 00:36:46,240
it up a lot and the attack i showed you

1203
00:36:44,240 --> 00:36:47,359
earlier was over my home gigabit land so

1204
00:36:46,240 --> 00:36:49,118
it was real fast

1205
00:36:47,359 --> 00:36:51,759
but in any case you can see that this is

1206
00:36:49,119 --> 00:36:53,680
a quite practical attack

1207
00:36:51,760 --> 00:36:55,200
lastly on this while i showed you an

1208
00:36:53,680 --> 00:36:56,000
example of sending a disconnection

1209
00:36:55,200 --> 00:36:57,759
request

1210
00:36:56,000 --> 00:36:59,920
packet injection attacks are not limited

1211
00:36:57,760 --> 00:37:01,119
to this basically any kind of packet can

1212
00:36:59,920 --> 00:37:03,680
be forged this way

1213
00:37:01,119 --> 00:37:05,119
including application specific payloads

1214
00:37:03,680 --> 00:37:07,520
so if your game has a way of doing

1215
00:37:05,119 --> 00:37:09,040
password resets in game for example

1216
00:37:07,520 --> 00:37:10,560
those could be forged too to do a

1217
00:37:09,040 --> 00:37:13,759
complete account takeover

1218
00:37:10,560 --> 00:37:13,759
and that's just the start

1219
00:37:15,280 --> 00:37:18,560
okay we're almost at the end for the

1220
00:37:17,040 --> 00:37:19,839
last two bugs we're going to leave super

1221
00:37:18,560 --> 00:37:21,680
smash brothers behind

1222
00:37:19,839 --> 00:37:23,599
and planes walk over to magic the

1223
00:37:21,680 --> 00:37:24,560
gathering i've been a magic nerd for a

1224
00:37:23,599 --> 00:37:26,640
long time in fact

1225
00:37:24,560 --> 00:37:27,599
these posters behind me are magic art by

1226
00:37:26,640 --> 00:37:29,598
john avon

1227
00:37:27,599 --> 00:37:31,599
some of my favorite behind perhaps seb

1228
00:37:29,599 --> 00:37:33,280
mckinnon just like before though

1229
00:37:31,599 --> 00:37:35,119
i was working on a pet project to make a

1230
00:37:33,280 --> 00:37:36,000
bot that could automate games of magic

1231
00:37:35,119 --> 00:37:39,119
the gathering against

1232
00:37:36,000 --> 00:37:40,400
itself my auto my motto is uh why play

1233
00:37:39,119 --> 00:37:42,800
games when you can make a bot to

1234
00:37:40,400 --> 00:37:44,320
automate playing against them for you

1235
00:37:42,800 --> 00:37:46,000
i never did wind up actually completing

1236
00:37:44,320 --> 00:37:50,560
this project but here are some cool

1237
00:37:46,000 --> 00:37:52,880
things that fell out of it

1238
00:37:50,560 --> 00:37:54,320
this one will be quick a cocker tree is

1239
00:37:52,880 --> 00:37:55,440
a popular open source magic the

1240
00:37:54,320 --> 00:37:57,040
gathering application

1241
00:37:55,440 --> 00:37:58,800
ever since the pandemic i've been using

1242
00:37:57,040 --> 00:38:00,800
it regularly actually a group of friends

1243
00:37:58,800 --> 00:38:02,400
and i play commander tuesday nights

1244
00:38:00,800 --> 00:38:04,320
magic is a game that requires a lot of

1245
00:38:02,400 --> 00:38:06,079
randomization as part of it the most

1246
00:38:04,320 --> 00:38:07,280
obvious example of this is shuffling

1247
00:38:06,079 --> 00:38:09,119
your deck of cards

1248
00:38:07,280 --> 00:38:10,720
if you could know the order of your deck

1249
00:38:09,119 --> 00:38:12,560
which is supposed to be randomized

1250
00:38:10,720 --> 00:38:13,919
then you could cheat and win at a game

1251
00:38:12,560 --> 00:38:16,160
pretty effectively

1252
00:38:13,920 --> 00:38:18,160
as you can see here cockatrice uses the

1253
00:38:16,160 --> 00:38:19,200
mercen twister as an algorithm to do all

1254
00:38:18,160 --> 00:38:21,520
the random events

1255
00:38:19,200 --> 00:38:24,000
uh server side including shuffling a

1256
00:38:21,520 --> 00:38:25,359
deck the percent twister is not a secure

1257
00:38:24,000 --> 00:38:26,800
random number generator

1258
00:38:25,359 --> 00:38:28,640
it starts off with an initial seat

1259
00:38:26,800 --> 00:38:30,400
integer and then produces new integers

1260
00:38:28,640 --> 00:38:30,720
in a completely predictable pattern from

1261
00:38:30,400 --> 00:38:32,560
it

1262
00:38:30,720 --> 00:38:34,959
i even wrote a little tool here called

1263
00:38:32,560 --> 00:38:35,520
untwister that untwists the mercen

1264
00:38:34,960 --> 00:38:37,440
twister

1265
00:38:35,520 --> 00:38:39,920
and can recover the initial seat given a

1266
00:38:37,440 --> 00:38:41,520
series of apparently random numbers

1267
00:38:39,920 --> 00:38:43,440
the end result is that it's entirely

1268
00:38:41,520 --> 00:38:43,839
feasible to reverse this rng seed and

1269
00:38:43,440 --> 00:38:46,079
then

1270
00:38:43,839 --> 00:38:48,000
cheat in your game of magic i disclosed

1271
00:38:46,079 --> 00:38:48,800
this issue to the developers a few years

1272
00:38:48,000 --> 00:38:51,520
back actually

1273
00:38:48,800 --> 00:38:53,200
but it was marked as a won't fix and you

1274
00:38:51,520 --> 00:38:54,400
know what they have a point actually

1275
00:38:53,200 --> 00:38:55,839
while it wouldn't hurt to use a

1276
00:38:54,400 --> 00:38:56,720
cryptographically secure random number

1277
00:38:55,839 --> 00:38:58,320
generator here

1278
00:38:56,720 --> 00:38:59,919
cockatrice doesn't even enforce the

1279
00:38:58,320 --> 00:39:01,280
rules of magic for you

1280
00:38:59,920 --> 00:39:03,119
cheating in cockatrices is pretty

1281
00:39:01,280 --> 00:39:04,640
trivial you can just like perform

1282
00:39:03,119 --> 00:39:06,480
any game actions you want even if

1283
00:39:04,640 --> 00:39:07,279
they're not legal ones the game won't

1284
00:39:06,480 --> 00:39:09,200
stop you

1285
00:39:07,280 --> 00:39:11,680
it's really meant for like low stakes

1286
00:39:09,200 --> 00:39:13,759
games amongst friends which is fair

1287
00:39:11,680 --> 00:39:15,440
also it made writing a bot in using

1288
00:39:13,760 --> 00:39:16,640
cockatrees hard since it doesn't know

1289
00:39:15,440 --> 00:39:18,640
how the rules work

1290
00:39:16,640 --> 00:39:20,319
my bot would be no good if it kept

1291
00:39:18,640 --> 00:39:24,000
taking illegal game actions

1292
00:39:20,320 --> 00:39:24,000
which led me to x-mage

1293
00:39:24,960 --> 00:39:28,000
x-page is also an open source magic the

1294
00:39:26,960 --> 00:39:29,520
gathering application

1295
00:39:28,000 --> 00:39:31,440
but this one actually does rules

1296
00:39:29,520 --> 00:39:32,560
enforcement which would be a much better

1297
00:39:31,440 --> 00:39:33,680
fit for the bot that i was trying to

1298
00:39:32,560 --> 00:39:35,680
write anyway

1299
00:39:33,680 --> 00:39:37,200
xmage has a client server architecture

1300
00:39:35,680 --> 00:39:38,078
so i figured i could basically write my

1301
00:39:37,200 --> 00:39:39,598
own client

1302
00:39:38,079 --> 00:39:41,200
that would talk to the remote server and

1303
00:39:39,599 --> 00:39:42,720
take game actions

1304
00:39:41,200 --> 00:39:46,480
so i went in and peaked at the source

1305
00:39:42,720 --> 00:39:50,078
code and uh 1.3 million lines of code

1306
00:39:46,480 --> 00:39:51,760
are you kidding me okay

1307
00:39:50,079 --> 00:39:53,200
forget trying to read the code uh let's

1308
00:39:51,760 --> 00:39:54,720
just boot up the game and look at the

1309
00:39:53,200 --> 00:39:56,399
network traffic between the client and

1310
00:39:54,720 --> 00:39:58,160
server and wireshark

1311
00:39:56,400 --> 00:40:00,160
i figured there'd be like a rest api

1312
00:39:58,160 --> 00:40:02,960
that i could make calls to

1313
00:40:00,160 --> 00:40:03,598
make my own client for so i started the

1314
00:40:02,960 --> 00:40:05,520
local

1315
00:40:03,599 --> 00:40:07,520
server and client locally here let's

1316
00:40:05,520 --> 00:40:11,839
just log in using a dummy account and

1317
00:40:07,520 --> 00:40:11,839
see what the traffic looks like

1318
00:40:17,599 --> 00:40:21,520
huh that's not http

1319
00:40:21,560 --> 00:40:28,000
java.lang.object java.lang.string

1320
00:40:24,960 --> 00:40:29,359
oh no oh no those are serialized java

1321
00:40:28,000 --> 00:40:32,160
objects aren't they

1322
00:40:29,359 --> 00:40:34,480
yup i'm gonna have to exploit this i

1323
00:40:32,160 --> 00:40:34,480
guess

1324
00:40:35,280 --> 00:40:40,400
xmage uses this rather abandoned project

1325
00:40:38,319 --> 00:40:41,599
called jboss remoting to do network

1326
00:40:40,400 --> 00:40:43,680
communication

1327
00:40:41,599 --> 00:40:45,920
it's a remote invocation library whose

1328
00:40:43,680 --> 00:40:48,480
last release was in 2014.

1329
00:40:45,920 --> 00:40:50,880
if allowing attackers to remotely invoke

1330
00:40:48,480 --> 00:40:53,280
methods on your server sounds insecure

1331
00:40:50,880 --> 00:40:55,280
that's because it is this kind of rmi

1332
00:40:53,280 --> 00:40:55,599
system is perfectly acceptable between

1333
00:40:55,280 --> 00:40:57,760
two

1334
00:40:55,599 --> 00:40:59,040
internal components of a system though

1335
00:40:57,760 --> 00:41:02,000
honestly even then

1336
00:40:59,040 --> 00:41:03,200
just use an http api but certainly not

1337
00:41:02,000 --> 00:41:06,800
between a server and

1338
00:41:03,200 --> 00:41:08,319
untrusted clients anyway jboss remoting

1339
00:41:06,800 --> 00:41:10,640
fundamentally works under the hood by

1340
00:41:08,319 --> 00:41:11,520
sending serialized java objects back and

1341
00:41:10,640 --> 00:41:13,598
forth

1342
00:41:11,520 --> 00:41:15,119
not plain old java objects though or

1343
00:41:13,599 --> 00:41:17,200
pojo as they say

1344
00:41:15,119 --> 00:41:19,200
noaa uses an equally abandoned project

1345
00:41:17,200 --> 00:41:20,640
called jboss serialization

1346
00:41:19,200 --> 00:41:22,480
this is a completely different and

1347
00:41:20,640 --> 00:41:25,598
custom marshalling format

1348
00:41:22,480 --> 00:41:27,359
so let's build an exploit for this i

1349
00:41:25,599 --> 00:41:27,920
have two working exploits to show you or

1350
00:41:27,359 --> 00:41:29,920
perhaps

1351
00:41:27,920 --> 00:41:31,200
one and a half the first is a simple

1352
00:41:29,920 --> 00:41:32,800
denial of service

1353
00:41:31,200 --> 00:41:34,640
so the easiest way to make an exploit in

1354
00:41:32,800 --> 00:41:35,440
this scenario is just to write a java

1355
00:41:34,640 --> 00:41:37,359
program that

1356
00:41:35,440 --> 00:41:38,720
uses jboss remoting and jboss

1357
00:41:37,359 --> 00:41:41,200
serialization and

1358
00:41:38,720 --> 00:41:43,040
send a legitimate message over the wire

1359
00:41:41,200 --> 00:41:45,279
what i did here is build a hash set that

1360
00:41:43,040 --> 00:41:47,119
recursively references itself

1361
00:41:45,280 --> 00:41:48,560
so when the reader tries to deserialize

1362
00:41:47,119 --> 00:41:49,760
this object and they will spend an

1363
00:41:48,560 --> 00:41:51,040
entire cpu

1364
00:41:49,760 --> 00:41:53,040
spinning trying to resolve the

1365
00:41:51,040 --> 00:41:54,560
references over and over and over

1366
00:41:53,040 --> 00:41:56,319
to bring down the server you just need

1367
00:41:54,560 --> 00:41:57,680
to send a few of these over to tie up

1368
00:41:56,319 --> 00:42:00,400
all the cpus it has

1369
00:41:57,680 --> 00:42:01,919
check that out okay there's a lot

1370
00:42:00,400 --> 00:42:03,839
happening on the screen right now but on

1371
00:42:01,920 --> 00:42:04,960
the top is my cpu usage that's what you

1372
00:42:03,839 --> 00:42:06,560
want to watch

1373
00:42:04,960 --> 00:42:09,200
you can see each time i run the attack

1374
00:42:06,560 --> 00:42:11,359
program on the bottom the cpu usage goes

1375
00:42:09,200 --> 00:42:11,359
up

1376
00:42:14,880 --> 00:42:20,000
after i've run the attack four times the

1377
00:42:17,200 --> 00:42:22,560
xmag server process is running at 400

1378
00:42:20,000 --> 00:42:24,079
cpu meaning it has four entire cpus

1379
00:42:22,560 --> 00:42:27,440
spinning doing nothing but trying to

1380
00:42:24,079 --> 00:42:27,440
read the hash set that i gave it

1381
00:42:27,920 --> 00:42:32,079
this next one is a bit more complicated

1382
00:42:30,160 --> 00:42:34,000
i'm going to use a modified gadget chain

1383
00:42:32,079 --> 00:42:35,920
that yso serial typically uses for the

1384
00:42:34,000 --> 00:42:37,839
commons collection 3 payload

1385
00:42:35,920 --> 00:42:39,839
it's modified because of an annoying bug

1386
00:42:37,839 --> 00:42:41,119
i ran into turns out that jboss

1387
00:42:39,839 --> 00:42:43,279
serialization just

1388
00:42:41,119 --> 00:42:44,560
fails to serialize certain objects it's

1389
00:42:43,280 --> 00:42:46,800
not a security mechanism

1390
00:42:44,560 --> 00:42:47,599
it just crashes on certain objects trust

1391
00:42:46,800 --> 00:42:49,040
me it was

1392
00:42:47,599 --> 00:42:51,040
very annoying while trying to make a

1393
00:42:49,040 --> 00:42:53,119
proof of concept when like a quarter of

1394
00:42:51,040 --> 00:42:54,400
all the objects i ran into just fail for

1395
00:42:53,119 --> 00:42:56,160
no clear reason

1396
00:42:54,400 --> 00:42:58,319
anyway one of the outer layers of the

1397
00:42:56,160 --> 00:42:58,799
default why so serial payload is one of

1398
00:42:58,319 --> 00:43:00,960
these

1399
00:42:58,800 --> 00:43:02,480
classes that crashes but we can work

1400
00:43:00,960 --> 00:43:03,920
around it

1401
00:43:02,480 --> 00:43:05,599
honestly you could probably spend an

1402
00:43:03,920 --> 00:43:07,200
entire presentation just talking about

1403
00:43:05,599 --> 00:43:07,760
what this payload is doing and how it

1404
00:43:07,200 --> 00:43:09,680
works

1405
00:43:07,760 --> 00:43:11,440
but the gist here is that it executes an

1406
00:43:09,680 --> 00:43:12,240
arbitrary shell command by chaining

1407
00:43:11,440 --> 00:43:14,240
together a

1408
00:43:12,240 --> 00:43:16,319
rue goldberg machine of invocation

1409
00:43:14,240 --> 00:43:17,279
gadgets uh we're only going to cheat a

1410
00:43:16,319 --> 00:43:19,440
little bit here

1411
00:43:17,280 --> 00:43:20,480
uh the commons collection 3 jar that

1412
00:43:19,440 --> 00:43:22,240
xmage uses

1413
00:43:20,480 --> 00:43:24,079
has been patched to prevent this exact

1414
00:43:22,240 --> 00:43:25,680
object the invoker transformer from

1415
00:43:24,079 --> 00:43:27,760
being deserialized

1416
00:43:25,680 --> 00:43:28,799
specifically because of this sort of

1417
00:43:27,760 --> 00:43:30,240
exploit

1418
00:43:28,800 --> 00:43:32,079
it's a band-aid that doesn't really

1419
00:43:30,240 --> 00:43:33,598
solve the underlying problem though

1420
00:43:32,079 --> 00:43:35,520
but i didn't want to go to all the

1421
00:43:33,599 --> 00:43:36,560
bother of discovering a brand new gadget

1422
00:43:35,520 --> 00:43:38,160
chain just for this

1423
00:43:36,560 --> 00:43:40,240
so i went and re-enabled the invoker

1424
00:43:38,160 --> 00:43:41,598
transformer class and the xmage server

1425
00:43:40,240 --> 00:43:44,640
that way we could demonstrate this

1426
00:43:41,599 --> 00:43:46,400
vulnerability in the jre arguments

1427
00:43:44,640 --> 00:43:48,078
on the left here is an xmage server

1428
00:43:46,400 --> 00:43:49,119
running in a debugger and on the right

1429
00:43:48,079 --> 00:43:50,720
is our attack code

1430
00:43:49,119 --> 00:43:52,880
it's currently set to run the gnome

1431
00:43:50,720 --> 00:43:55,839
calculator as a test payload

1432
00:43:52,880 --> 00:43:55,839
let's run it

1433
00:43:59,200 --> 00:44:02,640
now i just ran the calculator app using

1434
00:44:01,040 --> 00:44:04,800
this attack but of course you could run

1435
00:44:02,640 --> 00:44:06,480
any arbitrary shell command you want i

1436
00:44:04,800 --> 00:44:08,160
disclosed this issue to x mage over a

1437
00:44:06,480 --> 00:44:10,000
year ago but fixing it would require

1438
00:44:08,160 --> 00:44:11,920
a significant rework to how the entire

1439
00:44:10,000 --> 00:44:13,200
application does network communication

1440
00:44:11,920 --> 00:44:14,720
it would need to tear out all the

1441
00:44:13,200 --> 00:44:16,560
existing network code and design a

1442
00:44:14,720 --> 00:44:18,879
completely new rest api or

1443
00:44:16,560 --> 00:44:20,400
some other mechanism from scratch and it

1444
00:44:18,880 --> 00:44:24,720
seems like that's not likely to happen

1445
00:44:20,400 --> 00:44:24,720
so this issue is still exploitable today

1446
00:44:25,520 --> 00:44:29,040
i hope you had as much fun watching this

1447
00:44:26,960 --> 00:44:30,880
as i had putting it together video games

1448
00:44:29,040 --> 00:44:32,160
are complex pieces of technology we

1449
00:44:30,880 --> 00:44:33,200
often don't give them the respect they

1450
00:44:32,160 --> 00:44:35,279
deserve for that

1451
00:44:33,200 --> 00:44:37,040
games can sometimes be dismissed as just

1452
00:44:35,280 --> 00:44:38,880
toys but in my experience the

1453
00:44:37,040 --> 00:44:40,640
average online game is more complex than

1454
00:44:38,880 --> 00:44:41,920
the average web application

1455
00:44:40,640 --> 00:44:43,680
always approach your problems with a

1456
00:44:41,920 --> 00:44:46,240
security mindset and trust me things

1457
00:44:43,680 --> 00:44:46,240
will fall out

1458
00:44:48,839 --> 00:44:51,839
later

1459
00:45:10,400 --> 00:45:12,480
you

