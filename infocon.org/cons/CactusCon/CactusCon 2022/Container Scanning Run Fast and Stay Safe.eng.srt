1
00:00:08,480 --> 00:00:10,559
we're good

2
00:00:10,559 --> 00:00:13,120
welcome everyone in person and online to

3
00:00:13,120 --> 00:00:15,200
cactus con i am so excited to be able to

4
00:00:15,200 --> 00:00:17,279
share with you container scanning run

5
00:00:17,279 --> 00:00:19,600
fast and stay safe

6
00:00:19,600 --> 00:00:21,439
container scanning is really cool and

7
00:00:21,439 --> 00:00:22,800
let's talk about how we might get

8
00:00:22,800 --> 00:00:25,359
container scanning in place

9
00:00:25,359 --> 00:00:27,119
here's the part where i tell you i am

10
00:00:27,119 --> 00:00:28,400
definitely going to post the slides on

11
00:00:28,400 --> 00:00:31,039
my site tonight i've been that person

12
00:00:31,039 --> 00:00:32,399
chasing the speaker and it's never

13
00:00:32,399 --> 00:00:34,559
worked out for me very well either which

14
00:00:34,559 --> 00:00:36,800
is why you can go to robrich.org let's

15
00:00:36,800 --> 00:00:39,440
go there we'll click on robrich.org and

16
00:00:39,440 --> 00:00:40,800
we'll head here we'll click on

17
00:00:40,800 --> 00:00:42,800
presentations here at the top and here's

18
00:00:42,800 --> 00:00:44,800
container scanning run fast and stay

19
00:00:44,800 --> 00:00:50,000
safe the slides are online right now

20
00:00:50,000 --> 00:00:53,199
achievement unlocked

21
00:00:53,440 --> 00:00:55,120
while we're here on robrich.org let's

22
00:00:55,120 --> 00:00:56,640
click on about me and see some of the

23
00:00:56,640 --> 00:00:58,800
things that i've done recently

24
00:00:58,800 --> 00:01:01,039
i'm a cyril developer advocate if you're

25
00:01:01,039 --> 00:01:02,559
struggling with your data mesh i would

26
00:01:02,559 --> 00:01:04,959
love to learn from you i'm a microsoft

27
00:01:04,959 --> 00:01:07,119
mvp a docker captain and a friend of red

28
00:01:07,119 --> 00:01:07,920
gate

29
00:01:07,920 --> 00:01:10,320
easy gift camp is really fun azgive camp

30
00:01:10,320 --> 00:01:12,240
brings volunteer developers together

31
00:01:12,240 --> 00:01:14,960
with charities to build free software we

32
00:01:14,960 --> 00:01:16,560
start building software friday after

33
00:01:16,560 --> 00:01:18,799
work sunday afternoon we deliver the

34
00:01:18,799 --> 00:01:21,200
completed software to charities sleep is

35
00:01:21,200 --> 00:01:23,040
optional caffeine provided

36
00:01:23,040 --> 00:01:24,799
come join us the next time we do easy

37
00:01:24,799 --> 00:01:27,280
give camp here in phoenix or if you're

38
00:01:27,280 --> 00:01:29,520
connecting from far away hit me up on

39
00:01:29,520 --> 00:01:31,200
email or twitter and let's get a gift

40
00:01:31,200 --> 00:01:33,439
camp in your neighborhood too

41
00:01:33,439 --> 00:01:35,600
some of the other things that i've done

42
00:01:35,600 --> 00:01:38,400
pro microservices and net six

43
00:01:38,400 --> 00:01:40,560
this one just came out grab this link

44
00:01:40,560 --> 00:01:42,159
from robrich.org and i'll send you

45
00:01:42,159 --> 00:01:44,399
straight to amazon that is a fun book

46
00:01:44,399 --> 00:01:47,280
sean and matthew and i worked on that it

47
00:01:47,280 --> 00:01:49,360
worked out really well

48
00:01:49,360 --> 00:01:50,799
some of the other things that i've done

49
00:01:50,799 --> 00:01:53,200
i replied to a.net rocks podcast episode

50
00:01:53,200 --> 00:01:54,640
they read my comments on the air and

51
00:01:54,640 --> 00:01:57,040
they sent me a mug

52
00:01:57,040 --> 00:02:00,240
so there's my coveted.net rocksmug

53
00:02:00,240 --> 00:02:02,560
and if you'd like a.net rocksmug post a

54
00:02:02,560 --> 00:02:05,360
comment on no just kidding

55
00:02:05,360 --> 00:02:06,799
they actually don't give away.net rocks

56
00:02:06,799 --> 00:02:08,639
mugs anymore they give away

57
00:02:08,639 --> 00:02:11,678
music to code by

58
00:02:12,560 --> 00:02:14,879
so container scanning we talked about

59
00:02:14,879 --> 00:02:16,800
this guy

60
00:02:16,800 --> 00:02:18,879
doesn't kubernetes just do this for me

61
00:02:18,879 --> 00:02:20,480
isn't that why i containerize things so

62
00:02:20,480 --> 00:02:21,520
i didn't have to worry about the

63
00:02:21,520 --> 00:02:24,400
security piece

64
00:02:24,480 --> 00:02:26,000
well

65
00:02:26,000 --> 00:02:27,680
kind of

66
00:02:27,680 --> 00:02:29,599
here's an outline of kubernetes and when

67
00:02:29,599 --> 00:02:32,160
we look at this diagram we kind of uh

68
00:02:32,160 --> 00:02:36,160
squint real hard and it's like hmm

69
00:02:36,160 --> 00:02:37,760
what we see in this diagram is the

70
00:02:37,760 --> 00:02:40,400
control plane on the top and the worker

71
00:02:40,400 --> 00:02:42,080
nodes on the bottom control plane and

72
00:02:42,080 --> 00:02:44,239
green and worker nodes in blue

73
00:02:44,239 --> 00:02:47,360
on the top we have an api server

74
00:02:47,360 --> 00:02:49,440
when we're using cube ctl

75
00:02:49,440 --> 00:02:51,440
control cube cuddle will connect to that

76
00:02:51,440 --> 00:02:54,239
api server the api server will then save

77
00:02:54,239 --> 00:02:55,840
things in at cd

78
00:02:55,840 --> 00:02:57,760
the scheduler will notice through the

79
00:02:57,760 --> 00:03:00,959
api server that various fcd things or

80
00:03:00,959 --> 00:03:03,040
the controller manager will notice

81
00:03:03,040 --> 00:03:05,519
various things inside ncd have changed

82
00:03:05,519 --> 00:03:08,000
and will tell the scheduler to go kick

83
00:03:08,000 --> 00:03:10,400
off things the scheduler will move now

84
00:03:10,400 --> 00:03:12,720
down into the blue section where we have

85
00:03:12,720 --> 00:03:15,280
a cubelet and the cubelet is responsible

86
00:03:15,280 --> 00:03:18,400
for starting a process starting a pod

87
00:03:18,400 --> 00:03:20,319
starting a container inside of

88
00:03:20,319 --> 00:03:21,920
kubernetes

89
00:03:21,920 --> 00:03:23,680
as users come in they'll hit a load

90
00:03:23,680 --> 00:03:25,360
balancer eventually they'll end up on

91
00:03:25,360 --> 00:03:27,360
cube proxy and cube proxy will then

92
00:03:27,360 --> 00:03:29,360
route that content into the particular

93
00:03:29,360 --> 00:03:31,760
pod or container that is running our

94
00:03:31,760 --> 00:03:32,959
workloads

95
00:03:32,959 --> 00:03:34,480
and then we might have c advisor or

96
00:03:34,480 --> 00:03:36,159
other monitoring tools to be able to

97
00:03:36,159 --> 00:03:38,959
look at how kubernetes is running and

98
00:03:38,959 --> 00:03:41,200
keep track of how it's going

99
00:03:41,200 --> 00:03:43,120
now that's great that's that's a really

100
00:03:43,120 --> 00:03:44,720
cool architectural diagram of how

101
00:03:44,720 --> 00:03:47,040
kubernetes works

102
00:03:47,040 --> 00:03:49,040
what we notice is that kubernetes is

103
00:03:49,040 --> 00:03:50,560
really worried about protecting

104
00:03:50,560 --> 00:03:53,360
kubernetes restarting processes when

105
00:03:53,360 --> 00:03:55,519
they're not running but there's nothing

106
00:03:55,519 --> 00:03:57,760
about security baked into that process

107
00:03:57,760 --> 00:04:02,000
nothing about protecting our process

108
00:04:02,000 --> 00:04:03,920
okay so if it's not in kubernetes let's

109
00:04:03,920 --> 00:04:05,840
look in docker here's docker and we've

110
00:04:05,840 --> 00:04:07,439
seen this diagram where we're comparing

111
00:04:07,439 --> 00:04:09,920
dockers to virtual machines on the left

112
00:04:09,920 --> 00:04:12,000
we have a traditional virtual machine

113
00:04:12,000 --> 00:04:14,000
set up on the right we have docker we

114
00:04:14,000 --> 00:04:15,680
can talk about the different hypervisors

115
00:04:15,680 --> 00:04:17,839
that we have where on the left we might

116
00:04:17,839 --> 00:04:21,040
be using zen or vmware on the right

117
00:04:21,040 --> 00:04:23,680
we're using the docker hypervisor the

118
00:04:23,680 --> 00:04:26,880
osi compliant container runtime

119
00:04:26,880 --> 00:04:28,479
and then we can talk about how we have

120
00:04:28,479 --> 00:04:31,840
guest os's versus just virtualizing the

121
00:04:31,840 --> 00:04:33,600
operating system and just having the

122
00:04:33,600 --> 00:04:36,160
content for our particular container

123
00:04:36,160 --> 00:04:39,680
yeah we do have a sandbox we do have a

124
00:04:39,680 --> 00:04:41,759
unique hostname an ip address for each

125
00:04:41,759 --> 00:04:43,919
container to be able to interact with

126
00:04:43,919 --> 00:04:45,759
other things we need to reach out on the

127
00:04:45,759 --> 00:04:47,680
network we're not just reaching into

128
00:04:47,680 --> 00:04:49,120
other processes

129
00:04:49,120 --> 00:04:50,320
we have

130
00:04:50,320 --> 00:04:52,400
sandboxing

131
00:04:52,400 --> 00:04:54,639
but once i have a process running in any

132
00:04:54,639 --> 00:04:56,960
container i can just use network

133
00:04:56,960 --> 00:04:58,400
discovery to find all the other

134
00:04:58,400 --> 00:05:00,720
containers and start pivoting into those

135
00:05:00,720 --> 00:05:02,479
containers

136
00:05:02,479 --> 00:05:04,560
yeah docker again is going to protect

137
00:05:04,560 --> 00:05:07,039
docker not protect the workloads running

138
00:05:07,039 --> 00:05:10,080
inside of our containers

139
00:05:10,080 --> 00:05:11,600
kubernetes

140
00:05:11,600 --> 00:05:13,759
kubernetes is basically a cluster of

141
00:05:13,759 --> 00:05:15,199
machines

142
00:05:15,199 --> 00:05:16,000
where

143
00:05:16,000 --> 00:05:17,680
it

144
00:05:17,680 --> 00:05:20,160
takes care of keeping its micro services

145
00:05:20,160 --> 00:05:21,360
running

146
00:05:21,360 --> 00:05:22,720
if we want to think about it in a

147
00:05:22,720 --> 00:05:24,960
security context we might think of it as

148
00:05:24,960 --> 00:05:26,639
a firewall

149
00:05:26,639 --> 00:05:28,960
in front of our containers

150
00:05:28,960 --> 00:05:31,199
yeah we're kind of misusing cube proxy

151
00:05:31,199 --> 00:05:34,000
and the api server in that respect but

152
00:05:34,000 --> 00:05:35,280
at best

153
00:05:35,280 --> 00:05:37,600
it is a firewall

154
00:05:37,600 --> 00:05:39,039
we're only getting the particular

155
00:05:39,039 --> 00:05:40,639
traffic on the particular ports that

156
00:05:40,639 --> 00:05:42,160
we've subscribed to

157
00:05:42,160 --> 00:05:45,759
but we're getting all of that traffic

158
00:05:45,759 --> 00:05:48,160
kubernetes can't secure the process in

159
00:05:48,160 --> 00:05:49,600
the containers

160
00:05:49,600 --> 00:05:52,080
kubernetes focuses on securing

161
00:05:52,080 --> 00:05:54,080
kubernetes

162
00:05:54,080 --> 00:05:56,560
by comparison when we look at docker

163
00:05:56,560 --> 00:05:59,199
docker has a file system it has users it

164
00:05:59,199 --> 00:06:02,560
has processes it has ports

165
00:06:02,560 --> 00:06:03,360
wow

166
00:06:03,360 --> 00:06:06,400
this kind of looks familiar

167
00:06:06,400 --> 00:06:07,919
this looks a lot like

168
00:06:07,919 --> 00:06:09,440
a linux machine

169
00:06:09,440 --> 00:06:12,400
a linux machine has users and ports and

170
00:06:12,400 --> 00:06:15,440
processes and file system

171
00:06:15,440 --> 00:06:17,520
so yeah there's a lot that we can do to

172
00:06:17,520 --> 00:06:20,160
secure our container process in the same

173
00:06:20,160 --> 00:06:22,479
way that we would think of securing a

174
00:06:22,479 --> 00:06:25,120
linux machine

175
00:06:25,120 --> 00:06:27,600
well kind of a docker container is a

176
00:06:27,600 --> 00:06:29,919
linux machine except for its ephemeral

177
00:06:29,919 --> 00:06:32,400
isomorphic and deterministic

178
00:06:32,400 --> 00:06:34,479
it will start up every time

179
00:06:34,479 --> 00:06:37,280
it's designed to be short-lived and it's

180
00:06:37,280 --> 00:06:39,919
designed to get killed off and restarted

181
00:06:39,919 --> 00:06:41,759
as we build one we're going to build it

182
00:06:41,759 --> 00:06:44,160
in the identical way every time

183
00:06:44,160 --> 00:06:46,560
we have short-lived unchanging and

184
00:06:46,560 --> 00:06:49,199
identical containers

185
00:06:49,199 --> 00:06:52,560
ephemeral isomorphic and deterministic

186
00:06:52,560 --> 00:06:54,160
so some of the techniques that we might

187
00:06:54,160 --> 00:06:56,639
use to secure containers might be

188
00:06:56,639 --> 00:06:58,160
different than the techniques that we

189
00:06:58,160 --> 00:07:00,560
would use to secure a typical linux

190
00:07:00,560 --> 00:07:03,560
machine

191
00:07:04,080 --> 00:07:06,000
so by default

192
00:07:06,000 --> 00:07:08,240
every container can communicate with

193
00:07:08,240 --> 00:07:10,880
every other container

194
00:07:10,880 --> 00:07:13,280
yeah i just do network discovery whether

195
00:07:13,280 --> 00:07:15,840
i'm on docker or on kubernetes and i can

196
00:07:15,840 --> 00:07:17,680
just discover all of the other ip

197
00:07:17,680 --> 00:07:20,080
addresses and i can launch attacks at

198
00:07:20,080 --> 00:07:22,160
those other containers the moment that i

199
00:07:22,160 --> 00:07:24,560
get inside of a container is the moment

200
00:07:24,560 --> 00:07:26,000
that i can pivot to every other

201
00:07:26,000 --> 00:07:27,280
container

202
00:07:27,280 --> 00:07:29,599
oh but we have kubernetes namespaces i

203
00:07:29,599 --> 00:07:31,360
can't launch a process in a namespace

204
00:07:31,360 --> 00:07:33,680
that i don't have permission to

205
00:07:33,680 --> 00:07:36,479
yeah but once i do launch the process in

206
00:07:36,479 --> 00:07:38,400
a namespace i have permission to i can

207
00:07:38,400 --> 00:07:39,759
then pivot to all of the other

208
00:07:39,759 --> 00:07:42,000
namespaces namespaces are an

209
00:07:42,000 --> 00:07:44,800
organizational boundary they are not a

210
00:07:44,800 --> 00:07:47,840
security boundary

211
00:07:48,400 --> 00:07:50,719
yeah

212
00:07:51,039 --> 00:07:53,680
so how do i secure a container

213
00:07:53,680 --> 00:07:56,000
well it's interesting if i can pop any

214
00:07:56,000 --> 00:07:58,160
of the containers in the stack i can now

215
00:07:58,160 --> 00:08:00,479
pivot to any other container in the

216
00:08:00,479 --> 00:08:02,878
stack

217
00:08:04,160 --> 00:08:06,319
when we take a look at threat vectors

218
00:08:06,319 --> 00:08:08,639
towards containers we can kind of think

219
00:08:08,639 --> 00:08:12,080
of things a cve and installed software

220
00:08:12,080 --> 00:08:14,560
maybe a custom app has a vulnerability

221
00:08:14,560 --> 00:08:17,199
maybe it's excessive permissions maybe

222
00:08:17,199 --> 00:08:19,039
my app is running inside the container's

223
00:08:19,039 --> 00:08:22,000
root maybe i've exposed secrets we can

224
00:08:22,000 --> 00:08:24,960
kind of centralize these into maybe two

225
00:08:24,960 --> 00:08:27,280
major attack vectors something from

226
00:08:27,280 --> 00:08:28,400
underneath

227
00:08:28,400 --> 00:08:30,720
and something from outside

228
00:08:30,720 --> 00:08:33,200
and then once they're in either from

229
00:08:33,200 --> 00:08:35,360
underneath or from outside what can they

230
00:08:35,360 --> 00:08:37,200
pivot to

231
00:08:37,200 --> 00:08:38,880
well we've seen that once they take down

232
00:08:38,880 --> 00:08:40,640
this container they can pivot to all the

233
00:08:40,640 --> 00:08:43,360
other containers and so now they can

234
00:08:43,360 --> 00:08:46,800
continue to attack other things

235
00:08:46,800 --> 00:08:49,360
so the good news is now when i have an

236
00:08:49,360 --> 00:08:52,000
infected machine an infected container

237
00:08:52,000 --> 00:08:53,440
it's ephemeral isomorphic and

238
00:08:53,440 --> 00:08:54,959
deterministic

239
00:08:54,959 --> 00:08:58,080
its goal is to get replaced so

240
00:08:58,080 --> 00:09:00,000
i just fling off that container and i

241
00:09:00,000 --> 00:09:01,600
spin up a new one and the effect

242
00:09:01,600 --> 00:09:03,920
infection is gone

243
00:09:03,920 --> 00:09:05,839
in that container it may still be in the

244
00:09:05,839 --> 00:09:08,320
cluster so i may have to spin up all of

245
00:09:08,320 --> 00:09:10,640
the containers anew to be able to rid

246
00:09:10,640 --> 00:09:14,399
myself of this and to that end is the

247
00:09:14,399 --> 00:09:16,800
infection pivoting around my containers

248
00:09:16,800 --> 00:09:18,480
maybe i need to shut it all down and

249
00:09:18,480 --> 00:09:21,040
spin it all back up or if i'm using

250
00:09:21,040 --> 00:09:22,959
infrastructure as code throw away the

251
00:09:22,959 --> 00:09:24,800
entire cluster and spin up a new cluster

252
00:09:24,800 --> 00:09:26,880
to be able to get rid of the infection

253
00:09:26,880 --> 00:09:28,959
but

254
00:09:28,959 --> 00:09:31,200
i don't need to scrub my machine i don't

255
00:09:31,200 --> 00:09:33,200
need to run a virus scanner on my

256
00:09:33,200 --> 00:09:35,839
software on my container it's not

257
00:09:35,839 --> 00:09:39,120
designed to work that way

258
00:09:40,000 --> 00:09:42,640
so how do we test our container validate

259
00:09:42,640 --> 00:09:44,959
that our software works as expected

260
00:09:44,959 --> 00:09:47,279
we might run unit and integration tests

261
00:09:47,279 --> 00:09:49,440
we might run static analysis on our

262
00:09:49,440 --> 00:09:51,519
source code maybe we're doing a machine

263
00:09:51,519 --> 00:09:53,920
inventory for known vulnerabilities

264
00:09:53,920 --> 00:09:54,959
let's

265
00:09:54,959 --> 00:09:56,800
identify all the software running on our

266
00:09:56,800 --> 00:09:58,480
machine and compare that to a

267
00:09:58,480 --> 00:10:00,399
vulnerability database

268
00:10:00,399 --> 00:10:01,920
we probably need to do open source

269
00:10:01,920 --> 00:10:04,480
license validation let's go collect all

270
00:10:04,480 --> 00:10:06,640
the licenses of all the packages and

271
00:10:06,640 --> 00:10:08,480
validate that we're not exceeding any of

272
00:10:08,480 --> 00:10:09,839
those licenses

273
00:10:09,839 --> 00:10:11,200
and then ultimately we'll take the

274
00:10:11,200 --> 00:10:13,200
results of those four steps and we'll

275
00:10:13,200 --> 00:10:16,640
give ourselves a go or no go scenario

276
00:10:16,640 --> 00:10:18,079
let's validate this against our

277
00:10:18,079 --> 00:10:20,880
corporate policy

278
00:10:22,640 --> 00:10:24,160
unit tests

279
00:10:24,160 --> 00:10:25,839
integration tests

280
00:10:25,839 --> 00:10:28,000
um there's not much that i can say about

281
00:10:28,000 --> 00:10:28,959
this

282
00:10:28,959 --> 00:10:30,320
they're important

283
00:10:30,320 --> 00:10:34,480
you need to do it moving on

284
00:10:34,640 --> 00:10:36,560
static code analysis i'm not here to

285
00:10:36,560 --> 00:10:39,200
sell particular software but as you grab

286
00:10:39,200 --> 00:10:41,120
these slides from robrich.org you can

287
00:10:41,120 --> 00:10:43,279
click on any of these blue links to

288
00:10:43,279 --> 00:10:44,880
learn more about these particular

289
00:10:44,880 --> 00:10:46,959
software and maybe that will give you

290
00:10:46,959 --> 00:10:48,720
the search terms that you need to be

291
00:10:48,720 --> 00:10:50,320
able to discover the static code

292
00:10:50,320 --> 00:10:52,720
analysis software that works exactly as

293
00:10:52,720 --> 00:10:55,440
you expect

294
00:10:55,839 --> 00:10:56,800
next

295
00:10:56,800 --> 00:10:58,880
license analysis here's some more

296
00:10:58,880 --> 00:11:00,640
software packages that'll get you the

297
00:11:00,640 --> 00:11:03,040
search terms uh white source and black

298
00:11:03,040 --> 00:11:04,880
duck will get you to the point where you

299
00:11:04,880 --> 00:11:06,560
can discover other pieces that may

300
00:11:06,560 --> 00:11:08,800
exactly work for you

301
00:11:08,800 --> 00:11:11,120
so we've run our unit tests we've run

302
00:11:11,120 --> 00:11:13,360
our static analysis we've done our

303
00:11:13,360 --> 00:11:15,200
license analysis

304
00:11:15,200 --> 00:11:17,600
and now we go into this go or no go

305
00:11:17,600 --> 00:11:19,279
scenario

306
00:11:19,279 --> 00:11:20,800
so let's take the results of the unit

307
00:11:20,800 --> 00:11:22,480
test let's take the results of our

308
00:11:22,480 --> 00:11:24,079
license compliance let's take the

309
00:11:24,079 --> 00:11:26,000
results of our static code analysis and

310
00:11:26,000 --> 00:11:27,519
let's decide if the software is good

311
00:11:27,519 --> 00:11:29,600
enough to deploy

312
00:11:29,600 --> 00:11:31,279
now it's really easy at this point for

313
00:11:31,279 --> 00:11:33,279
us to go hey if there are any

314
00:11:33,279 --> 00:11:35,519
vulnerabilities at all if there are any

315
00:11:35,519 --> 00:11:37,279
failing tests at all

316
00:11:37,279 --> 00:11:40,720
we should not deploy it all

317
00:11:40,720 --> 00:11:42,880
well what happens

318
00:11:42,880 --> 00:11:45,920
if i have a situation

319
00:11:45,920 --> 00:11:48,640
where there's a disease

320
00:11:48,640 --> 00:11:51,600
without a cure

321
00:11:51,920 --> 00:11:57,079
should we not deploy what's better

322
00:11:58,480 --> 00:12:00,240
it's hard for us to say

323
00:12:00,240 --> 00:12:02,399
we shouldn't deploy at all if there are

324
00:12:02,399 --> 00:12:04,240
any failing unit tests

325
00:12:04,240 --> 00:12:06,720
if the production server is using is

326
00:12:06,720 --> 00:12:10,720
losing thousands of dollars per second

327
00:12:10,720 --> 00:12:13,200
just push it out the door

328
00:12:13,200 --> 00:12:15,200
i know it may not be perfect but it's

329
00:12:15,200 --> 00:12:17,519
probably better than what we have

330
00:12:17,519 --> 00:12:20,079
alternatively maybe our policy is very

331
00:12:20,079 --> 00:12:23,120
specific and uh identical there to say

332
00:12:23,120 --> 00:12:24,880
if there are any concerns in our

333
00:12:24,880 --> 00:12:28,079
software it is not good enough to deploy

334
00:12:28,079 --> 00:12:29,680
well what if

335
00:12:29,680 --> 00:12:33,440
the software running is bad and the

336
00:12:33,440 --> 00:12:37,440
software that we just built is also bad

337
00:12:37,440 --> 00:12:39,200
now do we just

338
00:12:39,200 --> 00:12:41,519
shut it down

339
00:12:41,519 --> 00:12:44,240
do we hubble along

340
00:12:44,240 --> 00:12:48,160
which worse is more worse

341
00:12:48,160 --> 00:12:49,920
this is not just a binary switch we

342
00:12:49,920 --> 00:12:52,320
can't just say there is a failing test

343
00:12:52,320 --> 00:12:54,800
we must not deploy

344
00:12:54,800 --> 00:12:56,560
there are certain scenarios where

345
00:12:56,560 --> 00:13:00,399
deploying anyway is still tolerable

346
00:13:01,760 --> 00:13:04,639
so how we doing

347
00:13:05,120 --> 00:13:06,639
thus far we've talked about pretty

348
00:13:06,639 --> 00:13:09,680
standard stuff unit testing integration

349
00:13:09,680 --> 00:13:13,279
testing policy validation

350
00:13:13,279 --> 00:13:15,680
static code analysis so where's the

351
00:13:15,680 --> 00:13:17,519
server list where's the container in

352
00:13:17,519 --> 00:13:20,000
this

353
00:13:20,000 --> 00:13:21,040
yeah

354
00:13:21,040 --> 00:13:24,800
let's pivot into that container scanning

355
00:13:24,800 --> 00:13:27,839
container scanning is the process of

356
00:13:27,839 --> 00:13:29,600
looking through our container to

357
00:13:29,600 --> 00:13:31,440
identify all of the software that is

358
00:13:31,440 --> 00:13:32,880
installed in it

359
00:13:32,880 --> 00:13:34,959
cataloging that software together with

360
00:13:34,959 --> 00:13:36,399
its version

361
00:13:36,399 --> 00:13:38,880
and then comparing that software list to

362
00:13:38,880 --> 00:13:42,000
a list of known vulnerabilities

363
00:13:42,000 --> 00:13:44,720
now the cool part is as we go grab that

364
00:13:44,720 --> 00:13:46,800
list of installed software we don't need

365
00:13:46,800 --> 00:13:49,279
to rescan our container again because

366
00:13:49,279 --> 00:13:50,800
it's ephemeral isomorphic and

367
00:13:50,800 --> 00:13:53,199
deterministic it doesn't change once we

368
00:13:53,199 --> 00:13:54,880
know the software that's installed on

369
00:13:54,880 --> 00:13:56,800
our container we know

370
00:13:56,800 --> 00:13:59,600
if that we know all of the content there

371
00:13:59,600 --> 00:14:01,600
now it's possible that other content

372
00:14:01,600 --> 00:14:02,720
could be

373
00:14:02,720 --> 00:14:04,880
installed on our container

374
00:14:04,880 --> 00:14:06,880
log4j but

375
00:14:06,880 --> 00:14:08,959
if that's the concern we need to kill

376
00:14:08,959 --> 00:14:10,959
off that container and spin up a new one

377
00:14:10,959 --> 00:14:12,880
that's the benefit of ephemeral

378
00:14:12,880 --> 00:14:16,079
isomorphic and deterministic hardware

379
00:14:16,079 --> 00:14:18,399
so container scanning we go grab a list

380
00:14:18,399 --> 00:14:20,079
of all of the software together with its

381
00:14:20,079 --> 00:14:22,560
versions and we compare that against a

382
00:14:22,560 --> 00:14:25,760
vulnerability database

383
00:14:26,720 --> 00:14:28,560
so when should we scan

384
00:14:28,560 --> 00:14:30,959
now the scanning process does take some

385
00:14:30,959 --> 00:14:33,040
time we basically need to go look

386
00:14:33,040 --> 00:14:35,279
through the os going and grabbing apt

387
00:14:35,279 --> 00:14:37,920
packages or

388
00:14:37,920 --> 00:14:40,560
dev archives we need to look through our

389
00:14:40,560 --> 00:14:43,440
software looking for the packages and

390
00:14:43,440 --> 00:14:45,199
libraries that we downloaded perhaps

391
00:14:45,199 --> 00:14:48,240
that's through npm or through gem and we

392
00:14:48,240 --> 00:14:51,199
need to then collect all of that content

393
00:14:51,199 --> 00:14:53,360
into a place so

394
00:14:53,360 --> 00:14:55,279
maybe it takes 10 minutes

395
00:14:55,279 --> 00:14:57,360
now if the goal of our build is to run

396
00:14:57,360 --> 00:15:00,240
in 10 minutes then can we

397
00:15:00,240 --> 00:15:02,160
run it in the build

398
00:15:02,160 --> 00:15:04,000
maybe we can start it in our build

399
00:15:04,000 --> 00:15:06,320
process and that's great but maybe we

400
00:15:06,320 --> 00:15:08,399
can't wait for it to finish

401
00:15:08,399 --> 00:15:11,199
in our build process

402
00:15:11,199 --> 00:15:12,639
next up we could

403
00:15:12,639 --> 00:15:14,959
as we publish our containers into our

404
00:15:14,959 --> 00:15:17,040
private container registry we could run

405
00:15:17,040 --> 00:15:18,880
a scan on all the software in that

406
00:15:18,880 --> 00:15:21,199
container registry let's look for all of

407
00:15:21,199 --> 00:15:22,639
our new containers that we don't know

408
00:15:22,639 --> 00:15:24,839
their contents yet and let's go run that

409
00:15:24,839 --> 00:15:28,240
scan once we've identified the software

410
00:15:28,240 --> 00:15:30,560
in each container we can compare that to

411
00:15:30,560 --> 00:15:33,040
our vulnerability database and we can

412
00:15:33,040 --> 00:15:34,720
also compare that to all of the

413
00:15:34,720 --> 00:15:36,800
containers that already exist

414
00:15:36,800 --> 00:15:39,279
when there's a new vulnerability in

415
00:15:39,279 --> 00:15:42,160
detected in the world we can go look

416
00:15:42,160 --> 00:15:44,320
through our inventory of running

417
00:15:44,320 --> 00:15:46,480
containers and all the software running

418
00:15:46,480 --> 00:15:47,839
on them

419
00:15:47,839 --> 00:15:50,240
which one has log4j in it

420
00:15:50,240 --> 00:15:52,320
we know exactly which one has log for j

421
00:15:52,320 --> 00:15:54,160
we inventoried all of our containers

422
00:15:54,160 --> 00:15:56,160
that's perfect

423
00:15:56,160 --> 00:15:58,240
so we could scan the container registry

424
00:15:58,240 --> 00:15:59,759
now the cool part about scanning the

425
00:15:59,759 --> 00:16:02,240
container registry is that

426
00:16:02,240 --> 00:16:04,720
we capture all of the things that are

427
00:16:04,720 --> 00:16:06,959
built now if we grabbed it in the build

428
00:16:06,959 --> 00:16:08,800
pipeline then that's perfect but the

429
00:16:08,800 --> 00:16:10,639
assumption of scanning inside the build

430
00:16:10,639 --> 00:16:12,720
pipeline is that everything runs through

431
00:16:12,720 --> 00:16:14,639
the build pipeline

432
00:16:14,639 --> 00:16:16,000
are you running any off-the-shelf

433
00:16:16,000 --> 00:16:17,199
containers

434
00:16:17,199 --> 00:16:19,920
nginx or redis

435
00:16:19,920 --> 00:16:21,199
those didn't go through your build

436
00:16:21,199 --> 00:16:22,800
pipeline

437
00:16:22,800 --> 00:16:24,720
so we can't just assume that the build

438
00:16:24,720 --> 00:16:26,880
pipeline will catch everything so we

439
00:16:26,880 --> 00:16:29,519
might look to our container registry

440
00:16:29,519 --> 00:16:31,360
now the assumption of scanning our

441
00:16:31,360 --> 00:16:33,040
container registry is that everything

442
00:16:33,040 --> 00:16:35,360
flows through our container registry

443
00:16:35,360 --> 00:16:37,600
are we pulling anything from docker hub

444
00:16:37,600 --> 00:16:39,759
or any other public registries do our

445
00:16:39,759 --> 00:16:41,680
helm charts reach into any public

446
00:16:41,680 --> 00:16:44,800
repositories if so then

447
00:16:44,800 --> 00:16:46,800
maybe the container registry isn't

448
00:16:46,800 --> 00:16:47,920
enough

449
00:16:47,920 --> 00:16:49,680
or maybe we have a corporate policy that

450
00:16:49,680 --> 00:16:51,519
says let's pull them from all those

451
00:16:51,519 --> 00:16:54,240
external resources and cache them in our

452
00:16:54,240 --> 00:16:57,519
local repository as well

453
00:16:57,519 --> 00:16:59,839
so next we could look at kubernetes web

454
00:16:59,839 --> 00:17:01,600
hooks let's come back to that one

455
00:17:01,600 --> 00:17:03,680
because that one is really interesting

456
00:17:03,680 --> 00:17:05,839
and final finally we can take a look at

457
00:17:05,839 --> 00:17:08,799
all of the clusters running in our

458
00:17:08,799 --> 00:17:10,079
all the containers running in our

459
00:17:10,079 --> 00:17:11,679
cluster

460
00:17:11,679 --> 00:17:12,880
now if we're looking at all of the

461
00:17:12,880 --> 00:17:15,199
containers in our cluster arguably it's

462
00:17:15,199 --> 00:17:17,520
too late it's already running

463
00:17:17,520 --> 00:17:20,240
but if we pulled things from an external

464
00:17:20,240 --> 00:17:22,559
registry or if we

465
00:17:22,559 --> 00:17:24,720
pulled them if we built them in another

466
00:17:24,720 --> 00:17:26,640
process then maybe this is the first

467
00:17:26,640 --> 00:17:28,640
time we've seen that container

468
00:17:28,640 --> 00:17:29,840
so

469
00:17:29,840 --> 00:17:31,760
maybe we need to run our container scan

470
00:17:31,760 --> 00:17:33,520
here too

471
00:17:33,520 --> 00:17:35,520
now the cool part is because these are

472
00:17:35,520 --> 00:17:37,280
deterministic hardware they're going to

473
00:17:37,280 --> 00:17:40,240
be identical every time if we've scanned

474
00:17:40,240 --> 00:17:43,280
that docker image hash we already know

475
00:17:43,280 --> 00:17:45,840
the content that's in that image and so

476
00:17:45,840 --> 00:17:47,520
let's quickly run through our list of

477
00:17:47,520 --> 00:17:50,000
containers identify the image id for

478
00:17:50,000 --> 00:17:51,840
each one identify if we have the

479
00:17:51,840 --> 00:17:53,840
software there and if so then we've

480
00:17:53,840 --> 00:17:55,520
already scanned it we're good

481
00:17:55,520 --> 00:17:57,200
that scan doesn't take 10 minutes that

482
00:17:57,200 --> 00:18:00,240
scan takes 10 milliseconds that's pretty

483
00:18:00,240 --> 00:18:01,600
nice

484
00:18:01,600 --> 00:18:04,559
so maybe we put our skin into

485
00:18:04,559 --> 00:18:06,960
all of these places

486
00:18:06,960 --> 00:18:08,799
now yeah if we don't know what this

487
00:18:08,799 --> 00:18:10,960
container is yet it may take 10 minutes

488
00:18:10,960 --> 00:18:12,880
to inventory it but once we've

489
00:18:12,880 --> 00:18:15,440
identified the contents in our container

490
00:18:15,440 --> 00:18:16,559
we can compare that with our

491
00:18:16,559 --> 00:18:18,400
vulnerability database and we know if

492
00:18:18,400 --> 00:18:20,720
it's time to evict this container

493
00:18:20,720 --> 00:18:23,360
and take appropriate action

494
00:18:23,360 --> 00:18:25,280
let's double click into kubernetes web

495
00:18:25,280 --> 00:18:27,280
hooks because that's really fun

496
00:18:27,280 --> 00:18:30,080
here's the process a container or in

497
00:18:30,080 --> 00:18:32,080
this case a pod goes through as it

498
00:18:32,080 --> 00:18:33,360
launches

499
00:18:33,360 --> 00:18:35,200
now we have a whole lot of internal

500
00:18:35,200 --> 00:18:37,440
pieces inside of kubernetes that takes

501
00:18:37,440 --> 00:18:38,960
care of getting

502
00:18:38,960 --> 00:18:41,120
from one step to another but we do have

503
00:18:41,120 --> 00:18:43,120
two spots where it reaches out to

504
00:18:43,120 --> 00:18:45,360
external services the first one is the

505
00:18:45,360 --> 00:18:47,520
mutating admission web hook the second

506
00:18:47,520 --> 00:18:51,440
one is the validating admission web hook

507
00:18:51,440 --> 00:18:53,840
in the mutating admission web hook it

508
00:18:53,840 --> 00:18:57,200
sends the yaml or in this case json to

509
00:18:57,200 --> 00:18:58,480
each

510
00:18:58,480 --> 00:19:00,960
subscribed api and says would you like

511
00:19:00,960 --> 00:19:03,120
to change this this is a great place to

512
00:19:03,120 --> 00:19:07,600
inject side cars perhaps inject

513
00:19:07,840 --> 00:19:10,160
references to secrets this is the

514
00:19:10,160 --> 00:19:12,960
perfect place to get that yaml up to

515
00:19:12,960 --> 00:19:14,160
speed

516
00:19:14,160 --> 00:19:15,760
the next place is the validating web

517
00:19:15,760 --> 00:19:18,080
hook and that's where it calls all of

518
00:19:18,080 --> 00:19:21,280
the subscribed web hooks in parallel and

519
00:19:21,280 --> 00:19:22,880
says here's what i'm going to launch go

520
00:19:22,880 --> 00:19:25,120
or no go

521
00:19:25,120 --> 00:19:26,960
hey that sounds familiar

522
00:19:26,960 --> 00:19:28,720
let's put that right here let's put our

523
00:19:28,720 --> 00:19:31,440
container scan results right here if

524
00:19:31,440 --> 00:19:34,240
we've seen the container before if we've

525
00:19:34,240 --> 00:19:36,160
scanned its contents and identified if

526
00:19:36,160 --> 00:19:38,160
this container is good or not we can

527
00:19:38,160 --> 00:19:40,240
make the choice right here we can say

528
00:19:40,240 --> 00:19:42,160
nope this container is not good enough

529
00:19:42,160 --> 00:19:43,760
to run we're not going to schedule this

530
00:19:43,760 --> 00:19:45,039
pod

531
00:19:45,039 --> 00:19:47,919
the beauty of putting it right here

532
00:19:47,919 --> 00:19:50,960
is that it can't launch in our cluster

533
00:19:50,960 --> 00:19:53,039
if we don't give it permission to do so

534
00:19:53,039 --> 00:19:55,360
here in this validating web hook

535
00:19:55,360 --> 00:19:57,280
now if we haven't seen this container

536
00:19:57,280 --> 00:19:59,280
before and we're doing that 10 minute

537
00:19:59,280 --> 00:20:02,159
scan perhaps the validating admission

538
00:20:02,159 --> 00:20:04,720
web hook is going to time out so perhaps

539
00:20:04,720 --> 00:20:07,280
we say no and then it reschedules it in

540
00:20:07,280 --> 00:20:09,120
a minute or five minutes and then maybe

541
00:20:09,120 --> 00:20:10,880
we finished by then so then we can say

542
00:20:10,880 --> 00:20:11,919
yes

543
00:20:11,919 --> 00:20:14,880
so there's uh there's some concerns to

544
00:20:14,880 --> 00:20:17,760
if we've just barely seen this container

545
00:20:17,760 --> 00:20:19,520
right here in the validating admission

546
00:20:19,520 --> 00:20:22,159
web hook we might have some pods that

547
00:20:22,159 --> 00:20:23,919
don't schedule correctly because we

548
00:20:23,919 --> 00:20:26,080
haven't scanned them yet

549
00:20:26,080 --> 00:20:27,919
but if we have scanned them in the

550
00:20:27,919 --> 00:20:30,559
registry or begun the scan inside the

551
00:20:30,559 --> 00:20:32,799
devops pipeline then by the time we get

552
00:20:32,799 --> 00:20:35,200
here we're really only validating that

553
00:20:35,200 --> 00:20:37,679
the software in our list meets our

554
00:20:37,679 --> 00:20:41,200
policy of exposed vulnerabilities

555
00:20:41,200 --> 00:20:43,360
that's perfect

556
00:20:43,360 --> 00:20:45,840
so we've now gotten a process where we

557
00:20:45,840 --> 00:20:48,159
can take a look at all of the software

558
00:20:48,159 --> 00:20:50,799
inside of our container we can catalog

559
00:20:50,799 --> 00:20:52,880
that together with the container image

560
00:20:52,880 --> 00:20:55,200
id and all of the versions of all of

561
00:20:55,200 --> 00:20:56,559
that software

562
00:20:56,559 --> 00:20:57,840
then let's compare that to a

563
00:20:57,840 --> 00:20:59,679
vulnerability database

564
00:20:59,679 --> 00:21:01,120
now once again i'm not here to sell

565
00:21:01,120 --> 00:21:03,840
software but here's a list of tools that

566
00:21:03,840 --> 00:21:05,600
you might want to choose

567
00:21:05,600 --> 00:21:07,760
this will definitely get you past the

568
00:21:07,760 --> 00:21:10,000
blank page grab these slides from

569
00:21:10,000 --> 00:21:12,240
robrich.org and click through each one

570
00:21:12,240 --> 00:21:14,640
and see which one matches your needs

571
00:21:14,640 --> 00:21:16,960
either from a compliance standpoint or

572
00:21:16,960 --> 00:21:18,640
from just a preferences or comfort

573
00:21:18,640 --> 00:21:20,000
standpoint

574
00:21:20,000 --> 00:21:21,840
the one that's not listed if you do a

575
00:21:21,840 --> 00:21:24,080
docker scan command it will actually

576
00:21:24,080 --> 00:21:26,159
call into seek

577
00:21:26,159 --> 00:21:27,120
sneak

578
00:21:27,120 --> 00:21:29,039
which in hindsight i should update this

579
00:21:29,039 --> 00:21:31,919
slide and put in sneak

580
00:21:31,919 --> 00:21:33,440
now

581
00:21:33,440 --> 00:21:35,520
i don't want to pick one but for the

582
00:21:35,520 --> 00:21:37,200
sake of demos

583
00:21:37,200 --> 00:21:39,760
i'm going to pick anchor

584
00:21:39,760 --> 00:21:42,400
so let's talk about anchor more so about

585
00:21:42,400 --> 00:21:44,159
the methodology of how we would

586
00:21:44,159 --> 00:21:46,400
integrate container scanning into our

587
00:21:46,400 --> 00:21:47,840
process and less about the

588
00:21:47,840 --> 00:21:50,559
implementation of anchor but

589
00:21:50,559 --> 00:21:52,720
how do you get started with anker encore

590
00:21:52,720 --> 00:21:54,240
is free and open source part of the

591
00:21:54,240 --> 00:21:56,400
reason that i chose it here

592
00:21:56,400 --> 00:21:59,039
it runs as micro service containers so

593
00:21:59,039 --> 00:22:01,600
maybe you launch anker in your cluster

594
00:22:01,600 --> 00:22:03,520
maybe it's running in a dev cloud dev

595
00:22:03,520 --> 00:22:05,200
test cluster rather than your production

596
00:22:05,200 --> 00:22:07,760
cluster but it's great at being able to

597
00:22:07,760 --> 00:22:09,600
run through these things and because

598
00:22:09,600 --> 00:22:11,600
it's micro services then it'll probably

599
00:22:11,600 --> 00:22:13,200
fit really well with the other tools

600
00:22:13,200 --> 00:22:15,520
that you have running in your cluster

601
00:22:15,520 --> 00:22:17,520
now we'll do a software inventory both

602
00:22:17,520 --> 00:22:19,840
of operating system packages and app

603
00:22:19,840 --> 00:22:23,120
packages the cool part is if your app is

604
00:22:23,120 --> 00:22:25,280
a netapp for example and you're also

605
00:22:25,280 --> 00:22:27,440
pulling in some npm dependencies then

606
00:22:27,440 --> 00:22:28,640
you'll have

607
00:22:28,640 --> 00:22:30,720
os dependencies you'll have your

608
00:22:30,720 --> 00:22:32,880
applications dependencies in nuget and

609
00:22:32,880 --> 00:22:35,280
you'll also have your npm dependencies

610
00:22:35,280 --> 00:22:37,679
and it will catalog all three

611
00:22:37,679 --> 00:22:39,600
or perhaps you're running a ruby app or

612
00:22:39,600 --> 00:22:42,960
a python app it'll reach into those

613
00:22:42,960 --> 00:22:45,200
libraries as well

614
00:22:45,200 --> 00:22:46,880
once it's inventoried it's listed

615
00:22:46,880 --> 00:22:48,640
software it will compare that against

616
00:22:48,640 --> 00:22:50,240
the list of vulnerabilities in its

617
00:22:50,240 --> 00:22:53,840
database and you can now see what

618
00:22:53,840 --> 00:22:56,000
vulnerabilities exist in the libraries

619
00:22:56,000 --> 00:22:57,679
that you've chosen to consume

620
00:22:57,679 --> 00:23:00,080
now this doesn't say that your app is

621
00:23:00,080 --> 00:23:01,760
not vulnerable

622
00:23:01,760 --> 00:23:03,600
we had static code analysis that might

623
00:23:03,600 --> 00:23:05,919
tell us if our app is vulnerable but

624
00:23:05,919 --> 00:23:07,840
this tells us if our dependencies are

625
00:23:07,840 --> 00:23:10,320
vulnerable or rather if they're known to

626
00:23:10,320 --> 00:23:12,400
be vulnerable

627
00:23:12,400 --> 00:23:14,480
now anchor is not fast

628
00:23:14,480 --> 00:23:17,039
it takes about 10 minutes to run but you

629
00:23:17,039 --> 00:23:20,000
can cue it and then you can

630
00:23:20,000 --> 00:23:22,000
go on and do other things and then come

631
00:23:22,000 --> 00:23:24,320
back and get the results

632
00:23:24,320 --> 00:23:26,320
the anger docs are

633
00:23:26,320 --> 00:23:27,679
not great

634
00:23:27,679 --> 00:23:30,240
they do get it done though so if we head

635
00:23:30,240 --> 00:23:32,159
over to the anchor docs grab the slides

636
00:23:32,159 --> 00:23:33,919
from robrich.org and click on the blue

637
00:23:33,919 --> 00:23:36,240
link then we'll be able to download this

638
00:23:36,240 --> 00:23:39,360
docker compose file that gives us all of

639
00:23:39,360 --> 00:23:41,679
the details that we need to be able to

640
00:23:41,679 --> 00:23:45,360
spin up all of the anchor micro services

641
00:23:45,360 --> 00:23:47,840
either docker compose up or

642
00:23:47,840 --> 00:23:49,600
one then do the docker compose up that

643
00:23:49,600 --> 00:23:51,520
gets the things running

644
00:23:51,520 --> 00:23:53,919
flipping docker compose into

645
00:23:53,919 --> 00:23:57,840
kubernetes yaml files you could use um

646
00:23:57,840 --> 00:24:00,559
k compose and that will just convert it

647
00:24:00,559 --> 00:24:02,640
which is really nice

648
00:24:02,640 --> 00:24:04,480
once you've got it running then you

649
00:24:04,480 --> 00:24:06,559
could either use docker exec or you

650
00:24:06,559 --> 00:24:09,360
could pip install the anchor cli and now

651
00:24:09,360 --> 00:24:12,000
you have the anchor cli which is the way

652
00:24:12,000 --> 00:24:14,080
that you interact with anchor

653
00:24:14,080 --> 00:24:16,840
now some products expose rest apis some

654
00:24:16,840 --> 00:24:20,000
expose clis in this case i think the cli

655
00:24:20,000 --> 00:24:21,600
works out pretty well and then

656
00:24:21,600 --> 00:24:23,600
ultimately now that i have the cli i can

657
00:24:23,600 --> 00:24:25,840
run commands

658
00:24:25,840 --> 00:24:26,720
so

659
00:24:26,720 --> 00:24:28,960
our first step is to go grab that

660
00:24:28,960 --> 00:24:31,840
vulnerability list we run anchor cli

661
00:24:31,840 --> 00:24:33,279
system status

662
00:24:33,279 --> 00:24:36,320
and then anchor cli feeds list and when

663
00:24:36,320 --> 00:24:38,480
we list the feeds it notices that it

664
00:24:38,480 --> 00:24:40,159
doesn't have the definitions for each

665
00:24:40,159 --> 00:24:41,919
feed and it goes and tries to download

666
00:24:41,919 --> 00:24:43,440
them

667
00:24:43,440 --> 00:24:46,000
now it says in the docs it may take up

668
00:24:46,000 --> 00:24:48,799
to 10 minutes

669
00:24:50,320 --> 00:24:52,960
if only

670
00:24:56,559 --> 00:24:59,200
i began on

671
00:24:59,200 --> 00:25:01,279
um

672
00:25:01,279 --> 00:25:03,360
the 20th

673
00:25:03,360 --> 00:25:08,559
and i ended on the 23rd

674
00:25:08,799 --> 00:25:10,960
it was only 10 minutes right

675
00:25:10,960 --> 00:25:12,799
yeah it took me about a week

676
00:25:12,799 --> 00:25:15,679
well four days of it just running and

677
00:25:15,679 --> 00:25:17,679
cranking to go download all the feeds i

678
00:25:17,679 --> 00:25:19,840
don't know if my

679
00:25:19,840 --> 00:25:23,200
if my behavior is unusual but i did

680
00:25:23,200 --> 00:25:25,840
enjoy that in their docs

681
00:25:25,840 --> 00:25:28,799
in one spot it said it may take 10

682
00:25:28,799 --> 00:25:30,640
minutes and another spot it said it may

683
00:25:30,640 --> 00:25:33,520
take a few hours

684
00:25:34,159 --> 00:25:35,919
the cool part is once you've downloaded

685
00:25:35,919 --> 00:25:37,600
that vulnerability database you already

686
00:25:37,600 --> 00:25:39,520
have it and grabbing updates is really

687
00:25:39,520 --> 00:25:42,000
easy it just needs to grab the diff from

688
00:25:42,000 --> 00:25:43,520
what it had before

689
00:25:43,520 --> 00:25:45,679
but it's the vulnerability database for

690
00:25:45,679 --> 00:25:48,880
all the versions of linux alpine and red

691
00:25:48,880 --> 00:25:52,799
hat and ubuntu and others all of the

692
00:25:52,799 --> 00:25:58,240
package definitions nuget and npm and

693
00:25:58,240 --> 00:26:01,440
rubygems and maven and so it has a

694
00:26:01,440 --> 00:26:04,159
database for each of these registries

695
00:26:04,159 --> 00:26:07,360
and all of the packages that exist in it

696
00:26:07,360 --> 00:26:09,520
for all of the versions of linux which

697
00:26:09,520 --> 00:26:11,520
is really interesting

698
00:26:11,520 --> 00:26:14,640
so it's not a small data set

699
00:26:14,640 --> 00:26:16,960
okay so once we've got the anchor cli

700
00:26:16,960 --> 00:26:18,159
info

701
00:26:18,159 --> 00:26:20,320
available then we can start to kick off

702
00:26:20,320 --> 00:26:22,640
the commands that will do stuff

703
00:26:22,640 --> 00:26:24,240
now here's the commands that anker

704
00:26:24,240 --> 00:26:27,360
exposes we can say anchor cli image add

705
00:26:27,360 --> 00:26:29,919
that's how we start the process

706
00:26:29,919 --> 00:26:32,000
and that is non-blocking so it'll

707
00:26:32,000 --> 00:26:34,400
return immediately and we can then take

708
00:26:34,400 --> 00:26:36,640
additional action now if we choose to

709
00:26:36,640 --> 00:26:38,480
wait for the image maybe

710
00:26:38,480 --> 00:26:40,880
10 minutes isn't our ideal build time so

711
00:26:40,880 --> 00:26:43,600
we're okay with the scan running in

712
00:26:43,600 --> 00:26:45,919
series in our build then maybe we can

713
00:26:45,919 --> 00:26:48,799
kick that off and then just wait for it

714
00:26:48,799 --> 00:26:51,360
so ankar cli image wait we'll pass in

715
00:26:51,360 --> 00:26:54,400
the name of the image and that will then

716
00:26:54,400 --> 00:26:57,120
wait for that image to get scanned now

717
00:26:57,120 --> 00:26:59,200
we can go grab the summary anchor cli

718
00:26:59,200 --> 00:27:01,120
image get

719
00:27:01,120 --> 00:27:03,279
those details and it will give us kind

720
00:27:03,279 --> 00:27:06,000
of a quick summary of all of the things

721
00:27:06,000 --> 00:27:08,960
it output outputs in json by the way

722
00:27:08,960 --> 00:27:11,520
we could also ask for the vulnerability

723
00:27:11,520 --> 00:27:13,679
list rather than just the entire list

724
00:27:13,679 --> 00:27:15,520
and in that vulnerability list we can

725
00:27:15,520 --> 00:27:18,000
also pass in the types of things that we

726
00:27:18,000 --> 00:27:21,760
want the os npm gem etc in this case i

727
00:27:21,760 --> 00:27:23,919
chose to pass in all so it'll give me

728
00:27:23,919 --> 00:27:25,919
all of the vulnerabilities that it knows

729
00:27:25,919 --> 00:27:27,600
about all of the packages that i have

730
00:27:27,600 --> 00:27:30,080
installed all of the packages

731
00:27:30,080 --> 00:27:32,880
at my current version that are installed

732
00:27:32,880 --> 00:27:35,360
and then finally i could just grab the

733
00:27:35,360 --> 00:27:37,679
list of installed software now this is

734
00:27:37,679 --> 00:27:40,080
perfect go grab this list

735
00:27:40,080 --> 00:27:43,039
stick it in an external database

736
00:27:43,039 --> 00:27:46,159
together with the image hash and now

737
00:27:46,159 --> 00:27:49,039
whenever i want to identify is my system

738
00:27:49,039 --> 00:27:51,760
vulnerable i can go look through all of

739
00:27:51,760 --> 00:27:53,520
the running containers that i have go

740
00:27:53,520 --> 00:27:56,000
grab all their hashes grab a query in

741
00:27:56,000 --> 00:27:58,320
this database for all of the software

742
00:27:58,320 --> 00:28:00,320
installed in those hashes compare that

743
00:28:00,320 --> 00:28:02,000
with my vulnerability database and i

744
00:28:02,000 --> 00:28:05,919
know exactly my exposure level

745
00:28:06,159 --> 00:28:07,760
that query

746
00:28:07,760 --> 00:28:09,440
happened

747
00:28:09,440 --> 00:28:12,240
without touching the containers

748
00:28:12,240 --> 00:28:14,399
that's pretty cool

749
00:28:14,399 --> 00:28:16,240
wouldn't it be cool if the cto walks in

750
00:28:16,240 --> 00:28:17,440
and says okay we've got this new

751
00:28:17,440 --> 00:28:19,840
vulnerability which containers are are

752
00:28:19,840 --> 00:28:22,799
susceptible to this and we can say

753
00:28:22,799 --> 00:28:25,520
nope we're good

754
00:28:25,520 --> 00:28:27,360
that's pretty cool

755
00:28:27,360 --> 00:28:28,720
so

756
00:28:28,720 --> 00:28:32,000
we can also do this process with github

757
00:28:32,000 --> 00:28:34,799
actions now the beauty of using github

758
00:28:34,799 --> 00:28:36,880
actions as our build system is that it

759
00:28:36,880 --> 00:28:39,440
is uh cloud hosted and

760
00:28:39,440 --> 00:28:40,880
we can run a certain amount of builds

761
00:28:40,880 --> 00:28:42,000
for free

762
00:28:42,000 --> 00:28:44,240
and they will keep the vulnerability

763
00:28:44,240 --> 00:28:46,320
database up to date so that big

764
00:28:46,320 --> 00:28:48,080
week-long process of downloading the

765
00:28:48,080 --> 00:28:50,480
definitions that's already done

766
00:28:50,480 --> 00:28:52,640
that is nice

767
00:28:52,640 --> 00:28:53,520
so

768
00:28:53,520 --> 00:28:55,520
all of those commands about spinning it

769
00:28:55,520 --> 00:28:57,520
up and waiting and all those things got

770
00:28:57,520 --> 00:29:00,480
compressed into one github action where

771
00:29:00,480 --> 00:29:03,520
i just pass it the name of my image

772
00:29:03,520 --> 00:29:05,600
i could optionally pass it my list of my

773
00:29:05,600 --> 00:29:06,960
docker file

774
00:29:06,960 --> 00:29:09,440
include app packages of course

775
00:29:09,440 --> 00:29:11,520
and then they also have this fail build

776
00:29:11,520 --> 00:29:13,679
option which i couldn't get to work

777
00:29:13,679 --> 00:29:15,120
we'll see the experiments when we get to

778
00:29:15,120 --> 00:29:17,200
the demo but i kept passing in fail

779
00:29:17,200 --> 00:29:19,120
build true to say if you have a

780
00:29:19,120 --> 00:29:21,440
vulnerability of above this threshold

781
00:29:21,440 --> 00:29:23,200
then fail the build right here and it

782
00:29:23,200 --> 00:29:26,399
was like yeah that's good

783
00:29:26,399 --> 00:29:29,440
so it runs the scan and it out grabs the

784
00:29:29,440 --> 00:29:31,520
results and so now i'm going to go look

785
00:29:31,520 --> 00:29:34,399
in that anchor reports directory and i

786
00:29:34,399 --> 00:29:36,880
can just echo out the contents of each

787
00:29:36,880 --> 00:29:37,760
file

788
00:29:37,760 --> 00:29:39,679
now i'm going to specifically run this

789
00:29:39,679 --> 00:29:43,760
if always because if i've chosen to fail

790
00:29:43,760 --> 00:29:45,440
the build here

791
00:29:45,440 --> 00:29:48,799
then i run the results here on a failed

792
00:29:48,799 --> 00:29:50,159
build

793
00:29:50,159 --> 00:29:53,520
i would not have any results

794
00:29:53,520 --> 00:29:55,440
that would be bad

795
00:29:55,440 --> 00:29:58,080
hey the build's green here's the results

796
00:29:58,080 --> 00:30:01,120
the build failed sorry

797
00:30:01,919 --> 00:30:05,200
so let's dig in now i have uh links to

798
00:30:05,200 --> 00:30:08,000
both of these repositories right here

799
00:30:08,000 --> 00:30:10,399
let's pull those up on github the cool

800
00:30:10,399 --> 00:30:13,200
part about this repository is that the

801
00:30:13,200 --> 00:30:15,679
content of this

802
00:30:15,679 --> 00:30:18,399
github actions build is identical

803
00:30:18,399 --> 00:30:20,240
i just happen to check in a vulnerable

804
00:30:20,240 --> 00:30:23,279
library in one of the paths

805
00:30:23,279 --> 00:30:25,760
so we can see that this is the past one

806
00:30:25,760 --> 00:30:27,600
and here's my experiment of trying to

807
00:30:27,600 --> 00:30:30,000
get it to fail in interesting ways you

808
00:30:30,000 --> 00:30:32,799
know can i get it to fail on uh

809
00:30:32,799 --> 00:30:35,360
if fail true and so you can see that i

810
00:30:35,360 --> 00:30:37,520
failed a bit but ultimately this one

811
00:30:37,520 --> 00:30:40,399
passes which is excellent

812
00:30:40,399 --> 00:30:42,000
we could also take a look at this one

813
00:30:42,000 --> 00:30:44,000
and we can see that when i committed

814
00:30:44,000 --> 00:30:44,960
that

815
00:30:44,960 --> 00:30:47,360
vulnerable library i got this one to

816
00:30:47,360 --> 00:30:48,399
fail

817
00:30:48,399 --> 00:30:50,320
one thing that i noticed with encore is

818
00:30:50,320 --> 00:30:52,960
it doesn't enumerate all of the files on

819
00:30:52,960 --> 00:30:54,880
disk looking to see what library they

820
00:30:54,880 --> 00:30:57,519
were part of it only enumerates my

821
00:30:57,519 --> 00:31:00,480
package list my package manifest so it

822
00:31:00,480 --> 00:31:01,840
did great at looking at my

823
00:31:01,840 --> 00:31:03,679
packages.config

824
00:31:03,679 --> 00:31:06,320
for nuget and it did great at looking at

825
00:31:06,320 --> 00:31:10,240
my package.json for npm but if i just

826
00:31:10,240 --> 00:31:11,480
grabbed

827
00:31:11,480 --> 00:31:14,159
jquery.js and put it on disk it was like

828
00:31:14,159 --> 00:31:16,320
yeah that's fine

829
00:31:16,320 --> 00:31:17,760
yeah that's where we lean on the static

830
00:31:17,760 --> 00:31:20,080
code analysis tools

831
00:31:20,080 --> 00:31:21,600
but ultimately

832
00:31:21,600 --> 00:31:23,919
have that package json in place so you

833
00:31:23,919 --> 00:31:26,559
can enumerate your external

834
00:31:26,559 --> 00:31:28,159
libraries as well

835
00:31:28,159 --> 00:31:31,440
so both of them use this identical build

836
00:31:31,440 --> 00:31:33,440
file and we can take a look at what that

837
00:31:33,440 --> 00:31:34,320
action

838
00:31:34,320 --> 00:31:36,159
what that build looks like but before we

839
00:31:36,159 --> 00:31:37,840
do that let's take a look at what we

840
00:31:37,840 --> 00:31:41,519
might do with a regular

841
00:31:42,399 --> 00:31:46,399
on-prem build so here's my build.sh

842
00:31:46,399 --> 00:31:49,120
maybe this is build.bat and maybe

843
00:31:49,120 --> 00:31:52,720
jenkins or teamcity kicks off this build

844
00:31:52,720 --> 00:31:54,559
and so right now we can see it's going

845
00:31:54,559 --> 00:31:57,440
to do a docker build it will do a docker

846
00:31:57,440 --> 00:32:00,240
push and do cubectl apply to get that

847
00:32:00,240 --> 00:32:02,240
pod into kubernetes

848
00:32:02,240 --> 00:32:04,720
so we want to add container scanning now

849
00:32:04,720 --> 00:32:06,640
we looked at the command lines that we

850
00:32:06,640 --> 00:32:08,559
saw previously the anchor command line

851
00:32:08,559 --> 00:32:11,279
so let's flip over to the build that is

852
00:32:11,279 --> 00:32:12,799
done

853
00:32:12,799 --> 00:32:15,360
we still have our docker build um we

854
00:32:15,360 --> 00:32:17,519
give it a name

855
00:32:17,519 --> 00:32:19,440
and we'll give it a version

856
00:32:19,440 --> 00:32:21,200
and we'll tell it we're building in the

857
00:32:21,200 --> 00:32:22,799
current directory

858
00:32:22,799 --> 00:32:24,960
now that we've got that image now let's

859
00:32:24,960 --> 00:32:28,480
call anchor cli and we will pass in that

860
00:32:28,480 --> 00:32:31,519
image name and version and we will also

861
00:32:31,519 --> 00:32:33,919
pass in our docker file so that it can

862
00:32:33,919 --> 00:32:35,840
do some additional checks to validate

863
00:32:35,840 --> 00:32:37,440
you know what did i choose to install

864
00:32:37,440 --> 00:32:39,679
and then maybe later remove or did i put

865
00:32:39,679 --> 00:32:42,640
it in an unusual directory in this case

866
00:32:42,640 --> 00:32:44,640
i chose to wait

867
00:32:44,640 --> 00:32:46,880
so i'm waiting for those results yeah

868
00:32:46,880 --> 00:32:49,840
the build is spinning for some time so

869
00:32:49,840 --> 00:32:53,200
maybe i do this

870
00:32:53,200 --> 00:32:54,880
and then i kick off all of my

871
00:32:54,880 --> 00:32:57,120
integration tests all my cypress tests

872
00:32:57,120 --> 00:32:58,799
all my

873
00:32:58,799 --> 00:33:00,640
sonar cube tests

874
00:33:00,640 --> 00:33:02,799
and then i wait

875
00:33:02,799 --> 00:33:04,960
that could be cool

876
00:33:04,960 --> 00:33:06,640
okay so once i've waited once it's

877
00:33:06,640 --> 00:33:08,480
finished it's gotten the results i'm

878
00:33:08,480 --> 00:33:10,480
going to go grab the list of

879
00:33:10,480 --> 00:33:13,399
vulnerabilities and stick it in this

880
00:33:13,399 --> 00:33:15,360
vulner.json file

881
00:33:15,360 --> 00:33:17,679
that's my list of vulnerabilities now we

882
00:33:17,679 --> 00:33:20,559
can apply our policy

883
00:33:20,559 --> 00:33:22,720
are we going to say all unit tests make

884
00:33:22,720 --> 00:33:24,880
the build fail are we going to say that

885
00:33:24,880 --> 00:33:27,039
any vulnerability over a certain level

886
00:33:27,039 --> 00:33:29,519
maybe medium or higher

887
00:33:29,519 --> 00:33:31,840
makes this build fail in this case i'm

888
00:33:31,840 --> 00:33:34,159
going to go look for any vulnerabilities

889
00:33:34,159 --> 00:33:35,360
anywhere

890
00:33:35,360 --> 00:33:37,279
and if there are any vulnerabilities in

891
00:33:37,279 --> 00:33:40,000
this vuln.json file i'm going to say

892
00:33:40,000 --> 00:33:40,799
nope

893
00:33:40,799 --> 00:33:42,480
we're done

894
00:33:42,480 --> 00:33:44,240
yeah that's probably a little bit too

895
00:33:44,240 --> 00:33:46,000
aggressive but

896
00:33:46,000 --> 00:33:47,519
that was my choice

897
00:33:47,519 --> 00:33:48,640
and

898
00:33:48,640 --> 00:33:50,559
next i'm going to go grab the content

899
00:33:50,559 --> 00:33:53,039
and put that in content.json now of

900
00:33:53,039 --> 00:33:54,799
course if i said

901
00:33:54,799 --> 00:33:56,480
fail the build i haven't pushed it to

902
00:33:56,480 --> 00:33:58,799
the registry yet so maybe i don't need

903
00:33:58,799 --> 00:34:02,559
to keep track of this inventory of this

904
00:34:02,559 --> 00:34:04,399
container because well the container is

905
00:34:04,399 --> 00:34:06,720
going to die in a minute but if i do

906
00:34:06,720 --> 00:34:08,560
pass it then i want to go grab that

907
00:34:08,560 --> 00:34:10,879
content and i want to go stick it in

908
00:34:10,879 --> 00:34:14,079
some build artifact location

909
00:34:14,079 --> 00:34:17,040
tagged with my image

910
00:34:17,040 --> 00:34:21,839
sha and the list of software

911
00:34:22,399 --> 00:34:24,239
software inventory together with their

912
00:34:24,239 --> 00:34:26,000
versions

913
00:34:26,000 --> 00:34:29,918
now now that i've passed this container

914
00:34:29,918 --> 00:34:32,639
it's good enough to deploy now i'm going

915
00:34:32,639 --> 00:34:36,000
to or push this into my registry

916
00:34:36,000 --> 00:34:37,440
so now i've made the assumption that

917
00:34:37,440 --> 00:34:39,760
anything in my registry is good enough

918
00:34:39,760 --> 00:34:41,440
now i may want to kick off the anchor

919
00:34:41,440 --> 00:34:44,079
scan on my registry as well but

920
00:34:44,079 --> 00:34:46,239
i've now got a clean container in my

921
00:34:46,239 --> 00:34:47,440
registry

922
00:34:47,440 --> 00:34:49,839
okay so let's apply this to kubernetes

923
00:34:49,839 --> 00:34:51,839
and cube ctl apply we'll go schedule

924
00:34:51,839 --> 00:34:54,560
that pod perhaps we have that validating

925
00:34:54,560 --> 00:34:57,040
web hook that's going to go look in this

926
00:34:57,040 --> 00:35:00,160
vuln.json and content.json or the

927
00:35:00,160 --> 00:35:02,079
database that i chose to put them in and

928
00:35:02,079 --> 00:35:04,640
validate that this image hash is clean

929
00:35:04,640 --> 00:35:07,359
and thus kick off the process

930
00:35:07,359 --> 00:35:10,160
so by switching by adding these ankar

931
00:35:10,160 --> 00:35:12,800
cli commands into my on-prem build we

932
00:35:12,800 --> 00:35:15,040
were able to add container scanning to

933
00:35:15,040 --> 00:35:17,119
be able to understand the content and

934
00:35:17,119 --> 00:35:19,839
the details of our

935
00:35:19,839 --> 00:35:21,200
of our content

936
00:35:21,200 --> 00:35:25,440
so here's the content.json and

937
00:35:25,440 --> 00:35:27,440
this isn't spaced very well so you know

938
00:35:27,440 --> 00:35:29,760
just mashed it but here's all of the

939
00:35:29,760 --> 00:35:33,280
details of all of the packages so if we

940
00:35:33,280 --> 00:35:35,760
look at particular things here's the

941
00:35:35,760 --> 00:35:38,720
content for my os we can see that

942
00:35:38,720 --> 00:35:39,839
here is

943
00:35:39,839 --> 00:35:42,078
my

944
00:35:42,320 --> 00:35:46,000
package name right here and here is the

945
00:35:46,000 --> 00:35:48,400
version of that package that's perfect

946
00:35:48,400 --> 00:35:50,480
so we can enumerate all of the different

947
00:35:50,480 --> 00:35:52,960
packages that we have installed uh it's

948
00:35:52,960 --> 00:35:55,040
also harvesting licenses where it can

949
00:35:55,040 --> 00:35:57,440
which is really elegant and so now i've

950
00:35:57,440 --> 00:35:59,359
got all of the content for my operating

951
00:35:59,359 --> 00:36:01,359
system in this case i also have some

952
00:36:01,359 --> 00:36:04,400
content for npm here's the location on

953
00:36:04,400 --> 00:36:06,480
disk of where that is relative to where

954
00:36:06,480 --> 00:36:09,359
it's scanned here's some other

955
00:36:09,359 --> 00:36:12,400
packages that we have installed and then

956
00:36:12,400 --> 00:36:14,320
ultimately when i'm looking at my

957
00:36:14,320 --> 00:36:16,720
vulnerability here's my list of

958
00:36:16,720 --> 00:36:18,720
vulnerabilities so here's all the

959
00:36:18,720 --> 00:36:22,800
policies that it used when it did it

960
00:36:22,800 --> 00:36:26,640
and let's go find a vulnerability action

961
00:36:26,640 --> 00:36:29,839
warn so that one's probably okay

962
00:36:29,839 --> 00:36:32,240
but here's the nope

963
00:36:32,240 --> 00:36:34,720
here it is

964
00:36:36,400 --> 00:36:38,410
get me past the warns to there we go

965
00:36:38,410 --> 00:36:39,680
[Music]

966
00:36:39,680 --> 00:36:42,799
policy evaluation

967
00:36:44,640 --> 00:36:45,140
ooh

968
00:36:45,140 --> 00:36:47,040
[Music]

969
00:36:47,040 --> 00:36:50,079
we are running our docker file as root

970
00:36:50,079 --> 00:36:51,920
glad it grabbed that one that's pretty

971
00:36:51,920 --> 00:36:54,920
cool

972
00:36:55,280 --> 00:36:57,040
i'll scan all the way down to the bottom

973
00:36:57,040 --> 00:36:59,599
of this and

974
00:36:59,599 --> 00:37:02,000
status pass

975
00:37:02,000 --> 00:37:06,320
it looks like this container is okay

976
00:37:06,800 --> 00:37:08,480
so that was the on-prem build and it was

977
00:37:08,480 --> 00:37:10,720
cool to be able to get anchor to be able

978
00:37:10,720 --> 00:37:13,119
to run in our local environment and to

979
00:37:13,119 --> 00:37:15,520
be able to get things done

980
00:37:15,520 --> 00:37:17,280
in a similar way we can flip back over

981
00:37:17,280 --> 00:37:20,240
to github actions and take a look at the

982
00:37:20,240 --> 00:37:22,160
github actions build and we'll do

983
00:37:22,160 --> 00:37:23,920
similar things but instead of doing all

984
00:37:23,920 --> 00:37:26,160
the anchor cli commands we can just

985
00:37:26,160 --> 00:37:27,920
reference this

986
00:37:27,920 --> 00:37:30,400
anchor scan task

987
00:37:30,400 --> 00:37:32,480
now we're going to check out our content

988
00:37:32,480 --> 00:37:34,160
we'll do a docker build in the normal

989
00:37:34,160 --> 00:37:35,200
way

990
00:37:35,200 --> 00:37:37,359
in this case i've chosen to label it

991
00:37:37,359 --> 00:37:39,839
with the github sha now the beauty of

992
00:37:39,839 --> 00:37:41,680
using the github sha as the version

993
00:37:41,680 --> 00:37:44,640
number is now we can walk through our

994
00:37:44,640 --> 00:37:46,960
cluster going oh here's the git hash

995
00:37:46,960 --> 00:37:48,400
that i need to be able to check out the

996
00:37:48,400 --> 00:37:52,560
code at that version that's pretty cool

997
00:37:52,560 --> 00:37:55,200
so i've built my image

998
00:37:55,200 --> 00:37:57,119
and now i want to kick off that scan

999
00:37:57,119 --> 00:37:59,520
here let's reference that image right

1000
00:37:59,520 --> 00:38:00,400
here

1001
00:38:00,400 --> 00:38:01,839
and

1002
00:38:01,839 --> 00:38:03,359
no idea why

1003
00:38:03,359 --> 00:38:05,040
fail build true doesn't work but it

1004
00:38:05,040 --> 00:38:05,920
doesn't

1005
00:38:05,920 --> 00:38:08,480
here's their experience of outputting

1006
00:38:08,480 --> 00:38:10,320
the results just getting it in the build

1007
00:38:10,320 --> 00:38:12,640
blog

1008
00:38:12,800 --> 00:38:14,960
that's not a great solution

1009
00:38:14,960 --> 00:38:17,119
but i'm always i'm running it on if

1010
00:38:17,119 --> 00:38:19,119
always to ensure that it always runs

1011
00:38:19,119 --> 00:38:20,880
even if i failed the build

1012
00:38:20,880 --> 00:38:23,520
now let's upload these build artifacts

1013
00:38:23,520 --> 00:38:26,079
the anchor reports folder so

1014
00:38:26,079 --> 00:38:29,040
in a similar way that we would pass our

1015
00:38:29,040 --> 00:38:31,520
unit test results our junit files we can

1016
00:38:31,520 --> 00:38:34,160
also pass the anchor reports

1017
00:38:34,160 --> 00:38:36,000
and then i'll go check it now

1018
00:38:36,000 --> 00:38:38,079
here's my overly aggressive check here

1019
00:38:38,079 --> 00:38:40,400
to say if there are any vulnerabilities

1020
00:38:40,400 --> 00:38:43,040
anywhere i want to evict this process so

1021
00:38:43,040 --> 00:38:45,280
maybe that's a little bit extreme

1022
00:38:45,280 --> 00:38:47,280
but that's the build that runs in both

1023
00:38:47,280 --> 00:38:49,520
places and so when i don't have

1024
00:38:49,520 --> 00:38:52,160
vulnerable software it succeeds and when

1025
00:38:52,160 --> 00:38:54,240
i do have vulnerability vulnerable

1026
00:38:54,240 --> 00:38:57,280
software it fails but it also took 11

1027
00:38:57,280 --> 00:39:00,320
minutes to build

1028
00:39:00,320 --> 00:39:03,760
yeah i exceeded that time frame

1029
00:39:03,760 --> 00:39:04,640
so

1030
00:39:04,640 --> 00:39:07,359
the cool part about anchor is that and

1031
00:39:07,359 --> 00:39:08,640
all of the

1032
00:39:08,640 --> 00:39:10,079
image scanning software is that it

1033
00:39:10,079 --> 00:39:13,280
allows us to get that inventory of our

1034
00:39:13,280 --> 00:39:15,760
containers and then compare that to a

1035
00:39:15,760 --> 00:39:17,680
vulnerability database

1036
00:39:17,680 --> 00:39:19,280
now the cool part is because our

1037
00:39:19,280 --> 00:39:22,160
containers don't change

1038
00:39:22,160 --> 00:39:25,440
if we want to re-validate this container

1039
00:39:25,440 --> 00:39:27,680
we just need to look through the

1040
00:39:27,680 --> 00:39:29,920
inventory list and recompare that to the

1041
00:39:29,920 --> 00:39:33,040
vulnerability database

1042
00:39:33,839 --> 00:39:35,839
if the software in our container changes

1043
00:39:35,839 --> 00:39:37,599
we've got bigger problems we don't run

1044
00:39:37,599 --> 00:39:39,599
windows update in the container

1045
00:39:39,599 --> 00:39:42,560
the way that we get new versions is we

1046
00:39:42,560 --> 00:39:44,000
patch our

1047
00:39:44,000 --> 00:39:46,480
as we rebuild our

1048
00:39:46,480 --> 00:39:49,839
container based on our docker file

1049
00:39:49,839 --> 00:39:51,920
so now what do we do with this

1050
00:39:51,920 --> 00:39:54,640
information now the cool part is that we

1051
00:39:54,640 --> 00:39:56,640
can now

1052
00:39:56,640 --> 00:39:59,680
rebuild our image to be able to get

1053
00:39:59,680 --> 00:40:00,400
a

1054
00:40:00,400 --> 00:40:04,240
non-vulnerable software into place so

1055
00:40:04,240 --> 00:40:06,400
perhaps we should rebuild our images

1056
00:40:06,400 --> 00:40:07,839
frequently

1057
00:40:07,839 --> 00:40:10,079
maybe have it run on a cron once a week

1058
00:40:10,079 --> 00:40:12,480
to go get the latest versions of things

1059
00:40:12,480 --> 00:40:14,319
now that does mean that we can't check

1060
00:40:14,319 --> 00:40:17,920
in our package lock.json or yarn.lock we

1061
00:40:17,920 --> 00:40:19,200
need to give it

1062
00:40:19,200 --> 00:40:22,000
image ranges senver ranges but the

1063
00:40:22,000 --> 00:40:24,160
beauty there is that if we have

1064
00:40:24,160 --> 00:40:26,960
confidence in our unit and integration

1065
00:40:26,960 --> 00:40:28,960
tests then we ought to be able to

1066
00:40:28,960 --> 00:40:31,520
upgrade our dependencies automatically

1067
00:40:31,520 --> 00:40:33,280
and push them into production without

1068
00:40:33,280 --> 00:40:34,480
incident

1069
00:40:34,480 --> 00:40:36,240
now that is an assumption at the point

1070
00:40:36,240 --> 00:40:37,599
where our unit tests have failed us

1071
00:40:37,599 --> 00:40:39,760
let's go back and build more robust unit

1072
00:40:39,760 --> 00:40:41,920
tests to be able to get more confidence

1073
00:40:41,920 --> 00:40:43,440
in our system

1074
00:40:43,440 --> 00:40:44,240
but

1075
00:40:44,240 --> 00:40:47,119
let's also expose this build button

1076
00:40:47,119 --> 00:40:50,880
from developers into operations

1077
00:40:50,880 --> 00:40:53,119
let's imagine a scenario where the next

1078
00:40:53,119 --> 00:40:55,520
version of a vulnerability comes out

1079
00:40:55,520 --> 00:40:57,920
operations can go look through the

1080
00:40:57,920 --> 00:41:00,720
catalog of installed software on running

1081
00:41:00,720 --> 00:41:03,040
containers validate which containers are

1082
00:41:03,040 --> 00:41:05,839
vulnerable and have patches and then go

1083
00:41:05,839 --> 00:41:08,000
into the devops pipeline and push

1084
00:41:08,000 --> 00:41:10,480
rebuild

1085
00:41:11,200 --> 00:41:13,280
it'll rebuild the content that is in the

1086
00:41:13,280 --> 00:41:15,280
main branch the deployment branch and

1087
00:41:15,280 --> 00:41:18,000
redeploy into production

1088
00:41:18,000 --> 00:41:20,720
and the vulnerability is patched

1089
00:41:20,720 --> 00:41:22,319
and development didn't need to wake up

1090
00:41:22,319 --> 00:41:23,680
and do that

1091
00:41:23,680 --> 00:41:25,680
operations was able to do that

1092
00:41:25,680 --> 00:41:28,079
that's excellent

1093
00:41:28,079 --> 00:41:31,200
if operations can kick off devops

1094
00:41:31,200 --> 00:41:33,680
pipelines to build non-vulnerable

1095
00:41:33,680 --> 00:41:36,160
versions of the software then we can get

1096
00:41:36,160 --> 00:41:38,720
new versions into production without

1097
00:41:38,720 --> 00:41:41,119
involving developers now if the unit

1098
00:41:41,119 --> 00:41:43,040
tests or integration tests fail because

1099
00:41:43,040 --> 00:41:44,720
the new version is incompatible in a

1100
00:41:44,720 --> 00:41:46,880
certain way yeah now operations needs to

1101
00:41:46,880 --> 00:41:48,960
get developers involved to be able to

1102
00:41:48,960 --> 00:41:53,280
get this software patched and in place

1103
00:41:53,680 --> 00:41:55,520
now what if we identify that there's a

1104
00:41:55,520 --> 00:41:57,760
vulnerability

1105
00:41:57,760 --> 00:42:00,160
but we also identify that there is no

1106
00:42:00,160 --> 00:42:02,560
remedy to this

1107
00:42:02,560 --> 00:42:04,480
maybe we're hardcoded into an older

1108
00:42:04,480 --> 00:42:06,640
version of the software or maybe it's

1109
00:42:06,640 --> 00:42:09,040
just not patched

1110
00:42:09,040 --> 00:42:12,560
should we block our deployments

1111
00:42:13,200 --> 00:42:15,040
what if

1112
00:42:15,040 --> 00:42:18,960
there's a vulnerability that has no cure

1113
00:42:19,440 --> 00:42:21,520
should we just

1114
00:42:21,520 --> 00:42:24,400
lock down the world

1115
00:42:26,079 --> 00:42:28,160
or maybe should we hobble on as best we

1116
00:42:28,160 --> 00:42:29,359
can

1117
00:42:29,359 --> 00:42:32,240
maybe the new version is better

1118
00:42:32,240 --> 00:42:35,359
not perfect but better

1119
00:42:35,359 --> 00:42:36,800
now this is a decision you'll need to

1120
00:42:36,800 --> 00:42:38,319
make in your organization what's your

1121
00:42:38,319 --> 00:42:41,280
tolerance for deployment is it okay to

1122
00:42:41,280 --> 00:42:44,240
have medium severity vulnerabilities if

1123
00:42:44,240 --> 00:42:46,000
there is no remedy

1124
00:42:46,000 --> 00:42:47,680
or are we going to say that if there is

1125
00:42:47,680 --> 00:42:49,839
any vulnerability in the container at

1126
00:42:49,839 --> 00:42:51,839
all we're just not going to deploy

1127
00:42:51,839 --> 00:42:53,839
now what if we have a vulnerable system

1128
00:42:53,839 --> 00:42:56,400
in production and we have no new image

1129
00:42:56,400 --> 00:42:59,760
that's good enough to push

1130
00:42:59,760 --> 00:43:02,880
do we shut off the site

1131
00:43:03,119 --> 00:43:04,319
i would invite you to have this

1132
00:43:04,319 --> 00:43:07,040
conversation with your devops team with

1133
00:43:07,040 --> 00:43:09,839
your infosec people and make that choice

1134
00:43:09,839 --> 00:43:12,000
what is your tolerance for

1135
00:43:12,000 --> 00:43:14,079
vulnerabilities within your system

1136
00:43:14,079 --> 00:43:15,760
what are the exceptions that you need to

1137
00:43:15,760 --> 00:43:18,400
justify if we're losing a lot of money

1138
00:43:18,400 --> 00:43:20,319
because this software is vulnerable then

1139
00:43:20,319 --> 00:43:22,720
we need to push out even if our unit

1140
00:43:22,720 --> 00:43:25,119
tests or integration tests fail

1141
00:43:25,119 --> 00:43:26,560
that might be a conversation worth

1142
00:43:26,560 --> 00:43:28,880
having

1143
00:43:29,280 --> 00:43:31,119
so we saw that kubernetes really only

1144
00:43:31,119 --> 00:43:33,839
protects itself docker only protects

1145
00:43:33,839 --> 00:43:36,880
itself and we secure the containers we

1146
00:43:36,880 --> 00:43:39,040
secure the content running inside of our

1147
00:43:39,040 --> 00:43:40,800
containers

1148
00:43:40,800 --> 00:43:43,280
container scanning is a great tool to be

1149
00:43:43,280 --> 00:43:44,800
able to do that

1150
00:43:44,800 --> 00:43:46,240
now the beauty of adding container

1151
00:43:46,240 --> 00:43:47,920
scanning is that we just need to

1152
00:43:47,920 --> 00:43:50,880
inventory our container in one spot and

1153
00:43:50,880 --> 00:43:52,800
once we i've we've identified the

1154
00:43:52,800 --> 00:43:54,640
contents of our container it will not

1155
00:43:54,640 --> 00:43:55,520
change

1156
00:43:55,520 --> 00:43:58,000
given a hash we know exactly what's in

1157
00:43:58,000 --> 00:43:59,839
our container given that list of

1158
00:43:59,839 --> 00:44:01,440
inventory we compare it to our

1159
00:44:01,440 --> 00:44:03,440
vulnerability database and we know our

1160
00:44:03,440 --> 00:44:06,000
exposure

1161
00:44:06,319 --> 00:44:09,200
that's great container scanning is an

1162
00:44:09,200 --> 00:44:11,359
excellent piece to be able to add to

1163
00:44:11,359 --> 00:44:14,000
your infosec piece to be able to gain a

1164
00:44:14,000 --> 00:44:15,920
level of confidence with the containers

1165
00:44:15,920 --> 00:44:17,119
in your system

1166
00:44:17,119 --> 00:44:19,200
i would invite you to go experiment with

1167
00:44:19,200 --> 00:44:21,200
container scanning software pick the one

1168
00:44:21,200 --> 00:44:24,160
that works for you and implement it into

1169
00:44:24,160 --> 00:44:27,280
your devops pipeline and your kubernetes

1170
00:44:27,280 --> 00:44:29,520
control plane

1171
00:44:29,520 --> 00:44:32,820
this was a lot of fun thanks for coming

1172
00:44:32,820 --> 00:44:36,960
[Applause]

1173
00:44:36,960 --> 00:44:38,400
any questions about the content i

1174
00:44:38,400 --> 00:44:40,160
presented what did i miss what should i

1175
00:44:40,160 --> 00:44:42,879
add next time

1176
00:44:45,359 --> 00:44:48,359
yep

1177
00:45:10,000 --> 00:45:12,000
oh great question

1178
00:45:12,000 --> 00:45:14,640
so we kind of skimmed over the unit and

1179
00:45:14,640 --> 00:45:16,960
integration testing piece how might i

1180
00:45:16,960 --> 00:45:19,760
add that into my system

1181
00:45:19,760 --> 00:45:21,920
excellent

1182
00:45:21,920 --> 00:45:24,800
let's flip over to this um

1183
00:45:24,800 --> 00:45:28,160
build script where we did that docker

1184
00:45:28,160 --> 00:45:30,720
build we did the docker push and the

1185
00:45:30,720 --> 00:45:33,440
cube ctl apply

1186
00:45:33,440 --> 00:45:35,760
now the interesting thing is here

1187
00:45:35,760 --> 00:45:37,359
where's our oh

1188
00:45:37,359 --> 00:45:39,760
i don't have my docker file here

1189
00:45:39,760 --> 00:45:42,400
inside my docker file i might let's

1190
00:45:42,400 --> 00:45:44,480
actually create a new docker file

1191
00:45:44,480 --> 00:45:45,599
from

1192
00:45:45,599 --> 00:45:48,119
mcr dot

1193
00:45:48,119 --> 00:45:50,400
microsoft dot

1194
00:45:50,400 --> 00:45:53,760
com slash asp.net

1195
00:45:53,760 --> 00:45:55,520
um all right now

1196
00:45:55,520 --> 00:45:57,520
sdk

1197
00:45:57,520 --> 00:46:00,240
6.0 dash alpine

1198
00:46:00,240 --> 00:46:02,560
copy all the things

1199
00:46:02,560 --> 00:46:04,880
run

1200
00:46:04,960 --> 00:46:06,880
dot net restore

1201
00:46:06,880 --> 00:46:09,040
run.net

1202
00:46:09,040 --> 00:46:11,839
build we'll build in release mode

1203
00:46:11,839 --> 00:46:14,560
run.net test i've never built a docker

1204
00:46:14,560 --> 00:46:16,640
file this fast before but this is

1205
00:46:16,640 --> 00:46:17,720
awesome

1206
00:46:17,720 --> 00:46:22,079
run.net publish dash c release dash

1207
00:46:22,079 --> 00:46:23,040
o

1208
00:46:23,040 --> 00:46:24,400
dist

1209
00:46:24,400 --> 00:46:26,480
uh from

1210
00:46:26,480 --> 00:46:31,160
front from mcr.microsoft.com

1211
00:46:32,800 --> 00:46:35,520
asp.net

1212
00:46:35,520 --> 00:46:38,880
6.0 dash alpine

1213
00:46:38,880 --> 00:46:39,839
um

1214
00:46:39,839 --> 00:46:41,280
copy

1215
00:46:41,280 --> 00:46:42,800
dash dash from

1216
00:46:42,800 --> 00:46:44,319
equals build

1217
00:46:44,319 --> 00:46:45,440
all the

1218
00:46:45,440 --> 00:46:48,079
dash disk to the current folder i need a

1219
00:46:48,079 --> 00:46:50,960
workdir of slash app and i also need a

1220
00:46:50,960 --> 00:46:53,200
worker here

1221
00:46:53,200 --> 00:46:57,359
of src and then i will

1222
00:46:57,359 --> 00:46:58,520
set some

1223
00:46:58,520 --> 00:47:02,319
environment variables

1224
00:47:02,480 --> 00:47:06,160
and then i will cmd

1225
00:47:06,560 --> 00:47:08,640
dot net

1226
00:47:08,640 --> 00:47:11,520
my dll

1227
00:47:11,520 --> 00:47:14,800
okay so there's our docker file

1228
00:47:14,800 --> 00:47:16,640
and this docker file does all of the

1229
00:47:16,640 --> 00:47:19,040
things here's the spot where i'm running

1230
00:47:19,040 --> 00:47:21,200
my unit tests

1231
00:47:21,200 --> 00:47:22,720
now the beautiful thing about running my

1232
00:47:22,720 --> 00:47:25,760
unit tests here is that if my unit tests

1233
00:47:25,760 --> 00:47:27,599
fail

1234
00:47:27,599 --> 00:47:29,680
i never publish

1235
00:47:29,680 --> 00:47:31,440
which means i never build the second

1236
00:47:31,440 --> 00:47:33,920
phase oh i needed

1237
00:47:33,920 --> 00:47:36,400
as build

1238
00:47:36,400 --> 00:47:37,359
there

1239
00:47:37,359 --> 00:47:39,280
i never got to my second phase i never

1240
00:47:39,280 --> 00:47:41,680
got an image so here's where i like to

1241
00:47:41,680 --> 00:47:45,118
run my unit tests

1242
00:47:45,280 --> 00:47:48,079
now wait a minute my tests may build

1243
00:47:48,079 --> 00:47:51,440
extra things they may put extra files in

1244
00:47:51,440 --> 00:47:54,640
my thing and so i may choose to say

1245
00:47:54,640 --> 00:47:58,078
something like this from

1246
00:48:02,000 --> 00:48:05,720
maybe i need to inject

1247
00:48:09,119 --> 00:48:11,760
um environment variables into my tests

1248
00:48:11,760 --> 00:48:14,079
so i'm going to say

1249
00:48:14,079 --> 00:48:17,200
copy uh

1250
00:48:18,319 --> 00:48:20,640
from equals build

1251
00:48:20,640 --> 00:48:22,960
the dist folder into my current folder

1252
00:48:22,960 --> 00:48:25,680
and cmd

1253
00:48:25,680 --> 00:48:27,920
dot net

1254
00:48:27,920 --> 00:48:30,160
test and here's where it's like yeah

1255
00:48:30,160 --> 00:48:33,520
this is an ugly way to do it but

1256
00:48:33,520 --> 00:48:35,280
that works

1257
00:48:35,280 --> 00:48:37,119
now i have three stages

1258
00:48:37,119 --> 00:48:39,440
now if i label this one

1259
00:48:39,440 --> 00:48:41,119
as test

1260
00:48:41,119 --> 00:48:43,760
and this one as prod

1261
00:48:43,760 --> 00:48:46,720
i can now build my docker file

1262
00:48:46,720 --> 00:48:50,319
differently so here in my build.sh

1263
00:48:50,319 --> 00:48:52,160
perhaps i do a docker build and that's

1264
00:48:52,160 --> 00:48:55,040
my regular build and then i also do a

1265
00:48:55,040 --> 00:48:57,599
docker build and i think it's

1266
00:48:57,599 --> 00:49:00,640
stage equals test i'm not positive about

1267
00:49:00,640 --> 00:49:03,040
that and it will only then go grab the

1268
00:49:03,040 --> 00:49:05,680
new pieces associated with that and now

1269
00:49:05,680 --> 00:49:06,880
i could say

1270
00:49:06,880 --> 00:49:09,359
docker

1271
00:49:09,680 --> 00:49:11,040
run

1272
00:49:11,040 --> 00:49:13,359
um

1273
00:49:13,520 --> 00:49:17,839
oh this one is dash test

1274
00:49:18,319 --> 00:49:20,319
docker run that

1275
00:49:20,319 --> 00:49:23,040
and i could also pass in

1276
00:49:23,040 --> 00:49:26,800
some environment variables

1277
00:49:27,200 --> 00:49:31,359
so maybe i say um

1278
00:49:31,359 --> 00:49:34,640
connection strings

1279
00:49:34,640 --> 00:49:38,480
my db equals

1280
00:49:39,280 --> 00:49:41,760
some

1281
00:49:42,839 --> 00:49:44,800
server and

1282
00:49:44,800 --> 00:49:46,160
i probably need to put quotes around

1283
00:49:46,160 --> 00:49:48,079
that because it's gonna but you know now

1284
00:49:48,079 --> 00:49:50,079
i can start to pass parameters to my

1285
00:49:50,079 --> 00:49:52,160
tests which is pretty cool

1286
00:49:52,160 --> 00:49:54,400
i really like to

1287
00:49:54,400 --> 00:49:57,280
do them right here if at all possible

1288
00:49:57,280 --> 00:49:58,559
but if you need that additional

1289
00:49:58,559 --> 00:50:00,400
configuration then that's one way where

1290
00:50:00,400 --> 00:50:02,079
you can kick off your unit tests in

1291
00:50:02,079 --> 00:50:03,760
really interesting ways

1292
00:50:03,760 --> 00:50:07,119
now similarly i'm doing this before i

1293
00:50:07,119 --> 00:50:09,839
push the container to my registry so if

1294
00:50:09,839 --> 00:50:12,720
my unit tests fail then i'm not getting

1295
00:50:12,720 --> 00:50:15,200
any farther

1296
00:50:15,200 --> 00:50:17,280
now the cool part is i can do similar

1297
00:50:17,280 --> 00:50:19,599
things with my integration tests so i

1298
00:50:19,599 --> 00:50:21,599
can say

1299
00:50:21,599 --> 00:50:23,760
docker run

1300
00:50:23,760 --> 00:50:26,880
cyprus test

1301
00:50:26,880 --> 00:50:27,839
and

1302
00:50:27,839 --> 00:50:30,640
so maybe i run this dash d

1303
00:50:30,640 --> 00:50:34,640
that will give me the image id

1304
00:50:35,280 --> 00:50:37,520
um

1305
00:50:38,079 --> 00:50:40,880
let's run that so i'm going to run my

1306
00:50:40,880 --> 00:50:43,680
app and then i will run

1307
00:50:43,680 --> 00:50:47,680
test id equals let's run the cypress

1308
00:50:47,680 --> 00:50:50,400
test that will output various results so

1309
00:50:50,400 --> 00:50:54,559
maybe i also need to say dash v

1310
00:50:54,800 --> 00:50:57,200
test results

1311
00:50:57,200 --> 00:50:58,640
to

1312
00:50:58,640 --> 00:50:59,920
data

1313
00:50:59,920 --> 00:51:03,040
results you know wherever i've got that

1314
00:51:03,040 --> 00:51:06,000
test results piece that actually

1315
00:51:06,000 --> 00:51:09,480
needs to go

1316
00:51:11,040 --> 00:51:13,520
there

1317
00:51:14,960 --> 00:51:17,119
and now i've got those two containers

1318
00:51:17,119 --> 00:51:19,440
running the one is hammering the other

1319
00:51:19,440 --> 00:51:20,880
and so i'm able to kind of get some

1320
00:51:20,880 --> 00:51:23,119
integration tests maybe i'm running a

1321
00:51:23,119 --> 00:51:25,599
docker compose that kicks up my entire

1322
00:51:25,599 --> 00:51:28,559
stack here but now i can run cypress

1323
00:51:28,559 --> 00:51:31,200
tests or i can run

1324
00:51:31,200 --> 00:51:33,680
sonar cube tests or i can run other

1325
00:51:33,680 --> 00:51:35,680
tests that need access to an entire

1326
00:51:35,680 --> 00:51:36,480
system

1327
00:51:36,480 --> 00:51:38,960
what's really cool in this part

1328
00:51:38,960 --> 00:51:41,359
spin up a copy of your database too

1329
00:51:41,359 --> 00:51:43,119
now i've got a throwaway database that's

1330
00:51:43,119 --> 00:51:45,520
really cool the cool part is at the end

1331
00:51:45,520 --> 00:51:47,520
of all of this process

1332
00:51:47,520 --> 00:51:50,000
i've now run all of my integration tests

1333
00:51:50,000 --> 00:51:51,040
and

1334
00:51:51,040 --> 00:51:53,680
i haven't left the build yet

1335
00:51:53,680 --> 00:51:55,599
so i validated that this container is

1336
00:51:55,599 --> 00:51:58,000
good enough and now i push it to my

1337
00:51:58,000 --> 00:52:00,559
registry

1338
00:52:01,359 --> 00:52:04,800
we did this inside of a

1339
00:52:04,800 --> 00:52:06,960
build file a script but we could do

1340
00:52:06,960 --> 00:52:09,839
similar things inside of github actions

1341
00:52:09,839 --> 00:52:12,800
files where we could do

1342
00:52:12,800 --> 00:52:14,720
you know this is just running script

1343
00:52:14,720 --> 00:52:16,480
commands so we could just execute those

1344
00:52:16,480 --> 00:52:18,079
lines but we could also create

1345
00:52:18,079 --> 00:52:20,720
additional tasks to go kick up cross

1346
00:52:20,720 --> 00:52:23,119
browser testing or reach into other

1347
00:52:23,119 --> 00:52:26,160
services that way too

1348
00:52:26,720 --> 00:52:28,640
that was a great question did that

1349
00:52:28,640 --> 00:52:30,480
answer your question

1350
00:52:30,480 --> 00:52:32,319
perfect what other questions do we have

1351
00:52:32,319 --> 00:52:36,079
any questions online yep

1352
00:52:43,839 --> 00:52:46,880
i'm just curious what a more

1353
00:52:46,880 --> 00:52:49,040
typical run time would be for that

1354
00:52:49,040 --> 00:52:51,680
process oh good call i did say anchor

1355
00:52:51,680 --> 00:52:54,319
was slow what is a better way to do that

1356
00:52:54,319 --> 00:52:57,759
is there faster software

1357
00:52:57,920 --> 00:52:59,520
no

1358
00:52:59,520 --> 00:53:02,079
anchor is decently typical in the space

1359
00:53:02,079 --> 00:53:04,160
it's just the process of spinning up the

1360
00:53:04,160 --> 00:53:07,359
container running an apt list

1361
00:53:07,359 --> 00:53:10,240
enumerating all of the possible places

1362
00:53:10,240 --> 00:53:12,960
where package.jsons could be or

1363
00:53:12,960 --> 00:53:15,280
packages.config we also don't know is

1364
00:53:15,280 --> 00:53:17,520
this a ruby app or is this a

1365
00:53:17,520 --> 00:53:19,680
python app so let's go look for packages

1366
00:53:19,680 --> 00:53:22,480
from all the different places and then

1367
00:53:22,480 --> 00:53:24,160
enumerating all of that and collecting

1368
00:53:24,160 --> 00:53:27,119
it it just takes time so anchor isn't

1369
00:53:27,119 --> 00:53:30,079
any better or worse at this it's just

1370
00:53:30,079 --> 00:53:33,040
that process takes a while

1371
00:53:33,040 --> 00:53:35,680
great question

1372
00:53:36,960 --> 00:53:38,319
what other questions do we have any

1373
00:53:38,319 --> 00:53:41,200
questions from online

1374
00:53:41,520 --> 00:53:43,839
not yet

1375
00:53:43,920 --> 00:53:45,280
well if you're watching this recording

1376
00:53:45,280 --> 00:53:47,400
later you can grab these slides on

1377
00:53:47,400 --> 00:53:49,359
robrich.org and if you think of a

1378
00:53:49,359 --> 00:53:51,760
question tomorrow or next week hit me up

1379
00:53:51,760 --> 00:53:54,240
on twitter at rob underscore rich this

1380
00:53:54,240 --> 00:53:57,510
has been a lot of fun thanks for coming

1381
00:53:57,510 --> 00:54:03,569
[Applause]

1382
00:54:24,800 --> 00:54:26,880
you

