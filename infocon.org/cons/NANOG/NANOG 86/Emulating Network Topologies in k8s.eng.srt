1
00:00:00,000 --> 00:00:00,060
[Music]

2
00:00:00,060 --> 00:00:02,210
foreign

3
00:00:02,210 --> 00:00:05,400
[Music]

4
00:00:05,400 --> 00:00:07,560
I'd like to present Marcus Hines and Rob

5
00:00:07,560 --> 00:00:09,420
Shakir who'll be presenting emulating

6
00:00:09,420 --> 00:00:12,300
Network topologies and kubernetes at

7
00:00:12,300 --> 00:00:14,639
Kates right k8s I'm always confused

8
00:00:14,639 --> 00:00:15,599
about that

9
00:00:15,599 --> 00:00:18,180
we have too much tubercology Marcus is

10
00:00:18,180 --> 00:00:19,920
an engineering productivity lead at

11
00:00:19,920 --> 00:00:21,539
Google and travel from Mountain View to

12
00:00:21,539 --> 00:00:23,820
join us today this is Marcus first time

13
00:00:23,820 --> 00:00:25,619
on the nanog stage as he co-presents

14
00:00:25,619 --> 00:00:27,840
with Rob and Rob Shaquille Works in

15
00:00:27,840 --> 00:00:30,060
Google's Network architecture team and

16
00:00:30,060 --> 00:00:31,920
also contributes to open source projects

17
00:00:31,920 --> 00:00:34,260
and standards bodies Rob presented at

18
00:00:34,260 --> 00:00:36,180
nanning for the first time in 2011 and

19
00:00:36,180 --> 00:00:39,000
again in 2019. thanks for being us with

20
00:00:39,000 --> 00:00:40,440
us todays guys

21
00:00:40,440 --> 00:00:43,260
thank you very much I I it occurs to me

22
00:00:43,260 --> 00:00:44,760
I probably should have updated my bio I

23
00:00:44,760 --> 00:00:47,100
do do that job but I also do a bunch of

24
00:00:47,100 --> 00:00:48,660
other things now you only seem to

25
00:00:48,660 --> 00:00:50,340
acquire jobs at Google

26
00:00:50,340 --> 00:00:52,320
uh so yeah we're going to talk a little

27
00:00:52,320 --> 00:00:53,460
bit about some work that we've been

28
00:00:53,460 --> 00:00:55,199
doing uh around emulating Network

29
00:00:55,199 --> 00:00:57,180
apologies and our use of kubernetes for

30
00:00:57,180 --> 00:00:59,219
that um we're presenting on behalf of

31
00:00:59,219 --> 00:01:01,320
both Google Engineers as well as the

32
00:01:01,320 --> 00:01:02,699
kind of wider open Comfort Community

33
00:01:02,699 --> 00:01:04,860
which is one of the vehicles for this

34
00:01:04,860 --> 00:01:07,920
work meeting open source

35
00:01:07,920 --> 00:01:09,540
and

36
00:01:09,540 --> 00:01:11,880
hopefully so we'll start out with uh

37
00:01:11,880 --> 00:01:13,200
let's just run down what we're going to

38
00:01:13,200 --> 00:01:15,299
go through I'm going to say well why on

39
00:01:15,299 --> 00:01:16,439
Earth do we want to do this what are we

40
00:01:16,439 --> 00:01:17,760
trying to solve what's the thing that

41
00:01:17,760 --> 00:01:19,200
we're trying to do

42
00:01:19,200 --> 00:01:20,939
um then I'll hand over to Marcus and

43
00:01:20,939 --> 00:01:22,740
he'll introduce knee and talk about what

44
00:01:22,740 --> 00:01:25,200
we're actually doing how that works and

45
00:01:25,200 --> 00:01:26,400
then I'll come back and we'll try and

46
00:01:26,400 --> 00:01:27,900
talk about the real world use case so

47
00:01:27,900 --> 00:01:29,159
Something That We're actually doing with

48
00:01:29,159 --> 00:01:30,360
this what's the thing that we're trying

49
00:01:30,360 --> 00:01:31,799
to achieve we're meeting some of the

50
00:01:31,799 --> 00:01:33,600
goals that we laid out at the start of

51
00:01:33,600 --> 00:01:36,380
the presentation

52
00:01:36,659 --> 00:01:39,240
so quick disclaimer first Marcus and I

53
00:01:39,240 --> 00:01:40,799
are up here on the stage but we're

54
00:01:40,799 --> 00:01:42,479
presenting on the behalf of a ton of

55
00:01:42,479 --> 00:01:44,820
Engineers at Google and elsewhere uh

56
00:01:44,820 --> 00:01:46,200
these folks are really talented they've

57
00:01:46,200 --> 00:01:47,759
made really great contributions they've

58
00:01:47,759 --> 00:01:49,619
really driven this work forward and I

59
00:01:49,619 --> 00:01:51,600
think we've really seen in in this kind

60
00:01:51,600 --> 00:01:53,280
of overall ecosystem the real benefits

61
00:01:53,280 --> 00:01:54,840
of open source of getting views from

62
00:01:54,840 --> 00:01:56,460
different places being able to share the

63
00:01:56,460 --> 00:01:58,020
ways that we want to iterate on things

64
00:01:58,020 --> 00:01:59,939
and really Drive New you know new

65
00:01:59,939 --> 00:02:02,159
Innovative approaches that work for both

66
00:02:02,159 --> 00:02:04,560
us as a network operator as well as from

67
00:02:04,560 --> 00:02:06,659
you know other network operators as well

68
00:02:06,659 --> 00:02:09,119
as equipment vendors to really build a

69
00:02:09,119 --> 00:02:10,560
good ecosystem around this and it's it's

70
00:02:10,560 --> 00:02:12,420
a it's a real Testament to think how far

71
00:02:12,420 --> 00:02:13,980
we've come as some of the industry of

72
00:02:13,980 --> 00:02:15,780
getting into open source did how these

73
00:02:15,780 --> 00:02:17,700
collaborations are growing

74
00:02:17,700 --> 00:02:20,220
um but absolutely want to call out the

75
00:02:20,220 --> 00:02:21,720
talented folks that we work with and

76
00:02:21,720 --> 00:02:23,220
make sure that they're acknowledged as

77
00:02:23,220 --> 00:02:24,900
to uh we're just up here doing some

78
00:02:24,900 --> 00:02:26,940
marketing for their work

79
00:02:26,940 --> 00:02:28,920
so why do we want to look at some form

80
00:02:28,920 --> 00:02:30,420
of network emulation why do we want to

81
00:02:30,420 --> 00:02:33,120
look at something that gives us a way to

82
00:02:33,120 --> 00:02:34,440
spin up nodes

83
00:02:34,440 --> 00:02:36,959
um in a different way and kind of take a

84
00:02:36,959 --> 00:02:38,340
step back to what are the things that

85
00:02:38,340 --> 00:02:40,260
we're you know we're often doing

86
00:02:40,260 --> 00:02:42,360
of course we are always adding features

87
00:02:42,360 --> 00:02:44,160
to the network we kind of say oh like

88
00:02:44,160 --> 00:02:46,019
okay we've just if we only had this one

89
00:02:46,019 --> 00:02:47,819
thing then things would be simpler or if

90
00:02:47,819 --> 00:02:49,200
we had this one thing then things would

91
00:02:49,200 --> 00:02:50,819
be more efficient or we could reduce the

92
00:02:50,819 --> 00:02:53,459
cost of the network so the reality is

93
00:02:53,459 --> 00:02:54,480
that we're always going to be

94
00:02:54,480 --> 00:02:56,519
introducing these these features and so

95
00:02:56,519 --> 00:02:58,260
we want to find out ways that we can

96
00:02:58,260 --> 00:03:00,360
make the the process of introducing

97
00:03:00,360 --> 00:03:03,120
features as low cost and as fast as

98
00:03:03,120 --> 00:03:05,220
possible and for many of those features

99
00:03:05,220 --> 00:03:06,480
you know there's some of them that do

100
00:03:06,480 --> 00:03:07,980
depend on hardware and having you know

101
00:03:07,980 --> 00:03:10,739
exact like chips burnt or new new

102
00:03:10,739 --> 00:03:12,720
silicon architectures that or new

103
00:03:12,720 --> 00:03:15,000
hardware layouts that we that we would

104
00:03:15,000 --> 00:03:17,159
need to be able to drive that work but

105
00:03:17,159 --> 00:03:18,540
many of the things that we're doing you

106
00:03:18,540 --> 00:03:20,040
know and especially when we're evolving

107
00:03:20,040 --> 00:03:21,239
the fleet that we've got in the ground

108
00:03:21,239 --> 00:03:22,800
or of course things that are done in

109
00:03:22,800 --> 00:03:23,879
software or the things that we can

110
00:03:23,879 --> 00:03:26,159
emulate in software so we really want to

111
00:03:26,159 --> 00:03:28,319
say how do we get to the stage where

112
00:03:28,319 --> 00:03:30,180
rather than having you know these like

113
00:03:30,180 --> 00:03:33,239
array of labs that each each developer

114
00:03:33,239 --> 00:03:35,519
kind of has to time share onto and say

115
00:03:35,519 --> 00:03:37,319
how do we just basically make that such

116
00:03:37,319 --> 00:03:38,580
that we can have an infinite number of

117
00:03:38,580 --> 00:03:40,920
topologies at least one percent per

118
00:03:40,920 --> 00:03:42,900
developer so you're not sitting there

119
00:03:42,900 --> 00:03:44,400
waiting for the topology or you're not

120
00:03:44,400 --> 00:03:45,599
sitting there thinking like oh well when

121
00:03:45,599 --> 00:03:47,159
I get the lab equipment I'll do this or

122
00:03:47,159 --> 00:03:48,540
are you breaking something doesn't block

123
00:03:48,540 --> 00:03:50,280
other people so I really want to be able

124
00:03:50,280 --> 00:03:52,680
to have that as a basis for you know

125
00:03:52,680 --> 00:03:54,540
moving Network development into the same

126
00:03:54,540 --> 00:03:55,560
way that we think about software

127
00:03:55,560 --> 00:03:57,060
development I don't have to think about

128
00:03:57,060 --> 00:03:59,459
software development you know can I can

129
00:03:59,459 --> 00:04:01,500
I get to the compiler can I run this on

130
00:04:01,500 --> 00:04:03,720
the machine right I want I just go do it

131
00:04:03,720 --> 00:04:06,060
and then I get to iterate on it in my

132
00:04:06,060 --> 00:04:08,519
own space so this is a real enabler for

133
00:04:08,519 --> 00:04:10,140
kind of the velocity of adding features

134
00:04:10,140 --> 00:04:11,700
to the network

135
00:04:11,700 --> 00:04:13,680
so once we've added those features to

136
00:04:13,680 --> 00:04:14,819
the network though we also want to be

137
00:04:14,819 --> 00:04:17,100
able to say well how do we robustly and

138
00:04:17,100 --> 00:04:19,620
repeatably test those those features so

139
00:04:19,620 --> 00:04:21,358
we've got a set of things that we that

140
00:04:21,358 --> 00:04:22,740
were running on the network maybe we're

141
00:04:22,740 --> 00:04:24,120
evolving them maybe it's an existing

142
00:04:24,120 --> 00:04:25,740
Network maybe we're changing something

143
00:04:25,740 --> 00:04:27,360
in there we want to build of course we

144
00:04:27,360 --> 00:04:28,440
need to build test them we need to be

145
00:04:28,440 --> 00:04:30,600
able to test them before we deploy them

146
00:04:30,600 --> 00:04:32,940
um and the the kind of theory here is if

147
00:04:32,940 --> 00:04:34,440
we were to take something take those

148
00:04:34,440 --> 00:04:36,960
those uh tests and we say well we can

149
00:04:36,960 --> 00:04:39,000
run them on Hardware of course we can

150
00:04:39,000 --> 00:04:40,860
you know we've all built labs and

151
00:04:40,860 --> 00:04:42,900
there's large lab infrastructures that

152
00:04:42,900 --> 00:04:45,060
we've maintained for many years but

153
00:04:45,060 --> 00:04:47,160
they're pretty fragile you know Hardware

154
00:04:47,160 --> 00:04:50,220
fails fibers fail the the

155
00:04:50,220 --> 00:04:51,900
um Power fails all these kind of things

156
00:04:51,900 --> 00:04:53,940
kind of stop us getting to getting to

157
00:04:53,940 --> 00:04:55,979
the state the state where these tests

158
00:04:55,979 --> 00:04:58,440
are easy for us to repeat easy and easy

159
00:04:58,440 --> 00:05:00,300
for us to keep robust you know a test

160
00:05:00,300 --> 00:05:02,040
failure happens and you say well is it a

161
00:05:02,040 --> 00:05:03,780
hardware flake is it something to do

162
00:05:03,780 --> 00:05:05,400
with a failure in the the actual

163
00:05:05,400 --> 00:05:07,500
infrastructure was it that actually the

164
00:05:07,500 --> 00:05:08,940
lab wasn't in the state that it should

165
00:05:08,940 --> 00:05:10,020
have been even if I've got software

166
00:05:10,020 --> 00:05:11,160
that's trying to make sure that it is

167
00:05:11,160 --> 00:05:13,560
and so really by being able to say hey

168
00:05:13,560 --> 00:05:14,940
we're going to take these virtualized

169
00:05:14,940 --> 00:05:16,680
topologies I'm going to be able to turn

170
00:05:16,680 --> 00:05:18,240
them up really quickly which means we

171
00:05:18,240 --> 00:05:19,620
can start a new one every time that we

172
00:05:19,620 --> 00:05:22,259
that we want to we can manage their life

173
00:05:22,259 --> 00:05:24,300
cycle so we can take them from you know

174
00:05:24,300 --> 00:05:26,759
turn up a bunch of brand new devices

175
00:05:26,759 --> 00:05:28,860
emulated devices and then kick them off

176
00:05:28,860 --> 00:05:31,680
in hermetically with a sorry with a

177
00:05:31,680 --> 00:05:33,960
hermetic set of inputs to be in a known

178
00:05:33,960 --> 00:05:36,060
state that kind of gives us a way to be

179
00:05:36,060 --> 00:05:38,160
able to test things differently to how

180
00:05:38,160 --> 00:05:39,720
we would have done before we can start

181
00:05:39,720 --> 00:05:41,639
think about well actually like we can

182
00:05:41,639 --> 00:05:43,380
run all these this test Suite all this

183
00:05:43,380 --> 00:05:46,080
set of cases against these emulated

184
00:05:46,080 --> 00:05:48,060
topologies that gives us a way to know

185
00:05:48,060 --> 00:05:49,560
that the tests are good and then we can

186
00:05:49,560 --> 00:05:51,300
move on to the hardware isn't now that

187
00:05:51,300 --> 00:05:52,800
we have to wait for the hardware or fix

188
00:05:52,800 --> 00:05:54,419
these flakes to know that the thing

189
00:05:54,419 --> 00:05:55,620
we're developing or the thing we're

190
00:05:55,620 --> 00:05:57,780
regressing is is good

191
00:05:57,780 --> 00:06:00,720
and the it opens up a huge new set of

192
00:06:00,720 --> 00:06:02,280
new opportunities as well which is like

193
00:06:02,280 --> 00:06:03,600
sets of things that are really difficult

194
00:06:03,600 --> 00:06:06,360
for us to emulate uh to do in physical

195
00:06:06,360 --> 00:06:08,699
um infrastructure so things like link

196
00:06:08,699 --> 00:06:09,900
impairment

197
00:06:09,900 --> 00:06:11,940
well kind of what do I do I kind of go

198
00:06:11,940 --> 00:06:13,560
and bend the fiber a bit but I can't

199
00:06:13,560 --> 00:06:15,000
really do that repeatably I can't really

200
00:06:15,000 --> 00:06:17,100
do that in a way that that creates those

201
00:06:17,100 --> 00:06:19,380
non-happy path scenarios so another

202
00:06:19,380 --> 00:06:21,120
opportunity we're looking at and thing

203
00:06:21,120 --> 00:06:22,560
that we wanted to solve in looking at

204
00:06:22,560 --> 00:06:24,720
this this kind of infrastructure is can

205
00:06:24,720 --> 00:06:26,759
we start to think about well if it's in

206
00:06:26,759 --> 00:06:28,560
software can we have fault injection can

207
00:06:28,560 --> 00:06:30,900
we have ways to be able to introduce new

208
00:06:30,900 --> 00:06:33,479
impairments to the to the infrastructure

209
00:06:33,479 --> 00:06:36,660
the let us validate things

210
00:06:36,660 --> 00:06:38,819
so we've now kind of like developed some

211
00:06:38,819 --> 00:06:40,560
tests that are giving us some some

212
00:06:40,560 --> 00:06:42,479
confidence internally but you know for a

213
00:06:42,479 --> 00:06:43,800
bunch of our Network deployments we also

214
00:06:43,800 --> 00:06:45,960
have a company boundary in the way you

215
00:06:45,960 --> 00:06:47,880
know we have a supplier and we meet with

216
00:06:47,880 --> 00:06:50,280
the customer and a lot of the compliance

217
00:06:50,280 --> 00:06:51,539
that we've had in terms of those

218
00:06:51,539 --> 00:06:53,759
specifications is about is you know

219
00:06:53,759 --> 00:06:55,440
humans interpreting text whether it's

220
00:06:55,440 --> 00:06:58,199
rfcs or rfps you know how we read them

221
00:06:58,199 --> 00:07:00,660
we have our own interpretation and at

222
00:07:00,660 --> 00:07:02,220
the end of the day we will all seen

223
00:07:02,220 --> 00:07:04,020
cases where you know we we've

224
00:07:04,020 --> 00:07:05,460
interpreted things differently so the

225
00:07:05,460 --> 00:07:06,840
infrastructure doesn't actually work how

226
00:07:06,840 --> 00:07:08,039
we want the product it doesn't do what

227
00:07:08,039 --> 00:07:10,620
we need if we move that into code look

228
00:07:10,620 --> 00:07:12,240
at the way that we can say well here

229
00:07:12,240 --> 00:07:14,639
we've got a something like an automated

230
00:07:14,639 --> 00:07:17,400
test case that gives us a clear contract

231
00:07:17,400 --> 00:07:19,680
but we also like that gives us some you

232
00:07:19,680 --> 00:07:21,240
know some part of that problem but we

233
00:07:21,240 --> 00:07:22,680
need to have some way common way that we

234
00:07:22,680 --> 00:07:24,240
can actually run that you know I want to

235
00:07:24,240 --> 00:07:26,639
be able to give something to a uh to A

236
00:07:26,639 --> 00:07:28,259
supplier and say hey just run this thing

237
00:07:28,259 --> 00:07:31,500
and it does turns up from your from

238
00:07:31,500 --> 00:07:33,360
nothing to your product running in some

239
00:07:33,360 --> 00:07:35,880
scenario I care about and that then has

240
00:07:35,880 --> 00:07:38,220
a set of testing that runs against it

241
00:07:38,220 --> 00:07:40,680
that when that passes that's compliant

242
00:07:40,680 --> 00:07:42,000
I'm happy with it

243
00:07:42,000 --> 00:07:44,220
so we need to be able to have that that

244
00:07:44,220 --> 00:07:45,780
we really want to look at a way to have

245
00:07:45,780 --> 00:07:47,940
that um packaging to reproduce scenarios

246
00:07:47,940 --> 00:07:50,039
in a way that we can also introduce new

247
00:07:50,039 --> 00:07:52,080
vendors we don't want to have to you

248
00:07:52,080 --> 00:07:53,819
know re-specify this across different

249
00:07:53,819 --> 00:07:56,220
vendors

250
00:07:56,220 --> 00:07:58,080
and then once we kind of look at the

251
00:07:58,080 --> 00:08:00,479
these sets of compliance and individual

252
00:08:00,479 --> 00:08:02,220
products we want to also be able to look

253
00:08:02,220 --> 00:08:04,740
at scale and you know if we want to go

254
00:08:04,740 --> 00:08:07,020
go and have a production scale emulate

255
00:08:07,020 --> 00:08:09,240
uh production scale lab infrastructure

256
00:08:09,240 --> 00:08:10,919
it's going to cost the same as it cost

257
00:08:10,919 --> 00:08:12,660
or somewhere similar to what it costs to

258
00:08:12,660 --> 00:08:15,419
do in production and so you maybe have

259
00:08:15,419 --> 00:08:17,460
some of these scaling environments but

260
00:08:17,460 --> 00:08:19,979
not that many of them and when you build

261
00:08:19,979 --> 00:08:21,300
them you build them and they've got a

262
00:08:21,300 --> 00:08:23,699
fixed apology and so you have one

263
00:08:23,699 --> 00:08:24,780
environment but now you've got the

264
00:08:24,780 --> 00:08:26,099
problem of like well actually well

265
00:08:26,099 --> 00:08:27,780
production doesn't really look like that

266
00:08:27,780 --> 00:08:29,099
because it's in between these two states

267
00:08:29,099 --> 00:08:30,780
of the old way we're doing things in the

268
00:08:30,780 --> 00:08:32,339
new state of doing things so we want to

269
00:08:32,339 --> 00:08:33,779
be able to actually flexibly produce

270
00:08:33,779 --> 00:08:36,360
these topologies at some scale I want to

271
00:08:36,360 --> 00:08:37,679
be able to do a what if about what

272
00:08:37,679 --> 00:08:39,719
happens if I had the whole new design or

273
00:08:39,719 --> 00:08:41,880
what happens if I'm in some hybrid and

274
00:08:41,880 --> 00:08:44,219
this kind of the thinking about moving

275
00:08:44,219 --> 00:08:46,380
to some more emulation and more use of

276
00:08:46,380 --> 00:08:48,480
software in this area was to say well

277
00:08:48,480 --> 00:08:50,880
can we go to production scale and Beyond

278
00:08:50,880 --> 00:08:53,399
it and verify at that scale

279
00:08:53,399 --> 00:08:55,980
so this is really the set of problems

280
00:08:55,980 --> 00:08:58,140
and I'll hand over to Marcus who'll uh

281
00:08:58,140 --> 00:09:00,600
explain what he did when I moaned as a

282
00:09:00,600 --> 00:09:02,459
customer

283
00:09:02,459 --> 00:09:05,100
so uh y'all did have a slight preview

284
00:09:05,100 --> 00:09:07,320
earlier uh with the OTG side of things

285
00:09:07,320 --> 00:09:08,640
but uh now we're going to actually talk

286
00:09:08,640 --> 00:09:10,019
in a little bit more in depth on what

287
00:09:10,019 --> 00:09:14,279
KNE is and uh why we uh came up with it

288
00:09:14,279 --> 00:09:16,620
so you know all those things that Rob

289
00:09:16,620 --> 00:09:18,300
really talked about is what started us

290
00:09:18,300 --> 00:09:20,100
down this path of trying to answer a

291
00:09:20,100 --> 00:09:21,300
question of

292
00:09:21,300 --> 00:09:23,640
how do we provide a virtualized

293
00:09:23,640 --> 00:09:26,760
environment that actually scales with

294
00:09:26,760 --> 00:09:28,620
our needs and I think that's one of the

295
00:09:28,620 --> 00:09:31,500
biggest pieces of why we ended up at a

296
00:09:31,500 --> 00:09:33,080
place with kubernetes

297
00:09:33,080 --> 00:09:36,600
and the ability to scale from a single

298
00:09:36,600 --> 00:09:38,940
developer environment on a laptop all

299
00:09:38,940 --> 00:09:41,160
the way up to a thousand plus node

300
00:09:41,160 --> 00:09:44,160
worker pool you know holding thousands

301
00:09:44,160 --> 00:09:46,620
of actual container nodes simulating you

302
00:09:46,620 --> 00:09:49,080
know large-scale networking we really

303
00:09:49,080 --> 00:09:51,300
appreciated the the k8s environment

304
00:09:51,300 --> 00:09:54,420
around life cycle management and that is

305
00:09:54,420 --> 00:09:56,459
one of the was one of our uh you know

306
00:09:56,459 --> 00:09:58,860
big blockers when we first started doing

307
00:09:58,860 --> 00:10:00,899
emulation platforms was we were

308
00:10:00,899 --> 00:10:02,940
Reinventing life cycle management you

309
00:10:02,940 --> 00:10:04,860
know uh you know the various vendors

310
00:10:04,860 --> 00:10:08,880
would provide us with a VM but VMS are

311
00:10:08,880 --> 00:10:10,980
are you know not a stable API every

312
00:10:10,980 --> 00:10:13,620
kernel version every new compilation can

313
00:10:13,620 --> 00:10:16,140
introduce new dependencies on the host

314
00:10:16,140 --> 00:10:17,640
that you're actually about to try and

315
00:10:17,640 --> 00:10:21,000
run that VM on and whereas kubernetes

316
00:10:21,000 --> 00:10:23,339
contain trainers have mainly abstracted

317
00:10:23,339 --> 00:10:26,459
a lot of those details away and so

318
00:10:26,459 --> 00:10:28,200
that's uh you know where we ended up

319
00:10:28,200 --> 00:10:30,360
with hey

320
00:10:30,360 --> 00:10:32,399
let's let kubernetes do what it does

321
00:10:32,399 --> 00:10:33,839
good which is life cycle management of

322
00:10:33,839 --> 00:10:36,120
containers let's get the vendors to

323
00:10:36,120 --> 00:10:37,740
partner with us on developing real

324
00:10:37,740 --> 00:10:40,620
container based Network os's and then

325
00:10:40,620 --> 00:10:43,800
we'll work on providing the actual uh

326
00:10:43,800 --> 00:10:45,959
wire transport to move you know the L2

327
00:10:45,959 --> 00:10:48,360
frames across a uh you know emulated

328
00:10:48,360 --> 00:10:50,600
Network

329
00:10:52,140 --> 00:10:53,820
so

330
00:10:53,820 --> 00:10:55,560
you know

331
00:10:55,560 --> 00:10:57,720
when talking about container container

332
00:10:57,720 --> 00:11:01,260
first again when we look at VMS VMS are

333
00:11:01,260 --> 00:11:03,839
very fat uh they they were their own OS

334
00:11:03,839 --> 00:11:05,399
I mean they're the full stack of os

335
00:11:05,399 --> 00:11:07,260
whereas containers you know there can be

336
00:11:07,260 --> 00:11:09,360
very low consumption uh can strip off

337
00:11:09,360 --> 00:11:11,339
most of the things that really aren't

338
00:11:11,339 --> 00:11:12,720
core to the functionality that we were

339
00:11:12,720 --> 00:11:14,100
really talking about because most of the

340
00:11:14,100 --> 00:11:15,540
time when we're talking about what are

341
00:11:15,540 --> 00:11:17,820
we testing about a network OS we're

342
00:11:17,820 --> 00:11:18,600
really talking about the control

343
00:11:18,600 --> 00:11:20,459
processes right we're talking about user

344
00:11:20,459 --> 00:11:22,760
space processes nothing magic past that

345
00:11:22,760 --> 00:11:25,740
there is a forwarding plane element but

346
00:11:25,740 --> 00:11:27,600
that forwarding plane element isn't

347
00:11:27,600 --> 00:11:29,519
really normally is implemented by the

348
00:11:29,519 --> 00:11:31,200
vendors in their own user space

349
00:11:31,200 --> 00:11:33,360
emulation as well they you know the

350
00:11:33,360 --> 00:11:34,700
whole point is to not use the Linux

351
00:11:34,700 --> 00:11:37,019
kernel you actually want to you know

352
00:11:37,019 --> 00:11:40,920
emulate some form of an Asic

353
00:11:40,920 --> 00:11:41,779
um

354
00:11:41,779 --> 00:11:45,000
by using k8s we also you know have a

355
00:11:45,000 --> 00:11:47,459
clear standardized API for how the

356
00:11:47,459 --> 00:11:49,440
vendors package that up we say hey we're

357
00:11:49,440 --> 00:11:50,640
going to provide you with this set of

358
00:11:50,640 --> 00:11:52,560
emulated interfaces when you boot you

359
00:11:52,560 --> 00:11:54,720
map those those internal uh provided

360
00:11:54,720 --> 00:11:56,940
Linux interfaces to your respective

361
00:11:56,940 --> 00:11:59,700
Hardware represented interfaces

362
00:11:59,700 --> 00:12:01,320
um we have an obviously standard image

363
00:12:01,320 --> 00:12:03,480
format and we have a standard lifecycle

364
00:12:03,480 --> 00:12:05,940
management system uh one of the other

365
00:12:05,940 --> 00:12:08,880
big pluses in the ks world is the

366
00:12:08,880 --> 00:12:11,940
operator uh pattern and so we've

367
00:12:11,940 --> 00:12:12,899
actually worked with the vendors not

368
00:12:12,899 --> 00:12:14,399
only to give us the images but almost

369
00:12:14,399 --> 00:12:16,800
all of them have actually completed uh

370
00:12:16,800 --> 00:12:19,019
implementing their own operators so you

371
00:12:19,019 --> 00:12:22,019
even get the vendor ownership when using

372
00:12:22,019 --> 00:12:25,200
KNE of not only do I not have to worry

373
00:12:25,200 --> 00:12:27,839
about how to bring up the uh container

374
00:12:27,839 --> 00:12:29,820
but the vendor actually owns that and

375
00:12:29,820 --> 00:12:31,200
maintains how they bring up their

376
00:12:31,200 --> 00:12:33,620
containers

377
00:12:33,779 --> 00:12:35,700
um the last little point is well we do

378
00:12:35,700 --> 00:12:37,620
also still support VMS because there are

379
00:12:37,620 --> 00:12:40,140
certain os's which are not uh container

380
00:12:40,140 --> 00:12:42,480
friendly we still have a mode for that

381
00:12:42,480 --> 00:12:44,399
it's not generally the one we we go with

382
00:12:44,399 --> 00:12:47,220
but obviously you know in the network

383
00:12:47,220 --> 00:12:49,980
operations world we know uh we are stuck

384
00:12:49,980 --> 00:12:51,240
with things for sometimes longer than

385
00:12:51,240 --> 00:12:53,600
we'd like

386
00:12:56,399 --> 00:12:57,720
um you know

387
00:12:57,720 --> 00:12:59,160
all right we definitely when looking at

388
00:12:59,160 --> 00:13:01,920
k8s it was leverage everything we can

389
00:13:01,920 --> 00:13:03,959
and so when it came to well how are we

390
00:13:03,959 --> 00:13:05,399
going to do these Network wires how are

391
00:13:05,399 --> 00:13:06,600
we going to do the L2 connectivity

392
00:13:06,600 --> 00:13:08,880
between the containers uh well we stole

393
00:13:08,880 --> 00:13:11,160
what we could and we had found a really

394
00:13:11,160 --> 00:13:15,720
good partner uh with uh Network op and

395
00:13:15,720 --> 00:13:18,240
um who built meshnet which is originally

396
00:13:18,240 --> 00:13:23,339
was a vxlan ve based L2 cni plug-in and

397
00:13:23,339 --> 00:13:25,200
we worked with them to modify it

398
00:13:25,200 --> 00:13:27,660
slightly so that worked with us in knee

399
00:13:27,660 --> 00:13:29,000
and so

400
00:13:29,000 --> 00:13:33,000
basically we can fire up a base just kns

401
00:13:33,000 --> 00:13:36,420
cluster deploy the mesh net cni uh

402
00:13:36,420 --> 00:13:38,100
deploy a load balancer onto it and then

403
00:13:38,100 --> 00:13:39,300
we can just take the vendor container

404
00:13:39,300 --> 00:13:40,800
operators deploy those and then we can

405
00:13:40,800 --> 00:13:43,860
start firing up uh any topologies we're

406
00:13:43,860 --> 00:13:47,360
looking for using just crds

407
00:13:47,760 --> 00:13:49,820
fundamental concept

408
00:13:49,820 --> 00:13:52,980
within akne topology

409
00:13:52,980 --> 00:13:54,540
unfortunately we did pick some bad

410
00:13:54,540 --> 00:13:56,100
naming in places because you'll see the

411
00:13:56,100 --> 00:13:58,019
word nodes and when we we talk about

412
00:13:58,019 --> 00:14:00,420
candy node we really refer to the

413
00:14:00,420 --> 00:14:02,279
network node you're actually emulating

414
00:14:02,279 --> 00:14:05,100
not the worker node that the k8s is

415
00:14:05,100 --> 00:14:06,660
actually going to drive you know run the

416
00:14:06,660 --> 00:14:08,000
process from

417
00:14:08,000 --> 00:14:10,680
but basically we have nodes and links

418
00:14:10,680 --> 00:14:13,980
and services and the node as we

419
00:14:13,980 --> 00:14:15,600
described can be any vendor container

420
00:14:15,600 --> 00:14:18,899
and the links are simply describing the

421
00:14:18,899 --> 00:14:20,579
L2 connection that we're going to

422
00:14:20,579 --> 00:14:23,459
deliver between the two two nodes and

423
00:14:23,459 --> 00:14:25,500
services are simply going to be your

424
00:14:25,500 --> 00:14:27,779
load balance service is exported through

425
00:14:27,779 --> 00:14:31,260
to k8s from the nodes for providing all

426
00:14:31,260 --> 00:14:34,620
the base level SSH gnmi greeby type

427
00:14:34,620 --> 00:14:37,320
services that we support

428
00:14:37,320 --> 00:14:39,600
mm-hmm

429
00:14:39,600 --> 00:14:42,779
so where do you start

430
00:14:42,779 --> 00:14:45,779
so unfortunately uh uh all of the

431
00:14:45,779 --> 00:14:47,160
vendors have not open sourced all of

432
00:14:47,160 --> 00:14:49,500
their uh container images yet so it is

433
00:14:49,500 --> 00:14:52,019
on the the the person to acquire your

434
00:14:52,019 --> 00:14:54,480
network images uh most of the vendors

435
00:14:54,480 --> 00:14:56,100
and pretty much all the big vendors

436
00:14:56,100 --> 00:14:58,440
support uh containerized version of an

437
00:14:58,440 --> 00:15:00,060
OS so you can work with them to get

438
00:15:00,060 --> 00:15:01,980
those once you have them you define your

439
00:15:01,980 --> 00:15:04,500
node in a simple uh topology protocol

440
00:15:04,500 --> 00:15:07,740
buffer and the services and links and

441
00:15:07,740 --> 00:15:10,320
basically there's a knee command to both

442
00:15:10,320 --> 00:15:12,060
create a cluster if you want to run a

443
00:15:12,060 --> 00:15:14,699
local cluster as well as a k uh the

444
00:15:14,699 --> 00:15:16,980
candy create which we'll just talk to an

445
00:15:16,980 --> 00:15:20,160
existing kubernetes cluster

446
00:15:20,160 --> 00:15:22,079
so what does that look like

447
00:15:22,079 --> 00:15:24,779
um we try to keep it simple we just have

448
00:15:24,779 --> 00:15:27,180
a simple protocol buffer that allows you

449
00:15:27,180 --> 00:15:29,339
to specify what type of os you're

450
00:15:29,339 --> 00:15:31,740
looking for what kind of node and uh

451
00:15:31,740 --> 00:15:33,540
basically a config Element Section that

452
00:15:33,540 --> 00:15:35,399
just says what container path are you

453
00:15:35,399 --> 00:15:37,800
looking for and then we also allow you

454
00:15:37,800 --> 00:15:39,959
mounting configs so that the devices can

455
00:15:39,959 --> 00:15:42,720
actually boot with a boot config and

456
00:15:42,720 --> 00:15:45,120
then at that point

457
00:15:45,120 --> 00:15:46,680
um

458
00:15:46,680 --> 00:15:49,320
you can now specify the interfaces which

459
00:15:49,320 --> 00:15:50,399
are going to be these are going to be

460
00:15:50,399 --> 00:15:52,079
the interfaces used by your link to

461
00:15:52,079 --> 00:15:54,240
describe how how you want to do your

462
00:15:54,240 --> 00:15:55,860
mapping so the interface section here in

463
00:15:55,860 --> 00:15:58,800
this case we have a Cisco xrd node and

464
00:15:58,800 --> 00:16:00,959
we are simply saying hey your eth1

465
00:16:00,959 --> 00:16:02,639
that's going to be referenced inside the

466
00:16:02,639 --> 00:16:06,180
container as a gigabit Ethernet 0 0 and

467
00:16:06,180 --> 00:16:09,480
you can this allows actually you to link

468
00:16:09,480 --> 00:16:11,880
your like say you have a actual

469
00:16:11,880 --> 00:16:13,560
operational config that actually has

470
00:16:13,560 --> 00:16:16,079
specific devices named uh you can use

471
00:16:16,079 --> 00:16:17,880
this to help you map those so that you

472
00:16:17,880 --> 00:16:19,800
can actually kind of keep a

473
00:16:19,800 --> 00:16:21,480
um you know maybe a production like

474
00:16:21,480 --> 00:16:23,639
config uh and and you could still use

475
00:16:23,639 --> 00:16:26,339
that same config interface naming uh in

476
00:16:26,339 --> 00:16:28,880
your emulation

477
00:16:29,160 --> 00:16:30,959
um Services uh they're just defined

478
00:16:30,959 --> 00:16:33,120
basically this is just giving you a

479
00:16:33,120 --> 00:16:35,160
mapping to allow you to say if you want

480
00:16:35,160 --> 00:16:36,660
to SSH to your device or you want to

481
00:16:36,660 --> 00:16:39,600
connect to a open config gnmi service

482
00:16:39,600 --> 00:16:41,399
um we have a you know kind of an

483
00:16:41,399 --> 00:16:43,139
internal to external mapping this lets

484
00:16:43,139 --> 00:16:45,060
you also normalize uh some vendors run

485
00:16:45,060 --> 00:16:47,220
specific services on internally

486
00:16:47,220 --> 00:16:49,500
different ports so we again this kind of

487
00:16:49,500 --> 00:16:50,940
lets you have a consistent presentation

488
00:16:50,940 --> 00:16:52,860
uh when you're coming out of the cluster

489
00:16:52,860 --> 00:16:55,620
to say hey all of my devices my gmmi is

490
00:16:55,620 --> 00:16:58,259
going to be in this case 50 000 uh 50

491
00:16:58,259 --> 00:17:00,480
051.

492
00:17:00,480 --> 00:17:01,520
links

493
00:17:01,520 --> 00:17:03,300
[Music]

494
00:17:03,300 --> 00:17:06,559
Rob and his pictures

495
00:17:06,900 --> 00:17:09,540
um so links uh we go with uh just a

496
00:17:09,540 --> 00:17:10,500
simple

497
00:17:10,500 --> 00:17:12,480
um setup of saying hey give me my easies

498
00:17:12,480 --> 00:17:14,280
and those are basically going to build

499
00:17:14,280 --> 00:17:17,359
uh once once the crd gets populated

500
00:17:17,359 --> 00:17:19,500
meshnet will go to work and actually lay

501
00:17:19,500 --> 00:17:21,240
out your Vees between all of those

502
00:17:21,240 --> 00:17:24,119
worker containers and we actually did

503
00:17:24,119 --> 00:17:26,299
just actually landed a change to where

504
00:17:26,299 --> 00:17:29,400
uh National originally used vxlan vxlan

505
00:17:29,400 --> 00:17:31,260
has a couple of issues around mtus and

506
00:17:31,260 --> 00:17:32,760
things like that so we actually replace

507
00:17:32,760 --> 00:17:35,039
that with actually a grpc wire transport

508
00:17:35,039 --> 00:17:38,039
so this allows us to basically send any

509
00:17:38,039 --> 00:17:41,160
MTU between nodes and so we can support

510
00:17:41,160 --> 00:17:44,100
you know whatever

511
00:17:44,100 --> 00:17:45,840
um whatever whatever Trend you know

512
00:17:45,840 --> 00:17:48,000
whatever frame size needs to be there

513
00:17:48,000 --> 00:17:50,340
um also some inner working with like

514
00:17:50,340 --> 00:17:52,860
Isis uh since the Linux kernel itself

515
00:17:52,860 --> 00:17:55,919
sometimes will uh eat those eat pdus

516
00:17:55,919 --> 00:17:58,980
that match specific Max by going to grpc

517
00:17:58,980 --> 00:18:00,660
wire and pulling the Linux bridge out of

518
00:18:00,660 --> 00:18:02,880
that mix lets us send uh sends those

519
00:18:02,880 --> 00:18:06,179
frames without any issues

520
00:18:06,179 --> 00:18:09,299
uh here's a simple simple topology

521
00:18:09,299 --> 00:18:11,340
um basically this is a three node

522
00:18:11,340 --> 00:18:13,620
topology with lags between the devices

523
00:18:13,620 --> 00:18:16,200
and so we just want to show you roughly

524
00:18:16,200 --> 00:18:17,700
uh you know this is what we would

525
00:18:17,700 --> 00:18:19,200
consider a pretty small topologies like

526
00:18:19,200 --> 00:18:20,520
actually this is one of our simplest

527
00:18:20,520 --> 00:18:23,100
topologies we use during our testing of

528
00:18:23,100 --> 00:18:24,360
knee to make sure we didn't break

529
00:18:24,360 --> 00:18:26,400
anything

530
00:18:26,400 --> 00:18:29,220
um this shows you the node uh the the

531
00:18:29,220 --> 00:18:31,080
node interface and then the interface is

532
00:18:31,080 --> 00:18:33,720
connected to it uh through its interface

533
00:18:33,720 --> 00:18:36,600
names through the uh mesh net links and

534
00:18:36,600 --> 00:18:38,700
then to the remote side uh we have like

535
00:18:38,700 --> 00:18:40,919
a simple visualization that basically

536
00:18:40,919 --> 00:18:42,960
will produce these pick topologies based

537
00:18:42,960 --> 00:18:46,980
on the provided uh Proto

538
00:18:46,980 --> 00:18:48,960
so whenever I mention the vendors these

539
00:18:48,960 --> 00:18:49,980
are all the vendors that are currently

540
00:18:49,980 --> 00:18:52,980
supported within the ecosystem uh Aristo

541
00:18:52,980 --> 00:18:55,799
Juniper Cisco Nokia and keysight uh you

542
00:18:55,799 --> 00:18:57,120
know have all given us you know major

543
00:18:57,120 --> 00:18:58,679
props around

544
00:18:58,679 --> 00:18:59,280
um

545
00:18:59,280 --> 00:19:01,260
you know working with us not only to to

546
00:19:01,260 --> 00:19:02,820
give us the container images but also to

547
00:19:02,820 --> 00:19:04,559
provide operators

548
00:19:04,559 --> 00:19:06,059
um you know keysight especially you know

549
00:19:06,059 --> 00:19:08,820
if you saw the presentation earlier uh

550
00:19:08,820 --> 00:19:11,039
big contributor on being able for us to

551
00:19:11,039 --> 00:19:13,320
actually have a full production

552
00:19:13,320 --> 00:19:15,840
um platform for traffic generation and

553
00:19:15,840 --> 00:19:17,340
uh

554
00:19:17,340 --> 00:19:20,039
protocols

555
00:19:20,039 --> 00:19:22,080
uh additionally

556
00:19:22,080 --> 00:19:23,640
you can actually start any container you

557
00:19:23,640 --> 00:19:25,679
want if you specify just a what we call

558
00:19:25,679 --> 00:19:28,140
a host node you can start up any Linux

559
00:19:28,140 --> 00:19:30,179
container that you may have so this also

560
00:19:30,179 --> 00:19:31,559
lets you take it not only to just like

561
00:19:31,559 --> 00:19:32,760
kind of a functional test but you could

562
00:19:32,760 --> 00:19:34,380
actually have a full integration test

563
00:19:34,380 --> 00:19:35,640
here as well because you could bring up

564
00:19:35,640 --> 00:19:37,500
any of your own service controllers in

565
00:19:37,500 --> 00:19:39,799
this environment and that would talk uh

566
00:19:39,799 --> 00:19:43,400
consistently across everything

567
00:19:45,360 --> 00:19:49,020
okay so that's Kenny in a nutshell I'll

568
00:19:49,020 --> 00:19:50,520
talk a little bit now about what we're

569
00:19:50,520 --> 00:19:53,340
actually using uh Kenny for and so this

570
00:19:53,340 --> 00:19:54,660
is coming back to some of the the use

571
00:19:54,660 --> 00:19:56,580
cases I was discussing at the start

572
00:19:56,580 --> 00:19:57,960
what we'd like to be able to do is

573
00:19:57,960 --> 00:19:59,940
programmatically repeatedly validate

574
00:19:59,940 --> 00:20:01,620
Network deployments and of course when

575
00:20:01,620 --> 00:20:03,059
you think about that statement you think

576
00:20:03,059 --> 00:20:06,780
about muskrat right which is an under

577
00:20:06,780 --> 00:20:08,700
um of course you don't what you have you

578
00:20:08,700 --> 00:20:09,720
do is you come up with a terrible

579
00:20:09,720 --> 00:20:11,280
acronym and then you figure out oh it

580
00:20:11,280 --> 00:20:12,900
sounds like an animal and so then you've

581
00:20:12,900 --> 00:20:14,700
got you've got your logo canned so

582
00:20:14,700 --> 00:20:16,740
that's that's what we did

583
00:20:16,740 --> 00:20:19,140
um too much confusion of lots of muscles

584
00:20:19,140 --> 00:20:21,600
pictures around the office so on that

585
00:20:21,600 --> 00:20:24,120
throws the open network device automated

586
00:20:24,120 --> 00:20:26,340
test Runner and API I told you it was a

587
00:20:26,340 --> 00:20:27,900
terrible background

588
00:20:27,900 --> 00:20:30,059
um and essentially what we this is in

589
00:20:30,059 --> 00:20:31,620
the wider ecosystem we've been working

590
00:20:31,620 --> 00:20:33,780
on is a way to be able to have a test

591
00:20:33,780 --> 00:20:37,020
framework that is very user-friendly

592
00:20:37,020 --> 00:20:39,240
promo I'm a network person wanting to do

593
00:20:39,240 --> 00:20:41,460
some Network testing and abstracts a lot

594
00:20:41,460 --> 00:20:44,640
of the details away from you so how what

595
00:20:44,640 --> 00:20:46,559
what the framework breaks down into is

596
00:20:46,559 --> 00:20:49,500
we have a test that's Express are

597
00:20:49,500 --> 00:20:51,240
expressed in code

598
00:20:51,240 --> 00:20:52,679
um this is the part of the kind of

599
00:20:52,679 --> 00:20:54,419
consistent contract that we're trying to

600
00:20:54,419 --> 00:20:55,440
provide

601
00:20:55,440 --> 00:20:57,960
um we write them in go and the network

602
00:20:57,960 --> 00:20:59,940
teams that want to write tests own this

603
00:20:59,940 --> 00:21:02,100
this test case what the test case looks

604
00:21:02,100 --> 00:21:03,179
like is it's calling a bunch of

605
00:21:03,179 --> 00:21:05,640
undoubted apis and those apis expose

606
00:21:05,640 --> 00:21:07,440
some of the sort of fundamental parts of

607
00:21:07,440 --> 00:21:09,059
the topology of the topology that you

608
00:21:09,059 --> 00:21:10,679
might need to do details about the test

609
00:21:10,679 --> 00:21:12,240
bed you know I'm dealing with an

610
00:21:12,240 --> 00:21:13,860
abstract device tell me what this port

611
00:21:13,860 --> 00:21:15,240
name is because I actually need to know

612
00:21:15,240 --> 00:21:17,340
it at this point in time or push some

613
00:21:17,340 --> 00:21:19,980
configuration read Telemetry from the

614
00:21:19,980 --> 00:21:22,140
device do some operation like upgrade

615
00:21:22,140 --> 00:21:25,140
the OS or prod a demon that's running on

616
00:21:25,140 --> 00:21:27,660
the on the device and then the traffic

617
00:21:27,660 --> 00:21:29,580
generation so your test case looks like

618
00:21:29,580 --> 00:21:31,679
essentially a relatively

619
00:21:31,679 --> 00:21:34,860
um opinionated set of apis that give you

620
00:21:34,860 --> 00:21:37,559
a clear sort of readable test case uh to

621
00:21:37,559 --> 00:21:40,440
be able to express your your test in on

622
00:21:40,440 --> 00:21:42,539
that herself then takes those sets of

623
00:21:42,539 --> 00:21:45,179
capabilities expresses them through a

624
00:21:45,179 --> 00:21:47,820
binding into the actual infrastructure

625
00:21:47,820 --> 00:21:49,380
in the lab so that's the you know the

626
00:21:49,380 --> 00:21:51,000
physical or the virtual resources that

627
00:21:51,000 --> 00:21:53,159
the tests run on so The Binding layer

628
00:21:53,159 --> 00:21:54,600
here is something that we'd specifically

629
00:21:54,600 --> 00:21:56,340
introduce thinking about well okay we

630
00:21:56,340 --> 00:21:58,260
might want to do this in not only in our

631
00:21:58,260 --> 00:22:00,120
own environment not only in other

632
00:22:00,120 --> 00:22:01,500
people's physical environments but also

633
00:22:01,500 --> 00:22:02,820
in Virtual environments where we want to

634
00:22:02,820 --> 00:22:04,320
abstract some of the differences between

635
00:22:04,320 --> 00:22:06,780
the you know the fact that that there

636
00:22:06,780 --> 00:22:08,100
might need to be a reservation system

637
00:22:08,100 --> 00:22:10,080
and a physical topology that says well

638
00:22:10,080 --> 00:22:12,600
can I get hold of this device versus in

639
00:22:12,600 --> 00:22:14,340
k e well you've probably got your own

640
00:22:14,340 --> 00:22:16,380
thing so the answer is yes you can have

641
00:22:16,380 --> 00:22:19,140
your own device so the the overall

642
00:22:19,140 --> 00:22:21,840
breakdown here is a a set of

643
00:22:21,840 --> 00:22:23,520
infrastructure that gives us a way to be

644
00:22:23,520 --> 00:22:25,380
able to express these test cases that

645
00:22:25,380 --> 00:22:26,940
takes into account that we've got this

646
00:22:26,940 --> 00:22:29,159
emulated uh and physical infrastructure

647
00:22:29,159 --> 00:22:30,299
to be able to accelerate that

648
00:22:30,299 --> 00:22:31,860
development

649
00:22:31,860 --> 00:22:33,720
and what that breaks down into is that

650
00:22:33,720 --> 00:22:35,580
something that we're building is what

651
00:22:35,580 --> 00:22:36,720
we're calling as functional or

652
00:22:36,720 --> 00:22:38,340
Standalone testing essentially we're

653
00:22:38,340 --> 00:22:40,679
trying to build a set of tests that give

654
00:22:40,679 --> 00:22:43,260
us a way to work with simple topologies

655
00:22:43,260 --> 00:22:44,880
whether they're one device or you know

656
00:22:44,880 --> 00:22:46,740
small number of devices to be able to

657
00:22:46,740 --> 00:22:48,120
validate the functionalities of the

658
00:22:48,120 --> 00:22:49,320
device you can really think about this

659
00:22:49,320 --> 00:22:51,360
like well I've got this black box sort

660
00:22:51,360 --> 00:22:53,100
of function that came in that was the

661
00:22:53,100 --> 00:22:54,419
network device and I want to think about

662
00:22:54,419 --> 00:22:56,460
how do I unit test it and how do I then

663
00:22:56,460 --> 00:22:58,320
start to integration test it so that as

664
00:22:58,320 --> 00:23:00,059
we move forward we can think about the

665
00:23:00,059 --> 00:23:01,679
changes in that infrastructure running

666
00:23:01,679 --> 00:23:04,620
through a CI CD pipeline in the same way

667
00:23:04,620 --> 00:23:07,620
it would have would if it's code but

668
00:23:07,620 --> 00:23:10,140
give us some way to when a test fails we

669
00:23:10,140 --> 00:23:11,460
don't have to say well okay this this

670
00:23:11,460 --> 00:23:13,440
complex topology failed let's go debug

671
00:23:13,440 --> 00:23:16,140
it it's like as simple as well this unit

672
00:23:16,140 --> 00:23:17,460
test will so of course all the other

673
00:23:17,460 --> 00:23:19,380
things fail so let's start there and on

674
00:23:19,380 --> 00:23:20,880
that gives us the way to be able to

675
00:23:20,880 --> 00:23:23,280
express these things and after the the

676
00:23:23,280 --> 00:23:26,100
infrastructure the provides away the we

677
00:23:26,100 --> 00:23:27,419
interface with the different parts of

678
00:23:27,419 --> 00:23:30,659
the the the the system that are going to

679
00:23:30,659 --> 00:23:33,179
deal with the test so for example if I

680
00:23:33,179 --> 00:23:35,700
run through a kind of basic test case

681
00:23:35,700 --> 00:23:38,100
the test case will come up that before

682
00:23:38,100 --> 00:23:40,140
the user gets any of their code run on

683
00:23:40,140 --> 00:23:42,659
data goes makes a reservation call gets

684
00:23:42,659 --> 00:23:44,700
whatever the underlying system is as

685
00:23:44,700 --> 00:23:46,260
part of that reservation call one of the

686
00:23:46,260 --> 00:23:48,059
things we do is reset the configuration

687
00:23:48,059 --> 00:23:49,980
of the device to some known config

688
00:23:49,980 --> 00:23:52,080
config based config that you can start

689
00:23:52,080 --> 00:23:55,080
with and then on that allows you to step

690
00:23:55,080 --> 00:23:56,720
through the test case

691
00:23:56,720 --> 00:23:58,440
abstracting from you what the device

692
00:23:58,440 --> 00:24:00,299
under test is and the automated test

693
00:24:00,299 --> 00:24:03,120
equipment like traffic generator that

694
00:24:03,120 --> 00:24:04,559
would sit alongside it that help you do

695
00:24:04,559 --> 00:24:06,059
some black box validation of those

696
00:24:06,059 --> 00:24:07,980
devices so this is something that we've

697
00:24:07,980 --> 00:24:09,840
been using KNE for helping our

698
00:24:09,840 --> 00:24:12,539
development of and and on that draw is

699
00:24:12,539 --> 00:24:15,740
the way that we realize it

700
00:24:16,140 --> 00:24:17,700
did not expect there all to be a white

701
00:24:17,700 --> 00:24:19,140
slide there

702
00:24:19,140 --> 00:24:20,220
um

703
00:24:20,220 --> 00:24:23,760
so how does k e help us in this

704
00:24:23,760 --> 00:24:26,039
um it gives us a way as I kind of said

705
00:24:26,039 --> 00:24:27,659
that we want to be able to you know

706
00:24:27,659 --> 00:24:29,940
start out with I've got this new feature

707
00:24:29,940 --> 00:24:31,559
that I want to run on the network device

708
00:24:31,559 --> 00:24:33,840
I'm going to start out with well I spin

709
00:24:33,840 --> 00:24:35,460
it up on my laptop

710
00:24:35,460 --> 00:24:39,059
I have candy running I have xcc or

711
00:24:39,059 --> 00:24:41,280
another traffic generator I have my

712
00:24:41,280 --> 00:24:43,020
device into test container and I can

713
00:24:43,020 --> 00:24:45,000
iterate I can experiment I didn't use

714
00:24:45,000 --> 00:24:47,520
anyone else's resources to do this

715
00:24:47,520 --> 00:24:50,159
um and we we can then take those those

716
00:24:50,159 --> 00:24:52,440
changes as we commit them put them into

717
00:24:52,440 --> 00:24:54,780
open source repository we're building

718
00:24:54,780 --> 00:24:56,760
this test like around open config and

719
00:24:56,760 --> 00:24:58,740
you kind of think about the the way that

720
00:24:58,740 --> 00:25:00,600
we get some of the other abstraction of

721
00:25:00,600 --> 00:25:02,220
the devices through those the the

722
00:25:02,220 --> 00:25:04,320
standard data models and grpc services

723
00:25:04,320 --> 00:25:06,059
we've been working with to make this

724
00:25:06,059 --> 00:25:07,620
these test cases portable across

725
00:25:07,620 --> 00:25:09,659
different implementations so now we

726
00:25:09,659 --> 00:25:11,940
we're integrating these test cases into

727
00:25:11,940 --> 00:25:13,620
open config but now you can just run

728
00:25:13,620 --> 00:25:16,020
this like you would run any CI CD

729
00:25:16,020 --> 00:25:18,360
testing so you say well I could launch

730
00:25:18,360 --> 00:25:21,179
it with a GitHub action startup a VM in

731
00:25:21,179 --> 00:25:23,280
gcp or in wherever you would like it to

732
00:25:23,280 --> 00:25:24,840
be spin up

733
00:25:24,840 --> 00:25:27,900
um KNE on that and then create the same

734
00:25:27,900 --> 00:25:29,700
topology and have this as a repeatable

735
00:25:29,700 --> 00:25:32,460
process that runs

736
00:25:32,460 --> 00:25:34,320
so we're going to do a demo

737
00:25:34,320 --> 00:25:36,480
unfortunately Greg who is our the tech

738
00:25:36,480 --> 00:25:38,520
lead for for and outro wasn't able to be

739
00:25:38,520 --> 00:25:39,539
here so we're going to run through the

740
00:25:39,539 --> 00:25:41,100
video of the demo and then we'll come

741
00:25:41,100 --> 00:25:44,400
back and have some some closing thoughts

742
00:25:44,400 --> 00:25:48,260
so I'm hoping this is just going to play

743
00:25:57,360 --> 00:25:59,840
okay

744
00:26:02,760 --> 00:26:05,460
any guidance on how to get it the video

745
00:26:05,460 --> 00:26:07,320
to play I assumed it would just auto

746
00:26:07,320 --> 00:26:09,620
play

747
00:26:16,740 --> 00:26:19,740
okay

748
00:26:37,080 --> 00:26:39,620
audio

749
00:26:39,840 --> 00:26:42,840
foreign

750
00:26:46,440 --> 00:26:49,260
before we set up knee itself we first

751
00:26:49,260 --> 00:26:51,840
need to install four of its appliances

752
00:26:51,840 --> 00:26:53,880
I'll start by verifying that I am go

753
00:26:53,880 --> 00:26:55,320
installed

754
00:26:55,320 --> 00:26:58,860
I need Go version at least 1.18 here I

755
00:26:58,860 --> 00:27:02,220
have 1.19 which will work fine

756
00:27:02,220 --> 00:27:04,020
next I'll check that I have Docker

757
00:27:04,020 --> 00:27:05,100
installed

758
00:27:05,100 --> 00:27:08,279
walk around hello world and I do indeed

759
00:27:08,279 --> 00:27:11,340
have Docker installed correctly

760
00:27:11,340 --> 00:27:13,679
third I'll install Cube

761
00:27:13,679 --> 00:27:15,779
Cube Kettle is a command line tool for

762
00:27:15,779 --> 00:27:18,779
interacting with kubernetes

763
00:27:18,779 --> 00:27:21,240
download it

764
00:27:21,240 --> 00:27:24,179
and install it

765
00:27:24,179 --> 00:27:25,799
done

766
00:27:25,799 --> 00:27:28,980
and fourth I'll install kind kind is a

767
00:27:28,980 --> 00:27:30,360
tool for running local kubernetes

768
00:27:30,360 --> 00:27:33,059
clusters in Docker containers

769
00:27:33,059 --> 00:27:37,559
I'll install kind version 0.14

770
00:27:38,340 --> 00:27:40,740
now I have the dependencies of candy

771
00:27:40,740 --> 00:27:43,380
installed and I'm going to install k e

772
00:27:43,380 --> 00:27:44,940
itself

773
00:27:44,940 --> 00:27:47,520
I'm going to clone the knee GitHub

774
00:27:47,520 --> 00:27:49,760
project

775
00:27:51,059 --> 00:27:53,640
I'm going to CD into

776
00:27:53,640 --> 00:27:56,760
the knee CLI directory

777
00:27:56,760 --> 00:27:59,460
I'm going to build the knee CLI that's

778
00:27:59,460 --> 00:28:01,559
the only part of knee we're going to

779
00:28:01,559 --> 00:28:05,418
need to build here is the CLI tool

780
00:28:09,059 --> 00:28:13,639
that has been built and now I'll verify

781
00:28:13,860 --> 00:28:16,559
that knee has been installed and set up

782
00:28:16,559 --> 00:28:18,840
correctly

783
00:28:18,840 --> 00:28:21,600
now we will create a network topology

784
00:28:21,600 --> 00:28:24,419
with KNE

785
00:28:24,419 --> 00:28:26,520
the network topology we are going to

786
00:28:26,520 --> 00:28:29,279
create in this demo is available as an

787
00:28:29,279 --> 00:28:31,380
example topology in the knee GitHub

788
00:28:31,380 --> 00:28:34,559
project under the name two node ixia

789
00:28:34,559 --> 00:28:36,360
CEOs

790
00:28:36,360 --> 00:28:39,179
it contains two nodes

791
00:28:39,179 --> 00:28:43,260
the first node is named OTG

792
00:28:43,260 --> 00:28:46,380
OTG stands for open traffic generator

793
00:28:46,380 --> 00:28:49,140
open traffic generator is a new API for

794
00:28:49,140 --> 00:28:51,539
generating test traffic developed by the

795
00:28:51,539 --> 00:28:52,919
makers of ixia

796
00:28:52,919 --> 00:28:55,260
so this is our node for generating

797
00:28:55,260 --> 00:28:57,559
traffic

798
00:28:57,900 --> 00:29:01,440
the second node is the Arista node

799
00:29:01,440 --> 00:29:04,020
it's our device under test

800
00:29:04,020 --> 00:29:06,419
here it is specified to be an arrested

801
00:29:06,419 --> 00:29:07,440
device

802
00:29:07,440 --> 00:29:10,260
that is running CEOs

803
00:29:10,260 --> 00:29:12,360
it is bootstrapped with a fairly minimal

804
00:29:12,360 --> 00:29:13,500
config

805
00:29:13,500 --> 00:29:15,659
referenced by this file

806
00:29:15,659 --> 00:29:17,940
that configures its interfaces

807
00:29:17,940 --> 00:29:21,899
and ensures gnmi is set up

808
00:29:21,899 --> 00:29:24,240
finally the topology creates two links

809
00:29:24,240 --> 00:29:28,140
between interfaces on the OTG and Arista

810
00:29:28,140 --> 00:29:30,380
nodes

811
00:29:32,760 --> 00:29:35,760
before we created topology we must first

812
00:29:35,760 --> 00:29:38,580
deploy a kubernetes cluster that is done

813
00:29:38,580 --> 00:29:41,399
with the knee deploy command

814
00:29:41,399 --> 00:29:43,860
Caney comes bundled with an example

815
00:29:43,860 --> 00:29:47,100
deployment definition kindbridge.yaml

816
00:29:47,100 --> 00:29:49,440
that uses kind to create the cluster on

817
00:29:49,440 --> 00:29:52,100
your local machine

818
00:30:25,140 --> 00:30:27,860
for me

819
00:30:38,940 --> 00:30:41,399
with the cluster deployed we can now use

820
00:30:41,399 --> 00:30:43,919
the knee create command

821
00:30:43,919 --> 00:30:46,860
to create our topology

822
00:30:46,860 --> 00:30:49,860
here we pass the do note ixia CEOs

823
00:30:49,860 --> 00:30:53,539
topology that we referenced before

824
00:31:12,539 --> 00:31:15,240
we can use Cube Kettle to see the pods

825
00:31:15,240 --> 00:31:18,320
that are running in the topology

826
00:31:19,620 --> 00:31:21,899
foreign

827
00:31:21,899 --> 00:31:25,140
here you can see a pod for the

828
00:31:25,140 --> 00:31:28,919
Arista Duty one for the Ott controller

829
00:31:28,919 --> 00:31:31,500
one for each of the o2g interfaces and

830
00:31:31,500 --> 00:31:33,000
so on

831
00:31:33,000 --> 00:31:34,679
you can also take a look at the running

832
00:31:34,679 --> 00:31:36,840
services in our topology with Cube

833
00:31:36,840 --> 00:31:39,620
Kettle get services

834
00:31:41,520 --> 00:31:43,980
now we will look at some ways you can

835
00:31:43,980 --> 00:31:45,600
manually interact with a running

836
00:31:45,600 --> 00:31:48,199
topology

837
00:31:48,419 --> 00:31:51,120
you can push config to a device with the

838
00:31:51,120 --> 00:31:53,580
KNE topology push command

839
00:31:53,580 --> 00:31:56,640
for our demo purposes it will push the

840
00:31:56,640 --> 00:31:58,080
same config that has already

841
00:31:58,080 --> 00:32:00,179
bootstrapped to the device so it will

842
00:32:00,179 --> 00:32:03,080
just be a no-op

843
00:32:03,960 --> 00:32:06,299
done

844
00:32:06,299 --> 00:32:09,299
you can also SSH to a node with the Kube

845
00:32:09,299 --> 00:32:12,860
Kettle exec command

846
00:32:15,600 --> 00:32:17,399
we have now logged in

847
00:32:17,399 --> 00:32:20,340
we can run an arbitrary command like

848
00:32:20,340 --> 00:32:23,000
show version

849
00:32:25,919 --> 00:32:29,580
we can also verify gnmi is available in

850
00:32:29,580 --> 00:32:31,799
working on the device

851
00:32:31,799 --> 00:32:35,640
first we'll install gmmi CLI

852
00:32:35,640 --> 00:32:39,200
from the open config project

853
00:32:40,559 --> 00:32:42,960
there it's installed

854
00:32:42,960 --> 00:32:44,820
if we looked at the config on the device

855
00:32:44,820 --> 00:32:46,679
we would see that the username and

856
00:32:46,679 --> 00:32:48,960
password

857
00:32:48,960 --> 00:32:52,080
set up for the gnmi server is just admin

858
00:32:52,080 --> 00:32:54,059
admin

859
00:32:54,059 --> 00:32:56,640
so let me set those here before I run my

860
00:32:56,640 --> 00:32:59,520
gnmi CLI command

861
00:32:59,520 --> 00:33:01,860
genome icli is also going to expect an

862
00:33:01,860 --> 00:33:04,080
IP address and port

863
00:33:04,080 --> 00:33:07,919
for the gnmi and point

864
00:33:07,919 --> 00:33:10,980
we can look that up with Cube kettle get

865
00:33:10,980 --> 00:33:13,340
services

866
00:33:13,799 --> 00:33:16,860
we see the Arista node has an external

867
00:33:16,860 --> 00:33:18,120
IP

868
00:33:18,120 --> 00:33:22,760
of 192.168 1854

869
00:33:22,919 --> 00:33:24,360
and

870
00:33:24,360 --> 00:33:26,880
it is running GMI is running on Port

871
00:33:26,880 --> 00:33:29,880
6030 which we could also look at we

872
00:33:29,880 --> 00:33:33,620
could also see that from the config

873
00:33:34,740 --> 00:33:36,960
so with that information

874
00:33:36,960 --> 00:33:39,000
now let's send a query

875
00:33:39,000 --> 00:33:42,960
to gnmi COI to that IP import

876
00:33:42,960 --> 00:33:44,940
and we're just going to query this state

877
00:33:44,940 --> 00:33:49,820
of the interface named ethernet one

878
00:33:51,480 --> 00:33:54,179
and there we can see the gnmi

879
00:33:54,179 --> 00:33:55,799
notification for the state of that

880
00:33:55,799 --> 00:33:58,279
interface

881
00:33:59,039 --> 00:34:01,260
the final piece of this demo will

882
00:34:01,260 --> 00:34:03,720
involve running an undocher test on our

883
00:34:03,720 --> 00:34:06,360
knee topology

884
00:34:06,360 --> 00:34:08,760
we start by cloning on datra from the

885
00:34:08,760 --> 00:34:11,599
GitHub repo

886
00:34:37,859 --> 00:34:40,080
now that it has been cloned we will

887
00:34:40,080 --> 00:34:43,080
build on datra the indatra readme says

888
00:34:43,080 --> 00:34:45,540
first to run go generate which Auto

889
00:34:45,540 --> 00:34:50,119
generates some of undoches apis

890
00:34:54,839 --> 00:34:58,220
now we run go build

891
00:35:17,579 --> 00:35:21,119
it is built successfully

892
00:35:21,119 --> 00:35:24,599
to run an undocher test on KNE we first

893
00:35:24,599 --> 00:35:27,480
have to configure the k e binding

894
00:35:27,480 --> 00:35:29,160
on Dodger tests can run in many

895
00:35:29,160 --> 00:35:31,680
different test environments KNE being

896
00:35:31,680 --> 00:35:33,000
just one

897
00:35:33,000 --> 00:35:35,040
each one of these environments needs a

898
00:35:35,040 --> 00:35:37,380
binding that lets on Doctrine know what

899
00:35:37,380 --> 00:35:39,599
the available devices are and how to

900
00:35:39,599 --> 00:35:41,400
access them

901
00:35:41,400 --> 00:35:44,220
or a configuration for the k e binding

902
00:35:44,220 --> 00:35:45,900
in this example

903
00:35:45,900 --> 00:35:50,300
is a simple three-line yaml file

904
00:35:53,820 --> 00:35:56,460
it specifies the username and password

905
00:35:56,460 --> 00:35:59,040
used by the device which here is just

906
00:35:59,040 --> 00:36:01,079
admin admin

907
00:36:01,079 --> 00:36:03,780
and the knee topology on which the test

908
00:36:03,780 --> 00:36:05,040
will run

909
00:36:05,040 --> 00:36:06,900
that's all we need to configure the k e

910
00:36:06,900 --> 00:36:08,579
binding

911
00:36:08,579 --> 00:36:10,260
now let's look at the test we will be

912
00:36:10,260 --> 00:36:11,880
running

913
00:36:11,880 --> 00:36:14,820
every undoctor test needs a test bed

914
00:36:14,820 --> 00:36:16,920
which specifies the physical resources

915
00:36:16,920 --> 00:36:19,200
it will need to run

916
00:36:19,200 --> 00:36:21,480
the resources are specified as abstract

917
00:36:21,480 --> 00:36:23,760
constraints not specific physical

918
00:36:23,760 --> 00:36:25,380
devices

919
00:36:25,380 --> 00:36:27,180
The Binding then resolves those

920
00:36:27,180 --> 00:36:29,220
constraints to specific devices at

921
00:36:29,220 --> 00:36:31,640
runtime

922
00:36:33,240 --> 00:36:36,500
here is the test bed

923
00:36:36,780 --> 00:36:39,119
this is a simple test bed that requires

924
00:36:39,119 --> 00:36:43,140
one device under test or dut

925
00:36:43,140 --> 00:36:45,060
Y and one piece of automated test

926
00:36:45,060 --> 00:36:47,640
equipment or ate

927
00:36:47,640 --> 00:36:50,160
an ate is a device that generates our

928
00:36:50,160 --> 00:36:51,660
test traffic

929
00:36:51,660 --> 00:36:55,440
and it constrains the dot in the ate

930
00:36:55,440 --> 00:36:59,040
to be linked on two ports

931
00:36:59,040 --> 00:37:01,260
finally let's look at the logic of the

932
00:37:01,260 --> 00:37:04,339
inductor test itself

933
00:37:05,460 --> 00:37:07,320
test main is the entry point for

934
00:37:07,320 --> 00:37:09,599
undocker test execution

935
00:37:09,599 --> 00:37:12,000
every undoctor test begins within a test

936
00:37:12,000 --> 00:37:12,839
Main

937
00:37:12,839 --> 00:37:16,440
that calls and daughter run tests

938
00:37:16,440 --> 00:37:19,260
this test has three test cases test

939
00:37:19,260 --> 00:37:21,720
config which tests our ability to push

940
00:37:21,720 --> 00:37:24,900
vendor config to the device

941
00:37:24,900 --> 00:37:27,720
test gnmi which tests our ability to

942
00:37:27,720 --> 00:37:31,079
query the Dutch gnmi service

943
00:37:31,079 --> 00:37:33,180
and test OTG

944
00:37:33,180 --> 00:37:35,940
which tests our ability to configure the

945
00:37:35,940 --> 00:37:38,700
open traffic generator node and query

946
00:37:38,700 --> 00:37:42,240
information about it via Gene MI

947
00:37:42,240 --> 00:37:46,459
here is the test command we will execute

948
00:37:46,920 --> 00:37:50,040
when we run any on Dodger test

949
00:37:50,040 --> 00:37:52,560
we pass a flag that specifies the test

950
00:37:52,560 --> 00:37:55,320
bed we want the test to use

951
00:37:55,320 --> 00:37:58,200
and because we're running on KNE we also

952
00:37:58,200 --> 00:38:01,160
specify a flag

953
00:38:01,740 --> 00:38:03,900
for the k e config which I showed

954
00:38:03,900 --> 00:38:06,300
earlier which here lists the username

955
00:38:06,300 --> 00:38:09,359
password and k e topology

956
00:38:09,359 --> 00:38:12,619
we now run the test

957
00:38:20,540 --> 00:38:24,119
here we see the devices from the KNE

958
00:38:24,119 --> 00:38:26,579
topology reserved by the test for the

959
00:38:26,579 --> 00:38:29,660
Texas execution

960
00:38:29,700 --> 00:38:32,460
in the test passed that concludes our

961
00:38:32,460 --> 00:38:34,820
demo

962
00:38:37,320 --> 00:38:40,320
cool so hopefully that shows the the set

963
00:38:40,320 --> 00:38:42,119
of tools kind of working together you

964
00:38:42,119 --> 00:38:44,220
know going from we'll we'll admit that

965
00:38:44,220 --> 00:38:46,260
we cut out a little bit of time waiting

966
00:38:46,260 --> 00:38:48,119
for things to build because it seemed

967
00:38:48,119 --> 00:38:49,560
like sitting here watching actually

968
00:38:49,560 --> 00:38:52,380
build was a bit too much but it's a it's

969
00:38:52,380 --> 00:38:54,119
close enough to real time that you can

970
00:38:54,119 --> 00:38:56,400
kind of go from nothing to a deployed

971
00:38:56,400 --> 00:38:59,040
set of infrastructure on your on your on

972
00:38:59,040 --> 00:39:01,980
your machine and run and write you can

973
00:39:01,980 --> 00:39:03,900
store some very simple test cases but

974
00:39:03,900 --> 00:39:06,119
these this set of apis are extended to

975
00:39:06,119 --> 00:39:08,880
cover much more and approach calls into

976
00:39:08,880 --> 00:39:10,859
other interfacing with the device other

977
00:39:10,859 --> 00:39:14,160
Telemetry retrieval type type tasks

978
00:39:14,160 --> 00:39:17,400
so that that sort of lays the foundation

979
00:39:17,400 --> 00:39:19,560
for this this wider concept that we've

980
00:39:19,560 --> 00:39:21,300
been aiming for for some time which is

981
00:39:21,300 --> 00:39:23,040
the this kind of idea of a test driven

982
00:39:23,040 --> 00:39:24,119
design

983
00:39:24,119 --> 00:39:25,859
um driven development for network

984
00:39:25,859 --> 00:39:27,720
devices so essentially we want to be

985
00:39:27,720 --> 00:39:29,700
able to style with okay we want to do

986
00:39:29,700 --> 00:39:31,200
something new with the device we want to

987
00:39:31,200 --> 00:39:32,940
be able to go and then design the API

988
00:39:32,940 --> 00:39:35,160
whether that's a new open config model

989
00:39:35,160 --> 00:39:36,900
because it's a configuration service or

990
00:39:36,900 --> 00:39:38,760
it needs some new Telemetry whether it's

991
00:39:38,760 --> 00:39:41,400
a new grpc service like gnoi or a new

992
00:39:41,400 --> 00:39:43,320
even kind of routing protocol like

993
00:39:43,320 --> 00:39:46,619
gribby go and design the API look at the

994
00:39:46,619 --> 00:39:48,900
way that we develop tests using on data

995
00:39:48,900 --> 00:39:52,200
so EXT using the either the inbuilt

996
00:39:52,200 --> 00:39:53,880
helpers the inductor has or inductor

997
00:39:53,880 --> 00:39:54,900
gives you a way to be able to access

998
00:39:54,900 --> 00:39:56,820
things like raw grpc connections to

999
00:39:56,820 --> 00:39:58,980
devices such you can iterate on on new

1000
00:39:58,980 --> 00:40:01,680
things and ideally test that against a

1001
00:40:01,680 --> 00:40:03,960
reference implementation so we don't

1002
00:40:03,960 --> 00:40:06,540
want to have to wait for there to be a

1003
00:40:06,540 --> 00:40:08,400
commercial available or a production

1004
00:40:08,400 --> 00:40:10,020
quality implementation before we start

1005
00:40:10,020 --> 00:40:11,400
looking at how this thing should work we

1006
00:40:11,400 --> 00:40:12,900
want to get those learnings of writing

1007
00:40:12,900 --> 00:40:14,460
code earlier and writing the

1008
00:40:14,460 --> 00:40:16,260
implementation earlier on so we have a

1009
00:40:16,260 --> 00:40:18,300
couple of reference implementations that

1010
00:40:18,300 --> 00:40:19,740
are open source there's a there's

1011
00:40:19,740 --> 00:40:21,060
lemming which is a reference

1012
00:40:21,060 --> 00:40:22,920
implementation of a network device that

1013
00:40:22,920 --> 00:40:25,260
has a gnmi server a grebe server it's

1014
00:40:25,260 --> 00:40:28,020
got support for bgp right now

1015
00:40:28,020 --> 00:40:30,060
um it's being it's got an emulated data

1016
00:40:30,060 --> 00:40:32,099
plane that can actually pass traffic and

1017
00:40:32,099 --> 00:40:33,480
so this gives us a way to be able to

1018
00:40:33,480 --> 00:40:35,160
quickly start to look at like okay we

1019
00:40:35,160 --> 00:40:36,300
want to be able to play with this

1020
00:40:36,300 --> 00:40:37,619
feature this this thing we're thinking

1021
00:40:37,619 --> 00:40:39,599
about let's go prototype it let's figure

1022
00:40:39,599 --> 00:40:40,980
out what it looks like let's look at

1023
00:40:40,980 --> 00:40:43,320
what the API should do let's write the

1024
00:40:43,320 --> 00:40:45,119
test that gives us the compliance

1025
00:40:45,119 --> 00:40:46,920
contract gives us a way that we don't

1026
00:40:46,920 --> 00:40:49,020
have to go and write an RFC to go and

1027
00:40:49,020 --> 00:40:50,400
describe everything does and actually

1028
00:40:50,400 --> 00:40:53,220
much more coherently describes what

1029
00:40:53,220 --> 00:40:54,780
should happen and more completely

1030
00:40:54,780 --> 00:40:56,700
describes what should happen in that we

1031
00:40:56,700 --> 00:40:58,380
also have a implementation of a

1032
00:40:58,380 --> 00:41:00,000
reference traffic generator that I think

1033
00:41:00,000 --> 00:41:01,619
was mentioned earlier that essentially

1034
00:41:01,619 --> 00:41:03,060
it's not meant to be a production

1035
00:41:03,060 --> 00:41:05,040
quality thing but if you're looking at a

1036
00:41:05,040 --> 00:41:08,040
new way that your new protocol or a new

1037
00:41:08,040 --> 00:41:10,079
um packet format that you may want to

1038
00:41:10,079 --> 00:41:11,460
play with gives you a way to be able to

1039
00:41:11,460 --> 00:41:12,660
add injection of that without

1040
00:41:12,660 --> 00:41:14,040
necessarily having to wait on other

1041
00:41:14,040 --> 00:41:16,380
requirements and then that gives you the

1042
00:41:16,380 --> 00:41:18,180
compliance contract to go and work on

1043
00:41:18,180 --> 00:41:19,740
the production implementation you say

1044
00:41:19,740 --> 00:41:21,060
okay I understand what it should look

1045
00:41:21,060 --> 00:41:22,920
like I understand how to spec it I can

1046
00:41:22,920 --> 00:41:24,420
explain to somebody else I've worked out

1047
00:41:24,420 --> 00:41:26,640
the nuances of it and now we can go and

1048
00:41:26,640 --> 00:41:28,560
look and implement this on a production

1049
00:41:28,560 --> 00:41:29,700
device

1050
00:41:29,700 --> 00:41:31,320
and reuse the things that we've

1051
00:41:31,320 --> 00:41:34,020
discussed on data for the test case k e

1052
00:41:34,020 --> 00:41:35,880
for the way that you play you use the

1053
00:41:35,880 --> 00:41:37,500
actual commercial implementation that

1054
00:41:37,500 --> 00:41:40,380
you you could take and and deploy that

1055
00:41:40,380 --> 00:41:42,960
into production based on that that this

1056
00:41:42,960 --> 00:41:46,079
pipeline which we think gives you a much

1057
00:41:46,079 --> 00:41:48,240
quicker way and a much more coherent way

1058
00:41:48,240 --> 00:41:49,980
to do feature development on network

1059
00:41:49,980 --> 00:41:52,500
devices and builds on this kind of the

1060
00:41:52,500 --> 00:41:54,180
overall concept of moving to

1061
00:41:54,180 --> 00:41:55,680
programmatic interaction with devices

1062
00:41:55,680 --> 00:41:57,660
which the open config project has been

1063
00:41:57,660 --> 00:42:00,240
working for the last uh seven or eight

1064
00:42:00,240 --> 00:42:02,280
years on

1065
00:42:02,280 --> 00:42:04,980
so thank you very much uh this is Marcus

1066
00:42:04,980 --> 00:42:06,900
and my email address

1067
00:42:06,900 --> 00:42:08,400
um everything that we mentioned is

1068
00:42:08,400 --> 00:42:10,380
somewhere in the the open config GitHub

1069
00:42:10,380 --> 00:42:12,359
uh there's probably some description of

1070
00:42:12,359 --> 00:42:14,520
it on openconfig.net as well thank you

1071
00:42:14,520 --> 00:42:17,119
very much indeed

1072
00:42:19,740 --> 00:42:23,649
[Applause]

1073
00:42:28,320 --> 00:42:30,740
yes

1074
00:42:34,020 --> 00:42:35,700
well thank you very much Marcus Rob that

1075
00:42:35,700 --> 00:42:38,160
was a great presentation thank you

1076
00:42:38,160 --> 00:42:39,960
oh we have a question we do have a

1077
00:42:39,960 --> 00:42:41,520
question okay

1078
00:42:41,520 --> 00:42:43,320
a little slow

1079
00:42:43,320 --> 00:42:46,020
I'd like to ask um so if you have a new

1080
00:42:46,020 --> 00:42:48,540
vendor who wants to become supported

1081
00:42:48,540 --> 00:42:50,940
from the key any perspective uh what

1082
00:42:50,940 --> 00:42:53,760
steps should they do to to get that

1083
00:42:53,760 --> 00:42:55,380
support edit

1084
00:42:55,380 --> 00:42:57,859
it's okay

1085
00:42:58,619 --> 00:43:00,060
um

1086
00:43:00,060 --> 00:43:01,140
okay

1087
00:43:01,140 --> 00:43:02,339
um I'll take it

1088
00:43:02,339 --> 00:43:04,800
um so in general

1089
00:43:04,800 --> 00:43:08,339
um the the barrier to entry is uh if you

1090
00:43:08,339 --> 00:43:10,020
can produce a container

1091
00:43:10,020 --> 00:43:13,140
um that's step one uh once you have a a

1092
00:43:13,140 --> 00:43:15,839
standard container at that point uh in k

1093
00:43:15,839 --> 00:43:19,440
e there is a node specification and a

1094
00:43:19,440 --> 00:43:22,859
node interface and uh the really

1095
00:43:22,859 --> 00:43:24,839
lightest way and and the way you should

1096
00:43:24,839 --> 00:43:27,540
probably bootstrap in is to say fulfill

1097
00:43:27,540 --> 00:43:29,280
that interface so you literally just

1098
00:43:29,280 --> 00:43:33,359
write a go module which fulfills six or

1099
00:43:33,359 --> 00:43:36,900
seven methods of basically you need to

1100
00:43:36,900 --> 00:43:40,380
create a couple kubernetes objects and

1101
00:43:40,380 --> 00:43:42,000
basically your service and your node

1102
00:43:42,000 --> 00:43:43,680
definition and we actually do provide a

1103
00:43:43,680 --> 00:43:46,140
default implementation uh but most

1104
00:43:46,140 --> 00:43:48,500
people do need to tweak that just a bit

1105
00:43:48,500 --> 00:43:52,440
and at that point uh you need to tweak

1106
00:43:52,440 --> 00:43:54,780
the topology Proto to add your new

1107
00:43:54,780 --> 00:43:58,740
vendor type in and at that point that's

1108
00:43:58,740 --> 00:44:02,160
pretty much it now uh again as you go

1109
00:44:02,160 --> 00:44:03,240
forward if you want to productionalize

1110
00:44:03,240 --> 00:44:05,520
that then learning a kubernetes operator

1111
00:44:05,520 --> 00:44:07,020
and then having a full kubernetes

1112
00:44:07,020 --> 00:44:09,420
operator deployment is obviously a a

1113
00:44:09,420 --> 00:44:11,579
better long term but yeah all you need

1114
00:44:11,579 --> 00:44:13,880
is that

1115
00:44:17,880 --> 00:44:19,980
any online questions Michael yeah we

1116
00:44:19,980 --> 00:44:22,560
have two well it's actually one from

1117
00:44:22,560 --> 00:44:25,160
Matt peacock

1118
00:44:26,520 --> 00:44:31,859
does o n d a t r a allow you to specify

1119
00:44:31,859 --> 00:44:35,400
link Management in your topology or even

1120
00:44:35,400 --> 00:44:39,900
link always perfect I.E can you add lose

1121
00:44:39,900 --> 00:44:41,760
latency to links

1122
00:44:41,760 --> 00:44:43,800
that so that's one of the reasons that

1123
00:44:43,800 --> 00:44:45,980
we went and implemented the grpc wire

1124
00:44:45,980 --> 00:44:48,780
essentially it would be we're kind of a

1125
00:44:48,780 --> 00:44:50,579
bit constrained as to what we can do but

1126
00:44:50,579 --> 00:44:52,319
it's an extension that now we've we've

1127
00:44:52,319 --> 00:44:54,599
landed the the grpc wire implementation

1128
00:44:54,599 --> 00:44:56,339
we're starting to think about well they

1129
00:44:56,339 --> 00:44:58,260
should be disinjected latency there

1130
00:44:58,260 --> 00:44:59,940
should be this injected impairment and

1131
00:44:59,940 --> 00:45:01,200
we've even started to think about well

1132
00:45:01,200 --> 00:45:02,579
should there be ways to be able to have

1133
00:45:02,579 --> 00:45:05,040
like lower layer errors injected so can

1134
00:45:05,040 --> 00:45:07,140
I start to have like bit error rate from

1135
00:45:07,140 --> 00:45:09,720
a what would be a transport system or

1136
00:45:09,720 --> 00:45:11,640
something that the optic might see so we

1137
00:45:11,640 --> 00:45:13,140
can start to test those paths but it

1138
00:45:13,140 --> 00:45:17,359
doesn't today but it's it's on the plan

1139
00:45:18,660 --> 00:45:20,040
okay

1140
00:45:20,040 --> 00:45:22,140
clear

1141
00:45:22,140 --> 00:45:23,880
okay thank you again guys thank you very

1142
00:45:23,880 --> 00:45:24,750
much

1143
00:45:24,750 --> 00:45:28,210
[Applause]

1144
00:45:29,730 --> 00:45:33,469
[Music]

