1
00:00:09,990 --> 00:00:16,420
hi so this talk will be different it'll

2
00:00:14,139 --> 00:00:19,270
be fun a lot of pictures won't be boring

3
00:00:16,420 --> 00:00:21,130
talk and you will learn about FPGA you

4
00:00:19,270 --> 00:00:24,369
will know more about FPGA than any other

5
00:00:21,130 --> 00:00:26,380
person in this conference probably so

6
00:00:24,369 --> 00:00:27,970
I'm Jeff in Kataria I am the principal

7
00:00:26,380 --> 00:00:29,769
scientist at red balloon security and

8
00:00:27,970 --> 00:00:34,089
I'll be talking about defeating Cisco

9
00:00:29,769 --> 00:00:37,620
trust anchor so you probably know this

10
00:00:34,090 --> 00:00:41,199
device right like this is a SR 1001 X

11
00:00:37,620 --> 00:00:45,190
top-of-the-line from Cisco and our main

12
00:00:41,199 --> 00:00:48,640
objective from DARPA was to run modified

13
00:00:45,190 --> 00:00:50,379
firmware on this system right and we

14
00:00:48,640 --> 00:00:52,570
have we have been doing research for the

15
00:00:50,379 --> 00:00:54,970
last 10 years on Cisco routers you can

16
00:00:52,570 --> 00:00:57,909
you know read papers in 2011 where we'd

17
00:00:54,970 --> 00:01:00,939
you know defeated around 300 different

18
00:00:57,909 --> 00:01:04,089
thousand images where we build a unique

19
00:01:00,939 --> 00:01:05,950
exploit for Cisco devices so we thought

20
00:01:04,089 --> 00:01:11,048
you know it was really easy to do this

21
00:01:05,950 --> 00:01:13,899
and but turned out it was we found about

22
00:01:11,049 --> 00:01:16,810
Cisco proprietary secure boot which was

23
00:01:13,899 --> 00:01:18,759
deployed in 2013 by Cisco to basically

24
00:01:16,810 --> 00:01:22,600
prevent people like us to run code on it

25
00:01:18,759 --> 00:01:24,939
so we took it as a challenge and during

26
00:01:22,600 --> 00:01:27,399
the course of this research we reported

27
00:01:24,939 --> 00:01:29,109
a vulnerability named try angry cat it's

28
00:01:27,399 --> 00:01:31,539
basically three angry cats floating in

29
00:01:29,109 --> 00:01:35,710
space that's actually drawn by our

30
00:01:31,539 --> 00:01:37,780
graphic designer and we reported the

31
00:01:35,710 --> 00:01:40,288
wound ability was about you know like

32
00:01:37,780 --> 00:01:44,740
Cisco trust anchor which is the core

33
00:01:40,289 --> 00:01:46,840
root of trust for their secure boot but

34
00:01:44,740 --> 00:01:49,179
before I explain this like how we

35
00:01:46,840 --> 00:01:50,859
achieve this and what it is about I'm

36
00:01:49,179 --> 00:01:54,280
going to talk about the impact of this

37
00:01:50,859 --> 00:01:55,538
one er ability so this when we reported

38
00:01:54,280 --> 00:01:57,899
this we thought you know we are only

39
00:01:55,539 --> 00:02:01,539
affecting one series of Cisco routers

40
00:01:57,899 --> 00:02:06,479
which would be ASR 1000 series but it

41
00:02:01,539 --> 00:02:11,560
turned out that we affected these these

42
00:02:06,479 --> 00:02:13,780
these keep on going it's around 133

43
00:02:11,560 --> 00:02:16,930
products we affected and recently they

44
00:02:13,780 --> 00:02:19,650
added 12 new products so around 1:45 so

45
00:02:16,930 --> 00:02:21,670
and I want to also focus on this

46
00:02:19,650 --> 00:02:23,319
recently notice that they have actually

47
00:02:21,670 --> 00:02:26,708
added this also

48
00:02:23,319 --> 00:02:29,230
these are Cisco aasa and fire power

49
00:02:26,709 --> 00:02:32,170
which is their security appliances so we

50
00:02:29,230 --> 00:02:33,700
affected their core IP and the note and

51
00:02:32,170 --> 00:02:35,888
the novel technique which we are talking

52
00:02:33,700 --> 00:02:37,420
about here doesn't just affect our

53
00:02:35,889 --> 00:02:40,840
routing infrastructure but it also

54
00:02:37,420 --> 00:02:43,929
affects weapon systems ADA systems in

55
00:02:40,840 --> 00:02:47,530
automotive medical utilities wherever

56
00:02:43,930 --> 00:02:50,919
FPGAs are used so in order to explain

57
00:02:47,530 --> 00:02:53,829
what we affected I want to explain what

58
00:02:50,919 --> 00:02:56,919
is inside in a SR 1001 X so as you can

59
00:02:53,829 --> 00:02:59,169
see here the a represents the SPI

60
00:02:56,919 --> 00:03:00,939
flashes which contains the firmware you

61
00:02:59,169 --> 00:03:04,359
know as you guys know which is Cisco IOS

62
00:03:00,939 --> 00:03:07,299
XE the bootloader which loads this iOS

63
00:03:04,359 --> 00:03:09,549
XE so that's in those two flashes which

64
00:03:07,299 --> 00:03:13,269
is marked as a then B is the way the

65
00:03:09,549 --> 00:03:15,340
FPGA bitstream is stored and I will

66
00:03:13,269 --> 00:03:18,459
explain what is a bit stream in my

67
00:03:15,340 --> 00:03:20,079
future slides and then C is the route

68
00:03:18,459 --> 00:03:22,629
processor you know when you go into the

69
00:03:20,079 --> 00:03:23,949
console of a cisco router the all the

70
00:03:22,629 --> 00:03:26,319
all the terminals coming in that's

71
00:03:23,949 --> 00:03:29,500
basically what C does it's an Intel Xeon

72
00:03:26,319 --> 00:03:35,619
processor and these the Southbridge is

73
00:03:29,500 --> 00:03:38,978
the FPGA itself next is I want to do

74
00:03:35,620 --> 00:03:41,290
some software analysis like how the

75
00:03:38,979 --> 00:03:44,349
system boots cisco started since 2013

76
00:03:41,290 --> 00:03:46,388
using UEFI interface as a bootloader and

77
00:03:44,349 --> 00:03:49,500
I don't have to explain you Raman

78
00:03:46,389 --> 00:03:52,870
because you guys are networking gurus so

79
00:03:49,500 --> 00:03:55,449
at what Cisco did was they implemented

80
00:03:52,870 --> 00:03:58,449
pre ROM on which is manager for ROM on

81
00:03:55,449 --> 00:04:00,340
itself and what it does is that it

82
00:03:58,449 --> 00:04:02,409
performs and validates the upgrade of

83
00:04:00,340 --> 00:04:04,870
the bootloader it also raises any

84
00:04:02,409 --> 00:04:06,668
concerns it raises an error if there is

85
00:04:04,870 --> 00:04:07,650
a if the upgrade integrity is

86
00:04:06,669 --> 00:04:10,900
compromised

87
00:04:07,650 --> 00:04:13,840
the next is ROM on itself which is

88
00:04:10,900 --> 00:04:16,750
implemented as DXE module in the UEFI

89
00:04:13,840 --> 00:04:18,880
interface and what it does is that it

90
00:04:16,750 --> 00:04:21,209
you know it validates the signature

91
00:04:18,880 --> 00:04:23,889
check of the Linux of the iris sexy and

92
00:04:21,209 --> 00:04:25,539
it also has a privileged mode which you

93
00:04:23,889 --> 00:04:28,509
probably don't know about and they

94
00:04:25,539 --> 00:04:30,940
disable it by they disable it by default

95
00:04:28,509 --> 00:04:32,020
and you can enable it if you you know

96
00:04:30,940 --> 00:04:33,729
mess up with the spi

97
00:04:32,020 --> 00:04:36,560
which allows you to do memory

98
00:04:33,729 --> 00:04:38,150
introspection during that stage

99
00:04:36,560 --> 00:04:40,220
and then what ramen does is that it you

100
00:04:38,150 --> 00:04:42,440
know after validating the check on Linux

101
00:04:40,220 --> 00:04:46,669
it passes the control to Linux and then

102
00:04:42,440 --> 00:04:48,650
it boots iOS D so this is basically from

103
00:04:46,669 --> 00:04:50,210
you know last 20 years Cisco has been

104
00:04:48,650 --> 00:04:52,159
running this iOS stack which is their

105
00:04:50,210 --> 00:04:55,219
code networking stack what they did was

106
00:04:52,160 --> 00:04:57,850
they they took that stack made it into a

107
00:04:55,220 --> 00:05:03,260
Linux process ran it as a daemon and

108
00:04:57,850 --> 00:05:05,210
it's almost the same code and they run

109
00:05:03,260 --> 00:05:06,830
it and they also manage it using a

110
00:05:05,210 --> 00:05:09,320
proprietary process manager so if you

111
00:05:06,830 --> 00:05:12,560
crash this iOS this whole system boots

112
00:05:09,320 --> 00:05:15,530
even though it's running as a process so

113
00:05:12,560 --> 00:05:19,430
and this comprises of iOS XE as you guys

114
00:05:15,530 --> 00:05:21,679
know so after doing the analysis we

115
00:05:19,430 --> 00:05:24,490
found that you know there are no hashes

116
00:05:21,680 --> 00:05:27,050
in the image there are no certificates

117
00:05:24,490 --> 00:05:29,270
available so it should be really easy to

118
00:05:27,050 --> 00:05:31,700
modify the UEFI and like complete the

119
00:05:29,270 --> 00:05:34,250
project and that's what we did we

120
00:05:31,700 --> 00:05:36,289
disabled some checks in pre ROM on stage

121
00:05:34,250 --> 00:05:39,620
and booted the firmware everything

122
00:05:36,290 --> 00:05:41,390
worked but wait it actually reset so the

123
00:05:39,620 --> 00:05:43,460
release had happened exactly after 100

124
00:05:41,390 --> 00:05:45,560
seconds and there were multiple theories

125
00:05:43,460 --> 00:05:49,190
where we were like why is this happening

126
00:05:45,560 --> 00:05:50,690
whether we messed up the spi flash had

127
00:05:49,190 --> 00:05:53,120
maybe there is some other checks which

128
00:05:50,690 --> 00:05:55,729
we don't know about and what it does is

129
00:05:53,120 --> 00:05:57,830
that it allows it tries to do the reboot

130
00:05:55,729 --> 00:06:00,590
three times but then it falls over the

131
00:05:57,830 --> 00:06:03,130
rom on console so we started the

132
00:06:00,590 --> 00:06:05,929
hypothesis for this hundred seconds and

133
00:06:03,130 --> 00:06:07,909
right you know like these days x86 come

134
00:06:05,930 --> 00:06:09,770
up with a lot of mitigations so we

135
00:06:07,910 --> 00:06:11,660
started thinking about okay let's try

136
00:06:09,770 --> 00:06:15,380
you know what kind of mitigations are

137
00:06:11,660 --> 00:06:17,870
enabled in this system so we looked at

138
00:06:15,380 --> 00:06:20,120
the which vmm layer which is the ring -

139
00:06:17,870 --> 00:06:23,360
one layer we saw that it was already

140
00:06:20,120 --> 00:06:25,100
disabled as we had hundred seconds so

141
00:06:23,360 --> 00:06:27,530
cisco allowed us to give hundred seconds

142
00:06:25,100 --> 00:06:29,840
which you know made us try different

143
00:06:27,530 --> 00:06:32,030
things with the firmware so we disabled

144
00:06:29,840 --> 00:06:33,710
the watchdog timers that was not it then

145
00:06:32,030 --> 00:06:37,159
there is the SMM mode inside the intel

146
00:06:33,710 --> 00:06:39,138
x86 which is the ring - 2.5 and we

147
00:06:37,160 --> 00:06:40,760
disable that because we had hundred

148
00:06:39,139 --> 00:06:43,850
seconds to do this and still it was

149
00:06:40,760 --> 00:06:45,530
rebooting so at this point we thought

150
00:06:43,850 --> 00:06:48,590
you know we should probably do some game

151
00:06:45,530 --> 00:06:50,239
analysis and this is our setup for the

152
00:06:48,590 --> 00:06:53,568
game analysis this is actually

153
00:06:50,240 --> 00:06:55,520
a self-made robot which goes over

154
00:06:53,569 --> 00:06:58,009
different places and you can attach a

155
00:06:55,520 --> 00:07:01,669
near-field probe and get you know like

156
00:06:58,009 --> 00:07:03,770
readings of what is going on and this is

157
00:07:01,669 --> 00:07:07,250
what we found we found that there is

158
00:07:03,770 --> 00:07:09,979
some readings on the bitstream spi flash

159
00:07:07,250 --> 00:07:12,530
which was the be in the image then the

160
00:07:09,979 --> 00:07:15,620
fpga boots up as you can see and then

161
00:07:12,530 --> 00:07:18,020
the circuitry comes up so this gave an

162
00:07:15,620 --> 00:07:20,810
idea of like maybe the fpga is coming up

163
00:07:18,020 --> 00:07:23,120
first but we thought it was only being

164
00:07:20,810 --> 00:07:24,770
used for crypto you know computations

165
00:07:23,120 --> 00:07:26,659
there's some other guy which we don't

166
00:07:24,770 --> 00:07:32,508
know about which is doing all this

167
00:07:26,659 --> 00:07:34,669
research and we also so the grout

168
00:07:32,509 --> 00:07:37,400
processor itself boots using those two

169
00:07:34,669 --> 00:07:39,919
spi flashes the fpga also use a boot

170
00:07:37,400 --> 00:07:42,979
using the spi flash the other SPI flash

171
00:07:39,919 --> 00:07:44,840
so we what we did was we snipped the spi

172
00:07:42,979 --> 00:07:47,090
bus what is going on what traffic is

173
00:07:44,840 --> 00:07:49,580
there and we found there was the micro

174
00:07:47,090 --> 00:07:51,349
code from the for the Intel x86 we also

175
00:07:49,580 --> 00:07:52,818
found that they were interrupt handlers

176
00:07:51,349 --> 00:07:54,860
which are usually you know back in the

177
00:07:52,819 --> 00:07:56,479
day if you know you know how your

178
00:07:54,860 --> 00:07:57,710
keyboard works how your mouse works at

179
00:07:56,479 --> 00:08:00,770
those kind of interrupt handlers and

180
00:07:57,710 --> 00:08:05,448
then there was bios also which usually

181
00:08:00,770 --> 00:08:07,430
exists in a thousand range so you know

182
00:08:05,449 --> 00:08:09,320
like after doing all this analysis we

183
00:08:07,430 --> 00:08:11,000
started maybe looking into pre Raman we

184
00:08:09,320 --> 00:08:13,370
thought that maybe it's the pre Rahman

185
00:08:11,000 --> 00:08:16,070
which is doing the validity of the

186
00:08:13,370 --> 00:08:18,979
upgrade also maybe that's how it figures

187
00:08:16,070 --> 00:08:21,199
out you know it's some magic that you

188
00:08:18,979 --> 00:08:24,469
know we have modified the firmware so we

189
00:08:21,199 --> 00:08:26,900
found this range which is the fvd you

190
00:08:24,469 --> 00:08:29,750
know that red box and this is where in

191
00:08:26,900 --> 00:08:31,638
until x86 if you put any external device

192
00:08:29,750 --> 00:08:34,610
which if you attach any external device

193
00:08:31,639 --> 00:08:37,490
through the serial quad interface which

194
00:08:34,610 --> 00:08:39,320
is the SPI interface to x86 this is

195
00:08:37,490 --> 00:08:40,880
where the memory is mapped usually and

196
00:08:39,320 --> 00:08:43,130
we saw that there are some checks being

197
00:08:40,880 --> 00:08:44,839
done so we knew that some external

198
00:08:43,130 --> 00:08:48,800
entity is there which is doing this and

199
00:08:44,839 --> 00:08:51,170
just to be sure about this because the

200
00:08:48,800 --> 00:08:53,479
stack is so big to reverse engineer we

201
00:08:51,170 --> 00:08:54,800
hijacked we wrote a custom serial driver

202
00:08:53,480 --> 00:08:56,990
and we hijacked the first instruction

203
00:08:54,800 --> 00:09:00,020
which there are processor runs and even

204
00:08:56,990 --> 00:09:03,470
then the reset was happening so we knew

205
00:09:00,020 --> 00:09:07,400
you know some external entity exists our

206
00:09:03,470 --> 00:09:11,120
who it is but and our you know hunch was

207
00:09:07,400 --> 00:09:13,100
that it is the Xilinx FPGA so this was

208
00:09:11,120 --> 00:09:14,660
our assumption as soon as the as soon as

209
00:09:13,100 --> 00:09:17,120
you turn on your router right like this

210
00:09:14,660 --> 00:09:20,300
is what happens the FPGA comes in its

211
00:09:17,120 --> 00:09:22,130
program itself and then it provides the

212
00:09:20,300 --> 00:09:25,069
marker loaded to pre ROM on stage which

213
00:09:22,130 --> 00:09:27,230
is basically the x86 stage and then the

214
00:09:25,070 --> 00:09:29,150
P Rama and boots drama and drama moots

215
00:09:27,230 --> 00:09:33,590
the Linux OS and then Linux OS boots the

216
00:09:29,150 --> 00:09:35,990
iOS D so if you actually own FPGA then

217
00:09:33,590 --> 00:09:38,270
you own the whole system and basically

218
00:09:35,990 --> 00:09:40,820
you can control you know different parts

219
00:09:38,270 --> 00:09:43,550
you can sniff traffic you can just live

220
00:09:40,820 --> 00:09:45,890
there and no one will know about it but

221
00:09:43,550 --> 00:09:47,900
in order to validate this theory we

222
00:09:45,890 --> 00:09:50,270
wanted to see you know like how much

223
00:09:47,900 --> 00:09:52,699
where is the reset pen we wanted to you

224
00:09:50,270 --> 00:09:54,170
know before we start doing FPGA

225
00:09:52,700 --> 00:09:55,130
reversing we wanted to validate that

226
00:09:54,170 --> 00:09:58,099
this is it

227
00:09:55,130 --> 00:10:02,240
but these artists cost a lot even on

228
00:09:58,100 --> 00:10:03,980
sale like it's $11,000 on sale so at

229
00:10:02,240 --> 00:10:06,290
this point we thought you know we have

230
00:10:03,980 --> 00:10:10,460
to you know sacrifice at $10,000 and

231
00:10:06,290 --> 00:10:13,610
find the reset pin and it's a BGA chip

232
00:10:10,460 --> 00:10:16,760
so we had an intern who spent a week

233
00:10:13,610 --> 00:10:19,580
mapping every pin out and we found the

234
00:10:16,760 --> 00:10:22,490
reset pin at this point we knew that our

235
00:10:19,580 --> 00:10:23,780
T of reconstruction is hard our TL is is

236
00:10:22,490 --> 00:10:25,580
basically the registers transfer

237
00:10:23,780 --> 00:10:28,819
language through which FPGAs are

238
00:10:25,580 --> 00:10:30,590
programmed it's hard so we want it to

239
00:10:28,820 --> 00:10:33,950
just the FPGA theory before we invest

240
00:10:30,590 --> 00:10:36,110
more time in it so what can you do how

241
00:10:33,950 --> 00:10:36,620
about just keep the reset pin high all

242
00:10:36,110 --> 00:10:38,450
the time

243
00:10:36,620 --> 00:10:41,060
what could go wrong right this is what I

244
00:10:38,450 --> 00:10:42,770
thought like you know what could go

245
00:10:41,060 --> 00:10:44,900
wrong so you I'm not hardware person I'm

246
00:10:42,770 --> 00:10:47,569
a systems person so I went to my

247
00:10:44,900 --> 00:10:49,970
colleague he's my teammate I usually go

248
00:10:47,570 --> 00:10:51,470
to anger Rick for my hardware problems

249
00:10:49,970 --> 00:10:52,580
and I said I want to keep the spin high

250
00:10:51,470 --> 00:10:55,760
what should I do

251
00:10:52,580 --> 00:10:57,620
and he said why don't you put a 10k

252
00:10:55,760 --> 00:10:59,089
resistor and keep the pin high what

253
00:10:57,620 --> 00:11:02,420
could you know this will this will work

254
00:10:59,089 --> 00:11:05,180
and then goes the other $10,000 so

255
00:11:02,420 --> 00:11:07,760
basically we are at this point total

256
00:11:05,180 --> 00:11:13,880
cost of $20,000 gone for and it's around

257
00:11:07,760 --> 00:11:15,290
$1 per ohm that's how much it was so one

258
00:11:13,880 --> 00:11:16,360
of her colleagues basically said you

259
00:11:15,290 --> 00:11:18,998
know hey

260
00:11:16,360 --> 00:11:21,730
I found this patent where Cisco is

261
00:11:18,999 --> 00:11:23,949
actually saying that they could use this

262
00:11:21,730 --> 00:11:26,439
FPGA they could connect this FPGA using

263
00:11:23,949 --> 00:11:28,118
the LPC bus which is basically the high

264
00:11:26,439 --> 00:11:31,959
speed bus connected to the Southbridge

265
00:11:28,119 --> 00:11:34,179
and we can do we can we can make the

266
00:11:31,959 --> 00:11:35,888
FPGA master of the SPI bus we can

267
00:11:34,179 --> 00:11:38,290
validate what's going on this is their

268
00:11:35,889 --> 00:11:40,290
theory right this is in 2012 and they

269
00:11:38,290 --> 00:11:44,079
said that they can also control

270
00:11:40,290 --> 00:11:46,599
different things like your console they

271
00:11:44,079 --> 00:11:48,279
can control the fans in the in the

272
00:11:46,600 --> 00:11:50,079
router they can control different

273
00:11:48,279 --> 00:11:50,559
quantum processor which are doing packet

274
00:11:50,079 --> 00:11:53,469
switching

275
00:11:50,559 --> 00:11:58,329
so FPGA is actually a single point of

276
00:11:53,470 --> 00:11:59,139
failure for them and also the I forgot

277
00:11:58,329 --> 00:12:02,439
one thing

278
00:11:59,139 --> 00:12:03,910
each time the FPGA finds out like you

279
00:12:02,439 --> 00:12:06,579
know there is something wrong in the

280
00:12:03,910 --> 00:12:08,949
bootloader it makes a huge fan noise and

281
00:12:06,579 --> 00:12:10,479
finally it made sense why it was making

282
00:12:08,949 --> 00:12:12,939
huge noise because the FPGA is

283
00:12:10,480 --> 00:12:16,360
controlling their fan also so this

284
00:12:12,939 --> 00:12:19,118
solidified our theory and at that point

285
00:12:16,360 --> 00:12:21,399
we thought you know FPGA reversing is

286
00:12:19,119 --> 00:12:24,639
too complex we left the project in mid

287
00:12:21,399 --> 00:12:27,220
2017 and you know we went for our lives

288
00:12:24,639 --> 00:12:29,709
and enjoying it but then we came back in

289
00:12:27,220 --> 00:12:30,999
2018 and you know I was like I'm down

290
00:12:29,709 --> 00:12:33,939
twenty thousand dollars give me more

291
00:12:30,999 --> 00:12:36,910
money to buy more routers and I can do

292
00:12:33,939 --> 00:12:39,429
definitely half these years but being a

293
00:12:36,910 --> 00:12:42,429
systems person what is FPGA I have no

294
00:12:39,429 --> 00:12:44,319
idea I'm not a hardware guy and this is

295
00:12:42,429 --> 00:12:47,259
what basically represents a FPGA

296
00:12:44,319 --> 00:12:49,149
right it is an ICU which includes the

297
00:12:47,259 --> 00:12:52,779
benefits of both software and hardware

298
00:12:49,149 --> 00:12:54,839
you can add computations like hardware

299
00:12:52,779 --> 00:12:58,239
and you can reconfigure it like software

300
00:12:54,839 --> 00:13:00,579
but really how does how does it work so

301
00:12:58,239 --> 00:13:03,100
a programmer specifies a hardware

302
00:13:00,579 --> 00:13:04,479
circuit by using this sub you know

303
00:13:03,100 --> 00:13:06,429
software language which is the hardware

304
00:13:04,480 --> 00:13:08,829
description language then the vendor

305
00:13:06,429 --> 00:13:12,249
tool chain Maps it it compiles it

306
00:13:08,829 --> 00:13:14,949
synthesizes it and then creates routing

307
00:13:12,249 --> 00:13:16,989
between hardware elements and that

308
00:13:14,949 --> 00:13:18,699
routing you can also do it by the

309
00:13:16,989 --> 00:13:21,489
developer can also do it or the vendor

310
00:13:18,699 --> 00:13:24,368
tool chain can do it and then it

311
00:13:21,489 --> 00:13:27,309
generates this hardware information

312
00:13:24,369 --> 00:13:29,769
about truth tables the memory what does

313
00:13:27,309 --> 00:13:31,389
the memory contain multiplexers

314
00:13:29,769 --> 00:13:33,429
the routing should do you know think

315
00:13:31,389 --> 00:13:35,170
about like all the switching map matrix

316
00:13:33,429 --> 00:13:37,420
is generated and then it's converted

317
00:13:35,170 --> 00:13:39,368
into a encoded into a binary and that's

318
00:13:37,420 --> 00:13:41,649
what's called configuration bitstream so

319
00:13:39,369 --> 00:13:43,989
the fpga reads this as soon as the fpga

320
00:13:41,649 --> 00:13:45,489
boots there is a logic which reads this

321
00:13:43,989 --> 00:13:48,670
configuration bit stream from anywhere

322
00:13:45,489 --> 00:13:51,160
and programs itself and tells what it

323
00:13:48,670 --> 00:13:53,128
what it is going to do now and then

324
00:13:51,160 --> 00:13:55,868
there are different types of fpga so

325
00:13:53,129 --> 00:13:58,449
most of the in the industry and for

326
00:13:55,869 --> 00:14:01,119
cisco we are talking about SRAM based

327
00:13:58,449 --> 00:14:03,069
fpga what it means is that like as soon

328
00:14:01,119 --> 00:14:04,989
as the power goes away SRAM means it's

329
00:14:03,069 --> 00:14:07,479
volatile right so as soon as the power

330
00:14:04,989 --> 00:14:09,970
goes away fpga has to again read the bit

331
00:14:07,480 --> 00:14:12,610
stream from some flash to program itself

332
00:14:09,970 --> 00:14:14,619
then there is the flash based fpga where

333
00:14:12,610 --> 00:14:17,470
the bits the configuration bit stream is

334
00:14:14,619 --> 00:14:20,439
inside the die itself so it is quick

335
00:14:17,470 --> 00:14:22,059
there is less power consumption and it

336
00:14:20,439 --> 00:14:23,889
boots itself really quickly and then the

337
00:14:22,059 --> 00:14:25,509
antabuse which defeats the purpose of

338
00:14:23,889 --> 00:14:28,869
the fpga because you cannot program it

339
00:14:25,509 --> 00:14:30,730
once you have you know configured it but

340
00:14:28,869 --> 00:14:33,279
really what is still an fpga i don't

341
00:14:30,730 --> 00:14:35,679
understand that so you can think of fpga

342
00:14:33,279 --> 00:14:38,230
as this it's basically a comp like it's

343
00:14:35,679 --> 00:14:41,079
a combination of different blocks here

344
00:14:38,230 --> 00:14:43,569
io b CL b b ram and all this jargon

345
00:14:41,079 --> 00:14:46,959
which i will be explaining later on but

346
00:14:43,569 --> 00:14:49,660
really fpga is just y is equal to FX if

347
00:14:46,959 --> 00:14:51,189
you think about it this is a map and you

348
00:14:49,660 --> 00:14:53,379
don't have to worry about anything and

349
00:14:51,189 --> 00:14:56,589
if you want to defeat fpga you only have

350
00:14:53,379 --> 00:14:59,079
to worry about Y or X Y to worry about F

351
00:14:56,589 --> 00:15:02,410
and that's the logic behind our novel

352
00:14:59,079 --> 00:15:06,040
technique where we care about if we only

353
00:15:02,410 --> 00:15:10,029
change Y if I can change that reset pin

354
00:15:06,040 --> 00:15:12,309
to be 1 instead of 0 I win and that's

355
00:15:10,029 --> 00:15:15,549
and usually hackers are lazy and that's

356
00:15:12,309 --> 00:15:17,589
what we go for and to give you an idea

357
00:15:15,549 --> 00:15:21,100
of like what is io b is basically

358
00:15:17,589 --> 00:15:23,110
something which drives a pin 1 or 0 so

359
00:15:21,100 --> 00:15:25,269
you can think like that and then what is

360
00:15:23,110 --> 00:15:26,769
iay this you can think of it like a

361
00:15:25,269 --> 00:15:29,589
routing matrix you know you are

362
00:15:26,769 --> 00:15:31,449
networking gurus so think of it like

363
00:15:29,589 --> 00:15:33,429
this basically explains you where the

364
00:15:31,449 --> 00:15:35,799
signal has to go from one component in

365
00:15:33,429 --> 00:15:38,769
the FPGA to another one so it's really

366
00:15:35,799 --> 00:15:42,220
this is there is an exercise we which

367
00:15:38,769 --> 00:15:43,030
will come later but IO interface is very

368
00:15:42,220 --> 00:15:45,790
important to do that

369
00:15:43,030 --> 00:15:47,709
exercise and then the complex logic

370
00:15:45,790 --> 00:15:49,930
block this is the boolean this this is

371
00:15:47,710 --> 00:15:52,810
the element which implement different

372
00:15:49,930 --> 00:15:55,150
boolean functions or act as a storage so

373
00:15:52,810 --> 00:15:57,400
you know it consisted of different

374
00:15:55,150 --> 00:15:59,890
slices and each slice has flip-flop

375
00:15:57,400 --> 00:16:02,740
lookup table MUX gates so think of like

376
00:15:59,890 --> 00:16:04,720
lookup table and MUX as your switching

377
00:16:02,740 --> 00:16:06,700
matrix which explains you where the bits

378
00:16:04,720 --> 00:16:09,040
have to go so think of it like a hash

379
00:16:06,700 --> 00:16:12,010
table and then flip-flop you know act as

380
00:16:09,040 --> 00:16:15,849
a storage devices and then gates does

381
00:16:12,010 --> 00:16:17,680
and or or and then again the switch

382
00:16:15,850 --> 00:16:20,170
matrix on the left-hand side is

383
00:16:17,680 --> 00:16:24,189
basically how it talks to other elements

384
00:16:20,170 --> 00:16:26,349
in the FPGA time and to give you an idea

385
00:16:24,190 --> 00:16:28,450
of like what the complexity of the CLB

386
00:16:26,350 --> 00:16:31,030
is this is what we are talking about

387
00:16:28,450 --> 00:16:34,180
right like this is one of the just one

388
00:16:31,030 --> 00:16:36,819
element in the FPGA of which explains

389
00:16:34,180 --> 00:16:40,689
how why a hacker wouldn't like to go

390
00:16:36,820 --> 00:16:43,840
after this so let's reverse the FPGA

391
00:16:40,690 --> 00:16:46,060
bitstream right there has been some work

392
00:16:43,840 --> 00:16:48,790
done back in the day like J bits is

393
00:16:46,060 --> 00:16:50,770
something with Xilinx released in 1999

394
00:16:48,790 --> 00:16:53,560
about like you know where you can change

395
00:16:50,770 --> 00:16:55,510
the bitstream after the way you don't

396
00:16:53,560 --> 00:16:58,030
need the source code and you can just

397
00:16:55,510 --> 00:16:59,920
directly modify the binary then Bill is

398
00:16:58,030 --> 00:17:01,780
something which you know this guy

399
00:16:59,920 --> 00:17:03,819
basically said you know unless you have

400
00:17:01,780 --> 00:17:06,609
a necklace which is think of it like

401
00:17:03,820 --> 00:17:08,590
when you compile a program the

402
00:17:06,609 --> 00:17:10,510
intermediate stage is what's called

403
00:17:08,589 --> 00:17:13,270
netlist an FPGA unless you have a

404
00:17:10,510 --> 00:17:14,950
netlist and you have a binary only then

405
00:17:13,270 --> 00:17:16,599
you can make these changes so our

406
00:17:14,950 --> 00:17:17,740
research actually you know there has

407
00:17:16,599 --> 00:17:20,199
been certain paper where they basically

408
00:17:17,740 --> 00:17:22,930
said that that's not true and then bit

409
00:17:20,200 --> 00:17:24,700
man I haven't looked into this much but

410
00:17:22,930 --> 00:17:27,640
this guy is basically saying that I can

411
00:17:24,700 --> 00:17:30,790
move the logic around without having the

412
00:17:27,640 --> 00:17:32,530
source code but again all of them are

413
00:17:30,790 --> 00:17:35,080
trying to do some CLB what we are trying

414
00:17:32,530 --> 00:17:38,710
to do is just change Y in y equal to FX

415
00:17:35,080 --> 00:17:42,639
so CLE as we did some analysis and we

416
00:17:38,710 --> 00:17:44,320
found out that as the FPGA complexity

417
00:17:42,640 --> 00:17:47,080
increases the seal becomes keep on

418
00:17:44,320 --> 00:17:49,389
increasing and again hackers are lazy so

419
00:17:47,080 --> 00:17:53,860
why to go about that but the I account

420
00:17:49,390 --> 00:17:57,100
remains things so if I if i hack if I

421
00:17:53,860 --> 00:18:00,059
figure out like how to change the IO

422
00:17:57,100 --> 00:18:03,039
then I have uniquely you know

423
00:18:00,059 --> 00:18:05,519
compromised all the whole family of the

424
00:18:03,039 --> 00:18:08,320
FPGA and that's what we are going for so

425
00:18:05,519 --> 00:18:10,840
for Cisco they use part in six family of

426
00:18:08,320 --> 00:18:13,450
Xilinx and as you can see the graph

427
00:18:10,840 --> 00:18:15,970
keeps on increasing with the complexity

428
00:18:13,450 --> 00:18:17,559
of the in the family of the devices and

429
00:18:15,970 --> 00:18:19,240
the family keeps on increasing so the

430
00:18:17,559 --> 00:18:24,059
max one is one forty seven thousand

431
00:18:19,240 --> 00:18:28,690
device you know CL b cells and but the

432
00:18:24,059 --> 00:18:30,899
the i/o comm remained almost same so in

433
00:18:28,690 --> 00:18:34,480
order to explain like what it is so we

434
00:18:30,899 --> 00:18:36,908
what we did was we took the sha-256 I

435
00:18:34,480 --> 00:18:39,519
think 512 computation and we compile it

436
00:18:36,909 --> 00:18:42,129
and this is this represents only a small

437
00:18:39,519 --> 00:18:43,870
part of that computation like look at

438
00:18:42,129 --> 00:18:45,219
that look at the routing which is

439
00:18:43,870 --> 00:18:49,330
happening here right like it's just

440
00:18:45,220 --> 00:18:53,789
crazy like so and this is an other way

441
00:18:49,330 --> 00:18:55,990
to look at the FPGA bitstream so the so

442
00:18:53,789 --> 00:18:58,450
here what I'm trying to represent is the

443
00:18:55,990 --> 00:19:00,669
bitmap of the bitstream it's the same

444
00:18:58,450 --> 00:19:03,250
base stream which we saw the complex

445
00:19:00,669 --> 00:19:05,110
routing for so the top part represents

446
00:19:03,250 --> 00:19:07,990
the CLP where most of the logic of the

447
00:19:05,110 --> 00:19:09,428
clb exist and then the IOB are done you

448
00:19:07,990 --> 00:19:12,759
know like as you can see on the red and

449
00:19:09,429 --> 00:19:14,470
then we made one single change a small

450
00:19:12,759 --> 00:19:16,899
change in the number of rounds of the

451
00:19:14,470 --> 00:19:19,029
SHA and look at how the bitstream change

452
00:19:16,899 --> 00:19:22,508
but the IO remain the same and if you

453
00:19:19,029 --> 00:19:24,909
dip the two it basically proves the fact

454
00:19:22,509 --> 00:19:28,870
that clb is too complex it cannot be

455
00:19:24,909 --> 00:19:31,360
uniquely modified and if we modify the

456
00:19:28,870 --> 00:19:33,518
IO be properly we can actually uniquely

457
00:19:31,360 --> 00:19:38,350
apply to different devices and different

458
00:19:33,519 --> 00:19:40,629
families which basically you know helped

459
00:19:38,350 --> 00:19:42,250
us to go after it so there are a few

460
00:19:40,629 --> 00:19:45,189
modifications in areas we are looking

461
00:19:42,250 --> 00:19:46,659
for we want to change the pin to zero we

462
00:19:45,190 --> 00:19:48,909
want to change the output pin to zero we

463
00:19:46,659 --> 00:19:50,950
want to change the output pin to one we

464
00:19:48,909 --> 00:19:54,070
want to change we want to make output to

465
00:19:50,950 --> 00:19:58,210
input and then again input to zero input

466
00:19:54,070 --> 00:19:59,529
to one and make again input to output so

467
00:19:58,210 --> 00:20:02,799
these are the modification scenarios we

468
00:19:59,529 --> 00:20:05,139
are going for so here I'm going to like

469
00:20:02,799 --> 00:20:06,908
stress on the fact that when what

470
00:20:05,139 --> 00:20:08,649
Wenders have been doing or you know I

471
00:20:06,909 --> 00:20:09,940
don't want to just say Cisco I mean it's

472
00:20:08,649 --> 00:20:12,219
everywhere

473
00:20:09,940 --> 00:20:14,350
we're how they are applying the model of

474
00:20:12,220 --> 00:20:17,530
securities through obscurity and as we

475
00:20:14,350 --> 00:20:19,389
have seen here is that it even though

476
00:20:17,530 --> 00:20:22,870
our TL reconstruction is hard but

477
00:20:19,390 --> 00:20:27,090
changing IO is not and again it's y is

478
00:20:22,870 --> 00:20:30,250
equal to FX so how do you go about

479
00:20:27,090 --> 00:20:31,990
bitstream reversing so when we when we

480
00:20:30,250 --> 00:20:34,600
do some any kind of analysis on a

481
00:20:31,990 --> 00:20:36,460
firmware you know for your programs or

482
00:20:34,600 --> 00:20:38,350
any kind of software what we go about is

483
00:20:36,460 --> 00:20:39,730
it has been you have to unpack it

484
00:20:38,350 --> 00:20:42,189
because the software has been compiled

485
00:20:39,730 --> 00:20:44,710
in some way if you unpack it analyze it

486
00:20:42,190 --> 00:20:46,480
modified and repack it somehow you can

487
00:20:44,710 --> 00:20:52,180
reach the same thing with different

488
00:20:46,480 --> 00:20:53,800
functionality so also like what would

489
00:20:52,180 --> 00:20:55,060
Wenders did was they thought like you

490
00:20:53,800 --> 00:20:57,010
know applying encryption is enough

491
00:20:55,060 --> 00:20:58,990
they're just going for confidentiality

492
00:20:57,010 --> 00:21:00,730
and if you talk to them you know what if

493
00:20:58,990 --> 00:21:02,680
your bridge stream is encrypted how

494
00:21:00,730 --> 00:21:05,140
would you modify it then but there has

495
00:21:02,680 --> 00:21:06,760
been so much research done on the way

496
00:21:05,140 --> 00:21:08,350
they have done side channel analysis

497
00:21:06,760 --> 00:21:10,330
because they usually use symmetric

498
00:21:08,350 --> 00:21:12,280
encryption and you can actually do power

499
00:21:10,330 --> 00:21:14,860
analysis to figure out what are they a

500
00:21:12,280 --> 00:21:16,510
is keys and if you want to look more

501
00:21:14,860 --> 00:21:19,330
into it you know check out riskier

502
00:21:16,510 --> 00:21:20,830
papers they do a lot of work on it we

503
00:21:19,330 --> 00:21:22,960
have done fault injection which is

504
00:21:20,830 --> 00:21:25,060
called bad fat that's how we defeated

505
00:21:22,960 --> 00:21:27,820
Cisco secure boot on a phone

506
00:21:25,060 --> 00:21:30,010
79 41 which is probably in your on your

507
00:21:27,820 --> 00:21:31,450
office desks so you can do forth

508
00:21:30,010 --> 00:21:33,310
injections where you can skip the check

509
00:21:31,450 --> 00:21:36,010
after you know like if there is any

510
00:21:33,310 --> 00:21:37,360
problem in encryption and people have

511
00:21:36,010 --> 00:21:41,170
done photon emission and mass is I don't

512
00:21:37,360 --> 00:21:43,600
even know much about it so so this was

513
00:21:41,170 --> 00:21:46,830
the development board which we used for

514
00:21:43,600 --> 00:21:50,080
our research this is using a device

515
00:21:46,830 --> 00:21:52,899
which is LX 45 T that's what Cisco use

516
00:21:50,080 --> 00:21:55,689
and we found a de port for doing our

517
00:21:52,900 --> 00:21:58,090
o-line analysis so let's go about like

518
00:21:55,690 --> 00:22:01,150
how do you do the unpack of FPGA

519
00:21:58,090 --> 00:22:02,560
bitstream all you have to do is just

520
00:22:01,150 --> 00:22:06,280
read that document and you will figure

521
00:22:02,560 --> 00:22:09,010
it out so to go about that so to do an

522
00:22:06,280 --> 00:22:13,290
unpack the FPGA bitstream as I said like

523
00:22:09,010 --> 00:22:15,820
FPGA has special logic to read its own

524
00:22:13,290 --> 00:22:18,190
configuration and it all starts with

525
00:22:15,820 --> 00:22:20,230
sync would it's it's a special magic

526
00:22:18,190 --> 00:22:22,270
marker which tells the FPGA hardware

527
00:22:20,230 --> 00:22:23,110
logic that this is how I'm this is where

528
00:22:22,270 --> 00:22:25,600
my configurations

529
00:22:23,110 --> 00:22:27,820
that's then the ID code which explains

530
00:22:25,600 --> 00:22:30,250
what kind of device it is and in that

531
00:22:27,820 --> 00:22:32,889
family then the CTL which basically

532
00:22:30,250 --> 00:22:35,380
tells whether the whether I need whether

533
00:22:32,890 --> 00:22:37,450
the FPGA needs to use the encryption

534
00:22:35,380 --> 00:22:39,760
decryption logic in the hardware to

535
00:22:37,450 --> 00:22:42,010
decrypt the bitstream and then it finds

536
00:22:39,760 --> 00:22:44,770
the command which basically tells when

537
00:22:42,010 --> 00:22:47,290
to configure itself and the FDR I

538
00:22:44,770 --> 00:22:48,820
register is the one which tells where

539
00:22:47,290 --> 00:22:51,280
the bitstream is going to start and then

540
00:22:48,820 --> 00:22:54,309
desync is the another magic marker which

541
00:22:51,280 --> 00:22:55,990
tells I'm done configuring it but here a

542
00:22:54,309 --> 00:22:59,139
cool thing is that if you again after

543
00:22:55,990 --> 00:23:01,419
desync it's really cool like if you know

544
00:22:59,140 --> 00:23:03,840
about Hardware Trojans so here we had an

545
00:23:01,419 --> 00:23:06,580
idea where you know if even if the

546
00:23:03,840 --> 00:23:09,668
vendor has put in the perfect bit stream

547
00:23:06,580 --> 00:23:11,439
and there is some space left usually

548
00:23:09,669 --> 00:23:13,929
because these SP eyes are 4 Meg's or it

549
00:23:11,440 --> 00:23:16,240
makes you can add another sync word

550
00:23:13,929 --> 00:23:18,220
after the words and FPGA will

551
00:23:16,240 --> 00:23:19,840
reconfigure it at himself so it will

552
00:23:18,220 --> 00:23:22,570
forget the configuration from back and

553
00:23:19,840 --> 00:23:24,699
you can do you know like redo the whole

554
00:23:22,570 --> 00:23:26,740
FPGA after you know using that sync word

555
00:23:24,700 --> 00:23:28,330
so that's another problem in it that's

556
00:23:26,740 --> 00:23:31,299
why you need the confidentiality and

557
00:23:28,330 --> 00:23:32,740
authentication then you analyze it so

558
00:23:31,299 --> 00:23:35,139
there are different types of frames each

559
00:23:32,740 --> 00:23:36,190
FBG can be thought of as like the

560
00:23:35,140 --> 00:23:38,440
bitstream can be thought of as like

561
00:23:36,190 --> 00:23:41,140
frames like basically arrays of things

562
00:23:38,440 --> 00:23:44,590
and each I raised in this case is 1 30

563
00:23:41,140 --> 00:23:47,350
bytes there is a type 0 frame which

564
00:23:44,590 --> 00:23:49,270
configures the clb then the type 1 which

565
00:23:47,350 --> 00:23:51,639
explains the memory part of it you know

566
00:23:49,270 --> 00:23:54,730
the initialization portions think of

567
00:23:51,640 --> 00:23:56,860
like FF PG is doing sha-256 computations

568
00:23:54,730 --> 00:24:00,940
then all the initial constants of the

569
00:23:56,860 --> 00:24:02,760
sha-256 are kept in B Ram and then the

570
00:24:00,940 --> 00:24:06,880
i/o interface which we care about

571
00:24:02,760 --> 00:24:09,309
so these are some nitty-gritty details

572
00:24:06,880 --> 00:24:13,840
of like this specific FPGA which Cisco

573
00:24:09,309 --> 00:24:15,820
uses and this is what is cool about is

574
00:24:13,840 --> 00:24:20,110
that like you can think of it like a 2d

575
00:24:15,820 --> 00:24:23,110
array a 2d matrix and each matrix has a

576
00:24:20,110 --> 00:24:28,449
row and a column and a major and a minor

577
00:24:23,110 --> 00:24:30,549
I think if I show you this thing right

578
00:24:28,450 --> 00:24:33,100
so this is a really cool UI you can

579
00:24:30,549 --> 00:24:35,260
actually access it we are hosting it and

580
00:24:33,100 --> 00:24:36,820
you can put in you can put in any

581
00:24:35,260 --> 00:24:41,050
configuration bitstream

582
00:24:36,820 --> 00:24:42,340
in a two-hour to which we have which is

583
00:24:41,050 --> 00:24:44,320
on github and there will be a link shown

584
00:24:42,340 --> 00:24:45,610
and you can analyze the bitstream if

585
00:24:44,320 --> 00:24:48,159
it's from spartan six and then you can

586
00:24:45,610 --> 00:24:51,159
visually see how the bitstream is laid

587
00:24:48,160 --> 00:24:54,700
out which column which major which minor

588
00:24:51,160 --> 00:24:57,460
represents which you know bits it's it's

589
00:24:54,700 --> 00:24:59,290
really cool so here as you can see this

590
00:24:57,460 --> 00:25:01,600
is a small example which i have it on

591
00:24:59,290 --> 00:25:04,270
the table and it basically turns on four

592
00:25:01,600 --> 00:25:06,399
lights and you can exactly see in which

593
00:25:04,270 --> 00:25:09,330
row the bitstream

594
00:25:06,400 --> 00:25:13,540
has you know which row the render has

595
00:25:09,330 --> 00:25:15,760
rendered tool has put in or when the

596
00:25:13,540 --> 00:25:18,250
tool has utilized the resources so you

597
00:25:15,760 --> 00:25:20,680
know it's basically multiple units of

598
00:25:18,250 --> 00:25:22,630
different resources and they can they

599
00:25:20,680 --> 00:25:25,510
can choose whichever element you want to

600
00:25:22,630 --> 00:25:28,180
use and as you can see we exactly

601
00:25:25,510 --> 00:25:30,340
specify which of the cells have been

602
00:25:28,180 --> 00:25:32,470
used properly and you can actually

603
00:25:30,340 --> 00:25:34,480
change it you can change this switching

604
00:25:32,470 --> 00:25:37,900
around playing you can basically make an

605
00:25:34,480 --> 00:25:39,910
fpga to you know instead of talking to a

606
00:25:37,900 --> 00:25:44,050
different pin or a different chaga

607
00:25:39,910 --> 00:25:46,210
rhythm you can change it to do even mv5

608
00:25:44,050 --> 00:25:48,190
you know because it's all about changing

609
00:25:46,210 --> 00:25:50,050
all the boolean functions are here so

610
00:25:48,190 --> 00:25:53,920
you can implement it but again we have

611
00:25:50,050 --> 00:25:57,250
focused on io changes and this is the

612
00:25:53,920 --> 00:25:59,110
representation of cisco FPGA

613
00:25:57,250 --> 00:26:01,270
implementation so as you can see they

614
00:25:59,110 --> 00:26:03,490
are using most of the resources all the

615
00:26:01,270 --> 00:26:07,090
great ones are unused resources so you

616
00:26:03,490 --> 00:26:09,880
can use them for your own you know like

617
00:26:07,090 --> 00:26:11,350
for your own functions so you can put in

618
00:26:09,880 --> 00:26:15,250
hardware trojans which no one will ever

619
00:26:11,350 --> 00:26:18,419
figure it out and i want to actually

620
00:26:15,250 --> 00:26:18,420
show you this too

621
00:26:22,919 --> 00:26:25,919
so

622
00:26:41,870 --> 00:26:51,289
so if you go to this so if you go to

623
00:26:47,840 --> 00:26:55,668
this website and it's called balloon

624
00:26:51,289 --> 00:26:58,520
Rouge that github that I oh and there's

625
00:26:55,669 --> 00:27:05,750
a there's this to which we have open

626
00:26:58,520 --> 00:27:08,658
source also and you can actually you can

627
00:27:05,750 --> 00:27:10,700
supply a bit string to it and you can

628
00:27:08,659 --> 00:27:12,799
specify which pin to turn it off which

629
00:27:10,700 --> 00:27:19,760
pin to turn it on and it generates a

630
00:27:12,799 --> 00:27:22,179
JSON file which you can load it one

631
00:27:19,760 --> 00:27:22,179
second

632
00:27:34,560 --> 00:27:40,560
so if you go ahead this is representing

633
00:27:36,990 --> 00:27:42,780
this mojo boat which has Alex nine bits

634
00:27:40,560 --> 00:27:45,210
it's a device called Alex nine and I

635
00:27:42,780 --> 00:27:48,570
have basically built a circuit which

636
00:27:45,210 --> 00:27:50,220
turns on four lights and you can

637
00:27:48,570 --> 00:27:52,290
actually go it has passed the whole

638
00:27:50,220 --> 00:27:57,510
thing and you can see here the whole bit

639
00:27:52,290 --> 00:28:00,450
stream and it specifies which model it

640
00:27:57,510 --> 00:28:02,129
is and this is the FDR I which explains

641
00:28:00,450 --> 00:28:05,190
how to configure different hardware

642
00:28:02,130 --> 00:28:07,520
elements and you can go in and see how

643
00:28:05,190 --> 00:28:10,500
different resources are actually used

644
00:28:07,520 --> 00:28:12,330
and I'm pretty sure whichever routers

645
00:28:10,500 --> 00:28:15,270
you are using they probably have an FPGA

646
00:28:12,330 --> 00:28:17,370
and you can take that bit stream put it

647
00:28:15,270 --> 00:28:19,110
in our tool you can add like if they're

648
00:28:17,370 --> 00:28:21,570
using altaira or something we haven't

649
00:28:19,110 --> 00:28:23,310
added much support for it but the the

650
00:28:21,570 --> 00:28:25,139
module has been designed in a way it's a

651
00:28:23,310 --> 00:28:28,379
very modular way you can use most of the

652
00:28:25,140 --> 00:28:30,660
parsers we have written and you can

653
00:28:28,380 --> 00:28:33,330
basically analyze what your routers are

654
00:28:30,660 --> 00:28:36,390
actually doing what components it

655
00:28:33,330 --> 00:28:40,379
contains so and it also explains you

656
00:28:36,390 --> 00:28:49,310
know like if I go here what it is trying

657
00:28:40,380 --> 00:28:49,310
to use so equal to then going back

658
00:28:52,460 --> 00:29:00,930
actually on also sure what it can do so

659
00:28:57,990 --> 00:29:04,530
here as you can see there are four pins

660
00:29:00,930 --> 00:29:06,030
right now right and I'm gonna just take

661
00:29:04,530 --> 00:29:07,170
the bitstream which is a binary bit

662
00:29:06,030 --> 00:29:09,840
string which you can dump it from your

663
00:29:07,170 --> 00:29:12,180
router I'm gonna I'm gonna disable one

664
00:29:09,840 --> 00:29:16,379
of the pin I'm gonna make one pin from 1

665
00:29:12,180 --> 00:29:19,680
to 0 so here if you see I'm just telling

666
00:29:16,380 --> 00:29:23,160
the P 123 which is the pin name to turn

667
00:29:19,680 --> 00:29:27,020
it off and without changing any source

668
00:29:23,160 --> 00:29:27,020
code all done through bit stream

669
00:29:34,940 --> 00:29:40,780
it's gonna load it and no software

670
00:29:37,880 --> 00:29:47,300
required just analyze the whole thing

671
00:29:40,780 --> 00:29:49,820
turn it off and I would highly recommend

672
00:29:47,300 --> 00:29:56,030
you guys to like check out this repo

673
00:29:49,820 --> 00:29:58,340
it's called bowels eiling's all this

674
00:29:56,030 --> 00:30:04,220
code has been open sourced we want

675
00:29:58,340 --> 00:30:05,959
people to like contribute to it please

676
00:30:04,220 --> 00:30:08,390
check it out there as there are examples

677
00:30:05,960 --> 00:30:10,400
to work with this specific device if you

678
00:30:08,390 --> 00:30:12,140
want to do some fpga analysis you want

679
00:30:10,400 --> 00:30:14,390
to learn about fpga mojo is that right

680
00:30:12,140 --> 00:30:16,100
boot to go about it because it exposes

681
00:30:14,390 --> 00:30:17,660
all the pins because in the end fpga is

682
00:30:16,100 --> 00:30:24,129
just about pins which takes input and

683
00:30:17,660 --> 00:30:24,130
output and as we can see here

684
00:30:33,310 --> 00:30:36,090
I think

685
00:30:38,170 --> 00:30:41,549
they might camera first

686
00:30:50,040 --> 00:30:55,139
while this is happening you can go ahead

687
00:30:52,990 --> 00:30:55,140
and

688
00:31:08,870 --> 00:31:12,668
camera throws on one second

689
00:31:20,620 --> 00:31:27,250
well you can see there are three lights

690
00:31:22,150 --> 00:31:34,000
on I'm now a sacrifice to demagogues was

691
00:31:27,250 --> 00:31:35,830
not happened but anyhow so there isn't a

692
00:31:34,000 --> 00:31:37,210
there is an algorithm about like how you

693
00:31:35,830 --> 00:31:39,580
can actually figure out which pin

694
00:31:37,210 --> 00:31:42,580
represents which bits represent which

695
00:31:39,580 --> 00:31:43,658
pin and you don't have to worry about

696
00:31:42,580 --> 00:31:46,570
the algorithm because it has been

697
00:31:43,659 --> 00:31:48,400
written in that github repo again you

698
00:31:46,570 --> 00:31:50,260
all you have to do is like write the

699
00:31:48,400 --> 00:31:51,909
unpack logic for the altaira and you

700
00:31:50,260 --> 00:31:55,539
should be able to use most of the things

701
00:31:51,909 --> 00:31:57,370
which we have developed how you modify

702
00:31:55,539 --> 00:32:00,039
it again there is a modifier in that

703
00:31:57,370 --> 00:32:03,459
github repo it's basically figuring out

704
00:32:00,039 --> 00:32:05,320
the crc during repack so what silence

705
00:32:03,460 --> 00:32:07,840
does is that the uses of weird algorithm

706
00:32:05,320 --> 00:32:09,730
for CRC which is a 22 bit crc it's

707
00:32:07,840 --> 00:32:11,620
usually they developed it not for

708
00:32:09,730 --> 00:32:13,570
security but for single event upset so

709
00:32:11,620 --> 00:32:16,750
while during while configuring your

710
00:32:13,570 --> 00:32:18,340
FPGAs there might be some problems in

711
00:32:16,750 --> 00:32:21,640
the electrical circuit and it can cause

712
00:32:18,340 --> 00:32:23,709
issues it skips a bunch of registers

713
00:32:21,640 --> 00:32:25,870
very proprietary and then what it does

714
00:32:23,710 --> 00:32:28,809
is that it raises this pin high so you

715
00:32:25,870 --> 00:32:32,199
cannot you know during our analysis of

716
00:32:28,809 --> 00:32:34,090
Cisco we had to actually add that attach

717
00:32:32,200 --> 00:32:35,770
to it because you know it is a it took

718
00:32:34,090 --> 00:32:38,049
us some time to figure out that register

719
00:32:35,770 --> 00:32:39,820
that algorithm and then if it is

720
00:32:38,049 --> 00:32:41,679
encrypted again doing the side channel

721
00:32:39,820 --> 00:32:43,629
analysis to figure out the AES keys and

722
00:32:41,679 --> 00:32:46,690
then you can use that AES key to encrypt

723
00:32:43,630 --> 00:32:48,549
it again there's also this register

724
00:32:46,690 --> 00:32:51,700
called CRC bypass so if you configure it

725
00:32:48,549 --> 00:32:54,220
configure the FPGA to bypass the CRC you

726
00:32:51,700 --> 00:32:57,929
can also skip the CRC and this was the

727
00:32:54,220 --> 00:33:01,539
demo which worked but not now the camera

728
00:32:57,929 --> 00:33:02,860
well then the idea was that we have

729
00:33:01,539 --> 00:33:06,399
developed this technique where we can

730
00:33:02,860 --> 00:33:09,100
automatically and extract the FPGA

731
00:33:06,399 --> 00:33:11,408
analyze it and then modify it now we

732
00:33:09,100 --> 00:33:13,570
wanted to apply this logic to Cisco

733
00:33:11,409 --> 00:33:18,250
routers right and the idea was spawn the

734
00:33:13,570 --> 00:33:21,549
pimp on DSR but again this the the LX 45

735
00:33:18,250 --> 00:33:23,950
T has 296 pins and how it works is that

736
00:33:21,549 --> 00:33:26,080
this SPI chip which is attached to the

737
00:33:23,950 --> 00:33:29,049
board you there is no way to program it

738
00:33:26,080 --> 00:33:31,840
and you have to take it off you know

739
00:33:29,049 --> 00:33:33,668
program it again take you know like put

740
00:33:31,840 --> 00:33:34,360
it back on so it takes around 15 to 20

741
00:33:33,669 --> 00:33:38,110
minutes we time

742
00:33:34,360 --> 00:33:40,029
so trick the second author and this came

743
00:33:38,110 --> 00:33:42,340
out with the cool idea of like JTAG

744
00:33:40,029 --> 00:33:44,860
chain so in Cisco routers you have JTAG

745
00:33:42,340 --> 00:33:47,019
in there and they they left it out so

746
00:33:44,860 --> 00:33:49,299
you can use the JTAG chain to figure out

747
00:33:47,019 --> 00:33:51,700
which pins are enabled when the fan

748
00:33:49,299 --> 00:33:54,519
noise goes out you know because when the

749
00:33:51,700 --> 00:33:56,440
FPGA figures out like the hash of the

750
00:33:54,519 --> 00:33:58,330
phone weight has been modified the fan

751
00:33:56,440 --> 00:34:01,240
noise goes up and that was a cutting

752
00:33:58,330 --> 00:34:03,939
point to figure out which pins modified

753
00:34:01,240 --> 00:34:06,820
the state using JTAG scan chain so we

754
00:34:03,940 --> 00:34:09,099
found 10 pins but again it's 10 into 15

755
00:34:06,820 --> 00:34:11,619
or 20 let's say 200 minutes who's gonna

756
00:34:09,099 --> 00:34:14,080
spend that much time so we had to build

757
00:34:11,619 --> 00:34:15,849
we had everything to create the to

758
00:34:14,080 --> 00:34:18,098
create these bit stream modifications we

759
00:34:15,849 --> 00:34:20,470
have written the automation framework

760
00:34:18,099 --> 00:34:24,010
but I need an automation framework to

761
00:34:20,469 --> 00:34:26,348
test this thing so I moved to my intern

762
00:34:24,010 --> 00:34:29,379
my automated bitstream extraction and

763
00:34:26,349 --> 00:34:30,909
testing framework bryant so in worst

764
00:34:29,379 --> 00:34:34,029
case what will happen is that if these

765
00:34:30,909 --> 00:34:37,810
ten pins doesn't work yes just I mean he

766
00:34:34,030 --> 00:34:39,970
has to sit down for 296 minutes and then

767
00:34:37,810 --> 00:34:41,980
finally we pawned the ASR we pawned the

768
00:34:39,969 --> 00:34:43,779
pin and upon the ASR so the logic worked

769
00:34:41,980 --> 00:34:47,379
we were able to disable it by just

770
00:34:43,780 --> 00:34:49,720
changing Y and y equal to FX but again

771
00:34:47,379 --> 00:34:51,190
now the question is if you go to Cisco I

772
00:34:49,719 --> 00:34:54,759
mean we have to figure out how to do it

773
00:34:51,190 --> 00:34:56,800
remotely and we've started doing more

774
00:34:54,760 --> 00:35:00,130
analysis we found out that you can

775
00:34:56,800 --> 00:35:02,680
actually modify the bitstream of the

776
00:35:00,130 --> 00:35:05,770
FPGA through the Linux kernel in the iOS

777
00:35:02,680 --> 00:35:08,140
XC there's a cpld driver which allows

778
00:35:05,770 --> 00:35:10,690
the upgrade of the FPGA this is the

779
00:35:08,140 --> 00:35:13,509
first problem here right like why a sick

780
00:35:10,690 --> 00:35:16,330
in the secure boot chain why the trust

781
00:35:13,510 --> 00:35:18,010
anchor is being modified through

782
00:35:16,330 --> 00:35:20,830
something which is high above the chain

783
00:35:18,010 --> 00:35:22,089
in the secure boot chain so it was

784
00:35:20,830 --> 00:35:25,930
pretty easy they had the driver called

785
00:35:22,089 --> 00:35:29,140
quack ko pretty cool name we hijacked

786
00:35:25,930 --> 00:35:31,149
that quack ko we updated basically the

787
00:35:29,140 --> 00:35:34,629
worse engineered the driver and all you

788
00:35:31,150 --> 00:35:36,550
have to do was take this in install this

789
00:35:34,630 --> 00:35:39,190
modified driver and it will update the

790
00:35:36,550 --> 00:35:41,920
fpga with the modified bit string which

791
00:35:39,190 --> 00:35:43,540
will disable the check but we needed

792
00:35:41,920 --> 00:35:47,140
fruit to do in smart on the linux kernel

793
00:35:43,540 --> 00:35:48,099
which which is how you you know load

794
00:35:47,140 --> 00:35:50,739
drivers

795
00:35:48,099 --> 00:35:52,359
so we started writing protocol fuzzers

796
00:35:50,739 --> 00:35:55,049
you know like this is a 20 year old

797
00:35:52,359 --> 00:35:57,699
called code which they have taken and

798
00:35:55,049 --> 00:36:01,329
made it as a process and running on this

799
00:35:57,699 --> 00:36:03,609
Linux kernel so you know we probably

800
00:36:01,329 --> 00:36:05,440
like first rate for a month and we found

801
00:36:03,609 --> 00:36:10,150
some crashes but none of them were you

802
00:36:05,440 --> 00:36:13,299
know like allowing us to get root then

803
00:36:10,150 --> 00:36:16,839
James one of the team members basically

804
00:36:13,299 --> 00:36:21,038
said you know cisco has implemented most

805
00:36:16,839 --> 00:36:24,339
of the analysis the management in Lua

806
00:36:21,039 --> 00:36:26,729
so he said Louis easy I can hack it he

807
00:36:24,339 --> 00:36:31,078
went ahead got command injection in FTP

808
00:36:26,729 --> 00:36:34,239
credentials and that's the CD number and

809
00:36:31,079 --> 00:36:37,029
he also said it lacks CSRF port

810
00:36:34,239 --> 00:36:39,549
protections that's the CV number for

811
00:36:37,029 --> 00:36:42,789
that and we were able to get root and

812
00:36:39,549 --> 00:36:44,469
once you had root you can upload the

813
00:36:42,789 --> 00:36:48,069
modified driver which will modify the

814
00:36:44,469 --> 00:36:50,229
FPGA bitstream and we will win and let

815
00:36:48,069 --> 00:36:52,660
me show you I didn't drink the router

816
00:36:50,229 --> 00:36:55,660
with me usually I bring the router but

817
00:36:52,660 --> 00:36:58,779
each time you do this update there is no

818
00:36:55,660 --> 00:37:01,479
way there is like a person has to go in

819
00:36:58,779 --> 00:37:03,819
and actually take out the chip update

820
00:37:01,479 --> 00:37:07,959
with with the real the original bit

821
00:37:03,819 --> 00:37:09,279
stream and then applied so I've lost ten

822
00:37:07,959 --> 00:37:16,328
more thousand dollars during their demo

823
00:37:09,279 --> 00:37:19,299
so not bringing it this is the demo so

824
00:37:16,329 --> 00:37:21,640
the idea here is that we will use one of

825
00:37:19,299 --> 00:37:24,910
the vulnerabilities you know which get

826
00:37:21,640 --> 00:37:27,609
us the route so this is actually pretty

827
00:37:24,910 --> 00:37:29,649
important so when a router boots here as

828
00:37:27,609 --> 00:37:31,719
you can see it's a it's the system

829
00:37:29,650 --> 00:37:34,269
integrity status this represents that

830
00:37:31,719 --> 00:37:36,099
you know like the stat this is what FPGA

831
00:37:34,269 --> 00:37:43,089
is telling the system that everything is

832
00:37:36,099 --> 00:37:45,009
good right and it boots up then you know

833
00:37:43,089 --> 00:37:46,808
does the the whole boot chain which we

834
00:37:45,009 --> 00:37:49,239
talked about you know boots the Linux

835
00:37:46,809 --> 00:37:51,249
boots the iOS this is the iOS and now

836
00:37:49,239 --> 00:37:53,319
we're gonna attack use the command

837
00:37:51,249 --> 00:37:57,669
injection vulnerability to get root on

838
00:37:53,319 --> 00:37:58,808
the system and again like you know

839
00:37:57,670 --> 00:38:00,459
people have been talking about like a

840
00:37:58,809 --> 00:38:01,609
lot of reporters side like you need food

841
00:38:00,459 --> 00:38:03,680
to do this but the

842
00:38:01,609 --> 00:38:07,430
ideas that there are so many if you if

843
00:38:03,680 --> 00:38:08,690
you just go if you just go to you know

844
00:38:07,430 --> 00:38:10,368
like their website you can see like

845
00:38:08,690 --> 00:38:11,450
there are multiple ways to get root and

846
00:38:10,369 --> 00:38:13,400
that's not the idea what we are

847
00:38:11,450 --> 00:38:15,859
proposing but the core problem here is

848
00:38:13,400 --> 00:38:19,460
that the root of trust is mutable and it

849
00:38:15,859 --> 00:38:22,730
should not be like that so here we have

850
00:38:19,460 --> 00:38:25,430
updated the bitstream now and now we can

851
00:38:22,730 --> 00:38:28,519
update the Rama so the bitstream the

852
00:38:25,430 --> 00:38:31,279
FPGA was validating the Rama if I can if

853
00:38:28,519 --> 00:38:33,348
I can if I have updated the FPGA disable

854
00:38:31,279 --> 00:38:37,400
the check and now updating the rom on I

855
00:38:33,349 --> 00:38:41,019
should be able to boot the router so you

856
00:38:37,400 --> 00:38:44,930
know it's updating the whole Rahman and

857
00:38:41,019 --> 00:38:48,439
then if you reboot the system after 100

858
00:38:44,930 --> 00:38:50,509
seconds so as you can see I could remove

859
00:38:48,440 --> 00:38:52,910
this right because I control the FPGA

860
00:38:50,509 --> 00:38:54,859
the the firmware now but just to explain

861
00:38:52,910 --> 00:38:58,788
like what we have done fpg has reported

862
00:38:54,859 --> 00:39:01,098
that something is bad but we have you

863
00:38:58,789 --> 00:39:02,779
know basically disable that reset pin so

864
00:39:01,099 --> 00:39:05,690
even though the FPGA is sending the

865
00:39:02,779 --> 00:39:09,579
reset pin signal that is disabled right

866
00:39:05,690 --> 00:39:09,579
so it wouldn't release reset the system

867
00:39:09,849 --> 00:39:19,099
and it goes ahead and the modified

868
00:39:13,460 --> 00:39:21,079
Rahman boots in and you know I'm

869
00:39:19,099 --> 00:39:23,480
creating the upgrading the firmware and

870
00:39:21,079 --> 00:39:27,440
try let's our mic

871
00:39:23,480 --> 00:39:31,960
oh there so now we have modified

872
00:39:27,440 --> 00:39:31,960
firmware running now let's get back

873
00:39:34,000 --> 00:39:40,810
so what was the final cost right $10,000

874
00:39:37,240 --> 00:39:42,729
for the sacrifice $10,000 to test the

875
00:39:40,810 --> 00:39:45,580
idea that whether the FBG is doing it on

876
00:39:42,730 --> 00:39:47,310
a 10,000 the automotive dicks extract

877
00:39:45,580 --> 00:39:50,799
automated extraction

878
00:39:47,310 --> 00:39:54,509
you know the Brian framework costed us

879
00:39:50,800 --> 00:39:57,580
$10,000 - and then during the demo

880
00:39:54,510 --> 00:40:00,340
$10,000 during demo so it's sacrificed

881
00:39:57,580 --> 00:40:00,880
for demo gods but what about mitigation

882
00:40:00,340 --> 00:40:03,190
right

883
00:40:00,880 --> 00:40:06,940
the only mitigation once you apply this

884
00:40:03,190 --> 00:40:09,609
batch the only way is you know someone

885
00:40:06,940 --> 00:40:12,760
has to go there these are to the chip

886
00:40:09,609 --> 00:40:15,759
and basically you know reflux the

887
00:40:12,760 --> 00:40:17,890
bitstream so cisco ever since then like

888
00:40:15,760 --> 00:40:20,619
has released the patch I've looked into

889
00:40:17,890 --> 00:40:23,200
it and what they're doing is that they

890
00:40:20,619 --> 00:40:25,359
are not allowing the FPGA upgrade to

891
00:40:23,200 --> 00:40:26,980
happen anymore they keep the SPI in

892
00:40:25,359 --> 00:40:28,869
order to do upgrade the SPI you have to

893
00:40:26,980 --> 00:40:30,550
select the SPI and they keep the SPI

894
00:40:28,869 --> 00:40:33,280
line low which is actually pretty cool

895
00:40:30,550 --> 00:40:36,310
but there are other ways to do it which

896
00:40:33,280 --> 00:40:38,109
we are going to do research and but the

897
00:40:36,310 --> 00:40:40,420
core problem here still exists right

898
00:40:38,109 --> 00:40:42,400
it's still a mutable route of Trustees

899
00:40:40,420 --> 00:40:44,710
it's supposed to be configurable it's an

900
00:40:42,400 --> 00:40:47,170
FPGA and that's not how secure boot

901
00:40:44,710 --> 00:40:50,280
chain is you know created it it it

902
00:40:47,170 --> 00:40:52,359
should be focused on an immutable thing

903
00:40:50,280 --> 00:40:54,190
what the question for the vendor is that

904
00:40:52,359 --> 00:40:55,990
if it has been deployed in the wild

905
00:40:54,190 --> 00:40:58,359
right like what we need is a tool for

906
00:40:55,990 --> 00:41:00,220
detection just encrypt the bitstream

907
00:40:58,359 --> 00:41:04,029
would not work because side-channel

908
00:41:00,220 --> 00:41:06,540
defeat that those kind of such an attack

909
00:41:04,030 --> 00:41:08,650
can be used to defeat those measures

910
00:41:06,540 --> 00:41:10,690
adding authentication in Hardware

911
00:41:08,650 --> 00:41:11,859
actually improves the security but the

912
00:41:10,690 --> 00:41:14,230
side channel attacks are still possible

913
00:41:11,859 --> 00:41:18,700
but in the end you know we are down

914
00:41:14,230 --> 00:41:20,050
$40,000 extra 50 and in future we want

915
00:41:18,700 --> 00:41:22,509
to look into Hardware Trojans which I

916
00:41:20,050 --> 00:41:25,000
talked about we want to see if we can

917
00:41:22,510 --> 00:41:27,220
use Fantana which is basically a way to

918
00:41:25,000 --> 00:41:31,030
transmit information if these things

919
00:41:27,220 --> 00:41:33,250
exist in some air gap facility and fpg

920
00:41:31,030 --> 00:41:37,510
also uses compression which we haven't

921
00:41:33,250 --> 00:41:41,859
been able to figure out but gladly Cisco

922
00:41:37,510 --> 00:41:46,089
use the uncompressed bit stream again

923
00:41:41,859 --> 00:41:48,020
this is where the the module is which we

924
00:41:46,089 --> 00:41:52,009
can we have open source the whole code

925
00:41:48,020 --> 00:41:54,530
and I want to say thanks to Rick Joey

926
00:41:52,010 --> 00:41:56,960
James my automated framework Brian the

927
00:41:54,530 --> 00:42:00,080
intern Alex were building that really

928
00:41:56,960 --> 00:42:01,760
cool UI tool and a tree despite nur who

929
00:42:00,080 --> 00:42:04,940
were with us during the start of this

930
00:42:01,760 --> 00:42:08,810
project and just to explain you what it

931
00:42:04,940 --> 00:42:12,140
feels like to lose $50,000 you know

932
00:42:08,810 --> 00:42:16,000
that's basically $50,000 to the cat

933
00:42:12,140 --> 00:42:16,000
goddess any questions

934
00:42:18,410 --> 00:42:26,199
[Applause]

935
00:42:32,520 --> 00:42:34,580
you

