1
00:00:00,000 --> 00:00:25,320
okay<font color="#E5E5E5"> next up we have cast a black re</font>

2
00:00:01,920 --> 00:00:27,060
from CSU good morning I'm<font color="#E5E5E5"> kaustubh from</font>

3
00:00:25,320 --> 00:00:28,800
Colorado State I'm a PhD student in the

4
00:00:27,060 --> 00:00:30,660
computer science department and I'm

5
00:00:28,800 --> 00:00:32,340
going<font color="#E5E5E5"> to be talking about a bit of my</font>

6
00:00:30,660 --> 00:00:47,399
work which<font color="#E5E5E5"> will go into my dissertation</font>

7
00:00:32,340 --> 00:00:49,110
I my slides went away so what problem

8
00:00:47,399 --> 00:00:50,879
are you trying<font color="#E5E5E5"> to solve we've known for</font>

9
00:00:49,110 --> 00:00:52,980
a long<font color="#E5E5E5"> time</font><font color="#CCCCCC"> that the rate of growth of</font>

10
00:00:50,879 --> 00:00:55,559
the rib of the global default free

11
00:00:52,980 --> 00:00:57,269
routing table has been<font color="#E5E5E5"> a concern for a</font>

12
00:00:55,559 --> 00:00:58,680
long time it's<font color="#E5E5E5"> been growing at a rate</font>

13
00:00:57,270 --> 00:01:02,160
that's faster than linear for a while

14
00:00:58,680 --> 00:01:04,979
<font color="#CCCCCC">now the global rib size also affects the</font>

15
00:01:02,160 --> 00:01:07,500
fifth size because ribs are a<font color="#E5E5E5"> function</font>

16
00:01:04,979 --> 00:01:09,330
of many tips calculator together we

17
00:01:07,500 --> 00:01:11,790
think that the growth is a bigger

18
00:01:09,330 --> 00:01:13,439
concern than trip growth fit memory

19
00:01:11,790 --> 00:01:16,680
tends to be small it tends<font color="#CCCCCC"> to be</font>

20
00:01:13,439 --> 00:01:19,889
expensive look up on the need to keep up

21
00:01:16,680 --> 00:01:22,290
with increasing line speeds and

22
00:01:19,890 --> 00:01:25,380
operators I guess you would know I have

23
00:01:22,290 --> 00:01:28,200
<font color="#E5E5E5">to deal with increasing line speeds as</font>

24
00:01:25,380 --> 00:01:29,520
well as more lookups per second and this

25
00:01:28,200 --> 00:01:31,259
makes<font color="#E5E5E5"> network preventing heart because</font>

26
00:01:29,520 --> 00:01:33,929
that should keep throwing more hardware

27
00:01:31,259 --> 00:01:36,240
and faster hardware at the problem this

28
00:01:33,930 --> 00:01:39,600
<font color="#E5E5E5">is all for ipv4 we don't know how bad</font>

29
00:01:36,240 --> 00:01:41,908
ipv6 is going to make<font color="#E5E5E5"> things so our work</font>

30
00:01:39,600 --> 00:01:45,630
focuses on solving this problem and our

31
00:01:41,909 --> 00:01:48,420
solution is to implement flip caching so

32
00:01:45,630 --> 00:01:50,970
why cash the short and sweet answer is

33
00:01:48,420 --> 00:01:53,100
performance class<font color="#E5E5E5"> also is involved the</font>

34
00:01:50,970 --> 00:01:56,130
way we see it caching gives us two

35
00:01:53,100 --> 00:01:59,130
potential benefits one it reduces the

36
00:01:56,130 --> 00:02:01,229
memory bandwidth required for the<font color="#E5E5E5"> fib</font>

37
00:01:59,130 --> 00:02:02,699
accesses that's because we actually

38
00:02:01,229 --> 00:02:05,880
reduce the number of<font color="#E5E5E5"> times the actual</font>

39
00:02:02,700 --> 00:02:07,860
fit but the slow memory is accessed we

40
00:02:05,880 --> 00:02:09,090
also think it also<font color="#E5E5E5"> gives us an</font>

41
00:02:07,860 --> 00:02:12,239
opportunity to have better compression

42
00:02:09,090 --> 00:02:13,500
and forwarding chips we think that<font color="#E5E5E5"> on</font>

43
00:02:12,239 --> 00:02:15,480
the cash we can have

44
00:02:13,500 --> 00:02:17,490
less compression for fast accesses and

45
00:02:15,480 --> 00:02:19,890
we can store the bulk of the entries on

46
00:02:17,490 --> 00:02:22,410
slow memory with more compression that

47
00:02:19,890 --> 00:02:23,940
gives a slower axis this may potentially

48
00:02:22,410 --> 00:02:25,370
be needed for the<font color="#E5E5E5"> next generation of</font>

49
00:02:23,940 --> 00:02:29,840
foreign ships that have to deal with

50
00:02:25,370 --> 00:02:29,840
terabit per second forwarding speeds

51
00:02:30,080 --> 00:02:34,800
caching depends on this on a on a

52
00:02:33,000 --> 00:02:37,200
property of traffic called locality so

53
00:02:34,800 --> 00:02:40,200
is their locality to measure this we

54
00:02:37,200 --> 00:02:42,690
took 22 24 hour<font color="#E5E5E5"> tracers simultaneously</font>

55
00:02:40,200 --> 00:02:45,209
from our friendly local neighborhood is

56
00:02:42,690 --> 00:02:48,690
PF r GP there's anybody from afar GP

57
00:02:45,209 --> 00:02:51,510
thanks guys we took these packet races

58
00:02:48,690 --> 00:02:54,590
at two<font color="#CCCCCC"> tier 1 provider links both links</font>

59
00:02:51,510 --> 00:02:56,820
were<font color="#CCCCCC"> 1 gigabit per second at the time of</font>

60
00:02:54,590 --> 00:02:59,040
the time that the traces were taken on

61
00:02:56,820 --> 00:03:01,620
both links we saw approximately 2

62
00:02:59,040 --> 00:03:05,579
billion packets over the entire 24 hour

63
00:03:01,620 --> 00:03:07,140
period we got chunked up these traces

64
00:03:05,580 --> 00:03:08,730
<font color="#E5E5E5">into</font><font color="#CCCCCC"> five-minute intervals to see what</font>

65
00:03:07,140 --> 00:03:10,529
the packet rates looked at I look like

66
00:03:08,730 --> 00:03:13,470
need five<font color="#CCCCCC"> minutes and that's what the</font>

67
00:03:10,530 --> 00:03:15,390
graph shows the graph essentially is

68
00:03:13,470 --> 00:03:17,010
what we expected we see<font color="#E5E5E5"> where the</font>

69
00:03:15,390 --> 00:03:18,420
<font color="#E5E5E5">well-known effect of a diurnal cycle in</font>

70
00:03:17,010 --> 00:03:21,390
traffic there is more traffic during the

71
00:03:18,420 --> 00:03:23,790
<font color="#E5E5E5">daytime than during the</font><font color="#CCCCCC"> nighttime so yes</font>

72
00:03:21,390 --> 00:03:26,160
there is mechanically from our analysis

73
00:03:23,790 --> 00:03:30,090
we saw that about 80,000 prefixes carry

74
00:03:26,160 --> 00:03:31,709
99% of all traffic for ninety percent of

75
00:03:30,090 --> 00:03:33,780
traffic you need<font color="#E5E5E5"> about</font><font color="#CCCCCC"> 1,000 prefixes</font>

76
00:03:31,709 --> 00:03:35,220
but that's a well-known result we've

77
00:03:33,780 --> 00:03:37,470
known that for a long time<font color="#CCCCCC"> Jennifer</font>

78
00:03:35,220 --> 00:03:41,010
expert Nina Taft a lot of researchers

79
00:03:37,470 --> 00:03:42,570
have<font color="#E5E5E5"> shown that this exists so let's get</font>

80
00:03:41,010 --> 00:03:46,649
down into<font color="#E5E5E5"> the meat of a solution does</font>

81
00:03:42,570 --> 00:03:49,260
caching work we implemented we simulated

82
00:03:46,650 --> 00:03:51,720
least recently used cash and we saw that

83
00:03:49,260 --> 00:03:53,548
<font color="#E5E5E5">with our traces we had a 96 to</font>

84
00:03:51,720 --> 00:03:55,709
<font color="#CCCCCC">ninety-nine percent</font><font color="#E5E5E5"> hit rate depending</font>

85
00:03:53,549 --> 00:03:57,780
on the duration of the day we also

86
00:03:55,709 --> 00:04:00,480
compare this to a optimal caching

87
00:03:57,780 --> 00:04:02,549
algorithm and we found<font color="#E5E5E5"> that</font><font color="#CCCCCC"> our results</font>

88
00:04:00,480 --> 00:04:04,290
are close to optimal even with a cold

89
00:04:02,549 --> 00:04:07,739
cash when the cash is warming up we see

90
00:04:04,290 --> 00:04:11,220
87 299<font color="#E5E5E5"> 91% hit rates so yes great</font>

91
00:04:07,739 --> 00:04:14,489
caching works so how do we<font color="#CCCCCC"> use this to</font>

92
00:04:11,220 --> 00:04:16,790
build gear that he was catching the way

93
00:04:14,489 --> 00:04:20,010
we see it there<font color="#E5E5E5"> are three barriers to</font>

94
00:04:16,790 --> 00:04:21,359
doing flip caching one is this problem

95
00:04:20,010 --> 00:04:24,120
called the cash hiding problem which

96
00:04:21,358 --> 00:04:25,169
we'll talk about later then is what do

97
00:04:24,120 --> 00:04:27,419
you do with the<font color="#E5E5E5"> package that actually</font>

98
00:04:25,169 --> 00:04:27,940
incorrect cache miss and the third one

99
00:04:27,419 --> 00:04:29,560
is how

100
00:04:27,940 --> 00:04:33,730
the<font color="#CCCCCC"> cache behave when it is</font><font color="#E5E5E5"> being</font>

101
00:04:29,560 --> 00:04:35,050
attacked so<font color="#CCCCCC"> to solve cash hiding are our</font>

102
00:04:33,730 --> 00:04:38,290
secret sauce is this thing called a

103
00:04:35,050 --> 00:04:40,720
<font color="#CCCCCC">cacheable film what we do is we take the</font>

104
00:04:38,290 --> 00:04:43,150
rib and we sorry the fib<font color="#E5E5E5"> and we post</font>

105
00:04:40,720 --> 00:04:45,220
process it to make<font color="#E5E5E5"> this thing called</font>

106
00:04:43,150 --> 00:04:48,479
<font color="#CCCCCC">cacheable film and we use the cacheable</font>

107
00:04:45,220 --> 00:04:50,470
flip to serve entries to in the<font color="#CCCCCC"> cache</font>

108
00:04:48,480 --> 00:04:52,240
the important<font color="#CCCCCC"> thing to note is that</font>

109
00:04:50,470 --> 00:04:55,840
enough cash now preserves forwarding

110
00:04:52,240 --> 00:04:56,890
correctness to explain the<font color="#CCCCCC"> cash reading</font>

111
00:04:55,840 --> 00:04:59,799
problem let us consider the following

112
00:04:56,890 --> 00:05:01,870
snippet of a fib it's a very contrived

113
00:04:59,800 --> 00:05:04,300
example the<font color="#CCCCCC"> 5th or more much more</font>

114
00:05:01,870 --> 00:05:06,580
complex<font color="#E5E5E5"> than this we know the point</font>

115
00:05:04,300 --> 00:05:09,610
would<font color="#E5E5E5"> be noted is that the 12 13 / 16</font>

116
00:05:06,580 --> 00:05:11,770
prefix covers the 12 13 14 / 24 prefix

117
00:05:09,610 --> 00:05:15,250
and they both have a<font color="#E5E5E5"> different outgoing</font>

118
00:05:11,770 --> 00:05:17,799
<font color="#E5E5E5">interface so how does cash hiding</font>

119
00:05:15,250 --> 00:05:20,440
impaired forwarding let starting off

120
00:05:17,800 --> 00:05:22,810
with the previous example and we have an

121
00:05:20,440 --> 00:05:25,750
empty cache suppose the packet comes

122
00:05:22,810 --> 00:05:27,510
around for 12 3 11 first thing we do is

123
00:05:25,750 --> 00:05:30,730
<font color="#E5E5E5">do a cash look up to see if there is a</font>

124
00:05:27,510 --> 00:05:33,669
prefix matching that packet in<font color="#CCCCCC"> the cache</font>

125
00:05:30,730 --> 00:05:36,970
there isn't so we go to the fib there is

126
00:05:33,669 --> 00:05:40,960
a longest prefix match for the 12 13 16

127
00:05:36,970 --> 00:05:43,030
matches we put that<font color="#CCCCCC"> in the cash</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> the</font>

128
00:05:40,960 --> 00:05:46,060
packet for 12 13 11 goes out of<font color="#E5E5E5"> the</font>

129
00:05:43,030 --> 00:05:48,580
right engine interface want to then

130
00:05:46,060 --> 00:05:52,650
suppose<font color="#CCCCCC"> a packet comes along for 12 13</font>

131
00:05:48,580 --> 00:05:55,450
14 one before we do a cash look up and

132
00:05:52,650 --> 00:05:58,719
in this case<font color="#CCCCCC"> we have hit it's a it</font>

133
00:05:55,450 --> 00:06:00,520
matches the 12 13 16 1 and the packet

134
00:05:58,720 --> 00:06:02,650
goes off happily along interface one but

135
00:06:00,520 --> 00:06:04,510
this is clearly wrong because we have a

136
00:06:02,650 --> 00:06:06,969
more specific entry for a different

137
00:06:04,510 --> 00:06:10,870
interface in our fib so what we've seen

138
00:06:06,970 --> 00:06:13,510
is that the 12 13 16 entry / 16 entry in

139
00:06:10,870 --> 00:06:16,710
the cash as actually hidden the correct

140
00:06:13,510 --> 00:06:19,510
entry for the 12 13 14 / 24 in the flip

141
00:06:16,710 --> 00:06:21,159
this is a bad thing because you have now

142
00:06:19,510 --> 00:06:22,840
<font color="#E5E5E5">packaged going wrong way all sorts</font><font color="#CCCCCC"> of</font>

143
00:06:21,160 --> 00:06:26,950
bad things<font color="#CCCCCC"> happened when packets go or</font>

144
00:06:22,840 --> 00:06:28,650
interfaces they're not supposed to so

145
00:06:26,950 --> 00:06:31,599
how do<font color="#E5E5E5"> we solve the cash adding problem</font>

146
00:06:28,650 --> 00:06:33,880
we<font color="#E5E5E5"> introduce a new hole filling</font>

147
00:06:31,600 --> 00:06:36,010
algorithm which works you know way that

148
00:06:33,880 --> 00:06:39,490
we<font color="#CCCCCC"> described let's</font><font color="#E5E5E5"> start let's start off</font>

149
00:06:36,010 --> 00:06:41,800
with<font color="#E5E5E5"> the previous fill our algorithm</font>

150
00:06:39,490 --> 00:06:44,409
<font color="#E5E5E5">goes to the fib selects the prefix</font>

151
00:06:41,800 --> 00:06:46,840
the shortest mask length we check if it

152
00:06:44,409 --> 00:06:51,550
has any descendants if it does we split

153
00:06:46,840 --> 00:06:52,780
it into his two children loop we select

154
00:06:51,550 --> 00:06:54,759
<font color="#E5E5E5">the prefix with the shortest mass length</font>

155
00:06:52,780 --> 00:06:57,039
this guy does not have any descendants

156
00:06:54,759 --> 00:06:59,440
so we deleted from the non-cash of afib

157
00:06:57,039 --> 00:07:01,599
and put it into<font color="#CCCCCC"> the</font><font color="#E5E5E5"> cache shovelful we</font>

158
00:06:59,440 --> 00:07:02,889
go<font color="#E5E5E5"> around we select the / 17 because</font>

159
00:07:01,599 --> 00:07:06,878
it's the prefix with the shortest mass

160
00:07:02,889 --> 00:07:08,919
length this<font color="#E5E5E5"> one has a descendant so we</font>

161
00:07:06,879 --> 00:07:11,560
split it into his two children we go

162
00:07:08,919 --> 00:07:13,210
around<font color="#E5E5E5"> we select the / 18 no descendants</font>

163
00:07:11,560 --> 00:07:16,180
so we put in the intro<font color="#E5E5E5"> the</font><font color="#CCCCCC"> cashable fib</font>

164
00:07:13,210 --> 00:07:19,479
we loop we said at the other / 18 this

165
00:07:16,180 --> 00:07:22,419
one has a as a descendant so we<font color="#E5E5E5"> split it</font>

166
00:07:19,479 --> 00:07:24,758
into its 2 / 9 teens select the / 19 put

167
00:07:22,419 --> 00:07:27,580
it into the casual<font color="#E5E5E5"> fib and so on and so</font>

168
00:07:24,759 --> 00:07:31,449
forth<font color="#E5E5E5"> until we reach this stage so we</font>

169
00:07:27,580 --> 00:07:35,500
<font color="#CCCCCC">have a 12 13 14 / 23 and</font><font color="#E5E5E5"> the 12 13 14 /</font>

170
00:07:31,449 --> 00:07:37,750
24 as we form the algorithm loops it

171
00:07:35,500 --> 00:07:39,460
selects the / 23 it<font color="#E5E5E5"> has a digitizer</font>

172
00:07:37,750 --> 00:07:42,610
descendant in this case the<font color="#E5E5E5"> descendant</font>

173
00:07:39,460 --> 00:07:45,909
is a child so instead<font color="#E5E5E5"> of adding the 2 /</font>

174
00:07:42,610 --> 00:07:47,800
24 we just add the missing / 24 we go

175
00:07:45,909 --> 00:07:50,259
around<font color="#CCCCCC"> at</font><font color="#E5E5E5"> this point we see that both /</font>

176
00:07:47,800 --> 00:07:53,669
24 actually<font color="#E5E5E5"> leaves neither of</font><font color="#CCCCCC"> them have</font>

177
00:07:50,259 --> 00:07:58,870
any descendants so we put them both into

178
00:07:53,669 --> 00:08:01,000
the<font color="#CCCCCC"> cacheable fill the casual fib has no</font>

179
00:07:58,870 --> 00:08:03,120
cash hiding problem we can catch these

180
00:08:01,000 --> 00:08:06,130
entries and we<font color="#E5E5E5"> don't have to deal with</font>

181
00:08:03,120 --> 00:08:07,659
incorrect warning but<font color="#E5E5E5"> this has the</font>

182
00:08:06,130 --> 00:08:09,250
potential to have let's actually

183
00:08:07,659 --> 00:08:10,960
introduces one more potential problem

184
00:08:09,250 --> 00:08:13,449
have we<font color="#E5E5E5"> just blown up</font><font color="#CCCCCC"> the fib by a</font>

185
00:08:10,960 --> 00:08:16,568
factor of nine right four and<font color="#E5E5E5"> a half we</font>

186
00:08:13,449 --> 00:08:19,360
went<font color="#E5E5E5"> from two prefixes 29 turns out we</font>

187
00:08:16,569 --> 00:08:21,849
don't we ran this algorithm on our F on

188
00:08:19,360 --> 00:08:23,139
<font color="#CCCCCC">the table we pulled from fr GP and we</font>

189
00:08:21,849 --> 00:08:25,569
<font color="#E5E5E5">went from about</font><font color="#CCCCCC"> three hundred ninety</font>

190
00:08:23,139 --> 00:08:27,340
<font color="#CCCCCC">seven thousand prefixes to about 432,000</font>

191
00:08:25,569 --> 00:08:29,919
prefixes which is an increase of about

192
00:08:27,340 --> 00:08:32,110
six and a half percent to make sure that

193
00:08:29,919 --> 00:08:33,698
this wasn't you know an edge artifact or

194
00:08:32,110 --> 00:08:35,860
we were doing<font color="#E5E5E5"> something funny with just</font>

195
00:08:33,698 --> 00:08:38,348
<font color="#CCCCCC">effigy p we</font><font color="#E5E5E5"> pull tables from</font><font color="#CCCCCC"> route views</font>

196
00:08:35,860 --> 00:08:40,479
and we ran the same<font color="#E5E5E5"> algorithm and turns</font>

197
00:08:38,349 --> 00:08:43,570
out that the percentage increase that we

198
00:08:40,479 --> 00:08:45,339
seen is actually same this<font color="#CCCCCC"> is</font><font color="#E5E5E5"> actually</font>

199
00:08:43,570 --> 00:08:48,040
not<font color="#CCCCCC"> that surprising because there is</font>

200
00:08:45,339 --> 00:08:50,170
research that shows that the tables

201
00:08:48,040 --> 00:08:52,990
themselves don't differ that much from

202
00:08:50,170 --> 00:08:54,889
<font color="#E5E5E5">isp twice p so this percentage increases</font>

203
00:08:52,990 --> 00:08:56,929
not really a big surprise<font color="#E5E5E5"> to us but</font>

204
00:08:54,889 --> 00:09:00,769
just wanted to make<font color="#CCCCCC"> sure</font><font color="#E5E5E5"> that we</font><font color="#CCCCCC"> are</font>

205
00:08:56,929 --> 00:09:03,769
being seen also since we do caching

206
00:09:00,769 --> 00:09:05,809
later on and the cache size is pinned to

207
00:09:03,769 --> 00:09:08,449
<font color="#CCCCCC">a few tens of thousand of entries this</font>

208
00:09:05,809 --> 00:09:11,089
<font color="#E5E5E5">person this increase of 30,000 prefixes</font>

209
00:09:08,449 --> 00:09:14,269
is pretty much irrelevant anyways also

210
00:09:11,089 --> 00:09:16,639
since these are slowed we envision<font color="#E5E5E5"> this</font>

211
00:09:14,269 --> 00:09:20,329
flipping slower on slow memory it's not

212
00:09:16,639 --> 00:09:21,919
<font color="#E5E5E5">a big deal so we've just dealt with the</font>

213
00:09:20,329 --> 00:09:24,258
cash hiding problem the next barrier

214
00:09:21,919 --> 00:09:29,779
took care to caching is what do we do

215
00:09:24,259 --> 00:09:31,459
with the the cache misses so in our

216
00:09:29,779 --> 00:09:33,259
system we cure them until they can be

217
00:09:31,459 --> 00:09:35,449
delivered<font color="#E5E5E5"> and while the cash is being</font>

218
00:09:33,259 --> 00:09:38,209
updated but what does that Q look like

219
00:09:35,449 --> 00:09:41,540
how deep does it go and what how much

220
00:09:38,209 --> 00:09:44,089
delay two packets incur to study this we

221
00:09:41,540 --> 00:09:46,129
built our caching simulator packets come

222
00:09:44,089 --> 00:09:48,799
in they hit the cash if the result in a

223
00:09:46,129 --> 00:09:51,019
cache hit they incur one<font color="#CCCCCC"> cash look up</font>

224
00:09:48,799 --> 00:09:54,019
and sent<font color="#E5E5E5"> out on the outgoing interface</font>

225
00:09:51,019 --> 00:09:55,399
no problems however or a cache miss week

226
00:09:54,019 --> 00:09:58,369
you the packets and put them into a

227
00:09:55,399 --> 00:10:00,439
special cache miss buffer when the

228
00:09:58,369 --> 00:10:01,759
buffer is are essentially a<font color="#CCCCCC"> 5 4 q's and</font>

229
00:10:00,439 --> 00:10:07,248
when the packets get<font color="#E5E5E5"> to the head of the</font>

230
00:10:01,759 --> 00:10:10,220
queue we do a cash fetch from the slow

231
00:10:07,249 --> 00:10:13,189
slow memory and then the packet goes out

232
00:10:10,220 --> 00:10:15,709
on<font color="#CCCCCC"> the</font><font color="#E5E5E5"> right interface we use a lookup</font>

233
00:10:13,189 --> 00:10:18,349
time of 100 nanoseconds for the cash

234
00:10:15,709 --> 00:10:20,748
<font color="#E5E5E5">flow cup and a hundred microseconds for</font>

235
00:10:18,350 --> 00:10:23,739
the slow memory look up we realized<font color="#E5E5E5"> that</font>

236
00:10:20,749 --> 00:10:27,110
these values our way on the higher side

237
00:10:23,739 --> 00:10:29,389
probably orders of magnitude higher we

238
00:10:27,110 --> 00:10:31,910
wanted<font color="#E5E5E5"> to</font><font color="#CCCCCC"> make sure that our system work</font>

239
00:10:29,389 --> 00:10:33,619
for the very worst of<font color="#E5E5E5"> conditions we</font>

240
00:10:31,910 --> 00:10:35,749
expect that it do better when we plug

241
00:10:33,619 --> 00:10:40,100
that chill right valuation for the

242
00:10:35,749 --> 00:10:42,079
memory access times so what does the

243
00:10:40,100 --> 00:10:43,459
cache miss buffer look like the one

244
00:10:42,079 --> 00:10:45,919
<font color="#E5E5E5">thing that we see is</font><font color="#CCCCCC"> that no data</font>

245
00:10:43,459 --> 00:10:49,399
packets are ever queued in the entire 24

246
00:10:45,919 --> 00:10:52,999
hour trace we saw about 950 6,000 cash

247
00:10:49,399 --> 00:10:55,699
misses out<font color="#E5E5E5"> of which 750 2,000 word</font><font color="#CCCCCC"> TCP</font>

248
00:10:52,999 --> 00:10:57,739
since the others was in acts also the

249
00:10:55,699 --> 00:11:00,349
buffer utilization is fairly low we need

250
00:10:57,739 --> 00:11:03,769
to stop buffer space to show to store

251
00:11:00,350 --> 00:11:06,730
about<font color="#E5E5E5"> 20-25 packets at any in any given</font>

252
00:11:03,769 --> 00:11:06,730
five minute interval

253
00:11:07,820 --> 00:11:12,690
so that's two out of three barriers to

254
00:11:11,010 --> 00:11:14,160
cashing that<font color="#CCCCCC"> we've</font><font color="#E5E5E5"> talked about the</font>

255
00:11:12,690 --> 00:11:16,560
third and possibly the<font color="#E5E5E5"> most important</font>

256
00:11:14,160 --> 00:11:19,560
one<font color="#CCCCCC"> is how how does our cash perform</font>

257
00:11:16,560 --> 00:11:21,420
under attacks unfortunately are

258
00:11:19,560 --> 00:11:23,400
<font color="#CCCCCC">attacking would an LRU cache is fairly</font>

259
00:11:21,420 --> 00:11:26,939
trivial you if you know the cache size

260
00:11:23,400 --> 00:11:29,670
you pick those many idle prefixes you

261
00:11:26,940 --> 00:11:31,530
send one packet to those many prefixes

262
00:11:29,670 --> 00:11:33,660
in a train and hold and what you get is

263
00:11:31,530 --> 00:11:35,939
a new cash what we should have done in

264
00:11:33,660 --> 00:11:38,390
this an<font color="#E5E5E5"> oversight on our part is we</font>

265
00:11:35,940 --> 00:11:41,850
<font color="#CCCCCC">should have simulated in a few instant</font>

266
00:11:38,390 --> 00:11:42,780
when we did our caching results this

267
00:11:41,850 --> 00:11:43,980
actually opens up an interesting

268
00:11:42,780 --> 00:11:45,360
research question what is the

269
00:11:43,980 --> 00:11:47,940
appropriate cash replacement algorithm

270
00:11:45,360 --> 00:11:49,380
we should use it's not a trivial

271
00:11:47,940 --> 00:11:51,180
question we don't have a good answer for

272
00:11:49,380 --> 00:11:54,420
it right now<font color="#E5E5E5"> but we plan to take a crack</font>

273
00:11:51,180 --> 00:11:56,130
at it in future work but given<font color="#CCCCCC"> that we</font>

274
00:11:54,420 --> 00:11:58,140
<font color="#E5E5E5">you know assuming that we simulate LF</font>

275
00:11:56,130 --> 00:12:00,390
you we want to<font color="#E5E5E5"> know at what rate and</font>

276
00:11:58,140 --> 00:12:03,600
attacker needs to send packets to

277
00:12:00,390 --> 00:12:05,699
replace all entries in the cache so

278
00:12:03,600 --> 00:12:08,100
let's assume this cache module the

279
00:12:05,700 --> 00:12:10,200
attacker knows the cache size he picks

280
00:12:08,100 --> 00:12:12,870
up prefix that's<font color="#E5E5E5"> idle it's not getting</font>

281
00:12:10,200 --> 00:12:15,480
packets and he<font color="#E5E5E5"> sends more packets per</font>

282
00:12:12,870 --> 00:12:17,040
second to that Idol prefix than the rate

283
00:12:15,480 --> 00:12:20,880
at which the most popular prefix in the

284
00:12:17,040 --> 00:12:23,670
cash gets<font color="#CCCCCC"> packets so what does this</font>

285
00:12:20,880 --> 00:12:25,290
attack do the attackers attack prefix

286
00:12:23,670 --> 00:12:28,189
which was previously<font color="#E5E5E5"> Idol now becomes</font>

287
00:12:25,290 --> 00:12:31,469
<font color="#E5E5E5">the top most popular prefix in the cache</font>

288
00:12:28,190 --> 00:12:32,820
what the prefix that<font color="#E5E5E5"> was previously the</font>

289
00:12:31,470 --> 00:12:35,100
most popular becomes the second most

290
00:12:32,820 --> 00:12:37,770
<font color="#E5E5E5">popular and so on and so forth until you</font>

291
00:12:35,100 --> 00:12:42,360
end up evicting the last the least most

292
00:12:37,770 --> 00:12:44,100
popular prefix from the cash to<font color="#CCCCCC"> even out</font>

293
00:12:42,360 --> 00:12:47,070
prefixes from the<font color="#E5E5E5"> cache the attacker has</font>

294
00:12:44,100 --> 00:12:48,780
to use<font color="#CCCCCC"> n Idol prefixes each of them at a</font>

295
00:12:47,070 --> 00:12:52,290
rate that is higher than the most

296
00:12:48,780 --> 00:12:56,310
popular prefix if we generalize the

297
00:12:52,290 --> 00:12:58,980
attack we see<font color="#E5E5E5"> that the attacker to evict</font>

298
00:12:56,310 --> 00:13:00,869
prefix I he needs to send packets at a

299
00:12:58,980 --> 00:13:03,840
rate that are greater that is greater

300
00:13:00,870 --> 00:13:06,600
than equal to<font color="#E5E5E5"> the packet rate of the ice</font>

301
00:13:03,840 --> 00:13:09,300
prefix times the rank of you know what

302
00:13:06,600 --> 00:13:13,080
the value of pi we ran these numbers on

303
00:13:09,300 --> 00:13:15,449
our traces we see<font color="#E5E5E5"> that if the attacker</font>

304
00:13:13,080 --> 00:13:17,910
needs to once replace the bottom<font color="#E5E5E5"> 100</font>

305
00:13:15,450 --> 00:13:20,070
prefixes he needs to send<font color="#E5E5E5"> 5500 packages</font>

306
00:13:17,910 --> 00:13:21,540
again so if he wants<font color="#CCCCCC"> to do you know if</font>

307
00:13:20,070 --> 00:13:23,910
if his bar is set low and if own

308
00:13:21,540 --> 00:13:25,980
citizens<font color="#E5E5E5"> replace the 100 least popular</font>

309
00:13:23,910 --> 00:13:28,110
prefixes Phoenix Tucson 5500 which is a

310
00:13:25,980 --> 00:13:30,930
fairly you know<font color="#E5E5E5"> it's very</font><font color="#CCCCCC"> easy to</font><font color="#E5E5E5"> do</font>

311
00:13:28,110 --> 00:13:33,480
however if<font color="#CCCCCC"> he wants to replace say half</font>

312
00:13:30,930 --> 00:13:36,660
of<font color="#E5E5E5"> the</font><font color="#CCCCCC"> cache with 5000 entries he needs</font>

313
00:13:33,480 --> 00:13:38,610
to send 8.7 million packets a second if

314
00:13:36,660 --> 00:13:40,110
he wants<font color="#E5E5E5"> to blow the entire cash he</font>

315
00:13:38,610 --> 00:13:42,330
needs to send<font color="#E5E5E5"> 17 and a half million</font>

316
00:13:40,110 --> 00:13:43,830
package<font color="#CCCCCC"> laughing at this point I think</font>

317
00:13:42,330 --> 00:13:46,500
<font color="#E5E5E5">this has become attack against the</font>

318
00:13:43,830 --> 00:13:48,300
network and not against the cash the

319
00:13:46,500 --> 00:13:49,830
least of the least of the operators

320
00:13:48,300 --> 00:13:52,020
<font color="#CCCCCC">where you should be what's in the cache</font>

321
00:13:49,830 --> 00:13:57,210
but they have network problems to deal

322
00:13:52,020 --> 00:13:59,340
with we realize that our work has

323
00:13:57,210 --> 00:14:02,420
limitations we<font color="#E5E5E5"> don't know if our</font>

324
00:13:59,340 --> 00:14:04,740
observations carried to the core we need

325
00:14:02,420 --> 00:14:07,469
traces from the code to investigate if

326
00:14:04,740 --> 00:14:11,490
anybody here wants to<font color="#E5E5E5"> give me a trace I</font>

327
00:14:07,470 --> 00:14:13,380
will gladly take one however there are

328
00:14:11,490 --> 00:14:14,940
there is research that<font color="#E5E5E5"> shows that recent</font>

329
00:14:13,380 --> 00:14:17,670
trends point towards traffic

330
00:14:14,940 --> 00:14:19,710
concentration at two data centers we

331
00:14:17,670 --> 00:14:21,449
believe<font color="#CCCCCC"> that if this is the case then</font>

332
00:14:19,710 --> 00:14:26,430
there should be locality of traffic at

333
00:14:21,450 --> 00:14:30,660
the course also the second future work

334
00:14:26,430 --> 00:14:33,120
we have is what is the right cash

335
00:14:30,660 --> 00:14:34,410
replacement algorithm is there a

336
00:14:33,120 --> 00:14:36,720
trade-off between performance and

337
00:14:34,410 --> 00:14:38,520
robustness is allow you the right way to

338
00:14:36,720 --> 00:14:39,780
<font color="#E5E5E5">go is LF you the right way to go we</font>

339
00:14:38,520 --> 00:14:41,910
don't<font color="#E5E5E5"> know it's um something we need to</font>

340
00:14:39,780 --> 00:14:45,270
investigate also we<font color="#E5E5E5"> need a better</font>

341
00:14:41,910 --> 00:14:47,730
analysis of what happens when in case of

342
00:14:45,270 --> 00:14:50,130
cache misses we need to investigate what

343
00:14:47,730 --> 00:14:52,500
is<font color="#E5E5E5"> the memory bandwidth requirement in</font>

344
00:14:50,130 --> 00:14:57,170
case of cache misses and we also need to

345
00:14:52,500 --> 00:15:00,390
<font color="#CCCCCC">know who suffers from these cache misses</font>

346
00:14:57,170 --> 00:15:02,790
to conclude<font color="#E5E5E5"> this work is another</font>

347
00:15:00,390 --> 00:15:05,880
reminder<font color="#E5E5E5"> of traffic locality and</font><font color="#CCCCCC"> also</font>

348
00:15:02,790 --> 00:15:07,469
<font color="#CCCCCC">that caching works we've</font><font color="#E5E5E5"> seen our</font>

349
00:15:05,880 --> 00:15:09,450
caching system give us 96<font color="#CCCCCC"> and</font>

350
00:15:07,470 --> 00:15:12,240
ninety-nine percent hit tricks with a

351
00:15:09,450 --> 00:15:13,770
cache size of about 10,000 entries these

352
00:15:12,240 --> 00:15:16,110
measurements are all carried out at the

353
00:15:13,770 --> 00:15:17,640
edge of the network we've seen<font color="#E5E5E5"> that we</font>

354
00:15:16,110 --> 00:15:20,130
eliminated the cache hiding problem

355
00:15:17,640 --> 00:15:24,210
we've<font color="#E5E5E5"> seen that in case</font><font color="#CCCCCC"> of cache misses</font>

356
00:15:20,130 --> 00:15:25,470
we suffer fairly low queuing delays we

357
00:15:24,210 --> 00:15:28,110
watch<font color="#E5E5E5"> this one data cache is fairly</font>

358
00:15:25,470 --> 00:15:31,680
robust we think attacks against the<font color="#E5E5E5"> top</font>

359
00:15:28,110 --> 00:15:34,290
most popular prefixes are infeasible so

360
00:15:31,680 --> 00:15:37,359
let's build gear with caches

361
00:15:34,290 --> 00:15:38,920
unless we<font color="#CCCCCC"> can come up with new laws of</font>

362
00:15:37,360 --> 00:15:41,589
physics we think these might this might

363
00:15:38,920 --> 00:15:43,378
be the only way<font color="#E5E5E5"> to go with the next</font>

364
00:15:41,589 --> 00:15:45,699
<font color="#CCCCCC">generation of foreign ships that do</font>

365
00:15:43,379 --> 00:15:48,250
terabyte per second and the small so be

366
00:15:45,699 --> 00:15:52,540
required when we have larger ribs

367
00:15:48,250 --> 00:16:01,120
because of ipv6 deployment and thank you

368
00:15:52,540 --> 00:16:02,860
and I'm open<font color="#CCCCCC"> for questions it's Charles</font>

369
00:16:01,120 --> 00:16:06,129
Mansur with wide<font color="#CCCCCC"> open west I'm curious</font>

370
00:16:02,860 --> 00:16:07,959
<font color="#E5E5E5">on the</font><font color="#CCCCCC"> LRU what sort of distribution do</font>

371
00:16:06,129 --> 00:16:13,120
you see in the<font color="#CCCCCC"> track in the data you had</font>

372
00:16:07,959 --> 00:16:14,410
as far as population and speed the top

373
00:16:13,120 --> 00:16:15,910
one obviously was going to have a<font color="#E5E5E5"> very</font>

374
00:16:14,410 --> 00:16:19,750
high rate but does it<font color="#E5E5E5"> fall off</font>

375
00:16:15,910 --> 00:16:21,459
dramatically or it does so the topmost

376
00:16:19,750 --> 00:16:24,430
from what I've seen in our faces is

377
00:16:21,459 --> 00:16:25,930
about<font color="#E5E5E5"> in the in the most popular</font>

378
00:16:24,430 --> 00:16:27,729
interval it gets about half a million

379
00:16:25,930 --> 00:16:30,339
packets in the<font color="#E5E5E5"> entire five minute</font>

380
00:16:27,730 --> 00:16:32,019
interval but I drank for the<font color="#E5E5E5"> tenth</font>

381
00:16:30,339 --> 00:16:34,540
10,000 most popular<font color="#E5E5E5"> theories is that's</font>

382
00:16:32,019 --> 00:16:35,529
in the tens or<font color="#E5E5E5"> 20 tens or hundreds of</font>

383
00:16:34,540 --> 00:16:37,569
packets or<font color="#E5E5E5"> seconds it's a fairly</font>

384
00:16:35,529 --> 00:16:39,189
dramatic drop-off in terms so<font color="#E5E5E5"> that it</font>

385
00:16:37,569 --> 00:16:41,410
<font color="#E5E5E5">hits obviously you need to do research</font>

386
00:16:39,189 --> 00:16:44,469
but I it sounds like just top of the

387
00:16:41,410 --> 00:16:46,149
head that a attack against the top<font color="#CCCCCC"> cache</font>

388
00:16:44,470 --> 00:16:48,310
<font color="#CCCCCC">entries isn't feasible but a</font><font color="#E5E5E5"> DDoS</font>

389
00:16:46,149 --> 00:16:52,170
against something in the lower part of

390
00:16:48,310 --> 00:16:52,170
the cash would be very feasible yes yes

391
00:16:54,209 --> 00:17:00,638
<font color="#E5E5E5">okay so my question is</font><font color="#CCCCCC"> you're hiding</font>

392
00:16:57,430 --> 00:17:03,370
problem what kind of simulation scenario

393
00:17:00,639 --> 00:17:06,549
you were using like what's a packet per

394
00:17:03,370 --> 00:17:08,859
second<font color="#E5E5E5"> rate yeah it actually doesn't</font>

395
00:17:06,549 --> 00:17:10,359
depend<font color="#E5E5E5"> on the packets per second it just</font>

396
00:17:08,859 --> 00:17:12,938
depends on what entries that are in the

397
00:17:10,359 --> 00:17:16,000
cache and what packets come in how about

398
00:17:12,939 --> 00:17:18,459
wire speed<font color="#E5E5E5"> are you don't it's generic</font>

399
00:17:16,000 --> 00:17:19,990
<font color="#E5E5E5">it's generic it actually is independent</font>

400
00:17:18,459 --> 00:17:22,720
of what the packet rate is just what

401
00:17:19,990 --> 00:17:24,549
entries that are there in the cash but

402
00:17:22,720 --> 00:17:28,000
you have this thin K for the<font color="#E5E5E5"> cache size</font>

403
00:17:24,549 --> 00:17:30,220
<font color="#E5E5E5">right you havin k that is not refutes</font>

404
00:17:28,000 --> 00:17:32,350
the 10 k prefixes is for our hit rate

405
00:17:30,220 --> 00:17:34,510
analysis it's it's not pertain it does

406
00:17:32,350 --> 00:17:35,860
not<font color="#E5E5E5"> pertain to the cash hiding</font><font color="#CCCCCC"> it's such</font>

407
00:17:34,510 --> 00:17:38,770
an example<font color="#E5E5E5"> that we use for cash right</font>

408
00:17:35,860 --> 00:17:42,129
okay and did results was amazingly

409
00:17:38,770 --> 00:17:45,100
similar among all the<font color="#CCCCCC"> 10 about about 10</font>

410
00:17:42,130 --> 00:17:47,290
cases right yes do you have any summary

411
00:17:45,100 --> 00:17:50,100
or yes

412
00:17:47,290 --> 00:17:52,870
there was a paper<font color="#E5E5E5"> that was published I</font>

413
00:17:50,100 --> 00:17:54,219
forget very<font color="#CCCCCC"> puzzles maybe globecom of</font>

414
00:17:52,870 --> 00:17:55,959
global internet a couple of<font color="#E5E5E5"> years ago</font>

415
00:17:54,220 --> 00:17:57,670
which shows<font color="#CCCCCC"> that there is</font><font color="#E5E5E5"> actually very</font>

416
00:17:55,960 --> 00:17:59,830
little<font color="#E5E5E5"> difference between the routing</font>

417
00:17:57,670 --> 00:18:02,320
tables of different eyes peas so given

418
00:17:59,830 --> 00:18:03,850
<font color="#CCCCCC">that that is true</font><font color="#E5E5E5"> we did not actually</font>

419
00:18:02,320 --> 00:18:06,760
expect that<font color="#CCCCCC"> to be</font><font color="#E5E5E5"> too much difference</font>

420
00:18:03,850 --> 00:18:11,379
between<font color="#CCCCCC"> the person to change in the size</font>

421
00:18:06,760 --> 00:18:13,629
of each I speak thank you David Barack

422
00:18:11,380 --> 00:18:16,090
AT&T have you done any and have you done

423
00:18:13,630 --> 00:18:19,210
any<font color="#CCCCCC"> analysis of the impact of the of the</font>

424
00:18:16,090 --> 00:18:21,250
of the cash or<font color="#CCCCCC"> cashable fib on multicast</font>

425
00:18:19,210 --> 00:18:22,870
performance I'm sure they<font color="#E5E5E5"> did not get</font>

426
00:18:21,250 --> 00:18:25,780
<font color="#CCCCCC">too hot on</font><font color="#E5E5E5"> have you looked at multicast</font>

427
00:18:22,870 --> 00:18:27,939
performance and its impact on no okay

428
00:18:25,780 --> 00:18:30,040
this is well and either haven't you have

429
00:18:27,940 --> 00:18:32,290
an idea of how where the where the

430
00:18:30,040 --> 00:18:37,860
lookups<font color="#E5E5E5"> would would of how conceptually</font>

431
00:18:32,290 --> 00:18:41,050
work no need to<font color="#E5E5E5"> think about okay thanks</font>

432
00:18:37,860 --> 00:18:44,250
John Lewis<font color="#E5E5E5"> atlanticnet how does your</font>

433
00:18:41,050 --> 00:18:47,110
cash a whole avoidance handle learning a

434
00:18:44,250 --> 00:18:51,540
more specific route after a less

435
00:18:47,110 --> 00:18:54,850
specific route is already in the cash so

436
00:18:51,540 --> 00:18:57,850
so you can stir / 16 you learn a / 24

437
00:18:54,850 --> 00:18:59,800
later so to solve that problem we

438
00:18:57,850 --> 00:19:02,709
actually have the thing called<font color="#CCCCCC"> the</font>

439
00:18:59,800 --> 00:19:05,760
<font color="#CCCCCC">cacheable fib so what I discovered an</font>

440
00:19:02,710 --> 00:19:07,870
algorithm that takes a existing fib and

441
00:19:05,760 --> 00:19:09,700
processes it to<font color="#CCCCCC"> actually get rid of this</font>

442
00:19:07,870 --> 00:19:11,469
same problem so there is<font color="#CCCCCC"> really no</font>

443
00:19:09,700 --> 00:19:14,890
learning involved in case of more

444
00:19:11,470 --> 00:19:18,250
specifics so the / 16 /<font color="#E5E5E5"> 24 would have</font>

445
00:19:14,890 --> 00:19:20,050
been<font color="#E5E5E5"> replaced by prefixes that actually</font>

446
00:19:18,250 --> 00:19:25,090
cover the entire space between the / 16

447
00:19:20,050 --> 00:19:27,690
/ 24 so there's no problem of having to

448
00:19:25,090 --> 00:19:27,689
relearn euros

449
00:19:31,410 --> 00:19:39,840
anybody else going<font color="#E5E5E5"> once</font><font color="#CCCCCC"> going twice</font>

450
00:19:36,059 --> 00:19:39,840
thank you very much thank<font color="#E5E5E5"> you</font>

