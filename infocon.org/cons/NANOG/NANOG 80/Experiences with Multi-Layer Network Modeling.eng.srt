1
00:00:01,640 --> 00:00:05,939
[Music]

2
00:00:06,160 --> 00:00:11,440
hi everyone i'm anish shaikh with the

3
00:00:08,800 --> 00:00:12,559
google global networking team uh today

4
00:00:11,440 --> 00:00:14,559
i'll be talking about

5
00:00:12,559 --> 00:00:16,400
the work that we've been doing uh over a

6
00:00:14,559 --> 00:00:18,880
few years actually on

7
00:00:16,400 --> 00:00:20,880
building a multi-layer network model to

8
00:00:18,880 --> 00:00:24,640
represent all of google's

9
00:00:20,880 --> 00:00:28,160
production and non-production networks

10
00:00:24,640 --> 00:00:29,199
this talk is based on largely on a paper

11
00:00:28,160 --> 00:00:32,960
that we published

12
00:00:29,199 --> 00:00:35,040
recently in this year's nsdi conference

13
00:00:32,960 --> 00:00:36,640
and there's a link in the slides i urge

14
00:00:35,040 --> 00:00:38,559
you if you're interested to

15
00:00:36,640 --> 00:00:40,160
get some more details to go have a look

16
00:00:38,559 --> 00:00:41,760
at that paper it has

17
00:00:40,160 --> 00:00:43,279
a lot more detail on some of the things

18
00:00:41,760 --> 00:00:44,640
i'll be talking about today

19
00:00:43,280 --> 00:00:46,559
um as i said we've been working on this

20
00:00:44,640 --> 00:00:48,719
for a few years

21
00:00:46,559 --> 00:00:50,879
at google and and we think we've made

22
00:00:48,719 --> 00:00:52,640
now enough progress that it's worth uh

23
00:00:50,879 --> 00:00:54,879
talking about to a broader audience

24
00:00:52,640 --> 00:00:58,320
where hopefully it might benefit others

25
00:00:54,879 --> 00:01:00,160
so so we've organized the talk along um

26
00:00:58,320 --> 00:01:02,800
sort of three main sections i'll try to

27
00:01:00,160 --> 00:01:06,320
give some motivation for why we think we

28
00:01:02,800 --> 00:01:08,240
need a common structure for representing

29
00:01:06,320 --> 00:01:09,679
the network

30
00:01:08,240 --> 00:01:12,320
and then some of the design choices that

31
00:01:09,680 --> 00:01:13,280
we made in building out the network

32
00:01:12,320 --> 00:01:14,960
model

33
00:01:13,280 --> 00:01:17,119
including uh some of the surrounding

34
00:01:14,960 --> 00:01:19,600
infrastructure and then

35
00:01:17,119 --> 00:01:21,759
uh i'll try to save some time to talk

36
00:01:19,600 --> 00:01:23,679
about some lessons and experiences

37
00:01:21,759 --> 00:01:25,040
that we uh went through some of them

38
00:01:23,680 --> 00:01:27,200
painful um

39
00:01:25,040 --> 00:01:28,400
in in doing this work that other people

40
00:01:27,200 --> 00:01:30,799
are interested in

41
00:01:28,400 --> 00:01:33,439
in also modeling networks may find uh

42
00:01:30,799 --> 00:01:36,159
may find useful

43
00:01:33,439 --> 00:01:37,279
so just to help motivate the reason why

44
00:01:36,159 --> 00:01:39,360
we need um

45
00:01:37,280 --> 00:01:40,720
a network model uh we can start by

46
00:01:39,360 --> 00:01:43,200
looking at kind of the

47
00:01:40,720 --> 00:01:44,720
the size and scale of the networks that

48
00:01:43,200 --> 00:01:46,640
we're working with so this is an outside

49
00:01:44,720 --> 00:01:49,119
in view of google's

50
00:01:46,640 --> 00:01:51,200
network uh our cloud network it has you

51
00:01:49,119 --> 00:01:54,640
know a little over 130

52
00:01:51,200 --> 00:01:58,159
pops around the world um terrestrial and

53
00:01:54,640 --> 00:02:00,640
subsea cables around the world

54
00:01:58,159 --> 00:02:02,479
so it's a large global network that we

55
00:02:00,640 --> 00:02:05,920
use to deliver all of google's

56
00:02:02,479 --> 00:02:07,759
services and our cloud platform

57
00:02:05,920 --> 00:02:09,199
and then if we kind of flip to the

58
00:02:07,759 --> 00:02:10,720
internal view of google's

59
00:02:09,199 --> 00:02:12,319
production networks this doesn't include

60
00:02:10,720 --> 00:02:13,120
for example our campus or office

61
00:02:12,319 --> 00:02:15,760
networks

62
00:02:13,120 --> 00:02:16,720
um we can sort of build it up uh this

63
00:02:15,760 --> 00:02:18,640
way so

64
00:02:16,720 --> 00:02:20,959
we have our data center fabrics these

65
00:02:18,640 --> 00:02:23,839
are big multi-stage

66
00:02:20,959 --> 00:02:24,959
clone networks we've talked about them

67
00:02:23,840 --> 00:02:27,360
in other forums

68
00:02:24,959 --> 00:02:28,800
this is our basically our jupiter data

69
00:02:27,360 --> 00:02:31,120
center fabric

70
00:02:28,800 --> 00:02:32,160
we have a wan that interconnects all of

71
00:02:31,120 --> 00:02:34,480
our data centers

72
00:02:32,160 --> 00:02:35,920
we call it b4 it's a it's a software

73
00:02:34,480 --> 00:02:39,040
defined

74
00:02:35,920 --> 00:02:40,238
network that we use to interconnect data

75
00:02:39,040 --> 00:02:42,640
centers

76
00:02:40,239 --> 00:02:44,400
then we have another wind that connects

77
00:02:42,640 --> 00:02:48,000
basically all of our data centers and

78
00:02:44,400 --> 00:02:50,640
and regions out to

79
00:02:48,000 --> 00:02:52,160
our edge so this is our user facing when

80
00:02:50,640 --> 00:02:55,440
we call it b2

81
00:02:52,160 --> 00:02:57,680
um you know as part of b2's edge we have

82
00:02:55,440 --> 00:03:01,359
peering metros where we've implemented

83
00:02:57,680 --> 00:03:03,360
another sdn architecture called espresso

84
00:03:01,360 --> 00:03:05,200
that we've also talked about in other

85
00:03:03,360 --> 00:03:06,879
forms and then of course

86
00:03:05,200 --> 00:03:08,640
you know we connect to the internet at

87
00:03:06,879 --> 00:03:10,079
these peering locations

88
00:03:08,640 --> 00:03:11,200
and this is how we get to users and

89
00:03:10,080 --> 00:03:12,640
enterprise so you can see there's a

90
00:03:11,200 --> 00:03:14,159
number of different networks here and

91
00:03:12,640 --> 00:03:15,518
this doesn't even include you know all

92
00:03:14,159 --> 00:03:18,159
of the networks that we run but these

93
00:03:15,519 --> 00:03:21,200
are the major production networks

94
00:03:18,159 --> 00:03:26,079
and so we of course are interested in in

95
00:03:21,200 --> 00:03:28,640
driving automation and virtualization

96
00:03:26,080 --> 00:03:31,040
so we also kind of include in that our

97
00:03:28,640 --> 00:03:33,119
virtual network so our cloud

98
00:03:31,040 --> 00:03:34,798
runs the andromeda virtualization stack

99
00:03:33,120 --> 00:03:37,840
which we've also talked about

100
00:03:34,799 --> 00:03:38,239
separately this is a layer um on top of

101
00:03:37,840 --> 00:03:40,239
our

102
00:03:38,239 --> 00:03:42,640
infrastructure that implements things

103
00:03:40,239 --> 00:03:47,360
like virtual private clouds

104
00:03:42,640 --> 00:03:49,599
as part of the google cloud platform

105
00:03:47,360 --> 00:03:50,879
so as i mentioned automation is sort of

106
00:03:49,599 --> 00:03:52,159
a key requirement

107
00:03:50,879 --> 00:03:55,359
for all networks i think we've talked

108
00:03:52,159 --> 00:03:57,679
about it in nanog over several years and

109
00:03:55,360 --> 00:03:59,439
you know lots of important reasons for

110
00:03:57,680 --> 00:04:01,680
automation and motivations

111
00:03:59,439 --> 00:04:04,239
obviously one around scale being able to

112
00:04:01,680 --> 00:04:06,239
grow the network without necessarily

113
00:04:04,239 --> 00:04:10,000
proportionally growing our engineering

114
00:04:06,239 --> 00:04:12,640
staff automation is enabler of that

115
00:04:10,000 --> 00:04:14,319
being able to deploy and stamp out

116
00:04:12,640 --> 00:04:15,518
designs and configurations in a

117
00:04:14,319 --> 00:04:17,680
consistent way

118
00:04:15,519 --> 00:04:19,840
to avoid introducing snowflakes into the

119
00:04:17,680 --> 00:04:20,959
network is another key motivation for

120
00:04:19,839 --> 00:04:23,440
automation

121
00:04:20,959 --> 00:04:24,720
and then of course well-programmed

122
00:04:23,440 --> 00:04:26,960
automation

123
00:04:24,720 --> 00:04:29,840
makes fewer mistakes typically than

124
00:04:26,960 --> 00:04:33,039
human engineers do so the correctness

125
00:04:29,840 --> 00:04:35,679
of repeated actions and so on can be um

126
00:04:33,040 --> 00:04:37,759
improved through automation and we often

127
00:04:35,680 --> 00:04:39,680
think of automation as being targeted at

128
00:04:37,759 --> 00:04:40,160
things like device turn ups or link turn

129
00:04:39,680 --> 00:04:42,320
ups

130
00:04:40,160 --> 00:04:44,400
uh configuration updates using

131
00:04:42,320 --> 00:04:45,199
automation to to set up monitoring or

132
00:04:44,400 --> 00:04:47,359
probing uh

133
00:04:45,199 --> 00:04:48,960
using automation to help us collect data

134
00:04:47,360 --> 00:04:50,080
to troubleshoot the network when things

135
00:04:48,960 --> 00:04:52,320
go wrong

136
00:04:50,080 --> 00:04:53,199
but as you get to sort of larger scale

137
00:04:52,320 --> 00:04:57,199
you see that

138
00:04:53,199 --> 00:04:59,280
um you know we need automation in

139
00:04:57,199 --> 00:05:00,400
a bunch of different aspects of managing

140
00:04:59,280 --> 00:05:01,919
the network

141
00:05:00,400 --> 00:05:03,599
including things like you know early

142
00:05:01,919 --> 00:05:05,680
stages of a network design in terms of

143
00:05:03,600 --> 00:05:07,919
forecasting and capacity planning

144
00:05:05,680 --> 00:05:09,360
turning those plans into you know maybe

145
00:05:07,919 --> 00:05:11,198
an abstract design and then a more

146
00:05:09,360 --> 00:05:14,479
detailed network design

147
00:05:11,199 --> 00:05:16,320
figuring out what is the set of physical

148
00:05:14,479 --> 00:05:17,919
infrastructure that we need to order and

149
00:05:16,320 --> 00:05:19,599
deploy

150
00:05:17,919 --> 00:05:20,960
you know we use automation also for

151
00:05:19,600 --> 00:05:23,199
informing the work that

152
00:05:20,960 --> 00:05:25,280
human engineers are doing for example on

153
00:05:23,199 --> 00:05:27,840
the data center floor when cabling

154
00:05:25,280 --> 00:05:30,000
a new data center fabric by providing

155
00:05:27,840 --> 00:05:31,919
them the information that they need

156
00:05:30,000 --> 00:05:33,280
in an automated way and then of course

157
00:05:31,919 --> 00:05:34,960
things that we mentioned before around

158
00:05:33,280 --> 00:05:38,880
configuration and monitoring

159
00:05:34,960 --> 00:05:40,880
and troubleshooting diagnosis so

160
00:05:38,880 --> 00:05:42,479
automation is key but to to do

161
00:05:40,880 --> 00:05:46,400
automation well um

162
00:05:42,479 --> 00:05:46,880
and safely we need precise and accurate

163
00:05:46,400 --> 00:05:49,679
data

164
00:05:46,880 --> 00:05:50,240
about the networks in question so for

165
00:05:49,680 --> 00:05:52,880
example

166
00:05:50,240 --> 00:05:54,960
you know we need precise data about

167
00:05:52,880 --> 00:05:56,800
connectivity plans at the abstract layer

168
00:05:54,960 --> 00:05:59,280
so for example you could imagine

169
00:05:56,800 --> 00:06:00,800
uh you know a model that captures

170
00:05:59,280 --> 00:06:03,679
information that is sort of

171
00:06:00,800 --> 00:06:05,199
the 12-month connectivity plan for

172
00:06:03,680 --> 00:06:08,560
capacity between

173
00:06:05,199 --> 00:06:10,639
various metros in the win a separate

174
00:06:08,560 --> 00:06:13,280
connectivity plan that reflects

175
00:06:10,639 --> 00:06:16,000
the existing network that's sort of

176
00:06:13,280 --> 00:06:19,758
fully concretized in terms of

177
00:06:16,000 --> 00:06:20,720
devices line cards links configuration

178
00:06:19,759 --> 00:06:23,120
um

179
00:06:20,720 --> 00:06:24,720
uh all of that um and then you get into

180
00:06:23,120 --> 00:06:26,000
further details that are represented in

181
00:06:24,720 --> 00:06:29,440
the model that enable

182
00:06:26,000 --> 00:06:31,680
automation around things like device and

183
00:06:29,440 --> 00:06:34,000
software controller configuration

184
00:06:31,680 --> 00:06:34,720
access control policies you know routing

185
00:06:34,000 --> 00:06:36,319
policies

186
00:06:34,720 --> 00:06:39,039
uh all the way down to ip address

187
00:06:36,319 --> 00:06:41,440
allocation and assignment

188
00:06:39,039 --> 00:06:43,280
that's captured in the model so we need

189
00:06:41,440 --> 00:06:45,440
automation basically to

190
00:06:43,280 --> 00:06:48,000
we need data rather to kind of drive

191
00:06:45,440 --> 00:06:51,039
automation across all of these different

192
00:06:48,000 --> 00:06:52,720
stages of the network design and

193
00:06:51,039 --> 00:06:54,560
deployment

194
00:06:52,720 --> 00:06:56,720
so that brings us to kind of the design

195
00:06:54,560 --> 00:07:00,000
of our network model so we call it

196
00:06:56,720 --> 00:07:01,680
multi-abstraction layer topology or malt

197
00:07:00,000 --> 00:07:03,840
we have a separate name internally and

198
00:07:01,680 --> 00:07:05,919
this is the one we're using externally

199
00:07:03,840 --> 00:07:08,000
this is google's internal sort of

200
00:07:05,919 --> 00:07:09,758
standard network representation

201
00:07:08,000 --> 00:07:11,440
uh for almost all of our networks at

202
00:07:09,759 --> 00:07:13,039
this point so it's taken us some years

203
00:07:11,440 --> 00:07:14,639
to get to adoption

204
00:07:13,039 --> 00:07:16,400
across all of these different network

205
00:07:14,639 --> 00:07:18,400
environments but now it's sort of

206
00:07:16,400 --> 00:07:19,758
uh part and parcel of all of the the

207
00:07:18,400 --> 00:07:21,520
networks that we run

208
00:07:19,759 --> 00:07:23,840
uh nearly all the networks that we run

209
00:07:21,520 --> 00:07:25,680
so it includes

210
00:07:23,840 --> 00:07:27,840
both i would say network topology

211
00:07:25,680 --> 00:07:28,960
connection of you know nodes and links

212
00:07:27,840 --> 00:07:30,799
in the network

213
00:07:28,960 --> 00:07:32,638
as well as what i'm more generally

214
00:07:30,800 --> 00:07:33,280
referring to as structure which is kind

215
00:07:32,639 --> 00:07:35,599
of

216
00:07:33,280 --> 00:07:36,719
um you know more abstract information

217
00:07:35,599 --> 00:07:38,719
about the network

218
00:07:36,720 --> 00:07:40,240
including things like configuration and

219
00:07:38,720 --> 00:07:41,840
something in some cases operational

220
00:07:40,240 --> 00:07:43,280
state of the network as well

221
00:07:41,840 --> 00:07:45,520
are all included in our network

222
00:07:43,280 --> 00:07:48,559
representation

223
00:07:45,520 --> 00:07:50,639
so the main function that it serves

224
00:07:48,560 --> 00:07:52,319
is interoperability between all the

225
00:07:50,639 --> 00:07:53,599
different automation and software

226
00:07:52,319 --> 00:07:56,080
systems that we have

227
00:07:53,599 --> 00:07:57,120
so having this common standard lets us

228
00:07:56,080 --> 00:07:59,359
build

229
00:07:57,120 --> 00:08:00,400
software that basically works against

230
00:07:59,360 --> 00:08:02,720
that standard

231
00:08:00,400 --> 00:08:04,000
and then any producers and consumers can

232
00:08:02,720 --> 00:08:06,400
use the same

233
00:08:04,000 --> 00:08:09,039
format to exchange data and i'll say a

234
00:08:06,400 --> 00:08:10,318
bit more about that in the next slide

235
00:08:09,039 --> 00:08:12,080
it supports multiple layers of

236
00:08:10,319 --> 00:08:15,520
abstraction so the model contains

237
00:08:12,080 --> 00:08:19,039
things like you know buildings and racks

238
00:08:15,520 --> 00:08:22,639
and even conduits all the way up to

239
00:08:19,039 --> 00:08:25,680
you know virtual abstract links

240
00:08:22,639 --> 00:08:27,919
and and virtual networking layers

241
00:08:25,680 --> 00:08:28,879
so it sort of spans uh all layers in

242
00:08:27,919 --> 00:08:32,000
between

243
00:08:28,879 --> 00:08:34,159
as well we've had to uh

244
00:08:32,000 --> 00:08:35,200
figure out how to make it extensible and

245
00:08:34,159 --> 00:08:36,718
evolvable

246
00:08:35,200 --> 00:08:38,560
this is something i'll talk a little bit

247
00:08:36,719 --> 00:08:40,880
more about later um

248
00:08:38,559 --> 00:08:42,159
you know as new use cases arrive and

249
00:08:40,880 --> 00:08:44,480
they come all the time

250
00:08:42,159 --> 00:08:45,920
um as far as use of the model you know

251
00:08:44,480 --> 00:08:48,720
being able to extend the

252
00:08:45,920 --> 00:08:50,319
the schema of the model and evolve um

253
00:08:48,720 --> 00:08:54,080
its ability to represent

254
00:08:50,320 --> 00:08:57,600
um various concepts and structure

255
00:08:54,080 --> 00:08:59,600
is key we've used it

256
00:08:57,600 --> 00:09:01,440
to implement network management systems

257
00:08:59,600 --> 00:09:02,720
that employ things like declarative

258
00:09:01,440 --> 00:09:04,320
network configuration i'll give an

259
00:09:02,720 --> 00:09:06,800
example of that

260
00:09:04,320 --> 00:09:08,000
and you know to be able to really make

261
00:09:06,800 --> 00:09:10,319
good use of it and to drive

262
00:09:08,000 --> 00:09:12,399
wide adoption we've had to build a

263
00:09:10,320 --> 00:09:14,560
fairly extensive software ecosystem

264
00:09:12,399 --> 00:09:16,399
to support it so it's not enough to just

265
00:09:14,560 --> 00:09:18,000
define the model and the schema

266
00:09:16,399 --> 00:09:23,440
there has to be a rich set of software

267
00:09:18,000 --> 00:09:25,200
around it to make it usable and useful

268
00:09:23,440 --> 00:09:26,959
okay so a little bit more about why we

269
00:09:25,200 --> 00:09:30,080
need a standard representation so

270
00:09:26,959 --> 00:09:31,839
before we had malt um it's not that we

271
00:09:30,080 --> 00:09:32,720
didn't have models before it's just that

272
00:09:31,839 --> 00:09:34,959
they were

273
00:09:32,720 --> 00:09:37,200
very bespoke to certain interactions

274
00:09:34,959 --> 00:09:38,880
between you know producers and consumers

275
00:09:37,200 --> 00:09:40,640
so there are sort of bilateral

276
00:09:38,880 --> 00:09:42,399
agreements between a producer and a

277
00:09:40,640 --> 00:09:44,959
consumer as to how

278
00:09:42,399 --> 00:09:46,560
data would be defined and exchanged and

279
00:09:44,959 --> 00:09:48,000
a lot of the information about the

280
00:09:46,560 --> 00:09:51,119
structure of the network

281
00:09:48,000 --> 00:09:52,640
was hidden in in code um

282
00:09:51,120 --> 00:09:54,880
so you know obviously a standard

283
00:09:52,640 --> 00:09:56,640
representation gives us this decoupling

284
00:09:54,880 --> 00:09:58,320
of producers and consumers so

285
00:09:56,640 --> 00:10:00,080
we try to capture all of the knowledge

286
00:09:58,320 --> 00:10:02,480
about the network in the data

287
00:10:00,080 --> 00:10:04,079
in the model itself rather than having

288
00:10:02,480 --> 00:10:06,399
it sitting in code

289
00:10:04,079 --> 00:10:09,120
and this allows us to also build a bunch

290
00:10:06,399 --> 00:10:11,519
of shared and common infrastructure

291
00:10:09,120 --> 00:10:12,720
which is sort of a key efficiency around

292
00:10:11,519 --> 00:10:14,800
that single standard

293
00:10:12,720 --> 00:10:15,760
so we don't need to then build

294
00:10:14,800 --> 00:10:18,479
additional

295
00:10:15,760 --> 00:10:20,480
very similar looking capabilities around

296
00:10:18,480 --> 00:10:22,800
n different standards for the network we

297
00:10:20,480 --> 00:10:24,720
can sort of focus on the single standard

298
00:10:22,800 --> 00:10:25,839
so this is a large motivation for sort

299
00:10:24,720 --> 00:10:27,600
of driving

300
00:10:25,839 --> 00:10:29,040
adoption of a single common network

301
00:10:27,600 --> 00:10:33,519
model across

302
00:10:29,040 --> 00:10:36,160
you know all of our networks

303
00:10:33,519 --> 00:10:38,079
so when we started this work our one of

304
00:10:36,160 --> 00:10:39,680
our main use cases or maybe the main use

305
00:10:38,079 --> 00:10:41,599
case was around

306
00:10:39,680 --> 00:10:44,000
building an intent driven configuration

307
00:10:41,600 --> 00:10:46,079
system and the reason why the model was

308
00:10:44,000 --> 00:10:48,240
so key is that the intent api that we

309
00:10:46,079 --> 00:10:51,760
had in mind here really was all about

310
00:10:48,240 --> 00:10:53,760
manipulating the model in order to drive

311
00:10:51,760 --> 00:10:56,480
configuration in a zero touch fashion of

312
00:10:53,760 --> 00:10:58,240
the network so this architecture

313
00:10:56,480 --> 00:10:59,920
sort of proceeds like this we have a

314
00:10:58,240 --> 00:11:01,360
bunch of workflows these are workflows

315
00:10:59,920 --> 00:11:04,479
that are doing things like

316
00:11:01,360 --> 00:11:06,640
device turn ups provisioning a new bgp

317
00:11:04,480 --> 00:11:10,000
peer external peer

318
00:11:06,640 --> 00:11:11,839
maybe adding capacity to a link

319
00:11:10,000 --> 00:11:13,680
and they work against this intent api

320
00:11:11,839 --> 00:11:16,160
and the intent api is basically an

321
00:11:13,680 --> 00:11:17,359
api that allows the workflow to

322
00:11:16,160 --> 00:11:20,399
manipulate

323
00:11:17,360 --> 00:11:22,160
or update a model of the network and

324
00:11:20,399 --> 00:11:25,040
then that model is used

325
00:11:22,160 --> 00:11:26,640
by the configuration generation system

326
00:11:25,040 --> 00:11:28,240
to basically generate the configuration

327
00:11:26,640 --> 00:11:29,839
needed to realize those updates

328
00:11:28,240 --> 00:11:31,920
and then they're finally validated and

329
00:11:29,839 --> 00:11:34,959
pushed to the network through

330
00:11:31,920 --> 00:11:36,800
an orchestration and config

331
00:11:34,959 --> 00:11:39,279
push block as shown here and also

332
00:11:36,800 --> 00:11:40,959
probably stored in a config database

333
00:11:39,279 --> 00:11:43,439
so the network model was the thing that

334
00:11:40,959 --> 00:11:45,599
allowed us to build this intent-based

335
00:11:43,440 --> 00:11:48,399
system where instead of directly

336
00:11:45,600 --> 00:11:49,200
manipulating device configurations we

337
00:11:48,399 --> 00:11:50,959
were

338
00:11:49,200 --> 00:11:52,480
having workflows manipulate a model it

339
00:11:50,959 --> 00:11:55,119
gives us a chance to validate those

340
00:11:52,480 --> 00:11:57,360
changes using the model

341
00:11:55,120 --> 00:11:59,120
and then uh have a representation that

342
00:11:57,360 --> 00:12:00,000
we could test before we actually push

343
00:11:59,120 --> 00:12:01,839
the network

344
00:12:00,000 --> 00:12:04,079
and then once we had the model you know

345
00:12:01,839 --> 00:12:07,200
a number of different use cases

346
00:12:04,079 --> 00:12:08,800
um became possible and uh it's perhaps

347
00:12:07,200 --> 00:12:09,600
no surprise you know we started doing

348
00:12:08,800 --> 00:12:11,680
things like

349
00:12:09,600 --> 00:12:13,519
using the model to implement various

350
00:12:11,680 --> 00:12:16,479
kinds of health checks maybe their

351
00:12:13,519 --> 00:12:18,000
health checks around you know uh bgp

352
00:12:16,480 --> 00:12:19,600
sessions being up or

353
00:12:18,000 --> 00:12:21,040
capacity health checks to make sure that

354
00:12:19,600 --> 00:12:21,920
capacity that has actually been

355
00:12:21,040 --> 00:12:24,399
provisioned

356
00:12:21,920 --> 00:12:25,599
and then drained for some reason is you

357
00:12:24,399 --> 00:12:28,560
know undrained uh

358
00:12:25,600 --> 00:12:29,839
correctly and in a timely way um we use

359
00:12:28,560 --> 00:12:31,839
the model to set up

360
00:12:29,839 --> 00:12:33,519
all of our device level monitoring so to

361
00:12:31,839 --> 00:12:34,959
understand which devices are there which

362
00:12:33,519 --> 00:12:36,959
devices are actually

363
00:12:34,959 --> 00:12:39,279
um appropriate to monitor is all

364
00:12:36,959 --> 00:12:41,599
captured in the model

365
00:12:39,279 --> 00:12:43,360
we use the model to figure out you know

366
00:12:41,600 --> 00:12:44,880
which peers are in sort of which

367
00:12:43,360 --> 00:12:46,160
different classes

368
00:12:44,880 --> 00:12:48,160
that we have and then use that for

369
00:12:46,160 --> 00:12:49,600
managing those peers

370
00:12:48,160 --> 00:12:51,360
and then we've introduced of course

371
00:12:49,600 --> 00:12:53,040
additional stages

372
00:12:51,360 --> 00:12:54,399
of the life cycle to the model so we

373
00:12:53,040 --> 00:12:55,519
started out with this model being

374
00:12:54,399 --> 00:12:58,639
primarily

375
00:12:55,519 --> 00:12:59,200
about the current um state of the

376
00:12:58,639 --> 00:13:00,720
network

377
00:12:59,200 --> 00:13:02,639
think of it as sort of the as built

378
00:13:00,720 --> 00:13:04,160
network if you will

379
00:13:02,639 --> 00:13:06,560
but then as we started thinking about

380
00:13:04,160 --> 00:13:08,800
using the model for also planning future

381
00:13:06,560 --> 00:13:10,638
versions of the network we added

382
00:13:08,800 --> 00:13:11,519
additional versions of the model to use

383
00:13:10,639 --> 00:13:14,959
for things like

384
00:13:11,519 --> 00:13:14,959
planning and high level design

385
00:13:15,279 --> 00:13:21,600
so some basics of the the malt

386
00:13:18,880 --> 00:13:22,639
design we use this notion of an entity

387
00:13:21,600 --> 00:13:24,880
relationship

388
00:13:22,639 --> 00:13:27,440
model so you know this shouldn't be

389
00:13:24,880 --> 00:13:28,560
confused with a relational database

390
00:13:27,440 --> 00:13:31,279
but if you're familiar with sort of

391
00:13:28,560 --> 00:13:32,959
database terms here so an entity

392
00:13:31,279 --> 00:13:34,880
relationship model is basically a way to

393
00:13:32,959 --> 00:13:36,160
represent things that might be real or

394
00:13:34,880 --> 00:13:38,880
abstract

395
00:13:36,160 --> 00:13:39,279
entities have a kind and they have a

396
00:13:38,880 --> 00:13:40,959
name

397
00:13:39,279 --> 00:13:42,560
entities have sets of attributes which

398
00:13:40,959 --> 00:13:44,079
i'll talk a little bit more about

399
00:13:42,560 --> 00:13:45,680
and then we use relationships to

400
00:13:44,079 --> 00:13:47,199
interconnect entities

401
00:13:45,680 --> 00:13:48,880
our relationships don't actually have

402
00:13:47,199 --> 00:13:51,519
any attributes themselves

403
00:13:48,880 --> 00:13:52,079
we capture all of the information within

404
00:13:51,519 --> 00:13:53,680
the

405
00:13:52,079 --> 00:13:56,399
entity and then the relationship just

406
00:13:53,680 --> 00:13:59,120
tells us how these entities actually

407
00:13:56,399 --> 00:14:00,720
go together so some examples of these

408
00:13:59,120 --> 00:14:02,079
real or concrete entities

409
00:14:00,720 --> 00:14:05,279
things that you might expect like

410
00:14:02,079 --> 00:14:09,040
routers um

411
00:14:05,279 --> 00:14:10,639
transceivers fibers machines buildings

412
00:14:09,040 --> 00:14:12,959
and then we have abstract entities like

413
00:14:10,639 --> 00:14:14,399
an entire

414
00:14:12,959 --> 00:14:16,079
multi-stage clone network an entire

415
00:14:14,399 --> 00:14:18,320
jupiter fabric in other words maybe a

416
00:14:16,079 --> 00:14:19,439
group of links that comprise a trunk

417
00:14:18,320 --> 00:14:21,920
and then we have lots of grouping

418
00:14:19,440 --> 00:14:23,360
constructs of all sorts that help us

419
00:14:21,920 --> 00:14:25,199
you know manage and reason about the

420
00:14:23,360 --> 00:14:27,199
network and then some example

421
00:14:25,199 --> 00:14:28,800
relationships are things like a contains

422
00:14:27,199 --> 00:14:30,479
relationship this is something we use

423
00:14:28,800 --> 00:14:32,800
quite often

424
00:14:30,480 --> 00:14:36,880
you know things like a rack contains a

425
00:14:32,800 --> 00:14:39,279
device a device contains a line card

426
00:14:36,880 --> 00:14:40,959
a network might contain another type of

427
00:14:39,279 --> 00:14:42,320
sub network

428
00:14:40,959 --> 00:14:44,079
another relationship we have is

429
00:14:42,320 --> 00:14:44,399
aggregate so this is used for things

430
00:14:44,079 --> 00:14:46,800
like

431
00:14:44,399 --> 00:14:48,000
uh link aggregation is the canonical

432
00:14:46,800 --> 00:14:50,079
example there where

433
00:14:48,000 --> 00:14:51,279
an aggregate link has an aggregates

434
00:14:50,079 --> 00:14:54,800
relationship with its

435
00:14:51,279 --> 00:14:57,839
um uh component links

436
00:14:54,800 --> 00:14:59,680
uh control relationships so in an sdn

437
00:14:57,839 --> 00:15:01,279
network for example we have controllers

438
00:14:59,680 --> 00:15:02,239
that have a controlled relationship

439
00:15:01,279 --> 00:15:05,120
over the network that they're

440
00:15:02,240 --> 00:15:07,040
responsible for configured on as another

441
00:15:05,120 --> 00:15:09,600
example so we have roughly

442
00:15:07,040 --> 00:15:10,800
about 250 different types of entities

443
00:15:09,600 --> 00:15:14,079
defined today

444
00:15:10,800 --> 00:15:15,199
in the model and around 20 relationships

445
00:15:14,079 --> 00:15:16,800
and i'll talk a little bit more about

446
00:15:15,199 --> 00:15:18,880
our kind of approach to

447
00:15:16,800 --> 00:15:20,399
how we grow or how we think about

448
00:15:18,880 --> 00:15:23,040
growing the set of entities versus

449
00:15:20,399 --> 00:15:23,040
relationships

450
00:15:24,240 --> 00:15:28,639
so here's a kind of trivial example it's

451
00:15:27,279 --> 00:15:29,680
trivial in what it's trying to represent

452
00:15:28,639 --> 00:15:31,279
but the example

453
00:15:29,680 --> 00:15:33,120
will end up not looking as trivial and

454
00:15:31,279 --> 00:15:34,720
i'll explain why so this is basically

455
00:15:33,120 --> 00:15:37,519
trying to represent a single

456
00:15:34,720 --> 00:15:38,959
layer three link between two routers so

457
00:15:37,519 --> 00:15:40,880
we have the

458
00:15:38,959 --> 00:15:42,000
ek stands for entity kind here so we

459
00:15:40,880 --> 00:15:44,880
have two

460
00:15:42,000 --> 00:15:46,639
entities routers on either end they each

461
00:15:44,880 --> 00:15:48,880
have a contains relationship

462
00:15:46,639 --> 00:15:50,880
this is the green arrows with interfaces

463
00:15:48,880 --> 00:15:52,720
so they contain this interface

464
00:15:50,880 --> 00:15:54,880
this interface has an originate

465
00:15:52,720 --> 00:15:56,639
terminate relationship with a logical

466
00:15:54,880 --> 00:15:59,360
packet link so we use logical packet

467
00:15:56,639 --> 00:16:01,519
link to represent certain l3 adjacency

468
00:15:59,360 --> 00:16:03,519
and you can see that this is sort of how

469
00:16:01,519 --> 00:16:05,360
we represent entities

470
00:16:03,519 --> 00:16:07,839
and relationships so the relationship as

471
00:16:05,360 --> 00:16:10,480
i said is the contains

472
00:16:07,839 --> 00:16:12,320
picture here and then if you build out

473
00:16:10,480 --> 00:16:14,320
the rest of this

474
00:16:12,320 --> 00:16:15,920
model you can see that we have you know

475
00:16:14,320 --> 00:16:16,560
an additional logical packet link

476
00:16:15,920 --> 00:16:18,399
because we

477
00:16:16,560 --> 00:16:21,119
represent links as unidirectional

478
00:16:18,399 --> 00:16:23,839
entities so we have you know

479
00:16:21,120 --> 00:16:25,440
two of them for every adjacency we also

480
00:16:23,839 --> 00:16:26,959
may want to represent the layer two

481
00:16:25,440 --> 00:16:28,320
adjacency which

482
00:16:26,959 --> 00:16:30,319
creates a relationship between the

483
00:16:28,320 --> 00:16:32,800
interface and the port

484
00:16:30,320 --> 00:16:34,160
uh that it traverses it uses a traverses

485
00:16:32,800 --> 00:16:35,839
relationship here

486
00:16:34,160 --> 00:16:38,480
um and then those similarly have

487
00:16:35,839 --> 00:16:40,160
originate terminate relationships with

488
00:16:38,480 --> 00:16:42,000
uh another entity which is called the

489
00:16:40,160 --> 00:16:43,759
physical packet link which represents

490
00:16:42,000 --> 00:16:46,480
the layer two adjacency

491
00:16:43,759 --> 00:16:48,079
so we have attributes in each of these

492
00:16:46,480 --> 00:16:48,720
entities which i'll give an example of

493
00:16:48,079 --> 00:16:50,959
and then

494
00:16:48,720 --> 00:16:52,399
these relationships are sort of uh bare

495
00:16:50,959 --> 00:16:53,279
in the sense that they just capture the

496
00:16:52,399 --> 00:16:56,480
relationship but

497
00:16:53,279 --> 00:16:57,759
and but no attributes so

498
00:16:56,480 --> 00:16:59,040
we need all of these entities and

499
00:16:57,759 --> 00:17:00,399
relationships and this isn't even the

500
00:16:59,040 --> 00:17:04,240
full set to

501
00:17:00,399 --> 00:17:05,839
capture a single um layer 3 adjacency

502
00:17:04,240 --> 00:17:07,760
and so you might think well boy this

503
00:17:05,839 --> 00:17:11,438
looks pretty complex um

504
00:17:07,760 --> 00:17:14,319
and too verbose but you know

505
00:17:11,439 --> 00:17:15,120
i guess the rationale is that really

506
00:17:14,319 --> 00:17:17,839
what we're building

507
00:17:15,119 --> 00:17:18,719
are systems that enable us to build

508
00:17:17,839 --> 00:17:20,240
software

509
00:17:18,720 --> 00:17:21,919
to kind of help automate the

510
00:17:20,240 --> 00:17:24,000
configuration and management

511
00:17:21,919 --> 00:17:26,160
of these things so you know we know that

512
00:17:24,000 --> 00:17:28,160
computers are really good at processing

513
00:17:26,160 --> 00:17:29,679
large scale graphs with potentially

514
00:17:28,160 --> 00:17:32,240
millions of entities

515
00:17:29,679 --> 00:17:33,360
and lots of relationships but software

516
00:17:32,240 --> 00:17:36,000
is really poor

517
00:17:33,360 --> 00:17:37,840
at figuring out what's actually going on

518
00:17:36,000 --> 00:17:39,520
you have to be super explicit provide as

519
00:17:37,840 --> 00:17:40,559
much detail as needed to get the right

520
00:17:39,520 --> 00:17:42,639
outcomes

521
00:17:40,559 --> 00:17:44,480
you know an engineer looking at a graph

522
00:17:42,640 --> 00:17:46,480
with some missing pieces

523
00:17:44,480 --> 00:17:47,840
can probably reason about what's missing

524
00:17:46,480 --> 00:17:50,960
and what's needed

525
00:17:47,840 --> 00:17:54,159
but computers can't do that so hence

526
00:17:50,960 --> 00:17:57,039
we have um uh focused on making the the

527
00:17:54,160 --> 00:17:57,919
model um as explicit as possible to

528
00:17:57,039 --> 00:18:01,200
enable

529
00:17:57,919 --> 00:18:03,440
uh software to kind of uh operate on it

530
00:18:01,200 --> 00:18:05,760
um and then we do have ways to represent

531
00:18:03,440 --> 00:18:07,440
these entities and relationships in text

532
00:18:05,760 --> 00:18:09,120
so that engineers can read them when we

533
00:18:07,440 --> 00:18:11,039
have to um

534
00:18:09,120 --> 00:18:13,120
but you know this isn't the normal way

535
00:18:11,039 --> 00:18:16,240
that we actually operate on the

536
00:18:13,120 --> 00:18:17,600
models and you know the text that i'm

537
00:18:16,240 --> 00:18:19,440
showing here represents

538
00:18:17,600 --> 00:18:20,719
about 80 percent of the previous diagram

539
00:18:19,440 --> 00:18:23,919
so it doesn't capture quite all of it

540
00:18:20,720 --> 00:18:27,520
but it captures quite a bit of it

541
00:18:23,919 --> 00:18:29,039
here's another example of a dwdm system

542
00:18:27,520 --> 00:18:30,720
if you're familiar you know these things

543
00:18:29,039 --> 00:18:33,280
have multiple layers of abstractions

544
00:18:30,720 --> 00:18:37,440
with different types of abstract links

545
00:18:33,280 --> 00:18:39,918
from odu down to oms and ots our

546
00:18:37,440 --> 00:18:41,840
our optical transport modeling captures

547
00:18:39,919 --> 00:18:43,520
things like terminal optic systems

548
00:18:41,840 --> 00:18:46,080
amplifiers rotoms

549
00:18:43,520 --> 00:18:47,039
all the different sort of fibers in

550
00:18:46,080 --> 00:18:48,879
between

551
00:18:47,039 --> 00:18:50,720
as well as these abstract links so the

552
00:18:48,880 --> 00:18:51,840
the abstractions are pretty extensive

553
00:18:50,720 --> 00:18:54,160
and detailed

554
00:18:51,840 --> 00:18:55,678
um and this is a good example that

555
00:18:54,160 --> 00:18:57,280
captures that

556
00:18:55,679 --> 00:19:00,480
and then the last example i'll show is

557
00:18:57,280 --> 00:19:02,080
um you know this is a simple switch

558
00:19:00,480 --> 00:19:03,919
topology where instead of a router we

559
00:19:02,080 --> 00:19:06,799
might have a packet switch entity

560
00:19:03,919 --> 00:19:07,600
it has a couple of layer two ports um

561
00:19:06,799 --> 00:19:09,440
that are

562
00:19:07,600 --> 00:19:11,039
again using the physical packet link to

563
00:19:09,440 --> 00:19:14,240
represent adjacencies

564
00:19:11,039 --> 00:19:17,440
um and there's also ports that are

565
00:19:14,240 --> 00:19:18,880
part of a machine maybe through a nic

566
00:19:17,440 --> 00:19:20,240
for example and the machines are

567
00:19:18,880 --> 00:19:22,640
connected into the

568
00:19:20,240 --> 00:19:23,280
ports on a switch using the relationship

569
00:19:22,640 --> 00:19:25,200
shown here

570
00:19:23,280 --> 00:19:27,200
so this is not that dissimilar from the

571
00:19:25,200 --> 00:19:30,000
l3 example it's just another

572
00:19:27,200 --> 00:19:31,760
uh example at the switching layer you

573
00:19:30,000 --> 00:19:35,440
know including things like uh

574
00:19:31,760 --> 00:19:35,440
machines and and server ports

575
00:19:35,679 --> 00:19:39,200
so as i mentioned entities have

576
00:19:37,840 --> 00:19:41,918
attributes that give us

577
00:19:39,200 --> 00:19:43,039
a way to express what the intended you

578
00:19:41,919 --> 00:19:46,320
know configuration

579
00:19:43,039 --> 00:19:48,160
and properties of that entity are

580
00:19:46,320 --> 00:19:50,639
for different points in the topology and

581
00:19:48,160 --> 00:19:52,400
then we also have a way to represent

582
00:19:50,640 --> 00:19:54,240
some state variables as well so this is

583
00:19:52,400 --> 00:19:55,919
a partial example for

584
00:19:54,240 --> 00:19:57,440
a port and an interface so the port is

585
00:19:55,919 --> 00:19:58,720
on the left and the interface is on the

586
00:19:57,440 --> 00:20:00,880
right here

587
00:19:58,720 --> 00:20:01,760
the red box captures the intent

588
00:20:00,880 --> 00:20:04,159
attributes

589
00:20:01,760 --> 00:20:06,480
things like names of the ports address

590
00:20:04,159 --> 00:20:08,960
assignments for v4 and v6

591
00:20:06,480 --> 00:20:10,400
um maybe the physical capacity that's

592
00:20:08,960 --> 00:20:13,120
intended on that

593
00:20:10,400 --> 00:20:14,320
uh port and then there's some observed

594
00:20:13,120 --> 00:20:16,080
attributes that might represent

595
00:20:14,320 --> 00:20:17,120
operational state these are things that

596
00:20:16,080 --> 00:20:19,120
could include

597
00:20:17,120 --> 00:20:20,320
things like packet drops that have been

598
00:20:19,120 --> 00:20:24,000
observed for example

599
00:20:20,320 --> 00:20:24,000
populated by a telemetry system

600
00:20:24,799 --> 00:20:27,840
uh so a little bit about the software

601
00:20:26,400 --> 00:20:30,720
ecosystem this is i mentioned that the

602
00:20:27,840 --> 00:20:33,678
outset is a very important part of

603
00:20:30,720 --> 00:20:35,520
malt's usage and adoption so we don't

604
00:20:33,679 --> 00:20:36,799
really get that far with just the entity

605
00:20:35,520 --> 00:20:39,679
relationship model

606
00:20:36,799 --> 00:20:41,600
um and the schema or the the definition

607
00:20:39,679 --> 00:20:42,320
of entities and relationships we need a

608
00:20:41,600 --> 00:20:45,439
way to

609
00:20:42,320 --> 00:20:48,000
for software to actually use the models

610
00:20:45,440 --> 00:20:49,600
so we built a fairly extensive set of

611
00:20:48,000 --> 00:20:50,880
libraries that support some common

612
00:20:49,600 --> 00:20:52,959
operations

613
00:20:50,880 --> 00:20:54,640
in terms of traversing the entity

614
00:20:52,960 --> 00:20:57,200
relationship graph

615
00:20:54,640 --> 00:20:59,360
abstracting some of the details out for

616
00:20:57,200 --> 00:21:01,360
consumers that don't need them

617
00:20:59,360 --> 00:21:03,280
we have a way to auto generate

618
00:21:01,360 --> 00:21:04,719
documentation from the schema oftentimes

619
00:21:03,280 --> 00:21:07,760
if you're new to the model

620
00:21:04,720 --> 00:21:10,000
being able to you know go quickly to a

621
00:21:07,760 --> 00:21:12,400
web page that has

622
00:21:10,000 --> 00:21:13,760
up-to-date auto-generated documentation

623
00:21:12,400 --> 00:21:15,760
about what the entity does what

624
00:21:13,760 --> 00:21:19,440
relationships it supports

625
00:21:15,760 --> 00:21:21,919
etc is is very useful we have some

626
00:21:19,440 --> 00:21:23,760
user interfaces that allow visualization

627
00:21:21,919 --> 00:21:26,559
of an entire network model

628
00:21:23,760 --> 00:21:28,000
as well as of uh you know particular

629
00:21:26,559 --> 00:21:29,678
schema things like we call them

630
00:21:28,000 --> 00:21:30,400
signature graphs that show the kind of

631
00:21:29,679 --> 00:21:31,919
key

632
00:21:30,400 --> 00:21:33,120
entities and relationships that are

633
00:21:31,919 --> 00:21:34,960
represented in a model without

634
00:21:33,120 --> 00:21:36,080
necessarily showing all of the instances

635
00:21:34,960 --> 00:21:37,919
of them

636
00:21:36,080 --> 00:21:39,918
we built a domain specific query

637
00:21:37,919 --> 00:21:40,320
language by domain specific here i mean

638
00:21:39,919 --> 00:21:41,919
that

639
00:21:40,320 --> 00:21:44,240
you know different network environments

640
00:21:41,919 --> 00:21:47,120
have different kinds of query

641
00:21:44,240 --> 00:21:48,320
requirements and so we have built a

642
00:21:47,120 --> 00:21:50,158
query language that

643
00:21:48,320 --> 00:21:52,399
runs across them but we have notions of

644
00:21:50,159 --> 00:21:53,200
things like can queries or predefined

645
00:21:52,400 --> 00:21:56,240
queries

646
00:21:53,200 --> 00:21:57,120
that are maybe specific to a specific

647
00:21:56,240 --> 00:22:00,000
network

648
00:21:57,120 --> 00:22:01,439
and then we have um of course a storage

649
00:22:00,000 --> 00:22:02,559
system for all of these models that

650
00:22:01,440 --> 00:22:05,520
we've defined

651
00:22:02,559 --> 00:22:07,120
uh that is sort of a key part of the

652
00:22:05,520 --> 00:22:08,799
infrastructure and is a

653
00:22:07,120 --> 00:22:12,158
common piece across all the different

654
00:22:08,799 --> 00:22:14,639
network models that we use

655
00:22:12,159 --> 00:22:16,720
so a little bit about queries um these

656
00:22:14,640 --> 00:22:17,919
models tend to get very large as you

657
00:22:16,720 --> 00:22:19,280
probably can guess looking at the

658
00:22:17,919 --> 00:22:21,600
earlier examples

659
00:22:19,280 --> 00:22:24,960
and most applications um let's take for

660
00:22:21,600 --> 00:22:26,959
example an application that's trying to

661
00:22:24,960 --> 00:22:28,559
build a configuration for a particular

662
00:22:26,960 --> 00:22:31,840
device or maybe a particular

663
00:22:28,559 --> 00:22:33,200
you know protocol uh obviously

664
00:22:31,840 --> 00:22:34,799
that application doesn't need the

665
00:22:33,200 --> 00:22:36,559
entirety of the model to be able to

666
00:22:34,799 --> 00:22:37,440
generate configuration for that device

667
00:22:36,559 --> 00:22:39,600
and its

668
00:22:37,440 --> 00:22:40,640
associated interfaces and ports it just

669
00:22:39,600 --> 00:22:43,678
needs basically a sub

670
00:22:40,640 --> 00:22:45,840
graph so we basically allow

671
00:22:43,679 --> 00:22:46,960
we build the query language to allow

672
00:22:45,840 --> 00:22:49,039
retrieval

673
00:22:46,960 --> 00:22:50,480
and traversal of small regions of the

674
00:22:49,039 --> 00:22:52,400
model rather than the entire

675
00:22:50,480 --> 00:22:53,760
graph and as i mentioned we have a query

676
00:22:52,400 --> 00:22:54,640
language that makes this reasonably

677
00:22:53,760 --> 00:22:56,480
efficient

678
00:22:54,640 --> 00:22:58,240
it's still fairly complex i would say

679
00:22:56,480 --> 00:23:00,080
not necessarily the easiest thing to

680
00:22:58,240 --> 00:23:02,000
learn and use just because

681
00:23:00,080 --> 00:23:04,080
it's hard to get the balance right we

682
00:23:02,000 --> 00:23:05,120
found between how expressive the query

683
00:23:04,080 --> 00:23:07,199
language is and

684
00:23:05,120 --> 00:23:08,879
you know how usable it is so this is

685
00:23:07,200 --> 00:23:10,559
where the can queries have come in so

686
00:23:08,880 --> 00:23:11,840
when we find a set of common queries

687
00:23:10,559 --> 00:23:14,480
that are used often by

688
00:23:11,840 --> 00:23:15,918
uh software systems uh we try to build

689
00:23:14,480 --> 00:23:17,760
those as predefined queries or

690
00:23:15,919 --> 00:23:18,799
parameterize queries that can be easily

691
00:23:17,760 --> 00:23:21,200
run

692
00:23:18,799 --> 00:23:21,840
by the software um and the can queries

693
00:23:21,200 --> 00:23:23,679
also are

694
00:23:21,840 --> 00:23:25,600
are more durable so even if we change

695
00:23:23,679 --> 00:23:28,320
the schema underneath or

696
00:23:25,600 --> 00:23:29,120
you know um move information in the

697
00:23:28,320 --> 00:23:31,678
model

698
00:23:29,120 --> 00:23:33,360
uh the can query can sort of stay

699
00:23:31,679 --> 00:23:35,840
unchanged and so the software

700
00:23:33,360 --> 00:23:36,879
of course stays unchanged while it still

701
00:23:35,840 --> 00:23:38,320
works with the model of course we have

702
00:23:36,880 --> 00:23:39,120
to change the implementation of the can

703
00:23:38,320 --> 00:23:42,158
query

704
00:23:39,120 --> 00:23:44,639
to handle the schema change you may be

705
00:23:42,159 --> 00:23:46,480
wondering why we didn't just use sql for

706
00:23:44,640 --> 00:23:47,840
these queries

707
00:23:46,480 --> 00:23:50,320
one of the reasons is that you know we

708
00:23:47,840 --> 00:23:52,240
do have a sql database underneath

709
00:23:50,320 --> 00:23:53,600
so the storage system is designed on

710
00:23:52,240 --> 00:23:57,440
spanner which i'll say more about

711
00:23:53,600 --> 00:24:01,279
uh which is a global

712
00:23:57,440 --> 00:24:04,720
geodistributed sql engine

713
00:24:01,279 --> 00:24:06,880
but we decouple the

714
00:24:04,720 --> 00:24:09,679
malt schema from the underlying sql

715
00:24:06,880 --> 00:24:12,240
schema and this allows us to also have

716
00:24:09,679 --> 00:24:14,000
clients only worry about the malt schema

717
00:24:12,240 --> 00:24:15,279
and not have to worry about changes to

718
00:24:14,000 --> 00:24:18,480
the sql schema

719
00:24:15,279 --> 00:24:20,159
in case we make a modifications to

720
00:24:18,480 --> 00:24:21,039
improve for example efficiency of how

721
00:24:20,159 --> 00:24:23,840
things are stored

722
00:24:21,039 --> 00:24:23,840
which we have done

723
00:24:24,640 --> 00:24:31,600
so a quick thing about storage as i said

724
00:24:28,080 --> 00:24:33,918
we call this malt shop in the paper

725
00:24:31,600 --> 00:24:35,360
malt shop is a single service so we

726
00:24:33,919 --> 00:24:37,120
don't build multiple storage systems

727
00:24:35,360 --> 00:24:37,678
we've built a single storage service for

728
00:24:37,120 --> 00:24:39,360
storing

729
00:24:37,679 --> 00:24:41,200
all of the models that we have across

730
00:24:39,360 --> 00:24:43,520
all of our networks so it's one high

731
00:24:41,200 --> 00:24:45,520
availability service

732
00:24:43,520 --> 00:24:47,440
it promotes sort of the sharing of

733
00:24:45,520 --> 00:24:49,200
models between systems in other words it

734
00:24:47,440 --> 00:24:51,360
acts as sort of a central clearinghouse

735
00:24:49,200 --> 00:24:53,200
of all the models that we've defined

736
00:24:51,360 --> 00:24:55,279
and it ensures that we have one place to

737
00:24:53,200 --> 00:24:58,799
go to go and find models that

738
00:24:55,279 --> 00:25:00,720
that you may need so malt shop has

739
00:24:58,799 --> 00:25:02,080
support for many many we call them

740
00:25:00,720 --> 00:25:03,440
shards in the paper you can think of

741
00:25:02,080 --> 00:25:06,320
them as essentially just

742
00:25:03,440 --> 00:25:08,559
models so for example we have a model of

743
00:25:06,320 --> 00:25:10,240
b4 we have a model of b2

744
00:25:08,559 --> 00:25:12,559
we have some models that are joined

745
00:25:10,240 --> 00:25:14,799
across some of these things

746
00:25:12,559 --> 00:25:15,678
to enable uh systems that need to reason

747
00:25:14,799 --> 00:25:17,360
about um

748
00:25:15,679 --> 00:25:19,279
network structure that crosses some of

749
00:25:17,360 --> 00:25:21,199
the network boundaries that we have

750
00:25:19,279 --> 00:25:23,279
the models have their own access control

751
00:25:21,200 --> 00:25:25,919
associated with them and they also have

752
00:25:23,279 --> 00:25:27,279
um immutable versioning semantics so in

753
00:25:25,919 --> 00:25:29,200
other words when you make a change to a

754
00:25:27,279 --> 00:25:29,600
model it creates a new version of the

755
00:25:29,200 --> 00:25:31,600
model

756
00:25:29,600 --> 00:25:32,959
using a copy on write mechanism so it's

757
00:25:31,600 --> 00:25:34,559
sort of space efficient

758
00:25:32,960 --> 00:25:36,080
but it gives you an easy way to sort of

759
00:25:34,559 --> 00:25:38,559
track changes using uh

760
00:25:36,080 --> 00:25:39,120
versions as they're as they're generated

761
00:25:38,559 --> 00:25:40,399
um

762
00:25:39,120 --> 00:25:42,959
as i said efficient support for

763
00:25:40,400 --> 00:25:44,159
incremental updates we use spanner

764
00:25:42,960 --> 00:25:46,240
underneath the covers

765
00:25:44,159 --> 00:25:47,840
to get a scale and geographic

766
00:25:46,240 --> 00:25:49,679
consistency so we get

767
00:25:47,840 --> 00:25:52,240
we solve some of these hard problems in

768
00:25:49,679 --> 00:25:56,559
terms of um

769
00:25:52,240 --> 00:25:58,480
consistency and and global scale um

770
00:25:56,559 --> 00:26:00,080
roughly for free in the sense that we're

771
00:25:58,480 --> 00:26:02,080
we're just building on top of a

772
00:26:00,080 --> 00:26:04,399
system that we have and you know

773
00:26:02,080 --> 00:26:07,279
currently we store thousands of models

774
00:26:04,400 --> 00:26:08,880
in malt shop each with you know millions

775
00:26:07,279 --> 00:26:11,679
of entities potentially

776
00:26:08,880 --> 00:26:12,080
um and and handling you know thousands

777
00:26:11,679 --> 00:26:16,080
of

778
00:26:12,080 --> 00:26:17,678
qps so

779
00:26:16,080 --> 00:26:19,520
in the last part of the talk i wanted to

780
00:26:17,679 --> 00:26:21,520
spend a little bit of time talking about

781
00:26:19,520 --> 00:26:22,639
lessons that we learned um i'll just

782
00:26:21,520 --> 00:26:24,000
quickly go through this list but we'll

783
00:26:22,640 --> 00:26:29,039
spend a bit more time on just

784
00:26:24,000 --> 00:26:30,559
a few of them schema design principles

785
00:26:29,039 --> 00:26:32,080
i'll say a bit more about this as well

786
00:26:30,559 --> 00:26:34,480
as schema evolution

787
00:26:32,080 --> 00:26:35,199
and using design pipelines as i

788
00:26:34,480 --> 00:26:36,960
mentioned

789
00:26:35,200 --> 00:26:38,880
near the beginning of the talk we use

790
00:26:36,960 --> 00:26:40,320
different models for different phases

791
00:26:38,880 --> 00:26:42,320
of the network so there's a notion of

792
00:26:40,320 --> 00:26:44,480
for example of an as built or

793
00:26:42,320 --> 00:26:46,399
you know as configured network and then

794
00:26:44,480 --> 00:26:48,960
we have you know networks

795
00:26:46,400 --> 00:26:51,039
models rather that are used in the

796
00:26:48,960 --> 00:26:53,600
course of planning

797
00:26:51,039 --> 00:26:55,600
capacity uh you know planning the design

798
00:26:53,600 --> 00:26:57,678
high level design and low level design

799
00:26:55,600 --> 00:26:59,279
and these are separate models altogether

800
00:26:57,679 --> 00:27:00,080
they use the same schema elements in

801
00:26:59,279 --> 00:27:02,400
many cases

802
00:27:00,080 --> 00:27:03,760
and they may use different schema

803
00:27:02,400 --> 00:27:04,400
elements to represent maybe more

804
00:27:03,760 --> 00:27:06,320
abstract

805
00:27:04,400 --> 00:27:08,080
entities as opposed to like the

806
00:27:06,320 --> 00:27:10,080
configured model which has

807
00:27:08,080 --> 00:27:11,600
you know a much more concretized uh

808
00:27:10,080 --> 00:27:15,520
version of the network

809
00:27:11,600 --> 00:27:16,959
um the challenge of migrating users as

810
00:27:15,520 --> 00:27:20,720
we change the model schema

811
00:27:16,960 --> 00:27:22,480
we consistently learning about how

812
00:27:20,720 --> 00:27:24,240
better ways to model things for example

813
00:27:22,480 --> 00:27:24,720
or less confusing ways to model things

814
00:27:24,240 --> 00:27:26,559
so

815
00:27:24,720 --> 00:27:27,760
the ability to change the schema is of

816
00:27:26,559 --> 00:27:30,720
course

817
00:27:27,760 --> 00:27:32,399
challenged by existing clients of the

818
00:27:30,720 --> 00:27:36,480
old schema and then migrating them onto

819
00:27:32,399 --> 00:27:39,120
a new one that's a really hard problem

820
00:27:36,480 --> 00:27:41,840
it's often tempting to put information

821
00:27:39,120 --> 00:27:43,918
into strings i think all of us probably

822
00:27:41,840 --> 00:27:44,879
have seen cases where there's

823
00:27:43,919 --> 00:27:47,520
information about

824
00:27:44,880 --> 00:27:49,919
an adjacency that's embedded in the

825
00:27:47,520 --> 00:27:51,600
description of a port for example

826
00:27:49,919 --> 00:27:53,200
and so you know the model gives us an

827
00:27:51,600 --> 00:27:55,199
opportunity to really get away from that

828
00:27:53,200 --> 00:27:57,120
sort of approach and

829
00:27:55,200 --> 00:27:58,640
introduce explicit attributes to capture

830
00:27:57,120 --> 00:28:00,000
that information rather than trying to

831
00:27:58,640 --> 00:28:01,520
put them in strings so

832
00:28:00,000 --> 00:28:03,279
we did have to do a little bit of

833
00:28:01,520 --> 00:28:04,720
cleanup to remove those cases from the

834
00:28:03,279 --> 00:28:05,440
model although we probably still have

835
00:28:04,720 --> 00:28:07,360
some

836
00:28:05,440 --> 00:28:08,559
um you know another hard lesson we

837
00:28:07,360 --> 00:28:11,279
learned is that we really should have

838
00:28:08,559 --> 00:28:13,039
used uuids i think for entities we've

839
00:28:11,279 --> 00:28:14,399
we started out by using human readable

840
00:28:13,039 --> 00:28:16,799
names for entities

841
00:28:14,399 --> 00:28:18,158
which made things a little bit more

842
00:28:16,799 --> 00:28:19,840
brittle um

843
00:28:18,159 --> 00:28:21,279
uh and we talked a little bit more about

844
00:28:19,840 --> 00:28:22,879
this in the paper i'd urge you to take a

845
00:28:21,279 --> 00:28:25,360
look if you're interested and then

846
00:28:22,880 --> 00:28:26,880
um you know maybe obvious but it's worth

847
00:28:25,360 --> 00:28:29,120
stating here is that

848
00:28:26,880 --> 00:28:31,440
the cleanest or most elegant schema will

849
00:28:29,120 --> 00:28:33,199
not save you if you don't have

850
00:28:31,440 --> 00:28:36,720
you know clean data to put into it right

851
00:28:33,200 --> 00:28:39,520
so populating the model

852
00:28:36,720 --> 00:28:40,960
with the data bootstrapping the model is

853
00:28:39,520 --> 00:28:42,080
a challenge that should be considered

854
00:28:40,960 --> 00:28:44,799
when you're

855
00:28:42,080 --> 00:28:46,240
attempting something like this um so

856
00:28:44,799 --> 00:28:48,480
i'll talk a little bit about

857
00:28:46,240 --> 00:28:49,279
these last few things and then um wrap

858
00:28:48,480 --> 00:28:51,760
up

859
00:28:49,279 --> 00:28:52,399
so schema design just quickly i'll say

860
00:28:51,760 --> 00:28:54,720
that you know

861
00:28:52,399 --> 00:28:55,439
we found that fewer entities doesn't

862
00:28:54,720 --> 00:28:57,840
make

863
00:28:55,440 --> 00:28:58,960
for a simpler model so we started out

864
00:28:57,840 --> 00:29:00,399
thinking that you know

865
00:28:58,960 --> 00:29:01,840
if there's too many entities it'll be

866
00:29:00,399 --> 00:29:03,439
hard for people to kind of look through

867
00:29:01,840 --> 00:29:03,918
this long list of entities and figure

868
00:29:03,440 --> 00:29:05,600
out

869
00:29:03,919 --> 00:29:07,039
how to capture what they're trying to

870
00:29:05,600 --> 00:29:09,439
model um

871
00:29:07,039 --> 00:29:10,080
but fewer entities actually resulted in

872
00:29:09,440 --> 00:29:11,679
us

873
00:29:10,080 --> 00:29:14,240
you know creating different types and

874
00:29:11,679 --> 00:29:17,039
overloading a particular entity

875
00:29:14,240 --> 00:29:18,640
um with too much information that then

876
00:29:17,039 --> 00:29:19,279
made it hard to reason about the right

877
00:29:18,640 --> 00:29:21,600
way to

878
00:29:19,279 --> 00:29:23,200
uh to do the modeling so our our kind of

879
00:29:21,600 --> 00:29:26,959
approach now is to

880
00:29:23,200 --> 00:29:28,880
um bias towards uh more entities

881
00:29:26,960 --> 00:29:30,240
that make explicit kind of what it is

882
00:29:28,880 --> 00:29:31,440
you're trying to model and the way that

883
00:29:30,240 --> 00:29:33,440
we make some of the

884
00:29:31,440 --> 00:29:35,840
these decisions is to think about

885
00:29:33,440 --> 00:29:37,600
orthogonality and separation of aspects

886
00:29:35,840 --> 00:29:39,039
orthogonality just means that

887
00:29:37,600 --> 00:29:40,639
if these two things that you're thinking

888
00:29:39,039 --> 00:29:41,840
about modeling and whether and trying to

889
00:29:40,640 --> 00:29:44,000
decide whether they should be in a

890
00:29:41,840 --> 00:29:45,439
single entity or separate entities

891
00:29:44,000 --> 00:29:47,120
if you look at the relationships of the

892
00:29:45,440 --> 00:29:48,960
two things independently

893
00:29:47,120 --> 00:29:50,320
and the attributes if there's a lot

894
00:29:48,960 --> 00:29:52,399
that's shared or common

895
00:29:50,320 --> 00:29:53,840
they probably should be the same entity

896
00:29:52,399 --> 00:29:56,158
maybe with some

897
00:29:53,840 --> 00:29:57,840
attributes that let you distinguish but

898
00:29:56,159 --> 00:29:59,200
if they really are mostly disjoint then

899
00:29:57,840 --> 00:30:00,080
they really ought to be in two different

900
00:29:59,200 --> 00:30:01,600
entities um

901
00:30:00,080 --> 00:30:03,918
maybe it seems like a straightforward

902
00:30:01,600 --> 00:30:04,959
idea but we did struggle with kind of

903
00:30:03,919 --> 00:30:06,480
figuring out

904
00:30:04,960 --> 00:30:08,000
uh whether it's best to create new

905
00:30:06,480 --> 00:30:11,360
entities or reuse existing

906
00:30:08,000 --> 00:30:13,200
ones um separation of aspects is some

907
00:30:11,360 --> 00:30:14,719
similar it just means uh essentially

908
00:30:13,200 --> 00:30:16,240
taking a very complex

909
00:30:14,720 --> 00:30:18,000
blob and instead of sticking it in a

910
00:30:16,240 --> 00:30:19,760
single entity separating it out and so

911
00:30:18,000 --> 00:30:21,919
an example of where we've done this is

912
00:30:19,760 --> 00:30:23,760
like in devices where we separate out

913
00:30:21,919 --> 00:30:25,919
data plane components from control plane

914
00:30:23,760 --> 00:30:28,399
components

915
00:30:25,919 --> 00:30:29,840
to make the uh the entities a bit more

916
00:30:28,399 --> 00:30:31,918
manageable

917
00:30:29,840 --> 00:30:33,439
we bias towards explicit relationships

918
00:30:31,919 --> 00:30:34,240
rather than name-based attributes so

919
00:30:33,440 --> 00:30:36,799
instead of sort of

920
00:30:34,240 --> 00:30:38,000
embedding attributes that identify what

921
00:30:36,799 --> 00:30:38,879
may be on the other end of a

922
00:30:38,000 --> 00:30:40,320
relationship

923
00:30:38,880 --> 00:30:43,440
we want to use the relationships

924
00:30:40,320 --> 00:30:44,799
directly um it makes the traversal and

925
00:30:43,440 --> 00:30:46,080
and retrieval easier there are some

926
00:30:44,799 --> 00:30:47,120
trade-offs though that we talk about in

927
00:30:46,080 --> 00:30:49,760
the paper

928
00:30:47,120 --> 00:30:51,840
um and we also found that you know

929
00:30:49,760 --> 00:30:55,440
relationship kinds don't always

930
00:30:51,840 --> 00:30:58,799
fit well so it contains or um

931
00:30:55,440 --> 00:31:01,039
uh traverses uh relationship for example

932
00:30:58,799 --> 00:31:02,960
it may not be always clear

933
00:31:01,039 --> 00:31:04,559
which relationship is the right to use

934
00:31:02,960 --> 00:31:06,080
right one to use to capture the concept

935
00:31:04,559 --> 00:31:09,200
that you're trying to model

936
00:31:06,080 --> 00:31:09,600
so it becomes critical to make sure that

937
00:31:09,200 --> 00:31:11,519
we're

938
00:31:09,600 --> 00:31:12,879
doing our best to use them consistently

939
00:31:11,519 --> 00:31:14,080
so that people when they're writing

940
00:31:12,880 --> 00:31:16,840
queries

941
00:31:14,080 --> 00:31:19,360
kind of can predict what they're gonna

942
00:31:16,840 --> 00:31:20,799
get um schema evolution

943
00:31:19,360 --> 00:31:22,799
you know this has been a hard thing we

944
00:31:20,799 --> 00:31:24,799
have um uh

945
00:31:22,799 --> 00:31:27,200
constantly been adding to the schema we

946
00:31:24,799 --> 00:31:28,879
use a few different ways to manage the

947
00:31:27,200 --> 00:31:31,519
evolution one of them is to have

948
00:31:28,880 --> 00:31:32,320
kind of a review board a set of experts

949
00:31:31,519 --> 00:31:35,279
who

950
00:31:32,320 --> 00:31:37,200
uh who kind of curate the model so

951
00:31:35,279 --> 00:31:39,279
proposals to add new concepts to the

952
00:31:37,200 --> 00:31:40,480
model new entity types etc go through

953
00:31:39,279 --> 00:31:42,159
this review board

954
00:31:40,480 --> 00:31:43,519
and our job in the review board is

955
00:31:42,159 --> 00:31:44,640
really to make sure that there's some

956
00:31:43,519 --> 00:31:47,039
consistency of

957
00:31:44,640 --> 00:31:47,760
of concept that we're not reinventing

958
00:31:47,039 --> 00:31:49,440
something that may

959
00:31:47,760 --> 00:31:51,039
be already in the model or not

960
00:31:49,440 --> 00:31:52,240
suggesting to reuse something where it's

961
00:31:51,039 --> 00:31:53,919
really more appropriate to create a

962
00:31:52,240 --> 00:31:55,840
separate entity those kinds of decisions

963
00:31:53,919 --> 00:31:57,679
are made in the review board

964
00:31:55,840 --> 00:31:58,879
we've introduced this notion of profiles

965
00:31:57,679 --> 00:32:02,000
to help

966
00:31:58,880 --> 00:32:03,919
define a constrained definition of a

967
00:32:02,000 --> 00:32:05,760
model to make it easier for producers

968
00:32:03,919 --> 00:32:08,399
and consumers to evolve so

969
00:32:05,760 --> 00:32:09,200
as you for example let's say we take the

970
00:32:08,399 --> 00:32:10,959
uh

971
00:32:09,200 --> 00:32:12,799
the cluster fabric or the data center

972
00:32:10,960 --> 00:32:14,000
fabric network and you know we've

973
00:32:12,799 --> 00:32:16,559
defined a sequence of

974
00:32:14,000 --> 00:32:17,360
profiles that you know have evolved the

975
00:32:16,559 --> 00:32:19,840
model but

976
00:32:17,360 --> 00:32:21,678
clients can write their software against

977
00:32:19,840 --> 00:32:24,158
a certain profile version

978
00:32:21,679 --> 00:32:25,600
and you know producers can make sure

979
00:32:24,159 --> 00:32:26,399
that when they produce a version of the

980
00:32:25,600 --> 00:32:27,918
model

981
00:32:26,399 --> 00:32:29,600
they're producing it according to a

982
00:32:27,919 --> 00:32:31,200
profile so that clients can have some

983
00:32:29,600 --> 00:32:32,639
predictability in what to expect in the

984
00:32:31,200 --> 00:32:34,240
model and the profile defines things

985
00:32:32,640 --> 00:32:35,039
like what entities what relationships

986
00:32:34,240 --> 00:32:38,240
are valid

987
00:32:35,039 --> 00:32:39,360
what attributes should be present um etc

988
00:32:38,240 --> 00:32:41,600
and then i already talked a little bit

989
00:32:39,360 --> 00:32:44,719
about can queries and i'll just

990
00:32:41,600 --> 00:32:48,000
say that you know abstraction uh

991
00:32:44,720 --> 00:32:48,880
is important and and easy but taxonomy

992
00:32:48,000 --> 00:32:50,799
in other words class

993
00:32:48,880 --> 00:32:53,279
classifying the different concepts into

994
00:32:50,799 --> 00:32:55,279
these modeling terms um

995
00:32:53,279 --> 00:32:56,320
is really hard even for people who are

996
00:32:55,279 --> 00:32:59,519
experts in the

997
00:32:56,320 --> 00:33:02,639
in the network uh structure

998
00:32:59,519 --> 00:33:04,559
and then lastly um you know we have

999
00:33:02,640 --> 00:33:06,640
bias towards this notion of a data flow

1000
00:33:04,559 --> 00:33:07,840
pipeline versus a database approach and

1001
00:33:06,640 --> 00:33:10,960
all that means is that

1002
00:33:07,840 --> 00:33:12,639
since we kind of build these different

1003
00:33:10,960 --> 00:33:14,480
versions or different types of models

1004
00:33:12,640 --> 00:33:17,200
and then versions within them

1005
00:33:14,480 --> 00:33:17,519
it becomes much easier to manage you

1006
00:33:17,200 --> 00:33:19,279
know

1007
00:33:17,519 --> 00:33:22,000
producer consumer interactions when you

1008
00:33:19,279 --> 00:33:22,559
have a data flow that basically says you

1009
00:33:22,000 --> 00:33:24,720
know some

1010
00:33:22,559 --> 00:33:27,039
high level design uh software system is

1011
00:33:24,720 --> 00:33:28,559
producing a high-level design model

1012
00:33:27,039 --> 00:33:30,240
there's some other lower level design

1013
00:33:28,559 --> 00:33:32,158
software system that can consume that

1014
00:33:30,240 --> 00:33:33,279
high-level design model and produce its

1015
00:33:32,159 --> 00:33:35,440
let's say low-level

1016
00:33:33,279 --> 00:33:37,279
lower level design uh model and then

1017
00:33:35,440 --> 00:33:40,080
there might be even another layer

1018
00:33:37,279 --> 00:33:42,000
let's say from layer three to layer one

1019
00:33:40,080 --> 00:33:43,678
that consumes the l3 model and can

1020
00:33:42,000 --> 00:33:46,240
produce the l1 model so

1021
00:33:43,679 --> 00:33:46,799
you know this clear ownership of who is

1022
00:33:46,240 --> 00:33:49,919
um

1023
00:33:46,799 --> 00:33:51,039
producing versus who's consuming um you

1024
00:33:49,919 --> 00:33:52,799
know there's clear

1025
00:33:51,039 --> 00:33:54,799
apis between the different software

1026
00:33:52,799 --> 00:33:56,240
systems in terms of the kind of model

1027
00:33:54,799 --> 00:33:58,480
they're expecting to get and the kind of

1028
00:33:56,240 --> 00:34:01,039
model that they're expecting to produce

1029
00:33:58,480 --> 00:34:02,640
it makes it much easier than this

1030
00:34:01,039 --> 00:34:04,960
approach for example where

1031
00:34:02,640 --> 00:34:06,000
it's much harder to kind of reason about

1032
00:34:04,960 --> 00:34:07,600
ownership of the data

1033
00:34:06,000 --> 00:34:09,520
it's much harder to create test

1034
00:34:07,600 --> 00:34:10,399
instances of data to test our software

1035
00:34:09,520 --> 00:34:11,918
systems

1036
00:34:10,399 --> 00:34:13,440
when you have all of it in a single

1037
00:34:11,918 --> 00:34:15,359
topology database and all of these

1038
00:34:13,440 --> 00:34:16,639
different systems are just accessing

1039
00:34:15,359 --> 00:34:18,560
the things that they think they need

1040
00:34:16,639 --> 00:34:20,240
from the topology database so we've

1041
00:34:18,560 --> 00:34:21,679
biased towards the left-hand side of

1042
00:34:20,239 --> 00:34:23,199
this picture which is more of a data

1043
00:34:21,679 --> 00:34:25,520
flow approach than the database for that

1044
00:34:23,199 --> 00:34:25,520
reason

1045
00:34:25,679 --> 00:34:29,359
so uh that brings us to the summary um

1046
00:34:28,480 --> 00:34:31,918
you know

1047
00:34:29,359 --> 00:34:34,000
a few quick things to to leave you with

1048
00:34:31,918 --> 00:34:36,879
uh you know we've seen that automation

1049
00:34:34,000 --> 00:34:38,719
requires um you know modeling at

1050
00:34:36,879 --> 00:34:40,480
multiple layers because automation is

1051
00:34:38,719 --> 00:34:42,480
operating at multiple layers all the way

1052
00:34:40,480 --> 00:34:43,839
from capacity planning and forecasting

1053
00:34:42,480 --> 00:34:47,918
you know down to

1054
00:34:43,839 --> 00:34:48,719
uh configuring every aspect of a network

1055
00:34:47,918 --> 00:34:50,879
um

1056
00:34:48,719 --> 00:34:51,918
you know the abstraction and taxonomy as

1057
00:34:50,879 --> 00:34:54,799
i as we mentioned

1058
00:34:51,918 --> 00:34:56,719
is is hard and it requires you know some

1059
00:34:54,800 --> 00:34:59,280
thinking about how to evolve

1060
00:34:56,719 --> 00:35:00,720
the uh model in a in a controlled in a

1061
00:34:59,280 --> 00:35:02,000
controlled way that makes it possible

1062
00:35:00,720 --> 00:35:04,640
for software to evolve with

1063
00:35:02,000 --> 00:35:06,640
it you know we couldn't get away with

1064
00:35:04,640 --> 00:35:07,920
just defining the data model we had to

1065
00:35:06,640 --> 00:35:10,799
build a fairly

1066
00:35:07,920 --> 00:35:12,480
complete software ecosystem around it

1067
00:35:10,800 --> 00:35:14,560
and you know as i said we've adopted

1068
00:35:12,480 --> 00:35:16,000
these network models across

1069
00:35:14,560 --> 00:35:17,680
almost all of our network management

1070
00:35:16,000 --> 00:35:19,599
automation at this point so it's it's

1071
00:35:17,680 --> 00:35:22,480
fairly well embedded into

1072
00:35:19,599 --> 00:35:23,680
our network operations um and then we

1073
00:35:22,480 --> 00:35:25,520
are using the models of course to

1074
00:35:23,680 --> 00:35:26,960
represent not just the current as built

1075
00:35:25,520 --> 00:35:29,520
version of the network but also

1076
00:35:26,960 --> 00:35:30,640
future versions such that we can model

1077
00:35:29,520 --> 00:35:32,880
the entire life cycle

1078
00:35:30,640 --> 00:35:34,240
not just the current running network so

1079
00:35:32,880 --> 00:35:35,839
with that thank you very much

1080
00:35:34,240 --> 00:35:36,990
for listening and i'll be happy to take

1081
00:35:35,839 --> 00:35:42,980
any questions

1082
00:35:36,990 --> 00:35:42,979
[Music]

1083
00:35:43,680 --> 00:35:47,598
so that was fabulous anise thank you so

1084
00:35:45,680 --> 00:35:49,200
much for providing us that information

1085
00:35:47,599 --> 00:35:51,359
we know that automation is one of the

1086
00:35:49,200 --> 00:35:53,040
most requested topics on the

1087
00:35:51,359 --> 00:35:54,560
nano surveys that we give and having the

1088
00:35:53,040 --> 00:35:56,320
overview of how you guys are

1089
00:35:54,560 --> 00:35:58,480
in one way that you guys are approaching

1090
00:35:56,320 --> 00:35:59,520
us is really valuable to nanak as a

1091
00:35:58,480 --> 00:36:01,119
community

1092
00:35:59,520 --> 00:36:02,560
so we definitely had a couple of

1093
00:36:01,119 --> 00:36:06,000
questions that came in

1094
00:36:02,560 --> 00:36:08,160
um the first one was from ernest he said

1095
00:36:06,000 --> 00:36:10,320
thank you for the presentation

1096
00:36:08,160 --> 00:36:13,839
i wanted to ask you the tool you use for

1097
00:36:10,320 --> 00:36:13,839
network capacity forecast

1098
00:36:14,400 --> 00:36:21,520
uh yeah um so network capacity planning

1099
00:36:18,720 --> 00:36:22,959
and forecasting um is all kind of um

1100
00:36:21,520 --> 00:36:24,480
it's an internal tool so it's not

1101
00:36:22,960 --> 00:36:26,400
something that we're using off the shelf

1102
00:36:24,480 --> 00:36:27,760
it's it's very tightly integrated with

1103
00:36:26,400 --> 00:36:30,000
our overall

1104
00:36:27,760 --> 00:36:31,680
uh kind of network optimization

1105
00:36:30,000 --> 00:36:34,720
framework which takes

1106
00:36:31,680 --> 00:36:36,480
you know traffic forecasts from our

1107
00:36:34,720 --> 00:36:38,240
different product areas

1108
00:36:36,480 --> 00:36:39,920
it takes information about the physical

1109
00:36:38,240 --> 00:36:43,200
infrastructure and the network structure

1110
00:36:39,920 --> 00:36:44,960
which comes from the malt models

1111
00:36:43,200 --> 00:36:46,960
information about failure rates and so

1112
00:36:44,960 --> 00:36:51,599
on and and costs of equipment

1113
00:36:46,960 --> 00:36:54,560
things like that and sort of produces

1114
00:36:51,599 --> 00:36:56,480
layer one and layer three topologies

1115
00:36:54,560 --> 00:37:00,000
along with their link capacities

1116
00:36:56,480 --> 00:37:01,520
um so we don't uh

1117
00:37:00,000 --> 00:37:03,839
like i said we we don't use something

1118
00:37:01,520 --> 00:37:06,079
that's kind of readily available

1119
00:37:03,839 --> 00:37:07,279
we've spent actually quite a bit of time

1120
00:37:06,079 --> 00:37:09,760
iterating through

1121
00:37:07,280 --> 00:37:11,119
our capacity planning and and um

1122
00:37:09,760 --> 00:37:14,880
optimization

1123
00:37:11,119 --> 00:37:16,000
uh pipeline um so in relation to this

1124
00:37:14,880 --> 00:37:18,800
talk i'll just say that

1125
00:37:16,000 --> 00:37:19,760
you know those systems all use malt as

1126
00:37:18,800 --> 00:37:22,079
one of their key

1127
00:37:19,760 --> 00:37:23,599
um both inputs and insert interchange

1128
00:37:22,079 --> 00:37:25,359
formats between different stages of the

1129
00:37:23,599 --> 00:37:27,680
optimization so in that sense

1130
00:37:25,359 --> 00:37:29,520
it's quite tightly coupled um to what we

1131
00:37:27,680 --> 00:37:30,960
talked about here today

1132
00:37:29,520 --> 00:37:32,480
i'm sorry i can't say too much about it

1133
00:37:30,960 --> 00:37:33,680
just because it's an internal system i'm

1134
00:37:32,480 --> 00:37:34,720
not sure how useful it would be to get

1135
00:37:33,680 --> 00:37:37,759
into too much detail

1136
00:37:34,720 --> 00:37:38,799
um there that makes sense

1137
00:37:37,760 --> 00:37:41,520
thank you for that answer though what

1138
00:37:38,800 --> 00:37:44,000
you could provide so gordon asked

1139
00:37:41,520 --> 00:37:45,759
hey anis do you recommend that a system

1140
00:37:44,000 --> 00:37:47,920
similar to malt can be implemented in a

1141
00:37:45,760 --> 00:37:49,359
network ecosystem like google's

1142
00:37:47,920 --> 00:37:51,599
meaning not every single bit of the

1143
00:37:49,359 --> 00:37:55,200
network stack is deployed and maintained

1144
00:37:51,599 --> 00:37:56,640
by the same org uh

1145
00:37:55,200 --> 00:37:58,480
yeah that's an interesting question i

1146
00:37:56,640 --> 00:37:59,759
mean i i think that

1147
00:37:58,480 --> 00:38:01,040
google is big enough with enough

1148
00:37:59,760 --> 00:38:02,560
different teams working on different

1149
00:38:01,040 --> 00:38:03,839
parts of the network that it often feels

1150
00:38:02,560 --> 00:38:04,799
like it's different organizations

1151
00:38:03,839 --> 00:38:05,759
working on different parts of the

1152
00:38:04,800 --> 00:38:07,280
network and

1153
00:38:05,760 --> 00:38:09,440
in fact this is one of the key reasons

1154
00:38:07,280 --> 00:38:12,000
why we came up with a common schema like

1155
00:38:09,440 --> 00:38:13,839
malt in the first place to enable

1156
00:38:12,000 --> 00:38:16,880
a common language for talking about the

1157
00:38:13,839 --> 00:38:20,240
network structure and its attributes so

1158
00:38:16,880 --> 00:38:22,079
it's proven extremely uh valuable to

1159
00:38:20,240 --> 00:38:23,200
have a common interchange format that

1160
00:38:22,079 --> 00:38:24,800
lets

1161
00:38:23,200 --> 00:38:26,319
you know what what are essentially

1162
00:38:24,800 --> 00:38:28,880
different organizations

1163
00:38:26,320 --> 00:38:30,960
um exchange information so if you were

1164
00:38:28,880 --> 00:38:32,720
now extending that to let's say beyond a

1165
00:38:30,960 --> 00:38:36,480
single company

1166
00:38:32,720 --> 00:38:38,240
um then we can say that uh

1167
00:38:36,480 --> 00:38:40,320
same thing applies right if we've in

1168
00:38:38,240 --> 00:38:43,359
fact contemplated how we might

1169
00:38:40,320 --> 00:38:45,520
expose parts of malt or maybe

1170
00:38:43,359 --> 00:38:47,040
a modified version of malt um to let's

1171
00:38:45,520 --> 00:38:49,359
say external customers where they could

1172
00:38:47,040 --> 00:38:52,320
describe things like virtual topologies

1173
00:38:49,359 --> 00:38:54,560
using that and have it consumed by some

1174
00:38:52,320 --> 00:38:56,960
of our provisioning systems for example

1175
00:38:54,560 --> 00:38:58,240
um and so there's some benefit to having

1176
00:38:56,960 --> 00:38:59,119
you know this common interchange so i

1177
00:38:58,240 --> 00:39:00,959
think

1178
00:38:59,119 --> 00:39:03,440
it does apply to organizations that

1179
00:39:00,960 --> 00:39:05,280
aren't like google in fact we use it

1180
00:39:03,440 --> 00:39:06,320
across different teams that are building

1181
00:39:05,280 --> 00:39:07,599
different parts of the network

1182
00:39:06,320 --> 00:39:08,480
especially where the scenes of the

1183
00:39:07,599 --> 00:39:10,480
network

1184
00:39:08,480 --> 00:39:12,320
um are where things come together and

1185
00:39:10,480 --> 00:39:16,079
you need a common way of expressing

1186
00:39:12,320 --> 00:39:16,079
uh what's on either side of that scene

1187
00:39:17,119 --> 00:39:23,280
okay thank you so tony asked

1188
00:39:20,880 --> 00:39:24,720
how do you think or handle temporal

1189
00:39:23,280 --> 00:39:26,240
issues for instance

1190
00:39:24,720 --> 00:39:28,240
labeling things as future versus

1191
00:39:26,240 --> 00:39:31,598
president present or even past

1192
00:39:28,240 --> 00:39:34,160
and um state intent that's temporary

1193
00:39:31,599 --> 00:39:35,520
so for example a link that's been costed

1194
00:39:34,160 --> 00:39:36,480
off intentionally during a maintenance

1195
00:39:35,520 --> 00:39:40,079
which means it's

1196
00:39:36,480 --> 00:39:43,359
in the correct intent but short term

1197
00:39:40,079 --> 00:39:44,960
yeah great question um we basically

1198
00:39:43,359 --> 00:39:45,359
evolved the model as i mentioned in the

1199
00:39:44,960 --> 00:39:48,640
talk

1200
00:39:45,359 --> 00:39:51,359
um you know we do use uh

1201
00:39:48,640 --> 00:39:52,960
models for different stages of of design

1202
00:39:51,359 --> 00:39:54,880
and deployment so

1203
00:39:52,960 --> 00:39:56,400
one simple example is you know we use

1204
00:39:54,880 --> 00:39:57,680
entirely different models for example to

1205
00:39:56,400 --> 00:39:59,839
represent the network at

1206
00:39:57,680 --> 00:40:01,040
um you know three months out six months

1207
00:39:59,839 --> 00:40:03,040
out twelve months out

1208
00:40:01,040 --> 00:40:04,960
and then a different version of the

1209
00:40:03,040 --> 00:40:06,400
model or even a different schema to

1210
00:40:04,960 --> 00:40:10,079
something to a large extent

1211
00:40:06,400 --> 00:40:10,800
that represents um the as built model or

1212
00:40:10,079 --> 00:40:14,880
the currently

1213
00:40:10,800 --> 00:40:16,960
uh configured model uh network rather

1214
00:40:14,880 --> 00:40:18,480
we also use this mechanism called entity

1215
00:40:16,960 --> 00:40:20,240
states where

1216
00:40:18,480 --> 00:40:21,839
suppose you have an entity like a device

1217
00:40:20,240 --> 00:40:23,598
it goes through its own life cycle in

1218
00:40:21,839 --> 00:40:25,279
terms of its

1219
00:40:23,599 --> 00:40:28,079
its turn up when it's just part of a

1220
00:40:25,280 --> 00:40:30,079
design then it becomes

1221
00:40:28,079 --> 00:40:32,319
provisioned like installed actually

1222
00:40:30,079 --> 00:40:33,680
instantiated somewhere physically

1223
00:40:32,319 --> 00:40:36,000
then it becomes provisioned with its

1224
00:40:33,680 --> 00:40:37,759
initial configuration then finally maybe

1225
00:40:36,000 --> 00:40:39,359
it's ready to start serving traffic so

1226
00:40:37,760 --> 00:40:41,040
we actually label entities that go

1227
00:40:39,359 --> 00:40:42,720
through that kind of life cycle

1228
00:40:41,040 --> 00:40:44,640
with this notion of entity states so

1229
00:40:42,720 --> 00:40:46,319
that a consuming software system

1230
00:40:44,640 --> 00:40:48,400
can sort of see where in the life cycle

1231
00:40:46,319 --> 00:40:50,160
of particular devices

1232
00:40:48,400 --> 00:40:51,520
the last part of the question around

1233
00:40:50,160 --> 00:40:54,160
maintenance

1234
00:40:51,520 --> 00:40:56,000
is interesting also so we tend to um at

1235
00:40:54,160 --> 00:40:59,440
least for our b2 network

1236
00:40:56,000 --> 00:41:01,200
uh tend to reflect the um temporary

1237
00:40:59,440 --> 00:41:02,000
states in the as built model as well so

1238
00:41:01,200 --> 00:41:04,480
in other words

1239
00:41:02,000 --> 00:41:06,160
suppose that we take some link offline

1240
00:41:04,480 --> 00:41:08,880
because it's under maintenance or we

1241
00:41:06,160 --> 00:41:09,598
have drained um you know line card on a

1242
00:41:08,880 --> 00:41:11,839
device

1243
00:41:09,599 --> 00:41:13,440
some ports aren't available um they'll

1244
00:41:11,839 --> 00:41:15,680
be marked as such in the model so that

1245
00:41:13,440 --> 00:41:19,119
any system that's going to let's say

1246
00:41:15,680 --> 00:41:20,799
um run a workflow where it depends on

1247
00:41:19,119 --> 00:41:23,440
that link being available or the or the

1248
00:41:20,800 --> 00:41:25,119
device device's current status can

1249
00:41:23,440 --> 00:41:27,680
use the model to see what the current

1250
00:41:25,119 --> 00:41:28,960
state is so we do capture some of that

1251
00:41:27,680 --> 00:41:30,720
in the as built model

1252
00:41:28,960 --> 00:41:32,880
in those cases so i would say we have a

1253
00:41:30,720 --> 00:41:35,279
few different mechanisms for handling

1254
00:41:32,880 --> 00:41:36,000
temporal concerns one is just different

1255
00:41:35,280 --> 00:41:37,440
versions

1256
00:41:36,000 --> 00:41:39,040
and even schemas of the model that

1257
00:41:37,440 --> 00:41:41,520
represent the network at different

1258
00:41:39,040 --> 00:41:43,680
points overall life cycle and then we

1259
00:41:41,520 --> 00:41:45,359
have entities themselves like devices

1260
00:41:43,680 --> 00:41:45,919
links etc that have their own entity

1261
00:41:45,359 --> 00:41:50,000
state

1262
00:41:45,920 --> 00:41:52,480
that tracks its life cycle over time

1263
00:41:50,000 --> 00:41:54,640
and then we you know do represent some

1264
00:41:52,480 --> 00:41:56,640
forms of operational state like the

1265
00:41:54,640 --> 00:41:57,680
whether a particular entity is drained

1266
00:41:56,640 --> 00:42:02,720
for example

1267
00:41:57,680 --> 00:42:05,759
um in the uh as built model itself

1268
00:42:02,720 --> 00:42:08,959
okay that makes sense thank you so paul

1269
00:42:05,760 --> 00:42:10,319
asked well he said great talk amis uh he

1270
00:42:08,960 --> 00:42:12,160
asked can you share the size of the

1271
00:42:10,319 --> 00:42:14,079
teams working on malt the pieces you

1272
00:42:12,160 --> 00:42:16,000
focused on first and how long it took

1273
00:42:14,079 --> 00:42:19,440
from the initial concept

1274
00:42:16,000 --> 00:42:20,240
to having a mvp of the most valuable

1275
00:42:19,440 --> 00:42:23,839
player of

1276
00:42:20,240 --> 00:42:26,959
the ecosystem yeah so

1277
00:42:23,839 --> 00:42:28,880
getting to an mvp um probably i guess

1278
00:42:26,960 --> 00:42:32,720
when i joined uh

1279
00:42:28,880 --> 00:42:34,880
google in it was uh beginning of 2014

1280
00:42:32,720 --> 00:42:36,879
and malt was already kind of

1281
00:42:34,880 --> 00:42:38,400
conceptualized by that point

1282
00:42:36,880 --> 00:42:40,160
but the focus was a little bit different

1283
00:42:38,400 --> 00:42:41,040
so as i mentioned our initial use case

1284
00:42:40,160 --> 00:42:43,279
was around

1285
00:42:41,040 --> 00:42:44,720
configuration management and so we

1286
00:42:43,280 --> 00:42:45,920
started really building out the schema

1287
00:42:44,720 --> 00:42:49,118
to support

1288
00:42:45,920 --> 00:42:49,680
an intent based configuration um scheme

1289
00:42:49,119 --> 00:42:51,920
around

1290
00:42:49,680 --> 00:42:53,279
you know that time and it took us i

1291
00:42:51,920 --> 00:42:57,200
would say

1292
00:42:53,280 --> 00:42:58,880
probably um eight months or a year eight

1293
00:42:57,200 --> 00:43:00,480
to twelve months to get to a point where

1294
00:42:58,880 --> 00:43:02,720
we had something that could actually be

1295
00:43:00,480 --> 00:43:04,880
used by these consuming systems

1296
00:43:02,720 --> 00:43:07,200
um so it took quite a bit of time and

1297
00:43:04,880 --> 00:43:08,880
incrementally building it over time so

1298
00:43:07,200 --> 00:43:10,319
for example having a complete model that

1299
00:43:08,880 --> 00:43:12,640
allows you to represent the entirety of

1300
00:43:10,319 --> 00:43:15,119
configuration in a network as complex as

1301
00:43:12,640 --> 00:43:17,200
b2 our user facing backbone

1302
00:43:15,119 --> 00:43:19,040
did take us some time the size of the

1303
00:43:17,200 --> 00:43:20,000
team has grown also considerably so i

1304
00:43:19,040 --> 00:43:22,720
would say that

1305
00:43:20,000 --> 00:43:23,839
um you know we still have a relatively

1306
00:43:22,720 --> 00:43:26,720
small team

1307
00:43:23,839 --> 00:43:28,480
managing kind of the core schema itself

1308
00:43:26,720 --> 00:43:28,959
i happen to sit on the review board i

1309
00:43:28,480 --> 00:43:31,680
mentioned

1310
00:43:28,960 --> 00:43:33,440
and there's you know half a dozen of us

1311
00:43:31,680 --> 00:43:34,000
representatives from different parts of

1312
00:43:33,440 --> 00:43:37,440
the

1313
00:43:34,000 --> 00:43:37,920
um organization you know that work on

1314
00:43:37,440 --> 00:43:39,119
different

1315
00:43:37,920 --> 00:43:41,599
network environments that are

1316
00:43:39,119 --> 00:43:43,359
representing kind of um

1317
00:43:41,599 --> 00:43:44,800
the perspectives of each different

1318
00:43:43,359 --> 00:43:46,240
consumer so that when this

1319
00:43:44,800 --> 00:43:48,319
as a schema evolves we can still

1320
00:43:46,240 --> 00:43:50,959
rationalize about them

1321
00:43:48,319 --> 00:43:52,240
the development team is sort of split

1322
00:43:50,960 --> 00:43:54,240
into different sections so we have a

1323
00:43:52,240 --> 00:43:56,799
development team that's devoted to

1324
00:43:54,240 --> 00:43:58,640
primarily use cases tools a lot of the

1325
00:43:56,800 --> 00:44:01,760
development work is around the libraries

1326
00:43:58,640 --> 00:44:03,598
the query support the all the software

1327
00:44:01,760 --> 00:44:04,880
systems that go with the schema itself

1328
00:44:03,599 --> 00:44:07,680
not necessarily with

1329
00:44:04,880 --> 00:44:09,520
malt the core of malt and those teams i

1330
00:44:07,680 --> 00:44:12,879
would say on the order of

1331
00:44:09,520 --> 00:44:14,160
you know probably 15 to 30 people um

1332
00:44:12,880 --> 00:44:16,400
you know for our data center fabrics

1333
00:44:14,160 --> 00:44:18,078
with a very complex models and

1334
00:44:16,400 --> 00:44:19,839
maybe a little bit less than that on in

1335
00:44:18,079 --> 00:44:21,599
other parts of the network but the core

1336
00:44:19,839 --> 00:44:24,319
team that maintains the schema

1337
00:44:21,599 --> 00:44:26,800
and the core schema tools the

1338
00:44:24,319 --> 00:44:28,400
visualization the storage system etc

1339
00:44:26,800 --> 00:44:30,079
um i would say it's probably on the

1340
00:44:28,400 --> 00:44:32,240
order of uh

1341
00:44:30,079 --> 00:44:33,839
or 10 people roughly maybe less than

1342
00:44:32,240 --> 00:44:37,040
that

1343
00:44:33,839 --> 00:44:38,078
gotcha thank you so tom asked uh if you

1344
00:44:37,040 --> 00:44:39,759
could post a link

1345
00:44:38,079 --> 00:44:41,440
for the paper you mentioned that goes

1346
00:44:39,760 --> 00:44:42,960
deeper into the topic and i

1347
00:44:41,440 --> 00:44:45,359
i'm not maybe already did that actually

1348
00:44:42,960 --> 00:44:46,480
in the in the chat room yeah happy to um

1349
00:44:45,359 --> 00:44:48,160
i will add that and

1350
00:44:46,480 --> 00:44:50,000
i was kind of hoping the slides would be

1351
00:44:48,160 --> 00:44:51,598
available at the time of the talk so i

1352
00:44:50,000 --> 00:44:53,599
did put a link to the paper on the front

1353
00:44:51,599 --> 00:44:55,280
page of the slides also just fyi so when

1354
00:44:53,599 --> 00:44:56,079
those become available you can get them

1355
00:44:55,280 --> 00:44:59,200
there as well

1356
00:44:56,079 --> 00:44:59,200
um thank you

1357
00:44:59,440 --> 00:45:03,119
okay so chris asked what modeling

1358
00:45:01,760 --> 00:45:07,359
language did you use and

1359
00:45:03,119 --> 00:45:11,040
is it published um

1360
00:45:07,359 --> 00:45:11,040
the modeling language is sort of

1361
00:45:12,079 --> 00:45:16,800
we basically represent the schema as as

1362
00:45:14,240 --> 00:45:18,640
protobufs internally so

1363
00:45:16,800 --> 00:45:19,920
we don't use a separate modeling we

1364
00:45:18,640 --> 00:45:21,279
don't we didn't define a new

1365
00:45:19,920 --> 00:45:23,040
domain-specific language

1366
00:45:21,280 --> 00:45:24,480
um just for the model we basically

1367
00:45:23,040 --> 00:45:26,160
defined the schema

1368
00:45:24,480 --> 00:45:27,760
as a set of protobufs and that allowed

1369
00:45:26,160 --> 00:45:28,640
us to use a lot of our tools and

1370
00:45:27,760 --> 00:45:30,079
especially

1371
00:45:28,640 --> 00:45:31,680
you know tools across different

1372
00:45:30,079 --> 00:45:34,800
languages

1373
00:45:31,680 --> 00:45:37,359
you know to work with the models we get

1374
00:45:34,800 --> 00:45:40,079
asked a lot about open sourcing

1375
00:45:37,359 --> 00:45:42,078
the models and the tools um you know at

1376
00:45:40,079 --> 00:45:43,920
this point i think the ideas around

1377
00:45:42,079 --> 00:45:45,920
malt are probably quite valuable for the

1378
00:45:43,920 --> 00:45:46,319
external community the problem is that

1379
00:45:45,920 --> 00:45:48,079
the

1380
00:45:46,319 --> 00:45:49,599
specific implementation and even the

1381
00:45:48,079 --> 00:45:51,280
schema that we have is

1382
00:45:49,599 --> 00:45:53,599
so tightly coupled to google's network

1383
00:45:51,280 --> 00:45:55,920
infrastructure and our network structure

1384
00:45:53,599 --> 00:45:57,359
that it becomes hard to disentangle you

1385
00:45:55,920 --> 00:45:58,560
know kind of the core schema elements

1386
00:45:57,359 --> 00:46:00,160
from

1387
00:45:58,560 --> 00:46:02,160
some of the specifics that we have in

1388
00:46:00,160 --> 00:46:04,640
our environment uh

1389
00:46:02,160 --> 00:46:05,440
so i think it's a significant um amount

1390
00:46:04,640 --> 00:46:07,040
of effort

1391
00:46:05,440 --> 00:46:08,319
but one that we are interested in and

1392
00:46:07,040 --> 00:46:09,599
we're still trying to figure out how

1393
00:46:08,319 --> 00:46:11,599
best we can

1394
00:46:09,599 --> 00:46:12,800
make some of this available externally

1395
00:46:11,599 --> 00:46:14,160
but right now i

1396
00:46:12,800 --> 00:46:16,560
unfortunately don't have a lot more to

1397
00:46:14,160 --> 00:46:17,040
say about plans to to make it available

1398
00:46:16,560 --> 00:46:21,200
um

1399
00:46:17,040 --> 00:46:23,040
open source okay thanks so ed asked um

1400
00:46:21,200 --> 00:46:25,520
where did the inspiration come from to

1401
00:46:23,040 --> 00:46:28,640
attempt this

1402
00:46:25,520 --> 00:46:30,640
yeah interestingly uh this grew out of

1403
00:46:28,640 --> 00:46:31,279
an effort in the network architecture

1404
00:46:30,640 --> 00:46:33,520
team

1405
00:46:31,280 --> 00:46:35,119
just before i had joined i think the the

1406
00:46:33,520 --> 00:46:36,480
idea was that we didn't

1407
00:46:35,119 --> 00:46:38,960
we had all these systems that were

1408
00:46:36,480 --> 00:46:38,960
trying to

1409
00:46:40,000 --> 00:46:43,200
operate on the network especially the

1410
00:46:41,599 --> 00:46:45,440
physical entities of the network so you

1411
00:46:43,200 --> 00:46:47,359
the malt started out as a schema that

1412
00:46:45,440 --> 00:46:49,680
was really representing

1413
00:46:47,359 --> 00:46:51,839
kind of physical things like buildings

1414
00:46:49,680 --> 00:46:54,240
and cables and conduits and stuff like

1415
00:46:51,839 --> 00:46:56,560
that and we sort of evolved it over time

1416
00:46:54,240 --> 00:46:57,680
thinking about other use cases into

1417
00:46:56,560 --> 00:47:00,160
really more

1418
00:46:57,680 --> 00:47:01,839
um a topology model we need a way to

1419
00:47:00,160 --> 00:47:02,720
represent topology we had n of them at

1420
00:47:01,839 --> 00:47:05,520
the time

1421
00:47:02,720 --> 00:47:06,399
and we needed a single one uh once we

1422
00:47:05,520 --> 00:47:08,520
started

1423
00:47:06,400 --> 00:47:10,079
representing topology in other words

1424
00:47:08,520 --> 00:47:11,839
interconnections um

1425
00:47:10,079 --> 00:47:13,119
it quickly became apparent that people

1426
00:47:11,839 --> 00:47:15,359
want to represent not just

1427
00:47:13,119 --> 00:47:17,599
the topology like connectivity of

1428
00:47:15,359 --> 00:47:18,240
different entities and devices and links

1429
00:47:17,599 --> 00:47:20,160
but also

1430
00:47:18,240 --> 00:47:21,279
attributes about them how they're

1431
00:47:20,160 --> 00:47:24,078
configured

1432
00:47:21,280 --> 00:47:25,119
then how they're designed and planned so

1433
00:47:24,079 --> 00:47:26,800
i would say that

1434
00:47:25,119 --> 00:47:28,240
you know the evolution and sort of

1435
00:47:26,800 --> 00:47:29,920
inspiration for kind of

1436
00:47:28,240 --> 00:47:32,640
building out this infrastructure and

1437
00:47:29,920 --> 00:47:34,240
ecosystem has really been driven by i

1438
00:47:32,640 --> 00:47:35,759
would say the vacuum that we had in

1439
00:47:34,240 --> 00:47:37,919
terms of a common

1440
00:47:35,760 --> 00:47:39,040
uh structure a common storage system for

1441
00:47:37,920 --> 00:47:40,160
all these models

1442
00:47:39,040 --> 00:47:42,558
you know once you have something like

1443
00:47:40,160 --> 00:47:45,118
this available people um

1444
00:47:42,559 --> 00:47:46,400
engineers will think of all kinds of use

1445
00:47:45,119 --> 00:47:48,720
cases for them and

1446
00:47:46,400 --> 00:47:49,920
you know uh you know just earlier this

1447
00:47:48,720 --> 00:47:51,598
week we had our

1448
00:47:49,920 --> 00:47:53,760
review board meeting and there were a

1449
00:47:51,599 --> 00:47:55,119
number of new proposals for people

1450
00:47:53,760 --> 00:47:56,319
wanting to add things into the model

1451
00:47:55,119 --> 00:47:57,040
that we hadn't thought about before

1452
00:47:56,319 --> 00:47:59,119
because

1453
00:47:57,040 --> 00:48:00,800
they have some system uh the information

1454
00:47:59,119 --> 00:48:01,760
is available there in malt or it can be

1455
00:48:00,800 --> 00:48:04,960
added to malt

1456
00:48:01,760 --> 00:48:06,400
in a convenient way and and so the set

1457
00:48:04,960 --> 00:48:09,839
of use cases just keeps

1458
00:48:06,400 --> 00:48:11,760
keeps growing yeah that's awesome

1459
00:48:09,839 --> 00:48:13,520
and we definitely see that every time

1460
00:48:11,760 --> 00:48:15,280
when something new comes out

1461
00:48:13,520 --> 00:48:16,880
uh it kind of inspires thought and a

1462
00:48:15,280 --> 00:48:19,040
rippling effect it's really neat

1463
00:48:16,880 --> 00:48:21,200
that's great um and then the final

1464
00:48:19,040 --> 00:48:23,279
question that we have on the q a section

1465
00:48:21,200 --> 00:48:24,720
is from travis he said is there an api

1466
00:48:23,280 --> 00:48:26,720
interface that you use to manage the

1467
00:48:24,720 --> 00:48:29,439
tool

1468
00:48:26,720 --> 00:48:30,078
yeah that's a good question i mean i'll

1469
00:48:29,440 --> 00:48:31,760
i'll

1470
00:48:30,079 --> 00:48:33,520
maybe reinterpret the question slightly

1471
00:48:31,760 --> 00:48:35,920
and and travis invite you to

1472
00:48:33,520 --> 00:48:37,359
to ask it differently if i'm not um uh

1473
00:48:35,920 --> 00:48:40,720
if i'm not answering it

1474
00:48:37,359 --> 00:48:43,598
uh kind of the the developer view of the

1475
00:48:40,720 --> 00:48:45,118
of the model um or the api that we use

1476
00:48:43,599 --> 00:48:46,319
let's say you're writing a configuration

1477
00:48:45,119 --> 00:48:47,920
generation system and

1478
00:48:46,319 --> 00:48:50,400
all the intended configuration

1479
00:48:47,920 --> 00:48:52,960
information is in the model and so

1480
00:48:50,400 --> 00:48:54,640
um you basically just want to get the

1481
00:48:52,960 --> 00:48:57,040
data that you need out of the

1482
00:48:54,640 --> 00:48:59,040
model and put it in some data structure

1483
00:48:57,040 --> 00:49:01,119
that then you can manipulate and

1484
00:48:59,040 --> 00:49:03,200
uh and use to build your let's say

1485
00:49:01,119 --> 00:49:05,440
business logic for config generation

1486
00:49:03,200 --> 00:49:07,118
and so we don't have a single api as

1487
00:49:05,440 --> 00:49:08,720
such unless you count things like the

1488
00:49:07,119 --> 00:49:10,160
query language for just querying the

1489
00:49:08,720 --> 00:49:12,799
model to let's say

1490
00:49:10,160 --> 00:49:14,480
traverse the topology or query you know

1491
00:49:12,800 --> 00:49:16,000
how many bgp sessions do we have with

1492
00:49:14,480 --> 00:49:16,960
this particular asn those kinds of

1493
00:49:16,000 --> 00:49:20,559
things we can

1494
00:49:16,960 --> 00:49:23,920
we can address through the the query api

1495
00:49:20,559 --> 00:49:27,440
um but we've built a number of specific

1496
00:49:23,920 --> 00:49:28,880
libraries that give different use cases

1497
00:49:27,440 --> 00:49:30,559
or different engineers who are working

1498
00:49:28,880 --> 00:49:32,880
on different use cases

1499
00:49:30,559 --> 00:49:34,559
you know fairly specific view of the

1500
00:49:32,880 --> 00:49:35,760
model like if i'm building configuration

1501
00:49:34,559 --> 00:49:38,000
for a device

1502
00:49:35,760 --> 00:49:39,520
we have a library that will you know

1503
00:49:38,000 --> 00:49:41,200
traverse the model

1504
00:49:39,520 --> 00:49:43,359
collect the data about the device its

1505
00:49:41,200 --> 00:49:44,879
adjacent links its interfaces its ports

1506
00:49:43,359 --> 00:49:46,480
put all of that into a data structure

1507
00:49:44,880 --> 00:49:47,839
that then makes it easy to access that

1508
00:49:46,480 --> 00:49:49,520
information so when i'm building out

1509
00:49:47,839 --> 00:49:51,440
config gen logic

1510
00:49:49,520 --> 00:49:53,119
it's sort of all in one place so that

1511
00:49:51,440 --> 00:49:56,880
becomes the api that

1512
00:49:53,119 --> 00:49:58,240
config general writer for let's say the

1513
00:49:56,880 --> 00:50:00,400
b2 network would use

1514
00:49:58,240 --> 00:50:01,919
um when accessing the model so i would

1515
00:50:00,400 --> 00:50:02,400
say we don't have a single api that way

1516
00:50:01,920 --> 00:50:05,760
we have

1517
00:50:02,400 --> 00:50:06,400
a few sets of apis that we use depending

1518
00:50:05,760 --> 00:50:09,680
on

1519
00:50:06,400 --> 00:50:12,079
what use cases okay thank you

1520
00:50:09,680 --> 00:50:13,839
we have one final question from ed he

1521
00:50:12,079 --> 00:50:17,839
said or he asked

1522
00:50:13,839 --> 00:50:20,160
um if possible

1523
00:50:17,839 --> 00:50:23,440
have graph database concepts been of

1524
00:50:20,160 --> 00:50:26,879
interest in your designs with topologies

1525
00:50:23,440 --> 00:50:28,800
yeah i think at the time when we started

1526
00:50:26,880 --> 00:50:30,000
graph databases if you think about you

1527
00:50:28,800 --> 00:50:31,680
know

1528
00:50:30,000 --> 00:50:33,440
open source graph databases like let's

1529
00:50:31,680 --> 00:50:36,399
say neo4j or

1530
00:50:33,440 --> 00:50:38,319
technologies like that they didn't quite

1531
00:50:36,400 --> 00:50:39,200
have the support we needed in particular

1532
00:50:38,319 --> 00:50:41,839
around

1533
00:50:39,200 --> 00:50:43,439
kind of versioning models like we're

1534
00:50:41,839 --> 00:50:44,480
trying to track a life cycle by just

1535
00:50:43,440 --> 00:50:46,800
creating

1536
00:50:44,480 --> 00:50:48,240
new versions of models and making them

1537
00:50:46,800 --> 00:50:50,079
available to different producers and

1538
00:50:48,240 --> 00:50:52,879
consumers and

1539
00:50:50,079 --> 00:50:52,880
it wasn't really

1540
00:50:53,280 --> 00:50:56,559
nothing like that was really available

1541
00:50:54,960 --> 00:51:00,240
and in addition

1542
00:50:56,559 --> 00:51:02,480
i would say that we were kind of um uh

1543
00:51:00,240 --> 00:51:03,919
very easily kind of convinced to use

1544
00:51:02,480 --> 00:51:04,400
something like spanner where we have

1545
00:51:03,920 --> 00:51:06,800
this

1546
00:51:04,400 --> 00:51:08,559
globally distributed database with

1547
00:51:06,800 --> 00:51:10,960
transactional semantics

1548
00:51:08,559 --> 00:51:12,559
uh it works at scale it's resilient to

1549
00:51:10,960 --> 00:51:14,160
failures it's replicated all of that

1550
00:51:12,559 --> 00:51:16,319
happens sort of under the covers and it

1551
00:51:14,160 --> 00:51:18,799
and it was a natural choice to kind of

1552
00:51:16,319 --> 00:51:18,800
use that

1553
00:51:19,599 --> 00:51:25,680
as a way to store um the

1554
00:51:22,640 --> 00:51:27,040
what what is in effect a graph model as

1555
00:51:25,680 --> 00:51:29,598
an entity um

1556
00:51:27,040 --> 00:51:31,279
relationship uh kind of schema and so we

1557
00:51:29,599 --> 00:51:33,280
did have to do some work to

1558
00:51:31,280 --> 00:51:34,400
to massage that entity relationship

1559
00:51:33,280 --> 00:51:37,359
model which is you know

1560
00:51:34,400 --> 00:51:38,960
a graph model at its essence into um you

1561
00:51:37,359 --> 00:51:40,720
know a sql database

1562
00:51:38,960 --> 00:51:42,160
um so i would say you could argue

1563
00:51:40,720 --> 00:51:43,279
there's some impedance mismatch there

1564
00:51:42,160 --> 00:51:44,640
but on the other hand

1565
00:51:43,280 --> 00:51:46,480
you know as i said in the talk we

1566
00:51:44,640 --> 00:51:49,359
decouple kind of the schema that

1567
00:51:46,480 --> 00:51:50,640
users see from the underlying sql schema

1568
00:51:49,359 --> 00:51:53,839
and we get all the benefits

1569
00:51:50,640 --> 00:51:55,920
of something like a global spanner

1570
00:51:53,839 --> 00:51:58,720
and so that's why we haven't we hadn't

1571
00:51:55,920 --> 00:52:01,200
really um

1572
00:51:58,720 --> 00:52:02,240
experimented or investigated a ton with

1573
00:52:01,200 --> 00:52:04,319
with other

1574
00:52:02,240 --> 00:52:06,160
off-the-shelf graph databases when we

1575
00:52:04,319 --> 00:52:07,520
started this work

1576
00:52:06,160 --> 00:52:09,279
gotcha well that was the end of the

1577
00:52:07,520 --> 00:52:12,720
questions that came into that q

1578
00:52:09,280 --> 00:52:14,079
a chat window um before we

1579
00:52:12,720 --> 00:52:17,439
kind of wrap up did you have anything

1580
00:52:14,079 --> 00:52:20,559
else that you wanted to add anis

1581
00:52:17,440 --> 00:52:22,559
no i think i'll just echo what um what

1582
00:52:20,559 --> 00:52:24,160
liz said at the outset of the q a period

1583
00:52:22,559 --> 00:52:25,440
you know this is sort of one perspective

1584
00:52:24,160 --> 00:52:26,399
on doing this i think there's lots of

1585
00:52:25,440 --> 00:52:28,960
different

1586
00:52:26,400 --> 00:52:31,359
approaches and you know whenever we talk

1587
00:52:28,960 --> 00:52:33,440
about standardizing a way to represent

1588
00:52:31,359 --> 00:52:34,480
topology models you know most network

1589
00:52:33,440 --> 00:52:36,880
operators

1590
00:52:34,480 --> 00:52:38,720
certainly the larger ones have their own

1591
00:52:36,880 --> 00:52:42,160
kind of approach and scheme

1592
00:52:38,720 --> 00:52:43,680
um for this so you know it becomes hard

1593
00:52:42,160 --> 00:52:45,040
then to think about what a single

1594
00:52:43,680 --> 00:52:46,160
standard let's say across the industry

1595
00:52:45,040 --> 00:52:48,079
might look like but i think it is

1596
00:52:46,160 --> 00:52:50,240
something of interest to talk about

1597
00:52:48,079 --> 00:52:51,200
um but you know again this is sort of

1598
00:52:50,240 --> 00:52:52,879
our experience

1599
00:52:51,200 --> 00:52:56,319
uh and some of the problems that we had

1600
00:52:52,880 --> 00:52:58,079
to solve um as we see this sort of

1601
00:52:56,319 --> 00:52:59,440
rapidly growing set of use cases around

1602
00:52:58,079 --> 00:53:01,119
modeling and you know

1603
00:52:59,440 --> 00:53:03,280
i just want also thank everyone for the

1604
00:53:01,119 --> 00:53:04,319
interest in the talk and the topic

1605
00:53:03,280 --> 00:53:14,960
and thanks very much for all the

1606
00:53:04,319 --> 00:53:14,960
questions all right thanks anis

