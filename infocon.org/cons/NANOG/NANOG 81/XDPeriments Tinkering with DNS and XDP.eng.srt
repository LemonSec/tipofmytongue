1
00:00:01,610 --> 00:00:05,440
[Music]

2
00:00:05,440 --> 00:00:07,120
uh hello everyone my name is luke

3
00:00:07,120 --> 00:00:08,240
hendricks i'm with

4
00:00:08,240 --> 00:00:10,719
nel net labs and i'm here today with

5
00:00:10,719 --> 00:00:13,040
willem to talk about the experiments we

6
00:00:13,040 --> 00:00:13,679
did

7
00:00:13,679 --> 00:00:15,679
we've been tinkering with dns and xdp

8
00:00:15,679 --> 00:00:17,039
and would like to share

9
00:00:17,039 --> 00:00:21,119
our first results on that so

10
00:00:21,119 --> 00:00:24,640
why xdp i'm sure you've heard about

11
00:00:24,640 --> 00:00:27,599
several programmable data plane

12
00:00:27,599 --> 00:00:29,760
technologies in recent years i'm sure

13
00:00:29,760 --> 00:00:31,679
you've heard about p4 and i'm also quite

14
00:00:31,679 --> 00:00:33,600
sure you've heard about xdp

15
00:00:33,600 --> 00:00:35,440
and they are popular and that's for a

16
00:00:35,440 --> 00:00:36,640
good reason because

17
00:00:36,640 --> 00:00:39,520
these technologies give you a certain

18
00:00:39,520 --> 00:00:40,399
flexibility

19
00:00:40,399 --> 00:00:43,680
in your data plane without sacrificing

20
00:00:43,680 --> 00:00:47,039
too much of performance and specifically

21
00:00:47,039 --> 00:00:47,760
when using

22
00:00:47,760 --> 00:00:51,360
xdp on your linux machine it's an easy

23
00:00:51,360 --> 00:00:51,760
way

24
00:00:51,760 --> 00:00:54,879
to perform some parts of what you want

25
00:00:54,879 --> 00:00:56,559
to do with incoming packets

26
00:00:56,559 --> 00:00:58,640
in your kernel do some hash lifting if

27
00:00:58,640 --> 00:01:00,000
you will

28
00:01:00,000 --> 00:01:02,000
and still have some traditional user

29
00:01:02,000 --> 00:01:04,319
space software after that

30
00:01:04,319 --> 00:01:07,040
and i think that's the most important

31
00:01:07,040 --> 00:01:07,520
thing

32
00:01:07,520 --> 00:01:09,280
the most important takeaway of this

33
00:01:09,280 --> 00:01:11,520
presentation

34
00:01:11,520 --> 00:01:14,159
and the thing we realized after working

35
00:01:14,159 --> 00:01:16,720
for almost a year with with xdp now

36
00:01:16,720 --> 00:01:20,799
is that you can use xtp um to augment

37
00:01:20,799 --> 00:01:23,280
what you already are doing on your

38
00:01:23,280 --> 00:01:24,720
system you don't have to replace

39
00:01:24,720 --> 00:01:26,479
everything that you're doing in user

40
00:01:26,479 --> 00:01:28,240
space you don't have to replace your

41
00:01:28,240 --> 00:01:29,119
entire

42
00:01:29,119 --> 00:01:32,159
dns name server or resolver and the

43
00:01:32,159 --> 00:01:34,320
focus in this presentation

44
00:01:34,320 --> 00:01:36,640
to show you what we do is response rate

45
00:01:36,640 --> 00:01:37,680
limiting

46
00:01:37,680 --> 00:01:40,720
we'll take it as a use case and show how

47
00:01:40,720 --> 00:01:42,159
you can make a drop-in

48
00:01:42,159 --> 00:01:45,280
in xtp to perform rate response rate

49
00:01:45,280 --> 00:01:46,320
limiting

50
00:01:46,320 --> 00:01:49,759
in your kernel so just to be on the same

51
00:01:49,759 --> 00:01:51,200
page with everyone response rate

52
00:01:51,200 --> 00:01:53,040
limiting 101

53
00:01:53,040 --> 00:01:58,240
if we see too many incoming queries

54
00:01:58,240 --> 00:02:00,640
we want to respond either with a

55
00:02:00,640 --> 00:02:01,600
truncated

56
00:02:01,600 --> 00:02:04,880
dns answer or we want to drop it and

57
00:02:04,880 --> 00:02:06,719
we track the number of queries per

58
00:02:06,719 --> 00:02:08,639
second ideally per

59
00:02:08,639 --> 00:02:10,479
the source ip so where the queries are

60
00:02:10,479 --> 00:02:11,680
coming from or

61
00:02:11,680 --> 00:02:14,959
the source prefix now for the other

62
00:02:14,959 --> 00:02:16,080
things that we need to know to

63
00:02:16,080 --> 00:02:17,120
understand everything in this

64
00:02:17,120 --> 00:02:18,160
presentation

65
00:02:18,160 --> 00:02:21,040
uh what's vpf what's xdp i assume most

66
00:02:21,040 --> 00:02:22,800
of us understand what dns

67
00:02:22,800 --> 00:02:27,040
is bpf or actually ebpf

68
00:02:27,040 --> 00:02:30,640
that's a let's call it an evolution of

69
00:02:30,640 --> 00:02:32,800
the traditional berkeley packet field

70
00:02:32,800 --> 00:02:35,040
that i guess everyone knows from their

71
00:02:35,040 --> 00:02:36,319
tcp dump filters

72
00:02:36,319 --> 00:02:39,280
i'm running to speed up now it's a bit

73
00:02:39,280 --> 00:02:39,760
of a

74
00:02:39,760 --> 00:02:42,000
deceiving name if you ask me because

75
00:02:42,000 --> 00:02:43,680
it's much more than a packet filter

76
00:02:43,680 --> 00:02:46,080
nowadays

77
00:02:46,080 --> 00:02:48,959
and actually if people talk about bpf if

78
00:02:48,959 --> 00:02:50,080
folks say bpf

79
00:02:50,080 --> 00:02:53,200
now they mean the extended ppf

80
00:02:53,200 --> 00:02:55,680
if you want to talk about the classic

81
00:02:55,680 --> 00:02:58,879
bpf that's how we call it nowadays cbpf

82
00:02:58,879 --> 00:03:00,879
everything in this presentation is about

83
00:03:00,879 --> 00:03:03,200
ebpf but we'll say ppf

84
00:03:03,200 --> 00:03:06,000
what's xdp xdp is the experts data path

85
00:03:06,000 --> 00:03:07,040
which

86
00:03:07,040 --> 00:03:09,360
is a network driver hook that lets you

87
00:03:09,360 --> 00:03:10,800
run bpf code

88
00:03:10,800 --> 00:03:13,200
exactly there in your drive so that

89
00:03:13,200 --> 00:03:14,480
means we can run

90
00:03:14,480 --> 00:03:17,599
arbitrary codes in

91
00:03:17,599 --> 00:03:19,680
kernel space so in the driver before

92
00:03:19,680 --> 00:03:20,800
anything happens

93
00:03:20,800 --> 00:03:22,720
with the linux network stack so before a

94
00:03:22,720 --> 00:03:25,519
second socket buffer is

95
00:03:25,519 --> 00:03:27,840
before a socket buffer is actually

96
00:03:27,840 --> 00:03:29,360
allocated

97
00:03:29,360 --> 00:03:32,879
so how do we run um

98
00:03:32,879 --> 00:03:35,519
codes how do we let it interact with the

99
00:03:35,519 --> 00:03:36,720
rest of the stack

100
00:03:36,720 --> 00:03:38,560
if we look at the classic stack we have

101
00:03:38,560 --> 00:03:40,319
the neck we have the driver we have the

102
00:03:40,319 --> 00:03:41,840
network stack on top of that

103
00:03:41,840 --> 00:03:44,400
and with sockets we communicate with the

104
00:03:44,400 --> 00:03:46,640
applications right there's no xp here

105
00:03:46,640 --> 00:03:49,120
if we have xdp we determine the package

106
00:03:49,120 --> 00:03:51,519
destiny based on the return codes from

107
00:03:51,519 --> 00:03:51,920
our

108
00:03:51,920 --> 00:03:55,760
piece of bpf code so for example

109
00:03:55,760 --> 00:03:59,120
on the left here we have a xdp tx

110
00:03:59,120 --> 00:04:01,120
return code which basically means send

111
00:04:01,120 --> 00:04:02,799
this out off the same mic

112
00:04:02,799 --> 00:04:06,080
again other option is xp drop which

113
00:04:06,080 --> 00:04:09,760
well no surprise drops the packet and

114
00:04:09,760 --> 00:04:11,920
this is very simple stuff but i hope you

115
00:04:11,920 --> 00:04:13,680
can imagine that this already enables

116
00:04:13,680 --> 00:04:14,480
you to

117
00:04:14,480 --> 00:04:18,000
do quite some cool things right without

118
00:04:18,000 --> 00:04:21,279
going up to user space we can still go

119
00:04:21,279 --> 00:04:23,120
up to user space if we decide that our

120
00:04:23,120 --> 00:04:24,000
code

121
00:04:24,000 --> 00:04:26,080
needs to pass to pump this packet

122
00:04:26,080 --> 00:04:27,919
upwards we can still do this we can punt

123
00:04:27,919 --> 00:04:28,880
it up

124
00:04:28,880 --> 00:04:32,080
the network stack and make it go to a

125
00:04:32,080 --> 00:04:33,919
authoritative name server nsd for

126
00:04:33,919 --> 00:04:36,080
example

127
00:04:36,080 --> 00:04:38,400
or we're not using this in this example

128
00:04:38,400 --> 00:04:40,240
but just for complete the sake

129
00:04:40,240 --> 00:04:42,639
we can return xcp redirected to send it

130
00:04:42,639 --> 00:04:44,639
out of another nic

131
00:04:44,639 --> 00:04:46,479
and we have a special case of xcp

132
00:04:46,479 --> 00:04:48,320
redirect where we can send it to a

133
00:04:48,320 --> 00:04:48,880
special

134
00:04:48,880 --> 00:04:51,280
special type of socket in this case you

135
00:04:51,280 --> 00:04:53,680
will need to adapt your user space

136
00:04:53,680 --> 00:04:56,160
application to actually use this type of

137
00:04:56,160 --> 00:04:58,000
socket but then you can bypass the

138
00:04:58,000 --> 00:05:00,320
entire linux network stack so that's

139
00:05:00,320 --> 00:05:03,199
interesting for performance reasons

140
00:05:03,199 --> 00:05:05,600
um so one more time what we're focusing

141
00:05:05,600 --> 00:05:06,639
on here today

142
00:05:06,639 --> 00:05:10,320
is we try to augment dna software

143
00:05:10,320 --> 00:05:12,800
existing running dns deployments if you

144
00:05:12,800 --> 00:05:14,400
will

145
00:05:14,400 --> 00:05:16,639
by using a subset of the return codes i

146
00:05:16,639 --> 00:05:17,600
just explained

147
00:05:17,600 --> 00:05:19,600
so we can drop certain things we can

148
00:05:19,600 --> 00:05:21,759
send it back out of the nic

149
00:05:21,759 --> 00:05:24,880
or we can actually pass it on to

150
00:05:24,880 --> 00:05:26,560
something running on the operating

151
00:05:26,560 --> 00:05:28,960
system we are not focusing

152
00:05:28,960 --> 00:05:32,000
on adapting existing software to use the

153
00:05:32,000 --> 00:05:34,160
special af xdp sockets and we're not

154
00:05:34,160 --> 00:05:35,360
going to re-implement

155
00:05:35,360 --> 00:05:39,120
everything in xdp now

156
00:05:39,120 --> 00:05:40,880
typical workflow when doing anything in

157
00:05:40,880 --> 00:05:42,479
http um

158
00:05:42,479 --> 00:05:45,520
the bpf code you write is actually c

159
00:05:45,520 --> 00:05:49,440
codes we compile it

160
00:05:49,440 --> 00:05:51,759
and this is important if your code

161
00:05:51,759 --> 00:05:53,520
compiles it does not mean that it will

162
00:05:53,520 --> 00:05:54,560
work because

163
00:05:54,560 --> 00:05:56,560
in the next step and this might be the

164
00:05:56,560 --> 00:05:58,080
most frustrating step when you do

165
00:05:58,080 --> 00:06:00,080
anything with xtp

166
00:06:00,080 --> 00:06:02,000
you will try to load to just compiled

167
00:06:02,000 --> 00:06:04,479
code which

168
00:06:04,479 --> 00:06:07,680
runs the verifier it's a special bpf

169
00:06:07,680 --> 00:06:11,919
verifier that checks whether your code

170
00:06:11,919 --> 00:06:13,919
will actually terminate or whether it's

171
00:06:13,919 --> 00:06:15,440
not too complex so whether it will

172
00:06:15,440 --> 00:06:16,000
terminate

173
00:06:16,000 --> 00:06:19,840
so soon enough so um

174
00:06:19,840 --> 00:06:23,280
complex code with many instructions

175
00:06:23,280 --> 00:06:25,280
will not be allowed to load on that

176
00:06:25,280 --> 00:06:26,800
interface and that makes perfect sense

177
00:06:26,800 --> 00:06:28,639
because you're trying to write arbitrary

178
00:06:28,639 --> 00:06:29,680
code

179
00:06:29,680 --> 00:06:31,840
in kernel space we cannot have kernel

180
00:06:31,840 --> 00:06:33,680
panics just because

181
00:06:33,680 --> 00:06:36,160
you know you made a mistake in your

182
00:06:36,160 --> 00:06:37,840
piece of networking codes that you try

183
00:06:37,840 --> 00:06:39,840
to load on the interface

184
00:06:39,840 --> 00:06:41,919
if there's no objections by the verifier

185
00:06:41,919 --> 00:06:42,960
the code is

186
00:06:42,960 --> 00:06:46,080
active on the interface again only on

187
00:06:46,080 --> 00:06:49,039
ingress so incoming packets are

188
00:06:49,039 --> 00:06:49,759
processed

189
00:06:49,759 --> 00:06:53,280
by your just loaded codes

190
00:06:53,280 --> 00:06:54,880
no more probing no reboot no

191
00:06:54,880 --> 00:06:56,720
reconfiguration of anything right so

192
00:06:56,720 --> 00:06:58,400
it's it's actually it's as simple as

193
00:06:58,400 --> 00:07:00,240
this if you're running a recent linux

194
00:07:00,240 --> 00:07:01,759
kernel you can do this

195
00:07:01,759 --> 00:07:02,960
and if you need any further

196
00:07:02,960 --> 00:07:04,639
configuration or interaction with that

197
00:07:04,639 --> 00:07:06,720
code in kernel space that goes via bpf

198
00:07:06,720 --> 00:07:08,400
maps we'll get to that

199
00:07:08,400 --> 00:07:11,759
so response rate limiting um what what

200
00:07:11,759 --> 00:07:13,599
does this code look like the code is

201
00:07:13,599 --> 00:07:16,319
online on github you can check it out

202
00:07:16,319 --> 00:07:19,120
but high level view we have to parse the

203
00:07:19,120 --> 00:07:20,000
package so

204
00:07:20,000 --> 00:07:22,240
is it ethernet ip and udp with a

205
00:07:22,240 --> 00:07:23,759
destination port 53

206
00:07:23,759 --> 00:07:26,880
obviously and we check whether

207
00:07:26,880 --> 00:07:28,639
the payload is actually a correctly

208
00:07:28,639 --> 00:07:30,080
formatted dns query

209
00:07:30,080 --> 00:07:31,919
if not we just pass it on because it's

210
00:07:31,919 --> 00:07:33,120
probably something else and we're not

211
00:07:33,120 --> 00:07:34,960
going to process it

212
00:07:34,960 --> 00:07:36,560
now we know that we're dealing with an

213
00:07:36,560 --> 00:07:38,560
actual dns query

214
00:07:38,560 --> 00:07:41,520
we have to do the state keeping so we're

215
00:07:41,520 --> 00:07:42,880
going to

216
00:07:42,880 --> 00:07:44,879
calculate the query rate from this

217
00:07:44,879 --> 00:07:46,080
specific source

218
00:07:46,080 --> 00:07:48,400
source address and we're keeping the

219
00:07:48,400 --> 00:07:49,680
state using maps

220
00:07:49,680 --> 00:07:51,919
and based on the rate we make a decision

221
00:07:51,919 --> 00:07:53,840
are we going to pass this on to nsd do

222
00:07:53,840 --> 00:07:55,759
we allow this query to

223
00:07:55,759 --> 00:07:59,520
be answered or are we going to drop it

224
00:07:59,520 --> 00:08:04,160
maps in bpf are your data structures to

225
00:08:04,160 --> 00:08:06,319
both keep state and to communicate with

226
00:08:06,319 --> 00:08:08,160
user space so you can do configuration

227
00:08:08,160 --> 00:08:09,440
with them

228
00:08:09,440 --> 00:08:11,680
they are specific to bpf and if you

229
00:08:11,680 --> 00:08:13,360
check the source code the bpa header

230
00:08:13,360 --> 00:08:14,319
file

231
00:08:14,319 --> 00:08:17,039
you will find plenty of different data

232
00:08:17,039 --> 00:08:18,160
structures

233
00:08:18,160 --> 00:08:19,919
made available to you you will need

234
00:08:19,919 --> 00:08:22,479
special helper functions to actually do

235
00:08:22,479 --> 00:08:25,520
lookup and deletes etc etc

236
00:08:25,520 --> 00:08:27,680
but this is this is the stuff that you

237
00:08:27,680 --> 00:08:29,360
need if you want to interact with what

238
00:08:29,360 --> 00:08:30,560
you just loaded

239
00:08:30,560 --> 00:08:33,760
in kernel space from user space

240
00:08:33,760 --> 00:08:36,320
so the two things that we'll see we do

241
00:08:36,320 --> 00:08:37,519
the safe keeping

242
00:08:37,519 --> 00:08:39,519
so keeping state in between packets if

243
00:08:39,519 --> 00:08:41,200
you ever worked with other

244
00:08:41,200 --> 00:08:43,279
data plane programmable data plane

245
00:08:43,279 --> 00:08:44,959
technologies you know that it's

246
00:08:44,959 --> 00:08:46,240
you know this can be this can be

247
00:08:46,240 --> 00:08:48,320
cumbersome and tricky um

248
00:08:48,320 --> 00:08:50,800
but the good thing here is it's you know

249
00:08:50,800 --> 00:08:52,480
normalcy

250
00:08:52,480 --> 00:08:54,640
we have created our own buckets wherein

251
00:08:54,640 --> 00:08:55,839
we keep a

252
00:08:55,839 --> 00:08:57,440
track of the start time and the number

253
00:08:57,440 --> 00:09:00,560
of packets uh and we attach that to

254
00:09:00,560 --> 00:09:04,399
a key which is in our case a v6 or v4

255
00:09:04,399 --> 00:09:08,160
source address and now we can just count

256
00:09:08,160 --> 00:09:10,000
the other use of maps the configuration

257
00:09:10,000 --> 00:09:11,360
from user space

258
00:09:11,360 --> 00:09:13,519
in this case we want to exclude certain

259
00:09:13,519 --> 00:09:15,519
prefixes from a rate limiting program

260
00:09:15,519 --> 00:09:18,320
and we do that using a different

261
00:09:18,320 --> 00:09:19,839
data structure that's available a

262
00:09:19,839 --> 00:09:21,440
different type of bpf map that's

263
00:09:21,440 --> 00:09:22,800
available to us that's the

264
00:09:22,800 --> 00:09:26,000
longest prefix match tree

265
00:09:26,000 --> 00:09:28,080
that's already there ready for you to

266
00:09:28,080 --> 00:09:29,040
use

267
00:09:29,040 --> 00:09:31,519
so we make two of these maps again one

268
00:09:31,519 --> 00:09:33,040
for v4 and v6

269
00:09:33,040 --> 00:09:36,399
so we can exclude the ranges from

270
00:09:36,399 --> 00:09:38,560
our customers for example that we do not

271
00:09:38,560 --> 00:09:41,279
want to rate limits

272
00:09:41,279 --> 00:09:43,760
we do need to keep a value in this map

273
00:09:43,760 --> 00:09:45,440
as well

274
00:09:45,440 --> 00:09:48,880
and so for this we

275
00:09:48,880 --> 00:09:51,600
just count the hits so how often is a

276
00:09:51,600 --> 00:09:52,640
excluded prefix

277
00:09:52,640 --> 00:09:55,760
actually uh hits how many

278
00:09:55,760 --> 00:09:57,360
incoming queries do we see for those

279
00:09:57,360 --> 00:10:00,160
prefixes populating those maps

280
00:10:00,160 --> 00:10:03,360
can be done with bpf tool but we can

281
00:10:03,360 --> 00:10:04,720
also

282
00:10:04,720 --> 00:10:07,680
write our own custom user space program

283
00:10:07,680 --> 00:10:08,320
to do that

284
00:10:08,320 --> 00:10:12,720
which makes it easier so

285
00:10:12,720 --> 00:10:16,079
i hope that's all clear for now because

286
00:10:16,079 --> 00:10:19,360
winning will take over and

287
00:10:19,360 --> 00:10:22,640
show you how it's done actually i'd love

288
00:10:22,640 --> 00:10:24,800
to

289
00:10:24,800 --> 00:10:28,880
let me share my terminal

290
00:10:28,880 --> 00:10:31,279
so i'm going to show you how this looks

291
00:10:31,279 --> 00:10:32,800
in practice with

292
00:10:32,800 --> 00:10:35,920
a live demo and i've

293
00:10:35,920 --> 00:10:38,959
started a virtual machine and

294
00:10:38,959 --> 00:10:42,800
it is running a name server

295
00:10:42,800 --> 00:10:46,320
and we are under attack it's this

296
00:10:46,320 --> 00:10:46,880
machine

297
00:10:46,880 --> 00:10:51,440
i can send a query to crease to it

298
00:10:51,440 --> 00:10:54,000
and we are going to pretend that this

299
00:10:54,000 --> 00:10:55,600
machine is under attack

300
00:10:55,600 --> 00:10:58,640
and i saw this presentation at the nanok

301
00:10:58,640 --> 00:10:59,680
81

302
00:10:59,680 --> 00:11:03,279
and i think well why don't i try that

303
00:11:03,279 --> 00:11:06,399
response weight limiting in xtp

304
00:11:06,399 --> 00:11:09,600
and see if my server becomes more

305
00:11:09,600 --> 00:11:11,200
responsive

306
00:11:11,200 --> 00:11:14,240
so and let me first

307
00:11:14,240 --> 00:11:17,519
log into that server so this is

308
00:11:17,519 --> 00:11:21,360
uh installing the response rate limiting

309
00:11:21,360 --> 00:11:25,120
by xtp from scratch actually

310
00:11:25,120 --> 00:11:30,480
so first i check out the repository

311
00:11:30,480 --> 00:11:35,120
and the repository is actually

312
00:11:35,120 --> 00:11:38,640
has code examples for material

313
00:11:38,640 --> 00:11:41,680
for which which we have written about in

314
00:11:41,680 --> 00:11:44,160
blog posts and there's a link to those

315
00:11:44,160 --> 00:11:45,360
blog posts

316
00:11:45,360 --> 00:11:48,399
posts at the end of our presentation

317
00:11:48,399 --> 00:11:50,320
but it's more than just response rate

318
00:11:50,320 --> 00:11:51,760
limiting we have two

319
00:11:51,760 --> 00:11:54,800
blog posts the first one is showing how

320
00:11:54,800 --> 00:11:55,519
to

321
00:11:55,519 --> 00:11:58,399
parse dns packets and the second one is

322
00:11:58,399 --> 00:12:00,399
about response rate limiting

323
00:12:00,399 --> 00:12:02,880
so this

324
00:12:03,760 --> 00:12:11,839
hit repository has a sub module

325
00:12:16,480 --> 00:12:19,839
that's it from the

326
00:12:19,839 --> 00:12:23,760
to configure the prefixes which should

327
00:12:23,760 --> 00:12:24,079
not

328
00:12:24,079 --> 00:12:27,440
be a response very limited

329
00:12:27,440 --> 00:12:32,480
so i have to compile

330
00:12:32,480 --> 00:12:35,040
this library first because we have this

331
00:12:35,040 --> 00:12:36,560
user space program

332
00:12:36,560 --> 00:12:39,600
if you would use only the xcp kernel

333
00:12:39,600 --> 00:12:41,440
space program you would not have

334
00:12:41,440 --> 00:12:44,240
to do this

335
00:12:46,000 --> 00:12:48,560
here is where the response with weight

336
00:12:48,560 --> 00:12:49,519
limiting code

337
00:12:49,519 --> 00:12:53,040
lives we have three versions

338
00:12:53,040 --> 00:12:56,000
the third version is a full fledged

339
00:12:56,000 --> 00:12:56,959
version

340
00:12:56,959 --> 00:13:00,079
with a response late weight limiting as

341
00:13:00,079 --> 00:13:01,839
it is

342
00:13:01,839 --> 00:13:05,279
implemented in actual dns software

343
00:13:05,279 --> 00:13:08,560
with all the belts and whistles and

344
00:13:08,560 --> 00:13:11,920
a configuration of it is in the source

345
00:13:11,920 --> 00:13:12,959
card

346
00:13:12,959 --> 00:13:15,040
so you have to specify the number of

347
00:13:15,040 --> 00:13:17,760
cpus

348
00:13:17,760 --> 00:13:21,040
this is the number of entries in the

349
00:13:21,040 --> 00:13:22,000
hash table

350
00:13:22,000 --> 00:13:25,519
which stores prefixes that will be

351
00:13:25,519 --> 00:13:29,040
very limited and because we are not

352
00:13:29,040 --> 00:13:31,760
weight limiting individual ip addresses

353
00:13:31,760 --> 00:13:32,839
but

354
00:13:32,839 --> 00:13:35,839
networks which can be configured

355
00:13:35,839 --> 00:13:39,120
and here is the actual

356
00:13:39,120 --> 00:13:42,720
number of queries per second and i'm

357
00:13:42,720 --> 00:13:44,639
going to lower this a little bit for

358
00:13:44,639 --> 00:13:46,399
demo sake

359
00:13:46,399 --> 00:13:48,959
and the slip rate is the number of

360
00:13:48,959 --> 00:13:50,000
responses

361
00:13:50,000 --> 00:13:54,320
that will be dropped before

362
00:13:54,320 --> 00:13:57,760
an answer is given with the truncate bit

363
00:13:57,760 --> 00:14:02,000
on so that the request will return or

364
00:14:02,000 --> 00:14:06,079
the requester will return over tcp

365
00:14:06,079 --> 00:14:10,639
if a requester returns over tcp

366
00:14:10,639 --> 00:14:14,079
it the address is not spoofed so it's a

367
00:14:14,079 --> 00:14:16,160
good check

368
00:14:16,160 --> 00:14:19,760
it's it's good to reply with the tc

369
00:14:19,760 --> 00:14:21,440
bit because then there is no

370
00:14:21,440 --> 00:14:23,279
amplification and the

371
00:14:23,279 --> 00:14:26,480
requester will actually get this dns

372
00:14:26,480 --> 00:14:28,240
answer

373
00:14:28,240 --> 00:14:32,079
so i will first make the programs

374
00:14:32,079 --> 00:14:35,680
this compiles the xp kernel module

375
00:14:35,680 --> 00:14:39,120
and the user space program to interact

376
00:14:39,120 --> 00:14:42,000
with the prefixes that should not be

377
00:14:42,000 --> 00:14:44,240
response weight limited

378
00:14:44,240 --> 00:14:48,000
then i

379
00:14:48,160 --> 00:14:51,839
have to create the maps

380
00:14:51,839 --> 00:14:54,480
that look just talked about to

381
00:14:54,480 --> 00:14:57,519
communicate with the xcp kernel program

382
00:14:57,519 --> 00:15:00,079
about which prefixes should be very

383
00:15:00,079 --> 00:15:02,160
limited and which not

384
00:15:02,160 --> 00:15:05,920
and now i load the kernel module

385
00:15:05,920 --> 00:15:09,440
and you can actually see

386
00:15:09,440 --> 00:15:12,880
by that xtp generic

387
00:15:12,880 --> 00:15:16,240
that ethernet 0 now has the xp program

388
00:15:16,240 --> 00:15:18,720
loaded

389
00:15:18,800 --> 00:15:26,000
so let's try sending some queries

390
00:15:26,000 --> 00:15:29,760
so first i will

391
00:15:29,920 --> 00:15:35,279
also show you the dates

392
00:15:38,839 --> 00:15:41,839
uh

393
00:15:43,920 --> 00:15:48,000
and i want short answers and also i

394
00:15:48,000 --> 00:15:51,360
with the ignore flag flag to dig

395
00:15:51,360 --> 00:15:54,480
i tell dick to not return when the

396
00:15:54,480 --> 00:15:55,440
truncate

397
00:15:55,440 --> 00:15:58,800
bit is received then sleep

398
00:15:58,800 --> 00:16:02,320
for half a second and now you're done

399
00:16:02,320 --> 00:16:04,720
and you see that we now receive the

400
00:16:04,720 --> 00:16:07,360
answers we are not response rate limited

401
00:16:07,360 --> 00:16:10,160
because i'm just sending a query once

402
00:16:10,160 --> 00:16:12,079
half seconds

403
00:16:12,079 --> 00:16:15,279
but if i lower the

404
00:16:15,279 --> 00:16:19,040
value of sleep to send more

405
00:16:19,040 --> 00:16:21,680
queries after each other you will notice

406
00:16:21,680 --> 00:16:22,560
that

407
00:16:22,560 --> 00:16:24,880
there are a number of entries which do

408
00:16:24,880 --> 00:16:26,000
not have the

409
00:16:26,000 --> 00:16:28,560
answer and those are actually the

410
00:16:28,560 --> 00:16:30,720
answers with the truncated bit set

411
00:16:30,720 --> 00:16:32,880
and without the answer so there's no

412
00:16:32,880 --> 00:16:33,920
amplification

413
00:16:33,920 --> 00:16:37,839
and it is a response rate limited

414
00:16:38,160 --> 00:16:43,279
now to exclude my own prefix

415
00:16:43,920 --> 00:16:47,680
and let's see what my address is

416
00:16:47,680 --> 00:16:50,800
this is my device oh

417
00:16:50,800 --> 00:16:54,800
not link the address

418
00:16:57,759 --> 00:17:01,040
so i'm using ipv6 to query

419
00:17:01,040 --> 00:17:06,240
so i'm going to add this prefix

420
00:17:06,720 --> 00:17:08,880
to

421
00:17:10,319 --> 00:17:14,160
the very important prefixes list

422
00:17:14,160 --> 00:17:16,839
to exclude me from response rate

423
00:17:16,839 --> 00:17:18,079
limiting

424
00:17:18,079 --> 00:17:23,199
oh add i forgot the word at

425
00:17:23,199 --> 00:17:26,400
there you go now every

426
00:17:26,400 --> 00:17:29,280
query is answered because i'm a known

427
00:17:29,280 --> 00:17:30,320
customer

428
00:17:30,320 --> 00:17:33,360
who's known to who is allowed to ask

429
00:17:33,360 --> 00:17:34,640
many queries

430
00:17:34,640 --> 00:17:37,280
per second

431
00:17:38,320 --> 00:17:42,799
all right so that's the demo

432
00:17:44,000 --> 00:17:49,440
now let me share my presentation we know

433
00:17:52,320 --> 00:17:56,000
so what have we learned from this

434
00:17:56,000 --> 00:17:59,039
we can leverage xcp to

435
00:17:59,039 --> 00:18:01,919
augmented dns servers right it doesn't

436
00:18:01,919 --> 00:18:02,960
need to be

437
00:18:02,960 --> 00:18:06,559
our dns server it could be any dns

438
00:18:06,559 --> 00:18:08,799
service and if you

439
00:18:08,799 --> 00:18:11,840
add this xtp module this response weight

440
00:18:11,840 --> 00:18:12,880
limiting module

441
00:18:12,880 --> 00:18:17,120
it will work for that dns service

442
00:18:17,520 --> 00:18:20,640
in xcp we can either drop a packet we

443
00:18:20,640 --> 00:18:22,160
can answer it or we can

444
00:18:22,160 --> 00:18:25,360
send it up to the name server maps

445
00:18:25,360 --> 00:18:28,799
enable keeping state not only to

446
00:18:28,799 --> 00:18:31,679
for statistics and rate calculation but

447
00:18:31,679 --> 00:18:32,799
also

448
00:18:32,799 --> 00:18:36,000
to configure the prefixes

449
00:18:36,000 --> 00:18:38,480
which we did not want to be subject to

450
00:18:38,480 --> 00:18:40,960
response rate limiting

451
00:18:40,960 --> 00:18:43,840
there are different kinds of maps for uh

452
00:18:43,840 --> 00:18:45,200
different purposes

453
00:18:45,200 --> 00:18:48,720
uh for example the the map that did

454
00:18:48,720 --> 00:18:52,320
for with which we did did the

455
00:18:52,320 --> 00:18:56,160
weight calculation is per cpu so no

456
00:18:56,160 --> 00:18:59,520
locking is needed and if you have a mini

457
00:18:59,520 --> 00:19:02,400
cpu system

458
00:19:02,400 --> 00:19:05,760
they can all anticipate or

459
00:19:05,760 --> 00:19:08,880
work on weight limiting the

460
00:19:08,880 --> 00:19:12,720
responses when they attack

461
00:19:13,440 --> 00:19:15,840
so i'd like to talk a little bit more

462
00:19:15,840 --> 00:19:16,720
about

463
00:19:16,720 --> 00:19:20,240
venus cookies because it's a mechanism

464
00:19:20,240 --> 00:19:21,039
in dns

465
00:19:21,039 --> 00:19:24,720
to generate vip lists the

466
00:19:24,720 --> 00:19:27,760
prefixes list to include automatically

467
00:19:27,760 --> 00:19:29,440
in protocol

468
00:19:29,440 --> 00:19:32,160
how does that work well the client sends

469
00:19:32,160 --> 00:19:34,080
a client cookie

470
00:19:34,080 --> 00:19:36,480
specific for the server it's contacting

471
00:19:36,480 --> 00:19:38,640
the server creates a server cookie based

472
00:19:38,640 --> 00:19:39,679
on the client

473
00:19:39,679 --> 00:19:42,320
the client ip and a secret only known to

474
00:19:42,320 --> 00:19:43,440
the server

475
00:19:43,440 --> 00:19:46,080
and returns this to the client the next

476
00:19:46,080 --> 00:19:47,760
time the client needs to contact the

477
00:19:47,760 --> 00:19:48,559
server

478
00:19:48,559 --> 00:19:50,840
it brings along the learned server

479
00:19:50,840 --> 00:19:52,000
cookie

480
00:19:52,000 --> 00:19:54,000
and in this way the server knows that

481
00:19:54,000 --> 00:19:55,520
the client

482
00:19:55,520 --> 00:19:58,640
ip at least is not spoofed so

483
00:19:58,640 --> 00:20:01,760
it's a bit like a tcp handshake

484
00:20:01,760 --> 00:20:05,600
but more light weight because the server

485
00:20:05,600 --> 00:20:06,080
does not

486
00:20:06,080 --> 00:20:09,280
need to maintain client state so if you

487
00:20:09,280 --> 00:20:11,120
have a valid server cookie

488
00:20:11,120 --> 00:20:13,520
you are not subjective to response based

489
00:20:13,520 --> 00:20:14,960
limiting

490
00:20:14,960 --> 00:20:17,440
so that means that if you do response

491
00:20:17,440 --> 00:20:18,400
weight limiting

492
00:20:18,400 --> 00:20:21,919
in xcp xzp have to do dns cookies in xp

493
00:20:21,919 --> 00:20:25,280
as well because otherwise xp will do the

494
00:20:25,280 --> 00:20:27,200
response weight limiting before your

495
00:20:27,200 --> 00:20:31,440
nameserver can do dns cookies

496
00:20:32,400 --> 00:20:35,760
luckily so there is this

497
00:20:35,760 --> 00:20:38,880
uh call in ppf which is called a tail

498
00:20:38,880 --> 00:20:39,360
call

499
00:20:39,360 --> 00:20:42,559
and you can basically chain multiple xp

500
00:20:42,559 --> 00:20:45,760
programs after each other this we can

501
00:20:45,760 --> 00:20:46,320
create

502
00:20:46,320 --> 00:20:50,159
a xcp cookie verification program

503
00:20:50,159 --> 00:20:53,200
we are actually about to post our third

504
00:20:53,200 --> 00:20:56,159
blog post telling you how to do this and

505
00:20:56,159 --> 00:20:57,520
then

506
00:20:57,520 --> 00:21:00,880
on successful cookie verification pass

507
00:21:00,880 --> 00:21:03,679
the packet to the already existing

508
00:21:03,679 --> 00:21:08,159
response weight limiting xcp module

509
00:21:08,360 --> 00:21:11,360
alternatively we could also do

510
00:21:11,360 --> 00:21:15,600
the complete dns cookie processing with

511
00:21:15,600 --> 00:21:19,360
ppf by running two bpf programs

512
00:21:19,360 --> 00:21:22,559
one for incoming packets verifying the

513
00:21:22,559 --> 00:21:23,200
cookies

514
00:21:23,200 --> 00:21:25,840
at the xcp layer and one for outgoing

515
00:21:25,840 --> 00:21:28,400
packets coming from the dns servicing

516
00:21:28,400 --> 00:21:32,400
user space which will be responsible for

517
00:21:32,400 --> 00:21:36,000
creating the cookies bpf

518
00:21:36,000 --> 00:21:38,400
programs on the tc layer are very

519
00:21:38,400 --> 00:21:39,919
flexible

520
00:21:39,919 --> 00:21:42,799
you work with sockets buffers instead of

521
00:21:42,799 --> 00:21:43,200
the

522
00:21:43,200 --> 00:21:46,240
lower packets and which can be resized

523
00:21:46,240 --> 00:21:47,120
with

524
00:21:47,120 --> 00:21:52,080
ppf helper friendships but it's not as

525
00:21:52,640 --> 00:21:56,080
fast as xcp of course but

526
00:21:56,080 --> 00:21:59,679
much more flexible so in this way

527
00:21:59,679 --> 00:22:03,280
the cookie mechanism could be

528
00:22:03,280 --> 00:22:06,720
added to dna services that

529
00:22:06,720 --> 00:22:09,360
even do not know about cookies or do not

530
00:22:09,360 --> 00:22:11,120
have it

531
00:22:11,120 --> 00:22:13,360
for cookies this especially interesting

532
00:22:13,360 --> 00:22:16,159
because the first implementation

533
00:22:16,159 --> 00:22:18,720
had different software vendors who

534
00:22:18,720 --> 00:22:20,720
implemented it differently

535
00:22:20,720 --> 00:22:24,159
and were not compatible

536
00:22:24,159 --> 00:22:26,320
so in this way you would also have a

537
00:22:26,320 --> 00:22:27,280
uniform

538
00:22:27,280 --> 00:22:30,960
dns cookie implementation

539
00:22:31,360 --> 00:22:34,880
so concluding a lot is possible with

540
00:22:34,880 --> 00:22:38,080
xp and ebpf but

541
00:22:38,080 --> 00:22:40,880
it is especially a very good fit for

542
00:22:40,880 --> 00:22:42,240
plain old udp

543
00:22:42,240 --> 00:22:45,280
based dns because it has a

544
00:22:45,280 --> 00:22:48,720
per packet processing right it will be

545
00:22:48,720 --> 00:22:52,080
much less suitable for tcp basedness

546
00:22:52,080 --> 00:22:54,960
and probably impossible for dns

547
00:22:54,960 --> 00:22:56,640
advertise or

548
00:22:56,640 --> 00:23:01,039
dough because it's convenient

549
00:23:01,039 --> 00:23:04,320
to or you have to parse the the package

550
00:23:04,320 --> 00:23:08,320
at the exp xp layer

551
00:23:08,320 --> 00:23:11,679
and we think that using xtp to augment

552
00:23:11,679 --> 00:23:12,000
the

553
00:23:12,000 --> 00:23:15,600
existing dns surface is an exciting new

554
00:23:15,600 --> 00:23:16,080
ide

555
00:23:16,080 --> 00:23:18,159
and a great new tool in the dns

556
00:23:18,159 --> 00:23:20,799
operators

557
00:23:20,840 --> 00:23:22,240
toolbox

558
00:23:22,240 --> 00:23:26,880
uh we're currently also looking into

559
00:23:26,880 --> 00:23:30,320
offloading of xcp programs to hardware

560
00:23:30,320 --> 00:23:34,240
the metronome smart mix can run

561
00:23:34,240 --> 00:23:38,480
xp programs in the network card itself

562
00:23:38,480 --> 00:23:41,919
and doing performance measurements for

563
00:23:41,919 --> 00:23:43,279
that

564
00:23:43,279 --> 00:23:47,600
we are also looking ahead for

565
00:23:47,600 --> 00:23:50,720
af xdp support in msd

566
00:23:50,720 --> 00:23:54,000
so completely bypassing the network

567
00:23:54,000 --> 00:23:55,200
stack

568
00:23:55,200 --> 00:23:58,320
and oh yeah also another id we have is a

569
00:23:58,320 --> 00:24:00,799
hot self managing cache

570
00:24:00,799 --> 00:24:04,480
right where the queries

571
00:24:04,480 --> 00:24:07,760
or the outgoing answers go

572
00:24:07,760 --> 00:24:11,600
into a least recently used hashmob

573
00:24:11,600 --> 00:24:14,480
that can immediately answer those

574
00:24:14,480 --> 00:24:15,120
queries

575
00:24:15,120 --> 00:24:18,320
if it's fine from the xp layer

576
00:24:18,320 --> 00:24:21,440
if it finds the query in that

577
00:24:21,440 --> 00:24:24,960
hash map and we're also looking into

578
00:24:24,960 --> 00:24:28,400
load balancing zones large zones of a

579
00:24:28,400 --> 00:24:31,039
multiple name servers and using xp

580
00:24:31,039 --> 00:24:34,799
to short

581
00:24:34,799 --> 00:24:38,720
or center queries to the correct servers

582
00:24:38,720 --> 00:24:41,440
we would also like to try in the future

583
00:24:41,440 --> 00:24:42,000
to

584
00:24:42,000 --> 00:24:46,799
serve the root zone from x2p

585
00:24:46,799 --> 00:24:50,559
so this is uh was our presentation uh

586
00:24:50,559 --> 00:24:53,600
have a look at the the gita repository

587
00:24:53,600 --> 00:24:54,640
and also

588
00:24:54,640 --> 00:24:58,000
at our blog posts and more blog posts

589
00:24:58,000 --> 00:25:00,960
about this will follow and we are now

590
00:25:00,960 --> 00:25:01,760
open for

591
00:25:01,760 --> 00:25:04,320
questions

592
00:25:04,530 --> 00:25:08,859
[Music]

593
00:25:08,960 --> 00:25:12,320
all right you're live and thank you

594
00:25:12,320 --> 00:25:14,960
luke and willam for uh presenting for us

595
00:25:14,960 --> 00:25:16,240
on the forum

596
00:25:16,240 --> 00:25:19,679
81 virtual um and i'll comment you were

597
00:25:19,679 --> 00:25:20,720
both uh

598
00:25:20,720 --> 00:25:22,880
you're you're both coming to us from the

599
00:25:22,880 --> 00:25:23,840
netherlands

600
00:25:23,840 --> 00:25:25,840
um which is something that would not be

601
00:25:25,840 --> 00:25:28,480
pop but it would not be possible in a uh

602
00:25:28,480 --> 00:25:32,320
in a real-world manner and uh as we

603
00:25:32,320 --> 00:25:34,159
you know when we when once we're able to

604
00:25:34,159 --> 00:25:35,440
move back to in-person

605
00:25:35,440 --> 00:25:39,120
meetings um hopefully sometime soon

606
00:25:39,120 --> 00:25:43,039
um you know hopefully you know i can uh

607
00:25:43,039 --> 00:25:45,440
i can uh say i hope that that the

608
00:25:45,440 --> 00:25:47,120
ability for remote participation

609
00:25:47,120 --> 00:25:49,440
representation such as these uh will

610
00:25:49,440 --> 00:25:50,559
stay with us uh

611
00:25:50,559 --> 00:25:51,760
it's been a great enhancement to the

612
00:25:51,760 --> 00:25:53,600
meeting and i hope you all appreciate

613
00:25:53,600 --> 00:25:54,159
that

614
00:25:54,159 --> 00:25:57,840
um so going to questions um

615
00:25:57,840 --> 00:26:00,960
looks like we have one from uh nate

616
00:26:00,960 --> 00:26:02,320
sales

617
00:26:02,320 --> 00:26:04,720
are there any current dns servers that

618
00:26:04,720 --> 00:26:05,440
support

619
00:26:05,440 --> 00:26:08,400
af xdp socket communications for

620
00:26:08,400 --> 00:26:09,200
managing

621
00:26:09,200 --> 00:26:12,799
cookies within the demon itself yes

622
00:26:12,799 --> 00:26:16,320
absolutely the the not not dns

623
00:26:16,320 --> 00:26:19,840
has as xtp support

624
00:26:19,840 --> 00:26:22,640
i think that's the only name server

625
00:26:22,640 --> 00:26:24,960
currently to support this

626
00:26:24,960 --> 00:26:28,720
and of course it's just as

627
00:26:28,720 --> 00:26:31,360
efficient to do it all in user space

628
00:26:31,360 --> 00:26:33,039
once you have this direct

629
00:26:33,039 --> 00:26:36,320
path from the network driver

630
00:26:36,320 --> 00:26:40,559
to the nature of software but

631
00:26:40,559 --> 00:26:43,679
we wanted to focus on if you're

632
00:26:43,679 --> 00:26:46,880
having an installation having software

633
00:26:46,880 --> 00:26:47,440
which

634
00:26:47,440 --> 00:26:50,840
perhaps does not have this feature you

635
00:26:50,840 --> 00:26:52,240
can

636
00:26:52,240 --> 00:26:56,000
use at that

637
00:26:56,000 --> 00:26:59,440
moment install xp software to

638
00:26:59,440 --> 00:27:02,159
alter the behavior of your software this

639
00:27:02,159 --> 00:27:02,559
could

640
00:27:02,559 --> 00:27:07,600
include features your surface

641
00:27:07,600 --> 00:27:10,320
would not have such as response rate

642
00:27:10,320 --> 00:27:12,240
limiting or dns cookies

643
00:27:12,240 --> 00:27:15,520
or adding or

644
00:27:16,159 --> 00:27:20,480
those kind of things

645
00:27:20,480 --> 00:27:24,000
okay uh thank you for that um the next

646
00:27:24,000 --> 00:27:25,120
question comes from

647
00:27:25,120 --> 00:27:28,799
dan magorian uh xdv xdp

648
00:27:28,799 --> 00:27:32,320
versus p4 uh

649
00:27:32,320 --> 00:27:34,640
i can i can take this one um it's uh

650
00:27:34,640 --> 00:27:35,440
it's a short

651
00:27:35,440 --> 00:27:38,559
question but um

652
00:27:38,559 --> 00:27:40,720
let's see if i can come up with a short

653
00:27:40,720 --> 00:27:42,640
answer as well b4 is a

654
00:27:42,640 --> 00:27:45,279
dsl which lets you describe what you

655
00:27:45,279 --> 00:27:45,919
want your

656
00:27:45,919 --> 00:27:49,760
data plane to do um which means that you

657
00:27:49,760 --> 00:27:51,760
need

658
00:27:51,760 --> 00:27:54,960
a development suite and

659
00:27:54,960 --> 00:27:57,919
a specific hardware target to compile

660
00:27:57,919 --> 00:27:58,720
the dsl

661
00:27:58,720 --> 00:28:02,159
to well that specific platform

662
00:28:02,159 --> 00:28:06,320
so that is a

663
00:28:06,320 --> 00:28:09,200
big step to take because you need to

664
00:28:09,200 --> 00:28:11,279
acquire specific hardware

665
00:28:11,279 --> 00:28:13,679
to do anything with before and then you

666
00:28:13,679 --> 00:28:14,840
need to get

667
00:28:14,840 --> 00:28:19,360
um yourself familiar with that entire

668
00:28:19,360 --> 00:28:22,960
development kit if you will and i think

669
00:28:22,960 --> 00:28:25,120
that's one of the biggest advantages of

670
00:28:25,120 --> 00:28:26,480
xtp is that

671
00:28:26,480 --> 00:28:29,120
everyone like william b showed can use

672
00:28:29,120 --> 00:28:30,399
this even if you didn't

673
00:28:30,399 --> 00:28:32,399
think of it before and you have a

674
00:28:32,399 --> 00:28:33,440
running system

675
00:28:33,440 --> 00:28:35,440
and it's a you know half recent linux

676
00:28:35,440 --> 00:28:38,320
system you can actually start using http

677
00:28:38,320 --> 00:28:42,640
um that's that's

678
00:28:42,640 --> 00:28:44,320
i guess for this presentation in this

679
00:28:44,320 --> 00:28:46,240
context the most important

680
00:28:46,240 --> 00:28:49,679
difference um we could talk fireworks

681
00:28:49,679 --> 00:28:51,360
about this and i'm happy to take this

682
00:28:51,360 --> 00:28:52,880
offline with that as well

683
00:28:52,880 --> 00:28:55,520
um but i see there's more questions so

684
00:28:55,520 --> 00:28:58,559
maybe we can dive into those okay

685
00:28:58,559 --> 00:29:01,120
uh looks like we've got one more que

686
00:29:01,120 --> 00:29:02,159
actually it's a

687
00:29:02,159 --> 00:29:04,240
two-part question from the same person

688
00:29:04,240 --> 00:29:06,240
uh benson slicer is asking

689
00:29:06,240 --> 00:29:08,159
if you can quantify the performance

690
00:29:08,159 --> 00:29:09,440
difference between

691
00:29:09,440 --> 00:29:12,880
xtp and a full kernel stack for simple

692
00:29:12,880 --> 00:29:15,039
options like forwarding packets dropping

693
00:29:15,039 --> 00:29:16,559
etc

694
00:29:16,559 --> 00:29:19,840
and any insight on improving

695
00:29:19,840 --> 00:29:21,600
you know quantifying performance

696
00:29:21,600 --> 00:29:23,919
improvements on smart mix

697
00:29:23,919 --> 00:29:27,200
versus xd and kernel for packet

698
00:29:27,200 --> 00:29:29,200
forwarding across a bus

699
00:29:29,200 --> 00:29:32,320
and similar activities

700
00:29:34,559 --> 00:29:38,320
well we haven't actually

701
00:29:38,399 --> 00:29:41,760
we know that it's it can be

702
00:29:41,760 --> 00:29:44,480
almost line speed but we haven't really

703
00:29:44,480 --> 00:29:46,000
tested for performance

704
00:29:46,000 --> 00:29:49,760
uh yet uh we will do that

705
00:29:49,760 --> 00:29:52,399
we are have access to smart mix which

706
00:29:52,399 --> 00:29:53,600
can run xp

707
00:29:53,600 --> 00:29:56,480
programs so we will soon do that and

708
00:29:56,480 --> 00:29:57,600
then

709
00:29:57,600 --> 00:30:01,439
write a blog post about it as well

710
00:30:02,320 --> 00:30:04,960
but i've i've heard that dropping

711
00:30:04,960 --> 00:30:05,919
packets

712
00:30:05,919 --> 00:30:08,640
is about line speed especially if you're

713
00:30:08,640 --> 00:30:09,840
when it's on a smart

714
00:30:09,840 --> 00:30:13,919
smart knit okay great

715
00:30:13,919 --> 00:30:16,720
um i believe that is the last of the

716
00:30:16,720 --> 00:30:17,760
questions so

717
00:30:17,760 --> 00:30:20,240
uh thank you uh thank you again for

718
00:30:20,240 --> 00:30:21,440
bringing this presentation

719
00:30:21,440 --> 00:30:24,240
and thank you all for and thank you for

720
00:30:24,240 --> 00:30:33,200
answering questions

