1
00:00:03,690 --> 00:00:08,650
thanks a lot

2
00:00:05,260 --> 00:00:10,088
I hope the sound is okay all right so

3
00:00:08,650 --> 00:00:12,820
yeah

4
00:00:10,089 --> 00:00:15,309
my name is summit and a very warm

5
00:00:12,820 --> 00:00:16,690
welcome to day hack and it's pretty

6
00:00:15,309 --> 00:00:20,049
chilly out here so I hope the warm

7
00:00:16,690 --> 00:00:22,390
welcome helps you my talk is going to be

8
00:00:20,050 --> 00:00:24,820
about what for those of you who are not

9
00:00:22,390 --> 00:00:28,269
aware what is an open standard for

10
00:00:24,820 --> 00:00:30,550
token-based delegated access put in

11
00:00:28,269 --> 00:00:32,829
simple terms it means that if you are a

12
00:00:30,550 --> 00:00:34,930
resource owner you can grant a

13
00:00:32,829 --> 00:00:38,500
third-party application access to the

14
00:00:34,930 --> 00:00:40,539
resources that you own using OAuth so

15
00:00:38,500 --> 00:00:43,180
the talk is going to focus on the

16
00:00:40,539 --> 00:00:46,449
implementation pitfalls that we observe

17
00:00:43,180 --> 00:00:48,190
generally very frequently and it's going

18
00:00:46,449 --> 00:00:49,960
to focus on the attacks and we're going

19
00:00:48,190 --> 00:00:53,858
to talk about how to mitigate against

20
00:00:49,960 --> 00:00:57,370
those attacks so without further ado let

21
00:00:53,859 --> 00:00:58,960
me just get to my intro as Florent

22
00:00:57,370 --> 00:01:02,078
already mentioned I work for the product

23
00:00:58,960 --> 00:01:05,110
security team at Citrix also I lead the

24
00:01:02,079 --> 00:01:08,100
blue team so basically my job is to make

25
00:01:05,110 --> 00:01:10,720
Citrix products a little more secure and

26
00:01:08,100 --> 00:01:12,640
I am a web and mobile application

27
00:01:10,720 --> 00:01:15,820
security enthusiast and I've spoken at a

28
00:01:12,640 --> 00:01:16,210
bunch of conferences including in Sec

29
00:01:15,820 --> 00:01:18,369
world

30
00:01:16,210 --> 00:01:20,889
romhack security fest Def Con China

31
00:01:18,369 --> 00:01:27,158
blackhat Asia and apps like us in the

32
00:01:20,890 --> 00:01:31,799
past so the agenda for today is to cover

33
00:01:27,159 --> 00:01:34,270
both what is it and why do we need it

34
00:01:31,799 --> 00:01:36,040
we're going to talk about access tokens

35
00:01:34,270 --> 00:01:37,479
and identity tokens how they are

36
00:01:36,040 --> 00:01:39,340
different from each other and when they

37
00:01:37,479 --> 00:01:41,710
are used i didn'ti tokens are

38
00:01:39,340 --> 00:01:45,689
specifically used in open ID connect but

39
00:01:41,710 --> 00:01:48,399
we're going to cover that as well so and

40
00:01:45,689 --> 00:01:54,339
we'll also touch upon the various ground

41
00:01:48,399 --> 00:01:57,310
types that Earth has to offer and we

42
00:01:54,340 --> 00:02:02,259
will also look into how auth flow works

43
00:01:57,310 --> 00:02:04,060
for mobile applications finally we will

44
00:02:02,259 --> 00:02:06,939
come to the attacks and discuss the

45
00:02:04,060 --> 00:02:12,400
mitigation and we'll end up with a short

46
00:02:06,939 --> 00:02:14,310
Q&A sessions so why do we need in the

47
00:02:12,400 --> 00:02:15,810
first place let's

48
00:02:14,310 --> 00:02:18,480
try to understand this with the help of

49
00:02:15,810 --> 00:02:19,290
the scenario where you're logging in to

50
00:02:18,480 --> 00:02:21,840
linkedin.com

51
00:02:19,290 --> 00:02:23,690
you enter your LinkedIn credentials and

52
00:02:21,840 --> 00:02:26,940
you see your dashboard

53
00:02:23,690 --> 00:02:29,579
now what if LinkedIn wants to access

54
00:02:26,940 --> 00:02:31,620
your gmail contacts you know just to

55
00:02:29,580 --> 00:02:35,160
increase your contact list on LinkedIn

56
00:02:31,620 --> 00:02:36,769
so in order to do so you would have to

57
00:02:35,160 --> 00:02:39,000
give linked in some sort of

58
00:02:36,769 --> 00:02:42,599
authorization to access your gmail

59
00:02:39,000 --> 00:02:44,849
accounts contacts one way and a very

60
00:02:42,599 --> 00:02:46,530
silly way of doing it is to just give

61
00:02:44,849 --> 00:02:48,390
credentials to LinkedIn and it goes

62
00:02:46,530 --> 00:02:50,790
ahead and logs into your Gmail account

63
00:02:48,390 --> 00:02:53,730
gets your contact details and just sinks

64
00:02:50,790 --> 00:02:56,730
it up with LinkedIn so LinkedIn is your

65
00:02:53,730 --> 00:02:59,700
third party application here Gmail is

66
00:02:56,730 --> 00:03:01,470
your resource provider and it is hosting

67
00:02:59,700 --> 00:03:05,069
your resources which are the contacts

68
00:03:01,470 --> 00:03:06,750
and you are the resource owner so this

69
00:03:05,069 --> 00:03:09,179
is a very silly idea you shouldn't be

70
00:03:06,750 --> 00:03:12,239
sharing your credentials with a third

71
00:03:09,180 --> 00:03:14,340
party application what are the problems

72
00:03:12,239 --> 00:03:16,739
that you see or why is it a silly idea

73
00:03:14,340 --> 00:03:18,900
because the knowledge of your Gmail

74
00:03:16,739 --> 00:03:22,380
password allows LinkedIn to do far more

75
00:03:18,900 --> 00:03:24,299
than just fetch your contacts it can log

76
00:03:22,380 --> 00:03:26,459
into your drive scan your photographs

77
00:03:24,299 --> 00:03:31,920
and do pretty much everything that you

78
00:03:26,459 --> 00:03:35,190
would do with your credentials also

79
00:03:31,920 --> 00:03:37,679
access cannot be revoked from a single

80
00:03:35,190 --> 00:03:39,600
specific third party application because

81
00:03:37,680 --> 00:03:41,459
similarly you would be sharing your

82
00:03:39,600 --> 00:03:43,858
credentials with multiple third party

83
00:03:41,459 --> 00:03:45,989
and if you want to revoke access from a

84
00:03:43,859 --> 00:03:48,209
single third party you will be doing

85
00:03:45,989 --> 00:03:49,829
that by changing your credentials and if

86
00:03:48,209 --> 00:03:51,269
you change your credentials so the

87
00:03:49,829 --> 00:03:53,639
credential will change for all the third

88
00:03:51,269 --> 00:03:55,590
party applications not just one so you

89
00:03:53,639 --> 00:04:02,519
can't revoke access from a specific

90
00:03:55,590 --> 00:04:04,230
third party application another drawback

91
00:04:02,519 --> 00:04:06,389
is that linkdin would be required to

92
00:04:04,230 --> 00:04:07,768
store your credentials and you shouldn't

93
00:04:06,389 --> 00:04:09,810
be trusting it with your Gmail

94
00:04:07,769 --> 00:04:12,750
credentials anyway so that's a bad idea

95
00:04:09,810 --> 00:04:14,010
and Google will be required to mandate

96
00:04:12,750 --> 00:04:19,470
really support password-based

97
00:04:14,010 --> 00:04:22,440
authentication so that's where

98
00:04:19,470 --> 00:04:24,540
came into being and it's a protocol for

99
00:04:22,440 --> 00:04:26,940
delegating authorization supported by

100
00:04:24,540 --> 00:04:30,290
all platforms web desktop and native

101
00:04:26,940 --> 00:04:33,270
apps native apps include mobile apps so

102
00:04:30,290 --> 00:04:35,490
the advantages of auth is that the scope

103
00:04:33,270 --> 00:04:37,560
of access can be restricted to a

104
00:04:35,490 --> 00:04:40,860
specific third-party application you can

105
00:04:37,560 --> 00:04:45,650
just allow access to your contacts only

106
00:04:40,860 --> 00:04:45,650
so that's one specific advantage and

107
00:04:46,700 --> 00:04:51,390
access granted can be revoked from a

108
00:04:49,230 --> 00:04:54,450
particular third-party application with

109
00:04:51,390 --> 00:04:56,159
the wot it avoids sharing of your

110
00:04:54,450 --> 00:04:59,880
credentials with the third-party that's

111
00:04:56,160 --> 00:05:01,440
a major win and finally it lays down a

112
00:04:59,880 --> 00:05:03,960
foundation for an authentication

113
00:05:01,440 --> 00:05:10,830
protocol which is also called Open ID

114
00:05:03,960 --> 00:05:13,890
Connect so before we start discussing

115
00:05:10,830 --> 00:05:15,719
the flow of Earth I would like to

116
00:05:13,890 --> 00:05:18,870
introduce some of the entities that are

117
00:05:15,720 --> 00:05:20,970
involved in a typical earth flow the

118
00:05:18,870 --> 00:05:22,860
first one is the resource owner himself

119
00:05:20,970 --> 00:05:27,510
if this is the end user who owns the

120
00:05:22,860 --> 00:05:29,610
resources then we have the client or the

121
00:05:27,510 --> 00:05:31,800
application or the relying party all

122
00:05:29,610 --> 00:05:35,640
these three terms are synonymous and are

123
00:05:31,800 --> 00:05:38,340
used interchangeably and this entity is

124
00:05:35,640 --> 00:05:40,469
basically the one which is requesting

125
00:05:38,340 --> 00:05:42,239
access to the end users resource and

126
00:05:40,470 --> 00:05:48,180
this was linked in in our previous

127
00:05:42,240 --> 00:05:50,520
example then we have the resource server

128
00:05:48,180 --> 00:05:51,870
which is the server which hosts the

129
00:05:50,520 --> 00:05:59,130
resources of the end user

130
00:05:51,870 --> 00:06:00,900
this was Gmail in our case authorization

131
00:05:59,130 --> 00:06:03,409
server is the entity that is responsible

132
00:06:00,900 --> 00:06:06,419
for authenticating the user and

133
00:06:03,410 --> 00:06:09,390
prompting for authorization and once the

134
00:06:06,419 --> 00:06:11,219
end user grants that authorization the

135
00:06:09,390 --> 00:06:13,860
auth server risk is responsible for

136
00:06:11,220 --> 00:06:15,840
generating the access tokens and sending

137
00:06:13,860 --> 00:06:18,210
it back to the client or the application

138
00:06:15,840 --> 00:06:22,590
and the relying party and this was

139
00:06:18,210 --> 00:06:25,969
Google in our case finally the user

140
00:06:22,590 --> 00:06:25,969
agent this is nothing but the browser

141
00:06:27,660 --> 00:06:33,270
so we also need to understand that

142
00:06:30,110 --> 00:06:36,150
before the entire or the OAuth flow

143
00:06:33,270 --> 00:06:37,740
starts the authorization server also

144
00:06:36,150 --> 00:06:39,390
needs to know what all client

145
00:06:37,740 --> 00:06:42,630
applications are going to interact with

146
00:06:39,390 --> 00:06:44,520
it and this is a mandatory step called

147
00:06:42,630 --> 00:06:47,100
client registration which is required

148
00:06:44,520 --> 00:06:48,870
before proceeding with the workflow so

149
00:06:47,100 --> 00:06:51,540
what happens in this step is that the

150
00:06:48,870 --> 00:06:53,910
client tells the auth server that see I

151
00:06:51,540 --> 00:06:56,850
am going to try and authenticate using

152
00:06:53,910 --> 00:07:00,240
your service so here are my details just

153
00:06:56,850 --> 00:07:02,000
register me for your OAuth flow so the

154
00:07:00,240 --> 00:07:05,400
client communicates application name

155
00:07:02,000 --> 00:07:07,650
website and the redirect URL to the auth

156
00:07:05,400 --> 00:07:09,900
server the auth server generates the

157
00:07:07,650 --> 00:07:14,130
client ID and the client secret for the

158
00:07:09,900 --> 00:07:16,349
client the odd server also stores the

159
00:07:14,130 --> 00:07:19,800
client ID and the redirect URI mapping

160
00:07:16,350 --> 00:07:21,990
with itself and the redirect URI is

161
00:07:19,800 --> 00:07:24,810
basically used to send back access

162
00:07:21,990 --> 00:07:28,440
tokens to the client after when the

163
00:07:24,810 --> 00:07:30,090
client when the client is actually

164
00:07:28,440 --> 00:07:32,370
trying to access the resource so the

165
00:07:30,090 --> 00:07:33,750
redirect URI is used by the auth server

166
00:07:32,370 --> 00:07:37,530
to send back access tokens or

167
00:07:33,750 --> 00:07:39,360
authorization code finally the client ID

168
00:07:37,530 --> 00:07:42,450
and the client secret is returned to the

169
00:07:39,360 --> 00:07:45,120
client now this client ID and secret is

170
00:07:42,450 --> 00:07:47,250
used for client or authentication with

171
00:07:45,120 --> 00:07:50,010
the auth server and we'll see where that

172
00:07:47,250 --> 00:07:52,650
happens in the entire flow but this is a

173
00:07:50,010 --> 00:07:55,830
mandatory step required before we begin

174
00:07:52,650 --> 00:07:57,450
the OAuth flow so and of course as the

175
00:07:55,830 --> 00:07:59,700
name suggests the client secret is a

176
00:07:57,450 --> 00:08:03,690
confidential information and should be

177
00:07:59,700 --> 00:08:06,180
kept secret by the client itself for

178
00:08:03,690 --> 00:08:09,030
those applications that cannot keep the

179
00:08:06,180 --> 00:08:10,980
client secret confidential like a mobile

180
00:08:09,030 --> 00:08:12,690
application or a single page application

181
00:08:10,980 --> 00:08:15,270
the client secret should never be used

182
00:08:12,690 --> 00:08:17,610
and the reason for that is that mobile

183
00:08:15,270 --> 00:08:20,010
applications can be reversed engineered

184
00:08:17,610 --> 00:08:22,860
and the client secret can be figured out

185
00:08:20,010 --> 00:08:24,360
easily or even you can intercept the

186
00:08:22,860 --> 00:08:24,810
traffic and find out what's the client

187
00:08:24,360 --> 00:08:27,390
secret

188
00:08:24,810 --> 00:08:29,880
so whatever application is running at

189
00:08:27,390 --> 00:08:31,860
the end-users device cannot be trusted

190
00:08:29,880 --> 00:08:35,880
with the client secret and the client

191
00:08:31,860 --> 00:08:38,280
secret should never be used with it so

192
00:08:35,880 --> 00:08:40,679
let's just see how earth works in a

193
00:08:38,280 --> 00:08:41,039
nutshell and I've listed down all the

194
00:08:40,679 --> 00:08:43,829
entry

195
00:08:41,039 --> 00:08:45,209
the odds server here when we have the

196
00:08:43,830 --> 00:08:48,690
relying party or the client application

197
00:08:45,210 --> 00:08:50,880
here which is Stack Exchange then we

198
00:08:48,690 --> 00:08:56,820
have the resource server and the end

199
00:08:50,880 --> 00:08:59,460
user here so the end user visits Stack

200
00:08:56,820 --> 00:09:02,040
Exchange and Stack Exchange shows this

201
00:08:59,460 --> 00:09:04,110
option of logging in with two different

202
00:09:02,040 --> 00:09:05,969
odds servers because it has previously

203
00:09:04,110 --> 00:09:08,160
registered with Google and Facebook as

204
00:09:05,970 --> 00:09:09,480
the odds server so the client has

205
00:09:08,160 --> 00:09:12,290
registered with Google and Facebook

206
00:09:09,480 --> 00:09:16,350
let's say that the user chooses Google

207
00:09:12,290 --> 00:09:18,569
and Stack Exchange will initiate an

208
00:09:16,350 --> 00:09:23,160
authorization request and redirect the

209
00:09:18,570 --> 00:09:26,780
user to the auth server where the end

210
00:09:23,160 --> 00:09:30,360
user will be expected to log in and

211
00:09:26,780 --> 00:09:32,250
after logging in an authorization prompt

212
00:09:30,360 --> 00:09:36,180
will be shown to the end user where

213
00:09:32,250 --> 00:09:38,550
Stack Exchange is trying to access some

214
00:09:36,180 --> 00:09:41,130
information of the end user would you

215
00:09:38,550 --> 00:09:43,469
like to grant it or not and once the end

216
00:09:41,130 --> 00:09:46,200
user accepts this authorization prompt

217
00:09:43,470 --> 00:09:49,080
an authorization code is generated and

218
00:09:46,200 --> 00:09:51,090
sent back at the clients redirect URL

219
00:09:49,080 --> 00:09:53,220
that's where the redirect URI is

220
00:09:51,090 --> 00:09:54,600
actually used the redirect URI is

221
00:09:53,220 --> 00:09:57,960
nothing but the URL of the client

222
00:09:54,600 --> 00:10:01,260
application and once the client receives

223
00:09:57,960 --> 00:10:03,870
the auth code it can hit the token

224
00:10:01,260 --> 00:10:07,080
endpoint at the auth server to get back

225
00:10:03,870 --> 00:10:09,890
an access token and the access token

226
00:10:07,080 --> 00:10:12,720
again is sent back to the redirect URI

227
00:10:09,890 --> 00:10:15,180
now that the client has some form of

228
00:10:12,720 --> 00:10:17,460
authorization which is basically in

229
00:10:15,180 --> 00:10:19,500
terms of the access token it can then

230
00:10:17,460 --> 00:10:22,370
hit the resource servers endpoints using

231
00:10:19,500 --> 00:10:25,310
the token and fetch back the resources

232
00:10:22,370 --> 00:10:29,850
so that's how our typical workflow works

233
00:10:25,310 --> 00:10:32,069
and the Open ID Connect flow is pretty

234
00:10:29,850 --> 00:10:34,050
much same in nature except that in step

235
00:10:32,070 --> 00:10:35,880
5 you will also see an identity token

236
00:10:34,050 --> 00:10:40,439
being generated in addition to the

237
00:10:35,880 --> 00:10:43,170
access token now the ID token is not

238
00:10:40,440 --> 00:10:44,910
used for authorization it's an identity

239
00:10:43,170 --> 00:10:47,459
token and contains some information

240
00:10:44,910 --> 00:10:49,980
which convey the identity of the

241
00:10:47,460 --> 00:10:51,600
end-user who has logged in and this is

242
00:10:49,980 --> 00:10:54,370
consumed by the client application

243
00:10:51,600 --> 00:10:56,170
itself to populate the UI

244
00:10:54,370 --> 00:10:59,470
with the username and other user details

245
00:10:56,170 --> 00:11:00,880
so the ID token has never sent the

246
00:10:59,470 --> 00:11:02,680
resource server in fact the Reis

247
00:11:00,880 --> 00:11:10,180
resource server doesn't need the ID

248
00:11:02,680 --> 00:11:12,760
token at all the client consumes it the

249
00:11:10,180 --> 00:11:15,040
odd server is generally opaque and when

250
00:11:12,760 --> 00:11:15,760
I say opaque you can't really make sense

251
00:11:15,040 --> 00:11:17,469
out of it

252
00:11:15,760 --> 00:11:19,029
you cannot decode it to figure out any

253
00:11:17,470 --> 00:11:21,010
other information or inferred

254
00:11:19,029 --> 00:11:22,920
information from it it just conveys

255
00:11:21,010 --> 00:11:25,800
authorization and it is consumed by the

256
00:11:22,920 --> 00:11:29,800
resource server as we just discussed

257
00:11:25,800 --> 00:11:32,620
whereas the identity token is a jot and

258
00:11:29,800 --> 00:11:34,540
if you decode the jot you will get a lot

259
00:11:32,620 --> 00:11:37,960
of user details about the user who

260
00:11:34,540 --> 00:11:40,360
logged in and as I mentioned before it

261
00:11:37,960 --> 00:11:42,810
conveys the users identity information

262
00:11:40,360 --> 00:11:45,460
like the user's name email address etc

263
00:11:42,810 --> 00:11:47,920
it is consumed by the client for

264
00:11:45,460 --> 00:11:56,110
displaying on the UI details about the

265
00:11:47,920 --> 00:11:58,360
user so this brings us to the various

266
00:11:56,110 --> 00:12:00,700
grants that worth has to offer there are

267
00:11:58,360 --> 00:12:02,470
primarily four different grants of which

268
00:12:00,700 --> 00:12:04,510
the top two are the most favored ones

269
00:12:02,470 --> 00:12:07,900
where famous ones the authorization code

270
00:12:04,510 --> 00:12:09,700
grant and the implicit drug these grants

271
00:12:07,900 --> 00:12:13,569
are used in different scenarios

272
00:12:09,700 --> 00:12:16,170
I have a short diagram which explains in

273
00:12:13,570 --> 00:12:18,160
what scenario to use which one and but

274
00:12:16,170 --> 00:12:20,020
throughout the presentation we'll be

275
00:12:18,160 --> 00:12:24,400
mostly talking about auth code grant

276
00:12:20,020 --> 00:12:28,120
flow and the implicit grant flow so

277
00:12:24,400 --> 00:12:30,339
which grant to use when simply put it's

278
00:12:28,120 --> 00:12:33,700
like if the application is the resource

279
00:12:30,339 --> 00:12:36,610
owner itself so let's say that Facebook

280
00:12:33,700 --> 00:12:38,980
wants to effect some resources that

281
00:12:36,610 --> 00:12:41,050
Facebook itself is owning like the

282
00:12:38,980 --> 00:12:44,170
banner or some details or the just the

283
00:12:41,050 --> 00:12:46,779
templates or whatever so Facebook is

284
00:12:44,170 --> 00:12:48,880
trying to fetch its own resources so

285
00:12:46,779 --> 00:12:53,020
that's where you go for the client

286
00:12:48,880 --> 00:12:55,060
credentials grant and like in the

287
00:12:53,020 --> 00:12:57,459
previous example where we had a third

288
00:12:55,060 --> 00:12:59,140
party application called LinkedIn and it

289
00:12:57,459 --> 00:13:02,560
was trying to access Google resources

290
00:12:59,140 --> 00:13:04,750
from of the end user that's where the

291
00:13:02,560 --> 00:13:06,310
authorization code grant is used and

292
00:13:04,750 --> 00:13:09,300
this is the most famous one you'll see

293
00:13:06,310 --> 00:13:09,300
across website

294
00:13:10,810 --> 00:13:16,790
so if the application is absolutely

295
00:13:13,880 --> 00:13:18,589
trusted with user credentials then you

296
00:13:16,790 --> 00:13:20,060
can go for a resource owner password

297
00:13:18,589 --> 00:13:22,250
credential grant which would mean that

298
00:13:20,060 --> 00:13:24,680
if we consider the previous situation if

299
00:13:22,250 --> 00:13:26,930
you are willing to share your Google

300
00:13:24,680 --> 00:13:29,029
credentials with LinkedIn then you can

301
00:13:26,930 --> 00:13:34,029
use this one which is called resource

302
00:13:29,029 --> 00:13:37,070
owner password credentials run and

303
00:13:34,029 --> 00:13:40,610
finally if the application is a mobile

304
00:13:37,070 --> 00:13:42,980
app or a single page application you go

305
00:13:40,610 --> 00:13:44,930
for the authorization code grant along

306
00:13:42,980 --> 00:13:46,910
with something known as proof key for

307
00:13:44,930 --> 00:13:50,209
code exchange which we'll discuss in

308
00:13:46,910 --> 00:13:54,410
detail later on this is also abbreviated

309
00:13:50,209 --> 00:13:56,060
as pixie ekc he for single page

310
00:13:54,410 --> 00:13:58,520
applications previously we could have

311
00:13:56,060 --> 00:14:00,739
used implicit grant as well but off late

312
00:13:58,520 --> 00:14:02,329
this technique has not been used in

313
00:14:00,740 --> 00:14:05,270
practice because it's vulnerable to a

314
00:14:02,330 --> 00:14:07,070
lot of attacks and it leaks the access

315
00:14:05,270 --> 00:14:09,170
tokens everywhere in your browser

316
00:14:07,070 --> 00:14:11,029
history and in the reference so it's

317
00:14:09,170 --> 00:14:13,099
always used to it it's always good to

318
00:14:11,029 --> 00:14:19,100
use authorization code grant with pixie

319
00:14:13,100 --> 00:14:21,200
for single page apps as well so I'm a

320
00:14:19,100 --> 00:14:26,170
big fan of Marvel and I made this small

321
00:14:21,200 --> 00:14:28,490
analogy with Avengers infinity war so

322
00:14:26,170 --> 00:14:32,300
the resource server will be played by

323
00:14:28,490 --> 00:14:34,660
the soulstone and as you would know if

324
00:14:32,300 --> 00:14:37,939
you've seen the movie the Red Skull

325
00:14:34,660 --> 00:14:41,569
owned or knew or had possession of the

326
00:14:37,940 --> 00:14:44,510
soul stone so resource owner which is

327
00:14:41,570 --> 00:14:46,310
Red Skull has the soul stone and then we

328
00:14:44,510 --> 00:14:51,200
have Thanos who wanted access to the

329
00:14:46,310 --> 00:14:53,660
soul stone and then we have Gamora Hyun

330
00:14:51,200 --> 00:14:55,850
who knew where the soul stone is it was

331
00:14:53,660 --> 00:14:58,670
on war meat and she could supervise

332
00:14:55,850 --> 00:15:02,890
access to it in a way so she'll play the

333
00:14:58,670 --> 00:15:05,660
role of the auth server so let's see how

334
00:15:02,890 --> 00:15:09,040
we just saw the flow in a nutshell now

335
00:15:05,660 --> 00:15:11,569
we'll discuss more details on it so

336
00:15:09,040 --> 00:15:14,180
client what Thanos wants to access the

337
00:15:11,570 --> 00:15:16,430
soul stone or the resource he hits the

338
00:15:14,180 --> 00:15:18,770
resource endpoint and gets an

339
00:15:16,430 --> 00:15:21,709
unauthorised message because he doesn't

340
00:15:18,770 --> 00:15:24,360
still have any token to them access to

341
00:15:21,709 --> 00:15:28,498
so the client then redirects the

342
00:15:24,360 --> 00:15:30,600
end-user to the authorization server

343
00:15:28,499 --> 00:15:32,639
where the end user is going to

344
00:15:30,600 --> 00:15:35,790
authenticate and grant the authorization

345
00:15:32,639 --> 00:15:37,259
and once the auth code is generated and

346
00:15:35,790 --> 00:15:39,120
sent back to the client

347
00:15:37,259 --> 00:15:41,040
we know that the client will now

348
00:15:39,120 --> 00:15:43,999
exchange this for an access token at the

349
00:15:41,040 --> 00:15:47,339
token endpoint get back the token and

350
00:15:43,999 --> 00:15:49,110
finally hit the token and finally hit

351
00:15:47,339 --> 00:15:52,139
the resource endpoint with the token and

352
00:15:49,110 --> 00:15:54,749
get back the resource so if you notice

353
00:15:52,139 --> 00:15:56,759
the client credentials are also required

354
00:15:54,749 --> 00:15:59,160
in this step for authenticating the

355
00:15:56,759 --> 00:16:01,139
client with the auth server now this is

356
00:15:59,160 --> 00:16:05,939
where the client ID and client secret is

357
00:16:01,139 --> 00:16:09,709
sent to the auth server so Tanis is

358
00:16:05,939 --> 00:16:13,248
happy he gets the soulstone finally and

359
00:16:09,709 --> 00:16:15,839
if you see the traffic on the wire

360
00:16:13,249 --> 00:16:17,249
you're hitting in the authorization

361
00:16:15,839 --> 00:16:20,309
request you are hitting the auth

362
00:16:17,249 --> 00:16:23,309
endpoint on the earth server along with

363
00:16:20,309 --> 00:16:26,370
some parameters in the request which

364
00:16:23,309 --> 00:16:29,910
includes the redirect URI the scope and

365
00:16:26,370 --> 00:16:32,939
the state so the redirect URI is nothing

366
00:16:29,910 --> 00:16:37,230
but the URI of the application or the

367
00:16:32,939 --> 00:16:40,349
client and the scope is else the auth

368
00:16:37,230 --> 00:16:42,809
server what kind of details the client

369
00:16:40,350 --> 00:16:44,639
is trying to access in this case the

370
00:16:42,809 --> 00:16:47,819
client is trying to access photos of the

371
00:16:44,639 --> 00:16:51,300
user and the state parameter is used to

372
00:16:47,819 --> 00:16:56,279
avoid CSRF attacks and we will see how

373
00:16:51,300 --> 00:16:58,378
later on so in the response you will see

374
00:16:56,279 --> 00:17:01,019
that the authorization code is returned

375
00:16:58,379 --> 00:17:06,149
and the state parameter is reflected

376
00:17:01,019 --> 00:17:08,099
back as it is then finally when the

377
00:17:06,148 --> 00:17:10,979
token exchange steps happen step happens

378
00:17:08,099 --> 00:17:13,408
the auth code is expected in the request

379
00:17:10,980 --> 00:17:15,029
parameter along with the client secret

380
00:17:13,409 --> 00:17:17,189
and the client ID client credentials

381
00:17:15,029 --> 00:17:19,230
basically and this is the token endpoint

382
00:17:17,189 --> 00:17:24,689
which is being hit and as a response to

383
00:17:19,230 --> 00:17:25,589
it you will get back the access token so

384
00:17:24,689 --> 00:17:31,860
what are the advantage

385
00:17:25,589 --> 00:17:33,330
of using the odd quadrant flow number

386
00:17:31,860 --> 00:17:35,729
one it provides the ability to

387
00:17:33,330 --> 00:17:40,408
authenticate the client what's happening

388
00:17:35,730 --> 00:17:42,720
right here next are the access token

389
00:17:40,409 --> 00:17:45,150
never really gets league into the

390
00:17:42,720 --> 00:17:47,820
browser's history or in the ref low head

391
00:17:45,150 --> 00:17:51,450
oh that's because it comes in as a post

392
00:17:47,820 --> 00:17:55,039
response to the to the client itself and

393
00:17:51,450 --> 00:17:55,039
it never goes through the users browser

394
00:17:56,870 --> 00:18:02,729
so this brings us to implicit grant and

395
00:17:59,779 --> 00:18:05,399
if you see the entire flow it is pretty

396
00:18:02,730 --> 00:18:07,950
much same except that there's no

397
00:18:05,399 --> 00:18:11,489
requirement of the authorization code

398
00:18:07,950 --> 00:18:13,260
it never gets generated except instead

399
00:18:11,490 --> 00:18:15,870
when you are hitting the authorized

400
00:18:13,260 --> 00:18:19,379
endpoint or token is def generated and

401
00:18:15,870 --> 00:18:21,299
sent back to the client directly and if

402
00:18:19,380 --> 00:18:23,520
you notice the traffic on the wire

403
00:18:21,299 --> 00:18:25,289
you'll see that the authorization

404
00:18:23,520 --> 00:18:27,120
request looks pretty much the same in

405
00:18:25,289 --> 00:18:28,679
the response there's no earth code

406
00:18:27,120 --> 00:18:33,479
instead the access token is directly

407
00:18:28,679 --> 00:18:35,340
sent back to the application well there

408
00:18:33,480 --> 00:18:37,110
are a few disadvantages of this there's

409
00:18:35,340 --> 00:18:39,270
no client authentication involved and

410
00:18:37,110 --> 00:18:40,949
the access token can end up in the

411
00:18:39,270 --> 00:18:44,010
browser's history because it's coming in

412
00:18:40,950 --> 00:18:47,909
as the response it's in the redirect

413
00:18:44,010 --> 00:18:49,919
URIs parameter so it can end up in your

414
00:18:47,909 --> 00:18:52,320
browser's history and it can also leak

415
00:18:49,919 --> 00:18:58,470
in reference when you are redirecting to

416
00:18:52,320 --> 00:19:00,629
a different third-party application so

417
00:18:58,470 --> 00:19:03,539
this brings us to earth for mobile

418
00:19:00,630 --> 00:19:06,240
clients and the blueprint remains the

419
00:19:03,539 --> 00:19:08,460
same or the client initiates the earth

420
00:19:06,240 --> 00:19:11,010
request end user authenticates and

421
00:19:08,460 --> 00:19:13,140
approves server returns the control with

422
00:19:11,010 --> 00:19:15,330
the auth code the auth code is exchanged

423
00:19:13,140 --> 00:19:19,200
for an access token and the protected

424
00:19:15,330 --> 00:19:21,720
api's are invoked but let's go through

425
00:19:19,200 --> 00:19:23,880
the details on how mobile applications

426
00:19:21,720 --> 00:19:28,770
are different from web applications when

427
00:19:23,880 --> 00:19:30,390
it comes to earth so here I have the

428
00:19:28,770 --> 00:19:33,059
resource which is the cloud API

429
00:19:30,390 --> 00:19:36,179
endpoints and we have the auth server

430
00:19:33,059 --> 00:19:38,580
here and this is the mobile application

431
00:19:36,179 --> 00:19:40,220
on executing on the client device and

432
00:19:38,580 --> 00:19:44,129
the

433
00:19:40,220 --> 00:19:46,740
so once the client needs to access some

434
00:19:44,129 --> 00:19:50,699
resources it will invoke the browser and

435
00:19:46,740 --> 00:19:54,299
redirect the browser to the authorized

436
00:19:50,700 --> 00:19:56,690
endpoint of the auth server where the

437
00:19:54,299 --> 00:19:59,700
user will of course authenticate and

438
00:19:56,690 --> 00:20:01,740
once the user authenticates an

439
00:19:59,700 --> 00:20:03,950
authorization prompt will be shown to

440
00:20:01,740 --> 00:20:06,749
the end-user on the native application

441
00:20:03,950 --> 00:20:09,990
once the user approves or sets of this

442
00:20:06,749 --> 00:20:13,070
authorization the auth code is generated

443
00:20:09,990 --> 00:20:15,480
by the author and sent to the browser

444
00:20:13,070 --> 00:20:17,639
now this is where things get tricky

445
00:20:15,480 --> 00:20:20,249
because the browser needs to convey the

446
00:20:17,639 --> 00:20:23,340
auth code to the native application and

447
00:20:20,249 --> 00:20:26,279
it needs to figure out which application

448
00:20:23,340 --> 00:20:27,928
should I send this earth code to for

449
00:20:26,279 --> 00:20:31,019
that we have something known as custom

450
00:20:27,929 --> 00:20:33,659
URL scheme so every application can

451
00:20:31,019 --> 00:20:35,999
register a custom URL scheme on the

452
00:20:33,659 --> 00:20:38,789
operating system which is nothing but a

453
00:20:35,999 --> 00:20:41,549
callback handling mechanism so the

454
00:20:38,789 --> 00:20:44,490
browser when it gets a URL starting with

455
00:20:41,549 --> 00:20:46,918
XCOM my caught my app it will know that

456
00:20:44,490 --> 00:20:52,919
this is the particular application that

457
00:20:46,919 --> 00:20:55,320
I need to convey the code to so every

458
00:20:52,919 --> 00:20:57,960
application can register for certain

459
00:20:55,320 --> 00:21:00,299
custom URL schemes let's see how that

460
00:20:57,960 --> 00:21:02,700
happens so in the manifest file on

461
00:21:00,299 --> 00:21:06,080
Android operating system you can declare

462
00:21:02,700 --> 00:21:09,210
a scheme with XCOM my coop app and

463
00:21:06,080 --> 00:21:11,549
whenever the browser sees any traffic

464
00:21:09,210 --> 00:21:12,899
coming in for this particular scheme it

465
00:21:11,549 --> 00:21:17,129
will redirect it to the native

466
00:21:12,899 --> 00:21:19,080
application that registered for it so

467
00:21:17,129 --> 00:21:22,678
once the native application gets the

468
00:21:19,080 --> 00:21:25,769
authorization code it can then hit the

469
00:21:22,679 --> 00:21:29,999
token endpoint and get back the bearer

470
00:21:25,769 --> 00:21:32,249
token in response that's the auth code

471
00:21:29,999 --> 00:21:35,389
there in the request and the client ID

472
00:21:32,249 --> 00:21:38,490
grant type of the application and

473
00:21:35,389 --> 00:21:41,699
finally once the native application gets

474
00:21:38,490 --> 00:21:43,590
access to the access token it can hit

475
00:21:41,700 --> 00:21:46,619
the endpoints ready the resource

476
00:21:43,590 --> 00:21:49,459
endpoints with the token embedded in the

477
00:21:46,619 --> 00:21:49,459
authorization header

478
00:21:51,600 --> 00:21:56,949
so we've talked a lot of theoretical

479
00:21:54,340 --> 00:21:59,169
stuff already and time for some action

480
00:21:56,950 --> 00:22:02,680
so we will talk about some attacks and

481
00:21:59,170 --> 00:22:04,960
how they can be mitigated we'll start

482
00:22:02,680 --> 00:22:07,420
with the authorization code intercept

483
00:22:04,960 --> 00:22:12,970
attack and this specific attack is on

484
00:22:07,420 --> 00:22:14,860
mobile applications and the precondition

485
00:22:12,970 --> 00:22:16,810
for this attack is that the client

486
00:22:14,860 --> 00:22:18,340
secret shouldn't be provision and since

487
00:22:16,810 --> 00:22:20,830
it's a mobile application we already

488
00:22:18,340 --> 00:22:22,959
know that client secret is not even

489
00:22:20,830 --> 00:22:25,720
provision for mobile apps or is useless

490
00:22:22,960 --> 00:22:27,550
it can easily be figured out that's one

491
00:22:25,720 --> 00:22:29,500
precondition the other one is that the

492
00:22:27,550 --> 00:22:31,149
attacker should be able to install a

493
00:22:29,500 --> 00:22:34,960
malicious application on the mobile

494
00:22:31,150 --> 00:22:36,790
device of the end user so here on the

495
00:22:34,960 --> 00:22:38,770
left-hand side on the end-users device

496
00:22:36,790 --> 00:22:41,649
you have a legit app and then you have

497
00:22:38,770 --> 00:22:43,870
the malicious application the third

498
00:22:41,650 --> 00:22:45,730
assumption is and it's also possible

499
00:22:43,870 --> 00:22:47,649
very possible because the malicious

500
00:22:45,730 --> 00:22:49,750
application can register for the same

501
00:22:47,650 --> 00:22:53,020
custom URL scheme as that of the

502
00:22:49,750 --> 00:22:57,580
legitimate application and there's no

503
00:22:53,020 --> 00:22:59,110
nothing hindering that so you see where

504
00:22:57,580 --> 00:23:00,639
this is going now because when the

505
00:22:59,110 --> 00:23:02,800
author authorization request is

506
00:23:00,640 --> 00:23:05,170
generated and the auth code is sent back

507
00:23:02,800 --> 00:23:06,760
to the browser the browser now knows

508
00:23:05,170 --> 00:23:08,620
that there are two apps that have

509
00:23:06,760 --> 00:23:10,750
registered with the same custom URL

510
00:23:08,620 --> 00:23:13,120
scheme and it will redirect the auth

511
00:23:10,750 --> 00:23:15,190
code to both of them and now the

512
00:23:13,120 --> 00:23:17,560
malicious application can also exchange

513
00:23:15,190 --> 00:23:22,300
this auth code for an access token and

514
00:23:17,560 --> 00:23:27,399
get access to the users resources so how

515
00:23:22,300 --> 00:23:30,790
do we mitigate this attack so there's

516
00:23:27,400 --> 00:23:31,630
something you should not use custom URL

517
00:23:30,790 --> 00:23:33,899
schemes at all

518
00:23:31,630 --> 00:23:36,220
because there's no naming Authority and

519
00:23:33,900 --> 00:23:39,760
multiple apps can register for the same

520
00:23:36,220 --> 00:23:42,070
custom URL schemes instead you said you

521
00:23:39,760 --> 00:23:43,240
should always use claimed HTTP scheme

522
00:23:42,070 --> 00:23:46,750
you are every direction

523
00:23:43,240 --> 00:23:50,500
now what's that so in with claimed HTTP

524
00:23:46,750 --> 00:23:54,730
scheme the scheme remains HTTPS followed

525
00:23:50,500 --> 00:23:56,740
by the fqn of the application now every

526
00:23:54,730 --> 00:23:59,290
application when it registers for this

527
00:23:56,740 --> 00:24:02,230
particular HTTP scheme it needs to prove

528
00:23:59,290 --> 00:24:02,850
that it owns the fqdn so at any point of

529
00:24:02,230 --> 00:24:04,770
time that

530
00:24:02,850 --> 00:24:08,149
not be more than one application that

531
00:24:04,770 --> 00:24:12,270
registers a particular STD and you are a

532
00:24:08,150 --> 00:24:14,160
so basically the destination app is

533
00:24:12,270 --> 00:24:18,450
guaranteed by the opposite operating

534
00:24:14,160 --> 00:24:20,340
system to the auth server but still if

535
00:24:18,450 --> 00:24:22,380
you are still using some legacy apps and

536
00:24:20,340 --> 00:24:24,810
you have a lot of custom URL schemes

537
00:24:22,380 --> 00:24:27,030
being used then what you can do is use

538
00:24:24,810 --> 00:24:31,200
proof key for code exchange also known

539
00:24:27,030 --> 00:24:34,980
as pixie and it adds on some elements to

540
00:24:31,200 --> 00:24:37,110
the typical worth flow if you go through

541
00:24:34,980 --> 00:24:38,910
the RFC you'll notice that there's a

542
00:24:37,110 --> 00:24:41,490
code verifier that needs to be generated

543
00:24:38,910 --> 00:24:43,680
by the client which is nothing but an

544
00:24:41,490 --> 00:24:48,210
alpha numeric value pseudo-random

545
00:24:43,680 --> 00:24:50,670
alphanumeric value and the hash of the

546
00:24:48,210 --> 00:24:52,410
code verifier needs to be sent along the

547
00:24:50,670 --> 00:24:54,690
authorization request along with the

548
00:24:52,410 --> 00:24:58,080
hash method so T underscore M is the

549
00:24:54,690 --> 00:25:01,110
hashing method and the code verified is

550
00:24:58,080 --> 00:25:07,159
the hashed value of the code verify also

551
00:25:01,110 --> 00:25:10,439
known as the code challenge so once this

552
00:25:07,160 --> 00:25:12,300
value asked value reaches the server the

553
00:25:10,440 --> 00:25:16,260
server stores it as the code challenge

554
00:25:12,300 --> 00:25:18,210
value and in the response the

555
00:25:16,260 --> 00:25:20,790
authorization code is sent back to the

556
00:25:18,210 --> 00:25:22,440
client and as we already know using the

557
00:25:20,790 --> 00:25:24,600
auth code intercept attack the malicious

558
00:25:22,440 --> 00:25:29,520
client can also get the authorization

559
00:25:24,600 --> 00:25:33,090
code but in the next request to the

560
00:25:29,520 --> 00:25:35,070
token endpoint the auth server expects

561
00:25:33,090 --> 00:25:38,250
the code verifies value from the client

562
00:25:35,070 --> 00:25:40,230
and once the code verify reaches the

563
00:25:38,250 --> 00:25:42,240
server it computes the hash again and

564
00:25:40,230 --> 00:25:44,850
matches it with the previously stored

565
00:25:42,240 --> 00:25:47,390
code challenge value if they are equal

566
00:25:44,850 --> 00:25:51,300
only then the access token is returned

567
00:25:47,390 --> 00:25:53,130
so the malicious client can never get to

568
00:25:51,300 --> 00:25:55,260
know the code verifies value because it

569
00:25:53,130 --> 00:25:58,470
has been generated by the client the

570
00:25:55,260 --> 00:26:00,090
legitimate client and therefore even if

571
00:25:58,470 --> 00:26:02,550
the malicious client gets the auth code

572
00:26:00,090 --> 00:26:05,760
it cannot make this request successfully

573
00:26:02,550 --> 00:26:07,350
and get the access token value because

574
00:26:05,760 --> 00:26:12,300
it doesn't know the code could verify

575
00:26:07,350 --> 00:26:14,850
value now this is known as pixie and I'm

576
00:26:12,300 --> 00:26:16,809
going to demo a vulnerability I found on

577
00:26:14,850 --> 00:26:19,090
Microsoft's identity provider

578
00:26:16,809 --> 00:26:24,418
which was a faulty implementation of

579
00:26:19,090 --> 00:26:24,418
pixie and I'll talk you through that so

580
00:26:27,299 --> 00:26:32,710
if you notice here there are three end

581
00:26:30,879 --> 00:26:35,590
points I'm hitting number one is the

582
00:26:32,710 --> 00:26:38,100
login windows.net this is the fqdn of

583
00:26:35,590 --> 00:26:40,539
the microsoft's identity provider and

584
00:26:38,100 --> 00:26:42,189
you'll notice that there's a login end

585
00:26:40,539 --> 00:26:43,600
point I'm hitting there is an authorized

586
00:26:42,190 --> 00:26:45,399
end point I'm hitting and then there's a

587
00:26:43,600 --> 00:26:46,990
token end point as we've already seen in

588
00:26:45,399 --> 00:27:01,959
the what flow these are the endpoints

589
00:26:46,990 --> 00:27:05,559
that are hit so if you notice in the

590
00:27:01,960 --> 00:27:07,210
request you will observe that there is a

591
00:27:05,559 --> 00:27:10,059
code challenge value which is the hashed

592
00:27:07,210 --> 00:27:12,909
value of the code verifier being sent in

593
00:27:10,059 --> 00:27:14,619
the authorized request and there's a

594
00:27:12,909 --> 00:27:24,970
redirect URL which is nothing but my

595
00:27:14,619 --> 00:27:26,889
mobile applications redirect URL in the

596
00:27:24,970 --> 00:27:28,720
response since the end user is not yet

597
00:27:26,889 --> 00:27:33,189
authenticated I get redirected to the

598
00:27:28,720 --> 00:27:36,220
login end point and once I log in the

599
00:27:33,190 --> 00:27:37,869
authorization code is generated and sent

600
00:27:36,220 --> 00:27:40,809
back to the redirect URI that I

601
00:27:37,869 --> 00:27:43,480
initially mentioned so this is the

602
00:27:40,809 --> 00:27:46,178
authorization code and it is being sent

603
00:27:43,480 --> 00:27:54,669
back to the redirect URI of my mobile

604
00:27:46,179 --> 00:27:57,129
application and in the next request to

605
00:27:54,669 --> 00:28:00,519
the token endpoint you will notice that

606
00:27:57,129 --> 00:28:02,918
the code verifies value is being sent to

607
00:28:00,519 --> 00:28:05,440
Microsoft's IDP along with the

608
00:28:02,919 --> 00:28:07,779
authorization code to get back the

609
00:28:05,440 --> 00:28:09,730
tokens refresh tokens identity tokens an

610
00:28:07,779 --> 00:28:12,070
access token so I put it in the repeater

611
00:28:09,730 --> 00:28:15,129
and as you can see in the response you

612
00:28:12,070 --> 00:28:17,080
will get all the tokens now the problem

613
00:28:15,129 --> 00:28:19,779
with Microsoft's identity provider was

614
00:28:17,080 --> 00:28:22,570
that even if you remove the code

615
00:28:19,779 --> 00:28:25,899
verifies value it was still responding

616
00:28:22,570 --> 00:28:27,658
back with valid I tokens refresh tokens

617
00:28:25,899 --> 00:28:30,539
that any tokens an access token and

618
00:28:27,659 --> 00:28:32,999
since the authorization code is not one

619
00:28:30,539 --> 00:28:35,519
News I could replay it as many times

620
00:28:32,999 --> 00:28:37,469
without the code verifies value to get

621
00:28:35,519 --> 00:28:39,899
back as many refresh tokens and I need

622
00:28:37,469 --> 00:28:42,809
cloak ins as I want and therefore have

623
00:28:39,899 --> 00:28:47,299
lifetime access to the end users

624
00:28:42,809 --> 00:28:49,529
resources and you know and this

625
00:28:47,299 --> 00:28:52,219
Microsoft's identity provider was being

626
00:28:49,529 --> 00:28:55,709
used by all probably like multiple

627
00:28:52,219 --> 00:28:58,079
mobile applications so you could if you

628
00:28:55,709 --> 00:29:00,359
leaked one authorization code you get

629
00:28:58,079 --> 00:29:02,339
lifetime access to the resources of that

630
00:29:00,359 --> 00:29:10,079
end user because of the access to the

631
00:29:02,339 --> 00:29:14,279
Refresh tokens if you read through the

632
00:29:10,079 --> 00:29:18,448
RFC for both for native applications you

633
00:29:14,279 --> 00:29:21,869
will notice that it mandates the use of

634
00:29:18,449 --> 00:29:23,669
pixie for such mobile applications and

635
00:29:21,869 --> 00:29:27,899
the auth service should always support

636
00:29:23,669 --> 00:29:33,029
pixie so like it so it was a big goof up

637
00:29:27,899 --> 00:29:34,859
by Microsoft and which brings us to the

638
00:29:33,029 --> 00:29:38,099
second attack which is called the

639
00:29:34,859 --> 00:29:40,319
cross-site request forgery and you must

640
00:29:38,099 --> 00:29:43,259
have you might find it very similar to

641
00:29:40,319 --> 00:29:47,579
login CSRF this attack happens on the

642
00:29:43,259 --> 00:29:50,039
client redirect URI and the attack

643
00:29:47,579 --> 00:29:53,129
results in the client to believe that it

644
00:29:50,039 --> 00:29:55,529
is accessing the legitimate users

645
00:29:53,129 --> 00:29:59,668
resources where in reality it is

646
00:29:55,529 --> 00:30:02,069
accessing the attackers resources so

647
00:29:59,669 --> 00:30:05,989
I've created a pictorial representation

648
00:30:02,069 --> 00:30:08,489
of the attack to understand it better so

649
00:30:05,989 --> 00:30:11,399
let's say the malicious or the attacker

650
00:30:08,489 --> 00:30:13,649
publishes the malicious website and the

651
00:30:11,399 --> 00:30:16,768
end user with this visits this website

652
00:30:13,649 --> 00:30:19,859
attacker.com now the malicious website

653
00:30:16,769 --> 00:30:23,309
needs to generate a force authorization

654
00:30:19,859 --> 00:30:25,948
response and in the response it needs to

655
00:30:23,309 --> 00:30:27,928
replace the code with the attackers auth

656
00:30:25,949 --> 00:30:30,389
code the attacker can initiate an

657
00:30:27,929 --> 00:30:32,099
authorization himself and replace the

658
00:30:30,389 --> 00:30:33,958
code with the attackers orth code

659
00:30:32,099 --> 00:30:35,458
instead of the legitimate end-users code

660
00:30:33,959 --> 00:30:37,379
because he can't figure out the

661
00:30:35,459 --> 00:30:40,259
end-users code but he can always replace

662
00:30:37,379 --> 00:30:42,050
it with his own code and now what will

663
00:30:40,259 --> 00:30:43,700
happen is that the client

664
00:30:42,050 --> 00:30:46,639
we'll think that this is the legitimate

665
00:30:43,700 --> 00:30:48,590
end-users earth code and try to redeem

666
00:30:46,640 --> 00:30:51,920
it at the token end point on the auth

667
00:30:48,590 --> 00:30:53,689
server and get back the access token

668
00:30:51,920 --> 00:30:55,670
which belongs to the attacker now and

669
00:30:53,690 --> 00:30:57,590
when it fetches the resource the

670
00:30:55,670 --> 00:31:01,150
resource will actually be the attackers

671
00:30:57,590 --> 00:31:03,919
resource and not the end users resource

672
00:31:01,150 --> 00:31:05,930
so as a result the client thinks it is

673
00:31:03,920 --> 00:31:07,820
accessing and uses resource but in

674
00:31:05,930 --> 00:31:10,130
reality it is not its accessing the

675
00:31:07,820 --> 00:31:12,710
attackers resource so how do you

676
00:31:10,130 --> 00:31:16,160
mitigate this is simply by putting a

677
00:31:12,710 --> 00:31:18,860
CSRF token in the state parameter which

678
00:31:16,160 --> 00:31:20,870
goes in the auth request and this is

679
00:31:18,860 --> 00:31:24,500
since the author request is generated by

680
00:31:20,870 --> 00:31:26,209
the client it can never be known the

681
00:31:24,500 --> 00:31:28,370
state parameter value can never be known

682
00:31:26,210 --> 00:31:30,440
to the malicious website so the client

683
00:31:28,370 --> 00:31:32,719
generates it and expects it back in the

684
00:31:30,440 --> 00:31:35,690
auth response and in the author response

685
00:31:32,720 --> 00:31:38,810
this is replayed as it is so reflected

686
00:31:35,690 --> 00:31:40,430
as it is so the malicious website can

687
00:31:38,810 --> 00:31:42,470
never get to know the state parameters

688
00:31:40,430 --> 00:31:44,210
value and as a result if the state

689
00:31:42,470 --> 00:31:47,560
parameter is missing here the client

690
00:31:44,210 --> 00:31:47,560
will get to know that something is fishy

691
00:31:49,030 --> 00:31:54,710
now this brings me to the most famous of

692
00:31:52,490 --> 00:31:56,630
all I mean the widely the most widely

693
00:31:54,710 --> 00:32:00,290
spread attacks that happened on earth

694
00:31:56,630 --> 00:32:03,410
which is basically occurring because of

695
00:32:00,290 --> 00:32:06,260
client side open redirects and as a

696
00:32:03,410 --> 00:32:09,320
result of this attack generally you end

697
00:32:06,260 --> 00:32:13,400
up losing or leaking your access tokens

698
00:32:09,320 --> 00:32:15,590
and authorization codes so a few

699
00:32:13,400 --> 00:32:17,660
assumptions that I'll make here to make

700
00:32:15,590 --> 00:32:19,399
this attack more understandable because

701
00:32:17,660 --> 00:32:22,100
it's a pretty complicated attack so

702
00:32:19,400 --> 00:32:24,080
we'll be using the implicit grant but

703
00:32:22,100 --> 00:32:27,020
this attack is also applicable to auth

704
00:32:24,080 --> 00:32:28,610
code grant flows and in North quadrant

705
00:32:27,020 --> 00:32:30,350
flow you will be leaking the auth code

706
00:32:28,610 --> 00:32:31,969
instead of the access tokens but an

707
00:32:30,350 --> 00:32:37,310
implicit grant you'll be leaking the

708
00:32:31,970 --> 00:32:39,650
access token then I am assuming here

709
00:32:37,310 --> 00:32:43,810
that the client has registered this

710
00:32:39,650 --> 00:32:43,810
particular URL with the auth server

711
00:32:43,900 --> 00:32:49,100
client some site example /cb question

712
00:32:47,060 --> 00:32:53,030
mark star so there's a wildcard at the

713
00:32:49,100 --> 00:32:55,379
end and this wild card will be misused

714
00:32:53,030 --> 00:32:58,918
by the attacker and we'll see how

715
00:32:55,380 --> 00:33:01,830
and the client supports open redirect at

716
00:32:58,919 --> 00:33:04,049
this particular endpoint with the help

717
00:33:01,830 --> 00:33:05,580
of a redirect to parameter so basically

718
00:33:04,049 --> 00:33:09,900
if you hit this endpoint you will be

719
00:33:05,580 --> 00:33:12,510
redirected to example comm so let's get

720
00:33:09,900 --> 00:33:17,160
to the attack now so the attacker Oh

721
00:33:12,510 --> 00:33:18,990
before that here's the client domain

722
00:33:17,160 --> 00:33:21,210
client some site example which it has

723
00:33:18,990 --> 00:33:23,250
registered with the auth server when the

724
00:33:21,210 --> 00:33:27,150
server sits on server dot some site

725
00:33:23,250 --> 00:33:29,900
example so the attacker publishes a

726
00:33:27,150 --> 00:33:34,470
malicious web site evil dot example and

727
00:33:29,900 --> 00:33:38,250
the victim visits that fqdn now once the

728
00:33:34,470 --> 00:33:41,730
victim visits it the malicious web site

729
00:33:38,250 --> 00:33:45,240
generates an authorization request which

730
00:33:41,730 --> 00:33:48,990
contains the redirect URI and it is the

731
00:33:45,240 --> 00:33:51,510
clients genuine redirect URI followed by

732
00:33:48,990 --> 00:33:53,549
the redirect to parameter with the

733
00:33:51,510 --> 00:33:56,610
attackers domain in it client evil

734
00:33:53,549 --> 00:33:58,740
example so if you decode this URL you

735
00:33:56,610 --> 00:34:01,080
will get client some side examples /cb

736
00:33:58,740 --> 00:34:04,620
question mark redirect to client evil

737
00:34:01,080 --> 00:34:07,110
example and once this request reaches

738
00:34:04,620 --> 00:34:09,138
the earth server the server matches it

739
00:34:07,110 --> 00:34:13,230
with the pattern that was registered and

740
00:34:09,139 --> 00:34:15,929
the pattern was exactly same client side

741
00:34:13,230 --> 00:34:18,510
example /cb question mark star and this

742
00:34:15,929 --> 00:34:20,639
pattern matches this particular value so

743
00:34:18,510 --> 00:34:22,440
the odd server approves of the

744
00:34:20,639 --> 00:34:26,820
redirection and redirects the access

745
00:34:22,440 --> 00:34:31,830
token back to the client and since the

746
00:34:26,820 --> 00:34:33,540
client has an open redirect exposed it

747
00:34:31,830 --> 00:34:39,239
will redirect this particular access

748
00:34:33,540 --> 00:34:41,040
token back to client evil example so as

749
00:34:39,239 --> 00:34:43,408
a URL fragment you will get the access

750
00:34:41,040 --> 00:34:49,109
token and the attacker can easily

751
00:34:43,409 --> 00:34:51,750
extract that value so the only

752
00:34:49,109 --> 00:34:54,629
mitigation is to not expose open

753
00:34:51,750 --> 00:34:56,690
redirect at all because you lose your

754
00:34:54,629 --> 00:34:58,410
access token the Northcote anyway so

755
00:34:56,690 --> 00:35:03,020
please don't do that

756
00:34:58,410 --> 00:35:03,020
that's a point you should always note

757
00:35:03,380 --> 00:35:12,710
so next one is fishing using users trust

758
00:35:08,030 --> 00:35:14,450
in the auth server and there are a few

759
00:35:12,710 --> 00:35:17,930
steps that the attacker needs to take he

760
00:35:14,450 --> 00:35:19,669
just needs to register a client he just

761
00:35:17,930 --> 00:35:21,710
needs to register a domain which the

762
00:35:19,670 --> 00:35:26,870
attacker controls with the odd server

763
00:35:21,710 --> 00:35:29,180
and then he misuses the trust that the

764
00:35:26,870 --> 00:35:32,089
class that the end user has in the

765
00:35:29,180 --> 00:35:34,220
authorization server so the author could

766
00:35:32,090 --> 00:35:36,440
be Google or Facebook and once the

767
00:35:34,220 --> 00:35:38,299
attacker registers a particular redirect

768
00:35:36,440 --> 00:35:39,830
you arrive with Facebook or Google he

769
00:35:38,300 --> 00:35:42,290
can just create this URL

770
00:35:39,830 --> 00:35:44,900
starting with authorization servers

771
00:35:42,290 --> 00:35:47,660
domain followed by the redirect URI of

772
00:35:44,900 --> 00:35:51,710
the attacker domain and when the victim

773
00:35:47,660 --> 00:35:53,540
clicks on it it'll be redirected to the

774
00:35:51,710 --> 00:35:55,190
attackers domain where the attacker can

775
00:35:53,540 --> 00:36:00,170
create a phishing page and extract

776
00:35:55,190 --> 00:36:02,000
whatever details at once so it's the

777
00:36:00,170 --> 00:36:05,330
responsibility of the authorization

778
00:36:02,000 --> 00:36:07,430
servers to inform the end user that it

779
00:36:05,330 --> 00:36:08,990
is going to redirect to a third party

780
00:36:07,430 --> 00:36:13,100
application which is this particular

781
00:36:08,990 --> 00:36:14,990
domain and not always will you see that

782
00:36:13,100 --> 00:36:18,140
happening also generally don't care

783
00:36:14,990 --> 00:36:20,870
about it so easily the phishing attacks

784
00:36:18,140 --> 00:36:25,460
can happen because of the trust that the

785
00:36:20,870 --> 00:36:31,490
end user has in the odd servers now this

786
00:36:25,460 --> 00:36:33,170
one is interesting attack and try to

787
00:36:31,490 --> 00:36:35,839
stay with me here because it gets a

788
00:36:33,170 --> 00:36:39,830
little complicated again so this happens

789
00:36:35,840 --> 00:36:41,990
when the client application has

790
00:36:39,830 --> 00:36:43,910
registered with multiple authorization

791
00:36:41,990 --> 00:36:46,250
servers like Facebook Google etcetera

792
00:36:43,910 --> 00:36:49,609
and one of the auth server turns

793
00:36:46,250 --> 00:36:51,890
malicious and the intent of the

794
00:36:49,610 --> 00:36:54,440
malicious auth server is to get access

795
00:36:51,890 --> 00:36:56,450
tokens which are generated by the other

796
00:36:54,440 --> 00:37:01,250
legitimate auth servers which are not

797
00:36:56,450 --> 00:37:03,529
malicious and the Poli precondition here

798
00:37:01,250 --> 00:37:06,320
is that the client has registered for

799
00:37:03,530 --> 00:37:09,260
the same redirect URI for all its hot

800
00:37:06,320 --> 00:37:11,030
servers so even for Google it has the

801
00:37:09,260 --> 00:37:12,770
same redirect URI even for Facebook it

802
00:37:11,030 --> 00:37:15,820
has the same redirect URI and that's

803
00:37:12,770 --> 00:37:15,820
what causes the attack

804
00:37:18,119 --> 00:37:25,029
so I have various entities listed here

805
00:37:21,990 --> 00:37:29,740
will be assuming that the end user is

806
00:37:25,029 --> 00:37:32,079
trying to access resources from the same

807
00:37:29,740 --> 00:37:34,089
odd server so I have Facebook and

808
00:37:32,079 --> 00:37:36,490
Facebook's resources Google and Google's

809
00:37:34,089 --> 00:37:38,349
resources here and the end user has

810
00:37:36,490 --> 00:37:40,538
resources on both both the auth servers

811
00:37:38,349 --> 00:37:42,700
and the client has registered with

812
00:37:40,539 --> 00:37:46,930
Google and Mozilla Facebook so once the

813
00:37:42,700 --> 00:37:50,769
user let's say chooses Facebook as its

814
00:37:46,930 --> 00:37:52,749
earth server LinkedIn will initiate a

815
00:37:50,769 --> 00:37:56,859
North request to Facebook's ad server

816
00:37:52,749 --> 00:37:58,959
and Facebook is malicious so what it

817
00:37:56,859 --> 00:38:00,970
does is that once the request reaches

818
00:37:58,960 --> 00:38:02,890
Facebook it will instead of showing the

819
00:38:00,970 --> 00:38:04,749
prompt to the user itself it will

820
00:38:02,890 --> 00:38:06,970
redirect to Google's authorization page

821
00:38:04,749 --> 00:38:09,578
and Google will show you the

822
00:38:06,970 --> 00:38:11,410
authorization so if the end user is not

823
00:38:09,579 --> 00:38:13,119
attentive enough to see that the

824
00:38:11,410 --> 00:38:15,578
authorization problem is coming in from

825
00:38:13,119 --> 00:38:17,499
Google instead of Facebook what happen

826
00:38:15,579 --> 00:38:19,599
is that after approval the auth code

827
00:38:17,499 --> 00:38:23,459
will be generated by Google's ad server

828
00:38:19,599 --> 00:38:26,680
and sent back to LinkedIn and LinkedIn

829
00:38:23,460 --> 00:38:28,450
will know is that the authorization was

830
00:38:26,680 --> 00:38:30,249
started with Facebook so it will try to

831
00:38:28,450 --> 00:38:34,649
redeem the auth code that Google

832
00:38:30,249 --> 00:38:37,720
generated at Facebook's end point and

833
00:38:34,650 --> 00:38:40,900
Facebook will then redirect that or

834
00:38:37,720 --> 00:38:42,519
token to Google's endpoint and the token

835
00:38:40,900 --> 00:38:45,220
that they generated will be sent to

836
00:38:42,519 --> 00:38:47,379
LinkedIn and LinkedIn because it knows

837
00:38:45,220 --> 00:38:48,700
that Facebook is the one that we started

838
00:38:47,380 --> 00:38:50,739
the authenticate or syndication

839
00:38:48,700 --> 00:38:54,519
authorization flow with it will again

840
00:38:50,739 --> 00:38:56,920
try to redeem the token at Facebook's

841
00:38:54,519 --> 00:39:00,788
end point Facebook's resource endpoint

842
00:38:56,920 --> 00:39:02,769
so now Facebook has got the token access

843
00:39:00,789 --> 00:39:05,499
token that was generated by Google and

844
00:39:02,769 --> 00:39:07,558
it can easily then access Google's

845
00:39:05,499 --> 00:39:10,328
resources on behalf of that user so

846
00:39:07,559 --> 00:39:12,880
that's how the mix of attack happens and

847
00:39:10,329 --> 00:39:15,999
there's a simple fix to it you should

848
00:39:12,880 --> 00:39:18,099
never use the same redirect urs for

849
00:39:15,999 --> 00:39:21,819
different auth servers you should always

850
00:39:18,099 --> 00:39:25,030
have different redirect URLs on the

851
00:39:21,819 --> 00:39:27,670
client expose for different auth servers

852
00:39:25,030 --> 00:39:29,400
and to show you how this works how this

853
00:39:27,670 --> 00:39:32,230
fix works

854
00:39:29,400 --> 00:39:35,080
the initial authorization request is to

855
00:39:32,230 --> 00:39:38,110
Facebook and once the auth code is

856
00:39:35,080 --> 00:39:40,299
returned to the clients redirect URI

857
00:39:38,110 --> 00:39:42,130
because it's Google redirecting so it'll

858
00:39:40,300 --> 00:39:44,050
be Google's redirect URI which will get

859
00:39:42,130 --> 00:39:45,850
the auth code so the client will

860
00:39:44,050 --> 00:39:47,980
immediately notice that there's a

861
00:39:45,850 --> 00:39:49,810
discrepancy the initial auth flow was

862
00:39:47,980 --> 00:39:53,500
started with Facebook and the redirect

863
00:39:49,810 --> 00:39:56,830
URI is of Google and because of this

864
00:39:53,500 --> 00:40:01,930
discrepancy the client will not then

865
00:39:56,830 --> 00:40:06,640
redeem the auth code at at Facebook so

866
00:40:01,930 --> 00:40:08,740
just to summarize what is used for

867
00:40:06,640 --> 00:40:12,040
delegating resource access to a third

868
00:40:08,740 --> 00:40:14,500
party application and access tokens

869
00:40:12,040 --> 00:40:18,250
prove authorization and identity tokens

870
00:40:14,500 --> 00:40:20,350
prove authentication for web apps stick

871
00:40:18,250 --> 00:40:22,510
to authorization code grants and for

872
00:40:20,350 --> 00:40:26,830
mobile applications you could use auth

873
00:40:22,510 --> 00:40:29,410
quadrant flow with pixee and then we

874
00:40:26,830 --> 00:40:32,230
also talked about how what works on

875
00:40:29,410 --> 00:40:35,740
native applications and of course a few

876
00:40:32,230 --> 00:40:37,480
bunch of attacks and the mitigations and

877
00:40:35,740 --> 00:40:39,669
if you want to get started with OAuth

878
00:40:37,480 --> 00:40:41,350
and OpenID connect there are a bunch of

879
00:40:39,670 --> 00:40:44,140
references these are good starting

880
00:40:41,350 --> 00:40:45,580
points and of course I'm there so if you

881
00:40:44,140 --> 00:40:52,600
have some questions then you can get

882
00:40:45,580 --> 00:40:54,730
back to me as well and okay so here are

883
00:40:52,600 --> 00:40:56,890
my contact details just in case you want

884
00:40:54,730 --> 00:40:58,750
to drop me a message and if you have

885
00:40:56,890 --> 00:41:01,540
some we can have some good interesting

886
00:40:58,750 --> 00:41:04,540
discussions so thank you so much that

887
00:41:01,540 --> 00:41:07,849
was it thank you for paying attention

888
00:41:04,540 --> 00:41:07,849
[Applause]

889
00:41:12,240 --> 00:41:18,160
so we got three minutes for our

890
00:41:16,000 --> 00:41:20,740
questions maybe you can we can we can

891
00:41:18,160 --> 00:41:32,290
get more in case so do you have any

892
00:41:20,740 --> 00:41:34,509
question for some it so I just one just

893
00:41:32,290 --> 00:41:37,869
one one questions with apparently or

894
00:41:34,510 --> 00:41:38,740
what is pretty complex to implement do

895
00:41:37,869 --> 00:41:41,410
you know is there

896
00:41:38,740 --> 00:41:43,689
Anthony work in terms of a formal

897
00:41:41,410 --> 00:41:47,670
verification of that protocol and what

898
00:41:43,690 --> 00:41:51,580
were the output of it that was for you

899
00:41:47,670 --> 00:41:53,560
okay so personally I have only seen gone

900
00:41:51,580 --> 00:41:56,350
through the RFC's so if you're talking

901
00:41:53,560 --> 00:41:58,720
about like probably mathematical

902
00:41:56,350 --> 00:42:01,750
formulations that have that verify the

903
00:41:58,720 --> 00:42:04,240
protocol itself I doubt that exist but

904
00:42:01,750 --> 00:42:06,670
there is a RFC committee obviously that

905
00:42:04,240 --> 00:42:10,029
sits and goes dude and threat models the

906
00:42:06,670 --> 00:42:11,770
entire protocol flow so that has been

907
00:42:10,030 --> 00:42:13,869
done throughout a long period of time

908
00:42:11,770 --> 00:42:16,240
and there are various RFC pages which

909
00:42:13,869 --> 00:42:17,890
talks about what are recommended what

910
00:42:16,240 --> 00:42:20,080
are the recommendations and what are the

911
00:42:17,890 --> 00:42:23,770
best practices that you should always

912
00:42:20,080 --> 00:42:26,790
stick to so as a pen tester you should

913
00:42:23,770 --> 00:42:31,780
always be looking up for it but yeah

914
00:42:26,790 --> 00:42:32,950
okay so no question so thank you so much

915
00:42:31,780 --> 00:42:36,060
thank you

916
00:42:32,950 --> 00:42:36,060
[Music]

917
00:42:36,480 --> 00:42:44,560
[Applause]

918
00:42:39,460 --> 00:42:49,550
from your failures are they generally

919
00:42:44,560 --> 00:42:53,120
communication or in HTTP so how do you

920
00:42:49,550 --> 00:42:57,080
see the token exchange or data exchange

921
00:42:53,120 --> 00:43:00,140
between the client and the server so

922
00:42:57,080 --> 00:43:03,049
you're asking me that the exchange is

923
00:43:00,140 --> 00:43:05,629
happening over TLS how do you see the

924
00:43:03,050 --> 00:43:10,100
data or the traffic right is that your

925
00:43:05,630 --> 00:43:12,350
question my question is that generally

926
00:43:10,100 --> 00:43:17,210
your communication between the client

927
00:43:12,350 --> 00:43:20,779
and the server are in HTTP yeah so it's

928
00:43:17,210 --> 00:43:24,500
encrypted yeah so it may not be possible

929
00:43:20,780 --> 00:43:27,590
to to get the token order to cook right

930
00:43:24,500 --> 00:43:29,990
yeah so if you're talking about mobile

931
00:43:27,590 --> 00:43:31,250
clients then you can still intercept the

932
00:43:29,990 --> 00:43:33,229
traffic between the client and the

933
00:43:31,250 --> 00:43:35,180
server because mobile client is

934
00:43:33,230 --> 00:43:37,880
executing on the end-users mobile device

935
00:43:35,180 --> 00:43:39,620
you can easily place a proxy in between

936
00:43:37,880 --> 00:43:41,090
and in start intercepting because you

937
00:43:39,620 --> 00:43:42,980
can install the certificates and start

938
00:43:41,090 --> 00:43:46,570
decrypting the traffic so you'll have to

939
00:43:42,980 --> 00:43:48,980
install the proxy is certificate on the

940
00:43:46,570 --> 00:43:50,720
web you'll have to install the proxy

941
00:43:48,980 --> 00:43:53,150
certificate on the mobile device so that

942
00:43:50,720 --> 00:43:54,950
you start decrypting the traffic so

943
00:43:53,150 --> 00:43:56,900
that's possible but if you are trying to

944
00:43:54,950 --> 00:43:58,819
intercept the traffic between a web

945
00:43:56,900 --> 00:44:00,890
application client and the auth server

946
00:43:58,820 --> 00:44:02,960
that is that is not feasible because

947
00:44:00,890 --> 00:44:09,350
it's a server to server call and the

948
00:44:02,960 --> 00:44:11,830
attacker can't intercept that okay thank

949
00:44:09,350 --> 00:44:11,830
you senator

