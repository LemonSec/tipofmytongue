1
00:00:03,410 --> 00:00:12,450
hi so I'm going to speak about VBA today

2
00:00:08,250 --> 00:00:15,030
let's get one thing first out before we

3
00:00:12,450 --> 00:00:17,189
start VBA means Visual Basic for

4
00:00:15,030 --> 00:00:21,330
applications and I'm actually talking

5
00:00:17,189 --> 00:00:29,460
about office macros so why office macros

6
00:00:21,330 --> 00:00:31,130
in 2019 first I would present I will do

7
00:00:29,460 --> 00:00:34,650
some shameless shameless self

8
00:00:31,130 --> 00:00:37,050
presentation then we're going to have an

9
00:00:34,650 --> 00:00:39,989
introduction into my office macros are

10
00:00:37,050 --> 00:00:43,459
still a subject now we don't look at a

11
00:00:39,990 --> 00:00:45,780
motet a malware that is using macros and

12
00:00:43,460 --> 00:00:48,300
obfuscation techniques that are used in

13
00:00:45,780 --> 00:00:50,210
macros to hide what they're doing and we

14
00:00:48,300 --> 00:00:53,940
don't look at it in and play an

15
00:00:50,210 --> 00:00:57,870
implementation of security framework

16
00:00:53,940 --> 00:01:01,080
that we developed to run macros and see

17
00:00:57,870 --> 00:01:03,300
what they're doing and finally I'm going

18
00:01:01,080 --> 00:01:04,769
to have some reference for references

19
00:01:03,300 --> 00:01:10,280
for you and I'm going to accept your

20
00:01:04,769 --> 00:01:14,130
questions ok so first of all Who am I I

21
00:01:10,280 --> 00:01:19,170
have done my PhD degree in the South of

22
00:01:14,130 --> 00:01:22,020
France in Eureka and I've worked on

23
00:01:19,170 --> 00:01:26,369
embedded systems vectoring hard drive

24
00:01:22,020 --> 00:01:29,639
and testing firmware now I'm in taro

25
00:01:26,369 --> 00:01:32,880
since at Cisco and I'm much more on the

26
00:01:29,639 --> 00:01:39,960
malware side on PC and we're doing

27
00:01:32,880 --> 00:01:45,509
detection analysis and defense okay so

28
00:01:39,960 --> 00:01:52,318
why analyze VBA macros they should have

29
00:01:45,509 --> 00:01:54,090
been dead long ago probably well there

30
00:01:52,319 --> 00:01:57,450
are a couple of things why they're not

31
00:01:54,090 --> 00:01:58,770
dead so first of all to clarify what

32
00:01:57,450 --> 00:02:00,569
we're speaking about here we're speaking

33
00:01:58,770 --> 00:02:02,490
about Visual Basic for applications

34
00:02:00,569 --> 00:02:07,399
there's also another type of macros

35
00:02:02,490 --> 00:02:10,288
which are extra 24.0 macros from 1992

36
00:02:07,399 --> 00:02:13,200
those ones are also used in malware and

37
00:02:10,288 --> 00:02:14,760
they're pretty interesting but there are

38
00:02:13,200 --> 00:02:20,970
out of scope for this work

39
00:02:14,760 --> 00:02:24,090
and the problem or the why we still have

40
00:02:20,970 --> 00:02:27,030
macros around is because there are many

41
00:02:24,090 --> 00:02:29,700
legitimate uses for it in a company

42
00:02:27,030 --> 00:02:32,750
people want to express custom formula or

43
00:02:29,700 --> 00:02:36,359
they want to connect to a database fetch

44
00:02:32,750 --> 00:02:39,450
fetch data into the excel sheet and then

45
00:02:36,360 --> 00:02:42,780
manipulate it there and this is actually

46
00:02:39,450 --> 00:02:44,790
wanted and I think this ambiguity

47
00:02:42,780 --> 00:02:47,819
between not having macros because they

48
00:02:44,790 --> 00:02:50,730
can contain malicious code and the

49
00:02:47,819 --> 00:02:52,708
legitimate use is carried in this small

50
00:02:50,730 --> 00:02:54,629
yellow bar that Microsoft is showing

51
00:02:52,709 --> 00:02:56,660
when you open a document with macros it

52
00:02:54,629 --> 00:02:58,828
tells you do you really want to run them

53
00:02:56,660 --> 00:03:00,840
because normally you don't want to run

54
00:02:58,829 --> 00:03:02,400
macros that come from the internet but

55
00:03:00,840 --> 00:03:06,030
if you click yes then you still have the

56
00:03:02,400 --> 00:03:09,629
ability to run macros and malicious code

57
00:03:06,030 --> 00:03:11,849
might use hooks to automatically execute

58
00:03:09,629 --> 00:03:19,048
itself just when you open the document

59
00:03:11,849 --> 00:03:21,030
when you click a cell and so on and yeah

60
00:03:19,049 --> 00:03:23,340
so now I've answered why macros are

61
00:03:21,030 --> 00:03:28,049
still around but why are they used by

62
00:03:23,340 --> 00:03:32,760
malware way are there threat so imitate

63
00:03:28,049 --> 00:03:36,090
is escort that is has been around since

64
00:03:32,760 --> 00:03:38,849
2014 I think initially it was a banking

65
00:03:36,090 --> 00:03:43,470
Trojan and then it evolved to our

66
00:03:38,849 --> 00:03:45,480
delivery platform and one way in motor

67
00:03:43,470 --> 00:03:50,760
disinfecting machines is via office

68
00:03:45,480 --> 00:03:53,099
macros so we could go and we could just

69
00:03:50,760 --> 00:03:56,130
dump the code that is behind the

70
00:03:53,099 --> 00:03:58,319
document to extract the macros and see

71
00:03:56,130 --> 00:04:02,639
what they're doing there are tools for

72
00:03:58,319 --> 00:04:06,690
that there is Philip laga decks or levy

73
00:04:02,639 --> 00:04:08,849
ba and the Viper monkey only VBA is a

74
00:04:06,690 --> 00:04:11,730
tool to just statically look at the code

75
00:04:08,849 --> 00:04:13,980
and try to extract things that are

76
00:04:11,730 --> 00:04:17,039
suspicious viper monkey goes a step

77
00:04:13,980 --> 00:04:19,620
further and parses code snippets and

78
00:04:17,039 --> 00:04:20,940
then translates them into Python and

79
00:04:19,620 --> 00:04:24,870
execute them in Python

80
00:04:20,940 --> 00:04:27,639
to see if if they have malicious

81
00:04:24,870 --> 00:04:30,819
behavior the

82
00:04:27,639 --> 00:04:33,460
is that the Viper monkey is an

83
00:04:30,819 --> 00:04:38,080
approximate tool and thus fails if the

84
00:04:33,460 --> 00:04:40,448
code is heavily obfuscated and all EVB a

85
00:04:38,080 --> 00:04:43,479
as it is a static tool if the code is

86
00:04:40,449 --> 00:04:45,460
obfuscated cannot do anything the

87
00:04:43,479 --> 00:04:47,830
problem is that we could also do dynamic

88
00:04:45,460 --> 00:04:50,830
analysis dynamic analysis currently

89
00:04:47,830 --> 00:04:53,590
means that we load the document into a

90
00:04:50,830 --> 00:04:55,688
virtual machine start office on this

91
00:04:53,590 --> 00:04:57,818
virtual machine run the document in

92
00:04:55,689 --> 00:04:59,620
office and then collect all the

93
00:04:57,819 --> 00:05:02,229
observables inside this virtual machine

94
00:04:59,620 --> 00:05:03,939
that happened during the execution there

95
00:05:02,229 --> 00:05:06,490
are several disadvantages first of all

96
00:05:03,939 --> 00:05:09,219
we need to spin up an instance of VMware

97
00:05:06,490 --> 00:05:11,680
or whatever and run over to a machine

98
00:05:09,219 --> 00:05:13,659
which is expensive we don't really know

99
00:05:11,680 --> 00:05:16,629
when the execution is terminated because

100
00:05:13,659 --> 00:05:18,360
we don't know when the macro code has

101
00:05:16,629 --> 00:05:22,810
finished executing because we don't have

102
00:05:18,360 --> 00:05:25,240
visibility into office and then we get

103
00:05:22,810 --> 00:05:28,120
tons of observables that are pretty

104
00:05:25,240 --> 00:05:29,680
noisy we have the operating system

105
00:05:28,120 --> 00:05:32,770
artifacts we have the artifacts from

106
00:05:29,680 --> 00:05:35,949
from office and we have somewhere inside

107
00:05:32,770 --> 00:05:39,460
the artifacts from running our code but

108
00:05:35,949 --> 00:05:41,710
then you need to extract them so the

109
00:05:39,460 --> 00:05:48,969
idea we had was to interpret the macro

110
00:05:41,710 --> 00:05:51,190
code ourselves no ok but before we go

111
00:05:48,969 --> 00:05:53,259
into interpreting the macro let's look

112
00:05:51,190 --> 00:05:56,650
at how a typical a motet infection looks

113
00:05:53,259 --> 00:05:58,349
like to get a feeling of what we are

114
00:05:56,650 --> 00:06:01,479
faced with

115
00:05:58,349 --> 00:06:06,360
so typically everything will start with

116
00:06:01,479 --> 00:06:09,039
an email like the one you see here the

117
00:06:06,360 --> 00:06:12,009
emote head is pretty good in social

118
00:06:09,039 --> 00:06:16,330
engineering in that when it infects a

119
00:06:12,009 --> 00:06:20,589
machine it extracts hundred 888 days of

120
00:06:16,330 --> 00:06:23,979
emails and it will contact the persons

121
00:06:20,589 --> 00:06:26,349
that the emails were written to and just

122
00:06:23,979 --> 00:06:28,659
reply to the existing email thread so

123
00:06:26,349 --> 00:06:32,469
you get an email from a person that you

124
00:06:28,659 --> 00:06:34,629
know you get an email thread where you

125
00:06:32,469 --> 00:06:39,759
have sent messages yourself in that you

126
00:06:34,629 --> 00:06:41,440
recognize and this makes that the email

127
00:06:39,759 --> 00:06:44,320
thread is quite believable

128
00:06:41,440 --> 00:06:46,180
and that you will probably open the

129
00:06:44,320 --> 00:06:51,310
document that is now being attached by a

130
00:06:46,180 --> 00:06:53,500
motet okay so the next step is you

131
00:06:51,310 --> 00:06:57,100
clicked on the attachment word is

132
00:06:53,500 --> 00:07:00,520
opening and you have this yellow bar

133
00:06:57,100 --> 00:07:02,260
here where it says enable content and of

134
00:07:00,520 --> 00:07:04,450
course there is a nice message in the

135
00:07:02,260 --> 00:07:06,010
document saying yeah this document

136
00:07:04,450 --> 00:07:08,890
cannot open you need to click this bar

137
00:07:06,010 --> 00:07:14,170
otherwise you will not see what is to be

138
00:07:08,890 --> 00:07:18,930
seen so you will click the bar and then

139
00:07:14,170 --> 00:07:22,030
the VBA code starts executing the

140
00:07:18,930 --> 00:07:24,040
easiest way for all the way in what that

141
00:07:22,030 --> 00:07:26,530
uses is it just uses an auto open

142
00:07:24,040 --> 00:07:33,280
function which is executed when the

143
00:07:26,530 --> 00:07:36,909
document opens and then this is a bit

144
00:07:33,280 --> 00:07:39,929
tricky with micro so then what the code

145
00:07:36,910 --> 00:07:43,210
will do is it will get an instance of

146
00:07:39,930 --> 00:07:46,270
win32 process windows management

147
00:07:43,210 --> 00:07:51,010
interface class and with this instance

148
00:07:46,270 --> 00:07:55,330
it can open a process and as an

149
00:07:51,010 --> 00:07:57,310
additional goodie it hides the window

150
00:07:55,330 --> 00:07:58,930
window of this process so that you don't

151
00:07:57,310 --> 00:08:04,030
see that the process started in the

152
00:07:58,930 --> 00:08:06,430
background ok then we create a process

153
00:08:04,030 --> 00:08:09,520
that is powered power shell with

154
00:08:06,430 --> 00:08:17,230
something encoded and base64 blob and

155
00:08:09,520 --> 00:08:21,419
that's it so the power shell code is

156
00:08:17,230 --> 00:08:24,460
actually being executed you can see here

157
00:08:21,419 --> 00:08:28,030
you have a couple of sorry you have a

158
00:08:24,460 --> 00:08:30,460
couple of URLs here and the code is just

159
00:08:28,030 --> 00:08:32,650
cycling through the URLs trying to

160
00:08:30,460 --> 00:08:34,750
download an executable from the URL if

161
00:08:32,650 --> 00:08:39,390
the executable is downloaded

162
00:08:34,750 --> 00:08:44,380
successfully it's invoked and we're done

163
00:08:39,390 --> 00:08:47,500
and then you install the actual

164
00:08:44,380 --> 00:08:50,950
executable which will then go on and

165
00:08:47,500 --> 00:08:53,589
download later stages it will steal your

166
00:08:50,950 --> 00:08:55,269
credentials it will exfiltrate the 180

167
00:08:53,589 --> 00:08:58,959
days of mails to attack

168
00:08:55,269 --> 00:09:01,179
your contacts it will spread laterally

169
00:08:58,959 --> 00:09:03,579
in the neck network for example the

170
00:09:01,179 --> 00:09:09,449
eternal blue or some other

171
00:09:03,579 --> 00:09:13,329
vulnerabilities and since since 2015 I

172
00:09:09,449 --> 00:09:17,019
think a motet is also delivering other

173
00:09:13,329 --> 00:09:19,599
payloads so it's not the in the most

174
00:09:17,019 --> 00:09:21,999
malicious payload itself anymore but it

175
00:09:19,600 --> 00:09:26,139
will for example deliver trick pot or

176
00:09:21,999 --> 00:09:32,350
ransomware all stuff and at this point

177
00:09:26,139 --> 00:09:35,619
we're pond so of course the code that I

178
00:09:32,350 --> 00:09:37,300
showed you there was very legible the

179
00:09:35,619 --> 00:09:40,869
code that we get delivered in the

180
00:09:37,300 --> 00:09:43,209
document is not the same so let's look

181
00:09:40,869 --> 00:09:49,179
at the opposition techniques that Emmet

182
00:09:43,209 --> 00:09:55,809
had uses to hide its code first one is

183
00:09:49,179 --> 00:09:58,689
that code so typically there there is

184
00:09:55,809 --> 00:10:01,569
huge amount of code but only very few

185
00:09:58,689 --> 00:10:05,319
lines will do what a Matata wants to do

186
00:10:01,569 --> 00:10:09,160
and one trick it uses is that variables

187
00:10:05,319 --> 00:10:11,170
in VBA are by default fails so if you

188
00:10:09,160 --> 00:10:13,629
reference any variable that hasn't been

189
00:10:11,170 --> 00:10:15,849
initialized it will evaluate to fails

190
00:10:13,629 --> 00:10:19,089
which is handy here in this wild

191
00:10:15,850 --> 00:10:22,540
condition where just some two variables

192
00:10:19,089 --> 00:10:24,189
that haven't been initialized I used the

193
00:10:22,540 --> 00:10:27,939
whole expression evaluates to fails the

194
00:10:24,189 --> 00:10:30,240
code block is not executed and this just

195
00:10:27,939 --> 00:10:36,160
confuses tools that are not able to

196
00:10:30,240 --> 00:10:38,920
understand this logic so yeah that code

197
00:10:36,160 --> 00:10:41,499
is not doing anything plus there are

198
00:10:38,920 --> 00:10:44,979
line break there's the line continuation

199
00:10:41,499 --> 00:10:47,019
character this is used excessively this

200
00:10:44,980 --> 00:10:51,220
is also just to confuse tools because

201
00:10:47,019 --> 00:10:54,040
you need to interpret this whole thing

202
00:10:51,220 --> 00:10:59,490
as it was on one line it's like the

203
00:10:54,040 --> 00:11:03,180
backslash character in C okay

204
00:10:59,490 --> 00:11:06,550
another technique is constant operate

205
00:11:03,180 --> 00:11:08,279
for example we can take a string and we

206
00:11:06,550 --> 00:11:12,969
can make two strings that are being

207
00:11:08,279 --> 00:11:14,769
concatenated or we can use dummy content

208
00:11:12,970 --> 00:11:16,540
that we insert inside the string and

209
00:11:14,769 --> 00:11:18,389
then we just use a replace function to

210
00:11:16,540 --> 00:11:22,149
remove the dummy content from the string

211
00:11:18,389 --> 00:11:24,910
or we can use a a lot of useless

212
00:11:22,149 --> 00:11:26,829
typecasting like you see here with the C

213
00:11:24,910 --> 00:11:27,399
bar that actually it doesn't change

214
00:11:26,829 --> 00:11:36,459
anything

215
00:11:27,399 --> 00:11:37,990
and will confuse tools another technique

216
00:11:36,459 --> 00:11:41,079
that I have seen in new document'

217
00:11:37,990 --> 00:11:44,379
documents from the imitate infections

218
00:11:41,079 --> 00:11:48,609
that started in September is this one

219
00:11:44,379 --> 00:11:51,970
here Visual Basic is pretty special in

220
00:11:48,610 --> 00:11:54,040
the way it can do error handling when

221
00:11:51,970 --> 00:11:57,040
you have a function or a procedure you

222
00:11:54,040 --> 00:11:59,680
can say at the beginning on error resume

223
00:11:57,040 --> 00:12:03,490
next or on error resume and the label

224
00:11:59,680 --> 00:12:05,589
and it will go to the error handler you

225
00:12:03,490 --> 00:12:08,589
specified so if you say on error resume

226
00:12:05,589 --> 00:12:12,240
next it means if a statement fails then

227
00:12:08,589 --> 00:12:16,540
just execute the next statement that

228
00:12:12,240 --> 00:12:18,129
follows the current one you can imagine

229
00:12:16,540 --> 00:12:22,209
this a bit like having a try/catch

230
00:12:18,129 --> 00:12:25,180
around every instruction and if you have

231
00:12:22,209 --> 00:12:26,768
in a statement like here and you cast

232
00:12:25,180 --> 00:12:29,920
something to an end that is clearly not

233
00:12:26,769 --> 00:12:34,509
an int it would result in an error and

234
00:12:29,920 --> 00:12:39,160
the instruction will be skipped so just

235
00:12:34,509 --> 00:12:44,589
like it wasn't there and this is all so

236
00:12:39,160 --> 00:12:47,679
confusing analysis tools okay another

237
00:12:44,589 --> 00:12:50,829
thing that is pretty annoying is the way

238
00:12:47,679 --> 00:12:53,050
a motet stores its actual content the

239
00:12:50,829 --> 00:12:59,290
powershell part that is then being

240
00:12:53,050 --> 00:13:02,050
executed so you have the main office

241
00:12:59,290 --> 00:13:06,879
macro code that is stored inside an OE

242
00:13:02,050 --> 00:13:08,760
object inside the document if the

243
00:13:06,879 --> 00:13:12,540
document is

244
00:13:08,760 --> 00:13:16,380
office 97 to 2003 document then it

245
00:13:12,540 --> 00:13:18,389
itself is an oily document and all the

246
00:13:16,380 --> 00:13:20,820
VBA projects and so on will be stored

247
00:13:18,389 --> 00:13:23,699
inside that if it is a later generation

248
00:13:20,820 --> 00:13:27,360
then the document is a zip file and

249
00:13:23,699 --> 00:13:31,290
inside the zip file is an e document

250
00:13:27,360 --> 00:13:33,120
that contains the vbe VBA project okay

251
00:13:31,290 --> 00:13:36,380
and inside this same old

252
00:13:33,120 --> 00:13:39,990
efile we also have a couple of

253
00:13:36,380 --> 00:13:43,079
serialized form elements those can be

254
00:13:39,990 --> 00:13:47,120
used to create forms like you can put

255
00:13:43,079 --> 00:13:49,829
text boxes comment buttons and so on and

256
00:13:47,120 --> 00:13:52,470
there is a specification from Microsoft

257
00:13:49,829 --> 00:13:56,339
that is open on how to parse this

258
00:13:52,470 --> 00:13:59,279
content and if we access the additional

259
00:13:56,339 --> 00:14:02,130
streams inside the Olli file where this

260
00:13:59,279 --> 00:14:05,550
content is stored we can parse the form

261
00:14:02,130 --> 00:14:08,220
elements and emote head stores parts of

262
00:14:05,550 --> 00:14:10,349
its contents in the for example in the

263
00:14:08,220 --> 00:14:15,170
caption of a tear of a comment button or

264
00:14:10,350 --> 00:14:15,170
in the text attribute of a text box I

265
00:14:15,529 --> 00:14:25,769
haven't seen any tools that decode these

266
00:14:18,680 --> 00:14:28,319
streams and in in the one we implemented

267
00:14:25,769 --> 00:14:31,889
we're decoding this but we're just

268
00:14:28,319 --> 00:14:38,099
looking for the part that contains the

269
00:14:31,889 --> 00:14:39,800
emote head strings and there is also

270
00:14:38,100 --> 00:14:43,529
some obfuscation of the PowerShell code

271
00:14:39,800 --> 00:14:45,689
there are first of all PowerShell uses

272
00:14:43,529 --> 00:14:49,019
backticks instead of backslash

273
00:14:45,690 --> 00:14:52,050
characters to to signify escape

274
00:14:49,019 --> 00:14:54,569
characters so if you have a backslash n

275
00:14:52,050 --> 00:14:57,389
this is a new line but just inside a

276
00:14:54,569 --> 00:15:02,099
string if the backtick end is outside of

277
00:14:57,389 --> 00:15:03,990
a string then it is regarded as a line

278
00:15:02,100 --> 00:15:05,579
continuation character just like the

279
00:15:03,990 --> 00:15:08,310
underscore I showed you before or like

280
00:15:05,579 --> 00:15:10,410
the backslash in C and if the backtick

281
00:15:08,310 --> 00:15:15,899
is not at the end of a line it is just

282
00:15:10,410 --> 00:15:17,790
ignored so the code here actually you

283
00:15:15,899 --> 00:15:22,140
can just remove the backticks and you

284
00:15:17,790 --> 00:15:26,069
have the valid code then

285
00:15:22,140 --> 00:15:29,250
location technique is it's not really an

286
00:15:26,070 --> 00:15:33,360
operation technique it's just a format

287
00:15:29,250 --> 00:15:36,510
confusion when you pass base64 blob to

288
00:15:33,360 --> 00:15:38,340
PowerShell it will automatically figure

289
00:15:36,510 --> 00:15:40,319
out the encoding so if you pass

290
00:15:38,340 --> 00:15:42,270
something that is utf-16 encoded like

291
00:15:40,320 --> 00:15:45,030
here then it will automatically

292
00:15:42,270 --> 00:15:49,050
understand it is utf-16 and will

293
00:15:45,030 --> 00:15:50,400
correctly decode it and that's a bit

294
00:15:49,050 --> 00:15:55,170
annoying because we need to do the same

295
00:15:50,400 --> 00:15:57,420
thing if we get the content and finally

296
00:15:55,170 --> 00:16:00,660
the same as in vba you have constant

297
00:15:57,420 --> 00:16:03,030
operations and case insensitivity so

298
00:16:00,660 --> 00:16:05,100
that this expression here which is one

299
00:16:03,030 --> 00:16:09,780
string gets split into an array of

300
00:16:05,100 --> 00:16:16,260
several strings and you need to handle

301
00:16:09,780 --> 00:16:18,120
this correctly okay so those were the

302
00:16:16,260 --> 00:16:24,870
problems that we have now let's find a

303
00:16:18,120 --> 00:16:27,090
solution yeah so my first thought was

304
00:16:24,870 --> 00:16:30,360
let's do it simple we just go into

305
00:16:27,090 --> 00:16:32,550
instrument MSV BM v b vm v l-l which is

306
00:16:30,360 --> 00:16:35,370
the dll that contains the Visual Basic

307
00:16:32,550 --> 00:16:39,420
virtual machine and I found this

308
00:16:35,370 --> 00:16:41,880
function it looks like this function is

309
00:16:39,420 --> 00:16:46,439
just taking an opcode and doing

310
00:16:41,880 --> 00:16:49,920
everything so I decided okay we're not

311
00:16:46,440 --> 00:16:52,260
going to use MSV BM v b BM & dll also

312
00:16:49,920 --> 00:16:54,479
the problem is that the integration

313
00:16:52,260 --> 00:16:57,750
between Visual Basic and office is quite

314
00:16:54,480 --> 00:16:59,910
tight so my initial thought was that

315
00:16:57,750 --> 00:17:01,890
maybe I can just take the dll I invoke

316
00:16:59,910 --> 00:17:05,099
one function in the DLL I get my code

317
00:17:01,890 --> 00:17:06,930
executed and I do this in a small

318
00:17:05,099 --> 00:17:09,659
sandbox environment so that I can see

319
00:17:06,930 --> 00:17:12,060
what's happening but since the

320
00:17:09,660 --> 00:17:14,820
integration with office is very tight

321
00:17:12,060 --> 00:17:20,909
it's not easy to just call a function in

322
00:17:14,819 --> 00:17:23,159
this DLL so different approach so this

323
00:17:20,910 --> 00:17:24,720
is where we went ahead and said okay

324
00:17:23,160 --> 00:17:29,670
let's try to interpret the code

325
00:17:24,720 --> 00:17:31,380
ourselves and we looked for existing

326
00:17:29,670 --> 00:17:34,620
interpreters that are around there for

327
00:17:31,380 --> 00:17:35,460
Visual Basic for applications and there

328
00:17:34,620 --> 00:17:38,370
is actually

329
00:17:35,460 --> 00:17:44,460
in libreoffice which is called star

330
00:17:38,370 --> 00:17:51,090
basic it is quite old the Parsis

331
00:17:44,460 --> 00:17:53,520
handwritten it works but it is the the

332
00:17:51,090 --> 00:17:56,459
star basic is very tightly knit into

333
00:17:53,520 --> 00:17:59,730
Libre Office so whenever you try to

334
00:17:56,460 --> 00:18:01,820
access something when you try to tear

335
00:17:59,730 --> 00:18:04,110
out the star basic code from LibreOffice

336
00:18:01,820 --> 00:18:08,070
you will have a lot of dependencies that

337
00:18:04,110 --> 00:18:09,689
you need to resolve and assuming you

338
00:18:08,070 --> 00:18:11,610
know so I managed in the end to make the

339
00:18:09,690 --> 00:18:16,050
code run standalone but then you still

340
00:18:11,610 --> 00:18:20,909
have a lot of you know objects which is

341
00:18:16,050 --> 00:18:24,629
the LibreOffice version of all objects

342
00:18:20,910 --> 00:18:26,880
that are not present because they were

343
00:18:24,630 --> 00:18:29,070
originally in Libre Office and I didn't

344
00:18:26,880 --> 00:18:31,920
take them over because they have too

345
00:18:29,070 --> 00:18:35,340
many dependencies so in the end I gave

346
00:18:31,920 --> 00:18:38,790
up on trying to make this code work with

347
00:18:35,340 --> 00:18:43,649
a patent rocker and look for something

348
00:18:38,790 --> 00:18:45,629
else okay so the second attempt after a

349
00:18:43,650 --> 00:18:51,480
while I found a repository in github

350
00:18:45,630 --> 00:18:55,200
from guy named in choix I don't know

351
00:18:51,480 --> 00:18:57,180
anything more about him I I just mailed

352
00:18:55,200 --> 00:19:00,270
him to tell him that I want to use the

353
00:18:57,180 --> 00:19:02,340
code and he told me it's fine but be

354
00:19:00,270 --> 00:19:07,910
very careful with the code it was never

355
00:19:02,340 --> 00:19:10,230
meant for to be used so why this code

356
00:19:07,910 --> 00:19:13,370
what's the advantage of this code over

357
00:19:10,230 --> 00:19:16,520
the other one first of all it uses

358
00:19:13,370 --> 00:19:20,419
antler which is a passage generator and

359
00:19:16,520 --> 00:19:22,920
I don't trust myself to write a puzzling

360
00:19:20,420 --> 00:19:24,600
so I would rather have a parser

361
00:19:22,920 --> 00:19:28,620
generator that does that for me

362
00:19:24,600 --> 00:19:30,570
and fortunately the grammar that was

363
00:19:28,620 --> 00:19:33,149
inside this project this comes from

364
00:19:30,570 --> 00:19:36,240
robotics which is a plug-in for

365
00:19:33,150 --> 00:19:39,650
analyzing VBA in a graphical interface

366
00:19:36,240 --> 00:19:41,790
and also the specification is open and

367
00:19:39,650 --> 00:19:44,790
microsoft itself has provided an

368
00:19:41,790 --> 00:19:48,350
antelope grammar for alongside the

369
00:19:44,790 --> 00:19:48,350
specification so that's pretty cool

370
00:19:48,400 --> 00:19:55,990
the project is written in Java again I

371
00:19:51,460 --> 00:19:59,320
don't trust myself to handle handled

372
00:19:55,990 --> 00:20:01,809
memory objects correctly and to handle

373
00:19:59,320 --> 00:20:06,178
the two always check the sizes so I

374
00:20:01,809 --> 00:20:08,500
prefer Java oversee simply for this and

375
00:20:06,179 --> 00:20:15,580
the project has a pretty cool interface

376
00:20:08,500 --> 00:20:18,940
to invoke Java methods from VBA but the

377
00:20:15,580 --> 00:20:22,830
the problem with this code was that the

378
00:20:18,940 --> 00:20:25,779
guy tried to make everything compile so

379
00:20:22,830 --> 00:20:29,889
VBA is pretty dynamic in its nature a

380
00:20:25,779 --> 00:20:33,010
bit like Python so you can invoke you

381
00:20:29,890 --> 00:20:35,230
can evaluate code at runtime and you

382
00:20:33,010 --> 00:20:37,379
have a lot of objects that don't have a

383
00:20:35,230 --> 00:20:41,080
type that are known at compile time and

384
00:20:37,380 --> 00:20:45,460
for these objects it is hard to try to

385
00:20:41,080 --> 00:20:50,020
compile it statically so I had to amend

386
00:20:45,460 --> 00:20:53,799
the project in this respect so this

387
00:20:50,020 --> 00:20:55,120
yielded our implementation where we

388
00:20:53,799 --> 00:20:58,029
start with the document with mouth

389
00:20:55,120 --> 00:21:00,668
closed we have a parser that is

390
00:20:58,029 --> 00:21:03,340
generated by our parser generator from

391
00:21:00,669 --> 00:21:05,620
unplug Rama we get an abstract syntax

392
00:21:03,340 --> 00:21:10,418
tree that is actually never exposed

393
00:21:05,620 --> 00:21:12,489
explicitly but is directly compiled to

394
00:21:10,419 --> 00:21:14,500
opcodes then we have an opcode

395
00:21:12,490 --> 00:21:17,080
representation of the program this is

396
00:21:14,500 --> 00:21:19,929
pretty similar to what LibreOffice is

397
00:21:17,080 --> 00:21:22,689
doing we're running this on our

398
00:21:19,929 --> 00:21:32,399
interpreter and finally we get a couple

399
00:21:22,690 --> 00:21:34,230
of observables in our report so yeah our

400
00:21:32,399 --> 00:21:36,879
implementation is a hybrid between

401
00:21:34,230 --> 00:21:40,480
libreoffice and this VBA interpreter

402
00:21:36,880 --> 00:21:42,419
project the parser is a lot slower than

403
00:21:40,480 --> 00:21:45,340
the libreoffice parser because it's

404
00:21:42,419 --> 00:21:47,860
nothing beats a handwritten parcel but

405
00:21:45,340 --> 00:21:49,639
hopefully it is also a bit more adherent

406
00:21:47,860 --> 00:21:58,209
to the specification and

407
00:21:49,640 --> 00:22:00,590
more secure yeah and the opcode

408
00:21:58,210 --> 00:22:05,870
representation as I said is inspired by

409
00:22:00,590 --> 00:22:07,820
LibreOffice and the advantage of this

410
00:22:05,870 --> 00:22:10,550
implementation is that since everything

411
00:22:07,820 --> 00:22:13,189
is a result at runtime it is pretty easy

412
00:22:10,550 --> 00:22:16,340
to handle dynamic types and it is also

413
00:22:13,190 --> 00:22:18,680
pretty easy to handle objects where you

414
00:22:16,340 --> 00:22:21,800
don't know what a motet expects them to

415
00:22:18,680 --> 00:22:27,110
be so if you want you can do something

416
00:22:21,800 --> 00:22:29,450
like slightly like a slide phaser where

417
00:22:27,110 --> 00:22:31,669
you give a motet an object that is not

418
00:22:29,450 --> 00:22:34,940
initialized and when it invokes a method

419
00:22:31,670 --> 00:22:39,920
on this object then you generate warning

420
00:22:34,940 --> 00:22:43,750
in the log from that our interpreter is

421
00:22:39,920 --> 00:22:46,690
a stack based interpreter the

422
00:22:43,750 --> 00:22:50,780
instructions are expressed as opcodes

423
00:22:46,690 --> 00:22:53,470
values are stored on a stack and a

424
00:22:50,780 --> 00:22:57,080
nested structure of dictionaries are our

425
00:22:53,470 --> 00:23:00,500
context our our scopes where our

426
00:22:57,080 --> 00:23:02,270
variables are stored there are lots of

427
00:23:00,500 --> 00:23:04,430
intricacies that need to be handled I

428
00:23:02,270 --> 00:23:06,590
showed before the on error zoom next

429
00:23:04,430 --> 00:23:08,000
instruction so we need to handle this

430
00:23:06,590 --> 00:23:09,770
correctly in the interpreter and we need

431
00:23:08,000 --> 00:23:12,860
to make sure that if an instruction is

432
00:23:09,770 --> 00:23:16,070
aborted during execution that we clear

433
00:23:12,860 --> 00:23:19,969
up all the artifacts that were generated

434
00:23:16,070 --> 00:23:22,370
during the execution and the function

435
00:23:19,970 --> 00:23:25,880
return values are a bit tricky in VBA

436
00:23:22,370 --> 00:23:27,800
so the way VBA denotes a return value

437
00:23:25,880 --> 00:23:32,960
from a function is that you just assign

438
00:23:27,800 --> 00:23:34,490
something to the function name itself so

439
00:23:32,960 --> 00:23:36,590
it's like there is a secret variable

440
00:23:34,490 --> 00:23:38,570
that is initialized in the beginning to

441
00:23:36,590 --> 00:23:41,330
empty and then you assign to the to

442
00:23:38,570 --> 00:23:43,280
itself and then when you return vba will

443
00:23:41,330 --> 00:23:46,580
read the secret variable and put and

444
00:23:43,280 --> 00:23:48,800
return this value unfortunately if you

445
00:23:46,580 --> 00:23:52,100
implement it exactly this way and you

446
00:23:48,800 --> 00:23:54,409
have a variable for that it means that

447
00:23:52,100 --> 00:23:56,510
this variable will then shadow the

448
00:23:54,410 --> 00:23:58,430
function name itself so when you try to

449
00:23:56,510 --> 00:24:01,700
recursively call the function after you

450
00:23:58,430 --> 00:24:03,440
have set a return value then

451
00:24:01,700 --> 00:24:06,230
my implementation will find the return

452
00:24:03,440 --> 00:24:09,320
value instead of the function name so

453
00:24:06,230 --> 00:24:13,039
this requires also some special handling

454
00:24:09,320 --> 00:24:17,539
and the argument notation in Visual

455
00:24:13,039 --> 00:24:19,850
Basic is positively annoying if if you

456
00:24:17,539 --> 00:24:23,120
have something that is just a name it

457
00:24:19,850 --> 00:24:25,189
means it can either be a variable or it

458
00:24:23,120 --> 00:24:28,008
can be a procedure that is invoked

459
00:24:25,190 --> 00:24:30,490
without arguments so whenever you have a

460
00:24:28,009 --> 00:24:33,529
variable you need to invoke the variable

461
00:24:30,490 --> 00:24:34,909
just to get its value because it could

462
00:24:33,529 --> 00:24:39,259
also be a procedure that you actually

463
00:24:34,909 --> 00:24:42,080
need to invoke in execute code so yeah a

464
00:24:39,259 --> 00:24:44,389
couple of things that are annoying okay

465
00:24:42,080 --> 00:24:47,449
let's look at how the implementation

466
00:24:44,389 --> 00:24:50,418
works if you're already familiar with

467
00:24:47,450 --> 00:24:53,529
Java how the java virtual machine works

468
00:24:50,419 --> 00:24:56,749
then this is nothing new for you I think

469
00:24:53,529 --> 00:25:00,820
we just start with a very simple program

470
00:24:56,749 --> 00:25:05,559
we want to execute a equals a plus B and

471
00:25:00,820 --> 00:25:08,779
we first push a string a on the stack

472
00:25:05,559 --> 00:25:13,158
then we have the find instruction that

473
00:25:08,779 --> 00:25:17,240
fetches us the variable named a from our

474
00:25:13,159 --> 00:25:20,210
dictionary of variables we do the same

475
00:25:17,240 --> 00:25:23,419
for variable B that we push the string

476
00:25:20,210 --> 00:25:26,740
on the stack we find the value of B in

477
00:25:23,419 --> 00:25:29,119
our dictionary retrieve the value and

478
00:25:26,740 --> 00:25:32,240
then we have an add instruction that

479
00:25:29,119 --> 00:25:36,289
just pops the toups top values of our

480
00:25:32,240 --> 00:25:39,860
stack execute the addition and puts the

481
00:25:36,289 --> 00:25:43,759
return value back and finally the write

482
00:25:39,860 --> 00:25:46,240
instruction not then we push again a for

483
00:25:43,759 --> 00:25:49,309
the variable we want to write to and

484
00:25:46,240 --> 00:25:53,799
finally the right instruction takes the

485
00:25:49,309 --> 00:25:57,700
two top values and writes the value to a

486
00:25:53,799 --> 00:25:57,700
so that's pretty simple

487
00:25:57,820 --> 00:26:05,689
what we get out in the end is a report

488
00:26:01,279 --> 00:26:07,460
like that so what we have done is we

489
00:26:05,690 --> 00:26:11,539
have instrumented all the functions that

490
00:26:07,460 --> 00:26:13,369
are doing something that is malicious we

491
00:26:11,539 --> 00:26:14,750
have the process window height

492
00:26:13,369 --> 00:26:17,168
instrumented

493
00:26:14,750 --> 00:26:20,210
we have the process start event

494
00:26:17,169 --> 00:26:25,220
instrumented and of course we don't

495
00:26:20,210 --> 00:26:28,309
execute them in the system so this is an

496
00:26:25,220 --> 00:26:34,669
advantage of our sandbox compared to if

497
00:26:28,309 --> 00:26:37,190
you execute the VBA in in a VM inside

498
00:26:34,669 --> 00:26:39,080
office that there you actually need to

499
00:26:37,190 --> 00:26:41,600
give the document access to the Internet

500
00:26:39,080 --> 00:26:43,189
if you want to see what it does or you

501
00:26:41,600 --> 00:26:45,320
need to emulate an F network traffic

502
00:26:43,190 --> 00:26:50,390
here we can just extract the events like

503
00:26:45,320 --> 00:26:53,360
that and then we can go ahead and decode

504
00:26:50,390 --> 00:27:01,159
the PowerShell blob with simple

505
00:26:53,360 --> 00:27:03,949
heuristics and be done with it so how

506
00:27:01,159 --> 00:27:07,880
does this fare compared to our previous

507
00:27:03,950 --> 00:27:10,250
solution of spinning a BMS well I'm

508
00:27:07,880 --> 00:27:13,909
pretty satisfied the just this prototype

509
00:27:10,250 --> 00:27:17,179
that I currently have takes 1.2 seconds

510
00:27:13,909 --> 00:27:18,380
for a document the whole just from the

511
00:27:17,179 --> 00:27:21,590
execution from the command line

512
00:27:18,380 --> 00:27:26,210
startup till finish and memory usage is

513
00:27:21,590 --> 00:27:29,270
around 300 megabytes and country well be

514
00:27:26,210 --> 00:27:31,039
m/s are also easy to paralyze but here

515
00:27:29,270 --> 00:27:32,570
you just spin up several processes on

516
00:27:31,039 --> 00:27:35,780
the same machine they don't influence

517
00:27:32,570 --> 00:27:37,309
each other and you can you can have a

518
00:27:35,780 --> 00:27:40,879
couple of hundred processes on the same

519
00:27:37,309 --> 00:27:44,418
machine if your memory does does allow

520
00:27:40,880 --> 00:27:51,350
you that so the performance for just the

521
00:27:44,419 --> 00:27:53,330
prototype is pretty ok of course that's

522
00:27:51,350 --> 00:27:57,469
not everything there are some

523
00:27:53,330 --> 00:27:59,629
shortcomings so one thing I didn't

524
00:27:57,470 --> 00:28:01,909
mention in the beginning is that office

525
00:27:59,630 --> 00:28:04,850
documents carry several versions of

526
00:28:01,909 --> 00:28:07,909
macro code inside there is the source

527
00:28:04,850 --> 00:28:10,428
code that is textual but there is also a

528
00:28:07,909 --> 00:28:14,600
semi compiled version that is called P

529
00:28:10,429 --> 00:28:16,549
code and sometimes there is binary code

530
00:28:14,600 --> 00:28:18,740
about this part I'm not a hundred

531
00:28:16,549 --> 00:28:24,289
percent sure when it carries binary code

532
00:28:18,740 --> 00:28:26,000
or not if we have some time I will go

533
00:28:24,289 --> 00:28:28,780
deeper into the P code but for the

534
00:28:26,000 --> 00:28:28,780
moment let's keep that

535
00:28:28,990 --> 00:28:32,080
the code is currently in a very hockey

536
00:28:31,389 --> 00:28:34,418
state

537
00:28:32,080 --> 00:28:36,789
I plan to clean it up and to have it in

538
00:28:34,419 --> 00:28:39,610
better shape but that takes some work

539
00:28:36,789 --> 00:28:42,100
and lots of stuff is not implemented so

540
00:28:39,610 --> 00:28:43,959
currently I only looked at the runtime

541
00:28:42,100 --> 00:28:45,998
functions I need it is pretty easy to

542
00:28:43,960 --> 00:28:49,090
add new runtime functions a lot of them

543
00:28:45,999 --> 00:28:53,379
are currently just commented but this is

544
00:28:49,090 --> 00:28:55,178
what it needs to be done and yeah there

545
00:28:53,379 --> 00:28:56,799
is still some small things like current

546
00:28:55,179 --> 00:29:04,330
and correct handling of recursive

547
00:28:56,799 --> 00:29:07,360
functions the project future is that I

548
00:29:04,330 --> 00:29:10,449
hope that we can put this as an internal

549
00:29:07,360 --> 00:29:12,939
service at first where we will allow

550
00:29:10,450 --> 00:29:15,009
people who have who are doing

551
00:29:12,940 --> 00:29:18,549
investigations to submit documents and

552
00:29:15,009 --> 00:29:23,740
also I would like to hook our sample

553
00:29:18,549 --> 00:29:26,320
stream we have inside Cisco we have mail

554
00:29:23,740 --> 00:29:30,909
gateway and we get documents from the

555
00:29:26,320 --> 00:29:34,090
mail gateway so we we have a couple of

556
00:29:30,909 --> 00:29:36,429
thousand documents per day out for a

557
00:29:34,090 --> 00:29:38,820
motet alone that arrived and I would

558
00:29:36,429 --> 00:29:41,799
like to plug those documents inside the

559
00:29:38,820 --> 00:29:44,110
emulator and get the results from it so

560
00:29:41,799 --> 00:29:49,590
that we can directly take them the URLs

561
00:29:44,110 --> 00:29:53,219
extracted from these documents and and

562
00:29:49,590 --> 00:29:57,699
get the binaries marked MSE motet and

563
00:29:53,220 --> 00:30:03,700
carry carried the good detection that we

564
00:29:57,700 --> 00:30:06,369
have through the system and currently

565
00:30:03,700 --> 00:30:10,600
the interpreter is optimized for a motet

566
00:30:06,369 --> 00:30:16,019
I would like to also see that it handles

567
00:30:10,600 --> 00:30:18,129
right X and other natural malware well

568
00:30:16,019 --> 00:30:22,149
I've provided you with a couple of

569
00:30:18,129 --> 00:30:25,269
references there are articles about

570
00:30:22,149 --> 00:30:27,539
imitate there is the original repository

571
00:30:25,269 --> 00:30:31,570
that I used the libreoffice repository

572
00:30:27,539 --> 00:30:33,879
pico dump is a utility that is very cool

573
00:30:31,570 --> 00:30:37,869
to dump the peacoat representation

574
00:30:33,879 --> 00:30:40,629
inside the document viper monkey and oli

575
00:30:37,869 --> 00:30:42,850
tools are the tools from Phillip backlog

576
00:30:40,629 --> 00:30:49,850
addict

577
00:30:42,850 --> 00:30:51,830
and not now but on Monday you should be

578
00:30:49,850 --> 00:30:55,159
able to download the code of this

579
00:30:51,830 --> 00:30:58,639
project here I will also provide the

580
00:30:55,160 --> 00:31:01,340
slides so as soon as the slides are

581
00:30:58,640 --> 00:31:04,790
online you should have the URL okay

582
00:31:01,340 --> 00:31:08,629
let's go and have a look at the tool

583
00:31:04,790 --> 00:31:11,870
running so first of all I want to show

584
00:31:08,630 --> 00:31:13,760
you the output of all e tools and Viper

585
00:31:11,870 --> 00:31:28,219
monkey so that you have an idea of what

586
00:31:13,760 --> 00:31:30,620
is tools currently do ok so this is the

587
00:31:28,220 --> 00:31:35,780
source code as its extracted from all

588
00:31:30,620 --> 00:31:40,370
eTools you have something that you see

589
00:31:35,780 --> 00:31:44,540
that is missing here is the class class

590
00:31:40,370 --> 00:31:45,949
module which is not correctly well it

591
00:31:44,540 --> 00:31:48,020
doesn't have any code attached it only

592
00:31:45,950 --> 00:31:50,210
has variable assignments attached but

593
00:31:48,020 --> 00:31:54,020
these variable assignments are not

594
00:31:50,210 --> 00:32:05,270
exposed by only tools you have the code

595
00:31:54,020 --> 00:32:08,960
that is being extracted and in the very

596
00:32:05,270 --> 00:32:12,049
end you have a list of observables that

597
00:32:08,960 --> 00:32:14,720
all it will extract from the document a

598
00:32:12,049 --> 00:32:16,850
lot of them are very useful like this

599
00:32:14,720 --> 00:32:20,809
here says it has an auto open function

600
00:32:16,850 --> 00:32:23,360
and it recognizes a couple of suspicious

601
00:32:20,809 --> 00:32:27,080
functions but the problem is that now

602
00:32:23,360 --> 00:32:28,939
the emote head authors know that people

603
00:32:27,080 --> 00:32:33,379
are analyzing with these tools and they

604
00:32:28,940 --> 00:32:35,679
also embed a lot of fails observables so

605
00:32:33,380 --> 00:32:38,510
you have a ton of IP addresses here that

606
00:32:35,679 --> 00:32:40,280
I'd try to figure out just with the

607
00:32:38,510 --> 00:32:45,940
Whois if they target specific people

608
00:32:40,280 --> 00:32:45,940
with that but it doesn't look like that

609
00:32:46,390 --> 00:32:49,990
ok then

610
00:32:56,720 --> 00:33:05,210
hey then we have Viper monkey

611
00:33:08,299 --> 00:33:14,369
so Viper monkey is just looking for

612
00:33:12,779 --> 00:33:18,470
certain expressions parsing those

613
00:33:14,369 --> 00:33:23,059
expressions and executing those

614
00:33:18,470 --> 00:33:26,159
expressions it also works fairly well

615
00:33:23,059 --> 00:33:31,320
but you will see that it will also

616
00:33:26,159 --> 00:33:36,539
exhibit some fails positives and in

617
00:33:31,320 --> 00:33:40,860
addition it is not super fast its Python

618
00:33:36,539 --> 00:33:44,639
and the already the parser generator and

619
00:33:40,860 --> 00:33:47,309
Python is pretty slow so you see it also

620
00:33:44,639 --> 00:33:49,830
found the auto open it found a couple of

621
00:33:47,309 --> 00:33:53,940
interesting functions like the caption

622
00:33:49,830 --> 00:33:55,350
and the win32 process but it doesn't

623
00:33:53,940 --> 00:34:04,820
show you the command line that is being

624
00:33:55,350 --> 00:34:08,520
executed okay so let's get to our tool

625
00:34:04,820 --> 00:34:11,869
so this is a presentation of the source

626
00:34:08,520 --> 00:34:16,679
code that is being dumped by our tool

627
00:34:11,869 --> 00:34:25,379
what was missing before is the project

628
00:34:16,679 --> 00:34:27,299
description and this section here which

629
00:34:25,379 --> 00:34:32,750
is the class module which contains all

630
00:34:27,299 --> 00:34:36,690
the objects that are serialized and

631
00:34:32,750 --> 00:34:41,668
finally you also have in the end in the

632
00:34:36,690 --> 00:34:44,069
end you have the serialized object

633
00:34:41,668 --> 00:34:47,399
contents so this is where the actual

634
00:34:44,069 --> 00:34:51,349
imitate PowerShell code is that is then

635
00:34:47,399 --> 00:34:51,348
being used and

636
00:34:57,640 --> 00:35:03,069
this is what the tool execution looks

637
00:34:59,530 --> 00:35:15,060
like so you see it's quite fast it dumps

638
00:35:03,070 --> 00:35:15,060
you the whole block of of code here and

639
00:35:15,090 --> 00:35:20,710
now you can go on and analyze what is

640
00:35:18,580 --> 00:35:28,150
inside you can get the URLs and you can

641
00:35:20,710 --> 00:35:37,360
handle what's going on so this brings me

642
00:35:28,150 --> 00:35:39,720
to the end and in the end are your

643
00:35:37,360 --> 00:35:39,720
questions

644
00:35:48,020 --> 00:35:52,740
thank you so much we have time for

645
00:35:50,430 --> 00:36:00,419
questions so if you have any question

646
00:35:52,740 --> 00:36:03,779
yes thank you for your talk you said

647
00:36:00,420 --> 00:36:06,980
that your tool was specific quite

648
00:36:03,780 --> 00:36:10,020
specific for ma tête

649
00:36:06,980 --> 00:36:13,260
in what way and what would you need to

650
00:36:10,020 --> 00:36:17,070
add to be able to analyze other tools

651
00:36:13,260 --> 00:36:18,720
other malware so right but specific to

652
00:36:17,070 --> 00:36:21,180
imitators because I used emotive

653
00:36:18,720 --> 00:36:23,399
documents to go along in the development

654
00:36:21,180 --> 00:36:25,649
and to see what's needed

655
00:36:23,400 --> 00:36:31,470
what is mainly needed for other

656
00:36:25,650 --> 00:36:34,260
documents is library functions and yeah

657
00:36:31,470 --> 00:36:36,480
so library functions plus looking at the

658
00:36:34,260 --> 00:36:38,430
library functions what you should not do

659
00:36:36,480 --> 00:36:41,070
on your system so for example if it

660
00:36:38,430 --> 00:36:44,669
writes code to a file you need to neuter

661
00:36:41,070 --> 00:36:46,380
this and you need to just write it in a

662
00:36:44,670 --> 00:36:48,720
temporary path whether you can analyze

663
00:36:46,380 --> 00:36:50,250
it then of course at some point the

664
00:36:48,720 --> 00:36:53,098
malware authors will come and they will

665
00:36:50,250 --> 00:36:55,680
write a file just to test if they're in

666
00:36:53,099 --> 00:36:59,550
the emulated environment but this is

667
00:36:55,680 --> 00:37:02,759
something that I will see then also if

668
00:36:59,550 --> 00:37:03,720
if this appears very soon in e motet I

669
00:37:02,760 --> 00:37:07,700
know that they're following this

670
00:37:03,720 --> 00:37:11,810
presentation which is interesting

671
00:37:07,700 --> 00:37:11,810
another common question yes

672
00:37:20,060 --> 00:37:27,660
still about the topic of response of

673
00:37:23,849 --> 00:37:30,900
malware authors how hard would it be for

674
00:37:27,660 --> 00:37:36,420
them doing that such tools are being

675
00:37:30,900 --> 00:37:39,780
used to hide interesting behaviors this

676
00:37:36,420 --> 00:37:41,970
is the same question as for any sandbox

677
00:37:39,780 --> 00:37:43,770
it boils down to a cat-and-mouse game so

678
00:37:41,970 --> 00:37:47,310
at some point they will implement

679
00:37:43,770 --> 00:37:49,259
defenses against the sandbox and then we

680
00:37:47,310 --> 00:37:53,529
will implement defenses against their

681
00:37:49,260 --> 00:37:55,900
defenses so

682
00:37:53,530 --> 00:37:58,780
it so first of all it depends on if they

683
00:37:55,900 --> 00:38:03,820
see us as a valid threat and once they

684
00:37:58,780 --> 00:38:08,910
do then we play with them what's our

685
00:38:03,820 --> 00:38:11,100
question comments we still have time yes

686
00:38:08,910 --> 00:38:20,799
MA

687
00:38:11,100 --> 00:38:23,860
same one in case you might want to adapt

688
00:38:20,800 --> 00:38:27,760
your tools for other mod well how would

689
00:38:23,860 --> 00:38:31,180
you ensure that custom-made interpreter

690
00:38:27,760 --> 00:38:33,280
will implement the exact same and

691
00:38:31,180 --> 00:38:35,980
behavior as the original VBA

692
00:38:33,280 --> 00:38:40,870
implementation including all the corner

693
00:38:35,980 --> 00:38:44,050
cases even the undocumented ones so the

694
00:38:40,870 --> 00:38:47,200
the easy way how at the moment this is

695
00:38:44,050 --> 00:38:48,970
the development stage but my next step

696
00:38:47,200 --> 00:38:51,220
will be that I hook up the interpreter

697
00:38:48,970 --> 00:38:53,379
to the sample path I will execute the

698
00:38:51,220 --> 00:38:56,290
interpreter I will see what observables

699
00:38:53,380 --> 00:38:59,470
I cannot extract and then I can run the

700
00:38:56,290 --> 00:39:01,800
same sample in our sandbox with office

701
00:38:59,470 --> 00:39:04,480
where we get all the observables and

702
00:39:01,800 --> 00:39:06,940
then I can actually cross correlate and

703
00:39:04,480 --> 00:39:10,150
see if I find observables that I find in

704
00:39:06,940 --> 00:39:12,010
my report there and if I find observers

705
00:39:10,150 --> 00:39:13,960
that have been deemed malicious from

706
00:39:12,010 --> 00:39:16,960
there also in my report and then I can

707
00:39:13,960 --> 00:39:19,630
cross validate between the two and for

708
00:39:16,960 --> 00:39:21,430
development I just go into office and at

709
00:39:19,630 --> 00:39:24,070
dry concrete commands to see what they

710
00:39:21,430 --> 00:39:25,750
do and sometimes they're surprising

711
00:39:24,070 --> 00:39:28,090
corner cases for example the replace

712
00:39:25,750 --> 00:39:29,800
function for replacing something in a

713
00:39:28,090 --> 00:39:31,390
string in VBA behaves completely

714
00:39:29,800 --> 00:39:34,210
differently than the Python function

715
00:39:31,390 --> 00:39:36,370
it's instead of going character by

716
00:39:34,210 --> 00:39:39,340
character through and then replacing it

717
00:39:36,370 --> 00:39:42,069
replaces it goes through finds the first

718
00:39:39,340 --> 00:39:44,620
occurrence of the string so it calls the

719
00:39:42,070 --> 00:39:46,300
find function on the string finds an

720
00:39:44,620 --> 00:39:48,339
occurrence then it replaces this

721
00:39:46,300 --> 00:39:52,090
occurrence and then it calls the find

722
00:39:48,340 --> 00:39:54,040
function again from offset zero and they

723
00:39:52,090 --> 00:40:00,720
are actually using this to confuse

724
00:39:54,040 --> 00:40:00,720
people why

725
00:40:01,620 --> 00:40:07,440
are there winning new performances or

726
00:40:04,260 --> 00:40:10,140
something with these tricks no because

727
00:40:07,440 --> 00:40:12,590
okay so I was waiting for this no it

728
00:40:10,140 --> 00:40:12,589
doesn't work

729
00:40:15,570 --> 00:40:22,230
Electric okay this is already enough

730
00:40:21,020 --> 00:40:24,840
thanks

731
00:40:22,230 --> 00:40:31,280
okay so imagine you have a string that

732
00:40:24,840 --> 00:40:33,780
is like this so you will go through

733
00:40:31,280 --> 00:40:41,850
let's say our spring that we want to

734
00:40:33,780 --> 00:40:46,290
replace is a B so we have C a BB abbc if

735
00:40:41,850 --> 00:40:48,509
you go through the implementation of a

736
00:40:46,290 --> 00:40:50,790
visual basic will first find this string

737
00:40:48,510 --> 00:40:54,810
replace it with nothing and then you

738
00:40:50,790 --> 00:40:58,320
have C ABC and then this will go

739
00:40:54,810 --> 00:41:00,120
together so you have this and then it

740
00:40:58,320 --> 00:41:03,080
will place this part and then C C

741
00:41:00,120 --> 00:41:06,480
remains what Python will go through will

742
00:41:03,080 --> 00:41:09,000
at this point replace but then will go

743
00:41:06,480 --> 00:41:15,270
on in the string so you will have C ABC

744
00:41:09,000 --> 00:41:18,480
as a result so just subtly rensis which

745
00:41:15,270 --> 00:41:23,480
one is correct it depends on your

746
00:41:18,480 --> 00:41:25,790
specification no produce the same output

747
00:41:23,480 --> 00:41:30,570
they are not comparable

748
00:41:25,790 --> 00:41:32,430
no but it's well visual basic I think

749
00:41:30,570 --> 00:41:34,950
the specification of Visual Basic is

750
00:41:32,430 --> 00:41:39,950
visual basic so you cannot say that it's

751
00:41:34,950 --> 00:41:43,319
wrong or right ok one other question

752
00:41:39,950 --> 00:41:46,799
sorry the same question but that means

753
00:41:43,320 --> 00:41:51,630
that if you want to replace say name

754
00:41:46,800 --> 00:41:57,270
with some value X now X is actually

755
00:41:51,630 --> 00:41:59,550
named you're just looping that's a good

756
00:41:57,270 --> 00:42:02,009
case I will take what VBA does on this

757
00:41:59,550 --> 00:42:05,100
case yes it's interesting but I think

758
00:42:02,010 --> 00:42:06,930
they have an if to just yeah I think and

759
00:42:05,100 --> 00:42:08,610
yeah in mine so what I did in my

760
00:42:06,930 --> 00:42:09,870
implementation is I have an if in the

761
00:42:08,610 --> 00:42:11,430
beginning to check if the expression

762
00:42:09,870 --> 00:42:12,950
that you're replacing with is the same

763
00:42:11,430 --> 00:42:18,890
as the one you're searching and

764
00:42:12,950 --> 00:42:28,970
I'm just aborting I was a question yes

765
00:42:18,890 --> 00:42:34,129
we go fast thanks for the talk

766
00:42:28,970 --> 00:42:38,089
have you tried to use a MC Porsche and

767
00:42:34,130 --> 00:42:45,609
when we Windows then it's a feature on

768
00:42:38,089 --> 00:42:45,609
partial to block the user execution of

769
00:42:47,349 --> 00:42:54,980
the code and the can can look to block

770
00:42:52,190 --> 00:42:58,670
just just before the execution and you

771
00:42:54,980 --> 00:43:02,359
can catch the first occasion change a

772
00:42:58,670 --> 00:43:04,570
few traces or no identify this this

773
00:43:02,359 --> 00:43:08,319
could be interesting okay yeah

774
00:43:04,570 --> 00:43:13,940
understand you can you can do this okay

775
00:43:08,320 --> 00:43:15,980
one more collaborator for you okay we

776
00:43:13,940 --> 00:43:21,109
talked about the fact that it was hard

777
00:43:15,980 --> 00:43:24,890
to know what was the real ideal behavior

778
00:43:21,109 --> 00:43:29,869
of VBA but did you find some cases where

779
00:43:24,890 --> 00:43:33,440
I don't know office 2003 would behave

780
00:43:29,869 --> 00:43:36,319
differently than another another version

781
00:43:33,440 --> 00:43:40,339
in which case you would be you will have

782
00:43:36,319 --> 00:43:43,790
to handle different interpretations no I

783
00:43:40,339 --> 00:43:46,420
didn't go this far so do you think that

784
00:43:43,790 --> 00:43:51,440
might be the case that there might be

785
00:43:46,420 --> 00:43:53,450
such corner cases so if you want to go

786
00:43:51,440 --> 00:43:54,740
to the extra slide with the P code there

787
00:43:53,450 --> 00:43:57,399
you actually have this corner case

788
00:43:54,740 --> 00:43:59,209
because the P code is a compiled

789
00:43:57,400 --> 00:44:01,520
representation and probably what it was

790
00:43:59,210 --> 00:44:03,740
for is it just when you have your own

791
00:44:01,520 --> 00:44:05,030
document your open it again then you

792
00:44:03,740 --> 00:44:07,069
have a performance cache you already

793
00:44:05,030 --> 00:44:08,720
have the compiled version but what they

794
00:44:07,069 --> 00:44:12,259
do is they check the office version and

795
00:44:08,720 --> 00:44:13,609
the fitness is 32 or 64-bit and if it's

796
00:44:12,260 --> 00:44:15,710
the same then you will execute the P

797
00:44:13,609 --> 00:44:17,420
code and this means you can actually

798
00:44:15,710 --> 00:44:19,670
remove the source code just leave the P

799
00:44:17,420 --> 00:44:22,400
code and if you have the correct office

800
00:44:19,670 --> 00:44:23,480
version the P code will execute and if

801
00:44:22,400 --> 00:44:26,829
you look at the source code reverse

802
00:44:23,480 --> 00:44:26,829
representation it's empty

803
00:44:28,080 --> 00:44:41,200
okay one more question thank you for the

804
00:44:37,210 --> 00:44:45,460
call sorry for the presentation I was

805
00:44:41,200 --> 00:44:48,640
wondering if regarding this did you find

806
00:44:45,460 --> 00:44:51,880
any common code with other amine groups

807
00:44:48,640 --> 00:44:54,609
like AP t-34 like other codes like bond

808
00:44:51,880 --> 00:44:56,950
over for instance like you know there's

809
00:44:54,610 --> 00:44:58,420
common sources because it seems to be

810
00:44:56,950 --> 00:45:01,020
interesting the P code is something

811
00:44:58,420 --> 00:45:04,450
interesting did you see this inside

812
00:45:01,020 --> 00:45:08,860
Imhotep so at the moment I didn't look

813
00:45:04,450 --> 00:45:11,020
at a huge amount of documents this is

814
00:45:08,860 --> 00:45:13,540
the next part of the project to hook it

815
00:45:11,020 --> 00:45:16,210
up to the general sample stream extract

816
00:45:13,540 --> 00:45:18,490
all the VBA code and all the objects

817
00:45:16,210 --> 00:45:20,890
that I have inside with the tool and

818
00:45:18,490 --> 00:45:25,600
then build the database from that so

819
00:45:20,890 --> 00:45:26,879
that we can do cross correlations one

820
00:45:25,600 --> 00:45:34,150
last question

821
00:45:26,880 --> 00:45:37,600
yes so in your talk you talked about

822
00:45:34,150 --> 00:45:40,150
many malware fiends and today have you

823
00:45:37,600 --> 00:45:42,940
ever stood it right legitimate of this

824
00:45:40,150 --> 00:45:47,890
metros possible use of in front

825
00:45:42,940 --> 00:45:49,690
abilities or some limited use cases does

826
00:45:47,890 --> 00:45:52,810
this work all right

827
00:45:49,690 --> 00:45:55,600
does your tool what's fine with them so

828
00:45:52,810 --> 00:45:57,790
I have downloaded a couple of hundred

829
00:45:55,600 --> 00:46:01,319
documents from virustotal that have zero

830
00:45:57,790 --> 00:46:07,000
detections and I'm using those as the

831
00:46:01,320 --> 00:46:08,410
test case for a good way Thank You IRA

832
00:46:07,000 --> 00:46:12,119
first was a question and thanks again

833
00:46:08,410 --> 00:46:12,118
Jonas was a good presentation

