1
00:00:02,820 --> 00:00:04,259
thank you

2
00:00:04,259 --> 00:00:05,640
um so I'm actually going to talk about

3
00:00:05,640 --> 00:00:08,220
PHP exploits but the most important part

4
00:00:08,220 --> 00:00:11,580
is it's binary exploits and these are

5
00:00:11,580 --> 00:00:15,599
remote binary exploits so this is pretty

6
00:00:15,599 --> 00:00:17,580
hard to do in PHP so that's why it's

7
00:00:17,580 --> 00:00:20,939
pretty interesting I hope and I will

8
00:00:20,939 --> 00:00:23,400
illustrate with like one zero day maybe

9
00:00:23,400 --> 00:00:25,800
two if we have time but probably only

10
00:00:25,800 --> 00:00:27,840
one

11
00:00:27,840 --> 00:00:31,320
so a little bit about our company we are

12
00:00:31,320 --> 00:00:33,120
a French offensive security company we

13
00:00:33,120 --> 00:00:35,640
do a lot of stuff we have two technical

14
00:00:35,640 --> 00:00:38,640
blogs first one is more about kerneland

15
00:00:38,640 --> 00:00:40,800
system the other one is more about web

16
00:00:40,800 --> 00:00:45,140
exploitation it's ambionics.io blog

17
00:00:45,660 --> 00:00:48,539
well PHP and I have been filling with

18
00:00:48,539 --> 00:00:51,420
PHP for most of my life I found quite a

19
00:00:51,420 --> 00:00:55,320
few rces on many like 100 cms's super

20
00:00:55,320 --> 00:00:59,039
Magento Symphony larva stuff like this

21
00:00:59,039 --> 00:01:02,100
but I've also done binary exploitation

22
00:01:02,100 --> 00:01:04,979
and why would you do binary expectation

23
00:01:04,979 --> 00:01:07,260
on PHP well if there is no vulnerability

24
00:01:07,260 --> 00:01:08,640
at some point you have to look into the

25
00:01:08,640 --> 00:01:09,960
core and try and find vulnerabilities

26
00:01:09,960 --> 00:01:13,860
there and there's one also another use

27
00:01:13,860 --> 00:01:16,560
that is sandbox escapes so sunbox Escape

28
00:01:16,560 --> 00:01:19,439
basically allows you to access to the

29
00:01:19,439 --> 00:01:20,880
process running PHP so you're not

30
00:01:20,880 --> 00:01:22,680
running PHP anymore you're running like

31
00:01:22,680 --> 00:01:27,420
like a machine instructions and you have

32
00:01:27,420 --> 00:01:30,540
access to the main process memory so

33
00:01:30,540 --> 00:01:32,880
what can you do with this well generally

34
00:01:32,880 --> 00:01:35,159
the worker that runs PHP is going to be

35
00:01:35,159 --> 00:01:37,560
connected to a main process that will

36
00:01:37,560 --> 00:01:40,619
run as root and so if you can find the

37
00:01:40,619 --> 00:01:42,119
bug that allows you to access to the

38
00:01:42,119 --> 00:01:43,799
worker process and then a bug that

39
00:01:43,799 --> 00:01:45,360
allows you to talk to the main process

40
00:01:45,360 --> 00:01:47,460
and get some kind of memory corruption

41
00:01:47,460 --> 00:01:49,860
you might be able to get a local route

42
00:01:49,860 --> 00:01:52,200
exploits such as the one that I found

43
00:01:52,200 --> 00:01:54,119
like three years ago on Apache and

44
00:01:54,119 --> 00:01:56,040
another one that is basically the same

45
00:01:56,040 --> 00:01:58,860
on PHP fpm that allows you as well to

46
00:01:58,860 --> 00:02:01,560
get Roots I am also the maintainer of

47
00:02:01,560 --> 00:02:05,280
PHP GC sorry which is basically why so

48
00:02:05,280 --> 00:02:09,439
serial but for PHP box

49
00:02:09,739 --> 00:02:12,720
first a little bit of introduction for

50
00:02:12,720 --> 00:02:15,540
the bugs that you can find in PHP

51
00:02:15,540 --> 00:02:17,760
as you all know PHP security is pretty

52
00:02:17,760 --> 00:02:22,800
approximative like this is actually true

53
00:02:22,800 --> 00:02:25,200
I will let you figure out why it's a

54
00:02:25,200 --> 00:02:28,520
hash and a float and it's true

55
00:02:28,520 --> 00:02:31,319
there are a lot of bugs also that you

56
00:02:31,319 --> 00:02:33,420
can find in a PHP bug tracker and they

57
00:02:33,420 --> 00:02:35,819
are some of them are still in patch for

58
00:02:35,819 --> 00:02:38,220
like 10 years the reason is they don't

59
00:02:38,220 --> 00:02:40,319
really care if the bug is exploitable

60
00:02:40,319 --> 00:02:42,360
only locally what they care about are

61
00:02:42,360 --> 00:02:45,540
remote remotely exploitable bugs

62
00:02:45,540 --> 00:02:47,340
so obviously we get a lot of sandbox

63
00:02:47,340 --> 00:02:51,000
Escape bugs but we have also almost zero

64
00:02:51,000 --> 00:02:53,700
remote exploit remote binary export box

65
00:02:53,700 --> 00:02:56,400
so we will try and figure out why and

66
00:02:56,400 --> 00:02:59,099
what we can look at in the php's code to

67
00:02:59,099 --> 00:03:02,099
find bugs that you can explore remotely

68
00:03:02,099 --> 00:03:04,739
so what kind of bugs can you find in

69
00:03:04,739 --> 00:03:06,900
php1 PHP is a weekly type scripting

70
00:03:06,900 --> 00:03:08,459
language so every time they use

71
00:03:08,459 --> 00:03:10,319
something they have to type check it so

72
00:03:10,319 --> 00:03:12,300
check the type of the Bible and then

73
00:03:12,300 --> 00:03:14,580
reference it as well if something is

74
00:03:14,580 --> 00:03:16,739
used at two places in PHP you have to

75
00:03:16,739 --> 00:03:18,659
have a refund at two otherwise you might

76
00:03:18,659 --> 00:03:21,720
delete it well when it's still being

77
00:03:21,720 --> 00:03:24,540
used so you might have type confusion

78
00:03:24,540 --> 00:03:27,959
box use after free box and it's pretty

79
00:03:27,959 --> 00:03:29,459
easy to exploit locally because you're

80
00:03:29,459 --> 00:03:31,440
just writing PHP code right so it's

81
00:03:31,440 --> 00:03:34,019
basically the same as JavaScript Runner

82
00:03:34,019 --> 00:03:36,840
bug you just write JavaScript and you

83
00:03:36,840 --> 00:03:37,640
get

84
00:03:37,640 --> 00:03:40,620
you can set them for your box so for

85
00:03:40,620 --> 00:03:43,440
instance do some kind of e-passash Eep

86
00:03:43,440 --> 00:03:46,560
layout then you can trigger your bug so

87
00:03:46,560 --> 00:03:48,480
for instance create an object and then

88
00:03:48,480 --> 00:03:50,580
trigger the buggy method on this subject

89
00:03:50,580 --> 00:03:53,459
and then you can use the bug that is for

90
00:03:53,459 --> 00:03:55,620
instance use the fact that the EP is

91
00:03:55,620 --> 00:03:57,599
connected to I don't know get some kind

92
00:03:57,599 --> 00:03:59,400
of read primitive or write primitive and

93
00:03:59,400 --> 00:04:00,840
then you could get called execution from

94
00:04:00,840 --> 00:04:03,720
this but this is all doable because you

95
00:04:03,720 --> 00:04:05,760
are writing PHP code remotely you are

96
00:04:05,760 --> 00:04:07,379
not writing PHP code you're just using

97
00:04:07,379 --> 00:04:09,659
code from someone else

98
00:04:09,659 --> 00:04:12,239
so obviously it gets pretty much harder

99
00:04:12,239 --> 00:04:14,939
there's one very difficult thing with

100
00:04:14,939 --> 00:04:17,100
this is that for each request PHP will

101
00:04:17,100 --> 00:04:19,260
create a brand new if allocate your

102
00:04:19,260 --> 00:04:21,238
input so get post cookies stuff like

103
00:04:21,238 --> 00:04:23,520
this and then they will run the code

104
00:04:23,520 --> 00:04:25,979
that you want to run and then it will

105
00:04:25,979 --> 00:04:28,080
discard the Heap entirely so that means

106
00:04:28,080 --> 00:04:30,120
that if you get some kind of bugs like

107
00:04:30,120 --> 00:04:32,280
for instance used after free if you

108
00:04:32,280 --> 00:04:33,660
don't exploit it in the same request

109
00:04:33,660 --> 00:04:36,600
it's going to be gone forever so you

110
00:04:36,600 --> 00:04:37,979
have to exploit everything in one

111
00:04:37,979 --> 00:04:40,259
request so that's pretty hard there's

112
00:04:40,259 --> 00:04:43,460
also the ID that

113
00:04:43,460 --> 00:04:46,440
we are pretty Limited in size because

114
00:04:46,440 --> 00:04:48,840
https won't allow you to send like

115
00:04:48,840 --> 00:04:51,660
gigabytes of data usually and you also

116
00:04:51,660 --> 00:04:53,100
have limited types you can attend

117
00:04:53,100 --> 00:04:55,740
integers you can send floats you can

118
00:04:55,740 --> 00:04:59,160
only send basically strings and arrays

119
00:04:59,160 --> 00:05:00,240
um

120
00:05:00,240 --> 00:05:02,759
there's also obviously since it's a

121
00:05:02,759 --> 00:05:04,979
binary bug you have to beat aslr and Pi

122
00:05:04,979 --> 00:05:08,340
a pi PSI and there's only one thing

123
00:05:08,340 --> 00:05:10,800
going for us it is that crashes are

124
00:05:10,800 --> 00:05:13,680
pretty much okay as I said generally PHP

125
00:05:13,680 --> 00:05:14,880
you're gonna have a main process that

126
00:05:14,880 --> 00:05:17,580
runs that runs as roots and workers if a

127
00:05:17,580 --> 00:05:20,580
worker was crashing PHP would just

128
00:05:20,580 --> 00:05:23,880
respawn it and this way you wouldn't

129
00:05:23,880 --> 00:05:25,620
really care if you crush the process

130
00:05:25,620 --> 00:05:27,960
when you are exploiting also that means

131
00:05:27,960 --> 00:05:31,259
that if you get the aslr randomization

132
00:05:31,259 --> 00:05:33,960
or the buy randomization from one worker

133
00:05:33,960 --> 00:05:35,639
you're gonna have it for the other

134
00:05:35,639 --> 00:05:38,400
workers as well

135
00:05:38,400 --> 00:05:41,520
so to illustrate a little bit uh if you

136
00:05:41,520 --> 00:05:43,860
have uh we will exploit uh generally

137
00:05:43,860 --> 00:05:45,539
you're going to interact like tons of

138
00:05:45,539 --> 00:05:47,340
times with the server you might set up

139
00:05:47,340 --> 00:05:49,020
the memory first then get some kind of

140
00:05:49,020 --> 00:05:50,940
leak then use this leak to set up the

141
00:05:50,940 --> 00:05:54,500
memory again use another bug to uh

142
00:05:54,500 --> 00:05:57,120
trigger a memory option and then use

143
00:05:57,120 --> 00:05:59,699
this memory corruption in PHP one

144
00:05:59,699 --> 00:06:03,740
request get a shell that's it

145
00:06:04,620 --> 00:06:06,900
so to me it comes down to picking the

146
00:06:06,900 --> 00:06:08,160
right targets you're not going to try

147
00:06:08,160 --> 00:06:10,139
and look for any kind of function you

148
00:06:10,139 --> 00:06:11,400
want a function that's going to be used

149
00:06:11,400 --> 00:06:13,080
a function where you can control some

150
00:06:13,080 --> 00:06:15,180
parameter usually and you're going to

151
00:06:15,180 --> 00:06:18,419
find a function also that after you've

152
00:06:18,419 --> 00:06:20,220
triggered a bug you can use the bug so

153
00:06:20,220 --> 00:06:22,620
okay I got memory corruption what can I

154
00:06:22,620 --> 00:06:24,960
do with it in the same request

155
00:06:24,960 --> 00:06:29,220
so usually the best function for this is

156
00:06:29,220 --> 00:06:31,139
unserialized which is php's

157
00:06:31,139 --> 00:06:34,199
digitalization function it allows you to

158
00:06:34,199 --> 00:06:36,840
interact with PHP several time in one

159
00:06:36,840 --> 00:06:39,180
request for instance here I have an

160
00:06:39,180 --> 00:06:42,120
array of filaments and in this array I

161
00:06:42,120 --> 00:06:45,060
have an object which contains an

162
00:06:45,060 --> 00:06:46,620
attribute it could contain like 50

163
00:06:46,620 --> 00:06:48,720
attributes and then there is another

164
00:06:48,720 --> 00:06:52,199
element that is string so you can easily

165
00:06:52,199 --> 00:06:53,940
see that if you have access to

166
00:06:53,940 --> 00:06:55,919
internalize as an attacker you can

167
00:06:55,919 --> 00:06:57,720
create any kind of a player that you

168
00:06:57,720 --> 00:07:00,300
want then create any kind of object then

169
00:07:00,300 --> 00:07:03,180
trigger for instance the bug of on one

170
00:07:03,180 --> 00:07:04,860
of these objects and then use the bug

171
00:07:04,860 --> 00:07:07,740
afterwards with other array elements so

172
00:07:07,740 --> 00:07:10,740
it comes down to as I said here interact

173
00:07:10,740 --> 00:07:13,380
with PHP several times but only during

174
00:07:13,380 --> 00:07:14,819
one request

175
00:07:14,819 --> 00:07:17,039
so and cellulitis I mean it's pretty

176
00:07:17,039 --> 00:07:18,660
well documented I won't talk about this

177
00:07:18,660 --> 00:07:20,099
one

178
00:07:20,099 --> 00:07:23,039
my idea was to use a database driver

179
00:07:23,039 --> 00:07:25,500
functions when PHP connects to the

180
00:07:25,500 --> 00:07:27,180
database it will First Connect and then

181
00:07:27,180 --> 00:07:29,220
it will send several queries and then

182
00:07:29,220 --> 00:07:31,319
the database is going to send the data

183
00:07:31,319 --> 00:07:33,479
back so that's a way to interact with

184
00:07:33,479 --> 00:07:36,240
PHP several times but only during one

185
00:07:36,240 --> 00:07:38,340
request so that's pretty good for us so

186
00:07:38,340 --> 00:07:40,020
that's a way to potentially have a

187
00:07:40,020 --> 00:07:42,539
trigger so find a bug and then use the

188
00:07:42,539 --> 00:07:45,120
bug by sending query results

189
00:07:45,120 --> 00:07:48,360
so I actually released two bucks

190
00:07:48,360 --> 00:07:50,460
um the first one I'm gonna talk about uh

191
00:07:50,460 --> 00:07:52,199
way more the second one maybe if we have

192
00:07:52,199 --> 00:07:54,300
time the second one doesn't matter too

193
00:07:54,300 --> 00:07:55,620
much actually because I couldn't find

194
00:07:55,620 --> 00:07:58,560
any uh known CMS or framework that was

195
00:07:58,560 --> 00:08:00,240
using this function it's pretty old

196
00:08:00,240 --> 00:08:02,819
sadly because it's actually a really

197
00:08:02,819 --> 00:08:05,400
funny bug but it's useless so the first

198
00:08:05,400 --> 00:08:07,500
one is more important it actually

199
00:08:07,500 --> 00:08:10,020
happens when PHP sends its password to a

200
00:08:10,020 --> 00:08:13,440
database and you you will get a buffer

201
00:08:13,440 --> 00:08:16,199
overflow in the Eep and that will affect

202
00:08:16,199 --> 00:08:18,240
basically any kind of database

203
00:08:18,240 --> 00:08:20,160
management system such as admin or PHP

204
00:08:20,160 --> 00:08:22,800
my admin any kind of share those thing

205
00:08:22,800 --> 00:08:27,780
also utility you would get the bug here

206
00:08:27,780 --> 00:08:29,879
so before we talk about the bugs I'm

207
00:08:29,879 --> 00:08:30,960
going to have to explain a little bit

208
00:08:30,960 --> 00:08:33,899
how it works in php's internals so don't

209
00:08:33,899 --> 00:08:34,979
worry it's going to be really simple

210
00:08:34,979 --> 00:08:37,080
we're going to talk about like only what

211
00:08:37,080 --> 00:08:39,360
we need and actually PHP is not that

212
00:08:39,360 --> 00:08:42,059
hard of an interpreter to understand the

213
00:08:42,059 --> 00:08:44,219
allocator is really easy so it's going

214
00:08:44,219 --> 00:08:45,899
to be I think a breeze for you to

215
00:08:45,899 --> 00:08:47,640
understand

216
00:08:47,640 --> 00:08:49,800
so obviously when you create a PHP

217
00:08:49,800 --> 00:08:52,680
variable you have to store it as a c

218
00:08:52,680 --> 00:08:53,839
variable

219
00:08:53,839 --> 00:08:56,760
it is done using a Zeva structure so la

220
00:08:56,760 --> 00:08:58,800
Luca talked a bit about it but that

221
00:08:58,800 --> 00:09:01,560
value is simply a type so any pfp type

222
00:09:01,560 --> 00:09:04,920
is possible array string object any kind

223
00:09:04,920 --> 00:09:07,279
of simple type as well ins for instance

224
00:09:07,279 --> 00:09:10,500
and then there is another structure that

225
00:09:10,500 --> 00:09:13,140
actually defines the type so for Strings

226
00:09:13,140 --> 00:09:15,480
you can have a Zen string arrays and

227
00:09:15,480 --> 00:09:18,600
array etc etc well

228
00:09:18,600 --> 00:09:19,800
um

229
00:09:19,800 --> 00:09:21,660
usually when PHP is going to use the

230
00:09:21,660 --> 00:09:23,399
variable it's going to always verify the

231
00:09:23,399 --> 00:09:25,920
type before otherwise you might send a

232
00:09:25,920 --> 00:09:27,959
wrong type and PHP is going to use it

233
00:09:27,959 --> 00:09:31,019
instead and you might get a bug so it

234
00:09:31,019 --> 00:09:33,060
uses it verifies the type and then if

235
00:09:33,060 --> 00:09:35,100
they reference the internal object and

236
00:09:35,100 --> 00:09:37,920
then uses the corresponding structure we

237
00:09:37,920 --> 00:09:39,300
don't really care about that boss we're

238
00:09:39,300 --> 00:09:41,220
gonna care about the string and then

239
00:09:41,220 --> 00:09:42,899
arrays that's the only two thing that we

240
00:09:42,899 --> 00:09:45,000
can send so that's pretty good for us we

241
00:09:45,000 --> 00:09:47,100
cannot create objects by sending remote

242
00:09:47,100 --> 00:09:49,740
requests that would be too easy so we

243
00:09:49,740 --> 00:09:51,620
are only going to talk about these two

244
00:09:51,620 --> 00:09:53,880
what you have to keep in mind is that

245
00:09:53,880 --> 00:09:55,440
these two are generally going to be

246
00:09:55,440 --> 00:09:57,240
allocated on the Eep which we're going

247
00:09:57,240 --> 00:10:00,600
to talk about later but those advers are

248
00:10:00,600 --> 00:10:02,160
not allocated on the if so we don't

249
00:10:02,160 --> 00:10:04,200
really care about them

250
00:10:04,200 --> 00:10:07,680
so first then string so this is actually

251
00:10:07,680 --> 00:10:09,660
not really a structure but a header I

252
00:10:09,660 --> 00:10:10,980
will explain why

253
00:10:10,980 --> 00:10:12,600
um so the first thing that you get in

254
00:10:12,600 --> 00:10:14,760
this structure is uh the GC which

255
00:10:14,760 --> 00:10:16,620
contains the Rev count and some Flags

256
00:10:16,620 --> 00:10:18,300
then you're going to have a hash value

257
00:10:18,300 --> 00:10:20,100
we don't really care about this one then

258
00:10:20,100 --> 00:10:22,200
the length of the string so if a string

259
00:10:22,200 --> 00:10:23,820
has a length of 100 is going to be

260
00:10:23,820 --> 00:10:27,060
stopped 100 and immediately after you

261
00:10:27,060 --> 00:10:28,500
have the buffer of the Swing so it's not

262
00:10:28,500 --> 00:10:30,300
the pointer to a buffer it's the buffer

263
00:10:30,300 --> 00:10:32,399
straight up so when PHP allocates the

264
00:10:32,399 --> 00:10:35,580
string well I'm gonna go here

265
00:10:35,580 --> 00:10:37,260
um when tsp look at the string it will

266
00:10:37,260 --> 00:10:38,880
just allocate enough size for these

267
00:10:38,880 --> 00:10:41,399
three plus the size for the buffer and

268
00:10:41,399 --> 00:10:43,680
then find a null byte right so it's not

269
00:10:43,680 --> 00:10:46,079
a pointer to some other buffer somewhere

270
00:10:46,079 --> 00:10:47,579
else in memory it's just straight up the

271
00:10:47,579 --> 00:10:48,839
buffer

272
00:10:48,839 --> 00:10:51,360
so obviously as an attacker what we care

273
00:10:51,360 --> 00:10:54,060
about is exploiting the length if we can

274
00:10:54,060 --> 00:10:56,000
change the length of a string

275
00:10:56,000 --> 00:10:58,620
artificially well that means that PHP is

276
00:10:58,620 --> 00:11:00,120
going to think that the string has a

277
00:11:00,120 --> 00:11:02,160
different length that it really has so

278
00:11:02,160 --> 00:11:04,200
if we can make PHP think that the string

279
00:11:04,200 --> 00:11:06,779
is U is huge when PHP displays the

280
00:11:06,779 --> 00:11:08,339
string is is going to actually display

281
00:11:08,339 --> 00:11:09,899
things that come after the string in

282
00:11:09,899 --> 00:11:13,200
memory so you might get a memory leak

283
00:11:13,200 --> 00:11:15,720
the other thing that we care about is

284
00:11:15,720 --> 00:11:17,700
the way to store PHP arrays so it's

285
00:11:17,700 --> 00:11:20,519
basically the same as the python dict uh

286
00:11:20,519 --> 00:11:22,860
basically a hash map we don't really

287
00:11:22,860 --> 00:11:24,540
care about the structure too much it's a

288
00:11:24,540 --> 00:11:26,339
pretty complex but what we care about is

289
00:11:26,339 --> 00:11:28,980
the GC which is the same as in the Zen

290
00:11:28,980 --> 00:11:31,680
swing first element is a GC then there's

291
00:11:31,680 --> 00:11:33,720
the pointer to a key value purpose we

292
00:11:33,720 --> 00:11:35,459
don't really care and then there's this

293
00:11:35,459 --> 00:11:37,620
speed instructor it is a function

294
00:11:37,620 --> 00:11:40,079
pointer so a c function pointer and it

295
00:11:40,079 --> 00:11:41,519
is called every time you remove an

296
00:11:41,519 --> 00:11:44,040
element from an array so here I have an

297
00:11:44,040 --> 00:11:46,260
array with three elements if I unset the

298
00:11:46,260 --> 00:11:47,940
first one it's going to go play this

299
00:11:47,940 --> 00:11:50,279
tractor on this Z value set value that

300
00:11:50,279 --> 00:11:53,519
contains one obviously as an attacker if

301
00:11:53,519 --> 00:11:55,440
we can control this well that means that

302
00:11:55,440 --> 00:11:59,160
when array gets destruct uh PD structure

303
00:11:59,160 --> 00:12:00,839
is going to be called and if we can

304
00:12:00,839 --> 00:12:02,579
control this we can basically do a stack

305
00:12:02,579 --> 00:12:04,560
pivot or just execute any kind of

306
00:12:04,560 --> 00:12:07,620
function so we we control PC so we might

307
00:12:07,620 --> 00:12:09,959
get called execution from this

308
00:12:09,959 --> 00:12:11,700
so now you have enough information to

309
00:12:11,700 --> 00:12:13,620
understand a local PHP exploit it's very

310
00:12:13,620 --> 00:12:14,519
simple

311
00:12:14,519 --> 00:12:16,920
you use a bug to change the size of a

312
00:12:16,920 --> 00:12:19,320
Zen swing this way the string is way

313
00:12:19,320 --> 00:12:21,779
bigger than it should be then you simply

314
00:12:21,779 --> 00:12:25,620
use PHP standard array notation on the

315
00:12:25,620 --> 00:12:28,920
string to read or write memory so you

316
00:12:28,920 --> 00:12:31,200
get basically read write over the whole

317
00:12:31,200 --> 00:12:33,600
heap using one bug so it's pretty nice

318
00:12:33,600 --> 00:12:35,940
and from this you can create lots of

319
00:12:35,940 --> 00:12:38,339
xender rays so you just Spam the

320
00:12:38,339 --> 00:12:40,740
creation of arrays and so in the mirror

321
00:12:40,740 --> 00:12:42,000
way you're going to be able to see open

322
00:12:42,000 --> 00:12:44,100
Destructor from the previous director

323
00:12:44,100 --> 00:12:45,660
you can find the program's Base address

324
00:12:45,660 --> 00:12:48,360
so Pi is useless and then you can

325
00:12:48,360 --> 00:12:49,920
replace it with any kind of function you

326
00:12:49,920 --> 00:12:52,260
want and get called execution from this

327
00:12:52,260 --> 00:12:54,360
then if you want to execute the

328
00:12:54,360 --> 00:12:56,100
structure you just have to unset the

329
00:12:56,100 --> 00:12:57,899
array or unset an element in the array

330
00:12:57,899 --> 00:13:00,540
and you get your execution super easy

331
00:13:00,540 --> 00:13:03,000
but it's for local exploits there's

332
00:13:03,000 --> 00:13:05,100
actually better ways to do this now but

333
00:13:05,100 --> 00:13:08,279
that's like the simplest example on what

334
00:13:08,279 --> 00:13:10,800
you can do with a local box so I chose

335
00:13:10,800 --> 00:13:12,959
to explain this one instead

336
00:13:12,959 --> 00:13:15,360
so to understand remote exploits however

337
00:13:15,360 --> 00:13:18,019
we have to talk about the if so

338
00:13:18,019 --> 00:13:21,260
a little bit

339
00:13:24,360 --> 00:13:27,600
so the Eep you have two main functions

340
00:13:27,600 --> 00:13:31,019
as usual one to allocate so I want like

341
00:13:31,019 --> 00:13:33,959
n bytes you use email log it returns a

342
00:13:33,959 --> 00:13:36,420
pointer to a chunk that is at least of

343
00:13:36,420 --> 00:13:37,620
size n

344
00:13:37,620 --> 00:13:39,300
and when you don't need the chunk

345
00:13:39,300 --> 00:13:41,459
anymore you just go E3 and it just

346
00:13:41,459 --> 00:13:45,839
removes it so how is it done in PHP well

347
00:13:45,839 --> 00:13:47,339
um generally you're gonna have a heap of

348
00:13:47,339 --> 00:13:50,459
two megabytes split in pages of orix

349
00:13:50,459 --> 00:13:52,519
thousand so for

350
00:13:52,519 --> 00:13:56,639
40086 in a decimal and that gives you

351
00:13:56,639 --> 00:13:59,820
like five 512 pages on your Eep the

352
00:13:59,820 --> 00:14:01,740
first page it contains if metadata so

353
00:14:01,740 --> 00:14:03,720
you can't really use it but the rest is

354
00:14:03,720 --> 00:14:06,540
used for storage and in a page you can

355
00:14:06,540 --> 00:14:09,600
find chunks of the same size a chunk is

356
00:14:09,600 --> 00:14:12,120
a fixed size memory region so a fixed

357
00:14:12,120 --> 00:14:15,120
size buffer and it could be of size 8 16

358
00:14:15,120 --> 00:14:20,160
24 etc etc up until 3772.

359
00:14:20,160 --> 00:14:23,399
when you want to allocate more than 3072

360
00:14:23,399 --> 00:14:25,579
bytes the buffer is going to be directly

361
00:14:25,579 --> 00:14:29,479
stored on contiguous pages

362
00:14:30,480 --> 00:14:32,399
so how does the allocation of the

363
00:14:32,399 --> 00:14:35,459
allocation work it's very very easy for

364
00:14:35,459 --> 00:14:37,680
each chunk of some size you have a

365
00:14:37,680 --> 00:14:39,600
linked list that contains the chunks

366
00:14:39,600 --> 00:14:41,699
that are free so for instance we have

367
00:14:41,699 --> 00:14:43,500
been zero that contains chunks of size 8

368
00:14:43,500 --> 00:14:46,019
being 1 for chunks of size 16

369
00:14:46,019 --> 00:14:49,740
etc etc up until 3072. what happens when

370
00:14:49,740 --> 00:14:51,959
we call E3 so we have a pointer that we

371
00:14:51,959 --> 00:14:54,180
don't need anymore so how is PHP going

372
00:14:54,180 --> 00:14:56,279
to put it in the right bin well it will

373
00:14:56,279 --> 00:14:58,380
just find out which page the pointer is

374
00:14:58,380 --> 00:15:01,620
in then deduce the chunk size from the

375
00:15:01,620 --> 00:15:03,720
IP metadata you will read the metadata

376
00:15:03,720 --> 00:15:05,699
and see what is the chunk size for this

377
00:15:05,699 --> 00:15:08,160
page then it will just add the pointer

378
00:15:08,160 --> 00:15:10,800
at the head of the corresponding bin

379
00:15:10,800 --> 00:15:12,720
when we do email log PHP is going to do

380
00:15:12,720 --> 00:15:14,820
the opposite for instance if we need 14

381
00:15:14,820 --> 00:15:16,680
bytes it's going to pick a bin so the

382
00:15:16,680 --> 00:15:18,600
bin is going to be bin 1 because it's 16

383
00:15:18,600 --> 00:15:22,260
bytes it's gonna then take the first

384
00:15:22,260 --> 00:15:24,720
element from the bin and return it right

385
00:15:24,720 --> 00:15:26,399
fairly easy

386
00:15:26,399 --> 00:15:28,320
evidently if there are no elements in

387
00:15:28,320 --> 00:15:30,720
the bin PHP has to do something else PHP

388
00:15:30,720 --> 00:15:33,300
has to find a page that is not used so

389
00:15:33,300 --> 00:15:35,100
it will use the eat metadata to find the

390
00:15:35,100 --> 00:15:37,500
page that is still not used and it will

391
00:15:37,500 --> 00:15:39,839
create new free chunks in the page and

392
00:15:39,839 --> 00:15:42,959
add them to the bin

393
00:15:42,959 --> 00:15:45,600
so to illustrate a little bit on the

394
00:15:45,600 --> 00:15:47,519
left we have the the Eep with the pages

395
00:15:47,519 --> 00:15:49,440
and let's say for instance page 10

396
00:15:49,440 --> 00:15:52,079
contains chunks of size of X100 and we

397
00:15:52,079 --> 00:15:54,899
have this bin originally uh chunks of

398
00:15:54,899 --> 00:15:57,600
size 0x100 are stored in B9

399
00:15:57,600 --> 00:15:59,880
um so if we have this bin originally and

400
00:15:59,880 --> 00:16:01,860
we free an element it's going to be put

401
00:16:01,860 --> 00:16:05,220
at the beginning of the bin right and if

402
00:16:05,220 --> 00:16:07,440
we allocate elements they're going to be

403
00:16:07,440 --> 00:16:10,320
taken from the first uh elements of the

404
00:16:10,320 --> 00:16:13,199
list so from the head that's it that's

405
00:16:13,199 --> 00:16:15,839
how phpc works

406
00:16:15,839 --> 00:16:17,940
so now you have enough to understand the

407
00:16:17,940 --> 00:16:20,940
bug and how we can exploit it

408
00:16:20,940 --> 00:16:25,560
so what is mysqlnd first mysqnd is php's

409
00:16:25,560 --> 00:16:28,680
a client driver so this is the code that

410
00:16:28,680 --> 00:16:30,540
is going to use to connect to the mySQL

411
00:16:30,540 --> 00:16:33,180
database and run queries it's not using

412
00:16:33,180 --> 00:16:36,600
any native MySQL stuff they all coded it

413
00:16:36,600 --> 00:16:39,060
by themselves like it's been done by PHP

414
00:16:39,060 --> 00:16:41,220
devs so evidently it's pretty horrible

415
00:16:41,220 --> 00:16:44,759
and uh like there were so many bugs I

416
00:16:44,759 --> 00:16:47,100
tried to fuzz it and it was like

417
00:16:47,100 --> 00:16:48,839
permanently crashing I couldn't reach

418
00:16:48,839 --> 00:16:50,940
anything useful so I was trying to patch

419
00:16:50,940 --> 00:16:52,800
to patch the code to reach something

420
00:16:52,800 --> 00:16:55,380
useful but I couldn't so I was like

421
00:16:55,380 --> 00:16:58,139
it I'm gonna delete the code and that's

422
00:16:58,139 --> 00:17:00,600
why I did so

423
00:17:00,600 --> 00:17:02,880
the bag is simple when you connect to a

424
00:17:02,880 --> 00:17:06,000
database with a clear text password so

425
00:17:06,000 --> 00:17:07,859
sorry when you connect to database the

426
00:17:07,859 --> 00:17:09,720
database can tell you he wants you to

427
00:17:09,720 --> 00:17:12,000
authenticate with some method or some

428
00:17:12,000 --> 00:17:13,859
other and it might ask you to

429
00:17:13,859 --> 00:17:15,059
authenticate with your clear text

430
00:17:15,059 --> 00:17:17,040
password so

431
00:17:17,040 --> 00:17:18,900
the idea is that PHP has to send the

432
00:17:18,900 --> 00:17:22,559
packet with a header which is a MySQL ND

433
00:17:22,559 --> 00:17:26,760
adder and the password right the thing

434
00:17:26,760 --> 00:17:28,980
is PHP on the allocate set of size for

435
00:17:28,980 --> 00:17:30,240
the password

436
00:17:30,240 --> 00:17:32,880
so the mng email log here is simply

437
00:17:32,880 --> 00:17:35,039
malloc they try to allocate the side of

438
00:17:35,039 --> 00:17:36,780
the password but they actually need the

439
00:17:36,780 --> 00:17:39,660
size of the password plus this but they

440
00:17:39,660 --> 00:17:41,400
don't so when they do the main copy

441
00:17:41,400 --> 00:17:42,840
afterwards the main copy is going to

442
00:17:42,840 --> 00:17:46,200
overflow or four bytes out of the buffer

443
00:17:46,200 --> 00:17:48,720
so to exploit this you need to find a

444
00:17:48,720 --> 00:17:50,940
way to make PHP connect to some kind of

445
00:17:50,940 --> 00:17:52,320
database that you control effect

446
00:17:52,320 --> 00:17:54,539
database the effect database is going to

447
00:17:54,539 --> 00:17:56,280
ask for PHP for the clear text password

448
00:17:56,280 --> 00:18:00,299
and then you send like huge a huge

449
00:18:00,299 --> 00:18:03,480
string here and it will trigger the bug

450
00:18:03,480 --> 00:18:05,940
so the target for today is going to be

451
00:18:05,940 --> 00:18:07,980
adminer it's basically the same as php9

452
00:18:07,980 --> 00:18:10,919
my admin sorry it's a way to manage your

453
00:18:10,919 --> 00:18:13,320
databases generally the thing is like

454
00:18:13,320 --> 00:18:15,360
some kind of system mean wants to use a

455
00:18:15,360 --> 00:18:17,220
adminer because it wants to check his

456
00:18:17,220 --> 00:18:20,340
database so it you plot it like on the

457
00:18:20,340 --> 00:18:22,559
main on the Webroot and then he forgets

458
00:18:22,559 --> 00:18:25,080
about it so what you have to do when you

459
00:18:25,080 --> 00:18:27,120
do some kind of pen test on PHP just add

460
00:18:27,120 --> 00:18:29,280
slash adminar.php and you might find one

461
00:18:29,280 --> 00:18:31,500
and you might be able to expect this

462
00:18:31,500 --> 00:18:34,200
back afterwards so this is the perfect

463
00:18:34,200 --> 00:18:35,940
Target for us because we can force PHP

464
00:18:35,940 --> 00:18:37,500
to connecting to a server that we

465
00:18:37,500 --> 00:18:39,480
control with the username that we want

466
00:18:39,480 --> 00:18:41,280
and obviously the password that we want

467
00:18:41,280 --> 00:18:43,860
when we are connected afterwards admin

468
00:18:43,860 --> 00:18:46,919
is able to run requests to import a

469
00:18:46,919 --> 00:18:49,260
database stuff or export database stuff

470
00:18:49,260 --> 00:18:52,500
so it's a perfect Target for us

471
00:18:52,500 --> 00:18:55,320
so now what can we do with debug so we

472
00:18:55,320 --> 00:18:57,000
need an allocation that is bigger than

473
00:18:57,000 --> 00:18:58,799
one page because otherwise PHP won't

474
00:18:58,799 --> 00:19:01,380
allocate or buffer but then afterwards

475
00:19:01,380 --> 00:19:04,799
we can overflow of four bytes so we get

476
00:19:04,799 --> 00:19:07,080
a four bytes overflow onto the next PHP

477
00:19:07,080 --> 00:19:07,919
page

478
00:19:07,919 --> 00:19:09,059
so

479
00:19:09,059 --> 00:19:10,620
generally what you want to do is all

480
00:19:10,620 --> 00:19:12,419
right structures that are already

481
00:19:12,419 --> 00:19:14,820
existing but four bytes in Zen string or

482
00:19:14,820 --> 00:19:16,380
then the array is useless because this

483
00:19:16,380 --> 00:19:18,480
is only the Rev count you could exploit

484
00:19:18,480 --> 00:19:21,120
this but it's really hard so my ID was

485
00:19:21,120 --> 00:19:24,299
to Simply overwrite the next pointer of

486
00:19:24,299 --> 00:19:26,700
a free chunk if a chunk is free that

487
00:19:26,700 --> 00:19:28,919
means that it is in a bin so a free list

488
00:19:28,919 --> 00:19:30,660
and so that means that it points to

489
00:19:30,660 --> 00:19:32,880
another chunk so there is a pointer here

490
00:19:32,880 --> 00:19:34,799
that you can partially override with

491
00:19:34,799 --> 00:19:36,380
four bytes

492
00:19:36,380 --> 00:19:39,419
so when you get to do this then you can

493
00:19:39,419 --> 00:19:41,760
change the linked list of a bin so that

494
00:19:41,760 --> 00:19:43,559
means that you can make the the bin

495
00:19:43,559 --> 00:19:45,660
Point somewhere else if you can do this

496
00:19:45,660 --> 00:19:47,400
that means that when you allocate you

497
00:19:47,400 --> 00:19:49,799
can make PHP allocate somewhere else and

498
00:19:49,799 --> 00:19:51,539
obviously that means so more for PHP

499
00:19:51,539 --> 00:19:54,299
because you wouldn't be able normally to

500
00:19:54,299 --> 00:19:55,799
do this

501
00:19:55,799 --> 00:19:58,200
so how do we allocate well simply since

502
00:19:58,200 --> 00:19:59,700
we are connecting to a server that we

503
00:19:59,700 --> 00:20:02,220
control we can just send arbitrary query

504
00:20:02,220 --> 00:20:04,919
results and so we send results that have

505
00:20:04,919 --> 00:20:06,960
the same size as the chunks in the bin

506
00:20:06,960 --> 00:20:10,320
and that allows us to allocate

507
00:20:10,320 --> 00:20:11,760
um afterwards it's basically going to be

508
00:20:11,760 --> 00:20:13,919
the same as before you try and find a

509
00:20:13,919 --> 00:20:16,440
way to corrupt the length of a Zen

510
00:20:16,440 --> 00:20:18,000
string and from this you might get color

511
00:20:18,000 --> 00:20:19,919
execution as we'll see it's a little bit

512
00:20:19,919 --> 00:20:22,200
harder but not too hot

513
00:20:22,200 --> 00:20:24,799
so the thing is we can

514
00:20:24,799 --> 00:20:27,419
trigger a bug it's simply by using

515
00:20:27,419 --> 00:20:29,280
adminer and it will immediately connect

516
00:20:29,280 --> 00:20:31,380
to the database and send the password

517
00:20:31,380 --> 00:20:34,740
and so we get the buffer overflow and

518
00:20:34,740 --> 00:20:36,419
then we can use the bug because we can

519
00:20:36,419 --> 00:20:38,220
send arbitrary query results and

520
00:20:38,220 --> 00:20:40,260
allocate whatever we want the thing is

521
00:20:40,260 --> 00:20:43,500
we don't have like the Eep setup we

522
00:20:43,500 --> 00:20:45,179
don't have the layout that we need to

523
00:20:45,179 --> 00:20:47,460
exploit so how do we get the E player

524
00:20:47,460 --> 00:20:50,520
that we need only using data that comes

525
00:20:50,520 --> 00:20:53,220
before so that means HTTP input well

526
00:20:53,220 --> 00:20:55,500
usually it can be it can be done pretty

527
00:20:55,500 --> 00:20:58,320
easily as you all know you can send

528
00:20:58,320 --> 00:21:01,500
strings to PHP like using the core

529
00:21:01,500 --> 00:21:04,140
listing or post data but you can also

530
00:21:04,140 --> 00:21:07,260
send arrays so you have arbitrary then

531
00:21:07,260 --> 00:21:09,059
string or then the right creation before

532
00:21:09,059 --> 00:21:12,419
the switch the script runs but there's

533
00:21:12,419 --> 00:21:14,580
also one thing that is very very useful

534
00:21:14,580 --> 00:21:17,280
it is that you can actually free some

535
00:21:17,280 --> 00:21:19,919
value before it's being used to do so

536
00:21:19,919 --> 00:21:23,039
you send the key a key twice and when

537
00:21:23,039 --> 00:21:25,559
the second key comes in It's Gonna free

538
00:21:25,559 --> 00:21:28,080
the first value here so that means that

539
00:21:28,080 --> 00:21:29,640
you can before the script Branch

540
00:21:29,640 --> 00:21:31,620
allocate anything on the Heap and then

541
00:21:31,620 --> 00:21:33,539
free anything on the Heap not anything

542
00:21:33,539 --> 00:21:36,419
but basically anything so generally that

543
00:21:36,419 --> 00:21:38,220
means that you can do any kind of Eep

544
00:21:38,220 --> 00:21:39,960
layout that you want so that's a perfect

545
00:21:39,960 --> 00:21:43,500
setup before we trigger our back

546
00:21:43,500 --> 00:21:45,960
quick example for you to understand the

547
00:21:45,960 --> 00:21:48,480
rest if you want to create 100 chunks of

548
00:21:48,480 --> 00:21:51,000
size 0x100 and we want to free one in

549
00:21:51,000 --> 00:21:53,460
the middle so how do we do this well we

550
00:21:53,460 --> 00:21:56,460
send strings of size Ox E7 why because

551
00:21:56,460 --> 00:21:59,220
as I said before then swing has a header

552
00:21:59,220 --> 00:22:01,500
size of ox18 because there are three

553
00:22:01,500 --> 00:22:05,280
elements of of three keywords and one

554
00:22:05,280 --> 00:22:07,260
final little bytes so if you do the

555
00:22:07,260 --> 00:22:10,799
addition you you get actually 100 and so

556
00:22:10,799 --> 00:22:12,900
you want a render chunks so you send an

557
00:22:12,900 --> 00:22:17,159
array with 100 times Ox E7 strings of

558
00:22:17,159 --> 00:22:19,679
size oxe7 and then afterwards you want

559
00:22:19,679 --> 00:22:21,360
to free one in the middle so you just

560
00:22:21,360 --> 00:22:23,880
redefine the array value here and that

561
00:22:23,880 --> 00:22:25,919
works

562
00:22:25,919 --> 00:22:28,980
so now what can we do we can set up the

563
00:22:28,980 --> 00:22:31,980
hip using get them post which is nice we

564
00:22:31,980 --> 00:22:33,419
can then trigger the bug by connecting

565
00:22:33,419 --> 00:22:36,240
to A rod MySQL server and then we can

566
00:22:36,240 --> 00:22:38,100
use the bug by sending arbitrary query

567
00:22:38,100 --> 00:22:41,039
results to a PHP so that means other

568
00:22:41,039 --> 00:22:43,679
than swing allocations so that means

569
00:22:43,679 --> 00:22:45,240
that we might be able to control a free

570
00:22:45,240 --> 00:22:47,340
list so we are pretty close to getting

571
00:22:47,340 --> 00:22:50,178
close execution

572
00:22:56,940 --> 00:22:59,460
there's one thing though we don't know

573
00:22:59,460 --> 00:23:02,400
the eslr we don't know Pi so we could

574
00:23:02,400 --> 00:23:05,159
maybe override some pointer but we don't

575
00:23:05,159 --> 00:23:06,900
even know where we are pointing there's

576
00:23:06,900 --> 00:23:09,659
a randomization in the addresses

577
00:23:09,659 --> 00:23:11,280
so the first thing that we are going to

578
00:23:11,280 --> 00:23:14,520
do is do a Eep setup that works well for

579
00:23:14,520 --> 00:23:18,000
us so the IDE is that we are going to

580
00:23:18,000 --> 00:23:20,340
have two empty pages here these pages

581
00:23:20,340 --> 00:23:22,260
are going to receive afterwards the

582
00:23:22,260 --> 00:23:24,120
buffer in which we will have the

583
00:23:24,120 --> 00:23:26,520
Overflow so the buffer will overflow

584
00:23:26,520 --> 00:23:28,559
into the Red Zone here and the Red Zone

585
00:23:28,559 --> 00:23:30,720
contains three chunks that's exactly

586
00:23:30,720 --> 00:23:32,100
what we wanted because we want to

587
00:23:32,100 --> 00:23:35,820
overflow this a pointer to a next chunk

588
00:23:35,820 --> 00:23:37,559
in addition to this

589
00:23:37,559 --> 00:23:39,900
we want a huge region which is one

590
00:23:39,900 --> 00:23:43,260
megabyte in size the ID is that we want

591
00:23:43,260 --> 00:23:45,840
to override this with overflow and make

592
00:23:45,840 --> 00:23:47,159
it Point here

593
00:23:47,159 --> 00:23:49,559
this way we then can control completely

594
00:23:49,559 --> 00:23:52,679
the free list and get some kind of uh

595
00:23:52,679 --> 00:23:55,679
like region where we can do whatever we

596
00:23:55,679 --> 00:23:58,140
want basically the problem with this is

597
00:23:58,140 --> 00:24:01,320
that as I said before aslr so this is

598
00:24:01,320 --> 00:24:03,419
completely random so how do we know that

599
00:24:03,419 --> 00:24:07,400
we are indeed pointing here well

600
00:24:07,500 --> 00:24:10,919
since huge is actually well huge uh we

601
00:24:10,919 --> 00:24:12,600
don't really care about the lower bytes

602
00:24:12,600 --> 00:24:15,539
what we care about first are those by

603
00:24:15,539 --> 00:24:17,700
controlling this we can ensure that we

604
00:24:17,700 --> 00:24:19,080
are pointing here

605
00:24:19,080 --> 00:24:21,780
so it's only 4096 possibilities so

606
00:24:21,780 --> 00:24:24,659
that's brute possible Right but there's

607
00:24:24,659 --> 00:24:26,880
one thing how do we know that the

608
00:24:26,880 --> 00:24:28,380
pointer that we corrupted is actually

609
00:24:28,380 --> 00:24:31,140
pointing here well to do this we can try

610
00:24:31,140 --> 00:24:33,960
every address twice

611
00:24:33,960 --> 00:24:36,840
the first time we fill this region with

612
00:24:36,840 --> 00:24:37,740
zeros

613
00:24:37,740 --> 00:24:40,200
if we manage to override the pointer and

614
00:24:40,200 --> 00:24:41,820
make it Point here we have this free

615
00:24:41,820 --> 00:24:44,520
list okay so an address that we changed

616
00:24:44,520 --> 00:24:46,559
pointing to nil so that's a valid free

617
00:24:46,559 --> 00:24:49,320
list because new means no no elements so

618
00:24:49,320 --> 00:24:51,120
when we allocate strings afterwards PHP

619
00:24:51,120 --> 00:24:52,440
will not crash

620
00:24:52,440 --> 00:24:55,620
if we actually fill the region with ffff

621
00:24:55,620 --> 00:24:57,539
well the free list is going to look like

622
00:24:57,539 --> 00:25:01,320
this and that means PHP will crash so we

623
00:25:01,320 --> 00:25:04,440
test each of those twice once with zeros

624
00:25:04,440 --> 00:25:07,620
here once with FF here and this way we

625
00:25:07,620 --> 00:25:09,900
can have a different Behavior with the

626
00:25:09,900 --> 00:25:11,520
same address so that means that we are

627
00:25:11,520 --> 00:25:14,820
Indian pointing at the right position

628
00:25:14,820 --> 00:25:16,799
well that's only like one and a half

629
00:25:16,799 --> 00:25:20,580
bytes so we need a few more to beat aslr

630
00:25:20,580 --> 00:25:23,880
uh there's nibos four and five we are

631
00:25:23,880 --> 00:25:25,919
which are on the right here on the

632
00:25:25,919 --> 00:25:30,419
address and to to find them out we can

633
00:25:30,419 --> 00:25:33,419
simply apply dichotomy so on the top we

634
00:25:33,419 --> 00:25:36,360
put zeros on the bottom FF and we just

635
00:25:36,360 --> 00:25:38,760
do the export again does it crash if it

636
00:25:38,760 --> 00:25:40,679
crashes it's on the bottom if it doesn't

637
00:25:40,679 --> 00:25:42,960
it's on the top you repeat this and at

638
00:25:42,960 --> 00:25:45,179
some point you are very like you are

639
00:25:45,179 --> 00:25:47,100
very certain of where you points in this

640
00:25:47,100 --> 00:25:49,860
memory region so that's really good

641
00:25:49,860 --> 00:25:51,960
there's Global bite though which is byte

642
00:25:51,960 --> 00:25:54,000
5 since we have an overflow of four

643
00:25:54,000 --> 00:25:58,080
bytes we can't modify by five luckily

644
00:25:58,080 --> 00:26:00,059
since we are pointing to a memory region

645
00:26:00,059 --> 00:26:02,220
that we control we can fake a pointer

646
00:26:02,220 --> 00:26:05,340
here and only have two 56 possibilities

647
00:26:05,340 --> 00:26:07,860
to try and determine the last byte of

648
00:26:07,860 --> 00:26:09,299
aslr

649
00:26:09,299 --> 00:26:11,460
so we do this until we get no crash and

650
00:26:11,460 --> 00:26:13,140
at some point we have beaten a SLR

651
00:26:13,140 --> 00:26:15,539
completely and we control some free

652
00:26:15,539 --> 00:26:19,860
lists so this is basically ideal exploit

653
00:26:19,860 --> 00:26:21,720
conditions because now what we need to

654
00:26:21,720 --> 00:26:24,299
do is simply create a free list that has

655
00:26:24,299 --> 00:26:26,880
two chunks that overlap once we have

656
00:26:26,880 --> 00:26:29,279
this we allocate the Chunk on the bottom

657
00:26:29,279 --> 00:26:31,080
and then we allocate the Chunk on the

658
00:26:31,080 --> 00:26:33,900
top since the Chunk on the top is bigger

659
00:26:33,900 --> 00:26:36,419
than where it should it's going to

660
00:26:36,419 --> 00:26:38,880
overflow into this chunk and this way

661
00:26:38,880 --> 00:26:40,140
you're going to be able to change the

662
00:26:40,140 --> 00:26:43,740
length of this trunk of this string if

663
00:26:43,740 --> 00:26:45,480
we change the length of this string that

664
00:26:45,480 --> 00:26:47,400
means that when PHP displays it it's

665
00:26:47,400 --> 00:26:49,140
going to actually display the old memory

666
00:26:49,140 --> 00:26:51,480
that comes afterwards and we get a heap

667
00:26:51,480 --> 00:26:54,140
leak

668
00:26:54,360 --> 00:26:56,340
well it's basically done at this point

669
00:26:56,340 --> 00:26:58,620
because if you get a hip leak you can

670
00:26:58,620 --> 00:27:01,020
create lots of arrays remotely using get

671
00:27:01,020 --> 00:27:03,779
and post as I said before and that means

672
00:27:03,779 --> 00:27:05,340
that when you get the Eep leak when you

673
00:27:05,340 --> 00:27:07,080
view the data you're gonna find the

674
00:27:07,080 --> 00:27:09,720
address of some bit Destructor if you

675
00:27:09,720 --> 00:27:10,980
find the address of a pet instructor

676
00:27:10,980 --> 00:27:12,480
that means that you have beaten Pi

677
00:27:12,480 --> 00:27:13,799
because it actually points to the

678
00:27:13,799 --> 00:27:15,179
program men's address

679
00:27:15,179 --> 00:27:17,100
and since you have the program's main

680
00:27:17,100 --> 00:27:18,419
address you can just change the

681
00:27:18,419 --> 00:27:20,940
structure using again the free list that

682
00:27:20,940 --> 00:27:24,240
you control so you might make a send

683
00:27:24,240 --> 00:27:27,840
array on a Zen swing overlap as we did

684
00:27:27,840 --> 00:27:29,760
for two Zen strings and this way you can

685
00:27:29,760 --> 00:27:31,380
override the descriptor and if you can

686
00:27:31,380 --> 00:27:33,960
avoid the restrictor you can change the

687
00:27:33,960 --> 00:27:36,059
address of the function that is executed

688
00:27:36,059 --> 00:27:38,880
when the array gets destroyed and the

689
00:27:38,880 --> 00:27:40,919
array evidently gets destroyed after the

690
00:27:40,919 --> 00:27:42,360
end of the request

691
00:27:42,360 --> 00:27:45,360
so now you get code execution

692
00:27:45,360 --> 00:27:47,580
you probably expect a demo now but

693
00:27:47,580 --> 00:27:49,740
actually there was some kind of patch

694
00:27:49,740 --> 00:27:52,260
that the exploits

695
00:27:52,260 --> 00:27:54,539
so I actually wanted to report it after

696
00:27:54,539 --> 00:27:57,360
like a few months and I realized like

697
00:27:57,360 --> 00:27:59,640
like two days before PHP changed the

698
00:27:59,640 --> 00:28:01,080
code responsible for Clear text

699
00:28:01,080 --> 00:28:03,240
authentication it wasn't related to this

700
00:28:03,240 --> 00:28:04,980
bug but they just wanted to add a null

701
00:28:04,980 --> 00:28:06,620
byte at the end of the medical password

702
00:28:06,620 --> 00:28:09,299
so my expert didn't work anymore

703
00:28:09,299 --> 00:28:11,340
the idea which they exploit here is that

704
00:28:11,340 --> 00:28:12,720
you have to control the last byte

705
00:28:12,720 --> 00:28:14,940
because you won't bite 4 to be console

706
00:28:14,940 --> 00:28:18,000
and if they have a new batch here well

707
00:28:18,000 --> 00:28:19,919
by far by four sorry it's not controlled

708
00:28:19,919 --> 00:28:21,779
anymore and so the expert doesn't work

709
00:28:21,779 --> 00:28:24,240
which is actually a good thing because I

710
00:28:24,240 --> 00:28:25,620
was pretty stupid with my first

711
00:28:25,620 --> 00:28:27,419
exploitation you can do way better and

712
00:28:27,419 --> 00:28:30,240
this is why I'm gonna show here

713
00:28:30,240 --> 00:28:32,460
so

714
00:28:32,460 --> 00:28:34,559
as I said you have a four bytes overflow

715
00:28:34,559 --> 00:28:38,460
but the buffer that gets overflown from

716
00:28:38,460 --> 00:28:41,640
is actually page aligned so if you

717
00:28:41,640 --> 00:28:43,799
create a password which has the size Ox

718
00:28:43,799 --> 00:28:46,620
2000 minus three and you add the four

719
00:28:46,620 --> 00:28:48,240
bytes of overflow you actually get only

720
00:28:48,240 --> 00:28:50,580
one byte of overflow on the next page so

721
00:28:50,580 --> 00:28:52,320
you get a way better primitive a one

722
00:28:52,320 --> 00:28:54,720
byte before buffer is really nice it's

723
00:28:54,720 --> 00:28:58,200
basically a new Love by one uh in the if

724
00:28:58,200 --> 00:29:00,419
uh obviously

725
00:29:00,419 --> 00:29:02,460
we have to explore differently but we

726
00:29:02,460 --> 00:29:05,100
are going to do this it's not too hard

727
00:29:05,100 --> 00:29:06,960
um so the idea is the same as before we

728
00:29:06,960 --> 00:29:09,480
want to overwrite a next pointer so that

729
00:29:09,480 --> 00:29:11,039
we can control some kind of free list

730
00:29:11,039 --> 00:29:13,919
and make it allocate wherever we want I

731
00:29:13,919 --> 00:29:16,140
chose this chunk size is not too

732
00:29:16,140 --> 00:29:18,360
important but for instance if you choose

733
00:29:18,360 --> 00:29:21,000
chunk size of ox 100 every chunk is

734
00:29:21,000 --> 00:29:23,039
going to be aligned with Ox 100 so

735
00:29:23,039 --> 00:29:24,840
you're always going to have zero zero

736
00:29:24,840 --> 00:29:27,000
zero zero zero zero and so your null

737
00:29:27,000 --> 00:29:28,980
bytes of by one is absolutely absolutely

738
00:29:28,980 --> 00:29:32,039
useless in here if you have write this

739
00:29:32,039 --> 00:29:34,260
byte with the zero zero obviously it

740
00:29:34,260 --> 00:29:36,240
doesn't change anything if we override

741
00:29:36,240 --> 00:29:37,799
this one with zero zero it actually

742
00:29:37,799 --> 00:29:39,419
points here so you have some kind of

743
00:29:39,419 --> 00:29:41,880
circular pointering so it's a pretty

744
00:29:41,880 --> 00:29:44,520
awful tool to debug and to to exploit

745
00:29:44,520 --> 00:29:46,980
this one we actually have the same it

746
00:29:46,980 --> 00:29:49,260
actually points to the first chunk here

747
00:29:49,260 --> 00:29:51,240
this one we don't really care about this

748
00:29:51,240 --> 00:29:54,000
one we care about so with this one if we

749
00:29:54,000 --> 00:29:55,919
override with zero zero it will actually

750
00:29:55,919 --> 00:29:58,500
point after this one but before this one

751
00:29:58,500 --> 00:30:00,659
and it will actually overlap with this

752
00:30:00,659 --> 00:30:01,740
one

753
00:30:01,740 --> 00:30:04,380
so our idea here is to overwrite the

754
00:30:04,380 --> 00:30:07,620
pointer that ends with one c0 and make

755
00:30:07,620 --> 00:30:10,440
it actually point to one zero zero this

756
00:30:10,440 --> 00:30:12,899
way it points right before 150 and we

757
00:30:12,899 --> 00:30:14,760
can do the same expertise before the

758
00:30:14,760 --> 00:30:16,500
same export as before is we have two

759
00:30:16,500 --> 00:30:18,899
chunks that actually overlap so we

760
00:30:18,899 --> 00:30:21,120
create a string in the first one and

761
00:30:21,120 --> 00:30:23,220
then we create another string in the

762
00:30:23,220 --> 00:30:25,260
second one and they will overlap so you

763
00:30:25,260 --> 00:30:28,919
can control the header of the first one

764
00:30:28,919 --> 00:30:31,980
so now it's a completely new exploit so

765
00:30:31,980 --> 00:30:33,299
you have to keep in mind we don't have

766
00:30:33,299 --> 00:30:34,860
aslr we don't have Pi anymore we're

767
00:30:34,860 --> 00:30:37,440
starting we are starting from a scratch

768
00:30:37,440 --> 00:30:40,380
so the ID

769
00:30:40,380 --> 00:30:42,659
is to have basically the same if setup

770
00:30:42,659 --> 00:30:44,580
but we don't need huge anymore we cannot

771
00:30:44,580 --> 00:30:46,820
point to it so the green region is gone

772
00:30:46,820 --> 00:30:50,940
and we instead of having a ox4 400 sorry

773
00:30:50,940 --> 00:30:53,220
chunks we are actually using a chunks of

774
00:30:53,220 --> 00:30:55,860
size Ox 70. so basically the same as

775
00:30:55,860 --> 00:30:58,740
before not too hard to do

776
00:30:58,740 --> 00:31:02,100
the problem is we are very interested in

777
00:31:02,100 --> 00:31:04,679
this address here because we will

778
00:31:04,679 --> 00:31:06,840
overflow one byte in this address so

779
00:31:06,840 --> 00:31:10,799
this address really needs to be 1c0 if

780
00:31:10,799 --> 00:31:13,140
it is 70 we're actually going to have a

781
00:31:13,140 --> 00:31:15,659
circular one if it is e0 it's going to

782
00:31:15,659 --> 00:31:18,120
be a circular pointering as well so we

783
00:31:18,120 --> 00:31:19,799
don't want this we actually want this

784
00:31:19,799 --> 00:31:22,740
one to be one c0 so we need to know what

785
00:31:22,740 --> 00:31:24,720
Chunk we are overwriting right we have

786
00:31:24,720 --> 00:31:26,700
sent lots of chunks and feed them all

787
00:31:26,700 --> 00:31:28,799
but we want to know which Chunk we are

788
00:31:28,799 --> 00:31:30,960
overwriting so to do this

789
00:31:30,960 --> 00:31:33,480
basically set up before we do trial on

790
00:31:33,480 --> 00:31:37,320
enter error so we we free every variable

791
00:31:37,320 --> 00:31:40,980
that we send but one so if the variable

792
00:31:40,980 --> 00:31:42,600
is here for instance

793
00:31:42,600 --> 00:31:46,140
we will overflow of four bytes here and

794
00:31:46,140 --> 00:31:48,600
PHP will crash when he wants to allocate

795
00:31:48,600 --> 00:31:50,580
because the free list is

796
00:31:50,580 --> 00:31:51,840
but here

797
00:31:51,840 --> 00:31:55,559
if we actually have uh or or chunk that

798
00:31:55,559 --> 00:31:57,539
is kept allocated on the top we will

799
00:31:57,539 --> 00:32:00,299
overflow only in rev count and if we

800
00:32:00,299 --> 00:32:01,799
overflow in your account it's gonna not

801
00:32:01,799 --> 00:32:03,840
gonna break PHP so it's going to work so

802
00:32:03,840 --> 00:32:05,820
that's a way of finding out which uh

803
00:32:05,820 --> 00:32:09,779
pointer which Chunk we are overwriting

804
00:32:09,779 --> 00:32:12,000
obviously you might suggest using

805
00:32:12,000 --> 00:32:14,760
dichotomy the problem is that if you use

806
00:32:14,760 --> 00:32:16,799
the economy you're going to send data of

807
00:32:16,799 --> 00:32:18,779
different sizes if you send data

808
00:32:18,779 --> 00:32:20,520
different sizes PHP is going to allocate

809
00:32:20,520 --> 00:32:23,039
them differently if if they allocate it

810
00:32:23,039 --> 00:32:25,140
differently all this is going to be

811
00:32:25,140 --> 00:32:26,580
completely changed and you're going to

812
00:32:26,580 --> 00:32:28,380
mess up everything here it's actually

813
00:32:28,380 --> 00:32:30,720
like I'm saying this is easy but it's

814
00:32:30,720 --> 00:32:32,760
actually hell like but at some point

815
00:32:32,760 --> 00:32:34,260
when you have something that works it

816
00:32:34,260 --> 00:32:36,419
usually works everywhere but before this

817
00:32:36,419 --> 00:32:39,179
you have to basically do try on error

818
00:32:39,179 --> 00:32:41,640
until it works out

819
00:32:41,640 --> 00:32:43,740
um so now we have the chunk that we want

820
00:32:43,740 --> 00:32:46,140
we didn't do too many requests to get it

821
00:32:46,140 --> 00:32:49,679
so it's not that expensive and

822
00:32:49,679 --> 00:32:54,779
now the ID is that we want c0 here 2.2

823
00:32:54,779 --> 00:32:57,000
C4 because this is the address we want

824
00:32:57,000 --> 00:33:00,299
to overwrite okay and before this we

825
00:33:00,299 --> 00:33:02,640
actually want 150

826
00:33:02,640 --> 00:33:05,600
to be allocated because once we have

827
00:33:05,600 --> 00:33:08,880
overflow down this is going to be one

828
00:33:08,880 --> 00:33:11,520
zero zero approximately here and then

829
00:33:11,520 --> 00:33:13,260
it's going to overflow into this but to

830
00:33:13,260 --> 00:33:15,059
referring to this we want to have this

831
00:33:15,059 --> 00:33:16,740
already allocated

832
00:33:16,740 --> 00:33:18,419
so that means that we have a free list

833
00:33:18,419 --> 00:33:20,940
that first allocates this and then

834
00:33:20,940 --> 00:33:23,940
allocates uh this and right after this

835
00:33:23,940 --> 00:33:27,960
it's not too hard to do generally by

836
00:33:27,960 --> 00:33:30,059
just sending get and post variables and

837
00:33:30,059 --> 00:33:32,399
freeing them then allocating them again

838
00:33:32,399 --> 00:33:34,679
you can get some kind of if setup that

839
00:33:34,679 --> 00:33:36,960
is not too hard it's actually good

840
00:33:36,960 --> 00:33:39,000
because we actually know the address of

841
00:33:39,000 --> 00:33:41,279
uh well we know the last bytes of c0 so

842
00:33:41,279 --> 00:33:43,500
we know the bytes of the others so it's

843
00:33:43,500 --> 00:33:45,240
not too hard to do I won't take too much

844
00:33:45,240 --> 00:33:47,220
to explain this one so this is the setup

845
00:33:47,220 --> 00:33:49,260
phase now for new exploit we want this

846
00:33:49,260 --> 00:33:51,720
kind of free list in PHP before we

847
00:33:51,720 --> 00:33:54,600
connect to the database right and once

848
00:33:54,600 --> 00:33:56,880
we have this we can trigger the bug so

849
00:33:56,880 --> 00:33:59,580
one bytes before overflow this becomes

850
00:33:59,580 --> 00:34:02,519
one zero zero now we have to change the

851
00:34:02,519 --> 00:34:03,480
overlap

852
00:34:03,480 --> 00:34:05,700
when we allocate this one is going to be

853
00:34:05,700 --> 00:34:07,440
allocated first and then at some point

854
00:34:07,440 --> 00:34:08,940
this one is going to be allocated and

855
00:34:08,940 --> 00:34:09,899
we're going to have to change that

856
00:34:09,899 --> 00:34:11,820
overlap

857
00:34:11,820 --> 00:34:13,320
so now it's pretty easy to exploit it's

858
00:34:13,320 --> 00:34:16,020
very close as before the different thing

859
00:34:16,020 --> 00:34:18,719
though is that we need to beat aslr we

860
00:34:18,719 --> 00:34:21,960
still haven't talked about aslr well in

861
00:34:21,960 --> 00:34:25,440
here there should be a pointer to the

862
00:34:25,440 --> 00:34:27,839
next chunk that is free well

863
00:34:27,839 --> 00:34:30,300
the thing is since we have moved the

864
00:34:30,300 --> 00:34:33,599
pointer that pointed here to here

865
00:34:33,599 --> 00:34:35,460
in here you still have a dangling

866
00:34:35,460 --> 00:34:38,300
pointer so when you do

867
00:34:38,300 --> 00:34:41,580
the the corruption on the Zen swing what

868
00:34:41,580 --> 00:34:42,659
you're going to see

869
00:34:42,659 --> 00:34:45,839
is actually first a pointer to the next

870
00:34:45,839 --> 00:34:47,460
chunk and using the pointer to an

871
00:34:47,460 --> 00:34:49,619
exchange you can obviously deduce aslr

872
00:34:49,619 --> 00:34:52,619
and so you don't care about ASL anymore

873
00:34:52,619 --> 00:34:55,679
so then basically the same as before we

874
00:34:55,679 --> 00:34:58,260
allocate we get effects and swing then

875
00:34:58,260 --> 00:35:02,040
we get effects and array and we get the

876
00:35:02,040 --> 00:35:03,540
address of the main program using the

877
00:35:03,540 --> 00:35:05,880
restrictor which is always going to

878
00:35:05,880 --> 00:35:08,099
point to the main program and so that

879
00:35:08,099 --> 00:35:10,079
means because execution remotely uh

880
00:35:10,079 --> 00:35:11,700
using an adminer

881
00:35:11,700 --> 00:35:14,220
so now it's demo time hopefully it's

882
00:35:14,220 --> 00:35:16,640
gonna work

883
00:35:18,480 --> 00:35:20,900
sorry

884
00:35:20,940 --> 00:35:23,599
10 seconds

885
00:35:28,980 --> 00:35:31,500
10 seconds demo

886
00:35:31,500 --> 00:35:35,060
one two

887
00:35:36,500 --> 00:35:39,359
you need the mic you need the mic ah yes

888
00:35:39,359 --> 00:35:43,500
right this is Amina there isn't the CSS

889
00:35:43,500 --> 00:35:45,720
or anything because I just messed up the

890
00:35:45,720 --> 00:35:48,060
setup but we don't recover but the CSS

891
00:35:48,060 --> 00:35:50,220
do we and

892
00:35:50,220 --> 00:35:54,379
I need to put what

893
00:35:59,460 --> 00:36:02,040
I might help you

894
00:36:02,040 --> 00:36:05,220
oh yeah but okay I need to to get this

895
00:36:05,220 --> 00:36:08,060
going anyways

896
00:36:13,920 --> 00:36:16,520
so

897
00:36:16,520 --> 00:36:20,400
uh there's that media there's an exploit

898
00:36:20,400 --> 00:36:22,099
the exploit is

899
00:36:22,099 --> 00:36:25,280
very simple

900
00:36:26,099 --> 00:36:28,680
so it looks for a chunk uh the thing

901
00:36:28,680 --> 00:36:31,260
that we are overwriting then it will

902
00:36:31,260 --> 00:36:33,359
leak memory uh

903
00:36:33,359 --> 00:36:36,180
get the address of an array and then you

904
00:36:36,180 --> 00:36:39,480
get code execution and to prove this I

905
00:36:39,480 --> 00:36:42,420
created a file here on the right route

906
00:36:42,420 --> 00:36:43,980
but I could do basically anything I have

907
00:36:43,980 --> 00:36:47,180
access to the process memory

908
00:36:54,960 --> 00:36:58,140
so I was too long ago time to finish

909
00:36:58,140 --> 00:37:00,960
time to finish okay well whatever uh I

910
00:37:00,960 --> 00:37:02,520
had the conclusion with basically PHP

911
00:37:02,520 --> 00:37:05,450
sucks and you could fight bugs but uh

912
00:37:05,450 --> 00:37:08,899
[Applause]

913
00:37:11,480 --> 00:37:15,960
okay we we have time for one question be

914
00:37:15,960 --> 00:37:18,300
lucky to the to be the guy to ask a

915
00:37:18,300 --> 00:37:19,440
question

916
00:37:19,440 --> 00:37:22,440
somebody raise your hand

917
00:37:22,440 --> 00:37:23,640
s okay

918
00:37:23,640 --> 00:37:27,180
so I will have a quick question what is

919
00:37:27,180 --> 00:37:29,060
the impact of the exploit or many

920
00:37:29,060 --> 00:37:31,560
systems can be asked do you think it's

921
00:37:31,560 --> 00:37:34,380
dangerous whatever you think about that

922
00:37:34,380 --> 00:37:38,760
take the mic please Charlie we found you

923
00:37:38,760 --> 00:37:40,579
can find a lot of admin

924
00:37:40,579 --> 00:37:42,599
instances and there are also other

925
00:37:42,599 --> 00:37:43,920
things that are vulnerable that you

926
00:37:43,920 --> 00:37:46,260
didn't talk about it but yeah yeah it's

927
00:37:46,260 --> 00:37:49,320
it's pretty useful okay useful but you

928
00:37:49,320 --> 00:37:51,180
have to have someone that up in

929
00:37:51,180 --> 00:37:52,619
the beginning because adminar shouldn't

930
00:37:52,619 --> 00:37:55,020
be on a website that is publicly

931
00:37:55,020 --> 00:37:56,940
accessible okay

932
00:37:56,940 --> 00:37:58,859
thank you so much some announcement

933
00:37:58,859 --> 00:38:02,660
about flora and thanks again Charles

