1
00:00:03,200 --> 00:00:06,779
okay hi hello everyone thanks for being

2
00:00:06,779 --> 00:00:08,940
there today uh today I'm going to

3
00:00:08,940 --> 00:00:12,300
present a crochet so first I'm going to

4
00:00:12,300 --> 00:00:15,420
talk a bit more about myself I'm a Phil

5
00:00:15,420 --> 00:00:17,520
said security researcher at work slam

6
00:00:17,520 --> 00:00:20,820
and since uh October I defended my PhD

7
00:00:20,820 --> 00:00:23,220
and the stuff I'm going to present today

8
00:00:23,220 --> 00:00:25,800
is something I did during this time and

9
00:00:25,800 --> 00:00:27,660
I'm working at quackslab which is a

10
00:00:27,660 --> 00:00:31,019
security company and we also published

11
00:00:31,019 --> 00:00:34,020
some internships so if you are looking

12
00:00:34,020 --> 00:00:35,940
for an internship don't hesitate to look

13
00:00:35,940 --> 00:00:37,440
at our offers

14
00:00:37,440 --> 00:00:40,800
so first let's introduce a bit more what

15
00:00:40,800 --> 00:00:43,320
is crochet and what is it useful for and

16
00:00:43,320 --> 00:00:45,540
for this I'm going to have to go back a

17
00:00:45,540 --> 00:00:47,760
bit in time and understand a bit the

18
00:00:47,760 --> 00:00:50,820
context in which I was doing my PhD so

19
00:00:50,820 --> 00:00:52,920
the subject was looking at a binary

20
00:00:52,920 --> 00:00:55,980
patches within uh or finding if a

21
00:00:55,980 --> 00:00:57,780
security patches has been applied to a

22
00:00:57,780 --> 00:01:00,360
binary and for this you're looking at

23
00:01:00,360 --> 00:01:02,600
static analysis and you're looking at

24
00:01:02,600 --> 00:01:06,119
thousands of 100 of binaries so you need

25
00:01:06,119 --> 00:01:08,280
to find ways to scale a bit your

26
00:01:08,280 --> 00:01:11,460
analysis and how to do some analysis and

27
00:01:11,460 --> 00:01:13,860
disassemble binaries and why are we

28
00:01:13,860 --> 00:01:16,260
actually talking about binary analysis

29
00:01:16,260 --> 00:01:19,080
it's mostly because when you're in the

30
00:01:19,080 --> 00:01:21,000
world you don't usually have the source

31
00:01:21,000 --> 00:01:23,640
code so part of the word is now running

32
00:01:23,640 --> 00:01:25,740
on a closed Source system which is not

33
00:01:25,740 --> 00:01:27,540
something that we're super happy about

34
00:01:27,540 --> 00:01:30,720
but never mind so when you have this not

35
00:01:30,720 --> 00:01:32,280
the source code the only thing you get

36
00:01:32,280 --> 00:01:34,380
is a binomial code and you have to look

37
00:01:34,380 --> 00:01:37,140
at the binary and the problem is how you

38
00:01:37,140 --> 00:01:40,020
make sense of this chunk of bytes and

39
00:01:40,020 --> 00:01:42,299
how do you know that is either data code

40
00:01:42,299 --> 00:01:46,460
or one dump junk and for this

41
00:01:46,460 --> 00:01:50,159
since it's hard or impossible to do it

42
00:01:50,159 --> 00:01:52,860
by hand you use something called

43
00:01:52,860 --> 00:01:56,520
disassemblies so there is a its tools

44
00:01:56,520 --> 00:01:58,579
that are that have been developed to

45
00:01:58,579 --> 00:02:02,040
make sense of this junk or with a chunk

46
00:02:02,040 --> 00:02:04,500
of bytes but this assembling is a hard

47
00:02:04,500 --> 00:02:07,860
problem so you have to understand uh the

48
00:02:07,860 --> 00:02:09,598
difference between code and data you

49
00:02:09,598 --> 00:02:12,180
have to understand what is the content

50
00:02:12,180 --> 00:02:14,879
flow recover the references between all

51
00:02:14,879 --> 00:02:17,700
of this and also find function bundabis

52
00:02:17,700 --> 00:02:20,340
which is even harder because it's a Cuts

53
00:02:20,340 --> 00:02:23,940
this construct and if you're not a

54
00:02:23,940 --> 00:02:26,760
like if you want to you know about know

55
00:02:26,760 --> 00:02:28,200
more about this subject there is a nice

56
00:02:28,200 --> 00:02:30,239
paper uh binary code is not easy that

57
00:02:30,239 --> 00:02:32,400
has been published in 2016 and highlight

58
00:02:32,400 --> 00:02:34,739
some of the problems so since it's a

59
00:02:34,739 --> 00:02:36,959
hard problem there have been a lot of

60
00:02:36,959 --> 00:02:38,459
different tools that have been published

61
00:02:38,459 --> 00:02:41,099
uh to do this and we can divide them

62
00:02:41,099 --> 00:02:43,620
into categories so the first one the

63
00:02:43,620 --> 00:02:45,959
commercial one uh so I'm talking about

64
00:02:45,959 --> 00:02:48,840
binary ninja Ida and Jeb for example

65
00:02:48,840 --> 00:02:51,420
which have a professional support but

66
00:02:51,420 --> 00:02:53,940
and rather expensive license so it's

67
00:02:53,940 --> 00:02:55,560
hard to to buy them if you're just an

68
00:02:55,560 --> 00:02:57,900
obese and you have the open source ones

69
00:02:57,900 --> 00:03:00,540
so for example guide or whatever reason

70
00:03:00,540 --> 00:03:03,180
which are free to use extensible but

71
00:03:03,180 --> 00:03:06,780
maybe lack some support I won't enter

72
00:03:06,780 --> 00:03:08,959
this debate yet right now

73
00:03:08,959 --> 00:03:13,200
so actually the most none of them is

74
00:03:13,200 --> 00:03:15,780
idapo which is a commercial one which is

75
00:03:15,780 --> 00:03:18,599
rather old about 30 years old now and

76
00:03:18,599 --> 00:03:20,280
which support like 60 different

77
00:03:20,280 --> 00:03:22,620
architecture and processors and which is

78
00:03:22,620 --> 00:03:24,900
very very expensive so it's hard to buy

79
00:03:24,900 --> 00:03:26,879
a lessons if you're on your

80
00:03:26,879 --> 00:03:29,099
but sadly it's still one of the best

81
00:03:29,099 --> 00:03:32,760
even the best disassembler in town so if

82
00:03:32,760 --> 00:03:35,099
you want to do something you kind of

83
00:03:35,099 --> 00:03:37,620
have to use it and if you don't trust me

84
00:03:37,620 --> 00:03:40,200
on this we publish the blog post in 2019

85
00:03:40,200 --> 00:03:42,540
comparing different disassemblers and it

86
00:03:42,540 --> 00:03:45,299
still has the best best results on x86

87
00:03:45,299 --> 00:03:47,940
and most architecture

88
00:03:47,940 --> 00:03:50,519
so if you want to automating your

89
00:03:50,519 --> 00:03:52,260
analysis and I'm going back to where I

90
00:03:52,260 --> 00:03:56,940
started Visto you have to use some kind

91
00:03:56,940 --> 00:03:59,519
of scripting within your tool and for

92
00:03:59,519 --> 00:04:01,379
either there is three different options

93
00:04:01,379 --> 00:04:03,659
the first one is IDC which has been

94
00:04:03,659 --> 00:04:06,659
deprecated but was a kind of a c like

95
00:04:06,659 --> 00:04:10,439
language and it was hard to use then you

96
00:04:10,439 --> 00:04:14,040
have the C plus SDK and the C plus SDK

97
00:04:14,040 --> 00:04:18,358
is well most of the function of the tool

98
00:04:18,358 --> 00:04:20,940
are exposed but it's has a pro

99
00:04:20,940 --> 00:04:23,160
documentation while it's still rather

100
00:04:23,160 --> 00:04:26,280
fast if you want to develop a plugin you

101
00:04:26,280 --> 00:04:28,560
can get plug-in with rather large

102
00:04:28,560 --> 00:04:30,180
performances but it's a business

103
00:04:30,180 --> 00:04:32,820
tutorial and finally they introduced a

104
00:04:32,820 --> 00:04:34,620
few years ago either python which

105
00:04:34,620 --> 00:04:37,620
started as a plugin but now is official

106
00:04:37,620 --> 00:04:40,199
and it's python bindings on top of the C

107
00:04:40,199 --> 00:04:43,139
plus plus SDK so not all of the SDK is

108
00:04:43,139 --> 00:04:45,840
sadly exposed but it's best if you want

109
00:04:45,840 --> 00:04:47,759
to prototype and if you want to do some

110
00:04:47,759 --> 00:04:50,460
quick scripting usage then it's a nice

111
00:04:50,460 --> 00:04:54,419
way of doing it however scripting as is

112
00:04:54,419 --> 00:04:56,820
limits especially when you are stuck

113
00:04:56,820 --> 00:05:00,479
within Ida so when you're using you can

114
00:05:00,479 --> 00:05:01,620
only

115
00:05:01,620 --> 00:05:04,259
script a single do script for a single

116
00:05:04,259 --> 00:05:06,660
binary and you have to be within Ida but

117
00:05:06,660 --> 00:05:08,220
if you want to look at Android or

118
00:05:08,220 --> 00:05:10,320
thousands of binaries you want to do

119
00:05:10,320 --> 00:05:11,780
something more on how to

120
00:05:11,780 --> 00:05:13,680
programmatically manipulate the

121
00:05:13,680 --> 00:05:16,979
disassembly of kind of offline and

122
00:05:16,979 --> 00:05:19,199
that's why binary exporters have been

123
00:05:19,199 --> 00:05:22,080
introduced and now we're getting to see

124
00:05:22,080 --> 00:05:25,440
where I was trying to head to so a

125
00:05:25,440 --> 00:05:27,419
binary exporter is something like a

126
00:05:27,419 --> 00:05:29,340
standalone file that you generate from

127
00:05:29,340 --> 00:05:31,259
the disassembly and then you can use

128
00:05:31,259 --> 00:05:33,539
outside of your disassemblers so you

129
00:05:33,539 --> 00:05:35,759
just generate it once and then you can

130
00:05:35,759 --> 00:05:37,560
close your disassembler trade to the bin

131
00:05:37,560 --> 00:05:40,020
and then you still have all the Wizards

132
00:05:40,020 --> 00:05:41,340
and the intelligence of your tool

133
00:05:41,340 --> 00:05:43,979
without any of its problems so you can

134
00:05:43,979 --> 00:05:46,680
use export for a lot of things for

135
00:05:46,680 --> 00:05:49,680
example you can obviously query the

136
00:05:49,680 --> 00:05:51,360
disassembly but that was something that

137
00:05:51,360 --> 00:05:54,960
you could do also within Ida but you can

138
00:05:54,960 --> 00:05:56,940
also use it anywhere on a computer that

139
00:05:56,940 --> 00:05:58,560
does not have either you can share the

140
00:05:58,560 --> 00:06:01,380
disassembly and so on you can load a few

141
00:06:01,380 --> 00:06:03,720
by enemies side by side and do the same

142
00:06:03,720 --> 00:06:06,180
queries on the two binaries which is not

143
00:06:06,180 --> 00:06:07,860
possible if you're stuck inside your

144
00:06:07,860 --> 00:06:11,039
disassemblers you can write scripts that

145
00:06:11,039 --> 00:06:12,780
are not dependent on the disassemblers

146
00:06:12,780 --> 00:06:14,699
version and you can have a stable API

147
00:06:14,699 --> 00:06:17,220
but you lose the interactivity so if you

148
00:06:17,220 --> 00:06:20,400
want to let's say rename stuff and so on

149
00:06:20,400 --> 00:06:23,639
and then it's and you reload your binary

150
00:06:23,639 --> 00:06:25,560
within your disassemble then it gets

151
00:06:25,560 --> 00:06:29,039
lost so that's some done sign there have

152
00:06:29,039 --> 00:06:31,380
been some exporters that have been

153
00:06:31,380 --> 00:06:33,960
introduced the most famous one is bin

154
00:06:33,960 --> 00:06:35,460
export which has been developed by

155
00:06:35,460 --> 00:06:37,979
Dynamics for bindiff so Dynamics has

156
00:06:37,979 --> 00:06:40,220
been acquired by Google a few years ago

157
00:06:40,220 --> 00:06:44,220
but to to make bindiff work they

158
00:06:44,220 --> 00:06:46,199
actually export the binary using bin

159
00:06:46,199 --> 00:06:49,500
Expo and we're loaded Within bindiff uh

160
00:06:49,500 --> 00:06:51,419
there is also the official guide web

161
00:06:51,419 --> 00:06:54,120
plugin for Ida which exports a project

162
00:06:54,120 --> 00:06:57,600
from a Guida to import it into it Gilda

163
00:06:57,600 --> 00:07:00,000
and there is also something from 12 of

164
00:07:00,000 --> 00:07:03,300
which an exporter for Maxima but well

165
00:07:03,300 --> 00:07:05,220
all this uh

166
00:07:05,220 --> 00:07:08,460
either plugin have also some guideway

167
00:07:08,460 --> 00:07:10,440
counterparts so bin export as an

168
00:07:10,440 --> 00:07:12,960
official Port now and guidewa also

169
00:07:12,960 --> 00:07:15,300
exports a built-in kind of exporter but

170
00:07:15,300 --> 00:07:18,060
most of this exporters have some

171
00:07:18,060 --> 00:07:20,699
limitations the first one is they're not

172
00:07:20,699 --> 00:07:23,099
made to be manipulated outside of this

173
00:07:23,099 --> 00:07:26,099
assembler so you're lacking bindings it

174
00:07:26,099 --> 00:07:27,539
does not always export the information

175
00:07:27,539 --> 00:07:30,120
your interest into so you kind of

176
00:07:30,120 --> 00:07:33,419
struggle and then they are not compact

177
00:07:33,419 --> 00:07:35,699
which is kind of a problem and we are

178
00:07:35,699 --> 00:07:38,220
going to see why just in in a while

179
00:07:38,220 --> 00:07:42,060
so imagine a white compactness matter

180
00:07:42,060 --> 00:07:45,060
um the first thing is if you're having a

181
00:07:45,060 --> 00:07:47,160
data set of hundreds of thousands of

182
00:07:47,160 --> 00:07:49,740
binaries it takes some weight and if you

183
00:07:49,740 --> 00:07:52,020
start to run either on them well it

184
00:07:52,020 --> 00:07:55,800
takes time and then as the idb so the

185
00:07:55,800 --> 00:07:58,319
file generated by either containing the

186
00:07:58,319 --> 00:08:00,840
disassemblies result is quite loud

187
00:08:00,840 --> 00:08:03,900
and so we did this test with my intern

188
00:08:03,900 --> 00:08:07,380
on 2000 libraries of open SSL and we had

189
00:08:07,380 --> 00:08:09,780
about six hours of disassembly and it

190
00:08:09,780 --> 00:08:12,720
took from a 1.5 gigabytes of Dynam is

191
00:08:12,720 --> 00:08:15,000
about 25 gigabytes of storage

192
00:08:15,000 --> 00:08:18,120
and it was only a tenth of the data set

193
00:08:18,120 --> 00:08:21,539
so you're trying to you're going to see

194
00:08:21,539 --> 00:08:24,780
how much space it takes on on disk so

195
00:08:24,780 --> 00:08:26,520
it's hard to to manipulate large

196
00:08:26,520 --> 00:08:28,979
binaries data set and so on and that's

197
00:08:28,979 --> 00:08:32,458
why uh Crocker comes into into mine so

198
00:08:32,458 --> 00:08:35,099
quokka is a Ida plugin with a daily

199
00:08:35,099 --> 00:08:38,099
generated logo so it's it tries to

200
00:08:38,099 --> 00:08:40,620
export as much data as possible from a

201
00:08:40,620 --> 00:08:43,919
disassembly it's quite efficient because

202
00:08:43,919 --> 00:08:45,720
we don't want to spend too many time

203
00:08:45,720 --> 00:08:47,519
exporting the data otherwise it's in

204
00:08:47,519 --> 00:08:50,899
usable and it's try to be compact to a

205
00:08:50,899 --> 00:08:54,000
alleged problem I mentioned earlier so

206
00:08:54,000 --> 00:08:55,620
it's open source obviously and it's

207
00:08:55,620 --> 00:08:59,100
available on quarks lab GitHub so to be

208
00:08:59,100 --> 00:09:02,700
a bit more specific uh quokka is a is an

209
00:09:02,700 --> 00:09:04,620
Ida plugin so it has been written in C

210
00:09:04,620 --> 00:09:07,440
plus plus sadly and to be efficient it

211
00:09:07,440 --> 00:09:09,959
generates a protobuf for the exports and

212
00:09:09,959 --> 00:09:12,480
the protobuf is a standalone file that

213
00:09:12,480 --> 00:09:14,880
you can query using the python bindings

214
00:09:14,880 --> 00:09:18,360
and if you're into I don't know PHP then

215
00:09:18,360 --> 00:09:20,160
you could probably write some PHP

216
00:09:20,160 --> 00:09:22,440
bindings on top of portob

217
00:09:22,440 --> 00:09:26,760
and so the tool is mostly exposing this

218
00:09:26,760 --> 00:09:30,060
API and you can manipulate it uh outside

219
00:09:30,060 --> 00:09:32,580
of these assemblers so when I'm saying

220
00:09:32,580 --> 00:09:34,980
uh crocodile try to export everything it

221
00:09:34,980 --> 00:09:37,440
only tries to to do it because it's kind

222
00:09:37,440 --> 00:09:40,380
of hard to so there is a program layout

223
00:09:40,380 --> 00:09:42,899
you know where is your code your data

224
00:09:42,899 --> 00:09:46,620
with junk and so on so it's the top bar

225
00:09:46,620 --> 00:09:48,480
in either for those who are familiar

226
00:09:48,480 --> 00:09:51,839
with the with the tool every data that

227
00:09:51,839 --> 00:09:53,940
types the address and their values if

228
00:09:53,940 --> 00:09:55,680
needed the graphs that have been

229
00:09:55,680 --> 00:09:59,040
generated by others by Ida so either the

230
00:09:59,040 --> 00:10:01,140
choreograph the control photograph and

231
00:10:01,140 --> 00:10:01,980
so on

232
00:10:01,980 --> 00:10:06,000
you also get the code information so not

233
00:10:06,000 --> 00:10:07,800
only the functions the blocks and the

234
00:10:07,800 --> 00:10:09,839
instruction but also

235
00:10:09,839 --> 00:10:13,140
um that type the mnemonics and so on and

236
00:10:13,140 --> 00:10:15,300
finally every analysis results you

237
00:10:15,300 --> 00:10:18,360
already put inside Ida also exported so

238
00:10:18,360 --> 00:10:20,279
if you decided to comment somewhere then

239
00:10:20,279 --> 00:10:23,580
it's uh when it's also exported and if

240
00:10:23,580 --> 00:10:25,620
you decided to rename some part with

241
00:10:25,620 --> 00:10:28,019
structures and animations that they are

242
00:10:28,019 --> 00:10:29,640
also there

243
00:10:29,640 --> 00:10:33,120
so let me have a small bag here

244
00:10:33,120 --> 00:10:34,920
foreign

245
00:10:34,920 --> 00:10:37,220
never mind

246
00:10:37,220 --> 00:10:41,519
okay so when I say quota is compact so

247
00:10:41,519 --> 00:10:43,500
here's a comparison on two different

248
00:10:43,500 --> 00:10:47,880
binaries for either TS TS3 server and

249
00:10:47,880 --> 00:10:50,700
llvm opt which are random binaries I

250
00:10:50,700 --> 00:10:52,920
found on my computer so if you look at

251
00:10:52,920 --> 00:10:55,920
the binary here the first one that's a

252
00:10:55,920 --> 00:10:58,320
size of one and then the idb is seven

253
00:10:58,320 --> 00:11:00,540
times bigger been export exported in

254
00:11:00,540 --> 00:11:02,579
something like three times bigger than

255
00:11:02,579 --> 00:11:04,800
the original binary and quokka is twice

256
00:11:04,800 --> 00:11:07,320
as big as the original binary which is

257
00:11:07,320 --> 00:11:09,240
like a three times prediction over

258
00:11:09,240 --> 00:11:10,440
either

259
00:11:10,440 --> 00:11:12,899
and then for nlvm up which is an even

260
00:11:12,899 --> 00:11:16,260
larger binary you get a it's nine times

261
00:11:16,260 --> 00:11:19,140
bigger the idb and quokka is like three

262
00:11:19,140 --> 00:11:21,060
times bigger as the original binary

263
00:11:21,060 --> 00:11:23,519
which is a nice trade-off because you

264
00:11:23,519 --> 00:11:26,040
can you can drop the idb and then you

265
00:11:26,040 --> 00:11:27,660
only have like four times your initial

266
00:11:27,660 --> 00:11:30,000
binary instead of 10 times when you want

267
00:11:30,000 --> 00:11:32,640
to to manipulate them

268
00:11:32,640 --> 00:11:35,040
and when we say that croca is fast so

269
00:11:35,040 --> 00:11:37,380
let's compare it to to being exposed so

270
00:11:37,380 --> 00:11:41,640
the big blue bars are the either time

271
00:11:41,640 --> 00:11:44,399
for the disassembly which is like

272
00:11:44,399 --> 00:11:47,700
the most uh important one and then you

273
00:11:47,700 --> 00:11:50,519
add only the export time so for bin

274
00:11:50,519 --> 00:11:54,060
export it's about 20 of the the total

275
00:11:54,060 --> 00:11:57,899
time while uh quokka adds only about

276
00:11:57,899 --> 00:12:00,779
eight to ten percent of uh analysis time

277
00:12:00,779 --> 00:12:02,820
which is much more manageable if you

278
00:12:02,820 --> 00:12:05,519
want to do it on a large scale

279
00:12:05,519 --> 00:12:08,399
um and then how to use the tool so

280
00:12:08,399 --> 00:12:11,339
it's first and I either plugging so you

281
00:12:11,339 --> 00:12:13,560
have to install it using either and

282
00:12:13,560 --> 00:12:15,839
since you want to to be efficient you

283
00:12:15,839 --> 00:12:18,720
can use the I.T version which doesn't

284
00:12:18,720 --> 00:12:21,540
spawn a graphic interface and you're

285
00:12:21,540 --> 00:12:23,579
just using use it in the command line

286
00:12:23,579 --> 00:12:26,820
with the quokka Auto parameters or you

287
00:12:26,820 --> 00:12:29,160
can do it directly from the bindings by

288
00:12:29,160 --> 00:12:32,100
just asking to generate it with the from

289
00:12:32,100 --> 00:12:34,680
binary option and this is the only step

290
00:12:34,680 --> 00:12:37,380
where you are required to get an ideal

291
00:12:37,380 --> 00:12:39,360
license so

292
00:12:39,360 --> 00:12:42,000
and then you can ask a friend if he has

293
00:12:42,000 --> 00:12:45,779
one and then I get it and finally you

294
00:12:45,779 --> 00:12:47,700
get a export file which is just a

295
00:12:47,700 --> 00:12:49,860
portable file and you can use it without

296
00:12:49,860 --> 00:12:53,339
any other either version

297
00:12:53,339 --> 00:12:56,459
and that's a small snippet on how to use

298
00:12:56,459 --> 00:12:59,459
the tool when you have your export so

299
00:12:59,459 --> 00:13:01,620
you just get a program class in Python

300
00:13:01,620 --> 00:13:04,800
and then you can manipulate it with I

301
00:13:04,800 --> 00:13:06,600
would like to think send defaults

302
00:13:06,600 --> 00:13:09,839
compared to the Ida API but that's maybe

303
00:13:09,839 --> 00:13:12,660
I'm a bit biased because that's what I

304
00:13:12,660 --> 00:13:15,060
want but when you're looking at the

305
00:13:15,060 --> 00:13:17,880
original python scripting of Ida that's

306
00:13:17,880 --> 00:13:21,300
something that looks a bit more sane and

307
00:13:21,300 --> 00:13:23,519
let's talk about some demos because

308
00:13:23,519 --> 00:13:25,800
otherwise is going to be a bit boring

309
00:13:25,800 --> 00:13:28,500
so the first one is something that I was

310
00:13:28,500 --> 00:13:30,660
interested into because we are looking

311
00:13:30,660 --> 00:13:31,820
at a

312
00:13:31,820 --> 00:13:35,519
uh some papers on machine learning and

313
00:13:35,519 --> 00:13:38,339
most of this paper have some kind of

314
00:13:38,339 --> 00:13:41,459
feature expression part so let's take

315
00:13:41,459 --> 00:13:43,740
this context where you have this new

316
00:13:43,740 --> 00:13:46,620
shiny tool and you want to to test it on

317
00:13:46,620 --> 00:13:48,000
some

318
00:13:48,000 --> 00:13:51,240
some data set but the problem is you

319
00:13:51,240 --> 00:13:53,279
need to extract let's say features from

320
00:13:53,279 --> 00:13:55,139
every function in every from every

321
00:13:55,139 --> 00:13:58,200
binary in your in your data set so you

322
00:13:58,200 --> 00:14:00,060
have two options the first one if you

323
00:14:00,060 --> 00:14:03,180
don't have any exporter is you just

324
00:14:03,180 --> 00:14:05,700
stuck with an Ida so you write Ida

325
00:14:05,700 --> 00:14:07,980
script and you know it's a bit painful

326
00:14:07,980 --> 00:14:10,980
and you have to make sure they work for

327
00:14:10,980 --> 00:14:12,600
you either version and if either version

328
00:14:12,600 --> 00:14:14,100
change in the middle then you have to

329
00:14:14,100 --> 00:14:17,160
rewrite them or you have to keep your

330
00:14:17,160 --> 00:14:20,760
old version or you have a nice exporter

331
00:14:20,760 --> 00:14:22,500
and you just have it to write a simple

332
00:14:22,500 --> 00:14:24,240
script and it works better

333
00:14:24,240 --> 00:14:26,639
so for this example I'm going to take

334
00:14:26,639 --> 00:14:29,760
the out our machine learning is solving

335
00:14:29,760 --> 00:14:31,800
the binary function simulator problem

336
00:14:31,800 --> 00:14:34,380
paper which has been published in use

337
00:14:34,380 --> 00:14:38,940
next 2022 by people from Cisco Telus lab

338
00:14:38,940 --> 00:14:41,279
which is super good if you're interested

339
00:14:41,279 --> 00:14:43,260
in this kind of paper because they

340
00:14:43,260 --> 00:14:45,360
compare a lot of different approaches in

341
00:14:45,360 --> 00:14:48,060
machine learning and how they they

342
00:14:48,060 --> 00:14:49,740
compare when looking at similar

343
00:14:49,740 --> 00:14:52,800
functions and for all this paper we had

344
00:14:52,800 --> 00:14:55,740
to write a features extractions uh

345
00:14:55,740 --> 00:14:58,560
for every function in the binary data

346
00:14:58,560 --> 00:15:00,839
set and we did it using either script so

347
00:15:00,839 --> 00:15:03,420
they have Android not Android but a lot

348
00:15:03,420 --> 00:15:05,839
of Ida script within the data set

349
00:15:05,839 --> 00:15:08,459
on GitHub and you can look at them

350
00:15:08,459 --> 00:15:10,560
because they're quite nicely done but

351
00:15:10,560 --> 00:15:13,260
let's see how we can do this without

352
00:15:13,260 --> 00:15:16,860
using at all either

353
00:15:16,860 --> 00:15:21,019
API and for this I'm

354
00:15:24,660 --> 00:15:27,180
like this this

355
00:15:27,180 --> 00:15:29,839
okay

356
00:15:39,899 --> 00:15:44,240
okay so let's first import quokka

357
00:15:44,240 --> 00:15:47,779
and then

358
00:15:48,000 --> 00:15:50,399
we can load the program so it's going to

359
00:15:50,399 --> 00:15:52,510
to load it directly

360
00:15:52,510 --> 00:15:54,680
[Music]

361
00:15:54,680 --> 00:15:57,000
and when we get the program that has

362
00:15:57,000 --> 00:15:58,680
been loaded so this one is a simple

363
00:15:58,680 --> 00:16:00,779
cubic Acme that you can find also in the

364
00:16:00,779 --> 00:16:02,820
repo if you're interested

365
00:16:02,820 --> 00:16:05,760
uh so let's go and explore what are the

366
00:16:05,760 --> 00:16:08,339
functions within the program

367
00:16:08,339 --> 00:16:10,320
so we just get their name and their

368
00:16:10,320 --> 00:16:12,899
address and there are some of them and

369
00:16:12,899 --> 00:16:15,240
we can see that there are some levels so

370
00:16:15,240 --> 00:16:17,279
it's a quack me and there are some

371
00:16:17,279 --> 00:16:20,519
levels so that makes sense

372
00:16:20,519 --> 00:16:24,240
so let's take the first one level zero

373
00:16:24,240 --> 00:16:27,899
and like look at how much how big is it

374
00:16:27,899 --> 00:16:30,800
so it has seven basic block and we can

375
00:16:30,800 --> 00:16:33,779
try to now export some basic block

376
00:16:33,779 --> 00:16:36,060
features so let's first look at every

377
00:16:36,060 --> 00:16:38,820
instruction in the first block of this

378
00:16:38,820 --> 00:16:42,300
function and we get the instruction

379
00:16:42,300 --> 00:16:46,440
address and the Capstone by the Capstone

380
00:16:46,440 --> 00:16:47,639
the assembly for this instruction

381
00:16:47,639 --> 00:16:50,100
because quokka also provides capstone's

382
00:16:50,100 --> 00:16:51,300
bindings

383
00:16:51,300 --> 00:16:54,180
so you get all this instruction and you

384
00:16:54,180 --> 00:16:57,360
see that it's just regular x86 code that

385
00:16:57,360 --> 00:16:59,880
are just loading and moving that I want

386
00:16:59,880 --> 00:17:03,060
so now in the paper they were looking

387
00:17:03,060 --> 00:17:05,819
for um memory classification so to know

388
00:17:05,819 --> 00:17:09,419
if for example the move uh mnemonic is

389
00:17:09,419 --> 00:17:11,520
something that is related to the stack

390
00:17:11,520 --> 00:17:13,559
or not so they did this whole

391
00:17:13,559 --> 00:17:15,900
architecture mapping uh

392
00:17:15,900 --> 00:17:18,959
a mapping mnemonic mapping which is a

393
00:17:18,959 --> 00:17:22,319
quite a nice job so for example all the

394
00:17:22,319 --> 00:17:24,839
mnemonics in x86 that touch the stack

395
00:17:24,839 --> 00:17:27,540
according to them are those ones that we

396
00:17:27,540 --> 00:17:29,220
are going to use it just because we want

397
00:17:29,220 --> 00:17:32,040
to classify the mnemonics so let's write

398
00:17:32,040 --> 00:17:34,260
a function to export the basic block

399
00:17:34,260 --> 00:17:36,179
features so first we get all the

400
00:17:36,179 --> 00:17:38,400
memonics when we get the architecture of

401
00:17:38,400 --> 00:17:41,700
the program and then we look at how big

402
00:17:41,700 --> 00:17:44,700
is it uh what kind of constant it has

403
00:17:44,700 --> 00:17:46,799
what kind of strings are included into

404
00:17:46,799 --> 00:17:49,919
how many of them varies so I'm not

405
00:17:49,919 --> 00:17:52,440
inventing this with actually features

406
00:17:52,440 --> 00:17:56,460
they used in the in the paper and on

407
00:17:56,460 --> 00:17:59,100
this one it's uh how many memonics are

408
00:17:59,100 --> 00:18:02,039
used using arithmetic features and they

409
00:18:02,039 --> 00:18:05,700
did all all of the others but for vft

410
00:18:05,700 --> 00:18:10,500
reasons I don't put them on here and

411
00:18:10,500 --> 00:18:12,740
let's go further

412
00:18:12,740 --> 00:18:15,539
so let's check if it works and it's not

413
00:18:15,539 --> 00:18:19,080
just a random code so we see that we

414
00:18:19,080 --> 00:18:21,320
still have a basic block exercise

415
00:18:21,320 --> 00:18:24,059
strings that are used here you have the

416
00:18:24,059 --> 00:18:25,740
what's the flag and something that looks

417
00:18:25,740 --> 00:18:28,200
like a flag so maybe that something you

418
00:18:28,200 --> 00:18:30,660
need to look at and then other things so

419
00:18:30,660 --> 00:18:32,760
now we can continue with function level

420
00:18:32,760 --> 00:18:36,440
features and what kind of features are

421
00:18:36,440 --> 00:18:39,240
exported so first we get the all the

422
00:18:39,240 --> 00:18:41,520
features for the block and then we

423
00:18:41,520 --> 00:18:44,640
we get all the features for the the node

424
00:18:44,640 --> 00:18:46,919
the age by looking at the CFG of the

425
00:18:46,919 --> 00:18:50,640
functions and then we export the number

426
00:18:50,640 --> 00:18:54,059
of nodes the number of edges and so on

427
00:18:54,059 --> 00:18:56,640
and we get also our basic block features

428
00:18:56,640 --> 00:18:59,820
and if we do this and we test we can

429
00:18:59,820 --> 00:19:01,860
test it on our function to see if it

430
00:19:01,860 --> 00:19:03,120
works

431
00:19:03,120 --> 00:19:05,820
and we get everything for every block in

432
00:19:05,820 --> 00:19:08,340
the function so that's what is working

433
00:19:08,340 --> 00:19:12,299
and now if you can just wrap it and have

434
00:19:12,299 --> 00:19:16,320
it within your a simple uh

435
00:19:16,320 --> 00:19:18,660
feature extractor for your binary

436
00:19:18,660 --> 00:19:22,500
program that has been done in like

437
00:19:22,500 --> 00:19:25,080
two minutes and 30 seconds because I'm

438
00:19:25,080 --> 00:19:27,840
typing kind of super fast and you get

439
00:19:27,840 --> 00:19:31,620
your Json file in your repository which

440
00:19:31,620 --> 00:19:33,539
is just there

441
00:19:33,539 --> 00:19:38,280
and it's the QB quack made Json here

442
00:19:38,280 --> 00:19:40,260
okay so let's go back

443
00:19:40,260 --> 00:19:41,820
here

444
00:19:41,820 --> 00:19:44,760
so that was the first demo and now a

445
00:19:44,760 --> 00:19:46,380
second one which is a bit more

446
00:19:46,380 --> 00:19:49,679
interesting or different and I like

447
00:19:49,679 --> 00:19:52,020
something that we can do with with

448
00:19:52,020 --> 00:19:54,900
Google and such exporters and that's

449
00:19:54,900 --> 00:19:58,140
actually an ID from a colleague of mine

450
00:19:58,140 --> 00:20:02,220
so we had this bionic file which is a C

451
00:20:02,220 --> 00:20:04,620
library used in

452
00:20:04,620 --> 00:20:08,760
in Android and it has some changes with

453
00:20:08,760 --> 00:20:11,760
the classic ellipsy you find on Unix

454
00:20:11,760 --> 00:20:14,220
system and one of them is the user uid

455
00:20:14,220 --> 00:20:16,860
mapping is embedded within the binary so

456
00:20:16,860 --> 00:20:18,720
you don't have the ETC password file

457
00:20:18,720 --> 00:20:22,440
anymore and the task he gave us was how

458
00:20:22,440 --> 00:20:24,120
to to extract the mapping from the

459
00:20:24,120 --> 00:20:25,200
binary

460
00:20:25,200 --> 00:20:27,419
and for this we are going to use a

461
00:20:27,419 --> 00:20:29,820
simple strategy so first we're going to

462
00:20:29,820 --> 00:20:33,120
find a function that is using this user

463
00:20:33,120 --> 00:20:36,179
table a second is going to within this

464
00:20:36,179 --> 00:20:38,340
function look at the find the data

465
00:20:38,340 --> 00:20:41,880
references to this user table then I

466
00:20:41,880 --> 00:20:44,460
look at identify the table boundaries

467
00:20:44,460 --> 00:20:47,640
and with one entry and then repeat until

468
00:20:47,640 --> 00:20:50,039
we have read the whole

469
00:20:50,039 --> 00:20:54,299
table so first the function using the

470
00:20:54,299 --> 00:20:56,340
user table we can look at for example

471
00:20:56,340 --> 00:20:59,700
get PW uid which is a function that

472
00:20:59,700 --> 00:21:02,520
returns a pointer containing a structure

473
00:21:02,520 --> 00:21:05,240
and so on that actually looks at the

474
00:21:05,240 --> 00:21:09,000
data user mapping and then just we

475
00:21:09,000 --> 00:21:12,360
return the something related to the user

476
00:21:12,360 --> 00:21:16,620
ID then we if we look at the code within

477
00:21:16,620 --> 00:21:18,720
Ida for this function we see there is

478
00:21:18,720 --> 00:21:21,360
the data reference to the Android IDs

479
00:21:21,360 --> 00:21:24,600
but so we we got the function correctly

480
00:21:24,600 --> 00:21:26,520
and then we know that there is already a

481
00:21:26,520 --> 00:21:28,140
data references in the beginning of this

482
00:21:28,140 --> 00:21:30,600
function so it's going to be easy

483
00:21:30,600 --> 00:21:33,960
then we identify the table boundaries so

484
00:21:33,960 --> 00:21:36,600
for bft reasons we just say we use a

485
00:21:36,600 --> 00:21:40,620
navistic and then we can look at our can

486
00:21:40,620 --> 00:21:43,020
we read an entry and we see that if

487
00:21:43,020 --> 00:21:44,640
we're looking at the source code of

488
00:21:44,640 --> 00:21:48,000
bionic we say that the Android IDs are a

489
00:21:48,000 --> 00:21:50,580
name so it's a pointer to a string and

490
00:21:50,580 --> 00:21:53,640
then a simple d word for uid

491
00:21:53,640 --> 00:21:56,340
and finally we can repeat until we get

492
00:21:56,340 --> 00:21:58,320
to the end of the table

493
00:21:58,320 --> 00:22:00,419
so

494
00:22:00,419 --> 00:22:03,419
let's

495
00:22:04,940 --> 00:22:10,280
do it like this let's keep this on

496
00:22:10,740 --> 00:22:13,520
and then

497
00:22:13,860 --> 00:22:16,340
okay

498
00:22:18,740 --> 00:22:23,299
maybe we can do it no

499
00:22:23,580 --> 00:22:26,880
okay let's let's clear the screen so

500
00:22:26,880 --> 00:22:29,280
okay so let's import quokka first like

501
00:22:29,280 --> 00:22:32,640
usual and then let's load our Lipsy that

502
00:22:32,640 --> 00:22:34,320
is already exported

503
00:22:34,320 --> 00:22:36,600
so then we get the program that has been

504
00:22:36,600 --> 00:22:39,240
loaded then we want to look at the

505
00:22:39,240 --> 00:22:40,440
function so let's look at the

506
00:22:40,440 --> 00:22:42,179
documentation of the get function and

507
00:22:42,179 --> 00:22:44,460
since we're using ipten you get the

508
00:22:44,460 --> 00:22:46,679
documentation for free in your shell so

509
00:22:46,679 --> 00:22:50,280
it's super cool to prototype so the get

510
00:22:50,280 --> 00:22:52,440
function takes a name as a parameter and

511
00:22:52,440 --> 00:22:54,659
approximative so if we know the exact

512
00:22:54,659 --> 00:22:56,940
name we can use this parameter so that's

513
00:22:56,940 --> 00:22:59,340
exactly what we're going to do so we are

514
00:22:59,340 --> 00:23:03,659
looking at the getpu the PW uid function

515
00:23:03,659 --> 00:23:05,700
and it's

516
00:23:05,700 --> 00:23:08,460
and we found it and now we can look at

517
00:23:08,460 --> 00:23:11,039
the data references within this function

518
00:23:11,039 --> 00:23:14,539
so we are at step two here

519
00:23:14,580 --> 00:23:17,220
so let's print all the data that are

520
00:23:17,220 --> 00:23:19,380
used within this function the type and

521
00:23:19,380 --> 00:23:20,880
their address because we are going to

522
00:23:20,880 --> 00:23:23,400
need them and we see that there is a

523
00:23:23,400 --> 00:23:26,580
four data the first one and the last one

524
00:23:26,580 --> 00:23:28,860
are not named but the two in the middle

525
00:23:28,860 --> 00:23:30,900
are the Android IDs table we are

526
00:23:30,900 --> 00:23:32,760
interested in

527
00:23:32,760 --> 00:23:33,299
um

528
00:23:33,299 --> 00:23:35,940
then we can

529
00:23:35,940 --> 00:23:39,299
check what is this uh we know that this

530
00:23:39,299 --> 00:23:41,700
Android ID table starts with a string so

531
00:23:41,700 --> 00:23:44,340
if we are looking at the string in this

532
00:23:44,340 --> 00:23:45,480
um

533
00:23:45,480 --> 00:23:47,880
for this data we can we should actually

534
00:23:47,880 --> 00:23:50,580
read some username and we see that we

535
00:23:50,580 --> 00:23:52,919
get the camera server uid which is

536
00:23:52,919 --> 00:23:54,419
something nice

537
00:23:54,419 --> 00:23:56,580
and then let's read the first user so

538
00:23:56,580 --> 00:23:59,700
the mapping between the string and the

539
00:23:59,700 --> 00:24:03,480
the ID so we know that the it's a table

540
00:24:03,480 --> 00:24:05,880
in C so it's contiguous in memory and

541
00:24:05,880 --> 00:24:08,400
then we have either the

542
00:24:08,400 --> 00:24:11,640
first is a pointer to a to a string and

543
00:24:11,640 --> 00:24:16,200
then the at the next uh at press 4 is

544
00:24:16,200 --> 00:24:19,559
going to be the address of the uid so we

545
00:24:19,559 --> 00:24:22,260
can just get the value here and that's

546
00:24:22,260 --> 00:24:24,659
exactly what's happened so camera server

547
00:24:24,659 --> 00:24:25,820
as your ID

548
00:24:25,820 --> 00:24:31,020
1047 and then we can simply find explain

549
00:24:31,020 --> 00:24:33,059
our heuristic to detect the end of the

550
00:24:33,059 --> 00:24:34,980
table so we know it's going to be a

551
00:24:34,980 --> 00:24:38,640
table in C and in this code there is no

552
00:24:38,640 --> 00:24:40,679
references in the middle code references

553
00:24:40,679 --> 00:24:42,299
in the middle of this table so we

554
00:24:42,299 --> 00:24:44,460
iterate this contiguous chunk of memory

555
00:24:44,460 --> 00:24:47,940
until we find the code references and so

556
00:24:47,940 --> 00:24:49,559
that's something that is super easy to

557
00:24:49,559 --> 00:24:51,480
do with Coca so we see that the second

558
00:24:51,480 --> 00:24:53,820
user has no code references because it's

559
00:24:53,820 --> 00:24:56,700
not yet the end of the table

560
00:24:56,700 --> 00:24:58,260
um they have there would have been other

561
00:24:58,260 --> 00:25:00,720
ways to do it like finding for example

562
00:25:00,720 --> 00:25:02,880
in the functions comparison until the

563
00:25:02,880 --> 00:25:05,100
max uid or the number of entries because

564
00:25:05,100 --> 00:25:07,740
it's statically embedded but that's one

565
00:25:07,740 --> 00:25:08,940
way to do it

566
00:25:08,940 --> 00:25:11,880
the user ID is read simply by using the

567
00:25:11,880 --> 00:25:14,360
read data function that takes an address

568
00:25:14,360 --> 00:25:18,059
and a size so a double word here and

569
00:25:18,059 --> 00:25:21,419
then we can wrap everything up and get

570
00:25:21,419 --> 00:25:23,760
the word user table so we start at the

571
00:25:23,760 --> 00:25:26,039
first

572
00:25:26,039 --> 00:25:28,980
the first element and since we already

573
00:25:28,980 --> 00:25:31,080
have the first user we we get the next

574
00:25:31,080 --> 00:25:33,720
point and then we continue until we find

575
00:25:33,720 --> 00:25:37,799
convey fences and we find our first

576
00:25:37,799 --> 00:25:41,700
username the user ID we print them and

577
00:25:41,700 --> 00:25:44,039
we open them to our table and we

578
00:25:44,039 --> 00:25:46,919
increment our content and we iterate

579
00:25:46,919 --> 00:25:49,080
over this so everything has been done

580
00:25:49,080 --> 00:25:52,260
without even touching as a idb except

581
00:25:52,260 --> 00:25:54,419
for generating the

582
00:25:54,419 --> 00:25:56,400
the

583
00:25:56,400 --> 00:26:00,600
the export file and last uh concluded

584
00:26:00,600 --> 00:26:03,059
the presentation

585
00:26:03,059 --> 00:26:04,799
so

586
00:26:04,799 --> 00:26:10,200
first uh what is yet to be what needs to

587
00:26:10,200 --> 00:26:12,240
be done in the tool so it's it's nice

588
00:26:12,240 --> 00:26:14,820
but it's not complete yet so there is no

589
00:26:14,820 --> 00:26:16,679
export of the types which is a pain

590
00:26:16,679 --> 00:26:18,720
because it's it could be super nice to

591
00:26:18,720 --> 00:26:20,940
have them and there are some other

592
00:26:20,940 --> 00:26:23,700
things that could be improved and if we

593
00:26:23,700 --> 00:26:26,220
wanted to go a bit further so you could

594
00:26:26,220 --> 00:26:27,960
actually export over these assemblies

595
00:26:27,960 --> 00:26:30,539
like gaidua which has a nice API even if

596
00:26:30,539 --> 00:26:33,240
it's in Java and you could try to export

597
00:26:33,240 --> 00:26:35,039
decompiled information because at this

598
00:26:35,039 --> 00:26:37,100
moment we are only interested in the

599
00:26:37,100 --> 00:26:40,380
disassembly path and we could integrate

600
00:26:40,380 --> 00:26:42,900
over tools like let's say I want to get

601
00:26:42,900 --> 00:26:45,600
a context like a Titan context for a

602
00:26:45,600 --> 00:26:48,299
function or so on and that's all for me

603
00:26:48,299 --> 00:26:49,679
so if you have any questions don't

604
00:26:49,679 --> 00:26:50,940
hesitate

605
00:26:50,940 --> 00:26:53,840
and then

606
00:26:59,539 --> 00:27:03,480
thank you Alexi I really appreciate your

607
00:27:03,480 --> 00:27:04,980
talk and the fact that you're talking

608
00:27:04,980 --> 00:27:07,260
consideration most of the comments that

609
00:27:07,260 --> 00:27:10,020
we made during the review so I have no

610
00:27:10,020 --> 00:27:14,600
question now uh are there any questions

611
00:27:20,400 --> 00:27:23,059
oops

612
00:27:25,340 --> 00:27:27,559
I guess

613
00:27:27,559 --> 00:27:31,080
hello thanks for the presentation

614
00:27:31,080 --> 00:27:34,080
um so as you said it's uh kinda only

615
00:27:34,080 --> 00:27:37,559
compatible with Ida for now are there

616
00:27:37,559 --> 00:27:39,900
any plans to make it compatible with I

617
00:27:39,900 --> 00:27:43,440
don't know gaija rather 2 or anything

618
00:27:43,440 --> 00:27:46,679
else the problem of this is as you're

619
00:27:46,679 --> 00:27:48,480
looking at the world API of the

620
00:27:48,480 --> 00:27:51,120
disassembler so since you have to export

621
00:27:51,120 --> 00:27:52,980
most of the thing you have to look at

622
00:27:52,980 --> 00:27:55,679
the world API and maintaining one tool

623
00:27:55,679 --> 00:27:58,140
is hard since even either change its

624
00:27:58,140 --> 00:27:59,940
compatibility sometimes and if you look

625
00:27:59,940 --> 00:28:02,520
at the plugin code there starts to be

626
00:28:02,520 --> 00:28:06,200
fiddled with defines and so on so

627
00:28:06,200 --> 00:28:09,000
maintaining it for another tour but I'm

628
00:28:09,000 --> 00:28:12,779
not using is kind of hard but if someone

629
00:28:12,779 --> 00:28:15,240
is reading like is using this and find

630
00:28:15,240 --> 00:28:17,340
it super interesting I'm more than happy

631
00:28:17,340 --> 00:28:21,179
to to help getting on board on on this

632
00:28:21,179 --> 00:28:23,580
but I don't think I have the skills in

633
00:28:23,580 --> 00:28:25,500
Java to do it for example for guideway

634
00:28:25,500 --> 00:28:27,539
and I don't think over this numbers

635
00:28:27,539 --> 00:28:29,580
could do the trick because they are

636
00:28:29,580 --> 00:28:32,899
lacking some features

637
00:28:33,419 --> 00:28:37,340
okay thanks any other question

638
00:28:39,360 --> 00:28:41,279
all right we're gonna be thanking Galaxy

639
00:28:41,279 --> 00:28:41,770
again

640
00:28:41,770 --> 00:28:42,550
[Music]

641
00:28:42,550 --> 00:28:46,069
[Applause]

