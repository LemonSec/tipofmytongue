1
00:00:00,160 --> 00:00:02,000
welcome to this talk about optimizing

2
00:00:02,000 --> 00:00:03,840
server-side template injection payloads

3
00:00:03,840 --> 00:00:05,359
for gj2

4
00:00:05,359 --> 00:00:07,680
i'm remy geschu also known as podalyrius

5
00:00:07,680 --> 00:00:11,440
and i am agrihack 2021

6
00:00:13,440 --> 00:00:14,799
so in my work days i work as an

7
00:00:14,799 --> 00:00:16,800
offensive security consultant and i do

8
00:00:16,800 --> 00:00:18,960
mostly pen tests and in my nights and my

9
00:00:18,960 --> 00:00:20,480
weekends i work in vulnerability

10
00:00:20,480 --> 00:00:22,400
research and i write open source tools

11
00:00:22,400 --> 00:00:25,359
on github to exploit new vulnerabilities

12
00:00:25,359 --> 00:00:27,279
on my website at podolus.net i also

13
00:00:27,279 --> 00:00:29,519
write articles about how to exploit new

14
00:00:29,519 --> 00:00:33,679
attack vectors and security concepts

15
00:00:36,480 --> 00:00:38,079
in this talk we are going to deep dive

16
00:00:38,079 --> 00:00:39,520
into template and joins and more

17
00:00:39,520 --> 00:00:41,200
specifically the server-side template

18
00:00:41,200 --> 00:00:42,800
injection vulnerabilities that we can

19
00:00:42,800 --> 00:00:45,280
find in them to do this we are going to

20
00:00:45,280 --> 00:00:47,920
use the python gj2 module which is very

21
00:00:47,920 --> 00:00:50,160
famous and very widely used

22
00:00:50,160 --> 00:00:52,239
and we are going to create new payloads

23
00:00:52,239 --> 00:00:55,280
to exploit gj2 sstis which are shorter

24
00:00:55,280 --> 00:00:59,239
than the currently known payload

25
00:01:01,120 --> 00:01:03,280
so what is a template engine

26
00:01:03,280 --> 00:01:05,760
basically a template engine is a new way

27
00:01:05,760 --> 00:01:07,840
of thinking our web application works

28
00:01:07,840 --> 00:01:09,760
where the template and the data are

29
00:01:09,760 --> 00:01:11,840
clearly separated

30
00:01:11,840 --> 00:01:14,159
we take an as an example order paradigms

31
00:01:14,159 --> 00:01:17,840
such as php in php you would have a php

32
00:01:17,840 --> 00:01:19,759
code and html code all mixed up in the

33
00:01:19,759 --> 00:01:21,360
same file

34
00:01:21,360 --> 00:01:23,840
and of course you can include files and

35
00:01:23,840 --> 00:01:27,280
you can do stuff in php to minimize this

36
00:01:27,280 --> 00:01:28,640
but

37
00:01:28,640 --> 00:01:31,439
the main concept is that you have html

38
00:01:31,439 --> 00:01:34,159
code and php code living in the same

39
00:01:34,159 --> 00:01:35,680
file

40
00:01:35,680 --> 00:01:37,840
and in template language you would have

41
00:01:37,840 --> 00:01:40,000
only the html code and template code

42
00:01:40,000 --> 00:01:43,119
inside one file but the data is uh

43
00:01:43,119 --> 00:01:44,640
actually in

44
00:01:44,640 --> 00:01:47,200
something else like an object a request

45
00:01:47,200 --> 00:01:49,280
another file a json file or whatever

46
00:01:49,280 --> 00:01:50,720
whatever you want

47
00:01:50,720 --> 00:01:52,880
and the template engine will create the

48
00:01:52,880 --> 00:01:54,399
link between the two

49
00:01:54,399 --> 00:01:56,240
where it takes as an input the template

50
00:01:56,240 --> 00:01:59,119
file with its template code and it will

51
00:01:59,119 --> 00:02:01,200
replace inside the template file

52
00:02:01,200 --> 00:02:04,719
everything you want from the data

53
00:02:04,719 --> 00:02:06,479
stampified is written in something

54
00:02:06,479 --> 00:02:09,520
called a template code which is

55
00:02:09,520 --> 00:02:11,360
kind of a programming language it has

56
00:02:11,360 --> 00:02:13,360
four loops it has while loops and

57
00:02:13,360 --> 00:02:15,440
condition variable name comments

58
00:02:15,440 --> 00:02:17,200
everything you want

59
00:02:17,200 --> 00:02:20,319
and you can access the variable that you

60
00:02:20,319 --> 00:02:23,680
put in the data inside the template

61
00:02:23,680 --> 00:02:25,599
so template engine replaces everything

62
00:02:25,599 --> 00:02:27,760
it you need and everything you mentioned

63
00:02:27,760 --> 00:02:30,640
inside the template code and outputs

64
00:02:30,640 --> 00:02:33,760
your output string from the template

65
00:02:33,760 --> 00:02:37,440
which can be an html page a markdown

66
00:02:37,440 --> 00:02:39,680
can be a string it can be almost

67
00:02:39,680 --> 00:02:41,840
everything

68
00:02:41,840 --> 00:02:44,720
what matters is only the template code

69
00:02:44,720 --> 00:02:46,800
inside the template

70
00:02:46,800 --> 00:02:48,560
everything is which is not template code

71
00:02:48,560 --> 00:02:50,720
will not be interpreted by the template

72
00:02:50,720 --> 00:02:52,800
engine therefore you can put everything

73
00:02:52,800 --> 00:02:55,200
you want

74
00:02:56,560 --> 00:02:58,560
so these four modules are the most

75
00:02:58,560 --> 00:03:01,840
common template engines on python

76
00:03:01,840 --> 00:03:04,879
marco genshi django and ginger

77
00:03:04,879 --> 00:03:07,200
and in this talk we are going to focus

78
00:03:07,200 --> 00:03:09,200
on ginger a2 and

79
00:03:09,200 --> 00:03:11,760
more specifically jnj2 internals and how

80
00:03:11,760 --> 00:03:14,959
we can exploit how it works to create

81
00:03:14,959 --> 00:03:16,879
new server-side template injection

82
00:03:16,879 --> 00:03:21,120
payloads for ga2

83
00:03:21,599 --> 00:03:26,000
so this is how gj2 looks like um so as i

84
00:03:26,000 --> 00:03:28,400
mentioned before gj2 is a template

85
00:03:28,400 --> 00:03:29,920
engine that

86
00:03:29,920 --> 00:03:31,519
is written in python

87
00:03:31,519 --> 00:03:33,200
and can render

88
00:03:33,200 --> 00:03:35,120
everything you want to a string from

89
00:03:35,120 --> 00:03:37,120
templates and

90
00:03:37,120 --> 00:03:39,200
in python as you can see here in this

91
00:03:39,200 --> 00:03:41,040
screenshot it's really simple to use in

92
00:03:41,040 --> 00:03:42,640
three lines of python you can already

93
00:03:42,640 --> 00:03:44,640
create a template and render it with the

94
00:03:44,640 --> 00:03:47,760
data you want

95
00:03:47,760 --> 00:03:51,920
in gj2 template code most variables are

96
00:03:51,920 --> 00:03:54,640
surrounded with two curly brackets

97
00:03:54,640 --> 00:03:55,680
and

98
00:03:55,680 --> 00:03:57,280
it's really simple to use as you can see

99
00:03:57,280 --> 00:03:59,120
here

100
00:03:59,120 --> 00:04:00,879
that's why it's used in many python

101
00:04:00,879 --> 00:04:04,239
modules and applications that are

102
00:04:04,239 --> 00:04:06,000
web applications that are based on flask

103
00:04:06,000 --> 00:04:07,840
for apis or

104
00:04:07,840 --> 00:04:09,840
simple applications for example

105
00:04:09,840 --> 00:04:12,799
or in templating uh such as python docs

106
00:04:12,799 --> 00:04:15,680
to generate microsoft word documents

107
00:04:15,680 --> 00:04:18,720
docx files from templates in python it's

108
00:04:18,720 --> 00:04:21,840
based on gnj2

109
00:04:22,560 --> 00:04:24,720
so this is an example of an html

110
00:04:24,720 --> 00:04:27,440
template file for gene j2 where you have

111
00:04:27,440 --> 00:04:30,000
mostly html code and

112
00:04:30,000 --> 00:04:31,919
parts of template code

113
00:04:31,919 --> 00:04:35,280
that is used by dj to template engine

114
00:04:35,280 --> 00:04:37,520
as you can see here we have a for loop

115
00:04:37,520 --> 00:04:39,600
which iterates over the items in the

116
00:04:39,600 --> 00:04:41,360
navigation list

117
00:04:41,360 --> 00:04:45,360
to create html lists in the output file

118
00:04:45,360 --> 00:04:47,759
and we have access to a variable called

119
00:04:47,759 --> 00:04:49,520
variable

120
00:04:49,520 --> 00:04:52,960
so this is really simple to use

121
00:04:53,199 --> 00:04:54,880
so the server side template injection

122
00:04:54,880 --> 00:04:56,880
vulnerability can happen when an

123
00:04:56,880 --> 00:04:58,400
attacker has control over the template

124
00:04:58,400 --> 00:05:00,240
file before being rendered by the

125
00:05:00,240 --> 00:05:01,759
template engine

126
00:05:01,759 --> 00:05:03,919
this can happen in many ways the most

127
00:05:03,919 --> 00:05:06,400
common way are when an attacker modifies

128
00:05:06,400 --> 00:05:08,320
the parameter of the request which will

129
00:05:08,320 --> 00:05:10,240
be reflected inside the template before

130
00:05:10,240 --> 00:05:11,360
rendering

131
00:05:11,360 --> 00:05:14,560
uh this is usually a result of bad code

132
00:05:14,560 --> 00:05:17,520
like mixing format string and

133
00:05:17,520 --> 00:05:20,160
template engines can result in this kind

134
00:05:20,160 --> 00:05:21,039
of

135
00:05:21,039 --> 00:05:22,560
behaviors

136
00:05:22,560 --> 00:05:25,120
and if the attacker has write access to

137
00:05:25,120 --> 00:05:27,360
the source template files for example

138
00:05:27,360 --> 00:05:29,120
using a file upload vulnerability on the

139
00:05:29,120 --> 00:05:30,560
web application

140
00:05:30,560 --> 00:05:33,280
or by ftp with write access or by any

141
00:05:33,280 --> 00:05:34,720
means

142
00:05:34,720 --> 00:05:36,800
he can modify the template and inject

143
00:05:36,800 --> 00:05:38,560
evl template code

144
00:05:38,560 --> 00:05:41,360
to achieve remote code execution or to

145
00:05:41,360 --> 00:05:44,320
modify the template

146
00:05:45,039 --> 00:05:46,560
so now that the attacker has control

147
00:05:46,560 --> 00:05:48,240
over the template file we can consider

148
00:05:48,240 --> 00:05:50,639
the template engine as being compromised

149
00:05:50,639 --> 00:05:53,120
because in most template languages you

150
00:05:53,120 --> 00:05:55,199
have ways to execute commands on the

151
00:05:55,199 --> 00:05:56,960
underlying machine

152
00:05:56,960 --> 00:05:58,319
either by

153
00:05:58,319 --> 00:06:00,720
exploiting the under the template engine

154
00:06:00,720 --> 00:06:06,000
itself or by using modules directly

155
00:06:06,000 --> 00:06:07,440
so now that we have a server-side

156
00:06:07,440 --> 00:06:09,440
template injection vulnerability inside

157
00:06:09,440 --> 00:06:12,240
the gj2 template engine as an attacker

158
00:06:12,240 --> 00:06:14,000
we would like to achieve remote code

159
00:06:14,000 --> 00:06:15,520
execution meaning we would like to

160
00:06:15,520 --> 00:06:17,120
exploit the template engine to gain

161
00:06:17,120 --> 00:06:19,440
access to the underlying machine

162
00:06:19,440 --> 00:06:21,120
in order to do this we will need to

163
00:06:21,120 --> 00:06:24,400
access the os of the os module of python

164
00:06:24,400 --> 00:06:27,759
which gives access to shell commands

165
00:06:27,759 --> 00:06:29,840
to do this inside the template language

166
00:06:29,840 --> 00:06:32,080
of dj2 a previous research have shown

167
00:06:32,080 --> 00:06:34,400
that you can use egg enter payloads

168
00:06:34,400 --> 00:06:36,160
which are highly context dependent

169
00:06:36,160 --> 00:06:38,240
meaning you have to find the offset of

170
00:06:38,240 --> 00:06:40,000
the module you want to import in this

171
00:06:40,000 --> 00:06:42,319
case some process

172
00:06:42,319 --> 00:06:44,800
therefore this type of payloads can be

173
00:06:44,800 --> 00:06:47,520
tricky to use

174
00:06:47,759 --> 00:06:49,520
so the main question that we can ask is

175
00:06:49,520 --> 00:06:51,199
is there other payloads in digital

176
00:06:51,199 --> 00:06:53,599
templates and more specifically can we

177
00:06:53,599 --> 00:06:55,199
find context-free payloads which does

178
00:06:55,199 --> 00:06:57,199
not require any data inside the dot

179
00:06:57,199 --> 00:06:58,880
render function

180
00:06:58,880 --> 00:07:01,440
uh also can we find shorter payloads

181
00:07:01,440 --> 00:07:04,639
that can import the os module

182
00:07:04,639 --> 00:07:08,240
and this is what we will try to build

183
00:07:08,240 --> 00:07:10,240
so inside j2 templates you have

184
00:07:10,240 --> 00:07:12,560
something in the language code which

185
00:07:12,560 --> 00:07:15,599
allows to reuse code blocks

186
00:07:15,599 --> 00:07:17,759
in this example i create a block name

187
00:07:17,759 --> 00:07:20,080
title where i put the value this is a

188
00:07:20,080 --> 00:07:21,360
title

189
00:07:21,360 --> 00:07:23,280
and i can reuse it

190
00:07:23,280 --> 00:07:26,800
in line three using self.title

191
00:07:26,800 --> 00:07:31,840
to access the previously created block

192
00:07:31,840 --> 00:07:35,120
i just have to render the template and

193
00:07:35,120 --> 00:07:37,440
here we have we have the line 6 and line

194
00:07:37,440 --> 00:07:40,560
7 with the same string which is a block

195
00:07:40,560 --> 00:07:43,560
title

196
00:07:44,080 --> 00:07:46,879
so the template reference object in gj2

197
00:07:46,879 --> 00:07:49,039
will hold the values of the blocks that

198
00:07:49,039 --> 00:07:51,039
we previously created

199
00:07:51,039 --> 00:07:52,960
and we can access them everywhere in the

200
00:07:52,960 --> 00:07:56,000
template from self.title and we do not

201
00:07:56,000 --> 00:07:57,360
have to

202
00:07:57,360 --> 00:08:00,560
put on a variable called self inside the

203
00:08:00,560 --> 00:08:03,120
dodge render method on the template

204
00:08:03,120 --> 00:08:04,639
because it's built in inside the

205
00:08:04,639 --> 00:08:07,759
template object and it's already linked

206
00:08:07,759 --> 00:08:11,280
to the template reference object

207
00:08:11,280 --> 00:08:13,280
this seems really cool from an attacker

208
00:08:13,280 --> 00:08:16,160
point of view because it's context-free

209
00:08:16,160 --> 00:08:18,240
we do not need anything in the dot

210
00:08:18,240 --> 00:08:19,919
render function

211
00:08:19,919 --> 00:08:21,199
to access

212
00:08:21,199 --> 00:08:23,199
the template reference object

213
00:08:23,199 --> 00:08:25,039
therefore we can use it as a starting

214
00:08:25,039 --> 00:08:28,240
point to create a payload

215
00:08:28,800 --> 00:08:30,479
so as we've seen the template reference

216
00:08:30,479 --> 00:08:32,719
object in jnj2 can be accessed from

217
00:08:32,719 --> 00:08:34,479
within a template with the double curly

218
00:08:34,479 --> 00:08:36,399
brackets itself

219
00:08:36,399 --> 00:08:38,399
and it's a context free variable meaning

220
00:08:38,399 --> 00:08:40,640
you don't have to do anything in the dot

221
00:08:40,640 --> 00:08:43,760
render function to have access to self

222
00:08:43,760 --> 00:08:47,279
and it's always accessible so we are

223
00:08:47,279 --> 00:08:49,279
going to use this as the base of our

224
00:08:49,279 --> 00:08:51,760
payloads

225
00:08:52,800 --> 00:08:55,040
so as i mentioned earlier if we want to

226
00:08:55,040 --> 00:08:56,560
achieve remote code execution we will

227
00:08:56,560 --> 00:09:00,399
need to access the python os module

228
00:09:00,399 --> 00:09:03,040
so we will need to find where we can

229
00:09:03,040 --> 00:09:05,680
access it from within jnj2

230
00:09:05,680 --> 00:09:06,640
because

231
00:09:06,640 --> 00:09:08,880
inside the template code of jnj2 you

232
00:09:08,880 --> 00:09:12,800
cannot use a classical python syntax and

233
00:09:12,800 --> 00:09:15,120
since you cannot import modules

234
00:09:15,120 --> 00:09:16,640
traditionally

235
00:09:16,640 --> 00:09:18,800
so we will need to find somewhere inside

236
00:09:18,800 --> 00:09:21,680
gj2 where the os module is already

237
00:09:21,680 --> 00:09:25,519
imported and how we can access it

238
00:09:25,519 --> 00:09:28,480
so if we try to explore a bit of dj2

239
00:09:28,480 --> 00:09:29,839
using

240
00:09:29,839 --> 00:09:31,760
python introspection like the deer

241
00:09:31,760 --> 00:09:32,720
function

242
00:09:32,720 --> 00:09:35,839
we can find by hand a path to the os

243
00:09:35,839 --> 00:09:37,360
module

244
00:09:37,360 --> 00:09:40,160
from the root of the module so

245
00:09:40,160 --> 00:09:43,160
j2.bck.tempfile.os

246
00:09:44,320 --> 00:09:47,600
access to the os module

247
00:09:47,600 --> 00:09:50,240
so this is possible to find one path to

248
00:09:50,240 --> 00:09:53,040
os by hand but it's clearly not possible

249
00:09:53,040 --> 00:09:55,920
to try every possibility of every path

250
00:09:55,920 --> 00:09:59,439
inside gj2 by hand

251
00:09:59,600 --> 00:10:01,839
so in order to find the

252
00:10:01,839 --> 00:10:04,399
path to the os module inside the gj2

253
00:10:04,399 --> 00:10:07,519
module we need to look at the python

254
00:10:07,519 --> 00:10:09,279
object tree as a graph

255
00:10:09,279 --> 00:10:11,600
and we are going to explore it

256
00:10:11,600 --> 00:10:13,680
like a traditional graph in breadth

257
00:10:13,680 --> 00:10:14,880
first search

258
00:10:14,880 --> 00:10:17,920
to list every possible path to our dos

259
00:10:17,920 --> 00:10:18,880
module

260
00:10:18,880 --> 00:10:19,839
and

261
00:10:19,839 --> 00:10:22,480
to see if we can leverage one of this

262
00:10:22,480 --> 00:10:25,279
path to connect to the template

263
00:10:25,279 --> 00:10:28,880
reference object that we found earlier

264
00:10:28,959 --> 00:10:31,519
so as i mentioned earlier python offers

265
00:10:31,519 --> 00:10:33,279
introspection concepts which means we

266
00:10:33,279 --> 00:10:35,760
can use python internal functions to

267
00:10:35,760 --> 00:10:37,920
crawl the object's attributes and

268
00:10:37,920 --> 00:10:39,279
functions

269
00:10:39,279 --> 00:10:41,040
as graph notes

270
00:10:41,040 --> 00:10:42,079
and

271
00:10:42,079 --> 00:10:43,600
we are going to use a breadth first

272
00:10:43,600 --> 00:10:45,040
search because

273
00:10:45,040 --> 00:10:46,720
using this we are going to find the

274
00:10:46,720 --> 00:10:50,480
shortest path to the os module in first

275
00:10:50,480 --> 00:10:52,880
and as we want to create the shortest

276
00:10:52,880 --> 00:10:54,800
payload possible

277
00:10:54,800 --> 00:10:56,079
this is

278
00:10:56,079 --> 00:10:58,800
really useful

279
00:10:58,800 --> 00:11:01,839
so here is a small animation that shows

280
00:11:01,839 --> 00:11:03,360
uh how we are going to work inside the

281
00:11:03,360 --> 00:11:05,760
python object tree so if we start at

282
00:11:05,760 --> 00:11:08,240
object one we are going to go in

283
00:11:08,240 --> 00:11:10,480
breadth-first search so up

284
00:11:10,480 --> 00:11:12,640
we access attribute one and attribute

285
00:11:12,640 --> 00:11:15,760
two then object 2 object 2 and the os

286
00:11:15,760 --> 00:11:18,720
module and we find a path to the os

287
00:11:18,720 --> 00:11:21,120
module

288
00:11:21,279 --> 00:11:22,399
and this path is at

289
00:11:22,399 --> 00:11:25,399
object1.attribute2.os

290
00:11:26,560 --> 00:11:28,800
so when we explore the python object

291
00:11:28,800 --> 00:11:32,079
tree as a graph in breadth first search

292
00:11:32,079 --> 00:11:35,360
we can we can have at least two problems

293
00:11:35,360 --> 00:11:37,680
the first one is cyclic traps which

294
00:11:37,680 --> 00:11:40,959
means um if we have like in this example

295
00:11:40,959 --> 00:11:43,600
an object which refers itself in one of

296
00:11:43,600 --> 00:11:46,160
its childs

297
00:11:46,160 --> 00:11:48,480
you will have an infinite loop meaning

298
00:11:48,480 --> 00:11:50,480
uh in this example you will explore

299
00:11:50,480 --> 00:11:52,000
object one

300
00:11:52,000 --> 00:11:54,399
then attribute two then attribute three

301
00:11:54,399 --> 00:11:56,880
and you will find object one in the

302
00:11:56,880 --> 00:11:59,600
attribute three uh child nodes so you

303
00:11:59,600 --> 00:12:02,800
will go uh to uh you will loop to object

304
00:12:02,800 --> 00:12:05,279
one and you will start over

305
00:12:05,279 --> 00:12:08,079
so this will create an infinite loop and

306
00:12:08,079 --> 00:12:09,440
um

307
00:12:09,440 --> 00:12:12,560
we need to avoid this

308
00:12:12,959 --> 00:12:14,800
the second problem that we have is a

309
00:12:14,800 --> 00:12:16,959
long expression time because during a

310
00:12:16,959 --> 00:12:18,720
breadth first search we will acquire a

311
00:12:18,720 --> 00:12:20,959
lot of objects in the python object tree

312
00:12:20,959 --> 00:12:22,320
and we can

313
00:12:22,320 --> 00:12:24,639
contour many of them more than once for

314
00:12:24,639 --> 00:12:27,680
example um in this graph we have object

315
00:12:27,680 --> 00:12:29,839
two which occurs three times

316
00:12:29,839 --> 00:12:31,839
uh meaning if we explore object one

317
00:12:31,839 --> 00:12:33,839
we'll go to attribute one then object

318
00:12:33,839 --> 00:12:36,320
two then attribute two then object two

319
00:12:36,320 --> 00:12:38,000
and we will have

320
00:12:38,000 --> 00:12:40,000
the object 2 which is

321
00:12:40,000 --> 00:12:42,639
referenced many times but it's the same

322
00:12:42,639 --> 00:12:43,600
object

323
00:12:43,600 --> 00:12:46,480
so we have a massive loss of time when

324
00:12:46,480 --> 00:12:48,320
exploring multiple times the same

325
00:12:48,320 --> 00:12:50,399
objects and we will have the same result

326
00:12:50,399 --> 00:12:51,920
that each time because it's the same

327
00:12:51,920 --> 00:12:52,800
object

328
00:12:52,800 --> 00:12:56,160
so we need to avoid this as well

329
00:12:56,560 --> 00:12:58,399
so to solve both of these problems i use

330
00:12:58,399 --> 00:13:01,200
the python id internal function which

331
00:13:01,200 --> 00:13:02,639
allows to

332
00:13:02,639 --> 00:13:03,600
check

333
00:13:03,600 --> 00:13:06,079
the memory address of an object given

334
00:13:06,079 --> 00:13:07,360
parameter

335
00:13:07,360 --> 00:13:10,959
so i just added a list called known ids

336
00:13:10,959 --> 00:13:13,839
into my program which stores every

337
00:13:13,839 --> 00:13:15,760
memory address of every object that has

338
00:13:15,760 --> 00:13:18,160
been explored inside the breadth first

339
00:13:18,160 --> 00:13:19,680
search

340
00:13:19,680 --> 00:13:23,360
so when i explore child nodes of a node

341
00:13:23,360 --> 00:13:25,200
i know every

342
00:13:25,200 --> 00:13:28,240
object that i already crawled so i don't

343
00:13:28,240 --> 00:13:29,680
have to

344
00:13:29,680 --> 00:13:34,040
explore many times the same object

345
00:13:34,079 --> 00:13:36,000
so here is an example of the output of

346
00:13:36,000 --> 00:13:38,800
my tool which prints a found module with

347
00:13:38,800 --> 00:13:41,040
module name and the complete path from

348
00:13:41,040 --> 00:13:43,120
the source module to the target module

349
00:13:43,120 --> 00:13:44,480
that he found

350
00:13:44,480 --> 00:13:47,680
it does not only looks for the os module

351
00:13:47,680 --> 00:13:50,880
and it lists every module it finds

352
00:13:50,880 --> 00:13:54,160
during the breadth first search

353
00:13:54,639 --> 00:13:56,880
so in output of my tool you also have a

354
00:13:56,880 --> 00:13:59,600
json file containing every path to the

355
00:13:59,600 --> 00:14:01,600
module that you want

356
00:14:01,600 --> 00:14:04,000
for example here in line four you have

357
00:14:04,000 --> 00:14:06,560
the module name the target module name

358
00:14:06,560 --> 00:14:10,079
for example os and after this you have a

359
00:14:10,079 --> 00:14:14,480
list of all the path to os from gj2 with

360
00:14:14,480 --> 00:14:17,839
the complete path each time

361
00:14:18,639 --> 00:14:20,399
so as i mentioned earlier we are going

362
00:14:20,399 --> 00:14:22,240
to use the template reference object as

363
00:14:22,240 --> 00:14:24,480
a starting point because it's context

364
00:14:24,480 --> 00:14:26,480
free meaning it's always accessible from

365
00:14:26,480 --> 00:14:28,639
inside the template no matter what you

366
00:14:28,639 --> 00:14:31,120
have inside the dot render function

367
00:14:31,120 --> 00:14:34,000
so it's a really useful for an attacker

368
00:14:34,000 --> 00:14:35,680
and

369
00:14:35,680 --> 00:14:38,160
we are going to try to

370
00:14:38,160 --> 00:14:39,920
connect the

371
00:14:39,920 --> 00:14:42,720
template reference object to one of the

372
00:14:42,720 --> 00:14:45,040
path to os inside gj2 that we found

373
00:14:45,040 --> 00:14:46,079
earlier

374
00:14:46,079 --> 00:14:50,160
so that we have a context free payload

375
00:14:50,160 --> 00:14:53,040
that can access os each time

376
00:14:53,040 --> 00:14:55,040
so in order in order to do this we need

377
00:14:55,040 --> 00:14:58,320
to list all the attributes and methods

378
00:14:58,320 --> 00:14:59,680
of the

379
00:14:59,680 --> 00:15:02,000
template reference object

380
00:15:02,000 --> 00:15:04,800
to do this i used the deer function of

381
00:15:04,800 --> 00:15:06,240
python to list

382
00:15:06,240 --> 00:15:07,760
every

383
00:15:07,760 --> 00:15:09,600
every python internal function and

384
00:15:09,600 --> 00:15:11,600
attributes and as we can see here

385
00:15:11,600 --> 00:15:13,680
there's only one attribute which is

386
00:15:13,680 --> 00:15:15,920
custom which is not a python internal

387
00:15:15,920 --> 00:15:17,120
function

388
00:15:17,120 --> 00:15:18,800
and it's underscore template reference

389
00:15:18,800 --> 00:15:20,880
underscore underscore context

390
00:15:20,880 --> 00:15:22,880
so uh we need to

391
00:15:22,880 --> 00:15:26,600
deep dive into this

392
00:15:28,399 --> 00:15:30,240
so we are going to print the content of

393
00:15:30,240 --> 00:15:32,720
the template reference context variable

394
00:15:32,720 --> 00:15:34,079
to see what

395
00:15:34,079 --> 00:15:37,279
it has inside and as we can see here in

396
00:15:37,279 --> 00:15:40,639
its string form there is a lot of

397
00:15:40,639 --> 00:15:42,880
information that is printed out

398
00:15:42,880 --> 00:15:45,199
but inside this information there is

399
00:15:45,199 --> 00:15:46,240
three

400
00:15:46,240 --> 00:15:49,199
elements that stands out it's the cycler

401
00:15:49,199 --> 00:15:52,320
joiner and namespace functions which

402
00:15:52,320 --> 00:15:54,560
are classes uh

403
00:15:54,560 --> 00:15:57,600
declared inside j2.utils

404
00:15:57,600 --> 00:15:58,639
module

405
00:15:58,639 --> 00:16:00,320
submodule

406
00:16:00,320 --> 00:16:02,560
and uh it's really interesting because

407
00:16:02,560 --> 00:16:04,880
if we if we remember well what we had

408
00:16:04,880 --> 00:16:05,920
before

409
00:16:05,920 --> 00:16:08,560
um in the output of

410
00:16:08,560 --> 00:16:10,480
the path to uh

411
00:16:10,480 --> 00:16:13,839
to modules from gene j2 we had a path to

412
00:16:13,839 --> 00:16:15,839
os module which is declared inside

413
00:16:15,839 --> 00:16:18,639
util.pi

414
00:16:18,720 --> 00:16:21,360
this means that the os module was

415
00:16:21,360 --> 00:16:24,480
imported globally in the utils.pi file

416
00:16:24,480 --> 00:16:26,800
and this is really cool because

417
00:16:26,800 --> 00:16:30,240
we could use cycler joiner or namespace

418
00:16:30,240 --> 00:16:31,440
classes

419
00:16:31,440 --> 00:16:32,399
to

420
00:16:32,399 --> 00:16:35,920
bounce and jump into the utils.pi global

421
00:16:35,920 --> 00:16:39,279
variables and access the os module which

422
00:16:39,279 --> 00:16:42,880
is imported globally in this file

423
00:16:43,920 --> 00:16:45,680
so we can now access the global

424
00:16:45,680 --> 00:16:48,240
variables of the utils.pi file fairly

425
00:16:48,240 --> 00:16:51,040
easily because we can connect the

426
00:16:51,040 --> 00:16:53,120
self.template reference context to

427
00:16:53,120 --> 00:16:55,360
cycler joiner or namespace

428
00:16:55,360 --> 00:16:56,160
and

429
00:16:56,160 --> 00:16:58,720
use cycler joiner or namespace to jump

430
00:16:58,720 --> 00:17:01,600
into the utils.by globals

431
00:17:01,600 --> 00:17:04,240
using dot underscore underscore init dot

432
00:17:04,240 --> 00:17:06,319
underscore underscore globals

433
00:17:06,319 --> 00:17:08,240
to uh

434
00:17:08,240 --> 00:17:11,119
get out of the class and access the

435
00:17:11,119 --> 00:17:13,760
global variables of the utils dot pi

436
00:17:13,760 --> 00:17:15,039
file

437
00:17:15,039 --> 00:17:17,119
in this global variables as we can see

438
00:17:17,119 --> 00:17:19,919
there is the os module

439
00:17:19,919 --> 00:17:23,039
on the center of the screen

440
00:17:23,359 --> 00:17:25,199
we now have a new payload to access the

441
00:17:25,199 --> 00:17:28,160
os module directly from a g82 template

442
00:17:28,160 --> 00:17:30,640
and this without requirements

443
00:17:30,640 --> 00:17:33,440
this payload is shorter than the agander

444
00:17:33,440 --> 00:17:35,360
payload and

445
00:17:35,360 --> 00:17:37,840
most notably there is less special

446
00:17:37,840 --> 00:17:39,280
characters in it

447
00:17:39,280 --> 00:17:40,960
so it will

448
00:17:40,960 --> 00:17:42,160
be

449
00:17:42,160 --> 00:17:44,840
simpler to use if there's filters in

450
00:17:44,840 --> 00:17:48,080
place also as you can see it's context

451
00:17:48,080 --> 00:17:50,240
free meaning it works

452
00:17:50,240 --> 00:17:52,559
even if the dot render function is

453
00:17:52,559 --> 00:17:55,679
completely empty and also you don't have

454
00:17:55,679 --> 00:17:57,200
the offset

455
00:17:57,200 --> 00:17:58,960
problem the offset problems that we had

456
00:17:58,960 --> 00:18:01,679
in the egg enter payloads where there is

457
00:18:01,679 --> 00:18:03,520
an offset that you have to find each

458
00:18:03,520 --> 00:18:05,679
time you want to run the payload

459
00:18:05,679 --> 00:18:07,440
uh in this payload you don't you don't

460
00:18:07,440 --> 00:18:09,200
have this problem you can access the os

461
00:18:09,200 --> 00:18:11,919
module directly and execute commands

462
00:18:11,919 --> 00:18:14,160
as we can see here i wrote a few lines

463
00:18:14,160 --> 00:18:17,120
of python to try this locally in jnj2

464
00:18:17,120 --> 00:18:18,799
template

465
00:18:18,799 --> 00:18:20,240
if we inject

466
00:18:20,240 --> 00:18:22,080
our payload with a self-template

467
00:18:22,080 --> 00:18:25,280
reference context a cycler joiner

468
00:18:25,280 --> 00:18:27,120
namespace

469
00:18:27,120 --> 00:18:28,720
one one of these three

470
00:18:28,720 --> 00:18:31,520
and access to init global's os

471
00:18:31,520 --> 00:18:33,600
you have access directly to the os

472
00:18:33,600 --> 00:18:36,480
module from the dj2 template each time

473
00:18:36,480 --> 00:18:40,400
and the dot render function is empty

474
00:18:41,280 --> 00:18:43,919
so uh to finish this we can add a little

475
00:18:43,919 --> 00:18:45,600
bit of optimization

476
00:18:45,600 --> 00:18:48,160
uh as we see we are already inside the

477
00:18:48,160 --> 00:18:50,880
template context because we are inside a

478
00:18:50,880 --> 00:18:53,120
template file which will be rendered by

479
00:18:53,120 --> 00:18:54,640
the template engine

480
00:18:54,640 --> 00:18:56,880
so we are inside the template

481
00:18:56,880 --> 00:18:58,480
therefore we can remove the

482
00:18:58,480 --> 00:19:00,559
self.template reference context from the

483
00:19:00,559 --> 00:19:02,720
payloads because the self.template

484
00:19:02,720 --> 00:19:04,080
reference context

485
00:19:04,080 --> 00:19:06,880
is an internal jnj2 object

486
00:19:06,880 --> 00:19:07,679
which

487
00:19:07,679 --> 00:19:10,559
we use to list the variables that are

488
00:19:10,559 --> 00:19:12,400
declared inside the template

489
00:19:12,400 --> 00:19:14,080
but as we are already inside the

490
00:19:14,080 --> 00:19:16,799
template we can use directly cycler

491
00:19:16,799 --> 00:19:19,200
joiner or namespace

492
00:19:19,200 --> 00:19:22,320
and access to init global's os for each

493
00:19:22,320 --> 00:19:25,520
of these three directly

494
00:19:25,520 --> 00:19:27,280
so we now have the shortest possible

495
00:19:27,280 --> 00:19:29,520
payloads to access the os module from a

496
00:19:29,520 --> 00:19:31,360
gj2 template

497
00:19:31,360 --> 00:19:33,440
these three payloads are the shortest

498
00:19:33,440 --> 00:19:35,919
are context-free and

499
00:19:35,919 --> 00:19:38,720
more importantly they cannot be fixed

500
00:19:38,720 --> 00:19:41,440
because they are using how j2 works

501
00:19:41,440 --> 00:19:43,600
internally

502
00:19:43,600 --> 00:19:46,480
internally j2 uses the os module inside

503
00:19:46,480 --> 00:19:48,720
the util.pi file

504
00:19:48,720 --> 00:19:49,440
but

505
00:19:49,440 --> 00:19:50,720
if you are

506
00:19:50,720 --> 00:19:52,640
you cannot just remove the os module

507
00:19:52,640 --> 00:19:54,559
from the util.pi file

508
00:19:54,559 --> 00:19:57,919
and uh if a developer is using j2 in

509
00:19:57,919 --> 00:20:01,039
non-sandbox and mode which is uh

510
00:20:01,039 --> 00:20:03,520
every uh almost every application that i

511
00:20:03,520 --> 00:20:05,840
saw written using

512
00:20:05,840 --> 00:20:08,400
was not using the sandboxing mode

513
00:20:08,400 --> 00:20:11,200
so if if someone does not use this

514
00:20:11,200 --> 00:20:12,559
unboxing mode

515
00:20:12,559 --> 00:20:14,720
it can be vulnerable to this

516
00:20:14,720 --> 00:20:15,679
because

517
00:20:15,679 --> 00:20:17,760
in sandboxing mode there is no way to

518
00:20:17,760 --> 00:20:20,240
escape from the template you cannot

519
00:20:20,240 --> 00:20:24,240
access to os or to any other module

520
00:20:24,240 --> 00:20:25,600
other than the variables that you

521
00:20:25,600 --> 00:20:28,240
declared but in classical mode you can

522
00:20:28,240 --> 00:20:30,240
access the os module with these three

523
00:20:30,240 --> 00:20:32,720
payloads and therefore you can achieve

524
00:20:32,720 --> 00:20:35,039
remote code execution from a server site

525
00:20:35,039 --> 00:20:38,720
template injection in gene j2

526
00:20:38,720 --> 00:20:41,200
thank you for listening you can find my

527
00:20:41,200 --> 00:20:43,919
tools on github my news on twitter and

528
00:20:43,919 --> 00:20:46,559
my articles on my website and i hope you

529
00:20:46,559 --> 00:20:49,840
enjoyed this

530
00:20:56,970 --> 00:20:59,039
[Applause]

531
00:20:59,039 --> 00:21:00,960
do you have any questions

532
00:21:00,960 --> 00:21:02,880
do you have any questions

533
00:21:02,880 --> 00:21:04,559
yes there are a couple of questions at

534
00:21:04,559 --> 00:21:07,840
least from the people online uh at one

535
00:21:07,840 --> 00:21:10,080
point uh first question from

536
00:21:10,080 --> 00:21:12,080
python developers um

537
00:21:12,080 --> 00:21:14,880
it's pretty difficult to avoid to use os

538
00:21:14,880 --> 00:21:16,480
module it's

539
00:21:16,480 --> 00:21:19,039
absolutely necessary

540
00:21:19,039 --> 00:21:19,760
and

541
00:21:19,760 --> 00:21:22,320
neces even when you include third party

542
00:21:22,320 --> 00:21:24,799
code what is the solution to protect

543
00:21:24,799 --> 00:21:25,679
against

544
00:21:25,679 --> 00:21:27,919
this

545
00:21:28,720 --> 00:21:30,559
the solution is not to use the os module

546
00:21:30,559 --> 00:21:33,280
but it's impossible so there is not it's

547
00:21:33,280 --> 00:21:34,880
not really a solution

548
00:21:34,880 --> 00:21:37,679
um i contacted j2 about this

549
00:21:37,679 --> 00:21:40,400
vulnerability and in their point of view

550
00:21:40,400 --> 00:21:42,720
it's not a vulnerability and

551
00:21:42,720 --> 00:21:45,600
sometimes the idea behind that is okay

552
00:21:45,600 --> 00:21:48,720
we use the os module but if you can do

553
00:21:48,720 --> 00:21:50,960
what i did in the slides like in

554
00:21:50,960 --> 00:21:53,360
introspecting to python and escape from

555
00:21:53,360 --> 00:21:55,760
templates the vulnerability is not in

556
00:21:55,760 --> 00:21:58,720
using the os module is before that

557
00:21:58,720 --> 00:21:59,520
so

558
00:21:59,520 --> 00:22:01,679
in a way it's complicated not to use it

559
00:22:01,679 --> 00:22:04,080
but it's not the the real problem here

560
00:22:04,080 --> 00:22:06,080
uh uh albert um

561
00:22:06,080 --> 00:22:06,880
uh

562
00:22:06,880 --> 00:22:08,960
do you know any uh

563
00:22:08,960 --> 00:22:12,240
exploits uh that would be using uh these

564
00:22:12,240 --> 00:22:16,080
issues against um uh jungle or flask um

565
00:22:16,080 --> 00:22:17,120
and i think

566
00:22:17,120 --> 00:22:19,520
the the reviewer was asking the question

567
00:22:19,520 --> 00:22:22,640
because she's using ctfd a lot and ctfv

568
00:22:22,640 --> 00:22:26,400
is using flats yeah

569
00:22:26,400 --> 00:22:28,799
yeah but the ctfd is

570
00:22:28,799 --> 00:22:31,600
really known it's a cf platform and it's

571
00:22:31,600 --> 00:22:34,080
been really tested by many people

572
00:22:34,080 --> 00:22:37,440
including inside the ctfs so

573
00:22:37,440 --> 00:22:39,679
there is no non-vulnerability

574
00:22:39,679 --> 00:22:40,880
in this

575
00:22:40,880 --> 00:22:42,320
but

576
00:22:42,320 --> 00:22:43,600
the server side template injection

577
00:22:43,600 --> 00:22:47,120
venarity always occurs when someone

578
00:22:47,120 --> 00:22:49,520
writes bad code which mixes format

579
00:22:49,520 --> 00:22:50,559
string

580
00:22:50,559 --> 00:22:52,880
string replace and

581
00:22:52,880 --> 00:22:56,080
template and giants so in ctfd it's

582
00:22:56,080 --> 00:22:59,039
really audited so it should not have

583
00:22:59,039 --> 00:23:00,799
this kind of vulnerabilities but it's

584
00:23:00,799 --> 00:23:03,600
not impossible

585
00:23:04,000 --> 00:23:07,640
okay thank you

586
00:23:12,640 --> 00:23:15,640
um

587
00:23:33,039 --> 00:23:35,039
not really because you would have to

588
00:23:35,039 --> 00:23:37,840
modify the os module which is built into

589
00:23:37,840 --> 00:23:40,559
python so we cannot deactivate it

590
00:23:40,559 --> 00:23:43,120
and we cannot

591
00:23:43,120 --> 00:23:44,000
prevent

592
00:23:44,000 --> 00:23:46,559
code execution from from this

593
00:23:46,559 --> 00:23:48,720
but inside the newer version of python

594
00:23:48,720 --> 00:23:51,360
you can restrict uh some functions you

595
00:23:51,360 --> 00:23:53,840
can it's something called audit aux

596
00:23:53,840 --> 00:23:56,000
which can prevent

597
00:23:56,000 --> 00:23:57,360
part of this

598
00:23:57,360 --> 00:23:59,440
you can use it to prevent code execution

599
00:23:59,440 --> 00:24:01,279
in certain ways

600
00:24:01,279 --> 00:24:02,880
but it's not really

601
00:24:02,880 --> 00:24:05,760
it's kind of new

602
00:24:05,760 --> 00:24:09,279
okay are there any other questions

603
00:24:10,159 --> 00:24:11,039
no

604
00:24:11,039 --> 00:24:13,360
thank you remy

605
00:24:13,360 --> 00:24:15,180
thank you

606
00:24:15,180 --> 00:24:18,319
[Music]

