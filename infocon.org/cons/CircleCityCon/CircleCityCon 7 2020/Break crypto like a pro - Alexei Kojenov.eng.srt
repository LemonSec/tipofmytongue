1
00:00:06,100 --> 00:00:11,239
welcome back everyone to Circle City

2
00:00:08,570 --> 00:00:13,459
contract three please welcome Alexi

3
00:00:11,240 --> 00:00:18,440
Cochin off with the talk break crypto

4
00:00:13,459 --> 00:00:22,130
like a pro thank you hi everyone and

5
00:00:18,440 --> 00:00:22,810
welcome to this talk so let's just move

6
00:00:22,130 --> 00:00:25,369
on

7
00:00:22,810 --> 00:00:27,560
well back in January if you followed

8
00:00:25,370 --> 00:00:30,920
cryptic news or even more like security

9
00:00:27,560 --> 00:00:32,839
news you could not miss this huge

10
00:00:30,920 --> 00:00:38,450
vulnerability that was discovered in

11
00:00:32,840 --> 00:00:40,070
Microsoft it was I'm hearing a little

12
00:00:38,450 --> 00:00:45,020
bit of static I don't know if it's on my

13
00:00:40,070 --> 00:00:48,940
side or anyway I hope you guys can hear

14
00:00:45,020 --> 00:00:52,489
it okay it's gone cool thanks alright so

15
00:00:48,940 --> 00:00:55,129
this this uh this big vulnerability was

16
00:00:52,489 --> 00:00:58,160
in a cryptographic library in Windows

17
00:00:55,130 --> 00:01:01,010
and that was that code was used to

18
00:00:58,160 --> 00:01:05,569
verify things like digital certificates

19
00:01:01,010 --> 00:01:09,789
the to validate code that was pushed for

20
00:01:05,569 --> 00:01:12,679
updates or that you could install and

21
00:01:09,789 --> 00:01:16,490
the consequences of this would be pretty

22
00:01:12,679 --> 00:01:17,840
dramatic if this was exploited and at

23
00:01:16,490 --> 00:01:20,708
this point I don't know if this was

24
00:01:17,840 --> 00:01:23,779
exploited in the world or not but the

25
00:01:20,709 --> 00:01:26,630
the issue was pretty huge and I wanted

26
00:01:23,779 --> 00:01:29,539
to point out that the problem with this

27
00:01:26,630 --> 00:01:32,539
particular bug was not that it was an

28
00:01:29,539 --> 00:01:37,549
issue with any particular cryptographic

29
00:01:32,539 --> 00:01:40,429
scheme or algorithm Microsoft used like

30
00:01:37,549 --> 00:01:42,799
the the correct algorithm they did

31
00:01:40,429 --> 00:01:46,490
pretty much everything right they just

32
00:01:42,799 --> 00:01:49,090
made a couple of little mistakes and

33
00:01:46,490 --> 00:01:52,548
they cut in their code and even though

34
00:01:49,090 --> 00:01:54,919
like I would say they they had all the

35
00:01:52,549 --> 00:01:58,700
check boxes checked like is this their

36
00:01:54,919 --> 00:02:00,529
the so-and-so algorithm yes Jarek are

37
00:01:58,700 --> 00:02:02,509
using the correct parameters Czechia and

38
00:02:00,529 --> 00:02:07,929
everything they've certified whatever

39
00:02:02,509 --> 00:02:11,530
right the there was still an issue and

40
00:02:07,929 --> 00:02:15,209
your cryptographic scheme is not just

41
00:02:11,530 --> 00:02:20,700
your algorithm it's not just

42
00:02:15,209 --> 00:02:23,640
whether you using the correct library or

43
00:02:20,700 --> 00:02:26,429
whatever it's the entire thing if

44
00:02:23,640 --> 00:02:28,798
something is broken there your entire

45
00:02:26,430 --> 00:02:32,340
cryptographic scheme is broken and that

46
00:02:28,799 --> 00:02:34,469
was the case here so you you can still

47
00:02:32,340 --> 00:02:38,219
make I mean there's a there was a lot of

48
00:02:34,469 --> 00:02:42,239
room for mistakes and even very smart

49
00:02:38,219 --> 00:02:45,239
guys at Microsoft did it so okay why

50
00:02:42,239 --> 00:02:46,859
they stuck why did I bring that up we

51
00:02:45,239 --> 00:02:50,120
all understand the cryptography is hard

52
00:02:46,859 --> 00:02:52,470
I hope you can all agree on that and

53
00:02:50,120 --> 00:02:56,220
mistakes are bad right the coding

54
00:02:52,470 --> 00:02:58,290
mistakes are not fun and especially if

55
00:02:56,220 --> 00:03:01,169
those mistakes lead to some kind of

56
00:02:58,290 --> 00:03:03,540
security issues we as security

57
00:03:01,169 --> 00:03:05,609
professionals know that there these

58
00:03:03,540 --> 00:03:09,269
things are especially really really bad

59
00:03:05,609 --> 00:03:10,379
so let's just agree on that so today

60
00:03:09,269 --> 00:03:13,530
we're gonna be talking about how to

61
00:03:10,379 --> 00:03:16,290
exploit some of these mistakes we're not

62
00:03:13,530 --> 00:03:18,269
gonna talk about any zero days I'm not

63
00:03:16,290 --> 00:03:25,220
giving you any like new and juicy stuff

64
00:03:18,269 --> 00:03:30,030
this is all pretty like known but yeah

65
00:03:25,220 --> 00:03:33,060
there will be no complex math that's

66
00:03:30,030 --> 00:03:35,030
really not my intent today we definitely

67
00:03:33,060 --> 00:03:38,879
not gonna talk about any quantum stuff

68
00:03:35,030 --> 00:03:40,979
this is not the that talk and we're not

69
00:03:38,879 --> 00:03:43,638
gonna discuss how to brake correctly

70
00:03:40,979 --> 00:03:45,629
implemented crypto because by definition

71
00:03:43,639 --> 00:03:48,780
currently implemented crypto is

72
00:03:45,629 --> 00:03:54,929
unbreakable today might be breakable

73
00:03:48,780 --> 00:03:58,379
tomorrow but today it's good so I am

74
00:03:54,930 --> 00:04:00,719
after developer and in the past I spent

75
00:03:58,379 --> 00:04:03,179
over a decade writing code and then I

76
00:04:00,719 --> 00:04:06,239
decided to switch gears now I'm in

77
00:04:03,180 --> 00:04:09,500
security mostly breaking things and

78
00:04:06,239 --> 00:04:11,879
helping people fix them

79
00:04:09,500 --> 00:04:14,819
well I have a couple of security

80
00:04:11,879 --> 00:04:16,529
certifications but this is the thing

81
00:04:14,819 --> 00:04:19,289
that I wanted to highlight I am NOT a

82
00:04:16,529 --> 00:04:21,958
cryptographer so I'm pretty sure that

83
00:04:19,289 --> 00:04:23,969
there are people here in this virtual

84
00:04:21,959 --> 00:04:26,880
room that who know more about

85
00:04:23,970 --> 00:04:30,000
cryptography than I do and and that's

86
00:04:26,880 --> 00:04:33,539
fine I I do not pretend that I know

87
00:04:30,000 --> 00:04:36,300
everything here and I'm coming to this

88
00:04:33,539 --> 00:04:39,030
particular topic from strictly practical

89
00:04:36,300 --> 00:04:42,150
perspective as as the hacker as a

90
00:04:39,030 --> 00:04:45,929
security professional what can I do to

91
00:04:42,150 --> 00:04:50,789
demonstrate a vulnerability and what

92
00:04:45,930 --> 00:04:53,759
issues should I be looking for - like if

93
00:04:50,789 --> 00:04:57,060
I'm looking at the code are there any

94
00:04:53,759 --> 00:05:00,180
things that that might developers need

95
00:04:57,060 --> 00:05:03,659
to fix and if I'm a developer right how

96
00:05:00,180 --> 00:05:07,139
do I do everything right so just general

97
00:05:03,659 --> 00:05:09,810
recommendations we all need to use

98
00:05:07,139 --> 00:05:13,020
well-known and secure algorithms right

99
00:05:09,810 --> 00:05:18,139
we no longer use md5 we no longer use

100
00:05:13,020 --> 00:05:21,690
DES and there is a reason for that now

101
00:05:18,139 --> 00:05:24,419
okay we pick the right algorithm but now

102
00:05:21,690 --> 00:05:27,419
we gotta pick the correct while good

103
00:05:24,419 --> 00:05:30,539
library like meaning a good

104
00:05:27,419 --> 00:05:33,299
implementation of this algorithm so

105
00:05:30,539 --> 00:05:37,530
don't we don't just download some

106
00:05:33,300 --> 00:05:39,409
obscure code and run it we we want to

107
00:05:37,530 --> 00:05:43,859
use some kind of library that's

108
00:05:39,409 --> 00:05:46,590
well-maintained that that does not have

109
00:05:43,860 --> 00:05:48,139
known issues and and so on and we

110
00:05:46,590 --> 00:05:52,219
definitely don't write our own

111
00:05:48,139 --> 00:05:55,080
implementation of cryptography for

112
00:05:52,220 --> 00:05:57,780
production I mean you can write it for

113
00:05:55,080 --> 00:06:00,539
fun for for studying that's that's

114
00:05:57,780 --> 00:06:03,059
awesome but I would not run my own code

115
00:06:00,539 --> 00:06:05,880
in production

116
00:06:03,060 --> 00:06:07,320
now the the next thing that's important

117
00:06:05,880 --> 00:06:09,540
to highlight is we need to follow the

118
00:06:07,320 --> 00:06:13,170
best practices so if somebody is telling

119
00:06:09,540 --> 00:06:15,000
you that you need to use a good random

120
00:06:13,170 --> 00:06:19,890
number generator or you need to use

121
00:06:15,000 --> 00:06:21,060
random IV for aes-256 algorithm there's

122
00:06:19,890 --> 00:06:23,669
probably a reason for that

123
00:06:21,060 --> 00:06:28,050
so all these best practices and

124
00:06:23,670 --> 00:06:30,950
guidelines are other because if we do

125
00:06:28,050 --> 00:06:34,440
not follow them we open ourselves to

126
00:06:30,950 --> 00:06:36,030
potential problems and I've already said

127
00:06:34,440 --> 00:06:39,870
that we don't invent our own crypto

128
00:06:36,030 --> 00:06:45,239
right and you you might have heard it

129
00:06:39,870 --> 00:06:47,160
before it's all day repeating ok

130
00:06:45,240 --> 00:06:52,020
in terms of common mistakes in

131
00:06:47,160 --> 00:06:54,270
cryptography we can put them in in a few

132
00:06:52,020 --> 00:06:56,219
separate buckets so first one would be

133
00:06:54,270 --> 00:06:58,830
insufficient entropy meaning there is

134
00:06:56,220 --> 00:07:01,470
not enough friendliness and when there

135
00:06:58,830 --> 00:07:03,659
is not enough randomness things get

136
00:07:01,470 --> 00:07:07,850
predictable and in cryptography that's

137
00:07:03,660 --> 00:07:09,870
not a good thing when when we look at

138
00:07:07,850 --> 00:07:13,320
ciphertext meaning the encrypted code

139
00:07:09,870 --> 00:07:16,050
encrypted data it should all look it

140
00:07:13,320 --> 00:07:19,530
should all look like random data to us

141
00:07:16,050 --> 00:07:20,120
we should not see any patterns nothing

142
00:07:19,530 --> 00:07:23,760
like that

143
00:07:20,120 --> 00:07:25,560
because like I said if we start seeing

144
00:07:23,760 --> 00:07:27,409
patterns things get predictable and

145
00:07:25,560 --> 00:07:32,160
there is a potential for breaking

146
00:07:27,410 --> 00:07:34,530
something the second common mistake is

147
00:07:32,160 --> 00:07:36,930
algorithm choice so we don't use the

148
00:07:34,530 --> 00:07:38,489
correct algorithm for the purpose we use

149
00:07:36,930 --> 00:07:39,750
a chain saw where we need to use a

150
00:07:38,490 --> 00:07:42,570
hammer or vice versa

151
00:07:39,750 --> 00:07:45,300
so we need to understand what we trying

152
00:07:42,570 --> 00:07:48,510
to do and what would be the right

153
00:07:45,300 --> 00:07:49,950
algorithm the third one is ok we pick

154
00:07:48,510 --> 00:07:55,740
the right algorithm for the purpose and

155
00:07:49,950 --> 00:07:59,670
now we don't I mean we don't really look

156
00:07:55,740 --> 00:08:02,430
into how to do it right like ok what

157
00:07:59,670 --> 00:08:06,030
kind of key do we need for that AES 256

158
00:08:02,430 --> 00:08:08,370
algorithm where did we get it are there

159
00:08:06,030 --> 00:08:10,109
any other things that we need to tune in

160
00:08:08,370 --> 00:08:13,980
that algorithm specific to this

161
00:08:10,110 --> 00:08:16,360
algorithm so that's also important the

162
00:08:13,980 --> 00:08:20,189
fourth one is the message integral

163
00:08:16,360 --> 00:08:22,599
we often tend to focus on the

164
00:08:20,189 --> 00:08:26,349
confidentiality of things so we want to

165
00:08:22,599 --> 00:08:29,800
encrypt so nobody decrypts or you know

166
00:08:26,349 --> 00:08:33,519
we really care about keeping things

167
00:08:29,800 --> 00:08:37,479
secret but we tend to forget that if

168
00:08:33,519 --> 00:08:40,019
somebody can tamper with with our will

169
00:08:37,479 --> 00:08:44,500
be the message with the encrypted data

170
00:08:40,019 --> 00:08:47,470
that's not good either and that can lead

171
00:08:44,500 --> 00:08:49,209
to pretty bad things and the last but

172
00:08:47,470 --> 00:08:52,209
not least is a key management you can do

173
00:08:49,209 --> 00:08:54,279
everything else right but if you don't

174
00:08:52,209 --> 00:08:57,550
manage duties correctly and they get

175
00:08:54,279 --> 00:09:01,779
leaked your entire scheme is broken all

176
00:08:57,550 --> 00:09:05,050
right this is the math for today the

177
00:09:01,779 --> 00:09:08,260
we're only gonna talk about the single

178
00:09:05,050 --> 00:09:10,510
operation called exclusive or or XOR

179
00:09:08,260 --> 00:09:12,370
usually you should know this one right

180
00:09:10,510 --> 00:09:16,300
but I call it the ultimate crypto weapon

181
00:09:12,370 --> 00:09:18,459
and the reason I'm doing that is I'll

182
00:09:16,300 --> 00:09:23,019
show you why there will be a few demos

183
00:09:18,459 --> 00:09:27,579
today that will will show us how you can

184
00:09:23,019 --> 00:09:29,500
use XOR to break things in crypto there

185
00:09:27,579 --> 00:09:34,959
are a few properties of this particular

186
00:09:29,500 --> 00:09:36,970
operation first one is anything XOR 0 is

187
00:09:34,959 --> 00:09:41,459
the same thing so 0 does not change

188
00:09:36,970 --> 00:09:43,839
things if you XOR something with itself

189
00:09:41,459 --> 00:09:48,640
you'll get zero so basically it just

190
00:09:43,839 --> 00:09:53,019
cancels itself out and then a X or B if

191
00:09:48,640 --> 00:09:56,410
a X or B equals C then X or C equals B

192
00:09:53,019 --> 00:09:59,890
and B X or C equals a so basically you

193
00:09:56,410 --> 00:10:03,880
can move these these values to either

194
00:09:59,890 --> 00:10:06,779
side of the equal equal sign and

195
00:10:03,880 --> 00:10:10,170
everything will be true and that's

196
00:10:06,779 --> 00:10:13,149
that's a cool thing about XOR operation

197
00:10:10,170 --> 00:10:18,069
all right the next thing that I wanted

198
00:10:13,149 --> 00:10:19,750
to discuss is the randomness like I said

199
00:10:18,070 --> 00:10:28,750
it's very important in cryptography and

200
00:10:19,750 --> 00:10:29,600
we have two big well - two major types

201
00:10:28,750 --> 00:10:33,170
of

202
00:10:29,600 --> 00:10:38,060
random number generators oranges true

203
00:10:33,170 --> 00:10:40,270
random number generator is is is a

204
00:10:38,060 --> 00:10:45,229
generator that's usually hardware based

205
00:10:40,270 --> 00:10:48,500
it gets the entropy from from the

206
00:10:45,230 --> 00:10:52,240
environment maybe if fluctuations in

207
00:10:48,500 --> 00:10:56,090
temperature or electricity or ambient

208
00:10:52,240 --> 00:10:57,940
noise or whatever the these random

209
00:10:56,090 --> 00:11:00,200
number generators are I'm the

210
00:10:57,940 --> 00:11:02,360
non-deterministic and completely

211
00:11:00,200 --> 00:11:07,730
unpredictable so you cannot you cannot

212
00:11:02,360 --> 00:11:11,840
guess with high probability what like

213
00:11:07,730 --> 00:11:14,060
what the next generators value will be

214
00:11:11,840 --> 00:11:19,520
is gonna be zero or one

215
00:11:14,060 --> 00:11:22,310
well no idea the problem with two random

216
00:11:19,520 --> 00:11:27,710
number generators is they are not fast

217
00:11:22,310 --> 00:11:29,959
they pretty slow so we have another kind

218
00:11:27,710 --> 00:11:32,270
of random number generator is called

219
00:11:29,960 --> 00:11:35,540
pseudo-random these are deterministic

220
00:11:32,270 --> 00:11:38,090
and steel based basically still around

221
00:11:35,540 --> 00:11:41,530
generator is an algorithm you and you

222
00:11:38,090 --> 00:11:46,270
see it with with a number with a value

223
00:11:41,530 --> 00:11:50,120
added and it generates a stream of of

224
00:11:46,270 --> 00:11:52,100
bits and bytes that looks like random

225
00:11:50,120 --> 00:11:56,270
but it's completely dependent on that

226
00:11:52,100 --> 00:11:58,040
initial seed so if you and it's

227
00:11:56,270 --> 00:11:59,840
repeatable so if you give it this same

228
00:11:58,040 --> 00:12:04,089
seed again it's gonna generate the same

229
00:11:59,840 --> 00:12:06,770
see the random stream well you might say

230
00:12:04,090 --> 00:12:09,320
this is not really good but that's

231
00:12:06,770 --> 00:12:13,670
actually in most cases that's sufficient

232
00:12:09,320 --> 00:12:17,180
for for the purpose and a lot of times

233
00:12:13,670 --> 00:12:19,670
we see a combination of both things

234
00:12:17,180 --> 00:12:21,739
being used first we get we use true

235
00:12:19,670 --> 00:12:23,060
random number generator to get that seed

236
00:12:21,740 --> 00:12:25,310
and then we see the pseudo-random

237
00:12:23,060 --> 00:12:27,109
generator with that with that true

238
00:12:25,310 --> 00:12:33,770
random number and then we get a

239
00:12:27,110 --> 00:12:38,780
pseudo-random stream alright and with

240
00:12:33,770 --> 00:12:43,449
that let's talk about mistakes five

241
00:12:38,780 --> 00:12:45,640
years ago some people decided to write a

242
00:12:43,450 --> 00:12:51,820
ransomware a Trojan for Linux at that

243
00:12:45,640 --> 00:12:54,580
time the ransomware was already like

244
00:12:51,820 --> 00:12:57,010
very popular but it was mostly targeting

245
00:12:54,580 --> 00:12:59,650
Windows platforms so some people decided

246
00:12:57,010 --> 00:13:03,790
well Linux runs the Internet so why

247
00:12:59,650 --> 00:13:08,560
don't we just ransom where that platform

248
00:13:03,790 --> 00:13:12,160
and and get rich but well they made a

249
00:13:08,560 --> 00:13:14,949
mistake and they the first version of

250
00:13:12,160 --> 00:13:18,069
this malware completely failed because

251
00:13:14,950 --> 00:13:21,100
it used predictable encryption keys to

252
00:13:18,070 --> 00:13:30,840
encrypt the data and anybody could

253
00:13:21,100 --> 00:13:34,090
decrypt them without pay no ransom so

254
00:13:30,840 --> 00:13:38,440
let's take a look at how that can be

255
00:13:34,090 --> 00:13:40,600
done here's a simple code by the way all

256
00:13:38,440 --> 00:13:41,830
the code is on github and at the end of

257
00:13:40,600 --> 00:13:43,540
this presentation I'm gonna give you a

258
00:13:41,830 --> 00:13:46,660
link and you'll be able to download it

259
00:13:43,540 --> 00:13:50,500
play with it modify it if you want and

260
00:13:46,660 --> 00:13:52,870
just just study but it's all it's all

261
00:13:50,500 --> 00:13:56,500
pretty basic all pretty simple so this

262
00:13:52,870 --> 00:14:01,500
code generates a random key right and

263
00:13:56,500 --> 00:14:07,090
then it opens the file encrypts it and

264
00:14:01,500 --> 00:14:08,830
demands to pay the ransom but yeah

265
00:14:07,090 --> 00:14:10,930
that's pretty much it and the key is not

266
00:14:08,830 --> 00:14:17,170
really stored anywhere it's thrown away

267
00:14:10,930 --> 00:14:20,969
so but the thing to note here is we see

268
00:14:17,170 --> 00:14:26,439
that random number generator with the

269
00:14:20,970 --> 00:14:34,270
current timestamp all right that might

270
00:14:26,440 --> 00:14:39,790
be okay but if you run it we have just

271
00:14:34,270 --> 00:14:44,770
encrypted file and the encrypted version

272
00:14:39,790 --> 00:14:46,569
is completely like binary data no way to

273
00:14:44,770 --> 00:14:51,100
understand what's going on the the

274
00:14:46,570 --> 00:14:53,740
original file was was text here it is

275
00:14:51,100 --> 00:14:55,140
the text says not all random functions

276
00:14:53,740 --> 00:14:57,490
were created equal

277
00:14:55,140 --> 00:15:01,620
okay and like I said the keys

278
00:14:57,490 --> 00:15:04,149
stored anywhere but we know that this

279
00:15:01,620 --> 00:15:07,270
the encryption was using the current

280
00:15:04,149 --> 00:15:11,529
time so to decrypt we just need to get

281
00:15:07,270 --> 00:15:14,319
the this file modification times to temp

282
00:15:11,529 --> 00:15:16,689
and see the random number generator and

283
00:15:14,320 --> 00:15:26,800
we'll get the same exact key to decrypt

284
00:15:16,690 --> 00:15:30,339
it let's see if that works yeah and I

285
00:15:26,800 --> 00:15:34,260
did it successfully decrypted the file

286
00:15:30,339 --> 00:15:37,330
and printed the the original data here

287
00:15:34,260 --> 00:15:39,339
cool that was really really simple but

288
00:15:37,330 --> 00:15:43,660
you know like I said people make these

289
00:15:39,339 --> 00:15:46,120
mistakes and in this case those

290
00:15:43,660 --> 00:15:48,219
ransomware guys did it yeah so a

291
00:15:46,120 --> 00:15:51,040
reminder to everyone you cannot just use

292
00:15:48,220 --> 00:15:55,300
time to seed your pseudo-random function

293
00:15:51,040 --> 00:15:58,689
you need to use md5 of timestamp well of

294
00:15:55,300 --> 00:16:03,520
course this is a joke don't do it it's a

295
00:15:58,690 --> 00:16:05,470
really bad advice all right let's move

296
00:16:03,520 --> 00:16:11,760
on okay

297
00:16:05,470 --> 00:16:15,010
let's talk about encryption algorithms a

298
00:16:11,760 --> 00:16:17,529
very simple but very very secure

299
00:16:15,010 --> 00:16:21,339
algorithm one of them is called one-time

300
00:16:17,529 --> 00:16:24,010
pad let's say we have a message that we

301
00:16:21,339 --> 00:16:27,279
want to encrypt and we have a key so our

302
00:16:24,010 --> 00:16:29,860
encryption is actually a simple XOR

303
00:16:27,279 --> 00:16:32,200
operation we just XOR that message with

304
00:16:29,860 --> 00:16:35,020
the key and I said that's our ciphertext

305
00:16:32,200 --> 00:16:38,170
and decryption is the opposite when we

306
00:16:35,020 --> 00:16:40,779
and when we XOR the ciphertext

307
00:16:38,170 --> 00:16:42,399
with the key again you'll get the

308
00:16:40,779 --> 00:16:46,420
original message back due to the

309
00:16:42,399 --> 00:16:51,970
properties of the XOR operation and here

310
00:16:46,420 --> 00:16:55,089
is an example well all right now one

311
00:16:51,970 --> 00:16:57,880
obvious problem here is that your key

312
00:16:55,089 --> 00:17:00,370
has to be as long as your message so if

313
00:16:57,880 --> 00:17:02,470
the message here is seven bits your key

314
00:17:00,370 --> 00:17:04,300
has to be seven bits if your message is

315
00:17:02,470 --> 00:17:05,770
one gigabyte your key has to be one

316
00:17:04,300 --> 00:17:09,180
gigabyte so it's very very impractical

317
00:17:05,770 --> 00:17:14,599
one-time pad is not I mean

318
00:17:09,180 --> 00:17:14,600
the key management it is a nightmare

319
00:17:15,680 --> 00:17:22,260
the other issue with this algorithm is

320
00:17:19,140 --> 00:17:26,430
in the name it's called one time for a

321
00:17:22,260 --> 00:17:29,910
reason and it means that you should not

322
00:17:26,430 --> 00:17:32,040
reuse the keys so let's see what happens

323
00:17:29,910 --> 00:17:35,550
when you reuse the keys let's say you

324
00:17:32,040 --> 00:17:39,389
have a message one and you encrypt it

325
00:17:35,550 --> 00:17:41,309
with with that with the key and have

326
00:17:39,390 --> 00:17:43,770
message two and you encrypt it through

327
00:17:41,309 --> 00:17:48,210
the same key and by encryption I mean

328
00:17:43,770 --> 00:17:53,550
you just XOR right now if we like okay

329
00:17:48,210 --> 00:17:56,940
we have two cipher texts but if we XOR

330
00:17:53,550 --> 00:18:00,540
these two cipher texts this will expand

331
00:17:56,940 --> 00:18:04,380
to to this expression and the key will

332
00:18:00,540 --> 00:18:08,520
cancel itself out and as a result we get

333
00:18:04,380 --> 00:18:10,980
an XOR of the original messages so the

334
00:18:08,520 --> 00:18:13,170
XOR of cipher text is the same as XOR of

335
00:18:10,980 --> 00:18:16,580
original messages and you can guess that

336
00:18:13,170 --> 00:18:21,000
this is not good you know like I said

337
00:18:16,580 --> 00:18:23,250
when you can derive some some

338
00:18:21,000 --> 00:18:26,010
predictable results from calligraphy

339
00:18:23,250 --> 00:18:30,090
then things can go really bad all right

340
00:18:26,010 --> 00:18:32,580
you might ask so what we still don't see

341
00:18:30,090 --> 00:18:35,010
the original message here but we get the

342
00:18:32,580 --> 00:18:38,699
XOR and in many cases that would be

343
00:18:35,010 --> 00:18:43,440
enough to either break things completely

344
00:18:38,700 --> 00:18:46,800
or get some really good guesses about

345
00:18:43,440 --> 00:18:49,400
the original message so do not reuse the

346
00:18:46,800 --> 00:18:53,700
keys okay

347
00:18:49,400 --> 00:18:56,340
stream cipher is otherwise called more

348
00:18:53,700 --> 00:18:59,940
practical one-time pad because it is by

349
00:18:56,340 --> 00:19:02,399
based on one-time pad but stream cipher

350
00:18:59,940 --> 00:19:07,440
is using a different kind of key so

351
00:19:02,400 --> 00:19:10,740
instead of this huge long key of the

352
00:19:07,440 --> 00:19:14,160
same length as the data we use a finite

353
00:19:10,740 --> 00:19:17,010
key and we use a generator function to

354
00:19:14,160 --> 00:19:20,280
generate a key stream so the original

355
00:19:17,010 --> 00:19:23,020
key might be let's say maybe 16 bytes

356
00:19:20,280 --> 00:19:25,540
and then we basically see

357
00:19:23,020 --> 00:19:29,520
that generator function and it will

358
00:19:25,540 --> 00:19:34,030
generate us an infinite stream of

359
00:19:29,520 --> 00:19:36,790
pseudo-random bits that we can just use

360
00:19:34,030 --> 00:19:38,889
in the stream cipher so the encryption

361
00:19:36,790 --> 00:19:42,190
is the same as a one-time pad we just

362
00:19:38,890 --> 00:19:46,240
XOR the message with that key stream and

363
00:19:42,190 --> 00:19:50,230
the decryption is the same operation but

364
00:19:46,240 --> 00:19:53,050
again do not reuse keys here because if

365
00:19:50,230 --> 00:19:57,570
you give the same key to this generator

366
00:19:53,050 --> 00:20:03,060
you'll get the same exact pseudo-random

367
00:19:57,570 --> 00:20:07,060
byte stream bitstream whatever and yeah

368
00:20:03,060 --> 00:20:12,610
that's not good okay so let's see in

369
00:20:07,060 --> 00:20:14,800
practice how we can break and the this

370
00:20:12,610 --> 00:20:17,399
this scheme and decrypt the message

371
00:20:14,800 --> 00:20:17,399
without the key

372
00:20:17,760 --> 00:20:29,200
all right I have two pictures here one

373
00:20:26,470 --> 00:20:31,510
is a picture of myself and the other is

374
00:20:29,200 --> 00:20:36,190
a picture of this black and white smiley

375
00:20:31,510 --> 00:20:38,890
face and I'm going to encrypt all both

376
00:20:36,190 --> 00:20:46,060
of these pictures using my special

377
00:20:38,890 --> 00:20:48,070
encrypter encrypt image what is doing

378
00:20:46,060 --> 00:20:51,070
you know I'm keying a little bit here so

379
00:20:48,070 --> 00:20:55,210
I'm not encrypting thief like the file

380
00:20:51,070 --> 00:20:59,710
itself I encrypt pixel by pixel to give

381
00:20:55,210 --> 00:21:03,850
it more so it's more visual for us right

382
00:20:59,710 --> 00:21:06,490
so I encrypt those pixels and I get you

383
00:21:03,850 --> 00:21:11,439
know these random noise pixels this is

384
00:21:06,490 --> 00:21:14,110
the result of of encrypting my picture

385
00:21:11,440 --> 00:21:16,090
and this is the result of encryption

386
00:21:14,110 --> 00:21:20,760
that smiley face picture both look

387
00:21:16,090 --> 00:21:23,169
really random right

388
00:21:20,760 --> 00:21:26,860
but I'm encryption with the same key and

389
00:21:23,170 --> 00:21:30,370
in this case I'm using if I remember

390
00:21:26,860 --> 00:21:32,919
correctly yeah here it is I'm using rc4

391
00:21:30,370 --> 00:21:36,949
algorithm which by the way is no longer

392
00:21:32,920 --> 00:21:41,310
secure but I'm using this here just for

393
00:21:36,950 --> 00:21:46,620
demonstration the idea is the same okay

394
00:21:41,310 --> 00:21:50,389
now well we have these two encrypted

395
00:21:46,620 --> 00:21:57,719
images can we do something with them

396
00:21:50,390 --> 00:22:12,450
well let's fire up a graphics editor mmm

397
00:21:57,720 --> 00:22:21,720
okay cool and and open both images in

398
00:22:12,450 --> 00:22:24,810
that text in the graphics editor so here

399
00:22:21,720 --> 00:22:28,910
is the so I have two layers in this

400
00:22:24,810 --> 00:22:31,649
image the first layer is the encrypted

401
00:22:28,910 --> 00:22:34,460
image of me the second layer is

402
00:22:31,650 --> 00:22:37,740
encrypted image of the smiley face well

403
00:22:34,460 --> 00:22:40,020
both random again but this particular

404
00:22:37,740 --> 00:22:47,820
editor allows me to perform layer

405
00:22:40,020 --> 00:22:53,010
operations and one of them is X or you

406
00:22:47,820 --> 00:22:59,040
can see it well or not but here X or I'm

407
00:22:53,010 --> 00:23:03,420
not fine now let's see what happens if I

408
00:22:59,040 --> 00:23:06,480
do X or boom immediately we can

409
00:23:03,420 --> 00:23:10,760
recognize both of the original messages

410
00:23:06,480 --> 00:23:14,640
we can we can see that one of one of the

411
00:23:10,760 --> 00:23:16,920
one of the original data was a picture

412
00:23:14,640 --> 00:23:19,800
of a human and the other regional data

413
00:23:16,920 --> 00:23:23,180
was this smiley face whatever right

414
00:23:19,800 --> 00:23:25,680
so we with our image recognition

415
00:23:23,180 --> 00:23:28,170
capabilities can immediately decrypt

416
00:23:25,680 --> 00:23:31,410
both original messages in this case and

417
00:23:28,170 --> 00:23:36,000
that's just you know that's just a

418
00:23:31,410 --> 00:23:38,370
result of XOR operation now what if we

419
00:23:36,000 --> 00:23:40,260
like take to take it further what if we

420
00:23:38,370 --> 00:23:42,090
know one of the original messages what

421
00:23:40,260 --> 00:23:45,150
if you know that one of there was it was

422
00:23:42,090 --> 00:23:48,350
this smiley face now if we add that as

423
00:23:45,150 --> 00:23:48,350
another layer and

424
00:23:49,149 --> 00:23:55,748
apply XOR operation we get the other

425
00:23:52,839 --> 00:23:57,969
original message as is without any

426
00:23:55,749 --> 00:24:01,059
changes without any noise without

427
00:23:57,969 --> 00:24:04,089
anything so let's recap it again we have

428
00:24:01,059 --> 00:24:08,769
three layers here one is looks like

429
00:24:04,089 --> 00:24:12,099
random the other looks random but when

430
00:24:08,769 --> 00:24:15,549
we combine them all with a very simple

431
00:24:12,099 --> 00:24:25,718
XOR operation we get something really

432
00:24:15,549 --> 00:24:28,899
cool okay in addition to the stream

433
00:24:25,719 --> 00:24:31,690
ciphers we also have block ciphers so

434
00:24:28,899 --> 00:24:34,478
stream ciphers operate on bits you can

435
00:24:31,690 --> 00:24:39,159
encrypt bit by bit block ciphers operate

436
00:24:34,479 --> 00:24:43,509
on blocks and popular block size these

437
00:24:39,159 --> 00:24:46,659
days is 16 bytes but the and it can vary

438
00:24:43,509 --> 00:24:50,489
depending on on the algorithm but the

439
00:24:46,659 --> 00:24:53,799
block cipher is taking the entire block

440
00:24:50,489 --> 00:24:57,219
they stick in the key and then it does

441
00:24:53,799 --> 00:25:01,029
permutations and gives you the result

442
00:24:57,219 --> 00:25:03,989
which is the encrypted data again it

443
00:25:01,029 --> 00:25:09,119
means the whole block in order to work

444
00:25:03,989 --> 00:25:12,460
now your message is usually not 16 bytes

445
00:25:09,119 --> 00:25:14,949
it's usually longer you know some kind

446
00:25:12,460 --> 00:25:17,169
of a file some kind of data so what

447
00:25:14,950 --> 00:25:19,539
happens when we need to encrypt longer

448
00:25:17,169 --> 00:25:21,369
data well the most obvious and most

449
00:25:19,539 --> 00:25:24,639
straightforward way to do it is to

450
00:25:21,369 --> 00:25:26,769
encrypt each block separately and then

451
00:25:24,639 --> 00:25:29,199
combine the results so we encrypt the

452
00:25:26,769 --> 00:25:30,729
first block with a key second block with

453
00:25:29,200 --> 00:25:36,669
the same key third block with the same

454
00:25:30,729 --> 00:25:40,690
key and then we just have the result the

455
00:25:36,669 --> 00:25:44,379
problem here is if block 1 and block 3

456
00:25:40,690 --> 00:25:47,919
are the same in original message they'll

457
00:25:44,379 --> 00:25:50,109
be the same in the encrypted message so

458
00:25:47,919 --> 00:25:51,789
you'll see a pattern here and even

459
00:25:50,109 --> 00:25:55,859
though the data will be encrypted

460
00:25:51,789 --> 00:25:59,799
sometimes those patterns are enough to

461
00:25:55,859 --> 00:26:03,399
to break the encryption so let's see how

462
00:25:59,799 --> 00:26:07,180
we can see the plaintext in

463
00:26:03,400 --> 00:26:11,200
in the ciphertext and again I am using a

464
00:26:07,180 --> 00:26:15,340
visual example here here is a test image

465
00:26:11,200 --> 00:26:19,690
that's a snapshot of my title slide okay

466
00:26:15,340 --> 00:26:26,129
and I'm going to encrypt this image with

467
00:26:19,690 --> 00:26:28,150
my special encrypter and it didn't work

468
00:26:26,130 --> 00:26:31,110
that's very cool

469
00:26:28,150 --> 00:26:34,110
I have not seen this before Oh

470
00:26:31,110 --> 00:26:34,110
interesting

471
00:26:35,250 --> 00:26:43,870
okay and I'm sorry about that

472
00:26:39,280 --> 00:26:49,240
I should have prepared better I did not

473
00:26:43,870 --> 00:26:52,780
account for the block size okay all

474
00:26:49,240 --> 00:26:55,960
right let's give that example but the

475
00:26:52,780 --> 00:26:59,170
idea here is when we encrypt we'll be

476
00:26:55,960 --> 00:27:02,730
able to see the pattern in the encrypted

477
00:26:59,170 --> 00:27:11,350
image and we'll be able to recognize the

478
00:27:02,730 --> 00:27:15,880
the original message okay so the best a

479
00:27:11,350 --> 00:27:23,559
better way to do it is I use a different

480
00:27:15,880 --> 00:27:28,800
mode with the block cyphers so if we

481
00:27:23,559 --> 00:27:35,139
have these consecutive blocks of the

482
00:27:28,800 --> 00:27:37,720
plaintext message we can then use well

483
00:27:35,140 --> 00:27:41,410
how to say we can use basically use the

484
00:27:37,720 --> 00:27:43,360
previous block to seed the next block so

485
00:27:41,410 --> 00:27:47,850
like let's start with the last block

486
00:27:43,360 --> 00:27:51,850
here before we perform our encryption

487
00:27:47,850 --> 00:27:54,219
operation we XOR our plaintext block

488
00:27:51,850 --> 00:27:56,559
with the ciphertext from the previous

489
00:27:54,220 --> 00:27:59,950
operation and that will give us more

490
00:27:56,559 --> 00:28:02,020
randomness this will actually give us a

491
00:27:59,950 --> 00:28:05,020
lot of randomness and the result of our

492
00:28:02,020 --> 00:28:06,520
ciphertext even though this plaintext

493
00:28:05,020 --> 00:28:08,260
block was seen before it will be

494
00:28:06,520 --> 00:28:11,650
completely different from anything that

495
00:28:08,260 --> 00:28:13,120
we have seen before now what about the

496
00:28:11,650 --> 00:28:16,210
first block it did not have a previous

497
00:28:13,120 --> 00:28:17,260
one but we still need to restore it with

498
00:28:16,210 --> 00:28:18,700
something and

499
00:28:17,260 --> 00:28:25,570
that's how we introduce the

500
00:28:18,700 --> 00:28:29,470
initialization vector or IV IV is just a

501
00:28:25,570 --> 00:28:31,720
random block it's not a secret data it

502
00:28:29,470 --> 00:28:35,230
just has to be random each encryption

503
00:28:31,720 --> 00:28:38,230
operation you generate in you IV and you

504
00:28:35,230 --> 00:28:39,970
just store it with the data and like I

505
00:28:38,230 --> 00:28:46,620
said it does not have to be secret it

506
00:28:39,970 --> 00:28:54,640
just has to be random okay how does the

507
00:28:46,620 --> 00:28:57,489
CBC encryption decryption work so if we

508
00:28:54,640 --> 00:28:59,590
have the encrypted message the

509
00:28:57,490 --> 00:29:02,260
ciphertext consisting of three blocks

510
00:28:59,590 --> 00:29:04,510
then we will decrypt the first block and

511
00:29:02,260 --> 00:29:07,660
then we XOR it with this initialization

512
00:29:04,510 --> 00:29:11,379
vector the second block will decrypt and

513
00:29:07,660 --> 00:29:14,770
we'll explore it with the the first

514
00:29:11,380 --> 00:29:19,870
block cipher text and so on okay that's

515
00:29:14,770 --> 00:29:21,670
fine now some people think and that's

516
00:29:19,870 --> 00:29:24,010
that's that's a mistake that I want to

517
00:29:21,670 --> 00:29:27,940
talk about some people think ok I have

518
00:29:24,010 --> 00:29:32,770
the key that I know it is secret and I

519
00:29:27,940 --> 00:29:38,950
need this initialization vector and why

520
00:29:32,770 --> 00:29:40,720
can't I just use the key as IV that

521
00:29:38,950 --> 00:29:43,300
might seem like a good idea especially

522
00:29:40,720 --> 00:29:45,550
in like if you're dealing with legacy

523
00:29:43,300 --> 00:29:47,500
code that you're trying to change the

524
00:29:45,550 --> 00:29:50,320
encryption algorithm and you don't have

525
00:29:47,500 --> 00:29:54,190
a field you don't have a room to store

526
00:29:50,320 --> 00:29:56,740
the initialization vector so ok I'll

527
00:29:54,190 --> 00:29:58,420
just use the key it's random enough like

528
00:29:56,740 --> 00:30:01,180
from the attackers perspective they

529
00:29:58,420 --> 00:30:04,060
don't know my key is random um since

530
00:30:01,180 --> 00:30:05,740
both the sender and receiver know the

531
00:30:04,060 --> 00:30:08,409
key I don't have to store it with the

532
00:30:05,740 --> 00:30:11,560
data so it's not going to be leaked all

533
00:30:08,410 --> 00:30:15,820
right but it's actually not very good

534
00:30:11,560 --> 00:30:18,250
because let's see what happens when we

535
00:30:15,820 --> 00:30:21,490
decrypt this kind of message so again we

536
00:30:18,250 --> 00:30:27,920
have an encrypted message consisting of

537
00:30:21,490 --> 00:30:31,130
three blocks c1 c2 and c3 if an attacker

538
00:30:27,920 --> 00:30:34,490
can modify the encrypted message and

539
00:30:31,130 --> 00:30:39,590
give it to the Decrypter and get the

540
00:30:34,490 --> 00:30:43,040
result back something really unfortunate

541
00:30:39,590 --> 00:30:46,330
can happen so I as an attacker can build

542
00:30:43,040 --> 00:30:50,450
a new message I'll take the first cipher

543
00:30:46,330 --> 00:30:53,090
text block and just copy it for the

544
00:30:50,450 --> 00:30:56,420
second block I just used all zeroes all

545
00:30:53,090 --> 00:30:58,580
my 16 bytes are going to be zeros and

546
00:30:56,420 --> 00:31:02,000
you'll see why I'm doing that and for

547
00:30:58,580 --> 00:31:07,970
the third block I'm copying with the

548
00:31:02,000 --> 00:31:11,180
first block again okay why well let's

549
00:31:07,970 --> 00:31:16,490
see why when we decrypt this first block

550
00:31:11,180 --> 00:31:20,000
it will basically be an XOR operation of

551
00:31:16,490 --> 00:31:23,080
the decryption and the key because as we

552
00:31:20,000 --> 00:31:27,860
remember we have just used the key as IV

553
00:31:23,080 --> 00:31:31,070
right the second decryption we don't

554
00:31:27,860 --> 00:31:33,500
really care about but what what we care

555
00:31:31,070 --> 00:31:36,379
about is those zeros in the ciphertext

556
00:31:33,500 --> 00:31:39,380
so the result of the third block being

557
00:31:36,380 --> 00:31:42,980
decrypted would be that block decrypted

558
00:31:39,380 --> 00:31:46,190
XOR 0 which as we know 0 has no

559
00:31:42,980 --> 00:31:48,080
influence on the XOR operation so the

560
00:31:46,190 --> 00:31:50,720
first block decryption and the third

561
00:31:48,080 --> 00:31:53,179
block decryption you can already see

562
00:31:50,720 --> 00:31:54,080
that there is an issue if we XOR these

563
00:31:53,180 --> 00:31:58,130
two things

564
00:31:54,080 --> 00:32:01,399
we'll get the key so the key is actually

565
00:31:58,130 --> 00:32:05,300
leaked in this scheme under certain

566
00:32:01,400 --> 00:32:06,950
assumptions of course like I said as an

567
00:32:05,300 --> 00:32:08,750
attacker we can modify some things

568
00:32:06,950 --> 00:32:13,190
Decrypter will decrypt them and so on

569
00:32:08,750 --> 00:32:18,700
but we sometimes we use these

570
00:32:13,190 --> 00:32:23,210
assumptions in cryptography based on the

571
00:32:18,700 --> 00:32:25,670
based on the application that where the

572
00:32:23,210 --> 00:32:30,170
cryptography is used and so let's see

573
00:32:25,670 --> 00:32:36,010
one of such applications this time I

574
00:32:30,170 --> 00:32:36,010
need to find my browser here it is

575
00:32:38,210 --> 00:32:46,399
so this time I have a bribe application

576
00:32:42,889 --> 00:32:49,678
that that is using a session cooking

577
00:32:46,399 --> 00:32:52,500
first time I go into this application it

578
00:32:49,679 --> 00:32:55,409
gives me a session cookie of a guest and

579
00:32:52,500 --> 00:32:58,080
for convenience sake I'm printing the

580
00:32:55,409 --> 00:33:00,990
that session cookie right here on the

581
00:32:58,080 --> 00:33:05,699
web page but here is the actual value of

582
00:33:00,990 --> 00:33:08,370
it and it is encrypted so I as the user

583
00:33:05,700 --> 00:33:11,429
of this application don't know the key

584
00:33:08,370 --> 00:33:15,750
to encrypt or decrypt this session

585
00:33:11,429 --> 00:33:20,429
cookie but the application knows it if

586
00:33:15,750 --> 00:33:22,950
you look at the source code the the key

587
00:33:20,429 --> 00:33:26,269
is generated once it is stored in the

588
00:33:22,950 --> 00:33:29,129
file and is used for all the sessions

589
00:33:26,269 --> 00:33:33,779
and like I said we we have no idea of

590
00:33:29,129 --> 00:33:37,019
the keys but we know that we can modify

591
00:33:33,779 --> 00:33:39,120
this value right and we can give it back

592
00:33:37,019 --> 00:33:46,500
to the application and it will print the

593
00:33:39,120 --> 00:33:49,379
result here so here's our assumptions so

594
00:33:46,500 --> 00:33:52,169
first thing that we need to do is we

595
00:33:49,379 --> 00:33:54,689
need to forge a new cookie with those

596
00:33:52,169 --> 00:34:01,379
zeros in the middle and you see those a

597
00:33:54,690 --> 00:34:03,840
AAA these are zeros in base64 now when

598
00:34:01,379 --> 00:34:06,899
we give it to the application and

599
00:34:03,840 --> 00:34:10,259
refresh the page it struggled with it

600
00:34:06,899 --> 00:34:15,319
because the message is no longer valid

601
00:34:10,260 --> 00:34:19,649
it decrypted to some kind of junk but

602
00:34:15,319 --> 00:34:28,609
that's okay we need this here is these

603
00:34:19,649 --> 00:34:32,879
basic C 4 value that got decrypted now

604
00:34:28,609 --> 00:34:37,909
if I give it to my other script to

605
00:34:32,879 --> 00:34:42,179
analyze that result of the decryption it

606
00:34:37,909 --> 00:34:43,409
aide was able to derive that the

607
00:34:42,179 --> 00:34:48,960
encryption key itself

608
00:34:43,409 --> 00:34:49,980
it reads C 4 f 1 whatever now if I go

609
00:34:48,960 --> 00:34:55,010
and

610
00:34:49,980 --> 00:34:58,470
actually print that session key file

611
00:34:55,010 --> 00:35:00,090
where the web application is storing the

612
00:34:58,470 --> 00:35:03,149
session key you'll see that it will

613
00:35:00,090 --> 00:35:07,770
match exactly it's C 4 f 1e zero and B

614
00:35:03,150 --> 00:35:10,980
and so on so again just just by using

615
00:35:07,770 --> 00:35:13,250
this application seeing the result of

616
00:35:10,980 --> 00:35:16,350
decryption being able to modify

617
00:35:13,250 --> 00:35:20,720
encrypted data we were able to

618
00:35:16,350 --> 00:35:20,720
completely crack the encryption key

619
00:35:21,830 --> 00:35:29,910
alright another thing with the block

620
00:35:24,930 --> 00:35:32,100
ciphers is so-called padding as we

621
00:35:29,910 --> 00:35:35,700
discuss the block ciphers work on blocks

622
00:35:32,100 --> 00:35:38,940
and it expects like let's say if it's if

623
00:35:35,700 --> 00:35:44,279
it's AES algorithm it will expect 16

624
00:35:38,940 --> 00:35:46,440
bytes right but your your data is not

625
00:35:44,280 --> 00:35:49,170
necessarily the length of you that is

626
00:35:46,440 --> 00:35:52,710
not necessarily multiple of 16 bytes

627
00:35:49,170 --> 00:35:57,720
right it's not exactly 16 32 48 and so

628
00:35:52,710 --> 00:36:00,900
on here is a message of 10 bytes how can

629
00:35:57,720 --> 00:36:04,470
we deal with it the block cipher is not

630
00:36:00,900 --> 00:36:09,210
going to like it okay so what we do is

631
00:36:04,470 --> 00:36:14,580
we add the missing 6 bytes to get 16

632
00:36:09,210 --> 00:36:19,980
bytes and by convention we set each byte

633
00:36:14,580 --> 00:36:22,650
to 6 so the system knows that 6 bytes

634
00:36:19,980 --> 00:36:24,810
were missing and these this is just

635
00:36:22,650 --> 00:36:27,570
padding they all look the same and they

636
00:36:24,810 --> 00:36:30,779
can be thrown away when needed and

637
00:36:27,570 --> 00:36:37,080
that's cool the now the block cipher can

638
00:36:30,780 --> 00:36:41,460
encrypt this on decryption what happens

639
00:36:37,080 --> 00:36:43,020
is we need to check that padding we need

640
00:36:41,460 --> 00:36:45,840
to assume that the pattern is correct

641
00:36:43,020 --> 00:36:48,570
and if we see something wrong here like

642
00:36:45,840 --> 00:36:51,600
going back one slide if one of these

643
00:36:48,570 --> 00:36:55,350
bytes is not 6 or if it's something else

644
00:36:51,600 --> 00:36:57,660
then this is wrong padding by convention

645
00:36:55,350 --> 00:37:00,500
this is there's something wrong

646
00:36:57,660 --> 00:37:00,500
the data was crap

647
00:37:00,820 --> 00:37:09,640
so it will be an error condition and

648
00:37:06,210 --> 00:37:11,830
it's preferred to assume that we need

649
00:37:09,640 --> 00:37:13,600
some kind of error message so if padding

650
00:37:11,830 --> 00:37:14,620
was okay then we'll continue if it was

651
00:37:13,600 --> 00:37:17,740
not okay we'll print

652
00:37:14,620 --> 00:37:19,359
error message but the problem here is if

653
00:37:17,740 --> 00:37:22,390
we do that and let the user know that

654
00:37:19,360 --> 00:37:25,300
the padding wasn't correct it can lead

655
00:37:22,390 --> 00:37:28,890
to patent oracle attacks and the parent

656
00:37:25,300 --> 00:37:31,570
Oracle attacks were completely on like

657
00:37:28,890 --> 00:37:33,609
on the attacker bill being able to

658
00:37:31,570 --> 00:37:36,430
modify the message giving it to the

659
00:37:33,610 --> 00:37:37,660
Decrypter and then the decrypted letting

660
00:37:36,430 --> 00:37:39,520
the attacker know whether the padding

661
00:37:37,660 --> 00:37:42,700
was correct or not and there was no

662
00:37:39,520 --> 00:37:45,850
other information that that we can get

663
00:37:42,700 --> 00:37:49,330
from the Decrypter and that can

664
00:37:45,850 --> 00:37:53,049
completely break the scheme and retrieve

665
00:37:49,330 --> 00:38:00,880
the original message and I have a

666
00:37:53,050 --> 00:38:04,870
working version of padding Oracle and in

667
00:38:00,880 --> 00:38:10,260
a web application so here is our

668
00:38:04,870 --> 00:38:13,839
application this this web app has one

669
00:38:10,260 --> 00:38:19,000
endpoint with the parameter which is an

670
00:38:13,840 --> 00:38:21,300
encrypted message and we when we give

671
00:38:19,000 --> 00:38:25,360
that encrypted message to the app it

672
00:38:21,300 --> 00:38:27,400
tells me tells us that thank you I'll

673
00:38:25,360 --> 00:38:31,120
get back to you so whatever it might

674
00:38:27,400 --> 00:38:33,610
store it somewhere so here's an example

675
00:38:31,120 --> 00:38:35,319
of such encrypted message and the

676
00:38:33,610 --> 00:38:39,730
application just gave it to me I have no

677
00:38:35,320 --> 00:38:42,220
idea what it is right but if I modify

678
00:38:39,730 --> 00:38:46,240
one of the bytes here so let me modify

679
00:38:42,220 --> 00:38:49,750
the right the the last byte it was for

680
00:38:46,240 --> 00:38:52,959
I'm gonna set it to one and resend that

681
00:38:49,750 --> 00:38:55,180
message I get an error saying invalid

682
00:38:52,960 --> 00:38:56,710
message which suggests that the padding

683
00:38:55,180 --> 00:38:59,589
wasn't correct I have just modified that

684
00:38:56,710 --> 00:39:01,960
last byte and the probably last blog

685
00:38:59,590 --> 00:39:03,840
decrypted to some garbage the

686
00:39:01,960 --> 00:39:08,800
application was not able to deal with it

687
00:39:03,840 --> 00:39:11,110
okay again we just have this URL we have

688
00:39:08,800 --> 00:39:11,620
this encrypted message we have no idea

689
00:39:11,110 --> 00:39:14,730
what that is

690
00:39:11,620 --> 00:39:14,730
let's try to break it

691
00:39:17,230 --> 00:39:26,660
my exploit script just accepts that URL

692
00:39:21,860 --> 00:39:30,680
and analyzes it and tries that padding

693
00:39:26,660 --> 00:39:34,819
Oracle attack by modifying bit by bit

694
00:39:30,680 --> 00:39:37,220
and sending multiple requests to the

695
00:39:34,820 --> 00:39:39,500
server hundreds I don't know maybe

696
00:39:37,220 --> 00:39:41,120
thousands I never counted but let's see

697
00:39:39,500 --> 00:39:45,530
what happens so it sends those requests

698
00:39:41,120 --> 00:39:47,690
and if I look at the at the backend

699
00:39:45,530 --> 00:39:52,340
sorry define it's a little small but you

700
00:39:47,690 --> 00:39:55,160
can see it it in the web server log it

701
00:39:52,340 --> 00:39:57,110
received hundreds of requests and each

702
00:39:55,160 --> 00:40:00,040
one of them you know they look pretty

703
00:39:57,110 --> 00:40:02,870
similar pretty identical but there was

704
00:40:00,040 --> 00:40:05,960
one difference somewhere I want one bite

705
00:40:02,870 --> 00:40:08,210
of this message was different but let's

706
00:40:05,960 --> 00:40:13,310
see what happened we were able to

707
00:40:08,210 --> 00:40:15,470
completely decrypt the original message

708
00:40:13,310 --> 00:40:20,750
which reads pairing Oracle's a real

709
00:40:15,470 --> 00:40:22,520
let's look at our code the code the

710
00:40:20,750 --> 00:40:28,550
server code yep it encrypted this

711
00:40:22,520 --> 00:40:30,650
message and that's it

712
00:40:28,550 --> 00:40:36,170
I mean in a cryptic message gave it to

713
00:40:30,650 --> 00:40:38,810
us here is the the exception handling

714
00:40:36,170 --> 00:40:42,980
where the panning was incorrect as a

715
00:40:38,810 --> 00:40:45,230
matter of fact it just uses the generic

716
00:40:42,980 --> 00:40:46,550
exception we didn't like in this case we

717
00:40:45,230 --> 00:40:48,110
don't even know whether the padding

718
00:40:46,550 --> 00:40:50,450
wasn't correct or something else but

719
00:40:48,110 --> 00:40:53,690
most likely than not it wasn't correct

720
00:40:50,450 --> 00:40:55,339
padding because an encryption operation

721
00:40:53,690 --> 00:40:57,440
decryption iteration will deal with any

722
00:40:55,340 --> 00:41:05,360
kind of binary data and it does pretty

723
00:40:57,440 --> 00:41:09,620
care okay so so far we in the examples

724
00:41:05,360 --> 00:41:13,700
that we have seen all the issues that we

725
00:41:09,620 --> 00:41:15,650
have seen were due to the bad integrity

726
00:41:13,700 --> 00:41:18,529
of the message so we modified something

727
00:41:15,650 --> 00:41:20,330
we gave it to as an attacker we gave it

728
00:41:18,530 --> 00:41:22,750
to the application and they just

729
00:41:20,330 --> 00:41:25,790
swallowed that

730
00:41:22,750 --> 00:41:28,430
without checking whether the message was

731
00:41:25,790 --> 00:41:31,670
tampered with or not so right there we

732
00:41:28,430 --> 00:41:36,200
already see that how bad integrity can

733
00:41:31,670 --> 00:41:41,630
lead to bad things but can we take it

734
00:41:36,200 --> 00:41:43,430
further and not just modify the message

735
00:41:41,630 --> 00:41:46,640
so it's garbage but modify it with

736
00:41:43,430 --> 00:41:48,950
specific purpose so let's say I send a

737
00:41:46,640 --> 00:41:52,100
message send 100 dollars to Alice I

738
00:41:48,950 --> 00:41:56,120
encrypt it and then the attacker

739
00:41:52,100 --> 00:41:59,810
intercepts that modifies it modifies the

740
00:41:56,120 --> 00:42:01,549
encrypted message right and then whoever

741
00:41:59,810 --> 00:42:03,920
is receiving that message decrypt it and

742
00:42:01,550 --> 00:42:05,480
they get completely different result so

743
00:42:03,920 --> 00:42:08,180
instead of hundred dollars going to

744
00:42:05,480 --> 00:42:12,100
Alice it's going to go to Mallory is

745
00:42:08,180 --> 00:42:15,200
this possible as a matter of fact it is

746
00:42:12,100 --> 00:42:17,089
and let's see two examples one with

747
00:42:15,200 --> 00:42:20,049
stream cipher and one with block cipher

748
00:42:17,090 --> 00:42:22,220
the attack here is called bit flipping

749
00:42:20,050 --> 00:42:24,680
so let's say our original message was

750
00:42:22,220 --> 00:42:28,279
guessed again we might be talking about

751
00:42:24,680 --> 00:42:30,919
session cookie and our user is guest so

752
00:42:28,280 --> 00:42:33,290
the encryption and this session cookie

753
00:42:30,920 --> 00:42:36,290
is encrypted the encryption is a simple

754
00:42:33,290 --> 00:42:41,570
XOR operation now as an attacker I can

755
00:42:36,290 --> 00:42:44,330
create a new session cookie and I take

756
00:42:41,570 --> 00:42:46,430
the original one and I accelerate with

757
00:42:44,330 --> 00:42:48,770
the original message I know that I know

758
00:42:46,430 --> 00:42:51,350
that I'm guests but I also accelerate

759
00:42:48,770 --> 00:42:55,850
with the one that I desired to have I

760
00:42:51,350 --> 00:42:57,560
want to be admin ok cool and I give that

761
00:42:55,850 --> 00:42:59,930
session cookie to the application and it

762
00:42:57,560 --> 00:43:01,430
tries to decrypt it and decryption is a

763
00:42:59,930 --> 00:43:06,020
simple XOR operation as we already

764
00:43:01,430 --> 00:43:09,109
established which so this will expand to

765
00:43:06,020 --> 00:43:11,570
this kind of thing and then that will in

766
00:43:09,110 --> 00:43:13,700
turn expand to this and then guests and

767
00:43:11,570 --> 00:43:16,790
guests will cancel out the key stream

768
00:43:13,700 --> 00:43:20,240
will cancel out and as a result we get

769
00:43:16,790 --> 00:43:23,930
the admin so the two decrypting this

770
00:43:20,240 --> 00:43:26,319
message is completely predictable in

771
00:43:23,930 --> 00:43:26,319
this case

772
00:43:29,309 --> 00:43:38,950
so let's see it in practice this session

773
00:43:33,460 --> 00:43:43,599
cookie and get a new one okay here is

774
00:43:38,950 --> 00:43:45,189
our application again it's using a

775
00:43:43,599 --> 00:43:46,780
session cookie it's encrypted it's a

776
00:43:45,190 --> 00:43:53,790
different encryption format in this case

777
00:43:46,780 --> 00:43:59,200
we're using a stream cipher we are using

778
00:43:53,790 --> 00:44:02,079
salsa 20 salsa 20 is a pretty new

779
00:43:59,200 --> 00:44:06,250
well.all it's it's new and it's it's

780
00:44:02,079 --> 00:44:13,420
secure algorithm it's using a random

781
00:44:06,250 --> 00:44:17,200
nonce so the key we reuse is not an

782
00:44:13,420 --> 00:44:23,319
issue here as much as in let's say our

783
00:44:17,200 --> 00:44:25,509
c4 but we're not talking about Kyrie's

784
00:44:23,319 --> 00:44:27,099
right now are we talking about modifying

785
00:44:25,510 --> 00:44:30,670
the message so there is no integrity

786
00:44:27,099 --> 00:44:32,799
check it just receives the the cookie

787
00:44:30,670 --> 00:44:37,829
value decrypts it and then analyzes it

788
00:44:32,799 --> 00:44:45,609
see seen if the user is admin or not and

789
00:44:37,829 --> 00:44:49,450
let's see if we can break it okay my

790
00:44:45,609 --> 00:44:53,109
exploit script is accepting this ifer

791
00:44:49,450 --> 00:44:55,118
text and original plaintext and we know

792
00:44:53,109 --> 00:44:57,279
the original plaintext here it's

793
00:44:55,119 --> 00:45:00,609
conveniently printed on the screen but I

794
00:44:57,280 --> 00:45:03,430
can also get it by looking at the source

795
00:45:00,609 --> 00:45:05,890
code right the only thing I don't know

796
00:45:03,430 --> 00:45:10,450
here is the encryption key itself so

797
00:45:05,890 --> 00:45:12,640
this the source code is open but it's

798
00:45:10,450 --> 00:45:19,509
useless if I don't know the encryption

799
00:45:12,640 --> 00:45:21,848
key but we can probably break it now I

800
00:45:19,510 --> 00:45:23,950
need the desired point X so instead of

801
00:45:21,849 --> 00:45:25,690
guest I want admin the other thing to

802
00:45:23,950 --> 00:45:28,689
note here is this application does not

803
00:45:25,690 --> 00:45:30,190
care about the second parameter date at

804
00:45:28,690 --> 00:45:32,760
this point it's not currently being used

805
00:45:30,190 --> 00:45:35,309
so we can just completely erase it and

806
00:45:32,760 --> 00:45:39,780
just leave the user information here and

807
00:45:35,309 --> 00:45:39,780
we're gonna replace guest with admin

808
00:45:41,040 --> 00:45:50,319
and I forgot the closing race okay this

809
00:45:47,319 --> 00:45:55,329
is better so here is our new cat cookie

810
00:45:50,319 --> 00:45:58,750
value let's put it in the browser send

811
00:45:55,329 --> 00:46:01,720
it to the app and now we are admin so

812
00:45:58,750 --> 00:46:03,940
this is the decrypted value now again we

813
00:46:01,720 --> 00:46:06,730
were able to modify the cypher text

814
00:46:03,940 --> 00:46:09,160
without knowing the key but we knew the

815
00:46:06,730 --> 00:46:13,780
original message and we we were able to

816
00:46:09,160 --> 00:46:15,058
change it to something that we want that

817
00:46:13,780 --> 00:46:17,920
was pretty easy to do

818
00:46:15,059 --> 00:46:20,430
apparently this same kind of attack is

819
00:46:17,920 --> 00:46:22,900
possible in block ciphers as well

820
00:46:20,430 --> 00:46:25,118
especially if we are talking about the

821
00:46:22,900 --> 00:46:27,880
first block so the first block as we

822
00:46:25,119 --> 00:46:30,400
know is completely dependent on this

823
00:46:27,880 --> 00:46:34,150
initialization vector with which is X

824
00:46:30,400 --> 00:46:37,440
sort with the ciphertext and I'm just

825
00:46:34,150 --> 00:46:40,059
gonna give it to you as homework to

826
00:46:37,440 --> 00:46:43,000
analyze it but it's basically the same

827
00:46:40,059 --> 00:46:45,670
idea so we just modify the

828
00:46:43,000 --> 00:46:48,670
initialization vector with particular

829
00:46:45,670 --> 00:46:51,690
data and when it's x sort during

830
00:46:48,670 --> 00:46:54,579
decryption we get the desired results

831
00:46:51,690 --> 00:46:57,960
and I have a demo for that as well and

832
00:46:54,579 --> 00:47:01,960
you can play with it if you want later

833
00:46:57,960 --> 00:47:04,240
so to to fix this Canisius we need some

834
00:47:01,960 --> 00:47:06,460
kind of way to check the integrity of

835
00:47:04,240 --> 00:47:09,098
the message to make sure that it's not

836
00:47:06,460 --> 00:47:14,760
been tampered with and that introduces

837
00:47:09,099 --> 00:47:17,740
the concept of authenticity and

838
00:47:14,760 --> 00:47:19,660
authenticated encryption so without

839
00:47:17,740 --> 00:47:21,540
Santa kate encryption not only we get

840
00:47:19,660 --> 00:47:25,299
the cipher text we only get the

841
00:47:21,540 --> 00:47:26,740
authentication tag and during the

842
00:47:25,299 --> 00:47:29,530
christian we validate that

843
00:47:26,740 --> 00:47:36,299
authentication tag and if it doesn't

844
00:47:29,530 --> 00:47:38,770
match our decrypted message then we can

845
00:47:36,299 --> 00:47:42,400
conclude that message has been tampered

846
00:47:38,770 --> 00:47:43,930
with and it's not good we just need to

847
00:47:42,400 --> 00:47:49,180
throw it away and keep some kind of

848
00:47:43,930 --> 00:47:51,669
error you know but you know like I said

849
00:47:49,180 --> 00:47:53,919
we tend to focus on confidentiality a

850
00:47:51,670 --> 00:47:54,790
lot and follow for a good reason and

851
00:47:53,920 --> 00:47:59,830
that's all

852
00:47:54,790 --> 00:48:02,259
but if there is no integrity then the

853
00:47:59,830 --> 00:48:06,670
there is no confidentiality either many

854
00:48:02,260 --> 00:48:10,150
attacks would rely on the fact that the

855
00:48:06,670 --> 00:48:12,900
integrity is not validated that there is

856
00:48:10,150 --> 00:48:15,790
no authenticity in cryptographic scheme

857
00:48:12,900 --> 00:48:19,330
okay and the last topic for today is

858
00:48:15,790 --> 00:48:21,790
storing passwords three simple rules

859
00:48:19,330 --> 00:48:25,990
rule number one no plaintext passwords

860
00:48:21,790 --> 00:48:27,820
right we know that rule number two no

861
00:48:25,990 --> 00:48:31,529
decrypted old passwords so if we store

862
00:48:27,820 --> 00:48:35,350
passwords in the database encrypted with

863
00:48:31,530 --> 00:48:38,400
AES 256 algorithm we got to store the

864
00:48:35,350 --> 00:48:40,960
key somewhere so if that key gets leaked

865
00:48:38,400 --> 00:48:43,630
somebody can decrypt the passwords not

866
00:48:40,960 --> 00:48:47,140
good and the rule number three no one

867
00:48:43,630 --> 00:48:47,680
way hash and at this point you're gonna

868
00:48:47,140 --> 00:48:50,560
say

869
00:48:47,680 --> 00:48:53,940
alexey are you kidding me everybody is

870
00:48:50,560 --> 00:48:57,670
telling me that you gotta use one-way

871
00:48:53,940 --> 00:48:59,770
encryption for just our passwords well

872
00:48:57,670 --> 00:49:01,869
yes that is correct

873
00:48:59,770 --> 00:49:04,720
but some people take this literally and

874
00:49:01,869 --> 00:49:07,240
they use a hash function instead of

875
00:49:04,720 --> 00:49:08,919
something else so what is this something

876
00:49:07,240 --> 00:49:11,109
else something else is the key

877
00:49:08,920 --> 00:49:17,490
derivation function now let's compare

878
00:49:11,109 --> 00:49:21,069
the tube here so the hash itself like

879
00:49:17,490 --> 00:49:24,790
sha-256 it's cheap it's fast right it's

880
00:49:21,070 --> 00:49:26,050
it's it's a very very fast function for

881
00:49:24,790 --> 00:49:28,840
for reason you know you want to

882
00:49:26,050 --> 00:49:32,560
calculate hashes quickly key derivation

883
00:49:28,840 --> 00:49:35,230
function on contrast is expensive it can

884
00:49:32,560 --> 00:49:38,619
be expensive in in terms of in terms of

885
00:49:35,230 --> 00:49:42,250
time CPU usage your memory or all three

886
00:49:38,619 --> 00:49:45,820
at the same time and it's designed this

887
00:49:42,250 --> 00:49:50,470
way for a purpose so it's expensive to

888
00:49:45,820 --> 00:49:53,200
to check the password and at my it sound

889
00:49:50,470 --> 00:49:54,609
like an issue but it's not if if you

890
00:49:53,200 --> 00:49:58,149
were a user who's typing the password

891
00:49:54,609 --> 00:50:02,380
you might be you know you won't make a

892
00:49:58,150 --> 00:50:04,660
big deal if you see like 200 millisecond

893
00:50:02,380 --> 00:50:07,510
delay or whatever or even half a second

894
00:50:04,660 --> 00:50:08,190
delay when your application verifies the

895
00:50:07,510 --> 00:50:10,859
password

896
00:50:08,190 --> 00:50:12,809
it's not a big deal but for an attacker

897
00:50:10,859 --> 00:50:16,848
who tries to brute-force a password

898
00:50:12,809 --> 00:50:21,960
that's a huge deal they are not able to

899
00:50:16,849 --> 00:50:27,630
to brute-force as efficiently as if you

900
00:50:21,960 --> 00:50:34,789
were using a hash function so let me

901
00:50:27,630 --> 00:50:37,980
just give you a very small demo I have a

902
00:50:34,789 --> 00:50:40,980
script that generates a couple of hashes

903
00:50:37,980 --> 00:50:48,750
so one the first time is gonna generate

904
00:50:40,980 --> 00:50:50,849
a shot hash of off my password and the

905
00:50:48,750 --> 00:50:53,789
password is not revealed here it's just

906
00:50:50,849 --> 00:50:57,180
a hash right now I can run John the

907
00:50:53,789 --> 00:50:59,970
Ripper which is the brute force tool and

908
00:50:57,180 --> 00:51:02,788
it's comparing against the dictionary

909
00:50:59,970 --> 00:51:04,169
and in the dictionary I have the word

910
00:51:02,789 --> 00:51:05,700
Pink Floyd which appears to be my

911
00:51:04,170 --> 00:51:10,349
password and it was able to crack it

912
00:51:05,700 --> 00:51:14,098
immediately you know it tells me that it

913
00:51:10,349 --> 00:51:18,690
was able to check 84,000 passwords per

914
00:51:14,099 --> 00:51:22,109
second pretty impressive but now if I do

915
00:51:18,690 --> 00:51:24,329
the same with pbkdf2 which is one of the

916
00:51:22,109 --> 00:51:26,430
key derivation functions by the way it's

917
00:51:24,329 --> 00:51:30,859
not the latest and greatest anymore but

918
00:51:26,430 --> 00:51:34,589
you know it's still much better than sha

919
00:51:30,859 --> 00:51:37,200
and now if I run John the Ripper it

920
00:51:34,589 --> 00:51:41,930
first of all it fire up fired up eight

921
00:51:37,200 --> 00:51:45,569
threats and now it's taking much longer

922
00:51:41,930 --> 00:51:49,828
to analyze that hash to try all these

923
00:51:45,569 --> 00:51:52,380
different passwords to to brute force it

924
00:51:49,829 --> 00:51:54,569
and it's it's going to return eventually

925
00:51:52,380 --> 00:51:57,690
but you can already see that it's taking

926
00:51:54,569 --> 00:52:01,430
much longer so this is just a good

927
00:51:57,690 --> 00:52:06,299
example to show you know how different

928
00:52:01,430 --> 00:52:08,609
that password cracking is depending on

929
00:52:06,299 --> 00:52:11,819
the function that is being used so in

930
00:52:08,609 --> 00:52:15,150
this case it was able to only check 44

931
00:52:11,819 --> 00:52:17,849
passwords per second versus 84,000 you

932
00:52:15,150 --> 00:52:19,070
know that's as a huge difference and not

933
00:52:17,849 --> 00:52:21,620
very efficient

934
00:52:19,070 --> 00:52:23,840
all right so takeaways if you're a

935
00:52:21,620 --> 00:52:26,270
breaking breaker you need to understand

936
00:52:23,840 --> 00:52:28,610
the concepts those cryptographic

937
00:52:26,270 --> 00:52:31,490
concepts at some kind of technical level

938
00:52:28,610 --> 00:52:33,830
you might need to go deeper a little bit

939
00:52:31,490 --> 00:52:37,520
in order to see what what's actually

940
00:52:33,830 --> 00:52:39,560
going on you know how can I break it

941
00:52:37,520 --> 00:52:40,970
examine the industry guidelines to

942
00:52:39,560 --> 00:52:43,250
understand why they're there and what

943
00:52:40,970 --> 00:52:45,259
can go wrong if those are not being

944
00:52:43,250 --> 00:52:47,570
followed and expand on other people's

945
00:52:45,260 --> 00:52:49,900
work there are there are tools there are

946
00:52:47,570 --> 00:52:55,310
their simple code there are write-ups

947
00:52:49,900 --> 00:52:57,770
from CTF or real-life vulnerabilities

948
00:52:55,310 --> 00:53:01,759
and those are pretty cool to study and

949
00:52:57,770 --> 00:53:03,950
understand how how things were broken if

950
00:53:01,760 --> 00:53:06,980
you're a builder again you need to

951
00:53:03,950 --> 00:53:10,399
understand the concepts of cryptography

952
00:53:06,980 --> 00:53:13,040
and your task right you know you use the

953
00:53:10,400 --> 00:53:16,370
right tool for the purpose that's that's

954
00:53:13,040 --> 00:53:17,810
important and then again you you gotta

955
00:53:16,370 --> 00:53:19,700
know those guidelines and you need to

956
00:53:17,810 --> 00:53:22,310
follow them like I said they're there

957
00:53:19,700 --> 00:53:25,450
for a reason and learn from other

958
00:53:22,310 --> 00:53:28,940
people's mistakes you know read those

959
00:53:25,450 --> 00:53:32,689
about those vulnerabilities and see how

960
00:53:28,940 --> 00:53:35,780
things gone bad and try not to do the

961
00:53:32,690 --> 00:53:38,530
same thing for further learning I would

962
00:53:35,780 --> 00:53:42,920
highly recommend this course on Coursera

963
00:53:38,530 --> 00:53:45,830
it's free and it's really amazing and

964
00:53:42,920 --> 00:53:49,250
there's this online book it's basically

965
00:53:45,830 --> 00:53:53,020
PDF but very very helpful lots of cool

966
00:53:49,250 --> 00:53:55,340
stuff for both breakers and builders

967
00:53:53,020 --> 00:53:57,460
like I said my code is on github

968
00:53:55,340 --> 00:54:01,720
feel free to download it play with it

969
00:53:57,460 --> 00:54:06,920
modify it use it in your presentations

970
00:54:01,720 --> 00:54:08,740
and feel free to contact me if you want

971
00:54:06,920 --> 00:54:15,440
to stay in touch and thank you very much

972
00:54:08,740 --> 00:54:18,200
and good luck thank you we will take an

973
00:54:15,440 --> 00:54:20,000
hour break and we'll come back here for

974
00:54:18,200 --> 00:54:23,089
our next talk if you have any questions

975
00:54:20,000 --> 00:54:26,180
please join the discord in track 3 and

976
00:54:23,090 --> 00:54:29,380
and thank you again for your talk all

977
00:54:26,180 --> 00:54:29,379
right take everyone

