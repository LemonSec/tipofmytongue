1
00:00:04,090 --> 00:00:06,150
you

2
00:00:11,210 --> 00:00:18,300
okay there we go

3
00:00:14,309 --> 00:00:20,970
say we got some video alright everyone

4
00:00:18,300 --> 00:00:23,010
thanks for joining I am Mike Saunders

5
00:00:20,970 --> 00:00:24,450
hard water hacker on Twitter today I

6
00:00:23,010 --> 00:00:27,930
want to talk to you about buffer

7
00:00:24,450 --> 00:00:30,210
overflow 101 will let you know that you

8
00:00:27,930 --> 00:00:34,590
can get these slides at red siege comm

9
00:00:30,210 --> 00:00:36,300
CIP and those slides will have all the

10
00:00:34,590 --> 00:00:38,190
demonstrations that I did today as well

11
00:00:36,300 --> 00:00:39,989
as links to the resources that I'm going

12
00:00:38,190 --> 00:00:41,430
to talk about and some practice

13
00:00:39,989 --> 00:00:46,320
resources that you can find at the end

14
00:00:41,430 --> 00:00:48,690
of the deck that you can use so standard

15
00:00:46,320 --> 00:00:51,420
about me principle consult with Fred

16
00:00:48,690 --> 00:00:54,180
seeds NIT a while and insecurity a while

17
00:00:51,420 --> 00:00:56,129
and when I'm not doing the security

18
00:00:54,180 --> 00:00:58,580
stuff you can probably find me kayaking

19
00:00:56,129 --> 00:01:02,970
or playing the guitars back there or

20
00:00:58,580 --> 00:01:05,069
maybe out doing some bacon so why am I

21
00:01:02,970 --> 00:01:07,048
talking to you about buffer overflow 101

22
00:01:05,069 --> 00:01:08,520
this this isn't a new topic

23
00:01:07,049 --> 00:01:11,280
this has been around and it hasn't

24
00:01:08,520 --> 00:01:14,880
changed since a since smashing the stack

25
00:01:11,280 --> 00:01:17,580
for fun and profit came out in 1995 well

26
00:01:14,880 --> 00:01:19,050
the real reason I'm doing this is when I

27
00:01:17,580 --> 00:01:22,200
was learning buffer overflows which

28
00:01:19,050 --> 00:01:26,550
honestly wasn't that long ago I felt

29
00:01:22,200 --> 00:01:28,620
like buffer overflow was well I think

30
00:01:26,550 --> 00:01:31,679
this gif pretty much sums it up it felt

31
00:01:28,620 --> 00:01:34,050
like magic to me I knew that a buffer

32
00:01:31,680 --> 00:01:36,690
overflow was you had this buffer in

33
00:01:34,050 --> 00:01:38,700
memory and you took some data and he

34
00:01:36,690 --> 00:01:42,090
pushed too much data into that buffer

35
00:01:38,700 --> 00:01:44,790
and bad stuff happened but I didn't

36
00:01:42,090 --> 00:01:46,080
understand any more than that and as I

37
00:01:44,790 --> 00:01:48,780
was learning it and starting to get

38
00:01:46,080 --> 00:01:51,800
comfortable I was I was noticing that

39
00:01:48,780 --> 00:01:55,290
you know on Twitter people that I follow

40
00:01:51,800 --> 00:01:56,729
are asking about buffer overflows just

41
00:01:55,290 --> 00:01:58,409
getting started with it and naturally

42
00:01:56,730 --> 00:01:59,580
because of imposter syndrome I assume

43
00:01:58,409 --> 00:02:01,770
that I know nothing and they know

44
00:01:59,580 --> 00:02:05,340
everything if they're asking about

45
00:02:01,770 --> 00:02:06,420
buffer overflows then why like why are

46
00:02:05,340 --> 00:02:08,190
they doing that because they should all

47
00:02:06,420 --> 00:02:10,649
know that and these were people that

48
00:02:08,190 --> 00:02:12,209
have been around awhile and in talking

49
00:02:10,649 --> 00:02:16,830
and friends you know just realized that

50
00:02:12,209 --> 00:02:20,040
this is a basic concept that a lot of us

51
00:02:16,830 --> 00:02:21,900
don't learn right away some of us many

52
00:02:20,040 --> 00:02:23,909
don't learn for a long time

53
00:02:21,900 --> 00:02:25,560
and there's so many new people coming

54
00:02:23,909 --> 00:02:26,939
into the industry all the time that

55
00:02:25,560 --> 00:02:28,470
don't have the background that is always

56
00:02:26,939 --> 00:02:30,870
going to be a relevant topic or at least

57
00:02:28,470 --> 00:02:33,260
you know for quite a while so that's why

58
00:02:30,870 --> 00:02:38,609
I'm talking to you about buffer overflow

59
00:02:33,260 --> 00:02:40,439
101 now to talk about that I do need to

60
00:02:38,609 --> 00:02:42,870
get some assumptions out there I'm

61
00:02:40,439 --> 00:02:46,189
talking about buffer overflows in a

62
00:02:42,870 --> 00:02:49,250
32-bit architecture x86 architecture

63
00:02:46,189 --> 00:02:52,560
these aren't any kinds of advanced

64
00:02:49,250 --> 00:02:54,780
buffer overflows we're not doing wrap

65
00:02:52,560 --> 00:02:57,870
chains we're not doing SCH type things

66
00:02:54,780 --> 00:02:59,579
this is a standard stack face buffer

67
00:02:57,870 --> 00:03:01,829
overflow where we overwrite a return

68
00:02:59,579 --> 00:03:03,989
address and gain execution control there

69
00:03:01,829 --> 00:03:05,489
are no protections in place when we're

70
00:03:03,989 --> 00:03:08,430
doing this there's no depth there's no a

71
00:03:05,489 --> 00:03:10,769
SLR I happen to be doing this on a

72
00:03:08,430 --> 00:03:13,650
Windows XP machine but this would work

73
00:03:10,769 --> 00:03:18,180
in Windows 10 as long as you don't have

74
00:03:13,650 --> 00:03:19,319
some kind of some kind of a V or EDR in

75
00:03:18,180 --> 00:03:22,470
place it's going to block the buffer

76
00:03:19,319 --> 00:03:25,888
overflow attempts this will also work

77
00:03:22,470 --> 00:03:29,699
you know these key concepts translate to

78
00:03:25,889 --> 00:03:32,340
things like ARM architecture or 64-bit

79
00:03:29,699 --> 00:03:33,629
architecture they aren't exactly the

80
00:03:32,340 --> 00:03:34,949
same but a lot of the concepts are

81
00:03:33,629 --> 00:03:38,879
similar so you can use this as a

82
00:03:34,949 --> 00:03:41,010
starting point so what is a buffer

83
00:03:38,879 --> 00:03:44,399
overflow we should define that this is

84
00:03:41,010 --> 00:03:45,870
not a buffer overflow this tweet was

85
00:03:44,400 --> 00:03:48,480
gold I was really glad I was able to

86
00:03:45,870 --> 00:03:52,769
snag it when when sub T tweeted it out

87
00:03:48,480 --> 00:03:56,879
so a buffer overflow at its most basic

88
00:03:52,769 --> 00:03:59,099
is a program incorrectly allows writing

89
00:03:56,879 --> 00:04:01,470
more data into a buffer than it did

90
00:03:59,099 --> 00:04:03,418
previously allocated space for and that

91
00:04:01,470 --> 00:04:07,260
causes adjacent memory to be overwritten

92
00:04:03,419 --> 00:04:11,280
and possibly bad things to happen so if

93
00:04:07,260 --> 00:04:14,429
you have 500 bytes that you write into a

94
00:04:11,280 --> 00:04:17,190
buffer and/or you allocate 500 bytes

95
00:04:14,430 --> 00:04:18,299
into for a buffer and then you write in

96
00:04:17,190 --> 00:04:20,339
600 bytes

97
00:04:18,298 --> 00:04:21,539
you've written in 500 bytes and you

98
00:04:20,339 --> 00:04:25,138
filled up your buffer and that

99
00:04:21,539 --> 00:04:27,449
additional hundred bytes goes into the

100
00:04:25,139 --> 00:04:29,010
adjacent memory there so that's what

101
00:04:27,449 --> 00:04:31,229
happens when a buffer overflow happens

102
00:04:29,010 --> 00:04:33,300
how you get execution control and

103
00:04:31,229 --> 00:04:35,200
actually exploit a system we will walk

104
00:04:33,300 --> 00:04:41,650
through that I will talk you through

105
00:04:35,200 --> 00:04:43,210
works oops screen here so before we do

106
00:04:41,650 --> 00:04:45,340
that I have to give you some background

107
00:04:43,210 --> 00:04:46,870
I talked about the stack a couple of

108
00:04:45,340 --> 00:04:48,969
times possibly the stack is a data

109
00:04:46,870 --> 00:04:52,560
structure it stores data in contiguous

110
00:04:48,970 --> 00:04:55,420
blocks in its temporary storage in RAM

111
00:04:52,560 --> 00:04:58,660
it's typically used to store local data

112
00:04:55,420 --> 00:05:00,940
things like parameter values data about

113
00:04:58,660 --> 00:05:02,350
the particular function that you're in

114
00:05:00,940 --> 00:05:04,120
for instance Maine and these various

115
00:05:02,350 --> 00:05:06,790
subroutines each one will have its own

116
00:05:04,120 --> 00:05:09,520
memory space something called a return

117
00:05:06,790 --> 00:05:11,140
address which we will get into and an

118
00:05:09,520 --> 00:05:13,599
important thing to know about the stack

119
00:05:11,140 --> 00:05:17,950
is that it is a last in first out

120
00:05:13,600 --> 00:05:19,540
architecture or data type so if you

121
00:05:17,950 --> 00:05:21,010
think of going to a buffet and they have

122
00:05:19,540 --> 00:05:22,750
that stack of plates and if you push

123
00:05:21,010 --> 00:05:26,980
down on it it goes down and it pops back

124
00:05:22,750 --> 00:05:29,140
up if you put five plates on to that

125
00:05:26,980 --> 00:05:30,610
stack and you push them on to the stack

126
00:05:29,140 --> 00:05:32,680
of plates and that's the terminology we

127
00:05:30,610 --> 00:05:34,360
push things on to the stack if you want

128
00:05:32,680 --> 00:05:36,400
to get that first plate that you took

129
00:05:34,360 --> 00:05:38,260
off you have to take off the previous

130
00:05:36,400 --> 00:05:40,450
four plates you have to pop them off the

131
00:05:38,260 --> 00:05:41,890
stack so the last thing to go in the

132
00:05:40,450 --> 00:05:44,380
stack is the first thing that come off

133
00:05:41,890 --> 00:05:48,700
the stack and that will become important

134
00:05:44,380 --> 00:05:50,350
here as we walk through this so I'm

135
00:05:48,700 --> 00:05:52,659
gonna give you a visualization of the

136
00:05:50,350 --> 00:05:55,480
stack this isn't entirely accurate but

137
00:05:52,660 --> 00:05:59,140
it's going to work for our purposes

138
00:05:55,480 --> 00:06:01,600
today so this is an example of a stack I

139
00:05:59,140 --> 00:06:03,190
talked about main right so if you think

140
00:06:01,600 --> 00:06:05,800
about your main routine that would be

141
00:06:03,190 --> 00:06:07,420
the parent routine down here and let's

142
00:06:05,800 --> 00:06:10,510
say we had a sub routine just called

143
00:06:07,420 --> 00:06:12,880
process this is the process subroutine

144
00:06:10,510 --> 00:06:16,060
here we've called process and it's this

145
00:06:12,880 --> 00:06:18,580
is its memory space process has a 50

146
00:06:16,060 --> 00:06:20,290
byte variable foo it's got some other

147
00:06:18,580 --> 00:06:22,090
things that are pushed on the stack like

148
00:06:20,290 --> 00:06:23,440
frame pointers and base pointers and

149
00:06:22,090 --> 00:06:25,060
they're all important and we're not

150
00:06:23,440 --> 00:06:26,260
going to talk about any of them the

151
00:06:25,060 --> 00:06:29,440
thing we are going to talk about is

152
00:06:26,260 --> 00:06:32,590
right here this return address and the

153
00:06:29,440 --> 00:06:35,680
return address tells the program how to

154
00:06:32,590 --> 00:06:38,169
get back to the parent routine how to

155
00:06:35,680 --> 00:06:41,500
get back to main or whatever function

156
00:06:38,170 --> 00:06:43,030
called it once it's done executing now

157
00:06:41,500 --> 00:06:44,470
some of you may be looking at this and

158
00:06:43,030 --> 00:06:47,270
thinking that I have this backwards it's

159
00:06:44,470 --> 00:06:49,400
upside-down and you probably learn

160
00:06:47,270 --> 00:06:52,580
buffer overflows or you learned about

161
00:06:49,400 --> 00:06:54,739
memory structure in school and you'll

162
00:06:52,580 --> 00:06:57,500
notice up here at the top is all zeros

163
00:06:54,740 --> 00:06:58,610
at the bottom sis is all F's so if you

164
00:06:57,500 --> 00:07:00,169
learned it in school you probably

165
00:06:58,610 --> 00:07:01,669
learned with all zeros on the bottom and

166
00:07:00,169 --> 00:07:04,609
F's on the top and there's nothing wrong

167
00:07:01,669 --> 00:07:07,460
with that with that model and it's it's

168
00:07:04,610 --> 00:07:09,830
probably a better way to do it the

169
00:07:07,460 --> 00:07:11,870
reason I use this is this is how I

170
00:07:09,830 --> 00:07:14,150
learned the examples that I followed

171
00:07:11,870 --> 00:07:16,009
laid it out this way and the debugger

172
00:07:14,150 --> 00:07:18,679
that I use lays it out this way

173
00:07:16,009 --> 00:07:20,360
so I'm going to use this model just be

174
00:07:18,680 --> 00:07:22,639
aware that as you're learning and you're

175
00:07:20,360 --> 00:07:24,110
researching if you come across a scarlet

176
00:07:22,639 --> 00:07:26,630
scholarly article and you're used to

177
00:07:24,110 --> 00:07:28,159
using a model like this they may have it

178
00:07:26,630 --> 00:07:29,330
flipped and it'll be somewhat bit

179
00:07:28,159 --> 00:07:31,280
wildering you don't think that

180
00:07:29,330 --> 00:07:33,800
everything you knew was wrong until you

181
00:07:31,280 --> 00:07:36,469
realize what's going on so a few more

182
00:07:33,800 --> 00:07:39,860
things to point out because memory

183
00:07:36,470 --> 00:07:42,470
addresses are at the bottom in this

184
00:07:39,860 --> 00:07:45,110
model if we were to pop foo off the

185
00:07:42,470 --> 00:07:47,810
stack the memory addresses are getting

186
00:07:45,110 --> 00:07:50,840
higher right like each entry in the

187
00:07:47,810 --> 00:07:52,669
stack has a higher memory address and if

188
00:07:50,840 --> 00:07:55,369
we were to push more data on to the

189
00:07:52,669 --> 00:07:58,430
stack for instance like this the memory

190
00:07:55,370 --> 00:08:00,830
address gets lower now

191
00:07:58,430 --> 00:08:04,070
we've pushed bar onto the stack you'll

192
00:08:00,830 --> 00:08:08,150
see that this ESP or top of stack moved

193
00:08:04,070 --> 00:08:09,979
an ESP is a register stands for the

194
00:08:08,150 --> 00:08:12,258
stack pointer and keeps track of where

195
00:08:09,979 --> 00:08:15,620
is the uppermost memory address of the

196
00:08:12,259 --> 00:08:18,469
stack so if we push bar onto the stack

197
00:08:15,620 --> 00:08:23,090
after foo ESP gets updated to point to

198
00:08:18,469 --> 00:08:25,940
this location but if we were to pop bar

199
00:08:23,090 --> 00:08:28,068
off the stack then now all we have left

200
00:08:25,940 --> 00:08:31,550
is foo on the stack in ESP has been

201
00:08:28,069 --> 00:08:34,760
updated to point to the top of foo here

202
00:08:31,550 --> 00:08:37,370
so the ESP will keep track of where the

203
00:08:34,760 --> 00:08:40,549
stack is at where the uppermost address

204
00:08:37,370 --> 00:08:44,380
or rather the lower most address in the

205
00:08:40,549 --> 00:08:44,380
stack if you're using this model

206
00:08:46,199 --> 00:08:51,569
ESP address moves higher as stack

207
00:08:49,199 --> 00:08:55,258
shrinks address moves lower is the stack

208
00:08:51,569 --> 00:08:58,680
rose there are other registers the

209
00:08:55,259 --> 00:09:00,149
accumulator stack pointer is the only

210
00:08:58,680 --> 00:09:02,069
one we're going to talk about these

211
00:09:00,149 --> 00:09:06,360
registers historically had a more

212
00:09:02,069 --> 00:09:07,979
defined purpose nowadays there we use

213
00:09:06,360 --> 00:09:10,019
can be fairly flexible and those

214
00:09:07,980 --> 00:09:14,069
decisions are made at compile time a lot

215
00:09:10,019 --> 00:09:17,759
of times there is a special purpose

216
00:09:14,069 --> 00:09:20,279
register called VIP that is the extended

217
00:09:17,759 --> 00:09:22,079
instruction pointer you'll notice all of

218
00:09:20,279 --> 00:09:23,879
those general-purpose registers started

219
00:09:22,079 --> 00:09:26,000
with e4 extended that's because we're in

220
00:09:23,879 --> 00:09:28,589
the 32-bit architecture if we were in

221
00:09:26,000 --> 00:09:32,069
16-bit it would just be the instruction

222
00:09:28,589 --> 00:09:35,490
pointer the instruction pointer stores

223
00:09:32,069 --> 00:09:37,920
address stores the address of the next

224
00:09:35,490 --> 00:09:40,230
instruction to be executed it does not

225
00:09:37,920 --> 00:09:42,389
store the instruction to be executed it

226
00:09:40,230 --> 00:09:43,889
does not store data about the

227
00:09:42,389 --> 00:09:46,709
instruction or anything else it stores

228
00:09:43,889 --> 00:09:48,870
the address of the next instruction to

229
00:09:46,709 --> 00:09:53,369
be executed it's an important thing to

230
00:09:48,870 --> 00:09:56,459
remember it stores an address if you can

231
00:09:53,370 --> 00:09:58,829
control what goes into EIP you could

232
00:09:56,459 --> 00:10:00,388
control what execution is going to

233
00:09:58,829 --> 00:10:02,870
happen next you can control what command

234
00:10:00,389 --> 00:10:05,339
is gonna is going to be executed and

235
00:10:02,870 --> 00:10:07,529
contrary to popular opinion you will

236
00:10:05,339 --> 00:10:09,149
hear people say I over wrote a I P I

237
00:10:07,529 --> 00:10:12,089
will probably screw it up and say it at

238
00:10:09,149 --> 00:10:14,069
some point today you do not over iTIP

239
00:10:12,089 --> 00:10:15,509
you overwrite the return address what

240
00:10:14,069 --> 00:10:17,639
gets loaded into EIP

241
00:10:15,509 --> 00:10:21,990
e IP for the most part can only be

242
00:10:17,639 --> 00:10:23,759
modified directly through the kernel so

243
00:10:21,990 --> 00:10:30,600
let's take a look at a buffer overflow

244
00:10:23,759 --> 00:10:33,509
what does it look like in the stack this

245
00:10:30,600 --> 00:10:35,939
is a simple command line program running

246
00:10:33,509 --> 00:10:37,470
on a Linux system but it would be not

247
00:10:35,939 --> 00:10:40,050
different doing it in a Windows

248
00:10:37,470 --> 00:10:42,329
environment we talked about that parent

249
00:10:40,050 --> 00:10:46,589
routine process right this is the parent

250
00:10:42,329 --> 00:10:48,930
routine here main and main calls foo

251
00:10:46,589 --> 00:10:51,839
with one argument that's an argument

252
00:10:48,930 --> 00:10:54,779
that it gets on the command line if we

253
00:10:51,839 --> 00:10:58,350
look at foo foo declares one variable

254
00:10:54,779 --> 00:10:59,570
here C we're gonna use ster copy so

255
00:10:58,350 --> 00:11:01,700
we're not going to check to see if

256
00:10:59,570 --> 00:11:04,450
things fit we're just gonna copy what we

257
00:11:01,700 --> 00:11:08,540
received on the command line into C and

258
00:11:04,450 --> 00:11:10,850
then we are going to print what's in C

259
00:11:08,540 --> 00:11:12,469
out to the screen now you'll notice

260
00:11:10,850 --> 00:11:15,020
there is no return here we're not

261
00:11:12,470 --> 00:11:18,020
reading says return back to main that's

262
00:11:15,020 --> 00:11:20,360
because that is built-in at compile time

263
00:11:18,020 --> 00:11:22,910
the instruction on how to get back to

264
00:11:20,360 --> 00:11:24,740
main and where it will go to will be

265
00:11:22,910 --> 00:11:25,939
immediately after what called it so it

266
00:11:24,740 --> 00:11:28,640
called it here it will go to the next

267
00:11:25,940 --> 00:11:31,760
instruction return zero and then we'll

268
00:11:28,640 --> 00:11:35,000
exit the program and it knows how to get

269
00:11:31,760 --> 00:11:38,660
there because of that return address and

270
00:11:35,000 --> 00:11:40,160
we'll take a look at that so this is

271
00:11:38,660 --> 00:11:42,709
what the stack for the program would

272
00:11:40,160 --> 00:11:44,120
look like for the most part we've got

273
00:11:42,710 --> 00:11:45,440
our parent routines stacked down at the

274
00:11:44,120 --> 00:11:48,050
bottom which is going to be main and

275
00:11:45,440 --> 00:11:51,530
this is gonna be foo and here's our

276
00:11:48,050 --> 00:11:54,079
variable see we've got some other things

277
00:11:51,530 --> 00:11:56,089
below C and then we've got the return

278
00:11:54,080 --> 00:11:59,330
address that's what tells it how to get

279
00:11:56,090 --> 00:12:02,350
back to main now if we were to run this

280
00:11:59,330 --> 00:12:05,240
program let's say let's run demo hello

281
00:12:02,350 --> 00:12:07,970
it runs it prints out hello to the

282
00:12:05,240 --> 00:12:08,990
screen in a Texas normally that's what

283
00:12:07,970 --> 00:12:11,030
we would expect to happen

284
00:12:08,990 --> 00:12:14,330
there was no we didn't put too much data

285
00:12:11,030 --> 00:12:15,709
in shouldn't be any problem if we were

286
00:12:14,330 --> 00:12:18,020
to look at the stack for the program we

287
00:12:15,710 --> 00:12:19,580
don't understand why we put in a hello

288
00:12:18,020 --> 00:12:21,770
we put in five bytes there's actually a

289
00:12:19,580 --> 00:12:24,580
six byte here and that is because

290
00:12:21,770 --> 00:12:27,170
strings in c and c++ are null terminated

291
00:12:24,580 --> 00:12:30,350
so we pushed in hello and our null

292
00:12:27,170 --> 00:12:35,150
terminator we did not fill up the rest

293
00:12:30,350 --> 00:12:38,330
of this buffer so that C was popped off

294
00:12:35,150 --> 00:12:42,110
the stack and then the rest of the data

295
00:12:38,330 --> 00:12:44,330
was popped off the stack and the return

296
00:12:42,110 --> 00:12:46,730
address popped off the stack loaded into

297
00:12:44,330 --> 00:12:49,460
EIP that takes us back to main and we

298
00:12:46,730 --> 00:12:52,460
exit out of main but what if we gave it

299
00:12:49,460 --> 00:12:57,260
too much data in this case 16 a's and

300
00:12:52,460 --> 00:12:59,510
four bytes a hex cc's i run that we

301
00:12:57,260 --> 00:13:01,400
print out the a's in the hex to this

302
00:12:59,510 --> 00:13:04,010
screen and then there's a segmentation

303
00:13:01,400 --> 00:13:06,370
fault and think about that order that i

304
00:13:04,010 --> 00:13:06,370
just said

305
00:13:07,160 --> 00:13:10,610
I ran the program with the input we

306
00:13:08,779 --> 00:13:12,649
printed the data out to the screen we

307
00:13:10,610 --> 00:13:15,529
put more than 12 bytes into the buffer

308
00:13:12,649 --> 00:13:17,420
we put 20 bytes into the buffer it still

309
00:13:15,529 --> 00:13:20,180
printed that out to the screen and then

310
00:13:17,420 --> 00:13:23,060
a segmentation fault occurred and if we

311
00:13:20,180 --> 00:13:24,769
look at our code we can you know we can

312
00:13:23,060 --> 00:13:28,008
understand what's happening here we push

313
00:13:24,769 --> 00:13:30,370
this into the we push this into the

314
00:13:28,009 --> 00:13:33,100
buffer and then we printed it out and

315
00:13:30,370 --> 00:13:36,139
then the segmentation fault happened

316
00:13:33,100 --> 00:13:38,569
it's an important thing to know it's

317
00:13:36,139 --> 00:13:41,079
important but subtle distinction and if

318
00:13:38,569 --> 00:13:43,790
we look at the stack we understand why

319
00:13:41,079 --> 00:13:47,839
we've got 12 bytes of AIDS we filled up

320
00:13:43,790 --> 00:13:51,349
our buffer but then we pushed in another

321
00:13:47,839 --> 00:13:52,490
four bytes into what was a base planter

322
00:13:51,350 --> 00:13:55,910
or frame point or something like that

323
00:13:52,490 --> 00:13:58,850
and then we pushed in these hexie sees

324
00:13:55,910 --> 00:14:00,709
that over wrote the return address so at

325
00:13:58,850 --> 00:14:03,019
that point when that return address was

326
00:14:00,709 --> 00:14:05,319
popped off the stack yeah I see IP would

327
00:14:03,019 --> 00:14:09,019
have been si si si si si si si si and

328
00:14:05,319 --> 00:14:10,670
that is not a spot where code for our

329
00:14:09,019 --> 00:14:11,779
program lives in memory and therefore

330
00:14:10,670 --> 00:14:13,969
the program doesn't know what

331
00:14:11,779 --> 00:14:16,790
instruction to execute X and it crashes

332
00:14:13,970 --> 00:14:19,399
that is a buffer overflow at its most

333
00:14:16,790 --> 00:14:22,599
basic so let's see if we can weaponize

334
00:14:19,399 --> 00:14:26,209
that I'm gonna pray to the demo gods

335
00:14:22,600 --> 00:14:30,290
I've got a backup presentation so we're

336
00:14:26,209 --> 00:14:32,959
gonna go over here and hopefully this

337
00:14:30,290 --> 00:14:35,480
all comes through I've got a Python

338
00:14:32,959 --> 00:14:37,310
script and I will have a link to the

339
00:14:35,480 --> 00:14:40,069
Python scripts that I used during this

340
00:14:37,310 --> 00:14:43,670
talk available for you at the end of the

341
00:14:40,069 --> 00:14:46,550
talk so I'm gonna fuzz the input length

342
00:14:43,670 --> 00:14:47,959
of this program actually you know what

343
00:14:46,550 --> 00:14:50,930
before we do this let's go back let's

344
00:14:47,959 --> 00:14:52,849
talk about this I'm gonna do a demo with

345
00:14:50,930 --> 00:14:54,920
a program called bone server bone

346
00:14:52,850 --> 00:14:57,199
servers written by Steven Bradshaw it's

347
00:14:54,920 --> 00:14:58,910
an intentionally vulnerable program that

348
00:14:57,199 --> 00:15:02,990
allows you to learn how to write buffer

349
00:14:58,910 --> 00:15:05,089
overflows if you think of how a web

350
00:15:02,990 --> 00:15:06,949
server works if you were to netcat to

351
00:15:05,089 --> 00:15:09,199
the port and you have a verb that you

352
00:15:06,949 --> 00:15:11,149
give it get then you have a couple of

353
00:15:09,199 --> 00:15:13,609
arguments you have what you want to get

354
00:15:11,149 --> 00:15:16,769
slash and then the protocol you want to

355
00:15:13,610 --> 00:15:18,629
speak HTTP 1.1 HTTP 1.0

356
00:15:16,769 --> 00:15:20,910
you hit enter and that sends a carriage

357
00:15:18,629 --> 00:15:22,800
return line view to the server that

358
00:15:20,910 --> 00:15:24,238
tells the server hey I'm done sending

359
00:15:22,800 --> 00:15:26,429
you input you can go ahead and process

360
00:15:24,239 --> 00:15:29,069
and then it sends you whatever you

361
00:15:26,429 --> 00:15:32,220
requested in much the same fashion von

362
00:15:29,069 --> 00:15:35,219
server has a suite of verbs one of them

363
00:15:32,220 --> 00:15:38,040
is tea run and if you enter tea run

364
00:15:35,220 --> 00:15:40,939
space period the server processes

365
00:15:38,040 --> 00:15:44,160
whatever data is after that period and

366
00:15:40,939 --> 00:15:46,439
it signifies the end of the input by

367
00:15:44,160 --> 00:15:48,779
sending a carriage return line view and

368
00:15:46,439 --> 00:15:53,040
then it will process that data SAT run

369
00:15:48,779 --> 00:15:56,009
complete so what we're gonna do is we're

370
00:15:53,040 --> 00:15:57,480
gonna fudge the input length for the tea

371
00:15:56,009 --> 00:15:59,489
run command so we're not fuzzing like a

372
00:15:57,480 --> 00:16:01,860
protocol here we're not doing you know

373
00:15:59,489 --> 00:16:04,139
some wire and wire protocol fuzzing or

374
00:16:01,860 --> 00:16:07,709
PDF or whatever we're fuzzing the input

375
00:16:04,139 --> 00:16:10,739
length so this Python script sets up a

376
00:16:07,709 --> 00:16:11,488
counter and yes Python to point whatever

377
00:16:10,739 --> 00:16:14,730
I know

378
00:16:11,489 --> 00:16:17,730
needs to be updated we've got this

379
00:16:14,730 --> 00:16:19,799
counter that we set up and it initially

380
00:16:17,730 --> 00:16:21,480
sets at 100 we've got our command to

381
00:16:19,799 --> 00:16:23,819
your own space period and we set up an

382
00:16:21,480 --> 00:16:26,309
empty list called buffer we're gonna

383
00:16:23,819 --> 00:16:28,139
populate that list with entries that

384
00:16:26,309 --> 00:16:30,569
consists of our command to your own

385
00:16:28,139 --> 00:16:33,089
space period and some number of A's

386
00:16:30,569 --> 00:16:35,189
which is a times the counter and then

387
00:16:33,089 --> 00:16:38,249
we're going to increase our counter and

388
00:16:35,189 --> 00:16:40,829
the next line in our list is going to be

389
00:16:38,249 --> 00:16:42,779
tea run slaves period with 200 more A's

390
00:16:40,829 --> 00:16:45,269
and we're gonna continue on until we

391
00:16:42,779 --> 00:16:48,329
filled that up and then we're going to

392
00:16:45,269 --> 00:16:51,329
take and send this data to the server

393
00:16:48,329 --> 00:16:53,040
we're gonna connect to the socket and

394
00:16:51,329 --> 00:16:54,420
we're gonna send our data we're gonna

395
00:16:53,040 --> 00:16:58,230
receive a response and we're gonna print

396
00:16:54,420 --> 00:17:01,860
it out to the screen so we're gonna look

397
00:16:58,230 --> 00:17:04,110
at a debugger here we're gonna look at

398
00:17:01,860 --> 00:17:05,959
the immunity debugger you can see that

399
00:17:04,109 --> 00:17:09,148
volunteers running I've got it loaded

400
00:17:05,959 --> 00:17:11,579
this here that we're that we're looking

401
00:17:09,148 --> 00:17:14,549
at that's actually the assembly language

402
00:17:11,579 --> 00:17:18,569
code right there that is push EBP and

403
00:17:14,549 --> 00:17:20,418
you know move a X those are assembly

404
00:17:18,569 --> 00:17:22,770
language instructions that are

405
00:17:20,419 --> 00:17:23,669
translated from our code that's how this

406
00:17:22,770 --> 00:17:26,638
program works

407
00:17:23,669 --> 00:17:28,710
I mentioned registers that's what's over

408
00:17:26,638 --> 00:17:30,300
here these are the registers so we've

409
00:17:28,710 --> 00:17:32,640
got EAX and

410
00:17:30,300 --> 00:17:33,930
ESP our stack planner that's one we're

411
00:17:32,640 --> 00:17:36,660
really going to want to pay attention to

412
00:17:33,930 --> 00:17:41,400
right here stack planner planning 222 f3

413
00:17:36,660 --> 00:17:45,480
AC right now we also see a IP so this

414
00:17:41,400 --> 00:17:49,050
because we know that e IP contains we

415
00:17:45,480 --> 00:17:50,910
know that e IP contains memory addresses

416
00:17:49,050 --> 00:17:53,190
of the next instruction and not the

417
00:17:50,910 --> 00:17:55,800
instruction itself this is a memory

418
00:17:53,190 --> 00:17:58,200
address that lives in ntdll and that's

419
00:17:55,800 --> 00:18:01,200
the next instruction that the programs

420
00:17:58,200 --> 00:18:04,650
can execute and we can go here we can

421
00:18:01,200 --> 00:18:07,830
look at the stack we can follow on stack

422
00:18:04,650 --> 00:18:10,380
so this is our stack here this is where

423
00:18:07,830 --> 00:18:14,040
ESP is currently planning we can see

424
00:18:10,380 --> 00:18:16,230
that there's data in the stack here our

425
00:18:14,040 --> 00:18:19,409
programs running everything's fine so

426
00:18:16,230 --> 00:18:23,760
let's go ahead and run this gonna run

427
00:18:19,410 --> 00:18:25,590
the module we're gonna see that it sends

428
00:18:23,760 --> 00:18:28,379
a bunch of input right so it starts at

429
00:18:25,590 --> 00:18:30,330
100 then 300 500 and it keeps saying t

430
00:18:28,380 --> 00:18:34,950
run complete just like we expected until

431
00:18:30,330 --> 00:18:38,100
we get to here 2100 bytes we send input

432
00:18:34,950 --> 00:18:42,000
but we don't get any response back from

433
00:18:38,100 --> 00:18:45,689
the server now if we were to go and take

434
00:18:42,000 --> 00:18:50,190
a look at our debugger we see that it is

435
00:18:45,690 --> 00:18:53,580
passé now and we see access violation

436
00:18:50,190 --> 00:18:56,460
when executing 41 41 41 41

437
00:18:53,580 --> 00:18:58,139
that means access violation when trying

438
00:18:56,460 --> 00:19:01,350
to execute the command that lives it 4

439
00:18:58,140 --> 00:19:04,470
to 1 41 41 41 we go up here there's no

440
00:19:01,350 --> 00:19:06,300
code there is no code here and if we

441
00:19:04,470 --> 00:19:08,640
look at our registers we submit see some

442
00:19:06,300 --> 00:19:12,120
interesting things we see that EAX has

443
00:19:08,640 --> 00:19:14,280
our command and then we see the ESP is

444
00:19:12,120 --> 00:19:18,649
pointing to a location that's filled

445
00:19:14,280 --> 00:19:18,649
with a z' that's what we sent the server

446
00:19:20,480 --> 00:19:24,820
one other

447
00:19:21,850 --> 00:19:28,870
want to point out here is that a IP is

448
00:19:24,820 --> 00:19:30,939
also 41 41 41 41 that's what that's what

449
00:19:28,870 --> 00:19:32,530
this means here that means e IP was

450
00:19:30,940 --> 00:19:35,260
populated with the memory address where

451
00:19:32,530 --> 00:19:37,660
it didn't know how to find code now if

452
00:19:35,260 --> 00:19:40,690
we were to go and look at this we'll

453
00:19:37,660 --> 00:19:43,240
follow it in stack we see here's our

454
00:19:40,690 --> 00:19:46,330
stack so this is currently the top of

455
00:19:43,240 --> 00:19:48,010
the stack we can see that there's a

456
00:19:46,330 --> 00:19:49,330
bunch of a s that happened before there

457
00:19:48,010 --> 00:19:51,400
and if we scroll up far enough we'd see

458
00:19:49,330 --> 00:19:56,379
T around space period and then we can

459
00:19:51,400 --> 00:19:58,570
see that they're a is afterwards now we

460
00:19:56,380 --> 00:20:00,789
know that from what we've already talked

461
00:19:58,570 --> 00:20:02,428
about the return address is something

462
00:20:00,789 --> 00:20:05,830
that gets pushed on the stack and then

463
00:20:02,429 --> 00:20:07,539
loaded into e IP so it's just a memory

464
00:20:05,830 --> 00:20:11,289
address that's pushed onto the stack

465
00:20:07,539 --> 00:20:13,539
if a I P is 41 41 41 we see that all

466
00:20:11,289 --> 00:20:18,970
these are 41 41 41 and these are all A's

467
00:20:13,539 --> 00:20:21,158
here that means that we have written

468
00:20:18,970 --> 00:20:23,049
overwritten the return address with our

469
00:20:21,159 --> 00:20:27,130
capital S and those capital a is were

470
00:20:23,049 --> 00:20:29,918
loaded interred D loaded into e IP this

471
00:20:27,130 --> 00:20:33,010
is an ASCII capital a in hex that's what

472
00:20:29,919 --> 00:20:35,169
41 is so we have overwritten a return

473
00:20:33,010 --> 00:20:38,770
address which subsequently got loaded

474
00:20:35,169 --> 00:20:40,330
into the IP we don't know how much data

475
00:20:38,770 --> 00:20:43,210
it took to get there we don't know

476
00:20:40,330 --> 00:20:47,110
anything at this point we just know that

477
00:20:43,210 --> 00:20:49,840
it was possible to do this so the key

478
00:20:47,110 --> 00:20:53,709
points here it took between 1900 and

479
00:20:49,840 --> 00:20:56,949
2100 bytes of input and when that

480
00:20:53,710 --> 00:20:58,539
happened VIP is overwritten with Ras so

481
00:20:56,950 --> 00:21:00,370
how do we find out if it's possible to

482
00:20:58,539 --> 00:21:03,780
know exactly how much data it would take

483
00:21:00,370 --> 00:21:06,010
before we over wrote the return address

484
00:21:03,780 --> 00:21:07,899
there are multiple ways to do it and I

485
00:21:06,010 --> 00:21:10,570
cover a different way in the slides that

486
00:21:07,900 --> 00:21:12,760
you can download but here I'm going to

487
00:21:10,570 --> 00:21:16,049
use pattern create which is a Metasploit

488
00:21:12,760 --> 00:21:19,720
utility it will create a non-repeating

489
00:21:16,049 --> 00:21:20,918
string of characters up up to about 20

490
00:21:19,720 --> 00:21:22,299
thousand bytes before it starts to

491
00:21:20,919 --> 00:21:24,520
repeat I forget exactly where it's at

492
00:21:22,299 --> 00:21:27,789
but you can see here I ran the command

493
00:21:24,520 --> 00:21:29,740
pattern create a shell 2500 it created

494
00:21:27,789 --> 00:21:32,620
this capital a little a zero capital a

495
00:21:29,740 --> 00:21:34,059
little a one so on and so forth and

496
00:21:32,620 --> 00:21:34,770
we're gonna send that to the server and

497
00:21:34,059 --> 00:21:37,950
see what

498
00:21:34,770 --> 00:21:40,650
happens so I've got another Python

499
00:21:37,950 --> 00:21:42,450
script here and I look at my Python

500
00:21:40,650 --> 00:21:44,130
script I don't have a list anymore

501
00:21:42,450 --> 00:21:47,300
because I'm just gonna send my can tear

502
00:21:44,130 --> 00:21:49,560
on space period I'm gonna add that

503
00:21:47,300 --> 00:21:51,600
string of characters that I generated

504
00:21:49,560 --> 00:21:55,020
with pattern create and I'm gonna send

505
00:21:51,600 --> 00:21:57,120
that to the server you see that bond

506
00:21:55,020 --> 00:22:01,950
server is running so let's go ahead and

507
00:21:57,120 --> 00:22:05,610
send that you send it program has

508
00:22:01,950 --> 00:22:08,160
crashed and if we go over here to our

509
00:22:05,610 --> 00:22:12,060
debugger we see that it has paused

510
00:22:08,160 --> 00:22:19,050
access violation when executing 3 9 6 F

511
00:22:12,060 --> 00:22:21,450
4 3 3 8 look up here there's no code we

512
00:22:19,050 --> 00:22:25,800
see that E I P is what we expect 3 9 6 F

513
00:22:21,450 --> 00:22:27,900
4 3 3 8 excuse me IP and if we look at

514
00:22:25,800 --> 00:22:30,990
ESP let me see it's pointing to this

515
00:22:27,900 --> 00:22:35,880
memory location that's filled with

516
00:22:30,990 --> 00:22:39,000
capital C lowercase P Zero and a/c so

517
00:22:35,880 --> 00:22:43,980
let's go ahead and look at this let's go

518
00:22:39,000 --> 00:22:46,860
down right here we see a bunch of data

519
00:22:43,980 --> 00:22:49,530
in the stack and if we look immediately

520
00:22:46,860 --> 00:22:51,540
before where the SP is pointing so if

521
00:22:49,530 --> 00:22:53,910
you remember that slide about the top of

522
00:22:51,540 --> 00:22:57,090
stack this is where the top of stack is

523
00:22:53,910 --> 00:23:00,480
pointing right here we see here 3 9 6 F

524
00:22:57,090 --> 00:23:03,179
4 3 3 8 it's the same value that's any

525
00:23:00,480 --> 00:23:05,730
IP in fact that's because this is where

526
00:23:03,180 --> 00:23:09,260
the return address lives in the input we

527
00:23:05,730 --> 00:23:13,290
loaded that return address into e IP and

528
00:23:09,260 --> 00:23:15,360
then it crashed 3 9 6 F 4 3 3 8 now

529
00:23:13,290 --> 00:23:17,580
since we know that those 40 ones were

530
00:23:15,360 --> 00:23:20,550
actually the capital a is this must be

531
00:23:17,580 --> 00:23:22,620
ascii hex representations of ascii

532
00:23:20,550 --> 00:23:26,570
characters here and in fact they are a

533
00:23:22,620 --> 00:23:31,709
39 is a nine if 38 is an eight but wait

534
00:23:26,570 --> 00:23:33,960
if we look here it's 8 c 0 9 or 8 c o9

535
00:23:31,710 --> 00:23:36,210
but we look here the 9 is on the left

536
00:23:33,960 --> 00:23:39,270
and the 8 is on the right the reason is

537
00:23:36,210 --> 00:23:41,280
because we are on a little endian system

538
00:23:39,270 --> 00:23:43,139
so data gets pushed on the stack and

539
00:23:41,280 --> 00:23:45,780
reverse byte order if we were big endian

540
00:23:43,140 --> 00:23:48,750
smalls and popping mainframes our stack

541
00:23:45,780 --> 00:23:51,149
would be our system would be big and

542
00:23:48,750 --> 00:23:53,760
so we would just push it in in the order

543
00:23:51,150 --> 00:23:55,140
that we wanted but it is not it's Little

544
00:23:53,760 --> 00:23:56,820
Indians so we have to push it in Reverse

545
00:23:55,140 --> 00:24:01,460
byte order helpfully immunity has

546
00:23:56,820 --> 00:24:03,990
reversed that for us so we know now that

547
00:24:01,460 --> 00:24:05,760
this is where that's occurring we still

548
00:24:03,990 --> 00:24:07,740
don't know how many bytes it is but we

549
00:24:05,760 --> 00:24:10,200
know that as soon as the overflow occurs

550
00:24:07,740 --> 00:24:12,360
the stack pointer is pointing to the

551
00:24:10,200 --> 00:24:15,120
next section of data after where the

552
00:24:12,360 --> 00:24:19,290
return address was we're gonna write

553
00:24:15,120 --> 00:24:23,790
down 3 9 6 f 4 3 3 8 we're gonna go back

554
00:24:19,290 --> 00:24:26,340
and look at another utility now what

555
00:24:23,790 --> 00:24:29,460
we're gonna look at is the compliment to

556
00:24:26,340 --> 00:24:33,480
pattern create which is something called

557
00:24:29,460 --> 00:24:37,080
pattern offset we've run pattern offset

558
00:24:33,480 --> 00:24:40,950
- cue 3 9 6 f 4 3 3 8 it tells us the

559
00:24:37,080 --> 00:24:44,040
exact match is at offset 2006 so what

560
00:24:40,950 --> 00:24:47,790
that means is it took exactly 2006 bytes

561
00:24:44,040 --> 00:24:51,450
of input before we reached the first

562
00:24:47,790 --> 00:24:55,470
byte of our return address so knowing

563
00:24:51,450 --> 00:24:59,610
that if we were to safe put in 2006 a s

564
00:24:55,470 --> 00:25:03,210
and then four B's and 50 sees the return

565
00:24:59,610 --> 00:25:05,969
address should be populated with 42 42

566
00:25:03,210 --> 00:25:11,970
42 42 which means that's what a IP

567
00:25:05,970 --> 00:25:15,270
should be when the program crashes so

568
00:25:11,970 --> 00:25:17,700
let's take a look at that got another

569
00:25:15,270 --> 00:25:18,870
Python script here and that's exactly

570
00:25:17,700 --> 00:25:23,040
what we're doing we're sending our

571
00:25:18,870 --> 00:25:26,870
command some 2006 a's four B's a bunch

572
00:25:23,040 --> 00:25:36,899
of seas and we expect the e IP will be

573
00:25:26,870 --> 00:25:40,320
42 42 42 alright so let's look access

574
00:25:36,900 --> 00:25:42,930
violation when executing 42 42 42 42 so

575
00:25:40,320 --> 00:25:44,639
now we know that it is exactly 2006 by

576
00:25:42,930 --> 00:25:48,330
its before we reach the first byte of

577
00:25:44,640 --> 00:25:49,800
the return address VIP is 42 we see that

578
00:25:48,330 --> 00:25:52,379
the stack pointer seems to be pointing

579
00:25:49,800 --> 00:25:55,440
to a location that's filled with C's we

580
00:25:52,380 --> 00:25:57,540
follow the stack we see just as we

581
00:25:55,440 --> 00:26:00,720
expected the bees were right before the

582
00:25:57,540 --> 00:26:03,860
C's started so now

583
00:26:00,720 --> 00:26:07,049
we know that when the program crashes

584
00:26:03,860 --> 00:26:11,879
data that we control was loaded into EIP

585
00:26:07,049 --> 00:26:13,918
and immediately following that is where

586
00:26:11,880 --> 00:26:16,350
our shellcode could go if we were able

587
00:26:13,919 --> 00:26:19,140
to inject shellcode and the stack

588
00:26:16,350 --> 00:26:21,120
pointer is pointing to that so it would

589
00:26:19,140 --> 00:26:23,490
be really cool if we could have a way of

590
00:26:21,120 --> 00:26:26,189
telling the computer go to where ESP is

591
00:26:23,490 --> 00:26:29,280
go to ESP and execute code and in fact

592
00:26:26,190 --> 00:26:32,730
there is an instruction called jump ESP

593
00:26:29,280 --> 00:26:37,049
that tells the processor to jump to the

594
00:26:32,730 --> 00:26:39,270
location that ESP is referencing so we

595
00:26:37,049 --> 00:26:41,039
can go to ESP but we can't just put jump

596
00:26:39,270 --> 00:26:42,150
ESPN I'll show you how to look up the OP

597
00:26:41,039 --> 00:26:44,158
code for that cuz that's going to be

598
00:26:42,150 --> 00:26:45,450
important but we can't just put that

599
00:26:44,159 --> 00:26:48,650
into these bytes where the bees are

600
00:26:45,450 --> 00:26:51,570
because remember that return address is

601
00:26:48,650 --> 00:26:53,760
exactly that it's an address it's not an

602
00:26:51,570 --> 00:26:57,178
instruction so we can't put the OP code

603
00:26:53,760 --> 00:26:59,850
for jump ESP in there because we're just

604
00:26:57,179 --> 00:27:01,610
gonna get an access violation when

605
00:26:59,850 --> 00:27:06,918
trying to load whatever that off code is

606
00:27:01,610 --> 00:27:11,928
so we need to find the we need to find

607
00:27:06,919 --> 00:27:14,309
something called NASM shell excuse me

608
00:27:11,929 --> 00:27:16,679
another Metasploit utility if we use

609
00:27:14,309 --> 00:27:18,658
NASM shell and we put in jump ESP will

610
00:27:16,679 --> 00:27:26,220
tell us that the OP code for that is FF

611
00:27:18,659 --> 00:27:28,140
e for so we can't put FF e for into that

612
00:27:26,220 --> 00:27:29,250
into the returned address because the

613
00:27:28,140 --> 00:27:30,870
computer's not gonna know what to do

614
00:27:29,250 --> 00:27:34,230
with that we need to find a memory

615
00:27:30,870 --> 00:27:37,168
address where the FF v4 lives so to do

616
00:27:34,230 --> 00:27:40,710
that in immunity I'm going to use a

617
00:27:37,169 --> 00:27:43,200
script called Mona Mona is written by

618
00:27:40,710 --> 00:27:47,070
coral and some great people peter is

619
00:27:43,200 --> 00:27:49,470
wonderful and if we load Mona one of the

620
00:27:47,070 --> 00:27:52,320
things we're gonna do got a clue right

621
00:27:49,470 --> 00:27:57,240
here module C windows system32 user is

622
00:27:52,320 --> 00:28:00,450
32 that DLL gonna run bang Mona modules

623
00:27:57,240 --> 00:28:02,640
and modules are dll's

624
00:28:00,450 --> 00:28:06,030
and other bits of code that are loaded

625
00:28:02,640 --> 00:28:07,890
with our program that these dll's are

626
00:28:06,030 --> 00:28:10,200
needed for our program to run like if we

627
00:28:07,890 --> 00:28:12,480
want to have networking we're gonna need

628
00:28:10,200 --> 00:28:14,640
networking capabilities loaded by dll's

629
00:28:12,480 --> 00:28:16,140
so we see a bunch of you

630
00:28:14,640 --> 00:28:18,270
you know things that probably look

631
00:28:16,140 --> 00:28:22,800
familiar to a lot of you usually 32 and

632
00:28:18,270 --> 00:28:24,150
ntdll kernel32.dll most of these all

633
00:28:22,800 --> 00:28:26,790
look familiar and then we see Vaughn

634
00:28:24,150 --> 00:28:30,150
server itself and something else called

635
00:28:26,790 --> 00:28:34,070
ESS funky DLL which happens to be looks

636
00:28:30,150 --> 00:28:38,490
like part of Vaughn server now over here

637
00:28:34,070 --> 00:28:41,939
these are memory addresses these are

638
00:28:38,490 --> 00:28:45,570
memory addresses where that DLL is is

639
00:28:41,940 --> 00:28:47,490
living so if we could find a location

640
00:28:45,570 --> 00:28:50,250
within this memory space a memory that

641
00:28:47,490 --> 00:28:52,230
has a jump ESP we could use it a couple

642
00:28:50,250 --> 00:28:54,030
of things point out one thing we want to

643
00:28:52,230 --> 00:28:55,020
pay attention to a SLR there's no

644
00:28:54,030 --> 00:28:57,389
address space layout randomization

645
00:28:55,020 --> 00:29:01,260
meaning we don't have to deal with that

646
00:28:57,390 --> 00:29:05,580
because this is 101 level another thing

647
00:29:01,260 --> 00:29:08,490
to point out here OS dll's so os dll's

648
00:29:05,580 --> 00:29:10,500
means that these are loaded with part of

649
00:29:08,490 --> 00:29:12,090
the operating system or not like our

650
00:29:10,500 --> 00:29:18,360
program here a third party that we've

651
00:29:12,090 --> 00:29:21,360
loaded now what we want to look for is a

652
00:29:18,360 --> 00:29:27,810
jump ESP and FF II for living in one of

653
00:29:21,360 --> 00:29:31,770
these modules these OS lo these OS dll's

654
00:29:27,810 --> 00:29:34,200
could be used for finding a jump ESP and

655
00:29:31,770 --> 00:29:36,389
we could do that let's say we find a

656
00:29:34,200 --> 00:29:38,460
jump ESP and usually 32 that DLL I can

657
00:29:36,390 --> 00:29:41,850
use that right now and that would be

658
00:29:38,460 --> 00:29:45,660
fine the problem is that these addresses

659
00:29:41,850 --> 00:29:48,030
vary depending on what patch level on

660
00:29:45,660 --> 00:29:49,320
what service pack you're on even what

661
00:29:48,030 --> 00:29:52,110
language pack you're on if you're

662
00:29:49,320 --> 00:29:53,550
running XP service pack 3 French

663
00:29:52,110 --> 00:29:55,290
language pack and I'm running English

664
00:29:53,550 --> 00:29:57,120
jump ESP might be in a different

665
00:29:55,290 --> 00:29:59,190
location for you than it is for me and

666
00:29:57,120 --> 00:30:00,570
that's part of the reason why if you've

667
00:29:59,190 --> 00:30:02,310
ever use Metasploit and asked you to

668
00:30:00,570 --> 00:30:04,290
select your target sometimes you need to

669
00:30:02,310 --> 00:30:05,970
do that so that it knows which return

670
00:30:04,290 --> 00:30:09,780
address to use for that particular

671
00:30:05,970 --> 00:30:11,580
exploit so we could use these but we

672
00:30:09,780 --> 00:30:13,230
don't want to because we would have to

673
00:30:11,580 --> 00:30:15,629
be able to fingerprint the targets know

674
00:30:13,230 --> 00:30:18,880
exactly what OS it's running and past

675
00:30:15,630 --> 00:30:20,800
level when we wanted XY

676
00:30:18,880 --> 00:30:25,510
but if there happens to be one here in

677
00:30:20,800 --> 00:30:27,460
ESS funk DLL we could use that one

678
00:30:25,510 --> 00:30:29,350
because this is something that's bundled

679
00:30:27,460 --> 00:30:32,200
with our program it's going to be there

680
00:30:29,350 --> 00:30:35,949
as long as we're running version 1.0 a

681
00:30:32,200 --> 00:30:38,190
Vaughn server every time that jump ESP

682
00:30:35,950 --> 00:30:41,710
should be in the same place every time

683
00:30:38,190 --> 00:30:43,780
so we can use Moana to find those so

684
00:30:41,710 --> 00:30:48,660
we're gonna use another command Mona

685
00:30:43,780 --> 00:30:52,980
find - s oops

686
00:30:48,660 --> 00:30:58,810
remember that our opcode is FF e for and

687
00:30:52,980 --> 00:31:01,300
then we use shim is s funk dll tells it

688
00:30:58,810 --> 00:31:05,560
to search within that module so we run

689
00:31:01,300 --> 00:31:07,750
it we find a total of nine pointers so

690
00:31:05,560 --> 00:31:11,620
that means there are nine jump PS PS in

691
00:31:07,750 --> 00:31:14,320
this particular DLL you can see here the

692
00:31:11,620 --> 00:31:18,399
first ones 6250 11 AF all the way down

693
00:31:14,320 --> 00:31:20,830
to 60 250 12:05 they're all happening to

694
00:31:18,400 --> 00:31:23,040
be living in a place called page execute

695
00:31:20,830 --> 00:31:26,730
read meaning we have executable memory

696
00:31:23,040 --> 00:31:31,600
so we can load this address for instance

697
00:31:26,730 --> 00:31:36,100
6250 11 AF if we put 6250 11 AF into the

698
00:31:31,600 --> 00:31:40,090
return address 6250 11 AF will be loaded

699
00:31:36,100 --> 00:31:43,149
into eip the processor will then say -

700
00:31:40,090 --> 00:31:44,620
next instruction is at 6250 11 1/2 it

701
00:31:43,150 --> 00:31:47,170
will go to that location that will see

702
00:31:44,620 --> 00:31:50,020
that that location says jump ESP will

703
00:31:47,170 --> 00:31:53,260
now jump to where the stack pointer is

704
00:31:50,020 --> 00:31:56,710
pointing to which happens to be the

705
00:31:53,260 --> 00:31:58,990
start of our shellcode so this is all we

706
00:31:56,710 --> 00:32:01,000
need to be able to exploit the system we

707
00:31:58,990 --> 00:32:02,590
just need to build the shellcode in the

708
00:32:01,000 --> 00:32:06,360
right manner and put everything together

709
00:32:02,590 --> 00:32:10,090
so we have one more piece to do that

710
00:32:06,360 --> 00:32:14,050
I've got a proof of concept that will

711
00:32:10,090 --> 00:32:15,970
pop calc or something like it so I've

712
00:32:14,050 --> 00:32:18,490
got my command T around space period I

713
00:32:15,970 --> 00:32:24,180
generated some shell code with MSF venom

714
00:32:18,490 --> 00:32:28,780
and I used platform windows architecture

715
00:32:24,180 --> 00:32:30,350
x86 I'm using the windows exec payload

716
00:32:28,780 --> 00:32:33,470
and I want to run

717
00:32:30,350 --> 00:32:37,340
and dot exe /c calc daddy XE I'm gonna

718
00:32:33,470 --> 00:32:42,169
pop calc exit func equals threat I will

719
00:32:37,340 --> 00:32:44,120
talk about and I know there are some of

720
00:32:42,169 --> 00:32:46,280
you in the chat right now they are much

721
00:32:44,120 --> 00:32:49,789
better versed in this than I am so feel

722
00:32:46,280 --> 00:32:51,110
free feel free to clarify if I'm if I'm

723
00:32:49,789 --> 00:32:54,679
screwing up some of this language at

724
00:32:51,110 --> 00:32:56,149
some point so we're using exit func

725
00:32:54,679 --> 00:32:59,570
equals thread and I'll tell you why in a

726
00:32:56,150 --> 00:33:04,370
little bit - II encoder I'm gonna use

727
00:32:59,570 --> 00:33:06,168
the x86 Shikata gunaih encoder - b means

728
00:33:04,370 --> 00:33:08,840
bad characters now you remember I told

729
00:33:06,169 --> 00:33:10,730
you that strengths in C and C++ are null

730
00:33:08,840 --> 00:33:12,799
terminated that's what this is right

731
00:33:10,730 --> 00:33:15,679
here it's a null terminator reason we

732
00:33:12,799 --> 00:33:17,450
don't want our shellcode to contain a

733
00:33:15,679 --> 00:33:18,799
null terminator is because that would

734
00:33:17,450 --> 00:33:20,840
signify it to the server

735
00:33:18,799 --> 00:33:22,549
be like oh hey there's the end of the

736
00:33:20,840 --> 00:33:23,780
input I can start doing my thing and it

737
00:33:22,549 --> 00:33:24,980
would drop it would just truncate off

738
00:33:23,780 --> 00:33:29,030
the rest of our shell code nothing's

739
00:33:24,980 --> 00:33:31,370
gonna work we also have 0 + 0 D carriage

740
00:33:29,030 --> 00:33:33,649
return in line feed because we know that

741
00:33:31,370 --> 00:33:35,658
our protocol signifies the end of input

742
00:33:33,650 --> 00:33:37,549
by sending a carriage return line field

743
00:33:35,659 --> 00:33:39,470
so we don't want our shellcode to

744
00:33:37,549 --> 00:33:44,809
contain any of these characters so that

745
00:33:39,470 --> 00:33:48,620
we don't get truncated now I'm gonna run

746
00:33:44,809 --> 00:33:50,899
this this is my shellcode here this is

747
00:33:48,620 --> 00:33:53,330
my return address right here and

748
00:33:50,900 --> 00:33:56,510
remember it's little endian system so

749
00:33:53,330 --> 00:34:00,320
6250 11 AF it's backwards we need to

750
00:33:56,510 --> 00:34:02,090
push it in in Reverse byte order so now

751
00:34:00,320 --> 00:34:04,399
what we're gonna send to the server is

752
00:34:02,090 --> 00:34:06,799
our command T run space period we're

753
00:34:04,400 --> 00:34:07,880
gonna send in 2006 days you don't have

754
00:34:06,799 --> 00:34:10,850
to use a s

755
00:34:07,880 --> 00:34:13,280
you could use any number of characters

756
00:34:10,850 --> 00:34:16,639
right I'm just using a is to make it

757
00:34:13,280 --> 00:34:20,119
easy my return address is going

758
00:34:16,639 --> 00:34:23,810
immediately after those 2006 days I'm

759
00:34:20,119 --> 00:34:27,139
gonna use 8 hex 90s

760
00:34:23,810 --> 00:34:28,699
no ops or knops they just tell the

761
00:34:27,139 --> 00:34:30,080
processor don't do anything and the

762
00:34:28,699 --> 00:34:33,368
reason why I will explain in a minute

763
00:34:30,080 --> 00:34:35,389
and then after that is my shellcode and

764
00:34:33,369 --> 00:34:38,960
then I'm just gonna send that to the

765
00:34:35,389 --> 00:34:41,510
server we know that we're running so

766
00:34:38,960 --> 00:34:43,320
let's go ahead and send it to the server

767
00:34:41,510 --> 00:34:45,270
sadly this doesn't come to the

768
00:34:43,320 --> 00:34:47,910
foreground like I like it but I got a

769
00:34:45,270 --> 00:34:51,840
click on it but that is the exploit we

770
00:34:47,909 --> 00:34:53,370
just exploited bone server and we

771
00:34:51,840 --> 00:34:56,010
displayed this instead of pop in calc

772
00:34:53,370 --> 00:34:58,049
and the reason I chose this is because

773
00:34:56,010 --> 00:34:59,640
honestly that's still kind of how I feel

774
00:34:58,050 --> 00:35:01,410
every time I get about for overflow

775
00:34:59,640 --> 00:35:03,299
working and this is how I felt most

776
00:35:01,410 --> 00:35:05,640
definitely the first time I ever did I

777
00:35:03,300 --> 00:35:08,910
did the shell dance in my office when I

778
00:35:05,640 --> 00:35:10,680
got that because it was a magical

779
00:35:08,910 --> 00:35:12,779
feeling when I when I went on my own

780
00:35:10,680 --> 00:35:15,060
without following someone's instructions

781
00:35:12,780 --> 00:35:16,710
I took the things that I've talked to

782
00:35:15,060 --> 00:35:21,660
you about here and I learned how they

783
00:35:16,710 --> 00:35:23,370
work and I practiced and I found a

784
00:35:21,660 --> 00:35:26,069
buffer overflow in a program that wasn't

785
00:35:23,370 --> 00:35:27,930
bone server and then I figured out how

786
00:35:26,070 --> 00:35:29,880
much data did it take till I could

787
00:35:27,930 --> 00:35:34,940
overwrite the return address and then I

788
00:35:29,880 --> 00:35:34,940
located a jump ESP and then I put it all

789
00:35:37,710 --> 00:35:41,730
together was shellcode and then I was

790
00:35:39,359 --> 00:35:44,400
able to go it was absolutely magical

791
00:35:41,730 --> 00:35:46,920
feeling and so that's why I decided to

792
00:35:44,400 --> 00:35:48,720
choose this instead of popping calc now

793
00:35:46,920 --> 00:35:50,460
one fun thing I want to point out if I

794
00:35:48,720 --> 00:35:53,189
can find the mouse there we go we look

795
00:35:50,460 --> 00:35:56,099
down here we're still running one server

796
00:35:53,190 --> 00:36:00,089
didn't crash this time and if we look

797
00:35:56,099 --> 00:36:02,579
here we have an idea why thread 9e for

798
00:36:00,089 --> 00:36:08,180
terminated now if you remember back in

799
00:36:02,579 --> 00:36:12,569
the code I used boy where did that go

800
00:36:08,180 --> 00:36:15,868
wrong one I use exit func equals thread

801
00:36:12,569 --> 00:36:18,690
that tells that tells Metasploit to

802
00:36:15,869 --> 00:36:21,119
generate code to generate a new thread

803
00:36:18,690 --> 00:36:23,249
so my ex-wife takes place in a new

804
00:36:21,119 --> 00:36:24,839
thread and execution control returns

805
00:36:23,249 --> 00:36:28,680
back to the program and the program

806
00:36:24,839 --> 00:36:31,499
doesn't crash if I had done process then

807
00:36:28,680 --> 00:36:35,730
the program would crash when I closed

808
00:36:31,499 --> 00:36:39,749
Explorer so I'm chosen

809
00:36:35,730 --> 00:36:41,789
I want the thing to keep running now the

810
00:36:39,749 --> 00:36:44,759
other thing that I want to show you is

811
00:36:41,789 --> 00:36:48,359
because I did that I could run it again

812
00:36:44,759 --> 00:36:51,239
and go back I can I can run it a few

813
00:36:48,359 --> 00:36:53,670
more times and we're still running and

814
00:36:51,239 --> 00:36:56,039
every time we're just generating new

815
00:36:53,670 --> 00:37:00,390
threads and then they're executing and

816
00:36:56,039 --> 00:37:02,069
the program still working the other

817
00:37:00,390 --> 00:37:05,578
thing I told you I'd tell you about is

818
00:37:02,069 --> 00:37:09,480
why I had those those hex 90s in there

819
00:37:05,579 --> 00:37:10,980
now the hex 90s are in there because

820
00:37:09,480 --> 00:37:14,609
they're they're just telling the

821
00:37:10,980 --> 00:37:16,710
processor not to do anything but they're

822
00:37:14,609 --> 00:37:19,410
really there because they're scratch

823
00:37:16,710 --> 00:37:21,539
space we used an encoder and when you

824
00:37:19,410 --> 00:37:27,029
use encoded shellcode it's just like

825
00:37:21,539 --> 00:37:29,009
base64 data right it's encoded but you

826
00:37:27,029 --> 00:37:31,019
can't do anything with it until it's

827
00:37:29,009 --> 00:37:33,089
decoded our shellcode has been encoded

828
00:37:31,019 --> 00:37:35,279
so it's not actually shellcode it's

829
00:37:33,089 --> 00:37:37,200
something that's encoded what there is

830
00:37:35,279 --> 00:37:39,210
is a little bit of a stub at the

831
00:37:37,200 --> 00:37:41,819
beginning of the shellcode that tells

832
00:37:39,210 --> 00:37:42,329
the processor how to decode the rest of

833
00:37:41,819 --> 00:37:44,549
the shellcode

834
00:37:42,329 --> 00:37:46,890
and those nops are in there for a

835
00:37:44,549 --> 00:37:50,190
scratch space so that we don't overwrite

836
00:37:46,890 --> 00:37:51,270
our shellcode this gives us the space to

837
00:37:50,190 --> 00:37:52,890
decode without

838
00:37:51,270 --> 00:37:54,960
decoding over ourselves and clobbering

839
00:37:52,890 --> 00:37:58,680
our x-play so when we put this all

840
00:37:54,960 --> 00:38:02,430
together we've gone from hey what is

841
00:37:58,680 --> 00:38:06,660
Vaughn server - hey I know how to fuzz

842
00:38:02,430 --> 00:38:08,460
this application and I can make it crash

843
00:38:06,660 --> 00:38:12,060
and I can exploit it and make it still

844
00:38:08,460 --> 00:38:14,130
run so what do you do after this like

845
00:38:12,060 --> 00:38:17,340
okay I learn bone server but what do I

846
00:38:14,130 --> 00:38:20,070
do next there are places that you can go

847
00:38:17,340 --> 00:38:22,020
to find vulnerable programs there's lots

848
00:38:20,070 --> 00:38:24,150
of them on the Internet one fun place is

849
00:38:22,020 --> 00:38:25,980
just going to exploit database you can

850
00:38:24,150 --> 00:38:28,500
search for these old buffer overflows

851
00:38:25,980 --> 00:38:30,980
look for the early to mid-2000s buffer

852
00:38:28,500 --> 00:38:33,330
overflows some are even later than that

853
00:38:30,980 --> 00:38:35,520
if you've got these buffer overflows for

854
00:38:33,330 --> 00:38:37,110
instance in many share the nice thing

855
00:38:35,520 --> 00:38:40,140
about this is you can download the

856
00:38:37,110 --> 00:38:43,290
vulnerable application from exploit

857
00:38:40,140 --> 00:38:44,670
database and you can use their buffer

858
00:38:43,290 --> 00:38:46,320
overflow that they've got an exploit

859
00:38:44,670 --> 00:38:47,790
database is a starting point to just

860
00:38:46,320 --> 00:38:49,430
help you understand and then start

861
00:38:47,790 --> 00:38:51,360
working it on your own

862
00:38:49,430 --> 00:38:56,368
excuse me but you can download these

863
00:38:51,360 --> 00:38:58,380
programs and you can fuzz them using the

864
00:38:56,369 --> 00:39:01,050
exact same process excuse me I showed

865
00:38:58,380 --> 00:39:04,230
you there's even a bunch of mp3 players

866
00:39:01,050 --> 00:39:07,080
back in the mid-2000s that were

867
00:39:04,230 --> 00:39:09,470
vulnerable to buffer overflows because

868
00:39:07,080 --> 00:39:12,950
of these badly formatted m3u playlists

869
00:39:09,470 --> 00:39:15,149
the process for doing that is not

870
00:39:12,950 --> 00:39:16,529
fundamental fundamental II different

871
00:39:15,150 --> 00:39:18,359
than what I did here it's just that

872
00:39:16,530 --> 00:39:20,880
instead of sending a bunch of data to a

873
00:39:18,359 --> 00:39:23,730
socket we would have to generate a bunch

874
00:39:20,880 --> 00:39:25,020
of m3u playlists and then open up each

875
00:39:23,730 --> 00:39:27,150
one of them until we figured out how

876
00:39:25,020 --> 00:39:28,800
much data we needed to overwrite the

877
00:39:27,150 --> 00:39:32,940
return address but you can take this

878
00:39:28,800 --> 00:39:35,730
process absolutely and use this to do

879
00:39:32,940 --> 00:39:37,890
your own buffer overflow on a vulnerable

880
00:39:35,730 --> 00:39:39,570
application so I told you there would be

881
00:39:37,890 --> 00:39:40,740
some resources and those are coming up

882
00:39:39,570 --> 00:39:43,109
but I do have to thank some people

883
00:39:40,740 --> 00:39:44,790
stephen bradshaw for writing bone server

884
00:39:43,109 --> 00:39:48,330
something that I could use to start

885
00:39:44,790 --> 00:39:48,779
practicing buffer overflows if you know

886
00:39:48,330 --> 00:39:51,690
Peter

887
00:39:48,780 --> 00:39:54,900
corland coder a wonderful human being

888
00:39:51,690 --> 00:39:57,690
and full of excellent information about

889
00:39:54,900 --> 00:40:00,440
buffer overflows learned a lot there

890
00:39:57,690 --> 00:40:02,650
ronbo is skull security if you know Ron

891
00:40:00,440 --> 00:40:04,150
Ron is a

892
00:40:02,650 --> 00:40:06,370
wizard and has a lot of great

893
00:40:04,150 --> 00:40:08,860
information on the skull security wiki I

894
00:40:06,370 --> 00:40:10,569
also want to thank these people for

895
00:40:08,860 --> 00:40:12,460
these some good friends of mine that

896
00:40:10,570 --> 00:40:14,500
they encourage me to do this talk and

897
00:40:12,460 --> 00:40:16,270
then spent a lot of time helping me

898
00:40:14,500 --> 00:40:18,460
refine this to make sure that what I was

899
00:40:16,270 --> 00:40:20,730
telling you was exactly the information

900
00:40:18,460 --> 00:40:23,470
that you needed without being too much

901
00:40:20,730 --> 00:40:27,400
without leaving things out so thanks to

902
00:40:23,470 --> 00:40:30,069
all these guys you can download vulvar

903
00:40:27,400 --> 00:40:34,780
at that link and you can download moana

904
00:40:30,070 --> 00:40:37,150
from coral and github and then there are

905
00:40:34,780 --> 00:40:38,950
seven buffer overflow blogs that you can

906
00:40:37,150 --> 00:40:40,540
follow the first happens to be Steven

907
00:40:38,950 --> 00:40:43,210
Bradshaw's and we'll walk you through

908
00:40:40,540 --> 00:40:45,880
various kinds of buffer overflows with

909
00:40:43,210 --> 00:40:49,030
bone server core lan also has a great

910
00:40:45,880 --> 00:40:51,160
series of buffer overflow tutorials that

911
00:40:49,030 --> 00:40:53,290
go from easy to progressively more

912
00:40:51,160 --> 00:40:55,299
complex and there's another one from

913
00:40:53,290 --> 00:40:57,250
security sift there as well and by all

914
00:40:55,300 --> 00:40:59,770
means just search on the internet you'll

915
00:40:57,250 --> 00:41:01,690
find so many know that some of them were

916
00:40:59,770 --> 00:41:02,890
poorly written in and that's just how it

917
00:41:01,690 --> 00:41:06,190
goes and some of them are really well

918
00:41:02,890 --> 00:41:09,129
done here's some resources just

919
00:41:06,190 --> 00:41:11,410
background material for you stack buffer

920
00:41:09,130 --> 00:41:13,600
overflows and how the stack works and

921
00:41:11,410 --> 00:41:16,990
then a link to some fundamentals from

922
00:41:13,600 --> 00:41:19,060
Skull security and there are some other

923
00:41:16,990 --> 00:41:21,370
places you can practice over the wire

924
00:41:19,060 --> 00:41:23,710
still has the over wire war gaming

925
00:41:21,370 --> 00:41:27,220
network that has things like smash the

926
00:41:23,710 --> 00:41:28,930
stack or a game and other games on there

927
00:41:27,220 --> 00:41:32,649
that you can practice buffer overflows

928
00:41:28,930 --> 00:41:33,520
and other kinds of security relevant

929
00:41:32,650 --> 00:41:35,470
skills

930
00:41:33,520 --> 00:41:39,250
there are also VMs you can download on

931
00:41:35,470 --> 00:41:40,839
volta ball hub that have buffer

932
00:41:39,250 --> 00:41:44,410
overflows in them that you can attack

933
00:41:40,840 --> 00:41:46,150
there also are I believe there they're

934
00:41:44,410 --> 00:41:48,850
still there and I think they're

935
00:41:46,150 --> 00:41:50,620
available for the free accounts buffer

936
00:41:48,850 --> 00:41:51,910
overflow resources at hack the box I

937
00:41:50,620 --> 00:41:54,220
know that they have had them in the past

938
00:41:51,910 --> 00:41:57,910
I haven't checked quite recently but I

939
00:41:54,220 --> 00:42:02,589
believe they have them there so with

940
00:41:57,910 --> 00:42:04,390
that I apparently was really juiced up

941
00:42:02,590 --> 00:42:07,330
because I'm about three minutes ahead of

942
00:42:04,390 --> 00:42:09,069
time but someone just asked will the

943
00:42:07,330 --> 00:42:11,740
slides be available yes if you look at

944
00:42:09,070 --> 00:42:14,140
the slide that is on the screen right

945
00:42:11,740 --> 00:42:16,439
now you can get the slides at red siege

946
00:42:14,140 --> 00:42:20,190
comm /e IP

947
00:42:16,440 --> 00:42:24,450
you can get the you know what that link

948
00:42:20,190 --> 00:42:26,609
for the source is wrong it's I'll have

949
00:42:24,450 --> 00:42:28,319
to update that and I'll tweet it out you

950
00:42:26,609 --> 00:42:29,460
can follow the hard water hacker twitter

951
00:42:28,319 --> 00:42:32,160
account for the red seeds twitter

952
00:42:29,460 --> 00:42:34,500
account but it's actually i underscore

953
00:42:32,160 --> 00:42:36,270
its I want my e IP with underscores

954
00:42:34,500 --> 00:42:38,160
instead of spaces or just go to

955
00:42:36,270 --> 00:42:40,829
github.com slash hard water hacker and

956
00:42:38,160 --> 00:42:42,839
you will find the Python scripts that I

957
00:42:40,829 --> 00:42:44,040
used here and do not judge me based on

958
00:42:42,839 --> 00:42:46,680
the code that you find in that

959
00:42:44,040 --> 00:42:49,680
repository because I'm a hacker I'm not

960
00:42:46,680 --> 00:42:51,750
a developer so if you have any questions

961
00:42:49,680 --> 00:42:54,450
about this feel free to contact me I

962
00:42:51,750 --> 00:42:56,069
reach out to me on Twitter please if you

963
00:42:54,450 --> 00:42:58,140
want follow the Red Sea Twitter account

964
00:42:56,069 --> 00:43:00,089
because that will give you information

965
00:42:58,140 --> 00:43:02,279
about our new blogs that are coming out

966
00:43:00,089 --> 00:43:06,420
and when we're doing our free webcasts

967
00:43:02,280 --> 00:43:08,700
and I'm all about helping people learn

968
00:43:06,420 --> 00:43:10,319
because that's how I got here people

969
00:43:08,700 --> 00:43:13,950
helped me learn and answered questions

970
00:43:10,319 --> 00:43:15,839
that quite frankly I just you know

971
00:43:13,950 --> 00:43:17,640
didn't know where to go people helped me

972
00:43:15,839 --> 00:43:20,730
and I want to try to return that so feel

973
00:43:17,640 --> 00:43:23,009
free to contact me on on Twitter or

974
00:43:20,730 --> 00:43:27,660
whatever my contacts information is here

975
00:43:23,010 --> 00:43:31,650
on the slide so that's all I have at

976
00:43:27,660 --> 00:43:33,540
this point and yeah Chris I'm gonna have

977
00:43:31,650 --> 00:43:34,920
to rewatch it again that's that's how it

978
00:43:33,540 --> 00:43:38,790
is for me I took quite a while

979
00:43:34,920 --> 00:43:42,810
rewatching it at at speeds so I want to

980
00:43:38,790 --> 00:43:45,180
thank all of you for being here thanks

981
00:43:42,810 --> 00:43:46,740
Circle City Con staff and volunteers for

982
00:43:45,180 --> 00:43:48,419
making this possible I really wish that

983
00:43:46,740 --> 00:43:51,270
my first circle city con had been in

984
00:43:48,420 --> 00:43:56,510
person but you know what this was this

985
00:43:51,270 --> 00:43:59,160
was pretty awesome so that's all I have

986
00:43:56,510 --> 00:44:01,140
help me out circle city con staff if

987
00:43:59,160 --> 00:44:02,879
we're doing questions on the air or if

988
00:44:01,140 --> 00:44:05,029
we're moving over to the track just let

989
00:44:02,880 --> 00:44:05,030
me know

990
00:44:10,779 --> 00:44:12,839
you

