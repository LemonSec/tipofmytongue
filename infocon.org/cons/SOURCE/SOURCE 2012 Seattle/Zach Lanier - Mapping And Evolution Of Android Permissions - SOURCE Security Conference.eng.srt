1
00:00:07,759 --> 00:00:12,230
we'll get started since it's pretty much

2
00:00:10,010 --> 00:00:14,090
on time so just so you know since

3
00:00:12,230 --> 00:00:17,750
they're obviously a plethora of talks to

4
00:00:14,090 --> 00:00:20,119
go see to you're in the mapping and

5
00:00:17,750 --> 00:00:22,820
evolution of Android permissions and

6
00:00:20,119 --> 00:00:26,179
rewriter is I'm I'm Zach by the way

7
00:00:22,820 --> 00:00:28,910
Andrew Reiter is my colleague who also

8
00:00:26,179 --> 00:00:30,829
did a lot of the research that I'm going

9
00:00:28,910 --> 00:00:33,470
to present we get this talk at blackhat

10
00:00:30,829 --> 00:00:36,410
turbo talks like 15 minutes there's a

11
00:00:33,470 --> 00:00:38,660
lot more content here than if you saw

12
00:00:36,410 --> 00:00:41,179
that version so just give you a little

13
00:00:38,660 --> 00:00:42,849
bit of background Andrew and I are both

14
00:00:41,180 --> 00:00:45,739
security researchers with fair code

15
00:00:42,850 --> 00:00:48,260
where we do binary static analysis stuff

16
00:00:45,739 --> 00:00:51,050
where we focus a lot on we and

17
00:00:48,260 --> 00:00:53,928
particularly focus a lot on mobile and I

18
00:00:51,050 --> 00:00:56,269
my former on the recovering consultant

19
00:00:53,929 --> 00:00:58,879
so to speak former net web app mobile

20
00:00:56,269 --> 00:01:03,079
and tester type managers all those

21
00:00:58,879 --> 00:01:07,160
things old old rule guy and we work

22
00:01:03,079 --> 00:01:08,720
there so the agenda is we're gonna talk

23
00:01:07,160 --> 00:01:09,770
a little bit about AOSP which is Android

24
00:01:08,720 --> 00:01:10,640
open source project

25
00:01:09,770 --> 00:01:13,189
there's a reason that I'm going to

26
00:01:10,640 --> 00:01:14,990
ensure that just see it'll set the stage

27
00:01:13,189 --> 00:01:17,000
as to what this research actually

28
00:01:14,990 --> 00:01:20,030
focused on we're gonna talk a little bit

29
00:01:17,000 --> 00:01:22,009
about permissions in Android it's not an

30
00:01:20,030 --> 00:01:23,240
Android talk in the sense of like

31
00:01:22,009 --> 00:01:26,720
explain do you have the reference

32
00:01:23,240 --> 00:01:27,798
monitor works and stuff but what what

33
00:01:26,720 --> 00:01:30,229
problem Barracks you're trying to solve

34
00:01:27,799 --> 00:01:32,930
the problems that surround permissions

35
00:01:30,229 --> 00:01:37,039
and some prior research from a lot of

36
00:01:32,930 --> 00:01:38,540
academics who use latex a lot and the

37
00:01:37,040 --> 00:01:40,280
approach that we took to kind of

38
00:01:38,540 --> 00:01:42,200
tackling this problem the results that

39
00:01:40,280 --> 00:01:45,380
came out of that and then finally just

40
00:01:42,200 --> 00:01:46,880
some conclusion future directions so if

41
00:01:45,380 --> 00:01:47,750
there are any questions of course you

42
00:01:46,880 --> 00:01:49,820
know feel free to ask

43
00:01:47,750 --> 00:01:53,689
throughout the presentation otherwise

44
00:01:49,820 --> 00:01:58,429
you can ask at the end so what is a OSP

45
00:01:53,689 --> 00:02:02,029
briefly bender it's basically the core

46
00:01:58,430 --> 00:02:03,950
of Android right it's the everything

47
00:02:02,030 --> 00:02:06,140
from all the frameworks to all the

48
00:02:03,950 --> 00:02:08,110
extras to everything that makes Android

49
00:02:06,140 --> 00:02:11,360
run and then of course the modified

50
00:02:08,110 --> 00:02:13,580
Linux kernel we focused for the purposes

51
00:02:11,360 --> 00:02:16,190
of this research on the API that was in

52
00:02:13,580 --> 00:02:18,290
Android dot jar which is the obviously

53
00:02:16,190 --> 00:02:20,020
the jar the Java archive that represents

54
00:02:18,290 --> 00:02:22,480
the Android API

55
00:02:20,020 --> 00:02:24,520
that your application can work with this

56
00:02:22,480 --> 00:02:27,820
doesn't our our research didn't include

57
00:02:24,520 --> 00:02:31,330
private api's so things that weren't

58
00:02:27,820 --> 00:02:34,540
open swatched by google or third party

59
00:02:31,330 --> 00:02:37,960
API so things like you know HTC any of

60
00:02:34,540 --> 00:02:41,019
the HTC things the Samsung any OEM

61
00:02:37,960 --> 00:02:43,920
provider or any vendor API that wasn't

62
00:02:41,020 --> 00:02:46,180
included in a OSP so just briefly

63
00:02:43,920 --> 00:02:48,820
permissions otherwise known as

64
00:02:46,180 --> 00:02:51,160
capabilities in Android parlance they're

65
00:02:48,820 --> 00:02:53,079
called permissions these are grants at

66
00:02:51,160 --> 00:02:54,730
application install time by the package

67
00:02:53,080 --> 00:02:56,170
manager based on what's declared in the

68
00:02:54,730 --> 00:02:57,970
Android manifest that nice little fat

69
00:02:56,170 --> 00:03:00,549
XML file that talks all about what the

70
00:02:57,970 --> 00:03:02,440
app is going to do and what its name is

71
00:03:00,550 --> 00:03:05,140
so these include things like internet

72
00:03:02,440 --> 00:03:09,040
send SMS read contacts vibrate which my

73
00:03:05,140 --> 00:03:13,179
phone just did etc and typically these

74
00:03:09,040 --> 00:03:15,370
these permissions are check the bearer

75
00:03:13,180 --> 00:03:17,230
of these permissions be map that's

76
00:03:15,370 --> 00:03:18,820
calling some function that requires this

77
00:03:17,230 --> 00:03:21,250
permission the permission is checked at

78
00:03:18,820 --> 00:03:24,549
the time of a call what we're gonna see

79
00:03:21,250 --> 00:03:26,260
throughout this this presentation is

80
00:03:24,550 --> 00:03:29,050
that these checks are sometimes done in

81
00:03:26,260 --> 00:03:31,269
an inconsistent way and we'll give a few

82
00:03:29,050 --> 00:03:32,709
examples of those so this you know these

83
00:03:31,270 --> 00:03:34,930
calls might be included creating a

84
00:03:32,709 --> 00:03:37,690
socket object which of course is just a

85
00:03:34,930 --> 00:03:39,670
wrapper to underlying socket

86
00:03:37,690 --> 00:03:41,560
functionality and Linux higher-level

87
00:03:39,670 --> 00:03:43,089
things like accessing Bluetooth which of

88
00:03:41,560 --> 00:03:45,310
course isn't as an abstraction of

89
00:03:43,090 --> 00:03:46,990
accessing Bluetooth Hardware starting an

90
00:03:45,310 --> 00:03:48,940
apps activity you know calling like the

91
00:03:46,990 --> 00:03:50,110
the browser main browser window maybe

92
00:03:48,940 --> 00:03:53,200
there's a permission that's checked to

93
00:03:50,110 --> 00:03:54,880
actually let an app call that and so

94
00:03:53,200 --> 00:03:57,130
forth and so on and content providers

95
00:03:54,880 --> 00:03:57,970
are things like SMS and contacts list

96
00:03:57,130 --> 00:04:00,299
and things like that you need

97
00:03:57,970 --> 00:04:03,970
permissions to actually access those

98
00:04:00,300 --> 00:04:05,170
some of the problems with with the the

99
00:04:03,970 --> 00:04:07,330
problem domain that we're encountering

100
00:04:05,170 --> 00:04:10,989
here the Android API reference

101
00:04:07,330 --> 00:04:13,870
documentation is generally pretty good

102
00:04:10,990 --> 00:04:15,400
about saying for a given class and a

103
00:04:13,870 --> 00:04:17,769
given method in that class or all the

104
00:04:15,400 --> 00:04:19,870
classes methods in that class you need

105
00:04:17,769 --> 00:04:23,169
this permission to do anything with them

106
00:04:19,870 --> 00:04:25,060
but it's not 100% complete and in some

107
00:04:23,169 --> 00:04:27,039
cases it's inconsistent it will say you

108
00:04:25,060 --> 00:04:27,970
need permission X or permission X

109
00:04:27,040 --> 00:04:30,820
doesn't exist

110
00:04:27,970 --> 00:04:32,890
which we've actually seen really you

111
00:04:30,820 --> 00:04:35,860
need permission wire Z so that's that's

112
00:04:32,890 --> 00:04:38,380
interesting edge cases like that there's

113
00:04:35,860 --> 00:04:41,260
no explicit map that says to a developer

114
00:04:38,380 --> 00:04:43,060
hey you want to send an SMS here's the

115
00:04:41,260 --> 00:04:44,170
method you need one minute SMS is

116
00:04:43,060 --> 00:04:46,540
probably bad example because that one's

117
00:04:44,170 --> 00:04:48,190
well documented follow me you want to

118
00:04:46,540 --> 00:04:49,780
send an SMS here's the method that you

119
00:04:48,190 --> 00:04:52,180
need to call and here's how to package

120
00:04:49,780 --> 00:04:53,799
you know the data to send it here's the

121
00:04:52,180 --> 00:04:57,130
permission you need to request in your

122
00:04:53,800 --> 00:04:59,380
manifest that's you know add a

123
00:04:57,130 --> 00:05:03,250
functional or implementation level these

124
00:04:59,380 --> 00:05:04,960
things this map doesn't exist you know

125
00:05:03,250 --> 00:05:07,300
this is obviously not going to happen

126
00:05:04,960 --> 00:05:08,950
but developers to really want a deep

127
00:05:07,300 --> 00:05:10,510
understanding of this we'll need to

128
00:05:08,950 --> 00:05:11,920
really read source code to see what

129
00:05:10,510 --> 00:05:14,440
permissions are being checked which is

130
00:05:11,920 --> 00:05:16,270
something we're trying to solve the

131
00:05:14,440 --> 00:05:17,740
consequences of this of course and I

132
00:05:16,270 --> 00:05:19,599
apologize for the font that I chose this

133
00:05:17,740 --> 00:05:20,980
really awful color scheme many moons ago

134
00:05:19,600 --> 00:05:23,740
for a different presentation and just

135
00:05:20,980 --> 00:05:25,420
decided to keep it we have two cases

136
00:05:23,740 --> 00:05:27,160
under granting of privileges and over

137
00:05:25,420 --> 00:05:30,580
granting of privileges so under granting

138
00:05:27,160 --> 00:05:32,320
is really typically don't not 100% of

139
00:05:30,580 --> 00:05:35,770
the time but typically a stability and

140
00:05:32,320 --> 00:05:37,390
usability issue if you think of when you

141
00:05:35,770 --> 00:05:38,979
get that nice little force close thing

142
00:05:37,390 --> 00:05:40,360
that comes up and if you're looking in

143
00:05:38,980 --> 00:05:42,960
the android log you'll see like a

144
00:05:40,360 --> 00:05:45,490
security exception was raised a throne

145
00:05:42,960 --> 00:05:47,380
and it gives a little bit of detail it's

146
00:05:45,490 --> 00:05:48,970
because the developer called something

147
00:05:47,380 --> 00:05:52,570
but didn't request the permission that

148
00:05:48,970 --> 00:05:53,710
was required to call it and it leads to

149
00:05:52,570 --> 00:05:56,070
a force close because they didn't write

150
00:05:53,710 --> 00:05:58,710
an exception handler

151
00:05:56,070 --> 00:06:00,360
over granting is really more of a

152
00:05:58,710 --> 00:06:02,489
typically more of a security issue

153
00:06:00,360 --> 00:06:03,750
something that app SEC folks might want

154
00:06:02,490 --> 00:06:06,120
to be a little more concerned with if

155
00:06:03,750 --> 00:06:08,040
you think of a mobile AV apps which

156
00:06:06,120 --> 00:06:09,900
requests every single permission known

157
00:06:08,040 --> 00:06:11,100
to man that's available in Android

158
00:06:09,900 --> 00:06:13,320
because they need to do so many

159
00:06:11,100 --> 00:06:15,210
privileged operations on the phone if

160
00:06:13,320 --> 00:06:17,310
you know a lot of them use native code

161
00:06:15,210 --> 00:06:18,900
like lookout for instance not to pick on

162
00:06:17,310 --> 00:06:21,480
them but that's the one that comes to

163
00:06:18,900 --> 00:06:24,150
mind if there's a you know some some

164
00:06:21,480 --> 00:06:25,800
sort of exploitable bug there rather

165
00:06:24,150 --> 00:06:28,200
than having to take over the phone and

166
00:06:25,800 --> 00:06:29,940
get root you know you just send bad data

167
00:06:28,200 --> 00:06:31,830
or deus interact with that privileged

168
00:06:29,940 --> 00:06:33,390
app in some way you affect your

169
00:06:31,830 --> 00:06:34,859
malicious app effectively inherits the

170
00:06:33,390 --> 00:06:37,560
capabilities or permissions that that

171
00:06:34,860 --> 00:06:39,960
has the over granting issue comes into

172
00:06:37,560 --> 00:06:41,400
play where they ask for all these

173
00:06:39,960 --> 00:06:42,539
permissions the developer asks for all

174
00:06:41,400 --> 00:06:43,830
these permissions for their app but

175
00:06:42,540 --> 00:06:45,990
never calls into code it actually

176
00:06:43,830 --> 00:06:48,990
exercises any of those permissions so

177
00:06:45,990 --> 00:06:51,270
why does this happen in some cases

178
00:06:48,990 --> 00:06:52,710
developers just don't have time to sit

179
00:06:51,270 --> 00:06:53,849
there and come up with their own maps

180
00:06:52,710 --> 00:06:55,289
for everything and figure out what

181
00:06:53,850 --> 00:06:57,420
permissions they need for something they

182
00:06:55,290 --> 00:06:59,520
just know when my app crashed when I

183
00:06:57,420 --> 00:07:00,930
called this so I'll just throw a bunch

184
00:06:59,520 --> 00:07:03,810
of permissions into the manifest until

185
00:07:00,930 --> 00:07:05,790
it goes away and then maybe that code

186
00:07:03,810 --> 00:07:07,700
never really gets called that exercised

187
00:07:05,790 --> 00:07:09,930
the permissions they added so

188
00:07:07,700 --> 00:07:13,020
effectively they're over over granting

189
00:07:09,930 --> 00:07:16,800
so why is that breezing through some of

190
00:07:13,020 --> 00:07:18,330
this why isn't there a map well a AOSP

191
00:07:16,800 --> 00:07:21,360
obviously there are many versions of

192
00:07:18,330 --> 00:07:24,359
Android it is somewhat of a moving

193
00:07:21,360 --> 00:07:25,620
target it evolves over time new

194
00:07:24,360 --> 00:07:29,280
permissions get added new permissions

195
00:07:25,620 --> 00:07:30,780
get removed so the nature of AOSP

196
00:07:29,280 --> 00:07:33,030
our Android open source project in and

197
00:07:30,780 --> 00:07:34,710
of itself makes it kind of hard to just

198
00:07:33,030 --> 00:07:36,270
sit there and focus on one particular

199
00:07:34,710 --> 00:07:40,190
version and build this map out

200
00:07:36,270 --> 00:07:43,830
comprehensively google has actually said

201
00:07:40,190 --> 00:07:45,870
sort of passing in the hall at blackhat

202
00:07:43,830 --> 00:07:48,930
that this is of interest to them but

203
00:07:45,870 --> 00:07:50,160
it's not priority they feel and I'm

204
00:07:48,930 --> 00:07:51,540
paraphrasing that you know what they

205
00:07:50,160 --> 00:07:53,100
have is good enough for developers to

206
00:07:51,540 --> 00:07:55,520
understand them by and large it is so

207
00:07:53,100 --> 00:07:58,380
you know they get a point there

208
00:07:55,520 --> 00:07:59,590
difficulty of generating the map as

209
00:07:58,380 --> 00:08:03,310
we'll see in

210
00:07:59,590 --> 00:08:04,869
some of the examples upcoming makes

211
00:08:03,310 --> 00:08:07,780
people kind of glance at this problem go

212
00:08:04,870 --> 00:08:10,030
yeah it's fine I'll just continue to run

213
00:08:07,780 --> 00:08:12,489
my you know source code scanners and my

214
00:08:10,030 --> 00:08:14,409
cool Python scripts that find find

215
00:08:12,490 --> 00:08:15,870
permission related issues and then

216
00:08:14,410 --> 00:08:18,310
finally there's no wow factor to this

217
00:08:15,870 --> 00:08:20,889
for the most part there's nothing like

218
00:08:18,310 --> 00:08:21,940
they're like cool exploitable bugs in

219
00:08:20,889 --> 00:08:23,350
generating this map you're not gonna

220
00:08:21,940 --> 00:08:26,440
like find anything that's really

221
00:08:23,350 --> 00:08:28,900
interesting it's more of just a kind of

222
00:08:26,440 --> 00:08:32,049
a partial mostly academic research study

223
00:08:28,900 --> 00:08:33,279
but it has real-world implications which

224
00:08:32,049 --> 00:08:34,390
I'll explain later if you know what

225
00:08:33,279 --> 00:08:37,510
verrico does you'll see why this is

226
00:08:34,390 --> 00:08:40,088
interesting some other things the API is

227
00:08:37,510 --> 00:08:41,950
just is pretty massive you have to

228
00:08:40,089 --> 00:08:43,659
figure that every single class and every

229
00:08:41,950 --> 00:08:45,250
single method therein is potentially a

230
00:08:43,659 --> 00:08:46,900
candidate there's something that's going

231
00:08:45,250 --> 00:08:50,620
to check a permission so we have to add

232
00:08:46,900 --> 00:08:55,480
in logic to see if a permission is

233
00:08:50,620 --> 00:08:58,779
required to enter into some code I'll

234
00:08:55,480 --> 00:09:01,480
get to that come the complexity of

235
00:08:58,779 --> 00:09:03,550
source code changes in in source code

236
00:09:01,480 --> 00:09:05,560
new commits to android tree might

237
00:09:03,550 --> 00:09:06,969
introduce problems around this and then

238
00:09:05,560 --> 00:09:09,219
as well we'll talk about in a moment

239
00:09:06,970 --> 00:09:10,930
some dynamic analysis difficulties one

240
00:09:09,220 --> 00:09:14,710
of the previous research projects from

241
00:09:10,930 --> 00:09:16,750
UCB that all mentioned tried to approach

242
00:09:14,710 --> 00:09:19,810
this from a dynamic angle and with mixed

243
00:09:16,750 --> 00:09:21,640
results so some data points this is the

244
00:09:19,810 --> 00:09:24,400
class count over the different revisions

245
00:09:21,640 --> 00:09:29,890
of the API from 4 up to 16 where 16

246
00:09:24,400 --> 00:09:31,959
represents jellybean there are let's see

247
00:09:29,890 --> 00:09:35,470
started probably about 2,200 classes in

248
00:09:31,960 --> 00:09:39,220
version 4 up to approaching 3,000 unique

249
00:09:35,470 --> 00:09:43,420
classes in API 16 and then for each of

250
00:09:39,220 --> 00:09:46,780
those a total a grand total of probably

251
00:09:43,420 --> 00:09:50,140
twenty or twenty thousand five hundred

252
00:09:46,780 --> 00:09:53,140
or so total methods in 16 so you can see

253
00:09:50,140 --> 00:09:56,140
it's generally like a nice you know

254
00:09:53,140 --> 00:09:57,890
upward upward number so each of these

255
00:09:56,140 --> 00:09:59,899
again is a candidate

256
00:09:57,890 --> 00:10:02,300
the number of permissions a lot of

257
00:09:59,899 --> 00:10:03,589
people who don't do Android stuff on a

258
00:10:02,300 --> 00:10:05,810
regular basis may not be aware that

259
00:10:03,589 --> 00:10:08,720
there are actually 130 unique

260
00:10:05,810 --> 00:10:10,969
permissions an API 16 not all of them

261
00:10:08,720 --> 00:10:13,459
are ones that are things you can request

262
00:10:10,970 --> 00:10:14,870
in the manifest some of them are like

263
00:10:13,459 --> 00:10:16,130
you know a little more private

264
00:10:14,870 --> 00:10:19,640
permissions that are only granted to

265
00:10:16,130 --> 00:10:21,980
system applications and whatnot it

266
00:10:19,640 --> 00:10:24,290
should be noted that this number is not

267
00:10:21,980 --> 00:10:25,550
an aggregate like this is not just a

268
00:10:24,290 --> 00:10:28,339
constantly increasing number because

269
00:10:25,550 --> 00:10:29,810
between say here and here they might

270
00:10:28,339 --> 00:10:31,519
have added two permissions but took

271
00:10:29,810 --> 00:10:34,000
taken away two permissions or renamed

272
00:10:31,519 --> 00:10:36,320
them in some cases they did things like

273
00:10:34,000 --> 00:10:38,510
instead of calling it access they called

274
00:10:36,320 --> 00:10:39,470
it read so they revoke certain

275
00:10:38,510 --> 00:10:41,870
permissions and add certain permissions

276
00:10:39,470 --> 00:10:44,750
interestingly enough Nick relevant from

277
00:10:41,870 --> 00:10:46,010
Google called me politely called me out

278
00:10:44,750 --> 00:10:49,760
and corrected me and I'm glad he did on

279
00:10:46,010 --> 00:10:52,399
a another presentation I did I did that

280
00:10:49,760 --> 00:10:53,450
in API 16 the read logs permission so in

281
00:10:52,399 --> 00:10:54,950
jellybean that doesn't exist anymore

282
00:10:53,450 --> 00:10:55,430
they they found it to be too much of a

283
00:10:54,950 --> 00:10:57,170
hassle

284
00:10:55,430 --> 00:10:59,180
too many people are screwing it up and

285
00:10:57,170 --> 00:11:02,660
using it the wrong way and leaking

286
00:10:59,180 --> 00:11:03,769
information that they or retrieving

287
00:11:02,660 --> 00:11:07,130
leaked information that they just

288
00:11:03,769 --> 00:11:09,230
revoked it entirely so even very

289
00:11:07,130 --> 00:11:11,779
prominent permissions like read logs are

290
00:11:09,230 --> 00:11:16,089
just no longer there and that's happened

291
00:11:11,779 --> 00:11:16,089
over time so

292
00:11:16,790 --> 00:11:21,980
with regard to source the complexity of

293
00:11:19,310 --> 00:11:23,810
source code so there are typically a

294
00:11:21,980 --> 00:11:25,610
number of ways that permissions are

295
00:11:23,810 --> 00:11:28,069
checked standard ways that are very

296
00:11:25,610 --> 00:11:29,720
easily identifiable such as check

297
00:11:28,070 --> 00:11:32,420
calling or self permission where you

298
00:11:29,720 --> 00:11:35,330
just you check the if if a given

299
00:11:32,420 --> 00:11:38,180
permission exists or has been granted to

300
00:11:35,330 --> 00:11:40,850
the calling application when it you know

301
00:11:38,180 --> 00:11:42,949
calls a method in some API and you know

302
00:11:40,850 --> 00:11:45,590
if Android up permission dot modify

303
00:11:42,950 --> 00:11:46,760
audio settings has been granted then we

304
00:11:45,590 --> 00:11:49,880
return true and this check audio

305
00:11:46,760 --> 00:11:52,520
settings permission works great however

306
00:11:49,880 --> 00:11:56,570
even sometimes there are less than

307
00:11:52,520 --> 00:12:00,050
identifiable ways and and such as like

308
00:11:56,570 --> 00:12:02,090
here we go if basically bind

309
00:12:00,050 --> 00:12:03,469
accessibility service equal service info

310
00:12:02,090 --> 00:12:06,320
dot permission basically just doing a

311
00:12:03,470 --> 00:12:08,210
comparison and if that's valid then this

312
00:12:06,320 --> 00:12:09,830
function completes so or doesn't

313
00:12:08,210 --> 00:12:11,480
complete based on whatever but this is

314
00:12:09,830 --> 00:12:13,010
not actually calling a method to check

315
00:12:11,480 --> 00:12:15,290
that permission it's just saying does

316
00:12:13,010 --> 00:12:16,819
this object equal this object if there

317
00:12:15,290 --> 00:12:17,990
if if so then we assume that the

318
00:12:16,820 --> 00:12:20,150
permission is granted therefore do

319
00:12:17,990 --> 00:12:22,190
something which makes it a little harder

320
00:12:20,150 --> 00:12:24,829
to identify where permission checks are

321
00:12:22,190 --> 00:12:27,040
actually happening routing through I

322
00:12:24,830 --> 00:12:30,350
binder which is a kernel mode driver

323
00:12:27,040 --> 00:12:34,280
that the Android team created that does

324
00:12:30,350 --> 00:12:37,070
a lot of security enhanced our PC and

325
00:12:34,280 --> 00:12:39,290
IPC stuff some of these calls can

326
00:12:37,070 --> 00:12:41,300
actually be wraps wrappers or routers

327
00:12:39,290 --> 00:12:43,130
into I binder interfaces which may be

328
00:12:41,300 --> 00:12:44,810
implemented in native code and therefore

329
00:12:43,130 --> 00:12:46,939
the check might be occurring in native

330
00:12:44,810 --> 00:12:48,410
code and that can be tough to identify

331
00:12:46,940 --> 00:12:49,970
all these levels of abstraction to where

332
00:12:48,410 --> 00:12:52,370
the check is actually happening and I'll

333
00:12:49,970 --> 00:12:54,710
show an example not I binder related but

334
00:12:52,370 --> 00:12:57,320
but something that represents this

335
00:12:54,710 --> 00:13:02,030
problem a little bit later in API 16

336
00:12:57,320 --> 00:13:03,650
there's roughly 9700 files and a total

337
00:13:02,030 --> 00:13:07,160
of about two million lines of executable

338
00:13:03,650 --> 00:13:12,709
source code so just to further emphasize

339
00:13:07,160 --> 00:13:14,300
how complex this this surface really is

340
00:13:12,709 --> 00:13:17,209
so that's that's really the static side

341
00:13:14,300 --> 00:13:20,240
of things from a dynamic side which you

342
00:13:17,209 --> 00:13:21,498
know has its own merit there's a lot of

343
00:13:20,240 --> 00:13:23,899
stuff that we have to execute there's a

344
00:13:21,499 --> 00:13:25,850
lot of rift identify candid candidate

345
00:13:23,899 --> 00:13:28,189
methods and classes and and how they

346
00:13:25,850 --> 00:13:29,360
work and to call them and you know do we

347
00:13:28,189 --> 00:13:30,649
grant permissions or do we not grant

348
00:13:29,360 --> 00:13:32,899
permissions and then how do we

349
00:13:30,649 --> 00:13:34,100
instrument the app to see when an

350
00:13:32,899 --> 00:13:36,019
exception of Sloane and what the

351
00:13:34,100 --> 00:13:37,730
permission was it required so there's a

352
00:13:36,019 --> 00:13:38,779
lot of code to generate we have to sit

353
00:13:37,730 --> 00:13:40,100
there and wait for everything to run

354
00:13:38,779 --> 00:13:43,579
with the wait for everything to crash we

355
00:13:40,100 --> 00:13:46,730
have to restarted method arguments you

356
00:13:43,579 --> 00:13:49,329
know is this polymorphic if we if we

357
00:13:46,730 --> 00:13:51,499
pass it one object type is it going to

358
00:13:49,329 --> 00:13:52,969
act in different ways it's not going to

359
00:13:51,499 --> 00:13:54,199
check a permission you know with

360
00:13:52,970 --> 00:13:56,329
identify all these different code paths

361
00:13:54,199 --> 00:13:59,540
and how to properly call each of these

362
00:13:56,329 --> 00:14:01,309
each of these methods system States some

363
00:13:59,540 --> 00:14:03,439
things require one operation to occur

364
00:14:01,309 --> 00:14:05,800
before another operation can occur

365
00:14:03,439 --> 00:14:08,149
before the permission won't be checked

366
00:14:05,800 --> 00:14:10,008
this is a problem that the UCB

367
00:14:08,149 --> 00:14:11,180
researchers encountered and then do we

368
00:14:10,009 --> 00:14:12,499
run things on an emulator versus

369
00:14:11,180 --> 00:14:14,899
hardware because there may be things

370
00:14:12,499 --> 00:14:17,329
like NFC or some of the low-level radio

371
00:14:14,899 --> 00:14:19,069
stuff that can't be emulated properly

372
00:14:17,329 --> 00:14:20,689
and therefore it's not really accessible

373
00:14:19,069 --> 00:14:23,029
so we can't really call into that and

374
00:14:20,689 --> 00:14:25,309
get the same the same kind of response

375
00:14:23,029 --> 00:14:26,750
that we would get from a physical piece

376
00:14:25,309 --> 00:14:29,029
of hardware and then finally retrieving

377
00:14:26,750 --> 00:14:30,769
test results how do we actually find

378
00:14:29,029 --> 00:14:31,629
where the error occurred and make make

379
00:14:30,769 --> 00:14:36,589
sense of that

380
00:14:31,629 --> 00:14:38,660
so some prior research UC Berkeley

381
00:14:36,589 --> 00:14:41,120
researchers wanted to do a static

382
00:14:38,660 --> 00:14:43,430
permission map they I think they call

383
00:14:41,120 --> 00:14:45,769
the like static permission requirement

384
00:14:43,430 --> 00:14:50,180
verification this was last year they

385
00:14:45,769 --> 00:14:52,029
took Android 2.2 and as interesting when

386
00:14:50,180 --> 00:14:55,819
I think it was may have been done for a

387
00:14:52,029 --> 00:14:59,600
fortifier or something responsive by

388
00:14:55,819 --> 00:15:01,250
them they wanted to build this this nice

389
00:14:59,600 --> 00:15:04,730
web-based map you could you could you

390
00:15:01,250 --> 00:15:06,379
could work with they realized the

391
00:15:04,730 --> 00:15:07,429
challenges of doing static static

392
00:15:06,379 --> 00:15:10,699
approach to this today it ended up

393
00:15:07,429 --> 00:15:12,589
taking a dynamic approach they modified

394
00:15:10,699 --> 00:15:14,540
the dalvik VM and some other core

395
00:15:12,589 --> 00:15:18,410
components of Android to return more

396
00:15:14,540 --> 00:15:20,120
like more verbose information about what

397
00:15:18,410 --> 00:15:21,230
the error actually was and when the

398
00:15:20,120 --> 00:15:22,309
security exception was threatening get

399
00:15:21,230 --> 00:15:23,460
more detail information about what

400
00:15:22,309 --> 00:15:27,240
permission was required

401
00:15:23,460 --> 00:15:28,290
when a method was called in a class they

402
00:15:27,240 --> 00:15:30,810
used ran dupe

403
00:15:28,290 --> 00:15:33,029
which is a JUnit test case generator to

404
00:15:30,810 --> 00:15:34,380
generate the the book of their their

405
00:15:33,029 --> 00:15:36,089
actual Android apps and then you know

406
00:15:34,380 --> 00:15:39,570
built them like you normally would and

407
00:15:36,089 --> 00:15:40,950
then just had devices or emulators just

408
00:15:39,570 --> 00:15:42,930
sit there and run those and and and

409
00:15:40,950 --> 00:15:45,440
they're well emulators to sit there and

410
00:15:42,930 --> 00:15:49,189
run those and then watch the log output

411
00:15:45,440 --> 00:15:51,750
the problem that they ran into was

412
00:15:49,190 --> 00:15:54,000
factory classes and constructors and

413
00:15:51,750 --> 00:15:55,800
methods that maybe had the quartz you

414
00:15:54,000 --> 00:15:58,649
know certain operations to be to occur

415
00:15:55,800 --> 00:16:00,839
and maintain system state they just

416
00:15:58,649 --> 00:16:02,730
bailed on those so they only got I think

417
00:16:00,839 --> 00:16:03,990
with the first pass like less than

418
00:16:02,730 --> 00:16:06,120
eighty percent coverage but in the

419
00:16:03,990 --> 00:16:07,350
second pass that when they modified this

420
00:16:06,120 --> 00:16:10,790
they actually got eighty percent

421
00:16:07,350 --> 00:16:13,370
coverage so their second approach was to

422
00:16:10,790 --> 00:16:16,020
develop their own test case generator

423
00:16:13,370 --> 00:16:20,100
and package these apps up and run them

424
00:16:16,020 --> 00:16:21,779
and they covered more than what was just

425
00:16:20,100 --> 00:16:24,420
in Android jar so they actually did call

426
00:16:21,779 --> 00:16:27,000
into some private frameworks and some

427
00:16:24,420 --> 00:16:28,529
Google and Google private frameworks but

428
00:16:27,000 --> 00:16:30,000
it actually you know the downside of

429
00:16:28,529 --> 00:16:31,980
this was they actually had to modify the

430
00:16:30,000 --> 00:16:33,810
Android source code which isn't you know

431
00:16:31,980 --> 00:16:36,450
infeasible but you can you know it's a

432
00:16:33,810 --> 00:16:38,449
little more work than you know I want to

433
00:16:36,450 --> 00:16:40,410
do in like my basement or something

434
00:16:38,450 --> 00:16:43,260
required human intervention so they

435
00:16:40,410 --> 00:16:44,760
actually needed to be you know a log

436
00:16:43,260 --> 00:16:46,890
monkey to sit there and go okay well it

437
00:16:44,760 --> 00:16:49,650
crashed will extract that out and plop

438
00:16:46,890 --> 00:16:51,180
it into the into you know this

439
00:16:49,650 --> 00:16:53,160
exceptions list so we can go back and

440
00:16:51,180 --> 00:16:56,060
rebuild the refine the test case

441
00:16:53,160 --> 00:16:59,430
generator so it'll account for that and

442
00:16:56,060 --> 00:17:01,949
it wasn't fully automated which were all

443
00:16:59,430 --> 00:17:05,188
about automation it

444
00:17:01,950 --> 00:17:07,350
the results are public but the tool set

445
00:17:05,189 --> 00:17:09,390
that they used and the means of

446
00:17:07,349 --> 00:17:11,730
replicating their research was not made

447
00:17:09,390 --> 00:17:14,390
public so they just talked about like

448
00:17:11,730 --> 00:17:17,220
what they did from a very high level and

449
00:17:14,390 --> 00:17:19,819
the the other tools they relied on and

450
00:17:17,220 --> 00:17:21,720
then gave you the results and

451
00:17:19,819 --> 00:17:23,750
furthermore they only covered revision

452
00:17:21,720 --> 00:17:26,970
eight of the API so Android 2.2

453
00:17:23,750 --> 00:17:30,059
obviously that's not representative of

454
00:17:26,970 --> 00:17:32,450
all of Android now a second major piece

455
00:17:30,059 --> 00:17:32,450
of research

456
00:17:32,820 --> 00:17:43,290
well well anyone well way le le French

457
00:17:38,700 --> 00:17:44,190
French University I think it's an offer

458
00:17:43,290 --> 00:17:45,450
and well it's the University of

459
00:17:44,190 --> 00:17:47,820
Luxembourg so I assume that that's

460
00:17:45,450 --> 00:17:51,240
probably somehow related with anyway

461
00:17:47,820 --> 00:17:52,830
another team called they wrote a tool

462
00:17:51,240 --> 00:17:55,770
called copes or correct permission set

463
00:17:52,830 --> 00:17:57,899
in May of this year so right after we

464
00:17:55,770 --> 00:17:59,940
had started working on our stuff they

465
00:17:57,900 --> 00:18:02,780
used suit which was another Java

466
00:17:59,940 --> 00:18:05,580
analysis tool and call graph generator

467
00:18:02,780 --> 00:18:07,950
to do this so the advantage that the

468
00:18:05,580 --> 00:18:09,480
nice thing there was it built more

469
00:18:07,950 --> 00:18:10,920
accurate call graphs but they had to

470
00:18:09,480 --> 00:18:12,090
also do there was also as human

471
00:18:10,920 --> 00:18:13,290
intervention because I had to go and say

472
00:18:12,090 --> 00:18:14,780
okay this is the entry point for this

473
00:18:13,290 --> 00:18:16,649
this is the root of the call tree and

474
00:18:14,780 --> 00:18:18,389
you know there's actually someone

475
00:18:16,650 --> 00:18:19,590
building that out which isn't terrible

476
00:18:18,390 --> 00:18:22,910
if you have a large enough team but

477
00:18:19,590 --> 00:18:25,020
still requires some human intervention

478
00:18:22,910 --> 00:18:28,140
when there were things into like service

479
00:18:25,020 --> 00:18:31,950
manager requests you know telephony

480
00:18:28,140 --> 00:18:35,880
service blue - Bluetooth I don't think

481
00:18:31,950 --> 00:18:37,530
Bluetooth as a service manager but some

482
00:18:35,880 --> 00:18:40,410
of the more like complex service manager

483
00:18:37,530 --> 00:18:41,730
calls which get a little muddled they

484
00:18:40,410 --> 00:18:43,260
actually had to like it kind of

485
00:18:41,730 --> 00:18:44,520
enumerate all the classes and methods

486
00:18:43,260 --> 00:18:45,690
that were related to those service

487
00:18:44,520 --> 00:18:48,870
manager calls because those are things

488
00:18:45,690 --> 00:18:51,180
that require like state there's a little

489
00:18:48,870 --> 00:18:53,310
bit of heavy lifting there the nice

490
00:18:51,180 --> 00:18:55,770
thing about that was the no need to

491
00:18:53,310 --> 00:18:58,320
modify Android source using something

492
00:18:55,770 --> 00:19:00,120
with like using suit they could feed a

493
00:18:58,320 --> 00:19:03,330
lot of the existing like output from

494
00:19:00,120 --> 00:19:05,250
their back into suit like specifying

495
00:19:03,330 --> 00:19:06,780
entry points to stuff and kind of have

496
00:19:05,250 --> 00:19:11,160
like templates to basically work with I

497
00:19:06,780 --> 00:19:14,520
think they had better results than UCB

498
00:19:11,160 --> 00:19:19,620
we think so that you know their approach

499
00:19:14,520 --> 00:19:21,180
was static but a little bit better the

500
00:19:19,620 --> 00:19:22,979
downside to this of course is that

501
00:19:21,180 --> 00:19:25,010
people had there's still a lot of human

502
00:19:22,980 --> 00:19:27,690
like heavy lifting from humans to

503
00:19:25,010 --> 00:19:30,990
specify entry points do all the service

504
00:19:27,690 --> 00:19:32,550
call stuff and back to the permission

505
00:19:30,990 --> 00:19:34,500
checks inconsistency problem that I

506
00:19:32,550 --> 00:19:36,720
talked about before when they

507
00:19:34,500 --> 00:19:38,220
encountered permission check types or

508
00:19:36,720 --> 00:19:40,560
methods of checking permission that they

509
00:19:38,220 --> 00:19:42,750
weren't used to like the enforce enforce

510
00:19:40,560 --> 00:19:45,270
calling or selfish Annette cetera when

511
00:19:42,750 --> 00:19:47,730
they had like you know dot equals

512
00:19:45,270 --> 00:19:48,810
they just kind of bailed on those so

513
00:19:47,730 --> 00:19:49,620
they had to go back and I think we'll

514
00:19:48,810 --> 00:19:50,970
find some of those or if they just

515
00:19:49,620 --> 00:19:53,129
discarded them entirely

516
00:19:50,970 --> 00:19:56,040
so finally because this is what you

517
00:19:53,130 --> 00:19:58,200
really care about our approach we

518
00:19:56,040 --> 00:20:00,510
originally wanted to take a just a

519
00:19:58,200 --> 00:20:02,940
purely static approach so oK we've got

520
00:20:00,510 --> 00:20:09,060
the Android source trees we've got

521
00:20:02,940 --> 00:20:10,800
Android jar we've got C scope let's go

522
00:20:09,060 --> 00:20:12,870
to town let's like let's see what we can

523
00:20:10,800 --> 00:20:18,000
do with just just these things and never

524
00:20:12,870 --> 00:20:20,520
run never run an app write our results

525
00:20:18,000 --> 00:20:21,240
with that were mixed pretty good but not

526
00:20:20,520 --> 00:20:24,389
good enough

527
00:20:21,240 --> 00:20:27,420
so taking a cue from the UCB researchers

528
00:20:24,390 --> 00:20:28,950
we decided to build a hybrid take a

529
00:20:27,420 --> 00:20:32,070
hybrid approach and build a dynamic tool

530
00:20:28,950 --> 00:20:35,700
to use some of the static results as

531
00:20:32,070 --> 00:20:38,340
sort of a seed and then augment the

532
00:20:35,700 --> 00:20:40,410
static results with dynamic validation

533
00:20:38,340 --> 00:20:42,959
of some of those as well as finding some

534
00:20:40,410 --> 00:20:44,820
cases where you know static might not

535
00:20:42,960 --> 00:20:47,900
have found a permission check correctly

536
00:20:44,820 --> 00:20:50,879
and this was all written in Python and

537
00:20:47,900 --> 00:20:55,440
with a lot of really folder comments and

538
00:20:50,880 --> 00:20:57,830
some of the some parts of it so static

539
00:20:55,440 --> 00:20:57,830
analysis

540
00:20:58,640 --> 00:21:02,720
like I said we wanted to use cscope you

541
00:21:01,400 --> 00:21:05,720
know if you're not familiar at sea scope

542
00:21:02,720 --> 00:21:08,300
in a nutshell it's it's a powerful

543
00:21:05,720 --> 00:21:11,810
source code indexing tool supports

544
00:21:08,300 --> 00:21:15,980
primarily C C++ in and Java ish we found

545
00:21:11,810 --> 00:21:21,470
a few issues and seascapes lexer in the

546
00:21:15,980 --> 00:21:27,100
way that it was it was identifying the

547
00:21:21,470 --> 00:21:29,570
names of some of some methods and

548
00:21:27,100 --> 00:21:32,000
certain plug that small subset of

549
00:21:29,570 --> 00:21:34,040
classes but enough that Andrew went back

550
00:21:32,000 --> 00:21:36,650
and actually modified this C scope

551
00:21:34,040 --> 00:21:38,030
lecture to you know properly I don't

552
00:21:36,650 --> 00:21:41,540
know this is actually a method don't

553
00:21:38,030 --> 00:21:43,730
stop here but ultimately I have the

554
00:21:41,540 --> 00:21:46,129
simple diff and patch like made it

555
00:21:43,730 --> 00:21:49,340
pretty easy so the first step was to

556
00:21:46,130 --> 00:21:51,620
identify and generate a list of the

557
00:21:49,340 --> 00:21:52,730
normal permission check methods so check

558
00:21:51,620 --> 00:21:54,590
permission kept calling permission

559
00:21:52,730 --> 00:21:55,970
enforce calling permission check calling

560
00:21:54,590 --> 00:21:57,949
yourself permission so forth and so on

561
00:21:55,970 --> 00:21:59,960
anything that was identified in the API

562
00:21:57,950 --> 00:22:02,900
and through the docs as being like this

563
00:21:59,960 --> 00:22:05,540
will check a permission then you see

564
00:22:02,900 --> 00:22:06,890
scope to sort of not really gonna know

565
00:22:05,540 --> 00:22:08,810
you even call it a call graph but just

566
00:22:06,890 --> 00:22:12,440
say who's calling me who's the parent

567
00:22:08,810 --> 00:22:14,570
the parent that's calling me so you know

568
00:22:12,440 --> 00:22:17,750
here's a permission check trace back up

569
00:22:14,570 --> 00:22:21,740
and find a where whether you basically

570
00:22:17,750 --> 00:22:25,640
like the entry is right map that back to

571
00:22:21,740 --> 00:22:28,910
API calls and stuff that was any Android

572
00:22:25,640 --> 00:22:31,610
jar and then finally glue all that

573
00:22:28,910 --> 00:22:33,410
together and say okay this is the permit

574
00:22:31,610 --> 00:22:35,360
this is the method that's being called

575
00:22:33,410 --> 00:22:36,410
in this class this is the permission

576
00:22:35,360 --> 00:22:37,699
that's being checked and this is the

577
00:22:36,410 --> 00:22:39,380
means of how they're checking the

578
00:22:37,700 --> 00:22:42,170
permission is it you know one of these

579
00:22:39,380 --> 00:22:45,260
methods that up at the top is it just a

580
00:22:42,170 --> 00:22:46,880
comparison and furthermore the

581
00:22:45,260 --> 00:22:48,590
permission that's being checked is that

582
00:22:46,880 --> 00:22:50,540
the only permission being checked or is

583
00:22:48,590 --> 00:22:52,610
it is there another requirement or is it

584
00:22:50,540 --> 00:22:55,430
you know this one will satisfy or this

585
00:22:52,610 --> 00:22:57,199
one will satisfy in some cases we

586
00:22:55,430 --> 00:22:58,610
actually found especially things around

587
00:22:57,200 --> 00:23:00,260
like native code and whatnot which we'll

588
00:22:58,610 --> 00:23:02,090
also talk a little bit about a second

589
00:23:00,260 --> 00:23:04,160
comp they were actually of value or

590
00:23:02,090 --> 00:23:05,030
comments that said hey if you want to

591
00:23:04,160 --> 00:23:06,309
call this you're going to need this

592
00:23:05,030 --> 00:23:08,080
permission

593
00:23:06,309 --> 00:23:09,850
because that might actually be a call

594
00:23:08,080 --> 00:23:11,799
back into native code or I binder or a

595
00:23:09,850 --> 00:23:13,330
call in to you know another class

596
00:23:11,799 --> 00:23:15,549
somewhere where the permission is

597
00:23:13,330 --> 00:23:17,199
actually being checked that's a little

598
00:23:15,549 --> 00:23:19,960
fuzzier but you know it did actually

599
00:23:17,200 --> 00:23:23,019
have some value and then finally like

600
00:23:19,960 --> 00:23:24,610
everyone like every good Python script

601
00:23:23,019 --> 00:23:25,980
or sort of hackish approach we sort

602
00:23:24,610 --> 00:23:28,299
everything in a sequel light database

603
00:23:25,980 --> 00:23:32,679
and then read a bunch of really crappy

604
00:23:28,299 --> 00:23:35,080
scripts to dump all that stuff out so

605
00:23:32,679 --> 00:23:37,389
from a dynamic analysis side once we had

606
00:23:35,080 --> 00:23:39,279
all the results from the static analysis

607
00:23:37,389 --> 00:23:42,549
side and I'll show some example of some

608
00:23:39,279 --> 00:23:44,799
of the output from that the stuff that

609
00:23:42,549 --> 00:23:48,220
was identified in the static the static

610
00:23:44,799 --> 00:23:51,658
map was then fed back into another

611
00:23:48,220 --> 00:23:55,809
wrapper script that actually would

612
00:23:51,659 --> 00:23:58,029
basically write out really horribly

613
00:23:55,809 --> 00:24:00,490
write out a bunch of Java

614
00:23:58,029 --> 00:24:03,309
just Java source into and what would

615
00:24:00,490 --> 00:24:07,899
later become an Android app so okay well

616
00:24:03,309 --> 00:24:10,539
you know this particular you know like

617
00:24:07,899 --> 00:24:14,110
get neighboring cell info go ahead and

618
00:24:10,539 --> 00:24:15,669
write out all the call for that you know

619
00:24:14,110 --> 00:24:17,740
build it properly so it receives the

620
00:24:15,669 --> 00:24:20,320
correct arguments and then eventually

621
00:24:17,740 --> 00:24:23,080
once that's all built out compile the

622
00:24:20,320 --> 00:24:24,668
app package it up sign it run it in an

623
00:24:23,080 --> 00:24:26,830
emulator and then another wrapper script

624
00:24:24,669 --> 00:24:28,389
sits there and walk watches the output

625
00:24:26,830 --> 00:24:30,129
from logcat and says when an exception

626
00:24:28,389 --> 00:24:34,750
was thrown and if there was more detail

627
00:24:30,129 --> 00:24:36,158
there so runs apk it built this built

628
00:24:34,750 --> 00:24:39,100
the apk it runs it against an emulator

629
00:24:36,159 --> 00:24:41,769
or Hardware mostly it was run against an

630
00:24:39,100 --> 00:24:45,639
emulator and then finally like I said

631
00:24:41,769 --> 00:24:48,080
parses logcat output so

632
00:24:45,640 --> 00:24:50,090
you really did these in batches so we

633
00:24:48,080 --> 00:24:53,030
didn't have like one apk that called

634
00:24:50,090 --> 00:24:54,169
like you know this portion of the API in

635
00:24:53,030 --> 00:24:55,940
this portion of the API and this portion

636
00:24:54,170 --> 00:24:58,160
maybe API we said okay service managers

637
00:24:55,940 --> 00:24:59,600
first we're gonna call all those so

638
00:24:58,160 --> 00:25:02,600
that'll be the service manager apk or

639
00:24:59,600 --> 00:25:05,330
set of apks static method calls just you

640
00:25:02,600 --> 00:25:08,330
know the bulk of the the java api our

641
00:25:05,330 --> 00:25:11,360
android api and then specifically

642
00:25:08,330 --> 00:25:14,570
pulling out classes that don't have or

643
00:25:11,360 --> 00:25:17,540
don't aren't a constructor and then ones

644
00:25:14,570 --> 00:25:20,270
that are constructor classes or have in

645
00:25:17,540 --> 00:25:21,500
them constructor methods and just by

646
00:25:20,270 --> 00:25:23,150
kind of like grouping these things

647
00:25:21,500 --> 00:25:28,130
together it was easier to identify when

648
00:25:23,150 --> 00:25:29,330
problems arose or if you know we needed

649
00:25:28,130 --> 00:25:30,860
to go back in to find this this this

650
00:25:29,330 --> 00:25:32,750
sort of as andrew likes to say

651
00:25:30,860 --> 00:25:34,090
stabilized testing it's a very academic

652
00:25:32,750 --> 00:25:36,350
way of putting it

653
00:25:34,090 --> 00:25:39,620
so some examples of service managers

654
00:25:36,350 --> 00:25:41,740
just to give you some idea select Wi-Fi

655
00:25:39,620 --> 00:25:43,550
manager Audio Manager telephony manager

656
00:25:41,740 --> 00:25:45,770
these are the things where we actually

657
00:25:43,550 --> 00:25:47,899
have to basically like say you know we

658
00:25:45,770 --> 00:25:50,120
context or this context get system

659
00:25:47,900 --> 00:25:52,250
service whatever the the handle is to

660
00:25:50,120 --> 00:25:55,219
Wi-Fi service since that's a you know a

661
00:25:52,250 --> 00:25:57,920
system-wide thing not just unique to our

662
00:25:55,220 --> 00:26:01,310
app so that's an example we had little

663
00:25:57,920 --> 00:26:04,160
snippets like that and then if we didn't

664
00:26:01,310 --> 00:26:04,970
have the permission to open it you know

665
00:26:04,160 --> 00:26:07,610
we didn't have like any of the

666
00:26:04,970 --> 00:26:08,870
appropriate Wi-Fi related permissions an

667
00:26:07,610 --> 00:26:09,500
exception is thrown and we get like a

668
00:26:08,870 --> 00:26:12,439
nice error

669
00:26:09,500 --> 00:26:15,470
validating our our static analysis our

670
00:26:12,440 --> 00:26:17,240
original static analysis map an example

671
00:26:15,470 --> 00:26:19,720
of a non constructor case like i said

672
00:26:17,240 --> 00:26:23,240
some of them don't have constructors

673
00:26:19,720 --> 00:26:25,220
like a bluetooth device for instance we

674
00:26:23,240 --> 00:26:26,480
just we get the default adapter that's

675
00:26:25,220 --> 00:26:28,090
kind of like that I think the Wi-Fi

676
00:26:26,480 --> 00:26:31,190
manager would be an example of this but

677
00:26:28,090 --> 00:26:33,169
maybe not if it's like a system-wide

678
00:26:31,190 --> 00:26:35,390
thing since there's no like we don't

679
00:26:33,170 --> 00:26:37,130
have an object that is our unique

680
00:26:35,390 --> 00:26:38,960
Bluetooth adapter it's sort of like a

681
00:26:37,130 --> 00:26:40,520
it's not really constructed returning

682
00:26:38,960 --> 00:26:41,990
the object it's returning like a handle

683
00:26:40,520 --> 00:26:44,000
basic like a system-wide handle to this

684
00:26:41,990 --> 00:26:45,890
we need to identify those and then write

685
00:26:44,000 --> 00:26:47,570
little snippets that would just you know

686
00:26:45,890 --> 00:26:50,270
if we don't already have one go ahead

687
00:26:47,570 --> 00:26:52,970
and open up a you know a handle so to

688
00:26:50,270 --> 00:26:54,290
speak to that and then you know interact

689
00:26:52,970 --> 00:26:55,460
with it in some way

690
00:26:54,290 --> 00:26:57,230
and then an exception would get thrown

691
00:26:55,460 --> 00:27:01,700
him we would hopefully validate our

692
00:26:57,230 --> 00:27:05,390
static results then back to just simple

693
00:27:01,700 --> 00:27:07,580
things so anything that was generic was

694
00:27:05,390 --> 00:27:09,770
like a simple constructor or most of the

695
00:27:07,580 --> 00:27:11,870
regular Java API and Android API stuff

696
00:27:09,770 --> 00:27:15,560
we would just identify simple primitives

697
00:27:11,870 --> 00:27:17,000
like int long float etc common things

698
00:27:15,560 --> 00:27:20,090
that you're used to if you've done Java

699
00:27:17,000 --> 00:27:24,740
stuff you know throwable list string

700
00:27:20,090 --> 00:27:26,510
socket stuff that's we called common and

701
00:27:24,740 --> 00:27:29,630
then finally identifying just Android

702
00:27:26,510 --> 00:27:31,510
specific things like context parcel

703
00:27:29,630 --> 00:27:34,880
which is basically the root of a lot of

704
00:27:31,510 --> 00:27:39,950
message passing stuff I binder int int

705
00:27:34,880 --> 00:27:42,980
package manager etc and then what for

706
00:27:39,950 --> 00:27:43,670
some of those folks if there's some

707
00:27:42,980 --> 00:27:44,960
things we're going to call in

708
00:27:43,670 --> 00:27:47,260
dynamically we need to just have like a

709
00:27:44,960 --> 00:27:50,060
basically a big nice list or array of

710
00:27:47,260 --> 00:27:52,580
you know what arguments we'll be feeding

711
00:27:50,060 --> 00:27:55,820
into the methods that we have to pull

712
00:27:52,580 --> 00:27:58,580
out of static so our our automation

713
00:27:55,820 --> 00:28:02,659
wrappers if you've ever built an Android

714
00:27:58,580 --> 00:28:05,240
app by hand ant to compile and build a

715
00:28:02,660 --> 00:28:07,310
apt to package all the resources jars

716
00:28:05,240 --> 00:28:08,930
seiner to put a crappy fake cert in

717
00:28:07,310 --> 00:28:12,050
there and then finally zip line to

718
00:28:08,930 --> 00:28:14,750
optimize it zip lines not necessary

719
00:28:12,050 --> 00:28:16,639
for this research but since we're

720
00:28:14,750 --> 00:28:17,960
already killing our emulators and some

721
00:28:16,640 --> 00:28:19,940
of our devices having as much

722
00:28:17,960 --> 00:28:23,240
optimization as possible in there for

723
00:28:19,940 --> 00:28:26,800
running these apps is really nice and

724
00:28:23,240 --> 00:28:29,860
then finally yet one more

725
00:28:26,800 --> 00:28:33,669
a pair of rappers that actually start up

726
00:28:29,860 --> 00:28:35,350
the emulator or talk to a push then

727
00:28:33,670 --> 00:28:38,830
and/or install and run the app on the

728
00:28:35,350 --> 00:28:41,560
device sit there and monitor logcat tail

729
00:28:38,830 --> 00:28:45,250
log cat man and repping out for certain

730
00:28:41,560 --> 00:28:47,110
expressions that look like a log cat a

731
00:28:45,250 --> 00:28:48,940
security exception being thrown and then

732
00:28:47,110 --> 00:28:50,949
pulling that information out and dumping

733
00:28:48,940 --> 00:28:53,050
it into the back into the database in

734
00:28:50,950 --> 00:28:55,090
the same format and it also handles

735
00:28:53,050 --> 00:28:57,220
automatically you know building

736
00:28:55,090 --> 00:29:02,500
installing uninstalling the set the

737
00:28:57,220 --> 00:29:05,290
previous one relaunching it etc so

738
00:29:02,500 --> 00:29:08,440
parsing log cat we learned is a it's

739
00:29:05,290 --> 00:29:09,879
super hackish but it's kind of there's

740
00:29:08,440 --> 00:29:12,850
not I don't really know of another a

741
00:29:09,880 --> 00:29:14,380
better way so typically will Co you know

742
00:29:12,850 --> 00:29:16,090
Java dot Lang that security exception

743
00:29:14,380 --> 00:29:18,190
okay easily identifiable when you see

744
00:29:16,090 --> 00:29:20,560
that and you see you know like a warning

745
00:29:18,190 --> 00:29:23,320
and system about error or something cool

746
00:29:20,560 --> 00:29:24,879
we know that that that an exception was

747
00:29:23,320 --> 00:29:26,350
thrown and we can we can parse the rest

748
00:29:24,880 --> 00:29:29,160
of that and find out what the permission

749
00:29:26,350 --> 00:29:31,629
was required in this case device power

750
00:29:29,160 --> 00:29:35,260
I've been calling the go to sleep method

751
00:29:31,630 --> 00:29:37,930
and power manager pretty easy however

752
00:29:35,260 --> 00:29:40,390
it's not always 100% effective because

753
00:29:37,930 --> 00:29:41,740
since a one developers like I'm just

754
00:29:40,390 --> 00:29:43,570
gonna raise this cube exception the

755
00:29:41,740 --> 00:29:46,240
other developer on Android might be like

756
00:29:43,570 --> 00:29:49,540
I'm just gonna spit out some stuff just

757
00:29:46,240 --> 00:29:52,090
a call permission denial so I'm just

758
00:29:49,540 --> 00:29:54,820
gonna write out literally like a log dot

759
00:29:52,090 --> 00:29:56,919
w permission denial here's some

760
00:29:54,820 --> 00:30:00,179
information rather than raising a

761
00:29:56,920 --> 00:30:03,400
security exception so in this case

762
00:30:00,180 --> 00:30:06,820
speakerphone on method was called and it

763
00:30:03,400 --> 00:30:07,900
just says permission denial okay that

764
00:30:06,820 --> 00:30:09,310
doesn't really tell me like what the

765
00:30:07,900 --> 00:30:12,310
error actually was what permission was

766
00:30:09,310 --> 00:30:13,780
actually required to call that makes a

767
00:30:12,310 --> 00:30:16,030
little kind of a pain in the neck to

768
00:30:13,780 --> 00:30:18,280
parse long cat out but Ola finally on

769
00:30:16,030 --> 00:30:20,770
Java net socket exception since that

770
00:30:18,280 --> 00:30:25,660
actually is a exs that's raised from

771
00:30:20,770 --> 00:30:28,420
Linux then you know then Java VM itself

772
00:30:25,660 --> 00:30:30,190
throws java.net the socket exception

773
00:30:28,420 --> 00:30:33,470
permission denied rather than a security

774
00:30:30,190 --> 00:30:39,390
exception and in some cases

775
00:30:33,470 --> 00:30:41,400
so our results were pretty good we

776
00:30:39,390 --> 00:30:43,290
didn't require modification to any

777
00:30:41,400 --> 00:30:46,230
Android source code it takes about 15

778
00:30:43,290 --> 00:30:48,450
minutes to do the static analysis are an

779
00:30:46,230 --> 00:30:51,960
average of 15 minutes across every

780
00:30:48,450 --> 00:30:54,540
version of Android of AOSP sorry

781
00:30:51,960 --> 00:30:57,350
and then about one hour to do the same

782
00:30:54,540 --> 00:31:01,020
for each each revision of the API

783
00:30:57,350 --> 00:31:03,240
dynamically and I believe that was only

784
00:31:01,020 --> 00:31:06,000
on one emulator so okay that's pretty

785
00:31:03,240 --> 00:31:07,500
good there's not a lot of human

786
00:31:06,000 --> 00:31:09,690
intervention required the dynamic stuff

787
00:31:07,500 --> 00:31:11,130
actually took more effort to go back and

788
00:31:09,690 --> 00:31:13,550
validate some of those results and shove

789
00:31:11,130 --> 00:31:15,780
them into the database much like UCB did

790
00:31:13,550 --> 00:31:18,320
but the static side didn't really

791
00:31:15,780 --> 00:31:21,170
require any human intervention once we

792
00:31:18,320 --> 00:31:24,020
you know felt it was ready enough

793
00:31:21,170 --> 00:31:26,580
compares about accurate with UCB

794
00:31:24,020 --> 00:31:29,910
especially for 2.2 since they only did

795
00:31:26,580 --> 00:31:32,310
2.2 we don't really have any other any

796
00:31:29,910 --> 00:31:33,780
other maps to compare against and like I

797
00:31:32,310 --> 00:31:36,929
said we can run it against every every

798
00:31:33,780 --> 00:31:38,610
version of the SDK so like I said we can

799
00:31:36,930 --> 00:31:43,860
only compare against T's the UCB to the

800
00:31:38,610 --> 00:31:45,449
UC B's map for revision 8 but you know

801
00:31:43,860 --> 00:31:48,449
if they decide to do another one maybe

802
00:31:45,450 --> 00:31:49,800
we can compare against that the night

803
00:31:48,450 --> 00:31:51,420
the nice thing that they had that we

804
00:31:49,800 --> 00:31:53,399
didn't was stuff that wasn't just

805
00:31:51,420 --> 00:31:55,800
explicitly in Android jars so you know

806
00:31:53,400 --> 00:31:57,750
private methods and things but what we

807
00:31:55,800 --> 00:32:00,030
covered and what they covered compared

808
00:31:57,750 --> 00:32:02,610
pretty well so since they were sort of

809
00:32:00,030 --> 00:32:04,710
the the first ones to really do this

810
00:32:02,610 --> 00:32:09,139
that we kind of forget it there a decent

811
00:32:04,710 --> 00:32:12,600
bar bad it doesn't cover all methods so

812
00:32:09,140 --> 00:32:14,970
back to the native code thing some

813
00:32:12,600 --> 00:32:16,560
methods are just j'ni stubs and when

814
00:32:14,970 --> 00:32:18,330
they enter into native code that's where

815
00:32:16,560 --> 00:32:20,090
the permission checks being done and we

816
00:32:18,330 --> 00:32:22,260
don't cover those right now

817
00:32:20,090 --> 00:32:23,189
that'll that's where the dynamic side

818
00:32:22,260 --> 00:32:27,500
comes and we can get a little more

819
00:32:23,190 --> 00:32:29,790
information about that here's an example

820
00:32:27,500 --> 00:32:33,240
the permission check is actually this is

821
00:32:29,790 --> 00:32:34,340
C++ code the check permission function

822
00:32:33,240 --> 00:32:36,870
is actually being called to see if

823
00:32:34,340 --> 00:32:39,439
access surface flinger permission has

824
00:32:36,870 --> 00:32:41,989
been granted and if so then

825
00:32:39,440 --> 00:32:43,700
you know this uh I figured what function

826
00:32:41,990 --> 00:32:44,779
this was but it'll proceed somewhere in

827
00:32:43,700 --> 00:32:48,860
surface flinger the surface flinger

828
00:32:44,779 --> 00:32:51,980
source code and it's also not the a in

829
00:32:48,860 --> 00:32:55,158
the the a ID graphics user whatever UID

830
00:32:51,980 --> 00:32:58,279
that is you know if this hasn't been

831
00:32:55,159 --> 00:33:00,649
granted permission denied but then of

832
00:32:58,279 --> 00:33:02,299
course i like this back back to the

833
00:33:00,649 --> 00:33:04,610
example of ink like very inconsistent

834
00:33:02,299 --> 00:33:07,970
logging permission denial can't access

835
00:33:04,610 --> 00:33:09,709
surface flinger UID p ID no information

836
00:33:07,970 --> 00:33:11,779
about what permission was actually

837
00:33:09,710 --> 00:33:13,990
required because maybe the developer is

838
00:33:11,779 --> 00:33:16,970
not actually gonna go be the source code

839
00:33:13,990 --> 00:33:20,389
that kind of presents a problem for us

840
00:33:16,970 --> 00:33:21,409
abstract classes we're kind of working

841
00:33:20,389 --> 00:33:23,209
on that right now

842
00:33:21,409 --> 00:33:27,200
i think andrew is putting in some stuff

843
00:33:23,210 --> 00:33:28,759
for abstract classes so you know sub sub

844
00:33:27,200 --> 00:33:30,649
classing all those abstract classes in

845
00:33:28,759 --> 00:33:33,620
the dynamic side that from a static side

846
00:33:30,649 --> 00:33:37,699
that's that's a little more of a of a

847
00:33:33,620 --> 00:33:39,918
pain in the neck again only limited AOSP

848
00:33:37,700 --> 00:33:41,840
know google private frameworks with

849
00:33:39,919 --> 00:33:43,940
third-party frameworks does require

850
00:33:41,840 --> 00:33:47,809
changes as a seascape man not not so

851
00:33:43,940 --> 00:33:50,120
hard it's literally a like a patch AOSP

852
00:33:47,809 --> 00:33:54,730
source trees are required this I think

853
00:33:50,120 --> 00:33:58,008
this took a day plus to check out every

854
00:33:54,730 --> 00:33:59,779
AOSP source tree because I'm lazy and I

855
00:33:58,009 --> 00:34:02,509
don't want to sit there and like use the

856
00:33:59,779 --> 00:34:04,490
repo tool to like branch and go back and

857
00:34:02,509 --> 00:34:06,740
and and whatnot so it's just easier to

858
00:34:04,490 --> 00:34:11,270
for simplicity sake to check them all

859
00:34:06,740 --> 00:34:14,300
out all at once so this I think each of

860
00:34:11,270 --> 00:34:17,089
these was roughly like counting all the

861
00:34:14,300 --> 00:34:19,190
get that like the whole get director in

862
00:34:17,089 --> 00:34:23,270
dot repo directory I think each one was

863
00:34:19,190 --> 00:34:25,369
like average of like five maybe ten gigs

864
00:34:23,270 --> 00:34:26,929
and the higher end so it's that's

865
00:34:25,369 --> 00:34:28,849
significant but it just takes a long

866
00:34:26,929 --> 00:34:32,000
time but it disk space is cheap so if

867
00:34:28,849 --> 00:34:33,349
you've got a fat pipe and disk space you

868
00:34:32,000 --> 00:34:37,190
know this not not an insurmountable

869
00:34:33,349 --> 00:34:39,190
problem so some practical results that

870
00:34:37,190 --> 00:34:40,659
came out of our analysis

871
00:34:39,190 --> 00:34:42,580
there was the standard a sanity check

872
00:34:40,659 --> 00:34:45,100
that we did just to make sure that our

873
00:34:42,580 --> 00:34:48,670
article graph analysis and from the

874
00:34:45,100 --> 00:34:50,739
static side was sufficient we basically

875
00:34:48,670 --> 00:34:52,780
just took a class that was well

876
00:34:50,739 --> 00:34:53,739
documented and had the permission check

877
00:34:52,780 --> 00:34:55,360
that was the commission that was

878
00:34:53,739 --> 00:34:58,000
required to : to do anything in that

879
00:34:55,360 --> 00:35:01,060
class that would be like let's just make

880
00:34:58,000 --> 00:35:03,250
sure that our results don't suck so in

881
00:35:01,060 --> 00:35:05,009
Bluetooth health class it explicitly

882
00:35:03,250 --> 00:35:07,150
says requires bluetooth permission

883
00:35:05,010 --> 00:35:08,950
requires bluetooth permission for get

884
00:35:07,150 --> 00:35:10,090
device mat devices matching connection

885
00:35:08,950 --> 00:35:11,230
states and unregistered app

886
00:35:10,090 --> 00:35:13,320
configuration just as a couple of

887
00:35:11,230 --> 00:35:16,630
examples so it's pretty well documented

888
00:35:13,320 --> 00:35:20,920
I've apologized for the terrible like

889
00:35:16,630 --> 00:35:22,600
text sublime text dump here but here's

890
00:35:20,920 --> 00:35:24,490
just an example of dumping some stuff

891
00:35:22,600 --> 00:35:25,990
from the DB so here we just have the

892
00:35:24,490 --> 00:35:29,169
revision that we were focusing on which

893
00:35:25,990 --> 00:35:30,669
was 15 so we enjoyed that bluetooth that

894
00:35:29,170 --> 00:35:33,940
Bluetooth health connect to channel

895
00:35:30,670 --> 00:35:35,440
source method in this case we so that's

896
00:35:33,940 --> 00:35:36,550
the here's the class here all the

897
00:35:35,440 --> 00:35:37,900
methods there's the permission that's

898
00:35:36,550 --> 00:35:40,420
required Android uh permission that

899
00:35:37,900 --> 00:35:42,130
Bluetooth and then finally the the way

900
00:35:40,420 --> 00:35:44,440
that it's being checked so enforce

901
00:35:42,130 --> 00:35:46,930
calling yourself permission is the the

902
00:35:44,440 --> 00:35:49,330
checking method that's the permission

903
00:35:46,930 --> 00:35:52,029
that's required and you know for each

904
00:35:49,330 --> 00:35:55,029
method so in this case documentation is

905
00:35:52,030 --> 00:35:56,890
superb permission requirement is

906
00:35:55,030 --> 00:35:59,160
accurate and they all check consistently

907
00:35:56,890 --> 00:36:02,529
and that's great

908
00:35:59,160 --> 00:36:07,589
examples of where this called out a few

909
00:36:02,530 --> 00:36:07,590
issues that we're not we're not known

910
00:36:07,960 --> 00:36:14,109
in the Wi-Fi manager class for the start

911
00:36:12,309 --> 00:36:16,240
scan method the documentation doesn't

912
00:36:14,109 --> 00:36:18,069
say what you need or what permission you

913
00:36:16,240 --> 00:36:19,750
actually need this is from

914
00:36:18,069 --> 00:36:20,920
developer.android.com now I don't think

915
00:36:19,750 --> 00:36:22,270
I still don't think it's been been

916
00:36:20,920 --> 00:36:25,150
updated so if you know anyone at Google

917
00:36:22,270 --> 00:36:27,549
tell them that fixes there's a here's

918
00:36:25,150 --> 00:36:28,890
just a simple block from the source code

919
00:36:27,549 --> 00:36:32,109
start scan method

920
00:36:28,890 --> 00:36:33,460
bla bla bla bla enforce access

921
00:36:32,109 --> 00:36:35,529
permission method which you know gets

922
00:36:33,460 --> 00:36:38,799
called enforce calling yourself

923
00:36:35,529 --> 00:36:41,200
permission checks to see if the access

924
00:36:38,799 --> 00:36:43,599
Wi-Fi state or change Wi-Fi state

925
00:36:41,200 --> 00:36:47,379
permissions are have been granted to the

926
00:36:43,599 --> 00:36:48,670
caller contrast to the documentation and

927
00:36:47,380 --> 00:36:50,559
then finally the output from our tool

928
00:36:48,670 --> 00:36:53,609
which oh by the way for pretty much

929
00:36:50,559 --> 00:36:56,829
everything in the Wi-Fi manager class

930
00:36:53,609 --> 00:36:59,230
you need you know access Wi-Fi state or

931
00:36:56,829 --> 00:37:01,150
change Wi-Fi state and luckily all being

932
00:36:59,230 --> 00:37:03,309
checked consistently so that that was

933
00:37:01,150 --> 00:37:04,750
cool but you know that's an example and

934
00:37:03,309 --> 00:37:07,809
there are other edge cases like this

935
00:37:04,750 --> 00:37:11,890
that you are free to explore another

936
00:37:07,809 --> 00:37:13,660
example telephony manager and actually I

937
00:37:11,890 --> 00:37:19,960
think I have some there was a chunk of

938
00:37:13,660 --> 00:37:25,420
notes that I I probably need to yeah

939
00:37:19,960 --> 00:37:27,069
yeah what a piece of crap hold on

940
00:37:25,420 --> 00:37:29,200
anyway just for clarification I'll

941
00:37:27,069 --> 00:37:31,839
mention this in a second but the

942
00:37:29,200 --> 00:37:34,328
documentation even not checked it today

943
00:37:31,839 --> 00:37:37,000
still says that the access course

944
00:37:34,329 --> 00:37:40,150
updates permission is required to call

945
00:37:37,000 --> 00:37:42,670
get neighboring cell info this is

946
00:37:40,150 --> 00:37:45,579
actually a known issue on Google code

947
00:37:42,670 --> 00:37:47,890
the Android bug bug tracker 1 9 192 for

948
00:37:45,579 --> 00:37:50,020
those interested so the access course

949
00:37:47,890 --> 00:37:52,210
updates for permission doesn't exist

950
00:37:50,020 --> 00:37:53,529
it's not a real permission I don't

951
00:37:52,210 --> 00:37:55,299
believe it's ever been a real permission

952
00:37:53,529 --> 00:37:58,150
but it could have been lost somewhere in

953
00:37:55,299 --> 00:38:01,480
the you know deltas of permissions added

954
00:37:58,150 --> 00:38:02,950
and removed so even in the source code

955
00:38:01,480 --> 00:38:05,190
it says oh yeah yeah you totally need

956
00:38:02,950 --> 00:38:09,549
the access course updates permission

957
00:38:05,190 --> 00:38:13,070
basically telephony managers get

958
00:38:09,549 --> 00:38:17,090
neighboring cell info actually calls

959
00:38:13,070 --> 00:38:20,210
the phone something phone and if a phone

960
00:38:17,090 --> 00:38:21,740
interface something I forget effectively

961
00:38:20,210 --> 00:38:23,000
I call it just calls another method in

962
00:38:21,740 --> 00:38:24,649
another class but if everywhere we

963
00:38:23,000 --> 00:38:27,610
traced it back and our tool actually

964
00:38:24,650 --> 00:38:29,560
work its get neighboring cell info

965
00:38:27,610 --> 00:38:33,530
enforced calling yourself permission

966
00:38:29,560 --> 00:38:35,840
access fine location or access course

967
00:38:33,530 --> 00:38:38,390
location so either of these permissions

968
00:38:35,840 --> 00:38:40,520
are sufficient for this for get

969
00:38:38,390 --> 00:38:41,930
neighboring cell info but the

970
00:38:40,520 --> 00:38:43,460
documentation says you need a permission

971
00:38:41,930 --> 00:38:44,810
that doesn't exist these are one of the

972
00:38:43,460 --> 00:38:46,040
two permissions is checked finally our

973
00:38:44,810 --> 00:38:48,830
tool output

974
00:38:46,040 --> 00:38:50,330
says access find location or access

975
00:38:48,830 --> 00:38:53,029
course location and this is the way it's

976
00:38:50,330 --> 00:38:55,540
being checked so you know it's a kind of

977
00:38:53,030 --> 00:38:57,980
funny that just totally inaccurate but

978
00:38:55,540 --> 00:39:01,670
it's an example of just an oversight on

979
00:38:57,980 --> 00:39:05,360
Google's part and these are plenty of

980
00:39:01,670 --> 00:39:09,560
these to be had so the conclusion the

981
00:39:05,360 --> 00:39:10,760
too long getting read with a cat so this

982
00:39:09,560 --> 00:39:12,860
would be great I think this would be

983
00:39:10,760 --> 00:39:14,210
really helpful well we believe it would

984
00:39:12,860 --> 00:39:16,250
be really helpful for developers and

985
00:39:14,210 --> 00:39:17,750
that applications to people who want to

986
00:39:16,250 --> 00:39:19,760
like learn if a app has been over

987
00:39:17,750 --> 00:39:21,050
permissioned or under permission or just

988
00:39:19,760 --> 00:39:26,810
to get an idea of you know when you're

989
00:39:21,050 --> 00:39:30,770
writing your nice report bro what issues

990
00:39:26,810 --> 00:39:33,170
might exist again they're strange edge

991
00:39:30,770 --> 00:39:35,030
cases where permissions are enforced and

992
00:39:33,170 --> 00:39:37,100
consistently or checked inconsistently

993
00:39:35,030 --> 00:39:39,550
or the documentation who doesn't match

994
00:39:37,100 --> 00:39:42,830
what the developer actually thinks and

995
00:39:39,550 --> 00:39:44,990
really it would be cool if Google had

996
00:39:42,830 --> 00:39:46,700
had control of this since they have all

997
00:39:44,990 --> 00:39:49,520
the resources and appropriate access to

998
00:39:46,700 --> 00:39:51,290
everything Android related to to really

999
00:39:49,520 --> 00:39:53,720
work on this but we you know we're

1000
00:39:51,290 --> 00:39:54,860
giving it our best shot one of the other

1001
00:39:53,720 --> 00:39:56,509
things that we learned was this is a

1002
00:39:54,860 --> 00:39:59,500
good exercise in understanding but not

1003
00:39:56,510 --> 00:40:02,780
to do so as probably a lot of talks

1004
00:39:59,500 --> 00:40:04,610
generally go into this was a nice way of

1005
00:40:02,780 --> 00:40:06,550
saying okay so you should really have a

1006
00:40:04,610 --> 00:40:08,960
more consistent naming scheme for

1007
00:40:06,550 --> 00:40:10,700
permissions and for the means of

1008
00:40:08,960 --> 00:40:13,610
checking those permissions having a

1009
00:40:10,700 --> 00:40:16,910
maybe a more consistent API for

1010
00:40:13,610 --> 00:40:19,040
developers or even platform developers

1011
00:40:16,910 --> 00:40:20,078
app developers and platform developers

1012
00:40:19,040 --> 00:40:21,069
to check

1013
00:40:20,079 --> 00:40:23,769
whether or not a permission has been

1014
00:40:21,069 --> 00:40:27,569
granted and then a map that keeps track

1015
00:40:23,769 --> 00:40:29,288
of all the API calls that require

1016
00:40:27,569 --> 00:40:33,449
permissions and what those permissions

1017
00:40:29,289 --> 00:40:35,410
are so ultimately our future plans

1018
00:40:33,449 --> 00:40:37,630
really include refining the static

1019
00:40:35,410 --> 00:40:39,719
discovery so I don't think that we'll

1020
00:40:37,630 --> 00:40:41,709
get the abstract class stuff solved

1021
00:40:39,719 --> 00:40:43,630
necessarily but it would be cooler to

1022
00:40:41,709 --> 00:40:45,489
have like I don't know stuff that isn't

1023
00:40:43,630 --> 00:40:47,679
just in Java so maybe all the native

1024
00:40:45,489 --> 00:40:49,269
code stuff that actually call does

1025
00:40:47,679 --> 00:40:52,150
Commission checks having that handled

1026
00:40:49,269 --> 00:40:56,649
from a static side and that'll really

1027
00:40:52,150 --> 00:41:00,029
help with enhancing the dynamic analysis

1028
00:40:56,650 --> 00:41:03,039
as well in the dynamic side

1029
00:41:00,029 --> 00:41:04,809
appropriately subclassing all abstract

1030
00:41:03,039 --> 00:41:07,769
classes and not just the one that's that

1031
00:41:04,809 --> 00:41:12,549
ones that were sort of haphazardly

1032
00:41:07,769 --> 00:41:16,149
chosen yeah so I think there will be

1033
00:41:12,549 --> 00:41:18,279
some stuff around this talk posted up on

1034
00:41:16,150 --> 00:41:21,549
the Avera code blog so it's very code

1035
00:41:18,279 --> 00:41:26,289
calm slash blog company shameless plug

1036
00:41:21,549 --> 00:41:28,779
and you know that look for that

1037
00:41:26,289 --> 00:41:33,729
hopefully within the next month or so or

1038
00:41:28,779 --> 00:41:38,559
upcoming weeks yeah and if you wish to

1039
00:41:33,729 --> 00:41:40,269
contact any of us I'm that's my email

1040
00:41:38,559 --> 00:41:45,670
address that is Andrews email address

1041
00:41:40,269 --> 00:41:47,229
those are our Twatter IDs and the very

1042
00:41:45,670 --> 00:41:50,880
code and then a bunch of greets to

1043
00:41:47,229 --> 00:41:54,609
people so yes so

1044
00:41:50,880 --> 00:41:57,770
to talk about trying to find some

1045
00:41:54,610 --> 00:41:58,900
way to check the Commission's

1046
00:41:57,770 --> 00:42:03,100
[Music]

1047
00:41:58,900 --> 00:42:04,900
is there some single point of native

1048
00:42:03,100 --> 00:42:07,080
code functionality that all commercial

1049
00:42:04,900 --> 00:42:12,520
checking goes down to whatever so just

1050
00:42:07,080 --> 00:42:15,100
so it kind of goes back to - the same

1051
00:42:12,520 --> 00:42:17,080
problem with with the Java side of

1052
00:42:15,100 --> 00:42:19,000
things so like you saw on the this the

1053
00:42:17,080 --> 00:42:20,259
surface flinger code there's actually a

1054
00:42:19,000 --> 00:42:23,410
function that's called that checks the

1055
00:42:20,260 --> 00:42:25,480
permission of that calling task right

1056
00:42:23,410 --> 00:42:28,029
but there's also stuff that's like do

1057
00:42:25,480 --> 00:42:30,070
you know equals equals like actual just

1058
00:42:28,030 --> 00:42:32,530
a comparison comparative operate

1059
00:42:30,070 --> 00:42:34,450
comparison operators that we get muddled

1060
00:42:32,530 --> 00:42:37,840
into that again really I'm going to be

1061
00:42:34,450 --> 00:42:40,990
honest just getting through identifying

1062
00:42:37,840 --> 00:42:42,490
all the Java based checks the Machine

1063
00:42:40,990 --> 00:42:44,200
checks and comparisons and all the

1064
00:42:42,490 --> 00:42:45,640
different really horrible and consistent

1065
00:42:44,200 --> 00:42:48,129
ways that was being done at that point

1066
00:42:45,640 --> 00:42:50,950
it was just like okay that's pretty good

1067
00:42:48,130 --> 00:42:52,450
let's work with that for now so that's

1068
00:42:50,950 --> 00:42:54,669
on the horizon and that's something that

1069
00:42:52,450 --> 00:42:56,379
we want to do next but yeah but there

1070
00:42:54,670 --> 00:43:00,160
are some ways it's it's still going to

1071
00:42:56,380 --> 00:43:01,650
require like I think the C scope some of

1072
00:43:00,160 --> 00:43:03,759
the C scope indexes that we built

1073
00:43:01,650 --> 00:43:05,800
focused primarily on Java like it if

1074
00:43:03,760 --> 00:43:09,310
like we take one index there's no

1075
00:43:05,800 --> 00:43:11,500
mention of C or C C++ source files in

1076
00:43:09,310 --> 00:43:14,080
there anywhere so we can't like resolve

1077
00:43:11,500 --> 00:43:16,080
a symbol in a Java file and then like

1078
00:43:14,080 --> 00:43:17,940
have C scope index that you know across

1079
00:43:16,080 --> 00:43:20,279
C

1080
00:43:17,940 --> 00:43:26,550
[Music]

1081
00:43:20,280 --> 00:43:29,730
just like watch there yeah so one of the

1082
00:43:26,550 --> 00:43:32,490
other things that I've kind of planted

1083
00:43:29,730 --> 00:43:35,970
in in this this research projects

1084
00:43:32,490 --> 00:43:38,790
collective mind there's a tool by Scott

1085
00:43:35,970 --> 00:43:41,759
Dunlop from IOA or used to be at Iowa

1086
00:43:38,790 --> 00:43:44,310
call and bug and it's it's it's really

1087
00:43:41,760 --> 00:43:46,770
an Android app debugger well I mean

1088
00:43:44,310 --> 00:43:48,360
anything that supports J DWP it'll it'll

1089
00:43:46,770 --> 00:43:52,680
let you attach to as long as it's mark

1090
00:43:48,360 --> 00:43:54,570
debuggable that that's something that

1091
00:43:52,680 --> 00:43:57,270
I've kind of thought we might be able to

1092
00:43:54,570 --> 00:43:59,040
leverage so like just trace when anytime

1093
00:43:57,270 --> 00:44:00,210
a check is any kind of anything that

1094
00:43:59,040 --> 00:44:02,520
looks like a permission check is being

1095
00:44:00,210 --> 00:44:06,390
called and then log additional

1096
00:44:02,520 --> 00:44:08,160
information that way that's just haven't

1097
00:44:06,390 --> 00:44:13,310
done it yet but that might be another

1098
00:44:08,160 --> 00:44:13,310
way yes

1099
00:44:13,760 --> 00:44:26,260
[Music]

1100
00:44:24,730 --> 00:44:28,000
replicated that at all and if so even

1101
00:44:26,260 --> 00:44:30,070
track

1102
00:44:28,000 --> 00:44:32,170
that was the first approach we took real

1103
00:44:30,070 --> 00:44:34,090
like oh let's just use let's use ran do

1104
00:44:32,170 --> 00:44:36,640
we actually wanted the first step was to

1105
00:44:34,090 --> 00:44:37,750
replicate the ucv research because we're

1106
00:44:36,640 --> 00:44:40,480
like okay they set the bar pretty high

1107
00:44:37,750 --> 00:44:43,930
let's let's reach for that and we used R

1108
00:44:40,480 --> 00:44:46,690
& R and OOP to build a bunch of Android

1109
00:44:43,930 --> 00:44:48,549
apps with it with J unit test cases with

1110
00:44:46,690 --> 00:44:54,280
no permissions calling every single

1111
00:44:48,550 --> 00:44:55,990
every single method in the API we

1112
00:44:54,280 --> 00:44:58,600
haven't really gone back and done that

1113
00:44:55,990 --> 00:44:59,770
across the different versions because we

1114
00:44:58,600 --> 00:45:01,540
ended up taking the static approach

1115
00:44:59,770 --> 00:45:03,490
focused all our efforts on that have

1116
00:45:01,540 --> 00:45:05,980
pretty good results and then we're like

1117
00:45:03,490 --> 00:45:08,620
okay well let's take the best of both

1118
00:45:05,980 --> 00:45:11,200
worlds let's like use the what we did

1119
00:45:08,620 --> 00:45:13,000
for with R and ooh but instead of just

1120
00:45:11,200 --> 00:45:15,100
saying OK for everything that's in the

1121
00:45:13,000 --> 00:45:18,490
API call it we were like well let's

1122
00:45:15,100 --> 00:45:21,130
let's give it first validation of what

1123
00:45:18,490 --> 00:45:22,979
we found statically then go back and and

1124
00:45:21,130 --> 00:45:28,520
you know fill in the gaps

1125
00:45:22,980 --> 00:45:32,760
[Music]

1126
00:45:28,520 --> 00:45:35,250
right yeah I don't know I'm right now

1127
00:45:32,760 --> 00:45:39,299
that the data is mostly really raw and

1128
00:45:35,250 --> 00:45:42,390
sitting on sitting in a bunch of sequel

1129
00:45:39,299 --> 00:45:46,589
Lite databases on a server I can't reach

1130
00:45:42,390 --> 00:45:48,720
right now so yeah I think hopefully

1131
00:45:46,589 --> 00:45:50,460
that'll be I'm not I'm not promising

1132
00:45:48,720 --> 00:45:53,279
anything and I know I'm on camera

1133
00:45:50,460 --> 00:45:54,599
so hopefully that would be one of the

1134
00:45:53,280 --> 00:45:56,190
things that we would we would hope to

1135
00:45:54,599 --> 00:45:58,290
release on like the blog is you know

1136
00:45:56,190 --> 00:46:00,050
here's here's some stats on what we

1137
00:45:58,290 --> 00:46:07,599
found

1138
00:46:00,050 --> 00:46:10,550
[Music]

1139
00:46:07,599 --> 00:46:12,970
to us searching

1140
00:46:10,550 --> 00:46:16,750
obviously all functionality without

1141
00:46:12,970 --> 00:46:16,750
reservation right hood

1142
00:46:17,829 --> 00:46:27,099
I I will go back and look through

1143
00:46:23,259 --> 00:46:29,019
because that's I'm willing to bet the

1144
00:46:27,099 --> 00:46:33,940
coffee or a beer that there are cases

1145
00:46:29,019 --> 00:46:36,308
where that that what the thing is so

1146
00:46:33,940 --> 00:46:38,229
it's it's our tool doesn't prove the

1147
00:46:36,309 --> 00:46:39,789
negative right like it doesn't say oh

1148
00:46:38,229 --> 00:46:41,649
well here's a method that you can call

1149
00:46:39,789 --> 00:46:44,170
that says it has requires a permission

1150
00:46:41,650 --> 00:46:46,359
doesn't we're saying for every method

1151
00:46:44,170 --> 00:46:47,859
that requires a permission here's the

1152
00:46:46,359 --> 00:46:49,089
permission that's require so I go back

1153
00:46:47,859 --> 00:46:51,940
and just basically do the inverse right

1154
00:46:49,089 --> 00:46:53,349
so that would be not listed but that

1155
00:46:51,940 --> 00:46:55,390
would probably be a another that's

1156
00:46:53,349 --> 00:46:59,829
that's really more of like the ahmed

1157
00:46:55,390 --> 00:47:01,808
well academic side of things the first

1158
00:46:59,829 --> 00:47:03,849
step was like proving that a nap is over

1159
00:47:01,809 --> 00:47:05,499
permission 400 permission the inverse

1160
00:47:03,849 --> 00:47:06,670
would then be to build the opposite nap

1161
00:47:05,499 --> 00:47:08,169
where you can reach into things without

1162
00:47:06,670 --> 00:47:15,710
a permission

1163
00:47:08,170 --> 00:47:18,810
[Music]

1164
00:47:15,710 --> 00:47:21,580
fact that actually does the defender of

1165
00:47:18,810 --> 00:47:23,299
people in this case probably

1166
00:47:21,580 --> 00:47:26,679
they patch their software

1167
00:47:23,299 --> 00:47:32,569
yeah I was talking with someone earlier

1168
00:47:26,679 --> 00:47:34,279
about interesting ways to go and they

1169
00:47:32,569 --> 00:47:37,939
have an app basically modify its own

1170
00:47:34,279 --> 00:47:39,619
well I mean this is this is a path to

1171
00:47:37,939 --> 00:47:44,078
explore but I how could you want modify

1172
00:47:39,619 --> 00:47:47,419
your own entitlements basically happier

1173
00:47:44,079 --> 00:47:49,039
right like what what are the what's the

1174
00:47:47,419 --> 00:47:50,868
possibility there for an Android app and

1175
00:47:49,039 --> 00:47:51,949
how does this relate but that would be

1176
00:47:50,869 --> 00:47:57,259
you know that's another interesting

1177
00:47:51,949 --> 00:48:00,319
interesting an approach so cool well

1178
00:47:57,259 --> 00:48:02,749
thank you for coming and uh be around

1179
00:48:00,319 --> 00:48:05,630
for a bit so I think there's like a

1180
00:48:02,749 --> 00:48:11,109
thing after the thing probably involves

1181
00:48:05,630 --> 00:48:11,109
beer so I'll be there well thank you

