1
00:00:08,850 --> 00:00:10,620
Wunderbar. Äh ja...

2
00:00:10,670 --> 00:00:12,330
Willkommen zu meinem Vortrag über calc.pw,

3
00:00:12,330 --> 00:00:13,830
Passwortberechnung mit Arduino

4
00:00:14,500 --> 00:00:17,010
Vielleicht kurz vorher: die Folien selber sind auf Englisch gehalten,

5
00:00:17,010 --> 00:00:19,310
damit non-native speaker sich daran orientieren können.

6
00:00:19,340 --> 00:00:21,660
Ich selbst werde aber trotzdem auf Deutsch vortragen.

7
00:00:22,860 --> 00:00:24,510
Vielleicht kurz zu mir, mein Name ist Kenny,

8
00:00:24,720 --> 00:00:28,240
und man kann mich erreichen per E-Mail, per Twitter, per Website

9
00:00:28,270 --> 00:00:30,230
und noch so ein paar andere Sachen, die ich nicht aufgeschrieben habe.

10
00:00:32,100 --> 00:00:33,130
Was ich heute erzählen werde,

11
00:00:33,130 --> 00:00:35,280
ist zum einen das Problem, was ich lösen wollte,

12
00:00:35,320 --> 00:00:37,860
dann meine Idee, wie ich dieses Problem lösen wollte,

13
00:00:37,920 --> 00:00:39,740
dann, wie die Lösung derzeit aussieht,

14
00:00:40,130 --> 00:00:41,620
wie die Lösung funktioniert,

15
00:00:41,680 --> 00:00:44,140
und was so die Fallstricke waren, die ich versucht habe,

16
00:00:44,140 --> 00:00:46,500
oder die mir begegnet sind, die ich lösen musste...

17
00:00:46,850 --> 00:00:48,590
Ja, fangen wir mit dem Problem einfach mal an.

18
00:00:49,790 --> 00:00:52,220
Viele von euch werden sicherlich das Internet benutzen,

19
00:00:52,460 --> 00:00:54,380
mit keine Ahnung wievielen verschiedenen Diensten,

20
00:00:54,410 --> 00:00:57,760
ihr werdet eigene Server haben, wo ihr euch per SSH einwählt,

21
00:00:57,780 --> 00:01:00,500
ihr habt E-Mail-Accounts, wo ihr euch einloggen müsst usw.,

22
00:01:01,200 --> 00:01:03,510
und wie ihr sicherlich wisst, sollte man für jeden Dienst

23
00:01:03,540 --> 00:01:04,980
ein eigenenes Passwort verwenden.

24
00:01:05,390 --> 00:01:06,400
Einfacher Grund:

25
00:01:06,500 --> 00:01:10,380
wird ein so ein Dienst mal angegriffen und die Passwörter entwendet,

26
00:01:10,500 --> 00:01:12,860
können diese Passwörter bei anderen Diensten ausprobiert werden,

27
00:01:13,250 --> 00:01:15,540
und schon habt ihr einen viel größeren Angriffsvektor.

28
00:01:16,540 --> 00:01:18,210
Deswegen: ein Passwort pro Dienst,

29
00:01:18,240 --> 00:01:20,720
das ist so das, was man einsetzen sollte.

30
00:01:21,240 --> 00:01:23,560
Das Problem ist, sich diese ganzen Passwörter zu merken.

31
00:01:23,580 --> 00:01:26,660
Also bei mir sind es im Schnitt so zwischen 25 und 50 Passwörter,

32
00:01:26,660 --> 00:01:27,700
die ich jede Woche verwende,

33
00:01:27,970 --> 00:01:29,760
je nachdem, wieviele Dienste ich gerade benutze.

34
00:01:31,560 --> 00:01:34,400
Weil man sich so viele starke Passwörter einfach nicht merken kann,

35
00:01:34,400 --> 00:01:37,120
haben Leute angefangen, sich Passwort-Schemen auszudenken.

36
00:01:37,360 --> 00:01:39,750
Zum Beispiel hat man ein starkes Passwort, das man vorne dranpackt,

37
00:01:39,750 --> 00:01:41,230
und hinten dann den Namen vom Dienst.

38
00:01:43,160 --> 00:01:47,400
Ist dann ein Problem, wenn ein Dienst z.B. Passwörter Plaintext abspeichert,

39
00:01:47,540 --> 00:01:51,420
weil dann kann man sich einfach dieses Präfix-Passwort nehmen,

40
00:01:51,420 --> 00:01:53,470
kann irgendeinen anderen Dienstnamen hinten dranschreiben

41
00:01:53,620 --> 00:01:55,320
und kann damit wieder Passwörter ausprobieren.

42
00:01:56,300 --> 00:02:00,740
Es gibt noch andere Möglichkeiten, Passwörter sich selber zu generieren,

43
00:02:00,740 --> 00:02:04,020
indem man z.B. einen Satz benutzt, da die Leerzeichen rausnimmt,

44
00:02:04,020 --> 00:02:06,260
noch ein paar Buchstaben durch Zahlen & Sonderzeichen ersetzt,

45
00:02:06,380 --> 00:02:07,790
und dann hat man wieder ein Passwort.

46
00:02:08,139 --> 00:02:10,639
Macht aber auch dann wieder Probleme, wenn man viele Dienste verwendet,

47
00:02:10,639 --> 00:02:12,680
weil für jeden Dienst muss man sich einen Satz merken,

48
00:02:12,680 --> 00:02:15,840
man muss sich merken, welchen Satz man für welchen Dienst benutzt hat,

49
00:02:15,840 --> 00:02:18,210
welche Buchstaben man wann ersetzt hat, und so weiter.

50
00:02:20,400 --> 00:02:23,080
Die andere Sache, die in den letzten Jahren sehr beliebt geworden ist,

51
00:02:23,080 --> 00:02:24,280
sind Passwortdatenbanken.

52
00:02:24,680 --> 00:02:25,800
Wenn man es sich mal genau überlegt,

53
00:02:25,820 --> 00:02:28,190
das ist im Grunde eine Datei, da schreibt man seine Passwörter rein,

54
00:02:28,190 --> 00:02:31,960
da schreibt man rein, auch noch, wie der Benutzername ist,

55
00:02:31,990 --> 00:02:34,580
wie der Dienst heißt, vielleicht noch die URL vom Dienst,

56
00:02:35,210 --> 00:02:37,240
verschlüsselt das ganze mit einem Passwort,

57
00:02:37,620 --> 00:02:40,680
und hofft, dass niemals diese Datei abhanden kommt,

58
00:02:40,680 --> 00:02:43,040
und dass niemals gleichzeitig das Passwort dazu abhanden kommt.

59
00:02:43,710 --> 00:02:46,020
Benutzt man dann sehr gerne auf Windows z.B.,

60
00:02:46,020 --> 00:02:49,020
wo Trojaner und Viren durchaus vorherrschend sind,

61
00:02:49,260 --> 00:02:52,330
und wir müssen, wenn wir Passwort-Datenbanken benutzen,

62
00:02:52,340 --> 00:02:55,700
hoffen, dass niemals ein Trojaner kommt, der genau darauf abzielt.

63
00:02:56,860 --> 00:02:57,340
Ja.

64
00:02:59,400 --> 00:03:00,580
Was ist jetzt so die Idee?

65
00:03:02,080 --> 00:03:04,240
Die Idee hinter dem ganzen ist zum einen,

66
00:03:04,240 --> 00:03:06,820
ich möchte die Passwortauswahl vereinfachen,

67
00:03:06,820 --> 00:03:09,900
sprich, welches Passwort wird für welchen Dienst wann verwendet.

68
00:03:10,660 --> 00:03:12,670
Ich möchte gleichzeitig das Problem lösen,

69
00:03:12,670 --> 00:03:14,710
wie man sich diese ganzen Passwörter merken soll.

70
00:03:15,760 --> 00:03:18,310
Es soll obendrein soweit wie möglich verhindert werden,

71
00:03:18,310 --> 00:03:19,660
dass diese Passwörter verloren gehen,

72
00:03:19,660 --> 00:03:20,780
z.B. durch einen Festplattencrash,

73
00:03:20,780 --> 00:03:22,910
wo dann plötzlich die Passwort-Datenbank weg ist,

74
00:03:23,200 --> 00:03:26,240
oder sie gestohlen werden, z.B. durch Trojaner.

75
00:03:26,640 --> 00:03:28,500
Und das ganze soll Open Source sein,

76
00:03:28,520 --> 00:03:30,640
einfach, damit jeder diese Technologie benutzen kann,

77
00:03:30,640 --> 00:03:33,360
und nicht sich an irgenwelche teuren Firmen wenden muss,

78
00:03:33,370 --> 00:03:35,110
um sowas in der Art haben zu können.

79
00:03:36,810 --> 00:03:39,900
Die Frage ist jetzt natürlich, wie soll das ganze funktionieren?

80
00:03:42,180 --> 00:03:42,840
so...

81
00:03:43,450 --> 00:03:44,400
...meiner Meinung nach.

82
00:03:44,400 --> 00:03:47,100
und zwar indem die pw kryptografisch berechnet werden

83
00:03:47,940 --> 00:03:49,060
es gibt da mehrere Faktoren

84
00:03:49,060 --> 00:03:51,800
das ist zum Beispiel das ist zum einen das Master-Passwort

85
00:03:52,450 --> 00:03:54,830
was die Stärke des ganzen darstellen soll

86
00:03:54,830 --> 00:03:56,660
einfach weil es schlussendlich eine Verschlüsselung ist

87
00:03:57,660 --> 00:04:00,240
wir haben eine Service-Information für die einfache Merkbarkeit

88
00:04:00,480 --> 00:04:05,120
das geht so in Richtung starkes Präfix und dann einfacs Service-Suffix

89
00:04:05,890 --> 00:04:07,800
es sollen öffentlichen Algorithmen verwendet werden

90
00:04:07,800 --> 00:04:09,910
einfach, damit man das ganze reproduzieren kann

91
00:04:10,180 --> 00:04:12,710
wenn man also ein Gerät hat, was Passwörter berechnet,

92
00:04:12,710 --> 00:04:15,340
und ein neues Gerät kauft, was die gleichen Algorithmen verwendet

93
00:04:15,540 --> 00:04:17,320
soll schlussendlich die gleichen PW dabei heraus kommen

94
00:04:17,820 --> 00:04:20,370
und das ganze soll dedizierte Hardware verwenden

95
00:04:20,670 --> 00:04:23,940
einfach, damit wir nicht durch normale Trojaner und Viren angegriffen werden können

96
00:04:23,950 --> 00:04:24,960
bei der Passwort-Berechnung.

97
00:04:26,840 --> 00:04:28,190
So, wie sieht die Lösung aus?

98
00:04:28,490 --> 00:04:31,800
Ich geh mal ein bisschen zurück, ins Jahre 2003 äh 2010

99
00:04:31,800 --> 00:04:34,500
da hab ich ein Programm geschrieben

100
00:04:34,500 --> 00:04:36,860
den Passwordcalculatur, der schon genau das gemacht hat

101
00:04:36,860 --> 00:04:38,940
man hat ein Master-Passwort eingegeben

102
00:04:39,100 --> 00:04:41,300
hat die Information eingegeben, hat auf berechnen geklickt

103
00:04:41,300 --> 00:04:42,840
und hat schlussendlich sein Passwort rausgekriegt

104
00:04:44,770 --> 00:04:46,970
hat funktioniert, funktioniert auch immer noch,

105
00:04:47,080 --> 00:04:49,170
hat aber eine unschöne Eigenschaft, nämlich,

106
00:04:49,280 --> 00:04:52,300
wo immer man sein Passwort braucht, muss man dieses Programm runterladen

107
00:04:52,630 --> 00:04:55,600
an dem Rechner muss man entsprechend auch sein Masterpasswort eingeben

108
00:04:55,940 --> 00:04:59,060
und ich habs mehrfach, also zweimal,

109
00:04:59,260 --> 00:05:02,030
dass ich bei einem Freund war, hab da irgendwas an einem Server machen müssen,

110
00:05:02,030 --> 00:05:04,390
hab das Programm runtergeladen, Passwort eingegeben,

111
00:05:04,580 --> 00:05:06,520
und als ich dann fertig war mit meiner Arbeit, wurde mir dann gesagt:

112
00:05:06,720 --> 00:05:10,520
"Du, mein Computer benimmt sich seit zwei Wochen ein bisschen merkwuerdig...

113
00:05:10,520 --> 00:05:12,540
wenn du schonmal da bist, kannst du nichtmal kucken?"

114
00:05:12,860 --> 00:05:15,860
Hmm. Schön. Erstmal alle Passwörter wechseln.

115
00:05:17,050 --> 00:05:18,850
Genau das soll eben nicht mehr vorkommen.

116
00:05:19,000 --> 00:05:23,520
Deswegen, calc.pw als wirklich Hardware-Anwendung

117
00:05:23,940 --> 00:05:26,740
sieht ungefähr so aus, schön in einer Box

118
00:05:27,460 --> 00:05:28,810
das ist noch die Revision "c",

119
00:05:28,820 --> 00:05:30,580
es gibt mittlerweise eine Revision "d",

120
00:05:31,140 --> 00:05:32,390
die ist noch nicht ganz fertig, wie man sieht

121
00:05:32,910 --> 00:05:33,980
aber wird noch.

122
00:05:34,720 --> 00:05:38,360
Wie man sieht, soll ein bisschen modularer werden, als es vorher gewesen ist

123
00:05:38,620 --> 00:05:46,280
soll auch... eher in Richtung Produktion in... ja... Fabriken kommen

124
00:05:47,770 --> 00:05:48,610
daran arbeite ich noch.

125
00:05:49,460 --> 00:05:50,680
Was ist da schlussendlich drin?

126
00:05:51,010 --> 00:05:54,690
In der Revision "d", also das ist ein verteiltes,

127
00:05:55,620 --> 00:05:58,300
ist einmal ein Arduino Leonardo drin, als Output-Device,

128
00:05:58,390 --> 00:06:01,260
das emuliert eine Tastatur gegenüber dem Computer

129
00:06:01,490 --> 00:06:03,640
spricht das LCD an und spricht auch ein paar LEDs an

130
00:06:03,640 --> 00:06:05,150
damit man so Status-Informationen kriegt,

131
00:06:05,920 --> 00:06:08,770
dazu noch ein Ardiuino Uno, als Eingabegerät,

132
00:06:08,920 --> 00:06:12,110
dort wird schlussendlich eine Tastaur angeschlossen

133
00:06:12,580 --> 00:06:14,670
es kann auch optional noch ein Keypad angeschlossen werden,

134
00:06:14,670 --> 00:06:15,620
daran arbeite ich gerade

135
00:06:15,850 --> 00:06:19,880
und dieses Arduino Uno führt auch die Berechnung schlussendlich durch

136
00:06:20,420 --> 00:06:23,630
und dann noch als 3. ein sogenanntes USB-Host-Shield

137
00:06:23,730 --> 00:06:26,750
das ist das, was eigentlich dann den USB-Anschluss hat

138
00:06:27,520 --> 00:06:30,520
was dann die Kommunikation mit dem USB-Gerät vornimmt

139
00:06:30,850 --> 00:06:32,380
und hier schon mal eine Empfehlung:

140
00:06:32,610 --> 00:06:35,200
dringend oder am besten das von circuits at home nehmen

141
00:06:35,200 --> 00:06:38,340
das ist das ursprünglich shield, wo auch die Bibliothek für geschrieben wird

142
00:06:38,760 --> 00:06:41,360
wo auch die Entwickler von dieser Bibliothek stark dahinter sind

143
00:06:42,040 --> 00:06:43,120
das es gut funktioniert

144
00:06:44,520 --> 00:06:46,810
So, wie funktioniert das ganze nun?

145
00:06:46,990 --> 00:06:48,460
Ich habe da mal eine Schematik gemacht

146
00:06:49,860 --> 00:06:52,420
im Grund, man hat seinen Computer, man hat seine Tastatur

147
00:06:52,420 --> 00:06:54,320
und genau dazwischen sitzt calc.pw

148
00:06:54,950 --> 00:06:56,740
ist so in der Art "man in the middle"

149
00:06:57,900 --> 00:07:00,130
liest ein, was über die Tastatur eingegeben wird,

150
00:07:00,130 --> 00:07:01,770
und gibt dann irgendwas an den Computer aus.

151
00:07:02,220 --> 00:07:05,730
Genauer gesagt, beim hochfahren fragt es einmal nach dem Masterpasswort

152
00:07:06,200 --> 00:07:07,420
was man dann nochmal wiederholt,

153
00:07:07,810 --> 00:07:10,260
und dann geht es in einen sogenannten passthrough-Modus

154
00:07:10,450 --> 00:07:13,340
heißt: die Eingaben, die dann über die Tastatur erfolgen,

155
00:07:13,360 --> 00:07:15,570
werden eins zu eins an den Rechner weitergegeben

156
00:07:15,720 --> 00:07:18,080
einfach damit man die Tastatur weiter benutzen kann, ganz normal

157
00:07:18,660 --> 00:07:21,260
erst durch eine spezielle Tastenkombination kommt man dann

158
00:07:21,260 --> 00:07:22,810
in den Passwort-berechnen-Modus

159
00:07:22,980 --> 00:07:24,230
wo man seine information eingibt,

160
00:07:24,470 --> 00:07:26,260
Enter drückt, das Passwort berechnet wird,

161
00:07:26,510 --> 00:07:28,910
und das Passwort als normale Tastatureingaben

162
00:07:28,910 --> 00:07:30,240
an den Rechner weitergegeben werden

163
00:07:30,540 --> 00:07:34,200
sprich; der kriegt nichtmal mit, dass da jetzt nicht über eine Tastatur

164
00:07:34,200 --> 00:07:36,390
ein Passwort eingegeben wurde sondern berechnet worden ist.

165
00:07:37,670 --> 00:07:38,160
So.

166
00:07:39,920 --> 00:07:41,180
Wie funktioniert die Berechnung?

167
00:07:41,740 --> 00:07:43,410
Nicht aufregen, komme ich gleich noch zu

168
00:07:45,510 --> 00:07:46,760
was zu erst gemacht wird,

169
00:07:46,760 --> 00:07:49,540
es wird aus dem Master-Passwort und der eingegebenen Information

170
00:07:49,540 --> 00:07:50,880
ein termporäres Passwort gebildet.

171
00:07:51,040 --> 00:07:53,180
das ist einfach gegen Rainbow-Attacks,

172
00:07:53,550 --> 00:07:56,540
dass sozusagen nicht vorher schon Passwörter vorberechnet werden können.

173
00:07:57,540 --> 00:07:58,980
Als nächstes wird die Information genommen,

174
00:07:59,140 --> 00:08:00,470
und die wird expandiert.

175
00:08:00,520 --> 00:08:03,940
Wenn wir uns vorstellen, wir haben eine ganz kurze Dienstinformation, wie z.B. "ebay"

176
00:08:04,120 --> 00:08:06,400
wir wollen nicht nur vier Zeichen kurze Passwörter generieren

177
00:08:06,780 --> 00:08:08,570
das ganze wird also entsprechend expandiert,

178
00:08:09,670 --> 00:08:11,810
wird verschlüsselt, noch ein bisschen sauber gemacht

179
00:08:11,810 --> 00:08:13,340
dass man es auch wirklich als Passwort benutzen kann

180
00:08:13,610 --> 00:08:14,960
und dass ist schlussendlich unser Passwort.

181
00:08:16,530 --> 00:08:20,280
Wir wissen, dass da ist das eine Problem: SHA1

182
00:08:21,430 --> 00:08:23,340
ist nicht mehr so ganz "state of the art"

183
00:08:24,180 --> 00:08:28,400
und das andere, seit Snowden, das da [RC4] auch nicht mehr so "state of the art"

184
00:08:29,190 --> 00:08:31,700
warum die noch eingesetzt werden, darauf komm ich später noch zu sprechen.

185
00:08:33,320 --> 00:08:36,210
So, was waren denn so die Fallstricke?

186
00:08:37,299 --> 00:08:40,919
im Grunde die vier hier als allererstes, und größtes

187
00:08:41,240 --> 00:08:43,659
diese Tastaturen, die man dort anschließt

188
00:08:43,659 --> 00:08:45,770
und selber ne tastatur darstellen,

189
00:08:46,060 --> 00:08:48,030
ist ziemlich ekelhaft

190
00:08:49,190 --> 00:08:52,690
das zweite ist, unser ram, den wir haben, unseren Arbeitsspeicher

191
00:08:52,690 --> 00:08:58,340
ist bei so einem Arduino sehr beschränkt, bei so einem Arduino Leonardo sind es 2.5 kB

192
00:08:59,180 --> 00:09:03,200
Unser Programmspeicher, wo sozusagen die Anwendung reingeladen wird auf das Arduino

193
00:09:03,200 --> 00:09:05,740
ist auch relativ klein mit 28 kb

194
00:09:06,170 --> 00:09:09,960
und das dritte, bzw das vierte, ist die...

195
00:09:09,970 --> 00:09:11,820
ich habs "mobile technology gap" genannt

196
00:09:11,820 --> 00:09:13,740
da komm ich gleich noch drauf zu sprechen, was ich damit meine

197
00:09:14,390 --> 00:09:15,700
So. Die Tastaturen.

198
00:09:16,480 --> 00:09:18,940
Jeder von euch hat sicherlich schonmal ein Betriebssystem eingerichtet

199
00:09:18,940 --> 00:09:19,750
und da wurde dann gefragt:

200
00:09:19,750 --> 00:09:21,660
ja, was für eine Tastatur hast du denn bei dir angeschlossen?

201
00:09:21,950 --> 00:09:24,600
Dann darf man auswählen, dass man eine deutsche Tastatur hat, eine de-DE

202
00:09:24,600 --> 00:09:26,500
oder eine de-CH oder was auch immer

203
00:09:27,280 --> 00:09:29,570
wo schlussendlich definiert wird, wenn man auf eine Taste drückt,

204
00:09:29,570 --> 00:09:31,130
was für ein Zeichen fällt hinten bei raus

205
00:09:32,730 --> 00:09:38,760
ich hab mal die häufigsten, die man in Europa sieht, aufgeschrieben

206
00:09:39,040 --> 00:09:42,480
gibt da dann zum Beispiel wie gesagt qwertz-de, qwertz aus der Schweiz

207
00:09:42,540 --> 00:09:45,860
qwertz aus Dänemark, qwerty aus Großbritannien, qwerty aus den USA

208
00:09:46,050 --> 00:09:48,080
azerty aus frankreich, azerty aus belgien,

209
00:09:48,260 --> 00:09:51,450
dann noch mal schon gemixt zwischen Mac und Windows und so weiter und so fort.

210
00:09:52,457 --> 00:09:55,360
wie gerade schon gesagt, unser Programmflash ist 28 kb groß

211
00:09:55,360 --> 00:09:58,240
und so ein Layout was sozusagen diese Umwandlung macht

212
00:09:58,251 --> 00:10:00,011
zwischen welche Taste zu welchem Zeichen

213
00:10:00,800 --> 00:10:02,091
braucht ein bisschen an Bytes.

214
00:10:03,211 --> 00:10:06,685
Zuviel, um alle möglichen abbilden zu können im Ardiuno selber.

215
00:10:07,577 --> 00:10:09,634
Wir haben auch einen Datenflash, der ist 1 kb groß,

216
00:10:09,725 --> 00:10:12,000
sozusagen Permamentspeicher, den man nochmal selber beschrieben kann,

217
00:10:12,274 --> 00:10:14,605
der ist nur 1kb groß, da passt grad mal eins rein,

218
00:10:15,400 --> 00:10:19,000
deswegen braucht man eine Lösung einfach, eines drauf flashen zu können,

219
00:10:19,000 --> 00:10:20,780
und wenn man seine Tastatur auf einmal wechseln sollte,

220
00:10:20,780 --> 00:10:23,090
- warum auch immer - einfach ein neues draufflashen zu können.

221
00:10:24,220 --> 00:10:26,580
So. So sieht das ganze dann aus:

222
00:10:26,580 --> 00:10:29,370
Das rechts ist sozusagen ein qwertz-de-Layout

223
00:10:30,500 --> 00:10:31,950
schön encodiert einfach als Hex

224
00:10:33,070 --> 00:10:34,930
und links sieht man dann wie das ganze aussieht

225
00:10:34,930 --> 00:10:35,960
wenn es dann gerade gesfllasht wird.

226
00:10:37,640 --> 00:10:40,060
So. Das zweite Problem ist der RAM.

227
00:10:40,650 --> 00:10:44,100
Wie gesagt 2.5 kb bei so einem Arduino Leonardo ist nicht gerade viel

228
00:10:44,290 --> 00:10:45,150
und was wir auch noch machen

229
00:10:45,150 --> 00:10:46,900
wir machen ja auch noch String-Bearbeitung,

230
00:10:47,060 --> 00:10:48,510
was nicht so schön ist.

231
00:10:48,960 --> 00:10:51,640
Weil, wenn man sich vorstellt, so ein kleiner Speicher, man allkoiert zwei Blöcke,

232
00:10:51,880 --> 00:10:53,920
deallokiert den ersten, und schon hat man ein Speicherloch

233
00:10:54,830 --> 00:10:57,040
sprich, fragmentierten Speicher,

234
00:10:57,670 --> 00:10:59,890
und wenn man das oft genug macht, dann ist der Ram voll,

235
00:10:59,890 --> 00:11:01,770
und man kann keine neuen Blöcke allokieren,

236
00:11:01,770 --> 00:11:04,060
und schon ist man in einer Deadlock Situation.

237
00:11:05,730 --> 00:11:08,640
Was ich deswegen gemacht habe, ich habe einen eigenen kleinen Speichermanager geschrieben

238
00:11:08,890 --> 00:11:11,930
dem man im Grunde übergibt, so viel Speicher sollst du verwalten

239
00:11:11,930 --> 00:11:13,930
soviele Blöcke sind maximal nöglich

240
00:11:14,450 --> 00:11:16,590
und sobald ein block deallokiert wird,

241
00:11:16,590 --> 00:11:18,840
werden einfach alle blöcke dahinter nach vorne geschoben.

242
00:11:19,110 --> 00:11:21,620
sodass man permanent eine Defragmentiertung des Speichers hat.

243
00:11:22,440 --> 00:11:23,460
Funktioniert ziemlich gut.

244
00:11:24,350 --> 00:11:25,290
Braucht auch nicht so lange.

245
00:11:26,540 --> 00:11:28,110
Ja. So würde es ansonsten aussehen,

246
00:11:28,110 --> 00:11:29,760
man hat überall kleine Miniblöcke,

247
00:11:30,910 --> 00:11:32,250
die man nicht mehr ordentlich benutzen kann

248
00:11:32,250 --> 00:11:34,090
und irgendwann ist der Speicher voll, wenn man neu allokieren will.

249
00:11:34,270 --> 00:11:34,590
Doof.

250
00:11:35,730 --> 00:11:36,070
So.

251
00:11:37,440 --> 00:11:39,490
Mein größtes Problem ist eigentlich der Programmflash,

252
00:11:39,490 --> 00:11:41,180
also sprich, wie groß kann die Anwendung sein.

253
00:11:42,540 --> 00:11:44,010
Das Usb-Host-Shield, was ich verwende,

254
00:11:44,100 --> 00:11:45,620
hat eine eigenen Bibliothek, wie gesagt,

255
00:11:46,020 --> 00:11:48,150
die immer mehr Funktionen bekommt,

256
00:11:48,150 --> 00:11:49,550
die entspchend aber auch immer größer wird,

257
00:11:49,550 --> 00:11:51,780
und auch immer mehr Programflash weg frisst.

258
00:11:53,500 --> 00:11:56,060
Wie auch schon gesagt, derzeit wird noch sha1 und rc4 benutzt,

259
00:11:56,060 --> 00:11:58,220
einfach deswegen, es passt gut in den Ram rein,

260
00:11:58,220 --> 00:11:59,830
und passt gut in den program flash rein

261
00:11:59,830 --> 00:12:01,850
also relativ schmal zu implementieren.

262
00:12:02,900 --> 00:12:04,740
Bessere Crypto braucht einfach mehr Platz,

263
00:12:05,550 --> 00:12:08,080
das ist eins der Themen an denen ich derzeit arbeite.

264
00:12:08,980 --> 00:12:12,210
Die andere Sache ist, auch neue Features brauchen mehr Platz.

265
00:12:13,540 --> 00:12:15,740
Ein Feature, was ich mir z.B. noch vorstelle,

266
00:12:15,740 --> 00:12:17,930
hab ich einfach mal type-through encryption genannt

267
00:12:18,210 --> 00:12:19,850
sprich, wie damals bei der Enigma,

268
00:12:20,010 --> 00:12:23,830
man hat sein calcpw, hat das in den Modus geschaltet,

269
00:12:24,110 --> 00:12:27,020
und während man seinen Text eintippt, wird der Text verschlüsselt

270
00:12:27,020 --> 00:12:28,900
und erst vershlüsselt an den Rechner übertagen

271
00:12:29,180 --> 00:12:30,050
der angeschlossen ist.

272
00:12:30,290 --> 00:12:34,060
So kann man z.B. dann in Internetcafés oder sowas

273
00:12:34,340 --> 00:12:36,150
vertrauliche Infromationen schreiben

274
00:12:36,150 --> 00:12:40,200
könnte sie auf, ja was auch immer, Pastebin oder sowas ablegen

275
00:12:40,510 --> 00:12:42,690
und derjenige, der es lesen soll, kann es dann entschlüsseln.

276
00:12:43,440 --> 00:12:44,010
So.

277
00:12:44,100 --> 00:12:46,070
Die Lösung, die ich jetzt gemacht habe, bei Revision "d"

278
00:12:46,070 --> 00:12:47,910
ist einfach ein zweites Arduino dazuzu nehmen,

279
00:12:48,200 --> 00:12:49,540
genauer gesagt ein Arduino Uno.

280
00:12:50,010 --> 00:12:51,390
Vorteil am Arduino Uno:

281
00:12:51,390 --> 00:12:54,360
Die Bauteile für den Kern des ganzen kosten gerade mal 5€

282
00:12:54,360 --> 00:12:55,570
und die kann man selber zusammenlöten

283
00:12:58,290 --> 00:13:01,620
so sieht das übrigens aus, wenn ein sogenannter Sketch zu groß wird,

284
00:13:01,620 --> 00:13:03,240
man kriegt einfach nur die Meldung "zu groß"

285
00:13:03,240 --> 00:13:05,440
kannste ja mal da kucken, wie du das vielleicht kleiner kriegst,

286
00:13:05,750 --> 00:13:08,970
ist poblematisch wenn eben der Code gebraucht wird,

287
00:13:08,970 --> 00:13:10,350
weil die Funktion ansonsten nicht funktioniert.

288
00:13:12,470 --> 00:13:15,690
Und das letzte, mobile technology gap:

289
00:13:16,460 --> 00:13:20,770
wir werden immer mobiler, wir haben unsere Laptops dabei,

290
00:13:20,770 --> 00:13:22,930
wo wir keine Tastatur unbedingt mitschleppen wollen,

291
00:13:22,930 --> 00:13:24,640
mit noch einem Extragerät, was wir anschließen,

292
00:13:24,910 --> 00:13:27,750
wir haben unsere Tablets, wo wir keine Usb-Tastaturen anschließen können,

293
00:13:27,750 --> 00:13:30,480
wir haben unsere Smartphones, wo wir keine Usb-Tastaturen anschließen können,

294
00:13:31,730 --> 00:13:32,990
ist etwas umständlich.

295
00:13:33,530 --> 00:13:37,220
So, und deswegen zwei Sachen, an denen ich derzeit arbeite,

296
00:13:37,220 --> 00:13:39,830
ist zum einen die calcpw-Funktionalität

297
00:13:39,830 --> 00:13:41,260
in eine Tastatur zu integrieren

298
00:13:41,560 --> 00:13:45,530
und die andere ist, dass calcpw nicht mehr nur über Usb funktioniert

299
00:13:45,530 --> 00:13:47,640
sondern auch über Bluetooth angeschlossen werden kann.

300
00:13:48,130 --> 00:13:51,850
Bluetooth haben wir Glück, funktioniert inzwischen mit Android realtiv gut,

301
00:13:51,850 --> 00:13:54,220
funktioniert auch mit iOS relativ gut,

302
00:13:55,230 --> 00:13:59,000
wo wir also Smartphones und Tablets abdecken können.

303
00:13:59,190 --> 00:14:01,340
Wenn man sozusagen eine Tastatur hätte, wo die Funktion drin ist,

304
00:14:01,340 --> 00:14:03,690
diese Tastatur funktioniert per Bluetooth,

305
00:14:04,680 --> 00:14:08,020
würde einige Probleme zumindest lösen können.

306
00:14:09,720 --> 00:14:12,660
So sieht ein Test aus, den ich derzeit gemacht habe,

307
00:14:12,660 --> 00:14:15,580
das ist ein einfaches Numpad, wie man früher hatte,

308
00:14:15,580 --> 00:14:17,680
wenn man dreimal auf die 2 drückt, kommt ein C raus

309
00:14:18,370 --> 00:14:19,850
die ganzen Sachen eingeben kann,

310
00:14:20,150 --> 00:14:21,290
funktioniert erstmal,

311
00:14:23,250 --> 00:14:25,300
das ist eine andere Sache, an der ich gearbeitet habe

312
00:14:25,990 --> 00:14:27,520
das da unten ist eine Tastaturmatrix,

313
00:14:27,520 --> 00:14:30,330
die ich aus einer normalen Kauftastatur rausgeholt habe,

314
00:14:30,880 --> 00:14:32,610
besteht im Grunde aus drei Schichten,

315
00:14:32,850 --> 00:14:34,740
eine untere leitenden Schicht, eine obere leitende Schicht

316
00:14:34,740 --> 00:14:35,510
und eine Trennschicht

317
00:14:35,510 --> 00:14:37,940
und jedesmal wenn man eine Taste drückt, wird die Oberschicht

318
00:14:37,940 --> 00:14:39,780
durch die Trennschicht auf die Unterschicht gedrückt

319
00:14:39,990 --> 00:14:43,730
und man kann herausfinden durch einfaches durchschalten

320
00:14:43,730 --> 00:14:45,180
welche Taste gerade gedrückt wurde

321
00:14:45,530 --> 00:14:47,080
und genau das ist was ich vorhabe.

322
00:14:47,080 --> 00:14:50,420
Sozusagen mich selber zwischen diese Matrix

323
00:14:50,650 --> 00:14:54,160
und den eigentlichen Controller der Tastatur zu bringen

324
00:14:54,580 --> 00:14:56,540
um dann den Controller zu benutzen als Output

325
00:14:56,540 --> 00:14:58,840
und die Matrix zu verwenden als Input.

326
00:14:59,430 --> 00:15:00,910
Man sieht, ist gar nicht so einfach,

327
00:15:01,460 --> 00:15:04,850
weil diese Matrix ist schlussendlich ein bisschen Plastik

328
00:15:04,850 --> 00:15:06,500
wo ein bisschen Silber aufgedampft ist,

329
00:15:07,400 --> 00:15:08,870
da dran löten funktioniert nicht.

330
00:15:09,650 --> 00:15:12,400
Mein derzeitiger Versuch ist, mit sogenanntem Leitfaden

331
00:15:13,160 --> 00:15:16,740
in die einzelnen Auflagekontakte von dieser Matrix zu stechen,

332
00:15:16,940 --> 00:15:21,160
dort einen Knoten zu machen, das ganze mit Nagellack zu fixieren

333
00:15:21,160 --> 00:15:24,380
und dann zu versuchen, das ganze an den Microcontroller anzuschließen

334
00:15:24,380 --> 00:15:31,110
*Applaus*

335
00:15:31,440 --> 00:15:35,680
Aber falls jemand eine Ahnung hat, wie man solche Auflagekontakte herstellen kann,

336
00:15:35,680 --> 00:15:38,600
wär das natürlich sehr hilfreich das würde nicht so viel frickeln sein.

337
00:15:39,540 --> 00:15:40,140
Ja.

338
00:15:41,870 --> 00:15:43,620
Gut, ich hab noch mehr als genug Zeit,

339
00:15:44,230 --> 00:15:45,650
aber trotzdem kann ich euch schonmal sagen,

340
00:15:45,650 --> 00:15:47,710
wenn ihr weitere Informationen haben wollt,

341
00:15:47,800 --> 00:15:49,360
könnt ihr einfach auf http://calc.pw gehen

342
00:15:49,680 --> 00:15:52,960
die Slides selber findet ihr auf http://calc.pw/30c3

343
00:15:53,860 --> 00:15:56,890
und da ich noch Zeit habe, kann ich ja noch ein bisschen weiter gehen.

344
00:15:59,980 --> 00:16:01,600
Eine Frage, die sich sicherlich stellen wird, ist

345
00:16:01,600 --> 00:16:04,780
wenn man jetzt so ein Ding hat, was Passwörter berechnet,

346
00:16:05,100 --> 00:16:07,810
wie kann man z.B. denn bestimmen, wie lang diese Passwörter sein sollen

347
00:16:07,810 --> 00:16:09,570
oder welche Sonderzeichen verwendet werden?

348
00:16:10,320 --> 00:16:12,380
Das wird bei calcpw derzeit inline gemacht,

349
00:16:12,620 --> 00:16:16,010
sprich man hat seine Information und kann hinten drann noch ein paar Sachen hinzuschreiben

350
00:16:16,300 --> 00:16:19,870
die die Passwörtberechnung beeinflussen

351
00:16:20,060 --> 00:16:23,940
das ist zum einen das Fragezeichen gefolgt von einem Integer bis 50

352
00:16:24,290 --> 00:16:27,010
wo man angibt wie lange das Passwort sein soll, das generiert wird

353
00:16:27,440 --> 00:16:30,210
50 einfach deswegen weil wir wenig RAM haben

354
00:16:30,210 --> 00:16:32,840
und ewiglange Passwörter generieren und im Ram halten ist schwierig

355
00:16:33,930 --> 00:16:35,720
dann gibt es noch das Ausrufezeichen

356
00:16:36,200 --> 00:16:39,190
wo man angeben kann welche Sonderzeichen verwendet werden dürfen,

357
00:16:39,610 --> 00:16:44,350
aus meiner Erfahrung mit dem Passwortcalculator Pass Calc also dieser Windows Software

358
00:16:45,340 --> 00:16:52,600
kann ich sagen, dass in 99,9% braucht man keine Sonderzeichen in Passwörtern

359
00:16:54,280 --> 00:16:59,160
deswegen eher so, dass man ihm wirklich sagt ok Ausrufezeichen welche Sonderzeichen sind erlaubt

360
00:16:59,630 --> 00:17:03,480
die kann man auch wild durcheinander mixen also egal in welcher Reihnefolge man sie angibt

361
00:17:03,780 --> 00:17:05,240
man muss halt immer wieder alle angeben.

362
00:17:05,867 --> 00:17:12,050
So. Dann gibt es noch ein großes Problem, was Passwortformulare häufig wollen oder manchmal wollen,

363
00:17:12,780 --> 00:17:16,490
dass man mindestens das eingibt und mindestens das eingibt und mindestens das eingibt

364
00:17:17,140 --> 00:17:19,910
dafür gibt es noch die Route die man vorne ran schreiben kann, die macht einfach einen Check:

365
00:17:20,220 --> 00:17:22,950
Ok, ist mindestenes ein Buchstabe enthalten ist mindestens eine Zahl enthalten?

366
00:17:23,280 --> 00:17:27,108
wenn man das Ausrufezeichen benutzt ist sowieso immer mindestens ein Sonderzeichen enthalten.

367
00:17:27,579 --> 00:17:32,270
Und so kann man auch solche Checks einbauen, dass ein Passwort irgendwelche Anforderungen erfüllt.

368
00:17:32,940 --> 00:17:36,710
So sehen dann Informationen aus die man eingeben kann "SomeINFO".

369
00:17:36,710 --> 00:17:40,830
"SomeINFO?25" wäre entsprechend Passwort 25 Zeichen lang,

370
00:17:40,830 --> 00:17:44,110
"SomeINFO" mit plus minus mal geteilt - eines davon wird genommen -

371
00:17:44,540 --> 00:17:47,530
dann eben "SomeINFO" 8 Zeichen langes Passwort als Default

372
00:17:47,530 --> 00:17:49,840
und da muss dann mindestens eine Zahl und ein Buchstabe drinn sein.

373
00:17:50,150 --> 00:17:52,820
Das ganze dann nochmal kombiniert und das ganze dann nochmal kombiniert.

374
00:17:53,690 --> 00:17:56,000
Ja, eine Folie hatte ich noch.

375
00:17:56,000 --> 00:17:56,670
Ja genau.

376
00:17:57,720 --> 00:18:00,890
So sieht der Ablauf aus wenn man das ganze verwendet,

377
00:18:02,200 --> 00:18:05,040
wie gesagt wenn es hoch fährt wird man einmal nach dem Passwort gefragt,

378
00:18:05,710 --> 00:18:08,680
das ganze soll man nochmal eingeben falls man sich vertippt hat, das man das mitkriegt

379
00:18:08,680 --> 00:18:12,470
und kommt dann eben in diesen pass-through-Modus wo die Daten einfach durchgereicht werden

380
00:18:12,920 --> 00:18:17,020
und wenn man den Passwortmodus wechselt gibt man die Information ein und drückt dann Enter

381
00:18:17,020 --> 00:18:19,530
Passwort wird berechnet und man kommt zurück in den pass-through Modus.

382
00:18:20,140 --> 00:18:21,950
Ja. Damit ist auch mein Backup zu Ende.

383
00:18:22,750 --> 00:18:23,060
Danke.

384
00:18:23,060 --> 00:18:31,680
*Applaus*

385
00:18:31,680 --> 00:18:33,960
Herald Engel: Ja vielen Dank für diesen hervorragenden Talk

386
00:18:33,960 --> 00:18:37,690
ich denke er ist sehr interessant und vielleicht haben wir ja auch ein paar interessante Ideen

387
00:18:37,690 --> 00:18:39,530
wie man das zum Beispiel erweitern könnte.

388
00:18:40,030 --> 00:18:41,630
Und damit sind dann die Fragen eröffnet.

389
00:18:42,390 --> 00:18:48,510
Ich bitte euch einfach an den Mikrofonen aufzustellen, an eins und zwei... vor allem.

390
00:18:54,740 --> 00:18:58,520
Frage 1: Mich interessiert, du sagt wenn du die reine Software verwendest

391
00:18:59,370 --> 00:19:03,300
und der Rechner ist kompromittiert, dann hast du hinterher ein Problem und kannst alle Passwörter ändern

392
00:19:03,720 --> 00:19:07,590
aber wenn der Rechner so kompromittiert ist, kann ja immer noch passieren,

393
00:19:08,940 --> 00:19:12,580
musst du nicht alle verwenden, man kommt auch nicht an dein Master Passwort ran,

394
00:19:12,910 --> 00:19:16,640
aber die expliziten Passwörter die du da verwendet hast sind auch tot.

395
00:19:17,140 --> 00:19:20,440
Kenny: Ja die sind schlussendlich tot wenn man dem Gerät nicht vertrauen kann, richtig.

396
00:19:20,440 --> 00:19:23,990
Ist eben der primäre Vorteil deswegen auch in dem Algorithmus entsprechend ...

397
00:19:32,180 --> 00:19:36,090
Ich wurde ein paar mal gefragt warum ich einfach nur hashe oder nur verschlüssele:

398
00:19:36,440 --> 00:19:39,100
Einfacher Hintergrund: Wir wollen dieses Master Passwort schützen,

399
00:19:39,370 --> 00:19:42,940
und dadurch das beides eingesetzt wird haben wir zwei Ebenen von Schutz drin,

400
00:19:43,860 --> 00:19:48,190
wenn sozusagen ein Passwort kompromittiert wird müssen wir nicht nur durch den Hash-Algorithmus durchbrechen können,

401
00:19:48,190 --> 00:19:50,140
sondern wir müssen auch durch die Verschlüsselung durchbrechen können.

402
00:19:50,350 --> 00:19:52,440
Das ist das gleiche wie wenn wir Firewalls aufbauen,

403
00:19:52,630 --> 00:19:55,130
da sollte man immer zwei nehmen und zwar von verschiedenen Herstellern.

404
00:19:55,620 --> 00:19:56,590
Ist hier genau das gleiche.

405
00:19:57,660 --> 00:20:02,080
Ja, wenn dieses eine Passwort auf einem Rechner verwendet wird der komprommitiert ist,

406
00:20:02,080 --> 00:20:06,240
ist dieses Passwort verbrannt, weil es wird schlussendlich unverschlüsselt an den Rechner geschickt.

407
00:20:08,360 --> 00:20:12,680
Hauptziel hier ist es, das aufgrund eines Passwortes oder aufgrund von n Passwörtern,

408
00:20:14,210 --> 00:20:18,690
die abgelesen werden, nicht auf das Master-Passwort zurückgeführt werden kann.

409
00:20:19,110 --> 00:20:20,670
Das ist hier einer der Hauptgründe.

410
00:20:21,370 --> 00:20:24,220
Deswegen Hardware und deswegen auch die Wahl des Algorithmus.

411
00:20:27,850 --> 00:20:34,490
Frage 2: Was machst denn du wenn dann eines deiner Passwörter bekannt geworden ist?

412
00:20:34,490 --> 00:20:38,180
Also dein ebay-Passwort, deine Info ebay ist genommen.

413
00:20:38,330 --> 00:20:42,200
Musst du dann künftig "ebay2" eintippen damit du die nächste Info hast, oder?

414
00:20:43,780 --> 00:20:44,690
Kenny: Ja, leider.

415
00:20:44,690 --> 00:20:48,400
Es gibt möglicherweise verschiedene Möglichkeiten,

416
00:20:48,400 --> 00:20:50,330
man kann z.B. anstatt "ebay" "ebay.com" nehmen.

417
00:20:51,270 --> 00:20:54,050
Frage 2: Jaja okay, aber du musst dir wieder ein neues ausdenken.

418
00:20:54,050 --> 00:20:56,180
Kenny: Ja, schlussendlich muss man sich eine neue Information ausdenken, das ist richtig.

419
00:20:56,810 --> 00:20:59,760
Man hat aber immer noch den Vorteil, das nicht plötzlich sämtliche Passwörter ändern muss.

420
00:21:00,230 --> 00:21:01,820
Frage 2: Ok, und dann habe ich noch eine Frage:

421
00:21:03,430 --> 00:21:06,990
In diesem pass-through Modus, gibt es da irgendwie eine spürbare Latenz von der Tastatur

422
00:21:06,990 --> 00:21:08,380
oder verlierst du irgendwelche Features?

423
00:21:09,340 --> 00:21:11,750
Kenny: In dem pass-through Modus habe ich noch keine Latenz mitbekommen.

424
00:21:11,750 --> 00:21:16,170
Man muss dazu sagen ich bin nur Entwickler und schreibe Texte, ich bin kein Gamer,

425
00:21:17,000 --> 00:21:20,090
man sollte also nicht unbedingt als Gamer da seine Gaming-Tastatur anschließen.

426
00:21:25,550 --> 00:21:27,250
Herald: Okay, wenn es keine Fragen mehr gibt hätte...

427
00:21:27,250 --> 00:21:28,410
Kenny: Doch ich glaube noch da, zwei.

428
00:21:28,720 --> 00:21:30,090
Herald: ... hätte ich sonst eine gehabt.

429
00:21:30,380 --> 00:21:32,290
Frage 3: Ja ich hätte da noch eine Frage und zwar:

430
00:21:32,290 --> 00:21:35,840
wie genau sieht das dann aus, weil das lädt ja eher dazu ein,

431
00:21:35,840 --> 00:21:38,060
dass man eher schwache Passwörter verwendet

432
00:21:38,060 --> 00:21:40,250
wie gerade geschrieben "ebay" einfach nur.

433
00:21:40,650 --> 00:21:43,120
Wenn dann jemand Zugriff auf das Gerät hat,

434
00:21:43,120 --> 00:21:46,100
das er dann ganz einfach an viele Accounts ran kommen kann?

435
00:21:48,610 --> 00:21:49,910
Kenny: Nicht unbedingt... *lacht*

436
00:21:51,220 --> 00:21:56,210
Schlussendlich, auch wieder hier aufgrund des Algorithmus, wir versuchen sowas wie...

437
00:21:56,210 --> 00:21:59,440
also, es wird versucht sowas wie Rainbowtables zu verhindern

438
00:21:59,440 --> 00:22:03,670
in dem eben du damit du überhaupt die Verschlüsselung im zweiten Schritt machen zu können

439
00:22:04,720 --> 00:22:06,730
du jedes Master Passwort nehmen musst

440
00:22:06,730 --> 00:22:09,120
und dort jede Information nehmen musst, die du durchprobieren willst.

441
00:22:10,610 --> 00:22:13,600
Das generieren deiner Rainbowtable dauert schlussendlich länger,

442
00:22:13,970 --> 00:22:16,530
und auch dann ist deine Rainbow table größer, weil du

443
00:22:16,860 --> 00:22:18,760
kannst ja nicht nur davon ausgehen das jemand "ebay" benutzt,

444
00:22:18,760 --> 00:22:20,810
du kannst auch "ebay.com" nehmen, du kannst "ebay.de" nehmen,

445
00:22:20,810 --> 00:22:22,850
du kannst was auch immer

446
00:22:24,920 --> 00:22:27,560
irgendwie deinen Usernamen nehmen,

447
00:22:29,230 --> 00:22:31,030
es wird dadurch divergierter.

448
00:22:31,630 --> 00:22:32,260
Frage 3: Ja okay.

449
00:22:34,740 --> 00:22:37,840
Frage 4: I've got a question about the iteration,

450
00:22:38,020 --> 00:22:42,830
most passwords do have an expiration date, so they have 90 days

451
00:22:43,410 --> 00:22:46,950
you've got to just change your password.

452
00:22:46,950 --> 00:22:48,660
How do you handle that?

453
00:22:49,020 --> 00:22:51,900
Kenny: Well, the question is how do we handle that with passwort schemes?

454
00:22:51,970 --> 00:22:58,700
Normally you have one character where you just increment a character or a number

455
00:22:58,700 --> 00:23:04,950
or you add something like "q1" for the first quarter of the year.

456
00:23:05,370 --> 00:23:13,300
Thats the same here so you could add for example "ebay" space then "q12014"

457
00:23:13,610 --> 00:23:17,050
than you have your passwort for that actual quarter of the year.

458
00:23:17,780 --> 00:23:18,220
Frage 4: Okay thanks.

459
00:23:18,510 --> 00:23:18,790
Kenny: Ok

460
00:23:23,850 --> 00:23:24,750
Herald: More questions?

461
00:23:26,120 --> 00:23:30,340
Is there something from the internet maybe? Where is the signal angel anyway? Yeah?

462
00:23:33,060 --> 00:23:34,130
Frage 5: I have one question,

463
00:23:34,130 --> 00:23:39,560
I was wondering wheter you could use - I don't know - maybe I should stick to english?

464
00:23:40,550 --> 00:23:43,580
I was wondering how you could use that system

465
00:23:43,580 --> 00:23:47,710
to somehow prevent that keyloggers can

466
00:23:48,480 --> 00:23:51,630
kind of get what you are typing.

467
00:23:51,830 --> 00:23:56,090
Kenny: Oh well, should I answer in English? *laughs*

468
00:23:58,330 --> 00:24:05,510
You have to differentiate between software keyloggers that are run on your computer

469
00:24:05,800 --> 00:24:07,200
you can't prevent that

470
00:24:07,560 --> 00:24:09,610
but when you use such a hardware

471
00:24:09,850 --> 00:24:15,290
and you have to look at it because it has an LED or an LCD where your information is shown

472
00:24:16,450 --> 00:24:21,160
you can see where your usb cable is going along

473
00:24:21,160 --> 00:24:24,930
and thus can see when there is another piece of hardware attatched to it.

474
00:24:24,930 --> 00:24:25,360
Frage 5: Yeah, ok.

475
00:24:31,070 --> 00:24:31,910
Herald: Next question?

476
00:24:33,590 --> 00:24:36,970
Frage 6: I'm really not sure if I should continue in English, I'll just do it..

477
00:24:36,970 --> 00:24:37,990
Herald: Wir könnten auch auf D...

478
00:24:38,470 --> 00:24:39,150
Kenny: Wir können auch auf Deutsch!

479
00:24:39,150 --> 00:24:40,420
Frage 6: *lacht* Dann machen wir auf Deutsch.

480
00:24:42,530 --> 00:24:47,900
Eine kleine Frage zu dem ganze Konzept von diesem sozusagen Zwischenschalten

481
00:24:47,900 --> 00:24:52,840
eines neuen Gerätes zwischen sozusagen Keyboard und dem tatsächlichen Computer,

482
00:24:53,190 --> 00:24:57,120
ich bin jetzt nicht wirklich technik-affin und würde einfach fragen, ob du

483
00:24:57,770 --> 00:25:03,920
darin sozusagen die Zukunft der persönlichen Sicherheit für Computer oder Passwörter allgemein siehst?

484
00:25:05,580 --> 00:25:11,260
kenny: Ich sehe die Zukunft von Logins definitiv in zusätzlicher Hardware, ja,

485
00:25:11,620 --> 00:25:14,400
wir haben es ja schon mit verschiedenen Tokens, wir haben RSA Tokens,

486
00:25:14,710 --> 00:25:16,180
wir haben irgend welche anderen Tokens

487
00:25:16,180 --> 00:25:18,620
die du dir von Google zuschicken kannst - whatever

488
00:25:18,980 --> 00:25:21,070
ich denke schon, dass es in diese Richtung gehen wird, ja.

489
00:25:29,330 --> 00:25:31,920
Frage 7: Denkst du auch über sowas wie "challenge response" nach?

490
00:25:31,920 --> 00:25:34,960
Also letzendlich hast du ja das Problem

491
00:25:34,960 --> 00:25:36,860
wenn du das Passwort einmal über den Computer geschickt hast,

492
00:25:36,860 --> 00:25:40,120
mag es abgegriffen worden sein,

493
00:25:40,460 --> 00:25:43,400
aber wenn du z.B. einen challenge response system einführen würdest,

494
00:25:43,400 --> 00:25:49,070
also sprich der Computer schickt etwas an dein Device, USB geht in beide Richtungen,

495
00:25:49,820 --> 00:25:51,050
rechnen rechnen, zurück.

496
00:25:53,230 --> 00:25:57,440
Kenny: Dir geht es also darum, dass du etwas vom Computer über USB an das Gerät schickst

497
00:25:57,440 --> 00:25:59,350
das irgendwas macht und es dir wieder zurück schickt?

498
00:26:00,960 --> 00:26:05,160
War so schon implementiert, nannte sich Revision "A", nicht ohne Grund.

499
00:26:06,650 --> 00:26:08,230
Denn hier hat man dann genau das Problem,

500
00:26:08,230 --> 00:26:10,460
das man das ganze schon an den Rechner eintippt,

501
00:26:10,770 --> 00:26:12,410
der entsprechend angreifbar ist,

502
00:26:12,790 --> 00:26:14,280
und dann kann man auch gleich ein Stück Software nehmen.

503
00:26:17,370 --> 00:26:19,260
Weil man schlussendlich, man gibt es am Rechner ein,

504
00:26:19,260 --> 00:26:21,300
der ist kompromittiert, kann das Master-Passwort auslesen,

505
00:26:21,550 --> 00:26:26,200
schickt das ganze dann an ein Gerät was offene Algorithmen verwendet,

506
00:26:26,290 --> 00:26:28,500
berechnet irgendwas, was man auch selber dann berechnen kann,

507
00:26:28,500 --> 00:26:31,270
denn es sind ja offene Algorithmen, schickt das ganze dann wieder zurück.

508
00:26:31,400 --> 00:26:35,860
Also schlussendlich hast du dann höchstens einen Prozessor der dir das ganze abnimmt

509
00:26:35,960 --> 00:26:37,460
der vielleicht optimiert sein könnte.

510
00:26:37,810 --> 00:26:40,400
Aber der Angriffsvektor von der normalen Software ist wieder da.

511
00:26:43,610 --> 00:26:49,680
Frage 7: Ich dachte mehr so an z.B. einen SSH-Login über private Keys

512
00:26:49,680 --> 00:26:52,710
die dann halt nicht auf dem Rechner gespeichert sind sondern halt nur auf deiner Device

513
00:26:52,710 --> 00:26:55,960
und das heißt die Informationen die nötig sind um das zu brechen

514
00:26:55,960 --> 00:26:57,360
sind überhaupt nie auf deinem Rechner.

515
00:26:59,980 --> 00:27:01,740
Kenny: Ich weiß nicht ob es in die gleiche Richtung geht,

516
00:27:01,740 --> 00:27:04,860
ich bin derzeit dabei ein Paper zu schreiben über das ganze

517
00:27:06,580 --> 00:27:09,680
wo es darum geht Smartcards zu verwenden

518
00:27:09,680 --> 00:27:11,480
um dort die Informationen darauf zu speichern.

519
00:27:11,480 --> 00:27:13,300
Ich weiß nicht ob es so ein bisschen in die Richtung geht.

520
00:27:14,090 --> 00:27:17,440
Man würde eben das ganze nicht über den Computer

521
00:27:17,440 --> 00:27:20,280
oder über das Betriebssystem hinschicken lassen,

522
00:27:20,280 --> 00:27:23,640
sondern man würde die Information auslagern auf nochmal ein separates Gerät

523
00:27:23,970 --> 00:27:27,250
was man entsprechend auch blacklisten kann - und weiß der Teufel.

524
00:27:27,460 --> 00:27:31,320
Publikum (leise, unverständlich): Es gibt ja auch einen Crypto-Stick, z.B. der sowas wieder macht.

525
00:27:31,320 --> 00:27:31,780
Kenny: Bitte?

526
00:27:31,780 --> 00:27:32,490
Herald: Die F...

527
00:27:32,490 --> 00:27:33,170
Publikum (leise, unverständlich): Crypto-Stick!

528
00:27:33,170 --> 00:27:35,460
Herald: Es gäbe einen Crypto-Stick der so etwas auch macht?

529
00:27:36,870 --> 00:27:37,810
Kenny: Der ist mir nicht bekannt.

530
00:27:38,360 --> 00:27:39,630
Publikum (leise, unverständlich): Der war unvollständig.

531
00:27:39,630 --> 00:27:40,080
Kenny: Ach so.

532
00:27:42,230 --> 00:27:43,280
Herald: Okay, Micro zwei.

533
00:27:43,720 --> 00:27:47,270
Frage 8: Die Frage ist, kann man auch irgendwie das Masterpasswort

534
00:27:47,750 --> 00:27:52,500
irgendwie auf eine Smartcard oder etwas anderes mit zusätzlicher Hardware auslagern,

535
00:27:52,500 --> 00:27:55,950
die du quasi mitnehmen kannst und vom Gerät trennen kannst.

536
00:27:56,230 --> 00:28:01,590
Also und so des, weil das Masterpasswort - wenn man sich dann noch ein, wenn man, weiß nicht,

537
00:28:01,590 --> 00:28:05,050
man neigt dazu, wenn man das Masterpasswort ständig eingeben muss,

538
00:28:05,050 --> 00:28:07,670
das auch wieder zu verkürzen und sich einfacher merkbar zu machen,

539
00:28:08,250 --> 00:28:11,800
das irgendwie besser zu merken auf dem Gerät und...

540
00:28:13,430 --> 00:28:14,960
Kenny: Hatte ich ja gerade schon kurz angesprochen,

541
00:28:14,960 --> 00:28:18,140
in dem Paper das ich gerade schreibe zeige ich genau sowas auf,

542
00:28:18,350 --> 00:28:24,460
zwar eher für Firmen, dass die damit die Passwortverwaltung ihrer Mitarbeiter verbessern könnnen,

543
00:28:24,670 --> 00:28:27,740
aber schlussendlich ja, es macht Sinn das ganze auf ein Gerät zu speichern,

544
00:28:28,520 --> 00:28:31,160
es sollte dann aber ein Gerät sein was sicherer ist,

545
00:28:31,280 --> 00:28:33,400
also sprich Smartcard schlussendlich.

546
00:28:36,180 --> 00:28:41,790
Frage 9: Ja ich hab da ein Problem, wenn die Tastatur an dieses Arduino angeschlossen wird

547
00:28:41,790 --> 00:28:43,380
und das ist dann sozusagen da in der Mitte,

548
00:28:43,760 --> 00:28:47,020
was ist wenn noch irgendwie eine kriminelle Energie -

549
00:28:47,020 --> 00:28:49,970
man sagt ja wenn man physikalsichen Zugriff hat, zum Beispiel auf die Tastatur

550
00:28:49,970 --> 00:28:52,850
und dann zwischen - im Prinzip - irgendwie in der Tastatur

551
00:28:52,850 --> 00:28:56,770
aber zwischen Tastatur und Arduino wieder einen Logger zwischen setzt,

552
00:28:56,770 --> 00:28:59,930
dass dann ja das Passwort wieder, das Masterpasswort

553
00:28:59,930 --> 00:29:06,660
inklusive den anderen Teil dieses Passwortes abgegriffen weden kann.

554
00:29:07,310 --> 00:29:08,960
Also so wohl wenn kriminelle Energie ist,

555
00:29:08,960 --> 00:29:13,000
dann lässt man zwischen Arduino und Tastatur den Logger dazwischen.

556
00:29:13,460 --> 00:29:19,260
Kenny: Ja man muss dazu sagen, Hintergrund ist hier nicht gegen Hardwarekeylogger zu arbeiten.

557
00:29:19,260 --> 00:29:21,480
Einfach deswegen weil man die nicht ordentlich erkennen kann.

558
00:29:22,190 --> 00:29:25,580
Du könntest es irgendwie auf irgend eine bestimmte Tastatur prägen

559
00:29:25,580 --> 00:29:27,900
und könntest dann hoffen, dass du mit den Latenzen heraus findest,

560
00:29:27,900 --> 00:29:29,560
dass wirklich die Tastatur angeschlossen ist.

561
00:29:32,430 --> 00:29:35,180
Macht aber in dem Umfang keinen Sinn,

562
00:29:35,180 --> 00:29:38,320
das ist dann, das geht dann viel zu tief rein, also...

563
00:29:40,160 --> 00:29:42,700
eine Sache hier drann ist, es soll möglichst einfach sein.

564
00:29:42,850 --> 00:29:46,570
Und ein Masterpasswort sich merken und dann irgend eine beliebige Information eingeben

565
00:29:46,570 --> 00:29:48,300
die man sich gut merken oder herleiten kann,

566
00:29:48,870 --> 00:29:51,120
ist noch im Rahmen der Dinge was normaler Nutzer tun kann.

567
00:29:51,450 --> 00:29:54,970
Und dann plötzlich anzufangen irgendwelche speziellen Konfigurationen durchzuführen,

568
00:29:54,970 --> 00:29:56,930
damit nur noch seine Tastatur erkannt wird,

569
00:29:57,690 --> 00:29:58,950
läuft dem ganzen schon wieder zu wider.

570
00:29:59,530 --> 00:30:02,430
Ganz abgesehen davon, es gibt ein Grund warum ihr...

571
00:30:02,810 --> 00:30:05,150
das Passwort immer wieder eingegeben werden soll beim Start

572
00:30:05,150 --> 00:30:08,530
nämlich, dass das Gerät selber nicht Angriffsziel wird.

573
00:30:08,530 --> 00:30:11,020
Wenn es z.B. verloren gehen würde und da würde das Masterpasswort drinn stehen,

574
00:30:11,730 --> 00:30:12,970
hätte man ein großes Problem.

575
00:30:14,100 --> 00:30:16,180
Deswegen eben wirklich so, dass man es immer wieder eingibt.

576
00:30:18,080 --> 00:30:19,910
Herald: Okay das war dann die letze Frage.

577
00:30:19,910 --> 00:30:22,580
Herzlichen Dank nochmal, einen großen Applaus für Kenny

578
00:30:22,580 --> 00:30:30,480
*Applaus*

579
00:30:30,480 --> 00:30:33,140
Herald: Und wer sich die Technologie nochmal näher ankucken kann,

580
00:30:33,500 --> 00:30:35,060
kann gerne hier nach vornen kommen,

581
00:30:35,060 --> 00:30:37,130
wir haben noch ein paar Minuten zwischen den Talks,

582
00:30:37,130 --> 00:30:38,700
da könnt ihr ihn gerne ausfragen.

583
00:30:38,960 --> 00:30:39,210
Kenny: Danke
