1
00:00:01,700 --> 00:00:10,690
[Music]

2
00:00:14,369 --> 00:00:18,310
memory deduplication is widely applied

3
00:00:18,310 --> 00:00:22,360
to reduce memory consumption today we

4
00:00:22,360 --> 00:00:25,150
are going to see three attack techniques

5
00:00:25,150 --> 00:00:29,200
that exploit memory deduplication we

6
00:00:29,200 --> 00:00:32,320
have two incredible security researchers

7
00:00:32,320 --> 00:00:35,050
here with us today that will show us how

8
00:00:35,050 --> 00:00:38,710
these attack works and to the left

9
00:00:38,710 --> 00:00:42,309
I have antonio beret see and to my right

10
00:00:42,309 --> 00:00:47,079
is eric Bassman Bosman sorry and they

11
00:00:47,079 --> 00:00:49,170
will then use the chance to also

12
00:00:49,170 --> 00:00:51,850
introduce themselves please help me

13
00:00:51,850 --> 00:00:56,190
welcome Antonio and Eric

14
00:01:02,879 --> 00:01:07,270
so good morning everyone this is memory

15
00:01:07,270 --> 00:01:09,460
deduplication a curse that keeps on

16
00:01:09,460 --> 00:01:09,759
giving

17
00:01:09,759 --> 00:01:13,210
so unfortunately it's just Eric and me

18
00:01:13,210 --> 00:01:16,509
so Ben and cavae I couldn't make it but

19
00:01:16,509 --> 00:01:18,700
they say hi and I just want to say that

20
00:01:18,700 --> 00:01:20,890
the credit goes also to them so we

21
00:01:20,890 --> 00:01:23,320
prepared the talk together and a big

22
00:01:23,320 --> 00:01:27,039
part of the comp that comes from them so

23
00:01:27,039 --> 00:01:30,220
Eric as he was introduced he is a PhD

24
00:01:30,220 --> 00:01:33,490
student at the fou SEC networks and

25
00:01:33,490 --> 00:01:35,740
system security research group in

26
00:01:35,740 --> 00:01:37,600
Amsterdam so if you want to see what

27
00:01:37,600 --> 00:01:40,000
they do go to the website resect that

28
00:01:40,000 --> 00:01:42,610
and I'm Antonio I'm a co-founder of

29
00:01:42,610 --> 00:01:46,569
extra lab Swiss IT security company in

30
00:01:46,569 --> 00:01:49,659
Zurich so the work that we are going to

31
00:01:49,659 --> 00:01:51,759
present actually there were a lot of

32
00:01:51,759 --> 00:01:53,380
other people working on that and here

33
00:01:53,380 --> 00:01:57,250
are some acknowledgments yeah so let's

34
00:01:57,250 --> 00:01:59,679
start so the message today is actually

35
00:01:59,679 --> 00:02:03,880
quite simple and straightforward memory

36
00:02:03,880 --> 00:02:05,679
the application is much more dangerous

37
00:02:05,679 --> 00:02:08,199
that you might possibly think in the

38
00:02:08,199 --> 00:02:11,050
beginning so it comes along like a nice

39
00:02:11,050 --> 00:02:13,300
little feature that helps you save

40
00:02:13,300 --> 00:02:16,330
memory but we're going to show you that

41
00:02:16,330 --> 00:02:18,220
it's actually dangerous and much more

42
00:02:18,220 --> 00:02:20,830
severe and we're going to do that by

43
00:02:20,830 --> 00:02:23,590
showing you three attack techniques that

44
00:02:23,590 --> 00:02:26,230
all exploit memory deduplication one or

45
00:02:26,230 --> 00:02:29,890
another way before we do that we'll look

46
00:02:29,890 --> 00:02:31,390
at memory need applications so everyone

47
00:02:31,390 --> 00:02:33,879
knows what it is we're going to show you

48
00:02:33,879 --> 00:02:36,069
the site channel that gets introduced by

49
00:02:36,069 --> 00:02:39,099
it and then we start with the three

50
00:02:39,099 --> 00:02:44,050
attacks so first we have Kane Kane is a

51
00:02:44,050 --> 00:02:46,480
cross VM leak attack which basically

52
00:02:46,480 --> 00:02:48,819
allows you to leak base addresses or

53
00:02:48,819 --> 00:02:52,030
other secrets with higher entropy from

54
00:02:52,030 --> 00:02:54,370
other VMs and we applied it to a SLR

55
00:02:54,370 --> 00:02:55,540
because we thought it's an interesting

56
00:02:55,540 --> 00:02:58,299
case and it only relies on memory

57
00:02:58,299 --> 00:03:01,450
deduplication will then show you did up

58
00:03:01,450 --> 00:03:05,230
s machina this is a attack against the

59
00:03:05,230 --> 00:03:06,459
process

60
00:03:06,459 --> 00:03:09,400
and actually got the pony award at this

61
00:03:09,400 --> 00:03:11,079
year's blanket for most innovative

62
00:03:11,079 --> 00:03:13,329
research and it relies on memory

63
00:03:13,329 --> 00:03:15,129
duplication and ro hammer and basically

64
00:03:15,129 --> 00:03:17,769
it allows you to read and write through

65
00:03:17,769 --> 00:03:22,629
JavaScript in in edge without any soft

66
00:03:22,629 --> 00:03:25,510
of ulnar ability and now we are going to

67
00:03:25,510 --> 00:03:28,420
present flip Feng Shui flip Feng Shui is

68
00:03:28,420 --> 00:03:32,379
a cross VM bit flip attack so basically

69
00:03:32,379 --> 00:03:35,439
imagine you could flip a bit in another

70
00:03:35,439 --> 00:03:39,099
VM and the only requirement is you you

71
00:03:39,099 --> 00:03:40,980
have to know the content of the page of

72
00:03:40,980 --> 00:03:44,139
any page so how will you actually

73
00:03:44,139 --> 00:03:45,879
compromise that system so we're going to

74
00:03:45,879 --> 00:03:48,280
show you so first of all how you can

75
00:03:48,280 --> 00:03:50,739
beat flip precisely and then we're going

76
00:03:50,739 --> 00:03:52,269
to show you two techniques to actually

77
00:03:52,269 --> 00:03:56,040
compromise the system with that bit flip

78
00:03:56,040 --> 00:03:59,709
after that we will conclude so let's

79
00:03:59,709 --> 00:04:02,230
start with memory read application so

80
00:04:02,230 --> 00:04:03,639
manga deal application is a method to

81
00:04:03,639 --> 00:04:05,709
reduce memory consumption and it's

82
00:04:05,709 --> 00:04:07,989
usually used in virtualized environment

83
00:04:07,989 --> 00:04:10,180
but not exclusively and it was also

84
00:04:10,180 --> 00:04:13,510
enabled and I emphasis is on was in

85
00:04:13,510 --> 00:04:17,738
Windows 8.1 and 10 so the idea is that

86
00:04:17,738 --> 00:04:20,488
inverter wise environments for example

87
00:04:20,488 --> 00:04:22,630
the virtual machine monitor will try to

88
00:04:22,630 --> 00:04:28,270
be quite a resource or try to save

89
00:04:28,270 --> 00:04:30,430
memory so basically will over commit

90
00:04:30,430 --> 00:04:32,289
certain resources like memory and memory

91
00:04:32,289 --> 00:04:33,789
need application is a technique to

92
00:04:33,789 --> 00:04:37,800
reclaim certain pages in a clever way or

93
00:04:37,800 --> 00:04:42,000
the or easily say speaking run more VMS

94
00:04:42,000 --> 00:04:44,520
so basically it's a nice feature right

95
00:04:44,520 --> 00:04:48,280
the idea is you can you can just have

96
00:04:48,280 --> 00:04:50,560
more VMS on the same hardware but you

97
00:04:50,560 --> 00:04:54,099
see that it has certain implications so

98
00:04:54,099 --> 00:04:56,500
let's look at how it looks it works so

99
00:04:56,500 --> 00:04:58,539
basically as an example you see memory

100
00:04:58,539 --> 00:05:00,370
pages of two virtual machines and the

101
00:05:00,370 --> 00:05:03,759
physical memory of the hardware so let's

102
00:05:03,759 --> 00:05:06,190
say you have like the picture of the

103
00:05:06,190 --> 00:05:08,860
Mona Lisa or a same process running so

104
00:05:08,860 --> 00:05:11,500
the same code pages or something and

105
00:05:11,500 --> 00:05:14,259
some data so basically in a normal

106
00:05:14,259 --> 00:05:16,720
scenario you'll have both address

107
00:05:16,720 --> 00:05:19,480
bases filled up with these pages and all

108
00:05:19,480 --> 00:05:21,970
consumed one physical page so when

109
00:05:21,970 --> 00:05:24,820
memory duplication is enabled the memory

110
00:05:24,820 --> 00:05:26,200
need application of limitation will try

111
00:05:26,200 --> 00:05:29,500
to identify these duplicates and then it

112
00:05:29,500 --> 00:05:31,330
will merge them so that the blue space

113
00:05:31,330 --> 00:05:34,810
gets free again and it will mark these

114
00:05:34,810 --> 00:05:36,310
pages as with the copy-on-write

115
00:05:36,310 --> 00:05:38,080
semantics which basically means if

116
00:05:38,080 --> 00:05:40,720
someone writes to it it it has to do

117
00:05:40,720 --> 00:05:44,040
something else it's not going to work

118
00:05:44,040 --> 00:05:47,230
now one implementation is kernel same

119
00:05:47,230 --> 00:05:50,530
page merging and with K KB M I'm sure

120
00:05:50,530 --> 00:05:53,170
most of you know that so if you have a

121
00:05:53,170 --> 00:05:55,210
Windows Server Window System usually

122
00:05:55,210 --> 00:05:57,220
that's I think even now enabled by

123
00:05:57,220 --> 00:05:59,860
default and you can check it so there is

124
00:05:59,860 --> 00:06:02,110
like the run file on the resist file

125
00:06:02,110 --> 00:06:03,430
system where you see if there is a

126
00:06:03,430 --> 00:06:05,080
wonder it's enabled and then there are

127
00:06:05,080 --> 00:06:07,150
certain parameters that allow you to

128
00:06:07,150 --> 00:06:09,130
define how fast the memory the

129
00:06:09,130 --> 00:06:12,610
application should work and there are

130
00:06:12,610 --> 00:06:16,210
other implementation as well so the

131
00:06:16,210 --> 00:06:17,830
problem with memory application on most

132
00:06:17,830 --> 00:06:20,110
implementations is that it doesn't

133
00:06:20,110 --> 00:06:22,390
respect the security domain and so

134
00:06:22,390 --> 00:06:24,760
basically even between two different VMs

135
00:06:24,760 --> 00:06:26,680
or if it's done for processes if you

136
00:06:26,680 --> 00:06:27,910
have two different processes you cannot

137
00:06:27,910 --> 00:06:30,520
trust each other but it still works

138
00:06:30,520 --> 00:06:33,700
across these boundaries and actually

139
00:06:33,700 --> 00:06:35,740
that's the dilemma of memory little need

140
00:06:35,740 --> 00:06:37,660
application because in the end you wanna

141
00:06:37,660 --> 00:06:39,340
save memory and it makes a lot of sense

142
00:06:39,340 --> 00:06:40,600
right if there's a lot of VMs running

143
00:06:40,600 --> 00:06:43,419
the same operating system so it makes

144
00:06:43,419 --> 00:06:46,120
sense to cross these boundaries but the

145
00:06:46,120 --> 00:06:48,390
problem is it introduces a side channel

146
00:06:48,390 --> 00:06:51,610
so let's look at the side channel so if

147
00:06:51,610 --> 00:06:53,680
you have a page that below belongs to

148
00:06:53,680 --> 00:06:55,630
you you just write to it and that's it

149
00:06:55,630 --> 00:06:59,320
okay so the problem is if you have

150
00:06:59,320 --> 00:07:00,580
married application you have

151
00:07:00,580 --> 00:07:03,240
copy-on-write so now if you write to it

152
00:07:03,240 --> 00:07:06,100
you need to go to the kernel the page

153
00:07:06,100 --> 00:07:09,790
has to be duplicated again test drop the

154
00:07:09,790 --> 00:07:12,040
page tables and then resume the process

155
00:07:12,040 --> 00:07:13,870
again and then you basically can write

156
00:07:13,870 --> 00:07:16,240
to that page so you see that there are a

157
00:07:16,240 --> 00:07:19,240
lot of more steps involved here and this

158
00:07:19,240 --> 00:07:21,910
introduces a one bit side channel that

159
00:07:21,910 --> 00:07:24,100
allows you to see basically if such a

160
00:07:24,100 --> 00:07:26,050
page exists in another process or in

161
00:07:26,050 --> 00:07:28,169
another VM

162
00:07:28,169 --> 00:07:30,090
it works closed VM if it's implemented

163
00:07:30,090 --> 00:07:31,559
in order to machine monitor across

164
00:07:31,559 --> 00:07:34,199
process or as we will see we will see

165
00:07:34,199 --> 00:07:35,879
one instance of that attack even within

166
00:07:35,879 --> 00:07:37,199
a process we have different security

167
00:07:37,199 --> 00:07:39,389
boundaries think about your JavaScript

168
00:07:39,389 --> 00:07:40,110
code right

169
00:07:40,110 --> 00:07:42,330
so it's might be interesting for your

170
00:07:42,330 --> 00:07:44,580
JavaScript code in a browser to find out

171
00:07:44,580 --> 00:07:48,029
certain things so let's look at the

172
00:07:48,029 --> 00:07:50,159
attacker perspective now so what does an

173
00:07:50,159 --> 00:07:54,330
attacker have to do to exploit that here

174
00:07:54,330 --> 00:07:55,860
the attacker has his memory this might

175
00:07:55,860 --> 00:07:57,900
be a VM or a process and then there is

176
00:07:57,900 --> 00:08:01,020
the victim so there is a secret page

177
00:08:01,020 --> 00:08:03,599
that's basically knowing that that page

178
00:08:03,599 --> 00:08:06,270
exists might help the attacker in one or

179
00:08:06,270 --> 00:08:09,060
another way so what the attacker has to

180
00:08:09,060 --> 00:08:10,889
do is the attacker has to guess a page

181
00:08:10,889 --> 00:08:13,529
so in that case he really has to guess

182
00:08:13,529 --> 00:08:14,779
the content of that page

183
00:08:14,779 --> 00:08:17,400
the attacker has to wait a certain

184
00:08:17,400 --> 00:08:20,849
amount of time right to it so modify his

185
00:08:20,849 --> 00:08:23,219
copy of the page so this is totally

186
00:08:23,219 --> 00:08:24,990
legitimate we don't need more privileges

187
00:08:24,990 --> 00:08:27,960
right measure the time and then see if

188
00:08:27,960 --> 00:08:29,580
the right time is above a certain

189
00:08:29,580 --> 00:08:33,000
threshold the attacker can deduce that

190
00:08:33,000 --> 00:08:36,208
this that page existed in the other VM

191
00:08:36,208 --> 00:08:38,818
for example and if the right time is

192
00:08:38,818 --> 00:08:41,279
below a certain threshold the attacker

193
00:08:41,279 --> 00:08:44,750
may can then use that didn't exist there

194
00:08:44,750 --> 00:08:49,740
okay so let's look at the first attack

195
00:08:49,740 --> 00:08:52,949
okay so kane is cross vm address space

196
00:08:52,949 --> 00:08:54,990
layout introspection I actually regret

197
00:08:54,990 --> 00:08:57,870
already the long name every time have to

198
00:08:57,870 --> 00:09:01,639
say basically only relies on DW keishon

199
00:09:01,639 --> 00:09:05,190
the idea is to use that to break a SLR

200
00:09:05,190 --> 00:09:08,040
so basically you have a VM that runs

201
00:09:08,040 --> 00:09:09,810
next to you memory the application is

202
00:09:09,810 --> 00:09:12,240
enabled and you will be able to find out

203
00:09:12,240 --> 00:09:14,190
what the base address for example ntdll

204
00:09:14,190 --> 00:09:18,959
is in the other VM so let's recap what

205
00:09:18,959 --> 00:09:20,370
you have to do as an attacker so first

206
00:09:20,370 --> 00:09:22,560
you need a secret page that allows you

207
00:09:22,560 --> 00:09:24,630
to deduce interesting information and in

208
00:09:24,630 --> 00:09:27,149
our case it's the ASLR base address of a

209
00:09:27,149 --> 00:09:30,870
certain dll for example so the question

210
00:09:30,870 --> 00:09:34,410
here is what page should we use then of

211
00:09:34,410 --> 00:09:36,029
course there are certain practical

212
00:09:36,029 --> 00:09:37,949
challenges so how long should you

213
00:09:37,949 --> 00:09:39,380
actually wait

214
00:09:39,380 --> 00:09:41,720
for because you have no idea how fast a

215
00:09:41,720 --> 00:09:43,540
memory need application scheme is and

216
00:09:43,540 --> 00:09:46,399
then in the end you have to practically

217
00:09:46,399 --> 00:09:48,259
detect that it was merged so you can

218
00:09:48,259 --> 00:09:49,940
measure right time but you'll see that

219
00:09:49,940 --> 00:09:52,610
in practice there is also noise involved

220
00:09:52,610 --> 00:09:54,380
so sometimes the right time is higher

221
00:09:54,380 --> 00:09:56,060
and it's not because of memory need

222
00:09:56,060 --> 00:10:00,920
application so we looked at the suitable

223
00:10:00,920 --> 00:10:04,630
pages to break SLR and I mean certain

224
00:10:04,630 --> 00:10:06,649
straightforward critique of juniors are

225
00:10:06,649 --> 00:10:08,209
you have to know as an attacker that

226
00:10:08,209 --> 00:10:11,329
that page exists in a lot of VM it has

227
00:10:11,329 --> 00:10:12,920
to be read only ideally in the VM

228
00:10:12,920 --> 00:10:14,990
because if it changes too often then it

229
00:10:14,990 --> 00:10:18,079
will not be deduplicated and it has to

230
00:10:18,079 --> 00:10:19,670
be paid too large so you really need to

231
00:10:19,670 --> 00:10:23,180
know the content mostly of that page and

232
00:10:23,180 --> 00:10:25,339
then if you want to break a SLR you need

233
00:10:25,339 --> 00:10:27,860
ideally a page that has the base address

234
00:10:27,860 --> 00:10:30,649
in there so basically the green part is

235
00:10:30,649 --> 00:10:33,199
totally predictable for an attacker and

236
00:10:33,199 --> 00:10:35,120
the only thing that the attacker doesn't

237
00:10:35,120 --> 00:10:39,130
know is the base address or another

238
00:10:39,130 --> 00:10:41,029
possible page will be a page that

239
00:10:41,029 --> 00:10:43,399
actually has different values that were

240
00:10:43,399 --> 00:10:45,740
derived from a base of us from the

241
00:10:45,740 --> 00:10:48,829
secret that you're interested in and the

242
00:10:48,829 --> 00:10:50,449
other thing you have to know is also the

243
00:10:50,449 --> 00:10:54,339
offsets of these secrets within the page

244
00:10:54,339 --> 00:10:57,170
so we are looking for certain pages and

245
00:10:57,170 --> 00:10:59,029
we are sure there are much more but

246
00:10:59,029 --> 00:11:00,829
luckily when we were looking at the

247
00:11:00,829 --> 00:11:04,069
first page of every executable P image

248
00:11:04,069 --> 00:11:06,410
in memory you'll already have a have a

249
00:11:06,410 --> 00:11:09,410
hit so if you look at the P file format

250
00:11:09,410 --> 00:11:13,310
it looks like on the left for an image

251
00:11:13,310 --> 00:11:15,709
on disk so there is an image base field

252
00:11:15,709 --> 00:11:18,350
there which basically gets updated with

253
00:11:18,350 --> 00:11:21,050
the runtime base address in memory and

254
00:11:21,050 --> 00:11:22,910
this is exactly what we need we can

255
00:11:22,910 --> 00:11:25,819
predict into all other bytes except for

256
00:11:25,819 --> 00:11:28,130
the base address with has 19 bits of

257
00:11:28,130 --> 00:11:29,410
entropy

258
00:11:29,410 --> 00:11:31,839
now of course other pages that fulfill

259
00:11:31,839 --> 00:11:33,429
that criteria but which we thought I

260
00:11:33,429 --> 00:11:35,769
mean why why should we look further if

261
00:11:35,769 --> 00:11:38,889
you already have have one so we use that

262
00:11:38,889 --> 00:11:41,889
page in the pocket so now the problem is

263
00:11:41,889 --> 00:11:44,919
you have this page you can basically ask

264
00:11:44,919 --> 00:11:46,599
that memory need applications a channel

265
00:11:46,599 --> 00:11:48,909
if if that exists or not but the problem

266
00:11:48,909 --> 00:11:50,559
is you still have to guess the base

267
00:11:50,559 --> 00:11:53,909
address so you have 19 bits of entropy

268
00:11:53,909 --> 00:12:00,159
so 19 bits of entropy in x64 windows is

269
00:12:00,159 --> 00:12:03,039
used for the base address of dll for

270
00:12:03,039 --> 00:12:06,849
example so as you need one page per

271
00:12:06,849 --> 00:12:09,249
guess it's more than 500-thousand bait

272
00:12:09,249 --> 00:12:11,019
pages that you would need right so if

273
00:12:11,019 --> 00:12:12,309
you will do that after each other

274
00:12:12,309 --> 00:12:15,939
basically will take a lot of time but of

275
00:12:15,939 --> 00:12:18,279
course we can just brute force it right

276
00:12:18,279 --> 00:12:21,009
so we can use much more memory all the

277
00:12:21,009 --> 00:12:22,599
memory that the attacker actually has

278
00:12:22,599 --> 00:12:25,720
right so the attacker has much more

279
00:12:25,720 --> 00:12:27,399
memory you can assume that usually you

280
00:12:27,399 --> 00:12:30,249
have maybe you have a different DM - for

281
00:12:30,249 --> 00:12:33,819
even more gigabytes so you can just fill

282
00:12:33,819 --> 00:12:35,709
up the entire memory that is at our

283
00:12:35,709 --> 00:12:38,679
disposal with all the guesses and in

284
00:12:38,679 --> 00:12:40,720
case of nineteen bits of entropy and one

285
00:12:40,720 --> 00:12:43,419
page per guess it's two gigabytes which

286
00:12:43,419 --> 00:12:48,879
actually is okay so what you do is you

287
00:12:48,879 --> 00:12:51,309
have these pages and then you allocate

288
00:12:51,309 --> 00:12:54,069
them and then you try to detect it and

289
00:12:54,069 --> 00:12:56,919
it's a classical brute force attack on

290
00:12:56,919 --> 00:12:58,419
this that memory need application

291
00:12:58,419 --> 00:13:02,829
side-channel so the other challenge that

292
00:13:02,829 --> 00:13:04,600
we had the practical one is how long

293
00:13:04,600 --> 00:13:05,859
should we wait of course we could just

294
00:13:05,859 --> 00:13:07,749
wait like hours right and at some point

295
00:13:07,749 --> 00:13:11,350
would work but it depends so we wanted

296
00:13:11,350 --> 00:13:13,149
to be a bit better so Indiana depends on

297
00:13:13,149 --> 00:13:14,649
the memory de-allocation implementation

298
00:13:14,649 --> 00:13:17,529
so how fast is it so you've seen so the

299
00:13:17,529 --> 00:13:20,049
parameters for KSM so depending on the

300
00:13:20,049 --> 00:13:23,139
parameters it might be faster or slower

301
00:13:23,139 --> 00:13:26,229
but it also depends on the memory usage

302
00:13:26,229 --> 00:13:28,779
so if you have a lot of VMs running in

303
00:13:28,779 --> 00:13:30,699
the end you have to compare all the

304
00:13:30,699 --> 00:13:32,589
pages to each other so you have to go

305
00:13:32,589 --> 00:13:34,119
through all the pages and if you assume

306
00:13:34,119 --> 00:13:37,059
the worst case then your guest page will

307
00:13:37,059 --> 00:13:39,459
be compared with the secret page at the

308
00:13:39,459 --> 00:13:40,900
latest point in time

309
00:13:40,900 --> 00:13:43,400
so there is a trade-off for the attacker

310
00:13:43,400 --> 00:13:45,830
so if the attacker waits too little then

311
00:13:45,830 --> 00:13:47,780
the attack will just not work but if the

312
00:13:47,780 --> 00:13:48,140
attacker

313
00:13:48,140 --> 00:13:49,610
are weights too long then the attack

314
00:13:49,610 --> 00:13:51,350
time increases and that's also not

315
00:13:51,350 --> 00:13:54,200
favorable for for the attacker so what

316
00:13:54,200 --> 00:13:56,660
we came up with is a detection mechanism

317
00:13:56,660 --> 00:13:58,550
to detect this memory need application

318
00:13:58,550 --> 00:14:00,530
basically at the time you'll have to

319
00:14:00,530 --> 00:14:02,900
wait until you have certain guarantees

320
00:14:02,900 --> 00:14:04,700
that your page was compared with another

321
00:14:04,700 --> 00:14:07,040
one we call it sleep time detection and

322
00:14:07,040 --> 00:14:10,610
the idea is as an attacker you can just

323
00:14:10,610 --> 00:14:13,100
allocate a lot of random bytes and a lot

324
00:14:13,100 --> 00:14:15,110
of pages and then you copy every second

325
00:14:15,110 --> 00:14:18,350
page of the half of your buffer to the

326
00:14:18,350 --> 00:14:20,030
other half of the buffer so what you

327
00:14:20,030 --> 00:14:21,920
create is basically the situation like

328
00:14:21,920 --> 00:14:23,870
on the slide where you have a lot of

329
00:14:23,870 --> 00:14:26,450
merging opportunities so you basically

330
00:14:26,450 --> 00:14:28,670
give the memory in application scheme a

331
00:14:28,670 --> 00:14:31,610
lot of work you create a lot of pages

332
00:14:31,610 --> 00:14:34,430
that can be DW gated and then you wait a

333
00:14:34,430 --> 00:14:36,580
certain amount of time like ten minutes

334
00:14:36,580 --> 00:14:38,900
try to detect how many of these pages

335
00:14:38,900 --> 00:14:40,760
were merged by doing your detection

336
00:14:40,760 --> 00:14:43,430
magic and then if the threshold is about

337
00:14:43,430 --> 00:14:45,020
and detection is above a certain

338
00:14:45,020 --> 00:14:46,760
threshold you say that's the right time

339
00:14:46,760 --> 00:14:49,850
so you use it in your attacks and if not

340
00:14:49,850 --> 00:14:51,440
you just increase T and then you try

341
00:14:51,440 --> 00:14:56,390
again so last practical challenge is how

342
00:14:56,390 --> 00:14:57,920
do you actually detect that the page was

343
00:14:57,920 --> 00:15:00,020
merged and what you have to do is I mean

344
00:15:00,020 --> 00:15:01,460
you have to write to it and you have to

345
00:15:01,460 --> 00:15:04,490
measure the right time right so what we

346
00:15:04,490 --> 00:15:06,200
did is we every time you have a guest

347
00:15:06,200 --> 00:15:07,940
page so that's the orange one they

348
00:15:07,940 --> 00:15:11,300
merged one we have pages adjacent pages

349
00:15:11,300 --> 00:15:14,120
that are for sure not merge and we know

350
00:15:14,120 --> 00:15:15,710
that because we can just fill it up with

351
00:15:15,710 --> 00:15:19,460
random bytes okay so you create the

352
00:15:19,460 --> 00:15:21,830
buffering in in such a way and then you

353
00:15:21,830 --> 00:15:23,480
just write to it and you measure the

354
00:15:23,480 --> 00:15:26,840
cycles and then you basically see this

355
00:15:26,840 --> 00:15:29,210
signal now of course there might be

356
00:15:29,210 --> 00:15:31,040
noise so we developed certain heuristics

357
00:15:31,040 --> 00:15:33,140
we didn't invest that much time to do

358
00:15:33,140 --> 00:15:34,670
that but the ones you see there work

359
00:15:34,670 --> 00:15:37,670
pretty well and that was fine for us

360
00:15:37,670 --> 00:15:45,200
works for me now the last question is

361
00:15:45,200 --> 00:15:48,950
how to handle noise right so we just

362
00:15:48,950 --> 00:15:50,450
implemented it in a quite conservative

363
00:15:50,450 --> 00:15:53,020
way because there is actually no harm if

364
00:15:53,020 --> 00:15:56,500
if you have certain pages that of

365
00:15:56,500 --> 00:15:58,810
certain false positives so what we did

366
00:15:58,810 --> 00:16:00,550
is we implemented rounds based system

367
00:16:00,550 --> 00:16:03,640
where you try to detect it then you do

368
00:16:03,640 --> 00:16:05,170
it again with the guesses that might be

369
00:16:05,170 --> 00:16:09,190
potentially correct and you do it over

370
00:16:09,190 --> 00:16:12,220
and over again and in the end as the

371
00:16:12,220 --> 00:16:15,610
noise will not affect the same guess all

372
00:16:15,610 --> 00:16:16,450
the time

373
00:16:16,450 --> 00:16:19,150
it will work but it might take certain

374
00:16:19,150 --> 00:16:23,830
runs so I'll show you some results for a

375
00:16:23,830 --> 00:16:26,500
Windows attack so we implemented it to

376
00:16:26,500 --> 00:16:29,110
attack which is basically liek the anti

377
00:16:29,110 --> 00:16:31,150
DLL base address of a neighboring

378
00:16:31,150 --> 00:16:34,120
windows 64-bit system so if you look at

379
00:16:34,120 --> 00:16:35,590
the entropy you see basically for data

380
00:16:35,590 --> 00:16:37,420
it's quite high so that approach

381
00:16:37,420 --> 00:16:40,470
wouldn't work that easily

382
00:16:40,470 --> 00:16:42,910
at least not if you have no control over

383
00:16:42,910 --> 00:16:46,420
how this the secret is is aligned so

384
00:16:46,420 --> 00:16:48,400
basically for GLS we have 19 bits of

385
00:16:48,400 --> 00:16:50,080
entropy and if you have the base address

386
00:16:50,080 --> 00:16:52,480
of one entity ll you basically can use

387
00:16:52,480 --> 00:16:53,980
it in your exploits for all the other

388
00:16:53,980 --> 00:16:56,430
processes because it's usually not we

389
00:16:56,430 --> 00:17:00,820
reran demised so we did it with a

390
00:17:00,820 --> 00:17:03,730
standard KBM KSM configuration with

391
00:17:03,730 --> 00:17:05,740
sleeps milli six to honor that's default

392
00:17:05,740 --> 00:17:08,079
and basically you see when we attack one

393
00:17:08,079 --> 00:17:10,209
single VM it took us a bit less than

394
00:17:10,209 --> 00:17:13,089
five hours to basically do that and we

395
00:17:13,089 --> 00:17:16,270
had like some rounds till we reduce the

396
00:17:16,270 --> 00:17:18,700
entropy from 19 bits to to the actual

397
00:17:18,700 --> 00:17:21,849
base address and we also wanted to show

398
00:17:21,849 --> 00:17:24,040
that it works with multiple VM so we

399
00:17:24,040 --> 00:17:25,690
speeded up the memory application by

400
00:17:25,690 --> 00:17:28,600
having sleep milli 620 and there you see

401
00:17:28,600 --> 00:17:30,610
even if you have more victim VMs it

402
00:17:30,610 --> 00:17:32,440
works it just takes more time because

403
00:17:32,440 --> 00:17:34,900
the sleep time detection will tell you

404
00:17:34,900 --> 00:17:36,730
to wait more because you have more

405
00:17:36,730 --> 00:17:41,950
memory that is used so in the end how it

406
00:17:41,950 --> 00:17:43,720
looks like so we have a video demo but

407
00:17:43,720 --> 00:17:44,950
we don't have that much time so just

408
00:17:44,950 --> 00:17:46,420
show you the screenshot we have a demo

409
00:17:46,420 --> 00:17:48,720
for a lip for another attack later

410
00:17:48,720 --> 00:17:52,090
basically here you have the attacker VM

411
00:17:52,090 --> 00:17:54,910
and on the right you have the victim VM

412
00:17:54,910 --> 00:17:58,690
and you do your magic you allocate these

413
00:17:58,690 --> 00:18:01,030
pages measure write times and so on and

414
00:18:01,030 --> 00:18:03,220
in the end and you just have the base

415
00:18:03,220 --> 00:18:05,650
address of T of the anti DLL in the

416
00:18:05,650 --> 00:18:06,490
other VM

417
00:18:06,490 --> 00:18:11,470
that's it so the attack is rather slow I

418
00:18:11,470 --> 00:18:13,120
would say but there were a lot of speed

419
00:18:13,120 --> 00:18:14,679
improvements that we didn't actually

420
00:18:14,679 --> 00:18:17,320
follow up with but one way would be to

421
00:18:17,320 --> 00:18:19,870
have more random pages in between so

422
00:18:19,870 --> 00:18:21,760
that the noise will not affect your

423
00:18:21,760 --> 00:18:24,400
guests or the probability is lower that

424
00:18:24,400 --> 00:18:27,100
happens and the other thing is you can

425
00:18:27,100 --> 00:18:29,170
also use more than one guest page right

426
00:18:29,170 --> 00:18:32,050
so have redundancy already because you

427
00:18:32,050 --> 00:18:33,580
might have for example code we located

428
00:18:33,580 --> 00:18:35,590
code pages that all have that secret so

429
00:18:35,590 --> 00:18:37,960
you can just use many of them right the

430
00:18:37,960 --> 00:18:39,400
only thing is you cannot use the same

431
00:18:39,400 --> 00:18:41,590
page because if you have it two times

432
00:18:41,590 --> 00:18:44,290
with the same guess then you create this

433
00:18:44,290 --> 00:18:45,880
merging opportunity and you have a false

434
00:18:45,880 --> 00:18:47,710
positive so we need different pages that

435
00:18:47,710 --> 00:18:51,070
all have the same uncertainty or the

436
00:18:51,070 --> 00:18:55,990
same secret now okay I will say cool

437
00:18:55,990 --> 00:18:57,850
attack but the problem is it's still

438
00:18:57,850 --> 00:19:00,790
quite limited so one problem is we don't

439
00:19:00,790 --> 00:19:02,650
have any control over the victim memory

440
00:19:02,650 --> 00:19:05,410
right so we really have to rely on how

441
00:19:05,410 --> 00:19:07,929
these pages are what the layout of these

442
00:19:07,929 --> 00:19:10,960
pages are and also hardware the secret

443
00:19:10,960 --> 00:19:13,600
actually is we need to find these pages

444
00:19:13,600 --> 00:19:15,790
so there is no control but some control

445
00:19:15,790 --> 00:19:18,010
would actually help a lot we didn't

446
00:19:18,010 --> 00:19:19,360
really investigate that how we can do

447
00:19:19,360 --> 00:19:22,600
that cross VM and then of course it's a

448
00:19:22,600 --> 00:19:23,980
leak right so you still need a

449
00:19:23,980 --> 00:19:27,070
vulnerability to exploit the base

450
00:19:27,070 --> 00:19:28,840
address for example they secretly forgot

451
00:19:28,840 --> 00:19:32,679
that's not enough but last year I mean

452
00:19:32,679 --> 00:19:35,710
it was a lot of were a lot of talks and

453
00:19:35,710 --> 00:19:37,420
a lot of publications about brohamer

454
00:19:37,420 --> 00:19:40,720
even here at the Congress Clementine and

455
00:19:40,720 --> 00:19:43,630
Daniel presented go hammer a Jas so

456
00:19:43,630 --> 00:19:44,530
basically they show that it's possible

457
00:19:44,530 --> 00:19:49,780
in JavaScript so let's say we are we

458
00:19:49,780 --> 00:19:51,850
were optimistic that we could do more

459
00:19:51,850 --> 00:19:55,179
and then Microsoft basically enabled an

460
00:19:55,179 --> 00:19:57,700
immediate application we noticed for

461
00:19:57,700 --> 00:20:02,110
Windows 8.1 and 10 cross process but is

462
00:20:02,110 --> 00:20:04,179
it's disabled again so it's not enabled

463
00:20:04,179 --> 00:20:04,870
anymore

464
00:20:04,870 --> 00:20:07,570
but let's say would have been cool but

465
00:20:07,570 --> 00:20:09,000
it didn't go that well

466
00:20:09,000 --> 00:20:12,130
[Music]

467
00:20:15,320 --> 00:20:22,419
[Applause]

468
00:20:22,419 --> 00:20:25,610
so for the next attack we call deadest

469
00:20:25,610 --> 00:20:30,008
machina we try to take it a step further

470
00:20:30,039 --> 00:20:34,629
so in this attack we're going to combine

471
00:20:34,629 --> 00:20:37,039
deduplication as a side channel attack

472
00:20:37,039 --> 00:20:40,899
with row hammer in order to exploit

473
00:20:40,899 --> 00:20:45,259
Microsoft edge my new browser from

474
00:20:45,259 --> 00:20:47,659
JavaScript without making use of any

475
00:20:47,659 --> 00:20:52,220
software books or well if you consider

476
00:20:52,220 --> 00:20:54,470
if you don't consider the duplication in

477
00:20:54,470 --> 00:20:59,899
software book so we're going to leak to

478
00:20:59,899 --> 00:21:03,320
secrets and we're going to the use

479
00:21:03,320 --> 00:21:06,019
deduplication to do this the first

480
00:21:06,019 --> 00:21:10,519
secret is a heap a hip pointer it's a

481
00:21:10,519 --> 00:21:13,669
location to data we control and the

482
00:21:13,669 --> 00:21:15,950
second secret is a code pointer and

483
00:21:15,950 --> 00:21:19,580
that's yeah needed and those two secrets

484
00:21:19,580 --> 00:21:23,840
are needed the two together create a

485
00:21:23,840 --> 00:21:28,700
fake object in our memory but then we

486
00:21:28,700 --> 00:21:30,799
have a problem because and this fake

487
00:21:30,799 --> 00:21:32,539
object will allow us to do arbitrary

488
00:21:32,539 --> 00:21:35,029
reads and arbitrary writes in memory but

489
00:21:35,029 --> 00:21:35,720
we have a problem

490
00:21:35,720 --> 00:21:37,580
javascript of course doesn't allow us to

491
00:21:37,580 --> 00:21:40,460
create references to this fake object

492
00:21:40,460 --> 00:21:43,100
it's just in data so we will use row

493
00:21:43,100 --> 00:21:45,590
hammer to flip a bit in a pointer and

494
00:21:45,590 --> 00:21:50,419
point this pointer to perfect object and

495
00:21:50,419 --> 00:21:52,370
then we are basically we can take over

496
00:21:52,370 --> 00:21:56,720
the process so in this in contrast to

497
00:21:56,720 --> 00:21:59,960
cane in this attack we won't only be

498
00:21:59,960 --> 00:22:02,690
using be probing for existing pages in

499
00:22:02,690 --> 00:22:06,309
memory we will assume that we can

500
00:22:06,309 --> 00:22:13,220
manipulate the data of the the victim in

501
00:22:13,220 --> 00:22:16,820
some way and this is not really unlikely

502
00:22:16,820 --> 00:22:18,679
if you think about it every time you do

503
00:22:18,679 --> 00:22:22,190
I owe to something you want to attack

504
00:22:22,190 --> 00:22:25,279
then your manipulate manipulating memory

505
00:22:25,279 --> 00:22:28,549
in this process and in this case is from

506
00:22:28,549 --> 00:22:33,159
JavaScript so it's even more easy

507
00:22:33,159 --> 00:22:36,190
and this allows us to not only probe for

508
00:22:36,190 --> 00:22:37,480
secrets that just happened to be in

509
00:22:37,480 --> 00:22:41,559
pages that we can leak but we can craft

510
00:22:41,559 --> 00:22:43,929
memory pages that just contain the

511
00:22:43,929 --> 00:22:46,419
secrets that we want to lick so it's

512
00:22:46,419 --> 00:22:50,110
quite a bit more powerful but still

513
00:22:50,110 --> 00:22:53,470
there are some problems with this the

514
00:22:53,470 --> 00:22:56,909
secret that we want to link might not be

515
00:22:56,909 --> 00:23:00,700
somewhere the secret we want to lick was

516
00:23:00,700 --> 00:23:03,639
is probably somewhere in the page which

517
00:23:03,639 --> 00:23:05,499
contains other information that we don't

518
00:23:05,499 --> 00:23:07,990
know and then we cannot craft a page to

519
00:23:07,990 --> 00:23:10,419
lick the secret so we need to find a way

520
00:23:10,419 --> 00:23:13,869
to kind of encode the secret into a

521
00:23:13,869 --> 00:23:19,840
memory page so that we can retrieve the

522
00:23:19,840 --> 00:23:23,679
secret again so so the secrets the

523
00:23:23,679 --> 00:23:25,600
memory pages we want to leak should

524
00:23:25,600 --> 00:23:28,990
contain only the secret and data known

525
00:23:28,990 --> 00:23:34,779
to us so this could be that because this

526
00:23:34,779 --> 00:23:38,049
data was written by us into the outer

527
00:23:38,049 --> 00:23:40,779
space of the victim or it's just data

528
00:23:40,779 --> 00:23:47,169
that we know yeah data that we know the

529
00:23:47,169 --> 00:23:50,919
contents of in some way and there's a

530
00:23:50,919 --> 00:23:53,499
second problem we might want to leak a

531
00:23:53,499 --> 00:23:56,470
secret which has too much entropy so

532
00:23:56,470 --> 00:23:58,860
much entropy that we cannot possibly

533
00:23:58,860 --> 00:24:02,049
brute-force the hole all the possible

534
00:24:02,049 --> 00:24:06,610
secrets for this we have found some ways

535
00:24:06,610 --> 00:24:09,820
to get around this and leak secrets

536
00:24:09,820 --> 00:24:16,869
iteratively the first method we we tried

537
00:24:16,869 --> 00:24:20,759
was a we call alignment probing in this

538
00:24:20,759 --> 00:24:26,379
this case we manipulate the victim into

539
00:24:26,379 --> 00:24:29,409
creating a memory page or putting the

540
00:24:29,409 --> 00:24:32,169
secret somewhere across memory page

541
00:24:32,169 --> 00:24:36,999
boundaries in this way we can in this

542
00:24:36,999 --> 00:24:40,929
way we can only we can partially leak

543
00:24:40,929 --> 00:24:45,240
the secret in one in one

544
00:24:45,240 --> 00:24:49,700
round and then when we you know and then

545
00:24:49,700 --> 00:24:53,519
the we have to get the victim to create

546
00:24:53,519 --> 00:24:55,830
a memory page with the secrets slide

547
00:24:55,830 --> 00:24:58,110
slightly more of the secret in one page

548
00:24:58,110 --> 00:25:01,980
and so on and so on and we'll we leak

549
00:25:01,980 --> 00:25:06,320
the whole secret the second primitive we

550
00:25:06,320 --> 00:25:10,649
tried was we call partial reuse where we

551
00:25:10,649 --> 00:25:14,370
assume that the yeah the victim has a

552
00:25:14,370 --> 00:25:18,019
secret somewhere and then we write data

553
00:25:18,019 --> 00:25:21,539
for example in a buffer that was

554
00:25:21,539 --> 00:25:23,610
previously used to store the secret and

555
00:25:23,610 --> 00:25:26,539
then we write data into in this buffer

556
00:25:26,539 --> 00:25:29,519
and overwrite only part of the secret

557
00:25:29,519 --> 00:25:33,690
and then again the entropy again such as

558
00:25:33,690 --> 00:25:40,230
entropy is slow enough to to leak it and

559
00:25:40,230 --> 00:25:43,710
the first of these two primitive the

560
00:25:43,710 --> 00:25:46,919
alignment probing is what we're going to

561
00:25:46,919 --> 00:25:49,379
use to leak the code address in this

562
00:25:49,379 --> 00:25:54,529
case and we're going to make use of

563
00:25:54,529 --> 00:25:59,249
edges JIT compiler so every modern

564
00:25:59,249 --> 00:26:01,470
browser has a JIT compiler compiling

565
00:26:01,470 --> 00:26:07,049
JavaScript to native code and for every

566
00:26:07,049 --> 00:26:10,460
chunk that's translated in Marcos edge

567
00:26:10,460 --> 00:26:13,710
the the function epilogue that the last

568
00:26:13,710 --> 00:26:15,570
part of the translated code is always

569
00:26:15,570 --> 00:26:18,299
looks the same except for one thing

570
00:26:18,299 --> 00:26:23,519
namely a code address so and what we did

571
00:26:23,519 --> 00:26:26,490
was create lots of JavaScript functions

572
00:26:26,490 --> 00:26:32,159
which are just just too big to fit into

573
00:26:32,159 --> 00:26:34,740
one memory page such that the code

574
00:26:34,740 --> 00:26:40,460
address spans multiple pages and then

575
00:26:40,460 --> 00:26:42,690
what all normally the code rather the

576
00:26:42,690 --> 00:26:45,450
rest is 19 bit so it wouldn't would need

577
00:26:45,450 --> 00:26:47,669
to eat a bunch of memory in this case we

578
00:26:47,669 --> 00:26:52,100
need only 16 I believe

579
00:26:54,700 --> 00:26:58,840
and yeah so so sorry

580
00:26:58,840 --> 00:27:01,000
in this way we can in one sweep we can

581
00:27:01,000 --> 00:27:04,030
lick lick part of the address and then

582
00:27:04,030 --> 00:27:05,740
the second sweep we can lick the

583
00:27:05,740 --> 00:27:12,130
complete failure so now we have a code

584
00:27:12,130 --> 00:27:16,420
pointer but we still need to lick a hip

585
00:27:16,420 --> 00:27:18,120
pointer and there's a problem with this

586
00:27:18,120 --> 00:27:21,430
we didn't find a situation where we

587
00:27:21,430 --> 00:27:23,260
could lick the hip pointer directly

588
00:27:23,260 --> 00:27:27,010
using the two primitives before and the

589
00:27:27,010 --> 00:27:29,440
hip pointer has quite a lot of entropy

590
00:27:29,440 --> 00:27:32,440
so this is an example of a hip pointer

591
00:27:32,440 --> 00:27:36,400
in mirga's edge there are some

592
00:27:36,400 --> 00:27:40,240
advertised randomness on Windows 10 24

593
00:27:40,240 --> 00:27:42,460
bits of randomness and if we only look

594
00:27:42,460 --> 00:27:43,810
at that part

595
00:27:43,810 --> 00:27:47,740
we'd need 64 gigabytes of memory just to

596
00:27:47,740 --> 00:27:50,860
try every one every every possibility

597
00:27:50,860 --> 00:27:53,700
and then we need to multiply this by a

598
00:27:53,700 --> 00:27:57,160
bit to get redundancy because there's

599
00:27:57,160 --> 00:28:03,280
noise but if we look at our point

600
00:28:03,280 --> 00:28:05,170
actually looks like there's also some

601
00:28:05,170 --> 00:28:08,320
kind of lots of non-determinism which

602
00:28:08,320 --> 00:28:12,460
actually increases the entropy of the

603
00:28:12,460 --> 00:28:14,920
pointer and quite a bit and yeah we

604
00:28:14,920 --> 00:28:16,330
don't have hundreds of terabytes of

605
00:28:16,330 --> 00:28:20,500
memory to probe so we needed to find

606
00:28:20,500 --> 00:28:23,590
something else we could improve this a

607
00:28:23,590 --> 00:28:26,860
bit that we found another side channel

608
00:28:26,860 --> 00:28:30,100
so if you allocate lots of arrays then

609
00:28:30,100 --> 00:28:34,270
every one megabyte the browser will ask

610
00:28:34,270 --> 00:28:36,340
the operating system for an extra

611
00:28:36,340 --> 00:28:39,570
megabyte of memory and then the first

612
00:28:39,570 --> 00:28:43,740
object that's fit into the new allocated

613
00:28:43,740 --> 00:28:47,860
one megabyte it will take longer to

614
00:28:47,860 --> 00:28:50,140
allocate and that's something you can

615
00:28:50,140 --> 00:28:54,550
detect so then we have a timing side

616
00:28:54,550 --> 00:28:56,980
channel and then we can reduce the

617
00:28:56,980 --> 00:29:01,180
entropy to 20 bits but with only already

618
00:29:01,180 --> 00:29:03,970
you know needs this 4 gigabytes of

619
00:29:03,970 --> 00:29:06,540
memory so that's also not

620
00:29:06,540 --> 00:29:11,710
nearly good enough so we had to find

621
00:29:11,710 --> 00:29:13,780
something else well luckily we found

622
00:29:13,780 --> 00:29:17,590
something else something very much like

623
00:29:17,590 --> 00:29:22,360
yeah yeah the intuition is very much

624
00:29:22,360 --> 00:29:26,729
like that of the birthday problem which

625
00:29:27,090 --> 00:29:32,860
in which you in a very in a surprisingly

626
00:29:32,860 --> 00:29:37,330
small group of people the chances of two

627
00:29:37,330 --> 00:29:39,550
people sharing the same birthday is

628
00:29:39,550 --> 00:29:44,380
actually becomes pretty high more that

629
00:29:44,380 --> 00:29:47,830
more than you would naively think faster

630
00:29:47,830 --> 00:29:50,950
than you would think not naively and the

631
00:29:50,950 --> 00:29:52,870
intuition behind this is that you're not

632
00:29:52,870 --> 00:29:55,150
comparing one person's birthday with a

633
00:29:55,150 --> 00:29:57,760
group of other people with other people

634
00:29:57,760 --> 00:29:59,830
you're actually comparing everybody's

635
00:29:59,830 --> 00:30:01,870
birthday with everybody else's birthday

636
00:30:01,870 --> 00:30:05,380
and when you think about it this is

637
00:30:05,380 --> 00:30:07,720
exactly what memory did the memory lead

638
00:30:07,720 --> 00:30:10,360
application routine does as well it

639
00:30:10,360 --> 00:30:11,890
compares every page with every other

640
00:30:11,890 --> 00:30:15,850
page so how can we exploit this in

641
00:30:15,850 --> 00:30:17,650
practice well we're going to assume that

642
00:30:17,650 --> 00:30:21,330
we don't have one secret to leak but

643
00:30:21,330 --> 00:30:23,950
lots of Secrets and then we have lots of

644
00:30:23,950 --> 00:30:27,190
guesses and then there's a yeah you

645
00:30:27,190 --> 00:30:28,750
can't compare every guess with every

646
00:30:28,750 --> 00:30:32,560
secret and then you get yeah we you need

647
00:30:32,560 --> 00:30:38,380
way less memory so so in practice

648
00:30:38,380 --> 00:30:43,240
victimís secrets and then you kind of

649
00:30:43,240 --> 00:30:45,130
need this you don't need as many

650
00:30:45,130 --> 00:30:48,550
different gasses to actually get the

651
00:30:48,550 --> 00:30:53,260
match so how do we exploit this in

652
00:30:53,260 --> 00:30:56,260
practice well we have the this we

653
00:30:56,260 --> 00:30:57,940
allocate lots of objects and then we get

654
00:30:57,940 --> 00:31:02,190
a do to the other side channel we get a

655
00:31:02,190 --> 00:31:05,170
list of objects which have are probably

656
00:31:05,170 --> 00:31:09,060
on one on a megabyte boundary and then

657
00:31:09,060 --> 00:31:12,670
we allocate the large array which of

658
00:31:12,670 --> 00:31:15,280
course is in practice just memory pages

659
00:31:15,280 --> 00:31:18,030
and then we put a reference to or a

660
00:31:18,030 --> 00:31:19,779
pointer to each

661
00:31:19,779 --> 00:31:22,830
objects in this array so and then

662
00:31:22,830 --> 00:31:27,159
there's one pointer per memory page so

663
00:31:27,159 --> 00:31:29,859
these very pages kind of encodes the

664
00:31:29,859 --> 00:31:33,299
addresses of the of the objects and

665
00:31:33,299 --> 00:31:36,849
those pages are we're going to probe for

666
00:31:36,849 --> 00:31:40,539
and then on the other end we're using a

667
00:31:40,539 --> 00:31:41,859
typed array which allows us to

668
00:31:41,859 --> 00:31:44,559
completely control the binary contents

669
00:31:44,559 --> 00:31:50,249
of memory and then we're going to create

670
00:31:50,249 --> 00:31:55,479
references to objects which are 128

671
00:31:55,479 --> 00:31:58,929
megabytes apart and then recreate the

672
00:31:58,929 --> 00:32:07,599
contents of the of the pages that the

673
00:32:07,599 --> 00:32:10,119
contents of the how they would look like

674
00:32:10,119 --> 00:32:15,489
if they were in the array so so you can

675
00:32:15,489 --> 00:32:17,799
see that the secret pages are close

676
00:32:17,799 --> 00:32:21,339
together and one megabyte apart and then

677
00:32:21,339 --> 00:32:24,909
the pro pages range range across entire

678
00:32:24,909 --> 00:32:27,269
address with a possible address space

679
00:32:27,269 --> 00:32:31,330
that that h might possibly use and then

680
00:32:31,330 --> 00:32:32,979
in the middle there's a hit and then we

681
00:32:32,979 --> 00:32:39,489
get our hip address don't want to belong

682
00:32:39,489 --> 00:32:42,369
right to an object where we control the

683
00:32:42,369 --> 00:32:47,830
data so now we have the old information

684
00:32:47,830 --> 00:32:50,830
to create effect object now we're going

685
00:32:50,830 --> 00:32:53,349
to use row hammer to create a reference

686
00:32:53,349 --> 00:32:57,999
to this object to allow us to use it so

687
00:32:57,999 --> 00:33:01,149
the objects is a typed array the fake

688
00:33:01,149 --> 00:33:03,129
object that we make which allows us to

689
00:33:03,129 --> 00:33:06,460
basically control yeah read and writes

690
00:33:06,460 --> 00:33:11,889
the entire address space so this typed

691
00:33:11,889 --> 00:33:15,009
array this this type array objects this

692
00:33:15,009 --> 00:33:18,849
fake object we recreate in a JavaScript

693
00:33:18,849 --> 00:33:22,409
array that we know the address off and

694
00:33:22,409 --> 00:33:28,059
then the next javascript array as

695
00:33:28,059 --> 00:33:31,629
appointed to it and then we recreate

696
00:33:31,629 --> 00:33:33,230
this in such a way that if we flip

697
00:33:33,230 --> 00:33:36,470
bit the pointer will point to our

698
00:33:36,470 --> 00:33:40,580
objective instead of the array and for

699
00:33:40,580 --> 00:33:43,460
this we're going to use the row hammer

700
00:33:43,460 --> 00:33:50,530
attack yes like Antonio said last year

701
00:33:50,530 --> 00:33:53,360
some of you might seen the raw images

702
00:33:53,360 --> 00:33:59,690
talk we were able to reproduce their

703
00:33:59,690 --> 00:34:06,290
findings and on Windows 10 and use it to

704
00:34:06,290 --> 00:34:11,780
yep for it attack in the roma attack the

705
00:34:11,780 --> 00:34:16,280
problem is that ddr memory uses

706
00:34:16,280 --> 00:34:19,790
capacitor capacitors to store memory

707
00:34:19,790 --> 00:34:23,179
store data and when you have to when you

708
00:34:23,179 --> 00:34:26,440
read it the capacitors are drained so

709
00:34:26,440 --> 00:34:29,090
yeah these capacitors are stored in rows

710
00:34:29,090 --> 00:34:31,460
and then because they are drained

711
00:34:31,460 --> 00:34:33,770
there has to be some kind of cache which

712
00:34:33,770 --> 00:34:37,550
doesn't lose its value which is a static

713
00:34:37,550 --> 00:34:42,350
Ram buffer but it's only a limited

714
00:34:42,350 --> 00:34:45,139
amount of memory so when the memory

715
00:34:45,139 --> 00:34:46,550
controller which needs to read a

716
00:34:46,550 --> 00:34:49,070
different row the data has to be written

717
00:34:49,070 --> 00:34:51,710
back to these capacitors and the

718
00:34:51,710 --> 00:34:56,600
different row is read to the buffer

719
00:34:56,600 --> 00:35:00,770
cache the problem is that this read some

720
00:35:00,770 --> 00:35:03,109
interference and if you do this in quick

721
00:35:03,109 --> 00:35:09,670
succession at at specific locations then

722
00:35:09,670 --> 00:35:16,190
and then after a while some bits may

723
00:35:16,190 --> 00:35:20,570
flip in neighboring rows and that's what

724
00:35:20,570 --> 00:35:24,230
we use to flip a bit in the pointer

725
00:35:24,230 --> 00:35:27,530
allowing us to get a reference to this

726
00:35:27,530 --> 00:35:30,680
object and basically taking control of

727
00:35:30,680 --> 00:35:35,930
over the process so that's the second

728
00:35:35,930 --> 00:35:40,820
attack in the third attack where we call

729
00:35:40,820 --> 00:35:43,190
which we call flip phone tray we

730
00:35:43,190 --> 00:35:45,740
actually are also using roarhammer

731
00:35:45,740 --> 00:35:46,630
incoming

732
00:35:46,630 --> 00:35:49,330
with deduplication but in a different

733
00:35:49,330 --> 00:35:51,940
way we won't be using the duplication as

734
00:35:51,940 --> 00:35:54,880
a software side channel anymore

735
00:35:54,880 --> 00:35:58,390
but we will be using it to make ro

736
00:35:58,390 --> 00:36:02,980
hammer more a more useful exploitation

737
00:36:02,980 --> 00:36:10,060
primitive and and our target will be one

738
00:36:10,060 --> 00:36:14,200
yes um on our in our attack an attacker

739
00:36:14,200 --> 00:36:17,080
will be in control of one virtual

740
00:36:17,080 --> 00:36:20,920
machine and will take off or another

741
00:36:20,920 --> 00:36:25,180
virtual machine on the same system so

742
00:36:25,180 --> 00:36:30,130
like I said the row hammer is a yeah

743
00:36:30,130 --> 00:36:34,300
Romo is a very powerful attack but it's

744
00:36:34,300 --> 00:36:36,520
it's also quite difficult to exploit

745
00:36:36,520 --> 00:36:39,520
because you can crop bits but it's not

746
00:36:39,520 --> 00:36:42,010
really you don't really control which

747
00:36:42,010 --> 00:36:44,740
physical bits in memory are vulnerable

748
00:36:44,740 --> 00:36:49,360
to it and if you can't flip bits yeah

749
00:36:49,360 --> 00:36:54,940
you have to did the data that's the data

750
00:36:54,940 --> 00:36:58,270
that's being corrupted has to be useful

751
00:36:58,270 --> 00:37:01,750
to you so yeah yeah you you kind of have

752
00:37:01,750 --> 00:37:04,480
a problem of getting the right data into

753
00:37:04,480 --> 00:37:08,520
the right location for you to exploit so

754
00:37:08,520 --> 00:37:10,720
it's unpredictable

755
00:37:10,720 --> 00:37:14,710
you in which physical page the flip will

756
00:37:14,710 --> 00:37:17,200
happen and it's impre dick table in

757
00:37:17,200 --> 00:37:21,760
which location in this page it might

758
00:37:21,760 --> 00:37:26,320
happen a flip phone Shui can solve the

759
00:37:26,320 --> 00:37:30,820
first part for you so given that you can

760
00:37:30,820 --> 00:37:33,460
flip a bit in some page on the same in

761
00:37:33,460 --> 00:37:36,460
some location in the page a flip phone

762
00:37:36,460 --> 00:37:41,230
Shui will give you the ability to get an

763
00:37:41,230 --> 00:37:45,460
RB page you know the victim has and put

764
00:37:45,460 --> 00:37:47,260
it in the location where you can flip

765
00:37:47,260 --> 00:37:50,020
the bit another thing to mention is that

766
00:37:50,020 --> 00:37:50,950
with roarhammer

767
00:37:50,950 --> 00:37:53,800
if you discover you can flip a bit

768
00:37:53,800 --> 00:37:56,620
somewhere it's very likely you can flip

769
00:37:56,620 --> 00:37:58,210
it again and again and again and again

770
00:37:58,210 --> 00:38:00,630
so

771
00:38:01,290 --> 00:38:07,780
yeah so we're going to look for pages

772
00:38:07,780 --> 00:38:09,910
that we want to in the victim that we

773
00:38:09,910 --> 00:38:12,760
want to flip and then make sure that

774
00:38:12,760 --> 00:38:16,780
these pages are put into a location

775
00:38:16,780 --> 00:38:19,660
where we can flip these bits so we

776
00:38:19,660 --> 00:38:22,120
thought the memory the depression is a

777
00:38:22,120 --> 00:38:27,100
kind of a an attractive way of doing

778
00:38:27,100 --> 00:38:31,960
this we thought and we're working on the

779
00:38:31,960 --> 00:38:34,810
Windows 10 attack and we thought well

780
00:38:34,810 --> 00:38:37,930
what if we yeah so if we do row hammer

781
00:38:37,930 --> 00:38:42,400
find the bit flip what if if we find a

782
00:38:42,400 --> 00:38:45,640
page that we want to flip a bit we just

783
00:38:45,640 --> 00:38:48,130
replicate the same contents of this page

784
00:38:48,130 --> 00:38:52,390
and then wait for Windows to merge them

785
00:38:52,390 --> 00:38:55,240
and then hope our our locate our page

786
00:38:55,240 --> 00:38:59,230
would be the location it would merge to

787
00:38:59,230 --> 00:39:02,110
but sadly enough on Windows Windows

788
00:39:02,110 --> 00:39:04,360
allocates a new page and come and points

789
00:39:04,360 --> 00:39:08,820
the the allocations to the new location

790
00:39:08,820 --> 00:39:12,970
however we found that on linux with

791
00:39:12,970 --> 00:39:16,300
great kernel say that merging it didn't

792
00:39:16,300 --> 00:39:22,030
so and it had some other it had some

793
00:39:22,030 --> 00:39:25,120
other things that are advantageous to us

794
00:39:25,120 --> 00:39:30,420
for example linux tries to give a

795
00:39:30,420 --> 00:39:36,040
consecutive physical memory to two

796
00:39:36,040 --> 00:39:38,380
virtual machine hosts for efficiency

797
00:39:38,380 --> 00:39:42,490
sake so at which make it makes it easier

798
00:39:42,490 --> 00:39:44,320
for us to do row hammer and find bit

799
00:39:44,320 --> 00:39:49,080
flips and also makes it easier for us to

800
00:39:49,830 --> 00:39:52,990
make sure that these bit flips occur in

801
00:39:52,990 --> 00:39:55,510
our own memory and not in someone else's

802
00:39:55,510 --> 00:39:58,660
memory which yeah we wouldn't want to

803
00:39:58,660 --> 00:40:01,690
corrupt a system before we can exploit

804
00:40:01,690 --> 00:40:04,030
that of course crash the system before

805
00:40:04,030 --> 00:40:09,130
we can exploit it so so once we know we

806
00:40:09,130 --> 00:40:11,530
can flip a bit that's useful to us

807
00:40:11,530 --> 00:40:15,100
we replicate the the content and then

808
00:40:15,100 --> 00:40:20,260
wait for KSM to merge memory and we can

809
00:40:20,260 --> 00:40:22,270
know in a dish in a deterministic way

810
00:40:22,270 --> 00:40:25,870
whether KSM will merge it to our page

811
00:40:25,870 --> 00:40:29,830
and then we do wrong again and then we

812
00:40:29,830 --> 00:40:35,020
can exploit the target victim okay so

813
00:40:35,020 --> 00:40:37,570
one example how we did this was by

814
00:40:37,570 --> 00:40:39,240
attacking the authorized keys file

815
00:40:39,240 --> 00:40:42,010
authorized keys files usually contain

816
00:40:42,010 --> 00:40:45,810
the public keys and these public keys

817
00:40:45,810 --> 00:40:50,530
are not supposed to yeah they don't have

818
00:40:50,530 --> 00:40:52,270
to be kept secret

819
00:40:52,270 --> 00:40:55,060
I bet lots of you have probably uploaded

820
00:40:55,060 --> 00:40:57,760
their public key to get up and their

821
00:40:57,760 --> 00:41:05,200
public so and what we see here is in

822
00:41:05,200 --> 00:41:07,660
yellow we see the so this is an RSA

823
00:41:07,660 --> 00:41:12,100
public key and in yellow we see the RSA

824
00:41:12,100 --> 00:41:18,580
modulus base64 encoded of course we're

825
00:41:18,580 --> 00:41:21,100
not we're not supposed to factorize this

826
00:41:21,100 --> 00:41:22,870
modulus because then we can get the

827
00:41:22,870 --> 00:41:29,310
private key but in red here we have

828
00:41:31,920 --> 00:41:34,240
characters which contain at least one

829
00:41:34,240 --> 00:41:37,990
bit that when flipped will remain basic

830
00:41:37,990 --> 00:41:40,420
seafloor encoded but we're able to

831
00:41:40,420 --> 00:41:46,200
factorize the modulus within one minute

832
00:41:46,200 --> 00:41:54,090
so that's what we did flip a bit in the

833
00:41:54,090 --> 00:41:57,910
in the modulus factorize it and then

834
00:41:57,910 --> 00:42:02,129
reconstruct the private key and login

835
00:42:05,180 --> 00:42:12,799
[Applause]

836
00:42:13,990 --> 00:42:18,430
we have a second example where where we

837
00:42:18,430 --> 00:42:22,630
target GPG and up get to exploit the

838
00:42:22,630 --> 00:42:28,180
updates mechanism in Debian or bumsoo so

839
00:42:28,180 --> 00:42:30,910
and it's this is a two-stage attack

840
00:42:30,910 --> 00:42:33,940
where we first career the sources dot

841
00:42:33,940 --> 00:42:37,500
list file to redirect the updates

842
00:42:37,500 --> 00:42:43,529
repository to a domain name we control

843
00:42:44,309 --> 00:42:50,319
and we also corrupt a bit in the DBT

844
00:42:50,319 --> 00:42:53,079
keyring to probe the signing key to a

845
00:42:53,079 --> 00:42:57,039
key that we can reconstruct and then we

846
00:42:57,039 --> 00:43:03,839
can back to our and then we can backdoor

847
00:43:03,839 --> 00:43:07,390
packages being installed so you have a

848
00:43:07,390 --> 00:43:14,079
demo for this as well first it's a dis

849
00:43:14,079 --> 00:43:16,049
attack

850
00:43:16,049 --> 00:43:20,319
so what you see here is it's a machine

851
00:43:20,319 --> 00:43:22,809
running both an attacker virtual machine

852
00:43:22,809 --> 00:43:28,299
and a victim virtual machine in the top

853
00:43:28,299 --> 00:43:31,569
right corner there's the victim well in

854
00:43:31,569 --> 00:43:36,009
a minute so top left there are some

855
00:43:36,009 --> 00:43:43,720
debug information the bottom part is the

856
00:43:43,720 --> 00:43:47,799
the access log off of a HTTP update

857
00:43:47,799 --> 00:43:50,140
repository server that we control and

858
00:43:50,140 --> 00:43:54,839
the middle part is used to create the

859
00:43:54,839 --> 00:44:00,509
fake create the fake package so now

860
00:44:00,509 --> 00:44:02,349
nothing happened yet

861
00:44:02,349 --> 00:44:06,460
and let's get update is run so this is

862
00:44:06,460 --> 00:44:09,579
all fine but now we're going to flip a

863
00:44:09,579 --> 00:44:12,970
bit in the sources of list file and then

864
00:44:12,970 --> 00:44:19,359
when we do apt-get update again there

865
00:44:19,359 --> 00:44:22,779
will be an error because now it will

866
00:44:22,779 --> 00:44:24,700
connect to

867
00:44:24,700 --> 00:44:30,370
our repository of course this step

868
00:44:30,370 --> 00:44:34,570
doesn't have to be done but this just to

869
00:44:34,570 --> 00:44:39,190
show that yeah that now connects to the

870
00:44:39,190 --> 00:44:43,210
first to our repository well then we

871
00:44:43,210 --> 00:44:45,430
have after wait for a while to find a

872
00:44:45,430 --> 00:44:52,649
bit that we can exploit to corrupt GP GP

873
00:44:53,760 --> 00:45:00,040
and when we have done this we can

874
00:45:00,040 --> 00:45:05,410
reconstruct a private key and create a

875
00:45:05,410 --> 00:45:09,120
new package with the new signing key a

876
00:45:09,750 --> 00:45:12,929
[Music]

877
00:45:22,500 --> 00:45:35,200
new package and then when they when I've

878
00:45:35,200 --> 00:45:38,140
got upgrade this run Oh

879
00:45:38,140 --> 00:45:42,970
first we do LS still okay but then after

880
00:45:42,970 --> 00:45:49,200
the update our code is run

881
00:45:50,210 --> 00:45:58,250
[Applause]

882
00:45:58,250 --> 00:46:06,570
so in conclusion I think yeah I hope

883
00:46:06,570 --> 00:46:08,460
that we hope to have convinced you that

884
00:46:08,460 --> 00:46:11,730
memory deduplication can be dangerous if

885
00:46:11,730 --> 00:46:15,000
you're thinking about employer deploying

886
00:46:15,000 --> 00:46:17,190
it think we'd like you to think again

887
00:46:17,190 --> 00:46:20,190
and think again I think again and then

888
00:46:20,190 --> 00:46:23,220
maybe conclude well maybe let's just

889
00:46:23,220 --> 00:46:26,620
decide what thank you very much

890
00:46:26,620 --> 00:46:35,320
[Applause]

891
00:46:35,320 --> 00:46:38,720
so we have time for questions if you do

892
00:46:38,720 --> 00:46:40,760
have questions please come forward to

893
00:46:40,760 --> 00:46:45,620
one of those four microphones does the

894
00:46:45,620 --> 00:46:54,470
internet have a question none no

895
00:46:54,470 --> 00:46:57,050
question right now okay we have a

896
00:46:57,050 --> 00:46:59,510
question on the microphone on my left

897
00:46:59,510 --> 00:47:02,330
side in the front please please speak

898
00:47:02,330 --> 00:47:03,740
loudly into the microphone so we can

899
00:47:03,740 --> 00:47:05,330
hear you while people are leaving I

900
00:47:05,330 --> 00:47:07,550
would like to ask how does this apply

901
00:47:07,550 --> 00:47:09,860
for large pages so I think in all your

902
00:47:09,860 --> 00:47:11,660
examples you had small pages for a

903
00:47:11,660 --> 00:47:14,090
kilobyte so how does this apply to two

904
00:47:14,090 --> 00:47:17,510
megabyte pages for example yes so kernel

905
00:47:17,510 --> 00:47:20,570
same page merging employs large pages

906
00:47:20,570 --> 00:47:23,720
but actually is sadly was good for us

907
00:47:23,720 --> 00:47:30,040
but sadly the kernel same page working

908
00:47:30,040 --> 00:47:34,450
prioritizes merging over huge pages so

909
00:47:34,450 --> 00:47:37,160
actually we create huge pages at the

910
00:47:37,160 --> 00:47:39,370
start and to do the row hammer part

911
00:47:39,370 --> 00:47:44,300
that's the consecutive memory thing but

912
00:47:44,300 --> 00:47:49,090
when kind of same page merging finds a

913
00:47:49,090 --> 00:47:51,800
page which is identical inside this huge

914
00:47:51,800 --> 00:47:54,560
page it will break up the huge page and

915
00:47:54,560 --> 00:47:56,990
merge anyway so that's actually the

916
00:47:56,990 --> 00:47:59,900
worst worst-case scenario

917
00:47:59,900 --> 00:48:03,230
okay I see thank you great thank you

918
00:48:03,230 --> 00:48:05,780
then the next question would be right

919
00:48:05,780 --> 00:48:08,060
behind you yeah thank you yes about the

920
00:48:08,060 --> 00:48:10,280
process of deduplication itself does it

921
00:48:10,280 --> 00:48:11,570
use hashes or other things to achieve

922
00:48:11,570 --> 00:48:13,430
speed up to comparing or some heart

923
00:48:13,430 --> 00:48:15,170
acceleration may be even or artistic

924
00:48:15,170 --> 00:48:18,950
Kesh and the timing the input perform

925
00:48:18,950 --> 00:48:21,560
impacts of that process running on the

926
00:48:21,560 --> 00:48:24,830
background yes so we didn't do research

927
00:48:24,830 --> 00:48:28,220
on the latency but I think it does use

928
00:48:28,220 --> 00:48:30,470
some form of hashing both on Linux and

929
00:48:30,470 --> 00:48:36,350
windows yes and the next question please

930
00:48:36,350 --> 00:48:38,420
and well before you ask the question

931
00:48:38,420 --> 00:48:39,890
could I please ask the audience to

932
00:48:39,890 --> 00:48:43,300
remain quiet at this point thank you

933
00:48:43,300 --> 00:48:46,410
so these attacks

934
00:48:46,410 --> 00:48:50,510
they require that I if I am the attacker

935
00:48:50,510 --> 00:48:53,670
own or at least have interactive access

936
00:48:53,670 --> 00:48:57,770
to a virtual machine hosted on the same

937
00:48:57,770 --> 00:49:03,680
host as the target machines right ok so

938
00:49:03,680 --> 00:49:07,260
what are the implications for a say we

939
00:49:07,260 --> 00:49:11,539
VM or whatever environment thinking of

940
00:49:11,539 --> 00:49:15,510
desktop virtualization were actually the

941
00:49:15,510 --> 00:49:18,420
virtual guests are being used for

942
00:49:18,420 --> 00:49:20,599
interactive access and so you run

943
00:49:20,599 --> 00:49:22,799
JavaScript and a browser or whatever

944
00:49:22,799 --> 00:49:26,220
because I'm like every week being

945
00:49:26,220 --> 00:49:28,319
approached by companies trying to sell

946
00:49:28,319 --> 00:49:31,559
us desktop virtualization so the idea of

947
00:49:31,559 --> 00:49:37,589
running that gives a complete new large

948
00:49:37,589 --> 00:49:41,039
open door for for members spreading

949
00:49:41,039 --> 00:49:44,369
across virtual client computers right if

950
00:49:44,369 --> 00:49:46,410
they have theirs desktop virtualization

951
00:49:46,410 --> 00:49:50,640
so so our second detected as machina was

952
00:49:50,640 --> 00:49:53,430
done on Windows 10 so there we could

953
00:49:53,430 --> 00:49:57,750
leak information because Windows 10 does

954
00:49:57,750 --> 00:50:01,770
marry deduplication not only for not for

955
00:50:01,770 --> 00:50:03,329
virtual machines but also for its own

956
00:50:03,329 --> 00:50:06,809
processes so and Windows has disabled it

957
00:50:06,809 --> 00:50:10,289
but if you run Windows on a hypervisor

958
00:50:10,289 --> 00:50:13,680
where deduplication is yet again enabled

959
00:50:13,680 --> 00:50:17,240
then you have the same problem again

960
00:50:17,240 --> 00:50:19,589
thank you and then I have a question

961
00:50:19,589 --> 00:50:23,309
here on the right please do you also

962
00:50:23,309 --> 00:50:27,450
have the problem if you so are you

963
00:50:27,450 --> 00:50:30,450
venerable if you have both ECC memory

964
00:50:30,450 --> 00:50:34,890
and exempt any cryptographic secrets

965
00:50:34,890 --> 00:50:42,599
from deduplication so I haven't seen a

966
00:50:42,599 --> 00:50:45,180
practical attack with ECC memory on

967
00:50:45,180 --> 00:50:45,720
roarhammer

968
00:50:45,720 --> 00:50:48,770
I don't know so

969
00:50:49,530 --> 00:50:53,670
and I guess if you if you have

970
00:50:53,670 --> 00:50:55,380
cryptographic secrets and you don't

971
00:50:55,380 --> 00:50:57,570
deduplicate it or you put some

972
00:50:57,570 --> 00:50:59,220
randomness in there that it's impossible

973
00:50:59,220 --> 00:51:03,180
to guess then I'd say there's not much

974
00:51:03,180 --> 00:51:06,690
you can leak from the point on but it's

975
00:51:06,690 --> 00:51:09,690
something I think it's not yeah you

976
00:51:09,690 --> 00:51:12,990
shouldn't burden an application

977
00:51:12,990 --> 00:51:16,500
developer to be aware that their memory

978
00:51:16,500 --> 00:51:18,750
pay even to be even be aware of the

979
00:51:18,750 --> 00:51:21,330
content layout of of their program

980
00:51:21,330 --> 00:51:23,730
that's for most of the time very much

981
00:51:23,730 --> 00:51:26,700
low-level stuff that yeah application

982
00:51:26,700 --> 00:51:29,340
developers have no shouldn't have to

983
00:51:29,340 --> 00:51:32,280
have any concept about so I think this

984
00:51:32,280 --> 00:51:36,000
is really up to the the the operating

985
00:51:36,000 --> 00:51:38,100
system and high profile offenders to

986
00:51:38,100 --> 00:51:45,780
yeah not use thank you and in the back

987
00:51:45,780 --> 00:51:49,590
place when you merge the pages you can

988
00:51:49,590 --> 00:51:52,050
get more off you can have two in those

989
00:51:52,050 --> 00:51:53,430
examples you can have more of them how

990
00:51:53,430 --> 00:51:55,860
do you know which page will be the one

991
00:51:55,860 --> 00:52:01,320
that will be the last one so into it

992
00:52:01,320 --> 00:52:03,270
because it would be good that it's the

993
00:52:03,270 --> 00:52:04,950
one new control so we can flip the bits

994
00:52:04,950 --> 00:52:06,060
and how do you know if you have like

995
00:52:06,060 --> 00:52:08,880
five VMs and everyone every has the same

996
00:52:08,880 --> 00:52:13,830
page so it's it's kind of complicated at

997
00:52:13,830 --> 00:52:20,130
the so in k sm it's the oldest vm that

998
00:52:20,130 --> 00:52:24,450
gets merged to but there's an exemption

999
00:52:24,450 --> 00:52:27,420
if you first merge two pages and they

1000
00:52:27,420 --> 00:52:30,690
are put in the deferred so it first

1001
00:52:30,690 --> 00:52:32,730
merges two already merged pages and then

1002
00:52:32,730 --> 00:52:38,190
it merges to the oldest vm and so this

1003
00:52:38,190 --> 00:52:40,290
how the attack becomes harder if you're

1004
00:52:40,290 --> 00:52:42,660
the second vm and so in order to flip

1005
00:52:42,660 --> 00:52:44,610
things you need to be the first one so

1006
00:52:44,610 --> 00:52:46,710
then they will merge into you well not

1007
00:52:46,710 --> 00:52:48,540
necessarily but the attack becomes a bit

1008
00:52:48,540 --> 00:52:51,930
harder because so what you could do is

1009
00:52:51,930 --> 00:52:55,770
if so so the merging happens because

1010
00:52:55,770 --> 00:52:59,340
files are in the page cache so if you

1011
00:52:59,340 --> 00:53:01,470
can

1012
00:53:01,470 --> 00:53:03,660
if the files are not yet in the page

1013
00:53:03,660 --> 00:53:07,800
cache in the victim because no one has

1014
00:53:07,800 --> 00:53:09,660
tried to login for a user for a long

1015
00:53:09,660 --> 00:53:14,880
time you might be able to first create

1016
00:53:14,880 --> 00:53:17,010
two pages in your own address space wait

1017
00:53:17,010 --> 00:53:20,220
for it to be duplicated then log in to

1018
00:53:20,220 --> 00:53:23,790
SSH and then SSH will load it in the

1019
00:53:23,790 --> 00:53:25,080
page cache and then it gets merged to

1020
00:53:25,080 --> 00:53:26,490
Europe you win because you're merged

1021
00:53:26,490 --> 00:53:32,430
already ins thank you and a question

1022
00:53:32,430 --> 00:53:34,650
here in the front please yes Ovid if I

1023
00:53:34,650 --> 00:53:37,670
understand it correctly the attack works

1024
00:53:37,670 --> 00:53:41,220
only if you know if you detect the time

1025
00:53:41,220 --> 00:53:43,680
difference between when copy-on-write

1026
00:53:43,680 --> 00:53:45,650
happens and when it does not

1027
00:53:45,650 --> 00:53:47,460
wouldn't it be able to have

1028
00:53:47,460 --> 00:53:49,710
implementations of deduplication with

1029
00:53:49,710 --> 00:53:53,010
some artificial timing edits so there's

1030
00:53:53,010 --> 00:53:57,120
no real difference so well the

1031
00:53:57,120 --> 00:54:00,630
copy-on-write takes time so there's yeah

1032
00:54:00,630 --> 00:54:04,830
that's probably not no yeah so there's

1033
00:54:04,830 --> 00:54:06,060
always going to be a time difference

1034
00:54:06,060 --> 00:54:07,760
because you don't want to have

1035
00:54:07,760 --> 00:54:10,490
artificially you don't want to

1036
00:54:10,490 --> 00:54:12,960
artificially slow every right operation

1037
00:54:12,960 --> 00:54:16,410
that's just would it be theoretically be

1038
00:54:16,410 --> 00:54:20,880
possible to do it if chiming is not a

1039
00:54:20,880 --> 00:54:22,950
constraint you have to all the right

1040
00:54:22,950 --> 00:54:25,560
operations you have to slow them down as

1041
00:54:25,560 --> 00:54:28,380
well right I mean this is not feasible

1042
00:54:28,380 --> 00:54:34,080
in the end so thank you if there is a

1043
00:54:34,080 --> 00:54:38,670
question from the internet yes the

1044
00:54:38,670 --> 00:54:42,060
question is can this be applied for long

1045
00:54:42,060 --> 00:54:45,860
PGP keys can we leak them

1046
00:54:47,460 --> 00:54:51,660
so licking the the complete contents or

1047
00:54:51,660 --> 00:54:56,369
breaking them or doesn't say so in a

1048
00:54:56,369 --> 00:55:01,349
question I suppose it's about leaking

1049
00:55:01,349 --> 00:55:04,980
them from memory if you can find a way

1050
00:55:04,980 --> 00:55:08,940
to for example first load them in so it

1051
00:55:08,940 --> 00:55:12,749
really depends so we take some effort to

1052
00:55:12,749 --> 00:55:19,160
find the situation so if lots of lots of

1053
00:55:19,160 --> 00:55:22,079
opportunity to find find situations

1054
00:55:22,079 --> 00:55:24,480
where you can leak data but it's really

1055
00:55:24,480 --> 00:55:29,809
difficult now it just takes time to find

1056
00:55:29,809 --> 00:55:33,180
right find the right circumstances

1057
00:55:33,180 --> 00:55:35,099
because it's just so much you can

1058
00:55:35,099 --> 00:55:40,769
explore so it's so we didn't find so we

1059
00:55:40,769 --> 00:55:44,039
didn't look for a situation where we

1060
00:55:44,039 --> 00:55:48,269
could leak GPG keys so I wouldn't say

1061
00:55:48,269 --> 00:55:53,220
it's impossible I do think that some

1062
00:55:53,220 --> 00:55:57,210
that some crypto applications really

1063
00:55:57,210 --> 00:56:03,779
make try to not keep private keys in

1064
00:56:03,779 --> 00:56:08,849
memory longer than needed so I wouldn't

1065
00:56:08,849 --> 00:56:12,150
know maybe you can try and find out all

1066
00:56:12,150 --> 00:56:15,450
right thank you great and then we have a

1067
00:56:15,450 --> 00:56:18,539
last question over here please maybe do

1068
00:56:18,539 --> 00:56:20,549
you have some advice for the Linux

1069
00:56:20,549 --> 00:56:23,239
kernel programmers I think in the second

1070
00:56:23,239 --> 00:56:27,720
example you set for example the HDD

1071
00:56:27,720 --> 00:56:29,430
application used I think it was Windows

1072
00:56:29,430 --> 00:56:33,059
10 was better they did first copy the

1073
00:56:33,059 --> 00:56:35,640
page to be duplicated in a free page and

1074
00:56:35,640 --> 00:56:39,420
then pointed the two pages to be DW kata

1075
00:56:39,420 --> 00:56:43,589
there and in Ubuntu it was that they

1076
00:56:43,589 --> 00:56:45,690
just point one page to the other and

1077
00:56:45,690 --> 00:56:48,779
drop drop the page so the Microsoft

1078
00:56:48,779 --> 00:56:51,989
approach is here more safe yet so I

1079
00:56:51,989 --> 00:56:53,730
don't know if they were aware of this

1080
00:56:53,730 --> 00:56:56,040
but in this case

1081
00:56:56,040 --> 00:56:58,620
well maybe they were I don't know in

1082
00:56:58,620 --> 00:57:00,120
this case it was and and there's

1083
00:57:00,120 --> 00:57:04,740
certainly some approaches are or make it

1084
00:57:04,740 --> 00:57:06,660
harder and some approaches make it

1085
00:57:06,660 --> 00:57:09,180
easier of course the the relocation

1086
00:57:09,180 --> 00:57:11,580
doesn't prevent us from leaking data but

1087
00:57:11,580 --> 00:57:18,660
it would help yeah would help maybe with

1088
00:57:18,660 --> 00:57:22,080
with making it row harder although we

1089
00:57:22,080 --> 00:57:25,050
also have a our group also has a paper

1090
00:57:25,050 --> 00:57:29,340
on row row on row hammer on Android

1091
00:57:29,340 --> 00:57:31,530
where we don't make use of memory

1092
00:57:31,530 --> 00:57:34,050
deduplication but with the met we make

1093
00:57:34,050 --> 00:57:38,730
use of a different mechanism in order to

1094
00:57:38,730 --> 00:57:45,950
control where memory pages are get

1095
00:57:45,950 --> 00:57:49,320
relocated so yeah from the wrong mo we

1096
00:57:49,320 --> 00:57:52,020
can't do anything because we hope to we

1097
00:57:52,020 --> 00:57:53,340
would have to change the memory

1098
00:57:53,340 --> 00:57:56,970
architecture but maybe you can publish

1099
00:57:56,970 --> 00:57:59,310
some advices what what you do better

1100
00:57:59,310 --> 00:58:01,650
with for example memory deallocation

1101
00:58:01,650 --> 00:58:03,900
what you found you you for in your

1102
00:58:03,900 --> 00:58:09,900
researches just as an idea yeah so there

1103
00:58:09,900 --> 00:58:15,120
are some mitigations we didn't know yeah

1104
00:58:15,120 --> 00:58:17,960
so my but they always have some

1105
00:58:17,960 --> 00:58:22,260
performance penalty drawbacks and so i I

1106
00:58:22,260 --> 00:58:23,880
don't know whether they will be

1107
00:58:23,880 --> 00:58:28,110
implemented because or our standards

1108
00:58:28,110 --> 00:58:34,980
yeah enabled okay bye thank you we have

1109
00:58:34,980 --> 00:58:37,950
to cut it thank you so much so please

1110
00:58:37,950 --> 00:58:40,260
help me thank Antonio and anything for a

1111
00:58:40,260 --> 00:58:41,210
wonderful demonstration

1112
00:58:41,210 --> 00:58:47,390
[Applause]

1113
00:58:47,390 --> 00:59:12,419
[Music]

