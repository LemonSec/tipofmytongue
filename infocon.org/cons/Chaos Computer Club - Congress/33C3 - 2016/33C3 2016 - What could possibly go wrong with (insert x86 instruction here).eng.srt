1
00:00:01,760 --> 00:00:10,690
[Music]

2
00:00:13,420 --> 00:00:15,549
we are real River motto and the motto of

3
00:00:15,549 --> 00:00:18,760
this yearís works for me and I think who

4
00:00:18,760 --> 00:00:20,590
many people how many people in your

5
00:00:20,590 --> 00:00:22,630
program is raise your hands or shout out

6
00:00:22,630 --> 00:00:27,489
or whoa that's a lot okay so I think

7
00:00:27,489 --> 00:00:35,469
many of you will work on x86 yeah and I

8
00:00:35,469 --> 00:00:37,899
think you assume that it works and that

9
00:00:37,899 --> 00:00:42,430
everything works as intended and I mean

10
00:00:42,430 --> 00:00:46,929
what could go wrong our next talk the

11
00:00:46,929 --> 00:00:49,239
first one today will be by Clementi

12
00:00:49,239 --> 00:00:53,409
maurice who previously was here with raw

13
00:00:53,409 --> 00:00:55,870
hamachi is something I would call scary

14
00:00:55,870 --> 00:00:59,499
and mobitz live who has worked on the

15
00:00:59,499 --> 00:01:03,699
Armageddon exploit back what is it

16
00:01:03,699 --> 00:01:08,950
okay so the next I would like to hear a

17
00:01:08,950 --> 00:01:11,979
really warm place for speakers for the

18
00:01:11,979 --> 00:01:14,140
talk what could what could possibly go

19
00:01:14,140 --> 00:01:17,049
wrong with insert x86 instruction here

20
00:01:17,049 --> 00:01:19,530
thank you

21
00:01:27,390 --> 00:01:30,490
well thank you all for being here this

22
00:01:30,490 --> 00:01:33,640
morning yes this is our talk what could

23
00:01:33,640 --> 00:01:36,220
possibly go wrong with instead x86

24
00:01:36,220 --> 00:01:38,650
instruction here so just a few words

25
00:01:38,650 --> 00:01:40,800
about ourselves so I'm clemency Murray's

26
00:01:40,800 --> 00:01:43,450
got my PhD last year in computer science

27
00:01:43,450 --> 00:01:45,640
and I'm not working as a postdoc at

28
00:01:45,640 --> 00:01:47,350
class University of Technology in

29
00:01:47,350 --> 00:01:50,110
Austria you can reach me on Twitter or

30
00:01:50,110 --> 00:01:52,090
by email but there's also I think a lots

31
00:01:52,090 --> 00:01:55,360
of time before the Congress is over hi

32
00:01:55,360 --> 00:01:57,640
and my name is Norbert slip I'm a PhD

33
00:01:57,640 --> 00:01:59,950
student at cars University of Technology

34
00:01:59,950 --> 00:02:02,320
and you can also reach me on Twitter or

35
00:02:02,320 --> 00:02:04,420
just after our talk and in the next

36
00:02:04,420 --> 00:02:08,229
day's so about this talk so the title

37
00:02:08,229 --> 00:02:10,570
says this is a talk about x86

38
00:02:10,570 --> 00:02:13,120
instructions but this is not a talk

39
00:02:13,120 --> 00:02:17,050
about software don't leave yet I'm

40
00:02:17,050 --> 00:02:19,660
actually even assuming safe software and

41
00:02:19,660 --> 00:02:21,220
the point that we want to make is that

42
00:02:21,220 --> 00:02:23,320
safe software does not mean safe

43
00:02:23,320 --> 00:02:26,470
execution and we have information

44
00:02:26,470 --> 00:02:27,940
leakage because of the underlying

45
00:02:27,940 --> 00:02:29,860
hardware and this is what we're going to

46
00:02:29,860 --> 00:02:32,799
talk about today so we'll be talking

47
00:02:32,799 --> 00:02:34,810
about cache attacks what are they what

48
00:02:34,810 --> 00:02:37,209
can we do with that and also a special

49
00:02:37,209 --> 00:02:39,040
kind of cache attack that we found this

50
00:02:39,040 --> 00:02:41,650
year so doing cache attacks without

51
00:02:41,650 --> 00:02:43,959
memory accesses and how to use that even

52
00:02:43,959 --> 00:02:49,540
to bypass K&L aslo so again the talk

53
00:02:49,540 --> 00:02:51,970
says is to talk about x86 instructions

54
00:02:51,970 --> 00:02:54,120
but this is even more global than that

55
00:02:54,120 --> 00:02:56,590
we can also mount this cache attacks on

56
00:02:56,590 --> 00:02:59,440
arm and not only on the x86 so some of

57
00:02:59,440 --> 00:03:00,910
the examples that you will see also

58
00:03:00,910 --> 00:03:07,299
applies to arm so today we'll do have a

59
00:03:07,299 --> 00:03:09,489
bit of background but actually most of

60
00:03:09,489 --> 00:03:11,560
the background will be along the lines

61
00:03:11,560 --> 00:03:14,500
because this covers really a huge chunk

62
00:03:14,500 --> 00:03:19,570
of our research and we'll see mainly

63
00:03:19,570 --> 00:03:22,150
three instructions so move and how we

64
00:03:22,150 --> 00:03:24,459
can perform these cache attacks what are

65
00:03:24,459 --> 00:03:28,120
they the instructions he'll flush so

66
00:03:28,120 --> 00:03:29,799
here we'll be doing cache attacks

67
00:03:29,799 --> 00:03:33,430
without any memory accesses then we'll

68
00:03:33,430 --> 00:03:36,190
see prefetch and how we can bypass

69
00:03:36,190 --> 00:03:39,160
kernel aslr and lots of translations

70
00:03:39,160 --> 00:03:40,450
levels

71
00:03:40,450 --> 00:03:43,780
and then there's even a bonus track so

72
00:03:43,780 --> 00:03:46,690
it's this this will be not our works but

73
00:03:46,690 --> 00:03:49,120
even more instructions and even more

74
00:03:49,120 --> 00:03:53,440
text okay so let's start with a bit of

75
00:03:53,440 --> 00:03:57,879
an introduction so we will be mainly

76
00:03:57,879 --> 00:04:00,299
focusing on Intel CPUs and this is

77
00:04:00,299 --> 00:04:02,920
roughly in terms of course and caches

78
00:04:02,920 --> 00:04:04,450
how it looks like today so we have

79
00:04:04,450 --> 00:04:07,330
different levels of course at different

80
00:04:07,330 --> 00:04:09,340
costs so here focus and different levels

81
00:04:09,340 --> 00:04:12,160
of caches so here usually we have three

82
00:04:12,160 --> 00:04:14,319
levels of caches we have level 1 and

83
00:04:14,319 --> 00:04:15,940
level 2 then our private to which core

84
00:04:15,940 --> 00:04:17,978
which means that core 0 can only access

85
00:04:17,978 --> 00:04:20,410
its level 1 and its level 2 and not

86
00:04:20,410 --> 00:04:22,300
level 1 and level 2 of for example call

87
00:04:22,300 --> 00:04:26,350
3 and we have the last level cache so

88
00:04:26,350 --> 00:04:29,650
here if you can see the pointer so this

89
00:04:29,650 --> 00:04:31,900
one is divided in slices so we have as

90
00:04:31,900 --> 00:04:35,950
many slices as core so here 4 slices but

91
00:04:35,950 --> 00:04:38,289
all the slices are shared across goal so

92
00:04:38,289 --> 00:04:40,330
cos 0 can access the whole last level

93
00:04:40,330 --> 00:04:45,760
cache let 0 1 2 & 3 we also have a nice

94
00:04:45,760 --> 00:04:48,340
property on Intel CPUs is that this

95
00:04:48,340 --> 00:04:50,440
level of cache is inclusive and what it

96
00:04:50,440 --> 00:04:51,729
means is that everything that is

97
00:04:51,729 --> 00:04:53,590
contained in level 1 and level 2 will

98
00:04:53,590 --> 00:04:55,450
also be contained in the last level

99
00:04:55,450 --> 00:04:57,340
cache and this will prove to be quite

100
00:04:57,340 --> 00:05:01,960
useful for cache attacks so today we

101
00:05:01,960 --> 00:05:05,370
mostly have says set associative caches

102
00:05:05,370 --> 00:05:08,680
what it means is that we have data that

103
00:05:08,680 --> 00:05:10,510
is loaded in specific sets and that

104
00:05:10,510 --> 00:05:13,210
depends only on its address so we have

105
00:05:13,210 --> 00:05:16,240
some bits of the address that gives us

106
00:05:16,240 --> 00:05:18,580
the index and that says ok the line is

107
00:05:18,580 --> 00:05:20,349
going to be loading in this cache set so

108
00:05:20,349 --> 00:05:24,370
this is a carry set then we have several

109
00:05:24,370 --> 00:05:28,139
ways per set so here we have 4 ways and

110
00:05:28,139 --> 00:05:30,550
the cache line is going to be loaded in

111
00:05:30,550 --> 00:05:33,130
a specific way and that will only depend

112
00:05:33,130 --> 00:05:35,169
on the replacement policy and not on the

113
00:05:35,169 --> 00:05:38,620
address itself so when you load a line

114
00:05:38,620 --> 00:05:40,630
into the cache usually the cache is

115
00:05:40,630 --> 00:05:42,550
already full and you have to make room

116
00:05:42,550 --> 00:05:44,950
for a new line so this is what the

117
00:05:44,950 --> 00:05:45,460
replacement

118
00:05:45,460 --> 00:05:48,219
replacement policy this is what it does

119
00:05:48,219 --> 00:05:50,469
it says ok I'm going to remove this line

120
00:05:50,469 --> 00:05:55,110
to mix to make room for the next line

121
00:05:55,149 --> 00:05:57,529
so for today we're going to see only

122
00:05:57,529 --> 00:05:59,149
through instruction sighs I've been

123
00:05:59,149 --> 00:06:01,550
telling you so the move instruction it

124
00:06:01,550 --> 00:06:04,309
does a lot of things but the only aspect

125
00:06:04,309 --> 00:06:06,589
that we're interested about it that can

126
00:06:06,589 --> 00:06:10,159
access data in the main memory we're

127
00:06:10,159 --> 00:06:12,949
going to see a CL flash what it does is

128
00:06:12,949 --> 00:06:15,439
that it removes a cache line from the

129
00:06:15,439 --> 00:06:18,319
cache from the whole cache and we're

130
00:06:18,319 --> 00:06:20,990
going to see prefetch here prefetch a

131
00:06:20,990 --> 00:06:25,459
cache line for future use so we're going

132
00:06:25,459 --> 00:06:28,069
to see what they do and the kind of side

133
00:06:28,069 --> 00:06:30,050
effect that they have and all the

134
00:06:30,050 --> 00:06:32,749
attacks that we can do with them and

135
00:06:32,749 --> 00:06:34,520
that's basically all the example you

136
00:06:34,520 --> 00:06:36,110
need for today so even if you're not an

137
00:06:36,110 --> 00:06:39,259
expert of x86 don't worry it's not just

138
00:06:39,259 --> 00:06:43,849
slides full of assembly and stuff okay

139
00:06:43,849 --> 00:06:45,830
so on to the first one so we will first

140
00:06:45,830 --> 00:06:48,279
start with the muff instruction and

141
00:06:48,279 --> 00:06:52,449
actually the first slide is full of code

142
00:06:52,449 --> 00:06:56,209
however as you consider the morph

143
00:06:56,209 --> 00:06:57,919
instruction is used to move data from

144
00:06:57,919 --> 00:07:00,379
registers to redress dust from the main

145
00:07:00,379 --> 00:07:02,149
memory and back to the main memory and

146
00:07:02,149 --> 00:07:04,639
as you can see there are many moves you

147
00:07:04,639 --> 00:07:06,740
can use but basically it's just to move

148
00:07:06,740 --> 00:07:09,409
data and that's all we need to know in

149
00:07:09,409 --> 00:07:11,719
addition a lot of exceptions can occur

150
00:07:11,719 --> 00:07:14,419
so we can assume that while those

151
00:07:14,419 --> 00:07:16,699
restrictions are so tight that nothing

152
00:07:16,699 --> 00:07:17,569
can go wrong

153
00:07:17,569 --> 00:07:20,329
when you just move data because moving

154
00:07:20,329 --> 00:07:23,719
data is simple however while there are a

155
00:07:23,719 --> 00:07:27,319
lot of exceptions the data that is

156
00:07:27,319 --> 00:07:29,209
accessed is always loaded into the cache

157
00:07:29,209 --> 00:07:33,680
so data is in the cache and this is

158
00:07:33,680 --> 00:07:36,110
transparent to the program that is

159
00:07:36,110 --> 00:07:39,199
running however there are side-effects

160
00:07:39,199 --> 00:07:41,779
when you run this instruction we will

161
00:07:41,779 --> 00:07:43,819
see how they look like with the move

162
00:07:43,819 --> 00:07:46,699
instruction so you probably all know

163
00:07:46,699 --> 00:07:49,819
that data can either be in CPU registers

164
00:07:49,819 --> 00:07:51,800
in the different levels of the cache

165
00:07:51,800 --> 00:07:54,289
that Clementine showed to you earlier in

166
00:07:54,289 --> 00:07:57,459
the main memory on the disk and

167
00:07:57,459 --> 00:08:00,079
depending on where the memory and the

168
00:08:00,079 --> 00:08:02,539
data is located it leaves a longer time

169
00:08:02,539 --> 00:08:05,050
to be loaded back to the CPU

170
00:08:05,050 --> 00:08:07,659
and this is what we can see in this plot

171
00:08:07,659 --> 00:08:12,789
so we try here to measure the access

172
00:08:12,789 --> 00:08:14,789
time of an address over and over again

173
00:08:14,789 --> 00:08:17,349
assuming that when we exit is more often

174
00:08:17,349 --> 00:08:20,099
it is already stored in the cache so

175
00:08:20,099 --> 00:08:24,069
around 70 cycles most of the time we can

176
00:08:24,069 --> 00:08:26,710
assume when we load an AK address and it

177
00:08:26,710 --> 00:08:29,139
takes 70 cycles its loaded into the

178
00:08:29,139 --> 00:08:34,240
cache however when we assume that the

179
00:08:34,240 --> 00:08:36,490
data is loaded from the main memory we

180
00:08:36,490 --> 00:08:39,279
can clearly see that it needs a much

181
00:08:39,279 --> 00:08:42,458
longer time like a bit more than 200

182
00:08:42,458 --> 00:08:45,519
cycles so depending when we measure the

183
00:08:45,519 --> 00:08:47,560
time it needs to take to load the

184
00:08:47,560 --> 00:08:49,870
address we can say the data has been

185
00:08:49,870 --> 00:08:52,180
loaded to the cache or the data is still

186
00:08:52,180 --> 00:08:56,110
located in the main memory and this

187
00:08:56,110 --> 00:08:58,660
property is what we can exploit using

188
00:08:58,660 --> 00:09:01,329
cache attacks so we measure the timing

189
00:09:01,329 --> 00:09:05,380
differences on memory accesses and what

190
00:09:05,380 --> 00:09:07,570
an attacker does he monitors the cache

191
00:09:07,570 --> 00:09:10,060
lines but he has no way to know what's

192
00:09:10,060 --> 00:09:12,160
actually the content of the cache line

193
00:09:12,160 --> 00:09:14,649
so we can only monitor that this cache

194
00:09:14,649 --> 00:09:17,020
line has been accessed and not what's

195
00:09:17,020 --> 00:09:19,890
actually stored in the cache line and

196
00:09:19,890 --> 00:09:22,270
what you can do with this is you can

197
00:09:22,270 --> 00:09:24,430
implement covert channels so you can

198
00:09:24,430 --> 00:09:26,829
allow two processes to communicate with

199
00:09:26,829 --> 00:09:27,430
each other

200
00:09:27,430 --> 00:09:29,860
evading the permission system what we

201
00:09:29,860 --> 00:09:32,500
will see later on in addition you can

202
00:09:32,500 --> 00:09:35,079
also do side channel attacks so you can

203
00:09:35,079 --> 00:09:37,420
spy with a malicious attacking

204
00:09:37,420 --> 00:09:40,630
application on benign processes and you

205
00:09:40,630 --> 00:09:42,640
can use this to steal cryptographic keys

206
00:09:42,640 --> 00:09:47,740
or to spy on keystrokes and basically we

207
00:09:47,740 --> 00:09:49,630
have different types of cache attacks

208
00:09:49,630 --> 00:09:54,339
and I want to explain the most popular

209
00:09:54,339 --> 00:09:56,290
one the flush and reload attack in the

210
00:09:56,290 --> 00:09:59,110
beginning so on the left you have the

211
00:09:59,110 --> 00:10:01,630
address space of the victim and on the

212
00:10:01,630 --> 00:10:03,610
right you have the address space of the

213
00:10:03,610 --> 00:10:06,209
attacker who maps a shared library on

214
00:10:06,209 --> 00:10:09,399
executable that the victim is used in to

215
00:10:09,399 --> 00:10:12,579
its own address space like the red

216
00:10:12,579 --> 00:10:15,310
rectangle and this means that when this

217
00:10:15,310 --> 00:10:18,110
data is stored in the cache

218
00:10:18,110 --> 00:10:22,790
it's cached for both processes now the

219
00:10:22,790 --> 00:10:25,100
attacker can use the flash instruction

220
00:10:25,100 --> 00:10:28,010
to remove the data out of the cache so

221
00:10:28,010 --> 00:10:30,079
it's not in the cache anymore so it's

222
00:10:30,079 --> 00:10:33,500
also not cached for the victim now the

223
00:10:33,500 --> 00:10:36,260
attacker can schedule the victim and if

224
00:10:36,260 --> 00:10:38,269
the victim decides yeah I need this data

225
00:10:38,269 --> 00:10:40,370
it will be loaded back into the cache

226
00:10:40,370 --> 00:10:43,810
and now the attacker can reload the data

227
00:10:43,810 --> 00:10:46,339
measure the time how long it took and

228
00:10:46,339 --> 00:10:49,160
then decide okay the victim has accessed

229
00:10:49,160 --> 00:10:51,140
the data in the meantime or the victim

230
00:10:51,140 --> 00:10:52,579
has not accessed the data in the

231
00:10:52,579 --> 00:10:55,880
meantime and by that you can spy if this

232
00:10:55,880 --> 00:10:59,600
address has been used the second type of

233
00:10:59,600 --> 00:11:02,240
attack is called Prime and probe and it

234
00:11:02,240 --> 00:11:04,579
does not rely on the shared memory like

235
00:11:04,579 --> 00:11:06,680
the flash entry load attack and it works

236
00:11:06,680 --> 00:11:09,519
as the following so instead of mapping

237
00:11:09,519 --> 00:11:12,890
anything into its own address space the

238
00:11:12,890 --> 00:11:16,310
cap attacker loads a lot of data into

239
00:11:16,310 --> 00:11:21,200
one cache line here and fills the cache

240
00:11:21,200 --> 00:11:24,050
and now he again schedules the victim

241
00:11:24,050 --> 00:11:26,899
and the schedule can access data that

242
00:11:26,899 --> 00:11:33,199
maps to the same cache set so the cache

243
00:11:33,199 --> 00:11:35,209
set is used by the attacker and the

244
00:11:35,209 --> 00:11:38,029
victim at the same time and now the

245
00:11:38,029 --> 00:11:41,149
attacker can start measuring the access

246
00:11:41,149 --> 00:11:43,130
time do the addresses he loaded into the

247
00:11:43,130 --> 00:11:46,130
cache before and when he accesses an

248
00:11:46,130 --> 00:11:48,709
address that is still in the cache it's

249
00:11:48,709 --> 00:11:51,230
faster so it measures the slower time

250
00:11:51,230 --> 00:11:53,930
and he fee if it's not in the cache

251
00:11:53,930 --> 00:11:56,570
anymore it has to be reloaded into the

252
00:11:56,570 --> 00:11:58,910
cache so it takes a longer time and he

253
00:11:58,910 --> 00:12:02,510
can sum this up and detect if the victim

254
00:12:02,510 --> 00:12:05,410
has loaded data into the cache as well

255
00:12:05,410 --> 00:12:08,240
so the first thing we want to show you

256
00:12:08,240 --> 00:12:10,310
is what you can do with cache attacks is

257
00:12:10,310 --> 00:12:13,120
you can implement a covert channel and

258
00:12:13,120 --> 00:12:15,800
this could be happening in the following

259
00:12:15,800 --> 00:12:18,920
scenario so you install an app on your

260
00:12:18,920 --> 00:12:22,130
phone to watch your favorite inventions

261
00:12:22,130 --> 00:12:25,790
you take to apply some filters and in

262
00:12:25,790 --> 00:12:27,199
the end you don't know that this

263
00:12:27,199 --> 00:12:29,209
malicious because the only permission it

264
00:12:29,209 --> 00:12:31,610
requires is to access your images

265
00:12:31,610 --> 00:12:33,950
which makes sense so you can easily

266
00:12:33,950 --> 00:12:37,550
install it without any fear in addition

267
00:12:37,550 --> 00:12:38,779
you want to know what the weather is

268
00:12:38,779 --> 00:12:41,089
outside so install a nice little weather

269
00:12:41,089 --> 00:12:43,519
widget and the only permission it has is

270
00:12:43,519 --> 00:12:46,130
to access the internet because it has

271
00:12:46,130 --> 00:12:50,170
blowed the information from somewhere so

272
00:12:50,170 --> 00:12:53,360
what happens if you're able to implement

273
00:12:53,360 --> 00:12:55,970
a cover channel between two these two

274
00:12:55,970 --> 00:12:58,760
applications without any permissions and

275
00:12:58,760 --> 00:13:00,680
privileges so they can communicate with

276
00:13:00,680 --> 00:13:03,800
each other without using any mechanisms

277
00:13:03,800 --> 00:13:05,779
provided by the operating system so it's

278
00:13:05,779 --> 00:13:09,019
hidden it can happen that now the

279
00:13:09,019 --> 00:13:11,149
gallery image can sent the image to the

280
00:13:11,149 --> 00:13:15,010
internet which will be uploaded and

281
00:13:15,010 --> 00:13:18,620
exposed for everyone so you maybe don't

282
00:13:18,620 --> 00:13:21,100
want to see the cat picture everywhere

283
00:13:21,100 --> 00:13:25,370
and while we can use this with those

284
00:13:25,370 --> 00:13:27,709
primont probe flash and reload attacks

285
00:13:27,709 --> 00:13:30,320
we will discuss a covert channel using

286
00:13:30,320 --> 00:13:32,779
priming probe so how can we transmit

287
00:13:32,779 --> 00:13:35,000
this data so we need to transmit ones

288
00:13:35,000 --> 00:13:38,300
and zeros at some point so the sender

289
00:13:38,300 --> 00:13:40,459
and the receiver agree on one cache set

290
00:13:40,459 --> 00:13:43,910
that they both use and the receiver

291
00:13:43,910 --> 00:13:48,500
probes the set all the time and when the

292
00:13:48,500 --> 00:13:50,930
sender wants to transmit a zero he just

293
00:13:50,930 --> 00:13:55,940
does nothing so the lines of the

294
00:13:55,940 --> 00:13:58,040
receiver are in the cache all the time

295
00:13:58,040 --> 00:14:00,260
and he knows okay he's sending nothing

296
00:14:00,260 --> 00:14:03,170
so it's a zero on the other hand if the

297
00:14:03,170 --> 00:14:04,970
sender wants to transmit the one he

298
00:14:04,970 --> 00:14:07,190
starts accessing addresses that mapped

299
00:14:07,190 --> 00:14:09,589
to the same cache set so it will take a

300
00:14:09,589 --> 00:14:12,110
longer time for the receiver to access

301
00:14:12,110 --> 00:14:14,540
its addresses again and he knows okay

302
00:14:14,540 --> 00:14:17,269
the sender of trusts entered me at one

303
00:14:17,269 --> 00:14:20,449
and Clementine will show you what you

304
00:14:20,449 --> 00:14:23,959
can do with this cover channel so the

305
00:14:23,959 --> 00:14:25,699
really nice thing about priming probe is

306
00:14:25,699 --> 00:14:27,470
that it has really low requirements so

307
00:14:27,470 --> 00:14:29,180
it doesn't in any kind of share memory

308
00:14:29,180 --> 00:14:32,510
and for example if you have two virtual

309
00:14:32,510 --> 00:14:34,699
machines you could have some shared

310
00:14:34,699 --> 00:14:37,070
memory via memory deduplication the

311
00:14:37,070 --> 00:14:38,779
thing is that this highly insecure so

312
00:14:38,779 --> 00:14:41,270
cloud providers like Amazon ec2 they

313
00:14:41,270 --> 00:14:44,149
disable that now we can see use Premiere

314
00:14:44,149 --> 00:14:45,130
Pro because it doesn't

315
00:14:45,130 --> 00:14:47,670
it doesn't need this share memory

316
00:14:47,670 --> 00:14:51,040
another problem with cache cover channel

317
00:14:51,040 --> 00:14:53,650
is that they are quite noisy so you have

318
00:14:53,650 --> 00:14:55,720
other applications that are also running

319
00:14:55,720 --> 00:14:57,790
on the system they are all competing for

320
00:14:57,790 --> 00:15:00,670
the cash and they might like evict some

321
00:15:00,670 --> 00:15:02,320
cache lines especially if it's an

322
00:15:02,320 --> 00:15:03,850
application that is very memory

323
00:15:03,850 --> 00:15:07,750
intensive and you also have noise due to

324
00:15:07,750 --> 00:15:08,890
the fact that the sender and the

325
00:15:08,890 --> 00:15:10,570
receiver might not be scheduled at the

326
00:15:10,570 --> 00:15:12,430
same time so if you have your sender

327
00:15:12,430 --> 00:15:14,230
that sends all the things and the

328
00:15:14,230 --> 00:15:16,510
receive is not scheduled then some part

329
00:15:16,510 --> 00:15:19,600
of the transmission can get lost so what

330
00:15:19,600 --> 00:15:22,060
we did is we try to build an error free

331
00:15:22,060 --> 00:15:25,360
cover channel so we took care of these

332
00:15:25,360 --> 00:15:28,570
all these noise issues by using some

333
00:15:28,570 --> 00:15:32,140
error detection to resynchronize the

334
00:15:32,140 --> 00:15:35,050
center and the receiver and then we use

335
00:15:35,050 --> 00:15:37,750
some error correction to correct the

336
00:15:37,750 --> 00:15:39,790
remaining errors so we managed to have

337
00:15:39,790 --> 00:15:41,650
it completely error-free cover channel

338
00:15:41,650 --> 00:15:44,770
even if you have a lot of noise so let's

339
00:15:44,770 --> 00:15:47,110
say another virtual machine also on the

340
00:15:47,110 --> 00:15:51,610
machine as in solving files through a

341
00:15:51,610 --> 00:15:54,640
web server also doing lots of memory

342
00:15:54,640 --> 00:15:59,710
intensive tasks at the same time and it

343
00:15:59,710 --> 00:16:00,940
the collection is stayed completely

344
00:16:00,940 --> 00:16:04,720
error-free and around 40 to 75 kilo

345
00:16:04,720 --> 00:16:06,820
bytes per second which is still quite a

346
00:16:06,820 --> 00:16:09,760
lot all of this between virtual machines

347
00:16:09,760 --> 00:16:13,060
on Amazon ec2 and the really neat thing

348
00:16:13,060 --> 00:16:15,930
that we wanted to do something with that

349
00:16:15,930 --> 00:16:19,120
and basically we managed to create an

350
00:16:19,120 --> 00:16:21,700
SSH connection really over the cache so

351
00:16:21,700 --> 00:16:26,230
they don't have any network between

352
00:16:26,230 --> 00:16:28,660
between them but just we are sending the

353
00:16:28,660 --> 00:16:31,030
zeros and the ones and we have an SSH

354
00:16:31,030 --> 00:16:33,610
connection between them so you could say

355
00:16:33,610 --> 00:16:35,620
that cache cover channel and more things

356
00:16:35,620 --> 00:16:40,780
but I think it's a real threat and yeah

357
00:16:40,780 --> 00:16:42,490
if you want to have more details about

358
00:16:42,490 --> 00:16:45,430
this work in particular it will be

359
00:16:45,430 --> 00:16:49,960
published soon at the NGSS so the second

360
00:16:49,960 --> 00:16:52,420
application that we wanted to show you

361
00:16:52,420 --> 00:16:55,330
is that we can attack crypto with cache

362
00:16:55,330 --> 00:16:58,420
attacks so in particular we are going to

363
00:16:58,420 --> 00:16:58,800
show

364
00:16:58,800 --> 00:17:01,769
an attack on a yes and a special

365
00:17:01,769 --> 00:17:03,600
implementation of a yes that uses tea

366
00:17:03,600 --> 00:17:04,859
table so that's the first software

367
00:17:04,859 --> 00:17:07,380
implementation because it uses some pre

368
00:17:07,380 --> 00:17:11,699
computed look-up tables so it's known to

369
00:17:11,699 --> 00:17:14,209
be vulnerable to section attacks since

370
00:17:14,209 --> 00:17:17,250
2006 by us we get a land it's a

371
00:17:17,250 --> 00:17:19,109
one-round known plaintext attack so you

372
00:17:19,109 --> 00:17:21,750
have P or plaintext and K your secret

373
00:17:21,750 --> 00:17:25,800
key and the the AES algorithm what it

374
00:17:25,800 --> 00:17:27,540
does that is compute an intermediate

375
00:17:27,540 --> 00:17:30,570
State at each round R and on the first

376
00:17:30,570 --> 00:17:33,030
round the accessed table indices are

377
00:17:33,030 --> 00:17:38,340
just Peaks okay now it's a 1 it's a

378
00:17:38,340 --> 00:17:41,280
known plaintext attack what it means is

379
00:17:41,280 --> 00:17:43,440
that if you can recover the access table

380
00:17:43,440 --> 00:17:45,630
indices you've also managed to recover

381
00:17:45,630 --> 00:17:47,630
the key because it's just said so

382
00:17:47,630 --> 00:17:50,660
so that would be bad right if we could

383
00:17:50,660 --> 00:17:53,640
recover this access table and this is

384
00:17:53,640 --> 00:17:56,610
well we can with cache attack so we did

385
00:17:56,610 --> 00:17:58,290
that with flush and me load and with

386
00:17:58,290 --> 00:18:01,410
from and probe so on the x-axis you have

387
00:18:01,410 --> 00:18:04,080
the plaintext bite values and on the

388
00:18:04,080 --> 00:18:06,120
y-axis you have the addresses which are

389
00:18:06,120 --> 00:18:09,150
essentially which T table the T table

390
00:18:09,150 --> 00:18:13,590
entries so a black cell with means that

391
00:18:13,590 --> 00:18:16,440
we've monitored the cache line and we've

392
00:18:16,440 --> 00:18:18,720
seen a lot of cache hits so this

393
00:18:18,720 --> 00:18:21,540
basically the black-headed is to show we

394
00:18:21,540 --> 00:18:23,309
are that the T table entry has been

395
00:18:23,309 --> 00:18:27,090
accessed and here it's a toy example the

396
00:18:27,090 --> 00:18:30,350
keys all zeros but you would have

397
00:18:30,350 --> 00:18:32,550
basically just a different pattern if

398
00:18:32,550 --> 00:18:34,860
the key was not all zeros and as long as

399
00:18:34,860 --> 00:18:37,110
you can see this nice diagonal or a

400
00:18:37,110 --> 00:18:40,850
pattern then you have recovered the key

401
00:18:40,850 --> 00:18:44,640
so it's an old attack 2006 it's been 10

402
00:18:44,640 --> 00:18:45,320
years

403
00:18:45,320 --> 00:18:48,270
everything should be fixed I know and

404
00:18:48,270 --> 00:18:52,620
you see where I'm going it's not so on

405
00:18:52,620 --> 00:18:54,559
Android the bouncy castle and

406
00:18:54,559 --> 00:18:58,200
implementation it uses by default at the

407
00:18:58,200 --> 00:19:01,830
T table so that's bad and also many

408
00:19:01,830 --> 00:19:03,750
implementation that you can find online

409
00:19:03,750 --> 00:19:06,690
uses pre computed values so maybe be

410
00:19:06,690 --> 00:19:11,540
wary about this kind of attacks

411
00:19:11,760 --> 00:19:13,620
last application we wanted to show you

412
00:19:13,620 --> 00:19:18,150
is how we can spy on keystrokes so for

413
00:19:18,150 --> 00:19:19,530
that we will use flush and reload

414
00:19:19,530 --> 00:19:21,840
because it's a really fine cranes attack

415
00:19:21,840 --> 00:19:24,360
we can see very precisely which cache

416
00:19:24,360 --> 00:19:26,520
line has been accessed and a cache line

417
00:19:26,520 --> 00:19:29,070
is only 64 bytes so it's really not a

418
00:19:29,070 --> 00:19:31,350
lot and we're going to use that to spy

419
00:19:31,350 --> 00:19:33,990
on keystrokes and we even have a small

420
00:19:33,990 --> 00:19:42,180
demo for you so what you can see on the

421
00:19:42,180 --> 00:19:44,460
screen this is not on intellect 86 it's

422
00:19:44,460 --> 00:19:47,580
on a smart phone on the Galaxy s6 but

423
00:19:47,580 --> 00:19:49,380
you can also apply this Quecha text

424
00:19:49,380 --> 00:19:50,970
there so that's what we want to

425
00:19:50,970 --> 00:19:53,070
empathize so on the left you see the

426
00:19:53,070 --> 00:19:54,630
screen and on the right we have

427
00:19:54,630 --> 00:19:57,240
connected the shell with no privileges

428
00:19:57,240 --> 00:19:58,890
and permissions so it can basically be

429
00:19:58,890 --> 00:20:00,480
an app that you install from the App

430
00:20:00,480 --> 00:20:03,750
Store and on the right we are going to

431
00:20:03,750 --> 00:20:09,780
start our spy tool and on the Left we

432
00:20:09,780 --> 00:20:11,280
just opened the messenger app and

433
00:20:11,280 --> 00:20:14,130
whenever the user hits any key on the

434
00:20:14,130 --> 00:20:16,920
keyboard our spy tool takes care of that

435
00:20:16,920 --> 00:20:19,620
and notices that also if you press the

436
00:20:19,620 --> 00:20:23,880
spacebar we can also measure that if the

437
00:20:23,880 --> 00:20:25,860
user decides ok and want to delete the

438
00:20:25,860 --> 00:20:28,650
word because he changed his mind we can

439
00:20:28,650 --> 00:20:30,930
also register if the user press the

440
00:20:30,930 --> 00:20:34,110
backspace button so in the end we can

441
00:20:34,110 --> 00:20:37,410
see exactly how long the words where the

442
00:20:37,410 --> 00:20:40,860
user typed into his phone without any

443
00:20:40,860 --> 00:20:46,580
permissions and privileges which is bad

444
00:20:54,570 --> 00:20:57,930
so enough about the morph instruction

445
00:20:57,930 --> 00:21:02,400
let's head to seal flush so this seal

446
00:21:02,400 --> 00:21:05,310
fresh instruction what it does is that

447
00:21:05,310 --> 00:21:08,760
it it invalidates from every level the

448
00:21:08,760 --> 00:21:10,260
cache line that contains the address

449
00:21:10,260 --> 00:21:13,260
that you pass to this instruction so in

450
00:21:13,260 --> 00:21:15,150
itself it's kind of bad because it

451
00:21:15,150 --> 00:21:16,710
enables the production below the text

452
00:21:16,710 --> 00:21:18,060
that we showed earlier that was just

453
00:21:18,060 --> 00:21:21,090
flush reload and the flush part is done

454
00:21:21,090 --> 00:21:23,460
with cell flush but there's actually

455
00:21:23,460 --> 00:21:26,730
more to it how wonderful

456
00:21:26,730 --> 00:21:29,670
so there's a first time in leakage with

457
00:21:29,670 --> 00:21:32,040
it so we're going to see that the cell

458
00:21:32,040 --> 00:21:33,840
fetch instruction has a different timing

459
00:21:33,840 --> 00:21:36,780
depending on whether the data that you

460
00:21:36,780 --> 00:21:39,570
that you pass to be dis cached or not so

461
00:21:39,570 --> 00:21:42,090
imagine you have a cache line that is on

462
00:21:42,090 --> 00:21:45,300
the level 1 by include with the included

463
00:21:45,300 --> 00:21:47,430
property it has to be also in the last

464
00:21:47,430 --> 00:21:50,880
level cache now this is quite convenient

465
00:21:50,880 --> 00:21:53,160
and this is also why we have this

466
00:21:53,160 --> 00:21:54,900
inclusion property for performance

467
00:21:54,900 --> 00:21:58,020
reason on Intel CPUs if you want to see

468
00:21:58,020 --> 00:22:00,330
if a line is present at all in the cache

469
00:22:00,330 --> 00:22:02,490
you just have to look in the last level

470
00:22:02,490 --> 00:22:04,650
cache so this is basically what the seal

471
00:22:04,650 --> 00:22:06,210
flush instruction does it goes to say

472
00:22:06,210 --> 00:22:08,250
last well character sees ok there's a

473
00:22:08,250 --> 00:22:10,880
line I'm going to flush this one and

474
00:22:10,880 --> 00:22:13,290
then there's something that tells ok the

475
00:22:13,290 --> 00:22:16,020
line is also prisons somewhere else so

476
00:22:16,020 --> 00:22:18,750
then it flushes the line in another one

477
00:22:18,750 --> 00:22:24,090
and all of it so that's low now if you

478
00:22:24,090 --> 00:22:25,920
perform self flush from some data that

479
00:22:25,920 --> 00:22:29,400
is not cached basically it does the same

480
00:22:29,400 --> 00:22:32,040
goes to the last level cache see that

481
00:22:32,040 --> 00:22:33,930
there's no line and they can't be any

482
00:22:33,930 --> 00:22:36,360
this data can't be anywhere else in the

483
00:22:36,360 --> 00:22:37,770
cache because it would be in the last

484
00:22:37,770 --> 00:22:41,010
level cache if it was anywhere so it

485
00:22:41,010 --> 00:22:42,480
does nothing I need stop there

486
00:22:42,480 --> 00:22:45,570
so that's fast so how exactly

487
00:22:45,570 --> 00:22:49,020
fast and slow am I talking about so it's

488
00:22:49,020 --> 00:22:51,720
actually only a very few cycles so we

489
00:22:51,720 --> 00:22:54,200
did this experiments on different

490
00:22:54,200 --> 00:22:57,090
microarchitecture so Center bridge Ivy

491
00:22:57,090 --> 00:23:00,210
Bridge and Haswell and so it different

492
00:23:00,210 --> 00:23:01,310
colors correspond to the different

493
00:23:01,310 --> 00:23:03,360
microarchitecture so a first thing that

494
00:23:03,360 --> 00:23:04,920
is already

495
00:23:04,920 --> 00:23:07,020
can often is that you can see that you

496
00:23:07,020 --> 00:23:08,610
can distinguish the micro architecture

497
00:23:08,610 --> 00:23:13,410
quite and nicely with this but the real

498
00:23:13,410 --> 00:23:14,970
point is that you have really a

499
00:23:14,970 --> 00:23:18,750
different zone the solids the solid line

500
00:23:18,750 --> 00:23:20,810
is when we performed the measurement on

501
00:23:20,810 --> 00:23:23,160
seal flush with the line that was

502
00:23:23,160 --> 00:23:25,380
already in the cache and the dashed line

503
00:23:25,380 --> 00:23:27,630
is when the line was not in the cache

504
00:23:27,630 --> 00:23:30,870
and in all microarchitectures you can

505
00:23:30,870 --> 00:23:32,580
see that we can see a difference it's

506
00:23:32,580 --> 00:23:35,450
only a few cycles it's a bit noisy

507
00:23:35,450 --> 00:23:40,580
so what could go wrong okay so

508
00:23:40,580 --> 00:23:42,900
exploiting these few cycles we still

509
00:23:42,900 --> 00:23:44,430
managed to perform a new cache attacks

510
00:23:44,430 --> 00:23:46,350
that we call flash and flash so I'm

511
00:23:46,350 --> 00:23:48,960
going to explain that to you so

512
00:23:48,960 --> 00:23:50,280
basically everything that we could do

513
00:23:50,280 --> 00:23:52,710
with Russian reload we can also do with

514
00:23:52,710 --> 00:23:54,720
flash and flash we can perform color

515
00:23:54,720 --> 00:23:58,170
channels and cybernetics is healthier

516
00:23:58,170 --> 00:24:00,030
than previous cache attacks I'm going to

517
00:24:00,030 --> 00:24:02,340
go back on this one and it's also faster

518
00:24:02,340 --> 00:24:04,680
than previous cache attacks so how does

519
00:24:04,680 --> 00:24:08,400
it work exactly so the principle is a

520
00:24:08,400 --> 00:24:10,800
bit similar to Russian Windows so we

521
00:24:10,800 --> 00:24:13,200
have the attacker and the victim that

522
00:24:13,200 --> 00:24:15,000
have some kind of shell memory let's say

523
00:24:15,000 --> 00:24:17,670
it's your library it will be shared in

524
00:24:17,670 --> 00:24:20,430
the cache Derek I'll start by flushing

525
00:24:20,430 --> 00:24:23,550
the cache line then let's the victim

526
00:24:23,550 --> 00:24:25,860
perform whatever it tells its encryption

527
00:24:25,860 --> 00:24:28,890
the victim will load some data into the

528
00:24:28,890 --> 00:24:32,100
cache automatically and now the attacker

529
00:24:32,100 --> 00:24:33,720
wants to know again if the victim

530
00:24:33,720 --> 00:24:35,700
accessed this precise cache line and

531
00:24:35,700 --> 00:24:38,550
instead of reloading it is going to

532
00:24:38,550 --> 00:24:42,090
flush it again and since we have this

533
00:24:42,090 --> 00:24:44,580
timing difference depending on whether

534
00:24:44,580 --> 00:24:46,530
the data is in the cache or not it give

535
00:24:46,530 --> 00:24:48,480
us the same information as if we be

536
00:24:48,480 --> 00:24:53,880
loaded it except it's way faster so I

537
00:24:53,880 --> 00:24:57,060
talked about stealthiness so the thing

538
00:24:57,060 --> 00:24:58,740
is that basically these cache attacks

539
00:24:58,740 --> 00:25:02,970
and that also applies to rohana there

540
00:25:02,970 --> 00:25:04,050
are already stealth

541
00:25:04,050 --> 00:25:06,570
in themselves because there's no

542
00:25:06,570 --> 00:25:08,880
antivirus today that can detect them but

543
00:25:08,880 --> 00:25:11,040
some people thought that we could detect

544
00:25:11,040 --> 00:25:13,560
them with performance counters because

545
00:25:13,560 --> 00:25:15,120
they do a lot of cache misses and cache

546
00:25:15,120 --> 00:25:17,309
references that happened when the day

547
00:25:17,309 --> 00:25:21,779
first and when you reacts s memory now

548
00:25:21,779 --> 00:25:23,700
what we thought is that yeah but that

549
00:25:23,700 --> 00:25:28,200
also not the only program steps to lots

550
00:25:28,200 --> 00:25:30,330
of cache misses and cache references so

551
00:25:30,330 --> 00:25:31,940
we would like to have a slightly

552
00:25:31,940 --> 00:25:35,759
parametric so these cache attacks they

553
00:25:35,759 --> 00:25:38,659
have a very heavy activity on the cache

554
00:25:38,659 --> 00:25:41,009
but they're also very particular because

555
00:25:41,009 --> 00:25:44,070
there are very short loops of code if

556
00:25:44,070 --> 00:25:45,539
you take flush and we know this just

557
00:25:45,539 --> 00:25:48,600
flush one line we load the line and then

558
00:25:48,600 --> 00:25:51,509
again fresh load that's very short loop

559
00:25:51,509 --> 00:25:53,669
and that creates a very low pressure on

560
00:25:53,669 --> 00:25:56,490
the instruction therapy which is kind of

561
00:25:56,490 --> 00:26:01,259
particular for of cache attacks so what

562
00:26:01,259 --> 00:26:03,480
we decided to do is normalizing the

563
00:26:03,480 --> 00:26:05,399
cache even so the cache misses and calf

564
00:26:05,399 --> 00:26:07,679
references by events that have to do

565
00:26:07,679 --> 00:26:10,559
with the instruction TLB and there we

566
00:26:10,559 --> 00:26:14,249
could manage to detect cache attacks and

567
00:26:14,249 --> 00:26:18,529
rahama without having false positives so

568
00:26:18,529 --> 00:26:20,669
the system a trick that I'm going to use

569
00:26:20,669 --> 00:26:24,450
when I talk about scariness so we

570
00:26:24,450 --> 00:26:26,639
started by creating a cover channel

571
00:26:26,639 --> 00:26:29,279
first we wanted to have it as fast as

572
00:26:29,279 --> 00:26:32,669
possible so we created a protocol to

573
00:26:32,669 --> 00:26:35,610
evaluates all the kind of cache attack

574
00:26:35,610 --> 00:26:37,470
that we had so flash and flash flash and

575
00:26:37,470 --> 00:26:40,350
we know then from a probe and we started

576
00:26:40,350 --> 00:26:42,809
with a packet side of 28 doesn't really

577
00:26:42,809 --> 00:26:46,320
matter we measured the capacity of our

578
00:26:46,320 --> 00:26:48,749
cover channel and flash and flash is

579
00:26:48,749 --> 00:26:51,840
around 500 kilobytes per second whereas

580
00:26:51,840 --> 00:26:54,210
Russian world was only 300 kilobytes per

581
00:26:54,210 --> 00:26:56,039
second so fresh and fresh is already

582
00:26:56,039 --> 00:26:58,769
quite an improvement on the speed then

583
00:26:58,769 --> 00:27:01,049
we measured this dead zone at this speed

584
00:27:01,049 --> 00:27:04,559
only fresh and fresh worst else and now

585
00:27:04,559 --> 00:27:05,789
the thing is that flash and flash and

586
00:27:05,789 --> 00:27:07,710
flash and reload as you've seen there

587
00:27:07,710 --> 00:27:09,869
are some similarities so for a cover

588
00:27:09,869 --> 00:27:11,460
channel they also share the same center

589
00:27:11,460 --> 00:27:14,129
on it is receivers different and for

590
00:27:14,129 --> 00:27:16,470
this one the center was not stills for

591
00:27:16,470 --> 00:27:19,379
both of them anyway if you want a fast

592
00:27:19,379 --> 00:27:21,600
cover channel then just while frozen

593
00:27:21,600 --> 00:27:26,429
flash that works now let's try to make

594
00:27:26,429 --> 00:27:28,169
it stealthy completely still see because

595
00:27:28,169 --> 00:27:29,460
if I have the standard that is not

596
00:27:29,460 --> 00:27:30,840
stance maybe that we give

597
00:27:30,840 --> 00:27:33,539
the whole attack so we said okay maybe

598
00:27:33,539 --> 00:27:35,909
if we just load down all the attacks

599
00:27:35,909 --> 00:27:38,820
then there will be less cash cash sheets

600
00:27:38,820 --> 00:27:41,279
cache misses and then maybe all the

601
00:27:41,279 --> 00:27:43,259
attacks are actually still see why not

602
00:27:43,259 --> 00:27:46,620
so we tried that we slowed down

603
00:27:46,620 --> 00:27:48,990
everything so flush a middle new flash

604
00:27:48,990 --> 00:27:51,899
and flash are around 50 kilo byte per

605
00:27:51,899 --> 00:27:54,059
seconds now from em probe is a bit

606
00:27:54,059 --> 00:27:55,999
slower because it takes more time to

607
00:27:55,999 --> 00:28:02,730
drum anything but still even with this

608
00:28:02,730 --> 00:28:05,700
slow down on me flash and flash has its

609
00:28:05,700 --> 00:28:09,720
receiver stealth and we also managed to

610
00:28:09,720 --> 00:28:12,929
have the sender cells now so basically

611
00:28:12,929 --> 00:28:14,940
whether you want a fast cover channel or

612
00:28:14,940 --> 00:28:17,369
a stylus cover channel flash and flash

613
00:28:17,369 --> 00:28:19,490
is really great

614
00:28:19,490 --> 00:28:22,950
now we wanted to also evaluate if it

615
00:28:22,950 --> 00:28:26,700
wasn't too noisy to perform some section

616
00:28:26,700 --> 00:28:28,980
attack so we did these side channels on

617
00:28:28,980 --> 00:28:31,259
the AES t-table implementation the

618
00:28:31,259 --> 00:28:33,379
attacks that have shown you earlier

619
00:28:33,379 --> 00:28:36,450
so we computed a lot of encryption that

620
00:28:36,450 --> 00:28:38,580
we needed to determine the upper four

621
00:28:38,580 --> 00:28:41,610
bits of a key bytes so here the lower

622
00:28:41,610 --> 00:28:45,269
the better the attack and flash and

623
00:28:45,269 --> 00:28:47,340
reload is a bit better so we need only

624
00:28:47,340 --> 00:28:50,309
250 encryptions to recover these bits

625
00:28:50,309 --> 00:28:54,629
but flash and flash comes what comes

626
00:28:54,629 --> 00:28:57,960
quite close with 350 and from a probe is

627
00:28:57,960 --> 00:28:59,580
actually the most noisy of them all

628
00:28:59,580 --> 00:29:05,039
needs 5 close to 5000 encryptions so we

629
00:29:05,039 --> 00:29:06,330
have around the same performance for

630
00:29:06,330 --> 00:29:09,590
thrush and flourish and flush envelopes

631
00:29:09,710 --> 00:29:11,970
now let's evaluate the stealthiness

632
00:29:11,970 --> 00:29:16,580
again so what we did here is we perform

633
00:29:16,580 --> 00:29:19,379
256 billion encryptions in a synchronous

634
00:29:19,379 --> 00:29:22,740
attack so we really had the spy and the

635
00:29:22,740 --> 00:29:25,799
victim scattered and we evaluated the

636
00:29:25,799 --> 00:29:28,049
status of them all and here only fresh

637
00:29:28,049 --> 00:29:28,830
and fresh again

638
00:29:28,830 --> 00:29:32,429
Estelle's and while you can always load

639
00:29:32,429 --> 00:29:34,619
on a cover channel you actually

640
00:29:34,619 --> 00:29:35,970
constantly slow down a side channel

641
00:29:35,970 --> 00:29:37,889
because in a real life scenario you're

642
00:29:37,889 --> 00:29:40,679
not going to say hey picked him who wait

643
00:29:40,679 --> 00:29:43,680
for me a bit trying to do an attack here

644
00:29:43,680 --> 00:29:48,400
that won't work so that's even more to

645
00:29:48,400 --> 00:29:50,170
it but I will is again a bit of

646
00:29:50,170 --> 00:29:54,130
background before continuing so I've

647
00:29:54,130 --> 00:29:55,900
shown you the different levels of caches

648
00:29:55,900 --> 00:29:58,330
and here I'm going to focus more on the

649
00:29:58,330 --> 00:30:02,320
last level cache so we have here our

650
00:30:02,320 --> 00:30:04,870
four slices so this is the last level

651
00:30:04,870 --> 00:30:08,800
cache and we have some bits of the

652
00:30:08,800 --> 00:30:10,950
address here that corresponds to the set

653
00:30:10,950 --> 00:30:13,600
but more importantly we need to know

654
00:30:13,600 --> 00:30:16,120
where in which lies and address is going

655
00:30:16,120 --> 00:30:18,930
to be and that is given that is given by

656
00:30:18,930 --> 00:30:21,610
some bits of the set and the type of the

657
00:30:21,610 --> 00:30:23,290
address that are passing to a heart

658
00:30:23,290 --> 00:30:26,140
function that says in which slice the

659
00:30:26,140 --> 00:30:28,360
line is going to be now the thing is

660
00:30:28,360 --> 00:30:29,950
that this hash function is undocumented

661
00:30:29,950 --> 00:30:30,820
by Intel

662
00:30:30,820 --> 00:30:35,590
we don't be fun otherwise so we have

663
00:30:35,590 --> 00:30:38,740
this as many spaces as core undocumented

664
00:30:38,740 --> 00:30:40,300
hash function that map's a physical

665
00:30:40,300 --> 00:30:42,820
address to a slice and while it's

666
00:30:42,820 --> 00:30:45,130
actually a bit of a pain for attacks it

667
00:30:45,130 --> 00:30:47,220
has it was not designed for security

668
00:30:47,220 --> 00:30:49,570
originally but for performance because

669
00:30:49,570 --> 00:30:51,760
you want all the access to be evenly

670
00:30:51,760 --> 00:30:55,720
distributed in the different slices for

671
00:30:55,720 --> 00:30:58,330
performance reasons so the heart

672
00:30:58,330 --> 00:31:00,760
function basically does it take some

673
00:31:00,760 --> 00:31:02,890
bits of the physical address and output

674
00:31:02,890 --> 00:31:06,550
K bits of slice so just one bits if you

675
00:31:06,550 --> 00:31:08,290
have a Tuco machine two bits if you have

676
00:31:08,290 --> 00:31:11,620
a for conversion and so on now let's go

677
00:31:11,620 --> 00:31:14,890
back to with CLR see what's the relation

678
00:31:14,890 --> 00:31:17,770
with that so the thing that we noticed

679
00:31:17,770 --> 00:31:19,660
is that still flesh is actually faster

680
00:31:19,660 --> 00:31:24,040
to reach a line on the local slice so if

681
00:31:24,040 --> 00:31:28,570
you have if you're flushing always one

682
00:31:28,570 --> 00:31:31,270
line and you run your program on call

683
00:31:31,270 --> 00:31:33,610
Sirocco one cut Winco three you will

684
00:31:33,610 --> 00:31:36,940
observe that one call in particular on

685
00:31:36,940 --> 00:31:38,920
when you run the program on one core the

686
00:31:38,920 --> 00:31:42,400
still flush is faster and so here this

687
00:31:42,400 --> 00:31:44,920
is on cold one and you can see that call

688
00:31:44,920 --> 00:31:47,980
zero two and three it's it's a bit

689
00:31:47,980 --> 00:31:51,460
slower and here we can deduce that so we

690
00:31:51,460 --> 00:31:53,410
run the program on call 1 and we first

691
00:31:53,410 --> 00:31:55,420
always the same line and we can deduce

692
00:31:55,420 --> 00:31:56,870
that the line belong to

693
00:31:56,870 --> 00:32:01,520
is one and what we can do with that is

694
00:32:01,520 --> 00:32:03,890
that we can map physical address slices

695
00:32:03,890 --> 00:32:06,320
and that's one way to reverse engineer

696
00:32:06,320 --> 00:32:08,180
this addressing function that was not

697
00:32:08,180 --> 00:32:12,890
documented funnily enough that's not the

698
00:32:12,890 --> 00:32:15,320
only way what I did before that was

699
00:32:15,320 --> 00:32:17,960
using the performance counters to

700
00:32:17,960 --> 00:32:20,120
reverse engineer this dysfunction but

701
00:32:20,120 --> 00:32:22,070
that's actually a whole other story and

702
00:32:22,070 --> 00:32:23,450
if you want more detail on that

703
00:32:23,450 --> 00:32:28,880
there's also another code on that so the

704
00:32:28,880 --> 00:32:30,500
next instruction we want to talk about

705
00:32:30,500 --> 00:32:33,559
is the prefetch instruction and the

706
00:32:33,559 --> 00:32:35,450
prefetch instruction is used to tell the

707
00:32:35,450 --> 00:32:38,570
CPU okay please load the data and it

708
00:32:38,570 --> 00:32:41,240
later on into the cache if you have some

709
00:32:41,240 --> 00:32:44,330
time and in the end there are actually

710
00:32:44,330 --> 00:32:47,330
six different prefetch instructions we

711
00:32:47,330 --> 00:32:51,500
fetched is 0 2 T 2 which means CPU

712
00:32:51,500 --> 00:32:53,210
please load the data into the first

713
00:32:53,210 --> 00:32:55,070
level cache or in the last level cache

714
00:32:55,070 --> 00:32:58,910
whatever you want to use but we spare

715
00:32:58,910 --> 00:33:00,679
you the details because it's not so

716
00:33:00,679 --> 00:33:02,960
interesting in the end however what's

717
00:33:02,960 --> 00:33:04,820
more interesting is when we take a look

718
00:33:04,820 --> 00:33:07,460
at the engine manual and what it says

719
00:33:07,460 --> 00:33:10,700
there so using the prefetch instruction

720
00:33:10,700 --> 00:33:13,040
is recommended only if data does not fit

721
00:33:13,040 --> 00:33:15,260
in the cache so you can tell the CPU

722
00:33:15,260 --> 00:33:18,380
please load data I want to stream into

723
00:33:18,380 --> 00:33:22,100
the cache so it's more performant use of

724
00:33:22,100 --> 00:33:24,200
software prefetch should be limited to

725
00:33:24,200 --> 00:33:26,480
memory addresses that are managed or

726
00:33:26,480 --> 00:33:30,260
owned within the application context so

727
00:33:30,260 --> 00:33:33,590
one might wonder what happens if this

728
00:33:33,590 --> 00:33:36,490
address is not managed by myself

729
00:33:36,490 --> 00:33:40,400
sounds interesting prefetching two

730
00:33:40,400 --> 00:33:42,230
addresses that are not mapped to

731
00:33:42,230 --> 00:33:44,350
physical pages can experience

732
00:33:44,350 --> 00:33:46,900
non-deterministic performance penalty

733
00:33:46,900 --> 00:33:50,360
for example specifying a null pointer as

734
00:33:50,360 --> 00:33:52,640
an address for prefetch can cause long

735
00:33:52,640 --> 00:33:55,340
delays so we don't want to do that

736
00:33:55,340 --> 00:33:58,750
because our program will be slow so

737
00:33:58,750 --> 00:34:01,910
let's take a look what they mean with

738
00:34:01,910 --> 00:34:04,360
non-deterministic performance penalty

739
00:34:04,360 --> 00:34:06,650
because we want to write good software

740
00:34:06,650 --> 00:34:09,630
right but before that

741
00:34:09,630 --> 00:34:11,070
we have to take a look at a little bit

742
00:34:11,070 --> 00:34:12,540
more background information to

743
00:34:12,540 --> 00:34:15,420
understand the attacks so on modern

744
00:34:15,420 --> 00:34:18,420
operating systems every application has

745
00:34:18,420 --> 00:34:21,570
its own virtual address space so at some

746
00:34:21,570 --> 00:34:23,670
point the CPU needs to translate these

747
00:34:23,670 --> 00:34:25,679
addresses to the physical addresses

748
00:34:25,679 --> 00:34:28,320
actually in the DRAM and for that we

749
00:34:28,320 --> 00:34:30,239
have this very complex looking data

750
00:34:30,239 --> 00:34:34,139
structure so we have a 48-bit virtual

751
00:34:34,139 --> 00:34:37,530
address and some of those bits mapped to

752
00:34:37,530 --> 00:34:41,250
a table like the vm level 4 table with

753
00:34:41,250 --> 00:34:44,659
512 entries so depending on those bits

754
00:34:44,659 --> 00:34:48,179
disappear knows at which line he has to

755
00:34:48,179 --> 00:34:51,330
look and if there is data there because

756
00:34:51,330 --> 00:34:53,850
the address is mapped he can proceed and

757
00:34:53,850 --> 00:34:56,190
look at the page directory point the

758
00:34:56,190 --> 00:35:00,380
table and so on for the town so is

759
00:35:00,380 --> 00:35:03,240
everything is the same for each level

760
00:35:03,240 --> 00:35:06,090
until you come to your page table where

761
00:35:06,090 --> 00:35:08,610
you have 4 kilobyte pages so it's in the

762
00:35:08,610 --> 00:35:12,240
end not that complicated but it's a bit

763
00:35:12,240 --> 00:35:13,800
confusing because you want to know a

764
00:35:13,800 --> 00:35:16,560
physical address so you have to look it

765
00:35:16,560 --> 00:35:20,130
up somewhere in the in the main memory

766
00:35:20,130 --> 00:35:22,320
with physical addresses to translate

767
00:35:22,320 --> 00:35:24,420
your virtual addresses and if you have

768
00:35:24,420 --> 00:35:27,540
to go through all those levels it needs

769
00:35:27,540 --> 00:35:31,080
a long time so we can do better than

770
00:35:31,080 --> 00:35:33,120
that and that's why int'l introduced

771
00:35:33,120 --> 00:35:36,390
additional caches also for all of those

772
00:35:36,390 --> 00:35:41,100
levels so if you want student translate

773
00:35:41,100 --> 00:35:44,010
an address you take a look at the itlp

774
00:35:44,010 --> 00:35:46,320
and for instructions and the data TLB

775
00:35:46,320 --> 00:35:49,080
for data if it's there you can stop

776
00:35:49,080 --> 00:35:51,570
otherwise you go down all those levels

777
00:35:51,570 --> 00:35:54,150
and if it's not in any cache you have to

778
00:35:54,150 --> 00:36:00,060
look it up in the DRAM in addition the

779
00:36:00,060 --> 00:36:02,310
address space you have is shared because

780
00:36:02,310 --> 00:36:03,840
you have on the one hand the user memory

781
00:36:03,840 --> 00:36:05,820
and the other hand you have mapped the

782
00:36:05,820 --> 00:36:07,880
kernel for convenience and performance

783
00:36:07,880 --> 00:36:11,220
also in the address space and if your

784
00:36:11,220 --> 00:36:13,410
user program wants to access some kernel

785
00:36:13,410 --> 00:36:15,960
functionality like reading a file it

786
00:36:15,960 --> 00:36:18,510
will switch to the kernel memory there's

787
00:36:18,510 --> 00:36:20,490
a privilege escalation and then you can

788
00:36:20,490 --> 00:36:22,090
read the file

789
00:36:22,090 --> 00:36:26,380
is wrong so that's it however you have

790
00:36:26,380 --> 00:36:29,380
drivers in the kernel and if you know

791
00:36:29,380 --> 00:36:31,540
the addresses of those drivers you can

792
00:36:31,540 --> 00:36:34,270
do code reuse at accent as a

793
00:36:34,270 --> 00:36:37,060
countermeasure they introduced address

794
00:36:37,060 --> 00:36:39,340
space layout randomization also for the

795
00:36:39,340 --> 00:36:43,300
kernel and this means that when you have

796
00:36:43,300 --> 00:36:45,940
your program running the kernel is

797
00:36:45,940 --> 00:36:48,790
mapped at one address and if you reboot

798
00:36:48,790 --> 00:36:50,950
the machine it's not on the same address

799
00:36:50,950 --> 00:36:54,490
anymore but somewhere else so if there

800
00:36:54,490 --> 00:36:57,370
is a way to find out at which address

801
00:36:57,370 --> 00:36:59,950
the kernel is loaded you have

802
00:36:59,950 --> 00:37:02,310
circumvented this countermeasure and

803
00:37:02,310 --> 00:37:04,720
defeated kernel address space layout

804
00:37:04,720 --> 00:37:06,880
randomization so this would be nice for

805
00:37:06,880 --> 00:37:11,590
some attacks in addition there's also

806
00:37:11,590 --> 00:37:15,190
the kernel direct physical map and what

807
00:37:15,190 --> 00:37:15,940
does this mean

808
00:37:15,940 --> 00:37:19,030
so it's implemented on many operating

809
00:37:19,030 --> 00:37:22,360
systems like OS X Linux also on X n

810
00:37:22,360 --> 00:37:25,300
hypervisor and PSD but not on Windows

811
00:37:25,300 --> 00:37:29,680
but what it means is that the complete

812
00:37:29,680 --> 00:37:32,320
physical memory is mapped in

813
00:37:32,320 --> 00:37:34,780
additionally in the kernel memory at the

814
00:37:34,780 --> 00:37:38,770
fixed offset so for every page that is

815
00:37:38,770 --> 00:37:40,900
map in the user space there's something

816
00:37:40,900 --> 00:37:43,330
like a twin page in the kernel memory

817
00:37:43,330 --> 00:37:45,820
which you can't access because it's in

818
00:37:45,820 --> 00:37:48,850
the kernel memory however we will need

819
00:37:48,850 --> 00:37:51,490
it later because now we go back to

820
00:37:51,490 --> 00:37:53,770
prefetch and see what we can do with

821
00:37:53,770 --> 00:37:58,510
that so prefetch is not a usual

822
00:37:58,510 --> 00:38:00,940
instruction because it just tells the

823
00:38:00,940 --> 00:38:03,880
CPU I might need that data later on if

824
00:38:03,880 --> 00:38:08,140
you have time loaded for me if not the

825
00:38:08,140 --> 00:38:10,210
CPU can ignore it because it's busy with

826
00:38:10,210 --> 00:38:13,360
other stuff so there's no necessity that

827
00:38:13,360 --> 00:38:15,820
this instruction is really executed but

828
00:38:15,820 --> 00:38:19,570
most of the time it is and a nice

829
00:38:19,570 --> 00:38:21,520
interesting thing is that it generates

830
00:38:21,520 --> 00:38:24,670
no false so whatever you pass to this

831
00:38:24,670 --> 00:38:28,120
instruction your program won't crash and

832
00:38:28,120 --> 00:38:30,910
it does not check any privileges so I

833
00:38:30,910 --> 00:38:33,460
can also pass and kernel address to it

834
00:38:33,460 --> 00:38:35,719
and it won't say now stop the X

835
00:38:35,719 --> 00:38:37,219
an address that you are not allowed to

836
00:38:37,219 --> 00:38:40,779
access so I crash it just continues

837
00:38:40,779 --> 00:38:46,190
which is nice the second interesting

838
00:38:46,190 --> 00:38:48,199
thing is that the operand is a virtual

839
00:38:48,199 --> 00:38:51,049
address so every time you execute this

840
00:38:51,049 --> 00:38:54,019
instruction the CPU has to go and check

841
00:38:54,019 --> 00:38:56,599
ok what physical address does this

842
00:38:56,599 --> 00:38:58,940
virtual address correspond to so it has

843
00:38:58,940 --> 00:39:00,349
to do the look up with all those tables

844
00:39:00,349 --> 00:39:04,249
we've seen earlier and as you probably

845
00:39:04,249 --> 00:39:06,529
have guessed already the execution time

846
00:39:06,529 --> 00:39:08,479
various also for the prefetch

847
00:39:08,479 --> 00:39:10,609
instruction and we will see later on

848
00:39:10,609 --> 00:39:14,180
what we can do with that so let's get

849
00:39:14,180 --> 00:39:17,569
back to the direct physical match map

850
00:39:17,569 --> 00:39:20,390
because we can create an Oracle for

851
00:39:20,390 --> 00:39:22,369
address translation so we can find out

852
00:39:22,369 --> 00:39:25,039
what physical address belongs to the

853
00:39:25,039 --> 00:39:27,199
virtual address because nowadays you

854
00:39:27,199 --> 00:39:29,209
don't want that the user to know because

855
00:39:29,209 --> 00:39:31,969
you can craft nice row hema attacks with

856
00:39:31,969 --> 00:39:34,940
that information and more advanced cache

857
00:39:34,940 --> 00:39:37,519
attacks so you restrict this information

858
00:39:37,519 --> 00:39:40,670
to the user but let's check if we find a

859
00:39:40,670 --> 00:39:43,940
way to still get this information so as

860
00:39:43,940 --> 00:39:48,199
I've told you earlier if you have a pet

861
00:39:48,199 --> 00:39:51,140
page in the user space map you have the

862
00:39:51,140 --> 00:39:53,779
twin page in the kernel space and if

863
00:39:53,779 --> 00:39:55,910
it's cached its cached for both of them

864
00:39:55,910 --> 00:39:59,119
again so the attack now works as the

865
00:39:59,119 --> 00:40:02,029
following from the attacker you flush

866
00:40:02,029 --> 00:40:05,660
your user space page so it's not in the

867
00:40:05,660 --> 00:40:07,849
cache for the also for the kernel memory

868
00:40:07,849 --> 00:40:12,319
and then you called prefetch on the

869
00:40:12,319 --> 00:40:14,749
address of the kernel because as I told

870
00:40:14,749 --> 00:40:17,209
you you still can do that because it

871
00:40:17,209 --> 00:40:21,499
doesn't create any faults so you tell

872
00:40:21,499 --> 00:40:23,749
the CPU please load me this data into

873
00:40:23,749 --> 00:40:27,440
the cache even if I don't have access to

874
00:40:27,440 --> 00:40:30,589
this data normally and if we now measure

875
00:40:30,589 --> 00:40:33,589
on our user space page the address again

876
00:40:33,589 --> 00:40:36,170
and we measure a cache hit because it

877
00:40:36,170 --> 00:40:38,269
has been loaded by the CPU into the

878
00:40:38,269 --> 00:40:41,569
cache we know exactly at which position

879
00:40:41,569 --> 00:40:43,579
since we passed the address to the

880
00:40:43,579 --> 00:40:47,299
function this address corresponds to and

881
00:40:47,299 --> 00:40:48,880
because this is at a fixed or

882
00:40:48,880 --> 00:40:50,890
set we can just do a simple subtraction

883
00:40:50,890 --> 00:40:53,950
and know the physically address again so

884
00:40:53,950 --> 00:40:57,070
we have a nice way to find physical

885
00:40:57,070 --> 00:40:59,380
addresses for virtual addresses and in

886
00:40:59,380 --> 00:41:01,750
practice this looks like this following

887
00:41:01,750 --> 00:41:04,570
plot so it's pretty simple because we

888
00:41:04,570 --> 00:41:07,060
just do this for every address and at

889
00:41:07,060 --> 00:41:09,100
some point we measure a cache hit so

890
00:41:09,100 --> 00:41:11,950
there's a huge difference and exactly at

891
00:41:11,950 --> 00:41:14,370
this point we know this physical address

892
00:41:14,370 --> 00:41:18,940
corresponds to our virtual address the

893
00:41:18,940 --> 00:41:21,160
second thing is that we can exploit the

894
00:41:21,160 --> 00:41:23,710
timing differences it needs for the

895
00:41:23,710 --> 00:41:27,340
prefetch instruction because as I told

896
00:41:27,340 --> 00:41:29,680
you when you go down this cache levels

897
00:41:29,680 --> 00:41:32,020
at some point you see it's here or it's

898
00:41:32,020 --> 00:41:35,230
not here so it can abort early and with

899
00:41:35,230 --> 00:41:37,690
that we can know exactly when the

900
00:41:37,690 --> 00:41:40,090
prefetch instruction reported and know

901
00:41:40,090 --> 00:41:43,090
how the pages are mapped into the

902
00:41:43,090 --> 00:41:47,770
address space so the timing depends on

903
00:41:47,770 --> 00:41:53,650
where the translation stops and using

904
00:41:53,650 --> 00:41:55,530
those two properties and tells

905
00:41:55,530 --> 00:41:57,940
information we can do the following on

906
00:41:57,940 --> 00:42:00,700
the one hand we can build variants of

907
00:42:00,700 --> 00:42:02,890
cache attacks so instead of flash and

908
00:42:02,890 --> 00:42:05,200
reload we can do for our flash and

909
00:42:05,200 --> 00:42:07,780
prefetch for instance we can also use

910
00:42:07,780 --> 00:42:09,910
prefetch - montreux Hema attacks on

911
00:42:09,910 --> 00:42:12,400
privileged addresses because it doesn't

912
00:42:12,400 --> 00:42:14,260
do any faults when we passed those

913
00:42:14,260 --> 00:42:17,890
addresses and it works as well in

914
00:42:17,890 --> 00:42:20,710
addition we can use it to recover the

915
00:42:20,710 --> 00:42:23,170
translation levels of a process which

916
00:42:23,170 --> 00:42:25,090
you could do earlier with the page map

917
00:42:25,090 --> 00:42:27,040
file but as I told you it's now

918
00:42:27,040 --> 00:42:28,810
privileged so you don't have access to

919
00:42:28,810 --> 00:42:32,020
that and by doing that you can by bus

920
00:42:32,020 --> 00:42:35,080
address space layout randomization in

921
00:42:35,080 --> 00:42:37,720
addition as I told you you can translate

922
00:42:37,720 --> 00:42:39,610
virtual addresses to physical addresses

923
00:42:39,610 --> 00:42:42,820
which is now also privileged with the

924
00:42:42,820 --> 00:42:45,550
page map file and using that it rien a

925
00:42:45,550 --> 00:42:48,040
Buhl's return to direct exploits which

926
00:42:48,040 --> 00:42:52,150
have been demonstrated last year on top

927
00:42:52,150 --> 00:42:54,580
of that we can also use this to locate

928
00:42:54,580 --> 00:42:56,590
kernel drivers as I told you it would be

929
00:42:56,590 --> 00:43:00,190
nice if we can circumvent KS lr as well

930
00:43:00,190 --> 00:43:02,130
and I will show you now how

931
00:43:02,130 --> 00:43:06,569
as possible so with the first Oracle we

932
00:43:06,569 --> 00:43:09,390
find out all the pages that are mapped

933
00:43:09,390 --> 00:43:14,670
and for each of those pages we evict the

934
00:43:14,670 --> 00:43:16,950
translation caches and we can do that by

935
00:43:16,950 --> 00:43:18,839
either calling sleep which schedules

936
00:43:18,839 --> 00:43:21,599
another program or access just a large

937
00:43:21,599 --> 00:43:25,109
memory buffer then we perform a sis call

938
00:43:25,109 --> 00:43:27,119
to the driver so there's code of the

939
00:43:27,119 --> 00:43:28,950
driver executed and loaded into the

940
00:43:28,950 --> 00:43:31,559
cache and then we just measured the time

941
00:43:31,559 --> 00:43:35,759
prefetch takes on this address and in

942
00:43:35,759 --> 00:43:38,730
the end the fastest average access time

943
00:43:38,730 --> 00:43:42,390
is the driver page so we can mount this

944
00:43:42,390 --> 00:43:44,339
attack on Windows 10 in less than 12

945
00:43:44,339 --> 00:43:47,759
seconds so we can defeat KS aligned in

946
00:43:47,759 --> 00:43:49,589
less than 12 seconds which is very nice

947
00:43:49,589 --> 00:43:53,160
and in practice the measurements looks

948
00:43:53,160 --> 00:43:56,579
like the following so we have a lot of

949
00:43:56,579 --> 00:43:59,339
long measurements and at some point you

950
00:43:59,339 --> 00:44:01,829
have a low one and you know exactly that

951
00:44:01,829 --> 00:44:06,809
this driver region and that Resta

952
00:44:06,809 --> 00:44:08,730
traivor is located and you can mount

953
00:44:08,730 --> 00:44:11,880
those read to direct attacks again

954
00:44:11,880 --> 00:44:15,630
however that's not everything because

955
00:44:15,630 --> 00:44:18,960
there are more instructions in - yeah so

956
00:44:18,960 --> 00:44:21,660
the following is not our work but we

957
00:44:21,660 --> 00:44:22,950
thought that would be interested because

958
00:44:22,950 --> 00:44:24,930
it's basically more instructions more

959
00:44:24,930 --> 00:44:28,950
attacks often so tells the artists each

960
00:44:28,950 --> 00:44:31,380
instruction and what it does that is

961
00:44:31,380 --> 00:44:33,269
requested random C to the hardware

962
00:44:33,269 --> 00:44:35,670
random number generator so the thing is

963
00:44:35,670 --> 00:44:37,349
that there is a fixed number of pre

964
00:44:37,349 --> 00:44:39,450
computed random bits and that takes time

965
00:44:39,450 --> 00:44:41,910
to regenerate them so as everything that

966
00:44:41,910 --> 00:44:44,190
takes time you can create a cover to

967
00:44:44,190 --> 00:44:48,029
nervous that there's also F ad and F mal

968
00:44:48,029 --> 00:44:50,849
which are floating point operations here

969
00:44:50,849 --> 00:44:53,849
the running time of this instruction

970
00:44:53,849 --> 00:44:56,700
depends on the operands some people

971
00:44:56,700 --> 00:44:58,650
manage to bypass Firefox same origin

972
00:44:58,650 --> 00:45:01,410
policy with an SVG filter timing attack

973
00:45:01,410 --> 00:45:04,740
with that there's also the jump

974
00:45:04,740 --> 00:45:08,279
instructions and so in modern CPUs you

975
00:45:08,279 --> 00:45:10,120
have branch prediction

976
00:45:10,120 --> 00:45:13,180
and branch target prediction with that

977
00:45:13,180 --> 00:45:15,850
it's actually been studied a lot you can

978
00:45:15,850 --> 00:45:17,980
create cover channel you can do such an

979
00:45:17,980 --> 00:45:19,870
attacks on crypto you can also bypass

980
00:45:19,870 --> 00:45:24,370
Canon DSLR and finally there are TSX

981
00:45:24,370 --> 00:45:27,490
instructions which is an extension for

982
00:45:27,490 --> 00:45:29,290
Hardware transactional memory support

983
00:45:29,290 --> 00:45:31,420
which has also been used to bypass

984
00:45:31,420 --> 00:45:33,370
Colonel ASL also in case you're not

985
00:45:33,370 --> 00:45:37,350
rockin ELISA lies dead you have lots of

986
00:45:37,350 --> 00:45:41,950
different things to read okay so on the

987
00:45:41,950 --> 00:45:45,400
conclusion now so I've just seen it's

988
00:45:45,400 --> 00:45:48,040
actually more a problem of CPU design

989
00:45:48,040 --> 00:45:49,990
than really the instruction set

990
00:45:49,990 --> 00:45:53,230
architecture the thing is that all these

991
00:45:53,230 --> 00:45:55,330
issues are really hard to patch they are

992
00:45:55,330 --> 00:45:58,240
all linked to performance optimizations

993
00:45:58,240 --> 00:46:00,100
and we are not getting rid of

994
00:46:00,100 --> 00:46:01,630
performance optimization that's

995
00:46:01,630 --> 00:46:03,220
basically a trade-off between

996
00:46:03,220 --> 00:46:05,860
performance and security and performance

997
00:46:05,860 --> 00:46:11,730
seems to always win there has been some

998
00:46:11,730 --> 00:46:18,700
propositions to against cache attacks -

999
00:46:18,700 --> 00:46:20,920
let's say remove this here first

1000
00:46:20,920 --> 00:46:23,590
instructions the thing is that all these

1001
00:46:23,590 --> 00:46:26,500
quick fix won't work because we always

1002
00:46:26,500 --> 00:46:28,270
find new ways to do the same thing

1003
00:46:28,270 --> 00:46:31,000
without these precise instructions and

1004
00:46:31,000 --> 00:46:32,710
also we keep finding new instruction

1005
00:46:32,710 --> 00:46:36,180
that leaked information so it's really

1006
00:46:36,180 --> 00:46:38,500
let's say quite quite a big topic that

1007
00:46:38,500 --> 00:46:42,400
that we have to fix this so thank you

1008
00:46:42,400 --> 00:46:44,710
very much for your attention if you have

1009
00:46:44,710 --> 00:46:47,700
any questions we'd be happy

1010
00:46:47,700 --> 00:46:52,120
[Applause]

1011
00:46:52,220 --> 00:46:54,970
okay

1012
00:46:59,900 --> 00:47:02,210
thank you very much again for your talk

1013
00:47:02,210 --> 00:47:04,789
and now we will have the Q&A and we have

1014
00:47:04,789 --> 00:47:07,759
I think about 15 minutes so you can

1015
00:47:07,759 --> 00:47:08,930
start lining up behind the microphones

1016
00:47:08,930 --> 00:47:12,609
they are in the Ganga race in the middle

1017
00:47:12,609 --> 00:47:16,249
except I think that one oh now it's back

1018
00:47:16,249 --> 00:47:19,039
up so it will work and while we wait I

1019
00:47:19,039 --> 00:47:20,630
think we will take questions from our

1020
00:47:20,630 --> 00:47:25,279
signal angel if there are any okay there

1021
00:47:25,279 --> 00:47:27,319
aren't any so microphone questions I

1022
00:47:27,319 --> 00:47:30,819
think you have front

1023
00:47:32,130 --> 00:47:34,940
can you me

1024
00:47:36,800 --> 00:47:38,310
try again

1025
00:47:38,310 --> 00:47:41,820
okay can you hear me now okay yeah I'd

1026
00:47:41,820 --> 00:47:43,890
like to know what exactly was your

1027
00:47:43,890 --> 00:47:46,500
stealthiness metric was it that you

1028
00:47:46,500 --> 00:47:49,050
can't distinguish distinguish it from a

1029
00:47:49,050 --> 00:47:55,530
normal process or so wait a second we

1030
00:47:55,530 --> 00:47:57,810
have still cute I could you quiet down a

1031
00:47:57,810 --> 00:47:58,440
bit

1032
00:47:58,440 --> 00:48:02,160
that would be nice what a question was

1033
00:48:02,160 --> 00:48:04,500
about the stiffness matrix basically and

1034
00:48:04,500 --> 00:48:10,500
we so we use the metric with cache

1035
00:48:10,500 --> 00:48:13,050
misses and cache references normalized

1036
00:48:13,050 --> 00:48:16,920
by the instructions will be events and

1037
00:48:16,920 --> 00:48:20,670
we just found the threshold under which

1038
00:48:20,670 --> 00:48:23,099
pretty much every every benign

1039
00:48:23,099 --> 00:48:25,050
application was below this and rahama

1040
00:48:25,050 --> 00:48:27,180
and cache attacks were after that so we

1041
00:48:27,180 --> 00:48:31,740
we fixed the threshold basically that

1042
00:48:31,740 --> 00:48:35,400
microphone oh thanks for your talk it

1043
00:48:35,400 --> 00:48:37,740
was great

1044
00:48:37,740 --> 00:48:40,830
first question did you inform Intel

1045
00:48:40,830 --> 00:48:46,170
before doing this talk nope okay the

1046
00:48:46,170 --> 00:48:49,310
second question what's your future plans

1047
00:48:49,310 --> 00:48:52,920
sorry what's your future plans future

1048
00:48:52,920 --> 00:48:56,640
plans well what I do that is interesting

1049
00:48:56,640 --> 00:48:59,339
is that we keep finding these small s by

1050
00:48:59,339 --> 00:49:03,720
accidents or manually so having a good

1051
00:49:03,720 --> 00:49:05,430
idea of what's the attack surface here

1052
00:49:05,430 --> 00:49:07,290
would be a good thing and doing that

1053
00:49:07,290 --> 00:49:10,500
automatically would be even better great

1054
00:49:10,500 --> 00:49:13,950
things okay the microphone in the back

1055
00:49:13,950 --> 00:49:17,310
over there the guy in white hi one

1056
00:49:17,310 --> 00:49:19,200
question if you have like a demon that

1057
00:49:19,200 --> 00:49:22,170
randomly invalidates some cache lines

1058
00:49:22,170 --> 00:49:25,050
would that be a better con dimensions

1059
00:49:25,050 --> 00:49:28,070
than disabling the cache

1060
00:49:28,960 --> 00:49:33,940
what was the question if invalidating

1061
00:49:33,940 --> 00:49:36,480
cash lines would be better than

1062
00:49:36,480 --> 00:49:41,109
delivering the whole cash so I'm if you

1063
00:49:41,109 --> 00:49:43,270
know which cash lines have been accessed

1064
00:49:43,270 --> 00:49:45,520
by the process you can invalidate those

1065
00:49:45,520 --> 00:49:47,920
cash lines before you swap those

1066
00:49:47,920 --> 00:49:50,559
processes but it's also a trade-off

1067
00:49:50,559 --> 00:49:53,020
between performance like you can also

1068
00:49:53,020 --> 00:49:55,240
with use switch processes flush the

1069
00:49:55,240 --> 00:49:58,059
whole cash and then it's empty and then

1070
00:49:58,059 --> 00:50:00,250
you don't see any activity anymore but

1071
00:50:00,250 --> 00:50:01,809
there's also the trade-off of

1072
00:50:01,809 --> 00:50:05,410
performance with this okay maybe a

1073
00:50:05,410 --> 00:50:07,329
second question if you there are some

1074
00:50:07,329 --> 00:50:10,690
architectures that have random cache

1075
00:50:10,690 --> 00:50:13,359
line in validations did you try those if

1076
00:50:13,359 --> 00:50:17,859
you can see as a professional there if

1077
00:50:17,859 --> 00:50:20,230
they're truly random but probably you

1078
00:50:20,230 --> 00:50:22,210
just have to make more measurements and

1079
00:50:22,210 --> 00:50:23,650
more measurements and then you can

1080
00:50:23,650 --> 00:50:26,980
average out the noise and then you can

1081
00:50:26,980 --> 00:50:28,990
do these attacks again this like with

1082
00:50:28,990 --> 00:50:30,369
priming probe where you need more

1083
00:50:30,369 --> 00:50:31,780
measurements because it's much more

1084
00:50:31,780 --> 00:50:33,790
noisy so in the end you will just need

1085
00:50:33,790 --> 00:50:35,319
much more measurements

1086
00:50:35,319 --> 00:50:37,809
so on arm it's supposed to give you the

1087
00:50:37,809 --> 00:50:39,880
random at this is what in the manual but

1088
00:50:39,880 --> 00:50:43,180
we actually found nice ways to AV cache

1089
00:50:43,180 --> 00:50:44,680
lines that we really wanted to with it

1090
00:50:44,680 --> 00:50:47,650
so it's not agreed that pseudo-random so

1091
00:50:47,650 --> 00:50:49,900
even let's see if something is truly

1092
00:50:49,900 --> 00:50:52,089
random it might be nice but then it's

1093
00:50:52,089 --> 00:50:55,359
also quite complicated to to implement I

1094
00:50:55,359 --> 00:50:57,190
mean you probably don't want to random

1095
00:50:57,190 --> 00:50:59,369
number generator of choice for a cache

1096
00:50:59,369 --> 00:51:03,130
okay thanks okay and then the three guys

1097
00:51:03,130 --> 00:51:06,450
here in the microphone in the front oh

1098
00:51:06,450 --> 00:51:09,099
my question is about a detail with the

1099
00:51:09,099 --> 00:51:12,970
key logger you could distinguish between

1100
00:51:12,970 --> 00:51:15,430
spaced backspace and alphabet which is

1101
00:51:15,430 --> 00:51:17,859
quite interesting but could you also

1102
00:51:17,859 --> 00:51:20,380
figure out the specific keys that were

1103
00:51:20,380 --> 00:51:22,450
pressed dad if so how

1104
00:51:22,450 --> 00:51:24,010
yeah that depends on the implementation

1105
00:51:24,010 --> 00:51:26,260
of the keyboard but what we did we used

1106
00:51:26,260 --> 00:51:28,420
the N word stock keyboard which is

1107
00:51:28,420 --> 00:51:30,190
shipped with the Sam zone so it's

1108
00:51:30,190 --> 00:51:33,040
pre-installed and if you have a table

1109
00:51:33,040 --> 00:51:35,079
somewhere in your code which says okay

1110
00:51:35,079 --> 00:51:37,809
if you press this exact location or this

1111
00:51:37,809 --> 00:51:40,569
image it's an A or this it's in B then

1112
00:51:40,569 --> 00:51:42,220
you can also do a more sophisticated

1113
00:51:42,220 --> 00:51:45,190
attack so if you find any functions or

1114
00:51:45,190 --> 00:51:48,160
data in the code which directly to LC

1115
00:51:48,160 --> 00:51:50,799
okay this is this character you can also

1116
00:51:50,799 --> 00:51:53,980
spy on the actual key characters on the

1117
00:51:53,980 --> 00:51:54,520
keyboard

1118
00:51:54,520 --> 00:52:01,030
thank you all right thank you for your

1119
00:52:01,030 --> 00:52:03,940
talk my first question is what can we

1120
00:52:03,940 --> 00:52:07,000
actually do now to mitigate this kind of

1121
00:52:07,000 --> 00:52:09,250
attack by for example switching off key

1122
00:52:09,250 --> 00:52:13,930
Essex or using ECC Ram so I think the

1123
00:52:13,930 --> 00:52:16,000
very important thing to protect would be

1124
00:52:16,000 --> 00:52:17,859
like crypto and the good thing is that

1125
00:52:17,859 --> 00:52:19,780
today we know how to be critical that is

1126
00:52:19,780 --> 00:52:21,790
resistant to section attacks so the cool

1127
00:52:21,790 --> 00:52:23,430
thing would be to stop improving

1128
00:52:23,430 --> 00:52:24,940
implementation that are known to be

1129
00:52:24,940 --> 00:52:28,480
vulnerable for 10 years then things like

1130
00:52:28,480 --> 00:52:31,780
keystrokes is way harder to to to

1131
00:52:31,780 --> 00:52:34,480
protect so let's say crypto is

1132
00:52:34,480 --> 00:52:36,990
manageable the whole system is clearly

1133
00:52:36,990 --> 00:52:39,970
another problem and you can have

1134
00:52:39,970 --> 00:52:41,530
different types of countermeasure on the

1135
00:52:41,530 --> 00:52:43,210
hardware side but it does would mean

1136
00:52:43,210 --> 00:52:45,280
that in turn an arm actually want to fix

1137
00:52:45,280 --> 00:52:47,200
that and that they know how to fix that

1138
00:52:47,200 --> 00:52:48,400
I don't even know how to fix that in

1139
00:52:48,400 --> 00:52:52,660
hardware then on the system side if you

1140
00:52:52,660 --> 00:52:55,510
prevent some kind of memory sharing you

1141
00:52:55,510 --> 00:52:57,040
don't have Russian whittled anymore and

1142
00:52:57,040 --> 00:52:59,049
primum probably is much more noisier I

1143
00:52:59,049 --> 00:53:01,900
miss much monoecious so it would be an

1144
00:53:01,900 --> 00:53:06,040
improvement thank you

1145
00:53:06,040 --> 00:53:10,329
do we have signal angel Christians no ok

1146
00:53:10,329 --> 00:53:12,940
then more microphone hi thank you I

1147
00:53:12,940 --> 00:53:15,220
wanted to ask about the way you

1148
00:53:15,220 --> 00:53:17,109
establish the side channel between the

1149
00:53:17,109 --> 00:53:19,240
two processes because it was it would

1150
00:53:19,240 --> 00:53:22,950
obviously have to be timed in a way to

1151
00:53:22,950 --> 00:53:26,319
transmit information between one process

1152
00:53:26,319 --> 00:53:28,540
to the other is there anywhere that you

1153
00:53:28,540 --> 00:53:30,880
documented the whole you know it's

1154
00:53:30,880 --> 00:53:33,010
actually almost like the seven layers or

1155
00:53:33,010 --> 00:53:34,450
something like that there any ways that

1156
00:53:34,450 --> 00:53:36,549
you documented that it would be really

1157
00:53:36,549 --> 00:53:38,500
interesting to know how it worked you

1158
00:53:38,500 --> 00:53:40,540
can find this information in the paper

1159
00:53:40,540 --> 00:53:42,549
because there are several papers on

1160
00:53:42,549 --> 00:53:45,430
covered channels using that so

1161
00:53:45,430 --> 00:53:48,130
the NGSS paper is published in February

1162
00:53:48,130 --> 00:53:50,619
I guess but the Armageddon paper also

1163
00:53:50,619 --> 00:53:53,509
Institute's introduces a cover channel

1164
00:53:53,509 --> 00:53:55,399
you can find more information about how

1165
00:53:55,399 --> 00:53:57,169
the packets look like and how the

1166
00:53:57,169 --> 00:53:59,239
synchronization works in the paper thank

1167
00:53:59,239 --> 00:54:01,329
you

1168
00:54:01,539 --> 00:54:05,809
one last question I am you mentioned

1169
00:54:05,809 --> 00:54:07,489
that you used us weeks attack for the

1170
00:54:07,489 --> 00:54:11,509
AES side channel attack did you solve

1171
00:54:11,509 --> 00:54:14,899
the round is round detection and is it

1172
00:54:14,899 --> 00:54:18,249
different to some scheduler manipulation

1173
00:54:18,249 --> 00:54:21,709
so on this one I think we only did some

1174
00:54:21,709 --> 00:54:23,929
synchronous attack so we already knew

1175
00:54:23,929 --> 00:54:26,119
when the victim is going to be scheduled

1176
00:54:26,119 --> 00:54:27,619
and we didn't have anything to do with

1177
00:54:27,619 --> 00:54:32,649
schedulers alright thank you

1178
00:54:32,649 --> 00:54:35,359
are there any more questions no I don't

1179
00:54:35,359 --> 00:54:37,339
see anyone then thank you very much

1180
00:54:37,339 --> 00:54:40,089
again to our speakers

1181
00:54:40,110 --> 00:54:43,530
[Applause]

1182
00:54:43,530 --> 00:55:07,579
[Music]

