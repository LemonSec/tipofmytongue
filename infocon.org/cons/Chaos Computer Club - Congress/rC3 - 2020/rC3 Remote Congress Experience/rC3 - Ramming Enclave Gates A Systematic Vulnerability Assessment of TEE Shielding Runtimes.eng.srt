1
00:00:01,500 --> 00:00:10,520
[Music]

2
00:00:07,350 --> 00:00:10,520
[Applause]

3
00:00:12,719 --> 00:00:16,079
so

4
00:00:13,280 --> 00:00:16,400
for the next talk i have joe van bulk

5
00:00:16,079 --> 00:00:18,479
and

6
00:00:16,400 --> 00:00:20,000
fritz alder from the university of

7
00:00:18,480 --> 00:00:23,199
leuven in belgium

8
00:00:20,000 --> 00:00:26,080
and david oswalt from a professor for

9
00:00:23,199 --> 00:00:28,320
cyber security in birmingham

10
00:00:26,080 --> 00:00:30,560
they are here to talk about the trusted

11
00:00:28,320 --> 00:00:31,359
execution environment you probably know

12
00:00:30,560 --> 00:00:35,040
from intel

13
00:00:31,359 --> 00:00:37,360
and so on and you should probably not

14
00:00:35,040 --> 00:00:38,160
trust it all the way because it's

15
00:00:37,360 --> 00:00:41,120
software

16
00:00:38,160 --> 00:00:42,239
and it has its flaws and so they're

17
00:00:41,120 --> 00:00:44,718
talking about

18
00:00:42,239 --> 00:00:45,599
ramming enclave gates which is always

19
00:00:44,719 --> 00:00:48,640
good

20
00:00:45,600 --> 00:00:49,200
a systematic vulnerability assessment of

21
00:00:48,640 --> 00:00:51,760
te

22
00:00:49,200 --> 00:00:53,920
shielding runtimes please go on with the

23
00:00:51,760 --> 00:00:56,800
turks

24
00:00:53,920 --> 00:00:58,079
hi everyone welcome to our talk so i'm

25
00:00:56,800 --> 00:01:00,160
your from

26
00:00:58,079 --> 00:01:02,640
e-mec dissonant research group at k11

27
00:01:00,160 --> 00:01:03,199
and today joining me are fritz also from

28
00:01:02,640 --> 00:01:04,720
levin

29
00:01:03,199 --> 00:01:06,399
and david from the university of

30
00:01:04,720 --> 00:01:08,400
birmingham and we have this very

31
00:01:06,400 --> 00:01:10,000
exciting topic to talk about the roaming

32
00:01:08,400 --> 00:01:12,080
enclave gates

33
00:01:10,000 --> 00:01:13,600
but before we dive into that i think

34
00:01:12,080 --> 00:01:14,320
most of you will not know what our

35
00:01:13,600 --> 00:01:17,679
enclaves

36
00:01:14,320 --> 00:01:20,720
let alone what are these tees so uh

37
00:01:17,680 --> 00:01:23,600
let me first start with uh some analogy

38
00:01:20,720 --> 00:01:25,840
so enclaves are essentially a sort of a

39
00:01:23,600 --> 00:01:26,720
secure fortress in the in the process in

40
00:01:25,840 --> 00:01:29,520
the cpu

41
00:01:26,720 --> 00:01:30,400
and uh so it's an encrypted memory

42
00:01:29,520 --> 00:01:32,560
region

43
00:01:30,400 --> 00:01:34,000
that is exclusively accessible from the

44
00:01:32,560 --> 00:01:36,960
inside and

45
00:01:34,000 --> 00:01:39,360
what we know from from the last uh

46
00:01:36,960 --> 00:01:40,559
history of fortress attacks and defenses

47
00:01:39,360 --> 00:01:42,240
of course is that

48
00:01:40,560 --> 00:01:44,560
when you cannot take affordance because

49
00:01:42,240 --> 00:01:46,798
the walls are high and strong

50
00:01:44,560 --> 00:01:48,720
uh you typically aim for the gates right

51
00:01:46,799 --> 00:01:49,840
that's the weakest point in any in any

52
00:01:48,720 --> 00:01:52,479
fortress defense

53
00:01:49,840 --> 00:01:55,119
and uh that's exactly the idea of of

54
00:01:52,479 --> 00:01:57,039
this research so it turns out to apply

55
00:01:55,119 --> 00:01:58,560
to enclaves as well

56
00:01:57,040 --> 00:02:00,079
and we have been ramming the enclave

57
00:01:58,560 --> 00:02:00,560
gate we have been attacking the input

58
00:02:00,079 --> 00:02:03,520
out of

59
00:02:00,560 --> 00:02:05,040
output interface of the enclave so a

60
00:02:03,520 --> 00:02:07,360
very simple idea but

61
00:02:05,040 --> 00:02:08,080
but very drastic consequences i dare to

62
00:02:07,360 --> 00:02:10,800
say so this

63
00:02:08,080 --> 00:02:12,000
is uh sort of the summary of our

64
00:02:10,800 --> 00:02:15,280
research

65
00:02:12,000 --> 00:02:17,440
um with over 40 interface analyzation

66
00:02:15,280 --> 00:02:20,560
vulnerabilities that we found in over

67
00:02:17,440 --> 00:02:22,560
eight widely used open source enclave

68
00:02:20,560 --> 00:02:24,959
projects um

69
00:02:22,560 --> 00:02:26,800
so we will go a bit into detail over

70
00:02:24,959 --> 00:02:29,280
that in the rest of the slides uh

71
00:02:26,800 --> 00:02:31,519
also a nice thing to say here is that

72
00:02:29,280 --> 00:02:32,160
this resulted in two academic papers to

73
00:02:31,519 --> 00:02:35,920
date

74
00:02:32,160 --> 00:02:37,680
uh over seven cves and and all together

75
00:02:35,920 --> 00:02:41,440
quite some responsible disclosure

76
00:02:37,680 --> 00:02:41,440
lengthy embargo uh periods

77
00:02:43,920 --> 00:02:48,640
okay so uh i guess uh we we should talk

78
00:02:47,440 --> 00:02:54,079
about why we need

79
00:02:48,640 --> 00:02:56,480
uh such enclave fortresses anyway

80
00:02:54,080 --> 00:02:59,040
so if you look at a traditional kind of

81
00:02:56,480 --> 00:03:01,040
like operating system or a computer

82
00:02:59,040 --> 00:03:04,239
architecture you have a very large

83
00:03:01,040 --> 00:03:05,760
trusted computing base so you uh

84
00:03:04,239 --> 00:03:08,480
for instance on the laptops that you

85
00:03:05,760 --> 00:03:11,359
most likely use to to watch this talk

86
00:03:08,480 --> 00:03:12,079
you you trust the uh the kernel you

87
00:03:11,360 --> 00:03:14,080
trust maybe

88
00:03:12,080 --> 00:03:16,400
a hypervisor if you have and the whole

89
00:03:14,080 --> 00:03:17,360
hardware under under the system so cpu

90
00:03:16,400 --> 00:03:19,920
memory

91
00:03:17,360 --> 00:03:22,319
maybe maybe hard drive trusted platform

92
00:03:19,920 --> 00:03:24,640
module and the likes

93
00:03:22,319 --> 00:03:26,238
so actually the problem is here with

94
00:03:24,640 --> 00:03:28,480
with such a large

95
00:03:26,239 --> 00:03:30,159
tcp trusted computing base you can also

96
00:03:28,480 --> 00:03:31,518
have vulnerabilities basically

97
00:03:30,159 --> 00:03:34,239
everywhere

98
00:03:31,519 --> 00:03:35,280
now and also malware hiding in all these

99
00:03:34,239 --> 00:03:38,480
parts

100
00:03:35,280 --> 00:03:41,440
so the idea of this enclave execution is

101
00:03:38,480 --> 00:03:42,480
as as we find for instance in intel sgx

102
00:03:41,440 --> 00:03:46,000
which is built into

103
00:03:42,480 --> 00:03:48,959
our most recent intel processors is that

104
00:03:46,000 --> 00:03:50,720
you uh take most of the software stack

105
00:03:48,959 --> 00:03:53,599
between an actual

106
00:03:50,720 --> 00:03:55,760
application here's the enclave app and

107
00:03:53,599 --> 00:03:59,119
the actual cpu out of the

108
00:03:55,760 --> 00:04:01,840
tcb so now you only trust really the

109
00:03:59,120 --> 00:04:02,480
cpu and of course you trust your own

110
00:04:01,840 --> 00:04:04,239
code

111
00:04:02,480 --> 00:04:06,560
but you don't have to trust the os

112
00:04:04,239 --> 00:04:08,239
anymore and sjx for instance promises to

113
00:04:06,560 --> 00:04:09,599
protect against an attacker who has

114
00:04:08,239 --> 00:04:12,239
achieved a root

115
00:04:09,599 --> 00:04:14,079
in the operating system and even

116
00:04:12,239 --> 00:04:15,760
depending on who you ask against for

117
00:04:14,080 --> 00:04:17,519
instance a malicious cloud cloud

118
00:04:15,760 --> 00:04:20,399
provider so imagine you run

119
00:04:17,519 --> 00:04:21,680
your application on the uh on the cloud

120
00:04:20,399 --> 00:04:24,799
and then you can still

121
00:04:21,680 --> 00:04:26,800
run your code in a trusted way with a

122
00:04:24,800 --> 00:04:28,400
hardware level isolation and you have

123
00:04:26,800 --> 00:04:30,880
attestation and so on you don't

124
00:04:28,400 --> 00:04:33,758
no longer really have to trust even the

125
00:04:30,880 --> 00:04:33,759
administrator

126
00:04:35,680 --> 00:04:39,040
so the problem uh is of course that

127
00:04:38,000 --> 00:04:41,919
attack surface

128
00:04:39,040 --> 00:04:43,120
remains so previous attacks and some

129
00:04:41,919 --> 00:04:46,880
some of them i think will

130
00:04:43,120 --> 00:04:49,520
uh also be uh presented at uh at this

131
00:04:46,880 --> 00:04:51,199
remote congress this year have targeted

132
00:04:49,520 --> 00:04:53,039
vulnerabilities in the micro

133
00:04:51,199 --> 00:04:55,600
architecture of the

134
00:04:53,040 --> 00:04:56,720
cpu now so you're you're attacking

135
00:04:55,600 --> 00:04:58,320
basically the

136
00:04:56,720 --> 00:05:00,160
the hardware level so you had four

137
00:04:58,320 --> 00:05:02,800
shadow yet uh micro

138
00:05:00,160 --> 00:05:03,440
architectural data sampling spectre and

139
00:05:02,800 --> 00:05:06,720
lvi

140
00:05:03,440 --> 00:05:08,160
and the likes but what less attention

141
00:05:06,720 --> 00:05:08,720
has been paid to and what we'll talk

142
00:05:08,160 --> 00:05:10,479
about

143
00:05:08,720 --> 00:05:13,039
more in this presentation is the

144
00:05:10,479 --> 00:05:16,159
software level inside the uh

145
00:05:13,039 --> 00:05:17,759
inside the enclave which which i hinted

146
00:05:16,160 --> 00:05:20,160
at that there's some software that you

147
00:05:17,759 --> 00:05:23,280
uh trust but now we look in more detail

148
00:05:20,160 --> 00:05:23,759
in into what actually is uh is in in

149
00:05:23,280 --> 00:05:27,679
such an

150
00:05:23,759 --> 00:05:30,560
enclave from the from the software side

151
00:05:27,680 --> 00:05:32,560
so can an attacker uh exploit any

152
00:05:30,560 --> 00:05:33,280
classical software vulnerabilities in

153
00:05:32,560 --> 00:05:36,479
the uh

154
00:05:33,280 --> 00:05:39,359
enclave yes david

155
00:05:36,479 --> 00:05:39,680
that's quite uh an interesting approach

156
00:05:39,360 --> 00:05:41,360
right

157
00:05:39,680 --> 00:05:42,560
let's let's let's aim for the software

158
00:05:41,360 --> 00:05:44,800
so we have to understand what is a

159
00:05:42,560 --> 00:05:47,840
software landscape out there for

160
00:05:44,800 --> 00:05:49,520
uh these sgx enclaves and tes in general

161
00:05:47,840 --> 00:05:51,440
uh so that's what we did we started with

162
00:05:49,520 --> 00:05:52,880
an analysis and you see some screenshots

163
00:05:51,440 --> 00:05:55,199
here this is actually

164
00:05:52,880 --> 00:05:56,880
a growing open source ecosystem many

165
00:05:55,199 --> 00:05:59,919
many of these runtimes

166
00:05:56,880 --> 00:06:01,680
library operating system sdks and

167
00:05:59,919 --> 00:06:03,280
before we dive into the details i want

168
00:06:01,680 --> 00:06:06,160
to stand still with

169
00:06:03,280 --> 00:06:06,559
what is the common factor that all of

170
00:06:06,160 --> 00:06:09,600
them

171
00:06:06,560 --> 00:06:11,440
share right what is kind of the idea of

172
00:06:09,600 --> 00:06:15,680
these enclave development environments

173
00:06:11,440 --> 00:06:18,080
so so here um what any

174
00:06:15,680 --> 00:06:19,199
tee to execution environment gives you

175
00:06:18,080 --> 00:06:22,400
is this notion of

176
00:06:19,199 --> 00:06:23,120
a secure enclave oasis in a hostile

177
00:06:22,400 --> 00:06:24,960
environment

178
00:06:23,120 --> 00:06:26,800
right and and you can do secure

179
00:06:24,960 --> 00:06:29,520
computations in the green box

180
00:06:26,800 --> 00:06:30,160
while the outside world is burning um

181
00:06:29,520 --> 00:06:32,318
without

182
00:06:30,160 --> 00:06:33,440
us with any defense mechanism as i said

183
00:06:32,319 --> 00:06:35,520
earlier the

184
00:06:33,440 --> 00:06:37,199
devil is in the details and typically at

185
00:06:35,520 --> 00:06:40,080
the gate right so how do you

186
00:06:37,199 --> 00:06:42,000
mediate between that induced world where

187
00:06:40,080 --> 00:06:42,800
the desert is on fire and the secure

188
00:06:42,000 --> 00:06:46,319
oasis

189
00:06:42,800 --> 00:06:47,680
in the anklet and and the intuition here

190
00:06:46,319 --> 00:06:49,759
is that you need some sort of

191
00:06:47,680 --> 00:06:50,240
intermediary software layer which what

192
00:06:49,759 --> 00:06:52,639
we call

193
00:06:50,240 --> 00:06:53,840
a shielding runtime so it kind of makes

194
00:06:52,639 --> 00:06:55,840
a secure bridge

195
00:06:53,840 --> 00:06:57,599
to go from the interstate walls to the

196
00:06:55,840 --> 00:06:59,198
enclave and back and that's that's what

197
00:06:57,599 --> 00:07:00,000
we are interested in right to see what

198
00:06:59,199 --> 00:07:02,240
kind of

199
00:07:00,000 --> 00:07:03,520
of security checks you need to do you

200
00:07:02,240 --> 00:07:05,120
need to do there

201
00:07:03,520 --> 00:07:07,440
so it's quite a beautiful picture you

202
00:07:05,120 --> 00:07:08,080
have on the right the fertile enclave

203
00:07:07,440 --> 00:07:11,440
and on the left

204
00:07:08,080 --> 00:07:13,120
the um the hostile desert and we make

205
00:07:11,440 --> 00:07:15,120
this secure bridge in between

206
00:07:13,120 --> 00:07:16,560
and what we are interested in is what if

207
00:07:15,120 --> 00:07:19,759
it goes wrong what if you

208
00:07:16,560 --> 00:07:21,120
your bridge itself is flawed so uh to

209
00:07:19,759 --> 00:07:24,800
answer that question

210
00:07:21,120 --> 00:07:27,039
we look at that yellow box and we ask

211
00:07:24,800 --> 00:07:28,080
what kind of sanitizations what kind of

212
00:07:27,039 --> 00:07:30,318
security checks

213
00:07:28,080 --> 00:07:32,240
do you need to apply when you go from

214
00:07:30,319 --> 00:07:34,720
the outside to the inside and back

215
00:07:32,240 --> 00:07:36,400
from the inside to the outside and and

216
00:07:34,720 --> 00:07:37,919
one of the key contributions that we

217
00:07:36,400 --> 00:07:39,599
have built up in the past two years of

218
00:07:37,919 --> 00:07:42,318
this research i think is that

219
00:07:39,599 --> 00:07:42,840
that yellow box can be subdivided into

220
00:07:42,319 --> 00:07:46,000
two

221
00:07:42,840 --> 00:07:47,840
smaller uh subsequent layers and and the

222
00:07:46,000 --> 00:07:49,759
first one is this abi

223
00:07:47,840 --> 00:07:51,359
application binary interface very low

224
00:07:49,759 --> 00:07:53,120
level cpu state

225
00:07:51,360 --> 00:07:54,720
and the second one is what we call api

226
00:07:53,120 --> 00:07:56,080
application programming interface so

227
00:07:54,720 --> 00:07:58,080
that's the kind of state that's already

228
00:07:56,080 --> 00:07:59,599
visible at the programming language then

229
00:07:58,080 --> 00:08:00,719
the remainder of this presentation we

230
00:07:59,599 --> 00:08:02,400
will kind of

231
00:08:00,720 --> 00:08:04,319
guide you through some relevant

232
00:08:02,400 --> 00:08:06,159
vulnerabilities of both these layers to

233
00:08:04,319 --> 00:08:07,280
give you an understanding of what this

234
00:08:06,160 --> 00:08:10,000
means

235
00:08:07,280 --> 00:08:13,280
so first fritz will guide you to the

236
00:08:10,000 --> 00:08:16,080
exciting low-level landscape of the api

237
00:08:13,280 --> 00:08:17,039
yeah exactly and uh yo you just said

238
00:08:16,080 --> 00:08:18,878
it's the

239
00:08:17,039 --> 00:08:20,080
cpu state and it's the application

240
00:08:18,879 --> 00:08:22,400
binary interface

241
00:08:20,080 --> 00:08:23,599
um but but let's like take a look at

242
00:08:22,400 --> 00:08:26,799
what this means actually

243
00:08:23,599 --> 00:08:28,080
so it means basically that the uh

244
00:08:26,800 --> 00:08:31,280
attacker controls

245
00:08:28,080 --> 00:08:32,220
the cpu register contents um

246
00:08:31,280 --> 00:08:35,120
and um

247
00:08:32,220 --> 00:08:38,479
[Music]

248
00:08:35,120 --> 00:08:39,760
um and that's um on every enclave entry

249
00:08:38,479 --> 00:08:43,039
on the network

250
00:08:39,760 --> 00:08:46,480
exit we need to perform some tasks

251
00:08:43,039 --> 00:08:49,920
um so that the enclave and the

252
00:08:46,480 --> 00:08:54,080
trusted runtime um have some like well

253
00:08:49,920 --> 00:08:57,439
initialized cpu state and as a compiler

254
00:08:54,080 --> 00:09:00,000
um can uh can work with the

255
00:08:57,440 --> 00:09:00,480
uh calling conventions that it expects

256
00:09:00,000 --> 00:09:03,200
um

257
00:09:00,480 --> 00:09:03,760
so these are basically the this is the

258
00:09:03,200 --> 00:09:06,880
key part

259
00:09:03,760 --> 00:09:09,120
uh we need to initialize ccp registers

260
00:09:06,880 --> 00:09:10,320
uh when entering the enclave and

261
00:09:09,120 --> 00:09:12,399
scrapping them

262
00:09:10,320 --> 00:09:13,600
scrubbing them when we're exiting the

263
00:09:12,399 --> 00:09:15,680
enclave so

264
00:09:13,600 --> 00:09:16,959
so we can't just assume anything that

265
00:09:15,680 --> 00:09:19,599
the attacker gives us

266
00:09:16,959 --> 00:09:20,079
as a given we have to initialize it to

267
00:09:19,600 --> 00:09:23,020
something

268
00:09:20,080 --> 00:09:24,640
proper and we looked at multiple

269
00:09:23,020 --> 00:09:28,160
[Music]

270
00:09:24,640 --> 00:09:30,319
te tt run times and then

271
00:09:28,160 --> 00:09:31,519
multiple tes and we found a lot of

272
00:09:30,320 --> 00:09:35,120
vulnerabilities

273
00:09:31,519 --> 00:09:35,760
uh in this avi layer and one key insight

274
00:09:35,120 --> 00:09:38,880
of

275
00:09:35,760 --> 00:09:42,160
this analysis is basically that

276
00:09:38,880 --> 00:09:44,880
a lot of these vulnerabilities um happen

277
00:09:42,160 --> 00:09:45,680
on uh complex instruction set processors

278
00:09:44,880 --> 00:09:48,080
so on

279
00:09:45,680 --> 00:09:49,279
cisc processors and basically on the

280
00:09:48,080 --> 00:09:51,839
international dx

281
00:09:49,279 --> 00:09:52,640
at te we also looked at some risk

282
00:09:51,839 --> 00:09:55,040
processors

283
00:09:52,640 --> 00:09:56,080
and of course it's not uh yeah

284
00:09:55,040 --> 00:09:59,439
representative

285
00:09:56,080 --> 00:10:02,560
but it's like immediately visible that

286
00:09:59,440 --> 00:10:05,440
a complex complex x86 api

287
00:10:02,560 --> 00:10:07,359
seems to be uh have a way higher a

288
00:10:05,440 --> 00:10:10,240
larger tech surface

289
00:10:07,360 --> 00:10:11,040
than the simpler risk designs so let's

290
00:10:10,240 --> 00:10:14,399
take a look at one

291
00:10:11,040 --> 00:10:15,279
example of of this uh yeah more complex

292
00:10:14,399 --> 00:10:17,360
design

293
00:10:15,279 --> 00:10:18,560
and so for example there's the x86

294
00:10:17,360 --> 00:10:21,360
string instructions

295
00:10:18,560 --> 00:10:22,399
um that are controlled by the direction

296
00:10:21,360 --> 00:10:25,839
flank

297
00:10:22,399 --> 00:10:29,760
so there's a special xb6 rep instruction

298
00:10:25,839 --> 00:10:32,240
um that basically allows you to perform

299
00:10:29,760 --> 00:10:33,279
stream memory operations so if you do

300
00:10:32,240 --> 00:10:36,320
like a mem set

301
00:10:33,279 --> 00:10:39,360
on a buffer this will yeah

302
00:10:36,320 --> 00:10:41,920
be compiled into the rep string

303
00:10:39,360 --> 00:10:43,440
operation instruction and the idea here

304
00:10:41,920 --> 00:10:46,719
is basically

305
00:10:43,440 --> 00:10:48,000
that the buffer is read uh from from

306
00:10:46,720 --> 00:10:50,959
left to right

307
00:10:48,000 --> 00:10:52,079
um and uh well written over it by

308
00:10:50,959 --> 00:10:54,959
memphis it

309
00:10:52,079 --> 00:10:55,519
but this direction flag also allows you

310
00:10:54,959 --> 00:10:57,518
to

311
00:10:55,519 --> 00:10:59,760
go through it from right to left so

312
00:10:57,519 --> 00:11:01,279
backwards

313
00:10:59,760 --> 00:11:03,839
let's not think about why this was a

314
00:11:01,279 --> 00:11:06,399
good idea or why why why this is needed

315
00:11:03,839 --> 00:11:08,640
and but definitely it is possible to to

316
00:11:06,399 --> 00:11:11,600
just set the direction factor 1 and

317
00:11:08,640 --> 00:11:12,240
run this buffer backwards and what we

318
00:11:11,600 --> 00:11:16,000
found out

319
00:11:12,240 --> 00:11:18,720
is that the systemv api actually says

320
00:11:16,000 --> 00:11:19,600
that this must be clear or set to

321
00:11:18,720 --> 00:11:21,440
forward

322
00:11:19,600 --> 00:11:23,200
on function entry and return and that

323
00:11:21,440 --> 00:11:26,480
compilers expect this

324
00:11:23,200 --> 00:11:28,720
to happen so let's take a look at this

325
00:11:26,480 --> 00:11:29,760
when we do this in our enclave so in our

326
00:11:28,720 --> 00:11:33,839
enclave

327
00:11:29,760 --> 00:11:37,360
when we in our trusted application

328
00:11:33,839 --> 00:11:39,279
perform this mem set on our buffer

329
00:11:37,360 --> 00:11:41,760
on normal entry with the normal

330
00:11:39,279 --> 00:11:43,120
direction flag this just means that we

331
00:11:41,760 --> 00:11:45,760
walk this buffer

332
00:11:43,120 --> 00:11:46,720
from front to back so you can see here

333
00:11:45,760 --> 00:11:50,000
uh it just

334
00:11:46,720 --> 00:11:51,680
runs correctly from front to back

335
00:11:50,000 --> 00:11:53,040
but now if the attacker enters the

336
00:11:51,680 --> 00:11:55,519
enclave with

337
00:11:53,040 --> 00:11:56,160
the direction flag set to one so it's

338
00:11:55,519 --> 00:11:59,440
set to

339
00:11:56,160 --> 00:12:02,639
run backwards this now means that

340
00:11:59,440 --> 00:12:04,000
from the start of our buffer so from

341
00:12:02,639 --> 00:12:06,800
from where the pointers

342
00:12:04,000 --> 00:12:08,399
points right now you can now see it

343
00:12:06,800 --> 00:12:10,399
actually runs backwards

344
00:12:08,399 --> 00:12:12,240
so that's a problem and that's

345
00:12:10,399 --> 00:12:15,360
definitely something that we don't want

346
00:12:12,240 --> 00:12:17,600
in our trust applications um because

347
00:12:15,360 --> 00:12:19,760
well as you can as you can think it

348
00:12:17,600 --> 00:12:22,560
allows you to override

349
00:12:19,760 --> 00:12:22,880
keys that are in the very location that

350
00:12:22,560 --> 00:12:25,920
you

351
00:12:22,880 --> 00:12:26,560
can go backwards it allows you to read

352
00:12:25,920 --> 00:12:27,839
out things

353
00:12:26,560 --> 00:12:30,079
that's definitely not something that

354
00:12:27,839 --> 00:12:30,800
that is useful and uh well we reported

355
00:12:30,079 --> 00:12:34,160
this this

356
00:12:30,800 --> 00:12:36,560
actually got a nice cd assigned

357
00:12:34,160 --> 00:12:38,000
we see base core high as you can see

358
00:12:36,560 --> 00:12:41,839
here on the next slide

359
00:12:38,000 --> 00:12:43,440
um and uh well uh

360
00:12:41,839 --> 00:12:45,200
you may think okay well that's that's

361
00:12:43,440 --> 00:12:47,040
that's uh one instance and

362
00:12:45,200 --> 00:12:48,240
and uh you just have to think of all the

363
00:12:47,040 --> 00:12:52,000
flags to to

364
00:12:48,240 --> 00:12:55,040
uh to sanitize and all the flex to check

365
00:12:52,000 --> 00:12:55,600
um but wait of course uh there's always

366
00:12:55,040 --> 00:12:58,959
more

367
00:12:55,600 --> 00:12:58,959
right um so

368
00:12:59,120 --> 00:13:04,480
as we found out uh there's actually the

369
00:13:02,320 --> 00:13:06,880
floating point unit which comes with

370
00:13:04,480 --> 00:13:08,240
like whole lots of other registers and a

371
00:13:06,880 --> 00:13:11,600
whole lot of other

372
00:13:08,240 --> 00:13:12,320
uh things to exploit um and i will spare

373
00:13:11,600 --> 00:13:15,519
you all the

374
00:13:12,320 --> 00:13:18,560
the the details um but just for this

375
00:13:15,519 --> 00:13:22,160
uh this is this presentation um

376
00:13:18,560 --> 00:13:25,920
just know that there is an older x87 fpu

377
00:13:22,160 --> 00:13:26,959
uh and a new sse uh that does vector

378
00:13:25,920 --> 00:13:29,439
floyd uh

379
00:13:26,959 --> 00:13:30,959
vector floating point operations um so

380
00:13:29,440 --> 00:13:34,079
there's the fpu control word

381
00:13:30,959 --> 00:13:38,399
and the mxcsr register for these newer

382
00:13:34,079 --> 00:13:41,359
instructions and this x87 fpu is older

383
00:13:38,399 --> 00:13:43,600
but it's still used for for example for

384
00:13:41,360 --> 00:13:46,160
extended precision like long double

385
00:13:43,600 --> 00:13:47,120
variables so old and new doesn't really

386
00:13:46,160 --> 00:13:48,959
apply here because

387
00:13:47,120 --> 00:13:51,440
both are still relevant and that's kind

388
00:13:48,959 --> 00:13:54,079
of the thing with x86 and x87 here

389
00:13:51,440 --> 00:13:54,079
um that

390
00:13:54,480 --> 00:14:00,240
old archive things that you could

391
00:13:57,680 --> 00:14:02,239
say are outdated are still relevant are

392
00:14:00,240 --> 00:14:04,399
still used nowadays and

393
00:14:02,240 --> 00:14:05,440
again if you look at the system v api

394
00:14:04,399 --> 00:14:08,160
now uh

395
00:14:05,440 --> 00:14:08,560
we saw that these control bits uh are

396
00:14:08,160 --> 00:14:10,160
called

397
00:14:08,560 --> 00:14:12,399
saved so they are preserved across

398
00:14:10,160 --> 00:14:16,079
function codes and the idea here is

399
00:14:12,399 --> 00:14:18,399
which to some degree holds merit is that

400
00:14:16,079 --> 00:14:19,359
these are some global states that you

401
00:14:18,399 --> 00:14:22,480
can set

402
00:14:19,360 --> 00:14:25,120
um and they are um well

403
00:14:22,480 --> 00:14:26,720
transferred uh within one application so

404
00:14:25,120 --> 00:14:27,519
one application can set some global

405
00:14:26,720 --> 00:14:30,480
state

406
00:14:27,519 --> 00:14:31,519
and keep the state across all its uh all

407
00:14:30,480 --> 00:14:33,600
its usage

408
00:14:31,519 --> 00:14:34,800
but the problem here as you can see here

409
00:14:33,600 --> 00:14:37,440
then um

410
00:14:34,800 --> 00:14:38,800
is our application or enclave is

411
00:14:37,440 --> 00:14:40,880
basically one application

412
00:14:38,800 --> 00:14:42,479
and we don't want our attacker to have

413
00:14:40,880 --> 00:14:45,519
control over the global state

414
00:14:42,480 --> 00:14:47,920
within our trusted application right so

415
00:14:45,519 --> 00:14:49,279
um what happens if your settings are

416
00:14:47,920 --> 00:14:53,439
preserved across goals well

417
00:14:49,279 --> 00:14:56,000
on a normal uh normal for a normal user

418
00:14:53,440 --> 00:14:57,519
let's say we just do some calculation

419
00:14:56,000 --> 00:15:00,320
inside the enclave

420
00:14:57,519 --> 00:15:02,639
like 2.1 times 3.4 which just nicely

421
00:15:00,320 --> 00:15:05,040
calculates to a 7.14

422
00:15:02,639 --> 00:15:05,680
long double that's nice right but what

423
00:15:05,040 --> 00:15:09,279
happens

424
00:15:05,680 --> 00:15:11,599
if the attacker now enters the enclave

425
00:15:09,279 --> 00:15:12,800
with some corrupt precision and rounding

426
00:15:11,600 --> 00:15:15,680
mode for

427
00:15:12,800 --> 00:15:16,560
the fpu well then we actually get

428
00:15:15,680 --> 00:15:19,839
another result

429
00:15:16,560 --> 00:15:20,800
so we get a distorted result uh with the

430
00:15:19,839 --> 00:15:22,720
lower precision

431
00:15:20,800 --> 00:15:24,880
and a different rounding mode so it

432
00:15:22,720 --> 00:15:27,839
actually runs running down here

433
00:15:24,880 --> 00:15:28,639
whenever it exceeds the is the precision

434
00:15:27,839 --> 00:15:30,560
um and

435
00:15:28,639 --> 00:15:31,839
this is something we don't want right so

436
00:15:30,560 --> 00:15:35,040
this is something where

437
00:15:31,839 --> 00:15:38,160
the uh developer expects uh

438
00:15:35,040 --> 00:15:39,360
a certain precision or double precision

439
00:15:38,160 --> 00:15:41,600
but the attacker could actually just

440
00:15:39,360 --> 00:15:43,920
reduce it to very uh very

441
00:15:41,600 --> 00:15:44,639
very short precision and we reported

442
00:15:43,920 --> 00:15:48,000
this uh

443
00:15:44,639 --> 00:15:49,600
and we actually found this issue um also

444
00:15:48,000 --> 00:15:51,279
in microsoft open enclaves that's why

445
00:15:49,600 --> 00:15:53,519
it's marked as uh

446
00:15:51,279 --> 00:15:54,560
not exploitable here um but what we

447
00:15:53,519 --> 00:15:56,560
found interesting is

448
00:15:54,560 --> 00:15:57,839
that the intel sjx sdk which was

449
00:15:56,560 --> 00:16:00,000
vulnerable and

450
00:15:57,839 --> 00:16:01,199
patched this as with some x restore

451
00:16:00,000 --> 00:16:04,959
instruction which

452
00:16:01,199 --> 00:16:06,800
completely restores the extended state

453
00:16:04,959 --> 00:16:09,839
to a known value

454
00:16:06,800 --> 00:16:12,719
while open enclave uh only uh

455
00:16:09,839 --> 00:16:13,440
uh restored the specific register that

456
00:16:12,720 --> 00:16:16,800
was affected

457
00:16:13,440 --> 00:16:17,839
the mxcsr instruction um and so let's

458
00:16:16,800 --> 00:16:19,519
just skip over the next

459
00:16:17,839 --> 00:16:20,880
few slides here because i just want to

460
00:16:19,519 --> 00:16:22,160
give you the idea that this was not

461
00:16:20,880 --> 00:16:24,320
enough so um

462
00:16:22,160 --> 00:16:25,199
you could we could we found out that

463
00:16:24,320 --> 00:16:28,560
even if you

464
00:16:25,199 --> 00:16:29,199
uh uh restore this specific specific

465
00:16:28,560 --> 00:16:31,599
register

466
00:16:29,199 --> 00:16:32,639
there's still another data register uh

467
00:16:31,600 --> 00:16:34,320
that you can just

468
00:16:32,639 --> 00:16:36,000
mark as in use before entering the

469
00:16:34,320 --> 00:16:39,360
enclave and

470
00:16:36,000 --> 00:16:42,800
with which the attacker can

471
00:16:39,360 --> 00:16:44,480
make that any floating point calculation

472
00:16:42,800 --> 00:16:47,279
results in another number and this is

473
00:16:44,480 --> 00:16:48,959
silent so this is not programming

474
00:16:47,279 --> 00:16:50,639
language specific this is not developer

475
00:16:48,959 --> 00:16:53,599
specific this is a silent

476
00:16:50,639 --> 00:16:54,560
api issue that the calculations are just

477
00:16:53,600 --> 00:16:57,680
not a number

478
00:16:54,560 --> 00:17:01,040
so we also reported this and now

479
00:16:57,680 --> 00:17:03,040
thankfully all

480
00:17:01,040 --> 00:17:04,480
enclave runtimes use this full x3 store

481
00:17:03,040 --> 00:17:06,799
instruction to fully

482
00:17:04,480 --> 00:17:07,919
restore this extended stage so it took

483
00:17:06,799 --> 00:17:11,359
two cvs

484
00:17:07,919 --> 00:17:11,919
but now luckily they all perform this

485
00:17:11,359 --> 00:17:14,719
nice

486
00:17:11,919 --> 00:17:17,280
full restore so i don't want to go to

487
00:17:14,720 --> 00:17:19,439
the full details of our use cases now or

488
00:17:17,280 --> 00:17:21,039
for case studies that we did now and so

489
00:17:19,439 --> 00:17:23,439
let me just

490
00:17:21,039 --> 00:17:24,559
give you the ideas of these case studies

491
00:17:23,439 --> 00:17:28,160
so um

492
00:17:24,559 --> 00:17:30,160
we we looked at these issues and

493
00:17:28,160 --> 00:17:32,720
and wanted to to look into whether they

494
00:17:30,160 --> 00:17:36,640
just feel difficult or whether they are

495
00:17:32,720 --> 00:17:39,760
a bad and we found that

496
00:17:36,640 --> 00:17:40,880
we can use overflows as a side channel

497
00:17:39,760 --> 00:17:43,679
to deduce secrets

498
00:17:40,880 --> 00:17:46,799
so for example the attacker could use

499
00:17:43,679 --> 00:17:50,400
this register to unmask exceptions

500
00:17:46,799 --> 00:17:53,918
was that that inside the enclave

501
00:17:50,400 --> 00:17:57,200
are then triggered by

502
00:17:53,919 --> 00:17:59,520
some input dependent multiplication

503
00:17:57,200 --> 00:18:00,320
and we found out that these side

504
00:17:59,520 --> 00:18:01,440
channels

505
00:18:00,320 --> 00:18:04,240
if you have some input dependent

506
00:18:01,440 --> 00:18:07,280
multiplication can actually be used

507
00:18:04,240 --> 00:18:10,480
in the enclave to

508
00:18:07,280 --> 00:18:12,480
perform a binary search on

509
00:18:10,480 --> 00:18:14,160
this input space and we can actually

510
00:18:12,480 --> 00:18:16,240
retrieve this

511
00:18:14,160 --> 00:18:18,240
multiplication secret um with a

512
00:18:16,240 --> 00:18:19,840
deterministic number of steps

513
00:18:18,240 --> 00:18:22,400
uh so even though we are just there for

514
00:18:19,840 --> 00:18:25,520
like a single uh mask

515
00:18:22,400 --> 00:18:26,240
we flip we can actually retrieve the

516
00:18:25,520 --> 00:18:29,520
secret

517
00:18:26,240 --> 00:18:32,160
with deterministic steps um and

518
00:18:29,520 --> 00:18:33,679
just for the uh just just so that you

519
00:18:32,160 --> 00:18:36,400
know there's more you can do

520
00:18:33,679 --> 00:18:37,760
um we can also do machine learning in

521
00:18:36,400 --> 00:18:40,799
the enclave so if

522
00:18:37,760 --> 00:18:41,360
you set it nicely you can run it inside

523
00:18:40,799 --> 00:18:44,639
the

524
00:18:41,360 --> 00:18:45,678
te inside the cloud and that's great for

525
00:18:44,640 --> 00:18:47,760
machine learning right

526
00:18:45,679 --> 00:18:48,960
so let's do a hand version digit

527
00:18:47,760 --> 00:18:52,559
recognition

528
00:18:48,960 --> 00:18:56,240
and if you look at just the model

529
00:18:52,559 --> 00:18:58,960
that we look at we just have two users

530
00:18:56,240 --> 00:19:00,320
where one user uh pushes some some

531
00:18:58,960 --> 00:19:02,240
machine learning model and the other

532
00:19:00,320 --> 00:19:04,639
user pushes some input

533
00:19:02,240 --> 00:19:07,280
and everything is protected with

534
00:19:04,640 --> 00:19:10,080
enclaves right so everything is secure

535
00:19:07,280 --> 00:19:12,000
um but we actually found out that we can

536
00:19:10,080 --> 00:19:15,280
poison these fpu registers

537
00:19:12,000 --> 00:19:17,919
and degrade uh the uh performance

538
00:19:15,280 --> 00:19:19,840
of this machine learning down from all

539
00:19:17,919 --> 00:19:22,640
digits were treated correctly

540
00:19:19,840 --> 00:19:24,000
to just eight digits where eight percent

541
00:19:22,640 --> 00:19:27,280
of digits work correctly

542
00:19:24,000 --> 00:19:30,720
and actually uh all digits were just uh

543
00:19:27,280 --> 00:19:32,399
uh predicted the same same number uh and

544
00:19:30,720 --> 00:19:34,080
this basically made this machine

545
00:19:32,400 --> 00:19:36,880
learning model uh useless

546
00:19:34,080 --> 00:19:37,600
right um there's more we did so we can

547
00:19:36,880 --> 00:19:39,919
also

548
00:19:37,600 --> 00:19:42,399
attack blender with image differences

549
00:19:39,919 --> 00:19:45,039
slight image differences between blender

550
00:19:42,400 --> 00:19:45,840
images um but but that's just for you to

551
00:19:45,039 --> 00:19:48,799
see that

552
00:19:45,840 --> 00:19:49,678
is small but it's it's a tricky thing

553
00:19:48,799 --> 00:19:52,799
and intricate

554
00:19:49,679 --> 00:19:56,080
that can go wrong very fast

555
00:19:52,799 --> 00:19:57,520
on the api level once you yeah once you

556
00:19:56,080 --> 00:20:01,360
play around with it

557
00:19:57,520 --> 00:20:03,200
so this is about the cpu state and now

558
00:20:01,360 --> 00:20:05,039
we will talk more about the application

559
00:20:03,200 --> 00:20:07,520
programming interface that i think

560
00:20:05,039 --> 00:20:08,720
more of you will be comfortable with

561
00:20:07,520 --> 00:20:11,360
yeah we take uh

562
00:20:08,720 --> 00:20:13,440
uh thank you fritz we take a quite a

563
00:20:11,360 --> 00:20:14,879
simple example so let's assume that we

564
00:20:13,440 --> 00:20:16,799
actually load the standard

565
00:20:14,880 --> 00:20:18,559
unix binary into such an enclave and

566
00:20:16,799 --> 00:20:21,120
there are frameworks that can do that

567
00:20:18,559 --> 00:20:23,678
such as a graphene or so

568
00:20:21,120 --> 00:20:25,600
and what what i want to illustrate with

569
00:20:23,679 --> 00:20:27,840
that example is that it's actually very

570
00:20:25,600 --> 00:20:28,480
important to check where point has come

571
00:20:27,840 --> 00:20:30,480
from

572
00:20:28,480 --> 00:20:32,400
because the enclave kind of partitions

573
00:20:30,480 --> 00:20:35,600
the memory into untrusted memory and

574
00:20:32,400 --> 00:20:38,799
enclave memory and they live in a shared

575
00:20:35,600 --> 00:20:39,439
and shared address space so the problem

576
00:20:38,799 --> 00:20:41,200
here is

577
00:20:39,440 --> 00:20:44,000
as follows let's assume we have an echo

578
00:20:41,200 --> 00:20:46,720
binaries that just prints an input

579
00:20:44,000 --> 00:20:48,000
and we give it as you know an argument

580
00:20:46,720 --> 00:20:50,880
string and that normally

581
00:20:48,000 --> 00:20:53,120
in when when everything is fine points

582
00:20:50,880 --> 00:20:53,520
to some string let's say uh hello world

583
00:20:53,120 --> 00:20:56,639
which

584
00:20:53,520 --> 00:20:57,360
is located in the untrusted memory so if

585
00:20:56,640 --> 00:21:00,000
everything

586
00:20:57,360 --> 00:21:01,760
runs as it uh should this enclave will

587
00:21:00,000 --> 00:21:03,039
run will get the pointer to untrusted

588
00:21:01,760 --> 00:21:05,679
memory and will

589
00:21:03,039 --> 00:21:08,000
just print print set string but the

590
00:21:05,679 --> 00:21:11,520
problem is now actually the enclave has

591
00:21:08,000 --> 00:21:14,240
access also to its own trusted memory

592
00:21:11,520 --> 00:21:16,559
so uh if you don't check this pointer

593
00:21:14,240 --> 00:21:18,159
and the attacker passes a pointer to the

594
00:21:16,559 --> 00:21:20,480
secret that might live in

595
00:21:18,159 --> 00:21:21,520
uh enclave memory what will happen where

596
00:21:20,480 --> 00:21:23,919
the enclave will

597
00:21:21,520 --> 00:21:25,600
fetch it from there and we'll just print

598
00:21:23,919 --> 00:21:27,440
it so suddenly you have turned this kind

599
00:21:25,600 --> 00:21:30,799
of like into a

600
00:21:27,440 --> 00:21:33,120
like a memory disclosure vulnerability

601
00:21:30,799 --> 00:21:35,280
now and we can see that in action here

602
00:21:33,120 --> 00:21:36,959
for the framework named graphene that i

603
00:21:35,280 --> 00:21:37,678
mentioned so we have a very simple hello

604
00:21:36,960 --> 00:21:40,080
world uh

605
00:21:37,679 --> 00:21:41,760
binary and we run it with a couple of

606
00:21:40,080 --> 00:21:44,080
command line arguments and now

607
00:21:41,760 --> 00:21:46,158
in on the untrusted side we actually

608
00:21:44,080 --> 00:21:47,439
change a memory address to point into

609
00:21:46,159 --> 00:21:48,880
enclave memory

610
00:21:47,440 --> 00:21:51,360
and as you can see normally it should

611
00:21:48,880 --> 00:21:53,600
print here test but actually it prints a

612
00:21:51,360 --> 00:21:56,080
super secret enclave strings that

613
00:21:53,600 --> 00:21:59,199
lift a lift inside the memory space of

614
00:21:56,080 --> 00:22:00,720
the of the enclave

615
00:21:59,200 --> 00:22:02,559
so these kind of vulnerabilities are

616
00:22:00,720 --> 00:22:04,720
quite well known from user

617
00:22:02,559 --> 00:22:06,399
to kernel research and from other

618
00:22:04,720 --> 00:22:08,640
instances and they're called confused

619
00:22:06,400 --> 00:22:11,039
deputies so the deputy

620
00:22:08,640 --> 00:22:12,559
kind of like has a gun here can read the

621
00:22:11,039 --> 00:22:14,879
uh enclave memory

622
00:22:12,559 --> 00:22:16,080
and uh suddenly then does something

623
00:22:14,880 --> 00:22:17,520
which is uh not

624
00:22:16,080 --> 00:22:19,360
not supposed to do because he didn't

625
00:22:17,520 --> 00:22:20,480
really didn't really check where the

626
00:22:19,360 --> 00:22:22,399
memory uh should

627
00:22:20,480 --> 00:22:24,240
belong or not so i think this

628
00:22:22,400 --> 00:22:27,039
vulnerability uh

629
00:22:24,240 --> 00:22:28,960
seems seems to be quite trivial to solve

630
00:22:27,039 --> 00:22:31,520
and you simply check all the time where

631
00:22:28,960 --> 00:22:32,720
uh where pointers come from but seo will

632
00:22:31,520 --> 00:22:36,000
tell you know it's uh

633
00:22:32,720 --> 00:22:38,159
often not quite quite that easy

634
00:22:36,000 --> 00:22:40,000
yes david that's quite insightful right

635
00:22:38,159 --> 00:22:41,760
we should check all of the pointers

636
00:22:40,000 --> 00:22:43,440
uh so that's what we did we checked all

637
00:22:41,760 --> 00:22:45,039
of the pointer checks and

638
00:22:43,440 --> 00:22:47,039
we noticed that intel has a very

639
00:22:45,039 --> 00:22:47,919
interesting kind of algorithm to check

640
00:22:47,039 --> 00:22:49,360
these things of course

641
00:22:47,919 --> 00:22:51,280
the intel code is high quality they

642
00:22:49,360 --> 00:22:52,799
checked all of the pointers but you have

643
00:22:51,280 --> 00:22:54,000
to do something special for strings

644
00:22:52,799 --> 00:22:56,000
right and we're talking here

645
00:22:54,000 --> 00:22:57,280
the c programming language so strings

646
00:22:56,000 --> 00:22:59,440
are null terminated

647
00:22:57,280 --> 00:23:01,760
terminated they end with the null bytes

648
00:22:59,440 --> 00:23:02,400
and you can use the function stln string

649
00:23:01,760 --> 00:23:03,919
length

650
00:23:02,400 --> 00:23:05,280
to compute the length of this thing and

651
00:23:03,919 --> 00:23:06,960
let's see how they check whether your

652
00:23:05,280 --> 00:23:08,000
string lights completely outside of

653
00:23:06,960 --> 00:23:10,240
enclave memory

654
00:23:08,000 --> 00:23:12,240
so the first step is you compute the

655
00:23:10,240 --> 00:23:13,760
length of the interested string

656
00:23:12,240 --> 00:23:15,280
and then you check whether the string

657
00:23:13,760 --> 00:23:17,200
from start to end

658
00:23:15,280 --> 00:23:18,320
lies completely outside of the ankle

659
00:23:17,200 --> 00:23:20,080
that sounds legit

660
00:23:18,320 --> 00:23:21,520
right then you reject the string so so

661
00:23:20,080 --> 00:23:23,600
this works beautifully

662
00:23:21,520 --> 00:23:25,280
let's see however how it behaves when

663
00:23:23,600 --> 00:23:26,559
when we pass on the legal stream right

664
00:23:25,280 --> 00:23:28,320
so we are not going to pass this thing

665
00:23:26,559 --> 00:23:31,039
hello world outside of the enclave

666
00:23:28,320 --> 00:23:33,678
that we pass some string secret one that

667
00:23:31,039 --> 00:23:35,600
that lies within the ankle

668
00:23:33,679 --> 00:23:37,600
so the first step will be that the

669
00:23:35,600 --> 00:23:39,678
enclave starts computing the length of

670
00:23:37,600 --> 00:23:42,000
that string that lies within the anklet

671
00:23:39,679 --> 00:23:43,679
right and that sounds already fishy but

672
00:23:42,000 --> 00:23:44,960
then luckily everything comes okay

673
00:23:43,679 --> 00:23:46,400
because then it will detect

674
00:23:44,960 --> 00:23:47,760
that this actually should never have

675
00:23:46,400 --> 00:23:49,679
been done and that the string lies

676
00:23:47,760 --> 00:23:52,080
inside the enclave so it will reject

677
00:23:49,679 --> 00:23:53,200
the the eagle so the the call into the

678
00:23:52,080 --> 00:23:55,678
enclave

679
00:23:53,200 --> 00:23:57,200
so that's fine but but some of you who

680
00:23:55,679 --> 00:23:58,720
know side channels know that this is

681
00:23:57,200 --> 00:24:00,480
exciting right because

682
00:23:58,720 --> 00:24:02,400
the enclave did some computation it was

683
00:24:00,480 --> 00:24:04,480
never supposed to do and the length of

684
00:24:02,400 --> 00:24:05,200
that computation depends on the amount

685
00:24:04,480 --> 00:24:08,480
of

686
00:24:05,200 --> 00:24:10,559
of non-zero bytes within the enclave

687
00:24:08,480 --> 00:24:11,679
right so what we have here is a side

688
00:24:10,559 --> 00:24:14,799
channel where

689
00:24:11,679 --> 00:24:16,960
the enclave will always return false but

690
00:24:14,799 --> 00:24:18,320
the time it takes to return false

691
00:24:16,960 --> 00:24:20,880
depends on

692
00:24:18,320 --> 00:24:23,039
the amount of of zero bytes inside that

693
00:24:20,880 --> 00:24:24,880
secret enclave memory block

694
00:24:23,039 --> 00:24:26,320
so that that's what we found we were

695
00:24:24,880 --> 00:24:27,840
excited and we said okay let's

696
00:24:26,320 --> 00:24:29,360
simple timing channel let's call it

697
00:24:27,840 --> 00:24:32,000
other so we did that

698
00:24:29,360 --> 00:24:33,600
um and you can see a graph here and and

699
00:24:32,000 --> 00:24:35,360
it turns out it's not as easy as it

700
00:24:33,600 --> 00:24:36,320
seems right so i can tell you that the

701
00:24:35,360 --> 00:24:37,840
blue one is

702
00:24:36,320 --> 00:24:39,439
for a string of length one and the red

703
00:24:37,840 --> 00:24:40,879
one is for a string of length two but

704
00:24:39,440 --> 00:24:41,919
there is no way you can see that from

705
00:24:40,880 --> 00:24:44,240
that graph

706
00:24:41,919 --> 00:24:46,400
because x86 processors are lightning

707
00:24:44,240 --> 00:24:47,679
fast so that one single increment

708
00:24:46,400 --> 00:24:49,760
instruction is completely

709
00:24:47,679 --> 00:24:52,000
uh dissolves into the pipeline you will

710
00:24:49,760 --> 00:24:52,559
not see that by by measuring execution

711
00:24:52,000 --> 00:24:54,480
time

712
00:24:52,559 --> 00:24:57,200
so we need something different and and

713
00:24:54,480 --> 00:24:59,760
and well we are smart so we hit papers

714
00:24:57,200 --> 00:25:02,000
and uh uh in literature one of the very

715
00:24:59,760 --> 00:25:03,919
common attacks in uh sjx is also

716
00:25:02,000 --> 00:25:07,120
something that intel describes here

717
00:25:03,919 --> 00:25:09,440
you can see which memory pages uh 4k

718
00:25:07,120 --> 00:25:10,719
memory blocks are being accessed while

719
00:25:09,440 --> 00:25:13,039
the enclave executes

720
00:25:10,720 --> 00:25:14,720
because you control the operating system

721
00:25:13,039 --> 00:25:16,720
and the paging machinery in there

722
00:25:14,720 --> 00:25:18,799
so so that's what we tried to do and we

723
00:25:16,720 --> 00:25:20,799
thought this is a nice side channel

724
00:25:18,799 --> 00:25:22,879
and and we were there sketching our head

725
00:25:20,799 --> 00:25:23,520
looking at that code a very simple for

726
00:25:22,880 --> 00:25:25,600
loop

727
00:25:23,520 --> 00:25:27,760
that fits entirely within one page and a

728
00:25:25,600 --> 00:25:28,799
very short string that fits entirely

729
00:25:27,760 --> 00:25:31,039
within one page

730
00:25:28,799 --> 00:25:32,799
so just having access to 4k memory

731
00:25:31,039 --> 00:25:35,840
regions it's not going to help us here

732
00:25:32,799 --> 00:25:36,720
right because because votes the code and

733
00:25:35,840 --> 00:25:38,799
the data fit

734
00:25:36,720 --> 00:25:40,159
on a single page so so this is

735
00:25:38,799 --> 00:25:42,400
essentially what we call

736
00:25:40,159 --> 00:25:43,279
the temporal resolution of the sideshow

737
00:25:42,400 --> 00:25:45,600
this is not

738
00:25:43,279 --> 00:25:47,039
accurate enough so we need another trick

739
00:25:45,600 --> 00:25:50,480
and uh

740
00:25:47,039 --> 00:25:51,840
well here we have been working on quite

741
00:25:50,480 --> 00:25:54,000
an exciting framework

742
00:25:51,840 --> 00:25:55,678
it uses interrupts and it's called sjx

743
00:25:54,000 --> 00:25:58,240
step so it's a completely open source

744
00:25:55,679 --> 00:26:00,400
framework on hitup

745
00:25:58,240 --> 00:26:01,279
and what it allows you to do essentially

746
00:26:00,400 --> 00:26:03,520
is to

747
00:26:01,279 --> 00:26:04,400
execute an enclave one step at a time

748
00:26:03,520 --> 00:26:05,918
hence the name

749
00:26:04,400 --> 00:26:07,520
so it allows you to interleave the

750
00:26:05,919 --> 00:26:08,080
execution of the enclave with attacker

751
00:26:07,520 --> 00:26:09,918
code

752
00:26:08,080 --> 00:26:11,918
after every single instruction and the

753
00:26:09,919 --> 00:26:13,679
way we pull it off is highly technical

754
00:26:11,919 --> 00:26:15,440
we have this linux kernel driver and a

755
00:26:13,679 --> 00:26:18,640
little library operating system

756
00:26:15,440 --> 00:26:20,080
um running in user space but that's a

757
00:26:18,640 --> 00:26:21,840
bit out of scope

758
00:26:20,080 --> 00:26:24,158
the matter is that we can interrupt an

759
00:26:21,840 --> 00:26:26,320
enclave after every single instruction

760
00:26:24,159 --> 00:26:29,200
and then let's see what we can do with

761
00:26:26,320 --> 00:26:30,879
dots so

762
00:26:29,200 --> 00:26:33,200
what we essentially can do here is to

763
00:26:30,880 --> 00:26:35,520
execute that for loop with all these x86

764
00:26:33,200 --> 00:26:37,520
increment instructions one at a time

765
00:26:35,520 --> 00:26:38,639
and after every interrupt we can simply

766
00:26:37,520 --> 00:26:41,679
check whether

767
00:26:38,640 --> 00:26:45,039
the uh enclave accessed the

768
00:26:41,679 --> 00:26:45,760
string residing at our targeted memory

769
00:26:45,039 --> 00:26:48,000
location

770
00:26:45,760 --> 00:26:49,200
another way to think about it is that we

771
00:26:48,000 --> 00:26:51,840
have that

772
00:26:49,200 --> 00:26:53,520
execution of the enclave and we can

773
00:26:51,840 --> 00:26:54,959
break that up into individual steps and

774
00:26:53,520 --> 00:26:57,120
then just count the steps

775
00:26:54,960 --> 00:26:58,320
and hence and hands have a deterministic

776
00:26:57,120 --> 00:27:00,799
uh iguana

777
00:26:58,320 --> 00:27:01,600
timing channel so in other words we have

778
00:27:00,799 --> 00:27:04,559
an oracle

779
00:27:01,600 --> 00:27:05,760
that tells you uh where all zero bytes

780
00:27:04,559 --> 00:27:07,200
are in the

781
00:27:05,760 --> 00:27:09,120
and i don't know if that's useful

782
00:27:07,200 --> 00:27:11,039
actually dave so

783
00:27:09,120 --> 00:27:12,799
turns out it is i mean some people who

784
00:27:11,039 --> 00:27:14,240
might be in into exploitation already

785
00:27:12,799 --> 00:27:17,039
know that it's good to know whether

786
00:27:14,240 --> 00:27:18,080
zero is somewhere in memory uh or not

787
00:27:17,039 --> 00:27:21,120
and we'll now

788
00:27:18,080 --> 00:27:21,840
do uh one example here we break a s and

789
00:27:21,120 --> 00:27:23,600
i which is

790
00:27:21,840 --> 00:27:25,520
which is the hardware acceleration of

791
00:27:23,600 --> 00:27:27,918
intel process for ai

792
00:27:25,520 --> 00:27:29,679
so finally that actually uh operates

793
00:27:27,919 --> 00:27:31,919
only on registers and i

794
00:27:29,679 --> 00:27:34,000
yo just said uh you can kind of like do

795
00:27:31,919 --> 00:27:35,840
that on on pointers on memory

796
00:27:34,000 --> 00:27:37,760
but there's another trick that comes

797
00:27:35,840 --> 00:27:38,959
into play here so whenever the enclave

798
00:27:37,760 --> 00:27:41,039
is interrupted

799
00:27:38,960 --> 00:27:43,360
it will store its current register state

800
00:27:41,039 --> 00:27:46,080
somewhere to memory called the ssa

801
00:27:43,360 --> 00:27:47,039
frame so we can actually interrupt the

802
00:27:46,080 --> 00:27:50,399
enclave

803
00:27:47,039 --> 00:27:52,799
make it write its memory to uh to uh

804
00:27:50,399 --> 00:27:53,678
it's it's register sorry to to ssa

805
00:27:52,799 --> 00:27:56,480
memory

806
00:27:53,679 --> 00:27:58,720
and then we can run the zero byte um

807
00:27:56,480 --> 00:28:00,080
oracle on the ssa memory and what we

808
00:27:58,720 --> 00:28:03,760
figure out is where

809
00:28:00,080 --> 00:28:06,000
zero is or if there's any 0 in the aes

810
00:28:03,760 --> 00:28:07,440
state so i don't want to go into the

811
00:28:06,000 --> 00:28:10,799
gory details of

812
00:28:07,440 --> 00:28:13,600
a s but what what we basically do is we

813
00:28:10,799 --> 00:28:16,960
find whenever there's a 0 in the last

814
00:28:13,600 --> 00:28:20,240
in the state before the last round of a

815
00:28:16,960 --> 00:28:22,320
s and then that zero will go

816
00:28:20,240 --> 00:28:23,919
down through the s box will be x or to a

817
00:28:22,320 --> 00:28:25,120
key byte and then that will give us a

818
00:28:23,919 --> 00:28:27,600
cipher text

819
00:28:25,120 --> 00:28:28,799
but we actually know the ciphertext byte

820
00:28:27,600 --> 00:28:32,080
and so we can

821
00:28:28,799 --> 00:28:34,559
go backwards so we can kind of compute

822
00:28:32,080 --> 00:28:35,360
we can compute from the zero up to here

823
00:28:34,559 --> 00:28:37,918
and

824
00:28:35,360 --> 00:28:40,320
from here to this axon and that way we

825
00:28:37,919 --> 00:28:43,360
can compute directly one key byte

826
00:28:40,320 --> 00:28:44,399
so we repeat that whole thing 16 times

827
00:28:43,360 --> 00:28:47,600
until we have found

828
00:28:44,399 --> 00:28:48,799
a zero in every byte of this uh state

829
00:28:47,600 --> 00:28:50,799
before the last round

830
00:28:48,799 --> 00:28:52,639
and that way we get the whole final

831
00:28:50,799 --> 00:28:55,279
round key and for those that

832
00:28:52,640 --> 00:28:57,120
know a s if you have a one round key you

833
00:28:55,279 --> 00:28:57,760
have the whole key in it so you get like

834
00:28:57,120 --> 00:29:01,439
the

835
00:28:57,760 --> 00:29:03,039
original key you can go backwards

836
00:29:01,440 --> 00:29:04,559
so sounds complicated but it's actually

837
00:29:03,039 --> 00:29:05,120
a very fast attack when you see it

838
00:29:04,559 --> 00:29:07,760
running

839
00:29:05,120 --> 00:29:09,840
so here is sjx step doing this attack

840
00:29:07,760 --> 00:29:14,080
and as you can see within a couple of

841
00:29:09,840 --> 00:29:16,959
seconds and maybe 520 invocations of

842
00:29:14,080 --> 00:29:18,559
of as here we get the full key so that's

843
00:29:16,960 --> 00:29:19,440
actually quite impressive especially

844
00:29:18,559 --> 00:29:22,240
because

845
00:29:19,440 --> 00:29:23,360
uh the whole uh yeah one of the points

846
00:29:22,240 --> 00:29:25,279
in asni

847
00:29:23,360 --> 00:29:27,199
is that you don't put anything in memory

848
00:29:25,279 --> 00:29:29,440
but there's this interaction with

849
00:29:27,200 --> 00:29:30,480
sjx which is kind of like allows you to

850
00:29:29,440 --> 00:29:34,720
put

851
00:29:30,480 --> 00:29:34,720
stuff into into memory

852
00:29:35,120 --> 00:29:42,239
so i want to wrap up here we have found

853
00:29:38,799 --> 00:29:45,120
various other attacks here so

854
00:29:42,240 --> 00:29:47,279
both in research code and in production

855
00:29:45,120 --> 00:29:48,158
codes such as the intel sdk and the

856
00:29:47,279 --> 00:29:51,600
microsoft

857
00:29:48,159 --> 00:29:53,520
sdk and they basically go across the

858
00:29:51,600 --> 00:29:55,600
whole range of vulnerabilities that

859
00:29:53,520 --> 00:29:56,960
we have often seen already from user to

860
00:29:55,600 --> 00:29:59,918
kernel research

861
00:29:56,960 --> 00:30:00,399
but there are also some some interesting

862
00:29:59,919 --> 00:30:02,399
new

863
00:30:00,399 --> 00:30:04,879
new kind of like vulnerabilities due to

864
00:30:02,399 --> 00:30:08,158
some of the aspects we explained

865
00:30:04,880 --> 00:30:10,159
there was also an a problem with oh

866
00:30:08,159 --> 00:30:12,640
calls that is when the enclave calls

867
00:30:10,159 --> 00:30:14,399
into untrusted code so that is used when

868
00:30:12,640 --> 00:30:17,440
you want to for instance emulate

869
00:30:14,399 --> 00:30:20,080
system calls and so on and if you return

870
00:30:17,440 --> 00:30:21,440
some kind of like a wrong result here

871
00:30:20,080 --> 00:30:23,678
you could again go

872
00:30:21,440 --> 00:30:24,880
out of out of bounds and they were

873
00:30:23,679 --> 00:30:28,240
actually uh quite

874
00:30:24,880 --> 00:30:31,039
quite uh widespread and then finally

875
00:30:28,240 --> 00:30:32,799
we also found some issues with padding

876
00:30:31,039 --> 00:30:34,960
with leakage in the padding

877
00:30:32,799 --> 00:30:36,480
i don't want to go into details i think

878
00:30:34,960 --> 00:30:38,720
we have uh

879
00:30:36,480 --> 00:30:39,600
learned uh a lesson here that that we

880
00:30:38,720 --> 00:30:41,360
always know from

881
00:30:39,600 --> 00:30:42,959
from the real world and that is it's

882
00:30:41,360 --> 00:30:43,840
important to wash your hands and so it's

883
00:30:42,960 --> 00:30:47,120
also important

884
00:30:43,840 --> 00:30:47,840
to sanitize enclave state to check

885
00:30:47,120 --> 00:30:50,879
pointers

886
00:30:47,840 --> 00:30:54,080
uh and so on no so uh that

887
00:30:50,880 --> 00:30:55,600
is kind of uh one one of the takeaway

888
00:30:54,080 --> 00:30:57,760
messages really is that

889
00:30:55,600 --> 00:30:59,600
to build enclave securely yes you need

890
00:30:57,760 --> 00:31:00,480
to fix all the hardware issues but you

891
00:30:59,600 --> 00:31:03,039
also need to

892
00:31:00,480 --> 00:31:04,399
write safe code and for enclaves that

893
00:31:03,039 --> 00:31:07,519
means you have

894
00:31:04,399 --> 00:31:08,399
to do proper abi and api sanitizations

895
00:31:07,519 --> 00:31:11,440
and that's quite

896
00:31:08,399 --> 00:31:13,039
a difficult task actually as

897
00:31:11,440 --> 00:31:15,760
as we've seen i think in in that

898
00:31:13,039 --> 00:31:15,760
presentation

899
00:31:15,919 --> 00:31:20,080
there's quite a large attack surface due

900
00:31:18,000 --> 00:31:22,320
to the attack model especially of intel

901
00:31:20,080 --> 00:31:24,080
sjx where you can interrupt after every

902
00:31:22,320 --> 00:31:26,320
uh instruction and so on

903
00:31:24,080 --> 00:31:28,240
and i think for from a resource research

904
00:31:26,320 --> 00:31:29,279
perspective there's really a need for a

905
00:31:28,240 --> 00:31:33,120
more principled

906
00:31:29,279 --> 00:31:35,039
uh approach than uh just buck hunting

907
00:31:33,120 --> 00:31:36,799
if you want maybe we can learn something

908
00:31:35,039 --> 00:31:39,440
from from the user to kernel

909
00:31:36,799 --> 00:31:40,559
analogy which which i invoked i think a

910
00:31:39,440 --> 00:31:43,440
couple of times

911
00:31:40,559 --> 00:31:43,678
so we can uh learn kind of like how what

912
00:31:43,440 --> 00:31:46,399
an

913
00:31:43,679 --> 00:31:46,799
enclave should do from from what we know

914
00:31:46,399 --> 00:31:48,879
about

915
00:31:46,799 --> 00:31:51,120
what a kernel should do but they are

916
00:31:48,880 --> 00:31:51,840
quite important uh differences also that

917
00:31:51,120 --> 00:31:54,639
need to be

918
00:31:51,840 --> 00:31:55,199
taken account so i think as you uh said

919
00:31:54,640 --> 00:31:57,760
all

920
00:31:55,200 --> 00:31:58,799
all our code is uh is open source so you

921
00:31:57,760 --> 00:32:01,279
can find that

922
00:31:58,799 --> 00:32:02,158
on on the below github links and you can

923
00:32:01,279 --> 00:32:05,360
of course ask

924
00:32:02,159 --> 00:32:09,440
also questions after you've

925
00:32:05,360 --> 00:32:09,439
watched this talk so thank you very much

926
00:32:10,000 --> 00:32:16,799
hello so back again here

927
00:32:13,039 --> 00:32:19,679
are the questions hello to see you live

928
00:32:16,799 --> 00:32:22,240
um we have no questions yet so you can

929
00:32:19,679 --> 00:32:23,919
put up questions in the irc below if you

930
00:32:22,240 --> 00:32:27,919
have questions

931
00:32:23,919 --> 00:32:29,120
and on the other hand oh let me make

932
00:32:27,919 --> 00:32:32,159
close this up

933
00:32:29,120 --> 00:32:34,239
so i'll ask you some questions

934
00:32:32,159 --> 00:32:37,039
how did you come about this topic and

935
00:32:34,240 --> 00:32:37,039
how did you meet

936
00:32:39,120 --> 00:32:43,120
well that's actually interesting i think

937
00:32:40,799 --> 00:32:46,480
this research has has uh

938
00:32:43,120 --> 00:32:50,000
been building up over the years um

939
00:32:46,480 --> 00:32:52,320
and there is some so so i think

940
00:32:50,000 --> 00:32:53,840
some some of the vulnerabilities uh from

941
00:32:52,320 --> 00:32:55,678
our initial paper

942
00:32:53,840 --> 00:32:57,439
i actually already started in my master

943
00:32:55,679 --> 00:32:59,600
thesis to sort of

944
00:32:57,440 --> 00:33:00,799
see and collect and we didn't really see

945
00:32:59,600 --> 00:33:03,360
the big picture

946
00:33:00,799 --> 00:33:04,960
until i think i met david and his

947
00:33:03,360 --> 00:33:07,439
colleagues from birmingham

948
00:33:04,960 --> 00:33:08,320
at an event in london the rice

949
00:33:07,440 --> 00:33:10,080
conference

950
00:33:08,320 --> 00:33:11,439
and then we we started to collaborate on

951
00:33:10,080 --> 00:33:12,639
this and too and to look at is a bit

952
00:33:11,440 --> 00:33:14,080
more systematic

953
00:33:12,640 --> 00:33:16,080
so i started with this whole list of

954
00:33:14,080 --> 00:33:17,840
vulnerabilities and then with david

955
00:33:16,080 --> 00:33:19,199
we kind of made it into a more

956
00:33:17,840 --> 00:33:21,600
systematic analysis

957
00:33:19,200 --> 00:33:22,799
and and uh and that was sort of a

958
00:33:21,600 --> 00:33:25,360
pandora's box

959
00:33:22,799 --> 00:33:26,080
i dare to say from that moment on this

960
00:33:25,360 --> 00:33:29,600
this kind of

961
00:33:26,080 --> 00:33:32,000
same errors keep being repeated uh

962
00:33:29,600 --> 00:33:33,120
and then also fritz who recently joined

963
00:33:32,000 --> 00:33:35,679
our team in leuven

964
00:33:33,120 --> 00:33:37,600
uh started working together with us on

965
00:33:35,679 --> 00:33:38,000
on more of this low-level cpu state and

966
00:33:37,600 --> 00:33:41,279
that's

967
00:33:38,000 --> 00:33:42,880
uh pandora's booking boxing itself i

968
00:33:41,279 --> 00:33:44,720
would say especially

969
00:33:42,880 --> 00:33:47,120
one of the lessons as we say there that

970
00:33:44,720 --> 00:33:48,640
x86 is extremely complex and

971
00:33:47,120 --> 00:33:50,239
it turns out that almost all of that

972
00:33:48,640 --> 00:33:53,279
complexity i would say

973
00:33:50,240 --> 00:33:55,120
can be abused potentially by adversities

974
00:33:53,279 --> 00:33:56,799
so it's more like a fractal and a

975
00:33:55,120 --> 00:33:58,479
fractal and a fractal yeah you're

976
00:33:56,799 --> 00:33:59,440
opening a box and you're getting more

977
00:33:58,480 --> 00:34:02,480
and more of

978
00:33:59,440 --> 00:34:02,480
questions out of that

979
00:34:02,720 --> 00:34:07,679
in a way i think yes i think it's fair

980
00:34:06,240 --> 00:34:08,560
to say this this research is not the

981
00:34:07,679 --> 00:34:11,520
final answer

982
00:34:08,560 --> 00:34:12,078
to to this but it's rather uh an attempt

983
00:34:11,520 --> 00:34:14,079
to to

984
00:34:12,079 --> 00:34:16,079
to give a systematic way of looking at

985
00:34:14,079 --> 00:34:18,800
other probably never-ending attacker

986
00:34:16,079 --> 00:34:18,800
defenders

987
00:34:19,119 --> 00:34:22,240
so uh there is a question from the

988
00:34:21,359 --> 00:34:24,799
internet so

989
00:34:22,239 --> 00:34:25,678
are there any other circumstances where

990
00:34:24,800 --> 00:34:29,599
aes

991
00:34:25,679 --> 00:34:31,040
minus any is writing its registers into

992
00:34:29,599 --> 00:34:35,839
memory or is this

993
00:34:31,040 --> 00:34:35,839
execute exclusive to sgx

994
00:34:36,960 --> 00:34:42,879
should i repeat i do not understand the

995
00:34:40,480 --> 00:34:45,599
question either

996
00:34:42,879 --> 00:34:48,239
so so well i think the question is that

997
00:34:45,599 --> 00:34:50,720
this ais attack that david presented

998
00:34:48,239 --> 00:34:52,560
depends on of course um having a memory

999
00:34:50,719 --> 00:34:54,719
disclosure attack to hit the register's

1000
00:34:52,560 --> 00:34:56,399
content and we pulled it off using sg

1001
00:34:54,719 --> 00:34:58,078
step to kind of forcibly write

1002
00:34:56,399 --> 00:34:59,440
the memory content uh the registered

1003
00:34:58,079 --> 00:35:02,640
content into memory

1004
00:34:59,440 --> 00:35:05,040
um so that is definitely specific

1005
00:35:02,640 --> 00:35:05,920
um however i would say one of the the

1006
00:35:05,040 --> 00:35:07,599
lessons from

1007
00:35:05,920 --> 00:35:09,040
let's say the past five years of sgx

1008
00:35:07,599 --> 00:35:10,960
research is that often these things

1009
00:35:09,040 --> 00:35:12,800
generalize beyond sgx and

1010
00:35:10,960 --> 00:35:14,320
at least the general concept of the

1011
00:35:12,800 --> 00:35:17,040
let's say the insight that

1012
00:35:14,320 --> 00:35:17,760
cpu registers end up in memory one way

1013
00:35:17,040 --> 00:35:19,599
or another

1014
00:35:17,760 --> 00:35:21,200
sooner or later i think that also

1015
00:35:19,599 --> 00:35:22,079
applies to operating systems right if

1016
00:35:21,200 --> 00:35:23,759
you

1017
00:35:22,079 --> 00:35:25,280
somehow can force an operating system to

1018
00:35:23,760 --> 00:35:26,880
context switch between two applications

1019
00:35:25,280 --> 00:35:28,960
it will also have to

1020
00:35:26,880 --> 00:35:30,960
dump the register content temporarily in

1021
00:35:28,960 --> 00:35:32,480
memory so if you would have

1022
00:35:30,960 --> 00:35:34,640
something similar like what we have in

1023
00:35:32,480 --> 00:35:36,880
an operating system kernel

1024
00:35:34,640 --> 00:35:39,279
you would potentially mind a similar

1025
00:35:36,880 --> 00:35:40,560
attack but maybe david wants to say

1026
00:35:39,280 --> 00:35:43,680
something uh

1027
00:35:40,560 --> 00:35:44,000
about operating systems there as well no

1028
00:35:43,680 --> 00:35:46,000
no

1029
00:35:44,000 --> 00:35:47,200
not really i think like one one thing

1030
00:35:46,000 --> 00:35:49,119
that helps with

1031
00:35:47,200 --> 00:35:51,359
sgx is that you have very precise

1032
00:35:49,119 --> 00:35:52,800
control as seo explained with with

1033
00:35:51,359 --> 00:35:55,680
interrupts and stuff

1034
00:35:52,800 --> 00:35:56,800
because you you root outside the outside

1035
00:35:55,680 --> 00:35:58,799
the enclave

1036
00:35:56,800 --> 00:36:01,599
so you can single step essentially the

1037
00:35:58,800 --> 00:36:03,839
whole enclave where it's like

1038
00:36:01,599 --> 00:36:06,240
interrupting the operating system at

1039
00:36:03,839 --> 00:36:07,119
exactly repeatedly at exactly the point

1040
00:36:06,240 --> 00:36:09,919
you want or

1041
00:36:07,119 --> 00:36:10,640
some other process or so tends to be

1042
00:36:09,920 --> 00:36:13,040
probably

1043
00:36:10,640 --> 00:36:14,879
uh probably harder just by design but of

1044
00:36:13,040 --> 00:36:17,040
course on a context switch

1045
00:36:14,880 --> 00:36:18,400
cpu has to save somewhere it's it's

1046
00:36:17,040 --> 00:36:21,119
register set and then

1047
00:36:18,400 --> 00:36:22,240
then it will end up in in memory in some

1048
00:36:21,119 --> 00:36:24,800
situations

1049
00:36:22,240 --> 00:36:27,839
probably not not as controlled as as it

1050
00:36:24,800 --> 00:36:27,839
is for for sjx

1051
00:36:29,280 --> 00:36:33,760
so uh there is the question what about

1052
00:36:32,079 --> 00:36:36,390
other cpu architectures

1053
00:36:33,760 --> 00:36:38,400
other than intel did you test those

1054
00:36:36,390 --> 00:36:40,960
[Music]

1055
00:36:38,400 --> 00:36:42,320
so maybe i can i can go into this so uh

1056
00:36:40,960 --> 00:36:44,640
well intel's gx is the

1057
00:36:42,320 --> 00:36:46,240
uh let's say uh largest one with the

1058
00:36:44,640 --> 00:36:48,240
largest software base

1059
00:36:46,240 --> 00:36:50,319
and the most enclave shooting runtimes

1060
00:36:48,240 --> 00:36:52,799
that is also that we could look at right

1061
00:36:50,320 --> 00:36:53,359
um but uh there are of course some other

1062
00:36:52,800 --> 00:36:56,960
software

1063
00:36:53,359 --> 00:36:58,640
we have or this internal te

1064
00:36:56,960 --> 00:37:00,079
that we developed at suncoast some years

1065
00:36:58,640 --> 00:37:03,040
ago it's called sankus

1066
00:37:00,079 --> 00:37:04,560
um and of course for for these uh there

1067
00:37:03,040 --> 00:37:07,279
are similar issues right so

1068
00:37:04,560 --> 00:37:09,279
you always need the software layer uh to

1069
00:37:07,280 --> 00:37:11,920
interact

1070
00:37:09,280 --> 00:37:13,200
to enter the enclave and to access the

1071
00:37:11,920 --> 00:37:15,760
enclave

1072
00:37:13,200 --> 00:37:16,879
and i think you and david in the earlier

1073
00:37:15,760 --> 00:37:19,920
work also found

1074
00:37:16,880 --> 00:37:23,920
issues in our te so it's not

1075
00:37:19,920 --> 00:37:26,720
just intel and really related projects

1076
00:37:23,920 --> 00:37:28,240
that mess up there of course um but what

1077
00:37:26,720 --> 00:37:29,200
we like definitely found is that it's

1078
00:37:28,240 --> 00:37:32,720
easier

1079
00:37:29,200 --> 00:37:35,040
to to think of all edge cases

1080
00:37:32,720 --> 00:37:36,399
for simpler designs like risk 5 or

1081
00:37:35,040 --> 00:37:39,359
simpler risk designs

1082
00:37:36,400 --> 00:37:40,079
than for this complex x86 uh

1083
00:37:39,359 --> 00:37:42,240
architecture

1084
00:37:40,079 --> 00:37:43,920
right so um right now there are not that

1085
00:37:42,240 --> 00:37:46,640
many besides intellect jacks

1086
00:37:43,920 --> 00:37:48,480
so so they have the advantage and and

1087
00:37:46,640 --> 00:37:50,160
disadvantage of being the first uh

1088
00:37:48,480 --> 00:37:54,320
widely deployed let's say

1089
00:37:50,160 --> 00:37:57,118
um but i think as soon as others

1090
00:37:54,320 --> 00:37:58,400
like start to to grow out and and

1091
00:37:57,119 --> 00:38:00,560
simpler designs start to

1092
00:37:58,400 --> 00:38:02,400
uh be more common i think we will see

1093
00:38:00,560 --> 00:38:04,120
this that it's it's easier to fix all

1094
00:38:02,400 --> 00:38:07,680
edge cases for simpler designs

1095
00:38:04,120 --> 00:38:11,200
[Music]

1096
00:38:07,680 --> 00:38:13,520
okay so what is a reasonable alternative

1097
00:38:11,200 --> 00:38:17,040
to the

1098
00:38:13,520 --> 00:38:21,040
or is there any you do you want to

1099
00:38:17,040 --> 00:38:24,320
take that or um should i say what

1100
00:38:21,040 --> 00:38:26,640
uh well we can probably both give our

1101
00:38:24,320 --> 00:38:30,160
perspectives so i i think

1102
00:38:26,640 --> 00:38:31,520
um well the questions

1103
00:38:30,160 --> 00:38:33,279
to start with of course is do we need an

1104
00:38:31,520 --> 00:38:35,359
alternative or do we need to find more

1105
00:38:33,280 --> 00:38:35,920
systematic ways to to to sanitize the

1106
00:38:35,359 --> 00:38:37,279
software

1107
00:38:35,920 --> 00:38:39,200
that's i think one one part of the

1108
00:38:37,280 --> 00:38:40,079
answer here that we don't have to

1109
00:38:39,200 --> 00:38:41,919
necessarily

1110
00:38:40,079 --> 00:38:43,359
throw away tes because we have problems

1111
00:38:41,920 --> 00:38:44,640
with them we can also look at how to

1112
00:38:43,359 --> 00:38:46,000
solve those problems

1113
00:38:44,640 --> 00:38:47,920
but apart from that there is some

1114
00:38:46,000 --> 00:38:49,599
exciting research um

1115
00:38:47,920 --> 00:38:51,760
but maybe david also wants to say a bit

1116
00:38:49,599 --> 00:38:54,800
more about for instance on capabilities

1117
00:38:51,760 --> 00:38:56,480
that that's that's um that are

1118
00:38:54,800 --> 00:38:58,160
in a way not so different than tes

1119
00:38:56,480 --> 00:38:59,280
necessarily yeah but but uh

1120
00:38:58,160 --> 00:39:00,720
when you have hydro support for

1121
00:38:59,280 --> 00:39:03,200
capabilities like like the cherry

1122
00:39:00,720 --> 00:39:05,598
project in cambridge which essentially

1123
00:39:03,200 --> 00:39:07,279
associates metadata to a pointer

1124
00:39:05,599 --> 00:39:09,359
metadata like permission checks

1125
00:39:07,280 --> 00:39:11,520
then then you could at least for a

1126
00:39:09,359 --> 00:39:13,279
sub-clause of the issues we talked about

1127
00:39:11,520 --> 00:39:15,680
pointer poisoning attacks you could

1128
00:39:13,280 --> 00:39:18,320
natively catch those uh

1129
00:39:15,680 --> 00:39:18,720
with hardware supports but but it's a

1130
00:39:18,320 --> 00:39:20,560
very

1131
00:39:18,720 --> 00:39:21,839
high level idea maybe david wants to say

1132
00:39:20,560 --> 00:39:24,480
something

1133
00:39:21,839 --> 00:39:24,960
yeah so so i think like alternative to

1134
00:39:24,480 --> 00:39:27,280
uh

1135
00:39:24,960 --> 00:39:28,000
tee is it's whenever you want to

1136
00:39:27,280 --> 00:39:30,480
partition your

1137
00:39:28,000 --> 00:39:32,560
system into into parts which is i think

1138
00:39:30,480 --> 00:39:35,040
a good idea and everybody's now

1139
00:39:32,560 --> 00:39:35,839
doing that also in in their how how we

1140
00:39:35,040 --> 00:39:39,279
build

1141
00:39:35,839 --> 00:39:39,839
online services and stuff so yeah teas

1142
00:39:39,280 --> 00:39:42,560
are

1143
00:39:39,839 --> 00:39:45,680
one system that we have become quite

1144
00:39:42,560 --> 00:39:47,599
used to from from mobile phones or from

1145
00:39:45,680 --> 00:39:48,720
uh maybe even even from something like a

1146
00:39:47,599 --> 00:39:50,640
banking card or so

1147
00:39:48,720 --> 00:39:52,720
which is it's also like a protected

1148
00:39:50,640 --> 00:39:54,240
environment for a very simple job

1149
00:39:52,720 --> 00:39:56,240
but the problem then starts when you

1150
00:39:54,240 --> 00:39:59,759
throw a lot of functionality into the t

1151
00:39:56,240 --> 00:40:01,919
as we saw the trusted code base becomes

1152
00:39:59,760 --> 00:40:03,599
more and more complex and you get

1153
00:40:01,920 --> 00:40:06,480
traditional bugs

1154
00:40:03,599 --> 00:40:07,440
so um think like yeah it's really the

1155
00:40:06,480 --> 00:40:08,800
question if you need an

1156
00:40:07,440 --> 00:40:10,319
alternative or a better way of

1157
00:40:08,800 --> 00:40:10,960
approaching it how your partition

1158
00:40:10,319 --> 00:40:12,800
software and

1159
00:40:10,960 --> 00:40:14,480
as you mentioned there there's some

1160
00:40:12,800 --> 00:40:15,200
other things you can do architecturally

1161
00:40:14,480 --> 00:40:17,920
so you can

1162
00:40:15,200 --> 00:40:18,480
change the way we or extend the way we

1163
00:40:17,920 --> 00:40:20,000
build

1164
00:40:18,480 --> 00:40:22,400
build architectures for instance with

1165
00:40:20,000 --> 00:40:24,640
these capabilities and then start to

1166
00:40:22,400 --> 00:40:26,160
isolate components for instance in in

1167
00:40:24,640 --> 00:40:28,078
one software project say

1168
00:40:26,160 --> 00:40:29,920
say in your web server you isolate the

1169
00:40:28,079 --> 00:40:32,400
uh tls stack or

1170
00:40:29,920 --> 00:40:34,079
or something like this and also thanks

1171
00:40:32,400 --> 00:40:35,520
for the people noticing the secret

1172
00:40:34,079 --> 00:40:38,079
password here

1173
00:40:35,520 --> 00:40:39,359
so obviously only for decoration

1174
00:40:38,079 --> 00:40:43,520
purposes yeah

1175
00:40:39,359 --> 00:40:46,400
to give the people something to watch

1176
00:40:43,520 --> 00:40:48,720
so um but it's not fundamentally broken

1177
00:40:46,400 --> 00:40:48,720
is it

1178
00:40:49,200 --> 00:40:55,759
sjx yeah there's no sjxte

1179
00:40:53,040 --> 00:40:57,720
i mean these are there are many of them

1180
00:40:55,760 --> 00:41:00,800
i think like you cannot say

1181
00:40:57,720 --> 00:41:04,240
fundamentally broken for but for

1182
00:41:00,800 --> 00:41:06,079
sjx question i had was specifically for

1183
00:41:04,240 --> 00:41:08,560
sgx at that point

1184
00:41:06,079 --> 00:41:10,079
because signal uses its mobile coin

1185
00:41:08,560 --> 00:41:13,279
cryptocurrency uses it

1186
00:41:10,079 --> 00:41:15,760
and so on and so forth is

1187
00:41:13,280 --> 00:41:16,800
is that fundamentally broken or would

1188
00:41:15,760 --> 00:41:21,599
you

1189
00:41:16,800 --> 00:41:25,440
rather say so so i guess it depends

1190
00:41:21,599 --> 00:41:27,839
uh what you call fundamentally

1191
00:41:25,440 --> 00:41:29,280
right so there has been in the past we

1192
00:41:27,839 --> 00:41:31,440
have worked also on

1193
00:41:29,280 --> 00:41:34,160
what i would say full breaches of sga's

1194
00:41:31,440 --> 00:41:36,160
but they have been fixed right and it's

1195
00:41:34,160 --> 00:41:36,640
actually quite a beautiful instance of

1196
00:41:36,160 --> 00:41:39,040
where

1197
00:41:36,640 --> 00:41:40,160
research can have short-term industry

1198
00:41:39,040 --> 00:41:43,119
impacted so

1199
00:41:40,160 --> 00:41:44,879
if you find a vulnerability then the

1200
00:41:43,119 --> 00:41:46,240
vendor has to devise a fix that they are

1201
00:41:44,880 --> 00:41:48,720
often not trivial

1202
00:41:46,240 --> 00:41:50,399
and and they often work around to the

1203
00:41:48,720 --> 00:41:51,680
problem right and then the later

1204
00:41:50,400 --> 00:41:53,680
because you're talking about of course

1205
00:41:51,680 --> 00:41:55,680
about hardware routes of course so then

1206
00:41:53,680 --> 00:41:56,960
you need new processes to really get a

1207
00:41:55,680 --> 00:41:58,399
fundamental

1208
00:41:56,960 --> 00:42:00,720
fix for the problem and then you have

1209
00:41:58,400 --> 00:42:02,240
temporary workarounds so i would say for

1210
00:42:00,720 --> 00:42:06,240
instance a

1211
00:42:02,240 --> 00:42:08,720
company like signal using sgx if they

1212
00:42:06,240 --> 00:42:10,399
so so it does not give you security by

1213
00:42:08,720 --> 00:42:11,680
default right you need to think about

1214
00:42:10,400 --> 00:42:12,480
the software that's what you focused on

1215
00:42:11,680 --> 00:42:14,560
in this stock

1216
00:42:12,480 --> 00:42:16,880
you also need to think about all of the

1217
00:42:14,560 --> 00:42:18,880
the micro code patches and or newer

1218
00:42:16,880 --> 00:42:20,079
processors

1219
00:42:18,880 --> 00:42:22,000
to take care of all the known

1220
00:42:20,079 --> 00:42:24,720
vulnerabilities

1221
00:42:22,000 --> 00:42:26,640
um and then of course the question

1222
00:42:24,720 --> 00:42:27,200
always remains are there vulnerabilities

1223
00:42:26,640 --> 00:42:30,720
that we don't

1224
00:42:27,200 --> 00:42:31,680
know of yet but that's with any secure

1225
00:42:30,720 --> 00:42:33,520
system i guess

1226
00:42:31,680 --> 00:42:35,598
but but maybe also david wants to say

1227
00:42:33,520 --> 00:42:39,119
something about some of his latest work

1228
00:42:35,599 --> 00:42:41,680
there that that's a bit interesting

1229
00:42:39,119 --> 00:42:42,240
yeah so i think what what yours has uh

1230
00:42:41,680 --> 00:42:43,520
or my

1231
00:42:42,240 --> 00:42:46,160
answer to this question would be it

1232
00:42:43,520 --> 00:42:50,319
depends on your threat model really

1233
00:42:46,160 --> 00:42:52,078
so some some people use sjx as a way to

1234
00:42:50,319 --> 00:42:53,440
kind of like remove the trust in the

1235
00:42:52,079 --> 00:42:56,720
cloud provider so you

1236
00:42:53,440 --> 00:42:58,800
you say like as in signal also i move

1237
00:42:56,720 --> 00:43:00,399
all this functionality that that is

1238
00:42:58,800 --> 00:43:04,160
hosted maybe on on some

1239
00:43:00,400 --> 00:43:06,240
cloud provider into an sgx enclave

1240
00:43:04,160 --> 00:43:08,480
and then uh then i don't have to trust

1241
00:43:06,240 --> 00:43:10,640
the uh cloud provider anymore because

1242
00:43:08,480 --> 00:43:12,400
sjx also has some form of protection

1243
00:43:10,640 --> 00:43:14,879
against physical access

1244
00:43:12,400 --> 00:43:16,079
but recently we actually we published

1245
00:43:14,880 --> 00:43:18,319
another attack

1246
00:43:16,079 --> 00:43:20,960
which shows that if you have hardware

1247
00:43:18,319 --> 00:43:23,839
access to an sjx processor

1248
00:43:20,960 --> 00:43:25,520
you can inject faults into into the

1249
00:43:23,839 --> 00:43:28,000
processor by

1250
00:43:25,520 --> 00:43:29,920
playing with the under volting interface

1251
00:43:28,000 --> 00:43:32,000
with with hardware access so you really

1252
00:43:29,920 --> 00:43:32,960
sorted to the main board to to a couple

1253
00:43:32,000 --> 00:43:35,119
of um

1254
00:43:32,960 --> 00:43:36,560
a couple of wires on the bus to the

1255
00:43:35,119 --> 00:43:40,560
voltage regulator

1256
00:43:36,560 --> 00:43:42,240
and then you can do voltage glitching as

1257
00:43:40,560 --> 00:43:43,599
some people might know from from other

1258
00:43:42,240 --> 00:43:45,200
embedded contacts

1259
00:43:43,599 --> 00:43:47,119
and that way then you can flip bits

1260
00:43:45,200 --> 00:43:50,319
essentially in the enclave and of course

1261
00:43:47,119 --> 00:43:52,800
do all kinds of um kind of like

1262
00:43:50,319 --> 00:43:53,759
inject all kinds of evil effects that

1263
00:43:52,800 --> 00:43:56,640
then can be

1264
00:43:53,760 --> 00:43:58,960
used further to get keys out or maybe

1265
00:43:56,640 --> 00:44:00,560
hijack control flow or something

1266
00:43:58,960 --> 00:44:02,079
so it depends on your threat model i

1267
00:44:00,560 --> 00:44:03,680
wouldn't say still that stx is

1268
00:44:02,079 --> 00:44:06,240
completely pointless

1269
00:44:03,680 --> 00:44:07,759
it's i think better than not having it

1270
00:44:06,240 --> 00:44:10,319
at all but

1271
00:44:07,760 --> 00:44:12,000
it definitely cannot you cannot have

1272
00:44:10,319 --> 00:44:13,680
like complete protection against

1273
00:44:12,000 --> 00:44:15,359
somebody who has physical access to your

1274
00:44:13,680 --> 00:44:17,759
server

1275
00:44:15,359 --> 00:44:18,720
so uh i have to close this talk it's a

1276
00:44:17,760 --> 00:44:20,880
bummer i would

1277
00:44:18,720 --> 00:44:22,319
ask all that questions that are flowing

1278
00:44:20,880 --> 00:44:24,720
but one

1279
00:44:22,319 --> 00:44:27,119
very very fast answer please what is

1280
00:44:24,720 --> 00:44:29,520
that with a password in your background

1281
00:44:27,119 --> 00:44:30,800
i i explained it it's uh it's of course

1282
00:44:29,520 --> 00:44:33,040
like just a joke yeah

1283
00:44:30,800 --> 00:44:34,880
so i'll say it again because some people

1284
00:44:33,040 --> 00:44:36,880
seem to have taken it seriously so

1285
00:44:34,880 --> 00:44:38,400
it was such an empty whiteboard so i put

1286
00:44:36,880 --> 00:44:40,160
a password there

1287
00:44:38,400 --> 00:44:41,680
unfortunately it's not fully visible in

1288
00:44:40,160 --> 00:44:45,359
the in the stream

1289
00:44:41,680 --> 00:44:48,160
okay so i thank you joefanbook

1290
00:44:45,359 --> 00:44:49,359
scritz alder david oswalt thank you for

1291
00:44:48,160 --> 00:44:51,200
having this nice talk

1292
00:44:49,359 --> 00:45:05,839
and now we make the transition to the

1293
00:44:51,200 --> 00:45:05,839
harris news show

1294
00:45:16,839 --> 00:45:19,839
wow

1295
00:45:31,839 --> 00:45:33,920
you

