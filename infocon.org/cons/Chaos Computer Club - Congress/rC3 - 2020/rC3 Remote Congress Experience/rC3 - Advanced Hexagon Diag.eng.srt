1
00:00:01,500 --> 00:00:10,520
[Music]

2
00:00:07,350 --> 00:00:10,520
[Applause]

3
00:00:12,799 --> 00:00:16,079
our next speaker

4
00:00:14,080 --> 00:00:17,840
alisa isage is an independent

5
00:00:16,079 --> 00:00:19,278
vulnerability researcher and has a

6
00:00:17,840 --> 00:00:22,000
notable record

7
00:00:19,279 --> 00:00:24,080
of security research achievements such

8
00:00:22,000 --> 00:00:26,960
as the sierra day initiative silver

9
00:00:24,080 --> 00:00:29,519
bounty hunter award 2018.

10
00:00:26,960 --> 00:00:30,000
elisa is going to present her latest

11
00:00:29,519 --> 00:00:32,879
research

12
00:00:30,000 --> 00:00:34,239
on the qualcomm direct protocol which is

13
00:00:32,880 --> 00:00:36,880
found

14
00:00:34,239 --> 00:00:37,599
abundantly in qualcomm hexagon based

15
00:00:36,880 --> 00:00:41,200
cellular

16
00:00:37,600 --> 00:00:45,840
modems alisa we're looking forward to

17
00:00:41,200 --> 00:00:48,559
your talk now

18
00:00:45,840 --> 00:00:50,879
this is alice sh you're attending my

19
00:00:48,559 --> 00:00:53,519
presentation advantagex abundance

20
00:00:50,879 --> 00:00:59,839
at cows communication congress 2020

21
00:00:53,520 --> 00:00:59,840
remote experience

22
00:01:00,079 --> 00:01:03,520
my main interest as an advanced

23
00:01:02,000 --> 00:01:07,360
vulnerability researcher

24
00:01:03,520 --> 00:01:09,840
is complex system and hardened systems

25
00:01:07,360 --> 00:01:10,560
for the last 10 years i have been

26
00:01:09,840 --> 00:01:12,400
researching

27
00:01:10,560 --> 00:01:14,400
various classes of software such as

28
00:01:12,400 --> 00:01:15,439
windows kernel browsers javascript

29
00:01:14,400 --> 00:01:16,960
engines

30
00:01:15,439 --> 00:01:20,000
and for the last three years i was

31
00:01:16,960 --> 00:01:21,600
focusing mostly on hyper-resource

32
00:01:20,000 --> 00:01:23,119
the project the project that i'm

33
00:01:21,600 --> 00:01:26,479
presenting today

34
00:01:23,119 --> 00:01:30,080
was a little side project that they made

35
00:01:26,479 --> 00:01:30,080
for destruction a couple of years ago

36
00:01:32,799 --> 00:01:37,439
the name of this talk advanced hexagon

37
00:01:34,799 --> 00:01:39,280
diag is a bit of an understatement

38
00:01:37,439 --> 00:01:40,639
in the attempt to keep this talk a

39
00:01:39,280 --> 00:01:44,960
little bit

40
00:01:40,640 --> 00:01:47,040
low key in the general internet

41
00:01:44,960 --> 00:01:48,399
because a big part of the talk will

42
00:01:47,040 --> 00:01:51,520
actually be

43
00:01:48,399 --> 00:01:53,200
devoted to a general vulnerability

44
00:01:51,520 --> 00:01:55,439
research in basebands

45
00:01:53,200 --> 00:01:57,200
but the primary focus of this talk is on

46
00:01:55,439 --> 00:02:00,559
the hexagon diag

47
00:01:57,200 --> 00:02:01,600
also known as qcdm qualcomm diagnostic

48
00:02:00,560 --> 00:02:03,600
manager

49
00:02:01,600 --> 00:02:07,199
this is a proprietary protocol developed

50
00:02:03,600 --> 00:02:09,919
by qualcomm for use in their base bands

51
00:02:07,200 --> 00:02:11,760
and it is included on all snapdragon

52
00:02:09,919 --> 00:02:15,519
socks and

53
00:02:11,760 --> 00:02:15,519
modem chips produced by qualcomm

54
00:02:16,400 --> 00:02:22,800
modern qualcomm chips run on a custom

55
00:02:19,599 --> 00:02:25,040
silicon with a custom

56
00:02:22,800 --> 00:02:26,239
instruction set architecture named qdsp6

57
00:02:25,040 --> 00:02:28,560
hexagon

58
00:02:26,239 --> 00:02:29,760
this is important because all the diet

59
00:02:28,560 --> 00:02:32,000
handlers

60
00:02:29,760 --> 00:02:33,840
that we will be dealing with are written

61
00:02:32,000 --> 00:02:37,840
in this

62
00:02:33,840 --> 00:02:37,840
instruction set architecture

63
00:02:41,040 --> 00:02:46,640
as usual with my talks i have adjusted

64
00:02:43,920 --> 00:02:49,359
the materials of this presentation

65
00:02:46,640 --> 00:02:51,040
for various audiences for the false

66
00:02:49,360 --> 00:02:52,720
picture of audiences

67
00:02:51,040 --> 00:02:54,879
specifically the first part of the

68
00:02:52,720 --> 00:02:58,080
presentation

69
00:02:54,879 --> 00:03:00,720
is mostly specialized

70
00:02:58,080 --> 00:03:02,800
for research directors and high-level

71
00:03:00,720 --> 00:03:05,440
technical staff

72
00:03:02,800 --> 00:03:09,040
and the last part is more deep technical

73
00:03:05,440 --> 00:03:11,280
and it would be mostly interesting to

74
00:03:09,040 --> 00:03:12,159
specialized vulnerability researchers

75
00:03:11,280 --> 00:03:15,200
and

76
00:03:12,159 --> 00:03:16,159
low-level programmers that somehow are

77
00:03:15,200 --> 00:03:19,839
related to

78
00:03:16,159 --> 00:03:19,840
this particular area

79
00:03:22,400 --> 00:03:29,120
let's start from the top level overview

80
00:03:26,080 --> 00:03:29,760
of cellular technology this mind map

81
00:03:29,120 --> 00:03:32,000
presents

82
00:03:29,760 --> 00:03:33,040
a simplified view of various types of

83
00:03:32,000 --> 00:03:34,720
entities that we

84
00:03:33,040 --> 00:03:37,280
have to deal with with respect to

85
00:03:34,720 --> 00:03:37,920
basebands it's not a complete diagram of

86
00:03:37,280 --> 00:03:41,760
course but

87
00:03:37,920 --> 00:03:45,040
it only presents the classes of

88
00:03:41,760 --> 00:03:48,399
entities that exist in this

89
00:03:45,040 --> 00:03:50,720
play space also this

90
00:03:48,400 --> 00:03:51,680
mind map is specific to the clean side

91
00:03:50,720 --> 00:03:54,080
equipment

92
00:03:51,680 --> 00:03:54,720
the user equipment and it completely

93
00:03:54,080 --> 00:03:57,040
omits

94
00:03:54,720 --> 00:03:58,799
any server side considerations which are

95
00:03:57,040 --> 00:04:00,640
enrolled in their own

96
00:03:58,799 --> 00:04:03,200
there exists quite a large number of

97
00:04:00,640 --> 00:04:05,518
cellular protocols on the planet

98
00:04:03,200 --> 00:04:07,599
from the user perspective this is simple

99
00:04:05,519 --> 00:04:10,319
this is usually the

100
00:04:07,599 --> 00:04:11,280
shirt name 3g 4g that you see on the

101
00:04:10,319 --> 00:04:14,399
mobile screen

102
00:04:11,280 --> 00:04:18,639
but in reality a this

103
00:04:14,400 --> 00:04:22,160
simple name that generation name encodes

104
00:04:18,639 --> 00:04:25,360
may encode several different

105
00:04:22,160 --> 00:04:25,360
distinct technologies

106
00:04:27,120 --> 00:04:30,479
there are a few key points about solar

107
00:04:29,280 --> 00:04:33,119
protocols that

108
00:04:30,479 --> 00:04:34,320
are crucial to understand before

109
00:04:33,120 --> 00:04:37,520
starting to

110
00:04:34,320 --> 00:04:39,280
approach this area the first one is the

111
00:04:37,520 --> 00:04:42,639
concept of regeneration this is

112
00:04:39,280 --> 00:04:45,198
simple this is simply the one g to g

113
00:04:42,639 --> 00:04:47,120
and so on the generic name of a family

114
00:04:45,199 --> 00:04:49,520
of protocols that are supported

115
00:04:47,120 --> 00:04:50,800
at a particular generation generation is

116
00:04:49,520 --> 00:04:53,520
simply a marketing name

117
00:04:50,800 --> 00:04:54,320
it's for users it doesn't really have

118
00:04:53,520 --> 00:04:56,960
any

119
00:04:54,320 --> 00:04:58,639
strict technical meaning and generations

120
00:04:56,960 --> 00:05:01,919
represent the evolution of

121
00:04:58,639 --> 00:05:04,320
cellular protocols in time

122
00:05:01,919 --> 00:05:07,359
the second most important thing about

123
00:05:04,320 --> 00:05:10,479
cellular protocols is the air interface

124
00:05:07,360 --> 00:05:11,680
this is or uh the protocol which

125
00:05:10,479 --> 00:05:13,680
actually

126
00:05:11,680 --> 00:05:15,759
this is the lowest level protocol which

127
00:05:13,680 --> 00:05:19,120
defines how exactly the

128
00:05:15,759 --> 00:05:22,320
cellular signal signal is digitized

129
00:05:19,120 --> 00:05:24,560
and read from the electromagnetic wave

130
00:05:22,320 --> 00:05:25,919
and how exactly the different players in

131
00:05:24,560 --> 00:05:29,840
this field

132
00:05:25,919 --> 00:05:32,240
divide the space historically

133
00:05:29,840 --> 00:05:35,440
there existed two main implementations

134
00:05:32,240 --> 00:05:37,600
of this low level protocol tdma and cdma

135
00:05:35,440 --> 00:05:38,639
today means time division multiple

136
00:05:37,600 --> 00:05:40,240
access

137
00:05:38,639 --> 00:05:41,919
which basically divides the entire

138
00:05:40,240 --> 00:05:42,880
electromagnetic spectrum within the

139
00:05:41,919 --> 00:05:46,080
radio band

140
00:05:42,880 --> 00:05:47,600
into time slots that are rotated in a

141
00:05:46,080 --> 00:05:50,960
round-robin manner

142
00:05:47,600 --> 00:05:55,199
by various mobile phones

143
00:05:50,960 --> 00:05:58,318
so that they speak um in

144
00:05:55,199 --> 00:06:02,240
in turns the tdma was the

145
00:05:58,319 --> 00:06:05,520
base for the jsm technology and

146
00:06:02,240 --> 00:06:06,160
gsm was the main protocol used on this

147
00:06:05,520 --> 00:06:08,799
planet

148
00:06:06,160 --> 00:06:10,479
for a long time another low-level

149
00:06:08,800 --> 00:06:13,120
implementation is cdma

150
00:06:10,479 --> 00:06:14,400
it was a little bit more complex from

151
00:06:13,120 --> 00:06:17,280
the beginning

152
00:06:14,400 --> 00:06:19,198
it's decoded as co-division multiple

153
00:06:17,280 --> 00:06:22,239
access

154
00:06:19,199 --> 00:06:25,520
and instead of dividing this picture by

155
00:06:22,240 --> 00:06:26,479
in time slots and dividing the protocol

156
00:06:25,520 --> 00:06:30,318
in bursts

157
00:06:26,479 --> 00:06:31,919
cdma uses solder random codes that are

158
00:06:30,319 --> 00:06:34,960
assigned to

159
00:06:31,919 --> 00:06:39,280
mobile phones so that

160
00:06:34,960 --> 00:06:39,280
this code can be used as an additional

161
00:06:41,120 --> 00:06:44,880
randomizing mask against the modulation

162
00:06:43,680 --> 00:06:47,520
protocol

163
00:06:44,880 --> 00:06:49,199
and multiple user equipments can talk on

164
00:06:47,520 --> 00:06:51,280
the same frequency without interrupting

165
00:06:49,199 --> 00:06:55,039
each other

166
00:06:51,280 --> 00:06:57,758
notable here is that cdma was developed

167
00:06:55,039 --> 00:07:00,159
by qualcomm and it was mostly used in

168
00:06:57,759 --> 00:07:02,880
the united states

169
00:07:00,160 --> 00:07:04,400
so at the level of 2g there were two

170
00:07:02,880 --> 00:07:06,719
main protocols gsm

171
00:07:04,400 --> 00:07:09,359
based on the tdma and cdma1 based on the

172
00:07:06,720 --> 00:07:09,360
sdma

173
00:07:10,400 --> 00:07:16,000
the third generation of mobile protocols

174
00:07:13,599 --> 00:07:17,120
this two branches of development were

175
00:07:16,000 --> 00:07:20,639
continued

176
00:07:17,120 --> 00:07:23,919
so gsm evolved into umts while cdma

177
00:07:20,639 --> 00:07:25,919
won evolved into cma 2000. the important

178
00:07:23,919 --> 00:07:29,198
point here is that umts have

179
00:07:25,919 --> 00:07:31,440
at this point already

180
00:07:29,199 --> 00:07:34,800
adopted the low-level air interface

181
00:07:31,440 --> 00:07:37,199
protocol from the cdma

182
00:07:34,800 --> 00:07:38,000
and eventually at the fourth generation

183
00:07:37,199 --> 00:07:39,599
of protocols

184
00:07:38,000 --> 00:07:42,800
these two branches of development come

185
00:07:39,599 --> 00:07:46,800
together to create the lte technology

186
00:07:42,800 --> 00:07:46,800
and same for the 5g

187
00:07:50,240 --> 00:07:53,840
this is a bit important for us as from

188
00:07:52,479 --> 00:07:56,639
the offensive perspective

189
00:07:53,840 --> 00:07:58,159
because first of all all these

190
00:07:56,639 --> 00:07:59,520
technologies including the air

191
00:07:58,160 --> 00:08:02,560
interfaces represent

192
00:07:59,520 --> 00:08:05,680
separate bits of

193
00:08:02,560 --> 00:08:07,919
code with separate parsing algorithms

194
00:08:05,680 --> 00:08:09,840
within the basement firmware

195
00:08:07,919 --> 00:08:12,240
and all of them are usually presented in

196
00:08:09,840 --> 00:08:13,758
each basement regardless of which one do

197
00:08:12,240 --> 00:08:15,520
you actually use

198
00:08:13,759 --> 00:08:17,680
does your mobile provider actually

199
00:08:15,520 --> 00:08:19,599
support

200
00:08:17,680 --> 00:08:21,280
another important and non-obvious thing

201
00:08:19,599 --> 00:08:23,039
from the office offensive security

202
00:08:21,280 --> 00:08:26,559
perspective here

203
00:08:23,039 --> 00:08:30,560
is that because of this um evolutionary

204
00:08:26,560 --> 00:08:31,039
development the protocols are not

205
00:08:30,560 --> 00:08:33,440
actually

206
00:08:31,039 --> 00:08:34,319
completely distinct so if you think

207
00:08:33,440 --> 00:08:35,519
about lte

208
00:08:34,320 --> 00:08:38,159
it is not a completely different

209
00:08:35,519 --> 00:08:40,719
protocol from gsm but instead it is

210
00:08:38,159 --> 00:08:44,159
based largely on the same

211
00:08:40,719 --> 00:08:44,880
internal structures and in fact if you

212
00:08:44,159 --> 00:08:48,399
look at

213
00:08:44,880 --> 00:08:50,480
specifications they some of them are

214
00:08:48,399 --> 00:08:52,000
almost directly relevant the

215
00:08:50,480 --> 00:08:54,480
specifications of the gsm

216
00:08:52,000 --> 00:08:55,120
to g some of them are still directly

217
00:08:54,480 --> 00:08:58,640
relevant

218
00:08:55,120 --> 00:08:59,519
to some extent to lte this is also

219
00:08:58,640 --> 00:09:01,680
important

220
00:08:59,519 --> 00:09:04,800
when you start analyzing protocols from

221
00:09:01,680 --> 00:09:04,800
the offensive perspective

222
00:09:05,440 --> 00:09:12,399
the cellular protocols are structured

223
00:09:09,360 --> 00:09:12,399
in a nested way

224
00:09:13,279 --> 00:09:18,480
in layers layers

225
00:09:16,480 --> 00:09:22,240
is the official terminology adopted by

226
00:09:18,480 --> 00:09:24,800
the specifications

227
00:09:22,240 --> 00:09:26,959
with the exception of level zero here i

228
00:09:24,800 --> 00:09:29,040
just edit it for convenience

229
00:09:26,959 --> 00:09:31,920
but it's in the specifications layer

230
00:09:29,040 --> 00:09:33,599
start from one and proceed to three

231
00:09:31,920 --> 00:09:35,040
from the offensive perspective the most

232
00:09:33,600 --> 00:09:37,040
interesting is level three

233
00:09:35,040 --> 00:09:38,160
as you can see from the screenshot of

234
00:09:37,040 --> 00:09:39,760
specifications

235
00:09:38,160 --> 00:09:41,519
because it encodes most of the high

236
00:09:39,760 --> 00:09:44,959
level protocol data such as

237
00:09:41,519 --> 00:09:46,800
handling sms and gsm this is the parts

238
00:09:44,959 --> 00:09:48,800
of the protocol which actually contains

239
00:09:46,800 --> 00:09:52,479
interesting data structures with deal

240
00:09:48,800 --> 00:09:52,479
with tlb values and so on

241
00:09:53,050 --> 00:09:56,399
[Applause]

242
00:09:54,959 --> 00:09:58,479
when people talk about attacking

243
00:09:56,399 --> 00:10:02,079
basebands they usually mean

244
00:09:58,480 --> 00:10:05,600
attacking basement over the air the

245
00:10:02,079 --> 00:10:08,239
ota attacker which is definitely

246
00:10:05,600 --> 00:10:09,200
one of the most interesting but let's

247
00:10:08,240 --> 00:10:12,480
take a step back

248
00:10:09,200 --> 00:10:16,079
and consider the entire big picture

249
00:10:12,480 --> 00:10:17,200
of the basement ecosystem this diagram

250
00:10:16,079 --> 00:10:20,560
presents

251
00:10:17,200 --> 00:10:22,640
unified view of

252
00:10:20,560 --> 00:10:23,680
generalized architecture of a modern

253
00:10:22,640 --> 00:10:27,279
basement

254
00:10:23,680 --> 00:10:27,279
with attack surfaces

255
00:10:28,240 --> 00:10:32,720
first of all there are two separate

256
00:10:31,440 --> 00:10:35,680
distant processors

257
00:10:32,720 --> 00:10:37,519
the ap application processor and the mp

258
00:10:35,680 --> 00:10:38,239
mobile processor it may be in either a

259
00:10:37,519 --> 00:10:41,360
dsp

260
00:10:38,240 --> 00:10:42,800
or another cpu usually there are two

261
00:10:41,360 --> 00:10:44,880
separate processors

262
00:10:42,800 --> 00:10:46,000
and each one of them runs a separate

263
00:10:44,880 --> 00:10:49,200
operating system

264
00:10:46,000 --> 00:10:50,480
in case of the ap it may be android or

265
00:10:49,200 --> 00:10:52,240
ios

266
00:10:50,480 --> 00:10:54,079
and the baseband processor would run

267
00:10:52,240 --> 00:10:55,760
some sort of a real-time operating

268
00:10:54,079 --> 00:10:58,479
system provided by the

269
00:10:55,760 --> 00:10:58,480
mobile vendor

270
00:10:59,200 --> 00:11:02,959
important point here that on modern

271
00:11:02,079 --> 00:11:05,120
implementations

272
00:11:02,959 --> 00:11:07,279
basement are usually protected by some

273
00:11:05,120 --> 00:11:10,560
sort of secure execution environment

274
00:11:07,279 --> 00:11:12,839
maybe trust on androids or surface on

275
00:11:10,560 --> 00:11:14,640
apple

276
00:11:12,839 --> 00:11:16,720
devices

277
00:11:14,640 --> 00:11:17,920
which means that the privileged boundary

278
00:11:16,720 --> 00:11:21,200
which is depicted here

279
00:11:17,920 --> 00:11:23,839
on the left side is dual sided so

280
00:11:21,200 --> 00:11:25,920
even if you have kernel access to the

281
00:11:23,839 --> 00:11:28,320
android journal

282
00:11:25,920 --> 00:11:29,760
you still are not supposed to be able to

283
00:11:28,320 --> 00:11:31,920
read the memory of the

284
00:11:29,760 --> 00:11:33,680
baseband or somehow intersect with this

285
00:11:31,920 --> 00:11:35,279
operation at least on the model

286
00:11:33,680 --> 00:11:38,079
production smartphones

287
00:11:35,279 --> 00:11:39,680
and the same goes around to the basement

288
00:11:38,079 --> 00:11:41,359
which is not supposed to be able to

289
00:11:39,680 --> 00:11:44,160
access to

290
00:11:41,360 --> 00:11:44,480
application processor directly so these

291
00:11:44,160 --> 00:11:47,519
two

292
00:11:44,480 --> 00:11:49,760
are mutually distrusting entities

293
00:11:47,519 --> 00:11:50,800
that are separated from each other and

294
00:11:49,760 --> 00:11:53,120
so there exists

295
00:11:50,800 --> 00:11:56,639
a privilege boundary which is which

296
00:11:53,120 --> 00:11:59,360
represents um

297
00:11:56,639 --> 00:11:59,360
attack surface

298
00:12:00,959 --> 00:12:04,560
within the uh real-time operating

299
00:12:03,040 --> 00:12:07,439
systems there are three

300
00:12:04,560 --> 00:12:08,479
large attack surfaces starting from

301
00:12:07,440 --> 00:12:11,760
right to left

302
00:12:08,480 --> 00:12:14,000
the rightmost gray box

303
00:12:11,760 --> 00:12:15,920
represents the attack surface of the

304
00:12:14,000 --> 00:12:18,000
cellular stacks

305
00:12:15,920 --> 00:12:20,399
uh this this is the code which actually

306
00:12:18,000 --> 00:12:24,800
parses the cellular protocols

307
00:12:20,399 --> 00:12:28,560
it usually runs in several distant

308
00:12:24,800 --> 00:12:28,560
real-time operating system tasks

309
00:12:29,839 --> 00:12:35,839
and this part of the

310
00:12:33,440 --> 00:12:37,040
attack surface handles all the layers of

311
00:12:35,839 --> 00:12:39,360
the protocol

312
00:12:37,040 --> 00:12:41,279
there is a huge amount of parsing that

313
00:12:39,360 --> 00:12:44,079
happens here

314
00:12:41,279 --> 00:12:46,000
the second box represents various

315
00:12:44,079 --> 00:12:48,479
management protocols

316
00:12:46,000 --> 00:12:50,399
the simplest one to think about is the

317
00:12:48,480 --> 00:12:53,200
at common protocol

318
00:12:50,399 --> 00:12:54,240
it is still widely included in all

319
00:12:53,200 --> 00:12:56,560
basebands

320
00:12:54,240 --> 00:12:57,600
and it's even usually exposed in some

321
00:12:56,560 --> 00:12:59,119
way to the

322
00:12:57,600 --> 00:13:01,600
application processor so you can

323
00:12:59,120 --> 00:13:04,880
actually send some 80 commands to the

324
00:13:01,600 --> 00:13:07,360
cellular madam about a bit more

325
00:13:04,880 --> 00:13:10,240
interesting is the

326
00:13:07,360 --> 00:13:10,639
vendor-specific management protocols one

327
00:13:10,240 --> 00:13:14,079
of them

328
00:13:10,639 --> 00:13:15,360
is the direct protocol because the

329
00:13:14,079 --> 00:13:17,359
basements

330
00:13:15,360 --> 00:13:19,120
modern basements are very complex so

331
00:13:17,360 --> 00:13:22,160
vendors need

332
00:13:19,120 --> 00:13:24,399
some sort of specialized protocol to

333
00:13:22,160 --> 00:13:27,040
enable configuration and diagnostics for

334
00:13:24,399 --> 00:13:27,040
the oms

335
00:13:27,600 --> 00:13:31,040
in case of qualcomm for example diag is

336
00:13:29,920 --> 00:13:35,040
just one of the many

337
00:13:31,040 --> 00:13:38,480
diagnostic protocols involved

338
00:13:35,040 --> 00:13:40,240
the third box is what i call the rto

339
00:13:38,480 --> 00:13:43,839
score

340
00:13:40,240 --> 00:13:47,120
it is various core level functionality

341
00:13:43,839 --> 00:13:50,800
such as the code which implements the

342
00:13:47,120 --> 00:13:50,800
interface to the application processor

343
00:13:51,350 --> 00:13:54,549
[Applause]

344
00:13:56,560 --> 00:14:00,160
on the side of the application operating

345
00:13:59,440 --> 00:14:02,959
system

346
00:14:00,160 --> 00:14:03,920
such as android there are also two

347
00:14:02,959 --> 00:14:06,160
attack surfaces

348
00:14:03,920 --> 00:14:07,040
that are attackable from the basement

349
00:14:06,160 --> 00:14:10,079
the first one

350
00:14:07,040 --> 00:14:11,839
is the peripheral drivers

351
00:14:10,079 --> 00:14:13,519
because basement is a separate hardware

352
00:14:11,839 --> 00:14:15,040
peripheral so it requires some

353
00:14:13,519 --> 00:14:18,800
specialized drivers

354
00:14:15,040 --> 00:14:21,839
that handle i o and such things

355
00:14:18,800 --> 00:14:23,519
and the second one is thumb duck surf is

356
00:14:21,839 --> 00:14:27,519
represented with

357
00:14:23,519 --> 00:14:30,560
various interface handlers because

358
00:14:27,519 --> 00:14:32,399
the basement and

359
00:14:30,560 --> 00:14:33,839
the main operating system cannot

360
00:14:32,399 --> 00:14:35,440
communicate directly

361
00:14:33,839 --> 00:14:36,959
they use some sort of a specialized

362
00:14:35,440 --> 00:14:38,399
interface to do that

363
00:14:36,959 --> 00:14:40,719
in case of qualcomm this is shared

364
00:14:38,399 --> 00:14:42,079
memory and so this

365
00:14:40,720 --> 00:14:44,079
shared memory implementations are

366
00:14:42,079 --> 00:14:46,638
usually quite complex

367
00:14:44,079 --> 00:14:49,519
and they represent an antac an attack

368
00:14:46,639 --> 00:14:51,440
surface on the both sides

369
00:14:49,519 --> 00:14:53,440
and finally the third piece of this

370
00:14:51,440 --> 00:14:56,480
diagram is in the lowest part

371
00:14:53,440 --> 00:14:57,839
i have depicted to create boxes

372
00:14:56,480 --> 00:14:59,760
which are related to the trusted

373
00:14:57,839 --> 00:15:02,880
execution environment

374
00:14:59,760 --> 00:15:06,560
because typically madame modem runs

375
00:15:02,880 --> 00:15:07,439
as a draftlet in um in a secure

376
00:15:06,560 --> 00:15:11,040
environment

377
00:15:07,440 --> 00:15:13,120
so technically the attack surfaces that

378
00:15:11,040 --> 00:15:13,760
exists within the truss zone or related

379
00:15:13,120 --> 00:15:16,079
to it

380
00:15:13,760 --> 00:15:18,160
also can be useful for basement

381
00:15:16,079 --> 00:15:21,040
offensive research

382
00:15:18,160 --> 00:15:23,120
here we can distinguish at least two

383
00:15:21,040 --> 00:15:25,360
large attack surfaces the first one is

384
00:15:23,120 --> 00:15:25,360
the

385
00:15:25,440 --> 00:15:29,680
secure manager uh call handlers

386
00:15:29,920 --> 00:15:34,880
which is the core interface that handles

387
00:15:33,040 --> 00:15:36,160
calls from the application processor to

388
00:15:34,880 --> 00:15:40,079
the draw zone

389
00:15:36,160 --> 00:15:43,680
and the second one are the trustlets

390
00:15:40,079 --> 00:15:45,439
the pieces of separate pieces of code

391
00:15:43,680 --> 00:15:47,758
which are executed and protected by the

392
00:15:45,440 --> 00:15:47,759
truss

393
00:15:53,759 --> 00:15:57,519
on this diagram i have also added some

394
00:15:56,720 --> 00:16:00,800
information

395
00:15:57,519 --> 00:16:02,880
about data codecs i'm not sure if they

396
00:16:00,800 --> 00:16:04,399
are supposed to be in the rs core

397
00:16:02,880 --> 00:16:05,519
because these things are directly

398
00:16:04,399 --> 00:16:09,120
accessible from the cell

399
00:16:05,519 --> 00:16:13,360
or stacks usually especially asn 1

400
00:16:09,120 --> 00:16:15,199
which i have seen some bugs

401
00:16:13,360 --> 00:16:17,279
reachable from the over-the-air

402
00:16:15,199 --> 00:16:20,319
interface

403
00:16:17,279 --> 00:16:22,880
on this diagram i have shown some

404
00:16:20,320 --> 00:16:24,800
example of vulnerabilities i'll i will

405
00:16:22,880 --> 00:16:26,639
not discuss them in details

406
00:16:24,800 --> 00:16:28,240
here since it's not the point of the

407
00:16:26,639 --> 00:16:30,720
presentation

408
00:16:28,240 --> 00:16:31,759
but at least the ones from the pontoon

409
00:16:30,720 --> 00:16:37,839
you can find the

410
00:16:31,759 --> 00:16:37,839
write-ups on the internet

411
00:16:38,040 --> 00:16:41,309
[Applause]

412
00:16:42,399 --> 00:16:47,199
to discuss baseband offensive tools and

413
00:16:45,360 --> 00:16:49,120
approaches i have narrowed down the

414
00:16:47,199 --> 00:16:49,680
previous diagram to just one attack

415
00:16:49,120 --> 00:16:52,320
surface

416
00:16:49,680 --> 00:16:54,319
the off the air attack surface this is

417
00:16:52,320 --> 00:16:55,040
the attack surface which is represented

418
00:16:54,320 --> 00:16:56,959
by

419
00:16:55,040 --> 00:16:59,040
parsing implementations of various

420
00:16:56,959 --> 00:17:00,560
cellular protocols inside the basement

421
00:16:59,040 --> 00:17:02,319
operating system

422
00:17:00,560 --> 00:17:04,079
and this is the attack surface that we

423
00:17:02,320 --> 00:17:07,439
can reach from

424
00:17:04,079 --> 00:17:07,918
the air interface in order to accomplish

425
00:17:07,439 --> 00:17:10,799
that

426
00:17:07,919 --> 00:17:10,799
we need a

427
00:17:11,119 --> 00:17:16,159
transceiver such as software defined

428
00:17:12,880 --> 00:17:19,600
radio or a mobile tester

429
00:17:16,160 --> 00:17:21,839
which is able to talk the specific

430
00:17:19,599 --> 00:17:24,159
cellular protocol that we're planning to

431
00:17:21,839 --> 00:17:24,159
attack

432
00:17:25,199 --> 00:17:29,520
the simplest way to accomplish this is

433
00:17:27,839 --> 00:17:31,600
use some sort of a software-defined

434
00:17:29,520 --> 00:17:33,200
radio such as address research srp or

435
00:17:31,600 --> 00:17:36,000
blade rf

436
00:17:33,200 --> 00:17:38,320
and install open source implementation

437
00:17:36,000 --> 00:17:42,400
of a base station such as open bts

438
00:17:38,320 --> 00:17:45,439
or open bsc the thing to note here

439
00:17:42,400 --> 00:17:47,520
is that the software-based

440
00:17:45,440 --> 00:17:50,160
implementations

441
00:17:47,520 --> 00:17:52,000
actually lag behind the development of

442
00:17:50,160 --> 00:17:54,799
technologies

443
00:17:52,000 --> 00:17:55,760
the implementations of gsm base stations

444
00:17:54,799 --> 00:17:58,400
are very

445
00:17:55,760 --> 00:18:00,720
well established and popular such as

446
00:17:58,400 --> 00:18:04,320
open bts

447
00:18:00,720 --> 00:18:09,760
and in fact when i tried to establish

448
00:18:04,320 --> 00:18:09,760
bts with my user b it was quite simple

449
00:18:10,880 --> 00:18:16,480
for umds and lt there exist

450
00:18:14,640 --> 00:18:17,919
less number of software based

451
00:18:16,480 --> 00:18:19,760
implementations

452
00:18:17,919 --> 00:18:21,679
and also there are more constraints on

453
00:18:19,760 --> 00:18:23,200
the hardware for example my model of the

454
00:18:21,679 --> 00:18:28,400
usurpy does not

455
00:18:23,200 --> 00:18:30,240
support umts due to resource constraints

456
00:18:28,400 --> 00:18:31,840
and the most interesting thing here is

457
00:18:30,240 --> 00:18:33,520
that there does not exist any

458
00:18:31,840 --> 00:18:34,559
software-based implementation of the

459
00:18:33,520 --> 00:18:38,160
cdma

460
00:18:34,559 --> 00:18:38,160
that you can use to establish a base

461
00:18:40,840 --> 00:18:43,840
station

462
00:18:46,240 --> 00:18:52,320
this is uh so the random uh diagram

463
00:18:49,520 --> 00:18:54,160
of one of the snapdragon ships there

464
00:18:52,320 --> 00:18:57,200
exists a huge amount of various

465
00:18:54,160 --> 00:19:00,160
models of snapdragons

466
00:18:57,200 --> 00:19:02,400
this one i have chosen so randomly when

467
00:19:00,160 --> 00:19:06,559
i was searching for some sort of

468
00:19:02,400 --> 00:19:09,600
visual diagram qualcomm used to include

469
00:19:06,559 --> 00:19:11,440
some high level diagrams of

470
00:19:09,600 --> 00:19:13,439
the architecture in their marketing

471
00:19:11,440 --> 00:19:17,360
materials previously but

472
00:19:13,440 --> 00:19:17,360
it seems that they don't do this anymore

473
00:19:17,760 --> 00:19:23,120
and this particular diagram is from a

474
00:19:20,880 --> 00:19:25,440
technical specification of a particular

475
00:19:23,120 --> 00:19:27,520
model 820

476
00:19:25,440 --> 00:19:29,760
also this particular model of snapdragon

477
00:19:27,520 --> 00:19:29,760
is

478
00:19:30,480 --> 00:19:34,960
a bit interesting because it is the

479
00:19:33,039 --> 00:19:37,440
first one that included the

480
00:19:34,960 --> 00:19:40,640
artificial intelligence agent which is

481
00:19:37,440 --> 00:19:40,640
also based on hexagon

482
00:19:44,000 --> 00:19:49,520
for our purposes the main interest here

483
00:19:46,400 --> 00:19:49,520
are the processors

484
00:19:49,780 --> 00:19:53,840
[Applause]

485
00:19:51,280 --> 00:19:56,480
majority of snapdragons include quite a

486
00:19:53,840 --> 00:19:59,439
long list of processors

487
00:19:56,480 --> 00:20:00,640
there are at least four arm based cryo

488
00:19:59,440 --> 00:20:04,120
cpus that actually

489
00:20:00,640 --> 00:20:08,240
run the arm the the android

490
00:20:04,120 --> 00:20:11,600
application operating system

491
00:20:08,240 --> 00:20:14,080
then there are the adreno gpus and then

492
00:20:11,600 --> 00:20:15,918
there are several hexagons

493
00:20:14,080 --> 00:20:18,639
on the most recent models there is not

494
00:20:15,919 --> 00:20:21,679
just one hexalone

495
00:20:18,640 --> 00:20:22,480
processing unit but several of them and

496
00:20:21,679 --> 00:20:24,480
they are called

497
00:20:22,480 --> 00:20:27,120
respectively to their purposes each one

498
00:20:24,480 --> 00:20:30,240
of them each one of this hexagon course

499
00:20:27,120 --> 00:20:32,719
is responsible for handling a specific

500
00:20:30,240 --> 00:20:33,360
functionality for example mdsp handles

501
00:20:32,720 --> 00:20:36,480
modem

502
00:20:33,360 --> 00:20:38,320
and runs their real-time operating

503
00:20:36,480 --> 00:20:42,799
system

504
00:20:38,320 --> 00:20:45,870
the adsp handles media and the cdsp

505
00:20:42,799 --> 00:20:47,679
handles compute

506
00:20:45,870 --> 00:20:51,360
[Applause]

507
00:20:47,679 --> 00:20:53,919
so the hexagons actually represent

508
00:20:51,360 --> 00:21:03,840
around one half of the processing power

509
00:20:53,919 --> 00:21:07,600
on modern snapdragons

510
00:21:03,840 --> 00:21:09,678
there are um there are two key

511
00:21:07,600 --> 00:21:12,959
points about the hexagon architecture

512
00:21:09,679 --> 00:21:12,960
from the hardware perspective

513
00:21:13,679 --> 00:21:19,360
first of all it is

514
00:21:16,960 --> 00:21:20,320
hexagon is specialized to parallel

515
00:21:19,360 --> 00:21:23,360
processing

516
00:21:20,320 --> 00:21:27,280
and so the first concept

517
00:21:23,360 --> 00:21:30,080
is variable sized instruction packets

518
00:21:27,280 --> 00:21:31,000
it means that the several instructions

519
00:21:30,080 --> 00:21:35,280
can execute

520
00:21:31,000 --> 00:21:37,070
simultaneously on in separate

521
00:21:35,280 --> 00:21:40,250
execution units

522
00:21:37,070 --> 00:21:40,250
[Applause]

523
00:21:40,720 --> 00:21:44,000
it also uses a hardware multithreading

524
00:21:43,440 --> 00:21:48,320
for the same

525
00:21:44,000 --> 00:21:51,120
purposes on the right side of the slide

526
00:21:48,320 --> 00:21:54,559
here is some example of the

527
00:21:51,120 --> 00:21:58,639
hexagon assembly it is quite

528
00:21:54,559 --> 00:22:01,918
funny at times this uh

529
00:21:58,640 --> 00:22:03,320
these curly brackets represent the

530
00:22:01,919 --> 00:22:05,760
instructions that are executed

531
00:22:03,320 --> 00:22:07,678
simultaneously

532
00:22:05,760 --> 00:22:09,840
and these instructions must be

533
00:22:07,679 --> 00:22:13,039
compatible in order to

534
00:22:09,840 --> 00:22:17,280
be able to use the

535
00:22:13,039 --> 00:22:19,840
distinct processing slots

536
00:22:17,280 --> 00:22:22,000
and then there is the funny.new notation

537
00:22:19,840 --> 00:22:24,399
which actually enables the instructions

538
00:22:22,000 --> 00:22:25,679
to use both the old and the new value of

539
00:22:24,400 --> 00:22:28,880
a particular register

540
00:22:25,679 --> 00:22:30,880
within the same instruction cycle

541
00:22:28,880 --> 00:22:34,559
this this provides quite a bit of

542
00:22:30,880 --> 00:22:34,559
optimization on the low level

543
00:22:34,799 --> 00:22:39,200
for more information i can direct you to

544
00:22:37,280 --> 00:22:41,600
the

545
00:22:39,200 --> 00:22:43,360
hexagon specification a programmer's

546
00:22:41,600 --> 00:22:46,480
reference manual which is available from

547
00:22:43,360 --> 00:22:46,479
the qualcomm website

548
00:22:46,570 --> 00:22:53,360
[Applause]

549
00:22:51,280 --> 00:22:56,080
[Music]

550
00:22:53,360 --> 00:22:57,039
the concept of production fusing is

551
00:22:56,080 --> 00:22:59,280
quite common

552
00:22:57,039 --> 00:23:02,559
as i said previously it's a common

553
00:22:59,280 --> 00:23:05,280
practice from mobile device vendors

554
00:23:02,559 --> 00:23:06,960
to lock down the devices before they

555
00:23:05,280 --> 00:23:09,918
enter the market

556
00:23:06,960 --> 00:23:11,760
to prevent modifications and tinkering

557
00:23:09,919 --> 00:23:12,799
and for the purposes of this locking

558
00:23:11,760 --> 00:23:16,000
down

559
00:23:12,799 --> 00:23:17,120
they usually there are several ways how

560
00:23:16,000 --> 00:23:20,159
this can be accomplished

561
00:23:17,120 --> 00:23:21,600
usually various advanced diagnostic and

562
00:23:20,159 --> 00:23:25,360
debugging functionalities

563
00:23:21,600 --> 00:23:28,158
are removed from either software or

564
00:23:25,360 --> 00:23:29,760
hardware or both

565
00:23:28,159 --> 00:23:31,679
it is quite common that these

566
00:23:29,760 --> 00:23:32,400
functionalities are only removed from

567
00:23:31,679 --> 00:23:35,440
software

568
00:23:32,400 --> 00:23:36,000
while the hardware remains here and in

569
00:23:35,440 --> 00:23:39,280
such a

570
00:23:36,000 --> 00:23:41,679
case we will

571
00:23:39,280 --> 00:23:42,480
eventually the researchers will come up

572
00:23:41,679 --> 00:23:45,919
with

573
00:23:42,480 --> 00:23:48,240
their own software based implementation

574
00:23:45,919 --> 00:23:49,279
all this functionality as in case with

575
00:23:48,240 --> 00:23:52,640
some custom

576
00:23:49,279 --> 00:23:55,039
ios kernel debuggers for example

577
00:23:52,640 --> 00:23:55,919
in case of qualcomm there was at some

578
00:23:55,039 --> 00:23:58,080
point a leaked

579
00:23:55,919 --> 00:24:00,559
internal memo which discusses what

580
00:23:58,080 --> 00:24:05,840
exactly they are doing

581
00:24:00,559 --> 00:24:05,840
for production fusing the devices

582
00:24:05,919 --> 00:24:15,600
in addition to production fusing

583
00:24:10,960 --> 00:24:19,360
in case of modern androids

584
00:24:15,600 --> 00:24:22,639
the basement runs within the truss zone

585
00:24:19,360 --> 00:24:23,760
and on my implementation it is already

586
00:24:22,640 --> 00:24:26,799
quite locked down

587
00:24:23,760 --> 00:24:29,120
it uses a separate component the

588
00:24:26,799 --> 00:24:32,240
basement uses a separate component named

589
00:24:29,120 --> 00:24:34,799
mba which stands from the modem basic

590
00:24:32,240 --> 00:24:38,000
authenticator

591
00:24:34,799 --> 00:24:40,559
and this entire thing is run by the

592
00:24:38,000 --> 00:24:42,640
subsystem of android kernel name peel

593
00:24:40,559 --> 00:24:44,000
the peripheral image larger you can open

594
00:24:42,640 --> 00:24:48,480
the source code

595
00:24:44,000 --> 00:24:51,600
and investigate how exactly it looks

596
00:24:48,480 --> 00:24:54,559
and the purpose of the

597
00:24:51,600 --> 00:24:56,000
mba is to authenticate the modern

598
00:24:54,559 --> 00:24:58,559
firmware

599
00:24:56,000 --> 00:25:00,559
so that you would not be able to inject

600
00:24:58,559 --> 00:25:02,799
some arbitrary commas into the modern

601
00:25:00,559 --> 00:25:06,399
firmware and flash it

602
00:25:02,799 --> 00:25:08,960
this is another side of the hardening so

603
00:25:06,400 --> 00:25:11,360
which makes it very difficult to inject

604
00:25:08,960 --> 00:25:13,120
any arbitrary code into the basement

605
00:25:11,360 --> 00:25:16,719
basically the only way to do this is

606
00:25:13,120 --> 00:25:16,719
through a software vulnerability

607
00:25:20,640 --> 00:25:23,840
during this project i have reverse

608
00:25:22,400 --> 00:25:26,480
engineered partially

609
00:25:23,840 --> 00:25:27,840
the hexagon magnetic firmware from my

610
00:25:26,480 --> 00:25:32,720
implementation

611
00:25:27,840 --> 00:25:32,720
from my nexus 6p

612
00:25:33,039 --> 00:25:37,760
the process of reverse engineering is

613
00:25:36,000 --> 00:25:39,360
not very difficult

614
00:25:37,760 --> 00:25:41,039
first of all you need to download the

615
00:25:39,360 --> 00:25:44,479
firmware from the website

616
00:25:41,039 --> 00:25:46,799
the google's website for in this case

617
00:25:44,480 --> 00:25:49,679
then you need to find the binary which

618
00:25:46,799 --> 00:25:52,799
corresponds to the modem firmware

619
00:25:49,679 --> 00:25:53,360
the this binary is actually a compound

620
00:25:52,799 --> 00:25:56,240
binary

621
00:25:53,360 --> 00:25:58,158
this corresponds that must be divided

622
00:25:56,240 --> 00:25:58,720
into separate binaries that represent

623
00:25:58,159 --> 00:26:01,840
specific

624
00:25:58,720 --> 00:26:04,320
sections inside the

625
00:26:01,840 --> 00:26:07,600
inside the firmware and for that purpose

626
00:26:04,320 --> 00:26:10,000
we can use the unifi trustlet script

627
00:26:07,600 --> 00:26:12,000
after you have split the basement

628
00:26:10,000 --> 00:26:14,480
firmware into separate sections you can

629
00:26:12,000 --> 00:26:18,080
load them into either pro

630
00:26:14,480 --> 00:26:21,200
there are several plugins available

631
00:26:18,080 --> 00:26:23,439
for eda pro that support hexagon

632
00:26:21,200 --> 00:26:25,520
i have tried one of them i think it was

633
00:26:23,440 --> 00:26:28,559
gsmk

634
00:26:25,520 --> 00:26:31,520
and it works quite good for basic curves

635
00:26:28,559 --> 00:26:31,520
engineering purposes

636
00:26:32,080 --> 00:26:38,799
notably here is that

637
00:26:35,360 --> 00:26:41,439
some sections of the modern firmware are

638
00:26:38,799 --> 00:26:43,200
compressed and relocated at runtime so

639
00:26:41,440 --> 00:26:46,799
you would not be able to

640
00:26:43,200 --> 00:26:48,080
reverse engineer them unless you can

641
00:26:46,799 --> 00:26:49,679
decompress them

642
00:26:48,080 --> 00:26:52,240
which is also a bit of a challenge

643
00:26:49,679 --> 00:26:53,200
because the qualcomm uses some internal

644
00:26:52,240 --> 00:26:56,480
compression

645
00:26:53,200 --> 00:26:59,840
algorithm for that

646
00:26:56,480 --> 00:26:59,840
for the reverse engineering

647
00:27:00,080 --> 00:27:04,158
uh the main approach here is to get

648
00:27:02,480 --> 00:27:05,919
started with some root points for

649
00:27:04,159 --> 00:27:07,679
example because this is a real-time

650
00:27:05,919 --> 00:27:10,960
operating system we know that it

651
00:27:07,679 --> 00:27:13,120
should have some task structures and

652
00:27:10,960 --> 00:27:14,159
test structures that we can locate and

653
00:27:13,120 --> 00:27:16,639
from there we can

654
00:27:14,159 --> 00:27:18,399
locate some interesting code in case of

655
00:27:16,640 --> 00:27:19,120
hexagon this is a bit non-trivial

656
00:27:18,399 --> 00:27:20,719
because

657
00:27:19,120 --> 00:27:22,959
as i said it doesn't have any log

658
00:27:20,720 --> 00:27:24,799
strings so even though

659
00:27:22,960 --> 00:27:26,799
you may locate something that looks like

660
00:27:24,799 --> 00:27:28,480
a dust strut but

661
00:27:26,799 --> 00:27:30,000
it's not clear which code does it

662
00:27:28,480 --> 00:27:34,000
actually represent so

663
00:27:30,000 --> 00:27:38,080
the first step here is to apply the

664
00:27:34,000 --> 00:27:41,360
log strings that were removed from the

665
00:27:38,080 --> 00:27:41,360
binary by q-shrink

666
00:27:42,640 --> 00:27:47,200
the i think the only way to do it is by

667
00:27:45,440 --> 00:27:50,559
using that

668
00:27:47,200 --> 00:27:53,440
mst underscore

669
00:27:50,559 --> 00:27:55,760
txt file from the leaked sources this

670
00:27:53,440 --> 00:27:58,159
file is not supposed to be available

671
00:27:55,760 --> 00:27:58,960
neither on the mobile devices nor in

672
00:27:58,159 --> 00:28:02,320
some open

673
00:27:58,960 --> 00:28:05,120
ecosystem and after you have

674
00:28:02,320 --> 00:28:06,720
applied this log strings you will create

675
00:28:05,120 --> 00:28:07,520
you will be able to rename some

676
00:28:06,720 --> 00:28:10,240
functions

677
00:28:07,520 --> 00:28:11,360
and based on these log strings and

678
00:28:10,240 --> 00:28:13,760
because the log strings

679
00:28:11,360 --> 00:28:14,799
often contain the names of the source

680
00:28:13,760 --> 00:28:17,840
file

681
00:28:14,799 --> 00:28:18,240
source module from which the code was

682
00:28:17,840 --> 00:28:22,720
built

683
00:28:18,240 --> 00:28:22,720
so it creates

684
00:28:22,799 --> 00:28:30,399
opportunity to understand what's what

685
00:28:26,000 --> 00:28:32,320
exactly this code is doing

686
00:28:30,399 --> 00:28:34,000
debugging was not was completely

687
00:28:32,320 --> 00:28:35,840
unavailable in my case

688
00:28:34,000 --> 00:28:38,240
and i realized that it would require

689
00:28:35,840 --> 00:28:44,000
some a couple of months more work

690
00:28:38,240 --> 00:28:46,559
to make it work and

691
00:28:44,000 --> 00:28:47,919
the the only way i think and the best

692
00:28:46,559 --> 00:28:49,120
way is to create a software-based

693
00:28:47,919 --> 00:28:51,760
debugger

694
00:28:49,120 --> 00:28:52,479
similar to modkit that the publication

695
00:28:51,760 --> 00:28:56,080
that i will

696
00:28:52,480 --> 00:28:58,640
will be referencing in the references

697
00:28:56,080 --> 00:29:01,039
based on software vulnerability in

698
00:28:58,640 --> 00:29:04,640
either the modem itself

699
00:29:01,039 --> 00:29:06,960
or in some authentic authenticator

700
00:29:04,640 --> 00:29:09,120
or in the trust zone so that we can

701
00:29:06,960 --> 00:29:09,919
eject a software debugger callbacks into

702
00:29:09,120 --> 00:29:14,639
the basement

703
00:29:09,919 --> 00:29:14,640
and connect it to the gdp stop

704
00:29:15,039 --> 00:29:21,919
this is how the

705
00:29:18,320 --> 00:29:25,120
part of the firmware looks that has the

706
00:29:21,919 --> 00:29:27,120
log string stripped out here

707
00:29:25,120 --> 00:29:28,399
it's already has some names applied

708
00:29:27,120 --> 00:29:30,239
using either script

709
00:29:28,399 --> 00:29:32,080
so of course there was no such names

710
00:29:30,240 --> 00:29:34,000
initially only the hashes

711
00:29:32,080 --> 00:29:35,199
each one of the sessions represent a log

712
00:29:34,000 --> 00:29:37,679
string

713
00:29:35,200 --> 00:29:41,600
that you can take in the from the

714
00:29:37,679 --> 00:29:43,760
message hash file

715
00:29:41,600 --> 00:29:44,639
and here is what you can get after you

716
00:29:43,760 --> 00:29:48,080
have applied

717
00:29:44,640 --> 00:29:48,080
the textual messages

718
00:29:48,240 --> 00:29:53,760
and rename some functions in this case

719
00:29:51,840 --> 00:29:55,918
you would be able to find some hundreds

720
00:29:53,760 --> 00:29:58,320
of procedures that are directly related

721
00:29:55,919 --> 00:30:01,360
to the diax up system

722
00:29:58,320 --> 00:30:04,240
and in a similar way you can locate

723
00:30:01,360 --> 00:30:06,879
various subsystems related to

724
00:30:04,240 --> 00:30:10,480
over-the-air vectors as well

725
00:30:06,880 --> 00:30:14,000
but unfortunately majority of the auto

726
00:30:10,480 --> 00:30:14,000
ota ventures are

727
00:30:14,480 --> 00:30:20,320
located in the segments that are not

728
00:30:17,600 --> 00:30:21,918
immediately available in the firmware

729
00:30:20,320 --> 00:30:23,760
the ones that are compressed and

730
00:30:21,919 --> 00:30:25,679
relocated

731
00:30:23,760 --> 00:30:28,000
meanwhile i have tried many different

732
00:30:25,679 --> 00:30:28,000
things

733
00:30:28,720 --> 00:30:32,320
during this project the things that

734
00:30:31,200 --> 00:30:35,440
definitely worked

735
00:30:32,320 --> 00:30:37,760
is building the msm kernel

736
00:30:35,440 --> 00:30:40,159
there is nothing special about this just

737
00:30:37,760 --> 00:30:43,279
a regular cross build

738
00:30:40,159 --> 00:30:44,960
another common commonly well known

739
00:30:43,279 --> 00:30:46,640
offensive approach is firmware

740
00:30:44,960 --> 00:30:49,760
downgrades when you

741
00:30:46,640 --> 00:30:51,840
take some old firmware that contains a

742
00:30:49,760 --> 00:30:55,279
well-known security vulnerability

743
00:30:51,840 --> 00:30:58,080
and flash it and use the bug to create

744
00:30:55,279 --> 00:30:58,080
an exploit to

745
00:30:58,320 --> 00:31:02,799
achieve some additional functionality or

746
00:31:02,840 --> 00:31:07,840
introspection into the system this part

747
00:31:06,320 --> 00:31:10,480
definitely works

748
00:31:07,840 --> 00:31:11,199
downgrades are trivial both on the

749
00:31:10,480 --> 00:31:13,840
entire

750
00:31:11,200 --> 00:31:15,600
firmware and the modem as well as the

751
00:31:13,840 --> 00:31:18,320
draw zone

752
00:31:15,600 --> 00:31:20,240
i did try to build a qualcomm firmware

753
00:31:18,320 --> 00:31:22,480
from the lead source codes

754
00:31:20,240 --> 00:31:24,399
i assign just a few days to this task

755
00:31:22,480 --> 00:31:28,000
since it's not mission critical

756
00:31:24,399 --> 00:31:32,559
and i have run out of time probably

757
00:31:28,000 --> 00:31:35,279
was different version of source codes

758
00:31:32,559 --> 00:31:35,840
but actually this is uh not a critical

759
00:31:35,279 --> 00:31:38,559
project

760
00:31:35,840 --> 00:31:38,959
because building a leaked firmware is

761
00:31:38,559 --> 00:31:41,200
not

762
00:31:38,960 --> 00:31:43,039
directly relevant to find a new box in

763
00:31:41,200 --> 00:31:46,320
the production form

764
00:31:43,039 --> 00:31:49,039
so i just set it aside for some later

765
00:31:46,320 --> 00:31:49,039
investigation

766
00:31:52,000 --> 00:31:57,200
i have also investigated the ram dumps

767
00:31:55,120 --> 00:31:59,279
ecosystem a little bit on the software

768
00:31:57,200 --> 00:32:03,360
side at least and it seems that it's

769
00:31:59,279 --> 00:32:03,360
also fused quite reliably

770
00:32:06,520 --> 00:32:10,720
[Applause]

771
00:32:08,399 --> 00:32:14,000
this is when i remembered about the

772
00:32:10,720 --> 00:32:15,600
qualcomm diag

773
00:32:14,000 --> 00:32:17,760
during the initial recognitions i

774
00:32:15,600 --> 00:32:21,360
stumbled on some white papers

775
00:32:17,760 --> 00:32:23,440
and slides that mentioned the qualcomm

776
00:32:21,360 --> 00:32:25,279
diagnostic protocol

777
00:32:23,440 --> 00:32:27,200
and it seemed like quite a powerful

778
00:32:25,279 --> 00:32:29,360
protocol specifically with respect to

779
00:32:27,200 --> 00:32:32,799
reconfiguring the baseband

780
00:32:29,360 --> 00:32:34,639
so i decided to first of all to test it

781
00:32:32,799 --> 00:32:35,918
in case that it would actually provide

782
00:32:34,640 --> 00:32:37,440
some advanced introspection

783
00:32:35,919 --> 00:32:39,919
functionality

784
00:32:37,440 --> 00:32:40,559
and then probably to use it to use the

785
00:32:39,919 --> 00:32:44,399
protocol

786
00:32:40,559 --> 00:32:44,399
for enabling log dumps

787
00:32:44,960 --> 00:32:50,720
qualcomm diag or qcdm

788
00:32:48,640 --> 00:32:52,799
is a proprietary protocol developed by

789
00:32:50,720 --> 00:32:54,880
qualcomm with the purposes of

790
00:32:52,799 --> 00:32:56,879
advanced baseband software configuration

791
00:32:54,880 --> 00:33:00,399
and diagnostics

792
00:32:56,880 --> 00:33:03,200
it is mostly aimed for om developers

793
00:33:00,399 --> 00:33:03,199
not for users

794
00:33:03,600 --> 00:33:07,360
the qualcomm direct protocol consists of

795
00:33:06,159 --> 00:33:10,640
around 200

796
00:33:07,360 --> 00:33:12,879
commons at least in theory that

797
00:33:10,640 --> 00:33:14,640
uh some of them are quite powerful on

798
00:33:12,880 --> 00:33:19,360
paper such as

799
00:33:14,640 --> 00:33:19,360
downloader mode and read write memory

800
00:33:19,840 --> 00:33:26,080
initially the diag

801
00:33:23,200 --> 00:33:27,600
was partially reverse engineered around

802
00:33:26,080 --> 00:33:30,799
2010

803
00:33:27,600 --> 00:33:33,840
and included in the open source project

804
00:33:30,799 --> 00:33:37,440
named modem manager and then

805
00:33:33,840 --> 00:33:40,158
it was also exposed in a presentation

806
00:33:37,440 --> 00:33:42,799
at the cow's communication progress uh

807
00:33:40,159 --> 00:33:45,200
caused communication congress 2011 by

808
00:33:42,799 --> 00:33:45,200
guillain-barre

809
00:33:45,600 --> 00:33:49,279
this uh i think this presentation

810
00:33:47,840 --> 00:33:51,120
popularized it

811
00:33:49,279 --> 00:33:53,039
and this is the one that introduced me

812
00:33:51,120 --> 00:33:55,360
to this protocol

813
00:33:53,039 --> 00:33:56,240
unfortunately that presentation is not

814
00:33:55,360 --> 00:33:59,279
really

815
00:33:56,240 --> 00:34:01,760
relevant majority of it to

816
00:33:59,279 --> 00:34:03,440
modern production phones but it does

817
00:34:01,760 --> 00:34:06,799
provide a high level overview

818
00:34:03,440 --> 00:34:10,480
and general expectation

819
00:34:06,799 --> 00:34:12,800
of what you will have to deal with

820
00:34:10,480 --> 00:34:14,480
from the offensive perspective the

821
00:34:12,800 --> 00:34:16,639
direct protocol

822
00:34:14,480 --> 00:34:18,839
represents a local attack vector from

823
00:34:16,639 --> 00:34:20,480
the application processor to the

824
00:34:18,839 --> 00:34:22,560
basement

825
00:34:20,480 --> 00:34:23,760
a common scenario of how it can be

826
00:34:22,560 --> 00:34:27,279
useful is

827
00:34:23,760 --> 00:34:30,399
unlocking mobile phones which are locked

828
00:34:27,280 --> 00:34:31,919
to a particular mobile career

829
00:34:30,399 --> 00:34:35,118
if we find a memory corruption

830
00:34:31,918 --> 00:34:38,000
vulnerability in direct protocol

831
00:34:35,119 --> 00:34:39,599
it may be possible to execute a code

832
00:34:38,000 --> 00:34:41,359
directly on the

833
00:34:39,599 --> 00:34:43,440
base band and change some material

834
00:34:41,359 --> 00:34:45,598
settings this is usually accomplished

835
00:34:43,440 --> 00:34:46,800
historically through the 80 common

836
00:34:45,599 --> 00:34:50,159
handlers but

837
00:34:46,800 --> 00:34:52,480
internal proprietary protocols are also

838
00:34:50,159 --> 00:34:55,200
very convenient for that

839
00:34:52,480 --> 00:34:56,639
the second scenario how the diag

840
00:34:55,199 --> 00:34:59,839
offensive can be useful

841
00:34:56,639 --> 00:35:03,839
is using it for

842
00:34:59,839 --> 00:35:03,839
ejecting a software-based debugger

843
00:35:05,200 --> 00:35:08,560
if you can find a bug in dialogue that

844
00:35:07,680 --> 00:35:10,720
enables

845
00:35:08,560 --> 00:35:13,759
read write capability on the basement

846
00:35:10,720 --> 00:35:15,359
you can eject some debugging hooks

847
00:35:13,760 --> 00:35:17,359
and eventually connect connected to a

848
00:35:15,359 --> 00:35:21,598
gdp stop

849
00:35:17,359 --> 00:35:23,920
so it enables to create a

850
00:35:21,599 --> 00:35:26,080
software-based debugger even when gtac

851
00:35:23,920 --> 00:35:29,429
is not available

852
00:35:26,080 --> 00:35:29,429
[Applause]

853
00:35:29,520 --> 00:35:34,160
what has changed in diag in 10 years

854
00:35:32,000 --> 00:35:34,960
based on some cursory investigation that

855
00:35:34,160 --> 00:35:37,759
i did

856
00:35:34,960 --> 00:35:39,040
first of all the original publication

857
00:35:37,760 --> 00:35:42,480
mentioned

858
00:35:39,040 --> 00:35:46,400
qualcomm baseband based on arm and with

859
00:35:42,480 --> 00:35:48,480
rex operating system all modern qualcomm

860
00:35:46,400 --> 00:35:51,119
basements are based on hexagon

861
00:35:48,480 --> 00:35:54,320
as opposed to arm and the rex operating

862
00:35:51,119 --> 00:35:57,680
system was replaced with curt

863
00:35:54,320 --> 00:35:59,440
which i think is still has some bits of

864
00:35:57,680 --> 00:36:02,319
rags but in general it's a different

865
00:35:59,440 --> 00:36:02,320
operating system

866
00:36:03,680 --> 00:36:08,000
majority of super powerful comments of

867
00:36:06,079 --> 00:36:11,280
diax such as downloader mode

868
00:36:08,000 --> 00:36:14,640
and memory read write were removed

869
00:36:11,280 --> 00:36:14,960
at least on my device and also it does

870
00:36:14,640 --> 00:36:17,920
not

871
00:36:14,960 --> 00:36:18,960
expose any immediately available

872
00:36:17,920 --> 00:36:22,880
interfaces

873
00:36:18,960 --> 00:36:25,119
such as usb channel i hear that it's

874
00:36:22,880 --> 00:36:28,320
possible to enable that

875
00:36:25,119 --> 00:36:31,520
usb direct channel

876
00:36:28,320 --> 00:36:34,400
by adding some special

877
00:36:31,520 --> 00:36:34,400
boot properties

878
00:36:35,200 --> 00:36:39,118
but usually it's not it wouldn't be

879
00:36:37,119 --> 00:36:42,400
available it shouldn't be expected to be

880
00:36:39,119 --> 00:36:44,160
available on all devices

881
00:36:42,400 --> 00:36:45,920
so these observations were based on my

882
00:36:44,160 --> 00:36:49,200
test device nexus 6p

883
00:36:45,920 --> 00:36:53,200
and this this should be around

884
00:36:49,200 --> 00:36:53,200
medium level of hardening

885
00:36:53,599 --> 00:36:56,800
more modern devices such as google

886
00:36:55,520 --> 00:36:58,960
pixels

887
00:36:56,800 --> 00:37:01,280
the modern ones should be expected to be

888
00:36:58,960 --> 00:37:02,880
even more hardened than that

889
00:37:01,280 --> 00:37:05,680
especially on the google side because

890
00:37:02,880 --> 00:37:08,240
they take hardening very seriously

891
00:37:05,680 --> 00:37:09,040
as opposed to it on the other side of

892
00:37:08,240 --> 00:37:12,078
this picture

893
00:37:09,040 --> 00:37:15,440
if you think about some

894
00:37:12,079 --> 00:37:16,320
no-name modem sticks these things can be

895
00:37:15,440 --> 00:37:22,079
more open

896
00:37:16,320 --> 00:37:25,040
and more easy to investigate

897
00:37:22,079 --> 00:37:26,640
the niacc implementation architecture is

898
00:37:25,040 --> 00:37:28,800
relatively simple

899
00:37:26,640 --> 00:37:30,480
this diagram is based roughly on the

900
00:37:28,800 --> 00:37:31,680
same diagram that i presented in the

901
00:37:30,480 --> 00:37:33,440
beginning of the talk

902
00:37:31,680 --> 00:37:35,440
on the light side on the on the left

903
00:37:33,440 --> 00:37:37,920
side there is the android kernel

904
00:37:35,440 --> 00:37:41,200
and on the right side there is the

905
00:37:37,920 --> 00:37:41,200
basement operating system

906
00:37:41,839 --> 00:37:46,240
the protocol actually it works in both

907
00:37:44,079 --> 00:37:47,599
sides it's not only commands

908
00:37:46,240 --> 00:37:49,839
that can be sent by the application

909
00:37:47,599 --> 00:37:51,599
processor to the basement but it's also

910
00:37:49,839 --> 00:37:54,000
the messages that can be sent by the

911
00:37:51,599 --> 00:37:55,839
basement to the application processor

912
00:37:54,000 --> 00:37:57,520
so their commands are not really

913
00:37:55,839 --> 00:38:01,680
commands they're more like tokens

914
00:37:57,520 --> 00:38:03,599
that also can be used to encode messages

915
00:38:01,680 --> 00:38:05,440
the green arrows on this slide

916
00:38:03,599 --> 00:38:08,400
represents an example

917
00:38:05,440 --> 00:38:09,839
an example of a call flow of the data

918
00:38:08,400 --> 00:38:11,520
flow

919
00:38:09,839 --> 00:38:13,599
originating from the baseband and go

920
00:38:11,520 --> 00:38:16,560
into the application processor

921
00:38:13,599 --> 00:38:19,119
so obviously in case of commands there

922
00:38:16,560 --> 00:38:21,680
would be a reversible flow

923
00:38:19,119 --> 00:38:21,680
data flow

924
00:38:25,040 --> 00:38:29,119
the main entity inside the operating

925
00:38:27,280 --> 00:38:31,520
system basement operating system

926
00:38:29,119 --> 00:38:33,839
responsible for diag is the direct task

927
00:38:31,520 --> 00:38:37,119
it has a separate task

928
00:38:33,839 --> 00:38:39,200
which handles specifically various

929
00:38:37,119 --> 00:38:41,680
operations related to the direct

930
00:38:39,200 --> 00:38:41,680
protocol

931
00:38:43,599 --> 00:38:48,640
the the exchange of data between the

932
00:38:46,560 --> 00:38:49,279
direct task and other tasks are done

933
00:38:48,640 --> 00:38:52,480
through the

934
00:38:49,280 --> 00:38:55,599
ring buffer so for example

935
00:38:52,480 --> 00:38:57,040
if um if some tasks if some task needs

936
00:38:55,599 --> 00:39:00,320
to

937
00:38:57,040 --> 00:39:05,279
log log something through the diag

938
00:39:00,320 --> 00:39:07,920
it will use um specialized login apis

939
00:39:05,280 --> 00:39:09,440
and it will in turn put logging data

940
00:39:07,920 --> 00:39:11,839
into the ring buffer

941
00:39:09,440 --> 00:39:13,040
the ring buffer will be drained either

942
00:39:11,839 --> 00:39:16,720
on timer or

943
00:39:13,040 --> 00:39:20,079
on a software based interrupt from

944
00:39:16,720 --> 00:39:23,520
from the caller and

945
00:39:20,079 --> 00:39:26,880
at this point the data will be wrapped

946
00:39:23,520 --> 00:39:28,400
into dia protocol and from there it will

947
00:39:26,880 --> 00:39:32,960
go to

948
00:39:28,400 --> 00:39:35,599
see your task this serial isle

949
00:39:32,960 --> 00:39:36,240
which is responsible to sending the

950
00:39:35,599 --> 00:39:39,760
output

951
00:39:36,240 --> 00:39:42,000
to a specific interface

952
00:39:39,760 --> 00:39:45,040
this is based on the modem on the

953
00:39:42,000 --> 00:39:45,040
basement configuration

954
00:39:49,119 --> 00:39:52,720
the main interface that i was dealing

955
00:39:52,400 --> 00:39:55,920
with

956
00:39:52,720 --> 00:39:56,240
is the shared memory which ends up in

957
00:39:55,920 --> 00:39:59,280
the

958
00:39:56,240 --> 00:40:03,520
director driver

959
00:39:59,280 --> 00:40:03,520
in inside the android kernel

960
00:40:03,680 --> 00:40:07,839
so in case of sending the comments from

961
00:40:06,240 --> 00:40:08,640
the android kernel to the basement it

962
00:40:07,839 --> 00:40:12,319
will be the

963
00:40:08,640 --> 00:40:14,160
reverse flow the first you will need to

964
00:40:12,319 --> 00:40:16,880
send some

965
00:40:14,160 --> 00:40:18,399
to craft the diet protocol data send it

966
00:40:16,880 --> 00:40:20,000
through the actual driver

967
00:40:18,400 --> 00:40:23,359
that will write to the shared memory

968
00:40:20,000 --> 00:40:25,280
interface from there it will go to the

969
00:40:23,359 --> 00:40:26,400
specialized specialized task in the

970
00:40:25,280 --> 00:40:28,480
basement

971
00:40:26,400 --> 00:40:29,440
and eventually end up in the direct task

972
00:40:28,480 --> 00:40:39,839
and

973
00:40:29,440 --> 00:40:39,839
potentially in other responsible tasks

974
00:40:40,400 --> 00:40:43,599
on the android side diag is represented

975
00:40:43,040 --> 00:40:46,319
with the

976
00:40:43,599 --> 00:40:46,880
dev diag device which is implemented

977
00:40:46,319 --> 00:40:50,079
with the

978
00:40:46,880 --> 00:40:53,280
director and dac forward kernel drivers

979
00:40:50,079 --> 00:40:56,400
in the msm kernel

980
00:40:53,280 --> 00:40:58,480
the purpose of the director driver is to

981
00:40:56,400 --> 00:41:01,520
support the dioc interface

982
00:40:58,480 --> 00:41:03,920
it is quite it's quite complex

983
00:41:01,520 --> 00:41:05,680
in code but functionally it's quite

984
00:41:03,920 --> 00:41:08,800
simple

985
00:41:05,680 --> 00:41:11,118
it contains some basic minimum

986
00:41:08,800 --> 00:41:12,960
of direct comments that enable

987
00:41:11,119 --> 00:41:14,560
configuration of the interface on the

988
00:41:12,960 --> 00:41:17,200
basement side

989
00:41:14,560 --> 00:41:17,599
and then it would be able to multiplex

990
00:41:17,200 --> 00:41:19,839
the

991
00:41:17,599 --> 00:41:20,880
the channel to either usb or memory

992
00:41:19,839 --> 00:41:24,160
device

993
00:41:20,880 --> 00:41:28,160
it also contains some

994
00:41:24,160 --> 00:41:30,078
ios details too for configuration

995
00:41:28,160 --> 00:41:31,440
that can be accessed from the android

996
00:41:30,079 --> 00:41:35,440
user land

997
00:41:31,440 --> 00:41:38,160
and finally the actual filters various

998
00:41:35,440 --> 00:41:39,359
comments that it considers unnecessary

999
00:41:38,160 --> 00:41:43,598
this is a bit

1000
00:41:39,359 --> 00:41:45,680
important because when you will start

1001
00:41:43,599 --> 00:41:47,040
when you will try to do some tests and

1002
00:41:45,680 --> 00:41:49,680
send some arbitrary

1003
00:41:47,040 --> 00:41:50,160
comments through the deck interface you

1004
00:41:49,680 --> 00:41:53,200
would

1005
00:41:50,160 --> 00:41:53,839
be required to rebuild the temperature

1006
00:41:53,200 --> 00:41:55,839
driver

1007
00:41:53,839 --> 00:41:57,920
to remove to remove this masking

1008
00:41:55,839 --> 00:42:02,160
otherwise your commands will not

1009
00:41:57,920 --> 00:42:04,560
make it to the basement side

1010
00:42:02,160 --> 00:42:05,200
at the core the director driver is based

1011
00:42:04,560 --> 00:42:08,560
on the

1012
00:42:05,200 --> 00:42:12,399
smd sharing memory device interface

1013
00:42:08,560 --> 00:42:17,440
which is a core interface specific to

1014
00:42:12,400 --> 00:42:20,800
qualcomm modem

1015
00:42:17,440 --> 00:42:25,359
so this is where the diag is the

1016
00:42:20,800 --> 00:42:25,359
director is on the diagram

1017
00:42:25,920 --> 00:42:29,839
the director driver itself is located in

1018
00:42:28,800 --> 00:42:34,079
the application

1019
00:42:29,839 --> 00:42:34,078
os vendor specific drivers

1020
00:42:34,319 --> 00:42:37,759
and then there is the

1021
00:42:38,000 --> 00:42:41,680
some shared memory implementation in the

1022
00:42:39,680 --> 00:42:45,839
basement that handles this

1023
00:42:41,680 --> 00:42:45,839
and the dioc implementation itself

1024
00:42:49,520 --> 00:42:56,839
the actual driver is quite complex

1025
00:42:52,800 --> 00:42:59,599
in code but the functionality is quite

1026
00:42:56,839 --> 00:43:02,640
simple

1027
00:42:59,599 --> 00:43:05,839
it does implement a handful of ictels

1028
00:43:02,640 --> 00:43:08,480
that enable some configuration

1029
00:43:05,839 --> 00:43:12,640
i i didn't check what exactly this

1030
00:43:08,480 --> 00:43:15,440
isotels are responsible for

1031
00:43:12,640 --> 00:43:17,520
it exposes the dev device which is

1032
00:43:15,440 --> 00:43:20,079
available for reading and writing

1033
00:43:17,520 --> 00:43:21,599
however by default you are not able to

1034
00:43:20,079 --> 00:43:24,880
access the direct channel

1035
00:43:21,599 --> 00:43:26,880
based on for this device because in

1036
00:43:24,880 --> 00:43:29,599
order to access it

1037
00:43:26,880 --> 00:43:30,560
there is a direct switch login function

1038
00:43:29,599 --> 00:43:33,599
which

1039
00:43:30,560 --> 00:43:38,000
switches the channel to

1040
00:43:33,599 --> 00:43:40,400
that is used for dial communications

1041
00:43:38,000 --> 00:43:42,400
on this screen there is several modes

1042
00:43:40,400 --> 00:43:44,240
listed but in practice only two of them

1043
00:43:42,400 --> 00:43:47,680
are supported the usb mode

1044
00:43:44,240 --> 00:43:48,479
and the memory device mode usb mode is

1045
00:43:47,680 --> 00:43:51,598
the default

1046
00:43:48,480 --> 00:43:55,040
so which is why if you

1047
00:43:51,599 --> 00:43:57,200
just open the dev driver the device and

1048
00:43:55,040 --> 00:43:58,319
try to read something from it it won't

1049
00:43:57,200 --> 00:44:01,598
work

1050
00:43:58,319 --> 00:44:05,279
it's tied to usb and in order to

1051
00:44:01,599 --> 00:44:05,280
reconfigure it to use the

1052
00:44:06,400 --> 00:44:11,599
memory device you need to send a special

1053
00:44:08,640 --> 00:44:11,598
rctl code

1054
00:44:15,599 --> 00:44:18,880
notice the procedure name mask request

1055
00:44:17,920 --> 00:44:23,359
validate

1056
00:44:18,880 --> 00:44:25,599
which employs a quite a strict filtering

1057
00:44:23,359 --> 00:44:28,240
on the dial commands that you try to

1058
00:44:25,599 --> 00:44:32,079
send through this interface

1059
00:44:28,240 --> 00:44:33,520
so it filters out basically everything

1060
00:44:32,079 --> 00:44:38,240
with the exception of some

1061
00:44:33,520 --> 00:44:38,240
basic requests

1062
00:44:39,280 --> 00:44:44,400
at the core director driver uses the

1063
00:44:42,400 --> 00:44:46,560
shared memory device to communicate with

1064
00:44:44,400 --> 00:44:50,960
the base band

1065
00:44:46,560 --> 00:44:54,319
the smd implementation is quite complex

1066
00:44:50,960 --> 00:44:57,280
it exposes smd read api

1067
00:44:54,319 --> 00:44:59,599
which is used by the actual for reading

1068
00:44:57,280 --> 00:45:03,520
the data from the shared memory

1069
00:44:59,599 --> 00:45:08,240
one of the apis shared memory also

1070
00:45:03,520 --> 00:45:08,240
operates on the obstruction of channels

1071
00:45:10,319 --> 00:45:17,520
which are accessed through the

1072
00:45:13,920 --> 00:45:19,119
api named smd named open an edge

1073
00:45:17,520 --> 00:45:20,720
so you can notice here that there are

1074
00:45:19,119 --> 00:45:21,950
some direct specific channels that can

1075
00:45:20,720 --> 00:45:23,200
be opened

1076
00:45:21,950 --> 00:45:24,879
[Applause]

1077
00:45:23,200 --> 00:45:26,319
now let's take a look at the smd

1078
00:45:24,880 --> 00:45:29,040
implementation this is a bit

1079
00:45:26,319 --> 00:45:31,119
important because a shared memory device

1080
00:45:29,040 --> 00:45:33,359
represents a part of the attack surface

1081
00:45:31,119 --> 00:45:34,800
for escalation from the modem to the

1082
00:45:33,359 --> 00:45:37,279
application processor

1083
00:45:34,800 --> 00:45:38,319
this is a very important attack surface

1084
00:45:37,280 --> 00:45:40,240
because if you just

1085
00:45:38,319 --> 00:45:41,920
achieve code execution on the basement

1086
00:45:40,240 --> 00:45:45,598
it's mostly useless

1087
00:45:41,920 --> 00:45:48,079
because it cannot access the

1088
00:45:45,599 --> 00:45:49,200
main operating system and in order to

1089
00:45:48,079 --> 00:45:52,560
make it useful

1090
00:45:49,200 --> 00:45:53,439
you will need to chain them to create an

1091
00:45:52,560 --> 00:45:55,599
exploit chain

1092
00:45:53,440 --> 00:45:57,119
and and one more exploit based on that

1093
00:45:55,599 --> 00:46:00,240
block

1094
00:45:57,119 --> 00:46:01,200
with um privilege escalation from the

1095
00:46:00,240 --> 00:46:03,520
modem

1096
00:46:01,200 --> 00:46:05,359
to the application processor so shared

1097
00:46:03,520 --> 00:46:08,240
memory device is one of the attack

1098
00:46:05,359 --> 00:46:08,240
services for this

1099
00:46:08,400 --> 00:46:13,280
the shared memory device is implemented

1100
00:46:13,440 --> 00:46:21,200
as um exposed my region

1101
00:46:17,440 --> 00:46:21,200
exposed by the qualcomm peripheral

1102
00:46:21,520 --> 00:46:28,480
the specialized msn driver will map it

1103
00:46:24,720 --> 00:46:33,520
and here it's the name snam ram face

1104
00:46:28,480 --> 00:46:33,520
the base of the shared memory region

1105
00:46:33,760 --> 00:46:38,480
the shared memory region is

1106
00:46:39,280 --> 00:46:43,839
operates on the concepts of

1107
00:46:44,079 --> 00:46:48,160
entries and channels so it's partitioned

1108
00:46:47,599 --> 00:46:50,880
in

1109
00:46:48,160 --> 00:46:54,799
distant parts that can be accessed

1110
00:46:50,880 --> 00:46:54,800
through the procedure smm get entry

1111
00:46:55,119 --> 00:46:59,760
and one of these entries is

1112
00:47:00,720 --> 00:47:07,520
smam channel tbl which contains

1113
00:47:04,079 --> 00:47:09,760
the list of available channels

1114
00:47:07,520 --> 00:47:11,040
that can be opened from there we can

1115
00:47:09,760 --> 00:47:16,240
actually open the channels

1116
00:47:11,040 --> 00:47:16,240
and use the shared memory interface

1117
00:47:17,520 --> 00:47:24,160
during this initial research project it

1118
00:47:20,000 --> 00:47:26,880
wasn't my goal to

1119
00:47:24,160 --> 00:47:28,480
to research the entire qualcomm

1120
00:47:26,880 --> 00:47:31,359
ecosystem

1121
00:47:28,480 --> 00:47:32,400
so while i was preparing for this talk i

1122
00:47:31,359 --> 00:47:34,160
have noticed

1123
00:47:32,400 --> 00:47:37,200
some more interesting things in the

1124
00:47:34,160 --> 00:47:41,598
source codes such as for example the

1125
00:47:37,200 --> 00:47:45,359
specialized driver that handles um

1126
00:47:41,599 --> 00:47:48,960
g tag my region which is presumably

1127
00:47:45,359 --> 00:47:51,200
exposed by some qualcomm system on chips

1128
00:47:48,960 --> 00:47:52,400
in the drivers this is mostly used read

1129
00:47:51,200 --> 00:47:54,879
only

1130
00:47:52,400 --> 00:47:55,440
and i suppose that it will not really

1131
00:47:54,880 --> 00:47:57,520
work

1132
00:47:55,440 --> 00:47:59,920
for writing but it's worth checking

1133
00:47:57,520 --> 00:47:59,920
probably

1134
00:48:01,440 --> 00:48:08,079
and now finally let's look at the

1135
00:48:05,200 --> 00:48:09,040
protocol itself one of the first things

1136
00:48:08,079 --> 00:48:12,000
that i noticed

1137
00:48:09,040 --> 00:48:13,599
when researching the diet protocol is

1138
00:48:12,000 --> 00:48:17,839
that it's actually used

1139
00:48:13,599 --> 00:48:21,040
in a few places not only in lip qcd

1140
00:48:17,839 --> 00:48:22,960
a popular tool named snobsnitch can

1141
00:48:21,040 --> 00:48:26,079
enable protocol dumps solar

1142
00:48:22,960 --> 00:48:29,040
protocol dubs on rooted devices

1143
00:48:26,079 --> 00:48:30,960
and in order to accomplish this snoop's

1144
00:48:29,040 --> 00:48:33,599
niche sends a pack blob

1145
00:48:30,960 --> 00:48:36,880
of their comments to the mobile device

1146
00:48:33,599 --> 00:48:39,119
through the direct interface

1147
00:48:36,880 --> 00:48:41,280
this block is normal is not documented

1148
00:48:39,119 --> 00:48:43,359
so it got me curious what exactly these

1149
00:48:41,280 --> 00:48:46,480
commands are doing

1150
00:48:43,359 --> 00:48:49,839
but before we can look at the dump

1151
00:48:46,480 --> 00:48:49,839
let's understand the protocol

1152
00:48:49,920 --> 00:48:56,800
the diet protocol consists of around 200

1153
00:48:53,200 --> 00:48:59,118
of commons or tokens

1154
00:48:56,800 --> 00:49:00,240
some of them are documented in the open

1155
00:48:59,119 --> 00:49:03,280
source

1156
00:49:00,240 --> 00:49:04,558
but not all of them so you can notice on

1157
00:49:03,280 --> 00:49:07,040
the screenshots

1158
00:49:04,559 --> 00:49:09,440
some of the comments are missing and one

1159
00:49:07,040 --> 00:49:13,200
of the missing comments is actually

1160
00:49:09,440 --> 00:49:17,440
the token

1161
00:49:13,200 --> 00:49:21,118
92 in hexadecimal

1162
00:49:17,440 --> 00:49:24,079
which represents a encoded

1163
00:49:21,119 --> 00:49:24,079
hash log message

1164
00:49:25,359 --> 00:49:29,119
the common format is quite simple

1165
00:49:29,440 --> 00:49:36,319
it's the base primitive

1166
00:49:32,800 --> 00:49:39,760
here is that direct token number 7e

1167
00:49:36,319 --> 00:49:43,040
it's not really a delimiter it's a

1168
00:49:39,760 --> 00:49:46,079
separate guy comment

1169
00:49:43,040 --> 00:49:47,920
126 it's missing in the open source as

1170
00:49:46,079 --> 00:49:50,559
you can see here

1171
00:49:47,920 --> 00:49:51,119
so the dial command is nested the outer

1172
00:49:50,559 --> 00:49:55,200
layer

1173
00:49:51,119 --> 00:49:57,920
consists of the this wrapper of

1174
00:49:55,200 --> 00:49:59,359
seven e hexadecimal bytes then there is

1175
00:49:57,920 --> 00:50:01,520
the main command

1176
00:49:59,359 --> 00:50:02,880
and then there is some variable length

1177
00:50:01,520 --> 00:50:06,079
data that can contain

1178
00:50:02,880 --> 00:50:10,319
even more subcommands this entire thing

1179
00:50:06,079 --> 00:50:13,200
is verified using the crc

1180
00:50:10,319 --> 00:50:16,160
and some bytes are escaped specifically

1181
00:50:13,200 --> 00:50:18,240
as you can see on the snippet

1182
00:50:16,160 --> 00:50:19,598
one interesting thing about the diode

1183
00:50:18,240 --> 00:50:23,680
protocol is that

1184
00:50:19,599 --> 00:50:25,760
it supports subsystem extensions

1185
00:50:23,680 --> 00:50:28,078
basically different subsystems in the

1186
00:50:25,760 --> 00:50:31,359
basement can register their own direct

1187
00:50:28,079 --> 00:50:36,079
system handlers arbitrary ones

1188
00:50:31,359 --> 00:50:38,319
and there is a special comment number 75

1189
00:50:36,079 --> 00:50:40,160
which simply forwards instructs the

1190
00:50:38,319 --> 00:50:42,480
direct system to forward this command to

1191
00:50:40,160 --> 00:50:46,879
the respective subsystem

1192
00:50:42,480 --> 00:50:46,880
and then it will be parsed there

1193
00:50:47,520 --> 00:50:52,160
the there exists quite a large number of

1194
00:50:52,839 --> 00:50:55,839
subsystems

1195
00:50:56,559 --> 00:51:00,640
not all of them are documented and when

1196
00:50:58,800 --> 00:51:03,200
i started investigating this

1197
00:51:00,640 --> 00:51:05,118
i noticed that there actually exists a

1198
00:51:03,200 --> 00:51:10,000
diag substance of system

1199
00:51:05,119 --> 00:51:13,119
and debugging subsystem the later one

1200
00:51:10,000 --> 00:51:15,599
immediately interested me because

1201
00:51:13,119 --> 00:51:17,200
i was hoping that it would enable some

1202
00:51:15,599 --> 00:51:18,800
more advanced introspection through this

1203
00:51:17,200 --> 00:51:20,839
debugging subsystem

1204
00:51:18,800 --> 00:51:22,160
but it turned out that the debugging

1205
00:51:20,839 --> 00:51:24,400
subsystem

1206
00:51:22,160 --> 00:51:25,759
is quite simple it only supported one

1207
00:51:24,400 --> 00:51:28,559
command

1208
00:51:25,760 --> 00:51:28,559
inject crash

1209
00:51:28,850 --> 00:51:33,598
[Applause]

1210
00:51:31,680 --> 00:51:35,680
so you can send a special direct command

1211
00:51:33,599 --> 00:51:37,040
that will inject the crash into the

1212
00:51:35,680 --> 00:51:40,879
basement

1213
00:51:37,040 --> 00:51:40,880
i will talk later about this

1214
00:51:42,480 --> 00:51:46,640
now let's take a look at specific

1215
00:51:44,000 --> 00:51:51,440
examples of the dag protocol

1216
00:51:46,640 --> 00:51:55,359
this is the annotated snippet of the

1217
00:51:51,440 --> 00:51:55,359
blob of comments from snoop snitch

1218
00:51:56,160 --> 00:51:59,200
this blog actually consists of three

1219
00:51:58,559 --> 00:52:01,599
large

1220
00:51:59,200 --> 00:52:02,399
logical parts the first part is largely

1221
00:52:01,599 --> 00:52:04,079
irrelevant

1222
00:52:02,400 --> 00:52:06,480
it's a bunch of comments that request

1223
00:52:04,079 --> 00:52:08,559
various informations from the baseband

1224
00:52:06,480 --> 00:52:10,480
such as timestamp version and four build

1225
00:52:08,559 --> 00:52:14,079
id and so on

1226
00:52:10,480 --> 00:52:16,400
the second bunch of comments

1227
00:52:14,079 --> 00:52:17,520
starts with a command number 73

1228
00:52:16,400 --> 00:52:20,720
hexadecimal

1229
00:52:17,520 --> 00:52:24,079
this is the common log config

1230
00:52:20,720 --> 00:52:28,959
this is the command which enables

1231
00:52:24,079 --> 00:52:32,160
protocol dumps and configures them

1232
00:52:28,960 --> 00:52:34,880
and the third part of this blob starts

1233
00:52:32,160 --> 00:52:37,440
with the command number 7d hexadecimal

1234
00:52:34,880 --> 00:52:39,520
this is the command x message config

1235
00:52:37,440 --> 00:52:41,920
this is actually the command that

1236
00:52:39,520 --> 00:52:42,640
is supposed to enable textual message

1237
00:52:41,920 --> 00:52:44,480
login

1238
00:52:42,640 --> 00:52:47,609
except that in case of the snoop snitch

1239
00:52:44,480 --> 00:52:50,079
it disables all logging all together

1240
00:52:47,610 --> 00:52:53,280
[Applause]

1241
00:52:50,079 --> 00:52:54,319
so how do actually cellular protocol

1242
00:52:53,280 --> 00:52:56,240
dumps work

1243
00:52:54,319 --> 00:52:57,359
in order to enable the solar protocol

1244
00:52:56,240 --> 00:53:00,720
dumps we need

1245
00:52:57,359 --> 00:53:02,558
a direct command lock config number 73

1246
00:53:00,720 --> 00:53:04,319
hexadecimal

1247
00:53:02,559 --> 00:53:06,720
it is partially documented in the lip

1248
00:53:04,319 --> 00:53:08,400
qcdm

1249
00:53:06,720 --> 00:53:10,480
the structure of the packet would

1250
00:53:08,400 --> 00:53:12,960
contain the code

1251
00:53:10,480 --> 00:53:14,720
and the subcomment would that would be

1252
00:53:12,960 --> 00:53:17,920
set mask in this case

1253
00:53:14,720 --> 00:53:20,160
it also needs an equipment id which

1254
00:53:17,920 --> 00:53:23,440
corresponds to the

1255
00:53:20,160 --> 00:53:26,240
specific protocol that we want to dump

1256
00:53:23,440 --> 00:53:27,599
and finally the masks that are applied

1257
00:53:26,240 --> 00:53:32,160
to

1258
00:53:27,599 --> 00:53:35,920
filter some parts of the dump

1259
00:53:32,160 --> 00:53:39,200
this is relatively straightforward

1260
00:53:35,920 --> 00:53:40,559
and now the second command direct

1261
00:53:39,200 --> 00:53:43,359
command text message config

1262
00:53:40,559 --> 00:53:44,079
this is the one which is supposed to

1263
00:53:43,359 --> 00:53:47,359
enable

1264
00:53:44,079 --> 00:53:47,359
textile message laws

1265
00:53:47,760 --> 00:53:53,280
this the common format is undocumented

1266
00:53:50,319 --> 00:53:56,960
so let's take a closer look at it

1267
00:53:53,280 --> 00:53:59,920
the the comment

1268
00:53:56,960 --> 00:53:59,920
consists of

1269
00:54:00,079 --> 00:54:03,760
a sub command in this case it's sub

1270
00:54:02,720 --> 00:54:07,279
comment number four

1271
00:54:03,760 --> 00:54:10,559
the set mask and then there are two

1272
00:54:07,280 --> 00:54:14,319
16 bit integers

1273
00:54:10,559 --> 00:54:15,119
ssid start and end ssid is a subsystem

1274
00:54:14,319 --> 00:54:17,040
id

1275
00:54:15,119 --> 00:54:19,520
which is not the same as the dioxide

1276
00:54:17,040 --> 00:54:19,520
systems

1277
00:54:19,680 --> 00:54:26,879
and the last one is the mask so

1278
00:54:23,280 --> 00:54:29,599
subsystem ids are used to filter the

1279
00:54:26,880 --> 00:54:31,839
messages based on a specific subsystem

1280
00:54:29,599 --> 00:54:33,200
because the there is a huge amount of

1281
00:54:31,839 --> 00:54:35,599
subsystems in the basement

1282
00:54:33,200 --> 00:54:37,520
and if all of them start logging this is

1283
00:54:35,599 --> 00:54:40,559
a huge amount of data so

1284
00:54:37,520 --> 00:54:41,359
that provides this capability to filter

1285
00:54:40,559 --> 00:54:43,200
a little bit

1286
00:54:41,359 --> 00:54:45,759
to a specific subsystem that you're

1287
00:54:43,200 --> 00:54:45,759
interested in

1288
00:54:45,920 --> 00:54:52,160
the the snippet of python code here

1289
00:54:49,040 --> 00:54:53,040
is an example how to enable textile

1290
00:54:52,160 --> 00:54:56,399
message logging

1291
00:54:53,040 --> 00:54:56,400
for all subsystems

1292
00:54:57,119 --> 00:55:01,440
you'll need to set the mask to all ones

1293
00:55:02,240 --> 00:55:07,189
and this is quite a lot of logging in my

1294
00:55:05,359 --> 00:55:11,119
experience

1295
00:55:07,190 --> 00:55:13,520
[Applause]

1296
00:55:11,119 --> 00:55:15,599
now for parsing the incoming log

1297
00:55:13,520 --> 00:55:17,920
messages there are two types of

1298
00:55:15,599 --> 00:55:19,359
direct tokens both of them are

1299
00:55:17,920 --> 00:55:22,079
undocumented

1300
00:55:19,359 --> 00:55:23,279
the first one is a legacy message number

1301
00:55:22,079 --> 00:55:27,359
79

1302
00:55:23,280 --> 00:55:28,000
hexadecimal this is a simple ascii based

1303
00:55:27,359 --> 00:55:31,279
message

1304
00:55:28,000 --> 00:55:33,119
that arrives through the diag interface

1305
00:55:31,280 --> 00:55:36,079
so you can parse it quite

1306
00:55:33,119 --> 00:55:36,079
straightforwardly

1307
00:55:36,240 --> 00:55:39,839
the second one is i called it the

1308
00:55:38,720 --> 00:55:42,959
command log hash

1309
00:55:39,839 --> 00:55:44,400
it's number 92 hexadecimal this is the

1310
00:55:42,960 --> 00:55:46,880
token which encodes

1311
00:55:44,400 --> 00:55:49,280
the log messages that contain of that

1312
00:55:46,880 --> 00:55:50,880
contain only the hashes

1313
00:55:49,280 --> 00:55:52,799
this is the one that if you have the

1314
00:55:50,880 --> 00:55:56,079
message message

1315
00:55:52,799 --> 00:55:57,759
dot txt file you can correspond the hash

1316
00:55:56,079 --> 00:56:00,000
arrive that was arrived through this

1317
00:55:57,760 --> 00:56:02,000
comment to the messages provided in the

1318
00:56:00,000 --> 00:56:03,599
text file and you can get the textual

1319
00:56:02,000 --> 00:56:06,240
logs

1320
00:56:03,599 --> 00:56:08,160
on the lower part of the slide there are

1321
00:56:06,240 --> 00:56:11,279
two examples of hexdumps

1322
00:56:08,160 --> 00:56:13,200
for both commands

1323
00:56:11,280 --> 00:56:14,960
both of them have a similar structure

1324
00:56:13,200 --> 00:56:18,240
first there are

1325
00:56:14,960 --> 00:56:21,520
four bytes that are essential the first

1326
00:56:18,240 --> 00:56:21,520
one is the command itself

1327
00:56:21,599 --> 00:56:28,480
and the third byte is quite interesting

1328
00:56:24,799 --> 00:56:31,359
is the number of arguments included

1329
00:56:28,480 --> 00:56:33,040
next there is a 64-bit value of

1330
00:56:31,359 --> 00:56:36,960
timestamp

1331
00:56:33,040 --> 00:56:40,240
next there is the ssid value 16-bit

1332
00:56:36,960 --> 00:56:43,280
some line number and

1333
00:56:40,240 --> 00:56:46,558
i'm not sure what is the next argument

1334
00:56:43,280 --> 00:56:50,319
and finally after that there is either

1335
00:56:46,559 --> 00:56:54,160
a ascii encoded log string

1336
00:56:50,319 --> 00:56:58,079
in plain text or a hash

1337
00:56:54,160 --> 00:57:00,078
of the log string

1338
00:56:58,079 --> 00:57:02,400
and optionally there may be included

1339
00:57:00,079 --> 00:57:05,040
some arguments

1340
00:57:02,400 --> 00:57:06,720
so in case of um the first legacy

1341
00:57:05,040 --> 00:57:08,319
command the arguments are included

1342
00:57:06,720 --> 00:57:10,558
before the log message

1343
00:57:08,319 --> 00:57:13,359
and in case of the second comment they

1344
00:57:10,559 --> 00:57:15,920
are included after the

1345
00:57:13,359 --> 00:57:17,569
md5 hash of the log message at least in

1346
00:57:15,920 --> 00:57:20,749
my version of this implementation

1347
00:57:17,570 --> 00:57:20,749
[Applause]

1348
00:57:23,520 --> 00:57:27,520
and this is a direct packet that enables

1349
00:57:26,960 --> 00:57:30,160
you

1350
00:57:27,520 --> 00:57:32,079
to inject a crash into the basement at

1351
00:57:30,160 --> 00:57:35,118
least in theory

1352
00:57:32,079 --> 00:57:38,319
because in my case it did not work

1353
00:57:35,119 --> 00:57:40,559
and by not working i mean that it did

1354
00:57:38,319 --> 00:57:42,160
simply nothing to the basement

1355
00:57:40,559 --> 00:57:43,760
normally i would expect that on

1356
00:57:42,160 --> 00:57:45,759
production device it should

1357
00:57:43,760 --> 00:57:48,000
just rest at the base band you will not

1358
00:57:45,760 --> 00:57:51,680
get a garage dump or anything like that

1359
00:57:48,000 --> 00:57:52,319
it's just just arrested so i suppose

1360
00:57:51,680 --> 00:57:54,399
that

1361
00:57:52,319 --> 00:57:56,880
it still should be working on some other

1362
00:57:54,400 --> 00:57:58,960
devices so it's worthy of checking

1363
00:57:56,880 --> 00:57:59,920
there are a few types of crashes that

1364
00:57:58,960 --> 00:58:03,040
you can

1365
00:57:59,920 --> 00:58:03,040
request in this way

1366
00:58:05,280 --> 00:58:09,839
[Applause]

1367
00:58:06,720 --> 00:58:12,558
in order to accomplish this i needed a

1368
00:58:09,839 --> 00:58:15,680
very simple tool

1369
00:58:12,559 --> 00:58:19,200
with basically two functions first

1370
00:58:15,680 --> 00:58:21,040
direct easy access to the diac interface

1371
00:58:19,200 --> 00:58:22,399
ideally through some sort of python

1372
00:58:21,040 --> 00:58:25,599
shell and second

1373
00:58:22,400 --> 00:58:26,400
is the ability to read and parse data

1374
00:58:25,599 --> 00:58:29,200
with

1375
00:58:26,400 --> 00:58:31,040
advanced log strings for that purpose i

1376
00:58:29,200 --> 00:58:34,319
wrote a simple framework

1377
00:58:31,040 --> 00:58:34,319
that i named diag talk

1378
00:58:34,480 --> 00:58:39,599
which is uh based directly on the dev

1379
00:58:38,240 --> 00:58:44,319
diag interface

1380
00:58:39,599 --> 00:58:47,599
in the android kernel and

1381
00:58:44,319 --> 00:58:50,720
with a python harness

1382
00:58:47,599 --> 00:58:53,760
so on the left side here is an example

1383
00:58:50,720 --> 00:58:57,279
of some advanced parsing

1384
00:58:53,760 --> 00:59:00,000
with some linked values and on the right

1385
00:58:57,280 --> 00:59:00,799
side here is the example of the advanced

1386
00:59:00,000 --> 00:59:04,000
message log

1387
00:59:00,799 --> 00:59:05,759
which includes the log strings

1388
00:59:04,000 --> 00:59:07,440
that were extracted uh that were

1389
00:59:05,760 --> 00:59:11,280
stripped out from the

1390
00:59:07,440 --> 00:59:15,200
firmware the lock is quite fun

1391
00:59:11,280 --> 00:59:18,000
as i expected to be it has a lot of

1392
00:59:15,200 --> 00:59:19,598
detailed data such as for example gps

1393
00:59:18,000 --> 00:59:22,319
coordinates

1394
00:59:19,599 --> 00:59:25,599
and various attempts of the basement to

1395
00:59:22,319 --> 00:59:25,599
connect to different channels

1396
00:59:28,240 --> 00:59:35,118
and i think it's quite useful for

1397
00:59:32,240 --> 00:59:36,399
offensive research purposes it's even

1398
00:59:35,119 --> 00:59:38,240
contains sometimes

1399
00:59:36,400 --> 00:59:40,880
raw pointers as you can notice on

1400
00:59:38,240 --> 00:59:40,879
screenshot

1401
00:59:42,240 --> 00:59:45,839
so in this project my conclusion was

1402
00:59:44,640 --> 00:59:49,598
that

1403
00:59:45,839 --> 00:59:51,759
indeed i was reassured that

1404
00:59:49,599 --> 00:59:54,559
it was the right choice and hexagon

1405
00:59:51,760 --> 00:59:57,839
seems to be quite a challenging target

1406
00:59:54,559 --> 00:59:59,839
and it would probably need several more

1407
00:59:57,839 --> 01:00:01,839
months of work to even begin to do some

1408
00:59:59,839 --> 01:00:05,599
serious offensive work

1409
01:00:01,839 --> 01:00:08,078
i also started to think about writing a

1410
01:00:05,599 --> 01:00:11,280
software debugger

1411
01:00:08,079 --> 01:00:13,280
because it seems to be the most

1412
01:00:11,280 --> 01:00:14,880
probably the most reliable way to

1413
01:00:13,280 --> 01:00:17,520
achieve a

1414
01:00:14,880 --> 01:00:19,359
debugging introspection and also i

1415
01:00:17,520 --> 01:00:22,400
noticed some black spaces

1416
01:00:19,359 --> 01:00:24,720
in the field that may require future

1417
01:00:22,400 --> 01:00:24,720
work

1418
01:00:24,799 --> 01:00:28,319
for qualcomm hexagon specifically there

1419
01:00:26,640 --> 01:00:30,960
is a lot of things that

1420
01:00:28,319 --> 01:00:30,960
can be done

1421
01:00:32,319 --> 01:00:36,000
for example you can take a look at other

1422
01:00:34,319 --> 01:00:38,160
qualcomm proprietary diagnostic

1423
01:00:36,000 --> 01:00:40,720
protocols or which there are few

1424
01:00:38,160 --> 01:00:41,680
such as qmi for example i think they are

1425
01:00:40,720 --> 01:00:44,480
lesser known than

1426
01:00:41,680 --> 01:00:44,480
diet protocol

1427
01:00:45,520 --> 01:00:49,280
and then there is a requirement to

1428
01:00:47,920 --> 01:00:51,440
create a

1429
01:00:49,280 --> 01:00:54,079
full system emulation based on camel at

1430
01:00:51,440 --> 01:00:54,079
least for some

1431
01:00:54,839 --> 01:01:00,160
chips

1432
01:00:56,720 --> 01:01:03,118
and a big problem about the compiler

1433
01:01:00,160 --> 01:01:06,558
which is a major obstacle to any serious

1434
01:01:03,119 --> 01:01:06,559
static analysis in the code

1435
01:01:07,839 --> 01:01:14,960
and for the offensive research there are

1436
01:01:12,480 --> 01:01:16,000
three large directions first one is

1437
01:01:14,960 --> 01:01:17,599
enabling debugging

1438
01:01:16,000 --> 01:01:19,920
there are different ways for that for

1439
01:01:17,599 --> 01:01:23,280
example software-based debugging

1440
01:01:19,920 --> 01:01:24,400
or bypassing jtag fusing on the other

1441
01:01:23,280 --> 01:01:26,559
hand

1442
01:01:24,400 --> 01:01:27,599
next there are explorations of the of

1443
01:01:26,559 --> 01:01:31,520
the air

1444
01:01:27,599 --> 01:01:33,200
attack vectors and the third one is

1445
01:01:31,520 --> 01:01:35,040
escalation from the basement to the

1446
01:01:33,200 --> 01:01:36,558
application processor these are the

1447
01:01:35,040 --> 01:01:39,520
three large

1448
01:01:36,559 --> 01:01:41,599
offensive research vectors and for the

1449
01:01:39,520 --> 01:01:43,839
basements in general there also exists

1450
01:01:41,599 --> 01:01:47,119
some interesting

1451
01:01:43,839 --> 01:01:51,040
directions of future work first of all

1452
01:01:47,119 --> 01:01:54,240
the osmo combi it definitely

1453
01:01:51,040 --> 01:01:57,440
deserves some update

1454
01:01:54,240 --> 01:01:59,038
a little bit it is the only one open

1455
01:01:57,440 --> 01:02:02,319
source implementation on baseband

1456
01:01:59,039 --> 01:02:04,319
and it is so outdated and

1457
01:02:02,319 --> 01:02:07,839
there is uh and it is based on some

1458
01:02:04,319 --> 01:02:07,839
really obscure hardwares

1459
01:02:08,319 --> 01:02:11,599
another problem here is that it doesn't

1460
01:02:10,640 --> 01:02:21,839
there doesn't exist

1461
01:02:11,599 --> 01:02:21,839
any software-based cdma implementation

1462
01:02:28,480 --> 01:02:32,480
elisa thank you very much for this nice

1463
01:02:31,359 --> 01:02:34,880
talk

1464
01:02:32,480 --> 01:02:37,359
um there are some questions from the

1465
01:02:34,880 --> 01:02:40,559
audience so basically the first one is

1466
01:02:37,359 --> 01:02:44,319
a little bit of icebreaker do you use a

1467
01:02:40,559 --> 01:02:44,319
mobile phone and do you trust it

1468
01:02:45,920 --> 01:02:50,480
no i don't really use a mobile phone

1469
01:02:48,319 --> 01:02:52,240
only for twitter

1470
01:02:50,480 --> 01:02:54,720
does anyone still use mobile phones

1471
01:02:52,240 --> 01:02:54,720
nowadays

1472
01:02:55,359 --> 01:03:02,960
well no idea ok

1473
01:02:59,599 --> 01:03:05,760
another question concerns the other

1474
01:03:02,960 --> 01:03:06,480
qualcomm chips do you did you have a

1475
01:03:05,760 --> 01:03:11,039
look at

1476
01:03:06,480 --> 01:03:11,039
the qualcomm wi-fi chipset

1477
01:03:13,599 --> 01:03:16,799
as i mentioned during the talk i had

1478
01:03:15,920 --> 01:03:19,280
only one month

1479
01:03:16,799 --> 01:03:20,960
it was like a short recognizance project

1480
01:03:19,280 --> 01:03:23,280
so i didn't really have

1481
01:03:20,960 --> 01:03:24,160
time to investigate everything i did

1482
01:03:23,280 --> 01:03:27,280
notice that

1483
01:03:24,160 --> 01:03:28,799
qualcomm socks have wi-fi chip which is

1484
01:03:27,280 --> 01:03:30,880
also based on hexagon

1485
01:03:28,799 --> 01:03:32,000
and more than that it also shares some

1486
01:03:30,880 --> 01:03:34,960
all the same

1487
01:03:32,000 --> 01:03:35,680
low-level technical primitives so it's

1488
01:03:34,960 --> 01:03:37,440
um

1489
01:03:35,680 --> 01:03:40,720
definitely worth looking but like to

1490
01:03:37,440 --> 01:03:40,720
investigate it in details

1491
01:03:41,119 --> 01:03:45,119
okay okay thanks well then there is also

1492
01:03:44,400 --> 01:03:48,000
a pretty

1493
01:03:45,119 --> 01:03:49,760
technical question here so instead of

1494
01:03:48,000 --> 01:03:51,920
having to go through the rigorous

1495
01:03:49,760 --> 01:03:53,359
command checking for the direct card

1496
01:03:51,920 --> 01:03:56,400
driver

1497
01:03:53,359 --> 01:03:59,680
wouldn't it be possible to end map dev

1498
01:03:56,400 --> 01:04:03,520
mem into user space process and

1499
01:03:59,680 --> 01:04:05,038
send over commands directly so

1500
01:04:03,520 --> 01:04:07,200
it depends a little bit on what the goal

1501
01:04:05,039 --> 01:04:07,200
is

1502
01:04:08,559 --> 01:04:14,160
okay so it really depends on your

1503
01:04:11,760 --> 01:04:16,240
previous background and your goals

1504
01:04:14,160 --> 01:04:18,399
the point here is that by default the

1505
01:04:16,240 --> 01:04:22,000
director ecosystem does not allow

1506
01:04:18,400 --> 01:04:24,240
to send arbitrary data commands

1507
01:04:22,000 --> 01:04:25,039
so either way you will have to hack

1508
01:04:24,240 --> 01:04:28,319
something

1509
01:04:25,039 --> 01:04:29,280
one way to hack this is to rebuild the

1510
01:04:28,319 --> 01:04:31,279
actual driver

1511
01:04:29,280 --> 01:04:32,960
so you would be able to send the

1512
01:04:31,280 --> 01:04:35,680
commands directly through the

1513
01:04:32,960 --> 01:04:37,440
app interface another way would be to

1514
01:04:35,680 --> 01:04:38,240
access the shared memory directly for

1515
01:04:37,440 --> 01:04:39,680
example

1516
01:04:38,240 --> 01:04:41,919
but i think it would be more complex

1517
01:04:39,680 --> 01:04:45,440
because the qualcomm shared memory

1518
01:04:41,920 --> 01:04:47,440
implementation is quite complex so

1519
01:04:45,440 --> 01:04:49,440
i think that the easiest way would be

1520
01:04:47,440 --> 01:04:54,960
actually to hack the director driver

1521
01:04:49,440 --> 01:04:58,160
and use the dev direct interface voice

1522
01:04:54,960 --> 01:05:02,319
okay yeah thanks thanks

1523
01:04:58,160 --> 01:05:05,200
um well is this there's one question

1524
01:05:02,319 --> 01:05:06,960
um quickly to read out maybe you can

1525
01:05:05,200 --> 01:05:10,640
make sense of it this is typically good

1526
01:05:06,960 --> 01:05:10,640
security for mobile phones

1527
01:05:11,359 --> 01:05:17,119
so this

1528
01:05:15,200 --> 01:05:18,240
level of hardening that i presented i

1529
01:05:17,119 --> 01:05:20,960
think is around

1530
01:05:18,240 --> 01:05:22,640
medium level so usually production

1531
01:05:20,960 --> 01:05:24,720
phones are even more hardened

1532
01:05:22,640 --> 01:05:26,160
if you take a look at things like google

1533
01:05:24,720 --> 01:05:29,520
pixel 5

1534
01:05:26,160 --> 01:05:31,839
or the latest items they would be

1535
01:05:29,520 --> 01:05:33,759
even better harder than the one that i

1536
01:05:31,839 --> 01:05:37,599
discussed

1537
01:05:33,760 --> 01:05:39,839
oh okay yeah thanks thanks then

1538
01:05:37,599 --> 01:05:41,200
so it doesn't look like we have any more

1539
01:05:39,839 --> 01:05:43,359
questions left

1540
01:05:41,200 --> 01:05:44,558
anyway so if you want to get in contact

1541
01:05:43,359 --> 01:05:47,759
with alisa

1542
01:05:44,559 --> 01:05:51,599
no problem there is the feedback

1543
01:05:47,760 --> 01:05:56,079
tab below your video now at the moment

1544
01:05:51,599 --> 01:05:59,599
just drop your questions over there and

1545
01:05:56,079 --> 01:06:01,680
that's a way to get in touch with elisa

1546
01:05:59,599 --> 01:06:03,039
urban that i would say we are done for

1547
01:06:01,680 --> 01:06:05,598
today for this session

1548
01:06:03,039 --> 01:06:07,520
thank you very very much elisa for this

1549
01:06:05,599 --> 01:06:10,640
really nice presentation once again

1550
01:06:07,520 --> 01:06:19,839
of course and i'll transfer now over

1551
01:06:10,640 --> 01:06:19,839
to the herald news show

1552
01:06:44,839 --> 01:06:47,839
wow

1553
01:06:53,440 --> 01:06:55,520
you

