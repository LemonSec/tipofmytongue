1
00:00:01,500 --> 00:00:10,520
[Music]

2
00:00:07,350 --> 00:00:10,520
[Applause]

3
00:00:13,200 --> 00:00:16,160
hi there

4
00:00:13,840 --> 00:00:17,680
this is a talk about creating your own

5
00:00:16,160 --> 00:00:18,960
programming language specifically a

6
00:00:17,680 --> 00:00:20,960
language that doesn't suck

7
00:00:18,960 --> 00:00:23,039
and for many of us the language that

8
00:00:20,960 --> 00:00:24,560
does not suck is the first language that

9
00:00:23,039 --> 00:00:26,560
we learned and for me

10
00:00:24,560 --> 00:00:27,680
this was the language that ran on this

11
00:00:26,560 --> 00:00:31,038
computer here

12
00:00:27,680 --> 00:00:33,440
the apple 2e which was a computer that

13
00:00:31,039 --> 00:00:35,440
my parents gave to me in 1983 and i just

14
00:00:33,440 --> 00:00:37,599
took that picture today it still works

15
00:00:35,440 --> 00:00:38,718
and it runs a language called applesoft

16
00:00:37,600 --> 00:00:41,040
basic and you can still find

17
00:00:38,719 --> 00:00:43,520
documentation on applesoft basic

18
00:00:41,040 --> 00:00:45,200
to this day so here's for example an

19
00:00:43,520 --> 00:00:46,960
introductory manual

20
00:00:45,200 --> 00:00:48,480
and if you like look inside that manual

21
00:00:46,960 --> 00:00:50,079
you can see what a basic program looks

22
00:00:48,480 --> 00:00:52,078
like and you see consists of a bunch of

23
00:00:50,079 --> 00:00:54,719
lines every line has a line number

24
00:00:52,079 --> 00:00:55,520
and on every line there is a command so

25
00:00:54,719 --> 00:00:57,520
it's none of that

26
00:00:55,520 --> 00:00:59,199
methods and classes and functions

27
00:00:57,520 --> 00:01:01,199
nonsense that we have today it's just

28
00:00:59,199 --> 00:01:01,839
straight up do this do that jump to that

29
00:01:01,199 --> 00:01:05,679
line

30
00:01:01,840 --> 00:01:08,479
and it was a lot of fun during the day

31
00:01:05,680 --> 00:01:10,080
so um we're going to use the racket

32
00:01:08,479 --> 00:01:13,119
system to implement that and

33
00:01:10,080 --> 00:01:15,600
racket is great it's a it's an entire

34
00:01:13,119 --> 00:01:16,960
toolbox that you can use to create your

35
00:01:15,600 --> 00:01:18,720
own languages it comes with many

36
00:01:16,960 --> 00:01:21,520
languages

37
00:01:18,720 --> 00:01:22,320
and it's just a lot of fun and if you

38
00:01:21,520 --> 00:01:24,560
want to

39
00:01:22,320 --> 00:01:25,439
play with the code for this talk

40
00:01:24,560 --> 00:01:27,280
yourself

41
00:01:25,439 --> 00:01:28,559
i put everything on github in a

42
00:01:27,280 --> 00:01:32,400
repository called

43
00:01:28,560 --> 00:01:32,880
mike sperber rc3 and that also links to

44
00:01:32,400 --> 00:01:36,000
a

45
00:01:32,880 --> 00:01:37,679
download link for for racket and has all

46
00:01:36,000 --> 00:01:40,720
the code for today so

47
00:01:37,680 --> 00:01:41,600
anyway i have to warn you this talk is a

48
00:01:40,720 --> 00:01:43,360
it's pretty heavy

49
00:01:41,600 --> 00:01:44,479
on code so that's pretty much the only

50
00:01:43,360 --> 00:01:46,079
thing that i'm going to be doing is i'm

51
00:01:44,479 --> 00:01:47,520
going to write code in front of your

52
00:01:46,079 --> 00:01:49,520
eyes

53
00:01:47,520 --> 00:01:50,960
and if if you know that's just too much

54
00:01:49,520 --> 00:01:53,200
for you today i'll

55
00:01:50,960 --> 00:01:54,559
i understand and i won't be mad if you

56
00:01:53,200 --> 00:01:57,119
go see another talk so

57
00:01:54,560 --> 00:01:57,759
but if you're in for some really serious

58
00:01:57,119 --> 00:02:02,560
hacking

59
00:01:57,759 --> 00:02:02,560
then this might just be the talk for you

60
00:02:02,799 --> 00:02:06,960
so racket when it starts up comes up

61
00:02:04,880 --> 00:02:08,239
with a blank screen such as this one

62
00:02:06,960 --> 00:02:10,720
well it's not quite blank

63
00:02:08,239 --> 00:02:11,680
uh each file in racket starts with a

64
00:02:10,720 --> 00:02:14,560
hash lang

65
00:02:11,680 --> 00:02:16,239
line that tells racket what language

66
00:02:14,560 --> 00:02:18,080
that file is written in and the system

67
00:02:16,239 --> 00:02:20,480
actually comes with many many languages

68
00:02:18,080 --> 00:02:21,840
one of which also happens to be called

69
00:02:20,480 --> 00:02:24,720
racket now racket's

70
00:02:21,840 --> 00:02:25,840
okay language but it also has some

71
00:02:24,720 --> 00:02:28,480
annoyances so we could

72
00:02:25,840 --> 00:02:30,239
print something out by calling the

73
00:02:28,480 --> 00:02:31,920
display function

74
00:02:30,239 --> 00:02:33,840
and if we run that program well down

75
00:02:31,920 --> 00:02:36,238
here you can see the output that's fine

76
00:02:33,840 --> 00:02:37,840
but sometimes we also want to display

77
00:02:36,239 --> 00:02:40,560
several things for example

78
00:02:37,840 --> 00:02:40,959
a little bit of explanatory text along

79
00:02:40,560 --> 00:02:44,160
with

80
00:02:40,959 --> 00:02:46,800
a computation so this year

81
00:02:44,160 --> 00:02:48,480
well you can see that the default racket

82
00:02:46,800 --> 00:02:50,160
language is a lisp dialect

83
00:02:48,480 --> 00:02:51,679
which always has parentheses around

84
00:02:50,160 --> 00:02:54,400
compound forms

85
00:02:51,680 --> 00:02:55,280
um and has an operator always in front

86
00:02:54,400 --> 00:02:57,519
so you don't write

87
00:02:55,280 --> 00:02:58,400
you know one plus one you write uh the

88
00:02:57,519 --> 00:03:01,200
sum of

89
00:02:58,400 --> 00:03:02,640
one and one now we really well we

90
00:03:01,200 --> 00:03:04,480
hopefully we know what that should print

91
00:03:02,640 --> 00:03:05,279
out but if we run that we get an error

92
00:03:04,480 --> 00:03:07,119
message

93
00:03:05,280 --> 00:03:08,720
and that's because display only takes a

94
00:03:07,120 --> 00:03:10,319
single argument

95
00:03:08,720 --> 00:03:12,239
to print out and the second argument is

96
00:03:10,319 --> 00:03:14,000
supposed to be a port which tells

97
00:03:12,239 --> 00:03:15,599
display where the output goes if it goes

98
00:03:14,000 --> 00:03:18,239
to a file or

99
00:03:15,599 --> 00:03:19,839
the rep or whatever so really if we want

100
00:03:18,239 --> 00:03:23,360
you know several pieces of output

101
00:03:19,840 --> 00:03:26,720
such as this then we need to put in

102
00:03:23,360 --> 00:03:30,159
several calls to display

103
00:03:26,720 --> 00:03:31,440
so there you go um well that's super

104
00:03:30,159 --> 00:03:33,280
annoying right

105
00:03:31,440 --> 00:03:34,400
and even you know applesoft basic at

106
00:03:33,280 --> 00:03:36,400
that thing where you could just say

107
00:03:34,400 --> 00:03:37,840
print and you could just put in several

108
00:03:36,400 --> 00:03:40,319
things so you could do this

109
00:03:37,840 --> 00:03:40,959
thing that we were trying to do with uh

110
00:03:40,319 --> 00:03:43,280
display

111
00:03:40,959 --> 00:03:44,400
in the first place right but of course

112
00:03:43,280 --> 00:03:47,440
you know run this

113
00:03:44,400 --> 00:03:50,000
print is just not

114
00:03:47,440 --> 00:03:51,280
built in in the shape that we would like

115
00:03:50,000 --> 00:03:53,680
so

116
00:03:51,280 --> 00:03:54,640
we're just going to define it ourselves

117
00:03:53,680 --> 00:03:57,920
and to do that

118
00:03:54,640 --> 00:04:01,119
we're going to write a macro which means

119
00:03:57,920 --> 00:04:02,238
that the this form with print at the

120
00:04:01,120 --> 00:04:05,439
front

121
00:04:02,239 --> 00:04:06,239
um is going to get translated into code

122
00:04:05,439 --> 00:04:08,319
that racket

123
00:04:06,239 --> 00:04:09,360
already knows about and so we want to

124
00:04:08,319 --> 00:04:12,560
translate this

125
00:04:09,360 --> 00:04:15,840
into these two calls to display up here

126
00:04:12,560 --> 00:04:17,358
right and well one

127
00:04:15,840 --> 00:04:19,440
restriction that we need to remember is

128
00:04:17,358 --> 00:04:21,519
that uh you know a form always

129
00:04:19,440 --> 00:04:23,199
translates into a single form so when

130
00:04:21,519 --> 00:04:25,680
there's two forms here in order to

131
00:04:23,199 --> 00:04:26,400
turn these uh into a single form we just

132
00:04:25,680 --> 00:04:28,960
put

133
00:04:26,400 --> 00:04:30,638
begin at the front and parentheses

134
00:04:28,960 --> 00:04:31,599
around so this is the translation that

135
00:04:30,639 --> 00:04:36,160
we want i'll

136
00:04:31,600 --> 00:04:36,160
comment that out just so that we

137
00:04:36,639 --> 00:04:40,720
have that at our disposal and in order

138
00:04:38,960 --> 00:04:41,440
to write a compile time function or a

139
00:04:40,720 --> 00:04:44,080
macro

140
00:04:41,440 --> 00:04:45,759
we say define syntax we're going to

141
00:04:44,080 --> 00:04:47,680
define a new piece of syntax

142
00:04:45,759 --> 00:04:48,880
and that piece of syntax always starts

143
00:04:47,680 --> 00:04:51,759
with open parent

144
00:04:48,880 --> 00:04:53,040
print and the compile time function that

145
00:04:51,759 --> 00:04:54,560
implements the macro

146
00:04:53,040 --> 00:04:56,320
always gets called with an argument

147
00:04:54,560 --> 00:04:57,360
which is exactly the piece of syntax

148
00:04:56,320 --> 00:05:00,639
that the compiler

149
00:04:57,360 --> 00:05:02,560
saw and we're going to call that form

150
00:05:00,639 --> 00:05:03,840
now in order to translate it into this

151
00:05:02,560 --> 00:05:05,600
begin form we need to

152
00:05:03,840 --> 00:05:07,840
take it apart a little bit identify the

153
00:05:05,600 --> 00:05:10,240
arguments we need to parse it

154
00:05:07,840 --> 00:05:11,359
and for parsing we will use a racket

155
00:05:10,240 --> 00:05:14,960
library called

156
00:05:11,360 --> 00:05:17,199
syntax parse and

157
00:05:14,960 --> 00:05:18,638
i'm going to import that as a library so

158
00:05:17,199 --> 00:05:21,360
it's not a default feature

159
00:05:18,639 --> 00:05:21,680
in the core bracket language and since

160
00:05:21,360 --> 00:05:25,280
we

161
00:05:21,680 --> 00:05:27,759
we're going to use syntax parse inside a

162
00:05:25,280 --> 00:05:29,520
function that runs at compile time or at

163
00:05:27,759 --> 00:05:31,919
syntax expansion time

164
00:05:29,520 --> 00:05:34,080
as we'd like to say we're going to say

165
00:05:31,919 --> 00:05:35,440
up here for syntax so we can use it

166
00:05:34,080 --> 00:05:39,198
inside a define

167
00:05:35,440 --> 00:05:40,000
syntax form so we write you know syntax

168
00:05:39,199 --> 00:05:42,560
parse here

169
00:05:40,000 --> 00:05:44,240
we want to take apart this form thing

170
00:05:42,560 --> 00:05:45,440
and we will write a pattern that

171
00:05:44,240 --> 00:05:47,680
describes the shape

172
00:05:45,440 --> 00:05:49,360
of the form so we'll start with a very

173
00:05:47,680 --> 00:05:52,080
simple version of that pattern

174
00:05:49,360 --> 00:05:53,360
uh so it starts with an open brand print

175
00:05:52,080 --> 00:05:55,199
then there's an argument and that

176
00:05:53,360 --> 00:05:57,199
argument has to be an expression which

177
00:05:55,199 --> 00:05:58,639
is denoted by putting colon expression

178
00:05:57,199 --> 00:06:00,560
there

179
00:05:58,639 --> 00:06:02,160
and now we want to translate that into a

180
00:06:00,560 --> 00:06:04,560
different piece of syntax

181
00:06:02,160 --> 00:06:05,360
in order to create syntax what we do is

182
00:06:04,560 --> 00:06:08,240
i put in

183
00:06:05,360 --> 00:06:08,560
hash back quote and we want to translate

184
00:06:08,240 --> 00:06:10,560
that

185
00:06:08,560 --> 00:06:12,960
into displayart for now so we'll just do

186
00:06:10,560 --> 00:06:16,000
a single argument version

187
00:06:12,960 --> 00:06:18,400
for starters so i'll put that here

188
00:06:16,000 --> 00:06:20,160
i'll run the code so there's nothing in

189
00:06:18,400 --> 00:06:23,120
the repo now but now i can say

190
00:06:20,160 --> 00:06:24,639
at least hello world not very exciting

191
00:06:23,120 --> 00:06:27,440
and that works but of course

192
00:06:24,639 --> 00:06:28,000
it will only work with a single argument

193
00:06:27,440 --> 00:06:29,600
we want

194
00:06:28,000 --> 00:06:31,520
to use it with several arguments in

195
00:06:29,600 --> 00:06:33,759
order to do that we can just say well we

196
00:06:31,520 --> 00:06:37,440
don't just want one arc we want several

197
00:06:33,759 --> 00:06:39,680
and to do that we put three dots here

198
00:06:37,440 --> 00:06:41,039
almost looks too simple to be true so it

199
00:06:39,680 --> 00:06:42,880
just says well there can be as many

200
00:06:41,039 --> 00:06:46,159
arguments as we want

201
00:06:42,880 --> 00:06:47,840
and now as we said about above we need

202
00:06:46,160 --> 00:06:50,000
to translate into a begin

203
00:06:47,840 --> 00:06:52,000
form so we want to say like this right

204
00:06:50,000 --> 00:06:53,759
and then we want to have as many

205
00:06:52,000 --> 00:06:55,680
calls to display as there are args and

206
00:06:53,759 --> 00:06:58,400
we can also do that by putting

207
00:06:55,680 --> 00:07:00,639
you know three dots here and racket will

208
00:06:58,400 --> 00:07:03,039
automatically figure out that that means

209
00:07:00,639 --> 00:07:04,000
we should have one call to display for

210
00:07:03,039 --> 00:07:05,599
each argument

211
00:07:04,000 --> 00:07:07,440
and make sure that all the parentheses

212
00:07:05,599 --> 00:07:10,800
are closed

213
00:07:07,440 --> 00:07:13,919
and uh well let's try that out 1 plus 1

214
00:07:10,800 --> 00:07:16,960
equals plus like this

215
00:07:13,919 --> 00:07:19,359
and sure enough that works so

216
00:07:16,960 --> 00:07:20,638
now we've added a new syntactic form to

217
00:07:19,360 --> 00:07:21,360
the racket language it's pretty simple

218
00:07:20,639 --> 00:07:24,240
as it goes

219
00:07:21,360 --> 00:07:25,360
and we'll use that as a small building

220
00:07:24,240 --> 00:07:28,479
block for

221
00:07:25,360 --> 00:07:29,360
our basic machinery that we're going to

222
00:07:28,479 --> 00:07:33,120
implement

223
00:07:29,360 --> 00:07:34,240
next so well i guess it's a good time to

224
00:07:33,120 --> 00:07:36,880
save our work

225
00:07:34,240 --> 00:07:38,319
uh just to make sure that we're not

226
00:07:36,880 --> 00:07:39,120
losing anything i'm just going to call

227
00:07:38,319 --> 00:07:44,800
this file

228
00:07:39,120 --> 00:07:47,520
basic dot racket and there we go

229
00:07:44,800 --> 00:07:49,120
so okay uh well we got that print thing

230
00:07:47,520 --> 00:07:51,758
which is similar to the print

231
00:07:49,120 --> 00:07:53,360
in basic which is nice but i don't know

232
00:07:51,759 --> 00:07:55,039
if you've ever used basically it looks a

233
00:07:53,360 --> 00:07:58,319
basic program really looks like

234
00:07:55,039 --> 00:07:59,840
this right it says you know print hello

235
00:07:58,319 --> 00:08:01,759
world and then

236
00:07:59,840 --> 00:08:03,039
uh you can see that there's a line

237
00:08:01,759 --> 00:08:05,280
number in the beginning and then you

238
00:08:03,039 --> 00:08:06,719
go something like yeah go to 10 so

239
00:08:05,280 --> 00:08:07,919
that's always the first program that

240
00:08:06,720 --> 00:08:10,960
just prints something

241
00:08:07,919 --> 00:08:13,359
repeatedly so um

242
00:08:10,960 --> 00:08:14,400
yeah well this is obviously not there

243
00:08:13,360 --> 00:08:16,560
yet right print

244
00:08:14,400 --> 00:08:18,638
well there's no line number um there's

245
00:08:16,560 --> 00:08:20,240
also still the funny parenthesis syntax

246
00:08:18,639 --> 00:08:21,759
so if you create when you create a new

247
00:08:20,240 --> 00:08:24,800
language in racket

248
00:08:21,759 --> 00:08:27,199
the way to do that is well you um

249
00:08:24,800 --> 00:08:28,960
you start with a parenthesis syntax and

250
00:08:27,199 --> 00:08:31,360
later on top of that we will

251
00:08:28,960 --> 00:08:33,760
implement the actual you know line based

252
00:08:31,360 --> 00:08:37,120
uh basic syntax that we might remember

253
00:08:33,760 --> 00:08:39,120
from our apple two days so um

254
00:08:37,120 --> 00:08:40,479
so to that end we'll just start by

255
00:08:39,120 --> 00:08:43,039
saying not

256
00:08:40,479 --> 00:08:43,519
you know 10 print what we'll say open

257
00:08:43,039 --> 00:08:47,439
paren

258
00:08:43,519 --> 00:08:50,800
tend print you know hello

259
00:08:47,440 --> 00:08:52,320
world eventually we're also going to

260
00:08:50,800 --> 00:08:55,519
have to take care of the

261
00:08:52,320 --> 00:08:59,760
lowercase print here and then say 20

262
00:08:55,519 --> 00:08:59,760
you know go to 10 something like this

263
00:09:00,399 --> 00:09:05,040
so that's what we're going to start with

264
00:09:02,560 --> 00:09:08,319
again we have to think about how we will

265
00:09:05,040 --> 00:09:11,439
translate this into code that racket

266
00:09:08,320 --> 00:09:13,279
recognizes and uh well you know this

267
00:09:11,440 --> 00:09:16,240
program it doesn't do anything yet

268
00:09:13,279 --> 00:09:20,080
um it just stores um you know the print

269
00:09:16,240 --> 00:09:23,120
command for example it just stores that

270
00:09:20,080 --> 00:09:24,880
into into storage of the

271
00:09:23,120 --> 00:09:26,880
of the apple soft interpreters and i can

272
00:09:24,880 --> 00:09:28,959
then start the program by saying well i

273
00:09:26,880 --> 00:09:32,000
want to start the program at line 10

274
00:09:28,959 --> 00:09:33,680
um or something like that so um

275
00:09:32,000 --> 00:09:35,920
it's it's not enough to just sort of

276
00:09:33,680 --> 00:09:37,439
translate this into a call to print we

277
00:09:35,920 --> 00:09:39,519
will also have to deal with the line

278
00:09:37,440 --> 00:09:41,279
numbers somehow so that also go to 10

279
00:09:39,519 --> 00:09:43,279
for example makes sense

280
00:09:41,279 --> 00:09:44,959
so in order to store a piece of code we

281
00:09:43,279 --> 00:09:46,720
can just give it a name and racket right

282
00:09:44,959 --> 00:09:47,920
so the idea is that we will translate it

283
00:09:46,720 --> 00:09:49,760
like this we will say

284
00:09:47,920 --> 00:09:51,040
well we'll call we'll just define a

285
00:09:49,760 --> 00:09:52,480
function we're just going to call that

286
00:09:51,040 --> 00:09:56,240
line 10

287
00:09:52,480 --> 00:10:00,320
and we will make that one

288
00:09:56,240 --> 00:10:02,839
call print and we will then define a

289
00:10:00,320 --> 00:10:06,079
function called line 20

290
00:10:02,839 --> 00:10:08,240
and well so go to of course

291
00:10:06,079 --> 00:10:10,000
in in racket doesn't exist but we can

292
00:10:08,240 --> 00:10:11,920
just go to another function by calling

293
00:10:10,000 --> 00:10:15,040
it right so i'm just going to call

294
00:10:11,920 --> 00:10:15,839
line 10 here and uh well you can already

295
00:10:15,040 --> 00:10:18,319
see that

296
00:10:15,839 --> 00:10:19,839
eventually this is hardly going to work

297
00:10:18,320 --> 00:10:22,399
as line 10 will never

298
00:10:19,839 --> 00:10:23,600
proceed to line 20 so eventually we will

299
00:10:22,399 --> 00:10:26,640
also have to put

300
00:10:23,600 --> 00:10:27,040
a call to line 20 here so that the code

301
00:10:26,640 --> 00:10:29,760
moves

302
00:10:27,040 --> 00:10:31,360
in the right direction but we'll start

303
00:10:29,760 --> 00:10:32,560
simple we're just going to start with a

304
00:10:31,360 --> 00:10:32,959
single line and then we don't need to

305
00:10:32,560 --> 00:10:34,719
call

306
00:10:32,959 --> 00:10:36,479
that next function how does that work

307
00:10:34,720 --> 00:10:39,680
well uh

308
00:10:36,480 --> 00:10:42,160
we again say define syntax right

309
00:10:39,680 --> 00:10:43,439
and in this case we're just going to to

310
00:10:42,160 --> 00:10:44,079
find a piece of syntax that we're just

311
00:10:43,440 --> 00:10:47,519
going to call

312
00:10:44,079 --> 00:10:49,199
basic again it takes an entire form as

313
00:10:47,519 --> 00:10:49,760
its argument will start just with a

314
00:10:49,200 --> 00:10:52,160
single

315
00:10:49,760 --> 00:10:53,200
command so i'm going to call syntax

316
00:10:52,160 --> 00:10:55,839
parse here

317
00:10:53,200 --> 00:10:56,240
pass it to form and say well basic and

318
00:10:55,839 --> 00:10:58,480
the way

319
00:10:56,240 --> 00:11:00,959
basic commands work is there's a line

320
00:10:58,480 --> 00:11:04,079
number beginning which is an integer

321
00:11:00,959 --> 00:11:06,959
and then there is a command which is

322
00:11:04,079 --> 00:11:07,680
in racket terms it's just an expression

323
00:11:06,959 --> 00:11:10,000
so

324
00:11:07,680 --> 00:11:11,359
well what do we need to do again we need

325
00:11:10,000 --> 00:11:14,959
to translate it into

326
00:11:11,360 --> 00:11:18,480
another piece of syntax so

327
00:11:14,959 --> 00:11:20,239
um well we can see up there

328
00:11:18,480 --> 00:11:21,600
right we want to translate it into

329
00:11:20,240 --> 00:11:25,680
define

330
00:11:21,600 --> 00:11:27,279
and then uh well there's an open paren

331
00:11:25,680 --> 00:11:29,519
we're going to have to cook up that line

332
00:11:27,279 --> 00:11:30,959
10 name well so we'll defer that problem

333
00:11:29,519 --> 00:11:34,399
for a little later

334
00:11:30,959 --> 00:11:38,479
and we will just insert in here the

335
00:11:34,399 --> 00:11:41,120
command in the body of the function so

336
00:11:38,480 --> 00:11:42,000
okay so that leaves the problem of

337
00:11:41,120 --> 00:11:45,279
computing

338
00:11:42,000 --> 00:11:46,800
the name line 10 from the line so we

339
00:11:45,279 --> 00:11:48,160
want to compute that name by sticking

340
00:11:46,800 --> 00:11:51,439
that you know line minus

341
00:11:48,160 --> 00:11:54,399
in front and to that end um

342
00:11:51,440 --> 00:11:55,279
well i want to call a function called

343
00:11:54,399 --> 00:11:58,800
format

344
00:11:55,279 --> 00:12:00,240
it and format it well uh so it takes

345
00:11:58,800 --> 00:12:01,120
something that i'll explain in just a

346
00:12:00,240 --> 00:12:02,959
moment

347
00:12:01,120 --> 00:12:04,160
it takes a pattern which is sort of like

348
00:12:02,959 --> 00:12:06,160
a printf

349
00:12:04,160 --> 00:12:07,680
uh except well the pattern language is

350
00:12:06,160 --> 00:12:10,160
slightly different so the tilde a

351
00:12:07,680 --> 00:12:12,560
says we should insert something in here

352
00:12:10,160 --> 00:12:16,079
and we want to insert the line number

353
00:12:12,560 --> 00:12:19,119
now i'm kind of tempted to put in

354
00:12:16,079 --> 00:12:21,199
line number here now

355
00:12:19,120 --> 00:12:23,279
i need you to understand one thing is

356
00:12:21,200 --> 00:12:24,639
that you know as syntax a piece of

357
00:12:23,279 --> 00:12:26,240
syntax that represents

358
00:12:24,639 --> 00:12:27,680
a number is not the same thing as the

359
00:12:26,240 --> 00:12:29,200
number itself so

360
00:12:27,680 --> 00:12:30,959
for example if the line number is 10 you

361
00:12:29,200 --> 00:12:32,240
know down here in the repel i can type

362
00:12:30,959 --> 00:12:35,199
10. well i get

363
00:12:32,240 --> 00:12:36,240
10 as a result but if i type this funny

364
00:12:35,200 --> 00:12:39,200
syntax thing

365
00:12:36,240 --> 00:12:40,720
10 then it says well there's a piece of

366
00:12:39,200 --> 00:12:43,839
syntax and it contains

367
00:12:40,720 --> 00:12:45,200
that number 10 in there if we want to

368
00:12:43,839 --> 00:12:47,519
stick it into the name we really need

369
00:12:45,200 --> 00:12:51,360
the number 10 in order to extract the

370
00:12:47,519 --> 00:12:53,519
sort of the actual piece of data that is

371
00:12:51,360 --> 00:12:55,519
uh represented by the syntax i can call

372
00:12:53,519 --> 00:12:58,639
a function called syntax e

373
00:12:55,519 --> 00:13:01,279
so if i call syntax e of

374
00:12:58,639 --> 00:13:02,160
uh you know here hash back row 10 then

375
00:13:01,279 --> 00:13:05,200
it gives me

376
00:13:02,160 --> 00:13:06,959
that 10. so really you know that's what

377
00:13:05,200 --> 00:13:10,880
that line number is so i need to call

378
00:13:06,959 --> 00:13:12,959
syntax e here moreover

379
00:13:10,880 --> 00:13:15,439
uh you can see here that i left three

380
00:13:12,959 --> 00:13:18,399
for the odds three dots here format it

381
00:13:15,440 --> 00:13:20,720
also um takes an argument that is called

382
00:13:18,399 --> 00:13:21,200
the syntactic context now the macro

383
00:13:20,720 --> 00:13:23,760
system

384
00:13:21,200 --> 00:13:25,279
in racket has great sophistication when

385
00:13:23,760 --> 00:13:27,200
it comes to identifiers

386
00:13:25,279 --> 00:13:28,880
if you if you've seen macro systems in

387
00:13:27,200 --> 00:13:29,760
other languages such as in c they're

388
00:13:28,880 --> 00:13:33,040
very simple

389
00:13:29,760 --> 00:13:34,399
about names and you can introduce name

390
00:13:33,040 --> 00:13:37,519
clashes

391
00:13:34,399 --> 00:13:39,519
very easily and racket avoids that

392
00:13:37,519 --> 00:13:40,720
that's not going to be the main subject

393
00:13:39,519 --> 00:13:43,279
of this talk

394
00:13:40,720 --> 00:13:45,120
so suffice it to say that as the context

395
00:13:43,279 --> 00:13:46,399
we want to define the line numbers are

396
00:13:45,120 --> 00:13:48,720
at the same level

397
00:13:46,399 --> 00:13:49,839
as the basic form that appeared so we'll

398
00:13:48,720 --> 00:13:52,959
just stick

399
00:13:49,839 --> 00:13:53,920
this here uh so just a little piece of

400
00:13:52,959 --> 00:13:55,359
magic here

401
00:13:53,920 --> 00:13:57,279
that we're just going to have to accept

402
00:13:55,360 --> 00:14:00,720
for the moment so well

403
00:13:57,279 --> 00:14:03,040
this thing we want to stick that in

404
00:14:00,720 --> 00:14:04,240
here right uh in here where the three

405
00:14:03,040 --> 00:14:06,880
dots are and to that

406
00:14:04,240 --> 00:14:07,600
end i will just give it a name i'll call

407
00:14:06,880 --> 00:14:11,600
that thing

408
00:14:07,600 --> 00:14:13,440
name and i want to stick it in here

409
00:14:11,600 --> 00:14:15,199
now you have to understand a very subtle

410
00:14:13,440 --> 00:14:18,959
issue here which is that

411
00:14:15,199 --> 00:14:20,639
so for example um you know when i have a

412
00:14:18,959 --> 00:14:21,439
pattern variable here that appears in

413
00:14:20,639 --> 00:14:23,120
the pattern

414
00:14:21,440 --> 00:14:25,120
i can just stick that in the syntax for

415
00:14:23,120 --> 00:14:26,880
example here i can just put in command

416
00:14:25,120 --> 00:14:29,040
and record will figure out that i really

417
00:14:26,880 --> 00:14:32,399
meant this command here

418
00:14:29,040 --> 00:14:33,519
unfortunately uh well i mean there are

419
00:14:32,399 --> 00:14:35,279
reasons but

420
00:14:33,519 --> 00:14:36,800
uh this that does not work for this

421
00:14:35,279 --> 00:14:39,279
which is a regular binding it's not

422
00:14:36,800 --> 00:14:39,920
a pattern binding in order to tell

423
00:14:39,279 --> 00:14:42,240
racket

424
00:14:39,920 --> 00:14:43,360
to well you know stick the result of

425
00:14:42,240 --> 00:14:45,440
evaluating that

426
00:14:43,360 --> 00:14:46,880
that piece of code here i will need to

427
00:14:45,440 --> 00:14:49,279
put in hash

428
00:14:46,880 --> 00:14:50,000
comma name which says well here's an

429
00:14:49,279 --> 00:14:52,720
expression

430
00:14:50,000 --> 00:14:54,880
you know stick uh stick the value of

431
00:14:52,720 --> 00:14:58,079
evaluating that expression in here

432
00:14:54,880 --> 00:14:59,439
so that's i think that's confusing at

433
00:14:58,079 --> 00:15:00,079
first but you'll get used to it so

434
00:14:59,440 --> 00:15:01,440
remember

435
00:15:00,079 --> 00:15:03,839
when there's something in here in the

436
00:15:01,440 --> 00:15:05,600
pattern you can just stick it in here

437
00:15:03,839 --> 00:15:07,519
and if you have regular bindings or if

438
00:15:05,600 --> 00:15:09,360
you have a piece of code

439
00:15:07,519 --> 00:15:11,199
that you want to stick in your syntax

440
00:15:09,360 --> 00:15:12,480
you will need to preface prefix that

441
00:15:11,199 --> 00:15:15,680
with a hash

442
00:15:12,480 --> 00:15:18,639
comma which is also called unquote so

443
00:15:15,680 --> 00:15:19,040
let's see if that works we'll run that

444
00:15:18,639 --> 00:15:21,839
ah

445
00:15:19,040 --> 00:15:24,079
see here i already ran into the first

446
00:15:21,839 --> 00:15:26,480
trap here that i just told you about

447
00:15:24,079 --> 00:15:28,160
i called syntax e on the line number but

448
00:15:26,480 --> 00:15:30,079
the same kind of kind of goes in reverse

449
00:15:28,160 --> 00:15:31,680
so if i can't just use a pattern

450
00:15:30,079 --> 00:15:34,160
variable in regular code

451
00:15:31,680 --> 00:15:35,599
instead of instead what i need to do is

452
00:15:34,160 --> 00:15:38,719
i need to

453
00:15:35,600 --> 00:15:41,759
prefix that pattern variable with hash

454
00:15:38,720 --> 00:15:43,680
backvote okay so and then it knows

455
00:15:41,759 --> 00:15:46,560
okay i need to look among the pattern

456
00:15:43,680 --> 00:15:49,040
variables for this so if i run this

457
00:15:46,560 --> 00:15:50,959
well then it says format it doesn't know

458
00:15:49,040 --> 00:15:53,599
about that and that's because format it

459
00:15:50,959 --> 00:15:54,000
in racket is in a separate library so

460
00:15:53,600 --> 00:15:57,279
i'm going

461
00:15:54,000 --> 00:15:59,600
to need to jump upwards a little bit and

462
00:15:57,279 --> 00:16:02,000
say here that for syntax i don't just

463
00:15:59,600 --> 00:16:02,720
want syntax powers i also want a library

464
00:16:02,000 --> 00:16:05,120
called

465
00:16:02,720 --> 00:16:05,839
bracket syntax and that hopefully

466
00:16:05,120 --> 00:16:08,959
contains

467
00:16:05,839 --> 00:16:10,639
formatted go back to that code press run

468
00:16:08,959 --> 00:16:12,800
and now at least it's silent

469
00:16:10,639 --> 00:16:13,920
and now well i could try doing that by

470
00:16:12,800 --> 00:16:18,800
saying basic

471
00:16:13,920 --> 00:16:21,920
you know 10 you know print hello world

472
00:16:18,800 --> 00:16:22,639
and it doesn't do anything right as it

473
00:16:21,920 --> 00:16:25,199
should it should

474
00:16:22,639 --> 00:16:26,079
just stash that piece of code and but if

475
00:16:25,199 --> 00:16:29,680
i now

476
00:16:26,079 --> 00:16:31,279
uh type this it executes that first line

477
00:16:29,680 --> 00:16:34,800
of code so hooray we've got

478
00:16:31,279 --> 00:16:38,399
a very basic basic version of basic here

479
00:16:34,800 --> 00:16:38,880
that works okay so now we have a single

480
00:16:38,399 --> 00:16:40,639
command

481
00:16:38,880 --> 00:16:42,480
in a basic program but of course we want

482
00:16:40,639 --> 00:16:45,440
to have several of them

483
00:16:42,480 --> 00:16:46,240
and so up here we already know how to do

484
00:16:45,440 --> 00:16:47,920
this

485
00:16:46,240 --> 00:16:49,519
or at least how to tell syntax powers

486
00:16:47,920 --> 00:16:51,519
about this we just put

487
00:16:49,519 --> 00:16:53,040
three dots here and says there can now

488
00:16:51,519 --> 00:16:56,639
be several lines

489
00:16:53,040 --> 00:16:58,800
in a in a basic form

490
00:16:56,639 --> 00:17:00,639
so um but of course we need to translate

491
00:16:58,800 --> 00:17:02,319
that differently right now our expansion

492
00:17:00,639 --> 00:17:04,000
just has a single definition for

493
00:17:02,320 --> 00:17:05,839
a single line and now we need to expand

494
00:17:04,000 --> 00:17:08,880
that to do

495
00:17:05,839 --> 00:17:10,240
several definitions so to that end

496
00:17:08,880 --> 00:17:12,079
we well record as a functional

497
00:17:10,240 --> 00:17:14,959
programming language we do a

498
00:17:12,079 --> 00:17:16,319
map so we apply a function to all the

499
00:17:14,959 --> 00:17:16,799
line numbers and commands and the

500
00:17:16,319 --> 00:17:19,359
function

501
00:17:16,799 --> 00:17:21,599
always returns a piece of syntax for a

502
00:17:19,359 --> 00:17:23,839
single definition let's try that

503
00:17:21,599 --> 00:17:25,359
so i'm going to say lambda here i'm

504
00:17:23,839 --> 00:17:27,119
going to put three dots here because

505
00:17:25,359 --> 00:17:28,479
there's a subtlety that i'll explain in

506
00:17:27,119 --> 00:17:29,840
just a moment

507
00:17:28,480 --> 00:17:31,760
and now the question is what do we map

508
00:17:29,840 --> 00:17:33,840
over well we want to map over

509
00:17:31,760 --> 00:17:35,679
all you know all the line numbers and

510
00:17:33,840 --> 00:17:39,280
all the commands of course so

511
00:17:35,679 --> 00:17:39,280
if we have line number here

512
00:17:40,400 --> 00:17:43,840
well you know it's not just one line

513
00:17:42,240 --> 00:17:46,000
number right it's several line numbers

514
00:17:43,840 --> 00:17:48,000
one for each line in the program so we

515
00:17:46,000 --> 00:17:49,840
always have to use it like this

516
00:17:48,000 --> 00:17:52,320
right that we always put the three dots

517
00:17:49,840 --> 00:17:54,879
behind it otherwise racket will complain

518
00:17:52,320 --> 00:17:56,559
and moreover a line number again is a

519
00:17:54,880 --> 00:17:57,919
pattern variable that comes from this

520
00:17:56,559 --> 00:18:01,200
line in the syntax

521
00:17:57,919 --> 00:18:03,120
parse form so you know the pattern

522
00:18:01,200 --> 00:18:06,960
variables they really only work

523
00:18:03,120 --> 00:18:08,559
in this hash bang this hash

524
00:18:06,960 --> 00:18:10,400
back quote form so that's what we need

525
00:18:08,559 --> 00:18:13,600
to write and

526
00:18:10,400 --> 00:18:15,840
um also we do the same thing with the

527
00:18:13,600 --> 00:18:16,719
commands and we're still not done

528
00:18:15,840 --> 00:18:19,120
because

529
00:18:16,720 --> 00:18:21,360
well you remember you know hash back

530
00:18:19,120 --> 00:18:23,120
quote returns a syntax object but what

531
00:18:21,360 --> 00:18:24,080
we really need is a list because we're

532
00:18:23,120 --> 00:18:27,199
feeding that

533
00:18:24,080 --> 00:18:28,960
into map so

534
00:18:27,200 --> 00:18:32,400
racket has a handy function that does

535
00:18:28,960 --> 00:18:32,400
that called syntax to list

536
00:18:32,640 --> 00:18:36,240
also here is syntax to list for the

537
00:18:35,120 --> 00:18:40,320
commands

538
00:18:36,240 --> 00:18:42,720
and that allows us to map over

539
00:18:40,320 --> 00:18:44,240
um well here are the nine numbers and

540
00:18:42,720 --> 00:18:47,840
the commands

541
00:18:44,240 --> 00:18:50,559
now you now here's the subtly um

542
00:18:47,840 --> 00:18:52,080
suddenly because we now have uh line

543
00:18:50,559 --> 00:18:54,000
number and command b regular lambda

544
00:18:52,080 --> 00:18:55,439
parameters they are no longer pattern

545
00:18:54,000 --> 00:18:57,360
variables

546
00:18:55,440 --> 00:18:59,280
okay they're just regular variables and

547
00:18:57,360 --> 00:19:00,559
this i think really is the most subtle

548
00:18:59,280 --> 00:19:02,639
aspect of the

549
00:19:00,559 --> 00:19:04,720
of the racket macro system is so if you

550
00:19:02,640 --> 00:19:06,880
understand this issue right the pattern

551
00:19:04,720 --> 00:19:09,360
variables come from up here

552
00:19:06,880 --> 00:19:11,679
and everything else everything that is

553
00:19:09,360 --> 00:19:13,678
not here in a syntax parse

554
00:19:11,679 --> 00:19:14,880
form in the in the pattern part is not a

555
00:19:13,679 --> 00:19:16,640
pattern variable

556
00:19:14,880 --> 00:19:18,559
so in this case these are now regular

557
00:19:16,640 --> 00:19:23,600
variables and that means they should not

558
00:19:18,559 --> 00:19:25,120
appear in hash back quote anymore

559
00:19:23,600 --> 00:19:27,439
and this part where the line number is

560
00:19:25,120 --> 00:19:28,159
also means that racket is not just going

561
00:19:27,440 --> 00:19:30,320
to replace

562
00:19:28,160 --> 00:19:32,080
the pattern variable by the expansion

563
00:19:30,320 --> 00:19:32,799
down here with command so i've got to

564
00:19:32,080 --> 00:19:36,080
push

565
00:19:32,799 --> 00:19:38,080
hash comma ear so if you figure that out

566
00:19:36,080 --> 00:19:39,600
if you figure out that distinction i

567
00:19:38,080 --> 00:19:41,280
think you'll be fine

568
00:19:39,600 --> 00:19:42,959
so let's try that out i'll run the

569
00:19:41,280 --> 00:19:46,000
program thankfully there are no

570
00:19:42,960 --> 00:19:49,440
error messages let's try again that

571
00:19:46,000 --> 00:19:50,720
basic program oh ah it complains again

572
00:19:49,440 --> 00:19:52,240
there's another trap

573
00:19:50,720 --> 00:19:53,840
well not a trap really it's something

574
00:19:52,240 --> 00:19:56,320
that we've seen before

575
00:19:53,840 --> 00:19:56,879
is map returns a list and you can see

576
00:19:56,320 --> 00:19:59,120
here

577
00:19:56,880 --> 00:20:02,559
so it says your quote open for n that

578
00:19:59,120 --> 00:20:02,559
means it returned a list

579
00:20:02,720 --> 00:20:08,240
and uh that means well map produce a

580
00:20:06,000 --> 00:20:09,440
list but racket really expects a syntax

581
00:20:08,240 --> 00:20:10,799
object

582
00:20:09,440 --> 00:20:13,440
you know if you're coming from lisp or

583
00:20:10,799 --> 00:20:15,679
from closure um you expect sort of lists

584
00:20:13,440 --> 00:20:17,919
to be usable as syntax objects

585
00:20:15,679 --> 00:20:19,520
but racket makes a strict distinction

586
00:20:17,919 --> 00:20:21,440
here and it uses that distinction to

587
00:20:19,520 --> 00:20:22,799
track

588
00:20:21,440 --> 00:20:24,720
source code locations to give you good

589
00:20:22,799 --> 00:20:26,960
error messages and also

590
00:20:24,720 --> 00:20:28,640
to track hygiene to keep track of

591
00:20:26,960 --> 00:20:29,520
lexical binding which is not the main

592
00:20:28,640 --> 00:20:32,000
focus

593
00:20:29,520 --> 00:20:34,000
of this tutorial but just so you know so

594
00:20:32,000 --> 00:20:36,159
anyway we need to definitely stick

595
00:20:34,000 --> 00:20:37,760
hash back quote here and now we have

596
00:20:36,159 --> 00:20:38,960
several definitions and because we have

597
00:20:37,760 --> 00:20:40,640
several definitions that we want to

598
00:20:38,960 --> 00:20:43,280
stick in one single form

599
00:20:40,640 --> 00:20:44,000
we use begin just like we did with print

600
00:20:43,280 --> 00:20:46,080
before

601
00:20:44,000 --> 00:20:47,679
just going to indent everything nicely

602
00:20:46,080 --> 00:20:48,240
and of course now we want to stick the

603
00:20:47,679 --> 00:20:51,360
result

604
00:20:48,240 --> 00:20:56,559
of evaluating this in here

605
00:20:51,360 --> 00:20:56,559
so i've got to put hash comma here okay

606
00:20:56,880 --> 00:21:00,559
and unfortunately there's still another

607
00:20:58,799 --> 00:21:00,960
satellite if you look at the expansion

608
00:21:00,559 --> 00:21:03,360
here

609
00:21:00,960 --> 00:21:04,159
you can see that it would well hopefully

610
00:21:03,360 --> 00:21:06,000
you can see

611
00:21:04,159 --> 00:21:07,679
that it would expand into something like

612
00:21:06,000 --> 00:21:10,320
this right you have begin

613
00:21:07,679 --> 00:21:12,080
you know from here and then you have the

614
00:21:10,320 --> 00:21:13,439
open paren which is from the list

615
00:21:12,080 --> 00:21:15,678
produced by map and then

616
00:21:13,440 --> 00:21:16,559
inside those open parens are the

617
00:21:15,679 --> 00:21:19,919
definitions

618
00:21:16,559 --> 00:21:23,200
of the various lines like you know line

619
00:21:19,919 --> 00:21:25,760
10 line 20 and so on

620
00:21:23,200 --> 00:21:26,880
and you can see that there's one pair of

621
00:21:25,760 --> 00:21:29,679
parentheses

622
00:21:26,880 --> 00:21:32,000
too many so we really don't want the

623
00:21:29,679 --> 00:21:33,520
racket macro expander to stick that list

624
00:21:32,000 --> 00:21:34,640
in there we want it to stick the

625
00:21:33,520 --> 00:21:37,840
elements of the list

626
00:21:34,640 --> 00:21:39,520
one by one inside the begin and to do

627
00:21:37,840 --> 00:21:40,240
that we need to put a magic character

628
00:21:39,520 --> 00:21:44,320
here

629
00:21:40,240 --> 00:21:47,360
also sometimes pronounced un splicing

630
00:21:44,320 --> 00:21:50,240
so and that does exactly what we want so

631
00:21:47,360 --> 00:21:51,760
it's it's just like comma but it expects

632
00:21:50,240 --> 00:21:53,679
a list and it will stick the elements of

633
00:21:51,760 --> 00:21:54,240
the list there effectively removing one

634
00:21:53,679 --> 00:21:57,760
pair

635
00:21:54,240 --> 00:21:58,480
of parentheses so let's try that again

636
00:21:57,760 --> 00:22:00,240
oops

637
00:21:58,480 --> 00:22:01,919
uh so here's that basic form at least it

638
00:22:00,240 --> 00:22:03,039
doesn't error out anymore let's see if

639
00:22:01,919 --> 00:22:05,840
we can start it

640
00:22:03,039 --> 00:22:06,799
and it says hello world and we could

641
00:22:05,840 --> 00:22:08,799
also now

642
00:22:06,799 --> 00:22:09,840
extend it right and put another line

643
00:22:08,799 --> 00:22:13,039
here

644
00:22:09,840 --> 00:22:15,918
um so right now we only know print

645
00:22:13,039 --> 00:22:15,919
so uh

646
00:22:16,480 --> 00:22:23,919
do that and um

647
00:22:20,960 --> 00:22:24,640
so i can start line 10 and you can see

648
00:22:23,919 --> 00:22:27,280
that it

649
00:22:24,640 --> 00:22:29,120
well line 10 runs but really we expect

650
00:22:27,280 --> 00:22:29,918
the program to go on to line 20 after

651
00:22:29,120 --> 00:22:32,719
line 10.

652
00:22:29,919 --> 00:22:34,640
line 20 is there but uh we haven't yet

653
00:22:32,720 --> 00:22:37,600
linked the lines together so that's

654
00:22:34,640 --> 00:22:38,240
going to be our next problem so what we

655
00:22:37,600 --> 00:22:41,280
need to do

656
00:22:38,240 --> 00:22:43,039
here is well after the command you know

657
00:22:41,280 --> 00:22:44,320
associated with the line happens we need

658
00:22:43,039 --> 00:22:48,720
to stick in

659
00:22:44,320 --> 00:22:50,399
a call to the next line right

660
00:22:48,720 --> 00:22:52,559
now how do we get that call right in

661
00:22:50,400 --> 00:22:54,320
order to produce the call for the next

662
00:22:52,559 --> 00:22:55,600
line we need the line number of the next

663
00:22:54,320 --> 00:22:57,280
line but we don't have it here we just

664
00:22:55,600 --> 00:22:59,520
have the current line number

665
00:22:57,280 --> 00:23:01,039
and uh to do that we're just going to

666
00:22:59,520 --> 00:23:03,360
map over an additional list

667
00:23:01,039 --> 00:23:04,960
which is going to be like the original

668
00:23:03,360 --> 00:23:05,918
list of line numbers but we'll shift it

669
00:23:04,960 --> 00:23:09,039
by one

670
00:23:05,919 --> 00:23:10,640
so along with the current line number

671
00:23:09,039 --> 00:23:13,120
there's always the next line number and

672
00:23:10,640 --> 00:23:14,080
to that end i'm going to call the the

673
00:23:13,120 --> 00:23:17,280
lisp function

674
00:23:14,080 --> 00:23:20,480
quarter which just you know removes the

675
00:23:17,280 --> 00:23:20,480
first element from a list

676
00:23:20,799 --> 00:23:26,639
and um so that that gives us that

677
00:23:24,240 --> 00:23:28,159
and now of course map would complain

678
00:23:26,640 --> 00:23:30,000
because the lists do not

679
00:23:28,159 --> 00:23:32,080
no longer have the same length right

680
00:23:30,000 --> 00:23:33,600
this list is one shorter

681
00:23:32,080 --> 00:23:35,199
and so we need to append an element to

682
00:23:33,600 --> 00:23:36,719
make up for the last element and since

683
00:23:35,200 --> 00:23:39,679
there is no

684
00:23:36,720 --> 00:23:41,120
um since there is no line after the last

685
00:23:39,679 --> 00:23:42,960
line i'm just going to pass

686
00:23:41,120 --> 00:23:44,719
false right this is racket syntax for

687
00:23:42,960 --> 00:23:46,320
false f

688
00:23:44,720 --> 00:23:48,080
and we'll need to make sure that after

689
00:23:46,320 --> 00:23:48,559
the last line we don't try to stick in a

690
00:23:48,080 --> 00:23:52,080
call

691
00:23:48,559 --> 00:23:53,918
okay so here we are

692
00:23:52,080 --> 00:23:55,678
ah we need to of course make sure that

693
00:23:53,919 --> 00:23:57,120
now that we're mapping over three lists

694
00:23:55,679 --> 00:24:00,960
and not just one

695
00:23:57,120 --> 00:24:02,479
i need to add an additional parameter

696
00:24:00,960 --> 00:24:05,679
here right and now

697
00:24:02,480 --> 00:24:08,799
we could say call next line

698
00:24:05,679 --> 00:24:11,360
and i could just you know stick in

699
00:24:08,799 --> 00:24:12,080
a call to format it like this right me

700
00:24:11,360 --> 00:24:14,799
and then pass

701
00:24:12,080 --> 00:24:15,520
next line number but that would be poor

702
00:24:14,799 --> 00:24:18,000
abstraction

703
00:24:15,520 --> 00:24:19,600
and uh well it's kind of copy paste code

704
00:24:18,000 --> 00:24:20,960
so we could pull it out into its own

705
00:24:19,600 --> 00:24:22,080
function definition that's a useful

706
00:24:20,960 --> 00:24:24,320
exercise so

707
00:24:22,080 --> 00:24:25,918
i'm going to take that code copy it one

708
00:24:24,320 --> 00:24:27,760
last time

709
00:24:25,919 --> 00:24:29,520
stick it up here now there's two

710
00:24:27,760 --> 00:24:31,279
subtleties let me get rid of this

711
00:24:29,520 --> 00:24:33,120
obsolete comment here that we have to

712
00:24:31,279 --> 00:24:35,520
pay attention to

713
00:24:33,120 --> 00:24:37,360
so i'm going to call that function you

714
00:24:35,520 --> 00:24:40,879
know make

715
00:24:37,360 --> 00:24:41,678
line name and of course we need to pass

716
00:24:40,880 --> 00:24:44,799
in the line number

717
00:24:41,679 --> 00:24:46,000
this thing here but we need to pass in

718
00:24:44,799 --> 00:24:47,918
one more thing because

719
00:24:46,000 --> 00:24:49,360
this basic here that you see here

720
00:24:47,919 --> 00:24:52,240
remember that it referred to

721
00:24:49,360 --> 00:24:52,879
this basic down here right it used to be

722
00:24:52,240 --> 00:24:54,320
here

723
00:24:52,880 --> 00:24:56,240
but that's no longer in scope because

724
00:24:54,320 --> 00:24:58,240
we're outside of its parentheses

725
00:24:56,240 --> 00:25:00,320
so we also need to pass it in as an

726
00:24:58,240 --> 00:25:01,679
argument and we'll call that it's called

727
00:25:00,320 --> 00:25:03,120
the context

728
00:25:01,679 --> 00:25:05,200
used by racket to make sure that the

729
00:25:03,120 --> 00:25:07,520
definitions appear

730
00:25:05,200 --> 00:25:08,960
in the right place and are referable by

731
00:25:07,520 --> 00:25:12,000
their name

732
00:25:08,960 --> 00:25:14,000
okay so we have this great

733
00:25:12,000 --> 00:25:15,120
and then we can take out those two calls

734
00:25:14,000 --> 00:25:18,559
here

735
00:25:15,120 --> 00:25:22,080
um and

736
00:25:18,559 --> 00:25:24,480
uh and call make line name instead

737
00:25:22,080 --> 00:25:25,520
remember that we now need to call this

738
00:25:24,480 --> 00:25:28,880
basic thing that was

739
00:25:25,520 --> 00:25:31,918
there before and line number

740
00:25:28,880 --> 00:25:35,279
and the same thing

741
00:25:31,919 --> 00:25:38,480
over here i'm sorry it's called make

742
00:25:35,279 --> 00:25:39,520
line name probably noticed and we'll do

743
00:25:38,480 --> 00:25:43,039
the same thing here

744
00:25:39,520 --> 00:25:43,760
call it make line name remove all the

745
00:25:43,039 --> 00:25:45,840
crud here

746
00:25:43,760 --> 00:25:47,360
let's duplicate it and now we have a

747
00:25:45,840 --> 00:25:49,520
nice call of course

748
00:25:47,360 --> 00:25:51,600
well we'll we'll get to the fact that

749
00:25:49,520 --> 00:25:54,400
it's not a call yet in a moment

750
00:25:51,600 --> 00:25:56,080
but also i want you to think about one

751
00:25:54,400 --> 00:25:57,679
more aspect of macro expansion

752
00:25:56,080 --> 00:25:59,678
this definition up here of make line

753
00:25:57,679 --> 00:26:00,960
name is just a regular procedure

754
00:25:59,679 --> 00:26:03,600
definition

755
00:26:00,960 --> 00:26:05,120
but we want to call it from the macro

756
00:26:03,600 --> 00:26:06,959
expansion process so

757
00:26:05,120 --> 00:26:08,719
essentially at compile time or macro

758
00:26:06,960 --> 00:26:10,000
expansion time but this is just a

759
00:26:08,720 --> 00:26:13,120
regular runtime function it will

760
00:26:10,000 --> 00:26:15,440
not be available until runtime happens

761
00:26:13,120 --> 00:26:16,639
and in order to tell racket no this is a

762
00:26:15,440 --> 00:26:17,760
function please make it available to

763
00:26:16,640 --> 00:26:20,880
macro expansion

764
00:26:17,760 --> 00:26:22,720
we need to replace the define by define

765
00:26:20,880 --> 00:26:24,080
for syntax so define it so it's

766
00:26:22,720 --> 00:26:29,600
available during syntax

767
00:26:24,080 --> 00:26:32,480
expansion okay so one more thing

768
00:26:29,600 --> 00:26:33,840
this is of course not a call yet in

769
00:26:32,480 --> 00:26:35,919
order to have a call we need to have

770
00:26:33,840 --> 00:26:36,720
parenthesis to the parentheses around

771
00:26:35,919 --> 00:26:40,799
the name

772
00:26:36,720 --> 00:26:44,799
of the next line so i'm going to

773
00:26:40,799 --> 00:26:46,158
put do this and put parentheses around

774
00:26:44,799 --> 00:26:48,879
it and then stick this in

775
00:26:46,159 --> 00:26:50,400
with hash comma right and that would be

776
00:26:48,880 --> 00:26:53,760
the call to the next line

777
00:26:50,400 --> 00:26:56,799
well except it isn't quite because

778
00:26:53,760 --> 00:27:00,000
remember next line number can be false

779
00:26:56,799 --> 00:27:01,840
right and then we would not have the

780
00:27:00,000 --> 00:27:03,360
then then we would not have a function

781
00:27:01,840 --> 00:27:05,279
to call there

782
00:27:03,360 --> 00:27:07,199
so we really need to make a case

783
00:27:05,279 --> 00:27:10,240
distinction here i'm going to say well

784
00:27:07,200 --> 00:27:11,919
if there's a next line number then

785
00:27:10,240 --> 00:27:13,679
this is a great function to call this is

786
00:27:11,919 --> 00:27:15,600
the function of the next line

787
00:27:13,679 --> 00:27:17,840
and if there isn't well i'm just going

788
00:27:15,600 --> 00:27:19,840
to call void which is

789
00:27:17,840 --> 00:27:21,039
a function that does absolutely nothing

790
00:27:19,840 --> 00:27:24,639
that's built

791
00:27:21,039 --> 00:27:27,120
into racket okay let's try it out let's

792
00:27:24,640 --> 00:27:29,840
give it a whirl well oh it says

793
00:27:27,120 --> 00:27:30,639
next line number reference to an unbound

794
00:27:29,840 --> 00:27:32,799
uh

795
00:27:30,640 --> 00:27:34,080
identifier ah that's because i put a

796
00:27:32,799 --> 00:27:35,840
typo here

797
00:27:34,080 --> 00:27:37,279
let's try that again okay now it at

798
00:27:35,840 --> 00:27:39,840
least goes through

799
00:27:37,279 --> 00:27:41,440
um let's see we had that program that

800
00:27:39,840 --> 00:27:43,439
had two lines in it

801
00:27:41,440 --> 00:27:44,640
it doesn't error out that's great call

802
00:27:43,440 --> 00:27:47,840
line ten

803
00:27:44,640 --> 00:27:48,799
and ah okay now it runs both lines

804
00:27:47,840 --> 00:27:50,720
that's wonderful

805
00:27:48,799 --> 00:27:52,639
but we see that we made a small mistake

806
00:27:50,720 --> 00:27:54,720
in the implementation of print

807
00:27:52,640 --> 00:27:56,399
at least in apple soft basic when you

808
00:27:54,720 --> 00:27:59,520
call print it prints

809
00:27:56,399 --> 00:28:01,600
return a new line at the end so why

810
00:27:59,520 --> 00:28:03,279
don't as a last act of this particular

811
00:28:01,600 --> 00:28:08,719
task we go up here

812
00:28:03,279 --> 00:28:12,720
and stick up here they called a new line

813
00:28:08,720 --> 00:28:15,440
that should work try that again

814
00:28:12,720 --> 00:28:17,039
and now we get the output as we've

815
00:28:15,440 --> 00:28:17,919
wanted it from the beginning so now we

816
00:28:17,039 --> 00:28:20,480
can have

817
00:28:17,919 --> 00:28:22,080
a sort of a basic program that has

818
00:28:20,480 --> 00:28:25,520
several lines where the lines

819
00:28:22,080 --> 00:28:27,918
are run consecutively that's great

820
00:28:25,520 --> 00:28:29,120
so what's next well here we can already

821
00:28:27,919 --> 00:28:31,520
see what might be next

822
00:28:29,120 --> 00:28:33,439
which is the infamous go-to command in

823
00:28:31,520 --> 00:28:36,080
basic which just jumps to a

824
00:28:33,440 --> 00:28:36,960
to another place with no memory of where

825
00:28:36,080 --> 00:28:40,480
it came from

826
00:28:36,960 --> 00:28:43,679
or what was going on beforehand so

827
00:28:40,480 --> 00:28:45,039
if we look at um you know our code here

828
00:28:43,679 --> 00:28:46,799
we can see that

829
00:28:45,039 --> 00:28:48,399
go to is going to require special

830
00:28:46,799 --> 00:28:50,080
treatment we can't just

831
00:28:48,399 --> 00:28:52,080
implement it the way that we implement

832
00:28:50,080 --> 00:28:54,399
it that we implement print

833
00:28:52,080 --> 00:28:55,520
because of course when there's a go to

834
00:28:54,399 --> 00:28:58,080
there should not be

835
00:28:55,520 --> 00:28:59,520
a call to the next line after the go to

836
00:28:58,080 --> 00:28:59,840
that would make no sense because go to

837
00:28:59,520 --> 00:29:02,960
just

838
00:28:59,840 --> 00:29:04,799
transfers control directly now

839
00:29:02,960 --> 00:29:06,880
um well things are getting a little bit

840
00:29:04,799 --> 00:29:08,559
unwieldy at this point uh in this in

841
00:29:06,880 --> 00:29:11,600
this longest function here

842
00:29:08,559 --> 00:29:13,520
so um i will

843
00:29:11,600 --> 00:29:14,799
put the code that translates a single

844
00:29:13,520 --> 00:29:16,480
command into

845
00:29:14,799 --> 00:29:17,918
a separate function and we'll see how

846
00:29:16,480 --> 00:29:20,000
that goes so

847
00:29:17,919 --> 00:29:20,960
here again remember that we need to say

848
00:29:20,000 --> 00:29:22,799
define for

849
00:29:20,960 --> 00:29:24,559
syntax so it's not a macro it's a

850
00:29:22,799 --> 00:29:25,600
function that is called from a macro

851
00:29:24,559 --> 00:29:26,799
definition

852
00:29:25,600 --> 00:29:28,719
i'm going to call that function

853
00:29:26,799 --> 00:29:32,399
translate command

854
00:29:28,720 --> 00:29:36,480
and um well so we pass in

855
00:29:32,399 --> 00:29:38,320
the we pass in the actual

856
00:29:36,480 --> 00:29:40,000
command so that's the that's if you will

857
00:29:38,320 --> 00:29:42,720
the original source code from the basic

858
00:29:40,000 --> 00:29:44,640
program and we need to translate that

859
00:29:42,720 --> 00:29:47,840
into racket code

860
00:29:44,640 --> 00:29:50,320
and well and the idea is that we

861
00:29:47,840 --> 00:29:51,199
use translate command to produce the

862
00:29:50,320 --> 00:29:54,879
body

863
00:29:51,200 --> 00:29:56,720
of this function here so

864
00:29:54,880 --> 00:29:59,520
of course that means we need to also

865
00:29:56,720 --> 00:30:02,559
pass in call next line

866
00:29:59,520 --> 00:30:05,279
so let's see let's pass that in

867
00:30:02,559 --> 00:30:06,799
great and for now we're just going to

868
00:30:05,279 --> 00:30:07,360
keep that very simple we're just going

869
00:30:06,799 --> 00:30:08,879
to

870
00:30:07,360 --> 00:30:10,479
going to keep the definition from up

871
00:30:08,880 --> 00:30:12,240
here now again remember

872
00:30:10,480 --> 00:30:14,559
that when we produce syntax we can only

873
00:30:12,240 --> 00:30:15,840
produce a single form at a time so there

874
00:30:14,559 --> 00:30:19,279
are two forms here

875
00:30:15,840 --> 00:30:20,399
but we know we can always combine two

876
00:30:19,279 --> 00:30:23,679
forms into one

877
00:30:20,399 --> 00:30:25,520
by sticking a beacon in front so we'll

878
00:30:23,679 --> 00:30:26,240
just do the abstraction for now without

879
00:30:25,520 --> 00:30:28,559
adding

880
00:30:26,240 --> 00:30:29,279
additional functionality so instead we

881
00:30:28,559 --> 00:30:32,879
will say

882
00:30:29,279 --> 00:30:36,960
ok translate command

883
00:30:32,880 --> 00:30:40,240
if command and call next

884
00:30:36,960 --> 00:30:42,960
line and omit this

885
00:30:40,240 --> 00:30:44,960
do away with that make sure that all the

886
00:30:42,960 --> 00:30:46,480
parentheses line up

887
00:30:44,960 --> 00:30:49,679
yeah it's getting getting to be a lot of

888
00:30:46,480 --> 00:30:53,520
parentheses and see if that works

889
00:30:49,679 --> 00:30:55,760
so run that and

890
00:30:53,520 --> 00:30:56,960
you know program runs as before that's

891
00:30:55,760 --> 00:30:59,600
great

892
00:30:56,960 --> 00:31:00,640
so we want to give go to special

893
00:30:59,600 --> 00:31:02,399
treatment

894
00:31:00,640 --> 00:31:04,480
and in order to do that well we need to

895
00:31:02,399 --> 00:31:05,918
inspect the command here and see well if

896
00:31:04,480 --> 00:31:07,519
it's a go to command then we give it

897
00:31:05,919 --> 00:31:08,960
this treatment in all other cases we

898
00:31:07,519 --> 00:31:10,000
just translate to the code that we

899
00:31:08,960 --> 00:31:12,720
already have

900
00:31:10,000 --> 00:31:13,760
so i call some text powers call pass the

901
00:31:12,720 --> 00:31:15,600
command

902
00:31:13,760 --> 00:31:17,440
and now i put here a pattern where it

903
00:31:15,600 --> 00:31:18,080
says well if it's a go to command looks

904
00:31:17,440 --> 00:31:20,080
like this go

905
00:31:18,080 --> 00:31:21,600
to there's a line number and that line

906
00:31:20,080 --> 00:31:22,639
number is an integer then i'm going to

907
00:31:21,600 --> 00:31:24,240
do one thing

908
00:31:22,640 --> 00:31:26,080
and in all other cases i want to do

909
00:31:24,240 --> 00:31:28,159
something else you can see here

910
00:31:26,080 --> 00:31:29,918
that you know this is now a syntax parse

911
00:31:28,159 --> 00:31:31,039
that has several clauses and it just

912
00:31:29,919 --> 00:31:33,039
tries them in order

913
00:31:31,039 --> 00:31:34,799
the compiler while it does syntax

914
00:31:33,039 --> 00:31:35,840
expansion first tries the first one then

915
00:31:34,799 --> 00:31:37,279
the second one the first one that

916
00:31:35,840 --> 00:31:39,840
matches

917
00:31:37,279 --> 00:31:41,840
gets to be run and this thing here is

918
00:31:39,840 --> 00:31:43,199
just a wild card pattern that matches

919
00:31:41,840 --> 00:31:45,600
anything that you want so that's the

920
00:31:43,200 --> 00:31:48,960
fall through clause at the end

921
00:31:45,600 --> 00:31:51,519
okay so in this case well we have go to

922
00:31:48,960 --> 00:31:53,360
now here's another subtly in order we

923
00:31:51,519 --> 00:31:53,760
really want the word goto to appear

924
00:31:53,360 --> 00:31:55,678
there

925
00:31:53,760 --> 00:31:57,039
but remember that syntax parse does

926
00:31:55,679 --> 00:31:58,320
pattern matching so whenever there's a

927
00:31:57,039 --> 00:31:59,760
name here

928
00:31:58,320 --> 00:32:01,519
that name is just going to match

929
00:31:59,760 --> 00:32:02,960
whatever is there in the input

930
00:32:01,519 --> 00:32:04,640
it's a really subtle issue we really

931
00:32:02,960 --> 00:32:07,760
want the word go to

932
00:32:04,640 --> 00:32:09,279
to appear here and another subtle issue

933
00:32:07,760 --> 00:32:09,760
is that we want that to be consistent

934
00:32:09,279 --> 00:32:11,120
with

935
00:32:09,760 --> 00:32:13,679
the rest of the binding structure of the

936
00:32:11,120 --> 00:32:16,080
program we'll ignore that here

937
00:32:13,679 --> 00:32:18,080
but in order to do that we need to put

938
00:32:16,080 --> 00:32:19,600
something like this a magic clause here

939
00:32:18,080 --> 00:32:22,639
at the beginning that says

940
00:32:19,600 --> 00:32:24,959
well go to whenever it appears here

941
00:32:22,640 --> 00:32:26,960
means that we really want the word go to

942
00:32:24,960 --> 00:32:29,200
to show up there so for all of our

943
00:32:26,960 --> 00:32:31,840
specially treated commands

944
00:32:29,200 --> 00:32:33,600
we need to put that in we put them you

945
00:32:31,840 --> 00:32:36,879
need to put the name of that command

946
00:32:33,600 --> 00:32:40,320
into the literals clause up here okay

947
00:32:36,880 --> 00:32:43,519
so now when there's a go to we don't

948
00:32:40,320 --> 00:32:46,559
you know we just want to generate a call

949
00:32:43,519 --> 00:32:47,840
to um the procedure that's associated

950
00:32:46,559 --> 00:32:50,320
with that line number

951
00:32:47,840 --> 00:32:51,199
and we get the name of that procedure by

952
00:32:50,320 --> 00:32:54,879
saying make

953
00:32:51,200 --> 00:32:56,320
my name um well and remember make line

954
00:32:54,880 --> 00:32:58,000
name now needs that

955
00:32:56,320 --> 00:32:59,678
context argument up here and we don't

956
00:32:58,000 --> 00:33:01,760
have it here so

957
00:32:59,679 --> 00:33:02,799
we need to add another parameter call

958
00:33:01,760 --> 00:33:07,279
that context

959
00:33:02,799 --> 00:33:07,279
up here we pass basic

960
00:33:08,159 --> 00:33:14,159
and uh okay got that here

961
00:33:11,440 --> 00:33:15,200
and then we can call make line name with

962
00:33:14,159 --> 00:33:18,320
context

963
00:33:15,200 --> 00:33:21,120
and the line number okay

964
00:33:18,320 --> 00:33:22,639
so got that here and that's just the

965
00:33:21,120 --> 00:33:24,479
name of the procedure we still need to

966
00:33:22,640 --> 00:33:25,360
make a piece of syntax with a call to it

967
00:33:24,480 --> 00:33:27,039
so we put

968
00:33:25,360 --> 00:33:29,279
hash bang back quote put a pair of

969
00:33:27,039 --> 00:33:31,039
parentheses and in the middle

970
00:33:29,279 --> 00:33:33,919
we need to put hashbang comma to

971
00:33:31,039 --> 00:33:35,919
actually stick that name there

972
00:33:33,919 --> 00:33:37,600
okay well let's see if it does anything

973
00:33:35,919 --> 00:33:40,720
oh error message

974
00:33:37,600 --> 00:33:42,080
well again i fell into the same trap

975
00:33:40,720 --> 00:33:44,720
that i always fall into

976
00:33:42,080 --> 00:33:46,240
line number here is a pattern variable

977
00:33:44,720 --> 00:33:49,440
so it really is only valid

978
00:33:46,240 --> 00:33:50,799
inside a hash bang back quote well it is

979
00:33:49,440 --> 00:33:52,799
inside a hashbang back quote but the

980
00:33:50,799 --> 00:33:53,120
hashbang comma kind of undoes that it's

981
00:33:52,799 --> 00:33:55,120
a

982
00:33:53,120 --> 00:33:57,199
so we refer to it as a regular variable

983
00:33:55,120 --> 00:33:57,760
here in order to refer to a pattern

984
00:33:57,200 --> 00:33:59,919
variable

985
00:33:57,760 --> 00:34:01,279
again we need to put hash bank back

986
00:33:59,919 --> 00:34:03,919
quote here

987
00:34:01,279 --> 00:34:04,720
so it must seem confusing at this point

988
00:34:03,919 --> 00:34:06,640
but

989
00:34:04,720 --> 00:34:08,240
if you just do a bunch of stuff with

990
00:34:06,640 --> 00:34:10,399
macros you will soon get the hang of

991
00:34:08,239 --> 00:34:12,399
that i think and then you'll recognize

992
00:34:10,399 --> 00:34:13,918
the uh the error message right here it

993
00:34:12,399 --> 00:34:16,159
says pattern variable cannot be

994
00:34:13,918 --> 00:34:17,679
used outside of a template so line

995
00:34:16,159 --> 00:34:18,560
number is a pattern variable now we can

996
00:34:17,679 --> 00:34:21,040
see oh

997
00:34:18,560 --> 00:34:23,359
that nicely that occurrence here of line

998
00:34:21,040 --> 00:34:26,399
number nicely refers to that one

999
00:34:23,359 --> 00:34:29,520
let's see if it runs now okay

1000
00:34:26,399 --> 00:34:29,520
see if we can do this

1001
00:34:30,480 --> 00:34:34,000
so well here's a rule that i forgot

1002
00:34:33,359 --> 00:34:35,119
about but

1003
00:34:34,000 --> 00:34:36,320
fortunately it's easier to remember

1004
00:34:35,119 --> 00:34:38,960
because there's an error message says

1005
00:34:36,320 --> 00:34:41,200
literal is unbound in phase zero

1006
00:34:38,960 --> 00:34:42,399
right uh phase zero has to do with the

1007
00:34:41,199 --> 00:34:44,638
phase zero's run time

1008
00:34:42,399 --> 00:34:47,118
uh don't have to worry about that too

1009
00:34:44,639 --> 00:34:49,760
much but it just means that go to has no

1010
00:34:47,119 --> 00:34:51,119
definition that it refers to and we're

1011
00:34:49,760 --> 00:34:52,960
not interested in a definition because

1012
00:34:51,119 --> 00:34:54,399
we're translating calls to go to

1013
00:34:52,960 --> 00:34:56,560
into something else anyway so i'm just

1014
00:34:54,399 --> 00:34:57,680
going to say put in a dummy definition

1015
00:34:56,560 --> 00:34:59,279
here to false

1016
00:34:57,680 --> 00:35:01,118
and that just means if there's any

1017
00:34:59,280 --> 00:35:04,240
reference to that go to

1018
00:35:01,119 --> 00:35:05,839
then you know syntax parse will

1019
00:35:04,240 --> 00:35:07,279
recognize it let's

1020
00:35:05,839 --> 00:35:09,359
push the wrong button there let me try

1021
00:35:07,280 --> 00:35:11,599
again

1022
00:35:09,359 --> 00:35:13,040
and well at least it doesn't error out

1023
00:35:11,599 --> 00:35:16,640
let's see if we can

1024
00:35:13,040 --> 00:35:19,759
run the program and that's pretty neat

1025
00:35:16,640 --> 00:35:22,799
and now well i guess it's time that

1026
00:35:19,760 --> 00:35:24,240
um i put an actual basic program here

1027
00:35:22,800 --> 00:35:26,640
into the source code so i don't have to

1028
00:35:24,240 --> 00:35:31,680
keep retyping it like this

1029
00:35:26,640 --> 00:35:33,839
um you know like like this for example

1030
00:35:31,680 --> 00:35:35,598
and well how are we going to see that it

1031
00:35:33,839 --> 00:35:36,880
works i'm just going to put a line 20

1032
00:35:35,599 --> 00:35:41,599
there that says go to

1033
00:35:36,880 --> 00:35:45,040
4d uh make that line 30

1034
00:35:41,599 --> 00:35:48,400
and put line 40 which says

1035
00:35:45,040 --> 00:35:51,359
uh you know the end right

1036
00:35:48,400 --> 00:35:52,960
so that we know the program is done

1037
00:35:51,359 --> 00:35:55,520
let's see if that works

1038
00:35:52,960 --> 00:35:57,440
we could call line 10 and indeed it says

1039
00:35:55,520 --> 00:36:00,720
hello world the end and it skips

1040
00:35:57,440 --> 00:36:02,800
hello again so go to works now

1041
00:36:00,720 --> 00:36:04,399
all right what's next well we can just

1042
00:36:02,800 --> 00:36:06,240
keep adding commands right but

1043
00:36:04,400 --> 00:36:07,680
of course some cause more trouble than

1044
00:36:06,240 --> 00:36:08,720
others and one that causes a little bit

1045
00:36:07,680 --> 00:36:11,118
of trouble

1046
00:36:08,720 --> 00:36:11,839
is assignment right we can have

1047
00:36:11,119 --> 00:36:13,680
variables

1048
00:36:11,839 --> 00:36:15,040
in basic might look like well in basic

1049
00:36:13,680 --> 00:36:18,480
it would look like this right a

1050
00:36:15,040 --> 00:36:21,040
equals 42. and

1051
00:36:18,480 --> 00:36:21,599
you know that would establish a variable

1052
00:36:21,040 --> 00:36:24,400
called a

1053
00:36:21,599 --> 00:36:25,520
we could then use it right we could say

1054
00:36:24,400 --> 00:36:28,160
something like this

1055
00:36:25,520 --> 00:36:29,359
and um i'm going to use the syntax

1056
00:36:28,160 --> 00:36:30,879
slightly different so

1057
00:36:29,359 --> 00:36:33,598
of course it has to be parenthesized the

1058
00:36:30,880 --> 00:36:35,839
operator has to be in front

1059
00:36:33,599 --> 00:36:38,480
so might look like this and i'm going to

1060
00:36:35,839 --> 00:36:39,440
use colon equals to avoid confusion with

1061
00:36:38,480 --> 00:36:42,240
the

1062
00:36:39,440 --> 00:36:43,920
with the equal sign without a colon

1063
00:36:42,240 --> 00:36:47,680
which is the equality

1064
00:36:43,920 --> 00:36:50,800
operator okay so we'll just use the same

1065
00:36:47,680 --> 00:36:51,598
technique that we used before so i'm

1066
00:36:50,800 --> 00:36:53,040
going to

1067
00:36:51,599 --> 00:36:55,040
just like go to right needs to be a

1068
00:36:53,040 --> 00:36:57,359
literal we want

1069
00:36:55,040 --> 00:36:58,480
another case to match only when there's

1070
00:36:57,359 --> 00:37:00,960
an actual

1071
00:36:58,480 --> 00:37:02,480
colon equal sign there well here's a

1072
00:37:00,960 --> 00:37:04,000
variable

1073
00:37:02,480 --> 00:37:06,079
and that has to be an identifier that's

1074
00:37:04,000 --> 00:37:07,440
how we talk tell syntax parts there

1075
00:37:06,079 --> 00:37:08,000
needs to be an identifier and then

1076
00:37:07,440 --> 00:37:10,800
there's a right

1077
00:37:08,000 --> 00:37:11,520
hand side which can be any expression

1078
00:37:10,800 --> 00:37:15,599
that

1079
00:37:11,520 --> 00:37:17,359
we want okay so got this here

1080
00:37:15,599 --> 00:37:19,359
and now we just need to generate a piece

1081
00:37:17,359 --> 00:37:22,960
of code that works with it right

1082
00:37:19,359 --> 00:37:25,040
and in uh in racket variable assignment

1083
00:37:22,960 --> 00:37:27,359
happens with an operator that's called

1084
00:37:25,040 --> 00:37:28,480
setbang so the exclamation mark is

1085
00:37:27,359 --> 00:37:30,160
pronounced bang

1086
00:37:28,480 --> 00:37:31,599
to denote that there is an evil side

1087
00:37:30,160 --> 00:37:33,839
effect happening here

1088
00:37:31,599 --> 00:37:35,200
so uh and we can just use these two

1089
00:37:33,839 --> 00:37:38,400
pattern variables we can just

1090
00:37:35,200 --> 00:37:41,919
reuse the right hand side here and

1091
00:37:38,400 --> 00:37:44,079
ah okay well remember that trick that we

1092
00:37:41,920 --> 00:37:46,000
needed here with go to we need it with

1093
00:37:44,079 --> 00:37:47,839
colon equals two so we need to provide a

1094
00:37:46,000 --> 00:37:51,280
dummy definition

1095
00:37:47,839 --> 00:37:54,480
and now well here's a little problem

1096
00:37:51,280 --> 00:37:57,200
right it says a is an

1097
00:37:54,480 --> 00:37:58,720
unbound identifier down here and that's

1098
00:37:57,200 --> 00:38:02,720
because

1099
00:37:58,720 --> 00:38:04,000
well racket distinguishes between

1100
00:38:02,720 --> 00:38:05,759
binding an identifier so you're

1101
00:38:04,000 --> 00:38:06,880
establishing that the identifier exists

1102
00:38:05,760 --> 00:38:08,720
and then changing

1103
00:38:06,880 --> 00:38:10,560
uh the value and the storage cell

1104
00:38:08,720 --> 00:38:12,720
associated with that identifier those

1105
00:38:10,560 --> 00:38:14,400
are two separate things right and

1106
00:38:12,720 --> 00:38:16,799
so we could make that error message go

1107
00:38:14,400 --> 00:38:20,000
away by saying you know define a to some

1108
00:38:16,800 --> 00:38:21,119
dummy value but then of course that's no

1109
00:38:20,000 --> 00:38:24,480
longer basic

1110
00:38:21,119 --> 00:38:25,920
right it's um if we would need that

1111
00:38:24,480 --> 00:38:27,200
additional definition in basic we can

1112
00:38:25,920 --> 00:38:29,520
just introduce

1113
00:38:27,200 --> 00:38:30,720
an identifier by doing an assignment to

1114
00:38:29,520 --> 00:38:33,920
it so somehow

1115
00:38:30,720 --> 00:38:35,680
we need to generate the set of variables

1116
00:38:33,920 --> 00:38:38,400
that appear in assignments and make sure

1117
00:38:35,680 --> 00:38:39,759
that we also

1118
00:38:38,400 --> 00:38:41,440
generate definitions for those

1119
00:38:39,760 --> 00:38:43,359
identifiers dummy definitions at the

1120
00:38:41,440 --> 00:38:45,200
beginning

1121
00:38:43,359 --> 00:38:46,720
so well we need to generate those

1122
00:38:45,200 --> 00:38:48,319
definitions and for generating those

1123
00:38:46,720 --> 00:38:51,279
definitions we need the set

1124
00:38:48,320 --> 00:38:52,560
of variables that are uh in a program

1125
00:38:51,280 --> 00:38:55,520
we'll start by just collecting the

1126
00:38:52,560 --> 00:38:58,720
variables that are in a single command

1127
00:38:55,520 --> 00:39:01,040
and to that end i'm just going to uh

1128
00:38:58,720 --> 00:39:02,879
define a new function here i'm going to

1129
00:39:01,040 --> 00:39:05,440
call that collect

1130
00:39:02,880 --> 00:39:06,480
variables and i'm going to pass in the

1131
00:39:05,440 --> 00:39:09,839
command

1132
00:39:06,480 --> 00:39:12,640
okay and well not just the command but

1133
00:39:09,839 --> 00:39:13,200
we will want to collect a list or rather

1134
00:39:12,640 --> 00:39:14,960
a set

1135
00:39:13,200 --> 00:39:16,799
of those variables because of course a

1136
00:39:14,960 --> 00:39:18,720
variable might occur in several

1137
00:39:16,800 --> 00:39:20,240
assignments so we will use something

1138
00:39:18,720 --> 00:39:23,439
called an id

1139
00:39:20,240 --> 00:39:25,598
set and we'll define that in a minute

1140
00:39:23,440 --> 00:39:27,119
so racket comes with a library that

1141
00:39:25,599 --> 00:39:30,400
allows you to manage

1142
00:39:27,119 --> 00:39:33,839
sets of these identifiers and we will

1143
00:39:30,400 --> 00:39:36,880
need to import that library up here

1144
00:39:33,839 --> 00:39:38,240
so call that syntax that's called syntax

1145
00:39:36,880 --> 00:39:41,520
it set

1146
00:39:38,240 --> 00:39:45,118
and that allows us to

1147
00:39:41,520 --> 00:39:47,040
deal with those sets okay and

1148
00:39:45,119 --> 00:39:48,160
of course we need to look inside those

1149
00:39:47,040 --> 00:39:50,320
commands

1150
00:39:48,160 --> 00:39:52,160
so we're just going to use the same

1151
00:39:50,320 --> 00:39:53,520
syntax part essentially the same syntax

1152
00:39:52,160 --> 00:39:56,799
parts that we had up here

1153
00:39:53,520 --> 00:39:57,680
right so we have various uh literals

1154
00:39:56,800 --> 00:39:59,200
here

1155
00:39:57,680 --> 00:40:01,279
with go to of course there can't be any

1156
00:39:59,200 --> 00:40:02,560
variables uh introduced by go to we're

1157
00:40:01,280 --> 00:40:06,160
mainly interested

1158
00:40:02,560 --> 00:40:08,240
in the clause that has to do with

1159
00:40:06,160 --> 00:40:11,598
assignments

1160
00:40:08,240 --> 00:40:13,680
and um well how does that work

1161
00:40:11,599 --> 00:40:14,960
so in that case what we need to do is we

1162
00:40:13,680 --> 00:40:19,040
need to say

1163
00:40:14,960 --> 00:40:22,160
uh free it's set at

1164
00:40:19,040 --> 00:40:25,680
and uh call it set and

1165
00:40:22,160 --> 00:40:27,920
add variable here

1166
00:40:25,680 --> 00:40:29,440
and anything else well we're not going

1167
00:40:27,920 --> 00:40:30,160
to do anything i'm just going to call

1168
00:40:29,440 --> 00:40:31,839
void

1169
00:40:30,160 --> 00:40:34,480
the function the built-in function that

1170
00:40:31,839 --> 00:40:38,640
doesn't do anything

1171
00:40:34,480 --> 00:40:40,560
okay okay and now we need to call that

1172
00:40:38,640 --> 00:40:42,400
function collect variables

1173
00:40:40,560 --> 00:40:43,920
for each command and we need to do that

1174
00:40:42,400 --> 00:40:46,319
up here from

1175
00:40:43,920 --> 00:40:47,440
the basic form right where we have all

1176
00:40:46,319 --> 00:40:49,440
the commands at our

1177
00:40:47,440 --> 00:40:51,280
disposal so first of all we need to

1178
00:40:49,440 --> 00:40:52,240
create an empty it set that we can add

1179
00:40:51,280 --> 00:40:55,359
to

1180
00:40:52,240 --> 00:40:57,598
call that it set and so

1181
00:40:55,359 --> 00:40:59,520
we're gonna call a function it's got a

1182
00:40:57,599 --> 00:41:02,880
cumbersome name mutable

1183
00:40:59,520 --> 00:41:05,359
it's set oh and not just that mutable

1184
00:41:02,880 --> 00:41:07,599
free it said because again racket makes

1185
00:41:05,359 --> 00:41:09,040
a subtle distinction between

1186
00:41:07,599 --> 00:41:11,920
identifiers depending on whether they're

1187
00:41:09,040 --> 00:41:14,960
free or bound don't worry about that

1188
00:41:11,920 --> 00:41:18,400
this this is going to work and

1189
00:41:14,960 --> 00:41:21,599
then what we do is well we want to call

1190
00:41:18,400 --> 00:41:24,000
collect variables

1191
00:41:21,599 --> 00:41:24,640
on each command and passing in that it

1192
00:41:24,000 --> 00:41:26,160
set

1193
00:41:24,640 --> 00:41:28,319
and but remember we don't just have a

1194
00:41:26,160 --> 00:41:29,200
single command we have a whole list of

1195
00:41:28,319 --> 00:41:33,040
them

1196
00:41:29,200 --> 00:41:35,520
and so we need to do this well um

1197
00:41:33,040 --> 00:41:36,960
we take that command dot dot and of

1198
00:41:35,520 --> 00:41:39,200
course need to wrap that hash

1199
00:41:36,960 --> 00:41:40,960
backward around it convert that into a

1200
00:41:39,200 --> 00:41:43,520
list we've done that before

1201
00:41:40,960 --> 00:41:44,640
and then we can use a built-in function

1202
00:41:43,520 --> 00:41:48,960
called for each

1203
00:41:44,640 --> 00:41:51,118
which just calls um

1204
00:41:48,960 --> 00:41:52,960
this function on every argument on every

1205
00:41:51,119 --> 00:41:54,319
element of that list right it's sort of

1206
00:41:52,960 --> 00:41:55,760
like map but

1207
00:41:54,319 --> 00:41:57,200
that returns your list of the result

1208
00:41:55,760 --> 00:41:59,280
whereas for each just doesn't bother

1209
00:41:57,200 --> 00:42:02,319
with the results and throws them away

1210
00:41:59,280 --> 00:42:05,440
so now we have a set of

1211
00:42:02,319 --> 00:42:06,720
identifiers we just need to generate

1212
00:42:05,440 --> 00:42:08,160
definitions from it and these

1213
00:42:06,720 --> 00:42:11,040
definitions need to go

1214
00:42:08,160 --> 00:42:12,640
here right before the actual code for

1215
00:42:11,040 --> 00:42:15,759
the basic program

1216
00:42:12,640 --> 00:42:19,279
so again we can use map right

1217
00:42:15,760 --> 00:42:20,400
to map all over all the variables we'll

1218
00:42:19,280 --> 00:42:22,400
figure out in a moment what we're going

1219
00:42:20,400 --> 00:42:24,480
to do with those and

1220
00:42:22,400 --> 00:42:26,079
uh well we'd like to map over its set

1221
00:42:24,480 --> 00:42:27,359
unfortunately it's set is not a list and

1222
00:42:26,079 --> 00:42:29,680
map wants a list

1223
00:42:27,359 --> 00:42:30,880
so we are going to use a function called

1224
00:42:29,680 --> 00:42:34,078
free it's set

1225
00:42:30,880 --> 00:42:36,319
to list to make it a list

1226
00:42:34,079 --> 00:42:38,240
right and so for each variable we want

1227
00:42:36,319 --> 00:42:39,920
to generate a dummy definition again we

1228
00:42:38,240 --> 00:42:42,720
need to generate a piece of syntax

1229
00:42:39,920 --> 00:42:44,240
says define we stick that variable in

1230
00:42:42,720 --> 00:42:47,598
and we'll just define it to

1231
00:42:44,240 --> 00:42:49,520
false to make sure that things

1232
00:42:47,599 --> 00:42:51,359
don't get mixed up with regular basic

1233
00:42:49,520 --> 00:42:53,040
values okay

1234
00:42:51,359 --> 00:42:54,400
now remember again i mean you can see

1235
00:42:53,040 --> 00:42:55,920
here the other called a map

1236
00:42:54,400 --> 00:42:58,160
right we want to make sure that this

1237
00:42:55,920 --> 00:43:01,760
gets spliced into

1238
00:42:58,160 --> 00:43:02,799
that form here so again i call that i

1239
00:43:01,760 --> 00:43:05,920
use that same

1240
00:43:02,800 --> 00:43:09,280
funny magic thing here hash comma at

1241
00:43:05,920 --> 00:43:12,800
which splices all those definitions into

1242
00:43:09,280 --> 00:43:15,359
that begin form okay well

1243
00:43:12,800 --> 00:43:16,880
let's see if that works and now it says

1244
00:43:15,359 --> 00:43:18,160
ah that variable is already defined

1245
00:43:16,880 --> 00:43:19,599
that's a good sign because

1246
00:43:18,160 --> 00:43:21,118
you can't have several definitions for

1247
00:43:19,599 --> 00:43:23,520
single variables and we put one in

1248
00:43:21,119 --> 00:43:27,440
ourselves so i'm going to delete that

1249
00:43:23,520 --> 00:43:28,640
and um okay and now we can see that

1250
00:43:27,440 --> 00:43:30,400
there's a variable here

1251
00:43:28,640 --> 00:43:32,400
right it's bound to false as it should

1252
00:43:30,400 --> 00:43:35,440
be and let's try

1253
00:43:32,400 --> 00:43:38,640
running the program uh well

1254
00:43:35,440 --> 00:43:40,000
not much happens why is that right why

1255
00:43:38,640 --> 00:43:41,359
does the program

1256
00:43:40,000 --> 00:43:43,680
not produce anything well we could look

1257
00:43:41,359 --> 00:43:46,078
at a a is now 42.

1258
00:43:43,680 --> 00:43:47,759
let's see let's go up here and we can

1259
00:43:46,079 --> 00:43:50,640
see here the translation

1260
00:43:47,760 --> 00:43:52,240
of colon equals and you see you can see

1261
00:43:50,640 --> 00:43:54,078
i forgot something

1262
00:43:52,240 --> 00:43:55,598
this just sets the variable but it does

1263
00:43:54,079 --> 00:43:58,640
not go on with

1264
00:43:55,599 --> 00:43:58,640
the program as

1265
00:43:58,880 --> 00:44:02,240
the rest does we need to put a begin

1266
00:44:00,880 --> 00:44:05,280
here and then put in

1267
00:44:02,240 --> 00:44:08,879
the call to the next line

1268
00:44:05,280 --> 00:44:11,839
see if that works and now line five

1269
00:44:08,880 --> 00:44:13,200
and that actually prints out the value

1270
00:44:11,839 --> 00:44:14,560
of that variable so now we've got

1271
00:44:13,200 --> 00:44:16,160
variables in our program that's

1272
00:44:14,560 --> 00:44:19,279
wonderful

1273
00:44:16,160 --> 00:44:20,399
next up are conditionals in basic so how

1274
00:44:19,280 --> 00:44:22,800
does that work well

1275
00:44:20,400 --> 00:44:24,319
basic has a statement called the if

1276
00:44:22,800 --> 00:44:26,319
statement might look like this right we

1277
00:44:24,319 --> 00:44:27,920
compare a with 42 it's kind of silly we

1278
00:44:26,319 --> 00:44:29,759
know what the result is but just to

1279
00:44:27,920 --> 00:44:31,520
demonstrate the feature and then

1280
00:44:29,760 --> 00:44:32,400
depending on whether that's true or

1281
00:44:31,520 --> 00:44:36,000
false we could

1282
00:44:32,400 --> 00:44:38,000
whatever set b to 1 or set b

1283
00:44:36,000 --> 00:44:39,680
to 2. and we'll just print that out

1284
00:44:38,000 --> 00:44:43,119
along with the a here

1285
00:44:39,680 --> 00:44:43,520
just so we know what came out all right

1286
00:44:43,119 --> 00:44:45,440
well

1287
00:44:43,520 --> 00:44:46,720
we need to translate the if command of

1288
00:44:45,440 --> 00:44:48,319
course

1289
00:44:46,720 --> 00:44:50,319
so we need to go up here into our

1290
00:44:48,319 --> 00:44:52,160
translate command function

1291
00:44:50,319 --> 00:44:53,920
we need to add if here to the list of

1292
00:44:52,160 --> 00:44:57,040
literals so we can recognize

1293
00:44:53,920 --> 00:44:57,599
ifs it looks like this well we have some

1294
00:44:57,040 --> 00:44:59,279
test

1295
00:44:57,599 --> 00:45:01,040
that's an expression we have a then

1296
00:44:59,280 --> 00:45:02,960
branch that's an expression

1297
00:45:01,040 --> 00:45:04,560
and we have an else branch that's an

1298
00:45:02,960 --> 00:45:06,880
expression

1299
00:45:04,560 --> 00:45:08,240
and well we're just going to translate

1300
00:45:06,880 --> 00:45:09,839
it into rackets

1301
00:45:08,240 --> 00:45:12,319
if but we need to make sure that the

1302
00:45:09,839 --> 00:45:16,799
then branch and the else branch also get

1303
00:45:12,319 --> 00:45:18,400
translated so we use hash back quote

1304
00:45:16,800 --> 00:45:20,319
again you know this is not the same if

1305
00:45:18,400 --> 00:45:23,359
as here this is now rackets if

1306
00:45:20,319 --> 00:45:24,160
we're just going to l leave test as it

1307
00:45:23,359 --> 00:45:26,880
is

1308
00:45:24,160 --> 00:45:27,920
and then we call translate command and

1309
00:45:26,880 --> 00:45:29,680
remember we need

1310
00:45:27,920 --> 00:45:31,359
we want the result of translate command

1311
00:45:29,680 --> 00:45:34,399
stuck in there so we need to put

1312
00:45:31,359 --> 00:45:35,839
hash comma in front uh pass in some

1313
00:45:34,400 --> 00:45:38,800
context

1314
00:45:35,839 --> 00:45:40,400
you know again you know we need to pass

1315
00:45:38,800 --> 00:45:42,079
a pattern variable here so we need to

1316
00:45:40,400 --> 00:45:46,319
put hashback quote in front

1317
00:45:42,079 --> 00:45:48,400
and we'll pass call next line as before

1318
00:45:46,319 --> 00:45:52,079
and do the same thing here translate

1319
00:45:48,400 --> 00:45:52,079
command context

1320
00:45:53,359 --> 00:46:00,880
and call call next

1321
00:45:56,560 --> 00:46:02,400
line okay well let's try running it

1322
00:46:00,880 --> 00:46:04,640
that doesn't work right we get an error

1323
00:46:02,400 --> 00:46:07,119
message says b is unbound why is that

1324
00:46:04,640 --> 00:46:08,640
well we're generating definitions for

1325
00:46:07,119 --> 00:46:11,680
all the variables that occur

1326
00:46:08,640 --> 00:46:12,560
but we um but so far we're only looking

1327
00:46:11,680 --> 00:46:14,240
at

1328
00:46:12,560 --> 00:46:15,920
assignments that occur at the top level

1329
00:46:14,240 --> 00:46:17,200
we're not looking inside and if so we

1330
00:46:15,920 --> 00:46:19,040
need to make sure that we

1331
00:46:17,200 --> 00:46:20,960
also extend collect variables in the

1332
00:46:19,040 --> 00:46:23,759
same way that we extended

1333
00:46:20,960 --> 00:46:26,079
translate command so we also need to add

1334
00:46:23,760 --> 00:46:28,000
that to the list of

1335
00:46:26,079 --> 00:46:31,200
literals here and just put the same we

1336
00:46:28,000 --> 00:46:34,720
can just copy the pattern from up here

1337
00:46:31,200 --> 00:46:35,439
copy that here and uh well we just need

1338
00:46:34,720 --> 00:46:38,078
to call

1339
00:46:35,440 --> 00:46:38,720
collect variables recursively on the two

1340
00:46:38,079 --> 00:46:42,319
branches

1341
00:46:38,720 --> 00:46:45,839
right so we call collect variables on

1342
00:46:42,319 --> 00:46:49,040
uh then with the it's set

1343
00:46:45,839 --> 00:46:52,319
and we call collect variables with

1344
00:46:49,040 --> 00:46:54,400
the else on the midset

1345
00:46:52,319 --> 00:46:56,720
well let's see if it gets any better

1346
00:46:54,400 --> 00:46:59,920
well at least it doesn't error out

1347
00:46:56,720 --> 00:47:01,919
uh let's show up our program again we

1348
00:46:59,920 --> 00:47:03,599
could call it starting at line number

1349
00:47:01,920 --> 00:47:07,200
five

1350
00:47:03,599 --> 00:47:09,119
and oh that's not bad so we now see the

1351
00:47:07,200 --> 00:47:10,879
it says princeton number one which comes

1352
00:47:09,119 --> 00:47:14,400
from this assignment here

1353
00:47:10,880 --> 00:47:16,720
right and so b is assigned to one if a

1354
00:47:14,400 --> 00:47:20,000
is 42 when a is indeed 42.

1355
00:47:16,720 --> 00:47:23,520
we could also kind of set it to 41.

1356
00:47:20,000 --> 00:47:24,160
try that again line 5 and we see that it

1357
00:47:23,520 --> 00:47:26,400
now

1358
00:47:24,160 --> 00:47:27,520
prints a2 because the branch went the

1359
00:47:26,400 --> 00:47:31,040
other way i'll just

1360
00:47:27,520 --> 00:47:34,800
change that back and save

1361
00:47:31,040 --> 00:47:36,480
great so we'll add one more feature

1362
00:47:34,800 --> 00:47:38,240
that's actually not just one command but

1363
00:47:36,480 --> 00:47:39,280
we'll need three commands and that is

1364
00:47:38,240 --> 00:47:42,640
basic

1365
00:47:39,280 --> 00:47:44,880
sub routines um so well how

1366
00:47:42,640 --> 00:47:46,240
what could that look like for example in

1367
00:47:44,880 --> 00:47:48,079
line 1000

1368
00:47:46,240 --> 00:47:49,520
we could say we're just going to print

1369
00:47:48,079 --> 00:47:53,280
the b variable

1370
00:47:49,520 --> 00:47:56,400
and then in line 1010 we just put

1371
00:47:53,280 --> 00:47:57,839
a return statement so applisoft basic

1372
00:47:56,400 --> 00:47:59,119
doesn't have functions in the way that

1373
00:47:57,839 --> 00:48:02,160
we know them

1374
00:47:59,119 --> 00:48:05,920
or methods it just has these subroutines

1375
00:48:02,160 --> 00:48:07,118
and so we could call we could output b

1376
00:48:05,920 --> 00:48:09,359
by just saying

1377
00:48:07,119 --> 00:48:10,319
you know whatever line ate here and we

1378
00:48:09,359 --> 00:48:14,240
could say go

1379
00:48:10,319 --> 00:48:16,640
sub line 1000 like this

1380
00:48:14,240 --> 00:48:17,839
and the idea is then that it will go and

1381
00:48:16,640 --> 00:48:20,960
print b

1382
00:48:17,839 --> 00:48:23,520
right and um

1383
00:48:20,960 --> 00:48:24,480
and return and go on after that with

1384
00:48:23,520 --> 00:48:26,319
hello world

1385
00:48:24,480 --> 00:48:28,160
and and whatnot we could also call it

1386
00:48:26,319 --> 00:48:31,200
several times of course

1387
00:48:28,160 --> 00:48:33,279
um okay

1388
00:48:31,200 --> 00:48:35,520
and yeah we'll just leave it like that

1389
00:48:33,280 --> 00:48:38,319
two commands okay so go sub

1390
00:48:35,520 --> 00:48:39,440
and return what should we do well we go

1391
00:48:38,319 --> 00:48:41,279
up here

1392
00:48:39,440 --> 00:48:43,839
and obviously we need to do something

1393
00:48:41,280 --> 00:48:47,200
with translate command we will just add

1394
00:48:43,839 --> 00:48:48,480
go sub and return and these are not

1395
00:48:47,200 --> 00:48:51,359
built into racket so

1396
00:48:48,480 --> 00:48:54,079
we need to have those up false dummy

1397
00:48:51,359 --> 00:48:58,078
definitions for them

1398
00:48:54,079 --> 00:49:00,160
uh to do that and so how does that work

1399
00:48:58,079 --> 00:49:01,520
well gosub is kind of like go to except

1400
00:49:00,160 --> 00:49:04,720
the program goes on

1401
00:49:01,520 --> 00:49:06,800
right so well there's go sub i number

1402
00:49:04,720 --> 00:49:09,359
which is an integer

1403
00:49:06,800 --> 00:49:10,319
and of course well we need to generate a

1404
00:49:09,359 --> 00:49:13,759
call

1405
00:49:10,319 --> 00:49:15,839
just as we do with go to right

1406
00:49:13,760 --> 00:49:18,000
so i'm going to put well i'm just going

1407
00:49:15,839 --> 00:49:19,920
to duplicate that from up here

1408
00:49:18,000 --> 00:49:22,079
and the only difference is after that

1409
00:49:19,920 --> 00:49:26,480
call is done

1410
00:49:22,079 --> 00:49:26,480
right when that finishes then

1411
00:49:26,559 --> 00:49:31,599
after that is done we need to

1412
00:49:30,079 --> 00:49:32,960
continue with the next line

1413
00:49:31,599 --> 00:49:34,559
unfortunately we know how to do that

1414
00:49:32,960 --> 00:49:35,280
because we've got the call to the next

1415
00:49:34,559 --> 00:49:38,319
line

1416
00:49:35,280 --> 00:49:40,800
sitting up here so i just stick

1417
00:49:38,319 --> 00:49:41,839
call next line here so that's the only

1418
00:49:40,800 --> 00:49:45,040
difference between

1419
00:49:41,839 --> 00:49:46,720
go to and go sub and of course we also

1420
00:49:45,040 --> 00:49:49,759
need to implement return

1421
00:49:46,720 --> 00:49:52,640
and well what happens with return

1422
00:49:49,760 --> 00:49:52,960
with return nothing happens also return

1423
00:49:52,640 --> 00:49:54,720
is

1424
00:49:52,960 --> 00:49:56,000
similar to go to and goes up in that it

1425
00:49:54,720 --> 00:49:57,040
doesn't go to the next line it just

1426
00:49:56,000 --> 00:49:59,280
returns

1427
00:49:57,040 --> 00:50:01,119
and when there's an active go to it will

1428
00:49:59,280 --> 00:50:04,400
just

1429
00:50:01,119 --> 00:50:07,680
go back to the line after that it will

1430
00:50:04,400 --> 00:50:10,800
go to that call to call next line here

1431
00:50:07,680 --> 00:50:10,799
let's see if that works

1432
00:50:10,880 --> 00:50:15,119
okay so at least we don't get an error

1433
00:50:12,880 --> 00:50:17,760
message line five

1434
00:50:15,119 --> 00:50:20,160
and well how do we interpret that output

1435
00:50:17,760 --> 00:50:22,640
i kind of forgot what the program was

1436
00:50:20,160 --> 00:50:24,879
well here it said go sub 1000 it printed

1437
00:50:22,640 --> 00:50:28,240
b and then it went on with the program

1438
00:50:24,880 --> 00:50:30,160
as before arguably the program should

1439
00:50:28,240 --> 00:50:31,839
finish here after line 40 and before

1440
00:50:30,160 --> 00:50:34,399
line 1000 but i'll

1441
00:50:31,839 --> 00:50:36,640
leave that for you as an exercise to

1442
00:50:34,400 --> 00:50:38,480
implement

1443
00:50:36,640 --> 00:50:40,558
so now we have enough basic there to at

1444
00:50:38,480 --> 00:50:42,000
least give us a fair idea

1445
00:50:40,559 --> 00:50:43,680
of how to do this whole thing and maybe

1446
00:50:42,000 --> 00:50:44,720
how to add the rest and i promise that

1447
00:50:43,680 --> 00:50:46,480
we would also get

1448
00:50:44,720 --> 00:50:48,720
actual basic syntax and we only have a

1449
00:50:46,480 --> 00:50:50,240
few minutes left so let's get to it in

1450
00:50:48,720 --> 00:50:51,759
order to do that we need to make sure

1451
00:50:50,240 --> 00:50:53,118
that the functionality that we've

1452
00:50:51,760 --> 00:50:55,599
implemented in this file

1453
00:50:53,119 --> 00:50:57,200
is available in other files and so we

1454
00:50:55,599 --> 00:50:59,680
need to

1455
00:50:57,200 --> 00:51:00,879
add what's called a provide form that's

1456
00:50:59,680 --> 00:51:03,040
like an export or

1457
00:51:00,880 --> 00:51:04,800
public annotation or something like that

1458
00:51:03,040 --> 00:51:06,240
and we just need to provide the basic

1459
00:51:04,800 --> 00:51:08,720
form that we implemented the print

1460
00:51:06,240 --> 00:51:10,319
command that we implemented go to

1461
00:51:08,720 --> 00:51:12,240
you know all those things that we added

1462
00:51:10,319 --> 00:51:15,839
to implement our

1463
00:51:12,240 --> 00:51:17,839
basic syntax return there we go and save

1464
00:51:15,839 --> 00:51:20,078
that file and then we're done with that

1465
00:51:17,839 --> 00:51:22,480
part

1466
00:51:20,079 --> 00:51:23,599
now for the actual basic syntax there's

1467
00:51:22,480 --> 00:51:25,520
no way around writing

1468
00:51:23,599 --> 00:51:26,800
a proper parser and we don't have nearly

1469
00:51:25,520 --> 00:51:28,400
enough time to do that it's

1470
00:51:26,800 --> 00:51:31,119
not that hard but it takes a little bit

1471
00:51:28,400 --> 00:51:32,640
of time so i've prepared the code to do

1472
00:51:31,119 --> 00:51:35,880
that it's just called

1473
00:51:32,640 --> 00:51:37,440
a reader so here's a file called basic

1474
00:51:35,880 --> 00:51:39,680
reader.racket

1475
00:51:37,440 --> 00:51:41,040
and if i run that well you can see here

1476
00:51:39,680 --> 00:51:41,919
for example there's a function called

1477
00:51:41,040 --> 00:51:43,359
parseline

1478
00:51:41,920 --> 00:51:45,839
it takes two arguments one of them is

1479
00:51:43,359 --> 00:51:46,799
called zertz um that's just context

1480
00:51:45,839 --> 00:51:48,960
information about

1481
00:51:46,800 --> 00:51:51,440
what file this code resides in and so on

1482
00:51:48,960 --> 00:51:53,920
i'm just going to pass false here

1483
00:51:51,440 --> 00:51:55,040
later that value will be provided by the

1484
00:51:53,920 --> 00:51:57,359
racket system

1485
00:51:55,040 --> 00:51:59,040
and the other argument is an input port

1486
00:51:57,359 --> 00:52:01,440
which is just a reference

1487
00:51:59,040 --> 00:52:03,119
to an open file or something like that

1488
00:52:01,440 --> 00:52:04,000
but we can also use a string by just

1489
00:52:03,119 --> 00:52:06,240
saying open input

1490
00:52:04,000 --> 00:52:08,319
string here so if i say you know 10

1491
00:52:06,240 --> 00:52:09,759
print a plus 1

1492
00:52:08,319 --> 00:52:11,839
and call that function you can see that

1493
00:52:09,760 --> 00:52:14,960
it returns list structure

1494
00:52:11,839 --> 00:52:16,720
that corresponds exactly to

1495
00:52:14,960 --> 00:52:18,640
you know the syntax that we the

1496
00:52:16,720 --> 00:52:19,439
parenthesis syntax that we implemented

1497
00:52:18,640 --> 00:52:21,520
earlier

1498
00:52:19,440 --> 00:52:23,040
we just need to hook this up to the rest

1499
00:52:21,520 --> 00:52:24,720
of the racket system and for that we

1500
00:52:23,040 --> 00:52:25,279
need to write a little boilerplate

1501
00:52:24,720 --> 00:52:29,439
function

1502
00:52:25,280 --> 00:52:31,040
i'm going to call that basic read syntax

1503
00:52:29,440 --> 00:52:32,480
it also takes deserts and an inner

1504
00:52:31,040 --> 00:52:34,720
argument and that

1505
00:52:32,480 --> 00:52:36,400
function calls powers program which does

1506
00:52:34,720 --> 00:52:38,000
the same thing as power's line but for

1507
00:52:36,400 --> 00:52:41,680
an entire program

1508
00:52:38,000 --> 00:52:43,440
uh do this and we want to embed the

1509
00:52:41,680 --> 00:52:46,240
result of that

1510
00:52:43,440 --> 00:52:47,119
in something that racket will later

1511
00:52:46,240 --> 00:52:50,078
understand

1512
00:52:47,119 --> 00:52:51,760
so to that and we need to create a

1513
00:52:50,079 --> 00:52:54,079
module declaration for racket

1514
00:52:51,760 --> 00:52:56,640
i'm just going to call that module basic

1515
00:52:54,079 --> 00:52:58,880
my name doesn't particularly matter

1516
00:52:56,640 --> 00:53:01,040
it imports the racket language and it

1517
00:52:58,880 --> 00:53:02,480
also requires so it imports

1518
00:53:01,040 --> 00:53:04,160
the code that we've just written which

1519
00:53:02,480 --> 00:53:07,599
is in the racket.arc

1520
00:53:04,160 --> 00:53:10,000
kt file and

1521
00:53:07,599 --> 00:53:11,760
now here's the result of parsing the

1522
00:53:10,000 --> 00:53:14,800
program we still need to put a

1523
00:53:11,760 --> 00:53:16,160
basic form around it and splice in the

1524
00:53:14,800 --> 00:53:18,880
result of parsing

1525
00:53:16,160 --> 00:53:20,078
the program so that's that now you might

1526
00:53:18,880 --> 00:53:22,559
have noticed that

1527
00:53:20,079 --> 00:53:24,240
the back quote up here and the comma add

1528
00:53:22,559 --> 00:53:25,680
here doesn't have a hash with it

1529
00:53:24,240 --> 00:53:27,520
it doesn't create syntax structure it

1530
00:53:25,680 --> 00:53:29,759
just creates an ordinary

1531
00:53:27,520 --> 00:53:30,960
racket list structure we still need to

1532
00:53:29,760 --> 00:53:33,359
convert it to

1533
00:53:30,960 --> 00:53:35,760
a syntax object and for that we use a

1534
00:53:33,359 --> 00:53:39,598
function called datum to syntax

1535
00:53:35,760 --> 00:53:41,119
and just pass false here for the context

1536
00:53:39,599 --> 00:53:43,520
that's enough make sure that all the

1537
00:53:41,119 --> 00:53:46,240
parentheses line up and

1538
00:53:43,520 --> 00:53:48,559
then we're good to go well almost good

1539
00:53:46,240 --> 00:53:51,759
to go we still need to export this

1540
00:53:48,559 --> 00:53:53,760
function and we need to have a different

1541
00:53:51,760 --> 00:53:55,280
slightly different name for it we're

1542
00:53:53,760 --> 00:53:57,839
just going to call it

1543
00:53:55,280 --> 00:53:58,400
read syntax on export and that's a magic

1544
00:53:57,839 --> 00:54:01,839
name

1545
00:53:58,400 --> 00:54:04,960
that racket will later recognize

1546
00:54:01,839 --> 00:54:08,078
so i'll save that file and then we

1547
00:54:04,960 --> 00:54:08,079
are good to go

1548
00:54:08,480 --> 00:54:12,160
so in order to try this out i've

1549
00:54:10,319 --> 00:54:14,720
prepared another little example file

1550
00:54:12,160 --> 00:54:16,000
called basic demo syntax dot rkt

1551
00:54:14,720 --> 00:54:17,839
this is what it looks like and you can

1552
00:54:16,000 --> 00:54:18,960
see the hash line lang line up here

1553
00:54:17,839 --> 00:54:21,119
declares that

1554
00:54:18,960 --> 00:54:22,160
we want to use the reader that we just

1555
00:54:21,119 --> 00:54:25,119
implemented

1556
00:54:22,160 --> 00:54:25,759
basic reader dot and what follows is a

1557
00:54:25,119 --> 00:54:28,880
very much

1558
00:54:25,760 --> 00:54:29,280
apple soft looking program and uh well i

1559
00:54:28,880 --> 00:54:32,160
can

1560
00:54:29,280 --> 00:54:33,599
run that by just typing line 10 like we

1561
00:54:32,160 --> 00:54:36,319
used to do that and we can see

1562
00:54:33,599 --> 00:54:38,400
that it pretty much works so there you

1563
00:54:36,319 --> 00:54:39,279
have it i mean applesoft is just about

1564
00:54:38,400 --> 00:54:42,000
as different from

1565
00:54:39,280 --> 00:54:42,880
usual racket as it can be so if you can

1566
00:54:42,000 --> 00:54:44,799
do that

1567
00:54:42,880 --> 00:54:47,119
then you can implement just about any

1568
00:54:44,799 --> 00:54:48,720
language you like with the racket system

1569
00:54:47,119 --> 00:54:50,839
and it's not just for toy stuff it's a

1570
00:54:48,720 --> 00:54:52,078
great tool for organizing your software

1571
00:54:50,839 --> 00:54:54,240
architecture

1572
00:54:52,079 --> 00:54:55,599
for just generally generating a pleasant

1573
00:54:54,240 --> 00:54:57,118
notation

1574
00:54:55,599 --> 00:54:58,720
for doing things like documentation in

1575
00:54:57,119 --> 00:55:00,559
the racket system there's lots of

1576
00:54:58,720 --> 00:55:01,598
publications and lots of examples on

1577
00:55:00,559 --> 00:55:03,440
that

1578
00:55:01,599 --> 00:55:05,200
and of course we've implemented the same

1579
00:55:03,440 --> 00:55:06,000
we've used the same machinery to also

1580
00:55:05,200 --> 00:55:08,960
implement

1581
00:55:06,000 --> 00:55:09,680
teaching languages and iterate quickly

1582
00:55:08,960 --> 00:55:11,760
improving

1583
00:55:09,680 --> 00:55:13,919
those languages so i hope this has

1584
00:55:11,760 --> 00:55:17,280
motivated you to try out

1585
00:55:13,920 --> 00:55:19,680
the racket system again please

1586
00:55:17,280 --> 00:55:21,200
check out the github repository if you

1587
00:55:19,680 --> 00:55:23,118
want to look at the code or send me

1588
00:55:21,200 --> 00:55:24,799
email or contact me some other ways

1589
00:55:23,119 --> 00:55:26,880
if you're interested in this stuff and

1590
00:55:24,799 --> 00:55:29,200
i'm looking forward to your question

1591
00:55:26,880 --> 00:55:31,680
and a little bit of discussion we'll see

1592
00:55:29,200 --> 00:55:31,680
thank you

1593
00:55:33,680 --> 00:55:40,640
thank you very much uh mike for the

1594
00:55:36,960 --> 00:55:44,319
talk and to for introducing us to

1595
00:55:40,640 --> 00:55:47,359
racket uh and

1596
00:55:44,319 --> 00:55:51,759
to show us how to implement a

1597
00:55:47,359 --> 00:55:52,319
language there i already saw there was

1598
00:55:51,760 --> 00:55:55,040
already

1599
00:55:52,319 --> 00:55:55,920
quite some discussion in the chat but we

1600
00:55:55,040 --> 00:55:59,839
have

1601
00:55:55,920 --> 00:56:05,920
still some questions for everyone

1602
00:55:59,839 --> 00:56:05,920
and uh we start with a question from

1603
00:56:06,640 --> 00:56:13,200
from someone and

1604
00:56:09,839 --> 00:56:16,319
and the question is why you use these

1605
00:56:13,200 --> 00:56:19,839
macros instead of simple functions uh

1606
00:56:16,319 --> 00:56:25,040
because he thinks you can also use

1607
00:56:19,839 --> 00:56:26,799
just functions to and to produce print

1608
00:56:25,040 --> 00:56:28,720
yeah so that question was asked just

1609
00:56:26,799 --> 00:56:30,000
after i introduced print right so it

1610
00:56:28,720 --> 00:56:31,759
doesn't refer to all the rest that we

1611
00:56:30,000 --> 00:56:35,280
did there and indeed print

1612
00:56:31,760 --> 00:56:37,119
could be a simple function um but um

1613
00:56:35,280 --> 00:56:38,480
and indeed there's a lot of things that

1614
00:56:37,119 --> 00:56:39,280
can just be functions that don't need to

1615
00:56:38,480 --> 00:56:42,720
be macros in

1616
00:56:39,280 --> 00:56:43,040
in racket um but and print is one of

1617
00:56:42,720 --> 00:56:44,879
them

1618
00:56:43,040 --> 00:56:47,119
but then i couldn't have used it to demo

1619
00:56:44,880 --> 00:56:48,720
a single a simple macro right the all

1620
00:56:47,119 --> 00:56:49,440
the other macros that i introduced are a

1621
00:56:48,720 --> 00:56:51,279
lot more

1622
00:56:49,440 --> 00:56:54,079
uh complicated so i figured i'd do a

1623
00:56:51,280 --> 00:56:54,079
simple one first

1624
00:56:54,480 --> 00:56:58,880
very good uh let's go on

1625
00:56:59,920 --> 00:57:05,119
they are all the differences between

1626
00:57:02,480 --> 00:57:07,760
bindings and operators

1627
00:57:05,119 --> 00:57:07,760
it would be

1628
00:57:10,240 --> 00:57:16,000
interpreters to quote unquote it would

1629
00:57:12,640 --> 00:57:16,000
be something i would

1630
00:57:16,400 --> 00:57:22,559
uh it would be great if you showed them

1631
00:57:18,799 --> 00:57:24,640
more in detail but that's more common

1632
00:57:22,559 --> 00:57:25,920
yeah um so so it is a little bit

1633
00:57:24,640 --> 00:57:27,520
confusing that there's two kinds of

1634
00:57:25,920 --> 00:57:28,799
variables right and i hope

1635
00:57:27,520 --> 00:57:30,559
throughout the talk there's enough of

1636
00:57:28,799 --> 00:57:31,520
them that you can see what the

1637
00:57:30,559 --> 00:57:34,400
difference is

1638
00:57:31,520 --> 00:57:35,599
the reason for that is in that um this

1639
00:57:34,400 --> 00:57:37,280
is sort of an

1640
00:57:35,599 --> 00:57:39,440
expert level macro system that we're

1641
00:57:37,280 --> 00:57:40,400
using there and the simple macro system

1642
00:57:39,440 --> 00:57:41,920
that's in racket

1643
00:57:40,400 --> 00:57:43,839
um the construct for that is called

1644
00:57:41,920 --> 00:57:45,440
syntax rules knows only

1645
00:57:43,839 --> 00:57:47,359
pattern variables so if you deal only

1646
00:57:45,440 --> 00:57:48,480
with syntax rules then it's very simple

1647
00:57:47,359 --> 00:57:50,160
but if you want to write more

1648
00:57:48,480 --> 00:57:51,040
complicated macros like the ones that we

1649
00:57:50,160 --> 00:57:53,520
did then

1650
00:57:51,040 --> 00:57:54,720
uh you naturally sort of incur both the

1651
00:57:53,520 --> 00:57:56,480
pattern variables and the regular

1652
00:57:54,720 --> 00:57:58,640
variables

1653
00:57:56,480 --> 00:58:00,319
but there's only these two kinds right

1654
00:57:58,640 --> 00:58:03,359
and you get you get the hang of it by

1655
00:58:00,319 --> 00:58:03,359
playing around with it some

1656
00:58:04,559 --> 00:58:13,119
then there's a comment by cinerogenia

1657
00:58:08,319 --> 00:58:16,880
who says all this switching between

1658
00:58:13,119 --> 00:58:17,280
hash back quote and hash kind of reminds

1659
00:58:16,880 --> 00:58:21,200
her

1660
00:58:17,280 --> 00:58:24,559
of existing and entering

1661
00:58:21,200 --> 00:58:27,439
math mode in lattice yeah

1662
00:58:24,559 --> 00:58:29,920
that's that's a that's a great analogy i

1663
00:58:27,440 --> 00:58:31,440
think right in in in latex when you put

1664
00:58:29,920 --> 00:58:32,480
a dollar sign you enter this different

1665
00:58:31,440 --> 00:58:34,240
syntax

1666
00:58:32,480 --> 00:58:35,920
uh this different world there and then

1667
00:58:34,240 --> 00:58:37,839
you can exit that again by writing you

1668
00:58:35,920 --> 00:58:39,680
know backslash text rm or something like

1669
00:58:37,839 --> 00:58:42,319
that that's exactly

1670
00:58:39,680 --> 00:58:44,160
uh that's exactly the same as the same

1671
00:58:42,319 --> 00:58:45,359
idea that you have

1672
00:58:44,160 --> 00:58:47,440
that you have in racket right is that

1673
00:58:45,359 --> 00:58:49,040
you enter the syntax construction mode

1674
00:58:47,440 --> 00:58:50,720
and that you exit it to regular code and

1675
00:58:49,040 --> 00:58:52,799
then you can re-enter it

1676
00:58:50,720 --> 00:58:54,160
so you kind of can pop pop pop push push

1677
00:58:52,799 --> 00:58:55,599
push uh

1678
00:58:54,160 --> 00:58:58,399
you know like the like the infinite

1679
00:58:55,599 --> 00:58:58,400
turtles i guess

1680
00:58:58,720 --> 00:59:04,640
the next question is uh if there is

1681
00:59:01,760 --> 00:59:05,760
if you have control over the runtime of

1682
00:59:04,640 --> 00:59:08,799
your language

1683
00:59:05,760 --> 00:59:08,799
within record

1684
00:59:09,359 --> 00:59:13,279
yeah so i see the question goes on a

1685
00:59:11,200 --> 00:59:14,720
little bit that

1686
00:59:13,280 --> 00:59:17,359
and suggests that memory management

1687
00:59:14,720 --> 00:59:19,279
might be a subject so

1688
00:59:17,359 --> 00:59:21,040
so racket gives you great control over

1689
00:59:19,280 --> 00:59:22,960
the runtime because it has one of the

1690
00:59:21,040 --> 00:59:23,440
most flexible run times in existence it

1691
00:59:22,960 --> 00:59:26,880
might be

1692
00:59:23,440 --> 00:59:28,799
the most flexible uh one in existence

1693
00:59:26,880 --> 00:59:30,000
specifically when it comes to control

1694
00:59:28,799 --> 00:59:32,400
structures

1695
00:59:30,000 --> 00:59:34,400
so so macros is one aspect of the

1696
00:59:32,400 --> 00:59:35,680
flexibility of racket another one

1697
00:59:34,400 --> 00:59:38,000
is that it has something called the

1698
00:59:35,680 --> 00:59:40,480
limited control which allows you to

1699
00:59:38,000 --> 00:59:41,359
um to implement exceptions to implement

1700
00:59:40,480 --> 00:59:42,799
threading

1701
00:59:41,359 --> 00:59:45,920
all kinds of things in terms of the

1702
00:59:42,799 --> 00:59:47,839
primitive constructs of the language

1703
00:59:45,920 --> 00:59:49,599
it does not give you control over memory

1704
00:59:47,839 --> 00:59:51,200
management directly

1705
00:59:49,599 --> 00:59:53,359
you can influence the way that it deals

1706
00:59:51,200 --> 00:59:54,879
with memory a little bit

1707
00:59:53,359 --> 00:59:56,160
it does not give you control whether

1708
00:59:54,880 --> 00:59:57,359
it's interpreted or compiled but if you

1709
00:59:56,160 --> 00:59:59,279
want an interpreted language

1710
00:59:57,359 --> 01:00:01,359
you just write an interpreter so i guess

1711
00:59:59,280 --> 01:00:03,280
it gets you control over that

1712
01:00:01,359 --> 01:00:04,720
but there's a great many examples that

1713
01:00:03,280 --> 01:00:05,200
come with a racket language and it's

1714
01:00:04,720 --> 01:00:08,160
package

1715
01:00:05,200 --> 01:00:10,480
ecosystem of different languages so one

1716
01:00:08,160 --> 01:00:12,319
example is that there's a haskell-like

1717
01:00:10,480 --> 01:00:15,359
language for example that comes the only

1718
01:00:12,319 --> 01:00:17,520
difference is that it has parentheses

1719
01:00:15,359 --> 01:00:19,119
or i think the racket-based system comes

1720
01:00:17,520 --> 01:00:20,160
with a language that does functional

1721
01:00:19,119 --> 01:00:22,400
reactive programming

1722
01:00:20,160 --> 01:00:23,359
where each value changes over time you

1723
01:00:22,400 --> 01:00:28,720
can see it change

1724
01:00:23,359 --> 01:00:31,359
live in the rebel

1725
01:00:28,720 --> 01:00:33,040
the next question is from decoder did

1726
01:00:31,359 --> 01:00:35,839
you implement a whole basic

1727
01:00:33,040 --> 01:00:38,240
interpreter in record and how does it

1728
01:00:35,839 --> 01:00:40,319
compare in speed with a more traditional

1729
01:00:38,240 --> 01:00:43,439
interpreter

1730
01:00:40,319 --> 01:00:44,400
uh so well i implemented a bit more than

1731
01:00:43,440 --> 01:00:47,040
i showed but

1732
01:00:44,400 --> 01:00:48,559
i didn't you know i didn't put the all

1733
01:00:47,040 --> 01:00:49,759
the features of applesoft basic and the

1734
01:00:48,559 --> 01:00:51,280
graphics in there

1735
01:00:49,760 --> 01:00:53,599
you notice because it's implemented in

1736
01:00:51,280 --> 01:00:55,359
macros though it is a compiler

1737
01:00:53,599 --> 01:00:56,960
effectively so it gets compiled into

1738
01:00:55,359 --> 01:00:58,240
racket code and i think it will compare

1739
01:00:56,960 --> 01:01:00,160
quite favorably

1740
01:00:58,240 --> 01:01:01,598
because racket has a pretty pretty

1741
01:01:00,160 --> 01:01:04,640
efficient compiler

1742
01:01:01,599 --> 01:01:07,760
um in the in the back seat there

1743
01:01:04,640 --> 01:01:09,759
um so so

1744
01:01:07,760 --> 01:01:11,920
it's kind of it's not apples to oranges

1745
01:01:09,760 --> 01:01:15,200
it's kind of apples to

1746
01:01:11,920 --> 01:01:16,799
40 year old prunes so um so what

1747
01:01:15,200 --> 01:01:18,319
and racket obviously doesn't run on

1748
01:01:16,799 --> 01:01:20,640
apple ii um

1749
01:01:18,319 --> 01:01:21,839
but i think the apple the the apple soft

1750
01:01:20,640 --> 01:01:22,400
and the basic implementation that you're

1751
01:01:21,839 --> 01:01:26,240
getting there

1752
01:01:22,400 --> 01:01:26,240
is is going to run quite fast actually

1753
01:01:28,079 --> 01:01:34,559
the next question is from proles

1754
01:01:31,119 --> 01:01:37,119
do you think racket wizard's extensive

1755
01:01:34,559 --> 01:01:40,640
macro system is particular well suited

1756
01:01:37,119 --> 01:01:40,640
for building languages

1757
01:01:41,680 --> 01:01:44,960
so it is the best system in the world to

1758
01:01:44,079 --> 01:01:47,119
build languages

1759
01:01:44,960 --> 01:01:48,640
right and when so in when in my

1760
01:01:47,119 --> 01:01:50,240
commercial work right whenever we need

1761
01:01:48,640 --> 01:01:52,400
to design a dsl

1762
01:01:50,240 --> 01:01:53,919
then uh racket is at least involved in

1763
01:01:52,400 --> 01:01:55,440
the prototyping stage

1764
01:01:53,920 --> 01:01:57,760
and it could very well be involved in

1765
01:01:55,440 --> 01:02:00,000
the in the production stage as well

1766
01:01:57,760 --> 01:02:01,359
specifically you've noticed that racket

1767
01:02:00,000 --> 01:02:04,079
is a lisp

1768
01:02:01,359 --> 01:02:04,960
descendant i guess in many ways and and

1769
01:02:04,079 --> 01:02:06,720
of course

1770
01:02:04,960 --> 01:02:08,400
if you get a more traditional lisp like

1771
01:02:06,720 --> 01:02:10,799
closure it also has a macro system but

1772
01:02:08,400 --> 01:02:13,359
the macro systems of traditional lisps

1773
01:02:10,799 --> 01:02:14,240
are significantly less powerful than the

1774
01:02:13,359 --> 01:02:15,920
one in racket

1775
01:02:14,240 --> 01:02:17,439
and there's two differences that are

1776
01:02:15,920 --> 01:02:20,960
relevant um

1777
01:02:17,440 --> 01:02:22,400
one of them is that the the syntax and

1778
01:02:20,960 --> 01:02:23,680
traditional list often doesn't track

1779
01:02:22,400 --> 01:02:25,280
source code information so you don't

1780
01:02:23,680 --> 01:02:25,919
really get good error messages which are

1781
01:02:25,280 --> 01:02:27,520
important

1782
01:02:25,920 --> 01:02:29,200
if you really have domain-specific

1783
01:02:27,520 --> 01:02:30,160
languages that are exposed to domain

1784
01:02:29,200 --> 01:02:32,480
experts

1785
01:02:30,160 --> 01:02:33,520
and the other one is that it deals with

1786
01:02:32,480 --> 01:02:35,359
hygiene

1787
01:02:33,520 --> 01:02:36,880
we didn't talk about this in the talk

1788
01:02:35,359 --> 01:02:37,839
because there's lots of other talks and

1789
01:02:36,880 --> 01:02:40,799
papers

1790
01:02:37,839 --> 01:02:42,400
on the topic of hygiene but you know

1791
01:02:40,799 --> 01:02:44,240
that sometimes when you

1792
01:02:42,400 --> 01:02:46,240
write a macro you need to invent new

1793
01:02:44,240 --> 01:02:47,038
names that are just supposed to be

1794
01:02:46,240 --> 01:02:50,078
temporary

1795
01:02:47,039 --> 01:02:52,640
and um and doing that requires

1796
01:02:50,079 --> 01:02:54,079
extreme care in a traditional lisp

1797
01:02:52,640 --> 01:02:55,520
system whereas in racket it's just

1798
01:02:54,079 --> 01:02:57,760
automatic

1799
01:02:55,520 --> 01:03:00,079
and so pretty much the subtleties that

1800
01:02:57,760 --> 01:03:01,359
i've shown

1801
01:03:00,079 --> 01:03:03,119
that's a pretty complete set i don't

1802
01:03:01,359 --> 01:03:05,920
think i deal with more subtleties

1803
01:03:03,119 --> 01:03:07,359
on a day-to-day basis um and at a

1804
01:03:05,920 --> 01:03:09,039
traditional lisp system you would also

1805
01:03:07,359 --> 01:03:10,319
need to deal with hygiene issues which

1806
01:03:09,039 --> 01:03:14,160
you don't in racket

1807
01:03:10,319 --> 01:03:14,640
so so that gets you sort of one level of

1808
01:03:14,160 --> 01:03:17,680
power

1809
01:03:14,640 --> 01:03:31,839
above traditional lisps in terms of how

1810
01:03:17,680 --> 01:03:31,839
funky you can get with your dsl

1811
01:03:42,839 --> 01:03:45,839
uh

1812
01:04:01,640 --> 01:04:04,640
bye

