1
00:00:00,000 --> 00:00:04,019
really excited to be here to talk<font color="#E5E5E5"> to you</font>

2
00:00:01,740 --> 00:00:08,220
today about<font color="#CCCCCC"> some work that I did with</font>

3
00:00:04,019 --> 00:00:10,800
Michael acosto and we went in search of

4
00:00:08,220 --> 00:00:12,809
shotgun parsers so very brief overview

5
00:00:10,800 --> 00:00:14,340
of<font color="#E5E5E5"> what we'll be covering will look at</font>

6
00:00:12,809 --> 00:00:16,680
some context surrounding this problem

7
00:00:14,340 --> 00:00:19,230
will actually go through our proposed

8
00:00:16,680 --> 00:00:20,970
definition for<font color="#E5E5E5"> shotgun parser will take</font>

9
00:00:19,230 --> 00:00:23,699
a look at an application of one part<font color="#E5E5E5"> of</font>

10
00:00:20,970 --> 00:00:25,049
that definition to<font color="#CCCCCC"> Android apps and then</font>

11
00:00:23,699 --> 00:00:26,369
take a look<font color="#CCCCCC"> at a couple of other</font>

12
00:00:25,050 --> 00:00:30,240
software systems and see how that

13
00:00:26,369 --> 00:00:32,159
definition can<font color="#CCCCCC"> be applied so what</font><font color="#E5E5E5"> are we</font>

14
00:00:30,240 --> 00:00:34,890
<font color="#E5E5E5">actually looking for when we say we're</font>

15
00:00:32,159 --> 00:00:36,269
going to look for shotgun parsers the

16
00:00:34,890 --> 00:00:38,040
concept of the shotgun<font color="#E5E5E5"> parser</font>

17
00:00:36,270 --> 00:00:40,800
anti-pattern is I'm<font color="#CCCCCC"> sure very familiar</font>

18
00:00:38,040 --> 00:00:41,850
<font color="#CCCCCC">to most in this audience and</font><font color="#E5E5E5"> Sergey and</font>

19
00:00:40,800 --> 00:00:44,160
Meredith have a couple<font color="#E5E5E5"> of excellent</font>

20
00:00:41,850 --> 00:00:46,320
talks about this concept which you shall

21
00:00:44,160 --> 00:00:48,328
watch on the blanks<font color="#E5E5E5"> Tech website if you</font>

22
00:00:46,320 --> 00:00:49,850
haven't seen them<font color="#E5E5E5"> already but basically</font>

23
00:00:48,329 --> 00:00:52,170
what we're talking about with this

24
00:00:49,850 --> 00:00:54,390
anti-pattern is the case where<font color="#CCCCCC"> you're</font>

25
00:00:52,170 --> 00:00:56,520
intermixing the use and validation of

26
00:00:54,390 --> 00:00:59,030
input data this would be of course in

27
00:00:56,520 --> 00:01:01,920
contrast<font color="#E5E5E5"> to the good practice case where</font>

28
00:00:59,030 --> 00:01:04,049
immediately<font color="#E5E5E5"> upon receiving input you</font>

29
00:01:01,920 --> 00:01:06,299
validate it with a formal grammar read

30
00:01:04,049 --> 00:01:08,130
it into some native strongly typed data

31
00:01:06,299 --> 00:01:12,600
structure and henceforth never actually

32
00:01:08,130 --> 00:01:14,100
deal with raw untrusted input so this<font color="#E5E5E5"> is</font>

33
00:01:12,600 --> 00:01:16,229
well and good<font color="#E5E5E5"> and we all colloquially</font>

34
00:01:14,100 --> 00:01:18,419
understand what it means to say we have

35
00:01:16,229 --> 00:01:20,970
a shotgun parser but if<font color="#E5E5E5"> we want to start</font>

36
00:01:18,420 --> 00:01:22,860
actually building automated tools to

37
00:01:20,970 --> 00:01:25,590
detect this anti-pattern we need a

38
00:01:22,860 --> 00:01:27,750
stricter definition and so this<font color="#CCCCCC"> is part</font>

39
00:01:25,590 --> 00:01:29,909
of what<font color="#E5E5E5"> we set out to achieve and we</font>

40
00:01:27,750 --> 00:01:32,220
frame our definition in the context of

41
00:01:29,909 --> 00:01:36,000
static chain analysis of control flow

42
00:01:32,220 --> 00:01:38,640
graphs so I'd now like to present to you

43
00:01:36,000 --> 00:01:41,909
informally our three hallmarks of the

44
00:01:38,640 --> 00:01:44,009
shotgun<font color="#E5E5E5"> parser first being large spread</font>

45
00:01:41,909 --> 00:01:45,810
relative<font color="#CCCCCC"> to size so when that untrusted</font>

46
00:01:44,009 --> 00:01:50,280
data enters your code how far does it

47
00:01:45,810 --> 00:01:51,630
actually propagate secondly the use

48
00:01:50,280 --> 00:01:54,509
<font color="#CCCCCC">before full recognition property</font>

49
00:01:51,630 --> 00:01:56,280
obviously is that input data being

50
00:01:54,509 --> 00:02:01,020
validated before the first time that you

51
00:01:56,280 --> 00:02:03,299
use it and secondly the large<font color="#CCCCCC"> number of</font>

52
00:02:01,020 --> 00:02:05,369
variables involved in a chain two<font color="#E5E5E5"> paths</font>

53
00:02:03,299 --> 00:02:08,390
so how many pieces of program state are

54
00:02:05,369 --> 00:02:10,348
being affected by<font color="#E5E5E5"> properties one and two</font>

55
00:02:08,389 --> 00:02:12,089
and I'd like<font color="#E5E5E5"> to</font><font color="#CCCCCC"> get</font><font color="#E5E5E5"> into</font><font color="#CCCCCC"> a bit more</font>

56
00:02:10,348 --> 00:02:13,950
detail<font color="#E5E5E5"> about each of these properties</font>

57
00:02:12,090 --> 00:02:15,989
starting with spread relative to

58
00:02:13,950 --> 00:02:18,000
<font color="#E5E5E5">sighs so if we consider some application</font>

59
00:02:15,989 --> 00:02:20,730
a which reads in a set of untrusted

60
00:02:18,000 --> 00:02:22,709
inputs n then let G be the static

61
00:02:20,730 --> 00:02:25,018
control flow graph which describes a and

62
00:02:22,709 --> 00:02:27,180
let P sub n be the connected subgraph

63
00:02:25,019 --> 00:02:31,110
induced by the vertices of G that have

64
00:02:27,180 --> 00:02:33,269
been tainted by<font color="#CCCCCC"> N and finally let s be</font>

65
00:02:31,110 --> 00:02:37,349
the set<font color="#CCCCCC"> of all such team do sub graphs</font>

66
00:02:33,269 --> 00:02:39,090
on G so now with this<font color="#CCCCCC"> definition in hand</font>

67
00:02:37,349 --> 00:02:41,488
we can start<font color="#E5E5E5"> to pick up a few shotgun</font>

68
00:02:39,090 --> 00:02:43,319
parser indicators first we can take a

69
00:02:41,489 --> 00:02:45,750
look at the diameter of that induced sub

70
00:02:43,319 --> 00:02:48,660
graph as compared to the diameter<font color="#CCCCCC"> of the</font>

71
00:02:45,750 --> 00:02:50,489
overall graph<font color="#CCCCCC"> g if you have comparable</font>

72
00:02:48,660 --> 00:02:52,170
diameters this indicates<font color="#CCCCCC"> your untrusted</font>

73
00:02:50,489 --> 00:02:53,880
input is spreading throughout your

74
00:02:52,170 --> 00:02:56,518
application it's not being handled in<font color="#E5E5E5"> a</font>

75
00:02:53,880 --> 00:02:59,010
principled manner secondly we can look

76
00:02:56,519 --> 00:03:00,959
at the cardinality of that set s if s

77
00:02:59,010 --> 00:03:02,609
contains<font color="#E5E5E5"> large number of elements this</font>

78
00:03:00,959 --> 00:03:05,430
could be evidence<font color="#CCCCCC"> that</font><font color="#E5E5E5"> you in fact have</font>

79
00:03:02,610 --> 00:03:09,690
multiple instances of<font color="#E5E5E5"> shotgun parsers in</font>

80
00:03:05,430 --> 00:03:11,130
your application<font color="#CCCCCC"> coming</font><font color="#E5E5E5"> to the second</font>

81
00:03:09,690 --> 00:03:12,989
<font color="#E5E5E5">property which is arguably</font><font color="#CCCCCC"> the most</font>

82
00:03:11,130 --> 00:03:15,390
important the use<font color="#CCCCCC"> of</font><font color="#E5E5E5"> before full</font>

83
00:03:12,989 --> 00:03:17,450
recognition of course unfortunately this

84
00:03:15,390 --> 00:03:19,260
is also the hardest property to

85
00:03:17,450 --> 00:03:22,108
characterize in an automated fashion

86
00:03:19,260 --> 00:03:24,030
because of course if you have an input

87
00:03:22,109 --> 00:03:26,370
language which at all approaches train

88
00:03:24,030 --> 00:03:29,010
completeness in complexity it becomes

89
00:03:26,370 --> 00:03:31,260
impossible<font color="#E5E5E5"> to actually quantify whether</font>

90
00:03:29,010 --> 00:03:32,700
arbitrary input into an arbitrary piece

91
00:03:31,260 --> 00:03:35,578
of code is fully recognized because that

92
00:03:32,700 --> 00:03:37,768
reduces to the halting problem so what

93
00:03:35,579 --> 00:03:41,220
we can instead start to do is to define

94
00:03:37,769 --> 00:03:43,410
a set of standards for handling specific

95
00:03:41,220 --> 00:03:46,530
<font color="#E5E5E5">well known well well understood data</font>

96
00:03:43,410 --> 00:03:48,359
types so for example<font color="#CCCCCC"> we can conceive of</font>

97
00:03:46,530 --> 00:03:50,730
this very simple<font color="#CCCCCC"> model in which we have</font>

98
00:03:48,359 --> 00:03:53,340
a single process a responsible for

99
00:03:50,730 --> 00:03:56,160
writing external data to an input buffer

100
00:03:53,340 --> 00:03:58,560
we consider another process B whose job

101
00:03:56,160 --> 00:04:00,690
it is to read data out of<font color="#CCCCCC"> that buffer</font>

102
00:03:58,560 --> 00:04:03,090
perform some operation and write to<font color="#CCCCCC"> our</font>

103
00:04:00,690 --> 00:04:04,889
validated buffer now within<font color="#CCCCCC"> this very</font>

104
00:04:03,090 --> 00:04:07,290
simple framework we can start to define

105
00:04:04,889 --> 00:04:09,299
rules so for example if we<font color="#CCCCCC"> have some</font>

106
00:04:07,290 --> 00:04:10,739
object of type<font color="#CCCCCC"> 0 which is well</font>

107
00:04:09,299 --> 00:04:12,750
understood we know all<font color="#CCCCCC"> those properties</font>

108
00:04:10,739 --> 00:04:15,389
we define the rule<font color="#CCCCCC"> that to fully</font>

109
00:04:12,750 --> 00:04:17,728
recognize oh you need<font color="#CCCCCC"> to do five rights</font>

110
00:04:15,389 --> 00:04:19,978
or<font color="#E5E5E5"> pardon me five reads of 4 bytes each</font>

111
00:04:17,728 --> 00:04:22,289
then write out 20 bytes in a specific

112
00:04:19,978 --> 00:04:23,880
order and we can capture read write

113
00:04:22,289 --> 00:04:25,979
memory events in order to ascertain

114
00:04:23,880 --> 00:04:27,780
whether this<font color="#E5E5E5"> has happened so in this way</font>

115
00:04:25,979 --> 00:04:30,900
<font color="#E5E5E5">we can start to sort of build up</font>

116
00:04:27,780 --> 00:04:33,119
a<font color="#CCCCCC"> whitelist</font><font color="#E5E5E5"> if you will of appropriate</font>

117
00:04:30,900 --> 00:04:39,000
read/write patterns corresponding to

118
00:04:33,120 --> 00:04:41,190
various common data types and now we get

119
00:04:39,000 --> 00:04:42,930
<font color="#E5E5E5">to this auxiliary property of number of</font>

120
00:04:41,190 --> 00:04:45,740
tainted input variables so consider

121
00:04:42,930 --> 00:04:48,090
<font color="#E5E5E5">again our tainted sub graph p sub n and</font>

122
00:04:45,740 --> 00:04:50,100
now let's let piece of n be a weighted

123
00:04:48,090 --> 00:04:52,440
graph where the wedge of the weight of

124
00:04:50,100 --> 00:04:54,690
each edge corresponds to the number<font color="#E5E5E5"> of</font>

125
00:04:52,440 --> 00:04:58,680
pieces of<font color="#E5E5E5"> state have been tainted by n</font>

126
00:04:54,690 --> 00:05:00,630
after traversing node X and again here

127
00:04:58,680 --> 00:05:02,550
<font color="#CCCCCC">we can pick up a few shotgun parser</font>

128
00:05:00,630 --> 00:05:04,680
indicators so if the number<font color="#E5E5E5"> of pieces of</font>

129
00:05:02,550 --> 00:05:06,660
tainted state is large compared<font color="#E5E5E5"> to the</font>

130
00:05:04,680 --> 00:05:08,490
total number of pieces of overall state

131
00:05:06,660 --> 00:05:11,190
this indicates that perhaps the

132
00:05:08,490 --> 00:05:13,350
prevalence<font color="#E5E5E5"> of untrusted data is</font>

133
00:05:11,190 --> 00:05:16,350
<font color="#E5E5E5">affecting a greater</font><font color="#CCCCCC"> proportion of your</font>

134
00:05:13,350 --> 00:05:19,229
program state and we can also use this

135
00:05:16,350 --> 00:05:21,960
to start to triage areas of large very

136
00:05:19,229 --> 00:05:23,460
complex control<font color="#E5E5E5"> flow graphs in terms of</font>

137
00:05:21,960 --> 00:05:25,739
where we<font color="#E5E5E5"> want to focus further analysis</font>

138
00:05:23,460 --> 00:05:26,960
we have a particular node<font color="#CCCCCC"> after which</font>

139
00:05:25,740 --> 00:05:29,370
the edge weight increases significantly

140
00:05:26,960 --> 00:05:30,900
the statements or methods involved in

141
00:05:29,370 --> 00:05:35,310
that node are something<font color="#CCCCCC"> that will</font><font color="#E5E5E5"> want</font>

142
00:05:30,900 --> 00:05:37,349
to focus further analysis on and so<font color="#E5E5E5"> now</font>

143
00:05:35,310 --> 00:05:40,640
we can use our three parts<font color="#E5E5E5"> of our</font>

144
00:05:37,350 --> 00:05:43,590
definition to visualize this 3d

145
00:05:40,640 --> 00:05:46,890
definition cube and within this space we

146
00:05:43,590 --> 00:05:48,090
can<font color="#E5E5E5"> talk about how prevalent each of</font>

147
00:05:46,890 --> 00:05:49,830
these properties<font color="#CCCCCC"> is in a given</font>

148
00:05:48,090 --> 00:05:51,630
application so of course our

149
00:05:49,830 --> 00:05:53,310
pathological shotgun parser would be out

150
00:05:51,630 --> 00:05:54,840
here at the extremities because it

151
00:05:53,310 --> 00:05:59,789
exhibits all three of these properties

152
00:05:54,840 --> 00:06:02,039
<font color="#E5E5E5">in abundance I'll night</font><font color="#CCCCCC"> tuck you through</font>

153
00:05:59,789 --> 00:06:04,440
<font color="#E5E5E5">a case study that we did applying part</font>

154
00:06:02,039 --> 00:06:07,469
of this definition to<font color="#E5E5E5"> android apps and</font>

155
00:06:04,440 --> 00:06:09,719
our goals in this part of the study were

156
00:06:07,470 --> 00:06:12,000
to<font color="#E5E5E5"> really establish the foundations for</font>

157
00:06:09,720 --> 00:06:14,550
a full shock on partial recognizer and

158
00:06:12,000 --> 00:06:16,590
to start<font color="#E5E5E5"> taking a</font><font color="#CCCCCC"> look at</font><font color="#E5E5E5"> hopefully a</font>

159
00:06:14,550 --> 00:06:18,960
different class of errors through the

160
00:06:16,590 --> 00:06:20,940
<font color="#CCCCCC">Lang's a cleanse for reasons of</font>

161
00:06:18,960 --> 00:06:23,430
computational tractability we focused in

162
00:06:20,940 --> 00:06:25,169
this phase exclusively on the<font color="#E5E5E5"> first part</font>

163
00:06:23,430 --> 00:06:28,740
of our definition namely the spread

164
00:06:25,169 --> 00:06:30,690
relative to size<font color="#E5E5E5"> property so again our</font>

165
00:06:28,740 --> 00:06:32,850
approach<font color="#CCCCCC"> was based on static taint</font>

166
00:06:30,690 --> 00:06:35,039
analysis of statement level<font color="#E5E5E5"> control flow</font>

167
00:06:32,850 --> 00:06:36,450
graphs and what we wanted to do<font color="#E5E5E5"> is</font>

168
00:06:35,039 --> 00:06:38,610
compute the actual path length

169
00:06:36,450 --> 00:06:41,400
associated with each source of taint

170
00:06:38,610 --> 00:06:42,720
into a<font color="#E5E5E5"> given application and are now</font>

171
00:06:41,400 --> 00:06:45,030
use the<font color="#E5E5E5"> gym pool intermediate</font>

172
00:06:42,720 --> 00:06:47,400
representation which is a representation

173
00:06:45,030 --> 00:06:51,530
that sits between dalvik bytecode and

174
00:06:47,400 --> 00:06:54,270
source level<font color="#CCCCCC"> Java in terms of complexity</font>

175
00:06:51,530 --> 00:06:56,489
so we built<font color="#E5E5E5"> our analysis on top of flow</font>

176
00:06:54,270 --> 00:06:59,219
droid which is an open source static

177
00:06:56,490 --> 00:07:01,530
analysis framework for<font color="#E5E5E5"> Android now flow</font>

178
00:06:59,220 --> 00:07:03,509
droids native operation is to provide

179
00:07:01,530 --> 00:07:05,969
the user with a set<font color="#CCCCCC"> of data flows that</font>

180
00:07:03,509 --> 00:07:08,490
<font color="#E5E5E5">exists</font><font color="#CCCCCC"> between predefined sets of</font>

181
00:07:05,970 --> 00:07:10,830
sources and<font color="#E5E5E5"> sinks we of course wanted to</font>

182
00:07:08,490 --> 00:07:14,910
take<font color="#E5E5E5"> that</font><font color="#CCCCCC"> one step further</font><font color="#E5E5E5"> and actually</font>

183
00:07:10,830 --> 00:07:16,650
track how far each piece of input state

184
00:07:14,910 --> 00:07:18,510
propagated within that application and

185
00:07:16,650 --> 00:07:19,830
we wanted<font color="#E5E5E5"> to track all tainted</font><font color="#CCCCCC"> pass not</font>

186
00:07:18,510 --> 00:07:22,080
just those which may terminate in<font color="#E5E5E5"> the</font>

187
00:07:19,830 --> 00:07:24,659
sink so we made those modifications to

188
00:07:22,080 --> 00:07:26,099
the flow droid framework and picked up a

189
00:07:24,660 --> 00:07:27,600
couple<font color="#E5E5E5"> of other pieces of information as</font>

190
00:07:26,100 --> 00:07:28,919
well unique identifiers for each taint

191
00:07:27,600 --> 00:07:31,110
source so we<font color="#E5E5E5"> could</font><font color="#CCCCCC"> actually quantify</font>

192
00:07:28,919 --> 00:07:33,299
these things and we picked up the

193
00:07:31,110 --> 00:07:36,810
specific API calls from which each

194
00:07:33,300 --> 00:07:39,389
change originated very<font color="#E5E5E5"> high level</font>

195
00:07:36,810 --> 00:07:41,280
overview of our implementation each time

196
00:07:39,389 --> 00:07:43,139
a taint gets propagated our custom

197
00:07:41,280 --> 00:07:45,479
handler gets invoked and what our

198
00:07:43,139 --> 00:07:47,910
handler does is capture the incoming

199
00:07:45,479 --> 00:07:49,590
data flow fact object which is<font color="#E5E5E5"> just the</font>

200
00:07:47,910 --> 00:07:52,800
taint source plus some<font color="#E5E5E5"> associated</font>

201
00:07:49,590 --> 00:07:54,539
metadata and also captures the set of

202
00:07:52,800 --> 00:07:56,430
outgoing objects from that taint

203
00:07:54,539 --> 00:07:58,469
propagation so if we<font color="#E5E5E5"> haven't seen a</font>

204
00:07:56,430 --> 00:08:00,150
particular taint before initialize its

205
00:07:58,470 --> 00:08:02,370
length<font color="#CCCCCC"> 0 add it to our working</font><font color="#E5E5E5"> set and</font>

206
00:08:00,150 --> 00:08:05,340
pick up the source from which<font color="#E5E5E5"> that input</font>

207
00:08:02,370 --> 00:08:08,270
originated and we then iterate over the

208
00:08:05,340 --> 00:08:09,989
outgoing set incrementing each taint

209
00:08:08,270 --> 00:08:14,280
incrementing<font color="#E5E5E5"> the path length of each</font>

210
00:08:09,990 --> 00:08:17,159
taint in that set so using this workflow

211
00:08:14,280 --> 00:08:18,869
we were able to analyze 56 free apps out

212
00:08:17,159 --> 00:08:20,940
of 12 different categories from<font color="#E5E5E5"> the</font>

213
00:08:18,870 --> 00:08:23,070
google play store we ran each app

214
00:08:20,940 --> 00:08:24,990
through our modified flow droid<font color="#E5E5E5"> measure</font>

215
00:08:23,070 --> 00:08:27,060
<font color="#E5E5E5">the path length for each input source</font>

216
00:08:24,990 --> 00:08:29,099
into that application and we then

217
00:08:27,060 --> 00:08:31,440
generated a histogram of normalized path

218
00:08:29,099 --> 00:08:33,770
lengths for each app<font color="#E5E5E5"> where in this case</font>

219
00:08:31,440 --> 00:08:38,309
<font color="#E5E5E5">we're normalizing by the graph diameter</font>

220
00:08:33,770 --> 00:08:41,579
and<font color="#CCCCCC"> you can see three such of our graphs</font>

221
00:08:38,309 --> 00:08:43,319
here so this<font color="#E5E5E5"> is kind of interesting</font>

222
00:08:41,580 --> 00:08:45,089
because<font color="#E5E5E5"> here we have three very</font>

223
00:08:43,320 --> 00:08:47,459
different apps from very different

224
00:08:45,089 --> 00:08:49,860
categories and yet they<font color="#CCCCCC"> all display this</font>

225
00:08:47,459 --> 00:08:51,589
<font color="#E5E5E5">very similar shape the sort</font><font color="#CCCCCC"> of inverse</font>

226
00:08:49,860 --> 00:08:54,600
power log shape and in fact this

227
00:08:51,589 --> 00:08:55,380
distribution was typical of majority of

228
00:08:54,600 --> 00:08:57,720
apps<font color="#E5E5E5"> that we serve</font>

229
00:08:55,380 --> 00:09:00,330
so this is<font color="#E5E5E5"> kind of interesting because</font>

230
00:08:57,720 --> 00:09:02,760
<font color="#E5E5E5">we see here that there are a large</font>

231
00:09:00,330 --> 00:09:05,640
number of very short paths indicating

232
00:09:02,760 --> 00:09:07,439
that data is read in and then used

233
00:09:05,640 --> 00:09:10,140
immediately without being passed on so

234
00:09:07,440 --> 00:09:11,340
this<font color="#E5E5E5"> is you know hopefully good news but</font>

235
00:09:10,140 --> 00:09:14,430
of course<font color="#CCCCCC"> we also see these long</font>

236
00:09:11,340 --> 00:09:16,980
trailing<font color="#E5E5E5"> tales indicating that we do</font>

237
00:09:14,430 --> 00:09:19,199
have<font color="#E5E5E5"> some pieces of data which propagate</font>

238
00:09:16,980 --> 00:09:21,480
twenty percent twenty-five percent fifty

239
00:09:19,200 --> 00:09:23,850
percent<font color="#E5E5E5"> of the way through each control</font>

240
00:09:21,480 --> 00:09:26,150
flow graph now of<font color="#E5E5E5"> course the caveat here</font>

241
00:09:23,850 --> 00:09:28,440
is that at this stage we're only

242
00:09:26,150 --> 00:09:30,750
characterizing raw path length we're not

243
00:09:28,440 --> 00:09:34,290
capturing the nature of<font color="#E5E5E5"> the operations</font>

244
00:09:30,750 --> 00:09:35,850
along each long path and of<font color="#CCCCCC"> course</font>

245
00:09:34,290 --> 00:09:38,219
another thing<font color="#E5E5E5"> I should mention is that</font>

246
00:09:35,850 --> 00:09:39,300
you know static<font color="#E5E5E5"> analysis of real</font>

247
00:09:38,220 --> 00:09:41,400
applications is time<font color="#CCCCCC"> and memory</font>

248
00:09:39,300 --> 00:09:43,229
intensive and this part of the project

249
00:09:41,400 --> 00:09:45,329
was actually my one semester

250
00:09:43,230 --> 00:09:47,540
undergraduate research project so we

251
00:09:45,330 --> 00:09:50,700
<font color="#E5E5E5">only had</font><font color="#CCCCCC"> three months</font><font color="#E5E5E5"> to conduct this</font>

252
00:09:47,540 --> 00:09:53,760
analysis and so for this<font color="#CCCCCC"> reason we were</font>

253
00:09:50,700 --> 00:09:56,070
only able<font color="#E5E5E5"> to characterize 56 apps so</font>

254
00:09:53,760 --> 00:09:58,189
<font color="#E5E5E5">definitely a big area for further work</font>

255
00:09:56,070 --> 00:10:00,420
in this project would<font color="#E5E5E5"> be to scale up our</font>

256
00:09:58,190 --> 00:10:01,950
implementation to now allow us to gather

257
00:10:00,420 --> 00:10:05,089
more<font color="#E5E5E5"> data and actually start</font><font color="#CCCCCC"> to draw</font>

258
00:10:01,950 --> 00:10:08,040
some meaningful statistical conclusions

259
00:10:05,090 --> 00:10:11,490
but<font color="#E5E5E5"> this is okay because really what our</font>

260
00:10:08,040 --> 00:10:12,480
tool is is the foundations of what can

261
00:10:11,490 --> 00:10:15,030
become a full shock on pressure

262
00:10:12,480 --> 00:10:17,790
recognizer for<font color="#E5E5E5"> Android and it can also</font>

263
00:10:15,030 --> 00:10:20,010
serve as a prioritization method for app

264
00:10:17,790 --> 00:10:23,339
analysis so you'll see here<font color="#CCCCCC"> the open</font>

265
00:10:20,010 --> 00:10:26,490
comic reader app simple application has

266
00:10:23,340 --> 00:10:28,800
a hundred thousand unique possible paths

267
00:10:26,490 --> 00:10:30,930
of execution through that control flow

268
00:10:28,800 --> 00:10:33,540
graph so obviously even in an automated

269
00:10:30,930 --> 00:10:35,310
sense we need to narrow in on which of

270
00:10:33,540 --> 00:10:37,439
<font color="#CCCCCC">these paths we want to focus on for</font><font color="#E5E5E5"> a</font>

271
00:10:35,310 --> 00:10:40,290
further analysis and so you'll<font color="#CCCCCC"> see here</font>

272
00:10:37,440 --> 00:10:42,330
<font color="#E5E5E5">that it does display that familiar power</font>

273
00:10:40,290 --> 00:10:44,670
log shape but we also<font color="#E5E5E5"> have three</font>

274
00:10:42,330 --> 00:10:47,610
clusters of very long paths including

275
00:10:44,670 --> 00:10:49,050
you'll see on the far side there we have

276
00:10:47,610 --> 00:10:51,150
two clusters of several thousand paths

277
00:10:49,050 --> 00:10:53,130
which spread over eighty percent of<font color="#E5E5E5"> the</font>

278
00:10:51,150 --> 00:10:54,720
way through<font color="#CCCCCC"> the graph diameter so this</font>

279
00:10:53,130 --> 00:10:57,210
is<font color="#CCCCCC"> the area that we're going</font><font color="#E5E5E5"> to want to</font>

280
00:10:54,720 --> 00:10:58,890
<font color="#E5E5E5">focus on when we start to characterize</font>

281
00:10:57,210 --> 00:11:02,910
the second and third shotgun<font color="#E5E5E5"> parsha</font>

282
00:10:58,890 --> 00:11:06,390
properties and so now<font color="#CCCCCC"> I'd</font><font color="#E5E5E5"> like to take a</font>

283
00:11:02,910 --> 00:11:08,760
look at<font color="#E5E5E5"> three other examples and see how</font>

284
00:11:06,390 --> 00:11:09,360
our definition can fit in and apply in

285
00:11:08,760 --> 00:11:12,060
these

286
00:11:09,360 --> 00:11:13,920
shins starting<font color="#CCCCCC"> with the so called image</font>

287
00:11:12,060 --> 00:11:15,989
tragic bug which is the<font color="#E5E5E5"> cutesy name</font>

288
00:11:13,920 --> 00:11:19,199
<font color="#E5E5E5">applied to the recently disclosed</font><font color="#CCCCCC"> balan</font>

289
00:11:15,990 --> 00:11:22,350
in imagemagick so the essentials<font color="#E5E5E5"> of this</font>

290
00:11:19,200 --> 00:11:24,839
vulnerability lay in the convert

291
00:11:22,350 --> 00:11:27,149
function of imagemagick which basically

292
00:11:24,839 --> 00:11:28,649
allows users to delegate functionality

293
00:11:27,149 --> 00:11:30,980
to external functions but as a side

294
00:11:28,649 --> 00:11:34,410
effect allows them to execute arbitrary

295
00:11:30,980 --> 00:11:35,760
<font color="#E5E5E5">shellcode which is fine and good if</font>

296
00:11:34,410 --> 00:11:37,620
you're a user sitting on your own

297
00:11:35,760 --> 00:11:39,149
machine but very<font color="#CCCCCC"> very bad if</font><font color="#E5E5E5"> you're</font>

298
00:11:37,620 --> 00:11:41,970
using this in the context of say a web

299
00:11:39,149 --> 00:11:44,160
server so<font color="#E5E5E5"> digging into the code you can</font>

300
00:11:41,970 --> 00:11:47,279
see this is the<font color="#CCCCCC"> actual location where</font>

301
00:11:44,160 --> 00:11:48,630
that delegate command is invoked and

302
00:11:47,279 --> 00:11:51,149
<font color="#CCCCCC">it's invoked at one of these four places</font>

303
00:11:48,630 --> 00:11:54,570
either the assistant caller by directly

304
00:11:51,149 --> 00:11:56,250
for<font color="#E5E5E5"> King and exacting and the astute</font>

305
00:11:54,570 --> 00:11:57,959
readers among you or those with very

306
00:11:56,250 --> 00:11:59,190
good<font color="#CCCCCC"> eyesight will notice that</font><font color="#E5E5E5"> we're</font>

307
00:11:57,959 --> 00:12:01,859
actually invoking something called

308
00:11:59,190 --> 00:12:04,200
<font color="#E5E5E5">sanitized command so it's not just raw</font>

309
00:12:01,860 --> 00:12:05,970
input and and in fact we<font color="#E5E5E5"> see up here yes</font>

310
00:12:04,200 --> 00:12:08,130
<font color="#CCCCCC">sanitized command is the output of this</font>

311
00:12:05,970 --> 00:12:09,779
sanitized delegate command function so

312
00:12:08,130 --> 00:12:12,420
this<font color="#E5E5E5"> is good right because we're poor</font>

313
00:12:09,779 --> 00:12:16,470
forming some sort of input<font color="#E5E5E5"> sanitization</font>

314
00:12:12,420 --> 00:12:18,510
turns out not quite so if we<font color="#E5E5E5"> dig into</font>

315
00:12:16,470 --> 00:12:20,399
<font color="#E5E5E5">sanitize delegate command you'll see</font>

316
00:12:18,510 --> 00:12:23,459
that it's really<font color="#E5E5E5"> just a white list of</font>

317
00:12:20,399 --> 00:12:25,649
<font color="#E5E5E5">ASCII printable characters which indeed</font>

318
00:12:23,459 --> 00:12:28,469
will defend<font color="#E5E5E5"> you against arbitrary binary</font>

319
00:12:25,649 --> 00:12:31,079
but absolutely accepts anything that is

320
00:12:28,470 --> 00:12:33,390
<font color="#CCCCCC">shellcode and this is actually in a</font>

321
00:12:31,079 --> 00:12:36,329
really interesting case of not only<font color="#E5E5E5"> an</font>

322
00:12:33,390 --> 00:12:38,550
example<font color="#E5E5E5"> of perhaps a shotgun parser</font>

323
00:12:36,329 --> 00:12:40,920
paradigm but also an example of another

324
00:12:38,550 --> 00:12:42,959
<font color="#CCCCCC">lang SEC anti-pattern namely language</font>

325
00:12:40,920 --> 00:12:45,779
specification drift because we have<font color="#CCCCCC"> here</font>

326
00:12:42,959 --> 00:12:48,029
a case where the validation where it was

327
00:12:45,779 --> 00:12:49,740
once appropriate didn't evolve along

328
00:12:48,029 --> 00:12:52,949
with the use case of this piece of

329
00:12:49,740 --> 00:12:54,360
<font color="#E5E5E5">software and to close off the image</font>

330
00:12:52,949 --> 00:12:56,760
tragic example<font color="#E5E5E5"> I just want to show you a</font>

331
00:12:54,360 --> 00:12:58,949
quick visual trace I know but text is

332
00:12:56,760 --> 00:13:00,510
too small to see<font color="#CCCCCC"> but</font><font color="#E5E5E5"> that's not not</font><font color="#CCCCCC"> the</font>

333
00:12:58,949 --> 00:13:02,339
point of this slide<font color="#E5E5E5"> I want to</font><font color="#CCCCCC"> show</font><font color="#E5E5E5"> you</font>

334
00:13:00,510 --> 00:13:04,980
quick visual trace of all of the places

335
00:13:02,339 --> 00:13:08,519
that raw input is touched along the path

336
00:13:04,980 --> 00:13:10,410
from user input to finally executing

337
00:13:08,519 --> 00:13:13,019
<font color="#CCCCCC">that delegate command so you see here we</font>

338
00:13:10,410 --> 00:13:14,550
pull in Argosy and arg v and then<font color="#E5E5E5"> just</font>

339
00:13:13,019 --> 00:13:16,019
start touching RV all over the place a

340
00:13:14,550 --> 00:13:17,910
few bites are pulled off some check is

341
00:13:16,019 --> 00:13:20,279
performed some things are converted to

342
00:13:17,910 --> 00:13:22,990
strings and this proceeds through about

343
00:13:20,279 --> 00:13:27,339
<font color="#E5E5E5">seven function calls before finally that</font>

344
00:13:22,990 --> 00:13:29,410
and is executed so some observations

345
00:13:27,339 --> 00:13:32,740
here<font color="#CCCCCC"> I</font><font color="#E5E5E5"> mean we obviously have evidence</font>

346
00:13:29,410 --> 00:13:34,719
of a relatively long path and you may

347
00:13:32,740 --> 00:13:36,010
think that<font color="#E5E5E5"> you know seven doesn't seem</font>

348
00:13:34,720 --> 00:13:38,830
<font color="#E5E5E5">like such a long number but of course</font>

349
00:13:36,010 --> 00:13:40,089
this<font color="#E5E5E5"> is seven function calls every one</font>

350
00:13:38,830 --> 00:13:41,920
of those functions contains several

351
00:13:40,089 --> 00:13:43,930
hundred lines of code that's you know

352
00:13:41,920 --> 00:13:45,490
several thousand<font color="#E5E5E5"> assembly level</font>

353
00:13:43,930 --> 00:13:47,410
statements so these are long paths and

354
00:13:45,490 --> 00:13:49,390
of course this is<font color="#CCCCCC"> just</font><font color="#E5E5E5"> that was just the</font>

355
00:13:47,410 --> 00:13:51,550
direct<font color="#E5E5E5"> line flow that I showed you in</font>

356
00:13:49,390 --> 00:13:53,529
<font color="#CCCCCC">between input and delegate execution</font>

357
00:13:51,550 --> 00:13:55,599
that input is being used in multiple

358
00:13:53,529 --> 00:13:58,029
functions in different branches along

359
00:13:55,600 --> 00:14:00,190
that path and this is raw input I mean

360
00:13:58,029 --> 00:14:02,290
literally we're just taking in arg v and

361
00:14:00,190 --> 00:14:03,940
in fact it gets used in five different

362
00:14:02,290 --> 00:14:05,649
functions<font color="#CCCCCC"> before it's ever read into a</font>

363
00:14:03,940 --> 00:14:07,450
native data structure so we absolutely

364
00:14:05,649 --> 00:14:10,240
have a case of input use in validation

365
00:14:07,450 --> 00:14:12,370
being intermixed and in the<font color="#E5E5E5"> end that</font>

366
00:14:10,240 --> 00:14:16,120
validation mechanism is unsuitable for

367
00:14:12,370 --> 00:14:17,709
<font color="#E5E5E5">the task at hand</font><font color="#CCCCCC"> I'd like to</font><font color="#E5E5E5"> quickly</font>

368
00:14:16,120 --> 00:14:19,600
touch on heartbleed which everyone knows

369
00:14:17,709 --> 00:14:21,520
all<font color="#E5E5E5"> about and is probably tired of</font>

370
00:14:19,600 --> 00:14:24,070
hearing about but this is an interesting

371
00:14:21,520 --> 00:14:26,620
case in<font color="#CCCCCC"> that it's fairly obviously not a</font>

372
00:14:24,070 --> 00:14:28,060
<font color="#E5E5E5">shotgun parser per se but part of our</font>

373
00:14:26,620 --> 00:14:30,160
definition namely the use before

374
00:14:28,060 --> 00:14:31,839
recognition still applies is of course

375
00:14:30,160 --> 00:14:33,850
the problem<font color="#CCCCCC"> here is the</font><font color="#E5E5E5"> failure to</font>

376
00:14:31,839 --> 00:14:35,649
actually validate the length of the

377
00:14:33,850 --> 00:14:38,200
heartbeat packet matches the specified

378
00:14:35,649 --> 00:14:40,810
length and this is where the trouble

379
00:14:38,200 --> 00:14:42,070
<font color="#E5E5E5">arises so I didn't show you a trace</font>

380
00:14:40,810 --> 00:14:44,529
through<font color="#CCCCCC"> open SSL because it's</font><font color="#E5E5E5"> not</font>

381
00:14:42,070 --> 00:14:45,790
<font color="#E5E5E5">particularly interesting but I will tell</font>

382
00:14:44,529 --> 00:14:47,170
you<font color="#CCCCCC"> that that input is passed</font><font color="#E5E5E5"> through</font>

383
00:14:45,790 --> 00:14:49,689
several function calls before processing

384
00:14:47,170 --> 00:14:51,579
but it's not<font color="#CCCCCC"> really used along the way</font>

385
00:14:49,690 --> 00:14:54,010
so<font color="#E5E5E5"> we don't really have</font><font color="#CCCCCC"> that input use</font>

386
00:14:51,579 --> 00:14:55,390
and validation intermixing however in

387
00:14:54,010 --> 00:14:57,130
the end<font color="#E5E5E5"> there's an</font><font color="#CCCCCC"> almost total lack of</font>

388
00:14:55,390 --> 00:15:00,610
validation of a<font color="#E5E5E5"> fairly important piece</font>

389
00:14:57,130 --> 00:15:02,110
of program state and now finally<font color="#CCCCCC"> let's</font>

390
00:15:00,610 --> 00:15:04,270
do you think everything<font color="#E5E5E5"> is terrible I'd</font>

391
00:15:02,110 --> 00:15:05,890
like to show you a good practice example

392
00:15:04,270 --> 00:15:08,560
of a case where parsing was actually

393
00:15:05,890 --> 00:15:10,810
done correctly and this is the HTTP

394
00:15:08,560 --> 00:15:12,520
request parser in the mongrel web server

395
00:15:10,810 --> 00:15:14,890
so you'll see<font color="#CCCCCC"> here from</font><font color="#E5E5E5"> this beautiful</font>

396
00:15:12,520 --> 00:15:16,779
state transition diagram that what they

397
00:15:14,890 --> 00:15:18,819
actually did in this parser was to

398
00:15:16,779 --> 00:15:20,680
define a finite state machine using the

399
00:15:18,820 --> 00:15:22,029
radial compiler<font color="#E5E5E5"> and of course</font><font color="#CCCCCC"> you'll</font>

400
00:15:20,680 --> 00:15:23,979
recall that finite<font color="#E5E5E5"> state machines are</font>

401
00:15:22,029 --> 00:15:25,839
fully equivalent to regular grammars so

402
00:15:23,980 --> 00:15:28,390
<font color="#E5E5E5">really what's been done here is that</font>

403
00:15:25,839 --> 00:15:29,950
they've defined the grammar<font color="#E5E5E5"> that they</font>

404
00:15:28,390 --> 00:15:31,390
expect strings in the language coming

405
00:15:29,950 --> 00:15:34,690
<font color="#E5E5E5">into their program to be a member of</font>

406
00:15:31,390 --> 00:15:36,790
they fully validate that input rejecting

407
00:15:34,690 --> 00:15:38,860
strings outside the language and this is

408
00:15:36,790 --> 00:15:41,760
is a good example of the nice fully

409
00:15:38,860 --> 00:15:43,720
compliant<font color="#CCCCCC"> lang SEC way of doing parsing</font>

410
00:15:41,760 --> 00:15:46,060
and so now we can come<font color="#E5E5E5"> back to this</font>

411
00:15:43,720 --> 00:15:48,070
beautiful state space cube and start to

412
00:15:46,060 --> 00:15:50,349
place these three examples within this

413
00:15:48,070 --> 00:15:52,540
context so imagemagick probably good

414
00:15:50,350 --> 00:15:54,520
shotgun parser candidate lots of use in

415
00:15:52,540 --> 00:15:57,579
validation intermixing long path<font color="#CCCCCC"> lengths</font>

416
00:15:54,520 --> 00:15:59,920
so<font color="#CCCCCC"> I'm going to</font><font color="#E5E5E5"> place them here the</font>

417
00:15:57,580 --> 00:16:02,920
heartbleed vulnerability less program

418
00:15:59,920 --> 00:16:04,630
state involved not really a<font color="#E5E5E5"> case of use</font>

419
00:16:02,920 --> 00:16:06,670
and validation intermixing but a<font color="#E5E5E5"> total</font>

420
00:16:04,630 --> 00:16:08,350
<font color="#E5E5E5">lack of validation of an important piece</font>

421
00:16:06,670 --> 00:16:09,520
of program state so<font color="#E5E5E5"> I'm going to place</font>

422
00:16:08,350 --> 00:16:12,610
it up there on youth before<font color="#E5E5E5"> full</font>

423
00:16:09,520 --> 00:16:14,470
recognition and finally our<font color="#E5E5E5"> poster child</font>

424
00:16:12,610 --> 00:16:16,840
for processing mongrel lives close to

425
00:16:14,470 --> 00:16:18,670
the axis here and you'll<font color="#CCCCCC"> notice that</font>

426
00:16:16,840 --> 00:16:20,920
that's<font color="#E5E5E5"> actually as far as possible from</font>

427
00:16:18,670 --> 00:16:22,120
our pathological shotgun parser which

428
00:16:20,920 --> 00:16:26,469
would be out on the extremities of the

429
00:16:22,120 --> 00:16:27,460
cube and now finally<font color="#E5E5E5"> just I'd like to</font>

430
00:16:26,470 --> 00:16:28,810
<font color="#CCCCCC">leave you with a couple of brief</font>

431
00:16:27,460 --> 00:16:30,940
thoughts about future work and

432
00:16:28,810 --> 00:16:33,369
directions that we can go with this

433
00:16:30,940 --> 00:16:35,770
<font color="#CCCCCC">project so really many roads lead from</font>

434
00:16:33,370 --> 00:16:37,210
here I mean definitely a next step would

435
00:16:35,770 --> 00:16:41,470
be to sort<font color="#E5E5E5"> of climb the hill of Android</font>

436
00:16:37,210 --> 00:16:43,480
and implement some of<font color="#E5E5E5"> the things that we</font>

437
00:16:41,470 --> 00:16:45,160
did<font color="#CCCCCC"> not have</font><font color="#E5E5E5"> time to implement in in</font>

438
00:16:43,480 --> 00:16:46,600
this project and also<font color="#E5E5E5"> to deal with some</font>

439
00:16:45,160 --> 00:16:48,430
<font color="#E5E5E5">of the platform-specific complications</font>

440
00:16:46,600 --> 00:16:50,140
that we encountered of course there's

441
00:16:48,430 --> 00:16:51,849
the opportunity as<font color="#CCCCCC"> well to implement</font>

442
00:16:50,140 --> 00:16:55,060
this type of automated detection in

443
00:16:51,850 --> 00:16:56,830
other areas of software as we've seen<font color="#E5E5E5"> in</font>

444
00:16:55,060 --> 00:16:58,119
these three ball these three boner the

445
00:16:56,830 --> 00:17:01,060
two vulnerabilities that I showed<font color="#CCCCCC"> you</font>

446
00:16:58,120 --> 00:17:03,040
there's<font color="#E5E5E5"> absolutely a lot to be</font>

447
00:17:01,060 --> 00:17:05,530
discovered<font color="#E5E5E5"> there there's also the issue</font>

448
00:17:03,040 --> 00:17:07,420
of characterizing these<font color="#CCCCCC"> input-output</font>

449
00:17:05,530 --> 00:17:10,119
whitelists and starting<font color="#CCCCCC"> to get a</font><font color="#E5E5E5"> handle</font>

450
00:17:07,420 --> 00:17:11,290
on how we're going to automate whether

451
00:17:10,119 --> 00:17:13,389
or not something has been fully

452
00:17:11,290 --> 00:17:15,099
recognized and then once we have all

453
00:17:13,390 --> 00:17:16,420
these pieces of<font color="#E5E5E5"> the puzzle in place we</font>

454
00:17:15,099 --> 00:17:18,520
<font color="#CCCCCC">can start to actually rigorously</font>

455
00:17:16,420 --> 00:17:20,680
classify some existing vulnerabilities

456
00:17:18,520 --> 00:17:23,109
and see to what extent each of these

457
00:17:20,680 --> 00:17:26,140
three shotgun purser properties is

458
00:17:23,109 --> 00:17:27,909
represented in<font color="#E5E5E5"> these vulnerabilities and</font>

459
00:17:26,140 --> 00:17:29,320
that's<font color="#E5E5E5"> pretty much all i have i just</font>

460
00:17:27,910 --> 00:17:31,000
wanted<font color="#CCCCCC"> to acknowledge stephen arsed from</font>

461
00:17:29,320 --> 00:17:32,439
the steep secure software engineering

462
00:17:31,000 --> 00:17:34,300
group it to you<font color="#E5E5E5"> darmstadt who's the</font>

463
00:17:32,440 --> 00:17:36,130
primary room maintainer<font color="#CCCCCC"> of flow droid</font>

464
00:17:34,300 --> 00:17:39,460
was very<font color="#CCCCCC"> helpful to</font><font color="#E5E5E5"> us during our flow</font>

465
00:17:36,130 --> 00:17:41,110
droid modification phase and<font color="#E5E5E5"> I think all</font>

466
00:17:39,460 --> 00:17:43,470
of you for<font color="#CCCCCC"> your attention ready for</font>

467
00:17:41,110 --> 00:17:43,469
questions

