1
00:00:00,000 --> 00:00:03,389
my name is Jacob<font color="#CCCCCC"> Tori I did this work</font>

2
00:00:01,949 --> 00:00:05,670
also with<font color="#CCCCCC"> mark bridge and one of my</font>

3
00:00:03,389 --> 00:00:07,859
colleagues who cannot<font color="#CCCCCC"> be here today this</font>

4
00:00:05,670 --> 00:00:10,170
is actually about crema which is a much

5
00:00:07,859 --> 00:00:14,280
easier to remember title than the the

6
00:00:10,170 --> 00:00:15,750
<font color="#E5E5E5">title and the the program disclaimer</font>

7
00:00:14,280 --> 00:00:17,460
<font color="#E5E5E5">this is I do not speak for the</font>

8
00:00:15,750 --> 00:00:19,080
<font color="#E5E5E5">government when I say this I'm not part</font>

9
00:00:17,460 --> 00:00:22,439
of<font color="#E5E5E5"> the government so just keep that in</font>

10
00:00:19,080 --> 00:00:24,359
mind so real quickly in a nutshell so

11
00:00:22,439 --> 00:00:26,490
essentially what we did with crema is we

12
00:00:24,359 --> 00:00:29,250
wanted to<font color="#E5E5E5"> explore</font><font color="#CCCCCC"> the sub turning space</font>

13
00:00:26,490 --> 00:00:30,778
so if you had<font color="#CCCCCC"> an execution environment</font>

14
00:00:29,250 --> 00:00:33,030
that you specifically limited when you

15
00:00:30,779 --> 00:00:34,559
created it kind of rather than most

16
00:00:33,030 --> 00:00:36,000
programming languages that are kind<font color="#E5E5E5"> of</font>

17
00:00:34,559 --> 00:00:38,669
assumed to be turned complete and then

18
00:00:36,000 --> 00:00:40,219
you kind<font color="#E5E5E5"> of deal with the syntax what</font>

19
00:00:38,670 --> 00:00:42,930
could you<font color="#E5E5E5"> do in these environments and</font>

20
00:00:40,219 --> 00:00:45,510
would<font color="#E5E5E5"> that be able to reduce the risk of</font>

21
00:00:42,930 --> 00:00:47,820
these weird machines so if you could

22
00:00:45,510 --> 00:00:49,769
give the developers the programming

23
00:00:47,820 --> 00:00:52,320
tools to be able to do say a majority of

24
00:00:49,770 --> 00:00:55,460
their work but make it just kind of by

25
00:00:52,320 --> 00:00:58,140
default more safe and make these

26
00:00:55,460 --> 00:00:59,520
analysis problems easier<font color="#CCCCCC"> now what would</font>

27
00:00:58,140 --> 00:01:02,670
<font color="#CCCCCC">that look like and what</font><font color="#E5E5E5"> does this space</font>

28
00:00:59,520 --> 00:01:04,350
look like so the goal was we wanted to

29
00:01:02,670 --> 00:01:06,869
<font color="#E5E5E5">demonstrate that there was something</font>

30
00:01:04,349 --> 00:01:09,000
useful in this space if we<font color="#CCCCCC"> got to the</font>

31
00:01:06,869 --> 00:01:11,240
sub<font color="#E5E5E5"> Turing environment and we could only</font>

32
00:01:09,000 --> 00:01:13,770
<font color="#E5E5E5">do you know the most trivial of</font>

33
00:01:11,240 --> 00:01:16,320
computations that might not be a very

34
00:01:13,770 --> 00:01:18,149
promising result and so to do this we

35
00:01:16,320 --> 00:01:20,220
created a programming language that

36
00:01:18,150 --> 00:01:25,140
targets<font color="#CCCCCC"> llvm so you can embed it in</font>

37
00:01:20,220 --> 00:01:27,509
existing software and essentially it

38
00:01:25,140 --> 00:01:29,850
won't<font color="#E5E5E5"> let you write a program that is</font>

39
00:01:27,509 --> 00:01:32,369
not provably to halting using both or

40
00:01:29,850 --> 00:01:34,079
recursion<font color="#E5E5E5"> and then we wanted to see what</font>

41
00:01:32,369 --> 00:01:35,460
that space looked like you know I<font color="#E5E5E5"> went</font>

42
00:01:34,079 --> 00:01:37,589
through<font color="#E5E5E5"> and did some of my homework</font>

43
00:01:35,460 --> 00:01:40,048
assignments from undergrad my homework

44
00:01:37,590 --> 00:01:42,659
assignments and then also explored

45
00:01:40,049 --> 00:01:45,270
existing code areas to see you know how

46
00:01:42,659 --> 00:01:48,240
useful was this and then the other<font color="#E5E5E5"> part</font>

47
00:01:45,270 --> 00:01:51,770
was is ok now we have say this will

48
00:01:48,240 --> 00:01:54,240
assume pretty useful space to<font color="#CCCCCC"> in play in</font>

49
00:01:51,770 --> 00:01:57,689
what does that<font color="#E5E5E5"> do with either formal</font>

50
00:01:54,240 --> 00:01:59,640
methods or program analysis and so we

51
00:01:57,689 --> 00:02:01,500
found empirically at least for the

52
00:01:59,640 --> 00:02:04,380
future work would be to show this more

53
00:02:01,500 --> 00:02:06,600
formally that you can analyze software

54
00:02:04,380 --> 00:02:08,818
with more granularity and then also a

55
00:02:06,600 --> 00:02:11,430
larger scale because you're spending

56
00:02:08,818 --> 00:02:13,709
less time on some of these hard problems

57
00:02:11,430 --> 00:02:16,080
and then you have some analyses

58
00:02:13,710 --> 00:02:17,310
that might be undecidable when you bump

59
00:02:16,080 --> 00:02:20,520
into the halting problem or the

60
00:02:17,310 --> 00:02:22,530
undecidability cliff that if you can

61
00:02:20,520 --> 00:02:24,420
kind<font color="#E5E5E5"> of you know rii scope your problem</font>

62
00:02:22,530 --> 00:02:27,270
they might now be possible to do some

63
00:02:24,420 --> 00:02:29,970
analysis I don't think<font color="#CCCCCC"> we need to talk</font>

64
00:02:27,270 --> 00:02:32,460
<font color="#CCCCCC">about weird machines but that's</font><font color="#E5E5E5"> just</font>

65
00:02:29,970 --> 00:02:33,660
<font color="#CCCCCC">their lvm for those you don't</font><font color="#E5E5E5"> know dan</font>

66
00:02:32,460 --> 00:02:35,310
gear mentioned his keynote it's

67
00:02:33,660 --> 00:02:38,100
essentially it's an abstracted

68
00:02:35,310 --> 00:02:40,260
compilation<font color="#E5E5E5"> toolchain you basically</font>

69
00:02:38,100 --> 00:02:42,150
generate assembly code for an<font color="#CCCCCC"> abstract</font>

70
00:02:40,260 --> 00:02:45,179
intermediate representation and<font color="#E5E5E5"> that can</font>

71
00:02:42,150 --> 00:02:47,070
either be just in time compiled it can

72
00:02:45,180 --> 00:02:48,870
be interpreted or can you be compiled to

73
00:02:47,070 --> 00:02:51,269
native code for whatever target you're

74
00:02:48,870 --> 00:02:53,100
facing one of<font color="#E5E5E5"> the nice things about</font>

75
00:02:51,270 --> 00:02:55,470
having things in this intermediate

76
00:02:53,100 --> 00:02:56,519
representation is that<font color="#CCCCCC"> cleese a tool</font>

77
00:02:55,470 --> 00:02:59,490
there's a lot of other<font color="#E5E5E5"> tools out there</font>

78
00:02:56,520 --> 00:03:02,010
they can<font color="#E5E5E5"> do static analysis or symbolic</font>

79
00:02:59,490 --> 00:03:03,090
execution on this kind of abstracted

80
00:03:02,010 --> 00:03:06,149
language where you have a<font color="#E5E5E5"> little bit</font>

81
00:03:03,090 --> 00:03:09,120
more semantic information so CLE was

82
00:03:06,150 --> 00:03:10,950
designed basically to execute most or

83
00:03:09,120 --> 00:03:12,960
all of the code paths looking for

84
00:03:10,950 --> 00:03:15,030
crashes and when they paper<font color="#E5E5E5"> first came</font>

85
00:03:12,960 --> 00:03:17,700
out they're actually able to<font color="#E5E5E5"> find some</font>

86
00:03:15,030 --> 00:03:20,640
unknown bugs and busy box and<font color="#E5E5E5"> some of</font>

87
00:03:17,700 --> 00:03:22,230
the other kind<font color="#E5E5E5"> of cor- utils just</font>

88
00:03:20,640 --> 00:03:26,579
because they never<font color="#E5E5E5"> actually gotten that</font>

89
00:03:22,230 --> 00:03:29,190
test coverage to those<font color="#E5E5E5"> areas so our</font>

90
00:03:26,580 --> 00:03:31,460
problem is it I think the hypothesis was

91
00:03:29,190 --> 00:03:34,440
that full turing-complete languages

92
00:03:31,460 --> 00:03:36,270
similar to that diagram of you know

93
00:03:34,440 --> 00:03:38,520
messages that we accept<font color="#E5E5E5"> versus messages</font>

94
00:03:36,270 --> 00:03:40,140
we want to accept provides more

95
00:03:38,520 --> 00:03:41,520
expressionist than we think most

96
00:03:40,140 --> 00:03:43,920
programmers would need for<font color="#CCCCCC"> a lot of</font>

97
00:03:41,520 --> 00:03:47,460
tasks<font color="#E5E5E5"> and then this kind of gap in</font>

98
00:03:43,920 --> 00:03:49,500
between where<font color="#CCCCCC"> the program expressed</font><font color="#E5E5E5"> an</font>

99
00:03:47,460 --> 00:03:51,030
expressiveness that we want versus what

100
00:03:49,500 --> 00:03:54,780
we<font color="#CCCCCC"> actually have is where these weird</font>

101
00:03:51,030 --> 00:03:56,520
machines and exploits live and so having

102
00:03:54,780 --> 00:03:57,900
<font color="#E5E5E5">more power than you need is kind of like</font>

103
00:03:56,520 --> 00:04:01,590
having<font color="#E5E5E5"> you know more rope to hang</font>

104
00:03:57,900 --> 00:04:03,180
yourself with so the<font color="#CCCCCC"> majority of</font>

105
00:04:01,590 --> 00:04:04,710
general-purpose programming languages

106
00:04:03,180 --> 00:04:06,720
that we've seen out<font color="#CCCCCC"> in the field our</font>

107
00:04:04,710 --> 00:04:09,390
design kind of with Turing completeness

108
00:04:06,720 --> 00:04:12,060
as yet we<font color="#E5E5E5"> got that</font><font color="#CCCCCC"> ticked that box and</font>

109
00:04:09,390 --> 00:04:14,489
<font color="#E5E5E5">now lets you know worry about some other</font>

110
00:04:12,060 --> 00:04:16,019
<font color="#E5E5E5">things about memory safety or making it</font>

111
00:04:14,490 --> 00:04:19,109
look pretty or make it really easy to

112
00:04:16,019 --> 00:04:20,519
parse so that's kind of you know what

113
00:04:19,108 --> 00:04:22,469
<font color="#E5E5E5">everyone seems to do and it's</font><font color="#CCCCCC"> actually</font>

114
00:04:20,519 --> 00:04:24,000
very very<font color="#E5E5E5"> easy to make something Turing</font>

115
00:04:22,470 --> 00:04:25,919
complete and so there's<font color="#E5E5E5"> been some work</font>

116
00:04:24,000 --> 00:04:26,910
from Sergei<font color="#CCCCCC"> and one of</font><font color="#E5E5E5"> his students</font>

117
00:04:25,919 --> 00:04:29,729
showing that extra the

118
00:04:26,910 --> 00:04:32,250
memory management semantics of the x86

119
00:04:29,730 --> 00:04:33,450
platform is and of itself to a complete

120
00:04:32,250 --> 00:04:36,110
without actually executing any

121
00:04:33,450 --> 00:04:38,520
instructions and then there's all the

122
00:04:36,110 --> 00:04:41,130
very small languages that might have

123
00:04:38,520 --> 00:04:46,890
seven operations that can be simulated

124
00:04:41,130 --> 00:04:48,150
<font color="#CCCCCC">Turing machine once you get to that then</font>

125
00:04:46,890 --> 00:04:49,919
you run into also the halting problem

126
00:04:48,150 --> 00:04:52,650
kind<font color="#E5E5E5"> of fall off that undecidability</font>

127
00:04:49,920 --> 00:04:54,870
cliff and now formal methods or program

128
00:04:52,650 --> 00:04:56,669
analysis becomes more difficult and then

129
00:04:54,870 --> 00:05:00,450
also reference monitors kind of lose

130
00:04:56,670 --> 00:05:02,100
some of their power so<font color="#CCCCCC"> similar</font><font color="#E5E5E5"> to the</font>

131
00:05:00,450 --> 00:05:04,530
<font color="#E5E5E5">Lion King you have a circle of</font><font color="#CCCCCC"> life and</font>

132
00:05:02,100 --> 00:05:06,510
<font color="#E5E5E5">Lang sec we have the circle of bugs so</font>

133
00:05:04,530 --> 00:05:09,270
you start off with a complex data format

134
00:05:06,510 --> 00:05:11,490
it requires a complex parser which then

135
00:05:09,270 --> 00:05:13,020
is a hard analysis task and you<font color="#CCCCCC"> have</font>

136
00:05:11,490 --> 00:05:15,480
these undetected bugs or emergent

137
00:05:13,020 --> 00:05:16,919
properties from the weird machines then

138
00:05:15,480 --> 00:05:19,680
you have to put a needs in front of that

139
00:05:16,920 --> 00:05:22,470
witch or a firewall or a fire I type

140
00:05:19,680 --> 00:05:24,990
thing which has some kind of under fit

141
00:05:22,470 --> 00:05:27,840
signature or overfit restrictions and

142
00:05:24,990 --> 00:05:30,930
then to be<font color="#CCCCCC"> able to kind of encapsulate</font>

143
00:05:27,840 --> 00:05:32,909
those extra layer of Defense's you need

144
00:05:30,930 --> 00:05:35,160
to complex data format in your needs and

145
00:05:32,910 --> 00:05:36,990
then it kind of goes around the circle

146
00:05:35,160 --> 00:05:41,160
until you know your<font color="#CCCCCC"> turtles all the way</font>

147
00:05:36,990 --> 00:05:42,630
down I don't<font color="#CCCCCC"> think I need to say this to</font>

148
00:05:41,160 --> 00:05:45,530
this<font color="#E5E5E5"> group but input parsing is</font>

149
00:05:42,630 --> 00:05:49,380
<font color="#CCCCCC">safety-critical you know basically as</font>

150
00:05:45,530 --> 00:05:50,760
<font color="#E5E5E5">dan gear said that you know data is just</font>

151
00:05:49,380 --> 00:05:53,520
attack or controlled code that's being

152
00:05:50,760 --> 00:05:56,849
run on your<font color="#E5E5E5"> system it drives execution</font>

153
00:05:53,520 --> 00:06:01,710
flow and it allows many cases arbitrary

154
00:05:56,850 --> 00:06:05,220
computation predicting the behavior of

155
00:06:01,710 --> 00:06:06,870
this is very very<font color="#CCCCCC"> difficult and then</font>

156
00:06:05,220 --> 00:06:10,380
that makes sense software verification

157
00:06:06,870 --> 00:06:12,540
or validation is much more challenging

158
00:06:10,380 --> 00:06:14,520
and so you get run into this with the

159
00:06:12,540 --> 00:06:17,220
state explosion of trying to be able to

160
00:06:14,520 --> 00:06:19,200
<font color="#E5E5E5">find counter examples and you know</font>

161
00:06:17,220 --> 00:06:21,540
problematically you can't be able to

162
00:06:19,200 --> 00:06:27,270
kind of suss out all the bugs that<font color="#E5E5E5"> may</font>

163
00:06:21,540 --> 00:06:30,480
<font color="#E5E5E5">be in your software so this is yeah</font>

164
00:06:27,270 --> 00:06:32,370
Chomsky hierarchy basically so what do

165
00:06:30,480 --> 00:06:33,930
we do so<font color="#E5E5E5"> we developed an open-source</font>

166
00:06:32,370 --> 00:06:35,970
proof-of-concept language that

167
00:06:33,930 --> 00:06:38,550
specifically every program you write

168
00:06:35,970 --> 00:06:39,990
will terminate which you can embed in

169
00:06:38,550 --> 00:06:41,910
other programs so

170
00:06:39,990 --> 00:06:43,770
it targets<font color="#E5E5E5"> lvm so you'd be able</font><font color="#CCCCCC"> to write</font>

171
00:06:41,910 --> 00:06:45,960
<font color="#E5E5E5">a c program so say if</font><font color="#CCCCCC"> you were writing a</font>

172
00:06:43,770 --> 00:06:47,969
PDF<font color="#E5E5E5"> reader you'd be</font><font color="#CCCCCC"> able to write the</font>

173
00:06:45,960 --> 00:06:49,650
parsing routines itself that go<font color="#E5E5E5"> from</font>

174
00:06:47,970 --> 00:06:52,920
your input packets to your structured

175
00:06:49,650 --> 00:06:54,390
kind of types data in something like

176
00:06:52,920 --> 00:06:55,770
crema because you never want<font color="#E5E5E5"> to be able</font>

177
00:06:54,390 --> 00:06:57,930
to parse something that will run forever

178
00:06:55,770 --> 00:07:00,030
that would be very<font color="#E5E5E5"> bad to be parsing a</font>

179
00:06:57,930 --> 00:07:02,070
PDF and<font color="#E5E5E5"> never actually displaying it and</font>

180
00:07:00,030 --> 00:07:04,739
then you'd be able to<font color="#E5E5E5"> pass that</font><font color="#CCCCCC"> off once</font>

181
00:07:02,070 --> 00:07:06,780
it's kind of in structured data form to

182
00:07:04,740 --> 00:07:08,070
a display or some other<font color="#CCCCCC"> application that</font>

183
00:07:06,780 --> 00:07:09,599
allows<font color="#CCCCCC"> the user to interact with</font><font color="#E5E5E5"> it</font>

184
00:07:08,070 --> 00:07:14,070
without terminating after say five

185
00:07:09,600 --> 00:07:16,620
minutes so this could be used as a

186
00:07:14,070 --> 00:07:19,980
parser bridge from<font color="#CCCCCC"> the untrusted world</font>

187
00:07:16,620 --> 00:07:21,960
into<font color="#CCCCCC"> the formal type system and so we're</font>

188
00:07:19,980 --> 00:07:23,460
looking at these kind of bridges that

189
00:07:21,960 --> 00:07:26,039
<font color="#E5E5E5">we're able to kind of reimplement in</font>

190
00:07:23,460 --> 00:07:27,299
crema as either transducers or parsers

191
00:07:26,040 --> 00:07:29,250
that essentially convert kind of

192
00:07:27,300 --> 00:07:31,650
untrusted input into structured data

193
00:07:29,250 --> 00:07:33,990
which<font color="#CCCCCC"> is then input in a slightly more</font>

194
00:07:31,650 --> 00:07:38,400
sanitized version to the<font color="#E5E5E5"> main program</font>

195
00:07:33,990 --> 00:07:40,110
body we then explored this sub

196
00:07:38,400 --> 00:07:42,030
turing-complete space to kind of with a

197
00:07:40,110 --> 00:07:44,130
lang<font color="#CCCCCC"> SEC legs and seeing is this</font>

198
00:07:42,030 --> 00:07:46,890
something of value are there benefits

199
00:07:44,130 --> 00:07:49,530
from this you know when some<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the</font>

200
00:07:46,890 --> 00:07:50,969
amazing you know immediate benefits your

201
00:07:49,530 --> 00:07:52,109
power<font color="#CCCCCC"> is limited you're giving to the</font>

202
00:07:50,970 --> 00:07:53,700
attacker because you're giving yourself

203
00:07:52,110 --> 00:07:56,790
less power<font color="#E5E5E5"> and so that right there</font><font color="#CCCCCC"> is</font>

204
00:07:53,700 --> 00:07:58,320
pretty<font color="#E5E5E5"> intuitive and then also we wanted</font>

205
00:07:56,790 --> 00:08:01,530
to see how<font color="#CCCCCC"> if you didn't</font><font color="#E5E5E5"> have a halting</font>

206
00:07:58,320 --> 00:08:04,680
problem what are the weird machines like

207
00:08:01,530 --> 00:08:07,130
in<font color="#E5E5E5"> that area and finally we wanted</font><font color="#CCCCCC"> to</font>

208
00:08:04,680 --> 00:08:10,230
look at program analysis improvements so

209
00:08:07,130 --> 00:08:13,230
can<font color="#E5E5E5"> we look at code more granularly can</font>

210
00:08:10,230 --> 00:08:15,600
we look at larger amounts of code can we

211
00:08:13,230 --> 00:08:18,150
you know simplify the problems going<font color="#E5E5E5"> to</font>

212
00:08:15,600 --> 00:08:19,820
<font color="#E5E5E5">your smt solver you know saying</font><font color="#CCCCCC"> CLE to</font>

213
00:08:18,150 --> 00:08:22,289
be able<font color="#E5E5E5"> to kind of verify those</font>

214
00:08:19,820 --> 00:08:23,909
constraints your paths and we can you

215
00:08:22,290 --> 00:08:25,830
make those easier so you can essentially

216
00:08:23,910 --> 00:08:27,570
touch more of your code as we're

217
00:08:25,830 --> 00:08:29,669
generating code and now that machines

218
00:08:27,570 --> 00:08:31,260
are generating code being<font color="#E5E5E5"> able to be</font>

219
00:08:29,670 --> 00:08:33,900
able to verify that code becomes

220
00:08:31,260 --> 00:08:36,000
increasingly important it was<font color="#CCCCCC"> very scary</font>

221
00:08:33,900 --> 00:08:40,079
<font color="#E5E5E5">to hear that machine generated code</font>

222
00:08:36,000 --> 00:08:43,260
already<font color="#CCCCCC"> has vulnerabilities in it so so</font>

223
00:08:40,080 --> 00:08:45,840
results there's a link I'll tweet that

224
00:08:43,260 --> 00:08:48,330
out it's<font color="#CCCCCC"> just at Jacob Tory but it's</font>

225
00:08:45,840 --> 00:08:50,490
<font color="#CCCCCC">open-source play with</font><font color="#E5E5E5"> it please submit</font>

226
00:08:48,330 --> 00:08:50,810
pull<font color="#CCCCCC"> request submit bug reports</font><font color="#E5E5E5"> anything</font>

227
00:08:50,490 --> 00:08:54,340
like

228
00:08:50,810 --> 00:08:57,529
it's designed<font color="#E5E5E5"> to be fairly easy to use</font>

229
00:08:54,340 --> 00:09:00,320
and it's capable of most with<font color="#E5E5E5"> an asterix</font>

230
00:08:57,529 --> 00:09:01,970
programming tasks if you're<font color="#E5E5E5"> thinking</font>

231
00:09:00,320 --> 00:09:05,060
about<font color="#E5E5E5"> it</font><font color="#CCCCCC"> for this input driven</font>

232
00:09:01,970 --> 00:09:06,620
computation there are some existing kind

233
00:09:05,060 --> 00:09:08,359
of sub Turing languages out there that

234
00:09:06,620 --> 00:09:10,670
were written kind of from academic

235
00:09:08,360 --> 00:09:14,060
perspective but they're not very

236
00:09:10,670 --> 00:09:15,860
intuitive and so you know back coming

237
00:09:14,060 --> 00:09:18,619
back<font color="#E5E5E5"> to the keynote when you say you</font>

238
00:09:15,860 --> 00:09:22,100
have some<font color="#E5E5E5"> of</font><font color="#CCCCCC"> these capabilities and</font>

239
00:09:18,620 --> 00:09:23,750
compilers that are for experts they're

240
00:09:22,100 --> 00:09:25,490
going<font color="#E5E5E5"> to get either misused or they're</font>

241
00:09:23,750 --> 00:09:27,860
<font color="#CCCCCC">not going to</font><font color="#E5E5E5"> be able to be understood by</font>

242
00:09:25,490 --> 00:09:29,990
the averaged a person who is<font color="#CCCCCC"> moving a</font>

243
00:09:27,860 --> 00:09:31,550
bit from one computer to another so we

244
00:09:29,990 --> 00:09:37,300
wanted to make<font color="#E5E5E5"> this as approachable as</font>

245
00:09:31,550 --> 00:09:37,300
we could and<font color="#E5E5E5"> then also we took DJ B's</font>

246
00:09:37,600 --> 00:09:46,910
smtp<font color="#CCCCCC"> Q mail and we when he</font><font color="#E5E5E5"> built that</font>

247
00:09:44,900 --> 00:09:49,279
software it's actually a<font color="#CCCCCC"> very great</font>

248
00:09:46,910 --> 00:09:51,680
model of secure programming he actually

249
00:09:49,279 --> 00:09:55,310
kind of identified back many many years

250
00:09:51,680 --> 00:09:56,810
ago<font color="#CCCCCC"> that the parsing elements are the</font>

251
00:09:55,310 --> 00:09:58,640
dangerous parts and so actually that's a

252
00:09:56,810 --> 00:10:00,650
<font color="#E5E5E5">separate program there's a separate</font>

253
00:09:58,640 --> 00:10:02,420
process that does the parsing and many

254
00:10:00,650 --> 00:10:04,220
has a very very<font color="#CCCCCC"> simple kind</font><font color="#E5E5E5"> of</font>

255
00:10:02,420 --> 00:10:06,260
translation language between that

256
00:10:04,220 --> 00:10:09,800
process and the process<font color="#E5E5E5"> that does the</font>

257
00:10:06,260 --> 00:10:12,770
actual kind of<font color="#E5E5E5"> mail work and what we did</font>

258
00:10:09,800 --> 00:10:14,810
was is we took that and we ran<font color="#CCCCCC"> that</font>

259
00:10:12,770 --> 00:10:17,480
through<font color="#E5E5E5"> CLE and then we also wrote</font>

260
00:10:14,810 --> 00:10:19,670
rewrote that same parser in crema to see

261
00:10:17,480 --> 00:10:23,990
how we compare so that's what I'll get

262
00:10:19,670 --> 00:10:26,120
into in a little bit so this<font color="#CCCCCC"> is a you</font>

263
00:10:23,990 --> 00:10:27,230
know fairly simple the syntax you know

264
00:10:26,120 --> 00:10:30,530
some<font color="#CCCCCC"> of the stuff is</font><font color="#E5E5E5"> going to get</font>

265
00:10:27,230 --> 00:10:33,320
cleaned up but you know it's fairly

266
00:10:30,530 --> 00:10:36,410
understandable right there this is the

267
00:10:33,320 --> 00:10:39,650
fizzbuzz but I have more examples as

268
00:10:36,410 --> 00:10:41,390
well if<font color="#CCCCCC"> people are interested later so</font>

269
00:10:39,650 --> 00:10:43,100
I'm not<font color="#CCCCCC"> sure if this yeah good you can</font>

270
00:10:41,390 --> 00:10:47,830
see the graph so if you look here the

271
00:10:43,100 --> 00:10:50,839
number<font color="#E5E5E5"> of paths to search in a kind of</font>

272
00:10:47,830 --> 00:10:52,580
untapped or unbounded they grow much

273
00:10:50,839 --> 00:10:54,830
quicker and they're much higher<font color="#CCCCCC"> than in</font>

274
00:10:52,580 --> 00:10:56,330
<font color="#E5E5E5">the lower one so the red would be just</font>

275
00:10:54,830 --> 00:10:59,060
kind of overall past and then the

276
00:10:56,330 --> 00:11:02,089
trimmed paths when you kind<font color="#E5E5E5"> of can</font><font color="#CCCCCC"> you</font>

277
00:10:59,060 --> 00:11:03,920
know tell the verifier or the analysis

278
00:11:02,089 --> 00:11:04,640
program that yes this program will heart

279
00:11:03,920 --> 00:11:06,400
halt

280
00:11:04,640 --> 00:11:09,560
and this is the maximum<font color="#CCCCCC"> amount of state</font>

281
00:11:06,400 --> 00:11:13,100
what we did in the paper is we showed it

282
00:11:09,560 --> 00:11:15,770
is<font color="#E5E5E5"> almost a just-in-time loop unrolling</font>

283
00:11:13,100 --> 00:11:17,240
and that you can<font color="#CCCCCC"> kind of imagine an</font>

284
00:11:15,770 --> 00:11:18,890
intuitive program where if you know the

285
00:11:17,240 --> 00:11:20,600
size of your input<font color="#CCCCCC"> coming</font><font color="#E5E5E5"> in which is</font><font color="#CCCCCC"> a</font>

286
00:11:18,890 --> 00:11:23,390
requirement or at least to be able<font color="#E5E5E5"> to</font>

287
00:11:20,600 --> 00:11:25,130
compute that in polynomial time you'd be

288
00:11:23,390 --> 00:11:28,220
able<font color="#E5E5E5"> to kind of create a forward only</font>

289
00:11:25,130 --> 00:11:29,990
execution environment that will then be

290
00:11:28,220 --> 00:11:32,180
able<font color="#CCCCCC"> to just by counting the number of</font>

291
00:11:29,990 --> 00:11:34,040
branches be able to kind of make a

292
00:11:32,180 --> 00:11:37,430
concrete understanding of how<font color="#CCCCCC"> many</font>

293
00:11:34,040 --> 00:11:39,260
states there are two search and so you

294
00:11:37,430 --> 00:11:41,120
can kind of use this and we talked about

295
00:11:39,260 --> 00:11:42,710
<font color="#E5E5E5">kind of a modified</font><font color="#CCCCCC"> Turing machine in the</font>

296
00:11:41,120 --> 00:11:46,460
paper which<font color="#CCCCCC"> is a little</font><font color="#E5E5E5"> beyond the scope</font>

297
00:11:42,710 --> 00:11:47,840
this<font color="#E5E5E5"> 25-minute talk but how you can kind</font>

298
00:11:46,460 --> 00:11:49,970
<font color="#E5E5E5">of work your way there from the other</font>

299
00:11:47,840 --> 00:11:54,080
side to show that there's some trimmed

300
00:11:49,970 --> 00:11:58,850
paths that are much much smaller and

301
00:11:54,080 --> 00:12:01,430
<font color="#E5E5E5">easier to solve looking here is a</font>

302
00:11:58,850 --> 00:12:04,940
function of time<font color="#E5E5E5"> basically you'll see</font>

303
00:12:01,430 --> 00:12:06,560
the red line is we ran Klee for a couple

304
00:12:04,940 --> 00:12:08,540
number of seconds and then stopped<font color="#E5E5E5"> and</font>

305
00:12:06,560 --> 00:12:10,699
then these<font color="#CCCCCC"> are the number of paths and</font>

306
00:12:08,540 --> 00:12:12,620
the red line with the unrestricted that

307
00:12:10,700 --> 00:12:14,770
had to be able<font color="#E5E5E5"> to search it it queued up</font>

308
00:12:12,620 --> 00:12:18,350
for the<font color="#CCCCCC"> SMT solver to start looking at</font>

309
00:12:14,770 --> 00:12:20,600
versus the blue line which<font color="#CCCCCC"> is</font><font color="#E5E5E5"> the number</font>

310
00:12:18,350 --> 00:12:22,820
<font color="#CCCCCC">of restricted paths that it</font><font color="#E5E5E5"> queued up to</font>

311
00:12:20,600 --> 00:12:24,260
solve so CLE we actually got some weird

312
00:12:22,820 --> 00:12:28,130
results here which we'll talk about in a

313
00:12:24,260 --> 00:12:29,900
moment that essentially it starts by

314
00:12:28,130 --> 00:12:31,550
kind of finding all the paths and then

315
00:12:29,900 --> 00:12:33,620
the ones that it finds interesting it

316
00:12:31,550 --> 00:12:35,870
creates and passes it off to an smt

317
00:12:33,620 --> 00:12:38,420
solver to kind of create a conversion

318
00:12:35,870 --> 00:12:40,520
from the symbolic constraints to a<font color="#E5E5E5"> real</font>

319
00:12:38,420 --> 00:12:42,319
<font color="#E5E5E5">world example and that's kind of where a</font>

320
00:12:40,520 --> 00:12:44,900
lot of the processing time comes from

321
00:12:42,320 --> 00:12:46,970
and so even though we<font color="#E5E5E5"> didn't run the</font>

322
00:12:44,900 --> 00:12:49,189
program for very<font color="#E5E5E5"> very long it still had</font>

323
00:12:46,970 --> 00:12:51,350
kind of a huge work queue for it to be

324
00:12:49,190 --> 00:12:54,800
doing and much much larger in the

325
00:12:51,350 --> 00:12:57,110
unrestricted<font color="#CCCCCC"> State our instruction</font>

326
00:12:54,800 --> 00:12:58,760
coverage as a function of time<font color="#CCCCCC"> also if</font>

327
00:12:57,110 --> 00:13:01,190
you only run<font color="#E5E5E5"> Klee for a very small</font>

328
00:12:58,760 --> 00:13:03,380
<font color="#CCCCCC">amount of time you get a slightly better</font>

329
00:13:01,190 --> 00:13:05,510
instruction coverage one thing to note

330
00:13:03,380 --> 00:13:07,520
about<font color="#E5E5E5"> this is if you write the program</font>

331
00:13:05,510 --> 00:13:10,069
hello world and<font color="#E5E5E5"> you run it in CLE you</font>

332
00:13:07,520 --> 00:13:12,740
only get<font color="#E5E5E5"> about twenty</font><font color="#CCCCCC"> percent code</font>

333
00:13:10,070 --> 00:13:15,590
coverage just<font color="#E5E5E5"> because printf has so many</font>

334
00:13:12,740 --> 00:13:18,259
paths that you can't<font color="#E5E5E5"> really complain</font><font color="#CCCCCC"> ok</font>

335
00:13:15,590 --> 00:13:20,720
explore if you don't put some

336
00:13:18,259 --> 00:13:22,910
input into it and so that's why you're

337
00:13:20,720 --> 00:13:24,079
kind of seeing this cap and it's kind of

338
00:13:22,910 --> 00:13:25,759
running out<font color="#CCCCCC"> because there's just so many</font>

339
00:13:24,079 --> 00:13:27,618
library functions that aren't<font color="#E5E5E5"> going to</font>

340
00:13:25,759 --> 00:13:30,019
be able to be explored unless you can

341
00:13:27,619 --> 00:13:33,109
specifically tell<font color="#CCCCCC"> CLE to start</font><font color="#E5E5E5"> making</font>

342
00:13:30,019 --> 00:13:34,910
those inputs as symbolic but if you do

343
00:13:33,109 --> 00:13:41,179
that then you<font color="#E5E5E5"> start getting a much more</font>

344
00:13:34,910 --> 00:13:44,839
increased you know time to suss out so

345
00:13:41,179 --> 00:13:47,539
we wrote the<font color="#E5E5E5"> Q mail parser and then in</font>

346
00:13:44,839 --> 00:13:50,269
the crema parser the instruction

347
00:13:47,539 --> 00:13:52,339
coverage was quite a bit higher and the

348
00:13:50,269 --> 00:13:54,819
number of states that<font color="#E5E5E5"> it had to explore</font>

349
00:13:52,339 --> 00:13:57,739
was quite a bit higher in sorry so

350
00:13:54,819 --> 00:14:00,889
coverage was higher in crema<font color="#CCCCCC"> states was</font>

351
00:13:57,739 --> 00:14:02,419
higher in the<font color="#CCCCCC"> see the execution times</font>

352
00:14:00,889 --> 00:14:04,369
are<font color="#CCCCCC"> about the same because of that</font>

353
00:14:02,419 --> 00:14:07,459
queuing we pretty much<font color="#E5E5E5"> just told it to</font>

354
00:14:04,369 --> 00:14:10,160
run for about 30 seconds so in<font color="#E5E5E5"> that 30</font>

355
00:14:07,459 --> 00:14:11,779
seconds what was happening here was is

356
00:14:10,160 --> 00:14:14,179
<font color="#CCCCCC">that it had queued up quite a bit more</font>

357
00:14:11,779 --> 00:14:16,699
to go<font color="#E5E5E5"> to the SMT solver which is why in</font>

358
00:14:14,179 --> 00:14:18,679
<font color="#E5E5E5">the sea version it wasn't able to go and</font>

359
00:14:16,699 --> 00:14:20,449
cover<font color="#E5E5E5"> all those instructions whereas</font>

360
00:14:18,679 --> 00:14:22,309
with crema since it had fewer<font color="#E5E5E5"> states to</font>

361
00:14:20,449 --> 00:14:23,660
go to in the<font color="#CCCCCC"> beginning it was able to</font>

362
00:14:22,309 --> 00:14:29,539
actually complete a lot<font color="#E5E5E5"> more of those</font>

363
00:14:23,660 --> 00:14:32,449
right from<font color="#E5E5E5"> the get-go so</font><font color="#CCCCCC"> Frank Schneider</font>

364
00:14:29,539 --> 00:14:34,220
has a good definition of reference

365
00:14:32,449 --> 00:14:36,789
monitors which are<font color="#CCCCCC"> utama tins that</font>

366
00:14:34,220 --> 00:14:39,139
recognize a language of events and

367
00:14:36,789 --> 00:14:41,839
currently they're prefix based in the

368
00:14:39,139 --> 00:14:44,299
sense that they can only identify bad

369
00:14:41,839 --> 00:14:45,859
sequences of events and then after that

370
00:14:44,299 --> 00:14:47,749
<font color="#E5E5E5">kind of they have to say all right well</font>

371
00:14:45,859 --> 00:14:50,359
this prefix I know is bad i'm going to

372
00:14:47,749 --> 00:14:51,799
stop that so if you have a walther

373
00:14:50,359 --> 00:14:53,600
recursive model you<font color="#E5E5E5"> can actually</font>

374
00:14:51,799 --> 00:14:55,399
strengthen that to look at something

375
00:14:53,600 --> 00:14:57,709
beyond prefix only you could actually

376
00:14:55,399 --> 00:14:59,749
look at an entire execution unit or

377
00:14:57,709 --> 00:15:01,429
computation and<font color="#E5E5E5"> you'd be able to</font>

378
00:14:59,749 --> 00:15:02,809
determine on that because you<font color="#CCCCCC"> know that</font>

379
00:15:01,429 --> 00:15:05,059
your program is going<font color="#E5E5E5"> to terminate a</font>

380
00:15:02,809 --> 00:15:06,589
certain point of time and then if it is

381
00:15:05,059 --> 00:15:08,419
still running<font color="#E5E5E5"> after that you</font><font color="#CCCCCC"> know that</font>

382
00:15:06,589 --> 00:15:10,100
something<font color="#CCCCCC"> has gone awry and</font><font color="#E5E5E5"> so with that</font>

383
00:15:08,419 --> 00:15:12,109
you<font color="#CCCCCC"> can actually</font><font color="#E5E5E5"> create much more</font>

384
00:15:10,100 --> 00:15:15,019
stronger reference monitors this is kind

385
00:15:12,109 --> 00:15:16,970
of<font color="#E5E5E5"> analogous to your antivirus software</font>

386
00:15:15,019 --> 00:15:18,919
running in kernel space and it's very

387
00:15:16,970 --> 00:15:20,899
good against maybe your user space

388
00:15:18,919 --> 00:15:22,519
malware but as soon<font color="#E5E5E5"> as the malware gets</font>

389
00:15:20,899 --> 00:15:23,839
into kernel space it kind of loses that

390
00:15:22,519 --> 00:15:26,029
power and so this<font color="#CCCCCC"> is kind of an</font>

391
00:15:23,839 --> 00:15:27,980
analogous jump where if your reference

392
00:15:26,029 --> 00:15:30,109
monitor has the full power and you're

393
00:15:27,980 --> 00:15:32,220
restricting what's its monitoring you

394
00:15:30,109 --> 00:15:35,080
have some advantages there

395
00:15:32,220 --> 00:15:40,330
so what we're<font color="#CCCCCC"> trying to do break the</font>

396
00:15:35,080 --> 00:15:42,520
cycle of complexity hopefully work

397
00:15:40,330 --> 00:15:45,550
towards verifying software out of the

398
00:15:42,520 --> 00:15:47,530
range for contemporary methods you know

399
00:15:45,550 --> 00:15:49,900
limiting the the risk through poor

400
00:15:47,530 --> 00:15:52,180
programming practices so you know in

401
00:15:49,900 --> 00:15:54,750
crema it's very difficult to write a

402
00:15:52,180 --> 00:15:57,699
program that would have some of these

403
00:15:54,750 --> 00:15:59,470
vulnerabilities in it and then be<font color="#E5E5E5"> able</font>

404
00:15:57,700 --> 00:16:02,280
to<font color="#E5E5E5"> provide some empirical data on these</font>

405
00:15:59,470 --> 00:16:06,220
<font color="#CCCCCC">models so we want</font><font color="#E5E5E5"> to do in the future</font>

406
00:16:02,280 --> 00:16:09,400
well we want<font color="#E5E5E5"> to look at you</font><font color="#CCCCCC"> know going</font>

407
00:16:06,220 --> 00:16:11,290
<font color="#E5E5E5">and pushing it down even further so lvm</font>

408
00:16:09,400 --> 00:16:14,199
yeah in the intermediate representation

409
00:16:11,290 --> 00:16:17,050
is kind of a full you know<font color="#E5E5E5"> full powered</font>

410
00:16:14,200 --> 00:16:18,760
environment and so the attacker might

411
00:16:17,050 --> 00:16:20,410
still be able<font color="#E5E5E5"> to inject intermediate</font>

412
00:16:18,760 --> 00:16:22,240
representation code which kind of can

413
00:16:20,410 --> 00:16:24,790
break out of this you know

414
00:16:22,240 --> 00:16:27,130
expressiveness jail so this could<font color="#E5E5E5"> be</font>

415
00:16:24,790 --> 00:16:30,160
done either as<font color="#CCCCCC"> FPGA or maybe a</font>

416
00:16:27,130 --> 00:16:32,680
customizable CPU environment so as I

417
00:16:30,160 --> 00:16:34,600
said we kind of mentioned a CPU

418
00:16:32,680 --> 00:16:37,420
environment what you can enforce kind of

419
00:16:34,600 --> 00:16:39,640
forward only execution of pre loop and

420
00:16:37,420 --> 00:16:41,260
rolled programs and then that would

421
00:16:39,640 --> 00:16:44,560
allow you to bring the crime of benefits

422
00:16:41,260 --> 00:16:46,270
<font color="#E5E5E5">to both hardware and embedded we also</font>

423
00:16:44,560 --> 00:16:48,819
look at more powerful formal methods

424
00:16:46,270 --> 00:16:50,710
tools so you<font color="#CCCCCC"> know what might be possible</font>

425
00:16:48,820 --> 00:16:52,840
now if you kind<font color="#E5E5E5"> of have these</font>

426
00:16:50,710 --> 00:16:55,840
assumptions for these restricted

427
00:16:52,840 --> 00:16:57,100
computation environments that before you

428
00:16:55,840 --> 00:17:01,900
kind of had<font color="#CCCCCC"> to just assume we're</font>

429
00:16:57,100 --> 00:17:04,959
infeasible this was one that<font color="#CCCCCC"> Sergey came</font>

430
00:17:01,900 --> 00:17:06,520
up with looking<font color="#E5E5E5"> at using some static</font>

431
00:17:04,959 --> 00:17:08,650
<font color="#E5E5E5">analysis that at some point if</font><font color="#CCCCCC"> the</font>

432
00:17:06,520 --> 00:17:10,300
program gets too complicated or you see

433
00:17:08,650 --> 00:17:12,430
that this is something<font color="#CCCCCC"> that is very</font>

434
00:17:10,300 --> 00:17:13,990
safety critical you might be able<font color="#E5E5E5"> to</font>

435
00:17:12,430 --> 00:17:16,300
tell the programmer actually I prefer if

436
00:17:13,990 --> 00:17:17,920
<font color="#E5E5E5">you rewrote this in something like crema</font>

437
00:17:16,300 --> 00:17:21,430
so we can actually<font color="#E5E5E5"> analyze this a little</font>

438
00:17:17,920 --> 00:17:24,040
bit better which kind<font color="#CCCCCC"> of is a</font><font color="#E5E5E5"> sidestep</font>

439
00:17:21,430 --> 00:17:26,920
around you know obviously automatic

440
00:17:24,040 --> 00:17:29,889
conversion so also in future work is

441
00:17:26,920 --> 00:17:31,210
there some kind<font color="#CCCCCC"> of heuristic automatic</font>

442
00:17:29,890 --> 00:17:33,250
source conversion or at least ways to

443
00:17:31,210 --> 00:17:36,760
detect regions that have code that could

444
00:17:33,250 --> 00:17:38,260
be done so when Nick did it<font color="#E5E5E5"> scl for they</font>

445
00:17:36,760 --> 00:17:40,300
did a lot of this manually where they're

446
00:17:38,260 --> 00:17:42,640
kind of manually partitioning the Turing

447
00:17:40,300 --> 00:17:44,200
complete and the<font color="#E5E5E5"> sub Turing as there are</font>

448
00:17:42,640 --> 00:17:46,649
some tools<font color="#E5E5E5"> that we could do to</font><font color="#CCCCCC"> help</font>

449
00:17:44,200 --> 00:17:48,909
so that's an area of future work and

450
00:17:46,649 --> 00:17:50,590
then obviously if there's some that are

451
00:17:48,909 --> 00:17:52,690
very obviously turing-complete like an

452
00:17:50,590 --> 00:17:55,389
operating schedule loop or the<font color="#CCCCCC"> Apache</font>

453
00:17:52,690 --> 00:17:56,919
you know<font color="#E5E5E5"> request loop or there are some</font>

454
00:17:55,389 --> 00:18:00,158
areas where maybe a human is needed to

455
00:17:56,919 --> 00:18:01,840
<font color="#CCCCCC">be able</font><font color="#E5E5E5"> to make</font><font color="#CCCCCC"> that determination we</font>

456
00:18:00,159 --> 00:18:02,980
want to be able to identify<font color="#E5E5E5"> these input</font>

457
00:18:01,840 --> 00:18:04,899
driven codes these transducers

458
00:18:02,980 --> 00:18:06,990
automatically so that<font color="#E5E5E5"> would be able</font><font color="#CCCCCC"> to</font>

459
00:18:04,899 --> 00:18:12,189
at least put bounds on what needs<font color="#E5E5E5"> to be</font>

460
00:18:06,990 --> 00:18:14,950
looked at hammer is a kind of parser

461
00:18:12,190 --> 00:18:16,929
generation tool looking and it also has

462
00:18:14,950 --> 00:18:19,529
kind of some built-in reference

463
00:18:16,929 --> 00:18:21,730
implementations of former formal parsers

464
00:18:19,529 --> 00:18:23,200
is there some<font color="#CCCCCC"> way that we could port</font>

465
00:18:21,730 --> 00:18:24,760
some of that to crema and then that

466
00:18:23,200 --> 00:18:27,130
<font color="#E5E5E5">might get us some extra verification</font>

467
00:18:24,760 --> 00:18:28,000
benefits and then<font color="#E5E5E5"> obviously for cle you</font>

468
00:18:27,130 --> 00:18:30,850
know one of the things that would really

469
00:18:28,000 --> 00:18:33,010
help if we could solve P equals NP that

470
00:18:30,850 --> 00:18:35,500
would really reduce the time for smt

471
00:18:33,010 --> 00:18:37,570
solving so that's a good<font color="#CCCCCC"> a thesis</font>

472
00:18:35,500 --> 00:18:40,690
project if anyone out there is looking

473
00:18:37,570 --> 00:18:45,789
<font color="#E5E5E5">for something I'll be happy to put my</font>

474
00:18:40,690 --> 00:18:47,529
name on that<font color="#E5E5E5"> paper so we wanted to look</font>

475
00:18:45,789 --> 00:18:49,629
at programming<font color="#E5E5E5"> language development from</font>

476
00:18:47,529 --> 00:18:51,340
the bottom up of what tools do we need

477
00:18:49,630 --> 00:18:53,559
and how can<font color="#E5E5E5"> we</font><font color="#CCCCCC"> make a set that covers</font>

478
00:18:51,340 --> 00:18:55,029
that rather than here's all the power

479
00:18:53,559 --> 00:18:58,720
<font color="#E5E5E5">that our computers kind of replicate</font>

480
00:18:55,029 --> 00:19:00,190
today as<font color="#E5E5E5"> being kind of pseudo Turing</font>

481
00:18:58,720 --> 00:19:02,620
machines obviously they don't<font color="#E5E5E5"> have</font>

482
00:19:00,190 --> 00:19:04,659
unlimited RAM and eventually the<font color="#E5E5E5"> Sun is</font>

483
00:19:02,620 --> 00:19:06,908
going<font color="#E5E5E5"> to explode so all programs will</font>

484
00:19:04,659 --> 00:19:10,169
terminate currently but something a

485
00:19:06,909 --> 00:19:12,539
little bit more tractable to<font color="#E5E5E5"> now analyze</font>

486
00:19:10,169 --> 00:19:14,830
so we're looking<font color="#CCCCCC"> for that sweet spot and</font>

487
00:19:12,539 --> 00:19:16,330
we think<font color="#E5E5E5"> that that's kind of this</font>

488
00:19:14,830 --> 00:19:19,840
reduced complexity is really the<font color="#CCCCCC"> only</font>

489
00:19:16,330 --> 00:19:21,668
safe method for input driven programs we

490
00:19:19,840 --> 00:19:24,549
wanted<font color="#CCCCCC"> to look at these environments and</font>

491
00:19:21,669 --> 00:19:26,350
then also looking at capabilities for

492
00:19:24,549 --> 00:19:29,710
formal methods and seeing how we could

493
00:19:26,350 --> 00:19:31,360
reduce<font color="#CCCCCC"> the state space growth so I like</font>

494
00:19:29,710 --> 00:19:34,179
<font color="#CCCCCC">to thank DARPA for funding some of this</font>

495
00:19:31,360 --> 00:19:36,039
work and dr.<font color="#E5E5E5"> John efforts back there and</font>

496
00:19:34,179 --> 00:19:38,169
then also thanks to some folks that

497
00:19:36,039 --> 00:19:41,279
helped with the ideas Julian<font color="#CCCCCC"> Sergey and</font>

498
00:19:38,169 --> 00:19:44,380
hover and with that<font color="#E5E5E5"> I</font><font color="#CCCCCC"> think we can go to</font>

499
00:19:41,279 --> 00:19:46,649
questions and discussion let's<font color="#CCCCCC"> think our</font>

500
00:19:44,380 --> 00:19:46,649
speaker

501
00:19:51,840 --> 00:20:04,470
hi spin<font color="#CCCCCC"> hauberk I one idea I had during</font>

502
00:19:58,150 --> 00:20:09,010
your talk was what if if weird machines

503
00:20:04,470 --> 00:20:11,500
that we're worried about our<font color="#E5E5E5"> our sub</font>

504
00:20:09,010 --> 00:20:17,620
touring which I imagine lots of them

505
00:20:11,500 --> 00:20:19,420
might be and so if if we are looking at

506
00:20:17,620 --> 00:20:21,280
things from<font color="#E5E5E5"> lang</font><font color="#CCCCCC"> sac perspective and</font>

507
00:20:19,420 --> 00:20:24,820
saying well we want all our languages to

508
00:20:21,280 --> 00:20:27,790
be at the worst context-free and so on

509
00:20:24,820 --> 00:20:31,330
and so forth we may<font color="#E5E5E5"> be may be</font>

510
00:20:27,790 --> 00:20:33,190
restricting our view a little with

511
00:20:31,330 --> 00:20:36,280
respect to the dark<font color="#E5E5E5"> computation that Dan</font>

512
00:20:33,190 --> 00:20:38,400
was talking about in his keynote so do

513
00:20:36,280 --> 00:20:40,960
we<font color="#E5E5E5"> do we just have to look look out</font>

514
00:20:38,400 --> 00:20:44,020
whether there is dark computation out

515
00:20:40,960 --> 00:20:47,560
there that is sub tearing and how do we

516
00:20:44,020 --> 00:20:49,900
<font color="#E5E5E5">find it what's your take yeah so</font>

517
00:20:47,560 --> 00:20:52,300
certainly you know a lot of<font color="#E5E5E5"> those small</font>

518
00:20:49,900 --> 00:20:53,710
bugs come from memory computation you

519
00:20:52,300 --> 00:20:55,570
know just flipping a single bit or a

520
00:20:53,710 --> 00:20:57,850
bite would be the<font color="#E5E5E5"> entire shell code</font>

521
00:20:55,570 --> 00:21:01,320
which<font color="#CCCCCC"> is obviously you</font><font color="#E5E5E5"> know that would</font>

522
00:20:57,850 --> 00:21:04,659
terminate quite quickly so<font color="#E5E5E5"> I think no</font>

523
00:21:01,320 --> 00:21:06,550
getting to that point this is a step in

524
00:21:04,660 --> 00:21:09,940
the right direction and I<font color="#E5E5E5"> think it</font>

525
00:21:06,550 --> 00:21:11,980
allows<font color="#CCCCCC"> us to hopefully kind of patch the</font>

526
00:21:09,940 --> 00:21:13,510
damn into letting someone get to the

527
00:21:11,980 --> 00:21:15,100
point where they can<font color="#E5E5E5"> get a weird machine</font>

528
00:21:13,510 --> 00:21:17,530
and be able<font color="#E5E5E5"> to control that weird</font>

529
00:21:15,100 --> 00:21:20,320
machine by reducing<font color="#CCCCCC"> the</font><font color="#E5E5E5"> kind of gap in</font>

530
00:21:17,530 --> 00:21:22,540
between what we as a programmer are kind

531
00:21:20,320 --> 00:21:24,460
of intending for the<font color="#CCCCCC"> program to do and</font>

532
00:21:22,540 --> 00:21:27,240
what an attacker is able to get<font color="#E5E5E5"> it to do</font>

533
00:21:24,460 --> 00:21:29,620
and so by reducing that<font color="#E5E5E5"> kind of space</font>

534
00:21:27,240 --> 00:21:32,440
you know clearly if there is still weird

535
00:21:29,620 --> 00:21:33,939
machines within that and you as an

536
00:21:32,440 --> 00:21:35,860
attacker were able to get to that point

537
00:21:33,940 --> 00:21:40,350
then you'll be<font color="#CCCCCC"> able</font><font color="#E5E5E5"> to still you know do</font>

538
00:21:35,860 --> 00:21:40,350
your nefarious acts but the gold

539
00:21:44,490 --> 00:21:50,610
you'd have<font color="#E5E5E5"> a much easier time finding</font>

540
00:21:47,110 --> 00:21:53,219
them when you're in the lower curve of

541
00:21:50,610 --> 00:21:58,020
analyzing code then on the upper curve

542
00:21:53,220 --> 00:22:01,780
so basically you know yes your needle

543
00:21:58,020 --> 00:22:09,760
can exist in any class of language but

544
00:22:01,780 --> 00:22:12,210
you have a much smaller head haystack so

545
00:22:09,760 --> 00:22:16,530
what I was mostly thinking about of his

546
00:22:12,210 --> 00:22:22,510
just that we might want to want<font color="#E5E5E5"> to</font>

547
00:22:16,530 --> 00:22:24,910
remember that right now out<font color="#E5E5E5"> there in the</font>

548
00:22:22,510 --> 00:22:27,430
sea of dark computation<font color="#CCCCCC"> that we have</font>

549
00:22:24,910 --> 00:22:36,010
that might actually be code that is sub

550
00:22:27,430 --> 00:22:40,180
Turing and is still very dangerous<font color="#E5E5E5"> keep</font>

551
00:22:36,010 --> 00:22:43,030
saying that Turing completeness<font color="#E5E5E5"> is</font>

552
00:22:40,180 --> 00:22:45,550
almost a distraction right because<font color="#CCCCCC"> of</font>

553
00:22:43,030 --> 00:22:47,710
course again for the attacker they are

554
00:22:45,550 --> 00:22:51,370
perfectly<font color="#E5E5E5"> happy you know if there</font><font color="#CCCCCC"> is a</font>

555
00:22:47,710 --> 00:22:53,770
finite automaton that is drip drivable

556
00:22:51,370 --> 00:22:56,979
by your input then the attacker will

557
00:22:53,770 --> 00:22:59,170
happily take advantage of<font color="#CCCCCC"> that but of</font>

558
00:22:56,980 --> 00:23:01,120
course<font color="#CCCCCC"> you know the way you of course</font>

559
00:22:59,170 --> 00:23:04,030
what impresses people is root shell

560
00:23:01,120 --> 00:23:07,989
right and Turing completeness is really

561
00:23:04,030 --> 00:23:09,550
just the root shell of those machine

562
00:23:07,990 --> 00:23:11,950
like hacking like in hacking in<font color="#E5E5E5"> the</font>

563
00:23:09,550 --> 00:23:14,710
movies you know that's<font color="#E5E5E5"> you VNC almost</font>

564
00:23:11,950 --> 00:23:16,330
even better than the<font color="#CCCCCC"> roadshow</font><font color="#E5E5E5"> I wrote an</font>

565
00:23:14,710 --> 00:23:17,830
article<font color="#E5E5E5"> about this about how kind of</font>

566
00:23:16,330 --> 00:23:21,100
Turing completeness at this point is

567
00:23:17,830 --> 00:23:23,199
less of a practical measurement for what

568
00:23:21,100 --> 00:23:26,290
an attacker<font color="#E5E5E5"> can do I mean you can be</font>

569
00:23:23,200 --> 00:23:27,580
playing you know the example of the

570
00:23:26,290 --> 00:23:29,320
language<font color="#E5E5E5"> that is kind of inappropriate</font>

571
00:23:27,580 --> 00:23:32,949
to say but starts with the brain and

572
00:23:29,320 --> 00:23:35,560
ends with an F and a bad word that is

573
00:23:32,950 --> 00:23:37,510
<font color="#CCCCCC">turning</font><font color="#E5E5E5"> complete however if you are able</font>

574
00:23:35,560 --> 00:23:39,040
<font color="#E5E5E5">to break into that environment it all it</font>

575
00:23:37,510 --> 00:23:40,720
can<font color="#E5E5E5"> really do is increment a couple</font>

576
00:23:39,040 --> 00:23:43,420
integers and simulate that whereas if

577
00:23:40,720 --> 00:23:45,460
you can write<font color="#CCCCCC"> to</font><font color="#E5E5E5"> arbitrary a memory or</font>

578
00:23:43,420 --> 00:23:46,900
send packets that's a much more powerful

579
00:23:45,460 --> 00:23:48,160
<font color="#E5E5E5">thing even though it might be restricted</font>

580
00:23:46,900 --> 00:23:50,830
so I think<font color="#E5E5E5"> they're actually orthogonal</font>

581
00:23:48,160 --> 00:23:52,450
to the sense that<font color="#E5E5E5"> you know what you can</font>

582
00:23:50,830 --> 00:23:54,699
do in your capabilities to be able to

583
00:23:52,450 --> 00:23:56,740
say impact systems from afar is what

584
00:23:54,700 --> 00:23:57,430
your goal is as an attacker is not

585
00:23:56,740 --> 00:23:58,720
<font color="#E5E5E5">necessarily</font>

586
00:23:57,430 --> 00:24:01,120
to be<font color="#CCCCCC"> able to run the most complex</font>

587
00:23:58,720 --> 00:24:03,970
computations and so I can talk to<font color="#CCCCCC"> you</font>

588
00:24:01,120 --> 00:24:05,770
offline<font color="#E5E5E5"> about that but I think this</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> a</font>

589
00:24:03,970 --> 00:24:08,260
Sergei said it makes the haystack

590
00:24:05,770 --> 00:24:10,150
smaller to search for but you're still

591
00:24:08,260 --> 00:24:14,590
going<font color="#CCCCCC"> to have these very poignant</font>

592
00:24:10,150 --> 00:24:22,870
attacks in this in this small space more

593
00:24:14,590 --> 00:24:24,850
questions ed so one comment you had was

594
00:24:22,870 --> 00:24:27,489
that maybe you know<font color="#E5E5E5"> sort of static</font>

595
00:24:24,850 --> 00:24:29,199
analysis and formal tools could do

596
00:24:27,490 --> 00:24:31,420
better if they had a restricted

597
00:24:29,200 --> 00:24:32,800
programming language and well I just

598
00:24:31,420 --> 00:24:34,360
<font color="#E5E5E5">wanted</font><font color="#CCCCCC"> to add a comment</font><font color="#E5E5E5"> there that</font>

599
00:24:32,800 --> 00:24:36,820
that's kind<font color="#E5E5E5"> of what they've been doing</font>

600
00:24:34,360 --> 00:24:38,590
for a long time like starting<font color="#CCCCCC"> with the</font>

601
00:24:36,820 --> 00:24:40,899
early development<font color="#CCCCCC"> of model checking was</font>

602
00:24:38,590 --> 00:24:42,310
let's assume finite state programs and

603
00:24:40,900 --> 00:24:45,100
then when<font color="#E5E5E5"> they did this</font><font color="#CCCCCC"> lamb project at</font>

604
00:24:42,310 --> 00:24:46,629
Microsoft they also had like boolean

605
00:24:45,100 --> 00:24:50,020
programs where you only had boolean data

606
00:24:46,630 --> 00:24:52,450
type right so so in a<font color="#E5E5E5"> sense I guess</font>

607
00:24:50,020 --> 00:24:55,150
<font color="#CCCCCC">cleese pretty recent but historically we</font>

608
00:24:52,450 --> 00:24:57,310
already had and<font color="#CCCCCC"> analyze programs in</font>

609
00:24:55,150 --> 00:24:59,650
restricted languages because it would

610
00:24:57,310 --> 00:25:01,060
have been undecidable otherwise and I

611
00:24:59,650 --> 00:25:03,100
guess the only difference would be

612
00:25:01,060 --> 00:25:04,750
whether you need to abstract or not like

613
00:25:03,100 --> 00:25:07,840
whether the results<font color="#CCCCCC"> are approximate or</font>

614
00:25:04,750 --> 00:25:09,520
not would change and do you see what I

615
00:25:07,840 --> 00:25:12,370
mean yes I think<font color="#E5E5E5"> this</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> kind of</font>

616
00:25:09,520 --> 00:25:14,050
bridging the gap of you know we've built

617
00:25:12,370 --> 00:25:15,100
up<font color="#E5E5E5"> a lot</font><font color="#CCCCCC"> of tools already air and now</font>

618
00:25:14,050 --> 00:25:17,050
it's<font color="#CCCCCC"> just a kind of a matter of</font>

619
00:25:15,100 --> 00:25:19,570
combining them to be<font color="#CCCCCC"> able to</font><font color="#E5E5E5"> make tools</font>

620
00:25:17,050 --> 00:25:21,460
analyze real source<font color="#E5E5E5"> codes so to speak</font>

621
00:25:19,570 --> 00:25:22,600
with all these kind of things<font color="#E5E5E5"> so that's</font>

622
00:25:21,460 --> 00:25:24,910
kind of where we're looking down the

623
00:25:22,600 --> 00:25:27,129
road<font color="#E5E5E5"> is to be able to kind of you know</font>

624
00:25:24,910 --> 00:25:28,630
bridge that gap and apply a lot of the

625
00:25:27,130 --> 00:25:31,840
<font color="#E5E5E5">tools that have you know come out from</font>

626
00:25:28,630 --> 00:25:33,670
the more simple verification tasks to a

627
00:25:31,840 --> 00:25:35,590
<font color="#E5E5E5">quote unquote real programming language</font>

628
00:25:33,670 --> 00:25:47,920
that you'd be<font color="#E5E5E5"> able to at least write a</font>

629
00:25:35,590 --> 00:25:52,810
portion of your code in and so I was

630
00:25:47,920 --> 00:25:56,530
<font color="#E5E5E5">talking to various people about right in</font>

631
00:25:52,810 --> 00:25:59,860
somehow Buster's you will go to an

632
00:25:56,530 --> 00:26:02,500
attacker this is the closest and the

633
00:25:59,860 --> 00:26:04,990
most valuable<font color="#E5E5E5"> piece</font><font color="#CCCCCC"> of code for some</font>

634
00:26:02,500 --> 00:26:08,620
reason they have not been as much of a

635
00:26:04,990 --> 00:26:10,930
target of a program verification as we

636
00:26:08,620 --> 00:26:16,360
would like them to and<font color="#E5E5E5"> would like them</font>

637
00:26:10,930 --> 00:26:20,680
to be and so it's say for example a leg

638
00:26:16,360 --> 00:26:31,110
to extend this has to do with the loopy

639
00:26:20,680 --> 00:26:31,110
nature of parsers so<font color="#E5E5E5"> poor flake have a</font>

640
00:26:31,260 --> 00:26:41,320
challenge problem for static analysis

641
00:26:35,070 --> 00:26:46,030
which consisted of a very simple loop in

642
00:26:41,320 --> 00:26:51,580
<font color="#E5E5E5">the sending and an actual bug that was</font>

643
00:26:46,030 --> 00:26:56,139
found there and<font color="#CCCCCC"> are julian has done work</font>

644
00:26:51,580 --> 00:27:04,439
<font color="#CCCCCC">with that challenge but</font><font color="#E5E5E5"> basically I mean</font>

645
00:26:56,140 --> 00:27:07,690
it was it was a five-state loop of

646
00:27:04,440 --> 00:27:11,560
consuming single characters that present

647
00:27:07,690 --> 00:27:14,620
the problem so what made this

648
00:27:11,560 --> 00:27:18,700
approachable was a semantic annotation

649
00:27:14,620 --> 00:27:22,419
of what is meant to be done<font color="#CCCCCC"> here but as</font>

650
00:27:18,700 --> 00:27:33,400
a piece of<font color="#CCCCCC"> C code even then kind of</font><font color="#E5E5E5"> a</font>

651
00:27:22,420 --> 00:27:35,620
<font color="#E5E5E5">simple</font><font color="#CCCCCC"> blog enough said one remark about</font>

652
00:27:33,400 --> 00:27:37,420
that I'm one thing that was not

653
00:27:35,620 --> 00:27:41,409
addressed in this talk and we haven't

654
00:27:37,420 --> 00:27:43,960
told about quite yet is the fact that<font color="#E5E5E5"> it</font>

655
00:27:41,410 --> 00:27:46,450
doesn't really matter how complex the

656
00:27:43,960 --> 00:27:49,390
code looks<font color="#E5E5E5"> like but what matters is how</font>

657
00:27:46,450 --> 00:27:51,490
contextual the implementation is because

658
00:27:49,390 --> 00:27:55,180
the more contextual or<font color="#E5E5E5"> certainly you</font>

659
00:27:51,490 --> 00:27:58,330
know say language will be or like a

660
00:27:55,180 --> 00:28:00,190
property will be then the hardest is

661
00:27:58,330 --> 00:28:02,830
going to be to eat try to prove this

662
00:28:00,190 --> 00:28:06,640
property we still such as SMT solvers

663
00:28:02,830 --> 00:28:11,080
which are otherwise really easy to<font color="#CCCCCC"> use</font>

664
00:28:06,640 --> 00:28:13,300
and can capture simple finite state

665
00:28:11,080 --> 00:28:16,120
machines like symbolic model checking

666
00:28:13,300 --> 00:28:17,830
would do so I don't necessarily<font color="#E5E5E5"> think</font>

667
00:28:16,120 --> 00:28:20,139
that model checking is a bad technique

668
00:28:17,830 --> 00:28:24,310
or as mr.<font color="#E5E5E5"> Riggins a bad technique but</font>

669
00:28:20,140 --> 00:28:27,910
for some classes<font color="#CCCCCC"> of properties where you</font>

670
00:28:24,310 --> 00:28:30,879
have a huge<font color="#CCCCCC"> amount of contexts or the</font>

671
00:28:27,910 --> 00:28:32,770
context is deep then that's where it

672
00:28:30,880 --> 00:28:37,510
would usually be hard to prove<font color="#E5E5E5"> the</font>

673
00:28:32,770 --> 00:28:44,170
properties so um maybe that's things we

674
00:28:37,510 --> 00:28:47,440
should research<font color="#CCCCCC"> wrong so I mean I</font><font color="#E5E5E5"> would</font>

675
00:28:44,170 --> 00:28:49,150
slightly disagree on the so I<font color="#CCCCCC"> think we</font>

676
00:28:47,440 --> 00:28:50,650
know how to handle the loops and the

677
00:28:49,150 --> 00:28:53,050
recursion actually so if you give me

678
00:28:50,650 --> 00:28:55,420
<font color="#E5E5E5">just programs with boolean data type and</font>

679
00:28:53,050 --> 00:28:56,530
arbitrary recursion we can analyze them

680
00:28:55,420 --> 00:28:58,390
like there are tools you can download

681
00:28:56,530 --> 00:29:00,100
that will analyze that and and I think

682
00:28:58,390 --> 00:29:02,500
<font color="#CCCCCC">the issue with parses is really strings</font>

683
00:29:00,100 --> 00:29:04,240
like strings as a data type<font color="#CCCCCC"> are not like</font>

684
00:29:02,500 --> 00:29:06,460
it very hard to reason about we don't

685
00:29:04,240 --> 00:29:09,070
have good SMT solvers for them like that

686
00:29:06,460 --> 00:29:11,620
<font color="#E5E5E5">it's very</font><font color="#CCCCCC"> early stage and to the extent</font>

687
00:29:09,070 --> 00:29:13,149
that we can we do see strings but we

688
00:29:11,620 --> 00:29:14,919
treat<font color="#E5E5E5"> them as bit vectors right and</font>

689
00:29:13,150 --> 00:29:16,450
that's the<font color="#CCCCCC"> only reason we can so so I'll</font>

690
00:29:14,920 --> 00:29:18,520
agree<font color="#E5E5E5"> with you that the tools are not</font>

691
00:29:16,450 --> 00:29:26,200
there I'm just disagreeing on the reason

692
00:29:18,520 --> 00:29:29,040
why the tools are not there yes

693
00:29:26,200 --> 00:29:29,040
absolutely absolutely

694
00:29:41,810 --> 00:29:51,590
you get rid<font color="#E5E5E5"> of a bunch of CWS and an</font>

695
00:29:46,610 --> 00:29:59,629
even bigger bunch of<font color="#CCCCCC"> CDs right the</font>

696
00:29:51,590 --> 00:30:02,480
payoff here is is quite obvious so we

697
00:29:59,630 --> 00:30:06,410
see a bit of impedance then between

698
00:30:02,480 --> 00:30:08,930
verification where it's no crime to

699
00:30:06,410 --> 00:30:11,990
produce those results a practical

700
00:30:08,930 --> 00:30:14,240
security and the reality<font color="#E5E5E5"> well people</font>

701
00:30:11,990 --> 00:30:25,340
verify things starting with abstracts

702
00:30:14,240 --> 00:30:27,560
industries why is that right<font color="#E5E5E5"> it's Falcon</font>

703
00:30:25,340 --> 00:30:29,840
here from Leviathan security um I was

704
00:30:27,560 --> 00:30:32,060
thinking<font color="#E5E5E5"> about this and I was</font><font color="#CCCCCC"> thinking</font>

705
00:30:29,840 --> 00:30:33,590
that<font color="#CCCCCC"> perhaps</font><font color="#E5E5E5"> you could compose a bunch</font>

706
00:30:32,060 --> 00:30:35,590
of<font color="#E5E5E5"> these</font><font color="#CCCCCC"> machines written</font><font color="#E5E5E5"> in kemah</font>

707
00:30:33,590 --> 00:30:40,220
together that are tearing incomplete and

708
00:30:35,590 --> 00:30:42,560
create a turing-complete machine and I

709
00:30:40,220 --> 00:30:44,870
was kind<font color="#CCCCCC"> of wondering</font><font color="#E5E5E5"> on two parts from</font>

710
00:30:42,560 --> 00:30:46,129
this one is my hunch true that these can

711
00:30:44,870 --> 00:30:50,719
be composed if they're composed

712
00:30:46,130 --> 00:30:53,630
dynamically on is that a is does that in

713
00:30:50,720 --> 00:30:55,820
any way take away from the usefulness of

714
00:30:53,630 --> 00:30:58,940
formally verifying these systems and the

715
00:30:55,820 --> 00:31:00,439
second part if it doesn't could you then

716
00:30:58,940 --> 00:31:02,150
model something<font color="#E5E5E5"> that must be</font>

717
00:31:00,440 --> 00:31:03,290
turing-complete like for example the

718
00:31:02,150 --> 00:31:05,990
<font color="#CCCCCC">apache event loop that you were</font>

719
00:31:03,290 --> 00:31:07,700
describing before<font color="#E5E5E5"> as simply a dynamic</font>

720
00:31:05,990 --> 00:31:15,620
concatenation of these<font color="#CCCCCC"> machines and</font>

721
00:31:07,700 --> 00:31:18,320
thereby secure it well yeah so one

722
00:31:15,620 --> 00:31:21,260
example look<font color="#E5E5E5"> at that is the you know</font>

723
00:31:18,320 --> 00:31:23,330
linux real-time fork or which is

724
00:31:21,260 --> 00:31:25,879
basically a real-time version of the

725
00:31:23,330 --> 00:31:27,710
<font color="#CCCCCC">linux kernel and that has</font><font color="#E5E5E5"> your kind of</font>

726
00:31:25,880 --> 00:31:28,760
fast loop and<font color="#E5E5E5"> then it kind of farms out</font>

727
00:31:27,710 --> 00:31:30,940
to these<font color="#E5E5E5"> things that have strict</font>

728
00:31:28,760 --> 00:31:32,960
deadlines and they're not necessarily

729
00:31:30,940 --> 00:31:34,870
subtour and complete they just kind of

730
00:31:32,960 --> 00:31:37,640
get halted after if they misbehave and

731
00:31:34,870 --> 00:31:40,639
so with that you can<font color="#E5E5E5"> kind of look at the</font>

732
00:31:37,640 --> 00:31:44,020
Linux kernels execution as a cat ination

733
00:31:40,640 --> 00:31:47,120
of these small tasks that are basically

734
00:31:44,020 --> 00:31:49,160
coerced to be provably halting in the

735
00:31:47,120 --> 00:31:52,100
sense that once their time runs out

736
00:31:49,160 --> 00:31:55,410
there they're killed as about

737
00:31:52,100 --> 00:31:56,909
composition I think<font color="#E5E5E5"> from</font>

738
00:31:55,410 --> 00:31:58,770
really depends on<font color="#E5E5E5"> what</font><font color="#CCCCCC"> you're looking at</font>

739
00:31:56,910 --> 00:32:01,020
so again<font color="#E5E5E5"> that's what we're talking about</font>

740
00:31:58,770 --> 00:32:05,010
is<font color="#CCCCCC"> you know if you look</font><font color="#E5E5E5"> at something</font>

741
00:32:01,020 --> 00:32:06,930
where you have a composition of multiple

742
00:32:05,010 --> 00:32:09,290
say layers where you have your crema

743
00:32:06,930 --> 00:32:11,640
program running on your you know larger

744
00:32:09,290 --> 00:32:13,110
lvm and then you have your assembly with

745
00:32:11,640 --> 00:32:15,300
all the pipelining which as I said

746
00:32:13,110 --> 00:32:17,280
<font color="#CCCCCC">earlier is the new</font><font color="#E5E5E5"> high level language</font>

747
00:32:15,300 --> 00:32:20,220
you know<font color="#E5E5E5"> if you're composing in that</font>

748
00:32:17,280 --> 00:32:22,050
space then certainly you know there

749
00:32:20,220 --> 00:32:24,600
might be some interesting inter place

750
00:32:22,050 --> 00:32:27,419
between being able to trigger something

751
00:32:24,600 --> 00:32:29,730
in a different<font color="#CCCCCC"> part you have</font><font color="#E5E5E5"> to look it</font>

752
00:32:27,420 --> 00:32:32,400
you know what we've done in terms<font color="#E5E5E5"> of you</font>

753
00:32:29,730 --> 00:32:36,000
know the compile time syntax checking

754
00:32:32,400 --> 00:32:37,860
and kind of restrictions to see and so

755
00:32:36,000 --> 00:32:42,240
if you're looking<font color="#CCCCCC"> at Walter recursion</font>

756
00:32:37,860 --> 00:32:44,969
which is kind of the space it's been

757
00:32:42,240 --> 00:32:47,160
shown pretty much whether our current

758
00:32:44,970 --> 00:32:48,660
research prototype reflects this

759
00:32:47,160 --> 00:32:51,990
perfectly or whether there may be bugs

760
00:32:48,660 --> 00:32:53,700
is a different question but that's been

761
00:32:51,990 --> 00:32:55,950
shown<font color="#E5E5E5"> pretty much that you know you're</font>

762
00:32:53,700 --> 00:32:59,070
composing you know wealth of recursion

763
00:32:55,950 --> 00:33:01,370
algorithms will still be be able to be

764
00:32:59,070 --> 00:33:04,649
<font color="#E5E5E5">determined in polynomial time the</font>

765
00:33:01,370 --> 00:33:06,330
termination bounds is this like

766
00:33:04,650 --> 00:33:10,500
sequential<font color="#E5E5E5"> composition like piping them</font>

767
00:33:06,330 --> 00:33:12,090
together or I mean I<font color="#E5E5E5"> guess well I guess</font>

768
00:33:10,500 --> 00:33:16,680
one question I have is you know it is

769
00:33:12,090 --> 00:33:19,669
mutual recursion legal in crema so our

770
00:33:16,680 --> 00:33:23,600
current implementation<font color="#E5E5E5"> co recursion is</font>

771
00:33:19,670 --> 00:33:25,800
not permitted we're looking at using

772
00:33:23,600 --> 00:33:29,159
continuations as a way to kind<font color="#E5E5E5"> of</font>

773
00:33:25,800 --> 00:33:31,110
boundaries between regions the code<font color="#CCCCCC"> that</font>

774
00:33:29,160 --> 00:33:34,110
may need more power or at least be able

775
00:33:31,110 --> 00:33:35,490
to<font color="#E5E5E5"> kind of logically isolate but the</font>

776
00:33:34,110 --> 00:33:37,590
research prototype we have does not

777
00:33:35,490 --> 00:33:40,680
<font color="#CCCCCC">include that currently it's more</font>

778
00:33:37,590 --> 00:33:43,639
restrictive than you know what it

779
00:33:40,680 --> 00:33:46,700
probably at some point could support

780
00:33:43,640 --> 00:33:46,700
anything else

