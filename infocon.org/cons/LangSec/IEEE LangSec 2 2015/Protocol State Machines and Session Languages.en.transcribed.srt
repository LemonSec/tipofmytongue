1
00:00:00,000 --> 00:00:04,680
so this is joint work with<font color="#CCCCCC"> Julie the</font>

2
00:00:02,340 --> 00:00:06,740
writer is a PhD student of mine recently

3
00:00:04,680 --> 00:00:09,239
moved to<font color="#E5E5E5"> University of Birmingham and</font>

4
00:00:06,740 --> 00:00:11,550
<font color="#E5E5E5">Alexis uber</font><font color="#CCCCCC"> tues</font><font color="#E5E5E5"> at the University of or</font>

5
00:00:09,240 --> 00:00:13,049
so and but it's actually building on a

6
00:00:11,550 --> 00:00:15,870
lot<font color="#E5E5E5"> of work I've been doing over the</font>

7
00:00:13,049 --> 00:00:18,539
past 10 15 years where we've been<font color="#E5E5E5"> trying</font>

8
00:00:15,870 --> 00:00:19,948
to<font color="#E5E5E5"> do on the one hand formal analysis so</font>

9
00:00:18,539 --> 00:00:21,539
my backgrounds in formal methods so

10
00:00:19,949 --> 00:00:24,960
we've tried formal verification of

11
00:00:21,539 --> 00:00:27,359
software formal analysis of protocol but

12
00:00:24,960 --> 00:00:29,099
also a lot of<font color="#E5E5E5"> ad hoc security analysis</font>

13
00:00:27,359 --> 00:00:30,960
where typically formal methods is not

14
00:00:29,099 --> 00:00:34,320
the quickest way you find the bugs so

15
00:00:30,960 --> 00:00:35,880
more at hog things and one thing<font color="#E5E5E5"> I found</font>

16
00:00:34,320 --> 00:00:38,760
there is that sort of my favorite

17
00:00:35,880 --> 00:00:41,010
formalism here is not even<font color="#CCCCCC"> F</font><font color="#E5E5E5"> numbers its</font>

18
00:00:38,760 --> 00:00:42,690
state machines so I found<font color="#CCCCCC"> out state</font>

19
00:00:41,010 --> 00:00:44,969
machines were a really useful tool in

20
00:00:42,690 --> 00:00:46,890
understanding these systems so this<font color="#E5E5E5"> is</font>

21
00:00:44,969 --> 00:00:49,950
why I sort of look at length sack from

22
00:00:46,890 --> 00:00:52,320
the from this perspective so the

23
00:00:49,950 --> 00:00:54,930
motivation for<font color="#E5E5E5"> this a Sega already</font>

24
00:00:52,320 --> 00:00:56,699
indicated so if you were handling inputs

25
00:00:54,930 --> 00:00:58,170
you're you're you're typically getting

26
00:00:56,699 --> 00:01:00,930
these input messages<font color="#E5E5E5"> according</font><font color="#CCCCCC"> to some</font>

27
00:00:58,170 --> 00:01:03,420
formats so these are of course<font color="#CCCCCC"> ssh</font>

28
00:01:00,930 --> 00:01:04,860
packets which are sort of crawling with

29
00:01:03,420 --> 00:01:07,860
length fields with some people don't

30
00:01:04,860 --> 00:01:10,590
approve here I understand but but just

31
00:01:07,860 --> 00:01:12,330
<font color="#E5E5E5">so you can so this is this is one part</font>

32
00:01:10,590 --> 00:01:13,530
of the problem but<font color="#CCCCCC"> the second step is</font>

33
00:01:12,330 --> 00:01:15,330
that<font color="#E5E5E5"> okay after you get these messages</font>

34
00:01:13,530 --> 00:01:17,250
you also have to<font color="#E5E5E5"> set up a session and</font>

35
00:01:15,330 --> 00:01:18,570
then typically come people come<font color="#E5E5E5"> up with</font>

36
00:01:17,250 --> 00:01:20,460
these sorts<font color="#CCCCCC"> of pictures to</font><font color="#E5E5E5"> show that</font>

37
00:01:18,570 --> 00:01:22,350
there is some notion of session and a

38
00:01:20,460 --> 00:01:24,210
particular<font color="#CCCCCC"> sequence of messages that</font>

39
00:01:22,350 --> 00:01:26,520
<font color="#CCCCCC">you're</font><font color="#E5E5E5"> expecting and that you have to</font>

40
00:01:24,210 --> 00:01:28,229
interpret and so<font color="#CCCCCC"> basically what we try</font>

41
00:01:26,520 --> 00:01:30,030
to do in our paper is trying to see so

42
00:01:28,229 --> 00:01:32,460
do the same language length check

43
00:01:30,030 --> 00:01:34,650
principles also apply at this level of

44
00:01:32,460 --> 00:01:37,048
obsession languages so when you look at

45
00:01:34,650 --> 00:01:39,329
the problems of specifying this or

46
00:01:37,049 --> 00:01:40,799
verifying this and of course<font color="#CCCCCC"> our answer</font>

47
00:01:39,329 --> 00:01:42,860
will be yes or at least that's what<font color="#E5E5E5"> we</font>

48
00:01:40,799 --> 00:01:47,119
<font color="#E5E5E5">will</font><font color="#CCCCCC"> try to hope to</font><font color="#E5E5E5"> convince you of and</font>

49
00:01:42,860 --> 00:01:49,229
so just an indication of sort of<font color="#E5E5E5"> this</font>

50
00:01:47,119 --> 00:01:51,390
formalisms people use for session

51
00:01:49,229 --> 00:01:53,789
languages so typically we<font color="#E5E5E5"> notice them in</font>

52
00:01:51,390 --> 00:01:57,090
specifications as message sequence

53
00:01:53,790 --> 00:02:00,270
charts so which describe sort of a<font color="#CCCCCC"> happy</font>

54
00:01:57,090 --> 00:02:02,219
flow of a complete session and this is a

55
00:02:00,270 --> 00:02:03,450
useful specification but<font color="#E5E5E5"> of</font><font color="#CCCCCC"> course you</font>

56
00:02:02,219 --> 00:02:05,219
should realize that<font color="#E5E5E5"> it's typically a</font>

57
00:02:03,450 --> 00:02:06,960
very incomplete specification because

58
00:02:05,219 --> 00:02:09,299
you're you're only giving one example of

59
00:02:06,960 --> 00:02:11,250
one<font color="#CCCCCC"> group happy flow and you're</font><font color="#E5E5E5"> not</font>

60
00:02:09,300 --> 00:02:12,220
saying okay what if something else

61
00:02:11,250 --> 00:02:14,830
happens

62
00:02:12,220 --> 00:02:17,800
another formalism which I prefer which i

63
00:02:14,830 --> 00:02:21,960
think is slightly better is just a state

64
00:02:17,800 --> 00:02:26,980
machine so so this was<font color="#E5E5E5"> SSH this is a</font>

65
00:02:21,960 --> 00:02:28,840
model<font color="#CCCCCC"> of ssh as a state machine so we</font>

66
00:02:26,980 --> 00:02:31,929
<font color="#CCCCCC">made this sort of after</font><font color="#E5E5E5"> reading our</font>

67
00:02:28,840 --> 00:02:33,910
seats for a while so here<font color="#E5E5E5"> we notice that</font>

68
00:02:31,930 --> 00:02:36,580
<font color="#E5E5E5">there</font><font color="#CCCCCC"> is actually</font><font color="#E5E5E5"> different different</font>

69
00:02:33,910 --> 00:02:38,829
correct flows there's actually cycle

70
00:02:36,580 --> 00:02:40,570
there because in ssh you can do<font color="#E5E5E5"> QE</font>

71
00:02:38,830 --> 00:02:43,390
<font color="#E5E5E5">negotiation where you sort of jump back</font>

72
00:02:40,570 --> 00:02:46,150
<font color="#E5E5E5">and so this</font><font color="#CCCCCC"> is this is a useful</font>

73
00:02:43,390 --> 00:02:47,920
formalism<font color="#E5E5E5"> I think but even though here</font>

74
00:02:46,150 --> 00:02:51,730
for instance there<font color="#CCCCCC"> are several</font><font color="#E5E5E5"> happy</font>

75
00:02:47,920 --> 00:02:53,410
flows it is still over simplistic

76
00:02:51,730 --> 00:02:54,850
because you're still ignoring you're not

77
00:02:53,410 --> 00:02:56,829
saying anything<font color="#E5E5E5"> about what happens in</font>

78
00:02:54,850 --> 00:02:58,870
the<font color="#E5E5E5"> other cases because of course in</font>

79
00:02:56,830 --> 00:03:00,670
general<font color="#CCCCCC"> if you implement the protocol</font>

80
00:02:58,870 --> 00:03:02,980
you will have to hand handle arbitrary

81
00:03:00,670 --> 00:03:06,250
sequences of messages also incorrect

82
00:03:02,980 --> 00:03:08,829
ones and so typically<font color="#CCCCCC"> you will have to</font>

83
00:03:06,250 --> 00:03:10,360
<font color="#E5E5E5">to give us the state machine which in</font>

84
00:03:08,830 --> 00:03:12,430
the<font color="#E5E5E5"> technical term is input enables</font>

85
00:03:10,360 --> 00:03:14,890
which is basically saying<font color="#CCCCCC"> that in every</font>

86
00:03:12,430 --> 00:03:17,110
<font color="#E5E5E5">state you have to be able to accept any</font>

87
00:03:14,890 --> 00:03:18,850
message and of course<font color="#CCCCCC"> the bulk of these</font>

88
00:03:17,110 --> 00:03:21,519
<font color="#CCCCCC">messages are incorrect and you will have</font>

89
00:03:18,850 --> 00:03:22,840
<font color="#E5E5E5">to abort or reset the protocol and only</font>

90
00:03:21,519 --> 00:03:24,880
the happy ones will sort of get you

91
00:03:22,840 --> 00:03:27,940
towards near<font color="#CCCCCC"> varma at the</font><font color="#E5E5E5"> ends where you</font>

92
00:03:24,880 --> 00:03:31,209
can actually exchange data so um<font color="#E5E5E5"> so</font><font color="#CCCCCC"> just</font>

93
00:03:27,940 --> 00:03:32,590
a visual indication so this is better

94
00:03:31,209 --> 00:03:34,450
than you typically see in these input

95
00:03:32,590 --> 00:03:36,310
the naval state machines that you have

96
00:03:34,450 --> 00:03:37,780
sort<font color="#E5E5E5"> of a normal flow and then here you</font>

97
00:03:36,310 --> 00:03:40,330
have all these red arrows which are for

98
00:03:37,780 --> 00:03:42,610
instance error transitions and typical

99
00:03:40,330 --> 00:03:44,950
<font color="#CCCCCC">trent response is that if you get an</font>

100
00:03:42,610 --> 00:03:47,080
error you jump back<font color="#CCCCCC"> to the beginning of</font>

101
00:03:44,950 --> 00:03:48,700
<font color="#E5E5E5">the session another pattern you see is</font>

102
00:03:47,080 --> 00:03:51,519
that you jump to some error state and

103
00:03:48,700 --> 00:03:53,290
you never returned from it or I'll see

104
00:03:51,519 --> 00:03:55,000
someone you will see examples later of

105
00:03:53,290 --> 00:03:56,980
where you basically ignore the funny

106
00:03:55,000 --> 00:04:00,760
messages so these are sort of patterns

107
00:03:56,980 --> 00:04:03,940
you see coming<font color="#CCCCCC"> up and so so we've been</font>

108
00:04:00,760 --> 00:04:05,590
looking<font color="#E5E5E5"> at different sort of products</font>

109
00:04:03,940 --> 00:04:07,930
protocols and pieces of<font color="#E5E5E5"> software and</font>

110
00:04:05,590 --> 00:04:09,610
<font color="#E5E5E5">hardware and then we're trying</font><font color="#CCCCCC"> to use</font>

111
00:04:07,930 --> 00:04:12,160
<font color="#CCCCCC">state machines to describe their</font>

112
00:04:09,610 --> 00:04:14,400
behavior to do some formal analysis and

113
00:04:12,160 --> 00:04:17,079
over the years we found some interesting

114
00:04:14,400 --> 00:04:20,289
security flaws which are basically due

115
00:04:17,079 --> 00:04:24,430
to broken state machine so the funniest

116
00:04:20,289 --> 00:04:25,780
example was a mid pssh know if anybody

117
00:04:24,430 --> 00:04:27,760
here still remembers Java

118
00:04:25,780 --> 00:04:29,559
feature phones we did software

119
00:04:27,760 --> 00:04:31,389
verification of Java feature phones<font color="#CCCCCC"> ten</font>

120
00:04:29,560 --> 00:04:34,660
years<font color="#E5E5E5"> ago there was somebody who</font>

121
00:04:31,389 --> 00:04:37,300
implemented SSH on<font color="#E5E5E5"> a Java Fiji phone so</font>

122
00:04:34,660 --> 00:04:38,980
we<font color="#CCCCCC"> thought we'd verify this and I really</font>

123
00:04:37,300 --> 00:04:40,570
think so we said few days pouring over

124
00:04:38,980 --> 00:04:42,639
the rfcs to come up<font color="#CCCCCC"> with</font><font color="#E5E5E5"> the state</font>

125
00:04:40,570 --> 00:04:44,020
machine and then<font color="#E5E5E5"> we wanted</font><font color="#CCCCCC"> to formally</font>

126
00:04:42,639 --> 00:04:46,600
<font color="#E5E5E5">verify using the program verification</font>

127
00:04:44,020 --> 00:04:48,250
tool that this implementation actually

128
00:04:46,600 --> 00:04:50,290
correctly implemented the finite state

129
00:04:48,250 --> 00:04:51,790
machine and then to our surprise we

130
00:04:50,290 --> 00:04:53,980
found out that<font color="#CCCCCC"> the implementers forgot</font>

131
00:04:51,790 --> 00:04:55,660
about the state machine so they wrote a

132
00:04:53,980 --> 00:04:58,990
lot of input handling functions to

133
00:04:55,660 --> 00:05:01,960
correctly you know detective the packets

134
00:04:58,990 --> 00:05:04,570
from SSH you know check all the max but

135
00:05:01,960 --> 00:05:06,760
completely forget about<font color="#CCCCCC"> getting the the</font>

136
00:05:04,570 --> 00:05:09,010
packets in the<font color="#E5E5E5"> right order which is a</font>

137
00:05:06,760 --> 00:05:11,260
bit of security worry if you do SSH

138
00:05:09,010 --> 00:05:13,750
because all the protocol layers of ssh

139
00:05:11,260 --> 00:05:15,280
is one big protocol so you could ask<font color="#E5E5E5"> you</font>

140
00:05:13,750 --> 00:05:19,960
know the user to authenticate before the

141
00:05:15,280 --> 00:05:21,429
recession key and yeah so it<font color="#E5E5E5"> was a bit</font>

142
00:05:19,960 --> 00:05:23,109
of<font color="#CCCCCC"> a shame that all our efforts in</font>

143
00:05:21,430 --> 00:05:25,300
<font color="#E5E5E5">trying to form licenses h of a sort of</font>

144
00:05:23,110 --> 00:05:28,720
useless at least for the point of

145
00:05:25,300 --> 00:05:30,520
verifying this but<font color="#E5E5E5"> this was sort of a</font>

146
00:05:28,720 --> 00:05:32,320
small open source software project

147
00:05:30,520 --> 00:05:34,870
somebody you know we<font color="#E5E5E5"> just got</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> Java</font>

148
00:05:32,320 --> 00:05:36,520
feature phone and a slightly more

149
00:05:34,870 --> 00:05:37,870
interesting one and i think<font color="#CCCCCC"> a more</font>

150
00:05:36,520 --> 00:05:41,580
embarrassing one for the for the

151
00:05:37,870 --> 00:05:44,979
producers was a<font color="#CCCCCC"> usb-connected</font><font color="#E5E5E5"> internet</font>

152
00:05:41,580 --> 00:05:47,289
banking device so this<font color="#E5E5E5"> is a device that</font>

153
00:05:44,979 --> 00:05:48,940
you get from one of the<font color="#CCCCCC"> Dutch banks wait</font>

154
00:05:47,289 --> 00:05:51,550
would you hook up with the USB interface

155
00:05:48,940 --> 00:05:53,890
to your<font color="#E5E5E5"> laptop you stick in your bank</font>

156
00:05:51,550 --> 00:05:57,039
art you<font color="#E5E5E5"> have typed in your PIN code and</font>

157
00:05:53,890 --> 00:05:58,780
then when you transfer money actually

158
00:05:57,039 --> 00:06:01,120
the actual bank<font color="#E5E5E5"> details of the bank</font>

159
00:05:58,780 --> 00:06:03,280
transfer are not shown on<font color="#CCCCCC"> your laptop</font>

160
00:06:01,120 --> 00:06:05,710
screen but are shown on this separate

161
00:06:03,280 --> 00:06:10,260
display and you actually have to press

162
00:06:05,710 --> 00:06:13,450
ok on<font color="#CCCCCC"> this special device to confirm the</font>

163
00:06:10,260 --> 00:06:15,520
transfer so this can defeat men in the

164
00:06:13,450 --> 00:06:18,490
browser attacks force this thing<font color="#E5E5E5"> is</font>

165
00:06:15,520 --> 00:06:19,900
connected<font color="#CCCCCC"> by USB so might be you an</font>

166
00:06:18,490 --> 00:06:21,220
attacker might be<font color="#CCCCCC"> able</font><font color="#E5E5E5"> to hack it but</font>

167
00:06:19,900 --> 00:06:23,289
it's going to<font color="#E5E5E5"> be very hard because you</font>

168
00:06:21,220 --> 00:06:27,039
know just not windows running on there

169
00:06:23,289 --> 00:06:29,020
or Firefox browser and and to our

170
00:06:27,039 --> 00:06:30,729
surprise and we would actually<font color="#E5E5E5"> weren't</font>

171
00:06:29,020 --> 00:06:33,340
trying<font color="#CCCCCC"> to hack the device we wanted to</font>

172
00:06:30,729 --> 00:06:35,289
<font color="#E5E5E5">use</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> reverse-engineer</font><font color="#E5E5E5"> to use it and</font>

173
00:06:33,340 --> 00:06:37,840
then we<font color="#E5E5E5"> found that it was broken because</font>

174
00:06:35,289 --> 00:06:39,580
so the security critical functionality

175
00:06:37,840 --> 00:06:41,830
here is that you have<font color="#E5E5E5"> to press ok on</font>

176
00:06:39,580 --> 00:06:43,719
device and when we<font color="#E5E5E5"> found that by sending</font>

177
00:06:41,830 --> 00:06:45,128
some strange sequence of USB commands

178
00:06:43,720 --> 00:06:47,139
you could actually press ok from the

179
00:06:45,129 --> 00:06:50,800
laptop which<font color="#CCCCCC"> is sort of defeating the</font>

180
00:06:47,139 --> 00:06:52,210
whole purpose of the device yeah so we

181
00:06:50,800 --> 00:06:54,219
started looking<font color="#E5E5E5"> at banking products</font>

182
00:06:52,210 --> 00:06:56,530
maybe<font color="#E5E5E5"> 10 15 years</font><font color="#CCCCCC"> 10 years</font><font color="#E5E5E5"> ago I</font><font color="#CCCCCC"> think</font>

183
00:06:54,219 --> 00:06:58,360
when I started it was my naive

184
00:06:56,530 --> 00:07:00,729
expectation that of course<font color="#E5E5E5"> these people</font>

185
00:06:58,360 --> 00:07:02,919
have looked at security but I mean I

186
00:07:00,729 --> 00:07:04,270
guess<font color="#E5E5E5"> somebody did security review but</font>

187
00:07:02,919 --> 00:07:08,378
they were probably asleep for most of

188
00:07:04,270 --> 00:07:11,139
the time and then earlier this week it

189
00:07:08,379 --> 00:07:13,060
was a presentation by the researchers

190
00:07:11,139 --> 00:07:16,030
from inria on research on TLS that

191
00:07:13,060 --> 00:07:17,860
they've done and they<font color="#E5E5E5"> found sort of a</font>

192
00:07:16,030 --> 00:07:19,840
lot of messy state machines in TLS

193
00:07:17,860 --> 00:07:22,300
implementations in France they found the

194
00:07:19,840 --> 00:07:23,948
freak attacks<font color="#E5E5E5"> I'll show you some</font>

195
00:07:22,300 --> 00:07:25,960
examples of TLS later because we also

196
00:07:23,949 --> 00:07:30,280
did a bunch of experiments with TLS and

197
00:07:25,960 --> 00:07:32,138
found lots of more bugs there and so one

198
00:07:30,280 --> 00:07:34,659
of the frustrations is if you try<font color="#E5E5E5"> to get</font>

199
00:07:32,139 --> 00:07:37,870
<font color="#E5E5E5">a good understanding of the of the</font>

200
00:07:34,659 --> 00:07:40,389
office of<font color="#CCCCCC"> the session language and you</font>

201
00:07:37,870 --> 00:07:42,569
start looking<font color="#E5E5E5"> at specifications then you</font>

202
00:07:40,389 --> 00:07:45,430
typically find a date written in prose

203
00:07:42,569 --> 00:07:48,060
so this<font color="#E5E5E5"> is a nice this these are some</font>

204
00:07:45,430 --> 00:07:52,629
quotes from the ssh specifications and

205
00:07:48,060 --> 00:07:55,930
so where they give some<font color="#E5E5E5"> expressionist</font>

206
00:07:52,629 --> 00:07:58,180
they give some pros to basically<font color="#E5E5E5"> gift</font>

207
00:07:55,930 --> 00:08:02,110
constraints on the order of messages

208
00:07:58,180 --> 00:08:04,539
that<font color="#E5E5E5"> can or cannot occur so this is</font><font color="#CCCCCC"> sort</font>

209
00:08:02,110 --> 00:08:05,979
of this<font color="#E5E5E5"> is this is</font><font color="#CCCCCC"> this is</font><font color="#E5E5E5"> giving a</font>

210
00:08:04,539 --> 00:08:08,529
constraint for the during the key

211
00:08:05,979 --> 00:08:10,360
exchange that after certain sending a

212
00:08:08,529 --> 00:08:12,310
certain message then until you set

213
00:08:10,360 --> 00:08:14,440
receive another message or send another

214
00:08:12,310 --> 00:08:18,190
message you should<font color="#CCCCCC"> know you should</font><font color="#E5E5E5"> only</font>

215
00:08:14,440 --> 00:08:19,990
be<font color="#CCCCCC"> getting key exchange messages now</font>

216
00:08:18,190 --> 00:08:22,960
then the annoying thing with these

217
00:08:19,990 --> 00:08:25,060
specifications is that of course if you

218
00:08:22,960 --> 00:08:27,279
take the rfcs from<font color="#CCCCCC"> ssh together i think</font>

219
00:08:25,060 --> 00:08:29,319
it's<font color="#E5E5E5"> about 2 300 pages there are</font>

220
00:08:27,279 --> 00:08:30,610
statements like this throughout the 300

221
00:08:29,319 --> 00:08:34,800
pages right so you have to read all of

222
00:08:30,610 --> 00:08:36,940
it<font color="#E5E5E5"> and try to cobble it together and to</font>

223
00:08:34,799 --> 00:08:38,370
understand what what what is really the

224
00:08:36,940 --> 00:08:41,019
state machine that you have to implement

225
00:08:38,370 --> 00:08:42,789
for so for instance one<font color="#CCCCCC"> of the funny</font>

226
00:08:41,019 --> 00:08:44,940
things in ssh we<font color="#E5E5E5"> notice</font><font color="#CCCCCC"> that there is</font>

227
00:08:42,789 --> 00:08:47,019
<font color="#E5E5E5">this notion of an unrecognized message</font>

228
00:08:44,940 --> 00:08:48,610
so if you get a message which you<font color="#E5E5E5"> don't</font>

229
00:08:47,019 --> 00:08:50,860
recognize you<font color="#E5E5E5"> have to say back to</font><font color="#CCCCCC"> the</font>

230
00:08:48,610 --> 00:08:53,470
other party and that you don't implement

231
00:08:50,860 --> 00:08:56,230
this there is<font color="#E5E5E5"> actually very hard to find</font>

232
00:08:53,470 --> 00:08:57,970
out what your name<font color="#CCCCCC"> only</font><font color="#E5E5E5"> the unrecognized</font>

233
00:08:56,230 --> 00:09:00,430
message you should be right if you<font color="#E5E5E5"> get a</font>

234
00:08:57,970 --> 00:09:02,170
message from a higher protocol layer in

235
00:09:00,430 --> 00:09:04,300
the wrong order is this<font color="#E5E5E5"> then</font>

236
00:09:02,170 --> 00:09:06,910
unrecognized or should you ignore it or

237
00:09:04,300 --> 00:09:09,579
should<font color="#E5E5E5"> you respond to it with saying you</font>

238
00:09:06,910 --> 00:09:11,199
don't implement it and so the bottom

239
00:09:09,580 --> 00:09:13,660
line is<font color="#CCCCCC"> that understanding the state</font>

240
00:09:11,200 --> 00:09:16,120
machines from from this kind<font color="#E5E5E5"> of process</font>

241
00:09:13,660 --> 00:09:20,439
can be very hard and then ssh is not the

242
00:09:16,120 --> 00:09:22,590
most complex protocol out there so at

243
00:09:20,440 --> 00:09:24,940
some stage when we were looking<font color="#CCCCCC"> at SSH</font>

244
00:09:22,590 --> 00:09:26,500
we also thought<font color="#CCCCCC"> okay let's look at some</font>

245
00:09:24,940 --> 00:09:29,950
source code to see if we understand it

246
00:09:26,500 --> 00:09:32,440
correctly and for ssh sort of open ssh

247
00:09:29,950 --> 00:09:35,740
is sort of a default implementation so

248
00:09:32,440 --> 00:09:40,180
we looked at and openssh not that<font color="#E5E5E5"> Vegas</font>

249
00:09:35,740 --> 00:09:42,520
<font color="#E5E5E5">about a few over a few hundred source</font>

250
00:09:40,180 --> 00:09:46,089
files of course there is some state

251
00:09:42,520 --> 00:09:47,439
machine implemented in this code and we

252
00:09:46,090 --> 00:09:49,540
started<font color="#CCCCCC"> looking for</font><font color="#E5E5E5"> the state machine</font>

253
00:09:47,440 --> 00:09:50,770
<font color="#E5E5E5">that just many ways</font><font color="#CCCCCC"> you can implement a</font>

254
00:09:49,540 --> 00:09:53,469
state machine right you could have like

255
00:09:50,770 --> 00:09:56,380
<font color="#CCCCCC">twenty bullion's flags or you could</font><font color="#E5E5E5"> have</font>

256
00:09:53,470 --> 00:09:58,690
one state variable and so the nice thing

257
00:09:56,380 --> 00:10:00,160
<font color="#CCCCCC">is in openssh there's only one state</font>

258
00:09:58,690 --> 00:10:02,500
variable and there's<font color="#E5E5E5"> only about a dozen</font>

259
00:10:00,160 --> 00:10:05,589
or so files which actually touch<font color="#CCCCCC"> this</font>

260
00:10:02,500 --> 00:10:07,990
state variable and the not so nice thing

261
00:10:05,590 --> 00:10:11,080
about the state variable is is that it's

262
00:10:07,990 --> 00:10:13,780
<font color="#E5E5E5">an array of function pointers with 255</font>

263
00:10:11,080 --> 00:10:15,880
function pointers to be exact and so the

264
00:10:13,780 --> 00:10:18,550
way openssh works is you get an ssh

265
00:10:15,880 --> 00:10:20,020
packet you look at one bite in<font color="#CCCCCC"> the</font>

266
00:10:18,550 --> 00:10:23,380
package which is giving the message type

267
00:10:20,020 --> 00:10:26,079
and then you use this table to jump to

268
00:10:23,380 --> 00:10:28,870
some routine that<font color="#E5E5E5"> handles that that</font>

269
00:10:26,080 --> 00:10:31,000
handles that packet and then so it<font color="#E5E5E5"> just</font>

270
00:10:28,870 --> 00:10:34,060
gets initialized at some stage and then

271
00:10:31,000 --> 00:10:37,390
during the protocol run you update this

272
00:10:34,060 --> 00:10:40,119
table with various entries now this<font color="#E5E5E5"> is</font>

273
00:10:37,390 --> 00:10:41,740
sort of very efficient a very clever but

274
00:10:40,120 --> 00:10:44,770
<font color="#E5E5E5">actually understanding the state machine</font>

275
00:10:41,740 --> 00:10:47,260
from the code is very horrendous I mean

276
00:10:44,770 --> 00:10:48,670
the state you mean the state space you

277
00:10:47,260 --> 00:10:51,430
know you're talking<font color="#E5E5E5"> but maybe about a</font>

278
00:10:48,670 --> 00:10:53,800
few dozen states I mean of course<font color="#E5E5E5"> if you</font>

279
00:10:51,430 --> 00:10:56,770
have<font color="#E5E5E5"> this this this array of 255</font>

280
00:10:53,800 --> 00:10:58,750
elements you know the potential state

281
00:10:56,770 --> 00:11:02,650
space is something like 22 to power 32

282
00:10:58,750 --> 00:11:04,300
or 64 to the power 255 and actually

283
00:11:02,650 --> 00:11:06,259
tracing this through the<font color="#E5E5E5"> source code is</font>

284
00:11:04,300 --> 00:11:09,978
really really<font color="#E5E5E5"> painful to try</font>

285
00:11:06,259 --> 00:11:13,009
standish so we did a manual code review

286
00:11:09,979 --> 00:11:15,319
of openssh we did not find any bugs at

287
00:11:13,009 --> 00:11:16,970
least for the transport<font color="#E5E5E5"> layer but</font><font color="#CCCCCC"> I</font>

288
00:11:15,319 --> 00:11:18,949
wouldn't make<font color="#E5E5E5"> any serious best on this</font>

289
00:11:16,970 --> 00:11:23,509
and I think<font color="#E5E5E5"> you want to implement this</font>

290
00:11:18,949 --> 00:11:26,329
in a clever away so<font color="#E5E5E5"> um yeah so</font><font color="#CCCCCC"> this can</font>

291
00:11:23,509 --> 00:11:29,509
be<font color="#E5E5E5"> very hard and I get sort of the first</font>

292
00:11:26,329 --> 00:11:31,549
<font color="#E5E5E5">a thing that</font><font color="#CCCCCC"> I would</font><font color="#E5E5E5"> like to propose</font>

293
00:11:29,509 --> 00:11:32,629
<font color="#E5E5E5">here is that saying that</font><font color="#CCCCCC"> okay these</font>

294
00:11:31,549 --> 00:11:34,249
political state machines they're

295
00:11:32,629 --> 00:11:38,779
important<font color="#E5E5E5"> and they deserve to be</font>

296
00:11:34,249 --> 00:11:40,100
explicitly specified so it's my my my

297
00:11:38,779 --> 00:11:41,479
guess is that people who design

298
00:11:40,100 --> 00:11:42,769
protocols typically they have a white

299
00:11:41,479 --> 00:11:44,449
board which looks<font color="#CCCCCC"> like this so they've</font>

300
00:11:42,769 --> 00:11:46,759
written up their finite state machine

301
00:11:44,449 --> 00:11:48,199
but then when they type in the RFC of

302
00:11:46,759 --> 00:11:51,199
course it's<font color="#E5E5E5"> really hard to type this in</font>

303
00:11:48,199 --> 00:11:53,118
an RFC so you leave it out and<font color="#CCCCCC"> then you</font>

304
00:11:51,199 --> 00:11:54,709
get<font color="#E5E5E5"> a bunch</font><font color="#CCCCCC"> of pros and then the people</font>

305
00:11:53,119 --> 00:11:56,389
<font color="#CCCCCC">who have</font><font color="#E5E5E5"> to implement the protocol they</font>

306
00:11:54,709 --> 00:11:57,439
read all the pros they go to their white

307
00:11:56,389 --> 00:11:59,929
board again and then they start

308
00:11:57,439 --> 00:12:01,728
redrawing the diagram if you're lucky

309
00:11:59,929 --> 00:12:03,579
it's identical diagram but of course the

310
00:12:01,729 --> 00:12:06,559
chances are that it's slightly different

311
00:12:03,579 --> 00:12:08,299
and and mean you can avoid<font color="#E5E5E5"> this but</font>

312
00:12:06,559 --> 00:12:11,689
you're sticking the state machine in the

313
00:12:08,299 --> 00:12:14,358
spec so now the jon postel<font color="#E5E5E5"> has beginning</font>

314
00:12:11,689 --> 00:12:15,649
<font color="#E5E5E5">some steak for the Postal principle but</font>

315
00:12:14,359 --> 00:12:18,949
actually if you look at the TCP

316
00:12:15,649 --> 00:12:21,079
specification it<font color="#E5E5E5"> actually includes the</font>

317
00:12:18,949 --> 00:12:23,358
state diagram which is then drawn in

318
00:12:21,079 --> 00:12:25,368
esky<font color="#E5E5E5"> arts because of course an RFC has</font>

319
00:12:23,359 --> 00:12:26,749
to be<font color="#CCCCCC"> esky but you can actually</font><font color="#E5E5E5"> draw the</font>

320
00:12:25,369 --> 00:12:28,039
state machine in esky art and they

321
00:12:26,749 --> 00:12:32,660
actually<font color="#E5E5E5"> did that and that's really</font>

322
00:12:28,039 --> 00:12:34,519
<font color="#CCCCCC">useful to</font><font color="#E5E5E5"> have so looking at some</font>

323
00:12:32,660 --> 00:12:35,959
protocol so we looked at some known

324
00:12:34,519 --> 00:12:37,160
protocols but we also looked at some

325
00:12:35,959 --> 00:12:40,128
unknown protocols to reverse-engineer

326
00:12:37,160 --> 00:12:42,230
them and now we find out that there is

327
00:12:40,129 --> 00:12:44,899
<font color="#CCCCCC">actually a really nice trick to get a</font>

328
00:12:42,230 --> 00:12:46,339
state machine from code so this morning

329
00:12:44,899 --> 00:12:49,639
there was a talk that was you mentioned

330
00:12:46,339 --> 00:12:51,949
the an algorithm by<font color="#CCCCCC"> out growing to do</font>

331
00:12:49,639 --> 00:12:56,079
inference so there's a really<font color="#E5E5E5"> nice</font>

332
00:12:51,949 --> 00:12:59,269
algorithm called<font color="#CCCCCC"> L star which is about</font>

333
00:12:56,079 --> 00:13:00,529
<font color="#E5E5E5">by black box testing a system you try to</font>

334
00:12:59,269 --> 00:13:02,749
extract the state machine that's

335
00:13:00,529 --> 00:13:05,359
implemented in the system<font color="#E5E5E5"> so this is a</font>

336
00:13:02,749 --> 00:13:08,720
i'll stop algorithm dates back to<font color="#CCCCCC"> the</font>

337
00:13:05,359 --> 00:13:10,459
1980s and there's no couple<font color="#CCCCCC"> of libraries</font>

338
00:13:08,720 --> 00:13:12,889
that actually implement it off the<font color="#CCCCCC"> shelf</font>

339
00:13:10,459 --> 00:13:15,049
so we typically use learning lip which

340
00:13:12,889 --> 00:13:17,019
is by the people from a<font color="#E5E5E5"> Bennett Stefan's</font>

341
00:13:15,049 --> 00:13:19,670
group in<font color="#CCCCCC"> the University of Dortmund and</font>

342
00:13:17,019 --> 00:13:21,830
basically what<font color="#E5E5E5"> this learning technique</font>

343
00:13:19,670 --> 00:13:23,449
doing<font color="#E5E5E5"> it sort of is basically sort of a</font>

344
00:13:21,830 --> 00:13:26,000
fuzzing technique you're trying to fast

345
00:13:23,450 --> 00:13:30,020
the system and based on the responses

346
00:13:26,000 --> 00:13:32,930
you're trying<font color="#E5E5E5"> to learn the behavior of</font>

347
00:13:30,020 --> 00:13:34,850
the system and<font color="#E5E5E5"> and so you what you have</font>

348
00:13:32,930 --> 00:13:38,060
to provide an interface which actually

349
00:13:34,850 --> 00:13:39,620
will send the messages or test harness

350
00:13:38,060 --> 00:13:41,989
which will send some dip or protocol

351
00:13:39,620 --> 00:13:43,610
messages and get a response but<font color="#E5E5E5"> then you</font>

352
00:13:41,990 --> 00:13:45,470
can use this test harness and learn lip

353
00:13:43,610 --> 00:13:47,960
and use by back box testing you come

354
00:13:45,470 --> 00:13:49,940
back after half an hour or an hour or a

355
00:13:47,960 --> 00:13:52,130
day and you have a state machine out

356
00:13:49,940 --> 00:13:54,080
there and so this<font color="#CCCCCC"> is really nice to get</font>

357
00:13:52,130 --> 00:13:59,270
there and it's nice maybe to implement

358
00:13:54,080 --> 00:14:00,860
to show the idea of the protocol it's

359
00:13:59,270 --> 00:14:03,530
nice<font color="#E5E5E5"> to actually do some formal language</font>

360
00:14:00,860 --> 00:14:05,870
theory in a talk because the basic

361
00:14:03,530 --> 00:14:07,040
principle<font color="#E5E5E5"> is very simple and supposed to</font>

362
00:14:05,870 --> 00:14:09,770
have a system which has<font color="#E5E5E5"> two input</font>

363
00:14:07,040 --> 00:14:11,780
actions amb now what I can do for

364
00:14:09,770 --> 00:14:14,420
instance I<font color="#CCCCCC"> can test is the test I can</font>

365
00:14:11,780 --> 00:14:17,449
give it the input a or I could<font color="#CCCCCC"> give it</font>

366
00:14:14,420 --> 00:14:21,500
the input B or I could give<font color="#CCCCCC"> it the input</font>

367
00:14:17,450 --> 00:14:23,270
be preceded by an<font color="#CCCCCC"> A and and the idea</font><font color="#E5E5E5"> of</font>

368
00:14:21,500 --> 00:14:25,610
the algorithm is you try both both

369
00:14:23,270 --> 00:14:27,800
options and then you look if you<font color="#E5E5E5"> get a</font>

370
00:14:25,610 --> 00:14:30,260
different response now if<font color="#E5E5E5"> I get a</font>

371
00:14:27,800 --> 00:14:33,829
different response in<font color="#CCCCCC"> the second case to</font>

372
00:14:30,260 --> 00:14:36,800
the B this means that it first aid that

373
00:14:33,830 --> 00:14:40,070
i sent cause an internal state change so

374
00:14:36,800 --> 00:14:42,260
if<font color="#E5E5E5"> i get a different answer after after</font>

375
00:14:40,070 --> 00:14:43,240
the after the B then I know the state

376
00:14:42,260 --> 00:14:45,680
machine looks something like this

377
00:14:43,240 --> 00:14:48,590
because there is a transition for the a

378
00:14:45,680 --> 00:14:50,719
if I don't<font color="#CCCCCC"> get a different response then</font>

379
00:14:48,590 --> 00:14:52,940
my conjecture could be that this<font color="#CCCCCC"> is the</font>

380
00:14:50,720 --> 00:14:54,950
state machine sort of doing<font color="#E5E5E5"> an a it's</font>

381
00:14:52,940 --> 00:14:56,540
not going to make a<font color="#E5E5E5"> difference so this</font>

382
00:14:54,950 --> 00:14:58,700
<font color="#CCCCCC">is</font><font color="#E5E5E5"> the whole idea of the algorithm and</font>

383
00:14:56,540 --> 00:15:01,849
then you just keep repeating this now

384
00:14:58,700 --> 00:15:03,440
<font color="#CCCCCC">that the algorithm is not perfect in a</font>

385
00:15:01,850 --> 00:15:05,750
sense that it's very<font color="#E5E5E5"> difficult to</font>

386
00:15:03,440 --> 00:15:08,540
exclude the fact that if I tried 10,000

387
00:15:05,750 --> 00:15:11,180
<font color="#E5E5E5">ace maybe then I will cause a CH state</font>

388
00:15:08,540 --> 00:15:13,069
change so there<font color="#CCCCCC"> is some limitations on</font>

389
00:15:11,180 --> 00:15:14,900
how accurately you will model the system

390
00:15:13,070 --> 00:15:17,480
so you only get an abstraction of the

391
00:15:14,900 --> 00:15:19,250
system and<font color="#E5E5E5"> of course if there's an input</font>

392
00:15:17,480 --> 00:15:20,840
action see and I'm not trying it out I

393
00:15:19,250 --> 00:15:24,620
don't learn<font color="#E5E5E5"> anything about the state</font>

394
00:15:20,840 --> 00:15:26,030
space that has to do with this and so so

395
00:15:24,620 --> 00:15:27,860
the state machine that you can<font color="#E5E5E5"> get out</font>

396
00:15:26,030 --> 00:15:31,130
is only as good as your approximation

397
00:15:27,860 --> 00:15:32,209
it's<font color="#E5E5E5"> only an approximation and it's</font><font color="#CCCCCC"> only</font>

398
00:15:31,130 --> 00:15:33,170
as good as the test

399
00:15:32,209 --> 00:15:36,128
interface that you have how many

400
00:15:33,170 --> 00:15:38,420
messages are you trying to<font color="#E5E5E5"> do give and</font>

401
00:15:36,129 --> 00:15:40,759
so the first example where we try this

402
00:15:38,420 --> 00:15:44,540
was which was really<font color="#E5E5E5"> successful was a</font>

403
00:15:40,759 --> 00:15:50,389
EMV in recent for Europe a<font color="#E5E5E5"> MasterCard</font>

404
00:15:44,540 --> 00:15:52,399
<font color="#E5E5E5">Visa am and if you have a bank card in</font>

405
00:15:50,389 --> 00:15:55,100
your pocket which has a chip<font color="#CCCCCC"> in there</font>

406
00:15:52,399 --> 00:15:59,779
you can bet that it's implementing a

407
00:15:55,100 --> 00:16:01,519
variant of EMV yesterday there was in

408
00:15:59,779 --> 00:16:03,589
the news here that scheming in the<font color="#CCCCCC"> u.s.</font>

409
00:16:01,519 --> 00:16:05,540
is going up like copying<font color="#E5E5E5"> magnetic</font>

410
00:16:03,589 --> 00:16:07,160
stripes which is not a surprise because

411
00:16:05,540 --> 00:16:08,420
of course all the criminals have moved

412
00:16:07,160 --> 00:16:11,179
<font color="#E5E5E5">to Europe now and they come to do it</font>

413
00:16:08,420 --> 00:16:15,439
here so they will be<font color="#E5E5E5"> rolling out in V</font>

414
00:16:11,179 --> 00:16:18,860
chip cards in the<font color="#E5E5E5"> States also in v-spec</font>

415
00:16:15,439 --> 00:16:22,699
is a bit nastier than<font color="#E5E5E5"> SSH the</font>

416
00:16:18,860 --> 00:16:25,699
specification is in<font color="#E5E5E5"> four books which is</font>

417
00:16:22,699 --> 00:16:27,139
<font color="#E5E5E5">totaling over</font><font color="#CCCCCC"> several hundred pages and</font>

418
00:16:25,699 --> 00:16:28,639
it's not<font color="#E5E5E5"> really a standard because i</font>

419
00:16:27,139 --> 00:16:30,709
think it's sort of a more of a<font color="#E5E5E5"> political</font>

420
00:16:28,639 --> 00:16:32,209
tool suite kit because<font color="#E5E5E5"> it's defining</font>

421
00:16:30,709 --> 00:16:36,979
lots of bits and pieces<font color="#CCCCCC"> that you could</font>

422
00:16:32,209 --> 00:16:39,859
use<font color="#CCCCCC"> to cobble together to do right do</font>

423
00:16:36,980 --> 00:16:41,779
right implement a banking card so

424
00:16:39,860 --> 00:16:43,819
there's now also a contactless version

425
00:16:41,779 --> 00:16:45,740
of this which is worse because then

426
00:16:43,819 --> 00:16:47,360
they'd have actually seven seven books

427
00:16:45,740 --> 00:16:53,110
with seven different standards which are

428
00:16:47,360 --> 00:16:55,309
partly compatible so so the specs are

429
00:16:53,110 --> 00:16:56,720
public but only in a sense that<font color="#E5E5E5"> they</font>

430
00:16:55,309 --> 00:16:59,029
define the message format they don't

431
00:16:56,720 --> 00:17:01,369
<font color="#E5E5E5">define the state machines and so we</font>

432
00:16:59,029 --> 00:17:03,679
wanted to understand it a bit better so

433
00:17:01,369 --> 00:17:05,929
we wrote the test a test harness which

434
00:17:03,679 --> 00:17:07,879
basically tries out some standards in<font color="#CCCCCC"> V</font>

435
00:17:05,929 --> 00:17:10,010
commands and looks at the response and

436
00:17:07,880 --> 00:17:12,380
this is<font color="#E5E5E5"> only</font><font color="#CCCCCC"> three hundred lines of code</font>

437
00:17:10,010 --> 00:17:16,220
and then if we use this this test

438
00:17:12,380 --> 00:17:18,470
harness and learn<font color="#E5E5E5"> it</font><font color="#CCCCCC"> and and we test it</font>

439
00:17:16,220 --> 00:17:20,959
using this algorithm for like 20 minutes

440
00:17:18,470 --> 00:17:23,839
then we get out<font color="#E5E5E5"> of state diagram or your</font>

441
00:17:20,959 --> 00:17:27,439
bank card so this is<font color="#CCCCCC"> a state machine of</font>

442
00:17:23,839 --> 00:17:28,850
a<font color="#E5E5E5"> German folks bank card so my</font>

443
00:17:27,439 --> 00:17:30,470
university is very close to<font color="#CCCCCC"> the German</font>

444
00:17:28,850 --> 00:17:31,699
border so we have<font color="#E5E5E5"> people with banks</font>

445
00:17:30,470 --> 00:17:34,309
across the border and<font color="#CCCCCC"> we can try</font>

446
00:17:31,700 --> 00:17:38,899
different cards so this<font color="#E5E5E5"> is what you get</font>

447
00:17:34,309 --> 00:17:41,750
out in<font color="#E5E5E5"> in half an hour or so you can</font>

448
00:17:38,899 --> 00:17:45,779
clearly identify that there's a handful

449
00:17:41,750 --> 00:17:48,210
of states eight or so the<font color="#CCCCCC"> little</font>

450
00:17:45,779 --> 00:17:50,669
out of arrows that you see in a lot of

451
00:17:48,210 --> 00:17:52,469
states this<font color="#E5E5E5"> is what I mentioned because</font>

452
00:17:50,669 --> 00:17:54,479
the thing it has to be input enabled and

453
00:17:52,469 --> 00:17:56,789
there are a lot of messages here in the

454
00:17:54,479 --> 00:17:59,759
protocol that if you send them at the

455
00:17:56,789 --> 00:18:02,190
wrong time they get ignored so this is

456
00:17:59,759 --> 00:18:05,489
<font color="#CCCCCC">actually if you if you try</font><font color="#E5E5E5"> to print this</font>

457
00:18:02,190 --> 00:18:08,190
off at a readable font size it becomes

458
00:18:05,489 --> 00:18:10,469
very very<font color="#E5E5E5"> wide so we do some tricks to</font>

459
00:18:08,190 --> 00:18:13,109
make it a bit more readable and if you

460
00:18:10,469 --> 00:18:15,059
simply merge all the arrows with which

461
00:18:13,109 --> 00:18:17,340
give<font color="#CCCCCC"> the same response so a lot of</font><font color="#E5E5E5"> these</font>

462
00:18:15,059 --> 00:18:20,820
arrows these little<font color="#E5E5E5"> circles they will</font>

463
00:18:17,340 --> 00:18:22,408
give you<font color="#CCCCCC"> standard error response if you</font>

464
00:18:20,820 --> 00:18:24,509
combine these you get something<font color="#E5E5E5"> which is</font>

465
00:18:22,409 --> 00:18:27,989
a bit more legible and<font color="#CCCCCC"> actually if you</font>

466
00:18:24,509 --> 00:18:30,389
combine all those arrows with with<font color="#E5E5E5"> the</font>

467
00:18:27,989 --> 00:18:33,299
same important with the same with the

468
00:18:30,389 --> 00:18:35,758
same begin state and end state you get a

469
00:18:33,299 --> 00:18:40,549
very readable format of actually the

470
00:18:35,759 --> 00:18:42,960
protocol and so this<font color="#CCCCCC"> is very nice</font>

471
00:18:40,549 --> 00:18:44,339
formulism then to use as a basis for

472
00:18:42,960 --> 00:18:48,739
understanding you<font color="#CCCCCC"> know is this</font>

473
00:18:44,339 --> 00:18:51,869
implementation of EMV secure so to our

474
00:18:48,739 --> 00:18:54,029
disappointment or we did not find<font color="#E5E5E5"> any</font>

475
00:18:51,869 --> 00:18:57,809
security bugs in the in the in the in

476
00:18:54,029 --> 00:19:01,739
the code but we found a bizarre variety

477
00:18:57,809 --> 00:19:03,389
of state machines between cards so it's

478
00:19:01,739 --> 00:19:05,460
my experience that if i take my<font color="#E5E5E5"> dutch</font>

479
00:19:03,389 --> 00:19:07,019
EMV cards and I stick it<font color="#E5E5E5"> into an ATM</font>

480
00:19:05,460 --> 00:19:10,499
anywhere in<font color="#E5E5E5"> the world I'll get money out</font>

481
00:19:07,019 --> 00:19:11,999
so<font color="#CCCCCC"> presumably there's a lot all</font><font color="#E5E5E5"> the</font>

482
00:19:10,499 --> 00:19:13,679
state machines of<font color="#CCCCCC"> although all the cars</font>

483
00:19:11,999 --> 00:19:16,259
are<font color="#E5E5E5"> different so my guess is</font><font color="#CCCCCC"> that ok</font>

484
00:19:13,679 --> 00:19:17,789
they all use some happy flow and a lot

485
00:19:16,259 --> 00:19:20,609
of the state that's actually there is

486
00:19:17,789 --> 00:19:24,029
actually redundant we didn't find<font color="#CCCCCC"> any</font>

487
00:19:20,609 --> 00:19:25,499
security bugs and now we did find the

488
00:19:24,029 --> 00:19:28,499
security bug in this<font color="#E5E5E5"> this internet</font>

489
00:19:25,499 --> 00:19:30,869
banking device<font color="#E5E5E5"> I showed earlier so we</font>

490
00:19:28,499 --> 00:19:34,289
also did state machine inference<font color="#E5E5E5"> for</font>

491
00:19:30,869 --> 00:19:38,009
this<font color="#E5E5E5"> device so the bank actually patched</font>

492
00:19:34,289 --> 00:19:40,229
the device of course the thing that

493
00:19:38,009 --> 00:19:41,339
actually give new new copies to the

494
00:19:40,229 --> 00:19:43,889
clients because you can't remotely

495
00:19:41,339 --> 00:19:48,629
updated they had several million of them

496
00:19:43,889 --> 00:19:51,718
in<font color="#E5E5E5"> the Netherlands and we infer the</font>

497
00:19:48,629 --> 00:19:53,218
state machine and here we in on the left

498
00:19:51,719 --> 00:19:54,389
you<font color="#CCCCCC"> see the original</font><font color="#E5E5E5"> state machine and</font>

499
00:19:53,219 --> 00:19:56,580
on the right you see the state machine

500
00:19:54,389 --> 00:19:57,250
of the patch device the red arrow there

501
00:19:56,580 --> 00:19:58,990
is

502
00:19:57,250 --> 00:20:00,640
security flaw that they had so they

503
00:19:58,990 --> 00:20:03,520
trimmed the state machine in the new

504
00:20:00,640 --> 00:20:06,310
implementation to get rid of the<font color="#CCCCCC"> get rid</font>

505
00:20:03,520 --> 00:20:08,320
of the security bug and one<font color="#E5E5E5"> of the funny</font>

506
00:20:06,310 --> 00:20:09,820
things<font color="#E5E5E5"> about this work was that to do</font>

507
00:20:08,320 --> 00:20:13,780
the fussing here we have to press the

508
00:20:09,820 --> 00:20:16,360
buttons and so I had some students they

509
00:20:13,780 --> 00:20:18,580
actually use Lego to make a little<font color="#E5E5E5"> lego</font>

510
00:20:16,360 --> 00:20:20,889
robot with three fingers which can press

511
00:20:18,580 --> 00:20:23,949
the buttons so we only need three

512
00:20:20,890 --> 00:20:26,200
fingers 140 k<font color="#E5E5E5"> 14</font><font color="#CCCCCC"> cancel and one for the</font>

513
00:20:23,950 --> 00:20:28,240
<font color="#E5E5E5">pin code and then our pin code is always</font>

514
00:20:26,200 --> 00:20:32,020
1 111 because then we only need one

515
00:20:28,240 --> 00:20:33,430
finger and so I was worried that<font color="#E5E5E5"> that</font>

516
00:20:32,020 --> 00:20:35,050
learning the state machine of this

517
00:20:33,430 --> 00:20:36,940
device would take weeks because<font color="#CCCCCC"> it's</font>

518
00:20:35,050 --> 00:20:38,980
it's not a very<font color="#E5E5E5"> fast robot that we built</font>

519
00:20:36,940 --> 00:20:40,270
but actually these two state machines

520
00:20:38,980 --> 00:20:43,330
they're obtained within two to three

521
00:20:40,270 --> 00:20:45,700
hours so this actually works<font color="#E5E5E5"> and the</font>

522
00:20:43,330 --> 00:20:48,520
<font color="#E5E5E5">only problem that we had so we ran more</font>

523
00:20:45,700 --> 00:20:50,140
extensive tests some of the buttons of

524
00:20:48,520 --> 00:20:53,020
<font color="#E5E5E5">the machine of the little device would</font>

525
00:20:50,140 --> 00:20:54,640
become would wear<font color="#CCCCCC"> outs right especially</font>

526
00:20:53,020 --> 00:20:57,580
<font color="#CCCCCC">the one for the pin code so</font><font color="#E5E5E5"> we had to</font>

527
00:20:54,640 --> 00:20:58,960
<font color="#E5E5E5">change the device a while yeah so we</font>

528
00:20:57,580 --> 00:21:00,610
<font color="#CCCCCC">actually have and we have a nice movie</font>

529
00:20:58,960 --> 00:21:02,650
on<font color="#E5E5E5"> YouTube I think this is my favorite</font>

530
00:21:00,610 --> 00:21:04,419
paper because it combines a formal

531
00:21:02,650 --> 00:21:09,550
method security and Legos or where you

532
00:21:04,420 --> 00:21:11,020
get that<font color="#E5E5E5"> run so of course so we could</font>

533
00:21:09,550 --> 00:21:12,340
confirm that they got<font color="#E5E5E5"> rid of this one</font>

534
00:21:11,020 --> 00:21:13,300
security vulnerability but then we

535
00:21:12,340 --> 00:21:15,970
wanted<font color="#E5E5E5"> to look if there were</font><font color="#CCCCCC"> other</font>

536
00:21:13,300 --> 00:21:18,909
security vulnerabilities so we also ran

537
00:21:15,970 --> 00:21:21,070
a more extreme test on the new device

538
00:21:18,910 --> 00:21:23,680
where we used a richer input alphabet

539
00:21:21,070 --> 00:21:28,990
and then to our<font color="#CCCCCC"> surprise we got a dis</font>

540
00:21:23,680 --> 00:21:30,910
state machine so the device basically

541
00:21:28,990 --> 00:21:32,560
only has to look if you press ok or not

542
00:21:30,910 --> 00:21:35,200
because<font color="#E5E5E5"> actually the checking of the pin</font>

543
00:21:32,560 --> 00:21:36,909
code is done by the smart<font color="#CCCCCC"> cards so</font><font color="#E5E5E5"> we</font>

544
00:21:35,200 --> 00:21:39,910
have no<font color="#E5E5E5"> idea why this device is so</font>

545
00:21:36,910 --> 00:21:42,450
complicated you can just about manually

546
00:21:39,910 --> 00:21:45,430
try to verify that it is secure but as a

547
00:21:42,450 --> 00:21:47,350
what we actually did is we fed this

548
00:21:45,430 --> 00:21:49,750
state machine to a model checker and

549
00:21:47,350 --> 00:21:51,879
then<font color="#E5E5E5"> Express the security property in</font>

550
00:21:49,750 --> 00:21:54,880
temporal logic and automatically verify

551
00:21:51,880 --> 00:21:57,190
this so we couldn't<font color="#E5E5E5"> find more security</font>

552
00:21:54,880 --> 00:22:00,640
flaws but this sort of complexity is a

553
00:21:57,190 --> 00:22:02,230
bit worrying i think because<font color="#CCCCCC"> i mean yeah</font>

554
00:22:00,640 --> 00:22:03,940
<font color="#CCCCCC">i don't</font><font color="#E5E5E5"> have any i don't i don't</font>

555
00:22:02,230 --> 00:22:05,590
<font color="#E5E5E5">expected to people who develop this had</font>

556
00:22:03,940 --> 00:22:06,450
any clue that this<font color="#E5E5E5"> what they implemented</font>

557
00:22:05,590 --> 00:22:09,000
or designed

558
00:22:06,450 --> 00:22:10,740
and that they were<font color="#E5E5E5"> really confident and</font>

559
00:22:09,000 --> 00:22:12,870
was secure and<font color="#E5E5E5"> my guess is that there's</font>

560
00:22:10,740 --> 00:22:16,580
a lot of branches in the state machine

561
00:22:12,870 --> 00:22:18,629
that are completely unnecessary so um

562
00:22:16,580 --> 00:22:22,050
earlier last year there were some issues

563
00:22:18,630 --> 00:22:24,840
with TLS and so we also said<font color="#CCCCCC"> okay</font><font color="#E5E5E5"> let's</font>

564
00:22:22,050 --> 00:22:26,340
have a look<font color="#E5E5E5"> at TLS TLS is of course a</font>

565
00:22:24,840 --> 00:22:27,480
<font color="#CCCCCC">very important protocols you expect</font>

566
00:22:26,340 --> 00:22:30,959
people have thought<font color="#CCCCCC"> about the state</font>

567
00:22:27,480 --> 00:22:35,430
machine for a lot and so we wrote test

568
00:22:30,960 --> 00:22:38,040
harness to two<font color="#CCCCCC"> test TLS servers and then</font>

569
00:22:35,430 --> 00:22:40,200
we tried out different ones so this is

570
00:22:38,040 --> 00:22:42,210
<font color="#CCCCCC">the state machine of</font><font color="#E5E5E5"> the NS NS s</font>

571
00:22:40,200 --> 00:22:45,060
implementation and this is actually

572
00:22:42,210 --> 00:22:47,240
<font color="#E5E5E5">quite a nice state machine so the green</font>

573
00:22:45,060 --> 00:22:50,520
transitions here this is a normal

574
00:22:47,240 --> 00:22:53,400
<font color="#E5E5E5">successful TLS handshake followed</font><font color="#CCCCCC"> by a</font>

575
00:22:50,520 --> 00:22:55,920
small session and all they are other

576
00:22:53,400 --> 00:22:57,510
errors are basically erroneous

577
00:22:55,920 --> 00:22:59,010
transitions where you sort of kick get

578
00:22:57,510 --> 00:23:03,090
Kidd back kick back to some error state

579
00:22:59,010 --> 00:23:04,110
at<font color="#E5E5E5"> the end so this was a from a security</font>

580
00:23:03,090 --> 00:23:05,550
point of view this is a nice

581
00:23:04,110 --> 00:23:08,699
implementation because the the

582
00:23:05,550 --> 00:23:15,450
specification is so simple but then nu

583
00:23:08,700 --> 00:23:18,540
te s looks like this so we discovered a

584
00:23:15,450 --> 00:23:20,460
funny buggin in the glue TLS was that so

585
00:23:18,540 --> 00:23:22,710
TLS is a nice trick that after you do

586
00:23:20,460 --> 00:23:24,600
the handshake both parties compute<font color="#E5E5E5"> the</font>

587
00:23:22,710 --> 00:23:26,190
hash over the entire handshake<font color="#CCCCCC"> now this</font>

588
00:23:24,600 --> 00:23:28,290
all the sequences of hand and<font color="#CCCCCC"> chicken</font>

589
00:23:26,190 --> 00:23:30,240
messages and they send there's a cross

590
00:23:28,290 --> 00:23:32,310
to each other to verify that the

591
00:23:30,240 --> 00:23:34,410
handshake was success successful and

592
00:23:32,310 --> 00:23:36,480
then you can also really rule out any

593
00:23:34,410 --> 00:23:38,630
man in the middle attacks because you

594
00:23:36,480 --> 00:23:41,100
you've you've both seen the same hash

595
00:23:38,630 --> 00:23:43,110
now we found out that apparently<font color="#E5E5E5"> the</font>

596
00:23:41,100 --> 00:23:45,480
buffer that's used<font color="#E5E5E5"> to compute this s ash</font>

597
00:23:43,110 --> 00:23:48,060
is<font color="#E5E5E5"> also used by the</font><font color="#CCCCCC"> heartbeat</font>

598
00:23:45,480 --> 00:23:51,030
functionality so if you send a heartbeat

599
00:23:48,060 --> 00:23:52,830
during the key exchange and which is

600
00:23:51,030 --> 00:23:56,580
probably silly idea but I'm not sure<font color="#E5E5E5"> if</font>

601
00:23:52,830 --> 00:23:58,620
it's disallowed by just back yet you can

602
00:23:56,580 --> 00:24:00,740
actually screw up this value so you

603
00:23:58,620 --> 00:24:04,530
could do a man-in-the-middle attack on

604
00:24:00,740 --> 00:24:06,210
<font color="#CCCCCC">avenue TLS server and</font><font color="#E5E5E5"> in an emic line</font>

605
00:24:04,530 --> 00:24:07,260
which is<font color="#E5E5E5"> the same vulnerability you</font>

606
00:24:06,210 --> 00:24:08,550
could do we meet men in the middle

607
00:24:07,260 --> 00:24:11,010
attack and then at the<font color="#CCCCCC"> end of the key</font>

608
00:24:08,550 --> 00:24:12,570
exchange send both<font color="#CCCCCC"> of them are big</font>

609
00:24:11,010 --> 00:24:14,520
message to reset this buffer and then

610
00:24:12,570 --> 00:24:16,439
they send an empty hash or a hash over

611
00:24:14,520 --> 00:24:18,129
an empty<font color="#E5E5E5"> string to each other and they</font>

612
00:24:16,440 --> 00:24:20,600
agree

613
00:24:18,130 --> 00:24:24,350
but then of<font color="#E5E5E5"> course it can get worse so</font>

614
00:24:20,600 --> 00:24:27,230
this is the state machine for openssl so

615
00:24:24,350 --> 00:24:28,580
this is<font color="#E5E5E5"> of course SS so I'm not</font><font color="#CCCCCC"> sure</font><font color="#E5E5E5"> how</font>

616
00:24:27,230 --> 00:24:32,179
many<font color="#E5E5E5"> of you saw the talk earlier this</font>

617
00:24:28,580 --> 00:24:35,270
week by the the people from inner ear

618
00:24:32,179 --> 00:24:39,620
and hearing<font color="#CCCCCC"> pls were only</font><font color="#E5E5E5"> trying 11</font>

619
00:24:35,270 --> 00:24:42,110
<font color="#CCCCCC">cipher as one set of key exchange</font>

620
00:24:39,620 --> 00:24:44,570
algorithms and one set of crypto

621
00:24:42,110 --> 00:24:46,490
algorithms so just you do one variant

622
00:24:44,570 --> 00:24:49,879
and we just<font color="#E5E5E5"> use doing the full and check</font>

623
00:24:46,490 --> 00:24:51,799
not abbreviated once so<font color="#CCCCCC"> it was actually</font>

624
00:24:49,880 --> 00:24:53,929
<font color="#E5E5E5">surprising that if you look to do more</font>

625
00:24:51,799 --> 00:24:55,190
mature implementations of<font color="#E5E5E5"> SSL we found</font>

626
00:24:53,929 --> 00:24:58,370
<font color="#E5E5E5">that the state machines become more</font>

627
00:24:55,190 --> 00:25:00,110
complicated one conjecture could be that

628
00:24:58,370 --> 00:25:01,250
<font color="#CCCCCC">codes</font><font color="#E5E5E5"> been around for longer and people</font>

629
00:25:00,110 --> 00:25:03,500
have been messing<font color="#CCCCCC"> with the code for</font><font color="#E5E5E5"> a</font>

630
00:25:01,250 --> 00:25:05,690
long time<font color="#CCCCCC"> and there's all this perious</font>

631
00:25:03,500 --> 00:25:09,169
complexity in there and then the worst

632
00:25:05,690 --> 00:25:11,690
one we found<font color="#E5E5E5"> was Java secure socket</font>

633
00:25:09,169 --> 00:25:14,419
exchange because there we could actually

634
00:25:11,690 --> 00:25:16,730
see from seduces state machine that we

635
00:25:14,419 --> 00:25:19,279
learn the red arrows there this is

636
00:25:16,730 --> 00:25:21,710
already a security problem because you

637
00:25:19,279 --> 00:25:25,190
end up<font color="#E5E5E5"> in the correct state or a</font>

638
00:25:21,710 --> 00:25:26,870
seemingly connect correct state but not

639
00:25:25,190 --> 00:25:28,880
by completing the fool handshake and

640
00:25:26,870 --> 00:25:32,870
this is also where the freak

641
00:25:28,880 --> 00:25:36,470
vulnerability comes in and then two or

642
00:25:32,870 --> 00:25:38,418
so we tried seven or eight or so TLS

643
00:25:36,470 --> 00:25:41,720
implementations and they none of<font color="#E5E5E5"> them</font>

644
00:25:38,419 --> 00:25:43,010
have the same state machine and my guess

645
00:25:41,720 --> 00:25:45,799
is that<font color="#CCCCCC"> the one on the bottom right</font><font color="#E5E5E5"> is</font>

646
00:25:43,010 --> 00:25:48,230
the best and all the other ones I mean

647
00:25:45,799 --> 00:25:51,850
you could trim the the source code to

648
00:25:48,230 --> 00:25:55,850
get rid of all the all the extra junk I

649
00:25:51,850 --> 00:25:58,010
think this<font color="#CCCCCC"> is</font><font color="#E5E5E5"> the NSS one and of course</font>

650
00:25:55,850 --> 00:26:00,080
<font color="#E5E5E5">if there is a redundant state it's not</font>

651
00:25:58,010 --> 00:26:02,840
trivial to check if there was a security

652
00:26:00,080 --> 00:26:04,370
vulnerability so we found one thing that

653
00:26:02,840 --> 00:26:06,860
could<font color="#CCCCCC"> be exploited in two things which</font>

654
00:26:04,370 --> 00:26:08,330
could probably not be exploited but this

655
00:26:06,860 --> 00:26:09,860
extra state shouldn't be there<font color="#E5E5E5"> right you</font>

656
00:26:08,330 --> 00:26:14,330
shouldn't be worrying about this sort<font color="#E5E5E5"> of</font>

657
00:26:09,860 --> 00:26:16,969
behavior<font color="#E5E5E5"> okay so on to my conclusion so</font>

658
00:26:14,330 --> 00:26:19,010
I'd like<font color="#CCCCCC"> to argue that I mean the same</font>

659
00:26:16,970 --> 00:26:20,809
<font color="#E5E5E5">length set principles that are useful</font>

660
00:26:19,010 --> 00:26:23,450
when looking at processing input

661
00:26:20,809 --> 00:26:25,639
messages are also useful that when

662
00:26:23,450 --> 00:26:27,409
you're<font color="#CCCCCC"> looking at the session languages</font>

663
00:26:25,640 --> 00:26:29,510
and processing sequences of messages

664
00:26:27,409 --> 00:26:30,980
because<font color="#CCCCCC"> ok we see the same issues that</font>

665
00:26:29,510 --> 00:26:33,049
<font color="#E5E5E5">the specifications are</font>

666
00:26:30,980 --> 00:26:35,390
are not clear you see a lot<font color="#CCCCCC"> of variation</font>

667
00:26:33,049 --> 00:26:38,210
in implementations and<font color="#E5E5E5"> some</font><font color="#CCCCCC"> security box</font>

668
00:26:35,390 --> 00:26:39,950
because of this and so it's not really

669
00:26:38,210 --> 00:26:42,110
<font color="#CCCCCC">clear to me yet it's sort of how common</font>

670
00:26:39,950 --> 00:26:45,190
this category of security flaws are but

671
00:26:42,110 --> 00:26:48,260
my guess is that there's more out there

672
00:26:45,190 --> 00:26:51,740
so if you then compare the notion of a

673
00:26:48,260 --> 00:26:54,650
session language with with the<font color="#CCCCCC"> notion of</font>

674
00:26:51,740 --> 00:26:57,679
the message format or the<font color="#CCCCCC"> language</font><font color="#E5E5E5"> I</font>

675
00:26:54,650 --> 00:26:59,990
think so a lot of specs they will have

676
00:26:57,679 --> 00:27:01,850
an e BNF somewhere in an appendix but<font color="#E5E5E5"> I</font>

677
00:26:59,990 --> 00:27:03,980
think the state machines are actually

678
00:27:01,850 --> 00:27:07,969
less likely to be rigorously specified

679
00:27:03,980 --> 00:27:10,850
and one practical problem I notices that

680
00:27:07,970 --> 00:27:12,710
actually giving a full completes<font color="#E5E5E5"> a state</font>

681
00:27:10,850 --> 00:27:14,209
machine I think it's actually<font color="#E5E5E5"> harder in</font>

682
00:27:12,710 --> 00:27:16,790
most cases than writing an email at

683
00:27:14,210 --> 00:27:18,950
grammar because especially handling all

684
00:27:16,790 --> 00:27:20,360
the error transitions and because you

685
00:27:18,950 --> 00:27:22,520
have to come up with an input enabled

686
00:27:20,360 --> 00:27:24,290
state machine actually<font color="#E5E5E5"> doing this in</font>

687
00:27:22,520 --> 00:27:25,730
practice is a bit of a challenge so I'm

688
00:27:24,290 --> 00:27:28,580
not<font color="#CCCCCC"> sure in practice what is the best</font>

689
00:27:25,730 --> 00:27:30,650
way of doing<font color="#CCCCCC"> this and and what I also</font>

690
00:27:28,580 --> 00:27:33,260
think it's a more difficult<font color="#CCCCCC"> for session</font>

691
00:27:30,650 --> 00:27:35,059
languages is generating code so it's

692
00:27:33,260 --> 00:27:37,549
trivial if you have an e BNF grammar to

693
00:27:35,059 --> 00:27:39,379
spit out some code now of<font color="#E5E5E5"> course if you</font>

694
00:27:37,549 --> 00:27:41,690
<font color="#CCCCCC">have a state machine you could spit out</font>

695
00:27:39,380 --> 00:27:44,360
some code but this code still has to<font color="#CCCCCC"> be</font>

696
00:27:41,690 --> 00:27:47,840
merged with some existing code because

697
00:27:44,360 --> 00:27:49,879
there is<font color="#CCCCCC"> more to ya handling the session</font>

698
00:27:47,840 --> 00:27:53,178
than just determining what type of input

699
00:27:49,880 --> 00:27:54,620
messages you have so if you have a

700
00:27:53,179 --> 00:27:57,559
language where you have for instance

701
00:27:54,620 --> 00:27:59,149
aspect orientation you might be able<font color="#E5E5E5"> to</font>

702
00:27:57,559 --> 00:28:01,399
factor out the state machine as a

703
00:27:59,150 --> 00:28:05,390
separate aspect but in general I think

704
00:28:01,400 --> 00:28:07,160
that yet to handle the the the the state

705
00:28:05,390 --> 00:28:08,990
machine you will<font color="#CCCCCC"> you will need some sort</font>

706
00:28:07,160 --> 00:28:10,760
<font color="#E5E5E5">of a scattershot approach because there</font>

707
00:28:08,990 --> 00:28:14,169
will be different pieces of code

708
00:28:10,760 --> 00:28:17,690
handling this sets at various places and

709
00:28:14,169 --> 00:28:19,610
<font color="#E5E5E5">so I think the good</font><font color="#CCCCCC"> news is what I've</font>

710
00:28:17,690 --> 00:28:21,770
shown you said it's actually quite easy

711
00:28:19,610 --> 00:28:24,860
to extract state machines for a lot of

712
00:28:21,770 --> 00:28:27,168
existing protocols so this morning<font color="#E5E5E5"> is</font>

713
00:28:24,860 --> 00:28:28,939
we've mentioned that in practice with

714
00:28:27,169 --> 00:28:31,100
grammar learning you<font color="#E5E5E5"> can actually learn</font>

715
00:28:28,940 --> 00:28:32,900
a lot of input alphabets I think it's

716
00:28:31,100 --> 00:28:34,699
<font color="#E5E5E5">even easier for state machines because</font>

717
00:28:32,900 --> 00:28:39,409
in practice<font color="#E5E5E5"> they're not quite as wild</font>

718
00:28:34,700 --> 00:28:41,659
and of course you if somebody actually

719
00:28:39,409 --> 00:28:43,970
makes a malicious back door in the code

720
00:28:41,659 --> 00:28:44,750
you are not going<font color="#E5E5E5"> to find it using the</font>

721
00:28:43,970 --> 00:28:46,940
state

722
00:28:44,750 --> 00:28:48,740
machine inference but if<font color="#CCCCCC"> there is an</font>

723
00:28:46,940 --> 00:28:50,270
accidental flow on the program logic it

724
00:28:48,740 --> 00:28:54,050
will typically show up that's sort of my

725
00:28:50,270 --> 00:28:55,730
gut feeling and and finally when if you

726
00:28:54,050 --> 00:28:57,740
look at the danger from<font color="#E5E5E5"> the perspective</font>

727
00:28:55,730 --> 00:29:01,640
of providing a weird machine to an

728
00:28:57,740 --> 00:29:03,050
attacker<font color="#E5E5E5"> I think that if you have a bug</font>

729
00:29:01,640 --> 00:29:05,840
in the state machine typically somebody

730
00:29:03,050 --> 00:29:07,100
can bypass some security check or they

731
00:29:05,840 --> 00:29:09,350
can<font color="#E5E5E5"> access some functionality they</font>

732
00:29:07,100 --> 00:29:11,449
should not<font color="#E5E5E5"> be able to</font><font color="#CCCCCC"> access but I don't</font>

733
00:29:09,350 --> 00:29:13,360
<font color="#E5E5E5">think you will are likely</font><font color="#CCCCCC"> to provide</font><font color="#E5E5E5"> a</font>

734
00:29:11,450 --> 00:29:17,060
lot<font color="#CCCCCC"> of you know a</font><font color="#E5E5E5"> very rich</font>

735
00:29:13,360 --> 00:29:20,330
computationally rich a weight machine to

736
00:29:17,060 --> 00:29:22,250
your attacker so I think<font color="#E5E5E5"> sort of the</font>

737
00:29:20,330 --> 00:29:24,260
weird state machines that we've seen are

738
00:29:22,250 --> 00:29:25,940
not<font color="#E5E5E5"> really weird machines in a sense</font>

739
00:29:24,260 --> 00:29:27,580
<font color="#CCCCCC">that you can actually easily program the</font>

740
00:29:25,940 --> 00:29:31,100
more do a lot programming not with them

741
00:29:27,580 --> 00:29:46,460
<font color="#CCCCCC">okay I'm suit ending in good Langston</font>

742
00:29:31,100 --> 00:29:51,669
<font color="#E5E5E5">lang sec tradition like this game I'll</font>

743
00:29:46,460 --> 00:29:55,070
take questions<font color="#CCCCCC"> now yes this is</font><font color="#E5E5E5"> excellent</font>

744
00:29:51,670 --> 00:29:56,990
<font color="#CCCCCC">yeah actually</font><font color="#E5E5E5"> I got started</font><font color="#CCCCCC"> on</font><font color="#E5E5E5"> Lang seg</font>

745
00:29:55,070 --> 00:29:58,820
by actually some somebody's giving a

746
00:29:56,990 --> 00:30:00,320
presentation and using one of these

747
00:29:58,820 --> 00:30:02,149
slides<font color="#E5E5E5"> from you i think the ccc</font>

748
00:30:00,320 --> 00:30:11,560
presentation and this got me hooked on

749
00:30:02,150 --> 00:30:14,510
let me find out what this is hey Julian

750
00:30:11,560 --> 00:30:16,399
<font color="#CCCCCC">Bloomberg yeah great talk very</font>

751
00:30:14,510 --> 00:30:19,340
entertaining I have a<font color="#E5E5E5"> question about the</font>

752
00:30:16,400 --> 00:30:21,850
EMV you know this you don so you

753
00:30:19,340 --> 00:30:24,439
mentioned that you didn't find any

754
00:30:21,850 --> 00:30:27,409
vulnerabilities however all the state

755
00:30:24,440 --> 00:30:30,350
machines are different yeah so do<font color="#E5E5E5"> you</font>

756
00:30:27,410 --> 00:30:32,930
know if they are equivalent<font color="#E5E5E5"> inside in</font>

757
00:30:30,350 --> 00:30:36,649
some way for<font color="#E5E5E5"> some other trace like</font>

758
00:30:32,930 --> 00:30:41,210
<font color="#E5E5E5">equivalent up to traces or equivalent up</font>

759
00:30:36,650 --> 00:30:43,850
to observations of know and<font color="#E5E5E5"> I know some</font>

760
00:30:41,210 --> 00:30:46,460
some machines are really different but

761
00:30:43,850 --> 00:30:48,020
<font color="#E5E5E5">but also because the MV is not a single</font>

762
00:30:46,460 --> 00:30:51,500
protocol which is sort of a family of

763
00:30:48,020 --> 00:30:53,570
protocols and in some settings the

764
00:30:51,500 --> 00:30:55,460
protocol sold on a typical<font color="#CCCCCC"> bankart are</font>

765
00:30:53,570 --> 00:30:56,929
actually multiple EMV implementations

766
00:30:55,460 --> 00:30:58,370
and

767
00:30:56,930 --> 00:31:00,800
actually enforce different security

768
00:30:58,370 --> 00:31:04,340
<font color="#CCCCCC">policies so just the simplest example is</font>

769
00:31:00,800 --> 00:31:05,990
that<font color="#E5E5E5"> and so there's an application on</font>

770
00:31:04,340 --> 00:31:08,330
<font color="#E5E5E5">Dutch EMV cards which we use for</font>

771
00:31:05,990 --> 00:31:10,130
internet banking and in this case the

772
00:31:08,330 --> 00:31:11,389
pain is verified offline typically

773
00:31:10,130 --> 00:31:16,120
<font color="#E5E5E5">because the internet banking devices</font>

774
00:31:11,390 --> 00:31:19,070
offline whereas for an ATM the pension

775
00:31:16,120 --> 00:31:20,689
verification might be might<font color="#CCCCCC"> be done</font>

776
00:31:19,070 --> 00:31:22,879
online and then it's not checked by the

777
00:31:20,690 --> 00:31:25,880
other card so there is some explanation

778
00:31:22,880 --> 00:31:28,580
for some of the differences but not for

779
00:31:25,880 --> 00:31:30,920
all of them<font color="#E5E5E5"> okay it also second question</font>

780
00:31:28,580 --> 00:31:32,659
did<font color="#CCCCCC"> you have to look manually at the</font>

781
00:31:30,920 --> 00:31:34,190
state machines to figure out whether you

782
00:31:32,660 --> 00:31:37,820
had a vulnerability or did you have some

783
00:31:34,190 --> 00:31:39,800
sort of automated so in practice<font color="#E5E5E5"> we've</font>

784
00:31:37,820 --> 00:31:41,689
so the<font color="#E5E5E5"> only example where</font><font color="#CCCCCC"> we used to</font>

785
00:31:39,800 --> 00:31:43,159
model check was 11<font color="#E5E5E5"> I showed you at the</font>

786
00:31:41,690 --> 00:31:45,830
<font color="#E5E5E5">end which was getting a bit complicated</font>

787
00:31:43,160 --> 00:31:50,800
and<font color="#E5E5E5"> boring to do by hand typically we've</font>

788
00:31:45,830 --> 00:31:50,800
done it with a manual analysis thank you

789
00:31:51,880 --> 00:31:58,700
<font color="#CCCCCC">thanks um I had the opposite intuition</font>

790
00:31:56,540 --> 00:32:01,310
about this methods ability to detect

791
00:31:58,700 --> 00:32:02,630
backdoors I'm just curious um do you

792
00:32:01,310 --> 00:32:04,550
think<font color="#E5E5E5"> that it would have difficulty</font>

793
00:32:02,630 --> 00:32:06,740
detecting backdoors just because they're

794
00:32:04,550 --> 00:32:08,330
so well hidden and the the automatic

795
00:32:06,740 --> 00:32:11,480
discovery of the state machine we didn't

796
00:32:08,330 --> 00:32:13,159
find them or yeah yeah so when you

797
00:32:11,480 --> 00:32:14,990
you're learning the state machine for

798
00:32:13,160 --> 00:32:18,830
<font color="#E5E5E5">your sending you know typical messages</font>

799
00:32:14,990 --> 00:32:20,060
of a certain type but you know the back

800
00:32:18,830 --> 00:32:22,460
door might be triggered with this<font color="#E5E5E5"> very</font>

801
00:32:20,060 --> 00:32:24,560
specific palos like for instance<font color="#E5E5E5"> you</font>

802
00:32:22,460 --> 00:32:26,060
<font color="#E5E5E5">know</font><font color="#CCCCCC"> Kane in the sshd</font><font color="#E5E5E5"> won't be random</font>

803
00:32:24,560 --> 00:32:28,280
numbers that you throw in doing this the

804
00:32:26,060 --> 00:32:31,040
key exchange we are not<font color="#E5E5E5"> going to try all</font>

805
00:32:28,280 --> 00:32:32,300
the random numbers and maybe you open

806
00:32:31,040 --> 00:32:33,710
the back door with one of these<font color="#E5E5E5"> random</font>

807
00:32:32,300 --> 00:32:37,190
numbers so you're never<font color="#E5E5E5"> going to</font><font color="#CCCCCC"> find</font>

808
00:32:33,710 --> 00:32:38,450
this just by blindly testing so one

809
00:32:37,190 --> 00:32:41,420
thing<font color="#CCCCCC"> you might try to do is for</font>

810
00:32:38,450 --> 00:32:43,550
instance<font color="#E5E5E5"> combined weight but then it's</font>

811
00:32:41,420 --> 00:32:45,890
not longer a white box approach but more

812
00:32:43,550 --> 00:32:48,230
of a black normal or black<font color="#E5E5E5"> box approach</font>

813
00:32:45,890 --> 00:32:49,430
but more of a<font color="#E5E5E5"> grey box approach when</font>

814
00:32:48,230 --> 00:32:50,420
you're learning<font color="#CCCCCC"> the state machine you</font>

815
00:32:49,430 --> 00:32:52,430
could for instance look if there's

816
00:32:50,420 --> 00:32:55,040
pieces of the code<font color="#CCCCCC"> that you don't reach</font>

817
00:32:52,430 --> 00:32:56,450
and that might be a different way that

818
00:32:55,040 --> 00:32:58,340
either there's dead code in the

819
00:32:56,450 --> 00:33:00,320
implementation which is of course not

820
00:32:58,340 --> 00:33:01,550
inconceivable but that could also then

821
00:33:00,320 --> 00:33:04,480
be a back door because you're not

822
00:33:01,550 --> 00:33:04,480
wriggling that functionality

823
00:33:11,549 --> 00:33:19,750
just real quick um i've been thinking

824
00:33:14,799 --> 00:33:22,418
about<font color="#E5E5E5"> how to how to specify specified</font>

825
00:33:19,750 --> 00:33:26,409
protocol state machines and how to

826
00:33:22,419 --> 00:33:29,769
generate code from them since you

827
00:33:26,409 --> 00:33:31,299
mentioned this<font color="#E5E5E5"> only in the end I the</font>

828
00:33:29,769 --> 00:33:33,100
question is how much<font color="#E5E5E5"> work have you done</font>

829
00:33:31,299 --> 00:33:35,799
on this and will you continue<font color="#E5E5E5"> in this</font>

830
00:33:33,100 --> 00:33:37,719
direction so<font color="#E5E5E5"> we actually did the first</font>

831
00:33:35,799 --> 00:33:39,580
work we've done but it's like 12<font color="#E5E5E5"> years</font>

832
00:33:37,720 --> 00:33:42,700
<font color="#E5E5E5">ago we actually had some stooling to</font>

833
00:33:39,580 --> 00:33:45,220
generate state machines from code so we

834
00:33:42,700 --> 00:33:47,440
<font color="#CCCCCC">had a tool where we generated Java card</font>

835
00:33:45,220 --> 00:33:49,179
smart card code from state machines and

836
00:33:47,440 --> 00:33:50,799
also actually method contracts that we

837
00:33:49,179 --> 00:33:53,049
could verify that if you change<font color="#E5E5E5"> the code</font>

838
00:33:50,799 --> 00:33:54,220
afterwards stay was still correct there

839
00:33:53,049 --> 00:33:56,230
are some there are some other

840
00:33:54,220 --> 00:33:58,690
alternatives<font color="#E5E5E5"> there's on the system</font>

841
00:33:56,230 --> 00:34:01,720
called Rachel which tries to do

842
00:33:58,690 --> 00:34:05,320
generation of state machines and I guess

843
00:34:01,720 --> 00:34:07,029
if you look<font color="#E5E5E5"> at any of the UML suite of</font>

844
00:34:05,320 --> 00:34:09,879
tools they can probably generate some

845
00:34:07,029 --> 00:34:11,830
code from state machines and but it's

846
00:34:09,879 --> 00:34:15,098
not<font color="#E5E5E5"> something I'm I plan to be working</font>

847
00:34:11,830 --> 00:34:17,889
on because in the end it's<font color="#CCCCCC"> not</font><font color="#E5E5E5"> very nice</font>

848
00:34:15,099 --> 00:34:19,629
<font color="#E5E5E5">I mean because you still</font><font color="#CCCCCC"> have to</font>

849
00:34:17,889 --> 00:34:21,129
intersperse it with normal code so for

850
00:34:19,629 --> 00:34:23,469
instance in Rachel you specify the state

851
00:34:21,129 --> 00:34:24,909
machine and then bits of C code which

852
00:34:23,469 --> 00:34:30,598
you stick on the transactions which is

853
00:34:24,909 --> 00:34:30,599
still<font color="#E5E5E5"> a bit</font><font color="#CCCCCC"> ok</font>

854
00:34:41,560 --> 00:34:50,000
and I propose we call this meddling sec

855
00:34:44,300 --> 00:34:51,290
I think one of the big progresses of

856
00:34:50,000 --> 00:35:11,840
smartphones is that people can take

857
00:34:51,290 --> 00:35:16,009
photographs<font color="#E5E5E5"> of whiteboards oh I was</font><font color="#CCCCCC"> just</font>

858
00:35:11,840 --> 00:35:17,930
saying in about skinning whiteboards and

859
00:35:16,010 --> 00:35:19,520
cell phones taking images i just noticed

860
00:35:17,930 --> 00:35:22,940
flooding on my street stream today

861
00:35:19,520 --> 00:35:25,250
there's I yet another round of articles

862
00:35:22,940 --> 00:35:28,430
<font color="#E5E5E5">in commentary about the jaebaek to bug</font>

863
00:35:25,250 --> 00:35:30,680
in the<font color="#CCCCCC"> Xerox document Center scanners</font>

864
00:35:28,430 --> 00:35:36,100
and the patchwork algorithm that they

865
00:35:30,680 --> 00:35:36,100
use for compressions so that's a yeah

