1
00:00:00,100 --> 00:00:08,860
any questions all right<font color="#E5E5E5"> sagia calls it</font>

2
00:00:07,600 --> 00:00:11,170
an invite you thought I call it research

3
00:00:08,860 --> 00:00:14,050
report because it's<font color="#E5E5E5"> really what it is is</font>

4
00:00:11,170 --> 00:00:18,160
more like a good bunch of you<font color="#E5E5E5"> know brain</font>

5
00:00:14,050 --> 00:00:19,750
you<font color="#E5E5E5"> know brain dumps from me so thanks</font>

6
00:00:18,160 --> 00:00:23,619
for<font color="#E5E5E5"> being here my enemies univer-</font>

7
00:00:19,750 --> 00:00:26,320
<font color="#CCCCCC">lumberg as a security architect today my</font>

8
00:00:23,619 --> 00:00:29,140
talk is about heat models for<font color="#CCCCCC"> exploited</font>

9
00:00:26,320 --> 00:00:31,180
seems so half of the talk will be pretty

10
00:00:29,140 --> 00:00:32,589
<font color="#E5E5E5">much about remaining you guys what we're</font>

11
00:00:31,180 --> 00:00:36,309
talking about making<font color="#CCCCCC"> sure we on the same</font>

12
00:00:32,589 --> 00:00:37,748
page and the other half of<font color="#E5E5E5"> the talk</font>

13
00:00:36,309 --> 00:00:40,479
would be a bit more formal or

14
00:00:37,749 --> 00:00:42,309
tentatively formal with you know<font color="#CCCCCC"> the</font>

15
00:00:40,479 --> 00:00:43,749
kind of insights<font color="#E5E5E5"> I think I have gained</font>

16
00:00:42,309 --> 00:00:47,858
by analyzing a lot of<font color="#CCCCCC"> different heap</font>

17
00:00:43,749 --> 00:00:49,569
allocators over the years so how many<font color="#E5E5E5"> of</font>

18
00:00:47,859 --> 00:00:53,530
you have written a heap overflow

19
00:00:49,569 --> 00:00:56,559
exploits before many all right excellent

20
00:00:53,530 --> 00:00:58,120
<font color="#E5E5E5">so if there is anything wrong you know</font>

21
00:00:56,559 --> 00:01:02,019
what I say please interrupt me right

22
00:00:58,120 --> 00:01:05,340
away I'll<font color="#E5E5E5"> be glad to be proven wrong on</font>

23
00:01:02,019 --> 00:01:07,360
anything and always eager to improve so

24
00:01:05,340 --> 00:01:09,009
interrupt me anytime if you have

25
00:01:07,360 --> 00:01:11,560
questions during the talk you feel free

26
00:01:09,009 --> 00:01:13,509
to actually<font color="#E5E5E5"> you know ask them right away</font>

27
00:01:11,560 --> 00:01:17,560
you<font color="#E5E5E5"> don't have to end to the</font><font color="#CCCCCC"> end so</font>

28
00:01:13,509 --> 00:01:20,710
let's get started the big picture<font color="#E5E5E5"> of</font>

29
00:01:17,560 --> 00:01:22,359
this<font color="#E5E5E5"> work is what I</font><font color="#CCCCCC"> called one or two</font>

30
00:01:20,710 --> 00:01:25,689
<font color="#CCCCCC">years ago</font><font color="#E5E5E5"> the automated exportation</font>

31
00:01:22,359 --> 00:01:27,699
grand challenge as you may all be

32
00:01:25,689 --> 00:01:29,380
<font color="#CCCCCC">familiar with the security exploit is a</font>

33
00:01:27,700 --> 00:01:31,049
way to basically take advantage of

34
00:01:29,380 --> 00:01:34,719
security vulnerability in a program

35
00:01:31,049 --> 00:01:37,509
either to do untrusted code execution or

36
00:01:34,719 --> 00:01:41,079
to steal secret information for example

37
00:01:37,509 --> 00:01:42,939
private keys and a bigger challenge so a

38
00:01:41,079 --> 00:01:45,669
lot of these security experts are eaten

39
00:01:42,939 --> 00:01:48,699
manually generally or most ninety-nine

40
00:01:45,670 --> 00:01:50,140
point nine percent of the time and<font color="#CCCCCC"> 4.01</font>

41
00:01:48,700 --> 00:01:52,929
<font color="#E5E5E5">percent of the time people claim that</font>

42
00:01:50,140 --> 00:01:55,539
they can sometimes automatically

43
00:01:52,929 --> 00:01:58,439
generate his exploits<font color="#E5E5E5"> I am highly</font>

44
00:01:55,539 --> 00:02:03,340
skeptical of that in<font color="#CCCCCC"> real world</font>

45
00:01:58,439 --> 00:02:07,298
conditions so this work is trying to

46
00:02:03,340 --> 00:02:10,360
understand<font color="#CCCCCC"> how to basically resolve one</font>

47
00:02:07,299 --> 00:02:12,920
of the problems that<font color="#E5E5E5"> I set up in the</font>

48
00:02:10,360 --> 00:02:14,930
Grand Challenge which is a<font color="#E5E5E5"> set of</font>

49
00:02:12,920 --> 00:02:18,619
11 problems that I believe are very hard

50
00:02:14,930 --> 00:02:20,630
to solve so some of the problems are

51
00:02:18,620 --> 00:02:24,110
about how to specify what an exploit

52
00:02:20,630 --> 00:02:27,530
should do how<font color="#E5E5E5"> to generate input for the</font>

53
00:02:24,110 --> 00:02:29,690
exploit how to represent state space for

54
00:02:27,530 --> 00:02:33,110
the<font color="#CCCCCC"> programming under attack how to</font>

55
00:02:29,690 --> 00:02:35,329
explore concurrency scheduling how to

56
00:02:33,110 --> 00:02:37,370
infer privilege separation and things

57
00:02:35,330 --> 00:02:41,660
like that so<font color="#E5E5E5"> it's not it's not trivial</font>

58
00:02:37,370 --> 00:02:45,640
at all one of the problem which is

59
00:02:41,660 --> 00:02:48,829
problem I of of<font color="#E5E5E5"> the grand challenge is a</font>

60
00:02:45,640 --> 00:02:52,100
heap prediction so but how can you<font color="#E5E5E5"> how</font>

61
00:02:48,830 --> 00:02:54,620
can you infer the state of the heap you

62
00:02:52,100 --> 00:02:58,280
know in a complex program is a really

63
00:02:54,620 --> 00:03:01,280
<font color="#E5E5E5">hard problem most people haven't really</font>

64
00:02:58,280 --> 00:03:03,970
studied the problem at all a lot of the

65
00:03:01,280 --> 00:03:06,890
research on heap analysis has<font color="#CCCCCC"> been</font>

66
00:03:03,970 --> 00:03:08,799
mostly for things such as shape<font color="#CCCCCC"> analysis</font>

67
00:03:06,890 --> 00:03:11,690
shape now this is basically<font color="#E5E5E5"> how to</font>

68
00:03:08,799 --> 00:03:13,250
analyze the shape of data structures in

69
00:03:11,690 --> 00:03:17,780
the heat for example if those are linked

70
00:03:13,250 --> 00:03:19,880
<font color="#E5E5E5">list graphs trees</font><font color="#CCCCCC"> IEC click etc we</font>

71
00:03:17,780 --> 00:03:22,370
<font color="#CCCCCC">normally talk about that my goal is not</font>

72
00:03:19,880 --> 00:03:24,500
to do shape analysis my goal is to see

73
00:03:22,370 --> 00:03:26,780
how we can predict this layout of the

74
00:03:24,500 --> 00:03:30,019
heap the delay the<font color="#CCCCCC"> layout of the heap</font>

75
00:03:26,780 --> 00:03:33,260
you'll see is the state of various

76
00:03:30,019 --> 00:03:36,829
internal structures as a heap<font color="#E5E5E5"> and that</font>

77
00:03:33,260 --> 00:03:39,380
can<font color="#CCCCCC"> be useful for exploitation also the</font>

78
00:03:36,829 --> 00:03:43,790
heap can be non deterministic sometimes

79
00:03:39,380 --> 00:03:45,890
the heap would act ninety<font color="#CCCCCC"> percent in a</font>

80
00:03:43,790 --> 00:03:49,090
certain way and ten percent in another

81
00:03:45,890 --> 00:03:51,200
way so it's very<font color="#E5E5E5"> hard sometimes to to</font>

82
00:03:49,090 --> 00:03:53,239
come up with<font color="#CCCCCC"> a semantics of the</font><font color="#E5E5E5"> heat</font>

83
00:03:51,200 --> 00:03:56,030
<font color="#CCCCCC">that reflect that I'm not</font><font color="#E5E5E5"> going to try</font>

84
00:03:53,239 --> 00:03:58,579
<font color="#CCCCCC">to</font><font color="#E5E5E5"> this today you can try to do this</font>

85
00:03:56,030 --> 00:04:00,049
using things like Markov models oh but

86
00:03:58,579 --> 00:04:01,970
he's a networking stuff like that I'm

87
00:04:00,049 --> 00:04:03,709
not<font color="#E5E5E5"> going to do that today but it's</font>

88
00:04:01,970 --> 00:04:08,030
something I'm researching however is

89
00:04:03,709 --> 00:04:10,609
<font color="#CCCCCC">going</font><font color="#E5E5E5"> to be for future work</font><font color="#CCCCCC"> okay why is</font>

90
00:04:08,030 --> 00:04:15,459
<font color="#E5E5E5">this an important an actual important</font>

91
00:04:10,609 --> 00:04:19,630
problem to solve um first of all because

92
00:04:15,459 --> 00:04:23,479
most research about hip export is very

93
00:04:19,630 --> 00:04:25,010
arcane as I call it it's like arcane

94
00:04:23,479 --> 00:04:26,450
knowledge that<font color="#CCCCCC"> exploit riders are</font>

95
00:04:25,010 --> 00:04:28,880
actually come<font color="#CCCCCC"> up with</font>

96
00:04:26,450 --> 00:04:31,670
on flies they have a target<font color="#E5E5E5"> and try to</font>

97
00:04:28,880 --> 00:04:35,900
find conditions under which the target

98
00:04:31,670 --> 00:04:40,730
can be exploited this is one of effort

99
00:04:35,900 --> 00:04:43,489
usually exploit Arthur exploit also heap

100
00:04:40,730 --> 00:04:46,370
allocators are extremely different<font color="#E5E5E5"> for</font>

101
00:04:43,490 --> 00:04:48,410
each operating system dl do glee as

102
00:04:46,370 --> 00:04:50,920
<font color="#CCCCCC">malik on linux is very is quite</font>

103
00:04:48,410 --> 00:04:53,510
different<font color="#E5E5E5"> from its successor</font><font color="#CCCCCC"> PT</font><font color="#E5E5E5"> malach</font>

104
00:04:50,920 --> 00:04:56,150
which basically add<font color="#E5E5E5"> a multi stripe</font>

105
00:04:53,510 --> 00:04:58,280
support to the<font color="#E5E5E5"> analog on</font><font color="#CCCCCC"> windows you</font>

106
00:04:56,150 --> 00:04:59,719
<font color="#CCCCCC">have the windows heap we sense things</font>

107
00:04:58,280 --> 00:05:00,679
like the low fragmentation heap<font color="#E5E5E5"> i'm</font>

108
00:04:59,720 --> 00:05:07,330
going to<font color="#E5E5E5"> talk about this little bit</font>

109
00:05:00,680 --> 00:05:10,460
later on from say firefox you'd have

110
00:05:07,330 --> 00:05:13,789
<font color="#CCCCCC">jima lock which is one more different</font>

111
00:05:10,460 --> 00:05:15,500
<font color="#CCCCCC">locator so is it really possible to</font><font color="#E5E5E5"> come</font>

112
00:05:13,790 --> 00:05:16,940
up<font color="#CCCCCC"> with generic</font><font color="#E5E5E5"> heat production</font>

113
00:05:15,500 --> 00:05:21,830
<font color="#E5E5E5">technique knowing that all these</font>

114
00:05:16,940 --> 00:05:23,480
alligators are so different that's what

115
00:05:21,830 --> 00:05:26,060
I try to solve this kind<font color="#E5E5E5"> of an</font>

116
00:05:23,480 --> 00:05:28,760
impossible problem so don't blame me if

117
00:05:26,060 --> 00:05:31,100
<font color="#E5E5E5">I don't manage but I think there</font><font color="#CCCCCC"> are</font>

118
00:05:28,760 --> 00:05:34,070
some some good stuff to actually infer

119
00:05:31,100 --> 00:05:37,190
from that my goal is really to try<font color="#E5E5E5"> to</font>

120
00:05:34,070 --> 00:05:39,409
formalize such technique and ideally

121
00:05:37,190 --> 00:05:41,630
<font color="#CCCCCC">write a tool that will be used usable of</font>

122
00:05:39,410 --> 00:05:44,030
the<font color="#E5E5E5"> shelf to do that</font><font color="#CCCCCC"> I'm still</font>

123
00:05:41,630 --> 00:05:45,500
developing that tool so from the

124
00:05:44,030 --> 00:05:47,510
evaluation side you're going to be quite

125
00:05:45,500 --> 00:05:49,370
disappointed<font color="#E5E5E5"> however we'll go through</font>

126
00:05:47,510 --> 00:05:52,599
the details of what I've learned by

127
00:05:49,370 --> 00:05:55,010
analyzing another thing the<font color="#E5E5E5"> alligators</font>

128
00:05:52,600 --> 00:05:58,580
just a few reminders a few<font color="#CCCCCC"> different</font>

129
00:05:55,010 --> 00:06:02,630
vulnerabilities that people experience

130
00:05:58,580 --> 00:06:04,700
on the heap are he based buffer

131
00:06:02,630 --> 00:06:07,040
overflows you guys are pretty<font color="#E5E5E5"> much</font>

132
00:06:04,700 --> 00:06:08,120
familiar with was at you<font color="#E5E5E5"> know he baits</font>

133
00:06:07,040 --> 00:06:10,520
buffer overflow an attacker can

134
00:06:08,120 --> 00:06:12,740
typically override the adjacent memory

135
00:06:10,520 --> 00:06:16,609
chunk so either is any interesting data

136
00:06:12,740 --> 00:06:18,230
after the data to be<font color="#E5E5E5"> overflow then the</font>

137
00:06:16,610 --> 00:06:21,740
attacker will try to corrupt that maybe

138
00:06:18,230 --> 00:06:24,850
this function pointer<font color="#E5E5E5"> maybe it's some</font>

139
00:06:21,740 --> 00:06:27,110
authentication flag and so<font color="#E5E5E5"> north of us</font>

140
00:06:24,850 --> 00:06:30,350
double free is invalid free sometimes

141
00:06:27,110 --> 00:06:33,800
it's possible to basically execute a

142
00:06:30,350 --> 00:06:36,620
primitive on the heap that will corrupt

143
00:06:33,800 --> 00:06:38,750
the heap for example if you try to free

144
00:06:36,620 --> 00:06:39,780
something twice or if you try to free

145
00:06:38,750 --> 00:06:43,410
something that's not

146
00:06:39,780 --> 00:06:46,020
<font color="#E5E5E5">junk then bad things can happen use</font>

147
00:06:43,410 --> 00:06:48,060
after freeze use after fees are major

148
00:06:46,020 --> 00:06:52,169
classes<font color="#CCCCCC"> major class of phrenology these</font>

149
00:06:48,060 --> 00:06:55,410
days it basically especially in browsers

150
00:06:52,169 --> 00:06:57,659
I is been full of these in the last few

151
00:06:55,410 --> 00:07:01,169
years not just<font color="#CCCCCC"> ie but also chrome and</font>

152
00:06:57,660 --> 00:07:05,340
firefox and basically that would be when

153
00:07:01,169 --> 00:07:06,960
<font color="#CCCCCC">a pointer is freed prematurely but there</font>

154
00:07:05,340 --> 00:07:09,060
was<font color="#CCCCCC"> a value of</font><font color="#E5E5E5"> the point to thats catch</font>

155
00:07:06,960 --> 00:07:12,210
somewhere in a local variable and this

156
00:07:09,060 --> 00:07:14,990
<font color="#CCCCCC">local viable gets used later on and that</font>

157
00:07:12,210 --> 00:07:18,090
in in that's where you basically can

158
00:07:14,990 --> 00:07:20,100
manipulate data that is an inconsistent

159
00:07:18,090 --> 00:07:24,659
state<font color="#CCCCCC"> i'll give you example of basic</font>

160
00:07:20,100 --> 00:07:26,310
example of that later one more class

161
00:07:24,660 --> 00:07:29,580
that's interesting is information

162
00:07:26,310 --> 00:07:32,160
disclosure it's when I typically would

163
00:07:29,580 --> 00:07:33,630
have a out<font color="#CCCCCC"> of an read and and the</font>

164
00:07:32,160 --> 00:07:35,700
attacker will<font color="#CCCCCC"> be able to read the</font>

165
00:07:33,630 --> 00:07:37,740
content of the memory space so not

166
00:07:35,700 --> 00:07:40,560
necessarily get getting untrusted code

167
00:07:37,740 --> 00:07:41,850
execution but reading data<font color="#E5E5E5"> that is not</font>

168
00:07:40,560 --> 00:07:43,350
supposed<font color="#E5E5E5"> to read which is sometimes you</font>

169
00:07:41,850 --> 00:07:44,940
know for example in kato heartbleed if

170
00:07:43,350 --> 00:07:50,280
you read private key in the memories big

171
00:07:44,940 --> 00:07:52,800
deal so just really really short a intro

172
00:07:50,280 --> 00:07:54,419
heap overflow obviously either's<font color="#E5E5E5"> malik</font>

173
00:07:52,800 --> 00:07:57,180
happening there<font color="#CCCCCC"> is some</font><font color="#E5E5E5"> kind of mem copy</font>

174
00:07:54,419 --> 00:07:59,039
happening which is could be out<font color="#CCCCCC"> of them</font>

175
00:07:57,180 --> 00:08:01,080
for<font color="#CCCCCC"> example here you could have a short</font>

176
00:07:59,039 --> 00:08:04,260
integer overflow that<font color="#CCCCCC"> will basically</font>

177
00:08:01,080 --> 00:08:06,419
lead to an hiep<font color="#CCCCCC"> O'Flynn mem copy so</font>

178
00:08:04,260 --> 00:08:08,490
what's interesting<font color="#E5E5E5"> he is that what's</font>

179
00:08:06,419 --> 00:08:10,440
after that trunk right because you're

180
00:08:08,490 --> 00:08:11,789
<font color="#E5E5E5">going to overflow the chunk so what's</font>

181
00:08:10,440 --> 00:08:13,830
after it is there anything interesting

182
00:08:11,789 --> 00:08:16,680
<font color="#CCCCCC">after that there is what's the location</font>

183
00:08:13,830 --> 00:08:22,620
of that chunk in heap and what what's

184
00:08:16,680 --> 00:08:25,080
after that location invalid free say you

185
00:08:22,620 --> 00:08:29,520
<font color="#E5E5E5">have some error condition you know say</font>

186
00:08:25,080 --> 00:08:31,349
online<font color="#E5E5E5"> for here you have you have if y</font>

187
00:08:29,520 --> 00:08:33,329
equals<font color="#CCCCCC"> 0 it goes straight to n and it</font>

188
00:08:31,350 --> 00:08:35,159
frees<font color="#E5E5E5"> the result in but the result was</font>

189
00:08:33,330 --> 00:08:36,570
supposed to be allocated<font color="#CCCCCC"> here so we go</font>

190
00:08:35,159 --> 00:08:38,039
<font color="#E5E5E5">straight to free and you free and</font>

191
00:08:36,570 --> 00:08:40,830
<font color="#E5E5E5">initialize value so will you would</font>

192
00:08:38,039 --> 00:08:42,500
basically free a pointer of whatever

193
00:08:40,830 --> 00:08:45,930
value was in memory at that moment

194
00:08:42,500 --> 00:08:49,790
that's a problem people been taking

195
00:08:45,930 --> 00:08:52,770
<font color="#CCCCCC">advantage of that similarly what's what</font>

196
00:08:49,790 --> 00:08:53,550
you know what what can you free with

197
00:08:52,770 --> 00:08:57,449
that<font color="#E5E5E5"> what</font>

198
00:08:53,550 --> 00:09:01,819
is what's what's<font color="#E5E5E5"> the location that can</font>

199
00:08:57,450 --> 00:09:06,360
be abused appointed by result

200
00:09:01,820 --> 00:09:08,820
use-after-free like several high-profile

201
00:09:06,360 --> 00:09:10,170
bugs like<font color="#CCCCCC"> arrival ability when Google</font>

202
00:09:08,820 --> 00:09:13,200
will hacked a few years<font color="#E5E5E5"> back five years</font>

203
00:09:10,170 --> 00:09:17,479
back and it was<font color="#E5E5E5"> because of a user for</font>

204
00:09:13,200 --> 00:09:20,370
free in ie6 typically you'd have a

205
00:09:17,480 --> 00:09:24,000
pointer<font color="#CCCCCC"> the small art you may</font><font color="#E5E5E5"> have an</font>

206
00:09:20,370 --> 00:09:27,839
object usually and then it pass this to

207
00:09:24,000 --> 00:09:30,630
a<font color="#E5E5E5"> function with certain input and this</font>

208
00:09:27,839 --> 00:09:32,640
<font color="#E5E5E5">function may free the pointer under some</font>

209
00:09:30,630 --> 00:09:34,320
condition some obscure conditions and

210
00:09:32,640 --> 00:09:36,000
never had almost never happened but

211
00:09:34,320 --> 00:09:40,410
<font color="#E5E5E5">sometimes it happens and then you had</font>

212
00:09:36,000 --> 00:09:42,060
these local value<font color="#CCCCCC"> cashed this</font><font color="#E5E5E5"> PTR that</font>

213
00:09:40,410 --> 00:09:44,550
would normally point to malloc but

214
00:09:42,060 --> 00:09:47,250
because that<font color="#CCCCCC"> was free then PT a-- will</font>

215
00:09:44,550 --> 00:09:49,019
basically point on frida memory that may

216
00:09:47,250 --> 00:09:51,690
have been reclaimed by another chunk

217
00:09:49,019 --> 00:09:53,100
later on so that is typically what

218
00:09:51,690 --> 00:09:55,529
<font color="#E5E5E5">happens when you have a use after free</font>

219
00:09:53,100 --> 00:09:58,350
of course in real-life cases<font color="#E5E5E5"> i'm most</font>

220
00:09:55,529 --> 00:10:03,120
most much more complicated but it's just

221
00:09:58,350 --> 00:10:05,700
<font color="#CCCCCC">for the sake of putting everybody on the</font>

222
00:10:03,120 --> 00:10:09,209
same page information is closure like

223
00:10:05,700 --> 00:10:12,420
heartbleed you'd have you'd receive

224
00:10:09,209 --> 00:10:17,880
something<font color="#E5E5E5"> for the</font><font color="#CCCCCC"> network you'd get say</font>

225
00:10:12,420 --> 00:10:22,290
a record header and you'd malik a an

226
00:10:17,880 --> 00:10:26,209
output buffer after<font color="#E5E5E5"> that</font><font color="#CCCCCC"> you'd</font><font color="#E5E5E5"> basically</font>

227
00:10:22,290 --> 00:10:28,890
copy something of a length<font color="#E5E5E5"> that was</font>

228
00:10:26,209 --> 00:10:30,989
provided by the user from the<font color="#CCCCCC"> network</font>

229
00:10:28,890 --> 00:10:32,579
and even though<font color="#E5E5E5"> you don't have a buffer</font>

230
00:10:30,990 --> 00:10:35,940
overflow because you may log the right

231
00:10:32,579 --> 00:10:39,449
thing you may<font color="#CCCCCC"> basically copy things that</font>

232
00:10:35,940 --> 00:10:41,820
were after<font color="#E5E5E5"> the internal data copy in</font>

233
00:10:39,449 --> 00:10:45,229
there but you when you send this back to

234
00:10:41,820 --> 00:10:48,930
<font color="#CCCCCC">the user the user will basically see a</font>

235
00:10:45,230 --> 00:10:51,540
data that was lying<font color="#E5E5E5"> around in memory and</font>

236
00:10:48,930 --> 00:10:55,349
if the data was sensitive then that's a

237
00:10:51,540 --> 00:10:58,410
problem also this is very important to

238
00:10:55,350 --> 00:11:03,329
understand what was after this this this

239
00:10:58,410 --> 00:11:07,350
chunk it's all what was as memory

240
00:11:03,329 --> 00:11:08,010
claimed by that Malik was<font color="#CCCCCC"> his</font><font color="#E5E5E5"> 0 after</font><font color="#CCCCCC"> it</font>

241
00:11:07,350 --> 00:11:10,380
was freed

242
00:11:08,010 --> 00:11:11,880
<font color="#E5E5E5">oh if it was not what was in there and</font>

243
00:11:10,380 --> 00:11:15,570
if<font color="#E5E5E5"> it's copied and if it's not</font>

244
00:11:11,880 --> 00:11:19,290
initialized then that<font color="#E5E5E5"> could be a problem</font>

245
00:11:15,570 --> 00:11:22,590
like he wants<font color="#E5E5E5"> you copy to the out buffer</font>

246
00:11:19,290 --> 00:11:24,750
what was a buff plus side of<font color="#CCCCCC"> rec for</font>

247
00:11:22,590 --> 00:11:26,760
that length then<font color="#E5E5E5"> you got a bunch of</font>

248
00:11:24,750 --> 00:11:29,430
uninitialized values is going on that's

249
00:11:26,760 --> 00:11:32,910
<font color="#CCCCCC">going to</font><font color="#E5E5E5"> be copied to out so what was</font>

250
00:11:29,430 --> 00:11:37,319
after after that particular<font color="#E5E5E5"> piece of</font>

251
00:11:32,910 --> 00:11:40,110
<font color="#E5E5E5">data in heap all of that just to say</font>

252
00:11:37,320 --> 00:11:42,120
that trying to<font color="#E5E5E5"> infer the location and</font>

253
00:11:40,110 --> 00:11:44,520
<font color="#CCCCCC">the relative location of chunks in the</font>

254
00:11:42,120 --> 00:11:48,570
heap is important for<font color="#E5E5E5"> exploit writers</font>

255
00:11:44,520 --> 00:11:50,970
and usually critically important<font color="#CCCCCC"> to get</font>

256
00:11:48,570 --> 00:11:55,620
a<font color="#E5E5E5"> successful exploit and like a reliable</font>

257
00:11:50,970 --> 00:11:59,640
exploit and so on one of the harness

258
00:11:55,620 --> 00:12:01,380
tests I created in my grand challenge is

259
00:11:59,640 --> 00:12:03,330
the following so we'll go through<font color="#E5E5E5"> that</font>

260
00:12:01,380 --> 00:12:08,250
<font color="#CCCCCC">because it's</font><font color="#E5E5E5"> kind of interesting to</font>

261
00:12:03,330 --> 00:12:11,190
understand let's say you have the

262
00:12:08,250 --> 00:12:16,710
following a small example we aware you

263
00:12:11,190 --> 00:12:18,630
have structures of type s 1 and s 2 i'm

264
00:12:16,710 --> 00:12:25,560
seeing that there is some missing curly

265
00:12:18,630 --> 00:12:28,080
brace here<font color="#CCCCCC"> i'm</font><font color="#E5E5E5"> sorry is that true</font><font color="#CCCCCC"> okay</font>

266
00:12:25,560 --> 00:12:29,849
so basically what happened here is that

267
00:12:28,080 --> 00:12:35,700
you've<font color="#CCCCCC"> got a function that</font><font color="#E5E5E5"> allocated a</font>

268
00:12:29,850 --> 00:12:37,620
few of these a structure<font color="#CCCCCC"> s 13 times and</font>

269
00:12:35,700 --> 00:12:40,980
you got a function that<font color="#CCCCCC"> allocates</font>

270
00:12:37,620 --> 00:12:43,920
structure s21<font color="#CCCCCC"> time you've got a function</font>

271
00:12:40,980 --> 00:12:46,590
that free structure of type s<font color="#CCCCCC"> 1 you got</font>

272
00:12:43,920 --> 00:12:49,709
a function that copy data in the

273
00:12:46,590 --> 00:12:54,450
structure<font color="#E5E5E5"> and basically the goal</font>

274
00:12:49,710 --> 00:12:57,360
<font color="#CCCCCC">whatever you want to reach is the point</font>

275
00:12:54,450 --> 00:12:58,980
where you basically say between you in

276
00:12:57,360 --> 00:13:01,950
just for the sake of understanding and

277
00:12:58,980 --> 00:13:05,460
what you<font color="#E5E5E5"> don't want to do is to fall</font>

278
00:13:01,950 --> 00:13:08,610
into this case where<font color="#E5E5E5"> you would basically</font>

279
00:13:05,460 --> 00:13:11,370
copy some data in a pointer that was

280
00:13:08,610 --> 00:13:13,050
freed so you wouldn't<font color="#CCCCCC"> want</font><font color="#E5E5E5"> to do say you</font>

281
00:13:11,370 --> 00:13:15,000
wouldn't want<font color="#E5E5E5"> to free that pointer and</font>

282
00:13:13,050 --> 00:13:16,920
then try to go into<font color="#E5E5E5"> that because you</font>

283
00:13:15,000 --> 00:13:21,390
make crash the program however if you go

284
00:13:16,920 --> 00:13:24,089
into that you may basically<font color="#E5E5E5"> be able to</font>

285
00:13:21,390 --> 00:13:27,390
awesome influence the value of this flag

286
00:13:24,090 --> 00:13:30,540
and if<font color="#E5E5E5"> you manage to get this flag to</font>

287
00:13:27,390 --> 00:13:32,460
<font color="#E5E5E5">one then when you when such service</font>

288
00:13:30,540 --> 00:13:37,740
condition you would<font color="#CCCCCC"> radically go into</font>

289
00:13:32,460 --> 00:13:39,240
the winning state so one of<font color="#E5E5E5"> the key to</font>

290
00:13:37,740 --> 00:13:42,480
understand exploitability about this

291
00:13:39,240 --> 00:13:45,420
example is recycling of chunks recycling

292
00:13:42,480 --> 00:13:48,930
a chance means when you free some

293
00:13:45,420 --> 00:13:50,910
structures the chunks will in fact not

294
00:13:48,930 --> 00:13:53,400
be back to the heat but it will<font color="#CCCCCC"> be</font>

295
00:13:50,910 --> 00:13:55,439
placed into a list of available shark

296
00:13:53,400 --> 00:13:59,220
and whenever you have a location<font color="#E5E5E5"> to</font>

297
00:13:55,440 --> 00:14:01,740
satisfy if a structure would be the same

298
00:13:59,220 --> 00:14:06,300
side in that case s1 and s2 are of the

299
00:14:01,740 --> 00:14:09,900
same size but if you reclaim if you

300
00:14:06,300 --> 00:14:13,790
reclaim the chunk by a structure<font color="#CCCCCC"> of the</font>

301
00:14:09,900 --> 00:14:16,290
same size you basically may be<font color="#CCCCCC"> able</font><font color="#E5E5E5"> to</font>

302
00:14:13,790 --> 00:14:20,040
take advantage of the fact that there

303
00:14:16,290 --> 00:14:23,699
were certain values for example here<font color="#CCCCCC"> if</font>

304
00:14:20,040 --> 00:14:27,329
you if you initialize that guy to one

305
00:14:23,700 --> 00:14:29,460
then if you reclaim p2 authenticated

306
00:14:27,330 --> 00:14:31,800
will become one so typically a

307
00:14:29,460 --> 00:14:34,590
successful run would be<font color="#CCCCCC"> to call</font><font color="#E5E5E5"> the</font>

308
00:14:31,800 --> 00:14:37,290
function in<font color="#CCCCCC"> disorder you would like to</font>

309
00:14:34,590 --> 00:14:39,150
allocate some structures and then you'd

310
00:14:37,290 --> 00:14:42,630
like to free one<font color="#E5E5E5"> of these</font><font color="#CCCCCC"> structures and</font>

311
00:14:39,150 --> 00:14:45,510
then you'd like to reallocate a second

312
00:14:42,630 --> 00:14:48,000
structure because structure to is of the

313
00:14:45,510 --> 00:14:50,520
same size instructor one then the chunk

314
00:14:48,000 --> 00:14:56,070
that was pointed by p1 a will now be

315
00:14:50,520 --> 00:14:59,850
prompted by p2 and after that you want

316
00:14:56,070 --> 00:15:01,890
to<font color="#E5E5E5"> basically a copy values into that</font>

317
00:14:59,850 --> 00:15:03,570
stuff and then you<font color="#E5E5E5"> want to call a</font>

318
00:15:01,890 --> 00:15:05,580
winning function however you do want to

319
00:15:03,570 --> 00:15:07,950
<font color="#E5E5E5">call</font><font color="#CCCCCC"> that function or otherwise you're</font>

320
00:15:05,580 --> 00:15:11,280
gonna crash so how do you how do you

321
00:15:07,950 --> 00:15:14,880
automate finding of these heap walls<font color="#E5E5E5"> as</font>

322
00:15:11,280 --> 00:15:17,310
<font color="#CCCCCC">i call them</font><font color="#E5E5E5"> that's kind of a harness of</font>

323
00:15:14,880 --> 00:15:19,890
the problem how can you phone

324
00:15:17,310 --> 00:15:21,930
automatically whether such a walk is

325
00:15:19,890 --> 00:15:25,590
possible to lead you to an exploitable

326
00:15:21,930 --> 00:15:29,270
state so the allocator I've studied are

327
00:15:25,590 --> 00:15:34,470
the following so do glee as<font color="#CCCCCC"> Mark it was</font>

328
00:15:29,270 --> 00:15:38,030
up to deep sea of 2006

329
00:15:34,470 --> 00:15:41,430
two thousand and then<font color="#CCCCCC"> Peeta Mellark West</font>

330
00:15:38,030 --> 00:15:43,170
was introduced in GDP cpg malach is

331
00:15:41,430 --> 00:15:45,510
pretty much<font color="#CCCCCC"> Dilma</font><font color="#E5E5E5"> lock with thread</font>

332
00:15:43,170 --> 00:15:47,610
support<font color="#E5E5E5"> by threat support I mean that</font>

333
00:15:45,510 --> 00:15:51,810
you<font color="#CCCCCC"> have the ability</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> have a separate</font>

334
00:15:47,610 --> 00:15:54,570
heat per thread you have the windows

335
00:15:51,810 --> 00:15:57,750
heap windows heap it's very interesting

336
00:15:54,570 --> 00:15:59,730
piece of of code because there are

337
00:15:57,750 --> 00:16:00,960
multiple<font color="#CCCCCC"> on locators in</font><font color="#E5E5E5"> a single process</font>

338
00:15:59,730 --> 00:16:03,260
you'd have something called the front

339
00:16:00,960 --> 00:16:07,260
and<font color="#E5E5E5"> a locator in the back in a locator</font>

340
00:16:03,260 --> 00:16:10,260
and based on such or such condition

341
00:16:07,260 --> 00:16:12,780
typically if<font color="#CCCCCC"> you allocate at least 21</font>

342
00:16:10,260 --> 00:16:15,120
chunks of a given bucket size it would

343
00:16:12,780 --> 00:16:16,760
switch to the other locator so that's

344
00:16:15,120 --> 00:16:20,190
kind of interesting when it comes to

345
00:16:16,760 --> 00:16:23,910
analyzing the<font color="#E5E5E5"> heap automatically to</font>

346
00:16:20,190 --> 00:16:27,690
other alligators I have not studied our

347
00:16:23,910 --> 00:16:30,390
<font color="#CCCCCC">Jima lock and any garbage collection</font>

348
00:16:27,690 --> 00:16:32,370
well I have studied them in a<font color="#CCCCCC"> different</font>

349
00:16:30,390 --> 00:16:34,500
context but I'm not<font color="#E5E5E5"> going</font><font color="#CCCCCC"> to talk about</font>

350
00:16:32,370 --> 00:16:37,380
them<font color="#E5E5E5"> today so</font><font color="#CCCCCC"> today</font><font color="#E5E5E5"> we're going to</font>

351
00:16:34,500 --> 00:16:40,710
really focus on mostly deal Bangkok

352
00:16:37,380 --> 00:16:42,990
<font color="#CCCCCC">Peeta Mellark</font><font color="#E5E5E5"> and also</font><font color="#CCCCCC"> i will i will</font>

353
00:16:40,710 --> 00:16:44,640
hint on how to modify slightly the

354
00:16:42,990 --> 00:16:52,650
formalism to support windows<font color="#CCCCCC"> here as</font>

355
00:16:44,640 --> 00:16:57,350
well<font color="#CCCCCC"> okay so typically um the algorithm</font>

356
00:16:52,650 --> 00:17:00,870
of a heap a locator is as follow first

357
00:16:57,350 --> 00:17:03,120
<font color="#E5E5E5">yves the last free trunk can be reused</font>

358
00:17:00,870 --> 00:17:06,930
it will be reused for the subsequent

359
00:17:03,120 --> 00:17:12,030
allocation if it's<font color="#E5E5E5"> not the case it will</font>

360
00:17:06,930 --> 00:17:15,120
<font color="#E5E5E5">basically try to find one free chunk in</font>

361
00:17:12,030 --> 00:17:18,240
the free lists there are several free

362
00:17:15,119 --> 00:17:20,099
lists usually it depends<font color="#E5E5E5"> on your carrier</font>

363
00:17:18,240 --> 00:17:22,680
but usually you have one free lease per

364
00:17:20,099 --> 00:17:27,959
bucket size so you have certain

365
00:17:22,680 --> 00:17:29,970
intervals of sizes and a given our

366
00:17:27,960 --> 00:17:32,940
location will try to look up a given

367
00:17:29,970 --> 00:17:34,620
list say if you'd make a malaka of 10 it

368
00:17:32,940 --> 00:17:36,540
will<font color="#E5E5E5"> go into the first freeze and say</font>

369
00:17:34,620 --> 00:17:37,860
okay do I have a small chunk of at least

370
00:17:36,540 --> 00:17:40,560
10 bytes that can satisfy this

371
00:17:37,860 --> 00:17:43,320
allocation if so it reach and Iran is

372
00:17:40,560 --> 00:17:46,649
unlink it from the list

373
00:17:43,320 --> 00:17:48,629
and it will mark<font color="#E5E5E5"> the trunk advocated if</font>

374
00:17:46,649 --> 00:17:50,758
it doesn't find this in the first list

375
00:17:48,630 --> 00:17:52,350
it will try to go to the next list and

376
00:17:50,759 --> 00:17:53,970
say<font color="#E5E5E5"> okay do I have a</font><font color="#CCCCCC"> chunk</font><font color="#E5E5E5"> with a</font>

377
00:17:52,350 --> 00:17:56,158
slightly bigger because it's in second

378
00:17:53,970 --> 00:17:59,789
list that can satisfy this allocation if

379
00:17:56,159 --> 00:18:04,909
so do the same thing and it is going<font color="#E5E5E5"> to</font>

380
00:17:59,789 --> 00:18:10,019
go list after list like that also if

381
00:18:04,909 --> 00:18:13,049
there are two free chunks in a row say

382
00:18:10,019 --> 00:18:14,820
you have you need 32 bytes however you

383
00:18:13,049 --> 00:18:17,190
just have to free chunks in the least

384
00:18:14,820 --> 00:18:19,649
one<font color="#E5E5E5"> East 20 bytes in the other in 30</font>

385
00:18:17,190 --> 00:18:23,220
bites what you look it will do it will

386
00:18:19,649 --> 00:18:25,979
coalesce<font color="#E5E5E5"> two chunks it will unlink the</font>

387
00:18:23,220 --> 00:18:28,500
chunk of 20 and<font color="#E5E5E5"> a</font><font color="#CCCCCC"> check of 30 bytes make</font>

388
00:18:25,980 --> 00:18:30,240
a chunk of 50 bytes and put it in a

389
00:18:28,500 --> 00:18:32,509
different Phyllis or actually<font color="#CCCCCC"> it</font><font color="#E5E5E5"> will</font>

390
00:18:30,240 --> 00:18:36,000
claim it for the allocation it may even

391
00:18:32,509 --> 00:18:37,860
split it to the exact same to the exact

392
00:18:36,000 --> 00:18:41,000
right side<font color="#E5E5E5"> that it needs and put the</font>

393
00:18:37,860 --> 00:18:43,139
reminder<font color="#CCCCCC"> to some other free list so</font>

394
00:18:41,000 --> 00:18:45,210
that's typically<font color="#E5E5E5"> the stead that are</font>

395
00:18:43,139 --> 00:18:47,549
taken and that<font color="#CCCCCC"> those steps are pretty</font>

396
00:18:45,210 --> 00:18:48,899
much consistent across allocators even

397
00:18:47,549 --> 00:18:52,350
though of course some implementation

398
00:18:48,899 --> 00:18:54,870
details change abstractly that's what

399
00:18:52,350 --> 00:18:57,840
<font color="#E5E5E5">another</font><font color="#CCCCCC"> carrier tries to do if it</font>

400
00:18:54,870 --> 00:19:00,059
doesn't<font color="#E5E5E5"> manage to find any chunk in any</font>

401
00:18:57,840 --> 00:19:03,090
free list what it will do it will extend

402
00:19:00,059 --> 00:19:06,990
<font color="#E5E5E5">the hip on</font><font color="#CCCCCC"> Linux</font><font color="#E5E5E5"> typically you would</font>

403
00:19:03,090 --> 00:19:09,928
call a system<font color="#CCCCCC"> call</font><font color="#E5E5E5"> call be</font><font color="#CCCCCC"> ok BRK will</font>

404
00:19:06,990 --> 00:19:14,240
extend heap it will basically bring the

405
00:19:09,929 --> 00:19:16,379
address of<font color="#E5E5E5"> the heap of the last address</font>

406
00:19:14,240 --> 00:19:19,769
the highest address of the heap will

407
00:19:16,379 --> 00:19:21,949
increase a<font color="#E5E5E5"> little bit so say you had the</font>

408
00:19:19,769 --> 00:19:28,580
last I'm just making that up if you had

409
00:19:21,950 --> 00:19:31,679
<font color="#E5E5E5">the last allocation at 08 04 8000 oh</font>

410
00:19:28,580 --> 00:19:35,330
yeah so it will basically say<font color="#CCCCCC"> ok now the</font>

411
00:19:31,679 --> 00:19:39,299
the<font color="#E5E5E5"> highest address is 0 a 0 for</font><font color="#CCCCCC"> 8 100</font>

412
00:19:35,330 --> 00:19:42,480
and then every<font color="#CCCCCC"> time you</font><font color="#E5E5E5"> will basically</font>

413
00:19:39,299 --> 00:19:45,269
need to allocate more memory it<font color="#CCCCCC"> will it</font>

414
00:19:42,480 --> 00:19:46,830
will try to do this algorithm and if it

415
00:19:45,269 --> 00:19:49,409
doesn't manage it will extend<font color="#E5E5E5"> the heap</font>

416
00:19:46,830 --> 00:19:53,970
and the top chunk will be the chunk that

417
00:19:49,409 --> 00:19:55,910
is you<font color="#CCCCCC"> know at the top of the heap so we</font>

418
00:19:53,970 --> 00:19:59,000
might remember about that the top

419
00:19:55,910 --> 00:20:00,500
is quite important<font color="#CCCCCC"> and otherwise it just</font>

420
00:19:59,000 --> 00:20:02,690
returns an error and then malloc returns

421
00:20:00,500 --> 00:20:04,520
null we are<font color="#CCCCCC"> like</font><font color="#E5E5E5"> witness nor see a</font>

422
00:20:02,690 --> 00:20:10,070
<font color="#E5E5E5">logarithm snow and then y el cajon just</font>

423
00:20:04,520 --> 00:20:13,010
failed so what we really<font color="#E5E5E5"> try to do here</font>

424
00:20:10,070 --> 00:20:17,060
<font color="#CCCCCC">is to define a transition system for the</font>

425
00:20:13,010 --> 00:20:19,129
<font color="#E5E5E5">heap so if you have an initial state for</font>

426
00:20:17,060 --> 00:20:23,149
the heap you<font color="#E5E5E5"> start here is an empty heap</font>

427
00:20:19,130 --> 00:20:24,530
and you may have<font color="#E5E5E5"> depending</font><font color="#CCCCCC"> on what the</font>

428
00:20:23,150 --> 00:20:27,050
program executes you may have a

429
00:20:24,530 --> 00:20:29,060
transition say you do an allocation of

430
00:20:27,050 --> 00:20:32,060
10 bytes and he'd do an allocation 20

431
00:20:29,060 --> 00:20:34,070
bytes and here 30 bytes and then after

432
00:20:32,060 --> 00:20:36,830
that<font color="#E5E5E5"> you may do the second or location</font>

433
00:20:34,070 --> 00:20:38,389
or you may do a free or here you may do

434
00:20:36,830 --> 00:20:42,590
a free as<font color="#CCCCCC"> well in that case you'd come</font>

435
00:20:38,390 --> 00:20:45,250
<font color="#E5E5E5">back to the you know h-1b h5 and based</font>

436
00:20:42,590 --> 00:20:47,629
each of the primitives of the heap

437
00:20:45,250 --> 00:20:49,580
perform the transition on<font color="#CCCCCC"> the</font>

438
00:20:47,630 --> 00:20:52,040
configuration<font color="#E5E5E5"> of the heap so he empty</font>

439
00:20:49,580 --> 00:20:54,889
heap and then you act you perform two

440
00:20:52,040 --> 00:20:58,430
<font color="#E5E5E5">remedies on the heap and it maker it</font>

441
00:20:54,890 --> 00:21:00,230
makes i call it may go very deep what's

442
00:20:58,430 --> 00:21:03,230
interesting<font color="#E5E5E5"> though is that this</font>

443
00:21:00,230 --> 00:21:04,880
transition system is only dependent on

444
00:21:03,230 --> 00:21:07,010
the primitive of the heap<font color="#E5E5E5"> you have a</font>

445
00:21:04,880 --> 00:21:09,560
huge amount<font color="#CCCCCC"> of operations happening in</font>

446
00:21:07,010 --> 00:21:11,030
the program and these two totally do not

447
00:21:09,560 --> 00:21:13,120
<font color="#E5E5E5">influence the heap if you don't touch</font>

448
00:21:11,030 --> 00:21:15,920
the heap so you can kind of abstract

449
00:21:13,120 --> 00:21:17,840
what happened to the heap even<font color="#CCCCCC"> though</font>

450
00:21:15,920 --> 00:21:19,250
the program's complex in my even<font color="#CCCCCC"> be say</font>

451
00:21:17,840 --> 00:21:21,379
true and complete it doesn't really

452
00:21:19,250 --> 00:21:23,360
matter because what matter is what

453
00:21:21,380 --> 00:21:28,040
happened on the heat and that's why<font color="#CCCCCC"> we</font>

454
00:21:23,360 --> 00:21:31,429
try to analyze writer so the key idea is

455
00:21:28,040 --> 00:21:35,330
to be<font color="#CCCCCC"> able to define what I call</font>

456
00:21:31,430 --> 00:21:37,730
semantics of<font color="#E5E5E5"> the heap is to understand</font>

457
00:21:35,330 --> 00:21:40,220
there are two levels of semantics one is

458
00:21:37,730 --> 00:21:45,020
physical semantics the physical

459
00:21:40,220 --> 00:21:47,030
<font color="#E5E5E5">semantics is the adjacency of chunks so</font>

460
00:21:45,020 --> 00:21:50,480
which chunk is adjacent to which other

461
00:21:47,030 --> 00:21:54,139
junk so in memory there is a linear

462
00:21:50,480 --> 00:21:57,020
memory and you say<font color="#CCCCCC"> okay a is after bees</font>

463
00:21:54,140 --> 00:22:00,470
after C and then you had a logical

464
00:21:57,020 --> 00:22:02,150
semantics which is how are the lists

465
00:22:00,470 --> 00:22:05,390
that I just mentioned Marshall times are

466
00:22:02,150 --> 00:22:08,240
they populated and then they may be

467
00:22:05,390 --> 00:22:09,350
populated and even if you<font color="#CCCCCC"> after another</font>

468
00:22:08,240 --> 00:22:11,049
chunk in<font color="#E5E5E5"> list</font>

469
00:22:09,350 --> 00:22:13,820
that you are physically after the

470
00:22:11,049 --> 00:22:15,470
physically after<font color="#E5E5E5"> that chunk because it</font>

471
00:22:13,820 --> 00:22:18,080
<font color="#CCCCCC">depend</font><font color="#E5E5E5"> on the size right each trees</font>

472
00:22:15,470 --> 00:22:20,600
depend on the side of the chunk so two

473
00:22:18,080 --> 00:22:23,330
adjacent chunk in the list will not be

474
00:22:20,600 --> 00:22:27,110
physically adjacent necessarily that

475
00:22:23,330 --> 00:22:28,970
make sense so this distinction is quite

476
00:22:27,110 --> 00:22:31,789
important because when it comes to

477
00:22:28,970 --> 00:22:33,530
analyzing adjacency of chunks the

478
00:22:31,789 --> 00:22:35,780
physical semantics is all what<font color="#E5E5E5"> is all</font>

479
00:22:33,530 --> 00:22:38,360
that matters you may take chunks from

480
00:22:35,780 --> 00:22:41,000
lists put them in list this will never

481
00:22:38,360 --> 00:22:42,350
<font color="#E5E5E5">change the adaption see of chunk it will</font>

482
00:22:41,000 --> 00:22:44,809
just change the state of the chunks

483
00:22:42,350 --> 00:22:47,539
whether<font color="#CCCCCC"> the allocated was as if read but</font>

484
00:22:44,809 --> 00:22:49,370
it<font color="#E5E5E5"> doesn't matter you the Justin see</font>

485
00:22:47,539 --> 00:22:54,230
predicate as I will be fine in a second

486
00:22:49,370 --> 00:22:56,629
does not does<font color="#CCCCCC"> not get influenced by</font>

487
00:22:54,230 --> 00:22:58,880
whether you free or you Malik something

488
00:22:56,630 --> 00:23:00,970
directly it may do so in certain

489
00:22:58,880 --> 00:23:04,190
<font color="#CCCCCC">conditions which I will talk about and</font>

490
00:23:00,970 --> 00:23:07,580
so that's<font color="#E5E5E5"> the first first inside second</font>

491
00:23:04,190 --> 00:23:09,590
inside is obviously you'd have to<font color="#CCCCCC"> you</font>

492
00:23:07,580 --> 00:23:12,199
have to model semantics of the<font color="#E5E5E5"> primitive</font>

493
00:23:09,590 --> 00:23:15,500
those he'd like free we are log a log I

494
00:23:12,200 --> 00:23:18,320
call them fri in this but also internal

495
00:23:15,500 --> 00:23:21,140
heat mechanism should be defined for

496
00:23:18,320 --> 00:23:23,470
example that ain<font color="#CCCCCC"> i came up</font><font color="#E5E5E5"> with three</font>

497
00:23:21,140 --> 00:23:25,970
different ones that are everywhere

498
00:23:23,470 --> 00:23:29,890
omnipresent in the heater<font color="#CCCCCC"> allocated</font>

499
00:23:25,970 --> 00:23:32,120
implementation coalesce split and<font color="#CCCCCC"> expand</font>

500
00:23:29,890 --> 00:23:35,210
we'll talk<font color="#E5E5E5"> about what what these things</font>

501
00:23:32,120 --> 00:23:37,520
are in second the goal is to<font color="#E5E5E5"> reconcile</font>

502
00:23:35,210 --> 00:23:48,950
the physical and logical semantics of

503
00:23:37,520 --> 00:23:50,720
the hip<font color="#CCCCCC"> alright any questions</font><font color="#E5E5E5"> so far it</font>

504
00:23:48,950 --> 00:23:54,860
might be in clear is it is it making any

505
00:23:50,720 --> 00:23:56,360
sense good<font color="#E5E5E5"> okay all right we entering a</font>

506
00:23:54,860 --> 00:24:01,070
little bit more sensitive part of the

507
00:23:56,360 --> 00:24:03,110
talk i hope i'm not losing too many

508
00:24:01,070 --> 00:24:05,178
people with these notations these are

509
00:24:03,110 --> 00:24:06,620
those are nothing<font color="#E5E5E5"> these are nothing</font>

510
00:24:05,179 --> 00:24:09,799
complicated really if you have any

511
00:24:06,620 --> 00:24:13,299
question about it let me<font color="#E5E5E5"> know so</font>

512
00:24:09,799 --> 00:24:17,660
formally what what<font color="#E5E5E5"> are</font><font color="#CCCCCC"> we talking about</font>

513
00:24:13,299 --> 00:24:24,690
sorry the heap

514
00:24:17,660 --> 00:24:29,670
you can see it as a top o call it to

515
00:24:24,690 --> 00:24:32,400
topple a set of lists a set of<font color="#E5E5E5"> orders</font>

516
00:24:29,670 --> 00:24:34,770
like two orders one I call it the

517
00:24:32,400 --> 00:24:36,390
capacity ordering the other granularity

518
00:24:34,770 --> 00:24:41,280
ordering and those are orders on lists

519
00:24:36,390 --> 00:24:44,490
the capacity ordering is a witch but

520
00:24:41,280 --> 00:24:46,889
<font color="#E5E5E5">which lease has the most features so</font>

521
00:24:44,490 --> 00:24:51,120
you'd have<font color="#E5E5E5"> an order between lists and</font>

522
00:24:46,890 --> 00:24:53,310
this order depends on half from any how

523
00:24:51,120 --> 00:24:58,649
many free<font color="#E5E5E5"> changsha in at least the</font>

524
00:24:53,310 --> 00:25:01,139
granularity ordering would be the size

525
00:24:58,650 --> 00:25:03,630
<font color="#E5E5E5">of chunks in that free list so for</font>

526
00:25:01,140 --> 00:25:06,960
example<font color="#E5E5E5"> I would say that freely that has</font>

527
00:25:03,630 --> 00:25:09,080
<font color="#E5E5E5">chunks three chunks of 32 bytes which is</font>

528
00:25:06,960 --> 00:25:11,550
the minimal minimal size usually

529
00:25:09,080 --> 00:25:16,290
sometimes 16 by sometimes such a device

530
00:25:11,550 --> 00:25:18,389
a freely that has chunks of 32 bytes is

531
00:25:16,290 --> 00:25:23,129
more granular than a<font color="#CCCCCC"> filly that has say</font>

532
00:25:18,390 --> 00:25:25,830
120<font color="#E5E5E5"> 8 bytes so that's what I mean and</font>

533
00:25:23,130 --> 00:25:27,990
this is<font color="#E5E5E5"> really hidden in the cementing</font>

534
00:25:25,830 --> 00:25:29,909
so I'm going to show so if is that

535
00:25:27,990 --> 00:25:32,190
confusing to you don't<font color="#E5E5E5"> worry just forget</font>

536
00:25:29,910 --> 00:25:33,740
<font color="#E5E5E5">about it and what's most really</font>

537
00:25:32,190 --> 00:25:37,520
important though is the adjacency

538
00:25:33,740 --> 00:25:41,300
predicate adjustment see predicate is

539
00:25:37,520 --> 00:25:43,620
you take<font color="#E5E5E5"> two chunk and either adjacent</font>

540
00:25:41,300 --> 00:25:47,580
this predicate is true is the knowledge

541
00:25:43,620 --> 00:25:51,629
<font color="#E5E5E5">acent</font><font color="#CCCCCC"> pre-salt</font><font color="#E5E5E5"> recent and additionally</font>

542
00:25:47,580 --> 00:25:54,929
there are<font color="#CCCCCC"> 22 maps to maps or functions</font>

543
00:25:51,630 --> 00:25:57,570
if you prefer to<font color="#E5E5E5"> call them functions it</font>

544
00:25:54,930 --> 00:26:01,590
takes a list and it returns how many

545
00:25:57,570 --> 00:26:05,129
chunks are allocated in that ha how many

546
00:26:01,590 --> 00:26:07,050
chunks are allocated as in that little

547
00:26:05,130 --> 00:26:08,880
it's a bit abusing the language here

548
00:26:07,050 --> 00:26:10,680
because in fact there<font color="#E5E5E5"> is no list of</font>

549
00:26:08,880 --> 00:26:13,590
allocated chunks that are just list of

550
00:26:10,680 --> 00:26:17,760
features but<font color="#E5E5E5"> basically take it that way</font>

551
00:26:13,590 --> 00:26:19,860
how<font color="#CCCCCC"> many how many chunks of the group of</font>

552
00:26:17,760 --> 00:26:21,870
the granularity of that list are

553
00:26:19,860 --> 00:26:25,020
allocated this is how to interpret this

554
00:26:21,870 --> 00:26:27,389
one this is the counter map for free

555
00:26:25,020 --> 00:26:30,180
chunks so given a free list of free

556
00:26:27,390 --> 00:26:30,550
drinks how many how many chunks are

557
00:26:30,180 --> 00:26:34,150
there

558
00:26:30,550 --> 00:26:38,830
<font color="#E5E5E5">in that list so these are kind of the</font>

559
00:26:34,150 --> 00:26:41,950
basic block of semantics of the heat<font color="#E5E5E5"> I'm</font>

560
00:26:38,830 --> 00:26:45,310
trying to define here now talking about

561
00:26:41,950 --> 00:26:47,950
heat primitives we if you remember I try

562
00:26:45,310 --> 00:26:49,419
to<font color="#E5E5E5"> define a transition system or that</font>

563
00:26:47,950 --> 00:26:51,640
goes from hip configuration to hip

564
00:26:49,420 --> 00:26:54,340
configuration and the transition<font color="#E5E5E5"> system</font>

565
00:26:51,640 --> 00:26:57,220
the arrows the transitions are basically

566
00:26:54,340 --> 00:26:59,860
one of<font color="#E5E5E5"> one</font><font color="#CCCCCC"> of these kinds so every time</font>

567
00:26:57,220 --> 00:27:01,240
<font color="#E5E5E5">heap heap primitive is performed whether</font>

568
00:26:59,860 --> 00:27:03,820
it's a free we all are color<font color="#E5E5E5"> koalas</font>

569
00:27:01,240 --> 00:27:05,110
speed extent then you'll go from<font color="#E5E5E5"> one</font>

570
00:27:03,820 --> 00:27:08,139
heap configuration to another hip

571
00:27:05,110 --> 00:27:10,360
configuration and typically you<font color="#CCCCCC"> will</font>

572
00:27:08,140 --> 00:27:13,150
write like that so you take the<font color="#E5E5E5"> input</font>

573
00:27:10,360 --> 00:27:16,179
heap say it would be h0 you know the

574
00:27:13,150 --> 00:27:19,360
empty heap o hopefully it's not a dmt if

575
00:27:16,180 --> 00:27:21,550
you do free but whatever heap

576
00:27:19,360 --> 00:27:24,219
configuration you perform a free on

577
00:27:21,550 --> 00:27:27,610
pointer P and you get a new<font color="#E5E5E5"> hip</font>

578
00:27:24,220 --> 00:27:30,400
configuration<font color="#CCCCCC"> H prime similarly if you</font>

579
00:27:27,610 --> 00:27:32,679
really a pointer with four we for size s

580
00:27:30,400 --> 00:27:34,540
then it will basically give you a new

581
00:27:32,680 --> 00:27:37,780
hip configuration and a fresh point of P

582
00:27:34,540 --> 00:27:40,720
to that of size s at least if you

583
00:27:37,780 --> 00:27:42,730
allocate a pointer of size s similarly

584
00:27:40,720 --> 00:27:44,620
it will take input<font color="#CCCCCC"> Hebe it will give you</font>

585
00:27:42,730 --> 00:27:48,850
new hip configuration and give you a

586
00:27:44,620 --> 00:27:53,199
pointer with sizes at least if you call

587
00:27:48,850 --> 00:27:55,810
a stew chunks and p1 and p2 it would

588
00:27:53,200 --> 00:27:57,370
usually give you another heap

589
00:27:55,810 --> 00:27:59,590
configuration you could say there is a

590
00:27:57,370 --> 00:28:02,199
p3 here which is kind of the union of p1

591
00:27:59,590 --> 00:28:04,270
and p2 I haven't displayed it here if

592
00:28:02,200 --> 00:28:07,390
you spit the two chunks<font color="#CCCCCC"> similarly you'd</font>

593
00:28:04,270 --> 00:28:11,050
have to two chunks I didn't I didn't

594
00:28:07,390 --> 00:28:14,140
write p1 p2 but if you split a chunk p

595
00:28:11,050 --> 00:28:16,690
at offset s you'd have basically a chunk

596
00:28:14,140 --> 00:28:19,900
<font color="#CCCCCC">in a star at p in a strong solid s @ p</font>

597
00:28:16,690 --> 00:28:21,730
process and then expand if you have a

598
00:28:19,900 --> 00:28:23,770
heap and you want to expand the heap you

599
00:28:21,730 --> 00:28:28,320
have a new heap and then the top chunk

600
00:28:23,770 --> 00:28:28,320
is<font color="#CCCCCC"> P where P is of size s at least</font>

601
00:28:29,040 --> 00:28:34,389
what's important as well you know to

602
00:28:32,080 --> 00:28:36,760
understand how<font color="#E5E5E5"> the heap operates is the</font>

603
00:28:34,390 --> 00:28:38,370
fitness algorithm fitness algorithm is

604
00:28:36,760 --> 00:28:42,820
basically how the heap allocated<font color="#E5E5E5"> aside</font>

605
00:28:38,370 --> 00:28:45,379
which chunk is the most fit to satisfy

606
00:28:42,820 --> 00:28:48,419
the next allocation

607
00:28:45,380 --> 00:28:51,780
one way<font color="#E5E5E5"> to define such fitness algorithm</font>

608
00:28:48,420 --> 00:28:55,380
is that way<font color="#E5E5E5"> I just use em Elle Style</font>

609
00:28:51,780 --> 00:28:57,810
syntax because it's easy and it you'd

610
00:28:55,380 --> 00:29:00,810
say and I will use<font color="#E5E5E5"> this particular feed</font>

611
00:28:57,810 --> 00:29:06,000
function afterwards so just try to

612
00:29:00,810 --> 00:29:07,500
understand the overall idea but the

613
00:29:06,000 --> 00:29:09,900
<font color="#E5E5E5">detail this implementation is not really</font>

614
00:29:07,500 --> 00:29:12,840
important after after<font color="#E5E5E5"> this slide so</font>

615
00:29:09,900 --> 00:29:14,280
you'd have a fitness function it takes

616
00:29:12,840 --> 00:29:16,290
all the list of<font color="#E5E5E5"> the heap or you could</font>

617
00:29:14,280 --> 00:29:18,930
take the whole heat if you like<font color="#E5E5E5"> and it</font>

618
00:29:16,290 --> 00:29:22,770
<font color="#CCCCCC">takes a certain size so what it does it</font>

619
00:29:18,930 --> 00:29:25,740
says<font color="#CCCCCC"> okay match the list is there is no</font>

620
00:29:22,770 --> 00:29:29,730
list in that list then nothing fits

621
00:29:25,740 --> 00:29:32,340
right bottom means error<font color="#E5E5E5"> is not finding</font>

622
00:29:29,730 --> 00:29:33,900
<font color="#E5E5E5">anything however is there is</font><font color="#CCCCCC"> a thing in</font>

623
00:29:32,340 --> 00:29:36,570
<font color="#E5E5E5">the least say there is a cure there is a</font>

624
00:29:33,900 --> 00:29:37,980
top a head and tail that would be just

625
00:29:36,570 --> 00:29:40,110
<font color="#E5E5E5">one list and then there would be the</font>

626
00:29:37,980 --> 00:29:44,000
rest of the lists then what I'm trying

627
00:29:40,110 --> 00:29:47,340
to do here is I will try<font color="#E5E5E5"> to find what is</font>

628
00:29:44,000 --> 00:29:51,270
what is a matching chunk in that

629
00:29:47,340 --> 00:29:52,800
particular list so here<font color="#E5E5E5"> I implemented</font>

630
00:29:51,270 --> 00:29:55,830
one particular fitness function which is

631
00:29:52,800 --> 00:29:59,820
<font color="#CCCCCC">a best fit best it will try to minimize</font>

632
00:29:55,830 --> 00:30:03,090
the<font color="#CCCCCC"> facts try to minimize the extra</font>

633
00:29:59,820 --> 00:30:07,320
memory in that chunk so let's<font color="#E5E5E5"> say I'm</font>

634
00:30:03,090 --> 00:30:12,510
trying to make a best fit on the coolest

635
00:30:07,320 --> 00:30:15,990
for size then what what will<font color="#E5E5E5"> it do it</font>

636
00:30:12,510 --> 00:30:20,190
will pass a list and it will check

637
00:30:15,990 --> 00:30:24,300
actually that one parcel is fine fit it

638
00:30:20,190 --> 00:30:30,030
is is firstly goes here so it takes a

639
00:30:24,300 --> 00:30:32,399
list and it goes recursively for one

640
00:30:30,030 --> 00:30:34,440
shark after the other and it says<font color="#CCCCCC"> okay</font>

641
00:30:32,400 --> 00:30:36,720
the list is finished and my candidate

642
00:30:34,440 --> 00:30:41,700
the<font color="#E5E5E5"> Canada recorded so far will be my</font>

643
00:30:36,720 --> 00:30:43,890
candidate a fit chunk otherwise if there

644
00:30:41,700 --> 00:30:46,610
is still a certain amount of chunks in

645
00:30:43,890 --> 00:30:50,460
the list I will try<font color="#CCCCCC"> to see whether</font>

646
00:30:46,610 --> 00:30:53,760
kerchunk the Cure memory unit will will

647
00:30:50,460 --> 00:30:55,800
<font color="#CCCCCC">be a best fit so it calls the choice</font>

648
00:30:53,760 --> 00:30:56,650
function and choice function remember is

649
00:30:55,800 --> 00:31:02,080
the best here

650
00:30:56,650 --> 00:31:05,080
I give best as a continuation and so it

651
00:31:02,080 --> 00:31:08,139
will call this particular best fit

652
00:31:05,080 --> 00:31:11,169
function with<font color="#E5E5E5"> the current shark and the</font>

653
00:31:08,140 --> 00:31:14,080
<font color="#E5E5E5">size i'm trying trying to satisfy and</font>

654
00:31:11,170 --> 00:31:15,760
the best candidate<font color="#CCCCCC"> i had so far and at</font>

655
00:31:14,080 --> 00:31:17,649
the beginning<font color="#E5E5E5"> the best kind i had is</font>

656
00:31:15,760 --> 00:31:22,300
nothing<font color="#CCCCCC"> i didn't have any candidate so</font>

657
00:31:17,650 --> 00:31:25,480
obviously if and I should have an extra

658
00:31:22,300 --> 00:31:27,490
condition here if cure is each can is

659
00:31:25,480 --> 00:31:30,970
bottom then obviously cure will be a

660
00:31:27,490 --> 00:31:34,090
better fit than the<font color="#E5E5E5"> bottom so it will</font>

661
00:31:30,970 --> 00:31:35,910
return cure otherwise if it's if can is

662
00:31:34,090 --> 00:31:38,590
a better fit than cure<font color="#CCCCCC"> it returned can</font>

663
00:31:35,910 --> 00:31:40,810
and so it will return it will iterate

664
00:31:38,590 --> 00:31:42,389
over the list like this it will actually

665
00:31:40,810 --> 00:31:46,389
eat earth over the list like this here

666
00:31:42,390 --> 00:31:48,640
recursively if if I have nothing else in

667
00:31:46,390 --> 00:31:50,350
the list<font color="#E5E5E5"> I will just return my best</font>

668
00:31:48,640 --> 00:31:53,890
candidate so far otherwise<font color="#E5E5E5"> I'll keep</font>

669
00:31:50,350 --> 00:31:55,330
recursing on fine<font color="#CCCCCC"> feat popping each</font>

670
00:31:53,890 --> 00:31:59,140
element of the list one after the other

671
00:31:55,330 --> 00:32:00,699
so anyway just to tell you<font color="#CCCCCC"> that this is</font>

672
00:31:59,140 --> 00:32:03,700
a way to just define a fitness function

673
00:32:00,700 --> 00:32:08,860
in<font color="#E5E5E5"> the very simple very simple syntax</font>

674
00:32:03,700 --> 00:32:10,690
the meta language start syntax now

675
00:32:08,860 --> 00:32:13,500
what's interesting is if I don't find

676
00:32:10,690 --> 00:32:18,190
anything in the current lease I try to I

677
00:32:13,500 --> 00:32:22,690
try to iterate over over here so right

678
00:32:18,190 --> 00:32:24,700
<font color="#E5E5E5">here is res result is nothing right what</font>

679
00:32:22,690 --> 00:32:29,490
I'm going to<font color="#E5E5E5"> try</font><font color="#CCCCCC"> to do is to fit into</font>

680
00:32:24,700 --> 00:32:31,420
the next list so if the right bucket

681
00:32:29,490 --> 00:32:33,760
correspond to a certain list but that

682
00:32:31,420 --> 00:32:36,910
certainly has no free chunk I'm going<font color="#E5E5E5"> to</font>

683
00:32:33,760 --> 00:32:38,650
try to<font color="#E5E5E5"> find a match in the next list and</font>

684
00:32:36,910 --> 00:32:41,920
I do this over and over until I actually

685
00:32:38,650 --> 00:32:43,870
find something that suits my location so

686
00:32:41,920 --> 00:32:45,700
one way of thinking of fitness function

687
00:32:43,870 --> 00:32:49,239
is just you know passing the list see

688
00:32:45,700 --> 00:32:51,010
what what chunks satisfy my fitness

689
00:32:49,240 --> 00:32:54,610
algorithm best fit is one of them

690
00:32:51,010 --> 00:32:57,250
minimizing defects minimizing a memory

691
00:32:54,610 --> 00:33:00,300
footprint say trying<font color="#E5E5E5"> to avoid the</font>

692
00:32:57,250 --> 00:33:03,340
fragmenting the heat as much as possible

693
00:33:00,300 --> 00:33:04,990
you could replace that by the first fit

694
00:33:03,340 --> 00:33:07,870
you know as<font color="#CCCCCC"> soon as you find a chunk</font>

695
00:33:04,990 --> 00:33:09,880
that's that's<font color="#CCCCCC"> okay you return that chunk</font>

696
00:33:07,870 --> 00:33:12,100
that I just<font color="#E5E5E5"> need the best fit because</font>

697
00:33:09,880 --> 00:33:14,200
<font color="#E5E5E5">a little more elaborate and it's all the</font>

698
00:33:12,100 --> 00:33:15,820
way it would be just returned and you

699
00:33:14,200 --> 00:33:17,830
wouldn't have any<font color="#E5E5E5"> of that passing so I</font>

700
00:33:15,820 --> 00:33:27,310
<font color="#E5E5E5">wanted to show you with more complex</font>

701
00:33:17,830 --> 00:33:30,220
example right now you understand the

702
00:33:27,310 --> 00:33:34,030
fitness algorithm hopefully fit is what

703
00:33:30,220 --> 00:33:36,640
matters ok feat returns what least we'll

704
00:33:34,030 --> 00:33:39,190
be able to satisfy this allocation so

705
00:33:36,640 --> 00:33:40,540
you give me the list<font color="#E5E5E5"> of lists and you</font>

706
00:33:39,190 --> 00:33:43,060
give me<font color="#E5E5E5"> what size you trying to allocate</font>

707
00:33:40,540 --> 00:33:46,899
and now we return you what list is going

708
00:33:43,060 --> 00:33:54,190
to be able<font color="#E5E5E5"> to satisfy that chunk can you</font>

709
00:33:46,900 --> 00:33:57,040
<font color="#E5E5E5">guys see that yes it's a bit small I'll</font>

710
00:33:54,190 --> 00:33:59,020
<font color="#E5E5E5">try to summarize so this feed function</font>

711
00:33:57,040 --> 00:34:01,840
we just talked about I use it here I use

712
00:33:59,020 --> 00:34:04,570
it here is it here is it here this is

713
00:34:01,840 --> 00:34:06,939
very basic hip<font color="#E5E5E5"> semantics you would</font>

714
00:34:04,570 --> 00:34:10,210
expect in a what I track in this

715
00:34:06,940 --> 00:34:12,909
particular somatic is a set of counters

716
00:34:10,210 --> 00:34:15,730
<font color="#CCCCCC">the counters is how many chunks are</font>

717
00:34:12,909 --> 00:34:17,830
allocated those two maps<font color="#E5E5E5"> I mentioned</font>

718
00:34:15,730 --> 00:34:20,080
previously there is the allocation the

719
00:34:17,830 --> 00:34:24,190
allocated map and there is a free map

720
00:34:20,080 --> 00:34:29,049
and so say you wanna you<font color="#E5E5E5"> want a free p</font>

721
00:34:24,190 --> 00:34:33,010
and p is of size x so what<font color="#CCCCCC"> list was</font>

722
00:34:29,050 --> 00:34:34,629
actually a fitting x is that this was l1

723
00:34:33,010 --> 00:34:40,210
what's going<font color="#E5E5E5"> to happen is that when i</font>

724
00:34:34,629 --> 00:34:43,600
freed l1 will have one more allocatable

725
00:34:40,210 --> 00:34:46,030
chunk and one less fringe free trunk if

726
00:34:43,600 --> 00:34:50,319
I want<font color="#E5E5E5"> to do</font><font color="#CCCCCC"> Malik of X I will find</font>

727
00:34:46,030 --> 00:34:55,929
which lists fit X once I had at least L

728
00:34:50,320 --> 00:34:58,060
1 i'm going<font color="#CCCCCC"> to say that there is</font><font color="#E5E5E5"> one</font>

729
00:34:55,929 --> 00:35:01,300
<font color="#E5E5E5">less free chunk and one more allocated</font>

730
00:34:58,060 --> 00:35:07,480
chunk<font color="#CCCCCC"> i say allocatable sorry that was</font>

731
00:35:01,300 --> 00:35:10,140
<font color="#E5E5E5">allocated here typo here we allow</font>

732
00:35:07,480 --> 00:35:10,140
similarly

733
00:35:12,700 --> 00:35:18,319
realloc similarly will try to relock

734
00:35:15,500 --> 00:35:20,000
pointer P one with the size x + e x

735
00:35:18,320 --> 00:35:23,570
being the original size and easy

736
00:35:20,000 --> 00:35:27,290
extension size say so that's why i said

737
00:35:23,570 --> 00:35:30,920
here sighs p is X<font color="#E5E5E5"> and then X would fit</font>

738
00:35:27,290 --> 00:35:32,990
<font color="#E5E5E5">l1 + X + e will fit l2 so what</font><font color="#CCCCCC"> happened</font>

739
00:35:30,920 --> 00:35:36,230
here is that this particular l1 list

740
00:35:32,990 --> 00:35:38,120
will get one new free chunk and this one

741
00:35:36,230 --> 00:35:42,590
would be we have one less that's what I

742
00:35:38,120 --> 00:35:47,259
say here I say okay<font color="#E5E5E5"> there will be one</font>

743
00:35:42,590 --> 00:35:51,590
less allocated chunk for in this<font color="#E5E5E5"> one one</font>

744
00:35:47,260 --> 00:35:55,010
one more free chunk in this one one more

745
00:35:51,590 --> 00:35:59,810
allocated chunkiness<font color="#CCCCCC"> 213 in checking</font>

746
00:35:55,010 --> 00:36:02,000
this<font color="#CCCCCC"> one is too sorry so it's just</font>

747
00:35:59,810 --> 00:36:07,240
basically updating counters you know

748
00:36:02,000 --> 00:36:10,190
<font color="#E5E5E5">nothing not no rocket science at all but</font>

749
00:36:07,240 --> 00:36:12,259
really it is not enough<font color="#E5E5E5"> to predict</font>

750
00:36:10,190 --> 00:36:14,480
predict the layout of the heap as you

751
00:36:12,260 --> 00:36:16,550
can see there<font color="#E5E5E5"> is no adjacency going on</font>

752
00:36:14,480 --> 00:36:20,480
here for<font color="#E5E5E5"> good reason</font><font color="#CCCCCC"> because I Justin</font>

753
00:36:16,550 --> 00:36:23,330
see only depends on how you extend the

754
00:36:20,480 --> 00:36:25,370
heap right the first time you obtain the

755
00:36:23,330 --> 00:36:27,350
address of a heap of a heap chunk then

756
00:36:25,370 --> 00:36:30,109
it's when you actually extend that heat

757
00:36:27,350 --> 00:36:35,569
that heap for making the top chunk

758
00:36:30,110 --> 00:36:38,090
higher than it used to be so the real

759
00:36:35,570 --> 00:36:43,880
cement<font color="#E5E5E5"> is a real interesting part of</font>

760
00:36:38,090 --> 00:36:46,790
that is this this those three rules the

761
00:36:43,880 --> 00:36:49,490
qualys rule says okay<font color="#CCCCCC"> I have two chunks</font>

762
00:36:46,790 --> 00:36:51,440
p1 and p2 and I want to<font color="#E5E5E5"> call it them I</font>

763
00:36:49,490 --> 00:36:55,700
want<font color="#E5E5E5"> to make a big chunk p</font><font color="#CCCCCC"> 3 out of</font>

764
00:36:51,440 --> 00:37:02,060
those<font color="#E5E5E5"> two so say p1 has size x 1 p-2 a</font>

765
00:36:55,700 --> 00:37:06,339
size x 2 x 1 15 12 1<font color="#E5E5E5"> x 2 fits into l 2 x</font>

766
00:37:02,060 --> 00:37:09,680
3 15 2 m3 what's going<font color="#E5E5E5"> to happen is that</font>

767
00:37:06,340 --> 00:37:12,080
those two those two free list will get

768
00:37:09,680 --> 00:37:14,180
one less trunk and these fries will get

769
00:37:12,080 --> 00:37:20,029
one more one extra chunk vicar Scott

770
00:37:14,180 --> 00:37:22,129
week or last one one chunk sp3 and the

771
00:37:20,030 --> 00:37:25,970
size of p3 is a side of p1 plus the size

772
00:37:22,130 --> 00:37:26,270
of p2 that's why<font color="#E5E5E5"> we have one chunk in in</font>

773
00:37:25,970 --> 00:37:29,930
this

774
00:37:26,270 --> 00:37:31,910
in this this<font color="#E5E5E5"> guy and similarly what</font>

775
00:37:29,930 --> 00:37:34,310
inversely i should say when you split a

776
00:37:31,910 --> 00:37:36,980
chunk say you have a chunk p and you

777
00:37:34,310 --> 00:37:40,940
want spit it out offset<font color="#CCCCCC"> oh you will see</font>

778
00:37:36,980 --> 00:37:45,920
into two different chunks p1 and p2 and

779
00:37:40,940 --> 00:37:49,010
you'll have one less free trunk in<font color="#E5E5E5"> the</font>

780
00:37:45,920 --> 00:37:51,110
matter the list that that map that fits

781
00:37:49,010 --> 00:37:54,200
the side of<font color="#E5E5E5"> p the size of peas the size</font>

782
00:37:51,110 --> 00:37:57,980
of piggies<font color="#E5E5E5"> x and the leaders the list</font>

783
00:37:54,200 --> 00:38:01,700
that fits x is l2 then at the end<font color="#E5E5E5"> of the</font>

784
00:37:57,980 --> 00:38:05,180
day in l2 you will have<font color="#CCCCCC"> one more free</font>

785
00:38:01,700 --> 00:38:07,669
chunk and in a three you'll have one

786
00:38:05,180 --> 00:38:11,950
more food drink and l1 you have one one

787
00:38:07,670 --> 00:38:14,870
less free drink so when you had p and

788
00:38:11,950 --> 00:38:17,390
which was originally in<font color="#E5E5E5"> the list l1</font>

789
00:38:14,870 --> 00:38:19,880
you'll take it<font color="#E5E5E5"> away from</font><font color="#CCCCCC"> the list</font><font color="#E5E5E5"> and</font>

790
00:38:17,390 --> 00:38:23,480
then you'll add those two chunks p 1 in

791
00:38:19,880 --> 00:38:25,670
at least<font color="#E5E5E5"> NP NP 2 in that list so you</font>

792
00:38:23,480 --> 00:38:30,590
basically create check here that's

793
00:38:25,670 --> 00:38:32,570
interesting that's<font color="#E5E5E5"> all I didn't see per</font>

794
00:38:30,590 --> 00:38:35,230
decade so here when you speed a chunk

795
00:38:32,570 --> 00:38:37,310
you know that p1 and p2 are adjacent

796
00:38:35,230 --> 00:38:39,350
because they were part<font color="#E5E5E5"> of the same</font><font color="#CCCCCC"> Chun</font>

797
00:38:37,310 --> 00:38:41,480
so you just cut<font color="#CCCCCC"> that check into two so</font>

798
00:38:39,350 --> 00:38:44,210
p1 and p2 are<font color="#E5E5E5"> adjacent here you know the</font>

799
00:38:41,480 --> 00:38:46,670
adjacent another way to know that you

800
00:38:44,210 --> 00:38:50,000
have adjacent shank is when you had a

801
00:38:46,670 --> 00:38:54,710
top chunk so he will say top before on

802
00:38:50,000 --> 00:38:59,740
top after and say you want<font color="#CCCCCC"> to extend the</font>

803
00:38:54,710 --> 00:39:05,240
heap for size s to make a new chunk p

804
00:38:59,740 --> 00:39:10,459
then if the list that fit s-sorry not<font color="#CCCCCC"> X</font>

805
00:39:05,240 --> 00:39:13,819
but s release that fit X is<font color="#CCCCCC"> l then the</font>

806
00:39:10,460 --> 00:39:16,340
least L will get one more allocated

807
00:39:13,820 --> 00:39:19,160
chunk show that women one free drink he

808
00:39:16,340 --> 00:39:20,870
has no type I'm sorry and you'll<font color="#E5E5E5"> get one</font>

809
00:39:19,160 --> 00:39:23,000
more feature in<font color="#E5E5E5"> spartacus and the new</font>

810
00:39:20,870 --> 00:39:25,759
top chunk will become<font color="#CCCCCC"> the new truck you</font>

811
00:39:23,000 --> 00:39:28,370
extended and obviously whatever was the

812
00:39:25,760 --> 00:39:30,980
top chunk before will be adjusting to

813
00:39:28,370 --> 00:39:32,990
the new top chunk so it's<font color="#E5E5E5"> another way to</font>

814
00:39:30,980 --> 00:39:36,290
figure<font color="#E5E5E5"> out that</font><font color="#CCCCCC"> you have Justin see and</font>

815
00:39:32,990 --> 00:39:38,750
that's Isaac is this is key that<font color="#E5E5E5"> only</font>

816
00:39:36,290 --> 00:39:39,710
those two rules are affecting adjacency

817
00:39:38,750 --> 00:39:41,930
of the heap

818
00:39:39,710 --> 00:39:43,310
because allocation free reallocation all

819
00:39:41,930 --> 00:39:44,779
these things those are logical

820
00:39:43,310 --> 00:39:48,950
operations those are not physical

821
00:39:44,780 --> 00:39:50,750
operations this is a physical operation

822
00:39:48,950 --> 00:39:52,368
extending the physical operation split

823
00:39:50,750 --> 00:39:54,619
is<font color="#CCCCCC"> a</font><font color="#E5E5E5"> physical operation nothing else</font><font color="#CCCCCC"> is</font>

824
00:39:52,369 --> 00:39:57,980
<font color="#CCCCCC">a physical operation so when you try to</font>

825
00:39:54,619 --> 00:39:59,570
to predict the state of the heap keep in

826
00:39:57,980 --> 00:40:01,700
mind that you<font color="#E5E5E5"> just not see other chunks</font>

827
00:39:59,570 --> 00:40:03,020
only depend<font color="#E5E5E5"> on how you extend the hip</font>

828
00:40:01,700 --> 00:40:08,149
and how your speed chunks in the hip

829
00:40:03,020 --> 00:40:10,599
everything else is half half keeping

830
00:40:08,150 --> 00:40:14,270
it's just how<font color="#E5E5E5"> you maintain your lists</font>

831
00:40:10,599 --> 00:40:16,880
how and how full are<font color="#E5E5E5"> your list so if you</font>

832
00:40:14,270 --> 00:40:20,359
maintain counters of your lists you know

833
00:40:16,880 --> 00:40:22,400
how<font color="#E5E5E5"> many how many</font><font color="#CCCCCC"> hip chunks are in each</font>

834
00:40:20,359 --> 00:40:24,650
of these lists then you'll<font color="#E5E5E5"> know whether</font>

835
00:40:22,400 --> 00:40:27,080
a list is going to be<font color="#CCCCCC"> capable of fitting</font>

836
00:40:24,650 --> 00:40:29,270
a particular chunk if that's the<font color="#CCCCCC"> case</font>

837
00:40:27,080 --> 00:40:31,430
<font color="#E5E5E5">then you're going to take</font><font color="#CCCCCC"> one of</font><font color="#E5E5E5"> these</font>

838
00:40:29,270 --> 00:40:33,740
chunks out of the list and you will

839
00:40:31,430 --> 00:40:35,299
decrement the counter if that's not<font color="#E5E5E5"> the</font>

840
00:40:33,740 --> 00:40:37,939
case you take the next list and see if

841
00:40:35,300 --> 00:40:39,260
you<font color="#CCCCCC"> have one chain that can</font><font color="#E5E5E5"> satisfy but</font>

842
00:40:37,940 --> 00:40:40,790
these will<font color="#CCCCCC"> not change the efficiency of</font>

843
00:40:39,260 --> 00:40:42,830
the other chunks because chunks already

844
00:40:40,790 --> 00:40:45,170
exists that just in the free list there

845
00:40:42,830 --> 00:40:46,190
will be reused<font color="#E5E5E5"> some time but you just</font>

846
00:40:45,170 --> 00:40:53,900
don't see all those chunks will not

847
00:40:46,190 --> 00:40:57,200
change<font color="#CCCCCC"> okay obviously I passed on a lot</font>

848
00:40:53,900 --> 00:41:01,210
of implementation details here my goal

849
00:40:57,200 --> 00:41:04,069
was really to give you a another view of

850
00:41:01,210 --> 00:41:06,080
the thinking other insights<font color="#E5E5E5"> I think I</font>

851
00:41:04,070 --> 00:41:08,780
gained by looking at all these

852
00:41:06,080 --> 00:41:10,430
implementations and there are<font color="#E5E5E5"> lots of</font>

853
00:41:08,780 --> 00:41:12,470
details I didn't<font color="#E5E5E5"> talk about obviously</font>

854
00:41:10,430 --> 00:41:17,180
the calculus that I presented here is

855
00:41:12,470 --> 00:41:18,709
not entirely describing<font color="#E5E5E5"> how the hip</font>

856
00:41:17,180 --> 00:41:21,680
works for example I didn't talk about

857
00:41:18,710 --> 00:41:24,380
metadata and there is a reason why I

858
00:41:21,680 --> 00:41:26,410
<font color="#E5E5E5">didn't talk about metadata because even</font>

859
00:41:24,380 --> 00:41:31,670
though<font color="#E5E5E5"> most of the heap expose now they</font>

860
00:41:26,410 --> 00:41:34,700
use meta data corruption to say<font color="#CCCCCC"> write</font>

861
00:41:31,670 --> 00:41:38,440
anywhere whatever they want<font color="#CCCCCC"> in aerospace</font>

862
00:41:34,700 --> 00:41:42,980
most<font color="#CCCCCC"> metadata gets protected over time</font>

863
00:41:38,440 --> 00:41:44,839
in the last 10<font color="#CCCCCC"> years 15 years</font><font color="#E5E5E5"> ago no</font>

864
00:41:42,980 --> 00:41:49,070
<font color="#CCCCCC">metadata</font><font color="#E5E5E5"> was protected people could</font>

865
00:41:44,839 --> 00:41:51,650
could corrupt a before chunk and the

866
00:41:49,070 --> 00:41:52,869
<font color="#E5E5E5">next chunk and they would say</font><font color="#CCCCCC"> okay</font><font color="#E5E5E5"> now</font>

867
00:41:51,650 --> 00:41:55,720
you're<font color="#E5E5E5"> gonna</font>

868
00:41:52,869 --> 00:41:59,230
write<font color="#E5E5E5"> to the address in the next pointer</font>

869
00:41:55,720 --> 00:42:01,569
that I supplied during an overflow and

870
00:41:59,230 --> 00:42:04,150
that was enough to basically<font color="#E5E5E5"> over a nip</font>

871
00:42:01,569 --> 00:42:07,049
exploit nowadays in G<font color="#E5E5E5"> lipsy I was</font>

872
00:42:04,150 --> 00:42:09,160
counting just a few days ago how many

873
00:42:07,049 --> 00:42:11,288
consistency checks are there<font color="#E5E5E5"> there</font><font color="#CCCCCC"> are a</font>

874
00:42:09,160 --> 00:42:14,140
lot of consistency<font color="#E5E5E5"> checks in the hip</font>

875
00:42:11,289 --> 00:42:16,960
<font color="#CCCCCC">allocator a lot of them if in several</font>

876
00:42:14,140 --> 00:42:20,558
people in the last 10<font color="#CCCCCC"> years 15 years i</font>

877
00:42:16,960 --> 00:42:22,569
should say have studied<font color="#CCCCCC"> alternative way</font>

878
00:42:20,559 --> 00:42:27,819
to corrupt metadata to exploit he power

879
00:42:22,569 --> 00:42:29,920
flows and my take on this is if metadata

880
00:42:27,819 --> 00:42:31,690
overwrite is not dead yet it<font color="#E5E5E5"> will be</font>

881
00:42:29,920 --> 00:42:34,900
soon so don't rely<font color="#E5E5E5"> on that anymore</font>

882
00:42:31,690 --> 00:42:39,660
because this will the<font color="#E5E5E5"> histone how you</font>

883
00:42:34,900 --> 00:42:44,410
write reliable experts what matters is

884
00:42:39,660 --> 00:42:46,690
which user data is adjacent to each

885
00:42:44,410 --> 00:42:49,328
other user data so what's inside that

886
00:42:46,690 --> 00:42:52,650
chunk don't try to<font color="#E5E5E5"> take advantage of the</font>

887
00:42:49,329 --> 00:42:55,480
metadata<font color="#E5E5E5"> learned in the heap try to see</font>

888
00:42:52,650 --> 00:42:56,829
who where are the function pointers in

889
00:42:55,480 --> 00:42:58,989
the heap what are the<font color="#E5E5E5"> authenticated</font>

890
00:42:56,829 --> 00:43:02,200
authentication flags in the heat try to

891
00:42:58,989 --> 00:43:04,059
get<font color="#E5E5E5"> those chunks just after whatever you</font>

892
00:43:02,200 --> 00:43:05,680
can overwrite try to override a function

893
00:43:04,059 --> 00:43:08,640
pointer try to override<font color="#E5E5E5"> no syndicated</font>

894
00:43:05,680 --> 00:43:12,368
flag try to overwrite a virtual table

895
00:43:08,640 --> 00:43:14,799
function pointer that's how I worked for

896
00:43:12,369 --> 00:43:17,619
<font color="#CCCCCC">years after feeds that's how a lot of</font>

897
00:43:14,799 --> 00:43:19,930
different<font color="#E5E5E5"> exploit worked actually so</font>

898
00:43:17,619 --> 00:43:22,089
really<font color="#E5E5E5"> the strength the trend it's been</font>

899
00:43:19,930 --> 00:43:24,308
a really<font color="#E5E5E5"> tall while already at least</font>

900
00:43:22,089 --> 00:43:27,308
five years<font color="#E5E5E5"> even even more i should say</font>

901
00:43:24,309 --> 00:43:30,519
maybe that'd<font color="#CCCCCC"> be ten years but more and</font>

902
00:43:27,309 --> 00:43:32,769
more metadata exploitation is going away

903
00:43:30,519 --> 00:43:34,660
what matters is where the chunks are

904
00:43:32,769 --> 00:43:36,910
located what the adjacency of chunky and

905
00:43:34,660 --> 00:43:40,569
whether you<font color="#E5E5E5"> can predict the layout of</font>

906
00:43:36,910 --> 00:43:43,450
<font color="#E5E5E5">the hip after all if you could just use</font>

907
00:43:40,569 --> 00:43:45,880
meta data why why bother because any

908
00:43:43,450 --> 00:43:48,038
child has a header with<font color="#CCCCCC"> meta data in it</font>

909
00:43:45,880 --> 00:43:49,869
<font color="#E5E5E5">so any chunk would make it however</font>

910
00:43:48,039 --> 00:43:51,970
protections are increasing on the meta

911
00:43:49,869 --> 00:43:54,220
data and we reach a point very soon that

912
00:43:51,970 --> 00:44:00,999
is not possible anymore to use metadata

913
00:43:54,220 --> 00:44:03,459
for exploitation so pitfalls of of this

914
00:44:00,999 --> 00:44:04,609
small see small analysis<font color="#CCCCCC"> I just</font>

915
00:44:03,460 --> 00:44:06,830
described<font color="#CCCCCC"> a single heat</font>

916
00:44:04,610 --> 00:44:09,230
in fact in systems you<font color="#CCCCCC"> have multiple</font>

917
00:44:06,830 --> 00:44:11,960
heap sometimes I pretend that this

918
00:44:09,230 --> 00:44:14,750
calculus can be adapted fairly easily to

919
00:44:11,960 --> 00:44:17,570
deal with multiple heaps just when you

920
00:44:14,750 --> 00:44:19,970
<font color="#E5E5E5">have a list of lists you'd have a list</font>

921
00:44:17,570 --> 00:44:24,050
of lists of lists and then you have a

922
00:44:19,970 --> 00:44:25,580
cell heap selector function that would

923
00:44:24,050 --> 00:44:27,140
basically say<font color="#CCCCCC"> okay you're acting on that</font>

924
00:44:25,580 --> 00:44:29,090
<font color="#E5E5E5">list of lists or this other lists of</font>

925
00:44:27,140 --> 00:44:30,950
lists depending<font color="#CCCCCC"> on which keep you using</font>

926
00:44:29,090 --> 00:44:32,480
so if you're in<font color="#CCCCCC"> one thread you know you</font>

927
00:44:30,950 --> 00:44:34,870
do that is<font color="#E5E5E5"> that heap if you another</font>

928
00:44:32,480 --> 00:44:39,520
thread you see how the hip and in fact

929
00:44:34,870 --> 00:44:42,620
it's it's not possible i believe to

930
00:44:39,520 --> 00:44:44,720
infer the layout of one<font color="#E5E5E5"> heat based on</font>

931
00:44:42,620 --> 00:44:46,759
<font color="#CCCCCC">another heap because all heaps are</font>

932
00:44:44,720 --> 00:44:49,910
pretty much independent one he busy an

933
00:44:46,760 --> 00:44:52,580
independent from<font color="#CCCCCC"> the other so this this</font>

934
00:44:49,910 --> 00:44:55,220
analysis<font color="#CCCCCC"> I</font><font color="#E5E5E5"> presented is really intra</font>

935
00:44:52,580 --> 00:44:59,660
heap intra he before given heap how you

936
00:44:55,220 --> 00:45:05,330
how you infer the delay delay<font color="#CCCCCC"> out of the</font>

937
00:44:59,660 --> 00:45:09,770
heat even more vicious sometimes you

938
00:45:05,330 --> 00:45:11,690
have two heaps that<font color="#CCCCCC"> are in the same</font>

939
00:45:09,770 --> 00:45:13,190
thread so<font color="#E5E5E5"> you have front-end a locator</font>

940
00:45:11,690 --> 00:45:15,890
and back in a locator i mentioned low

941
00:45:13,190 --> 00:45:17,630
fragmentation heap I've devised the same

942
00:45:15,890 --> 00:45:20,240
hole semantics for the low fragmentation

943
00:45:17,630 --> 00:45:22,460
heap which is really<font color="#E5E5E5"> different and but I</font>

944
00:45:20,240 --> 00:45:25,250
didn't have time to actually explain all

945
00:45:22,460 --> 00:45:28,160
of that so here you have something

946
00:45:25,250 --> 00:45:30,320
called an activation heuristic we're

947
00:45:28,160 --> 00:45:31,910
usually you would use a front and a

948
00:45:30,320 --> 00:45:34,490
locator which has just<font color="#E5E5E5"> one single list</font>

949
00:45:31,910 --> 00:45:38,750
just<font color="#E5E5E5"> one least whole list of free chunks</font>

950
00:45:34,490 --> 00:45:40,189
and you will try to satisfy your

951
00:45:38,750 --> 00:45:42,430
location by one of the chunk<font color="#E5E5E5"> of that</font>

952
00:45:40,190 --> 00:45:44,660
list but<font color="#CCCCCC"> after a</font><font color="#E5E5E5"> certain amount of</font>

953
00:45:42,430 --> 00:45:46,759
allocations for given bucket size<font color="#E5E5E5"> you</font>

954
00:45:44,660 --> 00:45:49,250
switch to a back in our<font color="#E5E5E5"> back end</font>

955
00:45:46,760 --> 00:45:50,870
implementation<font color="#E5E5E5"> of the allocator which is</font>

956
00:45:49,250 --> 00:45:52,610
a low fragmentation heap well you'd<font color="#CCCCCC"> have</font>

957
00:45:50,870 --> 00:45:56,060
one liter per<font color="#CCCCCC"> packet which is why the</font>

958
00:45:52,610 --> 00:45:58,880
code low fragmentation so I didn't I did

959
00:45:56,060 --> 00:46:01,310
not explain that the activation her is

960
00:45:58,880 --> 00:46:04,010
take here even though if you had two<font color="#CCCCCC"> of</font>

961
00:46:01,310 --> 00:46:05,660
these inferences acting in parallel you

962
00:46:04,010 --> 00:46:08,300
could switch from one to the other based

963
00:46:05,660 --> 00:46:10,250
on whether<font color="#CCCCCC"> or not the</font><font color="#E5E5E5"> blue fragmentation</font>

964
00:46:08,300 --> 00:46:14,330
heap was activated forgiven bucket size

965
00:46:10,250 --> 00:46:17,240
so also the this multiple he panel

966
00:46:14,330 --> 00:46:18,900
killer is is not so<font color="#CCCCCC"> much a showstopper</font>

967
00:46:17,240 --> 00:46:22,078
you just need to know<font color="#CCCCCC"> that</font><font color="#E5E5E5"> is there</font>

968
00:46:18,900 --> 00:46:25,470
<font color="#E5E5E5">I use lists some some alligators</font>

969
00:46:22,079 --> 00:46:29,339
imitation like<font color="#E5E5E5"> GE molecules</font><font color="#CCCCCC"> RS so you</font>

970
00:46:25,470 --> 00:46:32,549
cannot translate my small fraction

971
00:46:29,339 --> 00:46:35,490
coolest to GE Malik as it you'd need to

972
00:46:32,549 --> 00:46:36,930
change a little bit I think you can make

973
00:46:35,490 --> 00:46:39,240
it<font color="#E5E5E5"> much simpler if you deal with our</font>

974
00:46:36,930 --> 00:46:43,649
eyes but I<font color="#CCCCCC"> I haven't</font><font color="#E5E5E5"> really done it so I</font>

975
00:46:39,240 --> 00:46:46,500
don't say more about that and finally I

976
00:46:43,650 --> 00:46:48,329
didn't<font color="#E5E5E5"> talk about non determinism as I</font>

977
00:46:46,500 --> 00:46:52,650
said<font color="#E5E5E5"> you have some implementations like</font>

978
00:46:48,329 --> 00:46:54,569
<font color="#CCCCCC">die hard the hardwood is a secure heap</font>

979
00:46:52,650 --> 00:46:57,180
allocated<font color="#E5E5E5"> that would randomized a heap</font>

980
00:46:54,569 --> 00:47:00,690
it will do randomized decisions on the

981
00:46:57,180 --> 00:47:04,770
fitness algorithm so it's kind of is not

982
00:47:00,690 --> 00:47:05,819
a deterministic fitness function is an

983
00:47:04,770 --> 00:47:08,069
honor to mystic fitness function

984
00:47:05,819 --> 00:47:11,160
similarly in the low fragmentation heap

985
00:47:08,069 --> 00:47:15,109
since<font color="#CCCCCC"> Windows 8 there was a non</font>

986
00:47:11,160 --> 00:47:18,960
determinism introduced where certain

987
00:47:15,109 --> 00:47:20,369
lists or each list in a low frequent

988
00:47:18,960 --> 00:47:23,789
asian heap is represented by something

989
00:47:20,369 --> 00:47:25,529
called<font color="#CCCCCC"> sub-segment if a sub-segment</font>

990
00:47:23,789 --> 00:47:27,750
becomes full out eighty percent it will

991
00:47:25,529 --> 00:47:29,430
create a new<font color="#E5E5E5"> sub segments just to make</font>

992
00:47:27,750 --> 00:47:31,049
sure that you can't<font color="#CCCCCC"> fill a complete</font>

993
00:47:29,430 --> 00:47:32,669
<font color="#CCCCCC">sub-segment I have full</font><font color="#E5E5E5"> control over the</font>

994
00:47:31,049 --> 00:47:37,170
layout of the subsequent so that's

995
00:47:32,670 --> 00:47:41,730
another way where you know the<font color="#E5E5E5"> pitfall</font>

996
00:47:37,170 --> 00:47:43,079
of that to sum up he<font color="#CCCCCC"> gonna carry</font>

997
00:47:41,730 --> 00:47:47,940
implementation and our this is really

998
00:47:43,079 --> 00:47:50,010
hard but if you there are some common

999
00:47:47,940 --> 00:47:53,390
common functionalities like split

1000
00:47:50,010 --> 00:47:58,109
coalesced the in early space abstraction

1001
00:47:53,390 --> 00:48:01,348
metadata corruption is instead or will

1002
00:47:58,109 --> 00:48:02,880
be soon so focus on a location got what

1003
00:48:01,349 --> 00:48:05,400
i call location guide abstraction

1004
00:48:02,880 --> 00:48:07,349
because<font color="#CCCCCC"> i believe</font><font color="#E5E5E5"> that's what will work</font>

1005
00:48:05,400 --> 00:48:11,250
or still work and will work in the

1006
00:48:07,349 --> 00:48:13,140
future until implementing this whole

1007
00:48:11,250 --> 00:48:15,329
thing<font color="#E5E5E5"> i may release my tool from some</font>

1008
00:48:13,140 --> 00:48:16,799
time i will<font color="#CCCCCC"> give a follow-up talk at</font>

1009
00:48:15,329 --> 00:48:19,349
some account in new york<font color="#E5E5E5"> in about two</font>

1010
00:48:16,799 --> 00:48:23,630
more sooner hope to see you there happy

1011
00:48:19,349 --> 00:48:23,630
to<font color="#CCCCCC"> take questions thank you</font>

