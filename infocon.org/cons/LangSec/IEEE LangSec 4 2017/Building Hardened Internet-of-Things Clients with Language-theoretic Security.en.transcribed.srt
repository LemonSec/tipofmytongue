1
00:00:04,600 --> 00:00:10,730
<font color="#CCCCCC">Griffen everybody</font><font color="#E5E5E5"> am present I'm a PhD</font>

2
00:00:07,910 --> 00:00:14,750
student at<font color="#CCCCCC"> Dartmouth and</font><font color="#E5E5E5"> I work with</font>

3
00:00:10,730 --> 00:00:18,039
Sergey<font color="#E5E5E5"> and</font><font color="#CCCCCC"> Sean and this work was from</font>

4
00:00:14,750 --> 00:00:21,230
<font color="#E5E5E5">my internship over the summer at</font><font color="#CCCCCC"> SR I</font>

5
00:00:18,039 --> 00:00:24,560
with<font color="#E5E5E5"> Michaels</font><font color="#CCCCCC"> Gabriela</font><font color="#E5E5E5"> and wolf which is</font>

6
00:00:21,230 --> 00:00:28,939
here today<font color="#CCCCCC"> ok</font><font color="#E5E5E5"> so this work was</font><font color="#CCCCCC"> funded by</font>

7
00:00:24,560 --> 00:00:31,848
<font color="#E5E5E5">a</font><font color="#CCCCCC"> Sara</font><font color="#E5E5E5"> international independent or</font><font color="#CCCCCC"> NT</font>

8
00:00:28,939 --> 00:00:32,900
initiatives so this is the outline<font color="#CCCCCC"> of</font><font color="#E5E5E5"> my</font>

9
00:00:31,849 --> 00:00:34,640
talk I'm going to<font color="#CCCCCC"> give you an</font>

10
00:00:32,900 --> 00:00:37,519
introduction<font color="#E5E5E5"> of the language viewpoint</font>

11
00:00:34,640 --> 00:00:39,680
<font color="#E5E5E5">and an overview of IOT protocols and I'm</font>

12
00:00:37,519 --> 00:00:42,110
going<font color="#E5E5E5"> to discuss passing errors and</font>

13
00:00:39,680 --> 00:00:43,250
<font color="#E5E5E5">protocol state machines</font><font color="#CCCCCC"> in IOT protocols</font>

14
00:00:42,110 --> 00:00:45,710
and<font color="#E5E5E5"> then I'm going to go about</font>

15
00:00:43,250 --> 00:00:48,979
describing our<font color="#E5E5E5"> approach to tackle</font>

16
00:00:45,710 --> 00:00:49,479
tackling this problem and the results<font color="#E5E5E5"> of</font>

17
00:00:48,979 --> 00:00:53,089
our work

18
00:00:49,479 --> 00:00:55,159
<font color="#CCCCCC">ok</font><font color="#E5E5E5"> so what's the real problem over</font><font color="#CCCCCC"> here</font>

19
00:00:53,089 --> 00:00:57,110
<font color="#E5E5E5">so a problem we are trying</font><font color="#CCCCCC"> to deal</font><font color="#E5E5E5"> with</font>

20
00:00:55,159 --> 00:00:59,900
<font color="#E5E5E5">so how do i ot protocols actually</font>

21
00:00:57,110 --> 00:01:04,220
differentiate<font color="#E5E5E5"> between a good</font><font color="#CCCCCC"> input and</font>

22
00:00:59,900 --> 00:01:08,330
bad input<font color="#E5E5E5"> and how good does dope-ass or</font>

23
00:01:04,220 --> 00:01:11,060
<font color="#CCCCCC">combinators actually perform in in</font>

24
00:01:08,330 --> 00:01:14,030
<font color="#E5E5E5">constrained devices that use these IOT</font>

25
00:01:11,060 --> 00:01:19,340
protocols and how<font color="#CCCCCC"> can</font><font color="#E5E5E5"> we actually build</font>

26
00:01:14,030 --> 00:01:22,390
these passes well um so yeah so this is

27
00:01:19,340 --> 00:01:26,810
<font color="#E5E5E5">what</font><font color="#CCCCCC"> language is all about I would</font><font color="#E5E5E5"> say</font>

28
00:01:22,390 --> 00:01:29,119
so<font color="#CCCCCC"> differentiating between a set of</font>

29
00:01:26,810 --> 00:01:31,340
<font color="#E5E5E5">possible inputs and actually identifying</font>

30
00:01:29,119 --> 00:01:33,619
<font color="#E5E5E5">the input</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> is expected</font><font color="#CCCCCC"> that by our</font>

31
00:01:31,340 --> 00:01:36,649
system is what we are<font color="#E5E5E5"> trying to deal</font>

32
00:01:33,619 --> 00:01:40,069
<font color="#CCCCCC">with over</font><font color="#E5E5E5"> here</font><font color="#CCCCCC"> oh so validating</font><font color="#E5E5E5"> input is</font>

33
00:01:36,649 --> 00:01:43,060
judging what<font color="#E5E5E5"> affect the code the the</font>

34
00:01:40,069 --> 00:01:46,100
<font color="#E5E5E5">input is supposed to have on the code oh</font>

35
00:01:43,060 --> 00:01:47,960
so the recognizer design pattern is when

36
00:01:46,100 --> 00:01:50,240
is<font color="#CCCCCC"> the design pattern where we actually</font>

37
00:01:47,960 --> 00:01:52,699
take the grammar of the language and

38
00:01:50,240 --> 00:01:55,999
then build a recognizer for<font color="#E5E5E5"> the language</font>

39
00:01:52,700 --> 00:01:57,829
which which rejects all the messages

40
00:01:55,999 --> 00:02:01,189
<font color="#E5E5E5">that do not conform to our</font><font color="#CCCCCC"> language and</font>

41
00:01:57,829 --> 00:02:04,458
then<font color="#E5E5E5"> process and accept only objects</font>

42
00:02:01,189 --> 00:02:08,810
that are well typed and<font color="#E5E5E5"> no raw input</font>

43
00:02:04,459 --> 00:02:11,240
actually<font color="#CCCCCC"> okay</font><font color="#E5E5E5"> so we for our work be</font>

44
00:02:08,810 --> 00:02:14,000
dealt<font color="#CCCCCC"> with two industrial IOT protocols</font>

45
00:02:11,240 --> 00:02:16,000
<font color="#CCCCCC">one is called mqtt which happens to be a</font>

46
00:02:14,000 --> 00:02:19,870
<font color="#CCCCCC">publish/subscribe protocol and</font>

47
00:02:16,000 --> 00:02:22,180
widely<font color="#E5E5E5"> used in pipelines and the oil and</font>

48
00:02:19,870 --> 00:02:24,370
<font color="#E5E5E5">gas industry and the</font><font color="#CCCCCC"> other protocol that</font>

49
00:02:22,180 --> 00:02:26,790
we were dealing<font color="#E5E5E5"> with is the XMPP</font>

50
00:02:24,370 --> 00:02:29,890
protocol which is<font color="#E5E5E5"> being used widely in</font>

51
00:02:26,790 --> 00:02:33,519
industrial<font color="#E5E5E5"> automation and it happens to</font>

52
00:02:29,890 --> 00:02:35,350
<font color="#E5E5E5">the</font><font color="#CCCCCC"> xml-based</font><font color="#E5E5E5"> okay so first the</font><font color="#CCCCCC"> mqtt</font>

53
00:02:33,520 --> 00:02:37,690
protocols the<font color="#CCCCCC"> MQTT protocol is actually</font>

54
00:02:35,350 --> 00:02:41,560
<font color="#CCCCCC">really</font><font color="#E5E5E5"> lightweight and it has only a</font>

55
00:02:37,690 --> 00:02:42,850
fixed<font color="#CCCCCC"> set</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> messages</font><font color="#E5E5E5"> and so when you</font>

56
00:02:41,560 --> 00:02:44,830
publish a message on a particular

57
00:02:42,850 --> 00:02:45,910
channel there<font color="#CCCCCC"> are no no real details</font>

58
00:02:44,830 --> 00:02:49,570
about who the<font color="#CCCCCC"> sender is</font>

59
00:02:45,910 --> 00:02:51,280
and so the<font color="#CCCCCC"> MQTT protocol has a really</font>

60
00:02:49,570 --> 00:02:53,709
<font color="#E5E5E5">fun option which is you can</font><font color="#CCCCCC"> subscribe to</font>

61
00:02:51,280 --> 00:02:55,989
the hash symbol and then that would

62
00:02:53,709 --> 00:02:57,820
basically<font color="#E5E5E5"> give you messages from all the</font>

63
00:02:55,989 --> 00:03:00,010
channels on<font color="#CCCCCC"> the particular server</font><font color="#E5E5E5"> it</font>

64
00:02:57,820 --> 00:03:02,470
it's a very very<font color="#E5E5E5"> very bad idea but I'm</font>

65
00:03:00,010 --> 00:03:05,560
guessing<font color="#E5E5E5"> that administrators</font><font color="#CCCCCC"> find it</font>

66
00:03:02,470 --> 00:03:08,590
pretty<font color="#E5E5E5"> handy okay and one thing about</font>

67
00:03:05,560 --> 00:03:11,110
<font color="#E5E5E5">the</font><font color="#CCCCCC"> MQTT protocol is this that</font><font color="#E5E5E5"> as per</font>

68
00:03:08,590 --> 00:03:14,170
<font color="#E5E5E5">the spec TLS is optional and it's not</font>

69
00:03:11,110 --> 00:03:18,730
enforced by most servers<font color="#CCCCCC"> and most</font>

70
00:03:14,170 --> 00:03:22,149
providers so the packet format for<font color="#CCCCCC"> NQ DT</font>

71
00:03:18,730 --> 00:03:23,410
is very simple and so both the protocols

72
00:03:22,150 --> 00:03:26,650
<font color="#E5E5E5">that we are dealing with are application</font>

73
00:03:23,410 --> 00:03:28,870
layer protocols<font color="#E5E5E5"> and so the</font><font color="#CCCCCC"> MQTT protocol</font>

74
00:03:26,650 --> 00:03:31,330
basically<font color="#E5E5E5"> has a</font><font color="#CCCCCC"> one byte header with a</font>

75
00:03:28,870 --> 00:03:32,680
message type and<font color="#E5E5E5"> quality of service</font>

76
00:03:31,330 --> 00:03:35,860
there<font color="#E5E5E5"> are two bits for quality of</font>

77
00:03:32,680 --> 00:03:37,450
<font color="#E5E5E5">service and you</font><font color="#CCCCCC"> can so there's</font><font color="#E5E5E5"> a</font>

78
00:03:35,860 --> 00:03:39,910
remaining<font color="#E5E5E5"> length field which happens to</font>

79
00:03:37,450 --> 00:03:41,320
<font color="#CCCCCC">be at</font><font color="#E5E5E5"> most</font><font color="#CCCCCC"> 4 bytes</font><font color="#E5E5E5"> and then there's the</font>

80
00:03:39,910 --> 00:03:45,280
payload which is not really fixed size

81
00:03:41,320 --> 00:03:47,590
and so the protocol state machine for

82
00:03:45,280 --> 00:03:49,500
<font color="#CCCCCC">MQTT is again fairly simple because</font><font color="#E5E5E5"> the</font>

83
00:03:47,590 --> 00:03:52,030
number<font color="#E5E5E5"> of</font><font color="#CCCCCC"> messages are very limited so</font>

84
00:03:49,500 --> 00:03:54,940
<font color="#E5E5E5">the client sends the connects message</font>

85
00:03:52,030 --> 00:03:57,040
and then the server responds<font color="#E5E5E5"> and the</font>

86
00:03:54,940 --> 00:03:58,750
connection<font color="#E5E5E5"> is completed and then the</font>

87
00:03:57,040 --> 00:04:00,459
client<font color="#E5E5E5"> keeps sending ping messages to</font>

88
00:03:58,750 --> 00:04:02,769
the<font color="#E5E5E5"> server to keep the connection awake</font>

89
00:04:00,459 --> 00:04:05,200
and then the client can also subscribe

90
00:04:02,769 --> 00:04:07,120
<font color="#CCCCCC">to a particular</font><font color="#E5E5E5"> channel and then the</font>

91
00:04:05,200 --> 00:04:08,920
server<font color="#E5E5E5"> will send an ACK that's about it</font>

92
00:04:07,120 --> 00:04:11,350
it's<font color="#E5E5E5"> a</font><font color="#CCCCCC"> very</font><font color="#E5E5E5"> simple and straightforward</font>

93
00:04:08,920 --> 00:04:13,809
protocol the second protocol that<font color="#E5E5E5"> we</font>

94
00:04:11,350 --> 00:04:16,358
were dealing<font color="#E5E5E5"> with is the XMPP protocol</font>

95
00:04:13,810 --> 00:04:19,390
and as I<font color="#CCCCCC"> said</font><font color="#E5E5E5"> earlier this happens to be</font>

96
00:04:16,358 --> 00:04:24,640
<font color="#E5E5E5">XML based and almost all providers of</font>

97
00:04:19,390 --> 00:04:26,710
XMPP now enforced<font color="#E5E5E5"> TLS version</font><font color="#CCCCCC"> 2 and most</font>

98
00:04:24,640 --> 00:04:28,270
of<font color="#CCCCCC"> the</font><font color="#E5E5E5"> servers available right now or do</font>

99
00:04:26,710 --> 00:04:31,120
<font color="#E5E5E5">not really give an</font><font color="#CCCCCC"> option to decide</font>

100
00:04:28,270 --> 00:04:33,969
and there are other<font color="#E5E5E5"> options like</font>

101
00:04:31,120 --> 00:04:37,720
<font color="#E5E5E5">authentication which is still optional</font>

102
00:04:33,970 --> 00:04:39,310
<font color="#E5E5E5">and in our in our implementation we</font>

103
00:04:37,720 --> 00:04:40,900
<font color="#E5E5E5">actually made a design decision to</font>

104
00:04:39,310 --> 00:04:45,460
enforce<font color="#CCCCCC"> it</font>

105
00:04:40,900 --> 00:04:48,669
in our architecture<font color="#CCCCCC"> okay so this is how</font>

106
00:04:45,460 --> 00:04:50,979
a simple<font color="#E5E5E5"> lesson XMPP protocol</font><font color="#CCCCCC"> messages</font>

107
00:04:48,669 --> 00:04:55,120
look<font color="#E5E5E5"> like so there's a message tag with</font>

108
00:04:50,979 --> 00:04:58,240
an ID and type and to and from<font color="#CCCCCC"> and the</font>

109
00:04:55,120 --> 00:05:01,599
active tag is<font color="#E5E5E5"> basically to keep</font><font color="#CCCCCC"> the to</font>

110
00:04:58,240 --> 00:05:03,880
basically denote that<font color="#E5E5E5"> the</font><font color="#CCCCCC"> the client</font>

111
00:05:01,599 --> 00:05:05,259
<font color="#E5E5E5">that is it's basically the state of the</font>

112
00:05:03,880 --> 00:05:08,310
client so there is an active inactive

113
00:05:05,259 --> 00:05:10,479
busy those sort of<font color="#E5E5E5"> states and the</font>

114
00:05:08,310 --> 00:05:14,020
<font color="#CCCCCC">success message is the message that</font><font color="#E5E5E5"> is</font>

115
00:05:10,479 --> 00:05:16,630
<font color="#E5E5E5">sent by the server when you send TLS</font>

116
00:05:14,020 --> 00:05:18,609
<font color="#CCCCCC">request</font><font color="#E5E5E5"> and it's a TLS request which is</font>

117
00:05:16,630 --> 00:05:21,759
a<font color="#E5E5E5"> proceed message and then it comes back</font>

118
00:05:18,610 --> 00:05:23,229
with<font color="#E5E5E5"> the success so the XMPP protocol</font>

119
00:05:21,759 --> 00:05:25,630
state machine is<font color="#CCCCCC"> slightly more</font>

120
00:05:23,229 --> 00:05:28,479
complicated<font color="#CCCCCC"> so there</font><font color="#E5E5E5"> are way more states</font>

121
00:05:25,630 --> 00:05:31,300
because like the stream message is

122
00:05:28,479 --> 00:05:33,460
actually<font color="#CCCCCC"> sent three times so one before</font>

123
00:05:31,300 --> 00:05:35,940
one in the initial stage where the

124
00:05:33,460 --> 00:05:38,919
connection is<font color="#E5E5E5"> being initiated and then</font>

125
00:05:35,940 --> 00:05:40,210
when the TLS connection is<font color="#E5E5E5"> being</font>

126
00:05:38,919 --> 00:05:42,460
initiated and then when the

127
00:05:40,210 --> 00:05:44,320
authentication happens and then when the

128
00:05:42,460 --> 00:05:47,888
binding happens so the stream message is

129
00:05:44,320 --> 00:05:49,659
<font color="#E5E5E5">actually sent time and again and and</font>

130
00:05:47,889 --> 00:05:51,400
each<font color="#CCCCCC"> three message</font><font color="#E5E5E5"> actually has fields</font>

131
00:05:49,659 --> 00:05:55,719
that are unique to that particular

132
00:05:51,400 --> 00:05:57,520
<font color="#CCCCCC">message okay so</font><font color="#E5E5E5"> our contributions</font>

133
00:05:55,719 --> 00:05:59,830
basically over here was this that we use

134
00:05:57,520 --> 00:06:02,349
the hammer Ruby bindings<font color="#E5E5E5"> to build these</font>

135
00:05:59,830 --> 00:06:06,818
parsers<font color="#E5E5E5"> and then be basically</font>

136
00:06:02,349 --> 00:06:09,699
demonstrate that to build these<font color="#CCCCCC"> parcels</font>

137
00:06:06,819 --> 00:06:12,400
<font color="#E5E5E5">in an IOT setting it's not really all</font>

138
00:06:09,699 --> 00:06:14,530
<font color="#CCCCCC">that</font><font color="#E5E5E5"> much</font><font color="#CCCCCC"> effort as we would think</font><font color="#E5E5E5"> these</font>

139
00:06:12,400 --> 00:06:17,289
classes are<font color="#CCCCCC"> not really that difficult to</font>

140
00:06:14,530 --> 00:06:18,669
write and in terms of human effort<font color="#E5E5E5"> in</font>

141
00:06:17,289 --> 00:06:21,639
the number<font color="#E5E5E5"> of lines of code</font><font color="#CCCCCC"> that it took</font>

142
00:06:18,669 --> 00:06:23,289
it<font color="#E5E5E5"> was very very very minimal and we</font>

143
00:06:21,639 --> 00:06:24,849
actually<font color="#CCCCCC"> built fully</font><font color="#E5E5E5"> functioning</font>

144
00:06:23,289 --> 00:06:27,219
implementations with a lot<font color="#E5E5E5"> of options</font>

145
00:06:24,849 --> 00:06:29,380
<font color="#E5E5E5">and</font><font color="#CCCCCC"> a lot of</font><font color="#E5E5E5"> features</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> even then it</font>

146
00:06:27,219 --> 00:06:32,590
was not really<font color="#E5E5E5"> all</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> much</font><font color="#CCCCCC"> of an</font>

147
00:06:29,380 --> 00:06:36,599
overhead in terms<font color="#E5E5E5"> of CPU time nor the</font>

148
00:06:32,590 --> 00:06:39,880
<font color="#CCCCCC">lines of code that it took us okay so</font>

149
00:06:36,599 --> 00:06:41,330
passing<font color="#CCCCCC"> in the IOT is also a very</font>

150
00:06:39,880 --> 00:06:44,810
serious<font color="#CCCCCC"> problem like</font>

151
00:06:41,330 --> 00:06:46,669
everywhere else and we studied the<font color="#CCCCCC"> CVA</font>

152
00:06:44,810 --> 00:06:49,520
<font color="#E5E5E5">lists for the</font><font color="#CCCCCC"> two protocols</font><font color="#E5E5E5"> that we are</font>

153
00:06:46,670 --> 00:06:51,020
<font color="#E5E5E5">talking about</font><font color="#CCCCCC"> and we found that several</font>

154
00:06:49,520 --> 00:06:53,359
<font color="#E5E5E5">of the popular implementations</font>

155
00:06:51,020 --> 00:06:57,380
industrially available<font color="#E5E5E5"> have been</font>

156
00:06:53,360 --> 00:06:59,180
exploited<font color="#E5E5E5"> by crafted packet bugs not so</font>

157
00:06:57,380 --> 00:07:01,760
much for the<font color="#CCCCCC"> mqtt protocol because</font>

158
00:06:59,180 --> 00:07:05,480
although<font color="#E5E5E5"> it is widely used</font><font color="#CCCCCC"> it seems to</font>

159
00:07:01,760 --> 00:07:08,150
be<font color="#E5E5E5"> very sparsely reported on on the</font><font color="#CCCCCC"> CV</font>

160
00:07:05,480 --> 00:07:10,370
<font color="#E5E5E5">Ellis</font><font color="#CCCCCC"> whereas XMPP seems to have way</font>

161
00:07:08,150 --> 00:07:14,630
more vulnerabilities than crypto

162
00:07:10,370 --> 00:07:17,420
vulnerabilities actually<font color="#CCCCCC"> okay</font><font color="#E5E5E5"> so this is</font>

163
00:07:14,630 --> 00:07:19,850
basically a an interesting<font color="#CCCCCC"> bug</font><font color="#E5E5E5"> that we</font>

164
00:07:17,420 --> 00:07:22,040
found on<font color="#E5E5E5"> the region</font><font color="#CCCCCC"> fine will be</font><font color="#E5E5E5"> found</font>

165
00:07:19,850 --> 00:07:25,310
<font color="#E5E5E5">on the CV Ellis</font>

166
00:07:22,040 --> 00:07:27,650
it was the IBM<font color="#E5E5E5"> insight</font><font color="#CCCCCC"> MQTT bug</font><font color="#E5E5E5"> where in</font>

167
00:07:25,310 --> 00:07:29,870
the authentication message the<font color="#CCCCCC"> mqtt</font>

168
00:07:27,650 --> 00:07:33,130
client sends a particular crafted packet

169
00:07:29,870 --> 00:07:34,280
and then the server is<font color="#CCCCCC"> forced</font><font color="#E5E5E5"> to restart</font>

170
00:07:33,130 --> 00:07:36,909
<font color="#CCCCCC">okay</font>

171
00:07:34,280 --> 00:07:39,580
so our<font color="#CCCCCC"> approach</font><font color="#E5E5E5"> over here was</font><font color="#CCCCCC"> basically</font>

172
00:07:36,910 --> 00:07:42,980
using partial<font color="#CCCCCC"> combinators to build our</font>

173
00:07:39,580 --> 00:07:44,539
individual passes for each state<font color="#CCCCCC"> and we</font>

174
00:07:42,980 --> 00:07:47,420
use the Ruby bindings as I said we also

175
00:07:44,540 --> 00:07:49,970
made use of a ruby gem<font color="#CCCCCC"> called the state</font>

176
00:07:47,420 --> 00:07:53,810
machine gem to implement our protocol

177
00:07:49,970 --> 00:07:56,030
state machine<font color="#E5E5E5"> so our methodology was</font>

178
00:07:53,810 --> 00:07:58,580
<font color="#E5E5E5">this that we</font><font color="#CCCCCC"> we read through</font><font color="#E5E5E5"> these</font>

179
00:07:56,030 --> 00:08:01,489
specifications for these<font color="#E5E5E5"> protocols and</font>

180
00:07:58,580 --> 00:08:03,859
we<font color="#E5E5E5"> extracted</font><font color="#CCCCCC"> the protocol state machine</font>

181
00:08:01,490 --> 00:08:05,120
<font color="#E5E5E5">and we enforced some rules that we</font>

182
00:08:03,860 --> 00:08:07,820
thought were essential like

183
00:08:05,120 --> 00:08:09,020
authentication<font color="#CCCCCC"> TLS</font><font color="#E5E5E5"> and those sort of</font>

184
00:08:07,820 --> 00:08:11,930
rules<font color="#CCCCCC"> that we thought were actually</font>

185
00:08:09,020 --> 00:08:13,640
essential and then<font color="#E5E5E5"> we built the state</font>

186
00:08:11,930 --> 00:08:16,220
machine using<font color="#CCCCCC"> the state machine gem</font><font color="#E5E5E5"> and</font>

187
00:08:13,640 --> 00:08:18,440
then for<font color="#CCCCCC"> each of the</font><font color="#E5E5E5"> particular</font><font color="#CCCCCC"> states</font>

188
00:08:16,220 --> 00:08:20,330
we defined a separate parser<font color="#E5E5E5"> so there is</font>

189
00:08:18,440 --> 00:08:24,950
a separate parser for<font color="#E5E5E5"> each of the states</font>

190
00:08:20,330 --> 00:08:27,500
in the protocol state machine so<font color="#CCCCCC"> yeah so</font>

191
00:08:24,950 --> 00:08:29,780
we<font color="#E5E5E5"> made use of the state machine gem as</font>

192
00:08:27,500 --> 00:08:32,929
I said and this<font color="#CCCCCC"> is the</font><font color="#E5E5E5"> syntax of the</font>

193
00:08:29,780 --> 00:08:35,600
state machine gem where you can you can

194
00:08:32,929 --> 00:08:37,549
clearly specify before transitions and

195
00:08:35,600 --> 00:08:39,920
after transitions there are the state

196
00:08:37,549 --> 00:08:43,189
<font color="#E5E5E5">machine gem has a very robust way of</font>

197
00:08:39,919 --> 00:08:46,400
doing callbacks<font color="#E5E5E5"> and you can set events</font>

198
00:08:43,190 --> 00:08:49,190
<font color="#E5E5E5">and states like the transition helper</font>

199
00:08:46,400 --> 00:08:51,290
method basically denotes<font color="#CCCCCC"> that when a</font>

200
00:08:49,190 --> 00:08:52,850
particular event happens then you can

201
00:08:51,290 --> 00:08:54,870
<font color="#E5E5E5">basically transition from one state to</font>

202
00:08:52,850 --> 00:08:57,050
<font color="#CCCCCC">another state and</font>

203
00:08:54,870 --> 00:08:59,610
the state<font color="#E5E5E5"> machine</font><font color="#CCCCCC"> Jam also has a very</font>

204
00:08:57,050 --> 00:09:05,609
robust help set of helper methods to

205
00:08:59,610 --> 00:09:07,350
write our<font color="#CCCCCC"> test so our</font><font color="#E5E5E5"> next step after</font>

206
00:09:05,610 --> 00:09:09,420
<font color="#E5E5E5">extracting the protocol state machine</font>

207
00:09:07,350 --> 00:09:13,110
was actually<font color="#CCCCCC"> writing</font><font color="#E5E5E5"> individual passes</font>

208
00:09:09,420 --> 00:09:16,079
for each of the receiving<font color="#CCCCCC"> States</font><font color="#E5E5E5"> and for</font>

209
00:09:13,110 --> 00:09:18,270
this purpose we first<font color="#E5E5E5"> like first we</font>

210
00:09:16,080 --> 00:09:21,990
extracted<font color="#E5E5E5"> the grammar and wrote it down</font>

211
00:09:18,270 --> 00:09:26,040
<font color="#E5E5E5">and then we converted that</font><font color="#CCCCCC"> to a pass or</font>

212
00:09:21,990 --> 00:09:27,930
Combinator<font color="#E5E5E5"> so the best thing about</font>

213
00:09:26,040 --> 00:09:29,880
hammer is this that when<font color="#CCCCCC"> we actually</font>

214
00:09:27,930 --> 00:09:31,739
<font color="#E5E5E5">started writing it we realized that the</font>

215
00:09:29,880 --> 00:09:37,320
code actually looks exactly like the

216
00:09:31,740 --> 00:09:39,660
grammar<font color="#CCCCCC"> that we put down and so and it</font>

217
00:09:37,320 --> 00:09:42,330
was<font color="#E5E5E5"> very easy</font><font color="#CCCCCC"> to translate</font><font color="#E5E5E5"> our our</font>

218
00:09:39,660 --> 00:09:45,600
grammar into<font color="#E5E5E5"> the code specification over</font>

219
00:09:42,330 --> 00:09:48,600
here so these limitations<font color="#E5E5E5"> of our work</font>

220
00:09:45,600 --> 00:09:51,000
<font color="#E5E5E5">that we feel the limitations that we</font>

221
00:09:48,600 --> 00:09:54,810
feel could be<font color="#E5E5E5"> overcome</font><font color="#CCCCCC"> but I don't know</font>

222
00:09:51,000 --> 00:09:56,520
at<font color="#CCCCCC"> what time frame</font><font color="#E5E5E5"> it was this that it's</font>

223
00:09:54,810 --> 00:10:00,060
a<font color="#E5E5E5"> very tedious process of actually going</font>

224
00:09:56,520 --> 00:10:02,430
through hundreds<font color="#E5E5E5"> of</font><font color="#CCCCCC"> pages</font><font color="#E5E5E5"> of protocol</font>

225
00:10:00,060 --> 00:10:04,500
specification and actually extracting

226
00:10:02,430 --> 00:10:06,510
the protocol state machine<font color="#CCCCCC"> and the</font>

227
00:10:04,500 --> 00:10:08,270
grammar<font color="#E5E5E5"> so a lot of the</font><font color="#CCCCCC"> protocols</font><font color="#E5E5E5"> that</font>

228
00:10:06,510 --> 00:10:11,790
we were<font color="#E5E5E5"> looking at did not even have</font>

229
00:10:08,270 --> 00:10:13,290
clear<font color="#E5E5E5"> state machine diagrams so then we</font>

230
00:10:11,790 --> 00:10:15,930
<font color="#CCCCCC">actually had to read</font><font color="#E5E5E5"> through a lot of it</font>

231
00:10:13,290 --> 00:10:18,870
<font color="#E5E5E5">and actually extract it and there is</font>

232
00:10:15,930 --> 00:10:22,229
also an overhead to recognizing<font color="#E5E5E5"> every</font>

233
00:10:18,870 --> 00:10:24,990
message<font color="#E5E5E5"> so we</font><font color="#CCCCCC"> actually performed our</font>

234
00:10:22,230 --> 00:10:27,900
experiments on a<font color="#CCCCCC"> Raspberry Pi</font><font color="#E5E5E5"> and we</font>

235
00:10:24,990 --> 00:10:29,610
found that<font color="#E5E5E5"> for the XMPP protocol it was</font>

236
00:10:27,900 --> 00:10:31,260
in the order<font color="#CCCCCC"> of</font><font color="#E5E5E5"> milliseconds and for the</font>

237
00:10:29,610 --> 00:10:34,890
<font color="#CCCCCC">MQTT protocol it was in the order of</font>

238
00:10:31,260 --> 00:10:36,510
<font color="#E5E5E5">microseconds actually so there is a</font>

239
00:10:34,890 --> 00:10:40,140
small<font color="#E5E5E5"> overhead to recognizing each</font>

240
00:10:36,510 --> 00:10:43,620
message fully but we feel<font color="#E5E5E5"> that it</font><font color="#CCCCCC"> is a</font>

241
00:10:40,140 --> 00:10:49,050
prize we should be willing<font color="#CCCCCC"> to pay</font><font color="#E5E5E5"> okay</font>

242
00:10:43,620 --> 00:10:51,540
<font color="#CCCCCC">so</font><font color="#E5E5E5"> our results so we made use of a bunch</font>

243
00:10:49,050 --> 00:10:53,790
of techniques to<font color="#E5E5E5"> validate our work and</font>

244
00:10:51,540 --> 00:10:56,849
the first one was<font color="#CCCCCC"> that we performed</font>

245
00:10:53,790 --> 00:10:59,430
timing analysis<font color="#E5E5E5"> and on each of our</font>

246
00:10:56,850 --> 00:11:03,300
<font color="#E5E5E5">parcels</font><font color="#CCCCCC"> that we wrote and we</font><font color="#E5E5E5"> wrote unit</font>

247
00:10:59,430 --> 00:11:06,489
tests<font color="#CCCCCC"> by writing the code and we also</font>

248
00:11:03,300 --> 00:11:09,640
tested our code on you

249
00:11:06,490 --> 00:11:12,810
sample set of<font color="#CCCCCC"> messages that were</font><font color="#E5E5E5"> that we</font>

250
00:11:09,640 --> 00:11:16,600
took from<font color="#E5E5E5"> the CVE list basically</font>

251
00:11:12,810 --> 00:11:19,390
<font color="#E5E5E5">messages</font><font color="#CCCCCC"> that are known to be have been</font>

252
00:11:16,600 --> 00:11:22,120
<font color="#E5E5E5">known to be malicious in the past and we</font>

253
00:11:19,390 --> 00:11:25,270
ran our<font color="#CCCCCC"> parser we ran our parser on</font>

254
00:11:22,120 --> 00:11:26,380
those<font color="#E5E5E5"> set</font><font color="#CCCCCC"> of inputs and saw</font><font color="#E5E5E5"> saw</font><font color="#CCCCCC"> opposite</font>

255
00:11:25,270 --> 00:11:29,279
<font color="#E5E5E5">actually reject a</font><font color="#CCCCCC"> lot of those messages</font>

256
00:11:26,380 --> 00:11:32,920
<font color="#CCCCCC">actually all of those</font><font color="#E5E5E5"> messages not a lot</font>

257
00:11:29,279 --> 00:11:36,010
<font color="#E5E5E5">so performance</font><font color="#CCCCCC"> wise our implementation</font>

258
00:11:32,920 --> 00:11:37,660
actually<font color="#E5E5E5"> took lesser time to</font><font color="#CCCCCC"> establish a</font>

259
00:11:36,010 --> 00:11:41,410
connection when it came to the<font color="#CCCCCC"> mqtt</font>

260
00:11:37,660 --> 00:11:43,390
protocol<font color="#CCCCCC"> and it took slightly more time</font>

261
00:11:41,410 --> 00:11:45,939
than a few<font color="#CCCCCC"> implementations of the</font><font color="#E5E5E5"> XMPP</font>

262
00:11:43,390 --> 00:11:50,740
protocol based on different languages

263
00:11:45,940 --> 00:11:53,560
and<font color="#E5E5E5"> so</font><font color="#CCCCCC"> we were we were using a Raspberry</font>

264
00:11:50,740 --> 00:11:56,080
<font color="#E5E5E5">Pi to run our tests and we used the</font>

265
00:11:53,560 --> 00:12:00,279
<font color="#CCCCCC">whines</font><font color="#E5E5E5"> XMPP server and the mosquito</font><font color="#CCCCCC"> MQTT</font>

266
00:11:56,080 --> 00:12:03,700
server to perform<font color="#E5E5E5"> our experiments</font>

267
00:12:00,279 --> 00:12:06,820
so our implementation actually<font color="#E5E5E5"> had a</font>

268
00:12:03,700 --> 00:12:08,850
bunch of receiving<font color="#E5E5E5"> states like the</font>

269
00:12:06,820 --> 00:12:12,399
<font color="#E5E5E5">stream one</font><font color="#CCCCCC"> proceed stream two and so on</font>

270
00:12:08,850 --> 00:12:14,770
<font color="#CCCCCC">so the number of lines that</font><font color="#E5E5E5"> it took us</font>

271
00:12:12,399 --> 00:12:16,810
in Hammer was very minimal<font color="#CCCCCC"> like less</font>

272
00:12:14,770 --> 00:12:20,230
<font color="#CCCCCC">than 4 less than</font><font color="#E5E5E5"> 40 actually</font><font color="#CCCCCC"> for each of</font>

273
00:12:16,810 --> 00:12:22,989
the messages<font color="#CCCCCC"> and as you can</font><font color="#E5E5E5"> see</font><font color="#CCCCCC"> even</font><font color="#E5E5E5"> the</font>

274
00:12:20,230 --> 00:12:27,190
CPU time<font color="#CCCCCC"> is</font><font color="#E5E5E5"> quite</font><font color="#CCCCCC"> reasonable for XMPP</font>

275
00:12:22,990 --> 00:12:30,339
messages and we followed the exact same

276
00:12:27,190 --> 00:12:32,079
approach<font color="#CCCCCC"> for the MQTT protocol where we</font>

277
00:12:30,339 --> 00:12:36,010
wrote passes for individual<font color="#CCCCCC"> receive</font>

278
00:12:32,079 --> 00:12:37,719
<font color="#CCCCCC">states and we again saw that the CPU</font>

279
00:12:36,010 --> 00:12:39,310
time for each of<font color="#CCCCCC"> these messages was very</font>

280
00:12:37,720 --> 00:12:42,010
minimal<font color="#CCCCCC"> and the</font><font color="#E5E5E5"> number of lines of code</font>

281
00:12:39,310 --> 00:12:43,869
was way lesser<font color="#E5E5E5"> because the</font><font color="#CCCCCC"> MQTT protocol</font>

282
00:12:42,010 --> 00:12:48,399
is significantly simpler in comparison

283
00:12:43,870 --> 00:12:51,820
to the<font color="#E5E5E5"> XMPP protocol</font><font color="#CCCCCC"> ok</font><font color="#E5E5E5"> as I mentioned</font>

284
00:12:48,399 --> 00:12:53,920
<font color="#CCCCCC">earlier we wrote</font><font color="#E5E5E5"> unit tests for almost</font>

285
00:12:51,820 --> 00:12:56,589
each of our parser and we also wrote

286
00:12:53,920 --> 00:13:00,430
unit<font color="#E5E5E5"> tests for the protocol state</font>

287
00:12:56,589 --> 00:13:03,880
machine<font color="#CCCCCC"> and we saw that</font><font color="#E5E5E5"> we actually</font>

288
00:13:00,430 --> 00:13:06,310
covered almost<font color="#E5E5E5"> a we cover 100% of both</font>

289
00:13:03,880 --> 00:13:09,430
the protocol state machines for<font color="#E5E5E5"> XMPP +</font>

290
00:13:06,310 --> 00:13:11,890
mq<font color="#CCCCCC"> dt and in terms of</font><font color="#E5E5E5"> passive validation</font>

291
00:13:09,430 --> 00:13:15,370
we were slightly<font color="#CCCCCC"> behind but</font><font color="#E5E5E5"> I would</font>

292
00:13:11,890 --> 00:13:17,980
<font color="#CCCCCC">think that it's still pretty</font><font color="#E5E5E5"> good</font><font color="#CCCCCC"> ok</font><font color="#E5E5E5"> up</font>

293
00:13:15,370 --> 00:13:19,450
then what we did<font color="#E5E5E5"> was</font><font color="#CCCCCC"> that we started</font>

294
00:13:17,980 --> 00:13:21,730
<font color="#CCCCCC">building</font>

295
00:13:19,450 --> 00:13:24,190
simple<font color="#CCCCCC"> phaser</font><font color="#E5E5E5"> that would basically</font>

296
00:13:21,730 --> 00:13:27,340
generate messages<font color="#CCCCCC"> taking our parser</font>

297
00:13:24,190 --> 00:13:29,500
<font color="#CCCCCC">combinator</font><font color="#E5E5E5"> object as an input so since</font>

298
00:13:27,340 --> 00:13:32,620
we did it in Ruby<font color="#E5E5E5"> it</font><font color="#CCCCCC"> was a really</font>

299
00:13:29,500 --> 00:13:34,180
<font color="#E5E5E5">interesting task for us I think</font><font color="#CCCCCC"> the</font>

300
00:13:32,620 --> 00:13:38,170
<font color="#E5E5E5">developers of hammer have done a really</font>

301
00:13:34,180 --> 00:13:40,020
good job<font color="#CCCCCC"> in storing the objects and not</font>

302
00:13:38,170 --> 00:13:44,170
garbage collecting it

303
00:13:40,020 --> 00:13:46,510
<font color="#CCCCCC">so</font><font color="#E5E5E5"> our our phaser basically takes the</font>

304
00:13:44,170 --> 00:13:48,579
<font color="#CCCCCC">parser Combinator object as an input</font><font color="#E5E5E5"> and</font>

305
00:13:46,510 --> 00:13:50,830
builds a parse tree from the parser

306
00:13:48,580 --> 00:13:53,140
Combinator input and it traverses the

307
00:13:50,830 --> 00:13:55,450
<font color="#E5E5E5">path tree and generates all possible</font>

308
00:13:53,140 --> 00:13:59,410
image all possible<font color="#CCCCCC"> messages up to a</font>

309
00:13:55,450 --> 00:14:02,320
certain depth<font color="#E5E5E5"> and we then fed these</font>

310
00:13:59,410 --> 00:14:04,170
messages to our parser and<font color="#E5E5E5"> we look for</font>

311
00:14:02,320 --> 00:14:07,180
crashes we didn't<font color="#CCCCCC"> really</font><font color="#E5E5E5"> find any</font>

312
00:14:04,170 --> 00:14:09,010
<font color="#E5E5E5">because intuitively</font><font color="#CCCCCC"> all these</font><font color="#E5E5E5"> messages</font>

313
00:14:07,180 --> 00:14:12,670
are valid messages that were<font color="#E5E5E5"> generated</font>

314
00:14:09,010 --> 00:14:14,110
from<font color="#E5E5E5"> our path tree okay so the</font>

315
00:14:12,670 --> 00:14:16,300
limitations of this fuzzing approach

316
00:14:14,110 --> 00:14:18,430
that we took was<font color="#E5E5E5"> this that we were not</font>

317
00:14:16,300 --> 00:14:20,949
really<font color="#E5E5E5"> doing</font><font color="#CCCCCC"> much of mutation</font><font color="#E5E5E5"> and the</font>

318
00:14:18,430 --> 00:14:23,020
second<font color="#E5E5E5"> thing was that we were the</font>

319
00:14:20,950 --> 00:14:25,480
crashes that<font color="#CCCCCC"> happened we</font><font color="#E5E5E5"> aren't really</font>

320
00:14:23,020 --> 00:14:27,490
<font color="#E5E5E5">able to detect it automatically we have</font>

321
00:14:25,480 --> 00:14:29,260
to actually see through it<font color="#E5E5E5"> we have to</font>

322
00:14:27,490 --> 00:14:34,260
actually open<font color="#E5E5E5"> the log and see that it</font>

323
00:14:29,260 --> 00:14:36,370
crashed and this this particular

324
00:14:34,260 --> 00:14:39,640
<font color="#E5E5E5">approach of fuzzing actually could have</font>

325
00:14:36,370 --> 00:14:42,060
exposed<font color="#CCCCCC"> logical flaws in our</font><font color="#E5E5E5"> code but</font>

326
00:14:39,640 --> 00:14:46,270
then we didn't really detect any crashes

327
00:14:42,060 --> 00:14:47,609
on both of our passes<font color="#E5E5E5"> okay</font><font color="#CCCCCC"> so the</font>

328
00:14:46,270 --> 00:14:51,610
lessons<font color="#E5E5E5"> that we learned</font><font color="#CCCCCC"> from this</font>

329
00:14:47,610 --> 00:14:54,120
project<font color="#E5E5E5"> was this that parser</font><font color="#CCCCCC"> Combinator</font>

330
00:14:51,610 --> 00:14:58,630
toolkits make it actually<font color="#CCCCCC"> really easy</font><font color="#E5E5E5"> to</font>

331
00:14:54,120 --> 00:15:00,370
implement<font color="#E5E5E5"> grammar in code</font><font color="#CCCCCC"> and the tests</font>

332
00:14:58,630 --> 00:15:02,820
that<font color="#E5E5E5"> the implementation</font><font color="#CCCCCC"> that we</font>

333
00:15:00,370 --> 00:15:07,350
developed ran actually very really well

334
00:15:02,820 --> 00:15:10,810
on raspberry<font color="#E5E5E5"> PI's like it ran as good as</font>

335
00:15:07,350 --> 00:15:13,510
existing implementations publicly

336
00:15:10,810 --> 00:15:14,800
available<font color="#E5E5E5"> just that in some</font><font color="#CCCCCC"> cases</font>

337
00:15:13,510 --> 00:15:18,370
depending<font color="#E5E5E5"> on the</font><font color="#CCCCCC"> language it was</font>

338
00:15:14,800 --> 00:15:21,760
slightly<font color="#CCCCCC"> slower and IOT protocols seem</font>

339
00:15:18,370 --> 00:15:23,560
<font color="#E5E5E5">to have a lot of features and a lot</font><font color="#CCCCCC"> of</font>

340
00:15:21,760 --> 00:15:26,319
security<font color="#CCCCCC"> features and then half of them</font>

341
00:15:23,560 --> 00:15:28,959
seem to<font color="#E5E5E5"> not</font><font color="#CCCCCC"> be enforced by a lot of</font>

342
00:15:26,320 --> 00:15:31,210
implementations<font color="#E5E5E5"> and protocol</font>

343
00:15:28,960 --> 00:15:32,259
specifications in plain text<font color="#CCCCCC"> and in</font>

344
00:15:31,210 --> 00:15:33,669
hundreds of pages

345
00:15:32,259 --> 00:15:35,499
is just really really<font color="#E5E5E5"> hard for</font>

346
00:15:33,669 --> 00:15:39,160
<font color="#CCCCCC">developers to actually</font><font color="#E5E5E5"> read through and</font>

347
00:15:35,499 --> 00:15:43,389
understand so we feel that<font color="#E5E5E5"> it will be</font>

348
00:15:39,160 --> 00:15:45,459
really<font color="#CCCCCC"> good</font><font color="#E5E5E5"> for</font><font color="#CCCCCC"> developers if people who</font>

349
00:15:43,389 --> 00:15:48,009
write<font color="#CCCCCC"> these specifications including</font><font color="#E5E5E5"> us</font>

350
00:15:45,459 --> 00:15:51,160
should actually<font color="#E5E5E5"> include</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> protocol</font>

351
00:15:48,009 --> 00:15:52,720
state machine specifically and also<font color="#CCCCCC"> the</font>

352
00:15:51,160 --> 00:15:56,649
grammar<font color="#CCCCCC"> for each of the receiving States</font>

353
00:15:52,720 --> 00:15:58,839
<font color="#E5E5E5">and so yeah so lack the line check</font>

354
00:15:56,649 --> 00:16:00,309
approach doesn't<font color="#CCCCCC"> guarantee a success but</font>

355
00:15:58,839 --> 00:16:04,089
it does provide a very disciplined

356
00:16:00,309 --> 00:16:06,488
roadmap<font color="#E5E5E5"> and our next step</font><font color="#CCCCCC"> our next steps</font>

357
00:16:04,089 --> 00:16:09,669
for<font color="#CCCCCC"> this work is actually to use</font><font color="#E5E5E5"> formal</font>

358
00:16:06,489 --> 00:16:11,439
verification tools and to build a

359
00:16:09,669 --> 00:16:13,569
smarter faster than the preliminary

360
00:16:11,439 --> 00:16:16,539
<font color="#CCCCCC">facade that we have built</font><font color="#E5E5E5"> and also</font>

361
00:16:13,569 --> 00:16:22,259
diversify<font color="#E5E5E5"> and build more passes for more</font>

362
00:16:16,539 --> 00:16:22,259
protocols and that's about<font color="#E5E5E5"> it</font><font color="#CCCCCC"> thank you</font>

363
00:16:22,370 --> 00:16:27,330
[Applause]

364
00:16:28,949 --> 00:16:44,919
yes we did not really<font color="#E5E5E5"> compute the</font>

365
00:16:42,369 --> 00:16:46,569
overhead it was the total<font color="#E5E5E5"> time yeah and</font>

366
00:16:44,919 --> 00:16:47,859
we compared in the same way we actually

367
00:16:46,569 --> 00:16:55,089
<font color="#CCCCCC">compare the total time to other</font>

368
00:16:47,859 --> 00:16:57,879
implementations<font color="#E5E5E5"> yep yeah we didn't</font>

369
00:16:55,089 --> 00:17:06,389
specifically use any backends we just

370
00:16:57,879 --> 00:17:06,389
<font color="#E5E5E5">use</font><font color="#CCCCCC"> the bindings</font><font color="#E5E5E5"> and yeah no yes</font>

371
00:17:19,459 --> 00:17:24,319
so<font color="#E5E5E5"> almost every major company has its</font>

372
00:17:22,759 --> 00:17:27,529
<font color="#E5E5E5">own</font><font color="#CCCCCC"> implementation for these protocols</font>

373
00:17:24,319 --> 00:17:43,340
<font color="#CCCCCC">so there is no really one place</font><font color="#E5E5E5"> where</font><font color="#CCCCCC"> we</font>

374
00:17:27,529 --> 00:17:45,289
<font color="#CCCCCC">can actually push this technique yeah so</font>

375
00:17:43,340 --> 00:17:48,620
there has been<font color="#E5E5E5"> work in that direction in</font>

376
00:17:45,289 --> 00:17:51,289
the power grid<font color="#CCCCCC"> actually but not by this</font>

377
00:17:48,620 --> 00:17:53,750
group<font color="#E5E5E5"> specifically but there has been</font>

378
00:17:51,289 --> 00:18:35,658
<font color="#CCCCCC">work and we would definitely love to</font>

379
00:17:53,750 --> 00:18:37,429
look<font color="#E5E5E5"> into that yes yes yes that is</font><font color="#CCCCCC"> our</font>

380
00:18:35,659 --> 00:18:40,759
next<font color="#E5E5E5"> work as I mentioned we want to</font>

381
00:18:37,429 --> 00:18:43,639
<font color="#E5E5E5">build some</font><font color="#CCCCCC"> sort of a smart fuzzer</font><font color="#E5E5E5"> so so</font>

382
00:18:40,759 --> 00:18:47,389
the approach that<font color="#E5E5E5"> I've been looking into</font>

383
00:18:43,639 --> 00:18:49,908
is this<font color="#E5E5E5"> that I'm basically</font><font color="#CCCCCC"> trying to</font>

384
00:18:47,389 --> 00:18:53,469
<font color="#E5E5E5">feed this set of valid messages to a</font>

385
00:18:49,909 --> 00:18:56,240
smart officer like Lib<font color="#E5E5E5"> fuzzer actually</font>

386
00:18:53,470 --> 00:19:01,220
that can actually<font color="#E5E5E5"> or take</font><font color="#CCCCCC"> this set</font><font color="#E5E5E5"> of</font>

387
00:18:56,240 --> 00:19:04,370
<font color="#CCCCCC">messages as a corpus so the corpus</font><font color="#E5E5E5"> would</font>

388
00:19:01,220 --> 00:19:05,960
basically<font color="#E5E5E5"> so the loop buzzer would</font>

389
00:19:04,370 --> 00:19:08,449
basically<font color="#E5E5E5"> take</font><font color="#CCCCCC"> it as a</font><font color="#E5E5E5"> corpus and then</font>

390
00:19:05,960 --> 00:19:13,429
mutate these messages<font color="#E5E5E5"> and create</font>

391
00:19:08,450 --> 00:19:14,899
off-by-one errors<font color="#E5E5E5"> yes we would use the</font>

392
00:19:13,429 --> 00:19:19,669
<font color="#CCCCCC">Combinator's themselves to generate a</font>

393
00:19:14,899 --> 00:19:25,178
corpus<font color="#E5E5E5"> and feed not to generate illegal</font>

394
00:19:19,669 --> 00:19:25,179
messages<font color="#CCCCCC"> yes thank you</font>

395
00:19:27,450 --> 00:19:31,200
[Applause]

