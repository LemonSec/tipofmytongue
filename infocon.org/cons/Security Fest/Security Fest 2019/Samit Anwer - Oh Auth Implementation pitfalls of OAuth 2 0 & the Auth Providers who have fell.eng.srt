1
00:00:00,000 --> 00:00:04,080
kind of attacks can happen as a result

2
00:00:01,800 --> 00:00:07,620
of that and we'll also be covering the

3
00:00:04,080 --> 00:00:09,990
mitigations for them a brief

4
00:00:07,620 --> 00:00:11,759
introduction about myself my name is

5
00:00:09,990 --> 00:00:14,190
summit I work for the product security

6
00:00:11,759 --> 00:00:17,279
team at Citrix I'm a web and mobile

7
00:00:14,190 --> 00:00:19,109
application security enthusiast I've

8
00:00:17,279 --> 00:00:21,029
spoken at a bunch of conferences awfully

9
00:00:19,109 --> 00:00:24,930
it including Def Con China lack at Asia

10
00:00:21,029 --> 00:00:29,279
app sec USA good blue and some more in

11
00:00:24,930 --> 00:00:33,510
the past so for those who do not know

12
00:00:29,279 --> 00:00:35,430
what what is basically it's an open

13
00:00:33,510 --> 00:00:38,610
standard for token based authorization

14
00:00:35,430 --> 00:00:40,890
and basically as an end user you can

15
00:00:38,610 --> 00:00:42,870
authorize a third-party application to

16
00:00:40,890 --> 00:00:48,059
access the resources resources on your

17
00:00:42,870 --> 00:00:51,660
behalf we'll be covering why what came

18
00:00:48,059 --> 00:00:56,849
into being we'll also cover the flow in

19
00:00:51,660 --> 00:01:01,459
a nutshell and various terms that I'll

20
00:00:56,850 --> 00:01:04,409
be using across the presentation and

21
00:01:01,460 --> 00:01:06,180
obviously the grants that what provides

22
00:01:04,409 --> 00:01:07,560
there are four different grants we'll be

23
00:01:06,180 --> 00:01:09,350
covering two of them because those are

24
00:01:07,560 --> 00:01:14,280
more relevant for the current discourse

25
00:01:09,350 --> 00:01:16,350
and open ID Connect which is basically a

26
00:01:14,280 --> 00:01:17,250
by-product of worth and it is used for

27
00:01:16,350 --> 00:01:18,839
authentication

28
00:01:17,250 --> 00:01:23,670
whereas what is used for authorizing

29
00:01:18,840 --> 00:01:28,189
clients will be covering or these

30
00:01:23,670 --> 00:01:32,270
attacks and the mitigations for them and

31
00:01:28,189 --> 00:01:32,270
finally you have a short Q&A session

32
00:01:32,869 --> 00:01:37,770
some disclaimers ideas presented or

33
00:01:36,150 --> 00:01:39,869
personal are not speaking on behalf of

34
00:01:37,770 --> 00:01:41,789
my employer some content has been

35
00:01:39,869 --> 00:01:44,909
borrowed from Rand David Campbell slides

36
00:01:41,790 --> 00:01:49,920
on or 2.0 and mobile devices or zero and

37
00:01:44,909 --> 00:01:51,689
RFC documents on what humor is mine if

38
00:01:49,920 --> 00:01:55,649
you like it drop me a mail if you don't

39
00:01:51,689 --> 00:01:58,079
you can blame security first first all

40
00:01:55,649 --> 00:02:01,110
right I also have references to Avengers

41
00:01:58,079 --> 00:02:03,029
infinity war but no spoilers or for

42
00:02:01,110 --> 00:02:04,049
Avengers in game so if you haven't

43
00:02:03,030 --> 00:02:06,060
watched the end game you are still good

44
00:02:04,049 --> 00:02:11,459
but if you haven't watched the infinity

45
00:02:06,060 --> 00:02:12,770
war then you deserve the spoilers okay

46
00:02:11,459 --> 00:02:15,770
so why what

47
00:02:12,770 --> 00:02:19,550
so consider this scenario where Linden

48
00:02:15,770 --> 00:02:23,000
wants to access your contacts from Gmail

49
00:02:19,550 --> 00:02:26,000
and in order to do so it prompts you for

50
00:02:23,000 --> 00:02:27,830
your password on LinkedIn website now

51
00:02:26,000 --> 00:02:29,990
this clearly raises eyebrows and it's

52
00:02:27,830 --> 00:02:31,430
suspicious because LinkedIn you can't

53
00:02:29,990 --> 00:02:35,240
really give your credentials to a third

54
00:02:31,430 --> 00:02:37,550
party application so the problem here is

55
00:02:35,240 --> 00:02:39,500
that LinkedIn with your credentials can

56
00:02:37,550 --> 00:02:42,680
do far more than just access the

57
00:02:39,500 --> 00:02:45,380
contacts from Gmail there are other

58
00:02:42,680 --> 00:02:47,600
drawbacks as well LinkedIn would be

59
00:02:45,380 --> 00:02:50,750
required to store your credentials which

60
00:02:47,600 --> 00:02:53,269
is again a no-go Google will be required

61
00:02:50,750 --> 00:02:56,980
to save your credenza port

62
00:02:53,270 --> 00:03:00,560
password-based authentication and access

63
00:02:56,980 --> 00:03:02,510
cannot be revoked from one single

64
00:03:00,560 --> 00:03:04,250
third-party application without revoking

65
00:03:02,510 --> 00:03:06,140
it from all the third-party applications

66
00:03:04,250 --> 00:03:07,760
because the access is based on your

67
00:03:06,140 --> 00:03:12,410
password and if you change your password

68
00:03:07,760 --> 00:03:14,720
it gets teens for every third party so

69
00:03:12,410 --> 00:03:17,270
this is where what came in and it

70
00:03:14,720 --> 00:03:20,300
devises a mechanism for providing

71
00:03:17,270 --> 00:03:22,220
LinkedIn in our case to just access the

72
00:03:20,300 --> 00:03:28,250
contacts on behalf of the user

73
00:03:22,220 --> 00:03:30,080
from Gmail and nothing else so it's a

74
00:03:28,250 --> 00:03:32,870
protocol for delegating authorization

75
00:03:30,080 --> 00:03:36,950
supported by web mobile and native

76
00:03:32,870 --> 00:03:38,780
applications an access grant to a

77
00:03:36,950 --> 00:03:42,679
specific third-party application can be

78
00:03:38,780 --> 00:03:47,420
revoked and the scope of access or the

79
00:03:42,680 --> 00:03:49,040
permissions can be constrained it also

80
00:03:47,420 --> 00:03:51,920
avoids sharing of your credentials with

81
00:03:49,040 --> 00:03:55,070
the third party application and as I

82
00:03:51,920 --> 00:03:57,109
mentioned it is also it also sets a base

83
00:03:55,070 --> 00:04:01,280
for an authentication protocol called

84
00:03:57,110 --> 00:04:03,470
Open ID Connect so before we move on to

85
00:04:01,280 --> 00:04:04,820
the flow I would want to introduce the

86
00:04:03,470 --> 00:04:09,920
various entities that are typically

87
00:04:04,820 --> 00:04:11,900
involved in a lowered setup firstly the

88
00:04:09,920 --> 00:04:14,059
resource owner this is the guy who's

89
00:04:11,900 --> 00:04:16,160
going to grant access to the third party

90
00:04:14,060 --> 00:04:19,220
application to access the resources on

91
00:04:16,160 --> 00:04:23,600
its behalf this is generally the end

92
00:04:19,220 --> 00:04:25,910
user and finally this one is the

93
00:04:23,600 --> 00:04:27,500
application or the relying party or

94
00:04:25,910 --> 00:04:29,930
the client all these three terms are

95
00:04:27,500 --> 00:04:31,820
synonymous and this will be the

96
00:04:29,930 --> 00:04:34,160
application that is requesting access to

97
00:04:31,820 --> 00:04:38,659
the protected resources on behalf of the

98
00:04:34,160 --> 00:04:40,490
user then the resource server this is

99
00:04:38,660 --> 00:04:45,920
the server hosting the users resources

100
00:04:40,490 --> 00:04:47,780
which is Gmail in our case and the

101
00:04:45,920 --> 00:04:49,760
authorization server this is the server

102
00:04:47,780 --> 00:04:51,619
that authenticates the user and

103
00:04:49,760 --> 00:04:55,789
generates an access token when the user

104
00:04:51,620 --> 00:04:58,220
approves of the authorization this was

105
00:04:55,790 --> 00:05:01,010
Google in our case and finally the

106
00:04:58,220 --> 00:05:03,860
browser so all of these entities will be

107
00:05:01,010 --> 00:05:05,090
used on the next slide not not this one

108
00:05:03,860 --> 00:05:07,310
just on the next slide

109
00:05:05,090 --> 00:05:11,659
so this one is a mandatory step that is

110
00:05:07,310 --> 00:05:13,760
required for the authorization server to

111
00:05:11,660 --> 00:05:16,790
know who all are the clients that are

112
00:05:13,760 --> 00:05:19,340
going to request authorization so client

113
00:05:16,790 --> 00:05:23,600
registration needs to happen has a step

114
00:05:19,340 --> 00:05:24,799
before the earth exchange happens so in

115
00:05:23,600 --> 00:05:26,720
order to register your client

116
00:05:24,800 --> 00:05:29,810
application you provide your application

117
00:05:26,720 --> 00:05:31,700
name website logo and a redirect URI the

118
00:05:29,810 --> 00:05:34,190
redirect URI is used by the

119
00:05:31,700 --> 00:05:40,219
authorization server to redirect the

120
00:05:34,190 --> 00:05:42,350
auth code and the access token and after

121
00:05:40,220 --> 00:05:44,180
you register of all your eyes of the

122
00:05:42,350 --> 00:05:47,060
client you get a client ID and a client

123
00:05:44,180 --> 00:05:48,620
secret the client ID is not sensitive

124
00:05:47,060 --> 00:05:50,810
information it can be made public

125
00:05:48,620 --> 00:05:53,810
whereas the client secret has to be kept

126
00:05:50,810 --> 00:05:55,040
confidential and in case an application

127
00:05:53,810 --> 00:05:59,360
cannot keep the client secret

128
00:05:55,040 --> 00:06:01,370
confidential it should avoid using the

129
00:05:59,360 --> 00:06:02,660
client secret completely and this

130
00:06:01,370 --> 00:06:04,220
happens in case of single page

131
00:06:02,660 --> 00:06:07,010
applications or native applications

132
00:06:04,220 --> 00:06:08,930
because the applications can be reverse

133
00:06:07,010 --> 00:06:14,719
engineered and the client secret can be

134
00:06:08,930 --> 00:06:18,140
extracted from them okay so the resource

135
00:06:14,720 --> 00:06:20,780
server or is there and the relying party

136
00:06:18,140 --> 00:06:23,360
or the client is stack exchange in this

137
00:06:20,780 --> 00:06:27,260
case and we also have Google as our

138
00:06:23,360 --> 00:06:29,630
authorization server so when the client

139
00:06:27,260 --> 00:06:30,980
needs to request authorization or the

140
00:06:29,630 --> 00:06:32,870
relying party needs to request

141
00:06:30,980 --> 00:06:34,550
authorization it will show it shows a

142
00:06:32,870 --> 00:06:36,289
prompt saying sign in with Google or

143
00:06:34,550 --> 00:06:39,110
sign in with Facebook let's say you

144
00:06:36,289 --> 00:06:39,810
chose Google the client will generate an

145
00:06:39,110 --> 00:06:42,600
authorization

146
00:06:39,810 --> 00:06:44,880
request and the browser will use reader

147
00:06:42,600 --> 00:06:46,950
get redirected to Google's authorization

148
00:06:44,880 --> 00:06:49,110
page which is where the user will enter

149
00:06:46,950 --> 00:06:51,659
his credentials approved of the

150
00:06:49,110 --> 00:06:54,720
authorization and that is when the auth

151
00:06:51,660 --> 00:06:58,500
code gets generated and sent back to the

152
00:06:54,720 --> 00:07:01,340
redirect URI and the redirect URI is

153
00:06:58,500 --> 00:07:06,510
obviously Stack Exchange is redirect URI

154
00:07:01,340 --> 00:07:08,669
on on fetching the auth code the relying

155
00:07:06,510 --> 00:07:10,680
party exchanges this auth code for an

156
00:07:08,669 --> 00:07:13,070
access token by hitting the

157
00:07:10,680 --> 00:07:16,410
authorization servers token endpoint and

158
00:07:13,070 --> 00:07:17,940
once it receives the access token it can

159
00:07:16,410 --> 00:07:22,650
fetch the resources on behalf of the

160
00:07:17,940 --> 00:07:25,740
user so that covers like the OAuth flow

161
00:07:22,650 --> 00:07:29,820
in a nutshell we'll be talking about in

162
00:07:25,740 --> 00:07:31,260
more detail as we move it so the only

163
00:07:29,820 --> 00:07:34,229
difference between what an open ID

164
00:07:31,260 --> 00:07:38,880
Connect is that what is for authorizing

165
00:07:34,229 --> 00:07:41,430
or sharing resources and open ID Connect

166
00:07:38,880 --> 00:07:43,110
is meant for authenticating the user so

167
00:07:41,430 --> 00:07:45,510
the access tokens are consumed by the

168
00:07:43,110 --> 00:07:48,960
resource server because they prove

169
00:07:45,510 --> 00:07:51,630
authorization to the resources and the

170
00:07:48,960 --> 00:07:54,630
identity token is consumed by the client

171
00:07:51,630 --> 00:07:59,520
in order to populate the UI stating that

172
00:07:54,630 --> 00:08:01,469
this is the user who's authenticated so

173
00:07:59,520 --> 00:08:03,060
the flow entirely remains the same the

174
00:08:01,470 --> 00:08:04,979
only difference comes in to the last

175
00:08:03,060 --> 00:08:07,919
step where you get an access token and

176
00:08:04,979 --> 00:08:10,770
in addition to an access token you also

177
00:08:07,919 --> 00:08:12,090
get the identity token now this identity

178
00:08:10,770 --> 00:08:13,680
token is consumed by the relying party

179
00:08:12,090 --> 00:08:22,380
and it is not sent to the resource

180
00:08:13,680 --> 00:08:25,200
server access tokens are generally

181
00:08:22,380 --> 00:08:28,289
opaque and they are also called bearer

182
00:08:25,200 --> 00:08:29,849
tokens so when I say opaque it means

183
00:08:28,289 --> 00:08:31,260
that they don't have a structure to them

184
00:08:29,850 --> 00:08:32,570
if you try and decode them it will not

185
00:08:31,260 --> 00:08:35,039
make any sense

186
00:08:32,570 --> 00:08:36,779
it just informs the API that you're

187
00:08:35,039 --> 00:08:40,490
hitting that the bearer of this token

188
00:08:36,779 --> 00:08:43,588
has been granted access to this API

189
00:08:40,490 --> 00:08:45,750
whereas identity tokens are jour tokens

190
00:08:43,589 --> 00:08:48,360
and they have a structure to them if you

191
00:08:45,750 --> 00:08:51,530
decode them they will comprise of claims

192
00:08:48,360 --> 00:08:53,770
so you the claims are nothing but

193
00:08:51,530 --> 00:09:01,180
statements

194
00:08:53,770 --> 00:09:03,640
stating the identity of the user and as

195
00:09:01,180 --> 00:09:05,349
I mentioned before or the jaw tokens or

196
00:09:03,640 --> 00:09:12,880
the identity tokens will be consumed by

197
00:09:05,350 --> 00:09:14,560
the client application dots are

198
00:09:12,880 --> 00:09:16,240
self-contained there's some more

199
00:09:14,560 --> 00:09:18,010
information in jorts on this slide so

200
00:09:16,240 --> 00:09:21,270
jorts are self-contained which means

201
00:09:18,010 --> 00:09:24,010
that you can verify the authenticity and

202
00:09:21,270 --> 00:09:26,230
integrity of the job that is coming to

203
00:09:24,010 --> 00:09:29,620
you without ref referring to another

204
00:09:26,230 --> 00:09:31,450
third-party the reason for that is that

205
00:09:29,620 --> 00:09:32,920
jorts are signed so you can actually

206
00:09:31,450 --> 00:09:37,660
verify the signature and validate

207
00:09:32,920 --> 00:09:39,400
whether their integrity is intact the

208
00:09:37,660 --> 00:09:41,740
comprised of three components one of

209
00:09:39,400 --> 00:09:43,689
them is the header then the payload and

210
00:09:41,740 --> 00:09:47,320
the signature the header portion

211
00:09:43,690 --> 00:09:49,800
comprises of mainly the algorithm used

212
00:09:47,320 --> 00:09:53,230
for hashing the payload the payload and

213
00:09:49,800 --> 00:09:54,880
what kind of token it is the payload

214
00:09:53,230 --> 00:09:57,970
contains these claims which we saw in

215
00:09:54,880 --> 00:10:00,460
the previous slide and the signature

216
00:09:57,970 --> 00:10:08,080
path just mentions the hash of the

217
00:10:00,460 --> 00:10:11,200
payload and header all right

218
00:10:08,080 --> 00:10:15,330
so in the authorization request that the

219
00:10:11,200 --> 00:10:18,640
client makes to the authorization server

220
00:10:15,330 --> 00:10:20,380
the client embeds some scopes which is

221
00:10:18,640 --> 00:10:23,380
basically permission that it is

222
00:10:20,380 --> 00:10:25,420
requesting this may be like it might

223
00:10:23,380 --> 00:10:26,980
request the email of the user or the

224
00:10:25,420 --> 00:10:29,020
profile of the user so some data

225
00:10:26,980 --> 00:10:32,860
regarding the user and once the user

226
00:10:29,020 --> 00:10:35,470
approves of these scopes in the identity

227
00:10:32,860 --> 00:10:39,030
token that is generated these claims are

228
00:10:35,470 --> 00:10:39,030
embedded by the authorization server

229
00:10:39,780 --> 00:10:44,709
these claims are also available at the

230
00:10:42,640 --> 00:10:46,900
user info endpoint on the authorization

231
00:10:44,710 --> 00:10:51,280
server so the client can actually

232
00:10:46,900 --> 00:10:53,829
request for them and scopes allow

233
00:10:51,280 --> 00:10:55,750
applications to request delegated access

234
00:10:53,830 --> 00:10:58,510
so basically if you have a scope saying

235
00:10:55,750 --> 00:11:01,980
mail dot read the application is

236
00:10:58,510 --> 00:11:06,700
requesting read access to your mails and

237
00:11:01,980 --> 00:11:09,860
the authorization decision basically is

238
00:11:06,700 --> 00:11:12,769
made by combining three entities which

239
00:11:09,860 --> 00:11:15,769
is the male the permission that you're

240
00:11:12,769 --> 00:11:19,220
granting who's the user for which the

241
00:11:15,769 --> 00:11:20,600
male belongs and the entity that is

242
00:11:19,220 --> 00:11:22,339
requested which is the male in our case

243
00:11:20,600 --> 00:11:24,860
so if you have mailed or treat'

244
00:11:22,339 --> 00:11:28,490
permission the only the males of user

245
00:11:24,860 --> 00:11:30,440
who is the red one will be access and if

246
00:11:28,490 --> 00:11:32,120
there is some other users mail they will

247
00:11:30,440 --> 00:11:41,000
not be accessible to this particular

248
00:11:32,120 --> 00:11:44,510
client coming on to the various ground

249
00:11:41,000 --> 00:11:46,279
types there are four of them one is the

250
00:11:44,510 --> 00:11:48,500
authorization code grant an otherwise

251
00:11:46,279 --> 00:11:50,089
the implicit grant resource on a

252
00:11:48,500 --> 00:11:52,279
password credential grant and Klan

253
00:11:50,089 --> 00:11:54,800
credential grant all of these are used

254
00:11:52,279 --> 00:12:00,019
in different situations or scenarios I

255
00:11:54,800 --> 00:12:01,880
will be covering the first two but

256
00:12:00,019 --> 00:12:04,670
before we start with them I'm

257
00:12:01,880 --> 00:12:08,149
introducing the real actors small

258
00:12:04,670 --> 00:12:12,410
analogy a resource server will be the

259
00:12:08,149 --> 00:12:15,199
soulstone and obviously a Red Skull

260
00:12:12,410 --> 00:12:18,350
right now possesses that sole store so

261
00:12:15,199 --> 00:12:20,930
he is the resource owner and Thanos

262
00:12:18,350 --> 00:12:26,060
wants it and this is the application

263
00:12:20,930 --> 00:12:27,829
relying party or the clan and Gomorrha

264
00:12:26,060 --> 00:12:33,829
will be at authorizing authorization

265
00:12:27,829 --> 00:12:35,269
server so tano's tries to access the

266
00:12:33,829 --> 00:12:40,219
source indirectly and he gets an

267
00:12:35,269 --> 00:12:43,449
unauthorized response and it asked the

268
00:12:40,220 --> 00:12:45,890
resource owner for giving him approval

269
00:12:43,449 --> 00:12:48,859
by redirecting it to authorization

270
00:12:45,890 --> 00:12:50,510
server so you get redirected to the

271
00:12:48,860 --> 00:12:54,050
authorized endpoint on the authorization

272
00:12:50,510 --> 00:12:56,420
server and the user then approves of the

273
00:12:54,050 --> 00:12:58,699
authorization and that is when you get

274
00:12:56,420 --> 00:13:02,420
the auth code back redirected to the

275
00:12:58,699 --> 00:13:05,899
application so Tanis has been authorized

276
00:13:02,420 --> 00:13:07,640
to access the resource server now but

277
00:13:05,899 --> 00:13:09,709
there's one additional step in the auth

278
00:13:07,640 --> 00:13:12,019
code ground flow which requires you to

279
00:13:09,709 --> 00:13:15,380
exchange the auth code grant auth code

280
00:13:12,019 --> 00:13:17,329
for an access token and for this the

281
00:13:15,380 --> 00:13:19,670
client needs to authenticate to the

282
00:13:17,329 --> 00:13:24,530
authorization server by using the cly

283
00:13:19,670 --> 00:13:26,300
secret and the client ID so that's where

284
00:13:24,530 --> 00:13:29,510
the client ID and client secret come in

285
00:13:26,300 --> 00:13:31,939
handy and once you hit the token

286
00:13:29,510 --> 00:13:34,100
endpoint with the client secrets the

287
00:13:31,940 --> 00:13:37,630
client this token is generated by the

288
00:13:34,100 --> 00:13:40,820
auth server and returned to the client

289
00:13:37,630 --> 00:13:42,350
the client can then access the resources

290
00:13:40,820 --> 00:13:46,070
with the help of the token embedded in

291
00:13:42,350 --> 00:13:55,160
the header so tano's finally gets the

292
00:13:46,070 --> 00:13:57,050
soulstone he's happy so what are the

293
00:13:55,160 --> 00:13:58,550
benefits of the auth code step you could

294
00:13:57,050 --> 00:14:00,740
have directly returned an access token

295
00:13:58,550 --> 00:14:02,390
from the author but the auth code

296
00:14:00,740 --> 00:14:04,130
actually helps you to provide the

297
00:14:02,390 --> 00:14:05,960
ability to authenticate the client so

298
00:14:04,130 --> 00:14:08,540
even if the auth code gets leaked it

299
00:14:05,960 --> 00:14:10,280
cannot be exchanged for an access token

300
00:14:08,540 --> 00:14:12,740
by an attacker the attacker needs to

301
00:14:10,280 --> 00:14:14,630
know client secret and that is when can

302
00:14:12,740 --> 00:14:19,280
exchange the auth code for an access

303
00:14:14,630 --> 00:14:22,580
token additionally auth code gets

304
00:14:19,280 --> 00:14:25,339
exposed to the browser in the URL when

305
00:14:22,580 --> 00:14:27,800
the redirection happens but access token

306
00:14:25,340 --> 00:14:29,690
is returned in the response body by a

307
00:14:27,800 --> 00:14:33,319
server to server call from the odd

308
00:14:29,690 --> 00:14:36,050
server to the client so therefore it

309
00:14:33,320 --> 00:14:42,680
avoids the leak of access token via the

310
00:14:36,050 --> 00:14:44,300
browser Earth quadrants are frequently

311
00:14:42,680 --> 00:14:46,250
used for web applications so that's

312
00:14:44,300 --> 00:14:48,079
their use case and if you see the

313
00:14:46,250 --> 00:14:49,640
traffic it would look something like

314
00:14:48,080 --> 00:14:52,940
this yeah this is the authorization

315
00:14:49,640 --> 00:14:54,380
request and it comprises of the

316
00:14:52,940 --> 00:14:56,360
authorizes servers fqdn

317
00:14:54,380 --> 00:14:57,980
followed by the authorized endpoint and

318
00:14:56,360 --> 00:15:00,470
then the restore response type which is

319
00:14:57,980 --> 00:15:03,530
set as code for a cg which is

320
00:15:00,470 --> 00:15:07,010
authorization code grant and then the

321
00:15:03,530 --> 00:15:08,720
client ID and the redirect URI where the

322
00:15:07,010 --> 00:15:11,390
authorization server will redirect the

323
00:15:08,720 --> 00:15:14,290
auth code and in the response the auth

324
00:15:11,390 --> 00:15:16,880
code is being redirected to the client

325
00:15:14,290 --> 00:15:20,890
with a state parameter which is used to

326
00:15:16,880 --> 00:15:20,890
avoid CSRF attacks we'll come to that

327
00:15:21,130 --> 00:15:26,900
and when you hit the token endpoint with

328
00:15:24,440 --> 00:15:29,810
this auth code you're also supposed to

329
00:15:26,900 --> 00:15:32,000
specify the client secret so this is the

330
00:15:29,810 --> 00:15:33,378
client making the request it can send

331
00:15:32,000 --> 00:15:35,989
its client secret

332
00:15:33,379 --> 00:15:39,439
the auth code and that's when the access

333
00:15:35,989 --> 00:15:47,599
token is returned and has returned to

334
00:15:39,439 --> 00:15:50,299
the redirect URI again all right the

335
00:15:47,599 --> 00:15:51,019
second of them implicit grant pretty

336
00:15:50,299 --> 00:15:54,589
much alike

337
00:15:51,019 --> 00:15:58,429
orthe quadrant but with the difference

338
00:15:54,589 --> 00:16:01,789
that the auth code is not generated that

339
00:15:58,429 --> 00:16:03,769
is not sent back to the client but

340
00:16:01,789 --> 00:16:06,609
instead our token is directly generated

341
00:16:03,769 --> 00:16:06,609
and sent back to the client

342
00:16:09,159 --> 00:16:19,159
tarah still gets the resource so he's

343
00:16:11,689 --> 00:16:20,179
happy so if you see the traffic it would

344
00:16:19,159 --> 00:16:23,209
look something like this

345
00:16:20,179 --> 00:16:25,459
there you have the authorized endpoint

346
00:16:23,209 --> 00:16:27,498
being hit again with the same parameters

347
00:16:25,459 --> 00:16:31,219
and then you get back an access token

348
00:16:27,499 --> 00:16:33,379
directly so implicit grant was earlier

349
00:16:31,220 --> 00:16:35,329
used for single page applications and

350
00:16:33,379 --> 00:16:39,679
mobile applications or native

351
00:16:35,329 --> 00:16:41,689
applications but off late everybody is

352
00:16:39,679 --> 00:16:44,689
recommended to use earth quadrant

353
00:16:41,689 --> 00:16:48,429
without the client secret for native

354
00:16:44,689 --> 00:16:52,069
applications so this slide summarizes

355
00:16:48,429 --> 00:16:53,929
which grant to use in what scenarios so

356
00:16:52,069 --> 00:16:55,579
as I mentioned implicit grant was used

357
00:16:53,929 --> 00:16:57,409
for single space applications earlier

358
00:16:55,579 --> 00:17:00,349
even for native applications but

359
00:16:57,409 --> 00:17:02,809
nowadays we are using a CG with an

360
00:17:00,350 --> 00:17:05,120
additional layer of defense in depth

361
00:17:02,809 --> 00:17:07,549
called pixie which is proof key for code

362
00:17:05,119 --> 00:17:11,599
exchange and we come to that will cover

363
00:17:07,549 --> 00:17:14,689
pixie as well in the slides the rest of

364
00:17:11,599 --> 00:17:16,579
the to grant types are used in these

365
00:17:14,689 --> 00:17:22,399
cases which will not cover right now

366
00:17:16,579 --> 00:17:26,628
because we have shortage of time so next

367
00:17:22,398 --> 00:17:29,840
up is why DC open I reconnect in context

368
00:17:26,628 --> 00:17:31,908
of native applications over all the

369
00:17:29,840 --> 00:17:33,889
steps remain the same the only nuance

370
00:17:31,909 --> 00:17:35,570
that comes into play is when the auth

371
00:17:33,889 --> 00:17:37,729
code needs to be redirected to the

372
00:17:35,570 --> 00:17:39,320
native application and since the native

373
00:17:37,730 --> 00:17:42,259
application is running on the mobile

374
00:17:39,320 --> 00:17:43,759
device there is another attack surface

375
00:17:42,259 --> 00:17:46,610
that gets exposed because it's not a

376
00:17:43,759 --> 00:17:51,299
server to so call it's like more of

377
00:17:46,610 --> 00:17:56,250
untrusted device where the auth code has

378
00:17:51,299 --> 00:17:59,610
more chances of getting leaked so first

379
00:17:56,250 --> 00:18:01,399
step users need to access some protected

380
00:17:59,610 --> 00:18:03,389
resource or the client opens the browser

381
00:18:01,399 --> 00:18:09,600
redirects the user to the authorized

382
00:18:03,389 --> 00:18:13,080
endpoint and once the user signs in the

383
00:18:09,600 --> 00:18:16,408
user is asked to approve off the

384
00:18:13,080 --> 00:18:19,080
requests made by the client and once the

385
00:18:16,409 --> 00:18:21,539
user approves the authorization endpoint

386
00:18:19,080 --> 00:18:24,870
generates an auth code it needs to send

387
00:18:21,539 --> 00:18:28,110
it back do the native application and

388
00:18:24,870 --> 00:18:29,820
for that the browser has to do an HTTP

389
00:18:28,110 --> 00:18:32,240
redirection to invoke the native

390
00:18:29,820 --> 00:18:34,080
application with the auth code and

391
00:18:32,240 --> 00:18:38,370
that's where you have to register

392
00:18:34,080 --> 00:18:40,949
callbacks and if you see here the

393
00:18:38,370 --> 00:18:41,729
application has registered a custom URL

394
00:18:40,950 --> 00:18:45,990
scheme

395
00:18:41,730 --> 00:18:47,940
XCOM dot microbe dot my app and when the

396
00:18:45,990 --> 00:18:50,100
browser receives the auth code on this

397
00:18:47,940 --> 00:18:51,750
scheme it knows which I have to invoke

398
00:18:50,100 --> 00:18:55,889
because the application has registered

399
00:18:51,750 --> 00:18:59,820
for this custom URL scheme and that's

400
00:18:55,889 --> 00:19:01,740
done this way so if for Android in the

401
00:18:59,820 --> 00:19:05,879
manifest file you can define the URI

402
00:19:01,740 --> 00:19:07,740
scheme and whenever the browser receives

403
00:19:05,879 --> 00:19:09,509
this custom URL scheme it will redirect

404
00:19:07,740 --> 00:19:14,639
it to the native application which has

405
00:19:09,509 --> 00:19:17,340
registered for this scheme once the

406
00:19:14,639 --> 00:19:19,408
application receives the auth code it

407
00:19:17,340 --> 00:19:24,830
can exchange it with the token endpoint

408
00:19:19,409 --> 00:19:29,549
and it will get back the bearer token

409
00:19:24,830 --> 00:19:31,980
with the Refresh token as well and then

410
00:19:29,549 --> 00:19:34,200
the application can use this bearer

411
00:19:31,980 --> 00:19:42,539
token to access the resource which is

412
00:19:34,200 --> 00:19:45,000
the API here by embedding this is done

413
00:19:42,539 --> 00:19:47,340
by by emailing the bearer token as an

414
00:19:45,000 --> 00:19:49,259
authorization header so if you see here

415
00:19:47,340 --> 00:19:54,029
this is the authorization header with

416
00:19:49,259 --> 00:19:55,889
the bearer token embedded so that brings

417
00:19:54,029 --> 00:19:58,400
us to a first attack scenario called

418
00:19:55,889 --> 00:20:01,429
authorization code intercept attack

419
00:19:58,400 --> 00:20:04,130
and the preconditions for this attack is

420
00:20:01,430 --> 00:20:08,059
that the authorization code grant is

421
00:20:04,130 --> 00:20:10,309
used and in native applications the

422
00:20:08,059 --> 00:20:12,170
client secret is not used because native

423
00:20:10,309 --> 00:20:16,879
applications can be reversed and you can

424
00:20:12,170 --> 00:20:20,540
get the client secret and the attacker

425
00:20:16,880 --> 00:20:23,210
manages to register a custom URL scheme

426
00:20:20,540 --> 00:20:28,790
by using a malicious application on the

427
00:20:23,210 --> 00:20:30,140
same device so this custom URL scheme it

428
00:20:28,790 --> 00:20:32,090
was supposed to be used by the

429
00:20:30,140 --> 00:20:35,000
legitimate application and the attacker

430
00:20:32,090 --> 00:20:37,790
has registered for that callback with

431
00:20:35,000 --> 00:20:39,830
his malicious application so you can see

432
00:20:37,790 --> 00:20:42,170
where this is going because once the

433
00:20:39,830 --> 00:20:46,520
authorization code is returned in step

434
00:20:42,170 --> 00:20:49,580
number three the browser will because of

435
00:20:46,520 --> 00:20:51,350
the HTTP redirection will try to invoke

436
00:20:49,580 --> 00:20:52,970
the legitimate application with that

437
00:20:51,350 --> 00:20:54,678
auth code but since the malicious

438
00:20:52,970 --> 00:20:57,980
application has also registered for that

439
00:20:54,679 --> 00:21:00,110
custom URI scheme the attacker gets the

440
00:20:57,980 --> 00:21:03,320
auth code using his malicious

441
00:21:00,110 --> 00:21:05,449
application and once this auth code

442
00:21:03,320 --> 00:21:07,580
reaches the malicious application the

443
00:21:05,450 --> 00:21:08,990
attacker can redeem this auth code for

444
00:21:07,580 --> 00:21:17,500
an access token by hitting the

445
00:21:08,990 --> 00:21:20,120
authorization service token endpoint and

446
00:21:17,500 --> 00:21:22,840
obviously it becomes that most important

447
00:21:20,120 --> 00:21:25,780
to handle these redirections carefully

448
00:21:22,840 --> 00:21:29,899
instead of using custom URL schemes

449
00:21:25,780 --> 00:21:32,720
which is this there is no naming

450
00:21:29,900 --> 00:21:34,490
Authority for them so basically anybody

451
00:21:32,720 --> 00:21:36,650
any malicious application can register

452
00:21:34,490 --> 00:21:39,410
for the same custom URL scheme as the

453
00:21:36,650 --> 00:21:41,660
legitimate application so instead one

454
00:21:39,410 --> 00:21:46,630
should use claimed HTTP scheme URI

455
00:21:41,660 --> 00:21:48,620
direction so the scheme remains HTTPS

456
00:21:46,630 --> 00:21:52,780
followed by the fqdn

457
00:21:48,620 --> 00:21:57,169
under the control of the application and

458
00:21:52,780 --> 00:22:01,160
this is where the identity of the

459
00:21:57,170 --> 00:22:04,340
destination application is guaranteed to

460
00:22:01,160 --> 00:22:07,580
the authorization server by the

461
00:22:04,340 --> 00:22:09,350
operating system no other application

462
00:22:07,580 --> 00:22:11,600
can register for the same fqdn

463
00:22:09,350 --> 00:22:14,050
because it is owned by one particular

464
00:22:11,600 --> 00:22:14,050
client

465
00:22:16,220 --> 00:22:21,900
which brings us to peak peak AC which is

466
00:22:18,929 --> 00:22:28,980
pronounced as pixie and it's called

467
00:22:21,900 --> 00:22:33,150
proof key for code exchange so pixie

468
00:22:28,980 --> 00:22:35,970
adds some elements to the regular earth

469
00:22:33,150 --> 00:22:37,770
Code round flow to ensure that even if

470
00:22:35,970 --> 00:22:40,590
your authorization code gets leaked an

471
00:22:37,770 --> 00:22:46,320
attacker cannot exchange it for an

472
00:22:40,590 --> 00:22:50,399
access token so in addition to the in

473
00:22:46,320 --> 00:22:52,350
the authorization request what the

474
00:22:50,400 --> 00:22:54,360
client does is that it generates a code

475
00:22:52,350 --> 00:22:56,580
verifier which is nothing but an

476
00:22:54,360 --> 00:22:58,800
alphanumeric string kept confidential

477
00:22:56,580 --> 00:23:01,500
with that particular application which

478
00:22:58,800 --> 00:23:04,169
is generating it and it generally takes

479
00:23:01,500 --> 00:23:07,470
the hash of it which is called the code

480
00:23:04,170 --> 00:23:10,350
challenge which is symbolized by T

481
00:23:07,470 --> 00:23:12,330
followed by whatever code verify it is

482
00:23:10,350 --> 00:23:14,879
applied on so that's the hash value of

483
00:23:12,330 --> 00:23:17,580
code verified and then you're supposed

484
00:23:14,880 --> 00:23:19,380
to send the code challenge method which

485
00:23:17,580 --> 00:23:23,100
is the hash function you've used over

486
00:23:19,380 --> 00:23:25,020
the code verifier so basically you're

487
00:23:23,100 --> 00:23:27,809
sending the hash value here the

488
00:23:25,020 --> 00:23:33,900
authorization endpoint stores that

489
00:23:27,809 --> 00:23:37,620
hashed value with it and then it even

490
00:23:33,900 --> 00:23:39,720
redirects the browser to the client with

491
00:23:37,620 --> 00:23:41,729
the auth code and this can be

492
00:23:39,720 --> 00:23:43,800
intercepted by the malicious client so

493
00:23:41,730 --> 00:23:51,900
the malicious client is having the auth

494
00:23:43,800 --> 00:23:53,760
code now so in request number C where

495
00:23:51,900 --> 00:23:57,360
you have to exchange the code for the

496
00:23:53,760 --> 00:24:00,270
token the legitimate client needs to

497
00:23:57,360 --> 00:24:02,129
send the code verifier which is the

498
00:24:00,270 --> 00:24:05,940
unhoused value the message that is has

499
00:24:02,130 --> 00:24:07,500
digest or just which is hashed so the

500
00:24:05,940 --> 00:24:10,410
code verifier is not known to the

501
00:24:07,500 --> 00:24:13,559
malicious application and that's what

502
00:24:10,410 --> 00:24:15,000
provides the security here basically the

503
00:24:13,559 --> 00:24:17,129
token endpoint will receive this code

504
00:24:15,000 --> 00:24:20,160
verifier hash it again using the same

505
00:24:17,130 --> 00:24:21,780
code challenge method and then verify

506
00:24:20,160 --> 00:24:24,330
whether the value matches the code

507
00:24:21,780 --> 00:24:27,730
challenge which was received earlier in

508
00:24:24,330 --> 00:24:30,010
request B and if it does only then the

509
00:24:27,730 --> 00:24:38,110
access token is sent back otherwise it's

510
00:24:30,010 --> 00:24:40,900
not so this is a small and sweet demo or

511
00:24:38,110 --> 00:24:50,949
faulty pixie implementation on Microsoft

512
00:24:40,900 --> 00:24:55,059
IDP and it goes so if you notice here I

513
00:24:50,950 --> 00:24:56,559
have these last three requests one of

514
00:24:55,059 --> 00:24:58,780
them is going to the authorized end

515
00:24:56,559 --> 00:25:00,460
point the other one is going to the

516
00:24:58,780 --> 00:25:03,610
login end point and the third one is

517
00:25:00,460 --> 00:25:05,169
going to the token end point so the

518
00:25:03,610 --> 00:25:08,490
request that goes to the authorized end

519
00:25:05,169 --> 00:25:08,490
point has the redirect URI

520
00:25:21,880 --> 00:25:28,060
yep so if you notice here or there's the

521
00:25:26,230 --> 00:25:30,940
redirect URI of the native application

522
00:25:28,060 --> 00:25:32,710
and then the code challenge which is the

523
00:25:30,940 --> 00:25:34,120
highest value of the code verified and

524
00:25:32,710 --> 00:25:46,210
then followed by the code challenge

525
00:25:34,120 --> 00:25:48,699
method then I'm redirected back to the

526
00:25:46,210 --> 00:25:51,970
login page and I send my credentials and

527
00:25:48,700 --> 00:25:54,220
then the server when it receives that

528
00:25:51,970 --> 00:25:57,940
login request it generates an auth code

529
00:25:54,220 --> 00:26:02,080
for me and redirects the auth code to

530
00:25:57,940 --> 00:26:04,690
the native application which is

531
00:26:02,080 --> 00:26:05,949
happening here so you're getting

532
00:26:04,690 --> 00:26:11,910
redirected back to the native

533
00:26:05,950 --> 00:26:14,350
application with the auth code and

534
00:26:11,910 --> 00:26:17,050
finally the native application when it

535
00:26:14,350 --> 00:26:23,469
receives the auth code it hits the token

536
00:26:17,050 --> 00:26:29,070
endpoint with the code verifier and the

537
00:26:23,470 --> 00:26:29,070
redirect URI and the auth code

538
00:26:36,030 --> 00:26:41,760
so just sending it to the repeater

539
00:26:38,310 --> 00:26:44,129
trying it out and since it has the auth

540
00:26:41,760 --> 00:26:46,260
code and the code very fair value I get

541
00:26:44,130 --> 00:26:49,560
back the identity token access token and

542
00:26:46,260 --> 00:26:52,080
refresh tokens in the response but the

543
00:26:49,560 --> 00:26:54,240
problem with Microsoft's IDP was that it

544
00:26:52,080 --> 00:26:57,060
wasn't validating the code verifier here

545
00:26:54,240 --> 00:27:00,780
so even if you remove the code verifier

546
00:26:57,060 --> 00:27:02,940
completely you still get back the valid

547
00:27:00,780 --> 00:27:05,370
access token identity tokens and refresh

548
00:27:02,940 --> 00:27:07,860
tokens and since there is no client

549
00:27:05,370 --> 00:27:09,929
secret involved if your auth code gets

550
00:27:07,860 --> 00:27:13,620
leaked through the same attack that we

551
00:27:09,930 --> 00:27:15,480
saw earlier this can result in a

552
00:27:13,620 --> 00:27:24,629
malicious application redeeming your

553
00:27:15,480 --> 00:27:28,100
auth code for access tokens so the RFC

554
00:27:24,630 --> 00:27:31,320
unpick C actually mandates that all

555
00:27:28,100 --> 00:27:33,840
native applications must implement pixie

556
00:27:31,320 --> 00:27:35,700
and all the authorization servers must

557
00:27:33,840 --> 00:27:39,090
support pixie in order for the

558
00:27:35,700 --> 00:27:40,830
applications to use it but Microsoft

559
00:27:39,090 --> 00:27:43,679
clearly wasn't validating the code

560
00:27:40,830 --> 00:27:46,050
verifier which resulted in a in many

561
00:27:43,680 --> 00:27:48,240
native applications are being

562
00:27:46,050 --> 00:27:49,860
compromised which were using the same

563
00:27:48,240 --> 00:27:56,370
endpoints login dot Microsoft online

564
00:27:49,860 --> 00:27:58,469
comm and then we have the cross-site

565
00:27:56,370 --> 00:28:02,310
request forgery on the client redirect

566
00:27:58,470 --> 00:28:05,340
URI so let me explain this with the help

567
00:28:02,310 --> 00:28:07,020
of a flow diagram so we have the

568
00:28:05,340 --> 00:28:10,439
attacker here who is publishing a

569
00:28:07,020 --> 00:28:13,530
malicious web site and the clutter and

570
00:28:10,440 --> 00:28:19,440
the user or the resource owner happens

571
00:28:13,530 --> 00:28:21,330
to visit this malicious web site the

572
00:28:19,440 --> 00:28:26,250
malicious web site then generates a

573
00:28:21,330 --> 00:28:31,949
forged response with the attackers or

574
00:28:26,250 --> 00:28:34,890
code in it and what happens next is that

575
00:28:31,950 --> 00:28:37,170
the client will extract exchange this

576
00:28:34,890 --> 00:28:41,070
auth code for an access token with the

577
00:28:37,170 --> 00:28:42,810
auth server and it gets back the

578
00:28:41,070 --> 00:28:46,530
attackers access token instead of the

579
00:28:42,810 --> 00:28:47,820
legitimate users so basically if he

580
00:28:46,530 --> 00:28:49,649
accesses the resource

581
00:28:47,820 --> 00:28:51,419
he led back the attackers

582
00:28:49,650 --> 00:28:54,660
instead of the users resources so this

583
00:28:51,420 --> 00:28:58,680
is like a login CSRF which happens with

584
00:28:54,660 --> 00:29:01,020
what flows so there are two mitigation

585
00:28:58,680 --> 00:29:02,940
strategies for this one is to embed a

586
00:29:01,020 --> 00:29:04,889
state parameter in the authorization

587
00:29:02,940 --> 00:29:07,830
request since there is no authorization

588
00:29:04,890 --> 00:29:10,320
request the attacker has no way of

589
00:29:07,830 --> 00:29:12,810
knowing the state parameter it has no

590
00:29:10,320 --> 00:29:15,149
way of adding the state parameter in the

591
00:29:12,810 --> 00:29:17,700
response to the auth request which is

592
00:29:15,150 --> 00:29:19,320
this one and the clan needs to validate

593
00:29:17,700 --> 00:29:21,120
whether the state parameter is present

594
00:29:19,320 --> 00:29:26,610
and if it matches the one that was sent

595
00:29:21,120 --> 00:29:29,129
in the auth request and that's how the

596
00:29:26,610 --> 00:29:31,139
attack will get detected the second way

597
00:29:29,130 --> 00:29:33,150
to do is and do it is using a region

598
00:29:31,140 --> 00:29:34,350
header check because the malicious we

599
00:29:33,150 --> 00:29:37,140
have said generates this authorization

600
00:29:34,350 --> 00:29:39,060
response the client can check what kind

601
00:29:37,140 --> 00:29:41,730
of origin this respond response is

602
00:29:39,060 --> 00:29:43,679
coming from and then take a decision

603
00:29:41,730 --> 00:29:51,150
whether to proceed to exchange the auth

604
00:29:43,680 --> 00:29:53,280
code for an access token or not and the

605
00:29:51,150 --> 00:29:56,160
most commonly found one is open

606
00:29:53,280 --> 00:29:58,680
redirects on the client there are few

607
00:29:56,160 --> 00:30:02,040
assumptions are here so we're using the

608
00:29:58,680 --> 00:30:03,960
implicit grant just for convenience it

609
00:30:02,040 --> 00:30:05,909
could be both Quadrant as well but just

610
00:30:03,960 --> 00:30:08,700
to show the flow in a simpler way I've

611
00:30:05,910 --> 00:30:12,780
considered using the implicit grant and

612
00:30:08,700 --> 00:30:15,000
the client registered registers a

613
00:30:12,780 --> 00:30:17,940
redirect URL with the pattern client

614
00:30:15,000 --> 00:30:19,920
some site dot example /cb question mark

615
00:30:17,940 --> 00:30:22,290
star so clearly there's a wild card at

616
00:30:19,920 --> 00:30:24,630
the end and the attacker can actually

617
00:30:22,290 --> 00:30:26,820
add anything to it additionally the

618
00:30:24,630 --> 00:30:30,180
client is exposing open redirects using

619
00:30:26,820 --> 00:30:31,770
the redirect to parameter so all that

620
00:30:30,180 --> 00:30:34,290
the attacker needs to do is trick the

621
00:30:31,770 --> 00:30:36,960
victim into opening this malicious web

622
00:30:34,290 --> 00:30:39,960
site evil dot example and from evil dot

623
00:30:36,960 --> 00:30:44,310
example the attacker can initiate an

624
00:30:39,960 --> 00:30:47,610
authorization request with the redirect

625
00:30:44,310 --> 00:30:50,179
URI specified as client Sam site dot

626
00:30:47,610 --> 00:30:56,120
example which is exactly matching this

627
00:30:50,180 --> 00:31:00,190
/cb with a question mark redirect to

628
00:30:56,120 --> 00:31:02,600
client or evil example /cb

629
00:31:00,190 --> 00:31:04,880
so since the client is exposing this

630
00:31:02,600 --> 00:31:06,949
open redirector what will happen is that

631
00:31:04,880 --> 00:31:09,290
whence this request reaches the auth

632
00:31:06,950 --> 00:31:11,570
server the pattern matches because there

633
00:31:09,290 --> 00:31:13,340
was a wild card at the end we've just

634
00:31:11,570 --> 00:31:17,300
added a redirect to parameter at the end

635
00:31:13,340 --> 00:31:19,939
so matches and the auth server is going

636
00:31:17,300 --> 00:31:23,149
to redirect you back to the client with

637
00:31:19,940 --> 00:31:27,170
an access token which is here present as

638
00:31:23,150 --> 00:31:30,050
a URI fragment and once this response

639
00:31:27,170 --> 00:31:32,060
reaches the client the client since it

640
00:31:30,050 --> 00:31:35,990
is exposing an open redirect it'll

641
00:31:32,060 --> 00:31:38,780
redirect you to the client evil dot

642
00:31:35,990 --> 00:31:40,910
example and the waiver our browsers

643
00:31:38,780 --> 00:31:43,550
behaved is that if this redirect does

644
00:31:40,910 --> 00:31:46,970
not contain any you are a fragment the

645
00:31:43,550 --> 00:31:48,710
browser's will attach the reader the URL

646
00:31:46,970 --> 00:31:51,940
fragment from the previous response and

647
00:31:48,710 --> 00:31:54,530
had it appended to client evil example

648
00:31:51,940 --> 00:31:56,900
so that's that's how browsers behave

649
00:31:54,530 --> 00:31:58,160
they try to add tag-along more

650
00:31:56,900 --> 00:32:00,470
information to whatever you are

651
00:31:58,160 --> 00:32:02,840
accessing so they will naturally uh or

652
00:32:00,470 --> 00:32:04,970
inherently act the access token URI

653
00:32:02,840 --> 00:32:07,340
fragment to this particular domain which

654
00:32:04,970 --> 00:32:17,450
is the evil domain and that's how your

655
00:32:07,340 --> 00:32:19,490
access token could get leaked so if

656
00:32:17,450 --> 00:32:21,380
you're using auth quadrant and the same

657
00:32:19,490 --> 00:32:23,930
situation is there with the same

658
00:32:21,380 --> 00:32:25,670
assumptions you could end up leave

659
00:32:23,930 --> 00:32:28,160
leaking your auth code instead of the

660
00:32:25,670 --> 00:32:31,040
access token so let's say that the

661
00:32:28,160 --> 00:32:33,620
client com was exposing this read I was

662
00:32:31,040 --> 00:32:36,200
exposing a reopen redirect with the

663
00:32:33,620 --> 00:32:38,479
parameter redirect URL and it had an

664
00:32:36,200 --> 00:32:40,070
integration with Google Drive so when

665
00:32:38,480 --> 00:32:42,010
you hit this particular endpoint you are

666
00:32:40,070 --> 00:32:44,179
redirected to Google Drive to authorize

667
00:32:42,010 --> 00:32:49,850
the client to access your drive

668
00:32:44,180 --> 00:32:53,330
resources and once you're thrice the

669
00:32:49,850 --> 00:32:54,770
client redirects you back so sorry the

670
00:32:53,330 --> 00:32:56,899
auth server redirects you back to the

671
00:32:54,770 --> 00:32:59,330
client and since the client is exposing

672
00:32:56,900 --> 00:33:00,980
the open redirect it will redirect you

673
00:32:59,330 --> 00:33:03,610
to attacker.com with the auth code

674
00:33:00,980 --> 00:33:03,610
appended to it

675
00:33:07,270 --> 00:33:11,929
so as a mitigation clients must not

676
00:33:09,950 --> 00:33:15,260
expose open rewrites that's the best

677
00:33:11,929 --> 00:33:17,299
case clients must memorize which ad

678
00:33:15,260 --> 00:33:19,610
server this enter North request to and

679
00:33:17,299 --> 00:33:24,620
ensure that any subsequent requests go

680
00:33:19,610 --> 00:33:26,750
to the same authorization server Klan

681
00:33:24,620 --> 00:33:28,789
should use a CG which is the auth code

682
00:33:26,750 --> 00:33:32,450
grant flow so that even if the odd code

683
00:33:28,789 --> 00:33:34,100
gets leaked there is still a need of the

684
00:33:32,450 --> 00:33:36,080
client secret to be present in the next

685
00:33:34,100 --> 00:33:37,520
request so the attacker who gets it

686
00:33:36,080 --> 00:33:41,260
needs to know the client secret to

687
00:33:37,520 --> 00:33:41,260
exchange that code for an access token

688
00:33:43,480 --> 00:33:48,740
so small joke on Thanos again Thanos is

689
00:33:47,270 --> 00:33:51,200
a client who is exposed the open

690
00:33:48,740 --> 00:33:53,390
redirects and this is the dialogue

691
00:33:51,200 --> 00:34:04,909
between Gamora when Thanos snaps his

692
00:33:53,390 --> 00:34:07,700
finger and returns all right so fishing

693
00:34:04,909 --> 00:34:09,589
or using you stressin auth servers so

694
00:34:07,700 --> 00:34:12,379
this is a simple example

695
00:34:09,589 --> 00:34:15,560
pretty straightforward or where you are

696
00:34:12,379 --> 00:34:18,918
misusing the trust that the user has in

697
00:34:15,560 --> 00:34:21,049
authorization server so what you're

698
00:34:18,918 --> 00:34:22,520
going to do is you can register or an

699
00:34:21,050 --> 00:34:25,399
attacker can register with the

700
00:34:22,520 --> 00:34:28,989
authorization server with this

701
00:34:25,399 --> 00:34:31,310
particular redirect URI so basically his

702
00:34:28,989 --> 00:34:36,529
registered or malicious client on the

703
00:34:31,310 --> 00:34:41,210
aughts over and then it can send a

704
00:34:36,530 --> 00:34:43,820
forged uri to the user since the you URI

705
00:34:41,210 --> 00:34:47,510
has authorization server's fqdn the user

706
00:34:43,820 --> 00:34:49,330
will trust it I will he may click on it

707
00:34:47,510 --> 00:34:52,909
and if he does what will happen is that

708
00:34:49,330 --> 00:34:55,848
the scope here is an invalid scope so

709
00:34:52,909 --> 00:34:58,550
the authorization server will basically

710
00:34:55,849 --> 00:35:01,640
generate an error I'll redirect you back

711
00:34:58,550 --> 00:35:03,560
to the attackers domain because that is

712
00:35:01,640 --> 00:35:05,390
where the request is coming in from and

713
00:35:03,560 --> 00:35:08,029
that has been mentioned here in the

714
00:35:05,390 --> 00:35:10,000
redirect URI and since this redirect URI

715
00:35:08,030 --> 00:35:12,530
is already registered on the auth server

716
00:35:10,000 --> 00:35:14,119
the server will think okay I can

717
00:35:12,530 --> 00:35:15,770
redirect you back to the client but

718
00:35:14,119 --> 00:35:18,090
still I'm not going to give you anything

719
00:35:15,770 --> 00:35:20,160
else I'm not going to give you or code

720
00:35:18,090 --> 00:35:21,660
but I can still redirect you so you're

721
00:35:20,160 --> 00:35:22,620
eventually gonna get redirected to

722
00:35:21,660 --> 00:35:25,620
attacker.com

723
00:35:22,620 --> 00:35:27,839
without the auth code but then you can

724
00:35:25,620 --> 00:35:29,850
do a lot of phishing attack because the

725
00:35:27,840 --> 00:35:36,810
user thinks he's visiting also and he

726
00:35:29,850 --> 00:35:38,670
eventually ends up on attacker.com so s

727
00:35:36,810 --> 00:35:41,430
authorization server needs to take a

728
00:35:38,670 --> 00:35:43,860
call whether to redirect or not and he

729
00:35:41,430 --> 00:35:46,379
may choose to inform the user about the

730
00:35:43,860 --> 00:35:51,270
redirect and that's the only way the

731
00:35:46,380 --> 00:35:53,370
user can save himself okay then the mix

732
00:35:51,270 --> 00:35:56,310
of attack this attack happens in

733
00:35:53,370 --> 00:35:59,009
scenarios where the client interacts

734
00:35:56,310 --> 00:36:02,040
with multiple authorization servers and

735
00:35:59,010 --> 00:36:05,250
one of them made Guru or turn malicious

736
00:36:02,040 --> 00:36:07,710
and the goal is to obtain the auth code

737
00:36:05,250 --> 00:36:10,380
or access token by tricking the client

738
00:36:07,710 --> 00:36:16,830
or the application to sending it to the

739
00:36:10,380 --> 00:36:20,490
attacker control auth server -

740
00:36:16,830 --> 00:36:22,890
preconditions I'm gonna use a CG here

741
00:36:20,490 --> 00:36:25,919
which is the auth quadrant but it

742
00:36:22,890 --> 00:36:28,350
applies to implicit grant as well it is

743
00:36:25,920 --> 00:36:30,360
and the client is using multiple odd

744
00:36:28,350 --> 00:36:32,670
server that's the only precondition and

745
00:36:30,360 --> 00:36:35,160
the other one is about that the client

746
00:36:32,670 --> 00:36:37,380
is using the same redirect URI for all

747
00:36:35,160 --> 00:36:39,810
the authorization servers so the

748
00:36:37,380 --> 00:36:44,970
redirect URI is not authorization server

749
00:36:39,810 --> 00:36:47,670
specific so I'm gonna take the example

750
00:36:44,970 --> 00:36:50,100
of two AAS or motivation servers one is

751
00:36:47,670 --> 00:36:52,770
Google one is Facebook and let's just

752
00:36:50,100 --> 00:36:54,330
assume that Facebook goes malicious no

753
00:36:52,770 --> 00:36:56,340
offense to Mark Zuckerberg of Facebook

754
00:36:54,330 --> 00:37:01,710
it's just that Facebook has been in news

755
00:36:56,340 --> 00:37:05,040
of late and let's see the flow using

756
00:37:01,710 --> 00:37:08,010
this diagram so what happens is that

757
00:37:05,040 --> 00:37:10,020
lets say LinkedIn shows you that you can

758
00:37:08,010 --> 00:37:13,560
log in through Facebook or Google and

759
00:37:10,020 --> 00:37:15,000
the user chooses Facebook so the

760
00:37:13,560 --> 00:37:17,759
authorization request is generated

761
00:37:15,000 --> 00:37:19,770
Facebook's auth server and Facebook

762
00:37:17,760 --> 00:37:23,460
since it's malicious it will redirect

763
00:37:19,770 --> 00:37:25,320
you to Google's odds over so you get

764
00:37:23,460 --> 00:37:27,240
shown now you are shown the Google's

765
00:37:25,320 --> 00:37:29,220
also a page instead of Facebook that's

766
00:37:27,240 --> 00:37:31,589
the only place where the user can get to

767
00:37:29,220 --> 00:37:32,788
know that there's something going on

768
00:37:31,589 --> 00:37:38,009
but if the user doesn't pay attention

769
00:37:32,789 --> 00:37:41,339
then he may authorize the request and an

770
00:37:38,009 --> 00:37:43,499
auth code gets generated and is

771
00:37:41,339 --> 00:37:46,828
redirected back to the redirect URI of

772
00:37:43,499 --> 00:37:49,379
the client and the client still thinks

773
00:37:46,829 --> 00:37:52,319
that the earth was J authorization

774
00:37:49,380 --> 00:37:53,880
request was initiated with Facebook so

775
00:37:52,319 --> 00:37:56,489
it will try to hit facebook's

776
00:37:53,880 --> 00:38:01,799
authorization server to redeem this auth

777
00:37:56,489 --> 00:38:04,650
code but once Facebook gets the auth

778
00:38:01,799 --> 00:38:09,209
code it will try to redeem it at

779
00:38:04,650 --> 00:38:11,699
Google's auth token endpoint and get

780
00:38:09,209 --> 00:38:13,799
back a token for the user so Facebook

781
00:38:11,699 --> 00:38:24,749
can now use that token to access victims

782
00:38:13,799 --> 00:38:27,449
Google's resources so the idea here is

783
00:38:24,749 --> 00:38:31,049
to you know this odd server could

784
00:38:27,449 --> 00:38:34,949
actually return an issuer parameter so

785
00:38:31,049 --> 00:38:37,380
that the client knows that the auth code

786
00:38:34,949 --> 00:38:40,289
that it is receiving is from not is not

787
00:38:37,380 --> 00:38:42,660
from the intended also so in our case

788
00:38:40,289 --> 00:38:44,160
the issuer would have been Google

789
00:38:42,660 --> 00:38:46,109
because that's the entity that was

790
00:38:44,160 --> 00:38:47,788
generating the auth code but the client

791
00:38:46,109 --> 00:38:50,308
thought that it is initiating an author

792
00:38:47,789 --> 00:38:53,449
request to Facebook so that's where the

793
00:38:50,309 --> 00:38:53,449
attack would have got detected

794
00:38:53,809 --> 00:38:59,459
alternatively the clients could use

795
00:38:56,939 --> 00:39:03,269
authorization so a specific redirect URI

796
00:38:59,459 --> 00:39:05,669
as like so clan comm glueten Google

797
00:39:03,269 --> 00:39:08,848
redirect URI client comm FB redirect URL

798
00:39:05,670 --> 00:39:10,679
and the client when it in its initiates

799
00:39:08,849 --> 00:39:13,949
thoughts request it knows that it's

800
00:39:10,679 --> 00:39:16,529
Facebook that it it's redirecting to so

801
00:39:13,949 --> 00:39:18,359
the redirect so the auth code should

802
00:39:16,529 --> 00:39:20,749
come back to Facebook's redirect URI but

803
00:39:18,359 --> 00:39:23,369
if it comes to Google's redirect URI

804
00:39:20,749 --> 00:39:25,529
then obviously there's something fishy

805
00:39:23,369 --> 00:39:33,809
going on so the client will probably

806
00:39:25,529 --> 00:39:36,380
detect it and then finally I thought

807
00:39:33,809 --> 00:39:39,029
I'll give you some defense-in-depth tips

808
00:39:36,380 --> 00:39:41,279
so that you can reduce the damage even

809
00:39:39,029 --> 00:39:44,089
if your access tokens or auth code get

810
00:39:41,279 --> 00:39:44,089
is getting lead

811
00:39:44,660 --> 00:39:49,020
so what if your access token gets leaked

812
00:39:47,430 --> 00:39:53,759
what can you do best

813
00:39:49,020 --> 00:39:55,980
can you still reduce the damage so there

814
00:39:53,760 --> 00:39:57,840
are ways of tying the access token to

815
00:39:55,980 --> 00:40:00,180
the audience which is the resource

816
00:39:57,840 --> 00:40:02,700
server so you can have access tokens map

817
00:40:00,180 --> 00:40:05,129
to be used only to certain resource

818
00:40:02,700 --> 00:40:06,779
servers and that's called audience

819
00:40:05,130 --> 00:40:09,030
restricted access tokens there are

820
00:40:06,780 --> 00:40:10,920
multiple ways of doing it and I can't

821
00:40:09,030 --> 00:40:13,770
really cover them here because of the

822
00:40:10,920 --> 00:40:16,050
shortage of time but you can read about

823
00:40:13,770 --> 00:40:20,160
it on the RFC's that i have in the

824
00:40:16,050 --> 00:40:22,800
references the other thing that you can

825
00:40:20,160 --> 00:40:25,379
do to avoid the misuse of an access

826
00:40:22,800 --> 00:40:29,250
token by an attacker is that you can map

827
00:40:25,380 --> 00:40:30,840
it to the sender so basically these are

828
00:40:29,250 --> 00:40:32,940
called sender constrained access tokens

829
00:40:30,840 --> 00:40:34,170
so when you're generating an access

830
00:40:32,940 --> 00:40:36,660
token when your OAuth server is

831
00:40:34,170 --> 00:40:40,110
generating an access token it binds this

832
00:40:36,660 --> 00:40:42,420
access token to a specific client or the

833
00:40:40,110 --> 00:40:44,670
application so even if that access token

834
00:40:42,420 --> 00:40:50,010
gets leaked to a malicious entity it

835
00:40:44,670 --> 00:40:52,140
cannot access your resources so again

836
00:40:50,010 --> 00:40:55,140
there are multiple ways of doing it but

837
00:40:52,140 --> 00:40:58,549
you know you can always read about it I

838
00:40:55,140 --> 00:40:58,549
am NOT going to cover this right now

839
00:40:58,940 --> 00:41:06,810
what if your auth code gets leaked so

840
00:41:03,020 --> 00:41:09,840
maybe you can have the server what

841
00:41:06,810 --> 00:41:12,060
server implement the one-time use it's

842
00:41:09,840 --> 00:41:14,550
restriction for your auth code so if

843
00:41:12,060 --> 00:41:16,890
let's say your auth code gets lead the

844
00:41:14,550 --> 00:41:18,720
legitimate application uses that OAuth

845
00:41:16,890 --> 00:41:21,450
code and the malicious application also

846
00:41:18,720 --> 00:41:23,040
uses that auth code so what the server

847
00:41:21,450 --> 00:41:24,509
can detect this obviously because it is

848
00:41:23,040 --> 00:41:26,850
receiving two different requests with

849
00:41:24,510 --> 00:41:29,670
the same oath code and once the server

850
00:41:26,850 --> 00:41:34,020
receives two different requests what it

851
00:41:29,670 --> 00:41:36,540
can do is that it can invalidate all the

852
00:41:34,020 --> 00:41:41,550
access tokens that were generated with

853
00:41:36,540 --> 00:41:44,550
the previous auth code the other thing

854
00:41:41,550 --> 00:41:46,860
that the what server could do is that it

855
00:41:44,550 --> 00:41:49,170
can bind the authorization code to the

856
00:41:46,860 --> 00:41:52,230
redirect URI so once you hit the

857
00:41:49,170 --> 00:41:54,570
authorize endpoint of the es the auth

858
00:41:52,230 --> 00:41:56,600
server Maps the auth code it generates

859
00:41:54,570 --> 00:41:59,640
to the redirect URI

860
00:41:56,600 --> 00:42:02,310
and once the attacker tries to redeem

861
00:41:59,640 --> 00:42:04,319
the auth code the server needs to check

862
00:42:02,310 --> 00:42:06,720
whether the access token that it is

863
00:42:04,320 --> 00:42:09,090
sending to the reader QRA the redirect

864
00:42:06,720 --> 00:42:11,850
URI needs to match the auth codes

865
00:42:09,090 --> 00:42:13,950
redirect the auth code mapping before it

866
00:42:11,850 --> 00:42:15,630
did so basically you have a mapping of

867
00:42:13,950 --> 00:42:17,549
the auth code and the redirect URI and

868
00:42:15,630 --> 00:42:20,460
the server needs to validate whether the

869
00:42:17,550 --> 00:42:21,750
requests coming in is actually in the

870
00:42:20,460 --> 00:42:24,750
request that is coming in the redirect

871
00:42:21,750 --> 00:42:28,550
URI is matching or not so you can have

872
00:42:24,750 --> 00:42:32,390
the auth code bound to the redirect URI

873
00:42:28,550 --> 00:42:35,070
if you happen to use implicit grant and

874
00:42:32,390 --> 00:42:36,589
your access token is getting leaked in

875
00:42:35,070 --> 00:42:41,090
the browser's history

876
00:42:36,590 --> 00:42:43,020
avoid using redirect based access token

877
00:42:41,090 --> 00:42:45,300
returning the access token you can

878
00:42:43,020 --> 00:42:47,880
actually use form post response methods

879
00:42:45,300 --> 00:42:53,760
so that your access token is not exposed

880
00:42:47,880 --> 00:42:55,890
in the URI also you should avoid using 3

881
00:42:53,760 --> 00:42:57,990
node 7 times redirects that's a no-go

882
00:42:55,890 --> 00:43:01,200
for sure because your credentials may

883
00:42:57,990 --> 00:43:03,479
leak to the client and more on it at

884
00:43:01,200 --> 00:43:08,970
this particular RFC you can have a look

885
00:43:03,480 --> 00:43:12,390
at it alright these are some very

886
00:43:08,970 --> 00:43:15,180
important references that you should go

887
00:43:12,390 --> 00:43:17,700
through and if you want to implement the

888
00:43:15,180 --> 00:43:21,120
perfect or what solution I know it's a

889
00:43:17,700 --> 00:43:28,490
huge list but that's what things we do

890
00:43:21,120 --> 00:43:32,810
for security all right so all right so

891
00:43:28,490 --> 00:43:35,279
that brings me to the end of my talk and

892
00:43:32,810 --> 00:43:37,430
has some contact information just in

893
00:43:35,280 --> 00:43:42,030
case you'd like to drop me a message so

894
00:43:37,430 --> 00:43:46,100
thank you for your attention and that's

895
00:43:42,030 --> 00:43:46,100
all I'm up to take questions

896
00:43:48,710 --> 00:43:53,490
all right

897
00:43:50,160 --> 00:43:55,500
see thank you that was a great talk

898
00:43:53,490 --> 00:44:00,118
let's see if we have any questions in

899
00:43:55,500 --> 00:44:02,970
the crowd the Hansa I know you're

900
00:44:00,119 --> 00:44:03,480
getting a little bit tired but come on

901
00:44:02,970 --> 00:44:06,089
guys

902
00:44:03,480 --> 00:44:09,869
it must be one question it's probably

903
00:44:06,090 --> 00:44:12,270
candy in it for you really you covered

904
00:44:09,869 --> 00:44:15,200
everything man this is amazing you

905
00:44:12,270 --> 00:44:18,030
should hire you to do this guy's stuff

906
00:44:15,200 --> 00:44:19,740
so no hands up well I'm sure you can get

907
00:44:18,030 --> 00:44:21,240
in touch with you on Twitter or email if

908
00:44:19,740 --> 00:44:23,580
they have any questions afterwards or

909
00:44:21,240 --> 00:44:26,430
during the party of course which will

910
00:44:23,580 --> 00:44:28,140
hop in after the next talk so thanks

911
00:44:26,430 --> 00:44:28,759
again summit that was great thank you so

912
00:44:28,140 --> 00:44:34,828
much fun

913
00:44:28,760 --> 00:44:34,829
[Applause]

