1
00:00:00,030 --> 00:00:06,960
you yeah hello everyone my name is Kelly

2
00:00:03,449 --> 00:00:12,179
as I said and I'm going to talk a little

3
00:00:06,960 --> 00:00:14,340
bit about software obfuscation first a

4
00:00:12,179 --> 00:00:17,600
little bit in in in general what it is

5
00:00:14,340 --> 00:00:22,730
why I want to do it and then one

6
00:00:17,600 --> 00:00:29,490
particular way you can achieve this with

7
00:00:22,730 --> 00:00:33,719
the LLVM compiler framework so first

8
00:00:29,490 --> 00:00:37,440
just shortly about myself as I said my

9
00:00:33,719 --> 00:00:40,200
name is Carlo Keller and I work as the

10
00:00:37,440 --> 00:00:44,760
head of security at the healthcare

11
00:00:40,200 --> 00:00:46,789
company will and in my spare time

12
00:00:44,760 --> 00:00:50,039
I play a lot of these capture-the-flag

13
00:00:46,789 --> 00:00:54,079
competitions for Team hacking for sodium

14
00:00:50,039 --> 00:00:57,899
and if you want to get in touch with me

15
00:00:54,079 --> 00:01:05,280
after this talk or later or you can use

16
00:00:57,899 --> 00:01:09,090
one of these methods yeah and that's it

17
00:01:05,280 --> 00:01:10,320
and I am also going to tell you can I

18
00:01:09,090 --> 00:01:12,450
can tell you beforehand that this is

19
00:01:10,320 --> 00:01:14,580
gonna be a bit of a shorter talk but I

20
00:01:12,450 --> 00:01:16,770
don't think anyone will mind this we're

21
00:01:14,580 --> 00:01:19,798
getting towards the end of the day and

22
00:01:16,770 --> 00:01:22,920
people are a bit tired but hopefully

23
00:01:19,799 --> 00:01:26,280
it's gonna be some interesting content

24
00:01:22,920 --> 00:01:29,460
there so yeah as I said I'm going to

25
00:01:26,280 --> 00:01:33,270
talk a little bit about software alpha

26
00:01:29,460 --> 00:01:35,490
station and then we're going to talk a

27
00:01:33,270 --> 00:01:38,479
little bit about compilers and

28
00:01:35,490 --> 00:01:42,270
specifically about the LLVM compiler

29
00:01:38,479 --> 00:01:46,908
framework and then how you can use this

30
00:01:42,270 --> 00:01:50,759
to perform a software obfuscation and

31
00:01:46,909 --> 00:01:53,670
how you can some techniques for for

32
00:01:50,759 --> 00:01:56,280
testing this and finally we can talk a

33
00:01:53,670 --> 00:02:02,790
little bit about what you can do to try

34
00:01:56,280 --> 00:02:07,429
to counter these techniques so software

35
00:02:02,790 --> 00:02:13,069
obfuscation in general is just the like

36
00:02:07,429 --> 00:02:16,519
art and science of making software

37
00:02:13,069 --> 00:02:21,290
more difficult for someone else to

38
00:02:16,519 --> 00:02:26,870
understand this can be done at various

39
00:02:21,290 --> 00:02:29,359
different levels and areas of the

40
00:02:26,870 --> 00:02:33,500
program and with a lot of different

41
00:02:29,360 --> 00:02:36,650
methods this also depends on what kind

42
00:02:33,500 --> 00:02:40,239
of programming language or like

43
00:02:36,650 --> 00:02:43,329
execution context we're talking about so

44
00:02:40,239 --> 00:02:48,790
something that you would typically find

45
00:02:43,329 --> 00:02:51,079
in your everyday life which isn't maybe

46
00:02:48,790 --> 00:02:52,400
actually done for for the sake of making

47
00:02:51,079 --> 00:02:53,810
it harder to understand but for

48
00:02:52,400 --> 00:02:58,310
performance reasons is that most

49
00:02:53,810 --> 00:03:01,909
websites minified their JavaScript code

50
00:02:58,310 --> 00:03:03,440
so if you go to any like popular web

51
00:03:01,909 --> 00:03:05,298
application and you look at the

52
00:03:03,440 --> 00:03:08,569
JavaScript code you will see that

53
00:03:05,299 --> 00:03:10,970
everything is like single character

54
00:03:08,569 --> 00:03:16,819
variable names and all the whitespace is

55
00:03:10,970 --> 00:03:18,500
removed and so on and I think that's

56
00:03:16,819 --> 00:03:21,230
primarily done for performance reason

57
00:03:18,500 --> 00:03:23,840
but a side effect of it is that it's

58
00:03:21,230 --> 00:03:28,399
quite difficult to understand what the

59
00:03:23,840 --> 00:03:29,720
code is doing you can also do so then

60
00:03:28,400 --> 00:03:32,410
then this is done I think it kind of

61
00:03:29,720 --> 00:03:34,549
like the source code level because

62
00:03:32,410 --> 00:03:36,379
programming languages like JavaScript

63
00:03:34,549 --> 00:03:38,510
you you write the source code and then

64
00:03:36,379 --> 00:03:41,569
you ship the source code like the source

65
00:03:38,510 --> 00:03:45,590
code is the program but then you have

66
00:03:41,569 --> 00:03:49,298
other like compiled languages both like

67
00:03:45,590 --> 00:03:52,340
mid level languages like Java and.net

68
00:03:49,299 --> 00:03:55,010
based languages where you compile your

69
00:03:52,340 --> 00:03:57,230
source code into a an intermediate

70
00:03:55,010 --> 00:04:00,530
representation which is then interpreted

71
00:03:57,230 --> 00:04:05,510
by a virtual machine and then you can

72
00:04:00,530 --> 00:04:07,069
make changes to this intermediate code

73
00:04:05,510 --> 00:04:09,888
to make it more difficult to understand

74
00:04:07,069 --> 00:04:14,448
and it doesn't make as much sense to

75
00:04:09,889 --> 00:04:15,979
make changes to the source code or some

76
00:04:14,449 --> 00:04:17,870
kinds of changes to the source code

77
00:04:15,979 --> 00:04:20,000
doesn't really make any sense because

78
00:04:17,870 --> 00:04:20,570
it's gonna be compiled into this other

79
00:04:20,000 --> 00:04:22,550
thing

80
00:04:20,570 --> 00:04:25,219
anyway same goes for like lower-level

81
00:04:22,550 --> 00:04:29,750
languages like C++ or

82
00:04:25,220 --> 00:04:32,180
rusts or languages like those which are

83
00:04:29,750 --> 00:04:36,080
compiled down to machine code typically

84
00:04:32,180 --> 00:04:37,490
doesn't make any sense to modify well

85
00:04:36,080 --> 00:04:39,349
some kinds of modifications to the

86
00:04:37,490 --> 00:04:41,450
source code but you want to modify the

87
00:04:39,350 --> 00:04:44,960
actual program so that ones someone else

88
00:04:41,450 --> 00:04:47,120
gets this program it it's more difficult

89
00:04:44,960 --> 00:04:53,120
to reverse engineer it and understand

90
00:04:47,120 --> 00:04:54,980
what it's doing and there are a whole

91
00:04:53,120 --> 00:04:59,450
bunch of different techniques for

92
00:04:54,980 --> 00:05:03,860
achieving this and these are some of the

93
00:04:59,450 --> 00:05:07,450
like broad categories of techniques that

94
00:05:03,860 --> 00:05:12,890
you can find in software obfuscation so

95
00:05:07,450 --> 00:05:16,520
one very interesting concept is the

96
00:05:12,890 --> 00:05:19,849
control flow flattening so you can

97
00:05:16,520 --> 00:05:23,510
imagine that you have some program which

98
00:05:19,850 --> 00:05:26,060
has a structure like this diagram to the

99
00:05:23,510 --> 00:05:27,640
left you can imagine you know doing

100
00:05:26,060 --> 00:05:29,810
something and then you have a branch

101
00:05:27,640 --> 00:05:31,760
where you take one of the branches

102
00:05:29,810 --> 00:05:33,500
depending on something and then you do

103
00:05:31,760 --> 00:05:37,039
something at the end so this can be one

104
00:05:33,500 --> 00:05:39,950
part of your program and as a reverse

105
00:05:37,040 --> 00:05:42,760
engineer just being able to see just

106
00:05:39,950 --> 00:05:45,469
this structure without even knowing

107
00:05:42,760 --> 00:05:47,840
what's in these colored boxes already

108
00:05:45,470 --> 00:05:49,940
gives information about like the general

109
00:05:47,840 --> 00:05:54,440
structure of the program we know that

110
00:05:49,940 --> 00:05:56,240
there are two cases of something yeah so

111
00:05:54,440 --> 00:06:00,050
what you can do then is that you kind of

112
00:05:56,240 --> 00:06:02,960
rip this whole graph apart and you just

113
00:06:00,050 --> 00:06:05,720
line all these basic blocks up next to

114
00:06:02,960 --> 00:06:07,969
each other and then you have kind of

115
00:06:05,720 --> 00:06:10,790
like an internal counter which says

116
00:06:07,970 --> 00:06:13,190
which block we're going to execute next

117
00:06:10,790 --> 00:06:15,560
so we execute all of this we have a loop

118
00:06:13,190 --> 00:06:18,140
and a like a switch statement or

119
00:06:15,560 --> 00:06:20,120
something so every lap of this loop we

120
00:06:18,140 --> 00:06:21,530
choose one of the blocks to execute and

121
00:06:20,120 --> 00:06:24,410
then we go back to the beginning and we

122
00:06:21,530 --> 00:06:27,010
choose another block to execute so now

123
00:06:24,410 --> 00:06:31,730
this structure has been completely

124
00:06:27,010 --> 00:06:33,740
destroyed and and it's very difficult to

125
00:06:31,730 --> 00:06:35,690
get an overview like is this five

126
00:06:33,740 --> 00:06:37,540
different cases or are we just going to

127
00:06:35,690 --> 00:06:40,690
execute all of these five

128
00:06:37,540 --> 00:06:41,760
in a row or what's going on so that's

129
00:06:40,690 --> 00:06:45,780
one technique

130
00:06:41,760 --> 00:06:49,210
another thing is self-modifying code

131
00:06:45,780 --> 00:06:52,840
which is a fairly descriptive name it's

132
00:06:49,210 --> 00:06:55,989
basically a code which during execution

133
00:06:52,840 --> 00:06:58,630
will modify the program that is running

134
00:06:55,990 --> 00:07:02,380
either modify the actual piece of code

135
00:06:58,630 --> 00:07:06,969
that's running or maybe decrypt or

136
00:07:02,380 --> 00:07:10,409
modify other parts of the program you

137
00:07:06,970 --> 00:07:15,040
can also have dead code which is

138
00:07:10,410 --> 00:07:17,040
basically you insert a lot of stuff in

139
00:07:15,040 --> 00:07:23,680
the program that effectively does

140
00:07:17,040 --> 00:07:28,890
nothing so you could imagine that every

141
00:07:23,680 --> 00:07:34,390
time you assign a value to a variable

142
00:07:28,890 --> 00:07:36,390
you add some extra additions afterwards

143
00:07:34,390 --> 00:07:39,669
but then you subtract the same amount

144
00:07:36,390 --> 00:07:41,860
immediately afterwards or you like you /

145
00:07:39,670 --> 00:07:44,080
- but then you multiply by 2 again later

146
00:07:41,860 --> 00:07:46,540
and you just insert these meaningless

147
00:07:44,080 --> 00:07:48,280
less things or maybe you insert some

148
00:07:46,540 --> 00:07:51,340
stuff which will copy data from one

149
00:07:48,280 --> 00:07:53,789
place and then copy it back later and

150
00:07:51,340 --> 00:07:57,159
yeah all kinds of just a meaningless

151
00:07:53,790 --> 00:08:02,550
stuff which will not affect the actual

152
00:07:57,160 --> 00:08:02,550
semantics of the program but it will

153
00:08:02,610 --> 00:08:09,580
make it more tedious to go through and

154
00:08:06,520 --> 00:08:14,409
understand the code because like the

155
00:08:09,580 --> 00:08:17,320
code the program becomes larger while

156
00:08:14,410 --> 00:08:19,060
still containing like the same amount of

157
00:08:17,320 --> 00:08:21,190
information so the vector the density of

158
00:08:19,060 --> 00:08:25,180
information in the program goes down and

159
00:08:21,190 --> 00:08:29,730
makes it more tedious to analyze it you

160
00:08:25,180 --> 00:08:32,049
can have as a packers which executes

161
00:08:29,730 --> 00:08:33,430
parts of the program in stages so maybe

162
00:08:32,049 --> 00:08:34,809
you have a small part of the program

163
00:08:33,429 --> 00:08:38,228
which will decrypt another part of the

164
00:08:34,809 --> 00:08:39,699
program and which in turn will maybe

165
00:08:38,229 --> 00:08:42,780
decrypt another part of the program and

166
00:08:39,700 --> 00:08:48,460
so on which makes very difficult to know

167
00:08:42,780 --> 00:08:50,529
beforehand what the program does very

168
00:08:48,460 --> 00:08:54,399
related thing is droppers

169
00:08:50,529 --> 00:08:57,639
very common among malware where you will

170
00:08:54,399 --> 00:08:59,560
download additional code from the

171
00:08:57,639 --> 00:09:01,029
internet for example so you just have a

172
00:08:59,560 --> 00:09:03,790
small part of the code in the program

173
00:09:01,029 --> 00:09:07,449
and then you like dynamically retrieve

174
00:09:03,790 --> 00:09:10,300
code that you will execute you can

175
00:09:07,449 --> 00:09:12,639
insert a lot of anti debugging

176
00:09:10,300 --> 00:09:17,620
techniques in your program to make it

177
00:09:12,639 --> 00:09:20,199
difficult to debug the program there are

178
00:09:17,620 --> 00:09:22,300
from very simple techniques which just

179
00:09:20,199 --> 00:09:25,240
tries to detect if you have a debugger

180
00:09:22,300 --> 00:09:28,269
running and in that case it will either

181
00:09:25,240 --> 00:09:31,620
shut down or do something different or

182
00:09:28,269 --> 00:09:35,829
you know modify its behavior in some way

183
00:09:31,620 --> 00:09:40,240
there are other programs which abuse is

184
00:09:35,829 --> 00:09:42,279
different features in your operating

185
00:09:40,240 --> 00:09:47,139
system to make it like inherently hard

186
00:09:42,279 --> 00:09:49,389
to debug them maybe you will have a

187
00:09:47,139 --> 00:09:51,790
program that will fork itself into

188
00:09:49,389 --> 00:09:53,559
multiple processes and one lot of

189
00:09:51,790 --> 00:09:56,439
processors will start debugging the

190
00:09:53,559 --> 00:09:58,870
other process and make modifications to

191
00:09:56,439 --> 00:10:02,319
the program while it's running and all

192
00:09:58,870 --> 00:10:06,790
kinds of funky stuff which makes it very

193
00:10:02,319 --> 00:10:10,479
annoying to the debug program you can

194
00:10:06,790 --> 00:10:12,069
also have basically create completely

195
00:10:10,480 --> 00:10:16,809
new programming languages and have a

196
00:10:12,069 --> 00:10:19,469
virtual machine embedded into your into

197
00:10:16,809 --> 00:10:22,899
your program which executes this made-up

198
00:10:19,470 --> 00:10:24,399
programming language which makes it very

199
00:10:22,899 --> 00:10:26,860
annoying because then you have to create

200
00:10:24,399 --> 00:10:31,689
basically new tools specifically for

201
00:10:26,860 --> 00:10:33,040
analysis of this program the downside is

202
00:10:31,689 --> 00:10:34,990
that they can have a quite heavy

203
00:10:33,040 --> 00:10:40,269
performance impact depending on how you

204
00:10:34,990 --> 00:10:42,819
do this so today we're gonna I'm gonna

205
00:10:40,269 --> 00:10:45,370
talk about this how we can do some of

206
00:10:42,819 --> 00:10:50,099
this obfuscation and I'm gonna limit

207
00:10:45,370 --> 00:10:55,839
myself to these low-level languages so

208
00:10:50,100 --> 00:10:57,459
when we write code nowadays we typically

209
00:10:55,839 --> 00:11:03,360
don't write machine code instructions

210
00:10:57,459 --> 00:11:03,359
directly because that would be extremely

211
00:11:04,330 --> 00:11:09,410
boring and annoying and error-prone and

212
00:11:07,610 --> 00:11:13,070
just horrible so we have created

213
00:11:09,410 --> 00:11:14,900
higher-level languages like C++ and rust

214
00:11:13,070 --> 00:11:18,560
and then we take a compiler

215
00:11:14,900 --> 00:11:21,949
I'm very cumbersome because you need

216
00:11:18,560 --> 00:11:24,829
like one compiler per pair of

217
00:11:21,950 --> 00:11:30,430
programming language and target and this

218
00:11:24,830 --> 00:11:35,900
quickly becomes completely infeasible so

219
00:11:30,430 --> 00:11:39,680
what modern compilers do is that they

220
00:11:35,900 --> 00:11:43,490
have something that looks like the top

221
00:11:39,680 --> 00:11:45,410
image so including an LLVM does this as

222
00:11:43,490 --> 00:11:47,990
well so what you do is you have a front

223
00:11:45,410 --> 00:11:51,050
end where you take this specific

224
00:11:47,990 --> 00:11:54,520
programming language like C++ or go or

225
00:11:51,050 --> 00:11:58,990
rust and you transform this into

226
00:11:54,520 --> 00:12:01,819
intermediate language so it's not quite

227
00:11:58,990 --> 00:12:04,070
something that a computer could actually

228
00:12:01,820 --> 00:12:08,120
execute and it's not quite something

229
00:12:04,070 --> 00:12:11,030
that I'm human would reasonably be able

230
00:12:08,120 --> 00:12:14,930
to read and understand so it's something

231
00:12:11,030 --> 00:12:17,630
somewhere in between then the compiler

232
00:12:14,930 --> 00:12:19,670
can do a lot of processing on this

233
00:12:17,630 --> 00:12:22,250
intermediate representation and then

234
00:12:19,670 --> 00:12:24,189
finally we transform this intermediate

235
00:12:22,250 --> 00:12:26,870
representation into something that's

236
00:12:24,190 --> 00:12:28,610
specifically targeted towards the

237
00:12:26,870 --> 00:12:32,030
platform that we want to execute this

238
00:12:28,610 --> 00:12:35,120
code on and the really good thing about

239
00:12:32,030 --> 00:12:39,140
this is that if we just create these

240
00:12:35,120 --> 00:12:42,170
front-ends and backends all the tools

241
00:12:39,140 --> 00:12:45,410
and you know smart things that we come

242
00:12:42,170 --> 00:12:47,810
up with that operates on this

243
00:12:45,410 --> 00:12:49,250
intermediate representation they are

244
00:12:47,810 --> 00:12:51,949
applied to all these different

245
00:12:49,250 --> 00:12:54,050
combinations we get like all of this for

246
00:12:51,950 --> 00:12:56,120
free so we make some kind of let's say

247
00:12:54,050 --> 00:13:01,099
we create an optimizer

248
00:12:56,120 --> 00:13:02,960
which thus for example loop unrolling so

249
00:13:01,100 --> 00:13:05,750
it looks at the loops in your code and

250
00:13:02,960 --> 00:13:08,300
see may looks analyzes them and see if

251
00:13:05,750 --> 00:13:13,100
it's better to actually just split this

252
00:13:08,300 --> 00:13:15,140
up into just explicitly listed statement

253
00:13:13,100 --> 00:13:16,130
for example that would be one thing that

254
00:13:15,140 --> 00:13:18,170
an optimizer

255
00:13:16,130 --> 00:13:21,800
could do and if you create this then for

256
00:13:18,170 --> 00:13:23,750
the LLVM framework it will be able to do

257
00:13:21,800 --> 00:13:28,550
this no matter what programming language

258
00:13:23,750 --> 00:13:32,180
or target you are targeting so that's

259
00:13:28,550 --> 00:13:37,280
really cool and LLVM has a lot of

260
00:13:32,180 --> 00:13:39,349
built-in of these components in the

261
00:13:37,280 --> 00:13:43,880
pipeline for optimization and things

262
00:13:39,350 --> 00:13:46,370
like that but you can also create your

263
00:13:43,880 --> 00:13:51,680
own and other people I also created a

264
00:13:46,370 --> 00:13:56,360
lot of cool tools that work on this LLVM

265
00:13:51,680 --> 00:13:59,329
intermediate language which gives you

266
00:13:56,360 --> 00:14:02,090
this benefit that you get like all of

267
00:13:59,330 --> 00:14:07,460
these different targets in one like for

268
00:14:02,090 --> 00:14:09,380
the price of one so as I said LLVM has

269
00:14:07,460 --> 00:14:11,000
this kind of like pipeline where you

270
00:14:09,380 --> 00:14:12,800
have this intermediate representation

271
00:14:11,000 --> 00:14:15,620
and then it goes through different

272
00:14:12,800 --> 00:14:18,949
stages of this pipeline where it's this

273
00:14:15,620 --> 00:14:23,570
intermediate code is like processed in

274
00:14:18,950 --> 00:14:25,940
different steps to simplify it and

275
00:14:23,570 --> 00:14:31,610
optimize it and make it as good as

276
00:14:25,940 --> 00:14:36,770
possible and it's fairly easy to write a

277
00:14:31,610 --> 00:14:40,910
simple such such a component in this

278
00:14:36,770 --> 00:14:43,640
pipe and a path you can write one fairly

279
00:14:40,910 --> 00:14:48,560
easily yourself so this to the right

280
00:14:43,640 --> 00:14:51,140
it's like a minimum example of overpass

281
00:14:48,560 --> 00:14:54,229
this doesn't really do anything of

282
00:14:51,140 --> 00:14:58,160
interest it just prints out a message

283
00:14:54,230 --> 00:15:00,290
every time for every basic block that

284
00:14:58,160 --> 00:15:02,420
it's executed on so we like just lists

285
00:15:00,290 --> 00:15:05,660
all the basic block in your code not

286
00:15:02,420 --> 00:15:07,189
very interesting but this is like maybe

287
00:15:05,660 --> 00:15:09,170
like the minimum amount of code you

288
00:15:07,190 --> 00:15:13,400
would need to write one of these passes

289
00:15:09,170 --> 00:15:14,599
and they're written in C++ I don't know

290
00:15:13,400 --> 00:15:17,569
if you can write them in in other

291
00:15:14,600 --> 00:15:21,110
languages but yeah this is what you can

292
00:15:17,570 --> 00:15:23,840
do but we are not here to optimize the

293
00:15:21,110 --> 00:15:26,360
code we are here to obfuscate the code

294
00:15:23,840 --> 00:15:29,110
so just as well as we can write the pass

295
00:15:26,360 --> 00:15:29,110
that

296
00:15:29,320 --> 00:15:34,580
makes the code more efficient removes

297
00:15:31,970 --> 00:15:38,150
unnecessary instructions and so on we

298
00:15:34,580 --> 00:15:43,220
can make code that's more difficult to

299
00:15:38,150 --> 00:15:46,610
analyze and it was this really nice blog

300
00:15:43,220 --> 00:15:50,060
post from quark slabs from a couple of

301
00:15:46,610 --> 00:15:53,090
years ago where they did this and they

302
00:15:50,060 --> 00:15:57,199
base this around this mathematical

303
00:15:53,090 --> 00:16:01,180
expression so they would in some places

304
00:15:57,200 --> 00:16:04,520
in the code they would decide that

305
00:16:01,180 --> 00:16:06,739
instead of having anywhere in the code

306
00:16:04,520 --> 00:16:08,750
where you would need something that

307
00:16:06,740 --> 00:16:14,150
would that you want to evaluate to a

308
00:16:08,750 --> 00:16:16,700
false value you could replace this by

309
00:16:14,150 --> 00:16:22,430
this expression so you would take two

310
00:16:16,700 --> 00:16:23,870
variables in your code x and y and then

311
00:16:22,430 --> 00:16:27,469
you will just generate two random

312
00:16:23,870 --> 00:16:30,740
numbers a1 and a2 which we can then

313
00:16:27,470 --> 00:16:32,690
insert in this expression and you would

314
00:16:30,740 --> 00:16:35,150
also pick two prime numbers so we could

315
00:16:32,690 --> 00:16:38,690
have a table of prime numbers and we

316
00:16:35,150 --> 00:16:42,920
would replace something in the code that

317
00:16:38,690 --> 00:16:50,330
was just false and we replace it with

318
00:16:42,920 --> 00:17:01,040
this and if you do the math this will

319
00:16:50,330 --> 00:17:05,120
always hold so that's nice because the

320
00:17:01,040 --> 00:17:07,460
program is still behaving in the exact

321
00:17:05,119 --> 00:17:10,489
same way everything that was if this

322
00:17:07,460 --> 00:17:12,920
expression that we were to evaluate it

323
00:17:10,490 --> 00:17:16,700
was previously always false and it still

324
00:17:12,920 --> 00:17:19,550
always gonna be false but it's not as

325
00:17:16,700 --> 00:17:21,920
obvious if you if I would have liked a

326
00:17:19,550 --> 00:17:24,290
snippet of code where you'd say like an

327
00:17:21,920 --> 00:17:27,110
if statement which would say if false

328
00:17:24,290 --> 00:17:29,870
which means we never execute this piece

329
00:17:27,109 --> 00:17:31,760
of code that's very obvious we're never

330
00:17:29,870 --> 00:17:37,489
doing that but if the if statement says

331
00:17:31,760 --> 00:17:39,800
if this then it's not like immediately

332
00:17:37,490 --> 00:17:40,280
obvious whether that's true or false and

333
00:17:39,800 --> 00:17:45,809
in

334
00:17:40,280 --> 00:17:47,309
situations and the nice thing about this

335
00:17:45,809 --> 00:17:50,820
then is that sure we could have made

336
00:17:47,309 --> 00:17:54,270
these modifications in our source code

337
00:17:50,820 --> 00:17:55,860
when we wrote the program but nice thing

338
00:17:54,270 --> 00:17:59,070
here is that when we implement this as

339
00:17:55,860 --> 00:18:02,580
an LLVM pass we kind of get it like at

340
00:17:59,070 --> 00:18:04,830
scale for free so we can just we could

341
00:18:02,580 --> 00:18:07,918
maybe decide on some kind of density of

342
00:18:04,830 --> 00:18:11,100
how often you should insert something

343
00:18:07,919 --> 00:18:13,049
like this and then just like tune this

344
00:18:11,100 --> 00:18:17,070
up and down depending on how horrible we

345
00:18:13,049 --> 00:18:19,040
want the code to become and you can you

346
00:18:17,070 --> 00:18:22,470
know come up with all kinds of different

347
00:18:19,040 --> 00:18:25,139
funky expressions and transformation to

348
00:18:22,470 --> 00:18:27,330
your code that will not make the code

349
00:18:25,140 --> 00:18:29,870
behave any differently in practice but

350
00:18:27,330 --> 00:18:36,090
will make it much more difficult to

351
00:18:29,870 --> 00:18:36,770
analyze so I did as a small example for

352
00:18:36,090 --> 00:18:39,780
myself

353
00:18:36,770 --> 00:18:43,320
just one of these where I would take a

354
00:18:39,780 --> 00:18:45,178
value and move it around in a different

355
00:18:43,320 --> 00:18:47,760
in a few different places I copied to a

356
00:18:45,179 --> 00:18:50,429
register and I could push it to a stack

357
00:18:47,760 --> 00:18:53,070
and get it fetch it back and just juggle

358
00:18:50,429 --> 00:18:55,440
it around a few times before using it

359
00:18:53,070 --> 00:19:00,990
which will add a bunch of instruction

360
00:18:55,440 --> 00:19:03,330
which are completely meaningless oh yeah

361
00:19:00,990 --> 00:19:07,620
so this is this is one way you can use

362
00:19:03,330 --> 00:19:10,790
LLVM to create obfuscation you create

363
00:19:07,620 --> 00:19:14,189
these passes which insert into the LLVM

364
00:19:10,790 --> 00:19:16,260
pipeline and the nice thing is now you

365
00:19:14,190 --> 00:19:17,880
have created an obfuscator not only for

366
00:19:16,260 --> 00:19:20,669
a single saying a language but you have

367
00:19:17,880 --> 00:19:23,340
created an obfuscator for all the

368
00:19:20,669 --> 00:19:25,140
languages that are supported by LLVM

369
00:19:23,340 --> 00:19:27,240
which is also a cool thing because if

370
00:19:25,140 --> 00:19:29,640
you would have made it made this at the

371
00:19:27,240 --> 00:19:32,850
source code level say I I make the

372
00:19:29,640 --> 00:19:35,160
equivalent thing for C++ that would

373
00:19:32,850 --> 00:19:37,949
absolutely work but it would only be for

374
00:19:35,160 --> 00:19:42,270
C++ now I get all of this all these

375
00:19:37,950 --> 00:19:46,290
other things for free another thing you

376
00:19:42,270 --> 00:19:50,190
could do which some people have done is

377
00:19:46,290 --> 00:19:53,789
that they have completely forked the

378
00:19:50,190 --> 00:19:58,559
LLVM project

379
00:19:53,789 --> 00:20:05,399
to build further obfuscation routines

380
00:19:58,559 --> 00:20:07,139
and tools and the advantage of this is

381
00:20:05,399 --> 00:20:10,469
of course that you're no longer

382
00:20:07,139 --> 00:20:14,359
constrained to the exact interface that

383
00:20:10,470 --> 00:20:18,419
the LLVM provides to you so you can do

384
00:20:14,359 --> 00:20:21,539
more complicated obfuscation on the

385
00:20:18,419 --> 00:20:25,320
other hand it's you know it comes with

386
00:20:21,539 --> 00:20:27,509
all the downside of managing a fork of

387
00:20:25,320 --> 00:20:29,879
like a major software project that you

388
00:20:27,509 --> 00:20:32,940
have if you want to stay up to date you

389
00:20:29,879 --> 00:20:35,070
have to remember I pull in all like

390
00:20:32,940 --> 00:20:36,960
upstream patches and manage that and

391
00:20:35,070 --> 00:20:39,509
make sure that's compatible with your

392
00:20:36,960 --> 00:20:42,809
code and so on so it can be quite an

393
00:20:39,509 --> 00:20:46,609
endeavor but some people have done this

394
00:20:42,809 --> 00:20:46,609
and they call it the obfuscate or LLVM

395
00:20:46,759 --> 00:20:52,739
which is yeah exactly what the name says

396
00:20:50,159 --> 00:20:54,899
it's a open-source fork of LLVM

397
00:20:52,739 --> 00:20:57,389
compilation suite able to provide

398
00:20:54,899 --> 00:21:01,070
increased software security through code

399
00:20:57,389 --> 00:21:05,609
obfuscation and tampered roofing which

400
00:21:01,070 --> 00:21:07,049
brings me a little bit to which i should

401
00:21:05,609 --> 00:21:08,879
have talked to earlier talked about

402
00:21:07,049 --> 00:21:13,470
earlier but didn't is like why would you

403
00:21:08,879 --> 00:21:15,090
do this in the first place and there of

404
00:21:13,470 --> 00:21:19,830
course a couple of different reasons

405
00:21:15,090 --> 00:21:22,168
you could for example a lot of when it

406
00:21:19,830 --> 00:21:24,720
comes to like DRM and things related to

407
00:21:22,169 --> 00:21:26,489
that you typically all of your like copy

408
00:21:24,720 --> 00:21:28,259
protection mechanisms and things like

409
00:21:26,489 --> 00:21:31,320
that you typically want them to be

410
00:21:28,259 --> 00:21:34,529
difficult to reverse engineer so that it

411
00:21:31,320 --> 00:21:38,070
takes people a longer time to create

412
00:21:34,529 --> 00:21:40,889
crack or bypass for it so that's one

413
00:21:38,070 --> 00:21:43,259
area where you would use this or just

414
00:21:40,889 --> 00:21:46,619
for any kind of like intellectual

415
00:21:43,259 --> 00:21:49,080
property thing where you don't want like

416
00:21:46,619 --> 00:21:51,389
if you're releasing software but part of

417
00:21:49,080 --> 00:21:54,570
the software is actually what you

418
00:21:51,389 --> 00:21:56,549
consider you know important part of your

419
00:21:54,570 --> 00:21:59,279
trade secrets you can try to obfuscate

420
00:21:56,549 --> 00:22:01,080
this code to make it more difficult or

421
00:21:59,279 --> 00:22:04,139
take a longer time for competitors to

422
00:22:01,080 --> 00:22:06,730
like take your code apart and steal

423
00:22:04,139 --> 00:22:12,340
these ideas or algorithms or

424
00:22:06,730 --> 00:22:17,590
whatever also malware authors they use

425
00:22:12,340 --> 00:22:19,600
obfuscation heavily to make it difficult

426
00:22:17,590 --> 00:22:23,470
to analyze the malware but both

427
00:22:19,600 --> 00:22:27,820
automatically so that you get the lower

428
00:22:23,470 --> 00:22:31,600
hit rate from your like antivirus and

429
00:22:27,820 --> 00:22:33,790
anti-malware software but also for ICANN

430
00:22:31,600 --> 00:22:38,590
malware analysts to make it more tedious

431
00:22:33,790 --> 00:22:41,379
to to look at this code so basically any

432
00:22:38,590 --> 00:22:44,980
time when you don't really want people

433
00:22:41,380 --> 00:22:52,330
to know what you're up to for business

434
00:22:44,980 --> 00:22:55,810
or other reasons so as we know testing

435
00:22:52,330 --> 00:22:59,590
is important when building software same

436
00:22:55,810 --> 00:23:03,909
goes for one building obfuscators as you

437
00:22:59,590 --> 00:23:05,919
can create some really subtle bugs and

438
00:23:03,910 --> 00:23:09,640
they can be very strange behavior which

439
00:23:05,920 --> 00:23:12,220
can be very difficult to debug as an

440
00:23:09,640 --> 00:23:17,740
example from this blog post the core

441
00:23:12,220 --> 00:23:20,110
claps people they found out that if they

442
00:23:17,740 --> 00:23:22,600
weren't careful enough other parts of

443
00:23:20,110 --> 00:23:26,939
the like optimization pipeline could

444
00:23:22,600 --> 00:23:32,490
choose to optimize away these X and y

445
00:23:26,940 --> 00:23:35,170
variables for some reason which would

446
00:23:32,490 --> 00:23:41,590
cause the program to crash or behave

447
00:23:35,170 --> 00:23:46,000
very strangely so in another article guy

448
00:23:41,590 --> 00:23:49,110
he had the actually quite genius idea of

449
00:23:46,000 --> 00:23:52,510
just taking some large open source

450
00:23:49,110 --> 00:23:55,990
software and which already has like a

451
00:23:52,510 --> 00:24:01,330
huge test suite and an expected behavior

452
00:23:55,990 --> 00:24:03,040
so just recompile this big piece of

453
00:24:01,330 --> 00:24:05,830
software like the bigger the better the

454
00:24:03,040 --> 00:24:07,899
more tests the better with your

455
00:24:05,830 --> 00:24:11,290
obfuscator and just run it through all

456
00:24:07,900 --> 00:24:15,880
the tests and if it's still working then

457
00:24:11,290 --> 00:24:19,629
your obfuscation probably did not change

458
00:24:15,880 --> 00:24:22,870
the behavior of the program so that's

459
00:24:19,630 --> 00:24:24,700
actually a really neat idea I think

460
00:24:22,870 --> 00:24:27,760
instead of trying to like write test

461
00:24:24,700 --> 00:24:29,740
cases on your own just use large

462
00:24:27,760 --> 00:24:33,910
batteries of test cases that are already

463
00:24:29,740 --> 00:24:40,450
out there so what do we do about this

464
00:24:33,910 --> 00:24:42,370
and unfortunately I mean the answer is

465
00:24:40,450 --> 00:24:45,160
basically the same way we handle any

466
00:24:42,370 --> 00:24:49,979
kind of obfuscation with different kinds

467
00:24:45,160 --> 00:24:55,210
of reverse engineering methods so

468
00:24:49,980 --> 00:24:57,400
typically when when a tool like this is

469
00:24:55,210 --> 00:25:00,970
built by anyone it's for the purpose to

470
00:24:57,400 --> 00:25:04,180
be used on multiple occasions so that

471
00:25:00,970 --> 00:25:06,820
means that if we manage to find one

472
00:25:04,180 --> 00:25:12,310
sample let's say a malware author has

473
00:25:06,820 --> 00:25:14,200
built an obfuscation obfuscator and

474
00:25:12,310 --> 00:25:17,230
obfuscated their malware and you are

475
00:25:14,200 --> 00:25:21,100
analyzing this malware sample you might

476
00:25:17,230 --> 00:25:23,590
be able to eventually when you've like

477
00:25:21,100 --> 00:25:25,149
analyzed and see what's going on since

478
00:25:23,590 --> 00:25:27,100
since the office kitchen follows some

479
00:25:25,150 --> 00:25:30,100
kind of pattern you must be able to

480
00:25:27,100 --> 00:25:32,260
build and automated the obfuscate

481
00:25:30,100 --> 00:25:34,449
therefore for that specific of the

482
00:25:32,260 --> 00:25:35,860
scheduled technique and that helps you

483
00:25:34,450 --> 00:25:37,510
of course if you encounter another

484
00:25:35,860 --> 00:25:40,479
malware which is the impact or

485
00:25:37,510 --> 00:25:44,110
obfuscated with the same tool you are

486
00:25:40,480 --> 00:25:46,270
able to reuse your your tools against it

487
00:25:44,110 --> 00:25:50,520
so it's like an arms race thing where

488
00:25:46,270 --> 00:25:53,440
people will build more horrible

489
00:25:50,520 --> 00:25:56,350
obfuscators and people will try to build

490
00:25:53,440 --> 00:25:58,360
an automated the obfuscators and they

491
00:25:56,350 --> 00:26:02,290
can be done specific as in the example I

492
00:25:58,360 --> 00:26:04,870
said or you can try to use things like

493
00:26:02,290 --> 00:26:09,190
symbolic execution where you try to

494
00:26:04,870 --> 00:26:12,100
automatically analyze programs to

495
00:26:09,190 --> 00:26:14,680
determine maybe what part of codes are

496
00:26:12,100 --> 00:26:19,840
actually completely useless and optimize

497
00:26:14,680 --> 00:26:22,760
them away one thing I played around with

498
00:26:19,840 --> 00:26:24,949
a little bit is that I mentioned this

499
00:26:22,760 --> 00:26:30,580
tool called Manticore previously which

500
00:26:24,950 --> 00:26:34,520
is a tool for symbolic execution and

501
00:26:30,580 --> 00:26:39,439
made by the trail of bits us security

502
00:26:34,520 --> 00:26:41,990
company and what you can do is then if

503
00:26:39,440 --> 00:26:47,510
you have a compiled program and you're

504
00:26:41,990 --> 00:26:49,990
able to go backwards and turn it back

505
00:26:47,510 --> 00:26:54,610
into this LLVM intermediate

506
00:26:49,990 --> 00:26:57,559
representation you can then run these

507
00:26:54,610 --> 00:27:01,250
optimizers for example the ones already

508
00:26:57,559 --> 00:27:03,918
built into LLVM or other optimizer

509
00:27:01,250 --> 00:27:05,900
analyzing things to try to remove what

510
00:27:03,919 --> 00:27:07,370
is like dead or meaningless code and try

511
00:27:05,900 --> 00:27:09,429
to simplify the code again which

512
00:27:07,370 --> 00:27:15,290
hopefully that will remove part of this

513
00:27:09,429 --> 00:27:17,840
obfuscation and then as always you can

514
00:27:15,290 --> 00:27:21,590
always use your regular like dynamic

515
00:27:17,840 --> 00:27:24,860
analysis methods like debugging and

516
00:27:21,590 --> 00:27:30,110
tracing executions or even fussing it

517
00:27:24,860 --> 00:27:31,459
takes techniques to see where where part

518
00:27:30,110 --> 00:27:39,428
of the program's behaves differently

519
00:27:31,460 --> 00:27:43,520
depending on on your input so yeah I

520
00:27:39,429 --> 00:27:45,260
have some references listed here I think

521
00:27:43,520 --> 00:27:46,879
we'll make the slides available if you

522
00:27:45,260 --> 00:27:52,450
want to check out these like blog posts

523
00:27:46,880 --> 00:27:57,790
and resources about LLVM and obfuscation

524
00:27:52,450 --> 00:28:00,620
yeah and these topics and yeah that was

525
00:27:57,790 --> 00:28:02,980
it thank you very much for listening all

526
00:28:00,620 --> 00:28:02,979
right

527
00:28:03,090 --> 00:28:09,760
[Applause]

528
00:28:07,260 --> 00:28:12,070
those great do we have any questions

529
00:28:09,760 --> 00:28:15,160
perhaps we have you from Hugo do we have

530
00:28:12,070 --> 00:28:18,909
any candy no I'm sorry we don't we're

531
00:28:15,160 --> 00:28:25,320
not running out of here oh this guy this

532
00:28:18,910 --> 00:28:28,390
guy listening and you talked about

533
00:28:25,320 --> 00:28:29,889
reusing deification techniques against

534
00:28:28,390 --> 00:28:32,230
different types of malware if they've

535
00:28:29,890 --> 00:28:35,410
been using the same sort of packer how

536
00:28:32,230 --> 00:28:36,900
often would you say you find samples

537
00:28:35,410 --> 00:28:41,860
that have been using the same tools in a

538
00:28:36,900 --> 00:28:45,460
sample size of 100 so unfortunately I

539
00:28:41,860 --> 00:28:47,290
don't work too much with like in a

540
00:28:45,460 --> 00:28:51,460
position where I encountered this on a

541
00:28:47,290 --> 00:28:53,590
regular basis so it would be better to

542
00:28:51,460 --> 00:28:55,830
ask this question to someone working for

543
00:28:53,590 --> 00:28:59,800
example as a malware analyst at a

544
00:28:55,830 --> 00:29:02,710
anti-malware company and and they would

545
00:28:59,800 --> 00:29:05,139
have a much better understanding of what

546
00:29:02,710 --> 00:29:09,130
like what the landscape looks like I

547
00:29:05,140 --> 00:29:10,450
have more looked at this from like an

548
00:29:09,130 --> 00:29:12,040
academic perspective like it's a

549
00:29:10,450 --> 00:29:13,900
research thing so I looked at like

550
00:29:12,040 --> 00:29:16,210
specific examples and so but I have

551
00:29:13,900 --> 00:29:18,340
absolutely no idea about like the

552
00:29:16,210 --> 00:29:23,140
current landscape of malware like what's

553
00:29:18,340 --> 00:29:30,040
what what the trend is right now anyone

554
00:29:23,140 --> 00:29:31,660
else don't be shy I have no kami so and

555
00:29:30,040 --> 00:29:34,149
what you have looked at what would you

556
00:29:31,660 --> 00:29:39,370
say would be the performance impact on

557
00:29:34,150 --> 00:29:42,010
the application yes and that is there is

558
00:29:39,370 --> 00:29:43,419
definitely a performance impact and of

559
00:29:42,010 --> 00:29:47,920
course too depends on the techniques

560
00:29:43,420 --> 00:29:54,280
used and so on ranging from you know

561
00:29:47,920 --> 00:29:56,890
barely noticeable to huge impact so I

562
00:29:54,280 --> 00:30:00,790
think one of the most extreme cases

563
00:29:56,890 --> 00:30:03,730
there is something called the mob this

564
00:30:00,790 --> 00:30:06,730
Gator which I think I've mentioned on

565
00:30:03,730 --> 00:30:08,650
this stage previously some year which

566
00:30:06,730 --> 00:30:12,880
basically it's called it's what's called

567
00:30:08,650 --> 00:30:15,280
a one instruction VM so it takes all

568
00:30:12,880 --> 00:30:16,490
your machine code and instead of using

569
00:30:15,280 --> 00:30:19,129
this like

570
00:30:16,490 --> 00:30:22,250
rich set the feature that your processor

571
00:30:19,130 --> 00:30:25,540
provides for you it translates your code

572
00:30:22,250 --> 00:30:29,540
to only use a single CPU instruction

573
00:30:25,540 --> 00:30:30,889
over and over again and this

574
00:30:29,540 --> 00:30:32,330
specifically there are like the multiple

575
00:30:30,890 --> 00:30:33,920
example of these but this this specific

576
00:30:32,330 --> 00:30:37,669
case then will only use the move

577
00:30:33,920 --> 00:30:40,460
instruction so if you imagine like a

578
00:30:37,670 --> 00:30:42,590
call graph of your program it will be

579
00:30:40,460 --> 00:30:44,960
like a lot of branches and jumps all

580
00:30:42,590 --> 00:30:47,449
over the place when you transform it

581
00:30:44,960 --> 00:30:49,880
with the morph escape it all gets turned

582
00:30:47,450 --> 00:30:53,420
into one sequential line of instruction

583
00:30:49,880 --> 00:30:56,240
that will execute all the time and that

584
00:30:53,420 --> 00:31:00,040
has a horrible performance impact but

585
00:30:56,240 --> 00:31:05,420
it's also absolutely horrible to analyze

586
00:31:00,040 --> 00:31:07,550
so I guess what you could do is you use

587
00:31:05,420 --> 00:31:09,740
these like very heavy and performance

588
00:31:07,550 --> 00:31:11,750
heavy obfuscation techniques to denied

589
00:31:09,740 --> 00:31:15,500
not your whole program but like parts of

590
00:31:11,750 --> 00:31:17,470
your program if you want to write

591
00:31:15,500 --> 00:31:25,490
performance malware or something just

592
00:31:17,470 --> 00:31:28,940
one more yep one of my project I mean my

593
00:31:25,490 --> 00:31:31,370
client project they use the LLVM to

594
00:31:28,940 --> 00:31:34,910
obfuscate their source code and what I

595
00:31:31,370 --> 00:31:38,209
did on that time I use Falcon valgrind

596
00:31:34,910 --> 00:31:39,800
is also one of the tools and that what

597
00:31:38,210 --> 00:31:41,450
it will do it will remove all the

598
00:31:39,800 --> 00:31:43,669
obfuscation techniques dead code and

599
00:31:41,450 --> 00:31:45,890
everything and then I perform the side

600
00:31:43,670 --> 00:31:47,660
channel analysis on that thing yeah so

601
00:31:45,890 --> 00:31:50,710
this is the thing that you have to look

602
00:31:47,660 --> 00:31:55,760
out for when you're doing these

603
00:31:50,710 --> 00:32:00,440
obfuscation techniques like because your

604
00:31:55,760 --> 00:32:02,780
opponent the analyzer the analyst they

605
00:32:00,440 --> 00:32:04,610
have two sets of tools they have like

606
00:32:02,780 --> 00:32:07,220
computers and automated tools and they

607
00:32:04,610 --> 00:32:09,979
have like the human brain and your

608
00:32:07,220 --> 00:32:13,340
techniques you need to decide for

609
00:32:09,980 --> 00:32:14,690
yourself like what what parts am i

610
00:32:13,340 --> 00:32:17,330
obviously like am i making this

611
00:32:14,690 --> 00:32:19,880
difficult for an automated analysis

612
00:32:17,330 --> 00:32:21,649
program to understand or am i making it

613
00:32:19,880 --> 00:32:23,450
difficult for a human to understand or

614
00:32:21,650 --> 00:32:26,870
for both of them

615
00:32:23,450 --> 00:32:28,520
and the risk is if you use if you do

616
00:32:26,870 --> 00:32:30,530
something that you think this is really

617
00:32:28,520 --> 00:32:32,810
tricky for a human to understand but

618
00:32:30,530 --> 00:32:34,610
accidentally it's very very easy for a

619
00:32:32,810 --> 00:32:37,310
computer to understand it might happen

620
00:32:34,610 --> 00:32:40,790
that you like just optimize away all

621
00:32:37,310 --> 00:32:44,330
your options on the way or you make it

622
00:32:40,790 --> 00:32:46,280
really easy for the analyst to do this

623
00:32:44,330 --> 00:32:48,530
so you have to consider like what are

624
00:32:46,280 --> 00:32:50,320
you protecting against and and how do

625
00:32:48,530 --> 00:32:57,950
you achieve that

626
00:32:50,320 --> 00:33:00,110
suite one more the final one final

627
00:32:57,950 --> 00:33:02,150
question of the day I think there's

628
00:33:00,110 --> 00:33:04,969
people sleeping in the back I don't know

629
00:33:02,150 --> 00:33:07,580
why just kidding

630
00:33:04,970 --> 00:33:11,060
so you mentioned using a Manticore to

631
00:33:07,580 --> 00:33:13,159
perform symbolic execution yeah another

632
00:33:11,060 --> 00:33:15,740
very popular tool that I think you

633
00:33:13,160 --> 00:33:18,790
mentioned in the podcast is anger yep

634
00:33:15,740 --> 00:33:20,870
could you give like this dumbed down

635
00:33:18,790 --> 00:33:22,430
description of the differences between

636
00:33:20,870 --> 00:33:25,810
them or like yes

637
00:33:22,430 --> 00:33:29,560
so unless I'm completely mistaken anger

638
00:33:25,810 --> 00:33:34,280
works with its own intermediate

639
00:33:29,560 --> 00:33:37,820
representation of the program so they

640
00:33:34,280 --> 00:33:46,970
are not part of like the LLVM ecosystem

641
00:33:37,820 --> 00:33:49,310
of tools so that means that it will it

642
00:33:46,970 --> 00:33:52,220
will only support the things that they

643
00:33:49,310 --> 00:33:55,730
have built support for they cannot like

644
00:33:52,220 --> 00:33:59,300
piggyback on this on the other hand

645
00:33:55,730 --> 00:34:02,030
they're completely free to do whatever

646
00:33:59,300 --> 00:34:03,980
they want and they only have to care

647
00:34:02,030 --> 00:34:07,580
about being compatible with themselves

648
00:34:03,980 --> 00:34:10,850
so it's two different frameworks I

649
00:34:07,580 --> 00:34:13,250
actually have more experience with anger

650
00:34:10,850 --> 00:34:18,020
haven't used Manticore that much but I

651
00:34:13,250 --> 00:34:19,639
think this this whole idea which I think

652
00:34:18,020 --> 00:34:23,120
we've seen more and more of the last

653
00:34:19,639 --> 00:34:27,699
couple of years of building things in

654
00:34:23,120 --> 00:34:31,190
Canada's like general framework way is

655
00:34:27,699 --> 00:34:34,489
very like fruitful because that you get

656
00:34:31,190 --> 00:34:37,109
these scale benefits

657
00:34:34,489 --> 00:34:39,839
for example if you look at other like

658
00:34:37,109 --> 00:34:42,359
reverse engineering tools like the the

659
00:34:39,839 --> 00:34:44,909
Ghidorah that was released by the NSA

660
00:34:42,359 --> 00:34:46,828
previously this year they are also doing

661
00:34:44,909 --> 00:34:49,409
kind of the same thing they are first

662
00:34:46,829 --> 00:34:51,690
they disassembled the machine code into

663
00:34:49,409 --> 00:34:53,579
an intermediate representation and then

664
00:34:51,690 --> 00:34:55,649
they run their decompiler on this

665
00:34:53,579 --> 00:34:57,359
intermediate representation which means

666
00:34:55,649 --> 00:34:59,310
that they have to build one D compiler

667
00:34:57,359 --> 00:35:00,779
for this intermediate representation and

668
00:34:59,310 --> 00:35:03,140
that they have a decompiler that works

669
00:35:00,780 --> 00:35:06,630
for all of these different languages or

670
00:35:03,140 --> 00:35:08,730
architectures that they are targeting in

671
00:35:06,630 --> 00:35:11,369
contrast and to for example the hex race

672
00:35:08,730 --> 00:35:15,079
the compiler in ira which is built

673
00:35:11,369 --> 00:35:18,450
specifically for different architectures

674
00:35:15,079 --> 00:35:19,540
all right thank you again jela that was

675
00:35:18,450 --> 00:35:23,899
great thank you

676
00:35:19,540 --> 00:35:23,900
[Applause]

