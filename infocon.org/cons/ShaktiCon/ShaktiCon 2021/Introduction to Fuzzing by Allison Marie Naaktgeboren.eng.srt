1
00:00:05,120 --> 00:00:06,879
parts of the world

2
00:00:06,879 --> 00:00:09,440
uh we we reached the third day of

3
00:00:09,440 --> 00:00:11,360
shakthikhan successfully with

4
00:00:11,360 --> 00:00:14,480
really amazing trainings and speakers

5
00:00:14,480 --> 00:00:19,119
and panelists um yeah since two days

6
00:00:19,119 --> 00:00:22,320
um today we have alison alison is a

7
00:00:22,320 --> 00:00:24,240
researcher and a senior software

8
00:00:24,240 --> 00:00:25,279
engineer with

9
00:00:25,279 --> 00:00:28,400
an interest in cyber security she worked

10
00:00:28,400 --> 00:00:29,679
as a software engineer

11
00:00:29,679 --> 00:00:33,520
at signal sciences mansla factset

12
00:00:33,520 --> 00:00:35,760
and amazon and did her bachelor's from

13
00:00:35,760 --> 00:00:37,200
cmu

14
00:00:37,200 --> 00:00:39,760
fuzzing and voluntary research are

15
00:00:39,760 --> 00:00:41,760
especially interesting to her

16
00:00:41,760 --> 00:00:44,719
she mentors disadvantaged high school

17
00:00:44,719 --> 00:00:45,360
students

18
00:00:45,360 --> 00:00:48,480
in programming and robotics and adult

19
00:00:48,480 --> 00:00:50,480
underrepresented minorities

20
00:00:50,480 --> 00:00:53,520
trans transitioning into or expanding

21
00:00:53,520 --> 00:00:56,000
their career into technology through

22
00:00:56,000 --> 00:00:58,800
portland women in tech initiative she is

23
00:00:58,800 --> 00:01:01,199
also a core member of blackery

24
00:01:01,199 --> 00:01:04,400
hearty welcome to you alison and over to

25
00:01:04,400 --> 00:01:06,640
you the virtual stage is yours

26
00:01:06,640 --> 00:01:08,799
awesome good morning everybody or good

27
00:01:08,799 --> 00:01:10,640
evening since it is rather late for me

28
00:01:10,640 --> 00:01:12,080
and rather early for many of you

29
00:01:12,080 --> 00:01:13,119
i'll try to keep this a little bit

30
00:01:13,119 --> 00:01:16,560
whimsical and what-hearted uh

31
00:01:16,560 --> 00:01:19,759
see no yes

32
00:01:19,759 --> 00:01:22,479
okay i can click all right so another

33
00:01:22,479 --> 00:01:23,520
thing to mention is there's more than

34
00:01:23,520 --> 00:01:25,119
one alice in noctua born so if you try

35
00:01:25,119 --> 00:01:26,000
to find me on the internet with

36
00:01:26,000 --> 00:01:26,560
questions

37
00:01:26,560 --> 00:01:28,240
or you want some help please make sure

38
00:01:28,240 --> 00:01:29,759
you get the right one when we get to the

39
00:01:29,759 --> 00:01:32,000
lab i'll have my email and my discord

40
00:01:32,000 --> 00:01:32,479
handle

41
00:01:32,479 --> 00:01:35,520
to remind you as chris said i am a

42
00:01:35,520 --> 00:01:37,040
grad student but i am an old software

43
00:01:37,040 --> 00:01:39,119
developer i work a number of places

44
00:01:39,119 --> 00:01:41,439
since this is host by ctf team i'd also

45
00:01:41,439 --> 00:01:42,560
like to point out that i

46
00:01:42,560 --> 00:01:44,479
am a member of three i'm the president

47
00:01:44,479 --> 00:01:46,479
co-founder of the portland state team

48
00:01:46,479 --> 00:01:48,880
i'm the captain and co-founder of qq

49
00:01:48,880 --> 00:01:50,880
which is an all women's team here

50
00:01:50,880 --> 00:01:53,200
and i am so somewhat incompetent player

51
00:01:53,200 --> 00:01:54,159
on samurai

52
00:01:54,159 --> 00:01:55,759
spoken in a couple places and i am

53
00:01:55,759 --> 00:01:57,680
involved in a lot of communities

54
00:01:57,680 --> 00:01:59,360
i will also note that the security lab

55
00:01:59,360 --> 00:02:00,799
at portland state with the exception of

56
00:02:00,799 --> 00:02:02,640
our advisor is currently all women

57
00:02:02,640 --> 00:02:05,280
i thought that was a nice touch so what

58
00:02:05,280 --> 00:02:06,399
are we going to do today

59
00:02:06,399 --> 00:02:08,399
again this is rather early this goal is

60
00:02:08,399 --> 00:02:10,800
to equip you to understand buzzing

61
00:02:10,800 --> 00:02:12,080
based on what folks about to say in the

62
00:02:12,080 --> 00:02:13,520
discord i gather most of you are

63
00:02:13,520 --> 00:02:15,200
relatively new to computer science and

64
00:02:15,200 --> 00:02:16,400
or security

65
00:02:16,400 --> 00:02:18,080
so this is not going to be super

66
00:02:18,080 --> 00:02:19,840
in-depth but it's supposed to be a road

67
00:02:19,840 --> 00:02:21,200
map to help guide you

68
00:02:21,200 --> 00:02:22,480
we're going to talk about what fuzzing

69
00:02:22,480 --> 00:02:25,920
is understand the fuzzer differences

70
00:02:25,920 --> 00:02:28,480
understand some fuzzier limitations

71
00:02:28,480 --> 00:02:29,840
figure out who's interested in fuzzing

72
00:02:29,840 --> 00:02:31,599
why and what fuzzers might suit

73
00:02:31,599 --> 00:02:34,480
which group talk about specific buzzer

74
00:02:34,480 --> 00:02:35,200
afl

75
00:02:35,200 --> 00:02:36,720
and some of the pitfalls i've seen new

76
00:02:36,720 --> 00:02:38,800
students and then we're going to get

77
00:02:38,800 --> 00:02:39,120
some

78
00:02:39,120 --> 00:02:40,400
get our hands dirty and play with

79
00:02:40,400 --> 00:02:43,519
heartbleed everybody with me so far

80
00:02:43,519 --> 00:02:45,920
cool we'll take questions at the end so

81
00:02:45,920 --> 00:02:47,200
i've been regularly stopped

82
00:02:47,200 --> 00:02:49,040
literally metaphorically and

83
00:02:49,040 --> 00:02:51,200
figuratively in hallways with this

84
00:02:51,200 --> 00:02:51,840
question

85
00:02:51,840 --> 00:02:53,280
what's this new fuzzing thing i keep

86
00:02:53,280 --> 00:02:55,280
hearing about it's an exciting research

87
00:02:55,280 --> 00:02:56,720
area i hear it's got lots of papers and

88
00:02:56,720 --> 00:02:57,440
funding

89
00:02:57,440 --> 00:02:59,120
or i hear i can use fuzzy and make a lot

90
00:02:59,120 --> 00:03:00,720
of money on the internet easily

91
00:03:00,720 --> 00:03:03,120
that sounds super cool woo says you're

92
00:03:03,120 --> 00:03:04,000
the department expert

93
00:03:04,000 --> 00:03:06,560
on fuzzing how do i make money uh and

94
00:03:06,560 --> 00:03:08,480
fun is a little bit more complicated

95
00:03:08,480 --> 00:03:10,560
than i think some people let on so let's

96
00:03:10,560 --> 00:03:12,560
start with what fuzzing is

97
00:03:12,560 --> 00:03:14,400
it's a dynamic stochastic software

98
00:03:14,400 --> 00:03:16,800
testing technique by that i mean

99
00:03:16,800 --> 00:03:18,560
dynamic we're going to run the code so

100
00:03:18,560 --> 00:03:20,480
you have something you are afraid to run

101
00:03:20,480 --> 00:03:21,680
or run repeatedly

102
00:03:21,680 --> 00:03:24,000
fuzzing may be a bad fit for you and

103
00:03:24,000 --> 00:03:26,239
stochastic is a fancy word for we rely

104
00:03:26,239 --> 00:03:27,360
on probability

105
00:03:27,360 --> 00:03:28,879
we're going to use a lot of probability

106
00:03:28,879 --> 00:03:30,319
here because we need to flirt with the

107
00:03:30,319 --> 00:03:31,360
halting program

108
00:03:31,360 --> 00:03:34,239
problem without going too far over and

109
00:03:34,239 --> 00:03:37,200
ultimately we're testing software

110
00:03:37,200 --> 00:03:39,120
its goal is to thoroughly explore the

111
00:03:39,120 --> 00:03:40,720
input space of a target program

112
00:03:40,720 --> 00:03:42,720
also called a victim program looking for

113
00:03:42,720 --> 00:03:44,840
input or seeds that cause interesting

114
00:03:44,840 --> 00:03:46,239
behavior

115
00:03:46,239 --> 00:03:47,920
you should know that interesting is not

116
00:03:47,920 --> 00:03:49,680
universally defined we don't all agree

117
00:03:49,680 --> 00:03:51,840
on what constitutes interesting

118
00:03:51,840 --> 00:03:53,680
it does require the ability to reach any

119
00:03:53,680 --> 00:03:55,280
input in the input space

120
00:03:55,280 --> 00:03:56,959
on a computer and in computer science is

121
00:03:56,959 --> 00:03:58,560
pretty easy everything is ultimately a

122
00:03:58,560 --> 00:03:59,519
string of bits

123
00:03:59,519 --> 00:04:01,360
but if you were to try to apply fuzzing

124
00:04:01,360 --> 00:04:03,599
to areas outside of a computer

125
00:04:03,599 --> 00:04:04,959
you might run into some troubles if you

126
00:04:04,959 --> 00:04:07,040
can't actually do this

127
00:04:07,040 --> 00:04:08,799
you also note since anger has had a

128
00:04:08,799 --> 00:04:10,159
couple of presentations

129
00:04:10,159 --> 00:04:12,000
that some people consider a symbolic

130
00:04:12,000 --> 00:04:14,000
execution to be a subset of buzzing

131
00:04:14,000 --> 00:04:17,279
others don't depends on who you ask

132
00:04:17,279 --> 00:04:19,600
and it's not actually new buzzing was

133
00:04:19,600 --> 00:04:21,199
first published by dr bart miller and

134
00:04:21,199 --> 00:04:24,240
his students in december of 1990

135
00:04:24,240 --> 00:04:26,080
in a magazine article actually it wasn't

136
00:04:26,080 --> 00:04:27,440
even a full paper

137
00:04:27,440 --> 00:04:29,360
so it's not actually new it's over 30

138
00:04:29,360 --> 00:04:30,479
years old

139
00:04:30,479 --> 00:04:32,160
and then if i throw a lot of vocabulary

140
00:04:32,160 --> 00:04:33,680
at you in the next couple slides i do

141
00:04:33,680 --> 00:04:35,120
have a cheat sheet here

142
00:04:35,120 --> 00:04:36,560
let me know it's helpful if it's not

143
00:04:36,560 --> 00:04:37,759
helpful if you think it's missing

144
00:04:37,759 --> 00:04:38,479
something

145
00:04:38,479 --> 00:04:40,160
i personally struggle when i see talks

146
00:04:40,160 --> 00:04:41,840
in new area with some of the vocabulary

147
00:04:41,840 --> 00:04:42,720
and jargon

148
00:04:42,720 --> 00:04:44,000
so this is my attempt to make this

149
00:04:44,000 --> 00:04:46,000
easier for you

150
00:04:46,000 --> 00:04:49,280
so fuzzing at the fifty thousand hundred

151
00:04:49,280 --> 00:04:50,400
thousand foot level

152
00:04:50,400 --> 00:04:52,720
looks like this all fuzzers begin with

153
00:04:52,720 --> 00:04:54,160
this sort of series of steps

154
00:04:54,160 --> 00:04:55,680
some of them can be incredibly

155
00:04:55,680 --> 00:04:57,840
complicated sophisticated works of art

156
00:04:57,840 --> 00:05:00,000
but at its heart all fuzzers follow this

157
00:05:00,000 --> 00:05:00,880
format

158
00:05:00,880 --> 00:05:02,400
there's some sort of setup either it's

159
00:05:02,400 --> 00:05:04,080
done for you or done by some piece of

160
00:05:04,080 --> 00:05:06,479
the fuzzer or the software system

161
00:05:06,479 --> 00:05:08,000
we might prep the target we might select

162
00:05:08,000 --> 00:05:09,919
some inputs to start with we might tune

163
00:05:09,919 --> 00:05:10,960
some parameters

164
00:05:10,960 --> 00:05:14,000
we're going to kick the fuzzing job off

165
00:05:14,000 --> 00:05:15,919
we're basically running a giant while

166
00:05:15,919 --> 00:05:17,520
loop checking if an exit condition has

167
00:05:17,520 --> 00:05:18,240
been met

168
00:05:18,240 --> 00:05:20,240
if it hasn't we're going to choose some

169
00:05:20,240 --> 00:05:22,080
series of inputs to test

170
00:05:22,080 --> 00:05:23,520
and for each of those inputs we're going

171
00:05:23,520 --> 00:05:24,960
to feed it to the target program in a

172
00:05:24,960 --> 00:05:26,560
little experimental box and see what it

173
00:05:26,560 --> 00:05:27,280
does

174
00:05:27,280 --> 00:05:28,560
if it does something we think is

175
00:05:28,560 --> 00:05:30,000
interesting we're probably going to

176
00:05:30,000 --> 00:05:31,039
store that result

177
00:05:31,039 --> 00:05:32,800
we might update some bookkeeping we

178
00:05:32,800 --> 00:05:34,320
might do some deep thinking about what

179
00:05:34,320 --> 00:05:35,120
to do next

180
00:05:35,120 --> 00:05:37,280
and we'll move on to the next input and

181
00:05:37,280 --> 00:05:39,039
we'll do that until something tells us

182
00:05:39,039 --> 00:05:40,320
to stop

183
00:05:40,320 --> 00:05:42,960
all fuzzers have this characteristic

184
00:05:42,960 --> 00:05:44,560
basically we're gonna run those the

185
00:05:44,560 --> 00:05:46,240
program with the input and see what it

186
00:05:46,240 --> 00:05:47,840
does

187
00:05:47,840 --> 00:05:50,479
but this uh this gets a little it's a

188
00:05:50,479 --> 00:05:51,520
very broad view

189
00:05:51,520 --> 00:05:52,800
so let's talk about how fuzzers are

190
00:05:52,800 --> 00:05:54,160
different and how they go about solving

191
00:05:54,160 --> 00:05:55,759
that problem

192
00:05:55,759 --> 00:05:57,199
a couple questions the first one i

193
00:05:57,199 --> 00:05:58,800
always ask a new fuzzer is

194
00:05:58,800 --> 00:06:01,840
how do you define interesting where do

195
00:06:01,840 --> 00:06:02,800
you get your seeds

196
00:06:02,800 --> 00:06:06,319
or your inputs what's the exit condition

197
00:06:06,319 --> 00:06:08,560
how much do we know about the target how

198
00:06:08,560 --> 00:06:09,600
much do we need to know

199
00:06:09,600 --> 00:06:11,840
is another way to think about that does

200
00:06:11,840 --> 00:06:13,520
it have a focus or specialty

201
00:06:13,520 --> 00:06:15,039
and does it have some sort of secret

202
00:06:15,039 --> 00:06:18,240
sauce that makes it super awesome

203
00:06:18,240 --> 00:06:19,680
so the one we're gonna start with is how

204
00:06:19,680 --> 00:06:21,759
do you define interesting to me one of

205
00:06:21,759 --> 00:06:23,120
the things that's most interesting about

206
00:06:23,120 --> 00:06:24,479
fuzzers probably in the overuse of the

207
00:06:24,479 --> 00:06:25,199
word

208
00:06:25,199 --> 00:06:27,039
is how they figure out if a target

209
00:06:27,039 --> 00:06:28,720
program has done something they should

210
00:06:28,720 --> 00:06:30,080
care about

211
00:06:30,080 --> 00:06:32,319
now these are some for the four big ones

212
00:06:32,319 --> 00:06:33,280
but there are many more

213
00:06:33,280 --> 00:06:34,720
and they can be combined these are not

214
00:06:34,720 --> 00:06:36,800
mutually exclusive right now

215
00:06:36,800 --> 00:06:38,639
code coverage based fuzzers are very big

216
00:06:38,639 --> 00:06:40,160
and the most common so i'm gonna start

217
00:06:40,160 --> 00:06:40,880
there

218
00:06:40,880 --> 00:06:42,400
and a code coverage based buzzer

219
00:06:42,400 --> 00:06:44,000
interesting is defined as an

220
00:06:44,000 --> 00:06:46,639
increase in the code coverage graph it

221
00:06:46,639 --> 00:06:48,000
may not actually be a graph

222
00:06:48,000 --> 00:06:49,520
but i'm going to use that abstraction to

223
00:06:49,520 --> 00:06:51,199
sort of get the idea into your head and

224
00:06:51,199 --> 00:06:52,800
because it makes a nice comparison and

225
00:06:52,800 --> 00:06:55,599
contrast with directed fuzzing

226
00:06:55,599 --> 00:06:56,960
people who are experienced buzzing will

227
00:06:56,960 --> 00:06:58,319
know that i am deliberately lighting

228
00:06:58,319 --> 00:07:00,000
some details if you're new don't worry

229
00:07:00,000 --> 00:07:01,120
about it

230
00:07:01,120 --> 00:07:03,599
so in our contrived example artistically

231
00:07:03,599 --> 00:07:05,280
rendered for you here

232
00:07:05,280 --> 00:07:08,400
we have seed one which finds this

233
00:07:08,400 --> 00:07:11,599
these four nodes okay works for me

234
00:07:11,599 --> 00:07:14,639
c2 finds the same four nodes well that's

235
00:07:14,639 --> 00:07:15,919
not very interesting we didn't learn

236
00:07:15,919 --> 00:07:17,680
anything we didn't already know c2 is

237
00:07:17,680 --> 00:07:19,840
not interesting but seed one's okay

238
00:07:19,840 --> 00:07:22,240
and then we do c3 which finds us a new

239
00:07:22,240 --> 00:07:24,160
new area in the binary

240
00:07:24,160 --> 00:07:25,919
oh that's very interesting c3 is

241
00:07:25,919 --> 00:07:27,759
officially interesting so anything that

242
00:07:27,759 --> 00:07:29,360
causes new areas to be hit

243
00:07:29,360 --> 00:07:30,720
is considered interesting in code

244
00:07:30,720 --> 00:07:32,639
coverage based buzzers

245
00:07:32,639 --> 00:07:34,880
and a directed fuzzer we don't care

246
00:07:34,880 --> 00:07:35,840
about coverage

247
00:07:35,840 --> 00:07:37,360
we care about getting to a specific

248
00:07:37,360 --> 00:07:39,280
point we have a target

249
00:07:39,280 --> 00:07:41,440
that gets me that i want to get to that

250
00:07:41,440 --> 00:07:43,520
thing so in a directed fuzzer we are

251
00:07:43,520 --> 00:07:45,120
looking for things

252
00:07:45,120 --> 00:07:46,639
to get us to a point and anything that

253
00:07:46,639 --> 00:07:48,400
gets us closer than we've been before is

254
00:07:48,400 --> 00:07:49,360
interesting

255
00:07:49,360 --> 00:07:51,440
so our first seed yeah we find the same

256
00:07:51,440 --> 00:07:52,400
four tuple

257
00:07:52,400 --> 00:07:54,240
it's a start you know it's not very

258
00:07:54,240 --> 00:07:55,599
close to the green dot

259
00:07:55,599 --> 00:07:57,360
our second seed we get closer we're

260
00:07:57,360 --> 00:07:58,960
still one off

261
00:07:58,960 --> 00:08:00,800
and in our third seed we get to the

262
00:08:00,800 --> 00:08:02,400
target the third seed is the most

263
00:08:02,400 --> 00:08:03,440
interesting of all

264
00:08:03,440 --> 00:08:04,879
because it has gotten us where we want

265
00:08:04,879 --> 00:08:06,720
to go seed two is the second most

266
00:08:06,720 --> 00:08:08,160
interesting because it got us closer

267
00:08:08,160 --> 00:08:10,400
than previous seed

268
00:08:10,400 --> 00:08:11,360
and seed one's just not really

269
00:08:11,360 --> 00:08:12,560
interesting at all in the grand scheme

270
00:08:12,560 --> 00:08:13,840
of things

271
00:08:13,840 --> 00:08:15,360
another thing you'll frequently see is

272
00:08:15,360 --> 00:08:17,599
taint analysis also called taint

273
00:08:17,599 --> 00:08:18,240
checking

274
00:08:18,240 --> 00:08:20,400
or taint tracking i don't know why we

275
00:08:20,400 --> 00:08:22,080
can't quite agree on terminology so

276
00:08:22,080 --> 00:08:24,160
i'll give you all three and that does

277
00:08:24,160 --> 00:08:24,960
something a little bit more

278
00:08:24,960 --> 00:08:26,240
sophisticated

279
00:08:26,240 --> 00:08:27,759
particularly for security applications

280
00:08:27,759 --> 00:08:29,039
so we want to get from some sort of

281
00:08:29,039 --> 00:08:29,759
source address

282
00:08:29,759 --> 00:08:32,159
here indicated by red and security we're

283
00:08:32,159 --> 00:08:33,039
usually interested

284
00:08:33,039 --> 00:08:35,039
in sources that are user controlled so

285
00:08:35,039 --> 00:08:36,559
some sort of user controlled input or

286
00:08:36,559 --> 00:08:37,519
memory

287
00:08:37,519 --> 00:08:39,599
and we want to get to the green which is

288
00:08:39,599 --> 00:08:41,760
something like a uuid or password or

289
00:08:41,760 --> 00:08:43,279
some sort of sensitive data we want to

290
00:08:43,279 --> 00:08:44,080
get to

291
00:08:44,080 --> 00:08:46,399
and we're interested in paths and inputs

292
00:08:46,399 --> 00:08:47,440
that cause us to get

293
00:08:47,440 --> 00:08:50,000
from the red dot to the green dot this

294
00:08:50,000 --> 00:08:51,680
represents our ability to use

295
00:08:51,680 --> 00:08:53,519
user controlled input to get to places

296
00:08:53,519 --> 00:08:55,120
we're not supposed to

297
00:08:55,120 --> 00:08:56,560
and you can do that by attempting to

298
00:08:56,560 --> 00:08:58,640
navigate sort of the code coverage graph

299
00:08:58,640 --> 00:09:00,240
looking for pads that get you from one

300
00:09:00,240 --> 00:09:01,920
to the other

301
00:09:01,920 --> 00:09:04,480
and then last but not least crashes are

302
00:09:04,480 --> 00:09:06,000
eternally interesting

303
00:09:06,000 --> 00:09:08,160
anything that sets the target on fire is

304
00:09:08,160 --> 00:09:09,920
generally considered a very interesting

305
00:09:09,920 --> 00:09:10,560
input

306
00:09:10,560 --> 00:09:12,080
because we assume that targets are never

307
00:09:12,080 --> 00:09:13,920
supposed to crash so when they do

308
00:09:13,920 --> 00:09:15,200
they've automatically done something

309
00:09:15,200 --> 00:09:17,680
interesting

310
00:09:18,240 --> 00:09:20,080
next question is an exit condition this

311
00:09:20,080 --> 00:09:21,120
one's a little bit easier to wrap your

312
00:09:21,120 --> 00:09:23,440
head around when do we stop fuzzing

313
00:09:23,440 --> 00:09:25,760
well above and beyond is the most common

314
00:09:25,760 --> 00:09:27,760
one is scheduled duration

315
00:09:27,760 --> 00:09:30,160
or user initiate exit we basically run

316
00:09:30,160 --> 00:09:31,760
the fuzzer until something outside tells

317
00:09:31,760 --> 00:09:33,680
us to stop whether a timer or a user's

318
00:09:33,680 --> 00:09:35,120
control c

319
00:09:35,120 --> 00:09:36,720
some fuzzers will run until they run out

320
00:09:36,720 --> 00:09:38,959
of inputs and some fuzzers are

321
00:09:38,959 --> 00:09:40,959
one and done as soon as they find one

322
00:09:40,959 --> 00:09:42,080
interesting seed

323
00:09:42,080 --> 00:09:44,720
they exit we'll talk about who might

324
00:09:44,720 --> 00:09:46,080
want to do this and why a little bit

325
00:09:46,080 --> 00:09:46,800
later

326
00:09:46,800 --> 00:09:48,800
but it does exist that some fuzzers exit

327
00:09:48,800 --> 00:09:50,320
as soon as they find one interesting

328
00:09:50,320 --> 00:09:52,640
input

329
00:09:52,720 --> 00:09:54,959
so next question which is of course very

330
00:09:54,959 --> 00:09:56,160
relevant to my research

331
00:09:56,160 --> 00:09:57,920
is where do you get your inputs you can

332
00:09:57,920 --> 00:10:00,000
also think of this as what happens

333
00:10:00,000 --> 00:10:01,600
to your inputs of each iteration of the

334
00:10:01,600 --> 00:10:03,680
buzzing algorithm your fuzzing algorithm

335
00:10:03,680 --> 00:10:05,040
may run millions and hundreds and

336
00:10:05,040 --> 00:10:07,200
millions of times before you're done

337
00:10:07,200 --> 00:10:09,519
so what happens can be very important

338
00:10:09,519 --> 00:10:11,279
this is an excellent area for research

339
00:10:11,279 --> 00:10:12,560
and innovation

340
00:10:12,560 --> 00:10:14,480
but the three big ones right now are

341
00:10:14,480 --> 00:10:16,399
mutational generational and the classic

342
00:10:16,399 --> 00:10:19,200
or naive

343
00:10:19,200 --> 00:10:21,040
mutational is currently one of the

344
00:10:21,040 --> 00:10:22,720
biggest ones

345
00:10:22,720 --> 00:10:24,560
and it works by taking seeds that did

346
00:10:24,560 --> 00:10:26,560
well prior and tweaking a little and

347
00:10:26,560 --> 00:10:27,760
seeing if you can get them to do even

348
00:10:27,760 --> 00:10:28,560
better

349
00:10:28,560 --> 00:10:30,000
so in our case we started with a c with

350
00:10:30,000 --> 00:10:32,000
a picture of a cat that did

351
00:10:32,000 --> 00:10:34,720
okay so we're gonna twiddle some bits in

352
00:10:34,720 --> 00:10:35,600
the cat and

353
00:10:35,600 --> 00:10:37,760
see if we can make it do better if that

354
00:10:37,760 --> 00:10:39,600
does really well then in the third

355
00:10:39,600 --> 00:10:41,200
iteration we're gonna add lots of

356
00:10:41,200 --> 00:10:42,800
whiskers and see if that does extremely

357
00:10:42,800 --> 00:10:44,399
well or maybe it'll look terrible if you

358
00:10:44,399 --> 00:10:44,959
don't know

359
00:10:44,959 --> 00:10:46,160
but we're going to try it since adding

360
00:10:46,160 --> 00:10:48,399
whiskers work before notice that you are

361
00:10:48,399 --> 00:10:50,399
changing something from one iteration to

362
00:10:50,399 --> 00:10:51,279
the next

363
00:10:51,279 --> 00:10:52,800
and so you care about what happened in

364
00:10:52,800 --> 00:10:54,959
the prior iteration these are sort of

365
00:10:54,959 --> 00:10:55,920
chains

366
00:10:55,920 --> 00:10:57,120
and they're sort of dependent on

367
00:10:57,120 --> 00:10:59,440
previous behavior and that can inform

368
00:10:59,440 --> 00:11:00,000
the choice

369
00:11:00,000 --> 00:11:02,880
of behavior of a mutational fuzzer

370
00:11:02,880 --> 00:11:05,040
contrast that with a generational buzzer

371
00:11:05,040 --> 00:11:06,720
a generational father doesn't start so

372
00:11:06,720 --> 00:11:08,000
much with inputs although some of them

373
00:11:08,000 --> 00:11:08,720
do

374
00:11:08,720 --> 00:11:10,959
but with an algorithm or an idea you can

375
00:11:10,959 --> 00:11:12,720
think of it as assembling its seeds

376
00:11:12,720 --> 00:11:15,279
rather than mutating the existing ones

377
00:11:15,279 --> 00:11:17,120
in my contrived example here we know we

378
00:11:17,120 --> 00:11:19,839
need two ears two eyes and a nose

379
00:11:19,839 --> 00:11:21,440
and i'm gonna pick from each set and

380
00:11:21,440 --> 00:11:23,360
assemble it into a thing and try it

381
00:11:23,360 --> 00:11:24,720
a generational buzzer doesn't

382
00:11:24,720 --> 00:11:26,560
necessarily care about what happened in

383
00:11:26,560 --> 00:11:28,000
the prior iterations

384
00:11:28,000 --> 00:11:30,399
it can be a little bit more paralyzable

385
00:11:30,399 --> 00:11:31,200
because they are

386
00:11:31,200 --> 00:11:34,079
much more independent operations if you

387
00:11:34,079 --> 00:11:34,399
see

388
00:11:34,399 --> 00:11:35,760
something to prescribe itself as a

389
00:11:35,760 --> 00:11:37,760
grammar based buzzer or protocol-based

390
00:11:37,760 --> 00:11:38,399
buzzer

391
00:11:38,399 --> 00:11:40,000
there's a good chance that most of the

392
00:11:40,000 --> 00:11:41,440
generation is

393
00:11:41,440 --> 00:11:43,600
sorry most of the seeds are generated

394
00:11:43,600 --> 00:11:45,519
and then we might mutate specific picks

395
00:11:45,519 --> 00:11:47,600
algorithms can get mixed and match

396
00:11:47,600 --> 00:11:49,120
sometimes they'll generate sometimes

397
00:11:49,120 --> 00:11:50,320
they'll mutate sometimes they'll just

398
00:11:50,320 --> 00:11:51,760
pull from devrand

399
00:11:51,760 --> 00:11:53,200
all this can be part of it but when we

400
00:11:53,200 --> 00:11:55,760
generally describe it in algorithm

401
00:11:55,760 --> 00:11:57,600
we tend to pick one of the other big

402
00:11:57,600 --> 00:11:58,800
categories

403
00:11:58,800 --> 00:12:00,079
and then last but not least is the

404
00:12:00,079 --> 00:12:01,920
classic the original fuzzer

405
00:12:01,920 --> 00:12:03,440
which basically uses some source of

406
00:12:03,440 --> 00:12:05,360
randomness and takes whatever randomness

407
00:12:05,360 --> 00:12:06,079
you find and

408
00:12:06,079 --> 00:12:07,920
shoves it in there it doesn't really

409
00:12:07,920 --> 00:12:09,120
worry about prior

410
00:12:09,120 --> 00:12:11,279
future seeds it just tries randomness

411
00:12:11,279 --> 00:12:12,480
you might say i need a picture of the

412
00:12:12,480 --> 00:12:13,760
cat and you'll get a jackson pollock

413
00:12:13,760 --> 00:12:14,399
painting

414
00:12:14,399 --> 00:12:16,160
you might get a picture of a fish it's

415
00:12:16,160 --> 00:12:18,959
totally random

416
00:12:18,959 --> 00:12:20,720
random fuzzers do get a little bit of a

417
00:12:20,720 --> 00:12:22,560
bad rap but in practice they're

418
00:12:22,560 --> 00:12:25,839
surprisingly effective

419
00:12:26,639 --> 00:12:28,000
and the fourth question is what do we

420
00:12:28,000 --> 00:12:30,000
need to know about the target

421
00:12:30,000 --> 00:12:31,600
start for the top which is white box in

422
00:12:31,600 --> 00:12:33,360
a white box you usually have source

423
00:12:33,360 --> 00:12:35,440
you essentially have everything and if

424
00:12:35,440 --> 00:12:37,200
you have the source you can compile or

425
00:12:37,200 --> 00:12:38,880
jit your target to get a black box or

426
00:12:38,880 --> 00:12:40,959
gray box binary if you so desire

427
00:12:40,959 --> 00:12:42,480
but white box buzzers usually means

428
00:12:42,480 --> 00:12:43,760
they're interested in working with the

429
00:12:43,760 --> 00:12:46,000
most complete information available

430
00:12:46,000 --> 00:12:48,639
a black box buzzer is able to handle a

431
00:12:48,639 --> 00:12:49,279
binary

432
00:12:49,279 --> 00:12:51,360
you have no information beyond the

433
00:12:51,360 --> 00:12:54,079
compiled and presumably optimized binary

434
00:12:54,079 --> 00:12:55,920
nobody should be shipping unoptimized

435
00:12:55,920 --> 00:12:57,519
binaries in production so if you see a

436
00:12:57,519 --> 00:12:59,839
binary it's probably optimized

437
00:12:59,839 --> 00:13:02,639
and if you know anything about c plus or

438
00:13:02,639 --> 00:13:03,040
j

439
00:13:03,040 --> 00:13:05,279
java we lose a lot of information on the

440
00:13:05,279 --> 00:13:07,200
way down to compilation about

441
00:13:07,200 --> 00:13:09,279
the state of the original program on the

442
00:13:09,279 --> 00:13:11,279
source some fuzzers care a lot about

443
00:13:11,279 --> 00:13:13,120
having that others don't

444
00:13:13,120 --> 00:13:14,480
and in the middle and the most common

445
00:13:14,480 --> 00:13:15,839
form we're seeing right now is something

446
00:13:15,839 --> 00:13:16,880
called gray box

447
00:13:16,880 --> 00:13:18,880
which we spell whichever way you prefer

448
00:13:18,880 --> 00:13:20,959
i'm not picky about how you spell gray

449
00:13:20,959 --> 00:13:22,639
and that is a binary that's been

450
00:13:22,639 --> 00:13:25,040
compiled with special instrumentation

451
00:13:25,040 --> 00:13:26,240
so we'll have things like address

452
00:13:26,240 --> 00:13:29,440
sanitization code points

453
00:13:29,440 --> 00:13:32,639
barriers memory checks built in

454
00:13:32,639 --> 00:13:34,399
one of the catches with greybox is you

455
00:13:34,399 --> 00:13:36,399
usually need the source to compile in

456
00:13:36,399 --> 00:13:37,360
all that special

457
00:13:37,360 --> 00:13:39,519
instrumentation because you don't get it

458
00:13:39,519 --> 00:13:40,560
by default

459
00:13:40,560 --> 00:13:41,680
now there has been some interesting

460
00:13:41,680 --> 00:13:44,000
research work about how to take a binary

461
00:13:44,000 --> 00:13:45,680
and retroactively shove all the

462
00:13:45,680 --> 00:13:47,199
instrumentation in it to it

463
00:13:47,199 --> 00:13:48,720
but i haven't seen a lot of it used in

464
00:13:48,720 --> 00:13:50,399
production but

465
00:13:50,399 --> 00:13:53,760
it's an interesting area of research

466
00:13:55,279 --> 00:13:58,079
and then does it have a specialty some

467
00:13:58,079 --> 00:14:00,079
fuzzers are built for specific tasks

468
00:14:00,079 --> 00:14:01,839
buffers is meant to fuzz network

469
00:14:01,839 --> 00:14:03,120
protocols

470
00:14:03,120 --> 00:14:06,240
syscaller is built for linux afl win is

471
00:14:06,240 --> 00:14:08,240
built for you guessed it windows i've

472
00:14:08,240 --> 00:14:09,600
seen a good dozen

473
00:14:09,600 --> 00:14:11,920
buzzers come out aimed at iot such as

474
00:14:11,920 --> 00:14:13,920
routers or other small appliances

475
00:14:13,920 --> 00:14:15,760
i've even seen a small buzzer written

476
00:14:15,760 --> 00:14:17,680
for the network in your car

477
00:14:17,680 --> 00:14:19,440
and it too is surprisingly effective

478
00:14:19,440 --> 00:14:22,880
despite being a naive fuzzer

479
00:14:22,880 --> 00:14:24,560
so if a fuzzer is built for specific

480
00:14:24,560 --> 00:14:26,079
application and you're interested in

481
00:14:26,079 --> 00:14:27,040
that application

482
00:14:27,040 --> 00:14:29,839
it might be a good fit and then the most

483
00:14:29,839 --> 00:14:31,360
interesting question is always

484
00:14:31,360 --> 00:14:34,800
what's the secret sauce of this buzzer

485
00:14:34,800 --> 00:14:36,560
does it have some sort of advance in the

486
00:14:36,560 --> 00:14:38,240
state of the art some sort of really

487
00:14:38,240 --> 00:14:40,079
cool algorithm or optimization

488
00:14:40,079 --> 00:14:41,839
does it target rare branches does it

489
00:14:41,839 --> 00:14:43,920
have a powering power optimization does

490
00:14:43,920 --> 00:14:45,440
it have a scheduling optimization

491
00:14:45,440 --> 00:14:46,800
does it do something interesting of

492
00:14:46,800 --> 00:14:48,560
power management do we combine it with

493
00:14:48,560 --> 00:14:50,480
symbolic execution does it have special

494
00:14:50,480 --> 00:14:52,079
emulation properties

495
00:14:52,079 --> 00:14:54,560
like being mixed with qmu or unicorn

496
00:14:54,560 --> 00:14:55,519
does it have

497
00:14:55,519 --> 00:14:59,120
mlai deep neural network magic in it

498
00:14:59,120 --> 00:15:01,279
all these buzzers usually have something

499
00:15:01,279 --> 00:15:02,639
special about them

500
00:15:02,639 --> 00:15:04,800
whether or not it's useful for your task

501
00:15:04,800 --> 00:15:06,320
it's sort of an open question but it's

502
00:15:06,320 --> 00:15:07,920
good to ask what a fuzzer thinks is

503
00:15:07,920 --> 00:15:09,360
special

504
00:15:09,360 --> 00:15:12,160
so too long didn't read how you define

505
00:15:12,160 --> 00:15:12,720
interesting

506
00:15:12,720 --> 00:15:14,720
what the exit condition is how you get

507
00:15:14,720 --> 00:15:16,399
your seeds or what happens to them

508
00:15:16,399 --> 00:15:17,360
how much do we need to know about the

509
00:15:17,360 --> 00:15:19,519
target does it have a focus or specialty

510
00:15:19,519 --> 00:15:22,639
and does it have a super secret sauce if

511
00:15:22,639 --> 00:15:24,240
you can answer those questions about a

512
00:15:24,240 --> 00:15:24,800
fuzzer

513
00:15:24,800 --> 00:15:26,959
you've got a pretty good grasp about its

514
00:15:26,959 --> 00:15:30,160
strength and its weaknesses

515
00:15:30,880 --> 00:15:32,560
but please remember that fuzzing is not

516
00:15:32,560 --> 00:15:34,160
magic now i've run you through some of

517
00:15:34,160 --> 00:15:36,160
the major algorithmic blocks

518
00:15:36,160 --> 00:15:38,240
rather quickly that we have and that

519
00:15:38,240 --> 00:15:39,519
should probably be suggesting to your

520
00:15:39,519 --> 00:15:40,240
brain

521
00:15:40,240 --> 00:15:41,920
some sort of things which fuzzing may

522
00:15:41,920 --> 00:15:46,000
not be good or some of the limits

523
00:15:47,759 --> 00:15:49,040
so the first one that i think a lot of

524
00:15:49,040 --> 00:15:51,279
people run into is not the theoretical

525
00:15:51,279 --> 00:15:52,000
nice one

526
00:15:52,000 --> 00:15:54,000
but the practical one it's extremely

527
00:15:54,000 --> 00:15:55,199
hard on your hardware

528
00:15:55,199 --> 00:15:57,199
it's cpu intensive it's often ram

529
00:15:57,199 --> 00:15:59,440
intensive they consume a lot of power

530
00:15:59,440 --> 00:16:01,040
and potentially electricity

531
00:16:01,040 --> 00:16:03,440
all that stuff costs money now i know a

532
00:16:03,440 --> 00:16:04,560
number of people who are offensive

533
00:16:04,560 --> 00:16:05,440
researchers

534
00:16:05,440 --> 00:16:06,959
and they basically run the fuzzer in the

535
00:16:06,959 --> 00:16:08,399
background on spare hardware when

536
00:16:08,399 --> 00:16:09,440
they're not using it

537
00:16:09,440 --> 00:16:10,720
so they don't really care about the

538
00:16:10,720 --> 00:16:12,560
power consumption but if you are

539
00:16:12,560 --> 00:16:13,600
thinking about using this

540
00:16:13,600 --> 00:16:15,040
in a professional setting as part of

541
00:16:15,040 --> 00:16:18,160
production then that power cost can add

542
00:16:18,160 --> 00:16:18,880
up

543
00:16:18,880 --> 00:16:20,560
likewise if you're considering like well

544
00:16:20,560 --> 00:16:22,399
can i can i use this machine for it you

545
00:16:22,399 --> 00:16:23,920
want to ask yourself

546
00:16:23,920 --> 00:16:25,920
how strong the cpu is how many threads

547
00:16:25,920 --> 00:16:27,120
it's got

548
00:16:27,120 --> 00:16:29,920
and how good your ram is not all

549
00:16:29,920 --> 00:16:30,800
machines

550
00:16:30,800 --> 00:16:32,800
especially the smaller cheap ones like

551
00:16:32,800 --> 00:16:33,920
raspberry pi's

552
00:16:33,920 --> 00:16:37,040
are particularly good fit for buzzing on

553
00:16:37,040 --> 00:16:38,560
a fundamental level though fuzzing

554
00:16:38,560 --> 00:16:40,079
relies on probability

555
00:16:40,079 --> 00:16:41,360
and there are some problems which

556
00:16:41,360 --> 00:16:43,440
probability is not a good fit

557
00:16:43,440 --> 00:16:45,120
but it's not a good fit for probability

558
00:16:45,120 --> 00:16:46,160
fuzzing is probably going to be

559
00:16:46,160 --> 00:16:47,680
extremely difficult

560
00:16:47,680 --> 00:16:49,440
some of the sub problems in fuzzing are

561
00:16:49,440 --> 00:16:51,360
non-trivial some of them may even be mp

562
00:16:51,360 --> 00:16:52,560
complete

563
00:16:52,560 --> 00:16:54,240
and the code coverage algorithms i

564
00:16:54,240 --> 00:16:55,920
walked you through

565
00:16:55,920 --> 00:16:57,680
often have a lot of limitations miss a

566
00:16:57,680 --> 00:16:59,360
lot of spots take the wrong things into

567
00:16:59,360 --> 00:17:00,560
account

568
00:17:00,560 --> 00:17:02,639
it's hard to say much with certainty

569
00:17:02,639 --> 00:17:04,799
about path complexity in a binary

570
00:17:04,799 --> 00:17:06,400
we make a lot of assumptions and some of

571
00:17:06,400 --> 00:17:08,319
them are you know

572
00:17:08,319 --> 00:17:10,480
make it so that we can do stuff but also

573
00:17:10,480 --> 00:17:13,919
limit our ability to be correct

574
00:17:14,000 --> 00:17:15,919
fuzzing itself is just never usually

575
00:17:15,919 --> 00:17:17,119
tells you why

576
00:17:17,119 --> 00:17:18,400
you sometimes get results out of a

577
00:17:18,400 --> 00:17:20,400
buzzer and you're like why why does this

578
00:17:20,400 --> 00:17:23,199
work what does this do

579
00:17:23,520 --> 00:17:25,280
sometimes that can be more effort than

580
00:17:25,280 --> 00:17:27,359
understanding and running the fuzzer in

581
00:17:27,359 --> 00:17:29,039
the first place

582
00:17:29,039 --> 00:17:30,480
and then you should always keep in mind

583
00:17:30,480 --> 00:17:32,000
that figuring out how to wrong to run

584
00:17:32,000 --> 00:17:33,360
your fuzzer which is a practical

585
00:17:33,360 --> 00:17:34,559
stumbling block

586
00:17:34,559 --> 00:17:36,640
is a non-trivial question we don't have

587
00:17:36,640 --> 00:17:37,760
a good answer for it

588
00:17:37,760 --> 00:17:39,840
as a field how do you know when it stops

589
00:17:39,840 --> 00:17:41,600
making progress

590
00:17:41,600 --> 00:17:44,640
going right right now is 24 hours but it

591
00:17:44,640 --> 00:17:47,120
actually might be much closer to 168

592
00:17:47,120 --> 00:17:49,360
it might be even longer than a week we

593
00:17:49,360 --> 00:17:50,640
don't all the way now

594
00:17:50,640 --> 00:17:54,400
so a lot of times it's a gut check so

595
00:17:54,400 --> 00:17:57,039
run through the parts of a fuzzer some

596
00:17:57,039 --> 00:17:58,320
of the algorithms they use

597
00:17:58,320 --> 00:18:00,240
for those their jobs some of the

598
00:18:00,240 --> 00:18:01,520
limitations

599
00:18:01,520 --> 00:18:03,520
this is just probably what's a good

600
00:18:03,520 --> 00:18:05,360
target what's not

601
00:18:05,360 --> 00:18:07,679
so parsers are a classic target parsers

602
00:18:07,679 --> 00:18:08,799
and fuzzing have a very close

603
00:18:08,799 --> 00:18:11,039
relationship

604
00:18:11,039 --> 00:18:12,880
they are extremely aminable to both

605
00:18:12,880 --> 00:18:15,440
generational and mutational algorithms

606
00:18:15,440 --> 00:18:17,200
there's a lot of input space to explore

607
00:18:17,200 --> 00:18:18,640
and they tend to have a lot of problems

608
00:18:18,640 --> 00:18:21,360
that buzzing is very good at finding

609
00:18:21,360 --> 00:18:22,720
there are things that are don't look

610
00:18:22,720 --> 00:18:24,400
like parsers but you can think of as a

611
00:18:24,400 --> 00:18:25,440
parser

612
00:18:25,440 --> 00:18:26,880
i once got into an argument with an

613
00:18:26,880 --> 00:18:28,799
academic who believes that every program

614
00:18:28,799 --> 00:18:30,160
is secretly a parser

615
00:18:30,160 --> 00:18:33,679
and i did not win so if your code

616
00:18:33,679 --> 00:18:35,840
loads or stores any data you have some

617
00:18:35,840 --> 00:18:37,039
sort of parser there

618
00:18:37,039 --> 00:18:38,960
you just might not know it and those

619
00:18:38,960 --> 00:18:40,840
areas tend to be extremely fruitful for

620
00:18:40,840 --> 00:18:42,000
fuzzing

621
00:18:42,000 --> 00:18:43,679
command line utilities were the first

622
00:18:43,679 --> 00:18:45,200
target for fuzzing and they're still an

623
00:18:45,200 --> 00:18:46,480
excellent one

624
00:18:46,480 --> 00:18:48,480
they take strings of bits bits go in

625
00:18:48,480 --> 00:18:51,120
bits come out

626
00:18:51,919 --> 00:18:54,080
bart miller has a 30-year retrospective

627
00:18:54,080 --> 00:18:56,160
paper that's extremely good and targets

628
00:18:56,160 --> 00:18:57,760
many command line utilities and

629
00:18:57,760 --> 00:18:59,200
classic buzzing is still remarkably

630
00:18:59,200 --> 00:19:01,919
effective text-based apis

631
00:19:01,919 --> 00:19:04,400
biot apis often do extremely well as

632
00:19:04,400 --> 00:19:05,919
buzzing targets

633
00:19:05,919 --> 00:19:08,400
and then shared libraries generally also

634
00:19:08,400 --> 00:19:11,120
do rather well as fuzzing targets

635
00:19:11,120 --> 00:19:12,880
things that don't do so well or maybe

636
00:19:12,880 --> 00:19:14,480
aren't a good fit

637
00:19:14,480 --> 00:19:17,360
things with gui only access tend not to

638
00:19:17,360 --> 00:19:18,880
translate well to fuzzing algorithms

639
00:19:18,880 --> 00:19:20,400
it's hard to translate that into

640
00:19:20,400 --> 00:19:21,919
meaningful random patterns that are

641
00:19:21,919 --> 00:19:22,960
actually different

642
00:19:22,960 --> 00:19:24,400
however if you've got a file uploader

643
00:19:24,400 --> 00:19:26,160
you can fuzz the stuff that goes up via

644
00:19:26,160 --> 00:19:28,400
the file uploader

645
00:19:28,400 --> 00:19:31,039
deep complex non-visible state also

646
00:19:31,039 --> 00:19:32,240
rather difficult to fuzz because you're

647
00:19:32,240 --> 00:19:34,400
missing a lot of information

648
00:19:34,400 --> 00:19:36,840
complex sequences and exchanges also

649
00:19:36,840 --> 00:19:38,000
problematic

650
00:19:38,000 --> 00:19:39,360
and the reason is is they're difficult

651
00:19:39,360 --> 00:19:41,039
for probability to help you

652
00:19:41,039 --> 00:19:42,320
there are other things that are also

653
00:19:42,320 --> 00:19:44,320
difficult for probability

654
00:19:44,320 --> 00:19:45,919
and classic stumbling blocks reflect

655
00:19:45,919 --> 00:19:48,640
that so kernels have deep state

656
00:19:48,640 --> 00:19:52,559
network protocols have complex sequences

657
00:19:52,559 --> 00:19:54,000
and then magic numbers and tight

658
00:19:54,000 --> 00:19:56,160
branches rely on you finding that exact

659
00:19:56,160 --> 00:19:56,720
value

660
00:19:56,720 --> 00:19:59,919
and 2 to the 64 or worse probability is

661
00:19:59,919 --> 00:20:01,679
not your friend there you're unlikely to

662
00:20:01,679 --> 00:20:02,480
find it

663
00:20:02,480 --> 00:20:04,320
although symbolic execution does perform

664
00:20:04,320 --> 00:20:07,120
extremely well here

665
00:20:07,120 --> 00:20:08,799
and for all these limitations someone

666
00:20:08,799 --> 00:20:10,159
has tried to build a fuzzer

667
00:20:10,159 --> 00:20:11,679
or part of a fuzzer to get around it

668
00:20:11,679 --> 00:20:12,720
some of that research is very

669
00:20:12,720 --> 00:20:16,080
fascinating and very brilliant

670
00:20:16,320 --> 00:20:17,679
but generally those are things other

671
00:20:17,679 --> 00:20:21,360
issues so who's using fuzzy and why

672
00:20:21,360 --> 00:20:23,120
when i first started talking to people

673
00:20:23,120 --> 00:20:24,480
about fuzzing and buzzing as a

674
00:20:24,480 --> 00:20:25,840
researcher

675
00:20:25,840 --> 00:20:27,919
i got some very strange responses i'd

676
00:20:27,919 --> 00:20:29,679
get like this buzzer is great it does

677
00:20:29,679 --> 00:20:30,640
all the right things

678
00:20:30,640 --> 00:20:32,640
this fuzzer is terrible it's awful don't

679
00:20:32,640 --> 00:20:34,960
touch it

680
00:20:34,960 --> 00:20:37,679
why is everybody yelling and why can't

681
00:20:37,679 --> 00:20:39,360
we agree on anything

682
00:20:39,360 --> 00:20:40,799
and i eventually came to the conclusion

683
00:20:40,799 --> 00:20:42,960
now this is my opinion in my sort of

684
00:20:42,960 --> 00:20:46,000
taxonomy of who's in fuzzing so this is

685
00:20:46,000 --> 00:20:47,840
not conventionally agreed upon by any

686
00:20:47,840 --> 00:20:49,440
stretch but this is the realization i

687
00:20:49,440 --> 00:20:49,919
had

688
00:20:49,919 --> 00:20:51,280
there are different populations in

689
00:20:51,280 --> 00:20:53,200
fuzzing and they've got different goals

690
00:20:53,200 --> 00:20:54,159
and different

691
00:20:54,159 --> 00:20:56,240
values and they need different buzzers i

692
00:20:56,240 --> 00:20:57,840
don't think that there's one fuzzer that

693
00:20:57,840 --> 00:21:00,080
works for everybody or every group

694
00:21:00,080 --> 00:21:01,600
someone tells you that one fuzzer is the

695
00:21:01,600 --> 00:21:03,679
only fuzzer in town please be very

696
00:21:03,679 --> 00:21:04,480
careful

697
00:21:04,480 --> 00:21:05,919
i present this to you so that you can

698
00:21:05,919 --> 00:21:07,360
use your own critical thinking when

699
00:21:07,360 --> 00:21:08,880
evaluating someone's opinion

700
00:21:08,880 --> 00:21:10,880
or analysis of a fuzzer and seeing

701
00:21:10,880 --> 00:21:13,760
whether it works for you

702
00:21:14,880 --> 00:21:16,159
so let's start with the group that

703
00:21:16,159 --> 00:21:17,520
everyone tends to think of when we think

704
00:21:17,520 --> 00:21:18,320
of as buzzing

705
00:21:18,320 --> 00:21:20,480
it's the offensive folks the red teamers

706
00:21:20,480 --> 00:21:22,400
vulnerability researchers penetration

707
00:21:22,400 --> 00:21:25,600
testers bug bounty hunters

708
00:21:25,600 --> 00:21:27,440
they have some goals they're interested

709
00:21:27,440 --> 00:21:30,080
in finding vulnerabilities

710
00:21:30,080 --> 00:21:32,480
one or a chain is fine anything beyond

711
00:21:32,480 --> 00:21:34,000
that's really a bonus

712
00:21:34,000 --> 00:21:35,600
you want to pawn a box you really only

713
00:21:35,600 --> 00:21:38,080
need one way in anything else is

714
00:21:38,080 --> 00:21:40,240
you know nice to have as a backup they

715
00:21:40,240 --> 00:21:42,159
want to find it really fast

716
00:21:42,159 --> 00:21:44,080
they want to find it before anyone else

717
00:21:44,080 --> 00:21:45,280
they prefer other people have a

718
00:21:45,280 --> 00:21:47,679
difficult time finding it

719
00:21:47,679 --> 00:21:48,880
and i don't really care about why

720
00:21:48,880 --> 00:21:51,440
something works a very established

721
00:21:51,440 --> 00:21:53,120
penetration tester broke my heart when

722
00:21:53,120 --> 00:21:54,080
we were talking about

723
00:21:54,080 --> 00:21:56,159
races in a scheduler and he's like i

724
00:21:56,159 --> 00:21:57,760
don't care why it breaks i just need it

725
00:21:57,760 --> 00:22:00,080
to break consistently so i can get in

726
00:22:00,080 --> 00:22:02,320
get rude access and get on with my day

727
00:22:02,320 --> 00:22:04,000
i'm like but don't you care about why

728
00:22:04,000 --> 00:22:06,400
it's so cool he's like no

729
00:22:06,400 --> 00:22:08,720
so that was my realization that some

730
00:22:08,720 --> 00:22:10,799
people don't really care about why and

731
00:22:10,799 --> 00:22:12,000
they don't care that the fuzzer

732
00:22:12,000 --> 00:22:14,240
does not tell them why it's not part of

733
00:22:14,240 --> 00:22:15,039
their

734
00:22:15,039 --> 00:22:16,960
their values so if you're part of this

735
00:22:16,960 --> 00:22:18,400
group you are interested in bugs that

736
00:22:18,400 --> 00:22:20,320
are exclusively vulnerabilities

737
00:22:20,320 --> 00:22:22,559
you don't care about bugs that aren't

738
00:22:22,559 --> 00:22:23,760
exploitable

739
00:22:23,760 --> 00:22:25,360
you want a really fast time to that

740
00:22:25,360 --> 00:22:27,600
first find you want a fuzzer that'll

741
00:22:27,600 --> 00:22:29,919
find stuff that other people don't find

742
00:22:29,919 --> 00:22:31,360
because it will increase the value of

743
00:22:31,360 --> 00:22:33,360
your fine and you know the duration

744
00:22:33,360 --> 00:22:34,720
until

745
00:22:34,720 --> 00:22:36,159
probability that your exploit will be

746
00:22:36,159 --> 00:22:38,080
useful as long as possible

747
00:22:38,080 --> 00:22:39,440
and another feature that this group

748
00:22:39,440 --> 00:22:41,360
might be interested in is something that

749
00:22:41,360 --> 00:22:42,720
doesn't require source something that

750
00:22:42,720 --> 00:22:44,320
works in a black box

751
00:22:44,320 --> 00:22:46,320
because if you are a third party or an

752
00:22:46,320 --> 00:22:47,919
external tester

753
00:22:47,919 --> 00:22:49,600
you probably don't have access to the

754
00:22:49,600 --> 00:22:51,120
source all the time

755
00:22:51,120 --> 00:22:52,559
so something that doesn't require that

756
00:22:52,559 --> 00:22:54,720
might be real interesting

757
00:22:54,720 --> 00:22:56,240
so i mentioned a group if i might find

758
00:22:56,240 --> 00:22:58,480
blue buzzer interesting this is them

759
00:22:58,480 --> 00:23:00,799
because live fuzzer exits as soon as it

760
00:23:00,799 --> 00:23:02,080
finds its first crash

761
00:23:02,080 --> 00:23:04,320
it does not waste your cpu resources and

762
00:23:04,320 --> 00:23:05,600
some of the independent researchers i

763
00:23:05,600 --> 00:23:06,640
have talked to

764
00:23:06,640 --> 00:23:08,640
usually have a couple targets going in

765
00:23:08,640 --> 00:23:10,320
sequence and sort of parallel

766
00:23:10,320 --> 00:23:12,320
and so they don't want to spend cpu time

767
00:23:12,320 --> 00:23:13,840
on a target after they've found an

768
00:23:13,840 --> 00:23:15,760
exploit they want to move that cpu over

769
00:23:15,760 --> 00:23:17,840
to the next thing in the sequence

770
00:23:17,840 --> 00:23:19,760
so lib fuzzer exits as soon as it finds

771
00:23:19,760 --> 00:23:21,520
it it doesn't waste cpu resources

772
00:23:21,520 --> 00:23:22,880
looking for anything else

773
00:23:22,880 --> 00:23:24,000
for this group that's actually very

774
00:23:24,000 --> 00:23:26,080
appealing

775
00:23:26,080 --> 00:23:28,480
mopped afl and the magma paper found a

776
00:23:28,480 --> 00:23:30,159
bunch of bugs that other fuzzers didn't

777
00:23:30,159 --> 00:23:30,880
find

778
00:23:30,880 --> 00:23:32,400
the catch was it had to run for seven

779
00:23:32,400 --> 00:23:34,799
days to do that but if you've got the

780
00:23:34,799 --> 00:23:36,080
cpu time and the power

781
00:23:36,080 --> 00:23:37,520
that might be worth it to you to find

782
00:23:37,520 --> 00:23:41,039
stuff that other posers don't find

783
00:23:41,279 --> 00:23:42,880
another group that's similar also in the

784
00:23:42,880 --> 00:23:44,640
security party is

785
00:23:44,640 --> 00:23:46,559
the blue team these are often

786
00:23:46,559 --> 00:23:48,559
applications security engineers they're

787
00:23:48,559 --> 00:23:49,919
security consultants they're often

788
00:23:49,919 --> 00:23:52,080
charged with securing both a product

789
00:23:52,080 --> 00:23:54,080
and an enterprise if they're fortunate

790
00:23:54,080 --> 00:23:55,840
they only have to worry about one

791
00:23:55,840 --> 00:23:58,480
and their goals are slightly different

792
00:23:58,480 --> 00:23:59,360
they want to find all the

793
00:23:59,360 --> 00:24:00,400
vulnerabilities

794
00:24:00,400 --> 00:24:02,240
it's not much good to say do you see

795
00:24:02,240 --> 00:24:04,480
though that i patched a vulnerability

796
00:24:04,480 --> 00:24:05,840
and then we get owned next week by

797
00:24:05,840 --> 00:24:06,640
someone who found a different

798
00:24:06,640 --> 00:24:07,520
vulnerability

799
00:24:07,520 --> 00:24:10,159
you kind of need to patch all the holes

800
00:24:10,159 --> 00:24:10,720
and

801
00:24:10,720 --> 00:24:12,240
you don't necessarily care that much if

802
00:24:12,240 --> 00:24:14,000
other people find them

803
00:24:14,000 --> 00:24:17,440
as long as you find them before release

804
00:24:17,440 --> 00:24:19,440
if they aren't patched before then

805
00:24:19,440 --> 00:24:21,120
that's less of a thing

806
00:24:21,120 --> 00:24:23,279
this group cares a little bit about why

807
00:24:23,279 --> 00:24:24,960
because they want to know if they've got

808
00:24:24,960 --> 00:24:26,880
a systemic security problem like

809
00:24:26,880 --> 00:24:28,240
consistently unsecured

810
00:24:28,240 --> 00:24:31,279
ids or tokens or whether it's like

811
00:24:31,279 --> 00:24:34,559
a one one spot

812
00:24:34,880 --> 00:24:35,679
they're probably gonna look for

813
00:24:35,679 --> 00:24:37,760
something that probes as much of the

814
00:24:37,760 --> 00:24:38,400
product

815
00:24:38,400 --> 00:24:40,400
or target as possible because they need

816
00:24:40,400 --> 00:24:42,000
to find all the vulnerabilities

817
00:24:42,000 --> 00:24:43,520
they're not really as interested in

818
00:24:43,520 --> 00:24:45,360
regular bugs but i do care about finding

819
00:24:45,360 --> 00:24:46,640
all the vulnerabilities

820
00:24:46,640 --> 00:24:47,840
they probably want something that will

821
00:24:47,840 --> 00:24:49,919
complement security practices like

822
00:24:49,919 --> 00:24:51,120
security audits

823
00:24:51,120 --> 00:24:52,480
other tools they'll be looking for

824
00:24:52,480 --> 00:24:53,919
something like basically a security

825
00:24:53,919 --> 00:24:55,520
analysis workflow

826
00:24:55,520 --> 00:24:58,159
it's not super standalone for them and

827
00:24:58,159 --> 00:24:59,679
then fuzzers that might appeal to this

828
00:24:59,679 --> 00:25:00,480
group

829
00:25:00,480 --> 00:25:03,600
aflgo could be a good fit as part of a

830
00:25:03,600 --> 00:25:04,400
code audit

831
00:25:04,400 --> 00:25:06,400
you do the manual audit and you're like

832
00:25:06,400 --> 00:25:07,840
that section over there

833
00:25:07,840 --> 00:25:10,320
that section looks really dodgy and you

834
00:25:10,320 --> 00:25:12,159
point afl go which is a directed buzzer

835
00:25:12,159 --> 00:25:12,799
at it

836
00:25:12,799 --> 00:25:14,159
and see if you can get something out of

837
00:25:14,159 --> 00:25:16,080
that area instead of trying to fuzz the

838
00:25:16,080 --> 00:25:17,600
whole thing and things you think are low

839
00:25:17,600 --> 00:25:19,520
risk you can focus it on high risk areas

840
00:25:19,520 --> 00:25:20,720
code base

841
00:25:20,720 --> 00:25:23,039
hong fuz and afl are code coverage based

842
00:25:23,039 --> 00:25:24,559
give try to give you again a sense of

843
00:25:24,559 --> 00:25:26,559
covering more of the product

844
00:25:26,559 --> 00:25:27,679
and they receive a lot of active

845
00:25:27,679 --> 00:25:29,200
development right now so they might be

846
00:25:29,200 --> 00:25:31,919
good at finding new things

847
00:25:31,919 --> 00:25:33,360
these are not like hard and fast

848
00:25:33,360 --> 00:25:35,039
recommendations but i want you to think

849
00:25:35,039 --> 00:25:36,159
through the logic of

850
00:25:36,159 --> 00:25:37,760
what your goals are what features you

851
00:25:37,760 --> 00:25:40,000
want to find in a fuzzer

852
00:25:40,000 --> 00:25:42,720
and what fuzzers might have those the

853
00:25:42,720 --> 00:25:44,000
next party is one that

854
00:25:44,000 --> 00:25:46,320
sort of knew and these are sort of the

855
00:25:46,320 --> 00:25:47,440
software owners

856
00:25:47,440 --> 00:25:49,039
you could be an engineering manager a

857
00:25:49,039 --> 00:25:50,960
lead software engineer qa

858
00:25:50,960 --> 00:25:53,760
engineer a triage engineer sometimes as

859
00:25:53,760 --> 00:25:55,279
an engineering lead an engineering

860
00:25:55,279 --> 00:25:56,080
manager

861
00:25:56,080 --> 00:25:58,080
you spend a lot of time in triage my

862
00:25:58,080 --> 00:26:00,000
personal record is 36 hours in a single

863
00:26:00,000 --> 00:26:00,559
week

864
00:26:00,559 --> 00:26:02,240
and six and a half hours in triage in a

865
00:26:02,240 --> 00:26:04,880
single setting

866
00:26:04,960 --> 00:26:06,640
so if you're part of this group you care

867
00:26:06,640 --> 00:26:08,480
about finding all the vulnerabilities

868
00:26:08,480 --> 00:26:10,000
you also care about finding all the

869
00:26:10,000 --> 00:26:11,600
non-exploitable bugs

870
00:26:11,600 --> 00:26:13,520
a crash or hang even if it's not

871
00:26:13,520 --> 00:26:15,360
exploitable is still a problem that you

872
00:26:15,360 --> 00:26:16,640
need to fix

873
00:26:16,640 --> 00:26:17,919
you generally want to find them before

874
00:26:17,919 --> 00:26:19,760
release so you can triage them even if

875
00:26:19,760 --> 00:26:21,039
you decide not to fix them before

876
00:26:21,039 --> 00:26:22,159
release

877
00:26:22,159 --> 00:26:25,279
and you really care about why if you've

878
00:26:25,279 --> 00:26:26,720
ever seen a bug report

879
00:26:26,720 --> 00:26:28,559
the more detail about why this is a

880
00:26:28,559 --> 00:26:30,720
problem the faster i'm able to assess

881
00:26:30,720 --> 00:26:32,159
how much engineering effort is needed to

882
00:26:32,159 --> 00:26:34,400
fix it which group should do it

883
00:26:34,400 --> 00:26:35,919
and generally how to get that in the

884
00:26:35,919 --> 00:26:37,440
pipeline faster

885
00:26:37,440 --> 00:26:39,120
bug reports are like it doesn't work i'm

886
00:26:39,120 --> 00:26:40,400
like well we have to budget time to

887
00:26:40,400 --> 00:26:42,080
figure out and triage and

888
00:26:42,080 --> 00:26:43,679
diagnose it and that means that i don't

889
00:26:43,679 --> 00:26:45,600
know how big of a piece of work this is

890
00:26:45,600 --> 00:26:48,000
and those tend to fall to the bottom as

891
00:26:48,000 --> 00:26:49,919
a software owner vulnerability reports

892
00:26:49,919 --> 00:26:52,159
are just one type of bug report and i

893
00:26:52,159 --> 00:26:54,400
have to worry about all of them

894
00:26:54,400 --> 00:26:56,080
so why could be very important to this

895
00:26:56,080 --> 00:26:57,679
group

896
00:26:57,679 --> 00:27:00,240
so you might look for targeting specific

897
00:27:00,240 --> 00:27:01,360
commits

898
00:27:01,360 --> 00:27:04,000
cicd integration the fewer interruptions

899
00:27:04,000 --> 00:27:06,000
to your workflow the better that goes

900
00:27:06,000 --> 00:27:09,760
testing stability you want the photo to

901
00:27:09,760 --> 00:27:11,440
perform server reliably

902
00:27:11,440 --> 00:27:12,480
you're probably interested in more than

903
00:27:12,480 --> 00:27:14,080
just vulnerabilities if it crashes your

904
00:27:14,080 --> 00:27:15,760
program it's still bad

905
00:27:15,760 --> 00:27:17,279
and then code coverage again might

906
00:27:17,279 --> 00:27:19,279
interest you because you want to sort of

907
00:27:19,279 --> 00:27:20,960
cover all of your code base you're

908
00:27:20,960 --> 00:27:24,240
responsible for all of it

909
00:27:24,320 --> 00:27:25,520
and for this group i actually think

910
00:27:25,520 --> 00:27:28,000
classic fuzz testing has a lot to offer

911
00:27:28,000 --> 00:27:30,080
because it finds crashes hangs or

912
00:27:30,080 --> 00:27:32,000
inconsistent behavior

913
00:27:32,000 --> 00:27:33,600
much which may not be exploitable but is

914
00:27:33,600 --> 00:27:35,840
still your problem as a software owner

915
00:27:35,840 --> 00:27:37,840
tofu is a fuzzer that was built

916
00:27:37,840 --> 00:27:40,159
explicitly for the cicd pipeline that is

917
00:27:40,159 --> 00:27:41,600
what it's designed for

918
00:27:41,600 --> 00:27:43,279
and then microsoft one fuzz is a new

919
00:27:43,279 --> 00:27:44,799
player on the scene i haven't personally

920
00:27:44,799 --> 00:27:45,679
played with it

921
00:27:45,679 --> 00:27:48,480
but it does market itself as for

922
00:27:48,480 --> 00:27:50,000
developers and for a development

923
00:27:50,000 --> 00:27:52,480
pipeline

924
00:27:53,039 --> 00:27:55,279
now our last group is a little bit

925
00:27:55,279 --> 00:27:56,399
strange because

926
00:27:56,399 --> 00:27:58,720
its goals vary i've met academic

927
00:27:58,720 --> 00:28:00,080
researchers who bleed

928
00:28:00,080 --> 00:28:02,720
blue academic researchers that see only

929
00:28:02,720 --> 00:28:03,760
red

930
00:28:03,760 --> 00:28:05,679
some that are focused solely on training

931
00:28:05,679 --> 00:28:07,360
next generation of software engineers to

932
00:28:07,360 --> 00:28:07,919
write better

933
00:28:07,919 --> 00:28:09,840
more secure code and others that are

934
00:28:09,840 --> 00:28:11,919
starting more fundamental aspects of

935
00:28:11,919 --> 00:28:13,440
computer science

936
00:28:13,440 --> 00:28:14,880
they're not really interested in

937
00:28:14,880 --> 00:28:16,559
security for security stake it's how

938
00:28:16,559 --> 00:28:18,640
they explore their area of research

939
00:28:18,640 --> 00:28:20,399
and security happens to be the path that

940
00:28:20,399 --> 00:28:23,120
leads through that

941
00:28:23,120 --> 00:28:24,480
if you're in this group the thing you're

942
00:28:24,480 --> 00:28:26,159
generally looking for is a benchmark

943
00:28:26,159 --> 00:28:27,520
you're looking for a good substrate to

944
00:28:27,520 --> 00:28:29,279
test your new ideas you're looking for

945
00:28:29,279 --> 00:28:30,720
something publishable and something

946
00:28:30,720 --> 00:28:32,240
citable

947
00:28:32,240 --> 00:28:34,000
your super secret fuzzer that i can't

948
00:28:34,000 --> 00:28:35,840
talk about is very difficult to use

949
00:28:35,840 --> 00:28:38,240
my job is to talk about stuff or do

950
00:28:38,240 --> 00:28:39,520
research on stuff and then publish

951
00:28:39,520 --> 00:28:42,320
papers about it

952
00:28:42,720 --> 00:28:44,000
and then sponsors that are appealing to

953
00:28:44,000 --> 00:28:45,919
this group are generally afl

954
00:28:45,919 --> 00:28:47,520
afl is the benchmark to end all

955
00:28:47,520 --> 00:28:49,919
benchmarks i've only seen a few fuzzing

956
00:28:49,919 --> 00:28:52,399
papers that don't include it

957
00:28:52,399 --> 00:28:55,919
it's given rise to at least 28 different

958
00:28:55,919 --> 00:28:58,799
buzzers such as aflgo afl plus plus i

959
00:28:58,799 --> 00:29:00,399
stopped counting at 28 and easily a

960
00:29:00,399 --> 00:29:01,840
dozen have come out since i stopped

961
00:29:01,840 --> 00:29:03,200
counting a year ago

962
00:29:03,200 --> 00:29:04,799
a lot of times what we do is academics

963
00:29:04,799 --> 00:29:06,480
we eventually develop our own to test

964
00:29:06,480 --> 00:29:10,159
new optimizations and new features

965
00:29:11,200 --> 00:29:13,679
so talking about afl let's talk about

966
00:29:13,679 --> 00:29:14,720
afl

967
00:29:14,720 --> 00:29:17,520
afl is arguably the most famous buzzer

968
00:29:17,520 --> 00:29:18,559
in the world

969
00:29:18,559 --> 00:29:20,960
it is named after a breed of bunny i

970
00:29:20,960 --> 00:29:22,399
cannot convince google that i'm not

971
00:29:22,399 --> 00:29:23,840
interested in the australian football

972
00:29:23,840 --> 00:29:25,520
league

973
00:29:25,520 --> 00:29:28,559
but if you are in security afl

974
00:29:28,559 --> 00:29:31,600
means the buzzer it is so famous it

975
00:29:31,600 --> 00:29:34,480
needs shades when it goes out in public

976
00:29:34,480 --> 00:29:36,640
it was developed as a side project by an

977
00:29:36,640 --> 00:29:37,520
engineer at google

978
00:29:37,520 --> 00:29:39,120
and kind of took over the world

979
00:29:39,120 --> 00:29:41,760
partially because it was open source

980
00:29:41,760 --> 00:29:44,960
so characteristics is grey box we are

981
00:29:44,960 --> 00:29:47,440
working with an instrumented binary

982
00:29:47,440 --> 00:29:49,840
it usually uses mutation although i have

983
00:29:49,840 --> 00:29:51,360
i'm aware that there's a grammar-based

984
00:29:51,360 --> 00:29:52,399
extension

985
00:29:52,399 --> 00:29:54,000
should you feel that it's necessary you

986
00:29:54,000 --> 00:29:55,919
can use dictionaries to tune the mutator

987
00:29:55,919 --> 00:29:57,600
to only mutate certain sections which

988
00:29:57,600 --> 00:29:59,600
sort of gets into generational

989
00:29:59,600 --> 00:30:01,919
but that might be a bit of a detail it

990
00:30:01,919 --> 00:30:03,520
defines interesting as an increasing

991
00:30:03,520 --> 00:30:04,799
code coverage

992
00:30:04,799 --> 00:30:08,880
or a crash or hang you can exit it by

993
00:30:08,880 --> 00:30:10,799
setting a timer using ctrl c with your

994
00:30:10,799 --> 00:30:12,720
board with it or in theory it can run

995
00:30:12,720 --> 00:30:14,240
out of seeds

996
00:30:14,240 --> 00:30:16,159
i've never met anyone who has ever seen

997
00:30:16,159 --> 00:30:18,159
afl run out of inputs to test

998
00:30:18,159 --> 00:30:21,279
but it is theoretically possible and

999
00:30:21,279 --> 00:30:23,200
then we have a thing called a driver

1000
00:30:23,200 --> 00:30:25,440
also known as a harness this is a glue

1001
00:30:25,440 --> 00:30:27,840
or translator program between the target

1002
00:30:27,840 --> 00:30:30,320
and the fuzzer not all fuzzer and target

1003
00:30:30,320 --> 00:30:31,679
combinations need them

1004
00:30:31,679 --> 00:30:33,600
but usually when you're working with afl

1005
00:30:33,600 --> 00:30:34,880
you probably do

1006
00:30:34,880 --> 00:30:37,520
afl largely only speaks standard in and

1007
00:30:37,520 --> 00:30:38,880
if your program does not speak to

1008
00:30:38,880 --> 00:30:39,760
standardin

1009
00:30:39,760 --> 00:30:41,200
you're going to write some code in in

1010
00:30:41,200 --> 00:30:43,200
between and that code is actually very

1011
00:30:43,200 --> 00:30:44,720
important to getting

1012
00:30:44,720 --> 00:30:48,240
efficiency out of afl afl has a lot of

1013
00:30:48,240 --> 00:30:50,399
parameters to tune

1014
00:30:50,399 --> 00:30:53,760
please use them afl is very easy to get

1015
00:30:53,760 --> 00:30:55,039
started with and i think that accounts

1016
00:30:55,039 --> 00:30:56,399
for a lot of its popularity is it's

1017
00:30:56,399 --> 00:30:58,000
really easy to spin it up and get it

1018
00:30:58,000 --> 00:30:58,640
started

1019
00:30:58,640 --> 00:31:00,880
but to really really get good

1020
00:31:00,880 --> 00:31:01,679
performance

1021
00:31:01,679 --> 00:31:04,159
and efficiency and awesomeness out of it

1022
00:31:04,159 --> 00:31:05,440
you're going to need to spend a fair

1023
00:31:05,440 --> 00:31:08,640
amount of time and effort on it

1024
00:31:08,960 --> 00:31:10,799
and like all good superstars it has a

1025
00:31:10,799 --> 00:31:12,720
posse of tools to help you with that

1026
00:31:12,720 --> 00:31:14,399
the ones i recommend for new people are

1027
00:31:14,399 --> 00:31:17,120
afl min and afl plot

1028
00:31:17,120 --> 00:31:20,720
but it has a small zoo so

1029
00:31:20,720 --> 00:31:22,559
things i've seen people screw up with

1030
00:31:22,559 --> 00:31:24,159
afl

1031
00:31:24,159 --> 00:31:25,840
first of all is understanding that afl

1032
00:31:25,840 --> 00:31:27,200
has a life cycle

1033
00:31:27,200 --> 00:31:29,200
we start with you and the target program

1034
00:31:29,200 --> 00:31:31,039
and figuring out what buzzer you want

1035
00:31:31,039 --> 00:31:32,159
in this case i'm going to assume you

1036
00:31:32,159 --> 00:31:34,640
decide it's afl you probably

1037
00:31:34,640 --> 00:31:36,399
need to think a little about that there

1038
00:31:36,399 --> 00:31:38,320
are many many more fuzzers in the world

1039
00:31:38,320 --> 00:31:39,600
you do prep work you're going to get

1040
00:31:39,600 --> 00:31:41,279
your initial seeds your initial inputs

1041
00:31:41,279 --> 00:31:42,640
you're going to write a harness

1042
00:31:42,640 --> 00:31:45,519
here lovingly drawn as a harness to help

1043
00:31:45,519 --> 00:31:47,200
you carry the box

1044
00:31:47,200 --> 00:31:48,320
you're then going to tune some

1045
00:31:48,320 --> 00:31:50,000
parameters you're going to feed it to

1046
00:31:50,000 --> 00:31:51,279
afl on the server

1047
00:31:51,279 --> 00:31:53,360
it's going to run you're getting a bunch

1048
00:31:53,360 --> 00:31:55,120
of stuff in the results directory

1049
00:31:55,120 --> 00:31:56,480
you need to review that and try to

1050
00:31:56,480 --> 00:31:58,080
understand it and you're probably going

1051
00:31:58,080 --> 00:31:59,519
to need to rerun some of it to test to

1052
00:31:59,519 --> 00:32:01,760
see if it actually works

1053
00:32:01,760 --> 00:32:02,960
if you're lucky you get the thing you

1054
00:32:02,960 --> 00:32:04,559
wanted if you're not you might have to

1055
00:32:04,559 --> 00:32:06,559
go back and start the process again

1056
00:32:06,559 --> 00:32:07,760
so everyone comfortable with sort of

1057
00:32:07,760 --> 00:32:10,080
this life cycle diagram cool

1058
00:32:10,080 --> 00:32:11,519
so the thing i see people screw up and

1059
00:32:11,519 --> 00:32:13,200
start is they don't realize that they

1060
00:32:13,200 --> 00:32:14,960
need to have the source to instrument

1061
00:32:14,960 --> 00:32:18,159
you can run afl as a black box it's not

1062
00:32:18,159 --> 00:32:19,840
great it's not very effective

1063
00:32:19,840 --> 00:32:22,159
it doesn't do well afl is not really

1064
00:32:22,159 --> 00:32:23,600
worth running

1065
00:32:23,600 --> 00:32:25,200
if you don't have the ability to

1066
00:32:25,200 --> 00:32:27,679
instrument the prep step also gets

1067
00:32:27,679 --> 00:32:28,640
neglected

1068
00:32:28,640 --> 00:32:30,000
you should spend the time to develop a

1069
00:32:30,000 --> 00:32:31,360
good initial purpose those are the

1070
00:32:31,360 --> 00:32:33,600
initial inputs you feed the fuzzer

1071
00:32:33,600 --> 00:32:34,880
you should spend some time working on

1072
00:32:34,880 --> 00:32:36,480
making sure your driver and or harnesses

1073
00:32:36,480 --> 00:32:37,679
are good to go

1074
00:32:37,679 --> 00:32:40,080
one single function call and one driver

1075
00:32:40,080 --> 00:32:41,279
is unlikely to

1076
00:32:41,279 --> 00:32:44,320
really leverage the full power of afl

1077
00:32:44,320 --> 00:32:46,080
and you should pay special attention to

1078
00:32:46,080 --> 00:32:47,519
things like shared libraries

1079
00:32:47,519 --> 00:32:49,039
you really really want to instrument the

1080
00:32:49,039 --> 00:32:50,640
whole binary

1081
00:32:50,640 --> 00:32:52,080
otherwise it treats things it doesn't

1082
00:32:52,080 --> 00:32:53,760
instrument as black boxes

1083
00:32:53,760 --> 00:32:55,279
and we're back to basically random

1084
00:32:55,279 --> 00:32:58,320
fuzzing it's not not very effective

1085
00:32:58,320 --> 00:33:02,000
i see people ignoring parameters

1086
00:33:02,000 --> 00:33:03,519
you should tune them they can be very

1087
00:33:03,519 --> 00:33:05,039
effective be careful with the app

1088
00:33:05,039 --> 00:33:07,360
parameter it lets you chew on file names

1089
00:33:07,360 --> 00:33:09,200
but sometimes people chew on file names

1090
00:33:09,200 --> 00:33:11,440
and not the actual body of the seed

1091
00:33:11,440 --> 00:33:13,840
and that can be a problem and then when

1092
00:33:13,840 --> 00:33:14,640
you're running it

1093
00:33:14,640 --> 00:33:16,559
afl is very fussy about its processor

1094
00:33:16,559 --> 00:33:19,120
settings you usually need root or admin

1095
00:33:19,120 --> 00:33:19,840
access

1096
00:33:19,840 --> 00:33:22,000
to change those if you don't have it it

1097
00:33:22,000 --> 00:33:23,440
can be hard to get afl to do something

1098
00:33:23,440 --> 00:33:25,200
useful for you

1099
00:33:25,200 --> 00:33:27,279
and then running the fuzzer long enough

1100
00:33:27,279 --> 00:33:28,960
uh one of the things i think surprises

1101
00:33:28,960 --> 00:33:30,399
people is realizing how long you really

1102
00:33:30,399 --> 00:33:31,519
need to run a fuzzer

1103
00:33:31,519 --> 00:33:33,200
to be certain it's effective i'll get

1104
00:33:33,200 --> 00:33:34,640
soon so like i've run it for 30 minutes

1105
00:33:34,640 --> 00:33:36,000
nothing happens it's broken i'm like

1106
00:33:36,000 --> 00:33:36,880
well you know

1107
00:33:36,880 --> 00:33:39,360
going rates 24 hours might even be a

1108
00:33:39,360 --> 00:33:39,919
week

1109
00:33:39,919 --> 00:33:42,159
and their jaws hit the floor and they

1110
00:33:42,159 --> 00:33:43,760
stare at me in sad disbelief i'm like

1111
00:33:43,760 --> 00:33:44,880
well you see you're gonna have to wait a

1112
00:33:44,880 --> 00:33:45,679
while

1113
00:33:45,679 --> 00:33:47,279
like what the homeworks do in two hours

1114
00:33:47,279 --> 00:33:48,799
like well you should have started

1115
00:33:48,799 --> 00:33:50,840
earlier

1116
00:33:50,840 --> 00:33:53,200
um and sometimes you'll have to repeat

1117
00:33:53,200 --> 00:33:54,399
the buzzer

1118
00:33:54,399 --> 00:33:56,159
in research we expect to repeat

1119
00:33:56,159 --> 00:33:58,159
fuzzering runs at least 10 times to

1120
00:33:58,159 --> 00:33:58,799
account for

1121
00:33:58,799 --> 00:34:00,159
some of the stochastic nature in the

1122
00:34:00,159 --> 00:34:02,960
variances one single fuzzeron may not be

1123
00:34:02,960 --> 00:34:04,399
representative of what the fuzzer can

1124
00:34:04,399 --> 00:34:06,080
find because it's kind of a roll of the

1125
00:34:06,080 --> 00:34:08,079
dice you get lucky sometimes and

1126
00:34:08,079 --> 00:34:09,359
sometimes you don't

1127
00:34:09,359 --> 00:34:12,480
and you'll need to understand that so

1128
00:34:12,480 --> 00:34:14,399
then reviewing and analyzing the results

1129
00:34:14,399 --> 00:34:16,000
a lot of people do not budget enough

1130
00:34:16,000 --> 00:34:18,079
time for this this can be longer than

1131
00:34:18,079 --> 00:34:19,119
the fuzzer runs

1132
00:34:19,119 --> 00:34:20,879
to fully review and understand your

1133
00:34:20,879 --> 00:34:23,280
results and one of the gotchas is that

1134
00:34:23,280 --> 00:34:24,960
people see the crash counts like whoa

1135
00:34:24,960 --> 00:34:27,119
i found a bunch of stuff well the crash

1136
00:34:27,119 --> 00:34:28,879
is not necessarily a vulnerability

1137
00:34:28,879 --> 00:34:32,239
not all crashes are exploitable and

1138
00:34:32,239 --> 00:34:35,040
afl is actually rather bad about

1139
00:34:35,040 --> 00:34:36,239
counting

1140
00:34:36,239 --> 00:34:37,679
and telling you what it's got it's

1141
00:34:37,679 --> 00:34:39,119
pretty sure when it's found something

1142
00:34:39,119 --> 00:34:40,639
but exactly how many things is sort of

1143
00:34:40,639 --> 00:34:41,839
an open question

1144
00:34:41,839 --> 00:34:43,119
it does try to figure out if you got

1145
00:34:43,119 --> 00:34:45,440
unique crashes but my personal record is

1146
00:34:45,440 --> 00:34:46,239
52

1147
00:34:46,239 --> 00:34:49,280
unique crashes for four source bugs

1148
00:34:49,280 --> 00:34:51,359
there's a lot of duplicate crashes to go

1149
00:34:51,359 --> 00:34:52,560
through and figure out that they're not

1150
00:34:52,560 --> 00:34:53,119
real

1151
00:34:53,119 --> 00:34:56,000
i actually only had four four problems

1152
00:34:56,000 --> 00:34:57,440
so that can be a great place where you

1153
00:34:57,440 --> 00:35:00,839
spend a lot of effort without realizing

1154
00:35:00,839 --> 00:35:02,720
it

1155
00:35:02,720 --> 00:35:04,640
now oh if you remember nothing else from

1156
00:35:04,640 --> 00:35:05,920
this talk

1157
00:35:05,920 --> 00:35:07,520
if you don't remember what fuzzing is if

1158
00:35:07,520 --> 00:35:10,000
you remember this i will be happy

1159
00:35:10,000 --> 00:35:11,440
this is a friend of mine who's a very

1160
00:35:11,440 --> 00:35:13,359
accomplished vulnerability researcher

1161
00:35:13,359 --> 00:35:16,880
she prefers to remain nameless so

1162
00:35:16,880 --> 00:35:19,119
we're just going to quote her but she is

1163
00:35:19,119 --> 00:35:20,400
very insistent that the two most

1164
00:35:20,400 --> 00:35:21,839
important things in fuzzing

1165
00:35:21,839 --> 00:35:23,599
are a good harness program that probes

1166
00:35:23,599 --> 00:35:27,200
your target and really good seeds

1167
00:35:28,320 --> 00:35:29,599
the next question people then ask me is

1168
00:35:29,599 --> 00:35:30,800
like well all right how do i get good

1169
00:35:30,800 --> 00:35:33,280
seed you convinced me i need good seeds

1170
00:35:33,280 --> 00:35:34,800
well in the general case we really don't

1171
00:35:34,800 --> 00:35:36,400
know what an optimal purpose

1172
00:35:36,400 --> 00:35:38,640
looks like so i can give you heuristics

1173
00:35:38,640 --> 00:35:39,760
and things i've done

1174
00:35:39,760 --> 00:35:41,839
but i cannot say that like we know how

1175
00:35:41,839 --> 00:35:43,440
good this advice is because we can't

1176
00:35:43,440 --> 00:35:44,800
really evaluate it

1177
00:35:44,800 --> 00:35:46,160
general you want us to get to know the

1178
00:35:46,160 --> 00:35:48,240
target run it a few times

1179
00:35:48,240 --> 00:35:51,280
examine the source examine the binary

1180
00:35:51,280 --> 00:35:53,280
things i have personally done to get a

1181
00:35:53,280 --> 00:35:54,800
good initial corpus

1182
00:35:54,800 --> 00:35:56,720
or an initial corpus i should say is

1183
00:35:56,720 --> 00:35:58,640
i've rated the unit test directories of

1184
00:35:58,640 --> 00:36:00,400
the project if they're available

1185
00:36:00,400 --> 00:36:02,400
i've run strings in a binary and edited

1186
00:36:02,400 --> 00:36:03,599
down to the strings i think are

1187
00:36:03,599 --> 00:36:04,640
interesting

1188
00:36:04,640 --> 00:36:06,320
i've run the program a few times and

1189
00:36:06,320 --> 00:36:07,760
found a few valid inputs i'm like

1190
00:36:07,760 --> 00:36:09,520
alright that's close enough to start

1191
00:36:09,520 --> 00:36:12,160
or as a lot of people do is you do some

1192
00:36:12,160 --> 00:36:13,920
reverse engineering

1193
00:36:13,920 --> 00:36:16,000
to really figure out what you want and

1194
00:36:16,000 --> 00:36:17,520
where it looks interesting

1195
00:36:17,520 --> 00:36:19,680
as a friend previously quoted says she

1196
00:36:19,680 --> 00:36:20,960
spends

1197
00:36:20,960 --> 00:36:22,480
more than half her time doing the

1198
00:36:22,480 --> 00:36:24,000
reverse engineering then doing the

1199
00:36:24,000 --> 00:36:25,359
fuzzing to make sure the fuzzer is

1200
00:36:25,359 --> 00:36:26,800
pointed at the right stuff

1201
00:36:26,800 --> 00:36:28,560
with the right seeds to find the things

1202
00:36:28,560 --> 00:36:30,560
that she has identified as problematic

1203
00:36:30,560 --> 00:36:33,119
in the reverse engineering afl has a

1204
00:36:33,119 --> 00:36:34,800
thing called afl min that will help you

1205
00:36:34,800 --> 00:36:36,079
keep your test

1206
00:36:36,079 --> 00:36:38,400
your corpus like lean and mean in good

1207
00:36:38,400 --> 00:36:39,520
fighting shape

1208
00:36:39,520 --> 00:36:41,359
if you've come up with a couple seeds

1209
00:36:41,359 --> 00:36:42,560
you want to make sure there's no

1210
00:36:42,560 --> 00:36:46,240
no cruft that's a good tool to run

1211
00:36:47,359 --> 00:36:49,359
and then before we get into the lab i'm

1212
00:36:49,359 --> 00:36:50,560
going to do something slightly out of

1213
00:36:50,560 --> 00:36:51,119
order

1214
00:36:51,119 --> 00:36:52,560
i'd like to thank the shakatikan

1215
00:36:52,560 --> 00:36:53,920
organizers because they've been busting

1216
00:36:53,920 --> 00:36:55,359
their butts for months to put this on

1217
00:36:55,359 --> 00:36:57,440
and it's been a fabulous success

1218
00:36:57,440 --> 00:36:59,200
if you have some time please say thank

1219
00:36:59,200 --> 00:37:01,200
you because they have done a lot of work

1220
00:37:01,200 --> 00:37:02,480
i'd like to thank my long-suffering

1221
00:37:02,480 --> 00:37:04,480
advisor dr wu seong-feng the national

1222
00:37:04,480 --> 00:37:05,760
science foundation that

1223
00:37:05,760 --> 00:37:06,960
funded the work that put together this

1224
00:37:06,960 --> 00:37:08,880
lab you're about to do the security lab

1225
00:37:08,880 --> 00:37:10,960
here at portland state and my movie crew

1226
00:37:10,960 --> 00:37:12,000
and guinea pigs

1227
00:37:12,000 --> 00:37:13,920
who have patiently listened to me give

1228
00:37:13,920 --> 00:37:16,160
many practice versions of this talk

1229
00:37:16,160 --> 00:37:17,599
also a couple papers that might be

1230
00:37:17,599 --> 00:37:19,359
interesting if you read

1231
00:37:19,359 --> 00:37:21,599
only one of these read the relevance of

1232
00:37:21,599 --> 00:37:23,520
classic fuzz testing how we solve this

1233
00:37:23,520 --> 00:37:24,079
one

1234
00:37:24,079 --> 00:37:26,079
it's a good tour of 30 years of classic

1235
00:37:26,079 --> 00:37:29,839
buzzing what fuzzing can still do

1236
00:37:31,280 --> 00:37:34,480
fun time alright so here is the lab

1237
00:37:34,480 --> 00:37:36,640
it is public is available it'll be on

1238
00:37:36,640 --> 00:37:38,160
the internet around the clock

1239
00:37:38,160 --> 00:37:39,680
so if you do not feel like doing with it

1240
00:37:39,680 --> 00:37:41,440
at nine in the morning and i never want

1241
00:37:41,440 --> 00:37:42,880
to touch code at nine in the morning so

1242
00:37:42,880 --> 00:37:43,520
i

1243
00:37:43,520 --> 00:37:46,480
very very sympathetic uh the link will

1244
00:37:46,480 --> 00:37:46,960
be up

1245
00:37:46,960 --> 00:37:49,359
it's public it does use docker and it

1246
00:37:49,359 --> 00:37:50,720
does use gcp

1247
00:37:50,720 --> 00:37:52,640
i have done it locally but i have never

1248
00:37:52,640 --> 00:37:53,920
done it on windows so if you're on

1249
00:37:53,920 --> 00:37:55,839
windows i'm not sure i can help you

1250
00:37:55,839 --> 00:37:58,320
but i can try you can find me via email

1251
00:37:58,320 --> 00:37:59,839
or you can find me on discord

1252
00:37:59,839 --> 00:38:01,359
i'm generally more active on discord on

1253
00:38:01,359 --> 00:38:02,880
the weekends

1254
00:38:02,880 --> 00:38:04,960
or at night in portland time which is

1255
00:38:04,960 --> 00:38:06,240
morning for you guys

1256
00:38:06,240 --> 00:38:08,400
so during the day i'm often not

1257
00:38:08,400 --> 00:38:10,079
available so i've got to do other stuff

1258
00:38:10,079 --> 00:38:13,520
so thank you for listening and if you

1259
00:38:13,520 --> 00:38:14,720
have questions i'll take them now if you

1260
00:38:14,720 --> 00:38:16,160
want to get started on the lab

1261
00:38:16,160 --> 00:38:19,839
that's cool too

1262
00:38:22,560 --> 00:38:25,520
hi yeah there are some questions which i

1263
00:38:25,520 --> 00:38:26,960
can ask you right now

1264
00:38:26,960 --> 00:38:29,200
and the labs are to be done offline

1265
00:38:29,200 --> 00:38:31,040
right um

1266
00:38:31,040 --> 00:38:34,079
they can start them now okay i did them

1267
00:38:34,079 --> 00:38:35,680
a few weeks ago so they should all still

1268
00:38:35,680 --> 00:38:36,720
be good and the directions should all

1269
00:38:36,720 --> 00:38:38,079
still be up to date

1270
00:38:38,079 --> 00:38:41,440
okay but if they want to put them off

1271
00:38:41,440 --> 00:38:42,640
that's cool if they want to start them

1272
00:38:42,640 --> 00:38:45,920
now they want to go have a drink of tea

1273
00:38:45,920 --> 00:38:48,800
i'm not gonna argue

1274
00:38:48,800 --> 00:38:50,079
yeah all right yeah so the first

1275
00:38:50,079 --> 00:38:53,040
question is uh did you draw your own

1276
00:38:53,040 --> 00:38:54,960
pictures

1277
00:38:54,960 --> 00:38:57,280
yes it took an excruciatingly long

1278
00:38:57,280 --> 00:38:58,720
amount of time i went through six

1279
00:38:58,720 --> 00:39:00,720
drawing programs i've officially learned

1280
00:39:00,720 --> 00:39:02,320
how to use an apple pencil for the first

1281
00:39:02,320 --> 00:39:04,320
time

1282
00:39:04,320 --> 00:39:06,240
uh yes i drew those diagrams anything

1283
00:39:06,240 --> 00:39:07,520
that doesn't have a

1284
00:39:07,520 --> 00:39:09,920
credit or source i i drew or took a

1285
00:39:09,920 --> 00:39:12,400
picture of

1286
00:39:12,839 --> 00:39:16,720
okay um the next question

1287
00:39:16,720 --> 00:39:18,960
what essential computer science skills

1288
00:39:18,960 --> 00:39:20,000
do you recommend

1289
00:39:20,000 --> 00:39:23,040
someone has

1290
00:39:23,040 --> 00:39:25,680
someone has as a basic foundation before

1291
00:39:25,680 --> 00:39:26,240
they get

1292
00:39:26,240 --> 00:39:30,079
into fuzzing programming languages

1293
00:39:30,079 --> 00:39:31,839
programming languages or knowledge of

1294
00:39:31,839 --> 00:39:34,400
assembly or something

1295
00:39:34,400 --> 00:39:36,480
well a little bit of all three

1296
00:39:36,480 --> 00:39:38,240
algorithms is a good thing there is a

1297
00:39:38,240 --> 00:39:39,040
lot of heavy

1298
00:39:39,040 --> 00:39:42,320
pl theory in some of the leading edge

1299
00:39:42,320 --> 00:39:44,800
fuzzers

1300
00:39:44,800 --> 00:39:47,200
there is a lot of type theory in there

1301
00:39:47,200 --> 00:39:48,000
as well

1302
00:39:48,000 --> 00:39:50,800
i'm more on the system's practical end

1303
00:39:50,800 --> 00:39:51,119
so

1304
00:39:51,119 --> 00:39:52,880
i am evaluating buzzer performance as

1305
00:39:52,880 --> 00:39:54,400
opposed to building my own fuzzer right

1306
00:39:54,400 --> 00:39:55,359
now

1307
00:39:55,359 --> 00:39:57,359
but there is actually a fair amount of

1308
00:39:57,359 --> 00:40:00,319
theory that shows up

1309
00:40:00,880 --> 00:40:02,880
uh the reverse engineering aspect is

1310
00:40:02,880 --> 00:40:04,640
certainly a thing that is used by people

1311
00:40:04,640 --> 00:40:05,520
who are using fuzzing

1312
00:40:05,520 --> 00:40:06,640
in practice so i think there's a little

1313
00:40:06,640 --> 00:40:07,760
bit of a split whether you're so

1314
00:40:07,760 --> 00:40:08,960
interested in building

1315
00:40:08,960 --> 00:40:11,200
the next greatest buzzer or using the

1316
00:40:11,200 --> 00:40:12,640
existing fuzzers

1317
00:40:12,640 --> 00:40:14,720
effectively i think a lot of founding

1318
00:40:14,720 --> 00:40:15,920
and reverse engineering

1319
00:40:15,920 --> 00:40:18,079
and binary analysis is extremely helpful

1320
00:40:18,079 --> 00:40:19,040
if you're trying to use these in a

1321
00:40:19,040 --> 00:40:20,480
practical sense

1322
00:40:20,480 --> 00:40:21,680
if you are interested in building the

1323
00:40:21,680 --> 00:40:23,359
next one then more foundational things

1324
00:40:23,359 --> 00:40:24,880
like algorithms pl

1325
00:40:24,880 --> 00:40:28,160
type theory are much more relevant i go

1326
00:40:28,160 --> 00:40:29,599
to a fuzzing reading group and whenever

1327
00:40:29,599 --> 00:40:30,319
they hit like

1328
00:40:30,319 --> 00:40:32,240
a new fuzzing paper with a novel

1329
00:40:32,240 --> 00:40:34,720
methodology i spend half the paper

1330
00:40:34,720 --> 00:40:37,599
asking people what it does because my

1331
00:40:37,599 --> 00:40:38,880
theory background

1332
00:40:38,880 --> 00:40:41,599
is not it's rather rusty somewhere

1333
00:40:41,599 --> 00:40:43,440
there's a cave painting that depicts my

1334
00:40:43,440 --> 00:40:44,800
graduation from cmu

1335
00:40:44,800 --> 00:40:48,000
it was a very long time ago thus

1336
00:40:48,000 --> 00:40:49,280
a lot of that stuff is things i have

1337
00:40:49,280 --> 00:40:53,839
long forgotten

1338
00:40:54,560 --> 00:40:57,839
okay um the next question

1339
00:40:57,839 --> 00:41:00,720
uh when studying fuzzing are there

1340
00:41:00,720 --> 00:41:01,440
benchmark

1341
00:41:01,440 --> 00:41:04,000
programs that people fuss against to

1342
00:41:04,000 --> 00:41:06,240
check performances

1343
00:41:06,240 --> 00:41:09,920
yes so in 2018 a paper comes out called

1344
00:41:09,920 --> 00:41:10,880
evaluating fuzz

1345
00:41:10,880 --> 00:41:13,760
testing it's extremely controversial it

1346
00:41:13,760 --> 00:41:15,119
rifles through a lot of fuzzing

1347
00:41:15,119 --> 00:41:16,240
evaluations

1348
00:41:16,240 --> 00:41:18,160
and finds problems in just about all of

1349
00:41:18,160 --> 00:41:20,560
them one of the problems highlighted is

1350
00:41:20,560 --> 00:41:22,800
we cannot agree on exactly what to test

1351
00:41:22,800 --> 00:41:24,640
so it's hard to compare fuzzer a in

1352
00:41:24,640 --> 00:41:26,640
paper a to buzzer b and paper b

1353
00:41:26,640 --> 00:41:28,160
if they're tested on entirely different

1354
00:41:28,160 --> 00:41:30,319
things so that end a few things have

1355
00:41:30,319 --> 00:41:31,520
risen

1356
00:41:31,520 --> 00:41:34,079
there is fuzzbench which is aimed at

1357
00:41:34,079 --> 00:41:35,280
protocol fuzzers

1358
00:41:35,280 --> 00:41:36,640
there is magma which is a thing i've

1359
00:41:36,640 --> 00:41:38,160
referenced a few times here and i have

1360
00:41:38,160 --> 00:41:39,280
links in the slide

1361
00:41:39,280 --> 00:41:40,800
i'll eventually put those on github

1362
00:41:40,800 --> 00:41:43,440
probably tomorrow morning

1363
00:41:43,440 --> 00:41:46,480
and that one focuses more on classic

1364
00:41:46,480 --> 00:41:48,640
things there's also unifos

1365
00:41:48,640 --> 00:41:51,280
which i don't think is actually a great

1366
00:41:51,280 --> 00:41:52,480
approach to a benchmark

1367
00:41:52,480 --> 00:41:54,319
because it does not have ground truth

1368
00:41:54,319 --> 00:41:56,160
but it does exist so we've been trying

1369
00:41:56,160 --> 00:41:57,200
as a sort of

1370
00:41:57,200 --> 00:41:59,200
research area to standardize on what

1371
00:41:59,200 --> 00:42:01,200
programs make good benchmarks and good

1372
00:42:01,200 --> 00:42:03,440
tests and we have not yet converged on

1373
00:42:03,440 --> 00:42:04,880
an answer

1374
00:42:04,880 --> 00:42:06,720
but i think magma's answer is the best

1375
00:42:06,720 --> 00:42:08,240
one

1376
00:42:08,240 --> 00:42:09,920
it's also open source and on github so

1377
00:42:09,920 --> 00:42:11,119
you can pull that down and play with it

1378
00:42:11,119 --> 00:42:17,839
tonight if you wanted to

1379
00:42:18,640 --> 00:42:20,800
um the next question what's up with the

1380
00:42:20,800 --> 00:42:24,240
rabbits sounds like a fun story

1381
00:42:24,240 --> 00:42:27,440
i do not know why the creator of

1382
00:42:27,440 --> 00:42:30,160
afl chose to name after rabbits but ever

1383
00:42:30,160 --> 00:42:31,200
since then

1384
00:42:31,200 --> 00:42:33,520
rabbits are very associated with fuzzing

1385
00:42:33,520 --> 00:42:34,960
and fuzzing iconography

1386
00:42:34,960 --> 00:42:36,880
and we did have easter here in america

1387
00:42:36,880 --> 00:42:38,400
so my mother sent me a basket with that

1388
00:42:38,400 --> 00:42:39,760
cute little fuzzy chick

1389
00:42:39,760 --> 00:42:41,119
that was depicted and that you must be

1390
00:42:41,119 --> 00:42:44,079
this tall to find this bug i didn't

1391
00:42:44,079 --> 00:42:45,119
really know what else to do with it so i

1392
00:42:45,119 --> 00:42:45,520
was like

1393
00:42:45,520 --> 00:42:47,119
no i'm giving a talk on fuzzing it's

1394
00:42:47,119 --> 00:42:48,960
fuzzy i'll put it in the slide deck

1395
00:42:48,960 --> 00:42:51,200
yeah a lot of fuzzers have puns on

1396
00:42:51,200 --> 00:42:54,160
things that are fuzzy

1397
00:42:54,640 --> 00:42:56,400
i i don't know it's a cultural thing

1398
00:42:56,400 --> 00:42:58,160
that that's just sort of stuck around

1399
00:42:58,160 --> 00:42:59,359
fuzzing as a community

1400
00:42:59,359 --> 00:43:02,319
rabbits are very fuzzy i guess they're

1401
00:43:02,319 --> 00:43:05,200
popular for that reason

1402
00:43:07,119 --> 00:43:11,040
yeah all right um the next question

1403
00:43:11,040 --> 00:43:14,400
is there parallel distributed processing

1404
00:43:14,400 --> 00:43:16,880
for fuzzing this is common for machine

1405
00:43:16,880 --> 00:43:17,680
learning

1406
00:43:17,680 --> 00:43:20,640
uh to speed up things curious almost

1407
00:43:20,640 --> 00:43:23,520
happens some of them have it

1408
00:43:23,520 --> 00:43:25,440
but it depends on the fuzzer so some of

1409
00:43:25,440 --> 00:43:27,280
them do have distributed

1410
00:43:27,280 --> 00:43:30,640
or parallelizable parts or go after

1411
00:43:30,640 --> 00:43:32,400
something that's highly paralyzable

1412
00:43:32,400 --> 00:43:34,160
not all of them do so that would follow

1413
00:43:34,160 --> 00:43:36,079
under the secret sauce question

1414
00:43:36,079 --> 00:43:37,920
some fuzzers are deliberately built to

1415
00:43:37,920 --> 00:43:40,000
have high parallelization or distribu

1416
00:43:40,000 --> 00:43:41,200
distributed

1417
00:43:41,200 --> 00:43:43,440
computation powers and that's what makes

1418
00:43:43,440 --> 00:43:44,880
them special

1419
00:43:44,880 --> 00:43:46,560
but not all of them do they certainly

1420
00:43:46,560 --> 00:43:48,960
exist

1421
00:43:50,960 --> 00:43:54,319
okay another um

1422
00:43:54,319 --> 00:43:56,400
what is the practical use of fuzzing

1423
00:43:56,400 --> 00:43:59,119
with coding

1424
00:43:59,200 --> 00:44:03,119
well how do you feel about finding bugs

1425
00:44:03,119 --> 00:44:04,560
if you write code you probably want to

1426
00:44:04,560 --> 00:44:06,839
find your bugs buzzing and help you do

1427
00:44:06,839 --> 00:44:09,839
that

1428
00:44:12,319 --> 00:44:14,240
it can often find things that your qa

1429
00:44:14,240 --> 00:44:17,680
folks or the people who are writing code

1430
00:44:17,680 --> 00:44:19,359
don't think about like one of the things

1431
00:44:19,359 --> 00:44:20,400
that's fuzzing is that it will find

1432
00:44:20,400 --> 00:44:21,520
stuff that you were like

1433
00:44:21,520 --> 00:44:23,359
i didn't know it could do that and i

1434
00:44:23,359 --> 00:44:25,280
wrote it

1435
00:44:25,280 --> 00:44:27,119
thanks thanks source of randomness for

1436
00:44:27,119 --> 00:44:28,319
finding that

1437
00:44:28,319 --> 00:44:29,760
it's not a super fun feeling as a

1438
00:44:29,760 --> 00:44:31,520
developer to discover that

1439
00:44:31,520 --> 00:44:33,520
devrand knows more about the thing you

1440
00:44:33,520 --> 00:44:34,960
wrote than you do

1441
00:44:34,960 --> 00:44:38,000
but it's better for you to find it than

1442
00:44:38,000 --> 00:44:39,520
somebody outside the organization who

1443
00:44:39,520 --> 00:44:50,560
might do naughty things with it

1444
00:44:50,560 --> 00:44:53,119
okay i that's all what i could see in

1445
00:44:53,119 --> 00:44:54,160
the chat

1446
00:44:54,160 --> 00:44:57,359
um if there are more questions please do

1447
00:44:57,359 --> 00:44:59,440
post them in the chat because we have

1448
00:44:59,440 --> 00:45:05,839
10 more minutes um for discussion

1449
00:45:06,560 --> 00:45:09,760
i actually had a question so um if

1450
00:45:09,760 --> 00:45:12,160
you mentioned about fuzzers which could

1451
00:45:12,160 --> 00:45:14,960
be used by developers

1452
00:45:14,960 --> 00:45:18,319
are these fuzzers language dependent

1453
00:45:18,319 --> 00:45:21,280
so yeah i don't remember the names of

1454
00:45:21,280 --> 00:45:23,119
the puzzles you mentioned but

1455
00:45:23,119 --> 00:45:28,079
um yeah so aflgo is the open source

1456
00:45:28,079 --> 00:45:31,119
uh directed buzzer and that one is built

1457
00:45:31,119 --> 00:45:33,119
on afl so it has some of the limitations

1458
00:45:33,119 --> 00:45:35,599
that afl does it speaks only standard in

1459
00:45:35,599 --> 00:45:37,839
it was largely aimed at c binaries so it

1460
00:45:37,839 --> 00:45:38,800
doesn't really work on anything like

1461
00:45:38,800 --> 00:45:41,440
javascript

1462
00:45:41,839 --> 00:45:45,040
tofu also i think was c targeted and i

1463
00:45:45,040 --> 00:45:46,880
have not looked into microsoft onefs so

1464
00:45:46,880 --> 00:45:48,880
i don't actually know what its language

1465
00:45:48,880 --> 00:45:50,400
restrictions are

1466
00:45:50,400 --> 00:45:53,359
but okay usually it's aimed at compiled

1467
00:45:53,359 --> 00:45:54,160
code so we can

1468
00:45:54,160 --> 00:45:56,240
we can fuzz rust in some cases as easily

1469
00:45:56,240 --> 00:45:57,200
as c

1470
00:45:57,200 --> 00:45:59,359
provided it's been compiled down wasm

1471
00:45:59,359 --> 00:46:01,680
compiled to a c target also works in afl

1472
00:46:01,680 --> 00:46:02,720
just fine

1473
00:46:02,720 --> 00:46:06,079
i've done that but yes so where it

1474
00:46:06,079 --> 00:46:06,880
targets

1475
00:46:06,880 --> 00:46:08,960
is one of its chief limitations some

1476
00:46:08,960 --> 00:46:10,960
fuzzers really can only fuzz certain

1477
00:46:10,960 --> 00:46:13,280
languages or styles

1478
00:46:13,280 --> 00:46:15,520
navx was developed to go after js

1479
00:46:15,520 --> 00:46:18,319
montage i believe also goes after js

1480
00:46:18,319 --> 00:46:20,800
so you would be looking for a fuzzer

1481
00:46:20,800 --> 00:46:22,560
that can handle your language as part of

1482
00:46:22,560 --> 00:46:24,800
that

1483
00:46:24,800 --> 00:46:26,400
i don't think there's a fuzzer for every

1484
00:46:26,400 --> 00:46:28,240
language and style

1485
00:46:28,240 --> 00:46:30,240
yet i think there's still plenty of room

1486
00:46:30,240 --> 00:46:31,599
for innovation and development and

1487
00:46:31,599 --> 00:46:34,400
specialization

1488
00:46:34,480 --> 00:46:37,280
yeah and and which is the fuzzer that

1489
00:46:37,280 --> 00:46:39,520
you would suggest for network protocols

1490
00:46:39,520 --> 00:46:43,359
if you have like a pcap or

1491
00:46:43,359 --> 00:46:46,960
but bufos i think is white box uh afl

1492
00:46:46,960 --> 00:46:47,440
net

1493
00:46:47,440 --> 00:46:49,280
all was one of the early fuzzers to look

1494
00:46:49,280 --> 00:46:56,800
at network protocols

1495
00:46:56,800 --> 00:46:58,400
i believe is another one that's network

1496
00:46:58,400 --> 00:47:01,599
protocol buzzer

1497
00:47:02,400 --> 00:47:05,680
um can you name that again what was it

1498
00:47:05,680 --> 00:47:09,200
uh it's called fazowski okay

1499
00:47:09,200 --> 00:47:13,599
buffa's and then afl net

1500
00:47:13,599 --> 00:47:15,839
if on that is based based on you guessed

1501
00:47:15,839 --> 00:47:18,480
it afl

1502
00:47:18,720 --> 00:47:22,000
afl has a lot of grandchildren

1503
00:47:22,000 --> 00:47:25,119
um yeah and one more question how um so

1504
00:47:25,119 --> 00:47:25,599
when

1505
00:47:25,599 --> 00:47:28,640
when we have uh crashes

1506
00:47:28,640 --> 00:47:32,000
um how how can we detect what

1507
00:47:32,000 --> 00:47:34,400
what are the false positives and

1508
00:47:34,400 --> 00:47:35,280
repetitions

1509
00:47:35,280 --> 00:47:38,079
in there um is it just manually going

1510
00:47:38,079 --> 00:47:38,480
through

1511
00:47:38,480 --> 00:47:41,280
everything or the fuzzer also provides

1512
00:47:41,280 --> 00:47:43,680
some way to

1513
00:47:43,680 --> 00:47:45,280
almost all of them it's up to you to

1514
00:47:45,280 --> 00:47:46,480
figure out how to do that i know some

1515
00:47:46,480 --> 00:47:47,680
people who automate it

1516
00:47:47,680 --> 00:47:49,280
without scripts they wrote to take

1517
00:47:49,280 --> 00:47:50,800
everything out the crash directory

1518
00:47:50,800 --> 00:47:52,400
feed it to the target program and see if

1519
00:47:52,400 --> 00:47:54,160
it actually crashed if it didn't discard

1520
00:47:54,160 --> 00:47:54,720
it

1521
00:47:54,720 --> 00:47:56,720
and then figuring out whether they've

1522
00:47:56,720 --> 00:47:58,319
all got the same root cause was a thing

1523
00:47:58,319 --> 00:47:59,839
that i think everyone's largely done

1524
00:47:59,839 --> 00:48:01,040
manually

1525
00:48:01,040 --> 00:48:02,880
i know there's been some preliminary

1526
00:48:02,880 --> 00:48:04,960
research there but ultimately

1527
00:48:04,960 --> 00:48:06,400
it's things you do manually one of the

1528
00:48:06,400 --> 00:48:08,640
things i like about magma as a framework

1529
00:48:08,640 --> 00:48:10,880
is it tells you when you've hit specific

1530
00:48:10,880 --> 00:48:12,160
cves

1531
00:48:12,160 --> 00:48:14,000
so you don't have to do that resolution

1532
00:48:14,000 --> 00:48:15,920
for you it knows that you triggered that

1533
00:48:15,920 --> 00:48:16,960
crash

1534
00:48:16,960 --> 00:48:19,599
and found that specific bug so it says

1535
00:48:19,599 --> 00:48:20,000
you found

1536
00:48:20,000 --> 00:48:22,319
these 10 bugs out of the 20 possible

1537
00:48:22,319 --> 00:48:23,359
that we know about

1538
00:48:23,359 --> 00:48:25,520
and i think for evaluating a fuzzer

1539
00:48:25,520 --> 00:48:27,040
that's extremely useful

1540
00:48:27,040 --> 00:48:28,880
but that's less useful in practice and a

1541
00:48:28,880 --> 00:48:30,400
target where you don't know what the

1542
00:48:30,400 --> 00:48:31,839
ground truth is

1543
00:48:31,839 --> 00:48:33,760
so it's useful for me as an academic but

1544
00:48:33,760 --> 00:48:34,960
it's less useful for you

1545
00:48:34,960 --> 00:48:37,359
someone who's trying to find unknown

1546
00:48:37,359 --> 00:48:40,078
vulnerabilities

1547
00:48:40,319 --> 00:48:41,359
i think for the people who are looking

1548
00:48:41,359 --> 00:48:43,040
for the unknown stuff there's a fair

1549
00:48:43,040 --> 00:48:44,800
amount of either automated scripting or

1550
00:48:44,800 --> 00:48:49,839
manual testing that goes into that

1551
00:48:54,800 --> 00:48:57,839
all right i

1552
00:48:57,839 --> 00:49:00,880
i don't see any other questions

1553
00:49:00,880 --> 00:49:04,960
i will just post a link for

1554
00:49:09,040 --> 00:49:10,559
yeah and i'll drop a bunch of links in

1555
00:49:10,559 --> 00:49:12,800
the discord tell me which channel to do

1556
00:49:12,800 --> 00:49:15,040
it in

1557
00:49:15,760 --> 00:49:17,680
i'm thinking yeah you should have access

1558
00:49:17,680 --> 00:49:20,079
to the discussions and

1559
00:49:20,079 --> 00:49:23,119
you could post it there yeah

1560
00:49:23,119 --> 00:49:26,240
yeah all right then i guess that's it

1561
00:49:26,240 --> 00:49:26,960
for today

1562
00:49:26,960 --> 00:49:29,839
um thank you so much alison for that

1563
00:49:29,839 --> 00:49:30,800
wonderful talk

1564
00:49:30,800 --> 00:49:33,599
uh about fuzzing and how to get started

1565
00:49:33,599 --> 00:49:34,160
with it

1566
00:49:34,160 --> 00:49:38,000
i um always yeah i tried my hand a

1567
00:49:38,000 --> 00:49:40,240
little bit with afl someday

1568
00:49:40,240 --> 00:49:42,319
long back but maybe i'm going to start

1569
00:49:42,319 --> 00:49:44,559
again doing something with it

1570
00:49:44,559 --> 00:49:48,000
um and i'm sure that yeah many of the

1571
00:49:48,000 --> 00:49:50,240
attendees are also already on the

1572
00:49:50,240 --> 00:49:52,960
labs and trying to play with it so thank

1573
00:49:52,960 --> 00:49:54,240
you so much for your time

1574
00:49:54,240 --> 00:49:58,160
um you're welcome thank you all for

1575
00:49:58,160 --> 00:49:58,800
listening

1576
00:49:58,800 --> 00:50:00,559
i hope it's useful and enjoy the rest of

1577
00:50:00,559 --> 00:50:02,079
your copycon there are some really cool

1578
00:50:02,079 --> 00:50:04,800
speakers coming up today

1579
00:50:04,800 --> 00:50:08,240
yes uh i think our next talk

1580
00:50:08,240 --> 00:50:11,359
will start at 9 30 so we have uh

1581
00:50:11,359 --> 00:50:14,480
in eight minutes so

1582
00:50:14,480 --> 00:50:17,200
right half hour off okay uh then i guess

1583
00:50:17,200 --> 00:50:18,960
i will stop sharing and start

1584
00:50:18,960 --> 00:50:24,640
posting stuff yes yeah thank you so much

1585
00:50:24,839 --> 00:50:27,839
alison

1586
00:50:28,800 --> 00:50:30,880
you

