1
00:00:15,360 --> 00:00:16,960
hello everyone

2
00:00:16,960 --> 00:00:20,160
it's my honor to participant in this

3
00:00:20,160 --> 00:00:22,160
conference

4
00:00:22,160 --> 00:00:25,119
my topic is a story about virtualbox

5
00:00:25,119 --> 00:00:27,039
escape

6
00:00:27,039 --> 00:00:30,560
first introduce myself i'm a security

7
00:00:30,560 --> 00:00:31,599
researcher

8
00:00:31,599 --> 00:00:34,960
of chanting security research lab

9
00:00:34,960 --> 00:00:38,320
in the past years my work in water back

10
00:00:38,320 --> 00:00:39,280
hunting

11
00:00:39,280 --> 00:00:42,879
and exploiting technique mainly in

12
00:00:42,879 --> 00:00:44,000
virtualization

13
00:00:44,000 --> 00:00:48,160
iot and the os kernel

14
00:00:48,239 --> 00:00:50,719
chanting is an excellent network

15
00:00:50,719 --> 00:00:52,079
security company

16
00:00:52,079 --> 00:00:55,520
in china our ctf

17
00:00:55,520 --> 00:00:58,320
has received international attention and

18
00:00:58,320 --> 00:01:00,960
recognition

19
00:01:00,960 --> 00:01:05,440
we also welcome everyone to attend it

20
00:01:05,840 --> 00:01:09,040
the agenda for this talk first

21
00:01:09,040 --> 00:01:11,200
we will introduce the architecture of

22
00:01:11,200 --> 00:01:12,479
virtualbox

23
00:01:12,479 --> 00:01:16,080
and its attack services then

24
00:01:16,080 --> 00:01:18,320
introduce the back hunting ideas for

25
00:01:18,320 --> 00:01:20,159
these attack services

26
00:01:20,159 --> 00:01:24,560
including code review and fast methods

27
00:01:24,560 --> 00:01:27,759
next we will explain the course of some

28
00:01:27,759 --> 00:01:31,439
vulnerabilities through the real cases

29
00:01:31,439 --> 00:01:34,159
finally we explain the process of

30
00:01:34,159 --> 00:01:36,560
exploiting the vulnerabilities

31
00:01:36,560 --> 00:01:40,799
and should the final effect part 1

32
00:01:40,799 --> 00:01:44,240
virtual box overview

33
00:01:44,479 --> 00:01:46,880
let's look on to the architecture of

34
00:01:46,880 --> 00:01:48,320
virtualbox

35
00:01:48,320 --> 00:01:51,360
ok let's see the picture shoes this

36
00:01:51,360 --> 00:01:53,280
is a very common virtual machine

37
00:01:53,280 --> 00:01:55,200
architecture

38
00:01:55,200 --> 00:01:57,759
and other virtualization systems such as

39
00:01:57,759 --> 00:01:58,880
vmware

40
00:01:58,880 --> 00:02:01,360
and hyper-v also has similar

41
00:02:01,360 --> 00:02:03,840
architecture

42
00:02:03,840 --> 00:02:07,360
that is divided into two parts

43
00:02:07,360 --> 00:02:10,959
host and guest the host usually refers

44
00:02:10,959 --> 00:02:13,520
to the main operating system

45
00:02:13,520 --> 00:02:15,599
that is running the mini ultra watching

46
00:02:15,599 --> 00:02:18,160
program

47
00:02:18,400 --> 00:02:20,400
and the guest usually refers to the

48
00:02:20,400 --> 00:02:22,319
operating system

49
00:02:22,319 --> 00:02:26,238
that's running in the virtual machine

50
00:02:26,480 --> 00:02:28,800
the main security design of a virtual

51
00:02:28,800 --> 00:02:29,920
machine

52
00:02:29,920 --> 00:02:34,000
is system isolation so it's made right

53
00:02:34,000 --> 00:02:34,879
model

54
00:02:34,879 --> 00:02:39,280
is to attack the host through the guest

55
00:02:39,280 --> 00:02:42,560
as a bug hunter we need to observe the

56
00:02:42,560 --> 00:02:43,760
architecture

57
00:02:43,760 --> 00:02:48,560
from the perspective of an attacker

58
00:02:48,560 --> 00:02:51,519
this means that we need to understand

59
00:02:51,519 --> 00:02:55,440
how the guest communicates with the host

60
00:02:55,440 --> 00:02:58,400
next we will introduce in detail how

61
00:02:58,400 --> 00:03:01,280
they communicate

62
00:03:01,840 --> 00:03:04,239
first let's learn about general

63
00:03:04,239 --> 00:03:07,040
communication

64
00:03:08,400 --> 00:03:11,120
and thus name implies general

65
00:03:11,120 --> 00:03:12,239
communication

66
00:03:12,239 --> 00:03:15,519
is a common communication mode in

67
00:03:15,519 --> 00:03:18,640
all virtualization systems

68
00:03:18,640 --> 00:03:22,000
which emulates the communication of real

69
00:03:22,000 --> 00:03:25,360
computer devices

70
00:03:26,000 --> 00:03:28,560
this communication method can make the

71
00:03:28,560 --> 00:03:29,200
guest

72
00:03:29,200 --> 00:03:32,640
run without a perception because there

73
00:03:32,640 --> 00:03:33,120
is

74
00:03:33,120 --> 00:03:35,519
no need to install addition

75
00:03:35,519 --> 00:03:37,280
communication components

76
00:03:37,280 --> 00:03:40,640
in the guest as

77
00:03:40,640 --> 00:03:45,040
well in the figure in the waterfalls

78
00:03:45,040 --> 00:03:47,280
the guest runs the communication

79
00:03:47,280 --> 00:03:48,319
instructions

80
00:03:48,319 --> 00:03:53,040
through the system's old device drivers

81
00:03:53,200 --> 00:03:56,720
and the hosts have eraser will capture

82
00:03:56,720 --> 00:04:00,480
the instructions

83
00:04:00,480 --> 00:04:03,120
and pass the message to the

84
00:04:03,120 --> 00:04:05,040
corresponding in

85
00:04:05,040 --> 00:04:08,560
millicade device component

86
00:04:08,560 --> 00:04:12,080
the emulated device will pierce the

87
00:04:12,080 --> 00:04:12,640
message

88
00:04:12,640 --> 00:04:16,079
from the guest and implement the

89
00:04:16,079 --> 00:04:16,798
response

90
00:04:16,798 --> 00:04:19,440
operation

91
00:04:19,918 --> 00:04:22,240
general communication contains three

92
00:04:22,240 --> 00:04:24,160
types of methods

93
00:04:24,160 --> 00:04:27,199
they are i o method immio

94
00:04:27,199 --> 00:04:32,080
or dma method and other special methods

95
00:04:32,080 --> 00:04:35,280
the method instructions is related to

96
00:04:35,280 --> 00:04:35,680
the

97
00:04:35,680 --> 00:04:40,000
architecture of the cpu for example

98
00:04:40,000 --> 00:04:43,280
in there are

99
00:04:43,280 --> 00:04:48,000
in out more instructions and so on

100
00:04:48,000 --> 00:04:50,240
the io instructions communicates with

101
00:04:50,240 --> 00:04:51,680
the devices

102
00:04:51,680 --> 00:04:54,479
through the i o part the more

103
00:04:54,479 --> 00:04:56,000
instruction communicates with the

104
00:04:56,000 --> 00:04:56,880
devices

105
00:04:56,880 --> 00:05:00,240
by reading and writing special guests

106
00:05:00,240 --> 00:05:03,440
physical addresses

107
00:05:04,080 --> 00:05:07,600
for other special instructions messages

108
00:05:07,600 --> 00:05:12,000
are passed through special regester

109
00:05:12,400 --> 00:05:14,560
since the processing of special

110
00:05:14,560 --> 00:05:16,160
interactions

111
00:05:16,160 --> 00:05:18,320
doesn't include the appearance of

112
00:05:18,320 --> 00:05:20,560
complex speed

113
00:05:20,560 --> 00:05:24,000
it just emits the behavior of

114
00:05:24,000 --> 00:05:28,240
the cpu so we don't care about it for

115
00:05:28,240 --> 00:05:30,800
this time

116
00:05:31,120 --> 00:05:34,320
in the virtualbox we mainly care about

117
00:05:34,320 --> 00:05:39,199
io mm-io and dma method

118
00:05:39,199 --> 00:05:42,240
obviously these instructions

119
00:05:42,240 --> 00:05:47,520
need to be run in green 0 of the guest

120
00:05:47,520 --> 00:05:49,600
so when we test a virtualization

121
00:05:49,600 --> 00:05:51,440
platform

122
00:05:51,440 --> 00:05:55,039
we usually need to load a custom driver

123
00:05:55,039 --> 00:05:58,400
in the guest to do it

124
00:05:58,479 --> 00:06:01,600
in a virtualization system there is a

125
00:06:01,600 --> 00:06:03,680
type of device called

126
00:06:03,680 --> 00:06:07,120
a melody device because the device

127
00:06:07,120 --> 00:06:10,800
emulates the real hardware device

128
00:06:10,800 --> 00:06:13,840
since the vr devices usually use general

129
00:06:13,840 --> 00:06:14,720
communication

130
00:06:14,720 --> 00:06:17,840
with system software

131
00:06:17,840 --> 00:06:21,199
so in a virtualization system general

132
00:06:21,199 --> 00:06:22,880
emulation

133
00:06:22,880 --> 00:06:26,000
is usually implemented by a military

134
00:06:26,000 --> 00:06:30,639
devices in the virtual box

135
00:06:30,639 --> 00:06:33,919
there are many emulated devices which

136
00:06:33,919 --> 00:06:37,840
provide a large attack service

137
00:06:37,840 --> 00:06:40,800
and shoot in the figure motherboard

138
00:06:40,800 --> 00:06:41,759
chips

139
00:06:41,759 --> 00:06:45,039
graphics cards network cards

140
00:06:45,039 --> 00:06:48,000
sound cards and storage controller and

141
00:06:48,000 --> 00:06:48,880
so on

142
00:06:48,880 --> 00:06:53,120
these are all emulated devices

143
00:06:53,599 --> 00:06:57,120
each of these devices will emulate

144
00:06:57,120 --> 00:07:00,319
a special model of hardware

145
00:07:00,319 --> 00:07:03,599
for example the network card

146
00:07:03,599 --> 00:07:06,800
emulates the e1 key

147
00:07:06,800 --> 00:07:12,000
usb administrates ofci controller

148
00:07:12,000 --> 00:07:15,280
and the storage in middle case

149
00:07:15,280 --> 00:07:19,759
hci controller so we can refer

150
00:07:19,759 --> 00:07:23,840
to the digit of the real device

151
00:07:23,840 --> 00:07:26,440
to understand the principle of its

152
00:07:26,440 --> 00:07:29,120
implementation

153
00:07:29,120 --> 00:07:31,440
this is a good way to learn about

154
00:07:31,440 --> 00:07:34,880
emulated devices

155
00:07:35,360 --> 00:07:37,520
next let's talk about special

156
00:07:37,520 --> 00:07:40,240
communicates

157
00:07:41,840 --> 00:07:45,440
in addition to general communication

158
00:07:45,440 --> 00:07:48,240
marginalization systems usually include

159
00:07:48,240 --> 00:07:51,680
special communication methods

160
00:07:51,680 --> 00:07:54,639
as shown in the figure because the

161
00:07:54,639 --> 00:07:56,639
operating system itself

162
00:07:56,639 --> 00:07:58,879
can't recognize the special

163
00:07:58,879 --> 00:08:01,599
communication protocol

164
00:08:01,599 --> 00:08:03,919
the guest is to install additional

165
00:08:03,919 --> 00:08:04,960
drivers

166
00:08:04,960 --> 00:08:09,520
provided by virtualization systems

167
00:08:10,479 --> 00:08:13,199
the virtualbox contains many such

168
00:08:13,199 --> 00:08:14,479
drivers

169
00:08:14,479 --> 00:08:18,639
such as the vbox guest redbox servers

170
00:08:18,639 --> 00:08:22,639
we box the video and so on

171
00:08:22,879 --> 00:08:25,440
the implementation of these drivers

172
00:08:25,440 --> 00:08:26,000
depends

173
00:08:26,000 --> 00:08:29,360
on the guest operating system

174
00:08:29,360 --> 00:08:32,240
the drivers will communicate with the

175
00:08:32,240 --> 00:08:33,200
corresponding

176
00:08:33,200 --> 00:08:36,559
device in the host

177
00:08:36,559 --> 00:08:39,039
i will explain what devices are there

178
00:08:39,039 --> 00:08:41,838
later

179
00:08:42,719 --> 00:08:45,440
the essence of special communication and

180
00:08:45,440 --> 00:08:46,800
general communication

181
00:08:46,800 --> 00:08:50,080
is the theme they all communicate

182
00:08:50,080 --> 00:08:55,200
serial i o or mm-io instructions

183
00:08:55,200 --> 00:08:57,440
the main difference is that a special

184
00:08:57,440 --> 00:08:59,519
communication protocol

185
00:08:59,519 --> 00:09:03,760
is privatized and it doesn't exist

186
00:09:03,760 --> 00:09:08,560
on any real hardware the purpose of this

187
00:09:08,560 --> 00:09:11,600
is to make it easier for developers

188
00:09:11,600 --> 00:09:15,200
to make the features of virtualization

189
00:09:15,200 --> 00:09:20,160
to make communication more efficient

190
00:09:20,160 --> 00:09:23,519
for example the network card is a key

191
00:09:23,519 --> 00:09:24,959
component

192
00:09:24,959 --> 00:09:29,119
that affects the system performers

193
00:09:29,200 --> 00:09:32,160
through special communication developers

194
00:09:32,160 --> 00:09:32,720
can make

195
00:09:32,720 --> 00:09:36,240
an effective ring buffer and the host

196
00:09:36,240 --> 00:09:38,959
communication

197
00:09:39,519 --> 00:09:42,480
in addition special communication is

198
00:09:42,480 --> 00:09:45,120
also used to realize the unique

199
00:09:45,120 --> 00:09:49,440
functions of the virtual machine such as

200
00:09:49,440 --> 00:09:52,000
photo sharing and fair dragging and so

201
00:09:52,000 --> 00:09:53,760
on

202
00:09:53,760 --> 00:09:56,800
in virtualbox the host

203
00:09:56,800 --> 00:09:59,839
implements these functions as

204
00:09:59,839 --> 00:10:04,160
devices fellow laser is a very

205
00:10:04,160 --> 00:10:05,600
interesting place

206
00:10:05,600 --> 00:10:08,240
to use special communication which is

207
00:10:08,240 --> 00:10:10,480
spells

208
00:10:10,480 --> 00:10:13,360
the virtualization system may add a

209
00:10:13,360 --> 00:10:14,079
custom

210
00:10:14,079 --> 00:10:17,279
io port or mmi io

211
00:10:17,279 --> 00:10:20,720
to the emulated device for the

212
00:10:20,720 --> 00:10:23,839
convenience of bears

213
00:10:23,839 --> 00:10:27,279
therefore a military devices

214
00:10:27,279 --> 00:10:30,880
are not necessarily

215
00:10:30,880 --> 00:10:34,560
all general communications

216
00:10:36,079 --> 00:10:39,120
as shown in the picture virtualbox has

217
00:10:39,120 --> 00:10:41,279
many special devices

218
00:10:41,279 --> 00:10:43,920
such as network card device virtual i o

219
00:10:43,920 --> 00:10:45,279
ethernet

220
00:10:45,279 --> 00:10:48,640
graphics device svga3d

221
00:10:48,640 --> 00:10:51,920
storage device virtual i o and csi

222
00:10:51,920 --> 00:10:54,880
and video acceleration device vpva and

223
00:10:54,880 --> 00:10:57,040
so on

224
00:10:57,040 --> 00:10:59,279
there are also some devices that

225
00:10:59,279 --> 00:11:00,320
implement

226
00:11:00,320 --> 00:11:03,360
special functions such as virtual kt

227
00:11:03,360 --> 00:11:05,839
device for debugging

228
00:11:05,839 --> 00:11:09,360
and vmm devices that provide basic

229
00:11:09,360 --> 00:11:12,800
protocol as gcm for reverse

230
00:11:12,800 --> 00:11:16,320
special services such as the photo

231
00:11:16,320 --> 00:11:17,360
sharing

232
00:11:17,360 --> 00:11:21,920
failed dragging and other services

233
00:11:22,000 --> 00:11:25,600
therefore special communication also has

234
00:11:25,600 --> 00:11:28,160
a large attack surface

235
00:11:28,160 --> 00:11:31,519
but due to its provided nature

236
00:11:31,519 --> 00:11:34,560
you need to read the source code and

237
00:11:34,560 --> 00:11:38,959
reverse the binary to know its details

238
00:11:38,959 --> 00:11:42,240
okay next let's talk about back end

239
00:11:42,240 --> 00:11:46,480
communication in virtualization system

240
00:11:46,480 --> 00:11:50,079
a little device is not enough the device

241
00:11:50,079 --> 00:11:53,519
receives only the rotate and further

242
00:11:53,519 --> 00:11:56,000
processing needs to be formed by the

243
00:11:56,000 --> 00:11:59,839
back end for example the network card

244
00:11:59,839 --> 00:12:00,800
device

245
00:12:00,800 --> 00:12:04,560
only receives the network data package

246
00:12:04,560 --> 00:12:07,440
and how to forward it is to deal with

247
00:12:07,440 --> 00:12:08,639
the backend

248
00:12:08,639 --> 00:12:12,720
of the ethernet or ip protocols tank

249
00:12:12,720 --> 00:12:16,399
in addition usb devices only accept

250
00:12:16,399 --> 00:12:19,600
usb data package and the specific

251
00:12:19,600 --> 00:12:22,800
functions of usb have to be done by the

252
00:12:22,800 --> 00:12:23,279
act

253
00:12:23,279 --> 00:12:27,360
backhand there are also storage devices

254
00:12:27,360 --> 00:12:30,800
which just receive failed it where to

255
00:12:30,800 --> 00:12:31,680
read

256
00:12:31,680 --> 00:12:35,120
from and read tool it also needs to

257
00:12:35,120 --> 00:12:38,639
the backend to decide

258
00:12:38,639 --> 00:12:41,360
in the virtualbox there is usually a

259
00:12:41,360 --> 00:12:43,200
driver component

260
00:12:43,200 --> 00:12:46,720
that acts as a bridge between the device

261
00:12:46,720 --> 00:12:49,760
and the back end the driver is not a

262
00:12:49,760 --> 00:12:50,800
kernel driver

263
00:12:50,800 --> 00:12:54,000
but the design model in the code

264
00:12:54,000 --> 00:12:57,279
therefore guest and the backend

265
00:12:57,279 --> 00:13:01,440
constitute in direct communication

266
00:13:01,440 --> 00:13:04,880
we can think of it as a new attack

267
00:13:04,880 --> 00:13:06,240
service

268
00:13:06,240 --> 00:13:08,639
next we will introduce the warriors

269
00:13:08,639 --> 00:13:12,079
backhands one by one

270
00:13:12,399 --> 00:13:15,440
the first is usb backend

271
00:13:15,440 --> 00:13:18,399
and the picture shows the front device

272
00:13:18,399 --> 00:13:18,720
of

273
00:13:18,720 --> 00:13:22,800
usb is usb controller such as ohci

274
00:13:22,800 --> 00:13:26,000
excl and xhci

275
00:13:26,000 --> 00:13:28,079
these are standard usb hardware

276
00:13:28,079 --> 00:13:29,760
protocols

277
00:13:29,760 --> 00:13:31,760
when the controller receives the usb

278
00:13:31,760 --> 00:13:33,279
data packet

279
00:13:33,279 --> 00:13:35,839
it needs to be forwarded to the

280
00:13:35,839 --> 00:13:39,040
corresponding usb back-end

281
00:13:39,040 --> 00:13:41,600
there are many kinds of usb back-ends

282
00:13:41,600 --> 00:13:43,519
such as storage usb

283
00:13:43,519 --> 00:13:46,560
camera usb and network usb

284
00:13:46,560 --> 00:13:49,839
and so on this will define

285
00:13:49,839 --> 00:13:53,199
a unified interface

286
00:13:53,199 --> 00:13:56,399
and backhands interact with the front

287
00:13:56,399 --> 00:13:57,040
device

288
00:13:57,040 --> 00:14:00,720
through urb therefore

289
00:14:00,720 --> 00:14:03,760
the usb attached service has entered

290
00:14:03,760 --> 00:14:08,480
urb and warrior back-ends

291
00:14:09,440 --> 00:14:12,480
next is the storage button

292
00:14:12,480 --> 00:14:14,639
and the picture shows the front device

293
00:14:14,639 --> 00:14:16,000
of storage and storage

294
00:14:16,000 --> 00:14:21,360
controller such as ahci and cs and ata

295
00:14:21,360 --> 00:14:23,440
this is a standard storage hardware

296
00:14:23,440 --> 00:14:25,279
protocols

297
00:14:25,279 --> 00:14:27,760
when the controller receives the disk

298
00:14:27,760 --> 00:14:28,839
date

299
00:14:28,839 --> 00:14:32,000
package it needs to be forwarded to the

300
00:14:32,000 --> 00:14:35,279
corresponding storage backend

301
00:14:35,279 --> 00:14:38,320
in the virtualbox the bank handler

302
00:14:38,320 --> 00:14:39,279
represents

303
00:14:39,279 --> 00:14:42,480
different types of images

304
00:14:42,480 --> 00:14:44,959
because the format of each image is

305
00:14:44,959 --> 00:14:46,560
different

306
00:14:46,560 --> 00:14:49,360
so different backgrounds are needed to

307
00:14:49,360 --> 00:14:50,000
red

308
00:14:50,000 --> 00:14:52,639
and red

309
00:14:53,680 --> 00:14:56,320
there are many kinds of storage backends

310
00:14:56,320 --> 00:14:59,360
such as the vmtkvdi

311
00:14:59,360 --> 00:15:02,560
raw and server

312
00:15:02,560 --> 00:15:05,920
similar to usb virtualbox define

313
00:15:05,920 --> 00:15:10,839
a unified interface for this

314
00:15:10,839 --> 00:15:15,040
package the bridge driver is the

315
00:15:15,040 --> 00:15:19,120
3d components therefore

316
00:15:19,120 --> 00:15:22,959
the storage attack service has ended

317
00:15:22,959 --> 00:15:25,519
with the component and the reverse

318
00:15:25,519 --> 00:15:26,079
storage

319
00:15:26,079 --> 00:15:28,560
functions

320
00:15:29,199 --> 00:15:32,720
next is vmm device backend

321
00:15:32,720 --> 00:15:36,800
vmm device doesn't emulate the hardware

322
00:15:36,800 --> 00:15:40,079
device it is just a custom

323
00:15:40,079 --> 00:15:43,920
host and guest communication device

324
00:15:43,920 --> 00:15:46,959
it provides a communication basis for

325
00:15:46,959 --> 00:15:50,480
sharing files dragging fields

326
00:15:50,480 --> 00:15:54,320
and other functions therefore

327
00:15:54,320 --> 00:15:56,959
ensuring the figure expectance of

328
00:15:56,959 --> 00:15:59,839
various devices

329
00:15:59,839 --> 00:16:02,800
these devices are specific to virtual

330
00:16:02,800 --> 00:16:04,800
machine

331
00:16:04,800 --> 00:16:07,440
they need to install addition drivers in

332
00:16:07,440 --> 00:16:09,759
the guest

333
00:16:09,759 --> 00:16:13,199
similar to the previous backhands

334
00:16:13,199 --> 00:16:16,560
different devices has a unified

335
00:16:16,560 --> 00:16:20,800
interface that is hgcm

336
00:16:20,800 --> 00:16:24,160
therefore the vrmm devices

337
00:16:24,160 --> 00:16:28,800
attack service has ended hgcm

338
00:16:28,800 --> 00:16:33,199
and the reverse services backhands

339
00:16:34,480 --> 00:16:37,880
next is a svg 3d backhand

340
00:16:37,880 --> 00:16:40,959
svg3 is a 3d graphics device on

341
00:16:40,959 --> 00:16:42,880
virtualbox

342
00:16:42,880 --> 00:16:47,759
it emulates the function of gpu

343
00:16:48,160 --> 00:16:52,800
it isn't a mutated hardware device

344
00:16:52,800 --> 00:16:56,320
and customize this format so addition

345
00:16:56,320 --> 00:16:58,880
drivers need to be installed

346
00:16:58,880 --> 00:17:02,959
in the guest after the device

347
00:17:02,959 --> 00:17:06,640
receive the 3d data from the guest

348
00:17:06,640 --> 00:17:09,439
it needs to be converted to a this

349
00:17:09,439 --> 00:17:10,880
format

350
00:17:10,880 --> 00:17:13,919
that can be recognized by the host 3d

351
00:17:13,919 --> 00:17:16,839
graphics library

352
00:17:16,839 --> 00:17:20,400
therefore its background is directx and

353
00:17:20,400 --> 00:17:22,079
opengl

354
00:17:22,079 --> 00:17:24,839
which are used for windows and linux

355
00:17:24,839 --> 00:17:27,839
responsively

356
00:17:28,400 --> 00:17:31,200
since the graphics library is not much

357
00:17:31,200 --> 00:17:32,640
different

358
00:17:32,640 --> 00:17:35,520
so the bridge driver components are not

359
00:17:35,520 --> 00:17:37,679
used here

360
00:17:37,679 --> 00:17:41,280
therefore the svg a3d devices attack

361
00:17:41,280 --> 00:17:42,320
surface

362
00:17:42,320 --> 00:17:47,840
has either directx and opengl backend

363
00:17:48,559 --> 00:17:51,919
next is network backend the backend of

364
00:17:51,919 --> 00:17:54,000
network card device

365
00:17:54,000 --> 00:17:56,400
is mainly used to provide the network

366
00:17:56,400 --> 00:17:58,240
package protocol

367
00:17:58,240 --> 00:18:02,080
and then forward it virtualbox uses

368
00:18:02,080 --> 00:18:05,280
a third part open source library as

369
00:18:05,280 --> 00:18:08,880
our irg since the library can be easily

370
00:18:08,880 --> 00:18:09,600
compared

371
00:18:09,600 --> 00:18:12,640
and run independently many people have

372
00:18:12,640 --> 00:18:16,240
first aid similar to the previous

373
00:18:16,240 --> 00:18:17,679
spectrums

374
00:18:17,679 --> 00:18:21,799
it also have a unified interface that is

375
00:18:21,799 --> 00:18:25,360
drv180 therefore

376
00:18:25,360 --> 00:18:27,600
the network device attack service has

377
00:18:27,600 --> 00:18:28,880
under the dr

378
00:18:28,880 --> 00:18:35,440
ray 980 and isl irp banking

379
00:18:36,480 --> 00:18:39,120
okay after understanding the

380
00:18:39,120 --> 00:18:40,880
communication methods

381
00:18:40,880 --> 00:18:44,000
and attack services of virtualbox

382
00:18:44,000 --> 00:18:48,160
i will discuss how to back hunting

383
00:18:48,640 --> 00:18:51,760
the first method is code review but it

384
00:18:51,760 --> 00:18:53,520
isn't only a review

385
00:18:53,520 --> 00:18:55,679
i also need to consider how to fuzzing

386
00:18:55,679 --> 00:18:58,720
during the review process

387
00:18:58,720 --> 00:19:01,360
next i will discuss the key points of

388
00:19:01,360 --> 00:19:03,919
reviewing virtualbox

389
00:19:03,919 --> 00:19:06,480
it also applies to other virtualization

390
00:19:06,480 --> 00:19:09,039
systems

391
00:19:09,039 --> 00:19:11,520
device is an important attack service or

392
00:19:11,520 --> 00:19:13,919
virtualization system

393
00:19:13,919 --> 00:19:16,799
first let's look at the inertialization

394
00:19:16,799 --> 00:19:17,440
process

395
00:19:17,440 --> 00:19:21,440
of the wires in the virtual boards

396
00:19:21,440 --> 00:19:25,120
each device has a device registration

397
00:19:25,120 --> 00:19:29,039
structure object which contains the

398
00:19:29,039 --> 00:19:29,520
basic

399
00:19:29,520 --> 00:19:31,679
information and the callback functions

400
00:19:31,679 --> 00:19:34,559
of the device

401
00:19:34,799 --> 00:19:38,080
these callback functions describe the

402
00:19:38,080 --> 00:19:42,879
entire life cycle of the device

403
00:19:43,200 --> 00:19:46,320
and the picture shows

404
00:19:46,320 --> 00:19:48,320
these are some callback functions

405
00:19:48,320 --> 00:19:49,760
including the

406
00:19:49,760 --> 00:19:52,880
hdm structure

407
00:19:52,880 --> 00:19:56,000
for example the initialization function

408
00:19:56,000 --> 00:19:57,039
of the device

409
00:19:57,039 --> 00:20:00,799
is p function constructor

410
00:20:00,799 --> 00:20:04,400
and the startup function is a p function

411
00:20:04,400 --> 00:20:07,679
power on

412
00:20:07,679 --> 00:20:10,159
and the restart function is the function

413
00:20:10,159 --> 00:20:12,640
reset

414
00:20:12,640 --> 00:20:15,120
these are unified device interface

415
00:20:15,120 --> 00:20:16,400
defined by

416
00:20:16,400 --> 00:20:19,600
ultrabooks which is caused by the

417
00:20:19,600 --> 00:20:20,080
virtual

418
00:20:20,080 --> 00:20:24,159
smith ride at an appropriate

419
00:20:24,159 --> 00:20:28,159
time and show in the figure

420
00:20:28,159 --> 00:20:30,400
the picture on the right represents the

421
00:20:30,400 --> 00:20:32,559
mystery and all device

422
00:20:32,559 --> 00:20:34,960
which has fusion objects to the device

423
00:20:34,960 --> 00:20:36,720
list

424
00:20:36,720 --> 00:20:39,039
here you can see which devices are

425
00:20:39,039 --> 00:20:39,760
rejected

426
00:20:39,760 --> 00:20:42,880
in virtualbox and

427
00:20:42,880 --> 00:20:45,200
the picture on the left is the device

428
00:20:45,200 --> 00:20:46,159
registration

429
00:20:46,159 --> 00:20:50,880
structure of the e1k device

430
00:20:50,880 --> 00:20:53,200
which is a good interest to understand

431
00:20:53,200 --> 00:20:56,559
the u1k device

432
00:20:57,440 --> 00:21:00,080
the most important callback function of

433
00:21:00,080 --> 00:21:00,960
the device

434
00:21:00,960 --> 00:21:04,240
is a construct it is the callback

435
00:21:04,240 --> 00:21:04,880
function

436
00:21:04,880 --> 00:21:07,120
in the device registration object

437
00:21:07,120 --> 00:21:08,720
structure

438
00:21:08,720 --> 00:21:11,760
which is called by the ptm device innate

439
00:21:11,760 --> 00:21:13,679
function

440
00:21:13,679 --> 00:21:15,760
the constructor function is the

441
00:21:15,760 --> 00:21:19,520
initialization function of the device

442
00:21:19,520 --> 00:21:22,720
especially it shows which attack service

443
00:21:22,720 --> 00:21:27,039
the device has and so in the figure

444
00:21:27,039 --> 00:21:29,360
this is the constructor command code

445
00:21:29,360 --> 00:21:31,840
logic

446
00:21:32,320 --> 00:21:35,440
among them we need to focus on

447
00:21:35,440 --> 00:21:38,880
io port create mmi output

448
00:21:38,880 --> 00:21:43,520
and thread create iopod create registers

449
00:21:43,520 --> 00:21:46,880
the io port and the io code bank

450
00:21:46,880 --> 00:21:50,799
for the device so that we can use the

451
00:21:50,799 --> 00:21:54,000
in and out instruction to call from the

452
00:21:54,000 --> 00:21:56,320
guest

453
00:21:56,400 --> 00:22:01,280
mmi or create a similar tool io create

454
00:22:01,280 --> 00:22:03,840
and can be called by the moon

455
00:22:03,840 --> 00:22:06,480
instruction in the guest

456
00:22:06,480 --> 00:22:09,760
slide creator creates the working slide

457
00:22:09,760 --> 00:22:12,480
of the device which contains the main

458
00:22:12,480 --> 00:22:14,720
logic of the device

459
00:22:14,720 --> 00:22:19,120
so which requires us to review in detail

460
00:22:19,120 --> 00:22:21,440
and show in the favor the device is

461
00:22:21,440 --> 00:22:23,840
rejected with an

462
00:22:23,840 --> 00:22:27,679
output and a mm-io

463
00:22:27,679 --> 00:22:30,000
we can easily find their callback

464
00:22:30,000 --> 00:22:31,600
functions

465
00:22:31,600 --> 00:22:34,640
they are the parameters of the

466
00:22:34,640 --> 00:22:36,640
registration function

467
00:22:36,640 --> 00:22:40,240
next let's talk about io and mm-io

468
00:22:40,240 --> 00:22:42,480
callback functions

469
00:22:42,480 --> 00:22:45,360
as i mentioned earlier there are some

470
00:22:45,360 --> 00:22:46,159
instructions

471
00:22:46,159 --> 00:22:50,720
that can trigger io and mm-io callbacks

472
00:22:50,720 --> 00:22:53,919
such as the in and out instructions and

473
00:22:53,919 --> 00:22:56,880
move instruction

474
00:22:56,960 --> 00:22:59,200
and through in the figure their callback

475
00:22:59,200 --> 00:23:01,760
functions are similar

476
00:23:01,760 --> 00:23:05,600
and we need to focus on is which

477
00:23:05,600 --> 00:23:09,840
parameters the guest can control

478
00:23:09,840 --> 00:23:13,440
such as outside parameter usually

479
00:23:13,440 --> 00:23:18,320
two parameter cp parameter

480
00:23:18,320 --> 00:23:21,200
let's take the out instruction as an

481
00:23:21,200 --> 00:23:23,120
example

482
00:23:23,120 --> 00:23:26,640
the offside parameter represents

483
00:23:26,640 --> 00:23:30,400
the offsite based on the io part

484
00:23:30,400 --> 00:23:33,600
the u32 parameter is the

485
00:23:33,600 --> 00:23:36,720
value written

486
00:23:36,720 --> 00:23:39,919
the cb parameter represents

487
00:23:39,919 --> 00:23:44,880
the length of the usual parameter

488
00:23:46,080 --> 00:23:49,039
reviewing the virtualization systems

489
00:23:49,039 --> 00:23:50,559
usually starts with

490
00:23:50,559 --> 00:23:54,720
the io callback functions

491
00:23:54,720 --> 00:23:57,520
because this is the git fee for

492
00:23:57,520 --> 00:23:58,640
communication

493
00:23:58,640 --> 00:24:01,840
between guest and a host

494
00:24:01,840 --> 00:24:04,400
and through in the figure this is a

495
00:24:04,400 --> 00:24:05,840
callback function

496
00:24:05,840 --> 00:24:08,880
for the out instruction surely

497
00:24:08,880 --> 00:24:12,880
a device contains overviews registers

498
00:24:12,880 --> 00:24:14,559
we can see that when the offside

499
00:24:14,559 --> 00:24:17,039
parameter is zero

500
00:24:17,039 --> 00:24:20,320
usually two parameter represents the

501
00:24:20,320 --> 00:24:21,120
index

502
00:24:21,120 --> 00:24:25,679
of the registers where to be operate

503
00:24:25,679 --> 00:24:29,520
when offsite parameter is one

504
00:24:29,520 --> 00:24:32,240
usually two parameter represents the

505
00:24:32,240 --> 00:24:33,840
value to be written

506
00:24:33,840 --> 00:24:38,159
to the regester this register

507
00:24:38,159 --> 00:24:42,640
is specified when the offset parameter

508
00:24:42,640 --> 00:24:46,720
is zero as shown in the figure

509
00:24:46,720 --> 00:24:50,880
this is a mm-io callback function

510
00:24:50,880 --> 00:24:55,200
triggered by the moon instruction

511
00:24:55,200 --> 00:24:58,400
it should be noted that the moon

512
00:24:58,400 --> 00:24:59,520
instruction here

513
00:24:59,520 --> 00:25:03,120
is to write date to a fixed guest

514
00:25:03,120 --> 00:25:07,520
physical address the physical address

515
00:25:07,520 --> 00:25:10,880
can be directly excised in the guest

516
00:25:10,880 --> 00:25:15,440
you need to map the virtual memory first

517
00:25:15,440 --> 00:25:20,000
and then move it in addition to io part

518
00:25:20,000 --> 00:25:22,640
there is another important communication

519
00:25:22,640 --> 00:25:23,840
method

520
00:25:23,840 --> 00:25:26,880
directly memory excise

521
00:25:26,880 --> 00:25:29,279
in this way the host and the guest

522
00:25:29,279 --> 00:25:30,159
communicates

523
00:25:30,159 --> 00:25:32,320
by directly reading and writing the

524
00:25:32,320 --> 00:25:35,039
physical memory of the guest

525
00:25:35,039 --> 00:25:38,000
this is a very efficient communication

526
00:25:38,000 --> 00:25:39,120
mode

527
00:25:39,120 --> 00:25:42,559
but it needs a host and the guest to

528
00:25:42,559 --> 00:25:46,559
negotiate the physical address

529
00:25:46,640 --> 00:25:49,440
this process is usually completed by io

530
00:25:49,440 --> 00:25:51,039
port communication

531
00:25:51,039 --> 00:25:54,080
for example the guest sends a physical

532
00:25:54,080 --> 00:25:57,360
address to the host through io port

533
00:25:57,360 --> 00:26:00,000
then the host reads more date through

534
00:26:00,000 --> 00:26:02,480
the physical address

535
00:26:02,480 --> 00:26:05,520
in this way the guest did

536
00:26:05,520 --> 00:26:08,880
will enter the host space virtualbox

537
00:26:08,880 --> 00:26:10,080
usually use

538
00:26:10,080 --> 00:26:12,799
the two functions shown in the figure to

539
00:26:12,799 --> 00:26:14,720
complete such as the physical address

540
00:26:14,720 --> 00:26:15,440
reading and

541
00:26:15,440 --> 00:26:19,919
writing they need to care about a3

542
00:26:19,919 --> 00:26:23,440
parameters gc physicals

543
00:26:23,440 --> 00:26:27,279
she may burp and cp right gc physicals

544
00:26:27,279 --> 00:26:29,440
is against the physical advice

545
00:26:29,440 --> 00:26:31,679
public buffer is the powerful to be

546
00:26:31,679 --> 00:26:32,480
written and

547
00:26:32,480 --> 00:26:36,000
read cb right of cp read

548
00:26:36,000 --> 00:26:40,720
is the length of reading and writing

549
00:26:41,039 --> 00:26:43,520
and true in the figure this is an

550
00:26:43,520 --> 00:26:44,400
example

551
00:26:44,400 --> 00:26:48,320
of reading guest physical memory

552
00:26:48,320 --> 00:26:51,039
this is a function in the e1k network

553
00:26:51,039 --> 00:26:52,880
card device

554
00:26:52,880 --> 00:26:56,400
which obtains suited package by directly

555
00:26:56,400 --> 00:26:59,840
reading the guest physical memory

556
00:26:59,840 --> 00:27:02,799
therefore this is also an important

557
00:27:02,799 --> 00:27:06,000
attack service we need to care about

558
00:27:06,000 --> 00:27:09,120
even more important than io because the

559
00:27:09,120 --> 00:27:09,919
date rate

560
00:27:09,919 --> 00:27:12,799
in this way will be larger and more

561
00:27:12,799 --> 00:27:15,279
complex

562
00:27:15,279 --> 00:27:17,760
next we introduce the credit review of

563
00:27:17,760 --> 00:27:18,840
bank and

564
00:27:18,840 --> 00:27:21,520
communication the first is usb

565
00:27:21,520 --> 00:27:24,960
backend similar to the device

566
00:27:24,960 --> 00:27:28,399
the usb band defines the pdm usb

567
00:27:28,399 --> 00:27:30,720
register structure

568
00:27:30,720 --> 00:27:33,440
which unifies the interface for the usb

569
00:27:33,440 --> 00:27:35,200
bank and

570
00:27:35,200 --> 00:27:38,240
what we need to focus on is the function

571
00:27:38,240 --> 00:27:39,440
uibq

572
00:27:39,440 --> 00:27:43,279
callback function and the usb packet

573
00:27:43,279 --> 00:27:46,159
sent by the guest is finally processed

574
00:27:46,159 --> 00:27:48,720
by this function

575
00:27:48,720 --> 00:27:53,919
another important structure is v usb urb

576
00:27:53,919 --> 00:27:56,080
which defines the bridge between usb

577
00:27:56,080 --> 00:27:57,279
controller device

578
00:27:57,279 --> 00:28:00,559
and the usb backend

579
00:28:00,559 --> 00:28:03,760
as mentioned earlier after the usb

580
00:28:03,760 --> 00:28:06,480
controller receives a usb data packet

581
00:28:06,480 --> 00:28:08,399
from the guest

582
00:28:08,399 --> 00:28:12,799
it first sends it to the urb

583
00:28:12,799 --> 00:28:16,320
uip measures the date and then sends it

584
00:28:16,320 --> 00:28:19,520
to the usb banker for processing

585
00:28:19,520 --> 00:28:23,039
therefore the urb machining process

586
00:28:23,039 --> 00:28:26,320
is our attention and

587
00:28:26,320 --> 00:28:30,080
we also need to focus on the ap date

588
00:28:30,080 --> 00:28:32,799
and disabilities failed in the urb

589
00:28:32,799 --> 00:28:34,080
structure

590
00:28:34,080 --> 00:28:36,320
the embedded field is the usb this

591
00:28:36,320 --> 00:28:37,279
buffer

592
00:28:37,279 --> 00:28:39,919
and the cpt field is the length of the

593
00:28:39,919 --> 00:28:40,640
usb

594
00:28:40,640 --> 00:28:43,039
buffer

595
00:28:43,679 --> 00:28:49,120
they all are affected by the guests

596
00:28:49,120 --> 00:28:51,919
as through in the figure this is usb

597
00:28:51,919 --> 00:28:52,480
banker and

598
00:28:52,480 --> 00:28:55,760
gta switching function from here you can

599
00:28:55,760 --> 00:28:57,120
find all register

600
00:28:57,120 --> 00:29:01,279
usb battens and shown in the figure

601
00:29:01,279 --> 00:29:03,679
this is a quick copyright function of

602
00:29:03,679 --> 00:29:04,799
the usb

603
00:29:04,799 --> 00:29:09,919
msd backend the npt failed

604
00:29:09,919 --> 00:29:13,679
represents the type of usb date

605
00:29:13,679 --> 00:29:16,960
and the usb to packet is stored in

606
00:29:16,960 --> 00:29:20,320
curb parameter

607
00:29:20,320 --> 00:29:23,200
almost every usb bank current has such

608
00:29:23,200 --> 00:29:25,679
data processing logic

609
00:29:25,679 --> 00:29:29,120
next we talk about storage backend

610
00:29:29,120 --> 00:29:32,080
the storage backend defines the vt image

611
00:29:32,080 --> 00:29:32,799
background

612
00:29:32,799 --> 00:29:36,159
structure which unify the interface for

613
00:29:36,159 --> 00:29:38,559
the storage backend

614
00:29:38,559 --> 00:29:41,520
what we need to focus on is the function

615
00:29:41,520 --> 00:29:43,120
width and the pre-function write

616
00:29:43,120 --> 00:29:44,960
callback function

617
00:29:44,960 --> 00:29:47,440
because the final read and write to the

618
00:29:47,440 --> 00:29:48,480
hard disk

619
00:29:48,480 --> 00:29:52,320
will be handled by zero

620
00:29:52,320 --> 00:29:54,960
and show in the figure the picture on

621
00:29:54,960 --> 00:29:55,600
the left

622
00:29:55,600 --> 00:29:58,159
shows all the stories banking in water

623
00:29:58,159 --> 00:30:00,240
books

624
00:30:00,240 --> 00:30:02,720
it represents different disc image

625
00:30:02,720 --> 00:30:04,799
failed from this

626
00:30:04,799 --> 00:30:07,760
the picture on the right is the bank and

627
00:30:07,760 --> 00:30:08,720
structure of

628
00:30:08,720 --> 00:30:12,480
vmdk it contains various callback

629
00:30:12,480 --> 00:30:13,200
functions

630
00:30:13,200 --> 00:30:16,559
for this type of image

631
00:30:17,279 --> 00:30:20,320
next is the network backend

632
00:30:20,320 --> 00:30:23,039
as i mentioned earlier the network

633
00:30:23,039 --> 00:30:23,760
backend

634
00:30:23,760 --> 00:30:29,440
uses a slipper open source library

635
00:30:29,440 --> 00:30:32,320
a slayer for importer function is a

636
00:30:32,320 --> 00:30:35,200
state precision intro function

637
00:30:35,200 --> 00:30:37,919
the i buffer parameter contains the

638
00:30:37,919 --> 00:30:40,480
network date to be sent

639
00:30:40,480 --> 00:30:43,679
cb buffer is the length of the date when

640
00:30:43,679 --> 00:30:45,679
the network card device receives the

641
00:30:45,679 --> 00:30:47,360
network date package

642
00:30:47,360 --> 00:30:50,159
it will be sent here for the processing

643
00:30:50,159 --> 00:30:51,120
of the

644
00:30:51,120 --> 00:30:55,039
it's knight rip protocol stack

645
00:30:55,039 --> 00:30:58,720
next is the vmm device banker the vmm

646
00:30:58,720 --> 00:31:02,720
device banked and defines the vbug.gcm

647
00:31:02,720 --> 00:31:05,440
service function table structure

648
00:31:05,440 --> 00:31:08,320
it unifies the interface for the vm

649
00:31:08,320 --> 00:31:10,240
device background

650
00:31:10,240 --> 00:31:12,320
as shown in the figure the structure

651
00:31:12,320 --> 00:31:15,360
contains many callback functions

652
00:31:15,360 --> 00:31:18,000
they are responsible for the entire life

653
00:31:18,000 --> 00:31:18,960
cycle

654
00:31:18,960 --> 00:31:22,000
of xccm communication

655
00:31:22,000 --> 00:31:25,279
what we need to focus on is the function

656
00:31:25,279 --> 00:31:27,360
called callback function

657
00:31:27,360 --> 00:31:29,440
because it is the main function of the

658
00:31:29,440 --> 00:31:31,360
service

659
00:31:31,360 --> 00:31:34,480
mailbox as gcm service load is a

660
00:31:34,480 --> 00:31:35,120
function

661
00:31:35,120 --> 00:31:39,279
used to initialize the service

662
00:31:39,279 --> 00:31:42,080
each service contains this function we

663
00:31:42,080 --> 00:31:43,600
can find all services

664
00:31:43,600 --> 00:31:46,960
through this function in this function

665
00:31:46,960 --> 00:31:51,919
service is rejected for the table object

666
00:31:52,080 --> 00:31:54,880
and shown in the figure this is the core

667
00:31:54,880 --> 00:31:55,519
function

668
00:31:55,519 --> 00:31:59,519
of the guest probe service

669
00:31:59,519 --> 00:32:03,440
we are e function c parameters

670
00:32:03,440 --> 00:32:06,559
and the pcap parameters

671
00:32:06,559 --> 00:32:09,919
can be controlled by the guest make sure

672
00:32:09,919 --> 00:32:10,720
the pay attention

673
00:32:10,720 --> 00:32:14,480
to reserve next is the switch is

674
00:32:14,480 --> 00:32:16,000
redependent

675
00:32:16,000 --> 00:32:19,360
as i mentioned earlier svga3d banking

676
00:32:19,360 --> 00:32:23,200
includes directx and opengl

677
00:32:23,200 --> 00:32:26,000
as shown in the figure they define a

678
00:32:26,000 --> 00:32:28,080
unified interface

679
00:32:28,080 --> 00:32:31,360
so that the svga3d device only needs to

680
00:32:31,360 --> 00:32:33,120
call the interface

681
00:32:33,120 --> 00:32:38,158
and doesn't need to indefine the backend

682
00:32:39,039 --> 00:32:42,159
the interface of svg depend current

683
00:32:42,159 --> 00:32:46,159
usually corresponds to the svg 3d

684
00:32:46,159 --> 00:32:48,640
command

685
00:32:48,799 --> 00:32:51,519
and so in the figure the guest sends a

686
00:32:51,519 --> 00:32:53,679
service defined command

687
00:32:53,679 --> 00:32:56,640
which will be processed by the vms

688
00:32:56,640 --> 00:32:57,600
reduced led

689
00:32:57,600 --> 00:33:00,960
service device interface we need to pay

690
00:33:00,960 --> 00:33:03,279
attention to pc

691
00:33:03,279 --> 00:33:06,320
command parameter

692
00:33:06,320 --> 00:33:11,760
which is date controlled by the guest

693
00:33:11,760 --> 00:33:15,200
okay after introducing the code review

694
00:33:15,200 --> 00:33:18,399
lead to some interesting scenes how to

695
00:33:18,399 --> 00:33:20,799
automate back hunting

696
00:33:20,799 --> 00:33:24,159
first introduce a static detection

697
00:33:24,159 --> 00:33:28,159
method code cure

698
00:33:28,320 --> 00:33:30,799
code coil is an analysis engine used by

699
00:33:30,799 --> 00:33:32,000
developers

700
00:33:32,000 --> 00:33:35,279
to automate security strikes and by

701
00:33:35,279 --> 00:33:36,960
security researchers

702
00:33:36,960 --> 00:33:41,760
to perform variant analysis

703
00:33:41,840 --> 00:33:44,399
codecare compares code to a relational

704
00:33:44,399 --> 00:33:45,600
database

705
00:33:45,600 --> 00:33:50,240
which is created using semaql

706
00:33:50,240 --> 00:33:53,840
a declaring table object oriented

707
00:33:53,840 --> 00:33:56,240
through a language designed for program

708
00:33:56,240 --> 00:33:58,120
analysis

709
00:33:58,120 --> 00:34:00,640
audiocodecal can be used to find the

710
00:34:00,640 --> 00:34:01,519
code

711
00:34:01,519 --> 00:34:06,559
logic block grammatically

712
00:34:06,559 --> 00:34:10,000
the code clear basic workflow is that

713
00:34:10,000 --> 00:34:12,480
based on the analysis of historical

714
00:34:12,480 --> 00:34:14,399
vulnerabilities

715
00:34:14,399 --> 00:34:16,560
we write queries to find the code

716
00:34:16,560 --> 00:34:17,760
patterns

717
00:34:17,760 --> 00:34:22,800
that are thematically similar to them

718
00:34:22,800 --> 00:34:26,000
code clear analysis consists

719
00:34:26,000 --> 00:34:29,040
of three steps

720
00:34:29,040 --> 00:34:32,480
preparing the code by creating a

721
00:34:32,480 --> 00:34:36,560
good clear database second

722
00:34:36,560 --> 00:34:39,040
running code k aquarius against the

723
00:34:39,040 --> 00:34:41,679
database

724
00:34:42,000 --> 00:34:46,719
third integrating the query results

725
00:34:47,440 --> 00:34:51,839
for example answer in the figure

726
00:34:51,839 --> 00:34:54,560
this is create a good clear database of

727
00:34:54,560 --> 00:34:56,719
virtualbox

728
00:34:56,719 --> 00:34:59,280
for example we now want to find out the

729
00:34:59,280 --> 00:34:59,760
length

730
00:34:59,760 --> 00:35:02,800
parameter of a memo copy controllable by

731
00:35:02,800 --> 00:35:04,240
the guest

732
00:35:04,240 --> 00:35:07,359
first we determine the source of the

733
00:35:07,359 --> 00:35:08,720
date

734
00:35:08,720 --> 00:35:11,920
and the picture shows take up as

735
00:35:11,920 --> 00:35:15,920
example here purp contains a user

736
00:35:15,920 --> 00:35:17,760
controllable lens

737
00:35:17,760 --> 00:35:23,440
so find functions that use upurp

738
00:35:23,760 --> 00:35:26,560
second we need to determine the

739
00:35:26,560 --> 00:35:28,320
destination

740
00:35:28,320 --> 00:35:31,680
the destination here is the third lens

741
00:35:31,680 --> 00:35:34,960
parameter of mem copy

742
00:35:34,960 --> 00:35:37,280
so we look further so the parameter of

743
00:35:37,280 --> 00:35:38,640
mem curve

744
00:35:38,640 --> 00:35:41,680
and the source of this parameter is

745
00:35:41,680 --> 00:35:46,560
related to p u r b

746
00:35:46,560 --> 00:35:49,520
third and the date polluted by

747
00:35:49,520 --> 00:35:51,599
substitute to query

748
00:35:51,599 --> 00:35:55,200
for example in exception a to b

749
00:35:55,200 --> 00:35:58,400
point c the date follows

750
00:35:58,400 --> 00:36:01,839
from a to c finally

751
00:36:01,839 --> 00:36:05,280
execute the query we use date flow

752
00:36:05,280 --> 00:36:09,520
it will search the path automatically

753
00:36:09,520 --> 00:36:11,599
next we check the result and find

754
00:36:11,599 --> 00:36:13,359
vulnerabilities

755
00:36:13,359 --> 00:36:17,280
the script has more than 30 results

756
00:36:17,280 --> 00:36:20,240
of which more than 10 are duplicates

757
00:36:20,240 --> 00:36:20,960
suddenly

758
00:36:20,960 --> 00:36:23,920
after a short inspection two unabilities

759
00:36:23,920 --> 00:36:26,480
are found

760
00:36:26,480 --> 00:36:30,320
okay next let's try to use dynamic

761
00:36:30,320 --> 00:36:34,560
parsing here i use the afl plus plus

762
00:36:34,560 --> 00:36:36,880
tool

763
00:36:36,960 --> 00:36:40,960
afl is a father that employs genetic

764
00:36:40,960 --> 00:36:44,640
algorithms in order to efficiently

765
00:36:44,640 --> 00:36:47,119
increase the code coverage of the test

766
00:36:47,119 --> 00:36:48,720
cases

767
00:36:48,720 --> 00:36:52,240
fl platforms is a super rare work

768
00:36:52,240 --> 00:36:57,040
to google's afl more speed

769
00:36:57,040 --> 00:36:59,680
more and better mutations more and

770
00:36:59,680 --> 00:37:00,520
better

771
00:37:00,520 --> 00:37:04,000
instrumentation customer mode support

772
00:37:04,000 --> 00:37:07,280
and so on for more details please refer

773
00:37:07,280 --> 00:37:09,839
to github

774
00:37:10,640 --> 00:37:13,599
there are three steps for funding such

775
00:37:13,599 --> 00:37:14,800
code

776
00:37:14,800 --> 00:37:17,760
first compare the target with a special

777
00:37:17,760 --> 00:37:19,040
compiler

778
00:37:19,040 --> 00:37:22,000
that prepares the target to be fast

779
00:37:22,000 --> 00:37:24,079
efficiently

780
00:37:24,079 --> 00:37:27,359
this type is called instrumenting a

781
00:37:27,359 --> 00:37:29,839
target

782
00:37:30,000 --> 00:37:33,119
second prepare the fusing by selecting

783
00:37:33,119 --> 00:37:35,119
and optimizing the

784
00:37:35,119 --> 00:37:39,520
input couplers for the target

785
00:37:41,520 --> 00:37:44,720
third perform the fuzzing of the target

786
00:37:44,720 --> 00:37:48,400
by randomly mutating input and

787
00:37:48,400 --> 00:37:51,760
resizing of the general order input

788
00:37:51,760 --> 00:37:54,320
was processed in a new parts in the

789
00:37:54,320 --> 00:37:57,119
target binary

790
00:37:57,119 --> 00:38:01,200
afl plus plus has four moves

791
00:38:01,200 --> 00:38:04,079
the advantages are true in the figure

792
00:38:04,079 --> 00:38:04,640
please

793
00:38:04,640 --> 00:38:08,640
refer to github for details

794
00:38:08,800 --> 00:38:12,000
using afl plus plus in virtualbox i

795
00:38:12,000 --> 00:38:13,520
encountered

796
00:38:13,520 --> 00:38:17,359
four kinds of work problems

797
00:38:17,359 --> 00:38:19,920
the first is the problem of failing to

798
00:38:19,920 --> 00:38:21,440
compare

799
00:38:21,440 --> 00:38:24,800
the second is the problem of choosing

800
00:38:24,800 --> 00:38:27,200
why there are two files and a whole are

801
00:38:27,200 --> 00:38:29,040
split into independent

802
00:38:29,040 --> 00:38:32,240
components for fuzzing

803
00:38:32,240 --> 00:38:36,880
in addition where is the loop of fuzzing

804
00:38:36,880 --> 00:38:39,839
finally how to improve the performance

805
00:38:39,839 --> 00:38:40,079
of

806
00:38:40,079 --> 00:38:43,680
fuzzing first let's talk about

807
00:38:43,680 --> 00:38:46,880
compare problems

808
00:38:46,880 --> 00:38:50,079
when compelling virtualbox with fl plus

809
00:38:50,079 --> 00:38:50,880
plus

810
00:38:50,880 --> 00:38:53,359
the first thing i started off was to

811
00:38:53,359 --> 00:38:54,240
modify

812
00:38:54,240 --> 00:38:57,440
configure file to transfer

813
00:38:57,440 --> 00:39:01,680
cc and cxx to fl ceiling first and

814
00:39:01,680 --> 00:39:05,119
fl ceiling first plus plus

815
00:39:05,119 --> 00:39:07,119
but there were a lot of errors when

816
00:39:07,119 --> 00:39:08,800
comparing

817
00:39:08,800 --> 00:39:11,839
and even c grammar

818
00:39:11,839 --> 00:39:15,040
that clan couldn't recognize

819
00:39:15,040 --> 00:39:19,920
so that i couldn't fix it easily

820
00:39:20,480 --> 00:39:23,280
after research i found that there's this

821
00:39:23,280 --> 00:39:24,000
code

822
00:39:24,000 --> 00:39:27,040
that failed to compare is not related to

823
00:39:27,040 --> 00:39:30,480
the component we want to files such as

824
00:39:30,480 --> 00:39:31,680
ui related

825
00:39:31,680 --> 00:39:35,920
kernel related and some assembly files

826
00:39:35,920 --> 00:39:38,800
therefore i can say the mixed

827
00:39:38,800 --> 00:39:40,800
compilation

828
00:39:40,800 --> 00:39:43,440
the source code of first needs to be

829
00:39:43,440 --> 00:39:46,000
compared with afl plus plus

830
00:39:46,000 --> 00:39:49,440
and the other are compared with our

831
00:39:49,440 --> 00:39:52,800
original gcc

832
00:39:53,200 --> 00:39:56,480
fortunately the compilation framework of

833
00:39:56,480 --> 00:39:59,520
virtualbox is very easy to do this

834
00:39:59,520 --> 00:40:02,960
kmk is a tablet based compilation

835
00:40:02,960 --> 00:40:05,119
framework

836
00:40:05,119 --> 00:40:08,480
ultrabooks defines a template for each

837
00:40:08,480 --> 00:40:09,599
module

838
00:40:09,599 --> 00:40:12,720
they only need to modify the specified

839
00:40:12,720 --> 00:40:17,040
template so we can do like this

840
00:40:17,040 --> 00:40:20,079
create an afl.kmq file in keybuilder

841
00:40:20,079 --> 00:40:22,000
tools directory

842
00:40:22,000 --> 00:40:27,200
which can be copied from keyboard 12 gxx

843
00:40:27,200 --> 00:40:31,280
64 dot qm keyframe

844
00:40:31,280 --> 00:40:33,440
and the rest of the airfield compare

845
00:40:33,440 --> 00:40:36,960
this controller into it

846
00:40:37,440 --> 00:40:41,040
next we'll define the config.kmk file

847
00:40:41,040 --> 00:40:44,079
and change the compilation tool of the

848
00:40:44,079 --> 00:40:46,400
first model you need to airfare

849
00:40:46,400 --> 00:40:49,520
then you can compare it there may still

850
00:40:49,520 --> 00:40:51,040
be some errors

851
00:40:51,040 --> 00:40:54,160
but they can be easily resolved so i

852
00:40:54,160 --> 00:40:57,520
want to repeat them here

853
00:40:58,400 --> 00:41:00,800
the most common use of airfare is to

854
00:41:00,800 --> 00:41:03,119
find the separate library

855
00:41:03,119 --> 00:41:06,160
such as lab.xml

856
00:41:06,160 --> 00:41:08,160
there are also some libraries that can

857
00:41:08,160 --> 00:41:10,560
be fast in virtual books

858
00:41:10,560 --> 00:41:14,560
such as the slide shader lab

859
00:41:14,560 --> 00:41:17,280
but this is only a small part of their

860
00:41:17,280 --> 00:41:18,640
virtual box

861
00:41:18,640 --> 00:41:22,000
most of the others are strongly

862
00:41:22,000 --> 00:41:25,599
copper with the core

863
00:41:25,599 --> 00:41:29,440
such as the devices and the back ends

864
00:41:29,440 --> 00:41:31,760
these components are difficult to

865
00:41:31,760 --> 00:41:32,560
separate

866
00:41:32,560 --> 00:41:35,839
and run independently

867
00:41:35,839 --> 00:41:39,920
therefore split fires will not be able

868
00:41:39,920 --> 00:41:40,400
to

869
00:41:40,400 --> 00:41:44,000
cover completely in the end i'll choose

870
00:41:44,000 --> 00:41:44,400
the

871
00:41:44,400 --> 00:41:48,160
faster complete waterproofs

872
00:41:48,160 --> 00:41:50,960
because virtualbox is not a standard

873
00:41:50,960 --> 00:41:52,319
input and output

874
00:41:52,319 --> 00:41:55,359
program and it isn't

875
00:41:55,359 --> 00:41:58,400
a one-time execution program

876
00:41:58,400 --> 00:42:01,839
so we need to make it accept input and

877
00:42:01,839 --> 00:42:04,240
after processing

878
00:42:04,240 --> 00:42:06,880
therefore i designed a virtual box for

879
00:42:06,880 --> 00:42:08,400
circle

880
00:42:08,400 --> 00:42:10,960
first using vbox headlights and the

881
00:42:10,960 --> 00:42:11,680
startup

882
00:42:11,680 --> 00:42:14,839
program it will avoid loading the ui

883
00:42:14,839 --> 00:42:16,880
program

884
00:42:16,880 --> 00:42:20,480
second i end the p function files

885
00:42:20,480 --> 00:42:21,200
intrigue

886
00:42:21,200 --> 00:42:24,400
callback function to the pdm device

887
00:42:24,400 --> 00:42:26,079
register structure

888
00:42:26,079 --> 00:42:30,079
which is the first entry for each device

889
00:42:30,079 --> 00:42:33,440
and after power off

890
00:42:33,440 --> 00:42:36,640
i will call the p function for the entry

891
00:42:36,640 --> 00:42:37,280
function

892
00:42:37,280 --> 00:42:41,440
of each device finally

893
00:42:41,440 --> 00:42:44,560
close the autobots

894
00:42:44,560 --> 00:42:47,119
the main first coder is the gmp function

895
00:42:47,119 --> 00:42:48,800
files entry

896
00:42:48,800 --> 00:42:51,440
and we can directly call the io port

897
00:42:51,440 --> 00:42:52,079
handler

898
00:42:52,079 --> 00:42:55,839
and mml handler

899
00:42:55,839 --> 00:42:59,119
its parameters are taken from the input

900
00:42:59,119 --> 00:42:59,599
of

901
00:42:59,599 --> 00:43:04,000
afl in addition for directory

902
00:43:04,000 --> 00:43:07,359
physical memory with operations

903
00:43:07,359 --> 00:43:11,760
we also need to modify it to obtain from

904
00:43:11,760 --> 00:43:14,960
the afl input

905
00:43:15,200 --> 00:43:17,920
and show in the figure the picture on

906
00:43:17,920 --> 00:43:18,720
the left

907
00:43:18,720 --> 00:43:21,440
is the first entry function of the hd8

908
00:43:21,440 --> 00:43:23,040
device

909
00:43:23,040 --> 00:43:26,400
it mainly performs a fascist on the

910
00:43:26,400 --> 00:43:30,720
mmio handler of the hd8 device

911
00:43:30,720 --> 00:43:32,960
and the picture on the right is the

912
00:43:32,960 --> 00:43:34,640
first entry function of

913
00:43:34,640 --> 00:43:38,720
the pc9 device which performs a fast

914
00:43:38,720 --> 00:43:41,040
ties on the i o port handler

915
00:43:41,040 --> 00:43:44,640
of the pc9 device

916
00:43:44,720 --> 00:43:47,920
as shown in the figure this is a hook to

917
00:43:47,920 --> 00:43:48,880
the directory

918
00:43:48,880 --> 00:43:52,319
memory of size function and its this

919
00:43:52,319 --> 00:43:52,960
source

920
00:43:52,960 --> 00:43:56,880
is changed to afl which also makes

921
00:43:56,880 --> 00:44:00,880
a fast task when we calculate the first

922
00:44:00,880 --> 00:44:05,200
version or first let's run very slowly

923
00:44:05,200 --> 00:44:08,240
about two times in a second

924
00:44:08,240 --> 00:44:11,599
which couldn't meet our needs at all

925
00:44:11,599 --> 00:44:16,480
so we studied the optimization rule

926
00:44:16,720 --> 00:44:19,680
the biggest reason for the slowness is

927
00:44:19,680 --> 00:44:21,839
the start-up

928
00:44:21,839 --> 00:44:25,760
so we use persistent mode

929
00:44:25,760 --> 00:44:29,599
a cool feature of airflow plus

930
00:44:29,599 --> 00:44:32,400
first we load airflow loop after power

931
00:44:32,400 --> 00:44:33,599
up

932
00:44:33,599 --> 00:44:35,760
and then after the first inch is

933
00:44:35,760 --> 00:44:37,680
complete

934
00:44:37,680 --> 00:44:40,800
manually called device resize to ensure

935
00:44:40,800 --> 00:44:44,560
the consistency of the state

936
00:44:44,560 --> 00:44:47,119
but even this is very slow because the

937
00:44:47,119 --> 00:44:47,680
resize

938
00:44:47,680 --> 00:44:50,800
of the device is a waste of time

939
00:44:50,800 --> 00:44:54,640
and it can't be placed outside the loop

940
00:44:54,640 --> 00:44:58,000
therefore we need to optimize the resize

941
00:44:58,000 --> 00:44:58,319
of

942
00:44:58,319 --> 00:45:03,119
each device after optimization

943
00:45:03,119 --> 00:45:07,599
and finally miss the requestment of fast

944
00:45:07,599 --> 00:45:11,760
by using the above three myself

945
00:45:11,760 --> 00:45:14,160
10 plus vulnerabilities were finally

946
00:45:14,160 --> 00:45:15,760
found

947
00:45:15,760 --> 00:45:19,440
next i will introduce some of them

948
00:45:19,440 --> 00:45:23,280
past three can study first

949
00:45:23,280 --> 00:45:26,599
let's talk about cve 2021

950
00:45:26,599 --> 00:45:31,119
2112 this is a memory corruption

951
00:45:31,119 --> 00:45:34,800
in usb msd bankruptcy from

952
00:45:34,800 --> 00:45:38,160
guest to host and during the figure

953
00:45:38,160 --> 00:45:40,640
we can start from the ohci controller

954
00:45:40,640 --> 00:45:42,240
device

955
00:45:42,240 --> 00:45:45,280
and decide oxcid and

956
00:45:45,280 --> 00:45:49,280
citd through io part

957
00:45:49,280 --> 00:45:52,960
then two structure contains the physical

958
00:45:52,960 --> 00:45:53,599
address

959
00:45:53,599 --> 00:45:57,040
of the data packet and the id of

960
00:45:57,040 --> 00:46:00,800
the back end

961
00:46:00,800 --> 00:46:05,920
next start ohci work list

962
00:46:05,920 --> 00:46:08,400
the controller will read the usb data

963
00:46:08,400 --> 00:46:10,000
from the prepares

964
00:46:10,000 --> 00:46:14,000
physical device the ohcs sends the date

965
00:46:14,000 --> 00:46:15,680
to urb call

966
00:46:15,680 --> 00:46:18,880
your bitcoin measures the date and calls

967
00:46:18,880 --> 00:46:20,240
a quick function of

968
00:46:20,240 --> 00:46:23,599
msd by the backend id

969
00:46:23,599 --> 00:46:26,839
and sends a measured date to it

970
00:46:26,839 --> 00:46:30,240
finally when peers seen the usb

971
00:46:30,240 --> 00:46:33,920
date in the msd quick function the lens

972
00:46:33,920 --> 00:46:40,000
was not checked so resulting in oow

973
00:46:40,000 --> 00:46:42,400
let's see the source susquehanna and

974
00:46:42,400 --> 00:46:44,240
three in the figure

975
00:46:44,240 --> 00:46:47,920
cp copy can be controlled by the guest

976
00:46:47,920 --> 00:46:51,040
because the value is not checked it

977
00:46:51,040 --> 00:46:56,400
leads to out of bounds writing this is

978
00:46:56,400 --> 00:46:57,520
the stack trace

979
00:46:57,520 --> 00:47:00,960
as a crash we can easily say that

980
00:47:00,960 --> 00:47:04,240
this is a vulnerability in the usb msd

981
00:47:04,240 --> 00:47:05,680
background

982
00:47:05,680 --> 00:47:08,839
which caused the memory to ride out of

983
00:47:08,839 --> 00:47:10,640
bonds

984
00:47:10,640 --> 00:47:14,839
next let's talk about series 2021

985
00:47:14,839 --> 00:47:18,960
2131 this is the stack trash

986
00:47:18,960 --> 00:47:22,559
and the crash a trillion finger

987
00:47:22,559 --> 00:47:27,680
this is a oow of urp core

988
00:47:28,000 --> 00:47:31,200
it is caused by your becomes incorrect

989
00:47:31,200 --> 00:47:34,480
track of the disneyland we are using

990
00:47:34,480 --> 00:47:36,160
your ci controller

991
00:47:36,160 --> 00:47:40,319
here next let's talk about cve

992
00:47:40,319 --> 00:47:44,960
2021 2120

993
00:47:45,200 --> 00:47:48,720
this is the stack test and the crash

994
00:47:48,720 --> 00:47:51,520
and swing the figure this is an oor of

995
00:47:51,520 --> 00:47:55,440
the lsi logic as csi device

996
00:47:55,440 --> 00:47:58,720
this is a device vulnerability it can be

997
00:47:58,720 --> 00:48:00,079
seen from the stack

998
00:48:00,079 --> 00:48:03,359
trace and it is caused by the

999
00:48:03,359 --> 00:48:06,880
correct tracking of the lens field

1000
00:48:06,880 --> 00:48:10,240
when processing the ipod

1001
00:48:10,240 --> 00:48:13,599
next we will complete this last step

1002
00:48:13,599 --> 00:48:17,640
the exploit here is the series u1021

1003
00:48:17,640 --> 00:48:21,520
2118 as an example

1004
00:48:21,520 --> 00:48:23,920
first let's talk about the course of the

1005
00:48:23,920 --> 00:48:26,559
vulnerability

1006
00:48:26,559 --> 00:48:29,040
the weapon that says i read the string

1007
00:48:29,040 --> 00:48:30,400
function

1008
00:48:30,400 --> 00:48:33,680
is the repeating instruction handler of

1009
00:48:33,680 --> 00:48:34,640
the ssl

1010
00:48:34,640 --> 00:48:38,079
device cp transfer field

1011
00:48:38,079 --> 00:48:41,280
is controllable by the guest

1012
00:48:41,280 --> 00:48:45,200
and the leak of checks are cp transfer

1013
00:48:45,200 --> 00:48:48,720
and cp buffer life in v boxes design

1014
00:48:48,720 --> 00:48:50,800
reading string function

1015
00:48:50,800 --> 00:48:54,000
leads to oor

1016
00:48:54,319 --> 00:48:56,960
the most serious problem of this

1017
00:48:56,960 --> 00:48:57,920
vulnerability

1018
00:48:57,920 --> 00:49:00,800
is that the cp buffer live intake

1019
00:49:00,800 --> 00:49:03,280
overflow caused by the vulnerability in

1020
00:49:03,280 --> 00:49:03,920
v-bucks

1021
00:49:03,920 --> 00:49:07,520
and csi risk chain which can bypass

1022
00:49:07,520 --> 00:49:10,559
than to check out with cp buffer left

1023
00:49:10,559 --> 00:49:13,839
greater than zero in v bugs as desired

1024
00:49:13,839 --> 00:49:15,760
writing string function

1025
00:49:15,760 --> 00:49:19,839
this will be resulting in oow

1026
00:49:19,839 --> 00:49:22,640
therefore the variability can cause

1027
00:49:22,640 --> 00:49:23,200
outer

1028
00:49:23,200 --> 00:49:27,040
bounds with android which is very

1029
00:49:27,040 --> 00:49:28,839
suitable for

1030
00:49:28,839 --> 00:49:31,839
exploitation

1031
00:49:32,079 --> 00:49:35,119
this vulnerability has been exploited by

1032
00:49:35,119 --> 00:49:38,640
sour cloud team in real world ctf

1033
00:49:38,640 --> 00:49:41,599
the red top link is as follows its

1034
00:49:41,599 --> 00:49:44,960
version mainly use fccm related objects

1035
00:49:44,960 --> 00:49:47,680
for more hccm usage please driver to

1036
00:49:47,680 --> 00:49:49,920
source cloud's red hub

1037
00:49:49,920 --> 00:49:52,319
today we will introduce another

1038
00:49:52,319 --> 00:49:53,599
exploiter

1039
00:49:53,599 --> 00:49:57,119
rivet table which is related

1040
00:49:57,119 --> 00:50:00,960
to svg's led ultrabooks is very

1041
00:50:00,960 --> 00:50:03,040
difficult to work on the root

1042
00:50:03,040 --> 00:50:06,720
of 3d the other version

1043
00:50:06,720 --> 00:50:13,839
of virtualbox society is premium

1044
00:50:14,240 --> 00:50:16,240
that brings many security

1045
00:50:16,240 --> 00:50:18,720
vulnerabilities to a virtual both

1046
00:50:18,720 --> 00:50:22,079
therefore this model was deleted after

1047
00:50:22,079 --> 00:50:24,319
version 6.1

1048
00:50:24,319 --> 00:50:27,760
and the useful primitive cr connection

1049
00:50:27,760 --> 00:50:29,760
and the cr client

1050
00:50:29,760 --> 00:50:33,040
was also deleted then

1051
00:50:33,040 --> 00:50:36,559
i analyzed the svh3d

1052
00:50:36,559 --> 00:50:41,200
which replaces the vapour society

1053
00:50:41,200 --> 00:50:44,400
under funds that it also has a great use

1054
00:50:44,400 --> 00:50:47,760
of primitives

1055
00:50:48,960 --> 00:50:51,760
the exploit primitives are mainly vmware

1056
00:50:51,760 --> 00:50:55,119
switches with the map map label object

1057
00:50:55,119 --> 00:50:57,760
the mipmap object contains this buffer

1058
00:50:57,760 --> 00:51:00,640
point and the lens field

1059
00:51:00,640 --> 00:51:02,640
the content of this buffer can be

1060
00:51:02,640 --> 00:51:05,680
written and read by the guest

1061
00:51:05,680 --> 00:51:08,240
in addition the midfield object can also

1062
00:51:08,240 --> 00:51:09,599
be allocated

1063
00:51:09,599 --> 00:51:12,640
in any number and it can also look for

1064
00:51:12,640 --> 00:51:13,760
memory

1065
00:51:13,760 --> 00:51:16,640
in combination which means it can be

1066
00:51:16,640 --> 00:51:17,440
adapted

1067
00:51:17,440 --> 00:51:21,200
to many lines this is excellent

1068
00:51:21,200 --> 00:51:24,319
spread object

1069
00:51:25,040 --> 00:51:27,119
when we use vulnerabilities to change a

1070
00:51:27,119 --> 00:51:28,960
state buffer point

1071
00:51:28,960 --> 00:51:32,960
we can cause arbitrary address reading

1072
00:51:32,960 --> 00:51:33,280
and

1073
00:51:33,280 --> 00:51:37,119
writing the svg 3d command to apply for

1074
00:51:37,119 --> 00:51:38,400
this object

1075
00:51:38,400 --> 00:51:40,960
is the switch a3d command service

1076
00:51:40,960 --> 00:51:42,480
defined

1077
00:51:42,480 --> 00:51:45,520
and the svg3d command to read and write

1078
00:51:45,520 --> 00:51:46,480
date

1079
00:51:46,480 --> 00:51:51,839
is svg3d command surface dma

1080
00:51:52,880 --> 00:51:56,000
the next scene becomes very easy

1081
00:51:56,000 --> 00:51:58,640
through the hip supply we can get the

1082
00:51:58,640 --> 00:51:59,200
hip and

1083
00:51:59,200 --> 00:52:04,079
showing the figure get a series of

1084
00:52:04,079 --> 00:52:07,280
meep microarrays

1085
00:52:07,599 --> 00:52:10,640
and then freeze some of them create some

1086
00:52:10,640 --> 00:52:13,118
holes

1087
00:52:13,359 --> 00:52:16,640
next we create a vulnerable as csi

1088
00:52:16,640 --> 00:52:18,160
buffer object

1089
00:52:18,160 --> 00:52:21,440
assigned to the previously released

1090
00:52:21,440 --> 00:52:23,440
address

1091
00:52:23,440 --> 00:52:26,400
at this point the clip is laid out

1092
00:52:26,400 --> 00:52:28,800
finished

1093
00:52:29,599 --> 00:52:33,200
next we define the date point of mipman

1094
00:52:33,200 --> 00:52:36,400
by reading and writing out of bounds

1095
00:52:36,400 --> 00:52:39,760
resulting in arbitrary address reading

1096
00:52:39,760 --> 00:52:40,079
and

1097
00:52:40,079 --> 00:52:43,839
writing with arbitrary address read and

1098
00:52:43,839 --> 00:52:44,839
write

1099
00:52:44,839 --> 00:52:48,000
primitives you can easily find

1100
00:52:48,000 --> 00:52:53,200
some arbitrary challenge iip myself

1101
00:52:53,359 --> 00:52:57,119
such as modify some virtual table points

1102
00:52:57,119 --> 00:52:59,440
and there are many ways to link the base

1103
00:52:59,440 --> 00:53:01,359
address information

1104
00:53:01,359 --> 00:53:04,880
such as layout of svga 3d context

1105
00:53:04,880 --> 00:53:08,800
objects which will not be described

1106
00:53:08,800 --> 00:53:11,760
in detail here

1107
00:53:11,839 --> 00:53:16,000
part 4 demo time i see the effect

1108
00:53:16,000 --> 00:53:29,839
of the fennel escape

1109
00:53:48,240 --> 00:53:50,480
thanks very much for the help of my

1110
00:53:50,480 --> 00:53:51,920
colleges

1111
00:53:51,920 --> 00:53:55,359
they are carrying amphorax swing

1112
00:53:55,359 --> 00:53:59,280
exploit f1 wi-fi leo ima

1113
00:53:59,280 --> 00:54:04,319
xg thank you very much for watching

1114
00:54:04,319 --> 00:54:06,720
if you have any questions please contact

1115
00:54:06,720 --> 00:54:11,839
me email directly

