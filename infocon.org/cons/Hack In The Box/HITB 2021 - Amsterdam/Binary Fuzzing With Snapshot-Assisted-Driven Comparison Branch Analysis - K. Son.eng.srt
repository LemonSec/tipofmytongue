1
00:00:15,200 --> 00:00:17,199
hi everyone thank you for connect to our

2
00:00:17,199 --> 00:00:18,560
talk

3
00:00:18,560 --> 00:00:20,480
today i'm gonna talking about final

4
00:00:20,480 --> 00:00:21,840
reporting with

5
00:00:21,840 --> 00:00:24,640
snapchat assisted driven comparison

6
00:00:24,640 --> 00:00:26,960
franchise analysis

7
00:00:26,960 --> 00:00:30,160
i'm very excited to speak ahead here

8
00:00:30,160 --> 00:00:34,079
and happy to share our research with you

9
00:00:34,079 --> 00:00:36,800
many binary protein tools use mutation

10
00:00:36,800 --> 00:00:37,840
testing

11
00:00:37,840 --> 00:00:41,440
then and only generate test cases

12
00:00:41,440 --> 00:00:44,000
despite a lot of progress in

13
00:00:44,000 --> 00:00:45,039
mutation-based

14
00:00:45,039 --> 00:00:48,000
further there is an issue of taking

15
00:00:48,000 --> 00:00:49,600
unnecessary time

16
00:00:49,600 --> 00:00:52,239
to evaluate the conditional branches

17
00:00:52,239 --> 00:00:55,120
that compare complex inputs

18
00:00:55,120 --> 00:00:58,480
if a program requires a lot of input

19
00:00:58,480 --> 00:01:02,399
it's much more expensive to generate it

20
00:01:02,399 --> 00:01:06,640
supporting result may vary significantly

21
00:01:06,640 --> 00:01:09,280
depending on how value you perform the

22
00:01:09,280 --> 00:01:11,840
regeneration

23
00:01:11,840 --> 00:01:15,040
these regions modal project to

24
00:01:15,040 --> 00:01:19,280
input generation to support mutator

25
00:01:19,280 --> 00:01:22,560
in this talk we will introduce our

26
00:01:22,560 --> 00:01:27,840
approach over in food generation

27
00:01:28,960 --> 00:01:31,119
before i actually start quick

28
00:01:31,119 --> 00:01:32,240
introduction

29
00:01:32,240 --> 00:01:36,159
about myself my name is ki jung song

30
00:01:36,159 --> 00:01:38,240
currently i am security researcher at

31
00:01:38,240 --> 00:01:39,680
giza

32
00:01:39,680 --> 00:01:42,240
he's a united securities agency in south

33
00:01:42,240 --> 00:01:44,159
korea

34
00:01:44,159 --> 00:01:46,960
and also i am teaching penetration

35
00:01:46,960 --> 00:01:49,600
testing courses

36
00:01:49,600 --> 00:01:52,560
and previously i was vocal volunteer

37
00:01:52,560 --> 00:01:54,720
program major

38
00:01:54,720 --> 00:01:57,920
at that time my jury swore to georgie

39
00:01:57,920 --> 00:02:00,960
our critical volatility is

40
00:02:00,960 --> 00:02:03,360
and default root cause analysis of

41
00:02:03,360 --> 00:02:04,399
vulnerability

42
00:02:04,399 --> 00:02:07,680
to the vendor i am focused

43
00:02:07,680 --> 00:02:10,239
in i'm focusing mostly on vulnerability

44
00:02:10,239 --> 00:02:10,878
and

45
00:02:10,878 --> 00:02:14,399
exploitation research

46
00:02:17,200 --> 00:02:20,480
so this is the summary of our talk

47
00:02:20,480 --> 00:02:23,440
first we go we are gonna talk about why

48
00:02:23,440 --> 00:02:24,800
further leads

49
00:02:24,800 --> 00:02:27,680
to early the input generation people for

50
00:02:27,680 --> 00:02:29,360
software fuzzy

51
00:02:29,360 --> 00:02:32,879
and why we implement this tool and then

52
00:02:32,879 --> 00:02:34,720
for better understanding

53
00:02:34,720 --> 00:02:36,959
we introduce the whole design of our

54
00:02:36,959 --> 00:02:37,920
tool called

55
00:02:37,920 --> 00:02:41,120
live frenzy after that we are gonna

56
00:02:41,120 --> 00:02:43,040
given detail about

57
00:02:43,040 --> 00:02:46,800
how each of the stages is implemented

58
00:02:46,800 --> 00:02:49,200
and what we can do better to improve

59
00:02:49,200 --> 00:02:51,599
following result

60
00:02:51,599 --> 00:02:54,879
next i will describe how we can

61
00:02:54,879 --> 00:02:57,920
automatically extract input comparison

62
00:02:57,920 --> 00:02:59,280
value

63
00:02:59,280 --> 00:03:03,599
from binary also i will explain

64
00:03:03,599 --> 00:03:06,239
how to connect between computer and live

65
00:03:06,239 --> 00:03:07,519
branch

66
00:03:07,519 --> 00:03:11,120
which is our apprentice analyst tool

67
00:03:11,120 --> 00:03:14,080
by the end of talk i will show you

68
00:03:14,080 --> 00:03:17,440
simple demonstration

69
00:03:17,680 --> 00:03:21,360
so motivations a traditional problem in

70
00:03:21,360 --> 00:03:22,000
protein

71
00:03:22,000 --> 00:03:24,879
is product tend to get stocking input

72
00:03:24,879 --> 00:03:26,480
validation code

73
00:03:26,480 --> 00:03:29,599
during deterministic polling state

74
00:03:29,599 --> 00:03:32,400
so for the waste so many energies to

75
00:03:32,400 --> 00:03:35,599
satisfy input validation check

76
00:03:35,599 --> 00:03:38,400
in order to solve this constraint we

77
00:03:38,400 --> 00:03:40,959
need to supply feedback to further

78
00:03:40,959 --> 00:03:44,000
such as valid input

79
00:03:44,000 --> 00:03:46,879
you know most software vulnerabilities

80
00:03:46,879 --> 00:03:49,120
are highly associated

81
00:03:49,120 --> 00:03:53,120
with user input so test case generation

82
00:03:53,120 --> 00:03:54,319
is becoming

83
00:03:54,319 --> 00:03:58,319
more and more important part of body

84
00:03:58,319 --> 00:04:01,120
basically test case generation can be

85
00:04:01,120 --> 00:04:04,080
divided into two types

86
00:04:04,080 --> 00:04:07,280
mutation and generation

87
00:04:07,280 --> 00:04:09,280
the mutation is to find the

88
00:04:09,280 --> 00:04:10,640
vulnerability

89
00:04:10,640 --> 00:04:13,840
with randomly generated inputs

90
00:04:13,840 --> 00:04:16,959
however it takes a lot of program

91
00:04:16,959 --> 00:04:18,000
execution

92
00:04:18,000 --> 00:04:23,440
attempt and time to explore a typo path

93
00:04:23,440 --> 00:04:26,720
for example programs that has multiple

94
00:04:26,720 --> 00:04:27,680
inputs

95
00:04:27,680 --> 00:04:30,560
such as command line or interactive

96
00:04:30,560 --> 00:04:32,320
application

97
00:04:32,320 --> 00:04:35,280
has more comparison branches that hinder

98
00:04:35,280 --> 00:04:35,520
the

99
00:04:35,520 --> 00:04:39,040
protein so some

100
00:04:39,040 --> 00:04:41,919
mutation based product support user

101
00:04:41,919 --> 00:04:44,639
supplied dictionary

102
00:04:44,639 --> 00:04:47,680
this dictionary consists of keywords

103
00:04:47,680 --> 00:04:51,120
for feedback however

104
00:04:51,120 --> 00:04:53,680
manually making only procure this is

105
00:04:53,680 --> 00:04:56,080
very time consuming

106
00:04:56,080 --> 00:04:59,360
it requires human effort

107
00:04:59,360 --> 00:05:01,919
i don't want to spend too much time for

108
00:05:01,919 --> 00:05:03,520
this

109
00:05:03,520 --> 00:05:07,039
so we needed the functionality

110
00:05:07,039 --> 00:05:09,360
which can automatically generate

111
00:05:09,360 --> 00:05:10,720
interesting input

112
00:05:10,720 --> 00:05:13,440
for pausing

113
00:05:15,600 --> 00:05:18,479
here is a simple example why input

114
00:05:18,479 --> 00:05:19,840
generation

115
00:05:19,840 --> 00:05:23,280
makes better result as you can see we

116
00:05:23,280 --> 00:05:23,600
have

117
00:05:23,600 --> 00:05:27,199
three screenshots the scripture below

118
00:05:27,199 --> 00:05:31,199
show simple c program for testing

119
00:05:31,199 --> 00:05:34,320
this program first compare user input

120
00:05:34,320 --> 00:05:37,520
with six bytes string

121
00:05:37,520 --> 00:05:40,800
and then if 2 is equal we are able to

122
00:05:40,800 --> 00:05:42,880
move on to the next path

123
00:05:42,880 --> 00:05:47,600
which exists overflow volatility

124
00:05:47,680 --> 00:05:50,400
and the opposite screenshots is about

125
00:05:50,400 --> 00:05:51,280
two different

126
00:05:51,280 --> 00:05:54,639
mutation protein in the

127
00:05:54,639 --> 00:05:58,240
left upper window it mutates without any

128
00:05:58,240 --> 00:05:59,919
importance

129
00:05:59,919 --> 00:06:03,199
so it wasn't able to find you fast

130
00:06:03,199 --> 00:06:07,759
within the given time on the other hand

131
00:06:07,759 --> 00:06:10,800
in the light of the window it mutates

132
00:06:10,800 --> 00:06:11,520
with

133
00:06:11,520 --> 00:06:15,600
input dictionary we found you crash

134
00:06:15,600 --> 00:06:20,240
in 16 seconds it shows that there is

135
00:06:20,240 --> 00:06:23,520
logic performance difference

136
00:06:23,520 --> 00:06:26,560
also according to our test

137
00:06:26,560 --> 00:06:29,680
it took about 10 minutes to solve the

138
00:06:29,680 --> 00:06:32,840
two white comparison string without

139
00:06:32,840 --> 00:06:35,039
dictionary

140
00:06:35,039 --> 00:06:38,240
it turns out that a comparison over sean

141
00:06:38,240 --> 00:06:39,840
banks characters

142
00:06:39,840 --> 00:06:42,720
can be correctly matched in a short time

143
00:06:42,720 --> 00:06:46,160
even in the mutated input

144
00:06:46,160 --> 00:06:48,639
however in the case of complex and

145
00:06:48,639 --> 00:06:50,240
number strings

146
00:06:50,240 --> 00:06:53,039
it needs much more impulse to solve

147
00:06:53,039 --> 00:06:54,639
branch

148
00:06:54,639 --> 00:06:57,199
this is why products should although

149
00:06:57,199 --> 00:07:00,319
improve generation

150
00:07:01,759 --> 00:07:04,160
as i already mentioned the previous

151
00:07:04,160 --> 00:07:05,520
slide

152
00:07:05,520 --> 00:07:08,560
to reduce supporting time cost we need

153
00:07:08,560 --> 00:07:09,840
to generate valid

154
00:07:09,840 --> 00:07:14,080
inputs of the target program in advance

155
00:07:14,080 --> 00:07:16,880
so possible question is what's

156
00:07:16,880 --> 00:07:20,479
interesting inputs for further

157
00:07:20,479 --> 00:07:23,599
we can define like this is predefined

158
00:07:23,599 --> 00:07:28,479
inputs that are required by program

159
00:07:28,479 --> 00:07:31,440
some things that you may have noticed

160
00:07:31,440 --> 00:07:32,560
are things like

161
00:07:32,560 --> 00:07:35,759
option command file format

162
00:07:35,759 --> 00:07:39,440
protocol specification and so on

163
00:07:39,440 --> 00:07:41,440
we have been investigating for

164
00:07:41,440 --> 00:07:43,199
comparison pattern

165
00:07:43,199 --> 00:07:47,120
in various binaries it turns out that

166
00:07:47,120 --> 00:07:50,160
they tend to be compared at the front of

167
00:07:50,160 --> 00:07:51,199
the program

168
00:07:51,199 --> 00:07:54,240
after process initialization this is

169
00:07:54,240 --> 00:07:56,080
also an important point

170
00:07:56,080 --> 00:07:59,280
about the priority of tracing paths

171
00:07:59,280 --> 00:08:03,679
when you analyze the comparison flanges

172
00:08:03,919 --> 00:08:07,120
basically if refresher has informality

173
00:08:07,120 --> 00:08:10,560
it tries to achieve very code coverage

174
00:08:10,560 --> 00:08:14,160
and then move on to the mutation stage

175
00:08:14,160 --> 00:08:18,240
to generate the crash what that means

176
00:08:18,240 --> 00:08:21,280
is the input generation flow of ignore

177
00:08:21,280 --> 00:08:24,840
indicating you fast during product

178
00:08:24,840 --> 00:08:26,960
testing

179
00:08:26,960 --> 00:08:29,520
input generation have been adopted by

180
00:08:29,520 --> 00:08:30,000
many

181
00:08:30,000 --> 00:08:34,000
rotation-based folders so far

182
00:08:34,000 --> 00:08:36,559
and it's very hard research in the

183
00:08:36,559 --> 00:08:39,200
printful recording today

184
00:08:39,200 --> 00:08:41,120
here are some input generation

185
00:08:41,120 --> 00:08:42,240
techniques

186
00:08:42,240 --> 00:08:45,519
commonly used by producers

187
00:08:45,519 --> 00:08:48,080
first we can make a dictionary file

188
00:08:48,080 --> 00:08:48,720
which is

189
00:08:48,720 --> 00:08:51,920
referred to list of valid input

190
00:08:51,920 --> 00:08:55,200
and use deterministic stage

191
00:08:55,200 --> 00:08:58,480
for example american party law

192
00:08:58,480 --> 00:09:01,920
af has several common dictionaries

193
00:09:01,920 --> 00:09:05,200
in the cell directory this

194
00:09:05,200 --> 00:09:08,480
dictionary can be provided by user

195
00:09:08,480 --> 00:09:11,200
or automatically collected by generation

196
00:09:11,200 --> 00:09:13,519
2.

197
00:09:13,680 --> 00:09:16,320
and some products level is the symbolic

198
00:09:16,320 --> 00:09:17,040
or

199
00:09:17,040 --> 00:09:21,440
concrete execution to generate the input

200
00:09:21,440 --> 00:09:24,240
however there is some alone issue to be

201
00:09:24,240 --> 00:09:26,000
addressed

202
00:09:26,000 --> 00:09:28,640
simple quality executing program paths

203
00:09:28,640 --> 00:09:30,399
does not scale to large

204
00:09:30,399 --> 00:09:34,839
or complex problems such as the oral

205
00:09:34,839 --> 00:09:36,320
software

206
00:09:36,320 --> 00:09:38,480
and product can collect the seed

207
00:09:38,480 --> 00:09:40,959
template to generate the input

208
00:09:40,959 --> 00:09:44,080
on the internet from this

209
00:09:44,080 --> 00:09:47,279
it can provide multiple type of valid

210
00:09:47,279 --> 00:09:51,680
file formats and we can also generate

211
00:09:51,680 --> 00:09:52,399
the input

212
00:09:52,399 --> 00:09:57,440
using binary or source code analysis

213
00:09:57,440 --> 00:10:00,480
if we have a source called access it can

214
00:10:00,480 --> 00:10:02,079
be easier

215
00:10:02,079 --> 00:10:05,519
but our research target is only finally

216
00:10:05,519 --> 00:10:08,640
with our source code

217
00:10:08,880 --> 00:10:12,480
among these method we introduce

218
00:10:12,480 --> 00:10:15,519
what it decided to do is automatically

219
00:10:15,519 --> 00:10:16,880
make a dictionary

220
00:10:16,880 --> 00:10:21,279
using dynamic final analysis

221
00:10:24,640 --> 00:10:29,120
so how we learn to input inside binary

222
00:10:29,120 --> 00:10:32,560
for that our approach is full learning

223
00:10:32,560 --> 00:10:35,600
with international assisted comparison

224
00:10:35,600 --> 00:10:38,320
apprentice analysis

225
00:10:38,320 --> 00:10:40,480
before starting this research we

226
00:10:40,480 --> 00:10:44,160
reviewed the published research

227
00:10:44,160 --> 00:10:47,279
according to our investigation it seems

228
00:10:47,279 --> 00:10:47,680
that

229
00:10:47,680 --> 00:10:50,800
an input learning model for directly

230
00:10:50,800 --> 00:10:53,760
analyzing comparison branches

231
00:10:53,760 --> 00:10:57,839
has not been researched relatively

232
00:10:57,839 --> 00:11:00,640
so we made your decision to use this

233
00:11:00,640 --> 00:11:02,800
approach

234
00:11:02,800 --> 00:11:05,519
and also we thought this might be

235
00:11:05,519 --> 00:11:07,200
interesting

236
00:11:07,200 --> 00:11:14,480
and challenging task

237
00:11:14,480 --> 00:11:16,959
so before we introduce whole design of

238
00:11:16,959 --> 00:11:18,640
life french

239
00:11:18,640 --> 00:11:21,279
you might wonder why dream is like

240
00:11:21,279 --> 00:11:22,959
french

241
00:11:22,959 --> 00:11:28,160
i was inspired by the lighthouse

242
00:11:28,160 --> 00:11:30,560
as the lighthouse is used to guide the

243
00:11:30,560 --> 00:11:31,760
seeds

244
00:11:31,760 --> 00:11:35,519
light french illuminate the darker area

245
00:11:35,519 --> 00:11:38,800
that father cannot see

246
00:11:38,800 --> 00:11:42,800
and then it can guide it

247
00:11:42,800 --> 00:11:46,160
that's why we named it

248
00:11:46,160 --> 00:11:48,959
as you can see light branches consist of

249
00:11:48,959 --> 00:11:52,000
three major components

250
00:11:52,000 --> 00:11:55,200
its dynamic control flow constructor

251
00:11:55,200 --> 00:11:58,399
and the tenta analysis module and french

252
00:11:58,399 --> 00:12:01,120
analysis module

253
00:12:01,120 --> 00:12:04,079
first he actually load and execute the

254
00:12:04,079 --> 00:12:06,240
target finally

255
00:12:06,240 --> 00:12:09,519
next it tracks the flow related to

256
00:12:09,519 --> 00:12:12,639
input together with the support of

257
00:12:12,639 --> 00:12:15,680
slave share operation

258
00:12:15,680 --> 00:12:19,040
and then we identify comparison branches

259
00:12:19,040 --> 00:12:22,839
in the execution path based on tempting

260
00:12:22,839 --> 00:12:24,000
information

261
00:12:24,000 --> 00:12:26,560
branches analysis module can validate

262
00:12:26,560 --> 00:12:27,680
inputs

263
00:12:27,680 --> 00:12:30,320
by analyzing the operand value of the

264
00:12:30,320 --> 00:12:33,040
instruction

265
00:12:33,200 --> 00:12:35,680
main function of dynamic control program

266
00:12:35,680 --> 00:12:37,120
constructor

267
00:12:37,120 --> 00:12:40,160
is to take a selection

268
00:12:40,160 --> 00:12:43,600
it's actually selection engine and it

269
00:12:43,600 --> 00:12:44,079
also

270
00:12:44,079 --> 00:12:47,120
controls taint and flange analysis

271
00:12:47,120 --> 00:12:48,959
module

272
00:12:48,959 --> 00:12:52,959
for parallel result three borders work

273
00:12:52,959 --> 00:12:56,638
together organically

274
00:12:59,360 --> 00:13:02,240
now why we need abstraction for input

275
00:13:02,240 --> 00:13:03,760
generation

276
00:13:03,760 --> 00:13:06,639
solution insult technique that preserves

277
00:13:06,639 --> 00:13:07,360
data

278
00:13:07,360 --> 00:13:10,480
at a specific time and

279
00:13:10,480 --> 00:13:12,800
sunshine is widely used in cyber

280
00:13:12,800 --> 00:13:15,680
security industry

281
00:13:15,680 --> 00:13:19,279
as you can see our presentation topic

282
00:13:19,279 --> 00:13:22,560
the core idea of life branching is to

283
00:13:22,560 --> 00:13:25,760
leverage selection as well

284
00:13:25,760 --> 00:13:29,839
here are reasons why we use selection

285
00:13:29,839 --> 00:13:33,440
first we use snapchat to skip over

286
00:13:33,440 --> 00:13:37,360
sources startup code process startup

287
00:13:37,360 --> 00:13:39,839
code is unnecessary to generate the

288
00:13:39,839 --> 00:13:41,360
input

289
00:13:41,360 --> 00:13:44,959
because what we need to focus on is

290
00:13:44,959 --> 00:13:48,639
the instructions that after

291
00:13:48,639 --> 00:13:51,519
improve functions

292
00:13:51,760 --> 00:13:54,560
and we level the snapshot to execute

293
00:13:54,560 --> 00:13:55,920
both directions of

294
00:13:55,920 --> 00:13:59,600
conditional branch basically conditional

295
00:13:59,600 --> 00:14:00,160
branch

296
00:14:00,160 --> 00:14:03,360
jump to address depending on whether

297
00:14:03,360 --> 00:14:04,240
condition is

298
00:14:04,240 --> 00:14:07,279
true or not however

299
00:14:07,279 --> 00:14:10,880
we can execute both directions if we

300
00:14:10,880 --> 00:14:14,000
create a snapshot for conditional range

301
00:14:14,000 --> 00:14:17,360
during process running from this

302
00:14:17,360 --> 00:14:20,000
we can increase the tainted friendship

303
00:14:20,000 --> 00:14:21,519
coverage

304
00:14:21,519 --> 00:14:24,000
as already mentioned we use dynamic

305
00:14:24,000 --> 00:14:26,000
taint analysis

306
00:14:26,000 --> 00:14:29,279
it has a disadvantage of tracking input

307
00:14:29,279 --> 00:14:32,639
on your own executed path

308
00:14:32,639 --> 00:14:36,240
so comparing to static analysis it has

309
00:14:36,240 --> 00:14:38,959
lower branch coverage

310
00:14:38,959 --> 00:14:42,240
this is limitation in generating as

311
00:14:42,240 --> 00:14:46,079
many inputs as possible

312
00:14:46,079 --> 00:14:48,880
but if we level this lecture it can

313
00:14:48,880 --> 00:14:50,160
continue striking

314
00:14:50,160 --> 00:14:54,639
tainted data by jumping on the path

315
00:14:54,639 --> 00:14:57,519
so with this knowledge we can achieve

316
00:14:57,519 --> 00:15:01,440
more comparison financial coverage

317
00:15:01,440 --> 00:15:04,000
for these regions we can select our

318
00:15:04,000 --> 00:15:06,639
operation

319
00:15:09,279 --> 00:15:12,000
okay now let's go over action mechanism

320
00:15:12,000 --> 00:15:14,639
for input generation

321
00:15:14,639 --> 00:15:17,199
as i said live frames use dynamic

322
00:15:17,199 --> 00:15:18,480
control flow graph

323
00:15:18,480 --> 00:15:22,399
constructor to create the same chart

324
00:15:22,399 --> 00:15:25,440
in generate control flow graph nodes

325
00:15:25,440 --> 00:15:28,480
representing code paths actually

326
00:15:28,480 --> 00:15:30,240
executed

327
00:15:30,240 --> 00:15:33,360
but we don't generate every executed

328
00:15:33,360 --> 00:15:34,959
flaw

329
00:15:34,959 --> 00:15:38,079
only conditional branches are treated

330
00:15:38,079 --> 00:15:41,440
as graph notice

331
00:15:41,440 --> 00:15:45,279
basically control flow graph represents

332
00:15:45,279 --> 00:15:49,120
all the executed wave blocks however

333
00:15:49,120 --> 00:15:51,279
our interesting point for input

334
00:15:51,279 --> 00:15:52,560
generation

335
00:15:52,560 --> 00:15:55,519
is page blog where conditional french

336
00:15:55,519 --> 00:15:57,759
exists

337
00:15:57,759 --> 00:16:00,800
so our control program only

338
00:16:00,800 --> 00:16:05,839
consists of a conditional branch

339
00:16:06,000 --> 00:16:09,920
and each node represents a selection

340
00:16:09,920 --> 00:16:14,079
so it has some essential information

341
00:16:14,079 --> 00:16:16,320
we restore selection by referencing

342
00:16:16,320 --> 00:16:17,519
these cfg

343
00:16:17,519 --> 00:16:21,600
nodes we'll explain the type of

344
00:16:21,600 --> 00:16:26,240
safety information in the next slide

345
00:16:26,320 --> 00:16:29,440
and the cfg constructor also made a

346
00:16:29,440 --> 00:16:32,480
essential scheduling like selections

347
00:16:32,480 --> 00:16:33,839
creation frequency

348
00:16:33,839 --> 00:16:37,920
and timing we implemented the

349
00:16:37,920 --> 00:16:40,360
shape of the constructor in

350
00:16:40,360 --> 00:16:43,040
instrumentation framework

351
00:16:43,040 --> 00:16:45,880
to deduce overhead or type final

352
00:16:45,880 --> 00:16:47,440
instrumentation

353
00:16:47,440 --> 00:16:51,279
like branches cuteness cfg's constructor

354
00:16:51,279 --> 00:16:54,959
after detecting user input

355
00:16:57,279 --> 00:17:00,399
so this is node container made by safety

356
00:17:00,399 --> 00:17:03,199
constructor

357
00:17:03,360 --> 00:17:05,839
actually each node container has a

358
00:17:05,839 --> 00:17:07,839
snapshot repository

359
00:17:07,839 --> 00:17:10,480
it saves the execution context and

360
00:17:10,480 --> 00:17:11,599
memory state of

361
00:17:11,599 --> 00:17:15,520
conditional branch and it saves

362
00:17:15,520 --> 00:17:18,640
10 information as well

363
00:17:18,640 --> 00:17:21,839
for preserving memory state we record

364
00:17:21,839 --> 00:17:24,400
the previous values of memory

365
00:17:24,400 --> 00:17:28,000
that have been modified during non-time

366
00:17:28,000 --> 00:17:30,240
memory snapshot will be covered in

367
00:17:30,240 --> 00:17:32,480
detail later

368
00:17:32,480 --> 00:17:35,520
attempt information is used when

369
00:17:35,520 --> 00:17:38,480
executing a different path after

370
00:17:38,480 --> 00:17:41,200
snapshot is restored

371
00:17:41,200 --> 00:17:44,000
this means that we can continue tracking

372
00:17:44,000 --> 00:17:45,679
tenth propagation

373
00:17:45,679 --> 00:17:50,000
for other paths these node containers

374
00:17:50,000 --> 00:17:52,240
are connected to each other

375
00:17:52,240 --> 00:17:55,919
using single linked list

376
00:17:59,280 --> 00:18:02,160
okay now let's look at snapshot creation

377
00:18:02,160 --> 00:18:03,760
flow

378
00:18:03,760 --> 00:18:06,400
first we instrument header instruction

379
00:18:06,400 --> 00:18:08,080
of conditional branch

380
00:18:08,080 --> 00:18:11,760
without callback function and then

381
00:18:11,760 --> 00:18:14,799
if a config is called it saves runtime

382
00:18:14,799 --> 00:18:16,880
state or conditional branch

383
00:18:16,880 --> 00:18:20,480
in download container node container can

384
00:18:20,480 --> 00:18:21,679
be divided

385
00:18:21,679 --> 00:18:25,120
into two types if a conditional branch

386
00:18:25,120 --> 00:18:26,799
is which case

387
00:18:26,799 --> 00:18:30,000
is switch branch node and

388
00:18:30,000 --> 00:18:34,160
other cases normal branch node

389
00:18:34,559 --> 00:18:37,760
why we divide into two types

390
00:18:37,760 --> 00:18:40,840
because these assembly code patterns are

391
00:18:40,840 --> 00:18:42,880
different

392
00:18:42,880 --> 00:18:45,840
so we need to analyze nodules with two

393
00:18:45,840 --> 00:18:48,320
ways

394
00:18:48,320 --> 00:18:51,520
finally if all the snapshots of the

395
00:18:51,520 --> 00:18:54,720
executed path is completed

396
00:18:54,720 --> 00:18:57,600
it starts restoring structure on the

397
00:18:57,600 --> 00:19:00,400
predefined conditions

398
00:19:00,400 --> 00:19:03,520
we do this again and again until all

399
00:19:03,520 --> 00:19:04,320
structures

400
00:19:04,320 --> 00:19:07,520
have been installed

401
00:19:09,360 --> 00:19:12,640
so when we destroy snapchats

402
00:19:12,640 --> 00:19:15,919
here are some conditions for that

403
00:19:15,919 --> 00:19:18,720
if these conditions take place in target

404
00:19:18,720 --> 00:19:20,080
finally

405
00:19:20,080 --> 00:19:24,240
we immediately distort snapchat

406
00:19:24,240 --> 00:19:27,360
the key idea for digital structure is to

407
00:19:27,360 --> 00:19:28,240
detect leap

408
00:19:28,240 --> 00:19:32,160
node neep node is the node

409
00:19:32,160 --> 00:19:35,200
that doesn't have a child node in a

410
00:19:35,200 --> 00:19:37,280
binary tree

411
00:19:37,280 --> 00:19:40,160
with this idea we implemented the leap

412
00:19:40,160 --> 00:19:42,240
node detection algorithm

413
00:19:42,240 --> 00:19:46,000
to identify the store point

414
00:19:46,000 --> 00:19:48,640
if program is no longer executing for

415
00:19:48,640 --> 00:19:50,080
some reason

416
00:19:50,080 --> 00:19:53,360
we regard this last node in the rip

417
00:19:53,360 --> 00:19:57,120
load so we restore snapshot

418
00:19:57,120 --> 00:20:00,880
if we say at the end of main or reset

419
00:20:00,880 --> 00:20:04,640
the call to exit function or we catch

420
00:20:04,640 --> 00:20:07,679
some process exception

421
00:20:07,679 --> 00:20:10,240
also we need to check invalid

422
00:20:10,240 --> 00:20:11,600
instructions

423
00:20:11,600 --> 00:20:14,240
because we pause control pro to

424
00:20:14,240 --> 00:20:14,880
different

425
00:20:14,880 --> 00:20:18,159
node we continue

426
00:20:18,159 --> 00:20:21,200
taking a snapshot until we met this kind

427
00:20:21,200 --> 00:20:24,159
of start point

428
00:20:26,480 --> 00:20:28,960
and the restore location is the header

429
00:20:28,960 --> 00:20:30,159
address of

430
00:20:30,159 --> 00:20:34,080
conditional branches page block

431
00:20:34,080 --> 00:20:37,200
reasoning least essential at the head

432
00:20:37,200 --> 00:20:40,480
is the branch analysis module utilize

433
00:20:40,480 --> 00:20:43,679
the page problem level tracing

434
00:20:43,679 --> 00:20:47,600
as you can see this slide the page block

435
00:20:47,600 --> 00:20:48,080
which

436
00:20:48,080 --> 00:20:51,679
has the exit core is the deep node

437
00:20:51,679 --> 00:20:54,799
so if the problem is secured to the node

438
00:20:54,799 --> 00:20:58,720
it tried to distort snapshot

439
00:20:58,880 --> 00:21:02,240
and then censored is completed we jump

440
00:21:02,240 --> 00:21:05,200
head over conditional branch to get net

441
00:21:05,200 --> 00:21:06,159
to enter

442
00:21:06,159 --> 00:21:09,039
a project path

443
00:21:10,880 --> 00:21:14,159
next selection rules

444
00:21:14,159 --> 00:21:16,880
for improving input generation we

445
00:21:16,880 --> 00:21:17,520
applied

446
00:21:17,520 --> 00:21:20,880
some selection rules to right french

447
00:21:20,880 --> 00:21:24,159
first there are two default rules

448
00:21:24,159 --> 00:21:26,400
it doesn't take a snapshot for first

449
00:21:26,400 --> 00:21:27,600
page flaw

450
00:21:27,600 --> 00:21:30,640
right after the story

451
00:21:30,640 --> 00:21:33,679
because we have already extracted it

452
00:21:33,679 --> 00:21:36,799
on comparison branch

453
00:21:36,799 --> 00:21:39,520
and another one is the reston node is

454
00:21:39,520 --> 00:21:40,799
deleted from the

455
00:21:40,799 --> 00:21:44,559
node list second we have

456
00:21:44,559 --> 00:21:48,080
two optional rules first one we are able

457
00:21:48,080 --> 00:21:49,039
to set

458
00:21:49,039 --> 00:21:52,720
depths of the deepest node level

459
00:21:52,720 --> 00:21:55,760
to implement this functionality we

460
00:21:55,760 --> 00:21:58,799
assign unique id to each node whenever

461
00:21:58,799 --> 00:22:03,039
creating snapshot and this unique

462
00:22:03,039 --> 00:22:05,760
id is determined by referring to the

463
00:22:05,760 --> 00:22:08,640
previous node id

464
00:22:08,640 --> 00:22:11,840
and depth of node is number of nodes on

465
00:22:11,840 --> 00:22:12,720
the path

466
00:22:12,720 --> 00:22:15,840
from node to reef

467
00:22:15,840 --> 00:22:18,880
if we enable this option snapshots are

468
00:22:18,880 --> 00:22:19,760
saved

469
00:22:19,760 --> 00:22:22,880
only up to the depth level entered by

470
00:22:22,880 --> 00:22:24,720
user

471
00:22:24,720 --> 00:22:27,440
this means that in this two section if

472
00:22:27,440 --> 00:22:28,559
node level

473
00:22:28,559 --> 00:22:31,760
reaches maximum depth

474
00:22:31,760 --> 00:22:33,679
as i said at the beginning of the

475
00:22:33,679 --> 00:22:35,120
presentation

476
00:22:35,120 --> 00:22:38,640
program tends to compare input at the

477
00:22:38,640 --> 00:22:41,840
front end of problem so

478
00:22:41,840 --> 00:22:45,440
in this case we can adjust the deepest

479
00:22:45,440 --> 00:22:46,880
node level

480
00:22:46,880 --> 00:22:49,520
so that can quickly analyze the front

481
00:22:49,520 --> 00:22:51,919
end of the program

482
00:22:51,919 --> 00:22:54,880
this means that lifebranch can select

483
00:22:54,880 --> 00:22:55,919
the

484
00:22:55,919 --> 00:22:59,280
analysis range of companies branch

485
00:22:59,280 --> 00:23:03,520
as it is option another option is to

486
00:23:03,520 --> 00:23:04,559
configure

487
00:23:04,559 --> 00:23:07,760
redundant snapshot mode even developer

488
00:23:07,760 --> 00:23:08,640
selection mode

489
00:23:08,640 --> 00:23:11,679
is to allow to save the selection of

490
00:23:11,679 --> 00:23:15,280
already security the branch for that

491
00:23:15,280 --> 00:23:18,159
like branches could check and save

492
00:23:18,159 --> 00:23:18,799
whether

493
00:23:18,799 --> 00:23:21,039
same conditional branch has been

494
00:23:21,039 --> 00:23:23,280
executed

495
00:23:23,280 --> 00:23:27,039
basically there is no need to analyze

496
00:23:27,039 --> 00:23:30,480
its comparison branch again after is

497
00:23:30,480 --> 00:23:34,480
extracting input so we thought that

498
00:23:34,480 --> 00:23:37,600
we don't need to save a snapshot of same

499
00:23:37,600 --> 00:23:39,600
branch

500
00:23:39,600 --> 00:23:42,960
however after several tests

501
00:23:42,960 --> 00:23:46,320
we figure out a case whether redundant

502
00:23:46,320 --> 00:23:47,039
snapshot

503
00:23:47,039 --> 00:23:50,080
was needed

504
00:23:50,080 --> 00:23:53,039
one of these cases is that it compare

505
00:23:53,039 --> 00:23:54,559
different values

506
00:23:54,559 --> 00:23:57,600
in same conditional branch such as

507
00:23:57,600 --> 00:24:01,600
rupee iteration in this case

508
00:24:01,600 --> 00:24:04,640
if we disable relevant structure we

509
00:24:04,640 --> 00:24:06,559
couldn't extract the input

510
00:24:06,559 --> 00:24:09,760
as many as possible

511
00:24:09,760 --> 00:24:12,320
so for deep scan we need to set this

512
00:24:12,320 --> 00:24:13,679
option

513
00:24:13,679 --> 00:24:15,919
even though the threshold operation

514
00:24:15,919 --> 00:24:18,159
affects the performance of input

515
00:24:18,159 --> 00:24:20,799
generation

516
00:24:23,200 --> 00:24:25,760
of course live branch support memory

517
00:24:25,760 --> 00:24:28,320
selection

518
00:24:28,559 --> 00:24:30,960
this is all necessary functions to

519
00:24:30,960 --> 00:24:33,039
restore the execution state

520
00:24:33,039 --> 00:24:36,720
over binary for this we post the

521
00:24:36,720 --> 00:24:38,720
instrument to all the memory writing

522
00:24:38,720 --> 00:24:39,919
instructions

523
00:24:39,919 --> 00:24:42,960
on trace level and then

524
00:24:42,960 --> 00:24:46,000
in preserve original value memory in

525
00:24:46,000 --> 00:24:47,840
their node container

526
00:24:47,840 --> 00:24:49,840
whenever hitting memory writing

527
00:24:49,840 --> 00:24:52,240
instructions

528
00:24:52,240 --> 00:24:54,720
memory structure starts from each

529
00:24:54,720 --> 00:24:56,159
conditional branch

530
00:24:56,159 --> 00:24:59,279
to right people being restored and then

531
00:24:59,279 --> 00:25:02,159
we overwrite these preserved values back

532
00:25:02,159 --> 00:25:03,600
to the legends

533
00:25:03,600 --> 00:25:06,799
when restoring snapchat if we're very

534
00:25:06,799 --> 00:25:08,799
written to the same address multiple

535
00:25:08,799 --> 00:25:09,919
times

536
00:25:09,919 --> 00:25:12,960
we record only first original value in

537
00:25:12,960 --> 00:25:15,840
same node

538
00:25:16,960 --> 00:25:19,679
next how we travel snatcher 3 for this

539
00:25:19,679 --> 00:25:21,520
store

540
00:25:21,520 --> 00:25:24,320
as you can see there are two strategies

541
00:25:24,320 --> 00:25:24,720
of

542
00:25:24,720 --> 00:25:27,919
three tributaries for restoring these

543
00:25:27,919 --> 00:25:29,600
control flow graphs

544
00:25:29,600 --> 00:25:31,919
represents possible transition of

545
00:25:31,919 --> 00:25:33,279
conditional branch

546
00:25:33,279 --> 00:25:36,320
inside binary and each node

547
00:25:36,320 --> 00:25:39,440
represents 3 bases structure connected

548
00:25:39,440 --> 00:25:39,760
by

549
00:25:39,760 --> 00:25:43,840
edges case one bottom only store

550
00:25:43,840 --> 00:25:47,520
strategy and case two is top down

551
00:25:47,520 --> 00:25:50,559
mr strategy

552
00:25:50,559 --> 00:25:53,840
so what's the bottom of this store but

553
00:25:53,840 --> 00:25:56,720
only store is that it travels three

554
00:25:56,720 --> 00:25:59,760
bubbles to the top node

555
00:25:59,760 --> 00:26:02,640
you can see that soccer and green circle

556
00:26:02,640 --> 00:26:05,279
in these binary trees

557
00:26:05,279 --> 00:26:08,000
red circle represents the conditional

558
00:26:08,000 --> 00:26:09,200
branches

559
00:26:09,200 --> 00:26:12,480
executed in the first round

560
00:26:12,480 --> 00:26:14,720
and green circle represents the

561
00:26:14,720 --> 00:26:16,159
condition branch

562
00:26:16,159 --> 00:26:20,159
that is queued as soon as we restore

563
00:26:20,159 --> 00:26:23,279
like this in battle restore case

564
00:26:23,279 --> 00:26:26,640
the restore location is soccer pool

565
00:26:26,640 --> 00:26:29,120
and then second round started as soccer

566
00:26:29,120 --> 00:26:30,720
5.

567
00:26:30,720 --> 00:26:33,520
on the other hand top down history is

568
00:26:33,520 --> 00:26:38,000
that in moves down on level from the top

569
00:26:38,000 --> 00:26:40,720
this is also known as level order binary

570
00:26:40,720 --> 00:26:43,039
tree tree version

571
00:26:43,039 --> 00:26:46,400
in top down case those list location is

572
00:26:46,400 --> 00:26:47,600
circle one

573
00:26:47,600 --> 00:26:50,720
and then second round starts as

574
00:26:50,720 --> 00:26:55,039
circle 5 we tested both case against

575
00:26:55,039 --> 00:26:58,080
the old binary when implementing knight

576
00:26:58,080 --> 00:26:59,200
branch

577
00:26:59,200 --> 00:27:02,080
as a result i performed this top down

578
00:27:02,080 --> 00:27:04,559
restore strategy

579
00:27:04,559 --> 00:27:07,600
because there are more comparison branch

580
00:27:07,600 --> 00:27:11,440
at the beginning of program so it's more

581
00:27:11,440 --> 00:27:15,039
effective solution than others

582
00:27:15,039 --> 00:27:18,880
our earlier tool used but only store

583
00:27:18,880 --> 00:27:21,840
but for these regions we had to change

584
00:27:21,840 --> 00:27:24,959
our strategy

585
00:27:25,600 --> 00:27:28,720
now control flow hijacking it's actually

586
00:27:28,720 --> 00:27:30,159
pretty simple

587
00:27:30,159 --> 00:27:32,960
after listo section the first thing we

588
00:27:32,960 --> 00:27:33,440
do

589
00:27:33,440 --> 00:27:36,799
we post jump direction to another path

590
00:27:36,799 --> 00:27:39,600
in order to hijack control flow we check

591
00:27:39,600 --> 00:27:41,440
a flag status of

592
00:27:41,440 --> 00:27:44,880
conditional jump instruction and then

593
00:27:44,880 --> 00:27:47,440
in boost in the local detection by

594
00:27:47,440 --> 00:27:50,320
referring to the jump beat

595
00:27:50,320 --> 00:27:53,600
for example if the jump bit is true

596
00:27:53,600 --> 00:27:56,399
we set instruction point to the next

597
00:27:56,399 --> 00:27:57,279
address so we

598
00:27:57,279 --> 00:28:00,559
jump instruction on the other hand

599
00:28:00,559 --> 00:28:03,520
if jump a bit to its first we would want

600
00:28:03,520 --> 00:28:04,799
to jump to target

601
00:28:04,799 --> 00:28:09,360
address since we pause the execution of

602
00:28:09,360 --> 00:28:10,559
other paths

603
00:28:10,559 --> 00:28:12,880
sensitive paths could be generated

604
00:28:12,880 --> 00:28:15,760
memory access errors

605
00:28:15,760 --> 00:28:17,840
so in order to avoid this kind of

606
00:28:17,840 --> 00:28:19,120
behaviors

607
00:28:19,120 --> 00:28:22,720
we check validation of instructions

608
00:28:22,720 --> 00:28:25,520
first validation of lead white memory

609
00:28:25,520 --> 00:28:27,279
access

610
00:28:27,279 --> 00:28:29,919
to check invalid memory access we

611
00:28:29,919 --> 00:28:31,760
collect the currently mapped memory

612
00:28:31,760 --> 00:28:32,640
division

613
00:28:32,640 --> 00:28:36,799
and access permissions from mass prime

614
00:28:36,799 --> 00:28:39,760
we update this information before every

615
00:28:39,760 --> 00:28:40,720
check

616
00:28:40,720 --> 00:28:44,720
because of dynamic memory allocation

617
00:28:44,720 --> 00:28:48,559
and validation of indirect core address

618
00:28:48,559 --> 00:28:50,960
basically indirect call takes the

619
00:28:50,960 --> 00:28:52,159
address

620
00:28:52,159 --> 00:28:55,440
from memory or register

621
00:28:55,440 --> 00:28:57,840
so we check if it is in our code

622
00:28:57,840 --> 00:28:59,279
sections

623
00:28:59,279 --> 00:29:02,880
and validation of null point access

624
00:29:02,880 --> 00:29:05,600
it just checks if memory address is

625
00:29:05,600 --> 00:29:07,360
known

626
00:29:07,360 --> 00:29:09,760
and last validation will be invalid

627
00:29:09,760 --> 00:29:11,440
fully

628
00:29:11,440 --> 00:29:13,600
for this we create the corporate for him

629
00:29:13,600 --> 00:29:14,799
memorial location

630
00:29:14,799 --> 00:29:18,320
and pre-function using dvi

631
00:29:18,320 --> 00:29:20,640
if a callback is called we insert the

632
00:29:20,640 --> 00:29:22,399
location and free address

633
00:29:22,399 --> 00:29:25,760
in the list so we can check whether our

634
00:29:25,760 --> 00:29:26,559
argument of

635
00:29:26,559 --> 00:29:30,559
free function exists in the destiny

636
00:29:30,559 --> 00:29:35,279
also check double free with fully count

637
00:29:35,440 --> 00:29:37,679
when we detect this kind of memory

638
00:29:37,679 --> 00:29:38,960
access errors

639
00:29:38,960 --> 00:29:41,200
release to snapshot to find the

640
00:29:41,200 --> 00:29:44,159
different paths

641
00:29:45,520 --> 00:29:49,440
now snapchat for republic basically

642
00:29:49,440 --> 00:29:52,840
most of software have loop iteration

643
00:29:52,840 --> 00:29:54,080
code

644
00:29:54,080 --> 00:29:57,440
and it's an open case that info values

645
00:29:57,440 --> 00:29:57,919
are

646
00:29:57,919 --> 00:30:01,200
compared inside the loop statement

647
00:30:01,200 --> 00:30:04,159
so we investigated some real world

648
00:30:04,159 --> 00:30:05,360
finally

649
00:30:05,360 --> 00:30:07,679
and tried to figure out specific

650
00:30:07,679 --> 00:30:10,320
disassembly pattern of loop body

651
00:30:10,320 --> 00:30:14,080
when comparing input from this study

652
00:30:14,080 --> 00:30:16,799
we found that it's used to compare white

653
00:30:16,799 --> 00:30:17,760
by byte

654
00:30:17,760 --> 00:30:21,279
or multiple values live branch detect

655
00:30:21,279 --> 00:30:22,000
loop

656
00:30:22,000 --> 00:30:25,039
while monitoring jump address if

657
00:30:25,039 --> 00:30:29,279
jump address is verbal jump it's roof

658
00:30:29,279 --> 00:30:31,679
and also check if the jump address is

659
00:30:31,679 --> 00:30:32,799
greater than

660
00:30:32,799 --> 00:30:36,480
function star tolerance once

661
00:30:36,480 --> 00:30:38,960
we have extracted all the input values

662
00:30:38,960 --> 00:30:40,799
in the loop body

663
00:30:40,799 --> 00:30:42,960
we don't need to analyze the loop

664
00:30:42,960 --> 00:30:44,799
anymore

665
00:30:44,799 --> 00:30:46,720
so in order to avoid unnecessary

666
00:30:46,720 --> 00:30:49,760
analysis inside the loop

667
00:30:49,760 --> 00:30:53,279
branch provides specialty option

668
00:30:53,279 --> 00:30:56,799
it's root iteration threshold

669
00:30:56,799 --> 00:30:59,120
for this it counts the number of

670
00:30:59,120 --> 00:31:00,399
execution times

671
00:31:00,399 --> 00:31:03,440
of backward jump

672
00:31:03,440 --> 00:31:07,360
if max loop iteration reset is reached

673
00:31:07,360 --> 00:31:09,919
we no longer save the snapshot and

674
00:31:09,919 --> 00:31:11,200
restore it to

675
00:31:11,200 --> 00:31:14,080
escape loop

676
00:31:16,080 --> 00:31:19,279
so what is comparison branch comparison

677
00:31:19,279 --> 00:31:20,799
branches compare with

678
00:31:20,799 --> 00:31:24,880
two operands and then jump somewhere

679
00:31:24,880 --> 00:31:27,519
examples of comparison branches are

680
00:31:27,519 --> 00:31:28,320
equals

681
00:31:28,320 --> 00:31:31,679
and switch case statements to better

682
00:31:31,679 --> 00:31:32,399
understand

683
00:31:32,399 --> 00:31:35,279
the structure of companies branch we

684
00:31:35,279 --> 00:31:37,600
analyzed the disassembly code

685
00:31:37,600 --> 00:31:40,320
of conditional branches in the world

686
00:31:40,320 --> 00:31:42,000
binaries

687
00:31:42,000 --> 00:31:44,000
from this we figured out several

688
00:31:44,000 --> 00:31:45,039
patterns

689
00:31:45,039 --> 00:31:47,760
first as i said info validation takes

690
00:31:47,760 --> 00:31:48,640
place more

691
00:31:48,640 --> 00:31:50,559
in the early stage of learning the

692
00:31:50,559 --> 00:31:52,799
program

693
00:31:52,799 --> 00:31:55,600
this phenomenon is more pronounced when

694
00:31:55,600 --> 00:31:56,799
the input value

695
00:31:56,799 --> 00:32:00,480
is used as a command line parameter

696
00:32:00,480 --> 00:32:02,159
because command line parameter

697
00:32:02,159 --> 00:32:03,679
determines the program

698
00:32:03,679 --> 00:32:07,840
execution path this helps us choose

699
00:32:07,840 --> 00:32:10,880
which nodes of the cfd we are interested

700
00:32:10,880 --> 00:32:12,320
in first

701
00:32:12,320 --> 00:32:16,720
when analyzing competitive branches

702
00:32:16,720 --> 00:32:20,640
second there are some common use cases

703
00:32:20,640 --> 00:32:23,279
the single branch compares one or

704
00:32:23,279 --> 00:32:25,840
several predefined values using

705
00:32:25,840 --> 00:32:29,919
one statement and the tested branch

706
00:32:29,919 --> 00:32:33,279
statement open appears when in need to

707
00:32:33,279 --> 00:32:35,039
compare multiple input

708
00:32:35,039 --> 00:32:39,760
such as an interactive application

709
00:32:39,760 --> 00:32:42,480
it's also useful when there are multiple

710
00:32:42,480 --> 00:32:43,440
comparison

711
00:32:43,440 --> 00:32:46,480
targets for single input

712
00:32:46,480 --> 00:32:49,120
and loop iteration is often used when

713
00:32:49,120 --> 00:32:49,919
comparing

714
00:32:49,919 --> 00:32:53,840
string with white to bind

715
00:32:55,760 --> 00:32:58,640
in our point of view we can divide the

716
00:32:58,640 --> 00:33:00,000
comparison branches

717
00:33:00,000 --> 00:33:03,840
into two types taiwan is input

718
00:33:03,840 --> 00:33:06,000
dependency branch

719
00:33:06,000 --> 00:33:08,840
and type 2 is non-input comparison

720
00:33:08,840 --> 00:33:10,240
branch

721
00:33:10,240 --> 00:33:13,200
what we are interested in is the input

722
00:33:13,200 --> 00:33:15,919
dependency branch

723
00:33:15,919 --> 00:33:18,880
because it has a comparison value which

724
00:33:18,880 --> 00:33:19,440
we

725
00:33:19,440 --> 00:33:23,679
need to extract so we discard non-input

726
00:33:23,679 --> 00:33:26,159
comparison branch

727
00:33:26,159 --> 00:33:28,159
for identifying input dependency

728
00:33:28,159 --> 00:33:30,480
branching we use dynamic tangent

729
00:33:30,480 --> 00:33:32,480
analysis

730
00:33:32,480 --> 00:33:35,039
our initial seed impulse is mendel's

731
00:33:35,039 --> 00:33:37,360
team for taint

732
00:33:37,360 --> 00:33:39,519
there can be one input or multiple

733
00:33:39,519 --> 00:33:42,240
inputs in the program

734
00:33:42,240 --> 00:33:44,320
since the right branch doesn't know how

735
00:33:44,320 --> 00:33:45,440
many inputs

736
00:33:45,440 --> 00:33:48,399
target actually needs we could execute

737
00:33:48,399 --> 00:33:51,760
the target with several random inputs

738
00:33:51,760 --> 00:33:54,799
this is because unused inputs are

739
00:33:54,799 --> 00:33:55,840
automatically

740
00:33:55,840 --> 00:34:00,159
discarded and our gta module

741
00:34:00,159 --> 00:34:02,720
supports function level 10 as well as

742
00:34:02,720 --> 00:34:05,679
byte level 10

743
00:34:05,679 --> 00:34:08,480
some library functions such as data copy

744
00:34:08,480 --> 00:34:09,520
function

745
00:34:09,520 --> 00:34:13,040
for example when copy contributes to the

746
00:34:13,040 --> 00:34:13,520
retained

747
00:34:13,520 --> 00:34:16,800
propagation so we implemented

748
00:34:16,800 --> 00:34:20,560
this function and to improve the code

749
00:34:20,560 --> 00:34:21,520
coverage

750
00:34:21,520 --> 00:34:24,639
we can also take a u data analysis

751
00:34:24,639 --> 00:34:27,839
using the input values extracted

752
00:34:27,839 --> 00:34:35,839
through the control statement analysis

753
00:34:36,079 --> 00:34:38,480
after identifying input dependency

754
00:34:38,480 --> 00:34:40,639
branching we mark the tainted

755
00:34:40,639 --> 00:34:44,320
node in snapshot 3 like this

756
00:34:44,320 --> 00:34:46,839
this is helpful for french analysis

757
00:34:46,839 --> 00:34:49,839
model

758
00:34:50,079 --> 00:34:54,480
ok finally comparison value extraction

759
00:34:54,480 --> 00:34:58,400
actually we generate input at this stage

760
00:34:58,400 --> 00:35:00,839
this is pretty simple than selection

761
00:35:00,839 --> 00:35:02,240
mechanism

762
00:35:02,240 --> 00:35:04,800
our branch analysis module instrument

763
00:35:04,800 --> 00:35:05,440
compare

764
00:35:05,440 --> 00:35:08,960
instructions and functions

765
00:35:08,960 --> 00:35:10,960
you can see there are three types of

766
00:35:10,960 --> 00:35:12,160
comparison code

767
00:35:12,160 --> 00:35:15,200
we need to analyze

768
00:35:15,200 --> 00:35:17,440
and these are commonly used inside the

769
00:35:17,440 --> 00:35:19,599
binary

770
00:35:19,599 --> 00:35:22,160
at the cpu instruction set we instrument

771
00:35:22,160 --> 00:35:24,560
to compare instructions such as

772
00:35:24,560 --> 00:35:27,599
cmp and test

773
00:35:27,599 --> 00:35:30,079
since the cmp command various depending

774
00:35:30,079 --> 00:35:31,119
on the size of

775
00:35:31,119 --> 00:35:34,720
comparison we investigated all cmp

776
00:35:34,720 --> 00:35:35,440
commanders

777
00:35:35,440 --> 00:35:39,200
from intel architecture manual

778
00:35:39,200 --> 00:35:41,680
and sometimes the compiler optimizes

779
00:35:41,680 --> 00:35:42,480
code flow

780
00:35:42,480 --> 00:35:46,400
to rdp assembly family if rp assembly

781
00:35:46,400 --> 00:35:48,480
instruction is combined with

782
00:35:48,480 --> 00:35:51,760
cmp or scan string independent

783
00:35:51,760 --> 00:35:53,920
comparison the number of times

784
00:35:53,920 --> 00:35:57,760
specified in counter register

785
00:35:57,760 --> 00:36:00,000
so we also instrument to repeat the

786
00:36:00,000 --> 00:36:03,040
prefix instruction set

787
00:36:03,040 --> 00:36:05,839
and you know it can compare input with

788
00:36:05,839 --> 00:36:07,359
the function

789
00:36:07,359 --> 00:36:09,839
so at the function network we instrument

790
00:36:09,839 --> 00:36:13,119
the standard comparing library functions

791
00:36:13,119 --> 00:36:15,680
in this case cmp instruction is used to

792
00:36:15,680 --> 00:36:16,640
compare

793
00:36:16,640 --> 00:36:19,680
the detail of this function so we have

794
00:36:19,680 --> 00:36:20,240
to check

795
00:36:20,240 --> 00:36:24,000
functions argument not cmp operand

796
00:36:24,000 --> 00:36:27,839
when clearing painting information

797
00:36:29,520 --> 00:36:31,599
if instrumentation callback with the

798
00:36:31,599 --> 00:36:33,760
restore is called

799
00:36:33,760 --> 00:36:36,560
it tries to extract values through this

800
00:36:36,560 --> 00:36:38,720
flow

801
00:36:38,720 --> 00:36:41,839
first we need to identify location

802
00:36:41,839 --> 00:36:45,359
which actually has comparison value

803
00:36:45,359 --> 00:36:49,040
basically comparison branch use cmp or

804
00:36:49,040 --> 00:36:49,839
test

805
00:36:49,839 --> 00:36:53,440
assembly instruction to compare input

806
00:36:53,440 --> 00:36:57,040
however as i already mentioned two cases

807
00:36:57,040 --> 00:36:59,920
at the previous slide it might be

808
00:36:59,920 --> 00:37:00,560
somewhere

809
00:37:00,560 --> 00:37:03,760
other than cmp instruction

810
00:37:03,760 --> 00:37:06,480
all of these cases is that in youtube

811
00:37:06,480 --> 00:37:07,680
repeat

812
00:37:07,680 --> 00:37:11,680
instruction set or input validation

813
00:37:11,680 --> 00:37:14,240
another case is that input validation is

814
00:37:14,240 --> 00:37:17,440
performed at the function level

815
00:37:17,440 --> 00:37:20,079
so in this case we need to extract

816
00:37:20,079 --> 00:37:21,680
comparison value

817
00:37:21,680 --> 00:37:27,040
in other locations not of random cmp

818
00:37:27,040 --> 00:37:30,880
next we check which operands are tainted

819
00:37:30,880 --> 00:37:33,359
with this knowledge we can identify

820
00:37:33,359 --> 00:37:35,200
non-tainted operand

821
00:37:35,200 --> 00:37:39,040
which has comparison value and also we

822
00:37:39,040 --> 00:37:40,400
need to check

823
00:37:40,400 --> 00:37:44,079
operand type types are basically

824
00:37:44,079 --> 00:37:48,720
register memory and immediate value

825
00:37:48,720 --> 00:37:51,920
after identifying the type extract value

826
00:37:51,920 --> 00:37:52,160
of

827
00:37:52,160 --> 00:37:56,720
non-tainted operand according to time

828
00:37:56,720 --> 00:38:00,480
in cfp case just get less than memory or

829
00:38:00,480 --> 00:38:01,200
immediate

830
00:38:01,200 --> 00:38:05,599
value and in rep prefix instruction

831
00:38:05,599 --> 00:38:09,040
case get string from memory as the size

832
00:38:09,040 --> 00:38:10,320
of the kind

833
00:38:10,320 --> 00:38:14,400
count register and in compare function

834
00:38:14,400 --> 00:38:15,200
case

835
00:38:15,200 --> 00:38:19,839
just get argument value

836
00:38:22,000 --> 00:38:23,760
knight branch mostly designed for

837
00:38:23,760 --> 00:38:26,079
extracting no value

838
00:38:26,079 --> 00:38:30,400
over target operand other values such as

839
00:38:30,400 --> 00:38:33,520
encryption or encoded data are not in

840
00:38:33,520 --> 00:38:36,160
scope for light branch

841
00:38:36,160 --> 00:38:38,400
because it compared with transformed

842
00:38:38,400 --> 00:38:39,200
input

843
00:38:39,200 --> 00:38:41,200
so we don't know its original value

844
00:38:41,200 --> 00:38:43,599
without code analysis

845
00:38:43,599 --> 00:38:46,560
we tried to restore the original value

846
00:38:46,560 --> 00:38:48,960
by analyzing the type of transformed

847
00:38:48,960 --> 00:38:52,480
input it turns out that it is very

848
00:38:52,480 --> 00:38:53,680
difficult

849
00:38:53,680 --> 00:38:56,960
automatically analyze encoded or is

850
00:38:56,960 --> 00:39:01,040
encrypted data without original value

851
00:39:01,040 --> 00:39:03,440
so it was very serious challenging for

852
00:39:03,440 --> 00:39:05,520
right branch

853
00:39:05,520 --> 00:39:08,480
even if we analyzed it there is a lot of

854
00:39:08,480 --> 00:39:11,040
performance overhead

855
00:39:11,040 --> 00:39:14,400
and also after writing several binaries

856
00:39:14,400 --> 00:39:17,440
we found that open ssl handles user

857
00:39:17,440 --> 00:39:18,880
input

858
00:39:18,880 --> 00:39:22,560
without comparison as you can see

859
00:39:22,560 --> 00:39:25,200
in the live screenshot this source code

860
00:39:25,200 --> 00:39:25,920
is

861
00:39:25,920 --> 00:39:28,960
user input processing function over open

862
00:39:28,960 --> 00:39:30,880
csn

863
00:39:30,880 --> 00:39:33,760
the command used in open ssn is

864
00:39:33,760 --> 00:39:35,760
converted to h-value

865
00:39:35,760 --> 00:39:38,880
and saved when initializing

866
00:39:38,880 --> 00:39:41,920
any get point of digest model object

867
00:39:41,920 --> 00:39:44,720
only by user input

868
00:39:44,720 --> 00:39:47,200
and then with this analysis jump a

869
00:39:47,200 --> 00:39:48,800
function point

870
00:39:48,800 --> 00:39:52,320
of digest object so there is no

871
00:39:52,320 --> 00:39:53,680
compression value we

872
00:39:53,680 --> 00:39:56,880
strength also this means

873
00:39:56,880 --> 00:39:59,839
that we don't know input value to jump

874
00:39:59,839 --> 00:40:02,000
your fans

875
00:40:02,000 --> 00:40:04,400
to do this we need brute force input

876
00:40:04,400 --> 00:40:05,839
creation

877
00:40:05,839 --> 00:40:08,839
but this is not in scope for right

878
00:40:08,839 --> 00:40:11,839
branch

879
00:40:13,680 --> 00:40:16,160
okay now comparison of values from

880
00:40:16,160 --> 00:40:17,440
option

881
00:40:17,440 --> 00:40:20,240
binary often use indexing addressing to

882
00:40:20,240 --> 00:40:22,240
compare input

883
00:40:22,240 --> 00:40:24,560
in this case since the value separated

884
00:40:24,560 --> 00:40:27,680
by a specific offset from the base point

885
00:40:27,680 --> 00:40:30,640
is compared the offset information must

886
00:40:30,640 --> 00:40:31,760
be extracted

887
00:40:31,760 --> 00:40:35,680
to inform the product basically

888
00:40:35,680 --> 00:40:38,560
offset is determined by adding any

889
00:40:38,560 --> 00:40:41,599
combination of the three elements

890
00:40:41,599 --> 00:40:46,319
base displacement and index

891
00:40:46,319 --> 00:40:48,560
so we get these three elements of

892
00:40:48,560 --> 00:40:50,800
obtaining the operand

893
00:40:50,800 --> 00:40:54,800
and then adding before the cmp and test

894
00:40:54,800 --> 00:40:57,119
control command is executed

895
00:40:57,119 --> 00:41:00,079
the process of calculating the offset is

896
00:41:00,079 --> 00:41:02,000
preceded

897
00:41:02,000 --> 00:41:05,359
there are two types of offset in this

898
00:41:05,359 --> 00:41:08,160
indirect addressing the offset data is

899
00:41:08,160 --> 00:41:10,000
in all of the resistors

900
00:41:10,000 --> 00:41:14,160
that is specified by the instruction

901
00:41:14,160 --> 00:41:17,119
and in direct addressing mode the offset

902
00:41:17,119 --> 00:41:17,680
data

903
00:41:17,680 --> 00:41:21,680
is in immediate value offset type is

904
00:41:21,680 --> 00:41:25,279
determined at compile time

905
00:41:26,160 --> 00:41:30,160
so how we extract offset

906
00:41:30,160 --> 00:41:32,319
life branch uses bevel the tangent

907
00:41:32,319 --> 00:41:33,680
analysis from

908
00:41:33,680 --> 00:41:36,880
tainted branch from this

909
00:41:36,880 --> 00:41:40,560
it checks which operands are tainted

910
00:41:40,560 --> 00:41:42,640
because the offset of the comparison

911
00:41:42,640 --> 00:41:45,520
value is not important to us

912
00:41:45,520 --> 00:41:48,560
so we have together of cell or input

913
00:41:48,560 --> 00:41:51,599
with retained information

914
00:41:51,599 --> 00:41:53,920
and next we analyzing the index

915
00:41:53,920 --> 00:41:55,599
addressing models

916
00:41:55,599 --> 00:41:59,119
at the diy verity blocks

917
00:41:59,119 --> 00:42:01,520
and then extract offset value over

918
00:42:01,520 --> 00:42:04,640
tinted or current

919
00:42:08,560 --> 00:42:11,599
and byte sequencing white sequencing is

920
00:42:11,599 --> 00:42:12,640
necessary

921
00:42:12,640 --> 00:42:16,400
when comparing strings by byte

922
00:42:16,400 --> 00:42:18,960
in order to insert it to additionally we

923
00:42:18,960 --> 00:42:21,599
have to join it

924
00:42:21,599 --> 00:42:24,319
first we identify one white character in

925
00:42:24,319 --> 00:42:25,359
the output file

926
00:42:25,359 --> 00:42:28,720
like branch and then sorting ascending

927
00:42:28,720 --> 00:42:29,520
order with

928
00:42:29,520 --> 00:42:31,839
instructional addresses where the

929
00:42:31,839 --> 00:42:34,960
extract value exists

930
00:42:34,960 --> 00:42:37,520
and we check offset value to secondly

931
00:42:37,520 --> 00:42:40,079
join the white strings

932
00:42:40,079 --> 00:42:43,040
and represent a sequence of whites and

933
00:42:43,040 --> 00:42:46,079
save string to addiction required

934
00:42:46,079 --> 00:42:48,400
at that time you can see the result of

935
00:42:48,400 --> 00:42:49,200
training

936
00:42:49,200 --> 00:42:51,919
each bite

937
00:42:54,720 --> 00:42:57,680
this is architectural diagram of our

938
00:42:57,680 --> 00:42:58,720
generation-based

939
00:42:58,720 --> 00:43:01,599
project we know the target binary and

940
00:43:01,599 --> 00:43:01,920
then

941
00:43:01,920 --> 00:43:04,400
differential non-stone input and create

942
00:43:04,400 --> 00:43:07,200
prediction required be proposing

943
00:43:07,200 --> 00:43:13,280
and then putting in the extracted input

944
00:43:13,280 --> 00:43:15,760
okay now we would like to demonstrate

945
00:43:15,760 --> 00:43:19,119
and show a demo video

946
00:43:19,920 --> 00:43:22,319
in this demo i am gonna show you our

947
00:43:22,319 --> 00:43:23,520
live branch

948
00:43:23,520 --> 00:43:26,319
we have prepared the sample programs and

949
00:43:26,319 --> 00:43:28,800
the old binaries for demo

950
00:43:28,800 --> 00:43:32,079
so let's see in action

951
00:43:35,040 --> 00:43:37,680
first demo file is a simple c program

952
00:43:37,680 --> 00:43:38,240
that have

953
00:43:38,240 --> 00:43:41,680
three comparison plenties this is

954
00:43:41,680 --> 00:43:44,960
main function and here is the

955
00:43:44,960 --> 00:43:47,839
compare string main function has a

956
00:43:47,839 --> 00:43:48,480
single

957
00:43:48,480 --> 00:43:51,680
comparison currency in full roof

958
00:43:51,680 --> 00:43:54,160
and compare four white strings pipe to

959
00:43:54,160 --> 00:43:56,160
by byte

960
00:43:56,160 --> 00:43:58,960
center comparison branch is the improve

961
00:43:58,960 --> 00:44:01,119
function

962
00:44:01,119 --> 00:44:03,040
it compares thing with the standard

963
00:44:03,040 --> 00:44:04,800
library function

964
00:44:04,800 --> 00:44:07,280
and so the comparison parentheses is

965
00:44:07,280 --> 00:44:10,800
nasty branch like this

966
00:44:11,520 --> 00:44:13,599
all different types of comparison

967
00:44:13,599 --> 00:44:16,079
branches in this program

968
00:44:16,079 --> 00:44:23,839
so let's actually started

969
00:44:28,079 --> 00:44:31,119
to execute life plans we need to specify

970
00:44:31,119 --> 00:44:33,599
where the sample program is

971
00:44:33,599 --> 00:44:36,079
then you can execute right branch with

972
00:44:36,079 --> 00:44:38,880
some options

973
00:44:39,119 --> 00:44:41,040
this program takes the string as the

974
00:44:41,040 --> 00:44:42,800
input

975
00:44:42,800 --> 00:44:44,960
so we have to insert into value like

976
00:44:44,960 --> 00:44:47,200
this

977
00:44:48,400 --> 00:44:52,000
and this is output of live branching

978
00:44:52,000 --> 00:44:53,839
you can see that we are automatically

979
00:44:53,839 --> 00:44:56,960
creating three comparison values

980
00:44:56,960 --> 00:45:00,960
and this number is of the value

981
00:45:02,880 --> 00:45:06,000
since two strings has offset value

982
00:45:06,000 --> 00:45:08,880
we need to join the white by referencing

983
00:45:08,880 --> 00:45:10,319
offset

984
00:45:10,319 --> 00:45:14,560
as a result two strings is joined

985
00:45:14,560 --> 00:45:16,800
and then we created a result file in the

986
00:45:16,800 --> 00:45:19,839
same directory

987
00:45:22,160 --> 00:45:24,400
this file format is the dictionary

988
00:45:24,400 --> 00:45:25,280
format of

989
00:45:25,280 --> 00:45:28,319
american first row

990
00:45:29,359 --> 00:45:31,680
and second example is the previous one

991
00:45:31,680 --> 00:45:35,279
with the pure multiplication

992
00:45:37,680 --> 00:45:40,800
we only modified the offset value

993
00:45:40,800 --> 00:45:44,000
in nested branch

994
00:45:44,240 --> 00:45:47,839
let's take a look again

995
00:46:00,880 --> 00:46:03,680
unlike the previous result you print the

996
00:46:03,680 --> 00:46:05,280
http string

997
00:46:05,280 --> 00:46:08,800
separated by the offset

998
00:46:11,760 --> 00:46:14,240
and next we demonstrate to the old

999
00:46:14,240 --> 00:46:16,879
binaries

1000
00:46:18,400 --> 00:46:21,119
so the first is object dom which is

1001
00:46:21,119 --> 00:46:24,240
command line program

1002
00:46:27,200 --> 00:46:29,520
we don't knife plants with the object

1003
00:46:29,520 --> 00:46:43,839
don't binary

1004
00:46:54,319 --> 00:46:56,960
and now let's see save the dictionary

1005
00:46:56,960 --> 00:46:59,280
file

1006
00:47:01,839 --> 00:47:04,000
you can see the command line argument

1007
00:47:04,000 --> 00:47:05,119
value of object

1008
00:47:05,119 --> 00:47:08,960
dom is various comparison value

1009
00:47:08,960 --> 00:47:12,960
which is automatically expected

1010
00:47:13,599 --> 00:47:16,400
second file is naked activity which is

1011
00:47:16,400 --> 00:47:19,599
interactive program

1012
00:47:21,680 --> 00:47:25,839
i don't like french again with that kid

1013
00:47:41,119 --> 00:47:43,280
what we want to do here is firstly we

1014
00:47:43,280 --> 00:47:53,839
need to insert the input

1015
00:47:54,559 --> 00:47:57,839
let's see the result

1016
00:48:01,040 --> 00:48:03,040
there are options to use to buy netkit

1017
00:48:03,040 --> 00:48:04,559
ftp

1018
00:48:04,559 --> 00:48:06,559
we can use digital digital instrument

1019
00:48:06,559 --> 00:48:09,040
project video i have friends

1020
00:48:09,040 --> 00:48:12,240
that's very helpful

1021
00:48:13,440 --> 00:48:16,160
okay this is my end of talk thank you

1022
00:48:16,160 --> 00:48:17,920
for listening

1023
00:48:17,920 --> 00:48:20,240
if you have any question please join

1024
00:48:20,240 --> 00:48:32,078
discord server over hitbe

