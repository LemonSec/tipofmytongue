1
00:00:15,839 --> 00:00:17,199
hello

2
00:00:17,199 --> 00:00:20,240
welcome to utilizing law drivers in post

3
00:00:20,240 --> 00:00:23,279
exploitation tradecraft talk

4
00:00:23,279 --> 00:00:26,400
my name is walshakaya i work as a retime

5
00:00:26,400 --> 00:00:28,800
engineer at picosecurity

6
00:00:28,800 --> 00:00:31,840
you can find andy and me on tutor for

7
00:00:31,840 --> 00:00:35,040
any questions or just a chat

8
00:00:35,040 --> 00:00:37,840
let's see our agenda today we are going

9
00:00:37,840 --> 00:00:39,200
to take a look at

10
00:00:39,200 --> 00:00:41,600
some of the motivations and challenges

11
00:00:41,600 --> 00:00:43,520
of kernel mode attacks

12
00:00:43,520 --> 00:00:46,320
from the perspective of a red image we

13
00:00:46,320 --> 00:00:47,680
will analyze

14
00:00:47,680 --> 00:00:50,480
several capabilities of a driver which

15
00:00:50,480 --> 00:00:52,559
can be functional for red teamers

16
00:00:52,559 --> 00:00:56,000
in post-exploitation phase we will try

17
00:00:56,000 --> 00:00:57,280
to implement

18
00:00:57,280 --> 00:01:00,239
a couple of ttps with this driver we

19
00:01:00,239 --> 00:01:01,440
will also look at

20
00:01:01,440 --> 00:01:04,319
protected processes and ways of

21
00:01:04,319 --> 00:01:06,240
interacting with them

22
00:01:06,240 --> 00:01:08,640
we will create a simple metal printer

23
00:01:08,640 --> 00:01:09,760
loader

24
00:01:09,760 --> 00:01:12,720
which uses a protected process to evade

25
00:01:12,720 --> 00:01:14,640
defensive measures with the help of a

26
00:01:14,640 --> 00:01:15,759
driver

27
00:01:15,759 --> 00:01:19,360
and in the end i will introduce a tool

28
00:01:19,360 --> 00:01:21,280
that can be used to simulate the

29
00:01:21,280 --> 00:01:24,000
techniques in this talk

30
00:01:24,000 --> 00:01:27,040
let's begin

31
00:01:27,040 --> 00:01:29,520
current offensive security practices

32
00:01:29,520 --> 00:01:30,720
mainly focus on

33
00:01:30,720 --> 00:01:33,360
user mode threads when we think the

34
00:01:33,360 --> 00:01:34,079
variety

35
00:01:34,079 --> 00:01:37,119
and importance of user mode threats it

36
00:01:37,119 --> 00:01:39,280
seems unnatural

37
00:01:39,280 --> 00:01:41,439
defensive products are also aligned with

38
00:01:41,439 --> 00:01:42,399
this trend

39
00:01:42,399 --> 00:01:45,520
since it's usually harder to detect and

40
00:01:45,520 --> 00:01:48,880
prevent a kernel mod attack however

41
00:01:48,880 --> 00:01:51,520
threat actors continues to use kernel

42
00:01:51,520 --> 00:01:54,159
mode attacks for different purposes

43
00:01:54,159 --> 00:01:56,560
we can ask why an attacker prefers to

44
00:01:56,560 --> 00:01:58,799
use a technique

45
00:01:58,799 --> 00:02:01,439
including something like installing a

46
00:02:01,439 --> 00:02:02,640
driver

47
00:02:02,640 --> 00:02:06,240
well as we said evading defensive

48
00:02:06,240 --> 00:02:06,960
measures

49
00:02:06,960 --> 00:02:10,479
is one of the main reasons also

50
00:02:10,479 --> 00:02:12,959
executing code in the kernel gives an

51
00:02:12,959 --> 00:02:13,680
attacker

52
00:02:13,680 --> 00:02:17,040
to ability to bypass user mode controls

53
00:02:17,040 --> 00:02:20,239
like access control lists another

54
00:02:20,239 --> 00:02:23,360
reason could be manipulating operating

55
00:02:23,360 --> 00:02:24,080
system

56
00:02:24,080 --> 00:02:27,360
or av components in itself since these

57
00:02:27,360 --> 00:02:28,160
parts have

58
00:02:28,160 --> 00:02:32,640
general restrictions in user mode

59
00:02:34,879 --> 00:02:37,280
since we are talking motivations of

60
00:02:37,280 --> 00:02:38,800
using kernel mode

61
00:02:38,800 --> 00:02:40,239
let's see an important defensive

62
00:02:40,239 --> 00:02:42,800
mechanism frequently used to detect

63
00:02:42,800 --> 00:02:46,959
user mode attacks api hooking

64
00:02:46,959 --> 00:02:50,080
and its bypasses were well very well

65
00:02:50,080 --> 00:02:51,360
studied subjects

66
00:02:51,360 --> 00:02:54,640
in last years api hooking

67
00:02:54,640 --> 00:02:57,280
can simply be defined as changing

68
00:02:57,280 --> 00:02:58,000
behavior of

69
00:02:58,000 --> 00:03:00,840
api calls windows has a

70
00:03:00,840 --> 00:03:02,319
compartmentalized

71
00:03:02,319 --> 00:03:04,879
architecture which depends on lots of

72
00:03:04,879 --> 00:03:06,000
calls between

73
00:03:06,000 --> 00:03:09,840
separate layers so a hooking function

74
00:03:09,840 --> 00:03:12,400
would act as the men in the middle

75
00:03:12,400 --> 00:03:13,760
between layers

76
00:03:13,760 --> 00:03:16,959
like an api called from ntdl and

77
00:03:16,959 --> 00:03:19,360
it can read or change parameters of that

78
00:03:19,360 --> 00:03:21,120
hooked api call

79
00:03:21,120 --> 00:03:23,519
this technique is used by defensive

80
00:03:23,519 --> 00:03:24,400
products

81
00:03:24,400 --> 00:03:27,680
to monitor behavior of process and

82
00:03:27,680 --> 00:03:30,159
detect its malicious patterns for

83
00:03:30,159 --> 00:03:31,599
example

84
00:03:31,599 --> 00:03:34,400
currently attackers have several options

85
00:03:34,400 --> 00:03:34,799
for

86
00:03:34,799 --> 00:03:37,360
dealing with that one of them is

87
00:03:37,360 --> 00:03:38,400
unhooking

88
00:03:38,400 --> 00:03:42,159
by using a fresh copy of that library

89
00:03:42,159 --> 00:03:44,959
attackers also change api calls with

90
00:03:44,959 --> 00:03:47,040
their direct syscalls

91
00:03:47,040 --> 00:03:50,080
when compiling a tool in order to evade

92
00:03:50,080 --> 00:03:53,200
api hooking there are also

93
00:03:53,200 --> 00:03:55,360
lots of techniques depends on windows

94
00:03:55,360 --> 00:03:56,799
security flex

95
00:03:56,799 --> 00:03:59,280
which could be used by an attacker to

96
00:03:59,280 --> 00:03:59,840
defend

97
00:03:59,840 --> 00:04:03,200
its process against avs

98
00:04:03,200 --> 00:04:06,000
hooking engines

99
00:04:06,400 --> 00:04:09,599
so what prevents attackers just using

100
00:04:09,599 --> 00:04:10,480
kernel mode

101
00:04:10,480 --> 00:04:13,360
to execute malicious code and their

102
00:04:13,360 --> 00:04:14,080
target

103
00:04:14,080 --> 00:04:18,000
systems first of all it's difficult to

104
00:04:18,000 --> 00:04:20,000
create a stable rootkit

105
00:04:20,000 --> 00:04:23,600
because new os versions may have

106
00:04:23,600 --> 00:04:26,320
different undocumented objects and

107
00:04:26,320 --> 00:04:27,520
mechanisms

108
00:04:27,520 --> 00:04:30,560
which affect the spell stability of

109
00:04:30,560 --> 00:04:34,080
malicious driver secondly

110
00:04:34,080 --> 00:04:35,919
you need to have administrator

111
00:04:35,919 --> 00:04:38,400
privileges on the target system

112
00:04:38,400 --> 00:04:41,280
to deploy a driver and although you have

113
00:04:41,280 --> 00:04:41,600
it

114
00:04:41,600 --> 00:04:44,160
you still may choose not to deploy

115
00:04:44,160 --> 00:04:44,880
drivers

116
00:04:44,880 --> 00:04:47,199
since it can alert various monitoring

117
00:04:47,199 --> 00:04:48,720
tools

118
00:04:48,720 --> 00:04:51,759
lastly microsoft tries hard to defend

119
00:04:51,759 --> 00:04:54,800
kernel space against malicious codes

120
00:04:54,800 --> 00:04:55,199
with

121
00:04:55,199 --> 00:04:57,600
restrictions like driver signature

122
00:04:57,600 --> 00:04:58,320
enforcement

123
00:04:58,320 --> 00:05:01,280
and patch card

124
00:05:02,000 --> 00:05:04,639
driver signature enforcement is one of

125
00:05:04,639 --> 00:05:07,120
the restrictions

126
00:05:07,120 --> 00:05:10,560
for new developed drivers drivers has to

127
00:05:10,560 --> 00:05:11,199
be signed

128
00:05:11,199 --> 00:05:15,440
by microsoft itself this procedure

129
00:05:15,440 --> 00:05:19,199
requires an ev code signing certificate

130
00:05:19,199 --> 00:05:22,400
and it requires also a couple of other

131
00:05:22,400 --> 00:05:23,360
steps

132
00:05:23,360 --> 00:05:26,400
windows patch card is the feature

133
00:05:26,400 --> 00:05:28,479
that prevents the patching of the kernel

134
00:05:28,479 --> 00:05:31,520
code according to microsoft

135
00:05:31,520 --> 00:05:34,000
the quality cannot be measured on a

136
00:05:34,000 --> 00:05:36,400
dynamically patch code in kernel

137
00:05:36,400 --> 00:05:39,199
which affects the whole system actually

138
00:05:39,199 --> 00:05:40,320
this feature

139
00:05:40,320 --> 00:05:42,720
has affected both rootkits and antivirus

140
00:05:42,720 --> 00:05:43,840
applications

141
00:05:43,840 --> 00:05:46,880
uh operating in kernel level

142
00:05:46,880 --> 00:05:48,880
that's been said uh there are still

143
00:05:48,880 --> 00:05:50,720
bypasses for

144
00:05:50,720 --> 00:05:54,320
dse and patch card using vulnerable

145
00:05:54,320 --> 00:05:54,960
drivers

146
00:05:54,960 --> 00:05:57,360
which can provide kernel read write or

147
00:05:57,360 --> 00:05:59,280
code execution capabilities

148
00:05:59,280 --> 00:06:02,400
to bypass dsc is

149
00:06:02,400 --> 00:06:05,440
very studied subject you can find great

150
00:06:05,440 --> 00:06:07,360
research articles on this subject

151
00:06:07,360 --> 00:06:09,680
actually

152
00:06:09,840 --> 00:06:12,639
okay we can ask are there any other

153
00:06:12,639 --> 00:06:13,759
drivers that

154
00:06:13,759 --> 00:06:16,400
we can use for offensive purposes if

155
00:06:16,400 --> 00:06:17,440
there is

156
00:06:17,440 --> 00:06:19,919
we may not need to develop rootkits from

157
00:06:19,919 --> 00:06:20,639
scratch

158
00:06:20,639 --> 00:06:23,120
and we may not bother to bypass driver

159
00:06:23,120 --> 00:06:24,639
signature reinforcement or

160
00:06:24,639 --> 00:06:27,600
patch card which may cause blue screen

161
00:06:27,600 --> 00:06:29,680
on new windows versions

162
00:06:29,680 --> 00:06:32,160
while i'm looking for a driver like that

163
00:06:32,160 --> 00:06:32,960
i checked

164
00:06:32,960 --> 00:06:35,840
process echo which is one which is one

165
00:06:35,840 --> 00:06:37,039
of my favorite tools

166
00:06:37,039 --> 00:06:40,240
in windows i always thought about

167
00:06:40,240 --> 00:06:42,960
using it in terminal but i could not

168
00:06:42,960 --> 00:06:46,318
find a decent part of it

169
00:06:47,120 --> 00:06:49,919
to whom knows nothing about process

170
00:06:49,919 --> 00:06:50,560
hacker

171
00:06:50,560 --> 00:06:53,840
uh it's a windows monitoring tool with

172
00:06:53,840 --> 00:06:55,280
very nice pictures like

173
00:06:55,280 --> 00:06:58,080
reading memory of a selected process uh

174
00:06:58,080 --> 00:06:58,880
it can

175
00:06:58,880 --> 00:07:01,759
make your life easier when you try to

176
00:07:01,759 --> 00:07:03,199
reverse something or

177
00:07:03,199 --> 00:07:06,240
understand the behavior of a process in

178
00:07:06,240 --> 00:07:07,840
order to extract data

179
00:07:07,840 --> 00:07:10,720
from the system process sector deploys

180
00:07:10,720 --> 00:07:12,000
its own driver

181
00:07:12,000 --> 00:07:15,199
and uses it for interacting with other

182
00:07:15,199 --> 00:07:16,560
processes

183
00:07:16,560 --> 00:07:19,759
it has abilities like killing protected

184
00:07:19,759 --> 00:07:20,479
processes

185
00:07:20,479 --> 00:07:24,000
reading system handles which makes it a

186
00:07:24,000 --> 00:07:26,880
very powerful tool it has also been used

187
00:07:26,880 --> 00:07:27,360
by

188
00:07:27,360 --> 00:07:30,319
multiplayer families like dredex in a

189
00:07:30,319 --> 00:07:31,280
simpler way

190
00:07:31,280 --> 00:07:35,679
to kill av processes before

191
00:07:35,840 --> 00:07:38,800
so i began to read the source code of

192
00:07:38,800 --> 00:07:40,800
process acre to understand

193
00:07:40,800 --> 00:07:43,520
how it communicates with its driver

194
00:07:43,520 --> 00:07:44,000
process

195
00:07:44,000 --> 00:07:47,759
hacker uses iocta calls to execute some

196
00:07:47,759 --> 00:07:48,800
of its tasks

197
00:07:48,800 --> 00:07:52,160
using the driver ioctl or

198
00:07:52,160 --> 00:07:54,639
input output control calls are way of

199
00:07:54,639 --> 00:07:57,039
communicating with the device drivers

200
00:07:57,039 --> 00:08:00,479
from the user mode code a process can

201
00:08:00,479 --> 00:08:03,120
send iocts to a driver with control

202
00:08:03,120 --> 00:08:04,319
codes

203
00:08:04,319 --> 00:08:07,840
usually specific to that driver

204
00:08:07,840 --> 00:08:10,840
according to the control codes driver

205
00:08:10,840 --> 00:08:12,800
executes specific tasks

206
00:08:12,800 --> 00:08:15,039
and may return an information to the

207
00:08:15,039 --> 00:08:16,240
process

208
00:08:16,240 --> 00:08:19,360
windows gives an interface for iocts

209
00:08:19,360 --> 00:08:22,800
with device io control function which

210
00:08:22,800 --> 00:08:26,000
also uses anti-device bio control

211
00:08:26,000 --> 00:08:30,080
file function in ntdl

212
00:08:30,160 --> 00:08:33,519
here we can see the process hackers code

213
00:08:33,519 --> 00:08:34,559
which sends an

214
00:08:34,559 --> 00:08:38,159
iotl to its driver functions

215
00:08:38,159 --> 00:08:41,440
starting with kph in the source code are

216
00:08:41,440 --> 00:08:45,600
wrappers for sending ioctl to driver

217
00:08:45,600 --> 00:08:48,800
with specific codes we can see this

218
00:08:48,800 --> 00:08:50,000
function sends

219
00:08:50,000 --> 00:08:53,600
the code which is assigned to kph

220
00:08:53,600 --> 00:08:56,959
queer information object

221
00:08:57,600 --> 00:09:00,880
we can find iotl codes mapped to these

222
00:09:00,880 --> 00:09:01,519
names

223
00:09:01,519 --> 00:09:05,680
in the process sector source code

224
00:09:07,760 --> 00:09:10,160
uh ioctr codes can make the driver

225
00:09:10,160 --> 00:09:12,160
execute its regarding tasks

226
00:09:12,160 --> 00:09:16,000
we can see the iota code for kph query

227
00:09:16,000 --> 00:09:17,360
information object

228
00:09:17,360 --> 00:09:23,200
is 151 so when we send ioctl bits151 to

229
00:09:23,200 --> 00:09:24,560
process secret driver

230
00:09:24,560 --> 00:09:27,600
it executes the task mapped to that

231
00:09:27,600 --> 00:09:31,200
iostl code in the driver the source code

232
00:09:31,200 --> 00:09:34,800
has lots of iocts that can be useful for

233
00:09:34,800 --> 00:09:36,399
an attacker to

234
00:09:36,399 --> 00:09:41,760
execute in an engagement however

235
00:09:41,760 --> 00:09:44,399
after reading the code from the driver

236
00:09:44,399 --> 00:09:44,880
part

237
00:09:44,880 --> 00:09:48,399
we can understand using some of iocts is

238
00:09:48,399 --> 00:09:50,080
actually limited uh

239
00:09:50,080 --> 00:09:53,440
to just process accurate process

240
00:09:53,440 --> 00:09:56,480
you cannot send new desire styles from

241
00:09:56,480 --> 00:10:01,839
another processes so they are protected

242
00:10:01,839 --> 00:10:04,720
uh process driver has a client

243
00:10:04,720 --> 00:10:07,440
verification mechanism for the functions

244
00:10:07,440 --> 00:10:10,079
that can be used maliciously by

245
00:10:10,079 --> 00:10:11,519
attackers

246
00:10:11,519 --> 00:10:13,440
a key is generated in the verification

247
00:10:13,440 --> 00:10:14,560
process when

248
00:10:14,560 --> 00:10:17,680
the driver is installed to the system

249
00:10:17,680 --> 00:10:21,200
to generate such a key driver checks the

250
00:10:21,200 --> 00:10:23,839
signature and the image of the process

251
00:10:23,839 --> 00:10:24,560
calling

252
00:10:24,560 --> 00:10:28,480
the ioctl first time with its own key

253
00:10:28,480 --> 00:10:31,360
so if the client process is verified a

254
00:10:31,360 --> 00:10:32,880
new key is generated

255
00:10:32,880 --> 00:10:36,800
to be used in iocts like let's say

256
00:10:36,800 --> 00:10:40,160
kph open process

257
00:10:41,360 --> 00:10:43,680
finding out the client verification

258
00:10:43,680 --> 00:10:44,839
mechanism

259
00:10:44,839 --> 00:10:48,160
explains why i cannot find the terminal

260
00:10:48,160 --> 00:10:50,160
port of process echo

261
00:10:50,160 --> 00:10:53,040
since i don't want to deploy entire

262
00:10:53,040 --> 00:10:55,120
application to the target system

263
00:10:55,120 --> 00:10:58,240
in an engagement i checked when the

264
00:10:58,240 --> 00:11:00,160
verification mechanism is was

265
00:11:00,160 --> 00:11:01,279
implemented

266
00:11:01,279 --> 00:11:04,079
we can see from the commit messages that

267
00:11:04,079 --> 00:11:04,640
it was

268
00:11:04,640 --> 00:11:07,760
implemented in 2016.

269
00:11:07,760 --> 00:11:10,880
uh to check if i can send ioctls without

270
00:11:10,880 --> 00:11:11,760
verification

271
00:11:11,760 --> 00:11:14,000
i downloaded an old version of process

272
00:11:14,000 --> 00:11:14,880
secret

273
00:11:14,880 --> 00:11:17,440
i saw that i can send iocts to old

274
00:11:17,440 --> 00:11:18,640
driver

275
00:11:18,640 --> 00:11:21,440
without using process sector binary at

276
00:11:21,440 --> 00:11:23,600
all

277
00:11:23,760 --> 00:11:25,600
i also want to check the code from the

278
00:11:25,600 --> 00:11:27,040
old version

279
00:11:27,040 --> 00:11:30,160
after reverting the repo to the old

280
00:11:30,160 --> 00:11:30,720
commit

281
00:11:30,720 --> 00:11:33,920
i can find the same header file with ioc

282
00:11:33,920 --> 00:11:35,040
telcos

283
00:11:35,040 --> 00:11:38,240
which are shown as reserved

284
00:11:38,240 --> 00:11:41,680
in the current version like kph write

285
00:11:41,680 --> 00:11:44,240
process memory we can see these

286
00:11:44,240 --> 00:11:45,680
functionalities are

287
00:11:45,680 --> 00:11:47,600
removed from the current version of the

288
00:11:47,600 --> 00:11:50,000
driver possibly because

289
00:11:50,000 --> 00:11:52,399
they could be abused easily after

290
00:11:52,399 --> 00:11:54,079
finding this header file

291
00:11:54,079 --> 00:11:57,440
i began to test simple functions using

292
00:11:57,440 --> 00:12:00,000
the driver

293
00:12:00,560 --> 00:12:04,560
for the first implementation we will see

294
00:12:04,560 --> 00:12:06,720
how can we read process environment

295
00:12:06,720 --> 00:12:08,880
block of a remote process

296
00:12:08,880 --> 00:12:12,079
by using process secret driver

297
00:12:12,079 --> 00:12:15,120
normally reading pb consists of three

298
00:12:15,120 --> 00:12:16,560
steps

299
00:12:16,560 --> 00:12:19,200
opening process handle using anti-open

300
00:12:19,200 --> 00:12:20,320
process

301
00:12:20,320 --> 00:12:22,959
querying peb address with anti-care

302
00:12:22,959 --> 00:12:25,040
information process

303
00:12:25,040 --> 00:12:27,839
and reading the memory using anti-read

304
00:12:27,839 --> 00:12:29,440
virtual memory

305
00:12:29,440 --> 00:12:31,839
these api calls are dispatched in the

306
00:12:31,839 --> 00:12:33,839
system service dispatcher and after

307
00:12:33,839 --> 00:12:35,120
execution

308
00:12:35,120 --> 00:12:38,399
it returns proper informations to

309
00:12:38,399 --> 00:12:41,600
use remote processes

310
00:12:41,680 --> 00:12:44,800
in order to use process secure driver or

311
00:12:44,800 --> 00:12:48,160
some of the api calls we can change

312
00:12:48,160 --> 00:12:50,959
anti-open process to anti-device io

313
00:12:50,959 --> 00:12:52,079
control file

314
00:12:52,079 --> 00:12:56,560
with open process ctr code which has 50.

315
00:12:56,560 --> 00:12:58,800
we can also change anti-read virtual

316
00:12:58,800 --> 00:12:59,839
memory to

317
00:12:59,839 --> 00:13:03,200
ntd device control io control file

318
00:13:03,200 --> 00:13:05,440
since the driver exposed the same

319
00:13:05,440 --> 00:13:06,880
capability

320
00:13:06,880 --> 00:13:10,800
these api calls causes

321
00:13:10,800 --> 00:13:12,880
io request packets to be sent to the

322
00:13:12,880 --> 00:13:14,480
driver

323
00:13:14,480 --> 00:13:17,040
which will end up executing the function

324
00:13:17,040 --> 00:13:18,959
defined in the header file

325
00:13:18,959 --> 00:13:22,880
according to its ioctl code

326
00:13:23,519 --> 00:13:26,079
this is the code implementing the

327
00:13:26,079 --> 00:13:27,040
reading

328
00:13:27,040 --> 00:13:30,160
peb using process sector driver

329
00:13:30,160 --> 00:13:33,680
kph connect is the function for getting

330
00:13:33,680 --> 00:13:34,000
the

331
00:13:34,000 --> 00:13:36,880
handle for the driver the driver device

332
00:13:36,880 --> 00:13:37,440
object

333
00:13:37,440 --> 00:13:41,680
in order to send iocts by using kp

334
00:13:41,680 --> 00:13:44,639
kph open process and kph read virtual

335
00:13:44,639 --> 00:13:45,519
memory

336
00:13:45,519 --> 00:13:48,800
we can see we open uh

337
00:13:48,800 --> 00:13:51,600
open handle of a remote process and read

338
00:13:51,600 --> 00:13:52,800
its memory

339
00:13:52,800 --> 00:13:55,920
using this driver actually it is the

340
00:13:55,920 --> 00:13:57,120
process sector driver

341
00:13:57,120 --> 00:13:59,440
executes these tasks and returns

342
00:13:59,440 --> 00:14:00,320
information

343
00:14:00,320 --> 00:14:03,839
to our client process

344
00:14:04,560 --> 00:14:08,399
so let's see uh the execution of

345
00:14:08,399 --> 00:14:11,279
our implementation on a virtual machine

346
00:14:11,279 --> 00:14:11,600
this

347
00:14:11,600 --> 00:14:14,079
is the old process second driver we

348
00:14:14,079 --> 00:14:15,279
downloaded for

349
00:14:15,279 --> 00:14:18,320
using without client verification

350
00:14:18,320 --> 00:14:21,519
we can see it's signed under the name of

351
00:14:21,519 --> 00:14:24,720
the developer processor developer

352
00:14:24,720 --> 00:14:28,079
we can install this driver using

353
00:14:28,079 --> 00:14:31,839
service control manager

354
00:14:31,839 --> 00:14:33,760
service control manager configuration

355
00:14:33,760 --> 00:14:36,000
tool

356
00:14:42,839 --> 00:14:44,800
sc.exe

357
00:14:44,800 --> 00:14:47,199
okay

358
00:14:54,480 --> 00:14:57,760
first we see the execution of binary

359
00:14:57,760 --> 00:15:02,480
compiled with standard api calls

360
00:15:02,480 --> 00:15:05,839
we can see a peb

361
00:15:05,839 --> 00:15:09,120
of a process it's

362
00:15:09,120 --> 00:15:12,480
actually the process assess process

363
00:15:12,480 --> 00:15:16,240
is we can see the pv of a process is

364
00:15:16,240 --> 00:15:17,600
read from the address

365
00:15:17,600 --> 00:15:20,720
in the command output secondly

366
00:15:20,720 --> 00:15:24,800
we execute binary compiled with

367
00:15:24,800 --> 00:15:28,480
kph functions using process secret

368
00:15:28,480 --> 00:15:30,000
driver

369
00:15:30,000 --> 00:15:32,639
we can see

370
00:15:34,240 --> 00:15:37,360
the difference of

371
00:15:37,440 --> 00:15:41,360
okay so to see the difference

372
00:15:41,360 --> 00:15:44,560
between these two we can use the

373
00:15:44,560 --> 00:15:48,720
user tool like api monitor uh

374
00:15:48,720 --> 00:15:51,519
api monitor is a tool that you you can

375
00:15:51,519 --> 00:15:53,839
use to hook api calls of a process

376
00:15:53,839 --> 00:15:56,399
and display the function parameters in

377
00:15:56,399 --> 00:15:57,440
real time

378
00:15:57,440 --> 00:16:00,240
you can check the aps that you want to

379
00:16:00,240 --> 00:16:00,959
hook from

380
00:16:00,959 --> 00:16:03,680
here and

381
00:16:04,079 --> 00:16:06,000
select target processed monitor you can

382
00:16:06,000 --> 00:16:07,440
also start

383
00:16:07,440 --> 00:16:12,000
new processes for monitoring

384
00:16:12,399 --> 00:16:15,519
we check empty open process

385
00:16:15,519 --> 00:16:22,399
for example to hook

386
00:16:22,399 --> 00:16:26,800
we also checked anti-read virtual memory

387
00:16:26,800 --> 00:16:37,839
for hooking

388
00:16:40,560 --> 00:16:43,279
we also

389
00:16:43,600 --> 00:16:47,600
check antiquary information process

390
00:16:47,600 --> 00:16:52,880
to hook our new process

391
00:16:54,959 --> 00:16:58,800
last we checked the anti-device io

392
00:16:58,800 --> 00:17:01,599
control file

393
00:17:02,839 --> 00:17:05,839
called

394
00:17:09,919 --> 00:17:13,119
done we start uh

395
00:17:13,119 --> 00:17:16,839
we start executing our first binary

396
00:17:16,839 --> 00:17:19,199
uh which uses normal

397
00:17:19,199 --> 00:17:22,880
normal api calls we can see process id

398
00:17:22,880 --> 00:17:25,120
with

399
00:17:25,319 --> 00:17:30,320
680 is open from api parameters

400
00:17:30,320 --> 00:17:33,600
we can also display uh

401
00:17:33,600 --> 00:17:36,559
the buffer red with anti read virtual

402
00:17:36,559 --> 00:17:39,280
memory call

403
00:17:42,000 --> 00:17:45,679
yeah we can see it's the remote process

404
00:17:45,679 --> 00:17:46,799
is opened and

405
00:17:46,799 --> 00:17:50,400
we can see the buffer is

406
00:17:50,400 --> 00:17:53,200
actually red

407
00:17:56,320 --> 00:18:00,240
to compare a second binary with this

408
00:18:00,240 --> 00:18:03,600
we execute uh our second binary

409
00:18:03,600 --> 00:18:06,880
using api monitor as we can see two of

410
00:18:06,880 --> 00:18:08,400
the api calls

411
00:18:08,400 --> 00:18:11,360
are changing to anti-device i control

412
00:18:11,360 --> 00:18:12,080
file

413
00:18:12,080 --> 00:18:15,280
uh call doing that uh

414
00:18:15,280 --> 00:18:18,559
we have tested that we can

415
00:18:18,559 --> 00:18:20,880
alter the execution flow of a simple

416
00:18:20,880 --> 00:18:22,000
program

417
00:18:22,000 --> 00:18:26,320
by using iocts uh instead of

418
00:18:26,320 --> 00:18:29,360
standard windows apis we can

419
00:18:29,360 --> 00:18:32,960
also display the buffer sent to process

420
00:18:32,960 --> 00:18:34,320
sector driver

421
00:18:34,320 --> 00:18:43,840
using api monitor like here

422
00:18:45,440 --> 00:18:48,640
okay uh what are the advantages of using

423
00:18:48,640 --> 00:18:49,760
iocts

424
00:18:49,760 --> 00:18:53,679
instead of standard win api calls

425
00:18:53,679 --> 00:18:57,679
i think this creates an execution path

426
00:18:57,679 --> 00:19:00,320
which is harder to analyze just using

427
00:19:00,320 --> 00:19:01,919
api hooks

428
00:19:01,919 --> 00:19:04,160
since defensive products tend to hook

429
00:19:04,160 --> 00:19:05,760
api calls like

430
00:19:05,760 --> 00:19:09,760
virtual allocates write process memory

431
00:19:09,760 --> 00:19:10,160
and

432
00:19:10,160 --> 00:19:13,280
create remote thread that are frequently

433
00:19:13,280 --> 00:19:15,039
used by malware families

434
00:19:15,039 --> 00:19:18,720
and offensive tools switching these

435
00:19:18,720 --> 00:19:19,840
functions with

436
00:19:19,840 --> 00:19:23,280
iotas would create a non-standard

437
00:19:23,280 --> 00:19:24,559
behavior

438
00:19:24,559 --> 00:19:27,840
also the ioctl codes are usually

439
00:19:27,840 --> 00:19:29,440
specific to the driver

440
00:19:29,440 --> 00:19:33,039
so an automatic analyze just looking at

441
00:19:33,039 --> 00:19:36,559
ios parameters would be hard for edrs

442
00:19:36,559 --> 00:19:41,200
and also sandboxes secondly

443
00:19:41,200 --> 00:19:44,400
process secret driver uses kernel mode

444
00:19:44,400 --> 00:19:47,840
uh uses kernel mode when it opens a

445
00:19:47,840 --> 00:19:48,960
process

446
00:19:48,960 --> 00:19:52,160
so that it bypasses user mode

447
00:19:52,160 --> 00:19:55,280
access checks this is the main reason

448
00:19:55,280 --> 00:19:57,120
that process sector can display

449
00:19:57,120 --> 00:20:00,480
so much data actually normally a process

450
00:20:00,480 --> 00:20:02,480
wouldn't be able to display

451
00:20:02,480 --> 00:20:06,000
by using iocts we can utilize the same

452
00:20:06,000 --> 00:20:09,280
capability uh with any tool

453
00:20:09,280 --> 00:20:11,679
one more important thing is that modern

454
00:20:11,679 --> 00:20:13,440
day andrews programs

455
00:20:13,440 --> 00:20:16,159
uses mini filters to register into

456
00:20:16,159 --> 00:20:18,000
kernel notifications

457
00:20:18,000 --> 00:20:21,280
like process or threat creation

458
00:20:21,280 --> 00:20:25,360
however they can be more reluctant to

459
00:20:25,360 --> 00:20:28,320
analyze notifications coming from kernel

460
00:20:28,320 --> 00:20:29,760
mode operations

461
00:20:29,760 --> 00:20:33,360
therefore it's possible to that some of

462
00:20:33,360 --> 00:20:35,840
the tasks executed by process secret

463
00:20:35,840 --> 00:20:36,640
driver

464
00:20:36,640 --> 00:20:39,760
can execute without notification of

465
00:20:39,760 --> 00:20:43,360
interest applications

466
00:20:47,200 --> 00:20:49,919
the main reason behind this capability

467
00:20:49,919 --> 00:20:52,080
which can be abused by attackers

468
00:20:52,080 --> 00:20:55,520
uh is that it deliberately ignores

469
00:20:55,520 --> 00:20:57,919
some security check on behalf of

470
00:20:57,919 --> 00:20:59,200
functionality

471
00:20:59,200 --> 00:21:01,840
microsoft has the documentation for

472
00:21:01,840 --> 00:21:03,679
driver developers

473
00:21:03,679 --> 00:21:06,400
mentioning this type of issues when

474
00:21:06,400 --> 00:21:07,600
managing handles

475
00:21:07,600 --> 00:21:10,320
in kernel mode disregarding proper

476
00:21:10,320 --> 00:21:12,080
handle management

477
00:21:12,080 --> 00:21:15,120
could be an indicator that a driver

478
00:21:15,120 --> 00:21:18,799
could be used as a leverage to bypass

479
00:21:18,799 --> 00:21:21,919
user mode access controls so

480
00:21:21,919 --> 00:21:25,200
we can identify these drivers as

481
00:21:25,200 --> 00:21:27,919
long drivers

482
00:21:29,039 --> 00:21:31,919
although changing standard api calls to

483
00:21:31,919 --> 00:21:33,280
iocts

484
00:21:33,280 --> 00:21:35,600
seems easy to implement for simple

485
00:21:35,600 --> 00:21:36,880
usages

486
00:21:36,880 --> 00:21:39,520
rewriting offensive tool which have

487
00:21:39,520 --> 00:21:40,799
various capabilities

488
00:21:40,799 --> 00:21:43,600
could be problematic for a red teamer

489
00:21:43,600 --> 00:21:44,320
also

490
00:21:44,320 --> 00:21:46,720
you won't have access to the source code

491
00:21:46,720 --> 00:21:49,120
of every offensive tool

492
00:21:49,120 --> 00:21:51,280
it's necessary to modify the tools to

493
00:21:51,280 --> 00:21:53,679
use iocts

494
00:21:53,679 --> 00:21:57,360
for this purpose we can use api hooking

495
00:21:57,360 --> 00:22:00,799
this time for changing execution of our

496
00:22:00,799 --> 00:22:04,640
own offensive tools or processes

497
00:22:04,640 --> 00:22:06,960
by using a hooking library of your

498
00:22:06,960 --> 00:22:08,320
choosing

499
00:22:08,320 --> 00:22:11,480
you can redirect your api calls to

500
00:22:11,480 --> 00:22:16,559
sending ios to process second driver

501
00:22:17,760 --> 00:22:20,240
here we can see an example of using

502
00:22:20,240 --> 00:22:21,520
microsoft editor

503
00:22:21,520 --> 00:22:24,799
library to hook open process and

504
00:22:24,799 --> 00:22:27,840
read memory api calls to redirect them

505
00:22:27,840 --> 00:22:28,480
into

506
00:22:28,480 --> 00:22:32,240
kph open process and kph read virtual

507
00:22:32,240 --> 00:22:33,440
memory

508
00:22:33,440 --> 00:22:36,640
this code creates a dln which can be

509
00:22:36,640 --> 00:22:38,960
injected into your attacker process

510
00:22:38,960 --> 00:22:42,000
to hoop the api calls let's try this

511
00:22:42,000 --> 00:22:45,280
method on a well-known tool

512
00:22:46,400 --> 00:22:49,600
in this demo i will try to hook

513
00:22:49,600 --> 00:22:53,200
mimi cuts to make it use kph functions

514
00:22:53,200 --> 00:22:57,039
when it dumps the credentials normally

515
00:22:57,039 --> 00:23:00,240
memcat uses open process and read

516
00:23:00,240 --> 00:23:01,679
virtual memory calls

517
00:23:01,679 --> 00:23:05,520
to open elsa's exam and read its content

518
00:23:05,520 --> 00:23:09,280
we start monitoring mimikatz process

519
00:23:09,280 --> 00:23:13,918
by using api monitor we can

520
00:23:18,720 --> 00:23:22,400
here we can see

521
00:23:22,400 --> 00:23:26,240
empty calls are made here

522
00:23:26,240 --> 00:23:29,200
we can also see

523
00:23:29,760 --> 00:23:32,080
empty read virtual memory has returned

524
00:23:32,080 --> 00:23:33,840
the contents of elsa's memory

525
00:23:33,840 --> 00:23:37,840
in parameters

526
00:23:48,840 --> 00:23:51,440
okay

527
00:23:51,440 --> 00:23:54,080
we restart mimikatz process again for

528
00:23:54,080 --> 00:23:55,039
this time

529
00:23:55,039 --> 00:23:58,400
uh hooking i will use

530
00:23:58,400 --> 00:24:01,520
process echo's all injected live picture

531
00:24:01,520 --> 00:24:05,520
to inject our dieter dln into mimikaze x

532
00:24:05,520 --> 00:24:06,720
process

533
00:24:06,720 --> 00:24:09,600
we can see that

534
00:24:12,799 --> 00:24:16,840
we choose our theta dla

535
00:24:16,840 --> 00:24:20,880
so we can see that our dll

536
00:24:20,880 --> 00:24:23,200
is executed and it's successfully

537
00:24:23,200 --> 00:24:25,279
connected to

538
00:24:25,279 --> 00:24:28,559
the process sector driver

539
00:24:28,559 --> 00:24:32,080
we start monitoring

540
00:24:32,080 --> 00:24:35,520
mimi cuts process again

541
00:24:40,000 --> 00:24:43,039
we choose anti-device io control file

542
00:24:43,039 --> 00:24:48,559
from apm api monitor to see ioctls

543
00:24:56,400 --> 00:24:59,039
when we dump credentials from asa's

544
00:24:59,039 --> 00:24:59,760
process

545
00:24:59,760 --> 00:25:03,039
we see that the api calls of anti-open

546
00:25:03,039 --> 00:25:03,840
process and

547
00:25:03,840 --> 00:25:07,200
anti-read virtual memory is not shown in

548
00:25:07,200 --> 00:25:08,480
monitored calls

549
00:25:08,480 --> 00:25:10,960
this is because the alli we have

550
00:25:10,960 --> 00:25:11,679
injected

551
00:25:11,679 --> 00:25:15,279
actually redirected mimikatz code

552
00:25:15,279 --> 00:25:18,400
to use kph equivalents

553
00:25:18,400 --> 00:25:22,320
instead of min apis to see our stl code

554
00:25:22,320 --> 00:25:29,840
we start monitoring again

555
00:25:35,600 --> 00:25:40,879
we again dump the air sas process

556
00:25:41,440 --> 00:25:44,880
now we can see all io ctls

557
00:25:44,880 --> 00:25:47,279
that is used by mimikatz process for

558
00:25:47,279 --> 00:25:49,279
opening elsa's

559
00:25:49,279 --> 00:25:53,919
and reading its memory this way

560
00:25:53,919 --> 00:25:56,559
we can modify tools without actually

561
00:25:56,559 --> 00:25:58,159
recompiling them

562
00:25:58,159 --> 00:26:11,840
from scratch

563
00:26:12,640 --> 00:26:14,880
let's look at another implementation of

564
00:26:14,880 --> 00:26:17,220
our load driver

565
00:26:17,220 --> 00:26:18,880
[Applause]

566
00:26:18,880 --> 00:26:21,600
in summary process injection consists of

567
00:26:21,600 --> 00:26:23,440
three steps

568
00:26:23,440 --> 00:26:25,840
allocating memory for the payload

569
00:26:25,840 --> 00:26:26,559
writing

570
00:26:26,559 --> 00:26:28,880
payload to allocated memory and

571
00:26:28,880 --> 00:26:30,720
executing the payload

572
00:26:30,720 --> 00:26:33,760
to inject a process using the load

573
00:26:33,760 --> 00:26:34,559
driver

574
00:26:34,559 --> 00:26:37,520
we can use we can utilize some of the

575
00:26:37,520 --> 00:26:40,240
ios styles

576
00:26:40,240 --> 00:26:43,279
this is a simple code hijacks the main

577
00:26:43,279 --> 00:26:43,760
thread

578
00:26:43,760 --> 00:26:47,039
of a process to execute a shell code

579
00:26:47,039 --> 00:26:49,440
to do that you need to suspend the

580
00:26:49,440 --> 00:26:51,039
thread

581
00:26:51,039 --> 00:26:54,240
you want to hijack after you wrote the

582
00:26:54,240 --> 00:26:56,159
payload into the address space of the

583
00:26:56,159 --> 00:26:57,600
remote process

584
00:26:57,600 --> 00:27:00,159
then you get context of the thread which

585
00:27:00,159 --> 00:27:00,799
includes

586
00:27:00,799 --> 00:27:04,480
registry values since it's suspended

587
00:27:04,480 --> 00:27:07,760
we change the rip registry to the

588
00:27:07,760 --> 00:27:09,679
beginning of our shellcode

589
00:27:09,679 --> 00:27:13,200
by using setcontextthread api call

590
00:27:13,200 --> 00:27:15,520
after resuming this thread we expect

591
00:27:15,520 --> 00:27:16,480
that

592
00:27:16,480 --> 00:27:20,799
our shellcode is executed

593
00:27:20,799 --> 00:27:23,600
we can implement the same behavior using

594
00:27:23,600 --> 00:27:24,640
process sector

595
00:27:24,640 --> 00:27:28,240
ioctl functions these are the ioctl

596
00:27:28,240 --> 00:27:29,520
functions that

597
00:27:29,520 --> 00:27:32,320
that are used for the same function

598
00:27:32,320 --> 00:27:33,760
functionality

599
00:27:33,760 --> 00:27:36,720
since there is no anti-suspension

600
00:27:36,720 --> 00:27:39,440
equivalent for kph functions

601
00:27:39,440 --> 00:27:43,120
uh i used kph suspend process and resume

602
00:27:43,120 --> 00:27:44,320
process functions

603
00:27:44,320 --> 00:27:48,880
instead of the threads

604
00:27:48,880 --> 00:27:52,320
after switching api calls uh with their

605
00:27:52,320 --> 00:27:53,120
equivalent

606
00:27:53,120 --> 00:27:56,720
kph functions the injection code becomes

607
00:27:56,720 --> 00:27:59,279
like this

608
00:27:59,919 --> 00:28:03,520
let's see it let's see how it works in

609
00:28:03,520 --> 00:28:06,080
the demo

610
00:28:08,480 --> 00:28:10,640
in this demo we will inject a shellcode

611
00:28:10,640 --> 00:28:13,679
into explorer.exe process

612
00:28:13,679 --> 00:28:17,039
by using thread execution hijacking

613
00:28:17,039 --> 00:28:19,520
method

614
00:28:21,840 --> 00:28:24,960
here are functions checked for

615
00:28:24,960 --> 00:28:31,840
api monitoring

616
00:28:37,120 --> 00:28:40,480
let's start our third program which uses

617
00:28:40,480 --> 00:28:45,840
standard threat hijacking code

618
00:28:49,919 --> 00:28:52,240
after execution we see that the

619
00:28:52,240 --> 00:28:54,080
calculator is spawned

620
00:28:54,080 --> 00:28:57,919
we can see the ntdl apis called by our

621
00:28:57,919 --> 00:28:59,200
program

622
00:28:59,200 --> 00:29:01,520
most of the defensive product would

623
00:29:01,520 --> 00:29:02,640
identify this

624
00:29:02,640 --> 00:29:06,080
as threat hijacking

625
00:29:06,399 --> 00:29:13,840
because it's a well-known pattern

626
00:29:15,679 --> 00:29:19,440
now let's check our implementation using

627
00:29:19,440 --> 00:29:27,840
the process sector driver

628
00:29:31,840 --> 00:29:34,240
after a couple of seconds we can see the

629
00:29:34,240 --> 00:29:36,240
show code is actually executed

630
00:29:36,240 --> 00:29:38,840
uh when we look at the api monitor

631
00:29:38,840 --> 00:29:41,679
output we can see

632
00:29:41,679 --> 00:29:45,919
uh anti-device io control file calls in

633
00:29:45,919 --> 00:29:46,799
place of

634
00:29:46,799 --> 00:29:50,240
the old windows api functions

635
00:29:50,240 --> 00:29:52,559
our load driver does not have an

636
00:29:52,559 --> 00:29:54,000
equivalent for

637
00:29:54,000 --> 00:29:56,880
virtual unlock so we can still see it in

638
00:29:56,880 --> 00:29:57,919
the

639
00:29:57,919 --> 00:30:02,960
api monitor output we can check

640
00:30:03,120 --> 00:30:05,679
we can check the old api calls kind of

641
00:30:05,679 --> 00:30:06,880
normalized

642
00:30:06,880 --> 00:30:10,000
from the perspective of analysis

643
00:30:10,000 --> 00:30:13,279
this version actually knee version is

644
00:30:13,279 --> 00:30:15,360
harder to detect

645
00:30:15,360 --> 00:30:18,559
as a thread execution hijacking than

646
00:30:18,559 --> 00:30:23,600
the standard one

647
00:30:23,600 --> 00:30:26,880
okay uh let's move on to protected

648
00:30:26,880 --> 00:30:27,760
processes

649
00:30:27,760 --> 00:30:30,880
uh protected process slide is a windows

650
00:30:30,880 --> 00:30:31,600
feature

651
00:30:31,600 --> 00:30:36,240
introduced in windows 8.1

652
00:30:36,240 --> 00:30:39,600
ppl is a feature of a process defined in

653
00:30:39,600 --> 00:30:42,799
one of the fields in e-process kernel

654
00:30:42,799 --> 00:30:44,000
objects

655
00:30:44,000 --> 00:30:47,760
windows provided as a boundary between

656
00:30:47,760 --> 00:30:52,000
os components and user applications

657
00:30:52,000 --> 00:30:54,919
one of the well-known usages is running

658
00:30:54,919 --> 00:30:57,279
elsas.exe

659
00:30:57,279 --> 00:31:00,720
as ppl by configuring it with a registry

660
00:31:00,720 --> 00:31:01,679
key

661
00:31:01,679 --> 00:31:04,799
if your process is started if a process

662
00:31:04,799 --> 00:31:06,720
is started as ppi

663
00:31:06,720 --> 00:31:09,519
opening handles with full access is not

664
00:31:09,519 --> 00:31:10,640
permitted

665
00:31:10,640 --> 00:31:14,000
and the access right will be masked to

666
00:31:14,000 --> 00:31:18,559
lower lower according to its ppl level

667
00:31:18,559 --> 00:31:22,240
ppls also have a hierarchy level system

668
00:31:22,240 --> 00:31:25,519
between each other as it is shown in the

669
00:31:25,519 --> 00:31:26,559
graph

670
00:31:26,559 --> 00:31:30,159
a ppr process with windows tcv level

671
00:31:30,159 --> 00:31:33,279
can open full access to all other

672
00:31:33,279 --> 00:31:36,720
ppl processes while a process with

673
00:31:36,720 --> 00:31:39,519
anti-malware level can only access fully

674
00:31:39,519 --> 00:31:41,279
to processes

675
00:31:41,279 --> 00:31:46,640
with the same level or below

676
00:31:46,640 --> 00:31:49,840
as we said uh ppl is usually used as the

677
00:31:49,840 --> 00:31:50,640
mitigation

678
00:31:50,640 --> 00:31:53,840
for credential dumping attacks uh there

679
00:31:53,840 --> 00:31:54,720
are studies on

680
00:31:54,720 --> 00:31:58,159
turning off ppl bit by exploiting

681
00:31:58,159 --> 00:32:01,600
vulnerable drivers to over overwrite the

682
00:32:01,600 --> 00:32:02,080
field

683
00:32:02,080 --> 00:32:05,279
in e-process objects although this is an

684
00:32:05,279 --> 00:32:06,880
effective method

685
00:32:06,880 --> 00:32:08,880
it can also create an indicator for

686
00:32:08,880 --> 00:32:11,279
defenders as well

687
00:32:11,279 --> 00:32:14,480
moreover driver x

688
00:32:14,480 --> 00:32:16,559
the driver exploit may need to patch

689
00:32:16,559 --> 00:32:18,159
some objects in the kernel

690
00:32:18,159 --> 00:32:20,559
uh which can be problematic for patch

691
00:32:20,559 --> 00:32:21,200
card

692
00:32:21,200 --> 00:32:24,559
in different windows versions

693
00:32:24,559 --> 00:32:27,039
there may be different ways to interact

694
00:32:27,039 --> 00:32:28,799
with ppl processes

695
00:32:28,799 --> 00:32:31,360
and since we can open handles using our

696
00:32:31,360 --> 00:32:34,240
load driver without any restrictions

697
00:32:34,240 --> 00:32:36,559
it may be possible to use ppl as a

698
00:32:36,559 --> 00:32:37,840
protection

699
00:32:37,840 --> 00:32:40,720
for our offensive payload creating a

700
00:32:40,720 --> 00:32:42,240
process with ppl

701
00:32:42,240 --> 00:32:45,679
is possible only if you are using a ppr

702
00:32:45,679 --> 00:32:47,360
signed executables

703
00:32:47,360 --> 00:32:50,159
these executables also be third-party

704
00:32:50,159 --> 00:32:50,799
problem

705
00:32:50,799 --> 00:32:53,120
can be also third-party programs like

706
00:32:53,120 --> 00:32:55,120
anterior executables

707
00:32:55,120 --> 00:32:57,600
but third-party executable can be

708
00:32:57,600 --> 00:32:59,240
assigned as

709
00:32:59,240 --> 00:33:02,960
anti-anti-malware level at most

710
00:33:02,960 --> 00:33:06,320
i want to create a host process for my

711
00:33:06,320 --> 00:33:10,000
offensive payload at windows tcb level

712
00:33:10,000 --> 00:33:13,279
because it's higher than the antimalware

713
00:33:13,279 --> 00:33:14,159
level

714
00:33:14,159 --> 00:33:17,440
to do that i checked the windows tcb

715
00:33:17,440 --> 00:33:21,120
ppr signed tcp level ppl signed

716
00:33:21,120 --> 00:33:22,320
executables in

717
00:33:22,320 --> 00:33:26,159
windows 10 i decided to use services exa

718
00:33:26,159 --> 00:33:29,440
as the host process

719
00:33:30,399 --> 00:33:33,760
after that i created a simple loader

720
00:33:33,760 --> 00:33:37,919
for using early bird injection technique

721
00:33:37,919 --> 00:33:39,039
to create a new

722
00:33:39,039 --> 00:33:42,880
services exa instance in suspended state

723
00:33:42,880 --> 00:33:46,799
and injects it with our payload

724
00:33:46,799 --> 00:33:50,320
since we have the driver of process echo

725
00:33:50,320 --> 00:33:53,039
we use it to open a full access handle

726
00:33:53,039 --> 00:33:54,000
to

727
00:33:54,000 --> 00:33:57,360
uh created services exa instance and

728
00:33:57,360 --> 00:34:00,640
write our payload with kph write process

729
00:34:00,640 --> 00:34:02,240
memory

730
00:34:02,240 --> 00:34:05,120
after sending an apc to execute our

731
00:34:05,120 --> 00:34:05,919
shortcode

732
00:34:05,919 --> 00:34:09,520
we call kph resume process to start

733
00:34:09,520 --> 00:34:12,399
our execution

734
00:34:12,960 --> 00:34:15,199
this is the source code of the loader

735
00:34:15,199 --> 00:34:17,199
that we designed

736
00:34:17,199 --> 00:34:21,119
as we can see it utilizes kph wrapper

737
00:34:21,119 --> 00:34:23,839
functions to get handle and write

738
00:34:23,839 --> 00:34:26,239
payload to ppl process

739
00:34:26,239 --> 00:34:31,040
let's see how it works in the demo

740
00:34:32,839 --> 00:34:35,599
environment

741
00:34:35,599 --> 00:34:38,239
this is our demo environment for the

742
00:34:38,239 --> 00:34:40,719
loader

743
00:34:43,679 --> 00:34:48,719
as we can see uh real time

744
00:34:48,719 --> 00:34:53,839
and club delivered protection is on and

745
00:34:54,239 --> 00:35:02,960
also the defender is updated

746
00:35:02,960 --> 00:35:05,920
we can also see elsa's process is also

747
00:35:05,920 --> 00:35:06,720
configured

748
00:35:06,720 --> 00:35:10,240
to be run as ppl

749
00:35:12,640 --> 00:35:15,440
let's try our very first demo that reads

750
00:35:15,440 --> 00:35:16,160
pb of

751
00:35:16,160 --> 00:35:19,920
atlas process with standard api calls

752
00:35:19,920 --> 00:35:22,800
we can see it fails as we expected since

753
00:35:22,800 --> 00:35:24,640
opening handles to

754
00:35:24,640 --> 00:35:27,200
elsa's is recited with standard api

755
00:35:27,200 --> 00:35:28,320
calls

756
00:35:28,320 --> 00:35:31,680
okay uh let's create our payload this is

757
00:35:31,680 --> 00:35:35,920
the attacker kali machine we create

758
00:35:35,920 --> 00:35:40,000
we create reverse https metal printer

759
00:35:40,000 --> 00:35:40,880
payload using

760
00:35:40,880 --> 00:35:45,839
msf venom command

761
00:35:47,040 --> 00:35:50,000
we also start our metal printer handler

762
00:35:50,000 --> 00:35:50,720
since

763
00:35:50,720 --> 00:35:53,598
i intend to

764
00:35:54,000 --> 00:35:56,400
since i intend to serve the first

765
00:35:56,400 --> 00:35:57,200
payload

766
00:35:57,200 --> 00:36:01,920
on a simple http server

767
00:36:01,920 --> 00:36:05,040
i encrypted the shellcode using a simple

768
00:36:05,040 --> 00:36:08,400
is encrypt mechanism

769
00:36:09,040 --> 00:36:12,240
we start our http server

770
00:36:12,240 --> 00:36:14,800
on the attacker machine on the target

771
00:36:14,800 --> 00:36:16,079
machine

772
00:36:16,079 --> 00:36:21,920
we execute our loader

773
00:36:22,079 --> 00:36:27,839
with url parameter

774
00:36:28,880 --> 00:36:34,320
to downloading the shell code

775
00:36:36,720 --> 00:36:38,320
as we can see in the process sector

776
00:36:38,320 --> 00:36:40,640
window any services x

777
00:36:40,640 --> 00:36:46,400
instance is created with system token

778
00:36:47,680 --> 00:36:51,040
we checked the ppl level of it and it is

779
00:36:51,040 --> 00:36:52,079
shown as

780
00:36:52,079 --> 00:36:55,839
the win win tcb level

781
00:36:58,400 --> 00:37:00,800
now turning back to attacker machine we

782
00:37:00,800 --> 00:37:02,160
can see

783
00:37:02,160 --> 00:37:09,359
any metal printer session is started

784
00:37:09,359 --> 00:37:12,800
we can check the current user and

785
00:37:12,800 --> 00:37:22,880
the pid of the process

786
00:37:22,880 --> 00:37:25,200
okay

787
00:37:26,240 --> 00:37:28,720
let's try a different thing we said

788
00:37:28,720 --> 00:37:30,960
anti-malware processes have

789
00:37:30,960 --> 00:37:35,839
lower ppi level so in theory

790
00:37:35,839 --> 00:37:38,960
should have enough privilege to

791
00:37:38,960 --> 00:37:42,320
inject into

792
00:37:42,320 --> 00:37:45,680
the defender process from

793
00:37:45,680 --> 00:37:49,839
our service sector process we can use

794
00:37:49,839 --> 00:37:52,320
migrate command to inject into defender

795
00:37:52,320 --> 00:37:52,880
process

796
00:37:52,880 --> 00:37:55,359
like this

797
00:38:03,040 --> 00:38:07,520
we check the process id

798
00:38:10,640 --> 00:38:13,760
and also we can use since we are in the

799
00:38:13,760 --> 00:38:15,920
defender process we can use well-known

800
00:38:15,920 --> 00:38:17,359
malicious tools like

801
00:38:17,359 --> 00:38:20,640
kiwi inside the defender process

802
00:38:20,640 --> 00:38:24,240
without facing any obstacles actually

803
00:38:24,240 --> 00:38:27,280
let's dump credential from elsa's exit

804
00:38:27,280 --> 00:38:33,680
which is configured to run as ppl

805
00:38:33,680 --> 00:38:36,880
when we execute the command hashes are

806
00:38:36,880 --> 00:38:46,079
dumped without error

807
00:38:46,079 --> 00:38:50,000
okay that's all

808
00:38:50,160 --> 00:38:53,599
uh i decided to gather these techniques

809
00:38:53,599 --> 00:38:55,599
in a tool called offensive process

810
00:38:55,599 --> 00:38:56,880
seeker

811
00:38:56,880 --> 00:38:58,480
if you want to check the techniques i

812
00:38:58,480 --> 00:39:00,560
mentioned

813
00:39:00,560 --> 00:39:02,960
and some others you can find it on

814
00:39:02,960 --> 00:39:05,760
github link

815
00:39:07,119 --> 00:39:12,480
it's a new tool so uh pull requests or

816
00:39:12,480 --> 00:39:15,680
always appreciated

817
00:39:15,839 --> 00:39:19,040
for next i plan to search

818
00:39:19,040 --> 00:39:21,119
for drivers which can be utilized

819
00:39:21,119 --> 00:39:22,480
similarly

820
00:39:22,480 --> 00:39:24,720
i intend to implement new techniques to

821
00:39:24,720 --> 00:39:25,760
offensive p

822
00:39:25,760 --> 00:39:30,000
process soccer as well also finding

823
00:39:30,000 --> 00:39:32,400
less noisy ways of installing driver

824
00:39:32,400 --> 00:39:33,599
would increase the

825
00:39:33,599 --> 00:39:37,599
impact of this project

826
00:39:38,400 --> 00:39:41,440
that's all for this talk thank you

827
00:39:41,440 --> 00:39:50,800
see you in qay

