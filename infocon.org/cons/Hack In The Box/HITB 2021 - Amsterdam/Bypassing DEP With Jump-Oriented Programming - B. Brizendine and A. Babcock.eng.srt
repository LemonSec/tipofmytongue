1
00:00:15,440 --> 00:00:17,920
welcome to our hack in the box talk

2
00:00:17,920 --> 00:00:20,640
job rocket bypassing depth with jump

3
00:00:20,640 --> 00:00:22,160
oriented programming

4
00:00:22,160 --> 00:00:24,320
hi i'm dr bremel brisendein i'm the

5
00:00:24,320 --> 00:00:26,240
director of the verona lab

6
00:00:26,240 --> 00:00:29,439
and i'm also the creator of the job

7
00:00:29,439 --> 00:00:31,599
rocket i dabbled in being an assistant

8
00:00:31,599 --> 00:00:33,360
professor of computer

9
00:00:33,360 --> 00:00:36,000
and cyber science and i'm interested

10
00:00:36,000 --> 00:00:37,920
generally in code reuse attacks

11
00:00:37,920 --> 00:00:39,520
software exploitation reverse

12
00:00:39,520 --> 00:00:41,120
engineering and so much

13
00:00:41,120 --> 00:00:45,039
more i have a phd in cyber operations

14
00:00:45,039 --> 00:00:47,360
and i'm honored and privileged to be

15
00:00:47,360 --> 00:00:48,079
joined

16
00:00:48,079 --> 00:00:50,879
by my co-speaker austin babcock who is a

17
00:00:50,879 --> 00:00:52,320
graduate student

18
00:00:52,320 --> 00:00:54,239
studying computer science and cyber

19
00:00:54,239 --> 00:00:56,399
operations he is a security

20
00:00:56,399 --> 00:00:59,039
researcher in verona where he works with

21
00:00:59,039 --> 00:01:00,559
me to develop

22
00:01:00,559 --> 00:01:03,280
a novel shellcode analysis framework

23
00:01:03,280 --> 00:01:04,080
funded by an

24
00:01:04,080 --> 00:01:07,439
nsa grant he's a long time contributor

25
00:01:07,439 --> 00:01:08,640
to the job rocket

26
00:01:08,640 --> 00:01:11,360
and so skilled as he hit jump oriented

27
00:01:11,360 --> 00:01:12,240
programming

28
00:01:12,240 --> 00:01:14,240
you could probably call him a job

29
00:01:14,240 --> 00:01:15,360
whisperer

30
00:01:15,360 --> 00:01:17,600
he's interested in software exploitation

31
00:01:17,600 --> 00:01:19,680
fuzzing reverse engineering

32
00:01:19,680 --> 00:01:23,680
and bug bounties so let's get on with it

33
00:01:23,680 --> 00:01:26,479
jump oriented programming well firstly

34
00:01:26,479 --> 00:01:27,520
we'll introduce

35
00:01:27,520 --> 00:01:29,920
jump oriented programming and then the

36
00:01:29,920 --> 00:01:31,360
job rocket

37
00:01:31,360 --> 00:01:33,040
and then austin will show us how we can

38
00:01:33,040 --> 00:01:34,960
manually craft

39
00:01:34,960 --> 00:01:38,000
a job exploit to bypass dep

40
00:01:38,000 --> 00:01:39,759
and some various tips and techniques

41
00:01:39,759 --> 00:01:41,600
associated with it and then we'll see

42
00:01:41,600 --> 00:01:43,600
how we can remove the human labor

43
00:01:43,600 --> 00:01:44,320
element

44
00:01:44,320 --> 00:01:48,079
and do it all through automation

45
00:01:48,079 --> 00:01:50,479
next austin will show us instead of

46
00:01:50,479 --> 00:01:52,079
bypassing depth well

47
00:01:52,079 --> 00:01:55,200
what if we just simply avoid it and also

48
00:01:55,200 --> 00:01:56,799
avoid the need for shell code

49
00:01:56,799 --> 00:01:59,680
and instead just do all that shell code

50
00:01:59,680 --> 00:02:00,399
action

51
00:02:00,399 --> 00:02:03,520
directly inside of the job exploit

52
00:02:03,520 --> 00:02:06,719
hey we can do it and then finally novel

53
00:02:06,719 --> 00:02:08,479
dispatcher gadgets that's a very

54
00:02:08,479 --> 00:02:09,679
important topic because

55
00:02:09,679 --> 00:02:12,959
this helps to make job much much more

56
00:02:12,959 --> 00:02:14,239
accessible

57
00:02:14,239 --> 00:02:16,239
because previously the dispatcher gadget

58
00:02:16,239 --> 00:02:17,680
was kind of uncommon

59
00:02:17,680 --> 00:02:21,200
and now much less so so pretty big

60
00:02:21,200 --> 00:02:22,000
contribution

61
00:02:22,000 --> 00:02:24,400
there so let's get on with it the

62
00:02:24,400 --> 00:02:25,200
background of

63
00:02:25,200 --> 00:02:26,959
job now it's been around for about a

64
00:02:26,959 --> 00:02:28,959
decade in the academic literature but

65
00:02:28,959 --> 00:02:31,440
very sparse very minimal

66
00:02:31,440 --> 00:02:34,480
very little activity and

67
00:02:34,480 --> 00:02:37,120
really more theoretical no working job

68
00:02:37,120 --> 00:02:38,959
exploits to learn from

69
00:02:38,959 --> 00:02:41,280
and giving claims that had never been

70
00:02:41,280 --> 00:02:43,440
done in the wild

71
00:02:43,440 --> 00:02:45,519
much of the actual practical information

72
00:02:45,519 --> 00:02:46,640
on jop

73
00:02:46,640 --> 00:02:50,160
totally and completely missing things

74
00:02:50,160 --> 00:02:51,360
that austin and i

75
00:02:51,360 --> 00:02:52,720
have had to develop through

76
00:02:52,720 --> 00:02:55,280
experimentation and trial and error

77
00:02:55,280 --> 00:02:57,360
so we've taken something that's been out

78
00:02:57,360 --> 00:02:58,879
there in

79
00:02:58,879 --> 00:03:01,120
the academic world and theoretical and

80
00:03:01,120 --> 00:03:02,159
made it more

81
00:03:02,159 --> 00:03:04,720
realistic and we'll see some real world

82
00:03:04,720 --> 00:03:06,560
uh exploits later on

83
00:03:06,560 --> 00:03:09,599
with jop that we've done

84
00:03:09,599 --> 00:03:11,840
so we introduced the job rocket at

85
00:03:11,840 --> 00:03:13,120
defcon 27

86
00:03:13,120 --> 00:03:15,680
we did a full job exploit to bypass step

87
00:03:15,680 --> 00:03:17,840
but since then we've expanded it

88
00:03:17,840 --> 00:03:21,440
tremendously introducing automation

89
00:03:21,440 --> 00:03:23,840
and also the to gadget dispatcher which

90
00:03:23,840 --> 00:03:24,720
you'll hear

91
00:03:24,720 --> 00:03:28,080
more about shortly

92
00:03:28,159 --> 00:03:29,920
now there are some different paradigms

93
00:03:29,920 --> 00:03:31,599
or different ways to do job and we're

94
00:03:31,599 --> 00:03:33,599
going to focus on the first one

95
00:03:33,599 --> 00:03:36,080
which is the dispatcher gadget paradigm

96
00:03:36,080 --> 00:03:38,000
where we have a dispatch table

97
00:03:38,000 --> 00:03:39,760
containing addresses for functional

98
00:03:39,760 --> 00:03:41,280
gadgets and these are

99
00:03:41,280 --> 00:03:44,480
dispatched the other way to do it is to

100
00:03:44,480 --> 00:03:46,640
bring your own pop jump paradigm

101
00:03:46,640 --> 00:03:49,680
where we continuously load the address

102
00:03:49,680 --> 00:03:50,640
of the next

103
00:03:50,640 --> 00:03:54,159
gadget and at the same time also do the

104
00:03:54,159 --> 00:03:57,360
uh more substantial operation so it can

105
00:03:57,360 --> 00:03:59,439
be very chaotic and very twisted maybe

106
00:03:59,439 --> 00:04:01,040
not too practical

107
00:04:01,040 --> 00:04:02,720
another approach that i came upon

108
00:04:02,720 --> 00:04:05,040
recently used in some exploits for the

109
00:04:05,040 --> 00:04:06,879
sony playstation 4

110
00:04:06,879 --> 00:04:10,319
in free bsd is this this variant

111
00:04:10,319 --> 00:04:10,799
approach

112
00:04:10,799 --> 00:04:13,280
i don't there's no title name for it but

113
00:04:13,280 --> 00:04:14,000
basically

114
00:04:14,000 --> 00:04:17,040
combination dispatcher functional gadget

115
00:04:17,040 --> 00:04:18,880
and it does the dereferencing and the

116
00:04:18,880 --> 00:04:20,238
substance of

117
00:04:20,238 --> 00:04:23,520
actions simultaneously so in this case

118
00:04:23,520 --> 00:04:25,919
rax points to the dispatcher table and

119
00:04:25,919 --> 00:04:26,639
we can

120
00:04:26,639 --> 00:04:29,919
access different indexes within it

121
00:04:29,919 --> 00:04:31,840
so let's review some key elements you'll

122
00:04:31,840 --> 00:04:33,600
hear a lot about these

123
00:04:33,600 --> 00:04:35,919
later on throughout the presentation so

124
00:04:35,919 --> 00:04:37,600
the dispatch table can be anywhere in

125
00:04:37,600 --> 00:04:40,320
memory the stack the heap wherever

126
00:04:40,320 --> 00:04:43,120
and you'll have addresses to the

127
00:04:43,120 --> 00:04:44,639
functional gadgets and between them

128
00:04:44,639 --> 00:04:46,400
you'll have padding

129
00:04:46,400 --> 00:04:48,960
and then the dispatch or gadget will

130
00:04:48,960 --> 00:04:50,800
predictably modify

131
00:04:50,800 --> 00:04:53,680
and index into the dispatch table and at

132
00:04:53,680 --> 00:04:55,919
the same time dereference the same

133
00:04:55,919 --> 00:04:56,880
register

134
00:04:56,880 --> 00:04:58,720
so it's kind of like a program counter

135
00:04:58,720 --> 00:05:00,639
that allows us to to move from

136
00:05:00,639 --> 00:05:03,039
one entry in the dispatch table to the

137
00:05:03,039 --> 00:05:03,840
next

138
00:05:03,840 --> 00:05:06,080
and each entry point to the functional

139
00:05:06,080 --> 00:05:07,919
gadget which is more similar to

140
00:05:07,919 --> 00:05:10,080
our traditional rot gadgets they do the

141
00:05:10,080 --> 00:05:10,960
more uh

142
00:05:10,960 --> 00:05:13,600
important actions like setting up when

143
00:05:13,600 --> 00:05:14,240
api

144
00:05:14,240 --> 00:05:18,080
calls the stack forget about it we don't

145
00:05:18,080 --> 00:05:19,759
use it for control flow and that's very

146
00:05:19,759 --> 00:05:20,880
liberating

147
00:05:20,880 --> 00:05:24,160
um it gives us some some much needed

148
00:05:24,160 --> 00:05:25,520
flexibility

149
00:05:25,520 --> 00:05:28,080
but we do use it however to set up our

150
00:05:28,080 --> 00:05:29,039
win api

151
00:05:29,039 --> 00:05:32,160
functions like bypassing dep so we we

152
00:05:32,160 --> 00:05:34,400
don't use it for control flow but we do

153
00:05:34,400 --> 00:05:36,000
use it for

154
00:05:36,000 --> 00:05:39,280
our our bypasses and uh

155
00:05:39,280 --> 00:05:41,280
other similar things so let's see this

156
00:05:41,280 --> 00:05:43,759
in motion the dispatch goes to the table

157
00:05:43,759 --> 00:05:45,199
we have an address there let's

158
00:05:45,199 --> 00:05:46,960
de-reference it okay

159
00:05:46,960 --> 00:05:49,840
now let's do it and then we jump back to

160
00:05:49,840 --> 00:05:51,039
the dispatcher

161
00:05:51,039 --> 00:05:52,880
dereference the next go to the next

162
00:05:52,880 --> 00:05:54,479
functional gadget

163
00:05:54,479 --> 00:05:56,560
and then back to the dispatcher and this

164
00:05:56,560 --> 00:05:58,560
continues for however many

165
00:05:58,560 --> 00:06:00,240
gadgets there are and it works quite

166
00:06:00,240 --> 00:06:02,479
well so

167
00:06:02,479 --> 00:06:04,759
jump oriented programming it is a state

168
00:06:04,759 --> 00:06:05,919
state-of-the-art

169
00:06:05,919 --> 00:06:09,280
advanced code reuse attack not widely

170
00:06:09,280 --> 00:06:10,160
used

171
00:06:10,160 --> 00:06:11,680
but we're not trying to claim that this

172
00:06:11,680 --> 00:06:13,840
is the next best thing that's going to

173
00:06:13,840 --> 00:06:15,600
replace rob because

174
00:06:15,600 --> 00:06:17,759
even though we present a solution to the

175
00:06:17,759 --> 00:06:18,960
dispatcher

176
00:06:18,960 --> 00:06:21,600
problem with the two gadget dispatcher

177
00:06:21,600 --> 00:06:22,160
making it

178
00:06:22,160 --> 00:06:25,600
much more plentiful it's still not

179
00:06:25,600 --> 00:06:27,680
always going to be viable

180
00:06:27,680 --> 00:06:30,560
but at least now with the two gadget

181
00:06:30,560 --> 00:06:32,560
dispatcher and with the job rocket

182
00:06:32,560 --> 00:06:35,680
and the job chain generation we actually

183
00:06:35,680 --> 00:06:36,240
have

184
00:06:36,240 --> 00:06:38,960
you know a fairly decent chance of of

185
00:06:38,960 --> 00:06:39,919
doing job

186
00:06:39,919 --> 00:06:43,280
just not on every binary

187
00:06:43,280 --> 00:06:45,120
now at this point we would like to

188
00:06:45,120 --> 00:06:46,560
introduce the job rocket and throughout

189
00:06:46,560 --> 00:06:47,759
the presentation you'll see

190
00:06:47,759 --> 00:06:50,800
various cats with flammable devices

191
00:06:50,800 --> 00:06:52,319
strapped to their back and these

192
00:06:52,319 --> 00:06:53,440
actually come from

193
00:06:53,440 --> 00:06:56,160
medieval manuscripts like that image you

194
00:06:56,160 --> 00:06:57,360
see right there

195
00:06:57,360 --> 00:07:00,319
and there these cats are hell-bent on

196
00:07:00,319 --> 00:07:03,440
trying to set a castle or a city on fire

197
00:07:03,440 --> 00:07:06,319
in much the same fashion job rocket

198
00:07:06,319 --> 00:07:07,759
takes that inspiration

199
00:07:07,759 --> 00:07:12,160
we're looking for alternative pathways

200
00:07:12,160 --> 00:07:15,759
and and we we definitely find him

201
00:07:15,759 --> 00:07:17,599
so you might ask yourself well why do we

202
00:07:17,599 --> 00:07:19,520
need a job rocket why can't i just go

203
00:07:19,520 --> 00:07:21,599
inside ida pro or debugger and find

204
00:07:21,599 --> 00:07:22,560
everything on my own

205
00:07:22,560 --> 00:07:25,520
it's a good question well with rob i

206
00:07:25,520 --> 00:07:26,880
mean we we have tools

207
00:07:26,880 --> 00:07:29,199
and they they work great but one thing

208
00:07:29,199 --> 00:07:31,039
that they do is they look for the c3 the

209
00:07:31,039 --> 00:07:31,520
cb

210
00:07:31,520 --> 00:07:33,360
the op codes for return and a couple

211
00:07:33,360 --> 00:07:34,560
other variants

212
00:07:34,560 --> 00:07:37,759
and so it's not that many but with jop

213
00:07:37,759 --> 00:07:39,919
we're looking for 49 different op code

214
00:07:39,919 --> 00:07:40,960
combinations

215
00:07:40,960 --> 00:07:43,840
for many different forms and then once

216
00:07:43,840 --> 00:07:45,919
we find them we're going to disassemble

217
00:07:45,919 --> 00:07:49,120
and iterate create multiple disassembly

218
00:07:49,120 --> 00:07:49,759
chunks

219
00:07:49,759 --> 00:07:52,240
and we'll search for practical gadgets

220
00:07:52,240 --> 00:07:53,039
and one

221
00:07:53,039 --> 00:07:55,759
very interesting thing happens is op

222
00:07:55,759 --> 00:07:57,360
code splitting so this

223
00:07:57,360 --> 00:08:00,479
allows us to enrich the attack surface

224
00:08:00,479 --> 00:08:03,360
by finding unintended instructions that

225
00:08:03,360 --> 00:08:05,280
the programmer did not

226
00:08:05,280 --> 00:08:07,680
mean for it to be there but it doesn't

227
00:08:07,680 --> 00:08:09,759
matter because it still works so

228
00:08:09,759 --> 00:08:13,199
a couple examples right there and we can

229
00:08:13,199 --> 00:08:14,240
drastically

230
00:08:14,240 --> 00:08:16,960
increase the attack surface by doing op

231
00:08:16,960 --> 00:08:17,919
code splitting

232
00:08:17,919 --> 00:08:19,360
and of course this is something that's

233
00:08:19,360 --> 00:08:21,039
done automatically you don't need to to

234
00:08:21,039 --> 00:08:24,800
be aware of it it's just done for you

235
00:08:24,800 --> 00:08:28,160
so once we find a an op code like ff we

236
00:08:28,160 --> 00:08:29,520
then go search for

237
00:08:29,520 --> 00:08:31,840
what else it could lead to and if we

238
00:08:31,840 --> 00:08:32,958
find that

239
00:08:32,958 --> 00:08:35,440
then we perform classification

240
00:08:35,440 --> 00:08:36,479
classifying them

241
00:08:36,479 --> 00:08:39,200
into uh different categories based on

242
00:08:39,200 --> 00:08:40,399
operation

243
00:08:40,399 --> 00:08:42,640
and register affected so all this

244
00:08:42,640 --> 00:08:44,159
happens simultaneously

245
00:08:44,159 --> 00:08:46,720
we've optimized it so it's very fast

246
00:08:46,720 --> 00:08:47,279
it's not

247
00:08:47,279 --> 00:08:50,640
an extremely slow process

248
00:08:50,640 --> 00:08:53,920
uh now job rocket is a python uh program

249
00:08:53,920 --> 00:08:55,040
very modular

250
00:08:55,040 --> 00:08:57,200
but one thing i want to emphasize here

251
00:08:57,200 --> 00:08:58,240
is

252
00:08:58,240 --> 00:09:00,800
if you're gonna go after a target

253
00:09:00,800 --> 00:09:02,320
application

254
00:09:02,320 --> 00:09:04,399
have it installed and provide the

255
00:09:04,399 --> 00:09:05,839
absolute path

256
00:09:05,839 --> 00:09:08,240
is an input on a text file that way

257
00:09:08,240 --> 00:09:09,760
you're able to

258
00:09:09,760 --> 00:09:13,040
enumerate all of the the dlls and find

259
00:09:13,040 --> 00:09:13,760
gadgets

260
00:09:13,760 --> 00:09:16,080
for those otherwise if you do it just on

261
00:09:16,080 --> 00:09:18,160
the command line with the executable

262
00:09:18,160 --> 00:09:21,600
you won't find all of those dlls and

263
00:09:21,600 --> 00:09:23,360
if you're doing a very large program

264
00:09:23,360 --> 00:09:24,800
like 100 megabytes

265
00:09:24,800 --> 00:09:26,240
then you'll probably want to do the the

266
00:09:26,240 --> 00:09:30,000
64-bit python to avoid memory issues

267
00:09:30,000 --> 00:09:31,920
so let's see how it works with the menu

268
00:09:31,920 --> 00:09:33,920
system so first you want to indicate

269
00:09:33,920 --> 00:09:37,279
the registers of interest so simply r

270
00:09:37,279 --> 00:09:38,160
can do that

271
00:09:38,160 --> 00:09:40,080
and then g will go and scan for those

272
00:09:40,080 --> 00:09:41,279
selected registers

273
00:09:41,279 --> 00:09:43,839
or if you want all of them then you can

274
00:09:43,839 --> 00:09:44,880
just do the big g

275
00:09:44,880 --> 00:09:48,800
or z and then at the scope you can set

276
00:09:48,800 --> 00:09:50,959
if you want more than just the image

277
00:09:50,959 --> 00:09:53,279
executable you have that option

278
00:09:53,279 --> 00:09:55,360
and then you can specify mitigation that

279
00:09:55,360 --> 00:09:56,399
you want to avoid

280
00:09:56,399 --> 00:09:57,920
or to just simply enumerate the

281
00:09:57,920 --> 00:10:01,839
mitigations and then b will allow you to

282
00:10:01,839 --> 00:10:05,360
show or avoid particular bad characters

283
00:10:05,360 --> 00:10:09,040
j is the job chain sub sub menu which

284
00:10:09,040 --> 00:10:09,839
we'll see

285
00:10:09,839 --> 00:10:13,440
uh later on and then once you do the g

286
00:10:13,440 --> 00:10:15,120
option it's it's found and has

287
00:10:15,120 --> 00:10:16,560
classified everything

288
00:10:16,560 --> 00:10:18,079
so it's just simply a matter of printing

289
00:10:18,079 --> 00:10:20,560
your results and here we go the print

290
00:10:20,560 --> 00:10:21,839
sub menu so

291
00:10:21,839 --> 00:10:24,640
many different options and if you want

292
00:10:24,640 --> 00:10:26,160
everything just do the big p

293
00:10:26,160 --> 00:10:28,640
but you can also specify specific

294
00:10:28,640 --> 00:10:29,519
registers

295
00:10:29,519 --> 00:10:31,839
or operations here are some sample

296
00:10:31,839 --> 00:10:33,519
results for the icon

297
00:10:33,519 --> 00:10:34,880
making software we'll be looking at

298
00:10:34,880 --> 00:10:36,720
later on today

299
00:10:36,720 --> 00:10:40,079
and we can see we have a great number of

300
00:10:40,079 --> 00:10:41,120
results

301
00:10:41,120 --> 00:10:44,000
saved to a directory and each is named

302
00:10:44,000 --> 00:10:46,000
after the operation performed

303
00:10:46,000 --> 00:10:48,320
and the register affected and let's look

304
00:10:48,320 --> 00:10:50,480
at some of the results there

305
00:10:50,480 --> 00:10:53,680
we see that we have uh add ebx

306
00:10:53,680 --> 00:10:56,000
and so it has add as it had with carry

307
00:10:56,000 --> 00:11:01,519
and other various forms of ebx

308
00:11:01,519 --> 00:11:03,760
so we've learned all of this about jop

309
00:11:03,760 --> 00:11:04,640
how it works

310
00:11:04,640 --> 00:11:07,839
um but how do we actually want to

311
00:11:07,839 --> 00:11:10,160
apply this to making in a real world

312
00:11:10,160 --> 00:11:11,279
exploit that's

313
00:11:11,279 --> 00:11:13,839
the fun part of any exploitation

314
00:11:13,839 --> 00:11:15,680
technique is actually using it

315
00:11:15,680 --> 00:11:17,920
and that's a bit of a loaded question so

316
00:11:17,920 --> 00:11:19,040
part two is going to have

317
00:11:19,040 --> 00:11:22,160
a few different topics here first we're

318
00:11:22,160 --> 00:11:23,440
going to talk about selecting our

319
00:11:23,440 --> 00:11:24,880
dispatch registers

320
00:11:24,880 --> 00:11:27,040
and our dispatcher gadget we'll talk

321
00:11:27,040 --> 00:11:28,480
about job's purpose in an

322
00:11:28,480 --> 00:11:30,480
exploit we'll talk about different

323
00:11:30,480 --> 00:11:32,000
things job is able to do

324
00:11:32,000 --> 00:11:34,640
like avoiding bad bytes stack pivoting

325
00:11:34,640 --> 00:11:36,480
writing function parameters to memory

326
00:11:36,480 --> 00:11:38,320
performing function calls

327
00:11:38,320 --> 00:11:40,880
we'll also talk about job knops and then

328
00:11:40,880 --> 00:11:42,079
we'll

329
00:11:42,079 --> 00:11:45,040
show our demo exploit so on the first

330
00:11:45,040 --> 00:11:45,600
topic

331
00:11:45,600 --> 00:11:49,519
choosing dispatch registers um

332
00:11:49,519 --> 00:11:51,920
we want to choose a register for

333
00:11:51,920 --> 00:11:53,920
dispatcher gadget address and we don't

334
00:11:53,920 --> 00:11:56,480
actually want to we have to

335
00:11:56,480 --> 00:12:00,240
so with our dispatcher gadget address

336
00:12:00,240 --> 00:12:02,079
the register we choose will determine

337
00:12:02,079 --> 00:12:04,079
which functional gadgets we can use

338
00:12:04,079 --> 00:12:06,079
because our functional gadgets have to

339
00:12:06,079 --> 00:12:09,040
end in a jumper a call to this register

340
00:12:09,040 --> 00:12:12,560
we want to choose the register such that

341
00:12:12,560 --> 00:12:14,560
we have good functional gadgets to work

342
00:12:14,560 --> 00:12:16,480
with if we have a specific one that's

343
00:12:16,480 --> 00:12:17,519
very useful

344
00:12:17,519 --> 00:12:18,959
or if we have a lot of them that are

345
00:12:18,959 --> 00:12:21,120
very useful with little side effects we

346
00:12:21,120 --> 00:12:23,120
would prefer to choose that register if

347
00:12:23,120 --> 00:12:25,120
possible

348
00:12:25,120 --> 00:12:28,240
we can use gadgets from

349
00:12:28,240 --> 00:12:30,480
other registers that are a little bit

350
00:12:30,480 --> 00:12:32,000
more complicated like those on the

351
00:12:32,000 --> 00:12:32,720
bottom

352
00:12:32,720 --> 00:12:34,480
however if we can avoid some of those

353
00:12:34,480 --> 00:12:36,320
side effects or weird instructions we

354
00:12:36,320 --> 00:12:37,040
would probably

355
00:12:37,040 --> 00:12:40,160
prefer to do that

356
00:12:40,480 --> 00:12:44,959
also we need to choose a dispatch table

357
00:12:44,959 --> 00:12:48,639
register so our dispatcher gadget is

358
00:12:48,639 --> 00:12:50,480
pretty much going to tie us down as far

359
00:12:50,480 --> 00:12:52,000
as which register we can

360
00:12:52,000 --> 00:12:54,959
use for that if we have this dispatcher

361
00:12:54,959 --> 00:12:56,800
gadget on the top here where we're

362
00:12:56,800 --> 00:12:59,760
using a jump keyword pointer eax we

363
00:12:59,760 --> 00:13:01,600
pretty much just have to use eax as

364
00:13:01,600 --> 00:13:03,600
their dispatch table

365
00:13:03,600 --> 00:13:07,519
a register so we want to make sure this

366
00:13:07,519 --> 00:13:09,120
register is compatible with our

367
00:13:09,120 --> 00:13:11,120
functional gadgets that are available

368
00:13:11,120 --> 00:13:14,160
when possible but at the same time

369
00:13:14,160 --> 00:13:16,240
if we're making a bunch of compromises

370
00:13:16,240 --> 00:13:18,160
and using a dispatcher gadget like the

371
00:13:18,160 --> 00:13:18,639
one

372
00:13:18,639 --> 00:13:20,720
on the bottom where we have a lot of

373
00:13:20,720 --> 00:13:22,720
side effects then we're going to run

374
00:13:22,720 --> 00:13:24,160
into some troubles because

375
00:13:24,160 --> 00:13:26,079
each time we execute our dispatcher

376
00:13:26,079 --> 00:13:27,760
gadget we're gonna get those side

377
00:13:27,760 --> 00:13:30,079
effects

378
00:13:30,079 --> 00:13:32,320
on the topic of selecting a dispatcher

379
00:13:32,320 --> 00:13:34,320
you're talking earlier that modification

380
00:13:34,320 --> 00:13:35,920
to our dispatch table has to be

381
00:13:35,920 --> 00:13:36,959
predictable

382
00:13:36,959 --> 00:13:38,720
and what's more predictable than adding

383
00:13:38,720 --> 00:13:40,959
or subtracting the same value every time

384
00:13:40,959 --> 00:13:43,600
so these are nice dispatchers to use

385
00:13:43,600 --> 00:13:46,639
we're just gonna put all of our

386
00:13:46,639 --> 00:13:48,240
functional gadget addresses in our

387
00:13:48,240 --> 00:13:50,000
dispatch table in a row

388
00:13:50,000 --> 00:13:51,760
if we have more than four bytes being

389
00:13:51,760 --> 00:13:53,199
added or subtracted we'll

390
00:13:53,199 --> 00:13:56,800
add some padding and the only difference

391
00:13:56,800 --> 00:13:58,240
is if we're doing subtract we're just

392
00:13:58,240 --> 00:14:00,320
going to put them in a reverse order

393
00:14:00,320 --> 00:14:01,839
and we don't even have to worry about

394
00:14:01,839 --> 00:14:03,839
the mental overhead of putting them in

395
00:14:03,839 --> 00:14:05,440
reverse order manually because of

396
00:14:05,440 --> 00:14:07,360
something like python we can just do a

397
00:14:07,360 --> 00:14:07,760
list

398
00:14:07,760 --> 00:14:11,360
reverse on the list of all of our

399
00:14:11,360 --> 00:14:14,320
functional gadgets

400
00:14:14,399 --> 00:14:16,000
when we're selecting a dispatcher you

401
00:14:16,000 --> 00:14:17,760
want to keep in mind how much memory we

402
00:14:17,760 --> 00:14:19,760
have available for our payload so if we

403
00:14:19,760 --> 00:14:21,360
have a dispatcher that

404
00:14:21,360 --> 00:14:22,720
is going to be something like that one

405
00:14:22,720 --> 00:14:25,279
on the right where we have add edi

406
00:14:25,279 --> 00:14:28,240
hex 10 we have to have a lot of padding

407
00:14:28,240 --> 00:14:29,920
in between each functional gadget we're

408
00:14:29,920 --> 00:14:33,279
going to take up a lot of space

409
00:14:33,519 --> 00:14:36,720
so once we get our dispatch register set

410
00:14:36,720 --> 00:14:38,880
up what do we want to do with jop

411
00:14:38,880 --> 00:14:41,040
well with job we want to execute when

412
00:14:41,040 --> 00:14:42,399
api function calls

413
00:14:42,399 --> 00:14:44,320
and we're going to get around dep using

414
00:14:44,320 --> 00:14:45,920
those so

415
00:14:45,920 --> 00:14:47,600
the traditional method would be to use

416
00:14:47,600 --> 00:14:49,440
something like virtual protector virtual

417
00:14:49,440 --> 00:14:50,800
alec to make a

418
00:14:50,800 --> 00:14:53,519
memory region executable and then we

419
00:14:53,519 --> 00:14:56,240
would execute our shell code afterwards

420
00:14:56,240 --> 00:14:57,839
another method that we can do is shell

421
00:14:57,839 --> 00:14:59,199
codeless drop where we're not

422
00:14:59,199 --> 00:15:00,000
necessarily

423
00:15:00,000 --> 00:15:02,079
bypassing dep as much as we are just

424
00:15:02,079 --> 00:15:03,760
avoiding it all together

425
00:15:03,760 --> 00:15:05,360
we're actually using the function calls

426
00:15:05,360 --> 00:15:07,360
themselves to perform the actions that

427
00:15:07,360 --> 00:15:10,720
maybe our shell code normally would

428
00:15:10,720 --> 00:15:13,839
um with our win api function calls we

429
00:15:13,839 --> 00:15:15,680
have an example of the parameters that

430
00:15:15,680 --> 00:15:18,240
we would supply here for virtual protect

431
00:15:18,240 --> 00:15:22,000
and when we have the

432
00:15:22,000 --> 00:15:24,000
when we have values for parameters that

433
00:15:24,000 --> 00:15:25,680
we know at the time of writing or

434
00:15:25,680 --> 00:15:26,240
exploit

435
00:15:26,240 --> 00:15:28,240
things that can be hard coded we can

436
00:15:28,240 --> 00:15:29,279
just supply these

437
00:15:29,279 --> 00:15:32,480
into the payload themselves however with

438
00:15:32,480 --> 00:15:33,839
things like

439
00:15:33,839 --> 00:15:36,000
uh with things like parameters that have

440
00:15:36,000 --> 00:15:38,560
to be dynamically generated based off of

441
00:15:38,560 --> 00:15:40,079
memory locations

442
00:15:40,079 --> 00:15:44,240
or bad bytes we need to supply

443
00:15:44,240 --> 00:15:45,920
dummy variables that we can later

444
00:15:45,920 --> 00:15:48,160
overrate using chop

445
00:15:48,160 --> 00:15:50,399
so

446
00:15:51,279 --> 00:15:53,199
so talking about bad bytes is one of the

447
00:15:53,199 --> 00:15:55,360
reasons to supply dummy variables so bad

448
00:15:55,360 --> 00:15:57,040
bytes is the idea that if we have

449
00:15:57,040 --> 00:15:59,279
something like a string buffer

450
00:15:59,279 --> 00:16:02,639
when we start encountering a null byte

451
00:16:02,639 --> 00:16:05,600
or a carriage return or a line feed

452
00:16:05,600 --> 00:16:07,440
our string will stop being read in and

453
00:16:07,440 --> 00:16:08,880
then we can no longer use it as a

454
00:16:08,880 --> 00:16:10,240
payload because it's not getting read

455
00:16:10,240 --> 00:16:11,600
into memory

456
00:16:11,600 --> 00:16:13,920
so we can't supply those bytes in our

457
00:16:13,920 --> 00:16:14,639
payload

458
00:16:14,639 --> 00:16:16,399
so we need to get around that using job

459
00:16:16,399 --> 00:16:18,320
gadgets one way we can do this is with

460
00:16:18,320 --> 00:16:20,079
an xor gadget although there's plenty of

461
00:16:20,079 --> 00:16:21,519
other ways add subtract

462
00:16:21,519 --> 00:16:24,720
negate but xor is a good example

463
00:16:24,720 --> 00:16:27,440
so with xor we start by popping an xor

464
00:16:27,440 --> 00:16:28,160
key

465
00:16:28,160 --> 00:16:31,440
and then we pop the corresponding value

466
00:16:31,440 --> 00:16:32,639
into another register

467
00:16:32,639 --> 00:16:34,160
again that doesn't have to be a pop it

468
00:16:34,160 --> 00:16:36,240
just has to get loaded into the register

469
00:16:36,240 --> 00:16:37,600
somehow

470
00:16:37,600 --> 00:16:39,279
however you are able to do it the

471
00:16:39,279 --> 00:16:40,800
gadgets you have available

472
00:16:40,800 --> 00:16:43,199
and then once we perform that xor we're

473
00:16:43,199 --> 00:16:45,120
going to load that final value

474
00:16:45,120 --> 00:16:48,240
into a register and we haven't actually

475
00:16:48,240 --> 00:16:50,000
supplied that bad byte value in our

476
00:16:50,000 --> 00:16:52,480
payload at all

477
00:16:52,480 --> 00:16:54,880
another place bad bytes can show up is

478
00:16:54,880 --> 00:16:57,360
in functional gadget addresses

479
00:16:57,360 --> 00:16:59,040
so the addresses of the functional

480
00:16:59,040 --> 00:17:00,880
gadgets themselves might have a bad byte

481
00:17:00,880 --> 00:17:02,560
like these stack pivots

482
00:17:02,560 --> 00:17:04,240
on the right have a null byte at the

483
00:17:04,240 --> 00:17:06,400
beginning but if we want to still use

484
00:17:06,400 --> 00:17:07,839
them what we can do is load their

485
00:17:07,839 --> 00:17:10,000
address into a register and then jump to

486
00:17:10,000 --> 00:17:11,839
that register rather than putting them

487
00:17:11,839 --> 00:17:15,520
in the dispatch table themselves

488
00:17:16,640 --> 00:17:18,319
one other thing we need to do often with

489
00:17:18,319 --> 00:17:19,919
 is stack pivoting

490
00:17:19,919 --> 00:17:22,959
so with stack pivoting um we need this

491
00:17:22,959 --> 00:17:24,240
for all sorts of things

492
00:17:24,240 --> 00:17:26,959
popping values um getting the function

493
00:17:26,959 --> 00:17:28,880
parameters to be at the correct location

494
00:17:28,880 --> 00:17:31,280
making sure our overwrites happen at the

495
00:17:31,280 --> 00:17:33,039
same spot it's used for all sorts of

496
00:17:33,039 --> 00:17:34,080
things so

497
00:17:34,080 --> 00:17:37,039
stock pivoting forward is fairly easy

498
00:17:37,039 --> 00:17:39,039
with chop where we need just pop

499
00:17:39,039 --> 00:17:39,840
instructions

500
00:17:39,840 --> 00:17:42,480
we'll cut it each pop instruction will

501
00:17:42,480 --> 00:17:44,160
increment esp by four

502
00:17:44,160 --> 00:17:46,559
so here we have two pop gadgets moving

503
00:17:46,559 --> 00:17:47,200
esp

504
00:17:47,200 --> 00:17:50,400
eight bytes however

505
00:17:50,400 --> 00:17:52,080
moving backwards is a little bit more

506
00:17:52,080 --> 00:17:54,480
difficult the gadgets that are suitable

507
00:17:54,480 --> 00:17:56,559
are harder to find and it is true that

508
00:17:56,559 --> 00:17:58,880
the push instruction does subtract four

509
00:17:58,880 --> 00:18:01,679
from esp however we're also overriding

510
00:18:01,679 --> 00:18:04,160
values on the way as well which might

511
00:18:04,160 --> 00:18:05,360
not always be

512
00:18:05,360 --> 00:18:07,760
so useful for us and might actually

513
00:18:07,760 --> 00:18:09,360
cause problems

514
00:18:09,360 --> 00:18:11,760
although the push instruction can be

515
00:18:11,760 --> 00:18:13,039
used to our advantage

516
00:18:13,039 --> 00:18:15,120
as well even though it's not so great

517
00:18:15,120 --> 00:18:17,200
for stack pivots we can still use it to

518
00:18:17,200 --> 00:18:19,280
overwrite parameter values

519
00:18:19,280 --> 00:18:21,520
so if we have dummy values that we're

520
00:18:21,520 --> 00:18:22,400
using

521
00:18:22,400 --> 00:18:25,520
to uh hold the place of a value that

522
00:18:25,520 --> 00:18:27,120
needs to be dynamically generated

523
00:18:27,120 --> 00:18:28,000
whether that be

524
00:18:28,000 --> 00:18:30,320
for bad bytes or some other reason we

525
00:18:30,320 --> 00:18:32,960
can load that value into a register

526
00:18:32,960 --> 00:18:34,880
stack pivot four bytes above the

527
00:18:34,880 --> 00:18:36,640
location we want to overwrite because

528
00:18:36,640 --> 00:18:37,360
esp

529
00:18:37,360 --> 00:18:39,440
or push is going to overwrite to esp

530
00:18:39,440 --> 00:18:40,880
minus four

531
00:18:40,880 --> 00:18:44,160
and then we will push

532
00:18:44,160 --> 00:18:46,799
our value onto the stack there and now

533
00:18:46,799 --> 00:18:49,039
we have one of our functional parameter

534
00:18:49,039 --> 00:18:50,799
one of our functional parameters we have

535
00:18:50,799 --> 00:18:52,080
one of our

536
00:18:52,080 --> 00:18:53,840
virtual protect parameters that was a

537
00:18:53,840 --> 00:18:55,520
placeholder written with the actual

538
00:18:55,520 --> 00:18:57,120
value there

539
00:18:57,120 --> 00:18:59,200
and if we want to do a lot of pushes in

540
00:18:59,200 --> 00:19:01,280
a row like this we can set up our stack

541
00:19:01,280 --> 00:19:02,799
in a special way here

542
00:19:02,799 --> 00:19:04,880
where we have the same distance between

543
00:19:04,880 --> 00:19:07,919
each encoded parameter that we're

544
00:19:07,919 --> 00:19:09,840
dealing with and then our dummy

545
00:19:09,840 --> 00:19:12,080
variables the distances between

546
00:19:12,080 --> 00:19:15,600
each pair there are the same so that way

547
00:19:15,600 --> 00:19:17,679
we can keep on using the same distance

548
00:19:17,679 --> 00:19:18,960
stack pivots

549
00:19:18,960 --> 00:19:21,760
each time so for an example of that we

550
00:19:21,760 --> 00:19:22,559
have

551
00:19:22,559 --> 00:19:25,440
a pop eax here popping the first encoded

552
00:19:25,440 --> 00:19:26,960
parameter off the stack

553
00:19:26,960 --> 00:19:29,200
we're going to avoid bad bytes by using

554
00:19:29,200 --> 00:19:31,280
an xor and that's why it was encoded in

555
00:19:31,280 --> 00:19:32,720
the first place

556
00:19:32,720 --> 00:19:36,000
we will pivot esp using three pop evx

557
00:19:36,000 --> 00:19:36,880
gadgets

558
00:19:36,880 --> 00:19:38,960
and then we overwrite our placeholder in

559
00:19:38,960 --> 00:19:40,799
memory

560
00:19:40,799 --> 00:19:42,400
afterwards we're going to pivot esp

561
00:19:42,400 --> 00:19:44,400
backwards and then we can keep on

562
00:19:44,400 --> 00:19:46,240
repeating from step one

563
00:19:46,240 --> 00:19:48,000
just doing that same process over and

564
00:19:48,000 --> 00:19:49,840
over using the exact same gadgets we

565
00:19:49,840 --> 00:19:51,280
don't have to search for any different

566
00:19:51,280 --> 00:19:53,200
stack pivot gadgets or anything

567
00:19:53,200 --> 00:19:55,760
because we've set up our stack in this

568
00:19:55,760 --> 00:19:57,360
way here

569
00:19:57,360 --> 00:20:01,360
so moving on from push we have another

570
00:20:01,360 --> 00:20:03,120
way to operate dummy values which is

571
00:20:03,120 --> 00:20:03,919
with the move

572
00:20:03,919 --> 00:20:06,000
dealer pointer gadget and these are less

573
00:20:06,000 --> 00:20:07,280
commonly found

574
00:20:07,280 --> 00:20:09,120
and we can also use different types of

575
00:20:09,120 --> 00:20:10,480
gadgets so

576
00:20:10,480 --> 00:20:12,480
move dealer pointer is a one but we can

577
00:20:12,480 --> 00:20:13,679
also use things like

578
00:20:13,679 --> 00:20:16,240
add d word pointer or subtract or things

579
00:20:16,240 --> 00:20:17,360
like that as well

580
00:20:17,360 --> 00:20:18,799
but move is pretty good one to

581
00:20:18,799 --> 00:20:21,440
demonstrate here we are going to have to

582
00:20:21,440 --> 00:20:22,080
use

583
00:20:22,080 --> 00:20:24,320
two registers to set aside for this

584
00:20:24,320 --> 00:20:26,240
gadget which might be a bit of a problem

585
00:20:26,240 --> 00:20:28,080
with the job sometimes because we have

586
00:20:28,080 --> 00:20:28,400
two

587
00:20:28,400 --> 00:20:32,000
already set aside for our control flow

588
00:20:32,000 --> 00:20:34,080
but with move keyword pointer our first

589
00:20:34,080 --> 00:20:35,679
register is going to hold the address

590
00:20:35,679 --> 00:20:37,120
that we want to write to

591
00:20:37,120 --> 00:20:39,679
and our second register is going to hold

592
00:20:39,679 --> 00:20:40,720
the value

593
00:20:40,720 --> 00:20:43,760
and once we execute this gadget we will

594
00:20:43,760 --> 00:20:46,720
overwrite our second parameter that was

595
00:20:46,720 --> 00:20:48,000
a placeholder

596
00:20:48,000 --> 00:20:51,039
in our example virtual protect here

597
00:20:51,039 --> 00:20:52,400
one thing to note here is that we don't

598
00:20:52,400 --> 00:20:54,159
need any stack pivots at all

599
00:20:54,159 --> 00:20:57,440
which is nice once we have all of our

600
00:20:57,440 --> 00:20:59,120
parameters set up

601
00:20:59,120 --> 00:21:03,200
in our function here we can pivot esp to

602
00:21:03,200 --> 00:21:04,400
the beginning of them

603
00:21:04,400 --> 00:21:06,400
before our function call and then to

604
00:21:06,400 --> 00:21:07,760
call that function we can grab the

605
00:21:07,760 --> 00:21:09,520
function pointer and then de-reference

606
00:21:09,520 --> 00:21:10,880
it there are several different ways we

607
00:21:10,880 --> 00:21:11,600
can do that

608
00:21:11,600 --> 00:21:13,360
we have a couple of examples there the

609
00:21:13,360 --> 00:21:15,919
most simple straightforward one would

610
00:21:15,919 --> 00:21:16,880
probably just to be

611
00:21:16,880 --> 00:21:19,520
the top gadget there where we just do a

612
00:21:19,520 --> 00:21:21,039
jump dwarf pointer

613
00:21:21,039 --> 00:21:25,120
eax one last thing before we go into our

614
00:21:25,120 --> 00:21:25,840
demo

615
00:21:25,840 --> 00:21:27,919
as we might not always know when we're

616
00:21:27,919 --> 00:21:30,159
setting up our job exploit where

617
00:21:30,159 --> 00:21:32,720
exactly the dispatcher gadget or not the

618
00:21:32,720 --> 00:21:34,480
dispatcher gadget where exactly the

619
00:21:34,480 --> 00:21:36,559
dispatch table is gonna be

620
00:21:36,559 --> 00:21:38,480
so if we don't know the exact location

621
00:21:38,480 --> 00:21:40,080
but we have a pretty good idea we can

622
00:21:40,080 --> 00:21:41,840
kind of guess the location

623
00:21:41,840 --> 00:21:43,520
and we're going to use chop knobs in

624
00:21:43,520 --> 00:21:45,360
order to pad it out

625
00:21:45,360 --> 00:21:46,960
the dispatch table so we're going to

626
00:21:46,960 --> 00:21:48,640
make our dispatch table very large with

627
00:21:48,640 --> 00:21:50,400
a bunch of job knobs

628
00:21:50,400 --> 00:21:53,360
however these instructions are just an

629
00:21:53,360 --> 00:21:54,000
address

630
00:21:54,000 --> 00:21:56,000
to an instruction that's just going to

631
00:21:56,000 --> 00:21:58,159
jump back to the dispatcher gadget

632
00:21:58,159 --> 00:22:00,159
so we're gonna perform no operation with

633
00:22:00,159 --> 00:22:02,559
each one and just keep on jumping down

634
00:22:02,559 --> 00:22:04,640
the line if we guess anywhere in there

635
00:22:04,640 --> 00:22:06,559
until we get to our actual dispatch

636
00:22:06,559 --> 00:22:09,039
table one thing to keep in mind is that

637
00:22:09,039 --> 00:22:09,760
this is an

638
00:22:09,760 --> 00:22:12,799
address it's not like a

639
00:22:12,799 --> 00:22:14,640
um shell code map where it's just an op

640
00:22:14,640 --> 00:22:16,320
code so we do have to guess the

641
00:22:16,320 --> 00:22:18,559
alignment correctly there

642
00:22:18,559 --> 00:22:19,840
if we don't guess the alignment

643
00:22:19,840 --> 00:22:21,440
correctly we're not going to get the

644
00:22:21,440 --> 00:22:22,880
correct address and we're going to

645
00:22:22,880 --> 00:22:25,760
probably get an access violation

646
00:22:25,760 --> 00:22:27,200
also if we have padding with our

647
00:22:27,200 --> 00:22:29,520
dispatcher gadget we need to specialize

648
00:22:29,520 --> 00:22:31,039
our padding because we can have multiple

649
00:22:31,039 --> 00:22:32,799
entry points to our dispatch table

650
00:22:32,799 --> 00:22:35,039
depending on which knob we guessed so

651
00:22:35,039 --> 00:22:37,120
here we have the top drop knot

652
00:22:37,120 --> 00:22:39,919
the top drop knob which is uh kind of

653
00:22:39,919 --> 00:22:41,200
fun to say

654
00:22:41,200 --> 00:22:44,320
uh but we we guess our location of the

655
00:22:44,320 --> 00:22:46,000
top drop knob

656
00:22:46,000 --> 00:22:48,640
and then um we enter our dispatch table

657
00:22:48,640 --> 00:22:49,440
at one point

658
00:22:49,440 --> 00:22:52,400
so here top one enter at that top point

659
00:22:52,400 --> 00:22:54,320
however if we guess the second one

660
00:22:54,320 --> 00:22:56,080
we'll enter our dispatch table at the

661
00:22:56,080 --> 00:22:58,240
second location so we need to specialize

662
00:22:58,240 --> 00:22:59,120
our padding

663
00:22:59,120 --> 00:23:01,280
so that we can account for that and one

664
00:23:01,280 --> 00:23:03,120
easy way to do that is just to keep on

665
00:23:03,120 --> 00:23:05,520
repeating that previous gadget address

666
00:23:05,520 --> 00:23:07,440
over and over until we get to our next

667
00:23:07,440 --> 00:23:09,840
gadget

668
00:23:09,840 --> 00:23:12,880
so we'll take a look at a demo of an

669
00:23:12,880 --> 00:23:13,840
actual exploit

670
00:23:13,840 --> 00:23:16,880
used with drop so we'll see some stack

671
00:23:16,880 --> 00:23:17,600
pivoting

672
00:23:17,600 --> 00:23:19,200
or using drop i mean we'll see some

673
00:23:19,200 --> 00:23:20,880
stack pivoting we'll see some avoiding

674
00:23:20,880 --> 00:23:22,240
bad bites we'll see some writing

675
00:23:22,240 --> 00:23:24,720
parameter values but we won't go

676
00:23:24,720 --> 00:23:26,559
too deep into the weeds here we'll just

677
00:23:26,559 --> 00:23:29,440
show you the big ideas

678
00:23:29,440 --> 00:23:31,200
so we can see with our exploit here

679
00:23:31,200 --> 00:23:34,240
we're going to start with a stack pivot

680
00:23:34,240 --> 00:23:36,799
we are going to do a move esp to start

681
00:23:36,799 --> 00:23:38,240
it out and then we're going to

682
00:23:38,240 --> 00:23:42,000
add an 800 value two times

683
00:23:42,000 --> 00:23:45,440
so we're going to add 800 twice

684
00:23:45,440 --> 00:23:48,240
after that we're going to start xoring

685
00:23:48,240 --> 00:23:50,159
bad bytes out so that we can push

686
00:23:50,159 --> 00:23:52,159
function parameters so we're going to

687
00:23:52,159 --> 00:23:53,200
see an

688
00:23:53,200 --> 00:23:55,200
xor and we're going to see two virtual

689
00:23:55,200 --> 00:23:57,279
protect parameters being pushed here

690
00:23:57,279 --> 00:24:01,039
so here we can see xor ecx

691
00:24:01,039 --> 00:24:04,799
to get a bad byte value into ecx

692
00:24:04,799 --> 00:24:07,279
and then later we're going to push that

693
00:24:07,279 --> 00:24:08,640
along with eax

694
00:24:08,640 --> 00:24:12,080
as two of our functional i keep saying

695
00:24:12,080 --> 00:24:13,279
functional

696
00:24:13,279 --> 00:24:18,000
two of our function parameters here

697
00:24:18,000 --> 00:24:19,919
afterwards you can see step three here

698
00:24:19,919 --> 00:24:21,679
is keep on pushing parameters we're

699
00:24:21,679 --> 00:24:22,880
going to keep on doing what we were

700
00:24:22,880 --> 00:24:24,080
doing

701
00:24:24,080 --> 00:24:26,640
um xoring bad byte values and pushing

702
00:24:26,640 --> 00:24:28,400
more parameters to set up our virtual

703
00:24:28,400 --> 00:24:30,480
protect function call

704
00:24:30,480 --> 00:24:32,880
so we have two more pushes here and now

705
00:24:32,880 --> 00:24:36,159
a virtual protect is almost ready to go

706
00:24:36,159 --> 00:24:40,640
um so at this point we're going to stack

707
00:24:40,640 --> 00:24:41,120
pivot

708
00:24:41,120 --> 00:24:43,120
on over to the start of our virtual

709
00:24:43,120 --> 00:24:44,400
protect parameters

710
00:24:44,400 --> 00:24:46,240
we're going to grab that address to

711
00:24:46,240 --> 00:24:48,080
virtual protect the pointer

712
00:24:48,080 --> 00:24:49,760
and we're going to de-reference it to

713
00:24:49,760 --> 00:24:51,200
get the actual address to virtual

714
00:24:51,200 --> 00:24:53,200
protect

715
00:24:53,200 --> 00:24:55,520
now once we have that dereference we can

716
00:24:55,520 --> 00:24:57,120
call the function we can see our

717
00:24:57,120 --> 00:24:58,720
parameters in the bottom right and once

718
00:24:58,720 --> 00:25:00,960
we return we'll return to our shell code

719
00:25:00,960 --> 00:25:02,720
showing a proof of concept just opening

720
00:25:02,720 --> 00:25:04,240
notepad but

721
00:25:04,240 --> 00:25:06,559
that will show that we can run shellcode

722
00:25:06,559 --> 00:25:08,080
using chop

723
00:25:08,080 --> 00:25:10,559
bypass dep and that's really cool

724
00:25:10,559 --> 00:25:12,720
because that's rare

725
00:25:12,720 --> 00:25:14,559
in the wild so we don't see that often

726
00:25:14,559 --> 00:25:16,400
in the wild and

727
00:25:16,400 --> 00:25:18,880
that's a cool thing to do our next topic

728
00:25:18,880 --> 00:25:20,640
deals with the automation

729
00:25:20,640 --> 00:25:23,440
of job chain generation and when you

730
00:25:23,440 --> 00:25:24,880
approach something like this it really

731
00:25:24,880 --> 00:25:27,279
makes sense to reduce it to

732
00:25:27,279 --> 00:25:30,640
a recipe with return-oriented

733
00:25:30,640 --> 00:25:31,520
programming

734
00:25:31,520 --> 00:25:33,840
we create that recipe centered around

735
00:25:33,840 --> 00:25:34,799
push ad

736
00:25:34,799 --> 00:25:36,640
so with push ad we populate all the

737
00:25:36,640 --> 00:25:39,120
registers with specific values such that

738
00:25:39,120 --> 00:25:39,760
when we

739
00:25:39,760 --> 00:25:43,279
perform push ad the stack is all set up

740
00:25:43,279 --> 00:25:44,880
for or when api call

741
00:25:44,880 --> 00:25:47,840
and it makes the win api call is is part

742
00:25:47,840 --> 00:25:50,159
of that technique

743
00:25:50,159 --> 00:25:53,200
now with jop that's just not possible

744
00:25:53,200 --> 00:25:54,400
because

745
00:25:54,400 --> 00:25:58,080
for one we can't use push ad and also

746
00:25:58,080 --> 00:26:00,799
with rop every instruc every gadget is

747
00:26:00,799 --> 00:26:02,559
going to end in a return

748
00:26:02,559 --> 00:26:04,960
but with jop it's going to end in a jump

749
00:26:04,960 --> 00:26:06,080
or a call

750
00:26:06,080 --> 00:26:08,799
to one of several different registers

751
00:26:08,799 --> 00:26:09,600
and keep in mind

752
00:26:09,600 --> 00:26:12,640
what this is is it's a functional gadget

753
00:26:12,640 --> 00:26:16,080
jumping to the dispatcher

754
00:26:16,080 --> 00:26:18,559
and so we'll have certain registers set

755
00:26:18,559 --> 00:26:20,880
aside for those purposes

756
00:26:20,880 --> 00:26:22,720
and those registers need to remain

757
00:26:22,720 --> 00:26:25,039
deconflicted and the other registers

758
00:26:25,039 --> 00:26:27,360
we can use them to to do things like

759
00:26:27,360 --> 00:26:28,159
setting up

760
00:26:28,159 --> 00:26:31,120
our stack parameters so it really seems

761
00:26:31,120 --> 00:26:31,600
that

762
00:26:31,600 --> 00:26:34,080
all of this would maybe make uh

763
00:26:34,080 --> 00:26:36,400
automation infeasible because all of

764
00:26:36,400 --> 00:26:36,880
these

765
00:26:36,880 --> 00:26:39,360
different registers could be used for

766
00:26:39,360 --> 00:26:41,120
different purposes and how do you keep

767
00:26:41,120 --> 00:26:41,760
track of

768
00:26:41,760 --> 00:26:45,279
all of that it sounds like too much

769
00:26:45,279 --> 00:26:46,240
except

770
00:26:46,240 --> 00:26:49,279
well maybe it's not because it really

771
00:26:49,279 --> 00:26:50,880
begs the question then can you

772
00:26:50,880 --> 00:26:53,440
can you simplify job do you have to

773
00:26:53,440 --> 00:26:54,240
embrace

774
00:26:54,240 --> 00:26:56,559
the kind of manual technique that that

775
00:26:56,559 --> 00:26:57,840
austin showed you

776
00:26:57,840 --> 00:27:01,120
or is is there a simple path

777
00:27:01,120 --> 00:27:03,279
that could be an alternative and there

778
00:27:03,279 --> 00:27:04,400
is

779
00:27:04,400 --> 00:27:07,919
and it's utilizing a series of multiple

780
00:27:07,919 --> 00:27:09,279
stack pivots

781
00:27:09,279 --> 00:27:11,279
so let's check this out we have a buffer

782
00:27:11,279 --> 00:27:13,039
overflow we have an sch overwrite

783
00:27:13,039 --> 00:27:15,600
whatever the case may be and at that

784
00:27:15,600 --> 00:27:17,760
particular moment esp points to a

785
00:27:17,760 --> 00:27:18,880
certain value

786
00:27:18,880 --> 00:27:21,360
so it's one two three four uh right

787
00:27:21,360 --> 00:27:23,360
there in our example

788
00:27:23,360 --> 00:27:26,559
but our stack parameters are quite a

789
00:27:26,559 --> 00:27:29,760
distance away almost five thousand bytes

790
00:27:29,760 --> 00:27:32,000
and what we can do is we can precisely

791
00:27:32,000 --> 00:27:33,200
calculate that amount

792
00:27:33,200 --> 00:27:36,640
and do a series of stat pivots and

793
00:27:36,640 --> 00:27:40,399
look lo and behold we have reached it

794
00:27:40,399 --> 00:27:43,360
so by precisely figuring where out that

795
00:27:43,360 --> 00:27:44,559
location

796
00:27:44,559 --> 00:27:46,840
we can adjust our padding in different

797
00:27:46,840 --> 00:27:48,080
stack

798
00:27:48,080 --> 00:27:52,320
uh pivots to enable us to to get there

799
00:27:52,320 --> 00:27:55,440
so here's another example

800
00:27:55,440 --> 00:27:57,679
a little bit more technical detail so we

801
00:27:57,679 --> 00:28:00,159
have various uh ad esps

802
00:28:00,159 --> 00:28:03,279
and collectively they allow us to get to

803
00:28:03,279 --> 00:28:08,480
almost um about 1320 bytes

804
00:28:08,480 --> 00:28:12,240
and then next we pop into eax

805
00:28:12,240 --> 00:28:14,799
a pointer to virtual protect which job

806
00:28:14,799 --> 00:28:16,559
rocket finds for you

807
00:28:16,559 --> 00:28:18,960
and then we make a dereference call over

808
00:28:18,960 --> 00:28:21,360
there now this is something that the job

809
00:28:21,360 --> 00:28:23,279
rocket it takes care of all of this and

810
00:28:23,279 --> 00:28:25,520
it makes sure that all the registers are

811
00:28:25,520 --> 00:28:30,240
rd conflicted so specifically how this

812
00:28:30,240 --> 00:28:32,960
job rocket will do this is it'll try to

813
00:28:32,960 --> 00:28:34,240
set up

814
00:28:34,240 --> 00:28:37,520
registers uh for the dispatch table and

815
00:28:37,520 --> 00:28:40,159
also for the dispatcher gadget and we

816
00:28:40,159 --> 00:28:41,919
start things off with rob just because

817
00:28:41,919 --> 00:28:44,000
from an automation standpoint

818
00:28:44,000 --> 00:28:45,919
there's pretty much a guarantee that we

819
00:28:45,919 --> 00:28:47,200
can do that for

820
00:28:47,200 --> 00:28:50,159
every functional gadget you know a

821
00:28:50,159 --> 00:28:51,600
functional gadget ending

822
00:28:51,600 --> 00:28:54,559
in a particular register and what we

823
00:28:54,559 --> 00:28:56,799
want to do with drop rocket is enumerate

824
00:28:56,799 --> 00:28:59,919
each and every possibility so functional

825
00:28:59,919 --> 00:29:01,679
gadgets ending in eax

826
00:29:01,679 --> 00:29:06,240
and ebx ecx edx so on and so forth

827
00:29:06,240 --> 00:29:07,760
because depending on the registers

828
00:29:07,760 --> 00:29:09,679
available some of them may work

829
00:29:09,679 --> 00:29:11,039
some of them there just may not be

830
00:29:11,039 --> 00:29:13,440
enough gadgets so we look and we try

831
00:29:13,440 --> 00:29:16,880
all possibilities so it really

832
00:29:16,880 --> 00:29:19,600
works on the premise that functional

833
00:29:19,600 --> 00:29:21,200
gadgets are going to end

834
00:29:21,200 --> 00:29:25,039
in the same uh register now

835
00:29:25,039 --> 00:29:27,679
of course manually you can switch that

836
00:29:27,679 --> 00:29:28,799
if you want to

837
00:29:28,799 --> 00:29:30,720
but from an automation standpoint just a

838
00:29:30,720 --> 00:29:32,720
general best practice if you can stick

839
00:29:32,720 --> 00:29:33,200
to it

840
00:29:33,200 --> 00:29:35,200
to one register it's going to make your

841
00:29:35,200 --> 00:29:38,240
life a little bit easier

842
00:29:38,799 --> 00:29:41,039
now what job rocket will do is for each

843
00:29:41,039 --> 00:29:42,480
functional gadget and in

844
00:29:42,480 --> 00:29:43,840
a register it'll try to find five

845
00:29:43,840 --> 00:29:46,320
different unique chains so

846
00:29:46,320 --> 00:29:49,360
if for some reason one doesn't work okay

847
00:29:49,360 --> 00:29:51,360
then we have some other possibilities

848
00:29:51,360 --> 00:29:54,159
that we can consider so check it out we

849
00:29:54,159 --> 00:29:55,679
go to the job chain

850
00:29:55,679 --> 00:29:57,440
sub menu uh the first thing you want to

851
00:29:57,440 --> 00:29:58,799
do is hit s and that will get

852
00:29:58,799 --> 00:30:01,039
do the scanning for the job gadgets and

853
00:30:01,039 --> 00:30:03,679
also rob gadgets too to set it up with

854
00:30:03,679 --> 00:30:04,720
pop

855
00:30:04,720 --> 00:30:07,919
we can specify the desired stack pivot

856
00:30:07,919 --> 00:30:08,880
amount

857
00:30:08,880 --> 00:30:11,279
and this is important because if let's

858
00:30:11,279 --> 00:30:11,919
say

859
00:30:11,919 --> 00:30:15,840
uh functional gadgets ending in ecx

860
00:30:15,840 --> 00:30:18,720
there may only be a large stack pivot

861
00:30:18,720 --> 00:30:20,799
but if you're searching for only a

862
00:30:20,799 --> 00:30:23,039
small stack pivot amount then it may not

863
00:30:23,039 --> 00:30:24,080
find anything

864
00:30:24,080 --> 00:30:27,200
so try to assess and determine the

865
00:30:27,200 --> 00:30:29,200
desired minimum and maximum and keep in

866
00:30:29,200 --> 00:30:31,520
mind uh it doesn't need to be exact

867
00:30:31,520 --> 00:30:33,760
because we can make up the difference

868
00:30:33,760 --> 00:30:36,559
with padding just make sure you get the

869
00:30:36,559 --> 00:30:37,760
exact

870
00:30:37,760 --> 00:30:40,159
absolute minimum that you need and then

871
00:30:40,159 --> 00:30:41,279
from there g will

872
00:30:41,279 --> 00:30:44,240
go and get the gadgets you can also if

873
00:30:44,240 --> 00:30:45,279
you want to

874
00:30:45,279 --> 00:30:47,919
you can change the number of job chains

875
00:30:47,919 --> 00:30:49,600
that are generated per register

876
00:30:49,600 --> 00:30:50,720
so if you want more or less

877
00:30:50,720 --> 00:30:52,720
possibilities hey that's

878
00:30:52,720 --> 00:30:57,360
uh an option so this is the same exact

879
00:30:57,360 --> 00:31:00,080
uh thing that austin did it earlier from

880
00:31:00,080 --> 00:31:01,440
his manual exploit

881
00:31:01,440 --> 00:31:04,640
and we've gone through done it with uh

882
00:31:04,640 --> 00:31:06,640
jop rocket and we have a chain for

883
00:31:06,640 --> 00:31:08,640
virtual alec it's created

884
00:31:08,640 --> 00:31:11,919
uh one that has everything we need to

885
00:31:11,919 --> 00:31:15,679
to utilize the stack pivot technique

886
00:31:15,679 --> 00:31:18,240
and here's one for virtual protect we'll

887
00:31:18,240 --> 00:31:19,840
look at this more closely in

888
00:31:19,840 --> 00:31:23,440
a second but the the great thing about

889
00:31:23,440 --> 00:31:23,840
this

890
00:31:23,840 --> 00:31:25,840
is if we introduce the actual

891
00:31:25,840 --> 00:31:26,960
vulnerability

892
00:31:26,960 --> 00:31:30,559
part of the code then this pretty much

893
00:31:30,559 --> 00:31:33,600
works so everything that austin did

894
00:31:33,600 --> 00:31:36,559
could be reduced to doing it via job

895
00:31:36,559 --> 00:31:37,440
rocket the

896
00:31:37,440 --> 00:31:39,519
job chain generation we'll see that

897
00:31:39,519 --> 00:31:42,000
shortly with a live demo

898
00:31:42,000 --> 00:31:43,600
so let's break it down so we'll kick

899
00:31:43,600 --> 00:31:45,039
things off with some rop

900
00:31:45,039 --> 00:31:47,200
we'll load our dispatcher gadget load

901
00:31:47,200 --> 00:31:48,640
our dispatch table

902
00:31:48,640 --> 00:31:51,279
and then we'll actually start the job by

903
00:31:51,279 --> 00:31:53,039
jumping to edx

904
00:31:53,039 --> 00:31:54,640
and then from here it's just a series of

905
00:31:54,640 --> 00:31:56,720
stack pivots 8.94

906
00:31:56,720 --> 00:31:59,919
we do it again and now we're going to

907
00:31:59,919 --> 00:32:01,760
load eax

908
00:32:01,760 --> 00:32:05,200
with a pointer to virtual protect

909
00:32:05,200 --> 00:32:07,360
and then we're going to de-reference

910
00:32:07,360 --> 00:32:08,240
that

911
00:32:08,240 --> 00:32:10,080
and then from there that's when we

912
00:32:10,080 --> 00:32:11,840
actually make the call to virtual

913
00:32:11,840 --> 00:32:12,640
protect

914
00:32:12,640 --> 00:32:14,640
and so we want to then have all of our

915
00:32:14,640 --> 00:32:15,840
stack

916
00:32:15,840 --> 00:32:19,360
parameters which we do and

917
00:32:19,360 --> 00:32:21,360
if everything is set up and there's no

918
00:32:21,360 --> 00:32:23,039
little special issues you need to

919
00:32:23,039 --> 00:32:24,320
address

920
00:32:24,320 --> 00:32:27,840
then you you have a good exploit

921
00:32:27,840 --> 00:32:29,519
drop rocket also provides some other

922
00:32:29,519 --> 00:32:32,240
good starting points for you there

923
00:32:32,240 --> 00:32:34,399
and so without further ado then let's

924
00:32:34,399 --> 00:32:36,559
see this actual exploit

925
00:32:36,559 --> 00:32:40,559
live in action okay so let's do a stack

926
00:32:40,559 --> 00:32:43,600
pivot of 894

927
00:32:43,600 --> 00:32:46,559
and get back to our dispatcher gadget

928
00:32:46,559 --> 00:32:48,960
and then we're adding 12 to edi

929
00:32:48,960 --> 00:32:51,760
and another stack pivot of 894 and then

930
00:32:51,760 --> 00:32:54,480
back to our dispatcher adding 12 to edi

931
00:32:54,480 --> 00:32:56,240
and now we're going to pop into eax a

932
00:32:56,240 --> 00:32:58,399
pointer to virtual protect

933
00:32:58,399 --> 00:33:00,159
back to our dispatcher there we go

934
00:33:00,159 --> 00:33:01,840
adding 12 to edi

935
00:33:01,840 --> 00:33:03,600
and then now we're going to make a

936
00:33:03,600 --> 00:33:05,039
dereference jump

937
00:33:05,039 --> 00:33:07,600
to virtual protect contained in edi

938
00:33:07,600 --> 00:33:08,559
let's check out

939
00:33:08,559 --> 00:33:12,080
uh eax okay so we see a virtual protect

940
00:33:12,080 --> 00:33:13,039
right there

941
00:33:13,039 --> 00:33:15,440
now let's check out our stack values and

942
00:33:15,440 --> 00:33:17,600
we have our stack parameters

943
00:33:17,600 --> 00:33:20,240
yeah and let's check out the return

944
00:33:20,240 --> 00:33:21,519
address which is the actual

945
00:33:21,519 --> 00:33:24,159
shell code and we're walking to peb so

946
00:33:24,159 --> 00:33:25,760
yeah that's shell code

947
00:33:25,760 --> 00:33:30,399
so let's see if we can actually do it

948
00:33:31,039 --> 00:33:34,559
okay we're in virtual protect

949
00:33:35,039 --> 00:33:38,480
we got it that rocket cat got her shell

950
00:33:38,480 --> 00:33:40,000
code

951
00:33:40,000 --> 00:33:42,960
austin created a real world job exploit

952
00:33:42,960 --> 00:33:43,600
attacking

953
00:33:43,600 --> 00:33:47,200
icon making software using the drop

954
00:33:47,200 --> 00:33:50,559
stack pivot technique now he did it all

955
00:33:50,559 --> 00:33:52,559
by hand but actually the job rocket

956
00:33:52,559 --> 00:33:53,519
would have found

957
00:33:53,519 --> 00:33:55,840
a very similar chain so let's see what

958
00:33:55,840 --> 00:33:57,360
he did

959
00:33:57,360 --> 00:33:59,840
hey i'm back i'll be taking you through

960
00:33:59,840 --> 00:34:02,080
an example of an exploit i've created on

961
00:34:02,080 --> 00:34:02,480
a

962
00:34:02,480 --> 00:34:05,279
binary in the real world a binary called

963
00:34:05,279 --> 00:34:05,760
ico

964
00:34:05,760 --> 00:34:09,040
fx 2.6 it's an icon editor with a

965
00:34:09,040 --> 00:34:11,119
vulnerability that allows you to craft a

966
00:34:11,119 --> 00:34:13,199
malicious icon file

967
00:34:13,199 --> 00:34:16,079
and i've created a java exploit using a

968
00:34:16,079 --> 00:34:18,239
similar stack pivoting approach that the

969
00:34:18,239 --> 00:34:19,040
automated

970
00:34:19,040 --> 00:34:22,560
generation does so although i did build

971
00:34:22,560 --> 00:34:24,960
this exploit from the ground up

972
00:34:24,960 --> 00:34:26,879
comparing it to the automated job chain

973
00:34:26,879 --> 00:34:29,199
generated for this binary

974
00:34:29,199 --> 00:34:31,679
i actually could have saved some some

975
00:34:31,679 --> 00:34:33,679
trouble that i had finding gadgets at

976
00:34:33,679 --> 00:34:35,040
the beginning because a lot of the

977
00:34:35,040 --> 00:34:36,960
gadgets that the

978
00:34:36,960 --> 00:34:39,839
that the automated chain generated were

979
00:34:39,839 --> 00:34:41,679
actually the same that i was using so

980
00:34:41,679 --> 00:34:42,639
that would have been a really good

981
00:34:42,639 --> 00:34:43,918
starting point

982
00:34:43,918 --> 00:34:47,520
for my x-blade however even with that

983
00:34:47,520 --> 00:34:49,440
this was still a challenging binary and

984
00:34:49,440 --> 00:34:51,359
some of the gadgets that

985
00:34:51,359 --> 00:34:54,239
were used had to have some special

986
00:34:54,239 --> 00:34:55,760
considerations made

987
00:34:55,760 --> 00:34:57,839
and i'll talk about that here in the

988
00:34:57,839 --> 00:35:00,480
next few slides so

989
00:35:00,480 --> 00:35:03,440
our dispatcher gadget so our dispatcher

990
00:35:03,440 --> 00:35:04,800
gadget

991
00:35:04,800 --> 00:35:07,520
is a little bit weird it's kind of nice

992
00:35:07,520 --> 00:35:09,440
but we do have an ad with the d word

993
00:35:09,440 --> 00:35:10,560
pointer eax

994
00:35:10,560 --> 00:35:12,640
as the value that we're adding to our

995
00:35:12,640 --> 00:35:14,240
dispatch table

996
00:35:14,240 --> 00:35:18,160
so we do need to set up eax to point to

997
00:35:18,160 --> 00:35:20,880
a value that we want to add to ecx so

998
00:35:20,880 --> 00:35:22,720
that does need to be a valid memory

999
00:35:22,720 --> 00:35:25,040
location

1000
00:35:25,040 --> 00:35:28,400
also with our stack pivoting gadget we

1001
00:35:28,400 --> 00:35:31,680
have a similar problem where we have

1002
00:35:31,680 --> 00:35:34,720
a dispatching or a we have a

1003
00:35:34,720 --> 00:35:36,000
dereferencing

1004
00:35:36,000 --> 00:35:38,240
with an offset based off of ebx so we

1005
00:35:38,240 --> 00:35:39,520
want to make sure that that

1006
00:35:39,520 --> 00:35:42,000
value that that goes to is going to be

1007
00:35:42,000 --> 00:35:43,599
writable so that we don't get an

1008
00:35:43,599 --> 00:35:46,000
access violation there and even though

1009
00:35:46,000 --> 00:35:48,000
we do have some of these weird gadgets

1010
00:35:48,000 --> 00:35:50,160
we can still make them work and

1011
00:35:50,160 --> 00:35:51,599
that's just part of the fun of the job

1012
00:35:51,599 --> 00:35:53,680
you you every exploit is going to be

1013
00:35:53,680 --> 00:35:54,400
different

1014
00:35:54,400 --> 00:35:55,520
and we're going to have to do weird

1015
00:35:55,520 --> 00:35:57,680
things sometimes and that's kind of fun

1016
00:35:57,680 --> 00:35:58,800
um

1017
00:35:58,800 --> 00:36:02,720
so another thing that we have in this

1018
00:36:02,720 --> 00:36:03,680
exploit

1019
00:36:03,680 --> 00:36:06,960
is we have our dereferencing gadget here

1020
00:36:06,960 --> 00:36:09,200
and this dereference has an offset in it

1021
00:36:09,200 --> 00:36:11,280
and that's really not a problem at all

1022
00:36:11,280 --> 00:36:12,720
all we have to do is make sure that

1023
00:36:12,720 --> 00:36:15,200
we're adding that offset to our pointer

1024
00:36:15,200 --> 00:36:18,400
in our value that we supply there

1025
00:36:18,400 --> 00:36:21,200
so we can see our screenshot from our

1026
00:36:21,200 --> 00:36:22,960
code in the bottom right we just have

1027
00:36:22,960 --> 00:36:24,079
the pointer to

1028
00:36:24,079 --> 00:36:25,680
virtual protect and then we're adding

1029
00:36:25,680 --> 00:36:28,400
that 71 offset so we take care of that

1030
00:36:28,400 --> 00:36:29,760
with our gadget

1031
00:36:29,760 --> 00:36:33,359
so look at the video here we're going to

1032
00:36:33,359 --> 00:36:37,520
start with a pop ecx gadget and that's

1033
00:36:37,520 --> 00:36:38,640
just the start of

1034
00:36:38,640 --> 00:36:42,160
our wrap setup chain for our job control

1035
00:36:42,160 --> 00:36:43,520
flow so we're setting up our control

1036
00:36:43,520 --> 00:36:44,560
flow with rop

1037
00:36:44,560 --> 00:36:46,000
and then we're going to perform jop in

1038
00:36:46,000 --> 00:36:49,599
order to do our stack pivot

1039
00:36:50,079 --> 00:36:53,680
we will load our malicious icon file

1040
00:36:53,680 --> 00:36:55,440
we'll go to our first breakpoint that

1041
00:36:55,440 --> 00:36:56,880
wrap setup chain

1042
00:36:56,880 --> 00:36:58,480
and one thing to note with this setup

1043
00:36:58,480 --> 00:37:00,160
chain is that we're actually dynamically

1044
00:37:00,160 --> 00:37:02,000
grabbing the addresses

1045
00:37:02,000 --> 00:37:05,200
of our dispatcher or dispatch table

1046
00:37:05,200 --> 00:37:08,240
and then also that address that we use

1047
00:37:08,240 --> 00:37:09,440
for eax

1048
00:37:09,440 --> 00:37:12,240
for our value to add we're going to

1049
00:37:12,240 --> 00:37:14,000
dynamically grab that too

1050
00:37:14,000 --> 00:37:16,240
doing some self-location techniques just

1051
00:37:16,240 --> 00:37:18,400
for added stability here in case any of

1052
00:37:18,400 --> 00:37:19,839
those addresses change

1053
00:37:19,839 --> 00:37:21,760
if we didn't do that and one of those

1054
00:37:21,760 --> 00:37:23,520
addresses did change then we would run

1055
00:37:23,520 --> 00:37:26,320
into problems

1056
00:37:26,400 --> 00:37:28,880
so we can see after we set up our eax

1057
00:37:28,880 --> 00:37:30,000
register

1058
00:37:30,000 --> 00:37:32,960
we're going to be pointing at a value if

1059
00:37:32,960 --> 00:37:34,800
we look in the bottom left here

1060
00:37:34,800 --> 00:37:37,680
we're going to be pointing at 4 with the

1061
00:37:37,680 --> 00:37:38,320
eax

1062
00:37:38,320 --> 00:37:40,000
so that 4 value is what is going to get

1063
00:37:40,000 --> 00:37:42,079
added to our dispatch table each time

1064
00:37:42,079 --> 00:37:44,400
our dispatcher executes

1065
00:37:44,400 --> 00:37:46,000
we'll skip over some of the additional

1066
00:37:46,000 --> 00:37:48,240
setup here and then we'll skip to our

1067
00:37:48,240 --> 00:37:49,440
job section or

1068
00:37:49,440 --> 00:37:52,560
stack pivoting so

1069
00:37:52,560 --> 00:37:56,240
starting job we are going

1070
00:37:56,240 --> 00:38:00,800
to stack pivot 40 bytes using this

1071
00:38:00,800 --> 00:38:03,440
top evp gadget over and over so we can

1072
00:38:03,440 --> 00:38:04,240
see here

1073
00:38:04,240 --> 00:38:05,920
we're going to go to our breakpoint

1074
00:38:05,920 --> 00:38:08,000
we're going to do our pop evp

1075
00:38:08,000 --> 00:38:10,800
and every time we execute this gadget

1076
00:38:10,800 --> 00:38:12,800
we're going to get closer and closer to

1077
00:38:12,800 --> 00:38:14,320
our parameters and we can see us

1078
00:38:14,320 --> 00:38:15,520
stepping through

1079
00:38:15,520 --> 00:38:17,599
our dispatcher gadget and that's working

1080
00:38:17,599 --> 00:38:19,760
successfully too so that eax value is

1081
00:38:19,760 --> 00:38:22,560
set up correctly

1082
00:38:23,680 --> 00:38:25,920
so since bad bytes weren't an issue in

1083
00:38:25,920 --> 00:38:27,040
this exploit

1084
00:38:27,040 --> 00:38:28,240
that's why we're using the stack

1085
00:38:28,240 --> 00:38:30,560
pivoting approach we have

1086
00:38:30,560 --> 00:38:32,480
our virtual protect parameters all

1087
00:38:32,480 --> 00:38:34,480
supplied in our payload here we can see

1088
00:38:34,480 --> 00:38:38,320
those under vp params

1089
00:38:39,920 --> 00:38:42,000
we'll continue approaching that with our

1090
00:38:42,000 --> 00:38:44,079
stack pivot now we've gone through about

1091
00:38:44,079 --> 00:38:44,480
half

1092
00:38:44,480 --> 00:38:47,200
of our stack pivots and we'll just skip

1093
00:38:47,200 --> 00:38:48,960
through the rest of them real quick

1094
00:38:48,960 --> 00:38:50,720
we're ready to dereference our virtual

1095
00:38:50,720 --> 00:38:52,800
protect pointer

1096
00:38:52,800 --> 00:38:55,839
and call our function so we will call

1097
00:38:55,839 --> 00:38:58,880
virtual protect here

1098
00:38:58,960 --> 00:39:02,400
executing this jump

1099
00:39:03,200 --> 00:39:04,960
now that we're in virtual protect we're

1100
00:39:04,960 --> 00:39:06,960
ready to make that region of memory

1101
00:39:06,960 --> 00:39:07,760
executable

1102
00:39:07,760 --> 00:39:10,079
and execute our shell code and we can

1103
00:39:10,079 --> 00:39:11,680
see now we've popped calc

1104
00:39:11,680 --> 00:39:14,240
using jop in a real world exploit which

1105
00:39:14,240 --> 00:39:14,800
is

1106
00:39:14,800 --> 00:39:16,480
which it's really cool that's really

1107
00:39:16,480 --> 00:39:19,599
rare now our talk is about bypassing

1108
00:39:19,599 --> 00:39:21,920
depth but what if instead of bypassing

1109
00:39:21,920 --> 00:39:22,560
it

1110
00:39:22,560 --> 00:39:24,560
we could just simply avoid it all

1111
00:39:24,560 --> 00:39:26,720
together and call those windows api

1112
00:39:26,720 --> 00:39:27,520
functions

1113
00:39:27,520 --> 00:39:31,359
directly instead of using shell code

1114
00:39:31,359 --> 00:39:33,040
and that is exactly what austin will

1115
00:39:33,040 --> 00:39:34,880
show us how to do

1116
00:39:34,880 --> 00:39:37,280
so i'll be taking you through an example

1117
00:39:37,280 --> 00:39:39,200
of the shell clubless drop technique

1118
00:39:39,200 --> 00:39:41,119
we're going to look at an example

1119
00:39:41,119 --> 00:39:42,320
exploit here

1120
00:39:42,320 --> 00:39:44,240
and for an overview of renek of our

1121
00:39:44,240 --> 00:39:46,560
exploit we're going to set up our job

1122
00:39:46,560 --> 00:39:47,599
control flow

1123
00:39:47,599 --> 00:39:49,359
we're going to pivot esp then we're

1124
00:39:49,359 --> 00:39:51,839
going to perform three function calls so

1125
00:39:51,839 --> 00:39:54,320
the library is going to give us a handle

1126
00:39:54,320 --> 00:39:55,280
to the msv

1127
00:39:55,280 --> 00:39:58,240
crt dll we're going to use that handle

1128
00:39:58,240 --> 00:39:59,920
with git proc address to

1129
00:39:59,920 --> 00:40:01,599
get the address of a certain function

1130
00:40:01,599 --> 00:40:03,040
within that dll

1131
00:40:03,040 --> 00:40:05,520
and then we'll perform that call in

1132
00:40:05,520 --> 00:40:06,319
order to

1133
00:40:06,319 --> 00:40:09,599
perform a a windows

1134
00:40:09,599 --> 00:40:12,400
command line command and we'll see what

1135
00:40:12,400 --> 00:40:14,880
that command is during the demo

1136
00:40:14,880 --> 00:40:17,920
so just like with any ropex or

1137
00:40:17,920 --> 00:40:20,880
not wrap just like with any jobx flight

1138
00:40:20,880 --> 00:40:22,800
we're going to set up our job control

1139
00:40:22,800 --> 00:40:23,920
flow

1140
00:40:23,920 --> 00:40:25,599
first of all we're just going to use a

1141
00:40:25,599 --> 00:40:27,440
job gadget in order to do that

1142
00:40:27,440 --> 00:40:29,119
and we do have to export some values

1143
00:40:29,119 --> 00:40:30,560
there because we have to worry about bad

1144
00:40:30,560 --> 00:40:32,800
bytes however later in memory

1145
00:40:32,800 --> 00:40:35,119
um we have a copy of our payload that

1146
00:40:35,119 --> 00:40:37,119
doesn't have bad bytes in it

1147
00:40:37,119 --> 00:40:40,640
or well it does however you want to put

1148
00:40:40,640 --> 00:40:40,960
it

1149
00:40:40,960 --> 00:40:43,760
the the null bytes that are normally bad

1150
00:40:43,760 --> 00:40:45,280
at the start of our exploit

1151
00:40:45,280 --> 00:40:47,440
are included in our payload later in the

1152
00:40:47,440 --> 00:40:49,359
exploits so what we can do

1153
00:40:49,359 --> 00:40:52,960
is pivot esp forwards to our second copy

1154
00:40:52,960 --> 00:40:54,640
of our payload where those null bytes

1155
00:40:54,640 --> 00:40:56,240
are no longer an issue

1156
00:40:56,240 --> 00:40:59,119
and then we can pivot 72 bytes and

1157
00:40:59,119 --> 00:41:00,960
perform the rest of her exploit without

1158
00:41:00,960 --> 00:41:02,880
worrying about those

1159
00:41:02,880 --> 00:41:05,040
so some things to take into

1160
00:41:05,040 --> 00:41:06,880
consideration some of these when api

1161
00:41:06,880 --> 00:41:07,599
calls

1162
00:41:07,599 --> 00:41:11,200
is that we need um locations of pointers

1163
00:41:11,200 --> 00:41:14,400
for things like strings or sometimes

1164
00:41:14,400 --> 00:41:16,960
other kinds of data structures as well

1165
00:41:16,960 --> 00:41:19,440
if we can help it we want to try and

1166
00:41:19,440 --> 00:41:21,599
dynamically generate the address of

1167
00:41:21,599 --> 00:41:23,040
those

1168
00:41:23,040 --> 00:41:26,720
certain those certain values so

1169
00:41:26,720 --> 00:41:28,560
if we can dynamically generate those

1170
00:41:28,560 --> 00:41:30,720
pointers then we don't have to hard code

1171
00:41:30,720 --> 00:41:32,000
them into our exploit

1172
00:41:32,000 --> 00:41:33,760
and if we have something like rebasing

1173
00:41:33,760 --> 00:41:35,280
aslr going on

1174
00:41:35,280 --> 00:41:38,480
we can actually um still

1175
00:41:38,480 --> 00:41:41,839
do um that and supply the correct value

1176
00:41:41,839 --> 00:41:44,240
however we don't have aslr rebasing in

1177
00:41:44,240 --> 00:41:45,440
our exploit

1178
00:41:45,440 --> 00:41:49,359
in our program i mean so once we

1179
00:41:49,359 --> 00:41:51,839
once we can just hard code that value

1180
00:41:51,839 --> 00:41:53,599
into the

1181
00:41:53,599 --> 00:41:56,319
payload and we don't have to worry about

1182
00:41:56,319 --> 00:41:57,040
that

1183
00:41:57,040 --> 00:42:00,880
but if we were still being the the best

1184
00:42:00,880 --> 00:42:03,280
exploit writers we could be we would

1185
00:42:03,280 --> 00:42:04,319
probably want to

1186
00:42:04,319 --> 00:42:06,400
dynamically generate those so that we

1187
00:42:06,400 --> 00:42:09,599
have better stability

1188
00:42:09,839 --> 00:42:13,040
with those string parameters another

1189
00:42:13,040 --> 00:42:14,800
thing to consider is that with some

1190
00:42:14,800 --> 00:42:15,359
functions

1191
00:42:15,359 --> 00:42:17,680
such as load library exw which we're

1192
00:42:17,680 --> 00:42:19,520
using instead of the normal load library

1193
00:42:19,520 --> 00:42:20,160
function

1194
00:42:20,160 --> 00:42:22,240
that w means we want a wide character

1195
00:42:22,240 --> 00:42:24,560
string and that wide character string is

1196
00:42:24,560 --> 00:42:26,000
going to be formatted differently it's

1197
00:42:26,000 --> 00:42:27,359
got some padding in it

1198
00:42:27,359 --> 00:42:31,119
and the encoding there is usually utf-16

1199
00:42:31,119 --> 00:42:33,119
little indian although that can be

1200
00:42:33,119 --> 00:42:36,800
os dependent so just as a sanity check

1201
00:42:36,800 --> 00:42:38,160
we can throw that into something like

1202
00:42:38,160 --> 00:42:39,760
visual studio with c

1203
00:42:39,760 --> 00:42:42,319
plus and then we can run that debugger

1204
00:42:42,319 --> 00:42:44,000
in order to just make sure

1205
00:42:44,000 --> 00:42:45,920
that we're using the correct formatting

1206
00:42:45,920 --> 00:42:48,160
there

1207
00:42:49,359 --> 00:42:50,960
something else to consider is that we

1208
00:42:50,960 --> 00:42:52,400
might not always have

1209
00:42:52,400 --> 00:42:54,560
um the pointers to every function that

1210
00:42:54,560 --> 00:42:56,079
we want to use in our shell build this

1211
00:42:56,079 --> 00:42:58,079
exploit however if we have a pointer to

1212
00:42:58,079 --> 00:43:01,119
another function in the same library

1213
00:43:01,119 --> 00:43:03,920
we can get the offset to from one to the

1214
00:43:03,920 --> 00:43:04,480
other

1215
00:43:04,480 --> 00:43:06,000
so here we have a pointer to load

1216
00:43:06,000 --> 00:43:07,520
library exw

1217
00:43:07,520 --> 00:43:09,839
and then we'll open that up in ida and

1218
00:43:09,839 --> 00:43:11,280
we'll see the address to

1219
00:43:11,280 --> 00:43:14,560
load library exw and then we will see

1220
00:43:14,560 --> 00:43:15,119
that

1221
00:43:15,119 --> 00:43:18,160
git proc address is in the same

1222
00:43:18,160 --> 00:43:21,280
library it's in kernel 32 so we can

1223
00:43:21,280 --> 00:43:22,880
actually get the address of that

1224
00:43:22,880 --> 00:43:24,400
function as well and then find the

1225
00:43:24,400 --> 00:43:26,079
offset between the two

1226
00:43:26,079 --> 00:43:28,640
if we are doing this method it does lack

1227
00:43:28,640 --> 00:43:30,079
portability because

1228
00:43:30,079 --> 00:43:32,160
depending on the release of what os

1229
00:43:32,160 --> 00:43:33,200
we're using

1230
00:43:33,200 --> 00:43:35,520
um we're gonna have a different version

1231
00:43:35,520 --> 00:43:37,359
of the dll and those offsets are going

1232
00:43:37,359 --> 00:43:38,640
to be different

1233
00:43:38,640 --> 00:43:41,040
however once we get that offset we can

1234
00:43:41,040 --> 00:43:43,040
dereference the function pointer of the

1235
00:43:43,040 --> 00:43:44,560
one that we have

1236
00:43:44,560 --> 00:43:46,400
and then add that offset to get the

1237
00:43:46,400 --> 00:43:48,000
address of the next function we're gonna

1238
00:43:48,000 --> 00:43:51,280
use that in our exploit here

1239
00:43:51,280 --> 00:43:53,280
one last thing to consider is that if we

1240
00:43:53,280 --> 00:43:55,200
have output from one function that we're

1241
00:43:55,200 --> 00:43:56,880
using in another function here

1242
00:43:56,880 --> 00:43:58,800
so here we have loadlibrary which

1243
00:43:58,800 --> 00:44:00,920
returns a handle to

1244
00:44:00,920 --> 00:44:03,760
msvcrt.dll and we want to use that

1245
00:44:03,760 --> 00:44:04,560
handle as

1246
00:44:04,560 --> 00:44:06,160
one of our parameters for getproc

1247
00:44:06,160 --> 00:44:08,079
address so we're going to

1248
00:44:08,079 --> 00:44:10,480
actually get that handle and then we're

1249
00:44:10,480 --> 00:44:11,839
going to push it

1250
00:44:11,839 --> 00:44:13,760
using jot because we won't know what

1251
00:44:13,760 --> 00:44:15,599
that value is going to be at the time of

1252
00:44:15,599 --> 00:44:17,200
writing the exploit we have to do this

1253
00:44:17,200 --> 00:44:18,800
at run time here

1254
00:44:18,800 --> 00:44:21,839
so that return address or that that

1255
00:44:21,839 --> 00:44:23,520
return value is going to be returned

1256
00:44:23,520 --> 00:44:25,839
into eax and then we can do a push eax

1257
00:44:25,839 --> 00:44:27,119
gadget there

1258
00:44:27,119 --> 00:44:29,040
so again for another overview of what

1259
00:44:29,040 --> 00:44:30,560
we're doing we're going to set up our

1260
00:44:30,560 --> 00:44:32,240
jot control flow we're going to pivot

1261
00:44:32,240 --> 00:44:33,119
esp

1262
00:44:33,119 --> 00:44:34,640
we're going to perform our function

1263
00:44:34,640 --> 00:44:37,040
calls our load library is going to give

1264
00:44:37,040 --> 00:44:38,000
us the handle

1265
00:44:38,000 --> 00:44:39,760
our get proc address is going to give us

1266
00:44:39,760 --> 00:44:41,280
the address of system

1267
00:44:41,280 --> 00:44:43,280
and then our system call will be our

1268
00:44:43,280 --> 00:44:46,240
actual final malicious action

1269
00:44:46,240 --> 00:44:48,880
we'll take a look at our demo here so

1270
00:44:48,880 --> 00:44:50,560
we're going to start with our job setup

1271
00:44:50,560 --> 00:44:51,520
section

1272
00:44:51,520 --> 00:44:53,680
where we're going to set up our control

1273
00:44:53,680 --> 00:44:55,760
flow registers

1274
00:44:55,760 --> 00:44:57,599
so here we can see we're doing a bunch

1275
00:44:57,599 --> 00:45:00,880
of pops and some xors

1276
00:45:01,280 --> 00:45:03,280
once we get that set up we can see an

1277
00:45:03,280 --> 00:45:06,480
edi is the address of our dispatch table

1278
00:45:06,480 --> 00:45:08,960
an edx is our dispatcher gadget you can

1279
00:45:08,960 --> 00:45:10,640
see our dispatch table in the bottom

1280
00:45:10,640 --> 00:45:12,879
left

1281
00:45:13,200 --> 00:45:14,800
we're going to perform our stack pivot

1282
00:45:14,800 --> 00:45:17,040
afterwards

1283
00:45:17,040 --> 00:45:19,760
pivoting esp that's 72 bytes to the

1284
00:45:19,760 --> 00:45:20,880
better location

1285
00:45:20,880 --> 00:45:24,480
in our stack where we can supply those

1286
00:45:24,480 --> 00:45:26,160
no byte values so here we're trying to

1287
00:45:26,160 --> 00:45:28,480
get there

1288
00:45:28,480 --> 00:45:31,440
and we can see as we execute our add esp

1289
00:45:31,440 --> 00:45:32,800
we're going to keep on approaching that

1290
00:45:32,800 --> 00:45:33,839
location

1291
00:45:33,839 --> 00:45:36,640
getting closer closer again and then

1292
00:45:36,640 --> 00:45:39,200
we're there

1293
00:45:39,760 --> 00:45:43,520
after our stack pivot

1294
00:45:43,520 --> 00:45:45,680
let's take a look in the code what are

1295
00:45:45,680 --> 00:45:47,200
we doing next well first you want to

1296
00:45:47,200 --> 00:45:49,280
call the library exw

1297
00:45:49,280 --> 00:45:52,079
and all of the parameters for library we

1298
00:45:52,079 --> 00:45:52,800
can just

1299
00:45:52,800 --> 00:45:54,960
put directly into our payload here so we

1300
00:45:54,960 --> 00:45:56,560
have our pointer

1301
00:45:56,560 --> 00:45:59,680
to the mspcrt string and

1302
00:45:59,680 --> 00:46:02,319
in a second after we dereference the

1303
00:46:02,319 --> 00:46:03,040
address

1304
00:46:03,040 --> 00:46:04,720
or the pointer to that function and we

1305
00:46:04,720 --> 00:46:06,640
call it

1306
00:46:06,640 --> 00:46:09,839
we can see that we are using the correct

1307
00:46:09,839 --> 00:46:11,440
parameters we have our pointer

1308
00:46:11,440 --> 00:46:14,079
and if we follow that pointer and the

1309
00:46:14,079 --> 00:46:17,200
dump in the bottom left

1310
00:46:17,280 --> 00:46:21,119
and a little bit of misclicking here

1311
00:46:21,119 --> 00:46:22,880
but uh we'll follow that in the bottom

1312
00:46:22,880 --> 00:46:24,960
left and we can see

1313
00:46:24,960 --> 00:46:27,040
the actual ascii values of the bytes

1314
00:46:27,040 --> 00:46:28,000
there and

1315
00:46:28,000 --> 00:46:30,480
we have that padding in between each uh

1316
00:46:30,480 --> 00:46:31,599
letter there just

1317
00:46:31,599 --> 00:46:34,720
because we have the wide stream

1318
00:46:34,720 --> 00:46:37,920
so we actually returned to

1319
00:46:37,920 --> 00:46:40,560
a repair gadget because load library is

1320
00:46:40,560 --> 00:46:42,240
going to crush one of our registers that

1321
00:46:42,240 --> 00:46:43,040
we're using for

1322
00:46:43,040 --> 00:46:45,920
our control flow so we'll just do a bit

1323
00:46:45,920 --> 00:46:47,680
of a repair gadget here

1324
00:46:47,680 --> 00:46:49,440
and then along with that we're going to

1325
00:46:49,440 --> 00:46:51,839
re-pop the pointer for load library

1326
00:46:51,839 --> 00:46:53,520
because we're going to use that again

1327
00:46:53,520 --> 00:46:55,520
for getting that offset to get proc

1328
00:46:55,520 --> 00:46:59,040
address so

1329
00:46:59,040 --> 00:47:02,400
we'll see we're going to dereference

1330
00:47:02,400 --> 00:47:06,319
that pointer real quick

1331
00:47:06,319 --> 00:47:08,839
this is the section of the code or doing

1332
00:47:08,839 --> 00:47:11,839
so

1333
00:47:13,359 --> 00:47:16,960
we'll dereference our pointer

1334
00:47:17,680 --> 00:47:21,839
we'll grab our offset into ebx

1335
00:47:21,839 --> 00:47:24,319
which is actually a negative value we

1336
00:47:24,319 --> 00:47:26,960
use two's complement to find that

1337
00:47:26,960 --> 00:47:30,000
we will add those two values together

1338
00:47:30,000 --> 00:47:34,400
to get the address of git rock address

1339
00:47:36,160 --> 00:47:39,520
now that we have that we can push our

1340
00:47:39,520 --> 00:47:42,240
handle that we got from load library or

1341
00:47:42,240 --> 00:47:43,359
return value

1342
00:47:43,359 --> 00:47:46,160
and then we'll also push our return

1343
00:47:46,160 --> 00:47:48,960
address for git proc adder

1344
00:47:48,960 --> 00:47:51,359
that return address is actually a jump

1345
00:47:51,359 --> 00:47:52,000
eax

1346
00:47:52,000 --> 00:47:54,960
gadget because get proc address is going

1347
00:47:54,960 --> 00:47:55,920
to give us

1348
00:47:55,920 --> 00:47:58,000
the address of the next function we want

1349
00:47:58,000 --> 00:47:59,599
to call in eax

1350
00:47:59,599 --> 00:48:01,680
so we can just return to a jump eax

1351
00:48:01,680 --> 00:48:03,760
afterwards so here we can see our get

1352
00:48:03,760 --> 00:48:04,079
proc

1353
00:48:04,079 --> 00:48:07,839
address function is being called

1354
00:48:07,839 --> 00:48:09,119
you can see we're using the correct

1355
00:48:09,119 --> 00:48:11,760
parameters

1356
00:48:12,240 --> 00:48:15,680
we'll return to the jump eax gadget

1357
00:48:15,680 --> 00:48:18,839
and a second once we execute get proc

1358
00:48:18,839 --> 00:48:20,480
address

1359
00:48:20,480 --> 00:48:24,960
now we'll jump to our system call

1360
00:48:24,960 --> 00:48:26,880
and that's the function system not an

1361
00:48:26,880 --> 00:48:28,160
actual system call

1362
00:48:28,160 --> 00:48:30,880
and our command we're using for our

1363
00:48:30,880 --> 00:48:32,400
command align

1364
00:48:32,400 --> 00:48:35,760
command for this is shutdown l which is

1365
00:48:35,760 --> 00:48:38,079
going to log out the current user

1366
00:48:38,079 --> 00:48:40,319
so maybe it's not the most malicious

1367
00:48:40,319 --> 00:48:41,680
type of uh

1368
00:48:41,680 --> 00:48:43,200
payload here but it's definitely

1369
00:48:43,200 --> 00:48:45,119
annoying if you were trying to run this

1370
00:48:45,119 --> 00:48:46,720
program and you didn't know what was

1371
00:48:46,720 --> 00:48:48,079
going on

1372
00:48:48,079 --> 00:48:49,599
it's going to take a second but we'll

1373
00:48:49,599 --> 00:48:52,160
log out our user here

1374
00:48:52,160 --> 00:48:56,079
and that's a shellcodebliss job exploit

1375
00:48:56,079 --> 00:48:57,680
so with that i'm going to pass the

1376
00:48:57,680 --> 00:48:59,520
presentation back on over to bramwell

1377
00:48:59,520 --> 00:49:01,520
one last time

1378
00:49:01,520 --> 00:49:03,440
so our next topic is a very important

1379
00:49:03,440 --> 00:49:04,559
one and it deals with

1380
00:49:04,559 --> 00:49:06,640
novel dispatcher gadgets and when i say

1381
00:49:06,640 --> 00:49:09,200
novel i mean very novel because it's

1382
00:49:09,200 --> 00:49:12,079
uh very recent just last couple weeks so

1383
00:49:12,079 --> 00:49:14,400
let's review the existing

1384
00:49:14,400 --> 00:49:16,880
dispatcher gadgets we have add we have

1385
00:49:16,880 --> 00:49:18,880
subtract we have a load effective

1386
00:49:18,880 --> 00:49:19,520
address

1387
00:49:19,520 --> 00:49:21,040
and really at the heart of it we're

1388
00:49:21,040 --> 00:49:22,880
predictively modifying like say we're

1389
00:49:22,880 --> 00:49:23,680
adding

1390
00:49:23,680 --> 00:49:26,960
to to ebx a value like four and then we

1391
00:49:26,960 --> 00:49:28,000
go and make a d

1392
00:49:28,000 --> 00:49:31,200
reference jump to the same register

1393
00:49:31,200 --> 00:49:34,480
like ebx short and sweet

1394
00:49:34,480 --> 00:49:36,640
is the most desirable because we can

1395
00:49:36,640 --> 00:49:39,359
avoid side effects that would clobber

1396
00:49:39,359 --> 00:49:42,319
other registers not a good thing if it

1397
00:49:42,319 --> 00:49:44,800
sounds like we're asking for a lot

1398
00:49:44,800 --> 00:49:48,079
yeah indeed we are and

1399
00:49:48,079 --> 00:49:50,800
understandably gadgets like this are

1400
00:49:50,800 --> 00:49:52,240
kind of scarce and that's

1401
00:49:52,240 --> 00:49:54,559
a really bad thing if you're trying to

1402
00:49:54,559 --> 00:49:56,720
do jump oriented programming

1403
00:49:56,720 --> 00:50:00,079
and you're most important gadget

1404
00:50:00,079 --> 00:50:03,280
is obscure so i gave it a little bit of

1405
00:50:03,280 --> 00:50:04,400
thought

1406
00:50:04,400 --> 00:50:06,640
and it's kind of came to me relatively

1407
00:50:06,640 --> 00:50:07,599
quickly

1408
00:50:07,599 --> 00:50:11,359
and what i came upon was expanding it

1409
00:50:11,359 --> 00:50:14,559
to a two gadget dispatcher

1410
00:50:14,559 --> 00:50:18,319
so what if we could instead add

1411
00:50:18,319 --> 00:50:22,400
to a register make a non-dereference

1412
00:50:22,400 --> 00:50:23,440
just a traditional

1413
00:50:23,440 --> 00:50:26,160
indirect jump to a different register

1414
00:50:26,160 --> 00:50:28,160
let's say ebp

1415
00:50:28,160 --> 00:50:31,119
and then the next gadget all that it

1416
00:50:31,119 --> 00:50:32,800
does

1417
00:50:32,800 --> 00:50:36,160
is make a dereference jump to the first

1418
00:50:36,160 --> 00:50:40,000
register and turns out it actually works

1419
00:50:40,000 --> 00:50:41,520
so let's see it in motion

1420
00:50:41,520 --> 00:50:45,280
follow that little diamond okay so we go

1421
00:50:45,280 --> 00:50:45,760
there

1422
00:50:45,760 --> 00:50:48,800
and yeah it works

1423
00:50:48,800 --> 00:50:51,119
and we check this out through different

1424
00:50:51,119 --> 00:50:52,240
exploits and

1425
00:50:52,240 --> 00:50:54,559
indeed it does work so it's very

1426
00:50:54,559 --> 00:50:55,760
exciting because

1427
00:50:55,760 --> 00:50:58,079
this opens up a lot more possibilities

1428
00:50:58,079 --> 00:50:59,200
now instead of needing

1429
00:50:59,200 --> 00:51:02,160
a relatively obscure gadget you can find

1430
00:51:02,160 --> 00:51:02,640
just

1431
00:51:02,640 --> 00:51:06,480
any gadget that does add subtract

1432
00:51:06,480 --> 00:51:08,559
load effective address and some other

1433
00:51:08,559 --> 00:51:10,319
things we'll talk about shortly

1434
00:51:10,319 --> 00:51:13,839
and then jump to a different register

1435
00:51:13,839 --> 00:51:16,160
and that other register will then point

1436
00:51:16,160 --> 00:51:17,599
to the gadget that does the

1437
00:51:17,599 --> 00:51:18,800
dereferencing

1438
00:51:18,800 --> 00:51:20,880
and you may be thinking well what if we

1439
00:51:20,880 --> 00:51:22,640
don't have that other

1440
00:51:22,640 --> 00:51:26,400
dereference uh gadget well

1441
00:51:26,400 --> 00:51:29,119
guess what you probably do because

1442
00:51:29,119 --> 00:51:30,800
another thing i implemented it was what

1443
00:51:30,800 --> 00:51:32,960
i call empty jumpty references

1444
00:51:32,960 --> 00:51:35,200
so in this case it looks just for a

1445
00:51:35,200 --> 00:51:36,319
single line

1446
00:51:36,319 --> 00:51:39,520
so ff whatever a jump

1447
00:51:39,520 --> 00:51:42,800
to a particular line and these are

1448
00:51:42,800 --> 00:51:43,599
actually

1449
00:51:43,599 --> 00:51:45,760
very very plentiful and i call them

1450
00:51:45,760 --> 00:51:47,599
empty because it may exist

1451
00:51:47,599 --> 00:51:50,079
only as a single line and you expand it

1452
00:51:50,079 --> 00:51:51,040
to two lines

1453
00:51:51,040 --> 00:51:54,880
and uh it doesn't exist and for a medium

1454
00:51:54,880 --> 00:51:55,359
to

1455
00:51:55,359 --> 00:51:58,480
to large size binary you're pretty much

1456
00:51:58,480 --> 00:52:01,280
guaranteed that all of the registers

1457
00:52:01,280 --> 00:52:02,400
will be represented

1458
00:52:02,400 --> 00:52:04,559
although with ebp it may actually be

1459
00:52:04,559 --> 00:52:05,839
something like

1460
00:52:05,839 --> 00:52:09,680
jump ebp plus offset but

1461
00:52:09,680 --> 00:52:11,119
that's something we can easily

1462
00:52:11,119 --> 00:52:12,960
accommodate as well

1463
00:52:12,960 --> 00:52:18,079
and so a lot of results right there and

1464
00:52:18,079 --> 00:52:19,760
the great thing about this also

1465
00:52:19,760 --> 00:52:22,960
is we can also now use call gadgets

1466
00:52:22,960 --> 00:52:24,319
because usually

1467
00:52:24,319 --> 00:52:26,240
with a dispatcher gadget you don't want

1468
00:52:26,240 --> 00:52:27,920
to use call because it would

1469
00:52:27,920 --> 00:52:31,200
continuously add to the stack which is

1470
00:52:31,200 --> 00:52:32,319
not a good thing

1471
00:52:32,319 --> 00:52:34,000
if you're trying to to build stack

1472
00:52:34,000 --> 00:52:36,160
parameters for when api function

1473
00:52:36,160 --> 00:52:39,280
so how we accommodate this is i came up

1474
00:52:39,280 --> 00:52:41,359
with another gadget where we just simply

1475
00:52:41,359 --> 00:52:44,440
add a pop right in front of the

1476
00:52:44,440 --> 00:52:45,760
dereferencing

1477
00:52:45,760 --> 00:52:47,839
and so job rocket will search for this

1478
00:52:47,839 --> 00:52:49,599
as well and the good news

1479
00:52:49,599 --> 00:52:53,599
is this second um dereferencing gadget

1480
00:52:53,599 --> 00:52:56,720
is pretty plentiful it's not a guarantee

1481
00:52:56,720 --> 00:52:59,280
like the other one is almost a guarantee

1482
00:52:59,280 --> 00:53:01,520
but it's still very very plentiful so

1483
00:53:01,520 --> 00:53:04,800
this opens up tremendous possibilities

1484
00:53:04,800 --> 00:53:08,319
for potential dispatchers and

1485
00:53:08,319 --> 00:53:11,359
the end result of that is now

1486
00:53:11,359 --> 00:53:14,000
job jump oriented programming is much

1487
00:53:14,000 --> 00:53:14,880
more

1488
00:53:14,880 --> 00:53:18,880
feasible these do come at a cost though

1489
00:53:18,880 --> 00:53:21,440
so instead of reserving two registers

1490
00:53:21,440 --> 00:53:23,680
with a traditional dispatcher we will

1491
00:53:23,680 --> 00:53:24,559
also reserve

1492
00:53:24,559 --> 00:53:27,359
a third because we need another register

1493
00:53:27,359 --> 00:53:28,000
to point

1494
00:53:28,000 --> 00:53:32,960
to the dispatcher dereference gadget

1495
00:53:32,960 --> 00:53:34,880
now another thing that came to us

1496
00:53:34,880 --> 00:53:37,119
recently from one of our co-authors from

1497
00:53:37,119 --> 00:53:37,599
our

1498
00:53:37,599 --> 00:53:39,359
hack in the box white paper andrew

1499
00:53:39,359 --> 00:53:41,520
kramer who's a dakota state uh

1500
00:53:41,520 --> 00:53:42,720
instructor

1501
00:53:42,720 --> 00:53:44,559
he said well what about using some

1502
00:53:44,559 --> 00:53:46,079
string instructions

1503
00:53:46,079 --> 00:53:48,800
to do dereferencing so don't think about

1504
00:53:48,800 --> 00:53:50,960
their intended purpose which is to do

1505
00:53:50,960 --> 00:53:52,319
stuff with strings

1506
00:53:52,319 --> 00:53:55,119
think about how they are going to

1507
00:53:55,119 --> 00:53:56,480
predictably

1508
00:53:56,480 --> 00:54:00,319
increment esi or edi or both

1509
00:54:00,319 --> 00:54:02,000
so we don't care what their intended

1510
00:54:02,000 --> 00:54:04,000
purpose is just that they're going to

1511
00:54:04,000 --> 00:54:07,040
do that incrementing for us and also

1512
00:54:07,040 --> 00:54:10,000
the the qd form will do eight bytes so

1513
00:54:10,000 --> 00:54:11,680
four bytes or eight bytes

1514
00:54:11,680 --> 00:54:13,440
uh and i created a little chart down

1515
00:54:13,440 --> 00:54:14,880
there that shows

1516
00:54:14,880 --> 00:54:18,240
uh what does what um

1517
00:54:18,240 --> 00:54:20,640
so let's see that in action right there

1518
00:54:20,640 --> 00:54:22,400
uh we see an example right here with

1519
00:54:22,400 --> 00:54:23,760
load sd

1520
00:54:23,760 --> 00:54:25,760
and in this case we actually don't even

1521
00:54:25,760 --> 00:54:27,359
need any padding

1522
00:54:27,359 --> 00:54:31,200
because uh it does it four bytes

1523
00:54:31,200 --> 00:54:35,119
so we do load sd jump d word pointer

1524
00:54:35,119 --> 00:54:38,160
to esi and then that points to the

1525
00:54:38,160 --> 00:54:39,520
dispatch table

1526
00:54:39,520 --> 00:54:42,160
uh each address is for bytes because

1527
00:54:42,160 --> 00:54:43,200
that's the size

1528
00:54:43,200 --> 00:54:46,559
of the pointer uh and so

1529
00:54:46,559 --> 00:54:50,839
it's another way to expand available

1530
00:54:50,839 --> 00:54:53,200
dispatchers

1531
00:54:53,200 --> 00:54:56,160
and yes the the the two gadget uh string

1532
00:54:56,160 --> 00:54:57,280
dispatcher works

1533
00:54:57,280 --> 00:55:00,880
as well uh again it just simply

1534
00:55:00,880 --> 00:55:03,200
switched it up a bit so in this case we

1535
00:55:03,200 --> 00:55:03,920
would do

1536
00:55:03,920 --> 00:55:07,520
load sd and then a regular jump to ebp

1537
00:55:07,520 --> 00:55:10,559
and then now we dereference esi

1538
00:55:10,559 --> 00:55:14,079
in the second dr dereference gadget

1539
00:55:14,079 --> 00:55:16,799
some other quick various topics control

1540
00:55:16,799 --> 00:55:18,079
full guard

1541
00:55:18,079 --> 00:55:21,920
it's microsoft's way to

1542
00:55:21,920 --> 00:55:23,920
enforce control flow integrity but the

1543
00:55:23,920 --> 00:55:26,400
thing is it's done at a compiler

1544
00:55:26,400 --> 00:55:28,240
level and it's very coarse grain now

1545
00:55:28,240 --> 00:55:30,000
there have been various bypasses

1546
00:55:30,000 --> 00:55:31,680
out there we're not going to talk about

1547
00:55:31,680 --> 00:55:33,280
this we're just briefly going to

1548
00:55:33,280 --> 00:55:36,400
address some ways to to maybe avoid it

1549
00:55:36,400 --> 00:55:40,319
because if it's done perfectly

1550
00:55:40,319 --> 00:55:43,920
it can make job it can provide some good

1551
00:55:43,920 --> 00:55:46,400
defense against that

1552
00:55:46,400 --> 00:55:49,359
so the things to keep in mind here are

1553
00:55:49,359 --> 00:55:50,640
well number of different things

1554
00:55:50,640 --> 00:55:53,359
for one in-line assembly will not work

1555
00:55:53,359 --> 00:55:54,799
windows 7

1556
00:55:54,799 --> 00:55:57,359
will not work and that's 19 of computers

1557
00:55:57,359 --> 00:55:57,920
is of

1558
00:55:57,920 --> 00:56:00,880
the current month and also op code

1559
00:56:00,880 --> 00:56:02,799
splitting will allow us to form

1560
00:56:02,799 --> 00:56:05,520
a number of different gadgets drop

1561
00:56:05,520 --> 00:56:06,240
gadgets

1562
00:56:06,240 --> 00:56:08,240
and so if you get results and it looks

1563
00:56:08,240 --> 00:56:10,319
like it's going to work

1564
00:56:10,319 --> 00:56:12,640
it's probably going to work because what

1565
00:56:12,640 --> 00:56:14,160
cfg does is it

1566
00:56:14,160 --> 00:56:16,559
inserts a guard check and so it can't

1567
00:56:16,559 --> 00:56:18,400
insert a guard check if it's from

1568
00:56:18,400 --> 00:56:21,040
hop code splitting so although you have

1569
00:56:21,040 --> 00:56:23,440
the ability to exclude results based off

1570
00:56:23,440 --> 00:56:24,559
of cfg

1571
00:56:24,559 --> 00:56:27,520
i don't necessarily recommend that just

1572
00:56:27,520 --> 00:56:28,559
because you still

1573
00:56:28,559 --> 00:56:31,440
may find some viable results from opt

1574
00:56:31,440 --> 00:56:32,559
killed splitting

1575
00:56:32,559 --> 00:56:36,160
or firm inline assembly

1576
00:56:36,640 --> 00:56:38,720
and that's pretty much all that we have

1577
00:56:38,720 --> 00:56:41,440
to say our goal has been to expand job

1578
00:56:41,440 --> 00:56:43,359
to provide the tools to provide the

1579
00:56:43,359 --> 00:56:46,160
knowledge and to help you guys do

1580
00:56:46,160 --> 00:56:48,720
uh what you do best to do awesome

1581
00:56:48,720 --> 00:56:49,359
hacking

1582
00:56:49,359 --> 00:56:52,880
and hopefully expand that not just from

1583
00:56:52,880 --> 00:56:53,280
rob

1584
00:56:53,280 --> 00:56:56,319
but also to job with that we'd like to

1585
00:56:56,319 --> 00:56:56,960
thank you

1586
00:56:56,960 --> 00:57:00,160
we will be available in the studio

1587
00:57:00,160 --> 00:57:01,920
channel if you want to chat with us and

1588
00:57:01,920 --> 00:57:12,400
also on discord

