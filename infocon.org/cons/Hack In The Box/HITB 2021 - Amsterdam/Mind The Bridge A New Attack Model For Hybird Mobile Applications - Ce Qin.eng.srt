1
00:00:15,679 --> 00:00:16,320
hello

2
00:00:16,320 --> 00:00:20,240
everyone i'm glad here

3
00:00:20,240 --> 00:00:23,359
to show you with my presentation

4
00:00:23,359 --> 00:00:26,880
mind the bridge new attack model

5
00:00:26,880 --> 00:00:31,840
in hybrid mobile application

6
00:00:32,558 --> 00:00:36,160
i am a security researcher in octopus

7
00:00:36,160 --> 00:00:37,040
team

8
00:00:37,040 --> 00:00:41,040
i used to focus on browser like age

9
00:00:41,040 --> 00:00:44,320
chrome and internet explorer

10
00:00:44,320 --> 00:00:47,360
and now i am an

11
00:00:47,360 --> 00:00:52,079
android application security guy

12
00:00:52,480 --> 00:00:55,760
in the past i always talk about doom

13
00:00:55,760 --> 00:00:57,039
tree

14
00:00:57,039 --> 00:01:00,320
chakra core v8

15
00:01:00,320 --> 00:01:03,520
blink and so on

16
00:01:03,520 --> 00:01:07,760
now i usually work with activity

17
00:01:07,760 --> 00:01:12,240
receiver provider and services

18
00:01:12,240 --> 00:01:15,920
there is a big range between browser

19
00:01:15,920 --> 00:01:19,119
and android apps

20
00:01:19,119 --> 00:01:22,479
anyway after few times

21
00:01:22,479 --> 00:01:26,080
work i find that maybe

22
00:01:26,080 --> 00:01:29,439
there is a bridge between these two

23
00:01:29,439 --> 00:01:33,439
areas which called hybrid

24
00:01:33,439 --> 00:01:36,399
application

25
00:01:38,000 --> 00:01:43,439
this is where our story begins

26
00:01:45,680 --> 00:01:49,759
so what the hybrid application

27
00:01:49,759 --> 00:01:52,079
is

28
00:01:52,799 --> 00:01:56,000
the diagram shows the mobile app

29
00:01:56,000 --> 00:01:59,439
technology stakes we

30
00:01:59,439 --> 00:02:04,159
can see that native apes

31
00:02:04,159 --> 00:02:08,800
provide the full capability the best

32
00:02:08,800 --> 00:02:12,520
filters and the best of all mobile

33
00:02:12,520 --> 00:02:14,720
experience

34
00:02:14,720 --> 00:02:17,920
native apes are specific

35
00:02:17,920 --> 00:02:22,920
to a given mobile platform

36
00:02:22,920 --> 00:02:25,360
html5 apps

37
00:02:25,360 --> 00:02:28,720
use standard web technologies

38
00:02:28,720 --> 00:02:32,720
are easier to develop easier to support

39
00:02:32,720 --> 00:02:36,000
and can reach the widest range of

40
00:02:36,000 --> 00:02:40,000
devices and html5

41
00:02:40,000 --> 00:02:43,680
mobile app is basically

42
00:02:43,680 --> 00:02:47,200
a web page or series

43
00:02:47,200 --> 00:02:51,440
of web pages html5

44
00:02:51,440 --> 00:02:54,879
apps cannot access natural filters on

45
00:02:54,879 --> 00:02:57,518
devices

46
00:02:59,920 --> 00:03:03,040
hybrid development combines the best

47
00:03:03,040 --> 00:03:07,440
of both the native and html5

48
00:03:07,440 --> 00:03:10,640
words hybrid application

49
00:03:10,640 --> 00:03:15,280
like native apps run on the device

50
00:03:15,280 --> 00:03:19,519
and i write with web technologies

51
00:03:19,519 --> 00:03:22,959
hybrid apps use common language

52
00:03:22,959 --> 00:03:26,319
like html css

53
00:03:26,319 --> 00:03:30,400
and js wrapped in native code

54
00:03:30,400 --> 00:03:34,560
to meet device and operating system

55
00:03:34,560 --> 00:03:37,519
requirement

56
00:03:38,560 --> 00:03:41,840
hybrid apps run inside

57
00:03:41,840 --> 00:03:45,040
a native app container and

58
00:03:45,040 --> 00:03:48,239
leverage the devices browser

59
00:03:48,239 --> 00:03:52,000
engine to render the html

60
00:03:52,000 --> 00:03:56,080
and process the javascript locally

61
00:03:56,080 --> 00:04:00,080
a web to native abstraction layer

62
00:04:00,080 --> 00:04:04,959
enables access to device capabilities

63
00:04:04,959 --> 00:04:09,200
that are not accessible in mobile

64
00:04:09,200 --> 00:04:12,959
web applications such as

65
00:04:12,959 --> 00:04:16,079
the accelerate transmitter

66
00:04:16,079 --> 00:04:21,440
camera and local storage

67
00:04:22,720 --> 00:04:26,160
let's look at it in more detail

68
00:04:26,160 --> 00:04:29,360
at first webwheel is an

69
00:04:29,360 --> 00:04:33,440
android wheel a wheel that displays

70
00:04:33,440 --> 00:04:37,680
the web page as rectangular

71
00:04:37,680 --> 00:04:40,720
in an android application it has

72
00:04:40,720 --> 00:04:44,160
hundreds of api webview

73
00:04:44,160 --> 00:04:47,199
is also a chromium embedder

74
00:04:47,199 --> 00:04:51,520
it is one of the six platform support

75
00:04:51,520 --> 00:04:54,240
sam compile time flags as chrome for

76
00:04:54,240 --> 00:04:55,280
android

77
00:04:55,280 --> 00:04:59,919
but lots of runtime differences

78
00:05:00,720 --> 00:05:04,000
glossing over a lot of details

79
00:05:04,000 --> 00:05:08,400
chrome desktop has lots of renders

80
00:05:08,400 --> 00:05:11,680
utility processes for services

81
00:05:11,680 --> 00:05:16,080
and the sandbox for each render

82
00:05:16,080 --> 00:05:19,199
chrom for android runs services

83
00:05:19,199 --> 00:05:22,880
in browser process instead of utility

84
00:05:22,880 --> 00:05:25,840
process

85
00:05:26,000 --> 00:05:29,199
web will run the services in the browser

86
00:05:29,199 --> 00:05:30,080
process

87
00:05:30,080 --> 00:05:33,919
as chrome for android and it only has a

88
00:05:33,919 --> 00:05:35,600
single render

89
00:05:35,600 --> 00:05:39,840
and before android 9 8

90
00:05:39,840 --> 00:05:43,919
or in the apps process even nowadays

91
00:05:43,919 --> 00:05:47,600
it is the default situation for most

92
00:05:47,600 --> 00:05:50,000
vendor

93
00:05:51,680 --> 00:05:55,280
for hybrid app there are several bridges

94
00:05:55,280 --> 00:05:55,880
between

95
00:05:55,880 --> 00:05:59,919
html and native resources

96
00:05:59,919 --> 00:06:02,960
native callbacks navigation callbacks

97
00:06:02,960 --> 00:06:06,319
javascript interfaces javascript event

98
00:06:06,319 --> 00:06:07,360
handler

99
00:06:07,360 --> 00:06:11,919
and html5 apis

100
00:06:13,440 --> 00:06:17,600
the first bridge navigation callback

101
00:06:17,600 --> 00:06:19,919
developers have the option of

102
00:06:19,919 --> 00:06:23,039
controlling navigation within webview

103
00:06:23,039 --> 00:06:25,280
whenever there is a navigation on a

104
00:06:25,280 --> 00:06:26,160
webview

105
00:06:26,160 --> 00:06:28,800
the developer can intercept this or get

106
00:06:28,800 --> 00:06:30,800
notification

107
00:06:30,800 --> 00:06:33,840
like should override ui

108
00:06:33,840 --> 00:06:37,120
loading on page finished

109
00:06:37,120 --> 00:06:40,800
on page started and should intercept

110
00:06:40,800 --> 00:06:43,440
request

111
00:06:44,080 --> 00:06:47,520
navigation callbacks are involved

112
00:06:47,520 --> 00:06:51,759
during the life cycle of navigation

113
00:06:51,759 --> 00:06:55,039
this diagram shows a part of

114
00:06:55,039 --> 00:06:58,080
timeline of what happens

115
00:06:58,080 --> 00:07:01,599
in the navigation i delete

116
00:07:01,599 --> 00:07:04,639
the initialization and

117
00:07:04,639 --> 00:07:08,800
some other steps to make it simple

118
00:07:08,800 --> 00:07:12,000
it starts in the yellow means browser

119
00:07:12,000 --> 00:07:13,440
model

120
00:07:13,440 --> 00:07:17,919
in android also means ui street

121
00:07:17,919 --> 00:07:21,280
in blue we have network service and

122
00:07:21,280 --> 00:07:24,400
in green we have render thread

123
00:07:24,400 --> 00:07:27,680
first we call a function called begin

124
00:07:27,680 --> 00:07:31,120
navigation the next step

125
00:07:31,120 --> 00:07:34,880
is to hop over to the network service

126
00:07:34,880 --> 00:07:37,759
which will actually start the url

127
00:07:37,759 --> 00:07:39,120
request

128
00:07:39,120 --> 00:07:42,240
once we hear back the response we

129
00:07:42,240 --> 00:07:45,520
jump back to the browser thread and

130
00:07:45,520 --> 00:07:49,360
choose a render thread which will show

131
00:07:49,360 --> 00:07:53,280
the page next after that

132
00:07:53,280 --> 00:07:56,560
is to tell the render to commit

133
00:07:56,560 --> 00:07:59,680
the new navigation and send

134
00:07:59,680 --> 00:08:03,840
back an ack to browser

135
00:08:03,840 --> 00:08:07,280
at this point the navigation

136
00:08:07,280 --> 00:08:11,039
is basically finished but nothing is

137
00:08:11,039 --> 00:08:14,400
shown on the page yet

138
00:08:14,400 --> 00:08:17,919
next step is read response buddy

139
00:08:17,919 --> 00:08:21,120
and render it into a web page

140
00:08:21,120 --> 00:08:24,160
once they're done it will write the

141
00:08:24,160 --> 00:08:25,440
browser known

142
00:08:25,440 --> 00:08:28,639
with another message and say okay

143
00:08:28,639 --> 00:08:31,599
stop load

144
00:08:32,080 --> 00:08:35,360
should the override url loading

145
00:08:35,360 --> 00:08:38,159
is called at the beginning in the

146
00:08:38,159 --> 00:08:38,958
function

147
00:08:38,958 --> 00:08:42,240
begin navigation should intercept the

148
00:08:42,240 --> 00:08:43,279
request

149
00:08:43,279 --> 00:08:45,920
is called when the network service

150
00:08:45,920 --> 00:08:47,440
starts url

151
00:08:47,440 --> 00:08:51,600
request unpacked started

152
00:08:51,600 --> 00:08:54,720
is called after begin navigation this

153
00:08:54,720 --> 00:08:55,360
callback

154
00:08:55,360 --> 00:08:59,440
performed different after version 72

155
00:08:59,440 --> 00:09:03,839
but i will not talk about this today

156
00:09:03,839 --> 00:09:06,720
on-page finish is called after page

157
00:09:06,720 --> 00:09:07,360
render

158
00:09:07,360 --> 00:09:11,279
is in render street

159
00:09:12,959 --> 00:09:16,399
the web view api is also allow

160
00:09:16,399 --> 00:09:19,360
inserting java objects into web wheels

161
00:09:19,360 --> 00:09:20,160
using the

162
00:09:20,160 --> 00:09:23,519
8 javascript interface method

163
00:09:23,519 --> 00:09:26,560
it registers a java object

164
00:09:26,560 --> 00:09:30,399
with a specific webview instance

165
00:09:30,399 --> 00:09:33,760
javascript loaded in the web wheel

166
00:09:33,760 --> 00:09:37,040
can have access to applications

167
00:09:37,040 --> 00:09:40,320
internal java code giving webbing

168
00:09:40,320 --> 00:09:43,440
giving web code the ability to

169
00:09:43,440 --> 00:09:46,800
interact more tightly with

170
00:09:46,800 --> 00:09:50,880
a ape and in some cases

171
00:09:50,880 --> 00:09:56,320
get access to system resources

172
00:09:57,519 --> 00:10:01,519
it is a quite convenient way to exchange

173
00:10:01,519 --> 00:10:02,800
data

174
00:10:02,800 --> 00:10:05,920
at first application create

175
00:10:05,920 --> 00:10:09,519
a java object add this object

176
00:10:09,519 --> 00:10:12,880
to web wheel with api 8

177
00:10:12,880 --> 00:10:16,320
javascript interface webview

178
00:10:16,320 --> 00:10:19,519
will create a type of object

179
00:10:19,519 --> 00:10:22,880
named jin java bond object which

180
00:10:22,880 --> 00:10:26,640
is a reflection in the browser model

181
00:10:26,640 --> 00:10:30,000
so the web wheel can interact with the

182
00:10:30,000 --> 00:10:31,200
android code

183
00:10:31,200 --> 00:10:34,800
by this object's through j and i

184
00:10:34,800 --> 00:10:38,160
random model also needs an object

185
00:10:38,160 --> 00:10:41,200
to interfere with v8 injure

186
00:10:41,200 --> 00:10:43,760
which called the gene shower bridge

187
00:10:43,760 --> 00:10:44,959
object

188
00:10:44,959 --> 00:10:48,000
this kind of object will be bound with

189
00:10:48,000 --> 00:10:48,399
an

190
00:10:48,399 --> 00:10:51,600
empty v8 object

191
00:10:51,600 --> 00:10:55,279
this empty v8 object will be injected

192
00:10:55,279 --> 00:10:58,560
into the v8 global environments

193
00:10:58,560 --> 00:11:02,000
so the javascript code running in a

194
00:11:02,000 --> 00:11:03,279
render thread

195
00:11:03,279 --> 00:11:06,480
can access the java object with

196
00:11:06,480 --> 00:11:10,560
the supplied name

197
00:11:11,440 --> 00:11:15,120
the third bridge js

198
00:11:15,120 --> 00:11:18,560
event handler the

199
00:11:18,560 --> 00:11:22,800
web wheel api allows developer

200
00:11:22,800 --> 00:11:26,399
to handle the alert promote

201
00:11:26,399 --> 00:11:29,519
and confirm javascript event

202
00:11:29,519 --> 00:11:32,640
by register the unjs

203
00:11:32,640 --> 00:11:36,160
alert unjust promote and

204
00:11:36,160 --> 00:11:42,079
unjust confirm java callback message

205
00:11:42,079 --> 00:11:45,040
whenever the javascript site called any

206
00:11:45,040 --> 00:11:45,600
of this

207
00:11:45,600 --> 00:11:49,760
event method their respectively handler

208
00:11:49,760 --> 00:11:50,399
will be

209
00:11:50,399 --> 00:11:54,240
called if it is override

210
00:11:54,240 --> 00:11:57,519
the developer is free to implement any

211
00:11:57,519 --> 00:11:58,399
logical

212
00:11:58,399 --> 00:12:02,079
in this event handler

213
00:12:02,720 --> 00:12:07,120
under the false bridge html5

214
00:12:07,120 --> 00:12:11,519
api the release of html5

215
00:12:11,519 --> 00:12:14,639
has brought in a set of apis

216
00:12:14,639 --> 00:12:16,959
that can give web applications the

217
00:12:16,959 --> 00:12:18,160
ability to access

218
00:12:18,160 --> 00:12:21,360
device hardware while javascript

219
00:12:21,360 --> 00:12:24,720
for example dual geolocation

220
00:12:24,720 --> 00:12:27,839
and get user media which enable access

221
00:12:27,839 --> 00:12:29,200
to gpas

222
00:12:29,200 --> 00:12:32,880
and to media devices such as camera

223
00:12:32,880 --> 00:12:36,480
and microphone developer

224
00:12:36,480 --> 00:12:39,760
needs to make use of undue location

225
00:12:39,760 --> 00:12:42,880
show promote and on permission

226
00:12:42,880 --> 00:12:46,800
request to grant or deny permission

227
00:12:46,800 --> 00:12:49,920
to the requests

228
00:12:50,160 --> 00:12:53,440
these bridges provide our powerful

229
00:12:53,440 --> 00:12:57,279
future but also presents security

230
00:12:57,279 --> 00:13:01,920
risks when javascript interface

231
00:13:01,920 --> 00:13:05,279
is invoked there are at least

232
00:13:05,279 --> 00:13:08,800
two op codes in javascript engine

233
00:13:08,800 --> 00:13:13,200
first get messenger as we said before

234
00:13:13,200 --> 00:13:16,320
the object we seen from javascript

235
00:13:16,320 --> 00:13:19,440
is an empty v8 object

236
00:13:19,440 --> 00:13:23,519
so render will transfer has method

237
00:13:23,519 --> 00:13:26,720
to browser model and invoke java

238
00:13:26,720 --> 00:13:28,000
built-in function

239
00:13:28,000 --> 00:13:32,160
class dot get message through gni

240
00:13:32,160 --> 00:13:35,200
certainly there will be a cache

241
00:13:35,200 --> 00:13:39,360
in jin java bound object like you think

242
00:13:39,360 --> 00:13:42,720
the return value is also template

243
00:13:42,720 --> 00:13:45,839
just used to tell the javascript code

244
00:13:45,839 --> 00:13:49,360
yes there is a function

245
00:13:49,360 --> 00:13:53,279
second invoke method it works like

246
00:13:53,279 --> 00:13:56,800
get method it use reflection

247
00:13:56,800 --> 00:13:59,839
to invoke the target method and

248
00:13:59,839 --> 00:14:04,240
reflect the return value

249
00:14:04,800 --> 00:14:10,279
and this is how cve 2012

250
00:14:10,279 --> 00:14:12,800
6336 works

251
00:14:12,800 --> 00:14:17,360
the jni invoke class dot get methods

252
00:14:17,360 --> 00:14:20,959
will return all the method this

253
00:14:20,959 --> 00:14:24,399
java object has without any

254
00:14:24,399 --> 00:14:27,839
filters also the native built-in

255
00:14:27,839 --> 00:14:32,079
runtime attacker can get remote code

256
00:14:32,079 --> 00:14:33,279
execution

257
00:14:33,279 --> 00:14:37,760
on webview with the exploit

258
00:14:38,560 --> 00:14:41,600
so google add an annotation

259
00:14:41,600 --> 00:14:44,240
javascript interface to avoid this

260
00:14:44,240 --> 00:14:45,680
situation

261
00:14:45,680 --> 00:14:49,440
get method will first validate whether

262
00:14:49,440 --> 00:14:52,399
the written method has the anointation

263
00:14:52,399 --> 00:14:54,800
javascript interface

264
00:14:54,800 --> 00:14:58,560
all java objects inject by api

265
00:14:58,560 --> 00:15:02,000
8 javascript interface will help this

266
00:15:02,000 --> 00:15:04,959
restriction

267
00:15:05,920 --> 00:15:08,880
but those who do not inject it slow at

268
00:15:08,880 --> 00:15:10,399
javascript interface

269
00:15:10,399 --> 00:15:14,600
will not it is ycvae

270
00:15:14,600 --> 00:15:17,600
2014 1939

271
00:15:17,600 --> 00:15:23,040
and cve 2014.

272
00:15:23,040 --> 00:15:27,839
six double to fall occurs

273
00:15:29,199 --> 00:15:32,320
another well-known issue is

274
00:15:32,320 --> 00:15:36,720
if clone attack if web will

275
00:15:36,720 --> 00:15:39,440
set this 3 function true or default

276
00:15:39,440 --> 00:15:40,639
value

277
00:15:40,639 --> 00:15:43,519
attacker can still user's private file

278
00:15:43,519 --> 00:15:45,040
with a malicious

279
00:15:45,040 --> 00:15:49,839
local file with the help of set a low

280
00:15:49,839 --> 00:15:52,160
file access

281
00:15:52,160 --> 00:15:55,440
webview can load a local page

282
00:15:55,440 --> 00:15:59,279
with set a low file access from url

283
00:15:59,279 --> 00:16:02,560
this local page could access any private

284
00:16:02,560 --> 00:16:03,360
file

285
00:16:03,360 --> 00:16:07,120
with apps permission

286
00:16:07,440 --> 00:16:11,199
after get private files from target app

287
00:16:11,199 --> 00:16:13,839
attacker can totally clone a victim

288
00:16:13,839 --> 00:16:14,880
account

289
00:16:14,880 --> 00:16:18,480
in 20 000 miles away and victim

290
00:16:18,480 --> 00:16:23,120
may not get aware

291
00:16:23,120 --> 00:16:28,000
some html5 api can also be abused

292
00:16:28,000 --> 00:16:31,519
for example geolocation

293
00:16:31,519 --> 00:16:35,279
if the value set due location level is

294
00:16:35,279 --> 00:16:36,720
true

295
00:16:36,720 --> 00:16:39,440
and the callback on geolocation

296
00:16:39,440 --> 00:16:40,320
permission

297
00:16:40,320 --> 00:16:44,959
should promote do not ask for user

298
00:16:44,959 --> 00:16:49,600
host solarization attacker can use the

299
00:16:49,600 --> 00:16:52,959
file api navigator dot

300
00:16:52,959 --> 00:16:56,240
get geolocation dot get current position

301
00:16:56,240 --> 00:17:00,240
to get user due location remotely

302
00:17:00,240 --> 00:17:05,039
without any notification

303
00:17:05,039 --> 00:17:07,599
however the most common bridge problem

304
00:17:07,599 --> 00:17:08,079
is

305
00:17:08,079 --> 00:17:11,439
javascript interface abuse

306
00:17:11,439 --> 00:17:13,760
some app manufacturers prefer to

307
00:17:13,760 --> 00:17:16,400
implement a sensitive filter

308
00:17:16,400 --> 00:17:19,839
in javascript interface for example

309
00:17:19,839 --> 00:17:23,359
get user token access local file install

310
00:17:23,359 --> 00:17:26,879
other apps and other

311
00:17:27,280 --> 00:17:29,760
inject the supplied java object into

312
00:17:29,760 --> 00:17:30,799
webview

313
00:17:30,799 --> 00:17:33,600
the object is injected into all frames

314
00:17:33,600 --> 00:17:34,000
of

315
00:17:34,000 --> 00:17:37,520
web page including all the iframes

316
00:17:37,520 --> 00:17:40,559
using the supplied name these allow the

317
00:17:40,559 --> 00:17:42,400
java object's methods

318
00:17:42,400 --> 00:17:46,400
to be accessed from javascript

319
00:17:46,400 --> 00:17:48,720
the android developer document has

320
00:17:48,720 --> 00:17:49,600
warning

321
00:17:49,600 --> 00:17:52,080
there is no way to tell the calling

322
00:17:52,080 --> 00:17:52,640
frames

323
00:17:52,640 --> 00:17:56,080
orange from the website so the app must

324
00:17:56,080 --> 00:17:57,760
not assume that the caller is

325
00:17:57,760 --> 00:17:58,880
trustworthy

326
00:17:58,880 --> 00:18:02,160
unless the app can guarantee that no

327
00:18:02,160 --> 00:18:04,080
third party content

328
00:18:04,080 --> 00:18:07,600
is ever loaded into webview

329
00:18:07,600 --> 00:18:11,120
but in real world these important

330
00:18:11,120 --> 00:18:14,880
tips is not always fulfilled

331
00:18:14,880 --> 00:18:17,640
applications usually need to load

332
00:18:17,640 --> 00:18:19,760
unexpected

333
00:18:19,760 --> 00:18:24,320
web page for some business reason

334
00:18:25,600 --> 00:18:28,480
in this case to use the javascript

335
00:18:28,480 --> 00:18:30,080
interface safely

336
00:18:30,080 --> 00:18:32,960
manufacturers would perform app specific

337
00:18:32,960 --> 00:18:34,480
security checks

338
00:18:34,480 --> 00:18:38,480
to ensure the javascript interface

339
00:18:38,480 --> 00:18:42,799
can only be invoked by specific urls

340
00:18:42,799 --> 00:18:45,520
there are many fantastic designation but

341
00:18:45,520 --> 00:18:47,039
no matter what

342
00:18:47,039 --> 00:18:50,080
seg checks are see how to rely

343
00:18:50,080 --> 00:18:54,400
on the url get from webview

344
00:18:54,400 --> 00:18:57,840
there are two widely used machinism

345
00:18:57,840 --> 00:19:00,160
lifecycle-based access control and the

346
00:19:00,160 --> 00:19:00,960
real-time

347
00:19:00,960 --> 00:19:05,360
access control lifecycle best access

348
00:19:05,360 --> 00:19:06,240
control

349
00:19:06,240 --> 00:19:10,160
gets the url from the navigation

350
00:19:10,160 --> 00:19:12,880
callbacks like should override url

351
00:19:12,880 --> 00:19:13,760
loading

352
00:19:13,760 --> 00:19:17,840
and unpack started these callbacks will

353
00:19:17,840 --> 00:19:20,480
be invoked during the life cycle

354
00:19:20,480 --> 00:19:24,400
of navigation from different models

355
00:19:24,400 --> 00:19:28,000
as we stated before application

356
00:19:28,000 --> 00:19:31,039
will get url from these callbacks and

357
00:19:31,039 --> 00:19:34,960
sell as current url when there is

358
00:19:34,960 --> 00:19:37,760
a js bridge call application will treat

359
00:19:37,760 --> 00:19:38,000
this

360
00:19:38,000 --> 00:19:41,039
call as from

361
00:19:41,039 --> 00:19:44,480
that url

362
00:19:46,400 --> 00:19:49,600
this is a demo code application

363
00:19:49,600 --> 00:19:50,960
manufacturer

364
00:19:50,960 --> 00:19:54,080
get value from should override url

365
00:19:54,080 --> 00:19:57,280
loading and save it to a

366
00:19:57,280 --> 00:20:00,720
viable current host

367
00:20:00,720 --> 00:20:03,919
when the javascript interface get token

368
00:20:03,919 --> 00:20:06,320
worked it will check whether the current

369
00:20:06,320 --> 00:20:07,120
host

370
00:20:07,120 --> 00:20:10,879
is authorization

371
00:20:11,360 --> 00:20:15,520
this machinism is proved to be unsafe

372
00:20:15,520 --> 00:20:19,120
attacker can use time delay attack

373
00:20:19,120 --> 00:20:22,880
to bypass this call access control

374
00:20:22,880 --> 00:20:26,000
attacker first trigger navigation to

375
00:20:26,000 --> 00:20:28,559
change the variable current url

376
00:20:28,559 --> 00:20:32,559
after that js bridge call from the evo

377
00:20:32,559 --> 00:20:35,679
web app will treat us from the new

378
00:20:35,679 --> 00:20:38,799
trusted web app

379
00:20:38,799 --> 00:20:42,320
in the diagram you can see

380
00:20:42,320 --> 00:20:46,080
where and when it happened either should

381
00:20:46,080 --> 00:20:48,240
override url loading or

382
00:20:48,240 --> 00:20:51,520
on-page started is invoked before

383
00:20:51,520 --> 00:20:54,880
all the render page unloaded

384
00:20:54,880 --> 00:20:58,480
and as long as there is a new navigation

385
00:20:58,480 --> 00:21:01,760
the access control url will be replaced

386
00:21:01,760 --> 00:21:05,280
by the new one and there is a time

387
00:21:05,280 --> 00:21:06,559
window

388
00:21:06,559 --> 00:21:09,840
between callbacks and old render

389
00:21:09,840 --> 00:21:14,480
unloaded therefore any old rendering

390
00:21:14,480 --> 00:21:17,679
javascript interface in working in this

391
00:21:17,679 --> 00:21:18,720
window

392
00:21:18,720 --> 00:21:23,679
will be treated as from new render

393
00:21:24,559 --> 00:21:28,240
this is a real world exploit

394
00:21:28,240 --> 00:21:31,440
location will trigger navigation and fix

395
00:21:31,440 --> 00:21:33,520
the life cycle callback

396
00:21:33,520 --> 00:21:37,280
zeus sets the wrong current url

397
00:21:37,280 --> 00:21:40,960
with the help of set timeout that token

398
00:21:40,960 --> 00:21:44,400
will be executed after navigation zeus

399
00:21:44,400 --> 00:21:48,480
the access control will be bypassed

400
00:21:48,480 --> 00:21:51,840
so nowadays mao and my application

401
00:21:51,840 --> 00:21:54,880
use real time access control

402
00:21:54,880 --> 00:21:58,240
they do not get url from callbacks

403
00:21:58,240 --> 00:22:02,400
but use webwill.get url immensely

404
00:22:02,400 --> 00:22:06,880
when javascript interface is invoked

405
00:22:08,480 --> 00:22:11,760
we know that javascript interacts with

406
00:22:11,760 --> 00:22:14,080
java object on a private

407
00:22:14,080 --> 00:22:17,679
background street of webview so

408
00:22:17,679 --> 00:22:20,960
this solution user runnable

409
00:22:20,960 --> 00:22:25,520
to maintain street safety

410
00:22:25,679 --> 00:22:28,320
with the help of real-time access

411
00:22:28,320 --> 00:22:29,440
control

412
00:22:29,440 --> 00:22:32,400
the traditional time delay attack will

413
00:22:32,400 --> 00:22:33,679
not work

414
00:22:33,679 --> 00:22:37,440
because webwill.geturl may not

415
00:22:37,440 --> 00:22:40,960
affect it by javascript code

416
00:22:40,960 --> 00:22:43,840
in most cases

417
00:22:46,159 --> 00:22:49,600
so next i will show you the news written

418
00:22:49,600 --> 00:22:52,720
a totally new attack model

419
00:22:52,720 --> 00:22:55,600
will affect real-time access talk

420
00:22:55,600 --> 00:22:56,880
control

421
00:22:56,880 --> 00:22:59,360
as well

422
00:23:00,480 --> 00:23:03,320
let's dig into the function

423
00:23:03,320 --> 00:23:05,360
webwill.geturl

424
00:23:05,360 --> 00:23:08,799
it's not that simple as we think before

425
00:23:08,799 --> 00:23:11,919
actually the function can return

426
00:23:11,919 --> 00:23:15,360
two kinds of value pending entry

427
00:23:15,360 --> 00:23:18,720
and the last committed entry

428
00:23:18,720 --> 00:23:22,240
generally to say when the function is

429
00:23:22,240 --> 00:23:24,559
called after browser initiative

430
00:23:24,559 --> 00:23:25,600
navigation

431
00:23:25,600 --> 00:23:29,280
it will return pending entry

432
00:23:29,280 --> 00:23:31,440
when this function is called after a

433
00:23:31,440 --> 00:23:33,919
render initiates the navigation

434
00:23:33,919 --> 00:23:39,039
it's written last committed entry

435
00:23:39,039 --> 00:23:42,000
it seems interesting that during

436
00:23:42,000 --> 00:23:42,559
different

437
00:23:42,559 --> 00:23:47,120
types of navigation webwill.geturl

438
00:23:47,120 --> 00:23:51,439
will return different value

439
00:23:51,840 --> 00:23:54,960
there are two types of navigation

440
00:23:54,960 --> 00:23:57,840
browser initiative navigation and the

441
00:23:57,840 --> 00:23:59,120
render initiative

442
00:23:59,120 --> 00:24:03,600
navigation render initiated navigation

443
00:24:03,600 --> 00:24:07,120
start from render process this

444
00:24:07,120 --> 00:24:11,520
would be like click a link user form

445
00:24:11,520 --> 00:24:14,720
or just a piece of script

446
00:24:14,720 --> 00:24:18,480
it is less trustworthy because bad web

447
00:24:18,480 --> 00:24:19,279
pages

448
00:24:19,279 --> 00:24:23,200
can try to send you bad places

449
00:24:23,200 --> 00:24:26,400
but not internal pads

450
00:24:26,400 --> 00:24:28,400
we also have browser initiative

451
00:24:28,400 --> 00:24:29,520
navigations

452
00:24:29,520 --> 00:24:33,200
steam from url

453
00:24:33,200 --> 00:24:37,279
omi box bookmarks

454
00:24:37,279 --> 00:24:40,880
contact menus and other ui

455
00:24:40,880 --> 00:24:44,400
interaction navigation

456
00:24:44,480 --> 00:24:48,400
this is a timeline of browser initiative

457
00:24:48,400 --> 00:24:49,520
navigation

458
00:24:49,520 --> 00:24:53,200
as we've seen before pending entry

459
00:24:53,200 --> 00:24:55,679
will be set at the beginning of

460
00:24:55,679 --> 00:24:58,400
navigation in browser model

461
00:24:58,400 --> 00:25:01,679
and last committed entry is set

462
00:25:01,679 --> 00:25:06,400
after the render page is committed

463
00:25:06,400 --> 00:25:09,919
this is a timeline of render initiative

464
00:25:09,919 --> 00:25:11,200
navigation

465
00:25:11,200 --> 00:25:13,440
the only difference in the navigation

466
00:25:13,440 --> 00:25:14,720
form is that

467
00:25:14,720 --> 00:25:18,400
it will start to render and the setting

468
00:25:18,400 --> 00:25:22,080
will not set pending entry

469
00:25:22,080 --> 00:25:25,360
will not set panning

470
00:25:25,440 --> 00:25:28,799
in hybrid app rendering initiative

471
00:25:28,799 --> 00:25:29,919
navigation

472
00:25:29,919 --> 00:25:33,440
can be cheated by javascript code

473
00:25:33,440 --> 00:25:36,640
so it is untrusted and need

474
00:25:36,640 --> 00:25:39,919
lots of verification to ensure

475
00:25:39,919 --> 00:25:43,279
the context is no temping

476
00:25:43,279 --> 00:25:46,320
browser initiative navigation is

477
00:25:46,320 --> 00:25:49,840
triggered by load url

478
00:25:49,840 --> 00:25:53,120
most of time it is trustable

479
00:25:53,120 --> 00:25:56,240
browser initiative navigation will set

480
00:25:56,240 --> 00:25:58,799
pending entry at the beginning of

481
00:25:58,799 --> 00:25:59,919
navigation

482
00:25:59,919 --> 00:26:03,360
and return it during get url

483
00:26:03,360 --> 00:26:06,559
while render initiating the navigation

484
00:26:06,559 --> 00:26:11,120
not let's summarize

485
00:26:11,120 --> 00:26:15,360
for browser-initiated navigation get url

486
00:26:15,360 --> 00:26:18,480
will return the new url

487
00:26:18,480 --> 00:26:21,360
even before the old random model

488
00:26:21,360 --> 00:26:23,120
unloaded

489
00:26:23,120 --> 00:26:25,679
render initiative navigation it will

490
00:26:25,679 --> 00:26:26,240
return

491
00:26:26,240 --> 00:26:30,000
all the render url before the new one

492
00:26:30,000 --> 00:26:32,960
is committed

493
00:26:34,400 --> 00:26:37,279
it seems ok for a general desktop

494
00:26:37,279 --> 00:26:38,480
chromium

495
00:26:38,480 --> 00:26:41,279
best browser these two types of

496
00:26:41,279 --> 00:26:42,240
navigation

497
00:26:42,240 --> 00:26:45,760
is strictly compartmentalized

498
00:26:45,760 --> 00:26:49,200
in general desktop browser but in some

499
00:26:49,200 --> 00:26:52,400
other cases like webview in android

500
00:26:52,400 --> 00:26:55,600
things get different webview

501
00:26:55,600 --> 00:26:58,480
has some specific machinism a low

502
00:26:58,480 --> 00:27:00,080
javascript codes

503
00:27:00,080 --> 00:27:03,200
interact with native this means

504
00:27:03,200 --> 00:27:06,400
javascript code in webview is more

505
00:27:06,400 --> 00:27:07,440
powerful

506
00:27:07,440 --> 00:27:10,159
than in general browser and some

507
00:27:10,159 --> 00:27:11,600
assumption

508
00:27:11,600 --> 00:27:14,720
for browser is no longer suitable

509
00:27:14,720 --> 00:27:18,240
for hybrid app

510
00:27:18,240 --> 00:27:21,360
let's get back to the get url

511
00:27:21,360 --> 00:27:24,960
as it said in the comment the pen entry

512
00:27:24,960 --> 00:27:27,640
is set to return for new

513
00:27:27,640 --> 00:27:29,919
browser-initiated navigation

514
00:27:29,919 --> 00:27:33,200
most render initiated navigations

515
00:27:33,200 --> 00:27:36,880
should not show the pending to prevent

516
00:27:36,880 --> 00:27:40,960
url spoofing attacks

517
00:27:40,960 --> 00:27:44,000
in hybrid app browser

518
00:27:44,000 --> 00:27:47,200
initiative navigation can also be

519
00:27:47,200 --> 00:27:48,159
invoked

520
00:27:48,159 --> 00:27:51,520
by render model with bridges

521
00:27:51,520 --> 00:27:54,640
in this case the code will treat

522
00:27:54,640 --> 00:27:57,039
the javascript code trigger the

523
00:27:57,039 --> 00:27:58,159
navigation

524
00:27:58,159 --> 00:28:02,000
as a pure browser initiative navigation

525
00:28:02,000 --> 00:28:05,600
and the written pending entry which

526
00:28:05,600 --> 00:28:10,719
may not be the current url

527
00:28:10,880 --> 00:28:13,919
in another word if

528
00:28:13,919 --> 00:28:16,720
developers do not know the difference

529
00:28:16,720 --> 00:28:17,720
between

530
00:28:17,720 --> 00:28:20,480
browser-initiated navigation and

531
00:28:20,480 --> 00:28:23,760
render initiative navigation there

532
00:28:23,760 --> 00:28:27,279
will be a vulnerability

533
00:28:27,279 --> 00:28:31,760
and azir where our talk

534
00:28:31,760 --> 00:28:35,279
this new attack called navigation

535
00:28:35,279 --> 00:28:40,080
confused vulnerability

536
00:28:42,559 --> 00:28:45,600
we have found three vulnerability models

537
00:28:45,600 --> 00:28:48,960
in real world first one

538
00:28:48,960 --> 00:28:51,720
direct navigation confuse the

539
00:28:51,720 --> 00:28:54,480
vulnerability

540
00:28:54,480 --> 00:28:58,120
if application expose webwill

541
00:28:58,120 --> 00:28:59,360
webwheel.load.url

542
00:28:59,360 --> 00:29:03,279
through javascript interface directory

543
00:29:03,279 --> 00:29:06,720
and evil javascript code could use this

544
00:29:06,720 --> 00:29:08,559
javascript interface

545
00:29:08,559 --> 00:29:12,559
to invoke a browser-initiated navigation

546
00:29:12,559 --> 00:29:15,679
from render mode therefore

547
00:29:15,679 --> 00:29:20,240
the url get from webwill.geturl is not

548
00:29:20,240 --> 00:29:24,159
trustable it will return pending entry

549
00:29:24,159 --> 00:29:26,960
any validation based on this value will

550
00:29:26,960 --> 00:29:27,360
be

551
00:29:27,360 --> 00:29:30,158
bypassed

552
00:29:30,399 --> 00:29:33,440
in real world applications

553
00:29:33,440 --> 00:29:38,159
may not implement logical that simple

554
00:29:38,399 --> 00:29:42,799
but they prefer to do like this

555
00:29:42,960 --> 00:29:46,000
for some secrecy agreement

556
00:29:46,000 --> 00:29:49,520
i could not tell what apes are so

557
00:29:49,520 --> 00:29:53,520
let's just focus on the code itself

558
00:29:53,520 --> 00:29:56,080
the interface check login accept a

559
00:29:56,080 --> 00:29:57,200
parameter

560
00:29:57,200 --> 00:30:00,799
destination url and if the

561
00:30:00,799 --> 00:30:04,000
current login status is fulfilled it

562
00:30:04,000 --> 00:30:06,559
will load destination url

563
00:30:06,559 --> 00:30:09,679
with webwill.log url

564
00:30:09,679 --> 00:30:13,039
therefore untrusted javascript

565
00:30:13,039 --> 00:30:14,880
can trigger a trustful browser

566
00:30:14,880 --> 00:30:18,159
initiative navigation

567
00:30:19,120 --> 00:30:22,320
attacker called bridge

568
00:30:22,320 --> 00:30:25,760
check login to invoke webwheel.load.url

569
00:30:25,760 --> 00:30:28,480
it is a browser initiative navigation

570
00:30:28,480 --> 00:30:30,559
browser initiative navigation

571
00:30:30,559 --> 00:30:34,159
will set pending entry then attacker

572
00:30:34,159 --> 00:30:37,360
called get token this bridge get url

573
00:30:37,360 --> 00:30:38,320
from api

574
00:30:38,320 --> 00:30:42,159
webwill dot get url

575
00:30:42,159 --> 00:30:45,039
during browser-initiated navigation

576
00:30:45,039 --> 00:30:45,760
webview

577
00:30:45,760 --> 00:30:50,399
dot get url will written pending g

578
00:30:50,399 --> 00:30:53,678
the fake url

579
00:30:54,159 --> 00:30:57,200
this exploit looks like

580
00:30:57,200 --> 00:31:00,880
a normal time delay attack

581
00:31:00,880 --> 00:31:04,480
use set time out to post postpone get

582
00:31:04,480 --> 00:31:08,240
token use jsbridge.check

583
00:31:08,240 --> 00:31:11,360
login to trigger a browser initiate the

584
00:31:11,360 --> 00:31:12,799
navigation

585
00:31:12,799 --> 00:31:16,840
and the webview.geturl in

586
00:31:16,840 --> 00:31:18,480
jsbridge.gettoken

587
00:31:18,480 --> 00:31:21,679
will return panning entry

588
00:31:21,679 --> 00:31:25,440
google.com a url in whitelist

589
00:31:25,440 --> 00:31:29,919
and bypass the verification

590
00:31:30,559 --> 00:31:33,840
second model redirect

591
00:31:33,840 --> 00:31:38,159
navigation confused vulnerability

592
00:31:38,159 --> 00:31:42,000
if application calls webwill.log url

593
00:31:42,000 --> 00:31:44,960
in a navigation curve box it will

594
00:31:44,960 --> 00:31:45,760
convert

595
00:31:45,760 --> 00:31:49,480
render initiating navigation into

596
00:31:49,480 --> 00:31:52,240
browser-initiated navigation

597
00:31:52,240 --> 00:31:55,440
this evo javascript code

598
00:31:55,440 --> 00:31:58,840
could use this callbacks to trigger and

599
00:31:58,840 --> 00:32:01,120
browser-initiated navigation

600
00:32:01,120 --> 00:32:04,720
from render mode it is a real

601
00:32:04,720 --> 00:32:08,240
bad idea apps should never

602
00:32:08,240 --> 00:32:11,440
ever do this but it

603
00:32:11,440 --> 00:32:15,200
is extremely common thanks to the

604
00:32:15,200 --> 00:32:19,519
really widely copied past online

605
00:32:19,519 --> 00:32:22,399
you can find lots of examples on stake

606
00:32:22,399 --> 00:32:25,120
overflow

607
00:32:25,279 --> 00:32:28,880
in real world we find two typical

608
00:32:28,880 --> 00:32:32,480
misuse if the redirect url

609
00:32:32,480 --> 00:32:36,000
matched a specific partner apps

610
00:32:36,000 --> 00:32:39,039
think it is a protocol message

611
00:32:39,039 --> 00:32:42,080
and will extract another url inside

612
00:32:42,080 --> 00:32:45,918
it and load this one

613
00:32:46,000 --> 00:32:50,000
in the demo code if request the url

614
00:32:50,000 --> 00:32:53,039
match scheme protocol it will

615
00:32:53,039 --> 00:32:56,240
be treated as a protocol message and get

616
00:32:56,240 --> 00:32:59,519
parameter fullback url as a

617
00:32:59,519 --> 00:33:02,480
new target

618
00:33:02,799 --> 00:33:06,000
attacker can use location to trigger a

619
00:33:06,000 --> 00:33:08,320
render initiative navigation

620
00:33:08,320 --> 00:33:10,320
a render initiates initiative navigation

621
00:33:10,320 --> 00:33:11,440
will trigger

622
00:33:11,440 --> 00:33:15,120
should override url loading a specific

623
00:33:15,120 --> 00:33:16,159
url

624
00:33:16,159 --> 00:33:18,559
you should override url loading will

625
00:33:18,559 --> 00:33:20,519
invoke

626
00:33:20,519 --> 00:33:23,440
webwill.getual

627
00:33:23,440 --> 00:33:26,240
the render initiative navigation is

628
00:33:26,240 --> 00:33:27,200
converted

629
00:33:27,200 --> 00:33:31,039
into a browser initiated navigation

630
00:33:31,039 --> 00:33:34,080
then attacker

631
00:33:34,080 --> 00:33:37,519
called get token this bridge

632
00:33:37,519 --> 00:33:41,519
get url from api webview

633
00:33:41,519 --> 00:33:45,519
dot get url webview

634
00:33:45,519 --> 00:33:49,440
dot get url will return

635
00:33:49,440 --> 00:33:52,640
pending entry and this is the

636
00:33:52,640 --> 00:33:55,279
wrong way

637
00:33:56,159 --> 00:34:00,640
the exploit look like this the location

638
00:34:00,640 --> 00:34:03,679
is a specific url start

639
00:34:03,679 --> 00:34:07,679
with scheme protocol

640
00:34:07,679 --> 00:34:10,719
should override url loading will

641
00:34:10,719 --> 00:34:14,960
extract parameter full back url

642
00:34:14,960 --> 00:34:17,159
and will trigger another

643
00:34:17,159 --> 00:34:20,639
browser-initiated navigation

644
00:34:20,639 --> 00:34:25,839
the webwill.geturlinjs.gettoken

645
00:34:25,839 --> 00:34:29,280
will return the pending entry

646
00:34:29,280 --> 00:34:33,280
which is google.com a url

647
00:34:33,280 --> 00:34:36,800
in whitelist and bypass

648
00:34:36,800 --> 00:34:40,639
the verification

649
00:34:40,800 --> 00:34:43,918
another common misused like

650
00:34:43,918 --> 00:34:47,280
this when the orange

651
00:34:47,280 --> 00:34:51,199
redirect url is not matched

652
00:34:51,199 --> 00:34:54,480
a specific partner

653
00:34:54,480 --> 00:34:57,680
for example in this code

654
00:34:57,680 --> 00:35:00,960
if the redirect url

655
00:35:00,960 --> 00:35:06,000
do not start with recharge.com

656
00:35:06,000 --> 00:35:09,359
hybrid app will think it is

657
00:35:09,359 --> 00:35:13,760
a illegal url and

658
00:35:13,760 --> 00:35:17,520
would be redirect to a hard coded

659
00:35:17,520 --> 00:35:20,720
legal url which usually

660
00:35:20,720 --> 00:35:24,160
in white list

661
00:35:26,079 --> 00:35:31,839
attacker can write exploit like before

662
00:35:35,520 --> 00:35:38,880
third one shelled navigation

663
00:35:38,880 --> 00:35:44,320
confused vulnerability

664
00:35:44,320 --> 00:35:47,520
compared to the last two models

665
00:35:47,520 --> 00:35:50,720
this one is more puzzled

666
00:35:50,720 --> 00:35:54,880
if the launch mode of the activity

667
00:35:54,880 --> 00:35:58,480
who holding web wheel is single task

668
00:35:58,480 --> 00:36:02,000
or single instance the

669
00:36:02,000 --> 00:36:05,119
web wheel could be

670
00:36:05,119 --> 00:36:09,040
reused a specific

671
00:36:09,040 --> 00:36:14,000
deep link could launch this activity

672
00:36:14,000 --> 00:36:17,760
and the load page in web view

673
00:36:17,760 --> 00:36:22,000
if you invoke deep link twice

674
00:36:22,000 --> 00:36:25,440
two wireless pads would

675
00:36:25,440 --> 00:36:28,480
display but there will be only

676
00:36:28,480 --> 00:36:31,760
one webview object

677
00:36:31,760 --> 00:36:35,200
therefore all

678
00:36:35,200 --> 00:36:39,880
deep link could be convert into a

679
00:36:39,880 --> 00:36:42,640
browser-initiated navigation

680
00:36:42,640 --> 00:36:47,200
a same web wheel object

681
00:36:47,200 --> 00:36:50,320
it has the same effect

682
00:36:50,320 --> 00:36:54,880
as last two models

683
00:36:54,880 --> 00:36:58,880
maybe a diagram will be clearly

684
00:36:58,880 --> 00:37:02,079
if a web wheel launch mode

685
00:37:02,079 --> 00:37:05,839
is single task there will be

686
00:37:05,839 --> 00:37:09,040
only one webview object

687
00:37:09,040 --> 00:37:13,119
and any deep link will be convert

688
00:37:13,119 --> 00:37:16,400
to load url in this

689
00:37:16,400 --> 00:37:20,880
single one in the diagram

690
00:37:20,880 --> 00:37:25,760
is a.com and b dot com

691
00:37:29,119 --> 00:37:32,880
thus we find another way to invoke

692
00:37:32,880 --> 00:37:35,440
browser initiative navigation from

693
00:37:35,440 --> 00:37:36,800
random model

694
00:37:36,800 --> 00:37:41,280
in the diagram you can see the c.com

695
00:37:41,280 --> 00:37:46,560
is also loaded in the web wheel

696
00:37:49,680 --> 00:37:52,800
there are two ways to attack

697
00:37:52,800 --> 00:37:56,040
shelled navigation confused

698
00:37:56,040 --> 00:37:59,599
vulnerability if web wheel

699
00:37:59,599 --> 00:38:03,440
can trigger deep link itself

700
00:38:03,440 --> 00:38:06,720
it's quite simple

701
00:38:07,760 --> 00:38:10,960
attacker use location to trigger

702
00:38:10,960 --> 00:38:14,079
a deep link and the launch mode of the

703
00:38:14,079 --> 00:38:15,040
web wheel

704
00:38:15,040 --> 00:38:19,520
is single task and this deep link

705
00:38:19,520 --> 00:38:22,640
will be converted into a browser

706
00:38:22,640 --> 00:38:25,040
initiative navigation

707
00:38:25,040 --> 00:38:28,160
and the web wheel will be reused

708
00:38:28,160 --> 00:38:31,680
and the web build cor

709
00:38:31,680 --> 00:38:34,800
and deep link sorry a deep link will be

710
00:38:34,800 --> 00:38:35,520
converted

711
00:38:35,520 --> 00:38:38,160
into a browser initiative navigation and

712
00:38:38,160 --> 00:38:38,720
set

713
00:38:38,720 --> 00:38:43,280
the url in deep link to pen entry

714
00:38:43,280 --> 00:38:48,240
during access control webwill.geturl

715
00:38:48,240 --> 00:38:51,440
will return the pending entry

716
00:38:51,440 --> 00:38:56,240
then attacker called get token

717
00:38:56,240 --> 00:39:00,240
this bridge get url from webwheel

718
00:39:00,240 --> 00:39:03,839
dot get url and certainly

719
00:39:03,839 --> 00:39:07,440
this is a fake url

720
00:39:08,480 --> 00:39:11,680
we can do exploit like this just

721
00:39:11,680 --> 00:39:14,640
like before location will trigger deep

722
00:39:14,640 --> 00:39:15,599
link

723
00:39:15,599 --> 00:39:19,680
and launch web wheel due to the single

724
00:39:19,680 --> 00:39:21,359
task launch mode

725
00:39:21,359 --> 00:39:24,400
web wheel will be reused

726
00:39:24,400 --> 00:39:27,760
and it will launch a browser

727
00:39:27,760 --> 00:39:32,079
initiated navigation in the current

728
00:39:32,079 --> 00:39:35,920
webview and affected the written value

729
00:39:35,920 --> 00:39:41,680
of webwill.get url

730
00:39:41,680 --> 00:39:44,720
if target web will cannot

731
00:39:44,720 --> 00:39:47,759
trigger deep link

732
00:39:48,079 --> 00:39:52,800
we need a third pass browser help

733
00:39:54,079 --> 00:39:57,280
attacker need to trigger dblink twice in

734
00:39:57,280 --> 00:40:01,280
circumstances first dblink

735
00:40:01,280 --> 00:40:04,960
load attacker side to get token

736
00:40:04,960 --> 00:40:08,079
and the second db link load

737
00:40:08,079 --> 00:40:11,119
and the full url to

738
00:40:11,119 --> 00:40:14,240
bypass verification

739
00:40:14,240 --> 00:40:19,119
use js event with ability change

740
00:40:19,119 --> 00:40:22,800
to do this automatically

741
00:40:22,800 --> 00:40:26,720
this event will fire when the content

742
00:40:26,720 --> 00:40:30,160
of its tab has become visible

743
00:40:30,160 --> 00:40:34,640
or have been hidden

744
00:40:36,880 --> 00:40:40,160
this exploits work in some

745
00:40:40,160 --> 00:40:44,800
third part browser like quack

746
00:40:44,800 --> 00:40:47,240
the function attack will load

747
00:40:47,240 --> 00:40:49,040
attacker.site

748
00:40:49,040 --> 00:40:52,480
in target webview

749
00:40:52,480 --> 00:40:57,280
and due to the deep link

750
00:40:57,280 --> 00:41:00,960
the third part browser is hide

751
00:41:00,960 --> 00:41:04,000
and the event visible

752
00:41:04,000 --> 00:41:07,839
visibility change will be fired

753
00:41:07,839 --> 00:41:11,200
and after a short delay the event

754
00:41:11,200 --> 00:41:12,400
handler

755
00:41:12,400 --> 00:41:16,400
will load google.com

756
00:41:16,400 --> 00:41:20,400
through deep link in the same

757
00:41:20,400 --> 00:41:24,319
web wheel and

758
00:41:24,319 --> 00:41:27,680
the verification will be passed

759
00:41:27,680 --> 00:41:30,319
as before

760
00:41:33,040 --> 00:41:36,319
these are the vulnerability models

761
00:41:36,319 --> 00:41:39,440
we find so far and

762
00:41:39,440 --> 00:41:45,359
i believe it is just a tape of iceberg

763
00:41:46,400 --> 00:41:49,200
next i will show you how to mitigate

764
00:41:49,200 --> 00:41:51,839
this kind of vulnerability

765
00:41:51,839 --> 00:41:55,280
because for some business reason the web

766
00:41:55,280 --> 00:41:57,440
page that needs to be loaded

767
00:41:57,440 --> 00:42:01,119
is not easy to be modified so

768
00:42:01,119 --> 00:42:03,920
most of the time we could only enforce

769
00:42:03,920 --> 00:42:04,640
our

770
00:42:04,640 --> 00:42:07,359
application

771
00:42:07,760 --> 00:42:10,960
to help you find these vulnerabilities

772
00:42:10,960 --> 00:42:14,079
we developed another tour that can

773
00:42:14,079 --> 00:42:18,480
vet android apps automatically

774
00:42:18,480 --> 00:42:22,000
it is a pass search tour based on

775
00:42:22,000 --> 00:42:25,040
android god it has three

776
00:42:25,040 --> 00:42:28,319
simple logical to find this three

777
00:42:28,319 --> 00:42:31,520
vulnerability model

778
00:42:31,520 --> 00:42:35,200
it find a path from javascript interface

779
00:42:35,200 --> 00:42:38,480
to webview dot load url

780
00:42:38,480 --> 00:42:40,720
and find a path from navigation

781
00:42:40,720 --> 00:42:41,839
callbacks

782
00:42:41,839 --> 00:42:44,880
to webwill.url and

783
00:42:44,880 --> 00:42:47,599
try to find the single task launch mode

784
00:42:47,599 --> 00:42:48,880
activity

785
00:42:48,880 --> 00:42:52,160
holding webview

786
00:42:53,839 --> 00:42:57,040
due to the problem is root from webview

787
00:42:57,040 --> 00:42:58,400
native code

788
00:42:58,400 --> 00:43:01,359
android developer actually have less to

789
00:43:01,359 --> 00:43:02,319
do

790
00:43:02,319 --> 00:43:04,480
they can only try to avoid the

791
00:43:04,480 --> 00:43:06,319
vulnerability models

792
00:43:06,319 --> 00:43:11,119
i noticed before but it is not enough

793
00:43:11,119 --> 00:43:14,240
as i said this 3 model is

794
00:43:14,240 --> 00:43:18,640
just tips of iceberg

795
00:43:19,680 --> 00:43:23,920
so we come up with rich interface

796
00:43:23,920 --> 00:43:27,280
and enforcement in a deeper site

797
00:43:27,280 --> 00:43:30,079
we change the way web will invoke java

798
00:43:30,079 --> 00:43:31,280
objects

799
00:43:31,280 --> 00:43:33,839
this diagram shows how rich interface

800
00:43:33,839 --> 00:43:35,680
worked

801
00:43:35,680 --> 00:43:39,040
let's reminder how javascript interface

802
00:43:39,040 --> 00:43:42,400
worked a v8 object

803
00:43:42,400 --> 00:43:46,640
in js engine a gene java bridge object

804
00:43:46,640 --> 00:43:50,240
in render and a genjar bond object in

805
00:43:50,240 --> 00:43:53,440
browser and finally

806
00:43:53,440 --> 00:43:56,880
the java object we noticed

807
00:43:56,880 --> 00:44:00,319
that in browser model we can clearly

808
00:44:00,319 --> 00:44:00,880
know

809
00:44:00,880 --> 00:44:04,800
where this in work come from

810
00:44:04,800 --> 00:44:08,000
but this important information was

811
00:44:08,000 --> 00:44:11,359
banned during gni

812
00:44:11,359 --> 00:44:13,598
core

813
00:44:15,920 --> 00:44:19,520
reach interface will do another explicit

814
00:44:19,520 --> 00:44:20,160
jni

815
00:44:20,160 --> 00:44:23,599
car transfer the url

816
00:44:23,599 --> 00:44:26,960
so the verification can get

817
00:44:26,960 --> 00:44:30,560
a correct data the only change

818
00:44:30,560 --> 00:44:34,560
application needs is add a set url

819
00:44:34,560 --> 00:44:38,640
javascript interface in the java object

820
00:44:38,640 --> 00:44:42,960
to receive the message the time window

821
00:44:42,960 --> 00:44:46,280
between set url and actual

822
00:44:46,280 --> 00:44:49,440
javascript interface call is

823
00:44:49,440 --> 00:44:55,040
small enough to be ignored

824
00:44:55,520 --> 00:44:59,440
this is a demo using rich

825
00:44:59,440 --> 00:45:02,480
interface we can see it is

826
00:45:02,480 --> 00:45:05,520
quite simple the only thing you need

827
00:45:05,520 --> 00:45:09,920
to do is add a javascript interface

828
00:45:09,920 --> 00:45:12,960
named set url

829
00:45:12,960 --> 00:45:15,720
and this bridge will be called

830
00:45:15,720 --> 00:45:17,040
automatically

831
00:45:17,040 --> 00:45:21,759
when the bridge get token is called

832
00:45:22,160 --> 00:45:26,319
before reach interface application

833
00:45:26,319 --> 00:45:29,839
can not get the correct url from web

834
00:45:29,839 --> 00:45:30,839
wheel

835
00:45:30,839 --> 00:45:34,319
attacker can use navigation confused

836
00:45:34,319 --> 00:45:38,079
vulnerability to bypass the white list

837
00:45:38,079 --> 00:45:41,680
checker after reach interface

838
00:45:41,680 --> 00:45:44,960
application can get url

839
00:45:44,960 --> 00:45:48,800
from javascript interface directly

840
00:45:48,800 --> 00:45:52,720
any attack try to abuse url

841
00:45:52,720 --> 00:45:55,760
could not work

842
00:45:55,760 --> 00:45:58,880
what's more other mitigations like

843
00:45:58,880 --> 00:46:02,079
no frank or jackal is also

844
00:46:02,079 --> 00:46:05,839
worked thanks for the awesome

845
00:46:05,839 --> 00:46:09,040
care there

846
00:46:09,040 --> 00:46:12,480
are two lessons we learned first

847
00:46:12,480 --> 00:46:15,920
document will lead us whether we have

848
00:46:15,920 --> 00:46:17,200
read the document

849
00:46:17,200 --> 00:46:20,640
before we use the api both app clone

850
00:46:20,640 --> 00:46:21,520
attack

851
00:46:21,520 --> 00:46:24,560
and navigation confuse the vulnerability

852
00:46:24,560 --> 00:46:27,599
are caused by inaccurate

853
00:46:27,599 --> 00:46:30,960
reading of the document and

854
00:46:30,960 --> 00:46:34,880
in a declined understanding

855
00:46:35,280 --> 00:46:38,319
second for cross-platform

856
00:46:38,319 --> 00:46:42,480
framework some preconditions may not

857
00:46:42,480 --> 00:46:43,280
meet

858
00:46:43,280 --> 00:46:46,720
in every platform

859
00:46:48,880 --> 00:46:53,040
and this is all thanks

860
00:46:53,040 --> 00:46:56,160
to all my team matter

861
00:46:56,160 --> 00:47:08,160
and thank you for your attention

