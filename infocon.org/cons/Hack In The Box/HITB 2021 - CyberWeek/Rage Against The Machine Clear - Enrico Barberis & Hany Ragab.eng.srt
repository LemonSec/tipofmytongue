1
00:00:09,040 --> 00:00:10,240
welcome to

2
00:00:10,240 --> 00:00:12,160
our talk name the rage against the

3
00:00:12,160 --> 00:00:13,599
machine clear

4
00:00:13,599 --> 00:00:15,519
systematic analysis of machine clears

5
00:00:15,519 --> 00:00:16,880
and their implications for transcendent

6
00:00:16,880 --> 00:00:19,600
execution attacks

7
00:00:19,600 --> 00:00:22,400
this was a joint work with me enrico

8
00:00:22,400 --> 00:00:25,519
barbaris and henry raghav

9
00:00:25,519 --> 00:00:27,439
and our professors herbert bose and

10
00:00:27,439 --> 00:00:29,840
christina giufrida and all of us are

11
00:00:29,840 --> 00:00:32,719
coming from the rusec security group in

12
00:00:32,719 --> 00:00:35,280
amsterdam

13
00:00:35,520 --> 00:00:36,490
today we are going to

14
00:00:36,490 --> 00:00:38,079
[Music]

15
00:00:38,079 --> 00:00:39,520
present in

16
00:00:39,520 --> 00:00:42,079
this slots we start with some background

17
00:00:42,079 --> 00:00:44,239
later we are going to focus on the main

18
00:00:44,239 --> 00:00:46,640
topic of the presentation that is

19
00:00:46,640 --> 00:00:49,440
machine clears and later we are showing

20
00:00:49,440 --> 00:00:51,680
a full end and exploit on

21
00:00:51,680 --> 00:00:54,239
on firefox with uh with a demo and

22
00:00:54,239 --> 00:00:58,480
finally we conclude with some results

23
00:00:58,480 --> 00:01:00,320
before deep diving into

24
00:01:00,320 --> 00:01:02,399
washing clears let's have a small

25
00:01:02,399 --> 00:01:04,319
background section

26
00:01:04,319 --> 00:01:06,799
and all this work is based on site

27
00:01:06,799 --> 00:01:07,840
channel

28
00:01:07,840 --> 00:01:09,840
so what is a channel

29
00:01:09,840 --> 00:01:11,200
in a nutshell

30
00:01:11,200 --> 00:01:14,000
an attacker by observing side effects of

31
00:01:14,000 --> 00:01:17,119
a system can infer some secret

32
00:01:17,119 --> 00:01:19,759
data for example here

33
00:01:19,759 --> 00:01:22,240
with a stethoscope an attacker can hear

34
00:01:22,240 --> 00:01:23,360
the

35
00:01:23,360 --> 00:01:25,280
safe and

36
00:01:25,280 --> 00:01:27,280
discover the secret combination to open

37
00:01:27,280 --> 00:01:28,400
the safe

38
00:01:28,400 --> 00:01:30,799
again this is not an intended the

39
00:01:30,799 --> 00:01:33,040
communication channel is a side effect

40
00:01:33,040 --> 00:01:35,200
but still we can use this

41
00:01:35,200 --> 00:01:37,200
leakage or information to

42
00:01:37,200 --> 00:01:38,840
obtain

43
00:01:38,840 --> 00:01:40,640
information but

44
00:01:40,640 --> 00:01:44,399
all these apply to modern processor so

45
00:01:44,399 --> 00:01:45,200
um

46
00:01:45,200 --> 00:01:47,280
before we saw a time

47
00:01:47,280 --> 00:01:49,680
sound say channel sorry on processor

48
00:01:49,680 --> 00:01:52,000
usually we use timings a channel it is

49
00:01:52,000 --> 00:01:53,360
way more reliable

50
00:01:53,360 --> 00:01:56,560
and the most common way to observe this

51
00:01:56,560 --> 00:01:59,360
kind of leakage information is through

52
00:01:59,360 --> 00:02:02,560
flush and reload attack

53
00:02:02,560 --> 00:02:04,399
so let's have a very simple example to

54
00:02:04,399 --> 00:02:05,520
explain it

55
00:02:05,520 --> 00:02:07,680
we have the data cache that is in

56
00:02:07,680 --> 00:02:09,199
on the bottom

57
00:02:09,199 --> 00:02:11,200
where we have some entries of an array

58
00:02:11,200 --> 00:02:13,360
stored in this cache so the green one

59
00:02:13,360 --> 00:02:15,680
will be cached and the gray one will not

60
00:02:15,680 --> 00:02:18,080
be cached at the beginning some entries

61
00:02:18,080 --> 00:02:19,520
will be cached some other entries will

62
00:02:19,520 --> 00:02:20,879
not

63
00:02:20,879 --> 00:02:23,680
the first step is to bring this cache to

64
00:02:23,680 --> 00:02:25,200
a known state

65
00:02:25,200 --> 00:02:29,440
by for example flashing the entire cache

66
00:02:29,440 --> 00:02:30,400
then

67
00:02:30,400 --> 00:02:33,040
the victim will execute a snippet of

68
00:02:33,040 --> 00:02:34,720
code for example like this one that

69
00:02:34,720 --> 00:02:37,360
depending of a secret value so a bit of

70
00:02:37,360 --> 00:02:40,480
a crypto key will either access r80 or

71
00:02:40,480 --> 00:02:42,640
ra1 for example

72
00:02:42,640 --> 00:02:44,560
and let's say that in our example we are

73
00:02:44,560 --> 00:02:46,400
accessing the first entry of the array

74
00:02:46,400 --> 00:02:49,360
so array one

75
00:02:49,680 --> 00:02:51,519
and this will bring array1 into the

76
00:02:51,519 --> 00:02:52,560
cache

77
00:02:52,560 --> 00:02:54,800
later the attacker by performing the

78
00:02:54,800 --> 00:02:56,080
reload step

79
00:02:56,080 --> 00:02:59,200
will measure the timing for every

80
00:02:59,200 --> 00:03:01,200
access time for each entry of the array

81
00:03:01,200 --> 00:03:03,440
so the first one that was never accessed

82
00:03:03,440 --> 00:03:05,040
will be quite slow

83
00:03:05,040 --> 00:03:07,120
the second one instead since was loaded

84
00:03:07,120 --> 00:03:10,000
by the victim will be much faster and

85
00:03:10,000 --> 00:03:11,920
just by measuring this delta time

86
00:03:11,920 --> 00:03:13,840
between slow and fast

87
00:03:13,840 --> 00:03:15,760
an attacker can observe what the victim

88
00:03:15,760 --> 00:03:19,840
executed does leaking the key

89
00:03:20,159 --> 00:03:22,080
but all these actually

90
00:03:22,080 --> 00:03:23,120
become

91
00:03:23,120 --> 00:03:24,879
very interesting

92
00:03:24,879 --> 00:03:26,799
is with transient execution or

93
00:03:26,799 --> 00:03:29,519
speculative execution

94
00:03:29,519 --> 00:03:32,400
so let's combine these uh cache side

95
00:03:32,400 --> 00:03:35,519
channel with specular execution

96
00:03:35,519 --> 00:03:37,360
let's look at this uh simple snippet of

97
00:03:37,360 --> 00:03:39,280
code a very

98
00:03:39,280 --> 00:03:42,319
common piece of code so bounded array

99
00:03:42,319 --> 00:03:44,640
access so before accessing an array

100
00:03:44,640 --> 00:03:46,239
you're checking it is in the bounded

101
00:03:46,239 --> 00:03:47,440
size

102
00:03:47,440 --> 00:03:49,440
and let's suppose that the array size

103
00:03:49,440 --> 00:03:51,680
for some reason for example is a

104
00:03:51,680 --> 00:03:53,760
coming from a long memory operation is

105
00:03:53,760 --> 00:03:56,959
not available uh immediately

106
00:03:56,959 --> 00:04:00,159
the processor must

107
00:04:00,400 --> 00:04:02,319
well you would prefer to speculatively

108
00:04:02,319 --> 00:04:04,239
execute the

109
00:04:04,239 --> 00:04:06,319
the inner branch of the linear code of

110
00:04:06,319 --> 00:04:07,360
the branch

111
00:04:07,360 --> 00:04:09,519
to optimize the speed execution so the

112
00:04:09,519 --> 00:04:11,599
pressure is betting that the branch will

113
00:04:11,599 --> 00:04:14,080
be taken and the memory access will be

114
00:04:14,080 --> 00:04:16,320
executed

115
00:04:16,320 --> 00:04:18,880
but this is indeed a speculation what

116
00:04:18,880 --> 00:04:20,798
happens if this is

117
00:04:20,798 --> 00:04:22,720
a wrong one

118
00:04:22,720 --> 00:04:24,639
well the processor must revert the

119
00:04:24,639 --> 00:04:26,400
execution

120
00:04:26,400 --> 00:04:30,080
and roll back to the other branch

121
00:04:30,080 --> 00:04:31,600
to execute

122
00:04:31,600 --> 00:04:33,680
but still as you can see in this slide

123
00:04:33,680 --> 00:04:34,479
the

124
00:04:34,479 --> 00:04:36,560
array at position x is still in the

125
00:04:36,560 --> 00:04:37,840
cache so

126
00:04:37,840 --> 00:04:40,080
this trace is still there an attacker

127
00:04:40,080 --> 00:04:41,280
can still

128
00:04:41,280 --> 00:04:42,880
discover this

129
00:04:42,880 --> 00:04:44,960
liquid like this

130
00:04:44,960 --> 00:04:47,520
observe inside channel sorry

131
00:04:47,520 --> 00:04:48,479
and

132
00:04:48,479 --> 00:04:51,199
as you can see combining these two

133
00:04:51,199 --> 00:04:54,160
primitives so speculative execution and

134
00:04:54,160 --> 00:04:57,040
say channel an attacker is not only

135
00:04:57,040 --> 00:04:58,720
capable of observing what the victim is

136
00:04:58,720 --> 00:05:00,240
executing but also

137
00:05:00,240 --> 00:05:02,320
to observe what the processor is

138
00:05:02,320 --> 00:05:05,039
executing in a speculative path so wrong

139
00:05:05,039 --> 00:05:07,759
path it is never committed

140
00:05:07,759 --> 00:05:09,840
and again we can recover what the person

141
00:05:09,840 --> 00:05:13,600
did again using the timings each other

142
00:05:13,600 --> 00:05:15,520
just with these two primitives in the

143
00:05:15,520 --> 00:05:18,639
last years many attacks were discovered

144
00:05:18,639 --> 00:05:21,280
let's start by late 2017 we told you

145
00:05:21,280 --> 00:05:24,080
know the most famous spectra in meldon

146
00:05:24,080 --> 00:05:26,400
that probably all of you know

147
00:05:26,400 --> 00:05:28,639
and after that month after month new

148
00:05:28,639 --> 00:05:31,039
attacks variant popped up

149
00:05:31,039 --> 00:05:33,360
for example in 2018

150
00:05:33,360 --> 00:05:37,120
micro tutorial sampling brought a lot of

151
00:05:37,120 --> 00:05:38,560
variants as you can see

152
00:05:38,560 --> 00:05:41,039
where basically an attacker can

153
00:05:41,039 --> 00:05:43,280
basically can break every barrier in the

154
00:05:43,280 --> 00:05:45,440
single physical core

155
00:05:45,440 --> 00:05:47,680
for example we have the riddle load

156
00:05:47,680 --> 00:05:50,320
value injection and many other attacks

157
00:05:50,320 --> 00:05:52,400
then after 2020

158
00:05:52,400 --> 00:05:53,919
we even

159
00:05:53,919 --> 00:05:56,400
crossed this border by leaking across

160
00:05:56,400 --> 00:05:59,919
multiple cores on the same cpu die

161
00:05:59,919 --> 00:06:01,120
and now

162
00:06:01,120 --> 00:06:04,400
we are presenting two new complete

163
00:06:04,400 --> 00:06:06,560
attack primitives that are named the

164
00:06:06,560 --> 00:06:08,560
floating point wheel injection and the

165
00:06:08,560 --> 00:06:10,400
speculative store bypass that we're

166
00:06:10,400 --> 00:06:13,679
going to present today

167
00:06:16,639 --> 00:06:17,680
all right

168
00:06:17,680 --> 00:06:19,120
so

169
00:06:19,120 --> 00:06:22,720
let's look first at the main class of of

170
00:06:22,720 --> 00:06:24,240
these

171
00:06:24,240 --> 00:06:26,319
of all these trans execution attacks so

172
00:06:26,319 --> 00:06:27,120
here

173
00:06:27,120 --> 00:06:29,680
uh intel defines bad speculation as the

174
00:06:29,680 --> 00:06:31,440
root cause of discarding

175
00:06:31,440 --> 00:06:34,720
issued micro creations on x86 processors

176
00:06:34,720 --> 00:06:37,280
and it defines this bad speculation in

177
00:06:37,280 --> 00:06:38,880
two main subclasses the first one is

178
00:06:38,880 --> 00:06:40,960
branches prediction which we just

179
00:06:40,960 --> 00:06:44,000
saw and it's basically when a branch

180
00:06:44,000 --> 00:06:45,840
predictor mispredicts either the

181
00:06:45,840 --> 00:06:48,400
direction or a target of a branch and

182
00:06:48,400 --> 00:06:50,800
the second class is machine clear where

183
00:06:50,800 --> 00:06:53,120
a machine clear condition when it occurs

184
00:06:53,120 --> 00:06:55,199
it flushes the entire pipeline and

185
00:06:55,199 --> 00:06:56,479
resumes the execution from the last

186
00:06:56,479 --> 00:06:58,560
retail instruction so it's not waiting

187
00:06:58,560 --> 00:07:00,800
to mispredict the branch it's a

188
00:07:00,800 --> 00:07:03,039
deterministic condition that once it

189
00:07:03,039 --> 00:07:05,039
occurs it flushes the entire pipeline

190
00:07:05,039 --> 00:07:06,319
and resumes from less retired

191
00:07:06,319 --> 00:07:07,360
instruction

192
00:07:07,360 --> 00:07:08,720
well branch misprediction have been

193
00:07:08,720 --> 00:07:11,759
widely explored on for example spectre

194
00:07:11,759 --> 00:07:13,840
and along with different types of faults

195
00:07:13,840 --> 00:07:16,160
and different ways of aborting an insult

196
00:07:16,160 --> 00:07:18,960
tsx transaction all these three methods

197
00:07:18,960 --> 00:07:21,199
have been widely explained on all in all

198
00:07:21,199 --> 00:07:23,680
previous trans execution attacks

199
00:07:23,680 --> 00:07:25,840
uh the class of machine clear

200
00:07:25,840 --> 00:07:28,880
remains widely unexplored until now so

201
00:07:28,880 --> 00:07:30,720
everyone that wanted to create a transit

202
00:07:30,720 --> 00:07:32,960
execution path it had either to create a

203
00:07:32,960 --> 00:07:36,160
fault or aborted intel tsx transaction

204
00:07:36,160 --> 00:07:38,400
or mistrain branch predictor and

205
00:07:38,400 --> 00:07:41,520
mispredict but no one explored the other

206
00:07:41,520 --> 00:07:43,759
ways of creating these execution paths

207
00:07:43,759 --> 00:07:45,680
that fall under the class of machine

208
00:07:45,680 --> 00:07:47,680
clear and this is what we did in this

209
00:07:47,680 --> 00:07:49,680
work

210
00:07:49,680 --> 00:07:52,160
so in this work we performed the reverse

211
00:07:52,160 --> 00:07:54,800
engineering the the security analysis of

212
00:07:54,800 --> 00:07:56,400
the four main types of machine clear

213
00:07:56,400 --> 00:07:58,319
which are self-modifying code floating

214
00:07:58,319 --> 00:07:59,360
point

215
00:07:59,360 --> 00:08:00,960
memory ordering and

216
00:08:00,960 --> 00:08:04,000
memory examination machine player

217
00:08:04,000 --> 00:08:06,080
two of these four types of machine clear

218
00:08:06,080 --> 00:08:08,639
led us to obtain a completely new

219
00:08:08,639 --> 00:08:11,120
transit execution attack based attack

220
00:08:11,120 --> 00:08:13,039
primitive the first one is called

221
00:08:13,039 --> 00:08:14,960
speculative code store bypass which is

222
00:08:14,960 --> 00:08:16,400
based on a self-modifying code machine

223
00:08:16,400 --> 00:08:17,919
player and the second one is called

224
00:08:17,919 --> 00:08:19,599
floating point value injection which is

225
00:08:19,599 --> 00:08:21,599
based on top of a floating point machine

226
00:08:21,599 --> 00:08:23,840
clear

227
00:08:25,360 --> 00:08:27,199
furthermore uh the floating point value

228
00:08:27,199 --> 00:08:28,879
injection attack primitive led us to

229
00:08:28,879 --> 00:08:31,680
mount an end-to-end exploit uh leaking

230
00:08:31,680 --> 00:08:33,120
advertising memory addresses inside the

231
00:08:33,120 --> 00:08:35,039
firefox web browser with the leakage

232
00:08:35,039 --> 00:08:37,279
rate that can reach up to 30 kilobytes

233
00:08:37,279 --> 00:08:39,360
per second

234
00:08:39,360 --> 00:08:41,279
so in order to understand uh all these

235
00:08:41,279 --> 00:08:42,719
types of fusion clear and how a machine

236
00:08:42,719 --> 00:08:44,959
clear i can actually work we first try

237
00:08:44,959 --> 00:08:46,160
to understand what is the architectural

238
00:08:46,160 --> 00:08:48,320
environment upon which machine clear is

239
00:08:48,320 --> 00:08:49,360
based

240
00:08:49,360 --> 00:08:51,920
how this invariant can be violated and

241
00:08:51,920 --> 00:08:54,080
therefore triggering a machine clear or

242
00:08:54,080 --> 00:08:55,760
a pipeline flush

243
00:08:55,760 --> 00:08:58,560
how this environment violation

244
00:08:58,560 --> 00:09:00,080
what is the security implication of this

245
00:09:00,080 --> 00:09:01,200
violation

246
00:09:01,200 --> 00:09:03,279
and finally how this violation can be

247
00:09:03,279 --> 00:09:05,680
exploited

248
00:09:05,680 --> 00:09:06,959
so the first type of fashion clear that

249
00:09:06,959 --> 00:09:09,040
we are going to look at is software

250
00:09:09,040 --> 00:09:10,640
defined code machine player and a

251
00:09:10,640 --> 00:09:13,600
self-modifying code is a program storing

252
00:09:13,600 --> 00:09:16,080
instructions as data modifying its own

253
00:09:16,080 --> 00:09:17,760
execution

254
00:09:17,760 --> 00:09:19,200
modifying its own code while it's being

255
00:09:19,200 --> 00:09:20,959
executed

256
00:09:20,959 --> 00:09:22,480
let's take a look at this example the

257
00:09:22,480 --> 00:09:23,680
snippet of code where we have two

258
00:09:23,680 --> 00:09:25,680
instructions the first instruction is

259
00:09:25,680 --> 00:09:27,440
modifying the following instruction

260
00:09:27,440 --> 00:09:29,360
modifying it from changing it from a

261
00:09:29,360 --> 00:09:32,880
load secret to a new operation

262
00:09:33,360 --> 00:09:36,399
modern front end of my cpus

263
00:09:36,399 --> 00:09:38,160
try to in order to maximize the

264
00:09:38,160 --> 00:09:40,720
execution throughput will fetch the code

265
00:09:40,720 --> 00:09:43,200
and execute speculatively well ahead of

266
00:09:43,200 --> 00:09:44,720
retirement well ahead of the

267
00:09:44,720 --> 00:09:46,480
architectural retirement point

268
00:09:46,480 --> 00:09:48,959
and whenever a front end of motor cpu

269
00:09:48,959 --> 00:09:50,640
will detect

270
00:09:50,640 --> 00:09:52,640
a store instruction trying to modify

271
00:09:52,640 --> 00:09:54,240
code that has been already fetched

272
00:09:54,240 --> 00:09:55,920
decoded alex you executed so it's

273
00:09:55,920 --> 00:09:58,320
already residing in the in the pipeline

274
00:09:58,320 --> 00:10:00,880
it will have to flush its pipeline from

275
00:10:00,880 --> 00:10:03,440
the previously uh and speculatively

276
00:10:03,440 --> 00:10:05,279
executed instruction in this case the no

277
00:10:05,279 --> 00:10:07,040
the no operation sorry in this case the

278
00:10:07,040 --> 00:10:08,640
load secret that was already in the

279
00:10:08,640 --> 00:10:10,959
pipeline and fetch the code and execute

280
00:10:10,959 --> 00:10:13,040
the new code that has been uh that is

281
00:10:13,040 --> 00:10:14,399
being stored in this case the no

282
00:10:14,399 --> 00:10:15,920
operation because this is what the

283
00:10:15,920 --> 00:10:18,640
program is doing it needs to modify uh

284
00:10:18,640 --> 00:10:20,480
the code and therefore the the

285
00:10:20,480 --> 00:10:23,839
instruction stream inside the front end

286
00:10:23,839 --> 00:10:26,320
but since this detection of a

287
00:10:26,320 --> 00:10:28,399
self-modifying code is not immediate

288
00:10:28,399 --> 00:10:31,120
this creates a transient window or

289
00:10:31,120 --> 00:10:32,480
some uh

290
00:10:32,480 --> 00:10:36,000
time window where the cpu has already

291
00:10:36,000 --> 00:10:37,680
fetched decoded and executed the state

292
00:10:37,680 --> 00:10:40,079
codes which was already in the pipeline

293
00:10:40,079 --> 00:10:42,079
in this case the load secret and as we

294
00:10:42,079 --> 00:10:44,640
saw earlier through a cover channel

295
00:10:44,640 --> 00:10:47,760
we can leak uh the side effects of this

296
00:10:47,760 --> 00:10:50,560
stale execution of the load secret

297
00:10:50,560 --> 00:10:52,399
and therefore

298
00:10:52,399 --> 00:10:54,880
and therefore it will uh try to flash

299
00:10:54,880 --> 00:10:57,279
its pipeline from the cell code and uh

300
00:10:57,279 --> 00:10:58,560
try to

301
00:10:58,560 --> 00:11:01,839
execute the new code

302
00:11:02,000 --> 00:11:03,519
so the architectural environment here is

303
00:11:03,519 --> 00:11:04,959
that store

304
00:11:04,959 --> 00:11:07,360
store instructions always target

305
00:11:07,360 --> 00:11:10,160
data memory addresses

306
00:11:10,160 --> 00:11:11,360
this

307
00:11:11,360 --> 00:11:13,600
architectural environment is violated in

308
00:11:13,600 --> 00:11:14,959
the case of self-modifying code which

309
00:11:14,959 --> 00:11:15,680
does

310
00:11:15,680 --> 00:11:18,079
exactly the opposite where it targets

311
00:11:18,079 --> 00:11:20,399
code memory addresses instead

312
00:11:20,399 --> 00:11:22,560
this invariant validation allows an

313
00:11:22,560 --> 00:11:24,560
attacker to transiently execute state

314
00:11:24,560 --> 00:11:27,040
code which is in this case the load

315
00:11:27,040 --> 00:11:28,399
secret

316
00:11:28,399 --> 00:11:30,320
and in order to understand what how we

317
00:11:30,320 --> 00:11:32,320
can exploit such uh

318
00:11:32,320 --> 00:11:34,079
such behavior we needna said what is the

319
00:11:34,079 --> 00:11:35,360
attack primitive that this type of

320
00:11:35,360 --> 00:11:38,720
machine layer provides us with

321
00:11:38,720 --> 00:11:41,519
so a speculative code store bypass is an

322
00:11:41,519 --> 00:11:44,160
attack primitive that is built on top of

323
00:11:44,160 --> 00:11:47,120
a transit execution window created by a

324
00:11:47,120 --> 00:11:49,040
software code machine clear which allows

325
00:11:49,040 --> 00:11:52,240
an attacker to execute state code under

326
00:11:52,240 --> 00:11:54,839
its control

327
00:11:54,839 --> 00:11:57,040
uh let's take

328
00:11:57,040 --> 00:11:58,480
let's take a look at the three main

329
00:11:58,480 --> 00:12:00,160
steps of this uh attack parameter but

330
00:12:00,160 --> 00:12:02,240
first keep in mind that codes and data

331
00:12:02,240 --> 00:12:05,200
views are always uh coherent between

332
00:12:05,200 --> 00:12:06,880
between each other and there are two

333
00:12:06,880 --> 00:12:08,720
different views of the same memory the

334
00:12:08,720 --> 00:12:10,880
same addresses

335
00:12:10,880 --> 00:12:12,880
so in the first step of

336
00:12:12,880 --> 00:12:14,639
a csb we

337
00:12:14,639 --> 00:12:17,760
did uh the code of function f to perform

338
00:12:17,760 --> 00:12:19,839
the store step of a self-modifying code

339
00:12:19,839 --> 00:12:21,360
where we need to store code and then

340
00:12:21,360 --> 00:12:23,680
execute it in this case to store codes

341
00:12:23,680 --> 00:12:25,920
under attacker control we did a function

342
00:12:25,920 --> 00:12:26,959
f

343
00:12:26,959 --> 00:12:29,120
and we did it in at the same address

344
00:12:29,120 --> 00:12:30,880
where the code of function g is already

345
00:12:30,880 --> 00:12:33,200
residing in in memory

346
00:12:33,200 --> 00:12:34,959
in this case we do it through data

347
00:12:34,959 --> 00:12:36,639
because this is how self-referent code

348
00:12:36,639 --> 00:12:40,959
works it tries to store code as data

349
00:12:41,200 --> 00:12:43,120
the second step as we see here we are

350
00:12:43,120 --> 00:12:45,040
creating a temporary synchronization

351
00:12:45,040 --> 00:12:47,440
between code view and data view where

352
00:12:47,440 --> 00:12:50,160
the code view will contain will continue

353
00:12:50,160 --> 00:12:52,480
to contain the previously fetched

354
00:12:52,480 --> 00:12:54,480
decoded and executed

355
00:12:54,480 --> 00:12:56,639
code which is function g but the data

356
00:12:56,639 --> 00:12:59,120
view will contain the freshly stored

357
00:12:59,120 --> 00:13:01,600
code which is in this case function f

358
00:13:01,600 --> 00:13:03,440
creating this temporary synchronization

359
00:13:03,440 --> 00:13:06,320
between code and data

360
00:13:06,320 --> 00:13:08,160
eventually the cpu will detect that

361
00:13:08,160 --> 00:13:10,639
there has been a soft modifying code and

362
00:13:10,639 --> 00:13:12,560
will issue a machine clear flushing its

363
00:13:12,560 --> 00:13:15,440
own pipeline from the previous and sale

364
00:13:15,440 --> 00:13:20,200
code which in this case function g

365
00:13:20,560 --> 00:13:22,560
so yeah at this step um

366
00:13:22,560 --> 00:13:24,160
even before like flushing the the

367
00:13:24,160 --> 00:13:26,160
pipeline if we get to the point that we

368
00:13:26,160 --> 00:13:27,760
have actually to call

369
00:13:27,760 --> 00:13:30,639
the function that we just stored

370
00:13:30,639 --> 00:13:32,240
the processor will take the code

371
00:13:32,240 --> 00:13:34,079
residing at that address from the code

372
00:13:34,079 --> 00:13:35,760
view it will not take the one that we

373
00:13:35,760 --> 00:13:37,200
just wrote in

374
00:13:37,200 --> 00:13:40,000
because it has no no notion at this

375
00:13:40,000 --> 00:13:42,000
point at this point of

376
00:13:42,000 --> 00:13:44,000
a software front code so it needs to

377
00:13:44,000 --> 00:13:45,920
fetch whatever was in the code view

378
00:13:45,920 --> 00:13:48,880
executed transiently then trigger

379
00:13:48,880 --> 00:13:51,680
machine clear then as a last step we

380
00:13:51,680 --> 00:13:54,000
re-synchronize code and data to resume

381
00:13:54,000 --> 00:13:56,880
the coherency that was uh that was there

382
00:13:56,880 --> 00:13:58,480
before

383
00:13:58,480 --> 00:14:02,920
before the software encode program

384
00:14:03,440 --> 00:14:05,120
so during our reverse engineering of

385
00:14:05,120 --> 00:14:07,519
this behavior uh we looked at the

386
00:14:07,519 --> 00:14:10,160
developer manuals of intel to see how

387
00:14:10,160 --> 00:14:11,839
they suggest to handle self-motion code

388
00:14:11,839 --> 00:14:13,120
and cross modifying codes on their

389
00:14:13,120 --> 00:14:15,760
processors and we see that there are two

390
00:14:15,760 --> 00:14:18,320
basically two options uh to handle this

391
00:14:18,320 --> 00:14:20,880
and interestingly option one uh that

392
00:14:20,880 --> 00:14:23,199
intel is suggesting to users in order to

393
00:14:23,199 --> 00:14:24,480
handle self-referent code and custom

394
00:14:24,480 --> 00:14:26,959
reference code is describing the exact

395
00:14:26,959 --> 00:14:29,839
steps of our attack primitive

396
00:14:29,839 --> 00:14:32,560
which means that any program or any

397
00:14:32,560 --> 00:14:35,279
software uh relying on adopting option

398
00:14:35,279 --> 00:14:38,320
one to handle software defined code is

399
00:14:38,320 --> 00:14:40,560
uh speculatively performing a

400
00:14:40,560 --> 00:14:42,480
speculative code store bypass attack

401
00:14:42,480 --> 00:14:44,480
without knowing this

402
00:14:44,480 --> 00:14:46,160
because again

403
00:14:46,160 --> 00:14:48,160
option one is relying on the fact that

404
00:14:48,160 --> 00:14:51,040
uh code and data are coherent all the

405
00:14:51,040 --> 00:14:52,079
time

406
00:14:52,079 --> 00:14:53,839
this is true on the architectural side

407
00:14:53,839 --> 00:14:55,839
but but on the microcontextual side this

408
00:14:55,839 --> 00:14:57,600
can be violated this coherence can be

409
00:14:57,600 --> 00:14:58,560
broken

410
00:14:58,560 --> 00:15:01,360
in the case of a self-refined code

411
00:15:01,360 --> 00:15:04,320
in fact the two main web browsers used

412
00:15:04,320 --> 00:15:06,079
by millions of users

413
00:15:06,079 --> 00:15:07,279
are basically

414
00:15:07,279 --> 00:15:09,120
not performing any

415
00:15:09,120 --> 00:15:10,880
any operation whatsoever when they try

416
00:15:10,880 --> 00:15:14,079
to store new code which is the exact use

417
00:15:14,079 --> 00:15:16,480
case of our attack primitive where an

418
00:15:16,480 --> 00:15:18,560
attacker control code can be used so an

419
00:15:18,560 --> 00:15:19,760
attacker

420
00:15:19,760 --> 00:15:22,000
can get whatever javascript code they

421
00:15:22,000 --> 00:15:22,880
want

422
00:15:22,880 --> 00:15:25,440
which will be stored so creating and

423
00:15:25,440 --> 00:15:26,560
performing the store step of a

424
00:15:26,560 --> 00:15:28,399
self-modifying code and later at some

425
00:15:28,399 --> 00:15:30,480
point this jitted code will be executed

426
00:15:30,480 --> 00:15:32,800
and therefore execute instead of code

427
00:15:32,800 --> 00:15:34,560
and as we can see here both chrome and

428
00:15:34,560 --> 00:15:36,560
firefox are not doing anything to avoid

429
00:15:36,560 --> 00:15:39,360
this behavior because they are relying

430
00:15:39,360 --> 00:15:41,519
on option one that intel is suggesting

431
00:15:41,519 --> 00:15:46,000
in the uh in the developer manual

432
00:15:46,000 --> 00:15:49,440
so for exploiting uh smc we have

433
00:15:49,440 --> 00:15:50,720
speculative code survey pass which

434
00:15:50,720 --> 00:15:52,399
allows an attacker to execute state code

435
00:15:52,399 --> 00:15:54,160
which is somehow similar to its

436
00:15:54,160 --> 00:15:56,240
architecture counterpart uses the free

437
00:15:56,240 --> 00:15:58,800
attack primitive where an attack

438
00:15:58,800 --> 00:16:02,000
is accessing a memory that is not

439
00:16:02,000 --> 00:16:05,040
referenced anymore

440
00:16:05,519 --> 00:16:06,720
the second type of machine cloud that

441
00:16:06,720 --> 00:16:08,800
we're looking at today is called memory

442
00:16:08,800 --> 00:16:11,120
ordering machine clear which is based on

443
00:16:11,120 --> 00:16:12,160
a total

444
00:16:12,160 --> 00:16:13,920
order model memory model which is the

445
00:16:13,920 --> 00:16:16,240
one adapted by and implemented by intel

446
00:16:16,240 --> 00:16:18,160
in their cpus

447
00:16:18,160 --> 00:16:19,519
which is a memory model that guarantees

448
00:16:19,519 --> 00:16:21,680
that all cpu cores see all memory

449
00:16:21,680 --> 00:16:22,959
operations

450
00:16:22,959 --> 00:16:26,880
as the program order except one case

451
00:16:26,880 --> 00:16:29,040
a story where source instruction

452
00:16:29,040 --> 00:16:31,440
followed by a load instruction um

453
00:16:31,440 --> 00:16:33,440
operating on different addresses these

454
00:16:33,440 --> 00:16:36,320
two may be reordered so violating the

455
00:16:36,320 --> 00:16:38,399
the program order

456
00:16:38,399 --> 00:16:40,160
let's take a look at this example where

457
00:16:40,160 --> 00:16:42,079
we have processor a performing two load

458
00:16:42,079 --> 00:16:44,399
instructions and then a function call on

459
00:16:44,399 --> 00:16:46,079
the resulting

460
00:16:46,079 --> 00:16:48,079
loaded value and processor b is

461
00:16:48,079 --> 00:16:50,000
performing two store instructions on the

462
00:16:50,000 --> 00:16:51,279
same addresses that processor a is

463
00:16:51,279 --> 00:16:53,040
loading

464
00:16:53,040 --> 00:16:54,800
so let's assume that for some reason the

465
00:16:54,800 --> 00:16:57,199
first load of processor a is slow

466
00:16:57,199 --> 00:16:59,279
because for example it has a cache miss

467
00:16:59,279 --> 00:17:02,000
so it needs to fetch the data from main

468
00:17:02,000 --> 00:17:04,559
memory that will take time processor a

469
00:17:04,559 --> 00:17:06,880
will not wait internally for the data to

470
00:17:06,880 --> 00:17:07,679
come from

471
00:17:07,679 --> 00:17:10,079
memory and will execute out of order the

472
00:17:10,079 --> 00:17:12,000
second load and all subsequent dependent

473
00:17:12,000 --> 00:17:14,799
operations so in this case the second

474
00:17:14,799 --> 00:17:16,720
load on address y and all subsequent

475
00:17:16,720 --> 00:17:18,559
operations will be executed out of order

476
00:17:18,559 --> 00:17:20,720
and will be kept in a ready-to-commit

477
00:17:20,720 --> 00:17:22,959
state internally uh

478
00:17:22,959 --> 00:17:25,679
internally of in processor a waiting for

479
00:17:25,679 --> 00:17:27,520
the data of the first load to be fetched

480
00:17:27,520 --> 00:17:29,200
and then commit everything in program

481
00:17:29,200 --> 00:17:31,039
order to uh

482
00:17:31,039 --> 00:17:36,320
to follow the memory model of the cpu

483
00:17:36,559 --> 00:17:37,919
let's assume that at this point

484
00:17:37,919 --> 00:17:39,760
processor b performs its corresponding

485
00:17:39,760 --> 00:17:42,080
store instructions modifying the value

486
00:17:42,080 --> 00:17:45,360
of x address x and other address y which

487
00:17:45,360 --> 00:17:47,840
uh processor a have already loaded out

488
00:17:47,840 --> 00:17:49,120
of order

489
00:17:49,120 --> 00:17:52,080
at this point processor a1 cannot commit

490
00:17:52,080 --> 00:17:54,400
previously and the speculatively loaded

491
00:17:54,400 --> 00:17:57,440
value of address y and it needs to

492
00:17:57,440 --> 00:17:59,679
flush its line from the

493
00:17:59,679 --> 00:18:01,919
speculatively loaded value

494
00:18:01,919 --> 00:18:03,440
take into account the new value of y

495
00:18:03,440 --> 00:18:05,360
that stored by processor b

496
00:18:05,360 --> 00:18:07,760
re-executes the second load and all

497
00:18:07,760 --> 00:18:10,240
subsequent uh dependent operations so as

498
00:18:10,240 --> 00:18:12,160
we can see here we've loaded a cell

499
00:18:12,160 --> 00:18:14,080
value from memory by violating the

500
00:18:14,080 --> 00:18:15,760
memory uh

501
00:18:15,760 --> 00:18:18,400
order model

502
00:18:18,400 --> 00:18:19,760
so the architectural environment of this

503
00:18:19,760 --> 00:18:21,360
type of machine clear is that out of

504
00:18:21,360 --> 00:18:23,440
order execution always complies with the

505
00:18:23,440 --> 00:18:26,320
total store order memory model

506
00:18:26,320 --> 00:18:27,840
this architectural variant is violated

507
00:18:27,840 --> 00:18:29,280
in the case of a memory ordering machine

508
00:18:29,280 --> 00:18:32,160
clear where two processors can violate

509
00:18:32,160 --> 00:18:34,080
each other's

510
00:18:34,080 --> 00:18:35,679
program order

511
00:18:35,679 --> 00:18:38,559
this violation allows

512
00:18:38,559 --> 00:18:40,559
an attacker to transiently leak state

513
00:18:40,559 --> 00:18:43,520
data in this case the old value of a

514
00:18:43,520 --> 00:18:45,200
memory address

515
00:18:45,200 --> 00:18:46,480
and uh

516
00:18:46,480 --> 00:18:47,840
this type of machine clear is

517
00:18:47,840 --> 00:18:51,120
non-trivial all to to exploit we tried

518
00:18:51,120 --> 00:18:53,600
many times but it's not easy due to the

519
00:18:53,600 --> 00:18:55,600
strict synchronization between the two

520
00:18:55,600 --> 00:18:58,799
cores that need to be so precise

521
00:18:58,799 --> 00:19:00,640
even more on the microtexture level to

522
00:19:00,640 --> 00:19:02,080
violate the memory

523
00:19:02,080 --> 00:19:04,080
order model

524
00:19:04,080 --> 00:19:05,440
now we'll hand over to enrique we'll

525
00:19:05,440 --> 00:19:06,960
tell you more about this third type of

526
00:19:06,960 --> 00:19:10,080
machine cloud representing play

527
00:19:10,080 --> 00:19:11,360
okay thank you

528
00:19:11,360 --> 00:19:12,640
yeah now we're going to talk about

529
00:19:12,640 --> 00:19:14,880
floating point machine clear this one is

530
00:19:14,880 --> 00:19:17,039
the one that led us to find a full

531
00:19:17,039 --> 00:19:18,480
length and exploit on

532
00:19:18,480 --> 00:19:20,240
firefox

533
00:19:20,240 --> 00:19:22,000
and

534
00:19:22,000 --> 00:19:24,160
is completely based on a special

535
00:19:24,160 --> 00:19:25,840
representation of floating point numbers

536
00:19:25,840 --> 00:19:28,240
that are named subnormal

537
00:19:28,240 --> 00:19:30,160
and usually they are very small numbers

538
00:19:30,160 --> 00:19:32,240
for example for the double

539
00:19:32,240 --> 00:19:34,240
floating point representation

540
00:19:34,240 --> 00:19:37,280
every number below 2 to the power of

541
00:19:37,280 --> 00:19:40,000
minus one thousand to teacher will be a

542
00:19:40,000 --> 00:19:41,679
sub normal number

543
00:19:41,679 --> 00:19:43,280
but to keep it simple

544
00:19:43,280 --> 00:19:44,880
let's say in the i3 police standard

545
00:19:44,880 --> 00:19:47,200
floating point they decided to

546
00:19:47,200 --> 00:19:49,919
create a very let's say specialist and

547
00:19:49,919 --> 00:19:51,679
complicated representation of small

548
00:19:51,679 --> 00:19:52,880
numbers

549
00:19:52,880 --> 00:19:53,919
and

550
00:19:53,919 --> 00:19:56,880
there will be a machine clearer on this

551
00:19:56,880 --> 00:19:58,720
again let's use a snippet of code to

552
00:19:58,720 --> 00:20:00,720
explain this more easily

553
00:20:00,720 --> 00:20:01,840
let's suppose we have some floating

554
00:20:01,840 --> 00:20:03,440
point operations so a division followed

555
00:20:03,440 --> 00:20:05,760
by an addition very common

556
00:20:05,760 --> 00:20:08,080
snippet of code

557
00:20:08,080 --> 00:20:10,000
and

558
00:20:10,000 --> 00:20:11,600
basically every time the following is

559
00:20:11,600 --> 00:20:13,280
happening so the processor sorry the

560
00:20:13,280 --> 00:20:14,799
14-point unit

561
00:20:14,799 --> 00:20:16,720
is performing a division

562
00:20:16,720 --> 00:20:19,360
but cc the 14-point unit must be fast

563
00:20:19,360 --> 00:20:21,280
he's always operating

564
00:20:21,280 --> 00:20:23,200
on normal numbers only let's say

565
00:20:23,200 --> 00:20:25,039
standard floating point numbers he's

566
00:20:25,039 --> 00:20:26,880
always betting that this special

567
00:20:26,880 --> 00:20:29,039
presentation never

568
00:20:29,039 --> 00:20:31,440
kicks in basically so it quickly

569
00:20:31,440 --> 00:20:32,720
performs

570
00:20:32,720 --> 00:20:34,320
the floating point division result and

571
00:20:34,320 --> 00:20:36,480
you will forward this value to the

572
00:20:36,480 --> 00:20:38,320
subsequent instruction for example the

573
00:20:38,320 --> 00:20:40,480
addition

574
00:20:40,480 --> 00:20:41,919
but let's suppose that actually this

575
00:20:41,919 --> 00:20:43,840
division generate a very small number

576
00:20:43,840 --> 00:20:46,720
that is in the subnormal range

577
00:20:46,720 --> 00:20:49,520
later the 14 point unit will detect this

578
00:20:49,520 --> 00:20:51,760
and basically it needs to stop the

579
00:20:51,760 --> 00:20:53,919
entire processor because he generated a

580
00:20:53,919 --> 00:20:56,240
completely wrong result

581
00:20:56,240 --> 00:20:58,000
and

582
00:20:58,000 --> 00:21:00,159
it will basically trigger a machine

583
00:21:00,159 --> 00:21:02,400
clear by flashing all the subsequent

584
00:21:02,400 --> 00:21:04,320
instruction

585
00:21:04,320 --> 00:21:08,080
and again to compute the

586
00:21:08,080 --> 00:21:10,320
correct result

587
00:21:10,320 --> 00:21:11,760
the processor actually relies on

588
00:21:11,760 --> 00:21:13,280
software there will be a microcode

589
00:21:13,280 --> 00:21:14,320
assist

590
00:21:14,320 --> 00:21:15,919
and this division will be actually very

591
00:21:15,919 --> 00:21:18,240
slow compared to a normal division

592
00:21:18,240 --> 00:21:19,919
so the processor again we compute this

593
00:21:19,919 --> 00:21:21,679
division in software generate the

594
00:21:21,679 --> 00:21:23,840
current result and give it back to the

595
00:21:23,840 --> 00:21:25,280
cpu with the

596
00:21:25,280 --> 00:21:28,640
intended operation result

597
00:21:28,640 --> 00:21:30,000
so here we see that basically the

598
00:21:30,000 --> 00:21:31,520
floating point you need to be fast is

599
00:21:31,520 --> 00:21:33,840
optimized for normal uh

600
00:21:33,840 --> 00:21:35,760
floating point representation and it's

601
00:21:35,760 --> 00:21:37,600
abnormally stated as a special case that

602
00:21:37,600 --> 00:21:38,960
you need to handle

603
00:21:38,960 --> 00:21:41,120
uh separately

604
00:21:41,120 --> 00:21:42,799
to violate this it's super simple you

605
00:21:42,799 --> 00:21:44,640
just need to make a 14-point operation

606
00:21:44,640 --> 00:21:46,559
to generate a very small

607
00:21:46,559 --> 00:21:48,480
number

608
00:21:48,480 --> 00:21:50,880
and this good implication here is that

609
00:21:50,880 --> 00:21:53,120
the wrongly computed result

610
00:21:53,120 --> 00:21:54,640
the one that is using the red

611
00:21:54,640 --> 00:21:56,240
instruction

612
00:21:56,240 --> 00:21:58,159
is almost completely under attack

613
00:21:58,159 --> 00:22:00,640
control so an attacker by choosing the

614
00:22:00,640 --> 00:22:03,360
operands in a specific way

615
00:22:03,360 --> 00:22:06,400
you can transiently inject some

616
00:22:06,400 --> 00:22:08,320
arbitrary values to the subsequent

617
00:22:08,320 --> 00:22:10,000
instruction

618
00:22:10,000 --> 00:22:11,679
and for exploitation

619
00:22:11,679 --> 00:22:13,840
we are going to show you now the

620
00:22:13,840 --> 00:22:16,480
full exploit that we made to firefox and

621
00:22:16,480 --> 00:22:18,320
we named it floating point value

622
00:22:18,320 --> 00:22:20,799
injection

623
00:22:20,799 --> 00:22:23,760
okay this is a firefox eight version 83

624
00:22:23,760 --> 00:22:25,280
firmware correctly

625
00:22:25,280 --> 00:22:28,400
on the left you have a an origin that is

626
00:22:28,400 --> 00:22:30,640
different from the iframe to the right

627
00:22:30,640 --> 00:22:32,000
so the victim is on the left the

628
00:22:32,000 --> 00:22:33,440
attacker on the right

629
00:22:33,440 --> 00:22:35,679
completely separated

630
00:22:35,679 --> 00:22:37,840
and the goal here is from the attackery

631
00:22:37,840 --> 00:22:39,200
frame let's suppose there's another

632
00:22:39,200 --> 00:22:41,120
advertisement

633
00:22:41,120 --> 00:22:43,200
of our webpage is to link the entire

634
00:22:43,200 --> 00:22:46,640
content of the other page

635
00:22:47,440 --> 00:22:49,600
now let's go back for a moment to this

636
00:22:49,600 --> 00:22:52,000
arbitrary value

637
00:22:52,000 --> 00:22:53,919
injection so we develop a tool that is

638
00:22:53,919 --> 00:22:56,080
available on github

639
00:22:56,080 --> 00:22:57,919
where you just provide the value that

640
00:22:57,919 --> 00:22:59,840
you want to see transiently on the

641
00:22:59,840 --> 00:23:02,559
floating point division in this case and

642
00:23:02,559 --> 00:23:04,480
this two will give you the x and y

643
00:23:04,480 --> 00:23:06,240
operand of the division

644
00:23:06,240 --> 00:23:08,640
that transiently as you can see

645
00:23:08,640 --> 00:23:10,720
will give you the that b for example

646
00:23:10,720 --> 00:23:12,880
here the transient result as you as you

647
00:23:12,880 --> 00:23:14,799
want as you wish

648
00:23:14,799 --> 00:23:15,140
um

649
00:23:15,140 --> 00:23:16,480
[Music]

650
00:23:16,480 --> 00:23:18,559
again please notice that the real result

651
00:23:18,559 --> 00:23:20,480
the architectural result here is minus

652
00:23:20,480 --> 00:23:21,679
infinity

653
00:23:21,679 --> 00:23:23,440
but actually the processor and computes

654
00:23:23,440 --> 00:23:25,840
this wrong result will obtain the

655
00:23:25,840 --> 00:23:27,600
results on the under bottom that you can

656
00:23:27,600 --> 00:23:29,440
see

657
00:23:29,440 --> 00:23:32,159
now if you notice we also have ffb on

658
00:23:32,159 --> 00:23:33,760
the top of the

659
00:23:33,760 --> 00:23:35,280
floating point number

660
00:23:35,280 --> 00:23:38,640
why is the case well

661
00:23:38,640 --> 00:23:41,039
on firefox browser

662
00:23:41,039 --> 00:23:43,919
specifically in the javascript engine

663
00:23:43,919 --> 00:23:46,240
every object variable is represented

664
00:23:46,240 --> 00:23:48,400
with a floating point numbers and this

665
00:23:48,400 --> 00:23:51,279
technique is named non-boxing

666
00:23:51,279 --> 00:23:53,279
and it's quite simple so

667
00:23:53,279 --> 00:23:55,039
in the unused space of

668
00:23:55,039 --> 00:23:57,840
floating point numbers or none numbers

669
00:23:57,840 --> 00:24:00,480
the top bits ffb

670
00:24:00,480 --> 00:24:03,120
this is the encoding for the type of the

671
00:24:03,120 --> 00:24:05,200
variable so in this case this means that

672
00:24:05,200 --> 00:24:07,279
these are string objects

673
00:24:07,279 --> 00:24:10,159
while the bottom that b400 is the

674
00:24:10,159 --> 00:24:12,240
payload basically the pointer to the

675
00:24:12,240 --> 00:24:14,559
string

676
00:24:14,640 --> 00:24:16,480
so let's suppose that we use the x and y

677
00:24:16,480 --> 00:24:18,480
operands that we found before

678
00:24:18,480 --> 00:24:20,480
we perform the division and then we ask

679
00:24:20,480 --> 00:24:22,720
the javascript engine hey

680
00:24:22,720 --> 00:24:24,559
is the type of the division

681
00:24:24,559 --> 00:24:25,520
string

682
00:24:25,520 --> 00:24:28,640
obviously the answer is always no i mean

683
00:24:28,640 --> 00:24:29,919
if you operate on numbers the type of

684
00:24:29,919 --> 00:24:31,760
the variable should be integer

685
00:24:31,760 --> 00:24:34,000
and indeed architecturally the processor

686
00:24:34,000 --> 00:24:36,320
executes the blue branch taking the else

687
00:24:36,320 --> 00:24:37,760
case

688
00:24:37,760 --> 00:24:40,159
however speculatively

689
00:24:40,159 --> 00:24:42,640
we injected this ffb

690
00:24:42,640 --> 00:24:44,799
deadbeat result again a string where we

691
00:24:44,799 --> 00:24:46,880
control the pointer

692
00:24:46,880 --> 00:24:48,480
and the jasket engine at the beginning

693
00:24:48,480 --> 00:24:50,880
we say well of course the division of

694
00:24:50,880 --> 00:24:52,960
these numbers is a string

695
00:24:52,960 --> 00:24:56,159
and we control the pointer of the string

696
00:24:56,159 --> 00:24:57,840
so by accessing for example the length

697
00:24:57,840 --> 00:24:59,120
parameter

698
00:24:59,120 --> 00:25:00,640
we are forcing the javascript engine to

699
00:25:00,640 --> 00:25:02,720
read whatever we want

700
00:25:02,720 --> 00:25:04,400
and then using the flash node attack

701
00:25:04,400 --> 00:25:06,240
that we explained before

702
00:25:06,240 --> 00:25:08,400
we can then recover this data later with

703
00:25:08,400 --> 00:25:09,919
our state channel

704
00:25:09,919 --> 00:25:10,720
so

705
00:25:10,720 --> 00:25:12,320
again here if you think about is pretty

706
00:25:12,320 --> 00:25:15,360
crazy that we managed to type confuse

707
00:25:15,360 --> 00:25:17,600
javascript that a division result is of

708
00:25:17,600 --> 00:25:20,000
type string and on top of this we

709
00:25:20,000 --> 00:25:22,000
control the pointer

710
00:25:22,000 --> 00:25:23,120
bits

711
00:25:23,120 --> 00:25:26,799
so we managed to build a

712
00:25:26,799 --> 00:25:28,559
read primitive you can read any address

713
00:25:28,559 --> 00:25:30,240
in the firefox process

714
00:25:30,240 --> 00:25:33,440
just starting by a division

715
00:25:33,440 --> 00:25:35,600
and yeah usually we're used to that at

716
00:25:35,600 --> 00:25:38,080
least the cpu on mathematical operation

717
00:25:38,080 --> 00:25:41,039
is uh is perfect but here is making a

718
00:25:41,039 --> 00:25:44,080
huge mistake basically

719
00:25:44,080 --> 00:25:46,480
to conclude the primitive of the attack

720
00:25:46,480 --> 00:25:48,080
now we have a red primitive we can read

721
00:25:48,080 --> 00:25:50,400
any address that we want

722
00:25:50,400 --> 00:25:52,320
so we just need to break a clr because

723
00:25:52,320 --> 00:25:53,520
we don't know where the process of

724
00:25:53,520 --> 00:25:56,000
firefox is located and it's quite simple

725
00:25:56,000 --> 00:25:57,760
now you just need to for example locate

726
00:25:57,760 --> 00:26:00,159
one gigabyte of known

727
00:26:00,159 --> 00:26:02,080
text let's say all a's

728
00:26:02,080 --> 00:26:04,320
and then we start

729
00:26:04,320 --> 00:26:06,240
reading in a course grain way i don't

730
00:26:06,240 --> 00:26:07,840
know gigabyte after gigabyte in the

731
00:26:07,840 --> 00:26:08,880
memory

732
00:26:08,880 --> 00:26:11,679
and eventually we'll find that we licked

733
00:26:11,679 --> 00:26:14,159
the intended straight memory

734
00:26:14,159 --> 00:26:16,320
once we have this course course grade

735
00:26:16,320 --> 00:26:17,600
you just need to

736
00:26:17,600 --> 00:26:20,240
go page by page until we find

737
00:26:20,240 --> 00:26:22,400
the start of the spray

738
00:26:22,400 --> 00:26:25,360
and after that we break slr we can

739
00:26:25,360 --> 00:26:27,520
and we know that for example the firefox

740
00:26:27,520 --> 00:26:29,760
memory will be on top of our sprayed

741
00:26:29,760 --> 00:26:31,760
memory

742
00:26:31,760 --> 00:26:33,679
we're going to also to show a full video

743
00:26:33,679 --> 00:26:35,600
of the attack

744
00:26:35,600 --> 00:26:37,919
again this is the same setup of before

745
00:26:37,919 --> 00:26:39,600
the victim page on the left the attacker

746
00:26:39,600 --> 00:26:42,320
frame on the right

747
00:26:42,960 --> 00:26:44,960
exactly we start by

748
00:26:44,960 --> 00:26:46,640
again this

749
00:26:46,640 --> 00:26:48,080
spraying of memory so we have one

750
00:26:48,080 --> 00:26:49,360
gigabyte of

751
00:26:49,360 --> 00:26:52,880
known text and now using fpvi again a

752
00:26:52,880 --> 00:26:56,080
division that type confuse firefox

753
00:26:56,080 --> 00:26:58,960
to read arbitrary memory

754
00:26:58,960 --> 00:27:00,640
we are reading in a course green way

755
00:27:00,640 --> 00:27:02,559
until we find our

756
00:27:02,559 --> 00:27:04,080
spread memory

757
00:27:04,080 --> 00:27:05,360
and after

758
00:27:05,360 --> 00:27:07,039
a while i mean take a few seconds

759
00:27:07,039 --> 00:27:08,799
exactly now is uh

760
00:27:08,799 --> 00:27:10,240
almost finished

761
00:27:10,240 --> 00:27:14,240
we broke slr of uh of firefox and now we

762
00:27:14,240 --> 00:27:16,240
are already leaking the entire firefox

763
00:27:16,240 --> 00:27:18,559
process memory now we are just printing

764
00:27:18,559 --> 00:27:20,240
a useful text but in reality in the

765
00:27:20,240 --> 00:27:21,360
background is

766
00:27:21,360 --> 00:27:23,760
reading a lot of memory of the firefox

767
00:27:23,760 --> 00:27:26,799
process and eventually you see exactly

768
00:27:26,799 --> 00:27:28,960
we are linking the secret

769
00:27:28,960 --> 00:27:30,559
page of the victim

770
00:27:30,559 --> 00:27:32,480
again just by using

771
00:27:32,480 --> 00:27:34,720
a floating point division it is uh quite

772
00:27:34,720 --> 00:27:36,240
pleased in our opinion

773
00:27:36,240 --> 00:27:40,159
and if we let the attack runs for a bit

774
00:27:40,159 --> 00:27:42,640
we also start leaking uh other stuff

775
00:27:42,640 --> 00:27:44,960
after the the page that is for example

776
00:27:44,960 --> 00:27:47,120
javascript probably of

777
00:27:47,120 --> 00:27:48,880
i don't we still don't know this is the

778
00:27:48,880 --> 00:27:50,159
javascript code

779
00:27:50,159 --> 00:27:53,440
because again we completely

780
00:27:53,440 --> 00:27:55,360
broke the barrier so now we can read the

781
00:27:55,360 --> 00:27:59,360
entire firefox process memory

782
00:28:01,760 --> 00:28:03,279
now you may ask

783
00:28:03,279 --> 00:28:05,120
what is the leakage rate well is quite

784
00:28:05,120 --> 00:28:06,720
high for this kind of attack is 13

785
00:28:06,720 --> 00:28:09,919
kilobytes per second

786
00:28:09,919 --> 00:28:12,320
and how can we defend against it well

787
00:28:12,320 --> 00:28:14,080
there are multiple choice the first one

788
00:28:14,080 --> 00:28:16,320
is to disable entirely these special

789
00:28:16,320 --> 00:28:18,799
floating point numbers there are some

790
00:28:18,799 --> 00:28:20,159
registers in the floating point you need

791
00:28:20,159 --> 00:28:21,600
to to do that

792
00:28:21,600 --> 00:28:23,200
but it's not a viable solution because

793
00:28:23,200 --> 00:28:25,919
many programs actually

794
00:28:25,919 --> 00:28:28,799
works based on this representation

795
00:28:28,799 --> 00:28:32,880
so we try to implement a compiler pass

796
00:28:32,880 --> 00:28:34,080
to

797
00:28:34,080 --> 00:28:36,080
basically serialize the processor

798
00:28:36,080 --> 00:28:37,919
pipeline to avoid this

799
00:28:37,919 --> 00:28:39,840
speculative execution

800
00:28:39,840 --> 00:28:41,600
however the overhead is quite

801
00:28:41,600 --> 00:28:43,679
significant is at least 53 percent on

802
00:28:43,679 --> 00:28:44,799
the

803
00:28:44,799 --> 00:28:49,039
of on a floating heavy 14 point uh

804
00:28:49,039 --> 00:28:51,360
suite

805
00:28:51,440 --> 00:28:52,720
exactly

806
00:28:52,720 --> 00:28:54,640
so at the end

807
00:28:54,640 --> 00:28:57,840
firefox implemented a custom defense it

808
00:28:57,840 --> 00:29:00,320
is basically a conditional mask of 14

809
00:29:00,320 --> 00:29:01,760
point results so

810
00:29:01,760 --> 00:29:02,960
whenever you do a floating point

811
00:29:02,960 --> 00:29:05,600
division firefox before actually

812
00:29:05,600 --> 00:29:07,120
getting the results there is like an if

813
00:29:07,120 --> 00:29:10,159
condition checking it actually is not

814
00:29:10,159 --> 00:29:13,039
a non-result so you're sure that uh

815
00:29:13,039 --> 00:29:15,760
even transiently this cannot be abused

816
00:29:15,760 --> 00:29:17,840
or simply as chrome is doing set

817
00:29:17,840 --> 00:29:19,760
isolation every tab is a separate

818
00:29:19,760 --> 00:29:21,440
process and you cannot

819
00:29:21,440 --> 00:29:24,799
cross this this border

820
00:29:24,960 --> 00:29:27,600
now we present the last type of machine

821
00:29:27,600 --> 00:29:31,840
clear that is uh memories ambiguation

822
00:29:32,159 --> 00:29:32,960
and

823
00:29:32,960 --> 00:29:34,080
basically

824
00:29:34,080 --> 00:29:35,919
when a lot instruction is following a

825
00:29:35,919 --> 00:29:37,679
story instruction

826
00:29:37,679 --> 00:29:39,600
which the destination of these addresses

827
00:29:39,600 --> 00:29:41,520
are not ready yet

828
00:29:41,520 --> 00:29:43,200
this is there's a specific predictor in

829
00:29:43,200 --> 00:29:45,279
the cpu name the memory is aggregation

830
00:29:45,279 --> 00:29:46,480
unit

831
00:29:46,480 --> 00:29:48,720
that tries to predict if either this

832
00:29:48,720 --> 00:29:50,159
operation will operate on the same

833
00:29:50,159 --> 00:29:52,159
address or not so aliasing to the same

834
00:29:52,159 --> 00:29:53,840
address or not

835
00:29:53,840 --> 00:29:55,919
again let's use a very simple example to

836
00:29:55,919 --> 00:29:57,039
explain this

837
00:29:57,039 --> 00:30:00,000
a store followed by a load

838
00:30:00,000 --> 00:30:02,240
let's say again the store address is not

839
00:30:02,240 --> 00:30:04,159
available yet maybe it's coming from a

840
00:30:04,159 --> 00:30:05,520
long

841
00:30:05,520 --> 00:30:07,360
operation in the pipeline

842
00:30:07,360 --> 00:30:09,679
so at this point the processor

843
00:30:09,679 --> 00:30:11,760
asked the predictor

844
00:30:11,760 --> 00:30:13,760
look i know i should wait the store to

845
00:30:13,760 --> 00:30:15,520
complete before doing the load but

846
00:30:15,520 --> 00:30:17,360
can you predict for me if they are

847
00:30:17,360 --> 00:30:18,799
operating some others so i can

848
00:30:18,799 --> 00:30:22,399
parallelize and go faster

849
00:30:22,399 --> 00:30:24,000
let's say that the predictor will say

850
00:30:24,000 --> 00:30:25,840
yes they are not the same you can do

851
00:30:25,840 --> 00:30:26,960
them

852
00:30:26,960 --> 00:30:28,480
in parallel

853
00:30:28,480 --> 00:30:31,039
or out of order

854
00:30:31,039 --> 00:30:32,159
well

855
00:30:32,159 --> 00:30:34,559
obviously a predator can can be wrong

856
00:30:34,559 --> 00:30:35,440
and

857
00:30:35,440 --> 00:30:38,000
if actually the address of the store and

858
00:30:38,000 --> 00:30:39,760
the load is the same

859
00:30:39,760 --> 00:30:41,520
well you need to execute before the

860
00:30:41,520 --> 00:30:43,919
store and then loading the newly stored

861
00:30:43,919 --> 00:30:45,760
values in this case hello

862
00:30:45,760 --> 00:30:48,559
so the load lighted in red

863
00:30:48,559 --> 00:30:50,320
will be executed firstly with a steel

864
00:30:50,320 --> 00:30:53,039
data and later will be re-executed with

865
00:30:53,039 --> 00:30:55,840
the current data

866
00:30:56,000 --> 00:30:57,440
so here the invariant is that the

867
00:30:57,440 --> 00:30:59,279
processor really trusts this predictor

868
00:30:59,279 --> 00:31:01,360
and uh

869
00:31:01,360 --> 00:31:02,559
basically

870
00:31:02,559 --> 00:31:05,360
the predictor will never make a mistake

871
00:31:05,360 --> 00:31:07,360
and to violate this again you need a

872
00:31:07,360 --> 00:31:09,200
misprediction so bring the processor or

873
00:31:09,200 --> 00:31:11,120
the predictor in a state that is going

874
00:31:11,120 --> 00:31:12,880
to make a mistake

875
00:31:12,880 --> 00:31:15,039
and secure the implication is that

876
00:31:15,039 --> 00:31:18,080
it will translate stale data

877
00:31:18,080 --> 00:31:19,840
reagan exploitation this was already

878
00:31:19,840 --> 00:31:23,679
known in the past was named spectre v4

879
00:31:23,679 --> 00:31:25,200
we presented also in this paper because

880
00:31:25,200 --> 00:31:26,960
we believe was

881
00:31:26,960 --> 00:31:28,720
kinda

882
00:31:28,720 --> 00:31:31,360
mistaken for a spectre variant where is

883
00:31:31,360 --> 00:31:33,760
only branch misprediction

884
00:31:33,760 --> 00:31:35,039
here actually

885
00:31:35,039 --> 00:31:36,480
if you think about is a data

886
00:31:36,480 --> 00:31:38,480
misprediction so you are

887
00:31:38,480 --> 00:31:40,399
mispredicting the data the processor is

888
00:31:40,399 --> 00:31:43,120
operating on

889
00:31:43,360 --> 00:31:44,559
now

890
00:31:44,559 --> 00:31:47,120
yes on our paper i know four is already

891
00:31:47,120 --> 00:31:48,480
a lot but in our paper there are even

892
00:31:48,480 --> 00:31:50,480
more so if you want to to know about

893
00:31:50,480 --> 00:31:52,320
them there are other uh strange

894
00:31:52,320 --> 00:31:54,240
condition the processor must

895
00:31:54,240 --> 00:31:56,000
stop flush the entire pulpit and

896
00:31:56,000 --> 00:31:58,240
recontinue from the correct path

897
00:31:58,240 --> 00:32:00,080
for example uh exception we have

898
00:32:00,080 --> 00:32:01,279
interrupts

899
00:32:01,279 --> 00:32:03,039
there are other many type of microcode

900
00:32:03,039 --> 00:32:04,799
assist but for that please have a look

901
00:32:04,799 --> 00:32:07,519
at our paper

902
00:32:07,519 --> 00:32:08,559
and now

903
00:32:08,559 --> 00:32:11,600
back to 20.

904
00:32:13,120 --> 00:32:15,440
all right so uh now that we we've seen

905
00:32:15,440 --> 00:32:17,519
uh four types of machine clear let's uh

906
00:32:17,519 --> 00:32:18,880
look at the big pictures of what we

907
00:32:18,880 --> 00:32:20,960
presented so far we've seen uh a

908
00:32:20,960 --> 00:32:22,559
software phone code machine clear where

909
00:32:22,559 --> 00:32:25,440
a store instruction uh causes a machine

910
00:32:25,440 --> 00:32:28,480
clear trigging uh the pipeline flash of

911
00:32:28,480 --> 00:32:30,799
previously executed instructions

912
00:32:30,799 --> 00:32:32,559
we've seen the memory ordering machine

913
00:32:32,559 --> 00:32:34,480
clear where a processor validates the

914
00:32:34,480 --> 00:32:35,679
memory ordering model of another

915
00:32:35,679 --> 00:32:38,960
processor flashing its pipeline again

916
00:32:38,960 --> 00:32:41,039
the floating point machine clear where

917
00:32:41,039 --> 00:32:43,039
we perform any floating point division

918
00:32:43,039 --> 00:32:46,320
with controlled operands uh causing the

919
00:32:46,320 --> 00:32:47,919
the processor to flush his pipeline

920
00:32:47,919 --> 00:32:50,880
again and we execute the instructions

921
00:32:50,880 --> 00:32:52,240
and the last one is the mermaid's

922
00:32:52,240 --> 00:32:53,360
immigration

923
00:32:53,360 --> 00:32:54,960
machine clear where we flush the

924
00:32:54,960 --> 00:32:57,519
pipeline from one uh

925
00:32:57,519 --> 00:32:59,919
one load instruction that had loaded

926
00:32:59,919 --> 00:33:02,559
sale data

927
00:33:02,960 --> 00:33:04,720
so how these types of machine clearance

928
00:33:04,720 --> 00:33:05,840
perform

929
00:33:05,840 --> 00:33:07,519
uh compared to all previously known

930
00:33:07,519 --> 00:33:09,440
trans execution

931
00:33:09,440 --> 00:33:11,679
mechanisms so here on the x-axis you

932
00:33:11,679 --> 00:33:13,120
have the different types the different

933
00:33:13,120 --> 00:33:14,960
mechanisms that can trigger transit

934
00:33:14,960 --> 00:33:17,440
execution so speculative execution paths

935
00:33:17,440 --> 00:33:18,720
in the processor

936
00:33:18,720 --> 00:33:21,279
and on the y-axis we have two criteria

937
00:33:21,279 --> 00:33:22,799
the top plot is representing the number

938
00:33:22,799 --> 00:33:24,960
of transient loads that fit within a

939
00:33:24,960 --> 00:33:27,039
single transient window created by a

940
00:33:27,039 --> 00:33:28,960
corresponding machine corresponding

941
00:33:28,960 --> 00:33:31,360
transit execution mechanism and the

942
00:33:31,360 --> 00:33:33,519
bottom plot representing the leakage

943
00:33:33,519 --> 00:33:36,640
rate how a specific trans execution

944
00:33:36,640 --> 00:33:39,039
mechanism performs in terms of leaking

945
00:33:39,039 --> 00:33:40,559
data

946
00:33:40,559 --> 00:33:43,440
here we have the uh the flushing reload

947
00:33:43,440 --> 00:33:45,840
uh bars representing the architectural

948
00:33:45,840 --> 00:33:48,000
upper limit in terms of leakage rate

949
00:33:48,000 --> 00:33:50,159
uh that we can try to compare our

950
00:33:50,159 --> 00:33:52,640
leakage rate against

951
00:33:52,640 --> 00:33:56,080
and then we have intel tsx bsd and folds

952
00:33:56,080 --> 00:33:58,080
which are the three uh

953
00:33:58,080 --> 00:33:59,679
ways the three mechanisms that all

954
00:33:59,679 --> 00:34:01,679
previous strength extreme attacks were

955
00:34:01,679 --> 00:34:04,720
relying on to create uh transient uh

956
00:34:04,720 --> 00:34:07,200
paths

957
00:34:07,200 --> 00:34:09,918
where intel tsx is obviously available

958
00:34:09,918 --> 00:34:12,399
only on intel and is not supported

959
00:34:12,399 --> 00:34:15,040
anymore on recent cpu so

960
00:34:15,040 --> 00:34:18,079
before this uh our work an attacker

961
00:34:18,079 --> 00:34:20,639
would have been left only with a bhd so

962
00:34:20,639 --> 00:34:22,960
mistraining uh branch predictor or

963
00:34:22,960 --> 00:34:24,399
causing a fault to create a trending

964
00:34:24,399 --> 00:34:27,280
path but after our work we're basically

965
00:34:27,280 --> 00:34:29,679
providing five new ways to create

966
00:34:29,679 --> 00:34:32,159
transit execution attacks which are also

967
00:34:32,159 --> 00:34:34,159
available on md which is quite powerful

968
00:34:34,159 --> 00:34:35,440
in terms of

969
00:34:35,440 --> 00:34:37,599
tools to reverse engineer the internal

970
00:34:37,599 --> 00:34:40,639
behavior of a cpu

971
00:34:40,960 --> 00:34:42,800
when it comes to the number of transit

972
00:34:42,800 --> 00:34:44,879
loads we can see that we measured more

973
00:34:44,879 --> 00:34:48,079
than 160 transient loads that can fit

974
00:34:48,079 --> 00:34:50,320
inside one single window of a self

975
00:34:50,320 --> 00:34:52,000
modifying code machine clear

976
00:34:52,000 --> 00:34:54,399
160 loads that will never be committed

977
00:34:54,399 --> 00:34:56,879
architecturally and can leave a micro

978
00:34:56,879 --> 00:34:59,440
extension trace leaking memory

979
00:34:59,440 --> 00:35:01,760
and that this is with only one single

980
00:35:01,760 --> 00:35:03,760
somewhat code machine clear which is

981
00:35:03,760 --> 00:35:05,119
really powerful

982
00:35:05,119 --> 00:35:07,760
another interesting number is that with

983
00:35:07,760 --> 00:35:09,599
a floating point machine clear

984
00:35:09,599 --> 00:35:12,240
uh we can leak more than four megabits

985
00:35:12,240 --> 00:35:13,520
per second

986
00:35:13,520 --> 00:35:15,520
four megabits with performing flooring

987
00:35:15,520 --> 00:35:18,079
point operations and this again will be

988
00:35:18,079 --> 00:35:20,000
transiently executed will never be

989
00:35:20,000 --> 00:35:21,760
observed on the micro macro and

990
00:35:21,760 --> 00:35:24,079
architectural uh

991
00:35:24,079 --> 00:35:25,839
execution but on the micro architectural

992
00:35:25,839 --> 00:35:27,760
level it will leave

993
00:35:27,760 --> 00:35:31,040
an observable trace and we can reach

994
00:35:31,040 --> 00:35:32,720
more than 4 megabits per second thanks

995
00:35:32,720 --> 00:35:35,440
to the determinism of a flowing point

996
00:35:35,440 --> 00:35:37,680
operation we are not mistraining we are

997
00:35:37,680 --> 00:35:40,079
not wasting execution cycles on trying

998
00:35:40,079 --> 00:35:42,720
to bring the micro actual trace

999
00:35:42,720 --> 00:35:44,800
microarchitecture of a modern cpu to a

1000
00:35:44,800 --> 00:35:46,800
known or a specific state is

1001
00:35:46,800 --> 00:35:48,880
deterministic we perform flowing point

1002
00:35:48,880 --> 00:35:51,040
operation and we have a transit

1003
00:35:51,040 --> 00:35:54,000
execution path

1004
00:35:54,320 --> 00:35:58,160
so now that we have a clear image of all

1005
00:35:58,160 --> 00:36:00,400
different trans execution mechanisms we

1006
00:36:00,400 --> 00:36:02,880
try to classify these to have a more a

1007
00:36:02,880 --> 00:36:04,640
more systematic understanding of these

1008
00:36:04,640 --> 00:36:07,200
uh uh of this of trans execution and we

1009
00:36:07,200 --> 00:36:09,680
start from two main uh subclasses of bad

1010
00:36:09,680 --> 00:36:12,320
speculation bespeculation is the let's

1011
00:36:12,320 --> 00:36:14,400
say the top class representing this

1012
00:36:14,400 --> 00:36:16,480
behavior on modern cpus and we have two

1013
00:36:16,480 --> 00:36:18,560
main subclasses the first one is control

1014
00:36:18,560 --> 00:36:20,000
performance prediction and the second

1015
00:36:20,000 --> 00:36:21,119
one is database protection so

1016
00:36:21,119 --> 00:36:23,599
counterflow is speculating on the next

1017
00:36:23,599 --> 00:36:25,599
instruction to execute data prediction

1018
00:36:25,599 --> 00:36:26,400
is

1019
00:36:26,400 --> 00:36:30,160
speculating on the data not uh

1020
00:36:30,160 --> 00:36:31,760
not code

1021
00:36:31,760 --> 00:36:33,680
each subclass has its own

1022
00:36:33,680 --> 00:36:35,440
predictive subclass

1023
00:36:35,440 --> 00:36:37,440
while controlling protection are failed

1024
00:36:37,440 --> 00:36:39,119
attempts to speculate on the next

1025
00:36:39,119 --> 00:36:40,560
instructions to execute data

1026
00:36:40,560 --> 00:36:42,079
inspirations are failed attempts to

1027
00:36:42,079 --> 00:36:43,359
operate on data that has been not

1028
00:36:43,359 --> 00:36:45,920
validated yet

1029
00:36:45,920 --> 00:36:47,599
then we have the exceptions of flash

1030
00:36:47,599 --> 00:36:49,040
subclass of

1031
00:36:49,040 --> 00:36:50,320
database protection which represents all

1032
00:36:50,320 --> 00:36:51,839
the architectural

1033
00:36:51,839 --> 00:36:53,119
exceptions that have been widely

1034
00:36:53,119 --> 00:36:54,960
explored in previous attacks

1035
00:36:54,960 --> 00:36:57,839
and then we created this new subclass of

1036
00:36:57,839 --> 00:36:59,440
data inspiration which is called likely

1037
00:36:59,440 --> 00:37:01,200
in variance violations which represents

1038
00:37:01,200 --> 00:37:03,200
all the architectural environments that

1039
00:37:03,200 --> 00:37:05,119
usually hold but occasionally fail like

1040
00:37:05,119 --> 00:37:06,480
for example in the case of a floating

1041
00:37:06,480 --> 00:37:07,359
point

1042
00:37:07,359 --> 00:37:09,200
machine clear where it assumes to be

1043
00:37:09,200 --> 00:37:11,520
working on normal numbers and that's

1044
00:37:11,520 --> 00:37:13,280
correct because it works everything

1045
00:37:13,280 --> 00:37:14,800
everything works fine in that case but

1046
00:37:14,800 --> 00:37:18,720
whenever a subnormal number uh occurs

1047
00:37:18,720 --> 00:37:19,920
then this

1048
00:37:19,920 --> 00:37:22,880
invariant is violated

1049
00:37:22,880 --> 00:37:24,560
another class of data inspection that we

1050
00:37:24,560 --> 00:37:26,240
observed creating strategic execution

1051
00:37:26,240 --> 00:37:28,240
path is interrupts and more specifically

1052
00:37:28,240 --> 00:37:30,800
hardware interrupts you can need this

1053
00:37:30,800 --> 00:37:32,960
you can read more about this in our

1054
00:37:32,960 --> 00:37:34,880
our paper

1055
00:37:34,880 --> 00:37:36,800
so we disclosed floating point value

1056
00:37:36,800 --> 00:37:38,960
injection and uh speculative code server

1057
00:37:38,960 --> 00:37:41,119
pass to all major cpu browser operating

1058
00:37:41,119 --> 00:37:42,960
system hypervisors vendors earlier this

1059
00:37:42,960 --> 00:37:47,680
year and uh we uh also observed that

1060
00:37:47,680 --> 00:37:49,359
when it comes to

1061
00:37:49,359 --> 00:37:51,520
store code bypass specifically difficult

1062
00:37:51,520 --> 00:37:53,760
code store bypass all intel cpus are

1063
00:37:53,760 --> 00:37:56,800
affected all amd cpus are affected and

1064
00:37:56,800 --> 00:37:59,280
regarding arm cpus they are not affected

1065
00:37:59,280 --> 00:38:01,440
because the coherency between data and

1066
00:38:01,440 --> 00:38:04,400
code is explicitly left to the user so

1067
00:38:04,400 --> 00:38:07,920
it's not a vulnerability in that case

1068
00:38:07,920 --> 00:38:09,599
regarding floating point value injection

1069
00:38:09,599 --> 00:38:11,440
again all intel cpus are affected by

1070
00:38:11,440 --> 00:38:13,680
this all mdcpus are affected by this and

1071
00:38:13,680 --> 00:38:16,000
also arm cpus we were informed after our

1072
00:38:16,000 --> 00:38:17,920
disclosure that some floating point of

1073
00:38:17,920 --> 00:38:20,880
implementations on arm processor are uh

1074
00:38:20,880 --> 00:38:22,880
are affected by floating point value

1075
00:38:22,880 --> 00:38:25,280
injection

1076
00:38:26,160 --> 00:38:28,480
mozilla confirmed the vulnerability and

1077
00:38:28,480 --> 00:38:29,920
deploy the mitigation based on

1078
00:38:29,920 --> 00:38:32,320
conditionally masking malicious numb box

1079
00:38:32,320 --> 00:38:34,160
floating point results starting from

1080
00:38:34,160 --> 00:38:36,480
firefox 87 and on

1081
00:38:36,480 --> 00:38:39,119
and also the zen hypervisor mitigated

1082
00:38:39,119 --> 00:38:41,200
speculative code survey pass and release

1083
00:38:41,200 --> 00:38:42,720
the security advisory following our

1084
00:38:42,720 --> 00:38:44,640
proposed mitigation which is basically

1085
00:38:44,640 --> 00:38:46,400
issuing a serializing instruction after

1086
00:38:46,400 --> 00:38:48,720
we store the new code in the case of snc

1087
00:38:48,720 --> 00:38:50,880
so we make sure that code and data are

1088
00:38:50,880 --> 00:38:52,720
coherent and then when we try to call

1089
00:38:52,720 --> 00:38:54,960
the new code we're actually also uh

1090
00:38:54,960 --> 00:38:57,520
executing it on the microsoft level

1091
00:38:57,520 --> 00:38:59,440
and therefore avoiding a software called

1092
00:38:59,440 --> 00:39:01,599
machine clear

1093
00:39:01,599 --> 00:39:04,400
to include uh bad speculation is not

1094
00:39:04,400 --> 00:39:06,640
caused only by classic mispredictions

1095
00:39:06,640 --> 00:39:08,880
but also by architectural invariance

1096
00:39:08,880 --> 00:39:10,880
violation like the different types of

1097
00:39:10,880 --> 00:39:13,119
machine clay that we presented today

1098
00:39:13,119 --> 00:39:14,720
these architectural invariants can be

1099
00:39:14,720 --> 00:39:16,560
exploited creating a new security new

1100
00:39:16,560 --> 00:39:18,079
security threats like flowing point

1101
00:39:18,079 --> 00:39:20,000
value injection and speculative code

1102
00:39:20,000 --> 00:39:22,640
survey paths and we think that defenses

1103
00:39:22,640 --> 00:39:25,359
from now on uh must focus on the wider

1104
00:39:25,359 --> 00:39:27,280
meaning and the wider class of the root

1105
00:39:27,280 --> 00:39:29,520
causes of bad speculation which are not

1106
00:39:29,520 --> 00:39:32,480
only avoiding mistraining the predictor

1107
00:39:32,480 --> 00:39:34,960
as we saw here we can deterministically

1108
00:39:34,960 --> 00:39:35,920
perform

1109
00:39:35,920 --> 00:39:37,520
these type of attacks and therefore the

1110
00:39:37,520 --> 00:39:38,800
defenses must

1111
00:39:38,800 --> 00:39:42,160
be take this into account too

1112
00:39:42,160 --> 00:39:44,400
here you can find different links to our

1113
00:39:44,400 --> 00:39:47,440
paper the code and the exploit

1114
00:39:47,440 --> 00:39:49,680
and yeah thanks for your attention now

1115
00:39:49,680 --> 00:39:51,280
we can take any questions you might have

1116
00:39:51,280 --> 00:39:53,140
thanks

1117
00:39:53,140 --> 00:39:57,589
[Applause]

