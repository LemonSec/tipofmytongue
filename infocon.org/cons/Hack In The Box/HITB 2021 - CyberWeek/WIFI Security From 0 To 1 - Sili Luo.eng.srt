1
00:00:02,960 --> 00:00:04,720
hello everyone thank you for attending

2
00:00:04,720 --> 00:00:07,359
my talk i'm silly i'm happy to share my

3
00:00:07,359 --> 00:00:10,320
topic today my topic is wi-fi security

4
00:00:10,320 --> 00:00:13,440
from zero to one

5
00:00:14,400 --> 00:00:15,839
first of all please allow me to

6
00:00:15,839 --> 00:00:17,920
introduce myself i am a security

7
00:00:17,920 --> 00:00:20,240
researcher at huawei root lab i focused

8
00:00:20,240 --> 00:00:23,119
on software availability research below

9
00:00:23,119 --> 00:00:25,599
my twitter and github links if you are

10
00:00:25,599 --> 00:00:27,760
interested you can follow me next i will

11
00:00:27,760 --> 00:00:31,080
show my topic

12
00:00:31,199 --> 00:00:33,040
this is the outline of today's

13
00:00:33,040 --> 00:00:34,399
presentation

14
00:00:34,399 --> 00:00:36,480
first i will introduce some background

15
00:00:36,480 --> 00:00:39,120
knowledge about wi-fi security including

16
00:00:39,120 --> 00:00:41,600
the basic knowledge of wifi protocol

17
00:00:41,600 --> 00:00:44,160
some previous research on wi-fi security

18
00:00:44,160 --> 00:00:46,320
and finally i will introduce the

19
00:00:46,320 --> 00:00:48,719
security risks fixed by the wi-fi

20
00:00:48,719 --> 00:00:50,079
protocol stack

21
00:00:50,079 --> 00:00:52,640
then i will take your text format

22
00:00:52,640 --> 00:00:55,199
firmware and its linux soft mac drivers

23
00:00:55,199 --> 00:00:57,760
as an example to introduce the remote

24
00:00:57,760 --> 00:01:00,480
test surface of the wi-fi protocol stack

25
00:01:00,480 --> 00:01:02,320
as well as the code review and

26
00:01:02,320 --> 00:01:04,799
variability analysis technique of the

27
00:01:04,799 --> 00:01:07,280
wi-fi product stack and introduced

28
00:01:07,280 --> 00:01:09,680
several disk character properties to

29
00:01:09,680 --> 00:01:11,439
help you understand it

30
00:01:11,439 --> 00:01:13,680
then i will introduce the implementation

31
00:01:13,680 --> 00:01:16,799
of wi-fi hunter and several varieties

32
00:01:16,799 --> 00:01:19,280
discarded by this store

33
00:01:19,280 --> 00:01:21,280
wi-fi hunter is a browser for wi-fi

34
00:01:21,280 --> 00:01:23,840
portable stack it will open source on my

35
00:01:23,840 --> 00:01:26,560
github after the meeting

36
00:01:26,560 --> 00:01:28,799
next i will briefly introduce the local

37
00:01:28,799 --> 00:01:31,520
attack surface of linux wi-fi driver

38
00:01:31,520 --> 00:01:35,439
finally i will summarize the speech

39
00:01:36,880 --> 00:01:38,560
next i will introduce some background

40
00:01:38,560 --> 00:01:41,840
knowledge of wi-fi security

41
00:01:42,880 --> 00:01:44,799
first i will introduce three main

42
00:01:44,799 --> 00:01:47,280
reasons for studying wi-fi security

43
00:01:47,280 --> 00:01:49,200
first and showing the picture on the

44
00:01:49,200 --> 00:01:52,640
left where the development of technology

45
00:01:52,640 --> 00:01:55,840
wifi is used in more and more scenarios

46
00:01:55,840 --> 00:01:58,399
such as mobile phones iot device smart

47
00:01:58,399 --> 00:02:00,159
class and so on

48
00:02:00,159 --> 00:02:02,320
second the wi-fi protocol stack is

49
00:02:02,320 --> 00:02:05,680
complicated and needs to process complex

50
00:02:05,680 --> 00:02:07,759
data structure and state machine so it

51
00:02:07,759 --> 00:02:09,919
is frontal vulnerabilities

52
00:02:09,919 --> 00:02:12,080
third once the availability is

53
00:02:12,080 --> 00:02:15,440
successfully exploded the attacker can

54
00:02:15,440 --> 00:02:18,160
achieve a zero click attack

55
00:02:18,160 --> 00:02:21,680
and again access to user's network data

56
00:02:21,680 --> 00:02:23,760
for example the picture on the right

57
00:02:23,760 --> 00:02:26,239
shows google project xero attacking

58
00:02:26,239 --> 00:02:30,239
iphone through a wi-fi availability

59
00:02:31,280 --> 00:02:33,280
next i will introduce some previous

60
00:02:33,280 --> 00:02:36,319
research on wi-fi security the content

61
00:02:36,319 --> 00:02:39,120
in the green box is a classical case of

62
00:02:39,120 --> 00:02:41,360
remote control devices through the wi-fi

63
00:02:41,360 --> 00:02:43,360
protocol stack variability the

64
00:02:43,360 --> 00:02:46,080
probability used in these three cases

65
00:02:46,080 --> 00:02:48,800
are all hip overflow variabilities which

66
00:02:48,800 --> 00:02:51,440
are caused by passing some variables

67
00:02:51,440 --> 00:02:53,440
data structures of the wi-fi product

68
00:02:53,440 --> 00:02:56,160
step the grid blocks in the table are

69
00:02:56,160 --> 00:02:59,040
for typical wi-fi fuzzing research

70
00:02:59,040 --> 00:03:01,599
the both have a similar idea that is

71
00:03:01,599 --> 00:03:03,440
manually model the

72
00:03:03,440 --> 00:03:05,760
product stack and then perform targeted

73
00:03:05,760 --> 00:03:08,239
fuzzing on the vulnerable area in the

74
00:03:08,239 --> 00:03:10,720
wi-fi product stack for example various

75
00:03:10,720 --> 00:03:13,280
information elements in the wi-fi frame

76
00:03:13,280 --> 00:03:15,680
here i highlighted the research of ow

77
00:03:15,680 --> 00:03:17,920
files otw files is a wifi

78
00:03:17,920 --> 00:03:20,239
photographizing tool developed based on

79
00:03:20,239 --> 00:03:22,640
the open wi-fi platform after research

80
00:03:22,640 --> 00:03:25,040
and comparison i found that ow france

81
00:03:25,040 --> 00:03:27,200
should be the best wi-fi fuzzing tools

82
00:03:27,200 --> 00:03:29,040
in the open source community whatever

83
00:03:29,040 --> 00:03:31,120
hunter introduced in this speech is

84
00:03:31,120 --> 00:03:34,319
based on awful

85
00:03:35,519 --> 00:03:37,680
but analyze the previous security

86
00:03:37,680 --> 00:03:40,080
research we can find that the remote

87
00:03:40,080 --> 00:03:42,239
attack surface of wi-fi protocol stack

88
00:03:42,239 --> 00:03:44,840
is mainly located in the following two

89
00:03:44,840 --> 00:03:48,000
aspects first when the software pass the

90
00:03:48,000 --> 00:03:50,080
various character data in the wi-fi

91
00:03:50,080 --> 00:03:52,400
frame if the database is not checked

92
00:03:52,400 --> 00:03:54,239
carefully it may cause overflow

93
00:03:54,239 --> 00:03:55,680
vulnerabilities

94
00:03:55,680 --> 00:03:57,760
command structures that are planned to

95
00:03:57,760 --> 00:04:00,879
availabilities are information elements

96
00:04:00,879 --> 00:04:03,200
nested the television structure in the

97
00:04:03,200 --> 00:04:05,040
information elements such as the

98
00:04:05,040 --> 00:04:07,680
e-postgre wi-fi pdp attribute and some

99
00:04:07,680 --> 00:04:11,040
java structure customized by some vendor

100
00:04:11,040 --> 00:04:13,439
the second risk is data in the wi-fi

101
00:04:13,439 --> 00:04:16,238
protocol when device needed to transmit

102
00:04:16,238 --> 00:04:18,639
large amounts of data the data needs to

103
00:04:18,639 --> 00:04:20,880
be transmitted in fragments

104
00:04:20,880 --> 00:04:23,120
and the pure device needed to aggregate

105
00:04:23,120 --> 00:04:25,360
the fragmented data frames

106
00:04:25,360 --> 00:04:27,520
vulnerabilities are prone to occurs in

107
00:04:27,520 --> 00:04:30,160
the process of aggregating fragmented

108
00:04:30,160 --> 00:04:31,199
rooms

109
00:04:31,199 --> 00:04:33,759
in addition to the remote attack surface

110
00:04:33,759 --> 00:04:35,759
there are some local attack services for

111
00:04:35,759 --> 00:04:38,479
linux wi-fi driver the linux wi-fi

112
00:04:38,479 --> 00:04:40,000
driver generally provides some

113
00:04:40,000 --> 00:04:42,000
configuration interface with the user

114
00:04:42,000 --> 00:04:43,680
space

115
00:04:43,680 --> 00:04:46,000
if the driver does not carefully check

116
00:04:46,000 --> 00:04:48,560
the data from the user space it may

117
00:04:48,560 --> 00:04:51,199
cause security availabilities currently

118
00:04:51,199 --> 00:04:53,120
linux wi-fi driver can provide the

119
00:04:53,120 --> 00:04:56,400
interface for user spaces through wxc or

120
00:04:56,400 --> 00:04:59,400
cfg8021

121
00:05:00,320 --> 00:05:02,639
the figure on the left shows us charge

122
00:05:02,639 --> 00:05:05,280
of information element and the figure on

123
00:05:05,280 --> 00:05:07,680
the right through the pdp attribute

124
00:05:07,680 --> 00:05:10,240
there are all typical tlv structure in

125
00:05:10,240 --> 00:05:13,039
wifi frame

126
00:05:13,759 --> 00:05:15,680
next i will introduce some knowledge of

127
00:05:15,680 --> 00:05:18,000
wifi protocol stack the left picture

128
00:05:18,000 --> 00:05:20,960
shows a typical ap sta wifi network

129
00:05:20,960 --> 00:05:22,160
structure

130
00:05:22,160 --> 00:05:24,960
this is a scenario when we use the wifi

131
00:05:24,960 --> 00:05:28,400
router to access the internet at home

132
00:05:28,400 --> 00:05:31,199
the ap in the picture is our router and

133
00:05:31,199 --> 00:05:34,160
sta meets various devices that access

134
00:05:34,160 --> 00:05:36,479
the wifi router through the wi-fi

135
00:05:36,479 --> 00:05:38,479
protocol such as the mobile phones

136
00:05:38,479 --> 00:05:40,960
laptops and so on

137
00:05:40,960 --> 00:05:42,960
the figure on the right shows the

138
00:05:42,960 --> 00:05:45,440
structure of the wi-fi portal stack the

139
00:05:45,440 --> 00:05:47,600
wi-fi portal stack can be roughly

140
00:05:47,600 --> 00:05:50,400
divided into the physical layer and the

141
00:05:50,400 --> 00:05:52,800
data link layer and the further

142
00:05:52,800 --> 00:05:58,160
subdivided into phy plcp mac llc layers

143
00:05:58,160 --> 00:06:01,039
so mac layers is responsible for most of

144
00:06:01,039 --> 00:06:03,360
the logic of the wifi protocol stack

145
00:06:03,360 --> 00:06:06,080
such as data process or wi-fi frames

146
00:06:06,080 --> 00:06:08,400
protocol study to machine management and

147
00:06:08,400 --> 00:06:10,560
the most verifiability things history

148
00:06:10,560 --> 00:06:13,199
are located in the mac layer therefore

149
00:06:13,199 --> 00:06:15,520
the focus of availability mining should

150
00:06:15,520 --> 00:06:19,960
be the processing of map frames

151
00:06:20,720 --> 00:06:22,639
next we look at the structure of the

152
00:06:22,639 --> 00:06:25,280
wi-fi physical frame the physical frame

153
00:06:25,280 --> 00:06:27,759
composer of plcp header and its frame

154
00:06:27,759 --> 00:06:30,479
data there is a lens field in the signal

155
00:06:30,479 --> 00:06:32,880
field of plcb header which represents

156
00:06:32,880 --> 00:06:35,120
the length of the data behind the frame

157
00:06:35,120 --> 00:06:37,440
header

158
00:06:39,360 --> 00:06:41,840
after the wi-fi chips receive and pass

159
00:06:41,840 --> 00:06:44,400
the physical layer data it will pass the

160
00:06:44,400 --> 00:06:47,199
macular data to the apply software for

161
00:06:47,199 --> 00:06:48,400
processing

162
00:06:48,400 --> 00:06:51,199
a mac room consists of a frame head and

163
00:06:51,199 --> 00:06:53,840
a frame body there are several important

164
00:06:53,840 --> 00:06:56,080
fields in the frame header the frame

165
00:06:56,080 --> 00:06:58,319
control field stores a lot of important

166
00:06:58,319 --> 00:07:00,560
information including the type of frame

167
00:07:00,560 --> 00:07:02,720
whether it is a fragmented frame and so

168
00:07:02,720 --> 00:07:03,599
on

169
00:07:03,599 --> 00:07:05,840
there are also several address fields in

170
00:07:05,840 --> 00:07:08,240
the frame header which are used to

171
00:07:08,240 --> 00:07:11,120
indicate the sender receiver and the

172
00:07:11,120 --> 00:07:14,400
bssid address of the frame

173
00:07:14,400 --> 00:07:16,800
the frame body is followed by the frame

174
00:07:16,800 --> 00:07:19,199
header and shown in the figure it is the

175
00:07:19,199 --> 00:07:21,680
structure of a beacon frame you can see

176
00:07:21,680 --> 00:07:23,840
that a white chakra identifies the frame

177
00:07:23,840 --> 00:07:26,240
type with several address and a standard

178
00:07:26,240 --> 00:07:29,240
address

179
00:07:30,160 --> 00:07:32,400
different types of mac frames have some

180
00:07:32,400 --> 00:07:34,960
difference in the format of frame body

181
00:07:34,960 --> 00:07:37,520
the general format is composed of some

182
00:07:37,520 --> 00:07:39,840
fixed length structure and some variable

183
00:07:39,840 --> 00:07:42,639
lens information elements the pikachu is

184
00:07:42,639 --> 00:07:45,520
an association frame you can see its

185
00:07:45,520 --> 00:07:47,919
frame body is composed of fixture and

186
00:07:47,919 --> 00:07:50,479
attack parameters so take the parameters

187
00:07:50,479 --> 00:07:53,039
represent information elements fixture

188
00:07:53,039 --> 00:07:55,440
is the fixed length structure the red

189
00:07:55,440 --> 00:07:59,039
mark in the figure is an ssid ie which

190
00:07:59,039 --> 00:08:02,560
represents the ssid to be connected

191
00:08:02,560 --> 00:08:04,879
you can see that the lenses i is 5 and

192
00:08:04,879 --> 00:08:07,120
the value is 37 left

193
00:08:07,120 --> 00:08:10,319
and you can see that sie is followed by

194
00:08:10,319 --> 00:08:13,840
a supported risk ie

195
00:08:14,800 --> 00:08:16,639
let's take a look at the interaction

196
00:08:16,639 --> 00:08:19,680
between st and ap when ost wants to join

197
00:08:19,680 --> 00:08:21,680
the aps network

198
00:08:21,680 --> 00:08:24,479
first sta will send a probe request to

199
00:08:24,479 --> 00:08:27,680
the ap the nsap replies to the sta with

200
00:08:27,680 --> 00:08:29,280
a probe response

201
00:08:29,280 --> 00:08:32,240
then sta sends an authentication request

202
00:08:32,240 --> 00:08:34,958
to the ap the ap request authentication

203
00:08:34,958 --> 00:08:38,000
response to sta then the sta sends a

204
00:08:38,000 --> 00:08:40,958
association request to the ap then ap

205
00:08:40,958 --> 00:08:43,760
replace with a association response to

206
00:08:43,760 --> 00:08:44,959
the sta

207
00:08:44,959 --> 00:08:47,360
after the association is completed the

208
00:08:47,360 --> 00:08:49,680
data frame interaction will start and

209
00:08:49,680 --> 00:08:52,000
the import authentication is carried out

210
00:08:52,000 --> 00:08:54,399
in the data frame interaction in this

211
00:08:54,399 --> 00:08:56,480
process the information exchanged

212
00:08:56,480 --> 00:08:59,360
between st and ap is mainly created by

213
00:08:59,360 --> 00:09:02,160
various ie

214
00:09:04,399 --> 00:09:06,880
next i will take a real text formula for

215
00:09:06,880 --> 00:09:09,360
format network card and its linux driver

216
00:09:09,360 --> 00:09:11,920
for soft map network as examples to

217
00:09:11,920 --> 00:09:13,120
introduce a

218
00:09:13,120 --> 00:09:15,600
remote attack surface or wi-fi portable

219
00:09:15,600 --> 00:09:19,040
stack as well as audit and analysis

220
00:09:19,040 --> 00:09:21,760
technique of wi-fi protocols dac and

221
00:09:21,760 --> 00:09:23,920
introduced several previous disclosure

222
00:09:23,920 --> 00:09:26,640
vulnerabilities

223
00:09:27,200 --> 00:09:29,360
first let's take a look at the current

224
00:09:29,360 --> 00:09:31,600
hardware and software architecture for

225
00:09:31,600 --> 00:09:33,760
wi-fi network card the left picture

226
00:09:33,760 --> 00:09:35,839
shows the architecture of two types of

227
00:09:35,839 --> 00:09:38,560
wi-fi network currently wi-fi network

228
00:09:38,560 --> 00:09:40,880
can be divided into format and soft

229
00:09:40,880 --> 00:09:42,640
macro network class the difference

230
00:09:42,640 --> 00:09:45,279
between two is the location of the mac

231
00:09:45,279 --> 00:09:47,680
layer processing logic the processing

232
00:09:47,680 --> 00:09:49,680
logic of the mac layer in the format

233
00:09:49,680 --> 00:09:50,399
network

234
00:09:50,399 --> 00:09:53,279
is located in the firmware code of the

235
00:09:53,279 --> 00:09:54,560
chip

236
00:09:54,560 --> 00:09:56,480
which means that the processing of the

237
00:09:56,480 --> 00:09:59,279
information elements in wi-fi frame and

238
00:09:59,279 --> 00:10:01,519
the protocol stator machine are located

239
00:10:01,519 --> 00:10:04,240
in the firmware of the wi-fi chip where

240
00:10:04,240 --> 00:10:06,480
the processing logic of the mac layer in

241
00:10:06,480 --> 00:10:09,760
the soft network card is located in the

242
00:10:09,760 --> 00:10:11,440
driver code

243
00:10:11,440 --> 00:10:13,440
the figure on the right solution

244
00:10:13,440 --> 00:10:15,600
implementation of the linux soft mac

245
00:10:15,600 --> 00:10:18,320
driver the difference between the two is

246
00:10:18,320 --> 00:10:21,160
that the mach layer on the left use mac

247
00:10:21,160 --> 00:10:23,920
80211 while the mach layer on the right

248
00:10:23,920 --> 00:10:25,920
is implemented by the triple

249
00:10:25,920 --> 00:10:29,519
manufacturer macbeth 0 201 is the wifi

250
00:10:29,519 --> 00:10:31,440
mac layer implemented by the linux

251
00:10:31,440 --> 00:10:34,320
kernel itself its called quantity is

252
00:10:34,320 --> 00:10:36,800
relatively high and it is difficult to

253
00:10:36,800 --> 00:10:38,800
find variabilities in it

254
00:10:38,800 --> 00:10:41,279
however the mac layer implemented by the

255
00:10:41,279 --> 00:10:43,040
manufacturer is often prone to

256
00:10:43,040 --> 00:10:45,839
availabilities because it has not been

257
00:10:45,839 --> 00:10:48,880
gently audited

258
00:10:50,720 --> 00:10:53,440
next let me introduce the ideas and the

259
00:10:53,440 --> 00:10:56,160
technique of auditing the code of wifi

260
00:10:56,160 --> 00:10:58,720
protocol step this technique are also

261
00:10:58,720 --> 00:11:01,600
applicable to audit the code of other

262
00:11:01,600 --> 00:11:04,000
similar protocol stacks such as bi

263
00:11:04,000 --> 00:11:05,279
protocol

264
00:11:05,279 --> 00:11:08,000
code audit is actually a manual data

265
00:11:08,000 --> 00:11:09,680
flow analysis

266
00:11:09,680 --> 00:11:12,079
the process is as follows

267
00:11:12,079 --> 00:11:13,680
first we need to find the code

268
00:11:13,680 --> 00:11:16,800
responsible for processing internal data

269
00:11:16,800 --> 00:11:19,279
because probabilities are caused by

270
00:11:19,279 --> 00:11:21,920
improper handling of internal data

271
00:11:21,920 --> 00:11:23,760
common methods for locating data

272
00:11:23,760 --> 00:11:26,320
processing code are as follows first we

273
00:11:26,320 --> 00:11:28,320
can study some keywords in the code such

274
00:11:28,320 --> 00:11:30,720
as probe become and other keywords

275
00:11:30,720 --> 00:11:33,040
related to the wifi protocol

276
00:11:33,040 --> 00:11:35,760
in addition we can also use some command

277
00:11:35,760 --> 00:11:38,079
function name keywords such as pass

278
00:11:38,079 --> 00:11:39,040
handle

279
00:11:39,040 --> 00:11:41,360
second we can find the target code

280
00:11:41,360 --> 00:11:43,200
according to the wi-fi protocol

281
00:11:43,200 --> 00:11:45,920
specification and the processing logic

282
00:11:45,920 --> 00:11:48,480
in the code third we can quickly locate

283
00:11:48,480 --> 00:11:50,800
the data processing code by analysing

284
00:11:50,800 --> 00:11:53,680
the rule case of historical abilities

285
00:11:53,680 --> 00:11:55,680
in addition by analyzing historical

286
00:11:55,680 --> 00:11:57,680
abilities we can also know the scenes

287
00:11:57,680 --> 00:12:00,399
that are frontal bars when handles a

288
00:12:00,399 --> 00:12:03,279
wifi protocol which helps us to quickly

289
00:12:03,279 --> 00:12:07,200
found some similar availabilities

290
00:12:07,600 --> 00:12:10,320
after located the data processing code

291
00:12:10,320 --> 00:12:12,720
we need to check the data transmission

292
00:12:12,720 --> 00:12:14,800
and the process in the code in the

293
00:12:14,800 --> 00:12:17,279
process of checking data we need to pay

294
00:12:17,279 --> 00:12:19,920
addition to whether the operation of

295
00:12:19,920 --> 00:12:22,240
process data will cause variabilities

296
00:12:22,240 --> 00:12:24,240
there are two scenarios that are

297
00:12:24,240 --> 00:12:25,839
pronunciabilities

298
00:12:25,839 --> 00:12:28,560
the first is the process of various java

299
00:12:28,560 --> 00:12:30,959
data such as information elements equal

300
00:12:30,959 --> 00:12:33,519
frame structure and some nested table

301
00:12:33,519 --> 00:12:34,880
structures

302
00:12:34,880 --> 00:12:37,360
the second is the arithmetical operation

303
00:12:37,360 --> 00:12:39,920
in the code if the data involved in the

304
00:12:39,920 --> 00:12:42,720
calculation is not checked and integer

305
00:12:42,720 --> 00:12:45,839
overflow may occur

306
00:12:46,560 --> 00:12:48,360
next i will take

307
00:12:48,360 --> 00:12:51,360
rtl8195a as an example to introduce how

308
00:12:51,360 --> 00:12:54,079
to start with historical abilities and

309
00:12:54,079 --> 00:12:56,480
then analyze the code flow of this

310
00:12:56,480 --> 00:12:58,639
firmware and finally discover new

311
00:12:58,639 --> 00:13:00,000
availabilities

312
00:13:00,000 --> 00:13:01,639
in february

313
00:13:01,639 --> 00:13:05,760
2021 vdo team released several webinars

314
00:13:05,760 --> 00:13:09,680
in the wifi product stack of rtl8195a

315
00:13:09,680 --> 00:13:11,839
after analysis i found that these

316
00:13:11,839 --> 00:13:14,320
variabilities are mainly costed by not

317
00:13:14,320 --> 00:13:16,560
checking the data length when processing

318
00:13:16,560 --> 00:13:18,639
some type of data structure in the wi-fi

319
00:13:18,639 --> 00:13:22,079
frame such as the e-portframe

320
00:13:22,079 --> 00:13:23,920
the right picture in the slider is one

321
00:13:23,920 --> 00:13:26,560
of the bug you can see that when the

322
00:13:26,560 --> 00:13:28,639
length of input message is greater than

323
00:13:28,639 --> 00:13:31,279
the length of temp buffer actual memo

324
00:13:31,279 --> 00:13:33,440
copy will cause overflow when coping

325
00:13:33,440 --> 00:13:37,360
data to the temp buffer

326
00:13:38,240 --> 00:13:39,240
the

327
00:13:39,240 --> 00:13:42,160
rtl8195a is a real-time four mac wi-fi

328
00:13:42,160 --> 00:13:43,120
card

329
00:13:43,120 --> 00:13:45,199
the code voice wi-fi protocol stack and

330
00:13:45,199 --> 00:13:47,760
the developer's code will run on the

331
00:13:47,760 --> 00:13:50,000
ship as part of the firmware the

332
00:13:50,000 --> 00:13:52,639
protocol stack code is located in the

333
00:13:52,639 --> 00:13:55,839
static library of the sdk users can use

334
00:13:55,839 --> 00:13:58,399
sdk to develop their app level

335
00:13:58,399 --> 00:14:01,360
applications and this statical library

336
00:14:01,360 --> 00:14:04,560
in the sdk are linked into a firmware

337
00:14:04,560 --> 00:14:06,880
which is placed in the ram of the chip

338
00:14:06,880 --> 00:14:08,800
to run

339
00:14:08,800 --> 00:14:11,440
the following figure shows some static

340
00:14:11,440 --> 00:14:15,199
link libraries in the sdk the lib wlan.a

341
00:14:15,199 --> 00:14:17,519
contains most of the code of wifi portal

342
00:14:17,519 --> 00:14:19,680
step such as passing information

343
00:14:19,680 --> 00:14:22,480
elements handle protocol state machine

344
00:14:22,480 --> 00:14:26,639
password verification and so on

345
00:14:26,720 --> 00:14:31,519
next i will take cve 2020 9395 as an

346
00:14:31,519 --> 00:14:33,440
example to introduce how to analyze

347
00:14:33,440 --> 00:14:35,560
availabilities of

348
00:14:35,560 --> 00:14:38,320
rtl8195a in order to improve the

349
00:14:38,320 --> 00:14:41,760
efficiency of analysis i first extracted

350
00:14:41,760 --> 00:14:42,560
the

351
00:14:42,560 --> 00:14:45,519
old file in the o dot a file and then

352
00:14:45,519 --> 00:14:48,800
use gcc to link all the dot a files into

353
00:14:48,800 --> 00:14:51,760
a exo file and then i use i dot for

354
00:14:51,760 --> 00:14:54,720
analysis after i download the excel file

355
00:14:54,720 --> 00:14:57,199
we jump to the variability function that

356
00:14:57,199 --> 00:14:59,440
is a checkmate function the content of

357
00:14:59,440 --> 00:15:01,519
the function after the variability is

358
00:15:01,519 --> 00:15:03,920
patched is shown in the right figure

359
00:15:03,920 --> 00:15:06,800
the logic of the function is as follows

360
00:15:06,800 --> 00:15:09,279
first is a copy input data in the wifi

361
00:15:09,279 --> 00:15:12,079
frame towards dac buffer then i need to

362
00:15:12,079 --> 00:15:14,639
calculate the hash of the data

363
00:15:14,639 --> 00:15:17,120
finally it will verify the mix field in

364
00:15:17,120 --> 00:15:19,120
the e-power frame to ensure that there

365
00:15:19,120 --> 00:15:22,160
is no error in the data and showing the

366
00:15:22,160 --> 00:15:24,560
red box in the figure the patch the

367
00:15:24,560 --> 00:15:26,639
function editor check at the beginning

368
00:15:26,639 --> 00:15:28,800
of function to ensure that the data

369
00:15:28,800 --> 00:15:32,639
length is less than 0x 200 bytes so as

370
00:15:32,639 --> 00:15:36,639
to avoid stack overflow

371
00:15:38,320 --> 00:15:40,639
by analyzing the context of availability

372
00:15:40,639 --> 00:15:42,320
function we can know that the data

373
00:15:42,320 --> 00:15:44,800
parameter of the check make function

374
00:15:44,800 --> 00:15:46,680
actually points to the

375
00:15:46,680 --> 00:15:49,600
letter02.1x part of the wifi frame and

376
00:15:49,600 --> 00:15:52,079
the second parameter is the lens of the

377
00:15:52,079 --> 00:15:54,800
data therefore we can note that the data

378
00:15:54,800 --> 00:15:56,079
points to the

379
00:15:56,079 --> 00:15:58,720
externally controllable data and then we

380
00:15:58,720 --> 00:16:00,880
can check back to the app layer from the

381
00:16:00,880 --> 00:16:02,880
checkmaker function to check the use of

382
00:16:02,880 --> 00:16:05,759
the data so as to locate the code

383
00:16:05,759 --> 00:16:08,240
related to the wi-fi data processing in

384
00:16:08,240 --> 00:16:11,040
the program

385
00:16:12,240 --> 00:16:14,240
then i looked for the color of the

386
00:16:14,240 --> 00:16:16,639
checkmate function and try to found some

387
00:16:16,639 --> 00:16:18,560
new availabilities by checking the use

388
00:16:18,560 --> 00:16:20,800
of the data parameter

389
00:16:20,800 --> 00:16:22,399
then i found the code shown in the

390
00:16:22,399 --> 00:16:24,720
figure on the right you can see that in

391
00:16:24,720 --> 00:16:28,639
the 96 data plus 18 is a send to the

392
00:16:28,639 --> 00:16:31,040
import key message received member of

393
00:16:31,040 --> 00:16:32,880
the info structure

394
00:16:32,880 --> 00:16:35,040
then it will call checkmate function to

395
00:16:35,040 --> 00:16:38,079
verify the mic value of the data

396
00:16:38,079 --> 00:16:40,800
after the verification is passed it will

397
00:16:40,800 --> 00:16:45,199
call dc-gdk to decrypt some of the data

398
00:16:45,199 --> 00:16:47,839
finally mem copy will be coded to copy

399
00:16:47,839 --> 00:16:51,040
the data of the import key message icv

400
00:16:51,040 --> 00:16:53,680
to the auto stack buffer but the size

401
00:16:53,680 --> 00:16:55,759
parameter of a bam copy is directly

402
00:16:55,759 --> 00:16:58,880
taken from e4 key message received

403
00:16:58,880 --> 00:17:01,040
if this value is too large it will lead

404
00:17:01,040 --> 00:17:05,079
the stack overflow availability

405
00:17:05,599 --> 00:17:08,640
after continuous upload back checking we

406
00:17:08,640 --> 00:17:10,880
can gradually master the structure of

407
00:17:10,880 --> 00:17:13,199
the code to call the flow chart of the

408
00:17:13,199 --> 00:17:15,679
firmware we need to process wifi frames

409
00:17:15,679 --> 00:17:18,079
as follows

410
00:17:18,079 --> 00:17:20,319
first when wi-fi network card receives a

411
00:17:20,319 --> 00:17:22,640
wi-fi packet it will trigger and

412
00:17:22,640 --> 00:17:26,199
interrupt and then the cpu will call

413
00:17:26,199 --> 00:17:29,360
rtl8195a receive tasker that function

414
00:17:29,360 --> 00:17:31,520
which is used to process the received

415
00:17:31,520 --> 00:17:32,960
wi-fi packet

416
00:17:32,960 --> 00:17:35,440
this function will call receive func

417
00:17:35,440 --> 00:17:36,960
receive function is an intriguing

418
00:17:36,960 --> 00:17:39,679
function of packet processing received

419
00:17:39,679 --> 00:17:42,320
from the first call the serial func pro

420
00:17:42,320 --> 00:17:44,559
handle which is mainly responsible for

421
00:17:44,559 --> 00:17:46,640
processing management frame such as

422
00:17:46,640 --> 00:17:48,799
probe become and so on

423
00:17:48,799 --> 00:17:50,960
received bank processor handle is used

424
00:17:50,960 --> 00:17:53,520
to process data frames when data frames

425
00:17:53,520 --> 00:17:56,240
involve fragmentation and aggregation

426
00:17:56,240 --> 00:17:58,320
the function first aggregates the

427
00:17:58,320 --> 00:18:01,679
limited data frame and then cross htw

428
00:18:01,679 --> 00:18:03,760
receive indicator package to process

429
00:18:03,760 --> 00:18:06,480
data frames after analysis

430
00:18:06,480 --> 00:18:08,720
the main work of this function is to

431
00:18:08,720 --> 00:18:11,840
pass the data related to e4 frames

432
00:18:11,840 --> 00:18:14,400
vulgarity's motion above has appeared in

433
00:18:14,400 --> 00:18:17,120
this function

434
00:18:18,720 --> 00:18:20,880
let's take a look at another hip

435
00:18:20,880 --> 00:18:22,880
overflow variability when firmware

436
00:18:22,880 --> 00:18:25,120
passing information elements

437
00:18:25,120 --> 00:18:27,919
when the function has a specific

438
00:18:27,919 --> 00:18:30,160
information element it will enter line

439
00:18:30,160 --> 00:18:32,799
14 in the figure for process

440
00:18:32,799 --> 00:18:35,600
it first lock the memory to new ie the

441
00:18:35,600 --> 00:18:39,360
memory set is a length of ie minus 2

442
00:18:39,360 --> 00:18:41,600
then when copy memory to new ie the

443
00:18:41,600 --> 00:18:44,160
length of the computator is ions

444
00:18:44,160 --> 00:18:46,720
minerals 4. the structure of pi is

445
00:18:46,720 --> 00:18:49,520
defined on the left side of the slide

446
00:18:49,520 --> 00:18:52,160
all members in the pie are obtained from

447
00:18:52,160 --> 00:18:54,720
the waffle frame when the length of pair

448
00:18:54,720 --> 00:18:56,960
is three only one byte of memory will be

449
00:18:56,960 --> 00:19:00,160
located to new ie in the line 14 however

450
00:19:00,160 --> 00:19:04,400
when copy memory in 9 19 0xff bytes of

451
00:19:04,400 --> 00:19:07,440
data will be copied due to the integer

452
00:19:07,440 --> 00:19:09,600
overflow which leads to a hip overflow

453
00:19:09,600 --> 00:19:12,320
availability

454
00:19:13,760 --> 00:19:15,440
in addition to some new memory

455
00:19:15,440 --> 00:19:17,919
availabilities found in the formula and

456
00:19:17,919 --> 00:19:19,840
interesting things we found in the

457
00:19:19,840 --> 00:19:22,840
process of help real time to fix these

458
00:19:22,840 --> 00:19:25,440
probabilities next i will share it with

459
00:19:25,440 --> 00:19:28,080
you to avoid a similar situation in the

460
00:19:28,080 --> 00:19:29,760
future

461
00:19:29,760 --> 00:19:33,520
on the february 3 2021 the radio

462
00:19:33,520 --> 00:19:35,360
security team disclosed the sound

463
00:19:35,360 --> 00:19:38,000
varieties in rtl81958

464
00:19:38,000 --> 00:19:39,919
and the status that the vulnerabilities

465
00:19:39,919 --> 00:19:44,320
are completely fixed in april 20.

466
00:19:44,320 --> 00:19:47,760
on february 4 2021 after another

467
00:19:47,760 --> 00:19:49,919
sentence the probabilities and the patch

468
00:19:49,919 --> 00:19:52,480
for this i discovered some additional

469
00:19:52,480 --> 00:19:55,600
abilities and submitted services to

470
00:19:55,600 --> 00:19:58,880
reattacker by github

471
00:19:58,880 --> 00:20:02,720
and on february 26 2021

472
00:20:02,720 --> 00:20:04,559
japan stated that there's a new

473
00:20:04,559 --> 00:20:05,679
submission

474
00:20:05,679 --> 00:20:09,520
that was a fixture in sdk

475
00:20:09,760 --> 00:20:13,600
and a few months later on august 16th i

476
00:20:13,600 --> 00:20:16,159
announced that the latest version of the

477
00:20:16,159 --> 00:20:17,919
sdk again and found that some

478
00:20:17,919 --> 00:20:20,480
availabilities as submitted before have

479
00:20:20,480 --> 00:20:22,320
not been fixed

480
00:20:22,320 --> 00:20:25,200
on the september 7th after repeated

481
00:20:25,200 --> 00:20:27,360
communication with real tab it will

482
00:20:27,360 --> 00:20:29,840
found that the builder did not merge the

483
00:20:29,840 --> 00:20:32,159
patch for the availability

484
00:20:32,159 --> 00:20:34,720
on september 7th real text released the

485
00:20:34,720 --> 00:20:37,200
lead tester sdk which fixed the

486
00:20:37,200 --> 00:20:38,880
probabilities

487
00:20:38,880 --> 00:20:40,799
we can learn from this method that we

488
00:20:40,799 --> 00:20:43,919
should do well the regulation test after

489
00:20:43,919 --> 00:20:45,760
patching liabilities and the version

490
00:20:45,760 --> 00:20:49,840
management needed to be standardized

491
00:20:53,679 --> 00:20:56,080
next i will introduce how to audit the

492
00:20:56,080 --> 00:20:58,880
linux software driver of realtek and

493
00:20:58,880 --> 00:21:01,200
introduce some previous availabilities

494
00:21:01,200 --> 00:21:02,960
the reason i researched real test

495
00:21:02,960 --> 00:21:05,440
software mac driver was that i needed to

496
00:21:05,440 --> 00:21:08,720
perform wi-fi fuzzy in the 5g band

497
00:21:08,720 --> 00:21:11,280
after some searching i finally found the

498
00:21:11,280 --> 00:21:13,679
rto812au

499
00:21:13,679 --> 00:21:15,600
wireless network car

500
00:21:15,600 --> 00:21:18,000
then when debugging some banks analyzes

501
00:21:18,000 --> 00:21:19,600
its travel code and found some

502
00:21:19,600 --> 00:21:21,559
variabilities

503
00:21:21,559 --> 00:21:25,280
rtl812ao is a software network card

504
00:21:25,280 --> 00:21:28,000
it can use pointer mode in two-door 4g

505
00:21:28,000 --> 00:21:30,960
and 5g frequency bands and its price is

506
00:21:30,960 --> 00:21:33,440
relatively cheap in addition the core

507
00:21:33,440 --> 00:21:35,600
logic of the driver is similar between

508
00:21:35,600 --> 00:21:38,559
different realtek network card models so

509
00:21:38,559 --> 00:21:40,240
the variability is a funnel here can

510
00:21:40,240 --> 00:21:45,440
affect most real-time sold network class

511
00:21:47,600 --> 00:21:50,640
if i observe the derogatory structure of

512
00:21:50,640 --> 00:21:52,640
the driver and the searching keywords in

513
00:21:52,640 --> 00:21:54,799
the driver code we can find the code

514
00:21:54,799 --> 00:21:57,120
responsible for passing wifi data and

515
00:21:57,120 --> 00:22:00,799
then check the data processing flow

516
00:22:00,799 --> 00:22:03,600
finally we can get the code flow of the

517
00:22:03,600 --> 00:22:06,320
driver which is showing the figure when

518
00:22:06,320 --> 00:22:08,640
the driver is loaded into linux kernel

519
00:22:08,640 --> 00:22:11,360
it will register a interrupt handle in

520
00:22:11,360 --> 00:22:12,480
the kernel

521
00:22:12,480 --> 00:22:14,640
when the hardware of network card

522
00:22:14,640 --> 00:22:15,679
receives

523
00:22:15,679 --> 00:22:18,080
a wifi frame from the l interface it

524
00:22:18,080 --> 00:22:20,880
will trigger the interrupter and then

525
00:22:20,880 --> 00:22:23,280
the kernel will cause the interrupter

526
00:22:23,280 --> 00:22:27,360
process function to handle the package

527
00:22:27,360 --> 00:22:29,200
after interrupt process function

528
00:22:29,200 --> 00:22:31,840
performs some simple process on the data

529
00:22:31,840 --> 00:22:33,919
it will call receive buffer to receive

530
00:22:33,919 --> 00:22:36,880
frame for specific data processing if

531
00:22:36,880 --> 00:22:39,600
the monitor mode is enabled on the wi-fi

532
00:22:39,600 --> 00:22:40,880
card

533
00:22:40,880 --> 00:22:42,880
receive buffer to receive frame where

534
00:22:42,880 --> 00:22:45,120
called receive frame monitor sends the

535
00:22:45,120 --> 00:22:47,760
data package to the user space process

536
00:22:47,760 --> 00:22:50,400
and then the function will return

537
00:22:50,400 --> 00:22:53,679
when the monitor mode is not enabled

538
00:22:53,679 --> 00:22:55,760
it will call receive functional handle

539
00:22:55,760 --> 00:22:58,240
to process the management frames for

540
00:22:58,240 --> 00:23:01,600
example onpro request is used to process

541
00:23:01,600 --> 00:23:03,200
probe request

542
00:23:03,200 --> 00:23:05,760
if it is a data frame it will enter

543
00:23:05,760 --> 00:23:08,400
receive function handle this function

544
00:23:08,400 --> 00:23:11,039
first decrypts the data frame

545
00:23:11,039 --> 00:23:14,000
and if it is a tds frame on tdis

546
00:23:14,000 --> 00:23:15,679
function will be called

547
00:23:15,679 --> 00:23:18,159
otherwise fragment aggregation of the

548
00:23:18,159 --> 00:23:20,320
data frame will be carried out and

549
00:23:20,320 --> 00:23:22,240
finally it will call receive process

550
00:23:22,240 --> 00:23:25,360
mpdo to process the aggregated data

551
00:23:25,360 --> 00:23:27,760
frames

552
00:23:28,799 --> 00:23:30,880
by analysis the source code of the

553
00:23:30,880 --> 00:23:33,640
realtek driver and compared it with mac

554
00:23:33,640 --> 00:23:36,640
8021 in the links kernel we can guess

555
00:23:36,640 --> 00:23:38,559
that there are two main parts of the

556
00:23:38,559 --> 00:23:41,440
driver that are prone to vulnerabilities

557
00:23:41,440 --> 00:23:44,559
first some basical types of room of the

558
00:23:44,559 --> 00:23:46,720
wifi protocol will be passed in the

559
00:23:46,720 --> 00:23:49,760
driver such as probe become this is

560
00:23:49,760 --> 00:23:53,520
similar to the working mode of max s0211

561
00:23:53,520 --> 00:23:55,760
but because the code for processes

562
00:23:55,760 --> 00:23:57,679
frames in the real-time driver is

563
00:23:57,679 --> 00:23:59,760
developed by itself

564
00:23:59,760 --> 00:24:02,159
so the code quality should not be as

565
00:24:02,159 --> 00:24:05,760
good as mac 8021

566
00:24:05,760 --> 00:24:07,919
the second risk is that the real tech

567
00:24:07,919 --> 00:24:10,159
driver will also handle more complex

568
00:24:10,159 --> 00:24:12,559
protocols such as the tdis and the wi-fi

569
00:24:12,559 --> 00:24:14,720
pdp in the standard

570
00:24:14,720 --> 00:24:15,400
mac

571
00:24:15,400 --> 00:24:18,720
80211 driver the process of this

572
00:24:18,720 --> 00:24:21,039
protocol is handled by a user space

573
00:24:21,039 --> 00:24:22,080
process

574
00:24:22,080 --> 00:24:25,120
which limb is a wpa supplicant so it

575
00:24:25,120 --> 00:24:27,520
will introduce a new attack surface to

576
00:24:27,520 --> 00:24:29,679
the driver

577
00:24:29,679 --> 00:24:32,080
after analyze the code flow and

578
00:24:32,080 --> 00:24:34,880
determine the potential vulnerability

579
00:24:34,880 --> 00:24:37,360
locations the next things we need to do

580
00:24:37,360 --> 00:24:40,480
is to carefully analyze the wi-fi data

581
00:24:40,480 --> 00:24:42,960
processing logic in the code especially

582
00:24:42,960 --> 00:24:45,520
the various memory operations to find

583
00:24:45,520 --> 00:24:48,720
the security probabilities

584
00:24:48,720 --> 00:24:50,799
and show in the figure below it is a

585
00:24:50,799 --> 00:24:53,200
hebrew probability costed by the

586
00:24:53,200 --> 00:24:56,960
programmer when passing the supported ie

587
00:24:56,960 --> 00:24:59,600
in the saturation response frame the

588
00:24:59,600 --> 00:25:03,120
size of the supported risk infra ap is a

589
00:25:03,120 --> 00:25:06,000
16 bytes when the length of ie is

590
00:25:06,000 --> 00:25:10,240
greater than 16 it will overflow

591
00:25:10,720 --> 00:25:13,200
as i mentioned earlier in addition to

592
00:25:13,200 --> 00:25:15,360
the basic management frame

593
00:25:15,360 --> 00:25:18,400
the rear tech driver also processes tdrs

594
00:25:18,400 --> 00:25:19,039
and

595
00:25:19,039 --> 00:25:22,000
p2p protocol related data let's take a

596
00:25:22,000 --> 00:25:24,240
look at the availabilities when realtek

597
00:25:24,240 --> 00:25:27,760
driver process a wi-fi pdp protocol

598
00:25:27,760 --> 00:25:30,480
the wi-fi pdp protocol mainly transmits

599
00:25:30,480 --> 00:25:32,799
data through action frames and a small

600
00:25:32,799 --> 00:25:34,799
part of the data is also transmitted to

601
00:25:34,799 --> 00:25:37,679
the slow probe saturation and become

602
00:25:37,679 --> 00:25:40,720
frames and showing the figure is a brief

603
00:25:40,720 --> 00:25:44,320
wi-fi p2p protocol introduction process

604
00:25:44,320 --> 00:25:48,480
first usb send a pro request to device a

605
00:25:48,480 --> 00:25:51,039
unlike the normal pro request the

606
00:25:51,039 --> 00:25:54,240
request will carry a pdp ie which is

607
00:25:54,240 --> 00:25:56,799
used to transmit some pdp related

608
00:25:56,799 --> 00:25:58,720
information

609
00:25:58,720 --> 00:26:00,960
then device a will respond to a proper

610
00:26:00,960 --> 00:26:03,679
response packet this step is called the

611
00:26:03,679 --> 00:26:07,039
device discovery step

612
00:26:07,039 --> 00:26:09,760
next group owner negotiation will be

613
00:26:09,760 --> 00:26:11,200
carried out

614
00:26:11,200 --> 00:26:14,480
in this step pwp package of gold ngo

615
00:26:14,480 --> 00:26:17,360
type will be used for interaction and

616
00:26:17,360 --> 00:26:19,679
the information exchanged between the

617
00:26:19,679 --> 00:26:22,080
device will be transmitted through

618
00:26:22,080 --> 00:26:25,440
various attributes in the pdie after the

619
00:26:25,440 --> 00:26:28,640
geo negotiation is completed the

620
00:26:28,640 --> 00:26:31,120
interaction similar to the ap model will

621
00:26:31,120 --> 00:26:33,520
be carried out including standard

622
00:26:33,520 --> 00:26:36,240
authentication and association frames

623
00:26:36,240 --> 00:26:38,480
the only difference is that wi-fi pdp

624
00:26:38,480 --> 00:26:40,960
will carry ppi in these rooms to

625
00:26:40,960 --> 00:26:45,120
transmit wi-fi p2p related data

626
00:26:46,960 --> 00:26:49,120
on the previous page i introduced the

627
00:26:49,120 --> 00:26:52,320
introduction of the wifi pdp protocol

628
00:26:52,320 --> 00:26:54,080
here we will take a look at the

629
00:26:54,080 --> 00:26:56,960
structure of pwpi in wi-fi p2p the

630
00:26:56,960 --> 00:26:58,880
information in the pdp protocol

631
00:26:58,880 --> 00:27:01,679
specification is a transferred between

632
00:27:01,679 --> 00:27:03,440
device through the pdp information

633
00:27:03,440 --> 00:27:04,400
element

634
00:27:04,400 --> 00:27:06,320
the structure of pdp information

635
00:27:06,320 --> 00:27:09,120
elements is shown in the left figure

636
00:27:09,120 --> 00:27:12,480
first its element id is zero xdd which

637
00:27:12,480 --> 00:27:15,520
means it is a vendor ie and then through

638
00:27:15,520 --> 00:27:18,159
the our and our type field it is

639
00:27:18,159 --> 00:27:21,200
specified as a pwie

640
00:27:21,200 --> 00:27:24,320
the oui type is followed by an

641
00:27:24,320 --> 00:27:27,039
indeterminate number of attributes the

642
00:27:27,039 --> 00:27:29,200
structure of attribute is as shown in

643
00:27:29,200 --> 00:27:32,159
the right picture each attribute has one

644
00:27:32,159 --> 00:27:34,480
byte attribute id which indicates its

645
00:27:34,480 --> 00:27:35,360
type

646
00:27:35,360 --> 00:27:37,600
then there is a length of two bands

647
00:27:37,600 --> 00:27:39,520
which represents the length of the

648
00:27:39,520 --> 00:27:41,200
attribute body

649
00:27:41,200 --> 00:27:43,360
then there is the content of the

650
00:27:43,360 --> 00:27:45,440
attribute body therefore we can know

651
00:27:45,440 --> 00:27:49,840
that pwie actually embed a variable lens

652
00:27:49,840 --> 00:27:52,799
attribute structure in the basic ie and

653
00:27:52,799 --> 00:27:56,080
the passing of such nested variable

654
00:27:56,080 --> 00:27:57,840
length structure is often prone to

655
00:27:57,840 --> 00:27:59,039
problems

656
00:27:59,039 --> 00:28:01,279
next let's take a look at how they

657
00:28:01,279 --> 00:28:04,799
attack past these attributes

658
00:28:05,279 --> 00:28:07,600
the picture on the left is a pwie

659
00:28:07,600 --> 00:28:10,720
captured by well shark

660
00:28:10,720 --> 00:28:13,360
there is a pdp capability attribute in

661
00:28:13,360 --> 00:28:15,200
the ie and the lens of the

662
00:28:15,200 --> 00:28:16,559
9

663
00:28:16,559 --> 00:28:19,200
on the right is a code for passing pdp

664
00:28:19,200 --> 00:28:21,440
capability attributed in the real-time

665
00:28:21,440 --> 00:28:24,240
driver the code flow is as follows first

666
00:28:24,240 --> 00:28:27,760
is the core rtw get a pdpi in the 93 to

667
00:28:27,760 --> 00:28:31,760
sell the pwie in the received wifi frame

668
00:28:31,760 --> 00:28:34,720
there is a code iwgate pwph builder

669
00:28:34,720 --> 00:28:37,440
content name file to find the attribute

670
00:28:37,440 --> 00:28:40,159
whose attribute id is pdp capability in

671
00:28:40,159 --> 00:28:42,960
pdp ie and the content of the attribute

672
00:28:42,960 --> 00:28:45,440
will be copied to cap attr and the

673
00:28:45,440 --> 00:28:47,840
length of the attribute will be saved to

674
00:28:47,840 --> 00:28:51,120
http content alone

675
00:28:51,919 --> 00:28:53,840
let's take a look at the process and

676
00:28:53,840 --> 00:28:58,240
logical http atdr content function the

677
00:28:58,240 --> 00:29:00,880
code is showing the figure first in line

678
00:29:00,880 --> 00:29:03,440
6 it called itw get a pdp edge builder

679
00:29:03,440 --> 00:29:06,799
to find a specific attribute in pvi and

680
00:29:06,799 --> 00:29:10,000
return the starter address or attribute

681
00:29:10,000 --> 00:29:12,880
the length of attribute is studied in 80

682
00:29:12,880 --> 00:29:14,000
challenge

683
00:29:14,000 --> 00:29:16,559
then if buffer content is not empty the

684
00:29:16,559 --> 00:29:20,000
content of ati will be copied to buffer

685
00:29:20,000 --> 00:29:22,240
content and the length of the memo crop

686
00:29:22,240 --> 00:29:26,000
is 80 000 minus 3. note that it is not

687
00:29:26,000 --> 00:29:28,080
checked whether the copy length is

688
00:29:28,080 --> 00:29:29,919
greater than the length of buffer

689
00:29:29,919 --> 00:29:32,080
content if the length of the attribute

690
00:29:32,080 --> 00:29:33,840
is greater than the size of buffer

691
00:29:33,840 --> 00:29:36,959
content it will cause

692
00:29:38,840 --> 00:29:41,279
overflow next i will introduce a hip

693
00:29:41,279 --> 00:29:43,520
overflow variability when driver process

694
00:29:43,520 --> 00:29:46,080
the fragmentation of data frame in the

695
00:29:46,080 --> 00:29:47,760
wifi protocol

696
00:29:47,760 --> 00:29:50,240
if the length of the transmitted data is

697
00:29:50,240 --> 00:29:52,559
greater than the mto

698
00:29:52,559 --> 00:29:55,200
the frame is to be fragmented and then

699
00:29:55,200 --> 00:29:57,200
the fragmented frames needed to be

700
00:29:57,200 --> 00:30:00,559
aggregated to add the receiver device

701
00:30:00,559 --> 00:30:03,279
the frame fragmentation mechanism is

702
00:30:03,279 --> 00:30:06,000
implemented through the more fragments

703
00:30:06,000 --> 00:30:08,240
and the fragment number fields of the

704
00:30:08,240 --> 00:30:10,720
macrium header the figure show is a

705
00:30:10,720 --> 00:30:13,360
fragmented data frame so more fragments

706
00:30:13,360 --> 00:30:16,000
in the header is one which means that

707
00:30:16,000 --> 00:30:18,880
there is fragmented frames that need to

708
00:30:18,880 --> 00:30:22,799
be transmitted after this frame

709
00:30:22,799 --> 00:30:25,039
fragment number is zero means this is

710
00:30:25,039 --> 00:30:28,240
the first fragment

711
00:30:28,720 --> 00:30:31,039
the structure of the last fragmented

712
00:30:31,039 --> 00:30:33,520
frame is shown in the figure if more

713
00:30:33,520 --> 00:30:36,080
fragments is zero it means that this is

714
00:30:36,080 --> 00:30:38,559
the last fragmented frame when the

715
00:30:38,559 --> 00:30:40,880
receiver device receives this frame it

716
00:30:40,880 --> 00:30:45,120
needed to start frame aggregation

717
00:30:46,080 --> 00:30:47,919
next take a look at the whole rail tank

718
00:30:47,919 --> 00:30:50,480
driver's monitor received fragmented

719
00:30:50,480 --> 00:30:52,799
data frames when the attack receives a

720
00:30:52,799 --> 00:30:55,360
fragmented data frame it will store the

721
00:30:55,360 --> 00:30:58,080
fragmented frames in a linked list and

722
00:30:58,080 --> 00:31:01,279
then winter receives the last fragmented

723
00:31:01,279 --> 00:31:03,679
frame it will merge the fragments the

724
00:31:03,679 --> 00:31:07,039
function of receive frame deflect is to

725
00:31:07,039 --> 00:31:09,519
merge the fragmented frames in the

726
00:31:09,519 --> 00:31:12,399
linked list the specific process is as

727
00:31:12,399 --> 00:31:13,440
follows

728
00:31:13,440 --> 00:31:15,679
first it will send the header node of

729
00:31:15,679 --> 00:31:17,760
the linked list to

730
00:31:17,760 --> 00:31:21,200
pf hdr on the nice learn so pf hdr

731
00:31:21,200 --> 00:31:23,760
points to the memory that stores the

732
00:31:23,760 --> 00:31:26,320
first fragmented frame then the link

733
00:31:26,320 --> 00:31:29,279
list will be charized later and the date

734
00:31:29,279 --> 00:31:31,760
of all remaining fragments will be

735
00:31:31,760 --> 00:31:35,120
copied to the memory of the pf hdr when

736
00:31:35,120 --> 00:31:37,919
the frame size after dragon aggregation

737
00:31:37,919 --> 00:31:39,919
is greater than the size of the memory

738
00:31:39,919 --> 00:31:43,120
pointed by pf hdr a hip overflow will

739
00:31:43,120 --> 00:31:46,120
result

740
00:31:48,399 --> 00:31:52,159
since pf hdi is the memory located by

741
00:31:52,159 --> 00:31:55,919
skb buffer we can overflow to the skb

742
00:31:55,919 --> 00:31:58,720
shared info behind skb buff and shine

743
00:31:58,720 --> 00:32:01,039
the figure is the logo one cannot panic

744
00:32:01,039 --> 00:32:04,879
after the overflow is triggered

745
00:32:07,440 --> 00:32:09,279
next i will introduce the implementation

746
00:32:09,279 --> 00:32:11,279
of wi-fi hunter weather hunter is a

747
00:32:11,279 --> 00:32:14,159
wi-fi protocol further implemented based

748
00:32:14,159 --> 00:32:19,039
on the ow files with sound optimization

749
00:32:20,080 --> 00:32:22,640
authorify the best open source wifi

750
00:32:22,640 --> 00:32:25,200
browser but there are some limits

751
00:32:25,200 --> 00:32:27,519
first i test many network cards

752
00:32:27,519 --> 00:32:31,000
including rt5370

753
00:32:32,440 --> 00:32:34,240
ar9271

754
00:32:34,240 --> 00:32:38,519
812 au and so on but only

755
00:32:38,519 --> 00:32:42,559
rt3070 can work successfully but it will

756
00:32:42,559 --> 00:32:45,279
also lose some package and there is a

757
00:32:45,279 --> 00:32:48,120
more important reason is that

758
00:32:48,120 --> 00:32:51,679
rt3070 and open wi-fi only support a 2.4

759
00:32:51,679 --> 00:32:53,919
g frequency band

760
00:32:53,919 --> 00:32:56,080
due to the packet loose ends and some

761
00:32:56,080 --> 00:32:57,679
blocks in the implementation of a

762
00:32:57,679 --> 00:32:59,679
political interaction in authority

763
00:32:59,679 --> 00:33:01,600
further the interaction speed is

764
00:33:01,600 --> 00:33:04,399
relatively slow third this mutations

765
00:33:04,399 --> 00:33:06,960
challenge is relatively simple only one

766
00:33:06,960 --> 00:33:10,159
mutated ie will be generated for each

767
00:33:10,159 --> 00:33:11,679
packet

768
00:33:11,679 --> 00:33:13,919
for it don't support the frozen wi-fi

769
00:33:13,919 --> 00:33:18,080
p2p but in october ow files add some

770
00:33:18,080 --> 00:33:20,399
code it seems that the wi-fi pdp file

771
00:33:20,399 --> 00:33:23,600
was added but i have not tested it

772
00:33:23,600 --> 00:33:25,600
five the pure zero code and the

773
00:33:25,600 --> 00:33:28,159
reproduction mechanism is relatively

774
00:33:28,159 --> 00:33:29,200
simple

775
00:33:29,200 --> 00:33:31,840
six after one clash is found faster will

776
00:33:31,840 --> 00:33:34,960
exit we can't continue surfacing the

777
00:33:34,960 --> 00:33:36,000
target

778
00:33:36,000 --> 00:33:38,240
wi-fi hunter is a wi-fi protocol file

779
00:33:38,240 --> 00:33:40,799
developer data based on ultra refunds

780
00:33:40,799 --> 00:33:43,519
its main optimization are as follows

781
00:33:43,519 --> 00:33:46,799
first it optimizes the send and receive

782
00:33:46,799 --> 00:33:49,519
mechanism on wi-fi rooms which make it a

783
00:33:49,519 --> 00:33:53,480
supporting 5g banner network such as

784
00:33:53,480 --> 00:33:57,880
rtl8812au and mt7612u

785
00:33:58,399 --> 00:34:01,200
second it optimizes the protocol stator

786
00:34:01,200 --> 00:34:04,320
motion and the data mutation strategy to

787
00:34:04,320 --> 00:34:06,799
improve the speed and efficiency of

788
00:34:06,799 --> 00:34:08,480
fuzzing

789
00:34:08,480 --> 00:34:11,679
third it supports fasting wi-fi pdp

790
00:34:11,679 --> 00:34:15,040
first it optimizes the plc recording and

791
00:34:15,040 --> 00:34:17,520
replay mechanism crash detection

792
00:34:17,520 --> 00:34:19,918
mechanism and the support continuous

793
00:34:19,918 --> 00:34:22,399
frozen

794
00:34:24,239 --> 00:34:27,679
awful user interface encapsulated by

795
00:34:27,679 --> 00:34:30,000
aircraft ng to send and receive

796
00:34:30,000 --> 00:34:33,199
perfected frames after some research and

797
00:34:33,199 --> 00:34:35,760
experimentation i found that when i used

798
00:34:35,760 --> 00:34:37,839
little pcap interface to send and

799
00:34:37,839 --> 00:34:40,199
receive package

800
00:34:40,199 --> 00:34:43,839
ar9271 it went to au and other network

801
00:34:43,839 --> 00:34:46,839
hazard all can be used for fuzzy the

802
00:34:46,839 --> 00:34:49,440
specific modification is actually very

803
00:34:49,440 --> 00:34:52,960
simple that is a change osdp with the

804
00:34:52,960 --> 00:34:56,079
packet to pick up loop or pickup next

805
00:34:56,079 --> 00:34:59,119
and change all steps and package to pcap

806
00:34:59,119 --> 00:35:02,160
send package

807
00:35:02,160 --> 00:35:04,480
when capturing data package in the er

808
00:35:04,480 --> 00:35:07,359
for analysis during frozen i found that

809
00:35:07,359 --> 00:35:09,920
many packs have been retransmitted

810
00:35:09,920 --> 00:35:13,280
resulting a slower fighting speed

811
00:35:13,280 --> 00:35:16,000
after researching i found that wi-fi

812
00:35:16,000 --> 00:35:18,960
user acq mechanism if the ack frame is

813
00:35:18,960 --> 00:35:21,599
not received the sender will retransmit

814
00:35:21,599 --> 00:35:22,880
the frame

815
00:35:22,880 --> 00:35:25,040
which will affect the frozen speed and

816
00:35:25,040 --> 00:35:27,520
the effect and showing the figure

817
00:35:27,520 --> 00:35:30,240
five v87 will adjust first center probe

818
00:35:30,240 --> 00:35:33,440
request to 360.

819
00:35:33,440 --> 00:35:35,920
cs6 easily replaces the probe response

820
00:35:35,920 --> 00:35:39,920
frame to the favorite 87 but since 360

821
00:35:39,920 --> 00:35:42,480
does not receive the ack frame from the

822
00:35:42,480 --> 00:35:45,920
femi 87 it will constantly retransmit

823
00:35:45,920 --> 00:35:48,000
the probe response frame

824
00:35:48,000 --> 00:35:50,720
then the question is why my network card

825
00:35:50,720 --> 00:35:53,119
does not send ack frame to the target

826
00:35:53,119 --> 00:35:56,320
device and how to send the ack frame to

827
00:35:56,320 --> 00:35:59,359
the target device after some research i

828
00:35:59,359 --> 00:36:01,200
found that there are two ways to slow

829
00:36:01,200 --> 00:36:04,079
these programs of packet transmission

830
00:36:04,079 --> 00:36:06,800
the first method is that we can use the

831
00:36:06,800 --> 00:36:09,599
mac address or the network card itself

832
00:36:09,599 --> 00:36:11,839
as a macro address of the file when

833
00:36:11,839 --> 00:36:13,280
starting fuzzy

834
00:36:13,280 --> 00:36:15,599
so that when the hardware or network car

835
00:36:15,599 --> 00:36:18,000
receives a wi-fi from whose receiving

836
00:36:18,000 --> 00:36:19,119
address

837
00:36:19,119 --> 00:36:22,560
is easily macro address it will actively

838
00:36:22,560 --> 00:36:25,760
send ack frame to the target device this

839
00:36:25,760 --> 00:36:28,000
process is all in the network hardware

840
00:36:28,000 --> 00:36:29,520
hardware and

841
00:36:29,520 --> 00:36:32,000
has nothing to do with the driver

842
00:36:32,000 --> 00:36:34,800
the second method is to use a network

843
00:36:34,800 --> 00:36:37,200
card that supports active monitor mode

844
00:36:37,200 --> 00:36:38,440
such as

845
00:36:38,440 --> 00:36:41,440
mt-7612 and then we can use monitor mode

846
00:36:41,440 --> 00:36:46,320
to send ack frames directly in user mode

847
00:36:47,920 --> 00:36:50,880
this table is a list of wi-fi network

848
00:36:50,880 --> 00:36:54,240
card as i have tested the third column

849
00:36:54,240 --> 00:36:56,560
indicates the price of the network card

850
00:36:56,560 --> 00:36:57,839
in imb

851
00:36:57,839 --> 00:37:00,640
among them are two network cards let me

852
00:37:00,640 --> 00:37:03,720
introduce them in particular

853
00:37:03,720 --> 00:37:06,640
rto8812ao is the most suitable network

854
00:37:06,640 --> 00:37:09,280
card for fuzzy it supports a send and

855
00:37:09,280 --> 00:37:11,680
receive package in the monitor mode of

856
00:37:11,680 --> 00:37:15,960
2.4g and 5g frequency bands

857
00:37:15,960 --> 00:37:18,560
mt-7612u is the only network colors

858
00:37:18,560 --> 00:37:22,079
founded to support active monitor mode

859
00:37:22,079 --> 00:37:24,560
but this program is set up when the

860
00:37:24,560 --> 00:37:27,040
motor model is turned on it cannot send

861
00:37:27,040 --> 00:37:31,040
package in the 5g frequency band

862
00:37:31,040 --> 00:37:34,960
therefore i recommend use rtl801 oau for

863
00:37:34,960 --> 00:37:37,440
farming

864
00:37:39,280 --> 00:37:42,160
next let's introduce the optimization of

865
00:37:42,160 --> 00:37:45,280
wi-fi hunter's mutations strategy for

866
00:37:45,280 --> 00:37:47,119
information element we know that each

867
00:37:47,119 --> 00:37:49,359
eye in the wi-fi frame is stored

868
00:37:49,359 --> 00:37:51,920
sequentially this layout makes a little

869
00:37:51,920 --> 00:37:54,079
more troublesome for us to make a

870
00:37:54,079 --> 00:37:56,400
rotation especially if we want to modify

871
00:37:56,400 --> 00:37:59,040
the lens of ie and change the position

872
00:37:59,040 --> 00:38:00,720
between the ie

873
00:38:00,720 --> 00:38:03,440
so the plan i take is as follows

874
00:38:03,440 --> 00:38:06,720
first i pass oi in the wifi frame and

875
00:38:06,720 --> 00:38:09,280
use a link list to organize the oi in

876
00:38:09,280 --> 00:38:12,480
the frame then we mutate the i it muted

877
00:38:12,480 --> 00:38:15,599
the ie nodes in the linked list such as

878
00:38:15,599 --> 00:38:18,800
battery i learned changes and so on

879
00:38:18,800 --> 00:38:21,680
after the mutation is complete we will

880
00:38:21,680 --> 00:38:24,560
serialize the linked list and put it in

881
00:38:24,560 --> 00:38:27,119
the wi-fi frame during the serialization

882
00:38:27,119 --> 00:38:29,280
we can also modify the order between

883
00:38:29,280 --> 00:38:32,520
each ie

884
00:38:33,760 --> 00:38:36,400
the previous page introduces a general

885
00:38:36,400 --> 00:38:38,560
ie mutations challenger

886
00:38:38,560 --> 00:38:41,359
for some special ie and data in order to

887
00:38:41,359 --> 00:38:43,599
improve the fuzzing efficiency it is

888
00:38:43,599 --> 00:38:45,119
necessary to make customization

889
00:38:45,119 --> 00:38:49,359
mutations such as iso ie popi and e-po

890
00:38:49,359 --> 00:38:51,839
data structure and showing the left

891
00:38:51,839 --> 00:38:54,560
figure some variable length structure

892
00:38:54,560 --> 00:38:58,320
are nested in iso ie such as a paralyzer

893
00:38:58,320 --> 00:39:00,560
cheaper suit authentication key

894
00:39:00,560 --> 00:39:02,880
management and so on and showing the

895
00:39:02,880 --> 00:39:04,720
figure on the right there are also some

896
00:39:04,720 --> 00:39:06,640
variable length structure in the ipod

897
00:39:06,640 --> 00:39:09,279
frame data

898
00:39:11,200 --> 00:39:13,520
let's briefly introduce how i found

899
00:39:13,520 --> 00:39:15,920
wi-fi pdp protocol first

900
00:39:15,920 --> 00:39:18,560
i need to implement the wi-fi protocol

901
00:39:18,560 --> 00:39:21,440
interaction and then make a customizable

902
00:39:21,440 --> 00:39:23,920
rotation to the data in the pdp frame

903
00:39:23,920 --> 00:39:26,720
mainly the attribute in the ppie the

904
00:39:26,720 --> 00:39:29,200
mutation of attribute is similar to the

905
00:39:29,200 --> 00:39:31,280
previous mutations challenger for

906
00:39:31,280 --> 00:39:33,520
information elements so i want to repeat

907
00:39:33,520 --> 00:39:35,920
it here

908
00:39:36,880 --> 00:39:39,119
next i will introduce the optimization

909
00:39:39,119 --> 00:39:41,760
of wi-fi hunter in crash detection and

910
00:39:41,760 --> 00:39:44,560
plc recording and reproduction after

911
00:39:44,560 --> 00:39:47,280
analysis oda refunds currently only

912
00:39:47,280 --> 00:39:49,440
support pins attack at the machine to

913
00:39:49,440 --> 00:39:51,760
determine whether the target device is

914
00:39:51,760 --> 00:39:54,720
allowed and once the crash is found the

915
00:39:54,720 --> 00:39:56,880
father will only save the last package

916
00:39:56,880 --> 00:39:59,119
send it by it and the answer further

917
00:39:59,119 --> 00:40:00,320
will exit

918
00:40:00,320 --> 00:40:02,400
the implementation of wifi hunter is as

919
00:40:02,400 --> 00:40:03,520
follows

920
00:40:03,520 --> 00:40:06,160
in terms of crash detection wi-fi hunter

921
00:40:06,160 --> 00:40:08,800
adds a new mechanism to tell whether the

922
00:40:08,800 --> 00:40:11,520
device is crashed by monitor the wi-fi

923
00:40:11,520 --> 00:40:14,400
frames for targeted device and when the

924
00:40:14,400 --> 00:40:16,000
device crashes

925
00:40:16,000 --> 00:40:18,560
wifi hunter will save the test case and

926
00:40:18,560 --> 00:40:20,800
then wait for target device to restart

927
00:40:20,800 --> 00:40:23,760
for continuous fusing

928
00:40:23,760 --> 00:40:26,800
in terms of poc recording and the replay

929
00:40:26,800 --> 00:40:29,200
wi-fi hunter will start a new slide to

930
00:40:29,200 --> 00:40:31,280
record the wi-fi from interaction

931
00:40:31,280 --> 00:40:33,760
between the browser and the device under

932
00:40:33,760 --> 00:40:34,640
test

933
00:40:34,640 --> 00:40:36,880
when we pronounce the proceed wifi

934
00:40:36,880 --> 00:40:39,440
hunter will replace the recorded frames

935
00:40:39,440 --> 00:40:42,079
in the interactive order to ensure that

936
00:40:42,079 --> 00:40:44,880
the abilities can be reproduced

937
00:40:44,880 --> 00:40:47,280
the following figure is a test case of a

938
00:40:47,280 --> 00:40:50,160
poc you can see that the protocol

939
00:40:50,160 --> 00:40:52,240
interaction between files and the device

940
00:40:52,240 --> 00:40:53,599
on the test is

941
00:40:53,599 --> 00:40:57,119
recorded in the poc

942
00:41:00,000 --> 00:41:02,000
this is a demo video of

943
00:41:02,000 --> 00:41:04,240
windows wifi driver it can be seen that

944
00:41:04,240 --> 00:41:06,880
a wifi hunter will not exit after

945
00:41:06,880 --> 00:41:09,440
detected the target crash

946
00:41:09,440 --> 00:41:12,160
but wait for the target device to start

947
00:41:12,160 --> 00:41:13,680
again and then

948
00:41:13,680 --> 00:41:17,399
continue to frozen

949
00:41:31,040 --> 00:41:34,040
b

950
00:41:49,359 --> 00:41:52,359
foreign

951
00:42:12,160 --> 00:42:15,160
c

952
00:42:27,280 --> 00:42:30,280
c

953
00:42:42,079 --> 00:42:47,240
this is a demo video of poc reproduction

954
00:43:00,160 --> 00:43:02,640
after the development of wifi hunter i

955
00:43:02,640 --> 00:43:06,119
used the linux and windows driver of

956
00:43:06,119 --> 00:43:09,119
rtl8812au for fuzzing and finally found

957
00:43:09,119 --> 00:43:12,079
the following vulnerabilities it found

958
00:43:12,079 --> 00:43:14,160
three blocks in the linux driver that i

959
00:43:14,160 --> 00:43:16,400
didn't found by auditor driver source

960
00:43:16,400 --> 00:43:17,280
code

961
00:43:17,280 --> 00:43:19,520
and it found four box in the windows

962
00:43:19,520 --> 00:43:20,960
driver

963
00:43:20,960 --> 00:43:23,359
the tested one of the driver version is

964
00:43:23,359 --> 00:43:24,720
as follows

965
00:43:24,720 --> 00:43:28,240
this is a little driver provided by the

966
00:43:28,240 --> 00:43:30,880
network seller

967
00:43:30,880 --> 00:43:33,119
and showing the figure it is a plug in

968
00:43:33,119 --> 00:43:34,560
the next driver

969
00:43:34,560 --> 00:43:37,920
the product is that in line 7 under 13

970
00:43:37,920 --> 00:43:40,160
will unlock a slipping lock twice

971
00:43:40,160 --> 00:43:43,200
resulting in an infinite loop of the

972
00:43:43,200 --> 00:43:45,520
kernel

973
00:43:45,520 --> 00:43:48,319
there is another bug discovered by the

974
00:43:48,319 --> 00:43:51,599
drawfisher tr is from wifi frame so it

975
00:43:51,599 --> 00:43:55,280
is controlled by user inline 6 is a core

976
00:43:55,280 --> 00:43:58,400
camera log to lock memory

977
00:43:58,400 --> 00:44:01,040
it's a parameter is the lens when the

978
00:44:01,040 --> 00:44:04,160
lens is 0 cameras return 0 ptr instead

979
00:44:04,160 --> 00:44:07,040
of 0 so it will pass the check on the

980
00:44:07,040 --> 00:44:09,280
line 7 and then when the memory is

981
00:44:09,280 --> 00:44:12,240
accessed in mem copy it will read data

982
00:44:12,240 --> 00:44:14,440
from address

983
00:44:14,440 --> 00:44:19,599
0x10 it will cause the kernel to panic

984
00:44:20,480 --> 00:44:22,880
next i will briefly introduce the local

985
00:44:22,880 --> 00:44:26,800
attack surface of a linux wi-fi driver

986
00:44:26,800 --> 00:44:28,960
in linux users usually configure the

987
00:44:28,960 --> 00:44:31,920
network cards through the iw config oiw

988
00:44:31,920 --> 00:44:33,599
command

989
00:44:33,599 --> 00:44:35,680
such as setting the mac address or the

990
00:44:35,680 --> 00:44:38,400
network card allowing the network to

991
00:44:38,400 --> 00:44:42,000
scan the wi-fi hotspot and so on

992
00:44:42,000 --> 00:44:44,319
this operation are actually communicated

993
00:44:44,319 --> 00:44:47,040
with the wi-fi driver of the kernel

994
00:44:47,040 --> 00:44:49,680
store system cross and the the kernel

995
00:44:49,680 --> 00:44:51,839
driver will control the hardware to

996
00:44:51,839 --> 00:44:54,640
complete some specific configuration in

997
00:44:54,640 --> 00:44:57,520
the current linux kernel the user mode

998
00:44:57,520 --> 00:45:00,079
and the wi-fi driver can communicate

999
00:45:00,079 --> 00:45:03,760
slow wxt or cfg8021

1000
00:45:03,760 --> 00:45:07,520
wxt actually uses ndo2l control callback

1001
00:45:07,520 --> 00:45:09,160
functions and

1002
00:45:09,160 --> 00:45:12,560
clg802l1 is implemented based on the

1003
00:45:12,560 --> 00:45:14,560
netlink mechanism

1004
00:45:14,560 --> 00:45:17,119
regardless of the mode when the driver

1005
00:45:17,119 --> 00:45:19,839
is processed data from user mode it may

1006
00:45:19,839 --> 00:45:22,240
cause vulnerabilities if the data is not

1007
00:45:22,240 --> 00:45:25,439
carefully verified

1008
00:45:26,319 --> 00:45:28,079
serial tag driver provides two

1009
00:45:28,079 --> 00:45:30,240
implementation of the interface i guess

1010
00:45:30,240 --> 00:45:32,640
it is to support different version of

1011
00:45:32,640 --> 00:45:34,680
linux kernel on the left is the

1012
00:45:34,680 --> 00:45:38,319
registration structure of wxt here we

1013
00:45:38,319 --> 00:45:40,160
only need to pay attention to the

1014
00:45:40,160 --> 00:45:43,359
callback function of ndo2l control

1015
00:45:43,359 --> 00:45:45,760
so callback function registered here

1016
00:45:45,760 --> 00:45:48,319
will be coded when the user space

1017
00:45:48,319 --> 00:45:50,480
process performs our control on the

1018
00:45:50,480 --> 00:45:53,200
network card on the right is a callback

1019
00:45:53,200 --> 00:45:55,079
function of

1020
00:45:55,079 --> 00:45:57,839
cfg8021 when the user space process

1021
00:45:57,839 --> 00:46:00,160
sends a specific type of data link

1022
00:46:00,160 --> 00:46:02,240
message to the network card the

1023
00:46:02,240 --> 00:46:04,240
corresponding copy function will be

1024
00:46:04,240 --> 00:46:05,920
called

1025
00:46:05,920 --> 00:46:07,839
by searching this two structure in the

1026
00:46:07,839 --> 00:46:09,599
source code we can find the entry

1027
00:46:09,599 --> 00:46:12,480
function for process user mode data and

1028
00:46:12,480 --> 00:46:14,480
then according to the kernel calling

1029
00:46:14,480 --> 00:46:15,599
conversion

1030
00:46:15,599 --> 00:46:17,680
we can select vulnerability

1031
00:46:17,680 --> 00:46:21,680
next i will introduce two simple parts

1032
00:46:22,560 --> 00:46:24,960
this is a hip overflow variability when

1033
00:46:24,960 --> 00:46:27,920
wx interface process user model request

1034
00:46:27,920 --> 00:46:30,400
first the line for observer code memory

1035
00:46:30,400 --> 00:46:32,079
will be located according to the

1036
00:46:32,079 --> 00:46:33,920
appearance

1037
00:46:33,920 --> 00:46:36,640
the date of p is controlled by user mode

1038
00:46:36,640 --> 00:46:38,560
so the user model can control the length

1039
00:46:38,560 --> 00:46:41,680
of a and then on the next line it will

1040
00:46:41,680 --> 00:46:44,240
copy data to a copy set is the set of

1041
00:46:44,240 --> 00:46:45,680
global data

1042
00:46:45,680 --> 00:46:48,960
when the copy says plus 0x30 is greater

1043
00:46:48,960 --> 00:46:50,960
than the length of a it will cause hip

1044
00:46:50,960 --> 00:46:53,280
overflow

1045
00:46:53,280 --> 00:46:54,960
there is a hip overflow variability in

1046
00:46:54,960 --> 00:46:56,520
real-time

1047
00:46:56,520 --> 00:46:59,920
cfgs802l1 interface when process user

1048
00:46:59,920 --> 00:47:01,599
mode request

1049
00:47:01,599 --> 00:47:04,160
the cross-oxidability is similar to the

1050
00:47:04,160 --> 00:47:06,960
previous one first it used a lens to

1051
00:47:06,960 --> 00:47:08,880
lock his memory in 9

1052
00:47:08,880 --> 00:47:11,520
8 and then use billions when copying the

1053
00:47:11,520 --> 00:47:13,760
memory below

1054
00:47:13,760 --> 00:47:16,160
your balance is greater than aliens it

1055
00:47:16,160 --> 00:47:19,440
will cause capable flow

1056
00:47:20,480 --> 00:47:23,200
next i will summarize this research

1057
00:47:23,200 --> 00:47:25,359
thirteen research i have learned that

1058
00:47:25,359 --> 00:47:28,000
first verbatim plan to occur in kelvin

1059
00:47:28,000 --> 00:47:30,400
data processing and the aggregation of

1060
00:47:30,400 --> 00:47:33,200
fragmented frames

1061
00:47:33,200 --> 00:47:35,200
second the patch management mechanism

1062
00:47:35,200 --> 00:47:37,760
needed to be improved to ensure that the

1063
00:47:37,760 --> 00:47:40,079
variabilities are rarely fixed in the

1064
00:47:40,079 --> 00:47:42,400
actual released version

1065
00:47:42,400 --> 00:47:46,240
so frozen can found some acceptor bars

1066
00:47:46,240 --> 00:47:48,480
first the wi-fi driver should try to use

1067
00:47:48,480 --> 00:47:51,839
mac 80211 to handle the wifi protocol

1068
00:47:51,839 --> 00:47:56,078
instead of implementing its cell

1069
00:47:56,240 --> 00:47:58,960
the good news is that the new generation

1070
00:47:58,960 --> 00:48:01,520
of real-time software network card began

1071
00:48:01,520 --> 00:48:04,960
to use the mac 8021 to handle the wifi

1072
00:48:04,960 --> 00:48:07,839
protocol

1073
00:48:08,960 --> 00:48:11,680
this is just the idea when i was analyze

1074
00:48:11,680 --> 00:48:14,480
the wifi protocol and it has not been

1075
00:48:14,480 --> 00:48:16,720
verified

1076
00:48:16,720 --> 00:48:18,960
we know that there is a lens field in

1077
00:48:18,960 --> 00:48:21,119
the physical layer

1078
00:48:21,119 --> 00:48:23,440
protocol or wi-fi that indicates the

1079
00:48:23,440 --> 00:48:26,640
sense of the data behind the plcp header

1080
00:48:26,640 --> 00:48:28,800
will there be some network cards that

1081
00:48:28,800 --> 00:48:31,599
are handled incorrectly leading to

1082
00:48:31,599 --> 00:48:35,400
unacceptable behavior

1083
00:48:37,040 --> 00:48:39,040
and i would like to thank realtek's

1084
00:48:39,040 --> 00:48:42,079
security team for efficiently and

1085
00:48:42,079 --> 00:48:45,119
preventably handle this security issue

1086
00:48:45,119 --> 00:48:47,839
and for their professional conductor of

1087
00:48:47,839 --> 00:48:50,480
communication

1088
00:48:51,040 --> 00:48:52,800
thank you everyone so above with all my

1089
00:48:52,800 --> 00:48:55,800
speech

