1
00:00:07,520 --> 00:00:10,559
the remote attack surface in telegram

2
00:00:10,559 --> 00:00:13,120
and specifically the animated stickers

3
00:00:13,120 --> 00:00:16,119
feature

4
00:00:16,640 --> 00:00:19,119
this is going to be our agenda so first

5
00:00:19,119 --> 00:00:21,439
as always a little introduction about

6
00:00:21,439 --> 00:00:23,600
who i am and what is the

7
00:00:23,600 --> 00:00:26,160
lotte animation format then we'll have a

8
00:00:26,160 --> 00:00:27,119
look

9
00:00:27,119 --> 00:00:29,599
at the r lotte project developed by

10
00:00:29,599 --> 00:00:33,120
samsung and its integration in telegram

11
00:00:33,120 --> 00:00:34,960
after that we are going to have a look

12
00:00:34,960 --> 00:00:37,360
at the fighting efforts and my

13
00:00:37,360 --> 00:00:41,600
methodology i have used in my research

14
00:00:41,600 --> 00:00:43,200
then we'll

15
00:00:43,200 --> 00:00:46,079
analyze my findings the issues i have

16
00:00:46,079 --> 00:00:50,719
identified have a live demo of the issue

17
00:00:50,719 --> 00:00:52,160
and

18
00:00:52,160 --> 00:00:55,199
consider some exploit limitations of my

19
00:00:55,199 --> 00:00:56,399
specific

20
00:00:56,399 --> 00:00:58,399
attack vector

21
00:00:58,399 --> 00:01:00,160
in the end we will have some closing

22
00:01:00,160 --> 00:01:03,440
remarks and a little time for question

23
00:01:03,440 --> 00:01:05,920
dancer

24
00:01:07,040 --> 00:01:09,600
so let's jump jump right into the

25
00:01:09,600 --> 00:01:11,680
introduction

26
00:01:11,680 --> 00:01:13,280
so i'm pollock

27
00:01:13,280 --> 00:01:15,360
i'm availability research and exploit

28
00:01:15,360 --> 00:01:16,560
developer

29
00:01:16,560 --> 00:01:18,880
currently i am the research team

30
00:01:18,880 --> 00:01:21,680
director at shielder a cyber security

31
00:01:21,680 --> 00:01:23,520
company in italy

32
00:01:23,520 --> 00:01:25,200
my free time i enjoy backpacking around

33
00:01:25,200 --> 00:01:27,840
the world and you can find me on twitter

34
00:01:27,840 --> 00:01:30,960
at pawlik underscore so if you have any

35
00:01:30,960 --> 00:01:33,280
question after my talk we can either

36
00:01:33,280 --> 00:01:34,400
discuss

37
00:01:34,400 --> 00:01:36,880
face to face or you can just dm me since

38
00:01:36,880 --> 00:01:37,840
my

39
00:01:37,840 --> 00:01:40,400
dms are open

40
00:01:40,400 --> 00:01:43,200
so what is the load animation format

41
00:01:43,200 --> 00:01:46,560
basically it was created by airbnb

42
00:01:46,560 --> 00:01:48,720
by their design team

43
00:01:48,720 --> 00:01:50,399
and the core

44
00:01:50,399 --> 00:01:53,600
pro of using lotte instead of pngs or

45
00:01:53,600 --> 00:01:55,920
gifs is that they are

46
00:01:55,920 --> 00:01:59,119
really smaller than the others and

47
00:01:59,119 --> 00:02:01,119
after that they can also be

48
00:02:01,119 --> 00:02:04,640
manipulated at runtime so it's a really

49
00:02:04,640 --> 00:02:08,720
uh nice pro over the counterparts

50
00:02:08,720 --> 00:02:10,959
as you can see in this example

51
00:02:10,959 --> 00:02:14,000
uh the lottie animation was

52
00:02:14,000 --> 00:02:16,160
almost uh

53
00:02:16,160 --> 00:02:18,239
five times smaller than for example

54
00:02:18,239 --> 00:02:22,720
gives or even animated pngs

55
00:02:22,720 --> 00:02:25,280
load the animations are defined as a

56
00:02:25,280 --> 00:02:28,720
json file so instead of having like a

57
00:02:28,720 --> 00:02:30,160
binary blob

58
00:02:30,160 --> 00:02:33,360
there is a simple json file which will

59
00:02:33,360 --> 00:02:34,480
be

60
00:02:34,480 --> 00:02:36,800
which will come handy afterwards when we

61
00:02:36,800 --> 00:02:40,400
will see structural fuzzing

62
00:02:42,640 --> 00:02:45,920
so who is using what animations

63
00:02:45,920 --> 00:02:47,200
on the

64
00:02:47,200 --> 00:02:49,840
right part of the screen you can see

65
00:02:49,840 --> 00:02:52,160
an example of a lot animation you might

66
00:02:52,160 --> 00:02:53,599
have seen this

67
00:02:53,599 --> 00:02:56,000
in telegram itself and since it's part

68
00:02:56,000 --> 00:02:56,959
of the

69
00:02:56,959 --> 00:02:59,920
animated stickers sticker pack

70
00:02:59,920 --> 00:03:02,959
developed by telegram while on the left

71
00:03:02,959 --> 00:03:05,519
part you can see some of the

72
00:03:05,519 --> 00:03:08,400
vendors or products that actually use a

73
00:03:08,400 --> 00:03:10,239
lot animations

74
00:03:10,239 --> 00:03:13,920
so here most probably the

75
00:03:14,000 --> 00:03:16,480
most interesting one is signal

76
00:03:16,480 --> 00:03:18,400
but uh

77
00:03:18,400 --> 00:03:21,200
we need to consider here that uh most of

78
00:03:21,200 --> 00:03:23,519
the other vendors besides telegram

79
00:03:23,519 --> 00:03:24,480
actually

80
00:03:24,480 --> 00:03:26,480
parse and render a lot animation from

81
00:03:26,480 --> 00:03:29,040
the coming from the file system and not

82
00:03:29,040 --> 00:03:29,920
from

83
00:03:29,920 --> 00:03:32,959
third parties you can see also

84
00:03:32,959 --> 00:03:35,040
other examples

85
00:03:35,040 --> 00:03:36,080
like

86
00:03:36,080 --> 00:03:38,560
the galaxy watch because as you will see

87
00:03:38,560 --> 00:03:41,599
samsung developed the

88
00:03:41,599 --> 00:03:43,519
c plus plus library in order to parse

89
00:03:43,519 --> 00:03:46,080
and render a lot animations called

90
00:03:46,080 --> 00:03:48,720
arlotti

91
00:03:48,959 --> 00:03:52,000
while we'll have a look a specific look

92
00:03:52,000 --> 00:03:54,319
at the c plus plus version most of the

93
00:03:54,319 --> 00:03:57,120
other vendors actually use the java or

94
00:03:57,120 --> 00:04:00,480
zwift library developed by rb airbnb

95
00:04:00,480 --> 00:04:01,680
themselves

96
00:04:01,680 --> 00:04:05,519
i will focus on the samsung one since

97
00:04:05,519 --> 00:04:07,680
it is the one used in telegram

98
00:04:07,680 --> 00:04:09,439
but of course

99
00:04:09,439 --> 00:04:12,159
another potential work for the future is

100
00:04:12,159 --> 00:04:14,560
will be checking if those

101
00:04:14,560 --> 00:04:15,439
other

102
00:04:15,439 --> 00:04:17,680
libraries had similar

103
00:04:17,680 --> 00:04:20,079
issues

104
00:04:20,238 --> 00:04:21,600
so let's

105
00:04:21,600 --> 00:04:22,800
have a look

106
00:04:22,800 --> 00:04:25,199
at the barebone example of

107
00:04:25,199 --> 00:04:27,840
lotte animation as you can see as i

108
00:04:27,840 --> 00:04:29,520
mentioned earlier

109
00:04:29,520 --> 00:04:32,080
they are defined as a json so

110
00:04:32,080 --> 00:04:35,440
uh there is the outermost layer which

111
00:04:35,440 --> 00:04:37,280
will include

112
00:04:37,280 --> 00:04:38,560
these five

113
00:04:38,560 --> 00:04:40,000
main keys

114
00:04:40,000 --> 00:04:41,600
which as you can see in the comments are

115
00:04:41,600 --> 00:04:43,919
the version identifier the frame rate

116
00:04:43,919 --> 00:04:46,000
the in point the out point

117
00:04:46,000 --> 00:04:48,400
and actually the most interesting

118
00:04:48,400 --> 00:04:50,560
interesting one from the point of view

119
00:04:50,560 --> 00:04:54,880
of the animation which is the layers one

120
00:04:55,600 --> 00:04:58,960
so let's move to the samsung galaxy

121
00:04:58,960 --> 00:05:00,240
project because

122
00:05:00,240 --> 00:05:02,160
this is the lottie

123
00:05:02,160 --> 00:05:04,160
library which is actually used in all of

124
00:05:04,160 --> 00:05:08,000
the official clients of telegram

125
00:05:08,880 --> 00:05:11,680
as i mentioned earlier our lot is a c

126
00:05:11,680 --> 00:05:14,000
plus plus library developed by samsung

127
00:05:14,000 --> 00:05:16,240
for parsing and rendering a lot

128
00:05:16,240 --> 00:05:17,440
animations

129
00:05:17,440 --> 00:05:19,440
it is open source and its code is

130
00:05:19,440 --> 00:05:22,000
available on github.com so you can

131
00:05:22,000 --> 00:05:26,400
easily serve or instrument it

132
00:05:26,400 --> 00:05:28,720
and the main advantage from what i

133
00:05:28,720 --> 00:05:31,360
understood doing this research

134
00:05:31,360 --> 00:05:34,080
against the java or zwift counterparts

135
00:05:34,080 --> 00:05:34,880
is

136
00:05:34,880 --> 00:05:37,520
performance because since it's in c plus

137
00:05:37,520 --> 00:05:39,280
plus

138
00:05:39,280 --> 00:05:41,919
the animations are parsed and rendered

139
00:05:41,919 --> 00:05:45,120
in way less time

140
00:05:45,120 --> 00:05:47,360
an important thing to consider about air

141
00:05:47,360 --> 00:05:48,400
lot is

142
00:05:48,400 --> 00:05:50,800
its threat model since

143
00:05:50,800 --> 00:05:52,400
they don't currently

144
00:05:52,400 --> 00:05:56,000
track issues uh stemming from parsing

145
00:05:56,000 --> 00:05:58,720
rendering the rendering

146
00:05:58,720 --> 00:06:01,600
untrusted images as in third party

147
00:06:01,600 --> 00:06:04,000
images or animations

148
00:06:04,000 --> 00:06:07,360
this of course is a legit decision but

149
00:06:07,360 --> 00:06:09,759
in this specific telegram case

150
00:06:09,759 --> 00:06:11,600
since they have a different thread model

151
00:06:11,600 --> 00:06:13,840
since

152
00:06:14,400 --> 00:06:16,319
animated stickers are basically lot

153
00:06:16,319 --> 00:06:18,319
animations so

154
00:06:18,319 --> 00:06:22,560
you can send a custom load animation to

155
00:06:22,560 --> 00:06:26,319
uh uh an another user so it's not really

156
00:06:26,319 --> 00:06:29,520
the same thread model since you can

157
00:06:29,520 --> 00:06:31,280
pretty much uh

158
00:06:31,280 --> 00:06:33,199
create an animation from sketch and send

159
00:06:33,199 --> 00:06:35,120
it to the other client and the other

160
00:06:35,120 --> 00:06:37,360
client will try to parse it and render

161
00:06:37,360 --> 00:06:38,560
it so

162
00:06:38,560 --> 00:06:40,720
it creates a problem from telegram since

163
00:06:40,720 --> 00:06:42,400
they will

164
00:06:42,400 --> 00:06:44,720
need to track and fix each and every

165
00:06:44,720 --> 00:06:47,360
issue they find since the threat model

166
00:06:47,360 --> 00:06:48,479
is different

167
00:06:48,479 --> 00:06:51,360
so let's have a quick look

168
00:06:51,360 --> 00:06:53,759
about how we can

169
00:06:53,759 --> 00:06:56,720
basically use our lotte since uh as i

170
00:06:56,720 --> 00:06:59,039
mentioned earlier it's open source so

171
00:06:59,039 --> 00:07:02,479
you can directly use it and analyze it

172
00:07:02,479 --> 00:07:06,240
basically it is divided in two main apis

173
00:07:06,240 --> 00:07:07,199
which

174
00:07:07,199 --> 00:07:09,440
are

175
00:07:09,440 --> 00:07:13,120
named like in a human way and are pretty

176
00:07:13,120 --> 00:07:16,560
easy to use so the first is a load from

177
00:07:16,560 --> 00:07:19,120
file which will

178
00:07:19,120 --> 00:07:22,160
load in memory and pass an animation

179
00:07:22,160 --> 00:07:24,160
coming from the file system and there is

180
00:07:24,160 --> 00:07:26,479
also a lot from data which is basically

181
00:07:26,479 --> 00:07:29,440
the same one but it actually

182
00:07:29,440 --> 00:07:33,360
imports it from a string object

183
00:07:33,360 --> 00:07:34,720
while

184
00:07:34,720 --> 00:07:37,280
when we move to the render part

185
00:07:37,280 --> 00:07:40,160
there is a pretty much one single api

186
00:07:40,160 --> 00:07:42,840
which is the render sync

187
00:07:42,840 --> 00:07:46,080
method which will render the animation

188
00:07:46,080 --> 00:07:48,479
uh basically on a bitmap

189
00:07:48,479 --> 00:07:52,319
uh for example on the uh android case

190
00:07:52,319 --> 00:07:55,280
that we will see uh later

191
00:07:55,280 --> 00:07:56,879
as you can see in the render sync method

192
00:07:56,879 --> 00:07:59,919
there is the frame number argument which

193
00:07:59,919 --> 00:08:01,759
defines the specific

194
00:08:01,759 --> 00:08:06,960
frame we want to render on the bitmap

195
00:08:07,759 --> 00:08:10,000
so as we have seen

196
00:08:10,000 --> 00:08:12,960
it's really easy to use it and there are

197
00:08:12,960 --> 00:08:16,000
no not much calls we need to do so

198
00:08:16,000 --> 00:08:18,639
our harness which is the piece of code

199
00:08:18,639 --> 00:08:20,960
which we need in order to interface the

200
00:08:20,960 --> 00:08:24,639
fuzzer to the target api is pretty much

201
00:08:24,639 --> 00:08:30,240
uh ready so we can just uh fuzz it

202
00:08:31,280 --> 00:08:33,679
before we move to the fuzzing part let's

203
00:08:33,679 --> 00:08:37,279
have a look at the actual r lot

204
00:08:37,279 --> 00:08:40,479
integration in the telegram code

205
00:08:40,479 --> 00:08:42,799
you can see here a little overview of

206
00:08:42,799 --> 00:08:44,800
the process

207
00:08:44,800 --> 00:08:47,200
so once an animated sticker is sent it

208
00:08:47,200 --> 00:08:49,519
is saved in telegrams cloud and its

209
00:08:49,519 --> 00:08:51,760
coordinates sent to this recipient

210
00:08:51,760 --> 00:08:53,839
this is because since you are sending a

211
00:08:53,839 --> 00:08:56,240
custom animated seeker telegram doesn't

212
00:08:56,240 --> 00:08:58,560
have it yet on the in their cloud so

213
00:08:58,560 --> 00:09:00,560
they have to save it

214
00:09:00,560 --> 00:09:03,120
and send the coordinates to the

215
00:09:03,120 --> 00:09:05,519
recipient in case you send an animated

216
00:09:05,519 --> 00:09:08,959
sticker coming from a sticker pack

217
00:09:08,959 --> 00:09:11,760
uh it is already on the telegram cloud

218
00:09:11,760 --> 00:09:14,560
so uh only the coordinates the cloud

219
00:09:14,560 --> 00:09:17,120
coordinates will be sent to the

220
00:09:17,120 --> 00:09:20,959
uh recipients of the recipient client

221
00:09:20,959 --> 00:09:22,880
once the recipient opens the chat which

222
00:09:22,880 --> 00:09:25,839
is the case for the android app it is

223
00:09:25,839 --> 00:09:28,959
parsed and rendered as you can see uh

224
00:09:28,959 --> 00:09:31,279
there is a hatch here since

225
00:09:31,279 --> 00:09:34,640
uh some clients might actually parse and

226
00:09:34,640 --> 00:09:37,279
render the animation before you actually

227
00:09:37,279 --> 00:09:38,800
open the chat so

228
00:09:38,800 --> 00:09:39,920
this

229
00:09:39,920 --> 00:09:42,560
makes the attack directory either zero

230
00:09:42,560 --> 00:09:45,120
or one click since uh you might need the

231
00:09:45,120 --> 00:09:48,080
user interaction of opening the chat

232
00:09:48,080 --> 00:09:51,680
but this as i said actually

233
00:09:51,680 --> 00:09:55,040
depends on the victim's client

234
00:09:55,040 --> 00:09:56,000
last

235
00:09:56,000 --> 00:09:59,200
as i mentioned earlier the arlotti

236
00:09:59,200 --> 00:10:01,519
library in all of the official clients

237
00:10:01,519 --> 00:10:04,560
of telegram is used in order to parse

238
00:10:04,560 --> 00:10:06,720
and render the animator stickers in the

239
00:10:06,720 --> 00:10:09,200
chat view

240
00:10:10,959 --> 00:10:13,600
since the telegram apis

241
00:10:13,600 --> 00:10:14,800
are

242
00:10:14,800 --> 00:10:15,920
really

243
00:10:15,920 --> 00:10:18,000
simple and easy to use you don't even

244
00:10:18,000 --> 00:10:18,880
need

245
00:10:18,880 --> 00:10:21,279
an attacker physical device you just

246
00:10:21,279 --> 00:10:23,680
need a computer in order to interface

247
00:10:23,680 --> 00:10:26,560
with your telegram apis and send

248
00:10:26,560 --> 00:10:29,360
the malicious mit stickers to anybody

249
00:10:29,360 --> 00:10:31,440
you want

250
00:10:31,440 --> 00:10:33,279
last but not least

251
00:10:33,279 --> 00:10:34,640
by default

252
00:10:34,640 --> 00:10:37,519
uh during my research new chat from

253
00:10:37,519 --> 00:10:40,079
strangers do not have any additional

254
00:10:40,079 --> 00:10:41,920
protection enabled so

255
00:10:41,920 --> 00:10:44,320
uh new for example secret chat from

256
00:10:44,320 --> 00:10:45,600
strangers

257
00:10:45,600 --> 00:10:47,760
do not have animations disabled by

258
00:10:47,760 --> 00:10:50,320
default so

259
00:10:50,320 --> 00:10:52,640
you can just send a malicious animated

260
00:10:52,640 --> 00:10:54,079
sticker to

261
00:10:54,079 --> 00:10:56,079
somebody who has not you in their

262
00:10:56,079 --> 00:10:57,920
contacts and the

263
00:10:57,920 --> 00:10:59,680
animation sticker will be passed and

264
00:10:59,680 --> 00:11:02,880
rendered like it's normal

265
00:11:02,880 --> 00:11:04,720
let's have a look at the

266
00:11:04,720 --> 00:11:07,360
specific integration of a lot in

267
00:11:07,360 --> 00:11:09,600
telegram for android

268
00:11:09,600 --> 00:11:12,480
as you can as we can see in the

269
00:11:12,480 --> 00:11:13,839
above images

270
00:11:13,839 --> 00:11:16,079
they are com they come from the image

271
00:11:16,079 --> 00:11:17,040
loader

272
00:11:17,040 --> 00:11:18,959
file which is part of the

273
00:11:18,959 --> 00:11:20,160
chat

274
00:11:20,160 --> 00:11:21,600
code base

275
00:11:21,600 --> 00:11:24,320
as you can see first the mime type of

276
00:11:24,320 --> 00:11:26,560
the document which was received is

277
00:11:26,560 --> 00:11:29,360
checked to be the specific of the

278
00:11:29,360 --> 00:11:31,519
animated sticker so

279
00:11:31,519 --> 00:11:34,399
it must be application slash x-tg

280
00:11:34,399 --> 00:11:36,959
sticker and as you can see it will set

281
00:11:36,959 --> 00:11:39,279
the image type to image type lottie

282
00:11:39,279 --> 00:11:41,200
since it's a

283
00:11:41,200 --> 00:11:43,200
animated sticker so it's a lofty

284
00:11:43,200 --> 00:11:45,120
animation

285
00:11:45,120 --> 00:11:46,480
after that the

286
00:11:46,480 --> 00:11:48,880
our lottie drawable object will be

287
00:11:48,880 --> 00:11:51,279
created

288
00:11:51,279 --> 00:11:52,880
which as you can see

289
00:11:52,880 --> 00:11:53,920
will pass

290
00:11:53,920 --> 00:11:56,480
the local file system path of the

291
00:11:56,480 --> 00:11:58,959
downloaded animated sticker

292
00:11:58,959 --> 00:12:01,040
the width the height

293
00:12:01,040 --> 00:12:03,440
and some other option that we we don't

294
00:12:03,440 --> 00:12:07,120
care about and in the end it will

295
00:12:07,120 --> 00:12:09,920
finish in the load from file api that we

296
00:12:09,920 --> 00:12:12,560
have seen earlier in the arlotti

297
00:12:12,560 --> 00:12:15,920
uh project home page and from there

298
00:12:15,920 --> 00:12:18,000
there is going to be just the

299
00:12:18,000 --> 00:12:19,600
rendersync

300
00:12:19,600 --> 00:12:21,279
method function

301
00:12:21,279 --> 00:12:24,240
called that will actually render the

302
00:12:24,240 --> 00:12:28,200
animation on a bitmap

303
00:12:39,040 --> 00:12:41,760
so as we have seen

304
00:12:41,760 --> 00:12:44,079
our lot is reachable remotely there is

305
00:12:44,079 --> 00:12:45,920
no sandbox or

306
00:12:45,920 --> 00:12:48,320
specific protection or

307
00:12:48,320 --> 00:12:50,480
anything like that

308
00:12:50,480 --> 00:12:54,320
moreover during my tests i noticed that

309
00:12:54,320 --> 00:12:56,880
i couldn't actually send malicious

310
00:12:56,880 --> 00:13:01,200
animated stickers in the clear tags

311
00:13:01,200 --> 00:13:03,839
chat of telegram

312
00:13:03,839 --> 00:13:06,240
which is the default one which is not

313
00:13:06,240 --> 00:13:08,160
end-to-end encrypted

314
00:13:08,160 --> 00:13:09,839
so my guess was that

315
00:13:09,839 --> 00:13:12,800
uh telegram is actually filtering

316
00:13:12,800 --> 00:13:15,360
bad stickers from the clear text charts

317
00:13:15,360 --> 00:13:16,959
since they have access to the messages

318
00:13:16,959 --> 00:13:20,079
so on the other end it's not really

319
00:13:20,079 --> 00:13:22,160
received

320
00:13:22,160 --> 00:13:24,399
of course as i mentioned earlier

321
00:13:24,399 --> 00:13:26,560
uh they can't really

322
00:13:26,560 --> 00:13:28,320
filter secret shots

323
00:13:28,320 --> 00:13:30,480
uh the only way would be to have like an

324
00:13:30,480 --> 00:13:32,560
end-to-end bypass

325
00:13:32,560 --> 00:13:34,399
which i guess they don't have

326
00:13:34,399 --> 00:13:36,399
uh so they can't really filter secret

327
00:13:36,399 --> 00:13:37,839
chat and this is

328
00:13:37,839 --> 00:13:39,279
the actual

329
00:13:39,279 --> 00:13:43,360
attack vector we are going to analyze

330
00:13:44,880 --> 00:13:47,519
so let's move to the fuzzing efforts and

331
00:13:47,519 --> 00:13:48,480
the

332
00:13:48,480 --> 00:13:50,320
methodology i have adopted in this

333
00:13:50,320 --> 00:13:52,880
research

334
00:13:54,160 --> 00:13:55,120
i have

335
00:13:55,120 --> 00:13:57,600
a specific

336
00:13:57,600 --> 00:13:59,760
methodology usually which can be

337
00:13:59,760 --> 00:14:02,800
submitted up either by the keep it

338
00:14:02,800 --> 00:14:05,680
simple stupid

339
00:14:06,560 --> 00:14:07,920
title

340
00:14:07,920 --> 00:14:09,040
or

341
00:14:09,040 --> 00:14:13,079
this specific infosuc

342
00:14:16,320 --> 00:14:19,279
i always try to do the laziest and easy

343
00:14:19,279 --> 00:14:22,240
test first and see what happens

344
00:14:22,240 --> 00:14:25,360
and then if i really need to get smarter

345
00:14:25,360 --> 00:14:26,560
or

346
00:14:26,560 --> 00:14:27,600
like

347
00:14:27,600 --> 00:14:30,160
try some more advanced methods i will

348
00:14:30,160 --> 00:14:33,279
try them only if i really need to use

349
00:14:33,279 --> 00:14:35,439
them

350
00:14:36,560 --> 00:14:39,519
so during the first phase since

351
00:14:39,519 --> 00:14:42,639
our lot is open source i just decided to

352
00:14:42,639 --> 00:14:45,279
go with coverage guided fighting since

353
00:14:45,279 --> 00:14:46,880
we can easily

354
00:14:46,880 --> 00:14:50,399
instrument the arlotti code and

355
00:14:50,399 --> 00:14:52,639
fuzz it

356
00:14:52,639 --> 00:14:55,760
so the initial corpus was collected

357
00:14:55,760 --> 00:14:58,639
pretty much automatically from the

358
00:14:58,639 --> 00:15:00,880
telegram communities online since when i

359
00:15:00,880 --> 00:15:03,839
started my research

360
00:15:03,839 --> 00:15:07,519
the some of the animated stickers

361
00:15:07,519 --> 00:15:10,880
designers were already publishing some

362
00:15:10,880 --> 00:15:13,199
some of them online so i could just

363
00:15:13,199 --> 00:15:15,440
download them and

364
00:15:15,440 --> 00:15:19,040
add them to the corpus

365
00:15:20,399 --> 00:15:22,560
after

366
00:15:22,560 --> 00:15:26,639
by just using the default mutator first

367
00:15:26,639 --> 00:15:28,959
using fl plus plus then using live

368
00:15:28,959 --> 00:15:30,240
fuzzer

369
00:15:30,240 --> 00:15:32,800
so by just trying to beat flip them or

370
00:15:32,800 --> 00:15:35,759
mess for example with integers

371
00:15:35,759 --> 00:15:38,079
our lottie crashed already which was a

372
00:15:38,079 --> 00:15:40,720
really interesting point

373
00:15:40,720 --> 00:15:42,240
because uh

374
00:15:42,240 --> 00:15:45,279
still to this day i don't know if

375
00:15:45,279 --> 00:15:48,320
either no one fuzzed it before me or

376
00:15:48,320 --> 00:15:51,519
nobody reported any issue in this code i

377
00:15:51,519 --> 00:15:54,720
still don't know

378
00:15:54,720 --> 00:15:56,399
but

379
00:15:56,399 --> 00:15:58,240
since i had already some crashes i

380
00:15:58,240 --> 00:16:01,360
wanted to try to have a little of

381
00:16:01,360 --> 00:16:04,079
uh tesca minimization and the root cause

382
00:16:04,079 --> 00:16:07,360
analysis the problem here is that since

383
00:16:07,360 --> 00:16:08,720
the

384
00:16:08,720 --> 00:16:10,800
animated stickers coming from

385
00:16:10,800 --> 00:16:13,120
inserted in the corpus were coming from

386
00:16:13,120 --> 00:16:14,800
the

387
00:16:14,800 --> 00:16:16,880
online communities they included a lot

388
00:16:16,880 --> 00:16:18,320
of

389
00:16:18,320 --> 00:16:20,079
useless data

390
00:16:20,079 --> 00:16:21,360
for the

391
00:16:21,360 --> 00:16:24,079
actual crash to happen for example

392
00:16:24,079 --> 00:16:25,839
metadata or

393
00:16:25,839 --> 00:16:28,399
comments or stuff like that

394
00:16:28,399 --> 00:16:30,800
uh because i i didn't

395
00:16:30,800 --> 00:16:32,959
try to minimize them because as you can

396
00:16:32,959 --> 00:16:35,839
imagine since they included this much

397
00:16:35,839 --> 00:16:38,320
data and they had to

398
00:16:38,320 --> 00:16:39,759
respect

399
00:16:39,759 --> 00:16:44,079
first the json specification than the

400
00:16:44,079 --> 00:16:46,480
specification it wasn't really

401
00:16:46,480 --> 00:16:48,160
simple to do

402
00:16:48,160 --> 00:16:51,759
and this problem uh appeared again when

403
00:16:51,759 --> 00:16:54,480
i wanted to minimize the

404
00:16:54,480 --> 00:16:56,959
uh test cases

405
00:16:56,959 --> 00:16:57,759
which

406
00:16:57,759 --> 00:17:00,959
uh unfortunately from my experience is

407
00:17:00,959 --> 00:17:03,519
just uh endless brute force because it

408
00:17:03,519 --> 00:17:05,199
will try to remove

409
00:17:05,199 --> 00:17:07,919
bites randomly and see if it still

410
00:17:07,919 --> 00:17:09,439
crashes

411
00:17:09,439 --> 00:17:11,199
the only problem is that

412
00:17:11,199 --> 00:17:13,760
uh i wanted the specific animated

413
00:17:13,760 --> 00:17:16,880
sticker to keep crashing in the same way

414
00:17:16,880 --> 00:17:19,760
and since

415
00:17:19,760 --> 00:17:23,039
as i mentioned earlier i always try to

416
00:17:23,039 --> 00:17:26,319
find the easiest solution first and then

417
00:17:26,319 --> 00:17:27,280
maybe

418
00:17:27,280 --> 00:17:30,880
get smarter i just decided to

419
00:17:30,880 --> 00:17:33,039
brute force them but try to be a little

420
00:17:33,039 --> 00:17:36,640
bit a little bit smarter so

421
00:17:36,640 --> 00:17:38,160
by using uh

422
00:17:38,160 --> 00:17:41,200
both alpha empty and

423
00:17:41,200 --> 00:17:44,720
ozone and graph so basically

424
00:17:44,720 --> 00:17:45,600
this

425
00:17:45,600 --> 00:17:49,520
could be like the steps you can use

426
00:17:49,520 --> 00:17:52,160
of course uh manual minimization was uh

427
00:17:52,160 --> 00:17:54,880
not an option for me actually a sd brute

428
00:17:54,880 --> 00:17:58,320
forcer would have required the uh

429
00:17:58,320 --> 00:18:00,640
s asd aware

430
00:18:00,640 --> 00:18:03,200
parser and decoder which again require

431
00:18:03,200 --> 00:18:06,480
the uh quite some work

432
00:18:06,480 --> 00:18:10,080
empty is a tool developed by uh taviso

433
00:18:10,080 --> 00:18:12,840
from google project zero which allows us

434
00:18:12,840 --> 00:18:16,880
to try to minimize minimize

435
00:18:16,880 --> 00:18:18,480
a test case and

436
00:18:18,480 --> 00:18:21,520
test it through a script

437
00:18:21,520 --> 00:18:22,880
so what i

438
00:18:22,880 --> 00:18:26,000
have done i just use it together other

439
00:18:26,000 --> 00:18:28,080
sanitizer graph and alpha empty in order

440
00:18:28,080 --> 00:18:29,120
to keep

441
00:18:29,120 --> 00:18:30,640
that test case

442
00:18:30,640 --> 00:18:32,960
crashing in the same way while

443
00:18:32,960 --> 00:18:35,760
minimizing it

444
00:18:36,000 --> 00:18:37,919
so this is pretty much

445
00:18:37,919 --> 00:18:38,640
the

446
00:18:38,640 --> 00:18:41,120
what i've done so you can see above

447
00:18:41,120 --> 00:18:44,000
there is the run and grab

448
00:18:44,000 --> 00:18:46,960
it based buffer overflow for white

449
00:18:46,960 --> 00:18:50,080
dot bash script which basically

450
00:18:50,080 --> 00:18:53,120
will pass the standard input coming from

451
00:18:53,120 --> 00:18:55,280
alpha empty to the

452
00:18:55,280 --> 00:18:56,880
lottie parser

453
00:18:56,880 --> 00:18:58,799
instrumented with other sanitizer and

454
00:18:58,799 --> 00:19:00,640
then grab

455
00:19:00,640 --> 00:19:03,360
the right of size 4 because i wanted

456
00:19:03,360 --> 00:19:06,640
that specific crash of course

457
00:19:06,640 --> 00:19:07,919
i could have

458
00:19:07,919 --> 00:19:10,960
filtered for the program counter for the

459
00:19:10,960 --> 00:19:13,120
stack trace or whatever i wanted from

460
00:19:13,120 --> 00:19:15,520
the other sanitizer report

461
00:19:15,520 --> 00:19:20,400
but i just want i had just this specific

462
00:19:21,039 --> 00:19:24,720
right of four bytes so i just wanted to

463
00:19:24,720 --> 00:19:28,559
do it this way and below you can see the

464
00:19:28,559 --> 00:19:29,440
uh

465
00:19:29,440 --> 00:19:31,280
actual main

466
00:19:31,280 --> 00:19:33,600
command line

467
00:19:33,600 --> 00:19:37,039
definition which calls of empty

468
00:19:37,039 --> 00:19:39,919
says that it must be stable so

469
00:19:39,919 --> 00:19:43,440
deterministic the zero char is the uh

470
00:19:43,440 --> 00:19:45,760
ascii space chart because it's a json

471
00:19:45,760 --> 00:19:48,400
and the space will just be

472
00:19:48,400 --> 00:19:49,919
skipped

473
00:19:49,919 --> 00:19:52,000
i wanted the output in the minimize the

474
00:19:52,000 --> 00:19:55,760
json and i wanted this

475
00:19:55,840 --> 00:19:59,039
script to run with the other sanitizer

476
00:19:59,039 --> 00:20:00,400
instrumented

477
00:20:00,400 --> 00:20:02,960
parcel

478
00:20:05,600 --> 00:20:08,400
we can move to just a quick view of the

479
00:20:08,400 --> 00:20:10,559
summary stats and note that these are

480
00:20:10,559 --> 00:20:11,520
actually

481
00:20:11,520 --> 00:20:14,799
the very initial stats on chip hardware

482
00:20:14,799 --> 00:20:15,919
basically

483
00:20:15,919 --> 00:20:18,960
it was run on a

484
00:20:19,679 --> 00:20:22,400
laptop i had uh

485
00:20:22,400 --> 00:20:24,720
in our offices uh

486
00:20:24,720 --> 00:20:26,320
as you can see

487
00:20:26,320 --> 00:20:28,799
just by having it uh running some days

488
00:20:28,799 --> 00:20:31,919
it already has found quite some

489
00:20:31,919 --> 00:20:35,520
crashes here it says local unique but as

490
00:20:35,520 --> 00:20:37,280
you can imagine since

491
00:20:37,280 --> 00:20:40,720
they are both jsons both uh

492
00:20:40,720 --> 00:20:42,640
lotte animations

493
00:20:42,640 --> 00:20:44,400
um

494
00:20:44,400 --> 00:20:46,960
in this case fl plus plus is not really

495
00:20:46,960 --> 00:20:50,799
able to uh categorize them and

496
00:20:50,799 --> 00:20:53,200
test if they are actually unique because

497
00:20:53,200 --> 00:20:54,880
as we will see later all of these

498
00:20:54,880 --> 00:20:55,919
crashes

499
00:20:55,919 --> 00:20:57,840
in the end were just

500
00:20:57,840 --> 00:21:00,159
uh 11 11

501
00:21:00,159 --> 00:21:03,840
unique issues

502
00:21:04,880 --> 00:21:07,600
last but not least

503
00:21:07,600 --> 00:21:10,320
coverage at the end of my research was

504
00:21:10,320 --> 00:21:11,679
around 90

505
00:21:11,679 --> 00:21:14,720
so i was pretty happy with it so

506
00:21:14,720 --> 00:21:16,640
i didn't really

507
00:21:16,640 --> 00:21:17,520
put

508
00:21:17,520 --> 00:21:20,159
additional effort after the structural

509
00:21:20,159 --> 00:21:24,159
fuzzing that we will see later

510
00:21:24,159 --> 00:21:26,880
let's have a quick look at the

511
00:21:26,880 --> 00:21:30,000
harness as you can see it's just the

512
00:21:30,000 --> 00:21:33,520
load from file and the render sync

513
00:21:33,520 --> 00:21:35,600
method call

514
00:21:35,600 --> 00:21:38,320
just a thing to note here is that i

515
00:21:38,320 --> 00:21:41,200
added the specific frame number

516
00:21:41,200 --> 00:21:44,640
which the arlotti library was trying to

517
00:21:44,640 --> 00:21:46,960
parse to render

518
00:21:46,960 --> 00:21:49,280
in order to being able to

519
00:21:49,280 --> 00:21:53,039
spot which specific frame crashed

520
00:21:53,039 --> 00:21:56,760
the library

521
00:21:58,559 --> 00:22:03,360
so as i mentioned the earlier

522
00:22:03,360 --> 00:22:05,600
the animated stickers so the lottie

523
00:22:05,600 --> 00:22:07,039
animations

524
00:22:07,039 --> 00:22:09,679
must actually respect two specifications

525
00:22:09,679 --> 00:22:10,799
the first

526
00:22:10,799 --> 00:22:13,039
they must be valid jsons and the second

527
00:22:13,039 --> 00:22:15,600
is that they must respect the lottie

528
00:22:15,600 --> 00:22:17,280
specification

529
00:22:17,280 --> 00:22:19,260
so the problem here is that

530
00:22:19,260 --> 00:22:20,559
[Music]

531
00:22:20,559 --> 00:22:24,000
the built-in mutators in the most

532
00:22:24,000 --> 00:22:26,400
famous fathers like i mentioned earlier

533
00:22:26,400 --> 00:22:27,360
i used

534
00:22:27,360 --> 00:22:31,199
afl plus plus then lip father

535
00:22:31,760 --> 00:22:35,120
of course try to mess with some

536
00:22:35,120 --> 00:22:38,720
standard techniques like a bit flipping

537
00:22:38,720 --> 00:22:40,480
playing with the integers and other

538
00:22:40,480 --> 00:22:41,360
stuff

539
00:22:41,360 --> 00:22:43,360
but in this specific context since we

540
00:22:43,360 --> 00:22:44,640
have already

541
00:22:44,640 --> 00:22:46,640
all of these constraints

542
00:22:46,640 --> 00:22:49,120
they are not really uh

543
00:22:49,120 --> 00:22:51,520
useful since as we can see this is

544
00:22:51,520 --> 00:22:55,280
actually a reference to a bug in v8 but

545
00:22:55,280 --> 00:22:57,440
in in the early

546
00:22:57,440 --> 00:22:58,559
case

547
00:22:58,559 --> 00:23:02,240
-0 is really not it's useless because

548
00:23:02,240 --> 00:23:03,760
there is no

549
00:23:03,760 --> 00:23:04,960
such

550
00:23:04,960 --> 00:23:08,000
type of of layer as you can see the t y

551
00:23:08,000 --> 00:23:12,240
is the key for the type of the layer

552
00:23:12,240 --> 00:23:15,520
so it's a wasted mutation i wasted the

553
00:23:15,520 --> 00:23:17,280
test case so

554
00:23:17,280 --> 00:23:18,799
i didn't want this

555
00:23:18,799 --> 00:23:20,080
in order to

556
00:23:20,080 --> 00:23:24,080
improve this always uh surfing the uh

557
00:23:24,080 --> 00:23:26,080
his uh

558
00:23:26,080 --> 00:23:28,480
framework

559
00:23:28,480 --> 00:23:30,159
i tried to

560
00:23:30,159 --> 00:23:32,640
search online and

561
00:23:32,640 --> 00:23:34,480
google

562
00:23:34,480 --> 00:23:37,520
had uh this technology which which is

563
00:23:37,520 --> 00:23:40,000
called the protocol buffers or protobuf

564
00:23:40,000 --> 00:23:40,799
which

565
00:23:40,799 --> 00:23:42,080
is a

566
00:23:42,080 --> 00:23:44,799
language and agnostic grammar in order

567
00:23:44,799 --> 00:23:46,080
to define

568
00:23:46,080 --> 00:23:48,559
pretty much anything as you can see in

569
00:23:48,559 --> 00:23:51,200
this example on the left

570
00:23:51,200 --> 00:23:52,960
part you have

571
00:23:52,960 --> 00:23:54,720
the

572
00:23:54,720 --> 00:23:58,159
message type person which has a name an

573
00:23:58,159 --> 00:24:02,000
identifier and uh email attributes

574
00:24:02,000 --> 00:24:04,080
and on the right part you can see that

575
00:24:04,080 --> 00:24:06,240
in simplest plus it's really easy to

576
00:24:06,240 --> 00:24:08,400
parse for example the

577
00:24:08,400 --> 00:24:12,080
standard input into uh

578
00:24:12,080 --> 00:24:13,600
into a specific

579
00:24:13,600 --> 00:24:16,960
type which was defined in protobuf

580
00:24:16,960 --> 00:24:20,480
so we can easily encode and decode the

581
00:24:20,480 --> 00:24:22,880
data using uh

582
00:24:22,880 --> 00:24:26,240
a specific grammar

583
00:24:26,240 --> 00:24:28,320
what how we can uh

584
00:24:28,320 --> 00:24:30,000
implement this in

585
00:24:30,000 --> 00:24:33,279
a fadzer basically we first as i

586
00:24:33,279 --> 00:24:36,080
mentioned we need to define a grammar so

587
00:24:36,080 --> 00:24:38,080
all i have done is

588
00:24:38,080 --> 00:24:43,440
write in the uh arlotti protobuf

589
00:24:43,440 --> 00:24:46,799
i chose to write the specific arlotti

590
00:24:46,799 --> 00:24:49,360
specification and not the lost animation

591
00:24:49,360 --> 00:24:51,120
specification because they are

592
00:24:51,120 --> 00:24:52,960
they have some differences since i was

593
00:24:52,960 --> 00:24:56,080
targeting the arlotti library and not

594
00:24:56,080 --> 00:24:57,840
each and every

595
00:24:57,840 --> 00:25:01,360
lottie parser as you can see most of the

596
00:25:01,360 --> 00:25:03,360
attributes are

597
00:25:03,360 --> 00:25:06,320
primitive types so some doubles some

598
00:25:06,320 --> 00:25:09,039
unsigned ins

599
00:25:09,200 --> 00:25:10,960
but the most interesting one are

600
00:25:10,960 --> 00:25:13,360
actually the layers and assets because

601
00:25:13,360 --> 00:25:15,440
as we have seen earlier

602
00:25:15,440 --> 00:25:17,840
actually the most of the juicy stuff is

603
00:25:17,840 --> 00:25:18,799
in the

604
00:25:18,799 --> 00:25:21,918
layers part

605
00:25:23,520 --> 00:25:26,320
so by

606
00:25:26,320 --> 00:25:29,120
integrating this uh grammar grammar

607
00:25:29,120 --> 00:25:31,840
logic uh in a fadzer we can

608
00:25:31,840 --> 00:25:35,440
really uh do some actually useful uh

609
00:25:35,440 --> 00:25:37,279
mutations so for example here you can

610
00:25:37,279 --> 00:25:38,240
see

611
00:25:38,240 --> 00:25:41,919
a really dumb uh example but it's just

612
00:25:41,919 --> 00:25:44,720
to make you understand that this can be

613
00:25:44,720 --> 00:25:48,880
actually very powerful translated to a

614
00:25:48,880 --> 00:25:49,679
uh

615
00:25:49,679 --> 00:25:54,480
target complex complex as a lot or more

616
00:25:54,480 --> 00:25:58,159
instead of uh trying with weird numbers

617
00:25:58,159 --> 00:26:00,720
we will try only the

618
00:26:00,720 --> 00:26:03,760
accepted for example types of layers

619
00:26:03,760 --> 00:26:04,720
since

620
00:26:04,720 --> 00:26:06,720
we really want to

621
00:26:06,720 --> 00:26:09,039
advance our coverage so potentially

622
00:26:09,039 --> 00:26:10,000
reach

623
00:26:10,000 --> 00:26:13,679
100 percent of coverage

624
00:26:16,880 --> 00:26:19,200
so instead of using the built-in live

625
00:26:19,200 --> 00:26:22,159
fuzzer mutator uh

626
00:26:22,159 --> 00:26:25,440
google as well also created the the lib

627
00:26:25,440 --> 00:26:27,760
prototype mutator which

628
00:26:27,760 --> 00:26:28,559
uh

629
00:26:28,559 --> 00:26:29,760
is a

630
00:26:29,760 --> 00:26:32,880
external mutator which can be used in

631
00:26:32,880 --> 00:26:35,760
many uh fathers at the time

632
00:26:35,760 --> 00:26:38,159
if i remember correctly only father

633
00:26:38,159 --> 00:26:40,000
supported it

634
00:26:40,000 --> 00:26:41,919
but in this way we can

635
00:26:41,919 --> 00:26:44,960
easily uh tell the father that we want

636
00:26:44,960 --> 00:26:47,679
to use this mutator and we want only

637
00:26:47,679 --> 00:26:49,840
useful mutations because we define the

638
00:26:49,840 --> 00:26:52,960
grammar and we define the logic that the

639
00:26:52,960 --> 00:26:55,279
grammar must respect

640
00:26:55,279 --> 00:26:58,240
both in the grammar and in the arness

641
00:26:58,240 --> 00:27:00,720
so thanks to this we move to the second

642
00:27:00,720 --> 00:27:04,240
phase of my fuzzing methodology

643
00:27:04,240 --> 00:27:05,440
which is the structure structural

644
00:27:05,440 --> 00:27:07,360
fuzzing which is basically

645
00:27:07,360 --> 00:27:08,640
fuzzing

646
00:27:08,640 --> 00:27:10,159
uh from

647
00:27:10,159 --> 00:27:13,200
a structural aware mutator which allows

648
00:27:13,200 --> 00:27:14,880
us as i said to

649
00:27:14,880 --> 00:27:17,760
uh make useful mutations and potentially

650
00:27:17,760 --> 00:27:20,880
advance the coverage we reach so yeah it

651
00:27:20,880 --> 00:27:23,679
can be pretty much summed up in these

652
00:27:23,679 --> 00:27:25,600
four points

653
00:27:25,600 --> 00:27:28,240
the arlotti proto which is the protobuf

654
00:27:28,240 --> 00:27:29,760
definition of the

655
00:27:29,760 --> 00:27:31,760
arlotti specification

656
00:27:31,760 --> 00:27:33,520
then

657
00:27:33,520 --> 00:27:35,120
thanks to this uh

658
00:27:35,120 --> 00:27:37,440
grammar we create an animated sticker

659
00:27:37,440 --> 00:27:38,960
from scratch

660
00:27:38,960 --> 00:27:41,760
then we pass this to lib fuzzer in order

661
00:27:41,760 --> 00:27:42,559
to

662
00:27:42,559 --> 00:27:43,440
uh

663
00:27:43,440 --> 00:27:45,360
pass it in turn to the mutator which

664
00:27:45,360 --> 00:27:49,279
will mutate it in a useful way

665
00:27:49,279 --> 00:27:50,559
then

666
00:27:50,559 --> 00:27:53,919
since this is still in the protobuf

667
00:27:53,919 --> 00:27:56,720
format we need a way to convert this to

668
00:27:56,720 --> 00:27:59,200
a json in order to be accepted by the

669
00:27:59,200 --> 00:28:01,039
parcel

670
00:28:01,039 --> 00:28:02,399
so this conversion

671
00:28:02,399 --> 00:28:05,440
uh logic is implemented in the ernest

672
00:28:05,440 --> 00:28:10,000
which will in turn actually pass the um

673
00:28:10,000 --> 00:28:12,399
the created animated sticker created and

674
00:28:12,399 --> 00:28:15,679
the mutated animated sticker to the

675
00:28:15,679 --> 00:28:18,159
actual parser which will try to parse

676
00:28:18,159 --> 00:28:22,080
and render the sticker

677
00:28:23,520 --> 00:28:26,320
let's now have a little comparison of

678
00:28:26,320 --> 00:28:27,919
the fuzzers

679
00:28:27,919 --> 00:28:29,679
i wrote

680
00:28:29,679 --> 00:28:32,320
just a little discriminate here these

681
00:28:32,320 --> 00:28:34,080
benchmarks are

682
00:28:34,080 --> 00:28:37,360
uh not to be taken uh

683
00:28:37,360 --> 00:28:40,399
really like uh in a deterministic way

684
00:28:40,399 --> 00:28:45,520
since you might get some other results

685
00:28:45,520 --> 00:28:47,760
i've divided the

686
00:28:47,760 --> 00:28:50,399
columns in into two uh

687
00:28:50,399 --> 00:28:51,360
main

688
00:28:51,360 --> 00:28:53,840
fuzzers since as we have seen first i

689
00:28:53,840 --> 00:28:55,600
tried with simple coverage guided

690
00:28:55,600 --> 00:28:59,600
fuzzing then i moved to structure where

691
00:28:59,600 --> 00:29:01,919
as you can see

692
00:29:01,919 --> 00:29:04,000
i had quite some

693
00:29:04,000 --> 00:29:06,399
coding iterations for the harness

694
00:29:06,399 --> 00:29:08,480
because since in coverage guided i just

695
00:29:08,480 --> 00:29:10,080
needed to

696
00:29:10,080 --> 00:29:12,640
parse it from the file system or a

697
00:29:12,640 --> 00:29:13,679
string

698
00:29:13,679 --> 00:29:14,720
load it

699
00:29:14,720 --> 00:29:16,559
load it in memory parse it and then

700
00:29:16,559 --> 00:29:18,880
render it while in structure where i had

701
00:29:18,880 --> 00:29:22,159
to implement all of this uh

702
00:29:22,320 --> 00:29:25,120
arlotti grammar and

703
00:29:25,120 --> 00:29:27,039
protobuf2 json

704
00:29:27,039 --> 00:29:30,159
conversion grammar so i had to

705
00:29:30,159 --> 00:29:33,440
write the rns quite some time so

706
00:29:33,440 --> 00:29:35,600
but

707
00:29:35,840 --> 00:29:37,760
a plus of this

708
00:29:37,760 --> 00:29:41,279
improvement is the uh invalid mutations

709
00:29:41,279 --> 00:29:44,080
uh percentage because as you can see

710
00:29:44,080 --> 00:29:45,919
most of the coverage guided mutations

711
00:29:45,919 --> 00:29:47,039
either

712
00:29:47,039 --> 00:29:50,559
broke the json specification or

713
00:29:50,559 --> 00:29:53,840
didn't weren't really useful from uh our

714
00:29:53,840 --> 00:29:57,679
lotte grammar standpoint so i was pretty

715
00:29:57,679 --> 00:30:02,559
much wasting time and executions

716
00:30:02,559 --> 00:30:04,640
downside of this is a slow down of

717
00:30:04,640 --> 00:30:06,640
course because since there is a lot more

718
00:30:06,640 --> 00:30:09,360
logic involved is way slower instead of

719
00:30:09,360 --> 00:30:12,399
just with flipping it's creating from

720
00:30:12,399 --> 00:30:14,960
scratch animated stickers and mutating

721
00:30:14,960 --> 00:30:16,399
it

722
00:30:16,399 --> 00:30:19,360
by respecting a specific grammar

723
00:30:19,360 --> 00:30:21,919
last two rows of this page as you can

724
00:30:21,919 --> 00:30:24,240
see the time of course it's really

725
00:30:24,240 --> 00:30:26,399
different since with coverage guided i

726
00:30:26,399 --> 00:30:27,760
just needed to

727
00:30:27,760 --> 00:30:30,080
download quite a bunch of animated

728
00:30:30,080 --> 00:30:31,919
stickers from

729
00:30:31,919 --> 00:30:33,039
google

730
00:30:33,039 --> 00:30:34,080
and then

731
00:30:34,080 --> 00:30:35,200
run it

732
00:30:35,200 --> 00:30:37,679
after i wrote those five lines of uh

733
00:30:37,679 --> 00:30:39,919
harness while we

734
00:30:39,919 --> 00:30:42,240
structure where i needed to as i said

735
00:30:42,240 --> 00:30:45,120
write all of this grammar and conversion

736
00:30:45,120 --> 00:30:46,000
logic

737
00:30:46,000 --> 00:30:48,640
which took quite some time

738
00:30:48,640 --> 00:30:51,520
time to results uh two is uh quite

739
00:30:51,520 --> 00:30:53,760
different since uh

740
00:30:53,760 --> 00:30:56,880
even if the coverage was advancing uh

741
00:30:56,880 --> 00:30:59,279
faster than the coverage simple coverage

742
00:30:59,279 --> 00:31:00,720
guided fuzzing

743
00:31:00,720 --> 00:31:02,640
it still took quite a lot of time in

744
00:31:02,640 --> 00:31:05,279
order to arrive to

745
00:31:05,279 --> 00:31:08,480
more than 90 percent of coverage so

746
00:31:08,480 --> 00:31:10,399
that was another difference i'm moving

747
00:31:10,399 --> 00:31:13,760
to this second page

748
00:31:13,760 --> 00:31:14,720
uh

749
00:31:14,720 --> 00:31:16,720
as i said in the

750
00:31:16,720 --> 00:31:19,760
coverage part

751
00:31:19,760 --> 00:31:22,080
in simple coverage guided it really

752
00:31:22,080 --> 00:31:25,039
depends on the corpus since

753
00:31:25,039 --> 00:31:27,919
i wanted to have the most diversified

754
00:31:27,919 --> 00:31:29,519
corpus

755
00:31:29,519 --> 00:31:31,440
for starting the coverage guided fuzzing

756
00:31:31,440 --> 00:31:32,559
but still

757
00:31:32,559 --> 00:31:34,720
i couldn't really

758
00:31:34,720 --> 00:31:36,720
advance the coverage after a point

759
00:31:36,720 --> 00:31:38,880
because the mutator didn't have the

760
00:31:38,880 --> 00:31:42,320
knowledge to create useful objects or

761
00:31:42,320 --> 00:31:44,399
layers in the animations to in order to

762
00:31:44,399 --> 00:31:47,840
improve the coverage which instead

763
00:31:47,840 --> 00:31:50,080
was possible in the structure aware part

764
00:31:50,080 --> 00:31:51,120
since

765
00:31:51,120 --> 00:31:54,399
theoretically i had no limit no coverage

766
00:31:54,399 --> 00:31:56,240
limit because

767
00:31:56,240 --> 00:31:58,480
it was just a matter of time and

768
00:31:58,480 --> 00:32:00,559
the immutator would create

769
00:32:00,559 --> 00:32:01,919
a pretty much

770
00:32:01,919 --> 00:32:05,919
any kind of animated sticker

771
00:32:05,919 --> 00:32:07,919
two points about the this test case the

772
00:32:07,919 --> 00:32:09,919
minimization and comparison as i

773
00:32:09,919 --> 00:32:11,440
mentioned earlier

774
00:32:11,440 --> 00:32:13,519
in coverage guided the simple coverage

775
00:32:13,519 --> 00:32:17,120
guided it's possible really only through

776
00:32:17,120 --> 00:32:19,519
brute force or of course manually but

777
00:32:19,519 --> 00:32:21,679
that was not an option

778
00:32:21,679 --> 00:32:25,440
and the comparison also is low since

779
00:32:25,440 --> 00:32:27,279
we actually need to minimize them

780
00:32:27,279 --> 00:32:29,120
because as you can imagine three

781
00:32:29,120 --> 00:32:30,559
kilobytes of

782
00:32:30,559 --> 00:32:34,559
single line json uh files are not really

783
00:32:34,559 --> 00:32:39,039
simple to uh compare uh one another

784
00:32:39,039 --> 00:32:40,720
without a

785
00:32:40,720 --> 00:32:43,120
ast aware uh

786
00:32:43,120 --> 00:32:45,279
decoder and encoder

787
00:32:45,279 --> 00:32:47,679
while on the structure where it's

788
00:32:47,679 --> 00:32:50,480
pretty much direct and scriptable since

789
00:32:50,480 --> 00:32:52,399
we already have the grammar logic so we

790
00:32:52,399 --> 00:32:54,720
just we can just use it in order to

791
00:32:54,720 --> 00:32:57,279
minimize and compare them

792
00:32:57,279 --> 00:32:59,840
last but not least

793
00:32:59,840 --> 00:33:01,039
uh

794
00:33:01,039 --> 00:33:02,559
the

795
00:33:02,559 --> 00:33:04,399
some points about the

796
00:33:04,399 --> 00:33:06,000
number of unique issues i have

797
00:33:06,000 --> 00:33:08,799
identified after ruthless analysis since

798
00:33:08,799 --> 00:33:12,720
as we have seen uh by looking at the uh

799
00:33:12,720 --> 00:33:14,799
stats coming from the fathers of course

800
00:33:14,799 --> 00:33:17,679
there were thousands of crashes

801
00:33:17,679 --> 00:33:20,000
but uh after roots called root cause

802
00:33:20,000 --> 00:33:21,360
analysis

803
00:33:21,360 --> 00:33:24,880
uh they came down to 11 and 13 but still

804
00:33:24,880 --> 00:33:26,640
as you can see i could

805
00:33:26,640 --> 00:33:28,640
find two two additional issues by

806
00:33:28,640 --> 00:33:30,640
implementing this uh

807
00:33:30,640 --> 00:33:31,760
structural

808
00:33:31,760 --> 00:33:34,320
fuzzing

809
00:33:36,480 --> 00:33:37,519
so

810
00:33:37,519 --> 00:33:40,880
let's move to uh the findings i've

811
00:33:40,880 --> 00:33:45,919
identified uh have a live demo and some

812
00:33:45,919 --> 00:33:47,919
considerations about the exploit

813
00:33:47,919 --> 00:33:50,399
limitations of

814
00:33:50,399 --> 00:33:54,158
this specific attack vector

815
00:34:04,240 --> 00:34:06,799
so as you can see here

816
00:34:06,799 --> 00:34:08,960
in the end i found 13

817
00:34:08,960 --> 00:34:11,280
issues

818
00:34:11,280 --> 00:34:15,679
this is the list of all of them

819
00:34:16,000 --> 00:34:18,800
while i usually wouldn't consider a null

820
00:34:18,800 --> 00:34:20,960
pointer the references as actual

821
00:34:20,960 --> 00:34:22,879
security bugs in this case it was

822
00:34:22,879 --> 00:34:25,280
different since uh

823
00:34:25,280 --> 00:34:28,879
as we have seen in the android example

824
00:34:28,879 --> 00:34:31,199
each and every time you open the chat

825
00:34:31,199 --> 00:34:34,399
the chat crashes since it will try to

826
00:34:34,399 --> 00:34:36,320
parse and render the malicious animated

827
00:34:36,320 --> 00:34:39,440
sticker and in the end it will crash so

828
00:34:39,440 --> 00:34:41,440
non-technical people would have quite

829
00:34:41,440 --> 00:34:44,239
some problem in order to retrieve the

830
00:34:44,239 --> 00:34:47,440
messages shared uh before

831
00:34:47,440 --> 00:34:49,280
that specific malicious sticker of

832
00:34:49,280 --> 00:34:51,839
course this is not the case for

833
00:34:51,839 --> 00:34:54,320
uh chats from strangers but uh it could

834
00:34:54,320 --> 00:34:55,839
be used from uh

835
00:34:55,839 --> 00:34:58,560
like uh chats with uh uh

836
00:34:58,560 --> 00:35:03,720
maybe more uh personal chats

837
00:35:03,920 --> 00:35:06,240
these are just the types of issues i

838
00:35:06,240 --> 00:35:08,000
have identified you can

839
00:35:08,000 --> 00:35:09,520
anyway see

840
00:35:09,520 --> 00:35:11,359
all of them and their root cause

841
00:35:11,359 --> 00:35:13,520
analysis on our website

842
00:35:13,520 --> 00:35:15,280
this is shielder.edu

843
00:35:15,280 --> 00:35:17,280
advisories

844
00:35:17,280 --> 00:35:19,920
and as you can see in bold there is the

845
00:35:19,920 --> 00:35:22,560
ip base out of bounds right which is

846
00:35:22,560 --> 00:35:24,960
what we are going to

847
00:35:24,960 --> 00:35:28,000
have a look at today

848
00:35:29,040 --> 00:35:33,200
oops so let's have a quick look at the

849
00:35:33,200 --> 00:35:34,800
other sanitizer

850
00:35:34,800 --> 00:35:37,680
wrapper for this specific issue

851
00:35:37,680 --> 00:35:38,960
as you can see

852
00:35:38,960 --> 00:35:41,680
we can see the

853
00:35:42,079 --> 00:35:44,880
type identification by other sanitizer

854
00:35:44,880 --> 00:35:47,599
which is it based buffer overflow

855
00:35:47,599 --> 00:35:51,599
and that is a variety of uh for bytes

856
00:35:51,599 --> 00:35:52,560
this is

857
00:35:52,560 --> 00:35:56,060
the stack tracer so as you can see

858
00:35:56,060 --> 00:35:57,680
[Music]

859
00:35:57,680 --> 00:36:00,400
the specific

860
00:36:00,400 --> 00:36:02,800
problem is in the

861
00:36:02,800 --> 00:36:05,359
generated gradient color table method

862
00:36:05,359 --> 00:36:10,440
which we are going to have a look at now

863
00:36:12,000 --> 00:36:15,359
so um as you can see here maybe it's a

864
00:36:15,359 --> 00:36:18,000
little bit small but i will

865
00:36:18,000 --> 00:36:19,920
walk you through it

866
00:36:19,920 --> 00:36:22,320
our input basically arrives at the stops

867
00:36:22,320 --> 00:36:23,520
uh

868
00:36:23,520 --> 00:36:26,240
vigorous and stops vector which is the

869
00:36:26,240 --> 00:36:29,520
first argument

870
00:36:29,520 --> 00:36:31,370
as we can see

871
00:36:31,370 --> 00:36:33,280
[Music]

872
00:36:33,280 --> 00:36:36,240
it will influence at line 14 and 15 both

873
00:36:36,240 --> 00:36:39,279
the start and core

874
00:36:39,520 --> 00:36:42,160
variables

875
00:36:42,960 --> 00:36:45,680
then as you can see on line 17 it will

876
00:36:45,680 --> 00:36:48,160
influence also core color the only

877
00:36:48,160 --> 00:36:51,040
constraint here is that it must respect

878
00:36:51,040 --> 00:36:52,640
the error

879
00:36:52,640 --> 00:36:56,480
a rgb encoding which is pretty much the

880
00:36:56,480 --> 00:36:58,000
only

881
00:36:58,000 --> 00:37:00,880
constraint here

882
00:37:01,520 --> 00:37:06,800
we arrive at line 21 which will

883
00:37:06,800 --> 00:37:09,280
define the first

884
00:37:09,280 --> 00:37:11,680
color in the color table which is of

885
00:37:11,680 --> 00:37:13,280
size

886
00:37:13,280 --> 00:37:15,280
size

887
00:37:15,280 --> 00:37:18,720
we arrive at the while loop on line 30

888
00:37:18,720 --> 00:37:20,400
23

889
00:37:20,400 --> 00:37:23,440
and we can see that uh actually pos

890
00:37:23,440 --> 00:37:26,400
is not checked to be uh smaller than the

891
00:37:26,400 --> 00:37:29,280
size which is the size of the color

892
00:37:29,280 --> 00:37:32,240
table array which means that potentially

893
00:37:32,240 --> 00:37:33,680
we can write

894
00:37:33,680 --> 00:37:36,720
out of the color table array bounds

895
00:37:36,720 --> 00:37:39,760
which is exactly what happens online

896
00:37:39,760 --> 00:37:42,400
24.

897
00:37:43,680 --> 00:37:45,280
so

898
00:37:45,280 --> 00:37:47,040
let's have a

899
00:37:47,040 --> 00:37:51,839
live demo of this this issue

900
00:37:52,320 --> 00:37:55,359
okay okay

901
00:37:56,660 --> 00:37:58,079
[Music]

902
00:37:58,079 --> 00:38:01,040
i should say

903
00:38:01,040 --> 00:38:05,000
can you mirror the screen

904
00:38:05,680 --> 00:38:06,560
can you

905
00:38:06,560 --> 00:38:10,119
mirror the screen

906
00:38:18,240 --> 00:38:20,320
okay we'll just move them

907
00:38:20,320 --> 00:38:22,560
there

908
00:38:23,599 --> 00:38:26,160
yeah because

909
00:38:26,480 --> 00:38:28,880
okay

910
00:38:30,640 --> 00:38:33,640
nope

911
00:38:39,119 --> 00:38:42,240
okay it's there

912
00:38:42,560 --> 00:38:45,560
start

913
00:39:00,560 --> 00:39:02,400
okay

914
00:39:02,400 --> 00:39:06,240
yeah let's try this one

915
00:39:11,040 --> 00:39:15,240
okay close close now

916
00:39:23,280 --> 00:39:24,880
okay

917
00:39:24,880 --> 00:39:26,240
you can see on the

918
00:39:26,240 --> 00:39:29,119
right part of the screen there is my

919
00:39:29,119 --> 00:39:31,359
device which is here it's just mirrored

920
00:39:31,359 --> 00:39:33,119
on the screen

921
00:39:33,119 --> 00:39:34,720
while on the left

922
00:39:34,720 --> 00:39:37,359
you can see

923
00:39:37,440 --> 00:39:39,359
my

924
00:39:39,359 --> 00:39:41,839
command line which is from connected to

925
00:39:41,839 --> 00:39:43,119
a server

926
00:39:43,119 --> 00:39:45,440
this is uh actually the

927
00:39:45,440 --> 00:39:48,240
proof of concept i have sent to the

928
00:39:48,240 --> 00:39:50,480
telegram security team

929
00:39:50,480 --> 00:39:52,720
as you can see i can just

930
00:39:52,720 --> 00:39:55,200
define the uh

931
00:39:55,200 --> 00:39:56,720
pretty much

932
00:39:56,720 --> 00:40:00,160
recipient username and then the specific

933
00:40:00,160 --> 00:40:02,800
animated sticker i want to send

934
00:40:02,800 --> 00:40:06,640
so let's see if this works

935
00:40:06,800 --> 00:40:10,000
so as you can see on the um

936
00:40:10,000 --> 00:40:12,640
right part

937
00:40:12,800 --> 00:40:14,880
my script created a

938
00:40:14,880 --> 00:40:15,760
new

939
00:40:15,760 --> 00:40:18,640
secret chat and it was automatically

940
00:40:18,640 --> 00:40:21,040
accepted by the

941
00:40:21,040 --> 00:40:23,440
in this case the victim

942
00:40:23,440 --> 00:40:26,319
i don't know if you notice it but

943
00:40:26,319 --> 00:40:28,319
at the start of the demo i

944
00:40:28,319 --> 00:40:30,800
the my telegram contacts were shown and

945
00:40:30,800 --> 00:40:33,760
there were no contacts saved in telegram

946
00:40:33,760 --> 00:40:36,480
so this pollock one is actually a

947
00:40:36,480 --> 00:40:39,200
stranger for this specific

948
00:40:39,200 --> 00:40:40,800
recipient

949
00:40:40,800 --> 00:40:42,000
as you can see

950
00:40:42,000 --> 00:40:43,839
the secret chart was automatically

951
00:40:43,839 --> 00:40:45,200
accepted

952
00:40:45,200 --> 00:40:46,160
and

953
00:40:46,160 --> 00:40:48,560
if i

954
00:40:48,720 --> 00:40:50,720
i will just open lock cut so we can have

955
00:40:50,720 --> 00:40:53,839
a look at the

956
00:40:54,720 --> 00:40:57,200
logs

957
00:40:59,440 --> 00:41:02,400
okay if i click on the chart

958
00:41:02,400 --> 00:41:04,640
it will actually be

959
00:41:04,640 --> 00:41:08,400
passed and the

960
00:41:08,400 --> 00:41:10,960
recipient client will crash

961
00:41:10,960 --> 00:41:13,040
as you can see there was a segmentation

962
00:41:13,040 --> 00:41:15,920
fault during

963
00:41:16,240 --> 00:41:17,119
the

964
00:41:17,119 --> 00:41:20,319
access of memory in this specific case

965
00:41:20,319 --> 00:41:22,480
it was trying to write

966
00:41:22,480 --> 00:41:25,440
on a map of the ipo memory

967
00:41:25,440 --> 00:41:28,960
so of course it crashed

968
00:41:29,760 --> 00:41:30,960
so let's

969
00:41:30,960 --> 00:41:32,480
move back

970
00:41:32,480 --> 00:41:35,839
okay now

971
00:41:52,720 --> 00:41:54,400
okay

972
00:41:54,400 --> 00:41:55,920
so let's move to the

973
00:41:55,920 --> 00:41:57,040
to some

974
00:41:57,040 --> 00:41:59,760
uh exploit considerations

975
00:41:59,760 --> 00:42:01,760
so as i mentioned earlier the attack

976
00:42:01,760 --> 00:42:03,839
surface is only available in secret chat

977
00:42:03,839 --> 00:42:05,280
since

978
00:42:05,280 --> 00:42:07,760
apparently clear text chats are

979
00:42:07,760 --> 00:42:09,119
filtered

980
00:42:09,119 --> 00:42:11,359
moreover the telegram apis allow

981
00:42:11,359 --> 00:42:12,880
large-scale attacks from a single

982
00:42:12,880 --> 00:42:15,839
computer as we have seen in the demo

983
00:42:15,839 --> 00:42:18,000
i was able to just

984
00:42:18,000 --> 00:42:21,119
target any user i wanted through

985
00:42:21,119 --> 00:42:23,280
that specific script but of course you

986
00:42:23,280 --> 00:42:24,240
can

987
00:42:24,240 --> 00:42:25,839
scale it

988
00:42:25,839 --> 00:42:28,160
the specific

989
00:42:28,160 --> 00:42:30,960
out of bounds right issue we have

990
00:42:30,960 --> 00:42:33,359
analyzed is probably only exploitable on

991
00:42:33,359 --> 00:42:36,960
32-bit platform since it's just

992
00:42:36,960 --> 00:42:40,079
right of four bytes

993
00:42:40,079 --> 00:42:41,920
last but not least

994
00:42:41,920 --> 00:42:44,079
i couldn't find any remote inflict or

995
00:42:44,079 --> 00:42:46,800
memory problem oracle

996
00:42:46,800 --> 00:42:49,280
in order to bypass aslr which was the

997
00:42:49,280 --> 00:42:51,119
main problem

998
00:42:51,119 --> 00:42:52,640
in order to

999
00:42:52,640 --> 00:42:54,800
create an exploit from this specific

1000
00:42:54,800 --> 00:42:57,800
issues

1001
00:42:59,119 --> 00:43:00,800
i have also

1002
00:43:00,800 --> 00:43:02,720
wrote

1003
00:43:02,720 --> 00:43:05,680
some ideas i got after doing this

1004
00:43:05,680 --> 00:43:09,119
research that i can share with you which

1005
00:43:09,119 --> 00:43:11,119
can maybe

1006
00:43:11,119 --> 00:43:14,480
improve the results and lead to

1007
00:43:14,480 --> 00:43:17,599
additional issues so first

1008
00:43:17,599 --> 00:43:19,440
we could use the online offline

1009
00:43:19,440 --> 00:43:22,160
indicator as a memory problem oracle of

1010
00:43:22,160 --> 00:43:26,319
course this would require a very fast

1011
00:43:26,319 --> 00:43:28,560
crushing or non-crashing

1012
00:43:28,560 --> 00:43:29,520
state

1013
00:43:29,520 --> 00:43:32,640
which i didn't

1014
00:43:32,960 --> 00:43:35,200
study much

1015
00:43:35,200 --> 00:43:37,599
or we can craft for example a

1016
00:43:37,599 --> 00:43:39,760
polymorphic animated sticker which

1017
00:43:39,760 --> 00:43:42,800
passes the telegram api api checks for

1018
00:43:42,800 --> 00:43:44,000
validity

1019
00:43:44,000 --> 00:43:46,240
making clear text chats

1020
00:43:46,240 --> 00:43:47,839
vectors too because every time you

1021
00:43:47,839 --> 00:43:49,040
create a

1022
00:43:49,040 --> 00:43:51,440
sticker set the

1023
00:43:51,440 --> 00:43:53,520
sticker you want to add to the set is

1024
00:43:53,520 --> 00:43:54,960
actually

1025
00:43:54,960 --> 00:43:57,920
tested in the case of animated stickers

1026
00:43:57,920 --> 00:43:58,640
so

1027
00:43:58,640 --> 00:44:00,319
maybe there is a way to

1028
00:44:00,319 --> 00:44:02,400
create a malicious animated sticker

1029
00:44:02,400 --> 00:44:03,680
which

1030
00:44:03,680 --> 00:44:06,319
doesn't create problem on the telegram

1031
00:44:06,319 --> 00:44:08,640
api sides but creates problem on this

1032
00:44:08,640 --> 00:44:11,839
specific client

1033
00:44:11,839 --> 00:44:14,960
about this specific

1034
00:44:14,960 --> 00:44:16,400
issue

1035
00:44:16,400 --> 00:44:19,680
two ideas i got is to prove either as i

1036
00:44:19,680 --> 00:44:21,520
suppose that the

1037
00:44:21,520 --> 00:44:23,520
telegram apis are vulnerable to the same

1038
00:44:23,520 --> 00:44:26,079
issues in case they use the a lot the

1039
00:44:26,079 --> 00:44:28,319
same parser as in the clients so they

1040
00:44:28,319 --> 00:44:30,880
are not departure or

1041
00:44:30,880 --> 00:44:33,119
if they are using a different parser

1042
00:44:33,119 --> 00:44:35,440
find some partial differential issues

1043
00:44:35,440 --> 00:44:37,680
between those two parts so

1044
00:44:37,680 --> 00:44:40,000
find some additional issues in the

1045
00:44:40,000 --> 00:44:42,960
differences between the two parsers last

1046
00:44:42,960 --> 00:44:45,119
but not least skip

1047
00:44:45,119 --> 00:44:48,240
inside the fuzzing process the protobuf2

1048
00:44:48,240 --> 00:44:51,839
json conversion since

1049
00:44:52,079 --> 00:44:55,200
the fuzzing process might actually be

1050
00:44:55,200 --> 00:44:57,280
faster this way

1051
00:44:57,280 --> 00:45:00,160
but as i mentioned in the slider

1052
00:45:00,160 --> 00:45:01,920
there could be like

1053
00:45:01,920 --> 00:45:04,319
self bugs as in bugs that you actually

1054
00:45:04,319 --> 00:45:07,280
introduce by skipping

1055
00:45:07,280 --> 00:45:10,960
steps in the real

1056
00:45:10,960 --> 00:45:13,440
in the real case so they might lead to

1057
00:45:13,440 --> 00:45:14,960
some

1058
00:45:14,960 --> 00:45:16,400
problems there

1059
00:45:16,400 --> 00:45:18,720
another thing to mention here is that uh

1060
00:45:18,720 --> 00:45:21,599
uh since i added the proof that the

1061
00:45:21,599 --> 00:45:25,200
telegrams api are vulnerable too because

1062
00:45:25,200 --> 00:45:26,880
uh

1063
00:45:26,880 --> 00:45:29,119
at this time the telegrams server code

1064
00:45:29,119 --> 00:45:31,680
is closest source so we can't really

1065
00:45:31,680 --> 00:45:33,040
just

1066
00:45:33,040 --> 00:45:34,720
have a look at the code like for the

1067
00:45:34,720 --> 00:45:36,800
clients

1068
00:45:36,800 --> 00:45:38,480
so let's move to the

1069
00:45:38,480 --> 00:45:42,079
closing remarks for this presentation

1070
00:45:42,079 --> 00:45:44,400
first

1071
00:45:44,400 --> 00:45:47,920
since telegram not only fixed my

1072
00:45:47,920 --> 00:45:50,079
memory corruptions they also

1073
00:45:50,079 --> 00:45:53,040
implemented some additional protections

1074
00:45:53,040 --> 00:45:55,119
one of these is uh

1075
00:45:55,119 --> 00:45:57,599
containing this specific

1076
00:45:57,599 --> 00:46:01,520
code snippet which as you can see

1077
00:46:01,520 --> 00:46:04,800
it will try to check that actually the

1078
00:46:04,800 --> 00:46:06,880
animated sticker that you have received

1079
00:46:06,880 --> 00:46:10,480
is part of a public sticker set so

1080
00:46:10,480 --> 00:46:11,920
you will not

1081
00:46:11,920 --> 00:46:13,520
be able

1082
00:46:13,520 --> 00:46:16,240
uh thanks to this code

1083
00:46:16,240 --> 00:46:18,880
apparently to uh send the custom

1084
00:46:18,880 --> 00:46:21,280
animated stickers because even if they

1085
00:46:21,280 --> 00:46:23,760
were received on the recipient part they

1086
00:46:23,760 --> 00:46:25,520
would not be parsed and the renderers

1087
00:46:25,520 --> 00:46:26,480
since

1088
00:46:26,480 --> 00:46:28,960
they will check that they are actually

1089
00:46:28,960 --> 00:46:30,240
part of a

1090
00:46:30,240 --> 00:46:32,319
sticker sticker pack which allows them

1091
00:46:32,319 --> 00:46:34,720
to keep animated stickers in the secret

1092
00:46:34,720 --> 00:46:36,400
chats

1093
00:46:36,400 --> 00:46:39,119
as a feature

1094
00:46:39,200 --> 00:46:40,319
so

1095
00:46:40,319 --> 00:46:43,839
after this defensive depth measure you

1096
00:46:43,839 --> 00:46:46,000
not only need to find additional issues

1097
00:46:46,000 --> 00:46:48,800
in the arlotti library but you also need

1098
00:46:48,800 --> 00:46:49,680
to

1099
00:46:49,680 --> 00:46:53,200
uh bypass this specific check which in

1100
00:46:53,200 --> 00:46:56,079
my opinion was introduced because uh in

1101
00:46:56,079 --> 00:46:59,599
my proof of concept i faked the

1102
00:46:59,599 --> 00:47:02,800
sticker sets references because they he

1103
00:47:02,800 --> 00:47:04,240
actually

1104
00:47:04,240 --> 00:47:05,790
checked that

1105
00:47:05,790 --> 00:47:06,880
[Music]

1106
00:47:06,880 --> 00:47:09,040
once the animated sticker was

1107
00:47:09,040 --> 00:47:11,599
received he had the attributes of the

1108
00:47:11,599 --> 00:47:13,760
sticker set but they didn't actually

1109
00:47:13,760 --> 00:47:15,280
check that they were

1110
00:47:15,280 --> 00:47:17,680
really part of those speaker sets and in

1111
00:47:17,680 --> 00:47:21,839
the end they added this this new code

1112
00:47:22,559 --> 00:47:25,359
another uh option the

1113
00:47:25,359 --> 00:47:28,000
uh introduced is this uh filter a new

1114
00:47:28,000 --> 00:47:30,319
chart from non-contacts which is not

1115
00:47:30,319 --> 00:47:32,880
enabled by default so probably most

1116
00:47:32,880 --> 00:47:36,000
probably uh most users do not have it

1117
00:47:36,000 --> 00:47:39,359
enabled but basically what it does is

1118
00:47:39,359 --> 00:47:40,720
it will

1119
00:47:40,720 --> 00:47:43,440
archive and mute new chats coming from

1120
00:47:43,440 --> 00:47:47,599
non-contact so in this case

1121
00:47:47,599 --> 00:47:49,839
there will not be the risk of you

1122
00:47:49,839 --> 00:47:52,559
clicking on the chat or the malicious

1123
00:47:52,559 --> 00:47:54,960
sticker automatically being parsed and

1124
00:47:54,960 --> 00:47:56,880
rendered because they will be

1125
00:47:56,880 --> 00:47:59,440
non-available directly in the user

1126
00:47:59,440 --> 00:48:01,920
interface

1127
00:48:03,359 --> 00:48:05,520
some specific details of the patched

1128
00:48:05,520 --> 00:48:07,920
releases as you can see they are just

1129
00:48:07,920 --> 00:48:09,920
the official clients

1130
00:48:09,920 --> 00:48:11,119
and the

1131
00:48:11,119 --> 00:48:15,359
windows one for example is missing since

1132
00:48:15,520 --> 00:48:17,119
because of

1133
00:48:17,119 --> 00:48:19,760
the need of a secret chat environment

1134
00:48:19,760 --> 00:48:20,640
the

1135
00:48:20,640 --> 00:48:21,680
windows

1136
00:48:21,680 --> 00:48:23,280
client at the time

1137
00:48:23,280 --> 00:48:25,680
uh didn't support secret shots so i i

1138
00:48:25,680 --> 00:48:26,960
didn't even

1139
00:48:26,960 --> 00:48:29,440
test it because as i mentioned earlier

1140
00:48:29,440 --> 00:48:31,359
apparently they are filtering clear text

1141
00:48:31,359 --> 00:48:35,440
charts so it's not really uh

1142
00:48:35,440 --> 00:48:38,079
vulnerable as in you can't exploit it

1143
00:48:38,079 --> 00:48:40,000
probably the library is vulnerable but

1144
00:48:40,000 --> 00:48:43,760
you can't really reach it

1145
00:48:45,680 --> 00:48:47,599
last point

1146
00:48:47,599 --> 00:48:50,480
that is pretty much a really

1147
00:48:50,480 --> 00:48:53,280
long-standing debate between the user

1148
00:48:53,280 --> 00:48:56,640
experience and the security defaults

1149
00:48:56,640 --> 00:48:58,880
my personal experience with this

1150
00:48:58,880 --> 00:49:01,280
research is that

1151
00:49:01,280 --> 00:49:03,599
telegram really

1152
00:49:03,599 --> 00:49:06,240
cares about user experience and not

1153
00:49:06,240 --> 00:49:08,400
really much about uh

1154
00:49:08,400 --> 00:49:10,480
security because as we have seen there

1155
00:49:10,480 --> 00:49:11,760
are some

1156
00:49:11,760 --> 00:49:13,520
protection that

1157
00:49:13,520 --> 00:49:15,599
were included

1158
00:49:15,599 --> 00:49:17,200
only after

1159
00:49:17,200 --> 00:49:18,400
some issues

1160
00:49:18,400 --> 00:49:19,440
or

1161
00:49:19,440 --> 00:49:21,200
they introduced some features for

1162
00:49:21,200 --> 00:49:22,960
example the animated stickers without

1163
00:49:22,960 --> 00:49:26,000
really much testing or in this case

1164
00:49:26,000 --> 00:49:28,480
fuzzing

1165
00:49:29,359 --> 00:49:31,680
so thank you for uh

1166
00:49:31,680 --> 00:49:33,200
listening to my

1167
00:49:33,200 --> 00:49:34,400
talk

1168
00:49:34,400 --> 00:49:35,280
uh

1169
00:49:35,280 --> 00:49:36,400
i will be

1170
00:49:36,400 --> 00:49:39,599
available for some questions now uh in

1171
00:49:39,599 --> 00:49:41,440
any case you can find me on twitter at

1172
00:49:41,440 --> 00:49:43,040
pollock underscore

1173
00:49:43,040 --> 00:49:45,119
and you can keep up with our researches

1174
00:49:45,119 --> 00:49:45,960
at

1175
00:49:45,960 --> 00:49:47,760
schielder.if

1176
00:49:47,760 --> 00:49:50,350
thank you

1177
00:49:50,350 --> 00:49:53,739
[Applause]

