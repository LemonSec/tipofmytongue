1
00:00:06,000 --> 00:00:07,600
hello everyone and welcome to my

2
00:00:07,600 --> 00:00:10,320
presentation i'm sebastian

3
00:00:10,320 --> 00:00:13,120
and you might have seen me before in

4
00:00:13,120 --> 00:00:15,679
passwords con presentations notably

5
00:00:15,679 --> 00:00:18,320
around the wikipedia world list which i

6
00:00:18,320 --> 00:00:20,560
still intend to improve with ai

7
00:00:20,560 --> 00:00:22,560
technology at some point i'm just

8
00:00:22,560 --> 00:00:24,000
learning little by little because it's

9
00:00:24,000 --> 00:00:26,240
not my field

10
00:00:26,240 --> 00:00:28,320
particularly neural networks as i was

11
00:00:28,320 --> 00:00:30,400
presenting here at the university of

12
00:00:30,400 --> 00:00:33,200
cambridge to isolate words that are not

13
00:00:33,200 --> 00:00:34,960
made just of letters but something like

14
00:00:34,960 --> 00:00:39,600
dot four five s ampersand w as in the 45

15
00:00:39,600 --> 00:00:41,680
smith and wesson caliber if someone were

16
00:00:41,680 --> 00:00:43,840
to use that as part of their password or

17
00:00:43,840 --> 00:00:45,280
passphrase

18
00:00:45,280 --> 00:00:47,840
so i'm learning about all those new

19
00:00:47,840 --> 00:00:50,320
neural network technologies but i got an

20
00:00:50,320 --> 00:00:52,640
even better one just recently called zoe

21
00:00:52,640 --> 00:00:54,399
who is awesome and she's now my number

22
00:00:54,399 --> 00:00:56,399
one priority

23
00:00:56,399 --> 00:00:58,000
i work for a great company called

24
00:00:58,000 --> 00:01:00,719
digital 14 where we take security as

25
00:01:00,719 --> 00:01:02,480
seriously as possible going to the

26
00:01:02,480 --> 00:01:05,680
extent of for example melting the

27
00:01:05,680 --> 00:01:08,640
case of chips the packaging of chips

28
00:01:08,640 --> 00:01:10,880
decapping the surface adding all sorts

29
00:01:10,880 --> 00:01:13,360
of probe poking at them with lasers

30
00:01:13,360 --> 00:01:15,200
messing with the power

31
00:01:15,200 --> 00:01:18,159
all sorts of electromagnetic attacks and

32
00:01:18,159 --> 00:01:20,560
that's just the hardware lab actually uh

33
00:01:20,560 --> 00:01:22,880
as part of xenith labs so we try to

34
00:01:22,880 --> 00:01:24,799
evaluate security products from all

35
00:01:24,799 --> 00:01:27,360
possible angles to see if there are any

36
00:01:27,360 --> 00:01:29,280
secure at all or what level of security

37
00:01:29,280 --> 00:01:30,479
they provide

38
00:01:30,479 --> 00:01:32,479
and for example if you have a hardware

39
00:01:32,479 --> 00:01:35,600
security module which is supposed to

40
00:01:35,600 --> 00:01:36,960
keep

41
00:01:36,960 --> 00:01:38,960
aes key in hardware for example and

42
00:01:38,960 --> 00:01:40,640
making it impossible for someone to

43
00:01:40,640 --> 00:01:42,640
extract it while we would mess with this

44
00:01:42,640 --> 00:01:44,640
power see how it reacts things like that

45
00:01:44,640 --> 00:01:46,479
and analyze the signals that would be my

46
00:01:46,479 --> 00:01:48,479
team for example and

47
00:01:48,479 --> 00:01:50,240
be able sometimes to extract the

48
00:01:50,240 --> 00:01:51,840
encryption key which is not supposed to

49
00:01:51,840 --> 00:01:53,600
be possible with the hsm hardware

50
00:01:53,600 --> 00:01:56,079
security module

51
00:01:56,079 --> 00:01:57,920
so being lucky to work in that sort of

52
00:01:57,920 --> 00:02:00,719
environment i also participate in client

53
00:02:00,719 --> 00:02:02,159
server designs

54
00:02:02,159 --> 00:02:05,280
in the ideal world basically so we do

55
00:02:05,280 --> 00:02:07,520
everything from supply chain risk

56
00:02:07,520 --> 00:02:10,000
management where we can even kind of

57
00:02:10,000 --> 00:02:11,599
force factories to improve their

58
00:02:11,599 --> 00:02:13,760
security to not make it so easy to put

59
00:02:13,760 --> 00:02:16,400
back doors in equipment from the factory

60
00:02:16,400 --> 00:02:18,640
uh hardware assurances so that's putting

61
00:02:18,640 --> 00:02:20,879
equipment that you receive and the x-ray

62
00:02:20,879 --> 00:02:22,720
machine for example looking for any

63
00:02:22,720 --> 00:02:25,200
suspicious addition of a chip like you

64
00:02:25,200 --> 00:02:27,120
might have heard of with the super micro

65
00:02:27,120 --> 00:02:29,120
stories and things like that or just

66
00:02:29,120 --> 00:02:31,120
counterfeit chips which happens quite

67
00:02:31,120 --> 00:02:32,720
often actually

68
00:02:32,720 --> 00:02:34,400
software assurance

69
00:02:34,400 --> 00:02:37,040
which is um kind of like code review but

70
00:02:37,040 --> 00:02:39,280
taken to the extreme so you probably

71
00:02:39,280 --> 00:02:41,120
heard sometimes that governments are

72
00:02:41,120 --> 00:02:43,040
asking microsoft to show them the source

73
00:02:43,040 --> 00:02:45,920
of windows and then microsoft welcomes

74
00:02:45,920 --> 00:02:48,160
them to redmond to look at the source of

75
00:02:48,160 --> 00:02:50,560
windows on their own computers there i

76
00:02:50,560 --> 00:02:53,040
mean the microsoft computers which is

77
00:02:53,040 --> 00:02:55,120
kind of proving nothing then because you

78
00:02:55,120 --> 00:02:56,560
don't know if you're looking at the real

79
00:02:56,560 --> 00:02:58,879
thing so that's all the considerations

80
00:02:58,879 --> 00:03:01,200
of software assurance then

81
00:03:01,200 --> 00:03:03,280
once you have all of these

82
00:03:03,280 --> 00:03:06,159
statist factories so that you

83
00:03:06,159 --> 00:03:08,400
are expecting at least something usable

84
00:03:08,400 --> 00:03:10,560
out of what you have received you then

85
00:03:10,560 --> 00:03:12,640
would start with local attestation which

86
00:03:12,640 --> 00:03:15,120
is all of the technologies like secure

87
00:03:15,120 --> 00:03:17,360
trusted boots taking it to the extreme

88
00:03:17,360 --> 00:03:19,519
with things like linux integrity

89
00:03:19,519 --> 00:03:21,760
measurement architecture and maybe some

90
00:03:21,760 --> 00:03:23,840
newer ones like intel software guard

91
00:03:23,840 --> 00:03:25,120
extensions or something like that i

92
00:03:25,120 --> 00:03:27,680
haven't looked into that one but linux

93
00:03:27,680 --> 00:03:30,159
ima is already very good

94
00:03:30,159 --> 00:03:32,080
mutual authentication so that's a

95
00:03:32,080 --> 00:03:34,159
nothing new actually but it seems to be

96
00:03:34,159 --> 00:03:36,319
more in fashion now it's basically not

97
00:03:36,319 --> 00:03:38,560
having only server certificates but also

98
00:03:38,560 --> 00:03:40,799
client certificates so that clients and

99
00:03:40,799 --> 00:03:43,040
servers can mutually authenticate each

100
00:03:43,040 --> 00:03:45,280
other and now that you have

101
00:03:45,280 --> 00:03:47,120
the two the previous two then you can

102
00:03:47,120 --> 00:03:48,560
even do something called remote

103
00:03:48,560 --> 00:03:51,360
attestation which is for example asking

104
00:03:51,360 --> 00:03:54,000
the trusted platform module tpm which is

105
00:03:54,000 --> 00:03:56,640
kind of like a third-party observer

106
00:03:56,640 --> 00:03:58,319
on the other side so you're connecting

107
00:03:58,319 --> 00:04:00,080
to a remote computer and you want to

108
00:04:00,080 --> 00:04:01,280
make sure that

109
00:04:01,280 --> 00:04:03,040
it's running actually what you think it

110
00:04:03,040 --> 00:04:05,280
is running so that's how you can do that

111
00:04:05,280 --> 00:04:07,680
with the remote attestation you can ask

112
00:04:07,680 --> 00:04:09,519
the tpm on the other side to provide you

113
00:04:09,519 --> 00:04:11,200
a digital signature of the state of the

114
00:04:11,200 --> 00:04:13,840
machine on the other

115
00:04:13,840 --> 00:04:16,000
but in the real world actually i have

116
00:04:16,000 --> 00:04:17,839
much admiration for the rest of the

117
00:04:17,839 --> 00:04:19,918
security industry who has to deal with

118
00:04:19,918 --> 00:04:22,160
characters like dave here in this comic

119
00:04:22,160 --> 00:04:24,400
who would choose a password like dave is

120
00:04:24,400 --> 00:04:26,639
the best change the letter e to the

121
00:04:26,639 --> 00:04:28,639
number three change the letter i to an

122
00:04:28,639 --> 00:04:30,400
exclamation mark and that looks like a

123
00:04:30,400 --> 00:04:32,160
very strong password so let's use it

124
00:04:32,160 --> 00:04:34,000
everywhere

125
00:04:34,000 --> 00:04:37,520
um also even me personally just

126
00:04:37,520 --> 00:04:39,440
by lack of space for example i cannot

127
00:04:39,440 --> 00:04:41,360
put a server room in my flat or

128
00:04:41,360 --> 00:04:43,520
something like that i might do my hobby

129
00:04:43,520 --> 00:04:45,360
projects with a raspberry pi but here

130
00:04:45,360 --> 00:04:47,360
it's just a symbolism

131
00:04:47,360 --> 00:04:48,960
that

132
00:04:48,960 --> 00:04:51,520
most or many projects even from a small

133
00:04:51,520 --> 00:04:52,880
company or something like that would be

134
00:04:52,880 --> 00:04:55,120
running on a vps like a virtual machine

135
00:04:55,120 --> 00:04:57,440
that you're renting for cheap from some

136
00:04:57,440 --> 00:05:00,080
cloud provider so the idea here is

137
00:05:00,080 --> 00:05:01,520
basically that it doesn't have much

138
00:05:01,520 --> 00:05:02,960
power

139
00:05:02,960 --> 00:05:05,039
then especially if you're running it

140
00:05:05,039 --> 00:05:06,800
from home you would hide it behind the

141
00:05:06,800 --> 00:05:09,120
service like cloudflare which is a

142
00:05:09,120 --> 00:05:11,039
exposing their ip address instead of

143
00:05:11,039 --> 00:05:13,280
yours to the internet and as much as i

144
00:05:13,280 --> 00:05:14,880
really like cloudflare and believe that

145
00:05:14,880 --> 00:05:17,120
they take security seriously you have to

146
00:05:17,120 --> 00:05:19,360
keep in mind that in most of the cases

147
00:05:19,360 --> 00:05:21,360
actually they are decrypting and

148
00:05:21,360 --> 00:05:23,280
re-encrypting the traffic so when

149
00:05:23,280 --> 00:05:25,360
someone is visiting your website even if

150
00:05:25,360 --> 00:05:27,919
it's called https colon slash something

151
00:05:27,919 --> 00:05:30,880
something uh it's https only up to

152
00:05:30,880 --> 00:05:32,800
cloudflare where it's decrypted and then

153
00:05:32,800 --> 00:05:35,440
there might be another https connection

154
00:05:35,440 --> 00:05:37,120
to your home or even a clear text one

155
00:05:37,120 --> 00:05:39,039
depending on how you set it up it's

156
00:05:39,039 --> 00:05:40,479
possible of course to have it all the

157
00:05:40,479 --> 00:05:42,320
way but that's as far as i checked the

158
00:05:42,320 --> 00:05:44,000
result for enterprise clients of

159
00:05:44,000 --> 00:05:45,120
cloudflare

160
00:05:45,120 --> 00:05:47,440
and again it's just an example so i'm

161
00:05:47,440 --> 00:05:49,600
not blaming cloudflare here and

162
00:05:49,600 --> 00:05:52,320
it can be the same idea with some other

163
00:05:52,320 --> 00:05:54,320
cloud providers

164
00:05:54,320 --> 00:05:57,199
and it's not so much of a risk

165
00:05:57,199 --> 00:05:59,520
here but you hear every once in a while

166
00:05:59,520 --> 00:06:01,520
of some companies even facebook i think

167
00:06:01,520 --> 00:06:04,080
it was a couple of years ago where some

168
00:06:04,080 --> 00:06:06,240
developer or some admin mistakenly

169
00:06:06,240 --> 00:06:08,800
enabled some debug logs and everyone's

170
00:06:08,800 --> 00:06:11,520
passwords were being written into logs

171
00:06:11,520 --> 00:06:14,400
so that's what might happen here so we

172
00:06:14,400 --> 00:06:16,720
might we have to keep in mind that then

173
00:06:16,720 --> 00:06:18,560
your visitors passwords might be written

174
00:06:18,560 --> 00:06:20,560
to some logs here unintentionally so it

175
00:06:20,560 --> 00:06:22,720
would be better to have really some sort

176
00:06:22,720 --> 00:06:25,120
of end-to-end encryption

177
00:06:25,120 --> 00:06:26,880
and then the thing that you see quite

178
00:06:26,880 --> 00:06:27,759
often

179
00:06:27,759 --> 00:06:30,479
is for corporate visitors so someone who

180
00:06:30,479 --> 00:06:32,960
might visit your project from their work

181
00:06:32,960 --> 00:06:35,199
set up so they have like a work laptop

182
00:06:35,199 --> 00:06:37,520
which in itself nowadays is fairly

183
00:06:37,520 --> 00:06:40,160
powerful actually what happens is that

184
00:06:40,160 --> 00:06:42,400
they are usually or quite commonly put

185
00:06:42,400 --> 00:06:44,639
behind some sort of web security

186
00:06:44,639 --> 00:06:47,440
appliance which is actually doing even

187
00:06:47,440 --> 00:06:49,599
worse is actually doing a money in the

188
00:06:49,599 --> 00:06:52,479
middle attack against that https traffic

189
00:06:52,479 --> 00:06:55,039
but cooperatively with the permission of

190
00:06:55,039 --> 00:06:58,080
it the problem being however that it's

191
00:06:58,080 --> 00:07:00,800
so easy to hack so many company networks

192
00:07:00,800 --> 00:07:02,240
if you've done some pen testing you know

193
00:07:02,240 --> 00:07:03,840
how easy it can be most of the time

194
00:07:03,840 --> 00:07:06,160
really to the point of getting boring

195
00:07:06,160 --> 00:07:07,039
so

196
00:07:07,039 --> 00:07:09,520
when you when those company networks are

197
00:07:09,520 --> 00:07:11,680
so easy to hack then it's not a question

198
00:07:11,680 --> 00:07:13,840
anymore of just being able to

199
00:07:13,840 --> 00:07:15,440
for the attacker to access all the

200
00:07:15,440 --> 00:07:17,360
company intellectual property but then

201
00:07:17,360 --> 00:07:19,919
the attackers are even able to accept

202
00:07:19,919 --> 00:07:22,720
to access people's bank account or

203
00:07:22,720 --> 00:07:25,360
whatever private information that

204
00:07:25,360 --> 00:07:26,960
people might be accessing from their

205
00:07:26,960 --> 00:07:28,720
work laptop during the lunch break for

206
00:07:28,720 --> 00:07:30,880
example because of this

207
00:07:30,880 --> 00:07:33,599
very dangerous practice

208
00:07:33,599 --> 00:07:34,560
then

209
00:07:34,560 --> 00:07:36,880
visitors from home might visit your

210
00:07:36,880 --> 00:07:39,039
website with a gaming pc for example

211
00:07:39,039 --> 00:07:40,800
which is vastly more powerful than your

212
00:07:40,800 --> 00:07:43,520
raspberry pi or the vps and just in

213
00:07:43,520 --> 00:07:45,280
general you have all sorts of visitors

214
00:07:45,280 --> 00:07:46,879
on the go with

215
00:07:46,879 --> 00:07:49,039
flagship phones also which are very very

216
00:07:49,039 --> 00:07:51,599
powerful nowadays

217
00:07:51,599 --> 00:07:53,759
so to put all of this into perspective

218
00:07:53,759 --> 00:07:56,800
um let's talk about different categories

219
00:07:56,800 --> 00:07:59,280
of hardware so the absolute unit of

220
00:07:59,280 --> 00:08:02,240
performance is the asic the application

221
00:08:02,240 --> 00:08:03,919
specific integrated circuit so it's

222
00:08:03,919 --> 00:08:06,080
basically you take an algorithm and you

223
00:08:06,080 --> 00:08:09,199
hardwire it you put atoms on a

224
00:08:09,199 --> 00:08:10,800
circuit board i mean you mean you make

225
00:08:10,800 --> 00:08:13,039
the pcb out of it and

226
00:08:13,039 --> 00:08:15,680
this circuit board is capable of doing

227
00:08:15,680 --> 00:08:16,720
only

228
00:08:16,720 --> 00:08:18,960
only this algorithm and nothing else

229
00:08:18,960 --> 00:08:20,879
however it's the absolute fastest that

230
00:08:20,879 --> 00:08:22,960
doing it so it's kind of like this land

231
00:08:22,960 --> 00:08:25,520
speed record-breaking car that doesn't

232
00:08:25,520 --> 00:08:27,280
even look like a car anymore it's not

233
00:08:27,280 --> 00:08:29,280
really possible to call it a car it

234
00:08:29,280 --> 00:08:31,039
cannot even take turns or whatever it's

235
00:08:31,039 --> 00:08:33,279
the absolute fastest but definitely not

236
00:08:33,279 --> 00:08:34,720
practical

237
00:08:34,720 --> 00:08:36,000
[Music]

238
00:08:36,000 --> 00:08:38,159
so in general you would have something

239
00:08:38,159 --> 00:08:40,320
more commonly called the fpga a field

240
00:08:40,320 --> 00:08:42,799
programmable gateway which is

241
00:08:42,799 --> 00:08:44,959
not yet a cheap in the sense that you

242
00:08:44,959 --> 00:08:46,240
might think it's more like a

243
00:08:46,240 --> 00:08:48,720
virtualization of the previous one so

244
00:08:48,720 --> 00:08:51,440
you still have to design this printed

245
00:08:51,440 --> 00:08:53,200
circuit board but instead of

246
00:08:53,200 --> 00:08:55,839
manufacturing it it's virtualized within

247
00:08:55,839 --> 00:08:56,640
this

248
00:08:56,640 --> 00:08:59,760
fpga machine and so it's kind of like a

249
00:08:59,760 --> 00:09:02,160
formula one but already it's much more

250
00:09:02,160 --> 00:09:03,760
practical because you can do more things

251
00:09:03,760 --> 00:09:05,920
with it you can take turns in terms of

252
00:09:05,920 --> 00:09:07,040
driving

253
00:09:07,040 --> 00:09:10,080
but you can also replace all the time in

254
00:09:10,080 --> 00:09:11,760
your fpga you can put different

255
00:09:11,760 --> 00:09:14,560
algorithms so typically in pen testing

256
00:09:14,560 --> 00:09:16,000
for example you might use this sort of

257
00:09:16,000 --> 00:09:18,320
hardware from scientists and you don't

258
00:09:18,320 --> 00:09:20,560
want to be able to crack only one sort

259
00:09:20,560 --> 00:09:22,399
of algorithms depending on the pen test

260
00:09:22,399 --> 00:09:23,440
you know that

261
00:09:23,440 --> 00:09:25,120
depending on the target it's a different

262
00:09:25,120 --> 00:09:27,440
sorts of algorithms so it's very useful

263
00:09:27,440 --> 00:09:29,680
to be able to just swap them in and out

264
00:09:29,680 --> 00:09:32,959
of your hardware and this is

265
00:09:32,959 --> 00:09:35,440
still very very fast it's not as fast as

266
00:09:35,440 --> 00:09:38,320
the asic but still very fast much faster

267
00:09:38,320 --> 00:09:40,720
than gpus for example

268
00:09:40,720 --> 00:09:42,240
or it depends but

269
00:09:42,240 --> 00:09:44,640
in many cases it's much faster so in

270
00:09:44,640 --> 00:09:46,320
general then you would have your

271
00:09:46,320 --> 00:09:48,800
everyday computer but if you want to

272
00:09:48,800 --> 00:09:49,760
have the

273
00:09:49,760 --> 00:09:51,760
maximum performance out of you would

274
00:09:51,760 --> 00:09:54,080
program in assembly or c for example to

275
00:09:54,080 --> 00:09:56,880
get as close to the hardware as possible

276
00:09:56,880 --> 00:09:58,560
and um

277
00:09:58,560 --> 00:09:59,920
it's

278
00:09:59,920 --> 00:10:02,000
much slower already it's kind of like

279
00:10:02,000 --> 00:10:03,760
this everyday car that you can take to

280
00:10:03,760 --> 00:10:06,000
the supermarket you can take to work and

281
00:10:06,000 --> 00:10:08,320
so on but it's all of that at the cost

282
00:10:08,320 --> 00:10:10,079
of performance so it's great in terms of

283
00:10:10,079 --> 00:10:12,560
versatility but it's already far slower

284
00:10:12,560 --> 00:10:14,720
than the previous two

285
00:10:14,720 --> 00:10:17,680
and now you have a gpu so graphical

286
00:10:17,680 --> 00:10:20,959
processing units which is like the main

287
00:10:20,959 --> 00:10:23,040
part of a graphics card as you can see

288
00:10:23,040 --> 00:10:24,800
on the left typically now in gaming

289
00:10:24,800 --> 00:10:26,880
computers and usually the most expensive

290
00:10:26,880 --> 00:10:29,120
part of a computer nowadays or at least

291
00:10:29,120 --> 00:10:30,560
like a gaming one

292
00:10:30,560 --> 00:10:33,279
and it's actually slower than a cpu by

293
00:10:33,279 --> 00:10:35,279
itself but it's more like a freight

294
00:10:35,279 --> 00:10:37,600
train so the freight train is probably

295
00:10:37,600 --> 00:10:39,839
slower than the car but it's pulling so

296
00:10:39,839 --> 00:10:42,079
many carriages behind it that it's more

297
00:10:42,079 --> 00:10:43,600
powerful than a car in terms of

298
00:10:43,600 --> 00:10:45,200
delivering goods to a particular

299
00:10:45,200 --> 00:10:46,640
destination so it's the same with the

300
00:10:46,640 --> 00:10:49,680
gpu where as long as it's doing

301
00:10:49,680 --> 00:10:52,079
everything exactly the same then it's

302
00:10:52,079 --> 00:10:54,560
faster than a cpu so just to give you a

303
00:10:54,560 --> 00:10:57,200
rough example it's not a comparable like

304
00:10:57,200 --> 00:10:59,760
apples to apples but just roughly

305
00:10:59,760 --> 00:11:00,640
you can

306
00:11:00,640 --> 00:11:03,519
see that in a gpu there are nowadays 4

307
00:11:03,519 --> 00:11:06,079
000 costs so it means that you can just

308
00:11:06,079 --> 00:11:08,560
in one go try four different possible

309
00:11:08,560 --> 00:11:10,640
passwords to see if one of them cracks

310
00:11:10,640 --> 00:11:12,399
the target hash that you are trying to

311
00:11:12,399 --> 00:11:14,640
crack as opposed to even the most

312
00:11:14,640 --> 00:11:17,920
expensive cpu nowadays has like 32 or 64

313
00:11:17,920 --> 00:11:20,560
cores so cpu is nothing in terms of

314
00:11:20,560 --> 00:11:24,000
password cracking compared to a gpu

315
00:11:24,000 --> 00:11:26,959
then going deeper into um

316
00:11:26,959 --> 00:11:29,120
or higher into levels of abstraction and

317
00:11:29,120 --> 00:11:30,800
the apologies apparently that slide

318
00:11:30,800 --> 00:11:32,880
disappeared from the internet but it was

319
00:11:32,880 --> 00:11:35,519
a good example uh about java which

320
00:11:35,519 --> 00:11:37,839
popularized this idea of bytecode which

321
00:11:37,839 --> 00:11:41,200
is kind of like emulating uh imaginary

322
00:11:41,200 --> 00:11:43,200
chip that doesn't exist so if you look

323
00:11:43,200 --> 00:11:45,279
at the leftmost bar in that bar chart

324
00:11:45,279 --> 00:11:47,279
that was going to be the performance of

325
00:11:47,279 --> 00:11:48,720
the pico java

326
00:11:48,720 --> 00:11:51,040
chip that they were considering making

327
00:11:51,040 --> 00:11:53,839
at some point as a real world chip

328
00:11:53,839 --> 00:11:54,959
but

329
00:11:54,959 --> 00:11:57,120
in the end it wasn't worth really

330
00:11:57,120 --> 00:11:59,279
commercially so it didn't really happen

331
00:11:59,279 --> 00:12:01,120
but compared to the other bars on the

332
00:12:01,120 --> 00:12:03,680
chart you can see that um the rest of

333
00:12:03,680 --> 00:12:06,160
the computers so pcs at the time with

334
00:12:06,160 --> 00:12:08,639
pension chips or nowadays your phone

335
00:12:08,639 --> 00:12:10,320
even though it has a little bit of a

336
00:12:10,320 --> 00:12:13,279
java acceleration it's uh already much

337
00:12:13,279 --> 00:12:15,760
lower than if it was running real code

338
00:12:15,760 --> 00:12:18,240
as in native code so it's kind of like

339
00:12:18,240 --> 00:12:20,240
this golf cart in the sense that it's a

340
00:12:20,240 --> 00:12:21,600
car but it's not really in its

341
00:12:21,600 --> 00:12:23,760
environment so it's not very fast

342
00:12:23,760 --> 00:12:26,320
and then finally there is a scripting as

343
00:12:26,320 --> 00:12:28,240
in javascript for example is probably

344
00:12:28,240 --> 00:12:30,000
the most common language maybe even more

345
00:12:30,000 --> 00:12:33,040
than spoken languages nowadays and

346
00:12:33,040 --> 00:12:35,279
it's great in the sense of everyone can

347
00:12:35,279 --> 00:12:37,760
do it so it's like this toy car everyone

348
00:12:37,760 --> 00:12:39,760
can drive it and you can still do really

349
00:12:39,760 --> 00:12:41,440
cool things with it like this toy car is

350
00:12:41,440 --> 00:12:43,760
in a mclaren but

351
00:12:43,760 --> 00:12:46,399
in terms of performance you see it's far

352
00:12:46,399 --> 00:12:49,839
far slower than everything else

353
00:12:49,839 --> 00:12:52,240
so just in terms of very rough order of

354
00:12:52,240 --> 00:12:54,560
magnitudes because it's again not an

355
00:12:54,560 --> 00:12:56,959
apple to apple comparison because even

356
00:12:56,959 --> 00:12:59,120
with performance per watt or performance

357
00:12:59,120 --> 00:13:01,920
per dollar things etc it all depends on

358
00:13:01,920 --> 00:13:04,240
what chips you choose what sort of

359
00:13:04,240 --> 00:13:06,240
hardware architecture what sort of

360
00:13:06,240 --> 00:13:08,079
attackers you have in mind like teenage

361
00:13:08,079 --> 00:13:09,920
hackers or nation state actors or

362
00:13:09,920 --> 00:13:11,040
whatever

363
00:13:11,040 --> 00:13:13,680
but just very roughly speaking uh you

364
00:13:13,680 --> 00:13:15,440
would have the defenders using

365
00:13:15,440 --> 00:13:17,680
technologies on the left not having a

366
00:13:17,680 --> 00:13:19,519
fighting chance against the attackers

367
00:13:19,519 --> 00:13:21,680
with the technologies on the right and

368
00:13:21,680 --> 00:13:23,839
this is perfectly demonstrated with the

369
00:13:23,839 --> 00:13:26,480
evolution of bitcoin mining which is a

370
00:13:26,480 --> 00:13:28,160
very much like password cracking

371
00:13:28,160 --> 00:13:30,240
actually so the idea is like you have

372
00:13:30,240 --> 00:13:32,639
bank transactions happening like

373
00:13:32,639 --> 00:13:34,560
a statement every 10 minutes let's say

374
00:13:34,560 --> 00:13:38,399
for example and the miner is able to add

375
00:13:38,399 --> 00:13:40,880
one more transaction to rewind itself if

376
00:13:40,880 --> 00:13:43,519
it finds a particular value like you're

377
00:13:43,519 --> 00:13:45,360
cracking a password which produces a

378
00:13:45,360 --> 00:13:46,880
hash that is

379
00:13:46,880 --> 00:13:48,800
lower uh with starting with a certain

380
00:13:48,800 --> 00:13:51,040
number of zeros so it's essentially

381
00:13:51,040 --> 00:13:52,399
password cracking

382
00:13:52,399 --> 00:13:54,720
and it is really based on sha 256

383
00:13:54,720 --> 00:13:57,920
bitcoin is mainly on the sha 256 so in

384
00:13:57,920 --> 00:13:59,600
the beginning people who are mining

385
00:13:59,600 --> 00:14:01,839
bitcoin on cpu but then someone quickly

386
00:14:01,839 --> 00:14:03,920
thought oh well let's do it with a gpu

387
00:14:03,920 --> 00:14:06,320
so everyone moved to gpu then at some

388
00:14:06,320 --> 00:14:09,279
point it made sense to put the money and

389
00:14:09,279 --> 00:14:12,160
time into designing fpga designs to do

390
00:14:12,160 --> 00:14:14,480
that like i said it's not some it's not

391
00:14:14,480 --> 00:14:16,320
really a kind of programmation it's more

392
00:14:16,320 --> 00:14:18,959
like designing circuitry so it's already

393
00:14:18,959 --> 00:14:21,600
much more involved than gpu programming

394
00:14:21,600 --> 00:14:23,120
and um

395
00:14:23,120 --> 00:14:25,440
nowadays actually all of that even is

396
00:14:25,440 --> 00:14:27,680
kind of worthless compared to asic

397
00:14:27,680 --> 00:14:30,160
mining with the uh

398
00:14:30,160 --> 00:14:32,160
of bitcoin because

399
00:14:32,160 --> 00:14:34,639
bitcoin now is so valuable that it just

400
00:14:34,639 --> 00:14:36,560
made enough sense to manufacture

401
00:14:36,560 --> 00:14:39,519
specialized chips just to mine bitcoin

402
00:14:39,519 --> 00:14:41,920
and this is just because

403
00:14:41,920 --> 00:14:44,880
bitcoin being based on sha 256 didn't

404
00:14:44,880 --> 00:14:46,800
have any sort of

405
00:14:46,800 --> 00:14:50,240
breaks any sort of protection from this

406
00:14:50,240 --> 00:14:53,760
evolution to faster and faster hardware

407
00:14:53,760 --> 00:14:56,560
so one of the things that can be used to

408
00:14:56,560 --> 00:14:59,199
prevent this uh going forward is called

409
00:14:59,199 --> 00:15:01,839
the memory heart function so the idea is

410
00:15:01,839 --> 00:15:02,800
that

411
00:15:02,800 --> 00:15:04,959
the you want to see what is the

412
00:15:04,959 --> 00:15:06,320
difference between the left and the

413
00:15:06,320 --> 00:15:08,320
right on the left you actually hire

414
00:15:08,320 --> 00:15:10,800
quite a bit of ram at your disposal and

415
00:15:10,800 --> 00:15:12,560
on the right side even though gpus

416
00:15:12,560 --> 00:15:14,320
nowadays for example have like 16

417
00:15:14,320 --> 00:15:16,560
gigabytes of ram and so on that ram is

418
00:15:16,560 --> 00:15:19,360
actually tiered in a slower and slower

419
00:15:19,360 --> 00:15:21,760
or relatively slower and slower speeds

420
00:15:21,760 --> 00:15:23,920
and down to when you want to do the

421
00:15:23,920 --> 00:15:26,800
actual the faster implementations of

422
00:15:26,800 --> 00:15:28,720
algorithm you're more thinking about in

423
00:15:28,720 --> 00:15:31,199
terms of 64 kilobytes of ram

424
00:15:31,199 --> 00:15:32,160
so

425
00:15:32,160 --> 00:15:34,160
memory hard function is a function that

426
00:15:34,160 --> 00:15:36,880
requires more than that for example it

427
00:15:36,880 --> 00:15:39,199
ideally even requires gigabytes of ram

428
00:15:39,199 --> 00:15:41,120
so that makes it really annoying for the

429
00:15:41,120 --> 00:15:43,040
gpu attacker because they cannot use

430
00:15:43,040 --> 00:15:44,959
this really fast ram they have to use

431
00:15:44,959 --> 00:15:45,920
this

432
00:15:45,920 --> 00:15:48,480
lowest tier ram which is the bulk ram

433
00:15:48,480 --> 00:15:50,320
let's say those 16 gigabytes that you

434
00:15:50,320 --> 00:15:53,440
have in your gpu but it's really already

435
00:15:53,440 --> 00:15:55,120
slowing down the gpu

436
00:15:55,120 --> 00:15:58,079
a lot more than actually the cpu that

437
00:15:58,079 --> 00:16:00,720
has this all of this ram at its disposal

438
00:16:00,720 --> 00:16:03,199
normally

439
00:16:03,279 --> 00:16:06,160
uh so this was uh exemplified for

440
00:16:06,160 --> 00:16:08,399
example by the ethereum cryptocurrency

441
00:16:08,399 --> 00:16:11,040
which is based on the script the

442
00:16:11,040 --> 00:16:12,959
probably the very first i think as far

443
00:16:12,959 --> 00:16:14,639
as i know the very first memory hard

444
00:16:14,639 --> 00:16:16,800
function by colleen pascual actually he

445
00:16:16,800 --> 00:16:19,759
presented it at passwords con in 2012

446
00:16:19,759 --> 00:16:21,600
and um

447
00:16:21,600 --> 00:16:24,320
it's it was great at keeping

448
00:16:24,320 --> 00:16:27,759
um ethereum kind of stuck to gpu mining

449
00:16:27,759 --> 00:16:30,079
and making it very hard to implement

450
00:16:30,079 --> 00:16:34,320
with fpga and asic but as you can see

451
00:16:34,320 --> 00:16:36,320
with the recent announcements there are

452
00:16:36,320 --> 00:16:38,959
factories that are now going to launch

453
00:16:38,959 --> 00:16:41,600
asic mining for ethereum so it means

454
00:16:41,600 --> 00:16:43,360
that it's not a complete solution it

455
00:16:43,360 --> 00:16:45,440
slowed down this evolution it didn't

456
00:16:45,440 --> 00:16:48,000
happen as fast as it we as it did with

457
00:16:48,000 --> 00:16:50,480
bitcoin but it's still doing exactly the

458
00:16:50,480 --> 00:16:52,959
same so what else can we do to avoid

459
00:16:52,959 --> 00:16:54,320
having the

460
00:16:54,320 --> 00:16:56,240
attackers in terms of password tracking

461
00:16:56,240 --> 00:16:58,480
getting the advantage over the defenders

462
00:16:58,480 --> 00:17:00,320
who have to use the slower technologies

463
00:17:00,320 --> 00:17:02,480
on the left so another new field of

464
00:17:02,480 --> 00:17:04,160
research is called bandwidth heart

465
00:17:04,160 --> 00:17:06,799
functions and it's not bandwidth as in

466
00:17:06,799 --> 00:17:09,119
your internet bandwidth it's more um

467
00:17:09,119 --> 00:17:11,039
bandwidth in terms of

468
00:17:11,039 --> 00:17:12,959
local cache versus stretching

469
00:17:12,959 --> 00:17:15,039
far-fetching from the ram and so on so

470
00:17:15,039 --> 00:17:16,160
it's the

471
00:17:16,160 --> 00:17:18,640
internal bandwidth of

472
00:17:18,640 --> 00:17:21,439
systems on chips and so on uh but just

473
00:17:21,439 --> 00:17:23,839
in general the idea to make this kind of

474
00:17:23,839 --> 00:17:25,919
a fair fight between the defenders and

475
00:17:25,919 --> 00:17:27,919
the attackers is to go for the achilles

476
00:17:27,919 --> 00:17:30,480
heel of the attacker so what are the

477
00:17:30,480 --> 00:17:32,400
specifics of all these

478
00:17:32,400 --> 00:17:34,720
hardware architectures on the right that

479
00:17:34,720 --> 00:17:37,120
would make it much harder for attackers

480
00:17:37,120 --> 00:17:37,840
to

481
00:17:37,840 --> 00:17:40,080
try to crack your password in a way that

482
00:17:40,080 --> 00:17:42,640
is kind of easy for you but hard for the

483
00:17:42,640 --> 00:17:44,960
attacker so for example like i said with

484
00:17:44,960 --> 00:17:47,600
the gpu there's a typical

485
00:17:47,600 --> 00:17:50,160
pattern that you have to follow called

486
00:17:50,160 --> 00:17:52,960
single instruction multiple threads

487
00:17:52,960 --> 00:17:55,440
meaning that all your threads have to be

488
00:17:55,440 --> 00:17:58,080
exactly doing exactly the same thing so

489
00:17:58,080 --> 00:18:00,400
that's great for password cracking if

490
00:18:00,400 --> 00:18:02,640
let's say for example um you're cracking

491
00:18:02,640 --> 00:18:04,960
some md5 or whatever and

492
00:18:04,960 --> 00:18:07,120
you put uh four thousand different

493
00:18:07,120 --> 00:18:11,600
candidates uh of guesses like aaa a b a

494
00:18:11,600 --> 00:18:13,760
c and so on you launch all of them at

495
00:18:13,760 --> 00:18:16,080
the same time and for that the gpu is

496
00:18:16,080 --> 00:18:17,919
great because those four thousand

497
00:18:17,919 --> 00:18:20,080
threads will be executing exactly the

498
00:18:20,080 --> 00:18:22,960
same md5 at the same time and then maybe

499
00:18:22,960 --> 00:18:25,200
one of them has cracked the password

500
00:18:25,200 --> 00:18:27,440
but we don't want that as a defender we

501
00:18:27,440 --> 00:18:29,520
don't want the attacker to be able to do

502
00:18:29,520 --> 00:18:31,280
that so maybe we can design the

503
00:18:31,280 --> 00:18:33,200
algorithm in such a way that it's

504
00:18:33,200 --> 00:18:34,720
forcing

505
00:18:34,720 --> 00:18:37,200
something it's blocking the possibility

506
00:18:37,200 --> 00:18:38,880
of using a single instruction multiple

507
00:18:38,880 --> 00:18:40,799
threads maybe we can make the execution

508
00:18:40,799 --> 00:18:43,520
dependent on the password for example

509
00:18:43,520 --> 00:18:46,160
which i'll get to later um to defend

510
00:18:46,160 --> 00:18:48,799
against fpga like i said the idea is

511
00:18:48,799 --> 00:18:51,520
fpga is kind of virtualizing electronic

512
00:18:51,520 --> 00:18:53,440
circuit boards so

513
00:18:53,440 --> 00:18:54,640
it means that

514
00:18:54,640 --> 00:18:56,400
it can only contain

515
00:18:56,400 --> 00:18:58,960
a finite amount of them so if it's

516
00:18:58,960 --> 00:19:01,280
virtualizing tiny chips with very simple

517
00:19:01,280 --> 00:19:04,080
algorithms like aes md5 shawan chatu

518
00:19:04,080 --> 00:19:05,039
whatever

519
00:19:05,039 --> 00:19:08,400
fpga machine can virtualize many of

520
00:19:08,400 --> 00:19:10,799
those chips so what you want here is a

521
00:19:10,799 --> 00:19:13,360
kind of counterintuitive in terms of a

522
00:19:13,360 --> 00:19:15,120
crypto you actually want a complex

523
00:19:15,120 --> 00:19:17,440
algorithm so that the chip size is

524
00:19:17,440 --> 00:19:19,600
actually big and then the attacker with

525
00:19:19,600 --> 00:19:22,880
the fpga doesn't have enough room to run

526
00:19:22,880 --> 00:19:24,960
many of them at the same time in within

527
00:19:24,960 --> 00:19:27,200
one fpga machine

528
00:19:27,200 --> 00:19:30,000
and finally how to attack an asic well

529
00:19:30,000 --> 00:19:32,559
it's simple basically or i mean it's

530
00:19:32,559 --> 00:19:34,880
difficult to manage uh in terms of

531
00:19:34,880 --> 00:19:36,559
maintenance and so on but you just have

532
00:19:36,559 --> 00:19:39,679
to make just have to make your algorithm

533
00:19:39,679 --> 00:19:41,919
not fixed so that if there is a risk

534
00:19:41,919 --> 00:19:44,240
that tomorrow your algorithm will change

535
00:19:44,240 --> 00:19:46,080
it means that whoever

536
00:19:46,080 --> 00:19:49,520
manufactured specialized chip today to

537
00:19:49,520 --> 00:19:51,760
try to crack your algorithm tomorrow

538
00:19:51,760 --> 00:19:53,360
they can throw this to the garbage

539
00:19:53,360 --> 00:19:55,840
because you changed it tomorrow and then

540
00:19:55,840 --> 00:19:57,440
they cannot change it because it's all

541
00:19:57,440 --> 00:20:00,640
set in stone with their asics

542
00:20:00,640 --> 00:20:04,240
and finally the perhaps the current

543
00:20:04,240 --> 00:20:06,720
state of the art is actually the random

544
00:20:06,720 --> 00:20:08,799
x algorithm that was just added to the

545
00:20:08,799 --> 00:20:11,039
monero cryptocurrency a couple of years

546
00:20:11,039 --> 00:20:14,080
ago around 2019 they already had four

547
00:20:14,080 --> 00:20:16,240
different security audits of it

548
00:20:16,240 --> 00:20:18,960
and uh it's basically trying to do all

549
00:20:18,960 --> 00:20:20,960
of that like going for the achilles heel

550
00:20:20,960 --> 00:20:23,520
of this various technologies and so far

551
00:20:23,520 --> 00:20:25,200
it seems to be holding indeed because

552
00:20:25,200 --> 00:20:27,440
monero is kind of stuck on the cpu

553
00:20:27,440 --> 00:20:29,760
mining and uh of course while there's a

554
00:20:29,760 --> 00:20:31,600
bit of javascript and web assembly

555
00:20:31,600 --> 00:20:33,440
mining happening also because it's being

556
00:20:33,440 --> 00:20:35,360
used by

557
00:20:35,360 --> 00:20:38,080
malicious people hijacking your computer

558
00:20:38,080 --> 00:20:39,919
if you're visiting their website they

559
00:20:39,919 --> 00:20:42,400
might be mining monero in the background

560
00:20:42,400 --> 00:20:44,480
of your browser for example but that's

561
00:20:44,480 --> 00:20:46,840
unrelated to the technology

562
00:20:46,840 --> 00:20:48,880
itself so

563
00:20:48,880 --> 00:20:51,520
to recap basically we have all these

564
00:20:51,520 --> 00:20:53,840
clients that have quite a bit of

565
00:20:53,840 --> 00:20:56,080
untapped power and you have your little

566
00:20:56,080 --> 00:20:57,840
server which might be a raspberry pi or

567
00:20:57,840 --> 00:20:59,520
vps or whatever which is completely

568
00:20:59,520 --> 00:21:01,679
outnumbered and having to do so much

569
00:21:01,679 --> 00:21:02,559
work

570
00:21:02,559 --> 00:21:03,360
so

571
00:21:03,360 --> 00:21:05,520
what can we do about that

572
00:21:05,520 --> 00:21:10,600
so let me get some water actually

573
00:21:23,840 --> 00:21:26,159
so if you read xkcd you probably know

574
00:21:26,159 --> 00:21:29,039
this common example of a password or

575
00:21:29,039 --> 00:21:30,960
even a recommendation

576
00:21:30,960 --> 00:21:33,919
um it's often used in password cracking

577
00:21:33,919 --> 00:21:36,799
research and so on but i have issue with

578
00:21:36,799 --> 00:21:38,640
this one because my hands even get

579
00:21:38,640 --> 00:21:40,240
distracted by the horse and i write

580
00:21:40,240 --> 00:21:41,919
stable instead

581
00:21:41,919 --> 00:21:43,840
but what if you are unstable and you go

582
00:21:43,840 --> 00:21:46,799
horse bears beats butter stub galactica

583
00:21:46,799 --> 00:21:48,480
what if you actually are listening to

584
00:21:48,480 --> 00:21:50,000
metallica when you are typing your

585
00:21:50,000 --> 00:21:51,520
password you might be typing this

586
00:21:51,520 --> 00:21:52,640
instead

587
00:21:52,640 --> 00:21:54,320
what if you are listening to even more

588
00:21:54,320 --> 00:21:56,840
distracting music like the beach boys or

589
00:21:56,840 --> 00:21:59,520
aqua what if you're descending into

590
00:21:59,520 --> 00:22:02,080
madness and mathematics so let's just

591
00:22:02,080 --> 00:22:04,400
use a correct horse banana for scale and

592
00:22:04,400 --> 00:22:05,919
conclude that actually we need to

593
00:22:05,919 --> 00:22:08,880
truncate that 14 characters

594
00:22:08,880 --> 00:22:11,679
so now well we forgot kind of where did

595
00:22:11,679 --> 00:22:14,559
we put all those caps so it's difficult

596
00:22:14,559 --> 00:22:16,480
and especially some people have their

597
00:22:16,480 --> 00:22:19,520
caps lock key instead of shift so um

598
00:22:19,520 --> 00:22:21,360
let's try to help everyone and just to

599
00:22:21,360 --> 00:22:23,600
be sure capitalize all of this so we end

600
00:22:23,600 --> 00:22:26,960
up with correct horse bar all uppercase

601
00:22:26,960 --> 00:22:28,559
that's still a lot of to remember so

602
00:22:28,559 --> 00:22:30,320
what can we do about this can we do like

603
00:22:30,320 --> 00:22:31,919
in the movies i would really like to see

604
00:22:31,919 --> 00:22:33,679
that in the real world where we can

605
00:22:33,679 --> 00:22:36,240
crack password later by letter uh but

606
00:22:36,240 --> 00:22:38,159
that i have never seen happen in real

607
00:22:38,159 --> 00:22:39,600
life because that's not how passwords

608
00:22:39,600 --> 00:22:40,559
work

609
00:22:40,559 --> 00:22:42,400
but maybe we don't have to go as far

610
00:22:42,400 --> 00:22:44,720
because it looks like it's 50 correct so

611
00:22:44,720 --> 00:22:46,799
let's just divide it in half

612
00:22:46,799 --> 00:22:48,080
with this

613
00:22:48,080 --> 00:22:50,720
a fancy software engineering pattern

614
00:22:50,720 --> 00:22:52,480
called divide and conquer just cut it in

615
00:22:52,480 --> 00:22:54,400
half and now we realize that each half

616
00:22:54,400 --> 00:22:58,000
is 56 bits which is perfect for this ds

617
00:22:58,000 --> 00:23:00,000
algorithm from the 70s so it must be

618
00:23:00,000 --> 00:23:01,919
pretty good by now

619
00:23:01,919 --> 00:23:04,000
but what can we encrypted that

620
00:23:04,000 --> 00:23:06,080
because blockchaining sounds hard block

621
00:23:06,080 --> 00:23:08,880
paddocks outside and well let's just

622
00:23:08,880 --> 00:23:10,640
encrypt the steam constant measuring

623
00:23:10,640 --> 00:23:12,559
exactly one block

624
00:23:12,559 --> 00:23:15,360
so you would take this original password

625
00:23:15,360 --> 00:23:17,760
have truncated it to 14 characters

626
00:23:17,760 --> 00:23:19,919
uppercasedid it all divide it into two

627
00:23:19,919 --> 00:23:21,840
halves completely unrelated and

628
00:23:21,840 --> 00:23:24,640
encrypted ds would correct as a key of

629
00:23:24,640 --> 00:23:27,360
kgs something something and separately

630
00:23:27,360 --> 00:23:29,760
dds with horseback as a key of kgs

631
00:23:29,760 --> 00:23:31,760
something something and now if you're

632
00:23:31,760 --> 00:23:34,320
wondering like why am i telling you all

633
00:23:34,320 --> 00:23:37,039
this who in their right mind would

634
00:23:37,039 --> 00:23:38,880
design and use such a ridiculous

635
00:23:38,880 --> 00:23:43,520
algorithm well you might be surprised

636
00:23:43,919 --> 00:23:45,919
so if you think that it's a thing of the

637
00:23:45,919 --> 00:23:48,159
past well actually an article even from

638
00:23:48,159 --> 00:23:50,000
just last month is saying that there's

639
00:23:50,000 --> 00:23:52,559
still so many people using windows xp

640
00:23:52,559 --> 00:23:54,559
and it's not just people at home like

641
00:23:54,559 --> 00:23:56,559
you have the national health service

642
00:23:56,559 --> 00:23:58,320
health service in the uk which is

643
00:23:58,320 --> 00:24:00,000
managing all the hospitals it's a big

644
00:24:00,000 --> 00:24:02,159
deal in the uk it's getting hacked all

645
00:24:02,159 --> 00:24:03,919
the time because it's still running

646
00:24:03,919 --> 00:24:06,080
windows xp and all sorts of issues like

647
00:24:06,080 --> 00:24:08,320
that but then you might think that well

648
00:24:08,320 --> 00:24:10,320
it's only an issue with organizations

649
00:24:10,320 --> 00:24:11,919
that don't really have an i.t budget

650
00:24:11,919 --> 00:24:12,960
maybe

651
00:24:12,960 --> 00:24:15,039
but as you can see there's a three

652
00:24:15,039 --> 00:24:16,720
billion pound aircraft carrier being

653
00:24:16,720 --> 00:24:18,559
delivered two years from now which is

654
00:24:18,559 --> 00:24:22,240
apparently getting windows xp with it

655
00:24:22,240 --> 00:24:24,880
so some numbers and just to have fun

656
00:24:24,880 --> 00:24:26,640
here

657
00:24:26,640 --> 00:24:28,960
so a long time ago

658
00:24:28,960 --> 00:24:32,080
like 14 years ago i was pen testing a

659
00:24:32,080 --> 00:24:34,000
defense company so keep that in mind

660
00:24:34,000 --> 00:24:36,000
that a defense company so it means that

661
00:24:36,000 --> 00:24:38,480
you're not far from making security

662
00:24:38,480 --> 00:24:40,799
issues a matter of life and death

663
00:24:40,799 --> 00:24:42,720
i was there contesting them with

664
00:24:42,720 --> 00:24:44,720
jean-michel pico whom you might remember

665
00:24:44,720 --> 00:24:48,000
from the dpa peak so a tool that is

666
00:24:48,000 --> 00:24:50,080
extracting secrets from windows data

667
00:24:50,080 --> 00:24:52,480
protection api he presented that at

668
00:24:52,480 --> 00:24:54,559
black hat federal 2010

669
00:24:54,559 --> 00:24:56,720
and so we were

670
00:24:56,720 --> 00:24:58,880
just getting ready there

671
00:24:58,880 --> 00:25:00,640
so i think by that time i was still

672
00:25:00,640 --> 00:25:03,600
looking for a electricity socket to plug

673
00:25:03,600 --> 00:25:06,000
my laptop charger or whatever and it

674
00:25:06,000 --> 00:25:08,000
because it was kind of a big deal

675
00:25:08,000 --> 00:25:11,200
there was the cso the ceo and various

676
00:25:11,200 --> 00:25:13,200
members of the board of executives who

677
00:25:13,200 --> 00:25:15,360
were watching us getting set up

678
00:25:15,360 --> 00:25:16,400
and

679
00:25:16,400 --> 00:25:19,520
the cso was telling the ceo don't worry

680
00:25:19,520 --> 00:25:21,120
there's no way they will find anything

681
00:25:21,120 --> 00:25:23,440
because the admin password is all random

682
00:25:23,440 --> 00:25:25,200
all uppercase lowercase special

683
00:25:25,200 --> 00:25:27,600
characters whatever and ascii was saying

684
00:25:27,600 --> 00:25:29,919
that jean-michel asked him

685
00:25:29,919 --> 00:25:32,240
excuse me sorry to interrupt is it three

686
00:25:32,240 --> 00:25:34,799
capital d lowercase s and so on and so

687
00:25:34,799 --> 00:25:37,279
on and it was really that and it was not

688
00:25:37,279 --> 00:25:39,120
even like two minutes within our pen

689
00:25:39,120 --> 00:25:41,279
test of a defense company just because

690
00:25:41,279 --> 00:25:42,880
windows is so bad at protecting

691
00:25:42,880 --> 00:25:44,080
passwords

692
00:25:44,080 --> 00:25:46,240
so nowadays there's not even a need to

693
00:25:46,240 --> 00:25:48,720
have rainbow tables anymore because as

694
00:25:48,720 --> 00:25:50,799
an attacker or pen tester you would have

695
00:25:50,799 --> 00:25:53,360
at least gpus or maybe even fpgas at

696
00:25:53,360 --> 00:25:55,440
your disposal

697
00:25:55,440 --> 00:25:57,279
and because they are so fast there's

698
00:25:57,279 --> 00:25:59,279
just no need to use perfectly good

699
00:25:59,279 --> 00:26:01,279
storage space for rainbow tables because

700
00:26:01,279 --> 00:26:04,240
you can do it just as fast by cracking

701
00:26:04,240 --> 00:26:06,080
the password from scratch every single

702
00:26:06,080 --> 00:26:07,200
time

703
00:26:07,200 --> 00:26:09,279
and just to give you an example of how

704
00:26:09,279 --> 00:26:11,840
bad this is still nowadays especially

705
00:26:11,840 --> 00:26:14,720
now that computers are faster and faster

706
00:26:14,720 --> 00:26:17,200
it means that even just a teenager with

707
00:26:17,200 --> 00:26:19,039
a gaming pc from this year so not

708
00:26:19,039 --> 00:26:21,440
someone like who is an evil hacker with

709
00:26:21,440 --> 00:26:22,640
advanced

710
00:26:22,640 --> 00:26:24,320
hardware like in the movies or whatever

711
00:26:24,320 --> 00:26:26,960
just a regular teenager with a gaming pc

712
00:26:26,960 --> 00:26:29,200
would crack your password in 15 minutes

713
00:26:29,200 --> 00:26:31,039
so he would be admin of the aircraft

714
00:26:31,039 --> 00:26:33,520
carrier or something

715
00:26:33,520 --> 00:26:36,480
um so what can we do about that well

716
00:26:36,480 --> 00:26:38,720
apparently ds is pretty bad it's getting

717
00:26:38,720 --> 00:26:40,880
cracked left and right and so on so what

718
00:26:40,880 --> 00:26:43,679
can we do about that well phipps463 says

719
00:26:43,679 --> 00:26:46,080
to replace dis with triple des but

720
00:26:46,080 --> 00:26:48,159
actually triple des was designed or at

721
00:26:48,159 --> 00:26:49,760
least in the encrypted

722
00:26:49,760 --> 00:26:51,919
encrypt construct to be backwards

723
00:26:51,919 --> 00:26:54,320
compatible with the legacy systems that

724
00:26:54,320 --> 00:26:56,720
only understand this so if you do triple

725
00:26:56,720 --> 00:26:58,400
test with three

726
00:26:58,400 --> 00:27:00,320
thirds of a key that are the same so

727
00:27:00,320 --> 00:27:02,320
like the yes three times with the same

728
00:27:02,320 --> 00:27:04,640
key so it means that you just fall back

729
00:27:04,640 --> 00:27:06,799
onto this you're doing this encryption

730
00:27:06,799 --> 00:27:08,720
once with the key then decrypting it

731
00:27:08,720 --> 00:27:10,559
with the same key which just cancels

732
00:27:10,559 --> 00:27:12,960
itself out and then finally encrypting

733
00:27:12,960 --> 00:27:14,799
once with this so now you're just back

734
00:27:14,799 --> 00:27:17,039
to square one

735
00:27:17,039 --> 00:27:19,440
so well now we have to completely change

736
00:27:19,440 --> 00:27:21,840
that design that i was a that ridiculous

737
00:27:21,840 --> 00:27:24,880
algorithm that i presented before um so

738
00:27:24,880 --> 00:27:26,640
how can we use triple dash actually with

739
00:27:26,640 --> 00:27:28,720
the whole password well we would need

740
00:27:28,720 --> 00:27:32,720
168 bits for a key for the triple desk

741
00:27:32,720 --> 00:27:33,679
and

742
00:27:33,679 --> 00:27:36,799
that means at least 21 characters not

743
00:27:36,799 --> 00:27:39,440
taking into consideration the entropy

744
00:27:39,440 --> 00:27:41,840
the the fact that one character is not

745
00:27:41,840 --> 00:27:45,919
at all uh one of 255 or 56 possible

746
00:27:45,919 --> 00:27:47,520
combinations

747
00:27:47,520 --> 00:27:49,919
so what about something small requiring

748
00:27:49,919 --> 00:27:52,399
a smaller key like aes 128 well still

749
00:27:52,399 --> 00:27:55,279
you would need at least 16 characters as

750
00:27:55,279 --> 00:27:57,200
a password which is definitely not

751
00:27:57,200 --> 00:27:59,200
something very common so what if you

752
00:27:59,200 --> 00:28:00,720
take this

753
00:28:00,720 --> 00:28:03,120
example from microsoft documentation

754
00:28:03,120 --> 00:28:05,440
that actually it administrators use in

755
00:28:05,440 --> 00:28:08,080
the real world uh so password with the

756
00:28:08,080 --> 00:28:11,120
ads instead of a and 0 instead of o

757
00:28:11,120 --> 00:28:13,520
and just space it out putting some null

758
00:28:13,520 --> 00:28:15,440
character kind of like a space in

759
00:28:15,440 --> 00:28:16,960
between every single one of those

760
00:28:16,960 --> 00:28:18,480
letters so it kind of looks like now you

761
00:28:18,480 --> 00:28:20,320
have 16 letters so is it good enough for

762
00:28:20,320 --> 00:28:22,640
128 bits of password

763
00:28:22,640 --> 00:28:24,399
or what about the shorter passwords i

764
00:28:24,399 --> 00:28:26,320
didn't talk about that in the previous

765
00:28:26,320 --> 00:28:28,000
slides and so far

766
00:28:28,000 --> 00:28:29,840
so well what do you do with people who

767
00:28:29,840 --> 00:28:31,039
have only like

768
00:28:31,039 --> 00:28:33,840
10 uh letters or five letters or

769
00:28:33,840 --> 00:28:36,240
whatever password so you would still pad

770
00:28:36,240 --> 00:28:38,159
it with zeros which means that the rest

771
00:28:38,159 --> 00:28:41,679
of the key is kind of worthless

772
00:28:41,679 --> 00:28:43,679
so all of this well it sounds very hard

773
00:28:43,679 --> 00:28:45,440
actually you have to worry about entropy

774
00:28:45,440 --> 00:28:48,000
key derivation functions and so on so

775
00:28:48,000 --> 00:28:49,679
let's just use

776
00:28:49,679 --> 00:28:51,919
md4 you know like from the early 90s

777
00:28:51,919 --> 00:28:54,480
1992 if i remember correctly of the

778
00:28:54,480 --> 00:28:56,799
unicode 16 little engine representation

779
00:28:56,799 --> 00:28:59,200
of a password and again if you're

780
00:28:59,200 --> 00:29:01,200
thinking why am i telling you all this

781
00:29:01,200 --> 00:29:03,279
all this ridiculous algorithm well

782
00:29:03,279 --> 00:29:05,279
that's how windows is trying to protect

783
00:29:05,279 --> 00:29:08,320
your passwords nowaday

784
00:29:10,840 --> 00:29:15,440
so i'm bashing on windows but

785
00:29:15,440 --> 00:29:17,760
i have had to say i have to respect that

786
00:29:17,760 --> 00:29:19,760
microsoft is trying to offer this

787
00:29:19,760 --> 00:29:22,080
backwatch compatibility which is great

788
00:29:22,080 --> 00:29:24,640
in terms of i.t but from what i see from

789
00:29:24,640 --> 00:29:26,480
a lot of personal experience

790
00:29:26,480 --> 00:29:29,039
apparently many security teams maybe

791
00:29:29,039 --> 00:29:31,760
most of them if not all of them

792
00:29:31,760 --> 00:29:34,240
have no idea that actually the main

793
00:29:34,240 --> 00:29:37,039
defense of their whole infrastructure is

794
00:29:37,039 --> 00:29:39,679
like a rusty old lock from the 70s or

795
00:29:39,679 --> 00:29:42,799
the early 90s at best

796
00:29:42,799 --> 00:29:45,520
so just a quick idea of numbers that's

797
00:29:45,520 --> 00:29:47,760
something that jeremy presented that

798
00:29:47,760 --> 00:29:50,640
password scon password 2012

799
00:29:50,640 --> 00:29:54,480
um and while he was able to crack all

800
00:29:54,480 --> 00:29:55,279
those

801
00:29:55,279 --> 00:29:56,960
passwords windows passwords at the time

802
00:29:56,960 --> 00:29:59,200
in less than six hours so you might say

803
00:29:59,200 --> 00:30:01,440
well to be fair actually that article is

804
00:30:01,440 --> 00:30:02,240
about

805
00:30:02,240 --> 00:30:04,480
fully random but only eight character

806
00:30:04,480 --> 00:30:07,440
passwords and yeah nowadays thankfully

807
00:30:07,440 --> 00:30:09,440
people are being asked to use longer and

808
00:30:09,440 --> 00:30:11,600
longer passwords rather a passphrase

809
00:30:11,600 --> 00:30:12,559
instead

810
00:30:12,559 --> 00:30:13,840
and so

811
00:30:13,840 --> 00:30:16,640
maybe in your network you think that

812
00:30:16,640 --> 00:30:19,200
it's not applicable anymore but actually

813
00:30:19,200 --> 00:30:21,600
have you checked the passwords from it

814
00:30:21,600 --> 00:30:23,440
because they the rules don't apply to

815
00:30:23,440 --> 00:30:25,520
them and they put passwords that do not

816
00:30:25,520 --> 00:30:27,840
expire so it's very common even just

817
00:30:27,840 --> 00:30:30,320
like five years ago i was doing a pen

818
00:30:30,320 --> 00:30:32,559
test where thanks to mimikatz that's

819
00:30:32,559 --> 00:30:34,080
another reason to not

820
00:30:34,080 --> 00:30:37,120
trust windows security at all i dumped

821
00:30:37,120 --> 00:30:38,720
around 800

822
00:30:38,720 --> 00:30:40,799
passwords of a whole multinational

823
00:30:40,799 --> 00:30:43,039
company and was admin on five different

824
00:30:43,039 --> 00:30:44,799
active directory domains in just one

825
00:30:44,799 --> 00:30:45,600
week

826
00:30:45,600 --> 00:30:48,640
because of all of that weakness and the

827
00:30:48,640 --> 00:30:50,320
administration passwords were nine

828
00:30:50,320 --> 00:30:52,640
characters long and all lower case and

829
00:30:52,640 --> 00:30:55,679
maybe a couple of digits

830
00:30:55,679 --> 00:30:57,519
so well what can we do about all that

831
00:30:57,519 --> 00:30:59,600
obviously md4 is too weak so let's use

832
00:30:59,600 --> 00:31:01,519
md5 because five is bigger than four so

833
00:31:01,519 --> 00:31:03,600
parabola is better and let's use it

834
00:31:03,600 --> 00:31:05,919
twice to at least be twice as better

835
00:31:05,919 --> 00:31:07,279
than windows

836
00:31:07,279 --> 00:31:10,159
and why well for real this time

837
00:31:10,159 --> 00:31:11,840
it's also something that i've seen

838
00:31:11,840 --> 00:31:14,159
happen before where you might have this

839
00:31:14,159 --> 00:31:16,720
service provided to many customers like

840
00:31:16,720 --> 00:31:19,200
in this particular case it was a large

841
00:31:19,200 --> 00:31:21,360
corporate email service with tens maybe

842
00:31:21,360 --> 00:31:23,760
hundreds of thousands of clients around

843
00:31:23,760 --> 00:31:26,159
the world or visitors at least

844
00:31:26,159 --> 00:31:28,240
and it turned out that all those

845
00:31:28,240 --> 00:31:30,000
usernames and passwords were only

846
00:31:30,000 --> 00:31:32,399
protected with a single round of md5

847
00:31:32,399 --> 00:31:35,039
so it's already much better than windows

848
00:31:35,039 --> 00:31:36,799
but it also

849
00:31:36,799 --> 00:31:38,720
is very bad so

850
00:31:38,720 --> 00:31:40,799
what should we do about that how can we

851
00:31:40,799 --> 00:31:43,360
actually properly secure this well

852
00:31:43,360 --> 00:31:45,760
should we consider argon 2 the new best

853
00:31:45,760 --> 00:31:48,640
practice from 2015 no maybe it's too uh

854
00:31:48,640 --> 00:31:51,760
recent so escript from 2009 not too

855
00:31:51,760 --> 00:31:54,399
recent maybe b crypt from 1999 not too

856
00:31:54,399 --> 00:31:57,200
complicated at least bbk df2 which

857
00:31:57,200 --> 00:31:59,519
everyone has heard about i guess

858
00:31:59,519 --> 00:32:01,760
but no apparently still complicated so

859
00:32:01,760 --> 00:32:03,360
we'll just do something that is as

860
00:32:03,360 --> 00:32:05,440
compatible as possible for some reason

861
00:32:05,440 --> 00:32:07,440
that doesn't achieve anything in terms

862
00:32:07,440 --> 00:32:09,840
of improving the security and they waste

863
00:32:09,840 --> 00:32:12,000
a lot of time and money just to migrate

864
00:32:12,000 --> 00:32:13,919
everyone by forcing them to change their

865
00:32:13,919 --> 00:32:17,039
password to a single round of chat 256

866
00:32:17,039 --> 00:32:18,880
so if you remember those previous slides

867
00:32:18,880 --> 00:32:20,880
that i was showing earlier about rough

868
00:32:20,880 --> 00:32:24,799
orders of magnitude chat to 256 can be

869
00:32:24,799 --> 00:32:27,600
cracked at hundreds of trillions of

870
00:32:27,600 --> 00:32:30,320
guesses per second so it's hundreds of

871
00:32:30,320 --> 00:32:32,399
millions of millions per second so it's

872
00:32:32,399 --> 00:32:35,039
completely a waste of time

873
00:32:35,039 --> 00:32:36,960
and how does that look like in the real

874
00:32:36,960 --> 00:32:38,399
world where you have these companies

875
00:32:38,399 --> 00:32:40,399
that say well we take security extremely

876
00:32:40,399 --> 00:32:42,559
seriously but then they get hacked by a

877
00:32:42,559 --> 00:32:45,760
teenager so that's exactly why so how to

878
00:32:45,760 --> 00:32:47,679
actually take security seriously that's

879
00:32:47,679 --> 00:32:49,600
a presentation from alec muffet for

880
00:32:49,600 --> 00:32:52,480
example at passwordscron 2014

881
00:32:52,480 --> 00:32:54,080
where he was explaining how does

882
00:32:54,080 --> 00:32:55,440
facebook do it

883
00:32:55,440 --> 00:32:57,279
so it's basically a question of doing

884
00:32:57,279 --> 00:32:58,799
layers

885
00:32:58,799 --> 00:33:00,559
so let's say you just started the

886
00:33:00,559 --> 00:33:01,840
service and you don't really know

887
00:33:01,840 --> 00:33:04,159
anything about the security or maybe you

888
00:33:04,159 --> 00:33:05,679
don't have time to worry about the

889
00:33:05,679 --> 00:33:08,559
username database security yet so maybe

890
00:33:08,559 --> 00:33:10,399
you just store everything in clear text

891
00:33:10,399 --> 00:33:12,240
it's not very good but maybe next week

892
00:33:12,240 --> 00:33:14,399
you'll get around to improving it and

893
00:33:14,399 --> 00:33:17,760
then you had somewhere that at least md5

894
00:33:17,760 --> 00:33:20,799
is better than clear text or password

895
00:33:20,799 --> 00:33:23,039
but then at some point you realize that

896
00:33:23,039 --> 00:33:25,200
all the users that have the very same

897
00:33:25,200 --> 00:33:28,159
password have the same md5 hash so that

898
00:33:28,159 --> 00:33:30,559
doesn't look like a good idea either

899
00:33:30,559 --> 00:33:32,480
that's still a problem with windows

900
00:33:32,480 --> 00:33:35,120
nowadays but they're not fixing it so at

901
00:33:35,120 --> 00:33:36,880
least you are doing something better

902
00:33:36,880 --> 00:33:38,720
than windows you put a salt which makes

903
00:33:38,720 --> 00:33:40,000
the hash

904
00:33:40,000 --> 00:33:42,320
for people who have the same password at

905
00:33:42,320 --> 00:33:43,679
least the resulting hash would be

906
00:33:43,679 --> 00:33:45,440
different

907
00:33:45,440 --> 00:33:47,519
then you learn more about password

908
00:33:47,519 --> 00:33:49,840
security and so on and you

909
00:33:49,840 --> 00:33:51,919
read about something called a pepper so

910
00:33:51,919 --> 00:33:54,240
it's kind of like a salt except it's not

911
00:33:54,240 --> 00:33:56,640
specific to the user and it doesn't even

912
00:33:56,640 --> 00:33:58,720
go in the database so what i highlighted

913
00:33:58,720 --> 00:34:00,720
in yellow is what you would have in the

914
00:34:00,720 --> 00:34:03,120
database itself whilst the paper is kind

915
00:34:03,120 --> 00:34:04,480
of like a secret that you keep

916
00:34:04,480 --> 00:34:06,000
separately from the database you would

917
00:34:06,000 --> 00:34:07,360
keep it in the source code of the

918
00:34:07,360 --> 00:34:09,280
website like the php or whatever you

919
00:34:09,280 --> 00:34:10,800
write your website with

920
00:34:10,800 --> 00:34:13,760
and um that way what happens a lot of

921
00:34:13,760 --> 00:34:15,520
the time is that hackers are able to

922
00:34:15,520 --> 00:34:17,280
extract the whole database behind your

923
00:34:17,280 --> 00:34:18,879
website but they are not necessarily

924
00:34:18,879 --> 00:34:20,960
able to get to the source code so in

925
00:34:20,960 --> 00:34:23,040
this case the attack would be swatted

926
00:34:23,040 --> 00:34:25,040
because they don't know what is the

927
00:34:25,040 --> 00:34:26,159
pepper

928
00:34:26,159 --> 00:34:28,560
so then you learn about pbk df2 which is

929
00:34:28,560 --> 00:34:31,040
kind of a clutch like duct taping some

930
00:34:31,040 --> 00:34:32,800
fast hash like all of these before

931
00:34:32,800 --> 00:34:34,480
together but to try to at least slow it

932
00:34:34,480 --> 00:34:35,520
down a bit

933
00:34:35,520 --> 00:34:38,079
and as the time passes you might add

934
00:34:38,079 --> 00:34:40,159
layers and layers just to

935
00:34:40,159 --> 00:34:41,918
make it harder and harder because you

936
00:34:41,918 --> 00:34:44,320
have to basically find the happy medium

937
00:34:44,320 --> 00:34:46,719
of how slow you want to make it for your

938
00:34:46,719 --> 00:34:48,960
little raspberry pi vps or whatever your

939
00:34:48,960 --> 00:34:52,320
service is running on um but

940
00:34:52,320 --> 00:34:53,679
at the same time you want to find a

941
00:34:53,679 --> 00:34:55,199
happy medium with slowing down the

942
00:34:55,199 --> 00:34:56,239
attackers

943
00:34:56,239 --> 00:34:57,200
and the

944
00:34:57,200 --> 00:34:59,280
hardware becomes faster and faster every

945
00:34:59,280 --> 00:35:01,520
day or every six months and so on

946
00:35:01,520 --> 00:35:03,920
so at some point finally you read that

947
00:35:03,920 --> 00:35:06,240
well it's kind of bad to use all of

948
00:35:06,240 --> 00:35:08,480
these uh hashes fast hashes that are

949
00:35:08,480 --> 00:35:11,839
great for hashing files like md5 sha-2

950
00:35:11,839 --> 00:35:13,040
and so on but

951
00:35:13,040 --> 00:35:15,359
they have no place in being used for

952
00:35:15,359 --> 00:35:17,280
password protection you want actually a

953
00:35:17,280 --> 00:35:19,359
function an algorithm that has been

954
00:35:19,359 --> 00:35:21,200
designed for that so that's what bcrypt

955
00:35:21,200 --> 00:35:23,440
was in the 1990s for example so don't

956
00:35:23,440 --> 00:35:25,839
worry about the anachronism with the

957
00:35:25,839 --> 00:35:27,440
sha-3 being more recent that's just

958
00:35:27,440 --> 00:35:30,320
examples but yeah you are learning about

959
00:35:30,320 --> 00:35:31,839
the password security so at some point

960
00:35:31,839 --> 00:35:34,320
you add the layer a layer of decrypt and

961
00:35:34,320 --> 00:35:36,079
you still haven't required anyone to

962
00:35:36,079 --> 00:35:38,320
change the password just to show that

963
00:35:38,320 --> 00:35:40,000
it's possible to do

964
00:35:40,000 --> 00:35:43,119
without annoying anyone

965
00:35:43,119 --> 00:35:44,880
um

966
00:35:44,880 --> 00:35:47,520
then again time passes you had more and

967
00:35:47,520 --> 00:35:49,040
at some point you learned about these

968
00:35:49,040 --> 00:35:51,280
memory hard functions to try to throt

969
00:35:51,280 --> 00:35:53,520
the attackers with at least a gpu or

970
00:35:53,520 --> 00:35:56,000
maybe fpga asic and so on so you use

971
00:35:56,000 --> 00:35:58,000
script as an additional layer maybe at

972
00:35:58,000 --> 00:35:59,359
some point you add another layer of

973
00:35:59,359 --> 00:36:02,160
script and finally it's 2015 or more

974
00:36:02,160 --> 00:36:04,000
recent and you learn about this new best

975
00:36:04,000 --> 00:36:07,200
practice argon 2 and you add a layer

976
00:36:07,200 --> 00:36:09,760
each time with its different salt pepper

977
00:36:09,760 --> 00:36:11,520
and different factors so that for

978
00:36:11,520 --> 00:36:14,480
example maybe the first time you added a

979
00:36:14,480 --> 00:36:17,040
layer that takes just 10 milliseconds of

980
00:36:17,040 --> 00:36:18,960
execution but the next time you want to

981
00:36:18,960 --> 00:36:21,040
make it even like 100 milliseconds of

982
00:36:21,040 --> 00:36:22,960
execution or something like that so

983
00:36:22,960 --> 00:36:25,200
that's how you can improve layer by

984
00:36:25,200 --> 00:36:27,760
layer progressively being kind of future

985
00:36:27,760 --> 00:36:30,000
proofing your password security

986
00:36:30,000 --> 00:36:31,680
and at the same time you might think

987
00:36:31,680 --> 00:36:33,680
especially as a cryptographer if you're

988
00:36:33,680 --> 00:36:35,760
familiar with crypto you would get kind

989
00:36:35,760 --> 00:36:38,320
of a bad feeling for dragging all of

990
00:36:38,320 --> 00:36:41,359
this retro compatibility behind

991
00:36:41,359 --> 00:36:43,599
all of this especially if it was started

992
00:36:43,599 --> 00:36:45,680
with a password in clear text or going

993
00:36:45,680 --> 00:36:48,320
as far back as md5 sha-1 and so on but

994
00:36:48,320 --> 00:36:50,160
you don't really have to because at some

995
00:36:50,160 --> 00:36:52,000
point finally users might change their

996
00:36:52,000 --> 00:36:54,320
password or you might get a new user

997
00:36:54,320 --> 00:36:56,400
that just arrived when

998
00:36:56,400 --> 00:36:58,400
you're already within the generation

999
00:36:58,400 --> 00:37:01,280
nine of your improvements so maybe at

1000
00:37:01,280 --> 00:37:03,599
the time you take the brand new password

1001
00:37:03,599 --> 00:37:06,000
maybe the word password again you put it

1002
00:37:06,000 --> 00:37:08,079
through script and then one year later

1003
00:37:08,079 --> 00:37:10,320
you had this layer of argon 2 then

1004
00:37:10,320 --> 00:37:12,400
another year later another layer of

1005
00:37:12,400 --> 00:37:14,880
argon 2 and so on so as you can see you

1006
00:37:14,880 --> 00:37:16,960
can implement it within your database

1007
00:37:16,960 --> 00:37:18,880
like that for example where this new

1008
00:37:18,880 --> 00:37:20,400
recent user

1009
00:37:20,400 --> 00:37:23,359
doesn't have uh any of the salts for

1010
00:37:23,359 --> 00:37:26,400
example for the older algorithms

1011
00:37:26,400 --> 00:37:28,400
so if you remember this slide

1012
00:37:28,400 --> 00:37:31,040
um you see that while there's so much

1013
00:37:31,040 --> 00:37:33,760
performance on the right still maybe not

1014
00:37:33,760 --> 00:37:36,320
as much as a real like nation-state

1015
00:37:36,320 --> 00:37:38,480
actor but it's really a pity to not be

1016
00:37:38,480 --> 00:37:40,640
making any use of this

1017
00:37:40,640 --> 00:37:42,800
amount of performance that is vastly

1018
00:37:42,800 --> 00:37:45,920
outnumbering your raspberry pi or vps on

1019
00:37:45,920 --> 00:37:47,280
the left

1020
00:37:47,280 --> 00:37:48,480
so

1021
00:37:48,480 --> 00:37:50,640
i started uh building something called

1022
00:37:50,640 --> 00:37:52,880
hashmore just because i like to tune

1023
00:37:52,880 --> 00:37:55,839
security to 11 basically so let's uh

1024
00:37:55,839 --> 00:37:57,359
it's time for clients to start doing

1025
00:37:57,359 --> 00:37:59,520
their part let's see how we can do that

1026
00:37:59,520 --> 00:38:01,680
so let's say for example we have a

1027
00:38:01,680 --> 00:38:04,720
constant c1 just a welcome message

1028
00:38:04,720 --> 00:38:06,960
then a constant c2 that is supposed to

1029
00:38:06,960 --> 00:38:09,040
be a number used once but maybe you're

1030
00:38:09,040 --> 00:38:10,800
not very good at math or you like to

1031
00:38:10,800 --> 00:38:13,680
read xkcd when they were

1032
00:38:13,680 --> 00:38:16,880
laughing at a mistake made by debian 10

1033
00:38:16,880 --> 00:38:19,119
years ago or something

1034
00:38:19,119 --> 00:38:20,480
when

1035
00:38:20,480 --> 00:38:22,560
well you can use the number four

1036
00:38:22,560 --> 00:38:25,520
here instead of a random number just as

1037
00:38:25,520 --> 00:38:27,760
a joke because maybe it was taken from

1038
00:38:27,760 --> 00:38:30,560
one fair direct role but actually i

1039
00:38:30,560 --> 00:38:32,720
unintentionally found a remote exploit

1040
00:38:32,720 --> 00:38:33,920
with this way

1041
00:38:33,920 --> 00:38:36,400
trying to put a large number here but

1042
00:38:36,400 --> 00:38:38,560
it's a it better be a small number

1043
00:38:38,560 --> 00:38:40,320
actually

1044
00:38:40,320 --> 00:38:42,720
so the constant c3 can be the word post

1045
00:38:42,720 --> 00:38:45,680
for example then c4 a well-known unified

1046
00:38:45,680 --> 00:38:48,240
resource indicator maybe if you use less

1047
00:38:48,240 --> 00:38:49,760
encrypt for example you're familiar with

1048
00:38:49,760 --> 00:38:51,680
that sort of thing it's just a path that

1049
00:38:51,680 --> 00:38:53,839
starts with dot well dash known and so

1050
00:38:53,839 --> 00:38:54,560
on

1051
00:38:54,560 --> 00:38:56,320
and just to make sure that all of that

1052
00:38:56,320 --> 00:38:58,720
is constant then you can apply this

1053
00:38:58,720 --> 00:39:00,960
formula and you can see that actually

1054
00:39:00,960 --> 00:39:03,359
all of it is constant even if even that

1055
00:39:03,359 --> 00:39:05,440
md5 on the right side all of that can be

1056
00:39:05,440 --> 00:39:08,320
pre-calculated so in the end it's just

1057
00:39:08,320 --> 00:39:10,480
md5 of basically the username and

1058
00:39:10,480 --> 00:39:13,040
password with another md5 of that again

1059
00:39:13,040 --> 00:39:16,240
so md5 twice like i was saying and rsc

1060
00:39:16,240 --> 00:39:19,359
2069 is something that actually all the

1061
00:39:19,359 --> 00:39:22,000
browsers support it's called http digest

1062
00:39:22,000 --> 00:39:24,800
authentication it's not commonly used it

1063
00:39:24,800 --> 00:39:26,480
may be fallen behind the times or

1064
00:39:26,480 --> 00:39:28,400
something but it's still being uh

1065
00:39:28,400 --> 00:39:31,119
offered nowadays so that you can have

1066
00:39:31,119 --> 00:39:33,200
even a text mode browser for example

1067
00:39:33,200 --> 00:39:34,960
maybe if you are connected to a server

1068
00:39:34,960 --> 00:39:36,960
with ssh you might be using links

1069
00:39:36,960 --> 00:39:38,880
sometimes to quickly access your website

1070
00:39:38,880 --> 00:39:41,119
so it doesn't even it's not even capable

1071
00:39:41,119 --> 00:39:43,119
of displaying images but it does support

1072
00:39:43,119 --> 00:39:44,640
this rfc

1073
00:39:44,640 --> 00:39:46,880
you can even connect to this website

1074
00:39:46,880 --> 00:39:49,839
login using this method with the ncsa

1075
00:39:49,839 --> 00:39:50,880
mosaic

1076
00:39:50,880 --> 00:39:53,119
web browser that is three decades old or

1077
00:39:53,119 --> 00:39:55,440
netscape navigator from back in the day

1078
00:39:55,440 --> 00:39:57,520
or even nowadays people who

1079
00:39:57,520 --> 00:39:59,119
who might be using the no script

1080
00:39:59,119 --> 00:40:02,079
exemption to disable javascript from

1081
00:40:02,079 --> 00:40:04,560
their web browsing

1082
00:40:04,560 --> 00:40:08,000
um so basically how to do that you may

1083
00:40:08,000 --> 00:40:10,160
you just make a page that has a link to

1084
00:40:10,160 --> 00:40:13,040
the login page that by default is

1085
00:40:13,040 --> 00:40:14,880
pointing to the http digest

1086
00:40:14,880 --> 00:40:17,520
authentication and if that's where they

1087
00:40:17,520 --> 00:40:19,520
are taken that's the end they just log

1088
00:40:19,520 --> 00:40:21,440
in with this password prompt and at

1089
00:40:21,440 --> 00:40:23,119
least their password is transmitted with

1090
00:40:23,119 --> 00:40:25,760
md5 so we are already doing better with

1091
00:40:25,760 --> 00:40:28,480
regards to where is about the cloudflare

1092
00:40:28,480 --> 00:40:29,599
and

1093
00:40:29,599 --> 00:40:32,079
corporate ssl money in the middle of

1094
00:40:32,079 --> 00:40:34,000
machines

1095
00:40:34,000 --> 00:40:36,560
but if the browser is running javascript

1096
00:40:36,560 --> 00:40:38,640
then you can have javascript overwriting

1097
00:40:38,640 --> 00:40:40,480
this link so that it's pointing to a web

1098
00:40:40,480 --> 00:40:42,480
form so that's what you see nowadays

1099
00:40:42,480 --> 00:40:45,680
it's just a nice rounded corners box

1100
00:40:45,680 --> 00:40:47,599
where you put a username password and so

1101
00:40:47,599 --> 00:40:51,520
on but here you have to emulate the

1102
00:40:51,520 --> 00:40:53,680
same step that might have happened

1103
00:40:53,680 --> 00:40:55,680
differently with different biases you

1104
00:40:55,680 --> 00:40:58,560
need to emulate this rfc 2069 formula of

1105
00:40:58,560 --> 00:41:01,040
md5 of md5 or basically username and

1106
00:41:01,040 --> 00:41:02,800
password which you can do with the

1107
00:41:02,800 --> 00:41:04,880
javascript library called from pages

1108
00:41:04,880 --> 00:41:07,760
home which is compatible with browsers

1109
00:41:07,760 --> 00:41:10,880
even from the early 2000s

1110
00:41:10,880 --> 00:41:13,040
and if that browser is so old really

1111
00:41:13,040 --> 00:41:15,440
that at this point it's already quite a

1112
00:41:15,440 --> 00:41:17,359
bit of time that has passed

1113
00:41:17,359 --> 00:41:20,000
then you can submit this result already

1114
00:41:20,000 --> 00:41:22,400
because you know that well if you are

1115
00:41:22,400 --> 00:41:24,319
going to take several seconds for

1116
00:41:24,319 --> 00:41:26,880
example to submit the login page people

1117
00:41:26,880 --> 00:41:28,400
might get worried that did they click

1118
00:41:28,400 --> 00:41:30,079
the button or is the website not

1119
00:41:30,079 --> 00:41:32,640
responsive or whatever so at every step

1120
00:41:32,640 --> 00:41:34,800
you are checking is it the half a second

1121
00:41:34,800 --> 00:41:37,200
or one second already if it is because

1122
00:41:37,200 --> 00:41:38,960
it's a very old machine very slow

1123
00:41:38,960 --> 00:41:40,480
javascript or something then you can

1124
00:41:40,480 --> 00:41:42,560
already submit here and the server will

1125
00:41:42,560 --> 00:41:44,400
take charge of the rest

1126
00:41:44,400 --> 00:41:48,079
so now after that um i'm showing as an

1127
00:41:48,079 --> 00:41:49,920
exercise basically to show how we can

1128
00:41:49,920 --> 00:41:51,280
start with one of the oldest

1129
00:41:51,280 --> 00:41:54,640
technologies md5 and make it secure in

1130
00:41:54,640 --> 00:41:56,480
the end is it time already for the

1131
00:41:56,480 --> 00:41:58,160
accelerated crypto well there's

1132
00:41:58,160 --> 00:42:00,079
something great with all the web

1133
00:42:00,079 --> 00:42:01,920
browsers nowadays except internet

1134
00:42:01,920 --> 00:42:04,319
explorer being annoying as always called

1135
00:42:04,319 --> 00:42:06,880
the set of crypto

1136
00:42:06,880 --> 00:42:07,839
so

1137
00:42:07,839 --> 00:42:09,839
if we want to support internet explorer

1138
00:42:09,839 --> 00:42:12,079
users we have to do a bit of javascript

1139
00:42:12,079 --> 00:42:13,920
instead not too much to not waste too

1140
00:42:13,920 --> 00:42:16,319
much time but basically what if we

1141
00:42:16,319 --> 00:42:18,960
simply loop chat 256 until the deadline

1142
00:42:18,960 --> 00:42:21,200
or until the target if uh

1143
00:42:21,200 --> 00:42:23,760
by luck it's actually fast enough well

1144
00:42:23,760 --> 00:42:26,640
we cannot do that just like that because

1145
00:42:26,640 --> 00:42:28,560
there's a risk of it eating its own

1146
00:42:28,560 --> 00:42:31,599
thing if it lands on a particular value

1147
00:42:31,599 --> 00:42:33,440
like there's a kind of collisions that

1148
00:42:33,440 --> 00:42:36,560
then go in the loop that's why pbk df2

1149
00:42:36,560 --> 00:42:38,560
was invented as a construct which is

1150
00:42:38,560 --> 00:42:39,520
kind of

1151
00:42:39,520 --> 00:42:41,520
duct taping this together but at least a

1152
00:42:41,520 --> 00:42:43,680
little bit safely

1153
00:42:43,680 --> 00:42:44,400
but

1154
00:42:44,400 --> 00:42:45,920
it also makes it

1155
00:42:45,920 --> 00:42:48,160
hard to

1156
00:42:48,160 --> 00:42:50,880
do to have to measure exact amount of

1157
00:42:50,880 --> 00:42:52,800
time of this so you cannot say i want to

1158
00:42:52,800 --> 00:42:54,880
do this for half a second you have to

1159
00:42:54,880 --> 00:42:57,680
try like for a thousand iterations and

1160
00:42:57,680 --> 00:42:58,720
then see

1161
00:42:58,720 --> 00:43:00,640
how long has it been let's try a bit

1162
00:43:00,640 --> 00:43:02,880
more and a bit more etc and it doesn't

1163
00:43:02,880 --> 00:43:05,760
accumulate because each time it's uh

1164
00:43:05,760 --> 00:43:09,040
doing its own thing so uh it's not easy

1165
00:43:09,040 --> 00:43:11,520
to just extend

1166
00:43:11,520 --> 00:43:13,760
and you have to be careful also there's

1167
00:43:13,760 --> 00:43:16,720
a pitfall with the pbk df2 and the hmac

1168
00:43:16,720 --> 00:43:18,960
within it that if the

1169
00:43:18,960 --> 00:43:20,800
input is longer than the size of the

1170
00:43:20,800 --> 00:43:23,040
hash then it will silently pre-hash it

1171
00:43:23,040 --> 00:43:25,680
which actually introduces some other

1172
00:43:25,680 --> 00:43:28,000
weaknesses some collisions and so on but

1173
00:43:28,000 --> 00:43:30,000
actually if we use my silly idea of

1174
00:43:30,000 --> 00:43:32,880
starting with md5 it's not a problem

1175
00:43:32,880 --> 00:43:36,240
so to recap basically we have

1176
00:43:36,240 --> 00:43:38,000
let's say something starting where all

1177
00:43:38,000 --> 00:43:40,400
the the server is doing all of the hard

1178
00:43:40,400 --> 00:43:41,200
work

1179
00:43:41,200 --> 00:43:42,319
and um

1180
00:43:42,319 --> 00:43:45,440
because i don't uh uh it's just simpler

1181
00:43:45,440 --> 00:43:48,800
to get it done with now we could also if

1182
00:43:48,800 --> 00:43:50,880
the client is capable of javascript web

1183
00:43:50,880 --> 00:43:53,839
assembly or the web crypto api we can

1184
00:43:53,839 --> 00:43:56,000
use asymmetric encryption to submit

1185
00:43:56,000 --> 00:43:57,760
whatever the result was at any

1186
00:43:57,760 --> 00:43:59,760
particular time so at any particular

1187
00:43:59,760 --> 00:44:02,160
step if it was md5 or ppk df2 or

1188
00:44:02,160 --> 00:44:03,680
whatever

1189
00:44:03,680 --> 00:44:04,400
so

1190
00:44:04,400 --> 00:44:06,480
if you were able to do it that's great

1191
00:44:06,480 --> 00:44:08,160
otherwise the server would take charge

1192
00:44:08,160 --> 00:44:11,440
of it like i said maybe then if it's a

1193
00:44:11,440 --> 00:44:13,200
browser capable of javascript it does

1194
00:44:13,200 --> 00:44:15,200
this bit of bbk df2

1195
00:44:15,200 --> 00:44:16,160
and then

1196
00:44:16,160 --> 00:44:19,200
uh if ideally if it's capable of that

1197
00:44:19,200 --> 00:44:22,960
the web crypto api also called settle

1198
00:44:22,960 --> 00:44:24,960
well it should be able to do this a bit

1199
00:44:24,960 --> 00:44:27,680
of serious crypto except argon 2 is not

1200
00:44:27,680 --> 00:44:30,079
yet supported in it so if you would

1201
00:44:30,079 --> 00:44:32,480
really like to see that being supported

1202
00:44:32,480 --> 00:44:35,119
hopefully soon please go there and like

1203
00:44:35,119 --> 00:44:37,599
this page or whatever i add your support

1204
00:44:37,599 --> 00:44:41,359
so that it gets added into the standard

1205
00:44:41,359 --> 00:44:44,079
so what can we do for now uh until then

1206
00:44:44,079 --> 00:44:44,880
then

1207
00:44:44,880 --> 00:44:47,839
we can use a great implementation that

1208
00:44:47,839 --> 00:44:50,160
someone did of argon 2 in the browser

1209
00:44:50,160 --> 00:44:52,079
trying to go as fast as possible not

1210
00:44:52,079 --> 00:44:54,319
doing just javascript but using web

1211
00:44:54,319 --> 00:44:55,839
assembly which is already two or three

1212
00:44:55,839 --> 00:44:57,920
times faster than javascript and going

1213
00:44:57,920 --> 00:45:00,560
even further than that a bit faster

1214
00:45:00,560 --> 00:45:02,720
using this themed extension so like

1215
00:45:02,720 --> 00:45:05,119
single instruction multiple data not to

1216
00:45:05,119 --> 00:45:08,319
be confused with the simt of gpus but as

1217
00:45:08,319 --> 00:45:10,160
you can see roughly it's still 10 times

1218
00:45:10,160 --> 00:45:13,280
slower than a native code execution so

1219
00:45:13,280 --> 00:45:15,119
that means like what we would like to be

1220
00:45:15,119 --> 00:45:17,680
running directly on the cpu of the

1221
00:45:17,680 --> 00:45:18,720
visitor

1222
00:45:18,720 --> 00:45:21,680
so it still may be a waste of time

1223
00:45:21,680 --> 00:45:24,160
so what should we do here can we design

1224
00:45:24,160 --> 00:45:26,160
our own algorithm and i'm sorry i really

1225
00:45:26,160 --> 00:45:29,399
need water

1226
00:45:39,280 --> 00:45:41,280
so usually designing your own crypto is

1227
00:45:41,280 --> 00:45:43,200
a big no-no but

1228
00:45:43,200 --> 00:45:44,400
jeff philippe

1229
00:45:44,400 --> 00:45:46,319
the organizer of the original password

1230
00:45:46,319 --> 00:45:47,920
hashing competition

1231
00:45:47,920 --> 00:45:49,599
i said that it's okay and even rob

1232
00:45:49,599 --> 00:45:51,520
graham for example it's a it's a great

1233
00:45:51,520 --> 00:45:53,280
way to learn things so let's see can we

1234
00:45:53,280 --> 00:45:55,440
learn something about this so i would

1235
00:45:55,440 --> 00:45:57,760
like to introduce my own algorithm

1236
00:45:57,760 --> 00:46:00,480
called somewhat memory hard function but

1237
00:46:00,480 --> 00:46:02,240
probably cryptographers will call it

1238
00:46:02,240 --> 00:46:04,640
shaking my head frustratedly and in the

1239
00:46:04,640 --> 00:46:06,400
end at least hopefully we can just agree

1240
00:46:06,400 --> 00:46:09,680
that it was sebastian merely having fun

1241
00:46:09,680 --> 00:46:12,400
so what if we start with bbk df2 well

1242
00:46:12,400 --> 00:46:13,839
it's not a good start because it's

1243
00:46:13,839 --> 00:46:15,839
basically a speed competition between

1244
00:46:15,839 --> 00:46:18,000
that land speed record car and your toy

1245
00:46:18,000 --> 00:46:20,880
car so not a good idea

1246
00:46:20,880 --> 00:46:23,920
can we get more data out of pbk df2 kind

1247
00:46:23,920 --> 00:46:26,480
of like those memory hard functions well

1248
00:46:26,480 --> 00:46:28,800
pbk df2 can give you more data you can

1249
00:46:28,800 --> 00:46:31,599
say give me like 1 000 bytes or whatever

1250
00:46:31,599 --> 00:46:34,640
but actually it's giving you many times

1251
00:46:34,640 --> 00:46:36,800
the same thing completely separate so

1252
00:46:36,800 --> 00:46:39,440
it's even more of a waste of time

1253
00:46:39,440 --> 00:46:41,599
what we want is another construct which

1254
00:46:41,599 --> 00:46:43,760
is supported by the crypto web crypto

1255
00:46:43,760 --> 00:46:46,640
api actually called hkdf that's great

1256
00:46:46,640 --> 00:46:48,960
where you it's giving you one hash

1257
00:46:48,960 --> 00:46:51,599
followed by another hash of this hash

1258
00:46:51,599 --> 00:46:53,040
basically it's a little bit more

1259
00:46:53,040 --> 00:46:55,520
complicated but keeping it simple it's a

1260
00:46:55,520 --> 00:46:57,520
hashing more and more of the same so

1261
00:46:57,520 --> 00:47:00,800
that you have this long chain forming

1262
00:47:00,800 --> 00:47:03,040
and

1263
00:47:03,040 --> 00:47:05,280
another thing that you can see with the

1264
00:47:05,280 --> 00:47:07,040
difference between cryptographers and

1265
00:47:07,040 --> 00:47:09,680
maybe real world attackers is that there

1266
00:47:09,680 --> 00:47:11,280
is a really annoying property in the

1267
00:47:11,280 --> 00:47:14,160
hkdf that is starting to count from one

1268
00:47:14,160 --> 00:47:17,280
and uh using a single byte to for this

1269
00:47:17,280 --> 00:47:19,359
counter so it means that it's capable of

1270
00:47:19,359 --> 00:47:22,960
giving you only up to 255 hashes instead

1271
00:47:22,960 --> 00:47:26,240
of 256 which would have been perfect in

1272
00:47:26,240 --> 00:47:27,520
terms of

1273
00:47:27,520 --> 00:47:29,119
high performance computing four

1274
00:47:29,119 --> 00:47:32,640
kilobytes is the size of a memory page

1275
00:47:32,640 --> 00:47:34,960
of a page of ram so it's like the if you

1276
00:47:34,960 --> 00:47:36,800
want to go as fast as possible you want

1277
00:47:36,800 --> 00:47:39,599
your data to fit within blocks of four

1278
00:47:39,599 --> 00:47:42,319
kilobytes but with hkdf it's not

1279
00:47:42,319 --> 00:47:44,319
possible so you might think well can we

1280
00:47:44,319 --> 00:47:47,599
use pvk df2 on the left side to kind of

1281
00:47:47,599 --> 00:47:49,760
combine those together and add this

1282
00:47:49,760 --> 00:47:52,800
missing hash each time so you can kind

1283
00:47:52,800 --> 00:47:54,160
of do it

1284
00:47:54,160 --> 00:47:56,000
and you can have this all this yellow

1285
00:47:56,000 --> 00:47:58,000
part that is kind of chaining still

1286
00:47:58,000 --> 00:48:00,240
itself together when you're using the

1287
00:48:00,240 --> 00:48:02,640
salt of the the last value as the salt

1288
00:48:02,640 --> 00:48:05,359
for the previous one and each for the

1289
00:48:05,359 --> 00:48:08,000
first yellow block of the

1290
00:48:08,000 --> 00:48:10,400
of the yellow part and then using the

1291
00:48:10,400 --> 00:48:13,839
pba kdf2 value on the left as the key so

1292
00:48:13,839 --> 00:48:14,720
it's

1293
00:48:14,720 --> 00:48:15,839
fairly

1294
00:48:15,839 --> 00:48:17,200
arguably

1295
00:48:17,200 --> 00:48:19,440
strong in terms of

1296
00:48:19,440 --> 00:48:22,400
deriving data but actually it's not very

1297
00:48:22,400 --> 00:48:25,119
good because we have this like i said at

1298
00:48:25,119 --> 00:48:27,359
the beginning that pbk df2 is giving

1299
00:48:27,359 --> 00:48:29,040
hashes that are completely independent

1300
00:48:29,040 --> 00:48:30,720
from each other so it's kind of what is

1301
00:48:30,720 --> 00:48:33,440
symbolized here with the cyan magenta

1302
00:48:33,440 --> 00:48:34,720
cells

1303
00:48:34,720 --> 00:48:36,400
so

1304
00:48:36,400 --> 00:48:39,200
what can we actually achieve so if we

1305
00:48:39,200 --> 00:48:42,480
run hkdf um like i was saying and we

1306
00:48:42,480 --> 00:48:44,720
want to run it really a lot like to

1307
00:48:44,720 --> 00:48:47,280
produce megabytes if not gigabytes of

1308
00:48:47,280 --> 00:48:50,960
data so here i put only about 50 hashes

1309
00:48:50,960 --> 00:48:53,040
just to have an idea because otherwise

1310
00:48:53,040 --> 00:48:54,960
more wouldn't fit on the screen and if

1311
00:48:54,960 --> 00:48:56,880
you imagine that the red part is the

1312
00:48:56,880 --> 00:48:59,599
amount of data that the attacker can

1313
00:48:59,599 --> 00:49:03,440
keep in mind by using this more limited

1314
00:49:03,440 --> 00:49:06,720
memory architectures like gpu fpga asic

1315
00:49:06,720 --> 00:49:09,200
and so on then you might think well

1316
00:49:09,200 --> 00:49:11,680
simply i can just spread all of that

1317
00:49:11,680 --> 00:49:14,559
data and then jump back in the times to

1318
00:49:14,559 --> 00:49:16,880
force the attacker to recalculate all

1319
00:49:16,880 --> 00:49:18,960
those hashes from the beginning then

1320
00:49:18,960 --> 00:49:22,000
maybe i do a jump forward in which case

1321
00:49:22,000 --> 00:49:23,760
the attacker actually is a bit luckier

1322
00:49:23,760 --> 00:49:25,440
doesn't have to go from the beginning

1323
00:49:25,440 --> 00:49:27,680
and just start from where it was and get

1324
00:49:27,680 --> 00:49:29,920
to that position each time so it looks

1325
00:49:29,920 --> 00:49:31,920
like you are doing making it easy for

1326
00:49:31,920 --> 00:49:34,000
yourself and hard for the attacker

1327
00:49:34,000 --> 00:49:36,160
because roughly speaking there's a one

1328
00:49:36,160 --> 00:49:38,160
in two chance that the attacker has to

1329
00:49:38,160 --> 00:49:40,720
go from the beginning or from wherever

1330
00:49:40,720 --> 00:49:43,200
it was so you would think that each time

1331
00:49:43,200 --> 00:49:45,200
roughly on average the attacker has to

1332
00:49:45,200 --> 00:49:46,960
recalculate half of the memory that

1333
00:49:46,960 --> 00:49:48,559
you're using each time

1334
00:49:48,559 --> 00:49:51,520
but unfortunately the attacker is clever

1335
00:49:51,520 --> 00:49:53,839
and can optimize so they can

1336
00:49:53,839 --> 00:49:56,800
spread out also their memory as a sort

1337
00:49:56,800 --> 00:49:59,440
of save point for example to just have

1338
00:49:59,440 --> 00:50:01,599
to go from the nearest save point to

1339
00:50:01,599 --> 00:50:03,920
wherever you jumped and then your

1340
00:50:03,920 --> 00:50:06,559
algorithm is kind of defeated

1341
00:50:06,559 --> 00:50:10,400
so how can we make it one way both ways

1342
00:50:10,400 --> 00:50:12,800
not really can we modify the data each

1343
00:50:12,800 --> 00:50:14,559
time we land somewhere

1344
00:50:14,559 --> 00:50:16,319
that would be good but in the end

1345
00:50:16,319 --> 00:50:18,319
probably we want to have modified

1346
00:50:18,319 --> 00:50:20,319
everything so let's see at how is it

1347
00:50:20,319 --> 00:50:24,079
being done in a proper existing memory

1348
00:50:24,079 --> 00:50:27,040
hard functions like script so scripts

1349
00:50:27,040 --> 00:50:30,240
does actually with pbk df2 just to have

1350
00:50:30,240 --> 00:50:32,160
a lot of data to play with and doesn't

1351
00:50:32,160 --> 00:50:34,000
care that it's completely independent

1352
00:50:34,000 --> 00:50:35,680
from each other because then they are

1353
00:50:35,680 --> 00:50:38,720
doing the hashing one by one so they say

1354
00:50:38,720 --> 00:50:41,520
for example the very last hash and input

1355
00:50:41,520 --> 00:50:43,520
it uh with some

1356
00:50:43,520 --> 00:50:46,559
counter value basically into this bright

1357
00:50:46,559 --> 00:50:48,880
green arrow which is symbolizing a new

1358
00:50:48,880 --> 00:50:49,760
hash

1359
00:50:49,760 --> 00:50:50,960
and

1360
00:50:50,960 --> 00:50:53,040
taking the result of that combining it

1361
00:50:53,040 --> 00:50:55,359
with somewhere else that is like

1362
00:50:55,359 --> 00:50:58,000
randomly uh predictably but randomly

1363
00:50:58,000 --> 00:50:59,040
chosen

1364
00:50:59,040 --> 00:51:01,119
in a way that is unpredictable for the

1365
00:51:01,119 --> 00:51:03,760
attacker sorry i mean reproducible not

1366
00:51:03,760 --> 00:51:05,680
predictable and

1367
00:51:05,680 --> 00:51:08,559
then it's hashing one by one each time

1368
00:51:08,559 --> 00:51:10,720
until it reaches the final point which

1369
00:51:10,720 --> 00:51:12,960
is considered the final hash that you

1370
00:51:12,960 --> 00:51:15,359
would store in your database so this way

1371
00:51:15,359 --> 00:51:17,680
it's really forcing an attacker that

1372
00:51:17,680 --> 00:51:20,079
doesn't have as much ram as you to be

1373
00:51:20,079 --> 00:51:22,559
recalculating it a lot it has to

1374
00:51:22,559 --> 00:51:25,280
recalculate maybe everything this pbk

1375
00:51:25,280 --> 00:51:28,160
df2 at the top every single time

1376
00:51:28,160 --> 00:51:30,160
because the attacker doesn't know where

1377
00:51:30,160 --> 00:51:33,599
you will be jumping from each time

1378
00:51:33,599 --> 00:51:36,559
but for us it's not good because uh

1379
00:51:36,559 --> 00:51:38,480
in the web browser we cannot afford to

1380
00:51:38,480 --> 00:51:40,800
do hash one by one like that so let's

1381
00:51:40,800 --> 00:51:43,599
look at argon two the other now the best

1382
00:51:43,599 --> 00:51:46,000
practice let's see how they do it so

1383
00:51:46,000 --> 00:51:47,920
they start by putting two columns

1384
00:51:47,920 --> 00:51:50,400
basically that are completely unrelated

1385
00:51:50,400 --> 00:51:52,319
but created at the same time so that's

1386
00:51:52,319 --> 00:51:53,920
the first two columns that are kind of

1387
00:51:53,920 --> 00:51:56,319
the same color each time and then they

1388
00:51:56,319 --> 00:51:57,520
start

1389
00:51:57,520 --> 00:51:59,520
so the rows are different threads so

1390
00:51:59,520 --> 00:52:01,119
it's great in terms of parallel

1391
00:52:01,119 --> 00:52:04,319
processing and they take the value from

1392
00:52:04,319 --> 00:52:06,720
the previous cell on the same row

1393
00:52:06,720 --> 00:52:08,640
combined with uh somewhere not

1394
00:52:08,640 --> 00:52:10,960
predictable but reproducible uh like

1395
00:52:10,960 --> 00:52:14,319
this c1 r4 column one row four that gets

1396
00:52:14,319 --> 00:52:16,640
combined into the result column three

1397
00:52:16,640 --> 00:52:19,440
row one and same thing each time to

1398
00:52:19,440 --> 00:52:21,680
create each of those new cells and try

1399
00:52:21,680 --> 00:52:23,440
to create

1400
00:52:23,440 --> 00:52:25,520
maybe even a gigabyte or at least a lots

1401
00:52:25,520 --> 00:52:27,359
of megabytes to

1402
00:52:27,359 --> 00:52:29,760
out do the attacker in terms of memory

1403
00:52:29,760 --> 00:52:30,800
usage

1404
00:52:30,800 --> 00:52:33,200
towards the right side of the screen

1405
00:52:33,200 --> 00:52:35,200
which again means that we have to do all

1406
00:52:35,200 --> 00:52:38,400
of these hash by hash

1407
00:52:38,400 --> 00:52:40,559
calls which we cannot actually afford in

1408
00:52:40,559 --> 00:52:42,079
the web browser

1409
00:52:42,079 --> 00:52:44,480
like i said because there's a web worker

1410
00:52:44,480 --> 00:52:46,240
overhead so whenever you call the web

1411
00:52:46,240 --> 00:52:48,960
crypto api there's actually a starting

1412
00:52:48,960 --> 00:52:50,000
delay

1413
00:52:50,000 --> 00:52:50,960
and the

1414
00:52:50,960 --> 00:52:52,559
if you want to do it one by one of

1415
00:52:52,559 --> 00:52:54,319
course you can do it with javascript or

1416
00:52:54,319 --> 00:52:56,720
web assembly but as we know it's slow so

1417
00:52:56,720 --> 00:52:59,440
it quickly adds up and ends up being a

1418
00:52:59,440 --> 00:53:01,599
waste of time so what can we do to go

1419
00:53:01,599 --> 00:53:04,720
faster so argon as in argon one not

1420
00:53:04,720 --> 00:53:08,000
argon 2 originally used aes even the

1421
00:53:08,000 --> 00:53:10,480
actually the accelerated aes from the

1422
00:53:10,480 --> 00:53:13,839
intel cpus or what intel calls aes and i

1423
00:53:13,839 --> 00:53:16,000
and there's an equivalent in the amd

1424
00:53:16,000 --> 00:53:18,000
cpus

1425
00:53:18,000 --> 00:53:20,160
but then argon 2 was

1426
00:53:20,160 --> 00:53:22,559
released kind of because there were some

1427
00:53:22,559 --> 00:53:24,960
worries about doing it this way so they

1428
00:53:24,960 --> 00:53:27,520
replaced this encryption function aes

1429
00:53:27,520 --> 00:53:30,160
with the hash blake2b and actually which

1430
00:53:30,160 --> 00:53:33,280
they even tuned into a smaller faster

1431
00:53:33,280 --> 00:53:35,119
function to do all this one by one

1432
00:53:35,119 --> 00:53:37,839
hashing called blanca

1433
00:53:37,839 --> 00:53:40,079
so what can we what else can we do maybe

1434
00:53:40,079 --> 00:53:42,960
we can use some other great uh r d from

1435
00:53:42,960 --> 00:53:45,920
uh jean-philippe masso again uh like his

1436
00:53:45,920 --> 00:53:48,559
nox encryption algorithm which came

1437
00:53:48,559 --> 00:53:50,800
after the previous password happy

1438
00:53:50,800 --> 00:53:52,960
competition it was released or at least

1439
00:53:52,960 --> 00:53:56,240
the latest version was released in 2016.

1440
00:53:56,240 --> 00:53:59,200
um but again maybe that's something

1441
00:53:59,200 --> 00:54:01,280
we're not too sure about or at least i

1442
00:54:01,280 --> 00:54:03,119
not being a cryptographer i guess if

1443
00:54:03,119 --> 00:54:05,040
they already deemed the first time that

1444
00:54:05,040 --> 00:54:06,960
it was not a good idea to use a yes

1445
00:54:06,960 --> 00:54:10,960
maybe nox which is much faster than aes

1446
00:54:10,960 --> 00:54:13,040
would not be a good idea either so what

1447
00:54:13,040 --> 00:54:15,040
else can we do

1448
00:54:15,040 --> 00:54:17,359
what can we call from the web browser

1449
00:54:17,359 --> 00:54:19,760
that can manipulate a lot of data in one

1450
00:54:19,760 --> 00:54:22,640
go so there is webgl as in opengl but

1451
00:54:22,640 --> 00:54:24,800
for the web where maybe we can ask the

1452
00:54:24,800 --> 00:54:26,880
browser to take this table and do some

1453
00:54:26,880 --> 00:54:29,520
matrix multiplication or other sorts of

1454
00:54:29,520 --> 00:54:32,400
3d processing just to mess with the data

1455
00:54:32,400 --> 00:54:34,000
enough that it would be annoying to the

1456
00:54:34,000 --> 00:54:35,760
attacker

1457
00:54:35,760 --> 00:54:38,720
we could maybe even use web cl as in the

1458
00:54:38,720 --> 00:54:40,720
compute language

1459
00:54:40,720 --> 00:54:42,640
which unfortunately is not getting much

1460
00:54:42,640 --> 00:54:44,559
adoption for example firefox is

1461
00:54:44,559 --> 00:54:46,400
preferring webgl compute shutters

1462
00:54:46,400 --> 00:54:47,680
instead

1463
00:54:47,680 --> 00:54:50,079
but now we are realizing that well we

1464
00:54:50,079 --> 00:54:52,319
are using kind of the same techniques as

1465
00:54:52,319 --> 00:54:55,359
the attacker in the gpu space at least

1466
00:54:55,359 --> 00:54:56,319
so

1467
00:54:56,319 --> 00:54:58,000
being in the web browser there's no way

1468
00:54:58,000 --> 00:54:59,920
that we can be faster than the attacker

1469
00:54:59,920 --> 00:55:03,119
with the gpu because our web gpu kind of

1470
00:55:03,119 --> 00:55:04,960
technology would be are of course

1471
00:55:04,960 --> 00:55:07,280
already slower

1472
00:55:07,280 --> 00:55:09,680
so like i hinted that at the beginning

1473
00:55:09,680 --> 00:55:11,839
um maybe we can do password dependent

1474
00:55:11,839 --> 00:55:14,000
execution so

1475
00:55:14,000 --> 00:55:15,280
you might have noticed when i was

1476
00:55:15,280 --> 00:55:17,760
talking about argon 2 there's argon 2i

1477
00:55:17,760 --> 00:55:20,400
as in the password independent

1478
00:55:20,400 --> 00:55:22,880
memory access patterns so it means that

1479
00:55:22,880 --> 00:55:25,440
it's great for a smart card or somewhere

1480
00:55:25,440 --> 00:55:27,200
where you might be worried about someone

1481
00:55:27,200 --> 00:55:29,280
doing side channel attacks like i was

1482
00:55:29,280 --> 00:55:30,559
showing at the very beginning with

1483
00:55:30,559 --> 00:55:32,480
lasers or messing with the power things

1484
00:55:32,480 --> 00:55:33,520
like that

1485
00:55:33,520 --> 00:55:37,440
so it's actually very complicated and

1486
00:55:37,440 --> 00:55:40,000
in general argon 2d being a password

1487
00:55:40,000 --> 00:55:42,720
dependent uh memory access

1488
00:55:42,720 --> 00:55:44,799
you get better security for the same

1489
00:55:44,799 --> 00:55:47,040
amount of ram out of it but if you don't

1490
00:55:47,040 --> 00:55:49,040
know if you are not choose if you are

1491
00:55:49,040 --> 00:55:50,960
not sure which one to choose basically

1492
00:55:50,960 --> 00:55:53,119
you have to choose argon 2 id which does

1493
00:55:53,119 --> 00:55:55,200
half of the execution with password

1494
00:55:55,200 --> 00:55:56,640
independent and the other half with

1495
00:55:56,640 --> 00:55:59,920
password dependent or input dependent um

1496
00:55:59,920 --> 00:56:00,799
so

1497
00:56:00,799 --> 00:56:02,880
let's kind of say and take this same

1498
00:56:02,880 --> 00:56:05,520
distinction and what if we make this a

1499
00:56:05,520 --> 00:56:08,000
execution in our algorithm that is

1500
00:56:08,000 --> 00:56:10,240
completely dependent on the input so

1501
00:56:10,240 --> 00:56:12,079
that would be really nice to mess with

1502
00:56:12,079 --> 00:56:14,240
the attackers using a gpu at least

1503
00:56:14,240 --> 00:56:16,319
because they wouldn't be able to do this

1504
00:56:16,319 --> 00:56:18,480
a single instruction multiple threads

1505
00:56:18,480 --> 00:56:20,880
but at the same time it's a

1506
00:56:20,880 --> 00:56:23,599
the kind of thing we criticize at work

1507
00:56:23,599 --> 00:56:25,520
for example in evaluating security

1508
00:56:25,520 --> 00:56:28,319
products it's exactly how a computer or

1509
00:56:28,319 --> 00:56:31,359
a chip might leak a secret key because

1510
00:56:31,359 --> 00:56:33,359
it's power consumption for example or

1511
00:56:33,359 --> 00:56:36,079
its interference whatever signal leakage

1512
00:56:36,079 --> 00:56:38,400
is leaking and it's related to the

1513
00:56:38,400 --> 00:56:40,400
password or the encryption key so it

1514
00:56:40,400 --> 00:56:43,119
doesn't sound like a solution either

1515
00:56:43,119 --> 00:56:44,880
there's something that we might be able

1516
00:56:44,880 --> 00:56:47,200
to leverage here that is quite unique to

1517
00:56:47,200 --> 00:56:49,119
this particular approach

1518
00:56:49,119 --> 00:56:50,559
is rate limiting

1519
00:56:50,559 --> 00:56:53,200
because as you remember from those uh

1520
00:56:53,200 --> 00:56:56,160
slides with the big blocks and so on

1521
00:56:56,160 --> 00:56:59,440
and web technology web 2.0 3.0 whatever

1522
00:56:59,440 --> 00:57:02,960
it is nowadays um you can easily ask

1523
00:57:02,960 --> 00:57:04,640
interact with the server from your

1524
00:57:04,640 --> 00:57:06,880
javascript what if for example you do a

1525
00:57:06,880 --> 00:57:08,559
bit of hashing and

1526
00:57:08,559 --> 00:57:10,559
you see that you still have time but

1527
00:57:10,559 --> 00:57:12,480
before you continue you want to ask the

1528
00:57:12,480 --> 00:57:14,960
server to put its little grain of salt

1529
00:57:14,960 --> 00:57:17,440
into it so that's what the hmac function

1530
00:57:17,440 --> 00:57:19,599
would do for example then the continue

1531
00:57:19,599 --> 00:57:21,599
the client continues with phase two up

1532
00:57:21,599 --> 00:57:23,440
until a certain point like half a second

1533
00:57:23,440 --> 00:57:25,359
and one second or whatever and if there

1534
00:57:25,359 --> 00:57:27,520
is still time we can ask the server

1535
00:57:27,520 --> 00:57:29,920
again to put its grain of salt maybe

1536
00:57:29,920 --> 00:57:31,520
even more securely with the hardware

1537
00:57:31,520 --> 00:57:33,680
security module so that the attacker

1538
00:57:33,680 --> 00:57:36,160
wouldn't even be able to

1539
00:57:36,160 --> 00:57:38,240
try to crack the password at high speed

1540
00:57:38,240 --> 00:57:40,319
much faster than the actual security

1541
00:57:40,319 --> 00:57:42,799
hardware security module can do because

1542
00:57:42,799 --> 00:57:45,680
hsms are actually usually quite slow

1543
00:57:45,680 --> 00:57:48,559
unless you buy a really expensive one

1544
00:57:48,559 --> 00:57:51,359
so if you're thinking well

1545
00:57:51,359 --> 00:57:53,359
am i wasting your time

1546
00:57:53,359 --> 00:57:56,079
i'm kind of agreeing at least so far

1547
00:57:56,079 --> 00:57:56,880
that

1548
00:57:56,880 --> 00:57:59,440
i've put a ridiculous amount of effort

1549
00:57:59,440 --> 00:58:01,839
into all of this and i would really like

1550
00:58:01,839 --> 00:58:03,839
to be able to go swim and think of

1551
00:58:03,839 --> 00:58:06,079
actual pebbles instead of cumulative

1552
00:58:06,079 --> 00:58:07,760
pebbling complexity in designing all

1553
00:58:07,760 --> 00:58:09,359
these algorithms

1554
00:58:09,359 --> 00:58:10,799
so that's why i'm launching a new

1555
00:58:10,799 --> 00:58:12,720
password hashing competition to find a

1556
00:58:12,720 --> 00:58:15,920
new standard like the original argon 2.

1557
00:58:15,920 --> 00:58:18,880
so the original worked from late 2012

1558
00:58:18,880 --> 00:58:22,160
but it's actually started in early 2013

1559
00:58:22,160 --> 00:58:25,440
and they elected the winner in 2015 um

1560
00:58:25,440 --> 00:58:27,440
but there are other notable algorithms

1561
00:58:27,440 --> 00:58:29,520
like yes script which you see a lot in

1562
00:58:29,520 --> 00:58:31,280
cryptocurrencies that originally were

1563
00:58:31,280 --> 00:58:33,760
using script so now they are using

1564
00:58:33,760 --> 00:58:36,799
jascrypt as an easy upgrade path lira 2

1565
00:58:36,799 --> 00:58:38,559
also is getting a lot of deployment in

1566
00:58:38,559 --> 00:58:41,200
cryptocurrencies katena has

1567
00:58:41,200 --> 00:58:42,960
actually something that

1568
00:58:42,960 --> 00:58:44,319
i would really like here but

1569
00:58:44,319 --> 00:58:46,960
unfortunately it's not doable in the web

1570
00:58:46,960 --> 00:58:49,599
client it's this server relief and same

1571
00:58:49,599 --> 00:58:52,079
idea or even more advanced with macwa

1572
00:58:52,079 --> 00:58:54,160
another notable candidate in the

1573
00:58:54,160 --> 00:58:56,799
previous phd which has this trustless

1574
00:58:56,799 --> 00:58:58,880
delegation which means that you can

1575
00:58:58,880 --> 00:59:00,240
delegate the

1576
00:59:00,240 --> 00:59:02,480
hard work to even something completely

1577
00:59:02,480 --> 00:59:04,640
different like some uh machine in the

1578
00:59:04,640 --> 00:59:06,559
cloud or whatever so you can see all

1579
00:59:06,559 --> 00:59:09,599
this original data in the original phd

1580
00:59:09,599 --> 00:59:10,720
website

1581
00:59:10,720 --> 00:59:12,640
and why do i want to do a new one well

1582
00:59:12,640 --> 00:59:15,200
you can see at pasoscon 2016 which was a

1583
00:59:15,200 --> 00:59:18,079
mixed with b-sides um

1584
00:59:18,079 --> 00:59:20,319
for example was asking what's up argan

1585
00:59:20,319 --> 00:59:23,119
too so asking like what are the

1586
00:59:23,119 --> 00:59:25,839
evolutions looking at improvements uh

1587
00:59:25,839 --> 00:59:27,839
since then because it's uh ongoing

1588
00:59:27,839 --> 00:59:29,920
discussion there's always newer better

1589
00:59:29,920 --> 00:59:32,559
and better ideas and recently actually

1590
00:59:32,559 --> 00:59:33,520
the

1591
00:59:33,520 --> 00:59:35,200
cat got out of the bag because i was

1592
00:59:35,200 --> 00:59:37,520
discussing that with him privately and

1593
00:59:37,520 --> 00:59:39,359
with some misunderstanding he asked

1594
00:59:39,359 --> 00:59:41,119
about it publicly so

1595
00:59:41,119 --> 00:59:42,000
then

1596
00:59:42,000 --> 00:59:43,920
all of a sudden everyone agreed that we

1597
00:59:43,920 --> 00:59:47,440
have to do a new phc and so he gives his

1598
00:59:47,440 --> 00:59:49,359
blessing even jokingly saying that we

1599
00:59:49,359 --> 00:59:50,960
should make a blockchain company out of

1600
00:59:50,960 --> 00:59:53,599
it but uh hopefully just jokingly

1601
00:59:53,599 --> 00:59:55,680
so seriously like i said there's the

1602
00:59:55,680 --> 00:59:57,920
considerations of argon 2d versus argon

1603
00:59:57,920 --> 01:00:01,119
2i versus argon 2id and all these new

1604
01:00:01,119 --> 01:00:02,960
attacks and

1605
01:00:02,960 --> 01:00:05,440
improvements to argon 2 itself so it's

1606
01:00:05,440 --> 01:00:07,680
not perfect yet especially in the field

1607
01:00:07,680 --> 01:00:09,599
of password independent memory hard

1608
01:00:09,599 --> 01:00:11,599
functions it's not a completely solved

1609
01:00:11,599 --> 01:00:14,000
problem yet there's lots to do yet like

1610
01:00:14,000 --> 01:00:15,440
i said there's a bandwidth heart

1611
01:00:15,440 --> 01:00:17,200
functions as a kind of

1612
01:00:17,200 --> 01:00:18,880
it's not really completely new but it's

1613
01:00:18,880 --> 01:00:21,440
getting attention only now and other new

1614
01:00:21,440 --> 01:00:23,200
ideas maybe like this cache timing

1615
01:00:23,200 --> 01:00:24,559
safety

1616
01:00:24,559 --> 01:00:26,720
and new algorithms that came after the

1617
01:00:26,720 --> 01:00:28,799
previous phd so there was this balloon

1618
01:00:28,799 --> 01:00:30,799
hashing as a password protection

1619
01:00:30,799 --> 01:00:33,680
algorithm which came out after 2015

1620
01:00:33,680 --> 01:00:36,559
and this random x about the monero

1621
01:00:36,559 --> 01:00:38,960
cryptocurrency that seems to have lots

1622
01:00:38,960 --> 01:00:41,359
of excellent ideas that came out in 2019

1623
01:00:41,359 --> 01:00:44,880
or 2018 and finally this one that is uh

1624
01:00:44,880 --> 01:00:47,200
dearest to me the client-side hashing

1625
01:00:47,200 --> 01:00:49,119
especially for web clients

1626
01:00:49,119 --> 01:00:50,079
that

1627
01:00:50,079 --> 01:00:53,760
we need to consider hopefully and i

1628
01:00:53,760 --> 01:00:55,200
would like also to try a different

1629
01:00:55,200 --> 01:00:57,119
approach this time as in having a

1630
01:00:57,119 --> 01:01:00,319
standardized api making it less academic

1631
01:01:00,319 --> 01:01:03,040
like less math formula and more

1632
01:01:03,040 --> 01:01:04,000
code

1633
01:01:04,000 --> 01:01:05,920
especially implementations for hashcat

1634
01:01:05,920 --> 01:01:07,599
john the ripper or that sort of thing

1635
01:01:07,599 --> 01:01:09,599
would be really welcome

1636
01:01:09,599 --> 01:01:11,520
code ideally would speak more than the

1637
01:01:11,520 --> 01:01:13,280
paper and the paper itself would be more

1638
01:01:13,280 --> 01:01:15,839
like a request for comment actually and

1639
01:01:15,839 --> 01:01:17,520
with particular attention to future

1640
01:01:17,520 --> 01:01:19,200
proofing being able to swap out

1641
01:01:19,200 --> 01:01:20,960
algorithms things like that

1642
01:01:20,960 --> 01:01:24,079
um so i've already got several people

1643
01:01:24,079 --> 01:01:27,280
involved i'm uh honored actually to have

1644
01:01:27,280 --> 01:01:29,520
even alec muffet that i mentioned there

1645
01:01:29,520 --> 01:01:31,680
because his tool his crack tool that was

1646
01:01:31,680 --> 01:01:34,000
cracking passwords already 30 years ago

1647
01:01:34,000 --> 01:01:35,520
when he released it

1648
01:01:35,520 --> 01:01:37,359
is on board with this i haven't had a

1649
01:01:37,359 --> 01:01:39,599
chance to ask their loved heavy

1650
01:01:39,599 --> 01:01:42,160
industries yet but they were speaking at

1651
01:01:42,160 --> 01:01:42,960
the

1652
01:01:42,960 --> 01:01:44,960
previous passwords con so i'm sure they

1653
01:01:44,960 --> 01:01:46,319
would be interested

1654
01:01:46,319 --> 01:01:48,240
there's a sci engines the makers of

1655
01:01:48,240 --> 01:01:51,119
those fpga password crackers that are

1656
01:01:51,119 --> 01:01:52,720
already on board

1657
01:01:52,720 --> 01:01:54,319
as you know well i'm part of team

1658
01:01:54,319 --> 01:01:55,280
hashgraph

1659
01:01:55,280 --> 01:01:57,200
thankfully quite a few members are on

1660
01:01:57,200 --> 01:01:59,520
board there's

1661
01:01:59,520 --> 01:02:01,920
the company that jeremy gosney founded

1662
01:02:01,920 --> 01:02:03,680
to sell these password cracking machines

1663
01:02:03,680 --> 01:02:06,160
at least based on gpus and john the

1664
01:02:06,160 --> 01:02:08,960
ripper also a couple of people have

1665
01:02:08,960 --> 01:02:11,359
discussed already with

1666
01:02:11,359 --> 01:02:12,319
so

1667
01:02:12,319 --> 01:02:14,799
it's not the very start yet but i

1668
01:02:14,799 --> 01:02:17,839
created this website you can bookmark it

1669
01:02:17,839 --> 01:02:20,480
or something and please stay tuned for

1670
01:02:20,480 --> 01:02:23,280
more soon

1671
01:02:25,520 --> 01:02:28,839
thanks everyone

