1
00:00:09,040 --> 00:00:11,920
welcome i'm jean-francois and this is

2
00:00:11,920 --> 00:00:12,960
probably

3
00:00:12,960 --> 00:00:14,559
the longest title you'll ever see on a

4
00:00:14,559 --> 00:00:16,640
presentation so it's a trip down history

5
00:00:16,640 --> 00:00:18,400
lane on how to defeat edrs and user

6
00:00:18,400 --> 00:00:20,560
modes how to do it using the invoke and

7
00:00:20,560 --> 00:00:22,480
how these conference talks inspires

8
00:00:22,480 --> 00:00:23,439
others

9
00:00:23,439 --> 00:00:25,519
so without further ado let's

10
00:00:25,519 --> 00:00:27,199
talk about the story on how this

11
00:00:27,199 --> 00:00:29,359
presentation came to end

12
00:00:29,359 --> 00:00:31,519
so a few months ago i actually did a

13
00:00:31,519 --> 00:00:33,520
similar presentation for the company i

14
00:00:33,520 --> 00:00:36,239
used to work for it's called inviso

15
00:00:36,239 --> 00:00:38,239
and it was posted on youtube

16
00:00:38,239 --> 00:00:40,800
and then after a few weeks i checked my

17
00:00:40,800 --> 00:00:43,360
twitter like probably most of you do as

18
00:00:43,360 --> 00:00:44,800
infosec news travels faster around

19
00:00:44,800 --> 00:00:47,760
twitter that's what we all do and i saw

20
00:00:47,760 --> 00:00:49,760
this tweet from a guy i've never heard

21
00:00:49,760 --> 00:00:50,559
of

22
00:00:50,559 --> 00:00:52,800
his twitter handle is glass virus

23
00:00:52,800 --> 00:00:55,120
and he said blog post plus two release

24
00:00:55,120 --> 00:00:58,000
it said avn edr bypasses in like the

25
00:00:58,000 --> 00:00:59,920
tweets that interests me a lot because

26
00:00:59,920 --> 00:01:02,879
i'm a red teamer so edr and ev bypasses

27
00:01:02,879 --> 00:01:05,438
is kind of my jam i open the blog posts

28
00:01:05,438 --> 00:01:07,600
and i actually see my name there as well

29
00:01:07,600 --> 00:01:09,520
joe mas so that's me

30
00:01:09,520 --> 00:01:12,080
and i was pretty surprised by this i

31
00:01:12,080 --> 00:01:13,920
looked into the codes i liked it a lot

32
00:01:13,920 --> 00:01:15,759
and then i actually reached out to class

33
00:01:15,759 --> 00:01:17,600
virus he's actually right here

34
00:01:17,600 --> 00:01:20,240
and i told him hey why don't we combine

35
00:01:20,240 --> 00:01:22,240
forces and present together because i

36
00:01:22,240 --> 00:01:24,560
like the tool you use my techniques in

37
00:01:24,560 --> 00:01:26,320
your tool so let's just do it let's

38
00:01:26,320 --> 00:01:28,159
collaborate

39
00:01:28,159 --> 00:01:30,799
and that's how that ended up so what are

40
00:01:30,799 --> 00:01:33,200
we actually going to talk about well i

41
00:01:33,200 --> 00:01:36,400
actually made a short video to tell you

42
00:01:36,400 --> 00:01:38,400
has this ever happened to you you have

43
00:01:38,400 --> 00:01:40,640
been hired to do a penetration test and

44
00:01:40,640 --> 00:01:42,240
need to get a reverse shell or other

45
00:01:42,240 --> 00:01:43,840
payload on your target but the

46
00:01:43,840 --> 00:01:46,880
anti-virus or edr is in the way today is

47
00:01:46,880 --> 00:01:49,680
your lucky day in the next 45 to 60

48
00:01:49,680 --> 00:01:52,240
minutes john and alessandro will walk

49
00:01:52,240 --> 00:01:53,600
you through the history of cyber

50
00:01:53,600 --> 00:01:55,680
security and tell you how modern

51
00:01:55,680 --> 00:01:58,799
adversaries evade alerts in user land so

52
00:01:58,799 --> 00:02:02,560
sit back and enjoy the presentation

53
00:02:02,560 --> 00:02:06,079
so yeah that's a small advertisement

54
00:02:06,079 --> 00:02:07,840
i actually hired someone to do the

55
00:02:07,840 --> 00:02:10,399
voiceover and i can't imagine what that

56
00:02:10,399 --> 00:02:12,000
guy must have felt like when actually

57
00:02:12,000 --> 00:02:13,760
talking about that stuff

58
00:02:13,760 --> 00:02:15,360
but yeah he got a small payday out of it

59
00:02:15,360 --> 00:02:17,920
i used fiverr to do this so yeah no

60
00:02:17,920 --> 00:02:19,920
questions asked he just talked about it

61
00:02:19,920 --> 00:02:21,360
and yeah there you go

62
00:02:21,360 --> 00:02:23,920
so my name is jeffree swamas i'm now a

63
00:02:23,920 --> 00:02:25,760
senior consultant at trusted tech i'm

64
00:02:25,760 --> 00:02:28,160
also a sans instructor i teach the

65
00:02:28,160 --> 00:02:31,120
security 699 purple team so if you want

66
00:02:31,120 --> 00:02:33,040
to talk about sans purple teaming or red

67
00:02:33,040 --> 00:02:34,959
teaming come see me after the talk i

68
00:02:34,959 --> 00:02:37,280
love socializing so there you go you can

69
00:02:37,280 --> 00:02:38,800
also find me on twitter linkedin on

70
00:02:38,800 --> 00:02:39,920
github

71
00:02:39,920 --> 00:02:41,360
and i publish

72
00:02:41,360 --> 00:02:43,040
barely working tools that's also my

73
00:02:43,040 --> 00:02:44,879
twitter if you if you follow me on the

74
00:02:44,879 --> 00:02:46,480
on the twitter handles you'll actually

75
00:02:46,480 --> 00:02:48,400
see in my banner i like to call myself a

76
00:02:48,400 --> 00:02:50,560
tinkerer i publish codes it doesn't

77
00:02:50,560 --> 00:02:52,720
always work as intended but usually it

78
00:02:52,720 --> 00:02:54,080
does

79
00:02:54,080 --> 00:02:56,000
i just do this because i like

80
00:02:56,000 --> 00:02:58,400
learning and coding at the same time

81
00:02:58,400 --> 00:03:00,319
i like sharing knowledge as well so if

82
00:03:00,319 --> 00:03:02,400
you see some code examples from me

83
00:03:02,400 --> 00:03:03,760
you can definitely check it out on

84
00:03:03,760 --> 00:03:04,959
github

85
00:03:04,959 --> 00:03:06,560
then yeah i have my co-presenter here

86
00:03:06,560 --> 00:03:09,200
with me i'm digital media i'm alessandra

87
00:03:09,200 --> 00:03:10,959
mckenzie i'm a senior security

88
00:03:10,959 --> 00:03:13,840
consultant i'm working for bsi besides a

89
00:03:13,840 --> 00:03:15,840
nice environment nice company is a big

90
00:03:15,840 --> 00:03:18,640
company actually is involved with um

91
00:03:18,640 --> 00:03:21,519
standards like for the most part isis as

92
00:03:21,519 --> 00:03:22,560
you know it

93
00:03:22,560 --> 00:03:25,040
and uh we're also involved with training

94
00:03:25,040 --> 00:03:26,959
sub and cyber security like deeply in

95
00:03:26,959 --> 00:03:28,720
cyber security and we're offering

96
00:03:28,720 --> 00:03:31,360
services ranging from um hormone pen

97
00:03:31,360 --> 00:03:32,959
testing reverse engineering treat

98
00:03:32,959 --> 00:03:35,200
intelligence and also adversary

99
00:03:35,200 --> 00:03:36,400
simulation

100
00:03:36,400 --> 00:03:38,720
uh on top of this i'm

101
00:03:38,720 --> 00:03:41,200
back hunter for cynic red team

102
00:03:41,200 --> 00:03:42,239
and

103
00:03:42,239 --> 00:03:45,040
like in my spare time i usually

104
00:03:45,040 --> 00:03:47,599
i really like coding so i really like

105
00:03:47,599 --> 00:03:49,840
publishing offensive tool

106
00:03:49,840 --> 00:03:53,920
offensive tooling and tradecraft

107
00:03:54,080 --> 00:03:55,680
as michael speaker

108
00:03:55,680 --> 00:03:57,599
also michael there's some issues at

109
00:03:57,599 --> 00:03:59,519
times

110
00:03:59,519 --> 00:04:03,760
that i love to solve so uh my uncle on

111
00:04:03,760 --> 00:04:06,000
on on internet i go with the handle

112
00:04:06,000 --> 00:04:09,120
class virus bought on twitter and github

113
00:04:09,120 --> 00:04:11,599
if you want to um if you want to reach

114
00:04:11,599 --> 00:04:13,599
out if you want to test the code that we

115
00:04:13,599 --> 00:04:16,320
are presenting today uh just please go

116
00:04:16,320 --> 00:04:19,199
on the repository for the repository and

117
00:04:19,199 --> 00:04:21,680
just submit issues if you find or like

118
00:04:21,680 --> 00:04:24,639
either the ids or whatever because

119
00:04:24,639 --> 00:04:27,040
everything is very well appreciated and

120
00:04:27,040 --> 00:04:28,800
if you want to reach out on twitter i'm

121
00:04:28,800 --> 00:04:31,360
always open to conversation so

122
00:04:31,360 --> 00:04:33,680
feel free to there you go

123
00:04:33,680 --> 00:04:35,440
right so this is a bit of a calendar

124
00:04:35,440 --> 00:04:37,520
here today so first of all before i

125
00:04:37,520 --> 00:04:40,000
start talking about fancy edr bypasses

126
00:04:40,000 --> 00:04:41,600
i'm going to take you on a trip down

127
00:04:41,600 --> 00:04:44,080
memory lane talk about how anti-virus

128
00:04:44,080 --> 00:04:46,800
solutions and edrs by extension evolved

129
00:04:46,800 --> 00:04:47,919
over time

130
00:04:47,919 --> 00:04:50,080
and i'm going to give you very short and

131
00:04:50,080 --> 00:04:53,040
small primer about the win32 api because

132
00:04:53,040 --> 00:04:55,040
in order to actually bypass edrs you

133
00:04:55,040 --> 00:04:56,400
first have to understand

134
00:04:56,400 --> 00:04:58,400
how malware actually works

135
00:04:58,400 --> 00:05:00,240
i'm also going to talk about d invoke

136
00:05:00,240 --> 00:05:02,320
which is probably my favorite framework

137
00:05:02,320 --> 00:05:04,320
out there it's written in c sharp i like

138
00:05:04,320 --> 00:05:06,479
high level languages so c sharp is

139
00:05:06,479 --> 00:05:08,479
definitely one of my favorite languages

140
00:05:08,479 --> 00:05:10,800
as well and the invoke is specifically

141
00:05:10,800 --> 00:05:13,199
designed to tackle these problems that

142
00:05:13,199 --> 00:05:14,880
we are going to talk about today

143
00:05:14,880 --> 00:05:16,320
i'm also going to talk about manual

144
00:05:16,320 --> 00:05:17,759
mapping and syscalls so if you don't

145
00:05:17,759 --> 00:05:19,600
know what those are don't worry it will

146
00:05:19,600 --> 00:05:22,000
be clear in just a few moments

147
00:05:22,000 --> 00:05:24,160
and then my colleague alessandro will

148
00:05:24,160 --> 00:05:27,360
also talk about uh some things today

149
00:05:27,360 --> 00:05:29,360
so alessandra if you want to talk about

150
00:05:29,360 --> 00:05:30,880
my part is actually

151
00:05:30,880 --> 00:05:33,039
like after we we will see like

152
00:05:33,039 --> 00:05:34,960
specifically user land looking and

153
00:05:34,960 --> 00:05:36,639
looking and techniques to bypass usually

154
00:05:36,639 --> 00:05:39,039
looking we will actually go back a step

155
00:05:39,039 --> 00:05:41,520
and see how we can actually make our

156
00:05:41,520 --> 00:05:44,639
payloads and malwares better and so we

157
00:05:44,639 --> 00:05:46,720
start from basic things don't forget the

158
00:05:46,720 --> 00:05:48,800
basic to not get caught in an early

159
00:05:48,800 --> 00:05:52,080
stage and then we will like step again

160
00:05:52,080 --> 00:05:55,039
on user land bypass and other kind of

161
00:05:55,039 --> 00:05:57,440
ways to blend in with our target

162
00:05:57,440 --> 00:06:00,479
so that we are like probably like pass

163
00:06:00,479 --> 00:06:03,280
through even eyes of you know less

164
00:06:03,280 --> 00:06:05,360
experienced opsec guys

165
00:06:05,360 --> 00:06:07,440
so and then at the end we will bring in

166
00:06:07,440 --> 00:06:09,120
automation and we will show you a

167
00:06:09,120 --> 00:06:11,840
framework that you can use test

168
00:06:11,840 --> 00:06:14,160
and extend to build automatically your

169
00:06:14,160 --> 00:06:16,400
payload that will be automatically

170
00:06:16,400 --> 00:06:19,120
bypass edr and ad and when you say edr

171
00:06:19,120 --> 00:06:22,319
user land by using lanuking and

172
00:06:22,319 --> 00:06:24,639
nab solutions

173
00:06:24,639 --> 00:06:26,000
all right thank you man

174
00:06:26,000 --> 00:06:28,240
so let's first talk about

175
00:06:28,240 --> 00:06:30,319
a trip down memory lane and how it used

176
00:06:30,319 --> 00:06:33,440
to be when i wasn't even hacking yet

177
00:06:33,440 --> 00:06:35,600
but i heard stories of course by people

178
00:06:35,600 --> 00:06:37,600
who are way more experienced than me

179
00:06:37,600 --> 00:06:40,000
so what used to be the case was this was

180
00:06:40,000 --> 00:06:41,759
in terms that uh matasploit and the

181
00:06:41,759 --> 00:06:43,840
miterpreter framework was brand new you

182
00:06:43,840 --> 00:06:46,000
could basically just generate a payloads

183
00:06:46,000 --> 00:06:48,400
in metasploit framework drop it to disk

184
00:06:48,400 --> 00:06:49,520
double click it and you would have

185
00:06:49,520 --> 00:06:51,199
reverse shell

186
00:06:51,199 --> 00:06:53,680
antivirus wasn't really a big big thing

187
00:06:53,680 --> 00:06:56,560
by then uh and the obfuscation methods

188
00:06:56,560 --> 00:06:58,960
that uh the metasploit framework has

189
00:06:58,960 --> 00:07:00,960
used to work very very well still does

190
00:07:00,960 --> 00:07:03,840
sometimes and you could just bypass any

191
00:07:03,840 --> 00:07:05,840
antivirus if there was actually already

192
00:07:05,840 --> 00:07:07,680
an antivirus installed in the first

193
00:07:07,680 --> 00:07:08,479
place

194
00:07:08,479 --> 00:07:10,400
so happy days not a lot of effort that

195
00:07:10,400 --> 00:07:12,720
you had to do uh you could basically be

196
00:07:12,720 --> 00:07:14,560
a script kitty and compromise networks

197
00:07:14,560 --> 00:07:16,560
uh that way

198
00:07:16,560 --> 00:07:19,039
then microsoft especially when the

199
00:07:19,039 --> 00:07:20,639
powershell started getting more and more

200
00:07:20,639 --> 00:07:24,400
abused they actually got onto this quite

201
00:07:24,400 --> 00:07:26,560
rapidly and they introduced mc so if you

202
00:07:26,560 --> 00:07:28,319
don't know what mcs it's the anti-mower

203
00:07:28,319 --> 00:07:30,800
scanning interface from windows which

204
00:07:30,800 --> 00:07:33,440
actually helps defend against

205
00:07:33,440 --> 00:07:35,199
script kitty attacks so if you don't

206
00:07:35,199 --> 00:07:37,759
know about mc it's basically a dll that

207
00:07:37,759 --> 00:07:39,599
is injected into any process that is

208
00:07:39,599 --> 00:07:41,919
getting spawned it's also in user land

209
00:07:41,919 --> 00:07:44,000
so you could actually manipulate that as

210
00:07:44,000 --> 00:07:46,560
you can see right here that's what i did

211
00:07:46,560 --> 00:07:48,400
it's really not that hard if you know a

212
00:07:48,400 --> 00:07:50,800
little bit about the win32 api you could

213
00:07:50,800 --> 00:07:52,560
just override the pointer to the empty

214
00:07:52,560 --> 00:07:53,759
scan buffer

215
00:07:53,759 --> 00:07:55,520
and make it throw an error which makes

216
00:07:55,520 --> 00:07:58,240
it impossible for your mc to actually

217
00:07:58,240 --> 00:08:00,160
get scanned so your payload wouldn't get

218
00:08:00,160 --> 00:08:02,080
scanned and you would actually bypass it

219
00:08:02,080 --> 00:08:04,960
as you can see right here on this slide

220
00:08:04,960 --> 00:08:08,479
so that actually made um the cost of

221
00:08:08,479 --> 00:08:11,599
intrusion a bit harder because attackers

222
00:08:11,599 --> 00:08:13,280
now have to deal with some defensive

223
00:08:13,280 --> 00:08:15,360
measurements and they actually need to

224
00:08:15,360 --> 00:08:18,080
understand a bit how the win32 api works

225
00:08:18,080 --> 00:08:20,639
in order to try and bypass mc now of

226
00:08:20,639 --> 00:08:22,479
course there have been automation

227
00:08:22,479 --> 00:08:24,720
frameworks out there to try and automate

228
00:08:24,720 --> 00:08:25,840
this for you

229
00:08:25,840 --> 00:08:28,000
most notably mc.fail which was actually

230
00:08:28,000 --> 00:08:29,520
made by a colleague of mine also at

231
00:08:29,520 --> 00:08:32,799
trustedsec called melvin langvik but

232
00:08:32,799 --> 00:08:34,799
of course the publicly available mc

233
00:08:34,799 --> 00:08:36,958
bypasses they work for a few moments

234
00:08:36,958 --> 00:08:39,200
they work for maybe a week maybe a month

235
00:08:39,200 --> 00:08:42,000
if you're lucky a year but eventually

236
00:08:42,000 --> 00:08:43,919
time catches on and defenses will

237
00:08:43,919 --> 00:08:45,440
actually

238
00:08:45,440 --> 00:08:48,080
trigger on the publicly available mc

239
00:08:48,080 --> 00:08:50,560
bypasses so it's it is in your best

240
00:08:50,560 --> 00:08:52,880
interest to learn how to win 32 api

241
00:08:52,880 --> 00:08:54,480
works so you can actually do that by

242
00:08:54,480 --> 00:08:57,120
yourself as you can see here this code

243
00:08:57,120 --> 00:08:59,760
was actually written in about

244
00:08:59,760 --> 00:09:01,440
15 minutes

245
00:09:01,440 --> 00:09:03,279
so it's not that hard and there's not

246
00:09:03,279 --> 00:09:05,279
really a lot of obfuscation going on

247
00:09:05,279 --> 00:09:07,760
here as you can see here like load

248
00:09:07,760 --> 00:09:11,600
library i just split mc so a plus ms

249
00:09:11,600 --> 00:09:13,519
plus hacksaw and hacksaw is just i dot

250
00:09:13,519 --> 00:09:15,680
dll if you combine those that's just

251
00:09:15,680 --> 00:09:17,839
mc.dll there's not really a lot of

252
00:09:17,839 --> 00:09:19,839
obfuscation there but this is enough to

253
00:09:19,839 --> 00:09:22,480
actually bypass mc why because this is

254
00:09:22,480 --> 00:09:25,279
just quote unquote customly made it's

255
00:09:25,279 --> 00:09:28,000
not just publicly available on github so

256
00:09:28,000 --> 00:09:30,320
it takes a bit longer to actually detect

257
00:09:30,320 --> 00:09:32,320
this right because this bypass is not

258
00:09:32,320 --> 00:09:34,320
getting used very frequently which makes

259
00:09:34,320 --> 00:09:36,640
the shelf time a little bit longer so it

260
00:09:36,640 --> 00:09:38,720
is definitely in your best interests if

261
00:09:38,720 --> 00:09:41,760
you are a adversary or you do adversary

262
00:09:41,760 --> 00:09:44,000
emulations that you actually learn how

263
00:09:44,000 --> 00:09:47,200
to do this by yourself

264
00:09:47,760 --> 00:09:49,040
and then of course

265
00:09:49,040 --> 00:09:51,920
this is the current era we have edrs now

266
00:09:51,920 --> 00:09:52,800
it's

267
00:09:52,800 --> 00:09:55,040
a lot a lot harder for adversaries to

268
00:09:55,040 --> 00:09:56,880
actually breach

269
00:09:56,880 --> 00:09:59,440
enterprises when edrs are correctly

270
00:09:59,440 --> 00:10:02,079
implemented because that's another story

271
00:10:02,079 --> 00:10:04,640
sometimes enterprises do have endpoint

272
00:10:04,640 --> 00:10:06,800
solutions available to them edr's

273
00:10:06,800 --> 00:10:08,079
available to them but they are not

274
00:10:08,079 --> 00:10:09,920
really configured correctly

275
00:10:09,920 --> 00:10:11,839
especially when we're talking about

276
00:10:11,839 --> 00:10:14,640
sea level like sea level suites then

277
00:10:14,640 --> 00:10:16,079
defenses tend to get a little bit

278
00:10:16,079 --> 00:10:17,839
lowered because they don't want the

279
00:10:17,839 --> 00:10:19,600
complexity of retyping their password

280
00:10:19,600 --> 00:10:20,640
all the time

281
00:10:20,640 --> 00:10:21,839
and of course there are other things to

282
00:10:21,839 --> 00:10:23,760
deal with as well such as attack surface

283
00:10:23,760 --> 00:10:25,839
reduction application whitelisting and

284
00:10:25,839 --> 00:10:27,519
exploit guard

285
00:10:27,519 --> 00:10:29,760
but never fear though because if you

286
00:10:29,760 --> 00:10:31,839
know the win32 api you can start

287
00:10:31,839 --> 00:10:33,680
manipulating things and you can try and

288
00:10:33,680 --> 00:10:36,240
craft your bypasses but in order to do

289
00:10:36,240 --> 00:10:37,600
that you first need to understand a

290
00:10:37,600 --> 00:10:40,480
little bit how the win32 api works so

291
00:10:40,480 --> 00:10:42,480
windows actually well not windows

292
00:10:42,480 --> 00:10:46,079
microsoft has a publicly available api

293
00:10:46,079 --> 00:10:48,240
calls documented online

294
00:10:48,240 --> 00:10:50,079
that commonly is getting referred to as

295
00:10:50,079 --> 00:10:52,800
the msdn so if you go to the msdn and

296
00:10:52,800 --> 00:10:55,120
you look for an api call let's just say

297
00:10:55,120 --> 00:10:56,959
virtual unlock you would actually see

298
00:10:56,959 --> 00:10:59,120
the function declaration of virtual

299
00:10:59,120 --> 00:11:01,519
alloc usually it's written in c or c

300
00:11:01,519 --> 00:11:03,680
plus but you can translate that to any

301
00:11:03,680 --> 00:11:05,200
language you want

302
00:11:05,200 --> 00:11:07,279
and in order to fully understand how it

303
00:11:07,279 --> 00:11:10,160
works you need to understand ntdll.dll

304
00:11:10,160 --> 00:11:13,120
because this dll is very very important

305
00:11:13,120 --> 00:11:14,880
we are going to talk about ntd allowable

306
00:11:14,880 --> 00:11:17,040
tll quite a lot it's kind of a tongue

307
00:11:17,040 --> 00:11:20,320
twister as well because nt dll.dll so

308
00:11:20,320 --> 00:11:22,079
you can hear that quite a lot

309
00:11:22,079 --> 00:11:24,720
why is this one important well this is

310
00:11:24,720 --> 00:11:26,320
actually the bridge between what we

311
00:11:26,320 --> 00:11:29,519
refer to as userlands and kernel lands

312
00:11:29,519 --> 00:11:32,959
so microsoft windows runs of course um

313
00:11:32,959 --> 00:11:34,720
your operating system so your operating

314
00:11:34,720 --> 00:11:37,519
system has cpu of course and that is

315
00:11:37,519 --> 00:11:40,800
being managed by the kernel right as a

316
00:11:40,800 --> 00:11:42,880
regular user you can't just interact

317
00:11:42,880 --> 00:11:44,399
with the kernel directly there are

318
00:11:44,399 --> 00:11:46,000
protections around that so you can't

319
00:11:46,000 --> 00:11:47,440
just start manipulating the kernel

320
00:11:47,440 --> 00:11:50,000
directly what you can do however is

321
00:11:50,000 --> 00:11:52,720
spawn new processes these processes are

322
00:11:52,720 --> 00:11:55,120
being spawned in what we call user land

323
00:11:55,120 --> 00:11:56,959
so everything that is accessible to a

324
00:11:56,959 --> 00:12:00,800
user is living in userland now how do

325
00:12:00,800 --> 00:12:03,519
cpus actually interact well they

326
00:12:03,519 --> 00:12:05,760
actually see the userland application

327
00:12:05,760 --> 00:12:08,880
being spawned and there have there are

328
00:12:08,880 --> 00:12:11,920
api calls in the back ends usually nt

329
00:12:11,920 --> 00:12:14,480
apis so that's actually prefixed by the

330
00:12:14,480 --> 00:12:18,320
words nt but also zw and those are

331
00:12:18,320 --> 00:12:19,680
actually

332
00:12:19,680 --> 00:12:21,839
talking to the kernel directly

333
00:12:21,839 --> 00:12:24,360
so if you as an adversary know about

334
00:12:24,360 --> 00:12:26,800
ntdlr.tll know about all the exported

335
00:12:26,800 --> 00:12:29,920
functions that ntdlr.dll exposes learn

336
00:12:29,920 --> 00:12:32,000
about those prototypes so the function

337
00:12:32,000 --> 00:12:33,200
prototypes

338
00:12:33,200 --> 00:12:36,000
which are not documented on the msdn by

339
00:12:36,000 --> 00:12:37,120
the way

340
00:12:37,120 --> 00:12:38,880
but if you know about this stuff then

341
00:12:38,880 --> 00:12:40,880
you can actually start manipulating it

342
00:12:40,880 --> 00:12:43,040
and if you are that low level you're

343
00:12:43,040 --> 00:12:45,680
actually just one level above the kernel

344
00:12:45,680 --> 00:12:48,000
that's actually where edrs also place

345
00:12:48,000 --> 00:12:49,920
their hooks so if you know how to

346
00:12:49,920 --> 00:12:52,240
manipulate that you can avoid using land

347
00:12:52,240 --> 00:12:54,480
hooks and you can actually still

348
00:12:54,480 --> 00:12:56,720
run malicious payloads on the

349
00:12:56,720 --> 00:12:58,720
environment with even endpoint

350
00:12:58,720 --> 00:13:01,200
protections in place

351
00:13:01,200 --> 00:13:03,120
so that was a lot of theory but let's

352
00:13:03,120 --> 00:13:04,720
just look at a practical example right

353
00:13:04,720 --> 00:13:05,600
now

354
00:13:05,600 --> 00:13:07,519
so this are some api calls that are

355
00:13:07,519 --> 00:13:10,480
commonly used for process injection so

356
00:13:10,480 --> 00:13:12,639
uh shellcode injecting into a process

357
00:13:12,639 --> 00:13:15,120
that's already alive so what are the api

358
00:13:15,120 --> 00:13:17,440
calls well virtual ulc this is used to

359
00:13:17,440 --> 00:13:20,240
allocate memory into the process because

360
00:13:20,240 --> 00:13:22,320
you are going to inject shell codes so

361
00:13:22,320 --> 00:13:24,320
you need memory in order to actually

362
00:13:24,320 --> 00:13:26,240
inject the shell code so first you need

363
00:13:26,240 --> 00:13:27,920
to allocate some memory

364
00:13:27,920 --> 00:13:29,680
then virtual protect

365
00:13:29,680 --> 00:13:31,519
why do you need virtual protect well you

366
00:13:31,519 --> 00:13:33,839
need to actually allocate memory but you

367
00:13:33,839 --> 00:13:35,200
also need to have

368
00:13:35,200 --> 00:13:37,440
writable access to that memory because

369
00:13:37,440 --> 00:13:39,040
if you can't write to it you won't be

370
00:13:39,040 --> 00:13:40,880
able to inject your shell code into it

371
00:13:40,880 --> 00:13:42,720
so that is what virtual protect does

372
00:13:42,720 --> 00:13:44,959
then you have write process memory guess

373
00:13:44,959 --> 00:13:47,519
what that is writing operation so you're

374
00:13:47,519 --> 00:13:48,639
going to take the shell code and

375
00:13:48,639 --> 00:13:50,480
actually write it into the memory that

376
00:13:50,480 --> 00:13:52,720
you just created and then create remote

377
00:13:52,720 --> 00:13:54,320
threads what's that going to do is

378
00:13:54,320 --> 00:13:56,480
you're going to point to the shellcode

379
00:13:56,480 --> 00:13:58,000
that you just injected and you're going

380
00:13:58,000 --> 00:14:00,000
to say to your program dear program

381
00:14:00,000 --> 00:14:02,240
please create a new threat and use this

382
00:14:02,240 --> 00:14:04,800
new code as your entry points so you

383
00:14:04,800 --> 00:14:06,800
would actually create a new threat that

384
00:14:06,800 --> 00:14:11,120
is going to launch your malicious code

385
00:14:11,279 --> 00:14:13,360
so what happens if you create a loader

386
00:14:13,360 --> 00:14:17,120
that calls ntdll.ell when your edr hooks

387
00:14:17,120 --> 00:14:19,040
kernel32.tll

388
00:14:19,040 --> 00:14:22,680
well deal with it why because i said

389
00:14:22,680 --> 00:14:25,680
ntdl.pll is the lowest you can go from

390
00:14:25,680 --> 00:14:28,320
user modes so if your edr

391
00:14:28,320 --> 00:14:30,880
actually hooks above that let's say

392
00:14:30,880 --> 00:14:33,360
kernel 32.tl it's actually not going to

393
00:14:33,360 --> 00:14:36,160
catch anything you use because you are

394
00:14:36,160 --> 00:14:38,160
using ntdl.tll

395
00:14:38,160 --> 00:14:39,920
if that doesn't make a lot of sense yet

396
00:14:39,920 --> 00:14:41,279
don't worry we're actually going to see

397
00:14:41,279 --> 00:14:43,680
the call 3 in just a few slides

398
00:14:43,680 --> 00:14:46,399
which makes it more clear

399
00:14:46,399 --> 00:14:48,399
so rastamaus i don't know if you know

400
00:14:48,399 --> 00:14:50,160
him he's quite famous because of mc

401
00:14:50,160 --> 00:14:52,079
bypasses and he also has a red team

402
00:14:52,079 --> 00:14:54,000
operator course which i highly recommend

403
00:14:54,000 --> 00:14:55,920
by the way if you're into red teaming

404
00:14:55,920 --> 00:14:58,160
and as a rule of thumb you always want

405
00:14:58,160 --> 00:15:00,959
to go as low as you can so your user

406
00:15:00,959 --> 00:15:04,240
mode the lowest you can go is nt dll.tll

407
00:15:04,240 --> 00:15:06,480
so this is actually why

408
00:15:06,480 --> 00:15:08,160
in this slide you can actually see that

409
00:15:08,160 --> 00:15:11,199
we are calling virtual alok x virtual

410
00:15:11,199 --> 00:15:14,079
alloc x is actually an exposed function

411
00:15:14,079 --> 00:15:16,959
from kernel 32. tll but if you see in

412
00:15:16,959 --> 00:15:19,440
the call tree virtual alloc x is

413
00:15:19,440 --> 00:15:21,519
actually nothing more than just a high

414
00:15:21,519 --> 00:15:23,680
level wrapper around

415
00:15:23,680 --> 00:15:27,040
nt allocate virtual memory nt

416
00:15:27,040 --> 00:15:29,360
that should ring a bell nt means it's

417
00:15:29,360 --> 00:15:31,120
actually an exposed function from ntd

418
00:15:31,120 --> 00:15:34,000
allowable tll so that means that if you

419
00:15:34,000 --> 00:15:36,480
actually call anti-allocate virtual

420
00:15:36,480 --> 00:15:38,560
memory yourself so if you know the

421
00:15:38,560 --> 00:15:40,639
function prototype and you start coding

422
00:15:40,639 --> 00:15:42,800
your own nt function you don't have to

423
00:15:42,800 --> 00:15:45,920
call virtual a lock x so if your edr is

424
00:15:45,920 --> 00:15:48,240
hooking virtual a lock x it's not going

425
00:15:48,240 --> 00:15:50,240
to see the call below that

426
00:15:50,240 --> 00:15:52,959
however if your edr hooks

427
00:15:52,959 --> 00:15:55,199
the allocate virtual memory it is going

428
00:15:55,199 --> 00:15:57,759
to see the virtual allocax as well

429
00:15:57,759 --> 00:16:00,639
because virtual alloc x in the back end

430
00:16:00,639 --> 00:16:02,880
is calling anti-allocate virtual memory

431
00:16:02,880 --> 00:16:04,880
so i hope that kind of makes sense

432
00:16:04,880 --> 00:16:07,360
the same goes for write process memory

433
00:16:07,360 --> 00:16:09,440
that actually calls two nt functions in

434
00:16:09,440 --> 00:16:11,920
the back ends so from an edr perspective

435
00:16:11,920 --> 00:16:13,759
from a defender perspective

436
00:16:13,759 --> 00:16:15,839
it makes a lot of sense to hook nt

437
00:16:15,839 --> 00:16:17,279
functions because then you have

438
00:16:17,279 --> 00:16:19,600
telemetry on all the api calls that live

439
00:16:19,600 --> 00:16:23,000
above ntdl.tll

440
00:16:23,360 --> 00:16:26,320
edrs or malware why do i say that edrs

441
00:16:26,320 --> 00:16:28,480
are malware well because edrs are

442
00:16:28,480 --> 00:16:30,639
actually using the same methods that

443
00:16:30,639 --> 00:16:32,880
malware developers are using as well

444
00:16:32,880 --> 00:16:36,320
edrs injects their dll much like malware

445
00:16:36,320 --> 00:16:38,399
would inject their malicious dll into

446
00:16:38,399 --> 00:16:40,480
any process that is getting spawned why

447
00:16:40,480 --> 00:16:42,320
does it do that well it does that

448
00:16:42,320 --> 00:16:44,880
because it wants to hook certain api

449
00:16:44,880 --> 00:16:47,199
calls because that way they know

450
00:16:47,199 --> 00:16:49,519
whenever an api call is being called it

451
00:16:49,519 --> 00:16:52,079
can actually go to their scanning engine

452
00:16:52,079 --> 00:16:53,440
and then they will make informed

453
00:16:53,440 --> 00:16:55,040
decisions whether or not you're actually

454
00:16:55,040 --> 00:16:57,519
doing something malicious or not because

455
00:16:57,519 --> 00:16:59,279
every single program that is running on

456
00:16:59,279 --> 00:17:01,279
your operating system needs to interact

457
00:17:01,279 --> 00:17:03,920
with win32 api one way or another

458
00:17:03,920 --> 00:17:05,679
otherwise your kernel wouldn't know what

459
00:17:05,679 --> 00:17:08,640
to do with your program so that is why

460
00:17:08,640 --> 00:17:10,640
edr vendors need to inject their own

461
00:17:10,640 --> 00:17:12,400
dlls into

462
00:17:12,400 --> 00:17:16,160
any process that is getting spawned

463
00:17:16,319 --> 00:17:19,280
so this is uh an example of user land

464
00:17:19,280 --> 00:17:21,439
hooks so that is exactly what i said

465
00:17:21,439 --> 00:17:24,880
with edr vendors hooking nt functions so

466
00:17:24,880 --> 00:17:27,119
here on the top side of the slide you

467
00:17:27,119 --> 00:17:30,320
actually see how the disassembly of

468
00:17:30,320 --> 00:17:32,480
anti-allocate virtual memory

469
00:17:32,480 --> 00:17:34,480
actually should look like and it's

470
00:17:34,480 --> 00:17:36,559
always the same with any nt function by

471
00:17:36,559 --> 00:17:38,559
the way so there's going to be a move

472
00:17:38,559 --> 00:17:43,200
instruction from r10 to rcx eix to 18h

473
00:17:43,200 --> 00:17:46,240
and the 18h here is important because

474
00:17:46,240 --> 00:17:48,960
that is what we call a syscall number so

475
00:17:48,960 --> 00:17:51,840
this 18h is actually the representation

476
00:17:51,840 --> 00:17:54,480
of anti-allocate virtual memory

477
00:17:54,480 --> 00:17:56,799
this is the only thing that changes in

478
00:17:56,799 --> 00:17:58,559
any nt function

479
00:17:58,559 --> 00:18:01,600
so if i would uh want to want to call nt

480
00:18:01,600 --> 00:18:05,440
right virtual memory then r10 to rcx is

481
00:18:05,440 --> 00:18:07,919
still going to happen ax is also going

482
00:18:07,919 --> 00:18:09,679
to have the move instruction but the

483
00:18:09,679 --> 00:18:12,160
hexadecimal there the 18h would change

484
00:18:12,160 --> 00:18:14,799
to for example 21h which would be the

485
00:18:14,799 --> 00:18:16,320
syscall number for

486
00:18:16,320 --> 00:18:18,880
anti-write virtual memory and then of

487
00:18:18,880 --> 00:18:20,720
course you have the syscall instruction

488
00:18:20,720 --> 00:18:23,120
the return statement and that is how a

489
00:18:23,120 --> 00:18:24,880
normal function looks like an ntd

490
00:18:24,880 --> 00:18:27,360
allowable tll now on the bottom side of

491
00:18:27,360 --> 00:18:29,440
the slide however this is what it looks

492
00:18:29,440 --> 00:18:32,480
like when something is hooking nt

493
00:18:32,480 --> 00:18:35,120
functions so in this example we actually

494
00:18:35,120 --> 00:18:38,480
created our own demo edr and we placed a

495
00:18:38,480 --> 00:18:40,799
hook onto anti-allocate virtual memory

496
00:18:40,799 --> 00:18:42,960
and you can definitely see that those

497
00:18:42,960 --> 00:18:44,480
two functions don't look the same

498
00:18:44,480 --> 00:18:46,799
anymore the first instruction is

499
00:18:46,799 --> 00:18:49,440
actually a jump instruction to a new

500
00:18:49,440 --> 00:18:50,960
memory address and if you would follow

501
00:18:50,960 --> 00:18:52,799
that memory address it would actually

502
00:18:52,799 --> 00:18:55,520
end up in the dll of the edr

503
00:18:55,520 --> 00:18:57,679
because they want to inspect whatever

504
00:18:57,679 --> 00:19:00,000
api call you do and try to make informed

505
00:19:00,000 --> 00:19:01,440
decisions whether or not your action

506
00:19:01,440 --> 00:19:05,280
that you're doing is malicious or not

507
00:19:06,480 --> 00:19:08,000
then of course

508
00:19:08,000 --> 00:19:10,000
we have some very good security

509
00:19:10,000 --> 00:19:12,080
researchers uh one shout out i want to

510
00:19:12,080 --> 00:19:14,559
do is to mr unicoder he actually has a

511
00:19:14,559 --> 00:19:17,200
github repository with a list of known

512
00:19:17,200 --> 00:19:18,960
edr vendors

513
00:19:18,960 --> 00:19:20,799
and what they are hooking on

514
00:19:20,799 --> 00:19:22,640
so they he created a script that is

515
00:19:22,640 --> 00:19:24,559
actually going to

516
00:19:24,559 --> 00:19:26,720
scrape ntdll so all the exported

517
00:19:26,720 --> 00:19:28,400
functions compare it to the function

518
00:19:28,400 --> 00:19:30,240
prototype that i showed you here in this

519
00:19:30,240 --> 00:19:32,559
slide oh sorry

520
00:19:32,559 --> 00:19:33,520
um

521
00:19:33,520 --> 00:19:36,559
this slides so the move instructions if

522
00:19:36,559 --> 00:19:39,120
it differs from this so if it differs

523
00:19:39,120 --> 00:19:41,679
from the opt code they know or he knows

524
00:19:41,679 --> 00:19:44,240
that that uh function is hooked so on

525
00:19:44,240 --> 00:19:46,799
the right side well my right yeah you're

526
00:19:46,799 --> 00:19:48,480
right as well on the right side there's

527
00:19:48,480 --> 00:19:50,960
a crowdstrike so these are all the np

528
00:19:50,960 --> 00:19:53,120
functions and zw functions that

529
00:19:53,120 --> 00:19:55,760
crowdstrike is actually hooking so if

530
00:19:55,760 --> 00:19:58,480
you as an adversary want to do

531
00:19:58,480 --> 00:20:00,799
like a malware and you want to use any

532
00:20:00,799 --> 00:20:03,200
of these calls know that crowdstrike has

533
00:20:03,200 --> 00:20:04,799
hooks on those so crowdstrike has

534
00:20:04,799 --> 00:20:06,960
telemetry if you're using any of these

535
00:20:06,960 --> 00:20:09,520
calls so what can you do well there are

536
00:20:09,520 --> 00:20:11,600
two things you can actually do the first

537
00:20:11,600 --> 00:20:13,760
thing is what we call manual mapping and

538
00:20:13,760 --> 00:20:16,000
what this does is

539
00:20:16,000 --> 00:20:17,760
first let's just see how it normally

540
00:20:17,760 --> 00:20:20,240
works so this is the edr this is the

541
00:20:20,240 --> 00:20:23,200
malware imover i want to call an nt

542
00:20:23,200 --> 00:20:25,120
function so i'm going to call

543
00:20:25,120 --> 00:20:28,000
anti-allocate virtual memory x well

544
00:20:28,000 --> 00:20:30,559
guess what my edr is actually hooking

545
00:20:30,559 --> 00:20:32,799
that function as well so the edr is

546
00:20:32,799 --> 00:20:34,799
going to see my api call it's going to

547
00:20:34,799 --> 00:20:36,960
say ah that looks kind of suspicious i'm

548
00:20:36,960 --> 00:20:39,360
going to block your execution and i'm

549
00:20:39,360 --> 00:20:41,120
going to throw an alert so that is the

550
00:20:41,120 --> 00:20:42,880
normal flow

551
00:20:42,880 --> 00:20:45,520
but if i'm a smart malware author i

552
00:20:45,520 --> 00:20:47,960
cannot say okay look i know that

553
00:20:47,960 --> 00:20:51,200
ntdl.tll is already in my process memory

554
00:20:51,200 --> 00:20:55,039
but hey i want to create a new ntdlr.dll

555
00:20:55,039 --> 00:20:57,600
image in my own memory so i'm going to

556
00:20:57,600 --> 00:21:01,200
fetch a clean ntdlr.dll from disk and

557
00:21:01,200 --> 00:21:03,200
i'm going to map it in the memory of my

558
00:21:03,200 --> 00:21:06,400
process i'm currently in now this works

559
00:21:06,400 --> 00:21:07,760
but of course you lose all the

560
00:21:07,760 --> 00:21:09,679
functionality of the windows loader

561
00:21:09,679 --> 00:21:11,600
because you are manually mapping it

562
00:21:11,600 --> 00:21:13,440
yourself so that means that if you want

563
00:21:13,440 --> 00:21:14,240
to

564
00:21:14,240 --> 00:21:16,799
if you want to call an api like an nt

565
00:21:16,799 --> 00:21:18,880
function and you're using the windows

566
00:21:18,880 --> 00:21:20,880
loader it's going to default to the

567
00:21:20,880 --> 00:21:23,840
already mapped nt function so if you're

568
00:21:23,840 --> 00:21:26,240
manually mapping you have to do

569
00:21:26,240 --> 00:21:28,720
calculations and offsets all by yourself

570
00:21:28,720 --> 00:21:30,799
you have to do it all manually or use a

571
00:21:30,799 --> 00:21:33,200
framework like the invoke to do it for

572
00:21:33,200 --> 00:21:34,080
you

573
00:21:34,080 --> 00:21:35,919
so if you do it correctly you can

574
00:21:35,919 --> 00:21:37,360
actually say

575
00:21:37,360 --> 00:21:40,400
map a new ntdl.tll in memory and i want

576
00:21:40,400 --> 00:21:43,120
to use api calls from my newly mapped nt

577
00:21:43,120 --> 00:21:46,240
functions so what that means is edrs are

578
00:21:46,240 --> 00:21:48,240
going to place their hooks at runtime so

579
00:21:48,240 --> 00:21:50,240
when you spawn the program it's going to

580
00:21:50,240 --> 00:21:52,480
place the hooks because ntdll is already

581
00:21:52,480 --> 00:21:54,559
in the memory space the hooks will be

582
00:21:54,559 --> 00:21:58,080
placed on the regular ntdl.tl if you

583
00:21:58,080 --> 00:22:01,440
manually map a cl and a new ntdlltl from

584
00:22:01,440 --> 00:22:03,760
disk the hooks won't be there they will

585
00:22:03,760 --> 00:22:05,679
be in the original one but they won't be

586
00:22:05,679 --> 00:22:08,720
in the new one so if i call nt functions

587
00:22:08,720 --> 00:22:11,679
from my new ntdl.tll i can actually

588
00:22:11,679 --> 00:22:12,400
avoid

589
00:22:12,400 --> 00:22:15,760
edr hoops well at least from user modes

590
00:22:15,760 --> 00:22:17,840
the other thing we can do oh yeah this

591
00:22:17,840 --> 00:22:20,080
is another example the other thing we

592
00:22:20,080 --> 00:22:22,080
can do is syscalls but in order to

593
00:22:22,080 --> 00:22:24,559
understand syscalls i want you to

594
00:22:24,559 --> 00:22:26,480
i wanted to dumb it down a little bit

595
00:22:26,480 --> 00:22:28,799
because syscalls are quite complex so i

596
00:22:28,799 --> 00:22:31,840
just created a very very simple uh proof

597
00:22:31,840 --> 00:22:34,320
of concept so imagine i have a hooked

598
00:22:34,320 --> 00:22:36,320
function and i as an attacker know what

599
00:22:36,320 --> 00:22:38,240
that hook function looks like that

600
00:22:38,240 --> 00:22:40,640
hooked function is just going to print i

601
00:22:40,640 --> 00:22:42,159
do cool stuff

602
00:22:42,159 --> 00:22:44,799
it's not really anything special but i

603
00:22:44,799 --> 00:22:46,559
know as an attacker that i want to call

604
00:22:46,559 --> 00:22:47,520
this

605
00:22:47,520 --> 00:22:49,840
function just prints i do cool stuff

606
00:22:49,840 --> 00:22:52,240
well guess what i can just create a new

607
00:22:52,240 --> 00:22:53,200
function

608
00:22:53,200 --> 00:22:55,120
called for example clone of hooked

609
00:22:55,120 --> 00:22:56,640
function and just take the

610
00:22:56,640 --> 00:22:58,640
implementation of the original function

611
00:22:58,640 --> 00:23:00,559
put it in my new function and just call

612
00:23:00,559 --> 00:23:01,919
that function

613
00:23:01,919 --> 00:23:05,360
it's the same implementation but the

614
00:23:05,360 --> 00:23:07,440
clone of the hook function won't have

615
00:23:07,440 --> 00:23:10,799
the hook so if i call hooked function i

616
00:23:10,799 --> 00:23:12,400
do cool stuff it's going to print it to

617
00:23:12,400 --> 00:23:14,559
the console but if i do the clone of

618
00:23:14,559 --> 00:23:16,559
hooked function it's also going to print

619
00:23:16,559 --> 00:23:18,640
i do cool stuff into the console so from

620
00:23:18,640 --> 00:23:21,200
a user perspective nothing changes the

621
00:23:21,200 --> 00:23:23,520
functionality is exactly the same

622
00:23:23,520 --> 00:23:25,679
however the first api is getting

623
00:23:25,679 --> 00:23:28,159
monitored by the edr the second one is

624
00:23:28,159 --> 00:23:30,320
not because i just created it that's

625
00:23:30,320 --> 00:23:32,799
after the process was already spawned so

626
00:23:32,799 --> 00:23:35,440
no hooks are there

627
00:23:35,440 --> 00:23:36,880
right so

628
00:23:36,880 --> 00:23:38,720
uh use the land hook bypasses what can

629
00:23:38,720 --> 00:23:40,159
you do well

630
00:23:40,159 --> 00:23:43,200
first of all uh this is the preferred

631
00:23:43,200 --> 00:23:45,120
option actually the preferred approach

632
00:23:45,120 --> 00:23:47,440
don't get flagged as malicious of course

633
00:23:47,440 --> 00:23:49,679
this is a lot harder to just pull off

634
00:23:49,679 --> 00:23:51,600
because you would have to have the same

635
00:23:51,600 --> 00:23:52,720
edr

636
00:23:52,720 --> 00:23:55,120
in your test environment as your uh as

637
00:23:55,120 --> 00:23:57,520
your target actually has and if you are

638
00:23:57,520 --> 00:23:59,600
a red teamer or someone who is doing

639
00:23:59,600 --> 00:24:01,279
offensive research and you actually

640
00:24:01,279 --> 00:24:03,600
publish some white papers a lot of edr

641
00:24:03,600 --> 00:24:05,600
vendors are just going to say yeah no

642
00:24:05,600 --> 00:24:07,919
i'm not going to sell you any license

643
00:24:07,919 --> 00:24:09,600
because you're actually scrutinizing or

644
00:24:09,600 --> 00:24:11,520
edr so i'm not going to give you a

645
00:24:11,520 --> 00:24:13,360
license which makes it a lot harder of

646
00:24:13,360 --> 00:24:16,400
course to set up labs on top of that edr

647
00:24:16,400 --> 00:24:18,799
licenses usually are quite expensive so

648
00:24:18,799 --> 00:24:21,200
if you're a small shop you won't be able

649
00:24:21,200 --> 00:24:23,600
to just purchase all the edr licenses

650
00:24:23,600 --> 00:24:25,600
out there so chances are that you won't

651
00:24:25,600 --> 00:24:28,320
be able to have like a test run with the

652
00:24:28,320 --> 00:24:30,799
same configuration that your client has

653
00:24:30,799 --> 00:24:32,480
so it's going to be a bit hard to

654
00:24:32,480 --> 00:24:34,559
actually pull this off but if you can do

655
00:24:34,559 --> 00:24:36,240
it hey happy days because you're not

656
00:24:36,240 --> 00:24:37,840
flagged as malicious in the first place

657
00:24:37,840 --> 00:24:40,480
so you won't have to do any um like

658
00:24:40,480 --> 00:24:42,159
fancy bypasses

659
00:24:42,159 --> 00:24:44,640
of course you can also unhook the hooks

660
00:24:44,640 --> 00:24:47,440
so if you know that a specific function

661
00:24:47,440 --> 00:24:49,679
is hooked you could actually

662
00:24:49,679 --> 00:24:52,080
patch it again much like the mc patch so

663
00:24:52,080 --> 00:24:54,000
you just call the virtual unlock and you

664
00:24:54,000 --> 00:24:56,080
just patch it with the original byte

665
00:24:56,080 --> 00:24:57,679
that will work as well

666
00:24:57,679 --> 00:24:59,279
you can do manual mapping as i just

667
00:24:59,279 --> 00:25:01,360
explained or you could do syscalls as

668
00:25:01,360 --> 00:25:03,679
well of course the caveat with syscalls

669
00:25:03,679 --> 00:25:06,240
is that the number changes on every

670
00:25:06,240 --> 00:25:08,240
single operating system but also on

671
00:25:08,240 --> 00:25:10,400
operating system version so of course

672
00:25:10,400 --> 00:25:12,320
linux has syscalls as well linux

673
00:25:12,320 --> 00:25:14,080
syscalls won't be the same as windows

674
00:25:14,080 --> 00:25:17,039
syscalls and windows xp won't have the

675
00:25:17,039 --> 00:25:18,960
same syscall numbers as windows 10 for

676
00:25:18,960 --> 00:25:21,440
example so it's really um a cat and a

677
00:25:21,440 --> 00:25:23,840
mouse game there and it uh it helps

678
00:25:23,840 --> 00:25:25,600
adversaries a lot if you can automate

679
00:25:25,600 --> 00:25:28,080
this process or if you can fetch cisco

680
00:25:28,080 --> 00:25:31,120
numbers dynamically

681
00:25:31,120 --> 00:25:33,520
right so here are some edr bypasses

682
00:25:33,520 --> 00:25:35,600
summarized this was actually from last

683
00:25:35,600 --> 00:25:38,000
month on twitter yay twitter

684
00:25:38,000 --> 00:25:39,840
and it's actually really really well

685
00:25:39,840 --> 00:25:41,919
explained and i kind of agree with this

686
00:25:41,919 --> 00:25:44,080
whole approach so the first one is a

687
00:25:44,080 --> 00:25:47,120
technical capability bypass what is here

688
00:25:47,120 --> 00:25:49,279
is some edrs aren't capable of

689
00:25:49,279 --> 00:25:50,799
collecting all the telemetry right

690
00:25:50,799 --> 00:25:53,520
because the win32 api has literally

691
00:25:53,520 --> 00:25:55,279
thousands of functions it's really

692
00:25:55,279 --> 00:25:57,279
impossible for an edr vendor to collect

693
00:25:57,279 --> 00:25:59,520
telemetry of all these functions without

694
00:25:59,520 --> 00:26:01,440
slowing regular operations down

695
00:26:01,440 --> 00:26:04,000
tremendously so if you can identify as

696
00:26:04,000 --> 00:26:06,159
an adversary what the weak spots are

697
00:26:06,159 --> 00:26:08,080
which telemetry is not getting caught by

698
00:26:08,080 --> 00:26:10,159
the edr you're operating against and you

699
00:26:10,159 --> 00:26:12,400
work on those gray areas you're not

700
00:26:12,400 --> 00:26:14,480
going to get spotted by the edr

701
00:26:14,480 --> 00:26:16,640
now the second bypass is actually the

702
00:26:16,640 --> 00:26:19,200
edr configuration bypass remember that i

703
00:26:19,200 --> 00:26:21,600
talked about c-level suites which is a

704
00:26:21,600 --> 00:26:23,200
typical example

705
00:26:23,200 --> 00:26:25,279
where security is getting lowered just

706
00:26:25,279 --> 00:26:27,440
because ease of access usually you don't

707
00:26:27,440 --> 00:26:29,600
want your ceo to complain to you about

708
00:26:29,600 --> 00:26:31,840
having to retype his password all day so

709
00:26:31,840 --> 00:26:33,440
it could be that you lower like the

710
00:26:33,440 --> 00:26:35,679
security settings on the ceo's laptop

711
00:26:35,679 --> 00:26:37,279
for some reason

712
00:26:37,279 --> 00:26:39,200
and if adversaries land on a machine

713
00:26:39,200 --> 00:26:41,120
that has security settings that are

714
00:26:41,120 --> 00:26:43,440
lower than the regular security settings

715
00:26:43,440 --> 00:26:45,520
you could um play in those great gray

716
00:26:45,520 --> 00:26:47,279
areas once again in order to try and

717
00:26:47,279 --> 00:26:49,600
bypass the edr and then of course

718
00:26:49,600 --> 00:26:51,360
everything that we talked about

719
00:26:51,360 --> 00:26:54,080
up until this point is number three edr

720
00:26:54,080 --> 00:26:56,640
detection logic bypass so if you can't

721
00:26:56,640 --> 00:26:58,240
do number one or two and you have to

722
00:26:58,240 --> 00:27:00,000
resort to number three well then know

723
00:27:00,000 --> 00:27:02,240
that manual mapping and syscalls will

724
00:27:02,240 --> 00:27:06,000
help you out on that front

725
00:27:06,000 --> 00:27:07,520
and then i give the words to my

726
00:27:07,520 --> 00:27:09,760
colleague alessandro thanks a lot thanks

727
00:27:09,760 --> 00:27:12,960
a lot john it's a great great piece

728
00:27:12,960 --> 00:27:13,760
um

729
00:27:13,760 --> 00:27:14,720
so

730
00:27:14,720 --> 00:27:16,400
of course when we are developing a

731
00:27:16,400 --> 00:27:18,720
malware we don't

732
00:27:18,720 --> 00:27:20,480
really want don't want to forget the

733
00:27:20,480 --> 00:27:22,960
basics like yes we talked about user

734
00:27:22,960 --> 00:27:25,200
languaging but what's before that so

735
00:27:25,200 --> 00:27:26,799
let's consider what we want to do what

736
00:27:26,799 --> 00:27:28,640
we want to achieve and usually what we

737
00:27:28,640 --> 00:27:31,600
want to achieve is just having um we are

738
00:27:31,600 --> 00:27:33,840
departing as an external attacker we

739
00:27:33,840 --> 00:27:35,760
need some sort of payload delivery

740
00:27:35,760 --> 00:27:38,399
mechanism to actually take our shark

741
00:27:38,399 --> 00:27:40,720
back from a source and then execute it

742
00:27:40,720 --> 00:27:42,320
on a certain target

743
00:27:42,320 --> 00:27:44,080
and then when we are on the target and

744
00:27:44,080 --> 00:27:46,640
we are executing stuff we want also to

745
00:27:46,640 --> 00:27:48,960
be able to to be capable of bypassing

746
00:27:48,960 --> 00:27:52,240
the id and so we need to actually like

747
00:27:52,240 --> 00:27:54,080
install in our payload all the

748
00:27:54,080 --> 00:27:55,600
techniques that are

749
00:27:55,600 --> 00:27:58,080
needed to bypass the ab installed on the

750
00:27:58,080 --> 00:28:00,480
system we are attacking and after that

751
00:28:00,480 --> 00:28:02,960
we if there is an edr also an edr

752
00:28:02,960 --> 00:28:04,960
endpoint protection in place we want

753
00:28:04,960 --> 00:28:07,600
also to bypass this edr using user

754
00:28:07,600 --> 00:28:10,640
landing bypasses and other techniques um

755
00:28:10,640 --> 00:28:12,880
as john was describing before

756
00:28:12,880 --> 00:28:15,520
and after that we also want to

757
00:28:15,520 --> 00:28:18,960
we also might want to bypass

758
00:28:18,960 --> 00:28:21,840
eyes like isis that are looking at our

759
00:28:21,840 --> 00:28:24,960
payload and so we need to have some

760
00:28:24,960 --> 00:28:27,279
consideration of what we are doing

761
00:28:27,279 --> 00:28:28,559
and we

762
00:28:28,559 --> 00:28:30,480
want to install and provide

763
00:28:30,480 --> 00:28:32,320
our payload with techniques that can

764
00:28:32,320 --> 00:28:34,720
actually help us pass through these isis

765
00:28:34,720 --> 00:28:36,720
and pass through detection and stay

766
00:28:36,720 --> 00:28:37,760
there

767
00:28:37,760 --> 00:28:40,000
in the target for a long time

768
00:28:40,000 --> 00:28:42,000
so let's see a few of them

769
00:28:42,000 --> 00:28:43,440
and let's start with the basics so let's

770
00:28:43,440 --> 00:28:46,159
start with analyzing what an av is and

771
00:28:46,159 --> 00:28:47,840
how is um

772
00:28:47,840 --> 00:28:49,760
like nav software is actually a very

773
00:28:49,760 --> 00:28:52,240
complex system as an edr is

774
00:28:52,240 --> 00:28:55,679
uh but like in in a nutshell what anivia

775
00:28:55,679 --> 00:28:58,559
what an av is is actually a software

776
00:28:58,559 --> 00:29:01,440
based on four different components so

777
00:29:01,440 --> 00:29:03,760
the first component would be like

778
00:29:03,760 --> 00:29:06,000
something that we can't see so like the

779
00:29:06,000 --> 00:29:07,600
compressors that are needed to

780
00:29:07,600 --> 00:29:09,520
decompress the like the payload we are

781
00:29:09,520 --> 00:29:12,880
scanning to be able to actually scan it

782
00:29:12,880 --> 00:29:15,360
otherwise if i can if i don't know how

783
00:29:15,360 --> 00:29:18,480
to how to decompress a payload i can't

784
00:29:18,480 --> 00:29:20,000
actually scan it effectively against

785
00:29:20,000 --> 00:29:21,600
signatures for example

786
00:29:21,600 --> 00:29:25,120
uh unpackers is more like the same kind

787
00:29:25,120 --> 00:29:27,600
of uh thing about i mean the utility is

788
00:29:27,600 --> 00:29:28,799
the same of

789
00:29:28,799 --> 00:29:31,120
the compressors but they are different

790
00:29:31,120 --> 00:29:33,760
of course unpackers are based to um

791
00:29:33,760 --> 00:29:36,480
commonly known packers and they are

792
00:29:36,480 --> 00:29:38,960
designed to unpack payload that are

793
00:29:38,960 --> 00:29:40,640
packed with this kind of packers like

794
00:29:40,640 --> 00:29:42,720
let's think about upx for example which

795
00:29:42,720 --> 00:29:45,120
is a well-known parker so for example

796
00:29:45,120 --> 00:29:47,200
any antivirus should have an unpacker

797
00:29:47,200 --> 00:29:49,600
for epx to be able to unpack the payload

798
00:29:49,600 --> 00:29:52,399
in memory and scan it efficiently

799
00:29:52,399 --> 00:29:53,919
and then there is the part that we all

800
00:29:53,919 --> 00:29:55,919
know because we're constantly fighting

801
00:29:55,919 --> 00:29:59,440
against and is scanners and sandbox

802
00:29:59,440 --> 00:30:01,360
scanners are mostly divided in two

803
00:30:01,360 --> 00:30:03,440
categories which are on-demand scanner

804
00:30:03,440 --> 00:30:05,600
or file system scanner and runtime

805
00:30:05,600 --> 00:30:08,159
scanner or in-memory scanners

806
00:30:08,159 --> 00:30:10,159
the difference is that an on-demand

807
00:30:10,159 --> 00:30:11,919
scanner or file system scanner will

808
00:30:11,919 --> 00:30:12,960
actually

809
00:30:12,960 --> 00:30:13,840
play

810
00:30:13,840 --> 00:30:16,240
in our game when we want to land the

811
00:30:16,240 --> 00:30:17,919
payload in the target so if we want to

812
00:30:17,919 --> 00:30:19,679
install a payload in the file system of

813
00:30:19,679 --> 00:30:22,000
the target we are attacking well then of

814
00:30:22,000 --> 00:30:24,000
course we need to care about this file

815
00:30:24,000 --> 00:30:25,600
system scanner because we'll it will

816
00:30:25,600 --> 00:30:28,240
probably just try to take our payload

817
00:30:28,240 --> 00:30:30,480
and scan it against his database it's

818
00:30:30,480 --> 00:30:31,760
not okay

819
00:30:31,760 --> 00:30:33,919
the in-memory scanner is a bit more

820
00:30:33,919 --> 00:30:36,399
complex and it's what i mean what my

821
00:30:36,399 --> 00:30:37,919
colleague was actually already

822
00:30:37,919 --> 00:30:39,600
explaining is actually we can we can

823
00:30:39,600 --> 00:30:41,279
think about any memory scanner something

824
00:30:41,279 --> 00:30:43,760
that scan a payload a binary a binary

825
00:30:43,760 --> 00:30:47,039
payload in memory and msi for example is

826
00:30:47,039 --> 00:30:49,039
this in-memory scanner provided by

827
00:30:49,039 --> 00:30:51,279
microsoft what amc does is actually is

828
00:30:51,279 --> 00:30:53,520
actually installing an idea in a dll

829
00:30:53,520 --> 00:30:56,640
into the process image of of a process

830
00:30:56,640 --> 00:30:58,640
running into the system and what it will

831
00:30:58,640 --> 00:31:01,120
do it will just whenever i'm trying to

832
00:31:01,120 --> 00:31:03,519
load reflectively loading some binary

833
00:31:03,519 --> 00:31:05,600
payload it will just

834
00:31:05,600 --> 00:31:06,399
be

835
00:31:06,399 --> 00:31:08,880
loaded on demand and scan my payload for

836
00:31:08,880 --> 00:31:11,200
common signature is still signature

837
00:31:11,200 --> 00:31:12,159
based

838
00:31:12,159 --> 00:31:13,279
but

839
00:31:13,279 --> 00:31:15,760
like techniques that will allow me to

840
00:31:15,760 --> 00:31:17,519
bypass the antivirus

841
00:31:17,519 --> 00:31:19,279
back in the day like loading

842
00:31:19,279 --> 00:31:21,519
reflectively loading some shell code

843
00:31:21,519 --> 00:31:23,360
won't really work anymore if the

844
00:31:23,360 --> 00:31:25,440
shellcode is packed with known

845
00:31:25,440 --> 00:31:26,720
signatures

846
00:31:26,720 --> 00:31:28,480
so we need a way we need a way to bypass

847
00:31:28,480 --> 00:31:30,640
that as well and the sandbox for

848
00:31:30,640 --> 00:31:32,960
instance is is the more advanced maybe

849
00:31:32,960 --> 00:31:34,880
more advanced software in in the

850
00:31:34,880 --> 00:31:37,840
antivirus like world and it's actually

851
00:31:37,840 --> 00:31:39,519
what it is like it's a virtual machine

852
00:31:39,519 --> 00:31:41,519
it's a very little virtual machine that

853
00:31:41,519 --> 00:31:44,320
is designed to run my payload and

854
00:31:44,320 --> 00:31:46,159
actually understand if the payload is

855
00:31:46,159 --> 00:31:48,000
doing something dodgy and

856
00:31:48,000 --> 00:31:49,919
it classifies this and if it does it

857
00:31:49,919 --> 00:31:51,440
will classify this as malicious and it

858
00:31:51,440 --> 00:31:53,679
will just stop the execution and delete

859
00:31:53,679 --> 00:31:55,760
the payload

860
00:31:55,760 --> 00:31:56,640
so

861
00:31:56,640 --> 00:31:58,559
what we need to bypass like

862
00:31:58,559 --> 00:32:00,640
when we are attacking

863
00:32:00,640 --> 00:32:03,200
uh when we are at a target

864
00:32:03,200 --> 00:32:05,200
of course we have different kind of

865
00:32:05,200 --> 00:32:06,960
things to bypass depending on what

866
00:32:06,960 --> 00:32:08,799
language are we using to

867
00:32:08,799 --> 00:32:12,320
actually execute code so if i'm using

868
00:32:12,320 --> 00:32:14,960
net or powershell i need to actually

869
00:32:14,960 --> 00:32:16,399
care about

870
00:32:16,399 --> 00:32:18,799
because dot net and powershell fmsi

871
00:32:18,799 --> 00:32:21,120
loaded by default powershell when you

872
00:32:21,120 --> 00:32:24,080
load powershell uh you have msi loaded

873
00:32:24,080 --> 00:32:26,640
uh like assume powershell process is

874
00:32:26,640 --> 00:32:27,600
started

875
00:32:27,600 --> 00:32:31,120
instead in.net 4.8 is loaded on demand

876
00:32:31,120 --> 00:32:33,600
so it's actually loaded whenever i'm

877
00:32:33,600 --> 00:32:35,840
trying to load reflectively load

878
00:32:35,840 --> 00:32:37,760
something using assembly load or

879
00:32:37,760 --> 00:32:40,480
assembly load from whatever technique i

880
00:32:40,480 --> 00:32:42,960
use to road lift reflectively loading

881
00:32:42,960 --> 00:32:44,240
and assembly

882
00:32:44,240 --> 00:32:46,480
the dot net the clr will actually inject

883
00:32:46,480 --> 00:32:49,600
msi in the process image and msi will

884
00:32:49,600 --> 00:32:51,440
scan that buffer so we need to bypass

885
00:32:51,440 --> 00:32:54,559
the scanner for an added payload this is

886
00:32:54,559 --> 00:32:56,880
not really so important

887
00:32:56,880 --> 00:32:58,480
but we still need to bypass the

888
00:32:58,480 --> 00:33:01,519
sandboxing so after we bypass msi we

889
00:33:01,519 --> 00:33:03,600
still need to take it we did take an

890
00:33:03,600 --> 00:33:05,200
additional consideration about the

891
00:33:05,200 --> 00:33:07,600
sandboxing because probably my payload

892
00:33:07,600 --> 00:33:10,000
will be scanned we will just executed in

893
00:33:10,000 --> 00:33:12,480
a sandbox and if it contains any

894
00:33:12,480 --> 00:33:14,080
malicious behavior

895
00:33:14,080 --> 00:33:17,039
um then yes it will be detected as

896
00:33:17,039 --> 00:33:19,600
malicious if we want to land on the

897
00:33:19,600 --> 00:33:21,200
machine and we want to install a power

898
00:33:21,200 --> 00:33:24,000
script uh dot net executable or not is

899
00:33:24,000 --> 00:33:26,480
executable well in that case we need to

900
00:33:26,480 --> 00:33:30,799
take care also of the static scanner

901
00:33:32,240 --> 00:33:36,080
and so how can we bypass the

902
00:33:36,080 --> 00:33:38,799
like we were talking about talking about

903
00:33:38,799 --> 00:33:40,799
the real times camera how can we bypass

904
00:33:40,799 --> 00:33:42,640
the real-time scanner so the technique

905
00:33:42,640 --> 00:33:45,279
as was as john was saying before is in

906
00:33:45,279 --> 00:33:47,840
memory patching so we just need to

907
00:33:47,840 --> 00:33:49,600
open an handle to the process we are

908
00:33:49,600 --> 00:33:53,039
executing uh to our process detect mc in

909
00:33:53,039 --> 00:33:55,039
memory detect the location of the

910
00:33:55,039 --> 00:33:56,880
function that is actually executing the

911
00:33:56,880 --> 00:33:58,640
scan which is in this case the xampp

912
00:33:58,640 --> 00:34:01,440
system buffer and then we will use a

913
00:34:01,440 --> 00:34:04,640
patch and memory patch to just

914
00:34:04,640 --> 00:34:07,760
avoid the scan to be to return a correct

915
00:34:07,760 --> 00:34:10,480
value so even if my payload contains

916
00:34:10,480 --> 00:34:12,719
known signatures if amps is patched it

917
00:34:12,719 --> 00:34:15,440
won't be able to scan it in this case

918
00:34:15,440 --> 00:34:18,159
this patch is actually achieved

919
00:34:18,159 --> 00:34:20,560
zeroing out the uh register that

920
00:34:20,560 --> 00:34:22,560
contains the length of my buffer so in

921
00:34:22,560 --> 00:34:24,719
if you if you if you're aware about uh

922
00:34:24,719 --> 00:34:29,440
how x64 works um so you will have um the

923
00:34:29,440 --> 00:34:30,560
um

924
00:34:30,560 --> 00:34:31,918
in any function you are actually

925
00:34:31,918 --> 00:34:34,159
executing you will have the parameters

926
00:34:34,159 --> 00:34:39,040
put in rcx are the x r8 and r9 registers

927
00:34:39,040 --> 00:34:43,440
so um in this case r8 is the length of

928
00:34:43,440 --> 00:34:45,040
the payload in this case we are seeing

929
00:34:45,040 --> 00:34:46,879
just the um

930
00:34:46,879 --> 00:34:50,239
like the the left the left side uh 32

931
00:34:50,239 --> 00:34:52,399
bits of r8

932
00:34:52,399 --> 00:34:56,320
sorry the right side um of r8 and this

933
00:34:56,320 --> 00:34:57,920
is passed in edi

934
00:34:57,920 --> 00:35:00,160
and edi is then used as the length of

935
00:35:00,160 --> 00:35:02,560
the payload throughout the scan

936
00:35:02,560 --> 00:35:05,280
if we zero out edi we will zero out the

937
00:35:05,280 --> 00:35:06,640
length so

938
00:35:06,640 --> 00:35:08,320
msi will just say okay this buffer

939
00:35:08,320 --> 00:35:11,440
contains no byte no need to scan it and

940
00:35:11,440 --> 00:35:14,320
it will just break the execution

941
00:35:14,320 --> 00:35:16,720
and this is how we patch msi

942
00:35:16,720 --> 00:35:19,839
for signatures is even easier

943
00:35:19,839 --> 00:35:22,000
to actually bypass signatures because

944
00:35:22,000 --> 00:35:23,920
signicatures are commonly used a

945
00:35:23,920 --> 00:35:26,160
blacklist approach

946
00:35:26,160 --> 00:35:28,480
so if the payload matches signature is

947
00:35:28,480 --> 00:35:30,480
malicious if it's not detected signature

948
00:35:30,480 --> 00:35:32,960
is clear and

949
00:35:32,960 --> 00:35:35,839
sometimes just doing string encryption

950
00:35:35,839 --> 00:35:37,680
so like we are encrypting all the string

951
00:35:37,680 --> 00:35:40,079
returned by our payload is enough to

952
00:35:40,079 --> 00:35:43,119
bypass it like it's not mimikatz because

953
00:35:43,119 --> 00:35:44,800
it doesn't contain the word mimikets

954
00:35:44,800 --> 00:35:45,839
right

955
00:35:45,839 --> 00:35:47,920
but it's still dumping something else as

956
00:35:47,920 --> 00:35:50,079
though well it doesn't care because i'm

957
00:35:50,079 --> 00:35:52,000
i'm stupid i'm just seeing signatures so

958
00:35:52,000 --> 00:35:52,880
i can

959
00:35:52,880 --> 00:35:56,960
if it's not mimicked yeah not many cats

960
00:35:56,960 --> 00:35:59,599
so by passing the samplex instead is way

961
00:35:59,599 --> 00:36:01,359
more complex

962
00:36:01,359 --> 00:36:03,280
and there are a few techniques around

963
00:36:03,280 --> 00:36:04,079
this

964
00:36:04,079 --> 00:36:06,960
um so what what these techniques are

965
00:36:06,960 --> 00:36:09,119
about that there is a very good research

966
00:36:09,119 --> 00:36:10,880
by emmerich nazi

967
00:36:10,880 --> 00:36:12,480
uh 7 guess

968
00:36:12,480 --> 00:36:14,560
the creator of macro pack very good tool

969
00:36:14,560 --> 00:36:17,760
i would recommend actually taking it out

970
00:36:17,760 --> 00:36:18,560
and

971
00:36:18,560 --> 00:36:20,720
so in order to in order to bypass the

972
00:36:20,720 --> 00:36:22,960
sandbox the av sandbox we can use a set

973
00:36:22,960 --> 00:36:25,040
of techniques some of them ranging from

974
00:36:25,040 --> 00:36:27,599
anti-debug techniques that are meant to

975
00:36:27,599 --> 00:36:29,599
understand if we are executing in a

976
00:36:29,599 --> 00:36:31,440
virtualized environment

977
00:36:31,440 --> 00:36:34,000
uh and so in order to do that we can use

978
00:36:34,000 --> 00:36:36,000
non-virtualized function which are

979
00:36:36,000 --> 00:36:38,560
usually so consider a sandbox is a very

980
00:36:38,560 --> 00:36:40,720
small vm so i

981
00:36:40,720 --> 00:36:43,280
i probably don't want to just create a

982
00:36:43,280 --> 00:36:45,440
full vm because it will take too much

983
00:36:45,440 --> 00:36:47,920
resources so the av create a very small

984
00:36:47,920 --> 00:36:50,160
vm with a limited set of virtualized

985
00:36:50,160 --> 00:36:52,880
functions in it just in order to

986
00:36:52,880 --> 00:36:55,359
run my payload so if we if we can

987
00:36:55,359 --> 00:36:56,480
understand

988
00:36:56,480 --> 00:36:58,640
what functions are not virtualized and

989
00:36:58,640 --> 00:37:00,560
we can and we use them

990
00:37:00,560 --> 00:37:02,640
uh we can actually we can actually break

991
00:37:02,640 --> 00:37:05,200
the execution if you are in a sandbox

992
00:37:05,200 --> 00:37:07,119
or we can do other things like checking

993
00:37:07,119 --> 00:37:10,160
if that if a debugger is active or um

994
00:37:10,160 --> 00:37:11,680
doing map section action common

995
00:37:11,680 --> 00:37:13,920
anti-back techniques

996
00:37:13,920 --> 00:37:15,760
the other technique that we can use is

997
00:37:15,760 --> 00:37:18,480
resource disruption resource disruption

998
00:37:18,480 --> 00:37:20,640
is a technique that was working pretty

999
00:37:20,640 --> 00:37:23,119
fine like not long ago

1000
00:37:23,119 --> 00:37:26,240
and the aim is to try to allocate more

1001
00:37:26,240 --> 00:37:29,200
resources than a sandbox can oh low so

1002
00:37:29,200 --> 00:37:31,520
for example if i ask for one gig on the

1003
00:37:31,520 --> 00:37:35,280
hip and i have a very limited vm it will

1004
00:37:35,280 --> 00:37:37,200
probably say yeah okay you're asking too

1005
00:37:37,200 --> 00:37:38,480
much you don't you need too much

1006
00:37:38,480 --> 00:37:40,960
resources to run i can't run it just

1007
00:37:40,960 --> 00:37:42,960
let's keep it

1008
00:37:42,960 --> 00:37:45,359
and another technique instead

1009
00:37:45,359 --> 00:37:47,839
is logical disruption

1010
00:37:47,839 --> 00:37:49,680
or logic deception

1011
00:37:49,680 --> 00:37:51,920
which is like using techniques that are

1012
00:37:51,920 --> 00:37:54,640
impossible to achieve within a vm for

1013
00:37:54,640 --> 00:37:56,160
example we know the user we are

1014
00:37:56,160 --> 00:37:58,880
attacking we just aim to that user the

1015
00:37:58,880 --> 00:38:00,800
vm will not be able to know what user

1016
00:38:00,800 --> 00:38:03,440
i'm attacking so it won't be able to

1017
00:38:03,440 --> 00:38:05,839
actually uh continue the execution if

1018
00:38:05,839 --> 00:38:07,440
i'm targeting if i'm checking the name

1019
00:38:07,440 --> 00:38:09,359
of the user i'm attacking or some other

1020
00:38:09,359 --> 00:38:11,200
techniques checking the register or

1021
00:38:11,200 --> 00:38:12,560
whatever

1022
00:38:12,560 --> 00:38:14,480
so something that i'm expecting in the

1023
00:38:14,480 --> 00:38:16,240
real environment that can't be

1024
00:38:16,240 --> 00:38:18,720
replicated in the vm

1025
00:38:18,720 --> 00:38:19,599
um

1026
00:38:19,599 --> 00:38:22,320
some a technique usually uh implemented

1027
00:38:22,320 --> 00:38:24,720
is actually to check if the vm is joined

1028
00:38:24,720 --> 00:38:27,440
you is domain join for example the check

1029
00:38:27,440 --> 00:38:29,760
if the virtual via is the vm is joined

1030
00:38:29,760 --> 00:38:32,480
to a domain if it's not joined to the

1031
00:38:32,480 --> 00:38:34,480
domain i'm attacking then it will break

1032
00:38:34,480 --> 00:38:36,160
the execution the antivirus can't

1033
00:38:36,160 --> 00:38:38,160
actually replicate that domain and put

1034
00:38:38,160 --> 00:38:40,240
the domain in the vm so that this

1035
00:38:40,240 --> 00:38:42,320
technique is pretty much efficient

1036
00:38:42,320 --> 00:38:44,720
effective

1037
00:38:44,720 --> 00:38:47,040
and then we need to get rid of other

1038
00:38:47,040 --> 00:38:48,960
like thing like we want to get rid of

1039
00:38:48,960 --> 00:38:52,079
etw for example etw is a very complex

1040
00:38:52,079 --> 00:38:54,960
kind piece of piece of um

1041
00:38:54,960 --> 00:38:57,280
logic i would say so

1042
00:38:57,280 --> 00:38:58,880
um it's

1043
00:38:58,880 --> 00:39:00,880
the the the windows even trace actually

1044
00:39:00,880 --> 00:39:02,960
record all events

1045
00:39:02,960 --> 00:39:05,280
that uh a lot of events and a lot of

1046
00:39:05,280 --> 00:39:07,200
them are security related

1047
00:39:07,200 --> 00:39:10,880
uh i'm seeing mc as well as a lot of etw

1048
00:39:10,880 --> 00:39:12,400
events in it

1049
00:39:12,400 --> 00:39:13,760
so

1050
00:39:13,760 --> 00:39:17,200
and what we and why we would want to um

1051
00:39:17,200 --> 00:39:19,440
to to get rid of that is because a lot

1052
00:39:19,440 --> 00:39:22,000
of vdr are actually using the telemetry

1053
00:39:22,000 --> 00:39:25,119
collected by etw to actually um

1054
00:39:25,119 --> 00:39:27,359
correlate more information on the

1055
00:39:27,359 --> 00:39:30,560
payload and classify it as malicious so

1056
00:39:30,560 --> 00:39:33,040
we want to get rid of this so how we can

1057
00:39:33,040 --> 00:39:35,680
do it so in order to patch edw we are

1058
00:39:35,680 --> 00:39:38,000
interested in two different kind of

1059
00:39:38,000 --> 00:39:40,560
execution in etfw the first one is event

1060
00:39:40,560 --> 00:39:42,480
registration once a provider is actually

1061
00:39:42,480 --> 00:39:45,599
registering an event that you want to um

1062
00:39:45,599 --> 00:39:48,400
to trace in the in the windows 11 trace

1063
00:39:48,400 --> 00:39:49,839
registry

1064
00:39:49,839 --> 00:39:52,240
and the other one is the event right so

1065
00:39:52,240 --> 00:39:55,040
like when i am actually riding the event

1066
00:39:55,040 --> 00:39:58,160
in the in the event race

1067
00:39:58,160 --> 00:40:00,240
so in order to get rid of that there are

1068
00:40:00,240 --> 00:40:02,480
two main techniques so one is patching

1069
00:40:02,480 --> 00:40:04,160
we haven't tried the other one is

1070
00:40:04,160 --> 00:40:05,040
actually

1071
00:40:05,040 --> 00:40:07,119
i just i think i'll need to skip a bit

1072
00:40:07,119 --> 00:40:08,319
about this

1073
00:40:08,319 --> 00:40:11,680
the other one is just getting rid of

1074
00:40:11,680 --> 00:40:13,839
all the event registering a specific

1075
00:40:13,839 --> 00:40:16,079
process how does it work so

1076
00:40:16,079 --> 00:40:18,960
in event registration we have this um we

1077
00:40:18,960 --> 00:40:21,680
have old stack so the event register we

1078
00:40:21,680 --> 00:40:23,520
call the notification register that we

1079
00:40:23,520 --> 00:40:26,160
put the registration in a global

1080
00:40:26,160 --> 00:40:28,079
registration table

1081
00:40:28,079 --> 00:40:30,960
and this registration table contains a

1082
00:40:30,960 --> 00:40:31,920
list of

1083
00:40:31,920 --> 00:40:34,720
to all the events that have to be logged

1084
00:40:34,720 --> 00:40:38,240
within the process so if we can detect

1085
00:40:38,240 --> 00:40:40,079
up if we can get a pointer to this

1086
00:40:40,079 --> 00:40:42,000
registration table and this is usually

1087
00:40:42,000 --> 00:40:43,680
achieved just

1088
00:40:43,680 --> 00:40:46,240
um looking in the process memory in the

1089
00:40:46,240 --> 00:40:48,720
process image memory space

1090
00:40:48,720 --> 00:40:50,400
using brute force common brute force

1091
00:40:50,400 --> 00:40:51,760
because we know the

1092
00:40:51,760 --> 00:40:53,760
registration table structure we can

1093
00:40:53,760 --> 00:40:56,720
actually brute force the um the process

1094
00:40:56,720 --> 00:40:58,800
the process address space to locate this

1095
00:40:58,800 --> 00:41:01,440
in memory and we get an angle to that

1096
00:41:01,440 --> 00:41:03,760
and then we traverse this table to just

1097
00:41:03,760 --> 00:41:06,960
call atwm enter register or or the event

1098
00:41:06,960 --> 00:41:09,040
registered in this table and this is one

1099
00:41:09,040 --> 00:41:11,040
way to bypass dw

1100
00:41:11,040 --> 00:41:13,040
is a bit more complicated than the

1101
00:41:13,040 --> 00:41:14,480
memory patching but is also more

1102
00:41:14,480 --> 00:41:16,720
stealthy because a memory patching can

1103
00:41:16,720 --> 00:41:18,319
be detected

1104
00:41:18,319 --> 00:41:20,240
and can lead traces and the other

1105
00:41:20,240 --> 00:41:22,240
technique is exact is the same thing we

1106
00:41:22,240 --> 00:41:25,200
did with amps in dll we do with evan

1107
00:41:25,200 --> 00:41:28,000
etwment right which is in anti-dll the

1108
00:41:28,000 --> 00:41:30,079
patch is of course different and it uses

1109
00:41:30,079 --> 00:41:32,720
a different kind of mechanism but it the

1110
00:41:32,720 --> 00:41:36,240
technique is completely the same

1111
00:41:37,839 --> 00:41:40,960
and then username by bus this is what we

1112
00:41:40,960 --> 00:41:44,400
were talking about and um of course we

1113
00:41:44,400 --> 00:41:46,880
don't when we talk about cisco's manual

1114
00:41:46,880 --> 00:41:48,880
mapping and all that stuff we don't need

1115
00:41:48,880 --> 00:41:51,040
to think that we do where we have to do

1116
00:41:51,040 --> 00:41:53,680
anything from scratch of course we have

1117
00:41:53,680 --> 00:41:55,599
we can't rely on the show we can

1118
00:41:55,599 --> 00:41:58,000
actually stands on shoulders of john's

1119
00:41:58,000 --> 00:42:00,720
that created tools that can help us do

1120
00:42:00,720 --> 00:42:03,760
our work and these tools are can be like

1121
00:42:03,760 --> 00:42:05,520
using a static approach to locate c

1122
00:42:05,520 --> 00:42:07,760
schools or a dynamic approach to locate

1123
00:42:07,760 --> 00:42:09,920
cisco's be with me i'll just explain in

1124
00:42:09,920 --> 00:42:11,520
a second

1125
00:42:11,520 --> 00:42:15,040
so sysbispur sis whispers is a tool

1126
00:42:15,040 --> 00:42:18,960
created by um i think jarvu and actually

1127
00:42:18,960 --> 00:42:21,599
uh and jackson t yes

1128
00:42:21,599 --> 00:42:24,319
and so since whisper one is a way to

1129
00:42:24,319 --> 00:42:26,960
actually produce automatically a set of

1130
00:42:26,960 --> 00:42:30,079
ciscos that you can just take and embed

1131
00:42:30,079 --> 00:42:33,520
in your payload or malware so it's using

1132
00:42:33,520 --> 00:42:35,119
a static approach because using lookup

1133
00:42:35,119 --> 00:42:37,200
tables as john said before

1134
00:42:37,200 --> 00:42:38,319
every

1135
00:42:38,319 --> 00:42:40,960
windows version or build has different

1136
00:42:40,960 --> 00:42:44,160
cisco numbers so jaru did an incredible

1137
00:42:44,160 --> 00:42:46,480
work of mapping all these cisco numbers

1138
00:42:46,480 --> 00:42:48,960
throughout all the windows builds and

1139
00:42:48,960 --> 00:42:51,760
cisco cisco sis whispers verse one

1140
00:42:51,760 --> 00:42:53,920
version one actually uses these lookup

1141
00:42:53,920 --> 00:42:56,240
tables to build the cisco stub for us

1142
00:42:56,240 --> 00:42:58,960
given a windows build

1143
00:42:58,960 --> 00:43:00,640
of course this technique is not really

1144
00:43:00,640 --> 00:43:02,079
doesn't scale well

1145
00:43:02,079 --> 00:43:03,839
so with time

1146
00:43:03,839 --> 00:43:07,440
dynamic kind of resolution um was

1147
00:43:07,440 --> 00:43:10,160
implemented using other techniques so

1148
00:43:10,160 --> 00:43:12,960
since whisper v2 uses a

1149
00:43:12,960 --> 00:43:16,960
cisco called cisco's number ordering

1150
00:43:16,960 --> 00:43:19,280
uh sorry cisco numbers just like locates

1151
00:43:19,280 --> 00:43:21,520
all cisco numbers using

1152
00:43:21,520 --> 00:43:24,480
export addressable ordering so it orders

1153
00:43:24,480 --> 00:43:26,319
the functions because the functions in

1154
00:43:26,319 --> 00:43:27,760
ntdll can

1155
00:43:27,760 --> 00:43:30,400
change the uh like number

1156
00:43:30,400 --> 00:43:31,760
but they

1157
00:43:31,760 --> 00:43:33,839
luckily they like don't change all the

1158
00:43:33,839 --> 00:43:35,440
time so they're pretty much the same

1159
00:43:35,440 --> 00:43:38,560
functions so if you use an ordering

1160
00:43:38,560 --> 00:43:40,720
algorithm over the functions you can

1161
00:43:40,720 --> 00:43:43,359
actually detect the cisco number just

1162
00:43:43,359 --> 00:43:45,440
um just it's a very smart approach

1163
00:43:45,440 --> 00:43:47,839
actually and then it has this this part

1164
00:43:47,839 --> 00:43:50,160
has two two parts like the cisco stop

1165
00:43:50,160 --> 00:43:52,000
creation and an algorithm to locate the

1166
00:43:52,000 --> 00:43:54,319
cisco number at run time

1167
00:43:54,319 --> 00:43:56,160
and then you can just

1168
00:43:56,160 --> 00:43:58,480
take whatever it's output outputted by

1169
00:43:58,480 --> 00:44:00,079
sis whispers you can embed it in your

1170
00:44:00,079 --> 00:44:01,760
payload and you can call six codes that

1171
00:44:01,760 --> 00:44:03,920
way

1172
00:44:04,079 --> 00:44:06,960
uh another technique is

1173
00:44:06,960 --> 00:44:09,599
of course manual mapping and health gate

1174
00:44:09,599 --> 00:44:11,760
else gate is a very cool technique it's

1175
00:44:11,760 --> 00:44:14,640
still uh it's still a technique to

1176
00:44:14,640 --> 00:44:17,440
locate dynamically not even not just the

1177
00:44:17,440 --> 00:44:20,880
cisco number but also the assembly stub

1178
00:44:20,880 --> 00:44:24,160
is actually located at runtime

1179
00:44:24,160 --> 00:44:26,720
and these techniques are invoked by are

1180
00:44:26,720 --> 00:44:28,640
implemented in dimbook

1181
00:44:28,640 --> 00:44:30,560
that also offer support for manual

1182
00:44:30,560 --> 00:44:32,800
mapping which is the one explained by

1183
00:44:32,800 --> 00:44:33,920
john before

1184
00:44:33,920 --> 00:44:36,000
and over mapping which is like the same

1185
00:44:36,000 --> 00:44:37,680
technique just the difference is that

1186
00:44:37,680 --> 00:44:40,560
the entire the copy of ntdll in memory

1187
00:44:40,560 --> 00:44:42,960
is backed up with a file on disk so

1188
00:44:42,960 --> 00:44:43,839
there is

1189
00:44:43,839 --> 00:44:45,920
another object in another section object

1190
00:44:45,920 --> 00:44:48,640
in the process memory space with a file

1191
00:44:48,640 --> 00:44:52,000
endo open to the file to the file on

1192
00:44:52,000 --> 00:44:54,800
disk uh with like protective with second

1193
00:44:54,800 --> 00:44:57,440
mage protection but that's just

1194
00:44:57,440 --> 00:44:59,280
niche to know

1195
00:44:59,280 --> 00:45:00,960
and then there is allows gate which

1196
00:45:00,960 --> 00:45:02,720
wasn't actually i didn't i don't know

1197
00:45:02,720 --> 00:45:04,400
any tool that implemented that is that

1198
00:45:04,400 --> 00:45:05,920
is a new technique by

1199
00:45:05,920 --> 00:45:08,880
um by sector seven

1200
00:45:08,880 --> 00:45:12,000
because else gate is good but if the

1201
00:45:12,000 --> 00:45:14,319
cisco stub is hooked like the c closed

1202
00:45:14,319 --> 00:45:15,839
cap if the

1203
00:45:15,839 --> 00:45:17,599
function is hooked it doesn't really

1204
00:45:17,599 --> 00:45:19,440
work so well

1205
00:45:19,440 --> 00:45:22,160
so allosgate is a technique to patch

1206
00:45:22,160 --> 00:45:25,119
dynamically locate the cisco stub locate

1207
00:45:25,119 --> 00:45:28,160
the the cisco sub and patch it in memory

1208
00:45:28,160 --> 00:45:31,280
if it's hooked so it will just restore

1209
00:45:31,280 --> 00:45:34,240
the original the original cisco stub if

1210
00:45:34,240 --> 00:45:36,560
it finds a nook in it

1211
00:45:36,560 --> 00:45:38,480
very cool technique check it out is

1212
00:45:38,480 --> 00:45:40,720
renzo bisector 7

1213
00:45:40,720 --> 00:45:42,960
very good

1214
00:45:42,960 --> 00:45:44,319
and then we want to blend with our

1215
00:45:44,319 --> 00:45:46,560
target this can this is a set of

1216
00:45:46,560 --> 00:45:49,359
techniques that help us blending with

1217
00:45:49,359 --> 00:45:51,680
our target more and being a bit more

1218
00:45:51,680 --> 00:45:52,880
stealthy

1219
00:45:52,880 --> 00:45:53,680
uh

1220
00:45:53,680 --> 00:45:56,240
even for isis like that are actually

1221
00:45:56,240 --> 00:45:58,720
seeing our payload in in in the file

1222
00:45:58,720 --> 00:46:02,240
system and even for antiviruses because

1223
00:46:02,240 --> 00:46:05,119
they will actually check also this stuff

1224
00:46:05,119 --> 00:46:06,400
um

1225
00:46:06,400 --> 00:46:08,800
in in our payloads so one is metadata

1226
00:46:08,800 --> 00:46:10,960
cloning just actually cloning the

1227
00:46:10,960 --> 00:46:13,119
metadata of a legend of a legitimate

1228
00:46:13,119 --> 00:46:15,440
file can help us just being a little

1229
00:46:15,440 --> 00:46:17,359
more stealthy because we will actually

1230
00:46:17,359 --> 00:46:20,880
resemble a real file on the disk

1231
00:46:20,880 --> 00:46:23,920
and the other one is code signing like

1232
00:46:23,920 --> 00:46:26,079
code signing the loader is a well known

1233
00:46:26,079 --> 00:46:29,119
technique to like avoid being

1234
00:46:29,119 --> 00:46:31,920
over scanned let's say by uh by navy

1235
00:46:31,920 --> 00:46:33,440
like it's known that

1236
00:46:33,440 --> 00:46:35,440
code signed binaries are less

1237
00:46:35,440 --> 00:46:38,400
scrutinized by ab

1238
00:46:38,400 --> 00:46:42,079
by av solutions so we can code sign our

1239
00:46:42,079 --> 00:46:43,440
loader

1240
00:46:43,440 --> 00:46:45,839
and that actually is is a technique that

1241
00:46:45,839 --> 00:46:48,000
works quite efficiently

1242
00:46:48,000 --> 00:46:49,920
uh but there are but there are other

1243
00:46:49,920 --> 00:46:52,480
techniques like self delete the payload

1244
00:46:52,480 --> 00:46:54,480
in memory like when you're executing

1245
00:46:54,480 --> 00:46:55,839
something from fight system you want to

1246
00:46:55,839 --> 00:46:58,240
self-delete it while it's running or

1247
00:46:58,240 --> 00:46:59,760
other techniques there are a set of

1248
00:46:59,760 --> 00:47:02,079
techniques we don't have it them all

1249
00:47:02,079 --> 00:47:04,079
here but there are a set of techniques

1250
00:47:04,079 --> 00:47:06,560
that just help us being less or not

1251
00:47:06,560 --> 00:47:08,480
scrutinized at all or just less

1252
00:47:08,480 --> 00:47:12,160
scrutinized by the adr and also like

1253
00:47:12,160 --> 00:47:14,720
isis of operators

1254
00:47:14,720 --> 00:47:16,800
and then let's bring a bit of automation

1255
00:47:16,800 --> 00:47:17,920
which is

1256
00:47:17,920 --> 00:47:21,040
actually my contribution to this

1257
00:47:21,040 --> 00:47:23,520
so we created this tool which is called

1258
00:47:23,520 --> 00:47:25,680
inceptor

1259
00:47:25,680 --> 00:47:28,400
as i said before i'm pretty open to

1260
00:47:28,400 --> 00:47:30,880
any suggestion ideas or

1261
00:47:30,880 --> 00:47:33,359
issues just open issues so if you want

1262
00:47:33,359 --> 00:47:35,119
to check it out and test it against your

1263
00:47:35,119 --> 00:47:36,960
ab your adr

1264
00:47:36,960 --> 00:47:39,200
if you want to use it in your

1265
00:47:39,200 --> 00:47:40,960
in your engagement i don't know maybe

1266
00:47:40,960 --> 00:47:43,119
better in a test lab just clone the

1267
00:47:43,119 --> 00:47:46,720
repository use it and submit uh pr

1268
00:47:46,720 --> 00:47:48,480
whatever you want because any help is

1269
00:47:48,480 --> 00:47:50,480
accepted so inceptor is a template

1270
00:47:50,480 --> 00:47:51,839
driven

1271
00:47:51,839 --> 00:47:53,280
framework

1272
00:47:53,280 --> 00:47:55,119
which can actually automate all the

1273
00:47:55,119 --> 00:47:57,440
stuff that we were talking about

1274
00:47:57,440 --> 00:47:59,760
and as a way to abstract the shell

1275
00:47:59,760 --> 00:48:01,839
coding retrieval so it can actually

1276
00:48:01,839 --> 00:48:03,359
retrieve the share code wherever you

1277
00:48:03,359 --> 00:48:05,280
want you you don't you're not bound to

1278
00:48:05,280 --> 00:48:07,359
have a blob when you're actually

1279
00:48:07,359 --> 00:48:08,960
building your payload you don't have to

1280
00:48:08,960 --> 00:48:10,480
have a binary blob for the thing you

1281
00:48:10,480 --> 00:48:12,880
want to execute but you can embed it

1282
00:48:12,880 --> 00:48:15,920
within an icon a research a pdf download

1283
00:48:15,920 --> 00:48:17,359
it from internet whatever you want

1284
00:48:17,359 --> 00:48:19,839
because uh inceptor can abstract the way

1285
00:48:19,839 --> 00:48:21,839
you recover your shellcode

1286
00:48:21,839 --> 00:48:23,280
um

1287
00:48:23,280 --> 00:48:26,079
it has automatic encoding uh automatic

1288
00:48:26,079 --> 00:48:27,680
is is is a

1289
00:48:27,680 --> 00:48:30,559
not really true like you can set what

1290
00:48:30,559 --> 00:48:33,680
kind of encoding you want uh inceptor

1291
00:48:33,680 --> 00:48:36,240
differentiate between loader dependent

1292
00:48:36,240 --> 00:48:38,640
encoders and loader independent encoders

1293
00:48:38,640 --> 00:48:40,559
loader independent encoders are shell

1294
00:48:40,559 --> 00:48:42,880
code based so they will actually decode

1295
00:48:42,880 --> 00:48:45,119
your shell code while after you injected

1296
00:48:45,119 --> 00:48:46,240
it

1297
00:48:46,240 --> 00:48:48,480
and it's good but it's not suitable for

1298
00:48:48,480 --> 00:48:51,520
things like assembly load or

1299
00:48:51,520 --> 00:48:54,559
like pe manual mapping because

1300
00:48:54,559 --> 00:48:56,319
of course if you're mapping a pe you

1301
00:48:56,319 --> 00:48:59,040
want to have a pe if you just encrypt it

1302
00:48:59,040 --> 00:49:00,880
it's not a pe anymore so it doesn't make

1303
00:49:00,880 --> 00:49:02,559
sense you have to decrypt it before

1304
00:49:02,559 --> 00:49:04,480
mapping it

1305
00:49:04,480 --> 00:49:07,760
um and so

1306
00:49:07,760 --> 00:49:09,839
i also developed these loader dependent

1307
00:49:09,839 --> 00:49:12,960
encoders that are just encoders the same

1308
00:49:12,960 --> 00:49:14,960
way as loader independent encoders but

1309
00:49:14,960 --> 00:49:16,800
are dependent to the loader so the

1310
00:49:16,800 --> 00:49:19,200
loader will actually be aware of how to

1311
00:49:19,200 --> 00:49:21,359
decode the stub before injecting in

1312
00:49:21,359 --> 00:49:23,760
memory

1313
00:49:23,760 --> 00:49:26,319
and then there is automatic obfuscation

1314
00:49:26,319 --> 00:49:28,640
the native obfuscation is performed by

1315
00:49:28,640 --> 00:49:32,400
using llf the llvm compilation

1316
00:49:32,400 --> 00:49:34,880
the dot net obfuscation is actually is

1317
00:49:34,880 --> 00:49:36,640
based on

1318
00:49:36,640 --> 00:49:38,480
confusion reacts or other public i

1319
00:49:38,480 --> 00:49:41,040
believe available

1320
00:49:41,040 --> 00:49:42,240
for skaters

1321
00:49:42,240 --> 00:49:44,559
and powershell application is obtained

1322
00:49:44,559 --> 00:49:46,079
through chameleon which is a tool i

1323
00:49:46,079 --> 00:49:47,760
developed but you can choose your own

1324
00:49:47,760 --> 00:49:49,440
tool it doesn't make any difference you

1325
00:49:49,440 --> 00:49:52,240
just need to uh create a little

1326
00:49:52,240 --> 00:49:53,520
interface for it

1327
00:49:53,520 --> 00:49:55,440
and you can use it

1328
00:49:55,440 --> 00:49:56,480
and then

1329
00:49:56,480 --> 00:49:58,319
inceptor also provide ways to

1330
00:49:58,319 --> 00:50:00,640
automatically patch msi

1331
00:50:00,640 --> 00:50:02,559
windows lockdown policy well we didn't

1332
00:50:02,559 --> 00:50:06,240
talk too much about that wldp and etw in

1333
00:50:06,240 --> 00:50:10,160
memory before doing anything else

1334
00:50:10,160 --> 00:50:12,160
and it offers a way to compile

1335
00:50:12,160 --> 00:50:14,559
automatically and package offer a lot

1336
00:50:14,559 --> 00:50:17,599
like a few different compilers uh it has

1337
00:50:17,599 --> 00:50:21,520
a raptor for ms build csc cl clank cl

1338
00:50:21,520 --> 00:50:24,400
and llvmcl

1339
00:50:24,400 --> 00:50:27,119
so it offers for automatic compiling and

1340
00:50:27,119 --> 00:50:30,319
packing it also can pack.net binaries

1341
00:50:30,319 --> 00:50:32,319
which are which are built on top of

1342
00:50:32,319 --> 00:50:34,319
other dlls

1343
00:50:34,319 --> 00:50:36,079
so it's pretty suitable if you want if

1344
00:50:36,079 --> 00:50:37,760
you have just a dll that is working and

1345
00:50:37,760 --> 00:50:39,119
you just want to use that in your

1346
00:50:39,119 --> 00:50:42,480
malware is fine it automatically compile

1347
00:50:42,480 --> 00:50:44,240
it

1348
00:50:44,240 --> 00:50:46,079
and then it has also techniques to blend

1349
00:50:46,079 --> 00:50:48,000
with the target so all the techniques

1350
00:50:48,000 --> 00:50:50,000
about metadata cloning

1351
00:50:50,000 --> 00:50:53,520
code signing self deleting and other

1352
00:50:53,520 --> 00:50:55,200
techniques that i don't recall at the

1353
00:50:55,200 --> 00:50:56,720
moment

1354
00:50:56,720 --> 00:50:59,040
are already present in the tool

1355
00:50:59,040 --> 00:51:01,040
and we are actually implementing more

1356
00:51:01,040 --> 00:51:03,920
and more stuff with time

1357
00:51:03,920 --> 00:51:05,680
as i said if you have anything that you

1358
00:51:05,680 --> 00:51:07,280
want to actually

1359
00:51:07,280 --> 00:51:10,079
add to this tool if any any improvement

1360
00:51:10,079 --> 00:51:12,960
please reach out because i'm working on

1361
00:51:12,960 --> 00:51:15,599
of course in my spare time and yeah

1362
00:51:15,599 --> 00:51:16,720
it's

1363
00:51:16,720 --> 00:51:18,319
tough

1364
00:51:18,319 --> 00:51:20,880
and that's it we have for maybe a little

1365
00:51:20,880 --> 00:51:23,839
demo to

1366
00:51:28,559 --> 00:51:31,520
so this is a little demo about inceptor

1367
00:51:31,520 --> 00:51:33,839
and

1368
00:51:34,559 --> 00:51:36,880
it's just it's just to show that

1369
00:51:36,880 --> 00:51:39,119
inceptor can use automatically provide

1370
00:51:39,119 --> 00:51:41,760
support for um

1371
00:51:41,760 --> 00:51:43,200
for dimbook

1372
00:51:43,200 --> 00:51:45,839
you just need to specify

1373
00:51:45,839 --> 00:51:47,520
like a few parameters in when you're

1374
00:51:47,520 --> 00:51:49,839
generating your payload so here we are

1375
00:51:49,839 --> 00:51:51,520
just generating a meta on the

1376
00:51:51,520 --> 00:51:52,640
interpreter

1377
00:51:52,640 --> 00:51:55,440
kind of payload

1378
00:51:55,440 --> 00:52:01,160
and after that we pack it using inceptor

1379
00:52:04,000 --> 00:52:06,000
and the first time we'll just pack it

1380
00:52:06,000 --> 00:52:07,280
using

1381
00:52:07,280 --> 00:52:09,440
a common uh

1382
00:52:09,440 --> 00:52:11,760
a common classic pinbook

1383
00:52:11,760 --> 00:52:14,720
kind of thing so we

1384
00:52:14,880 --> 00:52:17,040
yeah i don't know why this is spawning

1385
00:52:17,040 --> 00:52:19,599
oh yeah i just uh yeah i did it this way

1386
00:52:19,599 --> 00:52:21,760
so first round no dim book

1387
00:52:21,760 --> 00:52:23,599
cisco

1388
00:52:23,599 --> 00:52:26,720
uh nothing at all we just have the we

1389
00:52:26,720 --> 00:52:28,000
just have the

1390
00:52:28,000 --> 00:52:30,240
the pmbok routine

1391
00:52:30,240 --> 00:52:32,960
so pimvo as we were saying with john is

1392
00:52:32,960 --> 00:52:34,800
can be detected by user land looking

1393
00:52:34,800 --> 00:52:36,960
because we are just importing statically

1394
00:52:36,960 --> 00:52:38,400
importing our

1395
00:52:38,400 --> 00:52:40,559
the function we want to use

1396
00:52:40,559 --> 00:52:41,440
and

1397
00:52:41,440 --> 00:52:43,520
so we we are detect we are detectable

1398
00:52:43,520 --> 00:52:46,720
both by using i80 uking hooking or

1399
00:52:46,720 --> 00:52:48,800
inline rooking doesn't matter we just

1400
00:52:48,800 --> 00:52:51,280
detected because every function that we

1401
00:52:51,280 --> 00:52:52,480
import

1402
00:52:52,480 --> 00:52:53,599
will be

1403
00:52:53,599 --> 00:52:56,000
present in

1404
00:52:56,000 --> 00:52:58,160
in our import of this table so now we're

1405
00:52:58,160 --> 00:53:00,160
just using frida which is a it's not an

1406
00:53:00,160 --> 00:53:02,880
edr of course but it's still doing the

1407
00:53:02,880 --> 00:53:04,800
same thing that the edr does so it's

1408
00:53:04,800 --> 00:53:06,400
install oops

1409
00:53:06,400 --> 00:53:09,040
on the function that we want to hook

1410
00:53:09,040 --> 00:53:10,640
and as you can see

1411
00:53:10,640 --> 00:53:12,640
the payload executes

1412
00:53:12,640 --> 00:53:14,400
we have a shell

1413
00:53:14,400 --> 00:53:17,680
but we are detected so an edr

1414
00:53:17,680 --> 00:53:20,400
doing the same thing we just say

1415
00:53:20,400 --> 00:53:21,760
what are you doing you're creating a

1416
00:53:21,760 --> 00:53:22,960
thread

1417
00:53:22,960 --> 00:53:26,240
just i'll stop you

1418
00:53:26,240 --> 00:53:27,040
yeah

1419
00:53:27,040 --> 00:53:29,440
this one was this one i want to explain

1420
00:53:29,440 --> 00:53:33,359
this one was a mute uh video so in in

1421
00:53:33,359 --> 00:53:35,440
every having in cases when i can't

1422
00:53:35,440 --> 00:53:36,880
actually speak

1423
00:53:36,880 --> 00:53:40,000
uh i also added this just to let you

1424
00:53:40,000 --> 00:53:42,000
understand more

1425
00:53:42,000 --> 00:53:44,559
in the second case what we want to do we

1426
00:53:44,559 --> 00:53:47,200
will pack the same interpreter payload

1427
00:53:47,200 --> 00:53:49,040
but we will use the invoke i don't know

1428
00:53:49,040 --> 00:53:53,200
if it's clear actually if it's inable

1429
00:53:54,720 --> 00:53:56,960
so yeah here we are just deleting the

1430
00:53:56,960 --> 00:53:58,319
file

1431
00:53:58,319 --> 00:53:59,599
and we are

1432
00:53:59,599 --> 00:54:02,079
returning to inceptor and then we use

1433
00:54:02,079 --> 00:54:04,960
the um dim book sorry it's not senable

1434
00:54:04,960 --> 00:54:07,440
we're using the dimbok module

1435
00:54:07,440 --> 00:54:09,119
to generate the payload this will

1436
00:54:09,119 --> 00:54:10,400
actually

1437
00:54:10,400 --> 00:54:12,640
help us using another template which is

1438
00:54:12,640 --> 00:54:15,359
the dimvok manual mapping here so we

1439
00:54:15,359 --> 00:54:17,760
will use manual mapping this time

1440
00:54:17,760 --> 00:54:20,240
is the same kind of payload just packed

1441
00:54:20,240 --> 00:54:23,040
using dimbook

1442
00:54:23,200 --> 00:54:25,839
and the same thing the notepad will be

1443
00:54:25,839 --> 00:54:26,880
spawned

1444
00:54:26,880 --> 00:54:28,559
and the notepad is just

1445
00:54:28,559 --> 00:54:30,240
the payload the sacrificial process we

1446
00:54:30,240 --> 00:54:33,680
spawn to actually inject into it

1447
00:54:34,160 --> 00:54:35,760
and then

1448
00:54:35,760 --> 00:54:38,400
this payload will inject into notepad

1449
00:54:38,400 --> 00:54:40,799
and start the handler

1450
00:54:40,799 --> 00:54:43,359
and yeah we have a shell now

1451
00:54:43,359 --> 00:54:47,040
but we have zero detection by frida like

1452
00:54:47,040 --> 00:54:50,640
the the call 20 create red x was not

1453
00:54:50,640 --> 00:54:51,760
called

1454
00:54:51,760 --> 00:54:53,359
and the reason why it's not cocked is

1455
00:54:53,359 --> 00:54:56,160
because we use the nt create red x

1456
00:54:56,160 --> 00:54:59,440
inside the manually mapped anti-dll if

1457
00:54:59,440 --> 00:55:00,799
you're wondering how this works it's

1458
00:55:00,799 --> 00:55:02,240
just

1459
00:55:02,240 --> 00:55:04,240
you we're just locating in memory we're

1460
00:55:04,240 --> 00:55:05,920
just getting an angle to our module in

1461
00:55:05,920 --> 00:55:08,720
memory and we just have to detect

1462
00:55:08,720 --> 00:55:11,520
the function in that module so it's just

1463
00:55:11,520 --> 00:55:13,599
a matter of scanning the process memory

1464
00:55:13,599 --> 00:55:15,839
in the right location until we found the

1465
00:55:15,839 --> 00:55:17,599
function pointer that we want to execute

1466
00:55:17,599 --> 00:55:19,760
and then execute

1467
00:55:19,760 --> 00:55:21,680
and that's it

1468
00:55:21,680 --> 00:55:24,160
we have it

1469
00:55:25,280 --> 00:55:27,680
yeah it's finished

1470
00:55:27,680 --> 00:55:28,960
and thanks for

1471
00:55:28,960 --> 00:55:31,760
listening so far and hope you enjoyed

1472
00:55:31,760 --> 00:55:33,599
that

1473
00:55:33,599 --> 00:55:38,440
have a nice rest of the day

