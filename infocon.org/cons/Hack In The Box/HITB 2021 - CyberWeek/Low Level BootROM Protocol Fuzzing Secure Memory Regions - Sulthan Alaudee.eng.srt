1
00:00:06,000 --> 00:00:09,120
hello everyone uh my name is uh

2
00:00:09,120 --> 00:00:10,160
sultan

3
00:00:10,160 --> 00:00:12,559
alolin i'm from uh

4
00:00:12,559 --> 00:00:14,160
venus labs i'm working as a senior

5
00:00:14,160 --> 00:00:16,160
hardware security researcher so

6
00:00:16,160 --> 00:00:18,240
basically today's talk is about

7
00:00:18,240 --> 00:00:20,240
microcontroller boot home security

8
00:00:20,240 --> 00:00:22,720
and low level protocol fuzzing

9
00:00:22,720 --> 00:00:25,119
and how do we assess access any secure

10
00:00:25,119 --> 00:00:26,720
memory regions

11
00:00:26,720 --> 00:00:28,640
this stock is not limited to the bootrom

12
00:00:28,640 --> 00:00:30,000
alone but we'll cover the whole

13
00:00:30,000 --> 00:00:33,039
microcontroller also

14
00:00:34,160 --> 00:00:37,440
i hope my voice is audible

15
00:00:37,840 --> 00:00:39,920
my wife is audible right okay great

16
00:00:39,920 --> 00:00:41,040
great

17
00:00:41,040 --> 00:00:42,079
okay

18
00:00:42,079 --> 00:00:44,879
so today's stock agenda uh will be about

19
00:00:44,879 --> 00:00:47,280
the speaker bio about myself

20
00:00:47,280 --> 00:00:49,520
uh then uh i'll talk about the

21
00:00:49,520 --> 00:00:51,520
microcontroller bootrom function

22
00:00:51,520 --> 00:00:53,520
and what are the securities of the boot

23
00:00:53,520 --> 00:00:54,399
rom

24
00:00:54,399 --> 00:00:56,640
and uh why do we need uh for

25
00:00:56,640 --> 00:00:58,399
fuzzing low low protocols

26
00:00:58,399 --> 00:00:59,760
in the

27
00:00:59,760 --> 00:01:01,280
microcontroller

28
00:01:01,280 --> 00:01:03,840
and finally we will

29
00:01:03,840 --> 00:01:05,760
showcase some vulnerabilities which we

30
00:01:05,760 --> 00:01:07,200
discovered in uh in modern

31
00:01:07,200 --> 00:01:08,960
microcontrollers

32
00:01:08,960 --> 00:01:11,280
and finally the conclusions and what's

33
00:01:11,280 --> 00:01:14,400
the next steps we would like to do

34
00:01:16,000 --> 00:01:19,119
ah okay about myself i'm a senior

35
00:01:19,119 --> 00:01:20,720
hardware security researcher at zenith

36
00:01:20,720 --> 00:01:22,799
labs digital 14

37
00:01:22,799 --> 00:01:24,840
i mainly work on embedded systems and

38
00:01:24,840 --> 00:01:27,119
security i come from an automotive and

39
00:01:27,119 --> 00:01:28,640
industrial control system background

40
00:01:28,640 --> 00:01:31,280
where i worked on different ecu's and

41
00:01:31,280 --> 00:01:32,799
ecu security

42
00:01:32,799 --> 00:01:34,880
and also on industry control systems

43
00:01:34,880 --> 00:01:37,680
mainly on scada and plcs and dcs systems

44
00:01:37,680 --> 00:01:39,119
and their security

45
00:01:39,119 --> 00:01:40,400
my research interest

46
00:01:40,400 --> 00:01:42,960
is mainly on low level embedded systems

47
00:01:42,960 --> 00:01:45,200
uh fuzzing fuzzing is something i do uh

48
00:01:45,200 --> 00:01:46,640
most of the time and my personal time

49
00:01:46,640 --> 00:01:49,439
into fuzzing of different hardwares uh

50
00:01:49,439 --> 00:01:50,880
mainly on usb

51
00:01:50,880 --> 00:01:53,119
that's something which i uh i

52
00:01:53,119 --> 00:01:54,399
mostly work into

53
00:01:54,399 --> 00:01:56,320
and finally uh fault and side channel

54
00:01:56,320 --> 00:01:57,759
attacks is something i do not into an

55
00:01:57,759 --> 00:01:58,960
organization

56
00:01:58,960 --> 00:02:00,880
and anything on hardware-based security

57
00:02:00,880 --> 00:02:03,600
is my interest

58
00:02:06,159 --> 00:02:06,960
okay

59
00:02:06,960 --> 00:02:09,840
let's get into the talk

60
00:02:10,000 --> 00:02:11,520
what are boot run functions what is

61
00:02:11,520 --> 00:02:13,200
actually a boot rom a boot rom is a

62
00:02:13,200 --> 00:02:15,680
small uh small immutable piece of code

63
00:02:15,680 --> 00:02:18,239
uh which cannot be changed uh inside the

64
00:02:18,239 --> 00:02:20,400
microcontroller and fine and they are

65
00:02:20,400 --> 00:02:21,440
very much

66
00:02:21,440 --> 00:02:23,280
uh very small in size

67
00:02:23,280 --> 00:02:25,680
basically a few kilobytes of size

68
00:02:25,680 --> 00:02:27,520
and they are like very much hard coded

69
00:02:27,520 --> 00:02:30,000
in in your microcontroller so uh as a

70
00:02:30,000 --> 00:02:32,560
user you cannot uh erase or you cannot

71
00:02:32,560 --> 00:02:37,840
rewrite the uh the rom uh the boot rom

72
00:02:39,680 --> 00:02:40,720
and

73
00:02:40,720 --> 00:02:42,239
the next step of a boot rom is basically

74
00:02:42,239 --> 00:02:44,400
after every power on reset uh the code

75
00:02:44,400 --> 00:02:46,400
executes from here so it's uh it's like

76
00:02:46,400 --> 00:02:47,440
a design

77
00:02:47,440 --> 00:02:49,360
that the hardware manufacturer or the

78
00:02:49,360 --> 00:02:51,120
microcontroller manufacturer

79
00:02:51,120 --> 00:02:52,640
puts into that after every power on

80
00:02:52,640 --> 00:02:55,040
reset the code has to execute from here

81
00:02:55,040 --> 00:02:57,760
and uh there are like a few vendors who

82
00:02:57,760 --> 00:02:59,599
provide that you can okay you can if you

83
00:02:59,599 --> 00:03:01,440
don't want my boot rom you can just uh

84
00:03:01,440 --> 00:03:03,760
set some otps or set some bits in the

85
00:03:03,760 --> 00:03:05,840
register then uh you can just move on

86
00:03:05,840 --> 00:03:08,480
from uh the code which you you flash

87
00:03:08,480 --> 00:03:10,959
into it

88
00:03:11,040 --> 00:03:12,720
and uh the main the main function of the

89
00:03:12,720 --> 00:03:14,800
boot rom is uh it's better to decide

90
00:03:14,800 --> 00:03:16,560
whether it uh boots from the internal

91
00:03:16,560 --> 00:03:18,560
flash or if you want to run from the

92
00:03:18,560 --> 00:03:22,080
bootloader or the other rom code

93
00:03:23,120 --> 00:03:25,040
and this is a very important function of

94
00:03:25,040 --> 00:03:27,360
a boot rom basically most of the

95
00:03:27,360 --> 00:03:30,720
security of of the microcontroller is

96
00:03:30,720 --> 00:03:33,040
residing in the boot rom so basically it

97
00:03:33,040 --> 00:03:35,440
checks uh security checks like secure

98
00:03:35,440 --> 00:03:37,760
boot validation uh secure firmware

99
00:03:37,760 --> 00:03:40,400
update and debug enable and disable

100
00:03:40,400 --> 00:03:42,319
in case of secure boot uh basically your

101
00:03:42,319 --> 00:03:46,000
microcontroller uh has certain otp fuses

102
00:03:46,000 --> 00:03:48,480
where you can uh

103
00:03:48,480 --> 00:03:50,640
you can burn the hash of your public key

104
00:03:50,640 --> 00:03:52,640
and then you verify the image with the

105
00:03:52,640 --> 00:03:54,879
corresponding uh you sign you sign and

106
00:03:54,879 --> 00:03:56,319
you sign the image with your private key

107
00:03:56,319 --> 00:03:58,239
then you verify with the hash of the

108
00:03:58,239 --> 00:03:59,439
public key

109
00:03:59,439 --> 00:04:01,599
and uh regarding a firmware update

110
00:04:01,599 --> 00:04:03,200
that's how modern microcontrollers

111
00:04:03,200 --> 00:04:05,519
nowadays provide they like uh they

112
00:04:05,519 --> 00:04:07,439
provide the user to update firmware

113
00:04:07,439 --> 00:04:09,920
securely uh you can either uh both

114
00:04:09,920 --> 00:04:11,599
encrypt the firmware you can sign the

115
00:04:11,599 --> 00:04:13,519
firmware and then you can flash into the

116
00:04:13,519 --> 00:04:15,519
hardware so basically the boot rom

117
00:04:15,519 --> 00:04:18,560
actually uh checks whether uh it's uh

118
00:04:18,560 --> 00:04:20,478
properly uh encrypted means that there's

119
00:04:20,478 --> 00:04:22,800
a proper key to decrypt it then it can

120
00:04:22,800 --> 00:04:24,800
verify using the root of hash or the

121
00:04:24,800 --> 00:04:26,960
other otp fuses

122
00:04:26,960 --> 00:04:30,240
and finally uh the debug part is now is

123
00:04:30,240 --> 00:04:32,000
part of the threat model so many

124
00:04:32,000 --> 00:04:34,400
microcontrollers uh uh they go into the

125
00:04:34,400 --> 00:04:36,240
field they're like part of your product

126
00:04:36,240 --> 00:04:38,479
it's it's accessible to the user uh but

127
00:04:38,479 --> 00:04:40,240
the company doesn't want the the

128
00:04:40,240 --> 00:04:43,440
manufacturer or the user uh the who who

129
00:04:43,440 --> 00:04:44,880
develops the product doesn't wants you

130
00:04:44,880 --> 00:04:47,120
to poke up with the with the firmware so

131
00:04:47,120 --> 00:04:48,960
they basically disable the uh the

132
00:04:48,960 --> 00:04:50,960
database access or any other

133
00:04:50,960 --> 00:04:52,320
programmable interface to the

134
00:04:52,320 --> 00:04:55,040
microcontroller

135
00:04:55,759 --> 00:04:57,280
and the next important function of the

136
00:04:57,280 --> 00:04:59,520
boot rom is basically it transfer

137
00:04:59,520 --> 00:05:01,919
controls uh to the user application uh

138
00:05:01,919 --> 00:05:04,080
basically it can be a secondary boot

139
00:05:04,080 --> 00:05:06,160
loader uh it can be a bad metal

140
00:05:06,160 --> 00:05:08,240
application or or a real-time operating

141
00:05:08,240 --> 00:05:09,680
system which you can

142
00:05:09,680 --> 00:05:12,080
run top of it so that's one of the main

143
00:05:12,080 --> 00:05:14,080
function so once the bootrom executes it

144
00:05:14,080 --> 00:05:16,000
does all the security checks then it

145
00:05:16,000 --> 00:05:17,840
finally hands over the control to the uh

146
00:05:17,840 --> 00:05:19,440
the bootloader or the second reboot

147
00:05:19,440 --> 00:05:21,520
loader or the uh or any barometer

148
00:05:21,520 --> 00:05:25,199
application you write top of it

149
00:05:25,199 --> 00:05:27,039
and finally this is a very important one

150
00:05:27,039 --> 00:05:30,400
uh it acts as a trust anchor so so so so

151
00:05:30,400 --> 00:05:31,840
most of the com vendors the

152
00:05:31,840 --> 00:05:33,919
microcontroller vendors uh provide you

153
00:05:33,919 --> 00:05:36,080
the uh they provide a immutable boot rom

154
00:05:36,080 --> 00:05:37,680
so the the user or the developers who

155
00:05:37,680 --> 00:05:39,280
are going to use this microcontroller

156
00:05:39,280 --> 00:05:41,600
has to trust it that's a trust tested

157
00:05:41,600 --> 00:05:43,600
base for them so they know that it comes

158
00:05:43,600 --> 00:05:45,360
from the vendor so nobody can change

159
00:05:45,360 --> 00:05:46,560
nobody can

160
00:05:46,560 --> 00:05:48,400
uh edit any of the boot roms so they

161
00:05:48,400 --> 00:05:50,000
believe that the boot rom is the most

162
00:05:50,000 --> 00:05:52,720
secure part and there's no chance to

163
00:05:52,720 --> 00:05:55,360
rewrite it so it acts as a trust anchor

164
00:05:55,360 --> 00:05:58,560
and also uh it it it enables you to

165
00:05:58,560 --> 00:06:00,319
transfer the root of trust from the boot

166
00:06:00,319 --> 00:06:03,120
rom to the next bootloaders and the and

167
00:06:03,120 --> 00:06:05,440
the next application which is on top of

168
00:06:05,440 --> 00:06:07,840
it

169
00:06:14,160 --> 00:06:15,120
okay

170
00:06:15,120 --> 00:06:16,240
this is what

171
00:06:16,240 --> 00:06:18,160
different vendor provides basically i

172
00:06:18,160 --> 00:06:20,240
have listed out at least the top five

173
00:06:20,240 --> 00:06:22,479
vendors basically of microcontroller uh

174
00:06:22,479 --> 00:06:24,880
they're like uh all are 32-bit series uh

175
00:06:24,880 --> 00:06:26,400
basically if you see the bootra

176
00:06:26,400 --> 00:06:28,319
functions uh for all almost all the

177
00:06:28,319 --> 00:06:30,479
microcontrollers are same uh but with

178
00:06:30,479 --> 00:06:32,880
different terminology so almost uh most

179
00:06:32,880 --> 00:06:34,319
of the secure or the modern

180
00:06:34,319 --> 00:06:36,800
microcontrollers which provide security

181
00:06:36,800 --> 00:06:38,880
they have this flash security where

182
00:06:38,880 --> 00:06:41,280
you can lock the flash and nobody can

183
00:06:41,280 --> 00:06:43,680
access it once it goes into the product

184
00:06:43,680 --> 00:06:45,600
and it goes to the field and after that

185
00:06:45,600 --> 00:06:48,400
you can even have secure boat in case of

186
00:06:48,400 --> 00:06:50,560
nxp

187
00:06:50,560 --> 00:06:52,880
sorry

188
00:06:53,520 --> 00:06:55,599
in case of nxp you have this flash

189
00:06:55,599 --> 00:06:57,759
security secure boot debug

190
00:06:57,759 --> 00:06:59,759
authentication as i said it is basically

191
00:06:59,759 --> 00:07:01,599
your jtag authentication if you want to

192
00:07:01,599 --> 00:07:03,680
connect a jtag of or if the device comes

193
00:07:03,680 --> 00:07:06,160
for a field return so you need to have a

194
00:07:06,160 --> 00:07:08,639
kind of debug authentication where the

195
00:07:08,639 --> 00:07:11,039
developer wants to use a secure jtag

196
00:07:11,039 --> 00:07:13,360
interface in order to see what kind of

197
00:07:13,360 --> 00:07:16,400
problems uh the device faced

198
00:07:16,400 --> 00:07:18,080
another one is basically the firmware

199
00:07:18,080 --> 00:07:20,160
decrypt verify and update so this is

200
00:07:20,160 --> 00:07:22,800
basically found in uh almost all modern

201
00:07:22,800 --> 00:07:25,280
controllers where you want to uh decrypt

202
00:07:25,280 --> 00:07:27,599
a firmware blob then you want to verify

203
00:07:27,599 --> 00:07:29,680
the blob and then finally update updated

204
00:07:29,680 --> 00:07:31,919
to the flash memory and there's terminal

205
00:07:31,919 --> 00:07:33,520
terminology in nxp they basically they

206
00:07:33,520 --> 00:07:35,520
call it as uh in system programming or

207
00:07:35,520 --> 00:07:38,560
isp or in application programming where

208
00:07:38,560 --> 00:07:40,400
and the the user application can call

209
00:07:40,400 --> 00:07:42,400
the boot rom to do uh most of the

210
00:07:42,400 --> 00:07:44,800
security stuff for them

211
00:07:44,800 --> 00:07:46,720
and again in st it's similar you have

212
00:07:46,720 --> 00:07:48,240
the reload protection or the property

213
00:07:48,240 --> 00:07:50,720
code protection then you have the unique

214
00:07:50,720 --> 00:07:52,080
entry boot it's again the secure boot

215
00:07:52,080 --> 00:07:53,440
concept

216
00:07:53,440 --> 00:07:55,520
and again venice they also provide the

217
00:07:55,520 --> 00:07:57,360
same debug protection then you can

218
00:07:57,360 --> 00:07:58,960
update the firmware then again you have

219
00:07:58,960 --> 00:08:01,199
secure boot and all you have tested

220
00:08:01,199 --> 00:08:02,879
memory

221
00:08:02,879 --> 00:08:04,800
so if you see that basically all the

222
00:08:04,800 --> 00:08:07,120
microcontrollers uh provide the most of

223
00:08:07,120 --> 00:08:08,160
the security functions but the

224
00:08:08,160 --> 00:08:10,400
terminology defaults and the important

225
00:08:10,400 --> 00:08:12,560
thing to note here is that

226
00:08:12,560 --> 00:08:13,840
the boot rom

227
00:08:13,840 --> 00:08:15,919
is responsible for

228
00:08:15,919 --> 00:08:19,680
most of the security functions here

229
00:08:25,680 --> 00:08:27,039
okay what are the use cases of

230
00:08:27,039 --> 00:08:28,479
microcontroller you know that

231
00:08:28,479 --> 00:08:30,800
microcontroller is almost found in uh

232
00:08:30,800 --> 00:08:33,120
all of your devices your day-to-day

233
00:08:33,120 --> 00:08:34,719
devices you have the routers in your

234
00:08:34,719 --> 00:08:36,640
home uh it has a microcontroller you

235
00:08:36,640 --> 00:08:38,080
have a washing machine you have a

236
00:08:38,080 --> 00:08:40,479
refrigerator even in your mobile phones

237
00:08:40,479 --> 00:08:42,320
microcontroller can offload certain

238
00:08:42,320 --> 00:08:44,720
tasks for you so it's almost found in

239
00:08:44,720 --> 00:08:46,880
almost most of the day-to-day devices we

240
00:08:46,880 --> 00:08:47,680
have

241
00:08:47,680 --> 00:08:49,760
and basically how does a microcontroller

242
00:08:49,760 --> 00:08:51,600
usually gets interfaced so basically you

243
00:08:51,600 --> 00:08:54,480
have a soc and uh that's your main

244
00:08:54,480 --> 00:08:55,920
processor then you have a small

245
00:08:55,920 --> 00:08:57,760
microcontroller and basically there's an

246
00:08:57,760 --> 00:09:00,560
interface using an spi in other case you

247
00:09:00,560 --> 00:09:02,480
have an application processor then you

248
00:09:02,480 --> 00:09:04,640
have an i square c interface uh then you

249
00:09:04,640 --> 00:09:07,120
connect your mcu where both parties

250
00:09:07,120 --> 00:09:09,120
exchange uh data or information between

251
00:09:09,120 --> 00:09:09,839
them

252
00:09:09,839 --> 00:09:11,519
and finally uh this is the overall

253
00:09:11,519 --> 00:09:14,640
picture how a host uh processor uh talks

254
00:09:14,640 --> 00:09:16,480
to the client it's basically your

255
00:09:16,480 --> 00:09:18,399
microcontroller via any of these

256
00:09:18,399 --> 00:09:20,480
interfaces which their vendor provides

257
00:09:20,480 --> 00:09:22,080
basically uh these interfaces are very

258
00:09:22,080 --> 00:09:24,399
much common in modern microcontrollers

259
00:09:24,399 --> 00:09:26,560
and it's depend upon the developers or

260
00:09:26,560 --> 00:09:28,480
the use cases what which interface they

261
00:09:28,480 --> 00:09:30,959
want to use

262
00:09:32,160 --> 00:09:34,399
as i said earlier microcontrollers are

263
00:09:34,399 --> 00:09:37,120
used to connect a larger host to these

264
00:09:37,120 --> 00:09:39,920
specific functions

265
00:09:40,160 --> 00:09:42,399
and it provides data exchange you can

266
00:09:42,399 --> 00:09:44,000
easily program the mcu's through the

267
00:09:44,000 --> 00:09:46,480
host so if you have a main processor and

268
00:09:46,480 --> 00:09:48,640
if you want to feel upgraded it then the

269
00:09:48,640 --> 00:09:51,040
host is responsible uh to program the

270
00:09:51,040 --> 00:09:52,880
mcu's and this happens through entire

271
00:09:52,880 --> 00:09:55,760
product lifecycle

272
00:09:56,080 --> 00:09:57,600
and if you want to talk to any of the

273
00:09:57,600 --> 00:10:00,000
bootron federals the the the vendor

274
00:10:00,000 --> 00:10:02,240
provides a set of commands uh basically

275
00:10:02,240 --> 00:10:03,920
it differs from different uh

276
00:10:03,920 --> 00:10:06,560
microcontrollers so one microcontroller

277
00:10:06,560 --> 00:10:08,480
can provide a different set of commands

278
00:10:08,480 --> 00:10:10,079
and other other vendor can provide a

279
00:10:10,079 --> 00:10:11,839
different set of commands why is that

280
00:10:11,839 --> 00:10:14,480
the boot rom is is a black box so

281
00:10:14,480 --> 00:10:16,079
basically they don't share the source of

282
00:10:16,079 --> 00:10:17,279
the boot wrong

283
00:10:17,279 --> 00:10:18,399
all you get is

284
00:10:18,399 --> 00:10:20,959
it's a it's a hard coded memory there

285
00:10:20,959 --> 00:10:22,079
and uh

286
00:10:22,079 --> 00:10:23,680
and and you have a documentation where

287
00:10:23,680 --> 00:10:26,240
the the vendor provides how to talk with

288
00:10:26,240 --> 00:10:26,959
the

289
00:10:26,959 --> 00:10:28,399
boot rom in case if you want to access

290
00:10:28,399 --> 00:10:32,040
any of the security functions

291
00:10:32,640 --> 00:10:33,839
so uh

292
00:10:33,839 --> 00:10:36,000
most time uh all the all the

293
00:10:36,000 --> 00:10:38,079
microcontrollers which uh talks to the

294
00:10:38,079 --> 00:10:40,160
host uh works in the client mode so

295
00:10:40,160 --> 00:10:42,320
basically if any transaction has to be

296
00:10:42,320 --> 00:10:45,360
happen the host has to initiate it and

297
00:10:45,360 --> 00:10:48,880
the host can be a pc or an embedded uh

298
00:10:48,880 --> 00:10:50,000
device

299
00:10:50,000 --> 00:10:50,720
and

300
00:10:50,720 --> 00:10:52,079
basically the bootloader is the target

301
00:10:52,079 --> 00:10:53,920
which receives the command and processes

302
00:10:53,920 --> 00:10:56,480
it and responds back

303
00:10:56,480 --> 00:10:59,040
any examples for it basically you have

304
00:10:59,040 --> 00:11:02,399
uh the tpm chips in your laptops or any

305
00:11:02,399 --> 00:11:04,240
strong box uh secure elements in your

306
00:11:04,240 --> 00:11:06,560
mobile phones so basically they all talk

307
00:11:06,560 --> 00:11:08,880
to the host uh processor in this case

308
00:11:08,880 --> 00:11:10,880
and they get the communication or data

309
00:11:10,880 --> 00:11:14,200
from the host

310
00:11:17,920 --> 00:11:19,519
ah the next important part we want to

311
00:11:19,519 --> 00:11:21,680
see is the peripherals uh these are very

312
00:11:21,680 --> 00:11:23,600
important part in a microcontroller

313
00:11:23,600 --> 00:11:25,120
and this is where most of the

314
00:11:25,120 --> 00:11:26,640
communication happens with the external

315
00:11:26,640 --> 00:11:27,600
world

316
00:11:27,600 --> 00:11:29,839
so most commonly used peripherals to

317
00:11:29,839 --> 00:11:30,720
talk

318
00:11:30,720 --> 00:11:32,399
it's almost in all the microcontrollers

319
00:11:32,399 --> 00:11:35,279
it's like gpio uh you have the serial

320
00:11:35,279 --> 00:11:37,519
preferred interface the spi the i square

321
00:11:37,519 --> 00:11:39,040
see the inter processor communication

322
00:11:39,040 --> 00:11:41,279
then you you have the uart channel and

323
00:11:41,279 --> 00:11:44,399
finally the usb usb is very much used in

324
00:11:44,399 --> 00:11:46,640
the in the automotive automotive sectors

325
00:11:46,640 --> 00:11:48,160
basically they have two ecu's and they

326
00:11:48,160 --> 00:11:50,480
want to talk uh internally so they

327
00:11:50,480 --> 00:11:52,560
usually use a usb interface but not

328
00:11:52,560 --> 00:11:54,240
limited to usb there are other

329
00:11:54,240 --> 00:11:56,959
interfaces but these pi i square c and

330
00:11:56,959 --> 00:11:59,200
and and the gpios are very much embedded

331
00:11:59,200 --> 00:12:01,279
in the pcb so they are not very much

332
00:12:01,279 --> 00:12:03,519
accessible to the external world uh

333
00:12:03,519 --> 00:12:06,320
whereas uart and usb can be accessed

334
00:12:06,320 --> 00:12:10,760
from from from the outside the product

335
00:12:11,839 --> 00:12:13,519
and the next thing is that the

336
00:12:13,519 --> 00:12:15,360
microcontroller vendor provides the

337
00:12:15,360 --> 00:12:17,440
low-level drivers and the sdk support

338
00:12:17,440 --> 00:12:19,680
and this is something uh we

339
00:12:19,680 --> 00:12:21,920
we saw in most of the microcontrollers

340
00:12:21,920 --> 00:12:23,920
where the vendor provides the uh of all

341
00:12:23,920 --> 00:12:25,600
the sdk support they provide all the

342
00:12:25,600 --> 00:12:27,360
examples you want to work all the

343
00:12:27,360 --> 00:12:29,440
low-level drivers all you need to do is

344
00:12:29,440 --> 00:12:31,040
that you need to develop your

345
00:12:31,040 --> 00:12:33,440
application just use the apis from the

346
00:12:33,440 --> 00:12:35,839
low-level drivers so it's very much kind

347
00:12:35,839 --> 00:12:38,240
of standardized from the vendor but but

348
00:12:38,240 --> 00:12:39,920
the only problem is that

349
00:12:39,920 --> 00:12:41,279
it's not standardized between the

350
00:12:41,279 --> 00:12:43,519
different vendors unless you use this

351
00:12:43,519 --> 00:12:45,600
use something like a cortex

352
00:12:45,600 --> 00:12:46,959
kinses

353
00:12:46,959 --> 00:12:49,439
drivers

354
00:12:50,560 --> 00:12:51,760
and if you want to develop an

355
00:12:51,760 --> 00:12:53,279
application you need to use the api

356
00:12:53,279 --> 00:12:55,279
provided by the low level drivers but if

357
00:12:55,279 --> 00:12:56,560
you want to develop your own low level

358
00:12:56,560 --> 00:12:58,480
drivers it's going to take time

359
00:12:58,480 --> 00:13:00,399
but the the vendor usually provides you

360
00:13:00,399 --> 00:13:02,720
the documentation or or the user manual

361
00:13:02,720 --> 00:13:03,760
where

362
00:13:03,760 --> 00:13:06,399
all the registers are documented and you

363
00:13:06,399 --> 00:13:08,160
can develop your own low level drivers

364
00:13:08,160 --> 00:13:11,120
but it's going to take time

365
00:13:11,200 --> 00:13:12,959
and many security functions are

366
00:13:12,959 --> 00:13:15,200
controlled by the vendor

367
00:13:15,200 --> 00:13:17,040
and finally the low level drivers and

368
00:13:17,040 --> 00:13:18,560
the boot rom code is tested by the

369
00:13:18,560 --> 00:13:19,680
vendor

370
00:13:19,680 --> 00:13:21,360
the low-level drivers is actually the

371
00:13:21,360 --> 00:13:23,760
source which can be shared with the uh

372
00:13:23,760 --> 00:13:25,519
the users for developing the application

373
00:13:25,519 --> 00:13:28,160
but the boot rom itself is not shared so

374
00:13:28,160 --> 00:13:29,760
basically it's a it's a either you can

375
00:13:29,760 --> 00:13:32,000
dump it as a binary blob but

376
00:13:32,000 --> 00:13:33,680
there's a restricted access to the boot

377
00:13:33,680 --> 00:13:36,959
rom source itself

378
00:13:38,160 --> 00:13:40,320
finally uh the low-level drivers would

379
00:13:40,320 --> 00:13:41,839
be a very good target for security

380
00:13:41,839 --> 00:13:44,160
researchers and and as i said bootrom is

381
00:13:44,160 --> 00:13:46,560
a very much a black box and you need

382
00:13:46,560 --> 00:13:48,560
time to dump it then you need to analyze

383
00:13:48,560 --> 00:13:50,480
and see the security functions how it

384
00:13:50,480 --> 00:13:52,639
works and finally it takes time to see

385
00:13:52,639 --> 00:13:56,320
the security bugs inside it

386
00:13:57,199 --> 00:13:59,440
and coming to the apis this is a very

387
00:13:59,440 --> 00:14:01,519
much standard they follow in almost all

388
00:14:01,519 --> 00:14:03,120
the microcontrollers where they

389
00:14:03,120 --> 00:14:04,959
basically if you want to uh

390
00:14:04,959 --> 00:14:06,880
you want to use any of the apis for the

391
00:14:06,880 --> 00:14:09,199
peripherals basically the the apis

392
00:14:09,199 --> 00:14:10,800
usually initialize the controllers they

393
00:14:10,800 --> 00:14:12,880
set up the configuration registers and

394
00:14:12,880 --> 00:14:14,480
they enable and disable the clock if you

395
00:14:14,480 --> 00:14:16,079
have different buses then you need to

396
00:14:16,079 --> 00:14:18,639
enable the clock for those buses and the

397
00:14:18,639 --> 00:14:20,000
then the peripherals are very much

398
00:14:20,000 --> 00:14:21,839
grouped uh between different speed of

399
00:14:21,839 --> 00:14:23,920
buses

400
00:14:23,920 --> 00:14:25,360
and finally if you want to set up you

401
00:14:25,360 --> 00:14:27,440
want to set up the tx and r structures

402
00:14:27,440 --> 00:14:29,199
and these are all inside the low level

403
00:14:29,199 --> 00:14:32,399
drivers which i'm i'm talking about

404
00:14:32,399 --> 00:14:34,079
and finally you have the interrupt

405
00:14:34,079 --> 00:14:36,079
handlers and interrupt handling and the

406
00:14:36,079 --> 00:14:37,120
handlers

407
00:14:37,120 --> 00:14:38,959
whenever event occurs or interrupt

408
00:14:38,959 --> 00:14:40,720
happens then you need to go to these

409
00:14:40,720 --> 00:14:42,480
handlers and do the

410
00:14:42,480 --> 00:14:45,120
function

411
00:14:45,120 --> 00:14:46,560
and they have the variables that have

412
00:14:46,560 --> 00:14:48,000
specific functions

413
00:14:48,000 --> 00:14:48,880
which

414
00:14:48,880 --> 00:14:51,279
which kind of differentiate between

415
00:14:51,279 --> 00:14:52,320
different

416
00:14:52,320 --> 00:14:54,240
protocols

417
00:14:54,240 --> 00:14:57,040
and finally the api to use application

418
00:14:57,040 --> 00:14:59,839
the user can use this api

419
00:14:59,839 --> 00:15:00,959
in order to

420
00:15:00,959 --> 00:15:03,199
want to get something done from the

421
00:15:03,199 --> 00:15:05,839
ferribals

422
00:15:07,519 --> 00:15:09,360
so if the vendor provides this low level

423
00:15:09,360 --> 00:15:10,720
driver

424
00:15:10,720 --> 00:15:12,959
there's a high possibility uh that it

425
00:15:12,959 --> 00:15:15,199
can be re be reused in the b rom the or

426
00:15:15,199 --> 00:15:17,920
the boot rom so uh we we have seen many

427
00:15:17,920 --> 00:15:20,399
cases where uh we can't access the boot

428
00:15:20,399 --> 00:15:22,320
rom or the boot rom if you dump it's

429
00:15:22,320 --> 00:15:24,320
like uh you need time to analyze it but

430
00:15:24,320 --> 00:15:26,959
if you see the low level drivers or and

431
00:15:26,959 --> 00:15:29,279
if the same uh functionality is in the

432
00:15:29,279 --> 00:15:31,360
boot rom you can see you can match with

433
00:15:31,360 --> 00:15:33,759
the low level drivers so that's one uh

434
00:15:33,759 --> 00:15:37,040
example and even uh in in the in the

435
00:15:37,040 --> 00:15:38,560
security issues which we found we saw

436
00:15:38,560 --> 00:15:40,720
the the low level drivers

437
00:15:40,720 --> 00:15:43,440
had a similar issue than the same as the

438
00:15:43,440 --> 00:15:45,839
boot rom

439
00:15:49,519 --> 00:15:51,839
so why this let's focus on the

440
00:15:51,839 --> 00:15:53,680
microcontroller fuzzing we see that

441
00:15:53,680 --> 00:15:55,839
fuzzing happens but most of the fuzzing

442
00:15:55,839 --> 00:15:58,240
is focused on the uh the higher linux

443
00:15:58,240 --> 00:16:00,560
side or the soc side uh where you have

444
00:16:00,560 --> 00:16:03,120
very good uh support for drivers there's

445
00:16:03,120 --> 00:16:05,360
there's a standard os for it so there

446
00:16:05,360 --> 00:16:06,959
are lots of research communities focused

447
00:16:06,959 --> 00:16:09,199
on the on the on the uh on the higher

448
00:16:09,199 --> 00:16:11,279
end processors

449
00:16:11,279 --> 00:16:13,600
uh one reason is that uh as i said

450
00:16:13,600 --> 00:16:15,360
different pro vendor uh the

451
00:16:15,360 --> 00:16:16,399
semiconductor vendor or the

452
00:16:16,399 --> 00:16:18,480
microcontroller vendor provides

453
00:16:18,480 --> 00:16:20,720
different device drivers and they are

454
00:16:20,720 --> 00:16:23,600
very much vendor-specific code

455
00:16:23,600 --> 00:16:25,120
and there's a less instrumentation to

456
00:16:25,120 --> 00:16:26,560
monitor the micro controllers during

457
00:16:26,560 --> 00:16:28,720
fuzzing uh in case of a linux system or

458
00:16:28,720 --> 00:16:30,320
an associate just running a linux you

459
00:16:30,320 --> 00:16:32,399
can you have the stack trays you have

460
00:16:32,399 --> 00:16:34,399
the debug logs and

461
00:16:34,399 --> 00:16:36,079
when compared to microcontroller you you

462
00:16:36,079 --> 00:16:38,720
don't get much information out of it

463
00:16:38,720 --> 00:16:40,320
and and that's one of the reason it's

464
00:16:40,320 --> 00:16:41,920
very complex uh to fast these kind of

465
00:16:41,920 --> 00:16:44,639
microcontrollers

466
00:16:44,639 --> 00:16:46,720
and as i said most of the fuzzing

467
00:16:46,720 --> 00:16:48,480
communities focused on uh the higher

468
00:16:48,480 --> 00:16:50,639
higher processing devices because they

469
00:16:50,639 --> 00:16:52,079
have operating system support and debug

470
00:16:52,079 --> 00:16:54,160
traces

471
00:16:54,160 --> 00:16:55,680
other side the micro controller runs on

472
00:16:55,680 --> 00:16:57,440
less frequency uh basically 400

473
00:16:57,440 --> 00:16:59,120
megahertz and less or is there a few

474
00:16:59,120 --> 00:17:01,279
microcontrollers which run at

475
00:17:01,279 --> 00:17:03,759
500 or 600 megahertz

476
00:17:03,759 --> 00:17:05,919
and as i said there's a very less code

477
00:17:05,919 --> 00:17:07,919
memory uh basically the microcontroller

478
00:17:07,919 --> 00:17:10,000
flash itself is like few kilobytes it

479
00:17:10,000 --> 00:17:14,480
can be ranging from 250 256 kb to a 1 mb

480
00:17:14,480 --> 00:17:15,439
but

481
00:17:15,439 --> 00:17:16,880
in other side if you see a higher end

482
00:17:16,880 --> 00:17:21,360
processor it it goes in gigabytes

483
00:17:25,439 --> 00:17:26,959
moreover uh if you see the

484
00:17:26,959 --> 00:17:28,880
microcontrollers are like and the

485
00:17:28,880 --> 00:17:30,400
interfaces which you are using the

486
00:17:30,400 --> 00:17:32,400
microcontrollers are very much

487
00:17:32,400 --> 00:17:34,320
not visible in the pcb they are they go

488
00:17:34,320 --> 00:17:36,559
deep under the layers so most of the

489
00:17:36,559 --> 00:17:38,320
time the researchers just they don't

490
00:17:38,320 --> 00:17:39,840
want to uh

491
00:17:39,840 --> 00:17:41,919
get inside the layers of the pcb so

492
00:17:41,919 --> 00:17:43,679
that's one reason that you don't see

493
00:17:43,679 --> 00:17:45,440
these interface lines

494
00:17:45,440 --> 00:17:47,360
in your products they are very much deep

495
00:17:47,360 --> 00:17:50,879
inside the pcb layers

496
00:17:52,400 --> 00:17:53,200
so

497
00:17:53,200 --> 00:17:54,880
so why do we need fuzzing for low level

498
00:17:54,880 --> 00:17:57,360
protocols so

499
00:17:57,360 --> 00:17:59,200
fuzzing is excellent excellent technique

500
00:17:59,200 --> 00:18:00,880
for locating vulnerabilities in low

501
00:18:00,880 --> 00:18:04,080
level hardware and software

502
00:18:04,400 --> 00:18:06,320
the basic premise is to deliver

503
00:18:06,320 --> 00:18:08,240
malformed inputs to the target device

504
00:18:08,240 --> 00:18:10,160
and detect failure that's that's uh

505
00:18:10,160 --> 00:18:12,080
almost all the fuzzers does that they

506
00:18:12,080 --> 00:18:14,080
just send a malformed input to the

507
00:18:14,080 --> 00:18:15,919
target and see how the target responds

508
00:18:15,919 --> 00:18:18,000
back

509
00:18:18,000 --> 00:18:20,080
and if you know the underlying protocol

510
00:18:20,080 --> 00:18:21,840
how the interface are working then all

511
00:18:21,840 --> 00:18:24,240
we need to do is iterate the bytes or

512
00:18:24,240 --> 00:18:25,600
add some intelligence to the request

513
00:18:25,600 --> 00:18:29,240
which we send to the target

514
00:18:30,880 --> 00:18:34,240
and the difficult part is to have a

515
00:18:34,240 --> 00:18:36,559
framework or to monitor the target

516
00:18:36,559 --> 00:18:38,240
this is something as i said earlier

517
00:18:38,240 --> 00:18:39,760
there's not much support in the

518
00:18:39,760 --> 00:18:41,200
microcontroller side

519
00:18:41,200 --> 00:18:43,760
where we can try to see how the target

520
00:18:43,760 --> 00:18:45,760
behaves when you try to fuzz that

521
00:18:45,760 --> 00:18:48,000
microcontroller so this is something uh

522
00:18:48,000 --> 00:18:50,480
something lots of work has to be done uh

523
00:18:50,480 --> 00:18:51,280
and

524
00:18:51,280 --> 00:18:53,120
this is something where our fuzzer also

525
00:18:53,120 --> 00:18:55,039
covers

526
00:18:55,039 --> 00:18:57,200
so basically uh in case of a frozen

527
00:18:57,200 --> 00:18:59,200
framework uh all you need to send is a

528
00:18:59,200 --> 00:19:01,039
malform input to the target then you're

529
00:19:01,039 --> 00:19:03,039
going to pass the responses back and you

530
00:19:03,039 --> 00:19:04,799
got you meanwhile you want to see how

531
00:19:04,799 --> 00:19:06,480
the target behave is there any

532
00:19:06,480 --> 00:19:08,559
abnormality uh when when you send these

533
00:19:08,559 --> 00:19:11,520
kind of inputs

534
00:19:11,520 --> 00:19:13,919
so how how we are going to

535
00:19:13,919 --> 00:19:15,520
see the target or how we are going to

536
00:19:15,520 --> 00:19:17,679
instrument instrument the target

537
00:19:17,679 --> 00:19:19,600
so basically

538
00:19:19,600 --> 00:19:21,919
we check the device behavior whether the

539
00:19:21,919 --> 00:19:24,000
microcontroller itself resets after you

540
00:19:24,000 --> 00:19:26,799
send a malform request so how do you

541
00:19:26,799 --> 00:19:28,640
find whether the microcontroller resets

542
00:19:28,640 --> 00:19:30,960
basically the gpa there are gpio pins or

543
00:19:30,960 --> 00:19:33,440
the reset pin from the microcontroller

544
00:19:33,440 --> 00:19:35,440
you can tap into this reset pin and see

545
00:19:35,440 --> 00:19:37,919
whenever you send a fast packet uh

546
00:19:37,919 --> 00:19:41,760
whether the device itself resets

547
00:19:42,000 --> 00:19:43,760
and the other way to see whether the

548
00:19:43,760 --> 00:19:45,600
device itself resets you can from the

549
00:19:45,600 --> 00:19:47,679
linux side you have the your kernel

550
00:19:47,679 --> 00:19:49,679
messages or your system logs where for

551
00:19:49,679 --> 00:19:51,679
example a usb disconnect you can see

552
00:19:51,679 --> 00:19:53,200
that uh

553
00:19:53,200 --> 00:19:54,799
there's a disconnect message in the logs

554
00:19:54,799 --> 00:19:57,120
uh if if you have an i square c device

555
00:19:57,120 --> 00:19:59,039
or an spi device uh the logs clearly

556
00:19:59,039 --> 00:20:02,880
shows that the device got disconnected

557
00:20:02,880 --> 00:20:04,640
and finally uh this is a very important

558
00:20:04,640 --> 00:20:06,720
one which we want to focus uh is the

559
00:20:06,720 --> 00:20:09,039
ovary responses so whenever you send a

560
00:20:09,039 --> 00:20:11,679
request uh to a target and you know that

561
00:20:11,679 --> 00:20:13,600
there's a con there's a fixed response

562
00:20:13,600 --> 00:20:15,280
going to come from it so we want to

563
00:20:15,280 --> 00:20:17,840
check how the response uh length is so

564
00:20:17,840 --> 00:20:20,400
if you send a if you request for let's

565
00:20:20,400 --> 00:20:22,559
say four kilobytes but the target

566
00:20:22,559 --> 00:20:24,960
response like 50 or 60 kilobytes then we

567
00:20:24,960 --> 00:20:26,559
know that this there's an issue with the

568
00:20:26,559 --> 00:20:28,480
target so we're going to check each

569
00:20:28,480 --> 00:20:31,919
responses and whether it exceeds uh the

570
00:20:31,919 --> 00:20:35,840
limit which has to be sent

571
00:20:37,200 --> 00:20:39,679
and finally uh this is a kind of a

572
00:20:39,679 --> 00:20:41,679
standardized where standardized

573
00:20:41,679 --> 00:20:43,200
instrumentation technique where you try

574
00:20:43,200 --> 00:20:45,520
to send a ping packet after every normal

575
00:20:45,520 --> 00:20:47,520
request so you're going to send a normal

576
00:20:47,520 --> 00:20:48,720
or you're going to send a malform

577
00:20:48,720 --> 00:20:50,640
request then after that you want to send

578
00:20:50,640 --> 00:20:52,080
a normal request and you know that the

579
00:20:52,080 --> 00:20:54,240
normal request has to come back properly

580
00:20:54,240 --> 00:20:55,760
if if the normal

581
00:20:55,760 --> 00:20:57,600
request doesn't comes back then you know

582
00:20:57,600 --> 00:20:59,200
that okay there's something wrong with

583
00:20:59,200 --> 00:21:00,480
the target

584
00:21:00,480 --> 00:21:02,960
so basically we use a ping pong target

585
00:21:02,960 --> 00:21:05,520
or where we just ping and respawn back

586
00:21:05,520 --> 00:21:08,320
and finally uh uh in in the right side

587
00:21:08,320 --> 00:21:10,880
you have the embedded host and and you

588
00:21:10,880 --> 00:21:12,480
have the target and the embedded host

589
00:21:12,480 --> 00:21:14,720
can be a linux system

590
00:21:14,720 --> 00:21:17,120
which has uh almost support for all of

591
00:21:17,120 --> 00:21:18,480
the drivers

592
00:21:18,480 --> 00:21:20,720
and here i'm talking about uh the uh

593
00:21:20,720 --> 00:21:22,400
controller interfaces so what i will

594
00:21:22,400 --> 00:21:25,200
talk about spi i square c ui usb these

595
00:21:25,200 --> 00:21:27,360
are all the device controllers uh

596
00:21:27,360 --> 00:21:29,600
in the target mcu so basically the linux

597
00:21:29,600 --> 00:21:31,280
system is the host

598
00:21:31,280 --> 00:21:34,080
and all your interfaces can be the

599
00:21:34,080 --> 00:21:35,600
device side

600
00:21:35,600 --> 00:21:37,039
and there are like fuzzers already

601
00:21:37,039 --> 00:21:38,880
available for the host site

602
00:21:38,880 --> 00:21:40,159
implementation

603
00:21:40,159 --> 00:21:43,039
for example cisco can fuss the usb host

604
00:21:43,039 --> 00:21:44,960
side also there's there are lots of

605
00:21:44,960 --> 00:21:47,039
fuzzers to check uh the whole side

606
00:21:47,039 --> 00:21:51,600
implementation in the linux side

607
00:21:52,559 --> 00:21:56,440
just a moment and take a water

608
00:22:10,640 --> 00:22:12,880
so we we know that okay we can fast the

609
00:22:12,880 --> 00:22:14,960
target but we need to see how far it

610
00:22:14,960 --> 00:22:17,679
reaches so you see here we are the

611
00:22:17,679 --> 00:22:20,159
fuzzer and the target this is the target

612
00:22:20,159 --> 00:22:22,320
device so as i said the microcontroller

613
00:22:22,320 --> 00:22:24,559
has different layers so you have the

614
00:22:24,559 --> 00:22:26,480
physical layer where all your files are

615
00:22:26,480 --> 00:22:28,640
there for example in case of usb or

616
00:22:28,640 --> 00:22:31,039
ethernet you have the physical layer for

617
00:22:31,039 --> 00:22:33,840
it or the five chips five ics then you

618
00:22:33,840 --> 00:22:35,919
have the controllers present inside the

619
00:22:35,919 --> 00:22:38,640
microcontroller it can basically be an

620
00:22:38,640 --> 00:22:40,799
spi or ice quesadilla or usb or your

621
00:22:40,799 --> 00:22:42,320
controllers these controllers are

622
00:22:42,320 --> 00:22:45,120
basically ip cores provided by your

623
00:22:45,120 --> 00:22:48,080
microcontroller vendor and it can

624
00:22:48,080 --> 00:22:50,880
differ from different microcontrollers

625
00:22:50,880 --> 00:22:52,480
and finally you have the low level

626
00:22:52,480 --> 00:22:56,000
drivers for each of the interface

627
00:22:56,000 --> 00:22:58,880
and that's how the user application can

628
00:22:58,880 --> 00:23:00,640
indeed want to talk with the uart or

629
00:23:00,640 --> 00:23:02,400
want to talk with the usb then basically

630
00:23:02,400 --> 00:23:05,280
the us application has to use the apis

631
00:23:05,280 --> 00:23:06,960
from the low level drivers and that's

632
00:23:06,960 --> 00:23:09,039
how you send a request to the outside

633
00:23:09,039 --> 00:23:10,320
world

634
00:23:10,320 --> 00:23:13,360
in this case if you see that

635
00:23:13,360 --> 00:23:16,080
the usb controller is very much

636
00:23:16,080 --> 00:23:18,559
complex and the usb low level drivers

637
00:23:18,559 --> 00:23:20,720
are very much complex and they also have

638
00:23:20,720 --> 00:23:23,039
a standardized standard where

639
00:23:23,039 --> 00:23:24,480
every vendor who wants to develop a

640
00:23:24,480 --> 00:23:25,919
low-level driver they need to follow the

641
00:23:25,919 --> 00:23:29,280
standard otherwise in spi square c or ur

642
00:23:29,280 --> 00:23:31,120
there's not much standard into it it's

643
00:23:31,120 --> 00:23:32,880
all uh the vendor-specific

644
00:23:32,880 --> 00:23:35,600
implementation

645
00:23:35,600 --> 00:23:37,679
one more thing we want to focus is that

646
00:23:37,679 --> 00:23:39,360
uh so we know that

647
00:23:39,360 --> 00:23:40,880
our first thing we can first any of

648
00:23:40,880 --> 00:23:42,000
these layers

649
00:23:42,000 --> 00:23:44,400
and fuzzing the silicon it will be very

650
00:23:44,400 --> 00:23:45,679
difficult i i think there are lots of

651
00:23:45,679 --> 00:23:46,880
research is happening to fuzz the

652
00:23:46,880 --> 00:23:48,320
silicon layer

653
00:23:48,320 --> 00:23:50,240
and if you want to fuss the low-level

654
00:23:50,240 --> 00:23:52,799
drivers yes uh there's this

655
00:23:52,799 --> 00:23:54,720
lots of people do it into it and finally

656
00:23:54,720 --> 00:23:56,640
the user application this is very much

657
00:23:56,640 --> 00:23:57,520
uh

658
00:23:57,520 --> 00:24:00,880
different uh from render to vendor

659
00:24:00,880 --> 00:24:02,960
and if you want to fast the boot rom

660
00:24:02,960 --> 00:24:07,440
again that's more into the higher layers

661
00:24:07,440 --> 00:24:10,240
so where is our focus uh currently we

662
00:24:10,240 --> 00:24:12,880
know that we try to fuss all these

663
00:24:12,880 --> 00:24:14,320
low-level drivers

664
00:24:14,320 --> 00:24:16,559
and we we know that like we found some

665
00:24:16,559 --> 00:24:19,039
vulnerabilities in the usb controller as

666
00:24:19,039 --> 00:24:21,679
i said it's it's a complex stack and

667
00:24:21,679 --> 00:24:25,360
it has to be follows the standards

668
00:24:25,360 --> 00:24:27,279
uh similarly we are trying to focus on

669
00:24:27,279 --> 00:24:28,000
the

670
00:24:28,000 --> 00:24:30,480
lower low level drivers for spi i square

671
00:24:30,480 --> 00:24:32,640
c and uart controllers and these are

672
00:24:32,640 --> 00:24:35,200
like something uh uh very much different

673
00:24:35,200 --> 00:24:37,440
between different uh microcontrollers

674
00:24:37,440 --> 00:24:39,600
this is something very much uh

675
00:24:39,600 --> 00:24:42,080
we feel the complexity because one

676
00:24:42,080 --> 00:24:43,919
low-level driver from one vendor will

677
00:24:43,919 --> 00:24:45,679
not work with the other vendor so it is

678
00:24:45,679 --> 00:24:48,400
all dependent on the implementation

679
00:24:48,400 --> 00:24:49,919
and finally

680
00:24:49,919 --> 00:24:52,480
the other fuzzer basically we try to

681
00:24:52,480 --> 00:24:54,159
send the request and responses to the

682
00:24:54,159 --> 00:24:56,400
microcontroller and finally we want to

683
00:24:56,400 --> 00:24:58,240
monitor how the device works so

684
00:24:58,240 --> 00:25:00,240
basically the request and response you

685
00:25:00,240 --> 00:25:01,039
can

686
00:25:01,039 --> 00:25:03,679
you can target each different layers and

687
00:25:03,679 --> 00:25:05,039
finally you can

688
00:25:05,039 --> 00:25:08,080
get the response back

689
00:25:08,400 --> 00:25:10,960
we have vulnerabilities observed in the

690
00:25:10,960 --> 00:25:13,360
usb driver that's over here

691
00:25:13,360 --> 00:25:16,400
then there are not much uh found uh

692
00:25:16,400 --> 00:25:18,480
so we we know that uh since it there's

693
00:25:18,480 --> 00:25:20,880
no issues uh it doesn't mean that uh

694
00:25:20,880 --> 00:25:22,640
it's not vulnerable but all we need to

695
00:25:22,640 --> 00:25:24,960
do is to improve the fuzzer here

696
00:25:24,960 --> 00:25:27,039
and this is something the path which we

697
00:25:27,039 --> 00:25:28,559
have not reached but we are planning to

698
00:25:28,559 --> 00:25:31,678
reach those paths

699
00:25:36,559 --> 00:25:38,480
okay coming to the second part of the

700
00:25:38,480 --> 00:25:39,760
talk these are the

701
00:25:39,760 --> 00:25:41,760
vulnerabilities which we found in modern

702
00:25:41,760 --> 00:25:44,559
microcontrollers

703
00:25:46,080 --> 00:25:48,640
basically the targets which we first is

704
00:25:48,640 --> 00:25:51,520
the lpc5569

705
00:25:51,520 --> 00:25:56,880
and and k82f or k821 from nxp

706
00:25:56,880 --> 00:25:59,679
so the first target is basically a

707
00:25:59,679 --> 00:26:01,120
dual core arm

708
00:26:01,120 --> 00:26:04,240
which has a cortex m33 mcu which runs at

709
00:26:04,240 --> 00:26:07,120
150 megahertz and you can see the flash

710
00:26:07,120 --> 00:26:09,360
memory is like very much

711
00:26:09,360 --> 00:26:11,600
it's in size of kilobytes you have 320

712
00:26:11,600 --> 00:26:13,840
kilobytes and six for 640 kb of flash

713
00:26:13,840 --> 00:26:15,120
memory

714
00:26:15,120 --> 00:26:18,240
similarly uh we also fast the kinect is

715
00:26:18,240 --> 00:26:20,960
k2 chip ic

716
00:26:20,960 --> 00:26:23,200
which has similar runs at 150 megahertz

717
00:26:23,200 --> 00:26:26,159
and it has 256kb of flash and similarly

718
00:26:26,159 --> 00:26:29,360
uh 256kb of ram

719
00:26:29,360 --> 00:26:31,520
as i said earlier when you compare to

720
00:26:31,520 --> 00:26:34,400
the highlander socs or

721
00:26:34,400 --> 00:26:36,400
high-end processors you know that the

722
00:26:36,400 --> 00:26:37,679
sram

723
00:26:37,679 --> 00:26:41,520
and the flash is in few kilobytes

724
00:26:44,640 --> 00:26:47,279
this is the target which we used for the

725
00:26:47,279 --> 00:26:49,679
lpc so we we brought the lpc a

726
00:26:49,679 --> 00:26:51,120
development board

727
00:26:51,120 --> 00:26:53,600
and this is division a2

728
00:26:53,600 --> 00:26:55,840
so this is a vulnerable version which we

729
00:26:55,840 --> 00:26:57,679
found and uh

730
00:26:57,679 --> 00:27:00,880
which was like uh available from 2017 or

731
00:27:00,880 --> 00:27:03,679
18 but the freedom board it's like uh

732
00:27:03,679 --> 00:27:05,440
very old it's like

733
00:27:05,440 --> 00:27:08,559
2015 and that's not much update from the

734
00:27:08,559 --> 00:27:10,960
vendor

735
00:27:14,240 --> 00:27:16,320
so one more thing i want to show here is

736
00:27:16,320 --> 00:27:18,880
basically you can see

737
00:27:18,880 --> 00:27:21,200
in a real target or real device you know

738
00:27:21,200 --> 00:27:24,640
that you can't access the uh peripherals

739
00:27:24,640 --> 00:27:25,840
so

740
00:27:25,840 --> 00:27:27,760
for example if you want to fuzz i square

741
00:27:27,760 --> 00:27:30,960
c or spi you know that in a real target

742
00:27:30,960 --> 00:27:33,760
this might be inside the pcb layers but

743
00:27:33,760 --> 00:27:36,320
since this is a development board uh

744
00:27:36,320 --> 00:27:38,480
most of the interfaces are present here

745
00:27:38,480 --> 00:27:40,960
so it's very easy for you to fuss but

746
00:27:40,960 --> 00:27:43,600
who can use the fuzzer uh it's like the

747
00:27:43,600 --> 00:27:45,760
developers while they're gonna create a

748
00:27:45,760 --> 00:27:47,360
product most of the time they use these

749
00:27:47,360 --> 00:27:49,279
development boards so we can use the

750
00:27:49,279 --> 00:27:52,159
development boards to in order to access

751
00:27:52,159 --> 00:27:53,679
the interfaces

752
00:27:53,679 --> 00:27:56,960
similarly in k82 you have the

753
00:27:56,960 --> 00:28:00,080
interfaces for accessing the peripherals

754
00:28:00,080 --> 00:28:03,919
and also you have this uh uh the uh

755
00:28:03,919 --> 00:28:05,760
bootloader switch basically so if you

756
00:28:05,760 --> 00:28:07,919
want the nxp chip to enter into the

757
00:28:07,919 --> 00:28:09,840
bootloader mode or into the bootrom mode

758
00:28:09,840 --> 00:28:11,440
basically you need to uh press the

759
00:28:11,440 --> 00:28:14,240
switch and you need to recycle the power

760
00:28:14,240 --> 00:28:15,919
then the the chip enters into the

761
00:28:15,919 --> 00:28:18,320
bootrom mode similarly for isp you can

762
00:28:18,320 --> 00:28:20,480
set the jumpers here then if you recycle

763
00:28:20,480 --> 00:28:22,640
the board reset the board it enters into

764
00:28:22,640 --> 00:28:26,120
the bootrom mode

765
00:28:30,080 --> 00:28:32,720
so this is the timeline which we uh had

766
00:28:32,720 --> 00:28:34,799
with the vendor

767
00:28:34,799 --> 00:28:36,480
so basically uh

768
00:28:36,480 --> 00:28:37,840
the vulnerabilities were reported to the

769
00:28:37,840 --> 00:28:42,480
nxp pizza team uh on lpc5569 and k82

770
00:28:42,480 --> 00:28:44,320
boot roms

771
00:28:44,320 --> 00:28:46,960
it was reported in november 2020

772
00:28:46,960 --> 00:28:49,679
then uh in within few days we got the

773
00:28:49,679 --> 00:28:52,960
response from the vendor and they asked

774
00:28:52,960 --> 00:28:55,760
for more information from the k82

775
00:28:55,760 --> 00:28:57,520
but lpc was like very much easy to

776
00:28:57,520 --> 00:28:59,200
reproduce

777
00:28:59,200 --> 00:29:02,080
then we had a 90 days disclosure

778
00:29:02,080 --> 00:29:05,600
which which ended in february 2021

779
00:29:05,600 --> 00:29:07,279
now the vendor comes back and he says

780
00:29:07,279 --> 00:29:08,640
and they said that

781
00:29:08,640 --> 00:29:10,159
it has a wider impact they found that

782
00:29:10,159 --> 00:29:12,159
the same boot rom has been used in

783
00:29:12,159 --> 00:29:14,960
different series of microcontrollers and

784
00:29:14,960 --> 00:29:16,799
they want they want to extend the

785
00:29:16,799 --> 00:29:19,360
embargo till september 2021 which we

786
00:29:19,360 --> 00:29:22,000
happily accepted

787
00:29:22,640 --> 00:29:25,120
and finally uh in june 2021 the vendor

788
00:29:25,120 --> 00:29:27,840
provides the mitigation uh and they

789
00:29:27,840 --> 00:29:29,760
notify the customers who are using the

790
00:29:29,760 --> 00:29:31,840
vulnerable product uh so the mitigation

791
00:29:31,840 --> 00:29:33,600
in this case uh it's like you need to

792
00:29:33,600 --> 00:29:35,760
disable the boot rom functions basically

793
00:29:35,760 --> 00:29:37,600
you want to disable the

794
00:29:37,600 --> 00:29:39,840
the usb interface or the usb uh

795
00:29:39,840 --> 00:29:41,679
peripheral which is connected to the

796
00:29:41,679 --> 00:29:43,840
boot rom so they asked the customers to

797
00:29:43,840 --> 00:29:45,919
disable the boot rom the usb uh

798
00:29:45,919 --> 00:29:47,200
interface

799
00:29:47,200 --> 00:29:47,919
and

800
00:29:47,919 --> 00:29:49,600
they also said uh

801
00:29:49,600 --> 00:29:52,159
if you if if you gonna stop the isp

802
00:29:52,159 --> 00:29:54,399
interface or you set some otp bits or

803
00:29:54,399 --> 00:29:57,200
registers then your usb is like disabled

804
00:29:57,200 --> 00:29:59,679
forever

805
00:30:00,799 --> 00:30:02,000
and

806
00:30:02,000 --> 00:30:04,080
the vendor comes back and they gave us

807
00:30:04,080 --> 00:30:07,039
the patched board which was retested by

808
00:30:07,039 --> 00:30:08,480
us in the labs again

809
00:30:08,480 --> 00:30:10,799
and they are finally assigned this cv in

810
00:30:10,799 --> 00:30:13,760
september 2021

811
00:30:14,080 --> 00:30:16,559
and and the vulnerable board revision is

812
00:30:16,559 --> 00:30:19,600
uh russian a2 and now they sent us the

813
00:30:19,600 --> 00:30:22,000
division a3 board which the bootrom

814
00:30:22,000 --> 00:30:25,039
vulnerabilities have been fixed

815
00:30:25,760 --> 00:30:26,799
finally

816
00:30:26,799 --> 00:30:28,480
we have the disclosure vulnerabilities

817
00:30:28,480 --> 00:30:30,960
in the cyber week that's today so we had

818
00:30:30,960 --> 00:30:34,080
a very good uh relationship with nxp

819
00:30:34,080 --> 00:30:36,000
where they happily accepted uh the

820
00:30:36,000 --> 00:30:38,159
vulnerabilities which we reported and uh

821
00:30:38,159 --> 00:30:40,480
they like gave us the quickly it was

822
00:30:40,480 --> 00:30:42,320
like a very short time frame it was like

823
00:30:42,320 --> 00:30:43,760
six to nine months they were like able

824
00:30:43,760 --> 00:30:47,039
to release a new division board

825
00:30:49,039 --> 00:30:50,640
so about the vulnerabilities uh before i

826
00:30:50,640 --> 00:30:51,919
want to go inside the vulnerability i

827
00:30:51,919 --> 00:30:55,120
want to uh get some basics here so

828
00:30:55,120 --> 00:30:57,200
basically the vulnerability was found

829
00:30:57,200 --> 00:30:59,279
during the enumeration process so

830
00:30:59,279 --> 00:31:02,559
whenever you have a usb host or linux

831
00:31:02,559 --> 00:31:04,960
system and you have your microcontroller

832
00:31:04,960 --> 00:31:07,039
connect to it so if you are using a usb

833
00:31:07,039 --> 00:31:08,960
interface it's basically enumerates the

834
00:31:08,960 --> 00:31:10,960
first time after recycle you want to

835
00:31:10,960 --> 00:31:12,559
talk with the target

836
00:31:12,559 --> 00:31:14,799
the usb host has to send a certain set

837
00:31:14,799 --> 00:31:17,279
of commands or set of messages and the

838
00:31:17,279 --> 00:31:19,360
target response pack according to it

839
00:31:19,360 --> 00:31:20,399
it's gonna

840
00:31:20,399 --> 00:31:23,200
load some drivers for it

841
00:31:23,200 --> 00:31:24,799
so basically uh you need to first

842
00:31:24,799 --> 00:31:26,640
connect the device to the host

843
00:31:26,640 --> 00:31:28,960
then the host sends the setup request

844
00:31:28,960 --> 00:31:32,240
and you identify and the target uh sends

845
00:31:32,240 --> 00:31:34,720
the speed and and the target sends the

846
00:31:34,720 --> 00:31:37,360
device descriptors and finally the host

847
00:31:37,360 --> 00:31:38,799
is going to reset the device and we're

848
00:31:38,799 --> 00:31:41,360
going to assign you a usb address

849
00:31:41,360 --> 00:31:43,120
and once the address is assigned then

850
00:31:43,120 --> 00:31:44,399
you're going to get the configuration

851
00:31:44,399 --> 00:31:47,039
registers about how much power it

852
00:31:47,039 --> 00:31:48,640
consumes and other configuration from

853
00:31:48,640 --> 00:31:50,000
the target

854
00:31:50,000 --> 00:31:51,600
then you want to set the other you're

855
00:31:51,600 --> 00:31:53,760
going to get the interfaces and finally

856
00:31:53,760 --> 00:31:56,159
the usb host is going to load the

857
00:31:56,159 --> 00:31:57,440
drivers

858
00:31:57,440 --> 00:31:59,919
and after this is where your actual

859
00:31:59,919 --> 00:32:02,399
function with the usb target is going to

860
00:32:02,399 --> 00:32:05,200
happen in case if you want to use uh as

861
00:32:05,200 --> 00:32:05,919
a

862
00:32:05,919 --> 00:32:07,279
you want to download image or upload

863
00:32:07,279 --> 00:32:09,919
image this is after when your

864
00:32:09,919 --> 00:32:13,799
class drivers have been loaded

865
00:32:18,480 --> 00:32:20,159
so this is something we target the

866
00:32:20,159 --> 00:32:22,320
fussing setup which we used so basically

867
00:32:22,320 --> 00:32:25,360
if you see uh the ice the usb you can

868
00:32:25,360 --> 00:32:27,519
use in any of your linux systems but if

869
00:32:27,519 --> 00:32:30,240
you want to use the spi or i square c

870
00:32:30,240 --> 00:32:32,960
then you need to have a host which can

871
00:32:32,960 --> 00:32:35,279
provide the interface to the sp and i

872
00:32:35,279 --> 00:32:36,799
square c in this case we used a

873
00:32:36,799 --> 00:32:38,080
raspberry pi

874
00:32:38,080 --> 00:32:41,600
which has support for device controllers

875
00:32:41,600 --> 00:32:44,159
so basically you connect the gpios to

876
00:32:44,159 --> 00:32:47,440
the spi and uh again sqci or usb with

877
00:32:47,440 --> 00:32:49,760
the with the raspberry pi or your linux

878
00:32:49,760 --> 00:32:52,000
host in this case the target is the lpc

879
00:32:52,000 --> 00:32:54,080
device this is the evk board

880
00:32:54,080 --> 00:32:56,559
revision a2 which we brought

881
00:32:56,559 --> 00:32:58,240
and basically we

882
00:32:58,240 --> 00:33:00,159
uh wired all the connection this is all

883
00:33:00,159 --> 00:33:02,320
almost available in the user manual or

884
00:33:02,320 --> 00:33:04,240
the data sheet

885
00:33:04,240 --> 00:33:05,919
in this case uh the

886
00:33:05,919 --> 00:33:07,679
in this case the fuzzing framework was

887
00:33:07,679 --> 00:33:11,640
running from the raspberry pi

888
00:33:14,080 --> 00:33:15,760
so about the vulnerability so this is

889
00:33:15,760 --> 00:33:18,559
what happens when you connect the target

890
00:33:18,559 --> 00:33:20,240
so basically it enumerates you can see

891
00:33:20,240 --> 00:33:23,120
all the logs in your linux linux

892
00:33:23,120 --> 00:33:26,080
system logs you can see that the nxp

893
00:33:26,080 --> 00:33:28,480
semiconductor device has been enumerated

894
00:33:28,480 --> 00:33:30,240
and after that you can see the final

895
00:33:30,240 --> 00:33:31,919
class driver the usb hid that's the

896
00:33:31,919 --> 00:33:33,760
class driver which gets loaded this is

897
00:33:33,760 --> 00:33:35,679
where your function starts

898
00:33:35,679 --> 00:33:36,799
so

899
00:33:36,799 --> 00:33:39,440
the microcontroller usually provides the

900
00:33:39,440 --> 00:33:41,760
hid class interface so basically you

901
00:33:41,760 --> 00:33:44,960
have three end points uh the inter in an

902
00:33:44,960 --> 00:33:47,360
inter in one and out two usually

903
00:33:47,360 --> 00:33:50,080
provides your hid class or your user

904
00:33:50,080 --> 00:33:52,080
functions but the control endpoint is

905
00:33:52,080 --> 00:33:54,320
where your enumeration happens this is

906
00:33:54,320 --> 00:33:56,080
where the setup requests are sent from

907
00:33:56,080 --> 00:33:58,480
the hardware from the host and your

908
00:33:58,480 --> 00:34:01,120
device in in response back

909
00:34:01,120 --> 00:34:04,080
what the host has asked for

910
00:34:04,080 --> 00:34:07,600
yeah this is uh the the rom region uh

911
00:34:07,600 --> 00:34:09,918
which for the boot rom uh in the ram so

912
00:34:09,918 --> 00:34:10,800
basically

913
00:34:10,800 --> 00:34:13,520
the lpc has an internal ram which is

914
00:34:13,520 --> 00:34:16,800
used during the bootrom execution

915
00:34:16,800 --> 00:34:18,960
and similarly for the k81 you can see

916
00:34:18,960 --> 00:34:20,719
that when you connect to a usb host it

917
00:34:20,719 --> 00:34:23,119
gets enumerated then finally it uses a

918
00:34:23,119 --> 00:34:24,960
usb hid class

919
00:34:24,960 --> 00:34:26,960
for user functions

920
00:34:26,960 --> 00:34:28,960
and it's similar to the lpc it uses

921
00:34:28,960 --> 00:34:30,480
three endpoints the control endpoint is

922
00:34:30,480 --> 00:34:33,040
used for your setup request

923
00:34:33,040 --> 00:34:34,719
and finally the interrupt is for your

924
00:34:34,719 --> 00:34:38,480
user specific hid class interrupts

925
00:34:41,460 --> 00:34:42,800
[Music]

926
00:34:42,800 --> 00:34:43,839
so

927
00:34:43,839 --> 00:34:45,440
about data's about the vulnerability

928
00:34:45,440 --> 00:34:47,918
it's it's it's a classic buffer flow we

929
00:34:47,918 --> 00:34:50,639
found in the boot rom so basically uh

930
00:34:50,639 --> 00:34:52,879
the vulnerability allows an attacker

931
00:34:52,879 --> 00:34:55,918
to read 16 kb from the lpc and 64 kb of

932
00:34:55,918 --> 00:34:58,560
data from the k82 this was from a locked

933
00:34:58,560 --> 00:35:01,040
device it has been secured it has been

934
00:35:01,040 --> 00:35:02,480
all the debug interfaces has been

935
00:35:02,480 --> 00:35:04,720
enabled so you can't access the jtag or

936
00:35:04,720 --> 00:35:06,880
you can't uh even

937
00:35:06,880 --> 00:35:08,400
run your own code because secure boot

938
00:35:08,400 --> 00:35:09,680
was running

939
00:35:09,680 --> 00:35:12,160
but the boot rom was vulnerable so you

940
00:35:12,160 --> 00:35:15,119
can dump at least 16 kb of memory uh

941
00:35:15,119 --> 00:35:18,079
from the lpc and 64 kb from the kt2 uh

942
00:35:18,079 --> 00:35:20,880
the the the memory ranges or the size

943
00:35:20,880 --> 00:35:23,280
can be less but as i said earlier uh

944
00:35:23,280 --> 00:35:25,440
these microcontrollers are like uh like

945
00:35:25,440 --> 00:35:28,320
used only 256kb of flash and 16kb of the

946
00:35:28,320 --> 00:35:29,200
flash

947
00:35:29,200 --> 00:35:32,000
comes from the secure regions

948
00:35:32,000 --> 00:35:35,520
what we found is that the

949
00:35:35,520 --> 00:35:37,599
the the memory which we dumped

950
00:35:37,599 --> 00:35:40,160
actually had some parts of the firmware

951
00:35:40,160 --> 00:35:42,720
uh which is actually uh which is

952
00:35:42,720 --> 00:35:44,160
actually been secured by the

953
00:35:44,160 --> 00:35:46,879
microcontroller

954
00:35:49,280 --> 00:35:51,119
similarly uh

955
00:35:51,119 --> 00:35:52,240
in

956
00:35:52,240 --> 00:35:53,839
what kind of uh the vulnerability was

957
00:35:53,839 --> 00:35:55,760
exactly found in the get descriptor

958
00:35:55,760 --> 00:35:57,440
configuration

959
00:35:57,440 --> 00:35:58,800
where you can modify the double lens

960
00:35:58,800 --> 00:36:01,760
value uh basically when you send a usb

961
00:36:01,760 --> 00:36:03,520
request to the host

962
00:36:03,520 --> 00:36:05,599
from the host to the target so basically

963
00:36:05,599 --> 00:36:07,920
you set the w length value and this w

964
00:36:07,920 --> 00:36:10,560
lens value if the target is not properly

965
00:36:10,560 --> 00:36:13,359
verifying it then you can control it in

966
00:36:13,359 --> 00:36:15,599
this case uh when the host sends a w

967
00:36:15,599 --> 00:36:19,280
length value of 65000 bytes uh the the

968
00:36:19,280 --> 00:36:21,200
lpc or the k81

969
00:36:21,200 --> 00:36:23,440
is going to transfer that amount of data

970
00:36:23,440 --> 00:36:24,480
from it

971
00:36:24,480 --> 00:36:26,960
so here in this case of lpc the target

972
00:36:26,960 --> 00:36:30,079
reset it at 16kb but 16kb was more than

973
00:36:30,079 --> 00:36:31,839
enough for us to see different parts of

974
00:36:31,839 --> 00:36:34,640
the firmware

975
00:36:37,760 --> 00:36:39,920
this is something we dumped so basically

976
00:36:39,920 --> 00:36:41,040
you can see

977
00:36:41,040 --> 00:36:44,079
uh the root of trust keys uh whatever

978
00:36:44,079 --> 00:36:44,800
the

979
00:36:44,800 --> 00:36:46,880
uh the your certificates which have been

980
00:36:46,880 --> 00:36:48,720
loaded into the memory uh everything can

981
00:36:48,720 --> 00:36:51,280
be dumped from here so this is a snippet

982
00:36:51,280 --> 00:36:55,680
of the code which we dumped from the lpc

983
00:36:55,680 --> 00:36:57,280
and finally this is the y shock trace

984
00:36:57,280 --> 00:36:59,680
which we have you can see that the host

985
00:36:59,680 --> 00:37:02,079
in this case uh the linux system uh

986
00:37:02,079 --> 00:37:04,160
tried to send an issue try to send a get

987
00:37:04,160 --> 00:37:06,640
descriptor request configuration and you

988
00:37:06,640 --> 00:37:09,680
saw that we got 4 kb of data

989
00:37:09,680 --> 00:37:11,040
this was a limitation in the linux

990
00:37:11,040 --> 00:37:13,359
system because the usb driver doesn't

991
00:37:13,359 --> 00:37:15,280
allow us to issue anything more than

992
00:37:15,280 --> 00:37:18,160
that but in a modified raspberry pi we

993
00:37:18,160 --> 00:37:20,880
try to modify the driver and we're able

994
00:37:20,880 --> 00:37:24,400
to get 16 kb of data

995
00:37:27,839 --> 00:37:29,920
and this is the uh

996
00:37:29,920 --> 00:37:32,000
code which was responsible for the

997
00:37:32,000 --> 00:37:33,280
vulnerability

998
00:37:33,280 --> 00:37:35,119
so how do we got this one this was from

999
00:37:35,119 --> 00:37:37,200
the uh drivers from the low level

1000
00:37:37,200 --> 00:37:40,000
drivers which nxp shared with the users

1001
00:37:40,000 --> 00:37:41,680
uh in order if you want to use the usb

1002
00:37:41,680 --> 00:37:43,599
stack in any of your application so the

1003
00:37:43,599 --> 00:37:45,760
similar uh stack was being used in the

1004
00:37:45,760 --> 00:37:48,000
boot rom so that's how we know that uh

1005
00:37:48,000 --> 00:37:51,119
the uh the drivers also been affected

1006
00:37:51,119 --> 00:37:54,560
and nxp was able to patch the drivers uh

1007
00:37:54,560 --> 00:37:56,960
for the sdk and also they were able to

1008
00:37:56,960 --> 00:37:59,359
patch the uh

1009
00:37:59,359 --> 00:38:03,640
the boot rom in the newer version

1010
00:38:06,480 --> 00:38:10,160
so about these cve so basically uh

1011
00:38:10,160 --> 00:38:14,320
uh nxps was able to patch the silicon

1012
00:38:14,320 --> 00:38:15,440
for

1013
00:38:15,440 --> 00:38:18,720
rt series 500 and lpc and they were able

1014
00:38:18,720 --> 00:38:20,960
to patch the sdk but

1015
00:38:20,960 --> 00:38:23,599
other other ics like the k81 they don't

1016
00:38:23,599 --> 00:38:25,280
have a patch for it so it's still

1017
00:38:25,280 --> 00:38:28,079
vulnerable in the field

1018
00:38:29,040 --> 00:38:31,119
and these are the different series

1019
00:38:31,119 --> 00:38:34,160
impacted by this vulnerability uh uh we

1020
00:38:34,160 --> 00:38:37,520
tested lpc and the k series but nxp was

1021
00:38:37,520 --> 00:38:39,280
kind enough to say that they were able

1022
00:38:39,280 --> 00:38:40,960
to also reproduce the issue in all the

1023
00:38:40,960 --> 00:38:42,720
series of microcontrollers

1024
00:38:42,720 --> 00:38:44,800
and they were able to only send a fix

1025
00:38:44,800 --> 00:38:48,720
for the lpc and the k81

1026
00:38:52,480 --> 00:38:54,880
so coming to the conclusion

1027
00:38:54,880 --> 00:38:56,560
we know that the lots of bhutan number

1028
00:38:56,560 --> 00:38:58,320
is found

1029
00:38:58,320 --> 00:39:00,480
majorly if you see the physically it's

1030
00:39:00,480 --> 00:39:01,760
it's the bootrom vulnerability in the

1031
00:39:01,760 --> 00:39:04,320
tegra soc so this was like used in the

1032
00:39:04,320 --> 00:39:06,480
nintendo uh uh

1033
00:39:06,480 --> 00:39:08,960
console and they were like uh these

1034
00:39:08,960 --> 00:39:11,200
vulnerabilities were like able to uh

1035
00:39:11,200 --> 00:39:12,400
that the researcher who found the

1036
00:39:12,400 --> 00:39:13,359
vulnerability

1037
00:39:13,359 --> 00:39:15,440
even able to exploit the secure boat out

1038
00:39:15,440 --> 00:39:17,040
of it

1039
00:39:17,040 --> 00:39:19,280
and this was like in 2017 you had the

1040
00:39:19,280 --> 00:39:21,760
imx vulnerabilities on the have the high

1041
00:39:21,760 --> 00:39:23,520
assurance boot basically again they were

1042
00:39:23,520 --> 00:39:25,920
able to compromise the root of trust and

1043
00:39:25,920 --> 00:39:28,000
in the certificate parser so there was a

1044
00:39:28,000 --> 00:39:31,200
like a stack based overflow in in the

1045
00:39:31,200 --> 00:39:34,800
x509 parser again the usb recovery mode

1046
00:39:34,800 --> 00:39:37,200
had a stack overflow so the users were

1047
00:39:37,200 --> 00:39:40,560
able to again uh bypass the secure board

1048
00:39:40,560 --> 00:39:42,000
and similarly there are like lots of

1049
00:39:42,000 --> 00:39:44,160
research happen on the stm side the like

1050
00:39:44,160 --> 00:39:46,640
people the researchers are able to uh

1051
00:39:46,640 --> 00:39:49,040
break into the debug interface and again

1052
00:39:49,040 --> 00:39:51,760
this was like to downgrade uh the rdp

1053
00:39:51,760 --> 00:39:54,000
protection in sdn32

1054
00:39:54,000 --> 00:39:55,839
and and recently they were like many

1055
00:39:55,839 --> 00:39:57,920
fault attacks uh were used to bypass

1056
00:39:57,920 --> 00:39:59,280
critical protections in modern

1057
00:39:59,280 --> 00:40:01,440
microcontrollers so lots of quite a lot

1058
00:40:01,440 --> 00:40:04,160
of research was happening and uh and and

1059
00:40:04,160 --> 00:40:06,800
i can say that uh the bootrom bugs are

1060
00:40:06,800 --> 00:40:10,400
very serious and if you don't uh

1061
00:40:10,400 --> 00:40:12,480
have a look at it or you don't uh

1062
00:40:12,480 --> 00:40:14,640
properly vet it for security issues this

1063
00:40:14,640 --> 00:40:17,040
is gonna create uh like a lots of

1064
00:40:17,040 --> 00:40:18,400
problem for your hardware you need to

1065
00:40:18,400 --> 00:40:20,560
get back the hardware from the field so

1066
00:40:20,560 --> 00:40:23,599
it's always good to find uh the check

1067
00:40:23,599 --> 00:40:25,920
the vulnerabilities and and

1068
00:40:25,920 --> 00:40:28,160
the main thing is that uh what we see is

1069
00:40:28,160 --> 00:40:29,920
that even the code size was very less it

1070
00:40:29,920 --> 00:40:32,000
was like few kb of bootron

1071
00:40:32,000 --> 00:40:34,000
but fuzzing was something been missing

1072
00:40:34,000 --> 00:40:37,599
here so uh we thought we will use this

1073
00:40:37,599 --> 00:40:40,720
uh opportunity to kind of release a

1074
00:40:40,720 --> 00:40:43,520
fuzzer for us so that we can find these

1075
00:40:43,520 --> 00:40:48,119
kind of vulnerabilities in the federals

1076
00:40:53,119 --> 00:40:54,720
so finally uh

1077
00:40:54,720 --> 00:40:56,160
we will be releasing the fuzzing

1078
00:40:56,160 --> 00:40:58,560
framework so basically the

1079
00:40:58,560 --> 00:41:00,960
llp fuzzer will be available in the

1080
00:41:00,960 --> 00:41:03,760
github account so the llp fuzzer has

1081
00:41:03,760 --> 00:41:06,400
support for the usb device stack and

1082
00:41:06,400 --> 00:41:09,280
also we are we also have a support for

1083
00:41:09,280 --> 00:41:11,760
the sp and i square c stack uh but it's

1084
00:41:11,760 --> 00:41:14,400
only focusing on a certain uh vendor so

1085
00:41:14,400 --> 00:41:15,839
we want to kind of make a generic

1086
00:41:15,839 --> 00:41:17,200
version of it

1087
00:41:17,200 --> 00:41:20,079
then we want to uh keep that added being

1088
00:41:20,079 --> 00:41:22,319
added to the fuzzer

1089
00:41:22,319 --> 00:41:25,359
and finally uh we're also releasing the

1090
00:41:25,359 --> 00:41:27,200
proof of concept to test

1091
00:41:27,200 --> 00:41:28,800
whether your device is vulnerable for

1092
00:41:28,800 --> 00:41:32,599
this bootrom vulnerability

1093
00:41:34,079 --> 00:41:35,680
and finally uh we'll come to the

1094
00:41:35,680 --> 00:41:37,760
conclusion

1095
00:41:37,760 --> 00:41:40,079
uh we know that the fuzzer is a small

1096
00:41:40,079 --> 00:41:42,640
step uh they like to test these kind of

1097
00:41:42,640 --> 00:41:45,760
interfaces uh so uh we want to develop a

1098
00:41:45,760 --> 00:41:48,640
generic implementation of the fuzzer to

1099
00:41:48,640 --> 00:41:50,800
to almost test a different set of uh

1100
00:41:50,800 --> 00:41:53,200
microcontrollers

1101
00:41:53,200 --> 00:41:54,720
and finally we want to reach different

1102
00:41:54,720 --> 00:41:56,880
code paths we know that as i said

1103
00:41:56,880 --> 00:41:59,280
earlier the fuzzer can only test certain

1104
00:41:59,280 --> 00:42:00,800
parts of the low-level drivers but we

1105
00:42:00,800 --> 00:42:03,200
want to try to see whether we can

1106
00:42:03,200 --> 00:42:05,200
send the first or the malformed inputs

1107
00:42:05,200 --> 00:42:08,720
to different layers of the controller

1108
00:42:08,720 --> 00:42:10,960
and also we want to test new targets

1109
00:42:10,960 --> 00:42:12,880
this is something we plan uh to check

1110
00:42:12,880 --> 00:42:14,720
whether any tpm modules because the tpm

1111
00:42:14,720 --> 00:42:17,119
module itself uses sp and i square c in

1112
00:42:17,119 --> 00:42:18,480
order to talk to your host in your

1113
00:42:18,480 --> 00:42:21,599
laptop uh and also a newer version of

1114
00:42:21,599 --> 00:42:23,680
the mobile phones they

1115
00:42:23,680 --> 00:42:26,000
sorry newer version of the mobile phones

1116
00:42:26,000 --> 00:42:27,599
uh basically they use the strongbox

1117
00:42:27,599 --> 00:42:30,400
concept or the hal where they usually

1118
00:42:30,400 --> 00:42:32,880
use the secure elements in order to

1119
00:42:32,880 --> 00:42:34,720
offload most of the security tasks from

1120
00:42:34,720 --> 00:42:37,119
your application processor this is

1121
00:42:37,119 --> 00:42:39,119
something we also plan to try out

1122
00:42:39,119 --> 00:42:41,040
different targets and to see how the

1123
00:42:41,040 --> 00:42:43,359
target responds and finally we want to

1124
00:42:43,359 --> 00:42:48,000
test different mcus and boot loaders

1125
00:42:50,560 --> 00:42:52,640
i think we are like end of the

1126
00:42:52,640 --> 00:42:54,240
presentation

1127
00:42:54,240 --> 00:42:56,000
and if you have any questions i'll be

1128
00:42:56,000 --> 00:42:58,560
happy to answer it

1129
00:42:58,560 --> 00:43:00,319
thank you so though

1130
00:43:00,319 --> 00:43:02,160
uh any questions from the room i saw

1131
00:43:02,160 --> 00:43:05,359
there were no questions in the app uh

1132
00:43:05,359 --> 00:43:09,119
anyone here yep wait a moment

1133
00:43:09,119 --> 00:43:11,520
please speak up loud because he doesn't

1134
00:43:11,520 --> 00:43:15,520
have the speaker doesn't have a headset

1135
00:43:16,160 --> 00:43:18,960
hi john hi thanks for the talk uh have

1136
00:43:18,960 --> 00:43:21,920
you tried nxp's secure element line of

1137
00:43:21,920 --> 00:43:22,960
products

1138
00:43:22,960 --> 00:43:24,720
because this is just a microcontroller

1139
00:43:24,720 --> 00:43:27,200
as a a freescale business have you also

1140
00:43:27,200 --> 00:43:29,920
tried too fast the secure elements from

1141
00:43:29,920 --> 00:43:32,720
the nxp uh okay we never tried the

1142
00:43:32,720 --> 00:43:34,720
secure element part uh since this

1143
00:43:34,720 --> 00:43:36,000
microcontrollers are very much easily

1144
00:43:36,000 --> 00:43:37,359
available

1145
00:43:37,359 --> 00:43:38,960
but that's something we are planning to

1146
00:43:38,960 --> 00:43:41,040
test the secure element but uh secure

1147
00:43:41,040 --> 00:43:42,400
element is totally different concept for

1148
00:43:42,400 --> 00:43:45,359
us uh with uh with the jkop and all the

1149
00:43:45,359 --> 00:43:47,520
java os running inside it it we need

1150
00:43:47,520 --> 00:43:49,440
some more time to see these kind of

1151
00:43:49,440 --> 00:43:51,359
devices but yeah we didn't test any of

1152
00:43:51,359 --> 00:43:55,078
the secure elements now

1153
00:43:55,200 --> 00:43:56,319
okay

1154
00:43:56,319 --> 00:43:59,040
any more questions from the room

1155
00:43:59,040 --> 00:43:59,839
no

1156
00:43:59,839 --> 00:44:01,920
okay then i want to thank you sultan for

1157
00:44:01,920 --> 00:44:03,920
your talk it was really great to learn

1158
00:44:03,920 --> 00:44:04,800
that

1159
00:44:04,800 --> 00:44:06,720
these vulnerabilities are not only found

1160
00:44:06,720 --> 00:44:09,839
in software but also in hardware

1161
00:44:09,839 --> 00:44:12,120
thank you thank you

1162
00:44:12,120 --> 00:44:15,199
[Applause]

