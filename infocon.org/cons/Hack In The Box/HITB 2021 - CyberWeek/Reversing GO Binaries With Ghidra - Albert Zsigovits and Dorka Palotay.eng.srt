1
00:00:09,120 --> 00:00:10,719
thank you for being here and it's not a

2
00:00:10,719 --> 00:00:13,040
really nice opportunity to present here

3
00:00:13,040 --> 00:00:15,120
our research about reversing online

4
00:00:15,120 --> 00:00:16,960
binaries with gidra

5
00:00:16,960 --> 00:00:19,359
i did this research together with one of

6
00:00:19,359 --> 00:00:21,680
my colleagues albert but i unfortunately

7
00:00:21,680 --> 00:00:24,560
he couldn't uh be here today so i will

8
00:00:24,560 --> 00:00:27,599
present the topic uh to you now

9
00:00:27,599 --> 00:00:30,480
just before we start i keep quickly want

10
00:00:30,480 --> 00:00:33,680
to introduce myself i work as a senior

11
00:00:33,680 --> 00:00:36,239
threat researcher at cujo ai

12
00:00:36,239 --> 00:00:40,640
i've studied mathematics and then

13
00:00:40,640 --> 00:00:43,760
my master's i did in a quick advanced

14
00:00:43,760 --> 00:00:45,120
cryptography

15
00:00:45,120 --> 00:00:47,039
and i was working in

16
00:00:47,039 --> 00:00:49,440
security companies and also different

17
00:00:49,440 --> 00:00:51,440
financial institutions

18
00:00:51,440 --> 00:00:54,879
and my main focus is mother analysis and

19
00:00:54,879 --> 00:00:56,719
reverse engineering

20
00:00:56,719 --> 00:00:59,680
so a few words about why we did this all

21
00:00:59,680 --> 00:01:02,559
research how this whole thing started

22
00:01:02,559 --> 00:01:06,080
at cujo ai we our team is focusing on

23
00:01:06,080 --> 00:01:08,640
iot malware research

24
00:01:08,640 --> 00:01:12,400
analyzing botnets and different uh iot

25
00:01:12,400 --> 00:01:15,920
mother families and we realized that we

26
00:01:15,920 --> 00:01:18,479
see more and more samples written in

27
00:01:18,479 --> 00:01:21,040
goal not just iot mother but malware in

28
00:01:21,040 --> 00:01:22,159
general

29
00:01:22,159 --> 00:01:24,000
and

30
00:01:24,000 --> 00:01:26,400
the issue is that reversing the goal

31
00:01:26,400 --> 00:01:28,560
binaries is challenging

32
00:01:28,560 --> 00:01:31,119
first of all these binaries are usually

33
00:01:31,119 --> 00:01:33,759
much more larger than binary written in

34
00:01:33,759 --> 00:01:35,840
c for example we will see examples for

35
00:01:35,840 --> 00:01:37,119
that later on

36
00:01:37,119 --> 00:01:40,320
and they have an unusual string handling

37
00:01:40,320 --> 00:01:43,360
and other issues that we really have to

38
00:01:43,360 --> 00:01:44,479
consider

39
00:01:44,479 --> 00:01:48,000
uh in our team we use guidra

40
00:01:48,000 --> 00:01:50,479
as a disassembler which is

41
00:01:50,479 --> 00:01:55,280
an open source tool released by nsa and

42
00:01:55,280 --> 00:01:57,759
compared to ida pro for example it's in

43
00:01:57,759 --> 00:01:59,920
early stage writing

44
00:01:59,920 --> 00:02:02,640
scripts and different tools for adar

45
00:02:02,640 --> 00:02:03,840
analysis

46
00:02:03,840 --> 00:02:05,200
so

47
00:02:05,200 --> 00:02:07,280
never only a few

48
00:02:07,280 --> 00:02:09,679
scripts available to help our problem to

49
00:02:09,679 --> 00:02:12,480
analyze the goaling binaries and our

50
00:02:12,480 --> 00:02:14,640
goal was to find some way to make it

51
00:02:14,640 --> 00:02:17,200
easier to make our lives easier so we

52
00:02:17,200 --> 00:02:19,599
that's why we started to work on how

53
00:02:19,599 --> 00:02:22,400
could we make this uh analysis

54
00:02:22,400 --> 00:02:23,520
uh

55
00:02:23,520 --> 00:02:25,040
much more effective

56
00:02:25,040 --> 00:02:27,680
so basically what i will explain in this

57
00:02:27,680 --> 00:02:30,080
talk today is uh

58
00:02:30,080 --> 00:02:33,200
what we need to know about the goal

59
00:02:33,200 --> 00:02:34,879
language what we need to understand

60
00:02:34,879 --> 00:02:37,599
there uh what the different features

61
00:02:37,599 --> 00:02:38,959
gitra had

62
00:02:38,959 --> 00:02:42,720
has that we used in the in our project

63
00:02:42,720 --> 00:02:44,560
and then

64
00:02:44,560 --> 00:02:46,160
i will introduce the scripts that we

65
00:02:46,160 --> 00:02:48,160
wrote and those are also available on

66
00:02:48,160 --> 00:02:51,120
github so if anyone

67
00:02:51,120 --> 00:02:53,280
needs this script want to use it or

68
00:02:53,280 --> 00:02:55,760
improve it or just collaborate then you

69
00:02:55,760 --> 00:02:58,400
can find it and use it for your

70
00:02:58,400 --> 00:03:00,159
own analysis

71
00:03:00,159 --> 00:03:01,040
so

72
00:03:01,040 --> 00:03:04,319
a few words just quickly about golang

73
00:03:04,319 --> 00:03:06,879
the this is a language which was

74
00:03:06,879 --> 00:03:10,080
developed by google and made available

75
00:03:10,080 --> 00:03:11,760
to the public

76
00:03:11,760 --> 00:03:14,879
now we are at the version of 1.18 in our

77
00:03:14,879 --> 00:03:16,959
research we were mainly focusing on

78
00:03:16,959 --> 00:03:19,760
versions up to 1.15 because most of the

79
00:03:19,760 --> 00:03:22,000
malware families that we analyzed are

80
00:03:22,000 --> 00:03:23,200
written in

81
00:03:23,200 --> 00:03:26,159
versions up to 1.15 but i will also

82
00:03:26,159 --> 00:03:27,920
mention some of the changes that

83
00:03:27,920 --> 00:03:30,840
happened since then between 1.15 and

84
00:03:30,840 --> 00:03:34,959
1.18 and um

85
00:03:35,040 --> 00:03:36,319
there are many

86
00:03:36,319 --> 00:03:37,920
different uh

87
00:03:37,920 --> 00:03:40,640
researches and questionnaires which

88
00:03:40,640 --> 00:03:43,280
shows that the golang is getting more

89
00:03:43,280 --> 00:03:45,920
and more popular not just among other

90
00:03:45,920 --> 00:03:48,159
developers but in for developers in

91
00:03:48,159 --> 00:03:50,560
general general it's a

92
00:03:50,560 --> 00:03:54,799
very easy to learn uh language very

93
00:03:54,799 --> 00:03:58,640
simple and with clear documentation

94
00:03:58,640 --> 00:04:01,839
and um

95
00:04:01,920 --> 00:04:04,560
probably the biggest uh advantage of

96
00:04:04,560 --> 00:04:06,000
this language for

97
00:04:06,000 --> 00:04:08,080
for example mother developers

98
00:04:08,080 --> 00:04:11,040
is this uh the cross-compiling uh

99
00:04:11,040 --> 00:04:13,920
uh feature of go so you don't have to

100
00:04:13,920 --> 00:04:16,478
maintain different code bases for linux

101
00:04:16,478 --> 00:04:18,880
windows mac and whatever you just have

102
00:04:18,880 --> 00:04:20,639
one code and then you can compile it for

103
00:04:20,639 --> 00:04:22,479
the different architectures that you

104
00:04:22,479 --> 00:04:24,800
want to use it and this is a for example

105
00:04:24,800 --> 00:04:27,199
in case of botnet families this is very

106
00:04:27,199 --> 00:04:29,280
useful for the marver developers they

107
00:04:29,280 --> 00:04:32,240
then compile it for arm x86 whatever

108
00:04:32,240 --> 00:04:34,240
they need they just have one code base

109
00:04:34,240 --> 00:04:36,240
and then they can use it on many

110
00:04:36,240 --> 00:04:38,960
different devices so that's why it's uh

111
00:04:38,960 --> 00:04:40,639
i think this is one of the main reasons

112
00:04:40,639 --> 00:04:42,639
why it's very

113
00:04:42,639 --> 00:04:45,199
popular and also it's it's really simple

114
00:04:45,199 --> 00:04:47,520
like a scripting language it's easy to

115
00:04:47,520 --> 00:04:49,520
to write in a go

116
00:04:49,520 --> 00:04:51,520
and um

117
00:04:51,520 --> 00:04:53,360
so for example if you look at the mother

118
00:04:53,360 --> 00:04:55,919
families here here i mention mention a

119
00:04:55,919 --> 00:04:59,600
couple of recent families and also

120
00:04:59,600 --> 00:05:01,840
research from uh

121
00:05:01,840 --> 00:05:04,000
the palo alto research group and also

122
00:05:04,000 --> 00:05:06,639
into their they they showed that the

123
00:05:06,639 --> 00:05:09,199
number of mother families written in goa

124
00:05:09,199 --> 00:05:10,800
increased dramatically in the last

125
00:05:10,800 --> 00:05:12,560
couple of years

126
00:05:12,560 --> 00:05:14,639
it's not just iot model not just linux

127
00:05:14,639 --> 00:05:16,160
malware it's also

128
00:05:16,160 --> 00:05:18,479
and mainly windows mother but in our

129
00:05:18,479 --> 00:05:21,759
team we are focusing more on uh linux

130
00:05:21,759 --> 00:05:23,360
binaries

131
00:05:23,360 --> 00:05:24,880
so

132
00:05:24,880 --> 00:05:26,560
oh sorry

133
00:05:26,560 --> 00:05:28,720
now i will only talk briefly about two

134
00:05:28,720 --> 00:05:32,560
families because we used uh samples from

135
00:05:32,560 --> 00:05:34,960
these to demonstrate the examples in

136
00:05:34,960 --> 00:05:36,960
this uh talk

137
00:05:36,960 --> 00:05:39,280
and for ev on every slide you will see

138
00:05:39,280 --> 00:05:40,720
which

139
00:05:40,720 --> 00:05:44,720
exact malware sample will using to to

140
00:05:44,720 --> 00:05:46,800
to show that specific feature so if

141
00:05:46,800 --> 00:05:49,039
anyone wants to later on play with it

142
00:05:49,039 --> 00:05:52,000
try out do the exact steps to understand

143
00:05:52,000 --> 00:05:54,080
what we were doing then it's uh very

144
00:05:54,080 --> 00:05:55,840
easy you can either download the mother

145
00:05:55,840 --> 00:05:57,680
samples from virustotal and there are

146
00:05:57,680 --> 00:05:59,680
non-malicious samples that we used and

147
00:05:59,680 --> 00:06:01,680
uploaded to our github repository so you

148
00:06:01,680 --> 00:06:03,759
can also use those

149
00:06:03,759 --> 00:06:05,680
so the first one that

150
00:06:05,680 --> 00:06:06,720
you will

151
00:06:06,720 --> 00:06:08,240
meet during this presentation is the

152
00:06:08,240 --> 00:06:10,639
acrylics ransomware this was first

153
00:06:10,639 --> 00:06:13,759
discovered in the 2019 and but it is

154
00:06:13,759 --> 00:06:16,800
still active since uh them it used both

155
00:06:16,800 --> 00:06:20,160
brute force and different exploits to

156
00:06:20,160 --> 00:06:23,520
attack mainly qnf-ness devices

157
00:06:23,520 --> 00:06:24,800
and uh

158
00:06:24,800 --> 00:06:27,360
over the years it added new and new uh

159
00:06:27,360 --> 00:06:29,600
exploits to its uh

160
00:06:29,600 --> 00:06:31,759
toolset and for the first version there

161
00:06:31,759 --> 00:06:33,759
is a decryptor available but

162
00:06:33,759 --> 00:06:35,680
unfortunately for the later versions we

163
00:06:35,680 --> 00:06:37,759
don't have those yet

164
00:06:37,759 --> 00:06:39,759
and the other mulvar family that we use

165
00:06:39,759 --> 00:06:43,199
for this research is the kaiji botnet

166
00:06:43,199 --> 00:06:46,160
this is named after a manga series and

167
00:06:46,160 --> 00:06:48,000
it was first discovered earlier this

168
00:06:48,000 --> 00:06:49,039
year

169
00:06:49,039 --> 00:06:52,160
uh it's fully written in go from scratch

170
00:06:52,160 --> 00:06:53,840
and um

171
00:06:53,840 --> 00:06:57,120
spreads using ssh brute forcing

172
00:06:57,120 --> 00:07:00,000
uh basically it is getting insulted into

173
00:07:00,000 --> 00:07:02,800
a specific location with a

174
00:07:02,800 --> 00:07:06,479
process name that looks legit and then

175
00:07:06,479 --> 00:07:09,440
maintains uh persistence through

176
00:07:09,440 --> 00:07:11,919
various uh

177
00:07:11,919 --> 00:07:13,280
solutions

178
00:07:13,280 --> 00:07:14,560
and then

179
00:07:14,560 --> 00:07:17,680
basically it copies the rootkit model

180
00:07:17,680 --> 00:07:20,800
and run it every 30 seconds

181
00:07:20,800 --> 00:07:21,599
and

182
00:07:21,599 --> 00:07:24,160
obviously it will then initiate ddos

183
00:07:24,160 --> 00:07:25,360
attacks

184
00:07:25,360 --> 00:07:27,520
so

185
00:07:28,000 --> 00:07:29,840
let's uh talk a little bit about go

186
00:07:29,840 --> 00:07:31,039
binaries

187
00:07:31,039 --> 00:07:34,240
uh the one thing is the static linking

188
00:07:34,240 --> 00:07:36,560
in goal so by default these binaries are

189
00:07:36,560 --> 00:07:38,800
statically linked that's why the huge

190
00:07:38,800 --> 00:07:41,120
size of a gold binary

191
00:07:41,120 --> 00:07:42,240
and

192
00:07:42,240 --> 00:07:44,160
it means that all the necessary

193
00:07:44,160 --> 00:07:46,319
libraries are included in the executable

194
00:07:46,319 --> 00:07:47,919
which means that it can run on every

195
00:07:47,919 --> 00:07:50,560
system without any dependency issues it

196
00:07:50,560 --> 00:07:52,400
it will have everything within the

197
00:07:52,400 --> 00:07:54,800
binary that it needs to run

198
00:07:54,800 --> 00:07:56,319
but

199
00:07:56,319 --> 00:07:58,720
with this larger size also comes with

200
00:07:58,720 --> 00:08:00,080
some some

201
00:08:00,080 --> 00:08:02,319
drawbacks like uh

202
00:08:02,319 --> 00:08:04,160
for example it's the mother distribution

203
00:08:04,160 --> 00:08:06,240
is difficult i'm talking about our iot

204
00:08:06,240 --> 00:08:08,160
mother but obviously where we don't

205
00:08:08,160 --> 00:08:09,440
really have

206
00:08:09,440 --> 00:08:10,319
enough

207
00:08:10,319 --> 00:08:13,120
room for uh such large binary it won't

208
00:08:13,120 --> 00:08:14,319
work but

209
00:08:14,319 --> 00:08:15,520
uh

210
00:08:15,520 --> 00:08:18,479
that's one issue also sometimes av

211
00:08:18,479 --> 00:08:20,960
products have some issues detecting

212
00:08:20,960 --> 00:08:24,080
these gold binaries and also reverse

213
00:08:24,080 --> 00:08:25,759
engineering is much more difficult when

214
00:08:25,759 --> 00:08:28,000
we have to look at such a huge binary

215
00:08:28,000 --> 00:08:30,080
and i will show examples what you have

216
00:08:30,080 --> 00:08:32,799
to face when you do reverse engineering

217
00:08:32,799 --> 00:08:33,760
so

218
00:08:33,760 --> 00:08:36,559
let's start with simple hello world

219
00:08:36,559 --> 00:08:39,440
examples uh we will compare however

220
00:08:39,440 --> 00:08:41,440
written in c and hello world returning

221
00:08:41,440 --> 00:08:43,839
goal if

222
00:08:43,839 --> 00:08:46,000
now we are talking about the unstripped

223
00:08:46,000 --> 00:08:47,360
binaries and

224
00:08:47,360 --> 00:08:49,279
basically what is interesting from this

225
00:08:49,279 --> 00:08:53,040
slide is only the size of the files so

226
00:08:53,040 --> 00:08:55,760
if you create a simple hello world in c

227
00:08:55,760 --> 00:08:58,240
and also you create one in go you can

228
00:08:58,240 --> 00:09:00,560
see that the go version is like two

229
00:09:00,560 --> 00:09:04,240
megabytes that's huge compared to the 16

230
00:09:04,240 --> 00:09:06,480
kilobytes of the c

231
00:09:06,480 --> 00:09:09,519
binary and also if you upload it into

232
00:09:09,519 --> 00:09:11,839
gitra so i'm not sure how much you can

233
00:09:11,839 --> 00:09:15,040
see from this but i tell you what the uh

234
00:09:15,040 --> 00:09:16,720
main thing that you have to look it look

235
00:09:16,720 --> 00:09:17,680
now

236
00:09:17,680 --> 00:09:20,480
there is a list of functions that are

237
00:09:20,480 --> 00:09:22,480
included in the binary and in case of

238
00:09:22,480 --> 00:09:24,320
the c there are 19 functions that's very

239
00:09:24,320 --> 00:09:25,920
easy you can just go through that and

240
00:09:25,920 --> 00:09:28,720
then see what this binary is doing but

241
00:09:28,720 --> 00:09:32,399
in go there are 719 functions so that's

242
00:09:32,399 --> 00:09:34,480
crazy so you have to find something

243
00:09:34,480 --> 00:09:37,360
interesting among those those functions

244
00:09:37,360 --> 00:09:39,440
and

245
00:09:39,440 --> 00:09:41,519
what is even a bigger problem that

246
00:09:41,519 --> 00:09:43,279
usually we don't see

247
00:09:43,279 --> 00:09:45,040
this clearly these function names

248
00:09:45,040 --> 00:09:47,120
because

249
00:09:47,120 --> 00:09:48,800
most of the cases these malware flies

250
00:09:48,800 --> 00:09:50,399
are stripped so it means that the

251
00:09:50,399 --> 00:09:52,959
debugging symbols are discarded the size

252
00:09:52,959 --> 00:09:54,880
of the of course will be reduced that's

253
00:09:54,880 --> 00:09:57,360
very nice and

254
00:09:57,360 --> 00:10:01,360
but there will be no function names no

255
00:10:01,360 --> 00:10:04,000
variable names and it's more more more

256
00:10:04,000 --> 00:10:05,600
difficult to debug and reverse

257
00:10:05,600 --> 00:10:07,440
engineering so when you cannot read what

258
00:10:07,440 --> 00:10:09,519
this function is doing exactly that's

259
00:10:09,519 --> 00:10:11,680
that's made that makes our work

260
00:10:11,680 --> 00:10:13,120
more difficult

261
00:10:13,120 --> 00:10:14,240
and

262
00:10:14,240 --> 00:10:16,160
but if you take a look at the same

263
00:10:16,160 --> 00:10:18,320
examples but here we stripped the

264
00:10:18,320 --> 00:10:21,200
binaries in case of go with the ld flags

265
00:10:21,200 --> 00:10:23,200
that as a

266
00:10:23,200 --> 00:10:26,240
parameter it's reduced from 2 megabytes

267
00:10:26,240 --> 00:10:29,200
to 1.3 which is still large

268
00:10:29,200 --> 00:10:32,640
so if and if we look at the uh

269
00:10:32,640 --> 00:10:34,720
sorry functions again

270
00:10:34,720 --> 00:10:38,560
now we don't have the 1700 but we still

271
00:10:38,560 --> 00:10:40,320
have 1000

272
00:10:40,320 --> 00:10:43,040
and more than 1100 functions and we

273
00:10:43,040 --> 00:10:44,800
don't have the function names so we can

274
00:10:44,800 --> 00:10:46,560
see that there are 1000 functions all

275
00:10:46,560 --> 00:10:48,399
with

276
00:10:48,399 --> 00:10:50,640
some numbers and then here you go let's

277
00:10:50,640 --> 00:10:53,519
try to find out what's going on here so

278
00:10:53,519 --> 00:10:56,240
what we were trying to understand if we

279
00:10:56,240 --> 00:10:58,320
could recover these function names how

280
00:10:58,320 --> 00:11:02,079
can we do it and

281
00:11:02,079 --> 00:11:03,839
obviously how we

282
00:11:03,839 --> 00:11:05,680
came to this idea we already knew that

283
00:11:05,680 --> 00:11:07,839
this can be recovered so even so if you

284
00:11:07,839 --> 00:11:10,240
don't use for example guidra but you use

285
00:11:10,240 --> 00:11:12,560
ida pro the latest version can already

286
00:11:12,560 --> 00:11:15,279
do it for you easily but here we are

287
00:11:15,279 --> 00:11:19,120
talking about how to do this with gidra

288
00:11:19,120 --> 00:11:20,480
and uh

289
00:11:20,480 --> 00:11:22,640
just for comparison if we look at the

290
00:11:22,640 --> 00:11:25,040
main function within the the

291
00:11:25,040 --> 00:11:28,640
disassembler wii u of the uh of gidra

292
00:11:28,640 --> 00:11:30,959
then you can see on the

293
00:11:30,959 --> 00:11:33,440
left side the uh unstreet version on the

294
00:11:33,440 --> 00:11:35,279
right the street version it's not too

295
00:11:35,279 --> 00:11:37,760
difficult okay now we don't see the name

296
00:11:37,760 --> 00:11:39,600
of the function but it's just a few

297
00:11:39,600 --> 00:11:42,160
lines so it's still easy to understand

298
00:11:42,160 --> 00:11:44,560
but in case of go already the main

299
00:11:44,560 --> 00:11:46,640
function which supposed to only print

300
00:11:46,640 --> 00:11:49,120
hello world is much more complicated

301
00:11:49,120 --> 00:11:51,600
than in c but it's just one line

302
00:11:51,600 --> 00:11:52,880
and

303
00:11:52,880 --> 00:11:54,880
when it's stripped we don't even have

304
00:11:54,880 --> 00:11:57,200
the function and don't have the

305
00:11:57,200 --> 00:11:59,200
have more information here

306
00:11:59,200 --> 00:12:00,000
so

307
00:12:00,000 --> 00:12:01,440
uh

308
00:12:01,440 --> 00:12:03,839
what we were trying to do here is figure

309
00:12:03,839 --> 00:12:05,360
out how we could recover the function

310
00:12:05,360 --> 00:12:07,760
names and the first step we did we tried

311
00:12:07,760 --> 00:12:09,279
to look for the functioning within the

312
00:12:09,279 --> 00:12:11,120
binaries so on the left side what you

313
00:12:11,120 --> 00:12:13,600
can see is looking for the main function

314
00:12:13,600 --> 00:12:15,600
name within the unstripped version in

315
00:12:15,600 --> 00:12:17,680
case of go the function name that we

316
00:12:17,680 --> 00:12:20,320
were looking for is main.main and on the

317
00:12:20,320 --> 00:12:22,320
right side you can see we were looking

318
00:12:22,320 --> 00:12:24,880
for the same in the street versions in c

319
00:12:24,880 --> 00:12:27,279
the main string just simply disappeared

320
00:12:27,279 --> 00:12:29,440
from the stripped binary but in go we

321
00:12:29,440 --> 00:12:32,399
could still see main.main which gave us

322
00:12:32,399 --> 00:12:35,920
some kind of hope that we can recover it

323
00:12:35,920 --> 00:12:37,680
so

324
00:12:37,680 --> 00:12:40,240
what we did here we loaded the the

325
00:12:40,240 --> 00:12:42,240
binary into gitra and tried to look for

326
00:12:42,240 --> 00:12:44,320
the main dot main

327
00:12:44,320 --> 00:12:46,880
string and when we looked at the memory

328
00:12:46,880 --> 00:12:47,920
map

329
00:12:47,920 --> 00:12:51,760
we saw that it's in a special specific

330
00:12:51,760 --> 00:12:54,240
section called go pclm tab

331
00:12:54,240 --> 00:12:56,959
so the next step was to figure out what

332
00:12:56,959 --> 00:12:57,760
this

333
00:12:57,760 --> 00:12:59,839
section is about what we do what we can

334
00:12:59,839 --> 00:13:02,880
we know about this section and how uh

335
00:13:02,880 --> 00:13:04,959
what kind of information is stored

336
00:13:04,959 --> 00:13:07,680
starter and it's um

337
00:13:07,680 --> 00:13:10,320
it was pretty easy so from google uh

338
00:13:10,320 --> 00:13:12,240
version 1.2 there is a very nice

339
00:13:12,240 --> 00:13:14,160
documentation the link is

340
00:13:14,160 --> 00:13:16,560
on the slide if someone is interested in

341
00:13:16,560 --> 00:13:20,079
more details about how the pcl and tab

342
00:13:20,079 --> 00:13:22,320
structure looks like

343
00:13:22,320 --> 00:13:25,279
it usually always it starts with a magic

344
00:13:25,279 --> 00:13:28,800
value and then to 0

345
00:13:28,800 --> 00:13:30,560
bytes following by

346
00:13:30,560 --> 00:13:32,240
instructions size quantum and the

347
00:13:32,240 --> 00:13:34,800
pointer size and then

348
00:13:34,800 --> 00:13:37,600
what is really interesting for us here

349
00:13:37,600 --> 00:13:40,240
is uh function function addresses

350
00:13:40,240 --> 00:13:42,639
followed by the function metadata

351
00:13:42,639 --> 00:13:44,800
pointers so for

352
00:13:44,800 --> 00:13:47,120
we have a an address of a function and

353
00:13:47,120 --> 00:13:49,199
then a pointer to a function metadata

354
00:13:49,199 --> 00:13:52,880
table so let's take a look at the

355
00:13:52,880 --> 00:13:56,480
function metadata table here it starts

356
00:13:56,480 --> 00:13:58,160
again with the entry point of that

357
00:13:58,160 --> 00:13:59,680
specific function

358
00:13:59,680 --> 00:14:01,120
and then

359
00:14:01,120 --> 00:14:04,320
among other information there is an

360
00:14:04,320 --> 00:14:06,000
offset to

361
00:14:06,000 --> 00:14:08,399
the function name so where can we find

362
00:14:08,399 --> 00:14:12,160
the name of that specific function

363
00:14:12,160 --> 00:14:13,680
this

364
00:14:13,680 --> 00:14:14,959
changed

365
00:14:14,959 --> 00:14:20,480
this year in go version 1.16 and 1.18

366
00:14:20,480 --> 00:14:23,040
our skipped is already updated for 1.16

367
00:14:23,040 --> 00:14:26,320
and will be shortly for 1.18 as well so

368
00:14:26,320 --> 00:14:28,240
basically the

369
00:14:28,240 --> 00:14:30,000
we have all the information there still

370
00:14:30,000 --> 00:14:32,720
but the function name of that and

371
00:14:32,720 --> 00:14:36,240
also this uh function metadata

372
00:14:36,240 --> 00:14:39,760
table was moved to somewhere else but

373
00:14:39,760 --> 00:14:41,839
i won't go into details but it's still

374
00:14:41,839 --> 00:14:44,320
there so we can just find it using this

375
00:14:44,320 --> 00:14:47,199
information the nice thing about golang

376
00:14:47,199 --> 00:14:48,880
is that everything is nicely documented

377
00:14:48,880 --> 00:14:50,240
you can just look at the source code and

378
00:14:50,240 --> 00:14:52,720
find what you need so for example here

379
00:14:52,720 --> 00:14:55,120
you can find the magic values that are

380
00:14:55,120 --> 00:14:57,440
used by different versions for the

381
00:14:57,440 --> 00:15:00,800
google pc ln tab and also how to check

382
00:15:00,800 --> 00:15:03,360
how to search for this uh

383
00:15:03,360 --> 00:15:04,560
structure

384
00:15:04,560 --> 00:15:05,360
and

385
00:15:05,360 --> 00:15:08,240
for every single uh version when some

386
00:15:08,240 --> 00:15:11,440
changes were made there are uh

387
00:15:11,440 --> 00:15:13,760
there is it it will exactly show you how

388
00:15:13,760 --> 00:15:15,680
to recover the information that you need

389
00:15:15,680 --> 00:15:18,320
so basically you just need to

390
00:15:18,320 --> 00:15:21,360
do the same in uh scripting for gydra

391
00:15:21,360 --> 00:15:23,040
but it's exactly these are exactly the

392
00:15:23,040 --> 00:15:24,639
same steps so you can see here the

393
00:15:24,639 --> 00:15:29,120
version 1.2 1.16 1.18 it will tell you

394
00:15:29,120 --> 00:15:31,120
how to search for the function name tab

395
00:15:31,120 --> 00:15:33,600
how to search for the file tab how to

396
00:15:33,600 --> 00:15:35,199
search for the function metadata

397
00:15:35,199 --> 00:15:37,040
metadata table

398
00:15:37,040 --> 00:15:39,040
and

399
00:15:39,040 --> 00:15:40,800
here are one side note so you're during

400
00:15:40,800 --> 00:15:43,199
our research we're focusing on linux but

401
00:15:43,199 --> 00:15:45,680
uh for windows there is no specific

402
00:15:45,680 --> 00:15:48,639
section called p go pcl and tab so

403
00:15:48,639 --> 00:15:50,160
in our scripts we are looking for that

404
00:15:50,160 --> 00:15:52,800
section but in windows this structure is

405
00:15:52,800 --> 00:15:55,519
still there so what you need to do here

406
00:15:55,519 --> 00:15:58,639
is looking for that magic values and all

407
00:15:58,639 --> 00:16:02,000
the bytes that are following so that's

408
00:16:02,000 --> 00:16:04,480
not much more difficult than in case of

409
00:16:04,480 --> 00:16:06,000
linux

410
00:16:06,000 --> 00:16:10,720
uh and um here in one on one example i

411
00:16:10,720 --> 00:16:13,519
just want to demonstrate the steps

412
00:16:13,519 --> 00:16:16,800
so the idea is to find this uh pcl and

413
00:16:16,800 --> 00:16:19,040
tab structure extract the function

414
00:16:19,040 --> 00:16:21,040
address and then find the function name

415
00:16:21,040 --> 00:16:23,120
offset and then you can just basically

416
00:16:23,120 --> 00:16:27,040
recover uh your function names so here

417
00:16:27,040 --> 00:16:28,959
if someone is interested you can go

418
00:16:28,959 --> 00:16:31,600
through every step we calculated it here

419
00:16:31,600 --> 00:16:34,639
so first you find the pcln tab and then

420
00:16:34,639 --> 00:16:36,560
in here

421
00:16:36,560 --> 00:16:37,920
there is the

422
00:16:37,920 --> 00:16:40,000
function address i also we also put it

423
00:16:40,000 --> 00:16:41,680
there that there is this main dot main

424
00:16:41,680 --> 00:16:43,279
function that we are looking for and

425
00:16:43,279 --> 00:16:45,120
then there is an offset to the function

426
00:16:45,120 --> 00:16:47,600
method data table where you can find

427
00:16:47,600 --> 00:16:50,480
again the address of the function

428
00:16:50,480 --> 00:16:53,839
followed by the address of the or the

429
00:16:53,839 --> 00:16:55,920
sorry offset of the

430
00:16:55,920 --> 00:16:56,639
uh

431
00:16:56,639 --> 00:16:59,680
function name so this is basically what

432
00:16:59,680 --> 00:17:01,279
we need to recover

433
00:17:01,279 --> 00:17:04,160
uh function names here so after

434
00:17:04,160 --> 00:17:06,480
executing the script

435
00:17:06,480 --> 00:17:09,760
what we can see that from 1100 functions

436
00:17:09,760 --> 00:17:11,839
we will get

437
00:17:11,839 --> 00:17:14,400
almost 1800

438
00:17:14,400 --> 00:17:17,520
and now we have all the function names

439
00:17:17,520 --> 00:17:19,919
nicely visible so for example main.main

440
00:17:19,919 --> 00:17:21,599
can be found

441
00:17:21,599 --> 00:17:23,919
and well with this hello bird example

442
00:17:23,919 --> 00:17:25,359
it's not very

443
00:17:25,359 --> 00:17:27,119
interesting but if you look at a real

444
00:17:27,119 --> 00:17:29,200
world example this is an acrylics

445
00:17:29,200 --> 00:17:31,840
ransomware once you execute the script

446
00:17:31,840 --> 00:17:34,480
and you can see the function names just

447
00:17:34,480 --> 00:17:36,400
by looking at the function names like

448
00:17:36,400 --> 00:17:37,840
main dot

449
00:17:37,840 --> 00:17:40,480
write message main dot check read me

450
00:17:40,480 --> 00:17:42,960
make secret or

451
00:17:42,960 --> 00:17:44,160
encrypt

452
00:17:44,160 --> 00:17:46,080
it's you don't really need to do much

453
00:17:46,080 --> 00:17:48,799
more to have an idea what this uh piece

454
00:17:48,799 --> 00:17:50,960
of malware is doing it's pretty obvious

455
00:17:50,960 --> 00:17:52,480
that it's a run somewhere but at least

456
00:17:52,480 --> 00:17:54,160
you can you know where to start the

457
00:17:54,160 --> 00:17:57,120
analysis so just by simply recovering

458
00:17:57,120 --> 00:18:00,000
function names it's it it becomes very

459
00:18:00,000 --> 00:18:02,559
easy to start reverse engineering such

460
00:18:02,559 --> 00:18:04,000
binaries

461
00:18:04,000 --> 00:18:05,039
and

462
00:18:05,039 --> 00:18:08,799
there were obviously some challenges uh

463
00:18:08,799 --> 00:18:11,840
didra had some issues which were solved

464
00:18:11,840 --> 00:18:17,120
even from video 9.1 to 9.2 so now

465
00:18:17,919 --> 00:18:20,000
this works much

466
00:18:20,000 --> 00:18:22,960
better but for example it can happen

467
00:18:22,960 --> 00:18:23,840
that

468
00:18:23,840 --> 00:18:26,000
you are looking for a

469
00:18:26,000 --> 00:18:28,240
function name but there is no strings

470
00:18:28,240 --> 00:18:30,720
defined there by didra so it will just

471
00:18:30,720 --> 00:18:32,080
throw an error that there is nothing

472
00:18:32,080 --> 00:18:33,440
because guidera didn't realize that

473
00:18:33,440 --> 00:18:35,679
there is a string so in that case we

474
00:18:35,679 --> 00:18:38,000
just need to take care of it before we

475
00:18:38,000 --> 00:18:40,640
use that we just have to create the

476
00:18:40,640 --> 00:18:42,960
string there and then we can recover the

477
00:18:42,960 --> 00:18:45,039
function function name

478
00:18:45,039 --> 00:18:47,760
so this was the first uh

479
00:18:47,760 --> 00:18:50,000
topic and now that we were talking about

480
00:18:50,000 --> 00:18:52,480
the strings let's move to the second one

481
00:18:52,480 --> 00:18:55,600
where we looked into the strings within

482
00:18:55,600 --> 00:18:57,120
uh gidra

483
00:18:57,120 --> 00:18:59,440
so again let's start with an easy hello

484
00:18:59,440 --> 00:19:01,679
world example and we look into the

485
00:19:01,679 --> 00:19:03,840
defined strings window within gitra this

486
00:19:03,840 --> 00:19:05,600
is where you can find all the strings

487
00:19:05,600 --> 00:19:07,520
that gidra could extract it from the

488
00:19:07,520 --> 00:19:09,919
binary and it can also be very helpful

489
00:19:09,919 --> 00:19:13,280
first step when you analyzing a malware

490
00:19:13,280 --> 00:19:15,280
and on the left side you can see the c

491
00:19:15,280 --> 00:19:17,760
version and on the right side you can

492
00:19:17,760 --> 00:19:20,320
see the go version so while in c there

493
00:19:20,320 --> 00:19:22,720
are seven defined strings there are more

494
00:19:22,720 --> 00:19:25,520
than six thousand in uh in the go

495
00:19:25,520 --> 00:19:27,679
version so that's already a little bit

496
00:19:27,679 --> 00:19:29,120
difficult to go through all the six

497
00:19:29,120 --> 00:19:31,679
thousand uh strings and try to figure

498
00:19:31,679 --> 00:19:32,880
out what is

499
00:19:32,880 --> 00:19:35,840
interesting for you and uh what is even

500
00:19:35,840 --> 00:19:37,919
worse here that this is the hello world

501
00:19:37,919 --> 00:19:39,919
binary so we are looking for hello bird

502
00:19:39,919 --> 00:19:42,480
which is nicely visible in the c binary

503
00:19:42,480 --> 00:19:44,960
but indra even there are more than six

504
00:19:44,960 --> 00:19:46,000
thousand

505
00:19:46,000 --> 00:19:48,480
strings it won't find hello world for

506
00:19:48,480 --> 00:19:50,160
you so the only thing that would be

507
00:19:50,160 --> 00:19:51,520
interesting

508
00:19:51,520 --> 00:19:54,799
so let's uh take a look at the

509
00:19:54,799 --> 00:19:56,080
strings

510
00:19:56,080 --> 00:19:58,080
first we just simply use the strings

511
00:19:58,080 --> 00:20:01,039
utility and grab for hello to see

512
00:20:01,039 --> 00:20:04,159
what we can expect and the in c that's

513
00:20:04,159 --> 00:20:06,320
pretty obvious we got hello world but in

514
00:20:06,320 --> 00:20:08,240
the go binary

515
00:20:08,240 --> 00:20:09,520
what uh

516
00:20:09,520 --> 00:20:11,440
the problem is that you can see that we

517
00:20:11,440 --> 00:20:13,760
got like a huge string blob where and

518
00:20:13,760 --> 00:20:15,440
somewhere in the middle that is hello

519
00:20:15,440 --> 00:20:18,000
bird now it's it's easy because we know

520
00:20:18,000 --> 00:20:19,520
that we are looking for hell hello but

521
00:20:19,520 --> 00:20:20,880
when we don't know what we are looking

522
00:20:20,880 --> 00:20:23,039
for going through these that is very

523
00:20:23,039 --> 00:20:25,360
time consuming and not really helpful so

524
00:20:25,360 --> 00:20:29,200
you won't read everything line by line

525
00:20:29,200 --> 00:20:30,799
so

526
00:20:30,799 --> 00:20:32,080
let's

527
00:20:32,080 --> 00:20:35,440
look at what our strings within go so in

528
00:20:35,440 --> 00:20:37,280
see what we all know this sequence of

529
00:20:37,280 --> 00:20:38,640
characters terminated with the null

530
00:20:38,640 --> 00:20:40,640
character the main difference is that in

531
00:20:40,640 --> 00:20:41,840
go

532
00:20:41,840 --> 00:20:44,240
these are sequence of bytes with a fixed

533
00:20:44,240 --> 00:20:46,640
length so they are not null terminated

534
00:20:46,640 --> 00:20:48,480
and there is of like a specific

535
00:20:48,480 --> 00:20:50,720
structure the string structure which

536
00:20:50,720 --> 00:20:52,159
consists of the

537
00:20:52,159 --> 00:20:54,960
uh a pointer to the string and also

538
00:20:54,960 --> 00:20:56,960
there is an integer showing the length

539
00:20:56,960 --> 00:20:59,360
of the string so we need to find these

540
00:20:59,360 --> 00:21:00,799
structures

541
00:21:00,799 --> 00:21:02,400
and

542
00:21:02,400 --> 00:21:05,039
and yes and all these uh different uh

543
00:21:05,039 --> 00:21:07,679
strings are concatenated together to

544
00:21:07,679 --> 00:21:09,840
like a large string blob and that's why

545
00:21:09,840 --> 00:21:11,760
when we were looking for however in the

546
00:21:11,760 --> 00:21:14,159
previous slide uh

547
00:21:14,159 --> 00:21:15,440
we got

548
00:21:15,440 --> 00:21:18,400
that huge uh stream so that's why deidra

549
00:21:18,400 --> 00:21:20,080
has a hard time defining these strings

550
00:21:20,080 --> 00:21:21,919
because it looks for characters

551
00:21:21,919 --> 00:21:23,679
non-terminated characters and this is

552
00:21:23,679 --> 00:21:27,280
what didra can handle so the idea was to

553
00:21:27,280 --> 00:21:29,679
find to have guidera somehow find these

554
00:21:29,679 --> 00:21:32,000
string structures and there are many

555
00:21:32,000 --> 00:21:34,080
different ways how these strings

556
00:21:34,080 --> 00:21:36,559
structures can be built up they can be

557
00:21:36,559 --> 00:21:39,520
statically or dynamically allocated this

558
00:21:39,520 --> 00:21:40,400
is

559
00:21:40,400 --> 00:21:43,440
very different per architecture set and

560
00:21:43,440 --> 00:21:46,080
even within one architecture there are

561
00:21:46,080 --> 00:21:47,760
multiple solutions

562
00:21:47,760 --> 00:21:49,919
and it can change pergola version so

563
00:21:49,919 --> 00:21:53,200
it's like a mess how you can

564
00:21:53,200 --> 00:21:56,000
recover the strings

565
00:21:56,000 --> 00:21:57,440
so

566
00:21:57,440 --> 00:22:00,159
uh i will go through a few examples now

567
00:22:00,159 --> 00:22:02,559
let's start with the dynamically

568
00:22:02,559 --> 00:22:05,039
allocated string structures

569
00:22:05,039 --> 00:22:07,200
so it basically means that these

570
00:22:07,200 --> 00:22:09,280
structures will be built up during run

571
00:22:09,280 --> 00:22:12,640
time and there are several different uh

572
00:22:12,640 --> 00:22:15,440
scenarios again so if we look at the

573
00:22:15,440 --> 00:22:16,960
hello world examples again from the

574
00:22:16,960 --> 00:22:19,280
string point of view if you

575
00:22:19,280 --> 00:22:21,039
look at the disassembly

576
00:22:21,039 --> 00:22:24,080
of uh the main function in c it's very

577
00:22:24,080 --> 00:22:26,720
easy to read so even if you never use

578
00:22:26,720 --> 00:22:28,880
gidra or ida or anything if you just

579
00:22:28,880 --> 00:22:30,880
look at this assembly you can tell that

580
00:22:30,880 --> 00:22:33,600
it will print hello world but

581
00:22:33,600 --> 00:22:34,960
for uh

582
00:22:34,960 --> 00:22:38,480
go it's it's a much bigger function you

583
00:22:38,480 --> 00:22:40,400
don't even see hello bird and probably

584
00:22:40,400 --> 00:22:42,080
you don't i'm not sure if you see it but

585
00:22:42,080 --> 00:22:44,960
there is an age which can help but in in

586
00:22:44,960 --> 00:22:46,400
general

587
00:22:46,400 --> 00:22:48,400
it's it's much bigger mess it's not that

588
00:22:48,400 --> 00:22:50,720
easy to read so

589
00:22:50,720 --> 00:22:52,159
but when you take a

590
00:22:52,159 --> 00:22:54,640
closer look then you will find an

591
00:22:54,640 --> 00:22:56,480
address uh

592
00:22:56,480 --> 00:22:59,440
which is uh move to a register and if

593
00:22:59,440 --> 00:23:00,880
you follow that you will see that there

594
00:23:00,880 --> 00:23:02,159
is hello bird

595
00:23:02,159 --> 00:23:04,400
this is how it looks like when it does

596
00:23:04,400 --> 00:23:06,159
it's not defined within githra these are

597
00:23:06,159 --> 00:23:08,159
just sequence of bytes but it doesn't

598
00:23:08,159 --> 00:23:11,520
realize that it's a string and then uh

599
00:23:11,520 --> 00:23:14,640
there is an integer uh moved

600
00:23:14,640 --> 00:23:15,840
to

601
00:23:15,840 --> 00:23:17,840
the stack and this is the length so

602
00:23:17,840 --> 00:23:19,600
basically this is how the string

603
00:23:19,600 --> 00:23:20,960
structure

604
00:23:20,960 --> 00:23:22,799
is built up

605
00:23:22,799 --> 00:23:23,840
during

606
00:23:23,840 --> 00:23:24,960
runtime

607
00:23:24,960 --> 00:23:26,400
and

608
00:23:26,400 --> 00:23:28,799
now we will take a look at the x86 and

609
00:23:28,799 --> 00:23:29,919
then

610
00:23:29,919 --> 00:23:31,360
the arm

611
00:23:31,360 --> 00:23:33,360
architectures so

612
00:23:33,360 --> 00:23:35,440
here what our script is doing it will

613
00:23:35,440 --> 00:23:38,080
look for these specific instructions

614
00:23:38,080 --> 00:23:40,400
these instruction sequences so here for

615
00:23:40,400 --> 00:23:43,279
example first the

616
00:23:43,279 --> 00:23:45,679
string address is moved into registers

617
00:23:45,679 --> 00:23:48,000
register and then placed onto a stack

618
00:23:48,000 --> 00:23:50,960
and then a string string size is placed

619
00:23:50,960 --> 00:23:53,360
onto the stack and that's the same for

620
00:23:53,360 --> 00:23:55,840
32-bit and 64-bit almost

621
00:23:55,840 --> 00:23:57,279
it works the same

622
00:23:57,279 --> 00:23:58,880
and uh

623
00:23:58,880 --> 00:24:01,760
so if after we execute the script what

624
00:24:01,760 --> 00:24:03,200
happens that

625
00:24:03,200 --> 00:24:04,400
the hello

626
00:24:04,400 --> 00:24:06,880
world string will be defined by guidera

627
00:24:06,880 --> 00:24:08,640
so you can you will be able to find it

628
00:24:08,640 --> 00:24:10,559
among the strings within the define

629
00:24:10,559 --> 00:24:12,960
strings window and also if you follow

630
00:24:12,960 --> 00:24:15,760
the address to the string then you it

631
00:24:15,760 --> 00:24:17,200
will be nicely visible it's not just

632
00:24:17,200 --> 00:24:19,039
sequence of bytes but nicely there is

633
00:24:19,039 --> 00:24:21,360
hello world and when you read the code

634
00:24:21,360 --> 00:24:23,760
there is already in the middle the hello

635
00:24:23,760 --> 00:24:26,240
world string so it's much easier to

636
00:24:26,240 --> 00:24:28,720
guess what's going on there

637
00:24:28,720 --> 00:24:31,039
and

638
00:24:31,039 --> 00:24:32,559
for example if you look at again the

639
00:24:32,559 --> 00:24:35,520
acrylics transformer example

640
00:24:35,520 --> 00:24:38,000
in the beginning we had more than 9000

641
00:24:38,000 --> 00:24:40,080
strings now we have even more so this

642
00:24:40,080 --> 00:24:42,240
season didn't help in the problem that

643
00:24:42,240 --> 00:24:44,000
how to find interesting strings when we

644
00:24:44,000 --> 00:24:47,120
have 11 000 strings but at least when we

645
00:24:47,120 --> 00:24:50,320
read the code then for example here it

646
00:24:50,320 --> 00:24:52,320
you can see that readme for

647
00:24:52,320 --> 00:24:54,080
decrypt.txt

648
00:24:54,080 --> 00:24:56,480
so that again something that will help

649
00:24:56,480 --> 00:24:58,960
by just looking at the functions and

650
00:24:58,960 --> 00:25:01,840
like grab some idea what is going on

651
00:25:01,840 --> 00:25:04,000
there

652
00:25:04,000 --> 00:25:06,159
and um

653
00:25:06,159 --> 00:25:08,799
let's move to the arm version

654
00:25:08,799 --> 00:25:12,080
i will show two examples here as well it

655
00:25:12,080 --> 00:25:15,440
it looks very similar so first

656
00:25:15,440 --> 00:25:17,679
there is one extra step because there is

657
00:25:17,679 --> 00:25:21,039
a string address pointer which is uh

658
00:25:21,039 --> 00:25:24,240
moved to the move the register

659
00:25:24,240 --> 00:25:26,640
but then it will also move to the stack

660
00:25:26,640 --> 00:25:29,200
along with the string size so what you

661
00:25:29,200 --> 00:25:30,880
can see here that if you follow follow

662
00:25:30,880 --> 00:25:32,720
the address then there is a pointer

663
00:25:32,720 --> 00:25:35,120
which will point to this to the address

664
00:25:35,120 --> 00:25:36,000
of the

665
00:25:36,000 --> 00:25:39,840
string which is not defined and then

666
00:25:39,840 --> 00:25:42,240
once we execute the script the

667
00:25:42,240 --> 00:25:44,400
disassembler we will be much nicer

668
00:25:44,400 --> 00:25:46,720
because you can write cc there

669
00:25:46,720 --> 00:25:49,520
do not remove this file and whatever the

670
00:25:49,520 --> 00:25:53,200
text itself and also it will be defined

671
00:25:53,200 --> 00:25:54,720
and

672
00:25:54,720 --> 00:25:58,159
if we look at the arm

673
00:25:58,159 --> 00:26:00,480
64-bit example so what this is what i

674
00:26:00,480 --> 00:26:02,080
have already said that there are

675
00:26:02,080 --> 00:26:04,159
differences between different

676
00:26:04,159 --> 00:26:06,559
architectures and also here there are

677
00:26:06,559 --> 00:26:09,200
differences even even within one so for

678
00:26:09,200 --> 00:26:11,440
example these uh two

679
00:26:11,440 --> 00:26:12,960
sequences of instructions are very

680
00:26:12,960 --> 00:26:15,840
similar they are doing the same but

681
00:26:15,840 --> 00:26:19,200
there is in the first one the or

682
00:26:19,200 --> 00:26:20,960
instruction while there is a move in the

683
00:26:20,960 --> 00:26:23,360
second one but the idea is the same

684
00:26:23,360 --> 00:26:25,440
everything will be placed on the stack

685
00:26:25,440 --> 00:26:28,400
and if we find these uh instructions

686
00:26:28,400 --> 00:26:29,440
then

687
00:26:29,440 --> 00:26:32,240
basically we will be able to recover all

688
00:26:32,240 --> 00:26:34,159
the strings

689
00:26:34,159 --> 00:26:36,000
that we were looking for so this is a

690
00:26:36,000 --> 00:26:39,039
for example a kaiji example and then

691
00:26:39,039 --> 00:26:40,880
you can see how

692
00:26:40,880 --> 00:26:43,520
the code looks like after we

693
00:26:43,520 --> 00:26:45,440
recover the strings

694
00:26:45,440 --> 00:26:46,880
and

695
00:26:46,880 --> 00:26:48,320
here

696
00:26:48,320 --> 00:26:50,720
there were there are several challenges

697
00:26:50,720 --> 00:26:52,640
so first of all we have to write it for

698
00:26:52,640 --> 00:26:53,520
every

699
00:26:53,520 --> 00:26:56,240
different architecture

700
00:26:56,240 --> 00:26:58,640
and as you have seen there are different

701
00:26:58,640 --> 00:27:00,640
solutions within one architecture and

702
00:27:00,640 --> 00:27:02,960
it's very easy to break intentionally so

703
00:27:02,960 --> 00:27:04,880
you just

704
00:27:04,880 --> 00:27:06,960
do it something a little bit other way

705
00:27:06,960 --> 00:27:09,840
around and then our script won't work

706
00:27:09,840 --> 00:27:14,400
and uh now from goal 1.17

707
00:27:14,400 --> 00:27:15,200
uh

708
00:27:15,200 --> 00:27:16,960
there is a new so what you have seen

709
00:27:16,960 --> 00:27:18,880
that everything was always placed onto

710
00:27:18,880 --> 00:27:21,679
the stack and this is uh

711
00:27:21,679 --> 00:27:24,799
very unusual that how go handle these

712
00:27:24,799 --> 00:27:27,600
arguments and written return values for

713
00:27:27,600 --> 00:27:29,760
of a function everything was always

714
00:27:29,760 --> 00:27:31,360
placed onto the stack instead of

715
00:27:31,360 --> 00:27:34,880
registers how we used to see it uh but

716
00:27:34,880 --> 00:27:36,960
they changed it for goal point uh goal

717
00:27:36,960 --> 00:27:40,000
1.17 and now they also use the registers

718
00:27:40,000 --> 00:27:42,720
instead of the stack so we also have to

719
00:27:42,720 --> 00:27:45,600
uh consider that but every malware

720
00:27:45,600 --> 00:27:47,919
families that we have seen so far they

721
00:27:47,919 --> 00:27:51,840
obviously didn't updated to go 1.17 yet

722
00:27:51,840 --> 00:27:54,399
but still we have to uh

723
00:27:54,399 --> 00:27:55,679
be able to

724
00:27:55,679 --> 00:27:57,360
change our script in a way that it will

725
00:27:57,360 --> 00:28:00,840
detect these even when we see a newer

726
00:28:00,840 --> 00:28:04,000
sample so this was the dynamically

727
00:28:04,000 --> 00:28:06,159
allocated part and there is this

728
00:28:06,159 --> 00:28:09,039
probably much easier part the statically

729
00:28:09,039 --> 00:28:11,440
allocated strength structure so what's

730
00:28:11,440 --> 00:28:14,320
uh going on here it's basically there is

731
00:28:14,320 --> 00:28:16,880
a part within the

732
00:28:16,880 --> 00:28:20,240
binary where the addresses are placed of

733
00:28:20,240 --> 00:28:23,279
the the string pointers followed by the

734
00:28:23,279 --> 00:28:25,520
length so these structures which i have

735
00:28:25,520 --> 00:28:27,279
shown in the beginning this just simply

736
00:28:27,279 --> 00:28:29,760
there within the memory

737
00:28:29,760 --> 00:28:32,799
and here to eliminate false positives we

738
00:28:32,799 --> 00:28:34,080
limited the

739
00:28:34,080 --> 00:28:36,559
string length so we didn't look for any

740
00:28:36,559 --> 00:28:39,440
integer and also we only search for

741
00:28:39,440 --> 00:28:41,120
printable characters

742
00:28:41,120 --> 00:28:44,080
and only checked it for in specific

743
00:28:44,080 --> 00:28:46,880
sections it is not architecture specific

744
00:28:46,880 --> 00:28:48,880
so what we were what we are looking for

745
00:28:48,880 --> 00:28:50,960
here is we look for an address followed

746
00:28:50,960 --> 00:28:52,880
by an integer and if we find something

747
00:28:52,880 --> 00:28:55,440
like that then we will try to create a

748
00:28:55,440 --> 00:28:57,520
string there so if you

749
00:28:57,520 --> 00:29:00,159
follow this um

750
00:29:00,159 --> 00:29:02,480
example here the first pointer was

751
00:29:02,480 --> 00:29:04,880
successfully defined since it is

752
00:29:04,880 --> 00:29:06,640
directly referenced from the code but it

753
00:29:06,640 --> 00:29:08,480
is followed by a length and then another

754
00:29:08,480 --> 00:29:11,279
pointer and the length and pointer but

755
00:29:11,279 --> 00:29:14,399
videra just didn't realize what uh those

756
00:29:14,399 --> 00:29:15,360
are

757
00:29:15,360 --> 00:29:17,919
so if we take a look at the address we

758
00:29:17,919 --> 00:29:20,000
can see that there are different

759
00:29:20,000 --> 00:29:21,919
extensions so yeah this is the acrylics

760
00:29:21,919 --> 00:29:23,760
transformer again so these are file

761
00:29:23,760 --> 00:29:25,520
extensions that we would expect from a

762
00:29:25,520 --> 00:29:27,679
ransomware so what it is it can encrypt

763
00:29:27,679 --> 00:29:29,600
or what it won't encrypt

764
00:29:29,600 --> 00:29:31,360
and um

765
00:29:31,360 --> 00:29:33,760
once we execute the script all these

766
00:29:33,760 --> 00:29:36,320
pointers will be created also the

767
00:29:36,320 --> 00:29:39,039
integer data type will be created and

768
00:29:39,039 --> 00:29:41,039
all the strings will be defined so you

769
00:29:41,039 --> 00:29:43,279
can see it on the define strings window

770
00:29:43,279 --> 00:29:46,480
and also you can

771
00:29:46,559 --> 00:29:48,960
take a look at it and search for those

772
00:29:48,960 --> 00:29:50,399
easily

773
00:29:50,399 --> 00:29:52,000
and

774
00:29:52,000 --> 00:29:53,520
so what are the

775
00:29:53,520 --> 00:29:54,960
issues here

776
00:29:54,960 --> 00:29:57,360
those two very easily solvable things so

777
00:29:57,360 --> 00:29:59,279
our script will look only for printable

778
00:29:59,279 --> 00:30:01,520
characters are as i mentioned but it's a

779
00:30:01,520 --> 00:30:03,200
very easy part of the code so if you

780
00:30:03,200 --> 00:30:06,399
need anything else for your um

781
00:30:06,399 --> 00:30:08,960
research then you can just easily change

782
00:30:08,960 --> 00:30:11,120
that part and also we limited the length

783
00:30:11,120 --> 00:30:14,000
to i guess 100 now but it's it can

784
00:30:14,000 --> 00:30:15,600
happen that you're looking for a larger

785
00:30:15,600 --> 00:30:17,919
string so you can play with it in a way

786
00:30:17,919 --> 00:30:19,520
to find the best

787
00:30:19,520 --> 00:30:22,240
for your uh project and also don't get

788
00:30:22,240 --> 00:30:24,880
too many false positives

789
00:30:24,880 --> 00:30:26,000
uh

790
00:30:26,000 --> 00:30:28,000
and just

791
00:30:28,000 --> 00:30:30,720
some side step from go

792
00:30:30,720 --> 00:30:32,240
uh this uh

793
00:30:32,240 --> 00:30:33,679
this statically allocated string

794
00:30:33,679 --> 00:30:36,399
structure is not only uh

795
00:30:36,399 --> 00:30:37,200
in

796
00:30:37,200 --> 00:30:38,720
it is something that we can observe in

797
00:30:38,720 --> 00:30:41,360
other languages as well so for example

798
00:30:41,360 --> 00:30:44,080
uh other than go we also seen some other

799
00:30:44,080 --> 00:30:46,000
families written in

800
00:30:46,000 --> 00:30:48,880
in rust recently mainly for windows

801
00:30:48,880 --> 00:30:52,480
and for us it it is the same so

802
00:30:52,480 --> 00:30:54,000
statically

803
00:30:54,000 --> 00:30:56,080
allocated string structures can be found

804
00:30:56,080 --> 00:30:59,600
so the same idea can also be applied to

805
00:30:59,600 --> 00:31:02,080
rust binaries because they handle

806
00:31:02,080 --> 00:31:04,880
strings the same very similar way to go

807
00:31:04,880 --> 00:31:06,320
so you can also look for these

808
00:31:06,320 --> 00:31:08,000
structures the only thing that you have

809
00:31:08,000 --> 00:31:10,640
to consider in which sections to look

810
00:31:10,640 --> 00:31:13,039
for these but this is just

811
00:31:13,039 --> 00:31:15,120
some note

812
00:31:15,120 --> 00:31:16,159
and

813
00:31:16,159 --> 00:31:18,320
here i would also like to show some of

814
00:31:18,320 --> 00:31:20,960
the challenges that we face the first

815
00:31:20,960 --> 00:31:23,519
one is when we

816
00:31:23,519 --> 00:31:24,960
there are

817
00:31:24,960 --> 00:31:27,360
some already defined data types where we

818
00:31:27,360 --> 00:31:29,679
want to define for example an integer

819
00:31:29,679 --> 00:31:32,480
and what gitra does it usually it uses

820
00:31:32,480 --> 00:31:34,720
these undefined called undefined data

821
00:31:34,720 --> 00:31:36,000
types but it still means that it's

822
00:31:36,000 --> 00:31:38,399
already created so what we need to do

823
00:31:38,399 --> 00:31:41,679
here is if we want to create an integer

824
00:31:41,679 --> 00:31:44,240
there then first we have to remove

825
00:31:44,240 --> 00:31:48,080
the undefined data type and then we can

826
00:31:48,080 --> 00:31:49,039
use

827
00:31:49,039 --> 00:31:51,679
we can create the integers so here for

828
00:31:51,679 --> 00:31:52,799
example

829
00:31:52,799 --> 00:31:54,880
our script would fail because okay i

830
00:31:54,880 --> 00:31:57,840
cannot create here integers and pointers

831
00:31:57,840 --> 00:31:59,279
because there are already something else

832
00:31:59,279 --> 00:32:01,840
there but if we remove first d something

833
00:32:01,840 --> 00:32:03,600
else then it will be

834
00:32:03,600 --> 00:32:05,760
uh easy to create what we need so this

835
00:32:05,760 --> 00:32:07,760
is uh

836
00:32:07,760 --> 00:32:09,840
another example from the acrylics

837
00:32:09,840 --> 00:32:11,919
ransomware how we could

838
00:32:11,919 --> 00:32:15,200
recover certain strings

839
00:32:15,200 --> 00:32:16,159
and

840
00:32:16,159 --> 00:32:19,039
another problem is when the string is

841
00:32:19,039 --> 00:32:21,200
already defined because as i mentioned

842
00:32:21,200 --> 00:32:22,320
how good

843
00:32:22,320 --> 00:32:25,200
go handles the strings they create large

844
00:32:25,200 --> 00:32:27,039
string blobs and this can happen there

845
00:32:27,039 --> 00:32:28,799
is a new character at the end so we'll

846
00:32:28,799 --> 00:32:32,240
give falsely identified as one huge

847
00:32:32,240 --> 00:32:34,000
string instead of

848
00:32:34,000 --> 00:32:37,760
smaller uh separate strings so

849
00:32:37,760 --> 00:32:39,919
what can we do here is

850
00:32:39,919 --> 00:32:42,480
so in this example for exam you can see

851
00:32:42,480 --> 00:32:44,480
that there are many offcut references to

852
00:32:44,480 --> 00:32:47,279
that specific string it means that there

853
00:32:47,279 --> 00:32:50,000
are references to some certain parts of

854
00:32:50,000 --> 00:32:51,840
the string so not the beginning but

855
00:32:51,840 --> 00:32:53,919
somewhere in the middle from the code

856
00:32:53,919 --> 00:32:56,480
so if you find uh in the define uh

857
00:32:56,480 --> 00:32:59,039
strings window what you can do here is

858
00:32:59,039 --> 00:32:59,840
to

859
00:32:59,840 --> 00:33:02,960
sort the strings based on the number of

860
00:33:02,960 --> 00:33:05,039
offcut references and when you see

861
00:33:05,039 --> 00:33:07,279
something with

862
00:33:07,279 --> 00:33:09,200
multiple thousands of offcut references

863
00:33:09,200 --> 00:33:11,200
then you can safely

864
00:33:11,200 --> 00:33:13,360
undefine it and then you will be able to

865
00:33:13,360 --> 00:33:15,519
create the smaller strings so that's

866
00:33:15,519 --> 00:33:17,279
also one step that

867
00:33:17,279 --> 00:33:19,519
we have to consider and this is at the

868
00:33:19,519 --> 00:33:21,919
moment is not

869
00:33:21,919 --> 00:33:24,720
handled by the script itself

870
00:33:24,720 --> 00:33:26,799
but you can do it yourself just to check

871
00:33:26,799 --> 00:33:30,080
the these these specific strings

872
00:33:30,080 --> 00:33:31,200
and

873
00:33:31,200 --> 00:33:33,120
basically these were the two topics that

874
00:33:33,120 --> 00:33:36,159
i wanted to this uh discuss today and uh

875
00:33:36,159 --> 00:33:36,960
just

876
00:33:36,960 --> 00:33:39,760
want to introduce some of the next steps

877
00:33:39,760 --> 00:33:41,200
so of course

878
00:33:41,200 --> 00:33:43,039
working on the string recovery it's a

879
00:33:43,039 --> 00:33:46,159
continuous work so for new architectures

880
00:33:46,159 --> 00:33:48,480
for new versions of gitra for whatever

881
00:33:48,480 --> 00:33:50,240
that's that's something that we have to

882
00:33:50,240 --> 00:33:51,360
consider

883
00:33:51,360 --> 00:33:53,840
as also what i've mentioned that

884
00:33:53,840 --> 00:33:56,480
function return values and arguments are

885
00:33:56,480 --> 00:33:58,080
placed onto the stack

886
00:33:58,080 --> 00:34:00,000
which is um

887
00:34:00,000 --> 00:34:01,200
not

888
00:34:01,200 --> 00:34:03,039
really easy to

889
00:34:03,039 --> 00:34:04,720
get right to handle since these are not

890
00:34:04,720 --> 00:34:09,440
in registers until 1.16 uh it

891
00:34:09,440 --> 00:34:12,320
there is one goal to somehow help guidra

892
00:34:12,320 --> 00:34:14,239
to handle this much better so because

893
00:34:14,239 --> 00:34:16,239
now we cannot really see what are the

894
00:34:16,239 --> 00:34:18,399
arguments what is the output of a

895
00:34:18,399 --> 00:34:21,440
function so it's a it's a huge mess but

896
00:34:21,440 --> 00:34:23,918
even now that um these are moved to the

897
00:34:23,918 --> 00:34:26,480
registers it's not perfect so there are

898
00:34:26,480 --> 00:34:28,879
room for uh improvement

899
00:34:28,879 --> 00:34:30,639
and um

900
00:34:30,639 --> 00:34:33,839
another interesting feature is in go is

901
00:34:33,839 --> 00:34:35,918
like types like the string structure

902
00:34:35,918 --> 00:34:37,119
that i have

903
00:34:37,119 --> 00:34:40,000
mentioned before there are uh

904
00:34:40,000 --> 00:34:42,560
different type descriptions of types

905
00:34:42,560 --> 00:34:44,480
within the binary there are obviously

906
00:34:44,480 --> 00:34:46,960
the built-in basic types and there are

907
00:34:46,960 --> 00:34:48,960
some composite types of that but when

908
00:34:48,960 --> 00:34:51,520
you write

909
00:34:51,520 --> 00:34:55,280
a go script then go program then you can

910
00:34:55,280 --> 00:34:58,079
uh define your own types like in this

911
00:34:58,079 --> 00:35:00,320
example from acrylics there is the main

912
00:35:00,320 --> 00:35:03,440
dot info struct which is which consists

913
00:35:03,440 --> 00:35:06,320
of a public key and the readme string so

914
00:35:06,320 --> 00:35:08,000
and this is also

915
00:35:08,000 --> 00:35:10,480
stored within the binary so it's it is

916
00:35:10,480 --> 00:35:12,560
possible to recover these

917
00:35:12,560 --> 00:35:15,839
which is very helpful when you want to

918
00:35:15,839 --> 00:35:18,000
analyze more deeply or for example to

919
00:35:18,000 --> 00:35:20,240
see what is sent to the c2 server and

920
00:35:20,240 --> 00:35:22,000
there is a structure containing all the

921
00:35:22,000 --> 00:35:24,960
information what needs to be can be sent

922
00:35:24,960 --> 00:35:26,480
or what

923
00:35:26,480 --> 00:35:29,359
can what commands for example botnet can

924
00:35:29,359 --> 00:35:32,480
get from a c2 server

925
00:35:32,480 --> 00:35:33,440
so

926
00:35:33,440 --> 00:35:36,160
before i uh finish my talk just i would

927
00:35:36,160 --> 00:35:38,320
like to mention some other researchers

928
00:35:38,320 --> 00:35:42,560
work uh mainly on in other for other

929
00:35:42,560 --> 00:35:45,760
tools ida pro is pretty good in handling

930
00:35:45,760 --> 00:35:49,920
the goal situation now also for radar uh

931
00:35:49,920 --> 00:35:52,160
there are very very good uh

932
00:35:52,160 --> 00:35:54,800
solutions we work with guidra for that

933
00:35:54,800 --> 00:35:56,480
there were not many that's why we

934
00:35:56,480 --> 00:35:58,880
started it and

935
00:35:58,880 --> 00:36:01,040
these are the files i used during this

936
00:36:01,040 --> 00:36:03,280
presentation so if anyone wants to dive

937
00:36:03,280 --> 00:36:04,400
in

938
00:36:04,400 --> 00:36:07,040
deeper like just practice grid video i

939
00:36:07,040 --> 00:36:08,320
think these are

940
00:36:08,320 --> 00:36:10,480
perfectly good to start with

941
00:36:10,480 --> 00:36:13,440
some references and nice additional

942
00:36:13,440 --> 00:36:15,599
reading and with all this i would like

943
00:36:15,599 --> 00:36:17,760
you to thank you for your attention you

944
00:36:17,760 --> 00:36:20,960
can find us on twitter also our research

945
00:36:20,960 --> 00:36:22,800
group and you can find all this

946
00:36:22,800 --> 00:36:24,640
everything that i've been talking here

947
00:36:24,640 --> 00:36:27,200
on github so you can use the files and

948
00:36:27,200 --> 00:36:29,440
anything and just feel free to contact

949
00:36:29,440 --> 00:36:31,440
me if you have any questions or anything

950
00:36:31,440 --> 00:36:33,840
else thank you very much

951
00:36:33,840 --> 00:36:36,889
[Applause]

