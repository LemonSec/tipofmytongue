1
00:00:00,000 --> 00:00:14,460
hi everyone I'm going to be talking

2
00:00:15,390 --> 00:00:22,470
about using new features of the modern
CPUs specifically tracing features to

3
00:00:22,470 --> 00:00:28,080
detect malicious files to detect
exploits so we get the interesting part

4
00:00:28,080 --> 00:00:35,099
little bit about us both with offensive
background both no longer dealing in

5
00:00:35,100 --> 00:00:39,660
there inoffensive technologies i work as
an independent security rate a

6
00:00:39,660 --> 00:00:43,559
researcher have been doing mostly
defensive defensive work offensive

7
00:00:43,560 --> 00:00:52,230
research some of you may have read my
bio and the news last night so I did

8
00:00:52,230 --> 00:00:57,480
used to work for nsl but I no longer do
I have been there have been out yourself

9
00:00:57,480 --> 00:01:01,559
about three-and-a-half years I don't
know much about that

10
00:01:02,910 --> 00:01:13,259
ok so what we'll be talking about today
i'll be talking about the project and

11
00:01:13,260 --> 00:01:20,070
the research that we performed during
$MONTH 2015 and the goal of the the talk

12
00:01:20,070 --> 00:01:25,500
will be to walk you through to the
project through my eyes as a developer

13
00:01:25,500 --> 00:01:30,960
through the obstacles encountered and
through the various various solutions we

14
00:01:30,960 --> 00:01:33,179
found the different obstacles

15
00:01:33,180 --> 00:01:37,049
the idea being that eventually after the
stock you should be able to implement

16
00:01:37,049 --> 00:01:41,970
the whole project on your own you won't
have to because we'll be releasing the

17
00:01:41,970 --> 00:01:47,670
cold sometimes when you're 16 but you'll
see all the you see the whole process we

18
00:01:47,670 --> 00:01:51,689
went through a stage by stage are we
starting with the strong small

19
00:01:51,689 --> 00:01:57,329
introduction about what personal grace
is what control-flow integrity is a how

20
00:01:57,329 --> 00:02:02,250
we use it to detect countries are the
types of exploitation and then they will

21
00:02:02,250 --> 00:02:08,639
do a drill down into the different parts
of the project a little bit about the

22
00:02:08,639 --> 00:02:13,410
project itself and developed
independently not affiliated with any

23
00:02:13,410 --> 00:02:19,859
specific company and not sponsored by a
specific company using a new cpu feature

24
00:02:19,860 --> 00:02:24,629
in modern a feature that exists in there
and you cpus called processor trace

25
00:02:25,190 --> 00:02:32,120
a where the the overarching idea is
taking a document and detecting it

26
00:02:32,120 --> 00:02:36,890
contains an exploit the document of some
kind of other content such as the flash

27
00:02:36,890 --> 00:02:43,850
applet or any type of of content that
can be parsed by an application very

28
00:02:43,850 --> 00:02:48,350
simply what we do is we trace the
program we analyze the trace and we

29
00:02:48,350 --> 00:02:52,609
detected the file contains an expert
when I say trace the program i mean we

30
00:02:52,610 --> 00:02:57,170
take for example adobe PDF reader we
give it a PDF we perform a trace and

31
00:02:57,170 --> 00:03:02,329
then we can detect and we can analyze
the strength and detects a xbox

32
00:03:02,330 --> 00:03:07,250
specifically for this project we focus
mostly on the tracing part we want to

33
00:03:07,250 --> 00:03:14,540
provide a framework for control file
integrity implementations and as a as an

34
00:03:14,540 --> 00:03:18,530
example implementation we implemented a
shadow stack right this is a backward

35
00:03:18,530 --> 00:03:24,050
edge see if I method that can detect any
type of of rob corddry of return

36
00:03:24,050 --> 00:03:29,780
oriented programming i will be talking
so much about the theoretical or the

37
00:03:29,780 --> 00:03:35,000
future of exploits where the rock is
dead weather CF is is is the future

38
00:03:35,000 --> 00:03:40,160
stuff like this this is I think better
for offline talks but focusing on this

39
00:03:40,160 --> 00:03:45,739
specific project so when we set out we
had several requirements for the project

40
00:03:45,739 --> 00:03:52,190
highlighted the main ones we wanted this
to work on windows-based the

41
00:03:52,190 --> 00:03:56,660
applications windows based machines
since these are the common enterprise

42
00:03:56,660 --> 00:04:01,820
machines we wanted a full trace of the
program go right so we wanted to trace

43
00:04:01,820 --> 00:04:06,620
every part of the program and be able to
reconstruct the complete flow of water

44
00:04:06,620 --> 00:04:09,709
program does we wanted to be fast

45
00:04:09,709 --> 00:04:13,459
ok we want this to be a practical
solution and we wanted to be

46
00:04:13,459 --> 00:04:18,680
non-intrusive non-intrusive meaning
given an information leak or something

47
00:04:18,680 --> 00:04:23,210
similar and attacking won't be able to
detect that this is being performed a on

48
00:04:23,210 --> 00:04:26,210
a specific application we also don't
want to have any kind of compatibility

49
00:04:26,210 --> 00:04:33,049
issues and when we are not intrusive we
immediately this card that problem there

50
00:04:33,050 --> 00:04:38,810
has been quite a lot of previous work on
on the use of cpu

51
00:04:38,810 --> 00:04:45,889
features to detect exploits this is a
non complete list the work by fudan

52
00:04:45,889 --> 00:04:52,940
university is a big a big part of recent
work and game presented in black at this

53
00:04:52,940 --> 00:04:59,810
year also quite impressive most of these
approaches use what is called the pmu

54
00:04:59,810 --> 00:05:06,620
the performance unit am and the approach
means it's slightly different so it's

55
00:05:06,620 --> 00:05:09,530
not directly related to any of this
previous work but it's sort of in the

56
00:05:09,530 --> 00:05:18,830
same realm so mr. to get a map of where
we are when we talk about the

57
00:05:18,830 --> 00:05:22,700
exploitation process there's different
ways of dividing this but we have the

58
00:05:22,700 --> 00:05:26,210
pre exploitation process we have the
exploitation itself and then everything

59
00:05:26,210 --> 00:05:30,109
that happens after the exploitation we
obviously want to try and stop the

60
00:05:30,110 --> 00:05:34,280
exploiters early as possible cause that
let allows for less wiggle room and less

61
00:05:34,280 --> 00:05:41,690
less place to play for the attacker that
we exploit is pretty hard you have to

62
00:05:41,690 --> 00:05:45,890
have prior knowledge of the expert or
use some kind of heuristic which is why

63
00:05:45,890 --> 00:05:50,599
a lot of work is focusing focuses on the
exploitation stage itself before the

64
00:05:50,600 --> 00:05:55,039
mount working trying to bait but as
early as $YEAR and as early as possible

65
00:05:57,289 --> 00:06:01,190
we're talking about anti exploitation
methods we have the traditional and

66
00:06:01,190 --> 00:06:09,320
exploitation message sets as that is
salar a later Emmett we have emerging

67
00:06:09,320 --> 00:06:14,539
and exploitation measures such as
Microsoft control-flow integrity and

68
00:06:14,539 --> 00:06:16,460
into control your integrity

69
00:06:16,460 --> 00:06:22,340
we have the pmu events i talked about
also nobody knows exactly what will be

70
00:06:22,340 --> 00:06:27,138
with them also emerging and of course
some application-specific and

71
00:06:27,139 --> 00:06:33,590
exploitation methods so so where we are
someone next to the pmu events like this

72
00:06:33,590 --> 00:06:39,530
project talks about a method that far as
i know hasn't been described before and

73
00:06:39,530 --> 00:06:46,219
sit somewhere next to the pmu events
contribute to CFC NCT this is the

74
00:06:46,220 --> 00:06:51,140
non-mainstream company pushing this to
all platforms on the one hand but on the

75
00:06:51,140 --> 00:06:51,830
other hand

76
00:06:51,830 --> 00:06:59,300
it's something immediately apply about
so what is control flow integrity very

77
00:06:59,300 --> 00:07:03,590
simply controller integrity means making
sure the program flows as intended

78
00:07:05,540 --> 00:07:09,950
this is something that has been talked
about a lot but often impractical

79
00:07:09,950 --> 00:07:13,460
impractical because existing ways to do
this

80
00:07:14,030 --> 00:07:21,020
have either been to use compiler based
right intervention in the compiler to

81
00:07:21,020 --> 00:07:25,370
change the calculation tool chain or
dynamic minor instrumentation based both

82
00:07:25,370 --> 00:07:30,500
of these have different types of
disadvantages that make control for

83
00:07:30,500 --> 00:07:36,020
integrity not very practical usually a
few new initiatives looks quite

84
00:07:36,020 --> 00:07:44,120
promising microsoft as I said Intel and
some commercial companies ok to perform

85
00:07:44,120 --> 00:07:48,500
see if I we need to two things we have
to do things well we have to wait to

86
00:07:48,500 --> 00:07:52,310
have a way to get the program flow and
we have to have a model to define how

87
00:07:52,310 --> 00:07:54,320
the program should flow

88
00:07:54,320 --> 00:08:00,140
luckily compilers linkers they write
programs right so people don't programs

89
00:08:00,140 --> 00:08:03,740
compilers write programs so we can
assume all kinds of truths about

90
00:08:03,740 --> 00:08:08,540
programs such as functions should return
to their color right people don't have

91
00:08:08,540 --> 00:08:16,190
to write software that way but compilers
well usually write software that way the

92
00:08:16,190 --> 00:08:21,530
main focus of this talk and the main
focus of the project itself is how to

93
00:08:21,530 --> 00:08:26,030
get the program flow right because once
you have the program flow this is the

94
00:08:26,030 --> 00:08:29,239
the technologically challenging part
after this there are many theoretical

95
00:08:29,240 --> 00:08:35,240
implementations of cfi forwards
backwards different types of analysis

96
00:08:35,240 --> 00:08:39,680
that can be performed so the focus is
how do we get program flow in a

97
00:08:39,679 --> 00:08:46,370
practical non-intrusive manner as i said
on a windows machine come in inter

98
00:08:46,370 --> 00:08:53,180
process or trace really cool future
feature it traces every instruction a

99
00:08:53,180 --> 00:08:59,959
cpu execute in real-time it traces it to
memory buffer and can be enabled by

100
00:08:59,960 --> 00:09:01,089
software

101
00:09:01,089 --> 00:09:04,689
a compressed race which means we don't
have to deal with gigabytes of memory

102
00:09:04,689 --> 00:09:10,629
unless we have a very long trace low
overhead documentation says I percent

103
00:09:10,629 --> 00:09:15,009
for up to five percent in effect it's
actually quite a lot lower because

104
00:09:15,009 --> 00:09:19,660
application spend a lot of time and I Oh
user interaction stuff like that so it's

105
00:09:19,660 --> 00:09:23,079
actually just five percent overhead on
actual CPU execution

106
00:09:23,079 --> 00:09:29,349
I think this has improved its latest the
latest models of cpus and very

107
00:09:29,350 --> 00:09:33,430
importantly it supports filtering by
process it doesn't allow a lot of

108
00:09:33,430 --> 00:09:40,239
operating system context but it does
allow filtering by the CR three register

109
00:09:40,240 --> 00:09:47,709
a available but starting within 2 15
cpus it's the successor the branch great

110
00:09:47,709 --> 00:09:52,899
storage i say successor because it's a
similar feature but they're actually

111
00:09:52,899 --> 00:09:56,199
very different the brand straight
storage would make a program run 40

112
00:09:56,199 --> 00:10:01,449
times slower while until PT processor
Grace has a five percent overhead which

113
00:10:01,449 --> 00:10:07,449
is very very different also put a star
next to available in 215 CP is because

114
00:10:07,449 --> 00:10:12,399
if you read the documentation carefully
you might deduce that it has been

115
00:10:12,399 --> 00:10:16,540
available before but wasn't documented I
don't actually know if this is true but

116
00:10:16,540 --> 00:10:21,370
it seems to be the case when leaving the
convention so how do we use

117
00:10:21,370 --> 00:10:26,170
inter-process or trace to detect
detective malicious file detective

118
00:10:26,170 --> 00:10:31,748
extract in very simple words to try to
give this every instruction in the

119
00:10:31,749 --> 00:10:35,980
program analysis of the program gives us
the control model which we should be

120
00:10:35,980 --> 00:10:42,129
watching for for example every function
should be returning to its color we can

121
00:10:42,129 --> 00:10:46,689
verify that the program does as it is
intended to do and does not do things

122
00:10:46,689 --> 00:10:53,379
that it is not intended to do and we
detect malicious files

123
00:10:53,379 --> 00:10:56,740
okay so obviously it's not that simple

124
00:10:56,740 --> 00:11:04,059
several several different challenges
that we have to overcome first is how we

125
00:11:04,059 --> 00:11:08,920
analyze for so trace how do we handle
models and threads do functions always

126
00:11:08,920 --> 00:11:14,250
return to their color if they don't have
we handle this doesn't opt even work

127
00:11:14,250 --> 00:11:19,920
the question is up there then it
probably doesn't always work and the

128
00:11:19,920 --> 00:11:25,260
major obstacle the major challenge of
analyzing processor place is how long it

129
00:11:25,260 --> 00:11:25,980
takes

130
00:11:25,980 --> 00:11:32,070
you'll see that there was quite a lot of
effort put into this so how do we

131
00:11:32,070 --> 00:11:37,380
analyze the trace that the format is
compressed and it only contains

132
00:11:37,380 --> 00:11:41,189
information that has to be contained
within the former and so it assumes a

133
00:11:41,190 --> 00:11:46,410
memory map of the program this means
when you analyze the trace you have to

134
00:11:46,410 --> 00:11:51,270
have the disassembly that was running
have to have the exact memory a la and

135
00:11:51,270 --> 00:11:56,460
the exact fights in every address of
memory while the program was traced so

136
00:11:56,460 --> 00:12:01,740
you take a memory map you take the trace
data you disassemble the memory map and

137
00:12:01,740 --> 00:12:05,340
you have the program flow this is the
general architecture of her dress is

138
00:12:05,340 --> 00:12:06,270
performed

139
00:12:06,270 --> 00:12:10,410
it's based on nine different packet
types

140
00:12:10,410 --> 00:12:15,060
we're not going to go into each and
every one of the packet types to our of

141
00:12:15,060 --> 00:12:21,300
of more importance and are basically the
packets used to perform trace these are

142
00:12:21,300 --> 00:12:26,550
the TNT packets and the tip pocket TNT
packet is a is a packet that will tell

143
00:12:26,550 --> 00:12:33,420
us for every conditional branch whether
the branch was taken or not taken

144
00:12:33,420 --> 00:12:37,410
everything else as i said we can deduce
from the assembly right of the branch

145
00:12:37,410 --> 00:12:41,310
was taken we can deduce the next address
from the disassembly and the tip packet

146
00:12:41,310 --> 00:12:45,060
which does the next address for every
instruction for which we cannot

147
00:12:45,060 --> 00:12:50,880
determine the next the next address why
did he have a phone call call the ax or

148
00:12:50,880 --> 00:12:54,420
call for memory address or something of
the sort we can't determine the next day

149
00:12:54,420 --> 00:13:05,219
the next address and so we need a packet
to tell us what the what the next

150
00:13:05,220 --> 00:13:11,190
additive ok

151
00:13:11,950 --> 00:13:17,290
this is what the packets look like once
again we're not going to go into too

152
00:13:17,290 --> 00:13:22,990
much detail a tip packet contains the
tip signature followed by an address

153
00:13:22,990 --> 00:13:33,910
very simple and a the TNT packet
contains a number of bits each bits

154
00:13:33,910 --> 00:13:39,040
corresponding to one conditional branch
right so every bit will be either one or

155
00:13:39,040 --> 00:13:44,260
zero and this will tell us if the branch
was taken or not taken pretty simple you

156
00:13:44,260 --> 00:13:47,800
can also see that the tip packets have a
length this is a method of compression

157
00:13:47,800 --> 00:13:52,780
if the target for somebody to the target
are the same as the previous address

158
00:13:52,780 --> 00:14:02,890
they will be omitted to save space so
okay I'm gonna guard this how do we

159
00:14:02,890 --> 00:14:08,740
analyze the trace we take a start
address the trace the entropy trace

160
00:14:08,740 --> 00:14:12,520
gives us a start address and we start by
disassembling we disassembled and

161
00:14:12,520 --> 00:14:16,720
instruction and we check if the
instruction is an indirect branch and

162
00:14:16,720 --> 00:14:20,530
indirect branch or far branch any brand
for which we do not know the next

163
00:14:20,530 --> 00:14:25,600
address interrupt will also fall into
this category returns would also fall

164
00:14:25,600 --> 00:14:30,430
into this category so if this
instruction is an indirect branch we

165
00:14:30,430 --> 00:14:35,079
look at the next tip and we go back and
disassemble if this instruction is not

166
00:14:35,080 --> 00:14:39,520
an indirect branch but it is a
conditional branch we look at the TNT

167
00:14:39,520 --> 00:14:44,890
bits and if the TNT bit is set we
calculate the next address space under

168
00:14:44,890 --> 00:14:49,600
this i'm going to go back to this
assembly if the TNT bit is not set we

169
00:14:49,600 --> 00:14:56,080
simply continue to disassemble so very
simple naive implementation this is the

170
00:14:56,080 --> 00:15:03,910
by-the-book way of analyzing into
post-race ok next we have to deal with

171
00:15:03,910 --> 00:15:08,079
models as i said we need a memory mapped
to perform this assembly we need to know

172
00:15:08,080 --> 00:15:11,260
what we have a date address in order to
be able to perform that this assembly

173
00:15:11,260 --> 00:15:20,020
step however obviously the memory map in
any more than operating system does not

174
00:15:20,020 --> 00:15:23,250
stay constant throughout the the life of
a program

175
00:15:23,250 --> 00:15:27,030
a models get loaded and unloaded often
they get loaded and unloaded at the same

176
00:15:27,030 --> 00:15:32,160
addresses or an overlapping addresses
and so we have to have a way to a get

177
00:15:32,160 --> 00:15:37,680
model loading and unloading and be sink
model and loading and loading to the

178
00:15:37,680 --> 00:15:45,449
trace so is the BTW event racing for
windows api quite an athlete API to use

179
00:15:45,450 --> 00:15:52,440
one of the Atlas the microsoft was
produced in order to get more loading

180
00:15:52,440 --> 00:15:56,670
and unloading and the trace itself in
order to sink the model loads and

181
00:15:56,670 --> 00:16:02,640
unloads between the trace and a and the
model loading and unloading so we

182
00:16:02,640 --> 00:16:06,870
actually can see every time the crease
reaches and anti load library or similar

183
00:16:06,870 --> 00:16:12,750
functions that cause of the loading and
then we can load the required required

184
00:16:12,750 --> 00:16:18,570
model into memory which we have on disk
that's about it

185
00:16:18,570 --> 00:16:22,950
this is a screenshot of what model
loading and unloading looks timestamps

186
00:16:22,950 --> 00:16:28,080
of the loaded models and the names
addresses and names of the loaded models

187
00:16:28,080 --> 00:16:35,190
you might see some of those appearing
price twice because they might get

188
00:16:35,190 --> 00:16:35,730
loaded

189
00:16:35,730 --> 00:16:38,940
well this is the big this part of a
program but sometimes you can see the

190
00:16:38,940 --> 00:16:42,060
same although being loaded twice because
it gets unloaded and reloaded a

191
00:16:42,060 --> 00:16:46,140
different addresses so we take this and
we think it with the trace based on the

192
00:16:46,140 --> 00:16:51,360
trace information itself on the address
on under the program reaching any load

193
00:16:51,360 --> 00:16:55,800
library there's no need to sync the
unloads since every time we perform a

194
00:16:55,800 --> 00:17:01,260
load we perform all the previous and
loads methods we also need to be able to

195
00:17:01,260 --> 00:17:04,530
handle threads and they said into a
processor Chris does not have any

196
00:17:04,530 --> 00:17:09,209
operating system context information and
we want to reconstruct the flow of the

197
00:17:09,209 --> 00:17:13,020
separate set of threads the separately
obviously we also want to have a shadows

198
00:17:13,020 --> 00:17:18,119
back to know if we returned to the
correct address after every function and

199
00:17:18,119 --> 00:17:23,280
for this we also need to have em to
reconstruct the airflow specific threads

200
00:17:23,280 --> 00:17:30,270
so there's a few approaches how this can
be done we attempted event racing for

201
00:17:30,270 --> 00:17:35,220
windows as one approach time stamps were
not correct enough in the trace I

202
00:17:35,220 --> 00:17:38,610
believe maybe in 6-10 cpus they'll be
better

203
00:17:38,610 --> 00:17:44,850
there's some enhanced features enhanced
I'm features but we ended up doing is

204
00:17:44,850 --> 00:17:50,580
using a lightweight driver hooking
context which is in the colonel and then

205
00:17:50,580 --> 00:17:59,250
using a more exact time stamps to sink
this with the trace i have seen other

206
00:17:59,250 --> 00:18:04,020
approaches specifically using a pc
methods using a pc methods to every

207
00:18:04,020 --> 00:18:08,580
thread all the time and then thinking on
the execution of the specific APC thread

208
00:18:08,580 --> 00:18:14,520
on Windows some advantages and
disadvantages to that kind of approach

209
00:18:14,520 --> 00:18:26,820
so when we want to to analyze and opt
you can see that until supplies quite a

210
00:18:26,820 --> 00:18:34,649
lot of support this linux support in the
colonel in perfect in gdb for inter PT

211
00:18:34,650 --> 00:18:40,980
mostly written by intel or some Intel
affiliated people from open source

212
00:18:40,980 --> 00:18:47,760
libraries such as live ipt for analyzing
pursuit race that is a disassembler

213
00:18:47,760 --> 00:18:53,400
until disassembler that can be used to
make sense i never knew until had

214
00:18:53,400 --> 00:18:58,530
assembled it doesn't make sense and both
of these are our free software more or

215
00:18:58,530 --> 00:19:04,560
less until also went to the trouble of
combining these two of taking the apt

216
00:19:04,560 --> 00:19:10,770
and said and creating what is called PT
then is the simple open source analysis

217
00:19:10,770 --> 00:19:13,770
engine for

218
00:19:16,880 --> 00:19:22,040
for in the process or trace it seems the
static memory map and a single-threaded

219
00:19:22,040 --> 00:19:30,110
application but it sort of works this is
the output of PD said so it is not the

220
00:19:30,110 --> 00:19:35,330
output of people that actually this is
the output of pd dump this is just a

221
00:19:35,330 --> 00:19:41,240
representation of the packets the trace
packets you can see the exclamation

222
00:19:41,240 --> 00:19:45,500
marks and dots at the TNT packets right
sort of Reclamation back mark is a taken

223
00:19:45,500 --> 00:19:50,210
branch and every dollars are not taken
branch and the tip packets have an

224
00:19:50,210 --> 00:19:53,480
address in them

225
00:19:53,480 --> 00:20:00,290
ok now some numbers obviously because
that is not so robust enough to to

226
00:20:00,290 --> 00:20:04,070
analyze a real application which is
multi-threaded and has a non-static

227
00:20:04,070 --> 00:20:11,179
memory map but we want to know if it's
fast enough so take adobe acrobat any

228
00:20:11,180 --> 00:20:19,310
version and the large PDF file and trace
the parting of that file several hundred

229
00:20:19,310 --> 00:20:21,440
megabyte race which doesn't sound so bad

230
00:20:21,440 --> 00:20:26,300
unfortunately run PT that on this fine
you get 27 miles of analysis i say

231
00:20:26,300 --> 00:20:29,780
several hours it might be days I've
never actually seen this finish never

232
00:20:29,780 --> 00:20:35,000
tried because obviously several hours is
not very practical

233
00:20:37,040 --> 00:20:43,220
now it is we're saying that until fixed
n cpus support range based racing so you

234
00:20:43,220 --> 00:20:47,030
can have a blacklist or white based on
the or whitelist on the trace itself

235
00:20:47,030 --> 00:20:53,180
this behalf would save us time it didn't
exist at the time and be it would sort

236
00:20:53,180 --> 00:20:57,020
of undermine the the requirement of full
visibility into the program so if we

237
00:20:57,020 --> 00:21:02,450
only trace part of the program somebody
could perform rock on increased and

238
00:21:02,450 --> 00:21:09,710
taste models optimization so so this was
a big big thing for the project we

239
00:21:09,710 --> 00:21:13,910
managed to bring down the analysis from
hours to seconds using some optimization

240
00:21:13,910 --> 00:21:19,430
optimization methods effectively making
the analysis practical right so this is

241
00:21:19,430 --> 00:21:26,390
the the main obstacle everything else
can be can be overcome but we do want to

242
00:21:26,390 --> 00:21:28,310
analyze files fast enough

243
00:21:28,310 --> 00:21:29,750
ok

244
00:21:29,750 --> 00:21:33,710
so the the main thing we noticed and and
this is pretty straightforward is that

245
00:21:33,710 --> 00:21:35,360
molecule is static

246
00:21:35,360 --> 00:21:38,300
we can also notice that we're not
interested in this assembly most up

247
00:21:38,300 --> 00:21:42,409
codes right if you have a move-up code
this does not affect the flow if you

248
00:21:42,410 --> 00:21:47,810
have an ad up call this does not affect
the flow we only want to look at that

249
00:21:47,810 --> 00:21:52,700
branch creating opcodes right we want to
look at call we want to look at jump you

250
00:21:52,700 --> 00:21:56,090
want to look at return to Center stuff
like that

251
00:21:56,090 --> 00:22:01,310
ok and so we only need the last
instruction of every basic look we don't

252
00:22:01,310 --> 00:22:10,730
need to disassemble is there any way of
making its not flow itself it can it

253
00:22:10,730 --> 00:22:12,680
which is life

254
00:22:12,680 --> 00:22:20,450
yeah system so it's probably my problem
apartments

255
00:22:20,450 --> 00:22:23,690
ok ok so we only need the last
instruction of every basic block

256
00:22:24,740 --> 00:22:28,070
unfortunately we can't find the last
interaction with actually disassembling

257
00:22:28,070 --> 00:22:31,250
all the other instructions right
basically don't just have their last

258
00:22:31,250 --> 00:22:35,630
instruction embedded inside the first
instruction and so we have to pre

259
00:22:35,630 --> 00:22:37,910
analyze the basic blocks okay

260
00:22:37,910 --> 00:22:41,840
every basic block contains at most one
branch and so we can pre analyze the

261
00:22:41,840 --> 00:22:46,550
basic blocks and somehow use this
information to faster to analyze the

262
00:22:46,550 --> 00:22:47,990
trace faster

263
00:22:47,990 --> 00:22:51,620
ok we're essentially making a graph of
the code or graph of the basic blocks

264
00:22:51,620 --> 00:22:56,120
and then we traverse the graph we have a
basic block we look at the taken not

265
00:22:56,120 --> 00:23:02,030
taken bit or the tip it and we know what
the next basic look to look at is this

266
00:23:02,030 --> 00:23:03,200
can be done offline

267
00:23:03,200 --> 00:23:06,680
thanks a bunch of time but it can be
done offline and we can use this

268
00:23:06,680 --> 00:23:13,370
information in order to trace in
real-time much faster and a Python

269
00:23:13,370 --> 00:23:20,209
script / python this is what the output
looks like a bunch of basic looks with

270
00:23:20,210 --> 00:23:24,110
the addresses the length of their
characteristics etc

271
00:23:24,110 --> 00:23:29,929
unfortunately this is not perfect it's
not perfect because I to make some

272
00:23:29,930 --> 00:23:34,580
mistakes it's not perfect because some
programs like to perform all kinds of

273
00:23:34,580 --> 00:23:40,669
and reversing tricks and jump into the
middle of up codes and we have to have

274
00:23:40,670 --> 00:23:43,030
this perfect right so if we missed
analyst

275
00:23:43,030 --> 00:23:46,660
I've a certain basic block and we don't
have it in the graph for the graph is

276
00:23:46,660 --> 00:23:47,680
incorrect

277
00:23:47,680 --> 00:23:51,550
we're not only missing code we can no
longer perform the analysis this breaks

278
00:23:51,550 --> 00:23:55,930
the state of the analyzer and we have to
have a perfect graph in order for this

279
00:23:55,930 --> 00:23:59,800
to work order for this to work like this

280
00:23:59,800 --> 00:24:07,480
ok so one thing is fixing simple idea
errors right all kinds of heuristics

281
00:24:07,480 --> 00:24:13,540
propagation somewhere is a simple some
errors stomach some areas still have

282
00:24:13,540 --> 00:24:19,210
errors either because it's difficult to
perform some kind of analysis with idle

283
00:24:19,210 --> 00:24:24,640
some kind of mix-up with that with IDA
all because the algorithms are not

284
00:24:24,640 --> 00:24:31,810
perfect and or because of auntie
reversing tricks so there's two things

285
00:24:31,810 --> 00:24:35,139
we can do the first is we always have a
backup method mechanism with real-time

286
00:24:35,140 --> 00:24:40,390
disassembly ok we ever encounter an area
which does not have a pre analyzed basic

287
00:24:40,390 --> 00:24:45,040
block for that area we can always go
back to this assembly this is also will

288
00:24:45,040 --> 00:24:48,940
sort of service later for dynamically
generated code which obviously cannot be

289
00:24:48,940 --> 00:24:56,680
reanalyzed and another thing we can do
is after we analyzed with either we can

290
00:24:56,680 --> 00:24:59,980
run the trace and see where we have
errors right see where the code actually

291
00:24:59,980 --> 00:25:04,270
goes but we don't have basic loss for
that area and then we take the basic

292
00:25:04,270 --> 00:25:09,400
blocks that we saw in the real execution
and we put them back in the end I'd

293
00:25:09,400 --> 00:25:17,020
analysis and we see that we're no longer
missing basic blocks we now have a an

294
00:25:17,020 --> 00:25:23,889
exact and an exact basic look
representation so once again we analyze

295
00:25:23,890 --> 00:25:27,880
the basic blocks in ida we start tracing
the program we see that we've missed

296
00:25:27,880 --> 00:25:31,780
some basic blocks we see that the trace
has arrived at addresses for which we

297
00:25:31,780 --> 00:25:36,460
don't have a great basic block analysis
and we feed this back into the idea

298
00:25:36,460 --> 00:25:40,660
analysis in a loop until we no longer
have any missing basic blocks we do this

299
00:25:40,660 --> 00:25:46,180
on enough a PDF files aren't enough
files for the specific application then

300
00:25:46,180 --> 00:25:51,850
we reach pretty good results so this is
what the analysis now looks like

301
00:25:51,850 --> 00:25:55,360
everything you see in orange

302
00:25:55,860 --> 00:26:02,159
has been added since the last analysis
we take the starkest we look for next

303
00:26:02,160 --> 00:26:06,450
address in our basic block that are
based on our basic graph we look at the

304
00:26:06,450 --> 00:26:12,540
specific data we analyze it and if we
have basic look information for this

305
00:26:12,540 --> 00:26:17,580
address we continue as we continue
before we look at this address is the

306
00:26:17,580 --> 00:26:21,389
last instruction of this basic block and
indirect branch right so we're only

307
00:26:21,390 --> 00:26:24,960
dealing with the last instruction of
every basic look if we don't have this

308
00:26:24,960 --> 00:26:31,740
basic block in our our graph will be
moving back to this assembly based

309
00:26:31,740 --> 00:26:37,260
analysis which is the slow slower
analysis only do this very rarely so

310
00:26:37,260 --> 00:26:41,490
this this improves a little bit on there
on the analysis

311
00:26:41,490 --> 00:26:45,780
unfortunately we have an extra stage
here of looking at the next address in

312
00:26:45,780 --> 00:26:51,480
in our data database every time we have
to look at the next basic book

313
00:26:51,990 --> 00:26:59,040
ok so we can improve this we didn't
prove this we prove this by relying on

314
00:26:59,040 --> 00:27:04,230
the fact that many branches are relative
ok many branches are inside the same

315
00:27:04,230 --> 00:27:11,429
model and their relative a and relative
branches or so we assumed don't branch

316
00:27:11,429 --> 00:27:15,720
intermodal usually actually don't branch
intermodal right so if you have a jump 0

317
00:27:15,720 --> 00:27:22,770
or any kind of relative a base
addressing a branching you know that

318
00:27:22,770 --> 00:27:28,290
they're inside the same model so we can
rearrange the basic look database so

319
00:27:28,290 --> 00:27:32,790
that different basic books are the same
relative address as they are in the

320
00:27:32,790 --> 00:27:34,590
wheel real word world

321
00:27:34,590 --> 00:27:37,649
so if you have a relative branch from
one basic look to another basic block

322
00:27:37,650 --> 00:27:42,570
were just calculating the difference and
we can find the new basic block this is

323
00:27:42,570 --> 00:27:46,740
always possible since we're actually
storing less information in the basic

324
00:27:46,740 --> 00:27:50,340
block than the original basic lock
itself we're still restoring the branch

325
00:27:50,340 --> 00:27:55,770
but we're not storing all the
superfluous and disassembly ok and we do

326
00:27:55,770 --> 00:27:59,370
this as long as the basically in the
same model so for every model we store

327
00:27:59,370 --> 00:28:02,969
the basic books in the same order and
the same distance as they were before

328
00:28:02,970 --> 00:28:06,870
this further improve on

329
00:28:07,430 --> 00:28:13,190
on performance we now no longer have to
look at the next model in our database

330
00:28:13,190 --> 00:28:19,310
for every for every basic block with
reverse we only have to look at the next

331
00:28:19,310 --> 00:28:25,159
address in our basic look database if
the basic block is not in the same model

332
00:28:25,160 --> 00:28:29,000
you have to check the basic block is not
the same mother only if we're using a

333
00:28:29,000 --> 00:28:35,780
tip right so we've taken this step which
is a very performance intensive step

334
00:28:35,780 --> 00:28:37,520
which we had to perform all the time

335
00:28:37,520 --> 00:28:42,290
we're taking it out of the analysis and
we have a much more streamlined analysis

336
00:28:43,250 --> 00:28:48,140
ok at the little implementation hack we
take all this information we save it in

337
00:28:48,140 --> 00:28:53,030
a portable executable form at every
basic look and its rightful place every

338
00:28:53,030 --> 00:28:58,129
basic book in its correct relative
address and we've essentially built a

339
00:28:58,130 --> 00:29:02,840
little sooner assembly language that is
easy to disassemble and only contains

340
00:29:02,840 --> 00:29:05,840
branch information

341
00:29:06,350 --> 00:29:10,879
ok so this is an example is obviously
loves an identical to the portable

342
00:29:10,880 --> 00:29:17,570
executable form at this is a basic look
of the first basic block of an export of

343
00:29:17,570 --> 00:29:24,379
em so dll with the basic block
information at the head right so this

344
00:29:24,380 --> 00:29:28,070
contains information about what
instruction this basic block ends with

345
00:29:28,070 --> 00:29:32,540
how long the basic book is and we can
use this information to perform a trace

346
00:29:35,240 --> 00:29:40,100
ok so now we only have to perform
lookups and intermodal branches having

347
00:29:40,100 --> 00:29:45,679
done all this analysis runs in about 30
seconds 25 minutes for file closer to 30

348
00:29:45,680 --> 00:29:48,110
seconds usually which is pretty good

349
00:29:48,110 --> 00:29:53,120
ok this is a big improvement on I'm
taking hours to analyze and it's

350
00:29:53,120 --> 00:29:55,340
becoming sort of more practical

351
00:29:55,340 --> 00:29:59,750
ok we can now take a file analyze and
construct the whole trace of the file

352
00:29:59,750 --> 00:30:04,580
perform shadow perform shadows and
stacked checks and attack rock within 30

353
00:30:04,580 --> 00:30:11,990
seconds 25 minutes but then i looked at
what what we're still spending time with

354
00:30:11,990 --> 00:30:16,550
so little time in this assembly

355
00:30:17,470 --> 00:30:22,000
quite all time on the lookout between
models and the shadow stack these are

356
00:30:22,000 --> 00:30:27,070
all taking up quite a lot of time this
assembly because of Miss analyzed basic

357
00:30:27,070 --> 00:30:33,730
blocks but also because of some
dynamically generated code i was working

358
00:30:33,730 --> 00:30:41,289
on adobe PDF files powerpoint and the
entire office week these and dynamically

359
00:30:41,289 --> 00:30:48,850
generated code for graphics was called
the warp just-in-time compiler and this

360
00:30:48,850 --> 00:30:51,730
obviously was not be analyzed

361
00:30:51,730 --> 00:30:58,480
so one way to optimize this is used very
fast disassembler that is until that is

362
00:30:58,480 --> 00:31:05,980
also not sort of suitable and in terms
of license i really really like these 86

363
00:31:05,980 --> 00:31:13,120
it's great attackable very permissive
license no errors really fast i tried

364
00:31:13,120 --> 00:31:19,449
this storm i tried capstone this is what
I chose for my specific purposes it's

365
00:31:19,450 --> 00:31:23,350
very very lightweight and maintained but
I really have to say this is a great

366
00:31:23,350 --> 00:31:32,049
product is 86 it was actually also the
fastest disassembler okay but we still

367
00:31:32,049 --> 00:31:35,379
doing this assembly and disassembly is
always a performance intensive operation

368
00:31:35,380 --> 00:31:40,120
we're doing a little bit of this
assembly but we're still doing this

369
00:31:40,120 --> 00:31:45,610
assembly so we can now allowing the fact
that the code is different per iteration

370
00:31:45,610 --> 00:31:51,070
but it will still run per iteration
meaning . execution of the process i

371
00:31:51,070 --> 00:31:56,139
will still run several times for a
process so what we can do is we can

372
00:31:56,140 --> 00:32:01,150
patch the code so that the last awkward
a branch of code of the basic look

373
00:32:01,150 --> 00:32:06,039
appears at the beginning of the basic
blocks we can always do this but usually

374
00:32:06,039 --> 00:32:06,940
this will work

375
00:32:06,940 --> 00:32:11,260
so if we have a long shift it generated
basic block containing a lot of

376
00:32:11,260 --> 00:32:14,890
mathematical operations we can take the
last awkward of this long basic block

377
00:32:14,890 --> 00:32:19,240
but at the beginning of the code and
we've essentially performed the pre

378
00:32:19,240 --> 00:32:24,340
analysis or something similar to the pre
analysis in runtime and save quite a lot

379
00:32:24,340 --> 00:32:29,439
of execution time we could about

380
00:32:29,440 --> 00:32:36,340
so okay that's a presentation if you
have a long basic look we take the jump

381
00:32:36,340 --> 00:32:39,009
instruction at the end we put it right
in the middle so we don't have to

382
00:32:39,009 --> 00:32:45,399
disassemble all the move instructions
the next time the next time we encounter

383
00:32:45,399 --> 00:32:50,739
this another thing that can be done and
which is a little bit tricky but its

384
00:32:50,740 --> 00:32:54,399
partial disassembly write these move
instructions even if we do this assemble

385
00:32:54,399 --> 00:32:59,018
them once we don't actually need full
operands for every instruction we only

386
00:32:59,019 --> 00:33:06,789
need the length of instructions if they
are not branch producing ok so analysis

387
00:33:06,789 --> 00:33:12,158
after this stage takes about 10 seconds
to minutes is really a top time for very

388
00:33:12,159 --> 00:33:16,450
large powerpoint files the testing was
done with some education or PowerPoint

389
00:33:16,450 --> 00:33:21,549
files with a lot of the graphics but
most files run between 10 seconds and 30

390
00:33:21,549 --> 00:33:27,250
seconds and there's a pretty clear
roadmap for further optimization so I

391
00:33:27,250 --> 00:33:31,539
really feel that this is becoming
practical right this is a practical way

392
00:33:31,539 --> 00:33:36,610
to analyze files and get a complete
program trace and then perform cfi on

393
00:33:36,610 --> 00:33:43,090
this file like mentioning I never tried
actually patching code in runtime

394
00:33:43,090 --> 00:33:48,189
without doing the pre analysis i believe
this would probably be pretty fast but

395
00:33:48,190 --> 00:33:51,009
not fast enough probably under an hour

396
00:33:51,009 --> 00:34:02,529
ok so I'm few a few other few other
watches encountered and a few other

397
00:34:02,529 --> 00:34:08,829
things that they always go quite as well
in real life as in there as expected

398
00:34:09,339 --> 00:34:17,500
ok so detours so we supposedly have a
working solution but we do assume that

399
00:34:17,500 --> 00:34:21,159
the static models loaded into the
process are indeed static models

400
00:34:21,159 --> 00:34:25,240
unfortunately it turns out the quarter
of applications like to put detours on

401
00:34:25,239 --> 00:34:32,348
themselves either because of
functionality enhancements sandboxing or

402
00:34:32,349 --> 00:34:35,859
other reasons we can see this in office

403
00:34:36,370 --> 00:34:42,549
because of function called happy apt
organization or in Adobe because of

404
00:34:42,550 --> 00:34:49,270
sandboxing mechanisms so since we
recalculate the basic blocks this will

405
00:34:49,270 --> 00:34:50,320
ruin our analysis

406
00:34:50,320 --> 00:34:56,500
ok it will only it doesn't mean we can't
analyze the detoured basic blocks it

407
00:34:56,500 --> 00:35:01,030
actually means that if we assume the
basic blocks our eyes we calculated them

408
00:35:01,030 --> 00:35:05,500
they were really in the state of the
analyzer so we can't sort of overlook

409
00:35:05,500 --> 00:35:08,800
this and just the assume it'll be okay
we have to fix this issue

410
00:35:09,370 --> 00:35:14,049
hey luckily these details always at the
same place so we can take a memory

411
00:35:14,050 --> 00:35:16,810
snapshots where of the process

412
00:35:16,810 --> 00:35:22,120
add this info to our analysis and mark
these areas missed analyzed so will be

413
00:35:22,120 --> 00:35:27,009
disassembling these areas in runtime
which is a small performance overhead

414
00:35:27,010 --> 00:35:34,750
but we won't be missed analyzing the
code we actually further improved in

415
00:35:34,750 --> 00:35:40,900
this by pre analyzing the detours as
well which was a little bit tricky and

416
00:35:40,900 --> 00:35:46,930
saved very little overhead so that's a
that's the way actually looks in the

417
00:35:46,930 --> 00:35:53,410
code these these details are actually
pre analyzed as well so there's like a

418
00:35:53,410 --> 00:35:58,509
another extension to the subassembly
that said okay now branch to detour

419
00:35:58,510 --> 00:36:04,270
number one in detail number one is is
preset for every application and dll and

420
00:36:04,270 --> 00:36:13,690
here that's just a picture of the thing
this is adobe and Auntie closed detour

421
00:36:14,320 --> 00:36:23,350
ok a natural called close this was also
a pretty big issue we want to implement

422
00:36:23,350 --> 00:36:28,150
the shadows back so in order to
implement the shadows that we have to

423
00:36:28,150 --> 00:36:31,720
assume this is not fun

424
00:36:31,720 --> 00:36:35,529
we have to assume the functions always
return to their color

425
00:36:35,530 --> 00:36:41,050
ok if we want if we want to perform
co-finances we actually use the shadow

426
00:36:41,050 --> 00:36:45,640
stack is part of the tracing mechanism
as well so the shadows that has to work

427
00:36:45,640 --> 00:36:49,600
so obviously we

428
00:36:49,600 --> 00:36:53,920
start assuming functions return to their
color and we found out that they don't

429
00:36:53,920 --> 00:36:59,320
quite a lot of different mechanisms
which makes functions not always return

430
00:36:59,320 --> 00:37:03,610
to their color a classic example
exception handling right we perform some

431
00:37:03,610 --> 00:37:08,890
kind of stack and winding or we jump to
completely different location but

432
00:37:08,890 --> 00:37:14,350
there's also quite a few other examples
we encountered these could in theory be

433
00:37:14,350 --> 00:37:21,130
solved in a post-processing base right
so we can mark all of these specific

434
00:37:21,130 --> 00:37:26,290
mismatches as false positives and just
and just remove them from the the

435
00:37:26,290 --> 00:37:35,980
analysis but the the flow is often more
complex so we handle these on a

436
00:37:35,980 --> 00:37:41,620
case-by-case basis and we actually
inside the flow have have specific

437
00:37:41,620 --> 00:37:43,359
handling for each of these cases

438
00:37:43,360 --> 00:37:47,650
luckily it's always specific rights au
pair windows major version this has to

439
00:37:47,650 --> 00:37:56,110
be done once at most so for example with
exception handling we often have a stack

440
00:37:56,110 --> 00:38:00,100
and wine to start an address we know
this is legal but we don't know how far

441
00:38:00,100 --> 00:38:03,520
up the stack we went if a function is
called several times

442
00:38:03,520 --> 00:38:06,970
ok so this is a little bit tricky and
has to be solved inside the analysis

443
00:38:06,970 --> 00:38:12,939
it's also weak spot for cfi so this area
also had to be hardened because we have

444
00:38:12,940 --> 00:38:16,570
ambiguous states at some point we don't
know how long the culture in it but we

445
00:38:16,570 --> 00:38:24,970
don't know how much we have minded and
the little binary signal changes to keep

446
00:38:24,970 --> 00:38:29,830
all of this stuff sort of think between
different minor versions of different

447
00:38:29,830 --> 00:38:33,009
major versions of operating system and
applications

448
00:38:34,390 --> 00:38:37,390
that's pretty straight

449
00:38:40,190 --> 00:38:47,329
ok another another thing i mentioned is
into PT doesn't always work as expected

450
00:38:47,329 --> 00:38:51,260
quite a few documented bags not so bad

451
00:38:51,260 --> 00:38:56,839
unfortunately also some documented and
undocumented bags which caused quite a

452
00:38:56,839 --> 00:39:02,779
lot of trouble i was working on a 15
laptop one of the first 15 laptops to to

453
00:39:02,780 --> 00:39:06,859
arrive in market so this may be very
model-specific it may have improved in

454
00:39:06,859 --> 00:39:14,750
6-10 never reported it to intellectually
and this may have improved one

455
00:39:14,750 --> 00:39:21,650
specifically nasty Bob and happens there
specifically with with Adobe DC or

456
00:39:21,650 --> 00:39:26,599
certain versions of Adobe see if a stock
return address is modified manually by

457
00:39:26,599 --> 00:39:33,290
the code if the code goes and puts a
specific return address in the stack and

458
00:39:33,290 --> 00:39:36,560
some other pre no neck with a repair
requisites right this doesn't always

459
00:39:36,560 --> 00:39:42,349
happen then we will get a special T&T
packet instead of a tip packet this will

460
00:39:42,349 --> 00:39:46,579
completely destroy the analysis day and
this has to be handled once again some

461
00:39:46,579 --> 00:39:52,819
reversing and some sort of case-by-case
handling ok so whenever we encounter a

462
00:39:52,819 --> 00:39:58,190
state error or States a problem with our
with our analysis engine we go back we

463
00:39:58,190 --> 00:40:02,030
disassemble the code we see if somebody
is putting a specific address on the

464
00:40:02,030 --> 00:40:11,480
stack with the specific characteristics
that we've seen and we fixed we fix the

465
00:40:11,480 --> 00:40:20,660
analysis this is was pretty annoying bug
because debugging is is is complex we

466
00:40:20,660 --> 00:40:26,960
run quite a lot of iterations and we
never know what causes a context problem

467
00:40:26,960 --> 00:40:29,780
analysis context problem it could have
happened the same price but many many

468
00:40:29,780 --> 00:40:38,900
packets ago so that's that result we run
this on the several thousand office

469
00:40:38,900 --> 00:40:47,630
suite files and PDF files several
malicious files for for this corpus it

470
00:40:47,630 --> 00:40:48,650
looks pretty good

471
00:40:48,650 --> 00:40:52,820
k 0 false positives detected all the
experts experts for

472
00:40:52,820 --> 00:40:56,960
simple exploits using Rob taken of
Medicine flight but no information or

473
00:40:56,960 --> 00:41:03,230
prior information about the experts was
given to the analysis engine and a cute

474
00:41:03,230 --> 00:41:07,640
little side effect is it actually shows
the rope chain right so one thing is

475
00:41:07,640 --> 00:41:11,089
knowing there's an expert but we can
also show and prove that there's an

476
00:41:11,090 --> 00:41:15,440
explore and we can help say incident
response to some of the analyzing file

477
00:41:15,440 --> 00:41:22,220
just learning to actually see the the
rock chain or other cfi see if I problem

478
00:41:22,220 --> 00:41:30,529
future challenges so I'm going to talk a
little bit about stuff that we didn't

479
00:41:30,530 --> 00:41:34,100
implement we stopped there this project
was developed as I said during $MONTH

480
00:41:34,100 --> 00:41:41,029
2015 but there's quite a lot of work to
be done my continued them now that we're

481
00:41:41,030 --> 00:41:45,950
releasing the code so one thing is
dynamic code generation one thing I

482
00:41:45,950 --> 00:41:49,970
completely didn't talk about and it's
pretty important

483
00:41:49,970 --> 00:41:56,899
ok adobe PDF office suite use some
dynamically generated code but nothing

484
00:41:56,900 --> 00:41:57,710
too serious

485
00:41:57,710 --> 00:42:02,630
this this was handled sort of very
simply but some other applications like

486
00:42:02,630 --> 00:42:09,770
browsers flash well so polite whatever
many many different content parses is

487
00:42:09,770 --> 00:42:16,160
just in time compilers in order to have
just in time compiler analysis we have

488
00:42:16,160 --> 00:42:19,520
to have a snapshot of every time this
code is executed

489
00:42:19,520 --> 00:42:27,020
ok so so one method is forcing a rights
or execute approach you use memory page

490
00:42:27,020 --> 00:42:31,370
protections to force the page to either
be writable or executable and every time

491
00:42:31,370 --> 00:42:35,870
it becomes executable you take a
snapshot and this is the model for the

492
00:42:35,870 --> 00:42:40,430
pseudo model that you will load into the
analysis engine according to this x time

493
00:42:40,430 --> 00:42:46,460
very similar to what we did this models
except we have to actually implement the

494
00:42:46,460 --> 00:42:53,450
model unloading and loading ourselves
something extra we can do is we can

495
00:42:53,450 --> 00:43:00,589
actually also take a snapshot every time
or a snapshot of the the context every

496
00:43:00,590 --> 00:43:05,030
time the pages moved to write mode and
periodically since it is moved to write

497
00:43:05,030 --> 00:43:05,910
my own and

498
00:43:05,910 --> 00:43:10,410
formulation of the other threads
admitting code to the jet page so we can

499
00:43:10,410 --> 00:43:13,799
actually see if get code is being
emitted from somewhere it shouldn't be

500
00:43:13,799 --> 00:43:18,390
admitted if an expert tries to write to
the gym page and then perform sort of

501
00:43:18,390 --> 00:43:20,308
legal code from the jet age

502
00:43:20,309 --> 00:43:25,410
this is of course somewhat theoretical
cause it's unimplemented but i think

503
00:43:25,410 --> 00:43:29,279
this is one of the probably most
promising from ways to go

504
00:43:30,599 --> 00:43:43,890
there's a few other few other approaches
that can be done that I virtualization

505
00:43:43,890 --> 00:43:51,270
so when i worked on this project 15 cpus
and this did not support virtualized

506
00:43:51,270 --> 00:43:56,009
environments 16 cpu support virtualized
environments and according to the spec

507
00:43:56,010 --> 00:44:00,480
should be able to perform a trace from
the guests from the host or within the

508
00:44:00,480 --> 00:44:05,849
guests it makes the solution more
invisible less intrusive but you can

509
00:44:05,849 --> 00:44:16,500
trace a virtualized environment from a
vm from a host machine and this is

510
00:44:16,500 --> 00:44:23,849
probably the way to go forward this
doesn't need vm support so last i

511
00:44:23,849 --> 00:44:29,490
checked and then kvm did not have
support for for interpro surprise but

512
00:44:29,490 --> 00:44:36,629
this can be added to the different
solutions either manually or by maintain

513
00:44:36,630 --> 00:44:44,910
us a little about countermeasures of how
how attackers will bypass these types of

514
00:44:44,910 --> 00:44:50,190
solutions so as I said see if is
somewhat less effective on dynamically

515
00:44:50,190 --> 00:44:53,910
generated code because we don't actually
know what the code looks like because

516
00:44:53,910 --> 00:44:58,440
someone may have been emitting code that
malicious stuff without breaking control

517
00:44:58,440 --> 00:45:04,890
for integrity and also a few calls
without pre pre countries are possible i

518
00:45:04,890 --> 00:45:07,859
believe there is there another talk
later on today that talks about a

519
00:45:07,859 --> 00:45:10,920
similar similar expert that has been
some work

520
00:45:11,830 --> 00:45:16,600
con control so bending have been some
work on how to bypass control-flow

521
00:45:16,600 --> 00:45:19,870
integrity solutions using only data
modifications

522
00:45:21,730 --> 00:45:27,520
having said that the cfi engine itself
can be hard and right given a strong

523
00:45:27,520 --> 00:45:32,259
enough platform that gives us complete
analysis of the whole the whole program

524
00:45:32,260 --> 00:45:39,100
trace is quite a lot of things we can do
for example this is an easy example if

525
00:45:39,100 --> 00:45:47,200
we have symbols we can mitigate some use
after free type bands by forcing called

526
00:45:47,200 --> 00:45:52,180
the virtual functions to only call into
functions of the same inheritance tree

527
00:45:52,690 --> 00:45:58,120
ok that's a sort of simple simple
example of different types of cfi hard

528
00:45:58,120 --> 00:46:04,270
and we can do once we get a complete
program trace so of course nothing will

529
00:46:04,270 --> 00:46:13,480
ever stop a fully unlimited read/write
anywhere exploit an open question

530
00:46:13,480 --> 00:46:19,240
whether sort of a mixture of anti
exploit mechanisms and this type of and

531
00:46:19,240 --> 00:46:24,459
excellent mechanism will be able to
completely stop exploits

532
00:46:24,460 --> 00:46:27,490
probably not but i think this raises the
bar

533
00:46:28,000 --> 00:46:32,110
thank you

534
00:46:34,030 --> 00:46:41,470
the floor or questions of stages always
yeah well then thank you very much no me

535
00:46:41,470 --> 00:46:42,549
and run as well

