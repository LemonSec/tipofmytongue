1
00:00:00,000 --> 00:00:13,170
thank you very much

2
00:00:14,610 --> 00:00:20,430
so today I'm going to talk about the
exploit development process from ID 11

3
00:00:20,430 --> 00:00:27,779
exploit we develop beginning of this
year and since we were targeting ie11 on

4
00:00:27,779 --> 00:00:31,380
the latest version of Windows 10 we had
to bypass quite a few exploit

5
00:00:31,380 --> 00:00:37,350
mitigations and so in the end we decided
to submit all the vulnerability

6
00:00:37,350 --> 00:00:41,700
information and all the techniques we
were using to Microsoft part of their

7
00:00:41,700 --> 00:00:47,460
education bypass bounty program and i'm
quite happy to say that we got the water

8
00:00:47,460 --> 00:00:53,579
the full hundred thousand US dollars for
our submission so today I'm finally able

9
00:00:53,579 --> 00:01:01,980
to publicly disclose all the techniques
and vulnerabilities we use and i will

10
00:01:01,980 --> 00:01:08,280
show you all of that basically so i will
start with some motivation basically

11
00:01:08,280 --> 00:01:12,000
explaining why we why we started
developing the exploit in the first

12
00:01:12,000 --> 00:01:16,290
place and after doing that i will go
through each technique and vulnerability

13
00:01:16,290 --> 00:01:22,170
so starting was a tight area neutering
vulnerability which is the back we

14
00:01:22,170 --> 00:01:26,970
exploited to get the initial code
execution i'll talk about is custom heap

15
00:01:26,970 --> 00:01:32,940
and how we use that in order to turn the
back into a read/write primitive i'll

16
00:01:32,940 --> 00:01:37,350
talk about god mode which is a known
technique previously known technique

17
00:01:37,350 --> 00:01:42,570
which can be used to get code execution
without using shellcode and i will talk

18
00:01:42,570 --> 00:01:47,100
about how we actually managed to
reenable that or we use that and the

19
00:01:47,100 --> 00:01:53,520
latest version of internet explorer i'll
talk about how we managed to escape the

20
00:01:53,520 --> 00:01:58,439
enhanced protected mode sandbox and
finally I'll talk about the generic

21
00:01:58,439 --> 00:02:05,189
technique which allowed us to make our
exploit work on the image so few words

22
00:02:05,189 --> 00:02:11,489
about myself my name is Marty died i'm
head of research at blue for security

23
00:02:11,489 --> 00:02:16,950
which is a small research based company
in Germany and my main focus is on

24
00:02:16,950 --> 00:02:21,209
application security so I'm mostly
interested in stuff like reverse

25
00:02:21,209 --> 00:02:25,680
engineering accounting exploitation and
I like to focus medications

26
00:02:27,670 --> 00:02:33,549
so yeah why when you actually start
doing the exploit so the initial idea

27
00:02:33,550 --> 00:02:39,280
was that we wanted to participate in
punta on this year so after thinking

28
00:02:39,280 --> 00:02:44,800
about it did which target we could
choose we decided to go after I 11

29
00:02:44,800 --> 00:02:51,819
mainly because first of all we had some
prior experience with it and second just

30
00:02:51,819 --> 00:02:58,299
based on the previous year rules and
price money we thought that the arm you

31
00:02:58,300 --> 00:03:03,069
know that they expected difficulty
versus the expected price money was just

32
00:03:03,069 --> 00:03:11,048
right for this target so the goal was to
exploit ie11 64-bit version and has

33
00:03:11,049 --> 00:03:14,620
protected mode had to be enabled
manually because that was a requirement

34
00:03:14,620 --> 00:03:20,170
and the last year's contest it had to be
run on the latest version of Windows 10

35
00:03:20,170 --> 00:03:27,488
and also it had to bypass the latest
version of them as well so basically we

36
00:03:27,489 --> 00:03:33,010
started the main work beginning of this
year and roughly a month later we

37
00:03:33,010 --> 00:03:38,048
already got got got an exploit we gotta
get lucky because we found a really nice

38
00:03:38,049 --> 00:03:44,290
for mobility and of course we didn't
have an EP and a DPMS cabe ready and we

39
00:03:44,290 --> 00:03:49,239
didn't have the Emmett bypass ready and
but in general we got code execution and

40
00:03:49,239 --> 00:03:53,140
everything look good look good so far
and we thought we would make it for .

41
00:03:53,140 --> 00:04:00,790
own than just a few days later going to
own published the rules and turned out I

42
00:04:00,790 --> 00:04:05,650
11 is for the first time no longer part
of the contest so we were really

43
00:04:05,650 --> 00:04:10,390
frustrated because we spent quite some
time and effort in getting to this point

44
00:04:10,390 --> 00:04:18,010
so we were thinking okay what can we do
now and in the end we decided to submit

45
00:04:18,010 --> 00:04:22,000
all the all the vulnerability details
and the old exploit and all the

46
00:04:22,000 --> 00:04:26,889
techniques to Microsoft directly as part
of their mitigation by this bounty

47
00:04:26,889 --> 00:04:32,229
program and it turns out that was
exactly the right decision because as I

48
00:04:32,229 --> 00:04:34,710
said before they awarded us with the

49
00:04:34,710 --> 00:04:42,299
under k failed so in the remaining
presentation i'm now going through all

50
00:04:42,300 --> 00:04:47,310
the vulnerabilities and techniques so
we'll start was a type error neutering

51
00:04:47,310 --> 00:04:52,080
vulnerability in order to understand
that you have to know about two basic

52
00:04:52,080 --> 00:04:56,729
JavaScript concepts first one is web
workers and the second one are typed

53
00:04:56,730 --> 00:05:04,710
arrays so web workers are basically
concept of having concurrent threads of

54
00:05:04,710 --> 00:05:10,859
JavaScript code running in the browser
there's a way to to communicate between

55
00:05:10,860 --> 00:05:15,540
workers and so you use message passing
so basically what you do is you call the

56
00:05:15,540 --> 00:05:20,100
post message function we pass it the
message you want to send and there's an

57
00:05:20,100 --> 00:05:24,120
optional argument called the transfer
list and the transfer list connection be

58
00:05:24,120 --> 00:05:29,730
used to transfer the ownership of an
object to another worker and what

59
00:05:29,730 --> 00:05:36,510
happens in that case is if you do that
an object becomes unusable and also

60
00:05:36,510 --> 00:05:41,219
called neutered and the current context
and it appears in the receiving context

61
00:05:41,220 --> 00:05:47,370
so it's a way of transferring objects
between workers basically and the second

62
00:05:47,370 --> 00:05:51,720
concept title race you probably all know
about them because they are really

63
00:05:51,720 --> 00:05:57,180
popular in recent browser exploit just
because they give you a really powerful

64
00:05:57,180 --> 00:06:02,520
and primitive so once you are able to
corrupt the type array and you basically

65
00:06:02,520 --> 00:06:06,900
get the ability to read and write
arbitrary memory which is which is

66
00:06:06,900 --> 00:06:13,590
really powerful so the implementation is
basically split between views and

67
00:06:13,590 --> 00:06:19,500
buffers so view can be seen us something
like a typecast it just defines the way

68
00:06:19,500 --> 00:06:25,020
how data access while the buffers
actually the part which which stores the

69
00:06:25,020 --> 00:06:33,090
the actual data buffers are implemented
in the air above object and this object

70
00:06:33,090 --> 00:06:36,840
can't be accessed directly so you always
have to use the view or one of these

71
00:06:36,840 --> 00:06:40,500
subclasses like you and eight array or
you and 32 array

72
00:06:40,500 --> 00:06:45,870
however you can get a reference to the
underlying area before typed array by

73
00:06:45,870 --> 00:06:48,129
using the buffer property

74
00:06:48,129 --> 00:06:54,669
so before we actually started to look
for box in general it's always good to

75
00:06:54,669 --> 00:06:59,799
have a look what other people did in the
past because in many many times it's

76
00:06:59,800 --> 00:07:05,259
just a quick way of finding new box and
it's also interesting to see where

77
00:07:05,259 --> 00:07:12,550
people might have looked for box already
so let's take a look at . own 2014the

78
00:07:12,550 --> 00:07:18,219
when total three firefox exploits and
interesting two of them we're really in

79
00:07:18,219 --> 00:07:25,089
related areas so the first one exploited
by do hot for the back which so the back

80
00:07:25,089 --> 00:07:28,719
description says out of bounds right
through type array object after

81
00:07:28,719 --> 00:07:34,089
neutering and the second back exploited
the you eat la and was also really

82
00:07:34,089 --> 00:07:40,179
related to New Terry buffers so it looks
like this whole concept of new Terra

83
00:07:40,179 --> 00:07:44,558
buffers on the whole neutering concept
seems to be error-prone and how to

84
00:07:44,559 --> 00:07:51,189
implement so we were looking into these
techniques and these technologies and

85
00:07:51,189 --> 00:07:56,559
see if maybe I 11 had some issues as
well and it turns out yes they do

86
00:07:56,559 --> 00:08:01,749
so this is our small proof-of-concept
it's pretty simple pretty

87
00:08:01,749 --> 00:08:03,009
straightforward

88
00:08:03,009 --> 00:08:07,509
so what we do first is we create an
empty worker so it doesn't contain code

89
00:08:07,509 --> 00:08:12,429
that just creates an empty worker and
then we create a typed array online

90
00:08:12,429 --> 00:08:19,568
five-year and what we do now is we call
the postmessage in order to transfer the

91
00:08:19,569 --> 00:08:25,419
ownership of the underlying area falls
to type array to this broker and by

92
00:08:25,419 --> 00:08:31,869
doing that what happens is the area file
will actually be alright will disappear

93
00:08:31,869 --> 00:08:36,219
in the current context so it will be
neutered and effectively that means it

94
00:08:36,219 --> 00:08:37,240
will be freed

95
00:08:37,240 --> 00:08:41,979
so after a few milliseconds the the
underlying air above the type array will

96
00:08:41,979 --> 00:08:49,180
be free since they didn't adjust all
they didn't account for this fact they

97
00:08:49,180 --> 00:08:53,138
didn't invalidate the area before
reference in the title ray so

98
00:08:53,139 --> 00:09:00,490
effectively and after this happened we
can just use the array and we can use it

99
00:09:00,490 --> 00:09:01,480
to excess

100
00:09:01,480 --> 00:09:07,779
the free dairy buffer and this is nice
because we can use the index of the air

101
00:09:07,779 --> 00:09:12,910
a to specify the exact offset where we
want to access the the free memory

102
00:09:12,910 --> 00:09:18,550
basically and we can read read from it
we can write to it so we have have good

103
00:09:18,550 --> 00:09:23,680
control over the Freak memory socio
enable peichi for example you get this

104
00:09:24,459 --> 00:09:29,560
so as you can see here we are writing
single bite to the free memory and in

105
00:09:29,560 --> 00:09:34,060
this case we control the the offset
which is can be found in the ESI

106
00:09:34,060 --> 00:09:43,839
register so i said this is a pretty
powerful back because compared to other

107
00:09:43,839 --> 00:09:50,500
use of the free box where you need to
find a third target object of exactly a

108
00:09:50,500 --> 00:09:55,360
specific size in this case we control
the size of the frame memory so if you

109
00:09:55,360 --> 00:10:02,110
know there's a nice target object which
we want to corrupt of specific size s we

110
00:10:02,110 --> 00:10:06,190
could just create typed array and thus
create the underlying area before

111
00:10:06,190 --> 00:10:11,680
exactly the size s trigger the back and
then we just have to force the creation

112
00:10:11,680 --> 00:10:16,000
of our target object which will
eventually be placed in in this free

113
00:10:16,000 --> 00:10:23,949
chunk of memory so it's pretty powerful
so the question is okay which object to

114
00:10:23,949 --> 00:10:30,069
retarget to answer that question we have
to first see where the area buffers

115
00:10:30,069 --> 00:10:34,120
actually allocated so if you take a look
at the Jays JavaScript variable factor

116
00:10:34,120 --> 00:10:38,709
eight function you will see that they're
using the Melk function to allocate

117
00:10:38,709 --> 00:10:43,779
their the the memory and that means the
memory is allocated on this year t.o.o

118
00:10:43,779 --> 00:10:49,569
on the process heat this actually
reduces the number of potentially useful

119
00:10:49,569 --> 00:10:55,120
objects a bit because all the nice stuff
which you could corrupt like typed

120
00:10:55,120 --> 00:11:01,000
arrays or other race or strings they are
located on a nice custom even step so

121
00:11:01,000 --> 00:11:06,910
the question is what which object could
be target in the end it turns out

122
00:11:06,910 --> 00:11:12,310
there's one interesting object which is
called the the large block object which

123
00:11:12,310 --> 00:11:13,810
builds the foundation

124
00:11:13,810 --> 00:11:19,270
around is custom-made and it turns out
you can trigger the creation of these

125
00:11:19,270 --> 00:11:24,160
objects on this year keep by creating
large javascript objects so you can just

126
00:11:24,160 --> 00:11:30,250
create a large large area object of
integers for example which will

127
00:11:30,250 --> 00:11:35,170
eventually create these largely black
objects and there's one thing to note

128
00:11:35,170 --> 00:11:42,849
here that if you create a large area of
integers largely black object of a

129
00:11:42,850 --> 00:11:44,560
certain size will be created

130
00:11:44,560 --> 00:11:49,959
however if you create an area of object
references for example the large cheese

131
00:11:49,960 --> 00:11:56,290
block object which will be traded has a
different size so by by changing the

132
00:11:56,290 --> 00:12:01,420
elements you're storing and in the array
you can crypt you can change this so you

133
00:12:01,420 --> 00:12:04,779
can control the size of the largely
black object which is created

134
00:12:05,380 --> 00:12:09,070
just keep that in mind because we are
making use of that in the pic in the

135
00:12:09,070 --> 00:12:14,830
exploit so if you're executing the
JavaScript code on the previous slide

136
00:12:14,830 --> 00:12:20,680
you will you will see that you get lots
of these locations of the eight sighs

137
00:12:20,680 --> 00:12:26,199
bite and if you take a look at the
memory of these allocations you will see

138
00:12:26,200 --> 00:12:29,200
that these are really the large cheap
objects were looking for

139
00:12:31,089 --> 00:12:35,050
so let's take a look at the content of
these objects there are some interesting

140
00:12:35,050 --> 00:12:42,339
fields in them so at a sedate there is a
point out to the IE customer so this is

141
00:12:42,339 --> 00:12:47,170
nice because this way we can get a
reference to the custom heap which

142
00:12:47,170 --> 00:12:53,800
becomes useful afterwards at offset 58
and 60 there is a forward and the

143
00:12:53,800 --> 00:12:59,589
backward pointer which usually a
sentinel and i will talk about that in a

144
00:12:59,589 --> 00:13:00,430
in a bit

145
00:13:00,430 --> 00:13:05,859
why this is interesting and finally at
offset 70 there is a pointer to the

146
00:13:05,860 --> 00:13:11,110
large cheese block itself so this is
nice because by leaking that point I you

147
00:13:11,110 --> 00:13:15,040
middle immediately find the address of
the current lucky block object your

148
00:13:15,040 --> 00:13:16,540
operator operating on

149
00:13:16,540 --> 00:13:24,969
so how do we actually uses for
corruption so I said this is forward and

150
00:13:24,970 --> 00:13:27,400
respect . and it turns out

151
00:13:27,400 --> 00:13:30,400
and during during garbage collection

152
00:13:30,970 --> 00:13:36,760
the code is actually iterating over all
the largely block object and its calling

153
00:13:36,760 --> 00:13:42,160
the operator method on on all of them
and this operator message was that what

154
00:13:42,160 --> 00:13:47,680
it does is it it performs a doubly lips
linked handling operation on these two .

155
00:13:47,680 --> 00:13:53,380
as if they are set and now you would
expect okay and on on the latest version

156
00:13:53,380 --> 00:13:57,100
of windows from these handling
operations they are probably protected

157
00:13:57,100 --> 00:14:02,650
like in every modern allocated
implementation however turns out they

158
00:14:02,650 --> 00:14:07,120
are not so it's really a simple doubly
linked on link operation and you can

159
00:14:07,120 --> 00:14:11,770
really exploit them like like you did in
the past when corrupting eat metadata

160
00:14:11,770 --> 00:14:16,210
for example so easily get a by
overwriting the forward and the backward

161
00:14:16,210 --> 00:14:22,630
pointers you easily get right for in
this case right a primitive you have

162
00:14:22,630 --> 00:14:26,770
this constraint that the the backward .
actually has to be a valid address

163
00:14:26,770 --> 00:14:30,699
because it's roughly reference to store
the whole part pointer

164
00:14:30,700 --> 00:14:35,110
however in the end it gives us the
ability to write a pointer to an

165
00:14:35,110 --> 00:14:39,760
arbitrary address in memory so that's
nice

166
00:14:39,760 --> 00:14:44,230
however we want something more so we
want the ability to read arbitrary

167
00:14:44,230 --> 00:14:48,640
addresses we want to write a bateria
dresses and we will also want to leak

168
00:14:48,640 --> 00:14:55,360
arbitrary JavaScript objects so as I
said before typed arrays a nice way of

169
00:14:55,360 --> 00:15:01,630
getting this this powerful primitive
however title race are located on ideas

170
00:15:01,630 --> 00:15:07,360
custom-made and with the back we have we
can only access objects on the on the

171
00:15:07,360 --> 00:15:09,070
normal your keep

172
00:15:09,070 --> 00:15:15,880
so how do we find the address of a type
array so the strategy is as follows

173
00:15:15,880 --> 00:15:23,050
so first we create two groups of typed
arrays so we basically create these

174
00:15:23,050 --> 00:15:27,280
title race which will effectively create
the corresponding and airy buffers on

175
00:15:27,280 --> 00:15:34,390
the CRT heap and we are i'm trading one
group of a specific size and another

176
00:15:34,390 --> 00:15:38,590
group of another size and then will
trigger the back so we will have typed

177
00:15:38,590 --> 00:15:40,680
arrays pointing to freeze every butters

178
00:15:40,680 --> 00:15:45,060
and then we'll start to alternate
between allocating JavaScript array of

179
00:15:45,060 --> 00:15:52,619
integers and JavaScript arrays of type
every reference is basically and this

180
00:15:52,620 --> 00:15:56,730
will eventually leave the created
largely block off objects will

181
00:15:56,730 --> 00:16:03,660
eventually fill the the free keep it
chunks and in order to understand a

182
00:16:03,660 --> 00:16:05,399
little bit better

183
00:16:05,399 --> 00:16:09,839
he's a small demonstration so on the
left side you can see this here keep on

184
00:16:09,839 --> 00:16:14,640
the right side we have the customer so
we start by trading the first group of

185
00:16:14,640 --> 00:16:21,390
typed arrays and in this case we create
typed arrays of size 8 which will

186
00:16:21,390 --> 00:16:26,670
effectively create area buffis of the
same size on the seer key then we create

187
00:16:26,670 --> 00:16:31,740
the second group so create another group
of typed arrays but this time we create

188
00:16:31,740 --> 00:16:37,260
them with a size of a zero and again
Arab of us will be created on the tiger

189
00:16:37,260 --> 00:16:46,230
on the CRT so now we start to to do the
allocations of these array of objects so

190
00:16:46,230 --> 00:16:50,850
first of all we trigger the back of
course so now we have typed arrays

191
00:16:50,850 --> 00:16:58,170
pointing to free memory and now we start
to do the alternating between creating

192
00:16:58,170 --> 00:17:02,490
areas of integers and areas of typed
arrays so first we created in $YEAR to

193
00:17:02,490 --> 00:17:09,209
generate a large integer II and i said
before this is a trigger the creation of

194
00:17:09,209 --> 00:17:13,350
a large cheese block object and in this
case and since we are storing integers

195
00:17:13,349 --> 00:17:18,389
will create a lot cheaper object of
exactly b8 sighs so eventually it will

196
00:17:18,390 --> 00:17:23,670
it will replace one of the current and
one of the previously freed everybody

197
00:17:23,670 --> 00:17:29,790
objects and then we will continue and we
will create area of type every

198
00:17:29,790 --> 00:17:35,010
references again this is a large array
so it will create a largely black object

199
00:17:35,010 --> 00:17:41,190
of the size 0 in this case because we're
not during into just but references and

200
00:17:41,190 --> 00:17:45,360
now you can see why we create the second
group of typing race because now the

201
00:17:45,360 --> 00:17:52,500
largely black object has exactly a zero
bytes so we continue that process so we

202
00:17:53,200 --> 00:17:58,210
continue to train new integer array in
which will again create another people

203
00:17:58,210 --> 00:18:04,450
object so in the end we are exactly
looking for this memory layout which you

204
00:18:04,450 --> 00:18:08,919
can see on the bottom right so what do
you really want to have as we want want

205
00:18:08,919 --> 00:18:13,510
an integer area at the beginning it
needs to be followed by an area of typed

206
00:18:13,510 --> 00:18:19,570
arrays and one of the reference type
arrays must be followed and finally at

207
00:18:19,570 --> 00:18:25,990
the end we need another integer rate the
good thing is of course there's

208
00:18:25,990 --> 00:18:30,010
randomization going on so you can't be
really sure that you trigger exactly as

209
00:18:30,010 --> 00:18:31,029
he play out

210
00:18:31,029 --> 00:18:36,039
however as you will see in a bit it's
quite easy to see if you actually manage

211
00:18:36,039 --> 00:18:41,019
to create exactly this layout and if you
didn't manage to create it we can just

212
00:18:41,019 --> 00:18:47,710
retry so it's pretty easy to two in a
loop try to create this layout and once

213
00:18:47,710 --> 00:18:54,490
we got that we continue with our exploit
so the first step in the exploit is to

214
00:18:54,490 --> 00:19:01,960
actually corrupt the first integer array
this one year so how do we do that so we

215
00:19:01,960 --> 00:19:08,019
have the the type array here which
allows us to access to to read and write

216
00:19:08,019 --> 00:19:12,820
the large cheese block object so as I
said before this is data . are pointing

217
00:19:12,820 --> 00:19:18,220
to the CRT heap which in this case
points to the integer array so we just

218
00:19:18,220 --> 00:19:24,669
like that . are so we find out the
address of the integer rain and then

219
00:19:24,669 --> 00:19:29,440
what we do is we use the the right a
primitive I talked about before so by

220
00:19:29,440 --> 00:19:35,559
overriding before the backward point of
the large she block up the block we we

221
00:19:35,559 --> 00:19:41,139
write a pointer to the size field of the
integer array and we do that to

222
00:19:41,139 --> 00:19:44,469
effectively yeah basically by
overwriting the size filled with the

223
00:19:44,470 --> 00:19:52,149
point you enlarge the size by a really
large factor and a quick refresher on

224
00:19:52,149 --> 00:19:57,549
how areas are stored in in memory so
basically you have three lengths fields

225
00:19:57,549 --> 00:20:04,179
you got the number of allocated bites
you get the actual error length which is

226
00:20:04,179 --> 00:20:06,909
the number of currently start element

227
00:20:06,909 --> 00:20:13,239
in the array and finally you got the
result length and in the during the

228
00:20:13,239 --> 00:20:13,629
right

229
00:20:13,629 --> 00:20:19,299
aight primitive always with the was a
size corruption we did we just override

230
00:20:19,299 --> 00:20:25,389
the reserve length which allows us to
use this array to actually write right

231
00:20:25,389 --> 00:20:26,769
out of bounds

232
00:20:26,769 --> 00:20:32,440
however if you want to read memory after
the array you actually have to modify a

233
00:20:32,440 --> 00:20:37,869
second length namely the airings and
instead of corrupting instead of

234
00:20:37,869 --> 00:20:41,918
corrupting to length field what you can
do is you first corrupt the reserve link

235
00:20:41,919 --> 00:20:48,729
and then you write at a really high
peaking at a really large index which is

236
00:20:48,729 --> 00:20:56,529
larger than that were rich original size
and that will affect the fleet and

237
00:20:56,529 --> 00:21:01,210
adjust their legs according so after
doing that you have the ability to read

238
00:21:01,210 --> 00:21:07,869
and write memory after the actual
integer array so the second step is

239
00:21:07,869 --> 00:21:13,509
actually to do exactly this so we are
using the the first integer array where

240
00:21:13,509 --> 00:21:20,049
we overwrote the size field and the
right to a really high index and now you

241
00:21:20,049 --> 00:21:24,940
see why we why we chose to use this
memory layout because we are writing to

242
00:21:24,940 --> 00:21:30,669
the first element of the of the second
integer array and we're doing that in

243
00:21:30,669 --> 00:21:35,799
order to not corrupt any unrelated
memory to not cause any crashes and also

244
00:21:35,799 --> 00:21:41,408
it gives us the ability to see if the if
everything worked basically because you

245
00:21:41,409 --> 00:21:45,519
can easily check the element of the
second array and if you successfully

246
00:21:45,519 --> 00:21:50,679
modified that element you can be sure
that from from that point on we are able

247
00:21:50,679 --> 00:21:55,749
to read and write to all this memory
memory between these two integer raise

248
00:21:55,749 --> 00:22:02,830
so the the last step is basically now
that we are able to read and write

249
00:22:02,830 --> 00:22:10,539
between these two integer race we want
to modify a type array so first we leak

250
00:22:10,539 --> 00:22:15,549
all the type area . us from the area of
typed arrays and for every point we are

251
00:22:15,549 --> 00:22:19,929
basically checking if the reference type
array resides between these two into

252
00:22:19,929 --> 00:22:26,769
arrays and if it does then we are able
to access it right so we may just

253
00:22:26,769 --> 00:22:31,720
override the size field and the raw data
point of the type the right and then we

254
00:22:31,720 --> 00:22:36,639
have a typed array which allows us to
access to read and write arbitrary

255
00:22:36,639 --> 00:22:43,508
addresses basically for 64-bit processes
there's still some some issues here

256
00:22:43,509 --> 00:22:52,090
running into many due to the way that
you can write really huge size field but

257
00:22:52,090 --> 00:22:56,769
you can easily work around that fact and
it's all described in the white paper if

258
00:22:56,769 --> 00:22:57,879
you're interested

259
00:22:57,879 --> 00:23:04,330
so now we got the ability to read and
write arbitrary memory so this is quite

260
00:23:04,330 --> 00:23:09,970
powerful and we can also leave some
arbitrary JavaScript objects so if you

261
00:23:09,970 --> 00:23:14,259
take a look at the slide again what you
can do is you can store arbitrary

262
00:23:14,259 --> 00:23:18,909
arbitrary JavaScript objects in the area
of typed arrays and then you just use

263
00:23:18,909 --> 00:23:24,309
the corrupted integer a year to to
league one of these pointers and you

264
00:23:24,309 --> 00:23:26,499
immediately get the get the address

265
00:23:26,499 --> 00:23:30,159
so what do we do with it

266
00:23:30,159 --> 00:23:33,909
so the most obvious thing to do is ok
let's leak

267
00:23:33,909 --> 00:23:39,129
let's let's get the address of the
JavaScript object and we just overwrite

268
00:23:39,129 --> 00:23:42,340
the table pointer and get code execution

269
00:23:42,340 --> 00:23:46,449
however on on the latest version of
windows you have control so God so it's

270
00:23:46,450 --> 00:23:47,379
not that easy

271
00:23:47,379 --> 00:23:53,469
I mean you would need to find a bypass
or CFG bypassed and it's might be quite

272
00:23:53,470 --> 00:23:59,619
some effort and also on using shellcode
and Rob gadgets and all that stuff might

273
00:23:59,619 --> 00:24:02,949
give you some some more work later on
when you want to but when we want to

274
00:24:02,950 --> 00:24:08,710
bypass Emmett so in the end we decided
to go another route and namely we were

275
00:24:08,710 --> 00:24:14,830
looking into god mode so god mode is a
known technique it was publicly

276
00:24:14,830 --> 00:24:20,110
presented by a young you and you can
change in 2014 already and it's

277
00:24:20,110 --> 00:24:25,899
basically an attack against ice cream
script into creator engine so in the

278
00:24:25,899 --> 00:24:30,908
past what you could do is there in the
in the script interpreter engine object

279
00:24:30,909 --> 00:24:33,460
there's a single flag called a safety
option flag

280
00:24:33,460 --> 00:24:37,659
and in the past what you could do is you
could just override the single bite

281
00:24:37,659 --> 00:24:42,399
there's a single now bite and that was
basically give you the ability to

282
00:24:42,399 --> 00:24:47,649
instantiate arbitrary unsafe activex
controls and effectively you can then

283
00:24:47,649 --> 00:24:53,559
execute any system commands without
using shellcode at all so inside the

284
00:24:53,559 --> 00:24:58,539
code there are two functions which are
responsible for deciding if this is

285
00:24:58,539 --> 00:25:03,399
possible without any prompts and which
is stripped engine can create object and

286
00:25:03,399 --> 00:25:10,239
script engine can object run so once
this was published Microsoft decided to

287
00:25:10,240 --> 00:25:15,130
do something about it and try to make it
a little bit harder and they introduced

288
00:25:15,130 --> 00:25:21,279
the 20 bite hashcode so this is
basically a way of trying to prevent you

289
00:25:21,279 --> 00:25:28,630
from just a right of writing single bite
some more details about this nicely

290
00:25:28,630 --> 00:25:34,990
documented in a blog post by 49 and
actually there there was a bypass for

291
00:25:34,990 --> 00:25:40,000
for that as well and so when you get
chance xsplit to which is quite awesome

292
00:25:40,000 --> 00:25:42,549
he implemented the bypass

293
00:25:42,549 --> 00:25:47,110
so instead of what he did instead of
overriding the safety option flag and

294
00:25:47,110 --> 00:25:51,490
what he did is he replaced the complete
reference to the security manager object

295
00:25:51,490 --> 00:25:56,919
and so he's basically building this the
security manager object a complete new

296
00:25:56,919 --> 00:26:01,990
security manager object in memory and
overriding the the reference to it in

297
00:26:01,990 --> 00:26:08,110
the script engine object and then what
he does is in the table of the office

298
00:26:08,110 --> 00:26:13,389
take object is basically i'm replacing
two down to function pointers was

299
00:26:13,390 --> 00:26:20,529
dynamically generated Rob gadgets as you
can see on the bottom here so this work

300
00:26:20,529 --> 00:26:21,340
nicely

301
00:26:21,340 --> 00:26:27,879
however one see if she was introduced
the way it was implemented no longer

302
00:26:27,880 --> 00:26:33,100
work i mean you could probably adjust
the technique and use some specific CFG

303
00:26:33,100 --> 00:26:39,639
are some specific Rob gadgets instead
but instead we found a much easier way

304
00:26:39,640 --> 00:26:47,230
of doing it so I started analyzing the
cord and in particular

305
00:26:47,230 --> 00:26:51,070
was interested in if it would be
possible to still use the god more

306
00:26:51,070 --> 00:26:57,070
technique and so I was looking for the
code mentioned in the previous 14 that

307
00:26:57,070 --> 00:27:02,559
article and I was looking for for the
code which basically does this hash code

308
00:27:02,559 --> 00:27:08,200
verification and calculation all that
stuff and I was looking in the just I

309
00:27:08,200 --> 00:27:12,130
really couldn't find the code so i was
thinking okay maybe I'm just too stupid

310
00:27:12,130 --> 00:27:16,809
to see it so in the end what I did is I
I just overwrote the safety option flag

311
00:27:16,809 --> 00:27:21,280
in order to see what would happen and it
turns out it still worked so it was a

312
00:27:21,280 --> 00:27:27,040
little bit confused so it looks like you
can still write a single bite and get

313
00:27:27,040 --> 00:27:36,250
code execution so it turns out the
protection just disappeared and later on

314
00:27:36,250 --> 00:27:42,100
I found out the the protection actually
just disappeared on Windows 10 so where

315
00:27:42,100 --> 00:27:47,199
did my analysis obviously so on Windows
8.1 for examples and the protection

316
00:27:47,200 --> 00:27:53,890
mechanism was still there so interesting
this year at can sequester I was talking

317
00:27:53,890 --> 00:28:00,160
to someone from microsoft and they told
me that the this hashing protection

318
00:28:00,160 --> 00:28:05,620
thingy it disappeared because due to an
internal compiler change which I found

319
00:28:05,620 --> 00:28:14,020
really interesting so in the end we
still had on Windows 10 the ability to

320
00:28:14,020 --> 00:28:18,760
write a single abide in memory and get
the ability to execute system commands

321
00:28:18,760 --> 00:28:26,080
so now this gave us the ability to get
code execution

322
00:28:26,620 --> 00:28:31,840
however as I said we were targeting and
enhanced protected mode sandbox since

323
00:28:31,840 --> 00:28:39,159
this was a requirement for . on so let's
see how we can maybe escape that again

324
00:28:39,160 --> 00:28:45,100
we did some research on what people used
in the past to escape the IE sandbox and

325
00:28:45,100 --> 00:28:51,490
there's a known and public technique on
which web which was used in the past by

326
00:28:51,490 --> 00:28:56,020
people to escape the protected mode
sandbox so the less restricted version

327
00:28:56,020 --> 00:29:00,908
of the sandbox so it's based on the
concept of

328
00:29:00,909 --> 00:29:05,710
zones so zones allow you to basically
define security settings for different

329
00:29:05,710 --> 00:29:12,849
groups of sides and it turns out that
the protected mode and also a PM is not

330
00:29:12,849 --> 00:29:17,168
enabled if a page is considered to be
part of the local internet zone all the

331
00:29:17,169 --> 00:29:23,289
trusted sites zone so every time your
page is considered considered to be part

332
00:29:23,289 --> 00:29:29,229
of this zone it's running it's raining
outside of the sandbox and it's rendered

333
00:29:29,229 --> 00:29:36,099
in the 32-bit process as well so this
was first documented in 2010 and in a

334
00:29:36,099 --> 00:29:42,820
paper published by Verizon and the basic
idea is to follow so once you get code

335
00:29:42,820 --> 00:29:47,918
execution in your first stage payload
you you're basically i'm starting a

336
00:29:47,919 --> 00:29:52,210
local web server which delivers your
same exploit again and then you just

337
00:29:52,210 --> 00:29:58,840
redirect IE to this web server and by
since is redirected to localhost it's

338
00:29:58,840 --> 00:30:03,279
automatically considered to be in the
local intranet zone so it's rendered

339
00:30:03,279 --> 00:30:08,200
outside of the sandbox here so you just
triggered the exploit again and then you

340
00:30:08,200 --> 00:30:13,929
get code execution outs outside of the
sandbox and this was as i said already

341
00:30:13,929 --> 00:30:22,539
exploited several times in the past so
the verizon guys dated vdi exploited the

342
00:30:22,539 --> 00:30:28,869
same vulnerability during the poem for
fun contests in 2014 for example and the

343
00:30:28,869 --> 00:30:33,428
the Advisory published by DC is pretty
interesting because you can see the

344
00:30:33,429 --> 00:30:38,649
response from Microsoft which where they
state that it does not meet the bar for

345
00:30:38,649 --> 00:30:45,008
security servicing and instead of fixing
the back they they they did a good

346
00:30:45,009 --> 00:30:50,320
recommendation and their recommendation
to mitigate this issue is to use EPM so

347
00:30:50,320 --> 00:30:56,019
the enhanced protected mode which we are
targeting so why does EPM protect

348
00:30:56,019 --> 00:31:01,690
against that so EPM is based on a
container and kept container uses the

349
00:31:01,690 --> 00:31:09,039
concept of network isolation and network
isolation basically prevents the sandbox

350
00:31:09,039 --> 00:31:13,960
process from receiving new network
connections and it should also prevent

351
00:31:13,960 --> 00:31:14,680
you from

352
00:31:14,680 --> 00:31:18,790
all the sandbox process from sending on
establishing new connections to the

353
00:31:18,790 --> 00:31:26,080
local machine so we were thinking about
that and I mean in general we are not

354
00:31:26,080 --> 00:31:31,149
restricted to local holes so all we want
to do is we want to get a domain name

355
00:31:31,150 --> 00:31:34,570
which is to be controlled which is
considered to be part of the local

356
00:31:34,570 --> 00:31:41,590
internet zone so in and it doesn't have
to be localhost so we were we were

357
00:31:41,590 --> 00:31:46,330
trying to find out how IE actually
decided to the side as part of the trust

358
00:31:46,330 --> 00:31:52,929
of the of the local internet zone and
there's one really simple rule which is

359
00:31:52,930 --> 00:31:57,520
called the plain wholesome rule which
basically says if there is if the domain

360
00:31:57,520 --> 00:32:02,889
name of the URL doesn't contain any
periods it's automatically mapped into

361
00:32:02,890 --> 00:32:08,590
the local internet zone so it all comes
down to are we actually able to register

362
00:32:08,590 --> 00:32:13,750
in somehow a new domain name without any
periods which still points to an

363
00:32:13,750 --> 00:32:19,780
external IP address we control and it
turns out yes that's possible and you

364
00:32:19,780 --> 00:32:24,910
can do that by duke i doing local
netbios name spoofing so again this is

365
00:32:24,910 --> 00:32:29,530
not a new technique it was as far as i
know first implemented in fox close hot

366
00:32:29,530 --> 00:32:35,530
potato exploit and they used it for the
purpose of local privilege escalation so

367
00:32:35,530 --> 00:32:41,260
netbios name service or n dns is a USB
based proper you unity based protocol

368
00:32:41,260 --> 00:32:46,990
and it's used as a fallback mechanism if
dns fails so you can just do a dns

369
00:32:46,990 --> 00:32:51,610
lookup and after a few seconds of the
the hostname can't resolve you see all

370
00:32:51,610 --> 00:32:58,780
these UDP broadcast packets being said
and during if you do normal netbios name

371
00:32:58,780 --> 00:33:01,660
spoofing like in a penetration test

372
00:33:01,660 --> 00:33:06,880
what you do is you just look for these
request packets you take the 16-bit

373
00:33:06,880 --> 00:33:13,120
transaction ID from the packet and you
take a response however compared to the

374
00:33:13,120 --> 00:33:17,110
local scenario we have a river big
difference because in the local scenario

375
00:33:17,110 --> 00:33:22,750
you don't see these outgoing UDP packets
so you can easily trigger trigger this

376
00:33:22,750 --> 00:33:23,810
and dns record

377
00:33:23,810 --> 00:33:28,669
but you won't see that the the outgoing
packets and that also means you don't

378
00:33:28,670 --> 00:33:33,680
see the transaction ining but in order
to send a valid response

379
00:33:34,820 --> 00:33:40,429
you have to send the the right front
section idea obviously so but what you

380
00:33:40,430 --> 00:33:44,990
can do is you can just brute faucet
right so you trigger the trigger one of

381
00:33:44,990 --> 00:33:50,420
these and DNS request packet and then
you just flat the locals with response

382
00:33:50,420 --> 00:33:54,500
packets with all different kinds of
transaction IDs until you get the right

383
00:33:54,500 --> 00:33:57,320
one

384
00:33:57,320 --> 00:34:05,570
so this is just how one of these nds
packets looks like so if you listen

385
00:34:05,570 --> 00:34:10,940
carefully to until now what I said you
would think that this technique local

386
00:34:10,940 --> 00:34:14,270
and Venus cool thing shouldn't be
possible from the EPM sandbox right

387
00:34:14,270 --> 00:34:18,469
because there is this concept of network
isolation which should prevent it from

388
00:34:18,469 --> 00:34:24,500
sending packets to the local machine
however it turns out there are

389
00:34:24,500 --> 00:34:30,080
exceptions so it it is actually possible
to send UDP packets to local one port

390
00:34:30,080 --> 00:34:35,239
1337 so in the end we can just do
locally and Vienna spoofing from within

391
00:34:35,239 --> 00:34:42,229
the app container sandbox and we didn't
exactly set so we we we try to register

392
00:34:42,230 --> 00:34:47,179
a new domain name without any periods
which pointed to an arbitrary IP address

393
00:34:47,179 --> 00:34:53,810
which we controlled and we redirected IE
to this new domain name and then we

394
00:34:53,810 --> 00:34:58,040
exploited the same back which we
exploited in the beginning but this time

395
00:34:58,040 --> 00:35:02,660
in a 32-bit Bruce process and that
effectively gave us code execution

396
00:35:02,660 --> 00:35:07,339
outside of the sandbox and again we
didn't use any memory corruption any

397
00:35:07,340 --> 00:35:18,170
tail and shellcode anyone not so now
basically we are already done but we had

398
00:35:18,170 --> 00:35:23,570
still this requirement of bypassing amat
and so let's see if we if you actually

399
00:35:23,570 --> 00:35:26,180
affected by them at all

400
00:35:26,180 --> 00:35:32,660
so it turns out we are so if you run the
exploit under Emmett and you will see in

401
00:35:32,660 --> 00:35:36,950
the locks that the feature called attack
surface reduction noise or

402
00:35:36,950 --> 00:35:41,720
is actually preventing a life plug from
running and ASR is a feature which

403
00:35:41,720 --> 00:35:47,209
basically black list number of modules
which are considered to be dangerous

404
00:35:47,210 --> 00:35:51,710
basically so they're doing that by
hooking the load library X function and

405
00:35:51,710 --> 00:35:57,380
then comparing the name of the loaded
module against the black list and in our

406
00:35:57,380 --> 00:36:02,839
case they detect the use of the
wscript.shell activex control which we

407
00:36:02,839 --> 00:36:07,310
are using to execute system commands so
let's see if they're the way of

408
00:36:07,310 --> 00:36:13,730
bypassing that again we did some
research on what people used in the past

409
00:36:13,730 --> 00:36:21,680
and there's a quite nice article by fire
i am about their latest and that bypass

410
00:36:21,680 --> 00:36:26,509
which lists all the previous work on
Emmett bypasses and ways to disable

411
00:36:26,510 --> 00:36:34,220
limit so you can get a nice overview
they are however the difference to most

412
00:36:34,220 --> 00:36:40,009
of these techniques is actually that in
in the usual case you already have the

413
00:36:40,010 --> 00:36:44,240
ability to execute Rob gadgets or you
have the ability to execute some small

414
00:36:44,240 --> 00:36:49,310
shell code which you can then use to
disable ended however in our case we

415
00:36:49,310 --> 00:36:54,140
don't have code execution yet so it's
the image is actually preventing us from

416
00:36:54,140 --> 00:36:59,779
from instantiating the activex control
and only after we got got the activex

417
00:36:59,780 --> 00:37:05,450
control running we get code execution so
we can't use any Rob gadgets for example

418
00:37:05,450 --> 00:37:11,419
and however we have our really powerful
rewrite primitive so let's see if you

419
00:37:11,420 --> 00:37:21,950
can use that in order to disable Emmett
so if you take a look at the code and in

420
00:37:21,950 --> 00:37:26,899
particular at the place where the ASR
check is implemented you're running into

421
00:37:26,900 --> 00:37:29,270
this small check here

422
00:37:29,270 --> 00:37:34,550
so what it does is it basically read the
point of from a known location memory it

423
00:37:34,550 --> 00:37:40,460
decodes the point are using the decode .
API the point is pointing to 2a

424
00:37:40,460 --> 00:37:45,800
conflicts tracked structure on the heap
and offset 28 there's another point to

425
00:37:45,800 --> 00:37:50,480
point to a flag in memory and if this
flag is actually

426
00:37:50,480 --> 00:37:57,200
not set to zero and the ASR checks up
phone and similar checks can be found

427
00:37:57,200 --> 00:38:03,169
for other image features as well so the
idea is ok we have a read/write

428
00:38:03,170 --> 00:38:08,780
primitive so maybe we can just overwrite
this flag right that doesn't work

429
00:38:08,780 --> 00:38:13,640
because the the people who wrote em and
they thought about this attack and they

430
00:38:13,640 --> 00:38:18,500
said the memory which is storing the
flag read-only ok so maybe you can

431
00:38:18,500 --> 00:38:23,930
override the the naval protection . are
pointing to the flag and pointed to some

432
00:38:23,930 --> 00:38:27,919
other memory autosum some fake flag
that's possible

433
00:38:27,920 --> 00:38:31,430
however you still have to find the
address of the complex direct on the

434
00:38:31,430 --> 00:38:32,480
heat

435
00:38:32,480 --> 00:38:38,480
there's a reference as i said but the
pointer to this structure is actually

436
00:38:38,480 --> 00:38:45,619
obfuscator good using the included . api
functions so let's take a look at that

437
00:38:45,619 --> 00:38:50,450
so if you take a look at the msdn
documentation for encode pointer they

438
00:38:50,450 --> 00:38:55,009
give you some hints on what they
actually do when they when they obvious

439
00:38:55,010 --> 00:39:02,330
k pointers so they say . obvious cated
was a secret value and this secret value

440
00:39:02,330 --> 00:39:10,580
is different for every closest so that
means it's the same in our process for

441
00:39:10,580 --> 00:39:13,009
all the cold . our calls

442
00:39:13,010 --> 00:39:18,740
so the question is can we maybe use our
read primitive to leaks the secret value

443
00:39:18,740 --> 00:39:23,479
somehow because if we manage to do that
we would be able to decode any obvious

444
00:39:23,480 --> 00:39:29,720
skated pointers and the closest so we
took a look at the implementation of

445
00:39:29,720 --> 00:39:34,939
these and encoded pointers which can be
found in arterial and cold . and our Tod

446
00:39:34,940 --> 00:39:40,070
called . are respectively and it turns
out they're using a 32-bit secret value

447
00:39:40,070 --> 00:39:45,320
which is also true for 64-bit processors
by the way and they obtain that directly

448
00:39:45,320 --> 00:39:46,400
from the colonel

449
00:39:46,400 --> 00:39:51,350
so they just do a call to ZW carry
information process and once they got

450
00:39:51,350 --> 00:39:55,310
the secret they're using it to do the
calculation and then just throw throw

451
00:39:55,310 --> 00:39:59,660
the way so it's not like it's stored at
some static location where you could

452
00:39:59,660 --> 00:40:03,740
leave it for example so it doesn't seem
to be possible to

453
00:40:03,740 --> 00:40:08,390
read the secret value from memory so
let's take a look at the implementation

454
00:40:08,390 --> 00:40:16,700
of and sophisticated pointers so this is
some so to code for the 64-bit version

455
00:40:16,700 --> 00:40:24,169
of these functions so what they do is
they take the plane . er the XOR it with

456
00:40:24,170 --> 00:40:28,369
a secret value and then they right shift
the whole result the third number of

457
00:40:28,369 --> 00:40:35,240
bits to the right and the number of bits
right shifted depends on the secret

458
00:40:35,240 --> 00:40:40,129
value and this is most probably down in
order to prevent simple xor attacks

459
00:40:40,130 --> 00:40:44,720
because if they wouldn't do it like this
you could just take a encoded . of the

460
00:40:44,720 --> 00:40:48,529
corresponding plane . er export them
together and you could basically

461
00:40:48,530 --> 00:40:54,140
calculate the secret value however is
there are only three of possible right

462
00:40:54,140 --> 00:41:01,009
shift values in this case and which
turns out to be easily brute forcible so

463
00:41:01,010 --> 00:41:06,320
in the end what we do is we obtain a
pair of pointers so we obtain a pair of

464
00:41:06,320 --> 00:41:11,900
known encoded and corresponding plane
pointer from memory and then we are we

465
00:41:11,900 --> 00:41:17,000
iterate over all the three of possible
righteous values and we perform a

466
00:41:17,000 --> 00:41:23,270
partial decode . operation on the
encoded pointer from our parents and the

467
00:41:23,270 --> 00:41:27,980
result of that we XOR it was known
corresponding plane pointer which gives

468
00:41:27,980 --> 00:41:33,800
us a potential secret value it hasn't
doesn't have to be the the right one but

469
00:41:33,800 --> 00:41:37,580
it is a potential secret value and in
order to check if it's the right secret

470
00:41:37,580 --> 00:41:41,750
value we just performed the encode
operations so we take the plane . are

471
00:41:41,750 --> 00:41:47,480
encoded with this potential secret value
and make sure or check if it is the

472
00:41:47,480 --> 00:41:53,869
result is actually the encoded pointer
and this will eventually give you a

473
00:41:53,869 --> 00:41:59,180
secret value and most of the time you
will get the right secret value however

474
00:41:59,180 --> 00:42:06,410
there's a problem so due to the way it's
implemented due to the right shift to

475
00:42:06,410 --> 00:42:12,410
the rolling right shift there's a chance
that you actually encode or encoding the

476
00:42:12,410 --> 00:42:17,390
same . with different secret secret
values could in theory result in

477
00:42:17,390 --> 00:42:23,150
the same and coded . up which isn't a
problem in the normal implementation but

478
00:42:23,150 --> 00:42:25,160
since we are doing it backwards

479
00:42:25,160 --> 00:42:30,470
this can result in the scenario will be
where we where we find a secret value

480
00:42:30,470 --> 00:42:36,799
which is the wrong one which is bad
because once we use the wrong secret

481
00:42:36,800 --> 00:42:41,960
value to decode the pointer we get a
wrong . and we would crash so in order

482
00:42:41,960 --> 00:42:46,640
to bypass this what we do is we just use
a second pair so use another pair of

483
00:42:46,640 --> 00:42:52,700
plain and coded pointers and we try is a
found secret against that . up here and

484
00:42:52,700 --> 00:42:57,379
if if it matches and we know okay we can
be pretty sure that this is the right

485
00:42:57,380 --> 00:43:04,790
secret value so in order to find the
these pairs of encoded plane pointers

486
00:43:04,790 --> 00:43:11,090
you can basically take a look and in to
add into any module which is loaded

487
00:43:11,090 --> 00:43:16,670
we took we took a look in the am module
itself and it's quite easy to find these

488
00:43:16,670 --> 00:43:21,410
periods for example on this slide you
can see what they they actually store

489
00:43:21,410 --> 00:43:28,370
the null pointer in encoded form at a
static location in the data segments so

490
00:43:28,370 --> 00:43:32,779
we know the plane . it's now encoded . i
can be read from that location in memory

491
00:43:32,780 --> 00:43:36,980
and finding more . this is not that hard

492
00:43:36,980 --> 00:43:40,580
so in the white paper we have another
example on how to do how to find another

493
00:43:40,580 --> 00:43:46,970
pair in at 64 dealer and in general you
just search for the use of ankle . calls

494
00:43:46,970 --> 00:43:54,290
so now that we are able to leak the
secret value we are able to basically

495
00:43:54,290 --> 00:44:04,310
and skate all the pointers in memory so
what we do is we first leaked the ms64

496
00:44:04,310 --> 00:44:10,549
base address which is easy because
Emmett is hooking many functions such as

497
00:44:10,550 --> 00:44:15,860
NT protect virtual memory which is one
of them and so you just read the first

498
00:44:15,860 --> 00:44:20,000
few bites of that function and then
basically follow . us until until you

499
00:44:20,000 --> 00:44:26,300
find the base addressed and once we
found that we we leak the obvious

500
00:44:26,300 --> 00:44:30,799
created . from the data segment we
decode it using the

501
00:44:30,799 --> 00:44:35,959
the extracted secret value and that way
we find the address of the context

502
00:44:35,959 --> 00:44:40,399
structure on the heat and once we found
that we use are right primitive to

503
00:44:40,400 --> 00:44:45,559
override the neighborhood protection
pointer and we just just pointed to some

504
00:44:45,559 --> 00:44:47,959
memory which happens to contain no bites

505
00:44:47,959 --> 00:44:54,288
so in the end this is enough to bypass
Emmett and while the ASR check in this

506
00:44:54,289 --> 00:44:59,119
case and as I said before this this kind
of technique and probably also be used

507
00:44:59,119 --> 00:45:06,199
for all the other Emmett checks as well
so now we got code execution outside of

508
00:45:06,199 --> 00:45:11,929
the sandbox and we successfully disabled
them aswell so my conclusion

509
00:45:12,589 --> 00:45:17,449
first of all the the current patch
status so the type area neutering

510
00:45:17,449 --> 00:45:23,509
vulnerability was already fixed in a 16
or 63 and interesting is the same back

511
00:45:23,509 --> 00:45:29,900
course already fixed in the track record
engine since its publication on on get

512
00:45:29,900 --> 00:45:30,829
up

513
00:45:30,829 --> 00:45:36,859
so it looks like this was some kind of
overlooked security fix backcourt maybe

514
00:45:36,859 --> 00:45:44,089
the EPM sandbox escape using at the
local NetBIOS names roofing was fixed in

515
00:45:44,089 --> 00:45:49,578
ms 1607 seven and interesting use the
same bag was found by young you and was

516
00:45:49,579 --> 00:45:55,069
used for a bad time research which he
presented this year blackhead the god

517
00:45:55,069 --> 00:46:01,038
mode single now by technique was fixed
an m16 or 51 and interesting me they

518
00:46:01,039 --> 00:46:07,880
instead of reintroducing this-this-this
hashing mechanism what they do now is a

519
00:46:07,880 --> 00:46:14,420
used very protected policy API function
which is used for a sec exactly this

520
00:46:14,420 --> 00:46:19,459
purpose so trying to prevent people from
modifying certain data which is

521
00:46:19,459 --> 00:46:26,089
considered to be important and last but
not least the Emmett bypass is not fixed

522
00:46:26,089 --> 00:46:32,569
and what i heard is there are no plans
to address it in the future so it looks

523
00:46:32,569 --> 00:46:36,890
like if you've got the ability to read
and write memory which I must say the

524
00:46:36,890 --> 00:46:40,939
really powerful primitive you first have
to get but if you got that then you can

525
00:46:40,939 --> 00:46:44,160
easily bypass Emmett

526
00:46:44,160 --> 00:46:50,250
so my conclusion is of course modern
exploit mitigations increase the effort

527
00:46:50,250 --> 00:46:56,069
quite a lot into to do in order to build
exploits and however the right one

528
00:46:56,069 --> 00:46:57,450
ability at hand

529
00:46:57,450 --> 00:47:04,020
it's still possible to buy this many of
these medications and mean many people

530
00:47:04,020 --> 00:47:11,400
things that once once CFG is really
really hard and there are no easy ways

531
00:47:11,400 --> 00:47:16,589
of bypassing CFG and the exploitation
will be over whatever just keep in mind

532
00:47:16,589 --> 00:47:22,349
that it's not really necessary to take
over the control slow so sometimes it's

533
00:47:22,349 --> 00:47:27,690
much it's it's also possible to just
modify some data and that way get

534
00:47:27,690 --> 00:47:32,460
basically get all want to know all what
you want just people did in the past

535
00:47:32,460 --> 00:47:36,869
because it's of course much easier to to
redirect to your own shell code and

536
00:47:36,869 --> 00:47:43,619
implement what you want to do but it's
not necessarily required and general

537
00:47:43,619 --> 00:47:47,099
about this kind of data only attacks
where you get the ability to read and

538
00:47:47,099 --> 00:47:53,190
write arbitrary memory you can use them
to bypass many medications and in

539
00:47:53,190 --> 00:47:56,940
general what you you can target
basically any functionality and in there

540
00:47:56,940 --> 00:48:03,420
are functionalities which are obvious
like like instantiate in an unsafe

541
00:48:03,420 --> 00:48:09,390
activex controls that's really dangerous
thing to have in your code obviously and

542
00:48:09,390 --> 00:48:13,799
all if you take a look at other browsers
like for example firefox and that you

543
00:48:13,799 --> 00:48:18,089
have the ability to execute JavaScript
code in in chrome context which gives

544
00:48:18,089 --> 00:48:24,390
you all the all the access to the
operating system basically but there are

545
00:48:24,390 --> 00:48:28,589
other functionalities which don't seem
that obvious but they can still be

546
00:48:28,589 --> 00:48:34,558
targeted and in general so that's just
my personal opinion but I think that

547
00:48:34,559 --> 00:48:41,549
once once all these CSI solutions major
and all the easy bypasses are gone if

548
00:48:41,549 --> 00:48:46,740
that happens I don't know then I think
then more and more people will actually

549
00:48:46,740 --> 00:48:52,259
make use of these data only attacks
because they they are really hard to

550
00:48:52,260 --> 00:48:57,900
defend against so you're some some of
the rest

551
00:48:57,900 --> 00:49:01,620
Prince works and yeah that's it thank
you very much

