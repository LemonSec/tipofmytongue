1
00:00:00,000 --> 00:00:12,120
thank you very much

2
00:00:12,929 --> 00:00:15,830
it's nice to be back and

3
00:00:15,830 --> 00:00:21,080
too nice to finally also be at this
conference for the $YEAR s many years

4
00:00:21,080 --> 00:00:29,449
and he's already exists now L so she
already said the title of my talk is iOS

5
00:00:29,450 --> 00:00:41,269
10 Colonel he previz attended so when
the cfp 4g seg was released i was

6
00:00:41,269 --> 00:00:50,000
thinking about what to submit and I fast
Lee got the idea that I would submit on

7
00:00:50,000 --> 00:00:55,760
the iOS Colonel heap and the reason for
that is that my last talked about the is

8
00:00:55,760 --> 00:01:02,239
Colonel he was around the time of I was
five and a lot of details had changed

9
00:01:02,239 --> 00:01:08,060
between I was five and I was nine which
was the one that was available at the

10
00:01:08,060 --> 00:01:15,350
time of the cfp submission and a lot of
changes have not been documented

11
00:01:15,350 --> 00:01:21,050
anywhere there are few changes that are
documented by for example charge $MONEY

12
00:01:21,050 --> 00:01:26,990
a month in the cosmos block but it's
only just one thing then depending if

13
00:01:26,990 --> 00:01:31,640
you follow some certain jailbreakers on
twitter you might have seen some tweets

14
00:01:31,640 --> 00:01:37,010
about certain things that changed but
there was absolutely no central place at

15
00:01:37,010 --> 00:01:40,520
least a public place where you would see
all the changes that were made to the

16
00:01:40,520 --> 00:01:42,950
heap between I was five and nine

17
00:01:42,950 --> 00:01:48,350
of course I wanted to make the the talk
more interesting to get voted so I said

18
00:01:48,350 --> 00:01:51,890
it's the iOS 10 Colonel he / revisited

19
00:01:51,890 --> 00:01:56,720
but of course at this time there was
actually no is 10 so i didn't know what

20
00:01:56,720 --> 00:02:04,370
I was getting into the interesting thing
is when i submitted I assume that apple

21
00:02:04,370 --> 00:02:08,000
would do the apple thing just from
version to version that would change

22
00:02:08,000 --> 00:02:13,220
some things some slide sins and so I
expected that when the bitter is

23
00:02:13,220 --> 00:02:18,019
released that they would have changed a
few things but it wouldn't be major

24
00:02:18,019 --> 00:02:21,019
changes now oh boy was I wrong

25
00:02:21,590 --> 00:02:26,460
now we will see later that they actually
made bigger changes

26
00:02:26,460 --> 00:02:35,340
so to the heap between I was nine and
ten then in most of the steps before so

27
00:02:35,340 --> 00:02:43,590
little disclaimer travel research
especially on new systems like I was ten

28
00:02:43,590 --> 00:02:51,480
arm is quite hard because there's no
public jailbreak and I really don't like

29
00:02:51,480 --> 00:02:56,340
traveling with private jailbreaks two
countries like Singapore so sorry for

30
00:02:56,340 --> 00:02:56,910
that

31
00:02:56,910 --> 00:03:03,660
so that means that most of this research
was done while I was traveling and I

32
00:03:03,660 --> 00:03:10,079
used most of the time Mecca with sarah
for that but I then took a decompiled

33
00:03:10,080 --> 00:03:16,050
colonel and compared and the
implementation is more or less identical

34
00:03:16,050 --> 00:03:21,960
so whatever i'm saying it might be
slightly wrong because I mostly

35
00:03:21,960 --> 00:03:25,980
concentrated on Sierra but it wouldn't
be too wrong

36
00:03:28,500 --> 00:03:36,150
also keep in mind the whole thing is
beat our Apple keeps sneaking in changes

37
00:03:36,150 --> 00:03:40,740
sometimes in the very last Peter they
used to always fix security box in the

38
00:03:40,740 --> 00:03:47,130
very last beta but in the past as we
will see later on they but put one big

39
00:03:47,130 --> 00:03:52,049
security mitigations in the very last
beater so it was not available for us

40
00:03:52,050 --> 00:03:54,360
early on but we come to that later

41
00:03:54,360 --> 00:04:00,480
so the end of this talk is therefore
first I give you a short reminder what

42
00:04:00,480 --> 00:04:03,810
the iOS Colonel heap is what it looks
like

43
00:04:03,810 --> 00:04:09,690
then I present shortly about how it
looked like in the iOS 5 days before all

44
00:04:09,690 --> 00:04:14,160
the changes and then I'm going through
all the team changes between six and

45
00:04:14,160 --> 00:04:21,298
nine and in the end you will see what's
up coming in deep trouble he'd for iOS

46
00:04:21,298 --> 00:04:29,190
10 so what is this is currently if you
have prior knowledge this will be

47
00:04:29,190 --> 00:04:33,330
nothing new so normally when we call
when we talk about the IRS Colonel heap

48
00:04:33,330 --> 00:04:38,430
we usually assume we are talking about
the zone a locator because that's the

49
00:04:38,430 --> 00:04:39,630
most used

50
00:04:39,630 --> 00:04:45,060
ok ty inside the colonel and the idea of
the zone calculator is that all the heat

51
00:04:45,060 --> 00:04:51,960
memory is divided into zones and the
ideas that zone groups memory groups

52
00:04:51,960 --> 00:04:56,070
allocations of a specific size so
there's one zone for this kind of memory

53
00:04:56,070 --> 00:04:59,070
one's own for this kind of memory and so
on and so on

54
00:05:00,690 --> 00:05:06,090
it's furthermore that inside alone when
you create a zone you define how big the

55
00:05:06,090 --> 00:05:11,489
elements are this cannot change during
the long time so all elements inside

56
00:05:11,490 --> 00:05:20,010
one's own are always of the same size
when you look at the code you will see

57
00:05:20,010 --> 00:05:25,260
that they are used like this when you
try to allocate something you tell the

58
00:05:25,260 --> 00:05:30,300
allocator oh I want to look at something
in this zone and when you free later on

59
00:05:30,300 --> 00:05:34,560
you have to also tell it oh I want to
free this pointer please put it back in

60
00:05:34,560 --> 00:05:36,750
this zone

61
00:05:36,750 --> 00:05:42,750
the reason for that is that from a
pointer the colonel does not know what

62
00:05:42,750 --> 00:05:44,580
kind of loan this belongs to

63
00:05:44,580 --> 00:05:51,090
so the caller has to keep track of that
with the zone ellicott alone there's no

64
00:05:51,090 --> 00:05:54,750
way to have a variable links a location
because everything needs to be the same

65
00:05:54,750 --> 00:06:02,430
size when you run or 60 iOS that is
jailbroken you can run the tool set

66
00:06:02,430 --> 00:06:06,480
print which will give you an output of
all these zones that exist in your

67
00:06:06,480 --> 00:06:13,080
system at at the moment and as you can
see there are a lot of them and this is

68
00:06:13,080 --> 00:06:15,000
just a short

69
00:06:15,000 --> 00:06:21,000
yeah at and substrate of all the short
short extract of all these zones and you

70
00:06:21,000 --> 00:06:25,050
can see they have actually names and
these names are internally registered so

71
00:06:25,050 --> 00:06:29,250
from the name usually already know what
kind of data element is in there

72
00:06:30,150 --> 00:06:33,539
de que el agua unused here specially
come to that later

73
00:06:33,540 --> 00:06:43,920
so inside the heap out in his own a
locator all the memory that is giving

74
00:06:43,920 --> 00:06:49,860
back by his own a locator is from the
zone map which is a region that the

75
00:06:49,860 --> 00:06:51,370
colonel registers are

76
00:06:51,370 --> 00:06:57,070
reserved on the on the physical memory
space and it's about a quarter the

77
00:06:57,070 --> 00:07:02,290
defaults a quarter of the physical
memory size so on a 1 gigabyte system

78
00:07:02,290 --> 00:07:10,090
this zone map is reserved to be 256
megabytes it's reserved very early on

79
00:07:10,090 --> 00:07:16,090
during the colonel starts so in the past
the problem here was that because there

80
00:07:16,090 --> 00:07:26,469
was no is Lauren so the position of the
storm was kinda yeah pretty find so now

81
00:07:26,470 --> 00:07:31,660
when memory is returned by the locator
it's returned from pages that are for

82
00:07:31,660 --> 00:07:37,900
from within the zone map and zone always
has his number of pages assigned to it

83
00:07:37,900 --> 00:07:43,570
and whenever his own is full it has to
grow and for this growing there some

84
00:07:43,570 --> 00:07:50,680
specific location size defined so most
zones or at least in the past would

85
00:07:50,680 --> 00:07:56,349
always grow by one page at the time when
they ran out of space but in reality

86
00:07:56,349 --> 00:08:02,440
entitled journal how big this allocation
size is is determined by a very simple

87
00:08:02,440 --> 00:08:06,370
algorithm that just try to find out
between one and five pages

88
00:08:06,940 --> 00:08:13,419
what is the optimal way to grow because
keep in mind every element in the zone

89
00:08:13,419 --> 00:08:19,900
is always the same size so when you
initialize a zone with 100 bite objects

90
00:08:19,900 --> 00:08:25,270
or so and you have a focal by page then
you have 96 bytes in the end that are

91
00:08:25,270 --> 00:08:31,000
just lying around so basically the the
colonel he presides when it starts his

92
00:08:31,000 --> 00:08:37,179
own if the waste of 96 x in this case
can be optimized by making the location

93
00:08:37,179 --> 00:08:40,299
size two or three or four five

94
00:08:40,299 --> 00:08:47,380
the other thing that is only visible on
later versions is that on all the new

95
00:08:47,380 --> 00:08:52,689
64-bit devices that have a lot of memory
i believe the the cutting points 1

96
00:08:52,690 --> 00:08:58,209
gigabyte so the device more when than
one gigabyte of memory the colonel

97
00:08:58,209 --> 00:09:03,699
suddenly switches to 16 kilobyte pages
so kernel memory is 64 kilobytes

98
00:09:04,570 --> 00:09:10,270
16 kilobyte sorry and all the other
devices use normal four kilobyte pages

99
00:09:10,270 --> 00:09:18,130
so now you would wonder ok but we always
need some kind of dynamic links at

100
00:09:18,130 --> 00:09:21,400
locations so how does that work

101
00:09:21,400 --> 00:09:27,250
this works by not using the zona located
directly but instead the code has to use

102
00:09:27,250 --> 00:09:36,640
things like ka-lok or monologue so kayla
is a wrapper around that log and the

103
00:09:36,640 --> 00:09:45,010
idea here is that it allows dynamic
locations where you see later how but

104
00:09:45,010 --> 00:09:51,640
the color of k LMK free must remember
how big the block was he was allocating

105
00:09:51,640 --> 00:09:56,050
how many fries the block later on he has
to tell the system all this was a 100 by

106
00:09:56,050 --> 00:10:02,079
block we see later why Moloch on the
other hand keeps extra internal meter

107
00:10:02,080 --> 00:10:06,190
data so my life is just like it normally
no Moloch and free you just get the

108
00:10:06,190 --> 00:10:08,380
pointer and you allocate a new free

109
00:10:08,380 --> 00:10:16,600
another nice thing that most people
actually don't know about this that by

110
00:10:16,600 --> 00:10:22,960
default OS X and iOS come with Colonel
boot arguments that allow Colonel heap

111
00:10:22,960 --> 00:10:30,700
debugging so for our recent security
researchers these things that you

112
00:10:30,700 --> 00:10:34,750
normally are interested in is the
so-called sewn corruption logging that

113
00:10:34,750 --> 00:10:40,690
you can activate by using the dish set C
boot argument and when you do that you

114
00:10:40,690 --> 00:10:48,580
can ya select one zone that you would
like to lock in you selected by name for

115
00:10:48,580 --> 00:10:55,330
example catalog . 128 and you can
specify how many entries you want to

116
00:10:55,330 --> 00:11:01,210
keep in that lock so the thing is an iOS
you cannot really make use of that

117
00:11:01,210 --> 00:11:05,200
without the colonel exploit because
Apple does not allow you to specify boot

118
00:11:05,200 --> 00:11:09,220
arguments but the moment you have a
jailbroken device and you can execute

119
00:11:09,220 --> 00:11:14,680
code into the kernel or can at least
corrupt memory in the journal or change

120
00:11:14,680 --> 00:11:17,849
memory in the colonel then you can
activate it features on the

121
00:11:17,850 --> 00:11:24,449
by and actually make use of them in iOS
and always extra just set these good

122
00:11:24,449 --> 00:11:27,300
arguments and then you reboot your
system and then you can do the same

123
00:11:27,300 --> 00:11:34,500
thing in always X so let's say we
activate this corruption mode logging

124
00:11:34,500 --> 00:11:39,360
what happens then is that basically the
colonel allocates one block of memory

125
00:11:39,360 --> 00:11:44,250
with the amount of records that we
specified and then it starts recording

126
00:11:44,250 --> 00:11:49,889
everything LOL ok shin every single day
location it starts to record the point

127
00:11:49,889 --> 00:11:56,220
of us allocated or Delocated it starts
to allocate to lock the back-trace at

128
00:11:56,220 --> 00:11:58,529
the moment of the location of the
location

129
00:11:58,529 --> 00:12:02,639
this is very nice for you as someone who
wants to do a control of the heap layout

130
00:12:02,639 --> 00:12:07,829
because you can record the heat actions
and you can see all my export is not

131
00:12:07,829 --> 00:12:12,899
working because that strange code pad
actually located something so let's try

132
00:12:12,899 --> 00:12:16,350
to make it not allocate this or do
something else

133
00:12:16,350 --> 00:12:22,649
the thing is internally all of this is
stored in a so-called BTW lock that in

134
00:12:22,649 --> 00:12:28,529
earlier versions of iOS has always been
just a linear list for around around

135
00:12:28,529 --> 00:12:32,430
robbing list also a ring buffer and you
can just dump it

136
00:12:32,430 --> 00:12:36,899
so that's the problem year Apple does
not provide you with the facility to get

137
00:12:36,899 --> 00:12:41,250
this out of kernel memory so as a
researcher you have to get yourself out

138
00:12:41,250 --> 00:12:47,279
of kernel memory when you do that you
can do a lot of analyzes on with this

139
00:12:47,279 --> 00:12:52,769
and I presented before that I have this
visualizer for this thing so this year

140
00:12:52,769 --> 00:13:00,509
is basically a little JavaScript tool
that gets a log and visualizes what it

141
00:13:00,509 --> 00:13:05,069
sees you can see here the pages that
were allocated the different colors

142
00:13:05,069 --> 00:13:09,479
means they were different located with
different code passes the blue stuff are

143
00:13:09,480 --> 00:13:13,980
basically free blocks and when you have
over something you can see the

144
00:13:13,980 --> 00:13:19,680
back-trace the back-trace in this case
is symbolized by just looking at the

145
00:13:19,680 --> 00:13:25,589
symbols from the kernel debugging code
that Apple releases for four weeks

146
00:13:25,589 --> 00:13:30,059
because this year it's taken from our
mistakes on iOS you can just do the same

147
00:13:30,059 --> 00:13:31,260
and just

148
00:13:31,260 --> 00:13:36,300
symbolized the colonel yourself or use
some tool to port symbols from 06 to iOS

149
00:13:36,300 --> 00:13:40,199
and then you have also nice names for
the back-trace what you see here is

150
00:13:40,200 --> 00:13:46,890
something I do during my iOS trainings
what you see here is basically result of

151
00:13:46,890 --> 00:13:52,230
a colonel he thinks sweet you see that
someone filled the whole heap with data

152
00:13:52,230 --> 00:13:57,150
and then you see in regular intervals
you see free blocks the blue ones so

153
00:13:57,150 --> 00:14:01,740
every cert block has basically freed to
prove keep control

154
00:14:02,460 --> 00:14:11,190
ok so this is a general idea of what the
he looks like from a user's point of

155
00:14:11,190 --> 00:14:12,120
view

156
00:14:12,120 --> 00:14:19,650
let's go to the internals and internally
and don't be scared of this a lot of

157
00:14:19,650 --> 00:14:25,020
code here are the structure now there's
not much code on the slides the idea

158
00:14:25,020 --> 00:14:29,790
here is to tell you everything that is
registered with the colonel the

159
00:14:29,790 --> 00:14:33,599
information about this stone is stored
in his own structure that looks a lot

160
00:14:33,600 --> 00:14:38,970
like this but this changed over the
years and this is actually stolen from

161
00:14:38,970 --> 00:14:45,960
the 10 75 source code that is around the
time of iOS 5 but around this time the

162
00:14:45,960 --> 00:14:51,000
iOS source code and the OSX articles
were not so synced so this structure is

163
00:14:51,000 --> 00:14:55,710
most likely not exactly the same that is
used in iOS but it looks very similar to

164
00:14:55,710 --> 00:14:56,580
this

165
00:14:56,580 --> 00:15:00,720
what you can see here mostly is that a
lot of this information is what you get

166
00:15:00,720 --> 00:15:05,730
to userspace when you call the
stepparent utility and the other stuff

167
00:15:05,730 --> 00:15:10,440
is most the for dealing with stone
internally

168
00:15:10,440 --> 00:15:16,620
interestingly here is that all these own
structures are stored on the zone heap

169
00:15:16,620 --> 00:15:21,090
itself so this is zone called zones and
they're all the stone structures are

170
00:15:21,090 --> 00:15:24,450
located in to that it's a chicken and
egg thingy

171
00:15:24,450 --> 00:15:32,490
ok now let's look at more detail when
you have a heap you have always located

172
00:15:32,490 --> 00:15:38,970
and not allocated blocks and the idea
here in the run time of iOS 5 days when

173
00:15:38,970 --> 00:15:40,400
you have a free

174
00:15:40,400 --> 00:15:49,189
block then the block is basically not
cleared you have a pointer in the

175
00:15:49,190 --> 00:15:55,400
beginning of that block that is the
point to the next free block and in the

176
00:15:55,400 --> 00:15:59,420
zone structure there's basically a
pointer that points to the very first

177
00:15:59,420 --> 00:16:05,810
free element and the idea here is for
one's own you have one such pointer so

178
00:16:05,810 --> 00:16:13,069
every single free block in that zone is
reachable through a one linked list

179
00:16:13,070 --> 00:16:19,460
single link list problem here's there's
no way to go back so there when you when

180
00:16:19,460 --> 00:16:24,260
you have a heating element you don't
know what zone it came from was only

181
00:16:24,260 --> 00:16:28,640
belongs to and this is a problem
especially for performance reasons

182
00:16:28,640 --> 00:16:33,080
because garbage collection on a used he
was very slow that way

183
00:16:36,530 --> 00:16:40,790
let's come to the location so as I said
when you have when you locate something

184
00:16:40,790 --> 00:16:45,560
the normal cases you have a free list
and we just take the first element from

185
00:16:45,560 --> 00:16:51,199
the free list return that and it's ok
but at some point you're free list will

186
00:16:51,200 --> 00:16:56,150
be empty because everything is allocated
so this means the system needs to grow

187
00:16:56,150 --> 00:17:02,780
this zone so a new pages edit and then
all the elements in that page i put into

188
00:17:02,780 --> 00:17:07,730
the free list so back then what would
happen is there would put the first

189
00:17:07,730 --> 00:17:13,040
moment the Second Amendment search for
element into the free list so that in

190
00:17:13,040 --> 00:17:17,839
the end you have a freelance that is
lethal the last frayed one so the last

191
00:17:17,839 --> 00:17:23,599
in a page is returned first so this
means on a normal i OS kernel heat when

192
00:17:23,599 --> 00:17:27,619
you allocate something in the worst new
memory it will always be given back to

193
00:17:27,619 --> 00:17:35,899
you in a backward fashion so when you
locate you get of course the element the

194
00:17:35,900 --> 00:17:41,030
pointer is changed and again and and so
on

195
00:17:41,030 --> 00:17:45,830
so basically you will get the memory
backward in the backward fashion page by

196
00:17:45,830 --> 00:17:53,610
page so now let's go back to dynamic
allocations so we need a dynamic Alex

197
00:17:53,610 --> 00:17:57,299
asians and I always said we use catalog
for that

198
00:17:57,299 --> 00:18:03,750
so the idea is now that ka-lok uses own
a locator internally so the first thing

199
00:18:03,750 --> 00:18:08,309
you need to do is it registers a lot of
zones you can see them they're like

200
00:18:08,309 --> 00:18:15,720
Kellogg 16 32 and so on and so on and
the idea now is that when you allocate

201
00:18:15,720 --> 00:18:21,780
for example 17 bites it will check out
what is the size 17 or it does not fit

202
00:18:21,780 --> 00:18:27,750
in a 16-byte block so i have to put in a
story to buy block so then que ella will

203
00:18:27,750 --> 00:18:33,929
basically get one element from the
catalog 32 and return that to the user

204
00:18:33,929 --> 00:18:40,710
and this means now that the last 15
months in that block actually unused

205
00:18:40,710 --> 00:18:46,260
they're like padding that is not never
used it also means when you later free

206
00:18:46,260 --> 00:18:52,020
this the system must know that you want
to free 17 bites because otherwise care

207
00:18:52,020 --> 00:18:56,850
law does not know in what the only needs
to put back this element and it would be

208
00:18:56,850 --> 00:19:04,709
really bad for example to put a 17 byte
buffer on the 120 I 228 bites freelance

209
00:19:04,710 --> 00:19:10,559
because then the next location would be
too small buffer and they were had would

210
00:19:10,559 --> 00:19:15,120
have a buffer overflow so it's very
important to always put it back into the

211
00:19:15,120 --> 00:19:16,350
right zone

212
00:19:16,350 --> 00:19:22,949
ok so what kind of ka-lok zones what the
numbers are

213
00:19:23,490 --> 00:19:29,700
depends on what iOS version you are on
if you're uncertain to bid on 64-bit so

214
00:19:29,700 --> 00:19:34,590
do during the two lifetime of the
colonel heap Apple change that all the

215
00:19:34,590 --> 00:19:39,899
time in the beginning there are only
powers of two later on they had some

216
00:19:39,900 --> 00:19:44,669
intermediate ones and this usually has
to do with Apple realizing that a

217
00:19:44,669 --> 00:19:51,210
certain element is located quite often
and it would turn into too much waste on

218
00:19:51,210 --> 00:19:56,429
the heap because of all the the ends are
always unused of the blocks so they just

219
00:19:56,429 --> 00:19:58,650
add a new element and so on

220
00:19:58,650 --> 00:20:07,260
for example let's assume you had a 17-9
bites allocations so in the all original

221
00:20:07,260 --> 00:20:13,080
he would always locate 128 bytes and now
they have just edit ecatalog 80 so you

222
00:20:13,080 --> 00:20:24,330
have always only one bite waste and not
4849 the other way to allocate dynamic

223
00:20:24,330 --> 00:20:32,370
he is this monologue function and it
basically allows the color to forget how

224
00:20:32,370 --> 00:20:37,800
bigger buffer was because it will just
put the size as meta data in front of

225
00:20:37,800 --> 00:20:42,899
the data so when you allocate something
there will always be the size prepended

226
00:20:42,900 --> 00:20:48,840
to the data and again you see in the end
they're still the same waste because it

227
00:20:48,840 --> 00:20:57,810
always needs to fit into a zone around
this time this whole alligator was

228
00:20:57,810 --> 00:21:03,750
abused in for heating show you basically
what people did was they were I've izay

229
00:21:03,750 --> 00:21:09,720
creating expert specific location and d
location primitives for example I used

230
00:21:09,720 --> 00:21:14,400
opening and closing android sockets
other people mapped an unmapped

231
00:21:14,400 --> 00:21:22,500
filesystems this was the expert specific
one then I presented on using always

232
00:21:22,500 --> 00:21:29,160
answer lies XML which is a function used
by I ok api functions to take xml and

233
00:21:29,160 --> 00:21:34,200
turn it into objects so you would fill
the memory with object an object . us

234
00:21:34,200 --> 00:21:38,520
which is really nice for over writing
them because then you have vtable

235
00:21:38,520 --> 00:21:41,520
overrides and you have control over the
coat

236
00:21:42,540 --> 00:21:49,889
yeah so that was the two things that
were used at this time and attackers

237
00:21:49,890 --> 00:21:54,450
were normally going after this single
link free list they were just over

238
00:21:54,450 --> 00:21:58,950
writing the pointer to the next free
element and when you do that the next

239
00:21:58,950 --> 00:22:05,040
location will basically make your
attacker . of the head of the free list

240
00:22:05,040 --> 00:22:10,980
and then the next location would return
and at a controlled pointer as the

241
00:22:10,980 --> 00:22:14,280
memory block and the colonel would write
something into it so you had an

242
00:22:14,280 --> 00:22:17,560
arbitrary wide anywhere

243
00:22:17,560 --> 00:22:21,879
the other thing people attacked where
the size fields of something like malach

244
00:22:21,880 --> 00:22:29,770
because then you can confuse the K free
to put the block back into the wrong

245
00:22:29,770 --> 00:22:30,670
zone

246
00:22:30,670 --> 00:22:36,970
keep in mind when you put a 17 bite
block into a 128 x zone the next

247
00:22:36,970 --> 00:22:41,950
location in 128 will actually just
returned a 17 bite block and then it

248
00:22:41,950 --> 00:22:47,380
will overflow the other thing was
especially after always answer lies xml

249
00:22:47,380 --> 00:22:53,110
you could just overwrite the table
pointers and then get code execution

250
00:22:53,110 --> 00:22:54,639
that way

251
00:22:54,640 --> 00:22:59,800
ok so there was a time when iOS had the
colonel had no mitigation whatsoever

252
00:22:59,800 --> 00:23:10,540
then Apple started adding mitigations so
when iOS 6 was released they made some

253
00:23:10,540 --> 00:23:17,020
changes to always answer lies xml that
actually had very little impact on being

254
00:23:17,020 --> 00:23:23,379
useful for exploitation but it fruit
some people to believe it it fix the

255
00:23:23,380 --> 00:23:26,380
problem but actually you can still use
the function today

256
00:23:27,910 --> 00:23:34,030
the next thing they did was they
randomized the initial locations so that

257
00:23:34,030 --> 00:23:39,399
now the whole zone memory is randomized
because it's in it's like something of

258
00:23:39,400 --> 00:23:43,780
random bytes is allocated before that so
the position of the soul map is no

259
00:23:43,780 --> 00:23:46,420
longer the same after every boot

260
00:23:46,420 --> 00:23:52,990
the next thing is they protected a
single free list against over rides and

261
00:23:52,990 --> 00:23:57,880
small memory blocks gets poisoned that
means they get overwritten

262
00:23:57,880 --> 00:24:01,930
so you cannot rely on the content after
you free them when we get into this in

263
00:24:01,930 --> 00:24:08,080
detail so these override protection of
the free list was implemented by

264
00:24:08,080 --> 00:24:13,480
creating two random cookies and the
colonel their quote no poison cookie and

265
00:24:13,480 --> 00:24:18,790
poison cookie and the lowest bit
basically distinguish which of the

266
00:24:18,790 --> 00:24:27,040
cookies it is and the idea now is that
when a block is freed the first for a

267
00:24:27,040 --> 00:24:30,320
few bites are still the pointer to the
next free blog

268
00:24:30,320 --> 00:24:36,950
but the last few bites are used as a
cookie that basically encodes the same .

269
00:24:36,950 --> 00:24:43,220
er export with one of the two cookies
and during usage of that free memory

270
00:24:43,220 --> 00:24:47,360
later on the colonel can distinguish if
it's the right cookie

271
00:24:47,870 --> 00:24:52,340
not everything right cookie if it's one
of the cookies or if it's a wrong cookie

272
00:24:52,340 --> 00:24:56,480
value at this point and we can panic and
say all this was modified he has an

273
00:24:56,480 --> 00:24:59,809
overflow game over

274
00:24:59,809 --> 00:25:04,908
so basically this was a protection
against a simple over right there off

275
00:25:04,909 --> 00:25:09,649
the pointer because you can only
override the point if you can make it a

276
00:25:09,649 --> 00:25:13,580
real cookie at the end and you cannot
normally not do that because it's a

277
00:25:13,580 --> 00:25:18,289
random value unless you're Likud so if
you leak the pointer you could still

278
00:25:18,289 --> 00:25:24,080
know if you leak the whole block you can
still calculate the cookie by taking the

279
00:25:24,080 --> 00:25:28,039
plaintext . are taking the cookie with
service the pointer soaring them and

280
00:25:28,039 --> 00:25:31,309
then you have the cookie and then you
can prepare whatever you want later on

281
00:25:31,309 --> 00:25:39,559
so the next thing Apple it was because
they have no these cookie and pointers

282
00:25:39,559 --> 00:25:44,418
and so on they obviously wanted this to
be protected against info leaks so now

283
00:25:44,419 --> 00:25:50,029
when you allocate a block on the memory
the first bite and the last place will

284
00:25:50,029 --> 00:25:55,279
be overwritten by debt beef so that you
if the code that is calling this

285
00:25:55,279 --> 00:26:01,370
accidentally exist data directly to use
the land it will have no impact on the

286
00:26:01,370 --> 00:26:09,139
protection of the cookies because they
are no overwritten the next thing is

287
00:26:09,139 --> 00:26:15,049
they created this poisoning this was
actually feature you could always

288
00:26:15,049 --> 00:26:18,950
activate in a debug furniture so you
could always say that the teller system

289
00:26:18,950 --> 00:26:24,860
or please poison all memories of the
street but at this point they actually

290
00:26:24,860 --> 00:26:30,469
decided okay let's activate this by
default on release Colonel's as long the

291
00:26:30,470 --> 00:26:35,929
block is small so normally it's a cage
size of its normally 64 bytes for for

292
00:26:35,929 --> 00:26:41,330
the for the for the processors so every
block smaller equals 64 byte is poison

293
00:26:41,330 --> 00:26:42,679
when you free it

294
00:26:42,680 --> 00:26:47,630
that means it uses the same kind of . up
kind of cookie but it uses the poison

295
00:26:47,630 --> 00:26:52,100
cookie for that and everything in
between is overwritten was that beef and

296
00:26:52,100 --> 00:26:57,740
then you later alligators block again it
will see oh this is the poison cookie so

297
00:26:57,740 --> 00:27:01,040
everything in between must be that beef
and actually shakes that everything is

298
00:27:01,040 --> 00:27:10,250
deadbeef otherwise of panax so this
means around the time of iOS 6 people

299
00:27:10,250 --> 00:27:15,200
who are now using different ways to
attack this so around this time marked

300
00:27:15,200 --> 00:27:22,070
out this tourist a diamond on ios6 and
they introduced a new hip thanks to a

301
00:27:22,070 --> 00:27:26,480
method that is called vmf copy t
basically the idea is that you're

302
00:27:26,480 --> 00:27:31,880
sending most of the time mark messages
without of line data they would then

303
00:27:31,880 --> 00:27:37,310
create this structures in kernel memory
and because you control how much bites

304
00:27:37,310 --> 00:27:42,560
are sent you basically control the size
of these allocations and you control

305
00:27:42,560 --> 00:27:52,610
most of the data except for the small
header and you can also free these so

306
00:27:52,610 --> 00:27:58,550
you have very good control over the heap
and basically between iOS 6 and maybe

307
00:27:58,550 --> 00:28:06,139
nine every single jailbreak where he was
using this and even in 10 you can still

308
00:28:06,140 --> 00:28:11,510
kinda some kind of use it but not in the
same way and the other singers there

309
00:28:11,510 --> 00:28:16,790
which tarjay and Mark . basically
explained this the head of these

310
00:28:16,790 --> 00:28:23,389
structures has a few interesting feels
like pointers and sizes and if you would

311
00:28:23,390 --> 00:28:27,620
not target them with an override you
could turn a small overflow into a

312
00:28:27,620 --> 00:28:34,399
larger overflow or you could just create
arbitrary info leaks at the same time

313
00:28:34,400 --> 00:28:39,290
people would also still go after other
things like override the size field of

314
00:28:39,290 --> 00:28:44,210
my logs so get fries into the wrong zone
or they would still go directly after

315
00:28:44,210 --> 00:28:52,760
the details of objects internal memory
so then apple released iOS 7 and there

316
00:28:52,760 --> 00:28:55,250
are basically two changes too

317
00:28:55,250 --> 00:29:00,200
the heat once more one big one first of
all they now start to poison even larger

318
00:29:00,200 --> 00:29:06,290
blocks and they introduce this new heap
pagelets feature that is most likely not

319
00:29:06,290 --> 00:29:12,050
caused by security just by performance
reasons so first the large block

320
00:29:12,050 --> 00:29:13,879
poisoning

321
00:29:13,880 --> 00:29:17,900
there's a debugging functionality in the
eye and the iOS Colonel it's called sexy

322
00:29:17,900 --> 00:29:18,860
factor

323
00:29:18,860 --> 00:29:24,379
you could always activate that if you
could set good arguments but with iOS 7

324
00:29:24,380 --> 00:29:28,730
Action Apple actually activated by
default and internalized initialize it

325
00:29:28,730 --> 00:29:35,720
to a random value so this random value
is either 15 16 or 17 and in twenty-five

326
00:29:35,720 --> 00:29:43,160
percent of the cases to its 15 insti
percent of the cases 16 and 25 pic cases

327
00:29:43,160 --> 00:29:44,630
is 17

328
00:29:44,630 --> 00:29:49,040
so what does it do so basically every
zone has a counter that is called it

329
00:29:49,040 --> 00:29:53,870
said p count and every time you free an
element in the zone it will increase the

330
00:29:53,870 --> 00:29:59,300
counter and every time this counter
reaches that set p factor value it will

331
00:29:59,300 --> 00:30:00,500
poison this blog

332
00:30:00,500 --> 00:30:05,060
no matter its smaller big that means
let's say in fifty percent of the cases

333
00:30:05,060 --> 00:30:13,610
every 16 free in any zone will result in
a poison block no matter how big the

334
00:30:13,610 --> 00:30:21,469
block is it small or big yeah but for
every zone this is separately and

335
00:30:21,470 --> 00:30:25,850
there's only one randomness boot so this
does not change over time it's always

336
00:30:25,850 --> 00:30:36,469
the same value 15 16 or 17 the other
change was way bigger so Apple realized

337
00:30:36,470 --> 00:30:40,040
that this whole garbage collection
singers really hard when you have no way

338
00:30:40,040 --> 00:30:47,480
from an element back to the to the zone
so they started to create page meter

339
00:30:47,480 --> 00:30:53,090
data and they call this feature the page
list feature what they did is they added

340
00:30:53,090 --> 00:30:59,510
new lists or cues of pages to the zone
structure and now the zone always keeps

341
00:30:59,510 --> 00:31:05,179
lists of pages that belong to that
specific going and yes you can see here

342
00:31:05,179 --> 00:31:06,820
it's a doubly linked list

343
00:31:06,820 --> 00:31:11,769
so you can go in both directions through
all the pages that belong to each zone

344
00:31:12,460 --> 00:31:17,049
furthermore what they did is they help
each meter data to the end of every page

345
00:31:17,860 --> 00:31:24,820
the problem with this is they decided to
not use that for everything that only

346
00:31:24,820 --> 00:31:29,980
uses for small subset of zones so a lot
of interesting zones for attackers don't

347
00:31:29,980 --> 00:31:34,090
use this new feature and in some cases
the attacker can actually shoes if he

348
00:31:34,090 --> 00:31:44,529
wants to go after new feature or old
feature so what does this metadata do so

349
00:31:44,529 --> 00:31:50,049
basically the idea is that the meta-data
now contains the back . into the zone so

350
00:31:50,049 --> 00:31:54,158
now when you have an element to go to
the page meta-data you then know what

351
00:31:54,159 --> 00:31:59,860
this one's own this element belongs to
the next thing is because now everything

352
00:31:59,860 --> 00:32:04,658
is peach related there's no global free
list for his own anymore

353
00:32:04,659 --> 00:32:10,330
now there's a free list for every single
page so you see the blue one is now the

354
00:32:10,330 --> 00:32:15,399
free list of that specific page and of
course all the pages need to be linked

355
00:32:15,399 --> 00:32:19,899
to each other so there's a doubly linked
list between all those pages and every

356
00:32:19,899 --> 00:32:24,250
page content contains a counter how many
free elements are currently in the free

357
00:32:24,250 --> 00:32:31,179
list and it has a counter how many
elements fit into one page so L account

358
00:32:31,179 --> 00:32:35,500
might be missed misleading it does not
mean how many are located it means how

359
00:32:35,500 --> 00:32:42,549
many elements fit into that one page so
now all the memories basically put in

360
00:32:42,549 --> 00:32:49,090
peach lists but it's not one page this
Apple has four pages for every zone and

361
00:32:49,090 --> 00:32:53,709
the idea is they have a list with all
the pages are in that are completely

362
00:32:53,710 --> 00:32:58,149
full at the moment because they're fully
allocated they have one that is all free

363
00:32:58,149 --> 00:33:03,219
so every single element and that pages
free they have one where they are

364
00:33:03,220 --> 00:33:08,710
specially free and paid partially use
that's called intermediate and for some

365
00:33:08,710 --> 00:33:14,740
very few special zones they have this
any free foreign list because very few

366
00:33:14,740 --> 00:33:18,410
special zones allow you to free memory

367
00:33:18,410 --> 00:33:24,200
into the zone that is actually not from
the zone map so that is memory somewhere

368
00:33:24,200 --> 00:33:29,720
on the heap so there's only very few
stones that allow this and for that they

369
00:33:29,720 --> 00:33:37,760
have this force list now it's up to iOS
and the locator to always ensure that a

370
00:33:37,760 --> 00:33:43,760
page moves around to be always in the
right of these cues so when a page gets

371
00:33:43,760 --> 00:33:45,020
completely full

372
00:33:45,020 --> 00:33:48,830
it needs to be removed from whatever
patron was on at the moment from other

373
00:33:48,830 --> 00:33:54,740
other listed was on it needs to be put
into all used to cue and so on and so on

374
00:33:54,740 --> 00:34:00,950
this means now when you allocate an
element what happens this the locator

375
00:34:00,950 --> 00:34:04,940
goes through the any free foreign the
intermediate 1 and the $MONEY or free

376
00:34:04,940 --> 00:34:10,940
list and tries to get the first
available page in that in that area so

377
00:34:10,940 --> 00:34:14,810
normally it would get the first
intermediate page so that is partially

378
00:34:14,810 --> 00:34:21,590
full and partially empty it will take
the first page selected and then go to

379
00:34:21,590 --> 00:34:26,840
the free list and return the first
element from that if no such

380
00:34:26,840 --> 00:34:31,130
intermediate page exists it will search
a patient is all free will get to the

381
00:34:31,130 --> 00:34:36,470
all free first page we'll take it we'll
get the first element and go on

382
00:34:36,469 --> 00:34:42,350
sometimes your he was completely full
when that means all these lists

383
00:34:42,350 --> 00:34:48,860
basically our empty everything is in the
all used one so in this case it will add

384
00:34:48,860 --> 00:34:54,050
a new page to the system and then put
all of this into the all three ph q and

385
00:34:54,050 --> 00:35:04,370
then restart this algorithm free on the
other hand will just go to the elements

386
00:35:04,370 --> 00:35:09,350
see what page it belongs to put it on
the free list and then just ensure that

387
00:35:09,350 --> 00:35:13,850
the page stays on the right Q so for
example it could go from the

388
00:35:13,850 --> 00:35:18,049
intermediate to the all free because
suddenly all the elements of freedom a

389
00:35:18,050 --> 00:35:21,290
page or previously the whole page was
full

390
00:35:21,290 --> 00:35:25,370
now one element is freed so it needs to
be put from all used to intermediate but

391
00:35:25,370 --> 00:35:27,950
this happens automatically in the
background

392
00:35:27,950 --> 00:35:32,299
so what is the impact on exploitation I
was seven

393
00:35:35,690 --> 00:35:40,490
well the general and pink is first of
all garbage collection this kind of

394
00:35:40,490 --> 00:35:44,899
those guys really easy because the
system keeps a list of pages are

395
00:35:44,900 --> 00:35:50,359
completely empty so the quality of the
the garbage collector can directly take

396
00:35:50,359 --> 00:35:56,839
this pages and return them to the system
it's a lot faster than just trying to

397
00:35:56,839 --> 00:36:03,710
find out which pages are full of himt it
also means that free operations are not

398
00:36:03,710 --> 00:36:08,150
always local to each peach there on that
means in the global context of hip

399
00:36:08,150 --> 00:36:15,560
fracture freeze by other threats don't
interrupt you as much as before Alex on

400
00:36:15,560 --> 00:36:19,400
the other hand interrupt you no matter
where they are because they're always

401
00:36:19,400 --> 00:36:24,050
deal with the first picture is currently
in a specific you so they were always

402
00:36:24,050 --> 00:36:28,250
located in the same page you are
currently in but this is not much

403
00:36:28,250 --> 00:36:32,720
different from before because before you
always need to stay in the same page

404
00:36:32,720 --> 00:36:37,669
anyway so other threats were allocating
at the same time so they would corrupt

405
00:36:37,670 --> 00:36:42,500
interrupt in the same way they do right
now the others just a frieze of other

406
00:36:42,500 --> 00:36:45,500
threats are now interrupting you not so
much anymore

407
00:36:46,670 --> 00:36:53,510
however Apple is a very very big mistake
because this metadata they created and

408
00:36:53,510 --> 00:36:59,089
the ques we're doubly linked list that
had absolutely no expert protection

409
00:36:59,089 --> 00:37:03,049
keep in mind this is three years ago so
three years ago Apple fit the whole

410
00:37:03,050 --> 00:37:08,960
kernel heap with double linked list that
had no protection against the yeah safe

411
00:37:08,960 --> 00:37:13,730
and links other while they had no save
our necks so with ios7 Colonel he

412
00:37:13,730 --> 00:37:19,250
exploits and I was got really easy to
export really easy also because of the

413
00:37:19,250 --> 00:37:24,170
new ph list feature there's now a new
attack that is going on

414
00:37:24,680 --> 00:37:32,149
it's now the idea to confuse the locator
to three elements from pages from zones

415
00:37:32,150 --> 00:37:37,339
that use the new feature into zones that
that use the old feature and vice versa

416
00:37:37,339 --> 00:37:41,270
so there's now the possibility to get
more country

417
00:37:41,270 --> 00:37:47,180
version of course Apple was aware of
this possibility that you free something

418
00:37:47,180 --> 00:37:53,480
into the wrong zone so they added this
coat of the system what they basically

419
00:37:53,480 --> 00:37:59,180
do here is the only slide with all of
code what they do is they detect when

420
00:37:59,180 --> 00:38:02,089
you try to free an element into the
wrong zone

421
00:38:02,090 --> 00:38:05,960
how can they do that because they can
just go to the element go to the page

422
00:38:05,960 --> 00:38:10,550
metadata take the zone pointer compared
to the one that you try to free tattoo

423
00:38:10,550 --> 00:38:14,600
and redness does not make a match then
it's obviously a problem in some it's a

424
00:38:14,600 --> 00:38:20,360
heap corruption so Apple detects the hip
correction at this point and the same

425
00:38:20,360 --> 00:38:25,820
thing would be to just panic but Apple
this differently they first try to

426
00:38:25,820 --> 00:38:30,890
repair this corruption by determining if
this zone . oil that they found with the

427
00:38:30,890 --> 00:38:35,720
element is actually illegal one and when
they find it in the list of zones they

428
00:38:35,720 --> 00:38:40,970
were just now change the a locator to
free that into the right zone according

429
00:38:40,970 --> 00:38:47,720
to the metadata but if they cannot
repair it so imagine they have detected

430
00:38:47,720 --> 00:38:53,750
a kernel memory corruption and they say
okay we can repair it so let the coaches

431
00:38:53,750 --> 00:39:01,010
run so they detect that there's a memory
corruption just little run both things

432
00:39:01,010 --> 00:39:06,020
are stupid the letting it run of course
is stupid but the other thing the

433
00:39:06,020 --> 00:39:11,720
repairs also stupid because and when you
try to free a page list element into a

434
00:39:11,720 --> 00:39:16,759
free list element a patient's own
element into a free list own element

435
00:39:16,760 --> 00:39:22,850
then this meter data this thing he tries
to pass is actually at a control stuff

436
00:39:22,850 --> 00:39:27,770
so the attacker can put forever zone .
once in there and then this repair

437
00:39:27,770 --> 00:39:31,430
algorithm will actually help the
attacker and put it in put this element

438
00:39:31,430 --> 00:39:33,770
on the run zone and this is really bad

439
00:39:33,770 --> 00:39:42,440
yeah so people use that he thinks sure
they basically used in ios7 the same as

440
00:39:42,440 --> 00:39:48,350
before and for corruption targets
everything work the same in ios7 as

441
00:39:48,350 --> 00:39:52,790
before but the new target where these
double linked list because they give you

442
00:39:52,790 --> 00:39:54,288
arbitrary whites anywhere

443
00:39:54,289 --> 00:39:58,999
for very little work really but really
easy to write explains that way

444
00:40:00,199 --> 00:40:08,359
ok let's go to iOS 8 in iOS 8 Apple
maybe because of charge a phone as much

445
00:40:08,359 --> 00:40:12,890
because it was talking about this they
started hardening these cues as we will

446
00:40:12,890 --> 00:40:19,368
see later and there may be also realized
that poisoning every 16 block is a

447
00:40:19,369 --> 00:40:25,579
little bit much and makes the system
slow so they deal with that so the first

448
00:40:25,579 --> 00:40:31,069
thing is they made this Q hardening so
they basically sneaked into the very

449
00:40:31,069 --> 00:40:37,788
very very last bit of iOS 8 sneak this
new protection that every single queue

450
00:40:37,789 --> 00:40:44,209
micro had now safe unlink protection in
and they were using these macros in many

451
00:40:44,209 --> 00:40:48,979
places not only in the heap so suddenly
in the very last beta you had a lot of

452
00:40:48,979 --> 00:40:53,928
say fundings the system that we're not
there before so this means you can no

453
00:40:53,929 --> 00:41:00,169
longer overflow this because this a fun
little bit will detect the overflow the

454
00:41:00,169 --> 00:41:06,169
next thing that introduced it is this
headpiece scale feature from the idea

455
00:41:06,169 --> 00:41:13,368
here is that poisoning every 16 location
maybe in there like let's say 2048 byte

456
00:41:13,369 --> 00:41:17,569
block is a lot of memory that gets
overwritten with step beef and it may be

457
00:41:17,569 --> 00:41:22,339
takes a lot of time so the most likely
reason why Apple did this is to make the

458
00:41:22,339 --> 00:41:24,049
system faster again

459
00:41:24,049 --> 00:41:30,739
so what they did is they change how
often they poisoned the block and they

460
00:41:30,739 --> 00:41:35,749
do this by introducing 2p scale which is
by default for so what they do is they

461
00:41:35,749 --> 00:41:51,979
take the size let's say 1024 and then
they / 16 which is one actually ate no

462
00:41:51,979 --> 00:41:57,468
64 so it should be 64 if i'm not
completely wrong at the moment

463
00:41:57,469 --> 00:42:02,539
well let's let's use the number on the
slides that's easier so it takes 256 /

464
00:42:02,539 --> 00:42:05,020
16 so we have 16

465
00:42:05,020 --> 00:42:10,480
so what happened does know it has this
number to the tempie factor so this

466
00:42:10,480 --> 00:42:16,360
means now 2056 byte blocks are only
poison everyone sorry to uh sorry three

467
00:42:16,360 --> 00:42:23,080
fries and the bigger the blog gets the
less often the poisoning happens this

468
00:42:23,080 --> 00:42:28,840
means for people who do we use after
free exploits and rely on the content

469
00:42:28,840 --> 00:42:33,880
being intact after the free it got
suddenly easier again because the poison

470
00:42:33,880 --> 00:42:42,820
gets less off the block the larger block
is so how do people attack this again

471
00:42:42,820 --> 00:42:45,820
for you think she actually nothing
changed

472
00:42:46,750 --> 00:42:50,920
you can no longer go after the doubling
list and iOS 8 because of the same

473
00:42:50,920 --> 00:42:54,160
unlinked but everything else work as
before

474
00:42:56,650 --> 00:43:09,880
let's switch to iOS 9 Apple started
hardening this vmf copy t structure that

475
00:43:09,880 --> 00:43:15,340
was used by all the jailbreaks they
started changing the the position of the

476
00:43:15,340 --> 00:43:21,070
metadata and they know started with one
of the latest i was minor versions to

477
00:43:21,070 --> 00:43:23,290
randomize something in the heap

478
00:43:23,290 --> 00:43:29,680
we will see so the hardening they did
was they took this vm copy t structure

479
00:43:29,680 --> 00:43:34,330
that was used for the colonel buffers
and inside the structures where data

480
00:43:34,330 --> 00:43:38,319
pointer that was completely useless
because normally it should always .

481
00:43:38,320 --> 00:43:42,820
directly after the header so it was
basically easily calculated this pointer

482
00:43:42,820 --> 00:43:46,360
and it was really bad to have it in
there because people could corrupted and

483
00:43:46,360 --> 00:43:51,790
use it for infants the next thing is
they had not one there to size field in

484
00:43:51,790 --> 00:43:57,640
the structure and this attacking these
two sides fields allowed to either have

485
00:43:57,640 --> 00:44:03,370
a very nice info leak or to confuse the
heap a locator when it put on their own

486
00:44:03,370 --> 00:44:09,100
on the zone later on so Apple removed
also that size field also they removed a

487
00:44:09,100 --> 00:44:13,330
bunch of unused stuff for Colonel
buffers so they made this BMR quality

488
00:44:13,330 --> 00:44:15,779
structure very small

489
00:44:15,780 --> 00:44:21,750
this is actually nice for an attacker
because the smaller structure is the

490
00:44:21,750 --> 00:44:26,280
then you can suddenly start to use it
for hip fracture in the small zones

491
00:44:26,280 --> 00:44:31,230
previously it was quite large header so
you had like any at least at least 88

492
00:44:31,230 --> 00:44:37,020
miles on 64-bit system to you couldn't
control any zone smaller now it's 24

493
00:44:37,020 --> 00:44:42,300
miles so you can use it for smaller
typing showy the next thing is because

494
00:44:42,300 --> 00:44:45,360
so many people are using it for
arbitrary in four weeks

495
00:44:45,360 --> 00:44:49,620
apple now chicks hard-coded 4 kilobyte
limit so i should try to have a $TIME

496
00:44:49,620 --> 00:44:54,540
p.m. appt copy t structure that has a
site feel larger than 4 kilobyte this is

497
00:44:54,540 --> 00:44:57,990
resulting in the kernel panic

498
00:44:57,990 --> 00:45:07,439
also they they have now in several
places where they make use of this kind

499
00:45:07,440 --> 00:45:11,850
of structure they have a size field in
an additional position and then they

500
00:45:11,850 --> 00:45:16,860
compare the size field of for example a
mock message with the size field in the

501
00:45:16,860 --> 00:45:19,410
EMF quality and if they don't match

502
00:45:19,410 --> 00:45:25,319
it's obviously manipulated and it's also
panicking out so they made it less

503
00:45:25,320 --> 00:45:32,220
usable but they only made it less usable
for info leaks and 4x4 here for buffer

504
00:45:32,220 --> 00:45:37,319
overflows four heaping sure it's the
same usable so you can still control the

505
00:45:37,320 --> 00:45:43,380
heat was that the next thing that I
didn't actually realize for a very very

506
00:45:43,380 --> 00:45:48,180
long time because i was never dealing
around with it between iOS 8 and I was

507
00:45:48,180 --> 00:45:52,379
nine and suddenly move this meter data
that was previously at the end of the

508
00:45:52,380 --> 00:45:58,020
page it suddenly moved to the beginning
of the page so most probably the reason

509
00:45:58,020 --> 00:46:03,060
for that is to protect against buffer
overflows because if it's before you you

510
00:46:03,060 --> 00:46:10,799
cannot overflow into it you can maybe
only underflow into it the most strange

511
00:46:10,800 --> 00:46:18,120
change stated in iOS mind or two because
they started to modify the free list

512
00:46:18,120 --> 00:46:24,029
generation so remember when you had a
new event asparagus own grow and you had

513
00:46:24,030 --> 00:46:25,270
a new element

514
00:46:25,270 --> 00:46:30,280
no you get a new zone page the first
thing you need to do it needs to create

515
00:46:30,280 --> 00:46:34,270
a freelance for that specific page so
what it normally would do it would take

516
00:46:34,270 --> 00:46:36,790
the first element the Second Amendment
so on and so on

517
00:46:36,790 --> 00:46:41,050
put them in the free list and then
because of Lee for the first element

518
00:46:41,050 --> 00:46:45,010
will be returned last and so on and so
on and the last moment would be returned

519
00:46:45,010 --> 00:46:53,320
first so this gave the heap very
predictable order i was i was nine . to

520
00:46:53,320 --> 00:46:56,620
they change that

521
00:46:56,620 --> 00:47:02,410
actually I hope it's not too not 90210 I
think it's not too so they changed that

522
00:47:02,410 --> 00:47:08,020
what they do now is whenever they they
do this after another so what they do

523
00:47:08,020 --> 00:47:12,880
now is they create this free list and
every time they need a new element the

524
00:47:12,880 --> 00:47:18,850
free list they throw a coin and the
random decision is made showed the first

525
00:47:18,850 --> 00:47:23,830
element in the page all the last one be
added to the free list so let's say we

526
00:47:23,830 --> 00:47:28,000
at the last point to the free list so
now the head of the fearless points to

527
00:47:28,000 --> 00:47:29,770
that one

528
00:47:29,770 --> 00:47:34,060
now it's throws the coin again but this
time it says take the first one so the

529
00:47:34,060 --> 00:47:39,700
further it will look like this and this
continues like always a random decision

530
00:47:39,700 --> 00:47:44,020
of it takes the first one or the last
one and so in the end what you end up

531
00:47:44,020 --> 00:47:49,930
with is whenever a new pages added to
the heap the initial free list is random

532
00:47:49,930 --> 00:47:56,200
so you can no longer predict where it
actually ends up there are some

533
00:47:56,200 --> 00:48:00,490
probabilities like if you allocate quite
late you will never end up most probably

534
00:48:00,490 --> 00:48:06,370
in the end of his own page but this all
probabilities there's no insurance

535
00:48:06,370 --> 00:48:14,080
anymore so how did people that abuse
that for him to make sure they're

536
00:48:14,080 --> 00:48:19,540
basically used most of the same version
of routines as I said vmf copy tea also

537
00:48:19,540 --> 00:48:24,070
it was harmless it still works as before
forever in the regular feedback chewy

538
00:48:24,070 --> 00:48:32,080
just for the corruptions they could now
only use smaller are leaks and they had

539
00:48:32,080 --> 00:48:37,400
to use a different function

540
00:48:37,400 --> 00:48:43,400
to not run into size limits and I mean
size comparisons but mostly it was the

541
00:48:43,400 --> 00:48:49,910
same and if you go after him after meter
data or application data and nothing

542
00:48:49,910 --> 00:48:53,029
changed and I was mine

543
00:48:53,030 --> 00:48:59,990
let's go to I was 10 and I'm actually
running out of time but should fit so

544
00:48:59,990 --> 00:49:07,339
Apple started happening I am a cop ET
more but again what they mostly did say

545
00:49:07,340 --> 00:49:11,090
they enforce more checks to validate
that you're not overriding the size and

546
00:49:11,090 --> 00:49:17,120
so on to do this in more places for
hitting sure that still will not do

547
00:49:17,120 --> 00:49:24,170
anything just for were writing they now
use the fixed stone structure array they

548
00:49:24,170 --> 00:49:30,920
completely revamp the ph meter data they
now change the free list against over

549
00:49:30,920 --> 00:49:39,530
rights and leagues they don't use
inbound meta data anymore anywhere in

550
00:49:39,530 --> 00:49:44,840
the rapper's they not have external
metadata and they change the zone

551
00:49:44,840 --> 00:49:49,280
allocated debugging features so the
first thing they did is they moved all

552
00:49:49,280 --> 00:49:54,260
the stone structures that were
previously on the heap they now move

553
00:49:54,260 --> 00:50:00,890
them into a fixed-size zone array that
is in the data BSS segment for for iOS

554
00:50:00,890 --> 00:50:08,569
kernels and this means all those are now
at a fixed address in the journal

555
00:50:08,570 --> 00:50:13,760
relative to the colonel base which is
maybe not a really good idea but they

556
00:50:13,760 --> 00:50:17,870
did it anyway so previously you would
know where specific Zonis now you know

557
00:50:17,870 --> 00:50:20,509
where is in memory

558
00:50:20,510 --> 00:50:27,440
I mean the stone structure the next
thing is when they allocate this zone

559
00:50:27,440 --> 00:50:33,860
map they now additionally reserve memory
in that zone map that is called the zone

560
00:50:33,860 --> 00:50:39,440
meta-data region and because the first
location should be in the beginning and

561
00:50:39,440 --> 00:50:44,600
what this contains is basically meter
data for every single page in the zone

562
00:50:44,600 --> 00:50:49,040
map so now for every single page tears
external meter data

563
00:50:50,660 --> 00:51:00,740
this now means every zone can make use
of metadata this meter data looks like

564
00:51:00,740 --> 00:51:07,729
this it's 24 bytes on a 64-bit system
and they distinguish between what they

565
00:51:07,730 --> 00:51:15,380
call real meter data and apparently not
real metadata and the idea here is that

566
00:51:15,380 --> 00:51:21,590
because of the location size so that was
the single on how much does his own grow

567
00:51:21,590 --> 00:51:23,450
whenever it runs out of space

568
00:51:23,450 --> 00:51:30,080
it might grow by more than one page so
the idea is the very first page is real

569
00:51:30,080 --> 00:51:37,040
meter data and every other page is
additional meter data so it does not get

570
00:51:37,040 --> 00:51:41,630
the full me today that it only gets back
pointers to the real one so the idea is

571
00:51:41,630 --> 00:51:47,330
when you on the second sort of force
page of any location size the only

572
00:51:47,330 --> 00:51:53,090
fields are filled out as its set index
which says 2056 means all this is like a

573
00:51:53,090 --> 00:51:59,660
secondary page and then the offset is
how many bytes do you need go backward

574
00:51:59,660 --> 00:52:05,899
from the beginning of this metadata to
get to our page 0 and then page 0

575
00:52:05,900 --> 00:52:13,520
contains forward backward pointers
inside the the page lists it contains a

576
00:52:13,520 --> 00:52:19,880
free count as before it does not have a
zone . anymore because now the zone sign

577
00:52:19,880 --> 00:52:24,980
the static erre so it just has a
one-bite index into that static area so

578
00:52:24,980 --> 00:52:31,490
you know what's on this page belongs to
and page count is how many pages fit

579
00:52:31,490 --> 00:52:38,600
into one location size so whenever the
zone grows how many pages are there the

580
00:52:38,600 --> 00:52:44,480
free list offset is also new instead of
having a pointer to the very first free

581
00:52:44,480 --> 00:52:50,420
element of that specific page they now
have a 32-bit offset that just says how

582
00:52:50,420 --> 00:52:55,520
many bytes from the beginning of that
page is the first free element are in

583
00:52:55,520 --> 00:53:01,220
this page so they basically removed all
the pointers from there

584
00:53:02,260 --> 00:53:06,730
except for the peaches points that are
protected by safe and link anywhere so

585
00:53:06,730 --> 00:53:10,870
when you leaked this information here
now you actually have no idea about the

586
00:53:10,870 --> 00:53:17,140
pointers might be one of the reasons for
the design i pre I change think it's

587
00:53:17,140 --> 00:53:21,069
mostly like to make the whole thing
smaller because you have so much meter

588
00:53:21,070 --> 00:53:26,890
data now so you want to have a smaller
amount of this data so inside a page

589
00:53:26,890 --> 00:53:33,609
they also changed stuff because now as I
said they now have this free list offset

590
00:53:33,610 --> 00:53:38,350
instead of the pointer so it will tell
you how many bytes from the beginning of

591
00:53:38,350 --> 00:53:44,080
the page is the head of the freeness
that's the first strange that it but

592
00:53:44,080 --> 00:53:46,210
they didn't get another change

593
00:53:46,210 --> 00:53:51,160
previously the beginning of the page
will be a pointer to the next block and

594
00:53:51,160 --> 00:53:56,080
the next block and the next block and
then the end now so they changed that

595
00:53:56,080 --> 00:54:01,720
now so that the beginning of these free
elements there is never a plaintext

596
00:54:01,720 --> 00:54:09,609
pointer instead it's always the pointer
x orders and no poison cookie and then

597
00:54:09,610 --> 00:54:14,500
in the end the backup pointer is still
the point X on the cookie and they are

598
00:54:14,500 --> 00:54:18,640
there you still the no poison or poison
cookie to determine if it's a poison

599
00:54:18,640 --> 00:54:25,000
block or not but the the first pointer
is always obvious cated now so why did

600
00:54:25,000 --> 00:54:31,690
they do that there might be many reasons
one reason is you don't leak the cookie

601
00:54:31,690 --> 00:54:35,980
anymore when you leave the full content
of the block anymore because both are

602
00:54:35,980 --> 00:54:40,510
either the same well you or six orbits
two random values so you cannot get to

603
00:54:40,510 --> 00:54:46,810
the cookie value that way but the more
important thing here is may be caused by

604
00:54:46,810 --> 00:54:53,770
google because I mba from google
basically told apple or told the public

605
00:54:53,770 --> 00:54:59,800
that having the pointer in the beginning
is really really really bad because when

606
00:54:59,800 --> 00:55:06,640
you type confuse an empty block for an i
okayed object the first pointer is used

607
00:55:06,640 --> 00:55:08,839
as a pointed to the v table

608
00:55:08,839 --> 00:55:15,140
so if you are free block is actually
confused as an iokit object it will

609
00:55:15,140 --> 00:55:21,170
point to the next free block and if you
have a vtable in that free block then

610
00:55:21,170 --> 00:55:27,259
you could easily type confuse an empty
block phone actually valid object and

611
00:55:27,259 --> 00:55:34,039
then you had code execution which made
race conditioning use after free in the

612
00:55:34,039 --> 00:55:39,319
iOS Colonel quite easy to exploit in
some cases so this is not possible

613
00:55:39,319 --> 00:55:42,319
anymore there's no real point in the
beginning anymore

614
00:55:44,479 --> 00:55:50,689
the next thing and it's mostly though
that the worst part of it all is now

615
00:55:50,690 --> 00:55:56,359
when you have an element you can always
get to the meta data for this element so

616
00:55:56,359 --> 00:56:02,839
you always know for every every buffer
what zone it belongs to that means the

617
00:56:02,839 --> 00:56:08,900
locator can always check that you try to
free it into the right zone if you don't

618
00:56:08,900 --> 00:56:13,519
try to free the right zone then it's
easily detectable by the comparing the

619
00:56:13,519 --> 00:56:16,578
zone index to the actual are one that
you wanted to

620
00:56:17,749 --> 00:56:23,899
yeah 3 2 and this means the whole attack
class of freeing something into the

621
00:56:23,900 --> 00:56:26,539
wrong zone is no longer possible

622
00:56:26,539 --> 00:56:35,479
so a lot of attacks that are used in the
White don't work anymore it doesn't mean

623
00:56:35,479 --> 00:56:38,868
it's not exploitable because you can
still go after other things like

624
00:56:38,869 --> 00:56:42,890
application data but the most used the
tech is not possible anymore

625
00:56:43,579 --> 00:56:56,660
also because now all the elements
basically have a zone assigned the size

626
00:56:56,660 --> 00:57:02,509
is always known because you know how big
the the elements of a specific zone it's

627
00:57:02,509 --> 00:57:07,279
our so all these rappers don't need to
really keep track of the size anymore

628
00:57:07,279 --> 00:57:11,359
for can't like its kind of doesn't
matter but for mark

629
00:57:11,960 --> 00:57:13,190
it means the

630
00:57:13,190 --> 00:57:17,839
sighs fields in the beginning is
completely superfluous it doesn't need

631
00:57:17,839 --> 00:57:23,089
it anymore and that means my lock was
basically changed by Apple to be just an

632
00:57:23,089 --> 00:57:30,440
even simpler wrapper around ka-lok and
so this metadata the size field is gone

633
00:57:30,440 --> 00:57:32,000
it's not there anymore

634
00:57:32,000 --> 00:57:37,940
they also did the same change to current
always my log which is basically a copy

635
00:57:37,940 --> 00:57:43,550
and paste of Mark and the funniest thing
here was when i did my talks in for iOS

636
00:57:43,550 --> 00:57:48,650
5 I busy set on stage with Apple people
in front that currently locked because

637
00:57:48,650 --> 00:57:53,420
it was copy and paste had a possible
integer overflow in it and five years

638
00:57:53,420 --> 00:57:56,420
later that's no fixed arm

639
00:57:56,420 --> 00:58:03,740
yeah so the thing is there's no sighs
field now anymore and this is actually

640
00:58:03,740 --> 00:58:08,899
good and bad for an attacker it's bad
because you cannot overwrite it anymore

641
00:58:08,900 --> 00:58:12,680
but it doesn't matter because these free
and the wrong zone doesn't work anymore

642
00:58:12,680 --> 00:58:17,118
anyway but now this is the good singers
because there's no sighs field anymore

643
00:58:17,810 --> 00:58:23,240
the whole thing is just data used by
whatever the colonel puts into the

644
00:58:23,240 --> 00:58:24,560
allocated data

645
00:58:24,560 --> 00:58:29,930
this means you now have way way my code
paths in the kernel that will take

646
00:58:29,930 --> 00:58:35,328
attacker data and put it into the heap
previously you always had this annoying

647
00:58:35,329 --> 00:58:39,230
size field in front of it so you could
not create arbitrary structures

648
00:58:39,230 --> 00:58:43,339
especially objects in the colonel
because the first size field would

649
00:58:43,339 --> 00:58:48,770
always be taken as the pointer so now
with this metadata gone you have way

650
00:58:48,770 --> 00:58:53,359
more code paths that allow you to put
arbitrary data into the heap that you

651
00:58:53,359 --> 00:59:04,670
can then use for type confusion and
everything else so the last thing at the

652
00:59:04,670 --> 00:59:10,880
also reaffirmed the debugging
functionality remember you had this good

653
00:59:10,880 --> 00:59:16,670
arguments to locate the two to lock the
heap allocations and the locations but

654
00:59:16,670 --> 00:59:21,020
it was limited to one single zone and
apple change that to now

655
00:59:21,770 --> 00:59:26,520
yeah you know allowed to lock up to five
mon

656
00:59:26,520 --> 00:59:30,660
but this is again just the limit in the
colonel theoretically the code is now

657
00:59:30,660 --> 00:59:36,870
able to lock all those at the same time
the boot arguments that you use for that

658
00:59:36,870 --> 00:59:41,640
is that like one two three four and five
and you can just give a different zones

659
00:59:41,640 --> 00:59:49,470
and they will look at the same time if
zone is locked to or not is defined in

660
00:59:49,470 --> 00:59:54,299
the stone structure so there's a bit now
that explains if it's locked or not and

661
00:59:54,300 --> 00:59:59,430
what they also introduced the setup BTW
lot . in the end so now every stone

662
00:59:59,430 --> 01:00:03,270
structure can point to its own BTW lock

663
01:00:03,270 --> 01:00:07,200
that's why the code is actually part
able to lock all those at the same time

664
01:00:07,200 --> 01:00:10,020
but for Speed reasons just limited to
five

665
01:00:10,020 --> 01:00:15,720
the other thing is is and having
research that too much is the structure

666
01:00:15,720 --> 01:00:18,330
of the bead lock is not completely
different

667
01:00:18,330 --> 01:00:23,130
they changed a simple ring buffer into
something its losses use hash tables

668
01:00:23,130 --> 01:00:27,540
with md5 as a hash function and all this
kind of thing its most we also used for

669
01:00:27,540 --> 01:00:32,279
speed and so on but this is a more
complicated thing that is not haven't

670
01:00:32,280 --> 01:00:42,360
fully documented yet so my prediction is
that for simple drawing show you all the

671
01:00:42,360 --> 01:00:49,230
previous methods will work are you will
have new methods because now you can

672
01:00:49,230 --> 01:00:54,450
also use everything that uses malach and
there's for example a possibility with

673
01:00:54,450 --> 01:01:00,569
posix porn to actually malach whatever
you want into the colonel

674
01:01:00,570 --> 01:01:04,560
so you can fill the colonel with
whatever data you want just by using

675
01:01:04,560 --> 01:01:10,740
plastic spawn and some specific flex the
corruption targets every size field is

676
01:01:10,740 --> 01:01:16,319
now becoming an interesting because you
cannot free into the wrong zone it might

677
01:01:16,320 --> 01:01:20,460
be still interesting for like in
freaking but not for the free in two

678
01:01:20,460 --> 01:01:27,000
runs on one but everybody who was
already attacking application data like

679
01:01:27,000 --> 01:01:29,490
pointers to objects for them

680
01:01:29,490 --> 01:01:34,350
nothing changed maybe one thing we'll
see in future is that people not attack

681
01:01:34,350 --> 01:01:38,220
the pointers to objects but the point is
to mark ports

682
01:01:38,220 --> 01:01:42,959
because then they can create themselves
really funny internal things that the

683
01:01:42,960 --> 01:01:49,230
system loves and then you can create
pointers to things that are usable by

684
01:01:49,230 --> 01:01:52,230
the system directly

685
01:01:53,130 --> 01:01:58,320
yeah just to explain for example when
you have a task like the colonel task

686
01:01:58,320 --> 01:02:04,230
and you create yourself a mach port for
that then you can read and write in it

687
01:02:04,230 --> 01:02:10,320
and so on so this art are things you can
still go after and Apple hasn't done

688
01:02:10,320 --> 01:02:16,740
anything to that at the moment unless I
didn't see it in the I was ten colonel

689
01:02:16,740 --> 01:02:22,020
yeah so we're running actually out of
time the over and deliberate

690
01:02:22,020 --> 01:02:35,220
so any questions before you go into the
break regarding the large block

691
01:02:35,220 --> 01:02:36,390
poisoning

692
01:02:36,390 --> 01:02:43,049
yes his happens sometimes yes what's the
point of a poisoning sometimes versus a

693
01:02:43,050 --> 01:02:49,050
jailbreak which can be tried many times
while the singers usually what you do is

694
01:02:49,050 --> 01:02:57,119
you when you have a use of the free your
exploit might rely on the fact that the

695
01:02:57,119 --> 01:03:03,810
content of a free block is still the
same that was before and when you have a

696
01:03:03,810 --> 01:03:09,420
random poisoning then the quantum might
actually be just deadbeef and when you

697
01:03:09,420 --> 01:03:13,890
know excessive it it will access maybe .
us that are now that beef and it will

698
01:03:13,890 --> 01:03:18,420
crash the system that's the problem if
you have like a random poisoning and you

699
01:03:18,420 --> 01:03:24,599
are exploited relied on keep and keep
stuff being intact after free then I

700
01:03:24,599 --> 01:03:29,099
understand what I'm asking is if you're
talking about a statistical poisoning or

701
01:03:29,099 --> 01:03:33,510
random poison yeah it almost seems like
this seems to mitigate attacks in the

702
01:03:33,510 --> 01:03:37,109
wild but not jailbreak switch you can
try again and again

703
01:03:37,109 --> 01:03:41,730
oh oh yeah well the distance the singers
yeah

704
01:03:42,240 --> 01:03:46,290
nowadays the jailbreaks actually have
things like boot loops or so so they

705
01:03:46,290 --> 01:03:50,400
just do the same exploit over and over
again but if you want to have a clean

706
01:03:50,400 --> 01:03:51,569
exploits this way

707
01:03:51,569 --> 01:03:55,229
be a problem so as long you have
something that you just loop and loop

708
01:03:55,229 --> 01:03:56,069
the loop

709
01:03:56,069 --> 01:04:01,410
it's fine and you can still do it like
this joke that I did on twitter where

710
01:04:01,410 --> 01:04:06,118
there was this one movie 5 when you open
it on you on your own you're on you're

711
01:04:06,119 --> 01:04:10,259
on your iPhone the colonel would crash
and people were like say i was telling

712
01:04:10,259 --> 01:04:13,499
all this is a new jailbreak and you just
click it and people are clicking it and

713
01:04:13,499 --> 01:04:17,669
then after this here is just crashing I
tell them yeah you just need to try it

714
01:04:17,670 --> 01:04:21,599
over and over again and people were
telling me then I tried it like 20 times

715
01:04:21,599 --> 01:04:23,400
and still does not work

716
01:04:23,400 --> 01:04:27,299
yeah but it's too is just like a
statistical probability and there's

717
01:04:27,299 --> 01:04:31,529
always quote from from Dave I tell that
he made like many years ago if you just

718
01:04:31,529 --> 01:04:37,109
have a one in 2056 chance just send the
exploit to a million hosts and there's

719
01:04:37,109 --> 01:04:45,598
still a lot of systems yeah them any
other questions maybe others will be

720
01:04:45,599 --> 01:04:47,759
offstage thank you very much Stepan

