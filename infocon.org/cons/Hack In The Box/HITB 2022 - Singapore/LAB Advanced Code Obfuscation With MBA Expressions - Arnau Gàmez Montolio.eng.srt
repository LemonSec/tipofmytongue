1
00:00:05,960 --> 00:00:09,179
okay great

2
00:00:09,179 --> 00:00:10,200
um

3
00:00:10,200 --> 00:00:12,540
this will be a kind of

4
00:00:12,540 --> 00:00:14,820
extended talk with a lot of demos and

5
00:00:14,820 --> 00:00:17,160
some live demons as well with some

6
00:00:17,160 --> 00:00:18,119
coding

7
00:00:18,119 --> 00:00:20,340
when I will walk you through

8
00:00:20,340 --> 00:00:21,960
where is the current research what

9
00:00:21,960 --> 00:00:23,580
methods we have for

10
00:00:23,580 --> 00:00:24,960
essentially state-of-the-art code

11
00:00:24,960 --> 00:00:28,080
obfuscation methodologies which leverage

12
00:00:28,080 --> 00:00:30,840
uh transformation on Expressions

13
00:00:30,840 --> 00:00:33,120
combining both arithmetic and Boolean

14
00:00:33,120 --> 00:00:35,520
Expressions okay let's talk about it

15
00:00:35,520 --> 00:00:37,320
today

16
00:00:37,320 --> 00:00:39,660
uh first of all if you want to follow

17
00:00:39,660 --> 00:00:41,700
your slides directly they already

18
00:00:41,700 --> 00:00:44,760
uploaded uh as well as all the materials

19
00:00:44,760 --> 00:00:47,879
in this repository so you just scan this

20
00:00:47,879 --> 00:00:49,739
Square you got this light immediately

21
00:00:49,739 --> 00:00:51,480
the same slides that I'm using in case

22
00:00:51,480 --> 00:00:55,020
you find more uh comfortable to look

23
00:00:55,020 --> 00:00:58,079
to look at them and your devices okay

24
00:00:58,079 --> 00:01:02,100
it's just uh my GitHub repotox you just

25
00:01:02,100 --> 00:01:04,319
navigate to 2022 hack in the Box you

26
00:01:04,319 --> 00:01:06,780
have already those lights available

27
00:01:06,780 --> 00:01:08,820
just a little bit on me very very

28
00:01:08,820 --> 00:01:12,600
briefly I'm a hacker I've been doing

29
00:01:12,600 --> 00:01:14,340
reverse engineer I'm also mathematician

30
00:01:14,340 --> 00:01:17,400
I work doing stuff for a company and I'm

31
00:01:17,400 --> 00:01:19,799
also doing research and trainings with

32
00:01:19,799 --> 00:01:21,659
four Labs which is my own security firm

33
00:01:21,659 --> 00:01:23,939
okay so here you have also some links

34
00:01:23,939 --> 00:01:26,580
that you can follow me around Twitter uh

35
00:01:26,580 --> 00:01:28,619
both on my personal account and also

36
00:01:28,619 --> 00:01:31,939
for Alaska okay

37
00:01:33,840 --> 00:01:36,360
so first a warning this talk this

38
00:01:36,360 --> 00:01:38,100
presentation

39
00:01:38,100 --> 00:01:40,680
may contain and actually will contain a

40
00:01:40,680 --> 00:01:42,659
little bit of math not that much but I

41
00:01:42,659 --> 00:01:46,079
will use so much to explain the basics

42
00:01:46,079 --> 00:01:48,840
of MBA Transformations and also well

43
00:01:48,840 --> 00:01:51,180
some assembly code very very simple but

44
00:01:51,180 --> 00:01:53,640
if you're not very used to I warn you

45
00:01:53,640 --> 00:01:54,780
that there will be a little bit of

46
00:01:54,780 --> 00:01:56,759
assembly code but very simple and we

47
00:01:56,759 --> 00:01:59,960
will go over it if it's necessary

48
00:02:01,079 --> 00:02:03,798
all right

49
00:02:04,979 --> 00:02:06,479
it's really a little bit of the agenda

50
00:02:06,479 --> 00:02:08,520
for today first I want to give you a

51
00:02:08,520 --> 00:02:11,580
little bit of context of where we placed

52
00:02:11,580 --> 00:02:14,220
when we talk about codification

53
00:02:14,220 --> 00:02:16,319
so you want to contextualize that in

54
00:02:16,319 --> 00:02:19,140
general and see where uh

55
00:02:19,140 --> 00:02:21,660
our techniques on the research that is

56
00:02:21,660 --> 00:02:23,819
being done with mixed bone arithmetic

57
00:02:23,819 --> 00:02:26,160
transformation how does it fit Within

58
00:02:26,160 --> 00:02:27,720
These broader context of code

59
00:02:27,720 --> 00:02:29,040
obfuscation

60
00:02:29,040 --> 00:02:32,340
now we'll discuss a little bit about

61
00:02:32,340 --> 00:02:35,220
mbas we'll see some introduction

62
00:02:35,220 --> 00:02:37,800
motivation I'll discuss a little bit

63
00:02:37,800 --> 00:02:40,140
about differences between use of this

64
00:02:40,140 --> 00:02:42,660
kind of expression uh

65
00:02:42,660 --> 00:02:44,580
difference between obfuscation and also

66
00:02:44,580 --> 00:02:46,459
cryptography that might as well use

67
00:02:46,459 --> 00:02:49,920
combined operators from arithmetic and

68
00:02:49,920 --> 00:02:51,420
Boolean Fields as well

69
00:02:51,420 --> 00:02:54,180
and then give some definitions for the

70
00:02:54,180 --> 00:02:57,000
kind of objects that we will be dealing

71
00:02:57,000 --> 00:02:59,580
today essentially polynomial MB

72
00:02:59,580 --> 00:03:01,800
expressions and also subset for them

73
00:03:01,800 --> 00:03:04,440
called linear MB expression

74
00:03:04,440 --> 00:03:06,540
finally we will present some techniques

75
00:03:06,540 --> 00:03:08,519
that leveraging these these tools that

76
00:03:08,519 --> 00:03:10,260
we have with MB Expressions allow us to

77
00:03:10,260 --> 00:03:13,260
obfuscate code essentially both fuscate

78
00:03:13,260 --> 00:03:14,519
Expressions that translate to

79
00:03:14,519 --> 00:03:17,700
obfuscating instructions but also

80
00:03:17,700 --> 00:03:19,739
obfuscating constants themselves will

81
00:03:19,739 --> 00:03:23,640
also motivate a little bit this uh this

82
00:03:23,640 --> 00:03:25,440
kind of obfuscation of constants while

83
00:03:25,440 --> 00:03:28,700
we might be interested in that

84
00:03:28,800 --> 00:03:31,319
so let's talk about first a little bit

85
00:03:31,319 --> 00:03:33,420
about code obfuscation and the context

86
00:03:33,420 --> 00:03:35,760
about code obfuscation

87
00:03:35,760 --> 00:03:38,060
and essentially

88
00:03:38,060 --> 00:03:40,799
godification is one of the technical

89
00:03:40,799 --> 00:03:42,599
techniques or technical protections that

90
00:03:42,599 --> 00:03:45,060
we have against what we call Manatee and

91
00:03:45,060 --> 00:03:47,580
attacks which is a scenario where the

92
00:03:47,580 --> 00:03:49,500
attacker or the analyst depending on

93
00:03:49,500 --> 00:03:52,980
where you put your moral boundaries

94
00:03:52,980 --> 00:03:57,659
is such that it has a control over both

95
00:03:57,659 --> 00:03:59,340
the binary that it's analyzing usually a

96
00:03:59,340 --> 00:04:01,379
binary program uh the code that is

97
00:04:01,379 --> 00:04:03,180
analyzing and also the environment where

98
00:04:03,180 --> 00:04:05,280
this program or this code is being run

99
00:04:05,280 --> 00:04:07,080
okay this is the scenario of Amana DNA

100
00:04:07,080 --> 00:04:09,900
attacks and within this broader scenario

101
00:04:09,900 --> 00:04:12,420
we find a different

102
00:04:12,420 --> 00:04:15,659
categories of protections mostly we can

103
00:04:15,659 --> 00:04:17,279
differentiate legal protections and

104
00:04:17,279 --> 00:04:18,959
Technical protections we won't talk

105
00:04:18,959 --> 00:04:21,238
anything about legal protections today

106
00:04:21,238 --> 00:04:24,180
but they are in there so if doing some

107
00:04:24,180 --> 00:04:26,820
kind of man at the end analysis you

108
00:04:26,820 --> 00:04:28,800
might face some legal lawsuits so that

109
00:04:28,800 --> 00:04:30,540
might be something to take into account

110
00:04:30,540 --> 00:04:32,880
before doing that research or before at

111
00:04:32,880 --> 00:04:34,680
least doing it public

112
00:04:34,680 --> 00:04:36,600
we'll Center specifically on the

113
00:04:36,600 --> 00:04:37,800
technical protections are more

114
00:04:37,800 --> 00:04:39,479
incomplete we'll take a look at

115
00:04:39,479 --> 00:04:41,699
obfuscation which is as you can see it

116
00:04:41,699 --> 00:04:43,560
lays a little bit in the same level as

117
00:04:43,560 --> 00:04:45,120
other kinds of protections that we could

118
00:04:45,120 --> 00:04:46,380
implement

119
00:04:46,380 --> 00:04:49,620
uh to protect our software or code in

120
00:04:49,620 --> 00:04:51,780
such a scenario we have our techniques

121
00:04:51,780 --> 00:04:53,940
such as encryption also server-side

122
00:04:53,940 --> 00:04:56,820
execution so we uh make the execution of

123
00:04:56,820 --> 00:04:58,740
sensitive parts of our code to not be

124
00:04:58,740 --> 00:05:00,360
executed within the client within the

125
00:05:00,360 --> 00:05:02,759
environment and the actual code that the

126
00:05:02,759 --> 00:05:05,160
attacker controls but on an external

127
00:05:05,160 --> 00:05:08,580
server that is from our control also the

128
00:05:08,580 --> 00:05:11,160
recent drastic native code platforms

129
00:05:11,160 --> 00:05:13,740
that are becoming more and more common

130
00:05:13,740 --> 00:05:16,500
and nowadays so these are a bit uh the

131
00:05:16,500 --> 00:05:19,860
great context where obfuscation lays so

132
00:05:19,860 --> 00:05:22,560
I will want you to

133
00:05:22,560 --> 00:05:25,680
understand that obfuscation is just one

134
00:05:25,680 --> 00:05:27,600
of the technical protections it can be

135
00:05:27,600 --> 00:05:29,460
very Advanced protection and very very

136
00:05:29,460 --> 00:05:31,500
used around

137
00:05:31,500 --> 00:05:33,000
for software protection within the

138
00:05:33,000 --> 00:05:34,860
context of this kind of attack this kind

139
00:05:34,860 --> 00:05:37,460
of scenarios

140
00:05:37,580 --> 00:05:40,340
so what is a qualification about

141
00:05:40,340 --> 00:05:43,680
essentially I'm very very broadly it's

142
00:05:43,680 --> 00:05:46,860
uh transformation process that taking as

143
00:05:46,860 --> 00:05:48,900
an input for this transformation process

144
00:05:48,900 --> 00:05:51,780
of initial program P or some code we

145
00:05:51,780 --> 00:05:53,699
will want to transform it into a program

146
00:05:53,699 --> 00:05:55,860
P Prime let's call it or another code

147
00:05:55,860 --> 00:05:57,979
which is functionally equivalent which

148
00:05:57,979 --> 00:06:00,300
behaves in the same way from a semantic

149
00:06:00,300 --> 00:06:03,600
point of view but this transform code we

150
00:06:03,600 --> 00:06:05,759
want it to be way harder to analyze it

151
00:06:05,759 --> 00:06:07,080
and way harder to extract information

152
00:06:07,080 --> 00:06:09,720
from it than from the original code or

153
00:06:09,720 --> 00:06:12,660
the original program okay

154
00:06:12,660 --> 00:06:16,620
motivation essentially I usually do we

155
00:06:16,620 --> 00:06:17,639
would like to prevent reverse

156
00:06:17,639 --> 00:06:19,440
engineering but if you have done you

157
00:06:19,440 --> 00:06:20,639
have some experience around reverse

158
00:06:20,639 --> 00:06:22,319
engineering you know that you never can

159
00:06:22,319 --> 00:06:25,680
prevent it uh like 100 what can you can

160
00:06:25,680 --> 00:06:27,600
do is complicate it to a level where

161
00:06:27,600 --> 00:06:30,720
your adversary would have to waste so

162
00:06:30,720 --> 00:06:34,380
much resources both in time and uh like

163
00:06:34,380 --> 00:06:37,319
full-time employees working towards

164
00:06:37,319 --> 00:06:38,580
reverse engineering something that at

165
00:06:38,580 --> 00:06:41,160
some point they uh it's not worth for

166
00:06:41,160 --> 00:06:43,560
them it will waste so many time

167
00:06:43,560 --> 00:06:45,539
resources different kind of resources

168
00:06:45,539 --> 00:06:50,580
that uh it it makes it so not not worth

169
00:06:50,580 --> 00:06:52,500
to do that so we wanna

170
00:06:52,500 --> 00:06:53,940
actually what we can do is obfuscation

171
00:06:53,940 --> 00:06:56,639
is complicating this process okay uh we

172
00:06:56,639 --> 00:06:59,580
will never prevent it uh

173
00:06:59,580 --> 00:07:01,800
like at all against uh sufficiently

174
00:07:01,800 --> 00:07:03,720
motivated actor with infinite time and

175
00:07:03,720 --> 00:07:06,600
infinite resources but then here it also

176
00:07:06,600 --> 00:07:08,580
plays around your thread modeling okay

177
00:07:08,580 --> 00:07:10,560
so you really need to have a concrete

178
00:07:10,560 --> 00:07:12,960
thread model uh to decide

179
00:07:12,960 --> 00:07:14,940
to which degree one alpha schedule you

180
00:07:14,940 --> 00:07:16,620
want to protect your software

181
00:07:16,620 --> 00:07:18,900
okay

182
00:07:18,900 --> 00:07:21,419
then what is the presence of this kind

183
00:07:21,419 --> 00:07:22,560
of protection this kind of software

184
00:07:22,560 --> 00:07:24,800
obfuscation obfuscation Transformations

185
00:07:24,800 --> 00:07:27,180
essentially we can differentiate two

186
00:07:27,180 --> 00:07:30,720
different big fields for the prevalence

187
00:07:30,720 --> 00:07:32,940
of codification on the first part we can

188
00:07:32,940 --> 00:07:34,680
think of software protection which is

189
00:07:34,680 --> 00:07:35,880
everything that has to do with

190
00:07:35,880 --> 00:07:38,400
intellectual property protection of

191
00:07:38,400 --> 00:07:40,319
intellectual property algorithms or some

192
00:07:40,319 --> 00:07:42,720
algorithms that are being patented or a

193
00:07:42,720 --> 00:07:44,880
part of some proprietary some

194
00:07:44,880 --> 00:07:47,099
proprietary software that the the

195
00:07:47,099 --> 00:07:49,080
algorithm themselves is an important

196
00:07:49,080 --> 00:07:51,539
part of the uh of the intellectual

197
00:07:51,539 --> 00:07:53,759
property for the company or for some

198
00:07:53,759 --> 00:07:56,460
kind of researchers so obfuscation might

199
00:07:56,460 --> 00:07:59,160
get in place to make the extraction the

200
00:07:59,160 --> 00:08:00,720
understanding or even the Reconstruction

201
00:08:00,720 --> 00:08:03,120
of such algorithm or such procedure to

202
00:08:03,120 --> 00:08:05,039
make it way harder

203
00:08:05,039 --> 00:08:07,440
also any kind of digital Rights

204
00:08:07,440 --> 00:08:09,060
Management which

205
00:08:09,060 --> 00:08:11,819
as soon many of you will know is this

206
00:08:11,819 --> 00:08:15,060
super fancy protection schemes that make

207
00:08:15,060 --> 00:08:16,919
that essentially any digital content

208
00:08:16,919 --> 00:08:19,740
that you buy is not yours because then

209
00:08:19,740 --> 00:08:21,539
it gets tied to the platform where you

210
00:08:21,539 --> 00:08:24,300
buy it think of any kind of Netflix

211
00:08:24,300 --> 00:08:27,960
movies uh ebooks on Amazon on any Kindle

212
00:08:27,960 --> 00:08:30,300
all of them come with durian with DRM

213
00:08:30,300 --> 00:08:33,479
which is a way of tying the the the

214
00:08:33,479 --> 00:08:35,458
content the digital content through the

215
00:08:35,458 --> 00:08:37,559
platform or to a concrete account so you

216
00:08:37,559 --> 00:08:39,719
don't really own the content

217
00:08:39,719 --> 00:08:41,580
a lot of the protections the copy

218
00:08:41,580 --> 00:08:43,440
protections are kind of protections for

219
00:08:43,440 --> 00:08:46,440
assuring that you cannot move these uh

220
00:08:46,440 --> 00:08:48,540
these files digital content around

221
00:08:48,540 --> 00:08:52,200
I need to use a lot of

222
00:08:52,200 --> 00:08:54,300
like dirty tricks which are actually

223
00:08:54,300 --> 00:08:56,940
embedded within the source of the the

224
00:08:56,940 --> 00:08:58,380
programs themselves which is this

225
00:08:58,380 --> 00:09:00,120
scenario that we have described so there

226
00:09:00,120 --> 00:09:01,620
is a lot of obfuscation to protect

227
00:09:01,620 --> 00:09:03,540
against reverse Engineers understanding

228
00:09:03,540 --> 00:09:08,160
and uh in an ultimate manner breaking in

229
00:09:08,160 --> 00:09:09,980
some sense DRM scheme so they could

230
00:09:09,980 --> 00:09:12,420
recover the the property of other

231
00:09:12,420 --> 00:09:14,940
digital contents

232
00:09:14,940 --> 00:09:18,720
and also extremely popular nowadays with

233
00:09:18,720 --> 00:09:20,339
everything that has to do with cheering

234
00:09:20,339 --> 00:09:23,940
and teaching walls if you have walked

235
00:09:23,940 --> 00:09:27,060
around the anti-cheating forums uh or

236
00:09:27,060 --> 00:09:27,800
even

237
00:09:27,800 --> 00:09:31,019
during this course around

238
00:09:31,019 --> 00:09:33,480
and there is a lot of obfuscation

239
00:09:33,480 --> 00:09:36,000
present in combination with other kinds

240
00:09:36,000 --> 00:09:37,800
of anti-reverse engineering antivirical

241
00:09:37,800 --> 00:09:39,300
machine and to debuggers and the

242
00:09:39,300 --> 00:09:41,880
analyzers whatever I think for example

243
00:09:41,880 --> 00:09:44,060
of

244
00:09:44,060 --> 00:09:47,880
those super fancy kernel drivers that

245
00:09:47,880 --> 00:09:49,920
you have to be forced to install to play

246
00:09:49,920 --> 00:09:53,100
valorant or to play uh ganshin impact or

247
00:09:53,100 --> 00:09:56,220
those guys are super fancy modern and

248
00:09:56,220 --> 00:09:57,420
cool games

249
00:09:57,420 --> 00:10:00,120
if you have just tried to load one of

250
00:10:00,120 --> 00:10:01,860
those drivers into either into your

251
00:10:01,860 --> 00:10:03,899
favorite disassembly you will see a lot

252
00:10:03,899 --> 00:10:06,000
of garbage that you don't understand

253
00:10:06,000 --> 00:10:07,380
the first place because they are

254
00:10:07,380 --> 00:10:09,120
implementing a lot of protections

255
00:10:09,120 --> 00:10:10,680
against analysis against running them

256
00:10:10,680 --> 00:10:12,779
against debugging them against

257
00:10:12,779 --> 00:10:15,060
these assemblers themselves but also

258
00:10:15,060 --> 00:10:18,360
they use a lot of obfuscation really a

259
00:10:18,360 --> 00:10:20,399
lot of obfuscation so

260
00:10:20,399 --> 00:10:23,640
you know for two for two different

261
00:10:23,640 --> 00:10:26,820
purposes I would say on one side you

262
00:10:26,820 --> 00:10:28,500
really want your auntie cheating a

263
00:10:28,500 --> 00:10:30,839
kernel driver to not be easy to

264
00:10:30,839 --> 00:10:33,240
understand especially making it not easy

265
00:10:33,240 --> 00:10:36,839
to leverage it or bypass it from the

266
00:10:36,839 --> 00:10:38,040
point of view of the Tutors or even

267
00:10:38,040 --> 00:10:40,980
leverage it for uh for doing well you

268
00:10:40,980 --> 00:10:42,779
have a kernel driver with kernel access

269
00:10:42,779 --> 00:10:45,540
so you have some bugs or some way of

270
00:10:45,540 --> 00:10:47,820
interacting with it kind of easily then

271
00:10:47,820 --> 00:10:49,500
bad things happen actually really

272
00:10:49,500 --> 00:10:51,000
recently I think yesterday there was a

273
00:10:51,000 --> 00:10:54,000
news for some news about uh some problem

274
00:10:54,000 --> 00:10:56,040
of some malware dropping the against an

275
00:10:56,040 --> 00:10:59,160
impact kernel driver to load some some

276
00:10:59,160 --> 00:11:00,899
of its code and with kernel permission

277
00:11:00,899 --> 00:11:04,680
so yeah I'm teaching products I use a

278
00:11:04,680 --> 00:11:07,079
lot of obfuscation to make it way harder

279
00:11:07,079 --> 00:11:08,279
especially

280
00:11:08,279 --> 00:11:11,220
for for cheaters to understand the games

281
00:11:11,220 --> 00:11:13,940
and also not only in the specific

282
00:11:13,940 --> 00:11:16,380
attitude components but also within the

283
00:11:16,380 --> 00:11:18,899
games themselves so making some parts of

284
00:11:18,899 --> 00:11:22,980
the games uh run in a way that is very

285
00:11:22,980 --> 00:11:24,540
difficult to understand there's a super

286
00:11:24,540 --> 00:11:27,600
obfuscated so an attacker analyst has a

287
00:11:27,600 --> 00:11:28,860
really hard time trying to reverse

288
00:11:28,860 --> 00:11:30,180
engineering to understanding what's

289
00:11:30,180 --> 00:11:33,360
happening that slows like slows a lot

290
00:11:33,360 --> 00:11:34,800
the process and makes the the other

291
00:11:34,800 --> 00:11:36,480
prosecutors to have the best a lot of

292
00:11:36,480 --> 00:11:38,339
resources a lot of time and

293
00:11:38,339 --> 00:11:40,260
understanding that code so they can

294
00:11:40,260 --> 00:11:42,360
ultimately try to build some kind of

295
00:11:42,360 --> 00:11:44,880
cheat around it okay so within the

296
00:11:44,880 --> 00:11:46,320
entity engineering wall there's a lot of

297
00:11:46,320 --> 00:11:47,640
obfuscation

298
00:11:47,640 --> 00:11:50,160
and also in the other way around cheats

299
00:11:50,160 --> 00:11:51,560
out there

300
00:11:51,560 --> 00:11:53,940
Implement also a lot of obfuscations so

301
00:11:53,940 --> 00:11:56,459
companies gaming companies working on

302
00:11:56,459 --> 00:11:58,680
anti-cheating they have to spend a lot

303
00:11:58,680 --> 00:12:00,240
of research understanding the cheats

304
00:12:00,240 --> 00:12:01,800
themselves to understand the problems

305
00:12:01,800 --> 00:12:03,600
that are affecting them process yeah two

306
00:12:03,600 --> 00:12:07,019
way uh towards World in that sense

307
00:12:07,019 --> 00:12:10,019
the other very very popular

308
00:12:10,019 --> 00:12:12,300
uh

309
00:12:12,300 --> 00:12:14,700
scenario where software obfuscation is

310
00:12:14,700 --> 00:12:16,920
present is of course malware threats

311
00:12:16,920 --> 00:12:18,839
very very all kinds of different

312
00:12:18,839 --> 00:12:21,480
obfuscation and essentially the

313
00:12:21,480 --> 00:12:24,959
motivation on one hand is a some point

314
00:12:24,959 --> 00:12:27,360
one avoid automatic signature detection

315
00:12:27,360 --> 00:12:29,640
so if we are doing some kind of

316
00:12:29,640 --> 00:12:31,200
obfuscation transformation even if it's

317
00:12:31,200 --> 00:12:33,300
not very complicated if we are actually

318
00:12:33,300 --> 00:12:35,579
changing the extractor of the code or

319
00:12:35,579 --> 00:12:37,140
even the instructions themselves to

320
00:12:37,140 --> 00:12:40,079
something different than we can bypass

321
00:12:40,079 --> 00:12:43,019
the automatic signature generation for

322
00:12:43,019 --> 00:12:45,120
our samples on our given campaign for

323
00:12:45,120 --> 00:12:47,880
example but in general they are

324
00:12:47,880 --> 00:12:50,100
this kind of

325
00:12:50,100 --> 00:12:52,019
not that big right now because most

326
00:12:52,019 --> 00:12:55,139
antivirus products or edrs or whatever

327
00:12:55,139 --> 00:12:58,500
they try to they don't really rely on

328
00:12:58,500 --> 00:13:00,240
signature status signatures anymore they

329
00:13:00,240 --> 00:13:04,620
analyze for behavioral behavioral

330
00:13:04,680 --> 00:13:07,139
analysis of the of the samples out there

331
00:13:07,139 --> 00:13:10,260
so really it's a lot more for slowing

332
00:13:10,260 --> 00:13:12,000
down the analyzes of the samples of the

333
00:13:12,000 --> 00:13:14,220
campaigns which means usually more time

334
00:13:14,220 --> 00:13:16,500
there are campaigns active which usually

335
00:13:16,500 --> 00:13:18,540
translates to more money through

336
00:13:18,540 --> 00:13:19,740
whatever that means that they are

337
00:13:19,740 --> 00:13:22,320
they're making the money with a malware

338
00:13:22,320 --> 00:13:26,000
campaign our actors

339
00:13:26,220 --> 00:13:28,139
what is the

340
00:13:28,139 --> 00:13:32,579
super in a nutshell the methodology and

341
00:13:32,579 --> 00:13:34,620
in big words

342
00:13:34,620 --> 00:13:37,920
of obfuscation so you want to apply a

343
00:13:37,920 --> 00:13:39,540
transformation some kind of

344
00:13:39,540 --> 00:13:41,040
transformation to the program to the

345
00:13:41,040 --> 00:13:43,459
code that message that complicates

346
00:13:43,459 --> 00:13:45,899
both the control flow and the data flow

347
00:13:45,899 --> 00:13:47,339
of the program the control flow is

348
00:13:47,339 --> 00:13:50,519
essentially uh the way in which

349
00:13:50,519 --> 00:13:53,040
um the the con all the control

350
00:13:53,040 --> 00:13:55,860
structures of our program are related to

351
00:13:55,860 --> 00:13:57,180
each other think of all the branching

352
00:13:57,180 --> 00:13:59,519
condition or the looping conditions if

353
00:13:59,519 --> 00:14:02,399
you have open uh any disassemble the

354
00:14:02,399 --> 00:14:04,079
control flow graph the graph view of a

355
00:14:04,079 --> 00:14:05,639
function that's the representation of

356
00:14:05,639 --> 00:14:06,720
the control forward if you're giving

357
00:14:06,720 --> 00:14:09,000
function so we want to mess with that

358
00:14:09,000 --> 00:14:11,279
control 4 and also a data flow data flow

359
00:14:11,279 --> 00:14:14,639
is a way of representing uh what is the

360
00:14:14,639 --> 00:14:16,920
the flow what is the the path that the

361
00:14:16,920 --> 00:14:19,380
data is taking where some variables are

362
00:14:19,380 --> 00:14:21,600
declared where they are used where they

363
00:14:21,600 --> 00:14:23,100
are updated

364
00:14:23,100 --> 00:14:25,079
um through the Eco themselves across the

365
00:14:25,079 --> 00:14:26,399
same function or different functions so

366
00:14:26,399 --> 00:14:29,279
we want to mess to complicate about the

367
00:14:29,279 --> 00:14:31,139
control flow on the data flow of a

368
00:14:31,139 --> 00:14:32,639
program and we can do that at different

369
00:14:32,639 --> 00:14:35,160
abstraction levels okay different

370
00:14:35,160 --> 00:14:36,420
abstraction levels that we could

371
00:14:36,420 --> 00:14:38,160
introduce obfuscation could be for

372
00:14:38,160 --> 00:14:40,139
example directly in a source code we

373
00:14:40,139 --> 00:14:42,120
could place a possession transformation

374
00:14:42,120 --> 00:14:44,160
directly in the source code this is very

375
00:14:44,160 --> 00:14:47,279
visual uh usually then you need some

376
00:14:47,279 --> 00:14:49,920
kind of control over the compilers in

377
00:14:49,920 --> 00:14:51,899
order to hey don't optimize that or

378
00:14:51,899 --> 00:14:53,760
don't touch this thing that I did this

379
00:14:53,760 --> 00:14:56,040
on purpose so don't touch it but you can

380
00:14:56,040 --> 00:14:57,360
do that on source code there are some

381
00:14:57,360 --> 00:14:59,220
tools around there that actually produce

382
00:14:59,220 --> 00:15:01,519
obfuscation on source code for example

383
00:15:01,519 --> 00:15:05,160
VM protect is a widely known obfuscate

384
00:15:05,160 --> 00:15:07,260
or based on virtual machine obfuscation

385
00:15:07,260 --> 00:15:09,120
obfuscation we will see a little bit on

386
00:15:09,120 --> 00:15:10,860
the demos about virtual machine

387
00:15:10,860 --> 00:15:12,480
obfuscation

388
00:15:12,480 --> 00:15:15,000
and it works on source code okay you

389
00:15:15,000 --> 00:15:17,160
just Implement some directives on your C

390
00:15:17,160 --> 00:15:20,339
or C plus plus files to include it

391
00:15:20,339 --> 00:15:22,260
then obfuscation can also work on

392
00:15:22,260 --> 00:15:23,880
compiled binaries themselves you just

393
00:15:23,880 --> 00:15:25,139
get your compile binary and apply

394
00:15:25,139 --> 00:15:28,279
obstruction in them this is on one hand

395
00:15:28,279 --> 00:15:32,100
the best way of having really concrete

396
00:15:32,100 --> 00:15:34,139
control of what will end up being in the

397
00:15:34,139 --> 00:15:35,279
binary because you're modifying the

398
00:15:35,279 --> 00:15:38,399
binary itself but then it might be also

399
00:15:38,399 --> 00:15:40,380
you need some engineering work some

400
00:15:40,380 --> 00:15:41,940
thinking process because if you are

401
00:15:41,940 --> 00:15:44,339
modifying a binary by itself then

402
00:15:44,339 --> 00:15:46,139
probably you're modifying the offsets

403
00:15:46,139 --> 00:15:48,540
and the references of everything and you

404
00:15:48,540 --> 00:15:49,680
would need of course to update the

405
00:15:49,680 --> 00:15:51,199
header of the binary but also probably

406
00:15:51,199 --> 00:15:54,240
reconstruct all the all the relative

407
00:15:54,240 --> 00:15:56,519
references within the code itself and if

408
00:15:56,519 --> 00:15:58,740
that code is called for example a

409
00:15:58,740 --> 00:16:00,420
library used by alert code you might

410
00:16:00,420 --> 00:16:02,699
need to fix also the offsets for the

411
00:16:02,699 --> 00:16:04,260
functions exporting and things like that

412
00:16:04,260 --> 00:16:05,760
but it's definitely possible and there

413
00:16:05,760 --> 00:16:07,440
are products out there not as much

414
00:16:07,440 --> 00:16:09,839
products at least publicly but

415
00:16:09,839 --> 00:16:11,519
their private products software

416
00:16:11,519 --> 00:16:13,079
protectors that do exactly that they

417
00:16:13,079 --> 00:16:15,540
work on the compile binaries

418
00:16:15,540 --> 00:16:17,100
and then we could also work on

419
00:16:17,100 --> 00:16:20,040
intermediate representations and if you

420
00:16:20,040 --> 00:16:21,420
have done any kind of compiling with

421
00:16:21,420 --> 00:16:24,540
silang you might be familiar with llvm

422
00:16:24,540 --> 00:16:25,980
intermediate representation for example

423
00:16:25,980 --> 00:16:27,899
there are a lot of them but this is

424
00:16:27,899 --> 00:16:29,579
quite quite known

425
00:16:29,579 --> 00:16:32,100
and this is in this sense for example

426
00:16:32,100 --> 00:16:34,260
for a llvm intermediate representation

427
00:16:34,260 --> 00:16:36,959
it's quite common to perform obfuscation

428
00:16:36,959 --> 00:16:38,699
on that step because then you have your

429
00:16:38,699 --> 00:16:41,820
compiler uh like the first step on a

430
00:16:41,820 --> 00:16:43,440
compile pipeline just translating the

431
00:16:43,440 --> 00:16:45,839
source code to llvm and then in the same

432
00:16:45,839 --> 00:16:47,579
way in null game that you would apply

433
00:16:47,579 --> 00:16:49,740
optimization passes for example you

434
00:16:49,740 --> 00:16:51,380
could perform your own custom

435
00:16:51,380 --> 00:16:54,420
obfuscation passes within the llvm bitco

436
00:16:54,420 --> 00:16:56,519
directly and then this gets translated

437
00:16:56,519 --> 00:16:58,620
that's compiled back to any native

438
00:16:58,620 --> 00:17:00,000
architecture that you would want to do

439
00:17:00,000 --> 00:17:02,100
okay

440
00:17:02,100 --> 00:17:04,199
so we have a transformation that

441
00:17:04,199 --> 00:17:06,059
complicates a message about the control

442
00:17:06,059 --> 00:17:07,559
data flow at different abstraction

443
00:17:07,559 --> 00:17:09,720
levels that we have discussed and they

444
00:17:09,720 --> 00:17:11,459
also can affect different Target units

445
00:17:11,459 --> 00:17:13,679
when Target units can be well we could

446
00:17:13,679 --> 00:17:15,419
obfuscate the whole program which is not

447
00:17:15,419 --> 00:17:17,099
something very

448
00:17:17,099 --> 00:17:18,059
um

449
00:17:18,059 --> 00:17:20,699
usual to see uh just plugging a whole

450
00:17:20,699 --> 00:17:22,199
problem and then obfuscate it in some

451
00:17:22,199 --> 00:17:24,299
way but definitely you can for example

452
00:17:24,299 --> 00:17:26,640
transform an entire program into a

453
00:17:26,640 --> 00:17:28,799
virtualized obfuscation implementation

454
00:17:28,799 --> 00:17:31,820
but what is more common is usually

455
00:17:31,820 --> 00:17:33,840
obfuscate a function or a set of

456
00:17:33,840 --> 00:17:36,000
functions or even some basic blocks or

457
00:17:36,000 --> 00:17:37,620
even some instruction or some basic

458
00:17:37,620 --> 00:17:40,020
operations so it's very complicated to

459
00:17:40,020 --> 00:17:41,880
understand just for taking a look at it

460
00:17:41,880 --> 00:17:44,340
or even within a dynamic analysis if you

461
00:17:44,340 --> 00:17:46,320
are not very very certain of what you're

462
00:17:46,320 --> 00:17:49,020
looking at making it very difficult to

463
00:17:49,020 --> 00:17:51,179
understand okay so we have we can Target

464
00:17:51,179 --> 00:17:53,100
different Target units either on the

465
00:17:53,100 --> 00:17:54,780
source code on a compile binary on an

466
00:17:54,780 --> 00:17:56,640
intimate representation and that will

467
00:17:56,640 --> 00:17:58,380
mess around with the control from the

468
00:17:58,380 --> 00:18:01,380
data flow of the programs

469
00:18:01,380 --> 00:18:04,799
so just like we remarking here there are

470
00:18:04,799 --> 00:18:07,380
a lot of obfuscation techniques okay a

471
00:18:07,380 --> 00:18:08,460
lot of them

472
00:18:08,460 --> 00:18:10,260
um you can come up with something new

473
00:18:10,260 --> 00:18:11,580
that might be a new obfuscation

474
00:18:11,580 --> 00:18:15,440
technique okay or a combination of them

475
00:18:15,440 --> 00:18:17,340
usually like to mention is that

476
00:18:17,340 --> 00:18:19,140
sometimes you read of some obfuscation

477
00:18:19,140 --> 00:18:20,400
techniques which you might think well

478
00:18:20,400 --> 00:18:22,740
this is okay it's clever trick but it's

479
00:18:22,740 --> 00:18:26,100
not very hard to spot or even to

480
00:18:26,100 --> 00:18:28,919
reverted back but usually obfuscation

481
00:18:28,919 --> 00:18:30,480
schemes can be used

482
00:18:30,480 --> 00:18:33,900
combined combined with with another an

483
00:18:33,900 --> 00:18:34,919
arbitrary number of different

484
00:18:34,919 --> 00:18:36,600
obfuscation schemes being combined in

485
00:18:36,600 --> 00:18:38,580
different orders in their leave which

486
00:18:38,580 --> 00:18:40,200
means that many times you can use

487
00:18:40,200 --> 00:18:43,080
several weak application transformation

488
00:18:43,080 --> 00:18:45,240
notification techniques but you end up

489
00:18:45,240 --> 00:18:47,220
the combination of them with a

490
00:18:47,220 --> 00:18:48,780
suggestion order and certain amount of

491
00:18:48,780 --> 00:18:50,100
them and you end up with a very strong

492
00:18:50,100 --> 00:18:51,600
protection from the point of view of

493
00:18:51,600 --> 00:18:54,179
making the problem understandable or

494
00:18:54,179 --> 00:18:58,160
easy to analyze extract information okay

495
00:19:01,980 --> 00:19:04,940
foreign

496
00:19:09,440 --> 00:19:12,240
protection codification

497
00:19:12,240 --> 00:19:14,940
let's discuss a little bit about mbas

498
00:19:14,940 --> 00:19:17,700
this will be a part where at some point

499
00:19:17,700 --> 00:19:18,960
there will be a little bit of math but

500
00:19:18,960 --> 00:19:21,000
we'll go over it we have plenty of time

501
00:19:21,000 --> 00:19:23,100
to discuss it it will be very complex

502
00:19:23,100 --> 00:19:25,440
and everything will be explained and

503
00:19:25,440 --> 00:19:27,900
translated into C and python assembly

504
00:19:27,900 --> 00:19:32,299
whatever okay so don't worry about it

505
00:19:32,580 --> 00:19:35,400
uh basically an MBA expression a mix

506
00:19:35,400 --> 00:19:36,960
Bull and arithmetic expression as the

507
00:19:36,960 --> 00:19:38,940
name suggests is just an expression and

508
00:19:38,940 --> 00:19:41,340
an algebraic expression and if the word

509
00:19:41,340 --> 00:19:43,260
algebra confuses you just forget about

510
00:19:43,260 --> 00:19:46,140
it uh it's just an expression which is

511
00:19:46,140 --> 00:19:48,380
as name suggests composed by both

512
00:19:48,380 --> 00:19:51,360
interior operations integral arithmetic

513
00:19:51,360 --> 00:19:53,039
operators essentially additions

514
00:19:53,039 --> 00:19:55,980
subtraction multiplication but also B

515
00:19:55,980 --> 00:19:58,260
device or Boolean operators I will use a

516
00:19:58,260 --> 00:20:00,780
Boolean and bitwise in a interchangeably

517
00:20:00,780 --> 00:20:03,840
monarchy here we have for example

518
00:20:03,840 --> 00:20:07,200
and or xor and not okay if you're not

519
00:20:07,200 --> 00:20:10,380
familiar with like formal notation for

520
00:20:10,380 --> 00:20:11,940
this kind of operators this is your

521
00:20:11,940 --> 00:20:15,120
usual and the usual or this is your xor

522
00:20:15,120 --> 00:20:16,679
and these are you're not your negation

523
00:20:16,679 --> 00:20:18,919
okay

524
00:20:20,400 --> 00:20:23,580
so this is a very simple example of uh

525
00:20:23,580 --> 00:20:25,380
mixed-born arithmetic expression this is

526
00:20:25,380 --> 00:20:26,580
just an expression

527
00:20:26,580 --> 00:20:28,440
a very simple expression that combines

528
00:20:28,440 --> 00:20:31,500
operators both for arithmetic uh

529
00:20:31,500 --> 00:20:32,940
integral for arithmetics for example the

530
00:20:32,940 --> 00:20:35,700
addition and also the implicit

531
00:20:35,700 --> 00:20:38,760
multiplication here but also bitwise

532
00:20:38,760 --> 00:20:41,520
operators Boon operators this xor and

533
00:20:41,520 --> 00:20:44,280
also this and okay so it's very simple

534
00:20:44,280 --> 00:20:46,980
mix one arithmetic expression just for

535
00:20:46,980 --> 00:20:48,720
you to get a sense of what does it look

536
00:20:48,720 --> 00:20:49,740
like

537
00:20:49,740 --> 00:20:51,720
in general

538
00:20:51,720 --> 00:20:54,900
so MBA Expressions we can leverage them

539
00:20:54,900 --> 00:20:56,280
to obfuscate

540
00:20:56,280 --> 00:20:58,679
mainly the data flow of the code but

541
00:20:58,679 --> 00:21:00,360
then we will see the demos that by

542
00:21:00,360 --> 00:21:02,940
obfuscating the data flow we bring new

543
00:21:02,940 --> 00:21:04,440
opportunities to also for skate control

544
00:21:04,440 --> 00:21:06,780
flow we'll see that in the Demos in a

545
00:21:06,780 --> 00:21:07,500
second

546
00:21:07,500 --> 00:21:11,100
essential the basic way of doing that is

547
00:21:11,100 --> 00:21:13,380
applying rewrite rules and a session of

548
00:21:13,380 --> 00:21:15,240
identities as essentially some kind of

549
00:21:15,240 --> 00:21:16,679
transformation that we will discuss in a

550
00:21:16,679 --> 00:21:19,500
second to a given expression

551
00:21:19,500 --> 00:21:22,260
uh given we have an initial kind of

552
00:21:22,260 --> 00:21:23,880
simple expression or none of the scary

553
00:21:23,880 --> 00:21:25,620
expression we apply some transformation

554
00:21:25,620 --> 00:21:27,840
processes that will transform this

555
00:21:27,840 --> 00:21:30,059
expression into another expression

556
00:21:30,059 --> 00:21:33,539
another MBA expression which will be way

557
00:21:33,539 --> 00:21:35,280
more complex from a syntactic point of

558
00:21:35,280 --> 00:21:37,020
view from the point of view of writing

559
00:21:37,020 --> 00:21:38,640
it from the point of view of the amount

560
00:21:38,640 --> 00:21:40,620
and the complexity of the instructions

561
00:21:40,620 --> 00:21:42,059
of the assembly instructions if you want

562
00:21:42,059 --> 00:21:43,500
to think it that way that they will get

563
00:21:43,500 --> 00:21:45,419
translated into but what is really

564
00:21:45,419 --> 00:21:47,400
important is that we want to preserve

565
00:21:47,400 --> 00:21:48,919
the semantic Behavior

566
00:21:48,919 --> 00:21:51,900
Behavior means that the opposite

567
00:21:51,900 --> 00:21:54,360
expression the obfuscated resulting code

568
00:21:54,360 --> 00:21:56,640
will produce exactly the same behavior

569
00:21:56,640 --> 00:21:58,980
that is given the same set of inputs it

570
00:21:58,980 --> 00:22:00,539
will produce always the same output as

571
00:22:00,539 --> 00:22:02,159
the original non-offuscated simple

572
00:22:02,159 --> 00:22:03,840
expression that's the whole idea we have

573
00:22:03,840 --> 00:22:05,640
behind obfuscation we have one to

574
00:22:05,640 --> 00:22:08,640
preserve the semantic behavior of

575
00:22:08,640 --> 00:22:12,500
our obfuscated counterparts

576
00:22:13,380 --> 00:22:17,179
why can we do that what is the

577
00:22:17,179 --> 00:22:20,940
like roughly the motivation that we are

578
00:22:20,940 --> 00:22:22,679
interested in doing that and it makes

579
00:22:22,679 --> 00:22:24,659
sense to do this kind of Transformations

580
00:22:24,659 --> 00:22:26,760
essentially

581
00:22:26,760 --> 00:22:28,799
a little bit sometimes I'm a little bit

582
00:22:28,799 --> 00:22:31,020
too rough to research with themselves

583
00:22:31,020 --> 00:22:33,780
but essentially it's because we did not

584
00:22:33,780 --> 00:22:36,059
have any idea how these things work so

585
00:22:36,059 --> 00:22:38,520
we are very ignorant in this field we've

586
00:22:38,520 --> 00:22:40,380
been using computers which have an

587
00:22:40,380 --> 00:22:42,419
arithmetic logic unit for decades and we

588
00:22:42,419 --> 00:22:44,460
don't really know the Expressions that

589
00:22:44,460 --> 00:22:47,580
come from that how they actually work so

590
00:22:47,580 --> 00:22:49,440
we don't have really

591
00:22:49,440 --> 00:22:52,559
a way of reasoning about mixed

592
00:22:52,559 --> 00:22:54,900
arithmetic algebraic expressions in

593
00:22:54,900 --> 00:22:57,600
general when we introduce this mixing of

594
00:22:57,600 --> 00:22:59,460
operators then they do not interact well

595
00:22:59,460 --> 00:23:00,720
in the sense that we lost General

596
00:23:00,720 --> 00:23:03,240
distributivity associativity even

597
00:23:03,240 --> 00:23:05,640
factorization which is a way of kind of

598
00:23:05,640 --> 00:23:07,200
separating the Expressions into things

599
00:23:07,200 --> 00:23:09,840
that we can reason about separately

600
00:23:09,840 --> 00:23:12,659
or in general any theory that allows us

601
00:23:12,659 --> 00:23:14,820
to deal with this mixing of operators as

602
00:23:14,820 --> 00:23:15,740
we have

603
00:23:15,740 --> 00:23:18,780
extensively developed for arithmetic

604
00:23:18,780 --> 00:23:21,120
Expressions normal arithmetic

605
00:23:21,120 --> 00:23:22,980
expressions or even for Boolean

606
00:23:22,980 --> 00:23:25,860
Expressions we have a lot of tools and

607
00:23:25,860 --> 00:23:28,080
and theory developed and methods to

608
00:23:28,080 --> 00:23:29,760
develop to work with them so when we are

609
00:23:29,760 --> 00:23:31,440
mixing both of these kind of operators

610
00:23:31,440 --> 00:23:32,880
then we enter to

611
00:23:32,880 --> 00:23:34,860
uh went into a place to some

612
00:23:34,860 --> 00:23:37,320
mathematical structures about which we

613
00:23:37,320 --> 00:23:40,679
don't really know how they work and we

614
00:23:40,679 --> 00:23:43,799
are very ignorant still about them and

615
00:23:43,799 --> 00:23:47,240
they are very hard to do actually

616
00:23:49,140 --> 00:23:51,539
so just a few words before continuing

617
00:23:51,539 --> 00:23:52,799
because some of you might be thinking

618
00:23:52,799 --> 00:23:55,140
yeah but is that isn't that kind of

619
00:23:55,140 --> 00:23:57,360
mixing cup operators kind of the same

620
00:23:57,360 --> 00:23:59,700
that happens in cryptography like in a

621
00:23:59,700 --> 00:24:01,620
crypto system definition you usually

622
00:24:01,620 --> 00:24:04,080
getting some input and then

623
00:24:04,080 --> 00:24:06,360
mixing it together in different ways

624
00:24:06,360 --> 00:24:09,000
using both operators from arithmetic

625
00:24:09,000 --> 00:24:11,280
World on both Boolean operators to

626
00:24:11,280 --> 00:24:12,780
produce the output to produce whatever

627
00:24:12,780 --> 00:24:14,880
the resulting crypto system is a hash

628
00:24:14,880 --> 00:24:16,799
function or an asymmetric encryption

629
00:24:16,799 --> 00:24:18,900
asymmetric encryption or whatever

630
00:24:18,900 --> 00:24:20,640
so yeah in a sense you're using the same

631
00:24:20,640 --> 00:24:23,480
kind of basic logs in the sense of

632
00:24:23,480 --> 00:24:26,039
arithmetic operators and Boolean

633
00:24:26,039 --> 00:24:28,620
operators but first

634
00:24:28,620 --> 00:24:31,799
a couple well an historic note the term

635
00:24:31,799 --> 00:24:34,980
of mbas of mixed one arithmetic algebra

636
00:24:34,980 --> 00:24:37,440
and expressions came from obfuscation

637
00:24:37,440 --> 00:24:40,799
research okay in cryptography they

638
00:24:40,799 --> 00:24:43,140
usually don't use this term like at all

639
00:24:43,140 --> 00:24:45,240
so if you read something about MBA

640
00:24:45,240 --> 00:24:46,799
expression usually is within the context

641
00:24:46,799 --> 00:24:48,500
of obfuscation because the term itself

642
00:24:48,500 --> 00:24:51,120
has been introduced and has been mainly

643
00:24:51,120 --> 00:24:53,159
and I would say only used within this

644
00:24:53,159 --> 00:24:54,120
context

645
00:24:54,120 --> 00:24:56,700
but going to the actual differences to

646
00:24:56,700 --> 00:24:58,740
the actual

647
00:24:58,740 --> 00:25:00,720
um yeah the difference between

648
00:25:00,720 --> 00:25:03,299
cryptography and obfuscation with the

649
00:25:03,299 --> 00:25:04,740
use of this kind of Expressions this

650
00:25:04,740 --> 00:25:06,659
kind of mixing of operators you would

651
00:25:06,659 --> 00:25:10,740
say that in cryptography uh the the MB

652
00:25:10,740 --> 00:25:12,960
Expressions that result for from the

653
00:25:12,960 --> 00:25:14,220
application of the crypto system

654
00:25:14,220 --> 00:25:15,840
description from the crypto algorithm

655
00:25:15,840 --> 00:25:19,020
for the hashing algorithm are in a way I

656
00:25:19,020 --> 00:25:20,940
intended to verify that they are hard

657
00:25:20,940 --> 00:25:22,860
they are complex from a semantic point

658
00:25:22,860 --> 00:25:24,360
of view from a black box point of view

659
00:25:24,360 --> 00:25:26,400
from the point of view of throwing some

660
00:25:26,400 --> 00:25:28,799
inputs of taking a look at the outputs

661
00:25:28,799 --> 00:25:31,740
and the semantics that can describe this

662
00:25:31,740 --> 00:25:33,600
relationship we want them to be very

663
00:25:33,600 --> 00:25:35,520
hard and by very hard we mean that we

664
00:25:35,520 --> 00:25:38,520
want them not to be invertible okay

665
00:25:38,520 --> 00:25:40,860
otherwise would make no sense

666
00:25:40,860 --> 00:25:44,279
so in a sense uh the complex way of

667
00:25:44,279 --> 00:25:47,760
writing this crypto system definitions

668
00:25:47,760 --> 00:25:49,740
this algorithms this cryptographic

669
00:25:49,740 --> 00:25:51,480
algorithms that can combine operations

670
00:25:51,480 --> 00:25:54,120
from both arithmetics integral

671
00:25:54,120 --> 00:25:56,220
arithmetics and Boolean operators is

672
00:25:56,220 --> 00:25:59,100
kind of directly related with an

673
00:25:59,100 --> 00:26:00,600
intrinsic semantic complexity

674
00:26:00,600 --> 00:26:02,820
computational complexity of the output

675
00:26:02,820 --> 00:26:05,340
of the cryptosystem of the result of the

676
00:26:05,340 --> 00:26:07,260
application of this of this expression

677
00:26:07,260 --> 00:26:12,120
so in a summary in cryptography a

678
00:26:12,120 --> 00:26:14,220
complex syntax that means a complex the

679
00:26:14,220 --> 00:26:16,440
complex way of writing the expression

680
00:26:16,440 --> 00:26:18,720
themselves is directly related with a

681
00:26:18,720 --> 00:26:20,640
complexity in the semantics in the

682
00:26:20,640 --> 00:26:22,740
behavior that we want to obtain whereas

683
00:26:22,740 --> 00:26:25,020
in obfuscation what we are doing

684
00:26:25,020 --> 00:26:27,679
actually is starting from a simple

685
00:26:27,679 --> 00:26:30,179
expression from an expression that has

686
00:26:30,179 --> 00:26:31,679
very simple semantics you want to

687
00:26:31,679 --> 00:26:33,240
complicate it we want to mess around we

688
00:26:33,240 --> 00:26:35,100
want to produce a transformation that

689
00:26:35,100 --> 00:26:37,919
gives us an obfuscated transfer an

690
00:26:37,919 --> 00:26:39,600
obfuscated expression a very complex

691
00:26:39,600 --> 00:26:41,100
expression from the point of view of the

692
00:26:41,100 --> 00:26:42,480
syntax from the point of view of the

693
00:26:42,480 --> 00:26:44,840
form of writing name but instead of

694
00:26:44,840 --> 00:26:47,760
being related to also a very complex

695
00:26:47,760 --> 00:26:49,559
semantic as this was the case in

696
00:26:49,559 --> 00:26:52,799
cryptography actually we are expecting

697
00:26:52,799 --> 00:26:55,559
and we are building them so that the

698
00:26:55,559 --> 00:26:57,840
semantics that are related to the

699
00:26:57,840 --> 00:27:00,659
complex form of writing are actually

700
00:27:00,659 --> 00:27:02,220
very simple that's the whole point of

701
00:27:02,220 --> 00:27:04,679
our obfuscational simple expression we

702
00:27:04,679 --> 00:27:07,080
want to preserve this semantics are kind

703
00:27:07,080 --> 00:27:08,700
of simple semantics but we want to

704
00:27:08,700 --> 00:27:10,080
present that in a way that is very

705
00:27:10,080 --> 00:27:12,179
complex to deal with from a synthetic

706
00:27:12,179 --> 00:27:13,799
from one point of view from the point of

707
00:27:13,799 --> 00:27:15,240
view of looking at the Expressions

708
00:27:15,240 --> 00:27:16,799
looking at the code generated from that

709
00:27:16,799 --> 00:27:19,039
okay

710
00:27:20,400 --> 00:27:23,340
uh needless to say but we'll be focusing

711
00:27:23,340 --> 00:27:25,679
during the session and also my research

712
00:27:25,679 --> 00:27:29,039
in general uh with mbas is always within

713
00:27:29,039 --> 00:27:31,140
the context of software protection and

714
00:27:31,140 --> 00:27:32,820
particular code obfuscation code the

715
00:27:32,820 --> 00:27:36,000
obfuscation okay so you won't be talking

716
00:27:36,000 --> 00:27:37,740
a lot about cryptography in the sense

717
00:27:37,740 --> 00:27:39,840
but I want to make the that distinction

718
00:27:39,840 --> 00:27:41,700
because it's important to keep in mind

719
00:27:41,700 --> 00:27:43,799
especially if you just have laying

720
00:27:43,799 --> 00:27:45,720
around okay but aren't those kind of

721
00:27:45,720 --> 00:27:48,179
Expressions the same as in cryptography

722
00:27:48,179 --> 00:27:50,100
yes but not for the same purpose I'm not

723
00:27:50,100 --> 00:27:53,178
using the same way okay

724
00:27:59,100 --> 00:28:04,020
so let's start with some definitions uh

725
00:28:04,020 --> 00:28:08,400
either derivately this decided to put

726
00:28:08,400 --> 00:28:11,279
the definitions of MBA expressions in a

727
00:28:11,279 --> 00:28:14,100
constructive way and I mean in a way of

728
00:28:14,100 --> 00:28:16,440
just describing explicitly what are the

729
00:28:16,440 --> 00:28:18,539
basic blocks what are the different kind

730
00:28:18,539 --> 00:28:20,100
of operators and in which ways we

731
00:28:20,100 --> 00:28:22,860
combine them instead of giving a more

732
00:28:22,860 --> 00:28:25,260
formal definition that exists but wow

733
00:28:25,260 --> 00:28:27,179
side note I'm not super happy about the

734
00:28:27,179 --> 00:28:28,559
definition I don't think this is the

735
00:28:28,559 --> 00:28:31,860
best definition so also for our

736
00:28:31,860 --> 00:28:34,260
practical standpoint and for the purpose

737
00:28:34,260 --> 00:28:35,960
of obfuscation the obfuscation just

738
00:28:35,960 --> 00:28:38,940
defining MB expressions in in terms of

739
00:28:38,940 --> 00:28:41,220
describing the different operators that

740
00:28:41,220 --> 00:28:42,720
they get combined together and in which

741
00:28:42,720 --> 00:28:45,059
way they keep combined together and will

742
00:28:45,059 --> 00:28:46,679
be more than enough and a little bit a

743
00:28:46,679 --> 00:28:48,480
little bit more simple to understand in

744
00:28:48,480 --> 00:28:50,760
this sense

745
00:28:50,760 --> 00:28:54,960
we usually uh when doing research on the

746
00:28:54,960 --> 00:28:56,700
early research articles on literature

747
00:28:56,700 --> 00:28:58,440
which is very scarce so there is not a

748
00:28:58,440 --> 00:28:59,720
lot of that

749
00:28:59,720 --> 00:29:02,520
we find two different categorization two

750
00:29:02,520 --> 00:29:04,940
main categorization for MB Expressions

751
00:29:04,940 --> 00:29:08,279
namely we have Linear B expressions

752
00:29:08,279 --> 00:29:09,659
which are

753
00:29:09,659 --> 00:29:12,240
actually a subset of polynomial lmb

754
00:29:12,240 --> 00:29:14,340
Expressions so we'll Now define a little

755
00:29:14,340 --> 00:29:16,679
bit of polynomial Expressions which will

756
00:29:16,679 --> 00:29:18,840
be probably the hardest slide in the

757
00:29:18,840 --> 00:29:21,000
whole session but we'll go over it very

758
00:29:21,000 --> 00:29:23,159
slowly and then linearity expression or

759
00:29:23,159 --> 00:29:25,200
just a particular case of the polynomial

760
00:29:25,200 --> 00:29:27,659
ones and you might be thinking why are

761
00:29:27,659 --> 00:29:30,360
you giving me these definitions I I can

762
00:29:30,360 --> 00:29:32,580
just carry around with understanding

763
00:29:32,580 --> 00:29:34,559
that we have Expressions that mix

764
00:29:34,559 --> 00:29:37,020
integer arithmetic angle operators and

765
00:29:37,020 --> 00:29:39,659
for the most part in practice you can

766
00:29:39,659 --> 00:29:41,039
carry around with that

767
00:29:41,039 --> 00:29:44,760
but this is kind of a niche talk if you

768
00:29:44,760 --> 00:29:47,220
want and there is a lot of research to

769
00:29:47,220 --> 00:29:50,279
be done and very few research that has

770
00:29:50,279 --> 00:29:52,200
been already has been already done on

771
00:29:52,200 --> 00:29:54,299
that and if you try to you like get

772
00:29:54,299 --> 00:29:55,860
interested in that and then try to go

773
00:29:55,860 --> 00:29:58,380
read anything about it you will need

774
00:29:58,380 --> 00:29:59,880
those definitions

775
00:29:59,880 --> 00:30:02,039
I hundred percent and understanding them

776
00:30:02,039 --> 00:30:04,500
from a very very very very compact paper

777
00:30:04,500 --> 00:30:06,720
is way more complex than with me going

778
00:30:06,720 --> 00:30:08,760
over it with colors and everything that

779
00:30:08,760 --> 00:30:10,260
we'll see in a sec okay

780
00:30:10,260 --> 00:30:14,880
so I you can be prepared to go on do

781
00:30:14,880 --> 00:30:16,500
your research on your own and do not

782
00:30:16,500 --> 00:30:18,179
feel to read any research paper any

783
00:30:18,179 --> 00:30:20,159
research article that might be in the

784
00:30:20,159 --> 00:30:22,980
topic because of notation let's see

785
00:30:22,980 --> 00:30:23,880
thank you

786
00:30:23,880 --> 00:30:26,779
so let's start with uh

787
00:30:26,779 --> 00:30:30,779
uh this fancy slide for defining

788
00:30:30,779 --> 00:30:33,419
polynomial MB expressions and I will use

789
00:30:33,419 --> 00:30:34,980
a

790
00:30:34,980 --> 00:30:37,200
kind of color codes mapping with this

791
00:30:37,200 --> 00:30:39,240
very simplified definition with the

792
00:30:39,240 --> 00:30:40,980
formulation with an example so we can

793
00:30:40,980 --> 00:30:42,779
you can match it visually and also it

794
00:30:42,779 --> 00:30:45,059
will I'll walk you through that anyways

795
00:30:45,059 --> 00:30:46,559
so we said that polynomial and B

796
00:30:46,559 --> 00:30:49,559
expression is just sum of terms and here

797
00:30:49,559 --> 00:30:51,059
if you know what a polynomial is in

798
00:30:51,059 --> 00:30:53,760
maths normal matter metric mats then it

799
00:30:53,760 --> 00:30:55,559
is very related so you have a sum of

800
00:30:55,559 --> 00:30:57,960
terms then each term is composed by a

801
00:30:57,960 --> 00:31:00,659
constant in this case an embed constant

802
00:31:00,659 --> 00:31:02,520
is just a constant on some a number of

803
00:31:02,520 --> 00:31:04,620
bits on some bit size

804
00:31:04,620 --> 00:31:06,840
and each of the terms is this constant

805
00:31:06,840 --> 00:31:09,419
times the product of several bitwise

806
00:31:09,419 --> 00:31:12,059
Expressions okay in in arithmetic

807
00:31:12,059 --> 00:31:14,419
polynomials this would be a sum of terms

808
00:31:14,419 --> 00:31:18,179
uh for an integral constant times uh

809
00:31:18,179 --> 00:31:20,880
some incognitive some X or x squared or

810
00:31:20,880 --> 00:31:23,580
X whatever in this case we have sum of

811
00:31:23,580 --> 00:31:25,559
terms each one composed by an embed con

812
00:31:25,559 --> 00:31:27,899
sometimes the product of several bitwise

813
00:31:27,899 --> 00:31:30,000
Expressions on any number of variables

814
00:31:30,000 --> 00:31:32,100
that we have the expression in this is

815
00:31:32,100 --> 00:31:34,140
what the formula looks like uh don't be

816
00:31:34,140 --> 00:31:36,960
scared you can map like all the colors

817
00:31:36,960 --> 00:31:39,299
to the format itself and also to this

818
00:31:39,299 --> 00:31:42,419
example which is a bit large uh not so

819
00:31:42,419 --> 00:31:43,980
much from in the sense of obfuscation

820
00:31:43,980 --> 00:31:45,720
but maybe for example is a little bit

821
00:31:45,720 --> 00:31:48,120
large but I didn't purpose to match

822
00:31:48,120 --> 00:31:50,220
everything in there so let's walk over

823
00:31:50,220 --> 00:31:53,279
it very quickly so we have polynomial in

824
00:31:53,279 --> 00:31:55,440
the expression is just sum of terms this

825
00:31:55,440 --> 00:31:56,460
is the sum

826
00:31:56,460 --> 00:31:58,860
symbol and this we have here some of

827
00:31:58,860 --> 00:32:00,360
them this is the first term

828
00:32:00,360 --> 00:32:03,120
sum the second term and assume the third

829
00:32:03,120 --> 00:32:05,640
term so we have a sum of terms in this

830
00:32:05,640 --> 00:32:06,960
case three terms

831
00:32:06,960 --> 00:32:09,360
then each term is composed by NM bit

832
00:32:09,360 --> 00:32:11,340
constant let's let's locate the same bit

833
00:32:11,340 --> 00:32:14,399
constant the formula is just the a sub I

834
00:32:14,399 --> 00:32:16,740
and this sub index is just a fancy

835
00:32:16,740 --> 00:32:19,080
notation math notation to say hey this

836
00:32:19,080 --> 00:32:21,779
is tied to a particular term of the

837
00:32:21,779 --> 00:32:24,299
expression so this would be the a sub 1

838
00:32:24,299 --> 00:32:26,580
is tied to the first term to the term

839
00:32:26,580 --> 00:32:29,220
number one of the expression so a sub 1

840
00:32:29,220 --> 00:32:31,440
the first constant here will be 43 in

841
00:32:31,440 --> 00:32:33,120
this case would be two and this case

842
00:32:33,120 --> 00:32:35,820
would be one two three okay this is the

843
00:32:35,820 --> 00:32:37,919
constant and then the rest of it is just

844
00:32:37,919 --> 00:32:40,380
a product of bitwise expression so here

845
00:32:40,380 --> 00:32:42,179
we have a product of different bitwise

846
00:32:42,179 --> 00:32:44,220
expression in this case we have three

847
00:32:44,220 --> 00:32:45,779
bit wise expression because the first

848
00:32:45,779 --> 00:32:49,200
one is X and Y or Z

849
00:32:49,200 --> 00:32:51,240
the second one is exactly the same this

850
00:32:51,240 --> 00:32:53,640
is why it is a squared and the third one

851
00:32:53,640 --> 00:32:57,299
is X x or y and z or t

852
00:32:57,299 --> 00:32:59,940
these are a product of several bitwise

853
00:32:59,940 --> 00:33:01,679
Expressions how many bitwise expressions

854
00:33:01,679 --> 00:33:03,539
in this case we have three have this

855
00:33:03,539 --> 00:33:06,059
first one the same repeat it this goes

856
00:33:06,059 --> 00:33:08,820
over the square and then this other one

857
00:33:08,820 --> 00:33:10,500
and then on a number two variables which

858
00:33:10,500 --> 00:33:12,000
mean okay how many variables are we

859
00:33:12,000 --> 00:33:13,679
using to generate these Expressions how

860
00:33:13,679 --> 00:33:15,779
many inputs we will have in this MBA

861
00:33:15,779 --> 00:33:17,039
expression

862
00:33:17,039 --> 00:33:18,720
and the second case it's very very

863
00:33:18,720 --> 00:33:21,240
simple because uh our

864
00:33:21,240 --> 00:33:23,580
we have a several bitwise expression in

865
00:33:23,580 --> 00:33:25,140
this case several means just only one

866
00:33:25,140 --> 00:33:26,640
bit wise expression and the bitwise

867
00:33:26,640 --> 00:33:28,500
expression that we have is just X which

868
00:33:28,500 --> 00:33:29,820
is the constant which is the variable

869
00:33:29,820 --> 00:33:31,860
itself okay

870
00:33:31,860 --> 00:33:33,779
how all the color mappings in here also

871
00:33:33,779 --> 00:33:35,760
for mapping the definition the formula

872
00:33:35,760 --> 00:33:37,380
and the example in the third case we

873
00:33:37,380 --> 00:33:38,100
have

874
00:33:38,100 --> 00:33:41,159
uh the this is the uh

875
00:33:41,159 --> 00:33:42,899
everything at the right of the one two

876
00:33:42,899 --> 00:33:44,399
three is the probability of bitwise

877
00:33:44,399 --> 00:33:46,260
expressions in this case we have four

878
00:33:46,260 --> 00:33:48,000
bitwise expression the third one the

879
00:33:48,000 --> 00:33:50,519
first one is X or Y the second one is z

880
00:33:50,519 --> 00:33:52,860
and the third is T and the fourth is T

881
00:33:52,860 --> 00:33:55,200
as well so we have t squared

882
00:33:55,200 --> 00:33:57,240
okay

883
00:33:57,240 --> 00:34:00,480
so this is essentially uh the definition

884
00:34:00,480 --> 00:34:02,399
of a polynomial and B expression is okay

885
00:34:02,399 --> 00:34:05,700
we have a polynomial uh but in instead

886
00:34:05,700 --> 00:34:11,339
of having like single variables uh

887
00:34:11,339 --> 00:34:12,960
be multiplied by a constant another

888
00:34:12,960 --> 00:34:15,119
together which is a normal polynomial if

889
00:34:15,119 --> 00:34:16,739
you want to say that way in this case

890
00:34:16,739 --> 00:34:19,500
our variables are actually bitwise

891
00:34:19,500 --> 00:34:20,760
Expressions that can end up being

892
00:34:20,760 --> 00:34:22,260
multiplied by themselves so this is

893
00:34:22,260 --> 00:34:24,359
let's go again these are sum of terms

894
00:34:24,359 --> 00:34:26,520
this is the sum we have here the sum of

895
00:34:26,520 --> 00:34:28,379
terms three terms being summed together

896
00:34:28,379 --> 00:34:30,300
each one is composed by an N bit

897
00:34:30,300 --> 00:34:32,820
constant so this is the constant tied to

898
00:34:32,820 --> 00:34:34,560
each one of the terms

899
00:34:34,560 --> 00:34:36,839
and each of the terms is the constant

900
00:34:36,839 --> 00:34:38,699
times a product of several bitwise

901
00:34:38,699 --> 00:34:40,020
Expressions so we have a product of

902
00:34:40,020 --> 00:34:42,179
several bitwise expression one bit with

903
00:34:42,179 --> 00:34:43,800
expression the second one the third one

904
00:34:43,800 --> 00:34:46,918
and so on and so forth okay

905
00:34:46,918 --> 00:34:49,859
uh if you have been a bit lost in here

906
00:34:49,859 --> 00:34:52,619
you didn't get it a hundred percent

907
00:34:52,619 --> 00:34:54,359
don't worry you have already the slides

908
00:34:54,359 --> 00:34:55,918
you can check it out and for the

909
00:34:55,918 --> 00:34:57,060
practice part you don't really need to

910
00:34:57,060 --> 00:34:59,280
remember this definition at all okay you

911
00:34:59,280 --> 00:35:00,960
can just remember it's a mixing of

912
00:35:00,960 --> 00:35:03,839
operators but I really wanted to do this

913
00:35:03,839 --> 00:35:05,760
so you can go out and read anything

914
00:35:05,760 --> 00:35:08,339
about mbas and understand and be able to

915
00:35:08,339 --> 00:35:10,380
face whatever comes next on whatever

916
00:35:10,380 --> 00:35:12,480
formulation formalization we have from

917
00:35:12,480 --> 00:35:14,400
from that

918
00:35:14,400 --> 00:35:17,160
now when we have seen that then defining

919
00:35:17,160 --> 00:35:19,320
a linearity expression is very easy it's

920
00:35:19,320 --> 00:35:21,720
very easy and it's way more simple

921
00:35:21,720 --> 00:35:23,760
but I I want to Define first the

922
00:35:23,760 --> 00:35:26,579
polynomial because then the linear MBA

923
00:35:26,579 --> 00:35:28,619
is just a particular case it's just the

924
00:35:28,619 --> 00:35:30,359
case in which we only have one bit wise

925
00:35:30,359 --> 00:35:32,520
expression okay so we could represent it

926
00:35:32,520 --> 00:35:35,339
in that way which is if you compare that

927
00:35:35,339 --> 00:35:36,960
to the previous one the only thing that

928
00:35:36,960 --> 00:35:39,540
we are ditching is this product of the

929
00:35:39,540 --> 00:35:43,140
device expression why because uh we are

930
00:35:43,140 --> 00:35:45,420
defined linear expressions in a way of

931
00:35:45,420 --> 00:35:48,000
restricting our Expressions to one to

932
00:35:48,000 --> 00:35:50,520
those that only have a single bitwise

933
00:35:50,520 --> 00:35:52,560
expression okay

934
00:35:52,560 --> 00:35:54,420
so we impose that restriction and call

935
00:35:54,420 --> 00:35:56,280
it linear mbas

936
00:35:56,280 --> 00:35:59,220
and practice here side note

937
00:35:59,220 --> 00:36:01,079
anywhere that you go around and read

938
00:36:01,079 --> 00:36:03,359
about something it's linear you can in

939
00:36:03,359 --> 00:36:06,240
practice think of it vaguely as a

940
00:36:06,240 --> 00:36:08,460
restriction that you're imposing that

941
00:36:08,460 --> 00:36:10,859
will not allow variables to be end up

942
00:36:10,859 --> 00:36:13,680
being multiplied together okay this is a

943
00:36:13,680 --> 00:36:15,599
very vague definition and if there is

944
00:36:15,599 --> 00:36:17,640
some mathematician in the room might

945
00:36:17,640 --> 00:36:18,900
jump

946
00:36:18,900 --> 00:36:21,660
and to me but for practice

947
00:36:21,660 --> 00:36:24,180
and practice you can vaguely think of

948
00:36:24,180 --> 00:36:26,700
linearity or whatever it might apply any

949
00:36:26,700 --> 00:36:29,280
kind of Expressions any kind of

950
00:36:29,280 --> 00:36:31,140
thing that you're reading about and

951
00:36:31,140 --> 00:36:32,700
mentions hey this is a linear

952
00:36:32,700 --> 00:36:35,280
transformation this is some preserved

953
00:36:35,280 --> 00:36:37,740
linearity it means that we don't allow

954
00:36:37,740 --> 00:36:39,540
variables to end up being multiplied

955
00:36:39,540 --> 00:36:40,980
together and then this makes a lot of

956
00:36:40,980 --> 00:36:42,660
sense if you want to think it a little

957
00:36:42,660 --> 00:36:44,820
bit geometrically because as long as you

958
00:36:44,820 --> 00:36:47,160
don't you only have one variable you

959
00:36:47,160 --> 00:36:49,320
what you have defined are lines

960
00:36:49,320 --> 00:36:51,960
and at the moment that you just allow

961
00:36:51,960 --> 00:36:53,520
for variables to be multiplied together

962
00:36:53,520 --> 00:36:55,380
then you start to have chords and other

963
00:36:55,380 --> 00:36:58,980
kind of surfaces on a on any dimensional

964
00:36:58,980 --> 00:37:00,180
space okay

965
00:37:00,180 --> 00:37:02,940
so just say note linearity is

966
00:37:02,940 --> 00:37:05,339
essentially we don't allow variables

967
00:37:05,339 --> 00:37:07,020
being end up being multiplied to where

968
00:37:07,020 --> 00:37:09,420
in here by the means of just allowing a

969
00:37:09,420 --> 00:37:11,099
single bitwise expression we don't allow

970
00:37:11,099 --> 00:37:13,079
the possibility that different device

971
00:37:13,079 --> 00:37:14,900
expressions and

972
00:37:14,900 --> 00:37:17,760
finally variables end up being

973
00:37:17,760 --> 00:37:21,079
multiplied together okay

974
00:37:21,660 --> 00:37:23,700
this is an example which is the very

975
00:37:23,700 --> 00:37:24,900
same example that we saw at the

976
00:37:24,900 --> 00:37:27,540
beginning is actually a linear in the

977
00:37:27,540 --> 00:37:29,220
expression why because we just have a

978
00:37:29,220 --> 00:37:31,740
sum of two terms in this case

979
00:37:31,740 --> 00:37:33,660
the first term is composed by a constant

980
00:37:33,660 --> 00:37:36,660
which is one it's uh implicit in here

981
00:37:36,660 --> 00:37:39,300
times a single bitwise expression in

982
00:37:39,300 --> 00:37:41,099
this case the video's expression is X x

983
00:37:41,099 --> 00:37:42,000
or y

984
00:37:42,000 --> 00:37:44,880
the second term the constant is two and

985
00:37:44,880 --> 00:37:46,560
the single video is expression that we

986
00:37:46,560 --> 00:37:50,160
allow is X and Y okay

987
00:37:50,160 --> 00:37:54,020
so this is an example of a linear MBA

988
00:37:58,619 --> 00:38:01,380
you might be also wondering

989
00:38:01,380 --> 00:38:03,420
why do we even need those kinds of

990
00:38:03,420 --> 00:38:05,220
definitions

991
00:38:05,220 --> 00:38:07,560
and the answer is because we don't know

992
00:38:07,560 --> 00:38:11,160
anything about mbas and by trying to put

993
00:38:11,160 --> 00:38:12,839
names to different ways of expressing

994
00:38:12,839 --> 00:38:15,000
things in a kind of General way then we

995
00:38:15,000 --> 00:38:16,500
can start working with these

996
00:38:16,500 --> 00:38:17,640
mathematical structures these

997
00:38:17,640 --> 00:38:19,859
mathematical constructs in a kind of

998
00:38:19,859 --> 00:38:21,359
formal way and deriving Knowledge from

999
00:38:21,359 --> 00:38:23,400
it okay and then there are some fancy

1000
00:38:23,400 --> 00:38:25,980
things as any kind of MBA can be

1001
00:38:25,980 --> 00:38:27,839
expressed as a combination of polynomial

1002
00:38:27,839 --> 00:38:30,540
mbas and other things so we understand

1003
00:38:30,540 --> 00:38:33,900
polynomial mbas which we don't yet uh

1004
00:38:33,900 --> 00:38:35,280
folio at least

1005
00:38:35,280 --> 00:38:38,280
decently enough from my perspective

1006
00:38:38,280 --> 00:38:40,320
then we kind of understand everything

1007
00:38:40,320 --> 00:38:43,800
that we can construct with mbas

1008
00:38:43,800 --> 00:38:45,599
Okay so

1009
00:38:45,599 --> 00:38:49,140
let's move a bit onto

1010
00:38:49,140 --> 00:38:50,760
motivation and a little bit of

1011
00:38:50,760 --> 00:38:53,400
obfuscation what how does it play a role

1012
00:38:53,400 --> 00:38:55,260
in here obfuscation how do we plug the

1013
00:38:55,260 --> 00:38:56,579
obfuscation thing that we have been

1014
00:38:56,579 --> 00:38:57,720
talking

1015
00:38:57,720 --> 00:39:00,000
leveraging this kind of MBA Expressions

1016
00:39:00,000 --> 00:39:02,220
maybe Transformations actually

1017
00:39:02,220 --> 00:39:04,260
so notice for example that the example

1018
00:39:04,260 --> 00:39:06,660
this example that we have been seeing a

1019
00:39:06,660 --> 00:39:09,000
couple times already this is an enemy

1020
00:39:09,000 --> 00:39:12,180
expression which actually simplifies to

1021
00:39:12,180 --> 00:39:14,040
this other expression

1022
00:39:14,040 --> 00:39:16,380
which means this expression and this

1023
00:39:16,380 --> 00:39:17,880
other expression which is just the

1024
00:39:17,880 --> 00:39:19,320
addition of two variables are

1025
00:39:19,320 --> 00:39:21,480
semantically equivalent in other words

1026
00:39:21,480 --> 00:39:24,780
if we plug any X and Y inputs to this

1027
00:39:24,780 --> 00:39:27,420
expression it will always give us a as

1028
00:39:27,420 --> 00:39:30,540
an output X Plus y on a semantic point

1029
00:39:30,540 --> 00:39:31,820
of view from an input output

1030
00:39:31,820 --> 00:39:34,200
relationship this expression produces

1031
00:39:34,200 --> 00:39:36,359
the same behavior the desired expression

1032
00:39:36,359 --> 00:39:37,680
which is just an addition of two

1033
00:39:37,680 --> 00:39:38,760
variables

1034
00:39:38,760 --> 00:39:40,140
so

1035
00:39:40,140 --> 00:39:44,339
uh we say that the expression is a more

1036
00:39:44,339 --> 00:39:47,040
complex expression than the esamp from a

1037
00:39:47,040 --> 00:39:48,420
syntactic point of view from the point

1038
00:39:48,420 --> 00:39:50,640
of view of writing them but they are

1039
00:39:50,640 --> 00:39:52,079
semantically equivalent from the

1040
00:39:52,079 --> 00:39:53,339
semantic point of view from the point of

1041
00:39:53,339 --> 00:39:55,320
view of each behavior is input out of

1042
00:39:55,320 --> 00:39:58,560
the relationship they are equivalent

1043
00:39:58,560 --> 00:40:01,859
we can actually uh verify very easily

1044
00:40:01,859 --> 00:40:03,540
that they are equivalent we can plug an

1045
00:40:03,540 --> 00:40:05,760
smt solver we won't talk a lot about smt

1046
00:40:05,760 --> 00:40:08,040
solvers but we just will use them to

1047
00:40:08,040 --> 00:40:10,260
prove semantic equivalence in case you

1048
00:40:10,260 --> 00:40:12,060
don't really know what an smt solver is

1049
00:40:12,060 --> 00:40:14,940
you can treat this as a magic black box

1050
00:40:14,940 --> 00:40:17,640
that can answer hard questions for us

1051
00:40:17,640 --> 00:40:20,160
and in this case we can

1052
00:40:20,160 --> 00:40:22,920
solve constraints so we can ask them to

1053
00:40:22,920 --> 00:40:23,880
solve hey

1054
00:40:23,880 --> 00:40:25,980
here you have these constraints is this

1055
00:40:25,980 --> 00:40:28,440
possible to happen and if it's possible

1056
00:40:28,440 --> 00:40:30,300
can you give me an example where this is

1057
00:40:30,300 --> 00:40:32,339
the case and leveraging data center

1058
00:40:32,339 --> 00:40:35,220
Source are able to produce proofs of

1059
00:40:35,220 --> 00:40:37,140
semantic key ones we can directly ask in

1060
00:40:37,140 --> 00:40:39,060
a sentence over hey can you prove that

1061
00:40:39,060 --> 00:40:40,740
these two expressions are semantically

1062
00:40:40,740 --> 00:40:43,619
equivalent that is that they are exactly

1063
00:40:43,619 --> 00:40:47,099
producing the same behavior all the time

1064
00:40:47,099 --> 00:40:49,500
so these are some super simple python

1065
00:40:49,500 --> 00:40:51,599
code you have checked out the repository

1066
00:40:51,599 --> 00:40:53,820
I will also Link at the end of The Talk

1067
00:40:53,820 --> 00:40:55,440
uh but you have all those demos all the

1068
00:40:55,440 --> 00:40:56,520
code that appears in here you have all

1069
00:40:56,520 --> 00:40:58,560
those Demos in there okay

1070
00:40:58,560 --> 00:41:00,780
uh within the same name appearing here

1071
00:41:00,780 --> 00:41:03,599
so we just uh import everything from Z3

1072
00:41:03,599 --> 00:41:05,400
which is our the smt solver that we will

1073
00:41:05,400 --> 00:41:07,740
be using and we just say okay let's

1074
00:41:07,740 --> 00:41:10,800
define X and Y as with vectors of eight

1075
00:41:10,800 --> 00:41:13,619
bits eight bit variables okay within the

1076
00:41:13,619 --> 00:41:16,200
context of Z3 objects let's define eight

1077
00:41:16,200 --> 00:41:19,440
bit vectors 8-bit variable sorry

1078
00:41:19,440 --> 00:41:21,180
and then justifying these two

1079
00:41:21,180 --> 00:41:22,980
expressions that we saw

1080
00:41:22,980 --> 00:41:25,680
the first one the second one and we have

1081
00:41:25,680 --> 00:41:28,260
this essential hey prove me the semantic

1082
00:41:28,260 --> 00:41:29,280
key elements between these two

1083
00:41:29,280 --> 00:41:31,619
expressions okay we just run it and it's

1084
00:41:31,619 --> 00:41:35,540
very very quick uh to prove that

1085
00:41:35,820 --> 00:41:39,480
okay so let's talk a bit Ah now we have

1086
00:41:39,480 --> 00:41:41,640
this motivation uh like how do we

1087
00:41:41,640 --> 00:41:43,440
leverage MBA transformations to

1088
00:41:43,440 --> 00:41:45,359
obfuscate to actually produce

1089
00:41:45,359 --> 00:41:48,119
obfuscation transformations

1090
00:41:48,119 --> 00:41:49,800
so the previous example that we have

1091
00:41:49,800 --> 00:41:51,839
just seen uh like these two different

1092
00:41:51,839 --> 00:41:53,520
representations for this for the same

1093
00:41:53,520 --> 00:41:55,619
semantic behavior for the same addition

1094
00:41:55,619 --> 00:41:58,740
semantics if you want it this suggests

1095
00:41:58,740 --> 00:42:01,800
uh basic obfuscation idea uh which might

1096
00:42:01,800 --> 00:42:03,180
seem really done but works really well

1097
00:42:03,180 --> 00:42:05,280
it is okay let's just

1098
00:42:05,280 --> 00:42:07,560
any place in our code that we want to

1099
00:42:07,560 --> 00:42:09,540
obfuscate that an addition is present

1100
00:42:09,540 --> 00:42:13,500
let's just replace that addition uh by

1101
00:42:13,500 --> 00:42:16,980
this other expression involving xor and

1102
00:42:16,980 --> 00:42:18,960
and Boon operators

1103
00:42:18,960 --> 00:42:22,079
so this way we could have the same code

1104
00:42:22,079 --> 00:42:23,640
from a semantic point of view but we

1105
00:42:23,640 --> 00:42:25,500
will change its syntactics it will

1106
00:42:25,500 --> 00:42:26,880
change the form of writing and at the

1107
00:42:26,880 --> 00:42:29,520
end the complexity of the instructions

1108
00:42:29,520 --> 00:42:32,040
that will be will result from this code

1109
00:42:32,040 --> 00:42:34,520
okay

1110
00:42:35,099 --> 00:42:38,700
so to put it in nice words

1111
00:42:38,700 --> 00:42:41,220
the idea for obfuscating with MBA

1112
00:42:41,220 --> 00:42:42,720
transformation is given an initial

1113
00:42:42,720 --> 00:42:45,359
expression initial MB expression very

1114
00:42:45,359 --> 00:42:46,920
simple that describes the semantics that

1115
00:42:46,920 --> 00:42:48,720
we want obfuscate we want to hide let's

1116
00:42:48,720 --> 00:42:51,119
call it E1 what we're interested in

1117
00:42:51,119 --> 00:42:53,880
doing is generating a second expression

1118
00:42:53,880 --> 00:42:55,500
E2

1119
00:42:55,500 --> 00:42:57,720
which is uh semantically equivalent

1120
00:42:57,720 --> 00:42:59,160
which is equivalent from the point of

1121
00:42:59,160 --> 00:43:00,540
view of Its Behavior from the point of

1122
00:43:00,540 --> 00:43:02,700
view of its input of the relationship is

1123
00:43:02,700 --> 00:43:06,240
semantically equivalent but this E2 has

1124
00:43:06,240 --> 00:43:08,160
to be syntactically more complex so more

1125
00:43:08,160 --> 00:43:10,140
complex from the point of view of each

1126
00:43:10,140 --> 00:43:11,640
writing form its syntactic

1127
00:43:11,640 --> 00:43:14,280
representation okay

1128
00:43:14,280 --> 00:43:16,740
this process to construct this kind of

1129
00:43:16,740 --> 00:43:19,079
transformation usually relying to

1130
00:43:19,079 --> 00:43:20,099
differentiated companies to

1131
00:43:20,099 --> 00:43:22,920
differentiated techniques that we have

1132
00:43:22,920 --> 00:43:24,720
and we can use them either alone or

1133
00:43:24,720 --> 00:43:27,480
combined without any problem those are

1134
00:43:27,480 --> 00:43:30,480
called uh well MBA writing and also in

1135
00:43:30,480 --> 00:43:32,940
session of identities and we'll talk a

1136
00:43:32,940 --> 00:43:34,980
little bit about both of them very very

1137
00:43:34,980 --> 00:43:39,000
simple ideas but very powerful as well

1138
00:43:39,000 --> 00:43:41,280
so with MBA rewriting the whole idea is

1139
00:43:41,280 --> 00:43:43,020
that we choose an operator or even a sub

1140
00:43:43,020 --> 00:43:45,180
expression if you want and then we just

1141
00:43:45,180 --> 00:43:47,760
rewrite it in an equivalent MBA

1142
00:43:47,760 --> 00:43:50,339
expression okay from the example that we

1143
00:43:50,339 --> 00:43:52,319
saw before this is the idea we have

1144
00:43:52,319 --> 00:43:54,180
discussed so we when we see some

1145
00:43:54,180 --> 00:43:56,460
addition in the code that we are trying

1146
00:43:56,460 --> 00:43:57,720
to obfuscate the expression that we're

1147
00:43:57,720 --> 00:44:00,240
trying to escape we will replace that by

1148
00:44:00,240 --> 00:44:04,140
this other uh expression which is as you

1149
00:44:04,140 --> 00:44:05,760
have been saying semantically equivalent

1150
00:44:05,760 --> 00:44:07,260
but more complex from the syntactic

1151
00:44:07,260 --> 00:44:08,880
point of view

1152
00:44:08,880 --> 00:44:12,000
uh what is really cool in here

1153
00:44:12,000 --> 00:44:15,180
um a lot of people don't really

1154
00:44:15,180 --> 00:44:18,720
get to play with that is that uh kind of

1155
00:44:18,720 --> 00:44:21,300
sign out uh

1156
00:44:21,300 --> 00:44:24,119
polynomial mbas and in particular linear

1157
00:44:24,119 --> 00:44:25,859
mbas which are polynomial mbas have a

1158
00:44:25,859 --> 00:44:26,940
really nice property which is

1159
00:44:26,940 --> 00:44:29,099
composition which essentially means that

1160
00:44:29,099 --> 00:44:31,800
you can plug in here

1161
00:44:31,800 --> 00:44:35,160
in X and Y can be also some Expressions

1162
00:44:35,160 --> 00:44:38,579
they don't need to be single variables

1163
00:44:38,579 --> 00:44:40,260
which means that you can apply these

1164
00:44:40,260 --> 00:44:42,540
right rules iteratively and grow the

1165
00:44:42,540 --> 00:44:44,220
expression really really fast because

1166
00:44:44,220 --> 00:44:46,319
now this very same rewrite rule we can

1167
00:44:46,319 --> 00:44:49,319
apply it to this resulting expression we

1168
00:44:49,319 --> 00:44:53,880
just use this X or Y as our X and these

1169
00:44:53,880 --> 00:44:57,359
two times X and Y as our Y and we can

1170
00:44:57,359 --> 00:44:59,220
apply the assembly right rule

1171
00:44:59,220 --> 00:45:02,099
but now with that part being X that part

1172
00:45:02,099 --> 00:45:05,339
being Y and we just expand the resulting

1173
00:45:05,339 --> 00:45:07,619
expression okay

1174
00:45:07,619 --> 00:45:09,660
these are fancy property of polynomial

1175
00:45:09,660 --> 00:45:12,240
mbas that is composition actually that

1176
00:45:12,240 --> 00:45:15,599
we can apply any transformation not only

1177
00:45:15,599 --> 00:45:17,460
to single variables but to solve

1178
00:45:17,460 --> 00:45:19,440
Expressions themselves and it will work

1179
00:45:19,440 --> 00:45:23,000
exactly in the same way

1180
00:45:23,700 --> 00:45:26,040
uh let's talk about insertion of

1181
00:45:26,040 --> 00:45:27,180
identities

1182
00:45:27,180 --> 00:45:29,760
which is another way of producing such

1183
00:45:29,760 --> 00:45:31,079
obfuscated

1184
00:45:31,079 --> 00:45:33,060
or more complex expression for my

1185
00:45:33,060 --> 00:45:37,380
initial one and the idea is having an

1186
00:45:37,380 --> 00:45:38,819
expression or a sub-expression that we

1187
00:45:38,819 --> 00:45:39,960
want to obfuscate that we want to

1188
00:45:39,960 --> 00:45:41,880
transform into something more complex

1189
00:45:41,880 --> 00:45:44,819
and then we need a couple of inverse

1190
00:45:44,819 --> 00:45:47,099
functions on the bit cycle we are

1191
00:45:47,099 --> 00:45:48,599
dealing with okay

1192
00:45:48,599 --> 00:45:51,720
these functions are usually are fine

1193
00:45:51,720 --> 00:45:53,640
functions

1194
00:45:53,640 --> 00:45:56,880
um and a fine function is again vague

1195
00:45:56,880 --> 00:45:59,160
node but it's some function in this form

1196
00:45:59,160 --> 00:46:01,140
is just a linear function because we

1197
00:46:01,140 --> 00:46:03,240
don't have variables end up being

1198
00:46:03,240 --> 00:46:05,040
multiplied together which has this form

1199
00:46:05,040 --> 00:46:07,020
is just a constant times whatever the

1200
00:46:07,020 --> 00:46:08,400
input the input might be a variable

1201
00:46:08,400 --> 00:46:10,859
might be an expression whatever Plus

1202
00:46:10,859 --> 00:46:13,140
another constant so you want to think of

1203
00:46:13,140 --> 00:46:15,180
that geometrically if you want the only

1204
00:46:15,180 --> 00:46:17,060
thing we are doing is

1205
00:46:17,060 --> 00:46:20,160
shrinking or expanding our variable and

1206
00:46:20,160 --> 00:46:22,079
then moving it around it's just this

1207
00:46:22,079 --> 00:46:23,700
multiplication by a constant and then

1208
00:46:23,700 --> 00:46:25,079
moving it around

1209
00:46:25,079 --> 00:46:28,319
those are called affine functions here I

1210
00:46:28,319 --> 00:46:31,460
also like to mention that

1211
00:46:31,460 --> 00:46:34,140
I put this as a fine function and I say

1212
00:46:34,140 --> 00:46:35,220
that there's often a fine functions

1213
00:46:35,220 --> 00:46:36,839
because if you go to research literature

1214
00:46:36,839 --> 00:46:39,420
you will find like almost exclusively a

1215
00:46:39,420 --> 00:46:41,220
fine functions used there

1216
00:46:41,220 --> 00:46:42,660
is no reason

1217
00:46:42,660 --> 00:46:44,700
there is no hard reason why they have to

1218
00:46:44,700 --> 00:46:47,099
be a fine functions any inverse mapping

1219
00:46:47,099 --> 00:46:48,780
any pair of inverse function will work

1220
00:46:48,780 --> 00:46:52,140
it's just well people doesn't really

1221
00:46:52,140 --> 00:46:54,240
read well the research or don't

1222
00:46:54,240 --> 00:46:55,740
understand it well they just go to the

1223
00:46:55,740 --> 00:46:57,540
first paper they used to find functions

1224
00:46:57,540 --> 00:46:59,160
then everyone else is using affine

1225
00:46:59,160 --> 00:47:03,060
functions but there is no uh

1226
00:47:03,060 --> 00:47:05,220
hard reason why they need to be assigned

1227
00:47:05,220 --> 00:47:06,839
functions and inverse mapping any

1228
00:47:06,839 --> 00:47:09,180
inverse verifying of a kind of functions

1229
00:47:09,180 --> 00:47:11,280
either a fine or whatever kind of

1230
00:47:11,280 --> 00:47:13,800
invertible mappings on and bits will

1231
00:47:13,800 --> 00:47:16,440
work exactly in the same way okay

1232
00:47:16,440 --> 00:47:18,599
so the idea is we got our expression to

1233
00:47:18,599 --> 00:47:21,180
one of skate and then we have a pair of

1234
00:47:21,180 --> 00:47:24,060
invertible functions and we apply the

1235
00:47:24,060 --> 00:47:26,640
first function to this expression and

1236
00:47:26,640 --> 00:47:28,500
then the other function to the

1237
00:47:28,500 --> 00:47:30,300
expression you might be thinking well

1238
00:47:30,300 --> 00:47:31,800
but if we I apply two different

1239
00:47:31,800 --> 00:47:34,619
functions which are inverse to an input

1240
00:47:34,619 --> 00:47:37,260
then I get exactly the same and that is

1241
00:47:37,260 --> 00:47:38,819
the whole point from a semantic point of

1242
00:47:38,819 --> 00:47:41,640
view but if you are doing that expanding

1243
00:47:41,640 --> 00:47:43,500
the symbolic expression that you obtain

1244
00:47:43,500 --> 00:47:45,780
then you're making it bigger and bigger

1245
00:47:45,780 --> 00:47:47,280
you're growing it we're going to see an

1246
00:47:47,280 --> 00:47:49,560
example uh right in Nexus live so you

1247
00:47:49,560 --> 00:47:51,960
understand what I mean by replacing

1248
00:47:51,960 --> 00:47:53,819
symbolically and then expanding like

1249
00:47:53,819 --> 00:47:57,540
writing actually the content from that

1250
00:47:57,540 --> 00:48:00,420
let's see an example so it will clarify

1251
00:48:00,420 --> 00:48:01,440
a lot of things from these two

1252
00:48:01,440 --> 00:48:02,819
techniques

1253
00:48:02,819 --> 00:48:05,099
uh let's just again

1254
00:48:05,099 --> 00:48:06,660
start with our very very simple

1255
00:48:06,660 --> 00:48:08,880
expression X Plus y

1256
00:48:08,880 --> 00:48:12,000
and consider the following functions

1257
00:48:12,000 --> 00:48:14,760
which are fine functions in this case on

1258
00:48:14,760 --> 00:48:16,680
eight bits so these functions are

1259
00:48:16,680 --> 00:48:17,960
inverse

1260
00:48:17,960 --> 00:48:20,339
which is a function the first one just

1261
00:48:20,339 --> 00:48:22,920
Maps X to 39x plus 23 and the inverse

1262
00:48:22,920 --> 00:48:26,819
function maps 151x to r11.

1263
00:48:26,819 --> 00:48:29,880
functions are inverse functions actually

1264
00:48:29,880 --> 00:48:32,099
I find in a fine inverse mappings on

1265
00:48:32,099 --> 00:48:34,560
eight bits so we have our expression

1266
00:48:34,560 --> 00:48:36,660
that we want to skate the two functions

1267
00:48:36,660 --> 00:48:38,040
the first thing that we're going to do

1268
00:48:38,040 --> 00:48:41,280
is well let's consider e sub 2 which is

1269
00:48:41,280 --> 00:48:43,079
obtained by applying the previously

1270
00:48:43,079 --> 00:48:44,700
write rule so this is like the first

1271
00:48:44,700 --> 00:48:47,040
obfuscation step using a rewrite rule

1272
00:48:47,040 --> 00:48:49,640
using the rewrite rule that we saw where

1273
00:48:49,640 --> 00:48:53,220
uh this uh addition

1274
00:48:53,220 --> 00:48:55,500
can be expressed also semantically as

1275
00:48:55,500 --> 00:48:57,180
that we have this right rule this is

1276
00:48:57,180 --> 00:48:59,520
exactly the revital that we saw in here

1277
00:48:59,520 --> 00:49:01,380
okay so first of all we apply the

1278
00:49:01,380 --> 00:49:03,720
rewrite rule

1279
00:49:03,720 --> 00:49:06,780
and we obtain a sub 2. and then to this

1280
00:49:06,780 --> 00:49:08,520
expression we will apply the insertion

1281
00:49:08,520 --> 00:49:11,220
of identities let's do it into steps

1282
00:49:11,220 --> 00:49:13,740
first we apply the first function and

1283
00:49:13,740 --> 00:49:15,180
the only thing that we do is just apply

1284
00:49:15,180 --> 00:49:16,740
the definition of the function we

1285
00:49:16,740 --> 00:49:19,920
applied the function to e sub 2 which is

1286
00:49:19,920 --> 00:49:22,980
39 times e sub 2 plus 23. we call it

1287
00:49:22,980 --> 00:49:26,700
item temporally okay now we apply the

1288
00:49:26,700 --> 00:49:28,980
inverse of the function we need to apply

1289
00:49:28,980 --> 00:49:31,740
the inverse to the original function to

1290
00:49:31,740 --> 00:49:33,180
the expression so we just apply it to

1291
00:49:33,180 --> 00:49:35,460
the e-temp which is exactly that and

1292
00:49:35,460 --> 00:49:37,920
what do we get well just apply the

1293
00:49:37,920 --> 00:49:40,800
definition of the inverse function 151

1294
00:49:40,800 --> 00:49:41,940
times

1295
00:49:41,940 --> 00:49:46,859
etem plus 111 and now we expand this we

1296
00:49:46,859 --> 00:49:49,140
expanding I mean okay but let's just

1297
00:49:49,140 --> 00:49:52,079
replace attempt but whatever is in here

1298
00:49:52,079 --> 00:49:54,720
and then now let's just replace e sub 2

1299
00:49:54,720 --> 00:49:58,140
but whatever is in here so we obtain the

1300
00:49:58,140 --> 00:49:59,940
refinal expression

1301
00:49:59,940 --> 00:50:03,480
and if we do that we get E3 and we

1302
00:50:03,480 --> 00:50:06,480
observe that essentially we have 151

1303
00:50:06,480 --> 00:50:09,660
times E10 plus 111 so this is the 151

1304
00:50:09,660 --> 00:50:11,940
this is the 111 this is everything else

1305
00:50:11,940 --> 00:50:14,579
the E temp and delete them check that

1306
00:50:14,579 --> 00:50:17,339
this is 39 times

1307
00:50:17,339 --> 00:50:21,060
is up to plus 23 39 times e sub 2 plus

1308
00:50:21,060 --> 00:50:24,000
23. so when we are expanding it we are

1309
00:50:24,000 --> 00:50:25,500
applying to function which are inverses

1310
00:50:25,500 --> 00:50:28,260
but as we are not evaluating a concrete

1311
00:50:28,260 --> 00:50:30,180
expression but we are constructing the

1312
00:50:30,180 --> 00:50:31,619
symbolic expression from it we are

1313
00:50:31,619 --> 00:50:34,079
expanding it we have our we arrive to A

1314
00:50:34,079 --> 00:50:36,000
more complex expression okay

1315
00:50:36,000 --> 00:50:37,380
now

1316
00:50:37,380 --> 00:50:39,900
for now you have had to trust me that

1317
00:50:39,900 --> 00:50:41,940
these things work and are correct but we

1318
00:50:41,940 --> 00:50:44,220
can actually prove that uh so very

1319
00:50:44,220 --> 00:50:46,319
effectively demo in here let's just

1320
00:50:46,319 --> 00:50:47,640
consider the three Expressions that we

1321
00:50:47,640 --> 00:50:49,380
have seen this is the first original

1322
00:50:49,380 --> 00:50:51,420
none of the scripted expression this is

1323
00:50:51,420 --> 00:50:52,920
the expression of 10 through the

1324
00:50:52,920 --> 00:50:54,780
insertion of identity sorry through the

1325
00:50:54,780 --> 00:50:56,520
application of the right rule that we

1326
00:50:56,520 --> 00:50:59,099
saw and then this is the expression that

1327
00:50:59,099 --> 00:51:01,740
we obtain by applying the identity

1328
00:51:01,740 --> 00:51:05,160
function identities to the this second

1329
00:51:05,160 --> 00:51:06,420
expression okay this is the two

1330
00:51:06,420 --> 00:51:08,700
expressions that we saw in the process

1331
00:51:08,700 --> 00:51:11,579
who will do first is well compare the

1332
00:51:11,579 --> 00:51:13,500
syntactic complexity of them you don't

1333
00:51:13,500 --> 00:51:15,300
really have to do a lot of work you can

1334
00:51:15,300 --> 00:51:16,920
already see that within the way of

1335
00:51:16,920 --> 00:51:20,220
writing them as Expressions but let's

1336
00:51:20,220 --> 00:51:22,559
take a look at that how we translate to

1337
00:51:22,559 --> 00:51:24,540
assembly for example

1338
00:51:24,540 --> 00:51:26,040
then we'll observe this semantic

1339
00:51:26,040 --> 00:51:27,720
equivalence of the two expressions and

1340
00:51:27,720 --> 00:51:29,099
by observing let's say okay let's just

1341
00:51:29,099 --> 00:51:30,540
Implement those functions and see that

1342
00:51:30,540 --> 00:51:32,400
they produce the same input output

1343
00:51:32,400 --> 00:51:34,440
behavior and finally in this case we

1344
00:51:34,440 --> 00:51:36,660
will prove we not only observe that we

1345
00:51:36,660 --> 00:51:37,859
will prove that they are semantically

1346
00:51:37,859 --> 00:51:39,720
equivalent with the help of an smt

1347
00:51:39,720 --> 00:51:41,640
solver okay

1348
00:51:41,640 --> 00:51:43,260
first thing let's just compare the

1349
00:51:43,260 --> 00:51:45,119
syntactic complexity of the three

1350
00:51:45,119 --> 00:51:47,819
expressions and very very simple it's

1351
00:51:47,819 --> 00:51:50,579
just observational exercise this is just

1352
00:51:50,579 --> 00:51:52,980
the expression put in C

1353
00:51:52,980 --> 00:51:56,579
C in C and this is the assembly uh the

1354
00:51:56,579 --> 00:51:58,859
produce assembly well minus the function

1355
00:51:58,859 --> 00:52:00,359
prologue and the functional epilogue

1356
00:52:00,359 --> 00:52:03,660
okay so the actual assembly code doing

1357
00:52:03,660 --> 00:52:06,540
the expression uh works like that if you

1358
00:52:06,540 --> 00:52:08,099
are reversing anything you have a

1359
00:52:08,099 --> 00:52:10,140
function that you just see that then

1360
00:52:10,140 --> 00:52:12,119
it's immediate it's an addition if you

1361
00:52:12,119 --> 00:52:14,280
see that wow

1362
00:52:14,280 --> 00:52:17,220
it's not that complicated you may need a

1363
00:52:17,220 --> 00:52:19,619
little bit of uh pen and paper but you

1364
00:52:19,619 --> 00:52:21,300
can see quite easily that this actually

1365
00:52:21,300 --> 00:52:23,339
corresponds to a to an addition because

1366
00:52:23,339 --> 00:52:25,680
well some tricks on the how this is

1367
00:52:25,680 --> 00:52:28,319
actually working on the xor and the car

1368
00:52:28,319 --> 00:52:30,059
and the carry values with that but then

1369
00:52:30,059 --> 00:52:32,599
if you see that or this representation

1370
00:52:32,599 --> 00:52:35,220
it's very improbable that you understand

1371
00:52:35,220 --> 00:52:37,380
what's happening in there okay and again

1372
00:52:37,380 --> 00:52:39,540
those are very very very very limited

1373
00:52:39,540 --> 00:52:41,400
and simple examples this expression can

1374
00:52:41,400 --> 00:52:44,579
grow as big as you want like bigger than

1375
00:52:44,579 --> 00:52:46,920
the whole screen if you want

1376
00:52:46,920 --> 00:52:49,740
okay because we can produce this uh

1377
00:52:49,740 --> 00:52:51,599
rewriting and insertion of identities

1378
00:52:51,599 --> 00:52:53,940
iteratively and it grows really fast

1379
00:52:53,940 --> 00:52:56,099
especially when you plug in sub

1380
00:52:56,099 --> 00:52:57,839
Expressions into the rewrite rule this

1381
00:52:57,839 --> 00:52:59,339
grows really really fast really really

1382
00:52:59,339 --> 00:53:02,880
quick uh into something really big if

1383
00:53:02,880 --> 00:53:05,940
you want to do that so the the group of

1384
00:53:05,940 --> 00:53:07,980
obfuscation of the the resulting

1385
00:53:07,980 --> 00:53:11,819
expression is totally totally arbitrary

1386
00:53:11,819 --> 00:53:13,319
now let's observe the semantic

1387
00:53:13,319 --> 00:53:15,119
equivalence between them and this case

1388
00:53:15,119 --> 00:53:16,740
just wow

1389
00:53:16,740 --> 00:53:18,599
some fantasy code I Define the two

1390
00:53:18,599 --> 00:53:21,380
functions of them then I get a couple

1391
00:53:21,380 --> 00:53:24,420
inputs from standard input and I then I

1392
00:53:24,420 --> 00:53:26,040
just call the three functions okay

1393
00:53:26,040 --> 00:53:27,599
there's nothing fancy there you also

1394
00:53:27,599 --> 00:53:29,339
have this code but just defining the

1395
00:53:29,339 --> 00:53:31,380
three functions and calling them with

1396
00:53:31,380 --> 00:53:33,780
inputs from from well from the calling

1397
00:53:33,780 --> 00:53:37,440
just call okay palette let's call uh the

1398
00:53:37,440 --> 00:53:38,940
problem with one and two and we see that

1399
00:53:38,940 --> 00:53:41,700
all the three functions produce the same

1400
00:53:41,700 --> 00:53:43,140
semantic Behavior and the same for this

1401
00:53:43,140 --> 00:53:45,180
example they produce the same outputs

1402
00:53:45,180 --> 00:53:46,440
means they are producing the same input

1403
00:53:46,440 --> 00:53:48,720
output first but and it's because we are

1404
00:53:48,720 --> 00:53:50,160
just observing that we can actually

1405
00:53:50,160 --> 00:53:53,040
prove it so let's just prove it and

1406
00:53:53,040 --> 00:53:54,300
we're going to prove this diagram of a

1407
00:53:54,300 --> 00:53:57,440
key balances which is a way of proving

1408
00:53:57,440 --> 00:54:00,059
uh when we want to prove that a lot of

1409
00:54:00,059 --> 00:54:01,559
things are equivalent between themselves

1410
00:54:01,559 --> 00:54:04,020
uh the naive approach is just proving

1411
00:54:04,020 --> 00:54:06,059
one with everything else and this second

1412
00:54:06,059 --> 00:54:09,240
with and everything else but it's just a

1413
00:54:09,240 --> 00:54:11,460
waste of time because you we can prove

1414
00:54:11,460 --> 00:54:13,200
like the whole circle then you can go

1415
00:54:13,200 --> 00:54:14,880
from one to the other and you don't need

1416
00:54:14,880 --> 00:54:17,520
to prove all with all okay actually the

1417
00:54:17,520 --> 00:54:20,040
last one is not even necessary because

1418
00:54:20,040 --> 00:54:21,900
uh the equivalence goes the other way

1419
00:54:21,900 --> 00:54:22,680
around

1420
00:54:22,680 --> 00:54:25,619
but for completeness I like to put it in

1421
00:54:25,619 --> 00:54:28,500
this case again a Z3 we Define exam wise

1422
00:54:28,500 --> 00:54:30,960
with vectors in this case of Egg Beats

1423
00:54:30,960 --> 00:54:32,700
can I'm using 8-bit in this case because

1424
00:54:32,700 --> 00:54:35,040
well it's kind of simpler the numbers

1425
00:54:35,040 --> 00:54:38,460
are more digestible for the for the

1426
00:54:38,460 --> 00:54:40,140
human eye but this kind of

1427
00:54:40,140 --> 00:54:42,359
Transformations work exactly in the same

1428
00:54:42,359 --> 00:54:45,900
way for any 16 bits 30 to be 64-bit and

1429
00:54:45,900 --> 00:54:48,540
this the functions not because they have

1430
00:54:48,540 --> 00:54:50,819
to be inverses on the bit size but the

1431
00:54:50,819 --> 00:54:53,400
rewrite rules uh all of them that we

1432
00:54:53,400 --> 00:54:56,160
generate are working on any kind of bit

1433
00:54:56,160 --> 00:54:57,720
size okay

1434
00:54:57,720 --> 00:55:00,359
so we just approve this diagram as we

1435
00:55:00,359 --> 00:55:04,140
saw and just run it okay that's proofed

1436
00:55:04,140 --> 00:55:06,540
which means that three expressions are

1437
00:55:06,540 --> 00:55:08,520
semantically equivalent as we wanted to

1438
00:55:08,520 --> 00:55:10,640
see

1439
00:55:11,160 --> 00:55:13,619
so

1440
00:55:13,619 --> 00:55:16,619
um let's discuss now about OPEC

1441
00:55:16,619 --> 00:55:17,940
constants

1442
00:55:17,940 --> 00:55:20,760
which is another technique which we can

1443
00:55:20,760 --> 00:55:22,380
leverage MBA Transformations for that

1444
00:55:22,380 --> 00:55:25,260
that all allows us to hide a Target

1445
00:55:25,260 --> 00:55:28,260
constant so why would we want to hide

1446
00:55:28,260 --> 00:55:30,059
the target constant think for example

1447
00:55:30,059 --> 00:55:33,720
any kind of dram or for example malware

1448
00:55:33,720 --> 00:55:35,880
that is doing some kind of crypto under

1449
00:55:35,880 --> 00:55:38,160
the hood if you have done any reversing

1450
00:55:38,160 --> 00:55:41,280
at all usually one of the first things

1451
00:55:41,280 --> 00:55:43,200
that you take a look is look for

1452
00:55:43,200 --> 00:55:45,240
cryptographic constants so you can

1453
00:55:45,240 --> 00:55:47,819
easily identify uh cryptographic

1454
00:55:47,819 --> 00:55:49,440
algorithms being used within the code so

1455
00:55:49,440 --> 00:55:51,180
you can trace back where is the yield

1456
00:55:51,180 --> 00:55:52,680
what is the data being consumed by the

1457
00:55:52,680 --> 00:55:54,300
cryptographic algorithm and so on so

1458
00:55:54,300 --> 00:55:56,579
forth so one of the first things that

1459
00:55:56,579 --> 00:55:57,720
you do and there are a lot of plugins

1460
00:55:57,720 --> 00:56:00,119
for Ida for level 2 and for any kind of

1461
00:56:00,119 --> 00:56:03,119
disassembler that actually find you this

1462
00:56:03,119 --> 00:56:04,980
cryptographic constants one of the use

1463
00:56:04,980 --> 00:56:07,200
cases for that is let's just hide this

1464
00:56:07,200 --> 00:56:09,240
constant so let's replace

1465
00:56:09,240 --> 00:56:11,359
the constants in code

1466
00:56:11,359 --> 00:56:14,760
by a construction by an expression that

1467
00:56:14,760 --> 00:56:16,619
produces the same constant but this is

1468
00:56:16,619 --> 00:56:20,359
completely obfuscated okay

1469
00:56:20,420 --> 00:56:24,359
this construct combines uh MB expression

1470
00:56:24,359 --> 00:56:27,720
now we'll see in a second with uh

1471
00:56:27,720 --> 00:56:30,119
cool tool mathematical tool called

1472
00:56:30,119 --> 00:56:33,119
permutation polynomials and and I will

1473
00:56:33,119 --> 00:56:34,500
discuss very briefly about permutation

1474
00:56:34,500 --> 00:56:37,380
polynomials but essentially

1475
00:56:37,380 --> 00:56:38,940
a permutation polynomial is just a

1476
00:56:38,940 --> 00:56:40,859
polynomial a regular arithmetic

1477
00:56:40,859 --> 00:56:43,020
polynomial which produces a permutation

1478
00:56:43,020 --> 00:56:44,760
which is a one-to-one mapping a

1479
00:56:44,760 --> 00:56:47,099
bijection okay which means that we can

1480
00:56:47,099 --> 00:56:49,980
go from the initial values to whatever

1481
00:56:49,980 --> 00:56:52,440
the the polynomial

1482
00:56:52,440 --> 00:56:55,559
leads us two and we can go back because

1483
00:56:55,559 --> 00:56:57,660
these are one-to-one mapping a

1484
00:56:57,660 --> 00:56:59,880
one-to-one permutation okay

1485
00:56:59,880 --> 00:57:01,740
in our case the values that we are using

1486
00:57:01,740 --> 00:57:04,020
are embed value so it's think of that as

1487
00:57:04,020 --> 00:57:08,220
a reordering of our box of MB values in

1488
00:57:08,220 --> 00:57:09,960
a way that is one to one which means

1489
00:57:09,960 --> 00:57:12,059
that we can apply the the inverse

1490
00:57:12,059 --> 00:57:13,700
reordering and get back the original

1491
00:57:13,700 --> 00:57:15,720
Regional values

1492
00:57:15,720 --> 00:57:19,440
uh just one note in here

1493
00:57:19,440 --> 00:57:22,339
uh

1494
00:57:23,040 --> 00:57:24,839
in general we have that for a

1495
00:57:24,839 --> 00:57:26,280
permutational program and we want to

1496
00:57:26,280 --> 00:57:28,559
find that we have another uh another

1497
00:57:28,559 --> 00:57:31,680
polynomial that defines the inverse okay

1498
00:57:31,680 --> 00:57:33,180
we have an ordering so we want to define

1499
00:57:33,180 --> 00:57:37,800
the inverse ordering uh we

1500
00:57:37,800 --> 00:57:40,079
we don't have for granted that this

1501
00:57:40,079 --> 00:57:42,599
polynomial exists but we have for

1502
00:57:42,599 --> 00:57:44,520
granted we don't have for granted it

1503
00:57:44,520 --> 00:57:47,160
exists in the same bit size okay and the

1504
00:57:47,160 --> 00:57:49,680
same degree sorry uh but such a

1505
00:57:49,680 --> 00:57:51,240
rewarding has to exist because we have

1506
00:57:51,240 --> 00:57:53,520
our permutation which is one to one so

1507
00:57:53,520 --> 00:57:55,260
the other one has to be has to be

1508
00:57:55,260 --> 00:57:56,640
defined anyway because this is about

1509
00:57:56,640 --> 00:57:58,800
ejection so just keep in mind that it

1510
00:57:58,800 --> 00:58:00,780
might not be defined in the same Degree

1511
00:58:00,780 --> 00:58:03,359
in General but we will use some

1512
00:58:03,359 --> 00:58:04,980
permutation phenomenas which are nice

1513
00:58:04,980 --> 00:58:07,079
that have this property and we can work

1514
00:58:07,079 --> 00:58:09,839
with them with a pretty bounded uh

1515
00:58:09,839 --> 00:58:11,220
degree okay

1516
00:58:11,220 --> 00:58:13,020
essentially this definition the way

1517
00:58:13,020 --> 00:58:14,520
you'll be using a

1518
00:58:14,520 --> 00:58:16,440
permutation we want a pair of

1519
00:58:16,440 --> 00:58:17,940
permutation polynomials of inverse

1520
00:58:17,940 --> 00:58:19,980
fermentation polynomials it's called p

1521
00:58:19,980 --> 00:58:22,619
and Q and the definition of them is that

1522
00:58:22,619 --> 00:58:24,240
well if we apply one then apply the

1523
00:58:24,240 --> 00:58:25,680
other as they are inverse pigmentation

1524
00:58:25,680 --> 00:58:28,380
inverse mappings then we apply to some

1525
00:58:28,380 --> 00:58:30,300
input we always get

1526
00:58:30,300 --> 00:58:32,339
the same as I'll put the same input as

1527
00:58:32,339 --> 00:58:34,020
the initially because one

1528
00:58:34,020 --> 00:58:36,299
like one ordering then we undo the order

1529
00:58:36,299 --> 00:58:37,980
and we get back the same

1530
00:58:37,980 --> 00:58:40,760
the same initial value okay

1531
00:58:40,760 --> 00:58:43,260
in a sense this function this

1532
00:58:43,260 --> 00:58:44,760
periodation polynomials are

1533
00:58:44,760 --> 00:58:47,339
generalization of of affine functions

1534
00:58:47,339 --> 00:58:49,559
and a fine function you can think of an

1535
00:58:49,559 --> 00:58:50,819
affine function as a permutational

1536
00:58:50,819 --> 00:58:53,339
polynomial of degree one okay these are

1537
00:58:53,339 --> 00:58:56,400
just the generalization on any degree

1538
00:58:56,400 --> 00:58:59,099
so uh closing the integration about

1539
00:58:59,099 --> 00:59:00,240
permutation point on is the only thing

1540
00:59:00,240 --> 00:59:01,920
that you need to remember is that those

1541
00:59:01,920 --> 00:59:05,460
are polynomials that are inverses within

1542
00:59:05,460 --> 00:59:07,619
themselves and Define a one-to-one

1543
00:59:07,619 --> 00:59:10,859
mapping okay so we need uh so many

1544
00:59:10,859 --> 00:59:13,260
Expressions some particular kind of can

1545
00:59:13,260 --> 00:59:14,339
be expression that we'll discuss in a

1546
00:59:14,339 --> 00:59:16,200
second and also this permutation

1547
00:59:16,200 --> 00:59:18,059
polynomials

1548
00:59:18,059 --> 00:59:20,339
so let's just construct it what are the

1549
00:59:20,339 --> 00:59:22,319
ingredients that we need to hide the

1550
00:59:22,319 --> 00:59:24,420
constant first we need the constant the

1551
00:59:24,420 --> 00:59:27,599
one height I would call it K uh this is

1552
00:59:27,599 --> 00:59:30,059
an embed constant we want to hide now we

1553
00:59:30,059 --> 00:59:32,220
need a pair of inverse permutation

1554
00:59:32,220 --> 00:59:35,040
polynomials okay again I put again what

1555
00:59:35,040 --> 00:59:37,200
does that mean but this is just a pair

1556
00:59:37,200 --> 00:59:39,119
of polynomials that Define one-to-one

1557
00:59:39,119 --> 00:59:40,440
mappings

1558
00:59:40,440 --> 00:59:43,140
and then we need an MB expression here

1559
00:59:43,140 --> 00:59:46,920
which is uh which works on any kind of

1560
00:59:46,920 --> 00:59:49,380
any number of variables we don't care

1561
00:59:49,380 --> 00:59:51,720
but that is non-trivial equal to zero

1562
00:59:51,720 --> 00:59:53,400
and by non-trivial equal to zero means

1563
00:59:53,400 --> 00:59:55,500
that this is an expression on any number

1564
00:59:55,500 --> 00:59:59,040
of variables and regardless of the input

1565
00:59:59,040 --> 01:00:00,960
variables that we throw to evaluate this

1566
01:00:00,960 --> 01:00:03,059
expression the output of the expression

1567
01:00:03,059 --> 01:00:05,040
is always zero and the non-trivial part

1568
01:00:05,040 --> 01:00:07,200
just that means that this MB expression

1569
01:00:07,200 --> 01:00:09,240
is not zero itself it's just something

1570
01:00:09,240 --> 01:00:11,640
that is not trivial but

1571
01:00:11,640 --> 01:00:14,339
plugging some variables into it any kind

1572
01:00:14,339 --> 01:00:16,740
of variables it will always produce zero

1573
01:00:16,740 --> 01:00:19,319
so it's semantically equivalent to the

1574
01:00:19,319 --> 01:00:20,880
constant function zero if you want to

1575
01:00:20,880 --> 01:00:23,480
think in that way

1576
01:00:23,640 --> 01:00:25,920
so now we have these ingredients our

1577
01:00:25,920 --> 01:00:27,720
constant our pair of fermentation

1578
01:00:27,720 --> 01:00:29,520
polynomials our and our non-trivial

1579
01:00:29,520 --> 01:00:31,980
equal to zero and B expression then we

1580
01:00:31,980 --> 01:00:35,760
can hide our constant by replacing it by

1581
01:00:35,760 --> 01:00:37,319
the expression produced or the function

1582
01:00:37,319 --> 01:00:40,020
produced by this construction okay and

1583
01:00:40,020 --> 01:00:42,119
this construction is just applying the

1584
01:00:42,119 --> 01:00:44,640
first permutation polynomials and as

1585
01:00:44,640 --> 01:00:47,640
input it's taking the non-trivial equal

1586
01:00:47,640 --> 01:00:50,760
to your MBA plus the the inverse

1587
01:00:50,760 --> 01:00:52,859
permutation polynomial evaluated in our

1588
01:00:52,859 --> 01:00:55,040
constant okay

1589
01:00:55,040 --> 01:00:57,900
I won't go over the formal proof of why

1590
01:00:57,900 --> 01:01:00,000
this actually works which means that why

1591
01:01:00,000 --> 01:01:01,680
this construction the expression that we

1592
01:01:01,680 --> 01:01:03,599
obtain by this construction always gets

1593
01:01:03,599 --> 01:01:07,260
us back our constant but the model proof

1594
01:01:07,260 --> 01:01:10,980
if you want is that essentially if you

1595
01:01:10,980 --> 01:01:13,740
remove the E from here you have P of Q

1596
01:01:13,740 --> 01:01:15,660
okay and as P of QR permutation

1597
01:01:15,660 --> 01:01:18,599
polynomials inverse mappings then that

1598
01:01:18,599 --> 01:01:21,059
will be K okay so we are retrieving K

1599
01:01:21,059 --> 01:01:22,920
and why

1600
01:01:22,920 --> 01:01:25,020
without being a former pro a former

1601
01:01:25,020 --> 01:01:28,440
proof the moral uh because we can do

1602
01:01:28,440 --> 01:01:30,900
that is because well e actually their

1603
01:01:30,900 --> 01:01:33,240
semantics are zero so the semantics of

1604
01:01:33,240 --> 01:01:34,920
the expression here introduced within

1605
01:01:34,920 --> 01:01:37,319
this construction are

1606
01:01:37,319 --> 01:01:40,079
essentially vanished

1607
01:01:40,079 --> 01:01:41,760
they're interlude within the final

1608
01:01:41,760 --> 01:01:44,579
expression but the effects that the E

1609
01:01:44,579 --> 01:01:46,200
part in here plays within the

1610
01:01:46,200 --> 01:01:47,760
construction of the expression is

1611
01:01:47,760 --> 01:01:50,520
vanished because the E actually the

1612
01:01:50,520 --> 01:01:52,680
semantics of V is zero okay the formal

1613
01:01:52,680 --> 01:01:54,599
proves a little bit more involved but

1614
01:01:54,599 --> 01:01:58,020
the model of it like the way which you

1615
01:01:58,020 --> 01:02:00,000
can be convinced that this makes sense

1616
01:02:00,000 --> 01:02:02,880
is that okay you can think that the the

1617
01:02:02,880 --> 01:02:05,579
meaning of the MB expression e in here

1618
01:02:05,579 --> 01:02:08,400
as e is not usually equal to zero is

1619
01:02:08,400 --> 01:02:09,839
equal to zero from a semantic point of

1620
01:02:09,839 --> 01:02:12,359
view it just vanishes and then we would

1621
01:02:12,359 --> 01:02:15,900
have the same meaning as applying P to Q

1622
01:02:15,900 --> 01:02:18,180
of K which is the two inverse perimeters

1623
01:02:18,180 --> 01:02:20,700
polynomials cancel on each other and we

1624
01:02:20,700 --> 01:02:22,799
get the same constant okay

1625
01:02:22,799 --> 01:02:25,200
these are a bit the moral motivation of

1626
01:02:25,200 --> 01:02:27,059
why this works while the formal proof is

1627
01:02:27,059 --> 01:02:28,319
a little bit more well we won't go over

1628
01:02:28,319 --> 01:02:30,359
it and again this will be an expression

1629
01:02:30,359 --> 01:02:32,940
a function if you want which will be on

1630
01:02:32,940 --> 01:02:35,579
the number of variables of the MBA

1631
01:02:35,579 --> 01:02:37,020
expression and there can be any number

1632
01:02:37,020 --> 01:02:39,660
of variables we don't care because it's

1633
01:02:39,660 --> 01:02:43,200
always by evaluating to zero okay

1634
01:02:43,200 --> 01:02:46,440
okay having this here let's actually

1635
01:02:46,440 --> 01:02:48,900
build one let's see a practical example

1636
01:02:48,900 --> 01:02:50,520
of that

1637
01:02:50,520 --> 01:02:53,160
so consider

1638
01:02:53,160 --> 01:02:55,859
um again working on 8-bit values again

1639
01:02:55,859 --> 01:02:59,220
for the Simplicity of the polynomial I

1640
01:02:59,220 --> 01:03:00,780
think that we will see but this would

1641
01:03:00,780 --> 01:03:03,359
work on any bit size so consider this

1642
01:03:03,359 --> 01:03:06,059
pair automatican polynomials uh this is

1643
01:03:06,059 --> 01:03:07,440
just permutation binomials which happen

1644
01:03:07,440 --> 01:03:09,900
to be inverse will say in a second but

1645
01:03:09,900 --> 01:03:11,339
you can trust me that they are inverse

1646
01:03:11,339 --> 01:03:12,839
permutation polynomials

1647
01:03:12,839 --> 01:03:14,700
and then we have this MBA expression in

1648
01:03:14,700 --> 01:03:17,760
this case on two variables which is a

1649
01:03:17,760 --> 01:03:19,440
non-trivially equal to 0mb expression

1650
01:03:19,440 --> 01:03:20,880
you can again trust me and we will see

1651
01:03:20,880 --> 01:03:22,799
in a second that this is non-trivial

1652
01:03:22,799 --> 01:03:26,180
equal to zero again let me repeat

1653
01:03:26,180 --> 01:03:29,339
means that for any X and Y values that

1654
01:03:29,339 --> 01:03:31,980
we evaluate this expression in the

1655
01:03:31,980 --> 01:03:34,200
result will always be zero okay but this

1656
01:03:34,200 --> 01:03:36,540
is non-trivial meaning this is not zero

1657
01:03:36,540 --> 01:03:39,119
itself

1658
01:03:39,119 --> 01:03:40,500
so

1659
01:03:40,500 --> 01:03:43,140
uh our Tasker right now would be first

1660
01:03:43,140 --> 01:03:45,240
let's check that P and Q actually Define

1661
01:03:45,240 --> 01:03:47,819
inverse mappings so that I will apply

1662
01:03:47,819 --> 01:03:50,640
one then the other to give an input for

1663
01:03:50,640 --> 01:03:52,799
all the possible inputs then we we

1664
01:03:52,799 --> 01:03:54,900
receive as output the same as the input

1665
01:03:54,900 --> 01:03:58,280
we also check that e our MB expression e

1666
01:03:58,280 --> 01:04:00,780
defines a non-true value equal to zero

1667
01:04:00,780 --> 01:04:02,640
MB expression that means that it

1668
01:04:02,640 --> 01:04:04,980
produces the zero output for all X and Y

1669
01:04:04,980 --> 01:04:06,119
inputs

1670
01:04:06,119 --> 01:04:08,400
and then let's create an OPAC constant

1671
01:04:08,400 --> 01:04:11,520
using our permutation polynomials that

1672
01:04:11,520 --> 01:04:14,280
we have seen and also e to hide the

1673
01:04:14,280 --> 01:04:15,900
constant k equals one two three for

1674
01:04:15,900 --> 01:04:18,599
example okay let's build this process

1675
01:04:18,599 --> 01:04:20,280
this upper constant function this up a

1676
01:04:20,280 --> 01:04:22,099
constant expression to

1677
01:04:22,099 --> 01:04:25,740
obfuscate our constant one two three

1678
01:04:25,740 --> 01:04:27,839
and finally let's check that the upper

1679
01:04:27,839 --> 01:04:29,099
constant we have constructed actually

1680
01:04:29,099 --> 01:04:32,220
works actually is giving us uh the the

1681
01:04:32,220 --> 01:04:34,559
constant that we want to hide

1682
01:04:34,559 --> 01:04:38,579
so let's do this uh first of all uh

1683
01:04:38,579 --> 01:04:40,260
let's check the p and Q defined inverse

1684
01:04:40,260 --> 01:04:41,819
mappings in this case I also like to

1685
01:04:41,819 --> 01:04:43,260
include like brute force method because

1686
01:04:43,260 --> 01:04:45,299
we are in eight bits we can literally

1687
01:04:45,299 --> 01:04:47,160
Brute Force the entire space you don't

1688
01:04:47,160 --> 01:04:48,839
really need to read this code you have

1689
01:04:48,839 --> 01:04:50,940
it but essentially I'm defining two

1690
01:04:50,940 --> 01:04:52,920
polynomials and I am traversing all the

1691
01:04:52,920 --> 01:04:54,720
possible inputs and checking that for

1692
01:04:54,720 --> 01:04:57,480
all of them uh it matches the expected

1693
01:04:57,480 --> 01:04:59,280
Behavior which is that all inputs

1694
01:04:59,280 --> 01:05:01,200
produce the same output as the input

1695
01:05:01,200 --> 01:05:03,000
okay this Brute Force we can do brute

1696
01:05:03,000 --> 01:05:04,920
forcing here I want to illustrate that

1697
01:05:04,920 --> 01:05:06,359
because we are working on eight bits and

1698
01:05:06,359 --> 01:05:07,980
it's easy to Brute Force entire 8-bit

1699
01:05:07,980 --> 01:05:10,140
space if you were working on 64-bit you

1700
01:05:10,140 --> 01:05:11,339
can't brute force that another

1701
01:05:11,339 --> 01:05:14,160
reasonable amount of time is not that

1702
01:05:14,160 --> 01:05:16,140
you need it because if you have your

1703
01:05:16,140 --> 01:05:17,640
permutation polynomials to be correct

1704
01:05:17,640 --> 01:05:19,260
you don't need to prove them every time

1705
01:05:19,260 --> 01:05:21,000
you already have generated them to be

1706
01:05:21,000 --> 01:05:24,059
correct but I want to show

1707
01:05:24,059 --> 01:05:26,520
you that we are actually working with uh

1708
01:05:26,520 --> 01:05:27,960
correct permutation point on now in this

1709
01:05:27,960 --> 01:05:30,660
case so for eight bits I said we can

1710
01:05:30,660 --> 01:05:32,579
Brute Force everything if you don't want

1711
01:05:32,579 --> 01:05:34,140
to brute force or you are on any bit

1712
01:05:34,140 --> 01:05:36,839
size way bigger than that we can also

1713
01:05:36,839 --> 01:05:39,059
prove that with an smt solver really

1714
01:05:39,059 --> 01:05:41,579
easily similarly as we've done before we

1715
01:05:41,579 --> 01:05:43,680
import everything from the tree we find

1716
01:05:43,680 --> 01:05:46,020
X in this case capital x because we want

1717
01:05:46,020 --> 01:05:47,700
to differentiate in this case the

1718
01:05:47,700 --> 01:05:49,380
permutation polynomials variables from

1719
01:05:49,380 --> 01:05:51,119
the variables within the ab expression

1720
01:05:51,119 --> 01:05:53,339
so we call it capital X

1721
01:05:53,339 --> 01:05:56,760
we just defined it to uh polynomials and

1722
01:05:56,760 --> 01:05:59,880
we asked us uh Z3 hey can you prove me

1723
01:05:59,880 --> 01:06:02,339
that the semantics of the combination of

1724
01:06:02,339 --> 01:06:04,020
the two polynomials is equals to the

1725
01:06:04,020 --> 01:06:06,180
semantic of the variable itself to the

1726
01:06:06,180 --> 01:06:07,980
input itself which is are those two

1727
01:06:07,980 --> 01:06:10,980
polynomials inverse mappings and we just

1728
01:06:10,980 --> 01:06:14,700
run it and again proved again all this

1729
01:06:14,700 --> 01:06:17,040
code you have in the in the in the

1730
01:06:17,040 --> 01:06:18,480
materials for for today you want to go

1731
01:06:18,480 --> 01:06:21,119
operate and play around it

1732
01:06:21,119 --> 01:06:23,880
you have all this code available

1733
01:06:23,880 --> 01:06:26,280
then let's do the same thing with the MB

1734
01:06:26,280 --> 01:06:28,619
expression e let's check that it is

1735
01:06:28,619 --> 01:06:30,660
non-trivial equal to zero again we can

1736
01:06:30,660 --> 01:06:32,700
brute force in this case it's the entire

1737
01:06:32,700 --> 01:06:35,839
8-bit space well both for X on y so it's

1738
01:06:35,839 --> 01:06:38,760
twice the the illustrate but anyway it's

1739
01:06:38,760 --> 01:06:40,980
visible if you wanted to do Brute Force

1740
01:06:40,980 --> 01:06:42,240
which is not something that you want to

1741
01:06:42,240 --> 01:06:44,460
do in general but here I want to be

1742
01:06:44,460 --> 01:06:46,440
super explicit with you

1743
01:06:46,440 --> 01:06:47,640
don't really need to understand anything

1744
01:06:47,640 --> 01:06:50,160
here just traversing the all possible

1745
01:06:50,160 --> 01:06:51,960
light bit space for the two variables

1746
01:06:51,960 --> 01:06:54,780
and then checking that uh no possible

1747
01:06:54,780 --> 01:06:56,460
pair of inputs producers are not zero

1748
01:06:56,460 --> 01:06:58,319
output which means all inputs produce

1749
01:06:58,319 --> 01:07:01,319
zero output okay which essentially in

1750
01:07:01,319 --> 01:07:04,140
other words our MBA is an untrueable

1751
01:07:04,140 --> 01:07:06,660
equal to zero MBA expression

1752
01:07:06,660 --> 01:07:09,059
again we can prove it with that with the

1753
01:07:09,059 --> 01:07:11,520
tree with the smt we Define X and Y as

1754
01:07:11,520 --> 01:07:13,799
with vectors of 8 Bits And then we

1755
01:07:13,799 --> 01:07:16,619
Define uh our xmb expression as a

1756
01:07:16,619 --> 01:07:18,900
function and we ask the smt solver to

1757
01:07:18,900 --> 01:07:20,700
prove that the semantics of the

1758
01:07:20,700 --> 01:07:22,319
expression are equivalent to semantics

1759
01:07:22,319 --> 01:07:25,799
of zero that it produces the same input

1760
01:07:25,799 --> 01:07:28,260
output behavior that the constant

1761
01:07:28,260 --> 01:07:30,780
function zero that is non-trivial equal

1762
01:07:30,780 --> 01:07:32,579
to zero

1763
01:07:32,579 --> 01:07:36,960
so you can run it again proofed

1764
01:07:36,960 --> 01:07:39,720
now we have proved that we have a pair

1765
01:07:39,720 --> 01:07:41,880
of inverse permutation polynomials we

1766
01:07:41,880 --> 01:07:43,380
have a

1767
01:07:43,380 --> 01:07:45,299
our Notch available to Jeremy expression

1768
01:07:45,299 --> 01:07:47,579
let's now construct our constant

1769
01:07:47,579 --> 01:07:48,660
function this code is a little bit

1770
01:07:48,660 --> 01:07:50,400
larger but everything we already seen

1771
01:07:50,400 --> 01:07:52,980
like all of that is just copy pasting

1772
01:07:52,980 --> 01:07:55,440
what we have seen before we Define the

1773
01:07:55,440 --> 01:07:58,319
pair of permutation polynomials uh with

1774
01:07:58,319 --> 01:08:01,680
capital x to differentiate it

1775
01:08:01,680 --> 01:08:04,680
um yep and then we Define X and Y as the

1776
01:08:04,680 --> 01:08:07,440
variables a bit variables again for the

1777
01:08:07,440 --> 01:08:09,420
non-trivial equal to zero expression so

1778
01:08:09,420 --> 01:08:11,400
we have our ingredients in here we have

1779
01:08:11,400 --> 01:08:13,200
the permutation polynomials inverse

1780
01:08:13,200 --> 01:08:15,359
permutation polynomials our non-trivial

1781
01:08:15,359 --> 01:08:17,460
equal to 0mb expression and then we just

1782
01:08:17,460 --> 01:08:19,738
Define a constant value in this case we

1783
01:08:19,738 --> 01:08:23,100
Define it as a Z3 object to operate with

1784
01:08:23,100 --> 01:08:24,779
combined with expression it's just a

1785
01:08:24,779 --> 01:08:27,660
fancy way of saying hey K is a concrete

1786
01:08:27,660 --> 01:08:31,020
value of 8 Bits with value one two three

1787
01:08:31,020 --> 01:08:33,560
okay

1788
01:08:34,880 --> 01:08:37,140
let's just apply the definition of the

1789
01:08:37,140 --> 01:08:39,238
upper constant or up a constant function

1790
01:08:39,238 --> 01:08:41,580
of a constant expression was the

1791
01:08:41,580 --> 01:08:43,679
polynomial p and the input for it being

1792
01:08:43,679 --> 01:08:46,679
the MBA expression plus the polynomial Q

1793
01:08:46,679 --> 01:08:50,160
it's inverse applied to the constant k

1794
01:08:50,160 --> 01:08:53,339
let's just uh do this construction and

1795
01:08:53,339 --> 01:08:55,859
then let's print it here I have a

1796
01:08:55,859 --> 01:08:57,779
kind of simplify function which comes

1797
01:08:57,779 --> 01:08:59,759
from Z3 which in a way the only thing

1798
01:08:59,759 --> 01:09:01,620
that is doing is grouping the terms

1799
01:09:01,620 --> 01:09:03,359
together and collapsing the constant

1800
01:09:03,359 --> 01:09:06,000
that might be uh laying around it's just

1801
01:09:06,000 --> 01:09:08,100
a way of printing a little bit nicer

1802
01:09:08,100 --> 01:09:09,540
okay but it's not doing anything else

1803
01:09:09,540 --> 01:09:12,359
just printing a little bit nicer

1804
01:09:12,359 --> 01:09:15,120
so we create uh this open constant we

1805
01:09:15,120 --> 01:09:18,000
run it and this is the our outcome this

1806
01:09:18,000 --> 01:09:20,698
is the expression that defines the OPAC

1807
01:09:20,698 --> 01:09:23,339
constant which means this expression on

1808
01:09:23,339 --> 01:09:25,500
X and Y variables on two inputs on two

1809
01:09:25,500 --> 01:09:27,899
eight bit inputs always produces as an

1810
01:09:27,899 --> 01:09:30,179
output the constant one two three four

1811
01:09:30,179 --> 01:09:32,040
new values X and Y

1812
01:09:32,040 --> 01:09:34,799
is all of a constant function

1813
01:09:34,799 --> 01:09:37,020
ah let's check it again we can Brute

1814
01:09:37,020 --> 01:09:39,000
Force entire space for eight bits this

1815
01:09:39,000 --> 01:09:40,080
is not something you can do in general

1816
01:09:40,080 --> 01:09:42,000
for bigger bit size but in this case you

1817
01:09:42,000 --> 01:09:43,198
can do it and I want to be super

1818
01:09:43,198 --> 01:09:45,238
explicit uh

1819
01:09:45,238 --> 01:09:47,339
so we just Define our function here's

1820
01:09:47,339 --> 01:09:48,540
exactly the same function put a little

1821
01:09:48,540 --> 01:09:51,238
bit more compacted so it feeds in the

1822
01:09:51,238 --> 01:09:53,640
screen and then we iterate over the

1823
01:09:53,640 --> 01:09:55,800
whole 8-bit space and we check that

1824
01:09:55,800 --> 01:09:58,380
there is no possible pair of inputs that

1825
01:09:58,380 --> 01:10:00,179
produces a result different than now

1826
01:10:00,179 --> 01:10:01,320
anti-3

1827
01:10:01,320 --> 01:10:03,960
so we just run it and say okay your

1828
01:10:03,960 --> 01:10:05,460
borrow the constant once is one two

1829
01:10:05,460 --> 01:10:08,520
three we can also prove that with an smt

1830
01:10:08,520 --> 01:10:10,620
solver again the same thing that we've

1831
01:10:10,620 --> 01:10:12,660
done so far we Define X and y's with

1832
01:10:12,660 --> 01:10:14,760
vectors of 8 Bits with the final for

1833
01:10:14,760 --> 01:10:17,160
Oppa constant function and then we prove

1834
01:10:17,160 --> 01:10:19,440
we ask the sentence over to prove that

1835
01:10:19,440 --> 01:10:21,600
our constant function is semantically

1836
01:10:21,600 --> 01:10:23,699
equivalent to the function the constant

1837
01:10:23,699 --> 01:10:25,980
function one two three okay which is

1838
01:10:25,980 --> 01:10:28,320
running it's proved

1839
01:10:28,320 --> 01:10:31,560
which means that this function now we

1840
01:10:31,560 --> 01:10:33,600
can use it in our code in our C code one

1841
01:10:33,600 --> 01:10:35,940
thing that we are using and instead well

1842
01:10:35,940 --> 01:10:37,440
it here is one to three what it can be

1843
01:10:37,440 --> 01:10:39,840
for example all the md5 constants that

1844
01:10:39,840 --> 01:10:41,219
you want to hide that you're using md5

1845
01:10:41,219 --> 01:10:43,260
for whatever you might be wanting to use

1846
01:10:43,260 --> 01:10:46,500
md5 instead of having uh the constant

1847
01:10:46,500 --> 01:10:48,179
laying around the data section of your

1848
01:10:48,179 --> 01:10:51,179
binary you can have calls to functions

1849
01:10:51,179 --> 01:10:54,179
which are obfuscated with random

1850
01:10:54,179 --> 01:10:56,699
parameters calling these functions and

1851
01:10:56,699 --> 01:10:59,880
also you could also construct like 10 20

1852
01:10:59,880 --> 01:11:02,159
30 different functions using different

1853
01:11:02,159 --> 01:11:03,600
permutation polynomials are different

1854
01:11:03,600 --> 01:11:05,820
and non-trivial equal to zmb expressions

1855
01:11:05,820 --> 01:11:08,219
for the same constant and every time you

1856
01:11:08,219 --> 01:11:09,840
need that constant you call a different

1857
01:11:09,840 --> 01:11:11,880
function kind of randomly you can pick

1858
01:11:11,880 --> 01:11:14,640
whichever of them and you can use kind

1859
01:11:14,640 --> 01:11:17,340
of also random or actually random inputs

1860
01:11:17,340 --> 01:11:19,620
for any of the functions that you wanted

1861
01:11:19,620 --> 01:11:21,780
and you will get back the constant that

1862
01:11:21,780 --> 01:11:23,940
you want okay

1863
01:11:23,940 --> 01:11:27,300
so uh well just some words before the

1864
01:11:27,300 --> 01:11:28,620
summary

1865
01:11:28,620 --> 01:11:31,620
you might be thinking okay but if I'm

1866
01:11:31,620 --> 01:11:33,780
doing Dynamic analysis and I just see

1867
01:11:33,780 --> 01:11:36,120
this function and I try to run it like

1868
01:11:36,120 --> 01:11:38,219
several times or even with an emulator I

1869
01:11:38,219 --> 01:11:40,020
will see that always producing the same

1870
01:11:40,020 --> 01:11:42,420
uh the same output and the answer is

1871
01:11:42,420 --> 01:11:45,480
yeah of course uh but

1872
01:11:45,480 --> 01:11:48,360
that's not immediate for for an analyst

1873
01:11:48,360 --> 01:11:50,280
for an attacker to get to a point where

1874
01:11:50,280 --> 01:11:52,500
you have isolated a function of or a set

1875
01:11:52,500 --> 01:11:54,480
of functions that you think they are

1876
01:11:54,480 --> 01:11:57,540
suspicious and you decide okay let's try

1877
01:11:57,540 --> 01:11:59,520
some probabilistic approach let's try to

1878
01:11:59,520 --> 01:12:01,380
run or emulate that a lot of times to

1879
01:12:01,380 --> 01:12:03,360
see what happens and then discover okay

1880
01:12:03,360 --> 01:12:05,520
it's just a constant function

1881
01:12:05,520 --> 01:12:07,080
first thing is that that is not

1882
01:12:07,080 --> 01:12:09,000
immediate that requires some degree of

1883
01:12:09,000 --> 01:12:11,580
model analysis and understanding of the

1884
01:12:11,580 --> 01:12:13,140
whole program which can be obfuscated as

1885
01:12:13,140 --> 01:12:15,060
well to be in a position where you can

1886
01:12:15,060 --> 01:12:17,159
say okay let's just take a look at this

1887
01:12:17,159 --> 01:12:20,219
and then decide that it's constant but

1888
01:12:20,219 --> 01:12:22,080
even if we're in this scenario there is

1889
01:12:22,080 --> 01:12:24,300
someone going research which is as far

1890
01:12:24,300 --> 01:12:25,860
as I know there is no public research on

1891
01:12:25,860 --> 01:12:27,900
that but at least I know

1892
01:12:27,900 --> 01:12:29,400
uh

1893
01:12:29,400 --> 01:12:31,800
another person doing kind of similar

1894
01:12:31,800 --> 01:12:34,440
things apart from me where we can

1895
01:12:34,440 --> 01:12:37,260
construct these kinds of things but they

1896
01:12:37,260 --> 01:12:41,400
only produce the constant desired If X

1897
01:12:41,400 --> 01:12:42,600
and Y

1898
01:12:42,600 --> 01:12:45,120
not they are not some specific values

1899
01:12:45,120 --> 01:12:46,620
but they satisfy some kind of constraint

1900
01:12:46,620 --> 01:12:49,320
so for example I have some private

1901
01:12:49,320 --> 01:12:51,120
research that I hope to publish soon

1902
01:12:51,120 --> 01:12:52,739
where I can construct this kind of

1903
01:12:52,739 --> 01:12:55,679
things but only when X and Y can be

1904
01:12:55,679 --> 01:12:57,980
seemingly random but they have to

1905
01:12:57,980 --> 01:13:01,860
satisfy that X and Y are inverse uh

1906
01:13:01,860 --> 01:13:05,280
inverse uh integers modulo the bit size

1907
01:13:05,280 --> 01:13:07,020
that we are working with for example so

1908
01:13:07,020 --> 01:13:09,840
it's even more resistant to this kind of

1909
01:13:09,840 --> 01:13:11,580
dynamic emulation analysis for

1910
01:13:11,580 --> 01:13:13,560
probabilistic approach because the true

1911
01:13:13,560 --> 01:13:15,120
constant would only reveal on some

1912
01:13:15,120 --> 01:13:18,239
certain cases for some constraints and

1913
01:13:18,239 --> 01:13:22,500
and all four other kind of inputs it

1914
01:13:22,500 --> 01:13:24,480
will produce seemingly random uh

1915
01:13:24,480 --> 01:13:26,100
seemingly random

1916
01:13:26,100 --> 01:13:28,199
output so there are some improvements

1917
01:13:28,199 --> 01:13:29,760
that that can be applied to that there's

1918
01:13:29,760 --> 01:13:31,380
some research ongoing but this

1919
01:13:31,380 --> 01:13:33,239
construction by itself is combined if

1920
01:13:33,239 --> 01:13:35,280
combined with several functions for

1921
01:13:35,280 --> 01:13:36,960
several constants and just picking

1922
01:13:36,960 --> 01:13:39,300
randomly and using random inputs it's

1923
01:13:39,300 --> 01:13:41,520
very very effective especially to start

1924
01:13:41,520 --> 01:13:43,739
a slow down allow the analysis and the

1925
01:13:43,739 --> 01:13:46,440
detection of maybe some crypto constant

1926
01:13:46,440 --> 01:13:48,420
being used or maybe some part of some

1927
01:13:48,420 --> 01:13:51,600
keys uh for some decryption of some

1928
01:13:51,600 --> 01:13:53,280
assets or whatever

1929
01:13:53,280 --> 01:13:54,540
okay

1930
01:13:54,540 --> 01:13:55,920
so

1931
01:13:55,920 --> 01:13:59,340
uh the summary we've seen how to apply

1932
01:13:59,340 --> 01:14:01,679
several MBA Association techniques

1933
01:14:01,679 --> 01:14:03,840
particle we have discussed about NBA

1934
01:14:03,840 --> 01:14:05,520
rewriting and session of identities and

1935
01:14:05,520 --> 01:14:07,320
upper constants and to do that

1936
01:14:07,320 --> 01:14:09,960
we have used several tools

1937
01:14:09,960 --> 01:14:12,719
and particular rewrite rules we have a

1938
01:14:12,719 --> 01:14:14,880
financial fine functions permutation

1939
01:14:14,880 --> 01:14:17,460
polynomials also this non-tival equal to

1940
01:14:17,460 --> 01:14:19,620
zero MB expressions

1941
01:14:19,620 --> 01:14:23,699
okay so now uh I want to do a bit of

1942
01:14:23,699 --> 01:14:26,640
demo about okay this is cool but what

1943
01:14:26,640 --> 01:14:28,980
can we do with that like in real life if

1944
01:14:28,980 --> 01:14:31,140
I have not convinced you enough with the

1945
01:14:31,140 --> 01:14:32,640
examples that I gave you that is really

1946
01:14:32,640 --> 01:14:34,860
powerful we can see are not very

1947
01:14:34,860 --> 01:14:37,620
Advanced examples but uh

1948
01:14:37,620 --> 01:14:40,620
some real examples about about it going

1949
01:14:40,620 --> 01:14:41,640
on okay

1950
01:14:41,640 --> 01:14:45,000
okay let's go back to here

1951
01:14:45,000 --> 01:14:46,920
so we have some time

1952
01:14:46,920 --> 01:14:49,760
to play with it

1953
01:14:50,820 --> 01:14:54,780
so uh can you read that well from the

1954
01:14:54,780 --> 01:14:56,100
from the back

1955
01:14:56,100 --> 01:14:57,480
okay

1956
01:14:57,480 --> 01:15:00,659
so imagine that you have this super dumb

1957
01:15:00,659 --> 01:15:04,380
code this function which is just okay uh

1958
01:15:04,380 --> 01:15:05,760
I will receive two parameters from

1959
01:15:05,760 --> 01:15:09,179
standard input and we generate an xor

1960
01:15:09,179 --> 01:15:11,699
and print it the the actual result of

1961
01:15:11,699 --> 01:15:12,659
that

1962
01:15:12,659 --> 01:15:13,800
okay

1963
01:15:13,800 --> 01:15:16,080
so we take a look

1964
01:15:16,080 --> 01:15:20,300
at the Assembly of that

1965
01:15:20,880 --> 01:15:24,560
well actually it was just

1966
01:15:25,860 --> 01:15:27,840
this is the main function and everything

1967
01:15:27,840 --> 01:15:30,080
is in there and if you see that

1968
01:15:30,080 --> 01:15:33,120
practically all of the code is passing

1969
01:15:33,120 --> 01:15:34,380
the standard input and converting into

1970
01:15:34,380 --> 01:15:36,000
integers okay

1971
01:15:36,000 --> 01:15:38,340
so there's nothing going on in there

1972
01:15:38,340 --> 01:15:40,800
and then when we have that the only

1973
01:15:40,800 --> 01:15:43,199
actual semantics Happening Here is okay

1974
01:15:43,199 --> 01:15:46,199
we have the first parameter the second

1975
01:15:46,199 --> 01:15:48,239
parameter and we are doing an xor and

1976
01:15:48,239 --> 01:15:50,880
then that's it let's print it and we

1977
01:15:50,880 --> 01:15:52,380
have finished there's nothing fancy

1978
01:15:52,380 --> 01:15:54,239
going on in here

1979
01:15:54,239 --> 01:15:57,060
just loading the parameters and doing

1980
01:15:57,060 --> 01:16:00,780
this xor which is kind of stands out

1981
01:16:00,780 --> 01:16:03,239
immediately

1982
01:16:03,239 --> 01:16:05,400
uh what if we just want to have this

1983
01:16:05,400 --> 01:16:07,460
kind of functionality but we wanna

1984
01:16:07,460 --> 01:16:10,800
mess with in this case with the control

1985
01:16:10,800 --> 01:16:13,560
flow with what is actually doing uh the

1986
01:16:13,560 --> 01:16:16,340
code so we can use

1987
01:16:16,340 --> 01:16:18,840
MBA transformation on this kind of

1988
01:16:18,840 --> 01:16:21,199
expression that we have seen to

1989
01:16:21,199 --> 01:16:23,520
obfuscate the control Flow by means of

1990
01:16:23,520 --> 01:16:26,699
producing OPAC predicates okay let me

1991
01:16:26,699 --> 01:16:29,460
explain in a minute it is but

1992
01:16:29,460 --> 01:16:32,760
essentially another predicate is a

1993
01:16:32,760 --> 01:16:34,080
conditional statement a conditional

1994
01:16:34,080 --> 01:16:36,679
expression that it is always

1995
01:16:36,679 --> 01:16:40,020
known to be either true or false so the

1996
01:16:40,020 --> 01:16:42,540
person doing the protection or putting

1997
01:16:42,540 --> 01:16:45,239
the code knows a priority that this

1998
01:16:45,239 --> 01:16:47,040
condition will always hold true or will

1999
01:16:47,040 --> 01:16:48,719
always hold false but it's not trivial

2000
01:16:48,719 --> 01:16:51,060
it's not Apparent at all and we can use

2001
01:16:51,060 --> 01:16:53,580
this to put essentially fake branches in

2002
01:16:53,580 --> 01:16:56,100
our code we can use fake branches on

2003
01:16:56,100 --> 01:16:57,840
conditions that they will always be sure

2004
01:16:57,840 --> 01:16:59,280
will always be false so some of the

2005
01:16:59,280 --> 01:17:02,760
branches will never be taken so this

2006
01:17:02,760 --> 01:17:05,100
will match the control Flow by means of

2007
01:17:05,100 --> 01:17:06,780
producing this kind of conditional

2008
01:17:06,780 --> 01:17:08,699
statements and we can build some of them

2009
01:17:08,699 --> 01:17:11,880
actually with mbas that we have seen

2010
01:17:11,880 --> 01:17:14,040
for example

2011
01:17:14,040 --> 01:17:16,199
we have here three different mbas

2012
01:17:16,199 --> 01:17:18,120
actually some of them are from the

2013
01:17:18,120 --> 01:17:20,400
examples that we have seen

2014
01:17:20,400 --> 01:17:22,679
so the first thing let me just put some

2015
01:17:22,679 --> 01:17:26,360
spacing here so it's easy

2016
01:17:26,400 --> 01:17:28,560
so the first thing I hit I have in here

2017
01:17:28,560 --> 01:17:30,719
is like okay this expression which is if

2018
01:17:30,719 --> 01:17:32,520
you remember the first reward rule for

2019
01:17:32,520 --> 01:17:33,719
the addition

2020
01:17:33,719 --> 01:17:36,960
is equivalent to this the second uh this

2021
01:17:36,960 --> 01:17:38,699
is what we obtain through the insertion

2022
01:17:38,699 --> 01:17:40,860
of identities to the addition example

2023
01:17:40,860 --> 01:17:42,420
for the first question so these two

2024
01:17:42,420 --> 01:17:44,640
actually are two different

2025
01:17:44,640 --> 01:17:46,380
representations of exactly the same

2026
01:17:46,380 --> 01:17:48,239
semantics which indeeda is the addition

2027
01:17:48,239 --> 01:17:50,820
of the two variables but we just have

2028
01:17:50,820 --> 01:17:52,739
that these two things are semantically

2029
01:17:52,739 --> 01:17:54,960
equivalent so if we make a branching of

2030
01:17:54,960 --> 01:17:57,659
uh comparing these two things we know

2031
01:17:57,659 --> 01:17:59,460
the outcome

2032
01:17:59,460 --> 01:18:01,199
it's not trivial at all but we know the

2033
01:18:01,199 --> 01:18:02,640
outcome of any branching any any

2034
01:18:02,640 --> 01:18:04,500
conditional statement involving these

2035
01:18:04,500 --> 01:18:05,640
two expressions because they are

2036
01:18:05,640 --> 01:18:08,640
equivalent okay same thing happens here

2037
01:18:08,640 --> 01:18:11,580
so uh this is an untrivial equal to zero

2038
01:18:11,580 --> 01:18:13,560
MB expression so if we do any kind of

2039
01:18:13,560 --> 01:18:17,280
conditional statement with this uh using

2040
01:18:17,280 --> 01:18:20,699
this nonlinear MBA expression we know a

2041
01:18:20,699 --> 01:18:23,060
priori what will be the outcome because

2042
01:18:23,060 --> 01:18:26,219
it's equal to zero so anything that we

2043
01:18:26,219 --> 01:18:27,840
compare it against which is not zero

2044
01:18:27,840 --> 01:18:30,600
would be always false okay and then we

2045
01:18:30,600 --> 01:18:32,580
have this actually the the OPAC constant

2046
01:18:32,580 --> 01:18:35,040
that we use this is the these are

2047
01:18:35,040 --> 01:18:36,960
another conditional statement that is

2048
01:18:36,960 --> 01:18:40,500
always true this okay this expression is

2049
01:18:40,500 --> 01:18:42,120
always one to three so any kind of

2050
01:18:42,120 --> 01:18:44,520
conditional statement that we build with

2051
01:18:44,520 --> 01:18:45,920
this knowledge

2052
01:18:45,920 --> 01:18:48,719
we will know this result its truth value

2053
01:18:48,719 --> 01:18:50,100
a priority

2054
01:18:50,100 --> 01:18:51,960
and we can actually build that

2055
01:18:51,960 --> 01:18:56,580
fairly simple I have here for example

2056
01:18:56,580 --> 01:18:58,380
from the first example I just construct

2057
01:18:58,380 --> 01:19:00,239
okay this expression

2058
01:19:00,239 --> 01:19:03,840
is greater than desired expression so

2059
01:19:03,840 --> 01:19:07,020
you have just an if statement of okay if

2060
01:19:07,020 --> 01:19:09,239
this expression is greater to this

2061
01:19:09,239 --> 01:19:10,800
expression like if the evaluation of

2062
01:19:10,800 --> 01:19:13,860
whatever the value that we get from X

2063
01:19:13,860 --> 01:19:15,840
plugging X and Y in this expression has

2064
01:19:15,840 --> 01:19:17,460
to be greater than plugging examinated

2065
01:19:17,460 --> 01:19:19,159
expression but remember that we know

2066
01:19:19,159 --> 01:19:21,239
that these two expressions are

2067
01:19:21,239 --> 01:19:22,620
semantically equivalent so this will

2068
01:19:22,620 --> 01:19:24,420
always be false

2069
01:19:24,420 --> 01:19:26,400
but the person analyzing the binary

2070
01:19:26,400 --> 01:19:27,719
resulting from that doesn't know it

2071
01:19:27,719 --> 01:19:29,820
that's the whole point

2072
01:19:29,820 --> 01:19:32,340
then we are checking for example the

2073
01:19:32,340 --> 01:19:36,060
second expression to be exactly equal uh

2074
01:19:36,060 --> 01:19:38,040
to error 0x17

2075
01:19:38,040 --> 01:19:41,280
but we know that this MBA expression is

2076
01:19:41,280 --> 01:19:43,620
non-trivial equal to zero so it will

2077
01:19:43,620 --> 01:19:45,659
never be

2078
01:19:45,659 --> 01:19:48,719
as ox17 so this Branch will never be

2079
01:19:48,719 --> 01:19:50,340
taken again

2080
01:19:50,340 --> 01:19:51,840
and

2081
01:19:51,840 --> 01:19:54,120
this is okay

2082
01:19:54,120 --> 01:19:57,739
the last one here

2083
01:19:58,920 --> 01:20:00,780
this is using the upper constant

2084
01:20:00,780 --> 01:20:02,219
construct you see that it's not always

2085
01:20:02,219 --> 01:20:04,260
that we can I use it to hide the

2086
01:20:04,260 --> 01:20:06,600
constants themselves but you can then

2087
01:20:06,600 --> 01:20:08,760
do smart things to use this kind of

2088
01:20:08,760 --> 01:20:10,260
knowledge this kind of instructions we

2089
01:20:10,260 --> 01:20:12,480
say okay this whole expression until

2090
01:20:12,480 --> 01:20:13,920
here

2091
01:20:13,920 --> 01:20:17,460
minus 57 because yes

2092
01:20:17,460 --> 01:20:20,280
it's my it's less than 100 so we have

2093
01:20:20,280 --> 01:20:22,199
that this whole expression before the

2094
01:20:22,199 --> 01:20:23,900
minus 57

2095
01:20:23,900 --> 01:20:27,380
is equal semantically equal to

2096
01:20:27,380 --> 01:20:31,679
123. so 123 minus 57 it's always less

2097
01:20:31,679 --> 01:20:34,860
than 100. so this conditional statement

2098
01:20:34,860 --> 01:20:36,840
is always true

2099
01:20:36,840 --> 01:20:38,760
regardless of the X and Y conditions

2100
01:20:38,760 --> 01:20:40,380
because we have constructed in a way

2101
01:20:40,380 --> 01:20:43,320
that we have a semantic meaning of 123

2102
01:20:43,320 --> 01:20:47,760
obfuscated minus 57 is less than 100 and

2103
01:20:47,760 --> 01:20:49,800
there's a fairly simple conditions

2104
01:20:49,800 --> 01:20:52,080
because this 57 could be another upper

2105
01:20:52,080 --> 01:20:53,880
constant construct the same for the 100

2106
01:20:53,880 --> 01:20:56,699
and we would we could have a lot of more

2107
01:20:56,699 --> 01:20:59,100
obfuscation going on a lot of iterative

2108
01:20:59,100 --> 01:21:00,600
rewrite rules okay

2109
01:21:00,600 --> 01:21:04,020
and then in this case okay we do the xor

2110
01:21:04,020 --> 01:21:06,480
which is the actual semantics of of the

2111
01:21:06,480 --> 01:21:07,800
code that we're trying to obfuscate and

2112
01:21:07,800 --> 01:21:10,500
else we just Z equals zero but this will

2113
01:21:10,500 --> 01:21:13,739
also never be taken because he we will

2114
01:21:13,739 --> 01:21:15,239
always go here

2115
01:21:15,239 --> 01:21:18,060
this code will always go to this line of

2116
01:21:18,060 --> 01:21:20,040
code it will never reach any other of

2117
01:21:20,040 --> 01:21:21,960
the branches because we have a pack

2118
01:21:21,960 --> 01:21:24,900
predicates that introduce fake branches

2119
01:21:24,900 --> 01:21:26,580
in the code essentially to mess around

2120
01:21:26,580 --> 01:21:29,159
the control flow okay

2121
01:21:29,159 --> 01:21:31,739
and again this is fairly simple and I

2122
01:21:31,739 --> 01:21:33,540
only targeted the control flow but you

2123
01:21:33,540 --> 01:21:35,520
could also obfuscate these Expressions

2124
01:21:35,520 --> 01:21:38,219
by themselves so even if you arrive here

2125
01:21:38,219 --> 01:21:39,780
then you might not see that this is an

2126
01:21:39,780 --> 01:21:41,280
xor because this is an xor that has been

2127
01:21:41,280 --> 01:21:43,140
obfuscated for example we are doing that

2128
01:21:43,140 --> 01:21:45,360
here we'll do it in the next in the next

2129
01:21:45,360 --> 01:21:46,440
example

2130
01:21:46,440 --> 01:21:47,580
okay

2131
01:21:47,580 --> 01:21:50,520
but let's take a look at the at the

2132
01:21:50,520 --> 01:21:52,440
assembly representation of that

2133
01:21:52,440 --> 01:21:55,759
I think I have it here

2134
01:21:57,060 --> 01:21:59,820
so now we go to the main

2135
01:21:59,820 --> 01:22:02,159
yeah

2136
01:22:02,159 --> 01:22:04,560
this is the

2137
01:22:04,560 --> 01:22:07,980
control photograph representation of it

2138
01:22:07,980 --> 01:22:09,060
so

2139
01:22:09,060 --> 01:22:11,340
before we just had a single basic blog

2140
01:22:11,340 --> 01:22:13,860
and now we have not a lot of that but a

2141
01:22:13,860 --> 01:22:15,060
little bit of branching you don't really

2142
01:22:15,060 --> 01:22:15,900
know

2143
01:22:15,900 --> 01:22:17,580
our first sight what is going on in

2144
01:22:17,580 --> 01:22:18,659
there and actually if you go to the

2145
01:22:18,659 --> 01:22:21,179
branching conditions for example now to

2146
01:22:21,179 --> 01:22:23,219
this Branch you see the coding here

2147
01:22:23,219 --> 01:22:25,440
okay uh

2148
01:22:25,440 --> 01:22:27,360
it's not clear what's happening we see

2149
01:22:27,360 --> 01:22:30,060
that the comparison with 0x17 and then

2150
01:22:30,060 --> 01:22:31,500
the branching condition depending on

2151
01:22:31,500 --> 01:22:34,620
that but we are comparing against 0x17

2152
01:22:34,620 --> 01:22:36,420
the result of all these computations

2153
01:22:36,420 --> 01:22:38,520
which is not clear at all what's

2154
01:22:38,520 --> 01:22:39,960
Happening Here

2155
01:22:39,960 --> 01:22:42,480
it is not clear at all that this is not

2156
01:22:42,480 --> 01:22:44,640
to this produce is a computation which

2157
01:22:44,640 --> 01:22:47,820
is not usually equal to zero Okay so

2158
01:22:47,820 --> 01:22:50,100
the same thing for the the other Branch

2159
01:22:50,100 --> 01:22:53,120
this actually goes even beyond that

2160
01:22:53,120 --> 01:22:56,219
there's a lot more code in that

2161
01:22:56,219 --> 01:22:58,860
and yeah for the rest one this is okay

2162
01:22:58,860 --> 01:23:00,300
we are at the last branch is the return

2163
01:23:00,300 --> 01:23:02,580
zero that we will never take this branch

2164
01:23:02,580 --> 01:23:06,600
because we only had we always had uh the

2165
01:23:06,600 --> 01:23:08,760
other the other Branch being taken which

2166
01:23:08,760 --> 01:23:10,739
is exactly this branch which is the only

2167
01:23:10,739 --> 01:23:12,960
one that will be taken always this all

2168
01:23:12,960 --> 01:23:15,000
brand will always be taken because all

2169
01:23:15,000 --> 01:23:16,080
the rest of the branches are fake

2170
01:23:16,080 --> 01:23:18,840
branches introduced by the OPAC predict

2171
01:23:18,840 --> 01:23:20,580
it's okay and this is well these are

2172
01:23:20,580 --> 01:23:22,860
just an xor very simple but we could

2173
01:23:22,860 --> 01:23:26,820
also obfuscate all the actual semantics

2174
01:23:26,820 --> 01:23:29,699
of the expression being executed

2175
01:23:29,699 --> 01:23:32,159
regardless of the opacity okay in this

2176
01:23:32,159 --> 01:23:34,080
case we just plugged into a pack

2177
01:23:34,080 --> 01:23:36,239
predicates to make it

2178
01:23:36,239 --> 01:23:38,699
a little bit more simple for the example

2179
01:23:38,699 --> 01:23:40,739
and again this is just three open

2180
01:23:40,739 --> 01:23:42,900
predicates but

2181
01:23:42,900 --> 01:23:44,760
there is malware around

2182
01:23:44,760 --> 01:23:47,159
uh that is using a lot of different

2183
01:23:47,159 --> 01:23:49,620
topic predicates to obfuscate a lot of

2184
01:23:49,620 --> 01:23:52,440
their their functions or components and

2185
01:23:52,440 --> 01:23:55,920
they can be extremely extremely big

2186
01:23:55,920 --> 01:23:57,480
control flow graphs these are very

2187
01:23:57,480 --> 01:23:58,860
simple control graph but you can imagine

2188
01:23:58,860 --> 01:24:01,860
a control graph of like thousands of

2189
01:24:01,860 --> 01:24:04,199
opaque predicates so it's kind of

2190
01:24:04,199 --> 01:24:06,659
impossible to to follow the the flow of

2191
01:24:06,659 --> 01:24:09,540
the code in an intuitive manner at all

2192
01:24:09,540 --> 01:24:11,760
okay this is just very simple from one

2193
01:24:11,760 --> 01:24:14,699
single basic block to a few branches but

2194
01:24:14,699 --> 01:24:17,580
you could do that as you could go you

2195
01:24:17,580 --> 01:24:20,600
could go as big as you wanted

2196
01:24:23,580 --> 01:24:24,900
okay

2197
01:24:24,900 --> 01:24:26,460
uh

2198
01:24:26,460 --> 01:24:30,060
let's see now a little bit of uh how can

2199
01:24:30,060 --> 01:24:32,400
we apply it to hard and even more

2200
01:24:32,400 --> 01:24:35,340
virtualization obfuscation and let me

2201
01:24:35,340 --> 01:24:36,480
walk you a little bit about

2202
01:24:36,480 --> 01:24:37,800
virtualization obfuscation in case

2203
01:24:37,800 --> 01:24:39,179
you're not familiar

2204
01:24:39,179 --> 01:24:42,780
but essentially

2205
01:24:42,780 --> 01:24:43,980
okay

2206
01:24:43,980 --> 01:24:45,719
imagine that

2207
01:24:45,719 --> 01:24:48,540
we have this

2208
01:24:48,540 --> 01:24:49,860
function

2209
01:24:49,860 --> 01:24:53,400
and we want to obfuscate it okay and now

2210
01:24:53,400 --> 01:24:55,500
we are not uh We're Not Gonna obfuscate

2211
01:24:55,500 --> 01:24:57,420
it now the expression itself we're gonna

2212
01:24:57,420 --> 01:24:59,219
build a virtual machine obfuscation for

2213
01:24:59,219 --> 01:25:01,679
that and then Harden the virtual machine

2214
01:25:01,679 --> 01:25:04,199
okay to see that we can really go to

2215
01:25:04,199 --> 01:25:06,840
state of the art obfuscation in that

2216
01:25:06,840 --> 01:25:10,020
what does it mean to uh what is exactly

2217
01:25:10,020 --> 01:25:12,120
virtual machine obfuscation you might be

2218
01:25:12,120 --> 01:25:15,360
familiar with things like VM protect or

2219
01:25:15,360 --> 01:25:18,239
themida or even Lenovo VM for video

2220
01:25:18,239 --> 01:25:20,540
games which are hard protection or

2221
01:25:20,540 --> 01:25:23,040
inferior heart protections

2222
01:25:23,040 --> 01:25:24,840
which essentially what they are doing is

2223
01:25:24,840 --> 01:25:27,480
transforming the code that once we

2224
01:25:27,480 --> 01:25:29,040
protect it all the code that they want

2225
01:25:29,040 --> 01:25:30,300
to protect or the function they want to

2226
01:25:30,300 --> 01:25:31,260
protect

2227
01:25:31,260 --> 01:25:35,040
into a custom made architecture into a

2228
01:25:35,040 --> 01:25:37,440
custom architecture totally made up

2229
01:25:37,440 --> 01:25:38,820
architecture

2230
01:25:38,820 --> 01:25:41,219
that they design that actually that can

2231
01:25:41,219 --> 01:25:43,440
be designed kind of dynamically and this

2232
01:25:43,440 --> 01:25:44,880
architecture is an architect of a

2233
01:25:44,880 --> 01:25:47,159
virtual machine of an abstract machine

2234
01:25:47,159 --> 01:25:48,960
totally made up

2235
01:25:48,960 --> 01:25:50,820
which has some of codes and some

2236
01:25:50,820 --> 01:25:53,600
instructions and works in a in any way

2237
01:25:53,600 --> 01:25:56,699
so what we do with virtualization based

2238
01:25:56,699 --> 01:26:00,000
obfuscation is we translate the function

2239
01:26:00,000 --> 01:26:02,219
or the code that we want to obfuscate

2240
01:26:02,219 --> 01:26:04,860
we translate it to the byte code to the

2241
01:26:04,860 --> 01:26:07,080
machine code of our abstract machine

2242
01:26:07,080 --> 01:26:09,840
that we have designed and then within

2243
01:26:09,840 --> 01:26:11,639
the code what we do is instead of

2244
01:26:11,639 --> 01:26:15,179
calling the the native function we call

2245
01:26:15,179 --> 01:26:18,179
an interpreter for our custom VM our

2246
01:26:18,179 --> 01:26:20,400
interpreter for our custom machine that

2247
01:26:20,400 --> 01:26:22,260
will parse the byte code the machine

2248
01:26:22,260 --> 01:26:24,179
code representing our code that we

2249
01:26:24,179 --> 01:26:26,100
wanted to obfuscate this might be a

2250
01:26:26,100 --> 01:26:28,139
little bit confusing but I will this is

2251
01:26:28,139 --> 01:26:30,060
this code you also have available and

2252
01:26:30,060 --> 01:26:32,219
it's a very simple VM implementation of

2253
01:26:32,219 --> 01:26:34,080
sketchum beam implementation and let's

2254
01:26:34,080 --> 01:26:37,080
walk through that so essentially in this

2255
01:26:37,080 --> 01:26:39,620
demo I want to obfuscate

2256
01:26:39,620 --> 01:26:43,500
this expression with a VM okay

2257
01:26:43,500 --> 01:26:44,940
so the first thing I will do is okay

2258
01:26:44,940 --> 01:26:46,679
let's just

2259
01:26:46,679 --> 01:26:48,120
ah

2260
01:26:48,120 --> 01:26:51,000
invent totally made up a custom

2261
01:26:51,000 --> 01:26:54,659
architecture with some operators uh so

2262
01:26:54,659 --> 01:26:56,639
we can translate this expression into

2263
01:26:56,639 --> 01:26:58,679
our virtual machine

2264
01:26:58,679 --> 01:27:00,420
so I did that

2265
01:27:00,420 --> 01:27:03,300
in here this is our virtual machine like

2266
01:27:03,300 --> 01:27:05,940
our interpreter for the virtual machine

2267
01:27:05,940 --> 01:27:07,560
which essentially the only thing that

2268
01:27:07,560 --> 01:27:09,420
you have to be addressing is that okay

2269
01:27:09,420 --> 01:27:13,020
I'm gonna Define that the op code a0

2270
01:27:13,020 --> 01:27:15,719
will be a push the op code b0 will be a

2271
01:27:15,719 --> 01:27:18,360
pop uh one zero addition to zero

2272
01:27:18,360 --> 01:27:19,800
subtraction three zero multiplication

2273
01:27:19,800 --> 01:27:23,600
for zero xor uh five zero and

2274
01:27:23,600 --> 01:27:27,179
uh yeah and the last one uh six zero or

2275
01:27:27,179 --> 01:27:29,639
so we will have these op codes these

2276
01:27:29,639 --> 01:27:31,920
instructions in our virtual machine okay

2277
01:27:31,920 --> 01:27:35,699
and then we Define we have made up we

2278
01:27:35,699 --> 01:27:37,080
have designed a virtual machine an

2279
01:27:37,080 --> 01:27:39,480
abstract machine with these op codes and

2280
01:27:39,480 --> 01:27:41,940
we want to transform our code

2281
01:27:41,940 --> 01:27:45,780
that we want to skate into bytecode into

2282
01:27:45,780 --> 01:27:47,580
actually machine instruction for our

2283
01:27:47,580 --> 01:27:50,100
abstract machine in this case here you

2284
01:27:50,100 --> 01:27:52,800
have a divide code representing the

2285
01:27:52,800 --> 01:27:54,960
function that we want to obfuscate

2286
01:27:54,960 --> 01:27:57,120
with all the comments so this is the

2287
01:27:57,120 --> 01:27:58,920
bytecode that represents

2288
01:27:58,920 --> 01:28:00,840
in our virtual machine which happens to

2289
01:28:00,840 --> 01:28:03,179
be a stack machine and the only thing

2290
01:28:03,179 --> 01:28:04,800
that that means is that we will have all

2291
01:28:04,800 --> 01:28:07,080
the operation going on in the stack

2292
01:28:07,080 --> 01:28:09,659
so we'll have push a value push a value

2293
01:28:09,659 --> 01:28:12,719
a little before this will be X then push

2294
01:28:12,719 --> 01:28:16,199
another value then addition push

2295
01:28:16,199 --> 01:28:20,639
uh variables variables and pushing

2296
01:28:20,639 --> 01:28:23,280
variables or xorbs to multiply and this

2297
01:28:23,280 --> 01:28:24,960
is exactly the semantic representation

2298
01:28:24,960 --> 01:28:27,900
of our function but with an rvm because

2299
01:28:27,900 --> 01:28:29,940
what it's doing that first of all we

2300
01:28:29,940 --> 01:28:33,300
push 4 we push X we push Y and the first

2301
01:28:33,300 --> 01:28:34,920
thing this is a stack machine remember

2302
01:28:34,920 --> 01:28:37,139
we are an addition okay what will do the

2303
01:28:37,139 --> 01:28:37,980
addition

2304
01:28:37,980 --> 01:28:40,860
instruction will pop the two previous

2305
01:28:40,860 --> 01:28:44,159
pushed values and add them together

2306
01:28:44,159 --> 01:28:46,739
see that this is exactly the first thing

2307
01:28:46,739 --> 01:28:48,960
that might happen from the inside out in

2308
01:28:48,960 --> 01:28:50,880
here

2309
01:28:50,880 --> 01:28:52,620
we are evaluating from the inside out

2310
01:28:52,620 --> 01:28:54,480
from in here from the parenthesis

2311
01:28:54,480 --> 01:28:58,560
actually I have putting here the postfix

2312
01:28:58,560 --> 01:29:00,960
representation which is the native uh

2313
01:29:00,960 --> 01:29:02,880
representation for a stack if you want

2314
01:29:02,880 --> 01:29:04,380
to think that way it is just the

2315
01:29:04,380 --> 01:29:06,840
notation for the reverse police notation

2316
01:29:06,840 --> 01:29:10,199
stack notation uh postfix notation

2317
01:29:10,199 --> 01:29:12,360
however you want to call it

2318
01:29:12,360 --> 01:29:15,420
so this is just pushing variables and

2319
01:29:15,420 --> 01:29:18,980
then every time we have an instruction

2320
01:29:18,980 --> 01:29:22,620
then we pop the two previous values and

2321
01:29:22,620 --> 01:29:24,900
apply the the instruction

2322
01:29:24,900 --> 01:29:27,239
so then

2323
01:29:27,239 --> 01:29:30,060
our the byte code representing the

2324
01:29:30,060 --> 01:29:32,159
instructions for our the expression that

2325
01:29:32,159 --> 01:29:34,380
we want to obfuscate in our totally made

2326
01:29:34,380 --> 01:29:37,199
up virtual machine is this bytecode so

2327
01:29:37,199 --> 01:29:39,840
this is our machine code for our custom

2328
01:29:39,840 --> 01:29:43,139
made uh virtual machine

2329
01:29:43,139 --> 01:29:45,360
that will execute it

2330
01:29:45,360 --> 01:29:48,060
so what do we do instead of calling our

2331
01:29:48,060 --> 01:29:49,800
function in the native architecture is

2332
01:29:49,800 --> 01:29:51,300
we will call

2333
01:29:51,300 --> 01:29:54,540
an interpreter for this uh for this

2334
01:29:54,540 --> 01:29:56,880
virtual machine passing as an argument

2335
01:29:56,880 --> 01:29:58,739
or a byte code so we will call an

2336
01:29:58,739 --> 01:30:00,780
interpreter Hall of orbital machine that

2337
01:30:00,780 --> 01:30:03,000
will interpret the bytecode that

2338
01:30:03,000 --> 01:30:05,520
represents uh the expression that we

2339
01:30:05,520 --> 01:30:06,659
want to obfuscate in this virtual

2340
01:30:06,659 --> 01:30:09,000
machine and The Interpreter is just a

2341
01:30:09,000 --> 01:30:10,679
loop with a switch case

2342
01:30:10,679 --> 01:30:13,139
nothing more fancy than that we have it

2343
01:30:13,139 --> 01:30:16,679
in here this is just some syntax sugar

2344
01:30:16,679 --> 01:30:19,440
to see where am I traversing the

2345
01:30:19,440 --> 01:30:20,699
bytecode array

2346
01:30:20,699 --> 01:30:24,719
and then well let's just get the current

2347
01:30:24,719 --> 01:30:26,699
bicode instruction let's make a switch

2348
01:30:26,699 --> 01:30:28,980
for the core instruction if it is an a0

2349
01:30:28,980 --> 01:30:31,380
then it is a push otherwise this is a

2350
01:30:31,380 --> 01:30:33,960
pop otherwise it's an ad is a shop and

2351
01:30:33,960 --> 01:30:35,580
all these functions are implemented in

2352
01:30:35,580 --> 01:30:36,960
here

2353
01:30:36,960 --> 01:30:39,560
okay

2354
01:30:40,340 --> 01:30:42,960
uh we have push and pop which are kind

2355
01:30:42,960 --> 01:30:44,840
of special in this sense

2356
01:30:44,840 --> 01:30:47,639
we have a stack

2357
01:30:47,639 --> 01:30:50,400
and then for example uh with addition

2358
01:30:50,400 --> 01:30:51,960
the only thing that does is okay I'm

2359
01:30:51,960 --> 01:30:54,480
gonna pop from the stack the uh the

2360
01:30:54,480 --> 01:30:57,120
operands the result will be applying an

2361
01:30:57,120 --> 01:30:58,739
addition to the two operands and then

2362
01:30:58,739 --> 01:31:01,080
pushing the result back to the stack and

2363
01:31:01,080 --> 01:31:01,920
this is the same for all the

2364
01:31:01,920 --> 01:31:04,440
instructions okay

2365
01:31:04,440 --> 01:31:06,540
this is how we built a very very basic

2366
01:31:06,540 --> 01:31:08,340
virtual machine obfuscation why because

2367
01:31:08,340 --> 01:31:09,420
now

2368
01:31:09,420 --> 01:31:11,820
our code won't be this expression being

2369
01:31:11,820 --> 01:31:15,900
evaluated in x64 it will be

2370
01:31:15,900 --> 01:31:17,639
an interpreter

2371
01:31:17,639 --> 01:31:20,699
interpreting some byte code of a totally

2372
01:31:20,699 --> 01:31:23,880
made up instruction set

2373
01:31:23,880 --> 01:31:25,020
okay

2374
01:31:25,020 --> 01:31:27,719
uh disclosure will be the aggression of

2375
01:31:27,719 --> 01:31:30,600
the virtual machines and you have

2376
01:31:30,600 --> 01:31:32,900
are still a bit confused about VMS don't

2377
01:31:32,900 --> 01:31:34,980
don't worry about it because what we

2378
01:31:34,980 --> 01:31:37,980
will do with mbas uh is just

2379
01:31:37,980 --> 01:31:40,920
making the VMS way harder to to

2380
01:31:40,920 --> 01:31:44,400
understand to analyze so what does this

2381
01:31:44,400 --> 01:31:46,500
look like in assembly

2382
01:31:46,500 --> 01:31:48,179
uh

2383
01:31:48,179 --> 01:31:54,120
so let me go straight to The Interpreter

2384
01:31:57,719 --> 01:32:00,199
okay

2385
01:32:00,600 --> 01:32:02,880
this is The Interpreter okay the control

2386
01:32:02,880 --> 01:32:04,980
flow graph of The Interpreter

2387
01:32:04,980 --> 01:32:06,840
let's just see a little bit of code to

2388
01:32:06,840 --> 01:32:11,820
make it somewhat more digestible uh

2389
01:32:11,820 --> 01:32:14,940
not here here for example

2390
01:32:14,940 --> 01:32:17,280
here okay

2391
01:32:17,280 --> 01:32:18,900
the first thing that's happening in The

2392
01:32:18,900 --> 01:32:20,760
Interpreter is

2393
01:32:20,760 --> 01:32:21,670
uh

2394
01:32:21,670 --> 01:32:24,000
[Music]

2395
01:32:24,000 --> 01:32:26,100
we are comparing

2396
01:32:26,100 --> 01:32:28,199
essentially this is the instruction for

2397
01:32:28,199 --> 01:32:29,880
the bytecode okay

2398
01:32:29,880 --> 01:32:31,620
you don't really have to care about

2399
01:32:31,620 --> 01:32:33,300
these details but what is interesting to

2400
01:32:33,300 --> 01:32:36,659
see is this set of comparisons

2401
01:32:36,659 --> 01:32:38,760
we are just comparing some variable

2402
01:32:38,760 --> 01:32:40,620
which in this case is the current uh

2403
01:32:40,620 --> 01:32:43,500
byte of our byte code with a value

2404
01:32:43,500 --> 01:32:46,139
and if this value is okay then we will

2405
01:32:46,139 --> 01:32:49,620
go here in this case this value b0 is

2406
01:32:49,620 --> 01:32:51,659
the opcode of our bytecode representing

2407
01:32:51,659 --> 01:32:52,980
the pop instruction

2408
01:32:52,980 --> 01:32:56,460
so we go here and I left the push and

2409
01:32:56,460 --> 01:32:59,040
pop calls to be explicit calls to make

2410
01:32:59,040 --> 01:33:00,840
it a little bit easier to follow but

2411
01:33:00,840 --> 01:33:03,860
they could be also in mind

2412
01:33:03,900 --> 01:33:05,880
then okay

2413
01:33:05,880 --> 01:33:09,420
uh let's just keep uh push and pop and

2414
01:33:09,420 --> 01:33:10,679
I'm interested for example on this one

2415
01:33:10,679 --> 01:33:12,600
this one is interesting

2416
01:33:12,600 --> 01:33:14,040
so

2417
01:33:14,040 --> 01:33:17,940
compare the current uh bytecode with

2418
01:33:17,940 --> 01:33:20,880
hero x60 this is the switch this is the

2419
01:33:20,880 --> 01:33:23,400
switch implementation that we saw so

2420
01:33:23,400 --> 01:33:27,120
if it's 0x60 then we'll go here which

2421
01:33:27,120 --> 01:33:30,360
will essentially as we discussed pop the

2422
01:33:30,360 --> 01:33:32,639
two values from a stack and then apply

2423
01:33:32,639 --> 01:33:34,739
this order this is usually disorder this

2424
01:33:34,739 --> 01:33:36,900
is the semantics of this Handler this is

2425
01:33:36,900 --> 01:33:38,580
called a virtual machine Handler okay

2426
01:33:38,580 --> 01:33:40,380
this is the semantics of this

2427
01:33:40,380 --> 01:33:42,360
instruction of the virtual machine

2428
01:33:42,360 --> 01:33:45,420
and even if it seems super cumbersome

2429
01:33:45,420 --> 01:33:49,199
we can quite easily I would say analyze

2430
01:33:49,199 --> 01:33:51,060
such a virtual machine by means of just

2431
01:33:51,060 --> 01:33:53,760
locating the bytecode seeing where the

2432
01:33:53,760 --> 01:33:56,219
instruction of the bycode goes and

2433
01:33:56,219 --> 01:33:58,080
observing what is the semantics what is

2434
01:33:58,080 --> 01:33:59,820
the behavior of its barcode so we could

2435
01:33:59,820 --> 01:34:03,199
say okay for this as ox60

2436
01:34:03,199 --> 01:34:06,000
represents the or operation and we can

2437
01:34:06,000 --> 01:34:08,219
see the same happening for a lot of the

2438
01:34:08,219 --> 01:34:09,480
different

2439
01:34:09,480 --> 01:34:13,020
once for ox 50 we have the same popping

2440
01:34:13,020 --> 01:34:15,540
the two value from stock and we have an

2441
01:34:15,540 --> 01:34:17,100
and operation

2442
01:34:17,100 --> 01:34:19,080
okay

2443
01:34:19,080 --> 01:34:22,980
so in this case it's fairly simple uh

2444
01:34:22,980 --> 01:34:24,600
to actually

2445
01:34:24,600 --> 01:34:26,639
build a

2446
01:34:26,639 --> 01:34:29,280
kind of with some

2447
01:34:29,280 --> 01:34:31,440
scripting here with either python with

2448
01:34:31,440 --> 01:34:33,120
auto pipe with whatever you want just

2449
01:34:33,120 --> 01:34:35,340
Traverse this

2450
01:34:35,340 --> 01:34:39,000
hook each comparison check what is the

2451
01:34:39,000 --> 01:34:41,639
value of the bike a bit compared go to

2452
01:34:41,639 --> 01:34:44,100
the tools branch and check what is this

2453
01:34:44,100 --> 01:34:46,260
instruction after the Pops that is being

2454
01:34:46,260 --> 01:34:49,260
executed so we would say okay 0x40 is an

2455
01:34:49,260 --> 01:34:53,699
xor 0x50 is an and 0x60 is an or so we

2456
01:34:53,699 --> 01:34:54,960
could construct our kind of phone

2457
01:34:54,960 --> 01:34:57,840
disassembler for our uh for our virtual

2458
01:34:57,840 --> 01:35:00,179
machine and this roughly the way that we

2459
01:35:00,179 --> 01:35:02,219
can analyze virtual machine office

2460
01:35:02,219 --> 01:35:03,900
credit code

2461
01:35:03,900 --> 01:35:06,060
so what I wanted to talk about virtual

2462
01:35:06,060 --> 01:35:07,800
machines and not because I I like them

2463
01:35:07,800 --> 01:35:11,580
that I do but these are very very verbum

2464
01:35:11,580 --> 01:35:15,179
design of a virtual machine where it's

2465
01:35:15,179 --> 01:35:18,060
very easy Once you have abstracted

2466
01:35:18,060 --> 01:35:19,739
everything from the virtual machine it's

2467
01:35:19,739 --> 01:35:24,120
very easy to see okay this 0x40

2468
01:35:24,120 --> 01:35:27,480
is related to the semantics of an xor so

2469
01:35:27,480 --> 01:35:30,780
the 0x40 op code of the instruction of

2470
01:35:30,780 --> 01:35:33,300
the virtual machine that I memorizing

2471
01:35:33,300 --> 01:35:35,880
actually represents the xor so you can

2472
01:35:35,880 --> 01:35:38,520
actually build this kind of mapping

2473
01:35:38,520 --> 01:35:40,020
between the up codes and the an

2474
01:35:40,020 --> 01:35:42,480
instruction and then reconstruct the

2475
01:35:42,480 --> 01:35:44,580
behavior of the virtual machine and

2476
01:35:44,580 --> 01:35:46,139
essentially get back

2477
01:35:46,139 --> 01:35:49,080
what is the uh the semantics that are

2478
01:35:49,080 --> 01:35:50,219
destroyed describing what is the

2479
01:35:50,219 --> 01:35:51,420
behavior of the code that is being

2480
01:35:51,420 --> 01:35:53,219
utilized that is being protected with

2481
01:35:53,219 --> 01:35:55,920
this kind of virtualization okay

2482
01:35:55,920 --> 01:35:58,500
but what happens and here mbas play a

2483
01:35:58,500 --> 01:35:59,940
role and

2484
01:35:59,940 --> 01:36:02,520
solar protection mechanisms are starting

2485
01:36:02,520 --> 01:36:04,199
to

2486
01:36:04,199 --> 01:36:06,600
play with these things a lot a lot more

2487
01:36:06,600 --> 01:36:09,540
and more which is yeah but what if we

2488
01:36:09,540 --> 01:36:11,820
had kind of the same construction but

2489
01:36:11,820 --> 01:36:14,040
here we don't know what's happening here

2490
01:36:14,040 --> 01:36:17,159
this xor or design is not clear at all

2491
01:36:17,159 --> 01:36:18,900
what's happening because here is Crystal

2492
01:36:18,900 --> 01:36:21,659
Clear once we see this branching we see

2493
01:36:21,659 --> 01:36:23,460
what is the op code being compared and

2494
01:36:23,460 --> 01:36:25,159
we see then exactly what is the

2495
01:36:25,159 --> 01:36:27,300
operation being performed by the

2496
01:36:27,300 --> 01:36:30,120
extraction but can we obfuscate this

2497
01:36:30,120 --> 01:36:33,900
extraction so can we actually obfuscate

2498
01:36:33,900 --> 01:36:35,880
beyond the virtual machine obfuscation

2499
01:36:35,880 --> 01:36:36,900
itself

2500
01:36:36,900 --> 01:36:40,620
we can also obfuscate the semantics of

2501
01:36:40,620 --> 01:36:42,420
each instruction of our custom virtual

2502
01:36:42,420 --> 01:36:43,980
machine

2503
01:36:43,980 --> 01:36:45,780
so it's even more complicated to reason

2504
01:36:45,780 --> 01:36:47,580
about it because even if we understand

2505
01:36:47,580 --> 01:36:49,020
that we have a virtual machine that is

2506
01:36:49,020 --> 01:36:51,120
doing something we have some handlers

2507
01:36:51,120 --> 01:36:52,800
some instructions for a virtual machine

2508
01:36:52,800 --> 01:36:55,560
then we need to understand what each

2509
01:36:55,560 --> 01:36:57,360
hander is doing what are the semantics

2510
01:36:57,360 --> 01:36:58,800
of each of the handlers each of the

2511
01:36:58,800 --> 01:37:00,600
virtual machine instructions so we can

2512
01:37:00,600 --> 01:37:02,820
reconstruct the behavior of the

2513
01:37:02,820 --> 01:37:04,320
obfuscated code

2514
01:37:04,320 --> 01:37:06,480
and in this case it's very simple to do

2515
01:37:06,480 --> 01:37:09,239
because we have it like in clear the

2516
01:37:09,239 --> 01:37:13,139
instructions pop up uh at first sight so

2517
01:37:13,139 --> 01:37:15,719
again this is uh the xor we have a lot

2518
01:37:15,719 --> 01:37:18,300
more here for the srx30

2519
01:37:18,300 --> 01:37:21,900
this is a multiplication

2520
01:37:21,900 --> 01:37:25,320
and so on and so forth for the 0x10 this

2521
01:37:25,320 --> 01:37:27,480
is just an addition

2522
01:37:27,480 --> 01:37:29,340
just popping into values and applying

2523
01:37:29,340 --> 01:37:30,300
the

2524
01:37:30,300 --> 01:37:33,000
the thing so we Could reconstruct kind

2525
01:37:33,000 --> 01:37:34,860
of a disassembler for our virtual

2526
01:37:34,860 --> 01:37:37,500
machine because we have understood very

2527
01:37:37,500 --> 01:37:42,260
very clearly what each of the op code uh

2528
01:37:42,260 --> 01:37:44,639
maps in terms of instruction in

2529
01:37:44,639 --> 01:37:45,900
thermosomatics

2530
01:37:45,900 --> 01:37:48,900
so what can we do with mbas make it even

2531
01:37:48,900 --> 01:37:50,159
more complicated

2532
01:37:50,159 --> 01:37:52,980
by means of not making it obvious or not

2533
01:37:52,980 --> 01:37:54,840
making it easy to understand the

2534
01:37:54,840 --> 01:37:57,420
semantics of each VM Hunter of each

2535
01:37:57,420 --> 01:37:59,820
Hunter of the virtual machine

2536
01:37:59,820 --> 01:38:02,400
how do we do that well I have here some

2537
01:38:02,400 --> 01:38:03,780
reward rules

2538
01:38:03,780 --> 01:38:06,120
uh these are the right rules for the

2539
01:38:06,120 --> 01:38:09,120
addition this means that op one plus Op

2540
01:38:09,120 --> 01:38:10,980
2 is semantically equivalent to this

2541
01:38:10,980 --> 01:38:12,800
other expression

2542
01:38:12,800 --> 01:38:16,020
uh of 1 minus of two is semantically

2543
01:38:16,020 --> 01:38:17,400
equivalent to this other expression the

2544
01:38:17,400 --> 01:38:20,040
same for multiplication xor and a door

2545
01:38:20,040 --> 01:38:21,420
okay

2546
01:38:21,420 --> 01:38:24,080
again those are fairly simple

2547
01:38:24,080 --> 01:38:27,239
obfuscation Expressions I'm using kind

2548
01:38:27,239 --> 01:38:29,820
of simple and small one uh for the sake

2549
01:38:29,820 --> 01:38:32,699
of well putting them kind of nicely in

2550
01:38:32,699 --> 01:38:34,800
the screen and making it not so

2551
01:38:34,800 --> 01:38:36,300
terrifying but these Expressions could

2552
01:38:36,300 --> 01:38:38,639
be as long and as complicated as you

2553
01:38:38,639 --> 01:38:40,199
want it and you can generate them

2554
01:38:40,199 --> 01:38:43,199
arbitrarily complex and arbitrary along

2555
01:38:43,199 --> 01:38:45,300
and then he will go into our discussion

2556
01:38:45,300 --> 01:38:48,000
if you want that usually when you're

2557
01:38:48,000 --> 01:38:49,320
protecting software there is some kind

2558
01:38:49,320 --> 01:38:51,420
of compromise between how many Computing

2559
01:38:51,420 --> 01:38:53,760
Cycles are you allowed to waste on some

2560
01:38:53,760 --> 01:38:57,000
functions for obfuscation uh so how far

2561
01:38:57,000 --> 01:38:59,159
can you go in obfuscation within the

2562
01:38:59,159 --> 01:39:00,960
constraints the performance constraints

2563
01:39:00,960 --> 01:39:02,040
that you might have but this is another

2564
01:39:02,040 --> 01:39:04,380
discussion from the only this the point

2565
01:39:04,380 --> 01:39:06,780
of view of how big can you go in a first

2566
01:39:06,780 --> 01:39:08,580
question with MDA transformation you can

2567
01:39:08,580 --> 01:39:10,500
go as big as you want because you can

2568
01:39:10,500 --> 01:39:12,060
just keep applying right rules

2569
01:39:12,060 --> 01:39:14,580
iteratively and the functionalities and

2570
01:39:14,580 --> 01:39:16,020
you can just make it bigger bigger

2571
01:39:16,020 --> 01:39:17,639
bigger bigger and bigger

2572
01:39:17,639 --> 01:39:19,980
until you want to stop

2573
01:39:19,980 --> 01:39:23,780
okay so anyway I have generated

2574
01:39:23,780 --> 01:39:26,820
these expressions

2575
01:39:26,820 --> 01:39:30,179
and well let's just take a look at what

2576
01:39:30,179 --> 01:39:31,139
the

2577
01:39:31,139 --> 01:39:32,880
what the virtual machine in this case

2578
01:39:32,880 --> 01:39:35,760
might look like and the only thing I did

2579
01:39:35,760 --> 01:39:39,000
in this code is everything is exactly

2580
01:39:39,000 --> 01:39:40,739
the same but

2581
01:39:40,739 --> 01:39:43,080
for the the functions that Define the

2582
01:39:43,080 --> 01:39:46,020
semantics of each Handler of Tia of its

2583
01:39:46,020 --> 01:39:48,179
op code the functions which are the VM

2584
01:39:48,179 --> 01:39:49,739
handlers that Define the semantics of

2585
01:39:49,739 --> 01:39:51,060
each opcode which means the function

2586
01:39:51,060 --> 01:39:53,520
that defines uh well again push and pop

2587
01:39:53,520 --> 01:39:56,040
a little bit as is so it's easier to

2588
01:39:56,040 --> 01:39:57,960
follow uh

2589
01:39:57,960 --> 01:40:00,900
but for the addition subtraction a

2590
01:40:00,900 --> 01:40:02,880
multiplication xor and the different

2591
01:40:02,880 --> 01:40:04,139
instructions

2592
01:40:04,139 --> 01:40:07,920
these functions instead of having simply

2593
01:40:07,920 --> 01:40:10,920
as we had here okay popping the values

2594
01:40:10,920 --> 01:40:12,120
and then

2595
01:40:12,120 --> 01:40:15,480
doing the result straight away

2596
01:40:15,480 --> 01:40:18,000
I just put uh

2597
01:40:18,000 --> 01:40:19,920
MBA Transformations that obfuscate that

2598
01:40:19,920 --> 01:40:23,460
so in this case so see that the addition

2599
01:40:23,460 --> 01:40:25,320
now is

2600
01:40:25,320 --> 01:40:27,360
this set of operations

2601
01:40:27,360 --> 01:40:29,580
the subtraction is this other the

2602
01:40:29,580 --> 01:40:31,380
multiplication and so on and so forth

2603
01:40:31,380 --> 01:40:33,060
for the rest of them

2604
01:40:33,060 --> 01:40:34,440
okay

2605
01:40:34,440 --> 01:40:37,560
so we can now take a look

2606
01:40:37,560 --> 01:40:39,239
at the

2607
01:40:39,239 --> 01:40:42,500
at the Assembly of that

2608
01:40:42,780 --> 01:40:47,940
and observe that now it's not that easy

2609
01:40:47,940 --> 01:40:50,599
no not me

2610
01:40:51,719 --> 01:40:55,340
let's go directly to The Interpreter

2611
01:40:57,000 --> 01:40:59,219
and now

2612
01:40:59,219 --> 01:41:02,100
we we see the up codes

2613
01:41:02,100 --> 01:41:05,159
for example here the 60 remember then

2614
01:41:05,159 --> 01:41:06,060
here

2615
01:41:06,060 --> 01:41:08,760
we have the two pops

2616
01:41:08,760 --> 01:41:10,739
the first poppies are about and then

2617
01:41:10,739 --> 01:41:12,360
here and then we have something in here

2618
01:41:12,360 --> 01:41:14,460
which is not clear what's happening so

2619
01:41:14,460 --> 01:41:16,739
we cannot build a

2620
01:41:16,739 --> 01:41:19,080
kind of easy disassembler in this sense

2621
01:41:19,080 --> 01:41:21,239
for any of the instructions let's see

2622
01:41:21,239 --> 01:41:22,500
some more

2623
01:41:22,500 --> 01:41:24,600
uh here for example we are comparing

2624
01:41:24,600 --> 01:41:25,320
with

2625
01:41:25,320 --> 01:41:26,639
50

2626
01:41:26,639 --> 01:41:29,100
again so we can say okay I have the 50

2627
01:41:29,100 --> 01:41:31,500
let's see what is the semantic what is

2628
01:41:31,500 --> 01:41:32,699
the instruction that isn't called in

2629
01:41:32,699 --> 01:41:35,280
this virtual machine we don't know

2630
01:41:35,280 --> 01:41:36,659
you don't know from here what's

2631
01:41:36,659 --> 01:41:39,000
happening because there are notification

2632
01:41:39,000 --> 01:41:40,380
transformation and MBA transformation

2633
01:41:40,380 --> 01:41:42,780
that obfuscates the semantics of the

2634
01:41:42,780 --> 01:41:45,480
original VM Handler office credit code

2635
01:41:45,480 --> 01:41:48,119
okay I know this VM example can be a

2636
01:41:48,119 --> 01:41:50,820
little bit tedious and hard if you have

2637
01:41:50,820 --> 01:41:53,219
no exposure at all to VMS but what I

2638
01:41:53,219 --> 01:41:54,960
wanted to introduce that

2639
01:41:54,960 --> 01:41:57,900
we can use MBA transformation uh to

2640
01:41:57,900 --> 01:41:59,880
harden even the kind of the most

2641
01:41:59,880 --> 01:42:02,040
Advanced Techniques even if this VM is

2642
01:42:02,040 --> 01:42:05,159
very uh Toy VM for the sake of the demos

2643
01:42:05,159 --> 01:42:08,280
but any commercial VM protection the the

2644
01:42:08,280 --> 01:42:12,119
basic idea is the same build a custom VM

2645
01:42:12,119 --> 01:42:14,460
transform the code that you wanna you

2646
01:42:14,460 --> 01:42:16,260
wanna protect into bytecode of this

2647
01:42:16,260 --> 01:42:18,600
custom VM and then run it with The

2648
01:42:18,600 --> 01:42:20,940
Interpreter of this custom VM

2649
01:42:20,940 --> 01:42:24,179
but we can obfuscate a lot uh the

2650
01:42:24,179 --> 01:42:25,860
possibilities of kind of quickly

2651
01:42:25,860 --> 01:42:28,320
understanding what each of the byte code

2652
01:42:28,320 --> 01:42:31,380
op codes uh translates to in terms of

2653
01:42:31,380 --> 01:42:33,840
semantics by means of obfuscating the

2654
01:42:33,840 --> 01:42:36,119
semantics of the of course of the

2655
01:42:36,119 --> 01:42:37,320
Handler themselves for each of

2656
01:42:37,320 --> 01:42:41,000
instructions of the VM okay

2657
01:42:41,179 --> 01:42:44,219
uh yeah I think that's

2658
01:42:44,219 --> 01:42:45,840
kind of

2659
01:42:45,840 --> 01:42:48,960
everything for the vmos we have some

2660
01:42:48,960 --> 01:42:51,060
time but let me just give some words

2661
01:42:51,060 --> 01:42:53,420
before

2662
01:42:53,639 --> 01:42:56,219
so you might be thinking yeah all that

2663
01:42:56,219 --> 01:42:58,739
is super nice but uh well how the hell

2664
01:42:58,739 --> 01:43:00,239
do you generate all the things that we

2665
01:43:00,239 --> 01:43:01,080
need

2666
01:43:01,080 --> 01:43:03,600
okay so we

2667
01:43:03,600 --> 01:43:05,940
uh like what would come next would be

2668
01:43:05,940 --> 01:43:09,119
well learning methods to get the tools

2669
01:43:09,119 --> 01:43:10,440
that you need to generate this kind of

2670
01:43:10,440 --> 01:43:11,940
transformation so for example we need

2671
01:43:11,940 --> 01:43:14,159
methods to generate non-trivial equal to

2672
01:43:14,159 --> 01:43:16,260
0mb expression so I have given you a

2673
01:43:16,260 --> 01:43:19,139
couple of them on the slides on the on

2674
01:43:19,139 --> 01:43:22,080
the the code but you might want to

2675
01:43:22,080 --> 01:43:23,639
generate your own non-trivial equal to

2676
01:43:23,639 --> 01:43:25,320
Germany expression so you can play with

2677
01:43:25,320 --> 01:43:26,760
them

2678
01:43:26,760 --> 01:43:29,699
also linear MBR write rules and I say

2679
01:43:29,699 --> 01:43:30,900
linear because

2680
01:43:30,900 --> 01:43:33,420
well the method that we know to generate

2681
01:43:33,420 --> 01:43:35,159
rewrite rules essentially generates

2682
01:43:35,159 --> 01:43:36,719
linear and behavioral right rules which

2683
01:43:36,719 --> 01:43:39,600
then we can make non-linear by applying

2684
01:43:39,600 --> 01:43:41,460
identities or functions as we've seen

2685
01:43:41,460 --> 01:43:45,780
but the method itself is just linear

2686
01:43:45,780 --> 01:43:48,719
we won't go over it uh right here but

2687
01:43:48,719 --> 01:43:50,820
there is published material and I have

2688
01:43:50,820 --> 01:43:52,980
reference for that and you can ask me

2689
01:43:52,980 --> 01:43:56,940
without any problem after the conference

2690
01:43:56,940 --> 01:43:58,560
mainly because that would be like an

2691
01:43:58,560 --> 01:44:01,380
entire day discussing these methods okay

2692
01:44:01,380 --> 01:44:03,840
but just to give you some ideas

2693
01:44:03,840 --> 01:44:06,480
we have a method to generate non-trivial

2694
01:44:06,480 --> 01:44:08,040
equal to zero Expressions we construct

2695
01:44:08,040 --> 01:44:10,800
some matrices do some computations solve

2696
01:44:10,800 --> 01:44:12,300
some systems of equations and we

2697
01:44:12,300 --> 01:44:14,460
generate this non-trivial equal to 0mb

2698
01:44:14,460 --> 01:44:17,340
expressions and then from that we have

2699
01:44:17,340 --> 01:44:20,280
linear MBA we write rules for free

2700
01:44:20,280 --> 01:44:22,619
because the only thing that we do now is

2701
01:44:22,619 --> 01:44:24,420
okay we have an untrivial equal to zero

2702
01:44:24,420 --> 01:44:27,300
MB expression let's just move things

2703
01:44:27,300 --> 01:44:30,300
around around the equality to generate

2704
01:44:30,300 --> 01:44:33,000
rewrite rules for example let me get

2705
01:44:33,000 --> 01:44:36,920
back a little bit and explain you that

2706
01:44:36,920 --> 01:44:39,179
with I think

2707
01:44:39,179 --> 01:44:41,219
come on this

2708
01:44:41,219 --> 01:44:44,400
here for example we could have

2709
01:44:44,400 --> 01:44:46,199
a REV we could generate from this

2710
01:44:46,199 --> 01:44:48,480
non-trivial equal to zero MB expression

2711
01:44:48,480 --> 01:44:50,940
we could generate a rewrite rule for the

2712
01:44:50,940 --> 01:44:52,739
xor for example

2713
01:44:52,739 --> 01:44:56,280
you could put xor like move it around

2714
01:44:56,280 --> 01:44:58,679
changing the sign and then x-axis or Y

2715
01:44:58,679 --> 01:45:01,080
would be this thing

2716
01:45:01,080 --> 01:45:03,119
I will write rule for x xor and

2717
01:45:03,119 --> 01:45:05,580
similarly for x minus y you could move

2718
01:45:05,580 --> 01:45:07,320
everything else changing the sign to the

2719
01:45:07,320 --> 01:45:08,820
other side and get a rewrite rule for

2720
01:45:08,820 --> 01:45:11,280
the subtraction so once you know to

2721
01:45:11,280 --> 01:45:13,500
generate a non-trivial equal to zero and

2722
01:45:13,500 --> 01:45:16,440
be Expressions then rewrite rules Come

2723
01:45:16,440 --> 01:45:19,320
kind of for free okay

2724
01:45:19,320 --> 01:45:23,100
let's get back to what we get here

2725
01:45:23,100 --> 01:45:24,900
so these two things we have a method to

2726
01:45:24,900 --> 01:45:27,420
generate this uh in all the reference

2727
01:45:27,420 --> 01:45:29,159
that I will point you you have this

2728
01:45:29,159 --> 01:45:30,960
method uh it may be a little bit

2729
01:45:30,960 --> 01:45:32,760
complicated to understand

2730
01:45:32,760 --> 01:45:35,940
or to program I have code for that which

2731
01:45:35,940 --> 01:45:37,980
is not public but if you can ask nicely

2732
01:45:37,980 --> 01:45:39,840
I can share it

2733
01:45:39,840 --> 01:45:43,560
and then and we would also be interested

2734
01:45:43,560 --> 01:45:46,320
in generating well both uh pairs of a

2735
01:45:46,320 --> 01:45:48,119
fine functions in general in particular

2736
01:45:48,119 --> 01:45:50,040
well fine functions or in general

2737
01:45:50,040 --> 01:45:51,719
permutation polynomial which as I've

2738
01:45:51,719 --> 01:45:53,940
been mentioning and a fine function and

2739
01:45:53,940 --> 01:45:55,920
a fine mapping is just a pigmentation

2740
01:45:55,920 --> 01:45:58,440
polynomial of degree one okay

2741
01:45:58,440 --> 01:46:00,360
so with also interested in generating

2742
01:46:00,360 --> 01:46:01,739
this kind of stuff

2743
01:46:01,739 --> 01:46:03,960
I can also give you some words for that

2744
01:46:03,960 --> 01:46:06,480
for a fine functions is very simple

2745
01:46:06,480 --> 01:46:09,060
uh just look uh just Google I find

2746
01:46:09,060 --> 01:46:11,820
Cipher which is not the same that we are

2747
01:46:11,820 --> 01:46:13,500
doing but the affine cipher is just

2748
01:46:13,500 --> 01:46:15,659
classical Cipher but uses a fine

2749
01:46:15,659 --> 01:46:17,760
functions and actually uses inverse of

2750
01:46:17,760 --> 01:46:19,199
fine functions that you have the

2751
01:46:19,199 --> 01:46:20,940
description of how to get from an aheim

2752
01:46:20,940 --> 01:46:23,820
function to its inverse really easily so

2753
01:46:23,820 --> 01:46:25,679
there is just one constraint which is

2754
01:46:25,679 --> 01:46:26,639
that

2755
01:46:26,639 --> 01:46:29,880
uh the coefficient for DX has to be odd

2756
01:46:29,880 --> 01:46:31,739
and then you can construct each inverse

2757
01:46:31,739 --> 01:46:33,480
very very easily okay it's everywhere

2758
01:46:33,480 --> 01:46:35,400
this method is everywhere

2759
01:46:35,400 --> 01:46:38,159
for inverse permutation polynomials it's

2760
01:46:38,159 --> 01:46:42,000
a little bit more complicated uh

2761
01:46:42,020 --> 01:46:45,480
there is a method which is on one of the

2762
01:46:45,480 --> 01:46:47,580
references that I will give you that

2763
01:46:47,580 --> 01:46:49,560
allows you to produce inverse

2764
01:46:49,560 --> 01:46:50,820
permutation polynomials of the same

2765
01:46:50,820 --> 01:46:53,820
degree but it's a method kind of limited

2766
01:46:53,820 --> 01:46:56,159
in the sense of it imposes a lot of

2767
01:46:56,159 --> 01:46:57,840
restrictions on the kind of permutation

2768
01:46:57,840 --> 01:46:59,760
polynomials that you can generate so the

2769
01:46:59,760 --> 01:47:01,020
space of fermentation polynomials that

2770
01:47:01,020 --> 01:47:03,300
you can generate is way smaller than the

2771
01:47:03,300 --> 01:47:04,380
space of the whole permutation

2772
01:47:04,380 --> 01:47:06,300
polynomials that will allow such an

2773
01:47:06,300 --> 01:47:07,739
inverse but

2774
01:47:07,739 --> 01:47:09,840
public leads the best we know we we have

2775
01:47:09,840 --> 01:47:11,940
so far there are some research papers

2776
01:47:11,940 --> 01:47:14,699
recently that uh

2777
01:47:14,699 --> 01:47:16,980
introduce methods to generate pairs of

2778
01:47:16,980 --> 01:47:18,900
investigmentation polynomials on any

2779
01:47:18,900 --> 01:47:20,400
degree so for example a permutation

2780
01:47:20,400 --> 01:47:22,920
problem ld3 might have an inverse

2781
01:47:22,920 --> 01:47:24,360
mutation polynomial but which is in

2782
01:47:24,360 --> 01:47:26,760
degree 17 I don't know which might work

2783
01:47:26,760 --> 01:47:28,380
for you I mean there's no problem that

2784
01:47:28,380 --> 01:47:30,000
they have different degree just if you

2785
01:47:30,000 --> 01:47:32,159
want to have it bounded then the method

2786
01:47:32,159 --> 01:47:34,320
that we know so far is kind of limited

2787
01:47:34,320 --> 01:47:36,659
in the permutation polynomials that you

2788
01:47:36,659 --> 01:47:38,699
can you can actually create

2789
01:47:38,699 --> 01:47:40,860
there are some there's some private

2790
01:47:40,860 --> 01:47:42,719
research that I'm aware of especially

2791
01:47:42,719 --> 01:47:45,600
because I've done some of it uh for

2792
01:47:45,600 --> 01:47:49,199
actually doing uh General uh generation

2793
01:47:49,199 --> 01:47:51,780
of investmentation polynomials of the

2794
01:47:51,780 --> 01:47:53,880
same degree which is way more General

2795
01:47:53,880 --> 01:47:56,760
and can cover all possible permutation

2796
01:47:56,760 --> 01:48:00,000
polynomials but it's not finished I have

2797
01:48:00,000 --> 01:48:02,699
some partial results which are great for

2798
01:48:02,699 --> 01:48:04,800
some small degrees

2799
01:48:04,800 --> 01:48:07,340
and I hope to

2800
01:48:07,340 --> 01:48:09,540
have some more time to deploy into that

2801
01:48:09,540 --> 01:48:12,659
but until then there are methods to do

2802
01:48:12,659 --> 01:48:14,699
that the ones that have the same degree

2803
01:48:14,699 --> 01:48:18,000
is a little bit limited because you have

2804
01:48:18,000 --> 01:48:19,139
a small number of accommodation

2805
01:48:19,139 --> 01:48:20,820
polynomials that you can generate and

2806
01:48:20,820 --> 01:48:22,020
there are other methods that can give

2807
01:48:22,020 --> 01:48:24,780
you in general any kind of inverse but

2808
01:48:24,780 --> 01:48:27,540
uh you might not have bounded the degree

2809
01:48:27,540 --> 01:48:28,739
which is something that might be

2810
01:48:28,739 --> 01:48:30,480
interesting depending on just the

2811
01:48:30,480 --> 01:48:32,280
constraints that you have

2812
01:48:32,280 --> 01:48:36,360
so uh a little bit about the talk some

2813
01:48:36,360 --> 01:48:37,920
references this is uh the first one is

2814
01:48:37,920 --> 01:48:39,900
the Shameless self plug this was my BC

2815
01:48:39,900 --> 01:48:41,060
this is

2816
01:48:41,060 --> 01:48:43,980
uh from a couple years ago actually have

2817
01:48:43,980 --> 01:48:45,840
another thesis after that which is not

2818
01:48:45,840 --> 01:48:47,820
linked in here because a little bit

2819
01:48:47,820 --> 01:48:49,860
I go up into things that I have not

2820
01:48:49,860 --> 01:48:52,860
covered really here uh but here there is

2821
01:48:52,860 --> 01:48:54,960
a lot of MBA explanation here there is a

2822
01:48:54,960 --> 01:48:56,580
lot of MBA explanation actually it is

2823
01:48:56,580 --> 01:48:58,800
really nice these are PhD thesis that

2824
01:48:58,800 --> 01:49:01,380
reach kind of easy and we avoid all the

2825
01:49:01,380 --> 01:49:04,080
PHD thingy uh it reads kind of nicely

2826
01:49:04,080 --> 01:49:06,719
and then this is the paper which was

2827
01:49:06,719 --> 01:49:08,880
like the first paper that introduced

2828
01:49:08,880 --> 01:49:09,960
this idea of mixed Boolean

2829
01:49:09,960 --> 01:49:12,360
transformation for code obfuscation this

2830
01:49:12,360 --> 01:49:17,040
is from 2006 I want to think 2007. no

2831
01:49:17,040 --> 01:49:18,540
one cared about it

2832
01:49:18,540 --> 01:49:21,659
until more than 10 years later then

2833
01:49:21,659 --> 01:49:23,040
people start to say hey this is really

2834
01:49:23,040 --> 01:49:25,260
interesting and we can use that for

2835
01:49:25,260 --> 01:49:26,760
obfuscation and then

2836
01:49:26,760 --> 01:49:28,679
from the other side people said okay so

2837
01:49:28,679 --> 01:49:30,840
we want to address that to the office

2838
01:49:30,840 --> 01:49:33,060
case to be able to reason about it and

2839
01:49:33,060 --> 01:49:34,980
that's what has been motivating this

2840
01:49:34,980 --> 01:49:36,719
kind of research appearing like super

2841
01:49:36,719 --> 01:49:39,719
recently so it's like five years to now

2842
01:49:39,719 --> 01:49:42,119
that people have to start to research a

2843
01:49:42,119 --> 01:49:43,500
little bit seriously on this kind of

2844
01:49:43,500 --> 01:49:44,940
thing so there's a lot of things to be

2845
01:49:44,940 --> 01:49:45,600
done

2846
01:49:45,600 --> 01:49:48,360
so these these references

2847
01:49:48,360 --> 01:49:50,699
and foreign

2848
01:49:50,699 --> 01:49:53,699
all the materials uh this is if you scan

2849
01:49:53,699 --> 01:49:55,320
that you go directly to my GitHub with

2850
01:49:55,320 --> 01:49:56,760
all the materials for today are already

2851
01:49:56,760 --> 01:49:59,219
uploaded you have the slides the Demos

2852
01:49:59,219 --> 01:50:00,780
in the slides and all the code that I

2853
01:50:00,780 --> 01:50:03,360
have shown and well you can check

2854
01:50:03,360 --> 01:50:05,760
everything if you want if you don't get

2855
01:50:05,760 --> 01:50:08,820
the QR don't worry I will do that I will

2856
01:50:08,820 --> 01:50:10,980
upload it to the hack in the Box

2857
01:50:10,980 --> 01:50:13,980
repository as well and also if you just

2858
01:50:13,980 --> 01:50:15,600
go over my GitHub which is the same

2859
01:50:15,600 --> 01:50:18,179
handle as everywhere else on the pin

2860
01:50:18,179 --> 01:50:20,760
repotox you can find it so if you're

2861
01:50:20,760 --> 01:50:22,080
interested you will find it that's no

2862
01:50:22,080 --> 01:50:24,260
problem

2863
01:50:24,500 --> 01:50:27,600
I would love if you want to get in touch

2864
01:50:27,600 --> 01:50:28,619
or interested in that you want to

2865
01:50:28,619 --> 01:50:31,080
discuss more uh I will be

2866
01:50:31,080 --> 01:50:34,199
probably around uh today but

2867
01:50:34,199 --> 01:50:36,960
for any kind of inquiry any

2868
01:50:36,960 --> 01:50:39,540
thing you're researching issue and a

2869
01:50:39,540 --> 01:50:41,880
cool idea that you have uh you can get

2870
01:50:41,880 --> 01:50:44,820
in touch with me I'm mostly on Twitter

2871
01:50:44,820 --> 01:50:47,280
um but you can find me on Discord

2872
01:50:47,280 --> 01:50:50,639
telegram mail wherever you find me and

2873
01:50:50,639 --> 01:50:52,800
also on well my website has also

2874
01:50:52,800 --> 01:50:55,560
contacts contact information the website

2875
01:50:55,560 --> 01:50:58,860
my security firm wow I offer trainings

2876
01:50:58,860 --> 01:51:01,679
on other kind of Consulting on

2877
01:51:01,679 --> 01:51:03,239
obfuscation the obfuscations about

2878
01:51:03,239 --> 01:51:05,520
protection and this kind of thing way

2879
01:51:05,520 --> 01:51:07,139
more extended if you might be interested

2880
01:51:07,139 --> 01:51:10,139
in that it's also cool to check it out

2881
01:51:10,139 --> 01:51:11,940
um that's that's it about me uh it was a

2882
01:51:11,940 --> 01:51:13,199
pleasure being here at hack in the Box

2883
01:51:13,199 --> 01:51:15,420
again in person again

2884
01:51:15,420 --> 01:51:17,880
and I wanted to thank all the organizers

2885
01:51:17,880 --> 01:51:19,920
on the crew

2886
01:51:19,920 --> 01:51:22,380
um the video guys that are putting this

2887
01:51:22,380 --> 01:51:24,900
together really nicely and it's been

2888
01:51:24,900 --> 01:51:26,760
really happy to be here again

2889
01:51:26,760 --> 01:51:29,699
been here for a few days already doing

2890
01:51:29,699 --> 01:51:31,860
my training the previous days now giving

2891
01:51:31,860 --> 01:51:33,780
I really wanted to do this this free lap

2892
01:51:33,780 --> 01:51:35,760
session for everyone be interested

2893
01:51:35,760 --> 01:51:37,739
because it's kind of a niche

2894
01:51:37,739 --> 01:51:40,199
content but people who are interested

2895
01:51:40,199 --> 01:51:42,239
I'm super happy with sharing And

2896
01:51:42,239 --> 01:51:44,280
discussing anything with them that's it

2897
01:51:44,280 --> 01:51:46,080
I think we have a few minutes if you

2898
01:51:46,080 --> 01:51:47,820
have some question otherwise it will be

2899
01:51:47,820 --> 01:51:50,460
walking around you can always find me on

2900
01:51:50,460 --> 01:51:52,739
internet for anything you may need thank

2901
01:51:52,739 --> 01:51:54,120
you very much

2902
01:51:54,120 --> 01:51:58,510
[Applause]

