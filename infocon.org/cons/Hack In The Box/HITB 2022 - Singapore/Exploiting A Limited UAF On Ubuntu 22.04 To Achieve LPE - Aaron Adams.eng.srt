1
00:00:06,440 --> 00:00:11,460
yep so uh just a quick about so I work

2
00:00:11,460 --> 00:00:14,040
for NCC group in a team of three people

3
00:00:14,040 --> 00:00:15,599
just called the exploit Development

4
00:00:15,599 --> 00:00:17,880
Group and we basically just mostly focus

5
00:00:17,880 --> 00:00:19,920
on end days until recently we started

6
00:00:19,920 --> 00:00:22,500
doing some pone to own stuff

7
00:00:22,500 --> 00:00:24,060
um so we

8
00:00:24,060 --> 00:00:27,300
um joined the poem to own Austin uh 2021

9
00:00:27,300 --> 00:00:29,220
which is more like iot and embedded

10
00:00:29,220 --> 00:00:32,159
stuff and we exploited uh Nas and

11
00:00:32,159 --> 00:00:33,960
Lexmark printer and

12
00:00:33,960 --> 00:00:36,180
um released some blogs talking about the

13
00:00:36,180 --> 00:00:38,219
the bugs we exploited in methodology and

14
00:00:38,219 --> 00:00:39,660
stuff

15
00:00:39,660 --> 00:00:41,760
um if you're interested

16
00:00:41,760 --> 00:00:44,940
so yeah basically we um we ended up

17
00:00:44,940 --> 00:00:47,460
wanting to or tried to

18
00:00:47,460 --> 00:00:49,860
um compete in pone to own desktop 2022

19
00:00:49,860 --> 00:00:52,320
or yeah 2022 but

20
00:00:52,320 --> 00:00:54,539
um it didn't quite go as planned so

21
00:00:54,539 --> 00:00:57,840
basically at first we found uh a bug and

22
00:00:57,840 --> 00:00:59,879
exploited it and we were happy and we

23
00:00:59,879 --> 00:01:01,860
were all ready to go and then it was

24
00:01:01,860 --> 00:01:02,940
patched

25
00:01:02,940 --> 00:01:05,099
um before the competition so we had to

26
00:01:05,099 --> 00:01:06,600
start from scratch which was kind of too

27
00:01:06,600 --> 00:01:09,420
bad so we founded or we founded a second

28
00:01:09,420 --> 00:01:11,939
vulnerability and we were pretty well on

29
00:01:11,939 --> 00:01:13,439
our way to exploiting it it definitely

30
00:01:13,439 --> 00:01:15,659
was exploitable and then that was also

31
00:01:15,659 --> 00:01:18,180
publicly patched before we were finished

32
00:01:18,180 --> 00:01:20,100
so we had to start from scratch again

33
00:01:20,100 --> 00:01:22,680
but it was getting kind of late

34
00:01:22,680 --> 00:01:24,299
um and unfortunately we didn't finish

35
00:01:24,299 --> 00:01:27,000
exploiting the third bug in time but it

36
00:01:27,000 --> 00:01:29,759
was still interesting experience and we

37
00:01:29,759 --> 00:01:31,500
decided to disclose it rather than sit

38
00:01:31,500 --> 00:01:33,360
on it for a year just because probably

39
00:01:33,360 --> 00:01:35,939
it would get found anyways

40
00:01:35,939 --> 00:01:37,920
um and yeah so basically this talk is

41
00:01:37,920 --> 00:01:39,540
just about the third bug because in the

42
00:01:39,540 --> 00:01:41,280
end there was no like collisions for

43
00:01:41,280 --> 00:01:44,100
this bug at ponton or anything so it's

44
00:01:44,100 --> 00:01:46,259
kind of interesting and yeah so at the

45
00:01:46,259 --> 00:01:49,619
time of the competition uh the the

46
00:01:49,619 --> 00:01:51,560
target was Ubuntu

47
00:01:51,560 --> 00:01:54,060
22.04 and it was

48
00:01:54,060 --> 00:01:57,659
um kernel 5.15

49
00:01:57,659 --> 00:02:00,420
um so yeah I guess I'm kind of fortunate

50
00:02:00,420 --> 00:02:02,640
to follow Sam's presentation in that I'm

51
00:02:02,640 --> 00:02:04,320
not going to talk too much about the

52
00:02:04,320 --> 00:02:06,000
methodology and stuff

53
00:02:06,000 --> 00:02:07,560
um it's just gonna mostly be a big

54
00:02:07,560 --> 00:02:09,720
technical dump of the bug and how he

55
00:02:09,720 --> 00:02:12,780
exploited it but just we mostly followed

56
00:02:12,780 --> 00:02:15,060
the typical tooling stuff that you do

57
00:02:15,060 --> 00:02:17,099
for Linux kernel

58
00:02:17,099 --> 00:02:19,200
uh debugging and whatnot I guess the one

59
00:02:19,200 --> 00:02:20,640
thing that's worth noting that I've

60
00:02:20,640 --> 00:02:22,020
noticed some people don't seem to know

61
00:02:22,020 --> 00:02:24,060
about is that the Linux kernel sources

62
00:02:24,060 --> 00:02:26,940
include some um helper Python scripts

63
00:02:26,940 --> 00:02:28,680
that you can import into GDB that

64
00:02:28,680 --> 00:02:31,200
actually let you analyze a bunch of the

65
00:02:31,200 --> 00:02:32,879
structures so like if you have a

66
00:02:32,879 --> 00:02:34,500
breakpoint and you want to only trigger

67
00:02:34,500 --> 00:02:38,040
the break point if the user land process

68
00:02:38,040 --> 00:02:40,200
is a specific one they basically provide

69
00:02:40,200 --> 00:02:42,660
you structures for that version that let

70
00:02:42,660 --> 00:02:43,440
you

71
00:02:43,440 --> 00:02:46,500
um do that check inside of GDB which is

72
00:02:46,500 --> 00:02:48,840
really nice but otherwise it's just

73
00:02:48,840 --> 00:02:51,000
pretty typical stuff PA hole for

74
00:02:51,000 --> 00:02:52,739
structure analysis we did end up using

75
00:02:52,739 --> 00:02:54,959
code ql for some

76
00:02:54,959 --> 00:02:56,940
um querying structure sizes and members

77
00:02:56,940 --> 00:02:58,860
and stuff which I'll talk about and then

78
00:02:58,860 --> 00:03:00,900
I guess the other big thing was we did a

79
00:03:00,900 --> 00:03:03,180
lot of like slub cash or slab cache

80
00:03:03,180 --> 00:03:04,379
analysis

81
00:03:04,379 --> 00:03:04,920
um

82
00:03:04,920 --> 00:03:06,959
during the research and at first we were

83
00:03:06,959 --> 00:03:08,819
using F Trace which a lot of people seem

84
00:03:08,819 --> 00:03:12,360
to be using but we found that just the

85
00:03:12,360 --> 00:03:13,980
information it provides in the level of

86
00:03:13,980 --> 00:03:15,540
analysis I let

87
00:03:15,540 --> 00:03:18,420
but uh as do wasn't quite what we wanted

88
00:03:18,420 --> 00:03:20,099
because we're used to using some other

89
00:03:20,099 --> 00:03:21,659
tools that we had written in user land

90
00:03:21,659 --> 00:03:24,239
so anyways we ended up writing our own

91
00:03:24,239 --> 00:03:26,879
um tool based off some other open source

92
00:03:26,879 --> 00:03:29,159
tool called slab dbg

93
00:03:29,159 --> 00:03:31,019
um that just works on the latest kernels

94
00:03:31,019 --> 00:03:32,640
and stuff and it's much nicer for

95
00:03:32,640 --> 00:03:34,920
analyzing all sorts of stuff on in the

96
00:03:34,920 --> 00:03:36,900
slab allocator so we're going to release

97
00:03:36,900 --> 00:03:39,599
that uh open source eventually but it's

98
00:03:39,599 --> 00:03:42,180
not quite open source yet but

99
00:03:42,180 --> 00:03:42,959
um

100
00:03:42,959 --> 00:03:45,180
stay tuned for that I guess so yeah I'm

101
00:03:45,180 --> 00:03:47,280
basically just going to go over like the

102
00:03:47,280 --> 00:03:51,239
net link net filter and NF tables parts

103
00:03:51,239 --> 00:03:52,920
of the Linux kernel just like a

104
00:03:52,920 --> 00:03:55,319
whirlwind up to the point of like

105
00:03:55,319 --> 00:03:58,319
um knowing enough uh

106
00:03:58,319 --> 00:04:00,720
to understand the bug and and then we'll

107
00:04:00,720 --> 00:04:02,280
just talk about how to exploit it and

108
00:04:02,280 --> 00:04:05,040
then look at how they patched it

109
00:04:05,040 --> 00:04:08,640
um so yeah basically

110
00:04:08,640 --> 00:04:11,159
um most people that use Linux are

111
00:04:11,159 --> 00:04:13,500
probably familiar with this userland uh

112
00:04:13,500 --> 00:04:15,480
utility called nft which is used for

113
00:04:15,480 --> 00:04:18,418
configuring the the firewall

114
00:04:18,418 --> 00:04:21,120
um and basically like if you want to add

115
00:04:21,120 --> 00:04:23,400
a rule for something like dropping a TTP

116
00:04:23,400 --> 00:04:25,320
Port 80 you just run a command like this

117
00:04:25,320 --> 00:04:26,880
and it's really well documented and

118
00:04:26,880 --> 00:04:29,220
fairly easy to use compared to the tools

119
00:04:29,220 --> 00:04:31,740
in the old days but we're interested in

120
00:04:31,740 --> 00:04:33,300
like how does this work underneath

121
00:04:33,300 --> 00:04:36,180
because parsing like the logic of these

122
00:04:36,180 --> 00:04:37,500
types of rules and and building

123
00:04:37,500 --> 00:04:39,180
structures based on them and stuff is

124
00:04:39,180 --> 00:04:40,620
quite complicated

125
00:04:40,620 --> 00:04:42,600
so basically everything is built around

126
00:04:42,600 --> 00:04:45,300
netlink which maybe people are familiar

127
00:04:45,300 --> 00:04:47,580
with but basically you can just create a

128
00:04:47,580 --> 00:04:49,259
socket and then

129
00:04:49,259 --> 00:04:52,259
um you can send packets to that socket

130
00:04:52,259 --> 00:04:54,419
to talk to various parts of the Linux

131
00:04:54,419 --> 00:04:57,240
kernel like networking subsystem

132
00:04:57,240 --> 00:04:59,040
um and there's a really nice userland

133
00:04:59,040 --> 00:05:00,720
library for helping you build the

134
00:05:00,720 --> 00:05:02,580
packets because it's kind of annoying to

135
00:05:02,580 --> 00:05:05,660
do by hand and then net filter

136
00:05:05,660 --> 00:05:09,479
is just basically like a bunch of kind

137
00:05:09,479 --> 00:05:12,240
of hooks into different parts of the

138
00:05:12,240 --> 00:05:14,160
Linux networking subsystem so things

139
00:05:14,160 --> 00:05:16,080
like Network address translation and

140
00:05:16,080 --> 00:05:18,000
what we're interested in the the

141
00:05:18,000 --> 00:05:21,380
firewall stuff and basically you can

142
00:05:21,380 --> 00:05:23,940
just create packets

143
00:05:23,940 --> 00:05:24,539
um

144
00:05:24,539 --> 00:05:27,360
that talk to these different hooked

145
00:05:27,360 --> 00:05:30,360
portions of the kernel and then finally

146
00:05:30,360 --> 00:05:32,460
again what we're interested in is NF

147
00:05:32,460 --> 00:05:35,039
tables kernel module and yeah basically

148
00:05:35,039 --> 00:05:37,500
it's like the newer new Wiz in like 10

149
00:05:37,500 --> 00:05:39,240
years or something

150
00:05:39,240 --> 00:05:41,340
um firewall in the in the Linux kernel

151
00:05:41,340 --> 00:05:45,180
and um it replaced IB tables and again

152
00:05:45,180 --> 00:05:47,340
there's a pretty nice userland library

153
00:05:47,340 --> 00:05:49,139
for constructing the packets and stuff

154
00:05:49,139 --> 00:05:51,900
because it's also quite annoying to do

155
00:05:51,900 --> 00:05:55,320
by hand if you have to tweak anything

156
00:05:55,320 --> 00:05:57,240
um and most importantly

157
00:05:57,240 --> 00:06:00,000
um access to stuff like

158
00:06:00,000 --> 00:06:02,520
um net filter and NF tables is

159
00:06:02,520 --> 00:06:03,660
um based on whether or not you have the

160
00:06:03,660 --> 00:06:06,240
net admin capability and I'm sure a lot

161
00:06:06,240 --> 00:06:08,340
of people are aware on Ubuntu you can

162
00:06:08,340 --> 00:06:09,600
enter

163
00:06:09,600 --> 00:06:12,479
um namespaces as an unprivileged user so

164
00:06:12,479 --> 00:06:14,100
you can enter a network namespace and

165
00:06:14,100 --> 00:06:15,720
basically obtain this capability and

166
00:06:15,720 --> 00:06:18,840
then expose the functionality that you

167
00:06:18,840 --> 00:06:20,880
wanted to Target

168
00:06:20,880 --> 00:06:24,300
so yeah recently this like NF tables

169
00:06:24,300 --> 00:06:27,240
module has been pretty popular

170
00:06:27,240 --> 00:06:30,180
um just especially this year I think we

171
00:06:30,180 --> 00:06:32,520
started buzzing it specifically around

172
00:06:32,520 --> 00:06:35,520
when David Bowman released his blog and

173
00:06:35,520 --> 00:06:37,380
if you're interested in any of the NF

174
00:06:37,380 --> 00:06:39,419
tables internals and stuff and follow up

175
00:06:39,419 --> 00:06:42,300
on the re like what I present here

176
00:06:42,300 --> 00:06:44,580
definitely read David Bowman's blog

177
00:06:44,580 --> 00:06:46,139
because it goes into the most detail

178
00:06:46,139 --> 00:06:48,479
just about net Lincoln

179
00:06:48,479 --> 00:06:50,340
um NF tables packets and all that kind

180
00:06:50,340 --> 00:06:52,740
of stuff but it's all pretty interesting

181
00:06:52,740 --> 00:06:55,199
reads if you want to go deeper and

182
00:06:55,199 --> 00:06:58,199
interestingly at least one team team

183
00:06:58,199 --> 00:07:00,900
Orca which I of C security which I think

184
00:07:00,900 --> 00:07:03,780
is from Singapore they ended up

185
00:07:03,780 --> 00:07:05,940
exploiting a bug in the same component

186
00:07:05,940 --> 00:07:07,800
successfully at Pawn to home so that's

187
00:07:07,800 --> 00:07:09,120
kind of cool and I'm sure there'll be

188
00:07:09,120 --> 00:07:11,699
more in the future

189
00:07:11,699 --> 00:07:13,139
um so yeah basically I'm gonna have to

190
00:07:13,139 --> 00:07:14,940
explain a whole bunch of structures that

191
00:07:14,940 --> 00:07:16,860
are used internally so that we can

192
00:07:16,860 --> 00:07:18,300
understand the bug

193
00:07:18,300 --> 00:07:20,280
so basically everything is grouped into

194
00:07:20,280 --> 00:07:23,520
tables which people that have again used

195
00:07:23,520 --> 00:07:25,620
um nft will be a bit familiar with but

196
00:07:25,620 --> 00:07:27,419
basically a table is just a group of

197
00:07:27,419 --> 00:07:29,819
chains and they're typically associated

198
00:07:29,819 --> 00:07:31,560
with like a specific networking protocol

199
00:07:31,560 --> 00:07:33,660
so like ipv4 will have a whole bunch of

200
00:07:33,660 --> 00:07:36,000
chains associated with it and then the

201
00:07:36,000 --> 00:07:37,740
chains typically just have like a

202
00:07:37,740 --> 00:07:41,099
default policy of accepts or drop and

203
00:07:41,099 --> 00:07:42,840
then the chains themselves hold a group

204
00:07:42,840 --> 00:07:44,639
of rules which

205
00:07:44,639 --> 00:07:47,940
um you know explains how to

206
00:07:47,940 --> 00:07:49,500
um actually process the packets

207
00:07:49,500 --> 00:07:51,000
themselves

208
00:07:51,000 --> 00:07:53,759
um and and basically the the rules are

209
00:07:53,759 --> 00:07:55,440
just made up of a group of Expressions

210
00:07:55,440 --> 00:07:57,120
which are more discrete pieces of like

211
00:07:57,120 --> 00:07:59,819
Logic for um processing the actual

212
00:07:59,819 --> 00:08:02,460
packets themselves

213
00:08:02,460 --> 00:08:03,780
um and there's a ton of different

214
00:08:03,780 --> 00:08:06,180
Expressions again the blog by David

215
00:08:06,180 --> 00:08:08,400
Bowman um goes over a lot of different

216
00:08:08,400 --> 00:08:11,160
ones and there's too many to cover

217
00:08:11,160 --> 00:08:13,380
um but really we're just interested in

218
00:08:13,380 --> 00:08:14,819
these three that we use during

219
00:08:14,819 --> 00:08:16,440
exploitation

220
00:08:16,440 --> 00:08:18,419
um and I'll go into them in more detail

221
00:08:18,419 --> 00:08:20,699
in a second

222
00:08:20,699 --> 00:08:22,860
um and then there's the concept of sets

223
00:08:22,860 --> 00:08:25,259
and so basically the idea is like if you

224
00:08:25,259 --> 00:08:27,479
create a rule that um

225
00:08:27,479 --> 00:08:30,919
like is going to Blacklist a list of ips

226
00:08:30,919 --> 00:08:33,539
or has a you know a list of ports or

227
00:08:33,539 --> 00:08:35,640
whatever basically those

228
00:08:35,640 --> 00:08:38,520
um sets of like numbers are represented

229
00:08:38,520 --> 00:08:40,200
in the kernel and just like a data

230
00:08:40,200 --> 00:08:42,599
structure and they they call it a um set

231
00:08:42,599 --> 00:08:45,360
so nft set structure

232
00:08:45,360 --> 00:08:46,980
um and basically yeah the elements

233
00:08:46,980 --> 00:08:48,720
inside of the the data structure are

234
00:08:48,720 --> 00:08:50,220
just referred to as Elements which I'll

235
00:08:50,220 --> 00:08:51,899
mention a couple times

236
00:08:51,899 --> 00:08:55,080
and um yeah given the name of the talk

237
00:08:55,080 --> 00:08:57,779
um we're specifically interested in this

238
00:08:57,779 --> 00:09:00,660
set structure and it's quite a big

239
00:09:00,660 --> 00:09:02,519
structure there's a lot of different

240
00:09:02,519 --> 00:09:05,040
fields too many to go over but these are

241
00:09:05,040 --> 00:09:06,779
the ones who are mostly interested in

242
00:09:06,779 --> 00:09:11,100
and I'll go into some detail about them

243
00:09:11,100 --> 00:09:13,800
um yeah so that there's there's a a

244
00:09:13,800 --> 00:09:15,600
member called list which is basically

245
00:09:15,600 --> 00:09:18,300
just a doubly linked list and uh of sets

246
00:09:18,300 --> 00:09:20,640
that are um associated with a table so

247
00:09:20,640 --> 00:09:23,399
if you have multiple Like rules

248
00:09:23,399 --> 00:09:25,080
referencing different sets of data

249
00:09:25,080 --> 00:09:27,600
they'll all just be linked on this same

250
00:09:27,600 --> 00:09:29,160
doubly linked list associated with

251
00:09:29,160 --> 00:09:31,620
whatever table they're part of

252
00:09:31,620 --> 00:09:33,060
um there's also a doubly linked list

253
00:09:33,060 --> 00:09:35,459
called bindings and basically if you

254
00:09:35,459 --> 00:09:37,380
have some expression that's referencing

255
00:09:37,380 --> 00:09:41,760
some element in the set it gets bound to

256
00:09:41,760 --> 00:09:44,820
um the set and it it by being bound it

257
00:09:44,820 --> 00:09:46,200
basically means it gets added to this

258
00:09:46,200 --> 00:09:48,300
doubly linked list

259
00:09:48,300 --> 00:09:49,740
um when you're interacting with a set

260
00:09:49,740 --> 00:09:51,360
through an expression or whatever you

261
00:09:51,360 --> 00:09:53,040
need to look it up somehow so there's a

262
00:09:53,040 --> 00:09:54,779
name which is important

263
00:09:54,779 --> 00:09:56,279
um if you end up corrupting things later

264
00:09:56,279 --> 00:09:59,700
there's like a reference counter

265
00:09:59,700 --> 00:10:01,980
um and when basically when you're when

266
00:10:01,980 --> 00:10:03,360
you're creating this set in the first

267
00:10:03,360 --> 00:10:05,100
place so you're building this netlink

268
00:10:05,100 --> 00:10:06,959
packet that you know

269
00:10:06,959 --> 00:10:09,180
um is talking to NF tables and say okay

270
00:10:09,180 --> 00:10:10,620
I want to build this set they give you

271
00:10:10,620 --> 00:10:13,320
the the ability to add some arbitrary

272
00:10:13,320 --> 00:10:16,140
data that you can store inline inside of

273
00:10:16,140 --> 00:10:18,480
the structure that ends up going on this

274
00:10:18,480 --> 00:10:21,540
um this lab cache and you can also read

275
00:10:21,540 --> 00:10:24,600
this uh data out from the set after the

276
00:10:24,600 --> 00:10:26,640
fact which will be from userland which

277
00:10:26,640 --> 00:10:28,680
will be useful later and so then there's

278
00:10:28,680 --> 00:10:30,360
a length field that says how much data

279
00:10:30,360 --> 00:10:32,220
did you actually store there and then

280
00:10:32,220 --> 00:10:33,899
interestingly there's the like a

281
00:10:33,899 --> 00:10:35,339
function table pointer for doing

282
00:10:35,339 --> 00:10:37,320
operations on the set like adding

283
00:10:37,320 --> 00:10:40,620
deleting elements and stuff like that

284
00:10:40,620 --> 00:10:43,440
um and so by default again it's a fairly

285
00:10:43,440 --> 00:10:45,600
big structure so by default it's stored

286
00:10:45,600 --> 00:10:48,899
on the 512 byte um so like slab cache

287
00:10:48,899 --> 00:10:50,880
but because of the variable length user

288
00:10:50,880 --> 00:10:53,399
data you can supply you can get it onto

289
00:10:53,399 --> 00:10:57,180
the 1024 byte slab cache um which is

290
00:10:57,180 --> 00:10:58,740
useful

291
00:10:58,740 --> 00:11:00,180
so

292
00:11:00,180 --> 00:11:02,880
um we want to take a bit of a closer

293
00:11:02,880 --> 00:11:04,860
look at the bindings member specifically

294
00:11:04,860 --> 00:11:08,519
so when an expression references the set

295
00:11:08,519 --> 00:11:10,980
it gets bound to the set and so

296
00:11:10,980 --> 00:11:13,200
basically any expression that's capable

297
00:11:13,200 --> 00:11:15,839
of referencing a set will embed this nft

298
00:11:15,839 --> 00:11:18,360
set binding structure and it basically

299
00:11:18,360 --> 00:11:20,579
just has The List member and that's what

300
00:11:20,579 --> 00:11:24,120
ends up being put onto the bindings list

301
00:11:24,120 --> 00:11:26,700
and so the entries on it each list point

302
00:11:26,700 --> 00:11:28,740
to that list member of this structure

303
00:11:28,740 --> 00:11:30,000
rather than the beginning of the

304
00:11:30,000 --> 00:11:31,500
expression itself which is kind of

305
00:11:31,500 --> 00:11:33,920
important

306
00:11:34,079 --> 00:11:34,620
um

307
00:11:34,620 --> 00:11:37,380
and so then Expressions themselves

308
00:11:37,380 --> 00:11:40,560
um basically there's like a a more

309
00:11:40,560 --> 00:11:42,600
um generic structure called nft

310
00:11:42,600 --> 00:11:44,940
underscore expression and basically

311
00:11:44,940 --> 00:11:46,800
every type of expression in the kernel

312
00:11:46,800 --> 00:11:48,720
extends from this so that it just has

313
00:11:48,720 --> 00:11:50,519
like its own little function pointer

314
00:11:50,519 --> 00:11:52,800
member and then an inline array that's

315
00:11:52,800 --> 00:11:54,420
going to contain the actual specific

316
00:11:54,420 --> 00:11:56,579
expression type so like at the bottom

317
00:11:56,579 --> 00:11:58,380
you can see we're going to create an or

318
00:11:58,380 --> 00:12:00,200
we want to reference an nft lookup

319
00:12:00,200 --> 00:12:03,000
expression and so it calls this function

320
00:12:03,000 --> 00:12:05,220
to just pull out the data member of that

321
00:12:05,220 --> 00:12:08,339
more generic structure and this is only

322
00:12:08,339 --> 00:12:11,399
just noteworthy because

323
00:12:11,399 --> 00:12:13,079
um If you're sort of analyzing the

324
00:12:13,079 --> 00:12:14,579
structures in the kernel and you want to

325
00:12:14,579 --> 00:12:16,380
know what slab cache structure is

326
00:12:16,380 --> 00:12:18,180
allocated on

327
00:12:18,180 --> 00:12:21,180
um if you don't include the size of the

328
00:12:21,180 --> 00:12:23,160
nft expression structure in that

329
00:12:23,160 --> 00:12:25,560
calculation you'll you'll be wrong and

330
00:12:25,560 --> 00:12:27,540
you'll be looking at the wrong cache so

331
00:12:27,540 --> 00:12:30,360
it's worth worth knowing

332
00:12:30,360 --> 00:12:31,800
um so yeah the Expressions we're

333
00:12:31,800 --> 00:12:35,160
interested in the lookup one basically

334
00:12:35,160 --> 00:12:37,620
the idea is that it just fetches some

335
00:12:37,620 --> 00:12:40,620
value from a set and it's a 48 byte

336
00:12:40,620 --> 00:12:43,380
structure so allocated on that subcache

337
00:12:43,380 --> 00:12:45,300
and we're mostly just interested in the

338
00:12:45,300 --> 00:12:48,060
fact that the binding structure entry is

339
00:12:48,060 --> 00:12:50,940
the last entry in the structure we don't

340
00:12:50,940 --> 00:12:54,060
really care what else it's used for

341
00:12:54,060 --> 00:12:56,100
um and similarly the dynamic set

342
00:12:56,100 --> 00:12:57,839
expression we don't care too much about

343
00:12:57,839 --> 00:12:59,940
anything that it's used for

344
00:12:59,940 --> 00:13:01,500
um except that it can reference a set

345
00:13:01,500 --> 00:13:03,480
Again The Binding

346
00:13:03,480 --> 00:13:05,160
um structure is at the bottom of the

347
00:13:05,160 --> 00:13:07,680
structure and this one's a bit bigger 96

348
00:13:07,680 --> 00:13:09,959
byte uh slab cache

349
00:13:09,959 --> 00:13:11,459
so

350
00:13:11,459 --> 00:13:13,079
the way this would normally look is

351
00:13:13,079 --> 00:13:15,000
you've got some set

352
00:13:15,000 --> 00:13:17,040
and then you've got you know you send

353
00:13:17,040 --> 00:13:19,380
some Expressions over netlink and they

354
00:13:19,380 --> 00:13:21,120
reference the set so they just get added

355
00:13:21,120 --> 00:13:22,920
to the bindings list

356
00:13:22,920 --> 00:13:26,339
and going back to the um beginning I

357
00:13:26,339 --> 00:13:28,500
mentioned the there's the list doubly

358
00:13:28,500 --> 00:13:30,240
linked list as well so in this case okay

359
00:13:30,240 --> 00:13:32,220
there's a table and there's multiple

360
00:13:32,220 --> 00:13:34,139
sets associated with this table and each

361
00:13:34,139 --> 00:13:36,480
one happens to have Expressions linked

362
00:13:36,480 --> 00:13:38,339
on to the bindings list so that's just

363
00:13:38,339 --> 00:13:41,160
like a high level overview of what you

364
00:13:41,160 --> 00:13:44,339
can think about it uh in your head

365
00:13:44,339 --> 00:13:47,700
so there's another sort of important bit

366
00:13:47,700 --> 00:13:49,800
which is like when you're creating the

367
00:13:49,800 --> 00:13:52,139
set originally you send the packet

368
00:13:52,139 --> 00:13:54,360
over net link you can basically say that

369
00:13:54,360 --> 00:13:56,160
you want to embed certain Expressions

370
00:13:56,160 --> 00:13:58,740
inside of the set itself and this is a

371
00:13:58,740 --> 00:13:59,820
little bit different because I said

372
00:13:59,820 --> 00:14:02,459
expressions are normally used to process

373
00:14:02,459 --> 00:14:04,500
um the actual packets that are coming in

374
00:14:04,500 --> 00:14:06,720
over the network but in this case the

375
00:14:06,720 --> 00:14:09,839
expressions are meant to get run when

376
00:14:09,839 --> 00:14:12,839
data in the set is being updated but

377
00:14:12,839 --> 00:14:15,600
there's only a limited number of types

378
00:14:15,600 --> 00:14:17,100
of Expressions that can actually be

379
00:14:17,100 --> 00:14:19,019
embedded in a set and they're called

380
00:14:19,019 --> 00:14:21,839
stateful expressions

381
00:14:21,839 --> 00:14:23,880
um which will be important so that's

382
00:14:23,880 --> 00:14:26,760
basically like a quick Whirlwind of like

383
00:14:26,760 --> 00:14:29,639
the the structures involved in how to at

384
00:14:29,639 --> 00:14:32,519
least enough to understand the bug

385
00:14:32,519 --> 00:14:33,779
so

386
00:14:33,779 --> 00:14:35,880
um yeah we basically were fuzzing I

387
00:14:35,880 --> 00:14:37,980
think after we read David Bowman's blog

388
00:14:37,980 --> 00:14:39,720
we decided to spin up like this is

389
00:14:39,720 --> 00:14:42,240
called fuzzer specifically targeting um

390
00:14:42,240 --> 00:14:44,220
NF tables just because it seemed like a

391
00:14:44,220 --> 00:14:46,440
fruitful area and this bug was

392
00:14:46,440 --> 00:14:47,779
specifically compelling because

393
00:14:47,779 --> 00:14:50,339
ciscollar wasn't able to automatically

394
00:14:50,339 --> 00:14:52,199
generate a reprofile because normally

395
00:14:52,199 --> 00:14:54,360
it'll give you like some C that you can

396
00:14:54,360 --> 00:14:56,459
run to trigger it and in this case it

397
00:14:56,459 --> 00:14:57,779
couldn't

398
00:14:57,779 --> 00:15:00,839
um and because we already got burnt

399
00:15:00,839 --> 00:15:03,000
twice with bugs we figured this might

400
00:15:03,000 --> 00:15:04,500
mean that other people didn't want to

401
00:15:04,500 --> 00:15:05,940
look at this bug if other people had

402
00:15:05,940 --> 00:15:08,399
already fuzzed it so we decided to do

403
00:15:08,399 --> 00:15:10,740
that and basically it's a use after free

404
00:15:10,740 --> 00:15:12,540
while handling Expressions on the

405
00:15:12,540 --> 00:15:14,339
bindings list that I that I just

406
00:15:14,339 --> 00:15:16,320
explained and it's quite Limited in so

407
00:15:16,320 --> 00:15:18,959
far as as we'll see you can basically

408
00:15:18,959 --> 00:15:21,120
just write one pointer that you don't

409
00:15:21,120 --> 00:15:22,980
control to an uncontrolled offset

410
00:15:22,980 --> 00:15:24,839
somewhere

411
00:15:24,839 --> 00:15:28,139
um and after we disclosed it and stuff

412
00:15:28,139 --> 00:15:29,940
and it was patched someone else noticed

413
00:15:29,940 --> 00:15:32,100
interestingly that Google's fuzzing

414
00:15:32,100 --> 00:15:33,600
infrastructure had actually found it

415
00:15:33,600 --> 00:15:36,720
already in November 2021 which we didn't

416
00:15:36,720 --> 00:15:38,160
know about and it was automatically

417
00:15:38,160 --> 00:15:40,320
closed as invalid which I actually have

418
00:15:40,320 --> 00:15:42,000
no idea why maybe because there's no

419
00:15:42,000 --> 00:15:45,899
Repro so it figured it wasn't real

420
00:15:45,899 --> 00:15:48,000
um but yeah so basically I I mentioned

421
00:15:48,000 --> 00:15:50,399
that when you're allocating a set you

422
00:15:50,399 --> 00:15:52,320
can you can embed certain Expressions

423
00:15:52,320 --> 00:15:54,600
inside and those expressions can only be

424
00:15:54,600 --> 00:15:56,459
of a certain type otherwise this this

425
00:15:56,459 --> 00:15:59,519
set is considered invalid and so this is

426
00:15:59,519 --> 00:16:02,040
the function responsible for that and

427
00:16:02,040 --> 00:16:03,899
interestingly we can see what it does at

428
00:16:03,899 --> 00:16:05,639
the top it calls nft expression

429
00:16:05,639 --> 00:16:07,880
initialize and that will actually

430
00:16:07,880 --> 00:16:11,639
allocate the expression structure like

431
00:16:11,639 --> 00:16:13,079
on the slab cache and call an

432
00:16:13,079 --> 00:16:15,480
initialization routine and only after

433
00:16:15,480 --> 00:16:17,639
we're like after it does all that it

434
00:16:17,639 --> 00:16:19,860
checks the flag to see is this

435
00:16:19,860 --> 00:16:22,620
expression legit or not like for this

436
00:16:22,620 --> 00:16:25,079
for being embedded in a set and if not

437
00:16:25,079 --> 00:16:28,139
it Just destroys it immediately and so

438
00:16:28,139 --> 00:16:30,120
this is actually kind of interesting

439
00:16:30,120 --> 00:16:32,639
because if there's any desynchronization

440
00:16:32,639 --> 00:16:34,680
between the initialization routine and

441
00:16:34,680 --> 00:16:36,620
the destruction routine because it's not

442
00:16:36,620 --> 00:16:39,180
maybe normally called in this type of

443
00:16:39,180 --> 00:16:41,279
context there could be some interesting

444
00:16:41,279 --> 00:16:43,680
bugs so we need to look a little bit

445
00:16:43,680 --> 00:16:46,440
closer at what happens so the

446
00:16:46,440 --> 00:16:48,540
destruction routine itself

447
00:16:48,540 --> 00:16:50,459
um basically

448
00:16:50,459 --> 00:16:53,399
um the only thing that's important is

449
00:16:53,399 --> 00:16:55,920
at the bottom it it just ends up calling

450
00:16:55,920 --> 00:16:57,660
into the destruction routine associated

451
00:16:57,660 --> 00:16:59,220
with the given expression that's being

452
00:16:59,220 --> 00:17:00,720
destroyed

453
00:17:00,720 --> 00:17:02,699
um and then at the top like after it

454
00:17:02,699 --> 00:17:04,380
calls that helper function it just frees

455
00:17:04,380 --> 00:17:06,299
the expression and that's all it does so

456
00:17:06,299 --> 00:17:07,859
we need to look specifically at the

457
00:17:07,859 --> 00:17:10,799
Expressions destroy routines

458
00:17:10,799 --> 00:17:13,140
um and yeah so these two expressions I

459
00:17:13,140 --> 00:17:14,520
mentioned

460
00:17:14,520 --> 00:17:16,919
um when when they get initialized they

461
00:17:16,919 --> 00:17:18,540
end up getting bound to the set that

462
00:17:18,540 --> 00:17:20,400
they reference so they call the NF

463
00:17:20,400 --> 00:17:23,819
tables bind set but neither of their

464
00:17:23,819 --> 00:17:26,099
destruction routines actually removes

465
00:17:26,099 --> 00:17:28,140
themselves from the bindings list itself

466
00:17:28,140 --> 00:17:30,120
the normal context in which they get

467
00:17:30,120 --> 00:17:33,360
called they get Unbound first and then

468
00:17:33,360 --> 00:17:34,620
destroyed

469
00:17:34,620 --> 00:17:35,940
so

470
00:17:35,940 --> 00:17:37,380
um this leads to a use after free

471
00:17:37,380 --> 00:17:39,299
because they get destroyed and there's

472
00:17:39,299 --> 00:17:40,919
there's still linkage on the bindings

473
00:17:40,919 --> 00:17:43,559
list pointing to them and that means

474
00:17:43,559 --> 00:17:46,200
that any update to the the linked list

475
00:17:46,200 --> 00:17:48,120
after the fact will

476
00:17:48,120 --> 00:17:50,340
um up like potentially write to a free

477
00:17:50,340 --> 00:17:52,140
chunk or something that's been replaced

478
00:17:52,140 --> 00:17:54,059
which means that we can either write the

479
00:17:54,059 --> 00:17:55,980
address of a set or one of the

480
00:17:55,980 --> 00:17:57,900
Expressions into freed memory or

481
00:17:57,900 --> 00:18:00,000
whatever replaces it

482
00:18:00,000 --> 00:18:01,559
um so this is just an example of like

483
00:18:01,559 --> 00:18:03,600
the dynamic set initialization routine

484
00:18:03,600 --> 00:18:05,280
we can see that it calls the function

485
00:18:05,280 --> 00:18:07,260
that's binding it to the set bindings

486
00:18:07,260 --> 00:18:09,059
doubly linked list the other stuff

487
00:18:09,059 --> 00:18:10,559
doesn't really matter we just know it's

488
00:18:10,559 --> 00:18:12,780
on the list that we're interested in

489
00:18:12,780 --> 00:18:15,240
and then the destruction routine

490
00:18:15,240 --> 00:18:18,000
is a little bit more complicated but

491
00:18:18,000 --> 00:18:20,100
um you can just basically avoid calling

492
00:18:20,100 --> 00:18:21,780
the the first for Loops function

493
00:18:21,780 --> 00:18:24,000
entirely and then it just ends up

494
00:18:24,000 --> 00:18:26,880
calling this NF tables destroy set which

495
00:18:26,880 --> 00:18:30,059
tries to destroy the set itself but only

496
00:18:30,059 --> 00:18:32,520
if the set bindings list is empty and

497
00:18:32,520 --> 00:18:34,140
it's not empty because the expression

498
00:18:34,140 --> 00:18:35,940
just got added to it so basically it

499
00:18:35,940 --> 00:18:38,580
doesn't call it and so effectively the

500
00:18:38,580 --> 00:18:40,980
destruction routine does nothing

501
00:18:40,980 --> 00:18:43,740
um in this particular case so it just

502
00:18:43,740 --> 00:18:45,660
frees the expression and leaves the

503
00:18:45,660 --> 00:18:48,240
entry on the bindings list

504
00:18:48,240 --> 00:18:50,760
um so yeah if if we want to like walk

505
00:18:50,760 --> 00:18:52,440
through the steps of how we would for

506
00:18:52,440 --> 00:18:54,600
instance write the address of a set

507
00:18:54,600 --> 00:18:57,000
um to a free chunk basically you need to

508
00:18:57,000 --> 00:18:59,700
create some valid set that Expressions

509
00:18:59,700 --> 00:19:01,320
um Can reference during the

510
00:19:01,320 --> 00:19:02,820
initialization so that there's a

511
00:19:02,820 --> 00:19:04,860
bindings list that exists for them to

512
00:19:04,860 --> 00:19:06,059
get added to

513
00:19:06,059 --> 00:19:08,100
and then basically we we create the

514
00:19:08,100 --> 00:19:09,960
expression to bind it to that set which

515
00:19:09,960 --> 00:19:12,120
gets added to the list and then we

516
00:19:12,120 --> 00:19:14,340
create a new invalid set

517
00:19:14,340 --> 00:19:17,160
and that invalid set will embed one of

518
00:19:17,160 --> 00:19:20,760
these buggy Expressions

519
00:19:20,760 --> 00:19:23,160
um and so the buggy expression gets

520
00:19:23,160 --> 00:19:25,380
added to the bindings list and then the

521
00:19:25,380 --> 00:19:28,140
code will say oh it's not stateful and

522
00:19:28,140 --> 00:19:31,320
then it gets destroyed

523
00:19:31,320 --> 00:19:32,760
um

524
00:19:32,760 --> 00:19:36,480
and then uh oh actually there's one I I

525
00:19:36,480 --> 00:19:38,700
forgot to mention when I said the second

526
00:19:38,700 --> 00:19:40,260
Point there's an important point when

527
00:19:40,260 --> 00:19:42,900
you create the valid Set uh or initially

528
00:19:42,900 --> 00:19:44,940
if you want to be able to write the

529
00:19:44,940 --> 00:19:46,860
address of the set into the free chunk

530
00:19:46,860 --> 00:19:49,020
you have to buy you have to first bind

531
00:19:49,020 --> 00:19:51,720
some legitimate expression to the set so

532
00:19:51,720 --> 00:19:53,940
that there's a pre-existing

533
00:19:53,940 --> 00:19:56,700
um entry on the bindings list and then

534
00:19:56,700 --> 00:19:59,400
when you create the invalid set the new

535
00:19:59,400 --> 00:20:02,520
expression gets added after that valid

536
00:20:02,520 --> 00:20:05,640
expression entry on the linked list

537
00:20:05,640 --> 00:20:07,200
um and then it gets freed so you've got

538
00:20:07,200 --> 00:20:08,700
a dangling pointer

539
00:20:08,700 --> 00:20:10,860
and then what you do is you destroy the

540
00:20:10,860 --> 00:20:12,480
good expression on the list which

541
00:20:12,480 --> 00:20:14,820
updates the linkage and so basically

542
00:20:14,820 --> 00:20:17,039
it'll it'll write the address of set

543
00:20:17,039 --> 00:20:19,500
bindings into the free pointer or the

544
00:20:19,500 --> 00:20:21,600
free chunk but it I know that that's

545
00:20:21,600 --> 00:20:24,120
kind of hard to understand so I'll go

546
00:20:24,120 --> 00:20:25,980
over it visually because it'll be a bit

547
00:20:25,980 --> 00:20:28,260
easier so in this case on the left we've

548
00:20:28,260 --> 00:20:30,600
got some a valid set that we're going to

549
00:20:30,600 --> 00:20:32,520
get Expressions to reference and then

550
00:20:32,520 --> 00:20:34,620
we've added some legitimate expression

551
00:20:34,620 --> 00:20:37,020
that's just on the bindings list and

552
00:20:37,020 --> 00:20:38,880
then on the right we've got some invalid

553
00:20:38,880 --> 00:20:40,740
set that we're creating and embedded

554
00:20:40,740 --> 00:20:42,480
inside of it is this Dynamic set

555
00:20:42,480 --> 00:20:44,340
expression which is not an okay

556
00:20:44,340 --> 00:20:46,799
expression to have but we can see at

557
00:20:46,799 --> 00:20:48,960
this stage it's already been bound to

558
00:20:48,960 --> 00:20:50,880
the bindings link list

559
00:20:50,880 --> 00:20:54,600
so then the set is deemed invalid so

560
00:20:54,600 --> 00:20:55,280
um

561
00:20:55,280 --> 00:20:58,380
the the dynamic set expression gets

562
00:20:58,380 --> 00:21:00,600
freed and so now the valid expression

563
00:21:00,600 --> 00:21:03,179
has a dangling pointer and now what we

564
00:21:03,179 --> 00:21:05,280
do is we free the

565
00:21:05,280 --> 00:21:07,679
um the valid expression and so then it

566
00:21:07,679 --> 00:21:09,539
updates the prev pointer of the free

567
00:21:09,539 --> 00:21:12,120
chunk with the to point backwards into

568
00:21:12,120 --> 00:21:15,480
set bindings which is our use after free

569
00:21:15,480 --> 00:21:17,220
um yeah and that's basically it so it's

570
00:21:17,220 --> 00:21:19,500
it's fairly Limited in so far as what

571
00:21:19,500 --> 00:21:21,539
you can write um and it doesn't give too

572
00:21:21,539 --> 00:21:25,940
many options to how to exploit it

573
00:21:26,039 --> 00:21:28,740
um so yeah I'd like some ideas

574
00:21:28,740 --> 00:21:31,500
um because we can write a pointer it

575
00:21:31,500 --> 00:21:32,880
would it would kind of be nice to be

576
00:21:32,880 --> 00:21:34,740
able to overwrite some length parameter

577
00:21:34,740 --> 00:21:36,780
so like replace the free chunk with some

578
00:21:36,780 --> 00:21:39,120
other structure value that happens to

579
00:21:39,120 --> 00:21:41,159
have an overlapping length that maybe

580
00:21:41,159 --> 00:21:42,840
gives you an out of boundary to write

581
00:21:42,840 --> 00:21:45,059
that would be like ideal but we didn't

582
00:21:45,059 --> 00:21:47,159
find something like that

583
00:21:47,159 --> 00:21:47,760
um

584
00:21:47,760 --> 00:21:50,700
another idea is to overwrite some

585
00:21:50,700 --> 00:21:52,440
pointer in a structure with the new

586
00:21:52,440 --> 00:21:54,240
pointer that points to set or points to

587
00:21:54,240 --> 00:21:56,220
another expression and maybe let us

588
00:21:56,220 --> 00:22:00,120
build a better use after free primitive

589
00:22:00,120 --> 00:22:01,740
um and then the other obvious thing

590
00:22:01,740 --> 00:22:03,900
would just be to write the pointer into

591
00:22:03,900 --> 00:22:05,400
some buffer that we can leak back to

592
00:22:05,400 --> 00:22:08,460
userline to at least get a limited

593
00:22:08,460 --> 00:22:11,100
um memory revelation

594
00:22:11,100 --> 00:22:11,760
um

595
00:22:11,760 --> 00:22:14,280
so the the first thing we did just for

596
00:22:14,280 --> 00:22:16,200
an easy win and just to help build the

597
00:22:16,200 --> 00:22:17,340
memory model because when you're doing

598
00:22:17,340 --> 00:22:19,200
this stuff it can be confusing so it's

599
00:22:19,200 --> 00:22:21,059
nice to have anything that works we

600
00:22:21,059 --> 00:22:23,340
decided to just leak the address of a

601
00:22:23,340 --> 00:22:25,020
set or expression

602
00:22:25,020 --> 00:22:28,020
um into some like into user land

603
00:22:28,020 --> 00:22:31,620
so how do we leak the data so there's a

604
00:22:31,620 --> 00:22:33,659
pretty popular technique that people

605
00:22:33,659 --> 00:22:35,760
have used in the past for Linux kernel

606
00:22:35,760 --> 00:22:38,100
stuff like this basically the Linux

607
00:22:38,100 --> 00:22:40,020
kernel includes like this key rendering

608
00:22:40,020 --> 00:22:42,059
service where you can just build keys

609
00:22:42,059 --> 00:22:45,120
and add them into the kernel and um you

610
00:22:45,120 --> 00:22:48,059
can basically add your own arbitrary

611
00:22:48,059 --> 00:22:50,700
data into these um

612
00:22:50,700 --> 00:22:54,720
Keys which get allocated using this user

613
00:22:54,720 --> 00:22:57,600
K user key payload structure and because

614
00:22:57,600 --> 00:23:00,120
the size that you provide is variable

615
00:23:00,120 --> 00:23:02,580
you can kind of control which slab cache

616
00:23:02,580 --> 00:23:04,559
it gets allocated on and then you can

617
00:23:04,559 --> 00:23:07,740
read the data back out the the the

618
00:23:07,740 --> 00:23:08,460
um

619
00:23:08,460 --> 00:23:10,320
you know the payload data that you

620
00:23:10,320 --> 00:23:11,760
provided you can read it back out into

621
00:23:11,760 --> 00:23:13,679
userline after the fact it's using this

622
00:23:13,679 --> 00:23:16,140
key cuddle syscall

623
00:23:16,140 --> 00:23:17,580
so

624
00:23:17,580 --> 00:23:19,260
um yeah this when we trigger this bug

625
00:23:19,260 --> 00:23:21,360
using the key stuff I'll refer to it as

626
00:23:21,360 --> 00:23:23,280
use after free one and the set that

627
00:23:23,280 --> 00:23:26,460
we're gonna abuse is called set one

628
00:23:26,460 --> 00:23:28,799
so again exactly the same as before

629
00:23:28,799 --> 00:23:33,419
we've got set one which is uh like the

630
00:23:33,419 --> 00:23:35,100
thing that people our Expressions can

631
00:23:35,100 --> 00:23:36,840
reference the legit expression and then

632
00:23:36,840 --> 00:23:38,100
we're going to use our use after free

633
00:23:38,100 --> 00:23:40,320
Dynamic set so we trigger the state

634
00:23:40,320 --> 00:23:42,659
where it's dangling

635
00:23:42,659 --> 00:23:44,640
um on the bindings list and then we

636
00:23:44,640 --> 00:23:48,000
replace it with user key payload

637
00:23:48,000 --> 00:23:49,799
um and then we unlink the legit

638
00:23:49,799 --> 00:23:51,000
expression

639
00:23:51,000 --> 00:23:53,159
writes the address of set one bindings

640
00:23:53,159 --> 00:23:56,159
into the user key payload and then from

641
00:23:56,159 --> 00:23:58,860
userland we can leak the address of set

642
00:23:58,860 --> 00:24:01,520
one bindings which is nice

643
00:24:01,520 --> 00:24:04,260
but it's not that nice I mean what do

644
00:24:04,260 --> 00:24:06,299
you do with like some random slab cache

645
00:24:06,299 --> 00:24:08,460
address not much

646
00:24:08,460 --> 00:24:11,400
um but it's it it's a good start because

647
00:24:11,400 --> 00:24:12,960
you know like

648
00:24:12,960 --> 00:24:14,780
um you learn how to like you know

649
00:24:14,780 --> 00:24:17,280
exploit the bug a little bit and stuff

650
00:24:17,280 --> 00:24:19,679
and build up the methodology for doing

651
00:24:19,679 --> 00:24:21,780
something a little bit more difficult so

652
00:24:21,780 --> 00:24:23,820
the next step is to try to free some

653
00:24:23,820 --> 00:24:26,880
other object in the kernel

654
00:24:26,880 --> 00:24:27,419
um

655
00:24:27,419 --> 00:24:30,900
so basically the goal here is we want to

656
00:24:30,900 --> 00:24:33,419
find some object that lives on the 48 or

657
00:24:33,419 --> 00:24:35,820
96 byte slab cache so that we can

658
00:24:35,820 --> 00:24:38,220
replace the lookup or dynamic set

659
00:24:38,220 --> 00:24:41,820
structure and we want whatever object we

660
00:24:41,820 --> 00:24:44,039
find that can live there to have pointer

661
00:24:44,039 --> 00:24:46,020
member that happens to overlap with the

662
00:24:46,020 --> 00:24:48,059
offset that we can write during the use

663
00:24:48,059 --> 00:24:49,380
after free write

664
00:24:49,380 --> 00:24:52,200
but the main constraint here is that not

665
00:24:52,200 --> 00:24:53,220
only does there have to be an

666
00:24:53,220 --> 00:24:54,659
overlapping pointer but it's got to be

667
00:24:54,659 --> 00:24:56,760
one that when we destroy whatever the

668
00:24:56,760 --> 00:25:00,659
object that we're writing to it will

669
00:25:00,659 --> 00:25:02,700
also try to free that pointer and that

670
00:25:02,700 --> 00:25:04,740
way we can build like an actual free

671
00:25:04,740 --> 00:25:06,720
primitive so we can freeze something

672
00:25:06,720 --> 00:25:08,580
else

673
00:25:08,580 --> 00:25:12,059
um so basically there's two options here

674
00:25:12,059 --> 00:25:15,360
um because the the pointer you write

675
00:25:15,360 --> 00:25:18,720
um points to the bindings member itself

676
00:25:18,720 --> 00:25:19,980
um and not the beginning of the

677
00:25:19,980 --> 00:25:21,600
expression

678
00:25:21,600 --> 00:25:24,600
um or or the the set it's it's a little

679
00:25:24,600 --> 00:25:26,580
bit quirky so what happens is when you

680
00:25:26,580 --> 00:25:28,200
free it

681
00:25:28,200 --> 00:25:31,020
um you're freeing like

682
00:25:31,020 --> 00:25:33,600
at a misaligned address inside of the

683
00:25:33,600 --> 00:25:36,240
expression or set and so part like the

684
00:25:36,240 --> 00:25:37,740
free will start there and it will

685
00:25:37,740 --> 00:25:40,799
overlap into the adjacent object

686
00:25:40,799 --> 00:25:42,299
um and in the case of the expression

687
00:25:42,299 --> 00:25:44,340
because the bindings member is the last

688
00:25:44,340 --> 00:25:46,679
member of the structure it's actually

689
00:25:46,679 --> 00:25:48,900
kind of quirky and potentially

690
00:25:48,900 --> 00:25:51,120
unreliable and I don't go into too many

691
00:25:51,120 --> 00:25:53,220
details why we didn't use it we'll

692
00:25:53,220 --> 00:25:55,380
release a Blog with details about why

693
00:25:55,380 --> 00:25:58,020
but in the in the case of set the

694
00:25:58,020 --> 00:25:59,340
bindings member is just the second

695
00:25:59,340 --> 00:26:01,620
member so you're basically freeing you

696
00:26:01,620 --> 00:26:03,600
can free all of the set from the second

697
00:26:03,600 --> 00:26:05,580
member onwards and you don't have to

698
00:26:05,580 --> 00:26:08,760
rely on any adjacent object uh being

699
00:26:08,760 --> 00:26:10,559
there on the same slab cache so it's

700
00:26:10,559 --> 00:26:12,480
more reliable

701
00:26:12,480 --> 00:26:13,140
um

702
00:26:13,140 --> 00:26:14,700
yep

703
00:26:14,700 --> 00:26:17,460
so the the question is okay so how do we

704
00:26:17,460 --> 00:26:19,200
find like a structure that actually

705
00:26:19,200 --> 00:26:21,720
meets these requirements um so we use

706
00:26:21,720 --> 00:26:23,400
code ql

707
00:26:23,400 --> 00:26:24,480
um

708
00:26:24,480 --> 00:26:27,059
so basically we just wrote this codeql

709
00:26:27,059 --> 00:26:28,320
query

710
00:26:28,320 --> 00:26:29,820
um and basically you can

711
00:26:29,820 --> 00:26:32,100
um just use queries like this to

712
00:26:32,100 --> 00:26:34,740
um find stuff inside the Linux kernel

713
00:26:34,740 --> 00:26:37,320
matching a set of rules and basically we

714
00:26:37,320 --> 00:26:39,240
just say okay find us some structure

715
00:26:39,240 --> 00:26:40,860
that's allocated from one of the heat

716
00:26:40,860 --> 00:26:42,900
functions that we're interested in that

717
00:26:42,900 --> 00:26:45,840
happens to be of size like 96 bytes so

718
00:26:45,840 --> 00:26:48,360
it's on the right slab cache and the

719
00:26:48,360 --> 00:26:51,000
offset says are the members at specific

720
00:26:51,000 --> 00:26:54,360
offsets are referenced as pointers so it

721
00:26:54,360 --> 00:26:56,520
meets our constraints and then basically

722
00:26:56,520 --> 00:26:58,380
this spits out a list of candidate

723
00:26:58,380 --> 00:26:59,760
structures

724
00:26:59,760 --> 00:27:01,159
um that you still have to go through

725
00:27:01,159 --> 00:27:03,779
manually and then you're looking for

726
00:27:03,779 --> 00:27:04,799
like

727
00:27:04,799 --> 00:27:06,900
um you're still looking to see okay this

728
00:27:06,900 --> 00:27:09,299
structure seems to maybe match can I

729
00:27:09,299 --> 00:27:10,740
allocate this structure from userland

730
00:27:10,740 --> 00:27:13,260
because if not then you can't use it for

731
00:27:13,260 --> 00:27:16,500
like the uh the attack and then also is

732
00:27:16,500 --> 00:27:18,539
the the overlapping member actual

733
00:27:18,539 --> 00:27:21,320
actually freeable on demand

734
00:27:21,320 --> 00:27:25,200
and believe it or not it we did find one

735
00:27:25,200 --> 00:27:28,020
um so there's this C group FS context

736
00:27:28,020 --> 00:27:29,159
structure

737
00:27:29,159 --> 00:27:32,100
which is 96 bytes so it's on this the

738
00:27:32,100 --> 00:27:34,740
right slab cache and basically there's a

739
00:27:34,740 --> 00:27:37,020
member called release agent that happens

740
00:27:37,020 --> 00:27:39,299
to perfectly overlap with the prev

741
00:27:39,299 --> 00:27:41,940
pointer of the bindings

742
00:27:41,940 --> 00:27:45,059
um doubly linked list entry and you can

743
00:27:45,059 --> 00:27:47,340
um you can just allocate them from user

744
00:27:47,340 --> 00:27:50,220
Land by calling this FS open syscall and

745
00:27:50,220 --> 00:27:51,120
then

746
00:27:51,120 --> 00:27:53,340
um when you close the file descriptor

747
00:27:53,340 --> 00:27:55,080
associated with it it will just free

748
00:27:55,080 --> 00:27:56,120
that

749
00:27:56,120 --> 00:27:59,159
structure and it happens to also free

750
00:27:59,159 --> 00:28:01,320
the release agent pointer

751
00:28:01,320 --> 00:28:03,299
so this is just what this structure

752
00:28:03,299 --> 00:28:05,159
looks like you can see there's a name

753
00:28:05,159 --> 00:28:07,140
and release agent members and it

754
00:28:07,140 --> 00:28:08,880
actually both of those actually overlap

755
00:28:08,880 --> 00:28:10,679
with next and prev so we could use

756
00:28:10,679 --> 00:28:12,960
either one and then this is the

757
00:28:12,960 --> 00:28:15,000
destruction routine

758
00:28:15,000 --> 00:28:16,679
so when you're closing the C group this

759
00:28:16,679 --> 00:28:18,240
ends up getting called and we can see it

760
00:28:18,240 --> 00:28:19,799
calls K free on both the name and

761
00:28:19,799 --> 00:28:21,960
release agent member and then it finally

762
00:28:21,960 --> 00:28:23,820
frees the actual structure itself so

763
00:28:23,820 --> 00:28:25,140
this is exactly what we wanted

764
00:28:25,140 --> 00:28:28,919
unfortunately the members line up okay

765
00:28:28,919 --> 00:28:31,620
so so for okay so we found a candidate

766
00:28:31,620 --> 00:28:33,179
structure but we have to actually create

767
00:28:33,179 --> 00:28:36,360
the primitive first to abuse it so this

768
00:28:36,360 --> 00:28:38,580
setting up the Primitive I refer to as

769
00:28:38,580 --> 00:28:40,559
use after free 2 and we'll use a

770
00:28:40,559 --> 00:28:43,080
different set for it so again same as

771
00:28:43,080 --> 00:28:45,600
before we've got Now set two legitimate

772
00:28:45,600 --> 00:28:47,760
expression and some use after free

773
00:28:47,760 --> 00:28:50,760
Dynamic set we free it to trigger the

774
00:28:50,760 --> 00:28:52,919
dangling pointer scenario

775
00:28:52,919 --> 00:28:56,640
this time we replace the free chunk with

776
00:28:56,640 --> 00:28:59,340
C group FS context then we unlink the

777
00:28:59,340 --> 00:29:01,320
expression and now we've got a release

778
00:29:01,320 --> 00:29:04,200
agent member pointing back into set two

779
00:29:04,200 --> 00:29:06,840
at the location of bindings

780
00:29:06,840 --> 00:29:08,700
um and that's basically it like that's

781
00:29:08,700 --> 00:29:10,320
our new

782
00:29:10,320 --> 00:29:12,960
um free primitive it lets us free set

783
00:29:12,960 --> 00:29:15,299
too and so in order to be able to

784
00:29:15,299 --> 00:29:16,860
freeset two

785
00:29:16,860 --> 00:29:17,700
um

786
00:29:17,700 --> 00:29:19,740
yeah we refer to it as use after free

787
00:29:19,740 --> 00:29:22,260
three because it's yeah you can still

788
00:29:22,260 --> 00:29:24,720
operate on the set after it's been freed

789
00:29:24,720 --> 00:29:26,580
because you still have a reference to it

790
00:29:26,580 --> 00:29:29,279
and so we're going to replace that two

791
00:29:29,279 --> 00:29:31,140
um and the what we replace there we

792
00:29:31,140 --> 00:29:33,600
refer to it as fake set one

793
00:29:33,600 --> 00:29:36,419
so this is our free primitive that lets

794
00:29:36,419 --> 00:29:38,880
us free set two basically all we have to

795
00:29:38,880 --> 00:29:42,360
do is close this C Group which will free

796
00:29:42,360 --> 00:29:45,360
the C group FS contact structure and

797
00:29:45,360 --> 00:29:46,500
then basically what happens is

798
00:29:46,500 --> 00:29:48,899
everything after the List member of set

799
00:29:48,899 --> 00:29:52,080
2 is freed so we can replace it with

800
00:29:52,080 --> 00:29:54,539
something else that we want

801
00:29:54,539 --> 00:29:55,200
um

802
00:29:55,200 --> 00:29:57,600
and in this case we use the fuse

803
00:29:57,600 --> 00:29:58,820
userline

804
00:29:58,820 --> 00:30:02,460
driver and a Sysco called set X adder

805
00:30:02,460 --> 00:30:04,799
and I'm this is a really popular

806
00:30:04,799 --> 00:30:08,220
technique lately but basically the idea

807
00:30:08,220 --> 00:30:09,960
is you can create some file in user land

808
00:30:09,960 --> 00:30:14,220
and cause when you when you call like

809
00:30:14,220 --> 00:30:17,279
set X Adder you can supply a path and in

810
00:30:17,279 --> 00:30:19,320
the process of trying to access that

811
00:30:19,320 --> 00:30:21,360
path it goes up through the kernel and

812
00:30:21,360 --> 00:30:23,960
back into userland in a fuse

813
00:30:23,960 --> 00:30:26,820
driver that you basically control so you

814
00:30:26,820 --> 00:30:28,860
can basically pause the kernel while

815
00:30:28,860 --> 00:30:31,200
it's copying data into a chunk and it

816
00:30:31,200 --> 00:30:33,720
allows you to just replace some chunk

817
00:30:33,720 --> 00:30:37,559
with uh effectively arbitrary data at an

818
00:30:37,559 --> 00:30:40,320
almost arbitrary size so it's easy to

819
00:30:40,320 --> 00:30:42,539
create a chunk of the size that we

820
00:30:42,539 --> 00:30:45,059
needed like nft set and just replace it

821
00:30:45,059 --> 00:30:48,779
all with completely controlled values

822
00:30:48,779 --> 00:30:51,559
um so from here what we want to do is

823
00:30:51,559 --> 00:30:53,760
get some sort of memory Revelation

824
00:30:53,760 --> 00:30:54,899
because eventually we're going to want

825
00:30:54,899 --> 00:30:57,840
to bypass kslr and stuff and so if you

826
00:30:57,840 --> 00:30:59,279
think back to the first years after free

827
00:30:59,279 --> 00:31:00,539
we did

828
00:31:00,539 --> 00:31:02,880
um we we leaked some address on the slab

829
00:31:02,880 --> 00:31:04,500
cache which at the time didn't seem that

830
00:31:04,500 --> 00:31:06,659
useful but now it's useful because maybe

831
00:31:06,659 --> 00:31:08,580
we can use that as a

832
00:31:08,580 --> 00:31:11,220
memory Revelation so when we replace

833
00:31:11,220 --> 00:31:13,559
that too with the fake set we basically

834
00:31:13,559 --> 00:31:16,679
can set the U data member to the address

835
00:31:16,679 --> 00:31:19,200
that we leaked from the subcache of set

836
00:31:19,200 --> 00:31:21,600
one we can set the length to the size of

837
00:31:21,600 --> 00:31:24,240
the set one structure and there's one

838
00:31:24,240 --> 00:31:26,460
constraint which is that the name has to

839
00:31:26,460 --> 00:31:28,980
be valid and we end up clobbering it but

840
00:31:28,980 --> 00:31:31,140
you can since we know the address of set

841
00:31:31,140 --> 00:31:34,380
one already we when we create set one

842
00:31:34,380 --> 00:31:36,419
initially we can just pre-populate part

843
00:31:36,419 --> 00:31:38,520
of the user data with some fake name

844
00:31:38,520 --> 00:31:40,559
that we'll use after the fact and then

845
00:31:40,559 --> 00:31:43,200
when we continue to use we access

846
00:31:43,200 --> 00:31:46,320
um set two and fake set via net link we

847
00:31:46,320 --> 00:31:49,919
have some legitimate um way of looking

848
00:31:49,919 --> 00:31:51,899
at the set after the fact

849
00:31:51,899 --> 00:31:54,240
so this lets us leak the contents of set

850
00:31:54,240 --> 00:31:56,700
one back into user land

851
00:31:56,700 --> 00:31:59,100
um which is nice it leaks us the NF

852
00:31:59,100 --> 00:32:00,419
tables

853
00:32:00,419 --> 00:32:02,460
um kernel module data pointer because of

854
00:32:02,460 --> 00:32:04,260
the function pointer table but

855
00:32:04,260 --> 00:32:06,480
unfortunately that is fairly limited for

856
00:32:06,480 --> 00:32:08,940
Rob gadgets so it's not actually as

857
00:32:08,940 --> 00:32:11,640
useful as we wanted but basically this

858
00:32:11,640 --> 00:32:13,140
is what it looks like so when we create

859
00:32:13,140 --> 00:32:15,659
the fake set and we've replaced set to

860
00:32:15,659 --> 00:32:17,580
the name just points to some

861
00:32:17,580 --> 00:32:19,740
pre-existing value that we had populated

862
00:32:19,740 --> 00:32:22,740
in set one during creation U data points

863
00:32:22,740 --> 00:32:24,299
to the beginning of the set we've got

864
00:32:24,299 --> 00:32:26,100
the length that encapsulates the full

865
00:32:26,100 --> 00:32:28,380
set and then that gives us like a

866
00:32:28,380 --> 00:32:32,880
limited leak at least of nftables.ko

867
00:32:32,880 --> 00:32:35,159
but we can do better than that because

868
00:32:35,159 --> 00:32:37,020
we want ideally

869
00:32:37,020 --> 00:32:39,360
um a full kslr bypass so get the address

870
00:32:39,360 --> 00:32:41,279
of VM Linux

871
00:32:41,279 --> 00:32:43,200
um so if you recall way back I said that

872
00:32:43,200 --> 00:32:45,419
there's the the linked list of all the

873
00:32:45,419 --> 00:32:47,520
sets associated with a table

874
00:32:47,520 --> 00:32:49,260
so

875
00:32:49,260 --> 00:32:51,000
um when we create the sets we can

876
00:32:51,000 --> 00:32:52,799
basically put them on the same table and

877
00:32:52,799 --> 00:32:55,020
so when we leak set one we can have the

878
00:32:55,020 --> 00:32:56,880
next pointer of The List member actually

879
00:32:56,880 --> 00:32:59,700
pointing back to the fake set so we can

880
00:32:59,700 --> 00:33:01,860
leak the address of the fake set as well

881
00:33:01,860 --> 00:33:03,960
which will be useful in the future

882
00:33:03,960 --> 00:33:06,720
because then we know where data is we

883
00:33:06,720 --> 00:33:07,880
fully control

884
00:33:07,880 --> 00:33:10,200
a little bit later

885
00:33:10,200 --> 00:33:12,899
and then um on the previous slide I had

886
00:33:12,899 --> 00:33:14,460
said well we can say UD land to the size

887
00:33:14,460 --> 00:33:16,320
of set one well actually it's not

888
00:33:16,320 --> 00:33:19,260
limited to that size so we can leak uh

889
00:33:19,260 --> 00:33:22,019
objects adjacent to set one as well so

890
00:33:22,019 --> 00:33:25,260
basically what we found a good candidate

891
00:33:25,260 --> 00:33:29,279
was was the these tdys uh structures

892
00:33:29,279 --> 00:33:32,519
that live on the 1024 byte slab cache

893
00:33:32,519 --> 00:33:34,440
and basically you just open this

894
00:33:34,440 --> 00:33:36,600
pseudo-terminal path and every time you

895
00:33:36,600 --> 00:33:38,399
open one it it

896
00:33:38,399 --> 00:33:40,440
um allocates one of these structures on

897
00:33:40,440 --> 00:33:42,120
the slab cache so basically you can just

898
00:33:42,120 --> 00:33:43,500
spray a whole bunch of these structures

899
00:33:43,500 --> 00:33:46,320
then allocate set one and be reasonably

900
00:33:46,320 --> 00:33:48,899
sure that there's a TDY structure

901
00:33:48,899 --> 00:33:50,640
adjacent to it and even if there's not

902
00:33:50,640 --> 00:33:52,919
you can start from scratch the one

903
00:33:52,919 --> 00:33:55,260
exception to it would be if when you

904
00:33:55,260 --> 00:33:57,360
allocate set one it happens to be the

905
00:33:57,360 --> 00:33:58,620
last

906
00:33:58,620 --> 00:33:59,419
um

907
00:33:59,419 --> 00:34:02,279
object on the slab cache in which case

908
00:34:02,279 --> 00:34:03,600
there's not necessarily going to be

909
00:34:03,600 --> 00:34:06,120
anything adjacent but because we leaked

910
00:34:06,120 --> 00:34:08,520
the address of set one early on we can

911
00:34:08,520 --> 00:34:10,980
actually compute Which slot it is on the

912
00:34:10,980 --> 00:34:13,679
slab cache and if it's the last one we

913
00:34:13,679 --> 00:34:17,219
just try again basically yeah

914
00:34:17,219 --> 00:34:19,500
um so this is nice because it will allow

915
00:34:19,500 --> 00:34:22,020
us to leak the address from VM Linux and

916
00:34:22,020 --> 00:34:25,560
this is because the TDY structure has an

917
00:34:25,560 --> 00:34:27,960
Ops function

918
00:34:27,960 --> 00:34:30,119
um pointer table and this structure has

919
00:34:30,119 --> 00:34:32,639
also been used previously in a couple

920
00:34:32,639 --> 00:34:35,040
public Linux kernel exploits so it's

921
00:34:35,040 --> 00:34:37,560
fairly well known but so this is what

922
00:34:37,560 --> 00:34:39,300
basically the op like the modified

923
00:34:39,300 --> 00:34:41,699
scenario looks like is we just have some

924
00:34:41,699 --> 00:34:44,520
TDY structure adjacent to set one on the

925
00:34:44,520 --> 00:34:47,159
slab cache and we've just modified the

926
00:34:47,159 --> 00:34:50,280
user data length to encapsulate both

927
00:34:50,280 --> 00:34:50,960
um

928
00:34:50,960 --> 00:34:53,159
chunks and then we can just read it all

929
00:34:53,159 --> 00:34:55,260
and in this case instead of like reading

930
00:34:55,260 --> 00:34:57,839
set one to Ops we read ddy strikes Ops

931
00:34:57,839 --> 00:35:00,060
and that gives us the the dot data

932
00:35:00,060 --> 00:35:03,060
address to bypass like in VM Linux which

933
00:35:03,060 --> 00:35:06,359
allows us to bypass kslr

934
00:35:06,359 --> 00:35:09,240
um so so the next phase is like okay we

935
00:35:09,240 --> 00:35:11,220
bypass kslr how do we actually get code

936
00:35:11,220 --> 00:35:14,099
execution out of this

937
00:35:14,099 --> 00:35:17,400
um so the idea is like we need to put

938
00:35:17,400 --> 00:35:19,740
the kslr adjusted pointers in memory

939
00:35:19,740 --> 00:35:21,359
somewhere

940
00:35:21,359 --> 00:35:23,220
um but fortunately we just leaked the

941
00:35:23,220 --> 00:35:26,160
address of fake set one uh while we were

942
00:35:26,160 --> 00:35:29,760
reading set one itself and because of

943
00:35:29,760 --> 00:35:32,220
fuse and set X Adder we basically can

944
00:35:32,220 --> 00:35:34,920
choose when we free the chunk and we can

945
00:35:34,920 --> 00:35:37,380
just reallocate it so basically we can

946
00:35:37,380 --> 00:35:39,480
just free fake set one on demand and

947
00:35:39,480 --> 00:35:42,119
replace it with a new fake set but this

948
00:35:42,119 --> 00:35:43,800
time we know the address of where it's

949
00:35:43,800 --> 00:35:46,079
going to live so we can put the kslr

950
00:35:46,079 --> 00:35:50,040
adjusted pointers into fake set two

951
00:35:50,040 --> 00:35:52,800
um and so this case because it's yet

952
00:35:52,800 --> 00:35:54,780
another new chunk that's replacing set

953
00:35:54,780 --> 00:35:58,440
two I call it use after free four and

954
00:35:58,440 --> 00:36:00,240
then we're replacing fakes that one with

955
00:36:00,240 --> 00:36:02,700
fake set two basically and and the idea

956
00:36:02,700 --> 00:36:04,500
is we can just now point the function

957
00:36:04,500 --> 00:36:07,260
pointer table of fake set two back into

958
00:36:07,260 --> 00:36:10,320
itself at some offset inside the inline

959
00:36:10,320 --> 00:36:13,020
data and that area can have the kslr

960
00:36:13,020 --> 00:36:14,960
adjusted point owners

961
00:36:14,960 --> 00:36:18,599
so yeah basically we just free the set X

962
00:36:18,599 --> 00:36:20,579
Adder chunk by unblocking fuse and

963
00:36:20,579 --> 00:36:22,859
letting the read complete and then we

964
00:36:22,859 --> 00:36:25,920
just use fuse and set Etc again to

965
00:36:25,920 --> 00:36:28,200
replace fake set 2 in the exact same

966
00:36:28,200 --> 00:36:31,380
slot on the slab cache

967
00:36:31,380 --> 00:36:33,359
um and then that basically lets us

968
00:36:33,359 --> 00:36:34,940
control the function

969
00:36:34,940 --> 00:36:38,339
pointer table so now the idea is we're

970
00:36:38,339 --> 00:36:39,480
going to call one of these function

971
00:36:39,480 --> 00:36:40,980
pointers from this function pointer

972
00:36:40,980 --> 00:36:43,980
table but it's fairly limited as far as

973
00:36:43,980 --> 00:36:45,720
like register control goes and stuff

974
00:36:45,720 --> 00:36:48,240
basically half the functions you have

975
00:36:48,240 --> 00:36:51,240
RDI and R14 pointing back into fake set

976
00:36:51,240 --> 00:36:53,760
two and then the other half is RSI and

977
00:36:53,760 --> 00:36:56,160
R12 but because fake said 2 is

978
00:36:56,160 --> 00:36:58,800
completely controlled in memory it's not

979
00:36:58,800 --> 00:37:00,720
too bad because you can maybe find some

980
00:37:00,720 --> 00:37:03,240
Gadget that is referencing interesting

981
00:37:03,240 --> 00:37:05,400
data at some offset from those registers

982
00:37:05,400 --> 00:37:07,440
and then using it

983
00:37:07,440 --> 00:37:10,440
um you know in an interesting way and we

984
00:37:10,440 --> 00:37:12,960
just use the Rob Gadget hunting tool RP

985
00:37:12,960 --> 00:37:14,760
we didn't do anything fancy for that I'm

986
00:37:14,760 --> 00:37:18,000
just gripping for the the relevant

987
00:37:18,000 --> 00:37:19,200
registers

988
00:37:19,200 --> 00:37:22,140
and so yeah we ended up finding of not

989
00:37:22,140 --> 00:37:25,260
so much a gadget but an actual function

990
00:37:25,260 --> 00:37:27,000
um which is just basically responsible

991
00:37:27,000 --> 00:37:28,859
for unlinking something from a doubly

992
00:37:28,859 --> 00:37:30,420
linked list

993
00:37:30,420 --> 00:37:32,760
um and so again I I had said that RDI is

994
00:37:32,760 --> 00:37:34,380
one of the registers that points into

995
00:37:34,380 --> 00:37:37,740
fake set two so you can see RDI plus

996
00:37:37,740 --> 00:37:40,740
hex60 will overlap with some of the

997
00:37:40,740 --> 00:37:43,820
fields and it get read into Rax and

998
00:37:43,820 --> 00:37:47,760
uh hex offset 68 gets rid into RDX and

999
00:37:47,760 --> 00:37:50,280
then it basically just writes Rex to RDX

1000
00:37:50,280 --> 00:37:52,440
so this immediately is like an eight

1001
00:37:52,440 --> 00:37:55,740
byte right primitive that we can use

1002
00:37:55,740 --> 00:37:58,380
um and then as usual with unlinking

1003
00:37:58,380 --> 00:37:59,820
something from a doubly linked list it

1004
00:37:59,820 --> 00:38:01,740
will also try to write the other pointer

1005
00:38:01,740 --> 00:38:05,280
back so in this case RDX will be written

1006
00:38:05,280 --> 00:38:08,280
back into Rax which is a potential

1007
00:38:08,280 --> 00:38:10,920
problem because it will oops if Rex is

1008
00:38:10,920 --> 00:38:13,220
actually like an arbitrary value

1009
00:38:13,220 --> 00:38:15,660
and so the question is does the oops

1010
00:38:15,660 --> 00:38:16,680
matter

1011
00:38:16,680 --> 00:38:20,460
and it does not because on Ubuntu they

1012
00:38:20,460 --> 00:38:22,320
basically use this CIS cuddle setting

1013
00:38:22,320 --> 00:38:25,140
called Panic on oops and they set it to

1014
00:38:25,140 --> 00:38:29,940
zero and so basically as long as like an

1015
00:38:29,940 --> 00:38:31,920
oops happens in like a non-critical

1016
00:38:31,920 --> 00:38:34,619
kernel path the kernel just says okay

1017
00:38:34,619 --> 00:38:36,960
just like pause or terminate that thread

1018
00:38:36,960 --> 00:38:39,359
and then just keep going but at that

1019
00:38:39,359 --> 00:38:41,040
point we've already triggered the first

1020
00:38:41,040 --> 00:38:43,200
eight byte right to a control like a

1021
00:38:43,200 --> 00:38:45,780
controlled address so that's kind of all

1022
00:38:45,780 --> 00:38:46,820
we need

1023
00:38:46,820 --> 00:38:49,859
interestingly like afterwards I think

1024
00:38:49,859 --> 00:38:53,099
fairly recently Star Labs released a

1025
00:38:53,099 --> 00:38:55,140
Blog that they talk about using a

1026
00:38:55,140 --> 00:38:57,960
similar function called list delete I'm

1027
00:38:57,960 --> 00:39:00,720
pretty sure it's almost identical

1028
00:39:00,720 --> 00:39:01,980
um and they did something similar but

1029
00:39:01,980 --> 00:39:04,500
they actually could avoid the oops by

1030
00:39:04,500 --> 00:39:06,359
abusing fizmap which I don't have time

1031
00:39:06,359 --> 00:39:08,520
to get into it was really cool technique

1032
00:39:08,520 --> 00:39:10,140
so worth reading about that as well but

1033
00:39:10,140 --> 00:39:11,940
we didn't need to worry about his map at

1034
00:39:11,940 --> 00:39:14,040
all because fortunately the Ubuntu was

1035
00:39:14,040 --> 00:39:16,320
the Target and we just let it oops and

1036
00:39:16,320 --> 00:39:19,380
there's a like a little stack Trace in

1037
00:39:19,380 --> 00:39:21,300
in D message and that's it so we don't

1038
00:39:21,300 --> 00:39:22,500
really care especially for something

1039
00:39:22,500 --> 00:39:24,540
like pone to own

1040
00:39:24,540 --> 00:39:27,480
um so then so

1041
00:39:27,480 --> 00:39:29,220
um the question is how do we invoke the

1042
00:39:29,220 --> 00:39:31,560
gadget so we chose to use this garbage

1043
00:39:31,560 --> 00:39:33,839
collection initialization routine just

1044
00:39:33,839 --> 00:39:36,000
because it was with the values that we

1045
00:39:36,000 --> 00:39:40,260
overwrite in nft set in order to use the

1046
00:39:40,260 --> 00:39:43,320
gadget it had them the least constrained

1047
00:39:43,320 --> 00:39:45,480
sort of code path to trigger but

1048
00:39:45,480 --> 00:39:47,280
basically you just need to

1049
00:39:47,280 --> 00:39:48,380
um

1050
00:39:48,380 --> 00:39:50,820
initialize some expression that has this

1051
00:39:50,820 --> 00:39:52,920
garbage collection flag associated with

1052
00:39:52,920 --> 00:39:54,660
it which there currently only seems to

1053
00:39:54,660 --> 00:39:56,160
be one in the kernel called connection

1054
00:39:56,160 --> 00:39:57,839
limit

1055
00:39:57,839 --> 00:39:59,579
um and as long as like when you're

1056
00:39:59,579 --> 00:40:01,859
initializing that expression this flag

1057
00:40:01,859 --> 00:40:05,099
is set then it will just call GC in it

1058
00:40:05,099 --> 00:40:06,900
um yeah and that's pretty much all you

1059
00:40:06,900 --> 00:40:07,859
need to do

1060
00:40:07,859 --> 00:40:10,560
so probably

1061
00:40:10,560 --> 00:40:12,960
um unsurprisingly we targeted mod Pro

1062
00:40:12,960 --> 00:40:15,060
path just because it's like the path of

1063
00:40:15,060 --> 00:40:17,820
least resistance no pun intended

1064
00:40:17,820 --> 00:40:20,420
um and it's super well documented

1065
00:40:20,420 --> 00:40:22,859
technique by now and basically the

1066
00:40:22,859 --> 00:40:26,060
kernel just has a writable string

1067
00:40:26,060 --> 00:40:29,280
that and the string is basically used to

1068
00:40:29,280 --> 00:40:32,000
run something responsible for handling

1069
00:40:32,000 --> 00:40:34,859
module loading at runtime so userland

1070
00:40:34,859 --> 00:40:37,680
tries to trigger some functionality and

1071
00:40:37,680 --> 00:40:39,599
there's no module loaded so it tries to

1072
00:40:39,599 --> 00:40:43,440
execute this path as root

1073
00:40:43,440 --> 00:40:44,400
um

1074
00:40:44,400 --> 00:40:47,339
and so you can just overwrite it so in

1075
00:40:47,339 --> 00:40:49,020
this case we are limited to eight bytes

1076
00:40:49,020 --> 00:40:52,500
but we can just write like temp slash X

1077
00:40:52,500 --> 00:40:54,300
um and just we control temp X on the

1078
00:40:54,300 --> 00:40:56,839
system so we can run that as a root

1079
00:40:56,839 --> 00:40:59,339
obviously like in real world scenarios

1080
00:40:59,339 --> 00:41:00,900
like outside of something like pone to

1081
00:41:00,900 --> 00:41:03,060
own there's some limitations with like

1082
00:41:03,060 --> 00:41:05,160
being able to write just a short string

1083
00:41:05,160 --> 00:41:07,320
like this for instance temp might be

1084
00:41:07,320 --> 00:41:09,540
mounted as non-executable

1085
00:41:09,540 --> 00:41:12,839
um and then like if you're

1086
00:41:12,839 --> 00:41:14,579
um trying to exploit it from inside of a

1087
00:41:14,579 --> 00:41:17,760
container for instance your slash temp X

1088
00:41:17,760 --> 00:41:20,599
is not going to be the same light path

1089
00:41:20,599 --> 00:41:24,119
as what the uh whatever is running the

1090
00:41:24,119 --> 00:41:25,140
module

1091
00:41:25,140 --> 00:41:25,800
um

1092
00:41:25,800 --> 00:41:29,640
like the mod Pro path binaries temp path

1093
00:41:29,640 --> 00:41:31,140
is going to be because typically like

1094
00:41:31,140 --> 00:41:33,000
they'll use overlay paths and they'll be

1095
00:41:33,000 --> 00:41:35,460
like a guide or something so like you

1096
00:41:35,460 --> 00:41:38,520
wouldn't control temp X in the actual

1097
00:41:38,520 --> 00:41:39,240
um

1098
00:41:39,240 --> 00:41:42,180
the right context so but in our case we

1099
00:41:42,180 --> 00:41:43,320
didn't care because we were just trying

1100
00:41:43,320 --> 00:41:46,800
to do it for bone to own so it's enough

1101
00:41:46,800 --> 00:41:48,359
um yeah so basically that's what it

1102
00:41:48,359 --> 00:41:49,619
looks like

1103
00:41:49,619 --> 00:41:50,400
um

1104
00:41:50,400 --> 00:41:53,400
once we've crafted fake set two you can

1105
00:41:53,400 --> 00:41:56,900
see that now the Ops pointer points into

1106
00:41:56,900 --> 00:41:59,220
the structure itself which we can do

1107
00:41:59,220 --> 00:42:01,800
again because we leaked the address of

1108
00:42:01,800 --> 00:42:03,960
fake said to when we leaked the contents

1109
00:42:03,960 --> 00:42:05,820
of set one

1110
00:42:05,820 --> 00:42:07,380
um and then we just have like the fake

1111
00:42:07,380 --> 00:42:09,359
function pointer table where GC init

1112
00:42:09,359 --> 00:42:12,359
points to the gadget and we can see that

1113
00:42:12,359 --> 00:42:15,780
the gadget will reference a couple

1114
00:42:15,780 --> 00:42:18,839
members in fake set 2 field count and

1115
00:42:18,839 --> 00:42:20,940
use and then number of elements and

1116
00:42:20,940 --> 00:42:22,680
another one

1117
00:42:22,680 --> 00:42:24,540
um but fortunately for the code path to

1118
00:42:24,540 --> 00:42:26,820
hit GC in it the none of those members

1119
00:42:26,820 --> 00:42:28,440
actually get referenced so we just don't

1120
00:42:28,440 --> 00:42:30,720
care we can just put arbitrary data

1121
00:42:30,720 --> 00:42:33,599
there and that's basically enough to

1122
00:42:33,599 --> 00:42:37,020
overwrite mod Pro path

1123
00:42:37,020 --> 00:42:39,119
um so just to go back from the very

1124
00:42:39,119 --> 00:42:41,820
beginning so there's basically four use

1125
00:42:41,820 --> 00:42:43,440
after freeze I guess

1126
00:42:43,440 --> 00:42:45,359
um that are getting triggered the first

1127
00:42:45,359 --> 00:42:47,520
one we

1128
00:42:47,520 --> 00:42:49,800
um we end up using the user key payload

1129
00:42:49,800 --> 00:42:52,140
in order to leak the address of set one

1130
00:42:52,140 --> 00:42:54,420
in memory

1131
00:42:54,420 --> 00:42:57,599
um the second one we end up uh also

1132
00:42:57,599 --> 00:42:58,980
triggering the use after free of a

1133
00:42:58,980 --> 00:43:00,960
dynamic set and replace the the

1134
00:43:00,960 --> 00:43:03,119
structure with a c group FS context

1135
00:43:03,119 --> 00:43:05,040
which lets us overwrite release agent

1136
00:43:05,040 --> 00:43:07,619
and then when we destroy the really or

1137
00:43:07,619 --> 00:43:09,540
the C group it ends up freeing release

1138
00:43:09,540 --> 00:43:12,060
agent which allows us to free most of

1139
00:43:12,060 --> 00:43:13,920
set two

1140
00:43:13,920 --> 00:43:15,780
um and then we can replace that too with

1141
00:43:15,780 --> 00:43:18,119
fake set one

1142
00:43:18,119 --> 00:43:20,819
um and then that allows us to read set

1143
00:43:20,819 --> 00:43:22,440
one's

1144
00:43:22,440 --> 00:43:23,099
um

1145
00:43:23,099 --> 00:43:25,260
yeah structure from memory which allows

1146
00:43:25,260 --> 00:43:27,240
us to bypass kslr

1147
00:43:27,240 --> 00:43:29,220
and then finally we replace fig set one

1148
00:43:29,220 --> 00:43:31,980
with fixed two in order to execute the

1149
00:43:31,980 --> 00:43:33,900
rock Gadget

1150
00:43:33,900 --> 00:43:35,819
um and then yeah over a mod probe and

1151
00:43:35,819 --> 00:43:37,440
then all you have to do from user land

1152
00:43:37,440 --> 00:43:39,420
is try to trigger some functionality

1153
00:43:39,420 --> 00:43:42,000
that there's no module for and then you

1154
00:43:42,000 --> 00:43:45,000
basically get root

1155
00:43:45,000 --> 00:43:46,619
um yep

1156
00:43:46,619 --> 00:43:48,240
so

1157
00:43:48,240 --> 00:43:49,920
um basically the way they patched this

1158
00:43:49,920 --> 00:43:52,140
was a little bit different than we

1159
00:43:52,140 --> 00:43:53,460
thought because we thought maybe they

1160
00:43:53,460 --> 00:43:55,220
would just modify the destroy routines

1161
00:43:55,220 --> 00:43:57,540
to unbind

1162
00:43:57,540 --> 00:44:00,119
um from the set but they did something a

1163
00:44:00,119 --> 00:44:02,099
little bit more robust which is that

1164
00:44:02,099 --> 00:44:04,500
they don't initialize the non-stateful

1165
00:44:04,500 --> 00:44:06,839
Expressions at all when you're creating

1166
00:44:06,839 --> 00:44:09,060
the set so basically they're never gonna

1167
00:44:09,060 --> 00:44:11,460
do the allocation or anything so you

1168
00:44:11,460 --> 00:44:14,280
basically avoid any case where you have

1169
00:44:14,280 --> 00:44:16,319
desynchronization between initialization

1170
00:44:16,319 --> 00:44:19,680
and destruction which is good because

1171
00:44:19,680 --> 00:44:22,380
well good and bad because it also fixed

1172
00:44:22,380 --> 00:44:24,480
a separate bug that we had found also

1173
00:44:24,480 --> 00:44:26,579
related to the desynchronization and I

1174
00:44:26,579 --> 00:44:30,000
think there is probably a lot more there

1175
00:44:30,000 --> 00:44:31,920
um I wouldn't be surprised if yeah other

1176
00:44:31,920 --> 00:44:33,900
people had found some of those

1177
00:44:33,900 --> 00:44:37,980
but we can see in the patch

1178
00:44:37,980 --> 00:44:40,680
um basically when it's doing the this

1179
00:44:40,680 --> 00:44:43,020
expression initialization stuff what it

1180
00:44:43,020 --> 00:44:45,060
does first is it parses out the

1181
00:44:45,060 --> 00:44:47,339
information about the the expression

1182
00:44:47,339 --> 00:44:49,619
into like a little structure without

1183
00:44:49,619 --> 00:44:51,240
actually calling the initialization

1184
00:44:51,240 --> 00:44:53,520
routine or allocating it and then it

1185
00:44:53,520 --> 00:44:55,800
checks the flag from

1186
00:44:55,800 --> 00:44:56,640
um

1187
00:44:56,640 --> 00:45:00,420
the the data it collected first and then

1188
00:45:00,420 --> 00:45:03,000
uh if it's non-stateful it exits and

1189
00:45:03,000 --> 00:45:05,480
only afterwards will it actually try to

1190
00:45:05,480 --> 00:45:09,859
allocate it if it's the right type

1191
00:45:09,859 --> 00:45:11,579
so

1192
00:45:11,579 --> 00:45:15,060
um yeah in conclusion I guess

1193
00:45:15,060 --> 00:45:17,460
um I think NF tables is probably going

1194
00:45:17,460 --> 00:45:20,760
to have a lot more bugs like uh I showed

1195
00:45:20,760 --> 00:45:22,079
there's quite a few blogs about it

1196
00:45:22,079 --> 00:45:23,760
already I won't be surprised if there's

1197
00:45:23,760 --> 00:45:26,040
more this year

1198
00:45:26,040 --> 00:45:28,140
um and as far as like what made it

1199
00:45:28,140 --> 00:45:30,240
easier obviously like unprivileged

1200
00:45:30,240 --> 00:45:32,520
namespaces are bad

1201
00:45:32,520 --> 00:45:35,460
um so I guess people should disable them

1202
00:45:35,460 --> 00:45:37,440
if they can

1203
00:45:37,440 --> 00:45:38,220
um

1204
00:45:38,220 --> 00:45:40,800
in which some distros do this Panic on

1205
00:45:40,800 --> 00:45:43,040
oops thing seems dangerous

1206
00:45:43,040 --> 00:45:45,480
everybody's been using fuse server and

1207
00:45:45,480 --> 00:45:47,880
sedex Adder ever since user fault FD got

1208
00:45:47,880 --> 00:45:49,920
killed so it seems still super powerful

1209
00:45:49,920 --> 00:45:53,700
and mod Pro path is pretty common

1210
00:45:53,700 --> 00:45:55,260
um I guess one of the things that's kind

1211
00:45:55,260 --> 00:45:57,359
of interesting aside about exploiting

1212
00:45:57,359 --> 00:46:00,000
this bug aside from the fact that it was

1213
00:46:00,000 --> 00:46:01,920
kind of limited and and so far as what

1214
00:46:01,920 --> 00:46:03,240
you could write

1215
00:46:03,240 --> 00:46:05,400
um to the free chunk is a lot of

1216
00:46:05,400 --> 00:46:07,020
exploits lately have been using this

1217
00:46:07,020 --> 00:46:09,000
message message structure in order to

1218
00:46:09,000 --> 00:46:12,839
build like arbitrary read Primitives and

1219
00:46:12,839 --> 00:46:16,020
um write Primitives and stuff but in uh

1220
00:46:16,020 --> 00:46:17,400
well in this case we didn't have to use

1221
00:46:17,400 --> 00:46:18,839
it but actually in this case we couldn't

1222
00:46:18,839 --> 00:46:21,300
use it anyways because

1223
00:46:21,300 --> 00:46:24,420
um you know Ubuntu 22.04 when they

1224
00:46:24,420 --> 00:46:27,839
upgraded to 5.15 there was a change in

1225
00:46:27,839 --> 00:46:30,300
this lab cache

1226
00:46:30,300 --> 00:46:34,079
sort of um layout so message message is

1227
00:46:34,079 --> 00:46:37,619
now I think accounted there's like some

1228
00:46:37,619 --> 00:46:39,960
new accounting like bucketing for slab

1229
00:46:39,960 --> 00:46:41,579
caches so

1230
00:46:41,579 --> 00:46:43,260
um you basically can't allocate the

1231
00:46:43,260 --> 00:46:45,359
message message structures to replace

1232
00:46:45,359 --> 00:46:47,760
certain types of other objects you might

1233
00:46:47,760 --> 00:46:50,280
want to use during use after free so

1234
00:46:50,280 --> 00:46:52,319
it's kind of interesting just that we

1235
00:46:52,319 --> 00:46:53,700
didn't have to use it because everybody

1236
00:46:53,700 --> 00:46:56,400
likes to use it lately and yeah if you

1237
00:46:56,400 --> 00:46:58,940
just spend enough time understanding

1238
00:46:58,940 --> 00:47:02,579
the underlying code and stuff like Sam

1239
00:47:02,579 --> 00:47:05,099
mentioned in his presentation you can

1240
00:47:05,099 --> 00:47:08,220
find typically ways to abuse you know

1241
00:47:08,220 --> 00:47:10,440
the place that you're already working on

1242
00:47:10,440 --> 00:47:14,160
to find Primitives and whatnot

1243
00:47:14,160 --> 00:47:15,599
um yeah so as far as like some

1244
00:47:15,599 --> 00:47:17,579
mitigations go like how to avoid these

1245
00:47:17,579 --> 00:47:19,440
there's some pretty obvious stuff I

1246
00:47:19,440 --> 00:47:21,660
think the thing that was surprising to

1247
00:47:21,660 --> 00:47:24,780
me the most was probably that I when we

1248
00:47:24,780 --> 00:47:27,119
first had the idea of like freeing set

1249
00:47:27,119 --> 00:47:29,940
bindings address or expression bindings

1250
00:47:29,940 --> 00:47:33,000
address I assumed that given that a slab

1251
00:47:33,000 --> 00:47:34,740
cache is

1252
00:47:34,740 --> 00:47:37,500
um broken up into like objects of the

1253
00:47:37,500 --> 00:47:40,200
same size it would check whether or not

1254
00:47:40,200 --> 00:47:42,359
you're freeing a misaligned address

1255
00:47:42,359 --> 00:47:44,040
because I don't think there's a

1256
00:47:44,040 --> 00:47:45,660
legitimate reason why you would ever do

1257
00:47:45,660 --> 00:47:47,760
that maybe there is and I'm not aware so

1258
00:47:47,760 --> 00:47:49,980
if you know tell me but I feel like they

1259
00:47:49,980 --> 00:47:51,960
could probably just prevent that in the

1260
00:47:51,960 --> 00:47:53,940
future which would at least make things

1261
00:47:53,940 --> 00:47:56,339
a lot more annoying and then there's

1262
00:47:56,339 --> 00:47:57,420
other

1263
00:47:57,420 --> 00:47:58,339
um

1264
00:47:58,339 --> 00:48:01,140
mitigations that are kind of coming out

1265
00:48:01,140 --> 00:48:03,240
or been around for a while Jr security

1266
00:48:03,240 --> 00:48:05,880
has one called Auto slab and I think

1267
00:48:05,880 --> 00:48:07,440
like last week or something Google

1268
00:48:07,440 --> 00:48:09,480
posted some information about some

1269
00:48:09,480 --> 00:48:11,220
experimental mitigations that they're

1270
00:48:11,220 --> 00:48:12,780
working on that are coming out of the

1271
00:48:12,780 --> 00:48:15,660
kctf challenges which is for targeting

1272
00:48:15,660 --> 00:48:17,339
like kubernetes

1273
00:48:17,339 --> 00:48:19,260
um sandboxes and using kernel

1274
00:48:19,260 --> 00:48:21,359
exploitation to break out but the idea

1275
00:48:21,359 --> 00:48:22,740
is like

1276
00:48:22,740 --> 00:48:25,920
um all slab caches will have like OB

1277
00:48:25,920 --> 00:48:28,260
will be object specific so if you

1278
00:48:28,260 --> 00:48:30,599
allocate like the dynamic expression

1279
00:48:30,599 --> 00:48:33,599
structures on some slab cache and then

1280
00:48:33,599 --> 00:48:35,940
you free one you can't replace that with

1281
00:48:35,940 --> 00:48:38,700
a different like some C group FS context

1282
00:48:38,700 --> 00:48:40,020
structure it will just prevent that

1283
00:48:40,020 --> 00:48:41,940
entirely

1284
00:48:41,940 --> 00:48:43,560
um and if you're familiar with stuff

1285
00:48:43,560 --> 00:48:45,300
that people have been doing like in the

1286
00:48:45,300 --> 00:48:47,099
last year or so with targeting like the

1287
00:48:47,099 --> 00:48:49,140
buddy allocator you might think okay

1288
00:48:49,140 --> 00:48:51,930
well even if I can't replace the

1289
00:48:51,930 --> 00:48:52,140
[Music]

1290
00:48:52,140 --> 00:48:53,099
um

1291
00:48:53,099 --> 00:48:55,200
the object with a different type maybe I

1292
00:48:55,200 --> 00:48:57,960
can free the entire slab cache and

1293
00:48:57,960 --> 00:48:59,819
replace it with a new slab cache after

1294
00:48:59,819 --> 00:49:01,500
the fact

1295
00:49:01,500 --> 00:49:03,480
um well with totally different object

1296
00:49:03,480 --> 00:49:05,099
types and and people have been doing

1297
00:49:05,099 --> 00:49:07,380
that already lately I think there's been

1298
00:49:07,380 --> 00:49:09,480
a few blog yeah three blog posts maybe

1299
00:49:09,480 --> 00:49:11,280
in the last year

1300
00:49:11,280 --> 00:49:13,619
um but I think autoslab has some

1301
00:49:13,619 --> 00:49:15,300
functionality to avoid this and and

1302
00:49:15,300 --> 00:49:17,819
Google's mitigations

1303
00:49:17,819 --> 00:49:20,760
um their proposal anyway seems to have

1304
00:49:20,760 --> 00:49:23,040
some ideas about preventing this

1305
00:49:23,040 --> 00:49:26,099
so any memory that's ever been used for

1306
00:49:26,099 --> 00:49:28,319
a slab cache of a specific object can't

1307
00:49:28,319 --> 00:49:30,180
be used for a different type of slab

1308
00:49:30,180 --> 00:49:32,280
cache after the fact so that will be

1309
00:49:32,280 --> 00:49:34,079
kind of interesting but I don't know

1310
00:49:34,079 --> 00:49:37,079
um if I'll actually make it to uh

1311
00:49:37,079 --> 00:49:38,579
Mainline anytime soon because there's

1312
00:49:38,579 --> 00:49:40,260
lots of cool mitigations that exist that

1313
00:49:40,260 --> 00:49:42,839
don't make it which leads me to like

1314
00:49:42,839 --> 00:49:45,000
control flow Integrity so that's been

1315
00:49:45,000 --> 00:49:47,099
around inside Android for a while

1316
00:49:47,099 --> 00:49:49,319
already but I haven't heard lately any

1317
00:49:49,319 --> 00:49:53,040
like movement for getting that on x64

1318
00:49:53,040 --> 00:49:56,339
and that would at least prevent the rock

1319
00:49:56,339 --> 00:49:59,339
Gadget execution stuff

1320
00:49:59,339 --> 00:50:01,560
um and then other obvious stuff you

1321
00:50:01,560 --> 00:50:03,060
could set Panic on oops to one which

1322
00:50:03,060 --> 00:50:05,040
would at least prevent the um the gadget

1323
00:50:05,040 --> 00:50:06,540
that we use but there could be other

1324
00:50:06,540 --> 00:50:09,420
gadgets and stuff and I suspect in the

1325
00:50:09,420 --> 00:50:10,680
real world it's pretty inconvenient

1326
00:50:10,680 --> 00:50:12,660
because if you just occasionally look at

1327
00:50:12,660 --> 00:50:14,760
your D message output you might notice

1328
00:50:14,760 --> 00:50:16,920
things like Ubuntu

1329
00:50:16,920 --> 00:50:19,619
um semi-regularly well oops and then if

1330
00:50:19,619 --> 00:50:21,119
every time that took your box down it

1331
00:50:21,119 --> 00:50:23,819
might be kind of annoying

1332
00:50:23,819 --> 00:50:26,160
um and then yeah so there is like a

1333
00:50:26,160 --> 00:50:28,980
config option called config static user

1334
00:50:28,980 --> 00:50:30,540
mode helper which

1335
00:50:30,540 --> 00:50:34,260
um makes mod probe path read only and I

1336
00:50:34,260 --> 00:50:36,420
don't know why it's not used by default

1337
00:50:36,420 --> 00:50:40,140
on Ubuntu and certain other kernels if

1338
00:50:40,140 --> 00:50:42,660
you know why it's not by default I'd be

1339
00:50:42,660 --> 00:50:43,980
curious because I don't know a

1340
00:50:43,980 --> 00:50:45,480
legitimate use case that people are

1341
00:50:45,480 --> 00:50:47,400
regularly doing

1342
00:50:47,400 --> 00:50:49,260
um that warrants being able to update

1343
00:50:49,260 --> 00:50:51,240
the path I assume there's one but I

1344
00:50:51,240 --> 00:50:53,520
don't know what it is and then yeah like

1345
00:50:53,520 --> 00:50:55,020
some distros just don't allow

1346
00:50:55,020 --> 00:50:56,880
unprivileged namespaces which just

1347
00:50:56,880 --> 00:50:58,920
removes this entire attack surface which

1348
00:50:58,920 --> 00:51:01,200
is I guess better than almost anything

1349
00:51:01,200 --> 00:51:02,220
else

1350
00:51:02,220 --> 00:51:03,839
and then you could always get rid of

1351
00:51:03,839 --> 00:51:06,839
userline view server support and stuff

1352
00:51:06,839 --> 00:51:08,520
but there's a fair bit of stuff that

1353
00:51:08,520 --> 00:51:10,200
relies on fuse now so it might be a

1354
00:51:10,200 --> 00:51:12,960
little bit harder to do

1355
00:51:12,960 --> 00:51:15,839
um yeah so that's basically it um we're

1356
00:51:15,839 --> 00:51:17,700
gonna release a Blog with like a bunch

1357
00:51:17,700 --> 00:51:19,319
more details

1358
00:51:19,319 --> 00:51:22,559
um and a few more diagrams and stuff

1359
00:51:22,559 --> 00:51:24,480
and this was a team effort so like I

1360
00:51:24,480 --> 00:51:26,400
said it's a team of three

1361
00:51:26,400 --> 00:51:27,480
um so

1362
00:51:27,480 --> 00:51:29,460
different parts we we all worked on

1363
00:51:29,460 --> 00:51:32,280
together so it's Cedric and Alex and I

1364
00:51:32,280 --> 00:51:34,319
did it together and we are hiring we're

1365
00:51:34,319 --> 00:51:35,940
looking for a fourth person so if you

1366
00:51:35,940 --> 00:51:37,380
find this kind of stuff interesting and

1367
00:51:37,380 --> 00:51:39,300
potentially want to do it with us you

1368
00:51:39,300 --> 00:51:41,460
can check out the link in the slides

1369
00:51:41,460 --> 00:51:43,559
when I share them or

1370
00:51:43,559 --> 00:51:46,319
um you can find me

1371
00:51:46,319 --> 00:51:50,280
um yep and one last just random tidbit

1372
00:51:50,280 --> 00:51:52,920
um which is not related to anything I

1373
00:51:52,920 --> 00:51:54,599
just talked about but

1374
00:51:54,599 --> 00:51:57,000
so for the last like maybe 10 plus years

1375
00:51:57,000 --> 00:51:58,680
I have really bad repetitive strain

1376
00:51:58,680 --> 00:52:01,559
injury and so about two or three years

1377
00:52:01,559 --> 00:52:03,960
ago like I had to basically stop using

1378
00:52:03,960 --> 00:52:06,119
my hands for using computers entirely

1379
00:52:06,119 --> 00:52:09,000
and the most and so I've been doing all

1380
00:52:09,000 --> 00:52:11,099
of my research using a voice coding

1381
00:52:11,099 --> 00:52:13,440
framework and an eye tracker machine for

1382
00:52:13,440 --> 00:52:15,059
like tracking my eyes instead of using a

1383
00:52:15,059 --> 00:52:18,359
mouse and I use this free tool called

1384
00:52:18,359 --> 00:52:21,000
Talon which is amazing

1385
00:52:21,000 --> 00:52:23,220
um and there's a lot of Open Source Code

1386
00:52:23,220 --> 00:52:25,260
surrounding it to help people that have

1387
00:52:25,260 --> 00:52:26,579
these kind of disabilities or whatever

1388
00:52:26,579 --> 00:52:28,980
use it and keep doing research so I just

1389
00:52:28,980 --> 00:52:30,240
wanted to give a shout out to that

1390
00:52:30,240 --> 00:52:31,500
project

1391
00:52:31,500 --> 00:52:32,760
um because otherwise I probably wouldn't

1392
00:52:32,760 --> 00:52:35,280
be able to keep doing my job at all and

1393
00:52:35,280 --> 00:52:37,200
just say like

1394
00:52:37,200 --> 00:52:38,819
um try to take care of your hands and

1395
00:52:38,819 --> 00:52:40,380
your posture and stuff because if you

1396
00:52:40,380 --> 00:52:42,119
don't 20 years later it can catch up

1397
00:52:42,119 --> 00:52:45,240
with you and it really really sucks

1398
00:52:45,240 --> 00:52:47,819
um yep so that's it this should say

1399
00:52:47,819 --> 00:52:50,540
questions but

1400
00:52:53,460 --> 00:52:55,200
oh thank you very much Aaron for that

1401
00:52:55,200 --> 00:52:56,400
talk will you give me a round of

1402
00:52:56,400 --> 00:52:56,780
applause

1403
00:52:56,780 --> 00:52:57,400
[Music]

1404
00:52:57,400 --> 00:53:02,940
[Applause]

1405
00:53:02,940 --> 00:53:04,859
so we have a couple of questions up on

1406
00:53:04,859 --> 00:53:06,359
the screen here and just a reminder if

1407
00:53:06,359 --> 00:53:07,559
you are in the room and you'd like to

1408
00:53:07,559 --> 00:53:09,599
ask any questions you can use slido for

1409
00:53:09,599 --> 00:53:10,859
doing that

1410
00:53:10,859 --> 00:53:12,480
so we'll start off with the top one

1411
00:53:12,480 --> 00:53:15,180
there what does your process tooling for

1412
00:53:15,180 --> 00:53:16,859
searching and enumerating New Primitives

1413
00:53:16,859 --> 00:53:18,660
look like for example is it

1414
00:53:18,660 --> 00:53:20,819
predominantly automated via code ql

1415
00:53:20,819 --> 00:53:23,700
manual auditing or a mix

1416
00:53:23,700 --> 00:53:25,559
yeah I would say it's mostly manually

1417
00:53:25,559 --> 00:53:27,119
auditing

1418
00:53:27,119 --> 00:53:28,619
um like a lot of it is first just

1419
00:53:28,619 --> 00:53:30,780
trolling the existing

1420
00:53:30,780 --> 00:53:34,500
um tooling or and and blogs and stuff

1421
00:53:34,500 --> 00:53:36,000
that exist because a lot of the time

1422
00:53:36,000 --> 00:53:37,800
like there might be some one-off

1423
00:53:37,800 --> 00:53:39,839
scenario that someone already talked

1424
00:53:39,839 --> 00:53:41,040
about and at the time you weren't

1425
00:53:41,040 --> 00:53:42,960
interested in what's in there so a lot

1426
00:53:42,960 --> 00:53:44,700
of it is just like actually reading

1427
00:53:44,700 --> 00:53:46,920
stuff that is at least Loosely related

1428
00:53:46,920 --> 00:53:49,200
to the same topic that's not exactly the

1429
00:53:49,200 --> 00:53:52,859
same Target just to get some ideas I

1430
00:53:52,859 --> 00:53:54,720
personally mostly just look manually

1431
00:53:54,720 --> 00:53:56,940
like I try to understand

1432
00:53:56,940 --> 00:53:59,220
um and I mean manually like grepping for

1433
00:53:59,220 --> 00:54:01,079
stuff or whatever

1434
00:54:01,079 --> 00:54:03,119
um but

1435
00:54:03,119 --> 00:54:06,059
um Alex specifically has had good

1436
00:54:06,059 --> 00:54:08,760
success using code ql for automating

1437
00:54:08,760 --> 00:54:10,619
stuff and and in the case of like

1438
00:54:10,619 --> 00:54:12,839
finding this C Group C or FS contact

1439
00:54:12,839 --> 00:54:15,420
structure it really worked well so I

1440
00:54:15,420 --> 00:54:16,140
think

1441
00:54:16,140 --> 00:54:19,800
um we'll probably start using it more uh

1442
00:54:19,800 --> 00:54:22,680
I had not used it before so I think it

1443
00:54:22,680 --> 00:54:24,960
will become a mix more afterwards yeah

1444
00:54:24,960 --> 00:54:26,640
awesome thank you very much

1445
00:54:26,640 --> 00:54:30,000
and second there in your view have Linux

1446
00:54:30,000 --> 00:54:31,800
kernel vulnerabilities been increasingly

1447
00:54:31,800 --> 00:54:34,559
hard to find over the years if so why do

1448
00:54:34,559 --> 00:54:36,180
you think this trend exists or does it

1449
00:54:36,180 --> 00:54:37,800
not

1450
00:54:37,800 --> 00:54:42,359
um I I would say not and but like

1451
00:54:42,359 --> 00:54:44,420
um

1452
00:54:44,460 --> 00:54:47,579
I I mean it's hard to say like so a long

1453
00:54:47,579 --> 00:54:49,500
long time ago like say 15 years or

1454
00:54:49,500 --> 00:54:51,119
whatever you could just kind of grab the

1455
00:54:51,119 --> 00:54:52,859
source code and just find bugs like they

1456
00:54:52,859 --> 00:54:55,020
just fall out of this guy

1457
00:54:55,020 --> 00:54:57,180
um and so in that sense it's easier but

1458
00:54:57,180 --> 00:54:58,800
now that there's good fuzzers like if

1459
00:54:58,800 --> 00:55:00,300
you look at the amount of bugs that

1460
00:55:00,300 --> 00:55:02,520
something like sis caller can drop out

1461
00:55:02,520 --> 00:55:04,079
and if you look at the results of

1462
00:55:04,079 --> 00:55:06,720
something like that like sizzbot which

1463
00:55:06,720 --> 00:55:09,180
is Google's like fuzzing infrastructure

1464
00:55:09,180 --> 00:55:11,940
that uses sis caller there's tons and

1465
00:55:11,940 --> 00:55:13,559
tons of bugs that are just not even

1466
00:55:13,559 --> 00:55:15,000
triaged

1467
00:55:15,000 --> 00:55:16,800
um and and in the example of the one we

1468
00:55:16,800 --> 00:55:19,440
did it turns out it like it just closed

1469
00:55:19,440 --> 00:55:22,440
as invalid which clearly it was valid

1470
00:55:22,440 --> 00:55:24,119
um and and so in that sense I think

1471
00:55:24,119 --> 00:55:25,740
because of the

1472
00:55:25,740 --> 00:55:27,900
um Improvement in the ability of fuzzers

1473
00:55:27,900 --> 00:55:30,900
to find more harder to find by hand but

1474
00:55:30,900 --> 00:55:32,760
like manually find bugs like use after

1475
00:55:32,760 --> 00:55:36,420
freeze it's actually become easier

1476
00:55:36,420 --> 00:55:38,400
um and and I think it's just easier to

1477
00:55:38,400 --> 00:55:40,920
augment fuzzers and stuff now than it

1478
00:55:40,920 --> 00:55:42,420
used to be because there's such a good

1479
00:55:42,420 --> 00:55:46,079
Corpus of like uh like there's a whole

1480
00:55:46,079 --> 00:55:48,480
Community like you know in our industry

1481
00:55:48,480 --> 00:55:50,400
that loves fuzzing and they share tons

1482
00:55:50,400 --> 00:55:52,260
of details about how to customize

1483
00:55:52,260 --> 00:55:53,880
grammars and all this kind of stuff so

1484
00:55:53,880 --> 00:55:56,520
in that sense it's become easier I think

1485
00:55:56,520 --> 00:55:58,680
I would say that there's more

1486
00:55:58,680 --> 00:56:01,260
I remember like before maybe

1487
00:56:01,260 --> 00:56:03,780
it's just less more attention now less

1488
00:56:03,780 --> 00:56:05,520
attention in the past but I remember

1489
00:56:05,520 --> 00:56:08,280
like times when maybe in a year you'd

1490
00:56:08,280 --> 00:56:11,099
hear maybe like two or three cool Linux

1491
00:56:11,099 --> 00:56:13,440
kernel bugs but now I feel like every

1492
00:56:13,440 --> 00:56:16,200
other week there's some potentially

1493
00:56:16,200 --> 00:56:18,359
exploitable bugs so yeah I think it's

1494
00:56:18,359 --> 00:56:20,040
gotten easier

1495
00:56:20,040 --> 00:56:22,260
um and yeah I don't hopefully that

1496
00:56:22,260 --> 00:56:23,700
answers the question yeah thank you very

1497
00:56:23,700 --> 00:56:25,380
much for the detailed answers and thank

1498
00:56:25,380 --> 00:56:26,700
you to those who have asked questions in

1499
00:56:26,700 --> 00:56:28,020
the audience please join me again in

1500
00:56:28,020 --> 00:56:30,040
thanking everyone again thank you

1501
00:56:30,040 --> 00:56:30,090
[Applause]

1502
00:56:30,090 --> 00:56:33,289
[Music]

