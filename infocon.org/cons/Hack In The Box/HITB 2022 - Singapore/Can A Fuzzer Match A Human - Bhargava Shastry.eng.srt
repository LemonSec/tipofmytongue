1
00:00:06,000 --> 00:00:08,639
good evening everyone if you wanted to

2
00:00:08,639 --> 00:00:11,219
know if and how a compiler can silently

3
00:00:11,219 --> 00:00:13,679
introduce vulnerabilities this talk is

4
00:00:13,679 --> 00:00:16,139
for you it was time the way it is

5
00:00:16,139 --> 00:00:18,240
because the ultimate aim of bug finding

6
00:00:18,240 --> 00:00:20,640
is to somehow match human capabilities

7
00:00:20,640 --> 00:00:23,300
to do so

8
00:00:25,080 --> 00:00:27,420
hello cannot keep the suspense simply

9
00:00:27,420 --> 00:00:29,519
because let's face it our fuzzer today

10
00:00:29,519 --> 00:00:32,040
is no match for a human in terms of

11
00:00:32,040 --> 00:00:34,260
writing tests that would ultimately

12
00:00:34,260 --> 00:00:36,239
discover vulnerabilities

13
00:00:36,239 --> 00:00:39,059
but it can definitely slowly get us

14
00:00:39,059 --> 00:00:41,700
there at the moment it can still flag

15
00:00:41,700 --> 00:00:44,460
interesting Corner cases that make my

16
00:00:44,460 --> 00:00:47,219
colleagues sometimes go oh wow I hadn't

17
00:00:47,219 --> 00:00:49,440
considered that and these are people who

18
00:00:49,440 --> 00:00:51,239
are developing features and writing

19
00:00:51,239 --> 00:00:52,980
tests for it so that is something I

20
00:00:52,980 --> 00:00:55,339
would say

21
00:00:56,000 --> 00:00:57,420
[Music]

22
00:00:57,420 --> 00:00:59,760
a quick summary of my talk if you're

23
00:00:59,760 --> 00:01:02,219
feeling a bit impatient already one of

24
00:01:02,219 --> 00:01:03,840
the first steps in creating a security

25
00:01:03,840 --> 00:01:05,580
testing framework is to define the

26
00:01:05,580 --> 00:01:08,100
threat model in other words what are the

27
00:01:08,100 --> 00:01:09,600
class of bugs we are interested in

28
00:01:09,600 --> 00:01:11,939
finding a positive debt

29
00:01:11,939 --> 00:01:14,100
for us in the Solarity compiler team

30
00:01:14,100 --> 00:01:16,320
there is mostly those arcs that result

31
00:01:16,320 --> 00:01:19,140
in incorrect code generation

32
00:01:19,140 --> 00:01:21,360
a compiler is not only expected to

33
00:01:21,360 --> 00:01:22,380
translate

34
00:01:22,380 --> 00:01:24,659
high level program to a low level one

35
00:01:24,659 --> 00:01:27,240
Faithfully but also optimize it for

36
00:01:27,240 --> 00:01:30,540
Optimum resource usage now we can

37
00:01:30,540 --> 00:01:33,900
tolerate unoptimized resource usage

38
00:01:33,900 --> 00:01:37,020
sometimes it's not a critical threat but

39
00:01:37,020 --> 00:01:39,479
it is a critical threat if it produces

40
00:01:39,479 --> 00:01:42,320
incorrect code

41
00:01:42,420 --> 00:01:45,180
to catch past the result in incorrect

42
00:01:45,180 --> 00:01:46,619
fourth generation we use semantic

43
00:01:46,619 --> 00:01:49,439
pausing framework uh using this approach

44
00:01:49,439 --> 00:01:51,720
we have found 22 bugs

45
00:01:51,720 --> 00:01:54,060
and we continue to deploy this approach

46
00:01:54,060 --> 00:01:58,680
for early early bug discovery

47
00:01:58,680 --> 00:01:59,399
um

48
00:01:59,399 --> 00:02:01,799
sorry we continue to use this approach

49
00:02:01,799 --> 00:02:04,799
for early bug Discovery and I'm glad to

50
00:02:04,799 --> 00:02:07,140
share that virtually no you will

51
00:02:07,140 --> 00:02:09,598
optimize a bug has been found

52
00:02:09,598 --> 00:02:11,580
post-release in the past two years

53
00:02:11,580 --> 00:02:14,700
thanks in a large part uh thanks for the

54
00:02:14,700 --> 00:02:18,679
most part to fuzzing

55
00:02:20,879 --> 00:02:23,459
about me I'm a security engineer in the

56
00:02:23,459 --> 00:02:25,140
solidity compiler team in the ethereum

57
00:02:25,140 --> 00:02:27,660
foundation most of my work revolves

58
00:02:27,660 --> 00:02:29,760
around using current testing Frameworks

59
00:02:29,760 --> 00:02:32,160
to find security critical bugs in the

60
00:02:32,160 --> 00:02:33,840
celebrity compiler hopefully before the

61
00:02:33,840 --> 00:02:36,040
compiler is shipped to end users

62
00:02:36,040 --> 00:02:37,580
[Music]

63
00:02:37,580 --> 00:02:40,400
let's get started

64
00:02:40,400 --> 00:02:42,660
the compiler like I said is a program

65
00:02:42,660 --> 00:02:44,640
that translates high-level program into

66
00:02:44,640 --> 00:02:46,860
a low-level machine code

67
00:02:46,860 --> 00:02:48,660
in the case of the similarity compiler

68
00:02:48,660 --> 00:02:50,580
the input program is a solidity smart

69
00:02:50,580 --> 00:02:54,300
contract most often and expected output

70
00:02:54,300 --> 00:02:56,519
is the ethereum virtual machine byte

71
00:02:56,519 --> 00:02:58,860
code shown on the right side

72
00:02:58,860 --> 00:03:01,280
and in the process of getting there

73
00:03:01,280 --> 00:03:04,379
the compiler essentially passes the

74
00:03:04,379 --> 00:03:06,660
input program converts it into an

75
00:03:06,660 --> 00:03:07,980
intermediate representation and

76
00:03:07,980 --> 00:03:10,019
optimizes that representation as much as

77
00:03:10,019 --> 00:03:13,319
possible before basically bringing it

78
00:03:13,319 --> 00:03:16,019
down to the Machine level by means of

79
00:03:16,019 --> 00:03:19,379
assembly so it has these four high level

80
00:03:19,379 --> 00:03:21,540
components

81
00:03:21,540 --> 00:03:24,560
inside it

82
00:03:24,900 --> 00:03:27,300
the salinity compiler actually comprises

83
00:03:27,300 --> 00:03:29,760
two largely semantically equivalent code

84
00:03:29,760 --> 00:03:33,780
generators one is IR based IR stands for

85
00:03:33,780 --> 00:03:35,459
intermediate representation

86
00:03:35,459 --> 00:03:37,440
please note that I'm going to be using

87
00:03:37,440 --> 00:03:39,540
the terms ir and you will

88
00:03:39,540 --> 00:03:42,900
interchangeably because U is the name of

89
00:03:42,900 --> 00:03:44,519
the intermediate representation that

90
00:03:44,519 --> 00:03:46,379
solidity uses

91
00:03:46,379 --> 00:03:49,799
so the new IR based code generator that

92
00:03:49,799 --> 00:03:52,140
has been recently um marked for

93
00:03:52,140 --> 00:03:54,180
production use

94
00:03:54,180 --> 00:03:56,879
is shown on the top and the Legacy code

95
00:03:56,879 --> 00:03:59,340
generator that has been in use since the

96
00:03:59,340 --> 00:04:02,700
early release is shown at the bottom the

97
00:04:02,700 --> 00:04:05,040
main difference is that the Legacy code

98
00:04:05,040 --> 00:04:08,340
generator directly converts solitary

99
00:04:08,340 --> 00:04:10,920
program into a byte code representation

100
00:04:10,920 --> 00:04:13,620
and Optimizer set whereas the IR based

101
00:04:13,620 --> 00:04:16,798
code generator first brexit brings the

102
00:04:16,798 --> 00:04:19,019
Solarity program down to the Yule level

103
00:04:19,019 --> 00:04:22,580
and uh thereafter works at the U level

104
00:04:22,580 --> 00:04:24,540
in the

105
00:04:24,540 --> 00:04:27,300
process of optimizing and assembling

106
00:04:27,300 --> 00:04:29,960
the code

107
00:04:30,680 --> 00:04:33,180
as I mentioned in the summary slide our

108
00:04:33,180 --> 00:04:35,540
thread model is

109
00:04:35,540 --> 00:04:39,180
not the compiler user or the programmer

110
00:04:39,180 --> 00:04:41,460
but box I'll be introduced by the

111
00:04:41,460 --> 00:04:44,040
compiler itself and this could be any of

112
00:04:44,040 --> 00:04:45,660
the three components Optimizer code

113
00:04:45,660 --> 00:04:48,000
generator or the assembler

114
00:04:48,000 --> 00:04:50,160
partial bugs are specifically out of

115
00:04:50,160 --> 00:04:51,479
scope for the purpose of this

116
00:04:51,479 --> 00:04:54,720
presentation but we do use a puzzle to

117
00:04:54,720 --> 00:04:57,660
continuously find our parcel Box by

118
00:04:57,660 --> 00:05:00,479
means of continuous testing

119
00:05:00,479 --> 00:05:03,060
and these most often looked like

120
00:05:03,060 --> 00:05:06,210
internal compiler errors

121
00:05:06,210 --> 00:05:08,699
[Music]

122
00:05:08,699 --> 00:05:10,560
now the slide is targeted at those of

123
00:05:10,560 --> 00:05:12,360
you who may be familiar with fast

124
00:05:12,360 --> 00:05:13,320
testing

125
00:05:13,320 --> 00:05:15,479
in a nutshell fuzzing is the process of

126
00:05:15,479 --> 00:05:18,240
feeding random mutations of an initial

127
00:05:18,240 --> 00:05:20,940
set of inputs to the program under test

128
00:05:20,940 --> 00:05:23,520
until it crashes or you have a

129
00:05:23,520 --> 00:05:25,139
sufficient assurance that the program

130
00:05:25,139 --> 00:05:26,880
has been well tested

131
00:05:26,880 --> 00:05:28,979
as simple as it sounds traditionally it

132
00:05:28,979 --> 00:05:30,720
has been very effective at finding

133
00:05:30,720 --> 00:05:33,600
vulnerabilities most often exploitable

134
00:05:33,600 --> 00:05:35,220
volume please

135
00:05:35,220 --> 00:05:38,220
so what you see on the slide is a simple

136
00:05:38,220 --> 00:05:40,860
while loop which runs until eternity

137
00:05:40,860 --> 00:05:44,820
unless you quit using Ctrl C and in each

138
00:05:44,820 --> 00:05:48,300
iteration a random program is generated

139
00:05:48,300 --> 00:05:51,120
a random input sorry is generated and

140
00:05:51,120 --> 00:05:52,620
this input is back to the program under

141
00:05:52,620 --> 00:05:54,419
test

142
00:05:54,419 --> 00:05:56,400
um and usually there is some sort of

143
00:05:56,400 --> 00:05:58,080
runtime monitoring to check if the

144
00:05:58,080 --> 00:06:00,740
program went correctly or not

145
00:06:00,740 --> 00:06:03,199
[Music]

146
00:06:03,199 --> 00:06:06,240
there is a caveat though I said random

147
00:06:06,240 --> 00:06:08,100
input generation is very effective in

148
00:06:08,100 --> 00:06:10,380
general but it's not really well suited

149
00:06:10,380 --> 00:06:12,479
for compilers the main reason for this

150
00:06:12,479 --> 00:06:14,759
is that most mutation or changes don't

151
00:06:14,759 --> 00:06:17,639
existing test input render it unpossible

152
00:06:17,639 --> 00:06:20,699
for example if we put randomly mutate

153
00:06:20,699 --> 00:06:23,100
the smart contract shown on the left

154
00:06:23,100 --> 00:06:25,259
which is syntactically well formed

155
00:06:25,259 --> 00:06:27,419
assuming that do something actually does

156
00:06:27,419 --> 00:06:31,319
something syntactically meaningful

157
00:06:31,319 --> 00:06:33,720
most often custom off-the-shelf puzzles

158
00:06:33,720 --> 00:06:36,840
would mutated at the byte level tweet

159
00:06:36,840 --> 00:06:39,960
and make the program impossible for

160
00:06:39,960 --> 00:06:41,460
example by messing with the function

161
00:06:41,460 --> 00:06:43,979
keyboard or the public keyword and this

162
00:06:43,979 --> 00:06:46,319
is quickly rejected by the parser this

163
00:06:46,319 --> 00:06:49,319
is a problem because our main intention

164
00:06:49,319 --> 00:06:51,300
is to find code generation bugs and you

165
00:06:51,300 --> 00:06:52,919
cannot find code generation blocks

166
00:06:52,919 --> 00:06:55,680
without having possible programs

167
00:06:55,680 --> 00:06:57,740
[Music]

168
00:06:57,740 --> 00:06:59,280
so

169
00:06:59,280 --> 00:07:00,960
um to summarize what we need is an

170
00:07:00,960 --> 00:07:03,000
approach that understands what a program

171
00:07:03,000 --> 00:07:05,400
valid program looks like and generate

172
00:07:05,400 --> 00:07:07,800
such a wildlife program using some form

173
00:07:07,800 --> 00:07:09,960
of structural awareness by structural

174
00:07:09,960 --> 00:07:11,639
awareness I mean

175
00:07:11,639 --> 00:07:13,560
um having a sense of what program

176
00:07:13,560 --> 00:07:15,780
language grammar looks like and what a

177
00:07:15,780 --> 00:07:18,300
semantically valid program means

178
00:07:18,300 --> 00:07:19,300
foreign

179
00:07:19,300 --> 00:07:22,340
[Music]

180
00:07:22,340 --> 00:07:24,840
in the next few slides I am going to

181
00:07:24,840 --> 00:07:27,110
outline our approach

182
00:07:27,110 --> 00:07:28,800
[Music]

183
00:07:28,800 --> 00:07:31,080
we approach input test program

184
00:07:31,080 --> 00:07:33,919
generation in two different ways

185
00:07:33,919 --> 00:07:36,479
initially we took the protobuf approach

186
00:07:36,479 --> 00:07:38,819
that is using protobuf Library written

187
00:07:38,819 --> 00:07:40,080
by Google to generate program

188
00:07:40,080 --> 00:07:42,120
specifications that are eventually

189
00:07:42,120 --> 00:07:44,759
turned into a test program later we felt

190
00:07:44,759 --> 00:07:46,199
that this introduced in additional

191
00:07:46,199 --> 00:07:49,800
dependency that is uh we had to

192
00:07:49,800 --> 00:07:51,479
essentially compile

193
00:07:51,479 --> 00:07:54,120
and build the first organ split

194
00:07:54,120 --> 00:07:55,560
photograph and lip photograph of your

195
00:07:55,560 --> 00:07:59,819
Theta to externally shift libraries and

196
00:07:59,819 --> 00:08:02,400
we decided to write the solidity program

197
00:08:02,400 --> 00:08:04,919
generator from scratch and this is the

198
00:08:04,919 --> 00:08:05,880
new

199
00:08:05,880 --> 00:08:07,860
um input generation strategy that we're

200
00:08:07,860 --> 00:08:09,960
using the advantage is that we don't

201
00:08:09,960 --> 00:08:11,580
have any external dependencies and it's

202
00:08:11,580 --> 00:08:14,599
written purely in C plus

203
00:08:16,580 --> 00:08:19,620
now finding a bug requires a reference

204
00:08:19,620 --> 00:08:20,699
point

205
00:08:20,699 --> 00:08:23,580
uh which we don't have remember that an

206
00:08:23,580 --> 00:08:26,759
incorrect code generation bug is only

207
00:08:26,759 --> 00:08:29,220
deemed to be incorrect if we know what

208
00:08:29,220 --> 00:08:31,020
is correct but we don't have a reference

209
00:08:31,020 --> 00:08:32,458
for what's correct

210
00:08:32,458 --> 00:08:34,440
to solve this problem we employ

211
00:08:34,440 --> 00:08:36,539
differential testing so what we do is we

212
00:08:36,539 --> 00:08:37,919
have two

213
00:08:37,919 --> 00:08:39,599
uh two arms

214
00:08:39,599 --> 00:08:43,740
so to speak a Baseline and an experiment

215
00:08:43,740 --> 00:08:46,080
this could be for example unoptimized

216
00:08:46,080 --> 00:08:49,500
and optimized code or Legacy and IR

217
00:08:49,500 --> 00:08:51,540
based code generators

218
00:08:51,540 --> 00:08:53,700
now we test both of them on the same

219
00:08:53,700 --> 00:08:56,580
input at the same time and see what they

220
00:08:56,580 --> 00:08:58,440
do if they do the same thing then

221
00:08:58,440 --> 00:09:00,000
they're doing it correctly they don't do

222
00:09:00,000 --> 00:09:01,680
the same thing then one of them is wrong

223
00:09:01,680 --> 00:09:05,279
and this is flagged as an incorrect uh

224
00:09:05,279 --> 00:09:07,860
code generation bug for manual pre-ash

225
00:09:07,860 --> 00:09:09,420
data

226
00:09:09,420 --> 00:09:11,459
now to find out what they're doing we

227
00:09:11,459 --> 00:09:13,980
use execution tracing and largely this

228
00:09:13,980 --> 00:09:17,100
means that we make use of an ebm client

229
00:09:17,100 --> 00:09:19,320
to monitor the state of the program

230
00:09:19,320 --> 00:09:21,480
during execution

231
00:09:21,480 --> 00:09:23,880
or the you will interpreter you're gonna

232
00:09:23,880 --> 00:09:25,380
get to each of these things a little

233
00:09:25,380 --> 00:09:28,980
later now

234
00:09:29,590 --> 00:09:29,700
[Music]

235
00:09:29,700 --> 00:09:31,560
um

236
00:09:31,560 --> 00:09:33,959
about the input generation I I told you

237
00:09:33,959 --> 00:09:36,120
that we have a fully fledged C plus plus

238
00:09:36,120 --> 00:09:38,399
only solidity program generator

239
00:09:38,399 --> 00:09:41,279
essentially what this does is each each

240
00:09:41,279 --> 00:09:43,820
iteration it generates a random

241
00:09:43,820 --> 00:09:46,200
semantically valid solidity program and

242
00:09:46,200 --> 00:09:48,300
feeds it to the component under test

243
00:09:48,300 --> 00:09:51,980
it's essentially what it does

244
00:09:51,980 --> 00:09:54,300
input generation is based on the

245
00:09:54,300 --> 00:09:57,120
photobuff approach which I outlined in

246
00:09:57,120 --> 00:09:58,620
the previous slide and this is slightly

247
00:09:58,620 --> 00:10:00,000
more complicated

248
00:10:00,000 --> 00:10:02,760
it involves three steps first we write a

249
00:10:02,760 --> 00:10:06,480
specification in the product of language

250
00:10:06,480 --> 00:10:08,640
this um

251
00:10:08,640 --> 00:10:11,279
contains a fundamental unit called a

252
00:10:11,279 --> 00:10:13,500
message and it allows us to build a

253
00:10:13,500 --> 00:10:15,300
bottom of specification of the language

254
00:10:15,300 --> 00:10:17,220
wherein for example we can define a

255
00:10:17,220 --> 00:10:19,500
basic block to be a set of statements

256
00:10:19,500 --> 00:10:21,300
and upwards the program as a set of

257
00:10:21,300 --> 00:10:23,220
basic blocks for those of you who are

258
00:10:23,220 --> 00:10:25,260
interested the full specification is

259
00:10:25,260 --> 00:10:26,890
linked below

260
00:10:26,890 --> 00:10:28,380
[Music]

261
00:10:28,380 --> 00:10:30,480
Step 2 involves generating protobuf

262
00:10:30,480 --> 00:10:32,519
messages based on the encoded

263
00:10:32,519 --> 00:10:35,459
specification for this we use electrode

264
00:10:35,459 --> 00:10:38,100
of new data essentially this library is

265
00:10:38,100 --> 00:10:39,540
a generator of protograph messages

266
00:10:39,540 --> 00:10:41,820
conforming to the specification we have

267
00:10:41,820 --> 00:10:43,380
custom written

268
00:10:43,380 --> 00:10:46,620
in text form a generation looks somewhat

269
00:10:46,620 --> 00:10:49,140
like the Json input shown below we may

270
00:10:49,140 --> 00:10:50,700
have for example a block of statements

271
00:10:50,700 --> 00:10:52,920
which consists of a single if statement

272
00:10:52,920 --> 00:10:54,839
whose condition is the equality operator

273
00:10:54,839 --> 00:10:59,360
or a variable reference and 0.

274
00:10:59,519 --> 00:11:01,980
the final step involves translating the

275
00:11:01,980 --> 00:11:03,839
protobuf message into a valid unit

276
00:11:03,839 --> 00:11:06,600
program this translator or a converter

277
00:11:06,600 --> 00:11:09,240
accepts a protobuf message and converts

278
00:11:09,240 --> 00:11:11,100
it to a yule program

279
00:11:11,100 --> 00:11:12,779
foreign

280
00:11:12,779 --> 00:11:14,880
in this slide I provide an example to

281
00:11:14,880 --> 00:11:17,000
visualize the three steps

282
00:11:17,000 --> 00:11:21,240
so essentially the Json input is

283
00:11:21,240 --> 00:11:24,000
converted to the text form of the Yule

284
00:11:24,000 --> 00:11:26,579
program which looks like if x0 equals 0

285
00:11:26,579 --> 00:11:28,560
when x0 is a

286
00:11:28,560 --> 00:11:31,140
free defined or a predeclared yule

287
00:11:31,140 --> 00:11:32,700
variable

288
00:11:32,700 --> 00:11:34,740
this is of course a code snippet the

289
00:11:34,740 --> 00:11:37,500
entire program is much larger but I just

290
00:11:37,500 --> 00:11:39,480
wanted to demonstrate what the

291
00:11:39,480 --> 00:11:44,000
conversion may be visualized as

292
00:11:44,420 --> 00:11:47,880
all of this is encapsulated in this

293
00:11:47,880 --> 00:11:49,740
block diagram so we have a proof of

294
00:11:49,740 --> 00:11:53,000
specification we generate instances of

295
00:11:53,000 --> 00:11:56,040
photograph messages based on using

296
00:11:56,040 --> 00:11:59,820
liquid a buff and Buffet data we use the

297
00:11:59,820 --> 00:12:01,440
converter program that we have written

298
00:12:01,440 --> 00:12:04,380
to convert these specifications into

299
00:12:04,380 --> 00:12:08,180
real test programs

300
00:12:09,240 --> 00:12:11,519
the next question is how do we know if

301
00:12:11,519 --> 00:12:13,320
there is a miscompilation or an

302
00:12:13,320 --> 00:12:17,600
incorrect code generation buff foreign

303
00:12:17,720 --> 00:12:20,160
differential fast testing as I hinted in

304
00:12:20,160 --> 00:12:22,860
the previous step this mainly involves

305
00:12:22,860 --> 00:12:25,380
Three Steps step one would be to track

306
00:12:25,380 --> 00:12:28,380
side effects of execution we have some

307
00:12:28,380 --> 00:12:31,140
infrastructure to do this using this

308
00:12:31,140 --> 00:12:32,880
infrastructure We Run The Baseline and

309
00:12:32,880 --> 00:12:34,860
experimental programs and compare side

310
00:12:34,860 --> 00:12:35,760
effects

311
00:12:35,760 --> 00:12:37,860
if the side effects don't match there is

312
00:12:37,860 --> 00:12:38,940
a bug

313
00:12:38,940 --> 00:12:40,940
most often they match so there is no

314
00:12:40,940 --> 00:12:44,519
bugs are often very rare sort of one in

315
00:12:44,519 --> 00:12:46,380
a million or one in seven hundred

316
00:12:46,380 --> 00:12:50,060
thousand iterations

317
00:12:51,360 --> 00:12:53,100
now to actually perform execution

318
00:12:53,100 --> 00:12:55,380
Precinct Auto monitor side effects we

319
00:12:55,380 --> 00:12:57,839
use either an ebm client like ebm1 or

320
00:12:57,839 --> 00:13:00,480
the UL interpreter specifically solitary

321
00:13:00,480 --> 00:13:03,360
programs Target or drive evf client and

322
00:13:03,360 --> 00:13:04,980
the yield programs drive you will

323
00:13:04,980 --> 00:13:07,019
interpreter

324
00:13:07,019 --> 00:13:10,560
so essentially in each of these

325
00:13:10,560 --> 00:13:12,720
two input generation strategies you have

326
00:13:12,720 --> 00:13:15,060
a test program that's been generated we

327
00:13:15,060 --> 00:13:17,279
take that test program put it to an

328
00:13:17,279 --> 00:13:18,899
execution free service and you can see

329
00:13:18,899 --> 00:13:21,000
what the program is actually doing at

330
00:13:21,000 --> 00:13:23,420
runtime

331
00:13:23,540 --> 00:13:26,700
and using all of these components we can

332
00:13:26,700 --> 00:13:29,160
summarize the fuzzing setup shown in the

333
00:13:29,160 --> 00:13:30,959
slide deck so we have a program

334
00:13:30,959 --> 00:13:33,600
generator we have two different ways of

335
00:13:33,600 --> 00:13:34,980
generating programs which I quickly

336
00:13:34,980 --> 00:13:37,860
summarized and uh differential testing

337
00:13:37,860 --> 00:13:40,079
strategy which involves reading this

338
00:13:40,079 --> 00:13:42,000
program to a baseline in an experimental

339
00:13:42,000 --> 00:13:43,740
component a component in order test

340
00:13:43,740 --> 00:13:46,260
using an execution preset to actually

341
00:13:46,260 --> 00:13:48,860
understand what is happening at runtime

342
00:13:48,860 --> 00:13:52,560
and comparing the stress to see if there

343
00:13:52,560 --> 00:13:55,339
is a bug or not

344
00:13:57,500 --> 00:14:00,120
uh now I summarize what we've achieved

345
00:14:00,120 --> 00:14:02,339
in this project so far so let me begin

346
00:14:02,339 --> 00:14:04,500
with a couple of example interesting

347
00:14:04,500 --> 00:14:05,760
works

348
00:14:05,760 --> 00:14:07,920
but one has to do with incorrect kitchen

349
00:14:07,920 --> 00:14:10,320
computation what you see on the slide

350
00:14:10,320 --> 00:14:12,060
deck is a simple smart contract that

351
00:14:12,060 --> 00:14:14,459
contains a single function called f

352
00:14:14,459 --> 00:14:16,139
the function returns a Boolean value

353
00:14:16,139 --> 00:14:17,579
called red

354
00:14:17,579 --> 00:14:20,040
it contains only assembly code the

355
00:14:20,040 --> 00:14:22,920
assembly code would write 32 word zero

356
00:14:22,920 --> 00:14:25,680
to memory location 0. it then computes

357
00:14:25,680 --> 00:14:28,800
the ktac-256 hash of the first 32 bytes

358
00:14:28,800 --> 00:14:32,700
stores it in a variable called a it then

359
00:14:32,700 --> 00:14:36,360
computes the 256 architect 256 hash of

360
00:14:36,360 --> 00:14:38,940
the first 23 bytes stores it in another

361
00:14:38,940 --> 00:14:41,339
variable called B and Returns the

362
00:14:41,339 --> 00:14:44,940
Boolean value a equals equals B that is

363
00:14:44,940 --> 00:14:47,820
true if a and b are equal and false

364
00:14:47,820 --> 00:14:49,800
otherwise question is what are the

365
00:14:49,800 --> 00:14:53,519
functional return are they equal or not

366
00:14:53,519 --> 00:14:55,620
what actually is to happen and this is

367
00:14:55,620 --> 00:14:58,260
the buggy execution was that the

368
00:14:58,260 --> 00:15:01,199
function used to return true

369
00:15:01,199 --> 00:15:03,480
and this was because the compiler

370
00:15:03,480 --> 00:15:07,860
assumed that case act 256 256 is always

371
00:15:07,860 --> 00:15:10,860
computed over memory regions there are

372
00:15:10,860 --> 00:15:13,339
multiples of 32 bytes in size that is

373
00:15:13,339 --> 00:15:14,959
3264

374
00:15:14,959 --> 00:15:19,560
128 96 so on so forth

375
00:15:19,560 --> 00:15:21,779
based on this assumption

376
00:15:21,779 --> 00:15:24,480
um the compiler would cache pre-computed

377
00:15:24,480 --> 00:15:27,240
kitchen to 56 values based on the start

378
00:15:27,240 --> 00:15:30,720
pointer assuming lens rounded to 32

379
00:15:30,720 --> 00:15:32,579
bytes were equal of two different

380
00:15:32,579 --> 00:15:35,279
computations as you see in the slide

381
00:15:35,279 --> 00:15:37,740
Bill uh before this the first

382
00:15:37,740 --> 00:15:40,199
computation has a length 32 and the

383
00:15:40,199 --> 00:15:43,320
second 23. so if you were to round 23 to

384
00:15:43,320 --> 00:15:45,540
the nearest article of 22 that would

385
00:15:45,540 --> 00:15:49,760
match uh the previous computation

386
00:15:49,760 --> 00:15:53,459
and this is incorrect because okay check

387
00:15:53,459 --> 00:15:57,480
hash over 23 zeros and over 32 zeros are

388
00:15:57,480 --> 00:15:59,459
two different values

389
00:15:59,459 --> 00:16:02,100
now the bug fixes obviously to add the

390
00:16:02,100 --> 00:16:04,920
additional safeties check where in

391
00:16:04,920 --> 00:16:08,040
um the cached value is only used if the

392
00:16:08,040 --> 00:16:12,199
start pointer and length match exactly

393
00:16:13,760 --> 00:16:16,260
now you can understand the motivation

394
00:16:16,260 --> 00:16:17,940
for the caching itself it was to save

395
00:16:17,940 --> 00:16:21,240
gas because uh Computing hash is

396
00:16:21,240 --> 00:16:23,940
resource intensive so if it's already

397
00:16:23,940 --> 00:16:26,100
been computed and the subsequent

398
00:16:26,100 --> 00:16:27,839
computation is

399
00:16:27,839 --> 00:16:29,820
identical can be guaranteed to be

400
00:16:29,820 --> 00:16:31,860
identical it saves resources but in this

401
00:16:31,860 --> 00:16:33,420
case

402
00:16:33,420 --> 00:16:35,459
um it turned out that that was at the

403
00:16:35,459 --> 00:16:38,880
cost of correct computation which is

404
00:16:38,880 --> 00:16:42,800
which is uh the main

405
00:16:43,259 --> 00:16:45,000
job of the compiler which is to produce

406
00:16:45,000 --> 00:16:47,540
correct code

407
00:16:47,639 --> 00:16:50,220
the second bug introduced that I'm going

408
00:16:50,220 --> 00:16:51,899
to demonstrate uh that's formed by the

409
00:16:51,899 --> 00:16:54,060
fuzzle is somewhat more subtle to

410
00:16:54,060 --> 00:16:55,680
demonstrate the bug here we have three

411
00:16:55,680 --> 00:16:58,199
yield functions remember Yule is the

412
00:16:58,199 --> 00:16:59,940
intermediate representation used by the

413
00:16:59,940 --> 00:17:03,019
solar e compiler

414
00:17:04,859 --> 00:17:06,599
the function read value Returns the

415
00:17:06,599 --> 00:17:09,839
value stored in evm storage slot zero

416
00:17:09,839 --> 00:17:12,660
the function write value writes 2 to

417
00:17:12,660 --> 00:17:14,640
Store Slots 0 and returns this value

418
00:17:14,640 --> 00:17:17,400
that is the value of 2. the function 1

419
00:17:17,400 --> 00:17:19,559
performs a multiplication of the value

420
00:17:19,559 --> 00:17:22,319
returned by write value and one the

421
00:17:22,319 --> 00:17:25,319
value 1 left shifted by the return value

422
00:17:25,319 --> 00:17:27,480
of the function read value

423
00:17:27,480 --> 00:17:30,900
please note that the op code shl that is

424
00:17:30,900 --> 00:17:34,080
shift left X Y in Yule means y left

425
00:17:34,080 --> 00:17:35,880
shifted by X and not the other way

426
00:17:35,880 --> 00:17:36,660
around

427
00:17:36,660 --> 00:17:39,360
another important note is that dual

428
00:17:39,360 --> 00:17:42,059
promises left to right evaluation that

429
00:17:42,059 --> 00:17:44,100
is expressions are evaluated from left

430
00:17:44,100 --> 00:17:46,440
to right now the question is what should

431
00:17:46,440 --> 00:17:49,200
the return value of the function bug b

432
00:17:49,200 --> 00:17:52,580
we can work it out together

433
00:17:52,679 --> 00:17:55,860
so the main computation in the bug

434
00:17:55,860 --> 00:17:57,900
function is the multiplication which can

435
00:17:57,900 --> 00:18:02,220
be simplified to null of 2 which is the

436
00:18:02,220 --> 00:18:03,960
value returned by right value please

437
00:18:03,960 --> 00:18:05,700
note that we are evaluating left to

438
00:18:05,700 --> 00:18:07,980
right and therefore right value is first

439
00:18:07,980 --> 00:18:09,360
evaluated

440
00:18:09,360 --> 00:18:12,539
followed by shift left of 2 comma 1 that

441
00:18:12,539 --> 00:18:15,419
is one left shifted by 2 which is the

442
00:18:15,419 --> 00:18:19,140
value 4. this simplifies further to mult

443
00:18:19,140 --> 00:18:21,720
2 comma 4 that is 2 multiplied by 4

444
00:18:21,720 --> 00:18:24,539
which is 8. that is the correct value

445
00:18:24,539 --> 00:18:26,100
that should be returned by the function

446
00:18:26,100 --> 00:18:28,320
log

447
00:18:28,320 --> 00:18:31,440
now before I demonstrate the buggy

448
00:18:31,440 --> 00:18:34,559
optimization that led to an incorrect or

449
00:18:34,559 --> 00:18:37,200
computation I should introduce you to

450
00:18:37,200 --> 00:18:40,200
the optimization rule that simplifies uh

451
00:18:40,200 --> 00:18:41,520
this function

452
00:18:41,520 --> 00:18:43,500
and this is that if we have two

453
00:18:43,500 --> 00:18:46,260
expressions X and 2 raised to the power

454
00:18:46,260 --> 00:18:48,179
Pi which are multiplied this is

455
00:18:48,179 --> 00:18:51,600
identical to X left shifted by y

456
00:18:51,600 --> 00:18:54,480
and hence the left hand side of the

457
00:18:54,480 --> 00:18:56,520
equation could be simplified to the

458
00:18:56,520 --> 00:18:58,020
right hand side the main advantage of

459
00:18:58,020 --> 00:18:59,580
course is that we are saving a

460
00:18:59,580 --> 00:19:01,380
multiplication and

461
00:19:01,380 --> 00:19:04,620
um potentially saving resources

462
00:19:04,620 --> 00:19:05,940
um and definitely saving gas by

463
00:19:05,940 --> 00:19:09,140
eliminating multiplication

464
00:19:10,500 --> 00:19:12,600
so we could optimize the program by

465
00:19:12,600 --> 00:19:14,400
applying this rule when we do it the

466
00:19:14,400 --> 00:19:16,799
program looks like this note that the

467
00:19:16,799 --> 00:19:18,059
function calls on the right hand side

468
00:19:18,059 --> 00:19:20,520
have been reordered so read value

469
00:19:20,520 --> 00:19:23,700
appears before write value and also note

470
00:19:23,700 --> 00:19:25,740
that we are evaluating from left to

471
00:19:25,740 --> 00:19:26,580
right

472
00:19:26,580 --> 00:19:28,559
so if we were to simplify this what

473
00:19:28,559 --> 00:19:30,179
would happen is

474
00:19:30,179 --> 00:19:33,419
we would evaluate heat value first which

475
00:19:33,419 --> 00:19:36,059
would return 0 because

476
00:19:36,059 --> 00:19:39,960
right it's not been returned to and uh

477
00:19:39,960 --> 00:19:41,700
the right value would return to as

478
00:19:41,700 --> 00:19:43,980
before this means 2 is being left

479
00:19:43,980 --> 00:19:46,620
shifted by zero bits which is equal to

480
00:19:46,620 --> 00:19:48,960
two clearly two and eight are different

481
00:19:48,960 --> 00:19:51,720
values and this is why the

482
00:19:51,720 --> 00:19:55,559
for the flag this is a bug and uh

483
00:19:55,559 --> 00:19:58,559
this was actually an important bug and

484
00:19:58,559 --> 00:20:00,600
uh something that was easy to fix by

485
00:20:00,600 --> 00:20:02,160
adding a safety check

486
00:20:02,160 --> 00:20:04,679
that is to say that apply the

487
00:20:04,679 --> 00:20:07,620
optimization only on Expressions that do

488
00:20:07,620 --> 00:20:09,900
not have any side effects they have side

489
00:20:09,900 --> 00:20:11,880
effects simply do not apply the

490
00:20:11,880 --> 00:20:14,160
optimization of course we would

491
00:20:14,160 --> 00:20:16,500
compromise optimization at the cost of

492
00:20:16,500 --> 00:20:18,660
correctness and that is no way now we

493
00:20:18,660 --> 00:20:20,460
would the main goal of the compiler like

494
00:20:20,460 --> 00:20:23,100
I said is produce correct code even if

495
00:20:23,100 --> 00:20:25,740
we were talking we miss optimization

496
00:20:25,740 --> 00:20:27,179
opportunities

497
00:20:27,179 --> 00:20:27,870
foreign

498
00:20:27,870 --> 00:20:32,020
[Music]

499
00:20:35,340 --> 00:20:37,559
the results that I that we found using

500
00:20:37,559 --> 00:20:40,940
this Approach at a very high level

501
00:20:41,940 --> 00:20:44,640
um so if we were to look at the box that

502
00:20:44,640 --> 00:20:47,220
performed by the fuzzle by component

503
00:20:47,220 --> 00:20:50,460
um most of them go box in the Dual

504
00:20:50,460 --> 00:20:51,919
optimizer

505
00:20:51,919 --> 00:20:54,720
and the good news here is that all of

506
00:20:54,720 --> 00:20:56,160
these bugs were found before the use

507
00:20:56,160 --> 00:20:58,320
Optimizer transition from experimental

508
00:20:58,320 --> 00:21:01,500
to production so this had very little

509
00:21:01,500 --> 00:21:04,200
impact on end users because the

510
00:21:04,200 --> 00:21:06,360
component was specifically marked as

511
00:21:06,360 --> 00:21:07,980
experimental release

512
00:21:07,980 --> 00:21:10,860
should use under

513
00:21:10,860 --> 00:21:15,000
use at your own risk

514
00:21:15,000 --> 00:21:17,700
the second highest number of bugs were

515
00:21:17,700 --> 00:21:20,000
found in the Legacy code generator

516
00:21:20,000 --> 00:21:23,340
followed by the new IRP support

517
00:21:23,340 --> 00:21:24,840
generator which was also marked

518
00:21:24,840 --> 00:21:27,140
experimental at the time and hence

519
00:21:27,140 --> 00:21:30,419
hydrating impact on end users followed

520
00:21:30,419 --> 00:21:33,659
by the optimizer Rule now

521
00:21:33,659 --> 00:21:37,320
the only security critical bugs

522
00:21:37,320 --> 00:21:39,480
that had a severity Reading had to do

523
00:21:39,480 --> 00:21:42,419
with bugs and optimization tool that is

524
00:21:42,419 --> 00:21:44,360
when the rule was

525
00:21:44,360 --> 00:21:48,059
unsafely applied that is sufficient

526
00:21:48,059 --> 00:21:49,860
safety checks were not carried out or

527
00:21:49,860 --> 00:21:53,899
the rule itself was wrong foreign

528
00:21:54,600 --> 00:21:57,299
ly the majority of the bugs were found

529
00:21:57,299 --> 00:21:59,280
in experimental features if we look at

530
00:21:59,280 --> 00:22:01,679
bugs by impact and did not affect smart

531
00:22:01,679 --> 00:22:04,320
contract or smart contracts that use

532
00:22:04,320 --> 00:22:05,760
stable features

533
00:22:05,760 --> 00:22:08,220
the Bugsby found introduction components

534
00:22:08,220 --> 00:22:09,919
were quickly patched

535
00:22:09,919 --> 00:22:12,900
and maybe the Highlight is to say that

536
00:22:12,900 --> 00:22:14,640
three bucks were found in unreleased

537
00:22:14,640 --> 00:22:17,539
features so they were even fixed before

538
00:22:17,539 --> 00:22:23,159
it saw the light of day so to speak

539
00:22:23,159 --> 00:22:25,740
if one want to break down the box down

540
00:22:25,740 --> 00:22:27,720
by the severity you would find that most

541
00:22:27,720 --> 00:22:30,360
of them have a low

542
00:22:30,360 --> 00:22:33,240
or a very low uh severity rating only

543
00:22:33,240 --> 00:22:35,940
one had a medium severity rating

544
00:22:35,940 --> 00:22:37,919
um this is either because uh they're

545
00:22:37,919 --> 00:22:39,780
easy to detect during regular smart

546
00:22:39,780 --> 00:22:42,000
contract testing or that they require a

547
00:22:42,000 --> 00:22:44,520
series of prerequisites to be fulfilled

548
00:22:44,520 --> 00:22:46,260
for the bug to manifest itself and

549
00:22:46,260 --> 00:22:48,179
satisfying all these prerequisites in

550
00:22:48,179 --> 00:22:51,799
most cases is a bit far-fetched

551
00:22:52,020 --> 00:22:54,780
um and reason the majority of the bugs

552
00:22:54,780 --> 00:22:56,820
like more than 80 percent are not

553
00:22:56,820 --> 00:22:59,220
applicable severity because uh these

554
00:22:59,220 --> 00:23:00,900
bugs were found in experimental features

555
00:23:00,900 --> 00:23:03,720
and by definition

556
00:23:03,720 --> 00:23:06,900
we did not categorize bugs in these

557
00:23:06,900 --> 00:23:08,700
experimental features are set as

558
00:23:08,700 --> 00:23:10,500
security critical because

559
00:23:10,500 --> 00:23:14,190
uh they're not marked for production use

560
00:23:14,190 --> 00:23:15,600
[Music]

561
00:23:15,600 --> 00:23:18,980
a few key takeaways from our

562
00:23:18,980 --> 00:23:22,140
experience three blocks performed by the

563
00:23:22,140 --> 00:23:24,299
plaza even before a PR was March this is

564
00:23:24,299 --> 00:23:26,940
great news and validation that continues

565
00:23:26,940 --> 00:23:28,530
pausing wears food

566
00:23:28,530 --> 00:23:30,720
[Music]

567
00:23:30,720 --> 00:23:32,940
um also more importantly fuzzing

568
00:23:32,940 --> 00:23:35,280
transitions you that you will optimize

569
00:23:35,280 --> 00:23:37,559
safely from experimental production use

570
00:23:37,559 --> 00:23:39,960
15 bucks per pound before production

571
00:23:39,960 --> 00:23:42,960
release this means 15 fewer bucks that

572
00:23:42,960 --> 00:23:46,080
users would encounter

573
00:23:46,080 --> 00:23:49,440
finally we notice zero population with

574
00:23:49,440 --> 00:23:51,480
the bugs found by the fossil and

575
00:23:51,480 --> 00:23:53,159
external users

576
00:23:53,159 --> 00:23:55,799
this poses the question if the father is

577
00:23:55,799 --> 00:23:57,360
actually finding bugs that are

578
00:23:57,360 --> 00:24:00,240
meaningful to end users and whether

579
00:24:00,240 --> 00:24:03,539
these perks would actually affect a real

580
00:24:03,539 --> 00:24:06,419
world deployed contracts at all I would

581
00:24:06,419 --> 00:24:08,220
leave this as an open question

582
00:24:08,220 --> 00:24:11,640
because this is out of the scope of the

583
00:24:11,640 --> 00:24:14,059
talk today

584
00:24:14,360 --> 00:24:16,559
let me say light on what you're

585
00:24:16,559 --> 00:24:19,860
currently doing now some of the reason

586
00:24:19,860 --> 00:24:22,020
focuses on trying to make the father

587
00:24:22,020 --> 00:24:24,360
generate more human-like or intentional

588
00:24:24,360 --> 00:24:28,260
test cases are kind of nice back to the

589
00:24:28,260 --> 00:24:30,059
idea of the title of this presentation

590
00:24:30,059 --> 00:24:33,120
can the father approach humanness and

591
00:24:33,120 --> 00:24:35,100
this is because of the Insight that two

592
00:24:35,100 --> 00:24:37,020
of the bugs that were recently found by

593
00:24:37,020 --> 00:24:38,880
the father were not directly exploitable

594
00:24:38,880 --> 00:24:42,240
but it need the assistance of my

595
00:24:42,240 --> 00:24:44,700
colleagues hubby and Daniel to actually

596
00:24:44,700 --> 00:24:46,679
demonstrate that they can be exploitable

597
00:24:46,679 --> 00:24:48,780
and are actually

598
00:24:48,780 --> 00:24:52,500
potentially security critical box

599
00:24:52,500 --> 00:24:54,120
so

600
00:24:54,120 --> 00:24:56,460
um the question is can you can the

601
00:24:56,460 --> 00:24:58,740
fuzzer approach humanist can it kind of

602
00:24:58,740 --> 00:25:01,500
approach the kind of things that my

603
00:25:01,500 --> 00:25:03,659
colleagues were doing to understand if

604
00:25:03,659 --> 00:25:06,620
the bug is exploitable

605
00:25:07,039 --> 00:25:09,480
finding a solution to this is tricky

606
00:25:09,480 --> 00:25:10,559
because

607
00:25:10,559 --> 00:25:15,840
um pure Randomness is ill-suited and we

608
00:25:15,840 --> 00:25:18,539
short of training an AI we don't have a

609
00:25:18,539 --> 00:25:21,179
means to understand what is human or

610
00:25:21,179 --> 00:25:22,679
intentional code

611
00:25:22,679 --> 00:25:24,960
but a few heuristics could be used which

612
00:25:24,960 --> 00:25:26,400
I can quickly

613
00:25:26,400 --> 00:25:27,419
um

614
00:25:27,419 --> 00:25:30,480
demonstrate using a concrete example

615
00:25:30,480 --> 00:25:32,760
we have an optimization pass called the

616
00:25:32,760 --> 00:25:34,860
Redundant memory store Eliminator whose

617
00:25:34,860 --> 00:25:37,559
job it is to eliminate 200 stores the

618
00:25:37,559 --> 00:25:38,340
memory

619
00:25:38,340 --> 00:25:40,080
now

620
00:25:40,080 --> 00:25:42,779
it requires either a relocation to be

621
00:25:42,779 --> 00:25:44,640
equal or not equal to the right location

622
00:25:44,640 --> 00:25:46,919
to perform two different functions to

623
00:25:46,919 --> 00:25:48,720
eliminate or not eliminate

624
00:25:48,720 --> 00:25:52,200
uh right to memory now pure Randomness

625
00:25:52,200 --> 00:25:54,840
will mostly most likely lead you to the

626
00:25:54,840 --> 00:25:57,480
not equal part time equal that is most

627
00:25:57,480 --> 00:26:00,960
often for us will synthesize a right

628
00:26:00,960 --> 00:26:02,700
to a location that's arbitrarily

629
00:26:02,700 --> 00:26:04,740
different than the relocation

630
00:26:04,740 --> 00:26:08,220
and very rarely exercise the equality

631
00:26:08,220 --> 00:26:11,220
path this could be solved by heuristic

632
00:26:11,220 --> 00:26:12,120
that

633
00:26:12,120 --> 00:26:14,460
uh we read from location that is already

634
00:26:14,460 --> 00:26:16,440
written to occasionally and this can

635
00:26:16,440 --> 00:26:19,020
already help us Bridge some gaps in

636
00:26:19,020 --> 00:26:22,080
purely random testing this is some of

637
00:26:22,080 --> 00:26:25,020
the work that we're currently doing

638
00:26:25,020 --> 00:26:27,059
yeah that brings me to the end of this

639
00:26:27,059 --> 00:26:30,059
talk before I conclude uh I would like

640
00:26:30,059 --> 00:26:32,760
to highlight some key takeaways

641
00:26:32,760 --> 00:26:34,440
in this talk I highlighted our

642
00:26:34,440 --> 00:26:36,419
continuous grammar based housing

643
00:26:36,419 --> 00:26:38,340
approach for early bug Discovery in the

644
00:26:38,340 --> 00:26:40,980
solidity compiler team this is proved to

645
00:26:40,980 --> 00:26:42,960
be quite useful to test security

646
00:26:42,960 --> 00:26:44,880
critical components of the compiler on

647
00:26:44,880 --> 00:26:46,679
special specifically to find this

648
00:26:46,679 --> 00:26:48,659
compilation or incorrect four generation

649
00:26:48,659 --> 00:26:49,500
box

650
00:26:49,500 --> 00:26:52,500
while it does not contain or provide

651
00:26:52,500 --> 00:26:54,900
formal guarantees there is evidence that

652
00:26:54,900 --> 00:26:58,440
it works so it is very practical and the

653
00:26:58,440 --> 00:26:59,940
other nice thing is that it can be

654
00:26:59,940 --> 00:27:02,220
continuously deployed I mean

655
00:27:02,220 --> 00:27:04,200
automatically deployed in a nucleus

656
00:27:04,200 --> 00:27:07,440
integration setup and uh that works

657
00:27:07,440 --> 00:27:08,700
quite well

658
00:27:08,700 --> 00:27:10,500
so we are reasonably happy but at the

659
00:27:10,500 --> 00:27:11,460
same time

660
00:27:11,460 --> 00:27:14,460
because of no formal guarantees

661
00:27:14,460 --> 00:27:16,500
um it is my day job to continuously

662
00:27:16,500 --> 00:27:18,179
monitor the kind of programs that the

663
00:27:18,179 --> 00:27:21,799
father is generating and to essentially

664
00:27:21,799 --> 00:27:24,480
ensure that we don't miss a security

665
00:27:24,480 --> 00:27:26,700
critical bugs especially in new leader

666
00:27:26,700 --> 00:27:29,640
lock features so on and so forth here

667
00:27:29,640 --> 00:27:31,500
I thank you for your patience thank you

668
00:27:31,500 --> 00:27:33,600
for attending the talk and I'll be happy

669
00:27:33,600 --> 00:27:36,120
to take questions now all right we

670
00:27:36,120 --> 00:27:38,279
actually have uh bhagava online with us

671
00:27:38,279 --> 00:27:41,539
so can you hear us

672
00:27:41,700 --> 00:27:44,100
I can hear you all right yes we can hear

673
00:27:44,100 --> 00:27:47,039
you too so we have uh two questions from

674
00:27:47,039 --> 00:27:48,900
the floor so first

675
00:27:48,900 --> 00:27:51,480
what are some of the factors that affect

676
00:27:51,480 --> 00:27:54,059
the performance of fuzzing on solidity

677
00:27:54,059 --> 00:27:56,220
and common ways to optimize for

678
00:27:56,220 --> 00:27:58,760
performance

679
00:28:00,000 --> 00:28:02,820
um some of the factors that affect the

680
00:28:02,820 --> 00:28:05,700
performance of solidity fuzzing are the

681
00:28:05,700 --> 00:28:08,700
the latency of compilation itself uh

682
00:28:08,700 --> 00:28:10,320
please bear in mind that the compiler

683
00:28:10,320 --> 00:28:12,000
passes the input

684
00:28:12,000 --> 00:28:14,340
uh translates it into an intermediate

685
00:28:14,340 --> 00:28:16,140
representation and then optimizes it and

686
00:28:16,140 --> 00:28:18,360
then assembles it so it's a pretty big

687
00:28:18,360 --> 00:28:20,640
pipeline sometimes it can have multiple

688
00:28:20,640 --> 00:28:23,159
seconds of delay and for fuzzing this is

689
00:28:23,159 --> 00:28:25,200
a bottleneck

690
00:28:25,200 --> 00:28:27,539
um some ways to optimize it would be to

691
00:28:27,539 --> 00:28:30,419
focus fuzzing on specific portions of

692
00:28:30,419 --> 00:28:33,120
the compiler for example we uh have a

693
00:28:33,120 --> 00:28:34,919
fuzzer that targets the optimizer

694
00:28:34,919 --> 00:28:37,919
specifically and skips the let's say uh

695
00:28:37,919 --> 00:28:39,720
the generic parsing and the code

696
00:28:39,720 --> 00:28:42,720
generation part uh so we use strategies

697
00:28:42,720 --> 00:28:44,640
like that

698
00:28:44,640 --> 00:28:45,600
um yeah

699
00:28:45,600 --> 00:28:48,900
that's one way to answer the question

700
00:28:48,900 --> 00:28:52,559
okay next question uh do you think we'll

701
00:28:52,559 --> 00:28:54,720
ever reach a time where we do not need

702
00:28:54,720 --> 00:28:58,039
to use the first thing anymore

703
00:28:58,320 --> 00:28:59,880
um yeah this made me chuckle I'm not

704
00:28:59,880 --> 00:29:05,400
sure to be honest because uh I mean

705
00:29:05,400 --> 00:29:08,880
um programs are quite complex in nature

706
00:29:08,880 --> 00:29:12,360
and uh we humans are prone to make

707
00:29:12,360 --> 00:29:15,720
errors and make mistakes and as much as

708
00:29:15,720 --> 00:29:19,220
we invest time in code reviews and

709
00:29:19,220 --> 00:29:21,779
thorough testing there are always Corner

710
00:29:21,779 --> 00:29:25,380
cases that can escape the human eye or

711
00:29:25,380 --> 00:29:25,980
um

712
00:29:25,980 --> 00:29:28,260
a test case that's

713
00:29:28,260 --> 00:29:31,799
um not sufficiently well written so I

714
00:29:31,799 --> 00:29:34,860
feel we'll probably need to use fuzzing

715
00:29:34,860 --> 00:29:36,899
for some time to come

716
00:29:36,899 --> 00:29:39,720
yeah yeah I agree as well all right

717
00:29:39,720 --> 00:29:41,179
thank you very much for your time uh

718
00:29:41,179 --> 00:29:45,140
good to see you soon next time

719
00:29:47,100 --> 00:29:50,270
[Applause]

