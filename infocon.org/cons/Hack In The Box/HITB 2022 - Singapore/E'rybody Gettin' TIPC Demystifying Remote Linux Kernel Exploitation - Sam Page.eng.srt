1
00:00:06,000 --> 00:00:09,000
all right uh let's do this uh first of

2
00:00:09,000 --> 00:00:10,559
all I'd just like to say thanks to hack

3
00:00:10,559 --> 00:00:13,320
in the Box for having me here this is

4
00:00:13,320 --> 00:00:15,000
actually my first conference and I think

5
00:00:15,000 --> 00:00:16,740
even my first international travel since

6
00:00:16,740 --> 00:00:18,119
the start of the pandemic so really

7
00:00:18,119 --> 00:00:19,440
awesome to be here

8
00:00:19,440 --> 00:00:21,600
and thank you for all you guys uh for

9
00:00:21,600 --> 00:00:23,580
listening to me waffle about kind of

10
00:00:23,580 --> 00:00:26,699
exploitation for the next hour

11
00:00:26,699 --> 00:00:29,699
um so without further Ado uh let's take

12
00:00:29,699 --> 00:00:32,159
a stab at demystifying remote Linux

13
00:00:32,159 --> 00:00:34,079
kernel exploitation and I promise it's

14
00:00:34,079 --> 00:00:36,540
not as scary as it sounds

15
00:00:36,540 --> 00:00:39,719
right the button's working good start

16
00:00:39,719 --> 00:00:42,000
um so obligatory uh who am I first of

17
00:00:42,000 --> 00:00:43,980
all my name's Sam some of you might know

18
00:00:43,980 --> 00:00:46,860
me online as sam4k I occasionally tweet

19
00:00:46,860 --> 00:00:48,600
things and enjoy blogging about Linux

20
00:00:48,600 --> 00:00:50,760
internals and kernel exploitation

21
00:00:50,760 --> 00:00:53,160
professionally speaking

22
00:00:53,160 --> 00:00:54,600
um I do vulnerability research and

23
00:00:54,600 --> 00:00:56,100
exploit development

24
00:00:56,100 --> 00:00:58,199
um outside of work I also enjoy doing

25
00:00:58,199 --> 00:00:59,940
vulnerability research and exploit

26
00:00:59,940 --> 00:01:01,260
development so I'm not sure what that

27
00:01:01,260 --> 00:01:03,359
says about me but I'm just a keen being

28
00:01:03,359 --> 00:01:05,880
for Linux and security I also have some

29
00:01:05,880 --> 00:01:07,799
normal Hobbies as well like gaming and

30
00:01:07,799 --> 00:01:09,299
cooking and things like that so it's not

31
00:01:09,299 --> 00:01:11,400
all work

32
00:01:11,400 --> 00:01:13,740
um that's enough about me uh let's dive

33
00:01:13,740 --> 00:01:15,479
straight into the talk

34
00:01:15,479 --> 00:01:17,340
now some of you might be thinking like

35
00:01:17,340 --> 00:01:19,619
Sam that it looks a lot that looks a lot

36
00:01:19,619 --> 00:01:22,380
like the seven stages of grief and you'd

37
00:01:22,380 --> 00:01:24,780
be absolutely right when it came to

38
00:01:24,780 --> 00:01:26,700
trying to come up with a structure and

39
00:01:26,700 --> 00:01:28,860
format for this talk to kind of weave an

40
00:01:28,860 --> 00:01:30,720
interesting narrative this was the first

41
00:01:30,720 --> 00:01:32,520
thing that came to mind

42
00:01:32,520 --> 00:01:34,080
so make of that what you will but I feel

43
00:01:34,080 --> 00:01:35,460
like it actually ended up fitting quite

44
00:01:35,460 --> 00:01:36,240
well

45
00:01:36,240 --> 00:01:38,040
but I guess you guys can be the judge of

46
00:01:38,040 --> 00:01:39,900
that towards the end

47
00:01:39,900 --> 00:01:41,640
so let's just start with the first stage

48
00:01:41,640 --> 00:01:44,520
shock perhaps unsurprisingly this all

49
00:01:44,520 --> 00:01:46,799
started with shock as I discovered a

50
00:01:46,799 --> 00:01:48,420
remote stack buffer overflow in the

51
00:01:48,420 --> 00:01:50,280
Linux kernel while I was looking for

52
00:01:50,280 --> 00:01:51,899
Primitives to exploit another bug

53
00:01:51,899 --> 00:01:53,600
entirely

54
00:01:53,600 --> 00:01:56,460
so for a bit of context here I was

55
00:01:56,460 --> 00:01:58,200
currently new to my role and I was

56
00:01:58,200 --> 00:02:00,360
looking for a cve to write up so you're

57
00:02:00,360 --> 00:02:01,799
probably thinking it makes sense to play

58
00:02:01,799 --> 00:02:03,479
it safe right maybe look for some

59
00:02:03,479 --> 00:02:05,640
low-hanging fruit nice simple primitive

60
00:02:05,640 --> 00:02:07,619
maybe it's in a module I'm familiar with

61
00:02:07,619 --> 00:02:09,720
and maybe even there's an existing proof

62
00:02:09,720 --> 00:02:12,239
of concept out there to take inspiration

63
00:02:12,239 --> 00:02:13,140
from

64
00:02:13,140 --> 00:02:15,900
this is where we cue this CV here

65
00:02:15,900 --> 00:02:18,540
discovered by Max boy which is a remote

66
00:02:18,540 --> 00:02:21,180
Linux kernel Heap overflow the spoiler

67
00:02:21,180 --> 00:02:23,520
alert that is absolutely none of the

68
00:02:23,520 --> 00:02:25,680
criteria I just mentioned for playing it

69
00:02:25,680 --> 00:02:27,780
safe there was no existing proof of

70
00:02:27,780 --> 00:02:30,360
concept out there for RCA it was in some

71
00:02:30,360 --> 00:02:32,160
random networking module I'd never heard

72
00:02:32,160 --> 00:02:34,440
of before and as we'll see it was far

73
00:02:34,440 --> 00:02:37,080
from a simple primitive to exploit but

74
00:02:37,080 --> 00:02:39,239
it's like rce right this is like the

75
00:02:39,239 --> 00:02:41,099
holy grail for exploit developers

76
00:02:41,099 --> 00:02:43,379
especially uh within the kernel so like

77
00:02:43,379 --> 00:02:45,420
I had to give it a shot

78
00:02:45,420 --> 00:02:46,920
um but before the Panic set in and I was

79
00:02:46,920 --> 00:02:49,080
like what have I gotten myself into

80
00:02:49,080 --> 00:02:51,300
uh that's where the game plan comes in

81
00:02:51,300 --> 00:02:53,340
because at the end of the day these are

82
00:02:53,340 --> 00:02:55,379
inherently complex and open-ended

83
00:02:55,379 --> 00:02:57,060
problems like there's many different

84
00:02:57,060 --> 00:02:58,860
approaches you can take

85
00:02:58,860 --> 00:03:00,480
um there's many possible solutions and

86
00:03:00,480 --> 00:03:02,280
sometimes there isn't even a solution at

87
00:03:02,280 --> 00:03:03,959
all and if you take something like the

88
00:03:03,959 --> 00:03:06,120
Linux kernel which is an incredibly vast

89
00:03:06,120 --> 00:03:08,040
and complicated code base you know

90
00:03:08,040 --> 00:03:09,720
wherever you're looking it can have its

91
00:03:09,720 --> 00:03:12,540
own nuances in idiosyncrasies so by

92
00:03:12,540 --> 00:03:14,879
approaching these problems with kind of

93
00:03:14,879 --> 00:03:16,500
like a framework and some methodology

94
00:03:16,500 --> 00:03:18,420
we're able to break down what can be a

95
00:03:18,420 --> 00:03:20,099
really daunting and overwhelming task

96
00:03:20,099 --> 00:03:23,400
into manageable bite-sized steps and at

97
00:03:23,400 --> 00:03:24,780
least then if we go through our

98
00:03:24,780 --> 00:03:27,000
framework and our methodology if we get

99
00:03:27,000 --> 00:03:28,080
to the end of it and we haven't found

100
00:03:28,080 --> 00:03:30,060
anything at least we can be content in

101
00:03:30,060 --> 00:03:31,500
knowing that we tried our best we can

102
00:03:31,500 --> 00:03:33,180
take what we've learned and we can apply

103
00:03:33,180 --> 00:03:35,159
it to the next problem

104
00:03:35,159 --> 00:03:37,319
now these kind of Frameworks can vary

105
00:03:37,319 --> 00:03:39,120
from person to person it's kind of about

106
00:03:39,120 --> 00:03:40,620
understanding your own strengths and

107
00:03:40,620 --> 00:03:42,599
weaknesses and tailoring this to your

108
00:03:42,599 --> 00:03:44,580
workflow and it's an iterative process

109
00:03:44,580 --> 00:03:46,019
the more you do this kind of thing the

110
00:03:46,019 --> 00:03:48,239
more you can kind of streamline this but

111
00:03:48,239 --> 00:03:50,280
for me invariably the first step when

112
00:03:50,280 --> 00:03:52,500
approaching these kind of problems is to

113
00:03:52,500 --> 00:03:54,659
really spend some time developing a

114
00:03:54,659 --> 00:03:57,060
strong foundation so developing like a

115
00:03:57,060 --> 00:03:58,799
strong understanding of the exploitation

116
00:03:58,799 --> 00:04:00,840
primitive we're looking at and also the

117
00:04:00,840 --> 00:04:02,940
attack surface and I think it's easy to

118
00:04:02,940 --> 00:04:04,200
sometimes skip this and just jump

119
00:04:04,200 --> 00:04:06,659
straight into trying to pone things but

120
00:04:06,659 --> 00:04:08,159
by doing this and laying a solid

121
00:04:08,159 --> 00:04:10,080
foundation it really pays dividends

122
00:04:10,080 --> 00:04:11,280
later on

123
00:04:11,280 --> 00:04:14,340
now the next step is to put all this

124
00:04:14,340 --> 00:04:16,680
information this understanding we've got

125
00:04:16,680 --> 00:04:18,540
um towards putting together our plan of

126
00:04:18,540 --> 00:04:20,339
attack so we kind of want to know what

127
00:04:20,339 --> 00:04:22,079
our goal is are you like popping a

128
00:04:22,079 --> 00:04:23,940
reverse shell or something and then we

129
00:04:23,940 --> 00:04:25,560
want to piece together our understanding

130
00:04:25,560 --> 00:04:28,020
of both the surface and our primitive of

131
00:04:28,020 --> 00:04:30,180
techniques and mitigations to put

132
00:04:30,180 --> 00:04:31,680
together a plan of attack for how we

133
00:04:31,680 --> 00:04:33,060
want to get there from our initial

134
00:04:33,060 --> 00:04:35,940
exploitation primitive and then the next

135
00:04:35,940 --> 00:04:38,040
step is to begin enumerating our attack

136
00:04:38,040 --> 00:04:39,960
surface for these Primitives to kind of

137
00:04:39,960 --> 00:04:42,600
put this plan of attack into action

138
00:04:42,600 --> 00:04:43,919
um but this is important to highlight

139
00:04:43,919 --> 00:04:46,080
this is an iterative process you know it

140
00:04:46,080 --> 00:04:47,340
might not often be the case that our

141
00:04:47,340 --> 00:04:49,440
initial plan of attack works we might

142
00:04:49,440 --> 00:04:50,940
you know find some Primitives we might

143
00:04:50,940 --> 00:04:52,440
be missing another piece or we might

144
00:04:52,440 --> 00:04:54,180
realize actually this just doesn't work

145
00:04:54,180 --> 00:04:55,919
so there's an element of taking what

146
00:04:55,919 --> 00:04:57,600
we've learned going back to the drawing

147
00:04:57,600 --> 00:04:59,580
board and reapplying that information

148
00:04:59,580 --> 00:05:01,620
coming out of a new plan of attack and

149
00:05:01,620 --> 00:05:03,840
hopefully after a few ciphers of that we

150
00:05:03,840 --> 00:05:05,840
come up with a win

151
00:05:05,840 --> 00:05:08,639
so if we kind of zoom in on this process

152
00:05:08,639 --> 00:05:10,500
and take the Heap overflow I just

153
00:05:10,500 --> 00:05:12,540
mentioned as a case study let's start

154
00:05:12,540 --> 00:05:14,340
with that initial developing of

155
00:05:14,340 --> 00:05:16,080
understanding right so we have an

156
00:05:16,080 --> 00:05:18,300
unauthenticated remote Heap overflow of

157
00:05:18,300 --> 00:05:20,280
attacker Control Data within the Linux

158
00:05:20,280 --> 00:05:23,220
kernel in the networking stack so we

159
00:05:23,220 --> 00:05:24,479
kind of want to ask ourselves straight

160
00:05:24,479 --> 00:05:26,400
away like what are the effective kernel

161
00:05:26,400 --> 00:05:28,380
versions this can impact what

162
00:05:28,380 --> 00:05:30,120
mitigations are present what techniques

163
00:05:30,120 --> 00:05:32,520
are available to us and how we kind of

164
00:05:32,520 --> 00:05:34,199
go on moving forward we don't want to

165
00:05:34,199 --> 00:05:35,759
think about you know can we trigger it

166
00:05:35,759 --> 00:05:38,280
how reliable how reliably can we trigger

167
00:05:38,280 --> 00:05:39,960
this and then kind of working together

168
00:05:39,960 --> 00:05:41,520
to put a proof of concept to make sure

169
00:05:41,520 --> 00:05:42,720
we can do this and just getting an

170
00:05:42,720 --> 00:05:44,759
understanding of the root cause of the

171
00:05:44,759 --> 00:05:46,139
primitive

172
00:05:46,139 --> 00:05:47,580
and then next we want to think about

173
00:05:47,580 --> 00:05:49,139
things like constraints what are the

174
00:05:49,139 --> 00:05:51,060
constraints around triggering it

175
00:05:51,060 --> 00:05:52,080
um you know where do we have to be on

176
00:05:52,080 --> 00:05:53,699
the network like what's the constraints

177
00:05:53,699 --> 00:05:54,960
around the size of our attacker

178
00:05:54,960 --> 00:05:57,000
controlled data and then there's also

179
00:05:57,000 --> 00:06:00,419
more nuanced uh aspects around the

180
00:06:00,419 --> 00:06:02,639
exploitation it primitive itself so in

181
00:06:02,639 --> 00:06:04,680
the case of a heap overflow we might be

182
00:06:04,680 --> 00:06:06,180
asking like you know how is this

183
00:06:06,180 --> 00:06:08,759
allocated is it in the slob allocator

184
00:06:08,759 --> 00:06:10,979
like what caches are we targeting here

185
00:06:10,979 --> 00:06:12,840
is this a special purpose cache a

186
00:06:12,840 --> 00:06:14,759
general purpose cache what sizes are we

187
00:06:14,759 --> 00:06:16,440
looking at so these are all things we

188
00:06:16,440 --> 00:06:17,940
want to factor in to develop an

189
00:06:17,940 --> 00:06:19,320
understanding of kind of what's going on

190
00:06:19,320 --> 00:06:20,220
here

191
00:06:20,220 --> 00:06:21,900
and then of course the other aspect of

192
00:06:21,900 --> 00:06:23,940
this is understanding the attack surface

193
00:06:23,940 --> 00:06:25,139
we're looking at because that

194
00:06:25,139 --> 00:06:26,940
exploitation primitive is just the first

195
00:06:26,940 --> 00:06:28,860
step you know contemporary kernels we

196
00:06:28,860 --> 00:06:30,180
have a lot of we have a lot of work to

197
00:06:30,180 --> 00:06:31,620
do to be able to get where we want and

198
00:06:31,620 --> 00:06:33,000
to pop that shell

199
00:06:33,000 --> 00:06:35,880
so again while the remote surface is

200
00:06:35,880 --> 00:06:38,580
still a lot smaller than that exposed to

201
00:06:38,580 --> 00:06:40,680
a local attacker it's still a lot of

202
00:06:40,680 --> 00:06:43,199
code to look through potentially so

203
00:06:43,199 --> 00:06:45,060
again this whole process is about making

204
00:06:45,060 --> 00:06:47,520
it manageable and kind of like feasible

205
00:06:47,520 --> 00:06:49,080
so we'll start with a narrowing the

206
00:06:49,080 --> 00:06:50,759
scope and let's just look at the tipc

207
00:06:50,759 --> 00:06:52,560
module right the bugs are already there

208
00:06:52,560 --> 00:06:54,840
so that's a safe Target

209
00:06:54,840 --> 00:06:56,520
um so we can always expand the scope

210
00:06:56,520 --> 00:06:58,560
later on if we need to

211
00:06:58,560 --> 00:07:00,600
so for those of you not in the know

212
00:07:00,600 --> 00:07:03,900
about tipc it's the transparent in a

213
00:07:03,900 --> 00:07:06,060
process communication protocol and this

214
00:07:06,060 --> 00:07:07,740
is basically a protocol for managing

215
00:07:07,740 --> 00:07:10,319
intra-cluster Communications via this

216
00:07:10,319 --> 00:07:11,819
concept of different nodes in the

217
00:07:11,819 --> 00:07:13,620
cluster and the links between those

218
00:07:13,620 --> 00:07:15,780
nodes and you can see this used in

219
00:07:15,780 --> 00:07:18,539
industry by telcos

220
00:07:18,539 --> 00:07:20,400
so we kind of really want to spend some

221
00:07:20,400 --> 00:07:22,680
time just really understanding the ins

222
00:07:22,680 --> 00:07:24,840
and outs of the protocol it's kernel its

223
00:07:24,840 --> 00:07:26,940
implementation within the kernel and

224
00:07:26,940 --> 00:07:28,080
just trying to figure out what's going

225
00:07:28,080 --> 00:07:29,639
on and we want to remember we're doing

226
00:07:29,639 --> 00:07:31,860
this within the context of being

227
00:07:31,860 --> 00:07:33,780
interested within the remote surface so

228
00:07:33,780 --> 00:07:36,000
what parts of this implementation can we

229
00:07:36,000 --> 00:07:37,740
as remote attackers kind of touch and

230
00:07:37,740 --> 00:07:40,080
play around with so this is things like

231
00:07:40,080 --> 00:07:41,759
you know how do nodes authenticate with

232
00:07:41,759 --> 00:07:43,560
one another what are the different tipc

233
00:07:43,560 --> 00:07:45,120
messages types how do these look on the

234
00:07:45,120 --> 00:07:47,460
network how is the packet handling for

235
00:07:47,460 --> 00:07:49,139
these different types implemented within

236
00:07:49,139 --> 00:07:51,060
the kernel

237
00:07:51,060 --> 00:07:53,220
um so how do we go about doing this well

238
00:07:53,220 --> 00:07:55,319
this is where we cue like a montage of

239
00:07:55,319 --> 00:07:56,819
just trolling through documentation

240
00:07:56,819 --> 00:07:59,340
auditing The Source getting some

241
00:07:59,340 --> 00:08:01,560
Hands-On by writing up the libraries or

242
00:08:01,560 --> 00:08:03,240
scripts and then even using tools like

243
00:08:03,240 --> 00:08:04,919
Wireshark to understand what this really

244
00:08:04,919 --> 00:08:07,919
looks like over the wire

245
00:08:07,919 --> 00:08:10,139
so an important part of this process to

246
00:08:10,139 --> 00:08:12,060
highlight is just really bring to the

247
00:08:12,060 --> 00:08:13,080
Forefront the difference between

248
00:08:13,080 --> 00:08:14,819
interrupt context and the process

249
00:08:14,819 --> 00:08:17,580
context in terms of Kernel exploitation

250
00:08:17,580 --> 00:08:19,979
so typically when we're dealing with

251
00:08:19,979 --> 00:08:22,740
local privilege escalation if we gain

252
00:08:22,740 --> 00:08:24,960
like control of the of Kernel execution

253
00:08:24,960 --> 00:08:26,639
this is typically happening within the

254
00:08:26,639 --> 00:08:28,680
process context so this is where the

255
00:08:28,680 --> 00:08:30,240
kernel thread of execution is doing

256
00:08:30,240 --> 00:08:31,860
something on behalf of a user mode

257
00:08:31,860 --> 00:08:34,020
process like carrying out a cispool or

258
00:08:34,020 --> 00:08:36,719
something and notably you know this

259
00:08:36,719 --> 00:08:38,640
kernel thread is associated with the

260
00:08:38,640 --> 00:08:40,500
user mode process it has access to the

261
00:08:40,500 --> 00:08:42,059
tasks drug and kind of understands its

262
00:08:42,059 --> 00:08:44,039
privileges and things like that however

263
00:08:44,039 --> 00:08:45,779
as a remote attacker we don't really

264
00:08:45,779 --> 00:08:47,279
we're not we don't have a user mode

265
00:08:47,279 --> 00:08:49,140
process Associated as with us on the

266
00:08:49,140 --> 00:08:50,700
target we're throwing a packet across

267
00:08:50,700 --> 00:08:53,279
the network to a Target machine or it's

268
00:08:53,279 --> 00:08:55,440
network card will then receive this it

269
00:08:55,440 --> 00:08:58,800
will um trigger a hardware interrupt and

270
00:08:58,800 --> 00:09:00,959
interrupt handle and be cooled and you

271
00:09:00,959 --> 00:09:02,519
know in our context this could be like

272
00:09:02,519 --> 00:09:04,860
some tibc packet handling code and all

273
00:09:04,860 --> 00:09:06,360
this is happening in the network stack

274
00:09:06,360 --> 00:09:08,279
in the interrupt context

275
00:09:08,279 --> 00:09:11,040
so notably here there is no Associated

276
00:09:11,040 --> 00:09:13,380
user space and specifically there's no

277
00:09:13,380 --> 00:09:15,060
context switching at all when we're

278
00:09:15,060 --> 00:09:16,800
operating and operating in the interrupt

279
00:09:16,800 --> 00:09:18,899
context so there's no sleeping there's

280
00:09:18,899 --> 00:09:20,880
no scheduling and there's no user mode

281
00:09:20,880 --> 00:09:22,740
access at all so this presents some

282
00:09:22,740 --> 00:09:25,260
implications for remote attackers

283
00:09:25,260 --> 00:09:26,880
because ultimately if we want to pop a

284
00:09:26,880 --> 00:09:28,620
shell or something we need to inject

285
00:09:28,620 --> 00:09:30,540
some kind of user mode payload so this

286
00:09:30,540 --> 00:09:31,920
is all something this is all part of

287
00:09:31,920 --> 00:09:33,540
that developing understanding that we

288
00:09:33,540 --> 00:09:35,519
need to factor in we move on to the next

289
00:09:35,519 --> 00:09:38,040
step and begin developing that plan of

290
00:09:38,040 --> 00:09:39,060
attack

291
00:09:39,060 --> 00:09:41,339
so at this point hopefully you know we

292
00:09:41,339 --> 00:09:42,720
understand what we have with our

293
00:09:42,720 --> 00:09:44,580
arbitrary Heap overflow we understand

294
00:09:44,580 --> 00:09:46,140
where we are in the kernel and what

295
00:09:46,140 --> 00:09:47,519
we're dealing with so we're in a

296
00:09:47,519 --> 00:09:48,839
position where we can come up with a

297
00:09:48,839 --> 00:09:50,580
plan of attack and begin kind of

298
00:09:50,580 --> 00:09:52,320
formulating how this export is going to

299
00:09:52,320 --> 00:09:55,260
look so in this instance we've got a

300
00:09:55,260 --> 00:09:57,720
heap overflow as a remote attacker so

301
00:09:57,720 --> 00:09:59,640
the first thing we want to do is try and

302
00:09:59,640 --> 00:10:01,980
find some Primitives which will allow us

303
00:10:01,980 --> 00:10:03,899
to remotely shape the heat so we want to

304
00:10:03,899 --> 00:10:05,160
be able to fiddle with the heat and

305
00:10:05,160 --> 00:10:06,899
provide some flexibility to our Heap

306
00:10:06,899 --> 00:10:08,700
overflow so we're kind of looking for

307
00:10:08,700 --> 00:10:10,260
ways we can like objects we might be

308
00:10:10,260 --> 00:10:12,660
able to spray allocations for objects we

309
00:10:12,660 --> 00:10:14,820
can determine deterministically allocate

310
00:10:14,820 --> 00:10:16,200
and free you know if we're really lucky

311
00:10:16,200 --> 00:10:18,180
objects of varying sizes that we can

312
00:10:18,180 --> 00:10:19,620
kind of change which cache we're

313
00:10:19,620 --> 00:10:22,019
targeting and hopefully the next step

314
00:10:22,019 --> 00:10:23,760
there is we want to really leverage this

315
00:10:23,760 --> 00:10:25,740
Heap overflow alongside our heat

316
00:10:25,740 --> 00:10:28,260
Primitives to leverage our memory

317
00:10:28,260 --> 00:10:30,360
corruption into a control flow hijacking

318
00:10:30,360 --> 00:10:32,040
primitive so the way we'd want to do

319
00:10:32,040 --> 00:10:34,019
this is using our Heap overflow to

320
00:10:34,019 --> 00:10:36,120
corrupt like a function pointer in an

321
00:10:36,120 --> 00:10:38,519
adjacent object like a disruptor or

322
00:10:38,519 --> 00:10:40,140
something which will allow us to gain

323
00:10:40,140 --> 00:10:42,720
control flow hijacking primitive we can

324
00:10:42,720 --> 00:10:44,519
then use that to potentially pivot from

325
00:10:44,519 --> 00:10:46,019
the interrupt context if that's where

326
00:10:46,019 --> 00:10:47,459
we're in execution to the process

327
00:10:47,459 --> 00:10:50,279
context and then now we're in a position

328
00:10:50,279 --> 00:10:52,200
to inject some kind of payload publisher

329
00:10:52,200 --> 00:10:54,779
right sound sounds good almost too good

330
00:10:54,779 --> 00:10:57,000
of course we have a lot of mitigations

331
00:10:57,000 --> 00:10:59,279
to worry about this is a great project

332
00:10:59,279 --> 00:11:01,560
by Alex Popov called the Linux defense

333
00:11:01,560 --> 00:11:04,140
map I think this is for the 5.17 kernel

334
00:11:04,140 --> 00:11:05,700
and you can see there is a lot going on

335
00:11:05,700 --> 00:11:08,700
I couldn't fit it all on the screen but

336
00:11:08,700 --> 00:11:10,260
basically this is kind of like a

337
00:11:10,260 --> 00:11:13,440
flowchart of all the Contemporary main

338
00:11:13,440 --> 00:11:15,779
line out of tree commercial Hardware

339
00:11:15,779 --> 00:11:18,240
mitigations the relevant exploitation

340
00:11:18,240 --> 00:11:21,060
techniques and then different like

341
00:11:21,060 --> 00:11:23,160
detection mechanisms within the kernel

342
00:11:23,160 --> 00:11:25,680
but everything in green here is a

343
00:11:25,680 --> 00:11:27,480
Mainline mitigation currently

344
00:11:27,480 --> 00:11:29,640
implemented within the kernel so as you

345
00:11:29,640 --> 00:11:31,260
can see we're looking to kind of turn

346
00:11:31,260 --> 00:11:32,880
something we've got a lot to factor in

347
00:11:32,880 --> 00:11:35,160
here so this all can call very you know

348
00:11:35,160 --> 00:11:36,420
based on the Kernel versions we're

349
00:11:36,420 --> 00:11:38,220
looking at the architecture stuff like

350
00:11:38,220 --> 00:11:39,420
that so we have to kind of take into

351
00:11:39,420 --> 00:11:41,399
account that understanding we've

352
00:11:41,399 --> 00:11:43,019
developed and apply that to figuring out

353
00:11:43,019 --> 00:11:44,399
what mitigations we've got to worry

354
00:11:44,399 --> 00:11:46,740
about so in our instance you know our

355
00:11:46,740 --> 00:11:48,420
initial plan of attack we're looking at

356
00:11:48,420 --> 00:11:49,860
getting a control flow hijacking

357
00:11:49,860 --> 00:11:51,360
Primitives or some kind of rock chain

358
00:11:51,360 --> 00:11:53,760
there so we have to worry about kslr if

359
00:11:53,760 --> 00:11:55,980
we want to find our gadgets depending on

360
00:11:55,980 --> 00:11:57,660
how we want to Pivot from the interrupts

361
00:11:57,660 --> 00:11:59,399
the process context we need to worry

362
00:11:59,399 --> 00:12:00,600
about things like write protection

363
00:12:00,600 --> 00:12:02,820
within the kernel and then if we want to

364
00:12:02,820 --> 00:12:04,620
inject the user mode payload we have to

365
00:12:04,620 --> 00:12:06,540
worry about mitigations like smep and

366
00:12:06,540 --> 00:12:09,000
snap so a lot to factor in here but we

367
00:12:09,000 --> 00:12:10,680
need to take all of this into account

368
00:12:10,680 --> 00:12:12,300
when we're developing that understanding

369
00:12:12,300 --> 00:12:15,079
and coming up with that plan of attack

370
00:12:15,079 --> 00:12:17,820
so hopefully with all this in mind we're

371
00:12:17,820 --> 00:12:19,260
in a position to begin enumerating

372
00:12:19,260 --> 00:12:21,839
Primitives I've kind of thrown this word

373
00:12:21,839 --> 00:12:23,339
around a lot like what do I mean by

374
00:12:23,339 --> 00:12:25,500
Primitives in this context and these are

375
00:12:25,500 --> 00:12:27,060
basically just building blocks which

376
00:12:27,060 --> 00:12:28,500
help us progress our plan of attack

377
00:12:28,500 --> 00:12:30,779
little aspects of capability we're able

378
00:12:30,779 --> 00:12:32,399
to leverage within the kernel given our

379
00:12:32,399 --> 00:12:34,200
exploitation Primitives which help us

380
00:12:34,200 --> 00:12:35,760
get from A to B

381
00:12:35,760 --> 00:12:37,140
um you know we start off riding a little

382
00:12:37,140 --> 00:12:39,779
Heap overflow primitive maybe this we

383
00:12:39,779 --> 00:12:41,940
can leverage that into a control flow

384
00:12:41,940 --> 00:12:43,380
hijacking primitive and so on and so

385
00:12:43,380 --> 00:12:44,880
forth and we're trying to piece these

386
00:12:44,880 --> 00:12:47,279
all together to get remote code

387
00:12:47,279 --> 00:12:49,740
execution so how do we find them well

388
00:12:49,740 --> 00:12:51,540
there's many approaches here

389
00:12:51,540 --> 00:12:53,040
um as with all the things in this field

390
00:12:53,040 --> 00:12:55,800
uh for me it really starts again with

391
00:12:55,800 --> 00:12:57,540
that fundamental understanding by

392
00:12:57,540 --> 00:12:59,100
understanding the code we're looking at

393
00:12:59,100 --> 00:13:00,959
we can narrow the scope easily we're not

394
00:13:00,959 --> 00:13:02,220
looking at stuff that we're not going to

395
00:13:02,220 --> 00:13:04,139
be able to touch and it also allows us

396
00:13:04,139 --> 00:13:06,720
to pick up nuances in the code itself if

397
00:13:06,720 --> 00:13:09,000
we want to find inconsistencies in a bit

398
00:13:09,000 --> 00:13:10,260
of code it really helps if we understand

399
00:13:10,260 --> 00:13:12,240
what's going on

400
00:13:12,240 --> 00:13:14,700
um the next step is about taking a

401
00:13:14,700 --> 00:13:16,440
Target approach again we want to break

402
00:13:16,440 --> 00:13:18,660
down this problem into manageable steps

403
00:13:18,660 --> 00:13:20,399
you know for example if we're looking

404
00:13:20,399 --> 00:13:22,200
for heat Primitives maybe we want to

405
00:13:22,200 --> 00:13:24,120
start with right let's look at all the K

406
00:13:24,120 --> 00:13:25,680
malloc allocations or the slab

407
00:13:25,680 --> 00:13:27,540
allocations that are going on kind of

408
00:13:27,540 --> 00:13:29,279
order them by size you know what cash

409
00:13:29,279 --> 00:13:30,720
they're going into if they're reachable

410
00:13:30,720 --> 00:13:32,639
things like that and then the next step

411
00:13:32,639 --> 00:13:35,279
of this is being methodical and making

412
00:13:35,279 --> 00:13:36,839
sure we document as much as we can

413
00:13:36,839 --> 00:13:38,220
because this is all knowledge and

414
00:13:38,220 --> 00:13:40,079
understanding we're building up and like

415
00:13:40,079 --> 00:13:41,820
I mentioned this is an iterative process

416
00:13:41,820 --> 00:13:43,860
so like this attack plan might not work

417
00:13:43,860 --> 00:13:45,839
out but you know some of the Primitives

418
00:13:45,839 --> 00:13:47,339
or techniques we've come up with and

419
00:13:47,339 --> 00:13:48,959
we've discovered could be useful later

420
00:13:48,959 --> 00:13:51,120
on so by documenting everything or

421
00:13:51,120 --> 00:13:52,920
saving ourselves some time we're not

422
00:13:52,920 --> 00:13:55,079
going to repeat things and it just makes

423
00:13:55,079 --> 00:13:56,760
life a lot easier

424
00:13:56,760 --> 00:13:59,519
so when it comes to actually locating

425
00:13:59,519 --> 00:14:01,079
um things and how do we look around so

426
00:14:01,079 --> 00:14:01,860
of course there's like good

427
00:14:01,860 --> 00:14:03,779
old-fashioned Source auditing

428
00:14:03,779 --> 00:14:04,980
um you know just going through the flow

429
00:14:04,980 --> 00:14:06,779
and understanding what's happening you

430
00:14:06,779 --> 00:14:08,399
know we can use things like regular

431
00:14:08,399 --> 00:14:10,019
expressions and the you know the

432
00:14:10,019 --> 00:14:11,519
standard kernel guidelines to kind of

433
00:14:11,519 --> 00:14:12,660
narrow things down and look for

434
00:14:12,660 --> 00:14:14,399
particular signatures

435
00:14:14,399 --> 00:14:15,720
um and then we can go in with a bit of

436
00:14:15,720 --> 00:14:17,700
deeper analysis via kernel bugging if we

437
00:14:17,700 --> 00:14:18,839
really want to understand how a

438
00:14:18,839 --> 00:14:20,339
particular functionality Works how

439
00:14:20,339 --> 00:14:22,740
something looks in memory

440
00:14:22,740 --> 00:14:24,899
and it was actually during this

441
00:14:24,899 --> 00:14:26,700
enumeration

442
00:14:26,700 --> 00:14:28,980
um section where I actually came across

443
00:14:28,980 --> 00:14:30,540
the shock

444
00:14:30,540 --> 00:14:32,040
um at the time we can see on the top

445
00:14:32,040 --> 00:14:34,620
left I was looking for elastic objects

446
00:14:34,620 --> 00:14:36,959
within the tipc module so these are

447
00:14:36,959 --> 00:14:39,120
basically objects of dynamic length so

448
00:14:39,120 --> 00:14:40,860
where their length is defined by a field

449
00:14:40,860 --> 00:14:42,899
within the object as opposed to like

450
00:14:42,899 --> 00:14:45,779
your typical static struct and these are

451
00:14:45,779 --> 00:14:47,820
useful and contemporary exploitation

452
00:14:47,820 --> 00:14:49,860
techniques because if we can corrupt

453
00:14:49,860 --> 00:14:51,300
that length make it longer than it

454
00:14:51,300 --> 00:14:53,160
should be and read it back we can have

455
00:14:53,160 --> 00:14:54,600
an out of bounds read and potentially

456
00:14:54,600 --> 00:14:56,220
like a kslr league or something like

457
00:14:56,220 --> 00:14:57,779
that so that was my motivation behind

458
00:14:57,779 --> 00:15:00,120
this you can see to do so I used a

459
00:15:00,120 --> 00:15:01,860
highly sophisticated regular expression

460
00:15:01,860 --> 00:15:04,860
here to try and find basically mem

461
00:15:04,860 --> 00:15:08,519
copies whose size parameter was a the

462
00:15:08,519 --> 00:15:10,620
object's field rather than your typical

463
00:15:10,620 --> 00:15:13,139
size obstruct it was a foolproof as the

464
00:15:13,139 --> 00:15:15,180
second result shows but it did come up

465
00:15:15,180 --> 00:15:16,740
with one interesting one so immediately

466
00:15:16,740 --> 00:15:18,660
I'm like right let's take a look at this

467
00:15:18,660 --> 00:15:20,040
what's going on

468
00:15:20,040 --> 00:15:22,680
uh so before we dive right into the code

469
00:15:22,680 --> 00:15:25,440
a bit of context about this monitor uh

470
00:15:25,440 --> 00:15:28,139
subsystem this part of tibc part of this

471
00:15:28,139 --> 00:15:30,240
implementation is to handle the sending

472
00:15:30,240 --> 00:15:32,279
and receiving of domain records to

473
00:15:32,279 --> 00:15:34,500
different tipc nodes within the same

474
00:15:34,500 --> 00:15:36,540
domain and these domain records

475
00:15:36,540 --> 00:15:39,120
basically allow different TABC nodes to

476
00:15:39,120 --> 00:15:41,579
tell their peers hey this is what my

477
00:15:41,579 --> 00:15:43,139
view of the network is this is who I

478
00:15:43,139 --> 00:15:45,420
think is up things like that and we can

479
00:15:45,420 --> 00:15:47,279
see these domain records are implemented

480
00:15:47,279 --> 00:15:49,560
by this struct on the bottom left struct

481
00:15:49,560 --> 00:15:52,139
tipc modern domain

482
00:15:52,139 --> 00:15:54,360
um and we can see that is indeed an

483
00:15:54,360 --> 00:15:56,699
elastic object we have this dynamically

484
00:15:56,699 --> 00:15:58,440
sized members field

485
00:15:58,440 --> 00:16:00,000
um the size of which is defined by

486
00:16:00,000 --> 00:16:02,100
member count we can see there's a limit

487
00:16:02,100 --> 00:16:04,560
to this defined by maximum domain so we

488
00:16:04,560 --> 00:16:06,360
can have up to 64 members but this can

489
00:16:06,360 --> 00:16:08,760
be a variable size and then we have this

490
00:16:08,760 --> 00:16:10,800
Len field which determines the actual

491
00:16:10,800 --> 00:16:12,720
length in bytes of the object so this

492
00:16:12,720 --> 00:16:14,820
will be the sum of all the static fields

493
00:16:14,820 --> 00:16:16,980
and then the sum of this members field

494
00:16:16,980 --> 00:16:19,500
depending on the size of member count

495
00:16:19,500 --> 00:16:22,079
okay sounds good so let's just take a

496
00:16:22,079 --> 00:16:23,699
look on the right we can see that the

497
00:16:23,699 --> 00:16:26,339
mem copy is over here on line 30. so

498
00:16:26,339 --> 00:16:27,959
this is what we're interested in let's

499
00:16:27,959 --> 00:16:29,760
get a bit of context about what's going

500
00:16:29,760 --> 00:16:31,560
on in this piece of code

501
00:16:31,560 --> 00:16:34,320
so the function on line three we can see

502
00:16:34,320 --> 00:16:36,480
it's tipc mon receive

503
00:16:36,480 --> 00:16:38,579
so this is the implementation which is

504
00:16:38,579 --> 00:16:40,860
responsible for receiving and processing

505
00:16:40,860 --> 00:16:43,259
these domain record packets

506
00:16:43,259 --> 00:16:45,300
as we can see in the function signature

507
00:16:45,300 --> 00:16:46,560
up there there's a lot of interesting

508
00:16:46,560 --> 00:16:49,620
parameters uh pertinent to us is this

509
00:16:49,620 --> 00:16:54,060
data and dlan data is a pointer to the

510
00:16:54,060 --> 00:16:56,399
tibc packets data that we've just

511
00:16:56,399 --> 00:16:59,220
received and then dlan is the length of

512
00:16:59,220 --> 00:17:02,279
this data as defined in the tipc packet

513
00:17:02,279 --> 00:17:04,559
header so this is being processed

514
00:17:04,559 --> 00:17:07,020
straight away on line six we can see we

515
00:17:07,020 --> 00:17:09,959
immediately cast that new packet data to

516
00:17:09,959 --> 00:17:12,599
one of these domain records and then on

517
00:17:12,599 --> 00:17:15,119
line 10 to 14 we kind of pull out the

518
00:17:15,119 --> 00:17:16,980
fields of this record into local

519
00:17:16,980 --> 00:17:19,740
variables and then as we'd expect on

520
00:17:19,740 --> 00:17:22,859
line 17 to 23 we do some sanitization to

521
00:17:22,859 --> 00:17:24,780
make sure this is a legitimate domain

522
00:17:24,780 --> 00:17:26,880
record namely

523
00:17:26,880 --> 00:17:28,380
we're basically doing some checks

524
00:17:28,380 --> 00:17:30,600
against the packet length so we checked

525
00:17:30,600 --> 00:17:33,000
that the tipc data length is at least

526
00:17:33,000 --> 00:17:35,400
long enough to hold an empty domain

527
00:17:35,400 --> 00:17:37,559
record otherwise you know what's going

528
00:17:37,559 --> 00:17:38,280
on

529
00:17:38,280 --> 00:17:41,220
the next check is to see that the tipc

530
00:17:41,220 --> 00:17:43,380
packet length matches the size we'd

531
00:17:43,380 --> 00:17:45,480
expect for a domain record given the

532
00:17:45,480 --> 00:17:47,700
member count is specified and then

533
00:17:47,700 --> 00:17:50,460
finally we check that the tibc data

534
00:17:50,460 --> 00:17:51,620
length

535
00:17:51,620 --> 00:17:54,179
matches the length the domain records

536
00:17:54,179 --> 00:17:56,220
says it is in the Len field so if all

537
00:17:56,220 --> 00:17:58,260
this checks out it all looks good we go

538
00:17:58,260 --> 00:18:00,120
on to do some more processing and then

539
00:18:00,120 --> 00:18:01,340
finally

540
00:18:01,340 --> 00:18:04,740
on line 26 here we'll do a block which

541
00:18:04,740 --> 00:18:06,780
basically says okay have we already

542
00:18:06,780 --> 00:18:08,760
received a domain record from this pier

543
00:18:08,760 --> 00:18:11,280
if we have we'll cache that old copy

544
00:18:11,280 --> 00:18:12,960
which is where that mem copy comes in

545
00:18:12,960 --> 00:18:15,960
and then later on I will update the peer

546
00:18:15,960 --> 00:18:17,880
to reflect the new domain record we've

547
00:18:17,880 --> 00:18:20,039
sent okay A bit of an information dump

548
00:18:20,039 --> 00:18:23,160
there but that's what's going on

549
00:18:23,160 --> 00:18:25,500
um so where does our mem copy come in so

550
00:18:25,500 --> 00:18:28,140
if we go back to that sanitization

551
00:18:28,140 --> 00:18:30,840
um we actually never check

552
00:18:30,840 --> 00:18:33,120
um that member count is at least

553
00:18:33,120 --> 00:18:35,280
um is equal to or less than this kind of

554
00:18:35,280 --> 00:18:37,080
limit we've defined here in maximum

555
00:18:37,080 --> 00:18:39,600
domain so the reality is we could send a

556
00:18:39,600 --> 00:18:41,760
domain record with a member count of

557
00:18:41,760 --> 00:18:44,640
like 200 which would be much larger than

558
00:18:44,640 --> 00:18:47,700
the 272 bytes we're expecting here and

559
00:18:47,700 --> 00:18:50,039
as long as the Len field and the tibc

560
00:18:50,039 --> 00:18:52,320
packet headers length all line up will

561
00:18:52,320 --> 00:18:54,360
pass this sanitization

562
00:18:54,360 --> 00:18:56,280
so then if we go on to reach this mem

563
00:18:56,280 --> 00:18:58,260
copy so we cache one of these malicious

564
00:18:58,260 --> 00:18:59,700
domain records

565
00:18:59,700 --> 00:19:01,440
which is much larger than it should be

566
00:19:01,440 --> 00:19:04,020
and we can see that you know Dom is the

567
00:19:04,020 --> 00:19:05,580
the previous domain record we've sent

568
00:19:05,580 --> 00:19:07,380
we're using the length to determine the

569
00:19:07,380 --> 00:19:09,299
size of the mem copy but then the

570
00:19:09,299 --> 00:19:11,460
destination object here is this Dom

571
00:19:11,460 --> 00:19:13,820
before and if we look where that's

572
00:19:13,820 --> 00:19:15,960
defined we can see this is actually a

573
00:19:15,960 --> 00:19:17,820
local struct so this is being copied

574
00:19:17,820 --> 00:19:20,340
into a stack-based buffer which is only

575
00:19:20,340 --> 00:19:24,000
expecting 272 bytes so this is sounding

576
00:19:24,000 --> 00:19:25,980
an awful lot like a stack based buffer

577
00:19:25,980 --> 00:19:27,000
overflow right like pretty

578
00:19:27,000 --> 00:19:28,620
straightforward

579
00:19:28,620 --> 00:19:30,480
which brings us on to the next stage

580
00:19:30,480 --> 00:19:34,440
denial AKA verification lots and lots of

581
00:19:34,440 --> 00:19:36,600
verification on my part and then

582
00:19:36,600 --> 00:19:38,100
disclosure

583
00:19:38,100 --> 00:19:40,380
so I think I'd be remiss not to mention

584
00:19:40,380 --> 00:19:42,840
like the Imposter syndrome is real um in

585
00:19:42,840 --> 00:19:45,240
this industry uh but again I'm no

586
00:19:45,240 --> 00:19:48,299
exception to that so um like I checked

587
00:19:48,299 --> 00:19:50,220
this so many times to make sure what I

588
00:19:50,220 --> 00:19:51,480
was looking at was what I was actually

589
00:19:51,480 --> 00:19:53,340
looking at because it's like no way is

590
00:19:53,340 --> 00:19:54,900
this just sitting here right this isn't

591
00:19:54,900 --> 00:19:57,720
this is this isn't the case so there's a

592
00:19:57,720 --> 00:19:59,160
lot of due diligence behind making sure

593
00:19:59,160 --> 00:20:01,440
this was was legit that I could trigger

594
00:20:01,440 --> 00:20:03,179
it reliably remotely coming up with a

595
00:20:03,179 --> 00:20:05,580
proof of concept understand being like

596
00:20:05,580 --> 00:20:07,620
what was going on and the impact

597
00:20:07,620 --> 00:20:09,360
and as soon as that was all clarified

598
00:20:09,360 --> 00:20:11,340
that was the point to move on to

599
00:20:11,340 --> 00:20:12,539
carrying out the coordinated

600
00:20:12,539 --> 00:20:14,820
vulnerability disclosure process

601
00:20:14,820 --> 00:20:16,980
and that had a few hurdles in itself on

602
00:20:16,980 --> 00:20:19,020
my part and I wrote I wrote a Blog about

603
00:20:19,020 --> 00:20:20,580
this if you're interested in the

604
00:20:20,580 --> 00:20:23,820
disclosure process but the tldr here is

605
00:20:23,820 --> 00:20:25,980
there's an initial embargo disclosure so

606
00:20:25,980 --> 00:20:28,020
I will contact the relevant private

607
00:20:28,020 --> 00:20:29,880
mailing lists which are in this case the

608
00:20:29,880 --> 00:20:32,220
Linux kernel distros and the Linux kind

609
00:20:32,220 --> 00:20:34,200
of security team I'll send them analysis

610
00:20:34,200 --> 00:20:35,640
and a patch submission a patch

611
00:20:35,640 --> 00:20:37,559
suggestion sorry

612
00:20:37,559 --> 00:20:39,840
um and then suggest an embargo period I

613
00:20:39,840 --> 00:20:41,580
think in this case it was 14 days which

614
00:20:41,580 --> 00:20:43,440
was the maximum and then there's some

615
00:20:43,440 --> 00:20:46,080
discussion the patch is finalized and

616
00:20:46,080 --> 00:20:47,640
then at the end of that embargo period

617
00:20:47,640 --> 00:20:49,559
the patch is submitted and at the same

618
00:20:49,559 --> 00:20:51,419
time there's a public disclosure where I

619
00:20:51,419 --> 00:20:54,000
post that analyzes on a public mailing

620
00:20:54,000 --> 00:20:55,620
list which was the open source security

621
00:20:55,620 --> 00:20:56,580
one

622
00:20:56,580 --> 00:20:58,320
and you know all in all it was a pretty

623
00:20:58,320 --> 00:20:59,640
quick turnaround it was a really cool

624
00:20:59,640 --> 00:21:01,200
experience to to interact with a

625
00:21:01,200 --> 00:21:03,539
community like that I'd be like if I

626
00:21:03,539 --> 00:21:05,160
said my disclosure debut didn't go off

627
00:21:05,160 --> 00:21:07,559
to a flying start I had issues of like

628
00:21:07,559 --> 00:21:10,440
pgp and like Office 365 not liking each

629
00:21:10,440 --> 00:21:11,640
other which meant like the first few

630
00:21:11,640 --> 00:21:13,919
emails I sent were just empty apart from

631
00:21:13,919 --> 00:21:15,480
this massive disclaimer this

632
00:21:15,480 --> 00:21:17,700
confidentiality disclaimer Office 365

633
00:21:17,700 --> 00:21:20,039
was a pending which obviously wasn't a

634
00:21:20,039 --> 00:21:21,419
great look on a free and open source

635
00:21:21,419 --> 00:21:24,299
mailing list but I digress got there in

636
00:21:24,299 --> 00:21:27,480
the end it's all patched and fine now

637
00:21:27,480 --> 00:21:29,820
but you know that's the responsible

638
00:21:29,820 --> 00:21:31,260
stuff out the way we've covered the soft

639
00:21:31,260 --> 00:21:33,419
skills let's try and get rce on a modern

640
00:21:33,419 --> 00:21:35,460
kernel which brings us on to the next

641
00:21:35,460 --> 00:21:37,559
stage anger

642
00:21:37,559 --> 00:21:39,900
so we've got a new bug we're going to

643
00:21:39,900 --> 00:21:41,760
try approach this exploit it let's not

644
00:21:41,760 --> 00:21:43,559
get overwhelmed let's record the game

645
00:21:43,559 --> 00:21:46,260
plan as we said first step get that

646
00:21:46,260 --> 00:21:48,179
understanding of what's going on get the

647
00:21:48,179 --> 00:21:50,220
layer of the land develop a plan of

648
00:21:50,220 --> 00:21:52,320
attack figure out how to implement that

649
00:21:52,320 --> 00:21:54,059
by enumerating some Primitives and then

650
00:21:54,059 --> 00:21:56,539
win right sounds good so like before

651
00:21:56,539 --> 00:21:59,220
we'll dive into this game plan a little

652
00:21:59,220 --> 00:22:00,960
bit more detail except this time we're

653
00:22:00,960 --> 00:22:02,700
using that newly found stack button

654
00:22:02,700 --> 00:22:04,260
Rover flow

655
00:22:04,260 --> 00:22:06,419
um as our case study

656
00:22:06,419 --> 00:22:08,880
fortunately all that time reading

657
00:22:08,880 --> 00:22:11,039
through documentation and writing hacky

658
00:22:11,039 --> 00:22:13,860
tipc Network libraries and C is all

659
00:22:13,860 --> 00:22:15,059
still relevant

660
00:22:15,059 --> 00:22:17,520
so that's time well spent at least as

661
00:22:17,520 --> 00:22:19,919
the bugs in the same place however this

662
00:22:19,919 --> 00:22:21,480
time our exploitation primitive has

663
00:22:21,480 --> 00:22:23,159
changed we've got different requirements

664
00:22:23,159 --> 00:22:25,260
to reach our goals of rce now that we're

665
00:22:25,260 --> 00:22:27,299
looking at stack Overflow rather than a

666
00:22:27,299 --> 00:22:29,880
heap one namely our route to control

667
00:22:29,880 --> 00:22:31,320
flow hijacking Primitives could

668
00:22:31,320 --> 00:22:32,880
potentially be a lot easier here right

669
00:22:32,880 --> 00:22:34,440
if we just overflow that return address

670
00:22:34,440 --> 00:22:38,400
we've got instant kernel control

671
00:22:38,400 --> 00:22:39,840
um and then we also again have to go

672
00:22:39,840 --> 00:22:41,340
through the process of understanding the

673
00:22:41,340 --> 00:22:42,840
Primitive and our constraints you know

674
00:22:42,840 --> 00:22:46,200
we're copying into a 272 byte buffer

675
00:22:46,200 --> 00:22:47,820
um it turned out that we couldn't just

676
00:22:47,820 --> 00:22:49,919
have Len as large as we want we're

677
00:22:49,919 --> 00:22:51,299
actually limited by the maximum

678
00:22:51,299 --> 00:22:52,919
transmission unit of the medium we're

679
00:22:52,919 --> 00:22:54,840
using so we're looking at a typical

680
00:22:54,840 --> 00:22:56,520
ethernet config and they take into

681
00:22:56,520 --> 00:22:58,260
account headers and stuff we've got a

682
00:22:58,260 --> 00:23:01,620
1400 byte payload going into that 272

683
00:23:01,620 --> 00:23:03,539
byte stack so we've got a bit of wiggle

684
00:23:03,539 --> 00:23:05,039
room there

685
00:23:05,039 --> 00:23:07,020
um and again we know for sure now we're

686
00:23:07,020 --> 00:23:08,400
dealing with the interrupt context

687
00:23:08,400 --> 00:23:10,620
because we're directly going to be

688
00:23:10,620 --> 00:23:13,500
hijacking control during that TABC

689
00:23:13,500 --> 00:23:14,940
packet handling code in the network

690
00:23:14,940 --> 00:23:17,220
stack and then we've got some more

691
00:23:17,220 --> 00:23:18,539
information now different kernel

692
00:23:18,539 --> 00:23:20,280
versions We have to consider based on

693
00:23:20,280 --> 00:23:22,140
what we want to Target

694
00:23:22,140 --> 00:23:24,240
cool so now we're in a position to come

695
00:23:24,240 --> 00:23:25,980
up with a plan of attack it's looking

696
00:23:25,980 --> 00:23:28,200
pretty similar to before except the

697
00:23:28,200 --> 00:23:30,419
start again we have a more simple route

698
00:23:30,419 --> 00:23:32,220
to a control flow hijacking primitive

699
00:23:32,220 --> 00:23:33,780
potentially

700
00:23:33,780 --> 00:23:35,520
um so we want to go from that like a

701
00:23:35,520 --> 00:23:37,020
rock chain or something to some more

702
00:23:37,020 --> 00:23:38,520
flexible form of arbitrary code

703
00:23:38,520 --> 00:23:40,980
execution this will make it easier for

704
00:23:40,980 --> 00:23:42,600
us to Pivot from that interrupt context

705
00:23:42,600 --> 00:23:44,760
so the process context and then like

706
00:23:44,760 --> 00:23:46,559
before we're in a position to kind of

707
00:23:46,559 --> 00:23:48,900
like inject some kind of user space

708
00:23:48,900 --> 00:23:51,539
payload to get our final reverse shell

709
00:23:51,539 --> 00:23:53,760
or something right again sounding very

710
00:23:53,760 --> 00:23:55,679
easy you have to consider the

711
00:23:55,679 --> 00:23:58,320
mitigations here great

712
00:23:58,320 --> 00:24:00,539
um like before if we're dealing with a

713
00:24:00,539 --> 00:24:02,039
control flow hijacking primitive we want

714
00:24:02,039 --> 00:24:03,419
to do some rock we've got to worry about

715
00:24:03,419 --> 00:24:06,299
kslr so we can find the gadgets write

716
00:24:06,299 --> 00:24:08,460
protection and stuff for our pivot snap

717
00:24:08,460 --> 00:24:11,940
and snap for the user mode injection

718
00:24:11,940 --> 00:24:13,679
but now of course we're looking at a

719
00:24:13,679 --> 00:24:15,120
stack base buffer overflow so our

720
00:24:15,120 --> 00:24:16,799
primitive changed a little bit how does

721
00:24:16,799 --> 00:24:18,539
that impact the mitigations we've got to

722
00:24:18,539 --> 00:24:20,460
worry about well now we have to worry

723
00:24:20,460 --> 00:24:22,500
about stack protector which introduces

724
00:24:22,500 --> 00:24:24,360
stacking areas so that's another leak

725
00:24:24,360 --> 00:24:26,580
requirement we need and then we also

726
00:24:26,580 --> 00:24:29,400
have a relatively new mitigation which

727
00:24:29,400 --> 00:24:31,559
was implemented last summer I think in

728
00:24:31,559 --> 00:24:35,100
5.12 kernels called fortify source

729
00:24:35,100 --> 00:24:37,140
and part of this mitigation introduced

730
00:24:37,140 --> 00:24:39,840
strict strict mem copy bounds checking

731
00:24:39,840 --> 00:24:41,520
so basically

732
00:24:41,520 --> 00:24:44,100
um if the kernel act compile time or

733
00:24:44,100 --> 00:24:47,340
boot time or runtime sorry knows the

734
00:24:47,340 --> 00:24:49,400
size of either the source or destination

735
00:24:49,400 --> 00:24:52,320
objects of a mem copy if the size is

736
00:24:52,320 --> 00:24:53,760
larger than those and something's wrong

737
00:24:53,760 --> 00:24:55,440
would have trigger a kernel panic and

738
00:24:55,440 --> 00:24:56,520
we're done

739
00:24:56,520 --> 00:24:59,400
now this sounds a lot like the root

740
00:24:59,400 --> 00:25:01,260
cause of the stack based buffer overflow

741
00:25:01,260 --> 00:25:03,240
we've been looking at and it exactly is

742
00:25:03,240 --> 00:25:06,480
so that is just a hard mitigation to to

743
00:25:06,480 --> 00:25:08,100
what we've been looking at talking about

744
00:25:08,100 --> 00:25:09,480
and the plan of attack we've come up

745
00:25:09,480 --> 00:25:13,679
with so that's it I guess or

746
00:25:13,679 --> 00:25:16,620
or we could just Target a kernel prior

747
00:25:16,620 --> 00:25:18,480
to this fortify Source coming in right

748
00:25:18,480 --> 00:25:20,340
we could just do one like maybe prior to

749
00:25:20,340 --> 00:25:22,740
512 we've got good coverage so let's go

750
00:25:22,740 --> 00:25:24,600
with that right and then we've got to

751
00:25:24,600 --> 00:25:27,299
still find this kslr and canaries league

752
00:25:27,299 --> 00:25:29,640
but what if we just say give it a nice

753
00:25:29,640 --> 00:25:31,440
leak given you know we can plug in a

754
00:25:31,440 --> 00:25:33,000
link down the line maybe we'll find one

755
00:25:33,000 --> 00:25:35,220
maybe someone else will find one would

756
00:25:35,220 --> 00:25:37,260
have given a leak what does our attack

757
00:25:37,260 --> 00:25:38,880
really look like right it would be a

758
00:25:38,880 --> 00:25:41,520
shame to have wasted all this time let's

759
00:25:41,520 --> 00:25:43,440
uh let's just Steam on ahead for a

760
00:25:43,440 --> 00:25:45,240
little bit and and try to implement this

761
00:25:45,240 --> 00:25:46,740
plan of attack and see what it looks

762
00:25:46,740 --> 00:25:48,799
like in action

763
00:25:48,799 --> 00:25:51,960
so after a few you know iterative

764
00:25:51,960 --> 00:25:53,700
processes of enumerating this attack

765
00:25:53,700 --> 00:25:55,320
plan now that we're going ahead with it

766
00:25:55,320 --> 00:25:58,020
it looks something like this

767
00:25:58,020 --> 00:26:00,059
um so we want to Pivot from our initial

768
00:26:00,059 --> 00:26:02,220
uh rip control so our initial control

769
00:26:02,220 --> 00:26:04,320
flow hijacking primitive using Rock we

770
00:26:04,320 --> 00:26:05,820
need to get some Shell Code execution

771
00:26:05,820 --> 00:26:07,620
we've got a lot of data on the stack

772
00:26:07,620 --> 00:26:09,720
let's try and find a way to use it

773
00:26:09,720 --> 00:26:12,299
and then to Pivot to the process context

774
00:26:12,299 --> 00:26:13,559
we're going to use a technique called

775
00:26:13,559 --> 00:26:15,960
Cisco hooking

776
00:26:15,960 --> 00:26:18,539
um and then we can use that hook to

777
00:26:18,539 --> 00:26:20,400
deliver our user mode payload and win

778
00:26:20,400 --> 00:26:22,620
right all sounds good

779
00:26:22,620 --> 00:26:24,000
so now we're actually getting to some

780
00:26:24,000 --> 00:26:25,620
technicals you know we've got the attack

781
00:26:25,620 --> 00:26:26,940
plan out the way

782
00:26:26,940 --> 00:26:28,380
um let's just get our bearings a little

783
00:26:28,380 --> 00:26:30,059
bit before we dive into some code so we

784
00:26:30,059 --> 00:26:31,919
can understand where we are all right

785
00:26:31,919 --> 00:26:33,419
so we've got this stack based buffer

786
00:26:33,419 --> 00:26:36,059
overflow let's get a bit of context and

787
00:26:36,059 --> 00:26:37,380
there's a few things we can do here to

788
00:26:37,380 --> 00:26:38,700
kind of build up our understanding of

789
00:26:38,700 --> 00:26:40,140
what's going on

790
00:26:40,140 --> 00:26:42,299
um on the bottom right we can see we can

791
00:26:42,299 --> 00:26:44,220
kind of look at the disassembly for the

792
00:26:44,220 --> 00:26:46,320
vulnerable function we can look at like

793
00:26:46,320 --> 00:26:48,179
the prologue and the epilogue so we can

794
00:26:48,179 --> 00:26:49,500
kind of understand what's being done to

795
00:26:49,500 --> 00:26:50,640
the stack

796
00:26:50,640 --> 00:26:52,080
um you know we can see the size of the

797
00:26:52,080 --> 00:26:53,700
stack frame we can see the registers

798
00:26:53,700 --> 00:26:55,500
that are being popped off and we have

799
00:26:55,500 --> 00:26:59,340
control over and then on the left this

800
00:26:59,340 --> 00:27:02,039
is a an output from GDB and we can break

801
00:27:02,039 --> 00:27:03,900
on the vulnerable mem copy to kind of

802
00:27:03,900 --> 00:27:05,820
see what the stack looked like before

803
00:27:05,820 --> 00:27:08,220
our overflow and so this is a picture of

804
00:27:08,220 --> 00:27:10,919
the tipc mon receive stack frame we can

805
00:27:10,919 --> 00:27:12,559
see where our buff is going to be

806
00:27:12,559 --> 00:27:14,400
overflowing we can see the original

807
00:27:14,400 --> 00:27:16,559
values of some of those saved registers

808
00:27:16,559 --> 00:27:18,600
and then we could continue looking down

809
00:27:18,600 --> 00:27:20,880
this to see the stack flow the stack

810
00:27:20,880 --> 00:27:23,100
frames that are after this and what

811
00:27:23,100 --> 00:27:25,020
other damage we're going to cause

812
00:27:25,020 --> 00:27:26,820
and with all this information in mind

813
00:27:26,820 --> 00:27:28,620
we're in a position to kind of get an

814
00:27:28,620 --> 00:27:30,720
idea like on the top right of what our

815
00:27:30,720 --> 00:27:32,340
payload might look like in memory the

816
00:27:32,340 --> 00:27:33,960
kind of offsets to our different fields

817
00:27:33,960 --> 00:27:35,880
and constraints where we want certain

818
00:27:35,880 --> 00:27:38,220
values to go

819
00:27:38,220 --> 00:27:39,779
so now we've got an understanding of

820
00:27:39,779 --> 00:27:41,820
like what where we are what's going on

821
00:27:41,820 --> 00:27:43,559
it's time to actually get to work and

822
00:27:43,559 --> 00:27:45,360
figure out how we want to go from our

823
00:27:45,360 --> 00:27:47,640
initial Rock chain to getting a more

824
00:27:47,640 --> 00:27:49,500
flexible form of execution right we've

825
00:27:49,500 --> 00:27:51,659
got all this space on the stack um to

826
00:27:51,659 --> 00:27:53,640
put our data in it'd be really cool if

827
00:27:53,640 --> 00:27:55,080
we could just jump to that and execute

828
00:27:55,080 --> 00:27:56,700
that right

829
00:27:56,700 --> 00:27:58,559
um fortunately you know with a control

830
00:27:58,559 --> 00:28:01,440
flow hijacking primitive like rock

831
00:28:01,440 --> 00:28:02,940
um you know we've got the keys to the

832
00:28:02,940 --> 00:28:04,500
kingdom essentially here right we've got

833
00:28:04,500 --> 00:28:06,600
all the tools and functionality provided

834
00:28:06,600 --> 00:28:09,059
to us by the kernel so we've got a lot

835
00:28:09,059 --> 00:28:11,279
of options one of which is a function

836
00:28:11,279 --> 00:28:14,039
called set memory X which does what it

837
00:28:14,039 --> 00:28:16,200
says in the tin it allows us to set a

838
00:28:16,200 --> 00:28:18,480
specified number of pages in memory as

839
00:28:18,480 --> 00:28:21,059
executable so if we just pointing this

840
00:28:21,059 --> 00:28:23,279
to our stack and we can set our kernel

841
00:28:23,279 --> 00:28:25,440
stack as executable and just like that

842
00:28:25,440 --> 00:28:28,260
we're back in the 90s we can jump to RSP

843
00:28:28,260 --> 00:28:30,600
and we'll be able to execute our Shell

844
00:28:30,600 --> 00:28:34,260
Code so not too much work there

845
00:28:34,260 --> 00:28:36,059
um you know we have the usual issues of

846
00:28:36,059 --> 00:28:37,500
rock in terms of fiddling we're trying

847
00:28:37,500 --> 00:28:39,000
to get stuff in registers we've got to

848
00:28:39,000 --> 00:28:41,760
kind of make the make sure the arguments

849
00:28:41,760 --> 00:28:44,220
are page aligned stuff like that um but

850
00:28:44,220 --> 00:28:47,120
all pretty feasible

851
00:28:47,220 --> 00:28:49,500
however you know like uh Spider-Man's

852
00:28:49,500 --> 00:28:52,080
uncle said with great power comes great

853
00:28:52,080 --> 00:28:54,059
responsibility you know we've got this

854
00:28:54,059 --> 00:28:55,440
awesome keys to the kingdom that's

855
00:28:55,440 --> 00:28:57,779
controlling the kernel but you know if

856
00:28:57,779 --> 00:28:59,340
we do anything wrong it'll be straight

857
00:28:59,340 --> 00:29:00,779
off the path just a little bit we're

858
00:29:00,779 --> 00:29:02,220
probably going to cause a colonel Panic

859
00:29:02,220 --> 00:29:04,919
or some undefined behavior and that's

860
00:29:04,919 --> 00:29:06,900
the end of our attack plan right there

861
00:29:06,900 --> 00:29:09,419
so it's really important that we spend

862
00:29:09,419 --> 00:29:11,159
some time making sure that once we you

863
00:29:11,159 --> 00:29:12,600
know done what we need to do when we

864
00:29:12,600 --> 00:29:14,520
hand control back to the kernel that we

865
00:29:14,520 --> 00:29:16,799
do so you know really well and that we

866
00:29:16,799 --> 00:29:18,659
spend some time making sure our cleanup

867
00:29:18,659 --> 00:29:20,580
is is well done

868
00:29:20,580 --> 00:29:23,039
so when it comes to kind of cleaning up

869
00:29:23,039 --> 00:29:24,720
this stack base buffer overflows and

870
00:29:24,720 --> 00:29:26,700
handing execution back there's a few

871
00:29:26,700 --> 00:29:28,140
things we need to do

872
00:29:28,140 --> 00:29:29,880
first of all we need to find somewhere

873
00:29:29,880 --> 00:29:31,860
along those list of Stack frames that we

874
00:29:31,860 --> 00:29:34,200
haven't completely screwed up and then

875
00:29:34,200 --> 00:29:35,279
think right we're going to hand

876
00:29:35,279 --> 00:29:37,500
execution back here we want to ask

877
00:29:37,500 --> 00:29:39,059
ourselves like what is the you know what

878
00:29:39,059 --> 00:29:41,460
is RSP what does RBP what are the stack

879
00:29:41,460 --> 00:29:43,740
pointers need to look like and we want

880
00:29:43,740 --> 00:29:45,480
to think does it expect any registered

881
00:29:45,480 --> 00:29:46,860
values because we might have skipped a

882
00:29:46,860 --> 00:29:48,659
lot of code here as we Chuck execution

883
00:29:48,659 --> 00:29:50,520
back to the kernel so you want to think

884
00:29:50,520 --> 00:29:52,380
is it expecting you know any registers

885
00:29:52,380 --> 00:29:54,360
to hold certain values and then we also

886
00:29:54,360 --> 00:29:56,100
need to have a think about you know what

887
00:29:56,100 --> 00:29:59,039
has happened in those functions in those

888
00:29:59,039 --> 00:30:00,539
bits of code that we've just skipped

889
00:30:00,539 --> 00:30:02,700
over you know have any locks been taken

890
00:30:02,700 --> 00:30:04,980
you know in which case we might end up

891
00:30:04,980 --> 00:30:06,299
with a deadlock or something like that

892
00:30:06,299 --> 00:30:08,640
and again undefined Behavior or Kernel

893
00:30:08,640 --> 00:30:12,360
Panic not great attack plan is over so

894
00:30:12,360 --> 00:30:13,799
we have to spend some time looking

895
00:30:13,799 --> 00:30:14,880
through the code and understanding

896
00:30:14,880 --> 00:30:16,679
what's going on there and of course in

897
00:30:16,679 --> 00:30:19,200
this case the warlock's taken so more

898
00:30:19,200 --> 00:30:21,120
work for me

899
00:30:21,120 --> 00:30:23,399
um unfortunately you know there's a lot

900
00:30:23,399 --> 00:30:25,679
taken in or two locks taken in the

901
00:30:25,679 --> 00:30:27,779
object which represents our TABC node

902
00:30:27,779 --> 00:30:30,059
okay again we've got the keys to the

903
00:30:30,059 --> 00:30:31,799
kingdom so we can just use functions

904
00:30:31,799 --> 00:30:34,620
provided by tibc to find this node and

905
00:30:34,620 --> 00:30:37,020
then release those locks

906
00:30:37,020 --> 00:30:39,480
the issue here is that tipc is a

907
00:30:39,480 --> 00:30:42,179
loadable module so this is loaded after

908
00:30:42,179 --> 00:30:44,700
boot time which means it's kind of at a

909
00:30:44,700 --> 00:30:46,980
dynamic address so we're already very

910
00:30:46,980 --> 00:30:49,559
generous and hypothetical kslr leak

911
00:30:49,559 --> 00:30:52,020
doesn't help us with this we need to

912
00:30:52,020 --> 00:30:53,880
kind of work out where tibc has been

913
00:30:53,880 --> 00:30:55,799
loaded into memory

914
00:30:55,799 --> 00:30:57,240
um again fortunately because we have

915
00:30:57,240 --> 00:30:59,220
this information on the stack and return

916
00:30:59,220 --> 00:31:01,200
addresses and things within the tibc

917
00:31:01,200 --> 00:31:04,140
networking stack if we find a valid tibc

918
00:31:04,140 --> 00:31:07,679
symbol we can use that to calculate the

919
00:31:07,679 --> 00:31:10,500
Base address of the tipc module and then

920
00:31:10,500 --> 00:31:11,820
we can actually call some of those

921
00:31:11,820 --> 00:31:13,440
functions to find that node and release

922
00:31:13,440 --> 00:31:15,659
that log so we can see here in this like

923
00:31:15,659 --> 00:31:18,539
snippet of cleanup assembly you know

924
00:31:18,539 --> 00:31:19,980
we've pulled one of these symbols off

925
00:31:19,980 --> 00:31:21,600
the stack which we which we know the

926
00:31:21,600 --> 00:31:23,299
value of and what it's pointing to

927
00:31:23,299 --> 00:31:27,419
calculate the Base address of the TABC

928
00:31:27,419 --> 00:31:29,100
module and then we're in a position to

929
00:31:29,100 --> 00:31:31,320
call like you know tipc node finds then

930
00:31:31,320 --> 00:31:33,120
we can release our locks and then we're

931
00:31:33,120 --> 00:31:35,399
back to basics of just correcting RSP

932
00:31:35,399 --> 00:31:37,980
and RBP setting up some values and

933
00:31:37,980 --> 00:31:40,679
jumping back to execution however you

934
00:31:40,679 --> 00:31:42,659
know all of this takes up a lot of space

935
00:31:42,659 --> 00:31:44,520
and now we have to worry about making

936
00:31:44,520 --> 00:31:46,740
sure we don't corrupt the last tipc

937
00:31:46,740 --> 00:31:49,620
symbol on the stack so we're in a

938
00:31:49,620 --> 00:31:50,460
position here where we have to

939
00:31:50,460 --> 00:31:52,380
reevaluate we've now got a lot smaller

940
00:31:52,380 --> 00:31:54,059
space on the stack

941
00:31:54,059 --> 00:31:55,679
and we have to factor that in moving

942
00:31:55,679 --> 00:31:57,059
forward we've already taken up a lot of

943
00:31:57,059 --> 00:31:58,500
space with this cleanup which we have to

944
00:31:58,500 --> 00:32:01,260
do every time so that's another piece of

945
00:32:01,260 --> 00:32:03,059
the puzzle we need to factor in

946
00:32:03,059 --> 00:32:05,640
but on the plus side we now have you

947
00:32:05,640 --> 00:32:07,679
know arbitrary Shell Code execution on

948
00:32:07,679 --> 00:32:10,260
the stack we can throw some more

949
00:32:10,260 --> 00:32:11,580
payloads now that the stack is

950
00:32:11,580 --> 00:32:13,500
executable we don't have to take up so

951
00:32:13,500 --> 00:32:15,600
much space doing a rock what's the plan

952
00:32:15,600 --> 00:32:16,860
now

953
00:32:16,860 --> 00:32:19,260
so like I mentioned we're still in the

954
00:32:19,260 --> 00:32:21,600
process context here so we kind of have

955
00:32:21,600 --> 00:32:24,000
to think about right we need to get uh

956
00:32:24,000 --> 00:32:25,559
sorry we're in the interrupt context now

957
00:32:25,559 --> 00:32:27,659
so we need to get to the process context

958
00:32:27,659 --> 00:32:29,760
so there's actually user space we can

959
00:32:29,760 --> 00:32:31,980
inject our final payload into

960
00:32:31,980 --> 00:32:33,539
now the way we're going to do that as I

961
00:32:33,539 --> 00:32:34,860
mentioned earlier is a technique called

962
00:32:34,860 --> 00:32:36,960
Cisco hooking

963
00:32:36,960 --> 00:32:38,340
um this is commonly used in things like

964
00:32:38,340 --> 00:32:40,140
root kits but it's actually great for us

965
00:32:40,140 --> 00:32:42,600
because what better way to hijack the

966
00:32:42,600 --> 00:32:45,240
process context than the fundamental API

967
00:32:45,240 --> 00:32:48,779
between user space and the kernel so a

968
00:32:48,779 --> 00:32:51,480
quick tldr on how ciscals work in Linux

969
00:32:51,480 --> 00:32:55,440
you know using x8664 as an example a

970
00:32:55,440 --> 00:32:57,179
user Space Program wants the candle to

971
00:32:57,179 --> 00:32:59,880
do something cool so basically it will

972
00:32:59,880 --> 00:33:02,039
put the registers put the arguments for

973
00:33:02,039 --> 00:33:04,080
that Cisco and the right registers it

974
00:33:04,080 --> 00:33:05,640
will put the number of the ciscool it

975
00:33:05,640 --> 00:33:08,159
wants to cool in Rex and then it will

976
00:33:08,159 --> 00:33:10,740
execute the Cisco instruction which will

977
00:33:10,740 --> 00:33:12,840
trigger a software interrupt the user

978
00:33:12,840 --> 00:33:15,240
space context is saved we transition

979
00:33:15,240 --> 00:33:17,220
over to the kernel and we basically end

980
00:33:17,220 --> 00:33:19,500
up somewhere where this diagram is here

981
00:33:19,500 --> 00:33:22,860
in a function called do Cisco 64. this

982
00:33:22,860 --> 00:33:25,080
will then use that Cisco number as an

983
00:33:25,080 --> 00:33:27,779
index into a structural Cisco table

984
00:33:27,779 --> 00:33:29,820
which is just a table of function

985
00:33:29,820 --> 00:33:32,580
pointers to the relevant implementation

986
00:33:32,580 --> 00:33:34,980
for those ciscals

987
00:33:34,980 --> 00:33:37,399
so our plan here is to basically

988
00:33:37,399 --> 00:33:39,779
overwrite one of those Cisco table

989
00:33:39,779 --> 00:33:42,240
entries to point to our own Shell Code

990
00:33:42,240 --> 00:33:45,120
do some stuff and then hand execution

991
00:33:45,120 --> 00:33:47,039
back to the correct Handler as if

992
00:33:47,039 --> 00:33:49,140
nothing had happened sounds pretty good

993
00:33:49,140 --> 00:33:52,320
so we know the what how do we do that

994
00:33:52,320 --> 00:33:55,080
um again fairly straightforward

995
00:33:55,080 --> 00:33:56,519
um now that we've got you know Shell

996
00:33:56,519 --> 00:33:58,440
Code execution we've got a lot of tools

997
00:33:58,440 --> 00:34:01,559
available to us thanks to the kernel

998
00:34:01,559 --> 00:34:03,600
um so some of the first steps we want to

999
00:34:03,600 --> 00:34:06,360
do is obviously make sure we save the

1000
00:34:06,360 --> 00:34:08,460
original value of what we're trying to

1001
00:34:08,460 --> 00:34:10,560
corrupt so our payload our hook can

1002
00:34:10,560 --> 00:34:12,060
actually hand execution back to there

1003
00:34:12,060 --> 00:34:14,159
and we then need to obviously on like

1004
00:34:14,159 --> 00:34:15,899
line 11 we need to actually allocate

1005
00:34:15,899 --> 00:34:18,899
some space for our hook to live in

1006
00:34:18,899 --> 00:34:20,699
um so we can use again tools provided by

1007
00:34:20,699 --> 00:34:22,859
the kernel like kshalock

1008
00:34:22,859 --> 00:34:24,540
um but again remembering to do things

1009
00:34:24,540 --> 00:34:26,040
atomically because we're still in the

1010
00:34:26,040 --> 00:34:27,480
interrupt context so we can't sleep

1011
00:34:27,480 --> 00:34:28,859
there's no scheduling or anything like

1012
00:34:28,859 --> 00:34:30,060
that

1013
00:34:30,060 --> 00:34:32,339
um so we allocate some space and we then

1014
00:34:32,339 --> 00:34:34,080
need to again set this space as

1015
00:34:34,080 --> 00:34:35,879
executable because the Kernel's not

1016
00:34:35,879 --> 00:34:37,918
expecting these hip allocations to be

1017
00:34:37,918 --> 00:34:39,960
running code

1018
00:34:39,960 --> 00:34:40,679
um

1019
00:34:40,679 --> 00:34:42,000
and then we're in a position you know

1020
00:34:42,000 --> 00:34:43,918
once we've set up this space this region

1021
00:34:43,918 --> 00:34:45,359
for our hook we've made it executable

1022
00:34:45,359 --> 00:34:46,859
we're in a position to actually begin

1023
00:34:46,859 --> 00:34:49,679
overriding the Cisco table and again the

1024
00:34:49,679 --> 00:34:51,239
candle is not expecting tweaks to this

1025
00:34:51,239 --> 00:34:53,580
so there's some write protections we

1026
00:34:53,580 --> 00:34:55,379
need to take care of but this functions

1027
00:34:55,379 --> 00:34:57,180
like set memory read write which allow

1028
00:34:57,180 --> 00:34:58,740
us to sort that out

1029
00:34:58,740 --> 00:35:00,720
and then we can also you know disable

1030
00:35:00,720 --> 00:35:02,700
write protection if necessary and then

1031
00:35:02,700 --> 00:35:04,800
just like that we can overwrite

1032
00:35:04,800 --> 00:35:06,780
um that entry with a pointer to our

1033
00:35:06,780 --> 00:35:09,359
freshly our code hook Shell Code and

1034
00:35:09,359 --> 00:35:11,640
just like that we are now have a hook

1035
00:35:11,640 --> 00:35:13,920
for arbitrary code execution in the

1036
00:35:13,920 --> 00:35:16,920
process context really awesome

1037
00:35:16,920 --> 00:35:18,359
um as I mentioned earlier we do have

1038
00:35:18,359 --> 00:35:20,099
some size constraints

1039
00:35:20,099 --> 00:35:22,140
so our initial Hook is actually very

1040
00:35:22,140 --> 00:35:23,700
small because as you can see in that

1041
00:35:23,700 --> 00:35:25,619
previous slide that takes up a lot of

1042
00:35:25,619 --> 00:35:26,880
space and then we also have to worry

1043
00:35:26,880 --> 00:35:28,740
about the cleanup as well so our first

1044
00:35:28,740 --> 00:35:30,420
hook it actually doesn't do anything it

1045
00:35:30,420 --> 00:35:32,579
just cools the original Handler but now

1046
00:35:32,579 --> 00:35:34,800
we have that executable allocated region

1047
00:35:34,800 --> 00:35:37,560
we can send another payload to copy our

1048
00:35:37,560 --> 00:35:41,040
fully fleshed out hook into that so what

1049
00:35:41,040 --> 00:35:43,800
do we want to do here we're almost there

1050
00:35:43,800 --> 00:35:45,359
um there's no need to reinvent the wheel

1051
00:35:45,359 --> 00:35:47,640
again we've got tools provided to us by

1052
00:35:47,640 --> 00:35:49,560
the kernel so the first thing we want to

1053
00:35:49,560 --> 00:35:52,140
do is just check is this process let's

1054
00:35:52,140 --> 00:35:54,060
call this Cisco is it root if it's not

1055
00:35:54,060 --> 00:35:55,800
we don't want like an unprivileged shell

1056
00:35:55,800 --> 00:35:57,420
right so we ignore it we can just carry

1057
00:35:57,420 --> 00:35:59,700
on and hand execution back to the Cisco

1058
00:35:59,700 --> 00:36:01,740
Handler like nothing happened however if

1059
00:36:01,740 --> 00:36:04,859
it is root okay we're interested

1060
00:36:04,859 --> 00:36:07,440
um so one useful thing about these Cisco

1061
00:36:07,440 --> 00:36:10,260
handlers is they're past a pointer to a

1062
00:36:10,260 --> 00:36:12,839
structure called PT Reg

1063
00:36:12,839 --> 00:36:14,339
um which is basically a structure which

1064
00:36:14,339 --> 00:36:16,859
contains that saved user space state so

1065
00:36:16,859 --> 00:36:18,960
it contains all the registered values

1066
00:36:18,960 --> 00:36:21,119
for the user space process which will

1067
00:36:21,119 --> 00:36:23,460
then be restored um when it's when

1068
00:36:23,460 --> 00:36:24,960
execution is handed back to the user

1069
00:36:24,960 --> 00:36:26,160
space

1070
00:36:26,160 --> 00:36:27,720
um so we saved that state because we're

1071
00:36:27,720 --> 00:36:28,920
going to tamper with it in a little bit

1072
00:36:28,920 --> 00:36:30,660
so we save that state in our user space

1073
00:36:30,660 --> 00:36:31,859
payload

1074
00:36:31,859 --> 00:36:34,020
we can then map some memory into user

1075
00:36:34,020 --> 00:36:35,520
space because we're in the kernel why

1076
00:36:35,520 --> 00:36:37,980
not so we can make some read write

1077
00:36:37,980 --> 00:36:40,200
executable mapping into user space we

1078
00:36:40,200 --> 00:36:43,020
can then copy our own user space payload

1079
00:36:43,020 --> 00:36:46,380
into into that region and then using

1080
00:36:46,380 --> 00:36:49,260
that PT reg we can update user spaces

1081
00:36:49,260 --> 00:36:51,599
instruction pointer such that you know

1082
00:36:51,599 --> 00:36:54,060
when we clean up and hand execution back

1083
00:36:54,060 --> 00:36:56,339
to the Cisco Handler when those register

1084
00:36:56,339 --> 00:36:58,140
values are restored it continues

1085
00:36:58,140 --> 00:37:00,480
execution in our payload that we've just

1086
00:37:00,480 --> 00:37:04,260
injected okay we're almost there now we

1087
00:37:04,260 --> 00:37:06,900
have some code execution in a privilege

1088
00:37:06,900 --> 00:37:09,240
process and we're in a position to do

1089
00:37:09,240 --> 00:37:11,640
some to finally get our RCU

1090
00:37:11,640 --> 00:37:13,020
still have to clean up though we don't

1091
00:37:13,020 --> 00:37:15,060
actually have any control over what

1092
00:37:15,060 --> 00:37:16,560
process we've landed up in we just know

1093
00:37:16,560 --> 00:37:18,180
that it's called The Cisco we've hooked

1094
00:37:18,180 --> 00:37:20,040
so you know the first thing is we can

1095
00:37:20,040 --> 00:37:22,020
just Fork if we're in the parent we can

1096
00:37:22,020 --> 00:37:23,760
use that register State we save to

1097
00:37:23,760 --> 00:37:26,160
repair any values that we changed and

1098
00:37:26,160 --> 00:37:27,660
return execution to where it's supposed

1099
00:37:27,660 --> 00:37:30,240
to be and do any relevant cleanup

1100
00:37:30,240 --> 00:37:32,520
however in the child we can then you

1101
00:37:32,520 --> 00:37:33,720
know we're free we're in a privilege

1102
00:37:33,720 --> 00:37:35,760
process we can call like a callback

1103
00:37:35,760 --> 00:37:37,920
payload or something to return to the

1104
00:37:37,920 --> 00:37:39,480
attacker so

1105
00:37:39,480 --> 00:37:44,220
just like that you know we got our rce

1106
00:37:44,220 --> 00:37:46,920
but let's let's go back to reality for a

1107
00:37:46,920 --> 00:37:48,660
second and actually talk about some

1108
00:37:48,660 --> 00:37:50,280
mitigations

1109
00:37:50,280 --> 00:37:51,900
um which brings us on to the next stage

1110
00:37:51,900 --> 00:37:54,740
depression

1111
00:37:55,079 --> 00:37:57,420
um as we saw that Linux kernel defense

1112
00:37:57,420 --> 00:37:59,280
map is like vast and varied there's a

1113
00:37:59,280 --> 00:38:01,260
lot going on right and we have to kind

1114
00:38:01,260 --> 00:38:03,420
of take that all in during this exploit

1115
00:38:03,420 --> 00:38:04,800
development process and there's lots of

1116
00:38:04,800 --> 00:38:06,420
factors which can determine what

1117
00:38:06,420 --> 00:38:08,400
mitigations we're dealing with you know

1118
00:38:08,400 --> 00:38:10,200
whether that's kernel version the

1119
00:38:10,200 --> 00:38:13,200
architecture the kernel config as well

1120
00:38:13,200 --> 00:38:15,000
as the bug type and the techniques we're

1121
00:38:15,000 --> 00:38:17,520
looking to exploit

1122
00:38:17,520 --> 00:38:19,859
and it's really important to during this

1123
00:38:19,859 --> 00:38:22,140
Expo development process to continue to

1124
00:38:22,140 --> 00:38:24,420
factor that in and be aware of of the

1125
00:38:24,420 --> 00:38:26,160
relevant mitigations you know if we take

1126
00:38:26,160 --> 00:38:28,140
into account our game plan right from

1127
00:38:28,140 --> 00:38:29,820
the offset as part of that developing

1128
00:38:29,820 --> 00:38:32,040
our understanding we want to be able to

1129
00:38:32,040 --> 00:38:34,020
kind of draw the dots right so we're

1130
00:38:34,020 --> 00:38:35,579
looking at oh this kernel version okay

1131
00:38:35,579 --> 00:38:38,339
that means these mitigations are present

1132
00:38:38,339 --> 00:38:39,599
um and then just kind of asking

1133
00:38:39,599 --> 00:38:41,400
ourselves you know is this mitigation

1134
00:38:41,400 --> 00:38:43,320
like a soft mitigation which is going to

1135
00:38:43,320 --> 00:38:44,880
introduce additional requirements for

1136
00:38:44,880 --> 00:38:46,680
our attack plan or is this a hard

1137
00:38:46,680 --> 00:38:48,060
mitigation which is going to kill our

1138
00:38:48,060 --> 00:38:50,760
attack Banner entirely and then we also

1139
00:38:50,760 --> 00:38:52,619
need to kind of apply this understanding

1140
00:38:52,619 --> 00:38:54,540
to our specific context right you know

1141
00:38:54,540 --> 00:38:56,520
each each area of the kernel each bug

1142
00:38:56,520 --> 00:38:57,780
type you know can all have its own

1143
00:38:57,780 --> 00:38:59,700
nuances you know and how does the

1144
00:38:59,700 --> 00:39:02,040
efficacy of this mitigation particularly

1145
00:39:02,040 --> 00:39:04,140
affect our circumstances you know how

1146
00:39:04,140 --> 00:39:06,240
does the efficacy vary between like

1147
00:39:06,240 --> 00:39:08,460
local privilege escalation and rce for

1148
00:39:08,460 --> 00:39:10,680
example

1149
00:39:10,680 --> 00:39:14,160
so if we take this extremely simplified

1150
00:39:14,160 --> 00:39:16,980
and very naive diagram of the

1151
00:39:16,980 --> 00:39:18,660
constituent components of a generic

1152
00:39:18,660 --> 00:39:21,420
exploit based on the the stuff we've

1153
00:39:21,420 --> 00:39:23,040
covered today you know we can see we

1154
00:39:23,040 --> 00:39:24,540
start off with a kernel vulnerability

1155
00:39:24,540 --> 00:39:26,579
like our stack-based buffer overflow

1156
00:39:26,579 --> 00:39:28,619
we're looking to leverage that into

1157
00:39:28,619 --> 00:39:31,380
kernel control like our rock or our

1158
00:39:31,380 --> 00:39:33,420
Shell Code execution and then the final

1159
00:39:33,420 --> 00:39:35,280
goal is our actual elevation of

1160
00:39:35,280 --> 00:39:37,320
privileges you know via a shell or a

1161
00:39:37,320 --> 00:39:39,839
reverse shell or something like that

1162
00:39:39,839 --> 00:39:41,520
so we touched on some of the mitigations

1163
00:39:41,520 --> 00:39:43,440
we mentioned today it's going to be

1164
00:39:43,440 --> 00:39:46,140
pretty brief but you know step and snap

1165
00:39:46,140 --> 00:39:48,420
for example supervisor mode execution

1166
00:39:48,420 --> 00:39:51,720
prevention seeks to stop attackers you

1167
00:39:51,720 --> 00:39:53,640
know pivoting from kernel execution and

1168
00:39:53,640 --> 00:39:55,859
jumping straight back to a user space

1169
00:39:55,859 --> 00:39:58,500
payload and supervisor mode access

1170
00:39:58,500 --> 00:40:01,079
prevention seeks to stop kernels uh

1171
00:40:01,079 --> 00:40:02,460
attackers of kind of execution from

1172
00:40:02,460 --> 00:40:05,400
accessing any kind of user space data

1173
00:40:05,400 --> 00:40:07,800
and this notably sits right between that

1174
00:40:07,800 --> 00:40:09,420
kernel control and that privilege

1175
00:40:09,420 --> 00:40:12,180
escalation so after you know the

1176
00:40:12,180 --> 00:40:14,160
attackers potentially have those keys to

1177
00:40:14,160 --> 00:40:16,260
the kingdom and again potentially have a

1178
00:40:16,260 --> 00:40:18,119
vast array of tools provided to them by

1179
00:40:18,119 --> 00:40:20,700
the kernel to kind of work around that

1180
00:40:20,700 --> 00:40:22,020
um and we can see that you know in

1181
00:40:22,020 --> 00:40:23,760
contemporary exploitation techniques

1182
00:40:23,760 --> 00:40:25,619
today you know Smith and snap there's

1183
00:40:25,619 --> 00:40:27,300
plenty of alternatives for attackers to

1184
00:40:27,300 --> 00:40:29,160
use to kind of bypass this due to the

1185
00:40:29,160 --> 00:40:30,720
wider range of options available to

1186
00:40:30,720 --> 00:40:32,880
available to them at this point you know

1187
00:40:32,880 --> 00:40:34,140
whether that's using other kernel

1188
00:40:34,140 --> 00:40:35,820
functions like commit creds for local

1189
00:40:35,820 --> 00:40:37,800
attackers to elevate their processes

1190
00:40:37,800 --> 00:40:40,440
privileges or data corruption techniques

1191
00:40:40,440 --> 00:40:43,079
like overriding mod Pro path again all

1192
00:40:43,079 --> 00:40:44,400
of these options are available to them

1193
00:40:44,400 --> 00:40:46,760
and allow them again depending on the

1194
00:40:46,760 --> 00:40:49,500
Primitives available to the attacker to

1195
00:40:49,500 --> 00:40:51,300
kind of find alternate routes that

1196
00:40:51,300 --> 00:40:52,740
privilege escalation

1197
00:40:52,740 --> 00:40:55,680
conversely if you look at mitigations

1198
00:40:55,680 --> 00:40:58,920
like kslr and stack protector these sit

1199
00:40:58,920 --> 00:41:02,160
prior to the attacker having those keys

1200
00:41:02,160 --> 00:41:03,420
to the kingdom having those elevated

1201
00:41:03,420 --> 00:41:06,000
Privileges and as a result they have

1202
00:41:06,000 --> 00:41:08,339
less tools at their disposal to be able

1203
00:41:08,339 --> 00:41:10,980
to bypass these or work around them

1204
00:41:10,980 --> 00:41:12,660
that said you know I don't think it's

1205
00:41:12,660 --> 00:41:14,880
particularly hot take to say that kslr

1206
00:41:14,880 --> 00:41:16,980
isn't the biggest hurdle for local

1207
00:41:16,980 --> 00:41:18,660
attackers to deal with and we can see

1208
00:41:18,660 --> 00:41:21,180
this historically if we look at exploits

1209
00:41:21,180 --> 00:41:22,800
in the wild you know kslr isn't the

1210
00:41:22,800 --> 00:41:25,740
biggest litigation out there and then we

1211
00:41:25,740 --> 00:41:27,540
have stag protector as well which again

1212
00:41:27,540 --> 00:41:29,760
introduces a higher degree of

1213
00:41:29,760 --> 00:41:31,440
requirement for a league

1214
00:41:31,440 --> 00:41:34,619
but I think notably here unlike Smith

1215
00:41:34,619 --> 00:41:36,240
and smap which is kind of the same

1216
00:41:36,240 --> 00:41:38,040
locally or remotely once you have that

1217
00:41:38,040 --> 00:41:40,260
kernel control you have a lot of options

1218
00:41:40,260 --> 00:41:41,880
available to you

1219
00:41:41,880 --> 00:41:44,160
however you know while kslr may be a bit

1220
00:41:44,160 --> 00:41:46,020
of a meme locally if you kind of switch

1221
00:41:46,020 --> 00:41:48,359
the context from the outside as a remote

1222
00:41:48,359 --> 00:41:50,880
attacker I think the compounding impact

1223
00:41:50,880 --> 00:41:53,460
of both not having kernel control yet

1224
00:41:53,460 --> 00:41:56,220
and the drastically reduced size of the

1225
00:41:56,220 --> 00:41:58,140
remote attack surface means that yes

1226
00:41:58,140 --> 00:42:01,260
suddenly a mitigation which you know may

1227
00:42:01,260 --> 00:42:03,300
not be a side for for local attackers is

1228
00:42:03,300 --> 00:42:05,579
actually a really potent mitigation for

1229
00:42:05,579 --> 00:42:07,079
remote attackers which I think is

1230
00:42:07,079 --> 00:42:09,480
sometimes easy to forget

1231
00:42:09,480 --> 00:42:11,099
uh and then of course we have things

1232
00:42:11,099 --> 00:42:12,960
like fought up by source which is an

1233
00:42:12,960 --> 00:42:15,180
example of just a hard mitigation which

1234
00:42:15,180 --> 00:42:16,859
cuts the you know the attack plan the

1235
00:42:16,859 --> 00:42:18,540
exploit off right at that initial kernel

1236
00:42:18,540 --> 00:42:19,920
vulnerability

1237
00:42:19,920 --> 00:42:21,839
um by you know mitigating it at the root

1238
00:42:21,839 --> 00:42:23,579
cause and I think this is the same you

1239
00:42:23,579 --> 00:42:25,320
know locally or remotely if it's if it's

1240
00:42:25,320 --> 00:42:27,240
patched dispatched

1241
00:42:27,240 --> 00:42:28,380
um and there's plenty more out there

1242
00:42:28,380 --> 00:42:30,180
which I haven't touched on you know any

1243
00:42:30,180 --> 00:42:32,880
more commercial out of tree

1244
00:42:32,880 --> 00:42:34,740
um some things that aren't enabled by

1245
00:42:34,740 --> 00:42:37,140
default and configurations and on and on

1246
00:42:37,140 --> 00:42:38,460
the horizons as well there's plenty more

1247
00:42:38,460 --> 00:42:39,540
out there

1248
00:42:39,540 --> 00:42:41,339
um which would you know introduce a lot

1249
00:42:41,339 --> 00:42:42,960
more issues in some of the techniques

1250
00:42:42,960 --> 00:42:45,119
I've talked about today

1251
00:42:45,119 --> 00:42:47,760
that's enough depression uh let's move

1252
00:42:47,760 --> 00:42:50,820
on to the next stage testing AKA how I

1253
00:42:50,820 --> 00:42:53,339
do mine my workflow and why I think

1254
00:42:53,339 --> 00:42:55,740
emacs is the best IDE

1255
00:42:55,740 --> 00:42:57,720
um besides really having to get my

1256
00:42:57,720 --> 00:42:59,579
mileage out of this seven stages of

1257
00:42:59,579 --> 00:43:01,619
grief analogy I actually find it really

1258
00:43:01,619 --> 00:43:03,119
interesting to hear about people's

1259
00:43:03,119 --> 00:43:05,400
different processes and workflows I

1260
00:43:05,400 --> 00:43:07,079
think particularly in this space as well

1261
00:43:07,079 --> 00:43:09,240
it's like less glamorous and then all

1262
00:43:09,240 --> 00:43:11,280
the cool like shells popped and stuff

1263
00:43:11,280 --> 00:43:13,020
like that but it is the stuff that

1264
00:43:13,020 --> 00:43:15,060
facilitates all the fun stuff so you

1265
00:43:15,060 --> 00:43:16,680
know it's interesting to hear and I

1266
00:43:16,680 --> 00:43:18,480
figured I'd just talked briefly about

1267
00:43:18,480 --> 00:43:19,560
mine

1268
00:43:19,560 --> 00:43:21,960
so the first Cornerstone of the workflow

1269
00:43:21,960 --> 00:43:24,000
obviously the IDE a lot of time is going

1270
00:43:24,000 --> 00:43:26,640
to be spent in that I do use emacs yeah

1271
00:43:26,640 --> 00:43:28,440
I'm that guy

1272
00:43:28,440 --> 00:43:29,819
um but now for real like I've got to

1273
00:43:29,819 --> 00:43:31,380
give a shout out to a talk by Russell

1274
00:43:31,380 --> 00:43:33,000
Curry called kernel hacking like it's

1275
00:43:33,000 --> 00:43:35,400
2020 which introduced me to like a

1276
00:43:35,400 --> 00:43:38,400
pre-config setup emacs called Doom so

1277
00:43:38,400 --> 00:43:40,500
like not super nerdy you know it's not

1278
00:43:40,500 --> 00:43:42,359
much tweaking involved there but for me

1279
00:43:42,359 --> 00:43:44,700
this is like really great for my kind of

1280
00:43:44,700 --> 00:43:47,160
workflow because it allows me to you

1281
00:43:47,160 --> 00:43:48,900
know navigate large and complex code

1282
00:43:48,900 --> 00:43:50,819
bases like the Linux kernel with minimal

1283
00:43:50,819 --> 00:43:52,380
overhead is very quick and snappy

1284
00:43:52,380 --> 00:43:54,180
between jumping between references and

1285
00:43:54,180 --> 00:43:56,700
definitions and like some electron based

1286
00:43:56,700 --> 00:43:58,980
IDs I've used in the past and also it's

1287
00:43:58,980 --> 00:44:00,780
really great to have everything in in

1288
00:44:00,780 --> 00:44:03,119
one environment so like packages you

1289
00:44:03,119 --> 00:44:04,560
know like having quality of life stuff

1290
00:44:04,560 --> 00:44:07,440
like having rip rep under the hood or

1291
00:44:07,440 --> 00:44:09,839
like magic the git workflow and then

1292
00:44:09,839 --> 00:44:12,180
even org mode as I've mentioned the

1293
00:44:12,180 --> 00:44:14,099
emphasis of organizing things is really

1294
00:44:14,099 --> 00:44:15,960
great as well

1295
00:44:15,960 --> 00:44:18,240
um but moving on the other Cornerstone

1296
00:44:18,240 --> 00:44:19,980
of course is virtualization another

1297
00:44:19,980 --> 00:44:21,599
really fundamental part of this kind of

1298
00:44:21,599 --> 00:44:23,400
work is being able to quickly spin up

1299
00:44:23,400 --> 00:44:26,040
test environments and stuff for me I go

1300
00:44:26,040 --> 00:44:27,660
for cremu like I think this is a really

1301
00:44:27,660 --> 00:44:30,599
lightweight and flexible option here and

1302
00:44:30,599 --> 00:44:32,640
what's really great about this and this

1303
00:44:32,640 --> 00:44:34,800
is the same on like virtualbox and

1304
00:44:34,800 --> 00:44:37,859
VMware is the GDB stub which is which

1305
00:44:37,859 --> 00:44:39,480
sort of makes kernel debugging like a

1306
00:44:39,480 --> 00:44:41,700
lot easier so it allows you to connect

1307
00:44:41,700 --> 00:44:44,700
to your guests via GDB for kernel

1308
00:44:44,700 --> 00:44:46,680
debugging either via your host or

1309
00:44:46,680 --> 00:44:48,420
another guest

1310
00:44:48,420 --> 00:44:50,460
um so that kind of power couple of

1311
00:44:50,460 --> 00:44:52,260
cremeu and GDB really gets me through a

1312
00:44:52,260 --> 00:44:54,000
lot of this as well I put in Brackets

1313
00:44:54,000 --> 00:44:56,579
there uh Jeff the GDP enhanced features

1314
00:44:56,579 --> 00:44:58,500
which is a nice quality of life plugin

1315
00:44:58,500 --> 00:45:01,680
for GDB particularly uh based around the

1316
00:45:01,680 --> 00:45:03,540
workflow for exploit developers and

1317
00:45:03,540 --> 00:45:05,700
reverse Engineers so that also adds some

1318
00:45:05,700 --> 00:45:07,800
quality of life features on top of a

1319
00:45:07,800 --> 00:45:10,380
very old debugger

1320
00:45:10,380 --> 00:45:13,079
um which makes life easier there

1321
00:45:13,079 --> 00:45:15,720
but abstracting away a little bit from

1322
00:45:15,720 --> 00:45:17,460
from the tools

1323
00:45:17,460 --> 00:45:19,440
um I guess as I've highlighted during

1324
00:45:19,440 --> 00:45:20,760
this talk

1325
00:45:20,760 --> 00:45:22,680
I really try to have a structured

1326
00:45:22,680 --> 00:45:25,380
approach um to my documentation and try

1327
00:45:25,380 --> 00:45:27,660
to document as much as possible you know

1328
00:45:27,660 --> 00:45:29,700
whether that's mark downloads or org

1329
00:45:29,700 --> 00:45:31,440
mode or whatever works for you like by

1330
00:45:31,440 --> 00:45:33,060
documenting everything and making it

1331
00:45:33,060 --> 00:45:35,520
easy to refer back to it just you know

1332
00:45:35,520 --> 00:45:38,099
helps if you have to re-re-go over a

1333
00:45:38,099 --> 00:45:39,780
project you know after a number of

1334
00:45:39,780 --> 00:45:41,700
months or years like I had to when I

1335
00:45:41,700 --> 00:45:43,500
wrote this talk or if you want to share

1336
00:45:43,500 --> 00:45:45,300
it or things like that like you'll kick

1337
00:45:45,300 --> 00:45:48,300
yourself if you forget to do this

1338
00:45:48,300 --> 00:45:50,099
um and then I think inherently as part

1339
00:45:50,099 --> 00:45:51,300
of like exploit development and

1340
00:45:51,300 --> 00:45:53,400
vulnerability research we really find

1341
00:45:53,400 --> 00:45:55,380
ourselves like writing hacky scripts and

1342
00:45:55,380 --> 00:45:57,359
tools and things to kind of like do

1343
00:45:57,359 --> 00:45:58,859
workarounds or just make our lives

1344
00:45:58,859 --> 00:46:01,140
easier and you know I really advocate

1345
00:46:01,140 --> 00:46:02,520
for trying to generalize these Solutions

1346
00:46:02,520 --> 00:46:04,200
where possible because more often than

1347
00:46:04,200 --> 00:46:05,520
not even you might end up needing them

1348
00:46:05,520 --> 00:46:07,140
down the line if you can spend a little

1349
00:46:07,140 --> 00:46:08,940
bit extra time to to make this

1350
00:46:08,940 --> 00:46:11,400
generalized and reusable like absolutely

1351
00:46:11,400 --> 00:46:12,660
try and do it

1352
00:46:12,660 --> 00:46:14,460
and then also don't be afraid to share

1353
00:46:14,460 --> 00:46:16,440
these hacky scripts and setups you know

1354
00:46:16,440 --> 00:46:19,020
even however Niche or messy you think it

1355
00:46:19,020 --> 00:46:20,460
is like there's probably someone out

1356
00:46:20,460 --> 00:46:22,140
there who who will need it at some point

1357
00:46:22,140 --> 00:46:23,760
like the amount of times I've been

1358
00:46:23,760 --> 00:46:26,160
working on a really Niche project and I

1359
00:46:26,160 --> 00:46:27,839
found like some one-star GitHub which

1360
00:46:27,839 --> 00:46:29,579
has just had just a bit of information I

1361
00:46:29,579 --> 00:46:31,740
need is that has happened more more than

1362
00:46:31,740 --> 00:46:33,660
you might think

1363
00:46:33,660 --> 00:46:36,420
um but yeah I guess that leads us on to

1364
00:46:36,420 --> 00:46:38,880
the the final stage

1365
00:46:38,880 --> 00:46:42,300
um acceptance okay me doing this talk

1366
00:46:42,300 --> 00:46:45,480
hopefully uh during this talk I've kind

1367
00:46:45,480 --> 00:46:47,819
of provided some insights behind into

1368
00:46:47,819 --> 00:46:50,700
the processes behind both like

1369
00:46:50,700 --> 00:46:52,740
discovering a vulnerability and then

1370
00:46:52,740 --> 00:46:54,180
trying to exploit it you know

1371
00:46:54,180 --> 00:46:55,440
highlighting that you know kind of

1372
00:46:55,440 --> 00:46:57,900
exploitation is cool uh but also that is

1373
00:46:57,900 --> 00:47:00,060
not so scary once you break it down like

1374
00:47:00,060 --> 00:47:04,560
it's not some obscure esoteric Mastery

1375
00:47:04,560 --> 00:47:06,119
um but actually this draws from lots of

1376
00:47:06,119 --> 00:47:07,319
skills

1377
00:47:07,319 --> 00:47:09,359
um not least of which are perseverance

1378
00:47:09,359 --> 00:47:11,400
and determination but also like Chris

1379
00:47:11,400 --> 00:47:13,260
mentioned in the keynote earlier lots

1380
00:47:13,260 --> 00:47:15,780
and lots of curiosity just spending some

1381
00:47:15,780 --> 00:47:17,339
time really understanding how things

1382
00:47:17,339 --> 00:47:19,740
work to put you in a position to be able

1383
00:47:19,740 --> 00:47:21,300
to break them

1384
00:47:21,300 --> 00:47:23,400
I think another important thing as well

1385
00:47:23,400 --> 00:47:25,440
is also that like success and winning

1386
00:47:25,440 --> 00:47:27,720
isn't binary in this kind of work you

1387
00:47:27,720 --> 00:47:29,099
know you're not always going to be able

1388
00:47:29,099 --> 00:47:31,859
to pop that shell or find that bug be

1389
00:47:31,859 --> 00:47:33,599
like that's normal that's that's part of

1390
00:47:33,599 --> 00:47:35,160
the job

1391
00:47:35,160 --> 00:47:36,720
um you know as we've mentioned and as

1392
00:47:36,720 --> 00:47:37,980
we've highlighted through this process

1393
00:47:37,980 --> 00:47:40,260
you know during that Journey during that

1394
00:47:40,260 --> 00:47:42,060
that framework you're going to be

1395
00:47:42,060 --> 00:47:43,740
deepening your understanding you're

1396
00:47:43,740 --> 00:47:45,359
going to be improving your workflow

1397
00:47:45,359 --> 00:47:48,119
developing tools discovering techniques

1398
00:47:48,119 --> 00:47:50,099
and Primitives all things which you can

1399
00:47:50,099 --> 00:47:51,599
add to your tool belt and apply to

1400
00:47:51,599 --> 00:47:53,280
projects down the line and secure future

1401
00:47:53,280 --> 00:47:55,079
wins

1402
00:47:55,079 --> 00:47:57,480
um and also the importance of sharing I

1403
00:47:57,480 --> 00:47:58,260
think

1404
00:47:58,260 --> 00:48:00,359
like I didn't study kernel exploitation

1405
00:48:00,359 --> 00:48:02,220
at Uni or anything like that like my

1406
00:48:02,220 --> 00:48:04,319
knowledge is the the culmination of most

1407
00:48:04,319 --> 00:48:06,900
practical application but also consuming

1408
00:48:06,900 --> 00:48:08,579
the wealth of like write-ups and

1409
00:48:08,579 --> 00:48:10,500
Publications that are out there that

1410
00:48:10,500 --> 00:48:11,940
have been shared by the community and is

1411
00:48:11,940 --> 00:48:13,319
this kind of thing that really drives

1412
00:48:13,319 --> 00:48:15,119
the industry forward

1413
00:48:15,119 --> 00:48:16,500
um because obviously malicious attackers

1414
00:48:16,500 --> 00:48:17,819
are out there doing the same thing but

1415
00:48:17,819 --> 00:48:18,900
you know they're just not providing

1416
00:48:18,900 --> 00:48:20,819
write-ups about it

1417
00:48:20,819 --> 00:48:22,020
um

1418
00:48:22,020 --> 00:48:24,839
and then just hopefully it's just been

1419
00:48:24,839 --> 00:48:26,520
cool to cover this all from a remote

1420
00:48:26,520 --> 00:48:27,900
perspective there's a wealth of

1421
00:48:27,900 --> 00:48:29,280
write-ups out there on local privilege

1422
00:48:29,280 --> 00:48:31,560
escalation so hopefully by you know

1423
00:48:31,560 --> 00:48:33,780
covering some familiar stuff and also

1424
00:48:33,780 --> 00:48:36,240
some different stuff has provided an

1425
00:48:36,240 --> 00:48:39,960
interesting take taken all this

1426
00:48:39,960 --> 00:48:42,060
um I've also got some resources here

1427
00:48:42,060 --> 00:48:43,859
like a bunch of the stuff I've mentioned

1428
00:48:43,859 --> 00:48:46,200
are all up here

1429
00:48:46,200 --> 00:48:47,640
um you know if any of you guys see me

1430
00:48:47,640 --> 00:48:49,920
around the conference feel free to come

1431
00:48:49,920 --> 00:48:51,480
at me and talk to me about Linux kernel

1432
00:48:51,480 --> 00:48:53,400
like internals exploitation techniques

1433
00:48:53,400 --> 00:48:54,900
anything like that like I love this

1434
00:48:54,900 --> 00:48:56,099
stuff and I'm always happy to talk about

1435
00:48:56,099 --> 00:48:58,140
it likewise if you'd rather like message

1436
00:48:58,140 --> 00:49:01,200
me online also totally happy with that

1437
00:49:01,200 --> 00:49:03,060
um but yeah I think that's I think

1438
00:49:03,060 --> 00:49:04,800
that's everything uh thanks for

1439
00:49:04,800 --> 00:49:07,160
listening

1440
00:49:08,800 --> 00:49:11,520
[Applause]

1441
00:49:11,520 --> 00:49:13,619
thank you Sam I think we got a couple of

1442
00:49:13,619 --> 00:49:16,140
questions from the audience

1443
00:49:16,140 --> 00:49:17,940
um what will you recommend to use to

1444
00:49:17,940 --> 00:49:23,000
document enumerate thing Primitives

1445
00:49:23,460 --> 00:49:26,040
in terms of documentation like I'm

1446
00:49:26,040 --> 00:49:27,900
pretty basic maybe I'm just a masochist

1447
00:49:27,900 --> 00:49:29,760
but like I just use markdown like

1448
00:49:29,760 --> 00:49:31,680
everything I do as a markdown for

1449
00:49:31,680 --> 00:49:33,660
documentation

1450
00:49:33,660 --> 00:49:34,319
um

1451
00:49:34,319 --> 00:49:36,240
I try and keep it as compartmentalized

1452
00:49:36,240 --> 00:49:37,859
so I have different you know not just

1453
00:49:37,859 --> 00:49:39,480
one massive file like I have different

1454
00:49:39,480 --> 00:49:40,980
files for different areas different

1455
00:49:40,980 --> 00:49:43,500
parts of my my plan and my process

1456
00:49:43,500 --> 00:49:45,900
so yeah just mark down or whatever works

1457
00:49:45,900 --> 00:49:46,859
for you really at the end of the day

1458
00:49:46,859 --> 00:49:47,940
you're the one that's going to be using

1459
00:49:47,940 --> 00:49:50,280
this and reading this so like whatever

1460
00:49:50,280 --> 00:49:52,859
works with your workflow

1461
00:49:52,859 --> 00:49:54,839
um yeah so hopefully that's not too

1462
00:49:54,839 --> 00:49:56,520
disappointing but Mark down I guess it's

1463
00:49:56,520 --> 00:49:58,200
the answer there

1464
00:49:58,200 --> 00:50:00,660
all right thanks um the next one is when

1465
00:50:00,660 --> 00:50:03,000
doing cleanup of the stack could we just

1466
00:50:03,000 --> 00:50:05,280
execute a failure condition instead

1467
00:50:05,280 --> 00:50:07,560
after we return back to our current

1468
00:50:07,560 --> 00:50:09,900
function call we set the registry value

1469
00:50:09,900 --> 00:50:12,540
such that it fails the length checks in

1470
00:50:12,540 --> 00:50:14,579
the function instead of cleaning the

1471
00:50:14,579 --> 00:50:16,619
stack ourselves the kernel will handle

1472
00:50:16,619 --> 00:50:20,040
it as the function failing yeah yeah

1473
00:50:20,040 --> 00:50:21,960
definitely I think part of that process

1474
00:50:21,960 --> 00:50:23,880
and that cleanup is finding the easiest

1475
00:50:23,880 --> 00:50:26,640
way to clean up the stack I think in

1476
00:50:26,640 --> 00:50:27,780
this instance

1477
00:50:27,780 --> 00:50:29,400
you know due to the size of the payload

1478
00:50:29,400 --> 00:50:31,500
we've gone away past our initial

1479
00:50:31,500 --> 00:50:33,420
vulnerable function

1480
00:50:33,420 --> 00:50:35,339
um so if we try to return to the

1481
00:50:35,339 --> 00:50:36,839
vulnerable function it would run through

1482
00:50:36,839 --> 00:50:38,880
that fine we failed the checks but then

1483
00:50:38,880 --> 00:50:41,160
like it goes to restore the previous

1484
00:50:41,160 --> 00:50:42,720
stacked frame and we've also corrupted

1485
00:50:42,720 --> 00:50:44,940
that as well so there's issues there so

1486
00:50:44,940 --> 00:50:46,619
basically the the process of this is

1487
00:50:46,619 --> 00:50:48,780
finding the nearest spot that doesn't

1488
00:50:48,780 --> 00:50:50,460
have a corrupted you know stack room

1489
00:50:50,460 --> 00:50:52,260
that it can recover from well but that's

1490
00:50:52,260 --> 00:50:54,059
that is the general approach is we want

1491
00:50:54,059 --> 00:50:55,440
to find the nearest spot even if it's a

1492
00:50:55,440 --> 00:50:57,660
failed condition to to basically restore

1493
00:50:57,660 --> 00:50:59,579
execution to

1494
00:50:59,579 --> 00:51:00,900
um but yeah in this case that wasn't

1495
00:51:00,900 --> 00:51:02,940
possible because we'd clobbered all the

1496
00:51:02,940 --> 00:51:04,319
like two or three stack frames after

1497
00:51:04,319 --> 00:51:06,119
that

1498
00:51:06,119 --> 00:51:07,920
all right thanks

1499
00:51:07,920 --> 00:51:09,300
um and the final question any

1500
00:51:09,300 --> 00:51:11,520
recommendations on places to get started

1501
00:51:11,520 --> 00:51:13,740
with kernel exploitation

1502
00:51:13,740 --> 00:51:16,079
um practical Labs or CTF challenges

1503
00:51:16,079 --> 00:51:17,700
absolutely

1504
00:51:17,700 --> 00:51:18,599
um

1505
00:51:18,599 --> 00:51:20,880
I think practical application is like

1506
00:51:20,880 --> 00:51:24,420
100 the way to go with these things like

1507
00:51:24,420 --> 00:51:26,099
it can be really daunting at first

1508
00:51:26,099 --> 00:51:27,420
because like I mentioned the kernel

1509
00:51:27,420 --> 00:51:29,819
exploitation and stuff is like so big

1510
00:51:29,819 --> 00:51:31,740
and there's so much going on and you're

1511
00:51:31,740 --> 00:51:32,940
never going to understand it all right

1512
00:51:32,940 --> 00:51:35,040
like I I I'm nowhere near understanding

1513
00:51:35,040 --> 00:51:37,140
most of the stuff in the kernel but it's

1514
00:51:37,140 --> 00:51:39,119
just that process of again finding like

1515
00:51:39,119 --> 00:51:41,040
a a bite-sized Challenge and just

1516
00:51:41,040 --> 00:51:42,839
chipping away that and the more you do

1517
00:51:42,839 --> 00:51:45,599
these kind of ctfs and these challenges

1518
00:51:45,599 --> 00:51:47,579
um the more knowledge you're kind of

1519
00:51:47,579 --> 00:51:48,960
adding to your tool belt some of you'll

1520
00:51:48,960 --> 00:51:51,000
forget that some you'll retain and it's

1521
00:51:51,000 --> 00:51:52,920
all about kind of like reapplying that

1522
00:51:52,920 --> 00:51:55,339
all down the line so I think yeah

1523
00:51:55,339 --> 00:51:57,480
ctfs are great I mean there's there's

1524
00:51:57,480 --> 00:51:59,400
loads around

1525
00:51:59,400 --> 00:52:03,359
um also like write-ups as well again I

1526
00:52:03,359 --> 00:52:05,099
don't know the best way to find these

1527
00:52:05,099 --> 00:52:07,800
things I just use Twitter uh just to see

1528
00:52:07,800 --> 00:52:09,359
all my stuff and I think like a lot of

1529
00:52:09,359 --> 00:52:10,680
people do that as well so there's a bit

1530
00:52:10,680 --> 00:52:12,839
of curation involved there in terms of

1531
00:52:12,839 --> 00:52:15,839
uh following the right people and stuff

1532
00:52:15,839 --> 00:52:16,500
um

1533
00:52:16,500 --> 00:52:18,359
but I think yeah both getting some

1534
00:52:18,359 --> 00:52:20,400
Hands-On with exploitation via ctfs and

1535
00:52:20,400 --> 00:52:22,200
stuff getting some Hands-On with just

1536
00:52:22,200 --> 00:52:24,300
understanding kernel stuff like kernel

1537
00:52:24,300 --> 00:52:28,260
internals and then also uh just reading

1538
00:52:28,260 --> 00:52:30,180
some write-ups and learning that way so

1539
00:52:30,180 --> 00:52:31,920
it's just again picking what works for

1540
00:52:31,920 --> 00:52:33,780
you what's best based on your strengths

1541
00:52:33,780 --> 00:52:35,760
or weaknesses but just diving in I think

1542
00:52:35,760 --> 00:52:37,920
is the best way and then that Curiosity

1543
00:52:37,920 --> 00:52:40,800
of if you're ever like trying to bash

1544
00:52:40,800 --> 00:52:42,300
your head against something don't don't

1545
00:52:42,300 --> 00:52:43,740
just keep going at it just take a pause

1546
00:52:43,740 --> 00:52:46,200
what don't I understand go off and like

1547
00:52:46,200 --> 00:52:48,180
understand it come back and go that way

1548
00:52:48,180 --> 00:52:50,940
like it can be frustrating if you just

1549
00:52:50,940 --> 00:52:53,160
try and do one of these ctfs and you

1550
00:52:53,160 --> 00:52:54,420
just want to get the flag or get the

1551
00:52:54,420 --> 00:52:56,579
shell like it's going to be difficult so

1552
00:52:56,579 --> 00:52:58,740
just take your time enjoy it and enjoy

1553
00:52:58,740 --> 00:53:02,880
the process I'd say awesome thanks

1554
00:53:02,880 --> 00:53:04,559
um if there's no more questions let's

1555
00:53:04,559 --> 00:53:07,940
give salmon a round of applause

1556
00:53:11,160 --> 00:53:13,200
so we're going to take a break for lunch

1557
00:53:13,200 --> 00:53:14,819
um lunch is served outside

1558
00:53:14,819 --> 00:53:17,460
um we'll reconvene at 2PM in this in the

1559
00:53:17,460 --> 00:53:18,480
same room

1560
00:53:18,480 --> 00:53:20,220
um there's also lots of exhibitions and

1561
00:53:20,220 --> 00:53:22,140
CTF challenges out there there's a drone

1562
00:53:22,140 --> 00:53:24,240
hacking Village at the corner

1563
00:53:24,240 --> 00:53:25,800
um you've got crypto hacking challenges

1564
00:53:25,800 --> 00:53:28,260
you've got lock picking Villages and so

1565
00:53:28,260 --> 00:53:29,760
on

1566
00:53:29,760 --> 00:53:30,960
thank you

1567
00:53:30,960 --> 00:53:33,960
foreign

