1
00:00:16,219 --> 00:00:24,799
so first of all let's welcome all of you

2
00:00:20,480 --> 00:00:26,930
in this talk called recreating an iOS do

3
00:00:24,800 --> 00:00:30,290
with a jailbreak out of Apple security

4
00:00:26,930 --> 00:00:32,659
Petrus so first of all I'm happy to be

5
00:00:30,290 --> 00:00:36,800
here I believe the third or fourth time

6
00:00:32,659 --> 00:00:38,919
at this conference and this time I want

7
00:00:36,800 --> 00:00:42,849
you to take you through the journey of

8
00:00:38,920 --> 00:00:47,090
looking at Apple security fixes and

9
00:00:42,850 --> 00:00:51,050
seeing what was actually fixed and how

10
00:00:47,090 --> 00:00:54,290
this can then be exploited so as I said

11
00:00:51,050 --> 00:00:57,919
I can skip my introduction basically I'm

12
00:00:54,290 --> 00:01:01,790
doing iOS since 2010 so it's really a

13
00:00:57,920 --> 00:01:05,180
long time like nearly 10 years soon so

14
00:01:01,790 --> 00:01:09,110
the motivation of this the motivation of

15
00:01:05,180 --> 00:01:10,940
this talk was that in February or

16
00:01:09,110 --> 00:01:14,870
beginning of February Apple released the

17
00:01:10,940 --> 00:01:18,890
security update for iOS this was twelve

18
00:01:14,870 --> 00:01:22,490
one four and lenses were suddenly a

19
00:01:18,890 --> 00:01:25,100
tweet from Google saying oh by the way

20
00:01:22,490 --> 00:01:27,410
this fixed two security vulnerabilities

21
00:01:25,100 --> 00:01:28,970
ever exploited in the wild and after

22
00:01:27,410 --> 00:01:31,700
that there was complete radio silence

23
00:01:28,970 --> 00:01:34,940
from Apple or from Google about this

24
00:01:31,700 --> 00:01:37,910
there was nothing now we have nearly

25
00:01:34,940 --> 00:01:39,410
eight months since then yeah nearly

26
00:01:37,910 --> 00:01:42,530
eight months and we heard absolutely

27
00:01:39,410 --> 00:01:44,810
nothing and so third parties like myself

28
00:01:42,530 --> 00:01:46,310
we got into the idea let's look what

29
00:01:44,810 --> 00:01:49,070
actually was patched and tried to

30
00:01:46,310 --> 00:01:50,780
reverse that because there was no real

31
00:01:49,070 --> 00:01:55,250
information from the official sources

32
00:01:50,780 --> 00:01:57,620
and that was the idea of this talk just

33
00:01:55,250 --> 00:02:01,400
tell the world what really or what

34
00:01:57,620 --> 00:02:03,590
seemed to have happened of course Google

35
00:02:01,400 --> 00:02:07,209
has their own ways and for whatever

36
00:02:03,590 --> 00:02:10,910
reason I am B I decided yesterday to

37
00:02:07,209 --> 00:02:14,120
release like five or six blog entries in

38
00:02:10,910 --> 00:02:19,480
a in a row in the official project zero

39
00:02:14,120 --> 00:02:22,099
block where they describe five iOS

40
00:02:19,480 --> 00:02:25,579
exploitation change they found in the

41
00:02:22,099 --> 00:02:28,049
wild including this one that is

42
00:02:25,580 --> 00:02:30,450
described here the the zero day one

43
00:02:28,050 --> 00:02:33,630
so this basically means whatever we have

44
00:02:30,450 --> 00:02:36,179
reversed here we could have just skipped

45
00:02:33,630 --> 00:02:39,660
that and just waited for for Google to

46
00:02:36,180 --> 00:02:41,970
release it but of course in the future

47
00:02:39,660 --> 00:02:45,690
you will see that third parties always

48
00:02:41,970 --> 00:02:47,820
will report bugs to Apple and very often

49
00:02:45,690 --> 00:02:50,970
they don't actually do any write-up

50
00:02:47,820 --> 00:02:54,320
about these bugs at all so we actually

51
00:02:50,970 --> 00:02:56,910
don't know how often it happens that

52
00:02:54,320 --> 00:02:59,760
third parties find something the wild

53
00:02:56,910 --> 00:03:02,280
report it to Apple they fix it and then

54
00:02:59,760 --> 00:03:05,190
just both keep silent about it we don't

55
00:03:02,280 --> 00:03:07,680
know because Apple will not tell us and

56
00:03:05,190 --> 00:03:11,720
as I said most of the time there are no

57
00:03:07,680 --> 00:03:14,310
write ups except maybe from project zero

58
00:03:11,720 --> 00:03:17,520
so the agenda of this talk is basically

59
00:03:14,310 --> 00:03:21,740
short introduction then I will go into

60
00:03:17,520 --> 00:03:25,650
how I dipped the the kernel part of this

61
00:03:21,740 --> 00:03:28,670
the next part will then be how third

62
00:03:25,650 --> 00:03:31,500
parties have dipped the userland part

63
00:03:28,670 --> 00:03:34,530
after we found and located the

64
00:03:31,500 --> 00:03:37,050
vulnerabilities I will then go over how

65
00:03:34,530 --> 00:03:38,820
we exploited the the kernel part or

66
00:03:37,050 --> 00:03:41,970
different ways you could do that and

67
00:03:38,820 --> 00:03:44,430
then how the other third parties exploit

68
00:03:41,970 --> 00:03:49,440
the userland part and in the end of

69
00:03:44,430 --> 00:03:52,709
course the short conclusion so and the

70
00:03:49,440 --> 00:03:55,320
introduction is mostly already given to

71
00:03:52,709 --> 00:03:57,930
you basically there was this incident

72
00:03:55,320 --> 00:04:00,660
that there was this very serious

73
00:03:57,930 --> 00:04:03,209
FaceTime vulnerability where you could

74
00:04:00,660 --> 00:04:03,900
call someone and they didn't need to

75
00:04:03,209 --> 00:04:06,180
answer

76
00:04:03,900 --> 00:04:10,230
you could also answer for them so you

77
00:04:06,180 --> 00:04:14,280
could spy on people and this was found

78
00:04:10,230 --> 00:04:16,829
by accident and got a lot of media

79
00:04:14,280 --> 00:04:20,880
attention and then on the 7th of

80
00:04:16,829 --> 00:04:23,640
February 2019 Apple released this 12-1

81
00:04:20,880 --> 00:04:25,909
for security update that officially

82
00:04:23,640 --> 00:04:29,039
patched this vulnerability

83
00:04:25,910 --> 00:04:31,020
however in the security update there

84
00:04:29,040 --> 00:04:33,800
were actually four win abilities fixed

85
00:04:31,020 --> 00:04:38,280
to we're about

86
00:04:33,800 --> 00:04:39,460
FaceTime and to where described like

87
00:04:38,280 --> 00:04:42,429
this here

88
00:04:39,460 --> 00:04:45,280
and the the issue I have with Apple

89
00:04:42,430 --> 00:04:47,949
description of these box is usually that

90
00:04:45,280 --> 00:04:51,940
they have a very rough idea where it's

91
00:04:47,949 --> 00:04:56,110
located and then the impact is basically

92
00:04:51,940 --> 00:04:57,699
always gain elevated privileges and they

93
00:04:56,110 --> 00:05:01,210
say nothing else and that is a memory

94
00:04:57,699 --> 00:05:03,280
corruption we can see here that there

95
00:05:01,210 --> 00:05:06,008
was a bunch of people who who apparently

96
00:05:03,280 --> 00:05:08,318
reported this so I don't know for

97
00:05:06,009 --> 00:05:11,349
example if this anonymous researcher is

98
00:05:08,319 --> 00:05:14,229
part of Google or why he's like listed

99
00:05:11,349 --> 00:05:17,710
separately here maybe several entities

100
00:05:14,229 --> 00:05:19,120
have found all the same zero-day all the

101
00:05:17,710 --> 00:05:20,739
other people are basically from google

102
00:05:19,120 --> 00:05:25,120
but the anonymous researcher we don't

103
00:05:20,740 --> 00:05:27,099
know okay so the next thing that

104
00:05:25,120 --> 00:05:29,680
happened I think it was a day later

105
00:05:27,099 --> 00:05:30,310
there was suddenly the tweet from Ben

106
00:05:29,680 --> 00:05:32,949
Hawkes

107
00:05:30,310 --> 00:05:37,599
where he basically said oh yeah these

108
00:05:32,949 --> 00:05:40,150
two bags were found in the wild of

109
00:05:37,599 --> 00:05:41,740
course Apple has never told anybody

110
00:05:40,150 --> 00:05:44,500
about this so this was the only

111
00:05:41,740 --> 00:05:47,669
information for a very long time that we

112
00:05:44,500 --> 00:05:51,509
had that was something was going on

113
00:05:47,669 --> 00:05:55,210
right at this time was the offensive con

114
00:05:51,509 --> 00:05:57,610
conference in Germany and this was a

115
00:05:55,210 --> 00:05:59,229
very big topic everybody was talking

116
00:05:57,610 --> 00:06:01,930
about this because there are so many

117
00:05:59,229 --> 00:06:04,150
unanswered asked questions like how did

118
00:06:01,930 --> 00:06:07,150
Google find that who was actually

119
00:06:04,150 --> 00:06:08,789
attacked was it Google themselves was

120
00:06:07,150 --> 00:06:11,258
one of their customers

121
00:06:08,789 --> 00:06:14,440
there was no description what these

122
00:06:11,259 --> 00:06:16,599
vulnerabilities actually we're the only

123
00:06:14,440 --> 00:06:18,310
thing I was quite clear very fast from

124
00:06:16,599 --> 00:06:20,710
the description is that it was one

125
00:06:18,310 --> 00:06:23,979
Colonel Bach that is local and one

126
00:06:20,710 --> 00:06:26,739
sandbox escaped that is also low current

127
00:06:23,979 --> 00:06:29,800
so the question is was this combined

128
00:06:26,740 --> 00:06:32,110
with some other remote capability or was

129
00:06:29,800 --> 00:06:34,270
it just the local thing so maybe someone

130
00:06:32,110 --> 00:06:38,169
uploaded an app to Google or somewhere

131
00:06:34,270 --> 00:06:40,650
else and they found it inside there also

132
00:06:38,169 --> 00:06:43,210
we had no idea why they kept silent

133
00:06:40,650 --> 00:06:45,638
because normally Google was always

134
00:06:43,210 --> 00:06:47,888
writing about whatever they did quite

135
00:06:45,639 --> 00:06:49,000
fast and we also don't know if we ever

136
00:06:47,889 --> 00:06:52,150
get samples

137
00:06:49,000 --> 00:06:54,100
the only other iOS 0

138
00:06:52,150 --> 00:06:56,710
they would find in the vial before was

139
00:06:54,100 --> 00:06:58,750
Pegasus from a few years ago I believe

140
00:06:56,710 --> 00:07:01,440
until today still they have never been

141
00:06:58,750 --> 00:07:04,960
released samples by those that have them

142
00:07:01,440 --> 00:07:07,740
yes but as I told you the situation has

143
00:07:04,960 --> 00:07:09,789
changed like yesterday evening or so

144
00:07:07,740 --> 00:07:14,920
basically I learned about this like two

145
00:07:09,790 --> 00:07:18,640
hours ago Google released this what

146
00:07:14,920 --> 00:07:21,700
feels like 1000 pages of information and

147
00:07:18,640 --> 00:07:23,770
now I'm not even sure what of these

148
00:07:21,700 --> 00:07:27,190
questions is answered in this document

149
00:07:23,770 --> 00:07:29,109
because I haven't read it yet so the

150
00:07:27,190 --> 00:07:31,060
only other info that we had earlier

151
00:07:29,110 --> 00:07:33,670
which was from another tweet from

152
00:07:31,060 --> 00:07:35,200
another Google person he basically said

153
00:07:33,670 --> 00:07:37,080
oh yeah we're just too busy to write it

154
00:07:35,200 --> 00:07:41,170
up we're not trying to hide anything

155
00:07:37,080 --> 00:07:45,810
also this was used remotely with an

156
00:07:41,170 --> 00:07:48,330
already fixed browser bug in combination

157
00:07:45,810 --> 00:07:50,470
yeah so here are the references

158
00:07:48,330 --> 00:07:53,320
unfortunately the last tweet I couldn't

159
00:07:50,470 --> 00:07:54,820
find it when I made the slides so for

160
00:07:53,320 --> 00:07:56,890
the last suite I don't have a reference

161
00:07:54,820 --> 00:07:58,510
so for every section I will provide a

162
00:07:56,890 --> 00:08:01,840
slide of references so you can always

163
00:07:58,510 --> 00:08:05,440
look at the actual thing how it happened

164
00:08:01,840 --> 00:08:07,210
okay this was the introduction and now

165
00:08:05,440 --> 00:08:10,120
let's get into the real thing so let's

166
00:08:07,210 --> 00:08:12,070
start with the kernel part so when we

167
00:08:10,120 --> 00:08:14,440
look at the description from Apple as

168
00:08:12,070 --> 00:08:16,990
usual as I told you there's very little

169
00:08:14,440 --> 00:08:19,570
information the only thing that we learn

170
00:08:16,990 --> 00:08:22,750
is it's a memory corruption and Apple

171
00:08:19,570 --> 00:08:24,969
lists the component as I knew kids so I

172
00:08:22,750 --> 00:08:27,520
okay it is usually part of the iOS

173
00:08:24,970 --> 00:08:31,330
kernel is one of the subsystems that

174
00:08:27,520 --> 00:08:35,799
basically is there to support device

175
00:08:31,330 --> 00:08:37,840
drivers so you wouldn't assume in this

176
00:08:35,799 --> 00:08:41,709
case that there's some vulnerability in

177
00:08:37,840 --> 00:08:43,360
the main kernel however further analysis

178
00:08:41,710 --> 00:08:47,980
basically revealed that that's not the

179
00:08:43,360 --> 00:08:52,570
case because I Apple used a very strange

180
00:08:47,980 --> 00:08:54,220
terminology too because as iokit so how

181
00:08:52,570 --> 00:08:57,100
do you start with this whole thing

182
00:08:54,220 --> 00:09:00,850
basically you need to grab a copy of

183
00:08:57,100 --> 00:09:03,330
these patches so you download these IPSW

184
00:09:00,850 --> 00:09:05,100
files from the Apple servers

185
00:09:03,330 --> 00:09:08,190
the links for that you can find on

186
00:09:05,100 --> 00:09:11,610
things like the iPhone wiki those are

187
00:09:08,190 --> 00:09:13,710
just zip files you unzip them then you

188
00:09:11,610 --> 00:09:15,750
use one of the public tools to extract

189
00:09:13,710 --> 00:09:18,750
the the kernels from the from the

190
00:09:15,750 --> 00:09:21,860
wrapper files for example the tool from

191
00:09:18,750 --> 00:09:24,360
syrup which you can find on github and

192
00:09:21,860 --> 00:09:27,600
once you've done that you can then load

193
00:09:24,360 --> 00:09:30,060
these kernels into basically any tool

194
00:09:27,600 --> 00:09:32,700
that deals with my own files however

195
00:09:30,060 --> 00:09:35,010
either is the best because they support

196
00:09:32,700 --> 00:09:38,610
all the newest changes in the kernel

197
00:09:35,010 --> 00:09:41,930
layouts and so on also Ida has this new

198
00:09:38,610 --> 00:09:47,100
feature called lumina which is basically

199
00:09:41,930 --> 00:09:49,109
shared server across the world where you

200
00:09:47,100 --> 00:09:53,880
have functions get uploaded with their

201
00:09:49,110 --> 00:09:57,140
symbol and so lumina can detect already

202
00:09:53,880 --> 00:09:59,820
known functions in your binaries and

203
00:09:57,140 --> 00:10:03,600
this means if anybody has ever uploaded

204
00:09:59,820 --> 00:10:07,020
an iOS kernel before lumina will give

205
00:10:03,600 --> 00:10:09,540
you this information what you need to

206
00:10:07,020 --> 00:10:13,610
know here is that Apple made a big

207
00:10:09,540 --> 00:10:16,260
mistake when they released iOS 12 beta

208
00:10:13,610 --> 00:10:19,440
they released one of the kernels that

209
00:10:16,260 --> 00:10:21,270
had 90,000 symbols in them so they

210
00:10:19,440 --> 00:10:23,730
forgot to strip it before releasing it

211
00:10:21,270 --> 00:10:26,100
to the public and someone immediately

212
00:10:23,730 --> 00:10:28,920
took this and uploaded alumina so that's

213
00:10:26,100 --> 00:10:33,180
why either is now so good in recognizing

214
00:10:28,920 --> 00:10:34,500
functions in iOS kernels so the next

215
00:10:33,180 --> 00:10:37,020
thing of course you have to do whenever

216
00:10:34,500 --> 00:10:40,500
you do binary pitch dipping you have to

217
00:10:37,020 --> 00:10:41,930
clean up the disassemblies so once you

218
00:10:40,500 --> 00:10:45,990
have done all of that you can then start

219
00:10:41,930 --> 00:10:47,760
using a tool like dear forum seems to be

220
00:10:45,990 --> 00:10:50,820
at the moment really the only thing that

221
00:10:47,760 --> 00:10:52,740
is usable it's open source in the

222
00:10:50,820 --> 00:10:54,450
resources you can find a link to it so

223
00:10:52,740 --> 00:10:57,900
the offeror is nowadays used for

224
00:10:54,450 --> 00:11:00,660
everything diffing a whole kernel can

225
00:10:57,900 --> 00:11:02,910
take a night so i just started in the

226
00:11:00,660 --> 00:11:07,530
evening went to bed and the next morning

227
00:11:02,910 --> 00:11:09,240
I looked at the result and the problem

228
00:11:07,530 --> 00:11:12,630
here is we don't know where the actual

229
00:11:09,240 --> 00:11:15,180
location is so we first try just the

230
00:11:12,630 --> 00:11:16,490
main kernel but we didn't really find

231
00:11:15,180 --> 00:11:21,060
anything and then we to

232
00:11:16,490 --> 00:11:23,280
everything yeah

233
00:11:21,060 --> 00:11:26,969
the result is basically that we get a

234
00:11:23,280 --> 00:11:28,829
lot of functions that are not real

235
00:11:26,970 --> 00:11:31,530
functions that match with something else

236
00:11:28,830 --> 00:11:33,480
so we get a lot of false matches and the

237
00:11:31,530 --> 00:11:36,329
differing result is also very incomplete

238
00:11:33,480 --> 00:11:40,140
because it's very hard to clean up a

239
00:11:36,330 --> 00:11:45,840
huge kernel with many many many drivers

240
00:11:40,140 --> 00:11:49,830
in it so but we were able to find one

241
00:11:45,840 --> 00:11:51,720
function that looked like this here so

242
00:11:49,830 --> 00:11:54,600
this is the new version of the function

243
00:11:51,720 --> 00:11:56,940
after D compilation and we could see

244
00:11:54,600 --> 00:11:59,940
that in the new version there was

245
00:11:56,940 --> 00:12:02,340
suddenly a new sized check inserted here

246
00:11:59,940 --> 00:12:08,160
with an error message that there's

247
00:12:02,340 --> 00:12:10,230
something wrong with the size so we can

248
00:12:08,160 --> 00:12:13,439
also see here let me see yeah we can

249
00:12:10,230 --> 00:12:16,020
also see here basically that this

250
00:12:13,440 --> 00:12:19,230
happens in a in an object called trough

251
00:12:16,020 --> 00:12:22,319
info i/o kit user client and there is

252
00:12:19,230 --> 00:12:24,450
the term i/o kit in it so we matched our

253
00:12:22,320 --> 00:12:26,790
description from apple where the

254
00:12:24,450 --> 00:12:30,090
vulnerability is and yes this whole

255
00:12:26,790 --> 00:12:32,400
thing comes from a driver called prof

256
00:12:30,090 --> 00:12:37,110
info i/o kit so it's actually not in the

257
00:12:32,400 --> 00:12:40,500
main kernel it's just in the driver so

258
00:12:37,110 --> 00:12:42,270
when you analyze this driver you will

259
00:12:40,500 --> 00:12:45,240
find that when you google for it and so

260
00:12:42,270 --> 00:12:47,340
on you will get no hits nowadays you

261
00:12:45,240 --> 00:12:50,970
find some write-ups but before that you

262
00:12:47,340 --> 00:12:52,950
find no hits or no usable hits you find

263
00:12:50,970 --> 00:12:56,190
sometimes a list of drivers but no

264
00:12:52,950 --> 00:12:57,780
description what this actually does so

265
00:12:56,190 --> 00:13:00,120
we had to dig a little bit deeper and

266
00:12:57,780 --> 00:13:03,420
find out what this actually is or how it

267
00:13:00,120 --> 00:13:06,480
can be used so what we saw is that it's

268
00:13:03,420 --> 00:13:08,670
actually not allowed from most sandboxes

269
00:13:06,480 --> 00:13:11,430
to access this there's only three

270
00:13:08,670 --> 00:13:14,959
sandbox profiles that actually make use

271
00:13:11,430 --> 00:13:17,790
of this driver like find my device

272
00:13:14,960 --> 00:13:21,960
t-mobile activation D and an identity

273
00:13:17,790 --> 00:13:23,849
service D so in theory this means you

274
00:13:21,960 --> 00:13:30,209
would need an availability in there to

275
00:13:23,850 --> 00:13:32,279
ever trigger this or a vulnerability

276
00:13:30,209 --> 00:13:34,910
outside of the sandbox and this is that

277
00:13:32,279 --> 00:13:38,040
we will learn later what really happens

278
00:13:34,910 --> 00:13:41,429
so the next thing when you analyze is

279
00:13:38,040 --> 00:13:45,589
that you will realize that this function

280
00:13:41,429 --> 00:13:49,829
that we found that is vulnerable it has

281
00:13:45,589 --> 00:13:53,220
is part of this object here that is

282
00:13:49,829 --> 00:13:55,679
called user client so user clients in IO

283
00:13:53,220 --> 00:13:58,170
kit are always the part that interfaces

284
00:13:55,679 --> 00:14:01,019
with user land so this is what userland

285
00:13:58,170 --> 00:14:02,670
code actually talks to so every driver

286
00:14:01,019 --> 00:14:05,999
that wants to talk with user land has to

287
00:14:02,670 --> 00:14:08,579
usually provide such an object and one

288
00:14:05,999 --> 00:14:11,009
of the ways to talk to userland is via

289
00:14:08,579 --> 00:14:12,809
the so-called external methods which is

290
00:14:11,009 --> 00:14:15,660
basically a list of methods that you

291
00:14:12,809 --> 00:14:18,149
make available to user land and in total

292
00:14:15,660 --> 00:14:20,790
there are six such messages as my

293
00:14:18,149 --> 00:14:23,639
methods in this driver and we can see

294
00:14:20,790 --> 00:14:26,040
the names here what we can also see is

295
00:14:23,639 --> 00:14:28,679
that in the binary actually these three

296
00:14:26,040 --> 00:14:31,199
have for whatever reason an obfuscated

297
00:14:28,679 --> 00:14:32,759
name we only know their real name

298
00:14:31,199 --> 00:14:35,660
because they are error message and there

299
00:14:32,759 --> 00:14:41,790
wherever the plain text name is inside

300
00:14:35,660 --> 00:14:43,290
and the next thing is this year was the

301
00:14:41,790 --> 00:14:46,829
vulnerability that the function that we

302
00:14:43,290 --> 00:14:48,799
found with the size check so now knowing

303
00:14:46,829 --> 00:14:52,888
that these are all external methods

304
00:14:48,799 --> 00:14:55,679
naturally I looked into the other two

305
00:14:52,889 --> 00:14:58,439
and I was very surprised to then see

306
00:14:55,679 --> 00:15:00,809
that the other that three of the others

307
00:14:58,439 --> 00:15:03,179
two of the others in total three

308
00:15:00,809 --> 00:15:05,639
function all had new sites checks in

309
00:15:03,179 --> 00:15:09,389
there so here's another length check in

310
00:15:05,639 --> 00:15:11,160
one of the other methods and I will

311
00:15:09,389 --> 00:15:13,860
already mention to you here this year's

312
00:15:11,160 --> 00:15:17,969
the very interesting thing so basically

313
00:15:13,860 --> 00:15:21,240
we can see here that a mem move is

314
00:15:17,970 --> 00:15:24,569
executed like a mem copy and the length

315
00:15:21,240 --> 00:15:27,269
of the memo P is coming from this year

316
00:15:24,569 --> 00:15:30,209
which I can tell you is basically the

317
00:15:27,269 --> 00:15:32,850
incoming data from the user so the user

318
00:15:30,209 --> 00:15:35,878
Inc can basically in kernel and trigger

319
00:15:32,850 --> 00:15:38,939
a memo P and he controls the last

320
00:15:35,879 --> 00:15:43,290
argument the length so he can copy too

321
00:15:38,939 --> 00:15:46,160
much data so

322
00:15:43,290 --> 00:15:49,139
yes and this is the other function that

323
00:15:46,160 --> 00:15:52,439
also has this problem here there are

324
00:15:49,139 --> 00:15:54,660
even two mem moves and two separate

325
00:15:52,440 --> 00:16:00,959
members coming from the same input

326
00:15:54,660 --> 00:16:02,670
buffer so this means we have in both of

327
00:16:00,959 --> 00:16:05,430
these functions are control mem move

328
00:16:02,670 --> 00:16:09,329
lengths and this means we can have an

329
00:16:05,430 --> 00:16:14,310
arbitrary overwrite of data in the

330
00:16:09,329 --> 00:16:16,529
outgoing message so this is how it will

331
00:16:14,310 --> 00:16:18,359
look like as a graphic you have

332
00:16:16,529 --> 00:16:21,149
basically the incoming message which is

333
00:16:18,360 --> 00:16:24,269
the coil to the function it has an input

334
00:16:21,149 --> 00:16:26,759
buffer and then we specify how much we

335
00:16:24,269 --> 00:16:28,920
copy and we basically copy it into the

336
00:16:26,759 --> 00:16:31,319
output buffer and of course the output

337
00:16:28,920 --> 00:16:33,420
buffer has only a specified length and

338
00:16:31,319 --> 00:16:36,719
this here will basically take this data

339
00:16:33,420 --> 00:16:37,740
and trash the output buffer or not the

340
00:16:36,720 --> 00:16:39,959
output buffers they were the thing

341
00:16:37,740 --> 00:16:43,380
behind the output buffer so it's kind of

342
00:16:39,959 --> 00:16:47,369
like a buffer overflow with the source

343
00:16:43,380 --> 00:16:49,740
coming from behind our buffer okay again

344
00:16:47,370 --> 00:16:51,750
these are the references you need so

345
00:16:49,740 --> 00:16:53,550
that was just like what is the

346
00:16:51,750 --> 00:16:55,380
vulnerability in the kernel so let's

347
00:16:53,550 --> 00:16:59,010
have a look at the userland part

348
00:16:55,380 --> 00:17:02,160
so in userland there's this company

349
00:16:59,010 --> 00:17:05,099
called sac ops who run what they call a

350
00:17:02,160 --> 00:17:07,918
reverse bug bounty not really sure what

351
00:17:05,099 --> 00:17:09,958
they really mean by that but they

352
00:17:07,919 --> 00:17:13,409
released a write-up about this it's

353
00:17:09,959 --> 00:17:15,480
linked in the references and in the

354
00:17:13,409 --> 00:17:17,220
following section I have a few content

355
00:17:15,480 --> 00:17:19,380
from their from their from their website

356
00:17:17,220 --> 00:17:23,819
so some of the graphics I just copied

357
00:17:19,380 --> 00:17:26,520
over so again this time the buck is

358
00:17:23,819 --> 00:17:30,350
described like this again it just says

359
00:17:26,520 --> 00:17:34,080
memory corruption and can gain evaluated

360
00:17:30,350 --> 00:17:36,570
privileges and then it says it's in the

361
00:17:34,080 --> 00:17:38,629
foundation so foundation is a hint that

362
00:17:36,570 --> 00:17:41,700
it could be in the foundation framework

363
00:17:38,630 --> 00:17:43,290
again the analysis will show you that

364
00:17:41,700 --> 00:17:47,940
it's actually not in the foundation

365
00:17:43,290 --> 00:17:50,510
framework so this time if we want to

366
00:17:47,940 --> 00:17:53,100
actually diss the foundation framework

367
00:17:50,510 --> 00:17:56,030
we have to deal with the fact that in

368
00:17:53,100 --> 00:17:58,159
iOS all libraries and frameworks

369
00:17:56,030 --> 00:18:01,250
are in the so-called dirt shared cage

370
00:17:58,160 --> 00:18:03,140
which is basically a gigantic file many

371
00:18:01,250 --> 00:18:05,090
hundred megabytes where all the

372
00:18:03,140 --> 00:18:07,100
libraries and frameworks are inside and

373
00:18:05,090 --> 00:18:12,199
they're basically paged into all

374
00:18:07,100 --> 00:18:14,419
processes at the same time so the good

375
00:18:12,200 --> 00:18:15,770
thing is that Ida has very good support

376
00:18:14,420 --> 00:18:18,200
for this right now

377
00:18:15,770 --> 00:18:21,200
most other tools have really miserable

378
00:18:18,200 --> 00:18:24,890
support for this so as long as long use

379
00:18:21,200 --> 00:18:26,480
Ida everything is fine also with a clear

380
00:18:24,890 --> 00:18:28,370
different target the foundation

381
00:18:26,480 --> 00:18:32,600
framework the diffing should go a lot

382
00:18:28,370 --> 00:18:34,340
faster the reality is when you do this

383
00:18:32,600 --> 00:18:37,760
on the foundation framework you will

384
00:18:34,340 --> 00:18:39,860
find nothing the reason for this is that

385
00:18:37,760 --> 00:18:41,840
once again Apple has kind of tricked us

386
00:18:39,860 --> 00:18:44,800
a little bit because it's not the

387
00:18:41,840 --> 00:18:47,659
foundation framework that has changed

388
00:18:44,800 --> 00:18:51,230
instead it's a core foundation framework

389
00:18:47,660 --> 00:18:53,780
so if you interview intuitively try to

390
00:18:51,230 --> 00:18:57,320
diff this you will get it therefore a

391
00:18:53,780 --> 00:18:58,700
result that looks like this here this

392
00:18:57,320 --> 00:19:00,590
year is one of those images that I've

393
00:18:58,700 --> 00:19:02,900
directly copied from the tech ops

394
00:19:00,590 --> 00:19:08,449
website and here you can see that

395
00:19:02,900 --> 00:19:10,910
there's some very high yeah likelihood

396
00:19:08,450 --> 00:19:12,830
this is like the matched function and we

397
00:19:10,910 --> 00:19:14,210
can see that there are some changes in

398
00:19:12,830 --> 00:19:15,830
the function because they have a

399
00:19:14,210 --> 00:19:18,380
different number of basic blocks and so

400
00:19:15,830 --> 00:19:24,260
on so you would have to look into what's

401
00:19:18,380 --> 00:19:26,780
going on there so luckily the check ups

402
00:19:24,260 --> 00:19:29,480
people already did this so nobody had to

403
00:19:26,780 --> 00:19:31,250
really manually decompile this because

404
00:19:29,480 --> 00:19:33,860
unfortunately this whole thing is in

405
00:19:31,250 --> 00:19:35,570
core foundation and four years ago Apple

406
00:19:33,860 --> 00:19:38,899
decided to no longer give your source

407
00:19:35,570 --> 00:19:40,490
code for that so we don't have source

408
00:19:38,900 --> 00:19:42,110
code for this so it's harder to look at

409
00:19:40,490 --> 00:19:45,800
it you have to actually really D compile

410
00:19:42,110 --> 00:19:47,570
it manually so they did this and they

411
00:19:45,800 --> 00:19:50,360
came up with this here this is also

412
00:19:47,570 --> 00:19:52,850
taken from their website the function is

413
00:19:50,360 --> 00:19:55,580
super long and they basically have just

414
00:19:52,850 --> 00:19:59,500
marked here so this here's a fix this is

415
00:19:55,580 --> 00:20:02,210
a fix here's a fix and this is a fix so

416
00:19:59,500 --> 00:20:06,680
long story short what does it actually

417
00:20:02,210 --> 00:20:08,930
do basically they identified that the

418
00:20:06,680 --> 00:20:09,710
vulnerability is reference counting

419
00:20:08,930 --> 00:20:12,320
problem

420
00:20:09,710 --> 00:20:14,330
that leads to a double free and it's

421
00:20:12,320 --> 00:20:16,939
basically in one of those XP sea

422
00:20:14,330 --> 00:20:21,590
handling functions and therefore can be

423
00:20:16,940 --> 00:20:25,310
triggered via XP C so by that's really

424
00:20:21,590 --> 00:20:27,620
nice because this demon a lot of

425
00:20:25,310 --> 00:20:30,649
entities and iOS can all talk to this

426
00:20:27,620 --> 00:20:32,840
demon and this demon up to then was

427
00:20:30,650 --> 00:20:37,030
running outside on the sandbox and even

428
00:20:32,840 --> 00:20:40,790
as route so this was a super target for

429
00:20:37,030 --> 00:20:42,980
sandbox escapes so the vulnerability

430
00:20:40,790 --> 00:20:45,530
Twiggs understand what this means this

431
00:20:42,980 --> 00:20:49,730
for example is the dictionary that could

432
00:20:45,530 --> 00:20:52,100
trigger a crash basically it runs

433
00:20:49,730 --> 00:20:56,540
through this CP preference messages

434
00:20:52,100 --> 00:20:59,899
array and each element is copied into a

435
00:20:56,540 --> 00:21:02,180
separate buffer and it's copying this

436
00:20:59,900 --> 00:21:03,920
without increasing the reference counter

437
00:21:02,180 --> 00:21:06,830
so that's basically pointer to it

438
00:21:03,920 --> 00:21:09,740
without a reference counter and then

439
00:21:06,830 --> 00:21:12,980
depending on the counter content they

440
00:21:09,740 --> 00:21:15,110
call different callbacks and these

441
00:21:12,980 --> 00:21:16,850
callbacks are then supposed to increase

442
00:21:15,110 --> 00:21:19,340
the reference counter on the object

443
00:21:16,850 --> 00:21:21,770
however when you have a special crafted

444
00:21:19,340 --> 00:21:22,610
message you can call some illegal

445
00:21:21,770 --> 00:21:27,050
callbacks

446
00:21:22,610 --> 00:21:29,870
so that will result in this reference

447
00:21:27,050 --> 00:21:32,919
counter never been increased the result

448
00:21:29,870 --> 00:21:36,139
is then that we have one reference

449
00:21:32,920 --> 00:21:42,080
missing and then on destruction we

450
00:21:36,140 --> 00:21:44,540
basically have a double free so the

451
00:21:42,080 --> 00:21:46,540
first one was the mem move and in

452
00:21:44,540 --> 00:21:50,389
userland we have a double free problem

453
00:21:46,540 --> 00:21:53,379
okay so this years the the only resource

454
00:21:50,390 --> 00:21:56,240
I used it's basically this blog post

455
00:21:53,380 --> 00:21:57,830
okay now that we've seen both the

456
00:21:56,240 --> 00:21:59,840
vulnerabilities that are involved let's

457
00:21:57,830 --> 00:22:03,770
see how this can theoretically be

458
00:21:59,840 --> 00:22:06,080
exploited so let's look at the kernel

459
00:22:03,770 --> 00:22:09,080
first because the kernel is what I like

460
00:22:06,080 --> 00:22:12,050
most remember this is how availability

461
00:22:09,080 --> 00:22:14,270
looks like in theory so we can copy

462
00:22:12,050 --> 00:22:18,620
whatever is behind our in buffer and

463
00:22:14,270 --> 00:22:20,720
overwrite was behind the out buffer so

464
00:22:18,620 --> 00:22:23,239
the question that you always ask in this

465
00:22:20,720 --> 00:22:26,840
cases where are these buffer

466
00:22:23,240 --> 00:22:31,039
and I can tell you that the incoming

467
00:22:26,840 --> 00:22:34,279
buffer is basically coming from the

468
00:22:31,039 --> 00:22:36,200
middle of a mock message because these

469
00:22:34,279 --> 00:22:38,330
external methods are called by amok

470
00:22:36,200 --> 00:22:41,179
messages and then the buffer for the

471
00:22:38,330 --> 00:22:43,520
content is basically inside that payload

472
00:22:41,179 --> 00:22:45,620
of the mock message that means somewhere

473
00:22:43,520 --> 00:22:49,850
in this allocated mock message you will

474
00:22:45,620 --> 00:22:52,399
find your buffer the next thing is this

475
00:22:49,850 --> 00:22:55,100
kind of messages are used in a

476
00:22:52,399 --> 00:22:57,469
compressed form by the kernel and the

477
00:22:55,100 --> 00:22:59,959
userland part so they try to make the

478
00:22:57,470 --> 00:23:02,169
messages as small as possible so that

479
00:22:59,960 --> 00:23:05,720
means depending on the length of the

480
00:23:02,169 --> 00:23:08,720
actual parameters the message will be

481
00:23:05,720 --> 00:23:10,610
smaller or larger so that means the

482
00:23:08,720 --> 00:23:12,500
position on the heap of the kernel

483
00:23:10,610 --> 00:23:17,899
depends on the length of the actual

484
00:23:12,500 --> 00:23:21,649
arguments to that function so these are

485
00:23:17,899 --> 00:23:23,719
the two vulnerable functions that have

486
00:23:21,649 --> 00:23:25,850
this mem copy directly in the mem move

487
00:23:23,720 --> 00:23:29,480
directly in there and we can see we have

488
00:23:25,850 --> 00:23:32,570
one time parameter length of 78 and one

489
00:23:29,480 --> 00:23:34,880
time of 8 see and the result of this is

490
00:23:32,570 --> 00:23:37,520
because of this compression that the

491
00:23:34,880 --> 00:23:40,100
upper method will use an input buffer

492
00:23:37,520 --> 00:23:43,700
that is somewhere on the KO log for

493
00:23:40,100 --> 00:23:46,850
kilobytes zone and the lower will use

494
00:23:43,700 --> 00:23:49,309
the catalog 512th own so these are

495
00:23:46,850 --> 00:23:50,928
different zones and if you're interested

496
00:23:49,309 --> 00:23:53,418
in this you have to look into one of the

497
00:23:50,929 --> 00:23:55,399
previous heap talks that I did basically

498
00:23:53,419 --> 00:23:59,299
these are different areas on the heap

499
00:23:55,399 --> 00:24:00,889
that is very nice because then they can

500
00:23:59,299 --> 00:24:04,039
be attacked independently from each

501
00:24:00,890 --> 00:24:06,799
other the fact that this whole thing is

502
00:24:04,039 --> 00:24:08,720
in Ko log memory is also nice because a

503
00:24:06,799 --> 00:24:10,220
lot of stuff buffers and everything is

504
00:24:08,720 --> 00:24:12,529
also in clear log memory

505
00:24:10,220 --> 00:24:16,850
so you're basically surrounded by

506
00:24:12,529 --> 00:24:18,529
interesting things and by choosing one

507
00:24:16,850 --> 00:24:21,199
of those different messages to attack

508
00:24:18,529 --> 00:24:23,149
the attacker can kinda kind of decide if

509
00:24:21,200 --> 00:24:25,490
he wants to go to the long zone or the

510
00:24:23,149 --> 00:24:29,299
short zone I skimmed through the

511
00:24:25,490 --> 00:24:31,159
description from a and b.a just an hour

512
00:24:29,299 --> 00:24:32,570
before the talk so I believe the

513
00:24:31,159 --> 00:24:35,830
official exploit that was found in

514
00:24:32,570 --> 00:24:35,830
awhile used this one yeah

515
00:24:37,420 --> 00:24:44,180
so now what about the output buffer well

516
00:24:42,350 --> 00:24:46,340
the output buffer is basically in the

517
00:24:44,180 --> 00:24:49,100
middle of the reply mark message and

518
00:24:46,340 --> 00:24:54,740
this is initially allocated to be from

519
00:24:49,100 --> 00:24:56,659
the catalog 8990 to zone because it

520
00:24:54,740 --> 00:24:58,880
doesn't know beforehand how long the

521
00:24:56,660 --> 00:25:01,490
output will be and then later it gets

522
00:24:58,880 --> 00:25:03,920
compressed and so on but this basically

523
00:25:01,490 --> 00:25:07,580
means that under our outgoing sing is

524
00:25:03,920 --> 00:25:10,520
somewhere in this other kind of zone the

525
00:25:07,580 --> 00:25:14,270
blocks are bigger in the zone so the

526
00:25:10,520 --> 00:25:16,780
result of this is that our source and

527
00:25:14,270 --> 00:25:20,060
destination use completely different

528
00:25:16,780 --> 00:25:22,160
catalogs zones that is nice because it

529
00:25:20,060 --> 00:25:22,669
means that an attacker can use he

530
00:25:22,160 --> 00:25:25,700
feng-shui

531
00:25:22,670 --> 00:25:29,020
on each of those zones separately and

532
00:25:25,700 --> 00:25:34,280
they are not interfering with each other

533
00:25:29,020 --> 00:25:36,590
the next thing is also that the attacker

534
00:25:34,280 --> 00:25:40,129
in the in the input can choose if he

535
00:25:36,590 --> 00:25:43,070
needs small or large zones depending on

536
00:25:40,130 --> 00:25:45,050
what kind of attack he tries to do by

537
00:25:43,070 --> 00:25:49,730
the way this graphics is supposed to

538
00:25:45,050 --> 00:25:51,440
show you that the in buffer is not at

539
00:25:49,730 --> 00:25:54,140
the beginning of this message somewhere

540
00:25:51,440 --> 00:25:56,030
in there and the actual copy is also not

541
00:25:54,140 --> 00:25:58,040
at the very beginning but somewhere here

542
00:25:56,030 --> 00:26:00,680
and then all of this here is basically

543
00:25:58,040 --> 00:26:02,270
moved into the output buffer but also

544
00:26:00,680 --> 00:26:04,610
not at the beginning of the output

545
00:26:02,270 --> 00:26:09,889
buffer but a little bit in I think in

546
00:26:04,610 --> 00:26:11,990
both cases 4 bytes in so knowing this

547
00:26:09,890 --> 00:26:15,350
now the question is how can you exploit

548
00:26:11,990 --> 00:26:18,250
this so I already told you you basically

549
00:26:15,350 --> 00:26:21,620
need hip Feng Shui to exploit this and

550
00:26:18,250 --> 00:26:26,930
most exploits against iOS kernel in the

551
00:26:21,620 --> 00:26:29,810
in the past few years use port fake port

552
00:26:26,930 --> 00:26:31,730
techniques to somehow in the end get

553
00:26:29,810 --> 00:26:34,639
something called the kernel task port

554
00:26:31,730 --> 00:26:37,460
which then legally gives you read/write

555
00:26:34,640 --> 00:26:39,290
access to the kernel from userland this

556
00:26:37,460 --> 00:26:42,560
is usually what most of the iOS exploits

557
00:26:39,290 --> 00:26:45,889
do so the hip factory techniques that we

558
00:26:42,560 --> 00:26:48,620
publicly know about is this here that we

559
00:26:45,890 --> 00:26:48,960
have we a map copy T that is the old one

560
00:26:48,620 --> 00:26:51,110
into

561
00:26:48,960 --> 00:26:56,250
Joost around the time of iOS 6 from

562
00:26:51,110 --> 00:26:58,799
McDowell and Taj a month after that up

563
00:26:56,250 --> 00:27:02,669
to iOS 9 most public jailbreak were

564
00:26:58,799 --> 00:27:04,559
using this technique but with every new

565
00:27:02,669 --> 00:27:07,919
revision Apple made us less and less and

566
00:27:04,559 --> 00:27:09,990
less useful but in our case the

567
00:27:07,919 --> 00:27:12,179
remaining things that you can do is this

568
00:27:09,990 --> 00:27:15,059
is still good enough for what we are

569
00:27:12,179 --> 00:27:17,610
trying to do with it then we have this

570
00:27:15,059 --> 00:27:20,010
second technique which is the oil i'll

571
00:27:17,610 --> 00:27:22,379
ports the scripted technique that was

572
00:27:20,010 --> 00:27:24,059
taught in my training for a long time

573
00:27:22,380 --> 00:27:27,659
and then the first time it was public

574
00:27:24,059 --> 00:27:30,270
was around the time of Yahoo because

575
00:27:27,659 --> 00:27:32,250
they they put it in there and then in

576
00:27:30,270 --> 00:27:35,250
2017 I did a target can sequester

577
00:27:32,250 --> 00:27:37,350
describing this technique it basically

578
00:27:35,250 --> 00:27:41,399
allows you to fill the memory with

579
00:27:37,350 --> 00:27:44,129
pointers to ports so the third one is

580
00:27:41,399 --> 00:27:47,250
this ORS unser Isaac's ml and was until

581
00:27:44,130 --> 00:27:50,669
Isaac's binary this is a technique for

582
00:27:47,250 --> 00:27:53,850
hip feng-shui that I created around the

583
00:27:50,669 --> 00:27:59,100
time of I was five long long time ago

584
00:27:53,850 --> 00:28:01,260
and then Apple patched it to mitigate my

585
00:27:59,100 --> 00:28:05,039
attacks and later they unpatched it

586
00:28:01,260 --> 00:28:07,710
again so basically my original attacks

587
00:28:05,039 --> 00:28:11,220
from from around of iOS 5 is still

588
00:28:07,710 --> 00:28:13,799
possible against these things also some

589
00:28:11,220 --> 00:28:16,409
slight variants was were always possible

590
00:28:13,799 --> 00:28:18,658
so still available Singh basically these

591
00:28:16,409 --> 00:28:22,980
techniques allow you to spray the heap

592
00:28:18,659 --> 00:28:26,220
with C++ objects and their data in

593
00:28:22,980 --> 00:28:30,600
kernel and then the the next technique

594
00:28:26,220 --> 00:28:32,960
is similar it basically assumes that

595
00:28:30,600 --> 00:28:36,600
Apple fixed everything that I showed and

596
00:28:32,960 --> 00:28:38,850
combines it with a different driver the

597
00:28:36,600 --> 00:28:41,459
iowa's surface driver and this year was

598
00:28:38,850 --> 00:28:44,699
presented at this conference like two

599
00:28:41,460 --> 00:28:48,630
years ago I believe by Adam I always

600
00:28:44,700 --> 00:28:50,700
forget dawna felt or so please don't I I

601
00:28:48,630 --> 00:28:53,730
die for always forever forget this last

602
00:28:50,700 --> 00:28:56,399
name so he basically showed how he

603
00:28:53,730 --> 00:28:59,639
combined this technique with his iris

604
00:28:56,399 --> 00:29:02,039
surface interface and the nice thing

605
00:28:59,639 --> 00:29:02,669
about this technique and this technique

606
00:29:02,039 --> 00:29:05,310
is

607
00:29:02,670 --> 00:29:08,400
that you cannot only override stuff but

608
00:29:05,310 --> 00:29:10,919
you can also read back to some degree

609
00:29:08,400 --> 00:29:12,420
what was overwritten with so this can be

610
00:29:10,920 --> 00:29:15,060
used for info leagues that's why these

611
00:29:12,420 --> 00:29:17,700
are interesting so in the last one that

612
00:29:15,060 --> 00:29:21,690
is mentioned here is something that I am

613
00:29:17,700 --> 00:29:25,470
pure invented so he's basically spraying

614
00:29:21,690 --> 00:29:28,290
the the memory with new parts that have

615
00:29:25,470 --> 00:29:30,000
pre-allocated mock messages and this is

616
00:29:28,290 --> 00:29:34,530
something that was used for example in

617
00:29:30,000 --> 00:29:37,350
the extract recipe iOS 10 jailbreak but

618
00:29:34,530 --> 00:29:42,090
as far as I remember its I am beer who

619
00:29:37,350 --> 00:29:44,419
did this first so knowing all this

620
00:29:42,090 --> 00:29:49,760
questions now how can we use that

621
00:29:44,420 --> 00:29:52,020
so in all devices before the iPhone 7

622
00:29:49,760 --> 00:29:56,100
this situation is basically immediately

623
00:29:52,020 --> 00:29:59,580
game over I showed that in Ken's like

624
00:29:56,100 --> 00:30:01,409
West 2017 basically I showed this

625
00:29:59,580 --> 00:30:03,629
technique where basically any memory

626
00:30:01,410 --> 00:30:06,660
corruption the kernel is instantly game

627
00:30:03,630 --> 00:30:10,050
over on these all devices so how can we

628
00:30:06,660 --> 00:30:13,160
use this in this case well we first have

629
00:30:10,050 --> 00:30:16,470
to use the vm app copy t-- technique to

630
00:30:13,160 --> 00:30:18,600
allocate something here in the 512 area

631
00:30:16,470 --> 00:30:21,300
so we have full control over the content

632
00:30:18,600 --> 00:30:25,770
here so we can make it user land

633
00:30:21,300 --> 00:30:29,250
pointers and then at the same time we

634
00:30:25,770 --> 00:30:34,530
use this technique here to fill in this

635
00:30:29,250 --> 00:30:38,940
size here everything to zero pointers to

636
00:30:34,530 --> 00:30:42,360
ports what happens now is when we

637
00:30:38,940 --> 00:30:47,610
trigger the vulnerability is that our

638
00:30:42,360 --> 00:30:50,669
control data from here it's written into

639
00:30:47,610 --> 00:30:52,919
a port pointer here so this year will be

640
00:30:50,670 --> 00:30:54,780
taking at the port pointer so on the old

641
00:30:52,920 --> 00:30:57,510
devices before the iphone 7 that is

642
00:30:54,780 --> 00:31:00,060
instant game over because we can make it

643
00:30:57,510 --> 00:31:01,860
at user land pointer and because user

644
00:31:00,060 --> 00:31:04,260
land dereference is possible on these

645
00:31:01,860 --> 00:31:06,629
devices you can do whatever you want in

646
00:31:04,260 --> 00:31:08,160
userland change the port as much as you

647
00:31:06,630 --> 00:31:09,240
want and you can use it then from

648
00:31:08,160 --> 00:31:11,100
userland

649
00:31:09,240 --> 00:31:13,410
and in this cancer quest talk I

650
00:31:11,100 --> 00:31:17,610
basically showed how you first take a

651
00:31:13,410 --> 00:31:20,100
clock port this way this allows you to

652
00:31:17,610 --> 00:31:23,280
break KS alarm because you can brute

653
00:31:20,100 --> 00:31:27,949
force the the kernel-based address then

654
00:31:23,280 --> 00:31:31,590
you use task port with the pitiful task

655
00:31:27,950 --> 00:31:34,830
method this allows you to read arbitrary

656
00:31:31,590 --> 00:31:38,820
32-bit values from kernel end and then

657
00:31:34,830 --> 00:31:41,310
with the help of these reads you can

658
00:31:38,820 --> 00:31:43,409
then create a new task port that is

659
00:31:41,310 --> 00:31:45,870
birthing a kernel task port or a fake

660
00:31:43,410 --> 00:31:48,330
kernel transport and this can then be

661
00:31:45,870 --> 00:31:51,540
used in VM read VM write and so on

662
00:31:48,330 --> 00:31:53,100
to read and write kernel memory again if

663
00:31:51,540 --> 00:31:55,710
you want to figure out how this really

664
00:31:53,100 --> 00:31:58,230
works in detail the can sequester slides

665
00:31:55,710 --> 00:32:02,430
are there but there's a reference so you

666
00:31:58,230 --> 00:32:04,350
can find it so but we are on new devices

667
00:32:02,430 --> 00:32:08,070
so how would this work on new devices

668
00:32:04,350 --> 00:32:10,379
the thing is this buck is so nice that

669
00:32:08,070 --> 00:32:13,110
you can have many many different ways to

670
00:32:10,380 --> 00:32:15,450
maybe abuse this so this here is an

671
00:32:13,110 --> 00:32:18,780
example what you could do in this case

672
00:32:15,450 --> 00:32:22,200
it's just for info leaking so you would

673
00:32:18,780 --> 00:32:25,910
use one of these two methods here

674
00:32:22,200 --> 00:32:29,070
basically to control the content here oh

675
00:32:25,910 --> 00:32:30,660
no sorry in the output buffer so you

676
00:32:29,070 --> 00:32:32,730
control the output buffer here behind

677
00:32:30,660 --> 00:32:36,330
with one of those he venturi techniques

678
00:32:32,730 --> 00:32:39,240
and then you trigger the back and what

679
00:32:36,330 --> 00:32:43,980
happens is everything that was in here

680
00:32:39,240 --> 00:32:46,050
will be written in here and the nice

681
00:32:43,980 --> 00:32:49,620
thing about these two techniques here is

682
00:32:46,050 --> 00:32:51,899
that you can read back the content that

683
00:32:49,620 --> 00:32:54,239
is now in there so you can basically see

684
00:32:51,900 --> 00:32:56,640
what you have overwritten this with and

685
00:32:54,240 --> 00:32:58,950
this means any kind of pointer or

686
00:32:56,640 --> 00:33:02,730
whatever was in here is all leaked to

687
00:32:58,950 --> 00:33:04,650
you at the same time of course you could

688
00:33:02,730 --> 00:33:06,630
have have done a special heat feng-shui

689
00:33:04,650 --> 00:33:09,660
here so that you know exactly what's

690
00:33:06,630 --> 00:33:11,190
inside there but even if you don't do

691
00:33:09,660 --> 00:33:15,050
that it's very likely that you find

692
00:33:11,190 --> 00:33:15,050
kernel pointers in there oops Allah

693
00:33:16,020 --> 00:33:24,330
yeah so another example is you could use

694
00:33:21,720 --> 00:33:27,059
the input zone use the oil technique

695
00:33:24,330 --> 00:33:31,379
again so you basically control exactly

696
00:33:27,059 --> 00:33:33,800
what's inside here and then this

697
00:33:31,380 --> 00:33:37,650
basically degrades the whole thing to a

698
00:33:33,800 --> 00:33:40,260
buffer flow and this basically makes it

699
00:33:37,650 --> 00:33:43,559
exactly the same as the iOS 10 jailbreak

700
00:33:40,260 --> 00:33:46,490
in terms of exploitation so you could

701
00:33:43,559 --> 00:33:49,530
then take any at iOS 10 jailbreak and

702
00:33:46,490 --> 00:33:53,600
combine that for example the technique

703
00:33:49,530 --> 00:33:57,240
used in extract recipe with iron beers

704
00:33:53,600 --> 00:33:59,639
message over writing that is what you

705
00:33:57,240 --> 00:34:04,470
can do here directly can basically maybe

706
00:33:59,640 --> 00:34:09,149
just copy and past it another thing that

707
00:34:04,470 --> 00:34:12,360
you can do is you could spray the input

708
00:34:09,149 --> 00:34:17,690
zone with actual pointers to legal ports

709
00:34:12,360 --> 00:34:21,450
and then the output zone you spray with

710
00:34:17,690 --> 00:34:23,460
empty pointer lists and what happens

711
00:34:21,449 --> 00:34:25,980
then is it copies the real pointers into

712
00:34:23,460 --> 00:34:28,590
the empty pointer list and the result

713
00:34:25,980 --> 00:34:32,010
will be that when this here is all freed

714
00:34:28,590 --> 00:34:34,169
all these pointers are basically the

715
00:34:32,010 --> 00:34:36,450
ports are gone and so we have a lot of

716
00:34:34,168 --> 00:34:40,049
dangling pointers to actual real ports

717
00:34:36,449 --> 00:34:42,270
and in the past few years there were

718
00:34:40,050 --> 00:34:44,730
multiple times where there were in

719
00:34:42,270 --> 00:34:46,379
abilities with dangling port pointers so

720
00:34:44,730 --> 00:34:48,510
again you could use any of those

721
00:34:46,379 --> 00:34:52,199
exploitation technique that was used in

722
00:34:48,510 --> 00:34:58,890
these days the last thing here that I

723
00:34:52,199 --> 00:35:03,839
have described here I've never actually

724
00:34:58,890 --> 00:35:07,580
tried of this year is totally good the

725
00:35:03,840 --> 00:35:13,770
idea is because we are in catalog area

726
00:35:07,580 --> 00:35:17,569
we can actually allocate memory and then

727
00:35:13,770 --> 00:35:20,910
make it next to other types of memory

728
00:35:17,570 --> 00:35:24,300
invs uses it exploits many many times so

729
00:35:20,910 --> 00:35:29,230
the idea here would be that you flood

730
00:35:24,300 --> 00:35:33,369
the heap with new kernel pods

731
00:35:29,230 --> 00:35:36,040
and then they are basically in this

732
00:35:33,369 --> 00:35:39,369
orange area here actual real Colonel

733
00:35:36,040 --> 00:35:42,040
pods and then you can use this here to

734
00:35:39,369 --> 00:35:44,530
basically partially overwrite the kernel

735
00:35:42,040 --> 00:35:46,660
pods from the beginning this allows you

736
00:35:44,530 --> 00:35:49,240
to change the pointer where the part is

737
00:35:46,660 --> 00:35:52,060
going to but it also allows you to

738
00:35:49,240 --> 00:35:53,649
change the type of the port which

739
00:35:52,060 --> 00:35:56,710
basically then allows you to actually

740
00:35:53,650 --> 00:36:00,730
have again access to a port from

741
00:35:56,710 --> 00:36:03,700
userland as long you only go after ports

742
00:36:00,730 --> 00:36:05,500
like this all of this will also work on

743
00:36:03,700 --> 00:36:09,100
the newest devices because we don't

744
00:36:05,500 --> 00:36:12,160
involve any kind of Rob we only do data

745
00:36:09,100 --> 00:36:19,180
only attacks to basically create fake

746
00:36:12,160 --> 00:36:22,839
ports so what methods the attackers

747
00:36:19,180 --> 00:36:26,560
really used I'm not sure like I said I

748
00:36:22,840 --> 00:36:30,930
did not read the the the gigantic blog

749
00:36:26,560 --> 00:36:33,190
post yet I only went fast through it so

750
00:36:30,930 --> 00:36:37,440
but they also used some hip feng-shui

751
00:36:33,190 --> 00:36:40,359
and some kind of override like this so

752
00:36:37,440 --> 00:36:44,500
again these are all the references only

753
00:36:40,359 --> 00:36:47,680
the last one years missing I will make

754
00:36:44,500 --> 00:36:53,410
an updated slightly available at some

755
00:36:47,680 --> 00:36:55,118
point where I put this link in so now

756
00:36:53,410 --> 00:36:58,629
that we have looked at the kernel and

757
00:36:55,119 --> 00:37:01,840
let's have a look at the user land so

758
00:36:58,630 --> 00:37:05,170
the user land again was looked at from

759
00:37:01,840 --> 00:37:05,800
Secord's and they again wrote a write-up

760
00:37:05,170 --> 00:37:09,310
about it

761
00:37:05,800 --> 00:37:12,760
there is the POC code and the problem

762
00:37:09,310 --> 00:37:15,970
with this is their pop fault has no

763
00:37:12,760 --> 00:37:19,510
payload it doesn't actually do what they

764
00:37:15,970 --> 00:37:22,990
described in the in the text and it

765
00:37:19,510 --> 00:37:26,200
doesn't actually work on iOS devices for

766
00:37:22,990 --> 00:37:29,229
sure because they are doing things that

767
00:37:26,200 --> 00:37:33,939
really for sure freeze iOS devices so

768
00:37:29,230 --> 00:37:37,420
maybe there's work on a Mac but even

769
00:37:33,940 --> 00:37:39,760
then it is just a crash POC because they

770
00:37:37,420 --> 00:37:42,230
gave up at some point because they could

771
00:37:39,760 --> 00:37:44,520
not solve a problem

772
00:37:42,230 --> 00:37:48,240
by the way the heap spray that they're

773
00:37:44,520 --> 00:37:52,650
using is basically copy pasted from iron

774
00:37:48,240 --> 00:37:55,319
Pierce slide deck so for example they're

775
00:37:52,650 --> 00:37:58,170
trying to spray one gigabyte of memory a

776
00:37:55,320 --> 00:38:02,790
good luck trying that on an iPhone you

777
00:37:58,170 --> 00:38:06,000
basically freeze the iPhone so what kind

778
00:38:02,790 --> 00:38:07,890
of vulnerability was this again so we

779
00:38:06,000 --> 00:38:10,890
know it's a reference counting thing and

780
00:38:07,890 --> 00:38:14,100
it happens in the same XP C request

781
00:38:10,890 --> 00:38:16,500
without any interruption by the user so

782
00:38:14,100 --> 00:38:21,450
we have no control between the first and

783
00:38:16,500 --> 00:38:25,050
the second release so how do you exploit

784
00:38:21,450 --> 00:38:26,879
this well you have to raise this you

785
00:38:25,050 --> 00:38:31,530
have to get a second connection to the

786
00:38:26,880 --> 00:38:35,490
expiry server and raise this how do you

787
00:38:31,530 --> 00:38:41,160
get in between well you need to increase

788
00:38:35,490 --> 00:38:45,359
the raise window so first of all how can

789
00:38:41,160 --> 00:38:48,629
you do fill memory where you create a

790
00:38:45,359 --> 00:38:51,509
new explicit connection and you just

791
00:38:48,630 --> 00:38:54,210
send over an array with a lot of data in

792
00:38:51,510 --> 00:38:56,880
it so this will do a lot of applications

793
00:38:54,210 --> 00:39:00,270
on the heap of the same demon just in a

794
00:38:56,880 --> 00:39:02,670
different thread yeah so you could do

795
00:39:00,270 --> 00:39:05,369
that or you have to do it multiple if

796
00:39:02,670 --> 00:39:07,050
you have multi multiple cores you might

797
00:39:05,369 --> 00:39:09,510
have to do this multiple times because

798
00:39:07,050 --> 00:39:13,140
on multi-core systems the allocation

799
00:39:09,510 --> 00:39:15,109
might end up on different areas of the

800
00:39:13,140 --> 00:39:20,700
heap if they are made from different

801
00:39:15,109 --> 00:39:23,340
threads so that is the first part so now

802
00:39:20,700 --> 00:39:28,830
the second part how do you ensure that

803
00:39:23,340 --> 00:39:31,100
you can raise that dead window the idea

804
00:39:28,830 --> 00:39:33,720
is that you can increase the time window

805
00:39:31,100 --> 00:39:36,330
because the first in the second free

806
00:39:33,720 --> 00:39:39,000
basically happened the first free

807
00:39:36,330 --> 00:39:41,940
happens in here when it runs through the

808
00:39:39,000 --> 00:39:44,369
array and goes through all entries of

809
00:39:41,940 --> 00:39:46,200
the array so naturally you can you see

810
00:39:44,369 --> 00:39:50,090
when you make the array very very very

811
00:39:46,200 --> 00:39:52,830
long then this year will loop longer and

812
00:39:50,090 --> 00:39:54,770
you have a longer time to actually get

813
00:39:52,830 --> 00:39:57,869
an allocation in between

814
00:39:54,770 --> 00:40:00,170
because the the actual second free will

815
00:39:57,869 --> 00:40:04,380
happen outside this function here so

816
00:40:00,170 --> 00:40:06,210
just make this here very very long the

817
00:40:04,380 --> 00:40:08,849
first element becomes your double free

818
00:40:06,210 --> 00:40:12,000
the other elements you legally deal with

819
00:40:08,849 --> 00:40:16,020
and then you have a longer time between

820
00:40:12,000 --> 00:40:18,390
the first and the second frame so what

821
00:40:16,020 --> 00:40:21,060
do you fill memory with and and this

822
00:40:18,390 --> 00:40:25,200
this is basically where the SEC ups

823
00:40:21,060 --> 00:40:28,049
people basically gave up they realized

824
00:40:25,200 --> 00:40:30,390
at this point that how you exploit this

825
00:40:28,050 --> 00:40:33,240
normally is done via this fake article

826
00:40:30,390 --> 00:40:36,089
from Nemo so you can look it up it's um

827
00:40:33,240 --> 00:40:38,910
basically a popular technique but it

828
00:40:36,090 --> 00:40:42,480
requires you to have access to the first

829
00:40:38,910 --> 00:40:45,390
eight bytes which is the ISO pointer the

830
00:40:42,480 --> 00:40:47,190
type of the object and then you also

831
00:40:45,390 --> 00:40:49,529
need to control the links of what you're

832
00:40:47,190 --> 00:40:52,380
allocating so what the guise of sec of

833
00:40:49,530 --> 00:40:55,070
tried was to use strings because they

834
00:40:52,380 --> 00:40:58,410
can make them arbitrary long and

835
00:40:55,070 --> 00:41:02,280
internally users stood up so it's just a

836
00:40:58,410 --> 00:41:04,348
normal malloc of a specific size and you

837
00:41:02,280 --> 00:41:07,410
can also do this many many times so they

838
00:41:04,349 --> 00:41:11,700
can basically heaps pray with it so they

839
00:41:07,410 --> 00:41:13,549
showed that they can do program counter

840
00:41:11,700 --> 00:41:18,569
control from this or crash controller

841
00:41:13,550 --> 00:41:21,750
but the problem here is that that

842
00:41:18,570 --> 00:41:23,760
doesn't work in reality because the

843
00:41:21,750 --> 00:41:26,190
pointers will normally have null boils

844
00:41:23,760 --> 00:41:29,760
in them and these strings will be

845
00:41:26,190 --> 00:41:31,920
truncated null bytes so the POC that

846
00:41:29,760 --> 00:41:36,690
they're released can never actually work

847
00:41:31,920 --> 00:41:38,730
in in real and at this point they just

848
00:41:36,690 --> 00:41:44,220
skip over it and don't say what they're

849
00:41:38,730 --> 00:41:47,820
doing so how did it really work well

850
00:41:44,220 --> 00:41:50,939
this is from this block that was

851
00:41:47,820 --> 00:41:53,849
released yesterday and I told you I have

852
00:41:50,940 --> 00:41:56,820
not read this completely but as you can

853
00:41:53,849 --> 00:42:01,080
see here they have the same kind of XP

854
00:41:56,820 --> 00:42:03,359
see requests here but they use a very

855
00:42:01,080 --> 00:42:05,980
different kind of messages that they

856
00:42:03,359 --> 00:42:07,750
send again they have

857
00:42:05,980 --> 00:42:10,150
fully documented messages that the

858
00:42:07,750 --> 00:42:13,090
actual real exploits sent on this blog

859
00:42:10,150 --> 00:42:16,270
post so I'm not going to copy paste this

860
00:42:13,090 --> 00:42:23,080
here so you basically can read it from

861
00:42:16,270 --> 00:42:24,850
from there what they really used so the

862
00:42:23,080 --> 00:42:31,119
nice saying that I haven't mentioned yet

863
00:42:24,850 --> 00:42:34,839
is why you do this exploitation you can

864
00:42:31,119 --> 00:42:39,070
actually abuse the fact that this demon

865
00:42:34,840 --> 00:42:42,010
is started via a launch daemon because

866
00:42:39,070 --> 00:42:44,650
it means every time you crash this it

867
00:42:42,010 --> 00:42:47,710
will automatically respawn the next time

868
00:42:44,650 --> 00:42:49,690
you connect to the expiry service so T

869
00:42:47,710 --> 00:42:55,119
erratically if you crash it you could

870
00:42:49,690 --> 00:42:56,920
just redo it that just means if your hip

871
00:42:55,119 --> 00:42:59,260
Feng shooey didn't work as well as you

872
00:42:56,920 --> 00:43:02,500
wanted you would crash it and then you

873
00:42:59,260 --> 00:43:04,510
can try over and over again the question

874
00:43:02,500 --> 00:43:07,270
is and again I have not read the whole

875
00:43:04,510 --> 00:43:09,640
thing so I have no idea however how

876
00:43:07,270 --> 00:43:11,590
Google really found all of this so I

877
00:43:09,640 --> 00:43:14,500
don't know if the original expert was so

878
00:43:11,590 --> 00:43:16,630
noisy that it has a lot of crash thumbs

879
00:43:14,500 --> 00:43:18,609
because this will make it easy for

880
00:43:16,630 --> 00:43:21,250
Google to actually no notice this kind

881
00:43:18,609 --> 00:43:23,350
of thing but yes this would be possible

882
00:43:21,250 --> 00:43:30,280
if your hip Feng Shui goes bonkers you

883
00:43:23,350 --> 00:43:34,109
can just retry after the crash yes what

884
00:43:30,280 --> 00:43:38,740
would you do the moment you have robbed

885
00:43:34,109 --> 00:43:41,859
so the good thing is at the moment the

886
00:43:38,740 --> 00:43:44,200
do th is mapped into all processes at

887
00:43:41,859 --> 00:43:47,890
the same position that means a local

888
00:43:44,200 --> 00:43:50,169
attacker can totally bypass a SLR in

889
00:43:47,890 --> 00:43:53,230
userland because all the libraries

890
00:43:50,170 --> 00:43:57,540
everything is at the same position at

891
00:43:53,230 --> 00:44:00,040
least at the moment so this means that

892
00:43:57,540 --> 00:44:03,009
treating Rob programs is very easy

893
00:44:00,040 --> 00:44:05,470
because you know where all these Rob

894
00:44:03,010 --> 00:44:09,190
gadgets are you don't need an info leak

895
00:44:05,470 --> 00:44:10,959
to actually find this out first so let's

896
00:44:09,190 --> 00:44:15,960
say we have solved this step and we can

897
00:44:10,960 --> 00:44:19,690
run whatever we want in CP f c/f prefs d

898
00:44:15,960 --> 00:44:24,369
what did we actually do so

899
00:44:19,690 --> 00:44:27,250
one thing that they said which is kind

900
00:44:24,369 --> 00:44:33,010
of amusing is they said oh you can run

901
00:44:27,250 --> 00:44:35,980
the system function or you can steal the

902
00:44:33,010 --> 00:44:38,020
task for like Brendon as I did so the

903
00:44:35,980 --> 00:44:39,550
thing is you cannot run the system

904
00:44:38,020 --> 00:44:42,250
function because the system function

905
00:44:39,550 --> 00:44:44,650
requires a shell to exist on an iPhone

906
00:44:42,250 --> 00:44:46,329
and on no normal iPhone that is not

907
00:44:44,650 --> 00:44:49,990
jailbroken you will ever find a shell

908
00:44:46,329 --> 00:44:51,550
normally so what you can only do here in

909
00:44:49,990 --> 00:44:54,750
this case would be to steal the task

910
00:44:51,550 --> 00:44:57,579
port and then remote-control the task

911
00:44:54,750 --> 00:44:59,290
they are to reference linked here both

912
00:44:57,579 --> 00:45:02,589
from Brandon desert where he basically

913
00:44:59,290 --> 00:45:04,450
shows us in one of his exploits where he

914
00:45:02,589 --> 00:45:06,730
basically in the first year basically

915
00:45:04,450 --> 00:45:09,069
steals the task port and remote controls

916
00:45:06,730 --> 00:45:11,200
it like introduced no new code and on

917
00:45:09,069 --> 00:45:14,380
and in the second one he actually

918
00:45:11,200 --> 00:45:19,149
created a little library to basically

919
00:45:14,380 --> 00:45:20,829
bypass an apple mitigation and do the

920
00:45:19,150 --> 00:45:23,140
whole remote control again so he has

921
00:45:20,829 --> 00:45:28,089
created a library basically to run code

922
00:45:23,140 --> 00:45:30,250
in other processes however the only

923
00:45:28,089 --> 00:45:32,589
thing that we need an hour attack is

924
00:45:30,250 --> 00:45:34,599
basically we need someone to open a

925
00:45:32,589 --> 00:45:37,450
connection to that driver and give us

926
00:45:34,599 --> 00:45:40,540
that port so we can then send the

927
00:45:37,450 --> 00:45:42,819
external methods to that port so in any

928
00:45:40,540 --> 00:45:44,849
case we could create a Rob halo that

929
00:45:42,819 --> 00:45:48,460
just gives us the driver connection over

930
00:45:44,849 --> 00:45:51,069
or we can steal the task port but then

931
00:45:48,460 --> 00:45:53,920
we have to inject code that creates the

932
00:45:51,069 --> 00:45:57,520
driver connection for us and so it's

933
00:45:53,920 --> 00:45:59,589
just the same thing the only difference

934
00:45:57,520 --> 00:46:03,670
is that the one of the things has

935
00:45:59,589 --> 00:46:08,279
actually good library so again these are

936
00:46:03,670 --> 00:46:11,230
the references and I'm already through

937
00:46:08,280 --> 00:46:17,020
so basically what are my conclusions

938
00:46:11,230 --> 00:46:21,069
from this research the thing is that

939
00:46:17,020 --> 00:46:23,589
both vulnerabilities were easily found

940
00:46:21,069 --> 00:46:28,359
by just using a little bit of de Fora

941
00:46:23,589 --> 00:46:31,990
and then reading the code and that was

942
00:46:28,359 --> 00:46:32,910
basically changed for my point of view

943
00:46:31,990 --> 00:46:35,939
the

944
00:46:32,910 --> 00:46:37,980
availability was super easy to spot from

945
00:46:35,940 --> 00:46:40,230
the diff because it was just the size

946
00:46:37,980 --> 00:46:43,530
check and the mem copy afterwards and

947
00:46:40,230 --> 00:46:45,390
also the code flow was easy to follow so

948
00:46:43,530 --> 00:46:48,720
you could see that this came directly

949
00:46:45,390 --> 00:46:51,810
from the user the user space

950
00:46:48,720 --> 00:46:53,790
vulnerability um on the other hand in my

951
00:46:51,810 --> 00:46:57,150
point of view is more work to find

952
00:46:53,790 --> 00:46:59,790
because you have to first use different

953
00:46:57,150 --> 00:47:02,060
ways to find it and then the code

954
00:46:59,790 --> 00:47:03,779
involved is a lot more complex and

955
00:47:02,060 --> 00:47:07,740
understanding that there is a reference

956
00:47:03,780 --> 00:47:09,810
counting issue is also not that easy

957
00:47:07,740 --> 00:47:12,089
so my point of view the kernel bug was

958
00:47:09,810 --> 00:47:14,759
very easy to find the the user space a

959
00:47:12,090 --> 00:47:18,570
little bit harder but you must always

960
00:47:14,760 --> 00:47:21,300
remember as a defender that this kind of

961
00:47:18,570 --> 00:47:22,890
work is done by people every day there

962
00:47:21,300 --> 00:47:25,530
are people who do nothing else in the

963
00:47:22,890 --> 00:47:29,520
job then to reverse patches and write

964
00:47:25,530 --> 00:47:31,200
exploits for whatever they find so also

965
00:47:29,520 --> 00:47:34,860
you must understand when you look at a

966
00:47:31,200 --> 00:47:39,210
target the more often you look at the

967
00:47:34,860 --> 00:47:41,160
same target you already know how this

968
00:47:39,210 --> 00:47:43,950
works you know how the target works you

969
00:47:41,160 --> 00:47:46,440
know the code flow and then you can

970
00:47:43,950 --> 00:47:50,189
basically find the actual real cause way

971
00:47:46,440 --> 00:47:51,810
easier like maybe the kernel thing was

972
00:47:50,190 --> 00:47:54,180
so much easier for me because I always

973
00:47:51,810 --> 00:47:56,400
look at the kernel maybe someone who

974
00:47:54,180 --> 00:47:59,819
looks in these demons he immediately saw

975
00:47:56,400 --> 00:48:01,230
what the problem is so always keep in

976
00:47:59,820 --> 00:48:04,770
mind that there are people out there

977
00:48:01,230 --> 00:48:08,670
that actually get fully paid to just do

978
00:48:04,770 --> 00:48:11,400
what you do for fun yeah and I don't

979
00:48:08,670 --> 00:48:14,070
believe that you can stop attackers for

980
00:48:11,400 --> 00:48:16,940
long when you release the patches but

981
00:48:14,070 --> 00:48:21,810
don't do a write up for eight months

982
00:48:16,940 --> 00:48:23,480
everybody who needed to know this will

983
00:48:21,810 --> 00:48:27,180
have known about it for a long time

984
00:48:23,480 --> 00:48:29,430
basically when I released my my write up

985
00:48:27,180 --> 00:48:31,020
for the kernel part I got some direct

986
00:48:29,430 --> 00:48:33,390
messages on Twitter where people told me

987
00:48:31,020 --> 00:48:35,340
oh by the way the the userland path is

988
00:48:33,390 --> 00:48:37,589
in this demon if you won't just look

989
00:48:35,340 --> 00:48:39,660
into this and then it's a cop's right up

990
00:48:37,590 --> 00:48:41,820
came up a way later

991
00:48:39,660 --> 00:48:46,920
so people already knew about all of this

992
00:48:41,820 --> 00:48:48,870
very early after the patch so

993
00:48:46,920 --> 00:48:51,780
the other computer conclusion is that

994
00:48:48,870 --> 00:48:53,609
the action exploit writing was also in

995
00:48:51,780 --> 00:48:55,400
my point way easier for the kernel and

996
00:48:53,610 --> 00:48:58,400
further for the you delenn part

997
00:48:55,400 --> 00:49:00,900
especially in my point of view because

998
00:48:58,400 --> 00:49:03,540
there's a lot of source code when it

999
00:49:00,900 --> 00:49:06,810
comes to iOS exploitation for kernel

1000
00:49:03,540 --> 00:49:08,880
exploits and there's way less public

1001
00:49:06,810 --> 00:49:11,820
exploits when it comes to user land

1002
00:49:08,880 --> 00:49:14,400
exploits and so when it comes to kernel

1003
00:49:11,820 --> 00:49:16,710
pads you can often just copy and paste

1004
00:49:14,400 --> 00:49:18,900
stuff and when you look at public

1005
00:49:16,710 --> 00:49:21,570
jailbreaks you will actually see that

1006
00:49:18,900 --> 00:49:23,760
you can very often see code blocks that

1007
00:49:21,570 --> 00:49:26,430
are completely copied for example from

1008
00:49:23,760 --> 00:49:29,880
imba slides or so or from his pockets

1009
00:49:26,430 --> 00:49:33,870
floyd so those guys use a lot of

1010
00:49:29,880 --> 00:49:37,200
copypasta and that makes writing these

1011
00:49:33,870 --> 00:49:39,359
experts of course easier if there is

1012
00:49:37,200 --> 00:49:43,430
nothing to copy from like the user and

1013
00:49:39,360 --> 00:49:48,330
stuff then of course stuff gets harder

1014
00:49:43,430 --> 00:49:51,390
so so now the question is where is the

1015
00:49:48,330 --> 00:49:55,170
code well the code will be uploaded

1016
00:49:51,390 --> 00:49:58,560
within the next days on this github if I

1017
00:49:55,170 --> 00:50:03,660
haven't uploaded it in a week ping me

1018
00:49:58,560 --> 00:50:06,990
until I do it so the thing is I will

1019
00:50:03,660 --> 00:50:09,960
look at the google part and i will

1020
00:50:06,990 --> 00:50:12,870
likely rewrite a few things because the

1021
00:50:09,960 --> 00:50:15,600
google parts have way better explanation

1022
00:50:12,870 --> 00:50:18,120
of certain things and so i will likely

1023
00:50:15,600 --> 00:50:22,529
have a better exploit at the end of the

1024
00:50:18,120 --> 00:50:25,049
week so you can keep updated about the

1025
00:50:22,530 --> 00:50:28,410
release by looking at our twitter and

1026
00:50:25,050 --> 00:50:37,380
yeah if you want you can also sign up

1027
00:50:28,410 --> 00:50:38,670
for our trainings yes so any question we

1028
00:50:37,380 --> 00:50:45,120
have any questions from the floor to

1029
00:50:38,670 --> 00:50:46,530
start us off thanks for the talk this

1030
00:50:45,120 --> 00:50:49,200
isn't a technical question about the

1031
00:50:46,530 --> 00:50:50,730
vulnerability but you mentioned that due

1032
00:50:49,200 --> 00:50:52,680
to the fact that the service restarts

1033
00:50:50,730 --> 00:50:54,600
and it can be noisy during exploitation

1034
00:50:52,680 --> 00:50:57,180
yes you suggested that maybe google

1035
00:50:54,600 --> 00:50:58,509
could detect that these are iOS devices

1036
00:50:57,180 --> 00:51:00,060
so

1037
00:50:58,510 --> 00:51:03,580
or how do you think google detects that

1038
00:51:00,060 --> 00:51:07,029
well the thing is the thing is access to

1039
00:51:03,580 --> 00:51:09,700
the crash dumps is easily possible on

1040
00:51:07,030 --> 00:51:12,220
non jailbroken devices there's a legal

1041
00:51:09,700 --> 00:51:15,069
way for for example X code to get them

1042
00:51:12,220 --> 00:51:17,950
but there's like open source code that

1043
00:51:15,070 --> 00:51:19,420
will also pull them down so it's quite

1044
00:51:17,950 --> 00:51:21,970
easy to every time you connect your

1045
00:51:19,420 --> 00:51:23,590
device to a Mac or whatever you can down

1046
00:51:21,970 --> 00:51:25,270
download all of the crash times and then

1047
00:51:23,590 --> 00:51:25,800
you see that there is something going on

1048
00:51:25,270 --> 00:51:30,460
there

1049
00:51:25,800 --> 00:51:32,380
so of course if the attacker is smart

1050
00:51:30,460 --> 00:51:36,010
and they they succeed they can delete it

1051
00:51:32,380 --> 00:51:37,480
afterwards but yeah if you have a device

1052
00:51:36,010 --> 00:51:39,580
where the export may be failed and

1053
00:51:37,480 --> 00:51:43,660
suddenly you see there like hundreds of

1054
00:51:39,580 --> 00:51:44,590
crashed down from CF CF pre RFD then you

1055
00:51:43,660 --> 00:51:47,830
can see that there's something

1056
00:51:44,590 --> 00:51:50,020
apparently wrong in the area but as I

1057
00:51:47,830 --> 00:51:56,170
said I have not read the the blog post

1058
00:51:50,020 --> 00:51:59,920
maybe Google discloses what they did any

1059
00:51:56,170 --> 00:52:02,080
other questions in the room look I think

1060
00:51:59,920 --> 00:52:10,870
we I think we have some on the slide Oh

1061
00:52:02,080 --> 00:52:15,610
questions in that case oh just answer

1062
00:52:10,870 --> 00:52:18,640
the ones you would like to I wouldn't

1063
00:52:15,610 --> 00:52:20,560
call it the cage yeah but I but of

1064
00:52:18,640 --> 00:52:23,109
course but of course ever every every

1065
00:52:20,560 --> 00:52:26,049
iOS researcher keeps a few things

1066
00:52:23,110 --> 00:52:27,610
private because if they don't then

1067
00:52:26,050 --> 00:52:31,170
they're there possibility to research

1068
00:52:27,610 --> 00:52:34,870
goes away with the next thing yeah yeah

1069
00:52:31,170 --> 00:52:39,480
the next question I Can Has Jarek now No

1070
00:52:34,870 --> 00:52:39,480
[Laughter]

1071
00:52:42,920 --> 00:52:49,890
well that's the question you have to ask

1072
00:52:46,110 --> 00:52:52,700
Apple legal team I don't think that

1073
00:52:49,890 --> 00:52:56,160
these two things have anything in common

1074
00:52:52,700 --> 00:52:59,220
Apple has sued other companies before

1075
00:52:56,160 --> 00:53:02,220
who try to virtualize part of the Apple

1076
00:52:59,220 --> 00:53:03,750
ecosystem so it's just like normal that

1077
00:53:02,220 --> 00:53:06,240
they would go off the cranium after why

1078
00:53:03,750 --> 00:53:10,190
they have gone after companies that sell

1079
00:53:06,240 --> 00:53:14,450
hacking tortious and destroyed them so

1080
00:53:10,190 --> 00:53:14,450
you can get what happens to curry Liam

1081
00:53:16,220 --> 00:53:23,609
well it's these days a lot easier to get

1082
00:53:20,460 --> 00:53:26,160
into iOS research I believe and I'm not

1083
00:53:23,610 --> 00:53:30,240
teasing my my my trainings here there's

1084
00:53:26,160 --> 00:53:34,279
a lot of actual content that you can

1085
00:53:30,240 --> 00:53:37,200
find especially from Google project zero

1086
00:53:34,280 --> 00:53:39,240
or the members of Google project zero

1087
00:53:37,200 --> 00:53:41,759
for example I mentioned Brennan added

1088
00:53:39,240 --> 00:53:43,799
before before he worked at Google he had

1089
00:53:41,760 --> 00:53:46,200
like a tons and tons of blog post about

1090
00:53:43,800 --> 00:53:47,850
different things and I think this is

1091
00:53:46,200 --> 00:53:50,189
just like a starting point and then you

1092
00:53:47,850 --> 00:53:51,779
maybe find people referencing it and you

1093
00:53:50,190 --> 00:53:53,820
just Google for it and then you find a

1094
00:53:51,780 --> 00:53:56,520
lot of write-ups these days it's a lot

1095
00:53:53,820 --> 00:53:59,490
easier than a few years ago oh yeah and

1096
00:53:56,520 --> 00:54:10,890
don't buy the book hacking iOS that is

1097
00:53:59,490 --> 00:54:12,689
totally outdated well this is something

1098
00:54:10,890 --> 00:54:16,080
that will happen on all platforms only

1099
00:54:12,690 --> 00:54:18,240
in the Apple world there's always the

1100
00:54:16,080 --> 00:54:21,060
vendor increasing security and then

1101
00:54:18,240 --> 00:54:24,029
somewhere we're breaking it the the

1102
00:54:21,060 --> 00:54:26,040
thing I belief is and sometimes I'm

1103
00:54:24,030 --> 00:54:29,100
surprised we have not reached us yet is

1104
00:54:26,040 --> 00:54:32,130
that stuff web gets so hard and so

1105
00:54:29,100 --> 00:54:35,759
expensive to break that we will seen no

1106
00:54:32,130 --> 00:54:38,040
public jailbreak ever again but we are

1107
00:54:35,760 --> 00:54:42,000
not there yet off obviously but yes

1108
00:54:38,040 --> 00:54:45,640
Apple makes everything harder yeah

1109
00:54:42,000 --> 00:54:46,869
yeah this is just like yeah any more

1110
00:54:45,640 --> 00:54:56,170
questions from the fall before we wrap

1111
00:54:46,869 --> 00:54:59,589
up okay that question from from me about

1112
00:54:56,170 --> 00:55:02,799
the Apple million-dollar bug bounty will

1113
00:54:59,589 --> 00:55:06,849
you participate if so why

1114
00:55:02,799 --> 00:55:09,460
or if you won't why not well let's say

1115
00:55:06,849 --> 00:55:10,990
it like this I was one of the original

1116
00:55:09,460 --> 00:55:13,630
invited people and I have never sent

1117
00:55:10,990 --> 00:55:18,970
anything to Apple that they would pay

1118
00:55:13,630 --> 00:55:25,000
for so so far I have not participated in

1119
00:55:18,970 --> 00:55:28,390
it all so I'm signed up now they've

1120
00:55:25,000 --> 00:55:32,410
changed all the rules and we will see

1121
00:55:28,390 --> 00:55:34,240
maybe I sent them something the question

1122
00:55:32,410 --> 00:55:36,220
is always how good their payouts really

1123
00:55:34,240 --> 00:55:40,319
are because you must always see the

1124
00:55:36,220 --> 00:55:43,569
magic up too and knowing how Apple

1125
00:55:40,319 --> 00:55:45,220
worked on this in the past because I

1126
00:55:43,569 --> 00:55:47,980
have the background info from the from

1127
00:55:45,220 --> 00:55:50,379
the first bug bounty they had some

1128
00:55:47,980 --> 00:55:52,569
really strange rules how they set how

1129
00:55:50,380 --> 00:55:54,119
high certain payments are there was

1130
00:55:52,569 --> 00:55:57,940
never declawed disclosed to the public

1131
00:55:54,119 --> 00:56:00,400
so we will see how good their payouts

1132
00:55:57,940 --> 00:56:02,579
are and if they really pay out then why

1133
00:56:00,400 --> 00:56:02,579
not

1134
00:56:02,790 --> 00:56:07,120
okay okay good big big lanky just a fan

1135
00:56:05,799 --> 00:56:10,670
for the talking

1136
00:56:07,120 --> 00:56:10,670
[Applause]

