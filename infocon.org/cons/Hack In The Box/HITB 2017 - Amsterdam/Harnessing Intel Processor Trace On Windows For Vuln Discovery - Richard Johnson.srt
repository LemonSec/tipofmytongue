1
00:00:09,650 --> 00:00:13,650
hello everybody I'm rich

2
00:00:11,140 --> 00:00:16,619
<font color="#E5E5E5">Johnson and yes this talk today is</font>

3
00:00:13,650 --> 00:00:19,110
about a hardware platform feature on

4
00:00:16,619 --> 00:00:21,539
<font color="#E5E5E5">Intel processors called Intel processor</font>

5
00:00:19,110 --> 00:00:23,970
trace and we'll talk about the internals

6
00:00:21,539 --> 00:00:27,960
of how all that works and how to apply

7
00:00:23,970 --> 00:00:30,000
<font color="#E5E5E5">it to things like buzzing as Belinda</font>

8
00:00:27,960 --> 00:00:32,519
mentioned i am the research lead for

9
00:00:30,000 --> 00:00:36,210
<font color="#E5E5E5">cisco Talos we're a small dome dev team</font>

10
00:00:32,519 --> 00:00:38,640
and primarily focusing on finding bugs

11
00:00:36,210 --> 00:00:42,629
and doing technology innovations which

12
00:00:38,640 --> 00:00:43,949
is where I focus this<font color="#E5E5E5"> is my third or</font>

13
00:00:42,629 --> 00:00:47,519
fourth year speaking<font color="#E5E5E5"> at hack in the box</font>

14
00:00:43,949 --> 00:00:49,349
so it's great<font color="#E5E5E5"> to be</font><font color="#CCCCCC"> back I definitely do</font>

15
00:00:47,519 --> 00:00:52,170
want<font color="#E5E5E5"> to highlight that I have a research</font>

16
00:00:49,350 --> 00:00:54,180
partner<font color="#E5E5E5"> aundrea leaving who's done</font><font color="#CCCCCC"> a lot</font>

17
00:00:52,170 --> 00:00:55,920
<font color="#CCCCCC">of this work with me he's a great kernel</font>

18
00:00:54,180 --> 00:00:57,930
developer and helps with the

19
00:00:55,920 --> 00:00:59,549
<font color="#CCCCCC">implementation of</font><font color="#E5E5E5"> the driver we've given</font>

20
00:00:57,930 --> 00:01:04,290
this talk together previously but he

21
00:00:59,549 --> 00:01:06,330
couldn't be here today so basically my

22
00:01:04,290 --> 00:01:08,460
<font color="#E5E5E5">last few years of research have</font><font color="#CCCCCC"> been</font>

23
00:01:06,330 --> 00:01:10,500
around trying<font color="#CCCCCC"> to squeeze out as much</font>

24
00:01:08,460 --> 00:01:13,289
performance<font color="#CCCCCC"> as possible during the</font>

25
00:01:10,500 --> 00:01:15,299
fuzzing process and I've had a couple of

26
00:01:13,290 --> 00:01:18,540
previous talks that have gone into<font color="#E5E5E5"> the</font>

27
00:01:15,299 --> 00:01:20,310
directions of looking at various<font color="#E5E5E5"> ways of</font>

28
00:01:18,540 --> 00:01:23,250
tracing either using hardware features

29
00:01:20,310 --> 00:01:25,290
such as legacy<font color="#E5E5E5"> versions of what I'm</font>

30
00:01:23,250 --> 00:01:27,810
going<font color="#E5E5E5"> to talk about or using things like</font>

31
00:01:25,290 --> 00:01:29,659
dynamic binary instrumentation things

32
00:01:27,810 --> 00:01:33,180
like tin and dynamo Rio so you can hook

33
00:01:29,659 --> 00:01:35,430
applications as well as looking<font color="#E5E5E5"> at the</font>

34
00:01:33,180 --> 00:01:37,590
platforms and processes and everything

35
00:01:35,430 --> 00:01:39,330
<font color="#E5E5E5">from input selection to how to tune your</font>

36
00:01:37,590 --> 00:01:41,159
virtual<font color="#CCCCCC"> machine so that there are</font><font color="#E5E5E5"> the</font>

37
00:01:39,330 --> 00:01:43,890
higher highest performance available so

38
00:01:41,159 --> 00:01:46,140
<font color="#E5E5E5">if you're interested</font><font color="#CCCCCC"> in this topic these</font>

39
00:01:43,890 --> 00:01:48,659
slides previous talks are available out

40
00:01:46,140 --> 00:01:50,340
<font color="#E5E5E5">there on the internet my websites</font><font color="#CCCCCC"> low</font>

41
00:01:48,659 --> 00:01:54,060
<font color="#CCCCCC">flow org it'll be at the ends don't</font>

42
00:01:50,340 --> 00:01:57,810
worry and so this this research started

43
00:01:54,060 --> 00:01:59,040
<font color="#E5E5E5">just last year last fall and I'll tell</font>

44
00:01:57,810 --> 00:02:02,549
<font color="#CCCCCC">you</font><font color="#E5E5E5"> about the progression through that</font>

45
00:01:59,040 --> 00:02:04,020
and most importantly the driver's side

46
00:02:02,549 --> 00:02:06,450
<font color="#E5E5E5">of</font><font color="#CCCCCC"> what I'm talking about today</font><font color="#E5E5E5"> is</font>

47
00:02:04,020 --> 00:02:08,699
available so the tracing engine that

48
00:02:06,450 --> 00:02:10,530
powers all of this research is already

49
00:02:08,699 --> 00:02:14,730
available to<font color="#E5E5E5"> available it's right now on</font>

50
00:02:10,530 --> 00:02:17,099
github / Intel PT and actually the code

51
00:02:14,730 --> 00:02:19,319
<font color="#CCCCCC">that I'm using for the fuzzing side will</font>

52
00:02:17,099 --> 00:02:21,480
also be released if not this week then

53
00:02:19,319 --> 00:02:22,899
next week everything is going to be open

54
00:02:21,480 --> 00:02:25,369
source here

55
00:02:22,900 --> 00:02:28,040
so<font color="#E5E5E5"> basically our agenda will be an</font>

56
00:02:25,370 --> 00:02:30,800
overview of Intel PT talk about the

57
00:02:28,040 --> 00:02:32,929
internals of the driver implementation a

58
00:02:30,800 --> 00:02:35,480
little bit so we're going to get<font color="#E5E5E5"> into</font>

59
00:02:32,930 --> 00:02:37,970
some windows kernel programming stuff

60
00:02:35,480 --> 00:02:39,560
for a little while and then<font color="#CCCCCC"> there'll be</font>

61
00:02:37,970 --> 00:02:43,070
a whole bunch<font color="#E5E5E5"> of demos we've got an Ida</font>

62
00:02:39,560 --> 00:02:45,860
<font color="#E5E5E5">plug-in and various demos to show you</font>

63
00:02:43,070 --> 00:02:47,480
how to<font color="#CCCCCC"> use this and so on before I get</font>

64
00:02:45,860 --> 00:02:49,610
<font color="#E5E5E5">started just to get a pulse of the room</font>

65
00:02:47,480 --> 00:02:52,160
I couldn't get a raise of hands who's

66
00:02:49,610 --> 00:02:54,290
done buzzing or actively does buzzing

67
00:02:52,160 --> 00:02:56,840
<font color="#E5E5E5">knows a little bit about buzzing okay</font>

68
00:02:54,290 --> 00:02:59,810
good and then how many<font color="#E5E5E5"> people here have</font>

69
00:02:56,840 --> 00:03:03,070
done driver developments on the Windows

70
00:02:59,810 --> 00:03:05,990
platform or anything along those lines

71
00:03:03,070 --> 00:03:08,390
ok so the fuzzing stuff is the second

72
00:03:05,990 --> 00:03:10,100
half I apologize if it gets a little

73
00:03:08,390 --> 00:03:11,929
dents in the first part where<font color="#CCCCCC"> we</font><font color="#E5E5E5"> talk</font>

74
00:03:10,100 --> 00:03:15,710
<font color="#E5E5E5">about the driver but there will</font><font color="#CCCCCC"> be a</font>

75
00:03:11,930 --> 00:03:17,630
good payoff<font color="#CCCCCC"> an end no spoilers but this</font>

76
00:03:15,710 --> 00:03:21,290
is the fastest engine for doing<font color="#CCCCCC"> andros</font>

77
00:03:17,630 --> 00:03:23,420
buzzing so so<font color="#E5E5E5"> Intel processor trace what</font>

78
00:03:21,290 --> 00:03:25,790
is it well it's a low overhead hardware

79
00:03:23,420 --> 00:03:28,519
execution tracer it's built into the

80
00:03:25,790 --> 00:03:33,590
silicon of Intel processors going from

81
00:03:28,520 --> 00:03:35,660
Sky lake forward specifically<font color="#CCCCCC"> Broadwell</font>

82
00:03:33,590 --> 00:03:37,970
forward but<font color="#CCCCCC"> skylake is the architecture</font>

83
00:03:35,660 --> 00:03:41,180
where it's fully baked<font color="#CCCCCC"> broadwell had a</font>

84
00:03:37,970 --> 00:03:43,940
limited feature set and basically what

85
00:03:41,180 --> 00:03:47,120
happens is each core and including hyper

86
00:03:43,940 --> 00:03:49,280
threaded cores in your processor have a

87
00:03:47,120 --> 00:03:51,230
mechanism in which when the instruction

88
00:03:49,280 --> 00:03:54,260
decoder encounters a branch instruction

89
00:03:51,230 --> 00:03:57,109
it goes off and if<font color="#E5E5E5"> you have checks a</font>

90
00:03:54,260 --> 00:03:59,720
register and the<font color="#E5E5E5"> CPU that you can set</font>

91
00:03:57,110 --> 00:04:01,700
from privileged mode and it says okay

92
00:03:59,720 --> 00:04:03,560
are we<font color="#E5E5E5"> especially handling branches and</font>

93
00:04:01,700 --> 00:04:06,589
if so how do you want to<font color="#E5E5E5"> handle them and</font>

94
00:04:03,560 --> 00:04:08,959
the processor tray subsystem is how<font color="#CCCCCC"> that</font>

95
00:04:06,590 --> 00:04:09,980
all happens inside your CPU there's

96
00:04:08,959 --> 00:04:12,140
something called a performance

97
00:04:09,980 --> 00:04:13,760
monitoring<font color="#E5E5E5"> unit you know similar just</font>

98
00:04:12,140 --> 00:04:15,829
<font color="#E5E5E5">like there is an ALU that does your</font>

99
00:04:13,760 --> 00:04:17,409
arithmetic well there's a PM you that

100
00:04:15,830 --> 00:04:20,600
does your performance monitoring and

101
00:04:17,410 --> 00:04:23,870
most commonly this is something<font color="#CCCCCC"> that you</font>

102
00:04:20,600 --> 00:04:25,260
might see that will tell you like things

103
00:04:23,870 --> 00:04:27,510
like branch misses

104
00:04:25,260 --> 00:04:29,400
or how your<font color="#E5E5E5"> cpu's utilizing your cash</font>

105
00:04:27,510 --> 00:04:32,190
simple counters that you can<font color="#E5E5E5"> utilize</font>

106
00:04:29,400 --> 00:04:34,310
well there's a whole lot more in there

107
00:04:32,190 --> 00:04:36,570
as<font color="#CCCCCC"> well that aren't is commonly used</font>

108
00:04:34,310 --> 00:04:38,250
there's some legacy systems like i

109
00:04:36,570 --> 00:04:41,550
mentioned called like branch try store

110
00:04:38,250 --> 00:04:42,630
and other things and so the important

111
00:04:41,550 --> 00:04:44,970
thing<font color="#CCCCCC"> to know is that this is just</font>

112
00:04:42,630 --> 00:04:46,680
<font color="#E5E5E5">inside your processor and you configure</font>

113
00:04:44,970 --> 00:04:51,240
your processor in a specific way to turn

114
00:04:46,680 --> 00:04:54,060
<font color="#E5E5E5">it on the properties of the trace and</font>

115
00:04:51,240 --> 00:04:57,120
this iteration of them giving you branch

116
00:04:54,060 --> 00:04:58,920
tracing are finely tuned for perform<font color="#CCCCCC"> too</font>

117
00:04:57,120 --> 00:05:01,940
<font color="#E5E5E5">for performance so it doesn't</font><font color="#CCCCCC"> have an</font>

118
00:04:58,920 --> 00:05:04,800
impact<font color="#E5E5E5"> on your CPU cache and so it's</font>

119
00:05:01,940 --> 00:05:08,090
<font color="#CCCCCC">very performance in the log that outputs</font>

120
00:05:04,800 --> 00:05:11,550
is very small so it has<font color="#CCCCCC"> a small space</font>

121
00:05:08,090 --> 00:05:12,989
requirement as well so of<font color="#E5E5E5"> course we're</font>

122
00:05:11,550 --> 00:05:14,730
<font color="#CCCCCC">talking about branch tracings so what do</font>

123
00:05:12,990 --> 00:05:18,570
we<font color="#E5E5E5"> use this for obviously code coverage</font>

124
00:05:14,730 --> 00:05:20,550
is the main focus<font color="#E5E5E5"> here for fuzzing and</font>

125
00:05:18,570 --> 00:05:22,830
then also it can be used in malware

126
00:05:20,550 --> 00:05:24,810
<font color="#E5E5E5">analysis and other sorts of things where</font>

127
00:05:22,830 --> 00:05:27,210
you need to<font color="#CCCCCC"> recover where your execution</font>

128
00:05:24,810 --> 00:05:31,080
went on the logic<font color="#CCCCCC"> that have followed in</font>

129
00:05:27,210 --> 00:05:32,640
the program so in order to detect if

130
00:05:31,080 --> 00:05:34,740
your processor supports intel PT

131
00:05:32,640 --> 00:05:36,780
programmatically because you know you

132
00:05:34,740 --> 00:05:39,540
can't<font color="#E5E5E5"> just trust a guy like label or</font>

133
00:05:36,780 --> 00:05:41,789
something you use the instruction cpuid

134
00:05:39,540 --> 00:05:44,730
and cpuid tells you you know

135
00:05:41,790 --> 00:05:48,090
specifically what model of secure your

136
00:05:44,730 --> 00:05:50,490
running and an MSR is a model specific

137
00:05:48,090 --> 00:05:53,849
register so each version of the

138
00:05:50,490 --> 00:05:55,650
architecture has different sub features

139
00:05:53,850 --> 00:05:58,680
that are accessible from<font color="#E5E5E5"> kernel mode or</font>

140
00:05:55,650 --> 00:06:00,989
hypervisors to configure the processor

141
00:05:58,680 --> 00:06:02,880
running in different ways the most the

142
00:06:00,990 --> 00:06:04,290
old common one that you may<font color="#CCCCCC"> have heard</font>

143
00:06:02,880 --> 00:06:06,600
of<font color="#E5E5E5"> is you know the switch from real mode</font>

144
00:06:04,290 --> 00:06:09,300
to protected mode is one type of

145
00:06:06,600 --> 00:06:11,220
<font color="#E5E5E5">operating pursuit mode you know there's</font>

146
00:06:09,300 --> 00:06:13,260
a vmx mode now when you have hypervisors

147
00:06:11,220 --> 00:06:15,480
and so on<font color="#E5E5E5"> so this</font><font color="#CCCCCC"> is in a similar vein</font>

148
00:06:13,260 --> 00:06:20,039
where<font color="#CCCCCC"> you're</font><font color="#E5E5E5"> specially telling your</font><font color="#CCCCCC"> CPU</font>

149
00:06:15,480 --> 00:06:21,000
to enter a special mode and one part

150
00:06:20,040 --> 00:06:22,380
that's exciting about this one of the

151
00:06:21,000 --> 00:06:24,810
reasons that<font color="#E5E5E5"> I took up the effort</font><font color="#CCCCCC"> to</font>

152
00:06:22,380 --> 00:06:27,360
<font color="#E5E5E5">work on this was that there isn't an</font>

153
00:06:24,810 --> 00:06:29,370
available engine for utilizing this on

154
00:06:27,360 --> 00:06:31,080
the<font color="#E5E5E5"> Windows platform it is inside the</font>

155
00:06:29,370 --> 00:06:34,960
windows current on the<font color="#E5E5E5"> Linux kernel side</font>

156
00:06:31,080 --> 00:06:37,300
I was like 4.3 if you

157
00:06:34,960 --> 00:06:38,409
compiling some special extensions but on

158
00:06:37,300 --> 00:06:40,630
the window side there really wasn't

159
00:06:38,410 --> 00:06:43,930
anything available there is an Intel

160
00:06:40,630 --> 00:06:46,539
system studio but they have a window bug

161
00:06:43,930 --> 00:06:48,699
KD plugin for the kernel debugger that

162
00:06:46,539 --> 00:06:50,560
will set these<font color="#CCCCCC"> msrs for you but the way</font>

163
00:06:48,699 --> 00:06:53,740
<font color="#E5E5E5">that it's set up is really meant to be a</font>

164
00:06:50,560 --> 00:06:55,449
<font color="#CCCCCC">master-slave debugging scenario and not</font>

165
00:06:53,740 --> 00:06:58,229
really<font color="#E5E5E5"> useful for fully automated</font>

166
00:06:55,449 --> 00:07:00,910
<font color="#CCCCCC">backend engines for unmonitored</font>

167
00:06:58,229 --> 00:07:02,680
execution training so that was kind of

168
00:07:00,910 --> 00:07:04,479
the motivation here and then timing-wise

169
00:07:02,680 --> 00:07:06,699
<font color="#E5E5E5">I've been aiming for getting it done</font>

170
00:07:04,479 --> 00:07:08,560
<font color="#CCCCCC">right about now because the Xeon CPUs</font>

171
00:07:06,699 --> 00:07:10,690
are switching to the sky<font color="#E5E5E5"> like</font>

172
00:07:08,560 --> 00:07:12,120
architecture this year and so<font color="#E5E5E5"> now when</font>

173
00:07:10,690 --> 00:07:15,039
you go out and you buy hardware to do

174
00:07:12,120 --> 00:07:17,770
<font color="#E5E5E5">malware analysis or fuzzing at scale you</font>

175
00:07:15,039 --> 00:07:20,889
<font color="#CCCCCC">can use my software and use this right</font>

176
00:07:17,770 --> 00:07:22,630
away so so anyways as I mentioned you

177
00:07:20,889 --> 00:07:25,449
see PID it looks something<font color="#E5E5E5"> like this</font>

178
00:07:22,630 --> 00:07:27,430
this isn't too<font color="#E5E5E5"> important but the point</font>

179
00:07:25,449 --> 00:07:28,720
is it's pretty simple once you know that

180
00:07:27,430 --> 00:07:31,030
you have the right processor you can

181
00:07:28,720 --> 00:07:32,830
Clary which sub features of<font color="#CCCCCC"> Intel</font>

182
00:07:31,030 --> 00:07:36,008
processor traits are available because

183
00:07:32,830 --> 00:07:38,020
<font color="#E5E5E5">there's a bunch of them essentially you</font>

184
00:07:36,009 --> 00:07:39,849
<font color="#CCCCCC">can trace either user mode or kernel</font>

185
00:07:38,020 --> 00:07:42,669
mode you can<font color="#E5E5E5"> filter on a specific</font>

186
00:07:39,849 --> 00:07:46,120
process of using the CR<font color="#E5E5E5"> 3 which is your</font>

187
00:07:42,669 --> 00:07:48,609
page table pointer you<font color="#CCCCCC"> can tell it that</font>

188
00:07:46,120 --> 00:07:50,919
you want<font color="#CCCCCC"> to reserve a range of physical</font>

189
00:07:48,610 --> 00:07:53,349
<font color="#E5E5E5">RAM that you want it to do like a ring</font>

190
00:07:50,919 --> 00:07:55,030
buffer right out to or you can tell it

191
00:07:53,349 --> 00:07:57,940
hey you know I've actually created a set

192
00:07:55,030 --> 00:07:59,919
of page tables for you so I can grow and

193
00:07:57,940 --> 00:08:03,039
still only manage physical memory myself

194
00:07:59,919 --> 00:08:04,599
so on so again there's a bunch of

195
00:08:03,039 --> 00:08:06,550
configurations this is a whole new

196
00:08:04,599 --> 00:08:08,979
chapter in the intel architecture manual

197
00:08:06,550 --> 00:08:10,930
actually chapter 36 it's about<font color="#CCCCCC"> 100 pages</font>

198
00:08:08,979 --> 00:08:12,969
<font color="#E5E5E5">and it covers all the sub features</font>

199
00:08:10,930 --> 00:08:14,380
available in<font color="#E5E5E5"> intel processor</font><font color="#CCCCCC"> trace and</font><font color="#E5E5E5"> i</font>

200
00:08:12,969 --> 00:08:16,330
totally stumbled across this by accident

201
00:08:14,380 --> 00:08:19,060
but it's hard to miss a whole new

202
00:08:16,330 --> 00:08:22,120
chapter and the manual when it's on a

203
00:08:19,060 --> 00:08:25,030
topic that you're interested<font color="#E5E5E5"> so you can</font>

204
00:08:22,120 --> 00:08:27,639
do<font color="#CCCCCC"> all sorts of things like you</font><font color="#E5E5E5"> know put</font>

205
00:08:25,030 --> 00:08:29,169
out precise timing information if<font color="#E5E5E5"> you</font>

206
00:08:27,639 --> 00:08:31,750
need to synchronize these or if you need

207
00:08:29,169 --> 00:08:34,718
to pull out you know if you're utilizing

208
00:08:31,750 --> 00:08:36,909
multiple cores then each of<font color="#CCCCCC"> those logs</font>

209
00:08:34,719 --> 00:08:39,070
are written separately by each core and

210
00:08:36,909 --> 00:08:41,039
you might<font color="#E5E5E5"> have to synchronize them and</font>

211
00:08:39,070 --> 00:08:43,060
so on<font color="#E5E5E5"> and so on I think I have a</font>

212
00:08:41,039 --> 00:08:45,069
graphical version of this in a second

213
00:08:43,059 --> 00:08:45,649
but the reason<font color="#E5E5E5"> that we're interested in</font>

214
00:08:45,070 --> 00:08:47,959
this for code

215
00:08:45,649 --> 00:08:50,449
coverage is number one you know we can

216
00:08:47,959 --> 00:08:52,160
trace native binaries so that's

217
00:08:50,449 --> 00:08:55,399
important we don't<font color="#CCCCCC"> need source code to</font>

218
00:08:52,160 --> 00:08:57,019
to add tracing logic to its implemented

219
00:08:55,399 --> 00:08:59,329
in hardware so it's number one it's

220
00:08:57,019 --> 00:09:01,220
reliable you don't have to do any sort

221
00:08:59,329 --> 00:09:02,719
<font color="#E5E5E5">of graph recovery to do instrumentation</font>

222
00:09:01,220 --> 00:09:06,499
or anything related to the<font color="#E5E5E5"> software at</font>

223
00:09:02,720 --> 00:09:10,249
all it runs<font color="#CCCCCC"> like I mentioned in kernel</font>

224
00:09:06,499 --> 00:09:12,769
and user it runs in<font color="#E5E5E5"> vmx mode it's</font>

225
00:09:10,249 --> 00:09:15,589
<font color="#E5E5E5">available in VI next mode no hypervisors</font>

226
00:09:12,769 --> 00:09:18,050
actually expose this feature yet but

227
00:09:15,589 --> 00:09:20,029
we're working on<font color="#CCCCCC"> that as of last week it</font>

228
00:09:18,050 --> 00:09:22,969
works but most importantly the

229
00:09:20,029 --> 00:09:24,769
performance is really good so the

230
00:09:22,970 --> 00:09:27,499
overheads that you see with this is

231
00:09:24,769 --> 00:09:29,899
fifteen percent to cover everything

232
00:09:27,499 --> 00:09:31,850
going on your<font color="#E5E5E5"> system so system-wide</font>

233
00:09:29,899 --> 00:09:34,240
branch tracing for fifteen percent

234
00:09:31,850 --> 00:09:37,089
overhead is more or less unheard of

235
00:09:34,240 --> 00:09:40,189
unless you're able<font color="#E5E5E5"> to do direct source</font>

236
00:09:37,089 --> 00:09:42,740
instrumentation<font color="#E5E5E5"> and it logs to physical</font>

237
00:09:40,189 --> 00:09:45,079
ram instead of two instead<font color="#CCCCCC"> of</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> giving</font>

238
00:09:42,740 --> 00:09:46,670
it a user space allocated buffer the

239
00:09:45,079 --> 00:09:48,229
demure<font color="#E5E5E5"> colonel passes down and then</font>

240
00:09:46,670 --> 00:09:51,469
there's address translation that has to

241
00:09:48,230 --> 00:09:54,949
occur<font color="#E5E5E5"> to write in that buffer for you if</font>

242
00:09:51,470 --> 00:09:56,420
the implementation takes the virtual

243
00:09:54,949 --> 00:09:58,219
memory addresses to write that buffer

244
00:09:56,420 --> 00:10:00,740
well that means<font color="#E5E5E5"> that every single branch</font>

245
00:09:58,220 --> 00:10:02,329
is going to have to do a lookup in from

246
00:10:00,740 --> 00:10:04,429
the physical range that its operating on

247
00:10:02,329 --> 00:10:07,248
in the<font color="#CCCCCC"> CPU to what that virtual address</font>

248
00:10:04,429 --> 00:10:09,499
is and that pollutes your cash that does

249
00:10:07,249 --> 00:10:11,629
that translation normally so when you're

250
00:10:09,499 --> 00:10:14,120
executing code or referencing normal

251
00:10:11,629 --> 00:10:16,429
data and that's in the course of running

252
00:10:14,120 --> 00:10:18,050
a program normally you want you know the

253
00:10:16,429 --> 00:10:19,279
most recent code to<font color="#CCCCCC"> be in your cash and</font>

254
00:10:18,050 --> 00:10:21,319
the<font color="#E5E5E5"> most recent data to be inter cash</font>

255
00:10:19,279 --> 00:10:23,300
but if every branch you have to go out

256
00:10:21,319 --> 00:10:25,219
<font color="#CCCCCC">and write out to a buffer well that's</font>

257
00:10:23,300 --> 00:10:28,790
<font color="#CCCCCC">going to pollute your translation</font>

258
00:10:25,220 --> 00:10:31,790
buffers and it will flush so by making

259
00:10:28,790 --> 00:10:33,769
the consumer of this tracing engine like

260
00:10:31,790 --> 00:10:35,990
us who wrote the driver have to handle

261
00:10:33,769 --> 00:10:38,240
<font color="#E5E5E5">all the memory management ourselves it</font>

262
00:10:35,990 --> 00:10:39,860
can<font color="#E5E5E5"> just say hey I expect some physical</font>

263
00:10:38,240 --> 00:10:41,509
<font color="#E5E5E5">RAM and it's up to</font><font color="#CCCCCC"> you to figure out it</font>

264
00:10:39,860 --> 00:10:43,549
do it and since you're giving me

265
00:10:41,509 --> 00:10:45,439
physical ranges that<font color="#CCCCCC"> means</font><font color="#E5E5E5"> that you're</font>

266
00:10:43,549 --> 00:10:47,720
<font color="#E5E5E5">ensuring that the OS isn't going to</font>

267
00:10:45,439 --> 00:10:49,248
stomp all over it<font color="#CCCCCC"> or whatever</font><font color="#E5E5E5"> and we</font>

268
00:10:47,720 --> 00:10:52,549
don't<font color="#E5E5E5"> have to do any cash pollution so</font>

269
00:10:49,249 --> 00:10:54,769
it incurs a bigger cost upfront to get

270
00:10:52,549 --> 00:10:55,300
everything configured but at runtime is

271
00:10:54,769 --> 00:11:00,070
very<font color="#E5E5E5"> very</font>

272
00:10:55,300 --> 00:11:02,800
and then another<font color="#E5E5E5"> annoyance and utilizing</font>

273
00:11:00,070 --> 00:11:04,660
it is that the recording format is so

274
00:11:02,800 --> 00:11:08,620
sparse that only records 1 bit per

275
00:11:04,660 --> 00:11:10,510
conditional branch and it records you

276
00:11:08,620 --> 00:11:13,329
<font color="#E5E5E5">know long branch target so if you have a</font>

277
00:11:10,510 --> 00:11:14,709
far call or or something like that then

278
00:11:13,329 --> 00:11:16,630
<font color="#E5E5E5">then you'll have some of the actual</font>

279
00:11:14,709 --> 00:11:19,810
<font color="#E5E5E5">address in there but otherwise you have</font>

280
00:11:16,630 --> 00:11:22,600
to do an online disassembly to determine

281
00:11:19,810 --> 00:11:24,459
where those branches are going so again

282
00:11:22,600 --> 00:11:27,640
on the implementation start site it's

283
00:11:24,459 --> 00:11:28,779
kind of<font color="#CCCCCC"> a difficult thing to do but at</font>

284
00:11:27,640 --> 00:11:31,689
the end<font color="#E5E5E5"> of the day once you get it all</font>

285
00:11:28,779 --> 00:11:35,130
configured you can operate in different

286
00:11:31,690 --> 00:11:37,899
modes of filtering so like I mentioned

287
00:11:35,130 --> 00:11:41,170
either all of user mode or all of kernel

288
00:11:37,899 --> 00:11:44,260
mode or specifically you can trace a

289
00:11:41,170 --> 00:11:48,430
single process using the<font color="#CCCCCC"> pml</font><font color="#E5E5E5"> for page</font>

290
00:11:44,260 --> 00:11:50,140
table which is kind of in x64 it's

291
00:11:48,430 --> 00:11:54,130
another<font color="#E5E5E5"> reach to your page table</font>

292
00:11:50,140 --> 00:11:57,490
partitions or you can specify up to four

293
00:11:54,130 --> 00:11:59,470
ranges of instruction pointer addresses

294
00:11:57,490 --> 00:12:02,200
so you can say I'm interested<font color="#CCCCCC"> in this</font>

295
00:11:59,470 --> 00:12:03,610
module that's mapped into memory you

296
00:12:02,200 --> 00:12:05,470
<font color="#E5E5E5">know this maybe I'm interested in these</font>

297
00:12:03,610 --> 00:12:07,000
couple of modules or I'm interested<font color="#CCCCCC"> in</font>

298
00:12:05,470 --> 00:12:09,250
this kernel driver and also the user

299
00:12:07,000 --> 00:12:11,079
mode application that interfacing with

300
00:12:09,250 --> 00:12:15,010
it and so on so<font color="#E5E5E5"> it has some pretty cool</font>

301
00:12:11,079 --> 00:12:16,120
<font color="#E5E5E5">configurations I've added</font><font color="#CCCCCC"> some stuff</font><font color="#E5E5E5"> to</font>

302
00:12:15,010 --> 00:12:18,640
this<font color="#E5E5E5"> talk so some of these</font>

303
00:12:16,120 --> 00:12:20,500
implementation details around how to<font color="#E5E5E5"> set</font>

304
00:12:18,640 --> 00:12:21,939
<font color="#CCCCCC">up</font><font color="#E5E5E5"> the memory since we don't have too</font>

305
00:12:20,500 --> 00:12:23,860
many colonel programmers here all kind

306
00:12:21,940 --> 00:12:25,899
of gloss over<font color="#E5E5E5"> I got a brand new feature</font>

307
00:12:23,860 --> 00:12:29,079
<font color="#E5E5E5">working as of today that's pretty killer</font>

308
00:12:25,899 --> 00:12:30,370
so but in kernel space if you want to

309
00:12:29,079 --> 00:12:32,439
<font color="#E5E5E5">Alec if you want to use</font><font color="#CCCCCC"> it in the</font>

310
00:12:30,370 --> 00:12:34,270
simplest mode and in fact on<font color="#E5E5E5"> the Linux</font>

311
00:12:32,440 --> 00:12:36,910
kernel they have an option to always

312
00:12:34,270 --> 00:12:39,160
have it on and to always be writing<font color="#CCCCCC"> to a</font>

313
00:12:36,910 --> 00:12:40,990
ring buffer so if you end up with<font color="#E5E5E5"> a</font>

314
00:12:39,160 --> 00:12:42,790
kernel crash you have that available and

315
00:12:40,990 --> 00:12:44,860
it will dump it out so one way<font color="#E5E5E5"> to do</font>

316
00:12:42,790 --> 00:12:47,319
that<font color="#CCCCCC"> is to reserve a range of physical</font>

317
00:12:44,860 --> 00:12:49,120
RAM when the colonel<font color="#CCCCCC"> is a place is</font>

318
00:12:47,320 --> 00:12:51,310
booting before your physical memory gets

319
00:12:49,120 --> 00:12:52,959
fragmented and in on the windows side

320
00:12:51,310 --> 00:12:55,300
you can do that<font color="#CCCCCC"> through allocate</font>

321
00:12:52,959 --> 00:12:56,890
contiguous memory our driver happens to

322
00:12:55,300 --> 00:12:59,740
implement all<font color="#CCCCCC"> the features available at</font>

323
00:12:56,890 --> 00:13:01,689
this point so you can use our drivers

324
00:12:59,740 --> 00:13:07,029
reference kind<font color="#E5E5E5"> of on the internals of</font>

325
00:13:01,690 --> 00:13:08,290
how this all works as well the table<font color="#E5E5E5"> of</font>

326
00:13:07,029 --> 00:13:10,870
physical addresses

327
00:13:08,290 --> 00:13:14,439
is an option for configuring it and

328
00:13:10,870 --> 00:13:16,269
fortunately it ends up using the same

329
00:13:14,440 --> 00:13:19,420
structures that are necessary on Windows

330
00:13:16,269 --> 00:13:21,100
to set up the memory descriptor lists

331
00:13:19,420 --> 00:13:23,589
that it uses for virtual memory

332
00:13:21,100 --> 00:13:26,680
addressing so it<font color="#E5E5E5"> turns out to</font><font color="#CCCCCC"> be fairly</font>

333
00:13:23,589 --> 00:13:28,060
easy until made it as easy as possible

334
00:13:26,680 --> 00:13:30,370
knowing<font color="#CCCCCC"> that we're gonna have to do all</font>

335
00:13:28,060 --> 00:13:33,279
this work and<font color="#CCCCCC"> this is the mode that</font><font color="#E5E5E5"> we</font>

336
00:13:30,370 --> 00:13:36,069
generally operated there's a smaller or

337
00:13:33,279 --> 00:13:38,610
there is a small<font color="#E5E5E5"> runtime hits because it</font>

338
00:13:36,069 --> 00:13:40,889
has to do page table walks obviously but

339
00:13:38,610 --> 00:13:43,660
at the end of the day you can<font color="#E5E5E5"> make your</font>

340
00:13:40,889 --> 00:13:47,769
<font color="#E5E5E5">logs as large as you want them it was</font>

341
00:13:43,660 --> 00:13:48,939
much virtual memory as<font color="#CCCCCC"> you need and then</font>

342
00:13:47,769 --> 00:13:50,649
of course<font color="#CCCCCC"> we get interrupts whenever</font>

343
00:13:48,940 --> 00:13:53,680
that's full and it lets us dump in parts

344
00:13:50,649 --> 00:13:55,389
everything<font color="#E5E5E5"> so the packets of interests</font>

345
00:13:53,680 --> 00:13:59,170
are I'll just give you the visual

346
00:13:55,389 --> 00:14:01,540
version on the the green ones<font color="#E5E5E5"> are the</font>

347
00:13:59,170 --> 00:14:03,339
taken not taken and<font color="#CCCCCC"> taken IP</font><font color="#E5E5E5"> address so</font>

348
00:14:01,540 --> 00:14:04,420
these<font color="#E5E5E5"> are your branch targets or whether</font>

349
00:14:03,339 --> 00:14:12,360
or not your conditional branches were

350
00:14:04,420 --> 00:14:15,219
taken the<font color="#CCCCCC"> f updates is the prime</font><font color="#E5E5E5"> updates</font>

351
00:14:12,360 --> 00:14:18,459
then paging in packets so that's

352
00:14:15,220 --> 00:14:21,250
important if you're tracing multiple

353
00:14:18,459 --> 00:14:23,138
user processes and you want to know<font color="#E5E5E5"> when</font>

354
00:14:21,250 --> 00:14:26,560
a certain<font color="#E5E5E5"> process gets paged in and is</font>

355
00:14:23,139 --> 00:14:28,899
activated<font color="#E5E5E5"> and so on if you're in ring</font>

356
00:14:26,560 --> 00:14:32,439
<font color="#E5E5E5">three mode or ring 0 and then theres</font>

357
00:14:28,899 --> 00:14:34,410
some timing stuff as well and then the

358
00:14:32,440 --> 00:14:36,100
trace the<font color="#E5E5E5"> PSB</font><font color="#CCCCCC"> and oviya those are</font>

359
00:14:34,410 --> 00:14:39,969
synchronization packets that are in

360
00:14:36,100 --> 00:14:44,050
there so allows you to seek ahead so for

361
00:14:39,970 --> 00:14:46,930
our driver we've released a number of

362
00:14:44,050 --> 00:14:50,500
versions over the<font color="#E5E5E5"> last almost year I</font>

363
00:14:46,930 --> 00:14:52,870
guess since actually only since may be

364
00:14:50,500 --> 00:14:54,850
almost a year and at this point in our

365
00:14:52,870 --> 00:14:57,279
first version it only you know supported

366
00:14:54,850 --> 00:14:59,620
the single buffer it was really<font color="#CCCCCC"> weak but</font>

367
00:14:57,279 --> 00:15:02,050
right now it's fully fully working fully

368
00:14:59,620 --> 00:15:05,259
baked pretty much<font color="#CCCCCC"> we run</font><font color="#E5E5E5"> version 5 or</font>

369
00:15:02,050 --> 00:15:07,540
0.5 but there isn't really anything left

370
00:15:05,259 --> 00:15:10,439
to implement right now other than<font color="#CCCCCC"> some</font>

371
00:15:07,540 --> 00:15:12,849
testing and<font color="#CCCCCC"> we support multiprocessors</font>

372
00:15:10,439 --> 00:15:16,150
<font color="#E5E5E5">all the filtering modes and output modes</font>

373
00:15:12,850 --> 00:15:17,850
and in the last two months<font color="#E5E5E5"> the thing</font>

374
00:15:16,150 --> 00:15:21,189
that we've added<font color="#CCCCCC"> are the kernel mode</font>

375
00:15:17,850 --> 00:15:22,660
tracing and also you can utilize this

376
00:15:21,190 --> 00:15:25,120
from another driver in kernel mode as

377
00:15:22,660 --> 00:15:27,370
<font color="#CCCCCC">well so</font><font color="#E5E5E5"> I have a user mode library that</font>

378
00:15:25,120 --> 00:15:30,880
I use to interact with<font color="#E5E5E5"> it with our</font>

379
00:15:27,370 --> 00:15:33,190
driver via I<font color="#E5E5E5"> octal and</font><font color="#CCCCCC"> then now there's</font>

380
00:15:30,880 --> 00:15:36,910
also an API exposed from the kernel side

381
00:15:33,190 --> 00:15:39,430
to utilize it as well and then there was

382
00:15:36,910 --> 00:15:42,819
some low lower<font color="#E5E5E5"> level stuff that we had</font>

383
00:15:39,430 --> 00:15:46,239
to manage along the lines of how to map

384
00:15:42,820 --> 00:15:48,280
those buffers and the apex program

385
00:15:46,240 --> 00:15:50,190
programming which is how<font color="#E5E5E5"> all the</font>

386
00:15:48,280 --> 00:15:56,860
interrupts are handled outside your<font color="#E5E5E5"> CPU</font>

387
00:15:50,190 --> 00:16:00,150
and so on so the performance monitoring

388
00:15:56,860 --> 00:16:02,770
interrupt is a special interrupts and in

389
00:16:00,150 --> 00:16:05,890
<font color="#CCCCCC">Hardware the basically the way that you</font>

390
00:16:02,770 --> 00:16:08,680
do asynchronous<font color="#E5E5E5"> notifications are via</font>

391
00:16:05,890 --> 00:16:11,050
interrupts and so when we<font color="#CCCCCC"> put the CPU</font>

392
00:16:08,680 --> 00:16:13,420
into a mode to log all your branches we

393
00:16:11,050 --> 00:16:15,520
say you know<font color="#E5E5E5"> go ahead until either we</font>

394
00:16:13,420 --> 00:16:17,520
tell you<font color="#CCCCCC"> to stop or certain conditions</font>

395
00:16:15,520 --> 00:16:21,250
arise such as the buffer being full and

396
00:16:17,520 --> 00:16:22,810
when the buffer is full we want to be

397
00:16:21,250 --> 00:16:24,460
notified so we have to register a call

398
00:16:22,810 --> 00:16:26,560
back in a kernel that listens for

399
00:16:24,460 --> 00:16:30,850
<font color="#E5E5E5">particular interrupts to let us know</font>

400
00:16:26,560 --> 00:16:35,109
<font color="#CCCCCC">that</font><font color="#E5E5E5"> school so in order to do that we</font>

401
00:16:30,850 --> 00:16:39,010
had to<font color="#CCCCCC"> jump through some hurdles that I</font>

402
00:16:35,110 --> 00:16:42,310
will partially skip over but<font color="#E5E5E5"> basically</font>

403
00:16:39,010 --> 00:16:45,310
you can use the<font color="#E5E5E5"> Hal set system</font>

404
00:16:42,310 --> 00:16:48,390
<font color="#E5E5E5">information API which is pretty much</font>

405
00:16:45,310 --> 00:16:51,040
undocumented that you can grab the a pic

406
00:16:48,390 --> 00:16:52,900
interrupt a dress out of there and then

407
00:16:51,040 --> 00:16:56,050
register your interrupts address with it

408
00:16:52,900 --> 00:16:57,670
and then of course this is running at a

409
00:16:56,050 --> 00:17:00,250
super high privilege level and so in

410
00:16:57,670 --> 00:17:01,540
order to be able to communicate<font color="#E5E5E5"> you need</font>

411
00:17:00,250 --> 00:17:05,079
to use things like deferred procedure

412
00:17:01,540 --> 00:17:07,089
calls and do things asynchronously it's

413
00:17:05,079 --> 00:17:13,089
like a whole bunch of<font color="#E5E5E5"> layers of</font>

414
00:17:07,089 --> 00:17:14,770
indirection so for the user mode buffer

415
00:17:13,089 --> 00:17:16,750
that<font color="#E5E5E5"> you want to finally get back so the</font>

416
00:17:14,770 --> 00:17:18,579
way<font color="#CCCCCC"> that we utilize this right now is</font><font color="#E5E5E5"> we</font>

417
00:17:16,750 --> 00:17:20,619
have you know a controller application

418
00:17:18,579 --> 00:17:22,179
or or what have you and then you have

419
00:17:20,619 --> 00:17:25,958
your target application that you want to

420
00:17:22,180 --> 00:17:29,450
trace and we need<font color="#CCCCCC"> to have the buffers</font>

421
00:17:25,959 --> 00:17:31,490
that<font color="#CCCCCC"> you want to</font><font color="#E5E5E5"> parse and utilize</font>

422
00:17:29,450 --> 00:17:33,409
mapped into that controller application

423
00:17:31,490 --> 00:17:35,450
because if we map it into the target

424
00:17:33,409 --> 00:17:37,429
application and we end up with<font color="#E5E5E5"> you know</font>

425
00:17:35,450 --> 00:17:39,409
<font color="#E5E5E5">a crash or something for fuzzing and</font>

426
00:17:37,429 --> 00:17:42,289
we're trying to cause crashes well that

427
00:17:39,409 --> 00:17:44,149
crashes while the<font color="#E5E5E5"> CPU is locked pages</font>

428
00:17:42,289 --> 00:17:46,279
into ram and is you know expecting

429
00:17:44,149 --> 00:17:47,870
things to be there all<font color="#E5E5E5"> of your process</font>

430
00:17:46,279 --> 00:17:49,429
dies then all of a<font color="#CCCCCC"> sudden the colonel</font>

431
00:17:47,870 --> 00:17:52,600
tries to clean up those pages and your

432
00:17:49,429 --> 00:17:54,710
CPU shits the bed and that's no good so

433
00:17:52,600 --> 00:17:56,719
in order to do that you know we set up

434
00:17:54,710 --> 00:17:57,769
these page tables and we tell the

435
00:17:56,720 --> 00:18:02,090
interrupt handler to tell us when it's

436
00:17:57,769 --> 00:18:04,730
full<font color="#E5E5E5"> and we use the windows memory</font>

437
00:18:02,090 --> 00:18:10,820
descriptor lyst api's and we lock it in

438
00:18:04,730 --> 00:18:13,039
there with<font color="#CCCCCC"> IMAP lock pages blog for the</font>

439
00:18:10,820 --> 00:18:14,629
multiprocessor and<font color="#E5E5E5"> multi threading</font>

440
00:18:13,039 --> 00:18:17,960
support we just had<font color="#CCCCCC"> to add a layer of</font>

441
00:18:14,630 --> 00:18:20,690
abstraction that essentially you know

442
00:18:17,960 --> 00:18:23,480
has specialized structures that handle

443
00:18:20,690 --> 00:18:26,360
all the configuration for this and then

444
00:18:23,480 --> 00:18:27,740
of course<font color="#E5E5E5"> we had to be able to handle</font>

445
00:18:26,360 --> 00:18:31,100
Kendall interrupt<font color="#E5E5E5"> and determine which</font>

446
00:18:27,740 --> 00:18:33,559
cpu core comes from and then right now

447
00:18:31,100 --> 00:18:35,209
the last stage which was actually

448
00:18:33,559 --> 00:18:37,549
advertised on the abstract but turned

449
00:18:35,210 --> 00:18:39,380
out to be a rabbit hold it didn't pay

450
00:18:37,549 --> 00:18:42,080
out was we were trying to<font color="#E5E5E5"> figure out how</font>

451
00:18:39,380 --> 00:18:44,120
to separate user mode threads which are

452
00:18:42,080 --> 00:18:46,610
a<font color="#E5E5E5"> completely different abstraction than</font>

453
00:18:44,120 --> 00:18:48,620
your hardware threads so that we can say

454
00:18:46,610 --> 00:18:50,689
you<font color="#CCCCCC"> know i'm interested in internet</font>

455
00:18:48,620 --> 00:18:52,879
explorer but<font color="#E5E5E5"> i'm only interested in the</font>

456
00:18:50,690 --> 00:18:55,399
<font color="#E5E5E5">thread that's doing you know javascript</font>

457
00:18:52,880 --> 00:18:56,690
parsing or interacting with the dog or

458
00:18:55,399 --> 00:18:58,340
maybe<font color="#E5E5E5"> that's a bad example because they</font>

459
00:18:56,690 --> 00:19:01,279
spawn acing this all the time<font color="#E5E5E5"> but maybe</font>

460
00:18:58,340 --> 00:19:03,559
you're interested in you know any larger

461
00:19:01,279 --> 00:19:07,880
application but really you only want to

462
00:19:03,559 --> 00:19:10,010
follow the parser threads and as you'll

463
00:19:07,880 --> 00:19:11,779
see here since that log format was so

464
00:19:10,010 --> 00:19:13,908
compressed there's a lot<font color="#CCCCCC"> of work in</font>

465
00:19:11,779 --> 00:19:15,470
decoding it so the more work we can take

466
00:19:13,909 --> 00:19:18,110
away from<font color="#CCCCCC"> us</font><font color="#E5E5E5"> but less data that we have</font>

467
00:19:15,470 --> 00:19:20,570
<font color="#E5E5E5">to parse and translate back into actual</font>

468
00:19:18,110 --> 00:19:22,549
branch addresses the better so we went

469
00:19:20,570 --> 00:19:26,360
down the route of doing windows<font color="#E5E5E5"> event</font>

470
00:19:22,549 --> 00:19:27,799
tracing etw and<font color="#CCCCCC"> had</font><font color="#E5E5E5"> to do some reverse</font>

471
00:19:26,360 --> 00:19:30,939
engineering of how<font color="#CCCCCC"> that all works</font><font color="#E5E5E5"> on the</font>

472
00:19:27,799 --> 00:19:33,918
<font color="#E5E5E5">colonel side because you're supposed to</font>

473
00:19:30,940 --> 00:19:35,360
generally you're supposed to give define

474
00:19:33,919 --> 00:19:37,520
what you want to trace so we wanted to

475
00:19:35,360 --> 00:19:40,610
<font color="#E5E5E5">trace the context switching</font>

476
00:19:37,520 --> 00:19:42,170
windows kernel and so you know normally

477
00:19:40,610 --> 00:19:44,000
what you<font color="#E5E5E5"> do is you give it an XML blob</font>

478
00:19:42,170 --> 00:19:46,220
and it generates code for you and says

479
00:19:44,000 --> 00:19:47,750
<font color="#E5E5E5">okay use this library this library will</font>

480
00:19:46,220 --> 00:19:50,570
now tell you whenever context which

481
00:19:47,750 --> 00:19:52,400
happens only a context which isn't

482
00:19:50,570 --> 00:19:54,260
actually one of<font color="#E5E5E5"> the things they let you</font>

483
00:19:52,400 --> 00:19:56,360
do and then we needed to do this<font color="#E5E5E5"> from</font>

484
00:19:54,260 --> 00:19:58,160
<font color="#CCCCCC">the kernel mode side so long story short</font>

485
00:19:56,360 --> 00:20:00,649
we went through about a couple weeks as

486
00:19:58,160 --> 00:20:02,630
implementing that reversing it and then

487
00:20:00,650 --> 00:20:04,430
we realized oh shoot that's<font color="#E5E5E5"> all</font>

488
00:20:02,630 --> 00:20:07,580
asynchronous and so at the end<font color="#E5E5E5"> of the</font>

489
00:20:04,430 --> 00:20:09,380
day we were notified<font color="#CCCCCC"> that thread had</font>

490
00:20:07,580 --> 00:20:12,290
switched who knows how many milliseconds

491
00:20:09,380 --> 00:20:14,720
ago and so<font color="#E5E5E5"> that key synchronized</font><font color="#CCCCCC"> our</font>

492
00:20:12,290 --> 00:20:18,860
<font color="#E5E5E5">logging and so on so</font><font color="#CCCCCC"> that is</font><font color="#E5E5E5"> the last</font>

493
00:20:14,720 --> 00:20:20,600
remaining issue to solve which is

494
00:20:18,860 --> 00:20:23,810
probably going to<font color="#E5E5E5"> be solved through a PC</font>

495
00:20:20,600 --> 00:20:25,280
but that's neither here neither so the

496
00:20:23,810 --> 00:20:27,230
colonel boat racing<font color="#E5E5E5"> I'll be able to demo</font>

497
00:20:25,280 --> 00:20:28,970
for you<font color="#E5E5E5"> it's actually</font><font color="#CCCCCC"> really cool we can</font>

498
00:20:27,230 --> 00:20:31,730
<font color="#E5E5E5">trace our own driver because all the</font>

499
00:20:28,970 --> 00:20:34,030
tracing is happening from the cpu so

500
00:20:31,730 --> 00:20:37,430
there's no issues like if you want to

501
00:20:34,030 --> 00:20:40,910
kind of<font color="#CCCCCC"> cell trace or trace any any</font>

502
00:20:37,430 --> 00:20:43,010
arbitrary code running on your kernel of

503
00:20:40,910 --> 00:20:47,240
course the<font color="#CCCCCC"> the way that you interact</font>

504
00:20:43,010 --> 00:20:48,980
with<font color="#E5E5E5"> our driver is</font><font color="#CCCCCC"> that we have named</font>

505
00:20:47,240 --> 00:20:51,950
<font color="#E5E5E5">pipe that you interact with and you said</font>

506
00:20:48,980 --> 00:20:53,690
I opticals down there and naturally<font color="#CCCCCC"> you</font>

507
00:20:51,950 --> 00:20:55,190
need administrated privileges because

508
00:20:53,690 --> 00:20:56,870
you know you wouldn't want a low

509
00:20:55,190 --> 00:21:00,010
privileged user to tell the<font color="#E5E5E5"> CPU to start</font>

510
00:20:56,870 --> 00:21:02,419
tracing a high privilege process so on

511
00:21:00,010 --> 00:21:03,950
but<font color="#E5E5E5"> yeah so now we can trace kernel</font>

512
00:21:02,420 --> 00:21:05,870
module loads and unloads and all the

513
00:21:03,950 --> 00:21:09,620
things<font color="#CCCCCC"> going on inside and so on I'll</font>

514
00:21:05,870 --> 00:21:12,020
demo that<font color="#E5E5E5"> here in a little bit and at</font>

515
00:21:09,620 --> 00:21:14,090
the end<font color="#CCCCCC"> of the day is abstracted fairly</font>

516
00:21:12,020 --> 00:21:16,460
well I have as I mentioned a library

517
00:21:14,090 --> 00:21:18,110
that interfaces with this but<font color="#E5E5E5"> generally</font>

518
00:21:16,460 --> 00:21:20,030
it's as simple as you get a handle to

519
00:21:18,110 --> 00:21:21,760
the device<font color="#CCCCCC"> that we expose and you</font>

520
00:21:20,030 --> 00:21:24,290
interact with<font color="#E5E5E5"> it through some I octaves</font>

521
00:21:21,760 --> 00:21:25,670
<font color="#CCCCCC">to start the trace and then you can stop</font>

522
00:21:24,290 --> 00:21:30,460
the trace and then query you know how

523
00:21:25,670 --> 00:21:30,460
many packets that<font color="#E5E5E5"> I receive and so on</font>

524
00:21:32,610 --> 00:21:37,379
and this is<font color="#E5E5E5"> probably not too important</font>

525
00:21:35,070 --> 00:21:40,980
for you there were some other tricky

526
00:21:37,380 --> 00:21:43,320
issues making the page tables not get

527
00:21:40,980 --> 00:21:47,210
swapped out<font color="#E5E5E5"> yada yada but let's go ahead</font>

528
00:21:43,320 --> 00:21:47,210
<font color="#CCCCCC">and</font><font color="#E5E5E5"> just look at some stuff here</font>

529
00:21:55,070 --> 00:21:59,149
let me fix my mirror

530
00:22:19,600 --> 00:22:25,240
sorry as i mentioned i was working on a

531
00:22:22,780 --> 00:22:28,360
new feature<font color="#CCCCCC"> that's kind of the exciting</font>

532
00:22:25,240 --> 00:22:29,410
addition for this version<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the talk</font>

533
00:22:28,360 --> 00:22:32,559
which will be the last version of the

534
00:22:29,410 --> 00:22:34,809
talk and so I didn't get a<font color="#E5E5E5"> chance to</font>

535
00:22:32,559 --> 00:22:42,100
fully get my demo set up ahead of<font color="#E5E5E5"> time</font>

536
00:22:34,809 --> 00:22:45,010
<font color="#E5E5E5">but this isn't so bad</font><font color="#CCCCCC"> okay so generally</font>

537
00:22:42,100 --> 00:22:47,080
we install a service that controls the

538
00:22:45,010 --> 00:22:48,910
driver<font color="#CCCCCC"> the driver right now since I was</font>

539
00:22:47,080 --> 00:22:51,699
already doing some testing as you know

540
00:22:48,910 --> 00:22:54,520
compiled and installed we have a demo

541
00:22:51,700 --> 00:23:02,740
app that we ship with it me make this

542
00:22:54,520 --> 00:23:10,889
not<font color="#E5E5E5"> at the bottom make this a little bit</font>

543
00:23:02,740 --> 00:23:12,909
bigger for you<font color="#CCCCCC"> okay so that's okay</font>

544
00:23:10,890 --> 00:23:17,950
alright so first we'll do some user mode

545
00:23:12,909 --> 00:23:20,140
traces you know we can do the something

546
00:23:17,950 --> 00:23:22,539
as simple<font color="#E5E5E5"> as notepad and how many</font>

547
00:23:20,140 --> 00:23:25,809
processors do we want<font color="#E5E5E5"> to run it on we'll</font>

548
00:23:22,539 --> 00:23:30,340
just do it<font color="#E5E5E5"> on the one for the moment all</font>

549
00:23:25,809 --> 00:23:32,700
right of<font color="#E5E5E5"> course we get a nice unknown</font>

550
00:23:30,340 --> 00:23:32,699
error

551
00:23:37,440 --> 00:23:48,480
<font color="#E5E5E5">okay so basically give an idea of what</font>

552
00:23:46,049 --> 00:23:55,408
we're dealing with here the<font color="#CCCCCC"> output is</font>

553
00:23:48,480 --> 00:23:57,690
this you<font color="#CCCCCC"> know</font><font color="#E5E5E5"> this binary format that's</font>

554
00:23:55,409 --> 00:24:09,149
not at all useful to us unless we decode

555
00:23:57,690 --> 00:24:11,730
it fortunately not sure ok so when the

556
00:24:09,149 --> 00:24:13,439
Intel shifts a library called live<font color="#E5E5E5"> ipt</font>

557
00:24:11,730 --> 00:24:15,840
and so<font color="#E5E5E5"> this is the output format</font>

558
00:24:13,440 --> 00:24:18,600
obviously to binary format has all those

559
00:24:15,840 --> 00:24:20,178
packets exposed we're able to jump that

560
00:24:18,600 --> 00:24:22,709
to text to<font color="#E5E5E5"> give you an idea of what</font>

561
00:24:20,179 --> 00:24:27,629
<font color="#E5E5E5">we're actually looking at the contents</font>

562
00:24:22,710 --> 00:24:31,500
here so these are those packets that I

563
00:24:27,629 --> 00:24:34,709
had just<font color="#E5E5E5"> shown you so the PSP is kind of</font>

564
00:24:31,500 --> 00:24:37,440
like the<font color="#E5E5E5"> start that this is a take an IP</font>

565
00:24:34,710 --> 00:24:40,889
packet and so we can see that we do have

566
00:24:37,440 --> 00:24:43,080
some long branches here so we can see

567
00:24:40,889 --> 00:24:45,719
the full physical address or full

568
00:24:43,080 --> 00:24:50,279
virtual address rather and then we see

569
00:24:45,720 --> 00:24:53,789
things<font color="#E5E5E5"> like take an IP no idea take an</font>

570
00:24:50,279 --> 00:24:57,779
IP but<font color="#E5E5E5"> only the low word then we have</font>

571
00:24:53,789 --> 00:24:59,730
things like the taken not taken and the

572
00:24:57,779 --> 00:25:02,399
taken not taken you'll notice how<font color="#E5E5E5"> these</font>

573
00:24:59,730 --> 00:25:03,960
exclamation marks and dots and so those

574
00:25:02,399 --> 00:25:06,508
are determining whether or not that

575
00:25:03,960 --> 00:25:09,330
branch was taken or not so it codes up

576
00:25:06,509 --> 00:25:11,460
to six branches into a single bite<font color="#E5E5E5"> the</font>

577
00:25:09,330 --> 00:25:14,668
<font color="#E5E5E5">other two bits are used for the actual</font>

578
00:25:11,460 --> 00:25:17,190
packet ID and so on<font color="#E5E5E5"> so this is what we</font>

579
00:25:14,669 --> 00:25:19,529
have<font color="#E5E5E5"> to start with and then naturally we</font>

580
00:25:17,190 --> 00:25:21,269
need to determine what those branch

581
00:25:19,529 --> 00:25:25,909
targets were that they<font color="#CCCCCC"> cannot taken us</font>

582
00:25:21,269 --> 00:25:29,539
so on so let's look at this an item

583
00:25:25,909 --> 00:25:29,539
let's go ahead

584
00:25:49,530 --> 00:26:02,129
<font color="#E5E5E5">alright so this is notepad and we will</font>

585
00:25:53,260 --> 00:26:02,129
go ahead and run our I to plug in here

586
00:26:34,510 --> 00:26:39,460
probably should<font color="#E5E5E5"> I run this legal</font>

587
00:26:36,140 --> 00:26:39,460
something with symbols sorry

588
00:26:45,960 --> 00:26:50,970
I'm not<font color="#CCCCCC"> sure it actually loaded that</font>

589
00:26:48,160 --> 00:26:50,970
file properly

590
00:26:57,159 --> 00:27:04,720
yeah<font color="#E5E5E5"> okay let's try that again sorry</font>

591
00:27:00,730 --> 00:27:04,720
this has been<font color="#E5E5E5"> a moving target because</font>

592
00:27:04,899 --> 00:27:10,029
every time I give this talk it's a

593
00:27:06,860 --> 00:27:12,199
totally new version of<font color="#CCCCCC"> the code and</font>

594
00:27:10,029 --> 00:27:14,710
obviously we get to synchronized a

595
00:27:12,200 --> 00:27:14,710
little bit sometimes

596
00:27:27,750 --> 00:27:31,630
maybe I'll just jump to<font color="#E5E5E5"> the colonel one</font>

597
00:27:29,919 --> 00:27:35,200
that has a symbol so it'll be<font color="#E5E5E5"> a lot</font>

598
00:27:31,630 --> 00:27:37,299
<font color="#E5E5E5">easier sorry about that yeah let's see</font>

599
00:27:35,200 --> 00:27:40,409
the colonel chase real quick just so

600
00:27:37,299 --> 00:27:40,408
that we can get<font color="#E5E5E5"> back on track</font>

601
00:28:08,980 --> 00:28:13,850
<font color="#E5E5E5">okay so now it's tracing in the</font>

602
00:28:11,690 --> 00:28:15,170
backgrounds my actual driver itself

603
00:28:13,850 --> 00:28:17,830
which i think<font color="#E5E5E5"> i have symbols compiled</font>

604
00:28:15,170 --> 00:28:20,830
for so we hopefully will be able<font color="#E5E5E5"> to see</font>

605
00:28:17,830 --> 00:28:20,830
here

606
00:28:35,390 --> 00:28:38,450
verify this

607
00:28:45,710 --> 00:28:54,960
<font color="#E5E5E5">okay yes and here</font><font color="#CCCCCC"> we can see obviously</font>

608
00:28:52,290 --> 00:28:57,899
this one's even a bigger pain because it

609
00:28:54,960 --> 00:29:01,110
has a lot less full addresses that you

610
00:28:57,900 --> 00:29:03,320
can utilize so let's try that<font color="#CCCCCC"> one more</font>

611
00:29:01,110 --> 00:29:03,320
time

612
00:29:17,800 --> 00:29:27,110
all right yes so this<font color="#E5E5E5"> time we have</font>

613
00:29:19,670 --> 00:29:29,590
symbols so we<font color="#E5E5E5"> should have better luck</font>

614
00:29:27,110 --> 00:29:29,590
here

615
00:29:36,890 --> 00:29:46,220
shit i'm having an issue parsing the

616
00:29:41,510 --> 00:29:47,930
file here unfortunately the side of

617
00:29:46,220 --> 00:29:51,380
<font color="#E5E5E5">plugins probably ought to sync with the</font>

618
00:29:47,930 --> 00:29:52,670
the parser on the that we're committing

619
00:29:51,380 --> 00:29:53,990
for the output basically what you

620
00:29:52,670 --> 00:29:55,310
normally would see here I've got<font color="#E5E5E5"> more</font>

621
00:29:53,990 --> 00:29:56,870
demos that you guys will enjoy<font color="#CCCCCC"> it but</font>

622
00:29:55,310 --> 00:29:58,909
what you'll normally see here is your

623
00:29:56,870 --> 00:30:01,760
typical overlay with highlight of blocks

624
00:29:58,910 --> 00:30:03,500
and then it will actually deepen the

625
00:30:01,760 --> 00:30:05,090
color we use blue and it gets darker

626
00:30:03,500 --> 00:30:09,200
blue<font color="#E5E5E5"> four cycles so it's immediately</font>

627
00:30:05,090 --> 00:30:10,310
obvious I when you get<font color="#E5E5E5"> the cycles yeah</font>

628
00:30:09,200 --> 00:30:11,450
it's a real<font color="#CCCCCC"> number if we</font><font color="#E5E5E5"> have time at</font>

629
00:30:10,310 --> 00:30:12,830
the end I'll come back and<font color="#E5E5E5"> do this one</font>

630
00:30:11,450 --> 00:30:19,250
again I don't<font color="#E5E5E5"> want to waste too much</font>

631
00:30:12,830 --> 00:30:23,870
time just<font color="#E5E5E5"> root around with this one so</font>

632
00:30:19,250 --> 00:30:25,820
yes let's get back to the slide<font color="#CCCCCC"> show so</font>

633
00:30:23,870 --> 00:30:28,250
okay<font color="#E5E5E5"> so we have</font><font color="#CCCCCC"> a fast racing engine</font>

634
00:30:25,820 --> 00:30:30,830
<font color="#CCCCCC">fifteen percent overhead we're recording</font>

635
00:30:28,250 --> 00:30:32,600
all the branches you'll<font color="#E5E5E5"> just have to</font>

636
00:30:30,830 --> 00:30:34,850
trust me that<font color="#E5E5E5"> learn to code and abruptly</font>

637
00:30:32,600 --> 00:30:37,820
but I to plugin so how do we utilize

638
00:30:34,850 --> 00:30:39,980
that for bone discovery well so

639
00:30:37,820 --> 00:30:41,659
evolutionary buzzing is more or less<font color="#CCCCCC"> the</font>

640
00:30:39,980 --> 00:30:44,330
hot sauce going<font color="#E5E5E5"> on today it's</font>

641
00:30:41,660 --> 00:30:46,520
incremental<font color="#CCCCCC"> e better mutational dumb</font>

642
00:30:44,330 --> 00:30:48,379
fuzzing via<font color="#E5E5E5"> using a feedback signal</font>

643
00:30:46,520 --> 00:30:50,900
which of course in this case is code

644
00:30:48,380 --> 00:30:53,420
coverage so we can<font color="#CCCCCC"> determine did the new</font>

645
00:30:50,900 --> 00:30:59,030
newly generated input reach new parts of

646
00:30:53,420 --> 00:31:02,600
the code right and so basically<font color="#E5E5E5"> we use</font>

647
00:30:59,030 --> 00:31:05,240
coverage and then we basically use<font color="#CCCCCC"> the</font>

648
00:31:02,600 --> 00:31:07,669
code coverage as a fitness function

649
00:31:05,240 --> 00:31:10,550
which is<font color="#E5E5E5"> what you would use in genetic</font>

650
00:31:07,670 --> 00:31:13,280
programming and then we also utilize

651
00:31:10,550 --> 00:31:16,430
that over time to determine each new

652
00:31:13,280 --> 00:31:17,990
input it's interesting from<font color="#E5E5E5"> my last</font>

653
00:31:16,430 --> 00:31:19,190
couple<font color="#E5E5E5"> years of talks the required</font>

654
00:31:17,990 --> 00:31:21,440
components in order<font color="#E5E5E5"> to do this</font>

655
00:31:19,190 --> 00:31:23,720
effectively is we need a fast racing

656
00:31:21,440 --> 00:31:25,700
engine obviously the slower<font color="#CCCCCC"> your</font><font color="#E5E5E5"> tracing</font>

657
00:31:23,720 --> 00:31:28,010
engine is you can't execute many times a

658
00:31:25,700 --> 00:31:30,080
second we need block-based granularity

659
00:31:28,010 --> 00:31:32,600
as opposed to something like function

660
00:31:30,080 --> 00:31:36,129
<font color="#E5E5E5">coverage the early</font><font color="#CCCCCC"> research in this</font>

661
00:31:32,600 --> 00:31:37,969
space was jared's<font color="#CCCCCC"> Amma's and the EFS</font>

662
00:31:36,130 --> 00:31:41,120
evolutionary fuzzing system from like

663
00:31:37,970 --> 00:31:44,360
two thousand six or so he did<font color="#E5E5E5"> the first</font>

664
00:31:41,120 --> 00:31:46,279
PhD and he really dope deep into the

665
00:31:44,360 --> 00:31:49,039
science of how genetic algorithm

666
00:31:46,279 --> 00:31:51,320
work and what fitness landscapes there

667
00:31:49,039 --> 00:31:54,349
are you know what attributes you<font color="#CCCCCC"> can put</font>

668
00:31:51,320 --> 00:31:56,599
<font color="#CCCCCC">into it but at</font><font color="#E5E5E5"> the end of the day we</font>

669
00:31:54,349 --> 00:31:58,070
<font color="#CCCCCC">need to minimize the attributes that</font>

670
00:31:56,599 --> 00:31:59,928
we're<font color="#E5E5E5"> looking at because we need to do</font>

671
00:31:58,070 --> 00:32:03,109
very very<font color="#E5E5E5"> fast lookups and references</font>

672
00:31:59,929 --> 00:32:06,349
across your entire population pool so

673
00:32:03,109 --> 00:32:09,168
all your entire corpus and in<font color="#E5E5E5"> order to</font>

674
00:32:06,349 --> 00:32:11,059
do that we need a data storage that is

675
00:32:09,169 --> 00:32:15,169
very efficient to do comparisons over

676
00:32:11,059 --> 00:32:16,940
time and<font color="#E5E5E5"> so American fuzzy</font><font color="#CCCCCC"> laugh is the</font>

677
00:32:15,169 --> 00:32:19,700
buzzer that<font color="#E5E5E5"> people have been using the</font>

678
00:32:16,940 --> 00:32:21,409
last few<font color="#E5E5E5"> years</font><font color="#CCCCCC"> it develops by Michaels</font>

679
00:32:19,700 --> 00:32:24,969
the<font color="#E5E5E5"> whiskey who's done a lot of great</font>

680
00:32:21,409 --> 00:32:28,249
work over the<font color="#E5E5E5"> decades and it was</font>

681
00:32:24,969 --> 00:32:31,149
originally designed as a buzzer for

682
00:32:28,249 --> 00:32:33,739
<font color="#CCCCCC">open-source</font><font color="#E5E5E5"> software it operated by</font>

683
00:32:31,149 --> 00:32:36,559
modifying the<font color="#E5E5E5"> assembler output</font><font color="#CCCCCC"> at</font><font color="#E5E5E5"> GCC</font>

684
00:32:33,739 --> 00:32:41,330
and annotating it such that you could<font color="#E5E5E5"> do</font>

685
00:32:36,559 --> 00:32:43,489
call<font color="#CCCCCC"> out to your coverage function it</font>

686
00:32:41,330 --> 00:32:45,710
implements<font color="#E5E5E5"> the variety of traditional</font>

687
00:32:43,489 --> 00:32:49,789
mutation buzzing so you know you're

688
00:32:45,710 --> 00:32:51,979
flipping bits or bytes or words or you

689
00:32:49,789 --> 00:32:53,509
know kind<font color="#E5E5E5"> of taking half of two files</font>

690
00:32:51,979 --> 00:32:55,700
and merging them together<font color="#E5E5E5"> and so on it</font>

691
00:32:53,509 --> 00:33:00,950
has a nice<font color="#E5E5E5"> catalog of different types of</font>

692
00:32:55,700 --> 00:33:02,779
mutations and then using the GCC or

693
00:33:00,950 --> 00:33:06,109
using the modification on the assembler

694
00:33:02,779 --> 00:33:08,269
emitted by GCC then he compiles that so

695
00:33:06,109 --> 00:33:10,728
instruments the<font color="#E5E5E5"> you know</font><font color="#CCCCCC"> dot s file the</font>

696
00:33:08,269 --> 00:33:13,359
intermediate file files that so it's

697
00:33:10,729 --> 00:33:16,190
baked in and then<font color="#E5E5E5"> most importantly</font>

698
00:33:13,359 --> 00:33:18,799
probably it<font color="#E5E5E5"> was to track it over time he</font>

699
00:33:16,190 --> 00:33:20,869
uses a bloom filter so you can determine

700
00:33:18,799 --> 00:33:23,559
<font color="#E5E5E5">whether or not you've traversed this</font>

701
00:33:20,869 --> 00:33:25,488
edge from block a<font color="#E5E5E5"> two block</font><font color="#CCCCCC"> B previously</font>

702
00:33:23,559 --> 00:33:27,979
and if you're not familiar with the

703
00:33:25,489 --> 00:33:33,379
bloom filter it's essentially a lookup

704
00:33:27,979 --> 00:33:36,919
<font color="#CCCCCC">of a map in this case he uses 64k of</font><font color="#E5E5E5"> RAM</font>

705
00:33:33,379 --> 00:33:39,379
which happens to be the size of a old

706
00:33:36,919 --> 00:33:42,619
CPU cache modern architecture still have

707
00:33:39,379 --> 00:33:44,570
<font color="#E5E5E5">128 k now but 64</font><font color="#CCCCCC"> k for</font><font color="#E5E5E5"> the cash because</font>

708
00:33:42,619 --> 00:33:47,449
you're hitting<font color="#E5E5E5"> it on every branch and he</font>

709
00:33:44,570 --> 00:33:49,218
takes the previous basic blocks address

710
00:33:47,450 --> 00:33:53,210
and the<font color="#E5E5E5"> next basic block address and</font>

711
00:33:49,219 --> 00:33:55,759
does a simple hash by shifting the<font color="#CCCCCC"> high</font>

712
00:33:53,210 --> 00:33:57,309
bites off and soars them together and so

713
00:33:55,759 --> 00:34:00,129
then you end up with<font color="#CCCCCC"> this</font>

714
00:33:57,309 --> 00:34:02,860
you know this one 64-bit value that

715
00:34:00,129 --> 00:34:06,580
represents an edge transition and then

716
00:34:02,860 --> 00:34:08,679
modulo<font color="#CCCCCC"> the 64</font><font color="#E5E5E5"> K map that he has he</font>

717
00:34:06,580 --> 00:34:10,750
indexes into that and then increments

718
00:34:08,679 --> 00:34:14,470
that offset and so that's how many times

719
00:34:10,750 --> 00:34:16,179
you've traversed this particular edge so

720
00:34:14,469 --> 00:34:18,520
that happens to<font color="#CCCCCC"> be a really really</font>

721
00:34:16,179 --> 00:34:21,250
efficient both in space to store all

722
00:34:18,520 --> 00:34:23,168
<font color="#CCCCCC">that so previously if you looked at</font>

723
00:34:21,250 --> 00:34:26,050
block tracers what they would normally

724
00:34:23,168 --> 00:34:28,540
do is record every time you<font color="#E5E5E5"> enter a</font>

725
00:34:26,050 --> 00:34:30,520
basic block either in a text or binary

726
00:34:28,540 --> 00:34:32,800
format you end up with<font color="#E5E5E5"> a list of blocks</font>

727
00:34:30,520 --> 00:34:36,550
and then later on you have to figure out

728
00:34:32,800 --> 00:34:39,700
<font color="#CCCCCC">how to do a diff across those executions</font>

729
00:34:36,550 --> 00:34:42,940
so this kind<font color="#E5E5E5"> of keeps that state all in</font>

730
00:34:39,699 --> 00:34:45,009
one 64k blog for you and then not only

731
00:34:42,940 --> 00:34:47,800
does it keep a single execution but of

732
00:34:45,010 --> 00:34:50,950
course<font color="#E5E5E5"> you can keep over time the entire</font>

733
00:34:47,800 --> 00:34:53,050
corpus estate as you've gone through

734
00:34:50,949 --> 00:34:55,089
them so it's very very trivial to

735
00:34:53,050 --> 00:34:57,970
determine if<font color="#E5E5E5"> this new execution that you</font>

736
00:34:55,089 --> 00:35:01,299
just did has incremented any of those

737
00:34:57,970 --> 00:35:04,029
bites in the maps so very useful and

738
00:35:01,300 --> 00:35:05,829
very very fast to do comparisons on and

739
00:35:04,030 --> 00:35:08,200
then of course this was written using

740
00:35:05,829 --> 00:35:09,700
POSIX API and so on and what we're

741
00:35:08,200 --> 00:35:14,020
interested in is applying this to

742
00:35:09,700 --> 00:35:16,569
windows so I think that covered all that

743
00:35:14,020 --> 00:35:18,690
also for server was another important

744
00:35:16,569 --> 00:35:21,310
addition that used<font color="#E5E5E5"> for performance</font>

745
00:35:18,690 --> 00:35:23,770
architectural<font color="#E5E5E5"> e on Linux when you create</font>

746
00:35:21,310 --> 00:35:26,259
a new process of V of<font color="#E5E5E5"> Fort uses</font>

747
00:35:23,770 --> 00:35:28,300
copy-on-write on the memory<font color="#E5E5E5"> pages so</font>

748
00:35:26,260 --> 00:35:30,069
it's a very<font color="#CCCCCC"> very fast to initialize new</font>

749
00:35:28,300 --> 00:35:34,180
process the matter of copying page

750
00:35:30,069 --> 00:35:35,950
tables so rather than having<font color="#CCCCCC"> to do a lot</font>

751
00:35:34,180 --> 00:35:38,169
<font color="#CCCCCC">of work to initialize and reload and</font>

752
00:35:35,950 --> 00:35:41,200
remap all your binaries it's using the

753
00:35:38,170 --> 00:35:42,520
<font color="#E5E5E5">already maps physical memory and just</font>

754
00:35:41,200 --> 00:35:45,549
copying a page tables oversee a new

755
00:35:42,520 --> 00:35:47,650
process<font color="#CCCCCC"> points</font><font color="#E5E5E5"> the same thing and then</font>

756
00:35:45,550 --> 00:35:49,359
you can do nice fancy tricks like wait

757
00:35:47,650 --> 00:35:52,329
until<font color="#CCCCCC"> a little bit later in</font><font color="#E5E5E5"> the process</font>

758
00:35:49,359 --> 00:35:54,460
to do your<font color="#E5E5E5"> Forks so you can skip all the</font>

759
00:35:52,329 --> 00:35:57,490
<font color="#E5E5E5">unnecessary code before your input is</font>

760
00:35:54,460 --> 00:35:59,050
<font color="#E5E5E5">seen and parsed all these things are</font>

761
00:35:57,490 --> 00:36:01,540
<font color="#E5E5E5">great performance additions and very</font>

762
00:35:59,050 --> 00:36:06,490
<font color="#E5E5E5">very important to the architecture of a</font>

763
00:36:01,540 --> 00:36:09,279
fast modern fuzzy and the kind of<font color="#E5E5E5"> a</font>

764
00:36:06,490 --> 00:36:09,910
<font color="#E5E5E5">keynote here is a</font><font color="#CCCCCC"> Venn</font><font color="#E5E5E5"> nagi originally</font>

765
00:36:09,280 --> 00:36:11,970
pointed out

766
00:36:09,910 --> 00:36:15,460
is that you know when we're buzzing

767
00:36:11,970 --> 00:36:17,740
complex you<font color="#E5E5E5"> know large targets like you</font>

768
00:36:15,460 --> 00:36:21,250
see commonly on Windows you can still

769
00:36:17,740 --> 00:36:24,279
use<font color="#E5E5E5"> these efficient buzzers to generate</font>

770
00:36:21,250 --> 00:36:27,460
corpus so now if you want<font color="#E5E5E5"> to go the PDF</font>

771
00:36:24,280 --> 00:36:30,160
library and windows let me<font color="#E5E5E5"> wanted</font>

772
00:36:27,460 --> 00:36:31,569
Windows<font color="#E5E5E5"> 10 an edge you know that's</font>

773
00:36:30,160 --> 00:36:33,220
actually<font color="#E5E5E5"> really difficult instrument</font>

774
00:36:31,569 --> 00:36:34,569
it's slow<font color="#CCCCCC"> hasn't a synchronous API</font>

775
00:36:33,220 --> 00:36:37,660
there's all kinds of<font color="#E5E5E5"> complications</font>

776
00:36:34,569 --> 00:36:39,210
around it but you<font color="#CCCCCC"> know you can take</font>

777
00:36:37,660 --> 00:36:42,730
<font color="#E5E5E5">American fuzzy lop and point it at</font>

778
00:36:39,210 --> 00:36:45,700
poplar any other<font color="#E5E5E5"> open source PDF library</font>

779
00:36:42,730 --> 00:36:48,369
and it keeps the corpus it keeps every

780
00:36:45,700 --> 00:36:50,348
unique input that it saw take a

781
00:36:48,369 --> 00:36:52,329
<font color="#E5E5E5">different branch and the open</font><font color="#CCCCCC"> source</font>

782
00:36:50,349 --> 00:36:53,799
version so you<font color="#E5E5E5"> take all those over and</font>

783
00:36:52,329 --> 00:36:55,599
then that's where you start buzzing on

784
00:36:53,799 --> 00:36:58,780
the windows side so that's just<font color="#CCCCCC"> a little</font>

785
00:36:55,599 --> 00:37:00,760
side note but some fuzz don't keep the

786
00:36:58,780 --> 00:37:03,490
entire corpus they only keep the crashes

787
00:37:00,760 --> 00:37:06,430
and actually a<font color="#CCCCCC"> lot of value is in those</font>

788
00:37:03,490 --> 00:37:10,200
unique inputs that you can then use as

789
00:37:06,430 --> 00:37:14,078
inputs into other parts of your workflow

790
00:37:10,200 --> 00:37:15,509
so yeah we covered that so on the

791
00:37:14,079 --> 00:37:21,880
windows side<font color="#CCCCCC"> I started looking at this</font>

792
00:37:15,510 --> 00:37:23,799
ruxton or so in 2015 and the initially

793
00:37:21,880 --> 00:37:26,109
my tests were actually on the<font color="#CCCCCC"> Linux side</font>

794
00:37:23,799 --> 00:37:28,329
since I noticed but this feature was in

795
00:37:26,109 --> 00:37:31,990
there<font color="#E5E5E5"> and then was looking if anybody if</font>

796
00:37:28,329 --> 00:37:32,920
it was<font color="#E5E5E5"> available to use via software you</font>

797
00:37:31,990 --> 00:37:34,990
know I notice that Linux had it

798
00:37:32,920 --> 00:37:36,700
available so not only does linux have it

799
00:37:34,990 --> 00:37:38,649
available but<font color="#CCCCCC"> i actually used a</font>

800
00:37:36,700 --> 00:37:42,118
reference driver that's available from

801
00:37:38,650 --> 00:37:44,980
intel it's on github called simple PT

802
00:37:42,119 --> 00:37:48,779
written by<font color="#CCCCCC"> andy clean who also wrote the</font>

803
00:37:44,980 --> 00:37:51,220
other<font color="#CCCCCC"> p mu tools available for linux so</font>

804
00:37:48,779 --> 00:37:52,480
so<font color="#CCCCCC"> i started</font><font color="#E5E5E5"> off on that direction and</font>

805
00:37:51,220 --> 00:37:54,399
just to see what kind<font color="#CCCCCC"> of performance</font>

806
00:37:52,480 --> 00:37:56,770
would get out<font color="#E5E5E5"> of it the performance was</font>

807
00:37:54,400 --> 00:37:59,680
sufficient enough that<font color="#CCCCCC"> i decided</font><font color="#E5E5E5"> to go</font>

808
00:37:56,770 --> 00:38:02,430
<font color="#E5E5E5">on this you know kind</font><font color="#CCCCCC"> of long trek and</font>

809
00:37:59,680 --> 00:38:05,020
trying to implement this on<font color="#CCCCCC"> Windows and</font>

810
00:38:02,430 --> 00:38:06,368
naturally the biggest problem<font color="#CCCCCC"> on Windows</font>

811
00:38:05,020 --> 00:38:08,529
is that we don't use a<font color="#CCCCCC"> lot of open</font>

812
00:38:06,369 --> 00:38:10,380
source software or at least the software

813
00:38:08,529 --> 00:38:12,870
that<font color="#E5E5E5"> you might download from vendors</font>

814
00:38:10,380 --> 00:38:15,000
is the open<font color="#E5E5E5"> source stuff will be baked</font>

815
00:38:12,870 --> 00:38:18,089
into other binaries and so on<font color="#E5E5E5"> so we</font>

816
00:38:15,000 --> 00:38:23,760
really<font color="#CCCCCC"> do need a binary tracer to work</font>

817
00:38:18,090 --> 00:38:26,220
on this and the<font color="#CCCCCC"> while I was thinking</font>

818
00:38:23,760 --> 00:38:28,020
<font color="#CCCCCC">about</font><font color="#E5E5E5"> this on how to move to the Windows</font>

819
00:38:26,220 --> 00:38:29,879
platform<font color="#E5E5E5"> it turns out that I've been</font>

820
00:38:28,020 --> 00:38:32,670
<font color="#E5E5E5">Frederick from google was also on the</font>

821
00:38:29,880 --> 00:38:35,400
same track and not on the<font color="#CCCCCC"> Intel PT side</font>

822
00:38:32,670 --> 00:38:37,110
but he just clearly identified that AFL

823
00:38:35,400 --> 00:38:38,370
is a great<font color="#E5E5E5"> closing engine wouldn't it be</font>

824
00:38:37,110 --> 00:38:41,310
great if we could get this on<font color="#E5E5E5"> Windows</font>

825
00:38:38,370 --> 00:38:42,750
and he happens to work with Zaleski so

826
00:38:41,310 --> 00:38:45,480
that was kind of a natural thought

827
00:38:42,750 --> 00:38:47,730
process I'm sure and it's available now

828
00:38:45,480 --> 00:38:50,700
it's<font color="#E5E5E5"> American fuzzy blop it does work on</font>

829
00:38:47,730 --> 00:38:53,310
<font color="#E5E5E5">Windows there was quite a bit</font><font color="#CCCCCC"> of</font>

830
00:38:50,700 --> 00:38:56,060
internals that had to be modified since

831
00:38:53,310 --> 00:38:58,740
<font color="#E5E5E5">Windows is</font><font color="#CCCCCC"> not at all posix compatible</font>

832
00:38:56,060 --> 00:39:00,630
and then of<font color="#CCCCCC"> course you had to</font><font color="#E5E5E5"> choose a</font>

833
00:38:58,740 --> 00:39:02,990
tracing engine that will work against

834
00:39:00,630 --> 00:39:05,520
minors in his case he chose dynamo<font color="#E5E5E5"> Rio</font>

835
00:39:02,990 --> 00:39:08,339
and the implementation on its<font color="#CCCCCC"> plugin is</font>

836
00:39:05,520 --> 00:39:10,530
actually excellent in if you look at my

837
00:39:08,340 --> 00:39:12,330
previous talks I really dissect the

838
00:39:10,530 --> 00:39:15,000
differences between<font color="#E5E5E5"> tune and dynamo Rio</font>

839
00:39:12,330 --> 00:39:16,950
diagrams and so on and why you<font color="#E5E5E5"> should</font>

840
00:39:15,000 --> 00:39:19,080
choose one over the other and my

841
00:39:16,950 --> 00:39:20,549
conclusion there was that dynamo Rio is

842
00:39:19,080 --> 00:39:23,009
the better platform if you need

843
00:39:20,550 --> 00:39:26,670
performance and the<font color="#CCCCCC"> primary reason</font><font color="#E5E5E5"> is</font>

844
00:39:23,010 --> 00:39:29,070
because on pin and most<font color="#CCCCCC"> dbi platforms</font>

845
00:39:26,670 --> 00:39:31,590
will allow you to<font color="#E5E5E5"> insert hooks out to a</font>

846
00:39:29,070 --> 00:39:32,810
callback function but dynamo real

847
00:39:31,590 --> 00:39:35,190
actually lets you synthesize

848
00:39:32,810 --> 00:39:37,140
instructions directly within the basic

849
00:39:35,190 --> 00:39:40,110
blocks so you can do and it also

850
00:39:37,140 --> 00:39:41,970
supports small static analysis so it can

851
00:39:40,110 --> 00:39:44,100
do a live pneus analysis on certain

852
00:39:41,970 --> 00:39:45,720
registers within that basic block you

853
00:39:44,100 --> 00:39:47,880
can determine that oh<font color="#E5E5E5"> this is a dead</font>

854
00:39:45,720 --> 00:39:51,720
register within the block so<font color="#E5E5E5"> I can use</font>

855
00:39:47,880 --> 00:39:52,770
<font color="#CCCCCC">it to implement you know a faster table</font>

856
00:39:51,720 --> 00:39:56,430
reference for example rather than

857
00:39:52,770 --> 00:39:58,590
calling out and you know doing cash

858
00:39:56,430 --> 00:40:00,240
pollution that way so he definitely it's

859
00:39:58,590 --> 00:40:01,650
one<font color="#E5E5E5"> of the prettier dynamo real plugins</font>

860
00:40:00,240 --> 00:40:04,890
out there it's worth studying for that

861
00:40:01,650 --> 00:40:07,440
<font color="#E5E5E5">alone it's good code but yeah so he's</font>

862
00:40:04,890 --> 00:40:09,029
using dynamo<font color="#E5E5E5"> Rio you can filter based</font>

863
00:40:07,440 --> 00:40:11,040
upon which module you want to do code

864
00:40:09,030 --> 00:40:13,980
coverage on because<font color="#E5E5E5"> demo reel is good</font>

865
00:40:11,040 --> 00:40:15,420
it's fast for<font color="#E5E5E5"> dbi but it's about 30</font>

866
00:40:13,980 --> 00:40:17,400
times slower than<font color="#CCCCCC"> eight of execution or</font>

867
00:40:15,420 --> 00:40:21,270
so so you want to limit the code<font color="#CCCCCC"> that</font>

868
00:40:17,400 --> 00:40:23,790
you're tracing and then he also i

869
00:40:21,270 --> 00:40:26,310
recently actually had a chat<font color="#CCCCCC"> with them</font>

870
00:40:23,790 --> 00:40:28,620
and we kind of fixed the<font color="#CCCCCC"> multi threading</font>

871
00:40:26,310 --> 00:40:32,910
edge coverage but<font color="#CCCCCC"> it has a block mode in</font>

872
00:40:28,620 --> 00:40:35,549
edge mode essentially the solution for

873
00:40:32,910 --> 00:40:38,430
doing the edge tracing across threads is

874
00:40:35,550 --> 00:40:41,250
to use the<font color="#E5E5E5"> thread-local storage to store</font>

875
00:40:38,430 --> 00:40:42,930
your last branch otherwise if<font color="#CCCCCC"> you get</font>

876
00:40:41,250 --> 00:40:45,120
interrupted in another threads executing

877
00:40:42,930 --> 00:40:49,410
you have a fake edge that doesn't

878
00:40:45,120 --> 00:40:51,690
actually<font color="#E5E5E5"> exist and then the biggest part</font>

879
00:40:49,410 --> 00:40:54,270
<font color="#E5E5E5">the</font><font color="#CCCCCC"> most important part is that he does</font>

880
00:40:51,690 --> 00:40:56,640
persistent execution meaning<font color="#E5E5E5"> that he's</font>

881
00:40:54,270 --> 00:40:59,250
<font color="#E5E5E5">doing in memory fuzzing and this is</font>

882
00:40:56,640 --> 00:41:01,620
important in particular with<font color="#CCCCCC"> dbi because</font>

883
00:40:59,250 --> 00:41:03,420
the way that<font color="#E5E5E5"> they work is there a custom</font>

884
00:41:01,620 --> 00:41:06,540
loader for your process and when you run

885
00:41:03,420 --> 00:41:09,240
your process the<font color="#E5E5E5"> dbi loads it and took</font>

886
00:41:06,540 --> 00:41:11,220
every branch if you register branch

887
00:41:09,240 --> 00:41:12,810
callbacks and it has<font color="#CCCCCC"> to disassemble that</font>

888
00:41:11,220 --> 00:41:16,589
branch each<font color="#E5E5E5"> time it discovers a new one</font>

889
00:41:12,810 --> 00:41:18,090
and so naturally<font color="#E5E5E5"> every time you restart</font>

890
00:41:16,590 --> 00:41:20,750
a process that has to do that all over

891
00:41:18,090 --> 00:41:22,890
again these aren't being cached to<font color="#E5E5E5"> disk</font>

892
00:41:20,750 --> 00:41:27,090
tenemo real does have a flag that's

893
00:41:22,890 --> 00:41:29,640
meant to cash its instrumented basic

894
00:41:27,090 --> 00:41:33,630
blocks to disk but it it has issues and

895
00:41:29,640 --> 00:41:34,980
in reality it isn't fully there so so I

896
00:41:33,630 --> 00:41:38,760
<font color="#E5E5E5">haven't</font><font color="#CCCCCC"> sucked the persistent mode</font>

897
00:41:34,980 --> 00:41:41,910
approach and the idea<font color="#CCCCCC"> is that you pass</font>

898
00:41:38,760 --> 00:41:43,770
in an offset into a module the module

899
00:41:41,910 --> 00:41:46,350
can be your own module that<font color="#E5E5E5"> you wrote</font>

900
00:41:43,770 --> 00:41:48,870
that's a wrapper for an<font color="#E5E5E5"> API which tends</font>

901
00:41:46,350 --> 00:41:51,720
to be the right<font color="#E5E5E5"> way to go if you can or</font>

902
00:41:48,870 --> 00:41:54,660
you can specify an arbitrary offset into

903
00:41:51,720 --> 00:41:56,160
an application or arbitrary dll that's

904
00:41:54,660 --> 00:41:57,629
the function entry points and you tell

905
00:41:56,160 --> 00:42:00,509
it how many parameters are passed to

906
00:41:57,630 --> 00:42:03,150
that function and then it's able<font color="#CCCCCC"> to use</font>

907
00:42:00,510 --> 00:42:05,400
the dynamo<font color="#CCCCCC"> Rio API to rapper that entry</font>

908
00:42:03,150 --> 00:42:10,710
point<font color="#E5E5E5"> and you</font><font color="#CCCCCC"> know do a loop for n</font>

909
00:42:05,400 --> 00:42:12,480
number of iterations before exiting so

910
00:42:10,710 --> 00:42:14,430
this works out to<font color="#E5E5E5"> be really</font><font color="#CCCCCC"> good and</font>

911
00:42:12,480 --> 00:42:17,480
very performance better than<font color="#E5E5E5"> anything</font>

912
00:42:14,430 --> 00:42:20,549
else<font color="#CCCCCC"> that was out there</font><font color="#E5E5E5"> on</font><font color="#CCCCCC"> Windows and</font>

913
00:42:17,480 --> 00:42:23,450
for<font color="#E5E5E5"> example since we are using dynamo</font>

914
00:42:20,550 --> 00:42:25,100
<font color="#E5E5E5">Rio if we restart the process every time</font>

915
00:42:23,450 --> 00:42:27,200
which essentially disables the

916
00:42:25,100 --> 00:42:30,319
persistence because it's<font color="#E5E5E5"> not doing it</font>

917
00:42:27,200 --> 00:42:32,960
memory buzzing<font color="#E5E5E5"> it takes</font><font color="#CCCCCC"> a you know a</font>

918
00:42:30,320 --> 00:42:36,800
half a second at least to do their demo

919
00:42:32,960 --> 00:42:39,380
which is a<font color="#CCCCCC"> wrapper for gdi+ now if</font><font color="#E5E5E5"> we</font>

920
00:42:36,800 --> 00:42:41,900
enable persistence mode then we get a

921
00:42:39,380 --> 00:42:43,940
much healthier 72 executions a second

922
00:42:41,900 --> 00:42:46,670
and that kind of tops out somewhere

923
00:42:43,940 --> 00:42:48,200
around a thousand iterations just over

924
00:42:46,670 --> 00:42:50,240
100 executions a second so this<font color="#E5E5E5"> is good</font>

925
00:42:48,200 --> 00:42:52,790
performance it's not quite where we're

926
00:42:50,240 --> 00:42:55,310
at on the<font color="#CCCCCC"> Linux side with being able to</font>

927
00:42:52,790 --> 00:42:57,740
do source instrumentation which might be

928
00:42:55,310 --> 00:43:00,250
triple or you know up<font color="#CCCCCC"> to five times</font><font color="#E5E5E5"> that</font>

929
00:42:57,740 --> 00:43:02,660
speed or so but it is quite<font color="#E5E5E5"> good and</font>

930
00:43:00,250 --> 00:43:04,970
really<font color="#E5E5E5"> just the key</font><font color="#CCCCCC"> takeaway here is</font>

931
00:43:02,660 --> 00:43:09,680
that persistence is the<font color="#E5E5E5"> key particularly</font>

932
00:43:04,970 --> 00:43:11,629
if you're using BB<font color="#E5E5E5"> I so where did we go</font>

933
00:43:09,680 --> 00:43:14,540
with this well we use our Intel PT

934
00:43:11,630 --> 00:43:19,820
driver I wrote some code to<font color="#CCCCCC"> wrap that</font>

935
00:43:14,540 --> 00:43:21,350
inside of<font color="#CCCCCC"> a FL and initially we have all</font>

936
00:43:19,820 --> 00:43:24,050
these problems<font color="#E5E5E5"> that we</font><font color="#CCCCCC"> have to solve the</font>

937
00:43:21,350 --> 00:43:25,910
block<font color="#E5E5E5"> IDs aren't available so I had to</font>

938
00:43:24,050 --> 00:43:27,860
figure<font color="#E5E5E5"> out a way to you know</font><font color="#CCCCCC"> obviously</font>

939
00:43:25,910 --> 00:43:29,839
it's a disassembled online and then

940
00:43:27,860 --> 00:43:32,120
build your own cash for<font color="#E5E5E5"> those branch</font>

941
00:43:29,840 --> 00:43:36,830
targets to do it efficiently and then

942
00:43:32,120 --> 00:43:39,350
ideally say that out to disk we you know

943
00:43:36,830 --> 00:43:41,950
the larger<font color="#E5E5E5"> the file is the log file</font>

944
00:43:39,350 --> 00:43:44,930
obviously it takes a<font color="#E5E5E5"> while to do that</font>

945
00:43:41,950 --> 00:43:48,710
parsing so we want<font color="#E5E5E5"> to limit the amount</font>

946
00:43:44,930 --> 00:43:50,629
of parsing Lee need to do previously the

947
00:43:48,710 --> 00:43:52,550
<font color="#CCCCCC">third point said that said that</font>

948
00:43:50,630 --> 00:43:55,180
persistence wasn't implemented yet but

949
00:43:52,550 --> 00:43:59,990
that's the new big feature as of today

950
00:43:55,180 --> 00:44:02,000
and we can limit<font color="#E5E5E5"> our the code</font><font color="#CCCCCC"> that we're</font>

951
00:43:59,990 --> 00:44:03,709
tracing down to<font color="#E5E5E5"> the four ranges that are</font>

952
00:44:02,000 --> 00:44:07,130
available supported by the hardware

953
00:44:03,710 --> 00:44:09,380
engine so so the<font color="#E5E5E5"> current at current</font>

954
00:44:07,130 --> 00:44:12,440
status is now we accurately decode the

955
00:44:09,380 --> 00:44:15,350
full trace the take an IP packet of

956
00:44:12,440 --> 00:44:16,430
course hold the target address and we

957
00:44:15,350 --> 00:44:19,220
get that<font color="#E5E5E5"> for the indirect branches in</font>

958
00:44:16,430 --> 00:44:21,649
return we disassemble you taken not

959
00:44:19,220 --> 00:44:25,609
taken packets and have a branch cache

960
00:44:21,650 --> 00:44:26,930
and then of<font color="#CCCCCC"> course we use that we have</font>

961
00:44:25,610 --> 00:44:29,000
to come up with our own little<font color="#E5E5E5"> way to</font>

962
00:44:26,930 --> 00:44:30,710
encode it into the bloom filter since we

963
00:44:29,000 --> 00:44:34,340
have full addresses and<font color="#E5E5E5"> not block IDs</font>

964
00:44:30,710 --> 00:44:36,810
<font color="#CCCCCC">but that's fairly simple and of course</font>

965
00:44:34,340 --> 00:44:38,340
since we don't have fort we need to

966
00:44:36,810 --> 00:44:40,460
use<font color="#CCCCCC"> create process and wait for single</font>

967
00:44:38,340 --> 00:44:42,870
object just like you normally would I

968
00:44:40,460 --> 00:44:46,620
did do some research we did try<font color="#CCCCCC"> to</font>

969
00:44:42,870 --> 00:44:50,279
implement native windows fork using some

970
00:44:46,620 --> 00:44:53,100
undocumented<font color="#CCCCCC"> ap</font><font color="#E5E5E5"> is called NCR RTL</font>

971
00:44:50,280 --> 00:44:55,290
colonias or process and went down that

972
00:44:53,100 --> 00:44:58,890
path we got it working the only problem

973
00:44:55,290 --> 00:45:01,980
is these are NT subsystem api's and are

974
00:44:58,890 --> 00:45:03,900
not aware of the win32 subsystem so

975
00:45:01,980 --> 00:45:08,100
basically anything that links against

976
00:45:03,900 --> 00:45:10,260
user32 and CS RSS is not aware that your

977
00:45:08,100 --> 00:45:11,549
process exists and so it was kind of a

978
00:45:10,260 --> 00:45:14,370
chicken<font color="#E5E5E5"> and the egg thing we could</font>

979
00:45:11,550 --> 00:45:16,770
compile library is especially not to

980
00:45:14,370 --> 00:45:18,690
link against user32 and do that<font color="#CCCCCC"> and have</font>

981
00:45:16,770 --> 00:45:21,840
fast forking and that was all great on

982
00:45:18,690 --> 00:45:24,180
our own wrapper<font color="#E5E5E5"> but the default compile</font>

983
00:45:21,840 --> 00:45:26,010
flags for visual studio the ones that

984
00:45:24,180 --> 00:45:28,950
all software are going to use<font color="#E5E5E5"> that you</font>

985
00:45:26,010 --> 00:45:30,690
will see<font color="#E5E5E5"> I mean you'd be lucky to find</font>

986
00:45:28,950 --> 00:45:33,600
any program out that it doesn't like to

987
00:45:30,690 --> 00:45:35,700
use a 32 so unfortunately that ended up

988
00:45:33,600 --> 00:45:37,380
<font color="#E5E5E5">being</font><font color="#CCCCCC"> a fun little journey down a rabbit</font>

989
00:45:35,700 --> 00:45:41,850
hole again that didn't pay off but it

990
00:45:37,380 --> 00:45:43,080
was interesting<font color="#E5E5E5"> research but so so</font>

991
00:45:41,850 --> 00:45:46,140
previously<font color="#E5E5E5"> I was comparing my</font>

992
00:45:43,080 --> 00:45:48,330
performance iterating each time creating

993
00:45:46,140 --> 00:45:49,500
new process and puzzling against it and

994
00:45:48,330 --> 00:45:51,960
<font color="#E5E5E5">I'll show you those numbers</font><font color="#CCCCCC"> in a second</font>

995
00:45:49,500 --> 00:45:55,350
but<font color="#E5E5E5"> as of</font><font color="#CCCCCC"> today the native persistence</font>

996
00:45:51,960 --> 00:45:56,730
mode is now implemented I don't have<font color="#CCCCCC"> a</font>

997
00:45:55,350 --> 00:45:59,160
lot of slides and<font color="#E5E5E5"> describe this to you</font>

998
00:45:56,730 --> 00:46:01,260
so I'll<font color="#CCCCCC"> just kind</font><font color="#E5E5E5"> of do it verbally Alex</font>

999
00:45:59,160 --> 00:46:04,109
lioness do last year<font color="#E5E5E5"> at recon gave a</font>

1000
00:46:01,260 --> 00:46:05,940
talk on various modes of Windows hooking

1001
00:46:04,110 --> 00:46:07,740
<font color="#CCCCCC">that are built into</font><font color="#E5E5E5"> the system and one</font>

1002
00:46:05,940 --> 00:46:10,020
in<font color="#E5E5E5"> particular that's interesting and may</font>

1003
00:46:07,740 --> 00:46:13,160
now be on your radar as of the last week

1004
00:46:10,020 --> 00:46:15,540
or<font color="#E5E5E5"> two is application verifier dll hooks</font>

1005
00:46:13,160 --> 00:46:18,180
they're relevant again because some

1006
00:46:15,540 --> 00:46:19,830
cyber company out there thought that

1007
00:46:18,180 --> 00:46:22,710
<font color="#CCCCCC">they invented</font><font color="#E5E5E5"> some new malware technique</font>

1008
00:46:19,830 --> 00:46:24,690
or something but so now<font color="#E5E5E5"> I don't know I</font>

1009
00:46:22,710 --> 00:46:26,850
chose this<font color="#E5E5E5"> approach as opposed to just</font>

1010
00:46:24,690 --> 00:46:28,530
doing DLL injection because I figured

1011
00:46:26,850 --> 00:46:30,330
<font color="#E5E5E5">well</font><font color="#CCCCCC"> I want</font><font color="#E5E5E5"> to run this on systems that</font>

1012
00:46:28,530 --> 00:46:33,060
might also have anti-malware software

1013
00:46:30,330 --> 00:46:35,490
running didn't want to cause issues and

1014
00:46:33,060 --> 00:46:37,410
flag with that so I<font color="#E5E5E5"> figured</font><font color="#CCCCCC"> ok if you're</font>

1015
00:46:35,490 --> 00:46:39,299
going<font color="#CCCCCC"> to use something like page heap</font>

1016
00:46:37,410 --> 00:46:41,720
and<font color="#E5E5E5"> windows the way that it's utilized</font>

1017
00:46:39,300 --> 00:46:43,890
is via application<font color="#CCCCCC"> verifier</font>

1018
00:46:41,720 --> 00:46:45,720
infrastructure<font color="#E5E5E5"> and so I was like</font>

1019
00:46:43,890 --> 00:46:47,250
thinking<font color="#E5E5E5"> that would</font><font color="#CCCCCC"> be a great system</font>

1020
00:46:45,720 --> 00:46:48,959
supported undocumented<font color="#E5E5E5"> the system</font>

1021
00:46:47,250 --> 00:46:51,960
supported<font color="#E5E5E5"> API for</font>

1022
00:46:48,960 --> 00:46:55,020
doing DLL injection so that's what<font color="#CCCCCC"> it</font>

1023
00:46:51,960 --> 00:46:56,430
uses<font color="#E5E5E5"> it's pretty cool maybe I'll pull</font><font color="#CCCCCC"> up</font>

1024
00:46:55,020 --> 00:46:58,109
that code in the second but you can

1025
00:46:56,430 --> 00:47:00,240
define some structures that say I'm

1026
00:46:58,109 --> 00:47:02,819
<font color="#CCCCCC">interested in</font><font color="#E5E5E5"> hooking this export from</font>

1027
00:47:00,240 --> 00:47:04,529
this library and all you<font color="#E5E5E5"> got to do</font><font color="#CCCCCC"> is to</font>

1028
00:47:02,820 --> 00:47:07,109
find a couple<font color="#E5E5E5"> of structures and your</font>

1029
00:47:04,530 --> 00:47:10,109
hook function and it's done turns out

1030
00:47:07,109 --> 00:47:12,900
that and I<font color="#CCCCCC"> also needed to do raw hooking</font>

1031
00:47:10,109 --> 00:47:14,819
as well in order<font color="#E5E5E5"> to do like you know</font>

1032
00:47:12,900 --> 00:47:17,550
arbitrary function hooks and so on your

1033
00:47:14,820 --> 00:47:19,589
actual rapper hook and so I<font color="#CCCCCC"> ended up</font>

1034
00:47:17,550 --> 00:47:21,810
using<font color="#E5E5E5"> die storm X which was just</font>

1035
00:47:19,589 --> 00:47:25,589
released last summer by the author<font color="#CCCCCC"> add</font><font color="#E5E5E5"> I</font>

1036
00:47:21,810 --> 00:47:27,509
storm which is separately I've done some

1037
00:47:25,589 --> 00:47:29,910
<font color="#CCCCCC">research on various assembler engines</font>

1038
00:47:27,510 --> 00:47:31,680
and I storm is actually twice as fast as

1039
00:47:29,910 --> 00:47:33,299
capstone and more accurate it's the

1040
00:47:31,680 --> 00:47:36,720
fastest and most accurate disassembler

1041
00:47:33,300 --> 00:47:39,300
out there so that's<font color="#E5E5E5"> the 1i favor and</font>

1042
00:47:36,720 --> 00:47:41,700
then there needed to be an IPC channel

1043
00:47:39,300 --> 00:47:44,099
when you're doing the persistence mode

1044
00:47:41,700 --> 00:47:46,200
because now instead of just waiting<font color="#E5E5E5"> for</font>

1045
00:47:44,099 --> 00:47:49,290
a process<font color="#CCCCCC"> to</font><font color="#E5E5E5"> exit you need to be able to</font>

1046
00:47:46,200 --> 00:47:51,509
notify the buzzer that<font color="#CCCCCC"> okay</font><font color="#E5E5E5"> i did an</font>

1047
00:47:49,290 --> 00:47:53,070
iteration<font color="#CCCCCC"> i'm back to the wrapper</font>

1048
00:47:51,510 --> 00:47:54,810
function<font color="#E5E5E5"> i need a new input to</font><font color="#CCCCCC"> be</font>

1049
00:47:53,070 --> 00:47:57,270
<font color="#E5E5E5">generated so i can do it</font><font color="#CCCCCC"> again so</font>

1050
00:47:54,810 --> 00:48:00,060
there's a small little IPC mechanism

1051
00:47:57,270 --> 00:48:01,470
using named pipes as well and so what

1052
00:48:00,060 --> 00:48:03,599
does this all looks like so in order to

1053
00:48:01,470 --> 00:48:05,160
do some raw performance testing<font color="#CCCCCC"> i</font>

1054
00:48:03,599 --> 00:48:07,220
figured<font color="#E5E5E5"> the first thing</font><font color="#CCCCCC"> that we should</font>

1055
00:48:05,160 --> 00:48:11,129
do is figure out what would<font color="#CCCCCC"> be our</font>

1056
00:48:07,220 --> 00:48:13,500
create process in wait top ends before I

1057
00:48:11,130 --> 00:48:15,780
got to the<font color="#E5E5E5"> persistence side so in this</font>

1058
00:48:13,500 --> 00:48:19,200
particular demo the one that comes with

1059
00:48:15,780 --> 00:48:23,730
win AFL the gdi+ rapper<font color="#CCCCCC"> I was able to</font>

1060
00:48:19,200 --> 00:48:25,589
only create 85 you know it or 85

1061
00:48:23,730 --> 00:48:30,210
processes the second is that we're

1062
00:48:25,589 --> 00:48:31,859
loading and parsley<font color="#E5E5E5"> file that's without</font>

1063
00:48:30,210 --> 00:48:33,570
tracing whatsoever that's literally just

1064
00:48:31,859 --> 00:48:35,880
a tight loop createprocess wait for

1065
00:48:33,570 --> 00:48:39,810
single object<font color="#CCCCCC"> parsad bitmap file using</font>

1066
00:48:35,880 --> 00:48:42,420
the gdi+<font color="#CCCCCC"> API the two</font><font color="#E5E5E5"> API calls so then I</font>

1067
00:48:39,810 --> 00:48:46,259
enabled the<font color="#E5E5E5"> Intel processor trace</font>

1068
00:48:42,420 --> 00:48:48,780
without logging the output just to see

1069
00:48:46,260 --> 00:48:50,730
<font color="#CCCCCC">okay what is the runtime hit that we're</font>

1070
00:48:48,780 --> 00:48:52,349
<font color="#CCCCCC">getting here the docs say</font><font color="#E5E5E5"> they</font><font color="#CCCCCC"> should be</font>

1071
00:48:50,730 --> 00:48:53,970
about fifteen percent is<font color="#CCCCCC"> that what we're</font>

1072
00:48:52,349 --> 00:48:55,950
seeing so yes in fact it was<font color="#E5E5E5"> almost</font>

1073
00:48:53,970 --> 00:48:58,379
exactly<font color="#E5E5E5"> fifteen percent so we went from</font>

1074
00:48:55,950 --> 00:49:02,279
85 down to 72 executions a second

1075
00:48:58,380 --> 00:49:05,220
<font color="#E5E5E5">alright so then we add in the part</font>

1076
00:49:02,280 --> 00:49:08,070
thing of<font color="#E5E5E5"> that log file with you know the</font>

1077
00:49:05,220 --> 00:49:09,359
binary logging and we're down<font color="#CCCCCC"> to 55</font>

1078
00:49:08,070 --> 00:49:11,580
executions a second which was another

1079
00:49:09,360 --> 00:49:14,700
twenty two percent parsing overhead so

1080
00:49:11,580 --> 00:49:17,759
in sum we hit about thirty-five percent

1081
00:49:14,700 --> 00:49:19,980
overhead on doing the Intel processor

1082
00:49:17,760 --> 00:49:23,480
trace tracing and starting any process

1083
00:49:19,980 --> 00:49:32,480
each time which turned out to be

1084
00:49:23,480 --> 00:49:34,590
slightly slower than the win AFL version

1085
00:49:32,480 --> 00:49:37,560
which I used to have in this slide but

1086
00:49:34,590 --> 00:49:39,740
it got moved<font color="#E5E5E5"> out</font><font color="#CCCCCC"> of here but basically</font>

1087
00:49:37,560 --> 00:49:42,210
<font color="#E5E5E5">they were they were hitting closer to</font>

1088
00:49:39,740 --> 00:49:45,120
like 80 executions a second and<font color="#E5E5E5"> I was</font>

1089
00:49:42,210 --> 00:49:48,960
getting 55 so that's where basically the

1090
00:49:45,120 --> 00:49:50,490
the talk was ending you know last<font color="#E5E5E5"> time I</font>

1091
00:49:48,960 --> 00:49:52,320
gave it except there are some gotchas

1092
00:49:50,490 --> 00:49:54,629
because dynamo Rio has a variable

1093
00:49:52,320 --> 00:49:58,530
performance depending on<font color="#E5E5E5"> how much code</font>

1094
00:49:54,630 --> 00:50:00,330
ass is disassembled and and what it

1095
00:49:58,530 --> 00:50:03,120
takes to bring that<font color="#E5E5E5"> process online under</font>

1096
00:50:00,330 --> 00:50:05,640
the<font color="#CCCCCC"> dbi whereas intel PT has</font><font color="#E5E5E5"> a reliable</font>

1097
00:50:03,120 --> 00:50:07,799
fifteen percent to code overhead so<font color="#CCCCCC"> I</font>

1098
00:50:05,640 --> 00:50:10,790
decided<font color="#CCCCCC"> okay well they use a gdi+ rapper</font>

1099
00:50:07,800 --> 00:50:14,520
why don't<font color="#CCCCCC"> I use lib PNG or something and</font>

1100
00:50:10,790 --> 00:50:17,400
naively just wrote a simple PNG parser I

1101
00:50:14,520 --> 00:50:20,190
was like what the hell this went down to

1102
00:50:17,400 --> 00:50:22,140
half an execution a second versus what i

1103
00:50:20,190 --> 00:50:24,720
was getting with<font color="#E5E5E5"> intel PT which was like</font>

1104
00:50:22,140 --> 00:50:26,759
60 for executions a second and that

1105
00:50:24,720 --> 00:50:28,589
seemed weird so I<font color="#CCCCCC"> ping dive in and I'm</font>

1106
00:50:26,760 --> 00:50:30,080
<font color="#CCCCCC">like hey that doesn't seem right that's</font>

1107
00:50:28,590 --> 00:50:31,920
a<font color="#E5E5E5"> hundred times performance difference</font>

1108
00:50:30,080 --> 00:50:33,270
well it<font color="#CCCCCC"> turns out there's a lot of</font>

1109
00:50:31,920 --> 00:50:35,340
gotchas when you use something<font color="#CCCCCC"> like</font>

1110
00:50:33,270 --> 00:50:36,780
dynamo<font color="#CCCCCC"> Rio this turned out to be an</font>

1111
00:50:35,340 --> 00:50:40,230
issue with<font color="#E5E5E5"> vile descriptor management</font>

1112
00:50:36,780 --> 00:50:41,940
where and windows file management is a

1113
00:50:40,230 --> 00:50:43,350
pain in the ass<font color="#E5E5E5"> but long story short</font>

1114
00:50:41,940 --> 00:50:45,720
that's not an accurate representation

1115
00:50:43,350 --> 00:50:48,569
once<font color="#E5E5E5"> I modified some stuff a little bit</font>

1116
00:50:45,720 --> 00:50:50,279
they were back on par so it was<font color="#CCCCCC"> up to me</font>

1117
00:50:48,570 --> 00:50:53,010
to say<font color="#CCCCCC"> alright</font><font color="#E5E5E5"> we're finally going to</font>

1118
00:50:50,280 --> 00:50:55,860
tackle<font color="#E5E5E5"> this persistence problem and so</font>

1119
00:50:53,010 --> 00:50:57,900
I'll demo that for you but what<font color="#E5E5E5"> we</font>

1120
00:50:55,860 --> 00:50:59,760
should see is we're now five times

1121
00:50:57,900 --> 00:51:02,790
faster than the<font color="#CCCCCC"> current version of</font>

1122
00:50:59,760 --> 00:51:05,430
winning FL so if the demo gods are with

1123
00:51:02,790 --> 00:51:09,150
me on this one<font color="#E5E5E5"> we'll at least get to see</font>

1124
00:51:05,430 --> 00:51:12,049
that so first let me show<font color="#E5E5E5"> the dynamo</font>

1125
00:51:09,150 --> 00:51:12,050
real version

1126
00:51:17,430 --> 00:51:20,970
<font color="#E5E5E5">alright this one</font>

1127
00:51:27,000 --> 00:51:36,849
okay yes<font color="#CCCCCC"> okay so this is a live version</font>

1128
00:51:31,420 --> 00:51:38,500
of dynamo<font color="#E5E5E5"> Rio tracing the gdi+ and we're</font>

1129
00:51:36,849 --> 00:51:40,570
seeing this will climb a little<font color="#CCCCCC"> bit</font><font color="#E5E5E5"> over</font>

1130
00:51:38,500 --> 00:51:42,550
time<font color="#E5E5E5"> as things that the cash gets hot</font>

1131
00:51:40,570 --> 00:51:45,579
and so on I think this actually<font color="#E5E5E5"> does top</font>

1132
00:51:42,550 --> 00:51:47,200
out closer to 65 or 70 but as you can

1133
00:51:45,579 --> 00:51:56,950
see pretty obviously the performance<font color="#CCCCCC"> is</font>

1134
00:51:47,200 --> 00:51:58,270
in that range and as of today some of

1135
00:51:56,950 --> 00:51:59,680
<font color="#CCCCCC">the changes that I had to put in</font><font color="#E5E5E5"> here</font>

1136
00:51:58,270 --> 00:52:04,869
that obviously screwed up some of<font color="#E5E5E5"> my</font>

1137
00:51:59,680 --> 00:52:07,660
other demos but yes so now we're<font color="#E5E5E5"> seeing</font>

1138
00:52:04,869 --> 00:52:10,599
that with live in<font color="#CCCCCC"> Intel BTW tracing</font>

1139
00:52:07,660 --> 00:52:13,690
using persistence mode in memory fuzzing

1140
00:52:10,599 --> 00:52:15,910
we have 230 this actually will get to

1141
00:52:13,690 --> 00:52:17,170
like 260 as well so<font color="#CCCCCC"> we've got like a</font>

1142
00:52:15,910 --> 00:52:19,149
five times performance increase so

1143
00:52:17,170 --> 00:52:21,220
that's the the main new thing here today

1144
00:52:19,150 --> 00:52:23,470
so the driver is open source right now

1145
00:52:21,220 --> 00:52:25,328
this code will be<font color="#E5E5E5"> open source soon and</font>

1146
00:52:23,470 --> 00:52:28,919
it will have advanced the performance

1147
00:52:25,329 --> 00:52:28,920
against windows binary by five times

1148
00:52:30,030 --> 00:52:37,030
yeah thanks so the conclusions takeaways

1149
00:52:34,869 --> 00:52:39,520
here trey songz<font color="#CCCCCC"> use and buzzing dynamic</font>

1150
00:52:37,030 --> 00:52:40,480
analysis we you know have all kinds<font color="#E5E5E5"> of</font>

1151
00:52:39,520 --> 00:52:42,640
applications for doing the branch

1152
00:52:40,480 --> 00:52:45,280
tracing my particular application today

1153
00:52:42,640 --> 00:52:47,078
is buzzing yours might<font color="#CCCCCC"> be doing mallar</font>

1154
00:52:45,280 --> 00:52:48,160
analysis across the billion or<font color="#E5E5E5"> I'm you</font>

1155
00:52:47,079 --> 00:52:52,050
know a million samples a day or

1156
00:52:48,160 --> 00:52:54,160
something it's definitely<font color="#CCCCCC"> a promising</font>

1157
00:52:52,050 --> 00:52:56,410
iteration in the hardware support of

1158
00:52:54,160 --> 00:52:58,779
tracing it's like 30 times faster than

1159
00:52:56,410 --> 00:53:01,720
the<font color="#E5E5E5"> previous</font><font color="#CCCCCC"> generation of supported</font>

1160
00:52:58,780 --> 00:53:03,220
tracing if not more which tells us the

1161
00:53:01,720 --> 00:53:06,009
<font color="#E5E5E5">Intel is actually dedicated to producing</font>

1162
00:53:03,220 --> 00:53:07,779
you know more interesting dedicated

1163
00:53:06,010 --> 00:53:11,079
silicon for doing things like<font color="#E5E5E5"> security</font>

1164
00:53:07,780 --> 00:53:13,240
<font color="#E5E5E5">analysis and so on my hope is that</font>

1165
00:53:11,079 --> 00:53:15,010
someday they will put some sort<font color="#CCCCCC"> of data</font>

1166
00:53:13,240 --> 00:53:16,750
flow tracing capability into the

1167
00:53:15,010 --> 00:53:18,520
<font color="#CCCCCC">processors so we can do things</font><font color="#E5E5E5"> like</font>

1168
00:53:16,750 --> 00:53:20,319
online paint tracing that<font color="#E5E5E5"> are efficient</font>

1169
00:53:18,520 --> 00:53:23,470
and so on<font color="#E5E5E5"> so we'll see</font><font color="#CCCCCC"> if we get there</font>

1170
00:53:20,319 --> 00:53:25,180
so the<font color="#E5E5E5"> to-do list number one we tried</font>

1171
00:53:23,470 --> 00:53:26,470
that we finished that doesn't work so

1172
00:53:25,180 --> 00:53:28,118
that's<font color="#E5E5E5"> not the</font><font color="#CCCCCC"> right way but the right</font>

1173
00:53:26,470 --> 00:53:30,790
way is probably using asynchronous

1174
00:53:28,119 --> 00:53:33,190
procedure calls which allow you<font color="#E5E5E5"> to</font>

1175
00:53:30,790 --> 00:53:36,339
preempt thread activation with your own

1176
00:53:33,190 --> 00:53:37,570
custom function if<font color="#CCCCCC"> I was</font><font color="#E5E5E5"> thinking</font><font color="#CCCCCC"> like a</font>

1177
00:53:36,339 --> 00:53:41,110
malware author I would

1178
00:53:37,570 --> 00:53:42,690
at first but i was<font color="#CCCCCC"> thinking like a like</font>

1179
00:53:41,110 --> 00:53:45,670
an antivirus author went the other way

1180
00:53:42,690 --> 00:53:48,190
so yeah that wasn't good the hypervisor

1181
00:53:45,670 --> 00:53:51,310
support on this as<font color="#CCCCCC"> i mentioned when your</font>

1182
00:53:48,190 --> 00:53:54,550
<font color="#CCCCCC">cpu is in vmx mode the hypervisor mode</font>

1183
00:53:51,310 --> 00:53:57,060
<font color="#E5E5E5">is supported now none of the hypervisor</font>

1184
00:53:54,550 --> 00:53:59,830
is currently<font color="#CCCCCC"> available then k vm</font>

1185
00:53:57,060 --> 00:54:03,340
virtualbox hyper-v<font color="#E5E5E5"> and none of</font><font color="#CCCCCC"> those</font>

1186
00:53:59,830 --> 00:54:07,450
support it at all only one of<font color="#E5E5E5"> those even</font>

1187
00:54:03,340 --> 00:54:09,070
supports the legacy BTS mechanism but

1188
00:54:07,450 --> 00:54:11,950
the good<font color="#CCCCCC"> news is my research partner</font>

1189
00:54:09,070 --> 00:54:13,960
<font color="#CCCCCC">andreia he actually has written a module</font>

1190
00:54:11,950 --> 00:54:16,109
it turns out that hyper-v is pluggable

1191
00:54:13,960 --> 00:54:18,820
he's going to be giving a<font color="#CCCCCC"> talk at recon</font>

1192
00:54:16,110 --> 00:54:21,280
just got accepted today that goes all

1193
00:54:18,820 --> 00:54:24,040
into the sub architecture of hyper-v and

1194
00:54:21,280 --> 00:54:26,290
he actually is<font color="#CCCCCC"> now got this working like</font>

1195
00:54:24,040 --> 00:54:27,970
last night so<font color="#CCCCCC"> that we can trace his</font>

1196
00:54:26,290 --> 00:54:29,830
guests from the hypervisor which is

1197
00:54:27,970 --> 00:54:32,980
great that was kind of the<font color="#E5E5E5"> last piece to</font>

1198
00:54:29,830 --> 00:54:36,940
scale this out so that will<font color="#E5E5E5"> be on your</font>

1199
00:54:32,980 --> 00:54:38,770
radar this<font color="#E5E5E5"> year we have heard</font><font color="#CCCCCC"> that smm</font>

1200
00:54:36,940 --> 00:54:41,950
code should be traceable with this as

1201
00:54:38,770 --> 00:54:43,840
<font color="#CCCCCC">well which is very intriguing however do</font>

1202
00:54:41,950 --> 00:54:45,990
like and some other guys says that it

1203
00:54:43,840 --> 00:54:48,960
might require<font color="#E5E5E5"> an Intel provided</font>

1204
00:54:45,990 --> 00:54:51,069
certificate so we may never get there oh

1205
00:54:48,960 --> 00:54:54,280
and the number<font color="#CCCCCC"> for I can</font><font color="#E5E5E5"> check that off</font>

1206
00:54:51,070 --> 00:54:58,810
the list here so that works now alright

1207
00:54:54,280 --> 00:55:00,550
so this code github /<font color="#E5E5E5"> Intel PT this talk</font>

1208
00:54:58,810 --> 00:55:03,340
and all the other talks related to it

1209
00:55:00,550 --> 00:55:05,770
<font color="#CCCCCC">are at mofo org you can reach me on</font>

1210
00:55:03,340 --> 00:55:08,650
<font color="#E5E5E5">Twitter rich in Seattle ondrea's the</font>

1211
00:55:05,770 --> 00:55:11,580
other one and thank<font color="#E5E5E5"> you for listening</font>

1212
00:55:08,650 --> 00:55:11,580
I'll take any questions

1213
00:55:14,520 --> 00:55:23,009
[Applause]

1214
00:55:17,750 --> 00:55:24,480
any questions from the floor<font color="#CCCCCC"> all maybe</font>

1215
00:55:23,010 --> 00:55:28,710
questions<font color="#CCCCCC"> off the</font><font color="#E5E5E5"> floor thank you very</font>

1216
00:55:24,480 --> 00:55:31,290
much richer yeah we're good<font color="#E5E5E5"> okay yeah no</font>

1217
00:55:28,710 --> 00:55:33,390
question thank you doing the<font color="#E5E5E5"> break thank</font>

1218
00:55:31,290 --> 00:55:35,400
you for so sorry about<font color="#CCCCCC"> that first demo</font>

1219
00:55:33,390 --> 00:55:38,279
if you I have the video<font color="#CCCCCC"> up from my talk</font>

1220
00:55:35,400 --> 00:55:40,380
<font color="#E5E5E5">is a cancer quest it has those demos</font>

1221
00:55:38,280 --> 00:55:41,490
available and since all those codes out

1222
00:55:40,380 --> 00:55:42,870
there I need to write a blog post that

1223
00:55:41,490 --> 00:55:44,609
<font color="#E5E5E5">will show you to do it I apologize</font>

1224
00:55:42,870 --> 00:55:46,859
clearly the drivers working with the

1225
00:55:44,610 --> 00:55:50,010
buzzer i modified it and fuck it up but

1226
00:55:46,860 --> 00:55:52,910
thanks again all right<font color="#CCCCCC"> thank you thank</font>

1227
00:55:50,010 --> 00:55:52,910
you very<font color="#E5E5E5"> much reaching</font>

