1
00:00:08,130 --> 00:00:15,820
hi<font color="#E5E5E5"> everyone thanks so</font><font color="#CCCCCC"> much</font><font color="#E5E5E5"> for coming to</font>

2
00:00:12,580 --> 00:00:17,920
this late end of the conference talk

3
00:00:15,820 --> 00:00:22,270
today<font color="#E5E5E5"> I'm going to talk about some</font>

4
00:00:17,920 --> 00:00:23,890
<font color="#E5E5E5">research I did into Microsoft edge I'm</font>

5
00:00:22,270 --> 00:00:25,509
Natalie<font color="#E5E5E5"> still van of it should i'm a</font>

6
00:00:23,890 --> 00:00:28,180
security researcher on Google's Project

7
00:00:25,509 --> 00:00:30,820
<font color="#E5E5E5">zero and you may remember for the last</font>

8
00:00:28,180 --> 00:00:33,399
<font color="#E5E5E5">year or two I've been looking at flash</font>

9
00:00:30,820 --> 00:00:34,899
and found a lot<font color="#E5E5E5"> of bugs there well</font>

10
00:00:33,399 --> 00:00:37,390
recently I've started looking at

11
00:00:34,899 --> 00:00:40,270
browsers and trying to see if i can find

12
00:00:37,390 --> 00:00:42,160
<font color="#E5E5E5">similar bugs today I want</font><font color="#CCCCCC"> to tell</font><font color="#E5E5E5"> you</font>

13
00:00:40,270 --> 00:00:47,230
<font color="#CCCCCC">what happened when i looked at Microsoft</font>

14
00:00:42,160 --> 00:00:49,870
edge so what<font color="#E5E5E5"> did I actually do I code</font>

15
00:00:47,230 --> 00:00:52,779
reviewed the<font color="#E5E5E5"> JavaScript engine of</font>

16
00:00:49,870 --> 00:00:54,790
Microsoft edge we seem to have<font color="#E5E5E5"> lost our</font>

17
00:00:52,780 --> 00:00:58,150
slides here but there was nothing too

18
00:00:54,790 --> 00:01:00,339
exciting on those ones anyhow so I

19
00:00:58,150 --> 00:01:03,519
reviewed the<font color="#E5E5E5"> JavaScript core of</font>

20
00:01:00,340 --> 00:01:06,009
Microsoft edge and I<font color="#E5E5E5"> found about 13 bugs</font>

21
00:01:03,520 --> 00:01:07,509
all of which are now fixed it was

22
00:01:06,009 --> 00:01:09,340
actually<font color="#E5E5E5"> the first time I've looked at a</font>

23
00:01:07,509 --> 00:01:11,250
browser in a long time for<font color="#E5E5E5"> about seven</font>

24
00:01:09,340 --> 00:01:14,500
or eight years and i discovered that

25
00:01:11,250 --> 00:01:15,850
javascript had changed a lot so<font color="#E5E5E5"> i want</font>

26
00:01:14,500 --> 00:01:18,159
<font color="#CCCCCC">to share with you what i learned about</font>

27
00:01:15,850 --> 00:01:20,470
javascript and how script engines are

28
00:01:18,159 --> 00:01:24,430
designed and how that impacts the type

29
00:01:20,470 --> 00:01:26,920
of bugs you can find in them so to start

30
00:01:24,430 --> 00:01:30,220
<font color="#CCCCCC">off I'm</font><font color="#E5E5E5"> going to talk a bit about what</font>

31
00:01:26,920 --> 00:01:32,380
edges what I'm chakra is and what<font color="#E5E5E5"> I como</font>

32
00:01:30,220 --> 00:01:34,658
script is then I'll go through some<font color="#CCCCCC"> of</font>

33
00:01:32,380 --> 00:01:36,460
the more interesting features<font color="#CCCCCC"> of</font>

34
00:01:34,659 --> 00:01:38,650
<font color="#E5E5E5">JavaScript and script engines and how</font>

35
00:01:36,460 --> 00:01:40,390
they're designed in chakra and finally

36
00:01:38,650 --> 00:01:44,860
I'll give you some examples of<font color="#CCCCCC"> some cool</font>

37
00:01:40,390 --> 00:01:47,470
bugs I found so to start<font color="#CCCCCC"> off what is</font>

38
00:01:44,860 --> 00:01:49,510
microsoft edge<font color="#E5E5E5"> microsoft edge is the new</font>

39
00:01:47,470 --> 00:01:53,170
internet explorer if the default browser

40
00:01:49,510 --> 00:01:56,020
on<font color="#CCCCCC"> Windows</font><font color="#E5E5E5"> 10 and chakra is edges</font>

41
00:01:53,170 --> 00:01:58,780
JavaScript engine it's open source you

42
00:01:56,020 --> 00:02:00,729
can<font color="#E5E5E5"> find it online on github and it's</font>

43
00:01:58,780 --> 00:02:02,229
constantly updated which is great you

44
00:02:00,729 --> 00:02:04,539
can<font color="#E5E5E5"> actually go through and look at</font>

45
00:02:02,229 --> 00:02:06,820
recent CBE that have been fixed<font color="#E5E5E5"> it even</font>

46
00:02:04,540 --> 00:02:08,319
accept external contributions just in

47
00:02:06,820 --> 00:02:11,230
case<font color="#CCCCCC"> you want to be the change you want</font>

48
00:02:08,318 --> 00:02:13,420
to see in Microsoft edge what is<font color="#CCCCCC"> echamos</font>

49
00:02:11,230 --> 00:02:15,369
script<font color="#CCCCCC"> echemus script is the</font><font color="#E5E5E5"> JavaScript</font>

50
00:02:13,420 --> 00:02:17,290
standard when a developer creates

51
00:02:15,370 --> 00:02:18,940
<font color="#CCCCCC">JavaScript engine equi script is the</font>

52
00:02:17,290 --> 00:02:22,329
<font color="#E5E5E5">standard they implement</font>

53
00:02:18,940 --> 00:02:24,280
and everyone always asked me why do you

54
00:02:22,330 --> 00:02:26,530
say<font color="#E5E5E5"> yakima script when you really mean</font>

55
00:02:24,280 --> 00:02:28,110
<font color="#E5E5E5">javascript and the reason is that</font>

56
00:02:26,530 --> 00:02:30,370
javascript is actually not<font color="#E5E5E5"> the only</font>

57
00:02:28,110 --> 00:02:32,860
implementation the other big player in

58
00:02:30,370 --> 00:02:34,540
the activist crypt world is action

59
00:02:32,860 --> 00:02:37,090
script which is what you write adobe

60
00:02:34,540 --> 00:02:39,970
flash will soon it and also QT script is

61
00:02:37,090 --> 00:02:41,650
also nekomet language so well most a

62
00:02:39,970 --> 00:02:43,630
javascript is probably most of the

63
00:02:41,650 --> 00:02:46,200
<font color="#CCCCCC">atmosphere implementations it's not the</font>

64
00:02:43,630 --> 00:02:47,980
only implementations by far and

65
00:02:46,200 --> 00:02:50,380
javascript is a constantly changing

66
00:02:47,980 --> 00:02:52,480
standard there's been<font color="#CCCCCC"> a lot at it in the</font>

67
00:02:50,380 --> 00:02:55,900
last couple of years and<font color="#E5E5E5"> they continue</font>

68
00:02:52,480 --> 00:02:57,010
<font color="#E5E5E5">to release new versions so now</font><font color="#CCCCCC"> i'm</font><font color="#E5E5E5"> going</font>

69
00:02:55,900 --> 00:02:59,400
<font color="#E5E5E5">to go through</font><font color="#CCCCCC"> some</font><font color="#E5E5E5"> of the more</font>

70
00:02:57,010 --> 00:03:01,959
interesting features of<font color="#E5E5E5"> javascript</font>

71
00:02:59,400 --> 00:03:05,050
starting with arrays I really is i think

72
00:03:01,960 --> 00:03:07,120
<font color="#E5E5E5">are one of the most important features</font>

73
00:03:05,050 --> 00:03:08,800
of javascript engine I think you know

74
00:03:07,120 --> 00:03:10,720
even<font color="#CCCCCC"> if you've only</font><font color="#E5E5E5"> been in</font><font color="#CCCCCC"> javascript</font>

75
00:03:08,800 --> 00:03:13,690
one you probably right use an array

76
00:03:10,720 --> 00:03:15,190
<font color="#CCCCCC">they're used very very commonly I what's</font>

77
00:03:13,690 --> 00:03:17,710
interesting about them is they seem

78
00:03:15,190 --> 00:03:20,500
extremely simple but they can get really

79
00:03:17,710 --> 00:03:23,230
complex really quickly so<font color="#CCCCCC"> to</font><font color="#E5E5E5"> start off</font>

80
00:03:20,500 --> 00:03:24,850
here are two arrays<font color="#CCCCCC"> um there's two ways</font>

81
00:03:23,230 --> 00:03:26,530
you can<font color="#E5E5E5"> create an array you</font><font color="#CCCCCC"> can use the</font>

82
00:03:24,850 --> 00:03:28,329
square bracket notation or you can<font color="#CCCCCC"> use</font>

83
00:03:26,530 --> 00:03:30,489
the constructor I like the square

84
00:03:28,330 --> 00:03:33,370
brackets but just so<font color="#CCCCCC"> you know what those</font>

85
00:03:30,489 --> 00:03:36,220
mean and these are very<font color="#E5E5E5"> simple arrays</font>

86
00:03:33,370 --> 00:03:38,590
they only have numbers in them and<font color="#E5E5E5"> I</font>

87
00:03:36,220 --> 00:03:40,600
would say most arrays using javascript

88
00:03:38,590 --> 00:03:43,030
are<font color="#CCCCCC"> raised like this they only have</font>

89
00:03:40,600 --> 00:03:45,100
members in them and<font color="#E5E5E5"> they're very simple</font>

90
00:03:43,030 --> 00:03:48,010
but there's<font color="#CCCCCC"> actually a lot more you</font><font color="#E5E5E5"> can</font>

91
00:03:45,100 --> 00:03:50,799
do<font color="#CCCCCC"> with arrays</font><font color="#E5E5E5"> so this next array has</font>

92
00:03:48,010 --> 00:03:52,450
strings in it still kind of basic you

93
00:03:50,800 --> 00:03:55,000
can also have mixed types in array so

94
00:03:52,450 --> 00:03:57,940
this already<font color="#E5E5E5"> has an integer</font><font color="#CCCCCC"> astraying an</font>

95
00:03:55,000 --> 00:04:00,250
<font color="#CCCCCC">object and even a regex pin it and then</font>

96
00:03:57,940 --> 00:04:02,230
next up we have an array of<font color="#E5E5E5"> arrays of</font>

97
00:04:00,250 --> 00:04:03,850
arrays and there is no limit how many

98
00:04:02,230 --> 00:04:05,738
times you can do this and you can<font color="#E5E5E5"> even</font>

99
00:04:03,850 --> 00:04:08,799
<font color="#E5E5E5">put a raise in themselves if you want</font>

100
00:04:05,739 --> 00:04:11,739
and then<font color="#CCCCCC"> last we have what is called a</font>

101
00:04:08,800 --> 00:04:14,200
sparse array and that means<font color="#E5E5E5"> that</font><font color="#CCCCCC"> as mr.</font>

102
00:04:11,739 --> 00:04:17,019
has missing elements so there<font color="#E5E5E5"> is the</font>

103
00:04:14,200 --> 00:04:19,988
array D which is one two three and then

104
00:04:17,019 --> 00:04:21,790
there's this element at index 10,000 and

105
00:04:19,988 --> 00:04:23,650
you can totally<font color="#CCCCCC"> do with that that with</font>

106
00:04:21,790 --> 00:04:26,260
arrays and this won't cause the memory

107
00:04:23,650 --> 00:04:27,880
generally to be allocated<font color="#CCCCCC"> and to the</font>

108
00:04:26,260 --> 00:04:30,070
terminology saying when you<font color="#E5E5E5"> look at a</font>

109
00:04:27,880 --> 00:04:32,830
sparse array the things that are empty

110
00:04:30,070 --> 00:04:37,110
between the first elements

111
00:04:32,830 --> 00:04:39,520
the last element are called holes so I

112
00:04:37,110 --> 00:04:42,160
regions<font color="#E5E5E5"> can get even more complex though</font>

113
00:04:39,520 --> 00:04:44,620
so not<font color="#CCCCCC"> only can</font><font color="#E5E5E5"> you have number indexes</font>

114
00:04:42,160 --> 00:04:47,920
you can also do array sub banana or

115
00:04:44,620 --> 00:04:49,810
array dot great and this is adding

116
00:04:47,920 --> 00:04:51,220
properties to the array and yes I'm

117
00:04:49,810 --> 00:04:52,840
regardless of whether you use the

118
00:04:51,220 --> 00:04:55,120
property notation or the subscript

119
00:04:52,840 --> 00:04:56,799
notation that does the same thing but<font color="#CCCCCC"> in</font>

120
00:04:55,120 --> 00:04:58,840
<font color="#CCCCCC">another complexity you can have a</font>

121
00:04:56,800 --> 00:05:01,570
property or in the Ray and<font color="#E5E5E5"> I'd say now</font>

122
00:04:58,840 --> 00:05:03,669
at this<font color="#E5E5E5"> point we're up to like most a</font>

123
00:05:01,570 --> 00:05:05,500
really really vast majority of arrays

124
00:05:03,670 --> 00:05:10,150
you see online and use just these

125
00:05:05,500 --> 00:05:12,070
features but it gets even crazier so you

126
00:05:10,150 --> 00:05:15,690
can also have configurations on arrays

127
00:05:12,070 --> 00:05:18,010
and that means you can make an array

128
00:05:15,690 --> 00:05:20,860
read only or you can even make a single

129
00:05:18,010 --> 00:05:22,810
element of an array read-only so for

130
00:05:20,860 --> 00:05:26,020
example<font color="#E5E5E5"> this first array the first</font>

131
00:05:22,810 --> 00:05:28,240
element element<font color="#CCCCCC"> 0 you can only read you</font>

132
00:05:26,020 --> 00:05:29,740
can't write<font color="#CCCCCC"> it and then another</font><font color="#E5E5E5"> thing</font>

133
00:05:28,240 --> 00:05:33,010
which i think is done a bit<font color="#E5E5E5"> more</font>

134
00:05:29,740 --> 00:05:35,050
commonly is there is this freeze

135
00:05:33,010 --> 00:05:37,570
function that will make the entire array

136
00:05:35,050 --> 00:05:38,710
read-only and you can't add any elements

137
00:05:37,570 --> 00:05:40,810
and then there's other similar things

138
00:05:38,710 --> 00:05:44,349
like object don't feel so that's another

139
00:05:40,810 --> 00:05:47,260
complexity but it<font color="#E5E5E5"> gets even weirder you</font>

140
00:05:44,350 --> 00:05:49,840
can also add getters or setters to array

141
00:05:47,260 --> 00:05:53,020
indexes so this array when you try to

142
00:05:49,840 --> 00:05:55,719
read or write property<font color="#CCCCCC"> 0 you will</font>

143
00:05:53,020 --> 00:05:57,820
execute code and for example<font color="#CCCCCC"> it together</font>

144
00:05:55,720 --> 00:06:00,190
that<font color="#CCCCCC"> code will return what you get back</font>

145
00:05:57,820 --> 00:06:02,409
<font color="#CCCCCC">from the array so I</font><font color="#E5E5E5"> don't think</font><font color="#CCCCCC"> this is</font>

146
00:06:00,190 --> 00:06:05,680
<font color="#E5E5E5">a very commonly used feature but every</font>

147
00:06:02,410 --> 00:06:08,170
single array has to support<font color="#E5E5E5"> it and then</font>

148
00:06:05,680 --> 00:06:10,810
<font color="#CCCCCC">finally you can also have a ray</font>

149
00:06:08,170 --> 00:06:12,430
<font color="#E5E5E5">prototype and to explain what these do</font>

150
00:06:10,810 --> 00:06:15,400
if you<font color="#E5E5E5"> look at how the class hierarchy</font>

151
00:06:12,430 --> 00:06:17,290
and<font color="#E5E5E5"> JavaScript works you start off with</font>

152
00:06:15,400 --> 00:06:19,780
<font color="#CCCCCC">the basic object the array which is the</font>

153
00:06:17,290 --> 00:06:21,550
array object in this diagram but then it

154
00:06:19,780 --> 00:06:22,869
has a<font color="#E5E5E5"> super class and a super super</font>

155
00:06:21,550 --> 00:06:24,940
class and there's no limit to<font color="#CCCCCC"> how many</font>

156
00:06:22,870 --> 00:06:26,680
times you can do this so to<font color="#E5E5E5"> start off</font>

157
00:06:24,940 --> 00:06:29,590
you have the proto object which gives it

158
00:06:26,680 --> 00:06:32,350
<font color="#E5E5E5">the array class and this is where the</font>

159
00:06:29,590 --> 00:06:34,780
array methods you typically call on an

160
00:06:32,350 --> 00:06:37,840
array are things like slice things like

161
00:06:34,780 --> 00:06:39,909
index of but then an array is also an

162
00:06:37,840 --> 00:06:42,760
object that's the<font color="#CCCCCC"> superclass so you also</font>

163
00:06:39,910 --> 00:06:44,230
have the array has a proto to object and

164
00:06:42,760 --> 00:06:46,700
then that gives you all the typical

165
00:06:44,230 --> 00:06:49,610
object features like two strings

166
00:06:46,700 --> 00:06:53,750
but what's even weirder here is let's

167
00:06:49,610 --> 00:06:56,960
say you have an object with a prototype

168
00:06:53,750 --> 00:07:00,110
that<font color="#CCCCCC"> prototype can also have elements in</font>

169
00:06:56,960 --> 00:07:02,539
it and the elements can be as crazy as

170
00:07:00,110 --> 00:07:05,030
the<font color="#CCCCCC"> elements in</font><font color="#E5E5E5"> the array itself so</font>

171
00:07:02,540 --> 00:07:07,940
let's<font color="#E5E5E5"> say</font><font color="#CCCCCC"> we have this amber array a</font><font color="#E5E5E5"> and</font>

172
00:07:05,030 --> 00:07:10,369
then we're missing<font color="#CCCCCC"> elements</font><font color="#E5E5E5"> element 3</font>

173
00:07:07,940 --> 00:07:14,930
element 3 as a whole but then the

174
00:07:10,370 --> 00:07:18,350
prototype has element 3<font color="#E5E5E5"> defined for</font>

175
00:07:14,930 --> 00:07:19,730
<font color="#E5E5E5">example this one then if you access I</font>

176
00:07:18,350 --> 00:07:21,800
wanted<font color="#E5E5E5"> three of that array it will</font>

177
00:07:19,730 --> 00:07:24,740
actually go up<font color="#E5E5E5"> there proto chain as far</font>

178
00:07:21,800 --> 00:07:26,630
as<font color="#CCCCCC"> it needs to and</font><font color="#E5E5E5"> then get the element</font>

179
00:07:24,740 --> 00:07:28,820
from there so I mean<font color="#CCCCCC"> that's pretty</font><font color="#E5E5E5"> weird</font>

180
00:07:26,630 --> 00:07:31,280
and then also you know it could be a

181
00:07:28,820 --> 00:07:33,440
getter setter it could be read-only it

182
00:07:31,280 --> 00:07:37,340
could be a banana it could be anything

183
00:07:33,440 --> 00:07:39,440
which is<font color="#E5E5E5"> interesting so I'm the other</font>

184
00:07:37,340 --> 00:07:41,060
thing to realize is that all these

185
00:07:39,440 --> 00:07:42,650
different types<font color="#CCCCCC"> of an array all the</font>

186
00:07:41,060 --> 00:07:44,240
basic array properties have to work on

187
00:07:42,650 --> 00:07:47,030
them you have to be able to slice them

188
00:07:44,240 --> 00:07:50,690
correctly yes be able to slice sword etc

189
00:07:47,030 --> 00:07:52,820
no matter how weird your array guess so

190
00:07:50,690 --> 00:07:56,270
this is<font color="#E5E5E5"> the challenge of script engine</font>

191
00:07:52,820 --> 00:07:58,700
designer the reality<font color="#E5E5E5"> is most arrays are</font>

192
00:07:56,270 --> 00:08:01,130
very<font color="#E5E5E5"> simple most arrays have only</font>

193
00:07:58,700 --> 00:08:04,010
integers and even after<font color="#CCCCCC"> that most of</font>

194
00:08:01,130 --> 00:08:05,180
them only have simple properties except

195
00:08:04,010 --> 00:08:07,670
there's all these out there features

196
00:08:05,180 --> 00:08:10,040
that could be used at any time so you

197
00:08:07,670 --> 00:08:12,530
end up getting is<font color="#E5E5E5"> that every modern</font>

198
00:08:10,040 --> 00:08:14,450
browser has multiple memory layouts for

199
00:08:12,530 --> 00:08:16,460
an array and then they transition

200
00:08:14,450 --> 00:08:19,159
through the different types of array so

201
00:08:16,460 --> 00:08:21,289
it's needed so here's how it works in

202
00:08:19,160 --> 00:08:24,470
chakra you started off with<font color="#CCCCCC"> the simple</font>

203
00:08:21,290 --> 00:08:27,110
array which is an integer array and then

204
00:08:24,470 --> 00:08:29,570
as<font color="#CCCCCC"> soon as you add a float to it it</font>

205
00:08:27,110 --> 00:08:32,030
becomes a float array and this is twice

206
00:08:29,570 --> 00:08:33,860
<font color="#E5E5E5">as big because floats or twice as</font>

207
00:08:32,030 --> 00:08:37,280
because in today's and these<font color="#CCCCCC"> are still</font>

208
00:08:33,860 --> 00:08:39,289
in contiguous memory and then let's say

209
00:08:37,280 --> 00:08:41,978
you add an object to<font color="#E5E5E5"> it or a string to</font>

210
00:08:39,289 --> 00:08:44,660
it then it becomes a bar array and

211
00:08:41,979 --> 00:08:46,460
that's<font color="#E5E5E5"> the same size as a double array</font>

212
00:08:44,660 --> 00:08:48,439
except it's an array is an array of

213
00:08:46,460 --> 00:08:49,850
pointers and then the pointers are to

214
00:08:48,440 --> 00:08:51,590
each element even if it's an integer

215
00:08:49,850 --> 00:08:54,410
it's now a pointer to an integer and

216
00:08:51,590 --> 00:08:57,230
that allows this<font color="#E5E5E5"> a rage now have objects</font>

217
00:08:54,410 --> 00:08:59,100
in it now this<font color="#CCCCCC"> is most arrays but now</font>

218
00:08:57,230 --> 00:09:00,600
<font color="#E5E5E5">let's say you can figure this array</font>

219
00:08:59,100 --> 00:09:02,970
you make it<font color="#E5E5E5"> so that a property is</font>

220
00:09:00,600 --> 00:09:05,730
read-only now it will become an ef5

221
00:09:02,970 --> 00:09:08,280
array and this is a dictionary array it

222
00:09:05,730 --> 00:09:09,780
is a hash table for<font color="#CCCCCC"> each element</font><font color="#E5E5E5"> and</font>

223
00:09:08,280 --> 00:09:12,030
then that makes it so that there is

224
00:09:09,780 --> 00:09:14,010
pretty<font color="#E5E5E5"> much no limit to what you can put</font>

225
00:09:12,030 --> 00:09:16,290
<font color="#CCCCCC">in the array array at the expense that</font>

226
00:09:14,010 --> 00:09:17,939
<font color="#E5E5E5">it's no</font><font color="#CCCCCC"> longer contiguous so</font><font color="#E5E5E5"> anything</font>

227
00:09:16,290 --> 00:09:20,610
you run<font color="#CCCCCC"> on it will not be as efficient</font>

228
00:09:17,940 --> 00:09:26,460
<font color="#E5E5E5">as contiguous memory there goes that</font>

229
00:09:20,610 --> 00:09:28,770
excellent<font color="#E5E5E5"> screen saver again so um how</font>

230
00:09:26,460 --> 00:09:31,860
is<font color="#E5E5E5"> this actually implemented well in</font>

231
00:09:28,770 --> 00:09:34,199
chakras actually do vtable swapping so

232
00:09:31,860 --> 00:09:36,600
to start<font color="#CCCCCC"> off this is how an array is</font>

233
00:09:34,200 --> 00:09:38,430
late i would a memory in chakra it's

234
00:09:36,600 --> 00:09:39,660
actually a fairly elegant design because

235
00:09:38,430 --> 00:09:42,540
it makes it really easy to transition

236
00:09:39,660 --> 00:09:45,300
between sparse arrays and dense arrays

237
00:09:42,540 --> 00:09:48,449
<font color="#E5E5E5">so to start off you have an array and</font>

238
00:09:45,300 --> 00:09:50,790
this is an inter a and then<font color="#E5E5E5"> the array</font>

239
00:09:48,450 --> 00:09:52,590
elements are<font color="#CCCCCC"> in this array</font><font color="#E5E5E5"> segment and</font>

240
00:09:50,790 --> 00:09:53,969
this can be in line for a very<font color="#E5E5E5"> simple</font>

241
00:09:52,590 --> 00:09:56,580
array but then there's<font color="#E5E5E5"> just a pointer to</font>

242
00:09:53,970 --> 00:09:58,470
it<font color="#E5E5E5"> and then for</font><font color="#CCCCCC"> a dense array you'll</font>

243
00:09:56,580 --> 00:10:01,770
usually just have one of these where it

244
00:09:58,470 --> 00:10:03,810
starts and where it ends and then if

245
00:10:01,770 --> 00:10:05,640
it's if it's a sparse array then you'll

246
00:10:03,810 --> 00:10:07,319
add in something yet<font color="#E5E5E5"> next so you can</font>

247
00:10:05,640 --> 00:10:09,540
have as many segments as you want to

248
00:10:07,320 --> 00:10:13,380
have our<font color="#CCCCCC"> mint</font><font color="#E5E5E5"> to find anywhere</font><font color="#CCCCCC"> in the</font>

249
00:10:09,540 --> 00:10:15,480
array which is<font color="#CCCCCC"> values so am i smart a</font>

250
00:10:13,380 --> 00:10:18,060
dense array in chakra is pretty much

251
00:10:15,480 --> 00:10:20,130
just a very<font color="#E5E5E5"> small sparse array the only</font>

252
00:10:18,060 --> 00:10:21,510
way it becomes truly a sparse trulia

253
00:10:20,130 --> 00:10:26,640
dictionary is if you configure a

254
00:10:21,510 --> 00:10:28,439
property then it becomes a hash table so

255
00:10:26,640 --> 00:10:31,170
then what happens when you transition

256
00:10:28,440 --> 00:10:33,120
between these two to start off it will

257
00:10:31,170 --> 00:10:34,740
just swap out the<font color="#E5E5E5"> B table so that it now</font>

258
00:10:33,120 --> 00:10:37,110
point to the right B table for<font color="#CCCCCC"> the right</font>

259
00:10:34,740 --> 00:10:38,880
thing and then it will change each

260
00:10:37,110 --> 00:10:40,830
segment to be the right type<font color="#E5E5E5"> and then it</font>

261
00:10:38,880 --> 00:10:42,990
will change the elements this can

262
00:10:40,830 --> 00:10:44,910
realloc memory but it doesn't<font color="#E5E5E5"> have to</font>

263
00:10:42,990 --> 00:10:46,590
sometimes if<font color="#E5E5E5"> it's short enough it will</font>

264
00:10:44,910 --> 00:10:49,589
just have enough space in memory to

265
00:10:46,590 --> 00:10:52,560
transition directly and you can see<font color="#CCCCCC"> how</font>

266
00:10:49,590 --> 00:10:55,380
this could be<font color="#CCCCCC"> starting to be problematic</font>

267
00:10:52,560 --> 00:10:57,089
this is only safe at certain times your

268
00:10:55,380 --> 00:10:58,110
arrays can change a lot so yes be

269
00:10:57,090 --> 00:11:03,000
careful you don't make a lot of

270
00:10:58,110 --> 00:11:05,730
assumptions about how they work um so

271
00:11:03,000 --> 00:11:07,740
moving on another important element is

272
00:11:05,730 --> 00:11:10,770
objects and they're actually fairly

273
00:11:07,740 --> 00:11:12,480
similar to arrays them but<font color="#E5E5E5"> there we tend</font>

274
00:11:10,770 --> 00:11:13,829
<font color="#E5E5E5">to be optimized</font><font color="#CCCCCC"> for</font><font color="#E5E5E5"> properties</font>

275
00:11:12,480 --> 00:11:16,889
so when you create an array you're

276
00:11:13,829 --> 00:11:18,959
usually putting indexes<font color="#E5E5E5"> 123 in them</font><font color="#CCCCCC"> for</font>

277
00:11:16,889 --> 00:11:22,740
objects the hint of named properties in

278
00:11:18,959 --> 00:11:25,619
them but they have all the same features

279
00:11:22,740 --> 00:11:27,839
of an array you know they can<font color="#CCCCCC"> also have</font>

280
00:11:25,620 --> 00:11:30,350
indexes they can also have accessories

281
00:11:27,839 --> 00:11:32,579
they can have all this sort of stuff and

282
00:11:30,350 --> 00:11:35,970
they can also be some<font color="#E5E5E5"> exactly small</font>

283
00:11:32,579 --> 00:11:37,589
exotic object types in chakra one that

284
00:11:35,970 --> 00:11:41,459
was kind of<font color="#CCCCCC"> interesting is there's a</font>

285
00:11:37,589 --> 00:11:43,230
deferred type so in<font color="#CCCCCC"> JavaScript there's</font>

286
00:11:41,459 --> 00:11:45,569
lots of different<font color="#E5E5E5"> objects that need to</font>

287
00:11:43,230 --> 00:11:48,480
be<font color="#CCCCCC"> available at any time for example the</font>

288
00:11:45,570 --> 00:11:50,639
regex constructor at any time javascript

289
00:11:48,480 --> 00:11:54,000
could create a regex but it probably

290
00:11:50,639 --> 00:11:55,920
won't oppose<font color="#CCCCCC"> javascript doesn't so this</font>

291
00:11:54,000 --> 00:11:57,510
would take up a lot of memory accept

292
00:11:55,920 --> 00:11:59,639
them they have this deferred type so the

293
00:11:57,510 --> 00:12:01,649
<font color="#E5E5E5">first time you access this object then</font>

294
00:11:59,639 --> 00:12:05,100
it starts loading it in<font color="#E5E5E5"> memory and this</font>

295
00:12:01,649 --> 00:12:08,370
saves a lot of memory but adds a bit of

296
00:12:05,100 --> 00:12:10,110
complexity and<font color="#E5E5E5"> I would say what subject</font>

297
00:12:08,370 --> 00:12:12,810
in general or a bit less<font color="#CCCCCC"> like Pro and</font>

298
00:12:10,110 --> 00:12:14,610
just because in arrays arrays are often

299
00:12:12,810 --> 00:12:16,949
very large and they're optimized for

300
00:12:14,610 --> 00:12:18,569
being very large meanwhile it's very

301
00:12:16,949 --> 00:12:21,810
rare to see an object assay has more

302
00:12:18,569 --> 00:12:24,000
than 100 properties in it so here's how

303
00:12:21,810 --> 00:12:26,430
an object works once<font color="#E5E5E5"> again there's two</font>

304
00:12:24,000 --> 00:12:28,560
notations be there actually subtly

305
00:12:26,430 --> 00:12:30,870
different but it's not that<font color="#E5E5E5"> important I</font>

306
00:12:28,560 --> 00:12:32,399
usually<font color="#CCCCCC"> use the curly braces where it</font>

307
00:12:30,870 --> 00:12:35,880
shows the object<font color="#E5E5E5"> and what the properties</font>

308
00:12:32,399 --> 00:12:38,190
of the object is and notice with<font color="#E5E5E5"> an</font>

309
00:12:35,880 --> 00:12:41,880
object like with an array you<font color="#CCCCCC"> can do all</font>

310
00:12:38,190 --> 00:12:43,290
<font color="#CCCCCC">sorts of crazy stuff for example this is</font>

311
00:12:41,880 --> 00:12:45,899
a pretty basic one you've got<font color="#CCCCCC"> a month</font>

312
00:12:43,290 --> 00:12:48,510
and a day as properties but then you can

313
00:12:45,899 --> 00:12:50,610
<font color="#E5E5E5">make the properties of</font><font color="#CCCCCC"> the object</font>

314
00:12:48,510 --> 00:12:52,920
indexes so this<font color="#CCCCCC"> is actually</font><font color="#E5E5E5"> like an</font>

315
00:12:50,610 --> 00:12:56,010
array has something at one and<font color="#CCCCCC"> two and</font>

316
00:12:52,920 --> 00:12:58,349
like with it raised you can have objects

317
00:12:56,010 --> 00:13:00,089
with objects with objects and you can

318
00:12:58,350 --> 00:13:03,810
also freeze them you can make them read

319
00:13:00,089 --> 00:13:06,630
only that sort of thing now<font color="#CCCCCC"> here's kind</font>

320
00:13:03,810 --> 00:13:09,329
<font color="#E5E5E5">of a fun question let's say you have an</font>

321
00:13:06,630 --> 00:13:11,610
array and let's say you have an object

322
00:13:09,329 --> 00:13:13,380
and you strip the proto off the object

323
00:13:11,610 --> 00:13:15,839
so you can't<font color="#E5E5E5"> just call a method to see</font>

324
00:13:13,380 --> 00:13:18,600
which is which<font color="#E5E5E5"> and you can't call type</font>

325
00:13:15,839 --> 00:13:20,339
of and you can't call instance of how

326
00:13:18,600 --> 00:13:22,620
can you tell which is which based on the

327
00:13:20,339 --> 00:13:25,019
functionality and one thing you might

328
00:13:22,620 --> 00:13:25,640
say is oh well you could call something

329
00:13:25,019 --> 00:13:27,560
<font color="#E5E5E5">like spy</font>

330
00:13:25,640 --> 00:13:29,660
so on it and it would work on<font color="#E5E5E5"> the</font>

331
00:13:27,560 --> 00:13:32,479
Iranian not the object that's not true

332
00:13:29,660 --> 00:13:35,990
<font color="#E5E5E5">all the</font><font color="#CCCCCC"> array methods actually do work</font>

333
00:13:32,480 --> 00:13:37,550
on an object if you call call it on an

334
00:13:35,990 --> 00:13:39,560
object<font color="#E5E5E5"> that has the right indexes and</font>

335
00:13:37,550 --> 00:13:41,329
has a length and<font color="#E5E5E5"> that sort of thing so</font>

336
00:13:39,560 --> 00:13:44,089
um how<font color="#E5E5E5"> can you tell the difference</font>

337
00:13:41,330 --> 00:13:46,160
between these two as far as i can tell i

338
00:13:44,090 --> 00:13:48,860
can only think<font color="#CCCCCC"> of one way which is</font><font color="#E5E5E5"> you</font>

339
00:13:46,160 --> 00:13:50,600
set the lengths to banana and you can do

340
00:13:48,860 --> 00:13:52,520
that<font color="#CCCCCC"> on an object but if you do that on</font>

341
00:13:50,600 --> 00:13:57,230
our<font color="#E5E5E5"> way you'll get an exception thrown</font>

342
00:13:52,520 --> 00:14:01,520
and so<font color="#E5E5E5"> that's their shows you kind of</font>

343
00:13:57,230 --> 00:14:03,380
how fluid objects are in<font color="#CCCCCC"> javascript</font><font color="#E5E5E5"> you</font>

344
00:14:01,520 --> 00:14:05,030
know yes arrays are supposed to be used

345
00:14:03,380 --> 00:14:06,350
for<font color="#CCCCCC"> one thing and yes objects are</font>

346
00:14:05,030 --> 00:14:07,670
supposed to be used<font color="#E5E5E5"> for another thing</font>

347
00:14:06,350 --> 00:14:09,260
but you get to the point where you can

348
00:14:07,670 --> 00:14:11,089
actually like add so much stuff to both

349
00:14:09,260 --> 00:14:14,569
of them that it can actually be fairly

350
00:14:11,090 --> 00:14:16,670
hard to tell which is which so we end up

351
00:14:14,570 --> 00:14:18,650
getting in different script engines is

352
00:14:16,670 --> 00:14:21,469
what they call the<font color="#CCCCCC"> fastpass than what</font>

353
00:14:18,650 --> 00:14:23,569
they call a slow path and the<font color="#CCCCCC"> fastpass</font>

354
00:14:21,470 --> 00:14:25,610
tends to be when things are normal and

355
00:14:23,570 --> 00:14:26,750
there can be more than one and the

356
00:14:25,610 --> 00:14:29,030
developers kinda have to pick what

357
00:14:26,750 --> 00:14:30,740
normal is but that's like an optimized

358
00:14:29,030 --> 00:14:33,650
stay if you're doing something that's

359
00:14:30,740 --> 00:14:35,510
<font color="#E5E5E5">fairly common and fairly expected so an</font>

360
00:14:33,650 --> 00:14:37,430
example is you might have a fast pass

361
00:14:35,510 --> 00:14:39,620
for splicing in a<font color="#CCCCCC"> ray that is all</font>

362
00:14:37,430 --> 00:14:43,939
integers and that's very optimized

363
00:14:39,620 --> 00:14:45,680
because you know it's limited and these

364
00:14:43,940 --> 00:14:47,270
<font color="#CCCCCC">are</font><font color="#E5E5E5"> good but they can cause bugs because</font>

365
00:14:45,680 --> 00:14:49,640
<font color="#CCCCCC">when you're saying well are things</font>

366
00:14:47,270 --> 00:14:51,380
normal are they in an expected state you

367
00:14:49,640 --> 00:14:53,000
need to make<font color="#CCCCCC"> sure that ever you protect</font>

368
00:14:51,380 --> 00:14:55,070
everything that can be unexpected in the

369
00:14:53,000 --> 00:14:56,780
state<font color="#E5E5E5"> and there's so many things you can</font>

370
00:14:55,070 --> 00:15:02,660
do with JavaScript objects that can be

371
00:14:56,780 --> 00:15:04,760
<font color="#E5E5E5">really hard and the other thing</font><font color="#CCCCCC"> that the</font>

372
00:15:02,660 --> 00:15:07,130
opposite<font color="#E5E5E5"> of fast path is the slow path</font>

373
00:15:04,760 --> 00:15:08,840
and a slow path is the base case that is

374
00:15:07,130 --> 00:15:11,780
supposed to<font color="#E5E5E5"> be able to handle</font><font color="#CCCCCC"> everything</font>

375
00:15:08,840 --> 00:15:13,520
<font color="#CCCCCC">and he's tend to be a little safer than</font>

376
00:15:11,780 --> 00:15:16,189
fast path they don't have quite as many

377
00:15:13,520 --> 00:15:17,660
bugs in my opinion but<font color="#CCCCCC"> then once again</font>

378
00:15:16,190 --> 00:15:21,560
you're trying to write this thing that

379
00:15:17,660 --> 00:15:23,870
can you handle any case ever but does it

380
00:15:21,560 --> 00:15:25,400
<font color="#E5E5E5">you know you have to be</font><font color="#CCCCCC"> very sure you're</font>

381
00:15:23,870 --> 00:15:29,120
catching everything and sometimes they

382
00:15:25,400 --> 00:15:32,270
don't so now<font color="#E5E5E5"> I'm going through a couple</font>

383
00:15:29,120 --> 00:15:34,130
<font color="#E5E5E5">of more features and complex objects so</font>

384
00:15:32,270 --> 00:15:36,430
<font color="#CCCCCC">I've talked</font><font color="#E5E5E5"> about objects and I talked</font>

385
00:15:34,130 --> 00:15:38,930
about<font color="#E5E5E5"> arrays but</font><font color="#CCCCCC"> there can also be</font>

386
00:15:36,430 --> 00:15:39,729
special objects that are subclasses of

387
00:15:38,930 --> 00:15:42,579
<font color="#CCCCCC">objects</font>

388
00:15:39,730 --> 00:15:44,350
like a regex a math a function and these

389
00:15:42,579 --> 00:15:47,229
need<font color="#E5E5E5"> to</font><font color="#CCCCCC"> have a different memory backing</font>

390
00:15:44,350 --> 00:15:49,180
and see because<font color="#E5E5E5"> for example a regex</font>

391
00:15:47,230 --> 00:15:50,920
needs a place to keep the pattern and a

392
00:15:49,180 --> 00:15:54,459
function needs a place to put the

393
00:15:50,920 --> 00:15:56,769
pointer to the code and they can also be

394
00:15:54,459 --> 00:15:58,239
extended so<font color="#CCCCCC"> in JavaScript not only can</font>

395
00:15:56,769 --> 00:16:00,190
<font color="#CCCCCC">you create a class that extends the</font>

396
00:15:58,240 --> 00:16:02,829
class<font color="#CCCCCC"> you created you</font><font color="#E5E5E5"> can also create a</font>

397
00:16:00,190 --> 00:16:05,560
class that extends<font color="#CCCCCC"> the regex so this</font>

398
00:16:02,829 --> 00:16:08,019
means that typing becomes interesting in

399
00:16:05,560 --> 00:16:10,209
<font color="#CCCCCC">JavaScript if you think of how script</font>

400
00:16:08,019 --> 00:16:12,850
actually execute<font color="#CCCCCC"> so I'm fundamentally</font>

401
00:16:10,209 --> 00:16:14,800
every object is some type of handle and

402
00:16:12,850 --> 00:16:17,589
it's the handle you put on the stack<font color="#E5E5E5"> and</font>

403
00:16:14,800 --> 00:16:19,120
it's the handle you put in a function as

404
00:16:17,589 --> 00:16:21,459
a parameter and that's what's used for

405
00:16:19,120 --> 00:16:22,690
all sorts of<font color="#CCCCCC"> things and script needs to</font>

406
00:16:21,459 --> 00:16:24,729
differentiate between all these

407
00:16:22,690 --> 00:16:27,250
different<font color="#E5E5E5"> types because a function when</font>

408
00:16:24,730 --> 00:16:28,899
it pulls a parameter off the stacker out

409
00:16:27,250 --> 00:16:31,810
of the parameter array it doesn't know

410
00:16:28,899 --> 00:16:33,730
what type it is so chakra does this I'm

411
00:16:31,810 --> 00:16:35,709
kind of two different<font color="#E5E5E5"> ways to start off</font>

412
00:16:33,730 --> 00:16:38,350
there's the actual values of the handle

413
00:16:35,709 --> 00:16:40,800
<font color="#E5E5E5">and in chakra these can either be</font>

414
00:16:38,350 --> 00:16:44,380
integers or they can be pointers and

415
00:16:40,800 --> 00:16:46,300
this is differentiated by the 48 bit so

416
00:16:44,380 --> 00:16:48,370
to give an example if on<font color="#CCCCCC"> the stack</font>

417
00:16:46,300 --> 00:16:52,149
you're pushing into your<font color="#E5E5E5"> 7 it will be</font>

418
00:16:48,370 --> 00:16:53,860
this long 1007 and that has the<font color="#CCCCCC"> right</font>

419
00:16:52,149 --> 00:16:55,899
bit set to show that is an integer

420
00:16:53,860 --> 00:16:58,060
otherwise if it doesn't have<font color="#CCCCCC"> that set</font>

421
00:16:55,899 --> 00:16:59,620
it's a pointer so it could be<font color="#CCCCCC"> a pointer</font>

422
00:16:58,060 --> 00:17:01,869
to an<font color="#CCCCCC"> object or</font><font color="#E5E5E5"> it could be a pointer to</font>

423
00:16:59,620 --> 00:17:03,730
a regex and then send there's a second

424
00:17:01,870 --> 00:17:05,020
type check that happens let's say you

425
00:17:03,730 --> 00:17:07,809
need<font color="#CCCCCC"> to do</font><font color="#E5E5E5"> something that's</font><font color="#CCCCCC"> just on a</font>

426
00:17:05,020 --> 00:17:11,049
regex then that will have a field inside

427
00:17:07,809 --> 00:17:12,819
<font color="#CCCCCC">the object to tell the caller what it is</font>

428
00:17:11,049 --> 00:17:14,260
and that needs<font color="#E5E5E5"> to be manually checked in</font>

429
00:17:12,819 --> 00:17:17,290
the script engine every time you do

430
00:17:14,260 --> 00:17:19,179
something specific to that type so one

431
00:17:17,290 --> 00:17:21,129
more thing i'll talk about which i will

432
00:17:19,179 --> 00:17:23,020
<font color="#CCCCCC">say is fortunately not very interesting</font>

433
00:17:21,130 --> 00:17:25,089
in chakra which is garbage collection

434
00:17:23,020 --> 00:17:26,709
<font color="#E5E5E5">there definitely are engines where</font>

435
00:17:25,089 --> 00:17:29,530
garbage collection is a problem where

436
00:17:26,709 --> 00:17:31,740
stuff can be spurious leaf read but

437
00:17:29,530 --> 00:17:33,580
chakra tends not to have this problem

438
00:17:31,740 --> 00:17:35,110
the garbage collector is very

439
00:17:33,580 --> 00:17:37,809
conservative it does something called

440
00:17:35,110 --> 00:17:39,520
stack scanning so if you have a pointer

441
00:17:37,809 --> 00:17:41,020
on<font color="#CCCCCC"> the stack even if you don't</font><font color="#E5E5E5"> have</font>

442
00:17:39,520 --> 00:17:43,720
another handle to it it won't free it

443
00:17:41,020 --> 00:17:45,639
free it and there's also some excellent

444
00:17:43,720 --> 00:17:47,740
protection features<font color="#E5E5E5"> I'm such as delayed</font>

445
00:17:45,640 --> 00:17:52,120
free which makes things it's not<font color="#E5E5E5"> free</font>

446
00:17:47,740 --> 00:17:53,390
very often so and I'm not<font color="#E5E5E5"> joking here my</font>

447
00:17:52,120 --> 00:17:55,850
model for the chakra he

448
00:17:53,390 --> 00:17:57,560
is that<font color="#CCCCCC"> nothing is ever free and so far</font>

449
00:17:55,850 --> 00:18:01,280
it's been good enough for the purposes

450
00:17:57,560 --> 00:18:04,879
of this research so now moving on to

451
00:18:01,280 --> 00:18:07,639
some fun<font color="#E5E5E5"> and exciting bugs so I'm gonna</font>

452
00:18:04,880 --> 00:18:13,310
start<font color="#E5E5E5"> off with this one and this one is</font>

453
00:18:07,640 --> 00:18:17,600
due to the ability<font color="#E5E5E5"> to put</font><font color="#CCCCCC"> a the ability</font>

454
00:18:13,310 --> 00:18:19,669
to put getter on an array and it's in a

455
00:18:17,600 --> 00:18:20,899
<font color="#CCCCCC">raid join which is basically to</font>

456
00:18:19,670 --> 00:18:22,430
straighten for an array<font color="#E5E5E5"> it's something</font>

457
00:18:20,900 --> 00:18:25,610
that you put<font color="#E5E5E5"> an array in and it creates</font>

458
00:18:22,430 --> 00:18:27,460
a string so that you can print it so

459
00:18:25,610 --> 00:18:29,780
here is<font color="#CCCCCC"> a proof of concept</font><font color="#E5E5E5"> for this bag</font>

460
00:18:27,460 --> 00:18:34,070
you start off you create your new array

461
00:18:29,780 --> 00:18:37,340
and then you create this interceptor the

462
00:18:34,070 --> 00:18:40,700
scatter function on the array index and

463
00:18:37,340 --> 00:18:42,560
then this function adds an object<font color="#E5E5E5"> to the</font>

464
00:18:40,700 --> 00:18:45,800
array and then you call this joint

465
00:18:42,560 --> 00:18:47,480
function and this ends up causing an

466
00:18:45,800 --> 00:18:49,370
unexpected transition which is

467
00:18:47,480 --> 00:18:52,430
problematic and makes it into an info

468
00:18:49,370 --> 00:18:55,729
leak so if you look<font color="#E5E5E5"> at how the code is</font>

469
00:18:52,430 --> 00:18:59,630
implemented in chakra what happens here

470
00:18:55,730 --> 00:19:01,430
<font color="#CCCCCC">is</font><font color="#E5E5E5"> that when you join this ring when you</font>

471
00:18:59,630 --> 00:19:04,130
try and append convert everything to a

472
00:19:01,430 --> 00:19:05,420
string and append it it<font color="#E5E5E5"> will go through</font>

473
00:19:04,130 --> 00:19:08,300
the array length and then it will call

474
00:19:05,420 --> 00:19:10,130
this<font color="#E5E5E5"> tri templated get item and this is</font>

475
00:19:08,300 --> 00:19:13,700
the templated function that assumes the

476
00:19:10,130 --> 00:19:16,400
type and nosa type based on the array

477
00:19:13,700 --> 00:19:19,040
you pushed in unfortunately it doesn't

478
00:19:16,400 --> 00:19:21,260
handle array transitions properly so

479
00:19:19,040 --> 00:19:23,120
when it calls this function and get some

480
00:19:21,260 --> 00:19:24,200
one of the indexes in this case<font color="#E5E5E5"> to it</font>

481
00:19:23,120 --> 00:19:26,600
will actually call into this function

482
00:19:24,200 --> 00:19:28,370
which will<font color="#E5E5E5"> put an object into the array</font>

483
00:19:26,600 --> 00:19:31,340
and then change the type and causing

484
00:19:28,370 --> 00:19:33,020
info leak<font color="#CCCCCC"> Plus example how the ability</font>

485
00:19:31,340 --> 00:19:39,050
to put a getter on array can be

486
00:19:33,020 --> 00:19:41,000
problematic sorry this is a genuine at a

487
00:19:39,050 --> 00:19:44,510
conference keynote I have genuine<font color="#E5E5E5"> con</font>

488
00:19:41,000 --> 00:19:47,390
flew here so another beauty of another

489
00:19:44,510 --> 00:19:49,760
issue<font color="#CCCCCC"> due to get</font><font color="#E5E5E5"> her</font><font color="#CCCCCC"> on an array and</font>

490
00:19:47,390 --> 00:19:51,590
this time it's an overflow and it's kind

491
00:19:49,760 --> 00:19:53,420
of interesting and it's in a spread

492
00:19:51,590 --> 00:19:55,370
operator you can see the spread operator

493
00:19:53,420 --> 00:19:57,530
being called at the very bottom cube dot

494
00:19:55,370 --> 00:19:58,850
dot dot T and what this does is this

495
00:19:57,530 --> 00:20:01,820
makes an array into an argument

496
00:19:58,850 --> 00:20:04,550
parameter so if<font color="#E5E5E5"> I call queue with</font><font color="#CCCCCC"> Chi</font>

497
00:20:01,820 --> 00:20:06,800
when I get into Q the arguments of my

498
00:20:04,550 --> 00:20:09,260
call will be the threat will be

499
00:20:06,800 --> 00:20:11,419
the<font color="#E5E5E5"> elements</font><font color="#CCCCCC"> of that array so in this</font>

500
00:20:09,260 --> 00:20:16,879
case I create an array and then once

501
00:20:11,420 --> 00:20:18,830
again i added getter to it and on on

502
00:20:16,880 --> 00:20:22,280
index 3 and then<font color="#E5E5E5"> this changes the length</font>

503
00:20:18,830 --> 00:20:23,990
and then I call the spread operator and

504
00:20:22,280 --> 00:20:26,090
what happens here if you look<font color="#CCCCCC"> at</font><font color="#E5E5E5"> the</font>

505
00:20:23,990 --> 00:20:29,240
code they kind of try and check for this

506
00:20:26,090 --> 00:20:31,580
<font color="#CCCCCC">situation right up front they say are</font>

507
00:20:29,240 --> 00:20:33,470
the arguments that<font color="#E5E5E5"> I'm copying too big</font>

508
00:20:31,580 --> 00:20:36,230
for the array I'm copying them into and

509
00:20:33,470 --> 00:20:38,510
if so just<font color="#CCCCCC"> throw a fatal error that's</font>

510
00:20:36,230 --> 00:20:41,930
good but<font color="#CCCCCC"> you can change the situation</font>

511
00:20:38,510 --> 00:20:43,250
later so the gate length is actually

512
00:20:41,930 --> 00:20:45,080
safe that's guaranteed to be a number

513
00:20:43,250 --> 00:20:47,420
<font color="#E5E5E5">guaranteed not to be</font><font color="#CCCCCC"> together or a</font>

514
00:20:45,080 --> 00:20:50,060
setter but<font color="#E5E5E5"> when you get the item</font><font color="#CCCCCC"> that</font>

515
00:20:47,420 --> 00:20:52,100
can call a getter or a setter and then

516
00:20:50,060 --> 00:20:53,240
that<font color="#E5E5E5"> can change the array length so you</font>

517
00:20:52,100 --> 00:20:55,490
can see this is just<font color="#CCCCCC"> like a massive</font>

518
00:20:53,240 --> 00:20:58,100
overflow if you change the<font color="#E5E5E5"> array likes</font>

519
00:20:55,490 --> 00:21:02,860
to be very large then it were float your

520
00:20:58,100 --> 00:21:06,020
staff and that's the issue with this bug

521
00:21:02,860 --> 00:21:08,719
so here's another interesting bug and

522
00:21:06,020 --> 00:21:12,670
this is a segmentation issue so you know

523
00:21:08,720 --> 00:21:14,840
how you described the arrays as being a

524
00:21:12,670 --> 00:21:16,970
lots<font color="#E5E5E5"> of different segments if they're</font>

525
00:21:14,840 --> 00:21:18,949
sparse well you can imagine for certain

526
00:21:16,970 --> 00:21:20,840
functions in an array it becomes quite

527
00:21:18,950 --> 00:21:24,620
difficult<font color="#E5E5E5"> to implement when your arrays</font>

528
00:21:20,840 --> 00:21:28,189
are done that way so this issue is in

529
00:21:24,620 --> 00:21:30,530
the reverse function and you can imagine

530
00:21:28,190 --> 00:21:32,360
<font color="#E5E5E5">that reversing that sort of segmented</font>

531
00:21:30,530 --> 00:21:33,770
array could be quite challenging because

532
00:21:32,360 --> 00:21:35,570
you know<font color="#E5E5E5"> things from the last segment</font>

533
00:21:33,770 --> 00:21:37,940
need to go into<font color="#E5E5E5"> the first segment and</font>

534
00:21:35,570 --> 00:21:42,129
one of your<font color="#E5E5E5"> segments change I'm not a</font>

535
00:21:37,940 --> 00:21:44,810
lot of<font color="#E5E5E5"> fun so this is</font><font color="#CCCCCC"> a bug that</font>

536
00:21:42,130 --> 00:21:47,480
involves once again<font color="#E5E5E5"> an array interceptor</font>

537
00:21:44,810 --> 00:21:49,970
<font color="#CCCCCC">and</font><font color="#E5E5E5"> array getter and it basically</font>

538
00:21:47,480 --> 00:21:51,320
changes the length of an array and this

539
00:21:49,970 --> 00:21:52,640
one's a little bit of<font color="#CCCCCC"> a picky bug you</font>

540
00:21:51,320 --> 00:21:56,840
can see I had to do some like very

541
00:21:52,640 --> 00:21:59,450
specifically but<font color="#CCCCCC"> the basic is that your</font>

542
00:21:56,840 --> 00:22:03,110
array length is a thousand and that or

543
00:21:59,450 --> 00:22:05,420
<font color="#CCCCCC">you're and then you create the items the</font>

544
00:22:03,110 --> 00:22:07,189
access or on it then you call reverse

545
00:22:05,420 --> 00:22:08,930
and then the access or makes the array

546
00:22:07,190 --> 00:22:14,120
longer than it was<font color="#E5E5E5"> before that's the</font>

547
00:22:08,930 --> 00:22:16,370
interesting part so you can see where

548
00:22:14,120 --> 00:22:18,139
the<font color="#CCCCCC"> what the problem is here</font><font color="#E5E5E5"> you start</font>

549
00:22:16,370 --> 00:22:20,750
off by getting the length of the array

550
00:22:18,140 --> 00:22:22,190
and then this function

551
00:22:20,750 --> 00:22:24,170
reverse does something called feel from

552
00:22:22,190 --> 00:22:25,490
prototypes because you know<font color="#CCCCCC"> revive</font>

553
00:22:24,170 --> 00:22:27,380
reversing is already a bit of a

554
00:22:25,490 --> 00:22:29,240
nightmare and<font color="#CCCCCC"> it's even more of a</font>

555
00:22:27,380 --> 00:22:30,950
nightmare because<font color="#E5E5E5"> you have to realize</font>

556
00:22:29,240 --> 00:22:33,500
<font color="#CCCCCC">arrays</font><font color="#E5E5E5"> kind of prototypes that can also</font>

557
00:22:30,950 --> 00:22:35,660
have indexes in them<font color="#E5E5E5"> you can imagine if</font>

558
00:22:33,500 --> 00:22:37,250
you were trying to<font color="#E5E5E5"> fetch everything from</font>

559
00:22:35,660 --> 00:22:38,900
the proto every time you access it and

560
00:22:37,250 --> 00:22:41,150
index you didn't<font color="#CCCCCC"> even know that</font><font color="#E5E5E5"> was</font>

561
00:22:38,900 --> 00:22:43,670
there before you were trying to<font color="#E5E5E5"> reverse</font>

562
00:22:41,150 --> 00:22:46,010
it that'd be<font color="#CCCCCC"> very problematic so the way</font>

563
00:22:43,670 --> 00:22:48,440
they try and<font color="#CCCCCC"> handle this is they try to</font>

564
00:22:46,010 --> 00:22:50,390
get everything<font color="#E5E5E5"> out of the proto before</font>

565
00:22:48,440 --> 00:22:52,130
they call reverse so they'll go and

566
00:22:50,390 --> 00:22:55,280
iterate through the proto and make<font color="#CCCCCC"> sure</font>

567
00:22:52,130 --> 00:22:57,650
<font color="#CCCCCC">that if you have say elements 3 on the</font>

568
00:22:55,280 --> 00:23:00,410
proto of the proto they copy it into the

569
00:22:57,650 --> 00:23:02,870
current array so now<font color="#E5E5E5"> that element is in</font>

570
00:23:00,410 --> 00:23:05,660
the array so they do that but what they

571
00:23:02,870 --> 00:23:07,790
don't<font color="#E5E5E5"> I'm anticipate is that this can</font>

572
00:23:05,660 --> 00:23:10,460
change the length of the array and then

573
00:23:07,790 --> 00:23:16,700
this becomes basically a simple overflow

574
00:23:10,460 --> 00:23:19,100
if your array was big what was small and

575
00:23:16,700 --> 00:23:21,770
is now big now this<font color="#E5E5E5"> can overflow and you</font>

576
00:23:19,100 --> 00:23:23,590
can end<font color="#E5E5E5"> up with this huge legs and this</font>

577
00:23:21,770 --> 00:23:26,300
will eventually overflow again and

578
00:23:23,590 --> 00:23:29,990
become basically an overflow in one of

579
00:23:26,300 --> 00:23:32,270
these segments so you know how I said<font color="#CCCCCC"> I</font>

580
00:23:29,990 --> 00:23:35,270
had told<font color="#CCCCCC"> you all the weird stuff about</font>

581
00:23:32,270 --> 00:23:37,250
arrays I totally lied<font color="#CCCCCC"> about that</font><font color="#E5E5E5"> part</font>

582
00:23:35,270 --> 00:23:38,660
there<font color="#E5E5E5"> is one thing</font><font color="#CCCCCC"> that is even actually</font>

583
00:23:37,250 --> 00:23:40,550
there's a few more but this is the most

584
00:23:38,660 --> 00:23:42,590
<font color="#E5E5E5">interesting of the things that are even</font>

585
00:23:40,550 --> 00:23:46,159
weirder than the stuff<font color="#E5E5E5"> I already talked</font>

586
00:23:42,590 --> 00:23:49,100
<font color="#CCCCCC">about so this is</font><font color="#E5E5E5"> a feature of</font><font color="#CCCCCC"> JavaScript</font>

587
00:23:46,160 --> 00:23:53,600
called array dot species and the idea of

588
00:23:49,100 --> 00:23:57,320
this<font color="#E5E5E5"> is that lets say you call a</font>

589
00:23:53,600 --> 00:23:59,060
function on an array and let's say it's

590
00:23:57,320 --> 00:24:00,710
a<font color="#E5E5E5"> function that returns an array so like</font>

591
00:23:59,060 --> 00:24:03,230
let's say it's something like filter

592
00:24:00,710 --> 00:24:04,730
where filter will take each element out

593
00:24:03,230 --> 00:24:06,290
of<font color="#E5E5E5"> the array and then run a function on</font>

594
00:24:04,730 --> 00:24:08,630
it and put<font color="#CCCCCC"> the return</font><font color="#E5E5E5"> value into a</font>

595
00:24:06,290 --> 00:24:11,210
different array now you pop this Korea

596
00:24:08,630 --> 00:24:14,720
you get back now is that array an array

597
00:24:11,210 --> 00:24:16,400
or is it a subclass of an array and what

598
00:24:14,720 --> 00:24:20,030
<font color="#E5E5E5">Yakima script standard has to say about</font>

599
00:24:16,400 --> 00:24:22,760
<font color="#E5E5E5">this subject is why don't we do both so</font>

600
00:24:20,030 --> 00:24:25,280
um you have the symbol species on the

601
00:24:22,760 --> 00:24:27,350
array class that you can redefine and

602
00:24:25,280 --> 00:24:30,310
add a constructor and then this will be

603
00:24:27,350 --> 00:24:32,419
used to construct<font color="#CCCCCC"> the thing that your</font>

604
00:24:30,310 --> 00:24:34,000
<font color="#E5E5E5">will lead us to</font><font color="#CCCCCC"> construct the things</font>

605
00:24:32,420 --> 00:24:36,610
that<font color="#CCCCCC"> you're</font>

606
00:24:34,000 --> 00:24:38,770
array gets copied into and of<font color="#E5E5E5"> course</font>

607
00:24:36,610 --> 00:24:40,840
<font color="#E5E5E5">this is easily implemented by putting an</font>

608
00:24:38,770 --> 00:24:43,240
extra script call into every single

609
00:24:40,840 --> 00:24:45,490
function in native code so<font color="#CCCCCC"> what ends up</font>

610
00:24:43,240 --> 00:24:49,510
causing a lot of problems so it's kind

611
00:24:45,490 --> 00:24:51,610
of an unexpected feature and it<font color="#CCCCCC"> really</font>

612
00:24:49,510 --> 00:24:53,800
gets into like the guts of every single

613
00:24:51,610 --> 00:24:58,649
<font color="#E5E5E5">array function that has</font><font color="#CCCCCC"> been there there</font>

614
00:24:53,800 --> 00:25:01,570
for years already so here is<font color="#CCCCCC"> an example</font>

615
00:24:58,650 --> 00:25:05,590
so here's a bug in array conversion<font color="#E5E5E5"> I do</font>

616
00:25:01,570 --> 00:25:07,270
to array dot species so to<font color="#E5E5E5"> start off you</font>

617
00:25:05,590 --> 00:25:09,189
create this array and notice this is<font color="#CCCCCC"> a</font>

618
00:25:07,270 --> 00:25:11,879
mixed type array it has you<font color="#E5E5E5"> know an</font>

619
00:25:09,190 --> 00:25:14,820
object an array and my name in<font color="#E5E5E5"> it and</font>

620
00:25:11,880 --> 00:25:16,870
then you call filter on this array

621
00:25:14,820 --> 00:25:20,740
except you've also said array dot

622
00:25:16,870 --> 00:25:22,179
species so this this<font color="#E5E5E5"> causes problems</font>

623
00:25:20,740 --> 00:25:25,690
when<font color="#E5E5E5"> you actually create the array an</font>

624
00:25:22,180 --> 00:25:28,090
array so in the implementation in chakra

625
00:25:25,690 --> 00:25:30,640
of a radar filter it starts<font color="#E5E5E5"> off by</font>

626
00:25:28,090 --> 00:25:32,379
calling or a species create and this

627
00:25:30,640 --> 00:25:35,500
creates the array that all the filters

628
00:25:32,380 --> 00:25:37,510
stuff is going<font color="#E5E5E5"> to be copied into but</font>

629
00:25:35,500 --> 00:25:39,970
notice what<font color="#E5E5E5"> it actually does here it</font>

630
00:25:37,510 --> 00:25:42,310
returns this array are the one at the

631
00:25:39,970 --> 00:25:44,530
<font color="#E5E5E5">top which is an integer array which is</font>

632
00:25:42,310 --> 00:25:46,659
totally not<font color="#E5E5E5"> the same type of the array</font>

633
00:25:44,530 --> 00:25:48,460
that you're copying out of so it does

634
00:25:46,660 --> 00:25:50,710
that and<font color="#CCCCCC"> now you have</font><font color="#E5E5E5"> this inter a and</font>

635
00:25:48,460 --> 00:25:52,420
then you eventually get down to<font color="#CCCCCC"> the</font>

636
00:25:50,710 --> 00:25:54,670
bottom here where it you know it gets

637
00:25:52,420 --> 00:25:58,300
the idea and it calls the filter and

638
00:25:54,670 --> 00:26:00,730
then it tries to<font color="#E5E5E5"> put the item back into</font>

639
00:25:58,300 --> 00:26:03,070
the array if it returns true but wait a

640
00:26:00,730 --> 00:26:05,050
sec this thing is the wrong type for the

641
00:26:03,070 --> 00:26:08,439
array you provided so that's type

642
00:26:05,050 --> 00:26:10,720
confusion and it happens because this

643
00:26:08,440 --> 00:26:13,360
function did not expect that the array

644
00:26:10,720 --> 00:26:14,950
return would<font color="#E5E5E5"> be anything but the</font><font color="#CCCCCC"> type of</font>

645
00:26:13,360 --> 00:26:18,850
<font color="#E5E5E5">the words anything different from the</font>

646
00:26:14,950 --> 00:26:20,860
type of the one that was<font color="#CCCCCC"> provided so</font>

647
00:26:18,850 --> 00:26:23,919
here's another weird fiction feature of

648
00:26:20,860 --> 00:26:26,560
<font color="#E5E5E5">JavaScript the proxy and the idea</font><font color="#CCCCCC"> here</font>

649
00:26:23,920 --> 00:26:29,350
<font color="#CCCCCC">is you know what if I want</font><font color="#E5E5E5"> to divide</font>

650
00:26:26,560 --> 00:26:31,030
javascript in<font color="#E5E5E5"> JavaScript what if I want</font>

651
00:26:29,350 --> 00:26:33,669
<font color="#E5E5E5">to debug javascript in JavaScript in</font>

652
00:26:31,030 --> 00:26:35,800
JavaScript so it tries to<font color="#E5E5E5"> create an</font>

653
00:26:33,670 --> 00:26:38,350
interceptor for absolutely everything

654
00:26:35,800 --> 00:26:40,659
you can imagine there<font color="#CCCCCC"> is nothing you</font><font color="#E5E5E5"> can</font>

655
00:26:38,350 --> 00:26:42,939
do in javascript that a proxy cannot

656
00:26:40,660 --> 00:26:45,220
intercept you know it condensers that's

657
00:26:42,940 --> 00:26:47,380
get it can intercept that you can

658
00:26:45,220 --> 00:26:50,080
intercept you know enumerated

659
00:26:47,380 --> 00:26:52,510
really anything could also be

660
00:26:50,080 --> 00:26:53,980
problematic in some situations where the

661
00:26:52,510 --> 00:26:56,379
developer might not be expecting a

662
00:26:53,980 --> 00:27:02,230
property it's<font color="#CCCCCC"> especially</font><font color="#E5E5E5"> interesting</font>

663
00:26:56,380 --> 00:27:04,990
sometimes when it's a prototype<font color="#E5E5E5"> the</font>

664
00:27:02,230 --> 00:27:07,240
<font color="#E5E5E5">prototype of</font><font color="#CCCCCC"> an object because it can</font>

665
00:27:04,990 --> 00:27:09,490
lead to lots of unexpected things when

666
00:27:07,240 --> 00:27:13,240
doing the fall back when getting<font color="#E5E5E5"> an</font>

667
00:27:09,490 --> 00:27:15,760
element so here's an<font color="#E5E5E5"> example here</font><font color="#CCCCCC"> of a</font>

668
00:27:13,240 --> 00:27:18,820
bug in the shift operator it's<font color="#E5E5E5"> actually</font>

669
00:27:15,760 --> 00:27:20,110
in that get element this<font color="#E5E5E5"> is</font><font color="#CCCCCC"> the</font>

670
00:27:18,820 --> 00:27:22,000
prototype<font color="#E5E5E5"> filling that I showed in the</font>

671
00:27:20,110 --> 00:27:25,689
reverse thing but I'll show that to you

672
00:27:22,000 --> 00:27:27,670
again so you've got your array and then

673
00:27:25,690 --> 00:27:29,380
you've<font color="#CCCCCC"> got this proxy and one</font><font color="#E5E5E5"> of the</font>

674
00:27:27,670 --> 00:27:31,870
many many things<font color="#CCCCCC"> there proxy can</font>

675
00:27:29,380 --> 00:27:34,240
overwrite is getting the prototype<font color="#CCCCCC"> of a</font>

676
00:27:31,870 --> 00:27:36,969
function so you've got<font color="#E5E5E5"> the array you've</font>

677
00:27:34,240 --> 00:27:39,460
got the proxy which is a prototype and

678
00:27:36,970 --> 00:27:41,290
then the proxies prototype is this code

679
00:27:39,460 --> 00:27:43,510
that will get called to return future

680
00:27:41,290 --> 00:27:45,460
prototypes<font color="#CCCCCC"> so then you've got this</font>

681
00:27:43,510 --> 00:27:48,580
special object and<font color="#E5E5E5"> then you call shift</font>

682
00:27:45,460 --> 00:27:50,410
on it and what happens well it starts

683
00:27:48,580 --> 00:27:53,110
off by calling internal<font color="#CCCCCC"> fill from</font>

684
00:27:50,410 --> 00:27:55,150
<font color="#CCCCCC">prototype and this is once again trying</font>

685
00:27:53,110 --> 00:27:57,219
to<font color="#E5E5E5"> get all the elements from the protos</font>

686
00:27:55,150 --> 00:27:59,260
into the manor ray because shifting it

687
00:27:57,220 --> 00:28:02,770
would be like extremely<font color="#E5E5E5"> painful if ya je</font>

688
00:27:59,260 --> 00:28:04,450
dirais through the array many times so

689
00:28:02,770 --> 00:28:06,820
it does that but it makes<font color="#E5E5E5"> the assumption</font>

690
00:28:04,450 --> 00:28:09,010
about the prototype you get back and

691
00:28:06,820 --> 00:28:11,350
that's<font color="#E5E5E5"> because in chakra only borrow</font>

692
00:28:09,010 --> 00:28:13,090
<font color="#CCCCCC">rays and I'm</font><font color="#E5E5E5"> guessing at es libraries as</font>

693
00:28:11,350 --> 00:28:15,550
well it can be the prototype of<font color="#E5E5E5"> an</font>

694
00:28:13,090 --> 00:28:19,330
object if it's an integer array it

695
00:28:15,550 --> 00:28:22,210
<font color="#E5E5E5">converts it to a bar array just to avoid</font>

696
00:28:19,330 --> 00:28:24,820
this type of problem the thing is when

697
00:28:22,210 --> 00:28:27,640
the prototype is the proxy the<font color="#E5E5E5"> prototype</font>

698
00:28:24,820 --> 00:28:29,710
can dynamically provide the next

699
00:28:27,640 --> 00:28:32,620
prototype and there's no checks done on

700
00:28:29,710 --> 00:28:34,870
that so this in this case it is an inter

701
00:28:32,620 --> 00:28:36,820
a so when it tries to<font color="#CCCCCC"> copy those</font>

702
00:28:34,870 --> 00:28:38,590
elements from the inter a into the<font color="#E5E5E5"> VAR</font>

703
00:28:36,820 --> 00:28:40,840
array they aren't correctly typed and

704
00:28:38,590 --> 00:28:43,270
you end up basically over overriding

705
00:28:40,840 --> 00:28:48,820
pointers with integers so<font color="#CCCCCC"> I think</font><font color="#E5E5E5"> makes</font>

706
00:28:43,270 --> 00:28:54,460
this an especially bad bug so here's

707
00:28:48,820 --> 00:28:55,990
another fun type of<font color="#E5E5E5"> bug so this low pass</font>

708
00:28:54,460 --> 00:28:58,150
everything<font color="#E5E5E5"> I've shown you so far has</font>

709
00:28:55,990 --> 00:29:00,970
been on<font color="#E5E5E5"> the fast path they're optimized</font>

710
00:28:58,150 --> 00:29:02,799
ones but there's also slow<font color="#CCCCCC"> past</font>

711
00:29:00,970 --> 00:29:04,929
and so paths can be challenging to write

712
00:29:02,799 --> 00:29:07,870
because they need to handle every single

713
00:29:04,929 --> 00:29:10,120
case ever you can imagine it's getting

714
00:29:07,870 --> 00:29:11,830
to be a more popular thing that slow

715
00:29:10,120 --> 00:29:13,658
paths are actually written in JavaScript

716
00:29:11,830 --> 00:29:15,370
which actually makes a ton of sense

717
00:29:13,659 --> 00:29:17,409
<font color="#E5E5E5">because you know you could probably</font>

718
00:29:15,370 --> 00:29:19,360
write a pretty good slice pretty quickly

719
00:29:17,409 --> 00:29:20,679
in JavaScript and you know it would one

720
00:29:19,360 --> 00:29:22,840
hundred percent work all of the time

721
00:29:20,679 --> 00:29:24,720
because<font color="#CCCCCC"> JavaScript always takes the</font>

722
00:29:22,840 --> 00:29:28,149
getters and setters into account anyhow

723
00:29:24,720 --> 00:29:29,980
so that's becoming<font color="#E5E5E5"> more common it's</font>

724
00:29:28,150 --> 00:29:33,010
pretty foolproof but<font color="#CCCCCC"> the one problem</font>

725
00:29:29,980 --> 00:29:35,320
that can come up is that user code can

726
00:29:33,010 --> 00:29:38,140
alter its behavior sometimes you have to

727
00:29:35,320 --> 00:29:40,230
be really careful that users can or you

728
00:29:38,140 --> 00:29:43,120
can<font color="#CCCCCC"> often end up messing up memory and</font>

729
00:29:40,230 --> 00:29:45,610
sometimes script engines you script

730
00:29:43,120 --> 00:29:48,219
<font color="#CCCCCC">strictmode</font><font color="#E5E5E5"> prevent this and it does help</font>

731
00:29:45,610 --> 00:29:52,240
but it's not perfect I'm to give an

732
00:29:48,220 --> 00:29:56,020
example here this is just my imaginary

733
00:29:52,240 --> 00:29:58,299
built-in function that is a slow path in

734
00:29:56,020 --> 00:30:00,970
script and it's called do built-in stuff

735
00:29:58,299 --> 00:30:03,370
and then it creates an object and then

736
00:30:00,970 --> 00:30:05,080
it adds a property to the object<font color="#E5E5E5"> that's</font>

737
00:30:03,370 --> 00:30:07,899
not object and then it freezes the

738
00:30:05,080 --> 00:30:10,960
object<font color="#E5E5E5"> and then it does a native call on</font>

739
00:30:07,900 --> 00:30:14,100
the object on this<font color="#E5E5E5"> object</font><font color="#CCCCCC"> over that's</font>

740
00:30:10,960 --> 00:30:20,730
created so what<font color="#CCCCCC"> are the problems here</font>

741
00:30:14,100 --> 00:30:23,469
well there's two one is what if<font color="#CCCCCC"> I put a</font>

742
00:30:20,730 --> 00:30:25,390
<font color="#CCCCCC">Jenner</font><font color="#E5E5E5"> or</font><font color="#CCCCCC"> a setter on the object</font>

743
00:30:23,470 --> 00:30:28,090
prototype so this<font color="#E5E5E5"> is the object</font>

744
00:30:25,390 --> 00:30:29,919
prototypes that is used on every object

745
00:30:28,090 --> 00:30:32,350
even objects to haven't been created yet

746
00:30:29,919 --> 00:30:34,150
because<font color="#E5E5E5"> every object points up to that</font>

747
00:30:32,350 --> 00:30:35,740
default prototype object and if you

748
00:30:34,150 --> 00:30:37,510
change that<font color="#E5E5E5"> that will change it for</font>

749
00:30:35,740 --> 00:30:40,630
every single<font color="#E5E5E5"> object even objects that</font>

750
00:30:37,510 --> 00:30:42,490
<font color="#E5E5E5">you create later so if you do that and</font>

751
00:30:40,630 --> 00:30:45,340
you create make this prototype so that

752
00:30:42,490 --> 00:30:47,710
stuff has a getter or center on it then

753
00:30:45,340 --> 00:30:49,510
when<font color="#E5E5E5"> it calls</font><font color="#CCCCCC"> odot stuff it's going to</font>

754
00:30:47,710 --> 00:30:51,820
call your function and then you can get

755
00:30:49,510 --> 00:30:53,860
a handle to<font color="#E5E5E5"> the object and</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> can</font><font color="#CCCCCC"> be</font>

756
00:30:51,820 --> 00:30:55,928
problematic<font color="#E5E5E5"> because maybe this native</font>

757
00:30:53,860 --> 00:30:57,879
change stuff assume something about it

758
00:30:55,929 --> 00:30:59,919
for example<font color="#E5E5E5"> it probably assumes that</font>

759
00:30:57,880 --> 00:31:03,510
stuff is an object because that's what

760
00:30:59,919 --> 00:31:06,100
it<font color="#E5E5E5"> put in so this is kind of a cause of</font>

761
00:31:03,510 --> 00:31:08,710
problems I know there's a second<font color="#CCCCCC"> thing</font>

762
00:31:06,100 --> 00:31:11,980
which is<font color="#CCCCCC"> that you can redefine functions</font>

763
00:31:08,710 --> 00:31:14,340
in JavaScript and so let's see you over

764
00:31:11,980 --> 00:31:14,340
right

765
00:31:14,619 --> 00:31:22,600
let's say you overwrite object don't

766
00:31:17,720 --> 00:31:22,600
freeze with this function and then you

767
00:31:24,609 --> 00:31:29,869
then you call the other function once

768
00:31:27,919 --> 00:31:32,179
again you can get a handle to that

769
00:31:29,869 --> 00:31:33,350
object oh and the other thing<font color="#CCCCCC"> is that</font><font color="#E5E5E5"> it</font>

770
00:31:32,179 --> 00:31:35,480
probably doesn't freeze it correctly

771
00:31:33,350 --> 00:31:37,639
either and either of<font color="#E5E5E5"> those can be</font>

772
00:31:35,480 --> 00:31:42,739
problematic for<font color="#E5E5E5"> this native function</font>

773
00:31:37,639 --> 00:31:44,330
that gets called<font color="#E5E5E5"> later so um this</font><font color="#CCCCCC"> I</font>

774
00:31:42,739 --> 00:31:47,090
think<font color="#E5E5E5"> is kind of an emerging area</font>

775
00:31:44,330 --> 00:31:50,269
because i<font color="#CCCCCC"> think as more slow paths get</font>

776
00:31:47,090 --> 00:31:52,039
added in<font color="#CCCCCC"> javascript due to lots of crazy</font>

777
00:31:50,269 --> 00:31:54,859
<font color="#E5E5E5">yakima features we're going to see more</font>

778
00:31:52,039 --> 00:31:57,230
and more bugs like this I'm chakra uses

779
00:31:54,859 --> 00:31:59,178
last what I what I call host<font color="#E5E5E5"> scripts and</font>

780
00:31:57,230 --> 00:32:01,789
<font color="#E5E5E5">a lot of browsers it only does</font>

781
00:31:59,179 --> 00:32:04,639
internationalisation for slow path<font color="#CCCCCC"> and</font>

782
00:32:01,789 --> 00:32:06,590
script but<font color="#E5E5E5"> I think this is like a</font>

783
00:32:04,639 --> 00:32:09,949
problem in<font color="#E5E5E5"> the long run that's going to</font>

784
00:32:06,590 --> 00:32:13,639
get worse and<font color="#E5E5E5"> worse so here's an example</font>

785
00:32:09,950 --> 00:32:15,799
<font color="#CCCCCC">of a bug in internationalisation due to</font>

786
00:32:13,639 --> 00:32:18,199
this lack of type checking and the

787
00:32:15,799 --> 00:32:21,168
ability to tamper with script so here's

788
00:32:18,200 --> 00:32:22,879
the code from chakra in the host of

789
00:32:21,169 --> 00:32:27,759
<font color="#CCCCCC">JavaScript so this isn't my</font><font color="#E5E5E5"> JavaScript</font>

790
00:32:22,879 --> 00:32:31,549
this is chakras<font color="#E5E5E5"> JavaScript you can</font>

791
00:32:27,759 --> 00:32:33,350
define<font color="#E5E5E5"> a property called collator or</font>

792
00:32:31,549 --> 00:32:35,059
they define the property called<font color="#E5E5E5"> collator</font>

793
00:32:33,350 --> 00:32:37,189
and this is I'm if you've ever used

794
00:32:35,059 --> 00:32:40,340
internationalization it's a way you can

795
00:32:37,190 --> 00:32:41,869
compare strings in different language in

796
00:32:40,340 --> 00:32:43,999
different type set to make sure they're

797
00:32:41,869 --> 00:32:46,609
compared correctly so this<font color="#E5E5E5"> is like red</font>

798
00:32:43,999 --> 00:32:47,929
Jac's or map or function it's supposed

799
00:32:46,609 --> 00:32:50,480
to be something<font color="#E5E5E5"> that is supplied</font><font color="#CCCCCC"> by the</font>

800
00:32:47,929 --> 00:32:54,169
<font color="#E5E5E5">script engine unless you change it and</font>

801
00:32:50,480 --> 00:32:56,210
then it in script it i get to property

802
00:32:54,169 --> 00:32:58,999
from it and does all the stuff to it

803
00:32:56,210 --> 00:33:02,419
without type checking the problem here

804
00:32:58,999 --> 00:33:04,820
is let's say<font color="#E5E5E5"> i define the very same</font>

805
00:33:02,419 --> 00:33:07,239
project property on an object and then<font color="#E5E5E5"> i</font>

806
00:33:04,820 --> 00:33:09,408
create the odd create the object

807
00:33:07,239 --> 00:33:12,830
remember how<font color="#CCCCCC"> i told</font><font color="#E5E5E5"> you about deferred</font>

808
00:33:09,409 --> 00:33:14,659
types in chakra well internationally

809
00:33:12,830 --> 00:33:20,600
they should have happens<font color="#E5E5E5"> to be a</font>

810
00:33:14,659 --> 00:33:24,889
deferred type so you start up and you

811
00:33:20,600 --> 00:33:28,010
call international dot number format or

812
00:33:24,889 --> 00:33:31,370
international<font color="#E5E5E5"> cool later and then you</font>

813
00:33:28,010 --> 00:33:33,320
um this will kick off the creation of

814
00:33:31,370 --> 00:33:34,969
this internationalization object it will

815
00:33:33,320 --> 00:33:37,879
<font color="#CCCCCC">make the deferred object try and become</font>

816
00:33:34,970 --> 00:33:40,670
a real object and when it does that it

817
00:33:37,880 --> 00:33:42,440
tries to execute this script and what it

818
00:33:40,670 --> 00:33:44,870
does you've already<font color="#E5E5E5"> created that object</font>

819
00:33:42,440 --> 00:33:46,430
and then it will call your getter on

820
00:33:44,870 --> 00:33:48,919
that object instead<font color="#E5E5E5"> of the default</font>

821
00:33:46,430 --> 00:33:51,470
object and then you can change<font color="#CCCCCC"> this</font>

822
00:33:48,920 --> 00:33:55,940
native object before this next code gets

823
00:33:51,470 --> 00:33:58,610
called and so what that does is<font color="#CCCCCC"> that</font>

824
00:33:55,940 --> 00:34:00,260
allows you to<font color="#E5E5E5"> change all these types</font>

825
00:33:58,610 --> 00:34:02,149
that they assume<font color="#E5E5E5"> are objects to things</font>

826
00:34:00,260 --> 00:34:05,540
like integers and this ends up being

827
00:34:02,150 --> 00:34:08,090
<font color="#E5E5E5">typed confusion even though these</font>

828
00:34:05,540 --> 00:34:09,860
objects on<font color="#CCCCCC"> the stack have that one set</font>

829
00:34:08,090 --> 00:34:12,350
which make them the number type it's not

830
00:34:09,860 --> 00:34:16,370
checking here so that means you can

831
00:34:12,350 --> 00:34:20,540
confuse pointers with objects and then

832
00:34:16,370 --> 00:34:23,350
i'm going to show you pretty much one

833
00:34:20,540 --> 00:34:26,840
last fun bug here which is simple error

834
00:34:23,350 --> 00:34:29,659
so<font color="#CCCCCC"> i'm</font><font color="#E5E5E5"> going</font><font color="#CCCCCC"> through a lot</font><font color="#E5E5E5"> of complex</font>

835
00:34:26,840 --> 00:34:32,030
bugs here and yes sometimes bugs do

836
00:34:29,659 --> 00:34:33,679
happen due to lots of complexity but you

837
00:34:32,030 --> 00:34:38,270
know sometimes bugs just happened due to

838
00:34:33,679 --> 00:34:40,460
sheer error and this is one of them so

839
00:34:38,270 --> 00:34:43,340
on this<font color="#E5E5E5"> is the inner</font><font color="#CCCCCC"> sympathy function i</font>

840
00:34:40,460 --> 00:34:45,168
shall show you the pot<font color="#E5E5E5"> first um this is</font>

841
00:34:43,340 --> 00:34:46,850
also my favorite bag just because<font color="#CCCCCC"> i can</font>

842
00:34:45,168 --> 00:34:51,138
tweet<font color="#CCCCCC"> it it's the right number of</font>

843
00:34:46,850 --> 00:34:53,659
characters and this is<font color="#E5E5E5"> just a fall</font>

844
00:34:51,139 --> 00:34:57,460
through so when you have a very large

845
00:34:53,659 --> 00:35:00,170
<font color="#E5E5E5">number of parameters we're very large is</font>

846
00:34:57,460 --> 00:35:01,910
three larger than three<font color="#E5E5E5"> it just follows</font>

847
00:35:00,170 --> 00:35:03,500
through and<font color="#CCCCCC"> i'm</font><font color="#E5E5E5"> pretty sure this was a</font>

848
00:35:01,910 --> 00:35:05,029
mistake they meant that assert to be

849
00:35:03,500 --> 00:35:06,710
<font color="#CCCCCC">something that</font><font color="#E5E5E5"> was alden Asura</font><font color="#CCCCCC"> may be a</font>

850
00:35:05,030 --> 00:35:10,700
fatal<font color="#E5E5E5"> error or something like that but</font>

851
00:35:06,710 --> 00:35:13,780
that is<font color="#CCCCCC"> not what happened</font><font color="#E5E5E5"> and this falls</font>

852
00:35:10,700 --> 00:35:17,390
through and this is an uninitialized

853
00:35:13,780 --> 00:35:19,640
variable um so that's about<font color="#E5E5E5"> it to</font>

854
00:35:17,390 --> 00:35:22,040
conclude here I think I've learned a<font color="#CCCCCC"> few</font>

855
00:35:19,640 --> 00:35:24,560
things here one is that<font color="#CCCCCC"> JavaScript has</font><font color="#E5E5E5"> a</font>

856
00:35:22,040 --> 00:35:26,150
lot of features it has an excessively

857
00:35:24,560 --> 00:35:28,190
large amount of features like I think

858
00:35:26,150 --> 00:35:30,020
I've only described about two features

859
00:35:28,190 --> 00:35:32,420
here and it has like a thousand more

860
00:35:30,020 --> 00:35:34,040
<font color="#E5E5E5">like this but</font><font color="#CCCCCC"> it's something I'm having</font>

861
00:35:32,420 --> 00:35:35,180
really important regardless<font color="#CCCCCC"> of</font><font color="#E5E5E5"> what</font>

862
00:35:34,040 --> 00:35:36,920
you're developing even if it's<font color="#E5E5E5"> not a</font>

863
00:35:35,180 --> 00:35:40,040
script<font color="#E5E5E5"> engine and every one of these</font>

864
00:35:36,920 --> 00:35:41,330
<font color="#CCCCCC">features hasil</font><font color="#E5E5E5"> adds bugs and you really</font>

865
00:35:40,040 --> 00:35:43,580
got to think about<font color="#E5E5E5"> you know are these</font>

866
00:35:41,330 --> 00:35:44,930
features worth it I know the people<font color="#E5E5E5"> that</font>

867
00:35:43,580 --> 00:35:47,660
make browsers don't write the browser

868
00:35:44,930 --> 00:35:50,660
standards but<font color="#CCCCCC"> you know</font><font color="#E5E5E5"> for</font><font color="#CCCCCC"> example with</font>

869
00:35:47,660 --> 00:35:53,390
the array dot C<font color="#E5E5E5"> sees how often have you</font>

870
00:35:50,660 --> 00:35:55,759
ever used that<font color="#E5E5E5"> you know how often have</font>

871
00:35:53,390 --> 00:35:57,650
you added an array index interceptor to

872
00:35:55,760 --> 00:36:00,290
our array so you can add a getter setter

873
00:35:57,650 --> 00:36:02,390
at an index like I know I have never

874
00:36:00,290 --> 00:36:04,370
<font color="#E5E5E5">done this not in a bug so I think that's</font>

875
00:36:02,390 --> 00:36:07,759
a big lesson hear that a lot<font color="#E5E5E5"> of these</font>

876
00:36:04,370 --> 00:36:09,770
kind<font color="#CCCCCC"> of obscure functions a do add bugs</font>

877
00:36:07,760 --> 00:36:13,250
and I think you've got to decide are

878
00:36:09,770 --> 00:36:16,509
they worth it or are<font color="#E5E5E5"> they not another</font>

879
00:36:13,250 --> 00:36:20,480
thing<font color="#CCCCCC"> is that implementation decisions</font>

880
00:36:16,510 --> 00:36:22,310
bake the<font color="#CCCCCC"> effect what kind of bugs you</font>

881
00:36:20,480 --> 00:36:23,840
have I'm not<font color="#E5E5E5"> trying to like you know it</font>

882
00:36:22,310 --> 00:36:26,060
would<font color="#CCCCCC"> be down on anyone who writes code</font>

883
00:36:23,840 --> 00:36:28,850
like these are super hard problems and

884
00:36:26,060 --> 00:36:30,140
there's no right choice here anyway you

885
00:36:28,850 --> 00:36:32,150
implement this there's going to be

886
00:36:30,140 --> 00:36:34,460
trade-off between basically<font color="#E5E5E5"> performance</font>

887
00:36:32,150 --> 00:36:36,380
and security and use of development and

888
00:36:34,460 --> 00:36:39,250
many other things<font color="#E5E5E5"> up he's really</font>

889
00:36:36,380 --> 00:36:43,000
important to be aware of this stuff some

890
00:36:39,250 --> 00:36:47,030
make sure that like you understand that

891
00:36:43,000 --> 00:36:48,800
that you<font color="#CCCCCC"> know your choices of you know</font>

892
00:36:47,030 --> 00:36:53,150
do you do a fast after you do a slow

893
00:36:48,800 --> 00:36:54,710
<font color="#E5E5E5">pass that sort of thing he's really</font>

894
00:36:53,150 --> 00:36:58,790
important<font color="#E5E5E5"> it changes the types of bugs</font>

895
00:36:54,710 --> 00:37:01,250
you have and also many other<font color="#E5E5E5"> features of</font>

896
00:36:58,790 --> 00:37:02,480
<font color="#CCCCCC">the engine so it's about developers I</font>

897
00:37:01,250 --> 00:37:03,980
think it's important to<font color="#CCCCCC"> think about</font><font color="#E5E5E5"> that</font>

898
00:37:02,480 --> 00:37:06,020
in the<font color="#E5E5E5"> design and</font><font color="#CCCCCC"> I think it's bugfinder</font>

899
00:37:03,980 --> 00:37:09,650
is it means that it's<font color="#E5E5E5"> really important</font>

900
00:37:06,020 --> 00:37:13,520
to understand the design and understand

901
00:37:09,650 --> 00:37:14,990
<font color="#E5E5E5">I would impact security</font><font color="#CCCCCC"> well from</font><font color="#E5E5E5"> the</font>

902
00:37:13,520 --> 00:37:16,100
side if<font color="#E5E5E5"> you're looking for more bugs I</font>

903
00:37:14,990 --> 00:37:18,470
think<font color="#E5E5E5"> like figuring out how the main</font>

904
00:37:16,100 --> 00:37:19,940
features works you know I didn't think

905
00:37:18,470 --> 00:37:23,270
it would lead to quite as<font color="#E5E5E5"> many bugs as</font>

906
00:37:19,940 --> 00:37:24,830
it did end up leading to but but really

907
00:37:23,270 --> 00:37:27,860
I'm just you know good understanding of

908
00:37:24,830 --> 00:37:30,620
<font color="#E5E5E5">how you how things are implemented</font>

909
00:37:27,860 --> 00:37:32,330
really does help find bugs and from the

910
00:37:30,620 --> 00:37:34,520
<font color="#CCCCCC">securing perspective i think is</font>

911
00:37:32,330 --> 00:37:37,549
important to understand this so that you

912
00:37:34,520 --> 00:37:39,080
<font color="#E5E5E5">know what to avoid you know once you</font>

913
00:37:37,550 --> 00:37:41,210
know that<font color="#CCCCCC"> certain designs leads to</font>

914
00:37:39,080 --> 00:37:43,370
weekly to certain<font color="#E5E5E5"> bugs certain problems</font>

915
00:37:41,210 --> 00:37:46,970
i think that's that's the first step 2

916
00:37:43,370 --> 00:37:50,180
i'm trying to prevent them so that's it

917
00:37:46,970 --> 00:37:52,959
thanks a<font color="#E5E5E5"> lot and please feel free to ask</font>

918
00:37:50,180 --> 00:37:52,960
any questions

919
00:37:58,930 --> 00:38:06,890
thank you very much Natalie any

920
00:38:01,550 --> 00:38:09,320
questions from<font color="#E5E5E5"> the floor now well she'll</font>

921
00:38:06,890 --> 00:38:11,450
be<font color="#E5E5E5"> at the party as well I</font><font color="#CCCCCC"> believe yeah</font>

922
00:38:09,320 --> 00:38:15,140
but I also have<font color="#CCCCCC"> my contact info if you</font>

923
00:38:11,450 --> 00:38:17,620
better email me or something thank you

924
00:38:15,140 --> 00:38:22,239
very much Natalie

925
00:38:17,620 --> 00:38:22,239
[Applause]

