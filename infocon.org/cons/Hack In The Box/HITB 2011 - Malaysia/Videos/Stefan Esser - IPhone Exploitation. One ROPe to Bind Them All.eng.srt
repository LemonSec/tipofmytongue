1
00:00:19,500 --> 00:00:23,859
so welcome to the talk iphone

2
00:00:23,859 --> 00:00:26,439
exploitation one rope to bind them all

3
00:00:26,439 --> 00:00:29,680
and I always keep my introduction

4
00:00:29,680 --> 00:00:31,689
because I have a lot of slides and I

5
00:00:31,689 --> 00:00:33,940
need to go through them in a way that we

6
00:00:33,940 --> 00:00:36,220
can finish in time so what is this

7
00:00:36,220 --> 00:00:40,180
session about this session is about the

8
00:00:40,180 --> 00:00:43,360
odds to successfully exploit an iphone

9
00:00:43,360 --> 00:00:45,550
in case you have no kind of information

10
00:00:45,550 --> 00:00:48,339
leak so you have the exploit but you

11
00:00:48,339 --> 00:00:50,440
don't know what device you're exporting

12
00:00:50,440 --> 00:00:53,680
and it's not only about the odds but

13
00:00:53,680 --> 00:00:57,570
it's a lot how to improve them and we

14
00:00:57,570 --> 00:01:00,460
well for this talk we say we have like a

15
00:01:00,460 --> 00:01:02,920
normal stack buffer overflow because

16
00:01:02,920 --> 00:01:04,809
otherwise we have to deal with some way

17
00:01:04,809 --> 00:01:08,350
to some gadget to get the heap into know

18
00:01:08,350 --> 00:01:10,210
get the stack pointer into the heap so

19
00:01:10,210 --> 00:01:12,369
we will just say we have a stack buffer

20
00:01:12,369 --> 00:01:15,250
overflow so we just need no kind of

21
00:01:15,250 --> 00:01:17,530
stack pointer movement in the beginning

22
00:01:17,530 --> 00:01:21,720
I want to start with some statistics so

23
00:01:21,720 --> 00:01:24,039
when you look at the idevices in two

24
00:01:24,039 --> 00:01:25,960
versions you see that there are like 12

25
00:01:25,960 --> 00:01:29,259
I device differently I devices that are

26
00:01:29,259 --> 00:01:32,560
supported supporting iOS four let's see

27
00:01:32,560 --> 00:01:38,380
the ipod 23 and g4 I mean and there's

28
00:01:38,380 --> 00:01:42,280
the ipod one ipad 2 Wi-Fi IP to cdma i

29
00:01:42,280 --> 00:01:47,409
pay 2g dsm and you have the iphones 3g

30
00:01:47,409 --> 00:01:51,609
3gs & 4 & 4s eaten available in gsm and

31
00:01:51,609 --> 00:01:54,280
cdma end of course you have the Apple TV

32
00:01:54,280 --> 00:01:58,389
but I ignore it for this talk so yeah

33
00:01:58,389 --> 00:02:02,709
and the soon-to-be-released iphone 4s

34
00:02:02,709 --> 00:02:04,479
but most probably only like support iOS

35
00:02:04,479 --> 00:02:07,380
5 so we don't need to reuse it we don't

36
00:02:07,380 --> 00:02:09,669
discuss it here we have no information

37
00:02:09,669 --> 00:02:13,540
anyway so you see there are 16 different

38
00:02:13,540 --> 00:02:15,819
versions of iOS four at the moment and

39
00:02:15,819 --> 00:02:18,099
when you like him do the maths you can

40
00:02:18,099 --> 00:02:22,630
see that probably like 12 x 16 versions

41
00:02:22,630 --> 00:02:24,670
but luckily it's not the case when you

42
00:02:24,670 --> 00:02:28,510
look at the this little picture you see

43
00:02:28,510 --> 00:02:31,300
that not all the versions are available

44
00:02:31,300 --> 00:02:32,100
for

45
00:02:32,100 --> 00:02:34,980
all of the devices basically the light

46
00:02:34,980 --> 00:02:40,230
green stuff is all the devices we we can

47
00:02:40,230 --> 00:02:41,790
download the firmware for and we have

48
00:02:41,790 --> 00:02:45,180
the the keys for the for the firmware so

49
00:02:45,180 --> 00:02:47,460
we can decrypt them and only for the

50
00:02:47,460 --> 00:02:51,030
ipad 2 there's afforded 3 version and we

51
00:02:51,030 --> 00:02:54,930
we don't have the keys for this 3 yeah

52
00:02:54,930 --> 00:02:58,080
firmwares so in total you can see there

53
00:02:58,080 --> 00:03:01,170
are 81 different combinations so when

54
00:03:01,170 --> 00:03:02,730
you have no idea you just know the

55
00:03:02,730 --> 00:03:06,990
devices running iOS 41 of this 81 things

56
00:03:06,990 --> 00:03:10,560
could be your target so another question

57
00:03:10,560 --> 00:03:12,090
how likely is it that something is your

58
00:03:12,090 --> 00:03:15,360
target and there's statistics I got from

59
00:03:15,360 --> 00:03:21,030
a German I t magazine and some the

60
00:03:21,030 --> 00:03:23,010
audience is very technical because I t

61
00:03:23,010 --> 00:03:27,110
magazine and it's a visit visiting

62
00:03:27,110 --> 00:03:32,550
visitors between first and I think 20 or

63
00:03:32,550 --> 00:03:37,260
25 sep tember and you can see which is

64
00:03:37,260 --> 00:03:39,570
very strange here is that mostly they

65
00:03:39,570 --> 00:03:42,450
have ipod and iphone visitors and there

66
00:03:42,450 --> 00:03:46,920
are very few iPads maybe only the users

67
00:03:46,920 --> 00:03:49,110
of the site are not using iPads or maybe

68
00:03:49,110 --> 00:03:50,790
IPS are just not though so common in

69
00:03:50,790 --> 00:03:55,260
Germany but the site owner could not

70
00:03:55,260 --> 00:03:57,510
explain why is where the bracelet low so

71
00:03:57,510 --> 00:03:59,340
he doesn't know if it's like a glitch in

72
00:03:59,340 --> 00:04:02,160
the statistics but it seems like we have

73
00:04:02,160 --> 00:04:04,290
a lot more iphones and ID ipods than

74
00:04:04,290 --> 00:04:09,660
ipads or at least this site so when we

75
00:04:09,660 --> 00:04:11,970
look at what kind of major version is

76
00:04:11,970 --> 00:04:14,220
used you will see that they're like very

77
00:04:14,220 --> 00:04:19,459
few iOS iOS 5 beta users at the time a

78
00:04:19,459 --> 00:04:22,530
little bit of users wise at three and

79
00:04:22,530 --> 00:04:26,580
below and the majority of ninety six

80
00:04:26,580 --> 00:04:29,780
point eight percent is running iOS four

81
00:04:29,780 --> 00:04:32,040
and now when we look at the minor

82
00:04:32,040 --> 00:04:35,490
version we will see that the earlier iOS

83
00:04:35,490 --> 00:04:38,130
four versions are dying out and there's

84
00:04:38,130 --> 00:04:41,249
still a lot of photo to users

85
00:04:41,249 --> 00:04:43,499
most probably in Germany because of the

86
00:04:43,499 --> 00:04:47,849
iphone 3g because the iphone 3g can only

87
00:04:47,849 --> 00:04:50,159
run a photo to that one and we have a

88
00:04:50,159 --> 00:04:53,849
lot of iphone 3gs and germany the

89
00:04:53,849 --> 00:04:56,639
majority's are however on photog 3 which

90
00:04:56,639 --> 00:05:03,119
includes RSL error a SLR and but you see

91
00:05:03,119 --> 00:05:05,489
that about twenty-two percent of the

92
00:05:05,489 --> 00:05:08,299
users on running without a is allowed

93
00:05:08,299 --> 00:05:12,029
and now we can break down the the users

94
00:05:12,029 --> 00:05:14,699
a little bit more and we can see that

95
00:05:14,699 --> 00:05:17,729
above half of the users are running the

96
00:05:17,729 --> 00:05:23,189
latest iOS four bid and but about forty

97
00:05:23,189 --> 00:05:25,049
eight point four percent are still

98
00:05:25,049 --> 00:05:26,819
running older versions and so are

99
00:05:26,819 --> 00:05:29,459
vulnerable to this jailbreak jailbreak

100
00:05:29,459 --> 00:05:31,529
military exploits so you can remotely

101
00:05:31,529 --> 00:05:34,289
jailbreak these iphones with just about

102
00:05:34,289 --> 00:05:38,579
half of the users and of course you see

103
00:05:38,579 --> 00:05:39,899
there are lot of different versions and

104
00:05:39,899 --> 00:05:42,119
a good exploit should support multiple

105
00:05:42,119 --> 00:05:45,899
versions so the next thing i want to

106
00:05:45,899 --> 00:05:48,089
tell you about this like when you look

107
00:05:48,089 --> 00:05:50,339
at i was for there's like different

108
00:05:50,339 --> 00:05:52,789
phases or different errors of

109
00:05:52,789 --> 00:05:56,099
exploitation because the protections

110
00:05:56,099 --> 00:05:58,469
changed a little bit and you can just

111
00:05:58,469 --> 00:06:02,069
say there's like i was iOS 42 hours or

112
00:06:02,069 --> 00:06:05,969
iOS fortitudo x and there I was followed

113
00:06:05,969 --> 00:06:09,319
suite of X and of course iOS 5 which

114
00:06:09,319 --> 00:06:14,129
came out yesterday I think and yeah so

115
00:06:14,129 --> 00:06:17,309
which each new era you have new security

116
00:06:17,309 --> 00:06:20,969
features and new mitigations and I will

117
00:06:20,969 --> 00:06:24,599
go through them shortly so the basis is

118
00:06:24,599 --> 00:06:26,279
that you have like a non-executable

119
00:06:26,279 --> 00:06:29,039
stack and heap and this is strictly

120
00:06:29,039 --> 00:06:31,529
enforced by the by the iOS kernel and

121
00:06:31,529 --> 00:06:34,289
you can't just like have memory that is

122
00:06:34,289 --> 00:06:36,119
executed and vital at the same time they

123
00:06:36,119 --> 00:06:38,959
are the kind of just doesn't allow bit

124
00:06:38,959 --> 00:06:42,089
additionally the code signing ensures

125
00:06:42,089 --> 00:06:44,669
that code can only be executed if

126
00:06:44,669 --> 00:06:46,709
there's a digital signature from elbow

127
00:06:46,709 --> 00:06:50,819
and therefore all exploits must be one

128
00:06:50,819 --> 00:06:51,590
hundred percent

129
00:06:51,590 --> 00:06:55,160
return orange programming and in this

130
00:06:55,160 --> 00:06:58,190
this times we also did not have any kind

131
00:06:58,190 --> 00:07:02,990
of a SLR in iOS the exception here is

132
00:07:02,990 --> 00:07:05,090
that of course some of these protections

133
00:07:05,090 --> 00:07:07,220
are not working on jailbroken iPhones

134
00:07:07,220 --> 00:07:11,060
but still at least the beginning of an

135
00:07:11,060 --> 00:07:13,100
exploit for jailbroken iphone must still

136
00:07:13,100 --> 00:07:15,650
use a little bit of rope to actually

137
00:07:15,650 --> 00:07:17,630
like map the memory writable an

138
00:07:17,630 --> 00:07:24,050
executable yeah another thing you need

139
00:07:24,050 --> 00:07:27,700
to know is that on iOS that 3 and above

140
00:07:27,700 --> 00:07:30,380
you have no libraries on the device

141
00:07:30,380 --> 00:07:32,210
anymore everything was moved into the

142
00:07:32,210 --> 00:07:35,360
shared cage and this is usually a map

143
00:07:35,360 --> 00:07:37,670
that this no it's always mapped at this

144
00:07:37,670 --> 00:07:40,250
address and the case looks like this you

145
00:07:40,250 --> 00:07:41,900
have like three mappings in inside the

146
00:07:41,900 --> 00:07:45,110
cage and the code signature and when you

147
00:07:45,110 --> 00:07:48,490
look into the the cage you will see that

148
00:07:48,490 --> 00:07:51,410
the first part contains the text segment

149
00:07:51,410 --> 00:07:53,930
of all the libraries the second part

150
00:07:53,930 --> 00:07:55,970
contains the data segments of all the

151
00:07:55,970 --> 00:07:58,400
libraries and in the last part you see

152
00:07:58,400 --> 00:08:00,920
some other segments like the Unicode

153
00:08:00,920 --> 00:08:03,290
string in some in some library or in

154
00:08:03,290 --> 00:08:08,890
some framework and linq edit information

155
00:08:09,130 --> 00:08:12,430
another thing you have to know is that

156
00:08:12,430 --> 00:08:15,650
when Apple packs the firmware they get

157
00:08:15,650 --> 00:08:17,420
irate this case and the case generation

158
00:08:17,420 --> 00:08:19,760
is done randomly so it will pick up all

159
00:08:19,760 --> 00:08:21,140
the libraries and just pick them

160
00:08:21,140 --> 00:08:22,640
randomly and then load them after each

161
00:08:22,640 --> 00:08:25,370
other which means then that when you

162
00:08:25,370 --> 00:08:29,720
have like them yeah when you have like

163
00:08:29,720 --> 00:08:31,850
different devices like the iPhone 4 the

164
00:08:31,850 --> 00:08:34,970
ipod 4 and so on they all get their own

165
00:08:34,970 --> 00:08:36,710
firmware and every time the film which

166
00:08:36,710 --> 00:08:39,710
generated the load order is different so

167
00:08:39,710 --> 00:08:41,960
for all of the devices you have the

168
00:08:41,960 --> 00:08:44,270
libraries that may be the same binary

169
00:08:44,270 --> 00:08:46,490
file but they are loaded there map to a

170
00:08:46,490 --> 00:08:49,250
different address so this means we had

171
00:08:49,250 --> 00:08:52,520
like 81 different devices and versions

172
00:08:52,520 --> 00:08:54,950
so they are deeper than 80 one different

173
00:08:54,950 --> 00:08:57,290
load addresses for all the without a

174
00:08:57,290 --> 00:09:00,440
salon 81 different load addresses for

175
00:09:00,440 --> 00:09:02,270
across all the devices for the same

176
00:09:02,270 --> 00:09:04,730
library and when you look into the

177
00:09:04,730 --> 00:09:06,320
the case you'd see also there's the

178
00:09:06,320 --> 00:09:08,600
malefic modification time and the inode

179
00:09:08,600 --> 00:09:10,940
inside and you see they are the same

180
00:09:10,940 --> 00:09:13,490
inode in the same modification time so

181
00:09:13,490 --> 00:09:15,350
most probably they're always the same

182
00:09:15,350 --> 00:09:22,160
binary so now let's go to the newer

183
00:09:22,160 --> 00:09:27,260
versions to fallout 3 and now Apple

184
00:09:27,260 --> 00:09:29,899
added something called the just-in-time

185
00:09:29,899 --> 00:09:32,329
compiler the neutral compiler to to a

186
00:09:32,329 --> 00:09:34,790
mobile safari and this adds something

187
00:09:34,790 --> 00:09:37,100
called dynamic code signing which allows

188
00:09:37,100 --> 00:09:39,740
Safari to actually have right of length

189
00:09:39,740 --> 00:09:43,339
and executable memory of course it's

190
00:09:43,339 --> 00:09:45,800
weakens the protections a bit and I will

191
00:09:45,800 --> 00:09:47,600
not go into into it at all because

192
00:09:47,600 --> 00:09:49,430
Charlie Miller will have a talk about a

193
00:09:49,430 --> 00:09:51,800
whole talk about this in next month's in

194
00:09:51,800 --> 00:09:55,190
Taipei so I will only care about the ASL

195
00:09:55,190 --> 00:09:58,970
are for this talk so this 8's law is or

196
00:09:58,970 --> 00:10:01,940
are in 43 basically randomized the

197
00:10:01,940 --> 00:10:03,949
dynamic linker the dynamic shared cache

198
00:10:03,949 --> 00:10:08,360
and the main binary when you look at the

199
00:10:08,360 --> 00:10:11,529
main binary however you will see that

200
00:10:11,529 --> 00:10:15,459
when you compile application for a new

201
00:10:15,459 --> 00:10:19,579
device for a new with a new it SDK you

202
00:10:19,579 --> 00:10:22,220
will see that the Xcode will compile it

203
00:10:22,220 --> 00:10:25,540
as a position independent to my old file

204
00:10:25,540 --> 00:10:28,930
when you compile against an old sdk for

205
00:10:28,930 --> 00:10:31,279
example to have compatibility to all the

206
00:10:31,279 --> 00:10:34,930
devices then exco does not generate on a

207
00:10:34,930 --> 00:10:37,790
position independent file this means

208
00:10:37,790 --> 00:10:39,410
that all the applications that are

209
00:10:39,410 --> 00:10:42,529
running that are using know that are

210
00:10:42,529 --> 00:10:44,959
also running on all devices like Twitter

211
00:10:44,959 --> 00:10:47,600
like Facebook they all want to come be

212
00:10:47,600 --> 00:10:48,980
compatible with all the old devices

213
00:10:48,980 --> 00:10:51,860
they're all run without they are all not

214
00:10:51,860 --> 00:10:54,170
positioned independently executables so

215
00:10:54,170 --> 00:10:56,930
or in all these cases the the main

216
00:10:56,930 --> 00:11:01,430
binary is not randomized actually I

217
00:11:01,430 --> 00:11:03,800
think in the wild on my iPhone I have

218
00:11:03,800 --> 00:11:05,930
the only application that are randomized

219
00:11:05,930 --> 00:11:09,529
are these from Apple every third party

220
00:11:09,529 --> 00:11:11,360
application is not randomized in my

221
00:11:11,360 --> 00:11:15,500
device so when we look at the dynamic

222
00:11:15,500 --> 00:11:18,220
linker it was always a

223
00:11:18,220 --> 00:11:20,710
binary with location information so it

224
00:11:20,710 --> 00:11:22,540
would be possible to move it around all

225
00:11:22,540 --> 00:11:25,990
the time or even in old versions but the

226
00:11:25,990 --> 00:11:27,520
colonel didn't do that nowadays the

227
00:11:27,520 --> 00:11:29,680
colonel randomized on start of an

228
00:11:29,680 --> 00:11:34,810
executor bone however the dynamic link

229
00:11:34,810 --> 00:11:40,030
has only slided if the main executable

230
00:11:40,030 --> 00:11:46,810
slided and only by the same amount so if

231
00:11:46,810 --> 00:11:50,080
the main executable is moved by a 4

232
00:11:50,080 --> 00:11:52,060
kilobyte then the dynamic linkers also

233
00:11:52,060 --> 00:11:56,740
moved by 4 kilobyte so for most of the

234
00:11:56,740 --> 00:11:58,660
application for a party application at

235
00:11:58,660 --> 00:12:03,100
the moment there is no Melissa kinome

236
00:12:03,100 --> 00:12:06,850
shifting of the dynamic linker and when

237
00:12:06,850 --> 00:12:09,430
you look into the shifting you will see

238
00:12:09,430 --> 00:12:12,070
that the shifting is well random number

239
00:12:12,070 --> 00:12:18,390
generator is good but it only has 256

240
00:12:18,390 --> 00:12:21,870
possible yeah outcomes so they're only

241
00:12:21,870 --> 00:12:24,970
256 different positions the main binary

242
00:12:24,970 --> 00:12:27,160
or the dynamic linker can be moved to if

243
00:12:27,160 --> 00:12:34,120
they actually moved the shell case on

244
00:12:34,120 --> 00:12:37,330
the other hand it's like one big blob

245
00:12:37,330 --> 00:12:40,240
and because of the code signing Apple

246
00:12:40,240 --> 00:12:42,130
cannot just like shift all the libraries

247
00:12:42,130 --> 00:12:44,520
around shuffle them they can only ship

248
00:12:44,520 --> 00:12:47,140
the whole block of libraries by a

249
00:12:47,140 --> 00:12:49,570
certain amount so the whole block moves

250
00:12:49,570 --> 00:12:52,050
left or right or up and down in memory

251
00:12:52,050 --> 00:12:55,660
therefore all the libraries if you know

252
00:12:55,660 --> 00:12:57,780
like one address inside the library then

253
00:12:57,780 --> 00:13:01,360
you know all the other addresses because

254
00:13:01,360 --> 00:13:06,490
they are all at the same Delta this is

255
00:13:06,490 --> 00:13:09,940
all done by when u janu osisko in my

256
00:13:09,940 --> 00:13:11,620
last back in the box presentation in

257
00:13:11,620 --> 00:13:13,150
amsterdam i explained a little bit

258
00:13:13,150 --> 00:13:15,190
better better how it works but we don't

259
00:13:15,190 --> 00:13:17,260
need it here but the thing is that it

260
00:13:17,260 --> 00:13:20,290
only about 4200 different base addresses

261
00:13:20,290 --> 00:13:25,600
even for the big cage so in summary this

262
00:13:25,600 --> 00:13:29,080
means the dynamic linker and main by any

263
00:13:29,080 --> 00:13:29,600
real

264
00:13:29,600 --> 00:13:31,790
only in like five minutes 56 different

265
00:13:31,790 --> 00:13:38,660
positions if they are moved at all x

266
00:13:38,660 --> 00:13:41,690
yeah before that there were like 48

267
00:13:41,690 --> 00:13:45,970
different load addresses for the cam

268
00:13:46,449 --> 00:13:48,740
yeah for the case before they were like

269
00:13:48,740 --> 00:13:57,290
48 different Dalton dresses I think

270
00:13:57,290 --> 00:13:58,240
there's something wrong with right

271
00:13:58,240 --> 00:14:02,720
anyway now you have like 48 x 2000

272
00:14:02,720 --> 00:14:06,709
possible loads of dresses oh yeah no

273
00:14:06,709 --> 00:14:10,190
okay the number 48 is of course all the

274
00:14:10,190 --> 00:14:13,790
old firmware sir don't have our SLR so

275
00:14:13,790 --> 00:14:15,620
there are only 48 different film words

276
00:14:15,620 --> 00:14:18,350
that have the capability to have our SLR

277
00:14:18,350 --> 00:14:20,630
so there are four this firmware so you

278
00:14:20,630 --> 00:14:22,310
don't have like 48 different load

279
00:14:22,310 --> 00:14:24,290
addresses for a library but in this case

280
00:14:24,290 --> 00:14:28,490
because of a SLR your 48 x 4200

281
00:14:28,490 --> 00:14:31,100
different load addresses so this means

282
00:14:31,100 --> 00:14:33,889
the also to hit the right gadget it's

283
00:14:33,889 --> 00:14:36,110
like one in and two thousand two hundred

284
00:14:36,110 --> 00:14:40,459
thousand so this means we will always

285
00:14:40,459 --> 00:14:42,589
especially for old apps we will go to

286
00:14:42,589 --> 00:14:44,630
after the dynamic linker or the main

287
00:14:44,630 --> 00:14:46,310
binary because they are not moved and

288
00:14:46,310 --> 00:14:48,829
for news and new absence seems to even

289
00:14:48,829 --> 00:14:51,380
get to still be better use to go after

290
00:14:51,380 --> 00:14:54,620
that I make dynamic linker because it's

291
00:14:54,620 --> 00:14:57,230
only 256 instead of like two hundred

292
00:14:57,230 --> 00:15:00,610
thousand different possibilities

293
00:15:03,570 --> 00:15:10,680
oh well 4300 so in iOS 5 which was

294
00:15:10,680 --> 00:15:13,170
released yesterday so therefore there I

295
00:15:13,170 --> 00:15:15,630
don't have any full Atlantis I only saw

296
00:15:15,630 --> 00:15:18,210
some crash comes and it is crushed under

297
00:15:18,210 --> 00:15:20,550
it looks like and now the dynamic linker

298
00:15:20,550 --> 00:15:22,710
is always moved even if the main battery

299
00:15:22,710 --> 00:15:27,030
is not moved so in this case maybe you

300
00:15:27,030 --> 00:15:32,130
want to go after the main binary okay

301
00:15:32,130 --> 00:15:37,140
this was the introduction so now the

302
00:15:37,140 --> 00:15:39,510
question is we have yet certain odds

303
00:15:39,510 --> 00:15:44,370
like we can hit the yeah we have 81

304
00:15:44,370 --> 00:15:48,240
different targets and with our SLR we

305
00:15:48,240 --> 00:15:50,370
have liked 256 different positions for

306
00:15:50,370 --> 00:15:54,120
dynamic linker and 4200 for the cage so

307
00:15:54,120 --> 00:15:56,640
can we improve our odds and the first

308
00:15:56,640 --> 00:15:59,160
thing we sheet our odds by we attack the

309
00:15:59,160 --> 00:16:04,710
dynamic linker again to find a specific

310
00:16:04,710 --> 00:16:06,990
gadget inside the cages one in two

311
00:16:06,990 --> 00:16:11,190
hundred thousand and therefore the

312
00:16:11,190 --> 00:16:12,900
dynamic linker is the weakest spot and

313
00:16:12,900 --> 00:16:16,200
we will do some more in endless so you

314
00:16:16,200 --> 00:16:18,990
remember this picture these were all the

315
00:16:18,990 --> 00:16:21,510
firmware versions that are available for

316
00:16:21,510 --> 00:16:25,950
the iPhone or on the other I devices now

317
00:16:25,950 --> 00:16:31,560
we want to know what dynamic linkers are

318
00:16:31,560 --> 00:16:34,920
these firmware is running so this is

319
00:16:34,920 --> 00:16:37,650
like the most colorful slider ever had

320
00:16:37,650 --> 00:16:41,010
on any presentation this is you can see

321
00:16:41,010 --> 00:16:43,970
they are actually certain different

322
00:16:43,970 --> 00:16:46,590
dynamic linker binaries across all the

323
00:16:46,590 --> 00:16:50,750
iDevices you see here for the fall of 33

324
00:16:50,750 --> 00:16:54,720
you have always one dynamic linker for

325
00:16:54,720 --> 00:16:58,080
two versions and in the older days you

326
00:16:58,080 --> 00:17:00,060
had one pair version about about one

327
00:17:00,060 --> 00:17:03,120
perversion and you have a different

328
00:17:03,120 --> 00:17:05,400
dynamic linker between the arm six

329
00:17:05,400 --> 00:17:08,490
devices and the arm seven devices well

330
00:17:08,490 --> 00:17:11,640
of course and for the iphone 4 cdma

331
00:17:11,640 --> 00:17:13,950
version you also have different

332
00:17:13,950 --> 00:17:16,290
dynamic linker binaries in total there

333
00:17:16,290 --> 00:17:22,170
13 so now you can split that up in on

334
00:17:22,170 --> 00:17:25,079
the one hand you have 10 dynamic linkers

335
00:17:25,079 --> 00:17:32,430
for the firmwares without a SLR and you

336
00:17:32,430 --> 00:17:34,500
have three different dynamic linker

337
00:17:34,500 --> 00:17:37,710
binaries for your the other case for the

338
00:17:37,710 --> 00:17:40,140
ace of our case so basically you have

339
00:17:40,140 --> 00:17:44,100
three times fit 500 256 possible

340
00:17:44,100 --> 00:17:46,710
addresses for dynamic linker for for

341
00:17:46,710 --> 00:17:50,730
gadgets in the in the linker and instead

342
00:17:50,730 --> 00:17:55,770
of 48 48 2 times 4200 possible addresses

343
00:17:55,770 --> 00:17:58,410
for the catch it in the case so you see

344
00:17:58,410 --> 00:18:01,680
it's all a lot better basically when you

345
00:18:01,680 --> 00:18:04,980
calculate numbers you see as a one in

346
00:18:04,980 --> 00:18:08,910
two hundred thousand or one in 778 for a

347
00:18:08,910 --> 00:18:12,090
new application or for an old

348
00:18:12,090 --> 00:18:14,900
application you only have like one in

349
00:18:14,900 --> 00:18:17,900
certain

350
00:18:21,310 --> 00:18:26,330
so that's like without any trickery so

351
00:18:26,330 --> 00:18:28,220
the question is can we get any better

352
00:18:28,220 --> 00:18:34,010
than that and that's why the hope the

353
00:18:34,010 --> 00:18:35,950
whole talk about is about so-called

354
00:18:35,950 --> 00:18:38,230
ropes that work in multiple environments

355
00:18:38,230 --> 00:18:41,600
so also called multi environment Rob

356
00:18:41,600 --> 00:18:44,860
payloads and the idea is very simple

357
00:18:44,860 --> 00:18:48,290
when you look at this rob payload and I

358
00:18:48,290 --> 00:18:50,900
ask you what does it do then you can't

359
00:18:50,900 --> 00:18:53,420
answer this question because you don't

360
00:18:53,420 --> 00:18:55,460
know what is the target environment so

361
00:18:55,460 --> 00:18:56,840
you don't know where the libraries are

362
00:18:56,840 --> 00:18:58,310
you you actually don't know what's

363
00:18:58,310 --> 00:19:00,200
hiding behind all the addresses and

364
00:19:00,200 --> 00:19:02,090
that's why you can't tell me what it

365
00:19:02,090 --> 00:19:04,700
will do and you can even not tell me if

366
00:19:04,700 --> 00:19:06,320
it's like a full payload or it's just

367
00:19:06,320 --> 00:19:09,260
like a small snippet of a payload so in

368
00:19:09,260 --> 00:19:11,690
order to interpret what it's the meaning

369
00:19:11,690 --> 00:19:13,760
you have to put it in a target

370
00:19:13,760 --> 00:19:16,910
environment so the first environment I

371
00:19:16,910 --> 00:19:19,040
want to put it into is like the IP to

372
00:19:19,040 --> 00:19:25,270
cdma the latest iOS for the 3 version

373
00:19:26,080 --> 00:19:29,570
and when you go to the to the gadget you

374
00:19:29,570 --> 00:19:32,540
see the in grey this is the program

375
00:19:32,540 --> 00:19:35,210
counter right now and then you

376
00:19:35,210 --> 00:19:38,930
disassemble the arm up coats you will

377
00:19:38,930 --> 00:19:43,790
see that there's a it tries to write a

378
00:19:43,790 --> 00:19:47,420
bite from the hour 5 register into some

379
00:19:47,420 --> 00:19:49,430
address that is that the r6 registers

380
00:19:49,430 --> 00:19:53,270
plus 11 of course this is like an

381
00:19:53,270 --> 00:19:56,060
exploit so we most probably don't know

382
00:19:56,060 --> 00:19:58,460
the status of the r6 register at the

383
00:19:58,460 --> 00:20:02,870
moment that's why it's with ? in the

384
00:20:02,870 --> 00:20:07,150
register window so when we execute this

385
00:20:07,150 --> 00:20:09,970
it's very likely that this will crash

386
00:20:09,970 --> 00:20:13,100
because our six is something is an

387
00:20:13,100 --> 00:20:15,260
insular unutilized well basically the

388
00:20:15,260 --> 00:20:16,640
application that we are exploiting will

389
00:20:16,640 --> 00:20:18,950
initialize do something but maybe it's 0

390
00:20:18,950 --> 00:20:21,080
so it's an illegal pointer so we will

391
00:20:21,080 --> 00:20:24,320
crash so obviously this Rob payload will

392
00:20:24,320 --> 00:20:27,620
do nothing else and crash on the iPad to

393
00:20:27,620 --> 00:20:30,250
cdma

394
00:20:32,820 --> 00:20:35,590
now take one of the other iPads two

395
00:20:35,590 --> 00:20:38,919
versions like this gsm version again you

396
00:20:38,919 --> 00:20:41,860
can disassemble it and you will see that

397
00:20:41,860 --> 00:20:45,340
this time it will jump into the in 20

398
00:20:45,340 --> 00:20:47,830
bytes of the of ammo file header the

399
00:20:47,830 --> 00:20:49,659
executable file data so there will be a

400
00:20:49,659 --> 00:20:52,240
lot of zero bytes you see either is dis

401
00:20:52,240 --> 00:20:56,139
is having this as move your our zero to

402
00:20:56,139 --> 00:21:00,690
R 0 which is basically like a flag

403
00:21:00,690 --> 00:21:05,049
changing knob well knock code so it's

404
00:21:05,049 --> 00:21:06,669
actually only is changing the flags but

405
00:21:06,669 --> 00:21:09,279
not doing anything else and of course

406
00:21:09,279 --> 00:21:11,019
it's a legal opcode and what will happen

407
00:21:11,019 --> 00:21:14,590
it will execute it and this will move

408
00:21:14,590 --> 00:21:17,679
our 0 to r 0 and we just increase the

409
00:21:17,679 --> 00:21:19,809
program counter and nothing else will

410
00:21:19,809 --> 00:21:23,499
happen and because our 0 was unknown so

411
00:21:23,499 --> 00:21:25,210
it's still unknown and it's going

412
00:21:25,210 --> 00:21:27,879
further and further until we hit this

413
00:21:27,879 --> 00:21:30,249
one and this is the last of the 0 bytes

414
00:21:30,249 --> 00:21:33,820
and suddenly we start to go to the first

415
00:21:33,820 --> 00:21:38,049
bite of the real oh so this is the real

416
00:21:38,049 --> 00:21:41,440
code in the beginning of the motto so

417
00:21:41,440 --> 00:21:45,210
it's a load of some objective c

418
00:21:45,210 --> 00:21:48,970
structure and it loads it into the r3

419
00:21:48,970 --> 00:21:51,610
register and you can see when it's

420
00:21:51,610 --> 00:21:55,119
executed the it's filled basically it's

421
00:21:55,119 --> 00:21:57,610
the delta to there now we add the

422
00:21:57,610 --> 00:21:59,559
program counter to it so now it's a real

423
00:21:59,559 --> 00:22:01,749
pointer you see we have a pointer in r3

424
00:22:01,749 --> 00:22:04,389
which is obviously a legal pointer

425
00:22:04,389 --> 00:22:06,909
because it was created by adding

426
00:22:06,909 --> 00:22:08,860
something to the current program counter

427
00:22:08,860 --> 00:22:11,590
so when we try to load a value from

428
00:22:11,590 --> 00:22:14,350
there it will actually load so now we

429
00:22:14,350 --> 00:22:18,129
have this 18 in the r3 register and this

430
00:22:18,129 --> 00:22:19,840
is basically an offset inside the object

431
00:22:19,840 --> 00:22:23,049
for another yeah for the variable in

432
00:22:23,049 --> 00:22:25,690
this case I think it was some from the

433
00:22:25,690 --> 00:22:28,119
game kids and it's loading the the

434
00:22:28,119 --> 00:22:29,889
number of friends it's trying to load

435
00:22:29,889 --> 00:22:33,460
the number of friends you have okay but

436
00:22:33,460 --> 00:22:36,399
in this case the problem is now it tries

437
00:22:36,399 --> 00:22:38,649
to notice the friends from the r0

438
00:22:38,649 --> 00:22:41,169
register but again this is like unknown

439
00:22:41,169 --> 00:22:44,350
to us so we cannot find out how many

440
00:22:44,350 --> 00:22:44,980
friends

441
00:22:44,980 --> 00:22:47,470
because we have because we have no real

442
00:22:47,470 --> 00:22:51,630
point of their and again this will crash

443
00:22:52,530 --> 00:22:58,179
okay so let's try another device finally

444
00:22:58,179 --> 00:23:02,350
we come to the ipad 2 Wi-Fi and this

445
00:23:02,350 --> 00:23:04,510
time this looks like something usable

446
00:23:04,510 --> 00:23:06,580
because this time we just end up in

447
00:23:06,580 --> 00:23:09,400
there in on the pop-up code which will

448
00:23:09,400 --> 00:23:11,710
pop the or four or five and the program

449
00:23:11,710 --> 00:23:15,280
counter from the stack well we can just

450
00:23:15,280 --> 00:23:18,730
do that and now we have filled a four

451
00:23:18,730 --> 00:23:20,950
and A five and when different program

452
00:23:20,950 --> 00:23:23,290
counter and our stack pointer has moved

453
00:23:23,290 --> 00:23:26,470
and we are in another gadget which

454
00:23:26,470 --> 00:23:28,809
obviously moves are for two or three and

455
00:23:28,809 --> 00:23:31,299
then Jung somewhere else where we just

456
00:23:31,299 --> 00:23:35,850
do that again we end in an illegal

457
00:23:35,850 --> 00:23:39,429
gadget and again we pop our fall in a

458
00:23:39,429 --> 00:23:42,850
five we can do that and this time we

459
00:23:42,850 --> 00:23:44,260
ended I get you that moves the stack

460
00:23:44,260 --> 00:23:46,750
pointer into r2 and then room somewhere

461
00:23:46,750 --> 00:23:50,860
else we do that which will jump to a

462
00:23:50,860 --> 00:23:54,700
another jump we do that and this one

463
00:23:54,700 --> 00:23:57,130
will move the art to which was the stack

464
00:23:57,130 --> 00:23:59,770
pointer into r0 and returned from the

465
00:23:59,770 --> 00:24:03,490
function call well prop the stack again

466
00:24:03,490 --> 00:24:08,470
and now we have the stack pointer in

467
00:24:08,470 --> 00:24:11,380
side r0 and can write it to any

468
00:24:11,380 --> 00:24:13,150
arbitrary memory address in this case

469
00:24:13,150 --> 00:24:15,400
it's 41 41 41 41 which will obviously

470
00:24:15,400 --> 00:24:17,590
crash but this is like just because I

471
00:24:17,590 --> 00:24:22,000
wanted it to crash so we can see that

472
00:24:22,000 --> 00:24:25,090
obviously the rub payload I showed you

473
00:24:25,090 --> 00:24:27,490
was meant for exactly this device and

474
00:24:27,490 --> 00:24:31,120
what it does it will just fill the r0

475
00:24:31,120 --> 00:24:33,640
register with the stack pointer so you

476
00:24:33,640 --> 00:24:37,150
can find out in your payload where you

477
00:24:37,150 --> 00:24:41,919
are at the moment so what we learned is

478
00:24:41,919 --> 00:24:43,900
normally when you have Rob payload is

479
00:24:43,900 --> 00:24:46,179
designed for one environment and for one

480
00:24:46,179 --> 00:24:50,440
environment only and if you try it in

481
00:24:50,440 --> 00:24:53,200
different environments it will end up

482
00:24:53,200 --> 00:24:55,870
crashing most likely but what I can

483
00:24:55,870 --> 00:24:58,030
happen exactly is that your I ever had

484
00:24:58,030 --> 00:24:58,509
either

485
00:24:58,509 --> 00:24:59,979
at the same address have an illegal

486
00:24:59,979 --> 00:25:02,699
gadget like a crash or an endless loop

487
00:25:02,699 --> 00:25:05,379
you can ask their a different or

488
00:25:05,379 --> 00:25:07,959
comfortable valid gadget or you can have

489
00:25:07,959 --> 00:25:09,909
like even an identical gadget like the

490
00:25:09,909 --> 00:25:11,589
same gadget is at the same address in

491
00:25:11,589 --> 00:25:15,399
another environment so for the illegal

492
00:25:15,399 --> 00:25:19,269
gadgets of course when it's crashing

493
00:25:19,269 --> 00:25:21,429
it's not usable because in this case our

494
00:25:21,429 --> 00:25:24,909
expert will fail if it's an endless loop

495
00:25:24,909 --> 00:25:27,639
it's still not really usable for us but

496
00:25:27,639 --> 00:25:29,199
it will not crash because if we run an

497
00:25:29,199 --> 00:25:31,719
endless loop so we can survive this

498
00:25:31,719 --> 00:25:34,779
attempt to exploit but we cannot

499
00:25:34,779 --> 00:25:41,859
actually exploit in this case identical

500
00:25:41,859 --> 00:25:44,199
gadget on the other hand when you have

501
00:25:44,199 --> 00:25:46,479
enough different environments it's very

502
00:25:46,479 --> 00:25:48,369
likely that you actually find some

503
00:25:48,369 --> 00:25:51,039
identical gadgets but it's only

504
00:25:51,039 --> 00:25:52,839
happening for very trivial gadgets

505
00:25:52,839 --> 00:25:56,289
normally and it's very unlikely for only

506
00:25:56,289 --> 00:26:00,129
a few comparison partners the more

507
00:26:00,129 --> 00:26:02,379
interesting thing is that you find some

508
00:26:02,379 --> 00:26:04,359
gadget that they are similar to each

509
00:26:04,359 --> 00:26:08,559
other and do something that's not

510
00:26:08,559 --> 00:26:10,779
harmful so they don't crash and they

511
00:26:10,779 --> 00:26:12,999
load the program counter from the stack

512
00:26:12,999 --> 00:26:15,789
and just return or jump to it and the

513
00:26:15,789 --> 00:26:18,039
funniest thing here is when you find two

514
00:26:18,039 --> 00:26:19,869
gadgets in two different environments

515
00:26:19,869 --> 00:26:22,149
and they both load the program counter

516
00:26:22,149 --> 00:26:23,919
from the stack but they load it from

517
00:26:23,919 --> 00:26:27,159
different areas of the stack then you

518
00:26:27,159 --> 00:26:30,069
can distinguish between both in this

519
00:26:30,069 --> 00:26:32,919
case i found a gadget that retrieves the

520
00:26:32,919 --> 00:26:35,169
program counter from tech position 28

521
00:26:35,169 --> 00:26:38,529
and in the other case from the position

522
00:26:38,529 --> 00:26:42,849
for so when you jump to this one address

523
00:26:42,849 --> 00:26:44,949
that has this bar to your gadgets you

524
00:26:44,949 --> 00:26:46,989
know when it takes the program in the

525
00:26:46,989 --> 00:26:49,119
next program counter from position 28

526
00:26:49,119 --> 00:26:51,819
then it was the first case otherwise it

527
00:26:51,819 --> 00:26:53,529
will take the program counter from the

528
00:26:53,529 --> 00:26:57,190
fourth position so you can distinguish

529
00:26:57,190 --> 00:27:00,669
between two environments now that what

530
00:27:00,669 --> 00:27:04,299
you want to do is you want to have a way

531
00:27:04,299 --> 00:27:06,429
to do this for many environments at the

532
00:27:06,429 --> 00:27:07,929
same time and get the best possible

533
00:27:07,929 --> 00:27:08,760
results

534
00:27:08,760 --> 00:27:14,580
and if you do that by hand you will go

535
00:27:14,580 --> 00:27:17,490
nuts after a while because you have to

536
00:27:17,490 --> 00:27:21,180
backtrack very often and so I tried that

537
00:27:21,180 --> 00:27:22,850
with a dynamic linker and after like a

538
00:27:22,850 --> 00:27:25,740
half a day after I found some solution

539
00:27:25,740 --> 00:27:29,010
it was nice I saw like well let's also

540
00:27:29,010 --> 00:27:32,220
map that so I wrote a little arm

541
00:27:32,220 --> 00:27:34,910
emulator which I call the baby arm

542
00:27:34,910 --> 00:27:37,710
because it's really a very very basic

543
00:27:37,710 --> 00:27:40,650
armor me later this means it only

544
00:27:40,650 --> 00:27:43,650
emulates like a few instructions mostly

545
00:27:43,650 --> 00:27:49,530
only the some instructions and also it

546
00:27:49,530 --> 00:27:51,300
only any amulets a very few instructions

547
00:27:51,300 --> 00:27:53,520
it's good enough to find gadgets because

548
00:27:53,520 --> 00:27:57,210
I implement the the op codes that are

549
00:27:57,210 --> 00:27:59,970
used in the end of functions usually or

550
00:27:59,970 --> 00:28:03,930
around the subroutine calls so the idea

551
00:28:03,930 --> 00:28:06,060
is that we are give it an initial state

552
00:28:06,060 --> 00:28:09,330
of the registers and then let it run and

553
00:28:09,330 --> 00:28:11,970
at the end and either it errors out

554
00:28:11,970 --> 00:28:14,490
because there was a crash or it will

555
00:28:14,490 --> 00:28:16,020
give us a gadget and give us a final

556
00:28:16,020 --> 00:28:19,110
state and then we can check in the final

557
00:28:19,110 --> 00:28:20,910
state if it's like a special gadget that

558
00:28:20,910 --> 00:28:23,220
we search for or not and it's all

559
00:28:23,220 --> 00:28:24,750
implied implementer and Python and I

560
00:28:24,750 --> 00:28:27,600
will release it well I have to clean it

561
00:28:27,600 --> 00:28:29,340
up a little bit so i will reason the

562
00:28:29,340 --> 00:28:33,660
next two days or so at github so yeah so

563
00:28:33,660 --> 00:28:36,690
how does it work I hope you can read

564
00:28:36,690 --> 00:28:39,060
that basically what it does its first it

565
00:28:39,060 --> 00:28:40,890
reached in the inspection bites from

566
00:28:40,890 --> 00:28:42,930
from the dynamic linker binary for

567
00:28:42,930 --> 00:28:45,120
example then it sets a program counter

568
00:28:45,120 --> 00:28:47,580
20 and then it looks through all the

569
00:28:47,580 --> 00:28:50,850
bites and basically every every position

570
00:28:50,850 --> 00:28:54,540
dividable by 4 will be sent to the arm

571
00:28:54,540 --> 00:28:58,830
emulator and every dividable by 2 will

572
00:28:58,830 --> 00:29:03,360
be sent to the thump emulator and of

573
00:29:03,360 --> 00:29:06,690
course we just loops with and yeah and

574
00:29:06,690 --> 00:29:08,190
the end will give out all the gadgets

575
00:29:08,190 --> 00:29:11,850
that were found when we look at the

576
00:29:11,850 --> 00:29:15,870
inner loop we will see the first thing

577
00:29:15,870 --> 00:29:18,930
that will get the initial state because

578
00:29:18,930 --> 00:29:20,850
the initial state tells it like for

579
00:29:20,850 --> 00:29:21,630
example

580
00:29:21,630 --> 00:29:25,320
registers are unknown or we have a stack

581
00:29:25,320 --> 00:29:28,560
pointer in register 0 or we have the

582
00:29:28,560 --> 00:29:32,130
value 15 in riga stuff for if we know

583
00:29:32,130 --> 00:29:33,960
this about our crash we can just put it

584
00:29:33,960 --> 00:29:36,240
into the initial state and then if

585
00:29:36,240 --> 00:29:37,920
you'll find different gadgets depending

586
00:29:37,920 --> 00:29:42,480
on the state so now the inner loop will

587
00:29:42,480 --> 00:29:44,610
read the next instruction bites at the

588
00:29:44,610 --> 00:29:48,000
program counter and then from the stated

589
00:29:48,000 --> 00:29:49,890
knows if it's correct right now in the

590
00:29:49,890 --> 00:29:52,050
sub mode or in the arm mode if it's in

591
00:29:52,050 --> 00:29:53,810
our mode if we give it to the arm

592
00:29:53,810 --> 00:29:57,240
emulator everything the some motive will

593
00:29:57,240 --> 00:29:58,770
check if it's is a 16-bit or 32-bit

594
00:29:58,770 --> 00:30:01,260
instruction and then give it to two

595
00:30:01,260 --> 00:30:04,800
different emulators and each emulator

596
00:30:04,800 --> 00:30:06,660
just immolates one single instruction

597
00:30:06,660 --> 00:30:10,410
and then returns and it can return an

598
00:30:10,410 --> 00:30:12,330
error this means for example it's a

599
00:30:12,330 --> 00:30:14,490
crash or it's an opcode we don't support

600
00:30:14,490 --> 00:30:16,770
so it's an arrow and snow gadget found

601
00:30:16,770 --> 00:30:20,160
the inner loop ends if it's not

602
00:30:20,160 --> 00:30:22,200
returning an error then we check if it's

603
00:30:22,200 --> 00:30:24,090
in a desired state and dark desired

604
00:30:24,090 --> 00:30:26,850
state could be for example we have

605
00:30:26,850 --> 00:30:29,700
suddenly a value in the in the program

606
00:30:29,700 --> 00:30:32,550
counter that was taken from the stack so

607
00:30:32,550 --> 00:30:33,810
this is usually the end of a gadget

608
00:30:33,810 --> 00:30:37,700
because it's a pop or a jump to to some

609
00:30:37,700 --> 00:30:40,790
program counter to a new program counter

610
00:30:40,790 --> 00:30:43,860
so if we are not in the desired end

611
00:30:43,860 --> 00:30:46,170
state we just adjust the program counter

612
00:30:46,170 --> 00:30:48,630
for the next run which is usually just +

613
00:30:48,630 --> 00:30:51,450
2 or plus 4 but sometimes it's like in a

614
00:30:51,450 --> 00:30:52,620
branch instruction it's something

615
00:30:52,620 --> 00:30:54,960
different but if we enter the desired

616
00:30:54,960 --> 00:30:57,330
state we collect this gadget and output

617
00:30:57,330 --> 00:31:04,140
it to our main loop so what's all inside

618
00:31:04,140 --> 00:31:07,440
the state the state contains of course

619
00:31:07,440 --> 00:31:09,630
all the registers it contains all the

620
00:31:09,630 --> 00:31:12,960
flex the IT blog information if you know

621
00:31:12,960 --> 00:31:15,480
into no arm then you know the sum then

622
00:31:15,480 --> 00:31:18,930
you know what are the IT is it contains

623
00:31:18,930 --> 00:31:21,090
the CPU mode so if it's running arm or

624
00:31:21,090 --> 00:31:24,120
some mode right now and it has a system

625
00:31:24,120 --> 00:31:25,830
state like there's error condition or

626
00:31:25,830 --> 00:31:27,090
there's a stop condition because a

627
00:31:27,090 --> 00:31:30,600
desired state was reached when we look

628
00:31:30,600 --> 00:31:31,920
at the flex

629
00:31:31,920 --> 00:31:34,080
are we emulate all the flightline

630
00:31:34,080 --> 00:31:38,760
negative carry over flow and 0 and the

631
00:31:38,760 --> 00:31:40,770
Flex can be either in the state unknown

632
00:31:40,770 --> 00:31:43,380
which means we don't know if the flag is

633
00:31:43,380 --> 00:31:46,260
set or not or it's in the state of value

634
00:31:46,260 --> 00:31:47,970
which means we know it's set or not and

635
00:31:47,970 --> 00:31:52,800
in this case it can be set or not four

636
00:31:52,800 --> 00:31:54,180
registers a little bit more complicated

637
00:31:54,180 --> 00:31:58,410
we have far more states we have the

638
00:31:58,410 --> 00:32:00,210
unknown stage which means we don't know

639
00:32:00,210 --> 00:32:01,950
the value of the register for example

640
00:32:01,950 --> 00:32:04,610
right after the exploit app is happening

641
00:32:04,610 --> 00:32:08,570
we actually know the value of a register

642
00:32:08,570 --> 00:32:11,610
we know the value was popped from the

643
00:32:11,610 --> 00:32:14,820
stack it's a stack value and so it's a

644
00:32:14,820 --> 00:32:16,920
user-defined because we can define it in

645
00:32:16,920 --> 00:32:19,560
an inner up a load or it's a stack

646
00:32:19,560 --> 00:32:22,080
pointer value which means yeah basically

647
00:32:22,080 --> 00:32:23,970
it's a stack pointer it's a copy of the

648
00:32:23,970 --> 00:32:28,890
stack pointer yeah and in the beginning

649
00:32:28,890 --> 00:32:30,960
I wanted to add some some other things

650
00:32:30,960 --> 00:32:32,970
like a normal pointer for memory access

651
00:32:32,970 --> 00:32:37,260
and program counter where you but it

652
00:32:37,260 --> 00:32:39,330
turned out I don't even need that for my

653
00:32:39,330 --> 00:32:41,430
own for my stuff it will maybe improve

654
00:32:41,430 --> 00:32:43,290
the analysis if I do that but right now

655
00:32:43,290 --> 00:32:46,710
it still works without it and depending

656
00:32:46,710 --> 00:32:49,080
on what state the registers in there the

657
00:32:49,080 --> 00:32:50,910
way you mean something different of

658
00:32:50,910 --> 00:32:52,590
course for an unknown value it's just

659
00:32:52,590 --> 00:32:55,260
nothing it's just ignored for a value

660
00:32:55,260 --> 00:32:58,680
estate it means the actual value for

661
00:32:58,680 --> 00:33:01,620
stack value it tells you what position

662
00:33:01,620 --> 00:33:03,540
this value was popped up from the stick

663
00:33:03,540 --> 00:33:08,120
so it's a stack pointer for example at

664
00:33:08,120 --> 00:33:11,760
position 8 register 3 was popped this is

665
00:33:11,760 --> 00:33:14,340
the information in there and and of

666
00:33:14,340 --> 00:33:16,530
course the stack pointer value types

667
00:33:16,530 --> 00:33:19,230
just is the value of the actual stack

668
00:33:19,230 --> 00:33:22,950
pointer I start by 0 so it's not a real

669
00:33:22,950 --> 00:33:26,810
stack pointer starting at 0

670
00:33:30,409 --> 00:33:32,779
so when I said on Twitter that I

671
00:33:32,779 --> 00:33:35,970
implemented an arm emulator every most

672
00:33:35,970 --> 00:33:37,950
likely yeah why why don't you base it on

673
00:33:37,950 --> 00:33:39,570
something else and why don't you base it

674
00:33:39,570 --> 00:33:43,580
on idea or something like pin Navi and

675
00:33:43,580 --> 00:33:45,779
one of the reasons why I wrote my own

676
00:33:45,779 --> 00:33:47,399
stuff is when you look at the other

677
00:33:47,399 --> 00:33:50,100
tools they're usually our when they look

678
00:33:50,100 --> 00:33:51,779
at it this assembly they can other only

679
00:33:51,779 --> 00:33:56,309
disassemble something as either an hour

680
00:33:56,309 --> 00:33:59,370
mode or in some mode and they cannot

681
00:33:59,370 --> 00:34:02,190
jump into a 32-bit arm instruction or

682
00:34:02,190 --> 00:34:06,450
into a 32-bit some instruction so a lot

683
00:34:06,450 --> 00:34:08,399
of things they will miss and one thing

684
00:34:08,399 --> 00:34:11,070
they will miss is that like nearly all

685
00:34:11,070 --> 00:34:14,399
of the arm mode function prologue

686
00:34:14,399 --> 00:34:17,989
epilogues are actually at the same time

687
00:34:17,989 --> 00:34:21,989
function epilogues for some mode you can

688
00:34:21,989 --> 00:34:25,739
see in the first case there's like the

689
00:34:25,739 --> 00:34:28,020
india unmowed it's loading some

690
00:34:28,020 --> 00:34:31,739
registers from the stack pointer from

691
00:34:31,739 --> 00:34:33,079
the address of the stack pointer

692
00:34:33,079 --> 00:34:36,000
including the program counter at the end

693
00:34:36,000 --> 00:34:37,710
so it's returning from a function and

694
00:34:37,710 --> 00:34:40,319
when you just disassemble the same bytes

695
00:34:40,319 --> 00:34:43,530
as arm as some you will see it's

696
00:34:43,530 --> 00:34:45,839
shifting around the r0 register and then

697
00:34:45,839 --> 00:34:48,149
pops some registers including the

698
00:34:48,149 --> 00:34:49,859
program counter so it's also return of a

699
00:34:49,859 --> 00:34:52,379
function and all these things will be

700
00:34:52,379 --> 00:34:54,179
miss if you do something like either or

701
00:34:54,179 --> 00:35:00,480
been a VSS base so now I can use my my

702
00:35:00,480 --> 00:35:05,390
baby arm for finding gadgets and of

703
00:35:05,390 --> 00:35:09,240
course normally I say okay it's a

704
00:35:09,240 --> 00:35:11,579
crashing in the binary it's not overflow

705
00:35:11,579 --> 00:35:15,180
so I don't know about any register

706
00:35:15,180 --> 00:35:18,180
everything is unknown so by definition

707
00:35:18,180 --> 00:35:21,329
the only gadgets it can it can find our

708
00:35:21,329 --> 00:35:23,940
gadgets that pop the program counter

709
00:35:23,940 --> 00:35:25,950
from the stack and this is just like a

710
00:35:25,950 --> 00:35:27,960
collection of some gadget is founder of

711
00:35:27,960 --> 00:35:29,940
course it far more gadget in a dynamic

712
00:35:29,940 --> 00:35:32,460
linker but you see there some that just

713
00:35:32,460 --> 00:35:36,089
just pops sometimes there's like an end

714
00:35:36,089 --> 00:35:38,280
before all there so it's a move before

715
00:35:38,280 --> 00:35:41,070
or there's a branch before that

716
00:35:41,070 --> 00:35:43,830
and you can always see I would address

717
00:35:43,830 --> 00:35:45,870
the program counter was taken from the

718
00:35:45,870 --> 00:35:48,900
from the stack yeah this is just like a

719
00:35:48,900 --> 00:35:53,520
basic example how to use it but if you

720
00:35:53,520 --> 00:35:55,650
want to apply additional restrictions or

721
00:35:55,650 --> 00:35:57,720
restrictions you can just check them

722
00:35:57,720 --> 00:35:59,910
after it returns or gadget found you can

723
00:35:59,910 --> 00:36:04,290
just check the the end state so what you

724
00:36:04,290 --> 00:36:07,440
can do is for example you just first

725
00:36:07,440 --> 00:36:09,210
initialize it's a completely unknown

726
00:36:09,210 --> 00:36:12,120
state and then set the register value of

727
00:36:12,120 --> 00:36:15,660
r 42 some value and then you let it find

728
00:36:15,660 --> 00:36:17,850
all the gadgets and in the end you will

729
00:36:17,850 --> 00:36:19,770
check which of the gadget suddenly has

730
00:36:19,770 --> 00:36:24,750
the same value in are 0s r 4 and then

731
00:36:24,750 --> 00:36:26,280
output all the gadgets and you will see

732
00:36:26,280 --> 00:36:29,040
this these gadgets always all move the

733
00:36:29,040 --> 00:36:32,340
value of r 4 into the r0 register so

734
00:36:32,340 --> 00:36:35,310
sometimes it's done directly sometimes

735
00:36:35,310 --> 00:36:38,400
you first have a branch sometimes it's

736
00:36:38,400 --> 00:36:40,890
moving it into the r6 register first and

737
00:36:40,890 --> 00:36:43,310
then moving the rs6 register into the

738
00:36:43,310 --> 00:36:47,430
r10 register so it's all like this kind

739
00:36:47,430 --> 00:36:55,800
of ya get it the next thing that you may

740
00:36:55,800 --> 00:36:57,840
want want two tries you also want to

741
00:36:57,840 --> 00:36:59,940
find all the other so-called free branch

742
00:36:59,940 --> 00:37:01,860
instructions so you want to find

743
00:37:01,860 --> 00:37:04,320
something like be Alex and some register

744
00:37:04,320 --> 00:37:09,480
because it's also usable for up well you

745
00:37:09,480 --> 00:37:11,330
shouldn't call it drop then but it's

746
00:37:11,330 --> 00:37:16,260
code reuse so yeah what how you do that

747
00:37:16,260 --> 00:37:18,150
first you go through all registers and

748
00:37:18,150 --> 00:37:20,550
give it a stack value which means the

749
00:37:20,550 --> 00:37:22,350
emulator believes that each of each

750
00:37:22,350 --> 00:37:24,870
register is under your control so Abby

751
00:37:24,870 --> 00:37:27,590
legs are three will suddenly be well it

752
00:37:27,590 --> 00:37:30,150
what you can do now is you will just let

753
00:37:30,150 --> 00:37:31,800
beginner ate all the gadgets and in the

754
00:37:31,800 --> 00:37:34,170
end you check if one of the registers

755
00:37:34,170 --> 00:37:37,710
contains an a register of type s p value

756
00:37:37,710 --> 00:37:41,240
which means somehow inside the gadget

757
00:37:41,240 --> 00:37:44,220
the stack pointer was moved into one

758
00:37:44,220 --> 00:37:47,250
register you can see it finds different

759
00:37:47,250 --> 00:37:52,230
kind of gadgets on the left side all the

760
00:37:52,230 --> 00:37:53,580
gadgets move the stack

761
00:37:53,580 --> 00:37:56,910
enter into our to the stick point is in

762
00:37:56,910 --> 00:37:59,460
our thoughts our team and on the right

763
00:37:59,460 --> 00:38:02,010
side the stack pointers moved in the r0

764
00:38:02,010 --> 00:38:07,740
register okay so that's how it looks

765
00:38:07,740 --> 00:38:10,110
like the output and how how it will be

766
00:38:10,110 --> 00:38:12,900
working so now the question is how can

767
00:38:12,900 --> 00:38:16,490
we use that to improve our odds

768
00:38:26,280 --> 00:38:29,490
so when we remember I told you there are

769
00:38:29,490 --> 00:38:31,770
certain different dynamic linker

770
00:38:31,770 --> 00:38:36,600
binaries and what I did is I download

771
00:38:36,600 --> 00:38:38,430
all the firmwares and extracted all the

772
00:38:38,430 --> 00:38:42,720
dynamic linker binaries and just renamed

773
00:38:42,720 --> 00:38:45,870
them to build underscore and the md5

774
00:38:45,870 --> 00:38:49,470
hash of the of the binary and then you

775
00:38:49,470 --> 00:38:51,510
can get this table of things and all my

776
00:38:51,510 --> 00:38:53,430
tools now work on this table of things

777
00:38:53,430 --> 00:38:59,240
and what we can do now is we can use our

778
00:38:59,240 --> 00:39:02,820
baby arm use it in an inner pizen script

779
00:39:02,820 --> 00:39:06,660
and what we do is we load all the text

780
00:39:06,660 --> 00:39:08,820
segments of all the binaries into memory

781
00:39:08,820 --> 00:39:12,750
and then we for each text segment we let

782
00:39:12,750 --> 00:39:15,450
baby arm find all the gadget defines for

783
00:39:15,450 --> 00:39:17,330
each position in the text segment and

784
00:39:17,330 --> 00:39:21,510
then we intersect the results and we

785
00:39:21,510 --> 00:39:24,390
will find well if we are lucky we will

786
00:39:24,390 --> 00:39:28,530
find addresses where it finds four

787
00:39:28,530 --> 00:39:31,340
different dual binaries it finds

788
00:39:31,340 --> 00:39:35,280
basically the same now well again you

789
00:39:35,280 --> 00:39:37,830
define to get it for the same address or

790
00:39:37,830 --> 00:39:42,360
what I didn't tell before is I split

791
00:39:42,360 --> 00:39:45,510
that in two groups before for the two

792
00:39:45,510 --> 00:39:49,170
that one and after for one simple reason

793
00:39:49,170 --> 00:39:53,040
if I I did this experiment before so I

794
00:39:53,040 --> 00:39:55,230
know that it's not possible to find

795
00:39:55,230 --> 00:39:57,570
something they were working on

796
00:39:57,570 --> 00:40:00,930
everything so this is the minimal set

797
00:40:00,930 --> 00:40:04,170
for half of the things I can find common

798
00:40:04,170 --> 00:40:06,420
gadgets for the first half ended for a

799
00:40:06,420 --> 00:40:08,160
second half I will only demonstrate it

800
00:40:08,160 --> 00:40:11,910
for the second half now so when you

801
00:40:11,910 --> 00:40:13,920
actually ask baby arm to find something

802
00:40:13,920 --> 00:40:17,280
you will see it finds in each of the

803
00:40:17,280 --> 00:40:20,520
seven bynars if it finds a gadget at the

804
00:40:20,520 --> 00:40:27,150
specific to fe 0 15 e 8 address and you

805
00:40:27,150 --> 00:40:30,330
can also see that it's what kind of

806
00:40:30,330 --> 00:40:32,490
gadget was found something in our first

807
00:40:32,490 --> 00:40:35,280
something complicated and then the end

808
00:40:35,280 --> 00:40:38,360
just like a Pop are seven and pc

809
00:40:38,360 --> 00:40:41,330
and you can also see in red what the

810
00:40:41,330 --> 00:40:43,130
address of the program counter on the

811
00:40:43,130 --> 00:40:50,330
stack is so you see first this this

812
00:40:50,330 --> 00:40:52,670
first gather diffuse it will allow you

813
00:40:52,670 --> 00:40:55,880
to distinguish between the ARM version

814
00:40:55,880 --> 00:40:58,940
on 640 tulips one and all the others

815
00:40:58,940 --> 00:41:03,080
because the arm 61 will load the program

816
00:41:03,080 --> 00:41:05,780
counter from in position 32 and all the

817
00:41:05,780 --> 00:41:08,090
others will also have like a valid

818
00:41:08,090 --> 00:41:09,320
gadget there and they will load the

819
00:41:09,320 --> 00:41:11,600
program counter from the position plus

820
00:41:11,600 --> 00:41:17,720
four because it's the r7 PC get it so

821
00:41:17,720 --> 00:41:20,330
obviously the next step is we will try

822
00:41:20,330 --> 00:41:24,290
to give baby arm the other six the

823
00:41:24,290 --> 00:41:26,630
remaining six and try to find some

824
00:41:26,630 --> 00:41:28,760
gadget that is common among all of them

825
00:41:28,760 --> 00:41:31,910
and when we do that we will see that

826
00:41:31,910 --> 00:41:35,290
this time it clustered in two different

827
00:41:35,290 --> 00:41:38,450
gadgets they're very similar it's both

828
00:41:38,450 --> 00:41:43,960
times a branch followed by some pop and

829
00:41:43,960 --> 00:41:49,250
basically it's using the first Gidget as

830
00:41:49,250 --> 00:41:52,190
a start point so when you when you count

831
00:41:52,190 --> 00:41:54,320
now the program counter is taken from

832
00:41:54,320 --> 00:41:59,390
position 20 which is actually yeah 16

833
00:41:59,390 --> 00:42:04,490
plus the fall from the last time because

834
00:42:04,490 --> 00:42:09,830
this gadget starts at position 4 and the

835
00:42:09,830 --> 00:42:12,260
other Gators started position for also

836
00:42:12,260 --> 00:42:14,270
but it takes the program counter for now

837
00:42:14,270 --> 00:42:18,800
from this position 24 so now by using

838
00:42:18,800 --> 00:42:21,290
two gadgets we obviously can distinguish

839
00:42:21,290 --> 00:42:24,950
between the first one the the arm 61 and

840
00:42:24,950 --> 00:42:28,160
we can distinguish between these two

841
00:42:28,160 --> 00:42:32,780
groups obviously the next step is we

842
00:42:32,780 --> 00:42:36,470
will try to go further at the third

843
00:42:36,470 --> 00:42:40,760
gadget so again we we ask for both of

844
00:42:40,760 --> 00:42:42,800
the groups we asked but this time

845
00:42:42,800 --> 00:42:44,810
independently where for both of the

846
00:42:44,810 --> 00:42:47,390
groups we start a baby arm again on the

847
00:42:47,390 --> 00:42:50,240
three binaries and in the first case for

848
00:42:50,240 --> 00:42:51,300
the old

849
00:42:51,300 --> 00:42:54,030
dynamic linkers it will return to groups

850
00:42:54,030 --> 00:42:58,440
again one spends the first two dynamic

851
00:42:58,440 --> 00:42:59,940
linkers and the and the second group is

852
00:42:59,940 --> 00:43:05,010
the last one and yeah you see again the

853
00:43:05,010 --> 00:43:06,960
sub branch and two pops and the other

854
00:43:06,960 --> 00:43:09,240
one is just the pop and it's loading the

855
00:43:09,240 --> 00:43:11,400
program counter from different offsets

856
00:43:11,400 --> 00:43:15,420
again so it's usable basically I had to

857
00:43:15,420 --> 00:43:16,890
try a little bit around so that they

858
00:43:16,890 --> 00:43:19,830
don't collide but yeah because I get a

859
00:43:19,830 --> 00:43:21,420
list from baby arm of all the gadgets

860
00:43:21,420 --> 00:43:25,490
and just take one that don't collide and

861
00:43:25,490 --> 00:43:28,620
for the over for the newab dynamic

862
00:43:28,620 --> 00:43:30,000
linker so you have the same situation

863
00:43:30,000 --> 00:43:34,890
the first two are found as the same

864
00:43:34,890 --> 00:43:38,940
gadget and then the second case for the

865
00:43:38,940 --> 00:43:40,760
last one there's the second case and

866
00:43:40,760 --> 00:43:43,770
again it's like either a simple pop or

867
00:43:43,770 --> 00:43:48,000
shift and two puffs and obviously now we

868
00:43:48,000 --> 00:43:51,380
can distinguish between the first one

869
00:43:51,380 --> 00:43:54,900
the first group this one this one this

870
00:43:54,900 --> 00:43:58,140
one so we have five different groups

871
00:43:58,140 --> 00:43:59,550
right now that we can distinguish

872
00:43:59,550 --> 00:44:03,120
between and what we do now would be of

873
00:44:03,120 --> 00:44:06,660
course well try to split up the other

874
00:44:06,660 --> 00:44:10,230
two and you can try that or I tried that

875
00:44:10,230 --> 00:44:13,680
and then I realized it cannot find a way

876
00:44:13,680 --> 00:44:15,540
to distinguish between to both of them

877
00:44:15,540 --> 00:44:20,490
and the reason for that is um when you

878
00:44:20,490 --> 00:44:22,650
look at the first two dynamic link us

879
00:44:22,650 --> 00:44:24,330
they only 18 nine different bytes in

880
00:44:24,330 --> 00:44:25,920
there so they're basically the same

881
00:44:25,920 --> 00:44:28,410
binary some just some field is different

882
00:44:28,410 --> 00:44:30,390
maybe some checksum is different or

883
00:44:30,390 --> 00:44:31,680
something like that or some version

884
00:44:31,680 --> 00:44:33,600
numbers just different but aside from

885
00:44:33,600 --> 00:44:36,330
that they are bite identical I'm the

886
00:44:36,330 --> 00:44:38,490
second case there are even only 66 by

887
00:44:38,490 --> 00:44:44,280
it's different so yeah so this means for

888
00:44:44,280 --> 00:44:47,280
all piata exportation they are basically

889
00:44:47,280 --> 00:44:49,500
the same binary files so all the other

890
00:44:49,500 --> 00:44:52,380
Gators will be in the same place this

891
00:44:52,380 --> 00:44:55,320
may be like a very very few exceptions

892
00:44:55,320 --> 00:44:59,100
that fit into these 66 bites but I think

893
00:44:59,100 --> 00:45:00,690
the difference we are in the head are

894
00:45:00,690 --> 00:45:01,660
not in the

895
00:45:01,660 --> 00:45:05,890
not in the actual text segment so

896
00:45:05,890 --> 00:45:07,359
basically the text segment should be

897
00:45:07,359 --> 00:45:12,190
more or less identical so now we have

898
00:45:12,190 --> 00:45:20,069
collected all these yeah well use and

899
00:45:20,069 --> 00:45:22,630
now we here we can like just put them

900
00:45:22,630 --> 00:45:28,059
into our Rock payloads and well I just

901
00:45:28,059 --> 00:45:31,930
see I miss one smile that show get so so

902
00:45:31,930 --> 00:45:33,460
basically what we have now is we have

903
00:45:33,460 --> 00:45:37,329
one Rock payload and in the beginning we

904
00:45:37,329 --> 00:45:40,990
put the first distinguishing get it then

905
00:45:40,990 --> 00:45:43,210
at the right position the next one and

906
00:45:43,210 --> 00:45:46,180
so on the position where we have to put

907
00:45:46,180 --> 00:45:50,410
it we know from the red numbers and then

908
00:45:50,410 --> 00:45:55,119
we can build it and this would be then

909
00:45:55,119 --> 00:45:57,280
the soccer but I call the switcher

910
00:45:57,280 --> 00:46:00,700
payload and our whole payload in the end

911
00:46:00,700 --> 00:46:03,039
will look like this we have to switch

912
00:46:03,039 --> 00:46:05,470
your payload and some copy stuffs some

913
00:46:05,470 --> 00:46:07,539
real payload and then the shell payroll

914
00:46:07,539 --> 00:46:13,270
data and the switcher payload we just

915
00:46:13,270 --> 00:46:18,819
use yeah it can distinguish between all

916
00:46:18,819 --> 00:46:22,029
the the binaries and now we need stack

917
00:46:22,029 --> 00:46:26,980
at once in gadgets because in the first

918
00:46:26,980 --> 00:46:29,349
group in the switcher payload now we

919
00:46:29,349 --> 00:46:31,089
have the problem at some point we know

920
00:46:31,089 --> 00:46:33,819
okay this is exactly this binary but

921
00:46:33,819 --> 00:46:36,240
what is the next scheduled you jump to

922
00:46:36,240 --> 00:46:38,770
we somehow want to come from the

923
00:46:38,770 --> 00:46:40,539
switcher to the copy stop one in the

924
00:46:40,539 --> 00:46:42,309
first case we want to come from the

925
00:46:42,309 --> 00:46:44,049
switch up here to the copy stop two in

926
00:46:44,049 --> 00:46:47,140
the second case and so on so we need a

927
00:46:47,140 --> 00:46:50,410
stack at once in gadgets so we will just

928
00:46:50,410 --> 00:46:52,000
return to a gadget they will move the

929
00:46:52,000 --> 00:46:53,950
stack pointer around so that we end up

930
00:46:53,950 --> 00:46:57,490
in the right copy stop and when we ask

931
00:46:57,490 --> 00:46:59,559
baby arm to do find something like this

932
00:46:59,559 --> 00:47:01,299
we will find for example these gadgets

933
00:47:01,299 --> 00:47:06,940
that move the stack pointer by 48-32 and

934
00:47:06,940 --> 00:47:12,010
forty four bytes and this is actually

935
00:47:12,010 --> 00:47:13,170
good enough

936
00:47:13,170 --> 00:47:15,420
because our copy stuff will be very very

937
00:47:15,420 --> 00:47:21,990
small our copy stuff will be 40 bytes so

938
00:47:21,990 --> 00:47:28,290
this is a copy stop so for each dynamic

939
00:47:28,290 --> 00:47:30,299
linker for each of the in the group of

940
00:47:30,299 --> 00:47:33,780
each each of the five we need to create

941
00:47:33,780 --> 00:47:37,290
some gadgets that will implement this

942
00:47:37,290 --> 00:47:41,010
soil code and the Scala code tries to

943
00:47:41,010 --> 00:47:43,609
retrieve the current stack pointer then

944
00:47:43,609 --> 00:47:47,040
copies the data from the current stack

945
00:47:47,040 --> 00:47:50,010
pointer to some known location for

946
00:47:50,010 --> 00:47:52,380
example we just take the BSS segment of

947
00:47:52,380 --> 00:47:54,900
the dynamic linker just some writable

948
00:47:54,900 --> 00:47:58,200
location that we know then we set the

949
00:47:58,200 --> 00:48:01,109
stack pointer the new one into the new

950
00:48:01,109 --> 00:48:03,750
location plus some Delta the Delta will

951
00:48:03,750 --> 00:48:05,579
be calculated from the address of the

952
00:48:05,579 --> 00:48:10,230
copy stop to to the payload Boojum want

953
00:48:10,230 --> 00:48:13,470
to jump to and then we just like return

954
00:48:13,470 --> 00:48:16,549
there and this sounds very complicated

955
00:48:16,549 --> 00:48:20,640
but in reality you can just do that with

956
00:48:20,640 --> 00:48:23,190
this ten stack values and two of them

957
00:48:23,190 --> 00:48:25,829
are even unused the the gray ones are

958
00:48:25,829 --> 00:48:29,400
unused the yellow ones are the data like

959
00:48:29,400 --> 00:48:31,619
the non location the size of the copy

960
00:48:31,619 --> 00:48:34,020
operation and all the other things are

961
00:48:34,020 --> 00:48:37,670
like addresses of gadgets and functions

962
00:48:37,670 --> 00:48:43,859
so these are 40 bytes so for every

963
00:48:43,859 --> 00:48:46,500
dynamic linker we can generate these 40

964
00:48:46,500 --> 00:48:49,920
bytes we have just to take the different

965
00:48:49,920 --> 00:48:52,290
address of the gadgets and for the older

966
00:48:52,290 --> 00:48:54,630
linkers we need a little bit different

967
00:48:54,630 --> 00:48:59,490
gadgets but yeah for the first three

968
00:48:59,490 --> 00:49:00,869
cases we can just like take the

969
00:49:00,869 --> 00:49:02,910
different addresses so the same gadget

970
00:49:02,910 --> 00:49:05,190
just put in another address and then we

971
00:49:05,190 --> 00:49:08,450
have like five blocks of 40 bytes and

972
00:49:08,450 --> 00:49:13,170
then we have all our copy stop and at

973
00:49:13,170 --> 00:49:17,460
this point we can generate the the

974
00:49:17,460 --> 00:49:20,849
actual payload and this can be some

975
00:49:20,849 --> 00:49:26,160
longer rap sing it can be like a real

976
00:49:26,160 --> 00:49:27,569
i exploit that were completed you

977
00:49:27,569 --> 00:49:29,940
jailbreak the device but in this case

978
00:49:29,940 --> 00:49:32,849
you have to do it five times with the

979
00:49:32,849 --> 00:49:37,170
five different gadgets it can be simply

980
00:49:37,170 --> 00:49:41,010
vibrate shell cold which will be very

981
00:49:41,010 --> 00:49:44,549
unusable for an iPad but yeah for iphone

982
00:49:44,549 --> 00:49:46,200
it will vibrate no matter what I phone

983
00:49:46,200 --> 00:49:49,500
you have you can steal a file of course

984
00:49:49,500 --> 00:49:51,809
but my favorite is that you just

985
00:49:51,809 --> 00:49:54,450
implement some connect back that will

986
00:49:54,450 --> 00:49:56,869
post information about the current

987
00:49:56,869 --> 00:50:00,150
environment to the remote server and

988
00:50:00,150 --> 00:50:01,829
then the remote server knows exactly

989
00:50:01,829 --> 00:50:04,049
what version you are on and then it can

990
00:50:04,049 --> 00:50:07,309
you give you back payload that is only

991
00:50:07,309 --> 00:50:12,750
designed for your specific case the ice

992
00:50:12,750 --> 00:50:15,960
a cage in this case because in the cage

993
00:50:15,960 --> 00:50:18,599
of course you have 103 megabytes of data

994
00:50:18,599 --> 00:50:21,299
and there are far more different gadgets

995
00:50:21,299 --> 00:50:23,190
you can use them in the dynamic linker

996
00:50:23,190 --> 00:50:27,299
that is like only less than 20 pages

997
00:50:27,299 --> 00:50:31,710
long no lesson sorry I think less than

998
00:50:31,710 --> 00:50:33,539
30 pages long the dynamic link us less

999
00:50:33,539 --> 00:50:37,140
than 30 pages in comparison to like 103

1000
00:50:37,140 --> 00:50:40,490
megabytes of gadgets that you can use

1001
00:50:40,490 --> 00:50:43,529
yeah so the solar code of the iconic

1002
00:50:43,529 --> 00:50:46,410
payload will look like this your first

1003
00:50:46,410 --> 00:50:48,380
create a soccer connected a soccer then

1004
00:50:48,380 --> 00:50:51,000
of course not that simple you have to

1005
00:50:51,000 --> 00:50:53,880
check that the right succeeds and writes

1006
00:50:53,880 --> 00:50:55,859
everything so you write all the image

1007
00:50:55,859 --> 00:51:00,180
information which contains the slide of

1008
00:51:00,180 --> 00:51:04,039
the dynamic case then you send the first

1009
00:51:04,039 --> 00:51:06,779
256 byte of the cage which should be

1010
00:51:06,779 --> 00:51:09,869
enough to identify what cage is actually

1011
00:51:09,869 --> 00:51:13,619
running on the other side then you read

1012
00:51:13,619 --> 00:51:16,140
the size of one of the new payload your

1013
00:51:16,140 --> 00:51:17,700
you read the payload that the know

1014
00:51:17,700 --> 00:51:20,039
location two sets a stack pointer there

1015
00:51:20,039 --> 00:51:25,289
and then you return there actually I

1016
00:51:25,289 --> 00:51:29,880
will after the conference I don't know

1017
00:51:29,880 --> 00:51:32,910
if this week or on on the weekend I will

1018
00:51:32,910 --> 00:51:35,859
release the actual working

1019
00:51:35,859 --> 00:51:39,700
palos that does implement this one for

1020
00:51:39,700 --> 00:51:43,960
all the dynamic linkers so and the last

1021
00:51:43,960 --> 00:51:46,509
thing in my my payload would maybe be a

1022
00:51:46,509 --> 00:51:49,329
shout data when you have like strings or

1023
00:51:49,329 --> 00:51:52,180
so in your and your payload you will

1024
00:51:52,180 --> 00:51:53,920
just put it all on down there in the

1025
00:51:53,920 --> 00:51:56,200
shell data because all the payloads has

1026
00:51:56,200 --> 00:51:58,329
ever just use the same string so you can

1027
00:51:58,329 --> 00:52:00,940
just address it because once you

1028
00:52:00,940 --> 00:52:03,579
executing payload one two three and four

1029
00:52:03,579 --> 00:52:06,190
and five you are in a lone known

1030
00:52:06,190 --> 00:52:08,619
location so you can make the rock

1031
00:52:08,619 --> 00:52:10,779
payload a little bit easier because you

1032
00:52:10,779 --> 00:52:13,599
know where what data elements on on the

1033
00:52:13,599 --> 00:52:17,470
stack exactly and then you can address

1034
00:52:17,470 --> 00:52:19,329
it directly you can change the pyramids

1035
00:52:19,329 --> 00:52:21,099
of the next function call by writing to

1036
00:52:21,099 --> 00:52:22,960
the next parameter because you know

1037
00:52:22,960 --> 00:52:25,420
exactly the address so this is a lot

1038
00:52:25,420 --> 00:52:28,599
easier and so you can always reference

1039
00:52:28,599 --> 00:52:34,539
the shell payload data okay then there's

1040
00:52:34,539 --> 00:52:40,239
one more thing haha what about air is

1041
00:52:40,239 --> 00:52:50,739
long so when it comes to a Islam we will

1042
00:52:50,739 --> 00:52:54,549
just concentrate on one binary we just

1043
00:52:54,549 --> 00:52:57,819
take the latest dynamic linker for the

1044
00:52:57,819 --> 00:53:01,390
three dot five and we again baby arm to

1045
00:53:01,390 --> 00:53:04,059
find all the gadgets which will be the

1046
00:53:04,059 --> 00:53:06,609
same as before but this time we collect

1047
00:53:06,609 --> 00:53:11,739
the gadgets by memory page offset so we

1048
00:53:11,739 --> 00:53:13,869
just take the lowest 12 bits of the

1049
00:53:13,869 --> 00:53:16,119
address and collect them in buckets for

1050
00:53:16,119 --> 00:53:19,660
the lowest 12 bits and so we find

1051
00:53:19,660 --> 00:53:22,890
gadgets that are in the same page offset

1052
00:53:22,890 --> 00:53:27,489
but on different pages you can see it

1053
00:53:27,489 --> 00:53:29,410
found four in this case on the left side

1054
00:53:29,410 --> 00:53:31,539
and four on the right side the

1055
00:53:31,539 --> 00:53:35,019
difference is on the left side basically

1056
00:53:35,019 --> 00:53:37,299
it takes the program counter from three

1057
00:53:37,299 --> 00:53:40,089
different addresses and here it takes it

1058
00:53:40,089 --> 00:53:41,650
from four different so this is a better

1059
00:53:41,650 --> 00:53:44,470
better case and what does this mean now

1060
00:53:44,470 --> 00:53:47,970
we need to jump to two

1061
00:53:47,970 --> 00:53:52,890
page well it's actually you when you

1062
00:53:52,890 --> 00:53:56,010
jump to a gadget inside the dynamic

1063
00:53:56,010 --> 00:53:59,730
linker you have a one in 256 chance to

1064
00:53:59,730 --> 00:54:01,410
actually hit the gadget here that you

1065
00:54:01,410 --> 00:54:06,470
wanted to hit but by returning to this

1066
00:54:06,470 --> 00:54:10,080
Rhett address here in the lower right

1067
00:54:10,080 --> 00:54:13,400
corner when you return to this address

1068
00:54:13,400 --> 00:54:17,670
then because it's at the same page

1069
00:54:17,670 --> 00:54:21,660
offset there are three times i wearin

1070
00:54:21,660 --> 00:54:23,609
total there are four times four times at

1071
00:54:23,609 --> 00:54:25,020
this page address there's a ballad

1072
00:54:25,020 --> 00:54:30,930
gadget so suddenly your chance to hit a

1073
00:54:30,930 --> 00:54:36,240
valid gadget as for in 256 which is one

1074
00:54:36,240 --> 00:54:40,530
in 64 so you have a better chance to

1075
00:54:40,530 --> 00:54:44,460
actually hit the abraded gadget than

1076
00:54:44,460 --> 00:54:50,849
before which is still not a lot but when

1077
00:54:50,849 --> 00:54:54,210
you have like a mass attack and some you

1078
00:54:54,210 --> 00:54:57,630
can attack with the same exploit you can

1079
00:54:57,630 --> 00:55:00,380
suddenly attack four times more people

1080
00:55:00,380 --> 00:55:04,680
that's quite convenient and now the

1081
00:55:04,680 --> 00:55:08,070
actual program counter which one of them

1082
00:55:08,070 --> 00:55:10,830
is used is used to determine the basilar

1083
00:55:10,830 --> 00:55:14,070
slide so in the stable be above you can

1084
00:55:14,070 --> 00:55:17,849
see if the very first program counter

1085
00:55:17,849 --> 00:55:20,220
was taken then obviously the slider

1086
00:55:20,220 --> 00:55:23,730
Thurman inka is 1a and three zeros if

1087
00:55:23,730 --> 00:55:26,220
the second one was technically the slide

1088
00:55:26,220 --> 00:55:29,640
will be 14 and so on and so you know

1089
00:55:29,640 --> 00:55:32,190
exactly the off that your dynamic linker

1090
00:55:32,190 --> 00:55:34,650
was moved and so again you can just like

1091
00:55:34,650 --> 00:55:38,670
calculate for each gadget the moved

1092
00:55:38,670 --> 00:55:40,770
address and then you do the same as

1093
00:55:40,770 --> 00:55:43,230
before but this time you just do it for

1094
00:55:43,230 --> 00:55:48,540
four cases it's better than nothing but

1095
00:55:48,540 --> 00:55:52,650
not what I hoped for maybe by

1096
00:55:52,650 --> 00:55:56,670
implementing more op codes and also some

1097
00:55:56,670 --> 00:55:58,559
op codes that help you to support of a

1098
00:55:58,559 --> 00:56:01,910
whole function call inline function call

1099
00:56:01,910 --> 00:56:07,109
maybe you can get increase the chance so

1100
00:56:07,109 --> 00:56:09,900
when you try the same thing for the

1101
00:56:09,900 --> 00:56:13,079
shared cage which is like 103 megabytes

1102
00:56:13,079 --> 00:56:18,740
of data and only shifted by 17 megabytes

1103
00:56:18,740 --> 00:56:22,319
so you have a moving window of 7 17

1104
00:56:22,319 --> 00:56:24,920
megabytes that you have to check and I

1105
00:56:24,920 --> 00:56:27,869
created these gadgets for the moving

1106
00:56:27,869 --> 00:56:31,069
window and you can see on the left side

1107
00:56:31,069 --> 00:56:33,450
these are a number of getting colors

1108
00:56:33,450 --> 00:56:36,510
collisions it finds you see in the

1109
00:56:36,510 --> 00:56:38,760
beginning it's like a medium good in

1110
00:56:38,760 --> 00:56:41,400
them in the middle there are very few

1111
00:56:41,400 --> 00:56:43,859
gadgets that are colliding and in the

1112
00:56:43,859 --> 00:56:45,119
end it's getting better and better and

1113
00:56:45,119 --> 00:56:48,000
better which is just a position inside

1114
00:56:48,000 --> 00:56:50,450
the fine the file this just random oh

1115
00:56:50,450 --> 00:56:54,480
this is for the iphone 4 so basically

1116
00:56:54,480 --> 00:56:56,579
when you do the same thing for the ipad

1117
00:56:56,579 --> 00:57:00,390
2 it could be different in we'll see it

1118
00:57:00,390 --> 00:57:03,599
look different but the problem is why

1119
00:57:03,599 --> 00:57:06,319
it's 119 which would be very nice like

1120
00:57:06,319 --> 00:57:10,260
4200 by 119 is a far better chance than

1121
00:57:10,260 --> 00:57:12,809
a full dynamic linker but the problem

1122
00:57:12,809 --> 00:57:14,460
here is that when you look at the

1123
00:57:14,460 --> 00:57:16,200
different program counter locations that

1124
00:57:16,200 --> 00:57:20,460
are taken in in the very best cases only

1125
00:57:20,460 --> 00:57:25,079
30 of these 119 are different program

1126
00:57:25,079 --> 00:57:27,530
counters

1127
00:57:32,080 --> 00:57:36,040
so to just swipe the first gadget the

1128
00:57:36,040 --> 00:57:40,320
chance two point eight percent but

1129
00:57:40,320 --> 00:57:42,490
because you only have like certain

1130
00:57:42,490 --> 00:57:44,710
different program counter locations but

1131
00:57:44,710 --> 00:57:47,590
119 different collisions you have many

1132
00:57:47,590 --> 00:57:51,760
gadgets clusters you have to distinguish

1133
00:57:51,760 --> 00:57:55,330
between so your extra shell code will be

1134
00:57:55,330 --> 00:57:57,130
longer and longer and longer and longer

1135
00:57:57,130 --> 00:57:59,680
and doing creating this by hand will be

1136
00:57:59,680 --> 00:58:06,040
like completely stupid and and in the

1137
00:58:06,040 --> 00:58:09,400
end when you look at the numbers the

1138
00:58:09,400 --> 00:58:11,470
work you put in there to construct this

1139
00:58:11,470 --> 00:58:16,150
payload will not be worth it because the

1140
00:58:16,150 --> 00:58:18,220
odds that you get are still not that

1141
00:58:18,220 --> 00:58:21,940
good that it's like yeah it's a good

1142
00:58:21,940 --> 00:58:29,230
idea to it was so much work okay so the

1143
00:58:29,230 --> 00:58:31,870
conclusion of all this is we have proof

1144
00:58:31,870 --> 00:58:34,900
that multi environment gadgets are can

1145
00:58:34,900 --> 00:58:38,110
improve our odds in the non eighth of

1146
00:58:38,110 --> 00:58:40,690
our case we can create one rope halo

1147
00:58:40,690 --> 00:58:43,630
that can own everything above photo to

1148
00:58:43,630 --> 00:58:49,180
that one no matter what device and we

1149
00:58:49,180 --> 00:58:52,330
can also do that for the the other

1150
00:58:52,330 --> 00:58:54,310
linkers we can have one raw pelo that

1151
00:58:54,310 --> 00:58:58,780
does it for 40 two photos a one I didn't

1152
00:58:58,780 --> 00:59:02,950
show that but it's the same thing and we

1153
00:59:02,950 --> 00:59:04,750
also can see that for the ace of our

1154
00:59:04,750 --> 00:59:07,540
case we can improve our odds about the

1155
00:59:07,540 --> 00:59:12,370
odds are still low and doing this kind

1156
00:59:12,370 --> 00:59:14,140
of attack for the dynamic shared cache

1157
00:59:14,140 --> 00:59:18,180
del sharecash is not really a worthwhile

1158
00:59:18,180 --> 00:59:20,740
the disclaimer however he is that all

1159
00:59:20,740 --> 00:59:23,200
the numbers are generated with a current

1160
00:59:23,200 --> 00:59:25,870
version of this baby arm which is just

1161
00:59:25,870 --> 00:59:27,850
very limited subset of the instruction

1162
00:59:27,850 --> 00:59:30,340
set so maybe if i add more instructions

1163
00:59:30,340 --> 00:59:34,420
i can get better results but i don't

1164
00:59:34,420 --> 00:59:38,620
expect it to be so much better yeah

1165
00:59:38,620 --> 00:59:41,750
there was it any questions

1166
00:59:41,750 --> 00:59:45,270
no questions yeah okay well thank you

1167
00:59:45,270 --> 00:59:47,960
very much sir

