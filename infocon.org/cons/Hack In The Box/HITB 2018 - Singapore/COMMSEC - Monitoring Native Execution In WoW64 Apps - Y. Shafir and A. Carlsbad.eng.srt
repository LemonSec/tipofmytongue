1
00:00:10,320 --> 00:00:17,279
hi<font color="#E5E5E5"> we're</font><font color="#CCCCCC"> seven</font><font color="#E5E5E5"> both working until one</font>

2
00:00:14,580 --> 00:00:19,500
we're here to talk about a project we

3
00:00:17,279 --> 00:00:22,740
<font color="#CCCCCC">did recently whose purpose is to monitor</font>

4
00:00:19,500 --> 00:00:24,840
<font color="#E5E5E5">the native 64-bit execution inside of of</font>

5
00:00:22,740 --> 00:00:27,320
<font color="#E5E5E5">64 applications which are basically</font>

6
00:00:24,840 --> 00:00:30,599
32-bit applications running inside<font color="#E5E5E5"> of</font>

7
00:00:27,320 --> 00:00:32,549
<font color="#E5E5E5">64-bit</font><font color="#CCCCCC"> operating system so we'll start</font>

8
00:00:30,599 --> 00:00:33,720
<font color="#CCCCCC">with our personal embarrassing</font>

9
00:00:32,549 --> 00:00:36,780
introductions

10
00:00:33,720 --> 00:00:39,989
I'm<font color="#E5E5E5"> your then I'm a dancer gymnast</font><font color="#CCCCCC"> and</font>

11
00:00:36,780 --> 00:00:41,940
<font color="#CCCCCC">Acrobat I started dancing</font><font color="#E5E5E5"> and competing</font>

12
00:00:39,989 --> 00:00:44,820
in rhythmic<font color="#CCCCCC"> gymnastics as a</font><font color="#E5E5E5"> kid and</font>

13
00:00:41,940 --> 00:00:46,860
continue doing<font color="#E5E5E5"> so for many years in the</font>

14
00:00:44,820 --> 00:00:51,240
<font color="#CCCCCC">past few years I've become</font><font color="#E5E5E5"> a circus</font>

15
00:00:46,860 --> 00:00:52,890
acrobat<font color="#CCCCCC"> in a realist</font><font color="#E5E5E5"> and on my spare</font>

16
00:00:51,240 --> 00:00:54,750
time I'm a security<font color="#CCCCCC"> researcher at</font>

17
00:00:52,890 --> 00:00:56,520
<font color="#CCCCCC">Cynthia luan where I did this project</font>

18
00:00:54,750 --> 00:00:59,519
together with<font color="#CCCCCC"> herself and</font><font color="#E5E5E5"> I'll let him</font>

19
00:00:56,520 --> 00:01:01,590
<font color="#E5E5E5">introduce himself so hi everyone</font>

20
00:00:59,520 --> 00:01:05,270
I'm a<font color="#CCCCCC"> stuff</font><font color="#E5E5E5"> and like she said it I'm</font>

21
00:01:01,590 --> 00:01:05,270
security lesotho<font color="#E5E5E5"> something I want</font>

22
00:01:05,479 --> 00:01:09,720
so before we<font color="#CCCCCC"> start talking about the</font>

23
00:01:07,979 --> 00:01:12,720
project<font color="#E5E5E5"> and let's have a bit of</font>

24
00:01:09,720 --> 00:01:14,789
<font color="#E5E5E5">background information</font><font color="#CCCCCC"> and a visa and</font>

25
00:01:12,720 --> 00:01:16,500
security products<font color="#CCCCCC"> in general</font><font color="#E5E5E5"> want to</font>

26
00:01:14,790 --> 00:01:19,020
monitor everything<font color="#E5E5E5"> is going on in the</font>

27
00:01:16,500 --> 00:01:21,240
system<font color="#E5E5E5"> and specifically inside of each</font>

28
00:01:19,020 --> 00:01:23,580
and every<font color="#CCCCCC"> process our common way to do</font>

29
00:01:21,240 --> 00:01:26,610
that is by using<font color="#CCCCCC"> user mode hooks</font><font color="#E5E5E5"> placed</font>

30
00:01:23,580 --> 00:01:29,039
on interesting API functions such as

31
00:01:26,610 --> 00:01:32,600
those<font color="#CCCCCC"> that deal with memory management</font>

32
00:01:29,040 --> 00:01:37,110
or inter-process communications these

33
00:01:32,600 --> 00:01:39,990
hooks<font color="#CCCCCC"> allowed them to to see every call</font>

34
00:01:37,110 --> 00:01:41,070
<font color="#CCCCCC">to such functions and monitor what's</font>

35
00:01:39,990 --> 00:01:43,710
<font color="#CCCCCC">happening inside</font><font color="#E5E5E5"> of all of these</font>

36
00:01:41,070 --> 00:01:45,720
processes<font color="#CCCCCC"> a major disadvantage</font><font color="#E5E5E5"> of these</font>

37
00:01:43,710 --> 00:01:48,419
<font color="#E5E5E5">hooks is that he can be quite easily</font>

38
00:01:45,720 --> 00:01:50,490
bypassed by various<font color="#CCCCCC"> different bypass</font>

39
00:01:48,420 --> 00:01:52,650
techniques<font color="#CCCCCC"> I won't talk about most of</font>

40
00:01:50,490 --> 00:01:54,750
these there<font color="#E5E5E5"> are about a billion I will</font>

41
00:01:52,650 --> 00:01:58,650
focus on a specific<font color="#E5E5E5"> family of</font><font color="#CCCCCC"> bypasses</font>

42
00:01:54,750 --> 00:02:00,810
<font color="#CCCCCC">the target the 1/64 mechanism a couple</font>

43
00:01:58,650 --> 00:02:03,060
of words<font color="#CCCCCC"> about this</font><font color="#E5E5E5"> mechanism when</font>

44
00:02:00,810 --> 00:02:05,060
Microsoft<font color="#E5E5E5"> started developing the 64-bit</font>

45
00:02:03,060 --> 00:02:08,039
operating system they faced a problem

46
00:02:05,060 --> 00:02:10,769
<font color="#E5E5E5">existing 32-bit applications can't</font>

47
00:02:08,038 --> 00:02:13,439
natively run<font color="#E5E5E5"> on 64-bit environments and</font>

48
00:02:10,769 --> 00:02:14,519
would generally play<font color="#E5E5E5"> great Microsoft</font>

49
00:02:13,439 --> 00:02:16,290
didn't<font color="#CCCCCC"> want to break off the</font>

50
00:02:14,519 --> 00:02:19,260
applications<font color="#CCCCCC"> so they had to find</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> way</font>

51
00:02:16,290 --> 00:02:21,450
to allow them to still run the solution

52
00:02:19,260 --> 00:02:24,209
they came up<font color="#CCCCCC"> with is called while 64</font><font color="#E5E5E5"> an</font>

53
00:02:21,450 --> 00:02:26,540
acronym<font color="#CCCCCC"> for</font><font color="#E5E5E5"> Windows on</font><font color="#CCCCCC"> windows 64 it</font>

54
00:02:24,210 --> 00:02:29,490
<font color="#CCCCCC">the subsystem</font><font color="#E5E5E5"> basically made up of a few</font>

55
00:02:26,540 --> 00:02:32,489
<font color="#E5E5E5">64-bit DLL is loaded into every 32-bit</font>

56
00:02:29,490 --> 00:02:35,310
process which allow the 32-bit

57
00:02:32,490 --> 00:02:37,020
application to run<font color="#E5E5E5"> on top of</font><font color="#CCCCCC"> a 64-bit</font>

58
00:02:35,310 --> 00:02:39,570
environment is if they<font color="#CCCCCC"> run inside of a</font>

59
00:02:37,020 --> 00:02:41,460
32-bit environment<font color="#E5E5E5"> there are</font><font color="#CCCCCC"> lots of</font>

60
00:02:39,570 --> 00:02:44,250
different<font color="#CCCCCC"> implications for the</font><font color="#E5E5E5"> subsystem</font>

61
00:02:41,460 --> 00:02:46,170
for<font color="#CCCCCC"> example</font><font color="#E5E5E5"> file system and registry</font>

62
00:02:44,250 --> 00:02:47,580
direction<font color="#E5E5E5"> which aren't really relevant</font>

63
00:02:46,170 --> 00:02:49,950
<font color="#E5E5E5">for this</font><font color="#CCCCCC"> project</font><font color="#E5E5E5"> so I won't talk</font><font color="#CCCCCC"> about</font>

64
00:02:47,580 --> 00:02:52,740
<font color="#E5E5E5">them another implication which is</font>

65
00:02:49,950 --> 00:02:55,560
relevant<font color="#CCCCCC"> for this project has to do with</font>

66
00:02:52,740 --> 00:02:57,600
system call handling basically whenever

67
00:02:55,560 --> 00:02:59,190
<font color="#E5E5E5">an application wants to ask something</font>

68
00:02:57,600 --> 00:03:01,440
<font color="#CCCCCC">from the O's kernel they do that through</font>

69
00:02:59,190 --> 00:03:03,420
<font color="#E5E5E5">a</font><font color="#CCCCCC"> mechanism called</font><font color="#E5E5E5"> a system call most of</font>

70
00:03:01,440 --> 00:03:06,090
<font color="#CCCCCC">the system calls are dispatched through</font>

71
00:03:03,420 --> 00:03:08,399
<font color="#CCCCCC">our</font><font color="#E5E5E5"> dedicated system DLL loaded into</font>

72
00:03:06,090 --> 00:03:11,040
<font color="#E5E5E5">every</font><font color="#CCCCCC"> windows process called ntdll</font>

73
00:03:08,400 --> 00:03:13,260
<font color="#CCCCCC">while 64 processors have two</font><font color="#E5E5E5"> versions of</font>

74
00:03:11,040 --> 00:03:16,829
this DLL a 32-bit version and a 64-bit

75
00:03:13,260 --> 00:03:19,500
one and this<font color="#E5E5E5"> is</font><font color="#CCCCCC"> a simplified view of</font>

76
00:03:16,830 --> 00:03:22,710
what this looks<font color="#E5E5E5"> like on</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> Left we have</font>

77
00:03:19,500 --> 00:03:25,380
<font color="#CCCCCC">the 32-bit api function either 32-bit</font>

78
00:03:22,710 --> 00:03:27,000
ntdll<font color="#CCCCCC"> as you might see doesn't</font><font color="#E5E5E5"> really do</font>

79
00:03:25,380 --> 00:03:29,640
much it basically just forwards the

80
00:03:27,000 --> 00:03:32,220
request<font color="#E5E5E5"> to</font><font color="#CCCCCC"> vo of</font><font color="#E5E5E5"> 64 layer which handles</font>

81
00:03:29,640 --> 00:03:34,410
it the<font color="#CCCCCC"> all 64 layer first</font><font color="#E5E5E5"> has to</font><font color="#CCCCCC"> make</font>

82
00:03:32,220 --> 00:03:37,200
the transition<font color="#E5E5E5"> from 32-bit to 64-bit</font>

83
00:03:34,410 --> 00:03:38,609
mode and does that through the jump

84
00:03:37,200 --> 00:03:41,549
instruction<font color="#E5E5E5"> we see there in the middle</font>

85
00:03:38,610 --> 00:03:44,460
<font color="#E5E5E5">this is a rather</font><font color="#CCCCCC"> unique instruction it's</font>

86
00:03:41,550 --> 00:03:46,740
a<font color="#E5E5E5"> four jump to code segment 33 this</font>

87
00:03:44,460 --> 00:03:48,660
instruction forces the processor on<font color="#CCCCCC"> the</font>

88
00:03:46,740 --> 00:03:50,820
hardware<font color="#E5E5E5"> level to switch from 32-bit</font>

89
00:03:48,660 --> 00:03:54,630
execution mode to 64-bit execution mode

90
00:03:50,820 --> 00:03:56,459
<font color="#CCCCCC">once we in 64-bit mode</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> wall 64 layer</font>

91
00:03:54,630 --> 00:03:58,260
has to<font color="#CCCCCC"> make a few more</font><font color="#E5E5E5"> adjustments to</font>

92
00:03:56,460 --> 00:04:00,510
your quest<font color="#CCCCCC"> such as pointer size</font>

93
00:03:58,260 --> 00:04:02,940
expansion from 32 bits to 64 bits

94
00:04:00,510 --> 00:04:04,920
<font color="#E5E5E5">calling convention adjustments and click</font>

95
00:04:02,940 --> 00:04:07,740
on convention is different on<font color="#E5E5E5"> 64-bit</font>

96
00:04:04,920 --> 00:04:10,320
mode and a couple<font color="#E5E5E5"> more stuff once it's</font>

97
00:04:07,740 --> 00:04:12,120
done if a request is ready<font color="#E5E5E5"> it forwards</font>

98
00:04:10,320 --> 00:04:14,340
it to<font color="#CCCCCC"> a function with the same name in</font>

99
00:04:12,120 --> 00:04:16,890
<font color="#CCCCCC">the second 64 bit ntdll</font>

100
00:04:14,340 --> 00:04:20,370
<font color="#E5E5E5">which dispatches the system call through</font>

101
00:04:16,890 --> 00:04:21,959
<font color="#CCCCCC">the</font><font color="#E5E5E5"> dedicated</font><font color="#CCCCCC"> cpu instruction now let's</font>

102
00:04:20,370 --> 00:04:24,360
go back to<font color="#CCCCCC"> a bypass</font><font color="#E5E5E5"> I mentioned earlier</font>

103
00:04:21,959 --> 00:04:26,760
there<font color="#CCCCCC"> is a whole family of bypasses they</font>

104
00:04:24,360 --> 00:04:29,370
target the<font color="#CCCCCC"> e.164</font><font color="#E5E5E5"> mechanism all working</font>

105
00:04:26,760 --> 00:04:31,950
pretty similar ways<font color="#E5E5E5"> the most well-known</font>

106
00:04:29,370 --> 00:04:34,020
and<font color="#CCCCCC"> most</font><font color="#E5E5E5"> commonly used one is</font><font color="#CCCCCC"> called</font>

107
00:04:31,950 --> 00:04:36,380
<font color="#E5E5E5">heaven's gate it was first published</font>

108
00:04:34,020 --> 00:04:39,620
<font color="#E5E5E5">about ten</font><font color="#CCCCCC"> years ago</font><font color="#E5E5E5"> and</font>

109
00:04:36,380 --> 00:04:41,330
then was seen in the world<font color="#CCCCCC"> in lots of</font>

110
00:04:39,620 --> 00:04:43,610
<font color="#CCCCCC">different types of malware</font><font color="#E5E5E5"> as a bypass</font>

111
00:04:41,330 --> 00:04:47,510
technique<font color="#E5E5E5"> how does it work this</font>

112
00:04:43,610 --> 00:04:50,540
technique makes the<font color="#E5E5E5"> system call by</font>

113
00:04:47,510 --> 00:04:53,500
calling<font color="#CCCCCC"> directly to the 64-bit</font><font color="#E5E5E5"> API</font>

114
00:04:50,540 --> 00:04:57,080
function<font color="#E5E5E5"> without going through the whole</font>

115
00:04:53,500 --> 00:04:59,270
<font color="#CCCCCC">process we saw here it does that by</font>

116
00:04:57,080 --> 00:05:01,010
using<font color="#E5E5E5"> the</font><font color="#CCCCCC"> for jump or a similar</font>

117
00:04:59,270 --> 00:05:03,799
instruction to transition itself<font color="#CCCCCC"> from</font>

118
00:05:01,010 --> 00:05:05,270
32-bit to 64-bit mode making<font color="#CCCCCC"> of the</font>

119
00:05:03,800 --> 00:05:08,150
required adjustments<font color="#CCCCCC"> and calling the</font>

120
00:05:05,270 --> 00:05:10,219
64-bit<font color="#E5E5E5"> API function the reason this is a</font>

121
00:05:08,150 --> 00:05:12,469
bypass technique is because<font color="#E5E5E5"> user mode</font>

122
00:05:10,220 --> 00:05:15,530
hooks<font color="#CCCCCC"> placed by security product or an</font>

123
00:05:12,470 --> 00:05:18,320
oil placed on the<font color="#CCCCCC"> 32 bit</font><font color="#E5E5E5"> API functions</font>

124
00:05:15,530 --> 00:05:20,989
as well 64<font color="#CCCCCC"> processors are basically just</font>

125
00:05:18,320 --> 00:05:23,900
regular<font color="#E5E5E5"> 32-bit processes it's much</font>

126
00:05:20,990 --> 00:05:26,120
<font color="#E5E5E5">easier</font><font color="#CCCCCC"> to hook 32-bit code</font><font color="#E5E5E5"> and normally</font>

127
00:05:23,900 --> 00:05:28,280
there's no need to<font color="#E5E5E5"> hook the 64-bit code</font>

128
00:05:26,120 --> 00:05:31,730
because any interesting call will first

129
00:05:28,280 --> 00:05:33,710
go through<font color="#CCCCCC"> the 32-bit</font><font color="#E5E5E5"> API functions</font><font color="#CCCCCC"> yeah</font>

130
00:05:31,730 --> 00:05:35,930
<font color="#E5E5E5">that is unless it was done using</font>

131
00:05:33,710 --> 00:05:38,390
<font color="#E5E5E5">Heaven's Gate or similar bypass</font>

132
00:05:35,930 --> 00:05:40,640
technique in<font color="#CCCCCC"> which case the security</font>

133
00:05:38,390 --> 00:05:43,250
product has a sort of<font color="#E5E5E5"> a blind</font><font color="#CCCCCC"> spot and</font>

134
00:05:40,640 --> 00:05:45,620
<font color="#E5E5E5">will miss any</font><font color="#CCCCCC"> call does done</font><font color="#E5E5E5"> using such</font>

135
00:05:43,250 --> 00:05:47,990
techniques we want to address<font color="#E5E5E5"> this</font>

136
00:05:45,620 --> 00:05:50,870
problem<font color="#CCCCCC"> by hooking</font><font color="#E5E5E5"> these</font><font color="#CCCCCC"> 64-bit api</font>

137
00:05:47,990 --> 00:05:53,450
functions<font color="#CCCCCC"> directly this sounds easy just</font>

138
00:05:50,870 --> 00:05:55,580
do the same<font color="#E5E5E5"> thing but actually it was</font>

139
00:05:53,450 --> 00:05:59,210
<font color="#E5E5E5">diseases we thought first we had to</font>

140
00:05:55,580 --> 00:06:01,700
<font color="#E5E5E5">inject 64-bit code into the effectively</font>

141
00:05:59,210 --> 00:06:03,739
<font color="#E5E5E5">32-bit process for that we need an</font>

142
00:06:01,700 --> 00:06:05,450
adjusting an injection technique capable

143
00:06:03,740 --> 00:06:07,820
of doing<font color="#E5E5E5"> that</font><font color="#CCCCCC"> so we'll see a couple of</font>

144
00:06:05,450 --> 00:06:10,670
<font color="#E5E5E5">this then we</font><font color="#CCCCCC"> can't just inject</font><font color="#E5E5E5"> any</font>

145
00:06:07,820 --> 00:06:12,770
64-bit code as it<font color="#CCCCCC"> faces a few</font>

146
00:06:10,670 --> 00:06:15,470
limitations when<font color="#CCCCCC"> running</font><font color="#E5E5E5"> inside of</font><font color="#CCCCCC"> our</font>

147
00:06:12,770 --> 00:06:17,390
64 process<font color="#E5E5E5"> and finally</font><font color="#CCCCCC"> we actually need</font>

148
00:06:15,470 --> 00:06:18,350
a<font color="#E5E5E5"> hook in</font><font color="#CCCCCC"> engine capable</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> working in</font>

149
00:06:17,390 --> 00:06:21,320
such an<font color="#E5E5E5"> environment</font>

150
00:06:18,350 --> 00:06:24,080
so we'll modify<font color="#E5E5E5"> an existing one to allow</font>

151
00:06:21,320 --> 00:06:26,540
it to<font color="#CCCCCC"> run under such conditions oh</font><font color="#E5E5E5"> that</font>

152
00:06:24,080 --> 00:06:32,240
was<font color="#E5E5E5"> the introduction let's start with</font>

153
00:06:26,540 --> 00:06:34,700
the injection<font color="#CCCCCC"> ok</font><font color="#E5E5E5"> so just</font><font color="#CCCCCC"> like he'll</font><font color="#E5E5E5"> then</font>

154
00:06:32,240 --> 00:06:36,860
said the first task<font color="#CCCCCC"> must accomplish</font><font color="#E5E5E5"> is</font>

155
00:06:34,700 --> 00:06:38,420
<font color="#CCCCCC">to find a suitable injection method</font>

156
00:06:36,860 --> 00:06:41,120
which<font color="#E5E5E5"> will allow us</font><font color="#CCCCCC"> to run</font><font color="#E5E5E5"> our own</font>

157
00:06:38,420 --> 00:06:44,740
64-bit code<font color="#E5E5E5"> in the context of the target</font>

158
00:06:41,120 --> 00:06:46,580
while 64<font color="#E5E5E5"> process so generally speaking</font>

159
00:06:44,740 --> 00:06:48,320
<font color="#E5E5E5">there are lots of very different</font>

160
00:06:46,580 --> 00:06:49,620
<font color="#E5E5E5">injection methods which are available at</font>

161
00:06:48,320 --> 00:06:52,050
our disposal

162
00:06:49,620 --> 00:06:54,300
unfortunately most<font color="#E5E5E5"> of them aren't very</font>

163
00:06:52,050 --> 00:06:56,430
<font color="#CCCCCC">beneficial to</font><font color="#E5E5E5"> us and the reason for that</font>

164
00:06:54,300 --> 00:06:58,050
is<font color="#CCCCCC"> that most injection techniques would</font>

165
00:06:56,430 --> 00:06:59,580
only allow<font color="#E5E5E5"> us to inject</font><font color="#CCCCCC"> the air</font><font color="#E5E5E5"> which</font>

166
00:06:58,050 --> 00:07:03,150
has<font color="#CCCCCC"> the same business as the target</font>

167
00:06:59,580 --> 00:07:06,030
<font color="#CCCCCC">process so that means I don't injecting</font>

168
00:07:03,150 --> 00:07:08,219
a 64-bit<font color="#E5E5E5"> DLL into</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> 64-bit process over</font>

169
00:07:06,030 --> 00:07:09,900
<font color="#E5E5E5">32-bit DLL into</font><font color="#CCCCCC"> a 32-bit process and</font>

170
00:07:08,220 --> 00:07:11,670
what<font color="#E5E5E5"> we needed in the course of this</font>

171
00:07:09,900 --> 00:07:13,320
<font color="#E5E5E5">project is something a little bit more</font>

172
00:07:11,670 --> 00:07:16,650
unique<font color="#CCCCCC"> we actually needed</font><font color="#E5E5E5"> the ability</font><font color="#CCCCCC"> to</font>

173
00:07:13,320 --> 00:07:18,990
inject<font color="#E5E5E5"> a</font><font color="#CCCCCC"> 64-bit DLL into a</font><font color="#E5E5E5"> well 64</font>

174
00:07:16,650 --> 00:07:21,210
process which just like<font color="#E5E5E5"> we have said</font>

175
00:07:18,990 --> 00:07:23,010
it's effectively<font color="#E5E5E5"> a 32-bit</font><font color="#CCCCCC"> processor so</font>

176
00:07:21,210 --> 00:07:26,700
not any injection method<font color="#E5E5E5"> is capable of</font>

177
00:07:23,010 --> 00:07:29,070
<font color="#E5E5E5">doing it okay so in the course of this</font>

178
00:07:26,700 --> 00:07:30,599
talk we're<font color="#E5E5E5"> going to describe three</font>

179
00:07:29,070 --> 00:07:32,760
relatively<font color="#E5E5E5"> known methods which are</font>

180
00:07:30,600 --> 00:07:35,070
capable of injecting<font color="#E5E5E5"> 64 bit barrels into</font>

181
00:07:32,760 --> 00:07:36,840
<font color="#CCCCCC">32-bit processes and we will start with</font>

182
00:07:35,070 --> 00:07:38,400
the relatively<font color="#E5E5E5"> easy stuff and gradually</font>

183
00:07:36,840 --> 00:07:41,010
walk all the way<font color="#E5E5E5"> through to more</font>

184
00:07:38,400 --> 00:07:42,900
complicated techniques we<font color="#CCCCCC"> will conclude</font>

185
00:07:41,010 --> 00:07:46,140
this phase by talking<font color="#E5E5E5"> about an injection</font>

186
00:07:42,900 --> 00:07:47,640
method<font color="#E5E5E5"> called injection via a PC and we</font>

187
00:07:46,140 --> 00:07:49,620
will see that<font color="#E5E5E5"> while this specific</font>

188
00:07:47,640 --> 00:07:51,240
technique works great on some of the

189
00:07:49,620 --> 00:07:53,430
older<font color="#CCCCCC"> Windows platform for example</font>

190
00:07:51,240 --> 00:07:54,720
<font color="#E5E5E5">windows 7 it would</font><font color="#CCCCCC"> probably break when</font>

191
00:07:53,430 --> 00:07:57,510
you<font color="#E5E5E5"> try to run it on more modern</font>

192
00:07:54,720 --> 00:07:59,490
platforms such as Windows 10<font color="#E5E5E5"> so after we</font>

193
00:07:57,510 --> 00:08:01,710
will dig in a little<font color="#CCCCCC"> bit into the root</font>

194
00:07:59,490 --> 00:08:03,540
cause of<font color="#E5E5E5"> this failure and analyze it we</font>

195
00:08:01,710 --> 00:08:05,400
will be<font color="#E5E5E5"> able to</font><font color="#CCCCCC"> present</font><font color="#E5E5E5"> two new</font>

196
00:08:03,540 --> 00:08:07,200
variations developed by us during the

197
00:08:05,400 --> 00:08:09,239
<font color="#E5E5E5">course of this research which basically</font>

198
00:08:07,200 --> 00:08:10,920
allows this specific injection technique

199
00:08:09,240 --> 00:08:13,410
to<font color="#E5E5E5"> work perfectly even on the latest</font>

200
00:08:10,920 --> 00:08:16,620
<font color="#E5E5E5">release of Windows 10 for example so</font>

201
00:08:13,410 --> 00:08:18,900
this<font color="#E5E5E5"> is our agenda so let's start with</font>

202
00:08:16,620 --> 00:08:20,820
the easy stuff<font color="#CCCCCC"> so the first technique</font>

203
00:08:18,900 --> 00:08:22,320
I'm<font color="#CCCCCC"> going</font><font color="#E5E5E5"> to describe was actually</font>

204
00:08:20,820 --> 00:08:24,810
<font color="#E5E5E5">discovered several years ago</font><font color="#CCCCCC"> by a</font>

205
00:08:22,320 --> 00:08:26,490
security<font color="#CCCCCC"> researcher named</font><font color="#E5E5E5"> Wally</font><font color="#CCCCCC"> darsow</font>

206
00:08:24,810 --> 00:08:28,800
<font color="#CCCCCC">and it basically revolves around</font>

207
00:08:26,490 --> 00:08:32,940
hijacking of a<font color="#CCCCCC"> dll named</font><font color="#E5E5E5"> while 64</font><font color="#CCCCCC"> log</font>

208
00:08:28,800 --> 00:08:35,010
<font color="#E5E5E5">DLL so what is this dealer anyway</font><font color="#CCCCCC"> and so</font>

209
00:08:32,940 --> 00:08:36,750
whenever I<font color="#E5E5E5"> launch</font><font color="#CCCCCC"> a new wall 64 process</font>

210
00:08:35,010 --> 00:08:38,760
in the system an integral part of its

211
00:08:36,750 --> 00:08:41,789
<font color="#E5E5E5">initialization phase is going to look up</font>

212
00:08:38,760 --> 00:08:44,150
and<font color="#CCCCCC"> load a</font><font color="#E5E5E5"> 64 bit DLL named of 64 log</font>

213
00:08:41,789 --> 00:08:46,589
directly from the system<font color="#CCCCCC"> 32 directory</font>

214
00:08:44,150 --> 00:08:48,209
<font color="#E5E5E5">now this Darrell is</font><font color="#CCCCCC"> not shipped by</font>

215
00:08:46,590 --> 00:08:50,520
default as part of the<font color="#CCCCCC"> standard wisdom</font>

216
00:08:48,210 --> 00:08:52,080
<font color="#E5E5E5">Windows installation which makes us and</font>

217
00:08:50,520 --> 00:08:53,970
<font color="#E5E5E5">many other security researchers in their</font>

218
00:08:52,080 --> 00:08:55,590
community<font color="#E5E5E5"> believe that this</font><font color="#CCCCCC"> dll is</font>

219
00:08:53,970 --> 00:08:57,810
actually only<font color="#E5E5E5"> used internally</font><font color="#CCCCCC"> by</font>

220
00:08:55,590 --> 00:09:00,720
Microsoft<font color="#E5E5E5"> in order to aid debugging or</font>

221
00:08:57,810 --> 00:09:01,760
Diagnostics of 1264 applications and in

222
00:09:00,720 --> 00:09:04,130
fact we can<font color="#E5E5E5"> level</font>

223
00:09:01,760 --> 00:09:05,990
the fact that<font color="#E5E5E5"> this</font><font color="#CCCCCC"> dll is</font><font color="#E5E5E5"> not</font><font color="#CCCCCC"> chipped by</font>

224
00:09:04,130 --> 00:09:08,210
default<font color="#E5E5E5"> in order</font><font color="#CCCCCC"> to gain code injection</font>

225
00:09:05,990 --> 00:09:11,090
<font color="#CCCCCC">and the way we do this is by simply</font>

226
00:09:08,210 --> 00:09:13,340
creating<font color="#E5E5E5"> our DLL renaming get 2 of 64</font>

227
00:09:11,090 --> 00:09:14,930
log making it export a specific

228
00:09:13,340 --> 00:09:17,180
well-defined set of functions and<font color="#E5E5E5"> then</font>

229
00:09:14,930 --> 00:09:19,790
just drop it to<font color="#CCCCCC"> the</font><font color="#E5E5E5"> system</font><font color="#CCCCCC"> 32</font><font color="#E5E5E5"> directory</font>

230
00:09:17,180 --> 00:09:21,709
<font color="#E5E5E5">and once we have done so well</font><font color="#CCCCCC"> DLL will</font>

231
00:09:19,790 --> 00:09:24,079
be like magically loaded<font color="#E5E5E5"> into every new</font>

232
00:09:21,710 --> 00:09:25,190
of 64 process in the system<font color="#E5E5E5"> and thus</font>

233
00:09:24,080 --> 00:09:26,240
we've gained our code injection

234
00:09:25,190 --> 00:09:29,000
capabilities

235
00:09:26,240 --> 00:09:32,680
so the<font color="#E5E5E5"> Samara</font><font color="#CCCCCC"> is really easy and</font>

236
00:09:29,000 --> 00:09:35,150
straightforward<font color="#E5E5E5"> DLL hijacking technique</font>

237
00:09:32,680 --> 00:09:37,160
<font color="#CCCCCC">ok the second</font><font color="#E5E5E5"> technique we're going to</font>

238
00:09:35,150 --> 00:09:39,620
describe<font color="#E5E5E5"> actually takes advantage of</font>

239
00:09:37,160 --> 00:09:41,240
<font color="#CCCCCC">Heaven's Gate so if</font><font color="#E5E5E5"> you'll</font><font color="#CCCCCC"> recall not</font>

240
00:09:39,620 --> 00:09:43,100
<font color="#E5E5E5">long</font><font color="#CCCCCC"> ago</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> we all then talked</font><font color="#E5E5E5"> about</font>

241
00:09:41,240 --> 00:09:46,370
Heaven's Gate<font color="#CCCCCC"> and basically</font><font color="#E5E5E5"> described it</font>

242
00:09:43,100 --> 00:09:48,470
as some sort<font color="#CCCCCC"> of a hook by this</font><font color="#E5E5E5"> technique</font>

243
00:09:46,370 --> 00:09:50,960
which is<font color="#E5E5E5"> used mostly by malicious actors</font>

244
00:09:48,470 --> 00:09:53,120
in<font color="#E5E5E5"> order to bite us</font><font color="#CCCCCC"> hooks inserted by</font>

245
00:09:50,960 --> 00:09:54,590
various security<font color="#CCCCCC"> products</font><font color="#E5E5E5"> but the</font>

246
00:09:53,120 --> 00:09:57,050
reality is sometimes<font color="#E5E5E5"> a</font><font color="#CCCCCC"> little bit</font><font color="#E5E5E5"> more</font>

247
00:09:54,590 --> 00:09:59,120
<font color="#E5E5E5">complex than that and there is usually</font>

248
00:09:57,050 --> 00:10:01,880
like a very fine line which separates

249
00:09:59,120 --> 00:10:03,320
<font color="#E5E5E5">Marvel from security</font><font color="#CCCCCC"> products and I</font>

250
00:10:01,880 --> 00:10:04,760
think this is one of<font color="#E5E5E5"> the cases in which</font>

251
00:10:03,320 --> 00:10:06,470
the very same technique can<font color="#CCCCCC"> be</font>

252
00:10:04,760 --> 00:10:08,720
beneficial<font color="#E5E5E5"> for the attacker as well so</font>

253
00:10:06,470 --> 00:10:10,790
the defender so<font color="#CCCCCC"> with that in mind let's</font>

254
00:10:08,720 --> 00:10:13,850
see how an<font color="#CCCCCC"> AV</font><font color="#E5E5E5"> for example might benefit</font>

255
00:10:10,790 --> 00:10:16,550
from Heaven's Gate so what we must

256
00:10:13,850 --> 00:10:19,190
understand is that<font color="#E5E5E5"> every</font><font color="#CCCCCC"> one</font><font color="#E5E5E5"> 64 process</font>

257
00:10:16,550 --> 00:10:20,990
has in it<font color="#CCCCCC"> two distinct image low-dose</font><font color="#E5E5E5"> 1</font>

258
00:10:19,190 --> 00:10:22,420
implemented in the<font color="#CCCCCC"> 32-bit</font><font color="#E5E5E5"> until the</font>

259
00:10:20,990 --> 00:10:25,220
other which can<font color="#E5E5E5"> only load additional</font>

260
00:10:22,420 --> 00:10:27,050
<font color="#E5E5E5">32-bit images and</font><font color="#CCCCCC"> one implemented in the</font>

261
00:10:25,220 --> 00:10:30,260
64-bit anti dealer which can only load

262
00:10:27,050 --> 00:10:32,750
additional<font color="#E5E5E5"> 64-bit images so now</font><font color="#CCCCCC"> for the</font>

263
00:10:30,260 --> 00:10:34,730
sake of argument<font color="#CCCCCC"> let's assume that we</font>

264
00:10:32,750 --> 00:10:37,790
that I already have 32-bit<font color="#E5E5E5"> code running</font>

265
00:10:34,730 --> 00:10:38,990
<font color="#E5E5E5">inside the target while 64</font><font color="#CCCCCC"> losses</font><font color="#E5E5E5"> again</font>

266
00:10:37,790 --> 00:10:41,180
<font color="#CCCCCC">without</font><font color="#E5E5E5"> talking about</font><font color="#CCCCCC"> the security</font>

267
00:10:38,990 --> 00:10:44,000
product<font color="#CCCCCC"> such as an AV this is a valid</font>

268
00:10:41,180 --> 00:10:47,180
assumption which usually<font color="#E5E5E5"> holds so this</font>

269
00:10:44,000 --> 00:10:49,400
32-bit<font color="#E5E5E5"> code</font><font color="#CCCCCC"> can normally only</font><font color="#E5E5E5"> access the</font>

270
00:10:47,180 --> 00:10:51,319
<font color="#E5E5E5">32-bit image loader which isn't really</font>

271
00:10:49,400 --> 00:10:53,780
<font color="#CCCCCC">getting me anywhere because</font><font color="#E5E5E5"> I can't use</font>

272
00:10:51,320 --> 00:10:56,840
<font color="#E5E5E5">this loader to load my desired</font><font color="#CCCCCC"> 64 bit</font>

273
00:10:53,780 --> 00:10:59,569
payload<font color="#E5E5E5"> but what this 32-bit code can do</font>

274
00:10:56,840 --> 00:11:01,370
is use techniques such as seventh gate

275
00:10:59,570 --> 00:11:04,010
in<font color="#CCCCCC"> order to</font><font color="#E5E5E5"> transition itself into</font>

276
00:11:01,370 --> 00:11:06,740
64-bit mode and once the jump<font color="#CCCCCC"> into</font>

277
00:11:04,010 --> 00:11:08,540
64-bit mode<font color="#E5E5E5"> has been</font><font color="#CCCCCC"> made it basically</font>

278
00:11:06,740 --> 00:11:11,030
opens<font color="#CCCCCC"> up the possibility of using the</font>

279
00:11:08,540 --> 00:11:13,040
64-bit<font color="#E5E5E5"> loader for example for example by</font>

280
00:11:11,030 --> 00:11:15,160
<font color="#E5E5E5">calling the 64-bit version</font><font color="#CCCCCC"> of a function</font>

281
00:11:13,040 --> 00:11:17,079
named<font color="#CCCCCC"> el Diablo</font><font color="#E5E5E5"> DLL</font>

282
00:11:15,160 --> 00:11:19,870
and I can use this function<font color="#E5E5E5"> to load my</font>

283
00:11:17,079 --> 00:11:21,370
desired<font color="#E5E5E5"> 64-bit payload and so to</font>

284
00:11:19,870 --> 00:11:23,110
<font color="#E5E5E5">summarize</font><font color="#CCCCCC"> were</font><font color="#E5E5E5"> basically talking about</font>

285
00:11:21,370 --> 00:11:25,060
<font color="#E5E5E5">the</font><font color="#CCCCCC"> two-phase injection method here in</font>

286
00:11:23,110 --> 00:11:27,430
which in<font color="#E5E5E5"> the first phase we inject the</font>

287
00:11:25,060 --> 00:11:29,619
32-bit dealer use this<font color="#CCCCCC"> dll to transition</font>

288
00:11:27,430 --> 00:11:33,699
into 64-bit mode and then load an

289
00:11:29,620 --> 00:11:35,680
additional 64-bit<font color="#CCCCCC"> DLL okay</font>

290
00:11:33,699 --> 00:11:37,300
the third and last injection<font color="#CCCCCC"> method</font>

291
00:11:35,680 --> 00:11:39,819
<font color="#CCCCCC">we're</font><font color="#E5E5E5"> going</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> describe is something</font>

292
00:11:37,300 --> 00:11:41,139
called injection via a PC<font color="#CCCCCC"> so before we</font>

293
00:11:39,819 --> 00:11:42,610
dive into all<font color="#CCCCCC"> of the</font><font color="#E5E5E5"> nitty-gritty</font>

294
00:11:41,139 --> 00:11:44,949
details of how this injection is

295
00:11:42,610 --> 00:11:46,810
actually implemented<font color="#CCCCCC"> and couple of what</font>

296
00:11:44,949 --> 00:11:49,089
about a<font color="#E5E5E5"> pcs in general are usually in</font>

297
00:11:46,810 --> 00:11:51,008
place<font color="#E5E5E5"> so an IPC is an acronym</font><font color="#CCCCCC"> which</font>

298
00:11:49,089 --> 00:11:53,050
<font color="#E5E5E5">stands for asynchronous</font><font color="#CCCCCC"> procedure call</font>

299
00:11:51,009 --> 00:11:55,149
and it's a<font color="#E5E5E5"> mechanism</font><font color="#CCCCCC"> built into the</font>

300
00:11:53,050 --> 00:11:56,949
<font color="#CCCCCC">Windows kernel</font><font color="#E5E5E5"> which basically allows me</font>

301
00:11:55,149 --> 00:12:00,069
to take a particular<font color="#CCCCCC"> boot in</font><font color="#E5E5E5"> and then</font>

302
00:11:56,949 --> 00:12:02,349
view<font color="#E5E5E5"> it to a thread</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> our choice and</font>

303
00:12:00,069 --> 00:12:04,240
what this mechanism<font color="#CCCCCC"> guarantees is that</font>

304
00:12:02,350 --> 00:12:05,860
at some<font color="#CCCCCC"> point</font><font color="#E5E5E5"> in the future the target</font>

305
00:12:04,240 --> 00:12:08,829
thread is<font color="#E5E5E5"> going to stop whatever it is</font>

306
00:12:05,860 --> 00:12:12,879
<font color="#E5E5E5">currently doing doing and instead jump</font>

307
00:12:08,829 --> 00:12:15,160
to my routine instead<font color="#E5E5E5"> so in Windows</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> PC</font>

308
00:12:12,879 --> 00:12:16,689
is come in several flavors<font color="#CCCCCC"> in the course</font>

309
00:12:15,160 --> 00:12:18,160
of this talk<font color="#CCCCCC"> we'll only</font><font color="#E5E5E5"> going to</font>

310
00:12:16,689 --> 00:12:20,980
describe one specific<font color="#E5E5E5"> kind which is</font>

311
00:12:18,160 --> 00:12:23,139
<font color="#E5E5E5">called user mode a</font><font color="#CCCCCC"> PCS so user mode</font><font color="#E5E5E5"> a</font>

312
00:12:20,980 --> 00:12:24,449
<font color="#E5E5E5">pcs have some distinct characteristics</font>

313
00:12:23,139 --> 00:12:28,630
to them

314
00:12:24,449 --> 00:12:30,180
first and foremost<font color="#E5E5E5"> the function that is</font>

315
00:12:28,630 --> 00:12:32,410
about to<font color="#CCCCCC"> be executed</font>

316
00:12:30,180 --> 00:12:33,910
<font color="#E5E5E5">is going to</font><font color="#CCCCCC"> one with user mode</font>

317
00:12:32,410 --> 00:12:34,660
permissions unlike kernel mode

318
00:12:33,910 --> 00:12:37,240
permissions

319
00:12:34,660 --> 00:12:39,310
the second key characteristic is that<font color="#E5E5E5"> in</font>

320
00:12:37,240 --> 00:12:41,410
<font color="#E5E5E5">order for</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> PC to</font><font color="#E5E5E5"> trigger or fire</font>

321
00:12:39,310 --> 00:12:43,750
the target thread must enter<font color="#E5E5E5"> something</font>

322
00:12:41,410 --> 00:12:45,279
called an allowable<font color="#CCCCCC"> wait</font><font color="#E5E5E5"> state so that</font>

323
00:12:43,750 --> 00:12:47,199
happens for<font color="#CCCCCC"> example when the flood goes</font>

324
00:12:45,279 --> 00:12:48,880
to sleep<font color="#E5E5E5"> wait for wait for a</font>

325
00:12:47,199 --> 00:12:49,410
synchronization object or<font color="#E5E5E5"> something like</font>

326
00:12:48,880 --> 00:12:51,910
that

327
00:12:49,410 --> 00:12:53,529
the third key point<font color="#E5E5E5"> to notice is</font><font color="#CCCCCC"> that</font>

328
00:12:51,910 --> 00:12:56,230
<font color="#E5E5E5">audio some of the pieces</font><font color="#CCCCCC"> are</font><font color="#E5E5E5"> first</font>

329
00:12:53,529 --> 00:12:58,660
handled by<font color="#E5E5E5"> one single function called K</font>

330
00:12:56,230 --> 00:12:59,559
<font color="#E5E5E5">IPC dispatcher which is exported from</font>

331
00:12:58,660 --> 00:13:01,719
<font color="#E5E5E5">ntdll</font>

332
00:12:59,559 --> 00:13:03,519
<font color="#CCCCCC">and so this function basically is going</font>

333
00:13:01,720 --> 00:13:06,639
<font color="#E5E5E5">to make several preparations and then</font>

334
00:13:03,519 --> 00:13:08,740
just jump to the function which the

335
00:13:06,639 --> 00:13:12,699
<font color="#E5E5E5">vulgrim are intended to call and we will</font>

336
00:13:08,740 --> 00:13:14,920
get<font color="#E5E5E5"> back</font><font color="#CCCCCC"> into this function later</font><font color="#E5E5E5"> we</font>

337
00:13:12,699 --> 00:13:17,920
have a few<font color="#E5E5E5"> possible options for queuing</font>

338
00:13:14,920 --> 00:13:20,860
an IPC the most common one is<font color="#E5E5E5"> to use the</font>

339
00:13:17,920 --> 00:13:22,599
kernel<font color="#E5E5E5"> mode either to do it we can do it</font>

340
00:13:20,860 --> 00:13:24,910
also for me<font color="#CCCCCC"> use</font><font color="#E5E5E5"> of space application but</font>

341
00:13:22,600 --> 00:13:28,569
<font color="#E5E5E5">we are going to stick</font><font color="#CCCCCC"> with the kernel</font>

342
00:13:24,910 --> 00:13:30,880
<font color="#CCCCCC">mode evaluation</font><font color="#E5E5E5"> okay so now let's talk</font>

343
00:13:28,569 --> 00:13:32,439
about the injection itself<font color="#E5E5E5"> so injection</font>

344
00:13:30,880 --> 00:13:35,380
via<font color="#E5E5E5"> a PC is probably the most popular</font>

345
00:13:32,439 --> 00:13:37,420
injection method<font color="#E5E5E5"> used both by</font><font color="#CCCCCC"> IVs</font><font color="#E5E5E5"> as</font>

346
00:13:35,380 --> 00:13:39,309
well as by<font color="#CCCCCC"> some intelligence</font><font color="#E5E5E5"> agencies as</font>

347
00:13:37,420 --> 00:13:41,949
you can see<font color="#E5E5E5"> and they do this by simply</font>

348
00:13:39,309 --> 00:13:44,649
<font color="#E5E5E5">human IPC which ultimately calls a</font>

349
00:13:41,949 --> 00:13:47,229
function<font color="#CCCCCC"> such as</font><font color="#E5E5E5"> LDL</font><font color="#CCCCCC"> or</font><font color="#E5E5E5"> DLL load</font><font color="#CCCCCC"> library</font>

350
00:13:44,649 --> 00:13:48,939
or one of its variants<font color="#E5E5E5"> and indeed in</font>

351
00:13:47,230 --> 00:13:50,679
most cases this technique is only used

352
00:13:48,939 --> 00:13:53,349
in order<font color="#E5E5E5"> to inject the DLL which has the</font>

353
00:13:50,679 --> 00:13:55,420
same business as the target<font color="#CCCCCC"> process</font><font color="#E5E5E5"> but</font>

354
00:13:53,350 --> 00:13:58,750
what what we should keep in<font color="#CCCCCC"> mind</font><font color="#E5E5E5"> is that</font>

355
00:13:55,420 --> 00:14:01,540
<font color="#CCCCCC">in while 64 processes a</font><font color="#E5E5E5"> pcs can run both</font>

356
00:13:58,750 --> 00:14:03,939
<font color="#E5E5E5">32-bit code or 64-bit code and in some</font>

357
00:14:01,540 --> 00:14:06,099
cases for<font color="#CCCCCC"> example when we do our IPC</font>

358
00:14:03,939 --> 00:14:08,199
from a kernel mode<font color="#CCCCCC"> either</font><font color="#E5E5E5"> the default</font>

359
00:14:06,100 --> 00:14:10,720
will<font color="#CCCCCC"> be to run it in 64-bit mode</font><font color="#E5E5E5"> and</font>

360
00:14:08,199 --> 00:14:14,699
then like makes them great candidates

361
00:14:10,720 --> 00:14:17,139
for<font color="#E5E5E5"> loading additional 64-bit dll's</font>

362
00:14:14,699 --> 00:14:19,329
<font color="#E5E5E5">okay what we can see here is basically</font>

363
00:14:17,139 --> 00:14:22,480
<font color="#E5E5E5">some</font><font color="#CCCCCC"> common mode code which implements</font>

364
00:14:19,329 --> 00:14:23,920
this technique<font color="#E5E5E5"> DLL injection via a PC</font>

365
00:14:22,480 --> 00:14:27,149
from the kernel mode rival

366
00:14:23,920 --> 00:14:29,319
so some key takeaways<font color="#CCCCCC"> from</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> slide</font>

367
00:14:27,149 --> 00:14:31,029
<font color="#E5E5E5">first of all let's talk about the</font>

368
00:14:29,319 --> 00:14:33,370
function which<font color="#E5E5E5"> is going to</font><font color="#CCCCCC"> execute in</font>

369
00:14:31,029 --> 00:14:35,679
the context<font color="#E5E5E5"> of the APC so all of these</font>

370
00:14:33,370 --> 00:14:37,839
functions<font color="#CCCCCC"> must conform to a standard</font>

371
00:14:35,679 --> 00:14:40,240
<font color="#CCCCCC">auto</font><font color="#E5E5E5"> type which was already predefined</font>

372
00:14:37,839 --> 00:14:42,509
<font color="#CCCCCC">by Microsoft</font><font color="#E5E5E5"> and as you can see all</font><font color="#CCCCCC"> of</font>

373
00:14:40,240 --> 00:14:45,639
<font color="#E5E5E5">these functions must return void and</font>

374
00:14:42,509 --> 00:14:48,670
receive<font color="#CCCCCC"> free pointers as their input</font>

375
00:14:45,639 --> 00:14:50,649
arguments and so that raises<font color="#E5E5E5"> the</font>

376
00:14:48,670 --> 00:14:52,059
<font color="#CCCCCC">question</font><font color="#E5E5E5"> what happens if the function</font>

377
00:14:50,649 --> 00:14:54,309
<font color="#CCCCCC">that I wish to call has a different</font>

378
00:14:52,059 --> 00:14:56,380
<font color="#E5E5E5">water type so in</font><font color="#CCCCCC"> order to</font><font color="#E5E5E5"> overcome this</font>

379
00:14:54,309 --> 00:14:58,029
obstacle we use some sort of a<font color="#E5E5E5"> trick and</font>

380
00:14:56,380 --> 00:14:59,620
the trick basically says<font color="#CCCCCC"> that</font><font color="#E5E5E5"> we're</font>

381
00:14:58,029 --> 00:15:01,779
going<font color="#E5E5E5"> to</font><font color="#CCCCCC"> use the first</font><font color="#E5E5E5"> parameter the</font>

382
00:14:59,620 --> 00:15:03,790
normal context parameter in order<font color="#CCCCCC"> to</font>

383
00:15:01,779 --> 00:15:05,649
pass in a user-defined structure and

384
00:15:03,790 --> 00:15:07,779
inside the<font color="#E5E5E5"> structure we can encapsulate</font>

385
00:15:05,649 --> 00:15:09,730
both the address of the<font color="#CCCCCC"> function that I</font>

386
00:15:07,779 --> 00:15:11,259
really<font color="#E5E5E5"> wish</font><font color="#CCCCCC"> to call as</font><font color="#E5E5E5"> well as the</font>

387
00:15:09,730 --> 00:15:13,089
values of all the parameters<font color="#CCCCCC"> that I wish</font>

388
00:15:11,259 --> 00:15:14,290
to<font color="#CCCCCC"> forward</font><font color="#E5E5E5"> into it so in our case</font>

389
00:15:13,089 --> 00:15:16,420
<font color="#CCCCCC">because</font><font color="#E5E5E5"> we</font><font color="#CCCCCC"> are dealing</font><font color="#E5E5E5"> with the other</font>

390
00:15:14,290 --> 00:15:19,300
injectors the function is going to<font color="#CCCCCC"> be</font>

391
00:15:16,420 --> 00:15:21,309
<font color="#E5E5E5">the 64-bit version</font><font color="#CCCCCC"> of El Diablo DLL</font><font color="#E5E5E5"> and</font>

392
00:15:19,300 --> 00:15:24,279
the parameter is basically going to be

393
00:15:21,309 --> 00:15:26,949
<font color="#E5E5E5">the name</font><font color="#CCCCCC"> of the DLL I wish to inject so</font>

394
00:15:24,279 --> 00:15:28,600
if we take a look at<font color="#E5E5E5"> this function in</font>

395
00:15:26,949 --> 00:15:30,490
<font color="#CCCCCC">its entirely we can see that</font><font color="#E5E5E5"> it's</font>

396
00:15:28,600 --> 00:15:31,750
basically<font color="#E5E5E5"> just translates one function</font>

397
00:15:30,490 --> 00:15:34,419
prototype into<font color="#E5E5E5"> another function</font>

398
00:15:31,750 --> 00:15:36,880
<font color="#E5E5E5">prototype and this is the reason we</font>

399
00:15:34,419 --> 00:15:38,679
<font color="#CCCCCC">chose to term it an adapter func this is</font>

400
00:15:36,880 --> 00:15:40,240
not an official<font color="#E5E5E5"> terminology</font><font color="#CCCCCC"> of any kind</font>

401
00:15:38,679 --> 00:15:41,199
but<font color="#E5E5E5"> this is the time we are going to use</font>

402
00:15:40,240 --> 00:15:45,670
for the<font color="#CCCCCC"> rest of</font><font color="#E5E5E5"> this</font>

403
00:15:41,200 --> 00:15:47,470
so keep<font color="#E5E5E5"> that in mind now the type of the</font>

404
00:15:45,670 --> 00:15:49,959
<font color="#CCCCCC">APC</font><font color="#E5E5E5"> we are using is</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> usermod APC</font>

405
00:15:47,470 --> 00:15:51,700
which means the<font color="#E5E5E5"> adapter</font><font color="#CCCCCC"> func itself must</font>

406
00:15:49,960 --> 00:15:53,710
reside in memory which is accessible<font color="#CCCCCC"> to</font>

407
00:15:51,700 --> 00:15:55,720
<font color="#E5E5E5">use all space so in order to make</font><font color="#CCCCCC"> sure</font>

408
00:15:53,710 --> 00:15:58,090
it does<font color="#E5E5E5"> we first have</font><font color="#CCCCCC"> to allocate and</font>

409
00:15:55,720 --> 00:16:00,220
execute<font color="#E5E5E5"> a user mode executable user mode</font>

410
00:15:58,090 --> 00:16:02,410
buffer which is<font color="#E5E5E5"> both executable as well</font>

411
00:16:00,220 --> 00:16:04,600
as<font color="#CCCCCC"> writable and after we get</font><font color="#E5E5E5"> this buffer</font>

412
00:16:02,410 --> 00:16:06,550
we can simply copy into<font color="#E5E5E5"> it the actual</font>

413
00:16:04,600 --> 00:16:08,920
<font color="#E5E5E5">code bytes which</font><font color="#CCCCCC"> comprise the</font><font color="#E5E5E5"> adapter</font>

414
00:16:06,550 --> 00:16:11,859
func after we do this we<font color="#CCCCCC"> can simply</font>

415
00:16:08,920 --> 00:16:14,050
<font color="#E5E5E5">initialize the APC object to point to</font>

416
00:16:11,860 --> 00:16:16,140
the buffer we have<font color="#CCCCCC"> allocated and</font><font color="#E5E5E5"> queue</font>

417
00:16:14,050 --> 00:16:19,240
it to the<font color="#E5E5E5"> APC queue of the target thread</font>

418
00:16:16,140 --> 00:16:21,220
now a formal<font color="#CCCCCC"> Kohima driver we</font><font color="#E5E5E5"> can</font>

419
00:16:19,240 --> 00:16:23,410
intercept thread<font color="#CCCCCC"> creation event</font><font color="#E5E5E5"> and</font>

420
00:16:21,220 --> 00:16:25,930
basically repeat this entire procedure

421
00:16:23,410 --> 00:16:28,240
for every<font color="#CCCCCC"> newly</font><font color="#E5E5E5"> created</font><font color="#CCCCCC"> well 64 flood in</font>

422
00:16:25,930 --> 00:16:30,910
<font color="#E5E5E5">the system and this</font><font color="#CCCCCC"> ultimately means</font>

423
00:16:28,240 --> 00:16:36,430
<font color="#E5E5E5">that our</font><font color="#CCCCCC"> DLL will be injected into every</font>

424
00:16:30,910 --> 00:16:37,689
<font color="#CCCCCC">164 horses</font><font color="#E5E5E5"> across the system</font><font color="#CCCCCC"> okay so we</font>

425
00:16:36,430 --> 00:16:39,630
have taken the source code<font color="#E5E5E5"> that I've</font>

426
00:16:37,690 --> 00:16:42,550
just shown<font color="#CCCCCC"> you compile</font><font color="#E5E5E5"> it into</font><font color="#CCCCCC"> a driver</font>

427
00:16:39,630 --> 00:16:44,410
<font color="#E5E5E5">loaded it into</font><font color="#CCCCCC"> I think a Windows</font><font color="#E5E5E5"> 7</font>

428
00:16:42,550 --> 00:16:47,079
system<font color="#E5E5E5"> and tested it and indeed as you</font>

429
00:16:44,410 --> 00:16:49,990
<font color="#E5E5E5">can see it worked quite</font><font color="#CCCCCC"> well</font><font color="#E5E5E5"> we have a</font>

430
00:16:47,080 --> 00:16:54,820
<font color="#CCCCCC">32 bit process to which we manage manage</font>

431
00:16:49,990 --> 00:16:57,370
<font color="#E5E5E5">to inject our own</font><font color="#CCCCCC"> 64 bit</font><font color="#E5E5E5"> DLL so this was</font>

432
00:16:54,820 --> 00:16:59,350
kind<font color="#E5E5E5"> of nice but after some time one</font><font color="#CCCCCC"> of</font>

433
00:16:57,370 --> 00:17:01,750
<font color="#E5E5E5">us said it would be like</font><font color="#CCCCCC"> a good idea to</font>

434
00:16:59,350 --> 00:17:03,610
<font color="#E5E5E5">test the same solution on a more recent</font>

435
00:17:01,750 --> 00:17:05,770
Windows version for example<font color="#E5E5E5"> Windows 10</font>

436
00:17:03,610 --> 00:17:08,079
and then we<font color="#E5E5E5"> got some</font><font color="#CCCCCC"> very different</font>

437
00:17:05,770 --> 00:17:09,940
<font color="#E5E5E5">result</font><font color="#CCCCCC"> specifically most of the</font>

438
00:17:08,079 --> 00:17:13,240
processes to which we try to inject<font color="#CCCCCC"> well</font>

439
00:17:09,940 --> 00:17:16,000
DLL simply crashed so after a little<font color="#CCCCCC"> bit</font>

440
00:17:13,240 --> 00:17:18,910
<font color="#CCCCCC">of debugging or bobbing on</font><font color="#E5E5E5"> Twitter we</font>

441
00:17:16,000 --> 00:17:21,400
bumped into this tweet from<font color="#CCCCCC"> Alex UNESCO</font>

442
00:17:18,910 --> 00:17:24,430
and from this<font color="#CCCCCC"> to it we learned</font><font color="#E5E5E5"> several</font>

443
00:17:21,400 --> 00:17:27,270
interesting facts<font color="#CCCCCC"> and specifically we</font>

444
00:17:24,430 --> 00:17:30,790
learned that the crash is probably

445
00:17:27,270 --> 00:17:32,500
<font color="#E5E5E5">related to CFG so before we can start</font>

446
00:17:30,790 --> 00:17:34,810
thinking about<font color="#E5E5E5"> possible solutions</font><font color="#CCCCCC"> to our</font>

447
00:17:32,500 --> 00:17:38,320
problem<font color="#CCCCCC"> we first</font><font color="#E5E5E5"> have to understand what</font>

448
00:17:34,810 --> 00:17:40,750
CFG is what are its implications<font color="#E5E5E5"> across</font>

449
00:17:38,320 --> 00:17:47,320
the system<font color="#E5E5E5"> and how it is related to all</font>

450
00:17:40,750 --> 00:17:49,390
64 so for those<font color="#CCCCCC"> of</font><font color="#E5E5E5"> you who don't</font><font color="#CCCCCC"> know is</font>

451
00:17:47,320 --> 00:17:52,270
feature CFG is an acronym for<font color="#E5E5E5"> control</font>

452
00:17:49,390 --> 00:17:54,740
<font color="#CCCCCC">flow guard</font><font color="#E5E5E5"> it's a relatively new exploit</font>

453
00:17:52,270 --> 00:17:57,470
mitigation technique introduced<font color="#E5E5E5"> by Mike</font>

454
00:17:54,740 --> 00:17:59,990
soft in<font color="#CCCCCC"> windows 8.1 and enhanced in we</font>

455
00:17:57,470 --> 00:18:02,360
lost em this is our compiler<font color="#CCCCCC"> enable</font>

456
00:17:59,990 --> 00:18:04,190
mitigation that is meant<font color="#E5E5E5"> to prevent</font>

457
00:18:02,360 --> 00:18:06,770
memory<font color="#E5E5E5"> corruption vulnerabilities by</font>

458
00:18:04,190 --> 00:18:09,140
preventing<font color="#CCCCCC"> indirect calls to</font><font color="#E5E5E5"> non</font>

459
00:18:06,770 --> 00:18:11,150
<font color="#E5E5E5">legitimate call targets it works by</font>

460
00:18:09,140 --> 00:18:13,730
inserting an additional call through a

461
00:18:11,150 --> 00:18:16,100
validation<font color="#E5E5E5"> routine before</font><font color="#CCCCCC"> every indirect</font>

462
00:18:13,730 --> 00:18:18,559
call done in the application as you<font color="#E5E5E5"> can</font>

463
00:18:16,100 --> 00:18:21,379
see here this validation routine

464
00:18:18,559 --> 00:18:22,700
receives a single<font color="#CCCCCC"> argument which is the</font>

465
00:18:21,380 --> 00:18:25,220
address<font color="#CCCCCC"> it</font><font color="#E5E5E5"> is about to be called</font>

466
00:18:22,700 --> 00:18:27,620
<font color="#E5E5E5">indirectly and checks whether or not it</font>

467
00:18:25,220 --> 00:18:30,440
makes a valid call target<font color="#E5E5E5"> if the address</font>

468
00:18:27,620 --> 00:18:32,510
is a valid target<font color="#E5E5E5"> the function returns</font>

469
00:18:30,440 --> 00:18:34,460
and the execution continues normally if

470
00:18:32,510 --> 00:18:36,590
the<font color="#CCCCCC"> address is not</font><font color="#E5E5E5"> of alcohol target</font>

471
00:18:34,460 --> 00:18:41,120
<font color="#E5E5E5">this validation routine will just</font><font color="#CCCCCC"> crush</font>

472
00:18:36,590 --> 00:18:44,270
<font color="#CCCCCC">the process now what are</font><font color="#E5E5E5"> valid call</font>

473
00:18:41,120 --> 00:18:47,659
targets for images compiled with CFG we

474
00:18:44,270 --> 00:18:50,600
the export a<font color="#E5E5E5"> list of where</font><font color="#CCCCCC"> their</font>

475
00:18:47,660 --> 00:18:52,210
functions are and so we've alcohol

476
00:18:50,600 --> 00:18:54,740
target is

477
00:18:52,210 --> 00:18:57,230
the eval<font color="#E5E5E5"> contract it is defined as the</font>

478
00:18:54,740 --> 00:18:59,929
beginning<font color="#CCCCCC"> of a function so we have this</font>

479
00:18:57,230 --> 00:19:01,910
list<font color="#E5E5E5"> of functions and we know we are</font>

480
00:18:59,929 --> 00:19:04,910
where<font color="#CCCCCC"> they Val call targets are for</font><font color="#E5E5E5"> this</font>

481
00:19:01,910 --> 00:19:07,250
image but for<font color="#E5E5E5"> images not compiled with</font>

482
00:19:04,910 --> 00:19:09,290
CFG or private memory<font color="#CCCCCC"> allocations we</font>

483
00:19:07,250 --> 00:19:11,750
don't have this list<font color="#CCCCCC"> so the whole</font>

484
00:19:09,290 --> 00:19:14,870
executable buffer is just considered<font color="#CCCCCC"> a</font>

485
00:19:11,750 --> 00:19:17,270
valid call target just<font color="#E5E5E5"> to be safe the</font>

486
00:19:14,870 --> 00:19:20,000
<font color="#CCCCCC">way CFG knows where these</font><font color="#E5E5E5"> Val call</font>

487
00:19:17,270 --> 00:19:21,650
targets are is by using a memory<font color="#E5E5E5"> area</font>

488
00:19:20,000 --> 00:19:24,530
designed<font color="#CCCCCC"> for this purpose called a</font>

489
00:19:21,650 --> 00:19:26,809
safety bitmap in this bitmap<font color="#E5E5E5"> each beat</font>

490
00:19:24,530 --> 00:19:29,360
marks<font color="#CCCCCC"> eight bytes in the process a</font>

491
00:19:26,809 --> 00:19:31,580
memory and<font color="#E5E5E5"> shows whether or not these</font>

492
00:19:29,360 --> 00:19:34,729
eight bytes make a valid call target or

493
00:19:31,580 --> 00:19:37,460
not<font color="#E5E5E5"> this is a very large</font><font color="#CCCCCC"> memory area so</font>

494
00:19:34,730 --> 00:19:39,470
most<font color="#CCCCCC"> of the time</font><font color="#E5E5E5"> a large portion of it</font>

495
00:19:37,460 --> 00:19:41,929
is<font color="#E5E5E5"> not used and only when every new</font>

496
00:19:39,470 --> 00:19:44,480
<font color="#E5E5E5">executable memory is introduced into the</font>

497
00:19:41,929 --> 00:19:47,809
process<font color="#E5E5E5"> the relevant part of a safety</font>

498
00:19:44,480 --> 00:19:50,270
bitmap is committed and<font color="#CCCCCC"> marked to</font><font color="#E5E5E5"> show</font>

499
00:19:47,809 --> 00:19:53,230
which parts<font color="#E5E5E5"> of it make</font><font color="#CCCCCC"> a Val</font><font color="#E5E5E5"> call forget</font>

500
00:19:50,270 --> 00:19:53,230
<font color="#CCCCCC">and which don't</font>

501
00:19:54,320 --> 00:19:59,120
now let's take a look at the validation

502
00:19:56,540 --> 00:20:00,710
routine<font color="#CCCCCC"> this</font><font color="#E5E5E5"> is l dfp validate user call</font>

503
00:19:59,120 --> 00:20:02,320
target found<font color="#E5E5E5"> inside of ntdll</font>

504
00:20:00,710 --> 00:20:05,720
this is a function<font color="#CCCCCC"> that gets called</font>

505
00:20:02,320 --> 00:20:07,760
whenever<font color="#E5E5E5"> a new</font><font color="#CCCCCC"> whenever an indirect</font>

506
00:20:05,720 --> 00:20:08,450
calls about to be made<font color="#E5E5E5"> this function</font>

507
00:20:07,760 --> 00:20:09,830
<font color="#E5E5E5">receives the</font>

508
00:20:08,450 --> 00:20:12,110
addressed is about to be called<font color="#E5E5E5"> and</font>

509
00:20:09,830 --> 00:20:14,810
makes the arithmetic<font color="#E5E5E5"> calculations</font>

510
00:20:12,110 --> 00:20:17,840
required to<font color="#E5E5E5"> find the beat in the safety</font>

511
00:20:14,810 --> 00:20:19,639
<font color="#E5E5E5">bitmap that</font><font color="#CCCCCC"> Marxist address then it</font>

512
00:20:17,840 --> 00:20:21,770
checks<font color="#E5E5E5"> if the bit is set if the</font><font color="#CCCCCC"> bit is</font>

513
00:20:19,640 --> 00:20:23,690
<font color="#CCCCCC">set</font><font color="#E5E5E5"> it means that the address is a valid</font>

514
00:20:21,770 --> 00:20:26,300
<font color="#E5E5E5">call target so we</font><font color="#CCCCCC"> take the left</font><font color="#E5E5E5"> branch</font>

515
00:20:23,690 --> 00:20:28,250
in the function returns<font color="#E5E5E5"> if the bit is</font>

516
00:20:26,300 --> 00:20:30,320
<font color="#E5E5E5">not that mean this is not a valid called</font>

517
00:20:28,250 --> 00:20:31,790
<font color="#CCCCCC">how gifted we take the right branch</font><font color="#E5E5E5"> the</font>

518
00:20:30,320 --> 00:20:34,580
function will eventually crush the

519
00:20:31,790 --> 00:20:36,860
process resulting in<font color="#E5E5E5"> the</font><font color="#CCCCCC"> Gorgias call</font>

520
00:20:34,580 --> 00:20:40,370
stack<font color="#E5E5E5"> we have here the</font><font color="#CCCCCC"> to talk from a</font>

521
00:20:36,860 --> 00:20:42,409
crash dump<font color="#CCCCCC"> on Windows 10 in all 64</font>

522
00:20:40,370 --> 00:20:45,979
processes if G gets a tiny bit<font color="#E5E5E5"> more</font>

523
00:20:42,410 --> 00:20:48,710
<font color="#CCCCCC">complicated since the since while 64 POC</font>

524
00:20:45,980 --> 00:20:52,640
says in<font color="#E5E5E5"> run both 32-bit and 64-bit code</font>

525
00:20:48,710 --> 00:20:54,350
we have<font color="#CCCCCC"> to</font><font color="#E5E5E5"> CFG bitmaps while 64</font><font color="#CCCCCC"> bit</font><font color="#E5E5E5"> map</font>

526
00:20:52,640 --> 00:20:56,870
<font color="#CCCCCC">that</font><font color="#E5E5E5"> mark is the 32-bit code in the</font>

527
00:20:54,350 --> 00:21:02,330
process and a native CFG bitmap<font color="#CCCCCC"> that</font>

528
00:20:56,870 --> 00:21:04,340
marks the 64-bit<font color="#E5E5E5"> code we also as you</font>

529
00:21:02,330 --> 00:21:08,090
might remember<font color="#E5E5E5"> we also have two versions</font>

530
00:21:04,340 --> 00:21:10,010
of ntdll 32-bit and 64-bit version so we

531
00:21:08,090 --> 00:21:13,220
also have two<font color="#E5E5E5"> versions of the validation</font>

532
00:21:10,010 --> 00:21:15,560
<font color="#E5E5E5">routine and it works that way the</font>

533
00:21:13,220 --> 00:21:17,450
<font color="#E5E5E5">validation routine in the 64-bit ntdll</font>

534
00:21:15,560 --> 00:21:20,179
<font color="#E5E5E5">checks addresses against the native</font>

535
00:21:17,450 --> 00:21:22,640
bitmap and the validation routine in the

536
00:21:20,180 --> 00:21:26,180
32-bit<font color="#E5E5E5"> ntdll checks addresses against</font>

537
00:21:22,640 --> 00:21:28,820
the<font color="#CCCCCC"> wall 64 CFG bitmap near the</font><font color="#E5E5E5"> suitable</font>

538
00:21:26,180 --> 00:21:30,830
memory involve<font color="#E5E5E5"> 64 processes</font><font color="#CCCCCC"> only ever</font>

539
00:21:28,820 --> 00:21:31,340
gets marked in one of these<font color="#CCCCCC"> two CFG</font>

540
00:21:30,830 --> 00:21:34,399
bitmaps

541
00:21:31,340 --> 00:21:38,060
<font color="#E5E5E5">so how do we choose which bitmap</font><font color="#CCCCCC"> ooh to</font>

542
00:21:34,400 --> 00:21:40,250
mark for<font color="#CCCCCC"> that we have a</font><font color="#E5E5E5"> this function</font><font color="#CCCCCC"> mi</font>

543
00:21:38,060 --> 00:21:42,260
select CFG bitmap this is a kernel

544
00:21:40,250 --> 00:21:44,990
kernel function called when every new

545
00:21:42,260 --> 00:21:49,100
executable<font color="#E5E5E5"> memory is introduced into any</font>

546
00:21:44,990 --> 00:21:51,140
process<font color="#CCCCCC"> his</font><font color="#E5E5E5"> function</font><font color="#CCCCCC"> chair chooses the</font>

547
00:21:49,100 --> 00:21:53,990
correct bitmap to mark<font color="#E5E5E5"> this memory in</font>

548
00:21:51,140 --> 00:21:56,630
based on a few simple checks first<font color="#E5E5E5"> this</font>

549
00:21:53,990 --> 00:21:59,990
memory<font color="#CCCCCC"> the process must be</font><font color="#E5E5E5"> our</font><font color="#CCCCCC"> work 64</font>

550
00:21:56,630 --> 00:22:02,510
process<font color="#E5E5E5"> if it isn't the process should</font>

551
00:21:59,990 --> 00:22:05,300
only have one<font color="#CCCCCC"> native CFG bitmap so it</font>

552
00:22:02,510 --> 00:22:07,610
will always<font color="#CCCCCC"> be returned</font><font color="#E5E5E5"> second if we are</font>

553
00:22:05,300 --> 00:22:11,060
running<font color="#CCCCCC"> the or 64 process the address</font>

554
00:22:07,610 --> 00:22:12,919
must<font color="#E5E5E5"> be below</font><font color="#CCCCCC"> 4 gigabytes in 164</font>

555
00:22:11,060 --> 00:22:15,770
processors actually<font color="#E5E5E5"> most of the memory</font>

556
00:22:12,920 --> 00:22:17,720
<font color="#E5E5E5">above 4 gigabytes is reserved and we</font>

557
00:22:15,770 --> 00:22:20,900
can't<font color="#E5E5E5"> access it or allocate it normally</font>

558
00:22:17,720 --> 00:22:22,279
<font color="#E5E5E5">so this check should always a almost</font>

559
00:22:20,900 --> 00:22:25,429
always come<font color="#E5E5E5"> true</font>

560
00:22:22,279 --> 00:22:27,139
in 164 processes<font color="#E5E5E5"> and finally we have</font>

561
00:22:25,429 --> 00:22:29,239
this check which actually tests<font color="#E5E5E5"> whether</font>

562
00:22:27,139 --> 00:22:31,820
this memory is<font color="#E5E5E5"> part</font><font color="#CCCCCC"> of an image</font><font color="#E5E5E5"> or a</font>

563
00:22:29,239 --> 00:22:34,700
private<font color="#E5E5E5"> memory location private memory</font>

564
00:22:31,820 --> 00:22:37,129
<font color="#CCCCCC">locations done in 164 processes will</font>

565
00:22:34,700 --> 00:22:39,859
always be marked in<font color="#E5E5E5"> there were 64 CFG</font>

566
00:22:37,129 --> 00:22:42,769
bitmap a regardless of who allocated

567
00:22:39,859 --> 00:22:44,178
<font color="#E5E5E5">them or for what purpose</font><font color="#CCCCCC"> now if this</font>

568
00:22:42,769 --> 00:22:46,340
memory is<font color="#E5E5E5"> part of an image we check</font>

569
00:22:44,179 --> 00:22:48,700
whether<font color="#CCCCCC"> its image isn't 32 bit or</font><font color="#E5E5E5"> 64 bit</font>

570
00:22:46,340 --> 00:22:51,559
<font color="#CCCCCC">one and choose</font><font color="#E5E5E5"> the bitmap accordingly</font>

571
00:22:48,700 --> 00:22:55,460
<font color="#CCCCCC">now how does this all relate to</font><font color="#E5E5E5"> our</font>

572
00:22:51,559 --> 00:22:57,289
<font color="#E5E5E5">crashes well let's say rewind a bit we</font>

573
00:22:55,460 --> 00:23:01,759
took another<font color="#E5E5E5"> look at the crash dumps and</font>

574
00:22:57,289 --> 00:23:03,979
so that we managed to<font color="#CCCCCC"> QR a</font><font color="#E5E5E5"> pcs</font><font color="#CCCCCC"> 21264</font>

575
00:23:01,759 --> 00:23:06,529
<font color="#CCCCCC">processes and actually got you</font><font color="#E5E5E5"> can use a</font>

576
00:23:03,979 --> 00:23:09,409
PC dispatcher<font color="#E5E5E5"> which is the function in</font>

577
00:23:06,529 --> 00:23:12,049
anti<font color="#E5E5E5"> DLL</font><font color="#CCCCCC"> that should dispatcher a PC and</font>

578
00:23:09,409 --> 00:23:14,119
<font color="#E5E5E5">color</font><font color="#CCCCCC"> adaptor</font><font color="#E5E5E5"> thunk but instead of</font>

579
00:23:12,049 --> 00:23:16,729
corner<font color="#CCCCCC"> adapter thunk dysfunction</font><font color="#E5E5E5"> first</font>

580
00:23:14,119 --> 00:23:19,459
called<font color="#E5E5E5"> the validation routine since a PC</font>

581
00:23:16,729 --> 00:23:21,349
dispatching uses<font color="#E5E5E5"> in direct calls and the</font>

582
00:23:19,460 --> 00:23:25,249
validation routine never<font color="#E5E5E5"> returned</font>

583
00:23:21,349 --> 00:23:25,968
instead it crashed our processes<font color="#E5E5E5"> but why</font>

584
00:23:25,249 --> 00:23:30,679
did<font color="#E5E5E5"> that happen</font>

585
00:23:25,969 --> 00:23:33,859
<font color="#CCCCCC">well you might remember</font><font color="#E5E5E5"> private memory</font>

586
00:23:30,679 --> 00:23:36,830
locations in<font color="#E5E5E5"> 164 processes always get</font>

587
00:23:33,859 --> 00:23:38,869
marked in the u.s. 64<font color="#E5E5E5"> safety bitmap but</font>

588
00:23:36,830 --> 00:23:42,228
the function that<font color="#E5E5E5"> should dispatcher a PC</font>

589
00:23:38,869 --> 00:23:44,209
is a function<font color="#E5E5E5"> in the</font><font color="#CCCCCC"> 64 bit</font><font color="#E5E5E5"> ntdll which</font>

590
00:23:42,229 --> 00:23:46,609
checks addresses against the native CFG

591
00:23:44,210 --> 00:23:49,399
bitmap<font color="#CCCCCC"> so</font><font color="#E5E5E5"> our doctor thank is sort of</font>

592
00:23:46,609 --> 00:23:52,099
marked in the wrong CFG bitmap<font color="#E5E5E5"> it's not</font>

593
00:23:49,399 --> 00:23:53,928
marked<font color="#E5E5E5"> in the native bitmap so the</font>

594
00:23:52,099 --> 00:23:55,700
validation within assumes it does not

595
00:23:53,929 --> 00:23:58,879
<font color="#E5E5E5">make</font><font color="#CCCCCC"> a valid Coulter again and crashes</font>

596
00:23:55,700 --> 00:24:01,039
all of our<font color="#CCCCCC"> processes if this seems to</font>

597
00:23:58,879 --> 00:24:03,228
put an end<font color="#E5E5E5"> to our</font><font color="#CCCCCC"> a PC injector in</font>

598
00:24:01,039 --> 00:24:04,849
Windows 10<font color="#E5E5E5"> but we kind of like this</font>

599
00:24:03,229 --> 00:24:08,539
solution<font color="#E5E5E5"> and they don't want to give up</font>

600
00:24:04,849 --> 00:24:10,460
on it<font color="#CCCCCC"> just yet</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> now I'm going to do</font>

601
00:24:08,539 --> 00:24:15,830
what I usually do in such cases and ask

602
00:24:10,460 --> 00:24:17,989
us off to solve the problem okay<font color="#CCCCCC"> so</font><font color="#E5E5E5"> at</font>

603
00:24:15,830 --> 00:24:20,389
this<font color="#CCCCCC"> point we took another closer look</font>

604
00:24:17,989 --> 00:24:22,609
at<font color="#CCCCCC"> mi selective G bitmap and realized</font>

605
00:24:20,389 --> 00:24:24,529
<font color="#E5E5E5">that if</font><font color="#CCCCCC"> we want our adapter</font><font color="#E5E5E5"> fund to be</font>

606
00:24:22,609 --> 00:24:26,928
marked as a valid call target in the

607
00:24:24,529 --> 00:24:31,070
native CFG bitmap<font color="#E5E5E5"> we have to make this</font>

608
00:24:26,929 --> 00:24:33,440
large if statement evaluates to false<font color="#CCCCCC"> so</font>

609
00:24:31,070 --> 00:24:35,809
<font color="#CCCCCC">we first decided to tackle</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> first</font><font color="#E5E5E5"> sub</font>

610
00:24:33,440 --> 00:24:36,179
condition because it seemed<font color="#E5E5E5"> like the</font>

611
00:24:35,809 --> 00:24:38,158
<font color="#CCCCCC">easiest</font>

612
00:24:36,179 --> 00:24:39,929
<font color="#CCCCCC">one to manipulate so the first sub</font>

613
00:24:38,159 --> 00:24:42,269
condition actually<font color="#CCCCCC"> checks whether or not</font>

614
00:24:39,929 --> 00:24:46,139
the current<font color="#E5E5E5"> process is about 64 plus or</font>

615
00:24:42,269 --> 00:24:47,460
not<font color="#E5E5E5"> and it does so by holding</font><font color="#CCCCCC"> one of the</font>

616
00:24:46,139 --> 00:24:49,559
members of the relevant<font color="#E5E5E5"> it was</font>

617
00:24:47,460 --> 00:24:52,889
<font color="#E5E5E5">structures so this member is actually a</font>

618
00:24:49,559 --> 00:24:54,570
pointer<font color="#E5E5E5"> and if this pointer is set to</font>

619
00:24:52,889 --> 00:24:56,639
<font color="#CCCCCC">null the colonel thinks we're dealing</font>

620
00:24:54,570 --> 00:24:58,710
with<font color="#E5E5E5"> a native 64-bit process otherwise</font>

621
00:24:56,639 --> 00:25:01,678
<font color="#E5E5E5">the</font><font color="#CCCCCC"> governor assumes we are</font><font color="#E5E5E5"> dealing with</font>

622
00:24:58,710 --> 00:25:04,649
<font color="#CCCCCC">while sixty-four process</font><font color="#E5E5E5"> so with that in</font>

623
00:25:01,679 --> 00:25:06,899
<font color="#CCCCCC">mind we came to some sort of decom based</font>

624
00:25:04,649 --> 00:25:09,090
solution<font color="#E5E5E5"> a directed kernel object</font>

625
00:25:06,899 --> 00:25:10,559
manipulation solution in which right

626
00:25:09,090 --> 00:25:12,629
before we allocate memory<font color="#CCCCCC"> for our</font>

627
00:25:10,559 --> 00:25:15,330
<font color="#E5E5E5">adapter</font><font color="#CCCCCC"> fun</font><font color="#E5E5E5"> we simply go up to the</font><font color="#CCCCCC"> a</font>

628
00:25:12,629 --> 00:25:18,509
<font color="#CCCCCC">process structure</font><font color="#E5E5E5"> reach this specific</font>

629
00:25:15,330 --> 00:25:20,730
member and<font color="#CCCCCC"> just zero it out or nullify</font>

630
00:25:18,509 --> 00:25:22,529
<font color="#CCCCCC">it and this</font><font color="#E5E5E5"> will basically trick a my</font>

631
00:25:20,730 --> 00:25:25,049
<font color="#E5E5E5">selective</font><font color="#CCCCCC"> g-- bitmap</font><font color="#E5E5E5"> into thinking that</font>

632
00:25:22,529 --> 00:25:27,450
<font color="#E5E5E5">we are</font><font color="#CCCCCC"> allocating executable memory in</font>

633
00:25:25,049 --> 00:25:29,429
the context of<font color="#E5E5E5"> a native 64-bit process</font>

634
00:25:27,450 --> 00:25:31,980
and thus our<font color="#E5E5E5"> adapter fund will</font><font color="#CCCCCC"> be marked</font>

635
00:25:29,429 --> 00:25:34,320
as a valid<font color="#E5E5E5"> call target in the native CFG</font>

636
00:25:31,980 --> 00:25:35,999
bitmap of<font color="#CCCCCC"> course that after</font><font color="#E5E5E5"> memory for</font>

637
00:25:34,320 --> 00:25:37,889
the adapter<font color="#CCCCCC"> funk has</font><font color="#E5E5E5"> been allocated we</font>

638
00:25:35,999 --> 00:25:39,720
should restore<font color="#E5E5E5"> the</font><font color="#CCCCCC"> original value</font><font color="#E5E5E5"> of</font>

639
00:25:37,889 --> 00:25:43,139
this pointer otherwise bad things might

640
00:25:39,720 --> 00:25:45,570
<font color="#CCCCCC">happen and so to</font><font color="#E5E5E5"> summarize this option</font>

641
00:25:43,139 --> 00:25:48,570
basically<font color="#E5E5E5"> walks by temporarily native</font>

642
00:25:45,570 --> 00:25:50,428
<font color="#CCCCCC">izing about 64 process and while it does</font>

643
00:25:48,570 --> 00:25:52,649
do the trick it suffers from<font color="#E5E5E5"> some</font>

644
00:25:50,429 --> 00:25:54,029
<font color="#E5E5E5">serious downsides and mainly because the</font>

645
00:25:52,649 --> 00:25:56,789
it was a<font color="#E5E5E5"> structure that has to be</font>

646
00:25:54,029 --> 00:25:58,619
<font color="#E5E5E5">modified is largely undocumented and</font>

647
00:25:56,789 --> 00:26:01,830
changes often<font color="#E5E5E5"> between</font><font color="#CCCCCC"> Windows releases</font>

648
00:25:58,619 --> 00:26:03,509
so this makes the offset of the member

649
00:26:01,830 --> 00:26:06,840
we wish to modify from<font color="#E5E5E5"> the beginning of</font>

650
00:26:03,509 --> 00:26:10,679
the structure<font color="#CCCCCC"> to</font><font color="#E5E5E5"> be inconsistent</font><font color="#CCCCCC"> so we</font>

651
00:26:06,840 --> 00:26:13,740
can put<font color="#CCCCCC"> a tie on</font><font color="#E5E5E5"> it</font><font color="#CCCCCC"> and this</font><font color="#E5E5E5"> is the some</font>

652
00:26:10,679 --> 00:26:16,200
<font color="#E5E5E5">sort of solution which tends to break</font>

653
00:26:13,740 --> 00:26:18,929
<font color="#E5E5E5">all the time and so taking all</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> these</font>

654
00:26:16,200 --> 00:26:20,340
down<font color="#CCCCCC"> so it's</font><font color="#E5E5E5"> into consideration we</font>

655
00:26:18,929 --> 00:26:22,080
decided<font color="#CCCCCC"> to look for an alternative</font>

656
00:26:20,340 --> 00:26:23,668
solution hopefully one which<font color="#E5E5E5"> doesn't</font>

657
00:26:22,080 --> 00:26:27,600
require making<font color="#E5E5E5"> modifications to</font>

658
00:26:23,669 --> 00:26:29,759
undocumented kernel structures<font color="#E5E5E5"> so at</font>

659
00:26:27,600 --> 00:26:31,469
this point we decided<font color="#E5E5E5"> to like mentally</font>

660
00:26:29,759 --> 00:26:34,080
zoom out and really rethink about<font color="#E5E5E5"> our</font>

661
00:26:31,470 --> 00:26:37,799
problem in the first<font color="#E5E5E5"> place</font><font color="#CCCCCC"> so to wake up</font>

662
00:26:34,080 --> 00:26:40,918
so far we have a PC injector<font color="#E5E5E5"> which works</font>

663
00:26:37,799 --> 00:26:43,139
by allocating<font color="#CCCCCC"> and</font><font color="#E5E5E5"> adaptive func and the</font>

664
00:26:40,919 --> 00:26:46,379
problem is caused by the second<font color="#CCCCCC"> at our</font>

665
00:26:43,139 --> 00:26:47,639
adapter func is marked in the<font color="#CCCCCC"> valve 64</font>

666
00:26:46,379 --> 00:26:49,289
CFG bitmap

667
00:26:47,639 --> 00:26:49,840
but if you<font color="#E5E5E5"> recall the only reason we</font>

668
00:26:49,289 --> 00:26:52,658
<font color="#E5E5E5">have an adopt</font>

669
00:26:49,840 --> 00:26:54,580
<font color="#E5E5E5">funk to begin with is to basically just</font>

670
00:26:52,659 --> 00:26:57,340
act<font color="#E5E5E5"> as a</font><font color="#CCCCCC"> middleman which just</font><font color="#E5E5E5"> followed</font>

671
00:26:54,580 --> 00:27:00,490
<font color="#E5E5E5">the calls to the 64-bit</font><font color="#CCCCCC"> version of El</font>

672
00:26:57,340 --> 00:27:02,918
<font color="#CCCCCC">Diablo</font><font color="#E5E5E5"> dealer in India and the 64-bit</font>

673
00:27:00,490 --> 00:27:06,190
version<font color="#CCCCCC"> of El Diablo dll</font><font color="#E5E5E5"> is obviously</font>

674
00:27:02,919 --> 00:27:08,260
marked in the native<font color="#CCCCCC"> the CFG</font><font color="#E5E5E5"> bitmap so</font>

675
00:27:06,190 --> 00:27:10,150
this made us wonder why do we really

676
00:27:08,260 --> 00:27:12,279
need an<font color="#CCCCCC"> adaptive funk in the first place</font>

677
00:27:10,150 --> 00:27:13,750
so to put<font color="#CCCCCC"> it in other</font><font color="#E5E5E5"> words why can't we</font>

678
00:27:12,279 --> 00:27:15,820
just initialize our<font color="#E5E5E5"> APC</font>

679
00:27:13,750 --> 00:27:19,330
to point directly<font color="#E5E5E5"> to the 64-bit version</font>

680
00:27:15,820 --> 00:27:21,220
<font color="#CCCCCC">of El Diablo the other okay so on the</font>

681
00:27:19,330 --> 00:27:23,799
surface<font color="#E5E5E5"> of it it looks like we have some</font>

682
00:27:21,220 --> 00:27:25,960
sort<font color="#CCCCCC"> of a problem</font><font color="#E5E5E5"> on the right hand side</font>

683
00:27:23,799 --> 00:27:27,940
we can<font color="#E5E5E5"> see the function</font><font color="#CCCCCC"> prototype which</font>

684
00:27:25,960 --> 00:27:29,260
is shared by all<font color="#E5E5E5"> user mode a PC audience</font>

685
00:27:27,940 --> 00:27:31,750
<font color="#CCCCCC">we've seen this one</font><font color="#E5E5E5"> before</font>

686
00:27:29,260 --> 00:27:34,270
and like we've said all of<font color="#E5E5E5"> these</font>

687
00:27:31,750 --> 00:27:36,399
<font color="#CCCCCC">functions</font><font color="#E5E5E5"> receive</font><font color="#CCCCCC"> three pointers us</font>

688
00:27:34,270 --> 00:27:37,570
their input arguments<font color="#E5E5E5"> and on the left</font>

689
00:27:36,399 --> 00:27:41,189
hand<font color="#E5E5E5"> side we can see the function</font>

690
00:27:37,570 --> 00:27:45,010
<font color="#CCCCCC">prototype</font><font color="#E5E5E5"> of LDL LDL and it happens to</font>

691
00:27:41,190 --> 00:27:46,419
accept<font color="#E5E5E5"> four arguments so at the</font><font color="#CCCCCC"> very</font>

692
00:27:45,010 --> 00:27:50,220
<font color="#E5E5E5">least we have</font><font color="#CCCCCC"> here some sort of a</font>

693
00:27:46,419 --> 00:27:53,500
<font color="#CCCCCC">function prototype</font><font color="#E5E5E5"> inconsistency issue</font>

694
00:27:50,220 --> 00:27:56,980
so does this mean we have<font color="#E5E5E5"> to give up on</font>

695
00:27:53,500 --> 00:27:59,649
this<font color="#CCCCCC"> idea and not yet and what might</font>

696
00:27:56,980 --> 00:28:02,649
actually<font color="#CCCCCC"> walk in our favor is the x64</font>

697
00:27:59,649 --> 00:28:05,289
calling convention so like some of you

698
00:28:02,649 --> 00:28:07,059
might know<font color="#CCCCCC"> already in X 64</font><font color="#E5E5E5"> almost every</font>

699
00:28:05,289 --> 00:28:09,490
<font color="#CCCCCC">function receives</font><font color="#E5E5E5"> these first four</font>

700
00:28:07,059 --> 00:28:12,340
<font color="#CCCCCC">arguments</font><font color="#E5E5E5"> we are registers the first</font>

701
00:28:09,490 --> 00:28:14,860
parameter<font color="#E5E5E5"> is best in</font><font color="#CCCCCC"> the al6</font><font color="#E5E5E5"> register</font>

702
00:28:12,340 --> 00:28:18,879
the second one in<font color="#CCCCCC"> al</font><font color="#E5E5E5"> DX the failed in</font><font color="#CCCCCC"> r8</font>

703
00:28:14,860 --> 00:28:20,918
and the fourth one in our<font color="#CCCCCC"> nine now if we</font>

704
00:28:18,880 --> 00:28:23,649
initialize<font color="#E5E5E5"> our APC to point directly to</font>

705
00:28:20,919 --> 00:28:25,240
<font color="#E5E5E5">a yellow dll we will have direct control</font>

706
00:28:23,649 --> 00:28:27,489
<font color="#CCCCCC">over</font><font color="#E5E5E5"> the values of the first three</font>

707
00:28:25,240 --> 00:28:29,470
parameters but<font color="#E5E5E5"> unfortunately we won't</font>

708
00:28:27,490 --> 00:28:32,230
have any control<font color="#CCCCCC"> over the value of the</font>

709
00:28:29,470 --> 00:28:34,690
<font color="#CCCCCC">last the fourth parameter and what will</font>

710
00:28:32,230 --> 00:28:36,820
happen<font color="#CCCCCC"> is that</font><font color="#E5E5E5"> by the time LDL or</font><font color="#CCCCCC"> dll</font>

711
00:28:34,690 --> 00:28:38,679
will be called<font color="#E5E5E5"> whatever value happens to</font>

712
00:28:36,820 --> 00:28:40,750
be loaded into our<font color="#CCCCCC"> nine will be</font>

713
00:28:38,679 --> 00:28:44,830
<font color="#E5E5E5">interpreted as</font><font color="#CCCCCC"> the fourth</font><font color="#E5E5E5"> so-called</font>

714
00:28:40,750 --> 00:28:46,450
missing parameter okay so now let's take

715
00:28:44,830 --> 00:28:49,120
a closer look<font color="#E5E5E5"> at El Diablo DLL and</font>

716
00:28:46,450 --> 00:28:50,679
<font color="#E5E5E5">specifically at its fourth parameter</font><font color="#CCCCCC"> so</font>

717
00:28:49,120 --> 00:28:52,899
as you can<font color="#E5E5E5"> see here the fourth parameter</font>

718
00:28:50,679 --> 00:28:55,570
is actually<font color="#E5E5E5"> annotated as an output</font>

719
00:28:52,899 --> 00:28:57,820
parameter<font color="#CCCCCC"> and it's basically a point out</font>

720
00:28:55,570 --> 00:29:00,100
which the function<font color="#E5E5E5"> is</font><font color="#CCCCCC"> going to</font><font color="#E5E5E5"> write the</font>

721
00:28:57,820 --> 00:29:02,620
base address<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the DLL that it has just</font>

722
00:29:00,100 --> 00:29:03,299
<font color="#E5E5E5">loaded so this kind of</font><font color="#CCCCCC"> makes things</font><font color="#E5E5E5"> a</font>

723
00:29:02,620 --> 00:29:05,129
little<font color="#E5E5E5"> bit more</font>

724
00:29:03,299 --> 00:29:06,960
implicated because<font color="#E5E5E5"> it means not any</font>

725
00:29:05,129 --> 00:29:09,299
value loaded into our<font color="#E5E5E5"> nine will suit our</font>

726
00:29:06,960 --> 00:29:11,970
<font color="#E5E5E5">needs and more specifically it</font><font color="#CCCCCC"> means</font>

727
00:29:09,299 --> 00:29:14,158
this it means<font color="#E5E5E5"> that our nine has to be a</font>

728
00:29:11,970 --> 00:29:16,559
pointer<font color="#E5E5E5"> to a</font><font color="#CCCCCC"> writable memory block</font><font color="#E5E5E5"> and</font>

729
00:29:14,159 --> 00:29:18,419
no<font color="#E5E5E5"> other this memory block has</font><font color="#CCCCCC"> to be</font>

730
00:29:16,559 --> 00:29:20,129
some<font color="#E5E5E5"> sort of some</font><font color="#CCCCCC"> sort of scratch space</font>

731
00:29:18,419 --> 00:29:22,080
<font color="#E5E5E5">because we cannot</font><font color="#CCCCCC"> overwrite important</font>

732
00:29:20,129 --> 00:29:25,738
information in the process<font color="#CCCCCC"> without</font>

733
00:29:22,080 --> 00:29:27,809
risking in crashing so now the

734
00:29:25,739 --> 00:29:29,730
<font color="#E5E5E5">million-dollar</font><font color="#CCCCCC"> question is what value</font>

735
00:29:27,809 --> 00:29:30,809
<font color="#E5E5E5">will be held by our nine by the time LDL</font>

736
00:29:29,730 --> 00:29:32,789
or<font color="#CCCCCC"> dll gets</font><font color="#E5E5E5"> called</font>

737
00:29:30,809 --> 00:29:34,440
so in order<font color="#E5E5E5"> to answer this</font><font color="#CCCCCC"> question we</font>

738
00:29:32,789 --> 00:29:37,080
<font color="#E5E5E5">have</font><font color="#CCCCCC"> to perform some reverse engineering</font>

739
00:29:34,440 --> 00:29:39,210
<font color="#E5E5E5">1k with</font><font color="#CCCCCC"> the APC dispatcher</font><font color="#E5E5E5"> and after</font>

740
00:29:37,080 --> 00:29:41,428
<font color="#E5E5E5">somewhere else in what we found out is</font>

741
00:29:39,210 --> 00:29:43,409
<font color="#CCCCCC">that right before ki PC</font><font color="#E5E5E5"> dispatcher</font>

742
00:29:41,429 --> 00:29:46,019
forward the call to the target of the

743
00:29:43,409 --> 00:29:48,119
APC which in our case is a yellow<font color="#E5E5E5"> DRL it</font>

744
00:29:46,019 --> 00:29:51,299
is going to load our nine with something

745
00:29:48,119 --> 00:29:53,820
with a<font color="#E5E5E5"> pointer to something called a</font>

746
00:29:51,299 --> 00:29:56,519
context<font color="#E5E5E5"> our job this context doctor</font>

747
00:29:53,820 --> 00:29:58,649
<font color="#CCCCCC">basically encapsulates the cpu state</font>

748
00:29:56,519 --> 00:30:01,649
that is about<font color="#E5E5E5"> to be resumed the other</font>

749
00:29:58,649 --> 00:30:04,320
call to<font color="#CCCCCC"> anti continue you can</font><font color="#E5E5E5"> see here</font>

750
00:30:01,649 --> 00:30:08,158
once the APC dispatching process has

751
00:30:04,320 --> 00:30:10,439
<font color="#CCCCCC">finished now because we know LDL</font><font color="#E5E5E5"> low</font>

752
00:30:08,159 --> 00:30:12,629
<font color="#CCCCCC">darrell is going to interpret</font><font color="#E5E5E5"> our nine</font>

753
00:30:10,440 --> 00:30:14,460
<font color="#CCCCCC">assets for parameter it basically means</font>

754
00:30:12,629 --> 00:30:16,980
it means it<font color="#E5E5E5"> is going to over like the</font>

755
00:30:14,460 --> 00:30:19,440
first few few<font color="#E5E5E5"> bytes of this structure</font>

756
00:30:16,980 --> 00:30:21,359
with<font color="#CCCCCC"> the base</font><font color="#E5E5E5"> address of the DLL that it</font>

757
00:30:19,440 --> 00:30:22,799
has just loaded so generally this

758
00:30:21,359 --> 00:30:25,320
doesn't sound<font color="#E5E5E5"> like</font><font color="#CCCCCC"> a very good idea</font>

759
00:30:22,799 --> 00:30:27,989
<font color="#CCCCCC">because</font><font color="#E5E5E5"> we are overwriting CPU</font>

760
00:30:25,320 --> 00:30:30,570
information<font color="#E5E5E5"> that is about to be resumed</font>

761
00:30:27,989 --> 00:30:33,359
later and but luckily<font color="#E5E5E5"> for us what</font>

762
00:30:30,570 --> 00:30:35,639
happens at least<font color="#E5E5E5"> on the</font><font color="#CCCCCC"> x66 x64</font>

763
00:30:33,359 --> 00:30:38,249
<font color="#CCCCCC">architecture is</font><font color="#E5E5E5"> that the first few</font>

764
00:30:35,639 --> 00:30:39,869
members<font color="#E5E5E5"> of</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> context structure don't</font>

765
00:30:38,249 --> 00:30:42,330
really hold members which are<font color="#CCCCCC"> cpu</font>

766
00:30:39,869 --> 00:30:44,488
related so we can<font color="#CCCCCC"> overwrite</font><font color="#E5E5E5"> them safely</font>

767
00:30:42,330 --> 00:30:46,168
because<font color="#E5E5E5"> we know they want to be</font><font color="#CCCCCC"> used</font>

768
00:30:44,489 --> 00:30:48,690
<font color="#E5E5E5">later by</font><font color="#CCCCCC"> an to continue to actually</font>

769
00:30:46,169 --> 00:30:50,429
<font color="#CCCCCC">restore the context so to summarize what</font>

770
00:30:48,690 --> 00:30:52,590
we found out is<font color="#CCCCCC"> that we can get rid of</font>

771
00:30:50,429 --> 00:30:55,679
<font color="#E5E5E5">the adapter</font><font color="#CCCCCC"> func entirely and instead</font>

772
00:30:52,590 --> 00:30:58,350
just<font color="#E5E5E5"> initialize our IPC 2.2 l diallo</font><font color="#CCCCCC"> dll</font>

773
00:30:55,679 --> 00:31:00,330
and so we have<font color="#E5E5E5"> modified our injector</font>

774
00:30:58,350 --> 00:31:02,399
<font color="#E5E5E5">accordingly compiled it into a driver</font>

775
00:31:00,330 --> 00:31:04,949
<font color="#E5E5E5">loaded it this time into a Windows 10</font>

776
00:31:02,399 --> 00:31:08,879
machine and as you can<font color="#CCCCCC"> see we indeed</font>

777
00:31:04,950 --> 00:31:12,710
managed to inject<font color="#E5E5E5"> our 64 bit DLL to a 32</font>

778
00:31:08,879 --> 00:31:12,709
bit process which is<font color="#CCCCCC"> CFG al</font>

779
00:31:15,700 --> 00:31:20,510
have a working<font color="#CCCCCC"> action method</font><font color="#E5E5E5"> or more</font>

780
00:31:18,890 --> 00:31:23,210
like three a<font color="#E5E5E5"> couple of them even work on</font>

781
00:31:20,510 --> 00:31:24,890
<font color="#E5E5E5">Windows 10 we can move on</font><font color="#CCCCCC"> to a second</font>

782
00:31:23,210 --> 00:31:27,890
part<font color="#E5E5E5"> of this project which is the</font>

783
00:31:24,890 --> 00:31:30,529
hooking we<font color="#E5E5E5"> stir this project by wanting</font>

784
00:31:27,890 --> 00:31:33,140
to hook 64-bit<font color="#E5E5E5"> API functions inside of</font>

785
00:31:30,529 --> 00:31:35,559
<font color="#E5E5E5">what 64 processes so for that we need</font><font color="#CCCCCC"> a</font>

786
00:31:33,140 --> 00:31:39,289
hook<font color="#CCCCCC"> an engine capable</font><font color="#E5E5E5"> of doing that</font>

787
00:31:35,559 --> 00:31:41,480
hooking method which is very<font color="#CCCCCC"> common in</font>

788
00:31:39,289 --> 00:31:44,870
<font color="#CCCCCC">hooking engines and also the one we used</font>

789
00:31:41,480 --> 00:31:47,840
here<font color="#E5E5E5"> is called inline hooks this method</font>

790
00:31:44,870 --> 00:31:49,850
works by<font color="#CCCCCC"> overriding the first few</font>

791
00:31:47,840 --> 00:31:52,100
instructions<font color="#E5E5E5"> of the hooks function and</font>

792
00:31:49,850 --> 00:31:54,918
replacing<font color="#E5E5E5"> them</font><font color="#CCCCCC"> with a jump instruction</font>

793
00:31:52,100 --> 00:31:56,899
<font color="#E5E5E5">to a memory buffer we allocate inside</font>

794
00:31:54,919 --> 00:31:59,450
the process<font color="#E5E5E5"> called trampoline this</font>

795
00:31:56,899 --> 00:32:02,000
trampoline<font color="#E5E5E5"> just forwards a call to our</font>

796
00:31:59,450 --> 00:32:04,220
<font color="#CCCCCC">deterrent function found in</font><font color="#E5E5E5"> the DLL we</font>

797
00:32:02,000 --> 00:32:05,840
<font color="#E5E5E5">have just injected our detail function</font>

798
00:32:04,220 --> 00:32:08,960
can basically run whatever code we<font color="#E5E5E5"> want</font>

799
00:32:05,840 --> 00:32:11,678
<font color="#CCCCCC">it to</font><font color="#E5E5E5"> either before or after eventually</font>

800
00:32:08,960 --> 00:32:13,730
calling back into the original function

801
00:32:11,679 --> 00:32:16,340
<font color="#E5E5E5">when we call back into the original</font>

802
00:32:13,730 --> 00:32:18,649
<font color="#CCCCCC">function we</font><font color="#E5E5E5"> first have</font><font color="#CCCCCC"> to call in to the</font>

803
00:32:16,340 --> 00:32:21,020
<font color="#E5E5E5">trampoline</font><font color="#CCCCCC"> in order</font><font color="#E5E5E5"> to run the missing</font>

804
00:32:18,649 --> 00:32:23,299
instructions that we wrote over<font color="#CCCCCC"> in our</font>

805
00:32:21,020 --> 00:32:26,029
hoped function then we jump<font color="#CCCCCC"> back into</font>

806
00:32:23,299 --> 00:32:28,879
the<font color="#E5E5E5"> sock function to allow it to resume</font>

807
00:32:26,029 --> 00:32:30,140
its normal execution<font color="#E5E5E5"> there are lots of</font>

808
00:32:28,880 --> 00:32:32,419
hooking engines that<font color="#E5E5E5"> implementation</font>

809
00:32:30,140 --> 00:32:33,169
technique but unfortunately while doing

810
00:32:32,419 --> 00:32:35,419
this research

811
00:32:33,169 --> 00:32:38,480
none of the hook images we inspected was

812
00:32:35,419 --> 00:32:40,820
<font color="#CCCCCC">capable</font><font color="#E5E5E5"> of running inside</font><font color="#CCCCCC"> of while 64</font>

813
00:32:38,480 --> 00:32:42,980
process or running as a<font color="#CCCCCC"> 64 bit token</font>

814
00:32:40,820 --> 00:32:46,908
engine inside<font color="#E5E5E5"> of such processes but</font>

815
00:32:42,980 --> 00:32:50,779
what's the<font color="#E5E5E5"> problem well anybody who</font>

816
00:32:46,909 --> 00:32:53,029
wrote code for<font color="#E5E5E5"> Windows might know a few</font>

817
00:32:50,779 --> 00:32:57,140
basic the lsah to implement most of the

818
00:32:53,029 --> 00:32:59,779
win32<font color="#E5E5E5"> api this</font><font color="#CCCCCC"> DLL</font><font color="#E5E5E5"> czar stuff like</font>

819
00:32:57,140 --> 00:33:02,720
kernel<font color="#E5E5E5"> based on 32 C runtime libraries</font>

820
00:32:59,779 --> 00:33:04,820
<font color="#CCCCCC">they're very</font><font color="#E5E5E5"> basic whenever when writing</font>

821
00:33:02,720 --> 00:33:08,090
code windows and all<font color="#CCCCCC"> cooking</font><font color="#E5E5E5"> engines we</font>

822
00:33:04,820 --> 00:33:09,320
looked at use them but the<font color="#CCCCCC"> 64-bit</font>

823
00:33:08,090 --> 00:33:12,320
versions of<font color="#E5E5E5"> this dll's</font>

824
00:33:09,320 --> 00:33:14,059
are simply<font color="#E5E5E5"> not loaded into while 64</font>

825
00:33:12,320 --> 00:33:15,649
processes and because<font color="#CCCCCC"> of some</font><font color="#E5E5E5"> technical</font>

826
00:33:14,059 --> 00:33:18,950
issues we generally can't load them in

827
00:33:15,649 --> 00:33:21,139
either<font color="#E5E5E5"> so the first thing we had to do</font>

828
00:33:18,950 --> 00:33:23,870
when modifying<font color="#E5E5E5"> our</font><font color="#CCCCCC"> Hawken engine</font><font color="#E5E5E5"> we</font>

829
00:33:21,140 --> 00:33:26,870
chose an existing one to modify was to

830
00:33:23,870 --> 00:33:27,709
get rid<font color="#CCCCCC"> of all of these of</font><font color="#E5E5E5"> these</font>

831
00:33:26,870 --> 00:33:31,370
dependencies

832
00:33:27,710 --> 00:33:33,919
the only<font color="#CCCCCC"> dll we could rely on was the</font>

833
00:33:31,370 --> 00:33:37,158
<font color="#E5E5E5">native ntdll which we knew was</font><font color="#CCCCCC"> always</font>

834
00:33:33,919 --> 00:33:39,320
<font color="#E5E5E5">loaded into of 64 processes so we had to</font>

835
00:33:37,159 --> 00:33:42,679
get rid<font color="#CCCCCC"> of all external dependencies</font>

836
00:33:39,320 --> 00:33:44,000
other than the native ntdll the major

837
00:33:42,679 --> 00:33:47,419
thing we<font color="#E5E5E5"> had</font><font color="#CCCCCC"> to do there</font><font color="#E5E5E5"> was</font>

838
00:33:44,000 --> 00:33:49,640
reimplemented<font color="#CCCCCC"> all win32 api</font><font color="#E5E5E5"> is that were</font>

839
00:33:47,419 --> 00:33:51,770
used by<font color="#CCCCCC"> our open engine for</font><font color="#E5E5E5"> example here</font>

840
00:33:49,640 --> 00:33:53,480
we<font color="#CCCCCC"> have our implementation of virtual</font>

841
00:33:51,770 --> 00:33:57,799
<font color="#CCCCCC">protec the function exported from</font>

842
00:33:53,480 --> 00:34:00,500
<font color="#E5E5E5">kernel32 in this example you</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> see our</font>

843
00:33:57,799 --> 00:34:02,899
implementation<font color="#E5E5E5"> of this is basically</font><font color="#CCCCCC"> just</font>

844
00:34:00,500 --> 00:34:05,809
a forwarder<font color="#E5E5E5"> to empty protect virtual</font>

845
00:34:02,899 --> 00:34:09,080
memory exported from ntdll<font color="#E5E5E5"> so it can</font><font color="#CCCCCC"> use</font>

846
00:34:05,809 --> 00:34:11,029
it most of our implementations<font color="#CCCCCC"> looked</font>

847
00:34:09,080 --> 00:34:13,520
something<font color="#CCCCCC"> like this so they were pretty</font>

848
00:34:11,030 --> 00:34:15,859
<font color="#E5E5E5">easy to achieve</font><font color="#CCCCCC"> a few were a bit more</font>

849
00:34:13,520 --> 00:34:18,080
complicated<font color="#E5E5E5"> and then we had either to</font>

850
00:34:15,859 --> 00:34:20,210
<font color="#CCCCCC">reverse engineer the missing functions</font>

851
00:34:18,080 --> 00:34:23,179
or go to the reactor<font color="#E5E5E5"> sources and do</font>

852
00:34:20,210 --> 00:34:26,149
whatever they did after we implemented

853
00:34:23,179 --> 00:34:30,349
all win32<font color="#E5E5E5"> api is in the hooking engine</font>

854
00:34:26,149 --> 00:34:32,540
we try to recompile<font color="#E5E5E5"> our</font><font color="#CCCCCC"> DLL with the</font>

855
00:34:30,349 --> 00:34:33,169
hooking engine and got this great list

856
00:34:32,540 --> 00:34:35,509
<font color="#E5E5E5">of errors</font>

857
00:34:33,168 --> 00:34:37,609
this looks pretty threatening at least

858
00:34:35,510 --> 00:34:41,119
it looked like that<font color="#CCCCCC"> to</font><font color="#E5E5E5"> us but actually</font>

859
00:34:37,609 --> 00:34:42,949
most<font color="#E5E5E5"> of these are just errors requiring</font>

860
00:34:41,119 --> 00:34:45,109
slight configuration changes like

861
00:34:42,949 --> 00:34:47,418
<font color="#CCCCCC">disabling some checks</font><font color="#E5E5E5"> that use AC</font>

862
00:34:45,109 --> 00:34:50,629
runtime libraries which we don't<font color="#E5E5E5"> have so</font>

863
00:34:47,418 --> 00:34:53,509
this<font color="#CCCCCC"> is all</font><font color="#E5E5E5"> very</font><font color="#CCCCCC"> technical and</font><font color="#E5E5E5"> honestly</font>

864
00:34:50,629 --> 00:34:56,330
not super interesting so<font color="#E5E5E5"> I'm not going</font>

865
00:34:53,510 --> 00:34:58,880
<font color="#CCCCCC">to</font><font color="#E5E5E5"> go into too much detail here hey</font>

866
00:34:56,330 --> 00:35:00,890
after<font color="#CCCCCC"> we</font><font color="#E5E5E5"> made all the configuration</font>

867
00:34:58,880 --> 00:35:03,830
changes required to fix<font color="#E5E5E5"> that we</font>

868
00:35:00,890 --> 00:35:07,310
recompile or<font color="#E5E5E5"> DLL and actually managed to</font>

869
00:35:03,830 --> 00:35:09,560
a<font color="#CCCCCC"> compile</font><font color="#E5E5E5"> a 64-bit DLL which includes</font>

870
00:35:07,310 --> 00:35:13,609
<font color="#CCCCCC">our work</font><font color="#E5E5E5"> in</font><font color="#CCCCCC"> hooking engine that</font><font color="#E5E5E5"> only</font>

871
00:35:09,560 --> 00:35:16,430
relies on<font color="#E5E5E5"> the</font><font color="#CCCCCC"> 64 bit ntdll</font><font color="#E5E5E5"> so we</font>

872
00:35:13,609 --> 00:35:18,680
injected this<font color="#E5E5E5"> DLL into our 64 process on</font>

873
00:35:16,430 --> 00:35:21,020
Windows<font color="#CCCCCC"> 7 and</font><font color="#E5E5E5"> saw that we can</font>

874
00:35:18,680 --> 00:35:24,080
successfully hook<font color="#E5E5E5"> any API functions we</font>

875
00:35:21,020 --> 00:35:26,300
wanted in the<font color="#E5E5E5"> 64 bit NT data then we</font>

876
00:35:24,080 --> 00:35:30,140
tried it on<font color="#E5E5E5"> Windows 10 and then it</font>

877
00:35:26,300 --> 00:35:33,050
<font color="#E5E5E5">didn't</font><font color="#CCCCCC"> do so great so what happened here</font>

878
00:35:30,140 --> 00:35:35,450
<font color="#E5E5E5">well the memory layout in</font><font color="#CCCCCC"> woof 64</font>

879
00:35:33,050 --> 00:35:39,190
processes is<font color="#E5E5E5"> slightly different between</font>

880
00:35:35,450 --> 00:35:41,270
Windows 7 and Windows 10<font color="#CCCCCC"> machines</font>

881
00:35:39,190 --> 00:35:44,300
<font color="#CCCCCC">basically in Windows 7</font>

882
00:35:41,270 --> 00:35:47,060
all of the memory<font color="#CCCCCC"> above 4 gigabytes</font><font color="#E5E5E5"> is</font>

883
00:35:44,300 --> 00:35:49,790
reserved in<font color="#E5E5E5"> 164 processes so we</font><font color="#CCCCCC"> can't</font>

884
00:35:47,060 --> 00:35:51,620
allocate it we can't use<font color="#CCCCCC"> it and all</font><font color="#E5E5E5"> of</font>

885
00:35:49,790 --> 00:35:54,800
our<font color="#E5E5E5"> the</font><font color="#CCCCCC"> length of</font><font color="#E5E5E5"> our code is found</font>

886
00:35:51,620 --> 00:35:58,640
below 4 gigabytes<font color="#E5E5E5"> on Windows 10 that's</font>

887
00:35:54,800 --> 00:36:01,370
<font color="#E5E5E5">almost the case only the 64-bit ntdll</font>

888
00:35:58,640 --> 00:36:04,009
<font color="#E5E5E5">was moved above 4 gigabytes to a much</font>

889
00:36:01,370 --> 00:36:06,650
higher address but other<font color="#E5E5E5"> than the native</font>

890
00:36:04,010 --> 00:36:08,690
ntdll<font color="#E5E5E5"> and the native CFG bitmap found</font>

891
00:36:06,650 --> 00:36:11,030
right<font color="#E5E5E5"> next to it the rest of the memory</font>

892
00:36:08,690 --> 00:36:14,330
above above 4 gigabytes<font color="#E5E5E5"> is still</font>

893
00:36:11,030 --> 00:36:15,050
reserved<font color="#E5E5E5"> and we can't access</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> why is</font>

894
00:36:14,330 --> 00:36:18,110
that a<font color="#CCCCCC"> problem</font>

895
00:36:15,050 --> 00:36:19,550
<font color="#E5E5E5">well the jump</font><font color="#CCCCCC"> instruction that we use to</font>

896
00:36:18,110 --> 00:36:21,530
<font color="#E5E5E5">overwrite the prologue of the hook</font>

897
00:36:19,550 --> 00:36:23,720
function is actually<font color="#CCCCCC"> a relative jump</font>

898
00:36:21,530 --> 00:36:26,450
that receives a<font color="#CCCCCC"> 4 byte offset</font><font color="#E5E5E5"> what this</font>

899
00:36:23,720 --> 00:36:29,180
means is that this jump can only pass a

900
00:36:26,450 --> 00:36:31,609
distance of up<font color="#CCCCCC"> to</font><font color="#E5E5E5"> 2 gigabytes from our</font>

901
00:36:29,180 --> 00:36:34,310
hook<font color="#E5E5E5"> the API function to our trampoline</font>

902
00:36:31,610 --> 00:36:36,200
<font color="#E5E5E5">which we allocate ourselves in</font><font color="#CCCCCC"> Windows</font><font color="#E5E5E5"> 7</font>

903
00:36:34,310 --> 00:36:38,000
<font color="#E5E5E5">that's fine we can allocate</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> trampoline</font>

904
00:36:36,200 --> 00:36:40,100
right next to the native ntdll<font color="#CCCCCC"> and</font>

905
00:36:38,000 --> 00:36:42,710
usually have a distance of way less than

906
00:36:40,100 --> 00:36:44,990
<font color="#CCCCCC">2 GB bytes you</font><font color="#E5E5E5"> go through but in Windows</font>

907
00:36:42,710 --> 00:36:47,840
10 we can't allocate a trampoline next

908
00:36:44,990 --> 00:36:50,839
with native ntdll<font color="#E5E5E5"> it's loaded way about</font>

909
00:36:47,840 --> 00:36:53,390
the four gigabyte line and we can<font color="#CCCCCC"> only</font>

910
00:36:50,840 --> 00:36:55,880
<font color="#E5E5E5">allocate a trampoline below</font><font color="#CCCCCC"> 4 gigabytes</font>

911
00:36:53,390 --> 00:36:59,330
<font color="#E5E5E5">since the total address space in what in</font>

912
00:36:55,880 --> 00:37:01,850
64-bit<font color="#E5E5E5"> processes is 128 terabytes we're</font>

913
00:36:59,330 --> 00:37:04,400
likely to<font color="#E5E5E5"> have a distance of way more</font>

914
00:37:01,850 --> 00:37:06,110
than<font color="#CCCCCC"> two gigabytes to</font><font color="#E5E5E5"> cast so we're</font>

915
00:37:04,400 --> 00:37:07,910
<font color="#E5E5E5">going</font><font color="#CCCCCC"> to need</font><font color="#E5E5E5"> to replace or jump</font>

916
00:37:06,110 --> 00:37:10,040
instruction with an alternative form of

917
00:37:07,910 --> 00:37:12,920
jump<font color="#E5E5E5"> preferably one that allows us</font><font color="#CCCCCC"> to</font>

918
00:37:10,040 --> 00:37:19,370
<font color="#CCCCCC">pass a disc to jump into</font><font color="#E5E5E5"> an absolute</font>

919
00:37:12,920 --> 00:37:22,430
64-bit address<font color="#CCCCCC"> ok</font><font color="#E5E5E5"> so at this point we</font>

920
00:37:19,370 --> 00:37:24,770
<font color="#E5E5E5">compile a list of some branching</font>

921
00:37:22,430 --> 00:37:27,649
sequences which are valid<font color="#E5E5E5"> on the x64</font>

922
00:37:24,770 --> 00:37:29,120
platform so let's just go<font color="#CCCCCC"> over them one</font>

923
00:37:27,650 --> 00:37:31,400
<font color="#E5E5E5">by one and</font><font color="#CCCCCC"> see what might fit our</font>

924
00:37:29,120 --> 00:37:33,290
requirements and<font color="#E5E5E5"> what not</font><font color="#CCCCCC"> so the first</font>

925
00:37:31,400 --> 00:37:35,330
<font color="#CCCCCC">option you</font><font color="#E5E5E5"> can see here is</font><font color="#CCCCCC"> actually the</font>

926
00:37:33,290 --> 00:37:38,750
relative jump which<font color="#CCCCCC"> is already</font><font color="#E5E5E5"> in use</font><font color="#CCCCCC"> by</font>

927
00:37:35,330 --> 00:37:41,299
most hooking engines<font color="#E5E5E5"> and like</font><font color="#CCCCCC"> Hilden</font>

928
00:37:38,750 --> 00:37:43,250
said this form of jump<font color="#E5E5E5"> walks on a devote</font>

929
00:37:41,300 --> 00:37:45,230
<font color="#E5E5E5">sized operon meaning it can only pass a</font>

930
00:37:43,250 --> 00:37:47,780
distance of up<font color="#CCCCCC"> to 2 gigabytes in every</font>

931
00:37:45,230 --> 00:37:50,090
direction<font color="#CCCCCC"> and like she said</font><font color="#E5E5E5"> to Jigga</font>

932
00:37:47,780 --> 00:37:52,430
bytes or simply not<font color="#CCCCCC"> enough for our</font><font color="#E5E5E5"> case</font>

933
00:37:50,090 --> 00:37:53,840
so we had to discard this option<font color="#E5E5E5"> almost</font>

934
00:37:52,430 --> 00:37:57,020
immediately

935
00:37:53,840 --> 00:37:59,300
the next two<font color="#CCCCCC"> options</font><font color="#E5E5E5"> walk by loading a</font>

936
00:37:57,020 --> 00:38:01,490
<font color="#E5E5E5">register with a 64-bit absolute address</font>

937
00:37:59,300 --> 00:38:03,230
<font color="#CCCCCC">either by loading</font><font color="#E5E5E5"> it with an immediate</font>

938
00:38:01,490 --> 00:38:05,750
<font color="#CCCCCC">value or by a reference to a memory</font>

939
00:38:03,230 --> 00:38:07,370
<font color="#E5E5E5">location and then just blend it</font>

940
00:38:05,750 --> 00:38:09,680
<font color="#E5E5E5">branching to the address held by the</font>

941
00:38:07,370 --> 00:38:11,870
register<font color="#E5E5E5"> and while these two are both</font>

942
00:38:09,680 --> 00:38:13,819
perfectly<font color="#E5E5E5"> valid solutions they suffer</font>

943
00:38:11,870 --> 00:38:14,600
from<font color="#E5E5E5"> the</font><font color="#CCCCCC"> same problem they both dirty</font>

944
00:38:13,820 --> 00:38:16,100
<font color="#CCCCCC">apologies</font>

945
00:38:14,600 --> 00:38:18,440
which kind of makes<font color="#E5E5E5"> things a little bit</font>

946
00:38:16,100 --> 00:38:21,310
<font color="#CCCCCC">more complicated</font><font color="#E5E5E5"> for</font><font color="#CCCCCC"> us</font><font color="#E5E5E5"> because we later</font>

947
00:38:18,440 --> 00:38:24,020
have<font color="#E5E5E5"> to restore</font><font color="#CCCCCC"> the original</font><font color="#E5E5E5"> value of it</font>

948
00:38:21,310 --> 00:38:25,370
so at least<font color="#CCCCCC"> for the first</font><font color="#E5E5E5"> iteration</font><font color="#CCCCCC"> we</font>

949
00:38:24,020 --> 00:38:27,740
wanted to keep things<font color="#E5E5E5"> as</font><font color="#CCCCCC"> simple as</font>

950
00:38:25,370 --> 00:38:29,900
<font color="#E5E5E5">possible so</font><font color="#CCCCCC"> we had to give up on these</font>

951
00:38:27,740 --> 00:38:31,459
two as well<font color="#E5E5E5"> the fourth option is</font>

952
00:38:29,900 --> 00:38:33,920
<font color="#CCCCCC">actually quite interesting because it</font>

953
00:38:31,460 --> 00:38:35,600
doesn't<font color="#CCCCCC"> use the</font><font color="#E5E5E5"> jump instruction instead</font>

954
00:38:33,920 --> 00:38:38,930
it builds and others onto<font color="#CCCCCC"> the stack and</font>

955
00:38:35,600 --> 00:38:40,930
<font color="#CCCCCC">then just returns into</font><font color="#E5E5E5"> it again for the</font>

956
00:38:38,930 --> 00:38:43,790
first<font color="#E5E5E5"> iteration it seems a little bit</font>

957
00:38:40,930 --> 00:38:45,680
tricky so we decided<font color="#E5E5E5"> to put it aside and</font>

958
00:38:43,790 --> 00:38:48,500
<font color="#E5E5E5">a quick spoiler alert we will</font><font color="#CCCCCC"> probably</font>

959
00:38:45,680 --> 00:38:50,120
get<font color="#E5E5E5"> back into this later and so for the</font>

960
00:38:48,500 --> 00:38:52,310
first<font color="#CCCCCC"> iteration it basically</font><font color="#E5E5E5"> left us</font>

961
00:38:50,120 --> 00:38:55,250
with the fifth and final option<font color="#E5E5E5"> which</font>

962
00:38:52,310 --> 00:38:57,049
<font color="#E5E5E5">takes</font><font color="#CCCCCC"> advantage of an other</font><font color="#E5E5E5"> single</font><font color="#CCCCCC"> mode</font>

963
00:38:55,250 --> 00:39:00,680
called<font color="#E5E5E5"> a light</font><font color="#CCCCCC"> be relative</font><font color="#E5E5E5"> addressing</font>

964
00:38:57,050 --> 00:39:02,210
and it's basically just<font color="#E5E5E5"> jumps to the 64</font>

965
00:39:00,680 --> 00:39:04,040
bit absolute address which immediately

966
00:39:02,210 --> 00:39:06,680
follows the jump<font color="#CCCCCC"> instruction in memory</font>

967
00:39:04,040 --> 00:39:10,190
so we have<font color="#E5E5E5"> modified our hooking engine</font>

968
00:39:06,680 --> 00:39:12,200
to use<font color="#E5E5E5"> this kind of jump compiled it</font>

969
00:39:10,190 --> 00:39:14,750
<font color="#CCCCCC">bundled this entire thing into a DLL</font>

970
00:39:12,200 --> 00:39:17,859
injected it and this<font color="#E5E5E5"> time what we found</font>

971
00:39:14,750 --> 00:39:21,140
<font color="#E5E5E5">out is</font><font color="#CCCCCC"> that our hooking engine works</font>

972
00:39:17,860 --> 00:39:24,640
only<font color="#CCCCCC"> on a Windows 10 but not on earlier</font>

973
00:39:21,140 --> 00:39:28,609
<font color="#CCCCCC">versions of Windows so in order</font><font color="#E5E5E5"> to</font>

974
00:39:24,640 --> 00:39:31,700
investigate this thing and get a<font color="#E5E5E5"> good</font>

975
00:39:28,610 --> 00:39:34,400
cause analysis we<font color="#E5E5E5"> decided to take a copy</font>

976
00:39:31,700 --> 00:39:36,740
of<font color="#CCCCCC"> anti DLL from windows 7 for example</font><font color="#E5E5E5"> a</font>

977
00:39:34,400 --> 00:39:38,780
copy of anti DLL from<font color="#CCCCCC"> Windows 10</font><font color="#E5E5E5"> and</font>

978
00:39:36,740 --> 00:39:40,160
then do some sort of<font color="#E5E5E5"> the binary</font><font color="#CCCCCC"> D</font><font color="#E5E5E5"> thing</font>

979
00:39:38,780 --> 00:39:42,680
and just<font color="#CCCCCC"> see</font><font color="#E5E5E5"> if there is anything</font>

980
00:39:40,160 --> 00:39:45,410
<font color="#E5E5E5">suspicious which pops up and what we</font>

981
00:39:42,680 --> 00:39:47,359
found out is that<font color="#E5E5E5"> in Windows 7</font><font color="#CCCCCC"> for</font>

982
00:39:45,410 --> 00:39:49,640
example<font color="#E5E5E5"> all functions to which we wish</font>

983
00:39:47,360 --> 00:39:52,190
to apply<font color="#CCCCCC"> all hooks are significantly</font>

984
00:39:49,640 --> 00:39:55,700
shorter<font color="#CCCCCC"> than</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> windows 10 counterparts</font>

985
00:39:52,190 --> 00:39:58,280
so why<font color="#CCCCCC"> this problem</font><font color="#E5E5E5"> because the form of</font>

986
00:39:55,700 --> 00:40:00,799
jump that we have chosen this<font color="#CCCCCC"> one is</font>

987
00:39:58,280 --> 00:40:03,230
actually<font color="#E5E5E5"> quite long</font><font color="#CCCCCC"> it's binary</font><font color="#E5E5E5"> encoding</font>

988
00:40:00,800 --> 00:40:05,420
takes up something<font color="#CCCCCC"> like</font><font color="#E5E5E5"> 14 bytes if I</font>

989
00:40:03,230 --> 00:40:07,650
recall correctly<font color="#CCCCCC"> and in Windows 10</font><font color="#E5E5E5"> for</font>

990
00:40:05,420 --> 00:40:09,120
example<font color="#CCCCCC"> the functions are simply not</font>

991
00:40:07,650 --> 00:40:12,750
we don't have enough bytes in<font color="#E5E5E5"> the</font>

992
00:40:09,120 --> 00:40:13,859
function<font color="#E5E5E5"> to all the light so this is the</font>

993
00:40:12,750 --> 00:40:16,590
root cause<font color="#E5E5E5"> of the failure we have</font>

994
00:40:13,860 --> 00:40:18,210
<font color="#E5E5E5">encountered so this fellow kind of took</font>

995
00:40:16,590 --> 00:40:21,600
us back<font color="#E5E5E5"> took us back to</font><font color="#CCCCCC"> the drawing</font>

996
00:40:18,210 --> 00:40:23,520
board<font color="#CCCCCC"> and</font><font color="#E5E5E5"> we decided to give another try</font>

997
00:40:21,600 --> 00:40:25,529
<font color="#E5E5E5">to the fourth option the</font><font color="#CCCCCC"> one which works</font>

998
00:40:23,520 --> 00:40:27,840
by<font color="#CCCCCC"> building the others onto</font><font color="#E5E5E5"> the stack</font><font color="#CCCCCC"> so</font>

999
00:40:25,530 --> 00:40:29,670
<font color="#CCCCCC">as you can see here this option is</font>

1000
00:40:27,840 --> 00:40:32,280
actually<font color="#E5E5E5"> comprised out of three</font>

1001
00:40:29,670 --> 00:40:34,470
different instructions we first have<font color="#CCCCCC"> the</font>

1002
00:40:32,280 --> 00:40:37,200
push instruction which takes care of

1003
00:40:34,470 --> 00:40:39,720
setting up the<font color="#E5E5E5"> low</font><font color="#CCCCCC"> order the world</font><font color="#E5E5E5"> of a</font>

1004
00:40:37,200 --> 00:40:41,580
64-bit absolute address it is then

1005
00:40:39,720 --> 00:40:43,410
followed<font color="#E5E5E5"> by</font><font color="#CCCCCC"> this move instruction which</font>

1006
00:40:41,580 --> 00:40:46,049
sets up the high order<font color="#E5E5E5"> the abode of</font><font color="#CCCCCC"> the</font>

1007
00:40:43,410 --> 00:40:48,000
same address and then concludes with<font color="#E5E5E5"> a</font>

1008
00:40:46,050 --> 00:40:49,500
<font color="#E5E5E5">read instruction which just pops up an</font>

1009
00:40:48,000 --> 00:40:51,870
<font color="#CCCCCC">eight bytes value form the</font><font color="#E5E5E5"> stack and</font>

1010
00:40:49,500 --> 00:40:53,250
returns into<font color="#E5E5E5"> it so when it's in its</font>

1011
00:40:51,870 --> 00:40:55,259
current form<font color="#E5E5E5"> this sequence of</font>

1012
00:40:53,250 --> 00:40:56,790
instructions is again too long for<font color="#CCCCCC"> us I</font>

1013
00:40:55,260 --> 00:41:00,410
think<font color="#E5E5E5"> it's even longer it takes up</font>

1014
00:40:56,790 --> 00:41:02,820
<font color="#CCCCCC">sixteen</font><font color="#E5E5E5"> bytes if I recall correctly so</font>

1015
00:41:00,410 --> 00:41:05,520
<font color="#E5E5E5">in its current form it's not going to</font>

1016
00:41:02,820 --> 00:41:07,710
get<font color="#E5E5E5"> us anywhere but we started to</font>

1017
00:41:05,520 --> 00:41:09,810
thinking<font color="#CCCCCC"> how can</font><font color="#E5E5E5"> we optimize this</font>

1018
00:41:07,710 --> 00:41:16,920
solution<font color="#E5E5E5"> and after a little bit</font><font color="#CCCCCC"> of trial</font>

1019
00:41:09,810 --> 00:41:19,230
and<font color="#E5E5E5"> error we managed to understand</font><font color="#CCCCCC"> it we</font>

1020
00:41:16,920 --> 00:41:21,360
understand that we can<font color="#E5E5E5"> get rid of the</font>

1021
00:41:19,230 --> 00:41:23,460
move instruction entirely<font color="#E5E5E5"> and still be</font>

1022
00:41:21,360 --> 00:41:26,280
left with walking solution so let's

1023
00:41:23,460 --> 00:41:28,050
understand why this is<font color="#CCCCCC"> possible and so</font>

1024
00:41:26,280 --> 00:41:30,540
like we have<font color="#E5E5E5"> said several times during</font>

1025
00:41:28,050 --> 00:41:32,760
<font color="#E5E5E5">the course of this talk in</font><font color="#CCCCCC"> 164 processes</font>

1026
00:41:30,540 --> 00:41:34,980
we normally can't allocate<font color="#E5E5E5"> memory above</font>

1027
00:41:32,760 --> 00:41:37,470
the<font color="#CCCCCC"> four gigabyte boundary because that</font>

1028
00:41:34,980 --> 00:41:39,120
was<font color="#CCCCCC"> space</font><font color="#E5E5E5"> very simply reserved and now</font>

1029
00:41:37,470 --> 00:41:41,339
<font color="#E5E5E5">because the trampoline is itself a</font>

1030
00:41:39,120 --> 00:41:43,440
private memorial occasion<font color="#E5E5E5"> it will always</font>

1031
00:41:41,340 --> 00:41:45,840
<font color="#E5E5E5">be allocated below</font><font color="#CCCCCC"> that line and</font><font color="#E5E5E5"> that</font>

1032
00:41:43,440 --> 00:41:48,750
<font color="#CCCCCC">means that if we take for example and</font>

1033
00:41:45,840 --> 00:41:51,390
others of the<font color="#E5E5E5"> trampoline we can split it</font>

1034
00:41:48,750 --> 00:41:53,730
into two distinct<font color="#CCCCCC"> devotes where the low</font>

1035
00:41:51,390 --> 00:41:55,950
<font color="#CCCCCC">order the</font><font color="#E5E5E5"> world will hold some arbitrary</font>

1036
00:41:53,730 --> 00:41:58,410
value and the high order<font color="#E5E5E5"> the world will</font>

1037
00:41:55,950 --> 00:42:01,200
<font color="#CCCCCC">always be zeroed out and what works in</font>

1038
00:41:58,410 --> 00:42:03,480
<font color="#E5E5E5">our</font><font color="#CCCCCC"> favor in</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> case is just x64</font>

1039
00:42:01,200 --> 00:42:05,460
assembly because whenever I use the push

1040
00:42:03,480 --> 00:42:07,650
instruction to push a 32-bit immediate

1041
00:42:05,460 --> 00:42:09,330
value what will actually<font color="#E5E5E5"> happen is that</font>

1042
00:42:07,650 --> 00:42:11,370
the<font color="#E5E5E5"> CPU is</font><font color="#CCCCCC"> going to push</font>

1043
00:42:09,330 --> 00:42:13,140
64-bit value<font color="#E5E5E5"> onto the stack</font><font color="#CCCCCC"> because the</font>

1044
00:42:11,370 --> 00:42:15,870
<font color="#E5E5E5">stack always has to remain</font><font color="#CCCCCC"> eight</font><font color="#E5E5E5"> byte</font>

1045
00:42:13,140 --> 00:42:18,690
aligned<font color="#CCCCCC"> and the high</font><font color="#E5E5E5"> order</font><font color="#CCCCCC"> the odd is</font>

1046
00:42:15,870 --> 00:42:21,680
going<font color="#E5E5E5"> to be zeroed out by default and so</font>

1047
00:42:18,690 --> 00:42:23,970
<font color="#CCCCCC">this is</font><font color="#E5E5E5"> exactly what we need</font>

1048
00:42:21,680 --> 00:42:25,589
actually<font color="#E5E5E5"> after</font><font color="#CCCCCC"> we get rid of this movie</font>

1049
00:42:23,970 --> 00:42:28,740
instruction we are left with a much

1050
00:42:25,589 --> 00:42:30,569
shorter sequence<font color="#E5E5E5"> which only takes up</font><font color="#CCCCCC"> six</font>

1051
00:42:28,740 --> 00:42:32,368
bytes<font color="#E5E5E5"> and this kind of makes</font><font color="#CCCCCC"> this</font>

1052
00:42:30,569 --> 00:42:34,920
<font color="#E5E5E5">solution a universal solution because it</font>

1053
00:42:32,369 --> 00:42:36,720
works on<font color="#E5E5E5"> all Windows</font><font color="#CCCCCC"> versions starting</font>

1054
00:42:34,920 --> 00:42:40,259
<font color="#CCCCCC">from Windows</font><font color="#E5E5E5"> 7 up to</font><font color="#CCCCCC"> an including</font>

1055
00:42:36,720 --> 00:42:42,500
<font color="#E5E5E5">Windows 10 so we have again modified our</font>

1056
00:42:40,259 --> 00:42:45,359
hooking engine to use<font color="#E5E5E5"> this kind</font><font color="#CCCCCC"> of jump</font>

1057
00:42:42,500 --> 00:42:48,150
<font color="#E5E5E5">compile this thing abundantly</font><font color="#CCCCCC"> into</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> dll</font>

1058
00:42:45,359 --> 00:42:51,839
<font color="#CCCCCC">injector didn't so forth</font><font color="#E5E5E5"> and this time</font>

1059
00:42:48,150 --> 00:42:55,049
it<font color="#CCCCCC"> just walked quite well and if you for</font>

1060
00:42:51,839 --> 00:42:56,970
example<font color="#CCCCCC"> try to disassemble</font><font color="#E5E5E5"> one of the</font>

1061
00:42:55,049 --> 00:42:58,589
hook functions<font color="#CCCCCC"> Prolog you will see</font>

1062
00:42:56,970 --> 00:43:04,618
something<font color="#E5E5E5"> like</font><font color="#CCCCCC"> that push which is</font>

1063
00:42:58,589 --> 00:43:06,839
immediately<font color="#E5E5E5"> followed by elect so to</font>

1064
00:43:04,619 --> 00:43:08,789
<font color="#CCCCCC">summarise it have a quick</font><font color="#E5E5E5"> recap of this</font>

1065
00:43:06,839 --> 00:43:11,130
stock<font color="#E5E5E5"> first we needed an injection</font>

1066
00:43:08,789 --> 00:43:13,980
method capable of<font color="#E5E5E5"> injecting</font><font color="#CCCCCC"> 64-bit</font>

1067
00:43:11,130 --> 00:43:17,160
dealers into<font color="#E5E5E5"> work 64 processors we</font>

1068
00:43:13,980 --> 00:43:21,119
started with a few<font color="#E5E5E5"> previously known a</font>

1069
00:43:17,160 --> 00:43:23,220
<font color="#E5E5E5">methods and improved our APC injector to</font>

1070
00:43:21,119 --> 00:43:26,490
make it work on<font color="#CCCCCC"> new and Windows versions</font>

1071
00:43:23,220 --> 00:43:28,890
as well<font color="#E5E5E5"> then we moved we moved on to the</font>

1072
00:43:26,490 --> 00:43:30,618
hooking engine<font color="#E5E5E5"> we took an existing one</font>

1073
00:43:28,890 --> 00:43:34,940
<font color="#CCCCCC">in our case we</font><font color="#E5E5E5"> used min hook and</font>

1074
00:43:30,619 --> 00:43:38,130
modified it to<font color="#E5E5E5"> allow it</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> work on a</font>

1075
00:43:34,940 --> 00:43:40,799
inside<font color="#E5E5E5"> of</font><font color="#CCCCCC"> web 64 processes first we had</font>

1076
00:43:38,130 --> 00:43:41,730
<font color="#E5E5E5">to strip it of dependencies</font><font color="#CCCCCC"> of the</font>

1077
00:43:40,799 --> 00:43:44,490
native ntdll

1078
00:43:41,730 --> 00:43:46,140
and then we had to replace the jump

1079
00:43:44,490 --> 00:43:48,899
instruction normally used by hooking

1080
00:43:46,140 --> 00:43:50,879
engines with in our case push<font color="#E5E5E5"> read</font>

1081
00:43:48,900 --> 00:43:55,859
<font color="#E5E5E5">solution to allow it</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> work on all</font>

1082
00:43:50,880 --> 00:43:58,740
Windows versions<font color="#E5E5E5"> that's it from us we</font>

1083
00:43:55,859 --> 00:44:00,538
also publish publish this research in a

1084
00:43:58,740 --> 00:44:03,209
series of<font color="#E5E5E5"> blog posts</font><font color="#CCCCCC"> if</font><font color="#E5E5E5"> you want to have</font>

1085
00:44:00,539 --> 00:44:05,819
more detailed<font color="#CCCCCC"> information and for</font>

1086
00:44:03,210 --> 00:44:08,910
anybody<font color="#CCCCCC"> who's interested we published</font>

1087
00:44:05,819 --> 00:44:11,970
our modified hooking engine and in this

1088
00:44:08,910 --> 00:44:13,680
repository here<font color="#CCCCCC"> umm questions of course</font>

1089
00:44:11,970 --> 00:44:21,000
you're<font color="#E5E5E5"> free to ask us</font><font color="#CCCCCC"> also later</font><font color="#E5E5E5"> on</font>

1090
00:44:13,680 --> 00:44:23,690
<font color="#E5E5E5">through Twitter email whatever ok so</font>

1091
00:44:21,000 --> 00:44:23,690
that's all<font color="#E5E5E5"> from us</font>

1092
00:44:26,740 --> 00:44:30,529
thank you very<font color="#E5E5E5"> much</font>

1093
00:44:28,430 --> 00:44:34,790
<font color="#CCCCCC">Elsa fee</font><font color="#E5E5E5"> I then are there any questions</font>

1094
00:44:30,530 --> 00:44:37,130
<font color="#E5E5E5">from</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> audience okay</font><font color="#CCCCCC"> if there are no</font>

1095
00:44:34,790 --> 00:44:40,100
<font color="#E5E5E5">questions then do keep in</font><font color="#CCCCCC"> mind</font><font color="#E5E5E5"> that they</font>

1096
00:44:37,130 --> 00:44:41,600
will be here all day<font color="#CCCCCC"> so</font><font color="#E5E5E5"> you can ask any</font>

1097
00:44:40,100 --> 00:44:44,150
questions<font color="#E5E5E5"> that comes to mind to them</font>

1098
00:44:41,600 --> 00:44:47,740
afterwards<font color="#E5E5E5"> thank you</font><font color="#CCCCCC"> very</font><font color="#E5E5E5"> much and give</font>

1099
00:44:44,150 --> 00:44:47,740
it a warming<font color="#E5E5E5"> time for us over here then</font>

