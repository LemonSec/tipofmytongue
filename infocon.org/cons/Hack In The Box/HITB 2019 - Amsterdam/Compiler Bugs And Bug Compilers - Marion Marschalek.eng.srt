1
00:00:19,270 --> 00:00:24,970
hello good morning everyone my name is

2
00:00:22,689 --> 00:00:26,230
Marian I just introduced I'm a security

3
00:00:24,970 --> 00:00:28,029
researcher with internal I'll be

4
00:00:26,230 --> 00:00:31,810
speaking about compiler bugs and what

5
00:00:28,029 --> 00:00:32,409
compilers in fact the title is a little

6
00:00:31,810 --> 00:00:35,110
misleading

7
00:00:32,409 --> 00:00:37,140
I will not actually focus on compiler

8
00:00:35,110 --> 00:00:39,790
bugs that accidentally happen and

9
00:00:37,140 --> 00:00:41,830
introduce vulnerabilities into binaries

10
00:00:39,790 --> 00:00:44,910
I will be speaking about how to make

11
00:00:41,830 --> 00:00:47,860
your compiler put vulnerabilities into

12
00:00:44,910 --> 00:00:49,720
innocent binaries that means that you

13
00:00:47,860 --> 00:00:51,160
could hand me any piece of perfectly

14
00:00:49,720 --> 00:00:53,769
well written source code without any

15
00:00:51,160 --> 00:00:55,690
bugs at all and as soon as I compile it

16
00:00:53,769 --> 00:01:00,010
all of a sudden it is vulnerable to

17
00:00:55,690 --> 00:01:02,440
different ways of exploitation I'll

18
00:01:00,010 --> 00:01:05,440
start this presentation off with the

19
00:01:02,440 --> 00:01:07,179
very important disclaimer since I'm

20
00:01:05,440 --> 00:01:08,798
working for a large corporation our

21
00:01:07,180 --> 00:01:11,320
lawyers wanted me to tell you that the

22
00:01:08,799 --> 00:01:13,060
opinions and positions expressed herein

23
00:01:11,320 --> 00:01:14,289
are mine only and still not represent

24
00:01:13,060 --> 00:01:15,760
the views of any current the previous

25
00:01:14,290 --> 00:01:18,909
employer including Intel Corporation or

26
00:01:15,760 --> 00:01:20,680
its affiliates yada yada the last

27
00:01:18,909 --> 00:01:23,049
important piece of the slide that I want

28
00:01:20,680 --> 00:01:24,850
you to take with here is that no no

29
00:01:23,049 --> 00:01:26,320
actual database software was harmed in

30
00:01:24,850 --> 00:01:28,119
the making of this presentation this

31
00:01:26,320 --> 00:01:29,408
becomes important as I walk through the

32
00:01:28,119 --> 00:01:33,369
presentation and you will see that I

33
00:01:29,409 --> 00:01:37,840
used an open-source database software to

34
00:01:33,369 --> 00:01:39,249
show my compilation magic all right now

35
00:01:37,840 --> 00:01:41,799
let's get started hello it is me again

36
00:01:39,249 --> 00:01:43,570
my name is Marion I'm a researcher at

37
00:01:41,799 --> 00:01:45,729
Intel I work on compiler internals

38
00:01:43,570 --> 00:01:47,288
currently and then also to buy their CPU

39
00:01:45,729 --> 00:01:48,548
related bugs and at this point I also

40
00:01:47,289 --> 00:01:50,409
ask you please don't ask me any

41
00:01:48,549 --> 00:01:53,829
questions about CPU bugs I really cannot

42
00:01:50,409 --> 00:01:55,390
talk to any of these at all if you have

43
00:01:53,829 --> 00:01:57,490
questions about the talk today or feel

44
00:01:55,390 --> 00:01:58,920
like you need to reach out here's my

45
00:01:57,490 --> 00:02:01,539
email address and my Twitter account

46
00:01:58,920 --> 00:02:04,030
alright now let's get started so when I

47
00:02:01,539 --> 00:02:06,039
saw that Jack in the Box is one our talk

48
00:02:04,030 --> 00:02:07,389
slots I was actually very excited I

49
00:02:06,039 --> 00:02:08,979
thought I can put everything in there

50
00:02:07,389 --> 00:02:10,060
that I've done on compilers and this is

51
00:02:08,979 --> 00:02:12,540
actually what happens so be prepared

52
00:02:10,060 --> 00:02:14,710
this presentation will be very quick and

53
00:02:12,540 --> 00:02:16,060
you will now walk with me through

54
00:02:14,710 --> 00:02:17,560
compiler and journalist and learn

55
00:02:16,060 --> 00:02:22,209
everything you'll need to know in about

56
00:02:17,560 --> 00:02:24,459
10 minutes let's start off with me

57
00:02:22,209 --> 00:02:26,860
saying that the idea of compiling box

58
00:02:24,459 --> 00:02:30,130
into an event source code wasn't mine

59
00:02:26,860 --> 00:02:32,190
that was actually count a coined more

60
00:02:30,130 --> 00:02:35,070
than 20 years ago so the first time

61
00:02:32,190 --> 00:02:38,930
that I found mention of compiling box

62
00:02:35,070 --> 00:02:42,180
into source code was in Ken Thompson's

63
00:02:38,930 --> 00:02:45,720
1983 turing award lecture where he

64
00:02:42,180 --> 00:02:47,910
pointed out that compilers are neglected

65
00:02:45,720 --> 00:02:50,280
in terms of security consideration he

66
00:02:47,910 --> 00:02:53,250
said that he can compile a bug into an

67
00:02:50,280 --> 00:02:55,500
innocent piece of source code and turns

68
00:02:53,250 --> 00:02:57,420
out since 1983 and today not much has

69
00:02:55,500 --> 00:02:59,010
changed about that you can still if you

70
00:02:57,420 --> 00:03:01,140
get your hands on a compiler and are

71
00:02:59,010 --> 00:03:03,510
able to compromise the compiler itself

72
00:03:01,140 --> 00:03:05,670
you're still very much a balloon pilot

73
00:03:03,510 --> 00:03:07,980
bugs in the binaries and those might be

74
00:03:05,670 --> 00:03:09,989
very very well visible if you have a

75
00:03:07,980 --> 00:03:11,459
good security team but even if you have

76
00:03:09,990 --> 00:03:13,410
a good security team you can also very

77
00:03:11,460 --> 00:03:15,270
well hide your box until binaries deep

78
00:03:13,410 --> 00:03:19,859
in there so that they're very hard to

79
00:03:15,270 --> 00:03:20,820
find and this is something else that I

80
00:03:19,860 --> 00:03:25,020
want you to take with you throughout

81
00:03:20,820 --> 00:03:26,310
this presentation back then when when

82
00:03:25,020 --> 00:03:28,380
Thompson gave his lecture it looked the

83
00:03:26,310 --> 00:03:30,420
very simple and it looks it seems very

84
00:03:28,380 --> 00:03:32,190
straightforward to compromise a compiler

85
00:03:30,420 --> 00:03:35,369
and make the compiler do whatever you

86
00:03:32,190 --> 00:03:38,520
want in order to insecure the output

87
00:03:35,370 --> 00:03:40,020
binary in fact though whatever you do in

88
00:03:38,520 --> 00:03:43,470
a compiler especially in a modern-day

89
00:03:40,020 --> 00:03:48,720
compiler is really hard to be ideal we

90
00:03:43,470 --> 00:03:50,940
have any use for for the community in

91
00:03:48,720 --> 00:03:53,160
some sense if you see publications about

92
00:03:50,940 --> 00:03:57,060
compiler modifications that proposed

93
00:03:53,160 --> 00:04:00,270
mitigation ideas that propose mediating

94
00:03:57,060 --> 00:04:02,850
entire bug classes all that proposes

95
00:04:00,270 --> 00:04:05,250
ideal compiling bugs in the binaries

96
00:04:02,850 --> 00:04:06,510
keep in mind that it is not always as

97
00:04:05,250 --> 00:04:09,540
simple as it looks like and if a POC

98
00:04:06,510 --> 00:04:11,130
looks very straightforward then possibly

99
00:04:09,540 --> 00:04:14,220
there's not that be capable to most

100
00:04:11,130 --> 00:04:17,010
source code basis compilers nowadays are

101
00:04:14,220 --> 00:04:19,829
very complex creatures they produce

102
00:04:17,010 --> 00:04:22,108
binaries that are very complex in their

103
00:04:19,829 --> 00:04:24,030
format those binaries are loaded by

104
00:04:22,108 --> 00:04:26,969
loaders that are very complex in their

105
00:04:24,030 --> 00:04:28,739
structure and in the end those planners

106
00:04:26,970 --> 00:04:30,330
will be executed by operating systems to

107
00:04:28,740 --> 00:04:32,820
the right complex so all these

108
00:04:30,330 --> 00:04:35,669
complexities together may our compilers

109
00:04:32,820 --> 00:04:37,260
nowadays really really sophisticated so

110
00:04:35,669 --> 00:04:39,810
which ever change you plan to apply to a

111
00:04:37,260 --> 00:04:42,830
compiler needs to be very well thought

112
00:04:39,810 --> 00:04:46,070
out and very well tested

113
00:04:42,830 --> 00:04:48,750
today what I'll be focusing on is the

114
00:04:46,070 --> 00:04:50,190
GCC compiler GCC is an open source

115
00:04:48,750 --> 00:04:52,500
compiler most of you will have heard

116
00:04:50,190 --> 00:04:56,190
about it and most of you will have used

117
00:04:52,500 --> 00:04:59,430
it at one or another point don't ask me

118
00:04:56,190 --> 00:05:02,790
why I'm focusing and GCC turns out that

119
00:04:59,430 --> 00:05:05,220
since I work for Intel we love to work

120
00:05:02,790 --> 00:05:07,650
on projects that we use internally and

121
00:05:05,220 --> 00:05:11,130
turns out that LLVM nowadays is mostly

122
00:05:07,650 --> 00:05:12,750
used by hipsters I did not say this most

123
00:05:11,130 --> 00:05:14,909
of our firmware turns out today compiled

124
00:05:12,750 --> 00:05:17,340
with GCC which is why I was told to

125
00:05:14,910 --> 00:05:19,620
focus my research on GCC and again the

126
00:05:17,340 --> 00:05:21,539
project that I'm talking about today is

127
00:05:19,620 --> 00:05:23,880
not directly linked to what I do at work

128
00:05:21,540 --> 00:05:26,610
at work I focus on researching compiler

129
00:05:23,880 --> 00:05:28,110
mitigations just turns out compiler

130
00:05:26,610 --> 00:05:30,210
mitigations aren't nearly as interesting

131
00:05:28,110 --> 00:05:33,750
as compiler bugs which is why I'm here

132
00:05:30,210 --> 00:05:35,789
today most of the presentations and blog

133
00:05:33,750 --> 00:05:37,410
posts and documentation and and whatnot

134
00:05:35,790 --> 00:05:39,960
you will find about GCC starts out with

135
00:05:37,410 --> 00:05:43,740
this picture this is the publicly

136
00:05:39,960 --> 00:05:46,560
understood 10,000 foot distance view of

137
00:05:43,740 --> 00:05:48,330
GCC it looks nicely while structure it

138
00:05:46,560 --> 00:05:49,590
has three main components which is the

139
00:05:48,330 --> 00:05:51,000
front end the middle end and the back

140
00:05:49,590 --> 00:05:54,479
end and there's a different compiler

141
00:05:51,000 --> 00:05:56,610
steps neatly listed in this graph in

142
00:05:54,480 --> 00:05:59,700
reality GCC is a monster of 14 million

143
00:05:56,610 --> 00:06:01,950
lines of code and the source base isn't

144
00:05:59,700 --> 00:06:03,810
nearly as well-structured as this

145
00:06:01,950 --> 00:06:05,640
picture but let's start with this

146
00:06:03,810 --> 00:06:07,200
picture so of course at the beginning

147
00:06:05,640 --> 00:06:09,750
you have the front end where you look at

148
00:06:07,200 --> 00:06:12,450
different different versions of source

149
00:06:09,750 --> 00:06:14,100
code like C or C++ or Java or in reality

150
00:06:12,450 --> 00:06:15,479
if you're a developer and you extend the

151
00:06:14,100 --> 00:06:16,860
the cheese is the front end you could

152
00:06:15,480 --> 00:06:19,230
raise your own programming language and

153
00:06:16,860 --> 00:06:21,510
have cheese C compile it for you to any

154
00:06:19,230 --> 00:06:23,220
given architecture that GCC can compile

155
00:06:21,510 --> 00:06:25,440
for because those parts are neatly

156
00:06:23,220 --> 00:06:27,780
separated you have the front end person

157
00:06:25,440 --> 00:06:29,760
which generates the abstract syntax tree

158
00:06:27,780 --> 00:06:32,909
and lowers this representation to the

159
00:06:29,760 --> 00:06:35,130
generic representation generic in theory

160
00:06:32,910 --> 00:06:38,760
is a source code independent

161
00:06:35,130 --> 00:06:41,490
representation it looks about as weird

162
00:06:38,760 --> 00:06:43,950
as you would expect if you try to put C

163
00:06:41,490 --> 00:06:45,660
and Java in the same intermediate

164
00:06:43,950 --> 00:06:47,310
presentation so this is what we have

165
00:06:45,660 --> 00:06:49,740
today and from there the compilation

166
00:06:47,310 --> 00:06:50,910
process goes on and lowers the generic

167
00:06:49,740 --> 00:06:53,040
representations different other

168
00:06:50,910 --> 00:06:55,470
representations which help the compiler

169
00:06:53,040 --> 00:06:58,200
find ways for optimization

170
00:06:55,470 --> 00:07:00,360
and help the compiler lower the last

171
00:06:58,200 --> 00:07:02,960
stage down to what we today know as

172
00:07:00,360 --> 00:07:06,180
machine code those stages that are

173
00:07:02,960 --> 00:07:09,989
important for us today are chimpo and

174
00:07:06,180 --> 00:07:12,090
RTL chimp as you can see is more close

175
00:07:09,990 --> 00:07:14,340
to the actual source code that was put

176
00:07:12,090 --> 00:07:16,979
in and RTL is more close to the actual

177
00:07:14,340 --> 00:07:18,750
machine code every time I mentioned that

178
00:07:16,980 --> 00:07:19,980
I work on compiler internals people

179
00:07:18,750 --> 00:07:22,320
start out with oh yeah this is really

180
00:07:19,980 --> 00:07:24,240
complicated all those optimizations and

181
00:07:22,320 --> 00:07:25,740
I'll tell you I've been working on GCC

182
00:07:24,240 --> 00:07:27,360
for more than a year now and I have not

183
00:07:25,740 --> 00:07:28,920
ever touched the actual optimization

184
00:07:27,360 --> 00:07:30,930
settings are the actual optimization

185
00:07:28,920 --> 00:07:33,060
passes of GCC I'm just not there yet

186
00:07:30,930 --> 00:07:34,800
I've mostly been focusing on RTL and

187
00:07:33,060 --> 00:07:36,360
simple as the different representations

188
00:07:34,800 --> 00:07:38,520
where we could have been to either

189
00:07:36,360 --> 00:07:42,420
secure source code or a buddyfight

190
00:07:38,520 --> 00:07:44,370
source code or security to be assembly

191
00:07:42,420 --> 00:07:46,740
presentation or bug if I D to be

192
00:07:44,370 --> 00:07:49,250
assembly representation and this is what

193
00:07:46,740 --> 00:07:53,790
we're going to be speaking about today

194
00:07:49,250 --> 00:07:55,620
GCC isn't only theoretically compiled

195
00:07:53,790 --> 00:07:57,000
into different modules it's also a

196
00:07:55,620 --> 00:07:59,430
theoretically part in two different

197
00:07:57,000 --> 00:08:01,050
passes so you can imagine you have the

198
00:07:59,430 --> 00:08:05,130
10,000 foot view if you look at the

199
00:08:01,050 --> 00:08:09,180
compiler passes you're like the 9,000

200
00:08:05,130 --> 00:08:12,659
foot view the GCC passes are organized

201
00:08:09,180 --> 00:08:14,850
to perform different dedicated tasks on

202
00:08:12,660 --> 00:08:16,410
the source or like I'm the different

203
00:08:14,850 --> 00:08:18,030
representation as they wander throughout

204
00:08:16,410 --> 00:08:21,090
the compiler the beginning you have the

205
00:08:18,030 --> 00:08:26,130
C source code and at the end you for

206
00:08:21,090 --> 00:08:28,260
example how the x86 binary output the

207
00:08:26,130 --> 00:08:29,850
process by itself there's plenty of then

208
00:08:28,260 --> 00:08:32,460
depending on which optimization setting

209
00:08:29,850 --> 00:08:35,610
you use you have either between 100 or

210
00:08:32,460 --> 00:08:38,310
300 passes that the compiler performs on

211
00:08:35,610 --> 00:08:41,450
the on the binary or under how do we

212
00:08:38,309 --> 00:08:44,159
call it source code to be binary

213
00:08:41,450 --> 00:08:49,320
important for us if we want to perform

214
00:08:44,159 --> 00:08:52,110
changes on the state of what our code is

215
00:08:49,320 --> 00:08:53,670
in then ideally we create our own paths

216
00:08:52,110 --> 00:08:55,470
and perform those changes in a given

217
00:08:53,670 --> 00:08:59,520
path important to note at this point is

218
00:08:55,470 --> 00:09:02,790
that GCC like the passes aren't nearly

219
00:08:59,520 --> 00:09:04,680
as well separated as we would expect

220
00:09:02,790 --> 00:09:06,569
in fact there's different data

221
00:09:04,680 --> 00:09:08,310
structures and different representations

222
00:09:06,570 --> 00:09:08,640
that Jesus uses internally that are

223
00:09:08,310 --> 00:09:10,439
avail

224
00:09:08,640 --> 00:09:13,050
throughout the compilation process of

225
00:09:10,440 --> 00:09:14,340
different stages so for example if you

226
00:09:13,050 --> 00:09:17,400
would go ahead and wanted to change

227
00:09:14,340 --> 00:09:20,010
something about a given register that is

228
00:09:17,400 --> 00:09:24,540
used in in the outputs let's say you're

229
00:09:20,010 --> 00:09:26,160
focusing RBX as an x86 register then you

230
00:09:24,540 --> 00:09:28,469
will need to locate where in your

231
00:09:26,160 --> 00:09:31,860
compilation step this register is

232
00:09:28,470 --> 00:09:33,900
present for you to get your hold on and

233
00:09:31,860 --> 00:09:36,200
grab on so for example if you're at the

234
00:09:33,900 --> 00:09:39,300
beginning of the RTL passes your

235
00:09:36,200 --> 00:09:41,640
representation is still very generic it

236
00:09:39,300 --> 00:09:43,500
is independent of any given machine

237
00:09:41,640 --> 00:09:46,350
architecture and only throughout the

238
00:09:43,500 --> 00:09:48,750
different RTL passes the generic

239
00:09:46,350 --> 00:09:50,340
representation of RTL will be lower down

240
00:09:48,750 --> 00:09:52,650
to a more Machine specific

241
00:09:50,340 --> 00:09:54,680
representation of our tail and somewhere

242
00:09:52,650 --> 00:09:57,480
in those passes you'll find the register

243
00:09:54,680 --> 00:09:58,739
allocator after the register allocator

244
00:09:57,480 --> 00:10:00,930
typically you have access to the

245
00:09:58,740 --> 00:10:03,180
different registers and this process is

246
00:10:00,930 --> 00:10:06,089
true for anything you want to change in

247
00:10:03,180 --> 00:10:09,020
the different representations of GCC so

248
00:10:06,090 --> 00:10:11,220
the passes are somewhat important for us

249
00:10:09,020 --> 00:10:13,470
what is more important for us than

250
00:10:11,220 --> 00:10:16,140
knowing the different passes is the

251
00:10:13,470 --> 00:10:18,240
debug output turns out there is a very

252
00:10:16,140 --> 00:10:19,770
thick book to tell you about GCC

253
00:10:18,240 --> 00:10:21,240
internals and about the different data

254
00:10:19,770 --> 00:10:24,270
structures and their availability and

255
00:10:21,240 --> 00:10:26,400
whatnot and it's about 800 pages thick

256
00:10:24,270 --> 00:10:28,290
things maybe even a bit more and it

257
00:10:26,400 --> 00:10:30,900
doesn't teach you it all how to perform

258
00:10:28,290 --> 00:10:32,760
any changes in GCC it is a very good

259
00:10:30,900 --> 00:10:34,290
book it is very neat documentation but

260
00:10:32,760 --> 00:10:36,960
if you want to learn how the different

261
00:10:34,290 --> 00:10:38,939
passes look like how they interact how

262
00:10:36,960 --> 00:10:41,820
the data structures look like how their

263
00:10:38,940 --> 00:10:43,530
representations look like you can best

264
00:10:41,820 --> 00:10:45,450
go about it and looking under at the

265
00:10:43,530 --> 00:10:47,040
debug output there's different compiler

266
00:10:45,450 --> 00:10:49,020
switches which help you print out all

267
00:10:47,040 --> 00:10:50,760
the different representations that GCC

268
00:10:49,020 --> 00:10:51,840
has available most importantly there

269
00:10:50,760 --> 00:10:55,830
will be fm3

270
00:10:51,840 --> 00:10:58,590
that all IPA - all an RTL - all this

271
00:10:55,830 --> 00:11:02,100
gives you the biggest collection of

272
00:10:58,590 --> 00:11:03,930
passed and the GCC companies and if you

273
00:11:02,100 --> 00:11:07,050
go ahead and insert your own compiler

274
00:11:03,930 --> 00:11:09,120
pass you can dump the representation

275
00:11:07,050 --> 00:11:12,510
that your compiler pass produces with F

276
00:11:09,120 --> 00:11:14,160
dump RTL my awesome pass this gives you

277
00:11:12,510 --> 00:11:17,210
insights in the changes that you perform

278
00:11:14,160 --> 00:11:20,730
yourself which is very helpful

279
00:11:17,210 --> 00:11:22,470
now I've been talking about compiler

280
00:11:20,730 --> 00:11:25,410
modifications if you ever tried to

281
00:11:22,470 --> 00:11:27,839
modify your GCC compiler and recompile

282
00:11:25,410 --> 00:11:29,640
with the changes and start testing your

283
00:11:27,839 --> 00:11:32,279
changes you will notice that you spend a

284
00:11:29,640 --> 00:11:33,959
lot of time compiling which makes it

285
00:11:32,279 --> 00:11:36,330
very unfeasible to work on the compiler

286
00:11:33,959 --> 00:11:38,880
source code itself thankfully since

287
00:11:36,330 --> 00:11:42,540
cheesy version 4.5 we can introduce

288
00:11:38,880 --> 00:11:45,870
plugins which have almost the same power

289
00:11:42,540 --> 00:11:47,550
the same availability of API is and data

290
00:11:45,870 --> 00:11:49,440
structures as you would have if you

291
00:11:47,550 --> 00:11:52,170
would type into the compiler source code

292
00:11:49,440 --> 00:11:55,260
itself except the plugins are easy to

293
00:11:52,170 --> 00:11:57,930
compile and easier to load than your

294
00:11:55,260 --> 00:11:59,279
personal compiler changes most of the

295
00:11:57,930 --> 00:12:02,550
parts that I will be presenting today

296
00:11:59,279 --> 00:12:04,439
were implemented using GCC plugins but

297
00:12:02,550 --> 00:12:06,599
keep in mind anything you do in a

298
00:12:04,440 --> 00:12:09,750
plug-in you can naturally also do in the

299
00:12:06,600 --> 00:12:11,670
GCC source space plugins are need for

300
00:12:09,750 --> 00:12:14,100
developing and extending if you're

301
00:12:11,670 --> 00:12:16,050
rather apply it change the compiler

302
00:12:14,100 --> 00:12:17,940
itself you can take the the plug-in

303
00:12:16,050 --> 00:12:21,300
source code and easily integrate it with

304
00:12:17,940 --> 00:12:25,560
GCC I say easily to quick it might not

305
00:12:21,300 --> 00:12:27,599
be easy but it's possible the GCC

306
00:12:25,560 --> 00:12:29,520
plugins themselves are a little bit more

307
00:12:27,600 --> 00:12:32,370
limited so you might not be able to port

308
00:12:29,520 --> 00:12:35,250
any given change to GCC to a plugin

309
00:12:32,370 --> 00:12:36,900
because by nature the plugins don't have

310
00:12:35,250 --> 00:12:40,529
access to all of the idea structures

311
00:12:36,900 --> 00:12:43,650
with GCC provides however we can write

312
00:12:40,529 --> 00:12:45,540
plugins that tap in as early as the

313
00:12:43,650 --> 00:12:47,189
generic phase which means after the

314
00:12:45,540 --> 00:12:51,660
abstract syntax tree is lowered to

315
00:12:47,190 --> 00:12:55,830
generic and as late as the last RTL pass

316
00:12:51,660 --> 00:12:58,020
which is almost x86 but still are almost

317
00:12:55,830 --> 00:13:00,420
the machine language but still compiler

318
00:12:58,020 --> 00:13:02,300
representation and this is about enough

319
00:13:00,420 --> 00:13:04,920
to be able to insert bugs into code

320
00:13:02,300 --> 00:13:09,839
we're almost done with GCC you know

321
00:13:04,920 --> 00:13:12,180
you're all experts um as final note and

322
00:13:09,839 --> 00:13:13,740
she say let me tell you that I've been

323
00:13:12,180 --> 00:13:15,750
talking about it like you can dump

324
00:13:13,740 --> 00:13:17,190
intermediate representations and look at

325
00:13:15,750 --> 00:13:20,040
them and understand which changes you

326
00:13:17,190 --> 00:13:21,300
did to GCC and it sounds that simple it

327
00:13:20,040 --> 00:13:22,290
is almost as simple but it's not exactly

328
00:13:21,300 --> 00:13:24,240
as straightforward

329
00:13:22,290 --> 00:13:27,300
a couple years ago when I was learning

330
00:13:24,240 --> 00:13:28,880
x86 I got used to look up different

331
00:13:27,300 --> 00:13:30,410
instructions and see

332
00:13:28,880 --> 00:13:32,030
their behavior works and what their

333
00:13:30,410 --> 00:13:34,490
conditions are and what their output is

334
00:13:32,030 --> 00:13:37,640
to be expected and I went in with the

335
00:13:34,490 --> 00:13:39,770
same expectation looking at the chimp or

336
00:13:37,640 --> 00:13:42,439
a presentation or the RTL representation

337
00:13:39,770 --> 00:13:45,530
of GCC and turns out RTL especially is a

338
00:13:42,440 --> 00:13:47,840
little bit more complicated RTL is what

339
00:13:45,530 --> 00:13:50,630
you would expect to be a generic

340
00:13:47,840 --> 00:13:53,300
assembly language that can be translated

341
00:13:50,630 --> 00:13:57,770
into any given architecture so in there

342
00:13:53,300 --> 00:13:59,750
you have not necessarily in the early

343
00:13:57,770 --> 00:14:00,800
stages you don't have the registers you

344
00:13:59,750 --> 00:14:03,020
would be used to in your architecture

345
00:14:00,800 --> 00:14:04,430
you don't have the memory restrictions

346
00:14:03,020 --> 00:14:05,750
you would be used in your architecture

347
00:14:04,430 --> 00:14:07,880
in fact in beginning

348
00:14:05,750 --> 00:14:09,770
RTL has an infinite number of registers

349
00:14:07,880 --> 00:14:11,660
available and only when she sees he

350
00:14:09,770 --> 00:14:13,449
learns which architecture it will

351
00:14:11,660 --> 00:14:17,510
compile to it will apply the

352
00:14:13,450 --> 00:14:21,070
architecture specific limitations to the

353
00:14:17,510 --> 00:14:24,110
RTL presentation this screenshot I took

354
00:14:21,070 --> 00:14:25,910
in one of the later stages of RTL where

355
00:14:24,110 --> 00:14:28,100
we already have registers designed and

356
00:14:25,910 --> 00:14:30,140
this piece is complicated as it looks

357
00:14:28,100 --> 00:14:34,160
like translates to two instructions

358
00:14:30,140 --> 00:14:37,670
which would be le a like load a string

359
00:14:34,160 --> 00:14:40,670
into the RDI register and then call the

360
00:14:37,670 --> 00:14:42,650
puts function put string so we load an

361
00:14:40,670 --> 00:14:45,650
argument into our di and then print that

362
00:14:42,650 --> 00:14:47,120
string and as you can imagine I give an

363
00:14:45,650 --> 00:14:48,800
output binary it has millions of

364
00:14:47,120 --> 00:14:51,140
instructions if the source code is big

365
00:14:48,800 --> 00:14:54,500
enough I give an instruction in RTL

366
00:14:51,140 --> 00:14:56,750
occupies at least two and like a maximum

367
00:14:54,500 --> 00:14:59,180
of five to ten lines of code so if you

368
00:14:56,750 --> 00:15:01,460
dump all the intermediate passes of your

369
00:14:59,180 --> 00:15:04,420
large application you will end up with a

370
00:15:01,460 --> 00:15:06,170
lot of log files and they're very big

371
00:15:04,420 --> 00:15:07,849
just to keep this in mind

372
00:15:06,170 --> 00:15:10,189
but yes in order to modify the

373
00:15:07,850 --> 00:15:12,020
intermediate representations of GCC we

374
00:15:10,190 --> 00:15:13,640
better get some understanding of the

375
00:15:12,020 --> 00:15:15,319
intermediate presentations themselves

376
00:15:13,640 --> 00:15:18,620
all these add up to either if you're

377
00:15:15,320 --> 00:15:21,770
interested in compiler research there is

378
00:15:18,620 --> 00:15:23,330
a couple of publications out there that

379
00:15:21,770 --> 00:15:25,460
are really helpful in getting up to

380
00:15:23,330 --> 00:15:27,980
speeds that show example source code and

381
00:15:25,460 --> 00:15:32,170
also there was an easy referee

382
00:15:27,980 --> 00:15:35,240
researcher from Hungary and her

383
00:15:32,170 --> 00:15:37,280
colleagues I'm not sure whether she was

384
00:15:35,240 --> 00:15:38,930
working with the PAC's team on a couple

385
00:15:37,280 --> 00:15:40,339
of GCC plugins that were earlier

386
00:15:38,930 --> 00:15:41,800
committed to the Linux kernel

387
00:15:40,339 --> 00:15:44,589
they're very elaborate

388
00:15:41,800 --> 00:15:48,670
they show a lot of best practices when

389
00:15:44,589 --> 00:15:51,040
trying to write cheesy plugins all right

390
00:15:48,670 --> 00:15:53,410
this was the introduction let's get to

391
00:15:51,040 --> 00:15:54,880
the first demo look at this this line of

392
00:15:53,410 --> 00:15:59,199
source code very well this is what I'm

393
00:15:54,880 --> 00:16:02,019
going to show you now inside of GCC and

394
00:15:59,200 --> 00:16:10,170
I hope I got my demos all very well set

395
00:16:02,019 --> 00:16:10,170
up here we go now we don't wear

396
00:16:10,890 --> 00:16:18,850
duplicate please yes hmm

397
00:16:16,620 --> 00:16:20,320
so I'm a hardware researcher but I have

398
00:16:18,850 --> 00:16:25,300
no idea how beamers work or why do you

399
00:16:20,320 --> 00:16:27,880
ever do what we want them to do here I'm

400
00:16:25,300 --> 00:16:30,399
in a folder where maybe if you can read

401
00:16:27,880 --> 00:16:33,370
what's in the screen there is a hello

402
00:16:30,399 --> 00:16:38,290
world dot C which I'll show you will

403
00:16:33,370 --> 00:16:39,550
print nothing about the hello world as

404
00:16:38,290 --> 00:16:43,569
you can see here there's a printf hello

405
00:16:39,550 --> 00:16:45,550
world and really nothing more okay but

406
00:16:43,570 --> 00:16:48,430
there's also a malicious compiler

407
00:16:45,550 --> 00:16:50,880
plug-in in this folder so now if I go

408
00:16:48,430 --> 00:16:55,359
ahead and just compile my hello world

409
00:16:50,880 --> 00:16:57,370
without any plug-in interference I can

410
00:16:55,360 --> 00:17:01,060
execute my hello world and surprisingly

411
00:16:57,370 --> 00:17:02,589
I see it prints hello world if you can

412
00:17:01,060 --> 00:17:05,559
see that too just believe me it says

413
00:17:02,589 --> 00:17:08,290
hello world now if I go ahead and load

414
00:17:05,559 --> 00:17:10,660
my super malicious compiler plug-in I

415
00:17:08,290 --> 00:17:12,579
can still compile the hello world dot C

416
00:17:10,660 --> 00:17:15,910
and now if I execute hello world all of

417
00:17:12,579 --> 00:17:16,418
a sudden it says hail Satan how did that

418
00:17:15,910 --> 00:17:18,520
happen

419
00:17:16,419 --> 00:17:25,510
I'll tell you if you're inside of the

420
00:17:18,520 --> 00:17:32,740
compiler you have superpowers oops there

421
00:17:25,510 --> 00:17:37,450
we go so this was hello world and this

422
00:17:32,740 --> 00:17:39,520
is hail Satan what I did in this in this

423
00:17:37,450 --> 00:17:42,070
tiny little plugin was essentially I

424
00:17:39,520 --> 00:17:44,230
just looked for the chimp of coal to the

425
00:17:42,070 --> 00:17:47,770
put string function which would output

426
00:17:44,230 --> 00:17:50,919
the hello world string and I located the

427
00:17:47,770 --> 00:17:53,430
argument as you can see here pointed

428
00:17:50,919 --> 00:17:57,630
simple underscore call underscore are

429
00:17:53,430 --> 00:17:59,580
we'll give us the first argument of our

430
00:17:57,630 --> 00:18:01,260
put string function and in the end I did

431
00:17:59,580 --> 00:18:03,540
something super simple I created a new

432
00:18:01,260 --> 00:18:06,120
argument which was a string hail Satan

433
00:18:03,540 --> 00:18:09,030
and then called the function simple call

434
00:18:06,120 --> 00:18:11,580
set argument with this function I

435
00:18:09,030 --> 00:18:14,100
essentially replace the argument that's

436
00:18:11,580 --> 00:18:16,460
in the call to put string and can put my

437
00:18:14,100 --> 00:18:19,620
own string in there now with this little

438
00:18:16,460 --> 00:18:20,970
example you will see in the compiler you

439
00:18:19,620 --> 00:18:23,250
have superpowers and kind of lots of

440
00:18:20,970 --> 00:18:25,170
very obvious stuff you can go ahead and

441
00:18:23,250 --> 00:18:26,700
change string arguments which is rather

442
00:18:25,170 --> 00:18:28,920
pointless but you could also go ahead

443
00:18:26,700 --> 00:18:31,140
and change buffer sizes you could remove

444
00:18:28,920 --> 00:18:33,090
sanity checks you could remove whole

445
00:18:31,140 --> 00:18:35,010
pieces of source code you can replace

446
00:18:33,090 --> 00:18:37,020
whole pieces of source code and enter a

447
00:18:35,010 --> 00:18:38,700
trance of logic you can think here

448
00:18:37,020 --> 00:18:40,560
without indication checks you can make

449
00:18:38,700 --> 00:18:41,340
crypto functions a lot more insecure

450
00:18:40,560 --> 00:18:42,899
than they should be

451
00:18:41,340 --> 00:18:44,429
you can be very obvious about what you

452
00:18:42,900 --> 00:18:49,020
do and it can be very sneaky about what

453
00:18:44,430 --> 00:18:51,480
you do as a defender you're in a hard

454
00:18:49,020 --> 00:18:55,200
position there because reviewing

455
00:18:51,480 --> 00:18:57,150
binaries is very very hard if you're

456
00:18:55,200 --> 00:18:59,550
like a company that puts out a

457
00:18:57,150 --> 00:19:01,020
significant amount of software then it

458
00:18:59,550 --> 00:19:02,879
is difficult to find as many reverse

459
00:19:01,020 --> 00:19:04,770
engineers that would help you look for

460
00:19:02,880 --> 00:19:06,780
bugs that the compiler put into the

461
00:19:04,770 --> 00:19:08,610
binary whether you can do that is you

462
00:19:06,780 --> 00:19:10,410
can different see whether anything was

463
00:19:08,610 --> 00:19:12,060
added or removed from what you would

464
00:19:10,410 --> 00:19:14,790
expect to be in a binary you can try to

465
00:19:12,060 --> 00:19:17,250
false of course which we should always

466
00:19:14,790 --> 00:19:18,540
do on your own binary is to see whether

467
00:19:17,250 --> 00:19:20,850
there's any bugs in there you wouldn't

468
00:19:18,540 --> 00:19:22,409
expect you can't try to guard your built

469
00:19:20,850 --> 00:19:24,629
environments which is rather kind of

470
00:19:22,410 --> 00:19:27,090
obvious don't let anyone go ahead and

471
00:19:24,630 --> 00:19:29,850
tinker with your compilers like I would

472
00:19:27,090 --> 00:19:30,959
and of course I don't know how many

473
00:19:29,850 --> 00:19:33,689
people in the room ever thought about

474
00:19:30,960 --> 00:19:36,330
doing security review on their make

475
00:19:33,690 --> 00:19:38,340
files I'm not sure whether that's a

476
00:19:36,330 --> 00:19:39,510
common habit to do I would recommend to

477
00:19:38,340 --> 00:19:41,100
do so every once in a while to see

478
00:19:39,510 --> 00:19:42,600
whether someone might have sneaked in a

479
00:19:41,100 --> 00:19:46,080
plugin that's being there within the

480
00:19:42,600 --> 00:19:49,469
compilation process um all right another

481
00:19:46,080 --> 00:19:50,939
thing that would be rather obvious is to

482
00:19:49,470 --> 00:19:53,700
attack a piece of source code that

483
00:19:50,940 --> 00:19:55,680
already had box in it in the past that

484
00:19:53,700 --> 00:19:57,090
were patched if you look at what was

485
00:19:55,680 --> 00:19:58,710
patched his source code in the past you

486
00:19:57,090 --> 00:20:00,659
can easily go ahead and spot the patch

487
00:19:58,710 --> 00:20:02,550
and through the compiler remove that

488
00:20:00,660 --> 00:20:04,260
given patch which is how I started my

489
00:20:02,550 --> 00:20:06,330
whole adventure into introducing bugs

490
00:20:04,260 --> 00:20:06,960
into binary so I picked up a bug that

491
00:20:06,330 --> 00:20:09,330
was

492
00:20:06,960 --> 00:20:12,200
last year by member of project zero from

493
00:20:09,330 --> 00:20:14,850
global where they found out that a

494
00:20:12,200 --> 00:20:18,029
phylum was checked for a given

495
00:20:14,850 --> 00:20:19,770
- and the routine that was looking for

496
00:20:18,029 --> 00:20:22,230
the - in the file name was expecting the

497
00:20:19,770 --> 00:20:24,090
- to be naturally there because it's a

498
00:20:22,230 --> 00:20:25,890
it's an SQLite or it's a database

499
00:20:24,090 --> 00:20:28,980
internal file that's being passed

500
00:20:25,890 --> 00:20:30,899
so that's routine wouldn't look for the

501
00:20:28,980 --> 00:20:32,929
end of the string so which is keep on

502
00:20:30,899 --> 00:20:35,129
looking for the - forever and afterwards

503
00:20:32,929 --> 00:20:38,669
very conveniently call a mem copy

504
00:20:35,130 --> 00:20:41,429
function to copy the part string name

505
00:20:38,669 --> 00:20:45,059
into a given buffer doesn't look bad at

506
00:20:41,429 --> 00:20:47,340
all right so I went ahead and picked up

507
00:20:45,059 --> 00:20:48,600
that open source project which is SQLite

508
00:20:47,340 --> 00:20:51,480
which is why in the beginning I

509
00:20:48,600 --> 00:20:53,580
mentioned there isn't actually more

510
00:20:51,480 --> 00:20:55,230
boxes collide now that I did my project

511
00:20:53,580 --> 00:20:57,210
as I were before

512
00:20:55,230 --> 00:20:59,640
whatsoever but all the boxes I share in

513
00:20:57,210 --> 00:21:01,200
this presentation were my work that was

514
00:20:59,640 --> 00:21:04,830
just me and the scale I it might be

515
00:21:01,200 --> 00:21:07,399
perfectly fine still hopefully all right

516
00:21:04,830 --> 00:21:10,168
so I went ahead an unpatched dead bug

517
00:21:07,399 --> 00:21:11,699
let's see how that looked like since I

518
00:21:10,169 --> 00:21:13,710
work for Intel now I started most of my

519
00:21:11,700 --> 00:21:15,179
slides on the right side and work my way

520
00:21:13,710 --> 00:21:17,279
to the left side so we have to begin

521
00:21:15,179 --> 00:21:19,320
over there when we see the original

522
00:21:17,279 --> 00:21:21,510
source code as this compiled with the

523
00:21:19,320 --> 00:21:25,289
patch you can see I marked down there a

524
00:21:21,510 --> 00:21:27,629
compare instruction which looks for a 0

525
00:21:25,289 --> 00:21:29,370
it compares a given character this

526
00:21:27,630 --> 00:21:30,809
variable over there is a character it

527
00:21:29,370 --> 00:21:33,658
sees whether that's a 0 which would

528
00:21:30,809 --> 00:21:35,610
indicate the end of a string if it

529
00:21:33,659 --> 00:21:37,380
reaches the end of a string then this

530
00:21:35,610 --> 00:21:39,689
loop that were in where we're looking

531
00:21:37,380 --> 00:21:41,399
for the - it's jumping to an error

532
00:21:39,690 --> 00:21:43,830
handler function says we didn't find the

533
00:21:41,399 --> 00:21:45,750
- originally this check wasn't there and

534
00:21:43,830 --> 00:21:47,730
after I compile this killer this trick

535
00:21:45,750 --> 00:21:49,620
wasn't there anymore either

536
00:21:47,730 --> 00:21:51,330
so over there on the right side or on

537
00:21:49,620 --> 00:21:52,979
the on the left side you can say that

538
00:21:51,330 --> 00:21:55,320
these two instructions are now missing

539
00:21:52,980 --> 00:21:57,360
that was my my proper work and turns out

540
00:21:55,320 --> 00:21:58,620
I had a closer look at this book it is

541
00:21:57,360 --> 00:22:02,399
actually not very helpful

542
00:21:58,620 --> 00:22:04,559
um and the routine looks for this - and

543
00:22:02,399 --> 00:22:06,689
if it can't find the - it will continue

544
00:22:04,559 --> 00:22:08,639
execution until it finds the - which

545
00:22:06,690 --> 00:22:09,929
could be anywhere and for me as an

546
00:22:08,640 --> 00:22:11,880
etiquette there was no way of actually

547
00:22:09,929 --> 00:22:13,649
putting a - somewhere in memory where I

548
00:22:11,880 --> 00:22:15,630
could control the location of the - and

549
00:22:13,649 --> 00:22:17,399
control the content of the buffer until

550
00:22:15,630 --> 00:22:19,470
this - is found which means that there

551
00:22:17,399 --> 00:22:20,379
is no other way than to sex hold with

552
00:22:19,470 --> 00:22:22,480
that bug

553
00:22:20,380 --> 00:22:24,270
and later on the started wondering is

554
00:22:22,480 --> 00:22:26,679
that true

555
00:22:24,270 --> 00:22:28,960
so with the source code as it looked

556
00:22:26,679 --> 00:22:31,660
like at that point in time I couldn't do

557
00:22:28,960 --> 00:22:33,610
much with a bug except if it could run

558
00:22:31,660 --> 00:22:35,140
another plugin and look for what they

559
00:22:33,610 --> 00:22:36,490
could do to make this bug actually more

560
00:22:35,140 --> 00:22:39,610
accessible and more controllable and

561
00:22:36,490 --> 00:22:43,330
more exploitable so I went ahead and did

562
00:22:39,610 --> 00:22:46,479
the obvious this function actually takes

563
00:22:43,330 --> 00:22:48,899
in the database name or the past plus

564
00:22:46,480 --> 00:22:51,100
name string that indicates where the

565
00:22:48,900 --> 00:22:53,950
database is located or where the file is

566
00:22:51,100 --> 00:22:58,719
located that escalate should be opening

567
00:22:53,950 --> 00:23:01,990
and inside and then I went ahead and

568
00:22:58,720 --> 00:23:03,820
looked where where this past is being

569
00:23:01,990 --> 00:23:05,080
read which function is and how it when

570
00:23:03,820 --> 00:23:07,450
there's then through the escalate

571
00:23:05,080 --> 00:23:09,240
function stack until the moment where

572
00:23:07,450 --> 00:23:15,490
the main copy operations happening

573
00:23:09,240 --> 00:23:17,350
so for me might venture in gdb where I

574
00:23:15,490 --> 00:23:18,640
found out which function it was where

575
00:23:17,350 --> 00:23:21,760
the mem copy was happening which is

576
00:23:18,640 --> 00:23:25,630
called find create file mode which does

577
00:23:21,760 --> 00:23:27,280
create a file at the end and contains

578
00:23:25,630 --> 00:23:29,110
the vulnerable man copy function and

579
00:23:27,280 --> 00:23:31,809
throughout the stack I figured out that

580
00:23:29,110 --> 00:23:33,879
the function sqlite3 pager open was the

581
00:23:31,809 --> 00:23:35,740
one which performed certain checks on my

582
00:23:33,880 --> 00:23:39,100
file name which prevented me originally

583
00:23:35,740 --> 00:23:40,990
from introducing my properly crafted

584
00:23:39,100 --> 00:23:43,658
file name in order to exploit my man

585
00:23:40,990 --> 00:23:45,880
copy bug so went to that function and

586
00:23:43,659 --> 00:23:47,320
checked looked for the security checks

587
00:23:45,880 --> 00:23:50,679
that are performed in this function and

588
00:23:47,320 --> 00:23:55,418
figure out we have a call to a function

589
00:23:50,679 --> 00:23:58,690
called sqlite3 os full path name you can

590
00:23:55,419 --> 00:24:01,929
see in the upper half here which takes

591
00:23:58,690 --> 00:24:03,730
in the provided string performed

592
00:24:01,929 --> 00:24:05,530
security checks to perform sanity checks

593
00:24:03,730 --> 00:24:08,590
in that string and copies it to a

594
00:24:05,530 --> 00:24:10,210
different buffer which in the continuing

595
00:24:08,590 --> 00:24:15,309
source code will be used as the actual

596
00:24:10,210 --> 00:24:17,289
path name to the SQLite database so what

597
00:24:15,309 --> 00:24:19,418
I did as an attacker was allocated that

598
00:24:17,289 --> 00:24:23,169
function a figure this is my problem and

599
00:24:19,419 --> 00:24:25,120
I removed it more about this in a minute

600
00:24:23,169 --> 00:24:29,860
the other check that I was curious about

601
00:24:25,120 --> 00:24:32,620
was down here where the length of the

602
00:24:29,860 --> 00:24:33,850
path name was compared to a given max

603
00:24:32,620 --> 00:24:35,830
path name variable

604
00:24:33,850 --> 00:24:37,620
this is also very destructive if you try

605
00:24:35,830 --> 00:24:40,210
to enter a path name it's just too long

606
00:24:37,620 --> 00:24:41,709
so went ahead and wrote the plugin which

607
00:24:40,210 --> 00:24:43,780
simply goes ahead and locates those

608
00:24:41,710 --> 00:24:46,840
checks and removes them the first one

609
00:24:43,780 --> 00:24:49,060
was removed by chest assigning the

610
00:24:46,840 --> 00:24:51,159
pointer of the past name that was to be

611
00:24:49,060 --> 00:24:55,240
checked to the pointer that would

612
00:24:51,160 --> 00:24:57,730
contain the checked path name in the end

613
00:24:55,240 --> 00:24:59,560
skipping the the validity checks were

614
00:24:57,730 --> 00:25:03,010
performed by the function mention before

615
00:24:59,560 --> 00:25:05,500
and the second thing I did was I located

616
00:25:03,010 --> 00:25:09,700
the condition the check for the max

617
00:25:05,500 --> 00:25:12,460
length variable and just slipped the

618
00:25:09,700 --> 00:25:15,040
output value so when you look through

619
00:25:12,460 --> 00:25:16,750
the simple API you would almost think

620
00:25:15,040 --> 00:25:19,629
it's written for a net occur because you

621
00:25:16,750 --> 00:25:22,390
can replace arguments you can replace

622
00:25:19,630 --> 00:25:25,900
values you can increase values and lower

623
00:25:22,390 --> 00:25:30,820
values you can switch arguments and you

624
00:25:25,900 --> 00:25:33,160
can negate or positive eight for

625
00:25:30,820 --> 00:25:35,490
everything like flip the outcome of

626
00:25:33,160 --> 00:25:37,780
logical conditions and it is also very

627
00:25:35,490 --> 00:25:39,700
rather straightforward to understand

628
00:25:37,780 --> 00:25:43,240
like simple by itself is not the most

629
00:25:39,700 --> 00:25:47,020
complicated language all right let's see

630
00:25:43,240 --> 00:25:49,480
how that looks like one more slide this

631
00:25:47,020 --> 00:25:50,680
is just my massive exploitation skills I

632
00:25:49,480 --> 00:25:52,420
have to say at this point I'm not a

633
00:25:50,680 --> 00:25:54,520
Linux specialist as much as I'm talking

634
00:25:52,420 --> 00:25:57,810
about Linux and I'm born and raised on

635
00:25:54,520 --> 00:26:00,370
Windows and neither am i TD be

636
00:25:57,810 --> 00:26:02,679
specialists in any source and neither am

637
00:26:00,370 --> 00:26:04,989
i exploitation specialist anyhow here's

638
00:26:02,680 --> 00:26:06,940
my my expectation skills we're we're at

639
00:26:04,990 --> 00:26:09,520
the end of the fight create fine create

640
00:26:06,940 --> 00:26:11,680
file mode function where essentially I

641
00:26:09,520 --> 00:26:14,770
over flowed my main copy operation that

642
00:26:11,680 --> 00:26:17,860
mem copy gladly copy stuff to the stack

643
00:26:14,770 --> 00:26:19,660
and gladly jesusí decided that in this

644
00:26:17,860 --> 00:26:21,669
particular function it doesn't need to

645
00:26:19,660 --> 00:26:23,410
apply any stack cookies because there's

646
00:26:21,670 --> 00:26:25,690
no input coming from an outside function

647
00:26:23,410 --> 00:26:28,270
because the checks were performed way

648
00:26:25,690 --> 00:26:31,570
earlier and clearly cheesy didn't see me

649
00:26:28,270 --> 00:26:34,660
coming and yeah so I entered a very long

650
00:26:31,570 --> 00:26:36,490
string as a database name it seems very

651
00:26:34,660 --> 00:26:38,290
simple and straightforward and in the

652
00:26:36,490 --> 00:26:40,810
end managed to override the return value

653
00:26:38,290 --> 00:26:43,750
on the stack and this return value I

654
00:26:40,810 --> 00:26:46,190
wrote the address of my own little

655
00:26:43,750 --> 00:26:48,610
shellcode that is since I'm the compiler

656
00:26:46,190 --> 00:26:51,110
also compiled that into my binaries

657
00:26:48,610 --> 00:26:53,539
anyhow it's just the demo if you're more

658
00:26:51,110 --> 00:26:57,889
versed in exploitation than me and feel

659
00:26:53,539 --> 00:27:03,158
free to exploit this bug yourself good

660
00:26:57,889 --> 00:27:22,729
day my number two whoops wrong one

661
00:27:03,159 --> 00:27:25,000
Jin's exclaim what first I have to find

662
00:27:22,730 --> 00:27:27,080
my demo here we go

663
00:27:25,000 --> 00:27:29,720
what happens if you have to win you mean

664
00:27:27,080 --> 00:27:33,408
windows open um so in this territory I

665
00:27:29,720 --> 00:27:39,519
prepared the perfectly innocent source

666
00:27:33,409 --> 00:27:42,980
code of SQLite 3 and my own plugin which

667
00:27:39,519 --> 00:27:43,970
I'm sorry um the plugin is in a

668
00:27:42,980 --> 00:27:45,409
different directory in this case and

669
00:27:43,970 --> 00:27:47,629
this in the directory we have the source

670
00:27:45,409 --> 00:27:49,429
code of SQLite 3 and we have a little

671
00:27:47,629 --> 00:27:51,918
database application which I will show

672
00:27:49,429 --> 00:27:55,309
you right now the database application

673
00:27:51,919 --> 00:27:59,019
as you can see is not actually fit for

674
00:27:55,309 --> 00:28:03,080
execution at all because as mentioned I

675
00:27:59,019 --> 00:28:05,539
bluntly just put a very absolutely

676
00:28:03,080 --> 00:28:07,399
useless database name in there this is

677
00:28:05,539 --> 00:28:08,990
my my neat little stack buffer overflow

678
00:28:07,399 --> 00:28:11,000
don't look at it too closely it is not

679
00:28:08,990 --> 00:28:12,259
very crowded very well anyway

680
00:28:11,000 --> 00:28:15,019
exploitation is not what I wanted to

681
00:28:12,259 --> 00:28:20,799
show you today but compilation so now as

682
00:28:15,019 --> 00:28:24,320
I go ahead I pre-built Robbie I

683
00:28:20,799 --> 00:28:27,230
pre-built the lip escalate 3000 so this

684
00:28:24,320 --> 00:28:29,470
is the SQLite library one of the reasons

685
00:28:27,230 --> 00:28:32,389
why I picked SQLite is my victim because

686
00:28:29,470 --> 00:28:34,159
SQLite has a very neat amalgamation

687
00:28:32,389 --> 00:28:37,309
release which means that all of their

688
00:28:34,159 --> 00:28:39,169
source code is located in 1c file which

689
00:28:37,309 --> 00:28:40,700
makes compiler tests very easy it's just

690
00:28:39,169 --> 00:28:42,169
like one large source file and you don't

691
00:28:40,700 --> 00:28:44,779
have to care about build chains and

692
00:28:42,169 --> 00:28:46,370
whatsoever you just execute GCC and it

693
00:28:44,779 --> 00:28:50,120
will compile the whole database library

694
00:28:46,370 --> 00:28:51,949
which is very neat anyhow what was I

695
00:28:50,120 --> 00:28:55,939
going to show you I have this script

696
00:28:51,950 --> 00:28:57,380
which compiles my useless database

697
00:28:55,940 --> 00:29:00,200
application

698
00:28:57,380 --> 00:29:04,460
it's called compile and run which if you

699
00:29:00,200 --> 00:29:07,280
have a look here then to them in the

700
00:29:04,460 --> 00:29:08,210
middle of the script the first couple

701
00:29:07,280 --> 00:29:10,399
lines are set up in the middle of the

702
00:29:08,210 --> 00:29:13,730
script you see that I call GCC seven to

703
00:29:10,400 --> 00:29:15,440
compile my database application which is

704
00:29:13,730 --> 00:29:18,260
called TB test at C which is what I just

705
00:29:15,440 --> 00:29:20,539
show you has this extremely long file

706
00:29:18,260 --> 00:29:22,549
name which won't do anything L and in

707
00:29:20,539 --> 00:29:26,629
the end we execute that application so

708
00:29:22,549 --> 00:29:29,090
let's go ahead and compile it and of

709
00:29:26,630 --> 00:29:31,850
course as karai's will tell us that it

710
00:29:29,090 --> 00:29:33,799
cannot open possibly this falling which

711
00:29:31,850 --> 00:29:35,030
is good we're still secure there's no no

712
00:29:33,799 --> 00:29:36,918
bug in there whatsoever

713
00:29:35,030 --> 00:29:40,129
but now if i go ahead and start

714
00:29:36,919 --> 00:29:45,230
recompiling sqi it with my prepped make

715
00:29:40,130 --> 00:29:47,480
file where we tell GCC to please unpatch

716
00:29:45,230 --> 00:29:49,429
the bug that was in there and now

717
00:29:47,480 --> 00:29:53,210
executing make with a none perchick was

718
00:29:49,429 --> 00:29:55,190
one which means that if you look at the

719
00:29:53,210 --> 00:29:57,110
line that is shown right here now we're

720
00:29:55,190 --> 00:29:59,929
loading the chimp lattaker dot s o

721
00:29:57,110 --> 00:30:01,520
plugin which in the end will remove all

722
00:29:59,929 --> 00:30:03,200
the sanity checks in the unpaired char

723
00:30:01,520 --> 00:30:06,020
overflow bug and in the end make the

724
00:30:03,200 --> 00:30:07,840
application vulnerable woohoo there we

725
00:30:06,020 --> 00:30:10,460
go now we have an SQLite database

726
00:30:07,840 --> 00:30:15,110
library which is absolutely vulnerable

727
00:30:10,460 --> 00:30:16,760
to attack and running my tests again

728
00:30:15,110 --> 00:30:18,979
sindermann woohoo

729
00:30:16,760 --> 00:30:20,629
all of a sudden we have a saw the

730
00:30:18,980 --> 00:30:24,020
calculator sorry I couldn't couldn't

731
00:30:20,630 --> 00:30:25,940
find the calculator it's Navitus um

732
00:30:24,020 --> 00:30:29,299
turns out Debian doesn't ship with the

733
00:30:25,940 --> 00:30:31,309
character DXE anyhow there is he like I

734
00:30:29,299 --> 00:30:33,320
just offered the buffer I captured the

735
00:30:31,309 --> 00:30:35,000
return address I loaded it into a IEP

736
00:30:33,320 --> 00:30:37,039
and I redirected it to my little piece

737
00:30:35,000 --> 00:30:38,870
of shell code that the compiled into my

738
00:30:37,039 --> 00:30:40,330
library and all of a sudden we see an

739
00:30:38,870 --> 00:30:43,610
abacus here

740
00:30:40,330 --> 00:30:46,280
good so you see we can perfectly well

741
00:30:43,610 --> 00:30:48,830
unpatch box we can introduce box we can

742
00:30:46,280 --> 00:30:51,049
modify so much stuff in the binary and

743
00:30:48,830 --> 00:30:53,870
something that I'll have to tell you

744
00:30:51,049 --> 00:30:56,240
about this is that is not quite evasive

745
00:30:53,870 --> 00:30:58,580
what I did there so I made major changes

746
00:30:56,240 --> 00:31:00,740
to the actual source code if you flip

747
00:30:58,580 --> 00:31:02,570
stuff in the source code and remove and

748
00:31:00,740 --> 00:31:04,520
add things you're always performing

749
00:31:02,570 --> 00:31:07,100
changes that at the end of the day might

750
00:31:04,520 --> 00:31:08,629
affect your future execution the checks

751
00:31:07,100 --> 00:31:10,100
that are removed might have been vital

752
00:31:08,630 --> 00:31:10,880
for some other operation that is the

753
00:31:10,100 --> 00:31:12,919
same function as

754
00:31:10,880 --> 00:31:14,810
especially if you use large applications

755
00:31:12,920 --> 00:31:16,130
it is very likely that if you go ahead

756
00:31:14,810 --> 00:31:17,750
and change something in the source code

757
00:31:16,130 --> 00:31:19,610
it will be a problem for you later on

758
00:31:17,750 --> 00:31:22,130
and you have to fix all the corner cases

759
00:31:19,610 --> 00:31:25,429
where your changes actually create

760
00:31:22,130 --> 00:31:27,320
Portland's a thing that I've been

761
00:31:25,430 --> 00:31:29,480
thinking going through the source space

762
00:31:27,320 --> 00:31:31,040
off escalade was that use the same

763
00:31:29,480 --> 00:31:32,780
sanity checks all over through their

764
00:31:31,040 --> 00:31:34,879
their codes if you would just go ahead

765
00:31:32,780 --> 00:31:36,980
and look for all the men copies they use

766
00:31:34,880 --> 00:31:39,230
a lot of memory and use the same sanity

767
00:31:36,980 --> 00:31:41,000
checks and if you generically just

768
00:31:39,230 --> 00:31:42,290
changed those sanity checks you cannot

769
00:31:41,000 --> 00:31:44,660
be sure that the application still

770
00:31:42,290 --> 00:31:47,750
properly execute this is the thing to

771
00:31:44,660 --> 00:31:49,880
keep in mind that's it there's lots of

772
00:31:47,750 --> 00:31:52,250
do's and don'ts when you go ahead and

773
00:31:49,880 --> 00:31:55,400
load such changes into a compiler

774
00:31:52,250 --> 00:31:57,530
first of all craft wisely once you got

775
00:31:55,400 --> 00:31:59,270
going on simple plugins and you can do

776
00:31:57,530 --> 00:32:00,260
changes in simple it is pretty

777
00:31:59,270 --> 00:32:02,810
straightforward

778
00:32:00,260 --> 00:32:05,300
to change arguments and change numerical

779
00:32:02,810 --> 00:32:07,190
values and to replace function calls and

780
00:32:05,300 --> 00:32:08,840
whatnot but in the end as I just

781
00:32:07,190 --> 00:32:10,850
mentioned you have to keep in mind that

782
00:32:08,840 --> 00:32:12,530
your changes might affect other parts of

783
00:32:10,850 --> 00:32:13,639
the binary as well and as mentioned in

784
00:32:12,530 --> 00:32:15,170
the beginning compilers are very

785
00:32:13,640 --> 00:32:17,450
complicated which ever change you do

786
00:32:15,170 --> 00:32:20,180
inside of the compiler might affect

787
00:32:17,450 --> 00:32:22,040
other important pieces of the compiler

788
00:32:20,180 --> 00:32:23,750
that you have to keep in mind this

789
00:32:22,040 --> 00:32:26,480
becomes more and more true especially as

790
00:32:23,750 --> 00:32:28,460
you move down lower the passes so in the

791
00:32:26,480 --> 00:32:30,050
beginning the closer you are to see the

792
00:32:28,460 --> 00:32:32,210
more natural it is for you to like

793
00:32:30,050 --> 00:32:34,159
change the function call to another the

794
00:32:32,210 --> 00:32:35,510
closer you move to the actual x86 the

795
00:32:34,160 --> 00:32:38,000
more you have to keep in mind how does

796
00:32:35,510 --> 00:32:40,160
your output binary format look like how

797
00:32:38,000 --> 00:32:42,170
does your loader load the binary like if

798
00:32:40,160 --> 00:32:44,320
you perform changes to the header to the

799
00:32:42,170 --> 00:32:46,390
actual representation of the of the code

800
00:32:44,320 --> 00:32:48,530
how does the loader deal with that

801
00:32:46,390 --> 00:32:50,990
afterwards you have to consider that

802
00:32:48,530 --> 00:32:53,180
your operating system wants to execute

803
00:32:50,990 --> 00:32:56,270
the binary on your machine on your

804
00:32:53,180 --> 00:32:58,100
actual CPU and you have to consider like

805
00:32:56,270 --> 00:33:00,800
for example if you perform changes to

806
00:32:58,100 --> 00:33:03,379
how registers are used or to change how

807
00:33:00,800 --> 00:33:05,060
the stack is being used so you have to

808
00:33:03,380 --> 00:33:06,950
know what else is affected by your

809
00:33:05,060 --> 00:33:08,720
change to the stack if you just they had

810
00:33:06,950 --> 00:33:10,400
a given Porsche instruction in any given

811
00:33:08,720 --> 00:33:12,710
function in the middle of sqlite

812
00:33:10,400 --> 00:33:14,660
execution you will crash because you

813
00:33:12,710 --> 00:33:16,760
will mess up the stack frames and this

814
00:33:14,660 --> 00:33:17,870
is box that in the end if you write a

815
00:33:16,760 --> 00:33:19,790
large plugin and do lots of

816
00:33:17,870 --> 00:33:21,620
modifications and don't perform proper

817
00:33:19,790 --> 00:33:23,670
testing you will have a very hard time

818
00:33:21,620 --> 00:33:24,959
finding those bugs and speaking of it

819
00:33:23,670 --> 00:33:26,730
variance because I've mentioned I tried

820
00:33:24,960 --> 00:33:28,770
to implement mitigation prototypes and

821
00:33:26,730 --> 00:33:31,770
she see and I found lots of those bugs

822
00:33:28,770 --> 00:33:34,230
that were very non obvious to me in my

823
00:33:31,770 --> 00:33:36,090
debugger so that's a test properly

824
00:33:34,230 --> 00:33:37,980
whichever changes you you perform

825
00:33:36,090 --> 00:33:40,439
refrain from me any assumptions there's

826
00:33:37,980 --> 00:33:42,720
lots of api's inside of jesusí that

827
00:33:40,440 --> 00:33:43,950
their names sound very obvious but if

828
00:33:42,720 --> 00:33:45,630
you don't understand what's going on in

829
00:33:43,950 --> 00:33:46,920
them please don't just use them but

830
00:33:45,630 --> 00:33:49,050
understand what you're doing that first

831
00:33:46,920 --> 00:33:50,790
because otherwise you might insert box

832
00:33:49,050 --> 00:33:54,540
they're very hard to find into your own

833
00:33:50,790 --> 00:33:56,129
box binaries and debugging binaries the

834
00:33:54,540 --> 00:33:59,730
malicious compiler spit out it isn't

835
00:33:56,130 --> 00:34:01,380
always that much fun consider the target

836
00:33:59,730 --> 00:34:03,120
as mentioned consider how stacks looked

837
00:34:01,380 --> 00:34:05,760
like our registers are being used for

838
00:34:03,120 --> 00:34:08,489
example do not perform any changes on

839
00:34:05,760 --> 00:34:10,080
our bx in the binary that's compiled as

840
00:34:08,489 --> 00:34:14,299
a position independent code because our

841
00:34:10,080 --> 00:34:17,159
bx is typically used to locate the

842
00:34:14,300 --> 00:34:19,380
linker table if your binary dynamically

843
00:34:17,159 --> 00:34:21,719
wants to look up where the linker table

844
00:34:19,380 --> 00:34:25,500
tells it to find a given API call then

845
00:34:21,719 --> 00:34:27,509
changing our BX is not recommended and

846
00:34:25,500 --> 00:34:29,159
as you see this explanation is very long

847
00:34:27,510 --> 00:34:31,350
I had a very hard time figuring out what

848
00:34:29,159 --> 00:34:34,879
was wrong with my usage for BX when I

849
00:34:31,350 --> 00:34:37,350
ran into that bug again compilers are

850
00:34:34,880 --> 00:34:39,330
complicated also something to keep in

851
00:34:37,350 --> 00:34:42,000
mind is that compilers change or cheeses

852
00:34:39,330 --> 00:34:43,620
he changes occasionally a lot among the

853
00:34:42,000 --> 00:34:46,469
different operations and something that

854
00:34:43,620 --> 00:34:48,299
you've been doing in GCC version 5 might

855
00:34:46,469 --> 00:34:51,178
not be applicable anymore in GCC version

856
00:34:48,300 --> 00:34:53,400
6 the same applies to version 7 and 8

857
00:34:51,179 --> 00:34:55,470
and this will sadly be true in the

858
00:34:53,400 --> 00:34:57,660
future as well so if you're not exactly

859
00:34:55,469 --> 00:35:01,169
sure which compiler version your victim

860
00:34:57,660 --> 00:35:02,879
will be using then essentially the

861
00:35:01,170 --> 00:35:05,340
amount of development effort that goes

862
00:35:02,880 --> 00:35:06,750
into a plug-in or a change the Rises

863
00:35:05,340 --> 00:35:08,300
exponentially because you have to

864
00:35:06,750 --> 00:35:12,210
consider the different versions of your

865
00:35:08,300 --> 00:35:14,250
compiler alright we're almost halfway

866
00:35:12,210 --> 00:35:17,490
through the presentation which is good

867
00:35:14,250 --> 00:35:19,200
let's get to the elf things I actually

868
00:35:17,490 --> 00:35:22,529
only added this slide because I thought

869
00:35:19,200 --> 00:35:25,140
else was so funny what I wanted to talk

870
00:35:22,530 --> 00:35:28,080
about with elf things was that the elf

871
00:35:25,140 --> 00:35:30,330
format itself offers us many ways to

872
00:35:28,080 --> 00:35:32,790
perform simple modifications that help

873
00:35:30,330 --> 00:35:34,170
us execute malicious code in there this

874
00:35:32,790 --> 00:35:36,150
just as a side note there is a nice

875
00:35:34,170 --> 00:35:36,870
documentation of the off format which I

876
00:35:36,150 --> 00:35:39,450
totally Rico

877
00:35:36,870 --> 00:35:42,540
and if I look up CS that Stevens dot edu

878
00:35:39,450 --> 00:35:44,009
they have this nice long explanation of

879
00:35:42,540 --> 00:35:45,930
what the different elf sections are

880
00:35:44,010 --> 00:35:47,580
therefore when I look through the

881
00:35:45,930 --> 00:35:51,569
documentation notice there's something

882
00:35:47,580 --> 00:35:53,580
that's called the init array section

883
00:35:51,570 --> 00:35:54,930
this is an actual binary section and as

884
00:35:53,580 --> 00:35:57,450
you can see in the documentation of that

885
00:35:54,930 --> 00:35:59,669
in either a is that it contains pointers

886
00:35:57,450 --> 00:36:01,680
to functions which will be executed when

887
00:35:59,670 --> 00:36:03,780
the program starts no this is exciting

888
00:36:01,680 --> 00:36:05,850
so that means if I purchase any given

889
00:36:03,780 --> 00:36:07,290
pointer in there then the binary will

890
00:36:05,850 --> 00:36:09,270
just execute wherever that pointer

891
00:36:07,290 --> 00:36:14,430
points to and turns out this is exactly

892
00:36:09,270 --> 00:36:15,990
what happens and the elf format I'm

893
00:36:14,430 --> 00:36:17,700
perfectly whatever this has to be that

894
00:36:15,990 --> 00:36:19,890
way but the elf form it offers different

895
00:36:17,700 --> 00:36:23,129
sections like that which offer exactly

896
00:36:19,890 --> 00:36:24,720
the same mode of adding functionality to

897
00:36:23,130 --> 00:36:26,430
binary this is typically what the

898
00:36:24,720 --> 00:36:30,000
compiler does just imagine you're

899
00:36:26,430 --> 00:36:32,640
writing C++ source code and the compiler

900
00:36:30,000 --> 00:36:34,560
for you as a constructor to the binary

901
00:36:32,640 --> 00:36:37,529
which would need to be executed on load

902
00:36:34,560 --> 00:36:39,960
time then it would add that constructor

903
00:36:37,530 --> 00:36:41,550
to one of those point of chains which

904
00:36:39,960 --> 00:36:43,590
means that this constructor will be

905
00:36:41,550 --> 00:36:46,560
executed and this is all perfectly well

906
00:36:43,590 --> 00:36:48,000
well and behind except when you're

907
00:36:46,560 --> 00:36:51,060
inside the compiler and want to use it

908
00:36:48,000 --> 00:36:52,650
so I went ahead and wrote a simple proof

909
00:36:51,060 --> 00:36:55,470
of concept which is really very

910
00:36:52,650 --> 00:36:57,540
straightforward where I edit a given

911
00:36:55,470 --> 00:37:03,990
function which will execute another

912
00:36:57,540 --> 00:37:06,330
abacus to my victim binary and as as

913
00:37:03,990 --> 00:37:08,279
simple as it sounds like it is one thing

914
00:37:06,330 --> 00:37:11,790
of function call inside of the plugin

915
00:37:08,280 --> 00:37:15,450
which will add this as a constructor to

916
00:37:11,790 --> 00:37:16,890
my ended array section and the source

917
00:37:15,450 --> 00:37:19,200
code here on the left side which you can

918
00:37:16,890 --> 00:37:21,270
see is a simple function which is called

919
00:37:19,200 --> 00:37:23,819
output pop-punk lit which does nothing

920
00:37:21,270 --> 00:37:26,100
else than popping another abacus which

921
00:37:23,820 --> 00:37:28,280
literally just adds a given function to

922
00:37:26,100 --> 00:37:31,650
the output of GCC

923
00:37:28,280 --> 00:37:33,060
at this point in time let me show you

924
00:37:31,650 --> 00:37:43,730
the demo that we're gonna talk about how

925
00:37:33,060 --> 00:37:43,730
this is working demo demodex

926
00:37:44,250 --> 00:37:50,960
whoops in it right here

927
00:37:49,400 --> 00:37:55,070
so this is what I've been talking about

928
00:37:50,960 --> 00:37:57,520
in here the init array demo folder we

929
00:37:55,070 --> 00:38:01,640
have a file that's called test dot C

930
00:37:57,520 --> 00:38:03,680
which is very useless as well all it

931
00:38:01,640 --> 00:38:09,560
does is it contains a super pointless

932
00:38:03,680 --> 00:38:13,490
function which initializes an array with

933
00:38:09,560 --> 00:38:15,259
with minus ones with FF it is called in

934
00:38:13,490 --> 00:38:16,399
the main function and the main function

935
00:38:15,260 --> 00:38:17,690
also prints that there's absolutely

936
00:38:16,400 --> 00:38:20,150
nothing to see there see I can say that

937
00:38:17,690 --> 00:38:25,520
this source code will not do very much

938
00:38:20,150 --> 00:38:27,800
if we execute it and as we would expect

939
00:38:25,520 --> 00:38:31,670
when we compile it without any

940
00:38:27,800 --> 00:38:34,430
interference we can see that the test

941
00:38:31,670 --> 00:38:35,780
binary really just friends nothing to

942
00:38:34,430 --> 00:38:38,450
see here this is all the binary that's

943
00:38:35,780 --> 00:38:40,810
very exciting but if we go ahead and

944
00:38:38,450 --> 00:38:42,710
compile it with my little in it array

945
00:38:40,810 --> 00:38:45,830
modification you can see I load the

946
00:38:42,710 --> 00:38:47,120
plugin which is called pop Stata so we

947
00:38:45,830 --> 00:38:49,100
compile again and all of a sudden we

948
00:38:47,120 --> 00:38:51,740
execute the test whether in did to them

949
00:38:49,100 --> 00:38:56,569
there's another epic Asst surprise

950
00:38:51,740 --> 00:39:04,580
surprise how did we do this that's my

951
00:38:56,570 --> 00:39:06,650
presentation there you go how did we do

952
00:39:04,580 --> 00:39:08,480
this so again by calling this function

953
00:39:06,650 --> 00:39:11,840
called default elf in an array as an out

954
00:39:08,480 --> 00:39:14,840
constructor very self speaking API names

955
00:39:11,840 --> 00:39:18,350
inside of GCC if we call it we can add a

956
00:39:14,840 --> 00:39:20,540
symbol to the init array section which

957
00:39:18,350 --> 00:39:23,299
in our case points to the function which

958
00:39:20,540 --> 00:39:26,270
is called pop underscore phone clip by

959
00:39:23,300 --> 00:39:28,280
creating a symbol reference in GCC's RTL

960
00:39:26,270 --> 00:39:29,960
stages we create an actual pointer to a

961
00:39:28,280 --> 00:39:32,320
given symbol which will be added to the

962
00:39:29,960 --> 00:39:34,880
symbol table of the compiler and

963
00:39:32,320 --> 00:39:37,790
instruct the compiler to output that to

964
00:39:34,880 --> 00:39:40,540
the assembly output on the left side of

965
00:39:37,790 --> 00:39:43,190
the screen you can see as mentioned the

966
00:39:40,540 --> 00:39:45,020
construction of that function so first

967
00:39:43,190 --> 00:39:46,460
of all we need a symbol that points to

968
00:39:45,020 --> 00:39:49,160
our function and of course we need to

969
00:39:46,460 --> 00:39:50,720
output the function itself it only took

970
00:39:49,160 --> 00:39:53,060
me about the math to figure out how to

971
00:39:50,720 --> 00:39:54,589
add a function inside of the compiler

972
00:39:53,060 --> 00:39:56,630
which will end up in the actual binary

973
00:39:54,590 --> 00:39:58,280
if you look at this closely you will see

974
00:39:56,630 --> 00:39:59,870
that there are lots of printf Center and

975
00:39:58,280 --> 00:40:02,300
actual as these strings that show

976
00:39:59,870 --> 00:40:03,109
assembly instructions which for me in

977
00:40:02,300 --> 00:40:06,019
the beginning was rather

978
00:40:03,109 --> 00:40:08,749
confusing because yes really we use f

979
00:40:06,019 --> 00:40:12,140
printf to print three azzam out file

980
00:40:08,749 --> 00:40:13,759
inside of the RTL banks um it's banality

981
00:40:12,140 --> 00:40:17,420
I'm not exactly sure this is the best

982
00:40:13,759 --> 00:40:18,799
and most beautiful way it was the first

983
00:40:17,420 --> 00:40:20,959
and the only way that I could find how

984
00:40:18,799 --> 00:40:25,339
to actually influence the functions

985
00:40:20,959 --> 00:40:28,219
inside of the output binary and I'm

986
00:40:25,339 --> 00:40:30,349
talking here like it's an output binary

987
00:40:28,219 --> 00:40:33,380
that I'm modifying if friend F is

988
00:40:30,349 --> 00:40:36,019
important to mention because what GCC

989
00:40:33,380 --> 00:40:38,029
itself actually is it's not one binary

990
00:40:36,019 --> 00:40:39,799
one compiler that does the whole

991
00:40:38,029 --> 00:40:43,309
modification from source code to

992
00:40:39,799 --> 00:40:45,499
executable GCC by itself is just a

993
00:40:43,309 --> 00:40:49,509
driver which instruments different tools

994
00:40:45,499 --> 00:40:51,769
that new provides for compiling binaries

995
00:40:49,509 --> 00:40:52,880
Jesuses all stands for the new compiler

996
00:40:51,769 --> 00:40:54,828
collection you might have heard that

997
00:40:52,880 --> 00:40:57,259
before and that actually means that GCC

998
00:40:54,829 --> 00:41:00,499
itself is the compiler if you're

999
00:40:57,259 --> 00:41:02,539
compiling C fast it would be CC one it

1000
00:41:00,499 --> 00:41:05,988
is also the assembler which is techno

1001
00:41:02,539 --> 00:41:08,569
assembler also called GIS or AAS which

1002
00:41:05,989 --> 00:41:10,819
takes in the assembly output the

1003
00:41:08,569 --> 00:41:14,109
text-based assembly output from the

1004
00:41:10,819 --> 00:41:16,940
compiler and assembles it into bytecode

1005
00:41:14,109 --> 00:41:19,098
and at the last stage you have the

1006
00:41:16,940 --> 00:41:20,989
linker which takes the output byte code

1007
00:41:19,099 --> 00:41:22,719
and links it together to an object file

1008
00:41:20,989 --> 00:41:25,400
or to an executable that one can load

1009
00:41:22,719 --> 00:41:27,140
here to reset is that what the compiler

1010
00:41:25,400 --> 00:41:29,930
actually output so what you can do when

1011
00:41:27,140 --> 00:41:32,359
you work on plugins or inside of the

1012
00:41:29,930 --> 00:41:34,399
main cheesy source base you can modify

1013
00:41:32,359 --> 00:41:37,069
how cheesy outputs the text-based

1014
00:41:34,400 --> 00:41:38,989
assembly representation which is why F

1015
00:41:37,069 --> 00:41:41,180
printf is great if you actually want to

1016
00:41:38,989 --> 00:41:42,619
add functions to the output subscribe if

1017
00:41:41,180 --> 00:41:46,899
you ever want to try you can execute

1018
00:41:42,619 --> 00:41:49,880
Jesus Eve with the DES ish this is is

1019
00:41:46,900 --> 00:41:52,430
it's like which gives you the assembly

1020
00:41:49,880 --> 00:41:53,509
output instead of the binary that GCC

1021
00:41:52,430 --> 00:41:55,819
would create that means that the

1022
00:41:53,509 --> 00:41:58,219
compilation process pops after CC one

1023
00:41:55,819 --> 00:42:00,469
and you only get to see the text-based

1024
00:41:58,219 --> 00:42:03,650
Assembly representation which can then

1025
00:42:00,469 --> 00:42:06,829
be consumed by the AAS tool the

1026
00:42:03,650 --> 00:42:09,199
assembler and further modified to the

1027
00:42:06,829 --> 00:42:11,029
actual bytecode this is very helpful for

1028
00:42:09,199 --> 00:42:14,150
us which means that if we apply

1029
00:42:11,029 --> 00:42:16,049
modifications to the GCC base itself we

1030
00:42:14,150 --> 00:42:17,489
can check in the assembly output where

1031
00:42:16,049 --> 00:42:19,890
there are simply actually ended up there

1032
00:42:17,489 --> 00:42:22,160
and what you see there is the pop funk

1033
00:42:19,890 --> 00:42:25,650
'let that I introduced to the source and

1034
00:42:22,160 --> 00:42:27,029
in there you see the call x''k L which I

1035
00:42:25,650 --> 00:42:28,739
just rolled in there as a piece of text

1036
00:42:27,029 --> 00:42:30,979
and now here's a nice piece of homework

1037
00:42:28,739 --> 00:42:34,349
if you want to try write a simple C file

1038
00:42:30,979 --> 00:42:36,779
which doesn't import any headers but

1039
00:42:34,349 --> 00:42:38,699
just execute call to an excel and

1040
00:42:36,779 --> 00:42:40,229
execute an application and you will see

1041
00:42:38,699 --> 00:42:42,599
that their compiler still compiles it

1042
00:42:40,229 --> 00:42:44,819
your link are still links it and your

1043
00:42:42,599 --> 00:42:47,369
system still executed and execute the

1044
00:42:44,819 --> 00:42:51,209
call execute because as it turns out the

1045
00:42:47,369 --> 00:42:53,249
chillip see by default if you don't set

1046
00:42:51,209 --> 00:42:55,589
certain compiles likes is used to

1047
00:42:53,249 --> 00:42:57,479
compile and Link any given C file that

1048
00:42:55,589 --> 00:42:59,549
the compiled on a Linux system which

1049
00:42:57,479 --> 00:43:01,828
means if you're an editor and you're

1050
00:42:59,549 --> 00:43:04,170
modifying the source code and you're

1051
00:43:01,829 --> 00:43:06,719
adding calls to functions that are

1052
00:43:04,170 --> 00:43:09,989
located in your chillip see if the

1053
00:43:06,719 --> 00:43:12,239
binary is not compiled without the use

1054
00:43:09,989 --> 00:43:16,019
of GCC which is a dedicated Slyke that

1055
00:43:12,239 --> 00:43:17,699
needs to be mentioned then any call you

1056
00:43:16,019 --> 00:43:19,410
insert there will be happily picked up

1057
00:43:17,699 --> 00:43:21,329
by the linker and happily edits to the

1058
00:43:19,410 --> 00:43:23,219
linkage table and hypertech's acute at

1059
00:43:21,329 --> 00:43:24,989
runtime you don't actually need a given

1060
00:43:23,219 --> 00:43:29,759
header file to be included or a given

1061
00:43:24,989 --> 00:43:31,170
library to be explicitly included this

1062
00:43:29,759 --> 00:43:33,779
was about it this is how it looks like

1063
00:43:31,170 --> 00:43:35,309
we have the assembly finally this is the

1064
00:43:33,779 --> 00:43:37,529
object timeout we have the assembly in

1065
00:43:35,309 --> 00:43:40,890
the file and you can see in the init

1066
00:43:37,529 --> 00:43:42,479
array section you have a pointer which

1067
00:43:40,890 --> 00:43:46,379
you see down here to the actual pop

1068
00:43:42,479 --> 00:43:48,269
function function Weehoo super simple

1069
00:43:46,380 --> 00:43:51,599
and super obvious if you're looking for

1070
00:43:48,269 --> 00:43:54,089
source changes I'm sorry this needle

1071
00:43:51,599 --> 00:43:55,769
someone please give me a haystack I

1072
00:43:54,089 --> 00:43:58,769
mentioned before this kind of obvious if

1073
00:43:55,769 --> 00:44:00,419
you add a plug in binary plugins or

1074
00:43:58,769 --> 00:44:03,238
shared libraries that need to be

1075
00:44:00,420 --> 00:44:05,160
somewhere in the file system and the GCC

1076
00:44:03,239 --> 00:44:08,309
command line needs to know where those

1077
00:44:05,160 --> 00:44:09,660
those objects lie and needs to know that

1078
00:44:08,309 --> 00:44:11,400
it has to load those into the

1079
00:44:09,660 --> 00:44:14,359
compilation process so it's kind of

1080
00:44:11,400 --> 00:44:17,009
obvious if you want to place a plug-in

1081
00:44:14,359 --> 00:44:18,420
into the build chain the problem that

1082
00:44:17,009 --> 00:44:20,670
the rise is there though at some point I

1083
00:44:18,420 --> 00:44:21,989
try to actually look into a compiled

1084
00:44:20,670 --> 00:44:23,910
plug-in and try to figure out what it

1085
00:44:21,989 --> 00:44:25,589
does and turns out if you don't know how

1086
00:44:23,910 --> 00:44:27,209
ECC works and if you don't now how the

1087
00:44:25,589 --> 00:44:29,400
intermediate representations look like

1088
00:44:27,209 --> 00:44:30,569
all your reverse engineering skills

1089
00:44:29,400 --> 00:44:32,730
we'll just tell you how the assembly

1090
00:44:30,570 --> 00:44:34,440
inside of the plugin looks like it will

1091
00:44:32,730 --> 00:44:37,320
not tell you at all what this plug-in

1092
00:44:34,440 --> 00:44:39,090
does so thinking about forensics

1093
00:44:37,320 --> 00:44:41,820
investigation that tries to figure out

1094
00:44:39,090 --> 00:44:44,930
which changes given plug-in applied to a

1095
00:44:41,820 --> 00:44:47,070
given output binary are absolutely mute

1096
00:44:44,930 --> 00:44:48,810
I'm saying absolutely if there's some

1097
00:44:47,070 --> 00:44:50,880
motivated reverse engineers necrotic and

1098
00:44:48,810 --> 00:44:52,410
happily share a plugin and you try your

1099
00:44:50,880 --> 00:44:55,890
luck it would be interesting to know

1100
00:44:52,410 --> 00:44:57,810
what you find in there on the other hand

1101
00:44:55,890 --> 00:45:00,150
if you want to be more stealthy and not

1102
00:44:57,810 --> 00:45:01,650
lower the plug-in you can still modify

1103
00:45:00,150 --> 00:45:03,210
cheese to see itself as mentioned you

1104
00:45:01,650 --> 00:45:07,500
have the same superpowers in there as

1105
00:45:03,210 --> 00:45:09,150
you have in a plugin it might take a

1106
00:45:07,500 --> 00:45:10,980
while though until your changes are

1107
00:45:09,150 --> 00:45:14,100
actually applied to the compiler and

1108
00:45:10,980 --> 00:45:17,450
stealthy or recompiling GCC and the

1109
00:45:14,100 --> 00:45:19,740
victims machine isn't all that easy

1110
00:45:17,450 --> 00:45:21,299
alright does mention binary code view is

1111
00:45:19,740 --> 00:45:23,009
kind of pointless and reproducible bills

1112
00:45:21,300 --> 00:45:25,890
would be what helps us find the actual

1113
00:45:23,010 --> 00:45:28,200
bugs that the compiler can introduce in

1114
00:45:25,890 --> 00:45:30,060
there but let me go ahead and show you

1115
00:45:28,200 --> 00:45:32,310
some more stealthy ways of adding bugs

1116
00:45:30,060 --> 00:45:35,400
to binary than just putting additional

1117
00:45:32,310 --> 00:45:37,279
source codes in the in the output so

1118
00:45:35,400 --> 00:45:39,830
let's go to the list of your stuff

1119
00:45:37,280 --> 00:45:44,700
something that I found out while

1120
00:45:39,830 --> 00:45:47,460
modifying indirect calls in a given

1121
00:45:44,700 --> 00:45:49,620
source base because turns out nowadays

1122
00:45:47,460 --> 00:45:53,570
everyone's really interested in indirect

1123
00:45:49,620 --> 00:45:56,430
branches in in files I did not say this

1124
00:45:53,570 --> 00:45:58,410
so enjoy that this this undertaking you

1125
00:45:56,430 --> 00:46:00,240
eventually will run into tail call

1126
00:45:58,410 --> 00:46:02,339
optimization tail call optimization

1127
00:46:00,240 --> 00:46:04,680
something that not only TCC but also

1128
00:46:02,340 --> 00:46:06,780
other mainstream compilers perform where

1129
00:46:04,680 --> 00:46:09,930
they try to reduce the number of calls

1130
00:46:06,780 --> 00:46:11,640
that are done in a in a binary and try

1131
00:46:09,930 --> 00:46:14,100
to eliminate them and replace them with

1132
00:46:11,640 --> 00:46:16,740
chumps given that at a given point in

1133
00:46:14,100 --> 00:46:19,529
time when a call is executed the stack

1134
00:46:16,740 --> 00:46:21,209
frame from the calling function is equal

1135
00:46:19,530 --> 00:46:23,400
to the stack frame that the code

1136
00:46:21,210 --> 00:46:25,440
function will use which means that a

1137
00:46:23,400 --> 00:46:27,870
function is called with in a different

1138
00:46:25,440 --> 00:46:29,880
sibling function which we reuses the

1139
00:46:27,870 --> 00:46:31,470
same stack of arguments and can reuse

1140
00:46:29,880 --> 00:46:33,450
the stack frame of the calling function

1141
00:46:31,470 --> 00:46:36,089
will be converted to a jump

1142
00:46:33,450 --> 00:46:40,020
because there need no changes be taken

1143
00:46:36,090 --> 00:46:40,940
to the stack frame it is all a little

1144
00:46:40,020 --> 00:46:42,730
bit

1145
00:46:40,940 --> 00:46:44,480
here we talking about compiler

1146
00:46:42,730 --> 00:46:45,950
optimizations and try to get your mind

1147
00:46:44,480 --> 00:46:47,480
in there in detail what's important for

1148
00:46:45,950 --> 00:46:49,069
us is that this is indicated by a che

1149
00:46:47,480 --> 00:46:50,720
flag so in the intermediate

1150
00:46:49,070 --> 00:46:53,360
representation you see a call

1151
00:46:50,720 --> 00:46:55,490
instruction swimming along and all that

1152
00:46:53,360 --> 00:46:57,710
diversify is this construction from a

1153
00:46:55,490 --> 00:46:59,479
regular construction is the che flag

1154
00:46:57,710 --> 00:47:02,090
which tells the compiler to instead of

1155
00:46:59,480 --> 00:47:03,980
cold put out the jump now what do we

1156
00:47:02,090 --> 00:47:06,940
think is attackers if we here : set of

1157
00:47:03,980 --> 00:47:11,480
champa drum instead of coal this is like

1158
00:47:06,940 --> 00:47:13,490
if we modify a jump into a coal that

1159
00:47:11,480 --> 00:47:16,040
would work just like the chump could

1160
00:47:13,490 --> 00:47:18,200
then we can sneak in an extra return

1161
00:47:16,040 --> 00:47:20,029
value to the stack and make our

1162
00:47:18,200 --> 00:47:24,109
application return to any given other

1163
00:47:20,030 --> 00:47:26,540
spot where we wanted to return to easier

1164
00:47:24,110 --> 00:47:27,740
said than done let's look at this output

1165
00:47:26,540 --> 00:47:31,190
for a minute which comes from the

1166
00:47:27,740 --> 00:47:33,770
compiler Explorer where we see this

1167
00:47:31,190 --> 00:47:36,530
simple piece of source code which shows

1168
00:47:33,770 --> 00:47:38,780
that there is a printf call which is

1169
00:47:36,530 --> 00:47:43,220
located right before a different printf

1170
00:47:38,780 --> 00:47:45,980
call can be modified into a it can be

1171
00:47:43,220 --> 00:47:48,290
optimized as a tail call if you don't

1172
00:47:45,980 --> 00:47:49,550
apply any optimization this is the

1173
00:47:48,290 --> 00:47:51,500
output of the compiler without

1174
00:47:49,550 --> 00:47:54,440
optimization you see in the yellow part

1175
00:47:51,500 --> 00:47:56,900
down here there's a call to put string

1176
00:47:54,440 --> 00:47:58,670
this is unoptimized this is one call

1177
00:47:56,900 --> 00:48:02,240
after another as you would expect the

1178
00:47:58,670 --> 00:48:04,700
compiler to put out now if we apply tail

1179
00:48:02,240 --> 00:48:07,459
call optimization all of a sudden our

1180
00:48:04,700 --> 00:48:10,310
output looks like this we see that the

1181
00:48:07,460 --> 00:48:13,100
yellow line has been split up down here

1182
00:48:10,310 --> 00:48:17,299
into one move instruction and one jump

1183
00:48:13,100 --> 00:48:19,750
instruction which essentially is the

1184
00:48:17,300 --> 00:48:23,060
same as this call to printf up here

1185
00:48:19,750 --> 00:48:25,640
except that down here we use a jump and

1186
00:48:23,060 --> 00:48:28,370
reuse the call frame of the function up

1187
00:48:25,640 --> 00:48:30,279
here because you can see that the layout

1188
00:48:28,370 --> 00:48:32,779
of the arguments is pretty much the same

1189
00:48:30,280 --> 00:48:34,940
this is what tail call optimization does

1190
00:48:32,780 --> 00:48:36,560
for you all of a sudden at the end of a

1191
00:48:34,940 --> 00:48:39,470
given binary and this again this works

1192
00:48:36,560 --> 00:48:40,730
only at the end of a given function all

1193
00:48:39,470 --> 00:48:43,450
of a sudden you see a jump instruction

1194
00:48:40,730 --> 00:48:46,040
there which should be a co instruction

1195
00:48:43,450 --> 00:48:49,759
it only works at the end of a function

1196
00:48:46,040 --> 00:48:51,800
because the jump that were using will

1197
00:48:49,760 --> 00:48:53,970
jump to another function which will

1198
00:48:51,800 --> 00:48:56,549
eventually execute the return statement

1199
00:48:53,970 --> 00:48:58,470
and this return statement will fetch the

1200
00:48:56,549 --> 00:48:59,970
original return value from the stack

1201
00:48:58,470 --> 00:49:01,950
that the calling function was using

1202
00:48:59,970 --> 00:49:03,959
which means as soon as the the the

1203
00:49:01,950 --> 00:49:06,210
called puts down their returns it will

1204
00:49:03,960 --> 00:49:08,609
return to the color of the caller and

1205
00:49:06,210 --> 00:49:10,589
this way with chaining these returns we

1206
00:49:08,609 --> 00:49:12,240
can save one return and we can save an

1207
00:49:10,589 --> 00:49:14,490
entire construction what's it with the

1208
00:49:12,240 --> 00:49:16,109
constructions constructions use up a lot

1209
00:49:14,490 --> 00:49:18,660
of time and CPU power and they're very

1210
00:49:16,109 --> 00:49:20,400
expensive in terms of executions if you

1211
00:49:18,660 --> 00:49:22,950
can switch the construction touch on

1212
00:49:20,400 --> 00:49:27,210
restriction you can save those valuable

1213
00:49:22,950 --> 00:49:29,129
milliseconds that optimizations after if

1214
00:49:27,210 --> 00:49:31,829
you want to optimize this really easy we

1215
00:49:29,130 --> 00:49:33,690
have to locate the function where our

1216
00:49:31,829 --> 00:49:35,369
changes are feasible we have to look at

1217
00:49:33,690 --> 00:49:37,260
the function where if we change jump

1218
00:49:35,369 --> 00:49:39,390
into a call we do not mess up the stick

1219
00:49:37,260 --> 00:49:40,980
the stack is important and the stack is

1220
00:49:39,390 --> 00:49:42,390
vicious and then you change to the stack

1221
00:49:40,980 --> 00:49:45,510
will eventually come back to you and

1222
00:49:42,390 --> 00:49:49,078
hunt you and of course you have to watch

1223
00:49:45,510 --> 00:49:51,119
out in most cases if you're in a real

1224
00:49:49,079 --> 00:49:53,339
application you need to take care of the

1225
00:49:51,119 --> 00:49:55,589
changes you do and revert them after you

1226
00:49:53,339 --> 00:49:57,690
modified your your return value at one

1227
00:49:55,589 --> 00:49:59,609
or another end and you will need to do

1228
00:49:57,690 --> 00:50:01,289
cleanup and save values and restore

1229
00:49:59,609 --> 00:50:02,759
values this is something that just comes

1230
00:50:01,289 --> 00:50:04,380
with the nature of the thing and again

1231
00:50:02,760 --> 00:50:05,549
here the register allocator isn't your

1232
00:50:04,380 --> 00:50:07,829
friend either you have to watch out

1233
00:50:05,549 --> 00:50:09,630
which register to use and whether those

1234
00:50:07,829 --> 00:50:13,380
registers are still available once you

1235
00:50:09,630 --> 00:50:15,559
return from your malicious function and

1236
00:50:13,380 --> 00:50:17,490
of course the linker is not a friend to

1237
00:50:15,559 --> 00:50:19,260
something I found out I'm working on

1238
00:50:17,490 --> 00:50:22,348
tail causes that I have very little

1239
00:50:19,260 --> 00:50:24,420
control over where in the source code

1240
00:50:22,349 --> 00:50:28,920
the given function will be located did I

1241
00:50:24,420 --> 00:50:31,020
put in there running out of time let's

1242
00:50:28,920 --> 00:50:32,760
go a little faster again though database

1243
00:50:31,020 --> 00:50:33,900
software was harmed in the making of

1244
00:50:32,760 --> 00:50:36,599
this presentation it didn't actually

1245
00:50:33,900 --> 00:50:39,510
mess with the Escalades were scared but

1246
00:50:36,599 --> 00:50:41,579
happiness I found a tail call inside of

1247
00:50:39,510 --> 00:50:43,859
escalator actually in the sqlite3 open

1248
00:50:41,579 --> 00:50:45,839
function we see that open receives those

1249
00:50:43,859 --> 00:50:47,788
two arguments and then cause open

1250
00:50:45,839 --> 00:50:49,410
database which has a very similar stack

1251
00:50:47,789 --> 00:50:52,740
frame it receives the same arguments

1252
00:50:49,410 --> 00:50:55,220
extended by a couple more now if we look

1253
00:50:52,740 --> 00:50:58,080
at this in the December

1254
00:50:55,220 --> 00:51:00,600
if you look at this in a disassembler we

1255
00:50:58,080 --> 00:51:02,700
see that originally without optimization

1256
00:51:00,600 --> 00:51:04,020
or without our modifications the

1257
00:51:02,700 --> 00:51:06,720
malicious modification we put in there

1258
00:51:04,020 --> 00:51:09,060
the call will be tail call optimized

1259
00:51:06,720 --> 00:51:11,609
which means the call to the open

1260
00:51:09,060 --> 00:51:12,360
database function will be reduced to a

1261
00:51:11,610 --> 00:51:14,310
chump

1262
00:51:12,360 --> 00:51:17,850
which means that when open database

1263
00:51:14,310 --> 00:51:20,580
returns it will reuse the return value

1264
00:51:17,850 --> 00:51:24,900
that SQLite open would have been using

1265
00:51:20,580 --> 00:51:27,870
upon its return and jumps to stack

1266
00:51:24,900 --> 00:51:29,610
frames upwards which means when open

1267
00:51:27,870 --> 00:51:33,720
database returns it will return to the

1268
00:51:29,610 --> 00:51:37,740
caller of SQLite open beautiful now if

1269
00:51:33,720 --> 00:51:39,180
we go ahead and modify the binary we can

1270
00:51:37,740 --> 00:51:41,279
switch this jump instruction into a

1271
00:51:39,180 --> 00:51:43,470
construction which means that we end up

1272
00:51:41,280 --> 00:51:45,360
having an extra return value in the

1273
00:51:43,470 --> 00:51:47,759
stack and all that we essentially need

1274
00:51:45,360 --> 00:51:51,780
to change to modify the behavior of this

1275
00:51:47,760 --> 00:51:54,510
return of this chained return in fact is

1276
00:51:51,780 --> 00:51:57,210
that we have to sneak in another address

1277
00:51:54,510 --> 00:51:59,280
which will be returned to this is like

1278
00:51:57,210 --> 00:52:01,050
overriding the return value of a

1279
00:51:59,280 --> 00:52:01,470
function just that the compiler does it

1280
00:52:01,050 --> 00:52:04,050
for you

1281
00:52:01,470 --> 00:52:06,240
lots of means though our malicious code

1282
00:52:04,050 --> 00:52:08,250
needs to be located in the binary

1283
00:52:06,240 --> 00:52:10,080
already there's very little possibility

1284
00:52:08,250 --> 00:52:11,700
of sneaking shortcut in there and the

1285
00:52:10,080 --> 00:52:13,770
bigger problem we face there is that we

1286
00:52:11,700 --> 00:52:15,390
have to trust that the linker puts a

1287
00:52:13,770 --> 00:52:18,509
given function which contains our

1288
00:52:15,390 --> 00:52:22,109
malicious activity right after the tail

1289
00:52:18,510 --> 00:52:23,970
call optimized function in our case here

1290
00:52:22,110 --> 00:52:25,920
I went ahead and modify the function

1291
00:52:23,970 --> 00:52:27,830
that's located right after in reality

1292
00:52:25,920 --> 00:52:31,290
that's a little bit more more tricky and

1293
00:52:27,830 --> 00:52:34,560
added another call to x ik l which in

1294
00:52:31,290 --> 00:52:36,270
the end will execute another abacus for

1295
00:52:34,560 --> 00:52:38,100
the sake of time I see I'm running out

1296
00:52:36,270 --> 00:52:39,840
quickly and I have one last demo which

1297
00:52:38,100 --> 00:52:42,299
is more interesting I'll skip this demo

1298
00:52:39,840 --> 00:52:43,620
at this point but be aware that the

1299
00:52:42,300 --> 00:52:45,450
things that you need to keep in mind if

1300
00:52:43,620 --> 00:52:48,029
you perform these kind of attacks is you

1301
00:52:45,450 --> 00:52:50,390
need to be be aware of the stack frame

1302
00:52:48,030 --> 00:52:52,800
you need to like spend lots of time on

1303
00:52:50,390 --> 00:52:55,350
analysis how the stack frame is used

1304
00:52:52,800 --> 00:52:57,660
after your your chump

1305
00:52:55,350 --> 00:53:00,270
slash call and make sure that you do not

1306
00:52:57,660 --> 00:53:04,250
mess up the layout what happens when I

1307
00:53:00,270 --> 00:53:06,780
wrote this proof of concept was that

1308
00:53:04,250 --> 00:53:08,300
three functions further down after the

1309
00:53:06,780 --> 00:53:11,150
call to open database there was

1310
00:53:08,300 --> 00:53:13,010
which fetched arguments from the stack

1311
00:53:11,150 --> 00:53:14,750
which in 64-bit is rather unlikely but

1312
00:53:13,010 --> 00:53:16,610
it happened and at this point in time

1313
00:53:14,750 --> 00:53:18,590
the Steckler they owe it would not be

1314
00:53:16,610 --> 00:53:21,200
the same if I wouldn't fix up the stack

1315
00:53:18,590 --> 00:53:22,850
layout before I actually execute the

1316
00:53:21,200 --> 00:53:25,460
jump this is rather easy it's just

1317
00:53:22,850 --> 00:53:28,069
sneaked in one pop instruction and the

1318
00:53:25,460 --> 00:53:30,710
attack still worked that much to be said

1319
00:53:28,070 --> 00:53:33,230
but okay we're almost done let's switch

1320
00:53:30,710 --> 00:53:37,310
to the last and my opinion most most

1321
00:53:33,230 --> 00:53:40,700
interesting way of attacking in a

1322
00:53:37,310 --> 00:53:42,110
conversation with with a peer of mine we

1323
00:53:40,700 --> 00:53:45,230
figured that all of these changes a

1324
00:53:42,110 --> 00:53:47,300
rather obvious because you're changing a

1325
00:53:45,230 --> 00:53:50,090
lot of bad hard binary how the output

1326
00:53:47,300 --> 00:53:52,460
binary looks like in terms of added

1327
00:53:50,090 --> 00:53:55,100
changes as well as in terms of added

1328
00:53:52,460 --> 00:53:57,620
behavior because as you can figure out

1329
00:53:55,100 --> 00:53:59,480
like if we have to fix up the stack

1330
00:53:57,620 --> 00:54:01,700
layout just so that our attack works

1331
00:53:59,480 --> 00:54:04,130
we're still adding a lot of changes into

1332
00:54:01,700 --> 00:54:06,830
the binary much easier it would be if we

1333
00:54:04,130 --> 00:54:09,470
used GCC internal functionality to

1334
00:54:06,830 --> 00:54:11,330
perform the actual attack for us and

1335
00:54:09,470 --> 00:54:15,049
another thing that I wanted to achieve

1336
00:54:11,330 --> 00:54:17,330
was to produce configurable bots you

1337
00:54:15,050 --> 00:54:19,730
will see if you modify your compiler it

1338
00:54:17,330 --> 00:54:21,410
will introduce bugs for you you're very

1339
00:54:19,730 --> 00:54:23,060
much set in these changes then you

1340
00:54:21,410 --> 00:54:24,910
perform to the compiler and afterwards

1341
00:54:23,060 --> 00:54:27,020
you have to trust that the compiler

1342
00:54:24,910 --> 00:54:29,270
essentially perfectly well performs this

1343
00:54:27,020 --> 00:54:32,450
thing is there it will be if we could

1344
00:54:29,270 --> 00:54:34,190
modify our own compiler but this is what

1345
00:54:32,450 --> 00:54:36,259
I came across built-ins and intrinsics

1346
00:54:34,190 --> 00:54:38,960
built-ins and intrinsics are a very

1347
00:54:36,260 --> 00:54:40,850
interesting subject solves a very large

1348
00:54:38,960 --> 00:54:43,100
piece of code inside of GCC and rather

1349
00:54:40,850 --> 00:54:44,870
complicated the simple explanation would

1350
00:54:43,100 --> 00:54:48,080
be that built-ins and in forensics are

1351
00:54:44,870 --> 00:54:49,520
there to add functionality to GCC in

1352
00:54:48,080 --> 00:54:51,560
order for TCC to be able to produce

1353
00:54:49,520 --> 00:54:53,360
better output which would mean that for

1354
00:54:51,560 --> 00:54:56,240
example machine specific functionality

1355
00:54:53,360 --> 00:54:57,950
is formulated in intrinsic or functions

1356
00:54:56,240 --> 00:55:00,140
that are frequently used and easily

1357
00:54:57,950 --> 00:55:00,589
optimized by GCC or formulated as

1358
00:55:00,140 --> 00:55:02,240
built-ins

1359
00:55:00,590 --> 00:55:04,100
so that GCC can pick which

1360
00:55:02,240 --> 00:55:05,540
implementation for example of the put

1361
00:55:04,100 --> 00:55:08,290
string function or which implementation

1362
00:55:05,540 --> 00:55:11,930
of a given man copy it wanted to use

1363
00:55:08,290 --> 00:55:13,610
this code look as follows if we look at

1364
00:55:11,930 --> 00:55:16,970
this very simple source code example

1365
00:55:13,610 --> 00:55:18,710
over here we see a mem copy which copies

1366
00:55:16,970 --> 00:55:20,870
a useless but far into another useless

1367
00:55:18,710 --> 00:55:22,099
buffer we say if we compile the source

1368
00:55:20,870 --> 00:55:24,529
code without Optima

1369
00:55:22,099 --> 00:55:26,059
session again we get one call after

1370
00:55:24,529 --> 00:55:28,220
another and everything is very clear and

1371
00:55:26,059 --> 00:55:30,950
understandable as opposed to when we

1372
00:55:28,220 --> 00:55:32,930
optimize as much as we can we say that

1373
00:55:30,950 --> 00:55:34,239
the whole piece was reduced to three

1374
00:55:32,930 --> 00:55:36,979
different instructions

1375
00:55:34,239 --> 00:55:39,410
this is buildings free this is where

1376
00:55:36,979 --> 00:55:41,029
Jesus he found out that the string line

1377
00:55:39,410 --> 00:55:43,519
function is absolutely useless because

1378
00:55:41,029 --> 00:55:45,410
we're looking at a static string at the

1379
00:55:43,519 --> 00:55:46,549
time of compilation we know how long the

1380
00:55:45,410 --> 00:55:48,470
string will be and the string is

1381
00:55:46,549 --> 00:55:51,380
constant it's not modifiable so we can

1382
00:55:48,470 --> 00:55:52,879
just skip the string length and replace

1383
00:55:51,380 --> 00:55:54,739
the value with a six because you know

1384
00:55:52,880 --> 00:55:56,299
it's six characters and also the mem

1385
00:55:54,739 --> 00:55:58,249
copy function down there the and are

1386
00:55:56,299 --> 00:56:01,549
calls rather useless because we can

1387
00:55:58,249 --> 00:56:03,558
replace the copying of six bytes with

1388
00:56:01,549 --> 00:56:05,059
two move instructions where we split up

1389
00:56:03,559 --> 00:56:07,819
in three and three bytes and copy those

1390
00:56:05,059 --> 00:56:09,410
to the actual destination so this will

1391
00:56:07,819 --> 00:56:11,989
be what buildings are and in that case

1392
00:56:09,410 --> 00:56:13,848
GCC needed to know how men copy looks

1393
00:56:11,989 --> 00:56:16,039
like inside how the input values look

1394
00:56:13,849 --> 00:56:17,900
like how their nature is like how the

1395
00:56:16,039 --> 00:56:21,979
rest of the binary is laid out in order

1396
00:56:17,900 --> 00:56:23,329
to perform this proper modification and

1397
00:56:21,979 --> 00:56:27,169
if you're interested you can go ahead

1398
00:56:23,329 --> 00:56:28,489
and monitor optimizations in GCC a bit

1399
00:56:27,170 --> 00:56:33,410
more it's fairly interesting to see

1400
00:56:28,489 --> 00:56:35,690
which changes GCC applies to man copy I

1401
00:56:33,410 --> 00:56:39,259
needed exercise would be for example to

1402
00:56:35,690 --> 00:56:41,410
walk with crap through all of the all of

1403
00:56:39,259 --> 00:56:44,390
the output dumps that GCC provides and

1404
00:56:41,410 --> 00:56:46,249
see where in the output dumps the

1405
00:56:44,390 --> 00:56:48,288
different costs mem copy pop up so if

1406
00:56:46,249 --> 00:56:50,328
you have a binary which just execute one

1407
00:56:48,289 --> 00:56:52,759
mem copy you can see for example without

1408
00:56:50,329 --> 00:56:54,170
optimization you can see that call

1409
00:56:52,759 --> 00:56:56,359
appear until the last stage of

1410
00:56:54,170 --> 00:56:58,219
compilation and without the my session

1411
00:56:56,359 --> 00:57:00,499
you see it disappear right after the

1412
00:56:58,219 --> 00:57:02,210
chamber passes which means in the RTL

1413
00:57:00,499 --> 00:57:05,058
presentations you wouldn't be able to

1414
00:57:02,210 --> 00:57:07,489
access this this call instruction

1415
00:57:05,059 --> 00:57:10,059
anymore what we could do is at the

1416
00:57:07,489 --> 00:57:12,859
cursor what we could be interested in is

1417
00:57:10,059 --> 00:57:16,190
extend a given man copy and make it more

1418
00:57:12,859 --> 00:57:17,598
efficient by copying more bytes so one

1419
00:57:16,190 --> 00:57:18,619
of the projects I was working on was

1420
00:57:17,599 --> 00:57:21,380
trying to spot

1421
00:57:18,619 --> 00:57:23,779
built-ins as they are being inlined into

1422
00:57:21,380 --> 00:57:26,299
a given binary what he can do in a

1423
00:57:23,779 --> 00:57:28,099
compiler plugin and you can tap into

1424
00:57:26,299 --> 00:57:30,049
different passes and you could

1425
00:57:28,099 --> 00:57:33,920
essentially go ahead and watch in which

1426
00:57:30,049 --> 00:57:35,930
pass a given call disappears so what I

1427
00:57:33,920 --> 00:57:38,510
did was I wrote a plug-in

1428
00:57:35,930 --> 00:57:40,640
looked at the very early compilation

1429
00:57:38,510 --> 00:57:42,500
stage and located my main copies and

1430
00:57:40,640 --> 00:57:44,390
where they were stored the location of

1431
00:57:42,500 --> 00:57:47,119
those mem copies and then tapped into a

1432
00:57:44,390 --> 00:57:48,920
very late compilation stage where those

1433
00:57:47,119 --> 00:57:51,049
mem copies are already in line and

1434
00:57:48,920 --> 00:57:55,010
there's no more call to man copy visible

1435
00:57:51,049 --> 00:57:58,099
and located those inlined instructions

1436
00:57:55,010 --> 00:58:03,859
and just extended them with a one byte

1437
00:57:58,099 --> 00:58:08,960
copy um two more minutes

1438
00:58:03,859 --> 00:58:10,578
however minutes can I use em I really

1439
00:58:08,960 --> 00:58:14,329
wanted to show you this this proof of

1440
00:58:10,579 --> 00:58:16,279
concept let's skip the theory let's look

1441
00:58:14,329 --> 00:58:18,890
at how it actually looks like so the

1442
00:58:16,279 --> 00:58:22,250
last thing for today five minutes good

1443
00:58:18,890 --> 00:58:24,170
good 30 seconds Pok what I wanted to

1444
00:58:22,250 --> 00:58:27,770
show you today is I have this very

1445
00:58:24,170 --> 00:58:32,059
useless source file again which is

1446
00:58:27,770 --> 00:58:35,150
called regular intrinsic stats e which

1447
00:58:32,059 --> 00:58:38,660
is a simple authentication method where

1448
00:58:35,150 --> 00:58:40,849
we have an if statement which checks

1449
00:58:38,660 --> 00:58:42,828
whether a given global authentication

1450
00:58:40,849 --> 00:58:45,109
variable equals zero and if it doesn't

1451
00:58:42,829 --> 00:58:47,359
then it will tell us not go away and if

1452
00:58:45,109 --> 00:58:49,160
it does it will execute our abacus again

1453
00:58:47,359 --> 00:58:51,140
you see that this variable is

1454
00:58:49,160 --> 00:58:53,808
initialized with zero so as the program

1455
00:58:51,140 --> 00:58:56,629
stands right now there is no way we can

1456
00:58:53,809 --> 00:58:59,869
get to the abacus execution but turns

1457
00:58:56,630 --> 00:59:02,000
out that before that is another mem copy

1458
00:58:59,869 --> 00:59:05,480
operation where we're trying to copy

1459
00:59:02,000 --> 00:59:07,130
exactly 96 very useless characters as

1460
00:59:05,480 --> 00:59:09,049
you see up here from one buffer to

1461
00:59:07,130 --> 00:59:10,789
another just imagine that this is a

1462
00:59:09,049 --> 00:59:13,309
proper application and there's a proper

1463
00:59:10,789 --> 00:59:16,309
man copy which copies exactly 96 bytes

1464
00:59:13,309 --> 00:59:18,349
what can we do now in the role of a

1465
00:59:16,309 --> 00:59:20,359
compiler was we could go ahead and look

1466
00:59:18,349 --> 00:59:21,680
for mem copies we could also go ahead

1467
00:59:20,359 --> 00:59:24,020
and look for mem copies that copy

1468
00:59:21,680 --> 00:59:27,379
exactly 96 bytes lika go ahead look from

1469
00:59:24,020 --> 00:59:30,230
M copies to copy 2638 bytes whatever

1470
00:59:27,380 --> 00:59:32,029
like we could agree with ourselves for a

1471
00:59:30,230 --> 00:59:34,099
given size that we're interested in and

1472
00:59:32,029 --> 00:59:36,680
then tap into the processing of this man

1473
00:59:34,099 --> 00:59:38,270
copy operation now what I did was my

1474
00:59:36,680 --> 00:59:39,799
plugin was doing exactly that I looked

1475
00:59:38,270 --> 00:59:41,750
for a mem copy of Britishness published

1476
00:59:39,799 --> 00:59:44,000
96 bytes and extended that copy

1477
00:59:41,750 --> 00:59:46,849
operation by exactly one byte and that

1478
00:59:44,000 --> 00:59:48,640
byte will override our authentication

1479
00:59:46,849 --> 00:59:53,680
variable

1480
00:59:48,640 --> 00:59:56,290
and now if I show you how this works I

1481
00:59:53,680 --> 00:59:59,319
can compile again with my malicious

1482
00:59:56,290 --> 01:00:01,450
plugin and if you look at the source

1483
00:59:59,320 --> 01:00:04,690
code again we couldn't actually execute

1484
01:00:01,450 --> 01:00:06,730
the abacus application anyway except

1485
01:00:04,690 --> 01:00:10,020
since I compiled it now all of a sudden

1486
01:00:06,730 --> 01:00:13,690
the authentication variable equals zero

1487
01:00:10,020 --> 01:00:16,090
or equals one sorry now if you execute

1488
01:00:13,690 --> 01:00:17,500
you see the abacus again this is what an

1489
01:00:16,090 --> 01:00:19,180
ad that crooked ooh mm-hmm

1490
01:00:17,500 --> 01:00:22,750
if you look at how this looks in the

1491
01:00:19,180 --> 01:00:25,000
binary it is rather stealthy I know

1492
01:00:22,750 --> 01:00:27,790
there's probably some very very good

1493
01:00:25,000 --> 01:00:30,220
reverse engineers in the audience but

1494
01:00:27,790 --> 01:00:32,560
honestly to figure out that this in line

1495
01:00:30,220 --> 01:00:34,240
man copy function copies exactly one

1496
01:00:32,560 --> 01:00:37,240
byte too much as you can see on top of

1497
01:00:34,240 --> 01:00:38,560
the screen is a very very hard task so

1498
01:00:37,240 --> 01:00:40,720
if you're looking for the bug that this

1499
01:00:38,560 --> 01:00:42,220
compiler plug and insert it I'm fishing

1500
01:00:40,720 --> 01:00:45,310
a very good luck and trying to figure

1501
01:00:42,220 --> 01:00:50,620
out how this mem copy was supposed to

1502
01:00:45,310 --> 01:00:52,029
work originally all right yeah again how

1503
01:00:50,620 --> 01:00:54,040
did I do this except into two different

1504
01:00:52,030 --> 01:00:56,050
compiler passes a figure out where the

1505
01:00:54,040 --> 01:00:57,570
original call was located I remembered

1506
01:00:56,050 --> 01:01:00,250
where in the source code it was

1507
01:00:57,570 --> 01:01:02,950
thankfully the RTL representation still

1508
01:01:00,250 --> 01:01:05,440
stores source code locations which means

1509
01:01:02,950 --> 01:01:09,089
if you look at something in source line

1510
01:01:05,440 --> 01:01:12,610
24 inch in pole you can figure out which

1511
01:01:09,090 --> 01:01:14,830
RTL instructions the source code line 24

1512
01:01:12,610 --> 01:01:17,350
referred to in the RTR presentations

1513
01:01:14,830 --> 01:01:19,509
which means that in the end you see five

1514
01:01:17,350 --> 01:01:23,350
instructions which equal your German

1515
01:01:19,510 --> 01:01:26,470
copy and in the second pass that I added

1516
01:01:23,350 --> 01:01:28,720
I looked for the inline memo P and edit

1517
01:01:26,470 --> 01:01:30,580
my one byte copy now the interesting

1518
01:01:28,720 --> 01:01:33,459
functionality that you could add doing

1519
01:01:30,580 --> 01:01:36,040
so is that actually through the mem copy

1520
01:01:33,460 --> 01:01:38,380
operation and given a ticker could hand

1521
01:01:36,040 --> 01:01:40,660
over configuration data which means not

1522
01:01:38,380 --> 01:01:42,850
only the 96 bytes could be an indicator

1523
01:01:40,660 --> 01:01:45,790
for the plugin but also the content

1524
01:01:42,850 --> 01:01:47,890
that's being mem copied with or without

1525
01:01:45,790 --> 01:01:50,140
use whatsoever could contain

1526
01:01:47,890 --> 01:01:51,400
configuration data that the second part

1527
01:01:50,140 --> 01:01:54,460
of the plugin could be shared which

1528
01:01:51,400 --> 01:01:58,060
means that as an attacker writing source

1529
01:01:54,460 --> 01:02:00,850
code that we want to contain a bug once

1530
01:01:58,060 --> 01:02:01,810
it's compiled we could insert a very

1531
01:02:00,850 --> 01:02:04,160
well-crafted

1532
01:02:01,810 --> 01:02:06,770
String are very well crafted piece of

1533
01:02:04,160 --> 01:02:08,569
data which tells the compiler where to

1534
01:02:06,770 --> 01:02:11,119
apply a given modification that the

1535
01:02:08,570 --> 01:02:12,770
compiler has then we'll insert and these

1536
01:02:11,119 --> 01:02:15,820
are very tricky parts as it just saw in

1537
01:02:12,770 --> 01:02:18,350
that are in the end very hard to find I

1538
01:02:15,820 --> 01:02:20,480
see I have one minute left from my

1539
01:02:18,350 --> 01:02:22,970
original time which is amazing because

1540
01:02:20,480 --> 01:02:25,490
I'm out almost done now what would you

1541
01:02:22,970 --> 01:02:27,740
do about this I mentioned before reverse

1542
01:02:25,490 --> 01:02:29,419
engineering a plug-in is not a task you

1543
01:02:27,740 --> 01:02:32,299
would look forward to if that was on

1544
01:02:29,420 --> 01:02:33,560
your table it would be possible or

1545
01:02:32,300 --> 01:02:36,970
reverse engineering anything is possible

1546
01:02:33,560 --> 01:02:39,920
but in practice it's not very feasible

1547
01:02:36,970 --> 01:02:41,419
diffing binaries and finding pieces of

1548
01:02:39,920 --> 01:02:43,460
source code that were added as possible

1549
01:02:41,420 --> 01:02:45,770
differing binaries and finding single

1550
01:02:43,460 --> 01:02:47,840
instructions that were added is tricky

1551
01:02:45,770 --> 01:02:49,850
as well you would have to have a very

1552
01:02:47,840 --> 01:02:51,140
fine-grain sniffing process and you

1553
01:02:49,850 --> 01:02:53,839
would probably spend a lot of time

1554
01:02:51,140 --> 01:02:55,129
looking and false positives what is the

1555
01:02:53,840 --> 01:02:57,350
thing that it could do about this was

1556
01:02:55,130 --> 01:02:58,400
relying on her producible builds and I

1557
01:02:57,350 --> 01:02:59,630
mentioned this like I know what I'm

1558
01:02:58,400 --> 01:03:01,640
talking about it I have not actually

1559
01:02:59,630 --> 01:03:03,680
looked into how reliable producible

1560
01:03:01,640 --> 01:03:05,660
builds would be and guaranteeing that no

1561
01:03:03,680 --> 01:03:07,100
malicious modifications were taken this

1562
01:03:05,660 --> 01:03:08,660
is the thing that I could recommend and

1563
01:03:07,100 --> 01:03:11,690
something that is absolutely and totally

1564
01:03:08,660 --> 01:03:12,500
and undeniably recommendable it's look

1565
01:03:11,690 --> 01:03:15,170
at your mic files

1566
01:03:12,500 --> 01:03:16,970
watch your build scripts take care of

1567
01:03:15,170 --> 01:03:18,530
your build chain let no-one ever touch

1568
01:03:16,970 --> 01:03:20,209
your compiler another one ever add

1569
01:03:18,530 --> 01:03:22,310
binary is through your compilation

1570
01:03:20,210 --> 01:03:24,230
machine look at your build robots and

1571
01:03:22,310 --> 01:03:27,040
review them all properly and don't let

1572
01:03:24,230 --> 01:03:30,609
anyone else like me touch it

1573
01:03:27,040 --> 01:03:34,430
awesome ten seconds left for questions

1574
01:03:30,609 --> 01:03:44,359
you thank you very much are there any

1575
01:03:34,430 --> 01:03:46,460
questions you need yeah sure I'll be

1576
01:03:44,359 --> 01:03:48,410
around all day and awesome then I want

1577
01:03:46,460 --> 01:03:52,060
to think oh yeah no nobody asked for a

1578
01:03:48,410 --> 01:03:55,290
very warm applause to thank her

1579
01:03:52,060 --> 01:03:55,290
thank you very much

1580
01:04:02,130 --> 01:04:04,190
you

