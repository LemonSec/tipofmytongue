1
00:00:19,290 --> 00:00:24,840
good morning everybody some then a quick

2
00:00:22,140 --> 00:00:26,790
hear from a French safety security

3
00:00:24,840 --> 00:00:30,060
company I'm going to present here a

4
00:00:26,790 --> 00:00:32,820
neutral to under load some specific

5
00:00:30,060 --> 00:00:35,910
chips from annex B so first of all I'm

6
00:00:32,820 --> 00:00:38,970
the head of R&D at the Caloocan digital

7
00:00:35,910 --> 00:00:41,849
security which is a French IT security

8
00:00:38,970 --> 00:00:44,760
company and we'll create it the first

9
00:00:41,850 --> 00:00:46,860
IOT cert so basically we are working on

10
00:00:44,760 --> 00:00:50,120
a lot of devices connected devices and

11
00:00:46,860 --> 00:00:53,850
also industrial devices and this is

12
00:00:50,120 --> 00:00:55,680
where this cone this toad comes from I'm

13
00:00:53,850 --> 00:00:58,560
also a senior security researcher and

14
00:00:55,680 --> 00:01:01,650
also a hardware hacker or at least

15
00:00:58,560 --> 00:01:05,280
pretending to be one but I don't know

16
00:01:01,650 --> 00:01:06,869
everything so what are we going to talk

17
00:01:05,280 --> 00:01:08,850
about so we are going to talk about from

18
00:01:06,869 --> 00:01:11,520
my extraction 101 I don't know if you

19
00:01:08,850 --> 00:01:15,869
are familiar with this from my

20
00:01:11,520 --> 00:01:19,320
extraction process we used to do when it

21
00:01:15,869 --> 00:01:21,509
comes to analyzing embedded devices but

22
00:01:19,320 --> 00:01:23,369
in fact I'm going to go through the this

23
00:01:21,509 --> 00:01:27,000
process and we're going to see that

24
00:01:23,369 --> 00:01:32,250
sometimes it may fail and it requires a

25
00:01:27,000 --> 00:01:35,630
lot more a lot more work to do to find a

26
00:01:32,250 --> 00:01:38,729
solution for some issues we we can meet

27
00:01:35,630 --> 00:01:41,369
so with then I'm going to go through the

28
00:01:38,729 --> 00:01:44,130
IMX architecture and especially its

29
00:01:41,369 --> 00:01:47,280
memory layout what is a very interesting

30
00:01:44,130 --> 00:01:49,649
here and are we going I was in prison by

31
00:01:47,280 --> 00:01:52,170
to my new tool ah remix nun tools so

32
00:01:49,649 --> 00:01:56,149
it's more than that it'll just a set of

33
00:01:52,170 --> 00:02:00,300
Tours that will is the work on academics

34
00:01:56,149 --> 00:02:03,080
flash non Flashdance and we will

35
00:02:00,300 --> 00:02:07,380
conclude with some best practices for

36
00:02:03,080 --> 00:02:12,000
Olympic systems designer so first of all

37
00:02:07,380 --> 00:02:14,269
the pharma extraction process when when

38
00:02:12,000 --> 00:02:17,760
you're doing some kind of analysis of a

39
00:02:14,270 --> 00:02:21,090
specific device you need to know what a

40
00:02:17,760 --> 00:02:23,940
device does so this device can contain a

41
00:02:21,090 --> 00:02:27,030
lot of data for such as file systems

42
00:02:23,940 --> 00:02:29,519
applications binary files so sometimes

43
00:02:27,030 --> 00:02:30,750
is just some kind of saying a single

44
00:02:29,519 --> 00:02:33,720
program that

45
00:02:30,750 --> 00:02:35,580
randomly on the system so this is

46
00:02:33,720 --> 00:02:38,010
something we want to extract from a

47
00:02:35,580 --> 00:02:40,680
device because by doing this we can be

48
00:02:38,010 --> 00:02:43,410
able to understand how this device works

49
00:02:40,680 --> 00:02:46,320
and what data does this device

50
00:02:43,410 --> 00:02:51,090
manipulate so this is a very interesting

51
00:02:46,320 --> 00:02:53,940
and also in this and this data we expect

52
00:02:51,090 --> 00:02:55,709
to find some very interesting stuff such

53
00:02:53,940 --> 00:02:58,380
as encryption keys the efficient key

54
00:02:55,709 --> 00:03:02,040
certificates passwords and sometimes

55
00:02:58,380 --> 00:03:03,780
also intellectual property you know some

56
00:03:02,040 --> 00:03:06,209
specific algorithm intermittent in the

57
00:03:03,780 --> 00:03:09,540
device so this is something very useful

58
00:03:06,209 --> 00:03:13,170
when you are analyzing this cellular

59
00:03:09,540 --> 00:03:14,910
device so you need to understand

60
00:03:13,170 --> 00:03:18,089
everything about the device you need

61
00:03:14,910 --> 00:03:20,520
turn to determine how this device has

62
00:03:18,090 --> 00:03:22,560
been created as been designed you need

63
00:03:20,520 --> 00:03:25,290
to understand also how it works

64
00:03:22,560 --> 00:03:28,830
and this is very specific here because

65
00:03:25,290 --> 00:03:31,650
you know Vande of print and to know that

66
00:03:28,830 --> 00:03:34,950
they might not know how the devices work

67
00:03:31,650 --> 00:03:37,590
but in fact they do not because there is

68
00:03:34,950 --> 00:03:40,738
a gap between the vision of our device

69
00:03:37,590 --> 00:03:43,080
work from a designer perspective and the

70
00:03:40,739 --> 00:03:45,060
way the device really works you know

71
00:03:43,080 --> 00:03:47,670
there are in between some developers

72
00:03:45,060 --> 00:03:49,950
that sometimes do mistakes and these

73
00:03:47,670 --> 00:03:53,160
mistakes introduce some vulnerabilities

74
00:03:49,950 --> 00:03:55,079
in many devices so they might think that

75
00:03:53,160 --> 00:03:57,060
a device works a specific way but in

76
00:03:55,080 --> 00:03:59,220
fact it can work or a different people

77
00:03:57,060 --> 00:04:02,489
so this is why we are going to analyze

78
00:03:59,220 --> 00:04:05,010
this device and and this is a why we are

79
00:04:02,489 --> 00:04:09,750
trying to determine how a device works

80
00:04:05,010 --> 00:04:12,090
and also we need to know what data is so

81
00:04:09,750 --> 00:04:14,670
where where you stalled what data we

82
00:04:12,090 --> 00:04:17,130
need to know when do we do that

83
00:04:14,670 --> 00:04:21,750
sorry where I can find the interesting

84
00:04:17,130 --> 00:04:25,380
data so the first method you can use is

85
00:04:21,750 --> 00:04:27,270
to buy a small clip for your chip that

86
00:04:25,380 --> 00:04:29,669
contains all the memory which is

87
00:04:27,270 --> 00:04:32,130
basically some non flash chip and by

88
00:04:29,669 --> 00:04:35,039
using this clip you can just plug it on

89
00:04:32,130 --> 00:04:37,800
the chip and use a some kind of adapter

90
00:04:35,040 --> 00:04:40,860
to extract the content of the memory so

91
00:04:37,800 --> 00:04:43,110
this way this method may work but

92
00:04:40,860 --> 00:04:43,900
sometimes may not because you know once

93
00:04:43,110 --> 00:04:46,690
you pour

94
00:04:43,900 --> 00:04:48,729
the non flashed ship then the whole

95
00:04:46,690 --> 00:04:50,590
system we're going to stop and interact

96
00:04:48,730 --> 00:04:52,660
with this ship so this is a sometimes a

97
00:04:50,590 --> 00:04:55,030
problem because since you are going to

98
00:04:52,660 --> 00:04:57,730
interact with this ship you won't get

99
00:04:55,030 --> 00:04:59,739
the correct data since another another

100
00:04:57,730 --> 00:05:00,790
device or component is actually

101
00:04:59,740 --> 00:05:03,880
interacting with it

102
00:05:00,790 --> 00:05:05,980
also so this is one method to do it but

103
00:05:03,880 --> 00:05:08,560
we prefer the second one which is a

104
00:05:05,980 --> 00:05:11,620
cheaper we are going to remove the flash

105
00:05:08,560 --> 00:05:13,690
memory component from a PCB by using

106
00:05:11,620 --> 00:05:17,290
some awesome tools so here I'm going to

107
00:05:13,690 --> 00:05:19,600
remove this this flash chip with a hot

108
00:05:17,290 --> 00:05:23,380
theory workstation so this is a big

109
00:05:19,600 --> 00:05:25,900
stuff for me I'm using here and so it

110
00:05:23,380 --> 00:05:28,930
takes off yeah sometimes a few minutes

111
00:05:25,900 --> 00:05:30,130
to get it removed from the PCB so you

112
00:05:28,930 --> 00:05:32,590
have to be careful when you are doing

113
00:05:30,130 --> 00:05:35,440
this because you can bear on the chip

114
00:05:32,590 --> 00:05:37,090
you can fight the chip if you set the

115
00:05:35,440 --> 00:05:41,800
temperature of this hot air wave

116
00:05:37,090 --> 00:05:43,929
oxidation too high so it's a need some

117
00:05:41,800 --> 00:05:46,080
kind of practice to to be able to

118
00:05:43,930 --> 00:05:49,060
extract this one well this one was a bit

119
00:05:46,080 --> 00:05:52,990
difficult to exploit oh yeah here it is

120
00:05:49,060 --> 00:05:58,120
so here I removed this chip and then

121
00:05:52,990 --> 00:06:00,100
it's ready to be dumped so you know that

122
00:05:58,120 --> 00:06:03,750
in order to extract data from this flash

123
00:06:00,100 --> 00:06:06,520
memory you need some specific stuff and

124
00:06:03,750 --> 00:06:08,710
this stuff is a professional flash

125
00:06:06,520 --> 00:06:11,859
programmer so this is a specific device

126
00:06:08,710 --> 00:06:15,340
there are many of them I put two of them

127
00:06:11,860 --> 00:06:17,470
on the sides on the left-hand left side

128
00:06:15,340 --> 00:06:19,150
of this tile you got a data man which is

129
00:06:17,470 --> 00:06:22,600
a very professional

130
00:06:19,150 --> 00:06:24,640
flash memory reader and an eraser and

131
00:06:22,600 --> 00:06:27,820
programmer and on the right side of this

132
00:06:24,640 --> 00:06:30,490
side right you get the TNM 5000 so this

133
00:06:27,820 --> 00:06:33,490
is a Chinese version of of the the first

134
00:06:30,490 --> 00:06:35,800
one and it works very well but in fact

135
00:06:33,490 --> 00:06:37,900
it's only works with on Windows with

136
00:06:35,800 --> 00:06:40,180
some specific drivers you need to

137
00:06:37,900 --> 00:06:42,190
install and it's a quite a challenge to

138
00:06:40,180 --> 00:06:44,710
get it work in Windows but once it works

139
00:06:42,190 --> 00:06:47,740
that's ok can use it and it comes with a

140
00:06:44,710 --> 00:06:49,380
lot of adapters these tiny green boards

141
00:06:47,740 --> 00:06:53,320
you can see here are with a lot of

142
00:06:49,380 --> 00:06:56,219
various sockets to put the memories in

143
00:06:53,320 --> 00:07:01,210
them so

144
00:06:56,220 --> 00:07:04,920
I'm going to plug this tiny flat non

145
00:07:01,210 --> 00:07:07,150
flash memory inside the this circuit so

146
00:07:04,920 --> 00:07:08,860
remember be very careful when you're

147
00:07:07,150 --> 00:07:11,320
doing this because you need to be sure

148
00:07:08,860 --> 00:07:14,410
that pin 1 on the flash chip is

149
00:07:11,320 --> 00:07:16,659
connected to the pin 1 on this adapter

150
00:07:14,410 --> 00:07:22,090
if you don't do this you are going to

151
00:07:16,660 --> 00:07:27,040
fry the memory and everything is gone so

152
00:07:22,090 --> 00:07:30,369
again take some time to do it so once

153
00:07:27,040 --> 00:07:32,380
you've got your adapter socket ready

154
00:07:30,370 --> 00:07:35,230
with the flash chip in it then you can

155
00:07:32,380 --> 00:07:38,260
plug it in the ZIF socket so if is zero

156
00:07:35,230 --> 00:07:44,560
insertion force so this is a very nice

157
00:07:38,260 --> 00:07:46,810
circuit you can adjust you can be your

158
00:07:44,560 --> 00:07:49,900
man of the laborer and then you can plug

159
00:07:46,810 --> 00:07:54,310
the this adapter and use the programmer

160
00:07:49,900 --> 00:07:57,190
with it and last but not least we are

161
00:07:54,310 --> 00:07:59,170
going to do with this program that we

162
00:07:57,190 --> 00:08:03,340
expect the framer so it takes some time

163
00:07:59,170 --> 00:08:07,480
here I think the video is has been

164
00:08:03,340 --> 00:08:10,090
modified to go faster than than it

165
00:08:07,480 --> 00:08:11,860
actually does it take it took me maybe

166
00:08:10,090 --> 00:08:13,780
10 minutes to extract the content of the

167
00:08:11,860 --> 00:08:16,960
obvious flash memory 1 gigabyte flash

168
00:08:13,780 --> 00:08:20,619
network so this is something very you

169
00:08:16,960 --> 00:08:23,200
know very we are used to it we know how

170
00:08:20,620 --> 00:08:26,830
to do it we do it very very very

171
00:08:23,200 --> 00:08:29,770
commonly so this is a when went on

172
00:08:26,830 --> 00:08:32,260
process and it's also documented if you

173
00:08:29,770 --> 00:08:35,230
have a look at the dolt you got from

174
00:08:32,260 --> 00:08:37,870
this this programmer then you would say

175
00:08:35,230 --> 00:08:41,560
that this done is not a one gigabyte

176
00:08:37,870 --> 00:08:44,260
dump since your flash chip on the

177
00:08:41,559 --> 00:08:47,349
superstore to contain one gigabyte one

178
00:08:44,260 --> 00:08:50,530
gigabyte data then you will see that

179
00:08:47,350 --> 00:08:53,170
it's a 1.1 gigabyte data stone in it so

180
00:08:50,530 --> 00:08:56,319
why why do we have more memory than

181
00:08:53,170 --> 00:08:59,079
expected the reason is that these NAND

182
00:08:56,320 --> 00:09:01,360
flash chips are storing data a very

183
00:08:59,080 --> 00:09:02,620
specific way so we are going to talk

184
00:09:01,360 --> 00:09:05,680
about pages

185
00:09:02,620 --> 00:09:08,910
bytes and what we are used to call OB

186
00:09:05,680 --> 00:09:08,910
for out-of-band data

187
00:09:09,020 --> 00:09:15,750
in the non-flash ship bytes are stored

188
00:09:12,330 --> 00:09:18,720
in pages if you want to modify your byte

189
00:09:15,750 --> 00:09:20,790
in a flash chip in you cannot modify

190
00:09:18,720 --> 00:09:23,220
just one bite you need to read a page

191
00:09:20,790 --> 00:09:25,949
modify the byte in the previous page and

192
00:09:23,220 --> 00:09:28,080
then write again this page so this page

193
00:09:25,950 --> 00:09:30,020
has a given size this is described in

194
00:09:28,080 --> 00:09:34,620
the documentation the datasheet of this

195
00:09:30,020 --> 00:09:38,160
chip and this is a quite quite useful

196
00:09:34,620 --> 00:09:40,140
but also these non flash chips are very

197
00:09:38,160 --> 00:09:42,779
prone to errors they are not under

198
00:09:40,140 --> 00:09:45,630
Poisson reliable so what does the

199
00:09:42,779 --> 00:09:49,740
manufacturer do they put some extra

200
00:09:45,630 --> 00:09:53,910
space in them to allow some more data to

201
00:09:49,740 --> 00:09:56,910
be stopped and basically this this extra

202
00:09:53,910 --> 00:09:59,069
space is used to store some ECC bytes so

203
00:09:56,910 --> 00:10:02,640
it CC bytes existence forever correction

204
00:09:59,070 --> 00:10:05,730
codes this is this sum these are

205
00:10:02,640 --> 00:10:09,750
specific data computed with some

206
00:10:05,730 --> 00:10:12,870
algorithm that allows many a driver or a

207
00:10:09,750 --> 00:10:17,670
controller to detect errors in the

208
00:10:12,870 --> 00:10:19,350
wedding's and then fix this error if you

209
00:10:17,670 --> 00:10:22,199
have a look of not specifically at the

210
00:10:19,350 --> 00:10:25,320
layout of this NAND flash so you will

211
00:10:22,200 --> 00:10:29,160
find two two different layout mainly or

212
00:10:25,320 --> 00:10:33,060
used by your nan such drivers or

213
00:10:29,160 --> 00:10:36,719
controllers so the first one on the Left

214
00:10:33,060 --> 00:10:39,959
puts an extra space after each page so

215
00:10:36,720 --> 00:10:42,810
you get a page of data then some bytes

216
00:10:39,959 --> 00:10:44,849
of data and then another page another

217
00:10:42,810 --> 00:10:47,640
pair will be data and so on and there is

218
00:10:44,850 --> 00:10:49,980
another day yard where all the OB data

219
00:10:47,640 --> 00:10:52,500
is stored in one page for instance or

220
00:10:49,980 --> 00:10:56,370
maybe multiple page depending on the

221
00:10:52,500 --> 00:10:58,560
flash the flash chip size so if you have

222
00:10:56,370 --> 00:11:00,600
a look at the data sheet you will find

223
00:10:58,560 --> 00:11:03,150
that all of this information in the

224
00:11:00,600 --> 00:11:04,860
datasheet such as the page size which is

225
00:11:03,150 --> 00:11:08,699
here four thousand three hundred and

226
00:11:04,860 --> 00:11:13,170
twenty bytes composed of two series of

227
00:11:08,700 --> 00:11:15,750
bytes one of 4096 bytes which is

228
00:11:13,170 --> 00:11:19,589
basically the data size stored in one

229
00:11:15,750 --> 00:11:21,390
page and 224 bytes which is the obit

230
00:11:19,589 --> 00:11:23,700
data so if they are

231
00:11:21,390 --> 00:11:25,680
we have a very nice clue about the

232
00:11:23,700 --> 00:11:28,380
layout used to stop the data in the

233
00:11:25,680 --> 00:11:30,989
flash chip so this is very common so

234
00:11:28,380 --> 00:11:33,900
we'll create some script in Python to

235
00:11:30,990 --> 00:11:36,180
remove this out-of-band data so what we

236
00:11:33,900 --> 00:11:38,160
are going to do just a load in memory

237
00:11:36,180 --> 00:11:40,500
the whole content of this of the file

238
00:11:38,160 --> 00:11:44,459
then we are going to be remove of each

239
00:11:40,500 --> 00:11:48,750
page this orbit data and cook catenate

240
00:11:44,460 --> 00:11:52,080
the result and then we got a cool flash

241
00:11:48,750 --> 00:11:54,570
memory dump without the orbit data then

242
00:11:52,080 --> 00:11:57,030
we can process it with some tools so

243
00:11:54,570 --> 00:12:00,890
here it is and then we are going to

244
00:11:57,030 --> 00:12:03,839
check if this if this dump is ok so

245
00:12:00,890 --> 00:12:05,640
let's use Bing work VIN work with a very

246
00:12:03,840 --> 00:12:08,010
standard tool where well-known tool to

247
00:12:05,640 --> 00:12:10,560
handle this this life and then it finds

248
00:12:08,010 --> 00:12:12,660
a lot of food systems in it for squash a

249
00:12:10,560 --> 00:12:18,510
fast fast system and to GFS to file

250
00:12:12,660 --> 00:12:22,230
system so that's core yeah that's good

251
00:12:18,510 --> 00:12:27,060
if my clicker drops so I think it's a

252
00:12:22,230 --> 00:12:28,740
lot of battery so there are many file

253
00:12:27,060 --> 00:12:30,930
systems that can be used to store data

254
00:12:28,740 --> 00:12:33,360
on this flash and we go very very

255
00:12:30,930 --> 00:12:35,270
quickly for this this file system so you

256
00:12:33,360 --> 00:12:38,610
can find some squash offense pod systems

257
00:12:35,270 --> 00:12:42,329
your ffs took yet another 5 /f s file

258
00:12:38,610 --> 00:12:44,910
systems Jeff is too and so journalist

259
00:12:42,330 --> 00:12:48,330
flash file system version too and with

260
00:12:44,910 --> 00:12:51,900
one partition image and also a Morris

261
00:12:48,330 --> 00:12:54,630
inferred system Morrison system of data

262
00:12:51,900 --> 00:12:57,630
storing which is ubi for insulted black

263
00:12:54,630 --> 00:13:01,110
image and we go further with this so

264
00:12:57,630 --> 00:13:04,350
basically at this moment we extracted

265
00:13:01,110 --> 00:13:07,890
the freshman wait ship we dumped all the

266
00:13:04,350 --> 00:13:10,020
contents of this we run bin world and we

267
00:13:07,890 --> 00:13:12,420
got everything we need so the next step

268
00:13:10,020 --> 00:13:14,579
is to try to extract information files a

269
00:13:12,420 --> 00:13:18,599
configuration and so on from the flash

270
00:13:14,580 --> 00:13:21,480
ship from from this dump sorry so this

271
00:13:18,600 --> 00:13:23,160
process is as I said is very well

272
00:13:21,480 --> 00:13:26,250
documented known recently pentas

273
00:13:23,160 --> 00:13:29,339
partners published a blog entry on this

274
00:13:26,250 --> 00:13:32,910
on this this process so everything is a

275
00:13:29,340 --> 00:13:34,040
bit more detail than that what I

276
00:13:32,910 --> 00:13:35,569
presented here

277
00:13:34,040 --> 00:13:38,930
sure want to have more information about

278
00:13:35,570 --> 00:13:41,630
this process and go further or try it by

279
00:13:38,930 --> 00:13:48,138
yourself go to this blog post this is

280
00:13:41,630 --> 00:13:49,189
very very detailed and complete so we

281
00:13:48,139 --> 00:13:52,220
know how to do this

282
00:13:49,190 --> 00:13:55,220
yeah that's okay this is one known but

283
00:13:52,220 --> 00:13:58,880
at this specific time customer asked us

284
00:13:55,220 --> 00:14:02,930
to help him with some kind of system he

285
00:13:58,880 --> 00:14:06,709
had and he was tagged this system is an

286
00:14:02,930 --> 00:14:10,040
imx6 platform so much see what is this

287
00:14:06,709 --> 00:14:13,250
imx6 platform it's something created by

288
00:14:10,040 --> 00:14:17,449
freescale and this this systems is very

289
00:14:13,250 --> 00:14:19,670
particular and well we told our client

290
00:14:17,449 --> 00:14:21,410
or customer that yeah we can do it we

291
00:14:19,670 --> 00:14:24,439
know how to do it yeah this is something

292
00:14:21,410 --> 00:14:28,009
we usually we are used to it to do sorry

293
00:14:24,440 --> 00:14:30,769
yeah give us this platform we are going

294
00:14:28,009 --> 00:14:34,160
to extracted shape and get all the data

295
00:14:30,769 --> 00:14:38,120
you want from this because this customer

296
00:14:34,160 --> 00:14:41,569
was not able to do so so yeah we go

297
00:14:38,120 --> 00:14:45,230
through it with the flash extract with

298
00:14:41,569 --> 00:14:49,610
the flash the exact same singer as I

299
00:14:45,230 --> 00:14:53,329
shown you and at the at the end we won't

300
00:14:49,610 --> 00:14:54,829
be work on this firmware and yeah we got

301
00:14:53,329 --> 00:14:58,370
a lot of food systems that's right

302
00:14:54,829 --> 00:15:03,880
that's cool but the fact is that when we

303
00:14:58,370 --> 00:15:07,760
extract the ubi coalition which is a

304
00:15:03,880 --> 00:15:11,389
codified system on that then we faced an

305
00:15:07,760 --> 00:15:14,689
issue this UBS file system didn't work

306
00:15:11,389 --> 00:15:17,600
we weren't able to get the the files all

307
00:15:14,690 --> 00:15:20,269
the file systems contain in this ubi

308
00:15:17,600 --> 00:15:23,000
volume so this was a problem so here it

309
00:15:20,269 --> 00:15:24,800
is I used some specific tools you'll be

310
00:15:23,000 --> 00:15:29,360
eye reader to extract all the data and

311
00:15:24,800 --> 00:15:33,290
then it's simplified we were not about

312
00:15:29,360 --> 00:15:35,720
to get this this data and it was a very

313
00:15:33,290 --> 00:15:39,500
personal you know because normally this

314
00:15:35,720 --> 00:15:44,029
is a straightforward process so we had

315
00:15:39,500 --> 00:15:47,269
to look at the at the S file because Nia

316
00:15:44,029 --> 00:15:48,420
well God since some kind of stack and in

317
00:15:47,269 --> 00:15:51,660
the India

318
00:15:48,420 --> 00:15:55,650
we had a specific look at Z webpages

319
00:15:51,660 --> 00:15:58,230
they were pages in flash memories mainly

320
00:15:55,650 --> 00:15:59,699
some pages full of zeros and this is

321
00:15:58,230 --> 00:16:01,770
very interesting because if you have

322
00:15:59,700 --> 00:16:04,920
some if you expect some oddities in the

323
00:16:01,770 --> 00:16:07,439
file then these zero pages or ffs pages

324
00:16:04,920 --> 00:16:09,750
this is quite the same might have some

325
00:16:07,440 --> 00:16:12,420
errors in it and in this dump

326
00:16:09,750 --> 00:16:16,590
we found that for at a very specific

327
00:16:12,420 --> 00:16:20,400
position in almost each pages we found a

328
00:16:16,590 --> 00:16:22,590
word like and we did not know we didn't

329
00:16:20,400 --> 00:16:27,510
know what this byte is formed we did not

330
00:16:22,590 --> 00:16:30,390
know if we think was was normal then we

331
00:16:27,510 --> 00:16:33,720
had a look at the ubi partition we found

332
00:16:30,390 --> 00:16:38,760
and this partition doesn't start at a

333
00:16:33,720 --> 00:16:41,370
very space at the expected offset we got

334
00:16:38,760 --> 00:16:44,810
a one byte offset from the ubi signature

335
00:16:41,370 --> 00:16:48,390
so this is also something uncommon with

336
00:16:44,810 --> 00:16:50,760
this dump so this is a some kind of

337
00:16:48,390 --> 00:16:54,390
quantify trigger and also we can see on

338
00:16:50,760 --> 00:16:59,210
the bin bulk output that the address the

339
00:16:54,390 --> 00:17:02,280
offset of the ubi data is a 21c one

340
00:16:59,210 --> 00:17:06,300
which is not common most of the times we

341
00:17:02,280 --> 00:17:08,550
get a multiple of the page size offset

342
00:17:06,300 --> 00:17:12,599
so this is not a line on the page size

343
00:17:08,550 --> 00:17:14,010
at this time so that's where we did a

344
00:17:12,599 --> 00:17:15,958
quick investigation and this quick

345
00:17:14,010 --> 00:17:18,569
investigation rivet anomalies on the

346
00:17:15,959 --> 00:17:22,620
system or dump seems ok this is a

347
00:17:18,569 --> 00:17:26,010
correct we get the the quite size and we

348
00:17:22,619 --> 00:17:27,389
didn't do some with even do anything

349
00:17:26,010 --> 00:17:30,390
wrong you know when we when we

350
00:17:27,390 --> 00:17:33,510
abstracting the dump so this may be what

351
00:17:30,390 --> 00:17:36,390
I did to the AMX platform maybe why not

352
00:17:33,510 --> 00:17:39,000
a custom storage mechanism so let's have

353
00:17:36,390 --> 00:17:42,240
a look at this platform this IMX

354
00:17:39,000 --> 00:17:44,640
platform is a dedicated to industry

355
00:17:42,240 --> 00:17:46,350
applications so this is a the

356
00:17:44,640 --> 00:17:48,540
integrating multimedia application

357
00:17:46,350 --> 00:17:52,740
processor and the family of processors

358
00:17:48,540 --> 00:17:55,710
are you can find AMX 28 and helix 5 7 6

359
00:17:52,740 --> 00:17:57,720
8 and this is very popular in automotive

360
00:17:55,710 --> 00:17:59,740
and home automation industries so you

361
00:17:57,720 --> 00:18:02,529
can expect this platform on

362
00:17:59,740 --> 00:18:06,399
a lot of devices such as one the month

363
00:18:02,529 --> 00:18:09,010
that in easy use in curls for instance

364
00:18:06,399 --> 00:18:12,070
or maybe not in home automation devices

365
00:18:09,010 --> 00:18:15,070
and this platform provides a lot of

366
00:18:12,070 --> 00:18:18,340
features including your unencrypted wom

367
00:18:15,070 --> 00:18:20,740
SATA to support secure boot and so on so

368
00:18:18,340 --> 00:18:25,000
this is very convenient for the people

369
00:18:20,740 --> 00:18:28,840
want to create an industrial system to

370
00:18:25,000 --> 00:18:33,549
use this this platform so it's based on

371
00:18:28,840 --> 00:18:36,549
ARM Cortex a9 control CPU for this IM

372
00:18:33,549 --> 00:18:38,799
extent e8 so this image is extracted

373
00:18:36,549 --> 00:18:40,658
from the reference manual available on

374
00:18:38,799 --> 00:18:44,320
the internet so I didn't do anything

375
00:18:40,659 --> 00:18:45,700
that rather than just brought the

376
00:18:44,320 --> 00:18:47,230
Internet and find the reference manual

377
00:18:45,700 --> 00:18:49,390
to to get the information

378
00:18:47,230 --> 00:18:53,230
this system can boot on various storage

379
00:18:49,390 --> 00:18:57,549
devices such as NAND flash SD cards for

380
00:18:53,230 --> 00:19:01,570
L not flash USB MMC and also other of

381
00:18:57,549 --> 00:19:04,080
these out drives so this boot process is

382
00:19:01,570 --> 00:19:07,090
under by a specific boot worm inside the

383
00:19:04,080 --> 00:19:09,129
IMX system and this boot rom start the

384
00:19:07,090 --> 00:19:11,709
whole system if you tell the system to

385
00:19:09,130 --> 00:19:14,200
boot on the NAND flash then it's going

386
00:19:11,710 --> 00:19:17,340
to to load the NAND flash and boot the

387
00:19:14,200 --> 00:19:20,710
system so that's it this is not very

388
00:19:17,340 --> 00:19:23,529
complicated at this time but we spotted

389
00:19:20,710 --> 00:19:26,470
something very unit all the general

390
00:19:23,529 --> 00:19:30,190
purpose multimedia interface also called

391
00:19:26,470 --> 00:19:32,830
GPM I so this GPM I component controls

392
00:19:30,190 --> 00:19:37,480
how that is read and stored on non flash

393
00:19:32,830 --> 00:19:40,928
chips and this is what this is at this

394
00:19:37,480 --> 00:19:42,760
time that is becomes a everything

395
00:19:40,929 --> 00:19:45,070
becomes interesting because it supports

396
00:19:42,760 --> 00:19:47,080
also multiple non flash chips we can put

397
00:19:45,070 --> 00:19:49,059
multiple chips map them on multiple

398
00:19:47,080 --> 00:19:52,928
partitions and load it on those systems

399
00:19:49,059 --> 00:19:55,750
this GPM I component also uses BCH which

400
00:19:52,929 --> 00:19:59,169
is a narrow control and correction

401
00:19:55,750 --> 00:20:02,649
mechanism to avoid errors on reading and

402
00:19:59,169 --> 00:20:06,429
writing in the same reference manual

403
00:20:02,649 --> 00:20:09,580
there is a little image of what the

404
00:20:06,429 --> 00:20:11,679
flash memory looks like on the top this

405
00:20:09,580 --> 00:20:13,449
is a common layout using non flash

406
00:20:11,679 --> 00:20:16,059
memories so this is very

407
00:20:13,450 --> 00:20:19,360
come on we got the two kilobyte mineral

408
00:20:16,059 --> 00:20:21,668
which is a page what you expect it to be

409
00:20:19,360 --> 00:20:26,370
the data the data and then at the end

410
00:20:21,669 --> 00:20:30,610
the obit data so this is a extra space

411
00:20:26,370 --> 00:20:34,120
put by by the manufacturers along with

412
00:20:30,610 --> 00:20:39,850
the heavy pages so on the bottom you get

413
00:20:34,120 --> 00:20:43,418
the layout used by this GP ml component

414
00:20:39,850 --> 00:20:44,370
and it is totally different so how does

415
00:20:43,419 --> 00:20:49,470
it work

416
00:20:44,370 --> 00:20:53,739
your data is split in 512 byte chunks

417
00:20:49,470 --> 00:20:57,730
then ECC bits are added happended to

418
00:20:53,740 --> 00:21:01,149
this this data so this is EC data is

419
00:20:57,730 --> 00:21:05,019
stored as bits this is not aligned with

420
00:21:01,149 --> 00:21:07,689
bytes so this has very specific

421
00:21:05,019 --> 00:21:11,440
consequence that it will shift all your

422
00:21:07,690 --> 00:21:14,200
data with maybe two three four five bits

423
00:21:11,440 --> 00:21:16,720
and you have to reconstruct the old

424
00:21:14,200 --> 00:21:20,320
stuff when you want to to deconstruct

425
00:21:16,720 --> 00:21:22,960
the specific layout so ECC bits are

426
00:21:20,320 --> 00:21:25,090
added then chunks are grouped and stored

427
00:21:22,960 --> 00:21:27,490
in a page preceded by a one metadata

428
00:21:25,090 --> 00:21:33,279
block the size of this metadata block

429
00:21:27,490 --> 00:21:35,080
can vary this it depends and a bad block

430
00:21:33,279 --> 00:21:37,539
marker byte is what with the first

431
00:21:35,080 --> 00:21:40,689
multiple Mitton metadata byte sorry if

432
00:21:37,539 --> 00:21:43,629
you have a look at this this this image

433
00:21:40,690 --> 00:21:46,690
there be the swab byte the third the

434
00:21:43,630 --> 00:21:51,039
first byte is in fact 1 byte taken from

435
00:21:46,690 --> 00:21:53,380
the last block and put enough other the

436
00:21:51,039 --> 00:21:56,649
offset 0 and is replaced with one bite

437
00:21:53,380 --> 00:21:58,000
from the data data and this is very

438
00:21:56,649 --> 00:22:00,489
interesting because it can explain

439
00:21:58,000 --> 00:22:03,070
something some anomalies we found

440
00:22:00,490 --> 00:22:07,299
remember the weird byte we found in the

441
00:22:03,070 --> 00:22:10,570
data page this can be explained by this

442
00:22:07,299 --> 00:22:13,510
byte swapping stuff for bad markers but

443
00:22:10,570 --> 00:22:16,389
block marker so this is a byte that is

444
00:22:13,510 --> 00:22:18,760
normally from the meter data byte but

445
00:22:16,389 --> 00:22:22,809
this byte has been swapped because of

446
00:22:18,760 --> 00:22:24,820
the storage mechanism used here all of

447
00:22:22,809 --> 00:22:27,250
this information all of the structure

448
00:22:24,820 --> 00:22:30,070
and all the sizes of

449
00:22:27,250 --> 00:22:33,910
fine in a firmware a configuration block

450
00:22:30,070 --> 00:22:36,820
also called FCB this structure contains

451
00:22:33,910 --> 00:22:39,160
all the required information but how

452
00:22:36,820 --> 00:22:41,889
that I stole this structure must be

453
00:22:39,160 --> 00:22:44,710
present in the first megabyte of your

454
00:22:41,890 --> 00:22:46,690
own flash and the second field of this

455
00:22:44,710 --> 00:22:51,310
filter contains the ASCII text

456
00:22:46,690 --> 00:22:52,480
FCB so if we look at off dump with on

457
00:22:51,310 --> 00:22:54,909
this

458
00:22:52,480 --> 00:22:57,790
FCB signature at the very start of the

459
00:22:54,910 --> 00:23:01,540
very beginning of the flash time we made

460
00:22:57,790 --> 00:23:03,129
so this makes sense we got this

461
00:23:01,540 --> 00:23:07,389
freighter so let's have a look at the

462
00:23:03,130 --> 00:23:09,340
structure if we if we look in the

463
00:23:07,390 --> 00:23:11,620
documentation the data sheets and also

464
00:23:09,340 --> 00:23:14,470
in some codes we find on three on github

465
00:23:11,620 --> 00:23:16,959
this filter contains the non space data

466
00:23:14,470 --> 00:23:18,900
size and also the OB that the size so

467
00:23:16,960 --> 00:23:22,240
this is quite interesting but

468
00:23:18,900 --> 00:23:25,210
furthermore there is also some block 0

469
00:23:22,240 --> 00:23:28,440
and block m specifications such as the

470
00:23:25,210 --> 00:23:31,480
block 0 size and the block in size there

471
00:23:28,440 --> 00:23:33,670
may some distinction between block 0 and

472
00:23:31,480 --> 00:23:36,820
the remaining blocks in the stall in the

473
00:23:33,670 --> 00:23:40,150
page but the fact it's quite all always

474
00:23:36,820 --> 00:23:42,550
the same and also we can find the number

475
00:23:40,150 --> 00:23:46,390
of bytes stone in the metadata block so

476
00:23:42,550 --> 00:23:48,159
if you want to determine how how many

477
00:23:46,390 --> 00:23:50,110
bytes are used to store the metadata

478
00:23:48,160 --> 00:23:52,570
information at the start of the page

479
00:23:50,110 --> 00:23:54,850
then you can get this information from

480
00:23:52,570 --> 00:23:56,919
the FCB so this is a critical structure

481
00:23:54,850 --> 00:23:59,830
we need to find and pass in order to

482
00:23:56,920 --> 00:24:04,030
know exactly how that is taught in this

483
00:23:59,830 --> 00:24:06,580
non-tourage if we have a look at the

484
00:24:04,030 --> 00:24:09,310
structure in the author and the offset

485
00:24:06,580 --> 00:24:11,409
Swissy we find out the number of bytes

486
00:24:09,310 --> 00:24:15,399
of metadata block and this number of

487
00:24:11,410 --> 00:24:20,470
bytes is 1 1 byte of me the pad blah

488
00:24:15,400 --> 00:24:23,740
blah blah I'm going to yeah one byte of

489
00:24:20,470 --> 00:24:26,860
metadata block so if we again have a

490
00:24:23,740 --> 00:24:30,100
look at this flag that we made then this

491
00:24:26,860 --> 00:24:33,550
can explain the offset we saw in the ubi

492
00:24:30,100 --> 00:24:36,040
image because this bite here which is a

493
00:24:33,550 --> 00:24:37,030
full of 0 which is 0

494
00:24:36,040 --> 00:24:40,850
is

495
00:24:37,030 --> 00:24:42,470
obviously this metadata bite but

496
00:24:40,850 --> 00:24:45,949
remember this fight has been swapped

497
00:24:42,470 --> 00:24:49,100
with some bytes in the webpage so this

498
00:24:45,950 --> 00:24:52,490
is full of zero down and so this means

499
00:24:49,100 --> 00:24:54,889
that the zero value we got here is the

500
00:24:52,490 --> 00:24:57,800
zero value of zero byte we may expect to

501
00:24:54,890 --> 00:25:02,380
find in the last block and if you have a

502
00:24:57,800 --> 00:25:04,700
look at the word byte that is Todd from

503
00:25:02,380 --> 00:25:07,940
further in memory then you will find

504
00:25:04,700 --> 00:25:09,140
that this light is FF and some

505
00:25:07,940 --> 00:25:12,110
documentation

506
00:25:09,140 --> 00:25:18,470
it's expected to the truth to be FF in

507
00:25:12,110 --> 00:25:21,260
the metadata so it makes sense there is

508
00:25:18,470 --> 00:25:24,470
also DBT which is a disc of a bad book

509
00:25:21,260 --> 00:25:26,000
table so GP GP might components

510
00:25:24,470 --> 00:25:29,720
implement some kind of bad blood

511
00:25:26,000 --> 00:25:32,300
management system it implements its own

512
00:25:29,720 --> 00:25:35,660
way of managing these bad blocks and

513
00:25:32,300 --> 00:25:37,820
this is done again with some specific

514
00:25:35,660 --> 00:25:40,490
structures and the structure specified

515
00:25:37,820 --> 00:25:43,100
the specified the number of bad blocks

516
00:25:40,490 --> 00:25:45,440
and the impact number of impacted pages

517
00:25:43,100 --> 00:25:50,059
by these bad blocks so basically what

518
00:25:45,440 --> 00:25:51,770
GPM ID does here is just read this DBT

519
00:25:50,059 --> 00:25:55,040
information this is a list of bad blocks

520
00:25:51,770 --> 00:25:57,470
and then remove the bad blocks so don't

521
00:25:55,040 --> 00:26:02,210
take care of these bad dogs when dealing

522
00:25:57,470 --> 00:26:07,940
with the linen flash going to read or

523
00:26:02,210 --> 00:26:09,679
write when it comes to the ECC again

524
00:26:07,940 --> 00:26:13,010
this is an image extracted from the

525
00:26:09,679 --> 00:26:17,030
reference manual of AMX 28 you have a

526
00:26:13,010 --> 00:26:20,510
very nice overview of the storage in one

527
00:26:17,030 --> 00:26:22,520
page so the first part is M is a

528
00:26:20,510 --> 00:26:26,230
four-metre data and then we got all the

529
00:26:22,520 --> 00:26:30,410
blocks block 0 with its specific size

530
00:26:26,230 --> 00:26:32,750
ECC be 0 so this is the ECC data for ECC

531
00:26:30,410 --> 00:26:35,210
bits for the corresponding block block 0

532
00:26:32,750 --> 00:26:38,179
and then with block 1 block 2 block 3

533
00:26:35,210 --> 00:26:40,730
and so on so this ECC is very

534
00:26:38,179 --> 00:26:44,000
interesting because you know as I said

535
00:26:40,730 --> 00:26:46,760
earlier the the NAND flash systems are

536
00:26:44,000 --> 00:26:48,559
not flash chips are prone to error so

537
00:26:46,760 --> 00:26:50,419
manual when we are going to read and

538
00:26:48,559 --> 00:26:53,450
extract information from this shape

539
00:26:50,419 --> 00:26:56,450
we may have some bits flipped and this

540
00:26:53,450 --> 00:26:59,299
can cause issues many well when you will

541
00:26:56,450 --> 00:27:03,409
try to to extract file system from this

542
00:26:59,299 --> 00:27:05,869
distant firmware so if it would be cool

543
00:27:03,409 --> 00:27:09,049
to be able to fix these errors and use

544
00:27:05,869 --> 00:27:13,609
this ECC bit to extract correctly data

545
00:27:09,049 --> 00:27:15,739
from this chip so it the CCC is based on

546
00:27:13,609 --> 00:27:18,080
a BCH which is a which stands for both

547
00:27:15,739 --> 00:27:20,179
weight Choudary and a keygen error

548
00:27:18,080 --> 00:27:21,889
correcting code so this is a widely

549
00:27:20,179 --> 00:27:24,169
documented it's also implemented in

550
00:27:21,889 --> 00:27:26,779
Python so if you want to use it with a

551
00:27:24,169 --> 00:27:29,289
Python script then you can use a current

552
00:27:26,779 --> 00:27:32,570
the corresponding library so this is a

553
00:27:29,289 --> 00:27:35,450
very common to stand out but the fact is

554
00:27:32,570 --> 00:27:37,458
that the data from each block may be

555
00:27:35,450 --> 00:27:41,389
shifted from a certain of number of bite

556
00:27:37,459 --> 00:27:45,919
bit sorry so this is the main issue here

557
00:27:41,389 --> 00:27:48,738
you have to reconstruct if we block by

558
00:27:45,919 --> 00:27:52,669
taking care of this bit shifting and it

559
00:27:48,739 --> 00:27:55,849
takes a lot of time to do so in the tool

560
00:27:52,669 --> 00:27:57,889
I wrote this is the part of the code

561
00:27:55,849 --> 00:28:00,439
that is the last performance you know

562
00:27:57,889 --> 00:28:02,718
because it takes sometimes to set

563
00:28:00,440 --> 00:28:05,389
everything and and we construct this

564
00:28:02,719 --> 00:28:07,759
this system so this a bit shifting is

565
00:28:05,389 --> 00:28:10,908
taken into account by the GP mi

566
00:28:07,759 --> 00:28:13,190
component itself from a hardware

567
00:28:10,909 --> 00:28:16,339
perspective so this is very very quick

568
00:28:13,190 --> 00:28:19,489
and very efficient in the IMX

569
00:28:16,339 --> 00:28:22,519
architecture but in fact we make comes

570
00:28:19,489 --> 00:28:25,279
from some issues if we are if you wanted

571
00:28:22,519 --> 00:28:26,779
to extract this this data from existence

572
00:28:25,279 --> 00:28:29,809
so what's next

573
00:28:26,779 --> 00:28:33,109
yeah somewhat next we're going to take

574
00:28:29,809 --> 00:28:35,599
our flash dump and then try to recover

575
00:28:33,109 --> 00:28:38,899
all the data from this dump knowing all

576
00:28:35,599 --> 00:28:41,599
of this we know actually at this time we

577
00:28:38,899 --> 00:28:44,359
know how this data of data is stored in

578
00:28:41,599 --> 00:28:47,450
this device or in this non flash we know

579
00:28:44,359 --> 00:28:51,408
how to under all the data stored in the

580
00:28:47,450 --> 00:28:54,169
flash term so let's go oh we are going

581
00:28:51,409 --> 00:28:56,389
to recover and we map all the bytes so

582
00:28:54,169 --> 00:28:58,429
first we need to find the FCB structure

583
00:28:56,389 --> 00:29:01,309
at the beginning of the flash dump so

584
00:28:58,429 --> 00:29:03,079
this is quite easy once you get the FCB

585
00:29:01,309 --> 00:29:03,510
straight or you can pass it and the

586
00:29:03,079 --> 00:29:05,850
recur

587
00:29:03,510 --> 00:29:08,789
every critical parameters such as the

588
00:29:05,850 --> 00:29:10,799
block size CB block size number of bits

589
00:29:08,789 --> 00:29:13,470
of geophys ECB you can also get the

590
00:29:10,799 --> 00:29:14,730
number of bytes of the metadata and so

591
00:29:13,470 --> 00:29:17,190
on some once you get all this

592
00:29:14,730 --> 00:29:19,590
information from them see me FCB then

593
00:29:17,190 --> 00:29:23,159
you know exactly how the data is stored

594
00:29:19,590 --> 00:29:25,350
in this non flash chip then we remove

595
00:29:23,159 --> 00:29:28,110
every metadata in a CC bit according to

596
00:29:25,350 --> 00:29:30,330
this f gb so we are going to remove all

597
00:29:28,110 --> 00:29:32,250
the ECC bit information we are going to

598
00:29:30,330 --> 00:29:35,580
remove the metadata as well the idea

599
00:29:32,250 --> 00:29:41,850
behind this is to reconstruct a basic

600
00:29:35,580 --> 00:29:44,490
page from the IMX version of it and of

601
00:29:41,850 --> 00:29:48,299
course we are going to use this ECC bit

602
00:29:44,490 --> 00:29:52,559
to fix errors in the don't we made so if

603
00:29:48,299 --> 00:29:55,200
a programmer may get some weird data or

604
00:29:52,559 --> 00:29:59,340
some bits flip in the page we can fix

605
00:29:55,200 --> 00:30:02,460
them and then a more reliable done that

606
00:29:59,340 --> 00:30:06,029
we are going to to work with surf at the

607
00:30:02,460 --> 00:30:08,100
top here you get the ion IMX memory

608
00:30:06,029 --> 00:30:11,549
layout and what we are going to do is

609
00:30:08,100 --> 00:30:14,959
this we are going to recover every piece

610
00:30:11,549 --> 00:30:18,539
of data stolen the enviros blocks and we

611
00:30:14,960 --> 00:30:21,570
are also taking care of the slab guide

612
00:30:18,539 --> 00:30:23,879
which is written in the at the very

613
00:30:21,570 --> 00:30:27,149
beginning of the page and put put this

614
00:30:23,880 --> 00:30:29,460
bike back in the quake block and we are

615
00:30:27,149 --> 00:30:33,809
going to do this for every pages

616
00:30:29,460 --> 00:30:36,720
inaudible so if you want to do this

617
00:30:33,809 --> 00:30:39,720
manually this may takes a lot of time so

618
00:30:36,720 --> 00:30:42,090
this is why we are going to create the

619
00:30:39,720 --> 00:30:45,299
tools so we developed a specific set of

620
00:30:42,090 --> 00:30:47,340
tools we called the IMX none tools so

621
00:30:45,299 --> 00:30:49,918
this is this tool has been published on

622
00:30:47,340 --> 00:30:53,158
a pi PI and also in github so if you

623
00:30:49,919 --> 00:30:55,580
want to have a look at the list or the

624
00:30:53,159 --> 00:30:59,159
source code and so on

625
00:30:55,580 --> 00:31:01,350
feel free to read actually it's written

626
00:30:59,159 --> 00:31:04,289
in Python on own in Python we are

627
00:31:01,350 --> 00:31:06,689
thinking about native version maybe a C

628
00:31:04,289 --> 00:31:08,460
version of this tool because I like I

629
00:31:06,690 --> 00:31:13,590
said it takes a lot of time to process

630
00:31:08,460 --> 00:31:15,240
all these bit shifting so expect form in

631
00:31:13,590 --> 00:31:17,020
order to give you an idea of the time

632
00:31:15,240 --> 00:31:21,400
you need to

633
00:31:17,020 --> 00:31:23,470
processor dump this one gigabyte dump it

634
00:31:21,400 --> 00:31:27,040
takes about ten minutes to process and

635
00:31:23,470 --> 00:31:29,770
to recover the memory the original

636
00:31:27,040 --> 00:31:41,230
memory layout so this is this is not

637
00:31:29,770 --> 00:31:43,600
very efficient but it does a job so you

638
00:31:41,230 --> 00:31:46,060
are going to extract information from

639
00:31:43,600 --> 00:31:49,719
this FC beef so we are going to use a

640
00:31:46,060 --> 00:31:52,060
amx not a fool not info that this tool

641
00:31:49,720 --> 00:31:55,240
extract the contents of the FGB

642
00:31:52,060 --> 00:31:59,050
and this place every field so you can

643
00:31:55,240 --> 00:32:01,570
see the number of bytes in each pages

644
00:31:59,050 --> 00:32:04,210
you can see also the size of the

645
00:32:01,570 --> 00:32:08,220
out-of-band data we can get also the

646
00:32:04,210 --> 00:32:13,360
sizes of the virus blocks the type of

647
00:32:08,220 --> 00:32:17,400
BCH of assisi used the multiple version

648
00:32:13,360 --> 00:32:20,709
of it you can set up different

649
00:32:17,400 --> 00:32:23,500
parameters for the BCH algorithm that

650
00:32:20,710 --> 00:32:27,310
will use more or less byte bit sorry for

651
00:32:23,500 --> 00:32:31,390
the ECC so it depends and we got

652
00:32:27,310 --> 00:32:33,129
everything we need - 12 13 at the bottom

653
00:32:31,390 --> 00:32:36,160
of the this out but you may see that

654
00:32:33,130 --> 00:32:38,760
there is - firmwares from number one and

655
00:32:36,160 --> 00:32:42,150
format number two these firmwares are

656
00:32:38,760 --> 00:32:46,300
dedicated to boot to the booting process

657
00:32:42,150 --> 00:32:48,490
if you set up the system to boot on on a

658
00:32:46,300 --> 00:32:50,500
non flash you can set up set it up to

659
00:32:48,490 --> 00:32:52,810
boot on the first one first firmware or

660
00:32:50,500 --> 00:32:55,510
second firmware so this is some kind of

661
00:32:52,810 --> 00:32:58,510
executable code that the IMX processor

662
00:32:55,510 --> 00:33:01,000
is about to burn so this is not where

663
00:32:58,510 --> 00:33:03,129
you are expecting to find the data or

664
00:33:01,000 --> 00:33:06,430
every partition so you can extract it

665
00:33:03,130 --> 00:33:10,150
with the following tool but it gives you

666
00:33:06,430 --> 00:33:13,030
just binary data you need to analyze so

667
00:33:10,150 --> 00:33:16,930
again it takes 10 minutes to processor 1

668
00:33:13,030 --> 00:33:19,330
gigabyte file so I sped up the video a

669
00:33:16,930 --> 00:33:22,530
bit just to show you the this process

670
00:33:19,330 --> 00:33:27,240
but in fact this is actually working

671
00:33:22,530 --> 00:33:31,770
also specified the - C option to enable

672
00:33:27,240 --> 00:33:35,610
SEC collection so it uses the ECC bid to

673
00:33:31,770 --> 00:33:38,520
fix all the blocks and we are able to

674
00:33:35,610 --> 00:33:42,090
get a very valuable page or flash dump

675
00:33:38,520 --> 00:33:43,918
here with this this this tool so this is

676
00:33:42,090 --> 00:33:47,100
the I immigrant convert so this is the

677
00:33:43,919 --> 00:33:49,260
second tool of this tool set that can be

678
00:33:47,100 --> 00:33:51,779
used to convert an image so once we

679
00:33:49,260 --> 00:33:55,320
converted this image we can again use

680
00:33:51,779 --> 00:33:58,409
bin work to try to find out to extract

681
00:33:55,320 --> 00:34:00,750
the file systems start off stolen it so

682
00:33:58,409 --> 00:34:04,529
if you look carefully you will see that

683
00:34:00,750 --> 00:34:08,639
now the ubi offset is aligned on the

684
00:34:04,529 --> 00:34:12,000
page size so we we can process it very

685
00:34:08,639 --> 00:34:15,690
easily so I'm going to extract the ubi

686
00:34:12,000 --> 00:34:19,379
volume by using DD so this is enough

687
00:34:15,690 --> 00:34:21,839
so come and enjoy very very easy to do

688
00:34:19,379 --> 00:34:24,239
and then you I'm going to use ubi Reader

689
00:34:21,839 --> 00:34:27,449
to extract all the files or the file

690
00:34:24,239 --> 00:34:28,279
systems and then on the files so there

691
00:34:27,449 --> 00:34:31,439
it is

692
00:34:28,280 --> 00:34:35,280
yeah we got everything no eros this time

693
00:34:31,440 --> 00:34:40,320
everything was fine and I'm going to

694
00:34:35,280 --> 00:34:45,030
extract all the images again no euros so

695
00:34:40,320 --> 00:34:47,159
that's pretty cool and yes they are we

696
00:34:45,030 --> 00:34:50,700
got we managed to extract all the images

697
00:34:47,159 --> 00:34:53,490
from the Oba Oba content container

698
00:34:50,699 --> 00:34:55,830
without any problem so this is great and

699
00:34:53,489 --> 00:34:57,810
then we are going to extract all the

700
00:34:55,830 --> 00:35:00,359
files so if you are familiar with ubi

701
00:34:57,810 --> 00:35:03,180
system just to give you another view but

702
00:35:00,359 --> 00:35:06,299
is what is this system it's sourced data

703
00:35:03,180 --> 00:35:08,609
in the volume so you have to do it in

704
00:35:06,300 --> 00:35:11,580
two steps you first extract the images

705
00:35:08,609 --> 00:35:13,650
of each partitions and then you extract

706
00:35:11,580 --> 00:35:16,560
files from each partition these

707
00:35:13,650 --> 00:35:20,270
partitions may use some way known file

708
00:35:16,560 --> 00:35:24,599
system such as a squashy face or other

709
00:35:20,270 --> 00:35:27,480
file systems but ubi also can comes with

710
00:35:24,599 --> 00:35:30,750
its own file system called the ubi FS

711
00:35:27,480 --> 00:35:33,510
and most of the time it's a this file

712
00:35:30,750 --> 00:35:36,480
system that is used to store data so

713
00:35:33,510 --> 00:35:38,880
again we are going to use your PI reader

714
00:35:36,480 --> 00:35:40,800
to extract all of this information so as

715
00:35:38,880 --> 00:35:43,860
I mentioned earlier this this tool is

716
00:35:40,800 --> 00:35:46,470
critical it's written in Python again so

717
00:35:43,860 --> 00:35:49,620
the source code is available on github

718
00:35:46,470 --> 00:35:53,430
you can use it to do a lot of stuff with

719
00:35:49,620 --> 00:35:55,650
this Ruby our system and then by using

720
00:35:53,430 --> 00:35:58,020
this tool we can extract from each image

721
00:35:55,650 --> 00:36:00,240
all the fancies all the facts from the

722
00:35:58,020 --> 00:36:02,610
each image for file systems we can get

723
00:36:00,240 --> 00:36:07,830
back the data and continue to analyze

724
00:36:02,610 --> 00:36:10,470
this device so this is a something quite

725
00:36:07,830 --> 00:36:16,100
unusual yeah but we managed to handle

726
00:36:10,470 --> 00:36:22,259
this so that's what I mean

727
00:36:16,100 --> 00:36:25,290
so some remarks about this IMX system so

728
00:36:22,260 --> 00:36:28,010
this I'll mix system every we France

729
00:36:25,290 --> 00:36:30,779
manual can be found on on the internet

730
00:36:28,010 --> 00:36:35,460
either published by nxp itself of

731
00:36:30,780 --> 00:36:37,800
fiscale or a lot of developers that on

732
00:36:35,460 --> 00:36:40,050
some personal websites and publish on

733
00:36:37,800 --> 00:36:42,570
the website this this reference manuals

734
00:36:40,050 --> 00:36:45,600
or these manuals are thousand pages long

735
00:36:42,570 --> 00:36:47,700
and the unit err to to go through these

736
00:36:45,600 --> 00:36:50,279
manuals to get all the valuable

737
00:36:47,700 --> 00:36:51,720
information but in fact this is open

738
00:36:50,280 --> 00:36:53,760
source the this is open source

739
00:36:51,720 --> 00:36:57,720
information can gather from the internet

740
00:36:53,760 --> 00:37:00,810
so there is no hidden in the engine

741
00:36:57,720 --> 00:37:03,899
information from an XP of rescale also a

742
00:37:00,810 --> 00:37:06,750
lot of publicly available a lot of code

743
00:37:03,900 --> 00:37:08,640
is available on github and if you crawl

744
00:37:06,750 --> 00:37:11,580
and many github repositories you can

745
00:37:08,640 --> 00:37:14,400
find a lot of mentions of the FCB

746
00:37:11,580 --> 00:37:18,360
structure and also the untidy driver if

747
00:37:14,400 --> 00:37:20,520
you go on get up in the Linux kernel

748
00:37:18,360 --> 00:37:24,930
source code you can find some drivers

749
00:37:20,520 --> 00:37:27,120
and link this GP mi component Japan

750
00:37:24,930 --> 00:37:29,520
system so in this source code you can

751
00:37:27,120 --> 00:37:30,810
find everything you need such as the

752
00:37:29,520 --> 00:37:34,680
details of this

753
00:37:30,810 --> 00:37:37,940
FCB structure and also the way the ECC

754
00:37:34,680 --> 00:37:40,890
word so this is quite this is not very

755
00:37:37,940 --> 00:37:43,470
obscure you know you need to to gather

756
00:37:40,890 --> 00:37:45,480
every piece of information and put it in

757
00:37:43,470 --> 00:37:48,120
put it together through to understand

758
00:37:45,480 --> 00:37:51,630
how it works but in fact the anybody can

759
00:37:48,120 --> 00:37:53,960
do it so this is the next track of the

760
00:37:51,630 --> 00:37:56,060
IMX knobs

761
00:37:53,960 --> 00:37:58,550
a github repository which is managed by

762
00:37:56,060 --> 00:38:00,890
an XP this is a legitimate

763
00:37:58,550 --> 00:38:04,099
representative and in this repository we

764
00:38:00,890 --> 00:38:06,500
can find the FCB block definition so

765
00:38:04,099 --> 00:38:08,510
this is a question for water to get this

766
00:38:06,500 --> 00:38:10,970
information the fact is that you need to

767
00:38:08,510 --> 00:38:14,720
sub to look for it to get this in this

768
00:38:10,970 --> 00:38:18,080
info again some extracted extract from

769
00:38:14,720 --> 00:38:21,230
our github from this time the u-boot

770
00:38:18,080 --> 00:38:24,470
source code and nubert contains some a

771
00:38:21,230 --> 00:38:27,980
specific code for IMX system AMX 28

772
00:38:24,470 --> 00:38:31,399
especially so this is M X 28 none get

773
00:38:27,980 --> 00:38:36,760
ECC strength and this is the formula to

774
00:38:31,400 --> 00:38:39,830
compute the size of your ACC bitsy block

775
00:38:36,760 --> 00:38:42,619
depending on the page data size and pgo

776
00:38:39,830 --> 00:38:44,900
besides so the specification of your own

777
00:38:42,619 --> 00:38:49,339
on flash so this is quite interesting

778
00:38:44,900 --> 00:38:52,210
because you can expect none flash to

779
00:38:49,339 --> 00:38:54,740
have this this number of bits of ECC

780
00:38:52,210 --> 00:38:58,070
depending on these settings you can get

781
00:38:54,740 --> 00:39:01,700
from the data sheet itself so the main

782
00:38:58,070 --> 00:39:04,240
concern here that is that this IMX is x

783
00:39:01,700 --> 00:39:06,589
allows data encryption we can use

784
00:39:04,240 --> 00:39:09,500
on-the-fly encryption for your NAND

785
00:39:06,589 --> 00:39:12,200
flash or even your SD card or even seeds

786
00:39:09,500 --> 00:39:14,990
which are different ways to store data

787
00:39:12,200 --> 00:39:17,930
on a remix system but this system

788
00:39:14,990 --> 00:39:22,129
supports this non flash encryption

789
00:39:17,930 --> 00:39:24,680
feature so this is possible to use this

790
00:39:22,130 --> 00:39:26,420
encryption but guess what most of the

791
00:39:24,680 --> 00:39:29,419
systems we analyzed

792
00:39:26,420 --> 00:39:31,010
we tested and this didn't use this

793
00:39:29,420 --> 00:39:33,710
feature because you know it's more

794
00:39:31,010 --> 00:39:36,290
convenient for for vandalism in fact

795
00:39:33,710 --> 00:39:41,030
roster not to use this encryption

796
00:39:36,290 --> 00:39:44,540
process so this is something yeah come

797
00:39:41,030 --> 00:39:48,950
on in the embedded device industry I can

798
00:39:44,540 --> 00:39:50,599
say it's a it's difficult to set up for

799
00:39:48,950 --> 00:39:52,609
some people difficult to set up this

800
00:39:50,599 --> 00:39:58,160
encryption mechanism so they don't use

801
00:39:52,609 --> 00:40:03,109
it and there are also some non variants

802
00:39:58,160 --> 00:40:04,310
of this this G PMI component because we

803
00:40:03,109 --> 00:40:07,220
found a limb

804
00:40:04,310 --> 00:40:10,460
but various some repositories on github

805
00:40:07,220 --> 00:40:12,830
with different versions of this of the

806
00:40:10,460 --> 00:40:16,250
GPM I component and most of the time

807
00:40:12,830 --> 00:40:18,830
this very the virus or different version

808
00:40:16,250 --> 00:40:23,570
of this GPM I driver depends on the

809
00:40:18,830 --> 00:40:25,220
bootrom put in the AMX system remember I

810
00:40:23,570 --> 00:40:28,160
told you at the beginning of the talk

811
00:40:25,220 --> 00:40:31,819
there is a specific bootrom embedded the

812
00:40:28,160 --> 00:40:37,029
in the AMX processor so this is

813
00:40:31,820 --> 00:40:41,000
something that has evolved over time and

814
00:40:37,030 --> 00:40:43,700
they also made changes to this FC big

815
00:40:41,000 --> 00:40:47,150
structure and also switches as well so

816
00:40:43,700 --> 00:40:49,069
you know you may expect some now some

817
00:40:47,150 --> 00:40:50,990
issues so this the current version of

818
00:40:49,070 --> 00:40:54,830
I'll mix 9 tools what for all of atoms

819
00:40:50,990 --> 00:40:56,990
but maybe it was for the late latest

820
00:40:54,830 --> 00:41:00,049
version of this bridge ROM we did not

821
00:40:56,990 --> 00:41:02,629
have the opportunity to test it on

822
00:41:00,050 --> 00:41:06,800
various version of this boot ROM and

823
00:41:02,630 --> 00:41:09,410
especially older versions so the only

824
00:41:06,800 --> 00:41:13,460
way to to know is to install test and

825
00:41:09,410 --> 00:41:15,500
contribute with to this to this tool so

826
00:41:13,460 --> 00:41:18,170
we opened to pull request and github and

827
00:41:15,500 --> 00:41:21,800
if you want to test it she found some

828
00:41:18,170 --> 00:41:26,590
bags in the store feel free to to to

829
00:41:21,800 --> 00:41:26,590
collaborate and to to fight upon request

830
00:41:26,830 --> 00:41:35,690
so as a conclusion I am existence use a

831
00:41:32,000 --> 00:41:40,010
custom non-flash layered and documented

832
00:41:35,690 --> 00:41:41,840
till now this day art is documented in

833
00:41:40,010 --> 00:41:44,990
various documents and publicly available

834
00:41:41,840 --> 00:41:46,250
codes everything no very specific

835
00:41:44,990 --> 00:41:49,279
explanation a very detailed explanation

836
00:41:46,250 --> 00:41:51,170
of all this layered works but all of

837
00:41:49,280 --> 00:41:54,860
this information is split among the

838
00:41:51,170 --> 00:41:56,810
various documents sub this this explains

839
00:41:54,860 --> 00:42:00,770
why it's not documented

840
00:41:56,810 --> 00:42:02,570
I am victim told this is a tool we we've

841
00:42:00,770 --> 00:42:04,730
developed provides a set of tools to

842
00:42:02,570 --> 00:42:06,980
handle this day out and convert them

843
00:42:04,730 --> 00:42:11,360
into useable images so the other bit of

844
00:42:06,980 --> 00:42:13,730
a trouble to solve this issue and of

845
00:42:11,360 --> 00:42:15,830
course I am existence should use a non

846
00:42:13,730 --> 00:42:18,080
fashioned caption feature to avoid key

847
00:42:15,830 --> 00:42:21,890
password or IP leaks

848
00:42:18,080 --> 00:42:25,279
from them so just did conclude I got a

849
00:42:21,890 --> 00:42:31,870
call from the project security incident

850
00:42:25,280 --> 00:42:34,460
response team manager a few days ago and

851
00:42:31,870 --> 00:42:36,890
this guy explained to me that they are

852
00:42:34,460 --> 00:42:38,960
expecting so much Tom for their

853
00:42:36,890 --> 00:42:42,950
customers coming from the customer you

854
00:42:38,960 --> 00:42:47,030
know a lot of customers use of an XP use

855
00:42:42,950 --> 00:42:50,330
this I missed em and the at least for

856
00:42:47,030 --> 00:42:52,550
the recent years they were expecting

857
00:42:50,330 --> 00:42:54,799
some kind of security because nobody was

858
00:42:52,550 --> 00:42:56,690
about to extract the data from the non

859
00:42:54,800 --> 00:43:00,140
flash chips because of this custom

860
00:42:56,690 --> 00:43:03,170
layout they are using but in fact they

861
00:43:00,140 --> 00:43:07,040
are going to I hope discover that this

862
00:43:03,170 --> 00:43:10,850
custom layered is no longer undocumented

863
00:43:07,040 --> 00:43:12,560
and maybe it will make the you know this

864
00:43:10,850 --> 00:43:14,690
customer move forward in terms of

865
00:43:12,560 --> 00:43:19,220
security and maybe use this encryption

866
00:43:14,690 --> 00:43:21,710
mechanism so who knows but in fact this

867
00:43:19,220 --> 00:43:25,160
is a very common to not to use

868
00:43:21,710 --> 00:43:27,590
encryption in the various devices we we

869
00:43:25,160 --> 00:44:11,210
test it so thank you for attending if

870
00:43:27,590 --> 00:44:13,700
you have any question no nobody yeah so

871
00:44:11,210 --> 00:44:16,640
if I don't understand well you monitor

872
00:44:13,700 --> 00:44:20,960
the CPU and you so that it reads one

873
00:44:16,640 --> 00:44:23,750
kilobyte plus thirteen bytes on a page

874
00:44:20,960 --> 00:44:27,490
when where the datasheet stated that

875
00:44:23,750 --> 00:44:27,490
it's a 4 kilobyte page

876
00:44:28,290 --> 00:44:34,160
yeah 21 and 24 for instance yeah I I got

877
00:44:32,220 --> 00:44:36,930
no explanation maybe it's some kind of

878
00:44:34,160 --> 00:44:38,520
variance of a specific version of the

879
00:44:36,930 --> 00:44:40,859
chip you know when you go through the

880
00:44:38,520 --> 00:44:44,310
datasheet there are some specifications

881
00:44:40,860 --> 00:44:46,320
where that very standard such as the one

882
00:44:44,310 --> 00:44:50,790
I showed you but but in fact there are

883
00:44:46,320 --> 00:44:54,470
some you know some variants of non-flash

884
00:44:50,790 --> 00:44:58,529
chips in which the page size may change

885
00:44:54,470 --> 00:45:01,259
so be sure to take the correct data

886
00:44:58,530 --> 00:45:03,660
sheet when you are doing this it may be

887
00:45:01,260 --> 00:45:05,910
anywhere from the documentation itself

888
00:45:03,660 --> 00:45:07,950
you know sometimes people writing this

889
00:45:05,910 --> 00:45:12,149
documentation these data sheets may do

890
00:45:07,950 --> 00:45:15,240
some arrows but in fact it's a it's not

891
00:45:12,150 --> 00:45:15,690
so common so maybe you got the one data

892
00:45:15,240 --> 00:45:20,700
sheet

893
00:45:15,690 --> 00:45:23,190
maybe the software that uses this this

894
00:45:20,700 --> 00:45:26,580
flash chip may consider that this flashy

895
00:45:23,190 --> 00:45:29,160
pass on only one kilobyte page what

896
00:45:26,580 --> 00:45:31,200
about one kilobyte page size and and

897
00:45:29,160 --> 00:45:33,690
that's it so I'm basically did maybe

898
00:45:31,200 --> 00:45:36,180
this this software things that this

899
00:45:33,690 --> 00:45:39,420
flash chip is only one kilobyte page

900
00:45:36,180 --> 00:45:41,279
size and then it reduces just a part of

901
00:45:39,420 --> 00:45:56,040
it to stall the data I don't know if

902
00:45:41,280 --> 00:46:28,530
this can be can be both no yeah I didn't

903
00:45:56,040 --> 00:46:32,009
get it sorry yeah yeah yeah I don't

904
00:46:28,530 --> 00:46:35,490
understand anything I wish maybe we will

905
00:46:32,010 --> 00:46:37,980
talk about it later so you have known

906
00:46:35,490 --> 00:46:41,899
yeah more clear audio but what you're

907
00:46:37,980 --> 00:46:43,230
talking about yeah okay anybody know

908
00:46:41,900 --> 00:46:46,700
okay bye

909
00:46:43,230 --> 00:46:46,700
thank you for the name

910
00:46:54,950 --> 00:46:57,009
you

