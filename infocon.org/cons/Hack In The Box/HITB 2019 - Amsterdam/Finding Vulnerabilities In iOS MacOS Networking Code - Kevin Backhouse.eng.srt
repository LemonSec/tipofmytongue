1
00:00:19,689 --> 00:00:22,080
thank you very much so yes my name is

2
00:00:21,460 --> 00:00:23,880
Kevin back

3
00:00:22,080 --> 00:00:26,430
I'm a member of cemil's security

4
00:00:23,880 --> 00:00:28,290
research team and I'm gonna be talking

5
00:00:26,430 --> 00:00:32,130
about some vulnerabilities I found

6
00:00:28,290 --> 00:00:34,650
during the course of 2018 in iOS and Mac

7
00:00:32,130 --> 00:00:37,739
OS so what I'm really talking about here

8
00:00:34,650 --> 00:00:40,890
is the xnu kernel it's shared between

9
00:00:37,739 --> 00:00:43,349
both iOS and Mac OS so if you find a bug

10
00:00:40,890 --> 00:00:46,170
in X in you then that typically means

11
00:00:43,350 --> 00:00:51,360
that you've found something in both of

12
00:00:46,170 --> 00:00:56,519
those platforms okay so this is really a

13
00:00:51,360 --> 00:00:59,460
story of three bugs as you can see

14
00:00:56,519 --> 00:01:00,960
there's more than three CVEs but I think

15
00:00:59,460 --> 00:01:03,629
of these as really just three bugs

16
00:01:00,960 --> 00:01:05,280
because what happened here was that

17
00:01:03,629 --> 00:01:09,420
there was there was kind of multiple

18
00:01:05,280 --> 00:01:12,240
variants of the of the bugs to a certain

19
00:01:09,420 --> 00:01:16,070
extent it's also the story of my career

20
00:01:12,240 --> 00:01:18,298
so far as a security researcher I'm

21
00:01:16,070 --> 00:01:20,639
approximately the the right age that I

22
00:01:18,299 --> 00:01:23,909
could have been in the cult of the dead

23
00:01:20,640 --> 00:01:25,590
cow with beta but in fact I didn't do

24
00:01:23,909 --> 00:01:29,220
any of that stuff when I was teenager I

25
00:01:25,590 --> 00:01:33,600
didn't do anything related to trying to

26
00:01:29,220 --> 00:01:39,120
hack or break anything prior to 2017 so

27
00:01:33,600 --> 00:01:43,139
this this bug here was one of the first

28
00:01:39,120 --> 00:01:45,240
CVS I ever got and as you'll find out in

29
00:01:43,140 --> 00:01:47,700
a second I really didn't know what I was

30
00:01:45,240 --> 00:01:49,560
looking for when I found that and at the

31
00:01:47,700 --> 00:01:51,960
time it actually felt kind of like a

32
00:01:49,560 --> 00:01:56,310
fluke I thought I'm never going to find

33
00:01:51,960 --> 00:01:57,839
anything like this again but in fact so

34
00:01:56,310 --> 00:02:00,690
I mean what you also see is that this

35
00:01:57,840 --> 00:02:02,940
packet mangler bug isn't nearly as

36
00:02:00,690 --> 00:02:04,679
exciting in terms of like the severity

37
00:02:02,940 --> 00:02:07,170
of the vulnerability as the the ones

38
00:02:04,680 --> 00:02:09,629
that came next what it did do was it

39
00:02:07,170 --> 00:02:11,580
taught me about what might be

40
00:02:09,628 --> 00:02:13,470
interesting to look for and that's what

41
00:02:11,580 --> 00:02:15,950
led to me finding these other bugs in in

42
00:02:13,470 --> 00:02:15,950
xnu

43
00:02:16,420 --> 00:02:24,429
okay so there's also going to be a few

44
00:02:22,209 --> 00:02:27,000
extra topics during the course of the

45
00:02:24,430 --> 00:02:30,340
presentation some of these things are

46
00:02:27,000 --> 00:02:31,720
potentially a bit dull so what I'm going

47
00:02:30,340 --> 00:02:33,670
to do is I'm going to try and weave them

48
00:02:31,720 --> 00:02:35,500
in when it's actually relevant to the

49
00:02:33,670 --> 00:02:36,790
story so I'm going to focus on the box

50
00:02:35,500 --> 00:02:42,489
and I'm going to talk about these things

51
00:02:36,790 --> 00:02:44,679
when it's when it's relevant okay so

52
00:02:42,489 --> 00:02:47,080
we'll just start with the the packet

53
00:02:44,680 --> 00:02:50,260
Mangala bug this is a cartoon that my

54
00:02:47,080 --> 00:02:53,980
son drew I kind of explained to him

55
00:02:50,260 --> 00:02:55,540
roughly what what happens and he likes

56
00:02:53,980 --> 00:02:56,920
drawing cartoons so he turned it into a

57
00:02:55,540 --> 00:02:58,690
little cartoon for me which i think is

58
00:02:56,920 --> 00:03:01,119
pretty cool I've got one of these for

59
00:02:58,690 --> 00:03:02,470
each of the each of the three bugs so

60
00:03:01,120 --> 00:03:03,940
just to explain quickly who the

61
00:03:02,470 --> 00:03:06,880
characters are

62
00:03:03,940 --> 00:03:09,730
this guy's he's called Eve 9 9 9 and

63
00:03:06,880 --> 00:03:12,370
he's a cyborg he's one of the heroes and

64
00:03:09,730 --> 00:03:16,780
this is one of the other heroes called

65
00:03:12,370 --> 00:03:18,160
Adam man who's a huge living atom so

66
00:03:16,780 --> 00:03:20,620
what happens here is they receive an

67
00:03:18,160 --> 00:03:23,410
evil packet and they say what should we

68
00:03:20,620 --> 00:03:25,780
do and the atom man says let's mangle it

69
00:03:23,410 --> 00:03:28,150
and as you can see that doesn't work out

70
00:03:25,780 --> 00:03:32,610
so well for them this is the villain

71
00:03:28,150 --> 00:03:35,769
this is slow Sally who is a robotic car

72
00:03:32,610 --> 00:03:44,260
so let me just show you now a quick

73
00:03:35,769 --> 00:03:46,810
video of what this looks like so I can

74
00:03:44,260 --> 00:03:53,500
send something over the network that is

75
00:03:46,810 --> 00:03:56,140
going to crash the the Mac now the

76
00:03:53,500 --> 00:03:57,250
reason that this is not as exciting as

77
00:03:56,140 --> 00:04:00,220
some of the bugs and I'm going to show

78
00:03:57,250 --> 00:04:02,890
you later is because it only works when

79
00:04:00,220 --> 00:04:06,400
the packet mangal is switched on and so

80
00:04:02,890 --> 00:04:09,339
the packet manga it's in the kernel but

81
00:04:06,400 --> 00:04:11,829
it seems to be some sort of vestigial

82
00:04:09,340 --> 00:04:13,420
thing that doesn't actually get used so

83
00:04:11,829 --> 00:04:15,459
although it's there and you can switch

84
00:04:13,420 --> 00:04:17,649
it on you need to have admin privileges

85
00:04:15,459 --> 00:04:20,048
to switch it on and nobody as far as I

86
00:04:17,649 --> 00:04:20,709
can tell ever does that so I got a CV

87
00:04:20,048 --> 00:04:24,520
for this

88
00:04:20,709 --> 00:04:26,289
well multiple but the severity isn't all

89
00:04:24,520 --> 00:04:29,510
that bad because of the the fact that

90
00:04:26,289 --> 00:04:30,919
the packet mangers not switched on but

91
00:04:29,510 --> 00:04:32,960
I do think the code is really

92
00:04:30,920 --> 00:04:36,550
interesting to look at and so that's why

93
00:04:32,960 --> 00:04:36,549
I'm gonna be talking about this first

94
00:04:39,880 --> 00:04:46,909
next slide okay there we go alright so

95
00:04:43,820 --> 00:04:48,650
this was one of the first bugs that I

96
00:04:46,910 --> 00:04:51,320
ever found so I didn't really know how

97
00:04:48,650 --> 00:04:52,880
to find security vulnerabilities and so

98
00:04:51,320 --> 00:04:55,460
I was kind of sort of just hunting

99
00:04:52,880 --> 00:04:58,790
around at the dark and so I was just

100
00:04:55,460 --> 00:05:01,310
looking for generic stuff so what I

101
00:04:58,790 --> 00:05:02,810
decided to look for was can I find

102
00:05:01,310 --> 00:05:06,140
anywhere where there's an array index

103
00:05:02,810 --> 00:05:07,660
that might have an integer overflow in

104
00:05:06,140 --> 00:05:12,349
it that that could potentially be a

105
00:05:07,660 --> 00:05:14,930
security vulnerability so I'm going to

106
00:05:12,350 --> 00:05:17,410
show you now is QL the the query

107
00:05:14,930 --> 00:05:21,890
language that I use to find this stuff

108
00:05:17,410 --> 00:05:23,630
this is free you can I mean it is a

109
00:05:21,890 --> 00:05:25,010
product that's made by my company but it

110
00:05:23,630 --> 00:05:27,050
this is all free so everything I'm going

111
00:05:25,010 --> 00:05:29,390
to show you here you can download and

112
00:05:27,050 --> 00:05:34,820
you can you can try it yourself on any

113
00:05:29,390 --> 00:05:37,430
any open source software so what I've

114
00:05:34,820 --> 00:05:39,650
got over here just in the left hand

115
00:05:37,430 --> 00:05:44,840
column so you can see I've got snapshots

116
00:05:39,650 --> 00:05:46,700
for the all of the recent versions of

117
00:05:44,840 --> 00:05:49,820
the X a new kernel the Apple of

118
00:05:46,700 --> 00:05:51,620
published I think they're there beyond

119
00:05:49,820 --> 00:05:53,000
ten point fourteen point one at this

120
00:05:51,620 --> 00:05:54,980
point but they haven't published the

121
00:05:53,000 --> 00:05:57,800
source code yet so that's that's all

122
00:05:54,980 --> 00:06:01,040
I've got but this was something I found

123
00:05:57,800 --> 00:06:03,970
in version 10 point 13 so I can click on

124
00:06:01,040 --> 00:06:07,370
that and I can say use this database and

125
00:06:03,970 --> 00:06:17,420
so then the array the the query that I

126
00:06:07,370 --> 00:06:20,120
wrote was very simple it just said find

127
00:06:17,420 --> 00:06:23,420
me basically something like this you've

128
00:06:20,120 --> 00:06:26,840
got an array indexing expression and

129
00:06:23,420 --> 00:06:29,680
it's got an add in the index and there's

130
00:06:26,840 --> 00:06:34,909
a possibility that the index might

131
00:06:29,680 --> 00:06:40,100
overflow and so you run this ear on this

132
00:06:34,910 --> 00:06:43,580
query and it founds a few things and a

133
00:06:40,100 --> 00:06:46,880
lot of these turned out not to be in

134
00:06:43,580 --> 00:06:49,070
but this one was so this is in the

135
00:06:46,880 --> 00:06:55,120
packet Mangler and it's adding these two

136
00:06:49,070 --> 00:06:58,490
variables I and J they're both int and

137
00:06:55,120 --> 00:07:00,260
our range analysis was not able to prove

138
00:06:58,490 --> 00:07:01,730
that this can't overflow now a lot of

139
00:07:00,260 --> 00:07:06,890
the time when you do range analysis is

140
00:07:01,730 --> 00:07:08,390
very difficult to actually come up with

141
00:07:06,890 --> 00:07:09,890
accurate results so a lot of the time

142
00:07:08,390 --> 00:07:11,780
when you're looking for overflows in C

143
00:07:09,890 --> 00:07:14,390
code you'll find that almost anything

144
00:07:11,780 --> 00:07:15,710
might overflow because range analysis

145
00:07:14,390 --> 00:07:17,390
isn't smart enough to be able to

146
00:07:15,710 --> 00:07:20,659
understand the kind of subtle invariants

147
00:07:17,390 --> 00:07:22,070
that are going on but in this case it

148
00:07:20,660 --> 00:07:25,390
turns out that it was totally right

149
00:07:22,070 --> 00:07:27,980
because they're doing stuff like this

150
00:07:25,390 --> 00:07:30,050
they're just doing plus equals on the

151
00:07:27,980 --> 00:07:36,110
the eye and if you go and look at the

152
00:07:30,050 --> 00:07:37,360
the loops that it's in TCP OPLAN is one

153
00:07:36,110 --> 00:07:39,620
of the things that it's looping over

154
00:07:37,360 --> 00:07:44,720
it's just going to stop when the thing

155
00:07:39,620 --> 00:07:46,850
is zero so it's really not written very

156
00:07:44,720 --> 00:07:47,390
carefully TCP OPLAN they're doing stuff

157
00:07:46,850 --> 00:07:50,330
like this

158
00:07:47,390 --> 00:07:53,030
so as an attacker you can easily make

159
00:07:50,330 --> 00:07:55,419
that overshoot go negative and then the

160
00:07:53,030 --> 00:07:59,599
loop is just never going to end

161
00:07:55,420 --> 00:08:02,750
so the other thing that's happening here

162
00:07:59,600 --> 00:08:06,080
is that this array here is on the stack

163
00:08:02,750 --> 00:08:07,820
so this is in fact a potential stack

164
00:08:06,080 --> 00:08:12,080
stack buffer overflow where you're

165
00:08:07,820 --> 00:08:14,630
writing potentially beyond the beyond

166
00:08:12,080 --> 00:08:21,169
the end of the array now just to quickly

167
00:08:14,630 --> 00:08:26,150
show you so m TMP tcp OPLAN that comes

168
00:08:21,170 --> 00:08:31,520
from here tcp opt off so let me go down

169
00:08:26,150 --> 00:08:36,049
back to the presentation now so this is

170
00:08:31,520 --> 00:08:37,520
a tweet that I kind of agree with I feel

171
00:08:36,049 --> 00:08:39,919
this way as well there's a lot of stuff

172
00:08:37,520 --> 00:08:41,659
that I've I've kind of started to learn

173
00:08:39,919 --> 00:08:42,829
about as a result of being a security

174
00:08:41,659 --> 00:08:46,520
engineer that I never would have

175
00:08:42,830 --> 00:08:49,370
bothered learning about otherwise but so

176
00:08:46,520 --> 00:08:52,910
this is the first one so tcp/ip packet

177
00:08:49,370 --> 00:08:55,600
structure I guess a lot of you probably

178
00:08:52,910 --> 00:08:57,469
already know about this already but the

179
00:08:55,600 --> 00:09:00,950
initially you have 20

180
00:08:57,470 --> 00:09:05,090
so of the IP header and then you've got

181
00:09:00,950 --> 00:09:07,190
some IP options offten zero but you can

182
00:09:05,090 --> 00:09:09,340
put options in there then you've got the

183
00:09:07,190 --> 00:09:12,200
TCP header which is also 20 bytes

184
00:09:09,340 --> 00:09:14,060
followed by the TCP options and then the

185
00:09:12,200 --> 00:09:16,220
payload the payload I think in theory

186
00:09:14,060 --> 00:09:20,890
can go up to 64 K but in practices

187
00:09:16,220 --> 00:09:23,210
almost always less than 1,400 bytes

188
00:09:20,890 --> 00:09:24,920
now of course normally when you're using

189
00:09:23,210 --> 00:09:26,570
TCP sockets you don't need to care about

190
00:09:24,920 --> 00:09:29,599
this stuff at all because you just open

191
00:09:26,570 --> 00:09:31,970
a socket and the whole point of TCP is

192
00:09:29,600 --> 00:09:33,170
that it it breaks it up into packets for

193
00:09:31,970 --> 00:09:34,730
you you don't need to worry about that

194
00:09:33,170 --> 00:09:36,229
you just you just send a stream of data

195
00:09:34,730 --> 00:09:42,830
and it gets received on the other end

196
00:09:36,230 --> 00:09:44,360
but if you want to try to write a POC

197
00:09:42,830 --> 00:09:47,720
for a vulnerability then you do need to

198
00:09:44,360 --> 00:09:49,760
use this stuff sometimes so from what

199
00:09:47,720 --> 00:09:52,070
I've seen we'll come back to this later

200
00:09:49,760 --> 00:09:53,840
the IP options almost never use they're

201
00:09:52,070 --> 00:09:55,250
almost always zero whereas the TCP

202
00:09:53,840 --> 00:09:57,680
options are actually quite frequently

203
00:09:55,250 --> 00:10:03,890
used TCP packets often have have options

204
00:09:57,680 --> 00:10:09,890
in them and so that's the data that this

205
00:10:03,890 --> 00:10:11,960
code is reading this is that section of

206
00:10:09,890 --> 00:10:14,210
the the header where the the TCP options

207
00:10:11,960 --> 00:10:16,010
are so this is attack of controllable I

208
00:10:14,210 --> 00:10:18,380
mean you can send you can send a network

209
00:10:16,010 --> 00:10:20,300
message over the over Wi-Fi with

210
00:10:18,380 --> 00:10:21,710
whatever you like in there and it's

211
00:10:20,300 --> 00:10:25,880
going to read it directly out of there

212
00:10:21,710 --> 00:10:26,960
into MP TCP OPLAN and in fact the way

213
00:10:25,880 --> 00:10:28,520
that they've declared this they've

214
00:10:26,960 --> 00:10:29,660
declared it as char so it's a signed

215
00:10:28,520 --> 00:10:34,900
number so you can actually make this

216
00:10:29,660 --> 00:10:39,230
thing signed if you feel like it okay so

217
00:10:34,900 --> 00:10:42,800
next step now we need to learn how to do

218
00:10:39,230 --> 00:10:43,960
raw socket programming so again this was

219
00:10:42,800 --> 00:10:47,900
something I didn't know about before

220
00:10:43,960 --> 00:10:52,690
this first one is the link where I found

221
00:10:47,900 --> 00:10:55,040
sample code to learn how to do this and

222
00:10:52,690 --> 00:10:58,339
having now done it myself you can also

223
00:10:55,040 --> 00:11:00,740
see it on our github page the the POC

224
00:10:58,339 --> 00:11:06,310
that I wrote for this is is on our our

225
00:11:00,740 --> 00:11:08,350
github so raw socket programming

226
00:11:06,310 --> 00:11:09,619
basically means

227
00:11:08,350 --> 00:11:12,660
[Music]

228
00:11:09,620 --> 00:11:14,580
filling in the filling and the headers

229
00:11:12,660 --> 00:11:17,850
yourself and these are the kind of basic

230
00:11:14,580 --> 00:11:22,500
steps so what you do is you you open the

231
00:11:17,850 --> 00:11:24,300
socket with sock rule and then you tell

232
00:11:22,500 --> 00:11:25,740
the kernel that you're going to include

233
00:11:24,300 --> 00:11:29,670
your own headers it doesn't need to add

234
00:11:25,740 --> 00:11:31,709
the headers for you then you obviously

235
00:11:29,670 --> 00:11:35,279
need to initialize the packet with all

236
00:11:31,709 --> 00:11:37,770
the correct header information and for

237
00:11:35,279 --> 00:11:39,300
that I recommend you do is just go grab

238
00:11:37,770 --> 00:11:41,899
one of those examples and then tweak the

239
00:11:39,300 --> 00:11:46,770
bits that you you need to tweak yourself

240
00:11:41,899 --> 00:11:47,880
and then you can send the packet one of

241
00:11:46,770 --> 00:11:49,410
the other fun things you can do with raw

242
00:11:47,880 --> 00:11:52,740
sockets actually as well as you can also

243
00:11:49,410 --> 00:11:54,540
write a kind of your own packet sniffer

244
00:11:52,740 --> 00:11:55,890
you can with with the raw socket you can

245
00:11:54,540 --> 00:11:59,160
actually see all the packets are

246
00:11:55,890 --> 00:12:00,899
happening on your on your network which

247
00:11:59,160 --> 00:12:07,020
can be can be useful for debugging

248
00:12:00,899 --> 00:12:09,709
sometimes okay and so then the the way

249
00:12:07,020 --> 00:12:15,390
that the the POC actually worked was

250
00:12:09,709 --> 00:12:18,750
it's stuck these these two values into

251
00:12:15,390 --> 00:12:22,020
the TCP options and that's what that's

252
00:12:18,750 --> 00:12:26,310
what triggers the bug because this thing

253
00:12:22,020 --> 00:12:28,770
has to be multipath TCP and then the

254
00:12:26,310 --> 00:12:31,859
second one so I plus one is what gets

255
00:12:28,770 --> 00:12:33,800
written into there and that makes bad

256
00:12:31,860 --> 00:12:37,770
things happen

257
00:12:33,800 --> 00:12:39,120
so the thing that took me a little bits

258
00:12:37,770 --> 00:12:44,720
of I surprised when I first wrote the

259
00:12:39,120 --> 00:12:46,649
pork it didn't seem to be working and I

260
00:12:44,720 --> 00:12:49,079
couldn't quite figure out what was going

261
00:12:46,649 --> 00:12:51,300
on and then my Apple what the Mac that I

262
00:12:49,079 --> 00:12:53,399
was using seems to have lost its

263
00:12:51,300 --> 00:12:54,630
internet access and so that was puzzling

264
00:12:53,399 --> 00:12:56,010
me for a while it actually took me about

265
00:12:54,630 --> 00:12:58,050
an hour to figure out what's going on

266
00:12:56,010 --> 00:12:59,550
which is quite embarrassing it turned

267
00:12:58,050 --> 00:13:00,750
out that what I'd done was rather than

268
00:12:59,550 --> 00:13:02,729
crashing the kernel which is what I

269
00:13:00,750 --> 00:13:04,560
thought was going to happen because this

270
00:13:02,730 --> 00:13:06,930
does appear to involve a stack buffer

271
00:13:04,560 --> 00:13:08,670
overflow what actually ended up

272
00:13:06,930 --> 00:13:12,870
happening was ended up getting stuck in

273
00:13:08,670 --> 00:13:15,589
an infinite loop so this was more of a

274
00:13:12,870 --> 00:13:19,589
denial of service varner ability this

275
00:13:15,589 --> 00:13:21,570
2017 1394 where you could send a packet

276
00:13:19,589 --> 00:13:23,220
to the Mac and it would trigger an

277
00:13:21,570 --> 00:13:25,620
infinite loop so that

278
00:13:23,220 --> 00:13:27,330
is now running one of its cores at

279
00:13:25,620 --> 00:13:29,360
hundred percent and it can't connect to

280
00:13:27,330 --> 00:13:37,080
the internet anymore

281
00:13:29,360 --> 00:13:42,600
okay so that bug in fact I I i reported

282
00:13:37,080 --> 00:13:45,150
to Apple in July of 2017 and it took a

283
00:13:42,600 --> 00:13:47,700
long time before I heard anything about

284
00:13:45,150 --> 00:13:50,280
it so it wasn't until February 2018 I

285
00:13:47,700 --> 00:13:51,690
got in touch with them say what's

286
00:13:50,280 --> 00:13:56,189
happened with this did you ever fix it

287
00:13:51,690 --> 00:13:57,870
and they said we fixed in December so I

288
00:13:56,190 --> 00:13:59,940
went back and look at look to the code

289
00:13:57,870 --> 00:14:02,550
and I honestly couldn't see what they

290
00:13:59,940 --> 00:14:08,790
changed from the code I figured it out

291
00:14:02,550 --> 00:14:10,589
now so if I go here and I select ten

292
00:14:08,790 --> 00:14:12,150
point thirteen point three which i think

293
00:14:10,590 --> 00:14:18,180
is the version that was out at that

294
00:14:12,150 --> 00:14:28,590
point and I run the same same query

295
00:14:18,180 --> 00:14:31,229
again where is it the only thing that

296
00:14:28,590 --> 00:14:38,670
they changed was they put a greater than

297
00:14:31,230 --> 00:14:40,830
in here so that didn't fix anything I

298
00:14:38,670 --> 00:14:45,120
could still cause a an infinite loop by

299
00:14:40,830 --> 00:14:46,650
basically just saying well what happened

300
00:14:45,120 --> 00:14:49,320
was I decided that would be easier to

301
00:14:46,650 --> 00:14:51,930
use this one here so I just made this

302
00:14:49,320 --> 00:14:53,820
this value here B zero and that means

303
00:14:51,930 --> 00:14:55,140
that the value of TCP OPLAN doesn't

304
00:14:53,820 --> 00:14:57,690
change and some of this thing just get

305
00:14:55,140 --> 00:14:59,310
stuck in an infinite loop so I I said

306
00:14:57,690 --> 00:15:02,520
that back to them and I said it's not

307
00:14:59,310 --> 00:15:07,170
fixed I can still cause a an infinite

308
00:15:02,520 --> 00:15:08,699
loop but the other thing when I mean I

309
00:15:07,170 --> 00:15:10,140
guess I kind of had more confidence in

310
00:15:08,700 --> 00:15:12,900
the kernel developers at this point

311
00:15:10,140 --> 00:15:16,650
where I thought that if I report a bug

312
00:15:12,900 --> 00:15:18,689
to them then they're going to go over

313
00:15:16,650 --> 00:15:21,020
this comb code with a fine-tooth comb

314
00:15:18,690 --> 00:15:23,490
and they're just going to fix everything

315
00:15:21,020 --> 00:15:25,170
that's not what happened at all I mean

316
00:15:23,490 --> 00:15:27,870
they just did the minimum possible thing

317
00:15:25,170 --> 00:15:29,930
so to basically fix the symptoms of the

318
00:15:27,870 --> 00:15:32,490
pock so once I realized that they

319
00:15:29,930 --> 00:15:35,069
actually aren't as diligent as I thought

320
00:15:32,490 --> 00:15:36,990
they would be I went back and started

321
00:15:35,070 --> 00:15:39,440
looking this code more closely

322
00:15:36,990 --> 00:15:46,410
and so the thing that I noticed then was

323
00:15:39,440 --> 00:15:48,960
this line here so here they're grabbing

324
00:15:46,410 --> 00:15:51,150
something again out of the TCP header

325
00:15:48,960 --> 00:15:53,460
and then they're subtracting a number

326
00:15:51,150 --> 00:15:55,920
from it without checking that this isn't

327
00:15:53,460 --> 00:15:58,080
going to overflow and then what happens

328
00:15:55,920 --> 00:16:02,339
is that that number gets copied into a

329
00:15:58,080 --> 00:16:03,840
ridged TCP OPLAN and gets plugged into

330
00:16:02,340 --> 00:16:10,050
this let me just make this a little

331
00:16:03,840 --> 00:16:11,880
smaller they call em buff copy data and

332
00:16:10,050 --> 00:16:15,089
they pass this thing in and at this

333
00:16:11,880 --> 00:16:18,000
point where that parameter gets passed

334
00:16:15,090 --> 00:16:20,880
in it gets cast to a size T so if it is

335
00:16:18,000 --> 00:16:27,240
a negative number then it wraps and

336
00:16:20,880 --> 00:16:28,650
becomes an enormous size T so this was

337
00:16:27,240 --> 00:16:31,290
the point at which I started to learn

338
00:16:28,650 --> 00:16:33,900
kind of more interesting stuff about

339
00:16:31,290 --> 00:16:36,510
what to look for in in xnu because I

340
00:16:33,900 --> 00:16:42,030
looked at this function and starts to

341
00:16:36,510 --> 00:16:45,120
figure out what it is okay so first of

342
00:16:42,030 --> 00:16:50,790
all this is the the struct that defines

343
00:16:45,120 --> 00:16:53,760
the TCP header that's the that's the

344
00:16:50,790 --> 00:16:57,240
field that we were just looking at what

345
00:16:53,760 --> 00:17:01,080
the purpose of this field is to tell you

346
00:16:57,240 --> 00:17:04,319
how how big the the options section is

347
00:17:01,080 --> 00:17:05,970
so if you have no options then the value

348
00:17:04,319 --> 00:17:07,829
of this should be five because what they

349
00:17:05,970 --> 00:17:10,410
do is it's the number of words of the

350
00:17:07,829 --> 00:17:12,750
header so if it's five then that gets

351
00:17:10,410 --> 00:17:16,740
multiplied by four to give you 20 which

352
00:17:12,750 --> 00:17:18,869
is the basic size of a TCP header and

353
00:17:16,740 --> 00:17:20,880
because it's a four bit number you can

354
00:17:18,869 --> 00:17:24,530
go up to 15 so the maximum that it can

355
00:17:20,880 --> 00:17:29,010
be is 60 bytes so you can have at most

356
00:17:24,530 --> 00:17:32,670
40 bytes worth of options in the in the

357
00:17:29,010 --> 00:17:34,140
TCP header but anything less than 5 is

358
00:17:32,670 --> 00:17:35,640
an illegal value and you're supposed to

359
00:17:34,140 --> 00:17:37,980
check that if you're if you're working

360
00:17:35,640 --> 00:17:39,570
with raw TCP headers then you're

361
00:17:37,980 --> 00:17:41,700
supposed to check that this number is is

362
00:17:39,570 --> 00:17:44,610
less than 5 and they didn't do that

363
00:17:41,700 --> 00:17:46,830
which is why they have this have this

364
00:17:44,610 --> 00:17:52,840
bug

365
00:17:46,830 --> 00:17:55,540
so so the next next topic is what's an

366
00:17:52,840 --> 00:17:57,399
n/bar because you saw in in in the code

367
00:17:55,540 --> 00:18:01,560
that they're doing stuff to do with em

368
00:17:57,400 --> 00:18:05,460
buffs so what's an em buff well this

369
00:18:01,560 --> 00:18:08,649
this is the type of a debuff which is I

370
00:18:05,460 --> 00:18:10,120
think not very helpful to look at is

371
00:18:08,650 --> 00:18:11,590
basically just a bunch of structs and

372
00:18:10,120 --> 00:18:14,139
unions it's really impossible to tell

373
00:18:11,590 --> 00:18:16,480
what this thing does in fact I think

374
00:18:14,140 --> 00:18:18,640
they might as well just implemented it

375
00:18:16,480 --> 00:18:21,730
like this because there's so little

376
00:18:18,640 --> 00:18:25,150
types a type safety there so it's more

377
00:18:21,730 --> 00:18:27,640
instructive to look at the look at the

378
00:18:25,150 --> 00:18:29,320
code that operates on em buffs so this

379
00:18:27,640 --> 00:18:33,160
is the function that it was calling

380
00:18:29,320 --> 00:18:37,629
earlier the EM buff copy data and so

381
00:18:33,160 --> 00:18:39,250
this this Len value is the is is the

382
00:18:37,630 --> 00:18:42,340
thing that we can make really huge in

383
00:18:39,250 --> 00:18:44,230
the in the packet Mangler and so what

384
00:18:42,340 --> 00:18:47,139
becomes now clear now as you look at

385
00:18:44,230 --> 00:18:50,800
this code is that M buff is a simply

386
00:18:47,140 --> 00:18:53,080
linked data structure a linked list data

387
00:18:50,800 --> 00:18:56,139
structure because this this first loop

388
00:18:53,080 --> 00:18:58,090
here what that's doing is its scanning

389
00:18:56,140 --> 00:19:00,610
through the linked list until it gets to

390
00:18:58,090 --> 00:19:04,360
the offset because we what we're saying

391
00:19:00,610 --> 00:19:08,350
here is I want to copy this amount of

392
00:19:04,360 --> 00:19:10,689
data from this offset into this buffer

393
00:19:08,350 --> 00:19:12,070
so first we need to scan forward through

394
00:19:10,690 --> 00:19:15,550
the linked list until we've got to the

395
00:19:12,070 --> 00:19:17,639
correct offset and then in the second

396
00:19:15,550 --> 00:19:22,600
loop that's when you can start copying

397
00:19:17,640 --> 00:19:23,710
and so one of the things that was

398
00:19:22,600 --> 00:19:29,770
interesting about this from the

399
00:19:23,710 --> 00:19:32,470
perspective of writing a writing an

400
00:19:29,770 --> 00:19:35,770
exploit for it is that even though I've

401
00:19:32,470 --> 00:19:40,900
made this size this length absolutely

402
00:19:35,770 --> 00:19:44,560
huge this loop will stop as soon as it

403
00:19:40,900 --> 00:19:47,320
gets to the end of the end of the linked

404
00:19:44,560 --> 00:19:50,399
list so you can actually control the

405
00:19:47,320 --> 00:19:55,389
amount of data that's going to get

406
00:19:50,400 --> 00:19:57,430
written in your buffer overflow by by

407
00:19:55,390 --> 00:19:59,810
the size of the the amount of data that

408
00:19:57,430 --> 00:20:05,150
you send it's not going to attempt to

409
00:19:59,810 --> 00:20:06,320
at 64 sighs team max amount of data is

410
00:20:05,150 --> 00:20:08,930
just going to go until it gets to the

411
00:20:06,320 --> 00:20:10,399
end of this linked list and so that

412
00:20:08,930 --> 00:20:16,850
gives you it gives you a lot of control

413
00:20:10,400 --> 00:20:20,840
over what you what you can do that okay

414
00:20:16,850 --> 00:20:23,209
so so yes so in in the code there so

415
00:20:20,840 --> 00:20:27,860
that the buff that the the place that

416
00:20:23,210 --> 00:20:30,170
we're writing into is a stack buffer and

417
00:20:27,860 --> 00:20:32,260
so in fact this is this is a stack

418
00:20:30,170 --> 00:20:35,000
buffer overflow where you can send a

419
00:20:32,260 --> 00:20:37,160
network packet to the Mac and it will

420
00:20:35,000 --> 00:20:40,460
write that data directly onto the stack

421
00:20:37,160 --> 00:20:43,910
I did not I mean

422
00:20:40,460 --> 00:20:47,330
so Apple accredited we move with for

423
00:20:43,910 --> 00:20:49,610
finding an RC for this I didn't ever

424
00:20:47,330 --> 00:20:56,360
build an RC I'm not skilled enough to do

425
00:20:49,610 --> 00:20:58,879
that kind of kernel sort of hacking so I

426
00:20:56,360 --> 00:21:03,080
just send them the crash and and that's

427
00:20:58,880 --> 00:21:05,990
all I did but yeah they credited as an

428
00:21:03,080 --> 00:21:07,730
RC e because because this is the this is

429
00:21:05,990 --> 00:21:12,170
the thing that you can you can overwrite

430
00:21:07,730 --> 00:21:12,830
an S on the stack okay so what happened

431
00:21:12,170 --> 00:21:16,880
next

432
00:21:12,830 --> 00:21:19,220
so I didn't notice this until again more

433
00:21:16,880 --> 00:21:22,640
than half a year later the reason for

434
00:21:19,220 --> 00:21:25,810
this is that they Apple are very slow to

435
00:21:22,640 --> 00:21:27,800
publish their source code so that

436
00:21:25,810 --> 00:21:29,419
version of the source code that I was

437
00:21:27,800 --> 00:21:31,520
showing you ten point thirteen point

438
00:21:29,420 --> 00:21:36,290
three that was the only thing that was

439
00:21:31,520 --> 00:21:38,629
available until October of 2018 and so

440
00:21:36,290 --> 00:21:40,040
when it finally came out when the when

441
00:21:38,630 --> 00:21:41,180
the updated source code was finally

442
00:21:40,040 --> 00:21:44,389
published they went to see what they'd

443
00:21:41,180 --> 00:21:46,520
done and it turned out that they'd not

444
00:21:44,390 --> 00:21:53,120
fixed one of the infinite loop bugs so

445
00:21:46,520 --> 00:21:54,830
what they what they had fixed was they

446
00:21:53,120 --> 00:21:58,250
had fixed this one because that was the

447
00:21:54,830 --> 00:22:00,139
POC that I sent them but you could get

448
00:21:58,250 --> 00:22:02,660
exactly the same effect by making this

449
00:22:00,140 --> 00:22:05,000
value zero and so I was again able to

450
00:22:02,660 --> 00:22:08,159
get an infinite loop and another CD of

451
00:22:05,000 --> 00:22:16,539
them okay

452
00:22:08,159 --> 00:22:18,879
so on to the on to the second bug so

453
00:22:16,539 --> 00:22:21,669
this time there was this time it was in

454
00:22:18,879 --> 00:22:23,559
the NFS client just to take you through

455
00:22:21,669 --> 00:22:27,250
the the cartoon again

456
00:22:23,559 --> 00:22:30,190
so that's Eve 999 and we've got a new

457
00:22:27,250 --> 00:22:33,879
villain here this is evil pixel blob who

458
00:22:30,190 --> 00:22:35,320
is a living cube of energy and what's

459
00:22:33,879 --> 00:22:37,059
happening here is that there's this kind

460
00:22:35,320 --> 00:22:42,450
of filing cabinet like thing called keV

461
00:22:37,059 --> 00:22:44,769
FS and Eve nine nine nine nine unwisely

462
00:22:42,450 --> 00:22:48,909
wonders what the huge handle on the side

463
00:22:44,769 --> 00:22:51,730
of it is and decides to try moving the

464
00:22:48,909 --> 00:22:52,360
handle evil pixel blob makes a hasty

465
00:22:51,730 --> 00:22:54,220
exit

466
00:22:52,360 --> 00:22:56,439
he was just finished hooking up the

467
00:22:54,220 --> 00:23:01,480
machine and of course it explodes in EVE

468
00:22:56,440 --> 00:23:04,500
nine nine 9's face again okay let me

469
00:23:01,480 --> 00:23:10,500
just show you what this looks like

470
00:23:04,500 --> 00:23:15,970
so this time I'm let me just pause that

471
00:23:10,500 --> 00:23:18,429
so I'm logged into the Mac I'm on the

472
00:23:15,970 --> 00:23:21,220
guest account just to just to kind of

473
00:23:18,429 --> 00:23:24,340
demonstrate that this doesn't require

474
00:23:21,220 --> 00:23:27,070
any elevated privileges something that's

475
00:23:24,340 --> 00:23:31,418
interesting on Mac OS is that you can as

476
00:23:27,070 --> 00:23:34,450
an ordinary user you can mount NFS or

477
00:23:31,419 --> 00:23:36,909
other stuff in as long as it's into a

478
00:23:34,450 --> 00:23:38,559
directory that you own so if it's into

479
00:23:36,909 --> 00:23:40,210
your home directory you're allowed to

480
00:23:38,559 --> 00:23:42,129
mount stuff on my Linux machine I'm not

481
00:23:40,210 --> 00:23:46,769
allowed to do this I have to be root to

482
00:23:42,129 --> 00:23:49,178
mount NFS drives but this was

483
00:23:46,769 --> 00:23:51,549
permissible I think it still is in the

484
00:23:49,179 --> 00:23:58,539
guest account and so that meant that I

485
00:23:51,549 --> 00:24:01,899
was able to mount the Kev FS NFS driver

486
00:23:58,539 --> 00:24:09,789
NFS drive that I'd created and then this

487
00:24:01,899 --> 00:24:14,279
is what happens so I mount the evil

488
00:24:09,789 --> 00:24:14,279
drive and it it reboots the machine

489
00:24:15,450 --> 00:24:24,160
okay so um so although the packet

490
00:24:22,540 --> 00:24:28,510
mangled bug wasn't very exciting in

491
00:24:24,160 --> 00:24:31,300
itself it it did kind of help me along

492
00:24:28,510 --> 00:24:33,550
so what I realized was that there's a

493
00:24:31,300 --> 00:24:38,290
bunch of these these functions in xnu

494
00:24:33,550 --> 00:24:40,600
there are X nu specific things that are

495
00:24:38,290 --> 00:24:42,730
a lot like mem copies I mean so if you

496
00:24:40,600 --> 00:24:44,500
were looking for bugs in a regular

497
00:24:42,730 --> 00:24:48,460
application then you're probably looking

498
00:24:44,500 --> 00:24:50,710
for mem copies where the size of the the

499
00:24:48,460 --> 00:24:54,640
data that's being copied is too big and

500
00:24:50,710 --> 00:24:56,170
a new go a buffer overflow but that

501
00:24:54,640 --> 00:24:57,880
doesn't work on X nu because they're not

502
00:24:56,170 --> 00:24:59,380
using mem copy they're using other stuff

503
00:24:57,880 --> 00:25:02,170
so they've got this m buff copy data

504
00:24:59,380 --> 00:25:04,720
which is potentially pretty dangerous

505
00:25:02,170 --> 00:25:11,160
because it's working on n buffs and M

506
00:25:04,720 --> 00:25:13,450
buffs are used for holding Network data

507
00:25:11,160 --> 00:25:15,700
and so that's potentially pretty

508
00:25:13,450 --> 00:25:19,660
dangerous they also often use B copy

509
00:25:15,700 --> 00:25:22,780
rather than rather than Papa for doing

510
00:25:19,660 --> 00:25:27,610
mam copies and then these two functions

511
00:25:22,780 --> 00:25:30,700
M both data and M em Tod what they do is

512
00:25:27,610 --> 00:25:33,820
they grab the raw data pointer out of

513
00:25:30,700 --> 00:25:35,830
the m bar so the M buff contains a bunch

514
00:25:33,820 --> 00:25:37,540
of bytes that come in over the network

515
00:25:35,830 --> 00:25:40,990
and you can use these two functions to

516
00:25:37,540 --> 00:25:44,320
actually just grab a pointer to that to

517
00:25:40,990 --> 00:25:46,690
that buffer and start reading it so so

518
00:25:44,320 --> 00:25:48,939
now that I knew about these functions I

519
00:25:46,690 --> 00:25:51,250
could start writing data flow queries to

520
00:25:48,940 --> 00:26:00,930
look for places where they might be used

521
00:25:51,250 --> 00:26:04,000
in in a dangerous way so this query here

522
00:26:00,930 --> 00:26:07,630
what I was looking for here was places

523
00:26:04,000 --> 00:26:09,280
where the sink is a B copy so B copy is

524
00:26:07,630 --> 00:26:12,670
just a macro that expands to this

525
00:26:09,280 --> 00:26:16,480
built-in memmove thing and the source is

526
00:26:12,670 --> 00:26:18,370
a place where we've grabbed a data

527
00:26:16,480 --> 00:26:23,440
pointer from an M bar so that's

528
00:26:18,370 --> 00:26:27,219
potentially tainted tainted data that we

529
00:26:23,440 --> 00:26:28,570
we've we've got there and that looks

530
00:26:27,220 --> 00:26:33,539
like it might be flowing

531
00:26:28,570 --> 00:26:38,980
into the the sighs argument of a B copy

532
00:26:33,539 --> 00:26:44,799
so if we run that let me just grab up

533
00:26:38,980 --> 00:26:47,139
grab the result immediately so there's

534
00:26:44,799 --> 00:26:50,440
actually you can see there's 23 results

535
00:26:47,139 --> 00:26:53,289
and I got multiple CVS for this because

536
00:26:50,440 --> 00:26:56,200
they made the mistake in the same

537
00:26:53,289 --> 00:27:01,559
mistake in multiple places but this is

538
00:26:56,200 --> 00:27:01,559
the this is the query result that we get

539
00:27:02,190 --> 00:27:06,789
that line there this this the reason I'm

540
00:27:05,289 --> 00:27:08,500
showing you this one is this this is the

541
00:27:06,789 --> 00:27:10,299
one that was the easiest no I'm showing

542
00:27:08,500 --> 00:27:12,210
you the wrong one this one four one five

543
00:27:10,299 --> 00:27:14,230
one this was the easiest ones trigger

544
00:27:12,210 --> 00:27:18,909
the reason it's the easiest one to

545
00:27:14,230 --> 00:27:22,330
trigger is because it's in NFS three

546
00:27:18,909 --> 00:27:24,009
mount so this happens right at the like

547
00:27:22,330 --> 00:27:28,600
the first stages of mounting and

548
00:27:24,009 --> 00:27:32,259
mounting a drive is when when when this

549
00:27:28,600 --> 00:27:37,539
stuff happens so it doesn't require a

550
00:27:32,259 --> 00:27:40,690
lot of implementation to to do this some

551
00:27:37,539 --> 00:27:47,408
of the other bugs were in nfsv4 so Mac

552
00:27:40,690 --> 00:27:50,919
OS can do nfsv4 as a client it cannot do

553
00:27:47,409 --> 00:27:54,279
nfsv4 as a as a server but the the

554
00:27:50,919 --> 00:27:57,240
client code for the the nfsv4 had a lot

555
00:27:54,279 --> 00:28:03,250
the same vulnerabilities as well what I

556
00:27:57,240 --> 00:28:05,980
discovered is that kind of writing a

557
00:28:03,250 --> 00:28:08,289
fake nfsv4 server is a lot more

558
00:28:05,980 --> 00:28:18,009
complicated than writing NFS 3v3

559
00:28:08,289 --> 00:28:21,789
server this cable is coming ok I hope it

560
00:28:18,009 --> 00:28:24,100
stops flickering for you ok

561
00:28:21,789 --> 00:28:26,379
so now looking at this line of code it's

562
00:28:24,100 --> 00:28:33,158
not at all obvious that there's a bug

563
00:28:26,379 --> 00:28:35,549
here this thing is a is a macro just

564
00:28:33,159 --> 00:28:35,549
show you this

565
00:29:06,729 --> 00:29:14,269
here this file

566
00:29:10,070 --> 00:29:19,279
NFS mm sobs dot hate has got some epic

567
00:29:14,269 --> 00:29:23,779
macro macro programming in it and so

568
00:29:19,279 --> 00:29:24,979
this is the definition of get FH and let

569
00:29:23,779 --> 00:29:29,809
me actually just go back to my slides

570
00:29:24,979 --> 00:29:34,369
because I've got this on a slide so

571
00:29:29,809 --> 00:29:40,369
there's a bunch of macros this is the

572
00:29:34,369 --> 00:29:43,609
get F age and what you see here is that

573
00:29:40,369 --> 00:29:47,029
it's reading a 32-bit value into FH Len

574
00:29:43,609 --> 00:29:49,789
and then passing that 32-bit value into

575
00:29:47,029 --> 00:29:51,499
this get opaque thing and there's no

576
00:29:49,789 --> 00:29:55,549
bounds check here at all

577
00:29:51,499 --> 00:30:01,299
so FHN ffh Len what that's supposed to

578
00:29:55,549 --> 00:30:04,039
be is a file handle length and on NFS v3

579
00:30:01,299 --> 00:30:11,049
the length of the file handle should be

580
00:30:04,039 --> 00:30:16,039
at most 64 bits bytes 4 bytes and on

581
00:30:11,049 --> 00:30:17,658
nfsv4 I think is 128 bytes maximum they

582
00:30:16,039 --> 00:30:19,789
didn't bother to check that but of

583
00:30:17,659 --> 00:30:24,049
course because it's been obscured in so

584
00:30:19,789 --> 00:30:26,599
many macros it's kind of not obvious

585
00:30:24,049 --> 00:30:28,339
that that that happened but once I

586
00:30:26,599 --> 00:30:30,139
started to scrutinize this I realized

587
00:30:28,339 --> 00:30:32,869
that yeah my query is right this this

588
00:30:30,139 --> 00:30:35,809
really is kind of dangerous so on the

589
00:30:32,869 --> 00:30:37,519
next slide I've got get opaque and so

590
00:30:35,809 --> 00:30:41,629
you see that what get opaque does is it

591
00:30:37,519 --> 00:30:46,249
takes that Len and it stops it directly

592
00:30:41,629 --> 00:30:47,899
into a be copy they also I mean yet

593
00:30:46,249 --> 00:30:49,100
another macro here I don't have it my

594
00:30:47,899 --> 00:30:52,489
slides but

595
00:30:49,100 --> 00:30:55,428
the classic rounding up code you know

596
00:30:52,490 --> 00:30:58,520
where you kind of add seven and then

597
00:30:55,429 --> 00:31:00,350
mauled by or do modulus by eight in

598
00:30:58,520 --> 00:31:02,780
order to round the number up to the next

599
00:31:00,350 --> 00:31:04,428
multiple of eight and so of course you

600
00:31:02,780 --> 00:31:06,080
can you can overflow that make it

601
00:31:04,429 --> 00:31:07,419
wraparound to zero so that there was

602
00:31:06,080 --> 00:31:13,370
that there was there was another bug

603
00:31:07,419 --> 00:31:16,070
right here in that macro so yes so so

604
00:31:13,370 --> 00:31:20,600
what this meant was that you can write

605
00:31:16,070 --> 00:31:23,510
an NFS server and when the Mac connects

606
00:31:20,600 --> 00:31:25,539
the NFS server the NFS server is

607
00:31:23,510 --> 00:31:28,100
supposed to send back a file handle and

608
00:31:25,539 --> 00:31:31,970
you just send back a really big file

609
00:31:28,100 --> 00:31:35,270
handle and that file handle will get

610
00:31:31,970 --> 00:31:38,720
just be copied directly into the kernel

611
00:31:35,270 --> 00:31:41,360
memory so essentially as many bytes as

612
00:31:38,720 --> 00:31:45,130
you as you like is it sort of unlimited

613
00:31:41,360 --> 00:31:57,530
what you could copy into the kernel that

614
00:31:45,130 --> 00:32:00,500
goes into f-h I think there were there

615
00:31:57,530 --> 00:32:05,389
were multiple bugs in in some cases f8

616
00:32:00,500 --> 00:32:09,200
was a stack pointer and in some cases F

617
00:32:05,390 --> 00:32:10,850
H was a was it was a heap pointer so he

618
00:32:09,200 --> 00:32:13,280
kind of had a choice of whether whether

619
00:32:10,850 --> 00:32:18,549
or not you wanted to overthrow the stack

620
00:32:13,280 --> 00:32:21,649
or if he wants to overflow the heap okay

621
00:32:18,549 --> 00:32:24,110
so how do you implement a fake NFS

622
00:32:21,650 --> 00:32:27,799
server so this seemed like a really

623
00:32:24,110 --> 00:32:29,750
daunting task when I first was going to

624
00:32:27,799 --> 00:32:34,429
write a POC for this it turns out that

625
00:32:29,750 --> 00:32:37,220
it's actually amazingly easy so NFS uses

626
00:32:34,429 --> 00:32:40,760
something called RPC and there's this

627
00:32:37,220 --> 00:32:48,110
tool called RPC gen which helps you to

628
00:32:40,760 --> 00:32:51,350
build RPC applications so the idea is

629
00:32:48,110 --> 00:32:54,879
that you don't the the the NFS server

630
00:32:51,350 --> 00:32:59,570
doesn't need to open its own port

631
00:32:54,880 --> 00:33:02,429
instead it there's this kind of sort of

632
00:32:59,570 --> 00:33:05,549
generic end port entry point run by

633
00:33:02,429 --> 00:33:07,879
PC that things connect to and then the

634
00:33:05,549 --> 00:33:10,379
RPC server sort of delegates the

635
00:33:07,879 --> 00:33:12,029
delegates to the work to the the code

636
00:33:10,379 --> 00:33:13,769
that you've you've written so it kind of

637
00:33:12,029 --> 00:33:15,960
provides the framework that does the

638
00:33:13,769 --> 00:33:18,720
network communication all you need to do

639
00:33:15,960 --> 00:33:22,230
is write an application that the

640
00:33:18,720 --> 00:33:26,220
implements the implements the logic

641
00:33:22,230 --> 00:33:28,379
that's going to happen and so because

642
00:33:26,220 --> 00:33:31,320
the bug happens during the mounting

643
00:33:28,379 --> 00:33:34,889
operations I I didn't need to write very

644
00:33:31,320 --> 00:33:36,629
many of the RPC methods at all I only

645
00:33:34,889 --> 00:33:39,809
needed to be able to handle the first

646
00:33:36,629 --> 00:33:42,389
couple of steps of the of the NFS

647
00:33:39,809 --> 00:33:44,850
protocol in order to trigger the bug so

648
00:33:42,389 --> 00:33:48,240
it ended up just being 63 lines of RPC

649
00:33:44,850 --> 00:33:49,740
language and only 46 lines of C so it

650
00:33:48,240 --> 00:33:55,350
was actually in the end remarkably easy

651
00:33:49,740 --> 00:34:00,869
to do I did a later stage also look into

652
00:33:55,350 --> 00:34:02,248
trying to write an nfsv4 server that

653
00:34:00,869 --> 00:34:03,658
turned out to be quite a lot more

654
00:34:02,249 --> 00:34:09,329
complicated and what I ended up doing

655
00:34:03,659 --> 00:34:10,950
was instead I'm still using RPC gen but

656
00:34:09,329 --> 00:34:12,480
what I instead did was made a kind of

657
00:34:10,949 --> 00:34:16,439
man in the middle so I had a like a

658
00:34:12,480 --> 00:34:18,389
genuine NFS server running kind of

659
00:34:16,440 --> 00:34:19,829
sending back all the correct commands

660
00:34:18,389 --> 00:34:21,899
most of which I would just pass on

661
00:34:19,829 --> 00:34:23,970
directly and then I could just intercept

662
00:34:21,899 --> 00:34:28,049
the ones that I wanted to mess with and

663
00:34:23,969 --> 00:34:31,678
and send that back to the Mac so that

664
00:34:28,049 --> 00:34:34,579
that code for the nfsv4 is not published

665
00:34:31,679 --> 00:34:37,049
because I didn't end up finding any

666
00:34:34,579 --> 00:34:38,429
didn't end up actually triggering any

667
00:34:37,049 --> 00:34:40,469
exploits with it but if you're

668
00:34:38,429 --> 00:34:42,480
interested in that then do please get in

669
00:34:40,469 --> 00:34:47,969
touch with me and I can I can can show

670
00:34:42,480 --> 00:34:51,690
you that stuff okay so yes so this is

671
00:34:47,969 --> 00:34:54,808
kind of the the main the kind of the the

672
00:34:51,690 --> 00:34:58,559
most important parts of that RPC file

673
00:34:54,809 --> 00:35:01,220
that I wrote and so this is the this is

674
00:34:58,559 --> 00:35:06,000
the key one here so this is the mount

675
00:35:01,220 --> 00:35:07,890
method it gets say a directory path and

676
00:35:06,000 --> 00:35:13,770
an it's supposed to send back a file

677
00:35:07,890 --> 00:35:15,830
handle for that path and normally this

678
00:35:13,770 --> 00:35:19,610
file handle would be

679
00:35:15,830 --> 00:35:22,580
it would be defined as a 64 byte array

680
00:35:19,610 --> 00:35:25,340
and all I did was I changed it so it was

681
00:35:22,580 --> 00:35:28,279
an unlimited size array and so then I

682
00:35:25,340 --> 00:35:31,340
could send back more bytes and trigger

683
00:35:28,280 --> 00:35:36,350
the bug so what happens when you run RPC

684
00:35:31,340 --> 00:35:37,850
Jen on this is it generates some of the

685
00:35:36,350 --> 00:35:40,069
implementation for you and it also

686
00:35:37,850 --> 00:35:42,680
generates some header files and you just

687
00:35:40,070 --> 00:35:45,020
have to fill in there the content of the

688
00:35:42,680 --> 00:35:47,629
of the functions and so this is the main

689
00:35:45,020 --> 00:35:49,640
function that I had to implement so they

690
00:35:47,630 --> 00:35:53,870
they'd given me this this signature here

691
00:35:49,640 --> 00:35:57,890
that I had to implement and the the key

692
00:35:53,870 --> 00:36:02,230
step here really is is is this is saying

693
00:35:57,890 --> 00:36:05,440
that the size is rx 1000 and then

694
00:36:02,230 --> 00:36:11,150
plugging that in and and returning it

695
00:36:05,440 --> 00:36:14,710
and that triggered the bug okay so

696
00:36:11,150 --> 00:36:20,330
moving on to the the third and final bug

697
00:36:14,710 --> 00:36:23,720
so we've got Eve 999 here again this

698
00:36:20,330 --> 00:36:26,270
villain here is is called mr. litter and

699
00:36:23,720 --> 00:36:28,879
so what's happening here is he's sending

700
00:36:26,270 --> 00:36:31,340
another evil packet to Eve 999 but this

701
00:36:28,880 --> 00:36:32,900
time even though nines wise to it and he

702
00:36:31,340 --> 00:36:36,770
says ha they're not doing this again

703
00:36:32,900 --> 00:36:40,370
send it back so he boxes it back up in

704
00:36:36,770 --> 00:36:42,860
an icon box and is going to send it back

705
00:36:40,370 --> 00:36:46,640
to mr. litter but then it explodes in

706
00:36:42,860 --> 00:36:55,280
his face yes again so let me show you

707
00:36:46,640 --> 00:36:58,609
the video so it's kind of like the

708
00:36:55,280 --> 00:37:04,070
packet Mangler sending packets over

709
00:36:58,610 --> 00:37:06,320
Wi-Fi but this time there's there is no

710
00:37:04,070 --> 00:37:07,940
kind of special configuration needed so

711
00:37:06,320 --> 00:37:11,210
whereas with the packet Mangler I had to

712
00:37:07,940 --> 00:37:13,340
go and do an admin command to switch on

713
00:37:11,210 --> 00:37:17,470
the packet Mangala this didn't require

714
00:37:13,340 --> 00:37:20,210
it just works on vanilla mac OS and iOS

715
00:37:17,470 --> 00:37:25,040
all you needed to do was be on the same

716
00:37:20,210 --> 00:37:27,080
Wi-Fi network and if I remember I'll

717
00:37:25,040 --> 00:37:28,580
explain why that is

718
00:37:27,080 --> 00:37:31,299
later why you have to be on the same

719
00:37:28,580 --> 00:37:31,299
Wi-Fi network

720
00:37:33,510 --> 00:37:37,780
okay so it's essentially the same thing

721
00:37:36,310 --> 00:37:40,000
that I was doing is before I was just

722
00:37:37,780 --> 00:37:42,370
using a different combinations of

723
00:37:40,000 --> 00:37:45,790
sources and sinks for the data flow so

724
00:37:42,370 --> 00:37:47,950
this time the source is this n M Tod

725
00:37:45,790 --> 00:37:51,330
thing which is the function that grabs

726
00:37:47,950 --> 00:37:55,569
the data pointer out of the em both

727
00:37:51,330 --> 00:37:58,509
packet and the sink is M copy data

728
00:37:55,570 --> 00:38:00,820
they've got a bit code duplication in

729
00:37:58,510 --> 00:38:02,530
the in the kernel so they've got like M

730
00:38:00,820 --> 00:38:04,720
underscore copy data they've got M buff

731
00:38:02,530 --> 00:38:10,690
on disk odd copy data so that's why you

732
00:38:04,720 --> 00:38:16,779
need to look for both so let me just run

733
00:38:10,690 --> 00:38:20,200
this one here so this is the query so

734
00:38:16,780 --> 00:38:26,950
you can see their source is mm Tod and

735
00:38:20,200 --> 00:38:33,850
sync is copy data running that let me

736
00:38:26,950 --> 00:38:36,490
just pull up the pull up immediately so

737
00:38:33,850 --> 00:38:42,040
a few results not all of them turned out

738
00:38:36,490 --> 00:38:44,979
to be interesting but this one so if I

739
00:38:42,040 --> 00:38:52,509
just show you the path here so it thinks

740
00:38:44,980 --> 00:38:54,400
that the data comes from there so this

741
00:38:52,510 --> 00:38:57,280
is all within a function called I comp

742
00:38:54,400 --> 00:39:01,320
error and so you see it's got this

743
00:38:57,280 --> 00:39:06,520
argument here which is named both and

744
00:39:01,320 --> 00:39:10,330
then it it reads some stuff out of that

745
00:39:06,520 --> 00:39:13,150
M buff and then it does a bit of a riff

746
00:39:10,330 --> 00:39:15,819
and take on it does a min operation on

747
00:39:13,150 --> 00:39:22,360
it and then it sticks it into M copy

748
00:39:15,820 --> 00:39:23,860
data so when I saw this I was a little

749
00:39:22,360 --> 00:39:26,040
bit unsure as to whether or not this is

750
00:39:23,860 --> 00:39:29,950
a real vulnerability it's kind of

751
00:39:26,040 --> 00:39:33,630
because it's all just in this this one

752
00:39:29,950 --> 00:39:33,629
function it's a little bit unclear

753
00:39:34,239 --> 00:39:37,700
and there's also a little bit of

754
00:39:35,960 --> 00:39:39,559
disbelief on my part it's like this car

755
00:39:37,700 --> 00:39:47,029
can't be real and surely somebody must

756
00:39:39,559 --> 00:39:48,979
have seen this before so one of the

757
00:39:47,029 --> 00:39:51,589
things that I forgot to mention earlier

758
00:39:48,979 --> 00:39:59,749
is M buffs I used both incoming and

759
00:39:51,589 --> 00:40:02,450
outgoing Network messages so it's a

760
00:39:59,749 --> 00:40:04,549
little bit unclear whether I mean this

761
00:40:02,450 --> 00:40:06,288
one could be one that we're sending it

762
00:40:04,549 --> 00:40:07,309
might be completely trusted because it

763
00:40:06,289 --> 00:40:08,690
might be something that we're sending

764
00:40:07,309 --> 00:40:13,579
rather than something that we're

765
00:40:08,690 --> 00:40:15,680
receiving so I had to do a bit of

766
00:40:13,579 --> 00:40:21,589
Investigation to figure out well what is

767
00:40:15,680 --> 00:40:24,729
this icon error thing and is it possible

768
00:40:21,589 --> 00:40:24,729
for me to trigger it remotely

769
00:40:25,059 --> 00:40:36,229
so what I started out with was this

770
00:40:31,789 --> 00:40:38,450
query where I basically just said okay I

771
00:40:36,229 --> 00:40:42,200
want the sync of the data flow so the

772
00:40:38,450 --> 00:40:46,819
thing that it flows to to be parameter

773
00:40:42,200 --> 00:40:49,129
zero of the icon error because I want to

774
00:40:46,819 --> 00:40:52,430
know what what this parameter is where

775
00:40:49,130 --> 00:40:55,670
does it come from and as the sources I'm

776
00:40:52,430 --> 00:40:58,098
just going to say anything I I don't

777
00:40:55,670 --> 00:41:02,779
know I'm just going to kind of look

778
00:40:58,099 --> 00:41:08,509
through them see what where might this

779
00:41:02,779 --> 00:41:10,059
come from and so one of the things that

780
00:41:08,509 --> 00:41:12,109
you then see when you look at these

781
00:41:10,059 --> 00:41:15,019
results is that some of them actually do

782
00:41:12,109 --> 00:41:16,308
come from a function called IP info that

783
00:41:15,019 --> 00:41:21,098
sounds interesting because that means

784
00:41:16,309 --> 00:41:24,799
it's coming from input not not Alper so

785
00:41:21,099 --> 00:41:27,440
so why did then was I said well let's

786
00:41:24,799 --> 00:41:29,359
restrict the sources so that we only

787
00:41:27,440 --> 00:41:31,009
look at sources that are in the function

788
00:41:29,359 --> 00:41:36,799
called IP input because they're likely

789
00:41:31,009 --> 00:41:40,849
to be the most interesting ones so if we

790
00:41:36,799 --> 00:41:43,299
run that and we get smaller number of

791
00:41:40,849 --> 00:41:43,299
results

792
00:41:45,600 --> 00:41:50,130
I'm sorry about the screen flickering

793
00:41:48,130 --> 00:41:54,550
like this I guess it's because of the

794
00:41:50,130 --> 00:41:56,740
connection here okay so we got eight

795
00:41:54,550 --> 00:41:59,590
results so one of the things I noticed

796
00:41:56,740 --> 00:42:03,640
looking at these ones was the if you

797
00:41:59,590 --> 00:42:05,410
look at the paths some of them that one

798
00:42:03,640 --> 00:42:09,069
looks like one of the real ones and you

799
00:42:05,410 --> 00:42:10,089
see if I've got another yeah so a lot of

800
00:42:09,070 --> 00:42:13,360
them ended up going through this

801
00:42:10,090 --> 00:42:16,270
function called IP forward not totally

802
00:42:13,360 --> 00:42:18,850
sure that is but it sounded like a less

803
00:42:16,270 --> 00:42:21,009
sort of plausible attack vector to me

804
00:42:18,850 --> 00:42:24,490
going through IP forward so I decided to

805
00:42:21,010 --> 00:42:25,930
exclude those from the results so that

806
00:42:24,490 --> 00:42:29,919
was the final tweak that I made to the

807
00:42:25,930 --> 00:42:31,930
query I put in this barrier to say I'm

808
00:42:29,920 --> 00:42:35,020
not interested if the data flow path

809
00:42:31,930 --> 00:42:47,230
goes through IP forward then leave it

810
00:42:35,020 --> 00:42:50,020
out I'm not interested in that that's

811
00:42:47,230 --> 00:42:53,050
where a second to get the results and so

812
00:42:50,020 --> 00:42:57,070
now we're down to five results and so if

813
00:42:53,050 --> 00:43:00,540
we look at this one here so it starts

814
00:42:57,070 --> 00:43:05,950
that end pull up and pull up is a

815
00:43:00,540 --> 00:43:08,650
function you see a lot in in the in the

816
00:43:05,950 --> 00:43:12,189
kernel what's happening is that M buff

817
00:43:08,650 --> 00:43:13,390
is a is a linked list and a lot of the

818
00:43:12,190 --> 00:43:15,910
time they're writing this really

819
00:43:13,390 --> 00:43:18,129
low-level kind of parsing code to sort

820
00:43:15,910 --> 00:43:21,100
of read the bytes that are in the in the

821
00:43:18,130 --> 00:43:22,660
buffer and so in order to be able to do

822
00:43:21,100 --> 00:43:25,839
that they want the bytes to be a

823
00:43:22,660 --> 00:43:27,220
continuous array of memory which might

824
00:43:25,840 --> 00:43:28,750
not necessarily be the case because

825
00:43:27,220 --> 00:43:30,970
you've got this linked list of little

826
00:43:28,750 --> 00:43:34,120
little chunks of data and so they use

827
00:43:30,970 --> 00:43:37,180
this M pull-up thing and what that does

828
00:43:34,120 --> 00:43:39,100
is if the if the first element of the

829
00:43:37,180 --> 00:43:41,169
linked list is too small so if the size

830
00:43:39,100 --> 00:43:43,569
of that first element is less than the

831
00:43:41,170 --> 00:43:46,840
size of a struct IP then that what they

832
00:43:43,570 --> 00:43:49,600
want to do is reallocate the memory copy

833
00:43:46,840 --> 00:43:51,370
at least that number of bytes into the

834
00:43:49,600 --> 00:43:53,140
first element of the linked list so that

835
00:43:51,370 --> 00:43:55,509
they can then start reading it without

836
00:43:53,140 --> 00:43:57,580
accidentally going off the end

837
00:43:55,510 --> 00:44:00,450
so that's that's what's going on here

838
00:43:57,580 --> 00:44:04,290
and just to show you quickly we are

839
00:44:00,450 --> 00:44:08,770
somewhere in the middle of this IP input

840
00:44:04,290 --> 00:44:13,680
IP input function these functions by the

841
00:44:08,770 --> 00:44:17,550
way they're doing the networking it's

842
00:44:13,680 --> 00:44:20,980
unbelievable to me how kind of

843
00:44:17,550 --> 00:44:23,770
unstructured they seem I mean the the

844
00:44:20,980 --> 00:44:26,530
worst offender is TCP input it's over

845
00:44:23,770 --> 00:44:30,580
3,000 lines long and it's all this just

846
00:44:26,530 --> 00:44:33,010
super low-level bits and bytes type of

847
00:44:30,580 --> 00:44:34,960
stuff so updating offsets and reading

848
00:44:33,010 --> 00:44:38,710
stuff out of the out of the packet I

849
00:44:34,960 --> 00:44:41,200
mean it's so error-prone and kind of

850
00:44:38,710 --> 00:44:43,390
hurts me is I mean before getting into

851
00:44:41,200 --> 00:44:47,950
security at my entire career was working

852
00:44:43,390 --> 00:44:49,569
as a compiler engineer and so it hurts

853
00:44:47,950 --> 00:44:51,819
me when people don't trust the compiler

854
00:44:49,570 --> 00:44:53,020
to do optimizations for them they feel

855
00:44:51,820 --> 00:44:55,030
that they have to take all of these

856
00:44:53,020 --> 00:44:56,560
things that should be little separate

857
00:44:55,030 --> 00:44:58,060
functions they have to inline them

858
00:44:56,560 --> 00:45:00,520
themselves because they don't trust the

859
00:44:58,060 --> 00:45:07,000
compiler to do that for them it really

860
00:45:00,520 --> 00:45:10,060
will work sure you okay so this one it

861
00:45:07,000 --> 00:45:12,700
starts here so this is an incoming IP

862
00:45:10,060 --> 00:45:15,480
packet and then the next thing that

863
00:45:12,700 --> 00:45:21,490
happens is it goes into IP do options

864
00:45:15,480 --> 00:45:24,940
and then inside IP do options that's the

865
00:45:21,490 --> 00:45:28,180
parameter there's then a possibility

866
00:45:24,940 --> 00:45:34,150
that if it hits this bad case that it's

867
00:45:28,180 --> 00:45:36,040
going to call IP comp error and so the

868
00:45:34,150 --> 00:45:38,170
way that you can make it hit that bad

869
00:45:36,040 --> 00:45:44,740
case is actually like plenty of

870
00:45:38,170 --> 00:45:50,830
opportunities but basically all you have

871
00:45:44,740 --> 00:45:53,799
to do is stick in a bad I P option so if

872
00:45:50,830 --> 00:45:55,600
you just put an invalid IP option into

873
00:45:53,800 --> 00:46:01,740
the packet then you're going to hit this

874
00:45:55,600 --> 00:46:05,970
bad case and you go into the icon error

875
00:46:01,740 --> 00:46:10,200
code down down here and then you you end

876
00:46:05,970 --> 00:46:15,169
up in that parameter so basically to

877
00:46:10,200 --> 00:46:15,169
trigger this all you have to do is send

878
00:46:15,410 --> 00:46:22,618
send an IP packet that contains an

879
00:46:20,309 --> 00:46:25,980
invalid IP option and you're going to

880
00:46:22,619 --> 00:46:27,750
hit this code and then if you make that

881
00:46:25,980 --> 00:46:31,079
packet big enough what it's going to do

882
00:46:27,750 --> 00:46:33,119
is it's so what I now understand is the

883
00:46:31,079 --> 00:46:35,130
I comp error the idea is that if

884
00:46:33,119 --> 00:46:37,950
something goes wrong then it sends out

885
00:46:35,130 --> 00:46:39,750
an IP icon message saying something went

886
00:46:37,950 --> 00:46:42,839
wrong this is the problem and what it

887
00:46:39,750 --> 00:46:46,770
appears to be doing is copying the

888
00:46:42,839 --> 00:46:48,660
entirety of the incoming IP packet into

889
00:46:46,770 --> 00:46:53,279
the icon packet in order to send it back

890
00:46:48,660 --> 00:47:01,200
out again so if we just go back to my

891
00:46:53,279 --> 00:47:02,609
slide about the structure of the so if

892
00:47:01,200 --> 00:47:05,220
you make this thing as big as possible

893
00:47:02,609 --> 00:47:07,109
so you can make the IP options be 40

894
00:47:05,220 --> 00:47:09,930
bytes and you can make the TCP options

895
00:47:07,109 --> 00:47:12,598
be 40 bytes so then you've got 120 bytes

896
00:47:09,930 --> 00:47:17,069
here and it turns out that that's big

897
00:47:12,599 --> 00:47:19,440
enough to make things go wrong in the in

898
00:47:17,069 --> 00:47:22,380
the packet mangler let me just go back

899
00:47:19,440 --> 00:47:32,849
to where it was not the panca bangle of

900
00:47:22,380 --> 00:47:40,529
the the icomparer okay back to

901
00:47:32,849 --> 00:47:42,329
presenting so I guess the kind of the

902
00:47:40,529 --> 00:47:43,829
ironic thing about this is that the the

903
00:47:42,329 --> 00:47:46,890
way that you trigger it is by turning a

904
00:47:43,829 --> 00:47:50,730
TCP packet because in that that's how

905
00:47:46,890 --> 00:47:54,109
you get the biggest size of IP packet in

906
00:47:50,730 --> 00:47:58,220
order for it to stick into the I comp

907
00:47:54,109 --> 00:47:58,220
message and trigger the bug

908
00:47:59,210 --> 00:48:04,710
so yeah so there was one final little

909
00:48:02,610 --> 00:48:06,780
thing to this story which is it did turn

910
00:48:04,710 --> 00:48:11,850
out that I was wrong about the reason

911
00:48:06,780 --> 00:48:13,680
that this crashed so my query was

912
00:48:11,850 --> 00:48:16,710
looking for places where it was flowing

913
00:48:13,680 --> 00:48:19,250
into em copy data and so I wrote a blog

914
00:48:16,710 --> 00:48:21,750
post about this and I got an email from

915
00:48:19,250 --> 00:48:26,040
Ian beer which is pretty cool to get an

916
00:48:21,750 --> 00:48:28,830
email from me in there and he I mean he

917
00:48:26,040 --> 00:48:31,470
actually knows how to debug the VX a new

918
00:48:28,830 --> 00:48:33,120
kernel and I don't and so he'd step

919
00:48:31,470 --> 00:48:34,830
through this in the debugger and it

920
00:48:33,120 --> 00:48:40,680
turns out that the place where it really

921
00:48:34,830 --> 00:48:41,970
crashes is on this line here so it turns

922
00:48:40,680 --> 00:48:44,490
out that they're doing some kind of

923
00:48:41,970 --> 00:48:51,509
unwise stuff with casting to you and 32

924
00:48:44,490 --> 00:48:53,490
here and and it causes a kind of a

925
00:48:51,510 --> 00:48:57,510
buffer overflow earlier in the code so

926
00:48:53,490 --> 00:49:00,350
it was it was crashing for a different

927
00:48:57,510 --> 00:49:02,570
reason that I realized but ultimately it

928
00:49:00,350 --> 00:49:05,700
didn't really matter too much I mean

929
00:49:02,570 --> 00:49:12,510
either way you could crash the crash the

930
00:49:05,700 --> 00:49:15,720
kernel okay so it's my final slide

931
00:49:12,510 --> 00:49:19,290
what's next so I haven't been working on

932
00:49:15,720 --> 00:49:21,209
xnu recently I've been looking at other

933
00:49:19,290 --> 00:49:22,680
open source projects so one of the main

934
00:49:21,210 --> 00:49:24,720
reasons for this is that I mean I'm

935
00:49:22,680 --> 00:49:26,879
still relatively inexperienced as a

936
00:49:24,720 --> 00:49:30,359
security researcher and I'm keen to

937
00:49:26,880 --> 00:49:32,250
learn not just how to crash things but

938
00:49:30,360 --> 00:49:35,400
also how to kind of like get code

939
00:49:32,250 --> 00:49:38,400
execution and I don't think that doing

940
00:49:35,400 --> 00:49:40,680
that on the XA new kernel where you

941
00:49:38,400 --> 00:49:42,030
can't just a touch gdb to is the best

942
00:49:40,680 --> 00:49:43,140
place to start learning that so I've

943
00:49:42,030 --> 00:49:45,180
been looking at some other projects

944
00:49:43,140 --> 00:49:48,000
worse where I can just fire up gdb and

945
00:49:45,180 --> 00:49:50,069
see what's happening but does that mean

946
00:49:48,000 --> 00:49:53,300
that X in use current networking code is

947
00:49:50,070 --> 00:49:57,090
bug free now I certainly doubt it

948
00:49:53,300 --> 00:49:59,670
you look at TCP input it is absolutely

949
00:49:57,090 --> 00:50:01,410
massive I find it hard to believe that

950
00:49:59,670 --> 00:50:04,380
they got every single line of that code

951
00:50:01,410 --> 00:50:06,060
right so I would encourage anybody who's

952
00:50:04,380 --> 00:50:08,109
interested to go look at that code and

953
00:50:06,060 --> 00:50:12,489
see if you could find

954
00:50:08,109 --> 00:50:14,230
find more bugs in it and that's all from

955
00:50:12,489 --> 00:50:20,349
me thank you very much

956
00:50:14,230 --> 00:50:20,349
[Applause]

957
00:50:25,540 --> 00:50:27,600
you

