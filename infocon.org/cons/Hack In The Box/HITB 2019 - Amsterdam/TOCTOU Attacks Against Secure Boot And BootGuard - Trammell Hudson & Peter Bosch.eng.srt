1
00:00:27,300 --> 00:00:33,000
welcome so what we found is a novel

2
00:00:30,990 --> 00:00:36,660
class of attacks against into a book art

3
00:00:33,000 --> 00:00:40,050
into book arts basically firmware

4
00:00:36,660 --> 00:00:42,140
verification and measurement feature

5
00:00:40,050 --> 00:00:45,660
that into offers to protect against

6
00:00:42,140 --> 00:00:49,470
malicious firmware or other kinds of

7
00:00:45,660 --> 00:00:54,239
hardware attacks on the fare system so I

8
00:00:49,470 --> 00:00:56,400
am beta butch I'm well this is actually

9
00:00:54,239 --> 00:01:00,300
my first security-related research have

10
00:00:56,400 --> 00:01:02,339
done mostly been spending last few years

11
00:01:00,300 --> 00:01:05,160
reverse engineering things when I wants

12
00:01:02,340 --> 00:01:07,350
to figure out more about them and when I

13
00:01:05,160 --> 00:01:09,660
got a new laptop and heard I couldn't

14
00:01:07,350 --> 00:01:11,789
put Corbett on it because of boot guard

15
00:01:09,660 --> 00:01:13,649
I really wanted to know how that worked

16
00:01:11,790 --> 00:01:16,860
and if there was some way to get around

17
00:01:13,649 --> 00:01:26,070
it so that's how I found this and I'll

18
00:01:16,860 --> 00:01:29,160
just have traveling to do some self well

19
00:01:26,070 --> 00:01:32,068
looks like we have some HDMI issues so

20
00:01:29,160 --> 00:01:33,539
I'm sure Martin I've been doing hardware

21
00:01:32,069 --> 00:01:35,700
and firmware security research for the

22
00:01:33,539 --> 00:01:38,039
past few years with on the offensive and

23
00:01:35,700 --> 00:01:39,929
the defensive side of things from the

24
00:01:38,039 --> 00:01:42,780
Thunderstrike work back a few years ago

25
00:01:39,929 --> 00:01:47,729
to the heads in Linux boot firmware

26
00:01:42,780 --> 00:01:49,649
projects and we're very focused on how

27
00:01:47,729 --> 00:01:53,369
can we protect against hardware and

28
00:01:49,649 --> 00:01:55,080
firmware threats and it's not just a

29
00:01:53,369 --> 00:01:58,470
research problem this is an

30
00:01:55,080 --> 00:02:00,810
industry-wide problem folks like Intel

31
00:01:58,470 --> 00:02:03,569
are also very concerned about how to

32
00:02:00,810 --> 00:02:04,729
protect systems from these sorts of

33
00:02:03,569 --> 00:02:07,649
attacks

34
00:02:04,729 --> 00:02:10,800
Vincent Zimmer is the head of the UEFI

35
00:02:07,649 --> 00:02:13,800
project at at Intel and he gave a talk

36
00:02:10,800 --> 00:02:16,140
at the Intel Developer Forum where he

37
00:02:13,800 --> 00:02:18,990
laid out a lot of the attacks on the

38
00:02:16,140 --> 00:02:22,319
platform now from different sort of root

39
00:02:18,990 --> 00:02:22,920
kits and malware in the boot roms to

40
00:02:22,319 --> 00:02:26,399
things

41
00:02:22,920 --> 00:02:28,708
malicious devices and he presented

42
00:02:26,400 --> 00:02:30,599
Intel's a solution to this something

43
00:02:28,709 --> 00:02:34,020
called a boot guard that's a fully

44
00:02:30,599 --> 00:02:36,269
verified boot sequence that moves the

45
00:02:34,020 --> 00:02:38,550
route of trust into hardware and does

46
00:02:36,270 --> 00:02:41,040
policy enforcement through that Hardware

47
00:02:38,550 --> 00:02:43,080
implementation

48
00:02:41,040 --> 00:02:46,109
unfortunately they have not released

49
00:02:43,080 --> 00:02:48,120
anything without NDA's so there's no

50
00:02:46,110 --> 00:02:51,300
real public documentation about how it

51
00:02:48,120 --> 00:02:53,250
works which means the best documentation

52
00:02:51,300 --> 00:02:55,500
right now our presentations like Alex

53
00:02:53,250 --> 00:02:59,040
metrof softs who watches the BIOS

54
00:02:55,500 --> 00:03:00,660
Watchers that lays out how boot guard is

55
00:02:59,040 --> 00:03:04,470
organized what the various structures

56
00:03:00,660 --> 00:03:06,180
are and how the chain of trust works and

57
00:03:04,470 --> 00:03:07,650
chain of trust is an important term that

58
00:03:06,180 --> 00:03:09,540
we're going to be talking a lot about in

59
00:03:07,650 --> 00:03:13,080
this presentation so there's a quick

60
00:03:09,540 --> 00:03:16,470
very simplified overview the boot guard

61
00:03:13,080 --> 00:03:19,519
chain of trust starts inside the intel

62
00:03:16,470 --> 00:03:24,989
management engines boot rom which is

63
00:03:19,519 --> 00:03:27,900
on-die and immutable in the hardware it

64
00:03:24,989 --> 00:03:31,019
has enough smarts to verify a signature

65
00:03:27,900 --> 00:03:33,890
on the AMIA region in the spy flash on

66
00:03:31,019 --> 00:03:37,650
the mainboard which is then able to

67
00:03:33,890 --> 00:03:40,200
start the x86 which runs Intel signed

68
00:03:37,650 --> 00:03:42,840
micro code which is able to invent

69
00:03:40,200 --> 00:03:46,828
validate Intel's signature on the

70
00:03:42,840 --> 00:03:49,350
authenticated code module in the also in

71
00:03:46,829 --> 00:03:53,940
the spy flash and these are all signed

72
00:03:49,350 --> 00:03:57,269
by Intel's private key and verified with

73
00:03:53,940 --> 00:04:01,650
keys that are fixed in the in the

74
00:03:57,269 --> 00:04:06,000
hardware the authenticated coach module

75
00:04:01,650 --> 00:04:08,430
is transferred a set of om keys that are

76
00:04:06,000 --> 00:04:11,069
fused by the manufacturer during

77
00:04:08,430 --> 00:04:14,040
manufacturing time and are then used to

78
00:04:11,069 --> 00:04:15,720
validate the reset vector and the spy

79
00:04:14,040 --> 00:04:19,039
fly actually the reset vector and the

80
00:04:15,720 --> 00:04:22,500
PGI region in the spy flash which then

81
00:04:19,039 --> 00:04:24,450
validates signatures on the the Dixie

82
00:04:22,500 --> 00:04:27,000
region in the spy flash which can then

83
00:04:24,450 --> 00:04:29,190
validate the bootloader which can then

84
00:04:27,000 --> 00:04:31,530
validate the OS kernel and these are all

85
00:04:29,190 --> 00:04:34,979
signed by the independent BIOS vendors

86
00:04:31,530 --> 00:04:39,320
or the OEMs or the legacy operating

87
00:04:34,979 --> 00:04:41,099
system manufacturers and this is

88
00:04:39,320 --> 00:04:44,070
wonderful from a security perspective

89
00:04:41,099 --> 00:04:44,969
because it does ensure that if

90
00:04:44,070 --> 00:04:48,630
implemented correctly

91
00:04:44,970 --> 00:04:51,780
no unauthorized code will run during the

92
00:04:48,630 --> 00:04:54,930
boot process but as Peter mentioned he

93
00:04:51,780 --> 00:04:56,250
wanted to run core boot and other

94
00:04:54,930 --> 00:04:58,590
people in the free software community

95
00:04:56,250 --> 00:05:01,169
have complained about this such as

96
00:04:58,590 --> 00:05:04,799
Matthew Garrett who pointed out that

97
00:05:01,169 --> 00:05:07,469
well this is great for security this is

98
00:05:04,800 --> 00:05:10,740
makes a trade off against user freedom

99
00:05:07,470 --> 00:05:12,690
that it sort of violates the spirit of

100
00:05:10,740 --> 00:05:18,330
free software if we can't put our own

101
00:05:12,690 --> 00:05:20,580
firmware onto our own machines but as he

102
00:05:18,330 --> 00:05:23,580
points out Intel should be congratulated

103
00:05:20,580 --> 00:05:25,560
for building a system that does give us

104
00:05:23,580 --> 00:05:29,820
a hardware board of trust because it

105
00:05:25,560 --> 00:05:31,740
does mean that very complex attacks are

106
00:05:29,820 --> 00:05:34,320
now in scope things like evil made

107
00:05:31,740 --> 00:05:36,120
attacks that used to be considered have

108
00:05:34,320 --> 00:05:38,729
out of scope and too hard to defend

109
00:05:36,120 --> 00:05:42,150
against or attacks that required

110
00:05:38,729 --> 00:05:44,490
physical access to internal hardware to

111
00:05:42,150 --> 00:05:46,650
install Hardware implants or other

112
00:05:44,490 --> 00:05:49,320
devices used to be considered you know

113
00:05:46,650 --> 00:05:52,560
just game over from security but with

114
00:05:49,320 --> 00:05:54,870
boot guard these attacks are supposed to

115
00:05:52,560 --> 00:05:58,889
be protected against and that's actually

116
00:05:54,870 --> 00:06:03,860
a good thing it if we can have some user

117
00:05:58,889 --> 00:06:07,169
freedom to go along with it and the the

118
00:06:03,860 --> 00:06:09,510
key management and the cryptography does

119
00:06:07,169 --> 00:06:11,330
seem to be fairly sound but there have

120
00:06:09,510 --> 00:06:14,250
been some attacks against a blue card

121
00:06:11,330 --> 00:06:15,659
and they're not against the algorithm

122
00:06:14,250 --> 00:06:17,880
itself they're against the

123
00:06:15,659 --> 00:06:21,650
implementation and typically against the

124
00:06:17,880 --> 00:06:24,780
OEM components of that implementation

125
00:06:21,650 --> 00:06:26,669
one of the most glaring problems right

126
00:06:24,780 --> 00:06:28,770
now is a lot of OEMs are not even

127
00:06:26,669 --> 00:06:33,000
turning on boot guard they're leaving

128
00:06:28,770 --> 00:06:35,760
the machines in with the OEM keys of

129
00:06:33,000 --> 00:06:38,699
unset which means that malware could

130
00:06:35,760 --> 00:06:41,030
potentially set those keys and create

131
00:06:38,699 --> 00:06:46,260
root kits that could not be removed by

132
00:06:41,030 --> 00:06:48,500
anyone on the machine Alex earmuff

133
00:06:46,260 --> 00:06:51,479
presented zero Knights where they found

134
00:06:48,500 --> 00:06:56,340
quite a few vendors were not bothering

135
00:06:51,479 --> 00:06:58,139
to enable it other OBM implementations

136
00:06:56,340 --> 00:07:01,669
have have made some poor choices such as

137
00:06:58,139 --> 00:07:04,770
what embed he found which is that the

138
00:07:01,669 --> 00:07:06,479
the boot guard checks were would set a

139
00:07:04,770 --> 00:07:10,020
global variable

140
00:07:06,479 --> 00:07:11,610
and then depended on code in the Dixie

141
00:07:10,020 --> 00:07:14,849
region to check that variable and

142
00:07:11,610 --> 00:07:19,229
enforce policy but you can't enforce

143
00:07:14,849 --> 00:07:21,270
policy from something that is being is

144
00:07:19,229 --> 00:07:23,339
being checked by it because if if the

145
00:07:21,270 --> 00:07:25,948
attacker can remove those checks then

146
00:07:23,339 --> 00:07:30,659
there's no code that actually ensures

147
00:07:25,949 --> 00:07:33,150
the validation is correct there are have

148
00:07:30,659 --> 00:07:35,639
been other sort of bad design decisions

149
00:07:33,150 --> 00:07:39,120
that folks have found such as Alex

150
00:07:35,639 --> 00:07:41,490
Morozov that who realized that when

151
00:07:39,120 --> 00:07:43,680
Windows 10 does its update it has a way

152
00:07:41,490 --> 00:07:45,689
to turn off boot guard which means that

153
00:07:43,680 --> 00:07:48,180
the hardware root of trust is no longer

154
00:07:45,689 --> 00:07:51,599
rooted in hardware that it's a it's only

155
00:07:48,180 --> 00:07:56,849
a software a bit away from being

156
00:07:51,599 --> 00:07:58,649
disabled so this also indicates the

157
00:07:56,849 --> 00:08:00,360
biggest problem with the chain of trust

158
00:07:58,649 --> 00:08:02,069
is it's not defense-in-depth

159
00:08:00,360 --> 00:08:04,379
it means that every link in the chain

160
00:08:02,069 --> 00:08:06,349
has to do the right thing has to

161
00:08:04,379 --> 00:08:09,300
implement security correctly or

162
00:08:06,349 --> 00:08:14,219
everything after that in the chain can

163
00:08:09,300 --> 00:08:15,779
be compromised in an example of where

164
00:08:14,219 --> 00:08:17,939
this can take effect or something like

165
00:08:15,779 --> 00:08:18,300
the positive technologies attack on boot

166
00:08:17,939 --> 00:08:21,360
guard

167
00:08:18,300 --> 00:08:22,830
sorry attack on the Emme that once they

168
00:08:21,360 --> 00:08:25,499
were able to get code execution in the

169
00:08:22,830 --> 00:08:29,849
Emme they're able to pass the their own

170
00:08:25,499 --> 00:08:33,930
om keys up to the to the ACM and pretend

171
00:08:29,849 --> 00:08:37,139
that that they've has signed the other

172
00:08:33,929 --> 00:08:40,260
firmware there have also been some

173
00:08:37,139 --> 00:08:42,479
vendors where parts of the firmware had

174
00:08:40,260 --> 00:08:46,740
not been included in the boot guard

175
00:08:42,479 --> 00:08:47,970
hashes both Lenovo and also Intel made

176
00:08:46,740 --> 00:08:51,500
them has taken some of the reference

177
00:08:47,970 --> 00:08:54,449
code so what I found these two

178
00:08:51,500 --> 00:08:57,240
vulnerabilities it wasn't a complex

179
00:08:54,449 --> 00:09:00,599
analysis of algorithms it literally was

180
00:08:57,240 --> 00:09:03,839
loading the firmware into the the UEFI

181
00:09:00,600 --> 00:09:06,029
tool program which helpfully color codes

182
00:09:03,839 --> 00:09:10,170
the parts that are boot guard protected

183
00:09:06,029 --> 00:09:12,540
by Intel's hashes the parts that are

184
00:09:10,170 --> 00:09:14,699
protected by the OEM he used in this

185
00:09:12,540 --> 00:09:16,620
case the Phoenix hash and then a bunch

186
00:09:14,699 --> 00:09:19,920
of firmware volumes that are just

187
00:09:16,620 --> 00:09:21,930
completely unsigned and unhatched so

188
00:09:19,920 --> 00:09:26,269
any executable code in there basically

189
00:09:21,930 --> 00:09:26,269
gives say ability to bypass blue card

190
00:09:26,450 --> 00:09:32,220
most of these attacks would be detected

191
00:09:29,579 --> 00:09:35,189
by a measured boot mode so where these

192
00:09:32,220 --> 00:09:38,790
these firmware volumes are are hashed

193
00:09:35,190 --> 00:09:42,329
into the TPM and the PCRs would reflect

194
00:09:38,790 --> 00:09:45,899
the actual values that were in the ROM

195
00:09:42,329 --> 00:09:48,209
so even if an attacker were able to

196
00:09:45,899 --> 00:09:50,160
modify them in a code execution they

197
00:09:48,209 --> 00:09:53,939
would not be able to extract say a TPM

198
00:09:50,160 --> 00:09:56,279
sealed secret because the code that is

199
00:09:53,940 --> 00:09:59,670
executed is the same that is measured

200
00:09:56,279 --> 00:10:00,570
into the hash but what if there's some

201
00:09:59,670 --> 00:10:02,990
sleight of hand

202
00:10:00,570 --> 00:10:05,310
where it's possible to change that code

203
00:10:02,990 --> 00:10:07,170
after the validation and the

204
00:10:05,310 --> 00:10:10,138
verification but before the execution

205
00:10:07,170 --> 00:10:17,880
and to talk more about that I'll hand it

206
00:10:10,139 --> 00:10:20,070
back over to Peter yes so yeah until did

207
00:10:17,880 --> 00:10:22,250
actually think about this in a design of

208
00:10:20,070 --> 00:10:26,790
boot guard this time I'll mention for

209
00:10:22,250 --> 00:10:31,980
our attacks really are in there in your

210
00:10:26,790 --> 00:10:34,050
fret level so let's see when you look at

211
00:10:31,980 --> 00:10:37,560
the manual that vendors get for

212
00:10:34,050 --> 00:10:41,040
configuring their bios's there's this

213
00:10:37,560 --> 00:10:45,410
little thing in there that says protect

214
00:10:41,040 --> 00:10:48,540
by his environment and it basically

215
00:10:45,410 --> 00:10:50,219
allows vendors to configure the ACM the

216
00:10:48,540 --> 00:10:54,779
authenticated code module first part of

217
00:10:50,220 --> 00:10:59,040
boot guard to configure the CPU in

218
00:10:54,779 --> 00:11:01,939
what's known as caches Ram mode and put

219
00:10:59,040 --> 00:11:05,640
the entire first part of the firmware

220
00:11:01,940 --> 00:11:07,440
inside last level cache so any attacks

221
00:11:05,640 --> 00:11:11,010
on the hardware can't touch it anymore

222
00:11:07,440 --> 00:11:15,360
no DMA attacks no attacks on the flesh

223
00:11:11,010 --> 00:11:17,670
itself so this shows that they did

224
00:11:15,360 --> 00:11:21,680
actually think about trying to prevent

225
00:11:17,670 --> 00:11:24,240
this so

226
00:11:21,680 --> 00:11:27,000
what actually is Cassius around Cassius

227
00:11:24,240 --> 00:11:30,959
Ram is needed because in modern systems

228
00:11:27,000 --> 00:11:33,690
you don't immediately have your your DDR

229
00:11:30,959 --> 00:11:35,758
memory working when the processor starts

230
00:11:33,690 --> 00:11:37,290
up there's a lot of configuration that

231
00:11:35,759 --> 00:11:40,019
needs to be done in order to get there

232
00:11:37,290 --> 00:11:41,399
and that happens after this station you

233
00:11:40,019 --> 00:11:45,329
want to make sure that the code that

234
00:11:41,399 --> 00:11:47,639
does that is actually verified so you

235
00:11:45,329 --> 00:11:51,209
need a different way of safeguarding

236
00:11:47,639 --> 00:11:53,940
your code and they reuse the cache to do

237
00:11:51,209 --> 00:11:58,500
that by putting any write back mode

238
00:11:53,940 --> 00:12:01,519
writing the stuff in there and then then

239
00:11:58,500 --> 00:12:05,279
you can basically use it as round so

240
00:12:01,519 --> 00:12:06,750
this is basically what we would do if we

241
00:12:05,279 --> 00:12:08,339
wanted to prevent up against the time to

242
00:12:06,750 --> 00:12:11,430
check time of use attack we copy

243
00:12:08,339 --> 00:12:14,370
whatever we need to verify into a safe

244
00:12:11,430 --> 00:12:16,709
area and then we verify it and no one

245
00:12:14,370 --> 00:12:18,959
can touch it so it's safe because

246
00:12:16,709 --> 00:12:21,359
there's no RAM you just caches Ram it

247
00:12:18,959 --> 00:12:26,430
looks something like this where so

248
00:12:21,360 --> 00:12:31,319
separate addresses and so it's safe but

249
00:12:26,430 --> 00:12:32,699
you need to copy it that's slow and then

250
00:12:31,319 --> 00:12:36,870
you need to verify it again so you

251
00:12:32,699 --> 00:12:38,639
basically reading it twice so Intel came

252
00:12:36,870 --> 00:12:41,550
up with a smarter way to do this sky

253
00:12:38,639 --> 00:12:44,550
like CPUs inure have a Novik mode of

254
00:12:41,550 --> 00:12:46,050
cache which means that not just can you

255
00:12:44,550 --> 00:12:49,740
use it as RAM you can actually tell it

256
00:12:46,050 --> 00:12:52,769
never to evict a line even if it's not

257
00:12:49,740 --> 00:12:57,329
dirty so you don't need to copy it

258
00:12:52,769 --> 00:13:00,660
anymore you can just have your wrong

259
00:12:57,329 --> 00:13:02,939
with your initial boot block do your

260
00:13:00,660 --> 00:13:05,660
hash verification on that when you do

261
00:13:02,939 --> 00:13:07,920
that you're reading it so it's cached

262
00:13:05,660 --> 00:13:10,860
because the cache isn't allowed to evict

263
00:13:07,920 --> 00:13:13,649
anything it will stay there and it's

264
00:13:10,860 --> 00:13:16,290
safe whether there's a number of

265
00:13:13,649 --> 00:13:19,230
problems with this approach if your each

266
00:13:16,290 --> 00:13:20,880
should work but it's all implicit so you

267
00:13:19,230 --> 00:13:24,600
don't copy it to a safe area you just

268
00:13:20,880 --> 00:13:28,290
trust the CPU to keep it in its cache so

269
00:13:24,600 --> 00:13:31,490
if if you do this you can think that if

270
00:13:28,290 --> 00:13:35,569
it's implicit putting it in there the

271
00:13:31,490 --> 00:13:37,490
you might also not notice if the cash

272
00:13:35,570 --> 00:13:41,180
all of sudden didn't keep it anymore

273
00:13:37,490 --> 00:13:43,610
so what could go wrong well what if your

274
00:13:41,180 --> 00:13:48,079
bias is larger than your last level

275
00:13:43,610 --> 00:13:49,880
cache so on on skylake CPA my laptop I

276
00:13:48,080 --> 00:13:52,220
think last level cache is about 12

277
00:13:49,880 --> 00:13:54,560
megabytes so this shouldn't happen but

278
00:13:52,220 --> 00:13:57,830
it could flash ship is 60 megabytes so

279
00:13:54,560 --> 00:13:59,900
if Venna were to set it up wrong they

280
00:13:57,830 --> 00:14:01,610
think it was protected but it's not this

281
00:13:59,900 --> 00:14:04,160
is actually what got me on this train is

282
00:14:01,610 --> 00:14:05,720
for pinafore at first because I saw they

283
00:14:04,160 --> 00:14:07,280
were using this way and I thought well

284
00:14:05,720 --> 00:14:09,980
what if it doesn't fit in the cache then

285
00:14:07,280 --> 00:14:12,709
I realized cache large enough but still

286
00:14:09,980 --> 00:14:16,280
wanted to look into it because you could

287
00:14:12,710 --> 00:14:18,320
also have a cache flush instruction or

288
00:14:16,280 --> 00:14:20,150
maybe something turns the caches off and

289
00:14:18,320 --> 00:14:21,950
then the code would keep running because

290
00:14:20,150 --> 00:14:23,329
it's still at the same address it just

291
00:14:21,950 --> 00:14:25,610
not be running from cache anymore

292
00:14:23,330 --> 00:14:28,220
instead it would be will be running

293
00:14:25,610 --> 00:14:30,820
directly from flash ship which of course

294
00:14:28,220 --> 00:14:30,820
is a bad idea

295
00:14:31,390 --> 00:14:36,920
so yeah when I realized this could

296
00:14:35,210 --> 00:14:40,490
happen I decided to hook up a logic

297
00:14:36,920 --> 00:14:42,680
analyzer and this was made possible by

298
00:14:40,490 --> 00:14:44,480
my hacker space because this is a pretty

299
00:14:42,680 --> 00:14:47,839
fast logic analyzer that I wouldn't have

300
00:14:44,480 --> 00:14:54,920
access to otherwise and I am I captured

301
00:14:47,840 --> 00:14:57,200
the trace of ESP I bus and then I had to

302
00:14:54,920 --> 00:14:59,540
write a sig Rock decoder to actually

303
00:14:57,200 --> 00:15:01,910
process it because it's not really just

304
00:14:59,540 --> 00:15:07,430
SPI there's all kinds of optimizations

305
00:15:01,910 --> 00:15:09,530
going on so when that was done running

306
00:15:07,430 --> 00:15:11,329
at 2 o'clock time as well because I

307
00:15:09,530 --> 00:15:16,189
think I captured about 4 gigabytes of

308
00:15:11,330 --> 00:15:18,600
trace data for a single booth of course

309
00:15:16,190 --> 00:15:22,290
it's all still serial form

310
00:15:18,600 --> 00:15:24,990
when I'd process the data I had a nice

311
00:15:22,290 --> 00:15:28,230
log saying which addresses were accessed

312
00:15:24,990 --> 00:15:30,180
in which order I think a good way to

313
00:15:28,230 --> 00:15:32,220
visualize this is just to plot it

314
00:15:30,180 --> 00:15:36,239
against time

315
00:15:32,220 --> 00:15:38,280
so although the blue lines on here blue

316
00:15:36,240 --> 00:15:40,730
dots are the first time an address is

317
00:15:38,280 --> 00:15:44,069
red and everything that's in red is

318
00:15:40,730 --> 00:15:46,400
something that's being read again that

319
00:15:44,070 --> 00:15:50,060
was already read before so those are

320
00:15:46,400 --> 00:15:55,520
potentially for a row so this is the

321
00:15:50,060 --> 00:15:57,719
actual hash of the BIOS being calculated

322
00:15:55,520 --> 00:16:02,310
which also the point it should be loaded

323
00:15:57,720 --> 00:16:05,370
in cache and be safe then at some point

324
00:16:02,310 --> 00:16:08,250
you start seeing these very frequent

325
00:16:05,370 --> 00:16:11,910
three reads from flash and there's

326
00:16:08,250 --> 00:16:13,620
actually a few happening before that but

327
00:16:11,910 --> 00:16:16,800
I really didn't really look into those

328
00:16:13,620 --> 00:16:19,620
because I just wanted to see if I could

329
00:16:16,800 --> 00:16:23,069
easily exploit this and I didn't really

330
00:16:19,620 --> 00:16:25,710
feel like chasing down whether a data

331
00:16:23,070 --> 00:16:30,930
read was possible to use to gain control

332
00:16:25,710 --> 00:16:33,210
of the thing they probably are so this

333
00:16:30,930 --> 00:16:38,370
is the first one that I could find that

334
00:16:33,210 --> 00:16:40,830
would actually directly x-cube code so

335
00:16:38,370 --> 00:16:42,600
it's this one that's in the set core

336
00:16:40,830 --> 00:16:45,120
module so for those of you who aren't

337
00:16:42,600 --> 00:16:48,890
familiar with exactly how you if I works

338
00:16:45,120 --> 00:16:51,780
this module just sets up the system and

339
00:16:48,890 --> 00:16:57,080
isn't really supposed to run very much

340
00:16:51,780 --> 00:17:02,160
later in boot so why is it running here

341
00:16:57,080 --> 00:17:04,079
this is actually this function the PAI

342
00:17:02,160 --> 00:17:06,599
temporary ramdom which is a handler

343
00:17:04,079 --> 00:17:11,250
that's installed by sec or as a callback

344
00:17:06,599 --> 00:17:12,959
to be run after the the actual main

345
00:17:11,250 --> 00:17:15,660
memory is initialized them when it can

346
00:17:12,960 --> 00:17:17,490
clean up what they call temporary RAM

347
00:17:15,660 --> 00:17:21,600
which is cache Ram

348
00:17:17,490 --> 00:17:23,880
so looking at those addresses in my

349
00:17:21,599 --> 00:17:26,549
disassembler I saw these instructions so

350
00:17:23,880 --> 00:17:28,860
this doesn't look too suspect at first

351
00:17:26,549 --> 00:17:30,899
if you're not familiar with the way

352
00:17:28,860 --> 00:17:33,779
Intel's cache setup works

353
00:17:30,899 --> 00:17:36,350
it's just clearing a bit in some Emma's

354
00:17:33,779 --> 00:17:38,730
our little specific register but then

355
00:17:36,350 --> 00:17:41,340
you get out your into architecture

356
00:17:38,730 --> 00:17:45,200
manual you see this is the NTR

357
00:17:41,340 --> 00:17:47,789
enable/disable bit and that when it set

358
00:17:45,200 --> 00:17:51,210
the mtrs work and everything is fine but

359
00:17:47,789 --> 00:17:53,370
when you clear it all of a sudden all of

360
00:17:51,210 --> 00:17:55,320
your memory is considered to be uncashed

361
00:17:53,370 --> 00:17:59,510
memory type so your caches are

362
00:17:55,320 --> 00:18:02,939
effectively disabled which explains why

363
00:17:59,510 --> 00:18:05,460
after this point you start seeing the

364
00:18:02,940 --> 00:18:09,659
firmware running execute in place from

365
00:18:05,460 --> 00:18:14,760
flash which it should never be doing so

366
00:18:09,659 --> 00:18:16,799
just to summarize what the actual flow

367
00:18:14,760 --> 00:18:18,390
is that the system goes through while

368
00:18:16,799 --> 00:18:20,429
booting you've got your ACM running

369
00:18:18,390 --> 00:18:23,340
which is a piece of Intel code that's

370
00:18:20,429 --> 00:18:27,419
I'm a and so you can't change it that

371
00:18:23,340 --> 00:18:30,480
verifies and hash on the ROM that then

372
00:18:27,419 --> 00:18:34,860
starts the SEC or which loads the P I

373
00:18:30,480 --> 00:18:36,200
chord in the next stage and then the P

374
00:18:34,860 --> 00:18:40,168
Ike or lost

375
00:18:36,200 --> 00:18:43,679
Ram and chip setting is initialization

376
00:18:40,169 --> 00:18:49,070
module which then goes on to initialize

377
00:18:43,679 --> 00:18:52,640
DRAM and disables caches Ram before

378
00:18:49,070 --> 00:18:55,799
running the rest of the UEFI modules

379
00:18:52,640 --> 00:18:57,419
from round but this is how it should

380
00:18:55,799 --> 00:19:00,260
work because actually we just saw that

381
00:18:57,419 --> 00:19:03,360
disable caches Ram snap halfway through

382
00:19:00,260 --> 00:19:07,669
would disable caches and execute in

383
00:19:03,360 --> 00:19:10,229
place from flash so when I saw this I

384
00:19:07,669 --> 00:19:13,260
thought well I need to check whether I

385
00:19:10,230 --> 00:19:16,950
can actually use this to run my own code

386
00:19:13,260 --> 00:19:19,789
this area but the reason that would be

387
00:19:16,950 --> 00:19:22,049
useful of course is that at this point

388
00:19:19,789 --> 00:19:23,360
almost none of the Emma's ours have been

389
00:19:22,049 --> 00:19:25,320
locked down

390
00:19:23,360 --> 00:19:28,080
there's no system management mode

391
00:19:25,320 --> 00:19:31,389
running yet so in theory you could load

392
00:19:28,080 --> 00:19:33,220
all kinds of nasty boot kids

393
00:19:31,390 --> 00:19:35,980
lock it down and the rest of the

394
00:19:33,220 --> 00:19:40,840
firmware would really notice so it's

395
00:19:35,980 --> 00:19:46,060
pretty bad to be able to do this so yeah

396
00:19:40,840 --> 00:19:49,929
he set out to try it so I opened up my

397
00:19:46,060 --> 00:19:52,090
laptop and at first I actually was

398
00:19:49,930 --> 00:19:53,800
trying to do this just using clamps but

399
00:19:52,090 --> 00:19:56,889
then I tore off some pads and I decided

400
00:19:53,800 --> 00:19:58,659
I need to do something more safe for my

401
00:19:56,890 --> 00:20:02,980
heart or so I sold it on a header to the

402
00:19:58,660 --> 00:20:05,830
SPI bus up here and actually lifted the

403
00:20:02,980 --> 00:20:08,080
pad for the chips leg thin so that's

404
00:20:05,830 --> 00:20:12,100
running through the header now instead

405
00:20:08,080 --> 00:20:14,230
of directly onto the motherboard which

406
00:20:12,100 --> 00:20:15,879
means that if I bridge that it's working

407
00:20:14,230 --> 00:20:18,660
as normal but I can interrupt it and

408
00:20:15,880 --> 00:20:21,400
have any other device response to the

409
00:20:18,660 --> 00:20:28,120
sort of request being sent by the by

410
00:20:21,400 --> 00:20:31,840
chipset and then I made a quick FPGA

411
00:20:28,120 --> 00:20:34,179
design that would listen for all the

412
00:20:31,840 --> 00:20:36,909
read transactions on the SPI bus and

413
00:20:34,180 --> 00:20:38,610
once it detected an address I could see

414
00:20:36,910 --> 00:20:41,680
in my log would only be accessed after

415
00:20:38,610 --> 00:20:44,139
verification so in this case that was

416
00:20:41,680 --> 00:20:49,420
one of the EFI variables which are not

417
00:20:44,140 --> 00:20:51,550
included in hash I would turn on my

418
00:20:49,420 --> 00:20:54,870
device which would then reroute chip

419
00:20:51,550 --> 00:20:57,700
select to an external ROM now this is a

420
00:20:54,870 --> 00:21:00,639
pretty simple way of doing it and it's

421
00:20:57,700 --> 00:21:02,740
got a lot of flaws because need to

422
00:21:00,640 --> 00:21:06,520
reflash that external ROM every time I

423
00:21:02,740 --> 00:21:11,100
want to try a new payload and it is

424
00:21:06,520 --> 00:21:14,620
pretty difficult to to time it correctly

425
00:21:11,100 --> 00:21:19,120
so so it worked I was able to run my own

426
00:21:14,620 --> 00:21:21,580
code because because there is not really

427
00:21:19,120 --> 00:21:26,439
a lot of input/output devices available

428
00:21:21,580 --> 00:21:30,460
at this point I decided to use the SPI

429
00:21:26,440 --> 00:21:32,800
bus itself to to communicate from my

430
00:21:30,460 --> 00:21:38,360
payload so I just had a big area of

431
00:21:32,800 --> 00:21:42,690
memory where I would

432
00:21:38,360 --> 00:21:46,529
or agreed index based on the data and

433
00:21:42,690 --> 00:21:52,169
just use that as a simple text mode

434
00:21:46,529 --> 00:21:54,500
output and I wrote a small script that

435
00:21:52,169 --> 00:21:57,330
would parse logic analyzer output and

436
00:21:54,500 --> 00:21:58,460
would show me when I painted so just

437
00:21:57,330 --> 00:22:00,539
hello world

438
00:21:58,460 --> 00:22:02,970
later on I didn't do some more

439
00:22:00,539 --> 00:22:07,590
complicated stuff but I could run code

440
00:22:02,970 --> 00:22:10,590
on a machine had boot guard enable very

441
00:22:07,590 --> 00:22:12,418
early during boot so so this is setup

442
00:22:10,590 --> 00:22:15,000
here's the board that has the ROM on

443
00:22:12,419 --> 00:22:17,940
it's actually not on your time I took

444
00:22:15,000 --> 00:22:21,210
this photo but this is the FPGA and also

445
00:22:17,940 --> 00:22:23,370
had the the address lines for the ROM

446
00:22:21,210 --> 00:22:25,559
decoded and sent out to logic analyzer

447
00:22:23,370 --> 00:22:27,360
so I didn't have to do very slow

448
00:22:25,559 --> 00:22:29,549
analysis of the SPI trace it could just

449
00:22:27,360 --> 00:22:33,360
look at a parallel bus that showed Y

450
00:22:29,549 --> 00:22:34,740
apples so this worked but then I wasn't

451
00:22:33,360 --> 00:22:36,330
really sure what to do about it because

452
00:22:34,740 --> 00:22:40,820
of what well it's a harbor attack one

453
00:22:36,330 --> 00:22:47,039
who's gonna be interested in that and

454
00:22:40,820 --> 00:22:48,840
this was late December so I just thought

455
00:22:47,039 --> 00:22:52,879
well let's get back to it later on I

456
00:22:48,840 --> 00:22:52,879
went to chaos communication congress and

457
00:22:53,360 --> 00:22:58,889
went there there was this open source

458
00:22:56,309 --> 00:23:00,269
firmware boof so I walked up there and

459
00:22:58,889 --> 00:23:02,639
asked is there anyone here that knows

460
00:23:00,269 --> 00:23:06,480
more about good guard and they pointed

461
00:23:02,639 --> 00:23:08,309
me to Trammell and when I said to a

462
00:23:06,480 --> 00:23:09,600
family I might have something I didn't

463
00:23:08,309 --> 00:23:11,970
really tell him that much

464
00:23:09,600 --> 00:23:15,480
first thing he does is he opens his

465
00:23:11,970 --> 00:23:17,429
laptop nipples of this so apparently a

466
00:23:15,480 --> 00:23:20,460
couple of months before I was doing this

467
00:23:17,429 --> 00:23:23,730
he'd already traced the access pattern

468
00:23:20,460 --> 00:23:26,370
and realized that there was probably

469
00:23:23,730 --> 00:23:27,840
something fishy going on here but he

470
00:23:26,370 --> 00:23:30,870
didn't really have time to look at it

471
00:23:27,840 --> 00:23:33,000
any further send it to Intel and they

472
00:23:30,870 --> 00:23:36,360
said well you need to have a proof of

473
00:23:33,000 --> 00:23:39,750
concept at first so yeah that's what I

474
00:23:36,360 --> 00:23:43,320
had so he agreed to meet up at at my

475
00:23:39,750 --> 00:23:48,169
hacker space rest base and build a

476
00:23:43,320 --> 00:23:48,168
better proof of concept so this time we

477
00:23:49,080 --> 00:23:53,790
took it from a big setup with multiple

478
00:23:51,240 --> 00:23:59,429
parts to just attaching this FPGA effort

479
00:23:53,790 --> 00:24:01,260
to the model board and yeah we also

480
00:23:59,429 --> 00:24:03,870
switched from having a separate external

481
00:24:01,260 --> 00:24:08,250
Rome to emulating Rome when we're

482
00:24:03,870 --> 00:24:12,928
overriding it in the FPGA and there's

483
00:24:08,250 --> 00:24:15,450
also now a serial output core in the

484
00:24:12,929 --> 00:24:19,440
FPGA that will send you the access

485
00:24:15,450 --> 00:24:22,429
pattern the access pattern as easily

486
00:24:19,440 --> 00:24:25,200
readable text over a USB serial port so

487
00:24:22,429 --> 00:24:27,270
no logic analyzers no expensive tooling

488
00:24:25,200 --> 00:24:29,250
required anymore you just hook this up

489
00:24:27,270 --> 00:24:35,340
and you can you can do your tracing you

490
00:24:29,250 --> 00:24:37,170
can attack it there was also something

491
00:24:35,340 --> 00:24:39,659
else that needed to be demonstrated I

492
00:24:37,170 --> 00:24:42,570
could run code but that wouldn't really

493
00:24:39,660 --> 00:24:43,770
show that it could go undetected so we

494
00:24:42,570 --> 00:24:46,830
needed to get the system to boot

495
00:24:43,770 --> 00:24:49,110
afterwards in order to do that we

496
00:24:46,830 --> 00:24:54,059
improved upon the basic idea of the type

497
00:24:49,110 --> 00:24:56,280
of check confuse by also adding a set

498
00:24:54,059 --> 00:24:58,110
where a second trigger address that once

499
00:24:56,280 --> 00:25:01,350
it's read will disable the entire device

500
00:24:58,110 --> 00:25:02,280
make it invisible again to the system so

501
00:25:01,350 --> 00:25:05,879
at the end of our payload

502
00:25:02,280 --> 00:25:11,309
we then you know read that a verse and

503
00:25:05,880 --> 00:25:13,620
jump back to the original to the

504
00:25:11,309 --> 00:25:18,389
original instruction that was supposed

505
00:25:13,620 --> 00:25:20,809
to be executing after and that way

506
00:25:18,390 --> 00:25:25,020
the system would Buddhist normal and

507
00:25:20,809 --> 00:25:26,910
once it booted up and the PCR so that

508
00:25:25,020 --> 00:25:29,550
the measurement registers in the TPM we

509
00:25:26,910 --> 00:25:31,559
show no sign of tampering so this is

510
00:25:29,550 --> 00:25:33,149
pretty bad then we could run whatever

511
00:25:31,559 --> 00:25:36,740
code we wanted to earlier boot and

512
00:25:33,150 --> 00:25:40,320
system the TPM wouldn't notice

513
00:25:36,740 --> 00:25:43,580
so at this point Tramell contacts some

514
00:25:40,320 --> 00:25:43,580
people at Intel we send them an email

515
00:25:43,910 --> 00:25:54,660
also containing this nice video we made

516
00:25:47,160 --> 00:26:00,770
it's so it's

517
00:25:54,660 --> 00:26:00,770
it's not really that interesting but a

518
00:26:01,220 --> 00:26:05,850
simple payload beeping out my radio call

519
00:26:04,080 --> 00:26:07,590
sign in Morse code just to show that we

520
00:26:05,850 --> 00:26:09,810
can actually run code because one of the

521
00:26:07,590 --> 00:26:14,399
only output devices working mr. speaker

522
00:26:09,810 --> 00:26:16,639
at this point it takes a while and my

523
00:26:14,400 --> 00:26:18,990
laptop's crappy so it will reboot up for

524
00:26:16,640 --> 00:26:24,420
this so it will do it again

525
00:26:18,990 --> 00:26:26,610
and that'll continue booting so that

526
00:26:24,420 --> 00:26:29,640
pretty much proves out we're running

527
00:26:26,610 --> 00:26:33,830
code at the point that we should not be

528
00:26:29,640 --> 00:26:37,410
and we still have a functioning system

529
00:26:33,830 --> 00:26:39,600
so internal respondent I think within a

530
00:26:37,410 --> 00:26:42,030
working day and they said yeah yeah

531
00:26:39,600 --> 00:26:48,179
that's that's not supposed to be

532
00:26:42,030 --> 00:26:49,710
happening and we're going to fix it so

533
00:26:48,180 --> 00:26:54,810
they were really responsive and out and

534
00:26:49,710 --> 00:26:58,320
I do want to really point out and even

535
00:26:54,810 --> 00:27:00,780
for something as difficult to exploit as

536
00:26:58,320 --> 00:27:02,370
a harbor tech intel was very responsive

537
00:27:00,780 --> 00:27:04,730
and they immediately acknowledged that

538
00:27:02,370 --> 00:27:06,689
it was actually a security issue and

539
00:27:04,730 --> 00:27:11,340
they actually assigned a pretty high

540
00:27:06,690 --> 00:27:21,090
severity to it so yeah that was really

541
00:27:11,340 --> 00:27:25,620
nice workings and all that that's she so

542
00:27:21,090 --> 00:27:28,770
this still required modification of the

543
00:27:25,620 --> 00:27:30,719
hardware so to interrupt a chip select

544
00:27:28,770 --> 00:27:33,450
line which means that you need to be

545
00:27:30,720 --> 00:27:38,250
solving on your machine it's actually

546
00:27:33,450 --> 00:27:40,770
pretty small so yeah you'd need a lot

547
00:27:38,250 --> 00:27:42,750
more than than just somebody opening up

548
00:27:40,770 --> 00:27:47,730
a case plugging something in and leaving

549
00:27:42,750 --> 00:27:48,750
again so still not really practical this

550
00:27:47,730 --> 00:27:50,340
is actually what we were doing

551
00:27:48,750 --> 00:27:53,390
interrupting chip select and just

552
00:27:50,340 --> 00:27:56,850
wrenching the other ones out the FPGA

553
00:27:53,390 --> 00:27:59,310
but then we realize that most

554
00:27:56,850 --> 00:28:03,449
motherboards allow just connecting a

555
00:27:59,310 --> 00:28:05,520
programmer in parallel to the to the to

556
00:28:03,450 --> 00:28:08,460
the flash head without removing it and

557
00:28:05,520 --> 00:28:11,009
in order to prevent damaging the chipset

558
00:28:08,460 --> 00:28:16,999
having two drivers on the bus there's

559
00:28:11,009 --> 00:28:19,019
some serious resistors in there on

560
00:28:16,999 --> 00:28:23,850
amongst other things the chip select

561
00:28:19,019 --> 00:28:26,789
line which means that you don't actually

562
00:28:23,850 --> 00:28:29,639
need to interrupt it this will work just

563
00:28:26,789 --> 00:28:32,070
as well you've got a series resistor and

564
00:28:29,639 --> 00:28:35,758
now you can just use an input output pin

565
00:28:32,070 --> 00:28:38,928
on your FPGA and and drive it strong

566
00:28:35,759 --> 00:28:43,860
enough to pull it down and that way

567
00:28:38,929 --> 00:28:45,210
comes a lot more simple so all of a

568
00:28:43,860 --> 00:28:47,580
sudden you don't need to modify it

569
00:28:45,210 --> 00:28:51,539
anymore and because we move everything

570
00:28:47,580 --> 00:28:52,980
to the small cheap fpga board f word you

571
00:28:51,539 --> 00:28:54,990
also don't need a big expensive logic

572
00:28:52,980 --> 00:28:58,980
analyzer so this is actually a trammel

573
00:28:54,990 --> 00:29:01,950
setup and she could see it's just say so

574
00:28:58,980 --> 00:29:03,450
ik clip and a small dev board and there

575
00:29:01,950 --> 00:29:05,940
for debugging purposes there's this is

576
00:29:03,450 --> 00:29:07,860
this oscilloscope but this is I think

577
00:29:05,940 --> 00:29:11,909
what twenty thirty euros worth of

578
00:29:07,860 --> 00:29:14,729
hardware at most so sudden it's

579
00:29:11,909 --> 00:29:17,759
something that everyone can do that

580
00:29:14,730 --> 00:29:23,039
everyone can build you don't need a lab

581
00:29:17,759 --> 00:29:24,929
you don't need to solar anything so yeah

582
00:29:23,039 --> 00:29:32,190
becomes a lot more practical of an

583
00:29:24,929 --> 00:29:35,730
attack all of sudden so let's see and

584
00:29:32,190 --> 00:29:39,059
this isn't just restricted to Intel

585
00:29:35,730 --> 00:29:43,619
systems there's a lot of other devices

586
00:29:39,059 --> 00:29:46,139
which uses SPI flash so using its tool

587
00:29:43,619 --> 00:29:48,209
we just hook it up to any device and see

588
00:29:46,139 --> 00:29:52,529
whether it was doing repeated reads and

589
00:29:48,210 --> 00:29:54,539
try to attack those in fact travel looks

590
00:29:52,529 --> 00:29:57,240
at a board management controller before

591
00:29:54,539 --> 00:30:01,710
which he also discussed in his toe caps

592
00:29:57,240 --> 00:30:03,450
has Communication Congress this year to

593
00:30:01,710 --> 00:30:09,119
see if he could attack that in this way

594
00:30:03,450 --> 00:30:10,230
and that turns out to be possible it's

595
00:30:09,119 --> 00:30:12,799
also possible for a lot of different

596
00:30:10,230 --> 00:30:12,799
systems

597
00:30:12,870 --> 00:30:17,100
you can maybe see on here that there is

598
00:30:15,360 --> 00:30:19,229
this ROM chip sitting out on some kind

599
00:30:17,100 --> 00:30:24,570
of a breakout board this is actually a

600
00:30:19,230 --> 00:30:27,180
stock part of the hardware we were also

601
00:30:24,570 --> 00:30:29,189
able to come up with a design containing

602
00:30:27,180 --> 00:30:30,810
a FPGA and a ROM chip that's small

603
00:30:29,190 --> 00:30:32,580
enough to fit in this form factor to

604
00:30:30,810 --> 00:30:35,399
just be soldered in place of a normal

605
00:30:32,580 --> 00:30:37,080
sewing chips also it's not just so he

606
00:30:35,400 --> 00:30:39,180
will clip onto a motor board but that

607
00:30:37,080 --> 00:30:41,100
you could actually put in there and

608
00:30:39,180 --> 00:30:42,750
during production and have a system that

609
00:30:41,100 --> 00:30:46,260
looks normal that when you were on flash

610
00:30:42,750 --> 00:30:47,970
ROM it will seem fine if the right

611
00:30:46,260 --> 00:30:52,920
results but actually contains malicious

612
00:30:47,970 --> 00:30:54,690
code so it's also something that could

613
00:30:52,920 --> 00:31:00,060
potentially be used as part of a supply

614
00:30:54,690 --> 00:31:03,060
chain attack which is actually what

615
00:31:00,060 --> 00:31:05,970
Trammell Stoker CC was about where he

616
00:31:03,060 --> 00:31:08,330
discovered discussed the feasibility of

617
00:31:05,970 --> 00:31:10,650
what Bloomberg was claiming the whole

618
00:31:08,330 --> 00:31:16,439
small passive component being replaced

619
00:31:10,650 --> 00:31:20,730
by a by an implant actually discovered

620
00:31:16,440 --> 00:31:22,230
up to be not that realistic so now I'll

621
00:31:20,730 --> 00:31:23,460
hand this off to Trammell to discuss the

622
00:31:22,230 --> 00:31:27,180
medication said in those planning

623
00:31:23,460 --> 00:31:30,810
offenses thanks Peter

624
00:31:27,180 --> 00:31:34,020
so as Peter mentioned Intel responded

625
00:31:30,810 --> 00:31:38,210
very promptly to our vulnerability

626
00:31:34,020 --> 00:31:41,850
report it's been 125 days since then and

627
00:31:38,210 --> 00:31:46,950
they are working on getting patches into

628
00:31:41,850 --> 00:31:48,300
the OEM and IBV supply chain as I

629
00:31:46,950 --> 00:31:50,940
pointed out in a lot of my firmware

630
00:31:48,300 --> 00:31:52,470
talks one of the big problems is it

631
00:31:50,940 --> 00:31:55,470
takes a really long time for firmware

632
00:31:52,470 --> 00:31:59,610
patches to make it all the way out to

633
00:31:55,470 --> 00:32:01,860
the end user because typically Intel

634
00:31:59,610 --> 00:32:04,320
fixes it in their reference code the

635
00:32:01,860 --> 00:32:06,090
independent BIOS vendors pick up that

636
00:32:04,320 --> 00:32:08,730
patch and apply it to their eggs to

637
00:32:06,090 --> 00:32:11,600
their new systems and but they may not

638
00:32:08,730 --> 00:32:14,400
back port it to all of their old systems

639
00:32:11,600 --> 00:32:17,310
but it is really encouraging that Intel

640
00:32:14,400 --> 00:32:18,870
is taking these sorts of hardware

641
00:32:17,310 --> 00:32:22,600
vulnerabilities seriously they are

642
00:32:18,870 --> 00:32:26,469
creating high severity bugs for them

643
00:32:22,600 --> 00:32:28,689
and they are actively patching them the

644
00:32:26,470 --> 00:32:30,970
fix that they have proposed to this one

645
00:32:28,690 --> 00:32:33,850
is really quite comprehensive I'm really

646
00:32:30,970 --> 00:32:36,910
pleased with what they've proposed to do

647
00:32:33,850 --> 00:32:41,260
which is that they they are going to

648
00:32:36,910 --> 00:32:44,559
relocate the entire contents of the firm

649
00:32:41,260 --> 00:32:47,980
where volumes from the flash ROM into

650
00:32:44,559 --> 00:32:51,700
RAM and then they're going to fix up any

651
00:32:47,980 --> 00:32:54,760
addresses and relocate any any

652
00:32:51,700 --> 00:32:59,020
executables in that region then they're

653
00:32:54,760 --> 00:33:06,010
going to flag the the ROM regions as

654
00:32:59,020 --> 00:33:08,470
being as being know read know execute so

655
00:33:06,010 --> 00:33:11,890
that they can ensure that there are no

656
00:33:08,470 --> 00:33:14,260
talk towel attacks possible from the spy

657
00:33:11,890 --> 00:33:16,030
flash chip this is a really good way to

658
00:33:14,260 --> 00:33:19,090
deal with the entire class of attacks

659
00:33:16,030 --> 00:33:21,240
and I'm hoping that the all of the

660
00:33:19,090 --> 00:33:23,889
independent BIOS fenders and the OEMs

661
00:33:21,240 --> 00:33:26,380
pick up these patches from Intel and

662
00:33:23,890 --> 00:33:29,020
very quickly get them into their supply

663
00:33:26,380 --> 00:33:31,480
chain so that they can protect their

664
00:33:29,020 --> 00:33:35,918
their systems from these sorts of

665
00:33:31,480 --> 00:33:37,929
attacks the other way I think that we as

666
00:33:35,919 --> 00:33:40,240
a community need to be addressing a lot

667
00:33:37,929 --> 00:33:42,760
of these attacks is by moving to more

668
00:33:40,240 --> 00:33:45,010
open source firmware that we shouldn't

669
00:33:42,760 --> 00:33:47,919
have to be reverse engineering these

670
00:33:45,010 --> 00:33:51,129
things is that Jeffers l pointed out in

671
00:33:47,919 --> 00:33:54,280
her recent 44 con talk you know we need

672
00:33:51,130 --> 00:33:56,830
to be building firmware that we can

673
00:33:54,280 --> 00:33:58,629
inspect that we can audit that's

674
00:33:56,830 --> 00:34:01,570
reproducibly built that we can measure

675
00:33:58,630 --> 00:34:04,240
into trusted devices so that we as

676
00:34:01,570 --> 00:34:06,129
system owners can actually have some

677
00:34:04,240 --> 00:34:09,550
assurance that what is running on the

678
00:34:06,130 --> 00:34:12,700
machine is what we built and flashed on

679
00:34:09,550 --> 00:34:14,770
to it so the coreboot project the Linux

680
00:34:12,699 --> 00:34:18,850
group project and the heads project are

681
00:34:14,770 --> 00:34:20,889
three fairly mature projects that are

682
00:34:18,850 --> 00:34:25,480
addressed this and and just talks about

683
00:34:20,889 --> 00:34:27,490
them in her talk it's worth watching now

684
00:34:25,480 --> 00:34:31,600
Peter and I will also be releasing the

685
00:34:27,489 --> 00:34:35,439
Verilog code for our spy spy device that

686
00:34:31,600 --> 00:34:36,380
will allow other researchers to to

687
00:34:35,440 --> 00:34:38,450
accept

688
00:34:36,380 --> 00:34:40,400
with her own machines as Peter mentioned

689
00:34:38,449 --> 00:34:42,879
pretty much everything every machine

690
00:34:40,400 --> 00:34:45,170
we've looked at so far has had

691
00:34:42,880 --> 00:34:48,710
potentially exploitable talked I'll on

692
00:34:45,170 --> 00:34:51,080
the spy bus so having a you know a 10 or

693
00:34:48,710 --> 00:34:53,720
20 euro device to be able to investigate

694
00:34:51,080 --> 00:34:56,929
this will hopefully get the industry to

695
00:34:53,719 --> 00:35:01,009
move towards fixing these problems we're

696
00:34:56,929 --> 00:35:02,480
currently working with Intel on on the

697
00:35:01,010 --> 00:35:04,070
disclosure timeline for releasing the

698
00:35:02,480 --> 00:35:07,940
source code but hopefully that will be

699
00:35:04,070 --> 00:35:10,190
sometime then in the next month or so so

700
00:35:07,940 --> 00:35:11,810
with that we'd love to take any

701
00:35:10,190 --> 00:35:14,690
questions that you all might have about

702
00:35:11,810 --> 00:35:17,180
about boot guard about spy buses about

703
00:35:14,690 --> 00:35:19,160
talked ow but you know all of these sort

704
00:35:17,180 --> 00:35:21,799
of deep hardware security things and

705
00:35:19,160 --> 00:35:24,000
thank you all for coming out to listen

706
00:35:21,800 --> 00:35:27,380
to our talk

707
00:35:24,000 --> 00:35:27,630
[Applause]

708
00:35:27,380 --> 00:35:32,060
[Music]

709
00:35:27,630 --> 00:35:34,260
[Applause]

710
00:35:32,060 --> 00:35:40,100
yes thank you so much for your

711
00:35:34,260 --> 00:35:43,470
presentation are there any questions yes

712
00:35:40,100 --> 00:35:45,210
hi I have a question is it possible to

713
00:35:43,470 --> 00:35:49,620
use the same technique for example to

714
00:35:45,210 --> 00:35:54,240
hack into a hard drive firmware rather

715
00:35:49,620 --> 00:35:57,839
than room so most of the hard drives are

716
00:35:54,240 --> 00:36:03,209
running arm or risk 5 CPUs many of them

717
00:35:57,840 --> 00:36:06,240
have on on on-die boot flashes however a

718
00:36:03,210 --> 00:36:08,340
lot of the OEM code is not particularly

719
00:36:06,240 --> 00:36:11,879
high quality so I expect it would work

720
00:36:08,340 --> 00:36:14,760
for for many hard disks we've certainly

721
00:36:11,880 --> 00:36:18,180
seen it works against ARM based VMC's so

722
00:36:14,760 --> 00:36:25,110
I expect that we could extend it to many

723
00:36:18,180 --> 00:36:28,529
other arm devices hi thanks for the talk

724
00:36:25,110 --> 00:36:31,430
my question is from a systems owner

725
00:36:28,530 --> 00:36:34,830
perspective is there any way they can

726
00:36:31,430 --> 00:36:36,990
they can detect this at this moment is

727
00:36:34,830 --> 00:36:39,390
there are there any tools to see that

728
00:36:36,990 --> 00:36:45,359
malicious code has been loaded or how

729
00:36:39,390 --> 00:36:48,900
can they go about that well that's yes

730
00:36:45,360 --> 00:36:50,340
and no because in terms of this having

731
00:36:48,900 --> 00:36:52,920
happened to your system at the moment

732
00:36:50,340 --> 00:36:55,350
you can't see it from a software side

733
00:36:52,920 --> 00:36:59,460
because the code hides itself again

734
00:36:55,350 --> 00:37:01,529
after being run and if someone would

735
00:36:59,460 --> 00:37:03,570
have made the device that I described

736
00:37:01,530 --> 00:37:06,330
that would fit inside the footprint of

737
00:37:03,570 --> 00:37:08,580
one of these chips and having flashes as

738
00:37:06,330 --> 00:37:12,450
a chip and installed in your machine at

739
00:37:08,580 --> 00:37:14,190
some point I think nothing short of the

740
00:37:12,450 --> 00:37:18,480
next ray of the machine would really

741
00:37:14,190 --> 00:37:20,130
point that out but on the other hand you

742
00:37:18,480 --> 00:37:21,600
can at least detector system being

743
00:37:20,130 --> 00:37:24,960
vulnerable even if it's already being

744
00:37:21,600 --> 00:37:26,370
exploited by using this device and

745
00:37:24,960 --> 00:37:29,160
looking for your access patterns so you

746
00:37:26,370 --> 00:37:30,600
can just hook it up it'll throw some

747
00:37:29,160 --> 00:37:33,420
numbers at you free to serial port you

748
00:37:30,600 --> 00:37:35,460
plot those and then if there's a lot of

749
00:37:33,420 --> 00:37:37,660
red in there then there's a good chance

750
00:37:35,460 --> 00:37:42,170
that your system is vulnerable

751
00:37:37,660 --> 00:37:44,690
it's actually not simple and if anyone

752
00:37:42,170 --> 00:37:47,660
wants to get together afterwards and we

753
00:37:44,690 --> 00:37:51,320
can pop open your laptop and and give

754
00:37:47,660 --> 00:37:52,580
giving a in-person examination can't

755
00:37:51,320 --> 00:37:54,890
promise we won't leave anything else in

756
00:37:52,580 --> 00:38:19,670
there but you might have to trust us on

757
00:37:54,890 --> 00:38:20,990
that any other questions guys all right

758
00:38:19,670 --> 00:38:23,010
if that's it then

759
00:38:20,990 --> 00:38:27,368
thank you Trammell and Peter

760
00:38:23,010 --> 00:38:27,369
[Applause]

761
00:38:33,150 --> 00:38:35,210
you

