1
00:00:12,400 --> 00:00:14,960
hi everybody welcome to our session on

2
00:00:14,960 --> 00:00:17,359
automated zero-day discovery in 2021

3
00:00:17,359 --> 00:00:18,880
squashing the low-hanging fruit in

4
00:00:18,880 --> 00:00:21,119
widespread embedded software thanks for

5
00:00:21,119 --> 00:00:23,519
joining us i'm daniel desentis

6
00:00:23,519 --> 00:00:25,039
and today i will be presenting with

7
00:00:25,039 --> 00:00:27,680
shahar menashe

8
00:00:27,680 --> 00:00:29,439
right so who we are

9
00:00:29,439 --> 00:00:30,720
as i mentioned previously i'm dana

10
00:00:30,720 --> 00:00:32,320
desantis i'm a research manager at

11
00:00:32,320 --> 00:00:34,800
forescout i have a background mostly in

12
00:00:34,800 --> 00:00:37,280
academic computer security

13
00:00:37,280 --> 00:00:39,840
i've uh a phd in computer science i've

14
00:00:39,840 --> 00:00:41,920
done lots of academic publications in

15
00:00:41,920 --> 00:00:43,440
access control and intrusion detection

16
00:00:43,440 --> 00:00:45,600
and other things but recently i moved to

17
00:00:45,600 --> 00:00:47,360
industry and

18
00:00:47,360 --> 00:00:49,520
where i've done some uh security

19
00:00:49,520 --> 00:00:51,120
research vulnerability research threat

20
00:00:51,120 --> 00:00:54,000
research research and um i've been

21
00:00:54,000 --> 00:00:55,600
speaking at conferences such as black

22
00:00:55,600 --> 00:00:58,960
hat uh zif khan and others and i'm very

23
00:00:58,960 --> 00:01:01,039
happy to be uh talking for the first

24
00:01:01,039 --> 00:01:03,520
time at uh hack in the box and to

25
00:01:03,520 --> 00:01:05,040
present this work that we did in

26
00:01:05,040 --> 00:01:08,640
collaboration with jfrog where we

27
00:01:08,640 --> 00:01:10,159
applied uh

28
00:01:10,159 --> 00:01:12,240
both manual and automated vulnerability

29
00:01:12,240 --> 00:01:14,960
discovery techniques to uh an embedded

30
00:01:14,960 --> 00:01:16,880
tcp stack and found some interesting

31
00:01:16,880 --> 00:01:18,479
results and we'll be discussing those

32
00:01:18,479 --> 00:01:20,400
with you during this presentation but

33
00:01:20,400 --> 00:01:22,000
before that i would like to hand over to

34
00:01:22,000 --> 00:01:24,840
shahar to introduce himself hi my name

35
00:01:24,840 --> 00:01:26,720
is i'm the

36
00:01:26,720 --> 00:01:28,799
senior director of security research at

37
00:01:28,799 --> 00:01:30,640
jfrog

38
00:01:30,640 --> 00:01:32,640
which recently acquired vidu which was

39
00:01:32,640 --> 00:01:34,960
the previous company i worked at

40
00:01:34,960 --> 00:01:37,119
coming from a line of

41
00:01:37,119 --> 00:01:38,799
manual reverse engineering and

42
00:01:38,799 --> 00:01:40,400
exploitation automated reverse

43
00:01:40,400 --> 00:01:41,759
engineering

44
00:01:41,759 --> 00:01:44,479
hardware hacking things like that

45
00:01:44,479 --> 00:01:48,399
and basically the system we developed

46
00:01:48,399 --> 00:01:51,520
that's now running a jfrog the automated

47
00:01:51,520 --> 00:01:53,520
vulnerability and now system found some

48
00:01:53,520 --> 00:01:55,520
of these vulnerabilities

49
00:01:55,520 --> 00:01:58,000
while running on some

50
00:01:58,000 --> 00:01:59,920
firmware images

51
00:01:59,920 --> 00:02:02,159
and we wanted to share you know the

52
00:02:02,159 --> 00:02:04,799
vulnerabilities and how exactly we found

53
00:02:04,799 --> 00:02:05,600
them

54
00:02:05,600 --> 00:02:07,280
automatically

55
00:02:07,280 --> 00:02:09,360
and how you can achieve the same

56
00:02:09,360 --> 00:02:11,760
basically what's the state of automated

57
00:02:11,760 --> 00:02:13,920
vulnerability analysis uh

58
00:02:13,920 --> 00:02:16,560
in the modern era in 2021

59
00:02:16,560 --> 00:02:18,000
so before we move on i would just like

60
00:02:18,000 --> 00:02:20,720
to um thank our co-authors stanislav and

61
00:02:20,720 --> 00:02:22,400
yours at the forest outside and stuff

62
00:02:22,400 --> 00:02:24,319
and then is the j frog side because they

63
00:02:24,319 --> 00:02:26,480
also had a an important contribution to

64
00:02:26,480 --> 00:02:28,480
this research

65
00:02:28,480 --> 00:02:30,480
right so what will we be talking about

66
00:02:30,480 --> 00:02:32,080
today so first i'll present an

67
00:02:32,080 --> 00:02:33,760
introduction a background on this

68
00:02:33,760 --> 00:02:35,360
research what are the infrared

69
00:02:35,360 --> 00:02:36,879
vulnerabilities that served as the the

70
00:02:36,879 --> 00:02:39,120
motivation for this talk and a little

71
00:02:39,120 --> 00:02:41,040
bit about how uh those vulnerabilities

72
00:02:41,040 --> 00:02:42,480
were actually found

73
00:02:42,480 --> 00:02:45,120
to uh then pave the way for uh the

74
00:02:45,120 --> 00:02:46,959
automated vulnerability discovery uh

75
00:02:46,959 --> 00:02:48,319
which is the main part of this

76
00:02:48,319 --> 00:02:49,920
presentation that will be presented by

77
00:02:49,920 --> 00:02:51,040
shahar

78
00:02:51,040 --> 00:02:52,239
and then at the end we'll talk a little

79
00:02:52,239 --> 00:02:54,720
bit about mitigation for device vendors

80
00:02:54,720 --> 00:02:56,560
and network operators and then conclude

81
00:02:56,560 --> 00:02:58,159
this presentation with some discussion

82
00:02:58,159 --> 00:02:59,920
and takeaways

83
00:02:59,920 --> 00:03:02,560
right so let's start by discussing the

84
00:03:02,560 --> 00:03:04,800
embedded system supply chain right so

85
00:03:04,800 --> 00:03:07,200
when we talk about devices in internet

86
00:03:07,200 --> 00:03:08,879
of things or operational technology or

87
00:03:08,879 --> 00:03:11,280
any type of embedded system

88
00:03:11,280 --> 00:03:14,000
there is a long uh journey between the

89
00:03:14,000 --> 00:03:16,480
the concept of this device uh their

90
00:03:16,480 --> 00:03:18,319
development production utilization

91
00:03:18,319 --> 00:03:20,239
support and retirement and there are

92
00:03:20,239 --> 00:03:21,519
many

93
00:03:21,519 --> 00:03:23,280
companies and many actors involved in

94
00:03:23,280 --> 00:03:26,000
that right and that forms this uh supply

95
00:03:26,000 --> 00:03:28,959
chain for these uh different devices and

96
00:03:28,959 --> 00:03:31,040
in several places of the supply chain

97
00:03:31,040 --> 00:03:34,480
there might be uh issues that introduce

98
00:03:34,480 --> 00:03:37,040
vulnerabilities or or any or weaknesses

99
00:03:37,040 --> 00:03:39,440
or any other types of problems within

100
00:03:39,440 --> 00:03:41,599
devices that are used in a network

101
00:03:41,599 --> 00:03:43,200
if you talk at the development level

102
00:03:43,200 --> 00:03:44,400
there could be naturally occurring

103
00:03:44,400 --> 00:03:45,760
vulnerabilities if you talk at the

104
00:03:45,760 --> 00:03:47,360
production level there could be injected

105
00:03:47,360 --> 00:03:49,440
back doors uh during utilization there

106
00:03:49,440 --> 00:03:51,519
could be misconfiguration so on but we

107
00:03:51,519 --> 00:03:54,000
are mostly interestedly interested in

108
00:03:54,000 --> 00:03:55,280
the uh naturally occurring

109
00:03:55,280 --> 00:03:56,799
vulnerabilities part uh at the

110
00:03:56,799 --> 00:03:58,400
development especially in

111
00:03:58,400 --> 00:04:00,400
vulnerabilities that affect widespread

112
00:04:00,400 --> 00:04:03,280
components right that are used by many

113
00:04:03,280 --> 00:04:04,080
uh

114
00:04:04,080 --> 00:04:06,720
actors in the supply chain of many

115
00:04:06,720 --> 00:04:08,480
different devices

116
00:04:08,480 --> 00:04:10,560
and one of these interesting components

117
00:04:10,560 --> 00:04:12,400
is called the tcp stack right and we

118
00:04:12,400 --> 00:04:14,239
have a an image there on the on the

119
00:04:14,239 --> 00:04:17,199
right hand side illustrating um

120
00:04:17,199 --> 00:04:19,120
one of those tcpap stacks which is

121
00:04:19,120 --> 00:04:20,560
basically a software component that

122
00:04:20,560 --> 00:04:22,400
allows the uh

123
00:04:22,400 --> 00:04:24,800
basic and foundational um connectivity

124
00:04:24,800 --> 00:04:27,199
elements of uh of devices so basically

125
00:04:27,199 --> 00:04:30,320
it implements the tcp um and ip

126
00:04:30,320 --> 00:04:32,479
protocols and other uh protocols on top

127
00:04:32,479 --> 00:04:34,800
of those right and and also uh below in

128
00:04:34,800 --> 00:04:36,160
some cases

129
00:04:36,160 --> 00:04:39,520
and that usually gets coupled to uh

130
00:04:39,520 --> 00:04:42,320
rtos's uh real-time operating systems

131
00:04:42,320 --> 00:04:44,880
that are used in uh in about the devices

132
00:04:44,880 --> 00:04:47,280
and and other um

133
00:04:47,280 --> 00:04:48,960
other components

134
00:04:48,960 --> 00:04:51,199
of software components of of these

135
00:04:51,199 --> 00:04:53,440
devices right to form uh actually the

136
00:04:53,440 --> 00:04:56,479
the firmware of a device

137
00:04:56,479 --> 00:04:59,919
but why would anybody target a protocol

138
00:04:59,919 --> 00:05:01,600
stack right so the interesting part is

139
00:05:01,600 --> 00:05:03,520
that they are widely deployed so there

140
00:05:03,520 --> 00:05:04,639
are vulnerabilities that actually

141
00:05:04,639 --> 00:05:06,240
trickle down the supply chain to many

142
00:05:06,240 --> 00:05:09,120
vendors as we presented before

143
00:05:09,120 --> 00:05:12,720
these tcp stacks are often used by many

144
00:05:12,720 --> 00:05:14,080
different vendors to produce many

145
00:05:14,080 --> 00:05:16,960
different devices but the stack the code

146
00:05:16,960 --> 00:05:19,520
of the stack itself comes from one

147
00:05:19,520 --> 00:05:21,360
single vendor

148
00:05:21,360 --> 00:05:22,639
currently there's an absence of a

149
00:05:22,639 --> 00:05:24,720
software build of materials or which is

150
00:05:24,720 --> 00:05:28,080
uh typically called an s bomb so

151
00:05:28,080 --> 00:05:31,039
vendors and users are not really aware

152
00:05:31,039 --> 00:05:32,639
of all the software components that are

153
00:05:32,639 --> 00:05:34,720
on their devices and fixes in the core

154
00:05:34,720 --> 00:05:35,600
stack

155
00:05:35,600 --> 00:05:37,520
uh either take a long time or might

156
00:05:37,520 --> 00:05:40,880
never make it to all the uh oem firmware

157
00:05:40,880 --> 00:05:43,199
down the supply chain

158
00:05:43,199 --> 00:05:47,360
uh interestingly these stacks tend to be

159
00:05:47,360 --> 00:05:50,800
very ancient so 20 30 years old so

160
00:05:50,800 --> 00:05:52,000
there's a good chance of finding

161
00:05:52,000 --> 00:05:53,520
exploitable bugs right there there are

162
00:05:53,520 --> 00:05:56,240
not many um well security was not the

163
00:05:56,240 --> 00:05:58,000
top concern at the time

164
00:05:58,000 --> 00:06:00,560
when this uh this code was written and

165
00:06:00,560 --> 00:06:02,479
also in in most of this firmware and

166
00:06:02,479 --> 00:06:04,800
most of these devices there is no actual

167
00:06:04,800 --> 00:06:07,039
uh exploit mitigation

168
00:06:07,039 --> 00:06:08,319
going on

169
00:06:08,319 --> 00:06:10,240
so basically they are

170
00:06:10,240 --> 00:06:12,080
uh protocol stacks are components that

171
00:06:12,080 --> 00:06:14,160
are externally exposed they are often

172
00:06:14,160 --> 00:06:16,080
run as privileged and low level

173
00:06:16,080 --> 00:06:19,199
components that have a high chance of

174
00:06:19,199 --> 00:06:21,280
having bugs so

175
00:06:21,280 --> 00:06:22,960
if you combine dispatching issues the

176
00:06:22,960 --> 00:06:24,960
long life span spans the broad

177
00:06:24,960 --> 00:06:26,639
trickle-down issues

178
00:06:26,639 --> 00:06:29,120
you basically have vulnerabilities with

179
00:06:29,120 --> 00:06:31,680
a very high lifespan uh which means

180
00:06:31,680 --> 00:06:33,360
there's an interesting return of

181
00:06:33,360 --> 00:06:36,160
investment uh for an attacker

182
00:06:36,160 --> 00:06:37,680
to find and exploit these

183
00:06:37,680 --> 00:06:39,360
vulnerabilities

184
00:06:39,360 --> 00:06:41,120
if you look at previous work on tcpap

185
00:06:41,120 --> 00:06:43,840
stacks in the previous um three years

186
00:06:43,840 --> 00:06:46,720
more or less so from 2019 to 2021 there

187
00:06:46,720 --> 00:06:48,720
has been a lot of work done on tcp

188
00:06:48,720 --> 00:06:50,000
stacks right

189
00:06:50,000 --> 00:06:52,720
it started with urgent 11 uh which was a

190
00:06:52,720 --> 00:06:55,440
set of 11 cvs on the the ip net

191
00:06:55,440 --> 00:06:57,759
typically run on vxworks

192
00:06:57,759 --> 00:07:00,960
in 2020 there was ripple 20 uh which was

193
00:07:00,960 --> 00:07:03,120
a set of 19 cvs affecting the track to

194
00:07:03,120 --> 00:07:06,160
cpap stack and uh both of them had uh

195
00:07:06,160 --> 00:07:07,599
critical vulnerabilities allowing for

196
00:07:07,599 --> 00:07:09,039
rc's

197
00:07:09,039 --> 00:07:12,639
and then starting in 2020 um we at fort

198
00:07:12,639 --> 00:07:14,160
scout uh

199
00:07:14,160 --> 00:07:16,639
started doing project memorial which was

200
00:07:16,639 --> 00:07:19,599
a set of integrated studies into tcpap

201
00:07:19,599 --> 00:07:21,840
stack vulnerabilities that were focusing

202
00:07:21,840 --> 00:07:24,240
on different parts of of the stacks and

203
00:07:24,240 --> 00:07:26,319
different uh stacks all together right

204
00:07:26,319 --> 00:07:28,240
we started with amnesia 33 that was a

205
00:07:28,240 --> 00:07:31,120
set of 33 cvs looking at open source

206
00:07:31,120 --> 00:07:32,400
stacks which was uh something

207
00:07:32,400 --> 00:07:34,000
interesting at the time and basically

208
00:07:34,000 --> 00:07:36,000
the supply chain effects of open source

209
00:07:36,000 --> 00:07:38,800
not just closed source stacks

210
00:07:38,800 --> 00:07:41,520
then we came up with a number jack in

211
00:07:41,520 --> 00:07:44,319
the beginning of 2021 which was a set of

212
00:07:44,319 --> 00:07:46,800
um vulnerabilities related related to

213
00:07:46,800 --> 00:07:49,280
predictable tcp initial sequence numbers

214
00:07:49,280 --> 00:07:52,319
in nine different stacks open and closed

215
00:07:52,319 --> 00:07:54,400
then recently we had name rack which was

216
00:07:54,400 --> 00:07:56,319
a set of dns client vulnerabilities

217
00:07:56,319 --> 00:07:59,440
affecting four uh stacks and what we're

218
00:07:59,440 --> 00:08:01,440
going to discuss in this presentation uh

219
00:08:01,440 --> 00:08:03,120
is called infrahalt which is a new set

220
00:08:03,120 --> 00:08:05,840
of 14 cvs on one specific stack called

221
00:08:05,840 --> 00:08:08,319
uh internish

222
00:08:08,319 --> 00:08:10,960
right so what is infra halt

223
00:08:10,960 --> 00:08:13,360
so the target for this uh for this

224
00:08:13,360 --> 00:08:15,759
research was uh niche stack also known

225
00:08:15,759 --> 00:08:17,039
as internish

226
00:08:17,039 --> 00:08:20,000
which is a tcpap stack an embedded cpp

227
00:08:20,000 --> 00:08:22,639
stack developed by internish in the 90s

228
00:08:22,639 --> 00:08:24,720
and acquired by a company called hcc

229
00:08:24,720 --> 00:08:27,199
embedded in 2016. it's distributed in

230
00:08:27,199 --> 00:08:30,960
several favors such as ipv4 ipv6 a duo

231
00:08:30,960 --> 00:08:32,719
combination of both and the light

232
00:08:32,719 --> 00:08:33,760
version

233
00:08:33,760 --> 00:08:35,919
and it served as basis for other stacks

234
00:08:35,919 --> 00:08:37,760
right such as emnet so if you think

235
00:08:37,760 --> 00:08:39,599
again about the supply chain it's even

236
00:08:39,599 --> 00:08:41,839
stacked to stack in in a way so some

237
00:08:41,839 --> 00:08:43,679
some tcpap stacks are derived from

238
00:08:43,679 --> 00:08:45,600
others and then end up in operating

239
00:08:45,600 --> 00:08:47,360
systems that then end up in in different

240
00:08:47,360 --> 00:08:50,480
products um and even before starting

241
00:08:50,480 --> 00:08:52,080
this research we knew that this stack

242
00:08:52,080 --> 00:08:53,920
was popular in ot devices because

243
00:08:53,920 --> 00:08:56,080
previous research by others had shown

244
00:08:56,080 --> 00:08:58,320
that it was used in in several siemens

245
00:08:58,320 --> 00:09:00,160
plcs for instance

246
00:09:00,160 --> 00:09:02,080
the siemens found a

247
00:09:02,080 --> 00:09:04,240
a segments mac variant that affected

248
00:09:04,240 --> 00:09:06,240
several devices uh and that was called

249
00:09:06,240 --> 00:09:09,200
cv 2019 9300

250
00:09:09,200 --> 00:09:11,600
and then there was some work by aliya

251
00:09:11,600 --> 00:09:12,720
basi

252
00:09:12,720 --> 00:09:16,640
looking at the s7 plc's um and looking

253
00:09:16,640 --> 00:09:17,519
at

254
00:09:17,519 --> 00:09:21,360
actually the source code of um of

255
00:09:21,360 --> 00:09:22,480
internish

256
00:09:22,480 --> 00:09:24,800
that was found that was leaked online

257
00:09:24,800 --> 00:09:26,480
and they were able to actually compile

258
00:09:26,480 --> 00:09:28,240
compile the source code and have a look

259
00:09:28,240 --> 00:09:29,600
at it but they didn't

260
00:09:29,600 --> 00:09:31,120
find any specific vulnerabilities in

261
00:09:31,120 --> 00:09:33,680
that but it was the the start of this

262
00:09:33,680 --> 00:09:36,160
work let's say

263
00:09:36,160 --> 00:09:38,000
right so what vulnerabilities did we

264
00:09:38,000 --> 00:09:40,399
find then in each stack as i mentioned

265
00:09:40,399 --> 00:09:43,120
before it's a set of 14 cvs so two of

266
00:09:43,120 --> 00:09:45,279
them are are critical allowing for rcs

267
00:09:45,279 --> 00:09:47,200
and the rest is mostly related to the

268
00:09:47,200 --> 00:09:48,720
knives of service but there are also

269
00:09:48,720 --> 00:09:51,120
some uh related to dns cache poisoning

270
00:09:51,120 --> 00:09:53,360
will explain uh in the next slides how

271
00:09:53,360 --> 00:09:55,360
they are interesting but there are five

272
00:09:55,360 --> 00:09:59,120
components affected so dns http and tftp

273
00:09:59,120 --> 00:10:01,200
at the application layer and then icmp

274
00:10:01,200 --> 00:10:04,000
and tcp at the lower layers

275
00:10:04,000 --> 00:10:05,279
the interesting point is those

276
00:10:05,279 --> 00:10:07,360
vulnerabilities were found uh

277
00:10:07,360 --> 00:10:09,680
both manually and automatically right

278
00:10:09,680 --> 00:10:11,279
some of them only manually some only

279
00:10:11,279 --> 00:10:14,000
automatically and some uh

280
00:10:14,000 --> 00:10:16,000
in both ways

281
00:10:16,000 --> 00:10:18,399
so let's talk quickly about drc so the

282
00:10:18,399 --> 00:10:20,880
first rc affects the dns component and

283
00:10:20,880 --> 00:10:22,480
it was found manually based on an

284
00:10:22,480 --> 00:10:25,040
anti-pattern uh from a previous research

285
00:10:25,040 --> 00:10:27,040
uh that we had name rack so it's similar

286
00:10:27,040 --> 00:10:28,959
to to one of the cvs that we had found

287
00:10:28,959 --> 00:10:30,640
before on another tcpap stack called

288
00:10:30,640 --> 00:10:32,959
nucleus nat and the issue here is that

289
00:10:32,959 --> 00:10:34,480
basically um

290
00:10:34,480 --> 00:10:36,640
the resource record length on dns

291
00:10:36,640 --> 00:10:39,040
responses called rd length

292
00:10:39,040 --> 00:10:41,200
is not checked right for for for uh the

293
00:10:41,200 --> 00:10:42,560
size basically

294
00:10:42,560 --> 00:10:44,880
um so an attacker can specify an

295
00:10:44,880 --> 00:10:46,720
arbitrary value for this rd length and

296
00:10:46,720 --> 00:10:48,560
then overflow the next field on the on

297
00:10:48,560 --> 00:10:49,839
the

298
00:10:49,839 --> 00:10:51,360
the packet which is the

299
00:10:51,360 --> 00:10:53,680
dr data field

300
00:10:53,680 --> 00:10:55,360
so if you look at the examples of code

301
00:10:55,360 --> 00:10:57,360
there there is basically a man copy

302
00:10:57,360 --> 00:10:59,279
function that takes that rd length minus

303
00:10:59,279 --> 00:11:02,000
one and then writes that into the uh dns

304
00:11:02,000 --> 00:11:03,760
entry uh

305
00:11:03,760 --> 00:11:06,399
ptr name um buffer but if you look at

306
00:11:06,399 --> 00:11:09,200
that buffer it's actually uh

307
00:11:09,200 --> 00:11:11,279
of a fixed size right so you can see

308
00:11:11,279 --> 00:11:12,959
that in between those there is no there

309
00:11:12,959 --> 00:11:15,920
is no check for the size of rd length

310
00:11:15,920 --> 00:11:16,720
and

311
00:11:16,720 --> 00:11:18,560
uh this buffer is located on the heap

312
00:11:18,560 --> 00:11:21,440
and usually there is no uh exploit

313
00:11:21,440 --> 00:11:23,200
mitigations right which

314
00:11:23,200 --> 00:11:25,360
uh leads to the actual exploitation of

315
00:11:25,360 --> 00:11:27,279
this vulnerability which was achieved

316
00:11:27,279 --> 00:11:29,600
with a classical unlinked technique

317
00:11:29,600 --> 00:11:32,320
because there's no uh safe and linking

318
00:11:32,320 --> 00:11:35,120
so basically there's an example of a dns

319
00:11:35,120 --> 00:11:36,640
packet at the right hand side there

320
00:11:36,640 --> 00:11:38,880
where you have name type class ttl rd

321
00:11:38,880 --> 00:11:40,800
length and rd data

322
00:11:40,800 --> 00:11:43,600
and basically if you uh if an attacker

323
00:11:43,600 --> 00:11:45,600
uh uses the values that are shown in the

324
00:11:45,600 --> 00:11:48,800
figure there test.com and type class ttl

325
00:11:48,800 --> 00:11:50,320
and so on and then provides an

326
00:11:50,320 --> 00:11:53,920
arbitrarily large uh rd length value uh

327
00:11:53,920 --> 00:11:56,079
it can then provide shell code in the

328
00:11:56,079 --> 00:11:58,480
packet that will be uh overflowing the

329
00:11:58,480 --> 00:12:00,880
our data buffer

330
00:12:00,880 --> 00:12:02,000
and

331
00:12:02,000 --> 00:12:04,160
it's interesting because this is a dns

332
00:12:04,160 --> 00:12:06,800
response packet but it's easy to uh

333
00:12:06,800 --> 00:12:08,959
spoof dns records that will be accepted

334
00:12:08,959 --> 00:12:11,600
by a device because the

335
00:12:11,600 --> 00:12:13,279
the techniques that are usually used to

336
00:12:13,279 --> 00:12:15,279
synchronize dns requests and replies

337
00:12:15,279 --> 00:12:17,680
which are the source port udp source

338
00:12:17,680 --> 00:12:19,600
port and the transaction id are not

339
00:12:19,600 --> 00:12:22,160
actually random in this uh in this stack

340
00:12:22,160 --> 00:12:23,920
right which are the other uh two

341
00:12:23,920 --> 00:12:25,440
vulnerabilities that we mentioned at the

342
00:12:25,440 --> 00:12:26,560
beginning

343
00:12:26,560 --> 00:12:28,240
and which means that in the end

344
00:12:28,240 --> 00:12:30,320
responses from any ip address uh are

345
00:12:30,320 --> 00:12:31,920
accepted and and

346
00:12:31,920 --> 00:12:34,639
and will be processed by the stack um

347
00:12:34,639 --> 00:12:36,639
and the show code that we uh that we

348
00:12:36,639 --> 00:12:38,959
developed actually uses the stack api to

349
00:12:38,959 --> 00:12:41,600
perform tcp handshakes and send uh other

350
00:12:41,600 --> 00:12:43,519
malicious packets and we'll discuss a

351
00:12:43,519 --> 00:12:45,519
little bit uh further on an attack

352
00:12:45,519 --> 00:12:46,959
scenario but

353
00:12:46,959 --> 00:12:49,200
the actual exploitation using uh

354
00:12:49,200 --> 00:12:51,920
unlinking is is shown uh quickly on the

355
00:12:51,920 --> 00:12:55,040
on the lower bottom of the uh

356
00:12:55,040 --> 00:12:57,120
sorry the lower side of the

357
00:12:57,120 --> 00:12:59,040
at the bottom side of the low of the

358
00:12:59,040 --> 00:13:01,360
right hand uh figure there

359
00:13:01,360 --> 00:13:04,560
where uh you corrupt the metadata of the

360
00:13:04,560 --> 00:13:07,440
the top bin and then basically there is

361
00:13:07,440 --> 00:13:09,519
a fake free chunk that is created also

362
00:13:09,519 --> 00:13:12,560
in this dns entry structure so that when

363
00:13:12,560 --> 00:13:15,760
um when there is an extra location that

364
00:13:15,760 --> 00:13:18,639
um will go to this fake free chunk and

365
00:13:18,639 --> 00:13:20,959
then that can be used to hijack the

366
00:13:20,959 --> 00:13:22,639
control flow uh

367
00:13:22,639 --> 00:13:24,800
and basically execute the the desired

368
00:13:24,800 --> 00:13:27,040
charcoal there are more details uh on

369
00:13:27,040 --> 00:13:29,839
the white paper that we have released um

370
00:13:29,839 --> 00:13:32,000
together with this research

371
00:13:32,000 --> 00:13:32,800
uh

372
00:13:32,800 --> 00:13:35,920
on the infrahalt website on uh for scout

373
00:13:35,920 --> 00:13:39,199
but um that's basically a quick overview

374
00:13:39,199 --> 00:13:40,560
of it

375
00:13:40,560 --> 00:13:43,600
so the next rc is related to http and

376
00:13:43,600 --> 00:13:45,920
this one was found automatically and it

377
00:13:45,920 --> 00:13:47,920
occurs when actually

378
00:13:47,920 --> 00:13:51,600
the stack parses uh the hpv post

379
00:13:51,600 --> 00:13:53,279
request uri field which is uh

380
00:13:53,279 --> 00:13:55,360
highlighted in red over there so a

381
00:13:55,360 --> 00:13:57,519
request string of more than 52 bytes

382
00:13:57,519 --> 00:13:59,600
causes a hipaa for overflow and then the

383
00:13:59,600 --> 00:14:02,639
rc can be achieved similarly to the

384
00:14:02,639 --> 00:14:04,240
previous one but

385
00:14:04,240 --> 00:14:07,760
it may require more careful heap shaping

386
00:14:07,760 --> 00:14:10,000
but the details on on how this one were

387
00:14:10,000 --> 00:14:12,720
found uh will be will be discussed later

388
00:14:12,720 --> 00:14:15,760
on by shahar in the uh section on uh

389
00:14:15,760 --> 00:14:17,440
automated vulnerability finding i just

390
00:14:17,440 --> 00:14:19,440
wanted to discuss a bit the the attack

391
00:14:19,440 --> 00:14:22,079
scenario uh enabled by this type of

392
00:14:22,079 --> 00:14:24,639
vulnerability right where if you have

393
00:14:24,639 --> 00:14:26,880
devices that are externally exposed and

394
00:14:26,880 --> 00:14:28,880
vulnerable to to infrahalt and then you

395
00:14:28,880 --> 00:14:31,680
have internal devices uh that may also

396
00:14:31,680 --> 00:14:33,519
be vulnerable to to to other things and

397
00:14:33,519 --> 00:14:36,560
that are controlling um critical uh

398
00:14:36,560 --> 00:14:38,720
operational technology processes such as

399
00:14:38,720 --> 00:14:40,079
uh heating ventilation and air

400
00:14:40,079 --> 00:14:42,639
conditioning and in a smart building uh

401
00:14:42,639 --> 00:14:46,160
in uh in a data center or in any place

402
00:14:46,160 --> 00:14:47,760
that needs uh temperature control for

403
00:14:47,760 --> 00:14:49,360
instance

404
00:14:49,360 --> 00:14:52,480
when that uh device that is uh exposed

405
00:14:52,480 --> 00:14:54,800
issues a dns request an attacker can

406
00:14:54,800 --> 00:14:57,360
spoof then a dns response with the shell

407
00:14:57,360 --> 00:15:00,399
code that instructs this device to

408
00:15:00,399 --> 00:15:02,720
create a connection with the uh with the

409
00:15:02,720 --> 00:15:04,160
internal device and send a malicious

410
00:15:04,160 --> 00:15:07,199
packet and then basically either again

411
00:15:07,199 --> 00:15:10,160
use an rc on this one or just a dos and

412
00:15:10,160 --> 00:15:12,079
then crash that so that the physical

413
00:15:12,079 --> 00:15:14,800
process is then uh disrupted right so

414
00:15:14,800 --> 00:15:16,639
this is the type of scenario that is

415
00:15:16,639 --> 00:15:17,920
enabled by

416
00:15:17,920 --> 00:15:18,800
um

417
00:15:18,800 --> 00:15:21,360
widespread vulnerabilities uh in

418
00:15:21,360 --> 00:15:23,120
embedded systems that affect different

419
00:15:23,120 --> 00:15:25,839
types of uh of devices and that are

420
00:15:25,839 --> 00:15:27,760
externally exposed and we also have a

421
00:15:27,760 --> 00:15:29,199
video of the exploitation that you can

422
00:15:29,199 --> 00:15:31,600
have a look there on youtube

423
00:15:31,600 --> 00:15:33,279
that has more details

424
00:15:33,279 --> 00:15:34,880
right but let's talk about the supply

425
00:15:34,880 --> 00:15:37,360
chain impact that we started uh as a

426
00:15:37,360 --> 00:15:39,040
motivation right so if you look at the

427
00:15:39,040 --> 00:15:40,959
niche stack uh offerings that we

428
00:15:40,959 --> 00:15:42,480
mentioned in the beginning those are

429
00:15:42,480 --> 00:15:44,240
distributed and were distributed over

430
00:15:44,240 --> 00:15:46,320
these 20 years via many uh different

431
00:15:46,320 --> 00:15:48,560
companies and ended up in many ways in

432
00:15:48,560 --> 00:15:50,399
many products from any vendors so those

433
00:15:50,399 --> 00:15:52,240
logos that you see at the end there they

434
00:15:52,240 --> 00:15:55,040
actually come from the uh old and now

435
00:15:55,040 --> 00:15:57,600
archived internish website that

436
00:15:57,600 --> 00:15:59,600
mentioned uh their customers and we're

437
00:15:59,600 --> 00:16:00,959
not saying that all of those figures

438
00:16:00,959 --> 00:16:03,680
that appear there uh are vulnerable but

439
00:16:03,680 --> 00:16:05,519
some of them uh have already confirmed

440
00:16:05,519 --> 00:16:07,279
that they are vulnerable and others are

441
00:16:07,279 --> 00:16:09,440
still investigating and so on but the

442
00:16:09,440 --> 00:16:13,680
issue is definitely um widespread

443
00:16:13,680 --> 00:16:15,600
so how did we actually find these

444
00:16:15,600 --> 00:16:17,680
vulnerabilities right so we had two

445
00:16:17,680 --> 00:16:19,759
types of input we had the leaked source

446
00:16:19,759 --> 00:16:22,560
code of a previous version called 3.1

447
00:16:22,560 --> 00:16:23,759
that we mentioned

448
00:16:23,759 --> 00:16:24,560
uh

449
00:16:24,560 --> 00:16:26,880
was used in previous research by ali

450
00:16:26,880 --> 00:16:28,399
abbasi and others

451
00:16:28,399 --> 00:16:31,120
and we had a binary demo of a more

452
00:16:31,120 --> 00:16:32,880
recent version that was uh previously

453
00:16:32,880 --> 00:16:34,480
available on the vendor's website it was

454
00:16:34,480 --> 00:16:36,240
took down now but it was uh publicly

455
00:16:36,240 --> 00:16:38,320
available at the time of this research

456
00:16:38,320 --> 00:16:40,000
and we started with the manual analysis

457
00:16:40,000 --> 00:16:41,199
that was based on the known

458
00:16:41,199 --> 00:16:43,440
anti-patterns from the previous research

459
00:16:43,440 --> 00:16:45,519
right amnesia 33 we looked at integer

460
00:16:45,519 --> 00:16:47,440
overflows lack of bounce checks and so

461
00:16:47,440 --> 00:16:50,880
on number jack we looked at the weak uh

462
00:16:50,880 --> 00:16:53,199
tcp is n and in name rack we looked at

463
00:16:53,199 --> 00:16:55,360
dns compression and several other types

464
00:16:55,360 --> 00:16:56,639
of uh

465
00:16:56,639 --> 00:16:59,360
of uh anti-patterns and basically all of

466
00:16:59,360 --> 00:17:01,360
those were found uh in this new stack

467
00:17:01,360 --> 00:17:03,360
and found uh manually

468
00:17:03,360 --> 00:17:06,640
uh we did not analyze uh ipv6 which is

469
00:17:06,640 --> 00:17:08,640
also an anti-pattern that we had

470
00:17:08,640 --> 00:17:10,079
previously seen

471
00:17:10,079 --> 00:17:12,799
uh and this was a great result but it

472
00:17:12,799 --> 00:17:15,679
was lots of work and potentially missed

473
00:17:15,679 --> 00:17:18,959
issues right which is what motivated uh

474
00:17:18,959 --> 00:17:20,640
the vulnerability automated

475
00:17:20,640 --> 00:17:22,799
vulnerability discovery part that will

476
00:17:22,799 --> 00:17:24,799
now be presented by sean

477
00:17:24,799 --> 00:17:27,760
okay so now let's talk about the

478
00:17:27,760 --> 00:17:30,640
automated vulnerability discovery part

479
00:17:30,640 --> 00:17:33,520
um basically how our system

480
00:17:33,520 --> 00:17:34,720
was able to find some of these

481
00:17:34,720 --> 00:17:38,000
vulnerabilities uh what are our methods

482
00:17:38,000 --> 00:17:40,080
that we suggest on

483
00:17:40,080 --> 00:17:42,000
at least from our side how to

484
00:17:42,000 --> 00:17:44,240
automate vulnerability discovery

485
00:17:44,240 --> 00:17:46,480
and what technologies are available

486
00:17:46,480 --> 00:17:48,960
today uh for automated vulnerability

487
00:17:48,960 --> 00:17:50,400
discovery

488
00:17:50,400 --> 00:17:53,039
and specifically how we

489
00:17:53,039 --> 00:17:56,080
will delve into how we found one of the

490
00:17:56,080 --> 00:17:57,760
vulnerabilities in

491
00:17:57,760 --> 00:18:00,320
an automated manner how the system found

492
00:18:00,320 --> 00:18:02,480
it

493
00:18:04,080 --> 00:18:06,559
so first of all our method of operation

494
00:18:06,559 --> 00:18:07,919
of the system

495
00:18:07,919 --> 00:18:10,720
uh is going to be as follows the system

496
00:18:10,720 --> 00:18:13,280
is going to map

497
00:18:13,280 --> 00:18:15,600
sources that's user input sources so

498
00:18:15,600 --> 00:18:17,280
basically these are

499
00:18:17,280 --> 00:18:19,840
variables and function calls um that the

500
00:18:19,840 --> 00:18:20,880
system

501
00:18:20,880 --> 00:18:22,880
believes that are coming from user input

502
00:18:22,880 --> 00:18:25,280
or external input

503
00:18:25,280 --> 00:18:27,520
the second step is going to be mapping

504
00:18:27,520 --> 00:18:29,520
dangerous sinks

505
00:18:29,520 --> 00:18:32,240
that's what we call the the leaf or the

506
00:18:32,240 --> 00:18:35,360
end of the flow a sync function

507
00:18:35,360 --> 00:18:37,760
so this will be a dangerous function or

508
00:18:37,760 --> 00:18:40,160
method or something that basically when

509
00:18:40,160 --> 00:18:42,480
it gets user input you know there's an

510
00:18:42,480 --> 00:18:44,799
exploit going to happen so for example

511
00:18:44,799 --> 00:18:45,520
for

512
00:18:45,520 --> 00:18:46,880
command injection it's going to be

513
00:18:46,880 --> 00:18:49,280
system or p open for

514
00:18:49,280 --> 00:18:51,360
uh buffer overflow type vulnerability is

515
00:18:51,360 --> 00:18:55,360
going to be sdrcpy or memcpy

516
00:18:55,360 --> 00:18:57,039
things like that

517
00:18:57,039 --> 00:18:59,120
so basically these are the dangerous

518
00:18:59,120 --> 00:19:01,440
functions these are the sinks and the

519
00:19:01,440 --> 00:19:03,919
third step is going to be to find an

520
00:19:03,919 --> 00:19:06,640
unfiltered data flow between one of the

521
00:19:06,640 --> 00:19:08,799
sources and one of the things

522
00:19:08,799 --> 00:19:10,960
so we will touch upon what it actually

523
00:19:10,960 --> 00:19:14,559
means unfiltered but basically uh

524
00:19:14,559 --> 00:19:16,559
it means that

525
00:19:16,559 --> 00:19:19,440
nobody is filtering out

526
00:19:19,440 --> 00:19:22,640
bad user inputs or malicious

527
00:19:22,640 --> 00:19:25,760
malicious user inputs uh and

528
00:19:25,760 --> 00:19:27,520
the term malicious really depends on

529
00:19:27,520 --> 00:19:29,679
what kind of vulnerability it is uh

530
00:19:29,679 --> 00:19:32,080
malicious uh in terms of buffer overflow

531
00:19:32,080 --> 00:19:34,080
isn't going to be the same in integrable

532
00:19:34,080 --> 00:19:36,160
flow or command injection so we'll

533
00:19:36,160 --> 00:19:37,679
actually

534
00:19:37,679 --> 00:19:38,960
go on that

535
00:19:38,960 --> 00:19:40,480
so for example you can see in this

536
00:19:40,480 --> 00:19:41,679
diagram

537
00:19:41,679 --> 00:19:44,880
uh here we show a source that is get in

538
00:19:44,880 --> 00:19:45,919
which

539
00:19:45,919 --> 00:19:47,520
for our internship

540
00:19:47,520 --> 00:19:48,880
purposes we

541
00:19:48,880 --> 00:19:51,280
consider that as user input because it's

542
00:19:51,280 --> 00:19:53,679
untrusted

543
00:19:53,679 --> 00:19:55,520
usually

544
00:19:55,520 --> 00:19:58,559
so the source uh reads some

545
00:19:58,559 --> 00:20:00,480
data into a variable and then there's a

546
00:20:00,480 --> 00:20:01,840
data flow

547
00:20:01,840 --> 00:20:02,559
uh

548
00:20:02,559 --> 00:20:05,120
from uh the get ad

549
00:20:05,120 --> 00:20:07,280
through some functions basic blocks etc

550
00:20:07,280 --> 00:20:10,559
and it gets to the system sync

551
00:20:10,559 --> 00:20:12,080
so in this case it would be a command

552
00:20:12,080 --> 00:20:13,919
injection vulnerability

553
00:20:13,919 --> 00:20:16,640
um so this is the

554
00:20:16,640 --> 00:20:18,159
the high level

555
00:20:18,159 --> 00:20:19,919
operation of the system and this is what

556
00:20:19,919 --> 00:20:21,600
we're going to discuss and

557
00:20:21,600 --> 00:20:23,919
each part obviously has uh

558
00:20:23,919 --> 00:20:25,679
we can delve into each part uh

559
00:20:25,679 --> 00:20:27,760
individually

560
00:20:27,760 --> 00:20:30,159
so let's start uh from the beginning

561
00:20:30,159 --> 00:20:32,320
chronologically um

562
00:20:32,320 --> 00:20:34,640
and the first step that we do is to

563
00:20:34,640 --> 00:20:36,480
convert the

564
00:20:36,480 --> 00:20:39,360
uh asm the raw assembly into a high

565
00:20:39,360 --> 00:20:41,360
level intermediate representation fairly

566
00:20:41,360 --> 00:20:43,679
high level it's not source code but it's

567
00:20:43,679 --> 00:20:45,120
fairly high level

568
00:20:45,120 --> 00:20:47,440
um so for example here

569
00:20:47,440 --> 00:20:49,200
on the upper right corner you can see

570
00:20:49,200 --> 00:20:50,720
the original source

571
00:20:50,720 --> 00:20:52,559
so uh we don't have the source because

572
00:20:52,559 --> 00:20:54,799
we have a binary but let's say that the

573
00:20:54,799 --> 00:20:56,559
binary was compiled from this source so

574
00:20:56,559 --> 00:20:59,520
it's called it calls memset with some

575
00:20:59,520 --> 00:21:02,400
constants and

576
00:21:02,400 --> 00:21:04,880
referenced the variable

577
00:21:04,880 --> 00:21:05,760
it

578
00:21:05,760 --> 00:21:07,360
writes two null pointers and then it

579
00:21:07,360 --> 00:21:11,280
calls another function basically uh with

580
00:21:11,280 --> 00:21:14,240
a different uh with one of the variables

581
00:21:14,240 --> 00:21:16,640
that was uh numbed

582
00:21:16,640 --> 00:21:19,120
so uh if we look uh

583
00:21:19,120 --> 00:21:20,799
at the assembly level

584
00:21:20,799 --> 00:21:22,960
the disassembly which is you know what

585
00:21:22,960 --> 00:21:27,679
object gives us or uh ida or guidra uh

586
00:21:27,679 --> 00:21:31,039
in the basic listing view um we can see

587
00:21:31,039 --> 00:21:33,520
good old familiar assembly uh in this

588
00:21:33,520 --> 00:21:35,679
case it's arm assembly

589
00:21:35,679 --> 00:21:38,480
um and of course this is a bit harder to

590
00:21:38,480 --> 00:21:39,760
discern

591
00:21:39,760 --> 00:21:42,240
even as a manual researcher

592
00:21:42,240 --> 00:21:43,520
and that's why we have tools like the

593
00:21:43,520 --> 00:21:45,919
the compiler and things like that uh but

594
00:21:45,919 --> 00:21:48,480
especially when you're uh using

595
00:21:48,480 --> 00:21:50,400
automated analysis

596
00:21:50,400 --> 00:21:51,760
um

597
00:21:51,760 --> 00:21:52,799
it become

598
00:21:52,799 --> 00:21:54,559
you have to convert it to a higher level

599
00:21:54,559 --> 00:21:55,919
anyways you need to understand the

600
00:21:55,919 --> 00:21:58,320
function calls the arguments etc so

601
00:21:58,320 --> 00:22:00,400
either you do it yourself by writing

602
00:22:00,400 --> 00:22:02,240
your own engine or you use something

603
00:22:02,240 --> 00:22:03,520
like guidra's

604
00:22:03,520 --> 00:22:04,720
p code

605
00:22:04,720 --> 00:22:05,840
analysis

606
00:22:05,840 --> 00:22:09,120
basically when you decompile a function

607
00:22:09,120 --> 00:22:11,280
with gidra

608
00:22:11,280 --> 00:22:12,400
um it

609
00:22:12,400 --> 00:22:14,320
converts the assembly language into high

610
00:22:14,320 --> 00:22:16,559
level p codes

611
00:22:16,559 --> 00:22:18,080
and there are all sorts of p codes here

612
00:22:18,080 --> 00:22:21,520
i'm showing uh disassembly converted

613
00:22:21,520 --> 00:22:24,159
uh to p code operations you can see it's

614
00:22:24,159 --> 00:22:26,799
a six p code operations which is much

615
00:22:26,799 --> 00:22:29,919
better than this whole mess of assembly

616
00:22:29,919 --> 00:22:33,200
um and basically the first uh field here

617
00:22:33,200 --> 00:22:36,159
is the output the second is the picot

618
00:22:36,159 --> 00:22:37,679
type the third

619
00:22:37,679 --> 00:22:40,799
and the third and so on are the inputs

620
00:22:40,799 --> 00:22:44,000
so for example um in order to uh create

621
00:22:44,000 --> 00:22:46,320
a variable or reference a variable uh

622
00:22:46,320 --> 00:22:48,960
there's the ptr sub p code

623
00:22:48,960 --> 00:22:51,200
and this uh causes the reference that we

624
00:22:51,200 --> 00:22:52,240
see here

625
00:22:52,240 --> 00:22:55,799
it takes uh this is the address of uh

626
00:22:55,799 --> 00:22:59,280
rcvdq for example um the the second

627
00:22:59,280 --> 00:23:00,240
input

628
00:23:00,240 --> 00:23:02,480
uh and this is a possible offset but in

629
00:23:02,480 --> 00:23:04,640
this case it's offset zero

630
00:23:04,640 --> 00:23:07,200
and then it creates a

631
00:23:07,200 --> 00:23:11,360
temporary variable um that has this name

632
00:23:11,360 --> 00:23:14,480
um or one zero zero zero zero zero four

633
00:23:14,480 --> 00:23:17,039
c and you can see this variable is then

634
00:23:17,039 --> 00:23:18,799
uh in the second p code which is a call

635
00:23:18,799 --> 00:23:22,400
p code here it's calling mem set so

636
00:23:22,400 --> 00:23:23,200
here

637
00:23:23,200 --> 00:23:25,919
guidra did the work for us and collected

638
00:23:25,919 --> 00:23:29,840
all the arguments for this call

639
00:23:30,000 --> 00:23:32,320
so it calls mem said and then all the

640
00:23:32,320 --> 00:23:34,480
other inputs

641
00:23:34,480 --> 00:23:36,080
are the arguments so you can see the

642
00:23:36,080 --> 00:23:38,080
first argument is this uh temporary

643
00:23:38,080 --> 00:23:40,240
variable that was created

644
00:23:40,240 --> 00:23:43,039
uh so it's uh rcvdq

645
00:23:43,039 --> 00:23:44,720
uh and then the second and third

646
00:23:44,720 --> 00:23:47,840
arguments are uh constants uh

647
00:23:47,840 --> 00:23:49,039
so

648
00:23:49,039 --> 00:23:51,120
it's very easy to discern

649
00:23:51,120 --> 00:23:52,880
here for example if we look at assembly

650
00:23:52,880 --> 00:23:54,320
level then

651
00:23:54,320 --> 00:23:55,440
first of all

652
00:23:55,440 --> 00:23:57,679
because it's a

653
00:23:57,679 --> 00:24:00,240
risk architecture then

654
00:24:00,240 --> 00:24:02,960
you can't put the whole 32-bit

655
00:24:02,960 --> 00:24:06,480
in one op code so it splits the address

656
00:24:06,480 --> 00:24:09,039
of rcbdq to two op codes

657
00:24:09,039 --> 00:24:10,960
uh and you know the

658
00:24:10,960 --> 00:24:14,480
the moves to uh the registers uh

659
00:24:14,480 --> 00:24:17,360
before the function call can uh

660
00:24:17,360 --> 00:24:18,799
uh can of course

661
00:24:18,799 --> 00:24:20,320
uh

662
00:24:20,320 --> 00:24:21,520
uh be

663
00:24:21,520 --> 00:24:24,400
not very much adjacent to the

664
00:24:24,400 --> 00:24:26,080
uh the branch

665
00:24:26,080 --> 00:24:28,080
uh so these are all things that gidra

666
00:24:28,080 --> 00:24:29,279
takes care of

667
00:24:29,279 --> 00:24:31,279
uh for us so here we can see copy

668
00:24:31,279 --> 00:24:34,720
operations we're copying uh two global

669
00:24:34,720 --> 00:24:37,200
variables so this is what uh these

670
00:24:37,200 --> 00:24:39,600
operations are doing

671
00:24:39,600 --> 00:24:41,840
um so uh we can see it's global

672
00:24:41,840 --> 00:24:43,760
variables because it's actually copying

673
00:24:43,760 --> 00:24:47,120
directly to uh to memory

674
00:24:47,120 --> 00:24:49,120
and constant zero

675
00:24:49,120 --> 00:24:51,360
and in the last call we also see another

676
00:24:51,360 --> 00:24:52,559
function call

677
00:24:52,559 --> 00:24:57,039
with another referenced variable

678
00:24:57,760 --> 00:24:59,600
yeah

679
00:24:59,600 --> 00:25:00,559
so

680
00:25:00,559 --> 00:25:03,600
this uh just makes uh analysis much

681
00:25:03,600 --> 00:25:05,760
easier and basically our code

682
00:25:05,760 --> 00:25:08,880
uh takes the p code as input instead of

683
00:25:08,880 --> 00:25:11,600
the the assembly um and this is also

684
00:25:11,600 --> 00:25:15,200
great for cross architecture because

685
00:25:15,200 --> 00:25:16,799
basically it doesn't matter if the

686
00:25:16,799 --> 00:25:18,960
original assembly was

687
00:25:18,960 --> 00:25:21,360
intel x86 or arm

688
00:25:21,360 --> 00:25:23,120
or mips or

689
00:25:23,120 --> 00:25:26,559
power pc we get the same p code

690
00:25:26,559 --> 00:25:29,279
so we can just focus on the high level

691
00:25:29,279 --> 00:25:32,480
intermediate representation

692
00:25:32,799 --> 00:25:34,799
so the second part would be mapping the

693
00:25:34,799 --> 00:25:37,039
user input sources um this is a bit

694
00:25:37,039 --> 00:25:38,960
harder than mapping the syncs which

695
00:25:38,960 --> 00:25:40,640
we'll get to

696
00:25:40,640 --> 00:25:43,200
basically so we need to hypothesize on

697
00:25:43,200 --> 00:25:45,760
where user input is uh getting into the

698
00:25:45,760 --> 00:25:47,360
program

699
00:25:47,360 --> 00:25:49,440
um so for example

700
00:25:49,440 --> 00:25:51,279
uh there's a lot there's some high

701
00:25:51,279 --> 00:25:53,200
accuracy sources so for example if we

702
00:25:53,200 --> 00:25:55,600
see a cisco like if we have the cisco

703
00:25:55,600 --> 00:25:56,559
names

704
00:25:56,559 --> 00:25:59,679
um or if we get them through uh

705
00:25:59,679 --> 00:26:01,840
divination that we'll see in a while

706
00:26:01,840 --> 00:26:03,760
uh so if we have those names like

707
00:26:03,760 --> 00:26:06,320
receive then we know that

708
00:26:06,320 --> 00:26:09,919
the second uh argument of receive

709
00:26:09,919 --> 00:26:10,799
is a

710
00:26:10,799 --> 00:26:12,960
output buffer that gets data from the

711
00:26:12,960 --> 00:26:14,880
network so we can immediately say okay

712
00:26:14,880 --> 00:26:17,840
this is an user input source because

713
00:26:17,840 --> 00:26:21,279
we record network data as user input

714
00:26:21,279 --> 00:26:23,440
the same thing with getend

715
00:26:23,440 --> 00:26:25,760
and the same thing with efrid although

716
00:26:25,760 --> 00:26:27,440
these were regarded as local input

717
00:26:27,440 --> 00:26:28,400
sources

718
00:26:28,400 --> 00:26:30,799
uh it's reading from a file or the local

719
00:26:30,799 --> 00:26:32,960
environment it might come from

720
00:26:32,960 --> 00:26:34,799
a remote source but we

721
00:26:34,799 --> 00:26:36,960
can't guarantee that so we regard them

722
00:26:36,960 --> 00:26:39,200
as local sources

723
00:26:39,200 --> 00:26:40,799
also for example

724
00:26:40,799 --> 00:26:42,400
uh this is

725
00:26:42,400 --> 00:26:44,640
much more geared toward embedded devices

726
00:26:44,640 --> 00:26:47,679
if you're reading from a well-known mmio

727
00:26:47,679 --> 00:26:49,679
memory map tile

728
00:26:49,679 --> 00:26:51,679
address

729
00:26:51,679 --> 00:26:52,799
for example

730
00:26:52,799 --> 00:26:55,360
a specific address might be mapped to

731
00:26:55,360 --> 00:26:58,880
uart or bluetooth etc and then you also

732
00:26:58,880 --> 00:27:00,799
know okay this is

733
00:27:00,799 --> 00:27:02,240
reading from that address is actually

734
00:27:02,240 --> 00:27:03,600
user input

735
00:27:03,600 --> 00:27:05,840
uh there's a very cool gydra plugin

736
00:27:05,840 --> 00:27:08,080
called svd loader which i highly

737
00:27:08,080 --> 00:27:09,279
recommend

738
00:27:09,279 --> 00:27:11,600
uh if which you can give the the board

739
00:27:11,600 --> 00:27:13,919
name and it maps out

740
00:27:13,919 --> 00:27:15,520
um

741
00:27:15,520 --> 00:27:18,080
using public data it maps out uh

742
00:27:18,080 --> 00:27:20,159
the the address calls to the actual

743
00:27:20,159 --> 00:27:21,919
peripherals

744
00:27:21,919 --> 00:27:24,240
uh so that's really useful

745
00:27:24,240 --> 00:27:25,679
um and

746
00:27:25,679 --> 00:27:27,520
uh other than the high accuracy sources

747
00:27:27,520 --> 00:27:29,520
we also have score based sources which

748
00:27:29,520 --> 00:27:32,480
uh we try to accumulate a couple of

749
00:27:32,480 --> 00:27:34,880
these uh before we say okay this is

750
00:27:34,880 --> 00:27:36,720
probably user input

751
00:27:36,720 --> 00:27:39,440
so for example um something that we use

752
00:27:39,440 --> 00:27:42,720
a lot uh is uh n2hs and n2hl

753
00:27:42,720 --> 00:27:45,360
uh network to host short or net network

754
00:27:45,360 --> 00:27:46,720
tools log

755
00:27:46,720 --> 00:27:48,720
so these operations usually indicate

756
00:27:48,720 --> 00:27:49,919
that

757
00:27:49,919 --> 00:27:52,799
there's a input coming from the network

758
00:27:52,799 --> 00:27:54,000
and uh

759
00:27:54,000 --> 00:27:56,720
the program wants to convert them

760
00:27:56,720 --> 00:27:58,880
uh before it actually uses it so

761
00:27:58,880 --> 00:28:00,640
integers

762
00:28:00,640 --> 00:28:03,760
um so uh of course it doesn't mean it's

763
00:28:03,760 --> 00:28:06,960
network input uh 100 but it's a good

764
00:28:06,960 --> 00:28:09,760
indicator that it might be network input

765
00:28:09,760 --> 00:28:10,960
uh these are

766
00:28:10,960 --> 00:28:13,120
a lot of the times in line because it's

767
00:28:13,120 --> 00:28:15,360
like two op codes

768
00:28:15,360 --> 00:28:17,679
um so we actually need to be able to

769
00:28:17,679 --> 00:28:19,600
identify them in line and not just as a

770
00:28:19,600 --> 00:28:23,039
function call so i'll get to that

771
00:28:23,039 --> 00:28:24,720
and there's also

772
00:28:24,720 --> 00:28:26,399
some for example if there's a function

773
00:28:26,399 --> 00:28:28,000
that references a lot of well-known

774
00:28:28,000 --> 00:28:29,600
protocol strings

775
00:28:29,600 --> 00:28:32,720
which i'll show an example in a second

776
00:28:32,720 --> 00:28:35,120
then we also regard that those the

777
00:28:35,120 --> 00:28:36,640
arguments of

778
00:28:36,640 --> 00:28:38,240
that function as

779
00:28:38,240 --> 00:28:40,880
possible user input sources and also the

780
00:28:40,880 --> 00:28:42,480
return value of that function because we

781
00:28:42,480 --> 00:28:44,320
see that the function is messing around

782
00:28:44,320 --> 00:28:45,200
with

783
00:28:45,200 --> 00:28:47,840
a well-known network protocol

784
00:28:47,840 --> 00:28:50,880
so an example for that uh i took just

785
00:28:50,880 --> 00:28:53,360
two examples from like random binaries

786
00:28:53,360 --> 00:28:54,880
um

787
00:28:54,880 --> 00:28:58,720
so here we have an example of some http

788
00:28:58,720 --> 00:29:00,480
strings being referenced from a function

789
00:29:00,480 --> 00:29:03,360
like content land multi-part form data

790
00:29:03,360 --> 00:29:07,039
and also ftp strings user pass

791
00:29:07,039 --> 00:29:09,279
acct

792
00:29:09,279 --> 00:29:11,440
so once we see these

793
00:29:11,440 --> 00:29:13,200
again we bump up the score for that

794
00:29:13,200 --> 00:29:15,440
function and if it goes over a certain

795
00:29:15,440 --> 00:29:17,039
threshold we say okay this is an

796
00:29:17,039 --> 00:29:18,960
interesting function

797
00:29:18,960 --> 00:29:20,399
and then

798
00:29:20,399 --> 00:29:22,559
we can take all its

799
00:29:22,559 --> 00:29:24,880
arguments and return value as

800
00:29:24,880 --> 00:29:27,520
possible user input sources

801
00:29:27,520 --> 00:29:28,799
um

802
00:29:28,799 --> 00:29:31,679
and that also gives us more inputs

803
00:29:31,679 --> 00:29:33,360
another example that i didn't show here

804
00:29:33,360 --> 00:29:36,000
but it's fairly obvious is uh the

805
00:29:36,000 --> 00:29:37,840
as an interesting function is

806
00:29:37,840 --> 00:29:42,159
uh the main call so uh of course

807
00:29:42,159 --> 00:29:44,640
anything that's coming to maine like rxe

808
00:29:44,640 --> 00:29:48,399
and rv or mostly rxe rgv actually

809
00:29:48,399 --> 00:29:51,279
um we can consider it as local sources

810
00:29:51,279 --> 00:29:54,000
uh because we know it's coming from

811
00:29:54,000 --> 00:29:55,919
external input

812
00:29:55,919 --> 00:29:57,840
in this case local user input but again

813
00:29:57,840 --> 00:29:59,279
external input so

814
00:29:59,279 --> 00:30:03,200
for example arc v is another one of the

815
00:30:03,200 --> 00:30:04,799
local sources

816
00:30:04,799 --> 00:30:07,600
of external data

817
00:30:07,600 --> 00:30:10,080
um so regarding uh syncs i'm just gonna

818
00:30:10,080 --> 00:30:12,559
show a few of course there's a ton so

819
00:30:12,559 --> 00:30:15,520
it's not an exhaustive list at all

820
00:30:15,520 --> 00:30:17,520
um but basically if we're talking about

821
00:30:17,520 --> 00:30:20,399
basic sinks so command injection is

822
00:30:20,399 --> 00:30:23,039
super obvious it's either the system

823
00:30:23,039 --> 00:30:24,960
call or p open call

824
00:30:24,960 --> 00:30:27,360
so you know that if data flows into

825
00:30:27,360 --> 00:30:29,679
these calls and it's not

826
00:30:29,679 --> 00:30:31,520
uh filtered for

827
00:30:31,520 --> 00:30:33,679
shell meta characters then of course

828
00:30:33,679 --> 00:30:37,520
it's a command injection vulnerability

829
00:30:37,520 --> 00:30:40,080
so this is an obvious sync another one

830
00:30:40,080 --> 00:30:43,440
for buffer overflow is mcpy and sdrcpy

831
00:30:43,440 --> 00:30:46,000
again sdrcpy

832
00:30:46,000 --> 00:30:48,399
here there's a caveat that of course the

833
00:30:48,399 --> 00:30:50,320
destination needs to be fixed size and

834
00:30:50,320 --> 00:30:52,320
this is also something that we do but

835
00:30:52,320 --> 00:30:54,399
i'm not elaborating on it

836
00:30:54,399 --> 00:30:56,880
because we don't have enough time

837
00:30:56,880 --> 00:30:58,000
but basically

838
00:30:58,000 --> 00:31:00,720
memcpi and sdrcpy if we see

839
00:31:00,720 --> 00:31:03,360
a user input source flowing into it in

840
00:31:03,360 --> 00:31:05,679
the data flow analysis then we say okay

841
00:31:05,679 --> 00:31:08,799
that's a possible buffer overflow

842
00:31:08,799 --> 00:31:11,519
um in mem cpy for example we also check

843
00:31:11,519 --> 00:31:13,200
that the length is user controlled

844
00:31:13,200 --> 00:31:16,080
otherwise of course can be

845
00:31:16,080 --> 00:31:18,480
truncated with a constant land and then

846
00:31:18,480 --> 00:31:20,559
there's no vulnerability

847
00:31:20,559 --> 00:31:22,880
uh more a bit more advanced things is

848
00:31:22,880 --> 00:31:25,679
for example memcpy and sdrcpy can be

849
00:31:25,679 --> 00:31:26,880
inlined

850
00:31:26,880 --> 00:31:27,919
or

851
00:31:27,919 --> 00:31:30,240
it can even be some copy loop which is

852
00:31:30,240 --> 00:31:32,240
what i'm showing here so this is a copy

853
00:31:32,240 --> 00:31:34,880
loop and it has a custom exit condition

854
00:31:34,880 --> 00:31:37,600
uh if uh

855
00:31:37,600 --> 00:31:39,840
if the current uh character is equal to

856
00:31:39,840 --> 00:31:40,880
the hat

857
00:31:40,880 --> 00:31:44,080
character then it breaks

858
00:31:44,080 --> 00:31:45,440
but this is also

859
00:31:45,440 --> 00:31:48,240
a copy loop uh very easily

860
00:31:48,240 --> 00:31:50,320
distinguishable uh and we need to take

861
00:31:50,320 --> 00:31:52,000
care of things like that as well we

862
00:31:52,000 --> 00:31:53,919
can't just say okay it has to be a copy

863
00:31:53,919 --> 00:31:56,960
to sarcpy or mcpy

864
00:31:56,960 --> 00:32:00,080
um so this is another example that we

865
00:32:00,080 --> 00:32:02,480
have to identify as a sink

866
00:32:02,480 --> 00:32:04,960
and also uh integer overflow leading to

867
00:32:04,960 --> 00:32:07,679
a buffer overflow so a sync might be uh

868
00:32:07,679 --> 00:32:08,880
two stage

869
00:32:08,880 --> 00:32:10,399
not just

870
00:32:10,399 --> 00:32:12,320
seeing that there's a system call but

871
00:32:12,320 --> 00:32:14,480
rather seeing that there's some sort of

872
00:32:14,480 --> 00:32:18,000
a possible integer overflow uh maybe an

873
00:32:18,000 --> 00:32:19,039
addition

874
00:32:19,039 --> 00:32:20,640
without a check

875
00:32:20,640 --> 00:32:22,480
and then that's the

876
00:32:22,480 --> 00:32:26,000
data flows from that integer overflow to

877
00:32:26,000 --> 00:32:28,960
uh buffer operation like sdrcpy so it's

878
00:32:28,960 --> 00:32:31,600
a two-stage sync basically

879
00:32:31,600 --> 00:32:33,519
uh so we'll show an example of that a

880
00:32:33,519 --> 00:32:35,519
bit later with the actual vulnerability

881
00:32:35,519 --> 00:32:39,360
that is automatically detected

882
00:32:39,760 --> 00:32:42,320
so i said before that we use a unicorn

883
00:32:42,320 --> 00:32:45,120
in order to detect leap c functions and

884
00:32:45,120 --> 00:32:48,159
other utility functions

885
00:32:48,159 --> 00:32:50,240
and the way that it happens is that we

886
00:32:50,240 --> 00:32:53,039
use uh our own

887
00:32:53,039 --> 00:32:57,360
homegrown divination engine um

888
00:32:57,360 --> 00:33:00,159
and basically what this uh engine does

889
00:33:00,159 --> 00:33:01,519
is uh

890
00:33:01,519 --> 00:33:03,440
the problem is that if uh

891
00:33:03,440 --> 00:33:06,640
if there's an rtos binary uh or some

892
00:33:06,640 --> 00:33:09,919
binary which links statically to libsy

893
00:33:09,919 --> 00:33:11,440
you're not going to have any symbols

894
00:33:11,440 --> 00:33:15,279
like sdrcpy malloc memcpy

895
00:33:15,279 --> 00:33:17,760
printf etc etc

896
00:33:17,760 --> 00:33:19,200
and you need to identify that

897
00:33:19,200 --> 00:33:20,880
functionality

898
00:33:20,880 --> 00:33:22,559
in order to make your life easier

899
00:33:22,559 --> 00:33:25,200
basically uh when doing the static

900
00:33:25,200 --> 00:33:27,279
analysis like i should before for

901
00:33:27,279 --> 00:33:28,240
example

902
00:33:28,240 --> 00:33:31,440
system is a sync fcpy is a sync get 10

903
00:33:31,440 --> 00:33:34,320
is the source you you want to

904
00:33:34,320 --> 00:33:36,480
understand these utility functions you

905
00:33:36,480 --> 00:33:39,120
want to get these symbols

906
00:33:39,120 --> 00:33:43,360
even if you don't have them uh naively

907
00:33:43,360 --> 00:33:47,440
so uh what we do is we use uh emulation

908
00:33:47,440 --> 00:33:49,279
with test cases

909
00:33:49,279 --> 00:33:51,919
in order to determine

910
00:33:51,919 --> 00:33:54,000
which function we're looking at so every

911
00:33:54,000 --> 00:33:56,080
unnamed function

912
00:33:56,080 --> 00:33:58,080
in the program

913
00:33:58,080 --> 00:34:00,880
we define test cases so for example here

914
00:34:00,880 --> 00:34:02,480
you can see a

915
00:34:02,480 --> 00:34:04,559
test case

916
00:34:04,559 --> 00:34:07,919
for sdr cat so basically we define uh

917
00:34:07,919 --> 00:34:09,359
inputs

918
00:34:09,359 --> 00:34:12,320
and uh we we define a test case so you

919
00:34:12,320 --> 00:34:14,960
know uh allocating uh some memory with

920
00:34:14,960 --> 00:34:16,480
unicorn

921
00:34:16,480 --> 00:34:19,280
um writing uh two strings to two

922
00:34:19,280 --> 00:34:20,560
different variables

923
00:34:20,560 --> 00:34:22,480
and then calling the function whatever

924
00:34:22,480 --> 00:34:24,159
the function is

925
00:34:24,159 --> 00:34:25,839
because we don't know what it is really

926
00:34:25,839 --> 00:34:28,560
it just has to match

927
00:34:28,560 --> 00:34:30,079
a given function prototype so for

928
00:34:30,079 --> 00:34:32,480
example in this case

929
00:34:32,480 --> 00:34:34,480
it will test all functions that's

930
00:34:34,480 --> 00:34:35,918
getting uh

931
00:34:35,918 --> 00:34:37,119
two

932
00:34:37,119 --> 00:34:38,699
uh two uh

933
00:34:38,699 --> 00:34:39,839
[Music]

934
00:34:39,839 --> 00:34:42,399
character pointers as input so two

935
00:34:42,399 --> 00:34:44,639
arguments which are pointers

936
00:34:44,639 --> 00:34:46,399
um and then it will call the function

937
00:34:46,399 --> 00:34:47,280
with

938
00:34:47,280 --> 00:34:49,359
hello in the world

939
00:34:49,359 --> 00:34:51,839
and it will check that

940
00:34:51,839 --> 00:34:54,960
the test case will eventually check that

941
00:34:54,960 --> 00:34:57,040
the destination argument which is of

942
00:34:57,040 --> 00:35:00,160
course the first argument

943
00:35:00,160 --> 00:35:02,960
is the concatenated result of

944
00:35:02,960 --> 00:35:04,880
these both both of these strings and

945
00:35:04,880 --> 00:35:07,359
that the second the argument wasn't

946
00:35:07,359 --> 00:35:08,880
changed somehow

947
00:35:08,880 --> 00:35:11,520
uh and of course we have multiple test

948
00:35:11,520 --> 00:35:13,760
cases uh to verify that you know this

949
00:35:13,760 --> 00:35:16,000
wasn't a fluke

950
00:35:16,000 --> 00:35:18,000
so for each just

951
00:35:18,000 --> 00:35:20,079
for test sd or cat there's also other

952
00:35:20,079 --> 00:35:21,920
test cases

953
00:35:21,920 --> 00:35:24,240
but basically if

954
00:35:24,240 --> 00:35:25,520
the function

955
00:35:25,520 --> 00:35:27,839
under test

956
00:35:27,839 --> 00:35:29,839
passes this test then we say okay this

957
00:35:29,839 --> 00:35:31,440
is strcat

958
00:35:31,440 --> 00:35:33,680
we just have to make sure that you know

959
00:35:33,680 --> 00:35:36,720
to check that it's not sdr ncat or

960
00:35:36,720 --> 00:35:39,119
sdrcpy et cetera so the test cases have

961
00:35:39,119 --> 00:35:43,079
to be very well defined

962
00:35:44,720 --> 00:35:47,359
okay so now uh we're done

963
00:35:47,359 --> 00:35:49,839
with mapping the the libc functions

964
00:35:49,839 --> 00:35:51,520
we're done with getting sources and

965
00:35:51,520 --> 00:35:53,760
getting things so the

966
00:35:53,760 --> 00:35:55,920
only step that that's left is the final

967
00:35:55,920 --> 00:35:57,760
step uh which is doing data flow

968
00:35:57,760 --> 00:35:59,200
analysis

969
00:35:59,200 --> 00:36:02,000
um so we're trying to figure out

970
00:36:02,000 --> 00:36:04,000
uh you know we start with some source

971
00:36:04,000 --> 00:36:06,400
variable and we're trying to figure out

972
00:36:06,400 --> 00:36:09,200
all the places that it propagates to so

973
00:36:09,200 --> 00:36:11,359
if it's being copied

974
00:36:11,359 --> 00:36:13,359
uh if it's being

975
00:36:13,359 --> 00:36:15,520
referenced in a struct

976
00:36:15,520 --> 00:36:18,560
if it's being copied as a buffer or not

977
00:36:18,560 --> 00:36:21,040
just by reference by value

978
00:36:21,040 --> 00:36:22,079
um

979
00:36:22,079 --> 00:36:24,079
and if it's been copied to a global and

980
00:36:24,079 --> 00:36:26,000
then being read at so basically

981
00:36:26,000 --> 00:36:28,000
everywhere this variable uh propagates

982
00:36:28,000 --> 00:36:29,200
to

983
00:36:29,200 --> 00:36:31,680
and uh actually gidra provides a basic

984
00:36:31,680 --> 00:36:34,640
uh api for this it's called get forward

985
00:36:34,640 --> 00:36:35,680
slice

986
00:36:35,680 --> 00:36:37,920
uh or get forward slice to b code ops it

987
00:36:37,920 --> 00:36:40,880
depends on what you want to get um

988
00:36:40,880 --> 00:36:43,760
but this is intra function

989
00:36:43,760 --> 00:36:47,760
um so that means it will only work

990
00:36:47,760 --> 00:36:50,720
inside the same function

991
00:36:50,720 --> 00:36:53,280
it will not show you where the variable

992
00:36:53,280 --> 00:36:54,880
propagates outside of the current

993
00:36:54,880 --> 00:36:56,160
function

994
00:36:56,160 --> 00:36:59,200
it also doesn't work very

995
00:36:59,200 --> 00:37:01,119
well with stack variables sometimes it

996
00:37:01,119 --> 00:37:03,119
works sometimes it doesn't but

997
00:37:03,119 --> 00:37:05,760
it's a bit iffy

998
00:37:05,760 --> 00:37:07,680
and basically

999
00:37:07,680 --> 00:37:10,320
so uh here i've highlighted you know ph

1000
00:37:10,320 --> 00:37:12,079
var2 and you can see

1001
00:37:12,079 --> 00:37:14,320
um okay ivar three

1002
00:37:14,320 --> 00:37:16,800
gets uh the reference of that

1003
00:37:16,800 --> 00:37:18,880
uh and then n also gets some dereference

1004
00:37:18,880 --> 00:37:19,839
of that

1005
00:37:19,839 --> 00:37:22,800
um and then uh ivar three is uh also

1006
00:37:22,800 --> 00:37:25,680
mentioned here and then so it will keep

1007
00:37:25,680 --> 00:37:28,079
on checking and ph var2

1008
00:37:28,079 --> 00:37:30,720
gets at the reference of that y by three

1009
00:37:30,720 --> 00:37:32,560
so so that works

1010
00:37:32,560 --> 00:37:34,240
kind of okay but

1011
00:37:34,240 --> 00:37:37,119
only intra function only inside

1012
00:37:37,119 --> 00:37:38,640
the current function and of course

1013
00:37:38,640 --> 00:37:41,200
that's not good enough for us

1014
00:37:41,200 --> 00:37:44,480
so we expanded the guidra's analysis to

1015
00:37:44,480 --> 00:37:46,720
work inter function

1016
00:37:46,720 --> 00:37:48,560
so basically there's two

1017
00:37:48,560 --> 00:37:51,599
major cases that we need to take care of

1018
00:37:51,599 --> 00:37:53,920
so uh propagation

1019
00:37:53,920 --> 00:37:55,920
into child functions propagation of the

1020
00:37:55,920 --> 00:37:57,599
data into child functions and

1021
00:37:57,599 --> 00:37:59,599
propagation of the data

1022
00:37:59,599 --> 00:38:02,640
outside of the current function

1023
00:38:02,640 --> 00:38:06,720
and again we propagate this data um and

1024
00:38:06,720 --> 00:38:09,440
to the whole program uh and check

1025
00:38:09,440 --> 00:38:11,440
eventually if we reach some sync

1026
00:38:11,440 --> 00:38:14,240
function if any of the sources uh

1027
00:38:14,240 --> 00:38:16,079
reach some sync function

1028
00:38:16,079 --> 00:38:17,839
um so for example let's look at an

1029
00:38:17,839 --> 00:38:19,200
example here

1030
00:38:19,200 --> 00:38:20,960
so we have a source function and it

1031
00:38:20,960 --> 00:38:23,599
writes to uh the d variable

1032
00:38:23,599 --> 00:38:24,720
um

1033
00:38:24,720 --> 00:38:26,720
so now d is uh

1034
00:38:26,720 --> 00:38:28,880
something that we track because it's a

1035
00:38:28,880 --> 00:38:30,880
source variable

1036
00:38:30,880 --> 00:38:32,960
uh and then it calls f2

1037
00:38:32,960 --> 00:38:36,240
and what if two does is copies

1038
00:38:36,240 --> 00:38:38,640
uh the first argument to the second

1039
00:38:38,640 --> 00:38:41,359
argument so basically um

1040
00:38:41,359 --> 00:38:44,640
d is getting copied into a

1041
00:38:44,640 --> 00:38:47,359
so uh if we look at it uh

1042
00:38:47,359 --> 00:38:49,359
in the diagram we can see that

1043
00:38:49,359 --> 00:38:52,320
uh it calls f2 and then copies uh the

1044
00:38:52,320 --> 00:38:53,200
source

1045
00:38:53,200 --> 00:38:54,960
into another variable

1046
00:38:54,960 --> 00:38:57,760
but the question is now okay what's a

1047
00:38:57,760 --> 00:39:00,560
and a is actually an argument of cs1

1048
00:39:00,560 --> 00:39:04,240
so now we have to propagate upwards um

1049
00:39:04,240 --> 00:39:06,880
outside of the current function

1050
00:39:06,880 --> 00:39:08,640
cs1 and check

1051
00:39:08,640 --> 00:39:11,280
okay where where did we get a from

1052
00:39:11,280 --> 00:39:13,520
uh so this is obviously you know

1053
00:39:13,520 --> 00:39:16,079
recursive operations so on and so forth

1054
00:39:16,079 --> 00:39:18,400
um and this is an example of both going

1055
00:39:18,400 --> 00:39:20,720
into a child and propagating out of the

1056
00:39:20,720 --> 00:39:22,240
current function

1057
00:39:22,240 --> 00:39:24,240
and eventually we propagate into all

1058
00:39:24,240 --> 00:39:27,280
variables in this manner and understand

1059
00:39:27,280 --> 00:39:29,359
where uh

1060
00:39:29,359 --> 00:39:31,359
which variables are tainted

1061
00:39:31,359 --> 00:39:34,799
uh by the initial variable

1062
00:39:36,000 --> 00:39:37,760
okay so um

1063
00:39:37,760 --> 00:39:39,839
so let's say we have the data flow

1064
00:39:39,839 --> 00:39:41,359
analysis down

1065
00:39:41,359 --> 00:39:43,200
but now we have to take care of a few

1066
00:39:43,200 --> 00:39:45,280
issues like i said before

1067
00:39:45,280 --> 00:39:46,320
uh

1068
00:39:46,320 --> 00:39:48,160
a lot of that a lot of the times you

1069
00:39:48,160 --> 00:39:50,079
just you can't be naive

1070
00:39:50,079 --> 00:39:52,560
and just say okay there's data flow boom

1071
00:39:52,560 --> 00:39:54,160
there's a vulnerability

1072
00:39:54,160 --> 00:39:57,359
because in the real world um

1073
00:39:57,359 --> 00:39:59,119
you add the size checks and things like

1074
00:39:59,119 --> 00:40:00,800
that to make sure that there's actually

1075
00:40:00,800 --> 00:40:02,640
not a vulnerability

1076
00:40:02,640 --> 00:40:04,319
um so for example

1077
00:40:04,319 --> 00:40:06,319
um in

1078
00:40:06,319 --> 00:40:08,560
buffer overflow

1079
00:40:08,560 --> 00:40:10,800
it's obvious to add some size check if

1080
00:40:10,800 --> 00:40:12,800
you're using sdrcpy which of course you

1081
00:40:12,800 --> 00:40:16,240
shouldn't but you know embedded uh so it

1082
00:40:16,240 --> 00:40:18,000
does get used

1083
00:40:18,000 --> 00:40:20,079
um so here there's an example of uh

1084
00:40:20,079 --> 00:40:22,800
allocating a buffer with 50 characters

1085
00:40:22,800 --> 00:40:25,040
and then uh

1086
00:40:25,040 --> 00:40:27,359
we still use sdrcpy which is bad but

1087
00:40:27,359 --> 00:40:30,480
here we uh add an sdr lan check and see

1088
00:40:30,480 --> 00:40:32,960
that if uh user input is over 50

1089
00:40:32,960 --> 00:40:34,480
characters

1090
00:40:34,480 --> 00:40:36,560
uh then we return an error and don't do

1091
00:40:36,560 --> 00:40:38,640
sdrc provide so so this is a good check

1092
00:40:38,640 --> 00:40:40,880
like this will there's no vulnerability

1093
00:40:40,880 --> 00:40:41,760
here

1094
00:40:41,760 --> 00:40:44,960
but if i would uh look you know at naive

1095
00:40:44,960 --> 00:40:46,960
data flow analysis i would say oh yeah

1096
00:40:46,960 --> 00:40:48,000
okay

1097
00:40:48,000 --> 00:40:51,119
bob user input is getting to sdrcpy and

1098
00:40:51,119 --> 00:40:53,359
buff is fixed size then

1099
00:40:53,359 --> 00:40:55,040
there's a vulnerability

1100
00:40:55,040 --> 00:40:58,480
so that doesn't work we actually need to

1101
00:40:58,480 --> 00:41:00,960
travel along the data flow path and look

1102
00:41:00,960 --> 00:41:02,800
for these uh checks

1103
00:41:02,800 --> 00:41:05,599
and again for each type of cwe or for

1104
00:41:05,599 --> 00:41:07,200
each type of vulnerability we'll have a

1105
00:41:07,200 --> 00:41:08,640
different check

1106
00:41:08,640 --> 00:41:10,880
a check for against command injection

1107
00:41:10,880 --> 00:41:12,960
for example can be seen

1108
00:41:12,960 --> 00:41:15,280
here

1109
00:41:15,520 --> 00:41:18,079
so for example here user input

1110
00:41:18,079 --> 00:41:20,160
is getting checked that if any of these

1111
00:41:20,160 --> 00:41:22,560
characters appear in the user input so

1112
00:41:22,560 --> 00:41:26,000
asterisk semicolon backtick

1113
00:41:26,000 --> 00:41:28,240
dollar sign blah blah blah

1114
00:41:28,240 --> 00:41:30,640
then it's a shell meta character

1115
00:41:30,640 --> 00:41:33,359
and we return an error so this is also a

1116
00:41:33,359 --> 00:41:34,960
pretty good check for command injection

1117
00:41:34,960 --> 00:41:36,480
i'm not saying it's

1118
00:41:36,480 --> 00:41:38,720
checking everything but um

1119
00:41:38,720 --> 00:41:40,319
it's a pretty good check for the basic

1120
00:41:40,319 --> 00:41:42,160
stuff and we need to take that into

1121
00:41:42,160 --> 00:41:44,480
account as well

1122
00:41:44,480 --> 00:41:47,280
and there's also um what we like to call

1123
00:41:47,280 --> 00:41:48,800
data anchoring

1124
00:41:48,800 --> 00:41:51,680
so for example uh sometimes you have a

1125
00:41:51,680 --> 00:41:53,599
user input but actually it's getting

1126
00:41:53,599 --> 00:41:55,599
checked to be matching to a very

1127
00:41:55,599 --> 00:41:57,040
specific thing

1128
00:41:57,040 --> 00:41:58,800
and after that point it's not really

1129
00:41:58,800 --> 00:42:00,720
considered user input so for example in

1130
00:42:00,720 --> 00:42:03,359
the third example here we can see

1131
00:42:03,359 --> 00:42:06,400
if the user input is not equal to fixed

1132
00:42:06,400 --> 00:42:08,240
input like the string

1133
00:42:08,240 --> 00:42:10,480
uh then it returns an error so so from

1134
00:42:10,480 --> 00:42:12,560
this place forward i actually know that

1135
00:42:12,560 --> 00:42:14,000
user input

1136
00:42:14,000 --> 00:42:16,240
it has to be uh

1137
00:42:16,240 --> 00:42:18,240
exactly the string fixed input so from

1138
00:42:18,240 --> 00:42:19,680
this place forward i

1139
00:42:19,680 --> 00:42:24,240
i i don't uh tag this variable as actual

1140
00:42:24,240 --> 00:42:26,880
user input or external input because it

1141
00:42:26,880 --> 00:42:29,359
has to be a very specific

1142
00:42:29,359 --> 00:42:31,520
constant input so from from this place

1143
00:42:31,520 --> 00:42:33,520
forward in the program uh from the

1144
00:42:33,520 --> 00:42:35,839
analysis side it's regarded as a

1145
00:42:35,839 --> 00:42:38,000
constant it's not really interesting

1146
00:42:38,000 --> 00:42:40,480
anymore

1147
00:42:41,119 --> 00:42:42,960
okay so let's talk about

1148
00:42:42,960 --> 00:42:45,040
actually detecting uh one of the

1149
00:42:45,040 --> 00:42:47,839
vulnerabilities from infrahold

1150
00:42:47,839 --> 00:42:51,839
so uh cve 2021 31 228

1151
00:42:51,839 --> 00:42:56,480
is a an http server denial of service

1152
00:42:56,480 --> 00:42:58,960
and it's a signed comparison leading to

1153
00:42:58,960 --> 00:43:00,160
overflow

1154
00:43:00,160 --> 00:43:03,280
uh well-known cwe that we all love

1155
00:43:03,280 --> 00:43:05,440
uh so it's uh

1156
00:43:05,440 --> 00:43:07,839
here's an excerpt from the code it's uh

1157
00:43:07,839 --> 00:43:09,760
pretty obvious

1158
00:43:09,760 --> 00:43:12,640
so uh we have the function get bound

1159
00:43:12,640 --> 00:43:15,440
search uh here lan is actually user

1160
00:43:15,440 --> 00:43:18,000
controllable and i'll show

1161
00:43:18,000 --> 00:43:20,160
why it's user controllable

1162
00:43:20,160 --> 00:43:21,359
um

1163
00:43:21,359 --> 00:43:23,680
and here we have an if condition if lan

1164
00:43:23,680 --> 00:43:26,960
is smaller than some boundary length

1165
00:43:26,960 --> 00:43:29,680
then do the mem copy

1166
00:43:29,680 --> 00:43:30,480
um

1167
00:43:30,480 --> 00:43:33,040
so this looks kind of fine until we

1168
00:43:33,040 --> 00:43:34,720
realize that uh

1169
00:43:34,720 --> 00:43:35,680
len

1170
00:43:35,680 --> 00:43:38,000
is an integer and boundary lan is

1171
00:43:38,000 --> 00:43:40,319
actually also an integer so this is a

1172
00:43:40,319 --> 00:43:42,800
signed comparison and not unsigned so if

1173
00:43:42,800 --> 00:43:44,480
lan is negative

1174
00:43:44,480 --> 00:43:45,359
uh

1175
00:43:45,359 --> 00:43:46,160
this

1176
00:43:46,160 --> 00:43:48,240
uh branch will be taken

1177
00:43:48,240 --> 00:43:50,720
which is bad it's not supposed to happen

1178
00:43:50,720 --> 00:43:52,319
and then we have a mem copy with a

1179
00:43:52,319 --> 00:43:54,960
negative value here which is

1180
00:43:54,960 --> 00:43:57,839
a huge unsigned value of course

1181
00:43:57,839 --> 00:43:59,440
and then we get a denial of service

1182
00:43:59,440 --> 00:44:01,680
because we get a huge memory copy

1183
00:44:01,680 --> 00:44:04,240
operation

1184
00:44:04,960 --> 00:44:05,760
so

1185
00:44:05,760 --> 00:44:08,880
uh the source here was detected

1186
00:44:08,880 --> 00:44:09,920
uh

1187
00:44:09,920 --> 00:44:12,480
via the the score based method uh that i

1188
00:44:12,480 --> 00:44:15,040
showed earlier so uh this is actually

1189
00:44:15,040 --> 00:44:17,280
the same function that i showed earlier

1190
00:44:17,280 --> 00:44:21,280
uh here um the score was high because of

1191
00:44:21,280 --> 00:44:25,040
two factors uh there's http strings here

1192
00:44:25,040 --> 00:44:28,880
and also um there's a function that was

1193
00:44:28,880 --> 00:44:31,119
after the the dynamic divination was

1194
00:44:31,119 --> 00:44:33,520
mapped out to be a2l

1195
00:44:33,520 --> 00:44:34,560
so it's

1196
00:44:34,560 --> 00:44:36,400
like again

1197
00:44:36,400 --> 00:44:38,880
um

1198
00:44:38,880 --> 00:44:42,720
one of the functions that we uh

1199
00:44:42,880 --> 00:44:44,400
that we uh

1200
00:44:44,400 --> 00:44:46,640
upgrade the score because of like uh

1201
00:44:46,640 --> 00:44:49,280
like i said before like uh

1202
00:44:49,280 --> 00:44:50,800
et cetera et cetera

1203
00:44:50,800 --> 00:44:53,200
uh because usually when converting a

1204
00:44:53,200 --> 00:44:56,319
string uh to an integer that string

1205
00:44:56,319 --> 00:44:58,480
usually comes from user input that's why

1206
00:44:58,480 --> 00:45:00,319
it's of course score based so we

1207
00:45:00,319 --> 00:45:02,400
accumulate all these things

1208
00:45:02,400 --> 00:45:05,200
but here a2l was

1209
00:45:05,200 --> 00:45:07,760
uh detected

1210
00:45:07,760 --> 00:45:10,480
uh using the dynamic analysis engine uh

1211
00:45:10,480 --> 00:45:12,560
so that's great because in some binaries

1212
00:45:12,560 --> 00:45:14,480
we had symbols and other binaries didn't

1213
00:45:14,480 --> 00:45:16,319
have symbols but the system still

1214
00:45:16,319 --> 00:45:18,720
detected it

1215
00:45:18,720 --> 00:45:22,319
uh so after a2l was detected this was uh

1216
00:45:22,319 --> 00:45:24,560
uh

1217
00:45:24,560 --> 00:45:26,319
this was detected at the source variable

1218
00:45:26,319 --> 00:45:29,599
and now lvar7 is a source variable you

1219
00:45:29,599 --> 00:45:31,839
can see here it's being written to a

1220
00:45:31,839 --> 00:45:33,520
struct here

1221
00:45:33,520 --> 00:45:35,440
um and then basically we follow that

1222
00:45:35,440 --> 00:45:37,200
struct

1223
00:45:37,200 --> 00:45:39,680
um

1224
00:45:39,839 --> 00:45:41,760
we follow that struct with a data flow

1225
00:45:41,760 --> 00:45:44,319
analysis

1226
00:45:44,319 --> 00:45:46,319
and until we get to that uh sync

1227
00:45:46,319 --> 00:45:48,960
function which i'll uh show again uh in

1228
00:45:48,960 --> 00:45:50,000
a second

1229
00:45:50,000 --> 00:45:51,920
so this is the data from analysis part

1230
00:45:51,920 --> 00:45:53,599
just tracking

1231
00:45:53,599 --> 00:45:56,240
the the various copies

1232
00:45:56,240 --> 00:45:58,960
uh and references and the references of

1233
00:45:58,960 --> 00:46:01,839
of this variable throughout the program

1234
00:46:01,839 --> 00:46:03,839
even the first reference was even a data

1235
00:46:03,839 --> 00:46:06,000
reference which we also track it also

1236
00:46:06,000 --> 00:46:08,480
affects the score but

1237
00:46:08,480 --> 00:46:11,119
it's tracked

1238
00:46:11,440 --> 00:46:13,359
so here

1239
00:46:13,359 --> 00:46:15,680
it's interesting to see

1240
00:46:15,680 --> 00:46:18,800
why we chose dynamic divination

1241
00:46:18,800 --> 00:46:23,200
for example to detect a2l and not static

1242
00:46:23,440 --> 00:46:25,359
so uh i'll

1243
00:46:25,359 --> 00:46:29,839
open up this code just one second

1244
00:46:31,760 --> 00:46:33,599
okay so now that we have everything

1245
00:46:33,599 --> 00:46:34,880
together

1246
00:46:34,880 --> 00:46:36,079
um

1247
00:46:36,079 --> 00:46:37,680
basically like i showed before the data

1248
00:46:37,680 --> 00:46:40,319
from analysis uh reached the the get

1249
00:46:40,319 --> 00:46:43,920
bonded search function and uh the second

1250
00:46:43,920 --> 00:46:45,119
argument is

1251
00:46:45,119 --> 00:46:47,680
tainted by that initial source argument

1252
00:46:47,680 --> 00:46:50,879
that's coming from a2l

1253
00:46:51,119 --> 00:46:52,880
and this vulnerability was classified as

1254
00:46:52,880 --> 00:46:54,960
a sign comparison why because as part of

1255
00:46:54,960 --> 00:46:57,040
the data flow we went through this line

1256
00:46:57,040 --> 00:46:58,400
this if

1257
00:46:58,400 --> 00:47:00,960
and of course we know uh

1258
00:47:00,960 --> 00:47:02,960
whether it's a signed or unsigned

1259
00:47:02,960 --> 00:47:04,880
comparison there's actually a different

1260
00:47:04,880 --> 00:47:07,119
p code for for each one for signed and

1261
00:47:07,119 --> 00:47:09,200
unsigned so that's easy

1262
00:47:09,200 --> 00:47:12,480
uh just you know to explain if

1263
00:47:12,480 --> 00:47:15,760
there wasn't this uh if check here

1264
00:47:15,760 --> 00:47:17,920
um then this would be classified as a

1265
00:47:17,920 --> 00:47:20,480
straight up heap overflow because it's

1266
00:47:20,480 --> 00:47:21,760
just

1267
00:47:21,760 --> 00:47:25,200
a source going to mem cpy with a

1268
00:47:25,200 --> 00:47:27,280
controlled length so it's a heap

1269
00:47:27,280 --> 00:47:28,400
overflow

1270
00:47:28,400 --> 00:47:31,680
um if this if wasn't here

1271
00:47:31,680 --> 00:47:34,160
and if this if was unsigned then this

1272
00:47:34,160 --> 00:47:35,280
would be classified as a

1273
00:47:35,280 --> 00:47:36,800
non-vulnerability

1274
00:47:36,800 --> 00:47:39,440
um because of course

1275
00:47:39,440 --> 00:47:41,520
this would be a proper if check and it's

1276
00:47:41,520 --> 00:47:44,319
not exploitable

1277
00:47:45,839 --> 00:47:48,319
okay so uh now we saw actually

1278
00:47:48,319 --> 00:47:51,440
you know the automation engine how it's

1279
00:47:51,440 --> 00:47:53,920
the score based analysis how it actually

1280
00:47:53,920 --> 00:47:56,079
found one of the vulnerabilities

1281
00:47:56,079 --> 00:47:59,040
um so let's go to the mitigation part

1282
00:47:59,040 --> 00:48:01,280
and here we're going to show both

1283
00:48:01,280 --> 00:48:03,839
you know network based and

1284
00:48:03,839 --> 00:48:05,440
vendor

1285
00:48:05,440 --> 00:48:07,680
recommendations on how to

1286
00:48:07,680 --> 00:48:08,720
mitigate

1287
00:48:08,720 --> 00:48:12,160
these sort of vulnerabilities

1288
00:48:12,160 --> 00:48:14,480
so the first thing for vendors and this

1289
00:48:14,480 --> 00:48:15,839
is

1290
00:48:15,839 --> 00:48:18,559
you know it's funny to say this in 2021

1291
00:48:18,559 --> 00:48:21,280
but you know that we don't have 20 year

1292
00:48:21,280 --> 00:48:23,599
old mitigations in place just because

1293
00:48:23,599 --> 00:48:24,720
it's

1294
00:48:24,720 --> 00:48:27,839
you know the default it's not it's it's

1295
00:48:27,839 --> 00:48:29,200
not just it's

1296
00:48:29,200 --> 00:48:31,839
uh in this day and age it's usually not

1297
00:48:31,839 --> 00:48:34,800
performance oriented like the embedded

1298
00:48:34,800 --> 00:48:36,640
processors are fast enough to do these

1299
00:48:36,640 --> 00:48:39,280
mitigations

1300
00:48:39,280 --> 00:48:40,880
so basically for vendors we're saying

1301
00:48:40,880 --> 00:48:42,720
okay don't use the default compilation

1302
00:48:42,720 --> 00:48:44,640
flags actually use

1303
00:48:44,640 --> 00:48:46,480
uh common vulnerability mitigations

1304
00:48:46,480 --> 00:48:48,800
which can be enabled in the compiler for

1305
00:48:48,800 --> 00:48:51,040
example here what would definitely solve

1306
00:48:51,040 --> 00:48:53,200
it

1307
00:48:54,000 --> 00:48:55,920
at least for our exploitation method

1308
00:48:55,920 --> 00:48:57,920
what we showed because we

1309
00:48:57,920 --> 00:49:00,720
exploited the unlink mechanism

1310
00:49:00,720 --> 00:49:03,359
is safe on linking

1311
00:49:03,359 --> 00:49:05,839
so this is a very very well known

1312
00:49:05,839 --> 00:49:07,440
mitigation method

1313
00:49:07,440 --> 00:49:09,839
that when you go to

1314
00:49:09,839 --> 00:49:11,200
unlink

1315
00:49:11,200 --> 00:49:12,800
uh

1316
00:49:12,800 --> 00:49:15,520
heap node in the doubly linked list

1317
00:49:15,520 --> 00:49:17,440
before you unlink it you actually check

1318
00:49:17,440 --> 00:49:19,440
that the backwards link and the forward

1319
00:49:19,440 --> 00:49:20,559
links

1320
00:49:20,559 --> 00:49:23,040
uh are proper

1321
00:49:23,040 --> 00:49:24,800
so for example if you're trying to a

1322
00:49:24,800 --> 00:49:27,119
free node b

1323
00:49:27,119 --> 00:49:28,800
uh you're checking that

1324
00:49:28,800 --> 00:49:30,400
if you go

1325
00:49:30,400 --> 00:49:32,800
forward and then backward you end up at

1326
00:49:32,800 --> 00:49:33,680
b

1327
00:49:33,680 --> 00:49:36,319
uh and the same if you go backwards and

1328
00:49:36,319 --> 00:49:37,760
then forward

1329
00:49:37,760 --> 00:49:39,920
of course in uh

1330
00:49:39,920 --> 00:49:42,079
unlinking exploit the whole idea is that

1331
00:49:42,079 --> 00:49:44,720
you're changing these links to

1332
00:49:44,720 --> 00:49:46,400
some crazy addresses because you want to

1333
00:49:46,400 --> 00:49:49,040
override them and then if you'll go

1334
00:49:49,040 --> 00:49:51,599
uh forward and backwards or and

1335
00:49:51,599 --> 00:49:53,359
backwards and forwards uh you're not

1336
00:49:53,359 --> 00:49:54,880
going to end up at the same note because

1337
00:49:54,880 --> 00:49:57,200
you just linked it to some crazy global

1338
00:49:57,200 --> 00:49:58,800
address

1339
00:49:58,800 --> 00:50:01,599
um so safe on linking stack categories

1340
00:50:01,599 --> 00:50:04,400
here if there were stack overflows

1341
00:50:04,400 --> 00:50:06,960
slr which this

1342
00:50:06,960 --> 00:50:09,359
from the devices that we saw did not

1343
00:50:09,359 --> 00:50:10,960
take advantage of that

1344
00:50:10,960 --> 00:50:12,720
and fortify source which is even

1345
00:50:12,720 --> 00:50:14,160
stronger

1346
00:50:14,160 --> 00:50:16,960
than carries uh and say for linking

1347
00:50:16,960 --> 00:50:18,960
because it can halt

1348
00:50:18,960 --> 00:50:20,880
right to the

1349
00:50:20,880 --> 00:50:22,000
right of the

1350
00:50:22,000 --> 00:50:25,599
mem copy operation for example

1351
00:50:25,760 --> 00:50:27,760
so we highly recommend these

1352
00:50:27,760 --> 00:50:29,280
uh also

1353
00:50:29,280 --> 00:50:31,760
as always static analysis and dynamic

1354
00:50:31,760 --> 00:50:33,920
analysis scanning solutions

1355
00:50:33,920 --> 00:50:36,880
as you can see for example uh our static

1356
00:50:36,880 --> 00:50:39,359
analysis uh solution

1357
00:50:39,359 --> 00:50:42,480
uh found this issue so

1358
00:50:42,480 --> 00:50:43,440
uh

1359
00:50:43,440 --> 00:50:45,599
it just goes to show that these issues

1360
00:50:45,599 --> 00:50:47,760
definitely can be found

1361
00:50:47,760 --> 00:50:49,520
uh with static and dynamic analysis

1362
00:50:49,520 --> 00:50:52,160
fuzzing etc

1363
00:50:52,160 --> 00:50:54,720
and we highly recommend those

1364
00:50:54,720 --> 00:50:56,960
so let's talk about mitigation for uh

1365
00:50:56,960 --> 00:50:58,880
network operators right and what should

1366
00:50:58,880 --> 00:51:00,480
they do um

1367
00:51:00,480 --> 00:51:02,000
regarding vulnerabilities such as these

1368
00:51:02,000 --> 00:51:04,160
internetworks so we have two types of

1369
00:51:04,160 --> 00:51:06,079
mitigation there we have uh general

1370
00:51:06,079 --> 00:51:08,960
recommendations and we have uh specific

1371
00:51:08,960 --> 00:51:10,800
mitigations related to infrahalt on the

1372
00:51:10,800 --> 00:51:12,800
general side the first thing you need to

1373
00:51:12,800 --> 00:51:13,760
know is

1374
00:51:13,760 --> 00:51:15,280
understand what is on your network right

1375
00:51:15,280 --> 00:51:17,040
and assess the risk of those devices

1376
00:51:17,040 --> 00:51:18,319
when they connect to the network and

1377
00:51:18,319 --> 00:51:20,160
continuously as long as they remain

1378
00:51:20,160 --> 00:51:22,400
connected to your network and then

1379
00:51:22,400 --> 00:51:25,119
understanding from this um

1380
00:51:25,119 --> 00:51:27,119
from this inventory of devices in the

1381
00:51:27,119 --> 00:51:29,680
network what is vulnerable and what

1382
00:51:29,680 --> 00:51:31,599
camera cannot be patched right because

1383
00:51:31,599 --> 00:51:34,400
we know that in the ot and iot world

1384
00:51:34,400 --> 00:51:36,160
patching is not always easy in the

1385
00:51:36,160 --> 00:51:38,480
embedded word not always uh patches make

1386
00:51:38,480 --> 00:51:40,160
it all the way down the supply chain as

1387
00:51:40,160 --> 00:51:42,319
we have discussed in the beginning but

1388
00:51:42,319 --> 00:51:44,559
also even if they are if the patches are

1389
00:51:44,559 --> 00:51:47,040
available applying them to to a device

1390
00:51:47,040 --> 00:51:49,440
might be time consuming or difficult

1391
00:51:49,440 --> 00:51:51,520
because it's a mission critical device

1392
00:51:51,520 --> 00:51:52,960
and so on

1393
00:51:52,960 --> 00:51:54,000
uh

1394
00:51:54,000 --> 00:51:56,000
so the second point is segmenting the

1395
00:51:56,000 --> 00:51:57,920
network to mitigate the risk so since

1396
00:51:57,920 --> 00:52:00,480
this um many of those devices cannot be

1397
00:52:00,480 --> 00:52:01,920
patched or even the ones that can be

1398
00:52:01,920 --> 00:52:04,640
patched should not be they may be

1399
00:52:04,640 --> 00:52:06,240
vulnerable to other things in the future

1400
00:52:06,240 --> 00:52:08,079
right and they should not be uh always

1401
00:52:08,079 --> 00:52:11,040
exposed uh externally uh

1402
00:52:11,040 --> 00:52:11,839
the

1403
00:52:11,839 --> 00:52:14,000
communication in the internal networks

1404
00:52:14,000 --> 00:52:16,480
should be segmented so that devices

1405
00:52:16,480 --> 00:52:18,079
cannot talk to basically any other

1406
00:52:18,079 --> 00:52:19,440
device in the network but only those

1407
00:52:19,440 --> 00:52:21,520
devices that they should be uh talking

1408
00:52:21,520 --> 00:52:22,480
with

1409
00:52:22,480 --> 00:52:24,319
so basically isolating devices so that

1410
00:52:24,319 --> 00:52:26,319
they cannot be used as entry points for

1411
00:52:26,319 --> 00:52:28,400
attacks in the network so isolating them

1412
00:52:28,400 --> 00:52:30,559
externally or that they cannot be used

1413
00:52:30,559 --> 00:52:33,280
uh as pivot points within the the the

1414
00:52:33,280 --> 00:52:35,920
network so isolating them internally as

1415
00:52:35,920 --> 00:52:38,240
well to segment to to isolate and

1416
00:52:38,240 --> 00:52:40,319
mitigate the

1417
00:52:40,319 --> 00:52:41,440
the

1418
00:52:41,440 --> 00:52:44,160
impact of an exploitation not just the

1419
00:52:44,160 --> 00:52:46,160
uh possibility of an exploitation or the

1420
00:52:46,160 --> 00:52:48,000
the the likelihood of an exploitation

1421
00:52:48,000 --> 00:52:49,760
but also the impact that it brings in

1422
00:52:49,760 --> 00:52:51,599
the network and the third point is

1423
00:52:51,599 --> 00:52:52,800
actually monitoring the network for

1424
00:52:52,800 --> 00:52:54,480
malicious packets

1425
00:52:54,480 --> 00:52:56,720
so as we have been uh discussing

1426
00:52:56,720 --> 00:52:57,520
throughout this presentation

1427
00:52:57,520 --> 00:52:59,200
vulnerabilities in gcp stacks they tend

1428
00:52:59,200 --> 00:53:01,200
to be very similar regardless of the

1429
00:53:01,200 --> 00:53:03,200
gcpip stack that is implemented in a

1430
00:53:03,200 --> 00:53:06,400
device uh we have seen several tcp

1431
00:53:06,400 --> 00:53:08,559
stacks that have vulnerabilities in dns

1432
00:53:08,559 --> 00:53:10,480
clients for instance several of them

1433
00:53:10,480 --> 00:53:12,319
that have similar vulnerabilities in the

1434
00:53:12,319 --> 00:53:14,480
tcp or ip layers

1435
00:53:14,480 --> 00:53:16,880
and so on right so basically monitoring

1436
00:53:16,880 --> 00:53:19,520
the network for um packets that are

1437
00:53:19,520 --> 00:53:21,839
malformed that don't really respect the

1438
00:53:21,839 --> 00:53:25,119
rfcs or that are um

1439
00:53:25,119 --> 00:53:29,839
enormous anomalous or or are uh

1440
00:53:30,240 --> 00:53:32,160
is a very important point right and and

1441
00:53:32,160 --> 00:53:34,160
a sort of a last line of defense as well

1442
00:53:34,160 --> 00:53:36,640
if devices are vulnerable they are not

1443
00:53:36,640 --> 00:53:39,119
segmented uh and an exploitation still

1444
00:53:39,119 --> 00:53:41,839
happens then uh at least uh somebody is

1445
00:53:41,839 --> 00:53:43,599
alerted about that

1446
00:53:43,599 --> 00:53:45,520
right in terms of specific

1447
00:53:45,520 --> 00:53:47,040
recommendations for uh the

1448
00:53:47,040 --> 00:53:49,040
vulnerabilities in infrahold

1449
00:53:49,040 --> 00:53:51,440
um we're talking basically about two

1450
00:53:51,440 --> 00:53:53,599
types of vulnerabilities there right the

1451
00:53:53,599 --> 00:53:55,760
ones on the lower layers on tcp and icmp

1452
00:53:55,760 --> 00:53:57,280
and the one on the ones on the upper

1453
00:53:57,280 --> 00:54:00,000
layers on dns and http for the ones on

1454
00:54:00,000 --> 00:54:02,400
the upper layers we tend to recommend

1455
00:54:02,400 --> 00:54:06,160
that the protocols are disabled directly

1456
00:54:06,160 --> 00:54:08,240
at the client or

1457
00:54:08,240 --> 00:54:09,040
that

1458
00:54:09,040 --> 00:54:11,599
uh firewalls and firewall rules can be

1459
00:54:11,599 --> 00:54:14,079
used to to block those protocols if they

1460
00:54:14,079 --> 00:54:16,079
are not needed right so

1461
00:54:16,079 --> 00:54:17,359
indeed if

1462
00:54:17,359 --> 00:54:19,280
if the protocols exist in the device it

1463
00:54:19,280 --> 00:54:20,880
may be that they are required for for

1464
00:54:20,880 --> 00:54:22,880
the functioning or on on your specific

1465
00:54:22,880 --> 00:54:24,720
network but if they are not needed

1466
00:54:24,720 --> 00:54:26,800
oftentimes they are just misconfigured

1467
00:54:26,800 --> 00:54:28,559
right so that there may be a device

1468
00:54:28,559 --> 00:54:30,640
issuing dns requests that are not really

1469
00:54:30,640 --> 00:54:33,280
necessary in your network and similarly

1470
00:54:33,280 --> 00:54:36,400
accepting http uh connections but

1471
00:54:36,400 --> 00:54:37,599
uh

1472
00:54:37,599 --> 00:54:39,760
you don't use the http for anything or

1473
00:54:39,760 --> 00:54:42,240
you only use that whenever it the device

1474
00:54:42,240 --> 00:54:43,440
needs to be

1475
00:54:43,440 --> 00:54:45,520
maintained or configured or so on so

1476
00:54:45,520 --> 00:54:47,839
basically making sure that

1477
00:54:47,839 --> 00:54:50,880
uh devices only

1478
00:54:50,880 --> 00:54:52,960
accept the connections that they they

1479
00:54:52,960 --> 00:54:54,480
should be accepting right that are

1480
00:54:54,480 --> 00:54:57,280
needed for their functioning uh on the

1481
00:54:57,280 --> 00:54:58,799
upper layers and on the on the lower

1482
00:54:58,799 --> 00:55:01,599
layers it's not possible to disable tcp

1483
00:55:01,599 --> 00:55:04,079
or or or or

1484
00:55:04,079 --> 00:55:07,040
ip and so on right but it goes back to

1485
00:55:07,040 --> 00:55:08,240
what we discussed before about

1486
00:55:08,240 --> 00:55:10,480
monitoring the traffic and either you

1487
00:55:10,480 --> 00:55:13,760
alert somebody when when these uh

1488
00:55:13,760 --> 00:55:16,480
anomalous packets are found or you just

1489
00:55:16,480 --> 00:55:18,720
drop these uh form packets directly at

1490
00:55:18,720 --> 00:55:20,559
the firewall which we know that in some

1491
00:55:20,559 --> 00:55:22,799
environments such as um critical ot

1492
00:55:22,799 --> 00:55:25,119
environments it's not always possible to

1493
00:55:25,119 --> 00:55:27,200
to drop packets because that that might

1494
00:55:27,200 --> 00:55:29,839
have a physical impact

1495
00:55:29,839 --> 00:55:32,079
but in some environments it is possible

1496
00:55:32,079 --> 00:55:33,599
and when it's not possible to drop the

1497
00:55:33,599 --> 00:55:35,280
devices at least alerting for the

1498
00:55:35,280 --> 00:55:37,920
presence is uh is important

1499
00:55:37,920 --> 00:55:39,920
right let's move on to the conclusions

1500
00:55:39,920 --> 00:55:41,520
and the the main takeaways and a little

1501
00:55:41,520 --> 00:55:42,960
bit of discussion

1502
00:55:42,960 --> 00:55:46,079
of what we learned during this research

1503
00:55:46,079 --> 00:55:48,000
so first the discussion part right so

1504
00:55:48,000 --> 00:55:50,079
the vulnerability finding um and

1505
00:55:50,079 --> 00:55:52,640
vulnerability research today uh it is

1506
00:55:52,640 --> 00:55:54,559
and it should be manual plus automated

1507
00:55:54,559 --> 00:55:57,119
right it's not one or the other um

1508
00:55:57,119 --> 00:55:58,880
automated vulnerability can find

1509
00:55:58,880 --> 00:56:00,720
low-hanging fruits much easier and much

1510
00:56:00,720 --> 00:56:02,640
faster than um

1511
00:56:02,640 --> 00:56:04,559
than researchers just just looking at

1512
00:56:04,559 --> 00:56:05,599
the code

1513
00:56:05,599 --> 00:56:08,160
uh but manual vulnerability research is

1514
00:56:08,160 --> 00:56:10,640
still useful for uh finding more complex

1515
00:56:10,640 --> 00:56:12,799
issues right so there

1516
00:56:12,799 --> 00:56:14,720
for now there are still issues that are

1517
00:56:14,720 --> 00:56:16,480
difficult for the uh automated

1518
00:56:16,480 --> 00:56:18,720
vulnerability discovery

1519
00:56:18,720 --> 00:56:21,359
uh techniques to to to find

1520
00:56:21,359 --> 00:56:23,280
and we believe that in the future as

1521
00:56:23,280 --> 00:56:25,119
well that there will be uh issues that

1522
00:56:25,119 --> 00:56:27,440
are always more difficult to find

1523
00:56:27,440 --> 00:56:28,319
but

1524
00:56:28,319 --> 00:56:30,880
more and more automated is becoming uh

1525
00:56:30,880 --> 00:56:32,640
part of the mainstream right and and

1526
00:56:32,640 --> 00:56:35,359
part of the of the goal of this uh

1527
00:56:35,359 --> 00:56:37,040
presentation that we had today is that

1528
00:56:37,040 --> 00:56:39,040
uh we help it become part of the

1529
00:56:39,040 --> 00:56:40,640
mainstream as well by disseminating

1530
00:56:40,640 --> 00:56:42,000
these ideas

1531
00:56:42,000 --> 00:56:42,799
so

1532
00:56:42,799 --> 00:56:45,280
more vulnerabilities uh that are found

1533
00:56:45,280 --> 00:56:47,599
right with automated discovery or manual

1534
00:56:47,599 --> 00:56:49,280
discovery and so on

1535
00:56:49,280 --> 00:56:50,319
means that there will be more

1536
00:56:50,319 --> 00:56:52,240
vulnerabilities to disclose right and we

1537
00:56:52,240 --> 00:56:53,280
want to talk a little bit about

1538
00:56:53,280 --> 00:56:55,280
vulnerability disclosure here so in the

1539
00:56:55,280 --> 00:56:57,359
specific case of infrahalt it took more

1540
00:56:57,359 --> 00:56:59,200
than nine months to

1541
00:56:59,200 --> 00:57:01,599
do the whole disclosure process with

1542
00:57:01,599 --> 00:57:05,200
um with the vendor with the downstream

1543
00:57:05,200 --> 00:57:08,000
vendors with uh coordinating agencies

1544
00:57:08,000 --> 00:57:09,119
and so on

1545
00:57:09,119 --> 00:57:11,760
um so it's it's a very long and

1546
00:57:11,760 --> 00:57:13,760
complicated process where basically the

1547
00:57:13,760 --> 00:57:16,880
the the needs and the the desires of all

1548
00:57:16,880 --> 00:57:18,559
these players have to be taken into

1549
00:57:18,559 --> 00:57:20,799
account up to some point

1550
00:57:20,799 --> 00:57:22,559
and currently there's very limited

1551
00:57:22,559 --> 00:57:25,200
involvement of um asset owners for

1552
00:57:25,200 --> 00:57:27,440
instance in this uh in this disclosure

1553
00:57:27,440 --> 00:57:30,240
process so it's

1554
00:57:30,240 --> 00:57:32,799
at some points the the researchers have

1555
00:57:32,799 --> 00:57:34,160
to decide

1556
00:57:34,160 --> 00:57:36,640
who they disclose to when they do that

1557
00:57:36,640 --> 00:57:40,480
and so on again respecting the the the

1558
00:57:40,480 --> 00:57:42,319
the desires and aligning with all of

1559
00:57:42,319 --> 00:57:44,960
these players is is important but at

1560
00:57:44,960 --> 00:57:47,520
some points also uh

1561
00:57:47,520 --> 00:57:48,640
we need to

1562
00:57:48,640 --> 00:57:50,480
move forward in the disclosure process

1563
00:57:50,480 --> 00:57:52,160
and make sure that more people are aware

1564
00:57:52,160 --> 00:57:54,960
and so on right so what i mean in the

1565
00:57:54,960 --> 00:57:57,200
second point basically is that

1566
00:57:57,200 --> 00:57:58,160
as

1567
00:57:58,160 --> 00:58:00,559
uh we move to automated discovery as

1568
00:58:00,559 --> 00:58:02,480
more vulnerabilities are discovered

1569
00:58:02,480 --> 00:58:04,480
faster and in

1570
00:58:04,480 --> 00:58:06,720
types of software that affect the supply

1571
00:58:06,720 --> 00:58:08,960
chain and in fact several types of

1572
00:58:08,960 --> 00:58:10,720
devices and several

1573
00:58:10,720 --> 00:58:12,799
sometimes hundreds of vendors at the

1574
00:58:12,799 --> 00:58:13,839
same time

1575
00:58:13,839 --> 00:58:14,960
uh

1576
00:58:14,960 --> 00:58:17,280
we need to we as a community right the

1577
00:58:17,280 --> 00:58:19,440
whole the whole research community the

1578
00:58:19,440 --> 00:58:21,359
whole vendor community and so on need to

1579
00:58:21,359 --> 00:58:22,559
work together

1580
00:58:22,559 --> 00:58:25,119
on the on the disclosure process to make

1581
00:58:25,119 --> 00:58:26,319
sure that

1582
00:58:26,319 --> 00:58:28,880
things are patched at the right time and

1583
00:58:28,880 --> 00:58:30,880
that everybody is notified and so that

1584
00:58:30,880 --> 00:58:34,079
when things become public um

1585
00:58:34,079 --> 00:58:37,280
there has been enough time for um

1586
00:58:37,280 --> 00:58:39,440
for everybody that needs to be aware of

1587
00:58:39,440 --> 00:58:42,480
that uh to be aware of that beforehand

1588
00:58:42,480 --> 00:58:45,200
um and identifying vulnerable devices

1589
00:58:45,200 --> 00:58:48,160
without formal analysis is challenging

1590
00:58:48,160 --> 00:58:49,680
currently there is no

1591
00:58:49,680 --> 00:58:51,280
software bill of materials there is a

1592
00:58:51,280 --> 00:58:53,440
lot of work on on making this a reality

1593
00:58:53,440 --> 00:58:55,359
but currently it's it's not the reality

1594
00:58:55,359 --> 00:58:58,319
for most of the devices on on a network

1595
00:58:58,319 --> 00:59:01,280
there is opaque documentation in in many

1596
00:59:01,280 --> 00:59:03,359
cases there are a few network banners

1597
00:59:03,359 --> 00:59:05,200
and so on so it's basically not easy to

1598
00:59:05,200 --> 00:59:08,000
identify devices that are affected by

1599
00:59:08,000 --> 00:59:10,240
this type of widespread vulnerability

1600
00:59:10,240 --> 00:59:11,440
right some

1601
00:59:11,440 --> 00:59:13,040
vendors are still investigating the

1602
00:59:13,040 --> 00:59:15,440
impact of amnesia 33 for instance which

1603
00:59:15,440 --> 00:59:17,520
we disclosed um

1604
00:59:17,520 --> 00:59:19,680
in december last year that also affected

1605
00:59:19,680 --> 00:59:22,160
tcp stacks and that's almost a year

1606
00:59:22,160 --> 00:59:23,760
after the initial disclosure right so

1607
00:59:23,760 --> 00:59:26,240
it's it's it's like eight months now

1608
00:59:26,240 --> 00:59:28,079
after the public disclosure but almost a

1609
00:59:28,079 --> 00:59:30,559
year after we started discussing with

1610
00:59:30,559 --> 00:59:33,839
uh with impacted vendors so basically

1611
00:59:33,839 --> 00:59:36,400
again more vulnerabilities are found if

1612
00:59:36,400 --> 00:59:37,280
you don't

1613
00:59:37,280 --> 00:59:39,520
uh have the right type of firmware

1614
00:59:39,520 --> 00:59:41,280
analysis tool

1615
00:59:41,280 --> 00:59:42,880
if you're a vendor and you don't have

1616
00:59:42,880 --> 00:59:44,960
the proper uh s bond documentation and

1617
00:59:44,960 --> 00:59:49,200
so on finding out which devices are uh

1618
00:59:49,200 --> 00:59:50,640
impacted

1619
00:59:50,640 --> 00:59:54,319
is is very challenging

1620
00:59:54,480 --> 00:59:56,880
right but what are the key takeaways

1621
00:59:56,880 --> 00:59:59,760
then from this uh from this research so

1622
00:59:59,760 --> 01:00:01,280
tcpap stacks have critical

1623
01:00:01,280 --> 01:00:02,799
vulnerabilities that trickle down the

1624
01:00:02,799 --> 01:00:05,200
supply chain right i think we we even in

1625
01:00:05,200 --> 01:00:07,040
previous work we had already uh shown

1626
01:00:07,040 --> 01:00:09,599
that but this one also uh specifically

1627
01:00:09,599 --> 01:00:11,440
for ot specifically for vulnerabilities

1628
01:00:11,440 --> 01:00:14,319
that are found automatically uh shows

1629
01:00:14,319 --> 01:00:15,920
that again

1630
01:00:15,920 --> 01:00:16,640
and

1631
01:00:16,640 --> 01:00:18,160
other popular software components could

1632
01:00:18,160 --> 01:00:19,680
have a similar impact right we have been

1633
01:00:19,680 --> 01:00:21,680
talking a lot about tcp stacks but you

1634
01:00:21,680 --> 01:00:25,680
can also think about things such as uh

1635
01:00:25,680 --> 01:00:27,520
dns clients that are not attached to a

1636
01:00:27,520 --> 01:00:29,920
through a tcp stack or

1637
01:00:29,920 --> 01:00:33,040
or web servers or

1638
01:00:33,040 --> 01:00:36,400
any sort of software component that or

1639
01:00:36,400 --> 01:00:38,319
different types of sdks in iot for

1640
01:00:38,319 --> 01:00:40,400
instance that

1641
01:00:40,400 --> 01:00:42,480
are used by several vendors at the same

1642
01:00:42,480 --> 01:00:44,160
time right and that have this supply

1643
01:00:44,160 --> 01:00:46,559
chain uh impact so basically

1644
01:00:46,559 --> 01:00:47,280
the

1645
01:00:47,280 --> 01:00:48,640
there will be

1646
01:00:48,640 --> 01:00:50,480
in the future for sure many more

1647
01:00:50,480 --> 01:00:52,640
vulnerabilities of the the same type

1648
01:00:52,640 --> 01:00:55,440
that affect several types of devices and

1649
01:00:55,440 --> 01:00:57,599
vendors at the same time

1650
01:00:57,599 --> 01:00:59,680
automated vulnerability discovery helps

1651
01:00:59,680 --> 01:01:01,680
in identifying many of those at a large

1652
01:01:01,680 --> 01:01:03,119
scale right so

1653
01:01:03,119 --> 01:01:04,799
uh i we believe that this is a turning

1654
01:01:04,799 --> 01:01:06,799
point for the for the community

1655
01:01:06,799 --> 01:01:08,400
so soon there will be even more

1656
01:01:08,400 --> 01:01:10,079
vulnerabilities found even faster it

1657
01:01:10,079 --> 01:01:11,839
goes back to what we were discussing in

1658
01:01:11,839 --> 01:01:14,480
the previous slide really the the pace

1659
01:01:14,480 --> 01:01:16,079
of vulnerability discovery is only set

1660
01:01:16,079 --> 01:01:18,400
to increase and that has several uh

1661
01:01:18,400 --> 01:01:20,799
implications for the community right

1662
01:01:20,799 --> 01:01:22,720
mitigating these widespread issues

1663
01:01:22,720 --> 01:01:24,559
involves both the device vendors and the

1664
01:01:24,559 --> 01:01:27,839
network operators so um

1665
01:01:27,839 --> 01:01:30,559
it's important advice vendors uh patch

1666
01:01:30,559 --> 01:01:32,480
these issues or hopefully find them even

1667
01:01:32,480 --> 01:01:36,559
before uh devices are actually

1668
01:01:36,559 --> 01:01:39,599
being distributed and so and so on but

1669
01:01:39,599 --> 01:01:41,200
since the word we're living today is

1670
01:01:41,200 --> 01:01:43,359
that this type of an abilities affect

1671
01:01:43,359 --> 01:01:45,599
lots of act legacy but still active

1672
01:01:45,599 --> 01:01:48,160
devices just waiting waiting for patches

1673
01:01:48,160 --> 01:01:49,359
is not a good solution so network

1674
01:01:49,359 --> 01:01:51,359
operators have to do their part as well

1675
01:01:51,359 --> 01:01:55,359
with uh with segmentation with um

1676
01:01:55,359 --> 01:01:58,799
looking at uh

1677
01:01:58,799 --> 01:02:00,640
malicious packets and monitoring the

1678
01:02:00,640 --> 01:02:02,160
network and so on

1679
01:02:02,160 --> 01:02:06,319
so uh if you're interested uh to learn

1680
01:02:06,319 --> 01:02:08,720
more about this type of research

1681
01:02:08,720 --> 01:02:09,839
look at

1682
01:02:09,839 --> 01:02:12,079
forskout's project memorial website and

1683
01:02:12,079 --> 01:02:14,720
the jfrog blog that was also put out

1684
01:02:14,720 --> 01:02:16,480
when we

1685
01:02:16,480 --> 01:02:18,839
disclosed publicly

1686
01:02:18,839 --> 01:02:20,880
infrahold and

1687
01:02:20,880 --> 01:02:22,480
that's what we had to say today thank

1688
01:02:22,480 --> 01:02:24,480
you so much for joining us and we can

1689
01:02:24,480 --> 01:02:26,799
keep the conversation open we'll be

1690
01:02:26,799 --> 01:02:29,440
happy to take uh questions and and

1691
01:02:29,440 --> 01:02:31,680
provide some answers and some discussion

1692
01:02:31,680 --> 01:02:33,359
at the discord channel

1693
01:02:33,359 --> 01:02:35,200
otherwise feel free as well to contact

1694
01:02:35,200 --> 01:02:37,359
us via email or linkedin or whatever you

1695
01:02:37,359 --> 01:02:41,400
want thank you so much

