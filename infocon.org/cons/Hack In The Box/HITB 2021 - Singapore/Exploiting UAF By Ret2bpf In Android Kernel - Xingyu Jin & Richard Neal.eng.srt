1
00:00:12,480 --> 00:00:14,160
hello everyone welcome to our

2
00:00:14,160 --> 00:00:15,839
presentation at the hack in the box

3
00:00:15,839 --> 00:00:18,800
conference today our topic is the art of

4
00:00:18,800 --> 00:00:21,600
exploiting user free by return to bp app

5
00:00:21,600 --> 00:00:24,560
in android kernel

6
00:00:25,359 --> 00:00:27,119
my name is xinjin i am a security

7
00:00:27,119 --> 00:00:30,320
engineer at google i play viracydia do

8
00:00:30,320 --> 00:00:32,238
reverse engineering and hunt endocrine

9
00:00:32,238 --> 00:00:34,079
bugs to make android ecosystem more

10
00:00:34,079 --> 00:00:37,200
skill richer new is my colleague and he

11
00:00:37,200 --> 00:00:39,360
is a staff security engineer and awesome

12
00:00:39,360 --> 00:00:42,399
manager teacher like reverse engineering

13
00:00:42,399 --> 00:00:44,800
especially for reading disassembly

14
00:00:44,800 --> 00:00:48,000
so today we would like to present a deep

15
00:00:48,000 --> 00:00:50,239
dive into a specific android kind of

16
00:00:50,239 --> 00:00:52,480
vulnerability discovered this year

17
00:00:52,480 --> 00:00:53,360
and

18
00:00:53,360 --> 00:00:56,000
more specifically is a user's feedback

19
00:00:56,000 --> 00:00:58,079
that has existed in android common

20
00:00:58,079 --> 00:00:59,840
kernel for use

21
00:00:59,840 --> 00:01:02,960
um here's our agenda we will introduce

22
00:01:02,960 --> 00:01:04,959
the internals of the affected kind of

23
00:01:04,959 --> 00:01:06,880
module in the android camera kernel

24
00:01:06,880 --> 00:01:08,720
including the passive vulnerabilities

25
00:01:08,720 --> 00:01:11,119
and then analyze the user free book

26
00:01:11,119 --> 00:01:14,119
cv2021039i

27
00:01:14,479 --> 00:01:17,600
we will later talk about how to exploit

28
00:01:17,600 --> 00:01:19,680
the vulnerability on our modern android

29
00:01:19,680 --> 00:01:23,040
device including our video demo

30
00:01:23,040 --> 00:01:24,960
richard will talk about

31
00:01:24,960 --> 00:01:26,880
android kind of mitigations and how

32
00:01:26,880 --> 00:01:29,840
google detects an x-ray code at scale by

33
00:01:29,840 --> 00:01:32,000
various approaches

34
00:01:32,000 --> 00:01:34,159
okay so let's take a look at the

35
00:01:34,159 --> 00:01:38,799
affected engine kernel model xdns qt gid

36
00:01:38,799 --> 00:01:42,000
the module is mainly used for checking

37
00:01:42,000 --> 00:01:43,920
the network traffic on a per socket

38
00:01:43,920 --> 00:01:47,680
basis for a unique app since ng3

39
00:01:47,680 --> 00:01:52,079
it is replaced by ebpf since ngq

40
00:01:52,079 --> 00:01:55,040
so only enter pi and lower versions are

41
00:01:55,040 --> 00:01:57,119
affected

42
00:01:57,119 --> 00:01:59,759
basically how it works is that

43
00:01:59,759 --> 00:02:02,079
a user space program

44
00:02:02,079 --> 00:02:04,560
may send the command data to the current

45
00:02:04,560 --> 00:02:06,960
module

46
00:02:07,040 --> 00:02:09,840
such as asking kernel to tag a socket or

47
00:02:09,840 --> 00:02:12,000
on text socket so taken circuit

48
00:02:12,000 --> 00:02:14,160
basically means that we want the entry

49
00:02:14,160 --> 00:02:16,560
kernel to track the specific socket file

50
00:02:16,560 --> 00:02:19,200
descriptor and provide network data

51
00:02:19,200 --> 00:02:21,520
usage information back to the

52
00:02:21,520 --> 00:02:24,000
user space

53
00:02:24,000 --> 00:02:26,480
you may interact with the kind of module

54
00:02:26,480 --> 00:02:29,520
by adb or you may use the

55
00:02:29,520 --> 00:02:32,400
android api from traffic status or other

56
00:02:32,400 --> 00:02:33,599
classes

57
00:02:33,599 --> 00:02:35,599
cool so

58
00:02:35,599 --> 00:02:36,959
now i'll introduce three different

59
00:02:36,959 --> 00:02:40,080
scenario open the module tag the socket

60
00:02:40,080 --> 00:02:43,280
and on text socket and see how

61
00:02:43,280 --> 00:02:46,239
the kernel works

62
00:02:47,040 --> 00:02:50,000
once user space open the current module

63
00:02:50,000 --> 00:02:52,319
the model will allocate to different

64
00:02:52,319 --> 00:02:53,760
structures

65
00:02:53,760 --> 00:02:55,519
and in respect to

66
00:02:55,519 --> 00:02:57,519
preview id and pid

67
00:02:57,519 --> 00:02:59,440
and as you can see there will be only

68
00:02:59,440 --> 00:03:01,440
one unique

69
00:03:01,440 --> 00:03:04,640
uid data attack data structure

70
00:03:04,640 --> 00:03:06,720
but there might be multiple proxy of

71
00:03:06,720 --> 00:03:09,599
data structure for every pid which are

72
00:03:09,599 --> 00:03:12,080
essentially linked to the

73
00:03:12,080 --> 00:03:16,080
uid tag data structure

74
00:03:16,159 --> 00:03:17,280
and

75
00:03:17,280 --> 00:03:20,560
while user space program tries to

76
00:03:20,560 --> 00:03:23,760
tag a socket it has to provide all sorts

77
00:03:23,760 --> 00:03:25,680
of information kind of wants such as

78
00:03:25,680 --> 00:03:29,440
like the sacrifice descriptor use id etc

79
00:03:29,440 --> 00:03:31,680
and the two different data structures

80
00:03:31,680 --> 00:03:34,159
will be allocated in terms of the uid

81
00:03:34,159 --> 00:03:35,920
and pid again

82
00:03:35,920 --> 00:03:36,799
so

83
00:03:36,799 --> 00:03:38,640
first of all the module will find the

84
00:03:38,640 --> 00:03:43,200
corresponding uid tech data based on uid

85
00:03:43,200 --> 00:03:45,360
so kernel will search a global variable

86
00:03:45,360 --> 00:03:47,519
called uidtech data tree

87
00:03:47,519 --> 00:03:50,799
and find the corresponding uidtech data

88
00:03:50,799 --> 00:03:52,080
okay

89
00:03:52,080 --> 00:03:54,959
then a specific structure called tech

90
00:03:54,959 --> 00:03:56,319
underscore wrap

91
00:03:56,319 --> 00:03:58,080
was allocated

92
00:03:58,080 --> 00:04:01,360
and initialized with the tag and the

93
00:04:01,360 --> 00:04:02,959
reference count

94
00:04:02,959 --> 00:04:06,080
and by the way the tag is just a 64-bit

95
00:04:06,080 --> 00:04:08,239
integer also following the similar

96
00:04:08,239 --> 00:04:10,000
pattern the

97
00:04:10,000 --> 00:04:12,159
kernel will find proctoru data for our

98
00:04:12,159 --> 00:04:14,560
global variable and allocate a structure

99
00:04:14,560 --> 00:04:16,880
called socket tag

100
00:04:16,880 --> 00:04:18,560
as you can see the

101
00:04:18,560 --> 00:04:20,238
different circuit tags are linked

102
00:04:20,238 --> 00:04:21,358
together

103
00:04:21,358 --> 00:04:23,759
and they are all from the proxy to data

104
00:04:23,759 --> 00:04:25,840
structure

105
00:04:25,840 --> 00:04:30,560
so for now please remember this subtitle

106
00:04:30,560 --> 00:04:33,759
later we will see a user-free in stock

107
00:04:33,759 --> 00:04:35,759
text structure

108
00:04:35,759 --> 00:04:37,120
so

109
00:04:37,120 --> 00:04:39,520
here is the basic overview of all the

110
00:04:39,520 --> 00:04:41,600
related kernel data structure when a

111
00:04:41,600 --> 00:04:43,199
circuit is tactic

112
00:04:43,199 --> 00:04:46,080
as we mentioned in the last slide

113
00:04:46,080 --> 00:04:48,960
the model will create tag underscore ref

114
00:04:48,960 --> 00:04:52,240
and suck on the skull tag structures

115
00:04:52,240 --> 00:04:55,199
in here and and here

116
00:04:55,199 --> 00:04:57,840
so while a circuit is untacted the

117
00:04:57,840 --> 00:04:59,919
reference count in the attack on on the

118
00:04:59,919 --> 00:05:02,960
skull rep get decreased and the stock

119
00:05:02,960 --> 00:05:05,520
tab is unlinked and later freed by the

120
00:05:05,520 --> 00:05:06,479
kernel

121
00:05:06,479 --> 00:05:07,280
so

122
00:05:07,280 --> 00:05:10,400
you may also embed the basic idea of

123
00:05:10,400 --> 00:05:11,360
how the

124
00:05:11,360 --> 00:05:14,320
cleanup works is that

125
00:05:14,320 --> 00:05:16,880
when user closes the module

126
00:05:16,880 --> 00:05:19,120
all the related stock underscore tag

127
00:05:19,120 --> 00:05:21,759
structure and proxy of data

128
00:05:21,759 --> 00:05:24,720
may be unlinked and free later

129
00:05:24,720 --> 00:05:26,560
since the model was introduced in

130
00:05:26,560 --> 00:05:29,280
android since 2011

131
00:05:29,280 --> 00:05:31,199
there were two vulnerabilities reported

132
00:05:31,199 --> 00:05:33,840
to google in the past

133
00:05:33,840 --> 00:05:38,359
the first one is cv 2016-3800

134
00:05:38,560 --> 00:05:40,800
is a pretty well known vulnerability is

135
00:05:40,800 --> 00:05:43,440
a very important kind of information

136
00:05:43,440 --> 00:05:45,600
issue for leaking the kernel sock

137
00:05:45,600 --> 00:05:47,759
structure address

138
00:05:47,759 --> 00:05:50,720
you may just read the pseudo file system

139
00:05:50,720 --> 00:05:54,400
and the arrow pointer is written to the

140
00:05:54,400 --> 00:05:56,560
user it helps a lot of

141
00:05:56,560 --> 00:05:58,800
experts to make them more stable and

142
00:05:58,800 --> 00:06:01,840
easier to access the endocrine such as

143
00:06:01,840 --> 00:06:04,000
like ping pong expert

144
00:06:04,000 --> 00:06:05,840
the root cause is pretty obvious if you

145
00:06:05,840 --> 00:06:08,240
look at the sequence print app the

146
00:06:08,240 --> 00:06:11,039
format string is not applied properly so

147
00:06:11,039 --> 00:06:13,360
a normal user may be able to

148
00:06:13,360 --> 00:06:16,400
read the wrong partner address

149
00:06:16,400 --> 00:06:20,080
well the other one is a user-free bug on

150
00:06:20,080 --> 00:06:23,600
tag graph2 by risk condition due to

151
00:06:23,600 --> 00:06:24,960
imperfect

152
00:06:24,960 --> 00:06:26,639
locking

153
00:06:26,639 --> 00:06:30,880
as you can see from 2011 to 2020 there

154
00:06:30,880 --> 00:06:33,759
are only two vulnerabilities in this

155
00:06:33,759 --> 00:06:36,639
model and the module got replaced and

156
00:06:36,639 --> 00:06:39,280
things lq by ebpf

157
00:06:39,280 --> 00:06:40,080
so

158
00:06:40,080 --> 00:06:44,560
what can possibly go wrong in 2021

159
00:06:44,560 --> 00:06:47,520
the bug was reported by

160
00:06:47,520 --> 00:06:49,680
extended researcher earlier this year

161
00:06:49,680 --> 00:06:52,479
saying that there is a potential user

162
00:06:52,479 --> 00:06:54,080
free

163
00:06:54,080 --> 00:06:56,560
under certain conditions

164
00:06:56,560 --> 00:06:58,800
there is no proof concept or

165
00:06:58,800 --> 00:07:01,360
exploitation details provided by the

166
00:07:01,360 --> 00:07:03,440
researchers believe

167
00:07:03,440 --> 00:07:05,919
it's impossible to exfoliate on modern

168
00:07:05,919 --> 00:07:07,120
devices

169
00:07:07,120 --> 00:07:08,800
because the hardware

170
00:07:08,800 --> 00:07:10,400
level mitigation

171
00:07:10,400 --> 00:07:11,120
the

172
00:07:11,120 --> 00:07:14,080
user access override is enabled on

173
00:07:14,080 --> 00:07:17,120
kernel 4.14 by default

174
00:07:17,120 --> 00:07:18,639
so

175
00:07:18,639 --> 00:07:21,440
usually android actually will choose to

176
00:07:21,440 --> 00:07:23,840
temporarily adjust the limit so they

177
00:07:23,840 --> 00:07:26,240
actually can use pipe cisco to do

178
00:07:26,240 --> 00:07:29,039
absolutely read and write but there are

179
00:07:29,039 --> 00:07:30,880
a lot of ways to

180
00:07:30,880 --> 00:07:33,680
temper the address limit for instance

181
00:07:33,680 --> 00:07:36,160
you may settle drop or jump

182
00:07:36,160 --> 00:07:38,960
to several well no kernel functions and

183
00:07:38,960 --> 00:07:41,360
linux kernel is very happy to override

184
00:07:41,360 --> 00:07:43,280
the address limit for you

185
00:07:43,280 --> 00:07:45,120
but with the user access override

186
00:07:45,120 --> 00:07:47,840
mitigation enabled it's not very likely

187
00:07:47,840 --> 00:07:50,240
to accelerate the kernel in this way

188
00:07:50,240 --> 00:07:52,400
that's why the external resources

189
00:07:52,400 --> 00:07:54,960
believe the vulnerability may not be

190
00:07:54,960 --> 00:07:58,319
able to be expert on modern devices thus

191
00:07:58,319 --> 00:07:59,759
the google interest security team

192
00:07:59,759 --> 00:08:02,479
decided to investigate the likelihood of

193
00:08:02,479 --> 00:08:04,639
exploitation of this vulnerability and

194
00:08:04,639 --> 00:08:06,879
see if it still works on modern android

195
00:08:06,879 --> 00:08:09,120
devices

196
00:08:09,120 --> 00:08:10,800
when the vote was reported to google

197
00:08:10,800 --> 00:08:12,960
rachel quickly wrote a minimum pop for

198
00:08:12,960 --> 00:08:14,960
kind of crash

199
00:08:14,960 --> 00:08:17,680
as you can see it's very simple

200
00:08:17,680 --> 00:08:21,120
you know just tag socket

201
00:08:21,840 --> 00:08:25,120
untag the socket from a chart process

202
00:08:25,120 --> 00:08:27,680
actually programmed and cannot crash

203
00:08:27,680 --> 00:08:29,360
how it is possible

204
00:08:29,360 --> 00:08:30,720
so

205
00:08:30,720 --> 00:08:32,799
let's take a look closer look at how

206
00:08:32,799 --> 00:08:34,719
untech actually works

207
00:08:34,719 --> 00:08:36,159
because

208
00:08:36,159 --> 00:08:38,559
when a user space program opens the

209
00:08:38,559 --> 00:08:39,599
module

210
00:08:39,599 --> 00:08:44,159
the model will create the pro qtl data

211
00:08:44,159 --> 00:08:46,399
based on the pid

212
00:08:46,399 --> 00:08:47,600
okay

213
00:08:47,600 --> 00:08:50,160
so conor tries to find the corresponding

214
00:08:50,160 --> 00:08:53,120
pro q2 data structure and then unlink

215
00:08:53,120 --> 00:08:56,080
this circuit tag

216
00:08:58,399 --> 00:09:01,279
and free the socket tag structure later

217
00:09:01,279 --> 00:09:03,360
but if you look at the code you may see

218
00:09:03,360 --> 00:09:06,000
that there is a starting check

219
00:09:06,000 --> 00:09:08,480
if the procredia data structure

220
00:09:08,480 --> 00:09:11,519
is not found by pid the model will just

221
00:09:11,519 --> 00:09:13,920
send a complaint here without doing

222
00:09:13,920 --> 00:09:17,120
anything but the socket tag structure is

223
00:09:17,120 --> 00:09:20,160
still on the linked list

224
00:09:20,160 --> 00:09:22,800
since the kernel was due through the

225
00:09:22,800 --> 00:09:25,440
circuit text structure

226
00:09:25,440 --> 00:09:29,200
there is a typical user free here

227
00:09:29,200 --> 00:09:30,959
um

228
00:09:30,959 --> 00:09:32,399
so

229
00:09:32,399 --> 00:09:35,200
when you unpack the socket in entire

230
00:09:35,200 --> 00:09:36,480
process

231
00:09:36,480 --> 00:09:39,440
the kernel module is unable to find the

232
00:09:39,440 --> 00:09:41,680
procured data structure

233
00:09:41,680 --> 00:09:45,279
so essentially it leads to the user-free

234
00:09:45,279 --> 00:09:47,440
so you may have a

235
00:09:47,440 --> 00:09:49,760
two socket tag structure under one

236
00:09:49,760 --> 00:09:52,640
procedure structure where one of this

237
00:09:52,640 --> 00:09:55,040
socket tag is already free

238
00:09:55,040 --> 00:09:57,600
but still resize in the

239
00:09:57,600 --> 00:09:58,800
linked list

240
00:09:58,800 --> 00:10:00,399
okay

241
00:10:00,399 --> 00:10:02,880
cool so let's see how to export the

242
00:10:02,880 --> 00:10:05,279
vulnerability in a modern android pi

243
00:10:05,279 --> 00:10:06,560
device

244
00:10:06,560 --> 00:10:09,600
specifically you may see the

245
00:10:09,600 --> 00:10:12,959
following mitigations are enabled for

246
00:10:12,959 --> 00:10:14,880
android pi devices

247
00:10:14,880 --> 00:10:17,279
like adjust limit check user access

248
00:10:17,279 --> 00:10:18,560
overwrite

249
00:10:18,560 --> 00:10:20,880
slab freelance random and slap release

250
00:10:20,880 --> 00:10:22,399
harden

251
00:10:22,399 --> 00:10:24,959
later i will show a demo on

252
00:10:24,959 --> 00:10:28,160
how to export the xiaomi mi 9 device

253
00:10:28,160 --> 00:10:30,800
with the latest conversion 4.14 for

254
00:10:30,800 --> 00:10:31,920
android pie

255
00:10:31,920 --> 00:10:33,040
with the

256
00:10:33,040 --> 00:10:35,519
aforementioned mitigations

257
00:10:35,519 --> 00:10:36,560
okay

258
00:10:36,560 --> 00:10:37,600
so

259
00:10:37,600 --> 00:10:39,440
first of all if you are not very

260
00:10:39,440 --> 00:10:42,480
familiar with endocrine exploitation

261
00:10:42,480 --> 00:10:44,959
most android devices nowadays use k

262
00:10:44,959 --> 00:10:48,880
malloc 128 as the minimum size of the

263
00:10:48,880 --> 00:10:50,320
slab object

264
00:10:50,320 --> 00:10:51,360
okay

265
00:10:51,360 --> 00:10:55,200
so the size of the object allocated by k

266
00:10:55,200 --> 00:10:59,120
malloc is actually 128 bytes

267
00:10:59,120 --> 00:11:01,839
the first kind of system we want to

268
00:11:01,839 --> 00:11:04,560
abuse is event fd

269
00:11:04,560 --> 00:11:06,079
as you can see

270
00:11:06,079 --> 00:11:07,440
um the

271
00:11:07,440 --> 00:11:08,399
count

272
00:11:08,399 --> 00:11:11,440
actually overlapped the this hat in the

273
00:11:11,440 --> 00:11:13,200
socket tag structure

274
00:11:13,200 --> 00:11:15,120
okay

275
00:11:15,120 --> 00:11:16,240
the

276
00:11:16,240 --> 00:11:19,279
idea for kernel keep address leak is

277
00:11:19,279 --> 00:11:20,160
that

278
00:11:20,160 --> 00:11:23,440
one circuit tag is already free

279
00:11:23,440 --> 00:11:25,040
you can we can

280
00:11:25,040 --> 00:11:26,160
spray

281
00:11:26,160 --> 00:11:29,680
event fd to make sure there is an event

282
00:11:29,680 --> 00:11:31,200
adv structure

283
00:11:31,200 --> 00:11:34,399
occupy the free circuit tag structure

284
00:11:34,399 --> 00:11:38,480
so now you see two sub two socket tag

285
00:11:38,480 --> 00:11:40,160
structure linked together and one of

286
00:11:40,160 --> 00:11:41,680
them

287
00:11:41,680 --> 00:11:44,640
is actually an event of this structure

288
00:11:44,640 --> 00:11:46,959
uh normally on tax stock attack in the

289
00:11:46,959 --> 00:11:48,079
right side

290
00:11:48,079 --> 00:11:49,600
so the count

291
00:11:49,600 --> 00:11:52,079
from the ift structure is now

292
00:11:52,079 --> 00:11:54,639
overwritten as the address of the list

293
00:11:54,639 --> 00:11:57,680
hack by unlim primitive

294
00:11:57,680 --> 00:11:58,720
okay

295
00:11:58,720 --> 00:11:59,600
so

296
00:11:59,600 --> 00:12:02,160
now you may get the event fd count

297
00:12:02,160 --> 00:12:05,760
by reading the certified system

298
00:12:05,760 --> 00:12:07,920
now we will talk about how to convert

299
00:12:07,920 --> 00:12:10,800
the heap adjust information leak

300
00:12:10,800 --> 00:12:13,279
into a specialty free

301
00:12:13,279 --> 00:12:15,920
in the entry point

302
00:12:15,920 --> 00:12:19,279
basically a very nice idea is that

303
00:12:19,279 --> 00:12:22,560
the way you can get double free is to

304
00:12:22,560 --> 00:12:25,360
grab to identical stock attack

305
00:12:25,360 --> 00:12:27,760
so kernel will eventually

306
00:12:27,760 --> 00:12:30,639
unlink all the tags and three of them

307
00:12:30,639 --> 00:12:31,680
so

308
00:12:31,680 --> 00:12:34,720
you might get a very nice

309
00:12:34,720 --> 00:12:38,079
delta free primitive but

310
00:12:38,079 --> 00:12:40,800
um obviously the kind of crowds because

311
00:12:40,800 --> 00:12:41,920
there are

312
00:12:41,920 --> 00:12:43,760
several security checks

313
00:12:43,760 --> 00:12:45,279
um

314
00:12:45,279 --> 00:12:48,000
for example if we crop a subtext

315
00:12:48,000 --> 00:12:49,279
structure

316
00:12:49,279 --> 00:12:50,839
with invalid

317
00:12:50,839 --> 00:12:54,800
tag the kernel crashes because the

318
00:12:54,800 --> 00:12:56,880
corresponding text real structure

319
00:12:56,880 --> 00:12:58,720
doesn't exist

320
00:12:58,720 --> 00:13:01,360
and if we create two identical

321
00:13:01,360 --> 00:13:03,839
circuit text structure

322
00:13:03,839 --> 00:13:04,560
the

323
00:13:04,560 --> 00:13:08,000
reference code will become invalid so

324
00:13:08,000 --> 00:13:10,959
kernel will crash too

325
00:13:10,959 --> 00:13:15,040
okay so therefore the approach to bypass

326
00:13:15,040 --> 00:13:17,200
on security check is to create several

327
00:13:17,200 --> 00:13:19,600
normal circuit text structures and

328
00:13:19,600 --> 00:13:22,079
steal their tags

329
00:13:22,079 --> 00:13:23,519
here is the

330
00:13:23,519 --> 00:13:26,240
um the way i figure out that

331
00:13:26,240 --> 00:13:27,760
uh first of all

332
00:13:27,760 --> 00:13:30,320
uh untagged the circuit tag b

333
00:13:30,320 --> 00:13:32,560
from a chart process so you get a user

334
00:13:32,560 --> 00:13:36,000
free okay and then the next step is to

335
00:13:36,000 --> 00:13:39,040
spread the event fd to occupy the free

336
00:13:39,040 --> 00:13:40,639
subject text structure

337
00:13:40,639 --> 00:13:41,600
okay

338
00:13:41,600 --> 00:13:42,959
and then

339
00:13:42,959 --> 00:13:45,360
free the next circuit texture to circuit

340
00:13:45,360 --> 00:13:47,279
text structure c

341
00:13:47,279 --> 00:13:49,600
and because of the only primitive the

342
00:13:49,600 --> 00:13:51,680
circuit tag structure d

343
00:13:51,680 --> 00:13:55,120
uh the its address gets licked in

344
00:13:55,120 --> 00:13:57,040
following this way

345
00:13:57,040 --> 00:14:00,160
you can also link the address of the

346
00:14:00,160 --> 00:14:02,160
list help

347
00:14:02,160 --> 00:14:03,279
there are

348
00:14:03,279 --> 00:14:05,199
als another three different tag

349
00:14:05,199 --> 00:14:08,480
structure e f and g in the linked list

350
00:14:08,480 --> 00:14:10,880
um we will talk about them later

351
00:14:10,880 --> 00:14:11,680
okay

352
00:14:11,680 --> 00:14:15,120
so the key point here is that we have a

353
00:14:15,120 --> 00:14:18,240
socket tag address

354
00:14:18,240 --> 00:14:20,240
and

355
00:14:20,240 --> 00:14:22,800
this header address

356
00:14:22,800 --> 00:14:24,639
cool so

357
00:14:24,639 --> 00:14:27,120
in order to bypass the grid check we

358
00:14:27,120 --> 00:14:28,639
now spray to

359
00:14:28,639 --> 00:14:31,519
a spread first two objects and

360
00:14:31,519 --> 00:14:35,040
impersonate the tag so the original tag

361
00:14:35,040 --> 00:14:37,600
are b and d

362
00:14:37,600 --> 00:14:40,399
and now they are becoming

363
00:14:40,399 --> 00:14:41,760
e and f

364
00:14:41,760 --> 00:14:43,600
okay

365
00:14:43,600 --> 00:14:46,639
also we also unlink efg from the

366
00:14:46,639 --> 00:14:48,240
procedure data

367
00:14:48,240 --> 00:14:51,680
to make sure the tag rep and the

368
00:14:51,680 --> 00:14:55,199
reference count will remain valid

369
00:14:55,199 --> 00:14:56,720
okay

370
00:14:56,720 --> 00:14:59,279
we will also have to free uh

371
00:14:59,279 --> 00:15:01,680
these two crafty objects because the

372
00:15:01,680 --> 00:15:04,560
first eight bytes of the object must be

373
00:15:04,560 --> 00:15:06,480
a valid address

374
00:15:06,480 --> 00:15:09,199
otherwise the rb erase operation might

375
00:15:09,199 --> 00:15:10,839
fail

376
00:15:10,839 --> 00:15:14,240
okay um cool in this way we may free the

377
00:15:14,240 --> 00:15:16,320
crafty socket tag structure without

378
00:15:16,320 --> 00:15:18,880
trigging any kind of checks

379
00:15:18,880 --> 00:15:20,959
i will deliver you this primitive for

380
00:15:20,959 --> 00:15:22,480
performing a

381
00:15:22,480 --> 00:15:25,519
special kernel level 3.

382
00:15:25,519 --> 00:15:27,680
by the way for devices still vulnerable

383
00:15:27,680 --> 00:15:31,479
to cv 2016-3800

384
00:15:31,600 --> 00:15:34,160
exporting the kernel might be

385
00:15:34,160 --> 00:15:37,199
much easier because we can abuse a

386
00:15:37,199 --> 00:15:39,519
socket push function in multi-cleaning

387
00:15:39,519 --> 00:15:40,399
process

388
00:15:40,399 --> 00:15:43,360
and craft a corrupted kernel

389
00:15:43,360 --> 00:15:45,519
substructure

390
00:15:45,519 --> 00:15:47,839
and and if you're doing so

391
00:15:47,839 --> 00:15:50,480
you are following the pattern of the

392
00:15:50,480 --> 00:15:52,839
pinpoint exploit or other well no

393
00:15:52,839 --> 00:15:56,320
exploit corrupting corrupt corrupting

394
00:15:56,320 --> 00:15:57,279
the

395
00:15:57,279 --> 00:15:59,519
circuit tag structure

396
00:15:59,519 --> 00:16:01,839
here the step two leaking kindness error

397
00:16:01,839 --> 00:16:03,920
if you check the size of the subtext

398
00:16:03,920 --> 00:16:06,800
structure is 64 bytes

399
00:16:06,800 --> 00:16:11,759
so luckily a 128 by slab object can

400
00:16:11,759 --> 00:16:14,240
host two circuit text gestures

401
00:16:14,240 --> 00:16:18,639
and thus we may impersonate the tag g

402
00:16:18,639 --> 00:16:20,880
and crop another circuit text structure

403
00:16:20,880 --> 00:16:24,480
in the same slab object

404
00:16:24,480 --> 00:16:26,399
okay so

405
00:16:26,399 --> 00:16:29,040
when the model is doing cleanup it will

406
00:16:29,040 --> 00:16:31,600
free the socket's tag structure

407
00:16:31,600 --> 00:16:33,519
and free the socket text structure in

408
00:16:33,519 --> 00:16:35,279
the middle of the

409
00:16:35,279 --> 00:16:36,480
slab object

410
00:16:36,480 --> 00:16:38,720
consequently which will help us

411
00:16:38,720 --> 00:16:40,800
reconnect there are

412
00:16:40,800 --> 00:16:42,079
okay

413
00:16:42,079 --> 00:16:44,800
cool so

414
00:16:45,600 --> 00:16:47,440
consider spring the slab at the

415
00:16:47,440 --> 00:16:49,199
beginning of the

416
00:16:49,199 --> 00:16:50,560
expert

417
00:16:50,560 --> 00:16:52,800
so

418
00:16:53,360 --> 00:16:55,199
in and then

419
00:16:55,199 --> 00:16:58,639
keep opening a lot of proc cpu info so

420
00:16:58,639 --> 00:17:00,800
kernel will allocate a number of

421
00:17:00,800 --> 00:17:03,040
signifier structures

422
00:17:03,040 --> 00:17:06,480
and because of the w3 primitive

423
00:17:06,480 --> 00:17:08,640
two signal file structures are very

424
00:17:08,640 --> 00:17:10,880
likely to overlap each other in this

425
00:17:10,880 --> 00:17:12,559
case

426
00:17:12,559 --> 00:17:13,599
cool

427
00:17:13,599 --> 00:17:17,039
so the overlapped event fd and sequence

428
00:17:17,039 --> 00:17:18,480
file structures

429
00:17:18,480 --> 00:17:23,039
leads to a very interesting result that

430
00:17:23,039 --> 00:17:26,559
the count from the event fd now becomes

431
00:17:26,559 --> 00:17:28,480
a sequence operation

432
00:17:28,480 --> 00:17:29,520
okay

433
00:17:29,520 --> 00:17:31,039
and

434
00:17:31,039 --> 00:17:33,440
very luckily the spin lock overlaps each

435
00:17:33,440 --> 00:17:34,400
other

436
00:17:34,400 --> 00:17:37,440
so this spin lock from the event ft

437
00:17:37,440 --> 00:17:38,640
still works

438
00:17:38,640 --> 00:17:42,000
and we can read the sequence operation

439
00:17:42,000 --> 00:17:45,120
from the event ft by study file system

440
00:17:45,120 --> 00:17:46,640
again

441
00:17:46,640 --> 00:17:49,679
and by doing so we can successfully leak

442
00:17:49,679 --> 00:17:52,320
kernel sks error

443
00:17:52,320 --> 00:17:55,200
from midnight device here

444
00:17:55,200 --> 00:17:58,160
so if this slap release is not hardened

445
00:17:58,160 --> 00:17:59,120
you may

446
00:17:59,120 --> 00:18:01,440
abuse the free primitive to do kernel

447
00:18:01,440 --> 00:18:03,360
space mirror attack

448
00:18:03,360 --> 00:18:05,360
um unfortunately the mitigation is

449
00:18:05,360 --> 00:18:08,799
enabled in united by so abusing the

450
00:18:08,799 --> 00:18:12,240
double free primitive directly is not

451
00:18:12,240 --> 00:18:15,200
very possible for me

452
00:18:15,200 --> 00:18:16,960
there are also other candidates such as

453
00:18:16,960 --> 00:18:18,160
using the

454
00:18:18,160 --> 00:18:19,600
socket put

455
00:18:19,600 --> 00:18:21,440
where you may control the circuit

456
00:18:21,440 --> 00:18:23,039
structure

457
00:18:23,039 --> 00:18:26,160
i would say it is possible to disable

458
00:18:26,160 --> 00:18:29,679
acid linux and kptl restrictions but it

459
00:18:29,679 --> 00:18:31,200
depends on

460
00:18:31,200 --> 00:18:33,919
kernel image

461
00:18:34,240 --> 00:18:35,120
okay

462
00:18:35,120 --> 00:18:38,400
cool so uh my approach is to

463
00:18:38,400 --> 00:18:40,480
override the sequence operation so

464
00:18:40,480 --> 00:18:43,280
sequence operation contains several kind

465
00:18:43,280 --> 00:18:45,600
of function pointer so

466
00:18:45,600 --> 00:18:47,600
time tempering the sequence operation

467
00:18:47,600 --> 00:18:50,880
might be a king interest for us

468
00:18:50,880 --> 00:18:52,480
okay so

469
00:18:52,480 --> 00:18:53,760
let's talk about

470
00:18:53,760 --> 00:18:57,120
event id again not only event fd

471
00:18:57,120 --> 00:18:59,280
can leak kernel information to us but we

472
00:18:59,280 --> 00:19:03,200
can also write data to event fd

473
00:19:03,200 --> 00:19:04,720
so

474
00:19:04,720 --> 00:19:07,039
in this case we can control the count

475
00:19:07,039 --> 00:19:09,760
from the event fd which is now

476
00:19:09,760 --> 00:19:11,039
equivalent

477
00:19:11,039 --> 00:19:13,280
to override the sequence operation

478
00:19:13,280 --> 00:19:15,679
because the these two structures are

479
00:19:15,679 --> 00:19:17,520
overlapped with each other

480
00:19:17,520 --> 00:19:19,919
but since we have a lot of file

481
00:19:19,919 --> 00:19:21,360
descriptor

482
00:19:21,360 --> 00:19:25,679
which open the cpu info so the question

483
00:19:25,679 --> 00:19:27,120
here is that

484
00:19:27,120 --> 00:19:29,440
how can we find the file description of

485
00:19:29,440 --> 00:19:30,799
the overlapped

486
00:19:30,799 --> 00:19:33,520
sequence file object

487
00:19:33,520 --> 00:19:36,720
so my solution is to override the cpu

488
00:19:36,720 --> 00:19:39,760
info operation to cancel operation

489
00:19:39,760 --> 00:19:42,160
and then read data from every file

490
00:19:42,160 --> 00:19:43,360
descriptor

491
00:19:43,360 --> 00:19:45,200
then we may find the

492
00:19:45,200 --> 00:19:46,480
corresponding

493
00:19:46,480 --> 00:19:48,640
white explorer because one of the

494
00:19:48,640 --> 00:19:51,200
firefight descriptor may print something

495
00:19:51,200 --> 00:19:53,520
different

496
00:19:53,520 --> 00:19:55,360
so the next step is to control the

497
00:19:55,360 --> 00:19:56,400
sequence

498
00:19:56,400 --> 00:20:00,240
operation we can simply overwrite the

499
00:20:00,240 --> 00:20:01,760
sequence operation

500
00:20:01,760 --> 00:20:05,039
to a control slab object and initially

501
00:20:05,039 --> 00:20:06,559
we can just fill

502
00:20:06,559 --> 00:20:08,640
the surface operation with

503
00:20:08,640 --> 00:20:12,400
you know something random like that beef

504
00:20:12,400 --> 00:20:14,799
so we can validate that we can

505
00:20:14,799 --> 00:20:18,159
now control the kernel fp from the kind

506
00:20:18,159 --> 00:20:22,720
of crash down okay cool

507
00:20:22,720 --> 00:20:23,600
and

508
00:20:23,600 --> 00:20:25,520
as we mentioned before the challenge

509
00:20:25,520 --> 00:20:27,360
here is that

510
00:20:27,360 --> 00:20:30,000
how can we crop a

511
00:20:30,000 --> 00:20:32,840
sequence operation to control the kernel

512
00:20:32,840 --> 00:20:37,520
ip and perform escalation privilege

513
00:20:37,520 --> 00:20:40,240
we might need to spray the

514
00:20:40,240 --> 00:20:42,880
sequence file structure again in order

515
00:20:42,880 --> 00:20:44,799
to ask kernel to

516
00:20:44,799 --> 00:20:46,880
use the crafty sequence operation

517
00:20:46,880 --> 00:20:49,840
correctly otherwise it kind of might

518
00:20:49,840 --> 00:20:52,158
crash

519
00:20:52,400 --> 00:20:55,039
so if the user access override is not

520
00:20:55,039 --> 00:20:58,000
enabled we may use blob gadget

521
00:20:58,000 --> 00:21:01,039
in the kernel get stock up to grizzly

522
00:21:01,039 --> 00:21:03,520
temper the adjusted limit

523
00:21:03,520 --> 00:21:05,440
but unfortunately it doesn't work on

524
00:21:05,440 --> 00:21:08,880
kernel 4.14 because the

525
00:21:08,880 --> 00:21:11,679
kernel will check the address limit for

526
00:21:11,679 --> 00:21:13,120
a resistor

527
00:21:13,120 --> 00:21:16,080
and kernel enables user access override

528
00:21:16,080 --> 00:21:18,880
which is a hardware level mitigation

529
00:21:18,880 --> 00:21:21,919
so we must find another way to properly

530
00:21:21,919 --> 00:21:23,919
fill the glove gadget

531
00:21:23,919 --> 00:21:24,880
so

532
00:21:24,880 --> 00:21:27,520
here is the ultimate drop

533
00:21:27,520 --> 00:21:31,679
and we also call it the return to bpl

534
00:21:31,679 --> 00:21:34,000
and as mentioned by project zero uh we

535
00:21:34,000 --> 00:21:35,360
can invoke

536
00:21:35,360 --> 00:21:37,280
an internal function

537
00:21:37,280 --> 00:21:39,840
called bpf on the scope prop underscore

538
00:21:39,840 --> 00:21:41,600
rom

539
00:21:41,600 --> 00:21:45,440
as the ultimate row so the basic idea

540
00:21:45,440 --> 00:21:48,240
here is that

541
00:21:48,240 --> 00:21:51,440
if the second argument is the address of

542
00:21:51,440 --> 00:21:53,919
the b3f instructions

543
00:21:53,919 --> 00:21:56,159
then the current is happy to execute

544
00:21:56,159 --> 00:21:58,799
optional bpaf instructions

545
00:21:58,799 --> 00:22:00,240
without any

546
00:22:00,240 --> 00:22:02,799
kinds of verification so you can do

547
00:22:02,799 --> 00:22:04,480
everything you want

548
00:22:04,480 --> 00:22:05,840
um

549
00:22:05,840 --> 00:22:08,320
so as a consequence um

550
00:22:08,320 --> 00:22:10,640
now you can get an actual kind of green

551
00:22:10,640 --> 00:22:13,120
and write primitive and for instance you

552
00:22:13,120 --> 00:22:15,440
may disable the

553
00:22:15,440 --> 00:22:18,159
kptr right check and essay linux in this

554
00:22:18,159 --> 00:22:20,320
way

555
00:22:20,320 --> 00:22:23,760
so here is the job cache field

556
00:22:23,760 --> 00:22:24,640
to

557
00:22:24,640 --> 00:22:27,919
do the return to bpf

558
00:22:27,919 --> 00:22:29,120
um

559
00:22:29,120 --> 00:22:32,320
and here the the results of

560
00:22:32,320 --> 00:22:35,520
this so disable the assay linux

561
00:22:35,520 --> 00:22:36,720
okay

562
00:22:36,720 --> 00:22:40,640
so uh finally we can get a rule show

563
00:22:40,640 --> 00:22:41,600
by

564
00:22:41,600 --> 00:22:45,120
sql the upgrade bpf instructions again

565
00:22:45,120 --> 00:22:46,080
and

566
00:22:46,080 --> 00:22:48,480
then hammer the cross structure by

567
00:22:48,480 --> 00:22:49,840
purecrack

568
00:22:49,840 --> 00:22:51,440
okay

569
00:22:51,440 --> 00:22:54,240
these bff instructions are just 128

570
00:22:54,240 --> 00:22:56,880
bytes so it just fits for a

571
00:22:56,880 --> 00:23:00,640
slab 128 object

572
00:23:00,640 --> 00:23:01,440
cool

573
00:23:01,440 --> 00:23:02,480
so

574
00:23:02,480 --> 00:23:04,400
now this is probably the most exciting

575
00:23:04,400 --> 00:23:07,679
part during this presentation i can find

576
00:23:07,679 --> 00:23:10,400
midnight device in less than seconds and

577
00:23:10,400 --> 00:23:13,120
that and then we can have

578
00:23:13,120 --> 00:23:16,120
russia

579
00:23:24,960 --> 00:23:28,480
so now we get a rusher

580
00:23:33,760 --> 00:23:36,480
cool so now please work on richard for

581
00:23:36,480 --> 00:23:38,799
the rest of the presentation

582
00:23:38,799 --> 00:23:40,960
now that xingyu has looked in detail at

583
00:23:40,960 --> 00:23:42,960
how he exploited the vulnerability and

584
00:23:42,960 --> 00:23:45,279
the problems he had to overcome i'll

585
00:23:45,279 --> 00:23:46,960
look at some of the mitigations that

586
00:23:46,960 --> 00:23:49,440
make exploitation here more difficult or

587
00:23:49,440 --> 00:23:50,480
impossible

588
00:23:50,480 --> 00:23:52,159
and then move on to reviewing some of

589
00:23:52,159 --> 00:23:54,320
our defensive systems that help us find

590
00:23:54,320 --> 00:23:57,760
malicious software and exploits

591
00:23:57,760 --> 00:24:00,799
starting off with kernel mitigations

592
00:24:00,799 --> 00:24:02,880
the first one we will look at is a linux

593
00:24:02,880 --> 00:24:04,960
kernel compilation setting that affects

594
00:24:04,960 --> 00:24:06,559
the pointers in the free lists

595
00:24:06,559 --> 00:24:09,120
maintained by memory management

596
00:24:09,120 --> 00:24:13,600
added in linux 4.14 in november 2017

597
00:24:13,600 --> 00:24:15,919
one of the things config slab free list

598
00:24:15,919 --> 00:24:18,880
hardens does is to xor the free list

599
00:24:18,880 --> 00:24:21,279
pointer in slug caches with a per cache

600
00:24:21,279 --> 00:24:22,880
random value

601
00:24:22,880 --> 00:24:25,039
this makes exploiting free list pointer

602
00:24:25,039 --> 00:24:27,600
overrides more difficult as unless the

603
00:24:27,600 --> 00:24:30,000
attacker also knows the xor value they

604
00:24:30,000 --> 00:24:32,480
don't get control of the memory address

605
00:24:32,480 --> 00:24:34,720
this mitigation has very low performance

606
00:24:34,720 --> 00:24:36,080
overhead

607
00:24:36,080 --> 00:24:38,480
the mitigation can be bypassed using the

608
00:24:38,480 --> 00:24:41,039
signal fd technique shown on the slide

609
00:24:41,039 --> 00:24:42,880
and described earlier

610
00:24:42,880 --> 00:24:45,520
spraying signal fd context structures

611
00:24:45,520 --> 00:24:48,000
allows a mostly user-specified value to

612
00:24:48,000 --> 00:24:50,640
be set by the mask argument

613
00:24:50,640 --> 00:24:52,960
i say mostly because two additional

614
00:24:52,960 --> 00:24:54,960
known bits will be set in the value that

615
00:24:54,960 --> 00:24:56,960
is written so the attacker does not have

616
00:24:56,960 --> 00:24:58,960
complete control over it

617
00:24:58,960 --> 00:25:00,799
this does allow the attacker to mostly

618
00:25:00,799 --> 00:25:02,799
control the important value in the sock

619
00:25:02,799 --> 00:25:05,279
tag structure so detection of the list

620
00:25:05,279 --> 00:25:07,760
corruption can be avoided

621
00:25:07,760 --> 00:25:09,840
other kernel structures may allow user

622
00:25:09,840 --> 00:25:12,000
mode some degree of control over data at

623
00:25:12,000 --> 00:25:14,880
particular offsets for other exploits

624
00:25:14,880 --> 00:25:17,200
using the multicast group join operation

625
00:25:17,200 --> 00:25:21,080
as an example of this ccbe

626
00:25:21,080 --> 00:25:23,200
2017-8890 for which there are a number

627
00:25:23,200 --> 00:25:28,200
of proof of concepts available on github

628
00:25:28,400 --> 00:25:31,120
kernel electric fence is a low overhead

629
00:25:31,120 --> 00:25:33,360
sampling based memory safety error

630
00:25:33,360 --> 00:25:37,440
detector introduced into linux in 2020

631
00:25:37,440 --> 00:25:40,320
it detects out of bounds heap access use

632
00:25:40,320 --> 00:25:43,520
after free and invalid free errors

633
00:25:43,520 --> 00:25:45,919
k fence uses a sampling interval time to

634
00:25:45,919 --> 00:25:48,159
determine whether to apply guards to a

635
00:25:48,159 --> 00:25:50,400
memory allocation when the sample

636
00:25:50,400 --> 00:25:52,480
interval is reached the next memory

637
00:25:52,480 --> 00:25:54,799
allocation made will be guarded and the

638
00:25:54,799 --> 00:25:57,120
sample interval is reset

639
00:25:57,120 --> 00:25:59,520
a guarded memory allocation requires two

640
00:25:59,520 --> 00:26:01,919
additional page table entries there is a

641
00:26:01,919 --> 00:26:04,559
page of memory for the allocation itself

642
00:26:04,559 --> 00:26:07,600
and a guard page either side of this one

643
00:26:07,600 --> 00:26:09,760
the actual memory allocation is made

644
00:26:09,760 --> 00:26:11,520
either at the beginning or the end of

645
00:26:11,520 --> 00:26:13,279
the page it is in

646
00:26:13,279 --> 00:26:15,600
the remainder of this page is not used

647
00:26:15,600 --> 00:26:18,000
for other allocations but is filled with

648
00:26:18,000 --> 00:26:20,080
no patterns to enable detecting

649
00:26:20,080 --> 00:26:22,799
incorrect rights into this area

650
00:26:22,799 --> 00:26:24,960
other underflows or overflows will be

651
00:26:24,960 --> 00:26:27,679
caught by the guard pages

652
00:26:27,679 --> 00:26:29,840
k fence will not detect every memory

653
00:26:29,840 --> 00:26:32,080
safety error that happens as owing to

654
00:26:32,080 --> 00:26:33,679
the sampling interval not every

655
00:26:33,679 --> 00:26:35,679
allocation will be guarded

656
00:26:35,679 --> 00:26:38,000
an individual system is very unlikely to

657
00:26:38,000 --> 00:26:39,760
apply guards to a given memory

658
00:26:39,760 --> 00:26:41,039
allocation

659
00:26:41,039 --> 00:26:43,919
however given enough systems running it

660
00:26:43,919 --> 00:26:46,000
code paths which cause errors will get

661
00:26:46,000 --> 00:26:48,000
exercised with guards applied to those

662
00:26:48,000 --> 00:26:51,520
allocations so issues will be identified

663
00:26:51,520 --> 00:26:53,440
as well as detecting the memory safety

664
00:26:53,440 --> 00:26:55,600
errors moving some blocks out of the

665
00:26:55,600 --> 00:26:57,760
normal heap area may affect the

666
00:26:57,760 --> 00:27:00,480
reliability of some exploits as memory

667
00:27:00,480 --> 00:27:04,880
layout cannot be so precisely controlled

668
00:27:05,600 --> 00:27:07,120
a common technique in kernel

669
00:27:07,120 --> 00:27:09,440
exploitation was to overwrite the user

670
00:27:09,440 --> 00:27:11,919
mode address limit stored in the kernel

671
00:27:11,919 --> 00:27:13,919
the address limit was used by the kernel

672
00:27:13,919 --> 00:27:15,919
to check whether an address provided by

673
00:27:15,919 --> 00:27:18,640
user mode via a syscall was allowable or

674
00:27:18,640 --> 00:27:21,360
safe to access i.e whether it was a user

675
00:27:21,360 --> 00:27:23,200
mode address or not

676
00:27:23,200 --> 00:27:25,520
addresses below the limit are okay

677
00:27:25,520 --> 00:27:28,000
addresses above the limit or not

678
00:27:28,000 --> 00:27:29,360
if the address limit could be

679
00:27:29,360 --> 00:27:32,080
overwritten by -1 for example then the

680
00:27:32,080 --> 00:27:33,919
colonel would think that it was okay for

681
00:27:33,919 --> 00:27:36,960
user modes to access kernel addresses

682
00:27:36,960 --> 00:27:38,640
having overwritten the address limit

683
00:27:38,640 --> 00:27:41,360
using an exploit to read kernel memory

684
00:27:41,360 --> 00:27:43,440
from user mode a pipe would then be

685
00:27:43,440 --> 00:27:44,799
created

686
00:27:44,799 --> 00:27:47,360
next a write syscall for the pipe using

687
00:27:47,360 --> 00:27:49,520
a kernel memory address for its buffer

688
00:27:49,520 --> 00:27:51,600
would copy from the desired kernel

689
00:27:51,600 --> 00:27:53,919
memory into the pipe buffer

690
00:27:53,919 --> 00:27:56,159
this would be followed by a read syscall

691
00:27:56,159 --> 00:27:58,000
which would read the kernel data from

692
00:27:58,000 --> 00:28:00,240
the pipe buffer and place it into the

693
00:28:00,240 --> 00:28:02,640
user mode buffer provided

694
00:28:02,640 --> 00:28:04,720
a similar two-step process can be used

695
00:28:04,720 --> 00:28:07,200
to write to kernel memory the right

696
00:28:07,200 --> 00:28:09,360
syscall writes data into the pipe's

697
00:28:09,360 --> 00:28:11,760
buffer then the read syscall reads from

698
00:28:11,760 --> 00:28:15,039
the pipe into a kernel address

699
00:28:15,039 --> 00:28:16,799
this exploitation technique was

700
00:28:16,799 --> 00:28:19,279
mitigated using arm's user access

701
00:28:19,279 --> 00:28:20,799
override bit

702
00:28:20,799 --> 00:28:24,240
uao changes the behavior of the ldtr and

703
00:28:24,240 --> 00:28:26,880
sttr instructions when they are used by

704
00:28:26,880 --> 00:28:28,880
the kernel to perform memory copy

705
00:28:28,880 --> 00:28:32,000
operations for example those required by

706
00:28:32,000 --> 00:28:34,240
the read write syscalls in the example

707
00:28:34,240 --> 00:28:36,080
given just now

708
00:28:36,080 --> 00:28:38,320
if the uao bit is set then the

709
00:28:38,320 --> 00:28:40,640
instructions behave as privileged load

710
00:28:40,640 --> 00:28:43,679
and store and cannot access user memory

711
00:28:43,679 --> 00:28:46,399
if the uao bit is clear the instructions

712
00:28:46,399 --> 00:28:48,320
are unprivileged and cannot access

713
00:28:48,320 --> 00:28:51,520
kernel memory so whichever state the uao

714
00:28:51,520 --> 00:28:53,520
bit is in one of the read or write

715
00:28:53,520 --> 00:28:55,840
operations will fail and the attacker

716
00:28:55,840 --> 00:28:58,080
cannot access kernel memory using this

717
00:28:58,080 --> 00:28:59,600
technique

718
00:28:59,600 --> 00:29:01,679
this mitigation can be worked around

719
00:29:01,679 --> 00:29:03,919
using the return to bpf technique

720
00:29:03,919 --> 00:29:05,600
described earlier

721
00:29:05,600 --> 00:29:07,360
address limit protection has also

722
00:29:07,360 --> 00:29:09,840
changed in more recent versions of linux

723
00:29:09,840 --> 00:29:11,440
resulting in the removal of this

724
00:29:11,440 --> 00:29:14,559
configuration option

725
00:29:15,600 --> 00:29:17,679
from the explanation of the exploitation

726
00:29:17,679 --> 00:29:20,159
process earlier you may remember the

727
00:29:20,159 --> 00:29:23,200
seek file structure was used to help

728
00:29:23,200 --> 00:29:26,159
overlapping event fd context and seek

729
00:29:26,159 --> 00:29:29,120
file allows you to use the seek file

730
00:29:29,120 --> 00:29:32,000
structures seek operation member as the

731
00:29:32,000 --> 00:29:35,039
event fd context structures count member

732
00:29:35,039 --> 00:29:36,799
and therefore leak kernel memory

733
00:29:36,799 --> 00:29:38,159
addresses

734
00:29:38,159 --> 00:29:40,880
later on in the exploitation process

735
00:29:40,880 --> 00:29:43,600
overriding seek operations was used to

736
00:29:43,600 --> 00:29:45,600
demonstrate control of the instruction

737
00:29:45,600 --> 00:29:47,039
pointer

738
00:29:47,039 --> 00:29:49,279
seek file has been used in many linux

739
00:29:49,279 --> 00:29:51,440
kernel exploits moving it into a

740
00:29:51,440 --> 00:29:53,440
dedicated cache would obviously make

741
00:29:53,440 --> 00:29:55,120
techniques such as the ones mentioned

742
00:29:55,120 --> 00:29:57,440
earlier stop working as it would not be

743
00:29:57,440 --> 00:29:59,679
possible to confuse seek file structures

744
00:29:59,679 --> 00:30:01,200
with other structures

745
00:30:01,200 --> 00:30:03,120
this would have some impact on memory

746
00:30:03,120 --> 00:30:05,520
usage

747
00:30:06,240 --> 00:30:08,320
control flow integrity tries to make

748
00:30:08,320 --> 00:30:10,480
sure that indirect calls and function

749
00:30:10,480 --> 00:30:13,440
returns go where they are supposed to

750
00:30:13,440 --> 00:30:15,679
without this attackers can hijack the

751
00:30:15,679 --> 00:30:18,080
expected control flow of a program or in

752
00:30:18,080 --> 00:30:20,240
this case the kernel by changing

753
00:30:20,240 --> 00:30:22,559
function pointer addresses or return

754
00:30:22,559 --> 00:30:24,000
addresses

755
00:30:24,000 --> 00:30:26,399
cfi is implemented for android using

756
00:30:26,399 --> 00:30:29,039
clang and is performed at the final link

757
00:30:29,039 --> 00:30:31,120
stage so all information is available

758
00:30:31,120 --> 00:30:32,960
regarding function addresses and their

759
00:30:32,960 --> 00:30:34,000
callers

760
00:30:34,000 --> 00:30:35,840
this does somewhat increase the link

761
00:30:35,840 --> 00:30:38,080
time when building the kernel image the

762
00:30:38,080 --> 00:30:40,000
link took longer than compiling all of

763
00:30:40,000 --> 00:30:42,159
the object files the last time i tried

764
00:30:42,159 --> 00:30:43,520
it

765
00:30:43,520 --> 00:30:45,840
for indirect calls the compiler

766
00:30:45,840 --> 00:30:47,679
essentially inserts a check on the

767
00:30:47,679 --> 00:30:49,600
target address just before the call

768
00:30:49,600 --> 00:30:50,799
happens

769
00:30:50,799 --> 00:30:52,640
if the target address is not in the list

770
00:30:52,640 --> 00:30:54,960
of allowed addresses for that call site

771
00:30:54,960 --> 00:30:57,039
the kernel panics and the attacker does

772
00:30:57,039 --> 00:30:58,880
not get to call the address they wanted

773
00:30:58,880 --> 00:30:59,840
to

774
00:30:59,840 --> 00:31:02,159
as shown on the slide in this case

775
00:31:02,159 --> 00:31:04,320
trying to use the modified seek file

776
00:31:04,320 --> 00:31:06,960
operations would have been detected

777
00:31:06,960 --> 00:31:09,200
an alternative way to execute return to

778
00:31:09,200 --> 00:31:12,320
dpf would have been required

779
00:31:12,320 --> 00:31:14,880
cfi usage in android has been increasing

780
00:31:14,880 --> 00:31:16,960
each year as more oems enable the

781
00:31:16,960 --> 00:31:18,880
feature in their kernels

782
00:31:18,880 --> 00:31:21,600
cfi is also used in the generic kernel

783
00:31:21,600 --> 00:31:23,919
image project so as newer android

784
00:31:23,919 --> 00:31:26,880
devices start shipping with gki kernels

785
00:31:26,880 --> 00:31:29,519
cfi support across android will continue

786
00:31:29,519 --> 00:31:32,760
to increase

787
00:31:32,960 --> 00:31:35,039
this kernel configuration setting which

788
00:31:35,039 --> 00:31:36,960
is now required for some architectures

789
00:31:36,960 --> 00:31:40,399
for android causes bpf to always use the

790
00:31:40,399 --> 00:31:42,480
just in time compiler

791
00:31:42,480 --> 00:31:45,120
the bpf instruction interpreter itself

792
00:31:45,120 --> 00:31:46,880
is not compiled when this setting is

793
00:31:46,880 --> 00:31:49,200
enabled so the code for it is not

794
00:31:49,200 --> 00:31:51,200
present in the kernel image

795
00:31:51,200 --> 00:31:53,440
since the code is not present it cannot

796
00:31:53,440 --> 00:31:55,279
be called by an attacker

797
00:31:55,279 --> 00:31:58,000
as xingyu demonstrated earlier if the

798
00:31:58,000 --> 00:32:00,720
bpf interpreter is present and having

799
00:32:00,720 --> 00:32:02,960
control of the instruction pointer and

800
00:32:02,960 --> 00:32:05,360
some arguments allows it to be called to

801
00:32:05,360 --> 00:32:07,840
execute arbitrary bpf instructions

802
00:32:07,840 --> 00:32:09,279
without them having gone through the

803
00:32:09,279 --> 00:32:10,960
verifier

804
00:32:10,960 --> 00:32:13,679
this mitigation blocks the return to bpf

805
00:32:13,679 --> 00:32:14,880
technique that was used in the

806
00:32:14,880 --> 00:32:17,600
demonstrated exploit in order to bypass

807
00:32:17,600 --> 00:32:20,159
other mitigation techniques defense in

808
00:32:20,159 --> 00:32:22,559
depth

809
00:32:23,279 --> 00:32:26,000
the final kernel mitigation config debug

810
00:32:26,000 --> 00:32:28,000
list is another one recommended by

811
00:32:28,000 --> 00:32:30,720
project xero this time by maddie stone

812
00:32:30,720 --> 00:32:33,679
which is also now required for android

813
00:32:33,679 --> 00:32:35,519
after an operation on a linked list

814
00:32:35,519 --> 00:32:37,519
element the forward and backward

815
00:32:37,519 --> 00:32:39,279
pointers are checked to ensure that the

816
00:32:39,279 --> 00:32:41,200
links between elements in the list are

817
00:32:41,200 --> 00:32:42,399
valid

818
00:32:42,399 --> 00:32:44,640
this has a slight performance impact

819
00:32:44,640 --> 00:32:46,399
that means that this corruption is

820
00:32:46,399 --> 00:32:48,960
detected as it occurs which would stop

821
00:32:48,960 --> 00:32:50,960
the exploitation techniques described

822
00:32:50,960 --> 00:32:53,840
earlier from being used

823
00:32:53,840 --> 00:32:56,080
in conclusion here there are a number of

824
00:32:56,080 --> 00:32:57,760
mitigations which would have blocked

825
00:32:57,760 --> 00:32:59,840
various parts of the exploit described

826
00:32:59,840 --> 00:33:01,279
by xinhu

827
00:33:01,279 --> 00:33:02,960
some of these mitigations were

828
00:33:02,960 --> 00:33:05,440
encountered on specific devices during

829
00:33:05,440 --> 00:33:07,600
development of the exploit and these

830
00:33:07,600 --> 00:33:10,159
were able to be worked around other

831
00:33:10,159 --> 00:33:12,000
mitigations that are present on other

832
00:33:12,000 --> 00:33:13,840
devices would have blocked these work

833
00:33:13,840 --> 00:33:15,120
around

834
00:33:15,120 --> 00:33:16,799
multiple mitigations that would have

835
00:33:16,799 --> 00:33:18,720
blocked the exploitation here are

836
00:33:18,720 --> 00:33:21,279
required now on android so a similar

837
00:33:21,279 --> 00:33:23,440
vulnerability would not be exploitable

838
00:33:23,440 --> 00:33:27,200
in the same way in the future

839
00:33:27,279 --> 00:33:28,799
now we'll talk about some of the other

840
00:33:28,799 --> 00:33:32,639
ways we protect android users

841
00:33:32,720 --> 00:33:35,039
starting off with on device protection

842
00:33:35,039 --> 00:33:37,039
android's application verification

843
00:33:37,039 --> 00:33:38,960
feature is something you may be familiar

844
00:33:38,960 --> 00:33:39,840
with

845
00:33:39,840 --> 00:33:41,840
when an application is side loaded for

846
00:33:41,840 --> 00:33:44,000
example the app verifier will check to

847
00:33:44,000 --> 00:33:46,240
see whether it's known to be malware

848
00:33:46,240 --> 00:33:49,039
as well as checking for specific apks

849
00:33:49,039 --> 00:33:51,120
android can also look at the similarity

850
00:33:51,120 --> 00:33:53,519
given apk on device

851
00:33:53,519 --> 00:33:56,000
information about known bad applications

852
00:33:56,000 --> 00:33:58,320
for the similarity check is provided by

853
00:33:58,320 --> 00:33:59,840
google servers

854
00:33:59,840 --> 00:34:02,080
this is to handle small differences in

855
00:34:02,080 --> 00:34:04,399
apk's contents which would defeat hash

856
00:34:04,399 --> 00:34:06,559
comparisons for example

857
00:34:06,559 --> 00:34:08,560
this covers the case where a side loaded

858
00:34:08,560 --> 00:34:10,399
application might contain a local

859
00:34:10,399 --> 00:34:12,560
privilege elevation exploit to support

860
00:34:12,560 --> 00:34:14,960
malicious activities

861
00:34:14,960 --> 00:34:17,199
advanced protection is an opt-in system

862
00:34:17,199 --> 00:34:19,359
that most visibly enables two-factor

863
00:34:19,359 --> 00:34:22,239
authentication and restricts application

864
00:34:22,239 --> 00:34:24,079
installations to a subset of those

865
00:34:24,079 --> 00:34:26,639
available on google play

866
00:34:26,639 --> 00:34:28,879
site loading is disabled and cannot be

867
00:34:28,879 --> 00:34:30,159
enabled

868
00:34:30,159 --> 00:34:32,000
limiting the pool of applications that

869
00:34:32,000 --> 00:34:34,399
can be installed makes users less likely

870
00:34:34,399 --> 00:34:38,319
to encounter malicious applications

871
00:34:38,800 --> 00:34:40,800
moving from on-device to server-side

872
00:34:40,800 --> 00:34:43,280
analysis we have a lot of infrastructure

873
00:34:43,280 --> 00:34:45,839
analyzing android applications

874
00:34:45,839 --> 00:34:47,599
all applications are constantly

875
00:34:47,599 --> 00:34:49,918
re-analyzed so that any new detection

876
00:34:49,918 --> 00:34:52,480
rules or analysis systems are applied to

877
00:34:52,480 --> 00:34:54,480
everything over time

878
00:34:54,480 --> 00:34:56,480
we use static analysis to generate

879
00:34:56,480 --> 00:34:59,040
information from an apk and the files it

880
00:34:59,040 --> 00:35:00,079
contains

881
00:35:00,079 --> 00:35:01,920
and dynamic analysis to run the

882
00:35:01,920 --> 00:35:04,320
application in instrumented environments

883
00:35:04,320 --> 00:35:07,599
to get information about what it does

884
00:35:07,599 --> 00:35:10,000
we also inspect packers and obfuscators

885
00:35:10,000 --> 00:35:12,480
to support better static analysis

886
00:35:12,480 --> 00:35:14,400
the graph here shows the proportion of

887
00:35:14,400 --> 00:35:16,320
malware apps that are protected by

888
00:35:16,320 --> 00:35:17,839
different packers

889
00:35:17,839 --> 00:35:19,760
this sort of data shows trends in the

890
00:35:19,760 --> 00:35:22,320
malware ecosystem and allows us to

891
00:35:22,320 --> 00:35:24,480
identify when packers lose and gain in

892
00:35:24,480 --> 00:35:26,720
popularity which can indicate that

893
00:35:26,720 --> 00:35:28,400
there's a new packer available for

894
00:35:28,400 --> 00:35:30,720
example

895
00:35:30,720 --> 00:35:32,720
dynamic analysis doesn't suffer from the

896
00:35:32,720 --> 00:35:35,520
same packet issues as static analysis as

897
00:35:35,520 --> 00:35:38,240
the application has to be able to run

898
00:35:38,240 --> 00:35:40,000
when an application runs its

899
00:35:40,000 --> 00:35:42,320
functionality can be exercised and we

900
00:35:42,320 --> 00:35:44,400
can see what it does by instrumenting

901
00:35:44,400 --> 00:35:47,200
framework and os apis and seeing what

902
00:35:47,200 --> 00:35:49,520
data it accesses

903
00:35:49,520 --> 00:35:51,920
the long-term objective of any analysis

904
00:35:51,920 --> 00:35:53,599
work that we do is to be able to

905
00:35:53,599 --> 00:35:55,520
automate the process of extracting

906
00:35:55,520 --> 00:35:57,520
additional information or performing

907
00:35:57,520 --> 00:35:59,599
additional detection based on what has

908
00:35:59,599 --> 00:36:01,200
been learned

909
00:36:01,200 --> 00:36:03,119
manual analysis and detection doesn't

910
00:36:03,119 --> 00:36:04,640
scale well against millions of

911
00:36:04,640 --> 00:36:06,160
applications

912
00:36:06,160 --> 00:36:07,839
we also have many machine learning

913
00:36:07,839 --> 00:36:09,920
models that take all kinds of data about

914
00:36:09,920 --> 00:36:12,079
applications as their input so

915
00:36:12,079 --> 00:36:13,599
additional types of data from

916
00:36:13,599 --> 00:36:15,760
applications can often be very useful

917
00:36:15,760 --> 00:36:18,480
here as well

918
00:36:18,800 --> 00:36:20,880
having just said that manual analysis

919
00:36:20,880 --> 00:36:22,960
doesn't scale well it is still an

920
00:36:22,960 --> 00:36:24,880
important part of detecting malicious

921
00:36:24,880 --> 00:36:27,680
software we work with a number of other

922
00:36:27,680 --> 00:36:29,760
internal teams from getting initial

923
00:36:29,760 --> 00:36:32,160
leads and performing investigations

924
00:36:32,160 --> 00:36:34,400
through to research enforcement and

925
00:36:34,400 --> 00:36:36,000
education

926
00:36:36,000 --> 00:36:38,400
external researchers submit information

927
00:36:38,400 --> 00:36:40,079
about malicious applications or

928
00:36:40,079 --> 00:36:41,599
vulnerabilities

929
00:36:41,599 --> 00:36:43,520
these will be investigated and the

930
00:36:43,520 --> 00:36:45,839
appropriate action taken

931
00:36:45,839 --> 00:36:48,320
inside our team we reverse engineer and

932
00:36:48,320 --> 00:36:50,320
analyze malware to understand what it

933
00:36:50,320 --> 00:36:51,200
does

934
00:36:51,200 --> 00:36:53,040
writing reports on its behavior and

935
00:36:53,040 --> 00:36:54,960
functionality to spread awareness and

936
00:36:54,960 --> 00:36:57,119
knowledge around other security teams

937
00:36:57,119 --> 00:36:58,800
and analysts

938
00:36:58,800 --> 00:37:01,200
most commonly this results in additional

939
00:37:01,200 --> 00:37:03,280
detection being implemented using

940
00:37:03,280 --> 00:37:05,040
existing systems

941
00:37:05,040 --> 00:37:06,720
sometimes we work with software

942
00:37:06,720 --> 00:37:08,640
engineers from other teams to design and

943
00:37:08,640 --> 00:37:10,800
implement new detection systems to fill

944
00:37:10,800 --> 00:37:13,680
capability gaps or to propose changes to

945
00:37:13,680 --> 00:37:15,839
the operating system to make it more

946
00:37:15,839 --> 00:37:19,119
secure or resilient

947
00:37:19,760 --> 00:37:21,839
static analysis of software scales

948
00:37:21,839 --> 00:37:24,079
better than dynamic analysis

949
00:37:24,079 --> 00:37:26,000
however it can be very difficult to

950
00:37:26,000 --> 00:37:28,480
understand what an executable actually

951
00:37:28,480 --> 00:37:29,280
does

952
00:37:29,280 --> 00:37:32,160
purely by using static analysis

953
00:37:32,160 --> 00:37:34,000
the image on the left shows the control

954
00:37:34,000 --> 00:37:36,720
flow for a very simple exploit sample

955
00:37:36,720 --> 00:37:40,160
cve 2016-5195

956
00:37:40,160 --> 00:37:42,880
the m advise and seek right loops can be

957
00:37:42,880 --> 00:37:45,839
seen in this minimal implementation

958
00:37:45,839 --> 00:37:48,160
the image on the right shows a larger

959
00:37:48,160 --> 00:37:50,160
different exploit and the apparent

960
00:37:50,160 --> 00:37:52,240
control flows there

961
00:37:52,240 --> 00:37:54,000
the image in the middle shows control

962
00:37:54,000 --> 00:37:56,000
flow of an obfuscated function as

963
00:37:56,000 --> 00:37:58,560
displayed by ida which is considerably

964
00:37:58,560 --> 00:38:01,119
more difficult to understand

965
00:38:01,119 --> 00:38:03,200
even a simple piece of code such as that

966
00:38:03,200 --> 00:38:05,119
on the left becomes harder to read when

967
00:38:05,119 --> 00:38:07,520
it is obfuscated

968
00:38:07,520 --> 00:38:09,680
dynamic analysis however lets you see

969
00:38:09,680 --> 00:38:12,000
what the code really does providing you

970
00:38:12,000 --> 00:38:13,839
can get it to run and perform its

971
00:38:13,839 --> 00:38:15,680
malicious actions

972
00:38:15,680 --> 00:38:17,280
exploit samples are generally

973
00:38:17,280 --> 00:38:19,119
straightforward in that they try to

974
00:38:19,119 --> 00:38:20,800
exploit the device

975
00:38:20,800 --> 00:38:22,240
there may be checks for whether the

976
00:38:22,240 --> 00:38:24,960
device is supported particularly if the

977
00:38:24,960 --> 00:38:26,960
exploit relies on knowing memory

978
00:38:26,960 --> 00:38:29,520
addresses or offsets for example but

979
00:38:29,520 --> 00:38:31,680
these can always be knocked out provided

980
00:38:31,680 --> 00:38:33,520
you don't mind taking the risk of

981
00:38:33,520 --> 00:38:35,440
crashing your test device if it is

982
00:38:35,440 --> 00:38:37,359
vulnerable

983
00:38:37,359 --> 00:38:40,000
local privilege elevation exploits often

984
00:38:40,000 --> 00:38:42,480
referred to as routing generally need to

985
00:38:42,480 --> 00:38:44,960
interact with the os kernel

986
00:38:44,960 --> 00:38:46,960
obviously if an exploit requires a

987
00:38:46,960 --> 00:38:49,200
particular device driver you have to

988
00:38:49,200 --> 00:38:52,160
have an appropriate device to run it on

989
00:38:52,160 --> 00:38:54,320
if you can see what the exploit actually

990
00:38:54,320 --> 00:38:56,800
asks the kernel to do then you can start

991
00:38:56,800 --> 00:38:58,960
to understand what's happening and then

992
00:38:58,960 --> 00:39:00,800
look to see whether it is for a known

993
00:39:00,800 --> 00:39:02,400
vulnerability

994
00:39:02,400 --> 00:39:05,040
ebpf one of a number of tracing or

995
00:39:05,040 --> 00:39:07,599
monitoring mechanisms for linux allows

996
00:39:07,599 --> 00:39:09,520
monitoring of kernel calls and the

997
00:39:09,520 --> 00:39:11,680
parameters they are given which can be

998
00:39:11,680 --> 00:39:13,280
used to look for evidence of

999
00:39:13,280 --> 00:39:16,720
exploitation behavior

1000
00:39:17,520 --> 00:39:19,920
the exploit described earlier by xingyu

1001
00:39:19,920 --> 00:39:22,320
relies on various kernel heat sprays in

1002
00:39:22,320 --> 00:39:24,320
order to control use after freeze by

1003
00:39:24,320 --> 00:39:26,560
manipulating the contents and layouts of

1004
00:39:26,560 --> 00:39:29,680
a kernel heap if we can detect that a

1005
00:39:29,680 --> 00:39:31,760
spray is occurring or seems to be

1006
00:39:31,760 --> 00:39:33,920
occurring maybe we can detect when

1007
00:39:33,920 --> 00:39:36,240
exploitation is happening

1008
00:39:36,240 --> 00:39:37,760
kernel heap sprays are performed

1009
00:39:37,760 --> 00:39:40,079
typically from user mode by allocating

1010
00:39:40,079 --> 00:39:42,400
or releasing large numbers of particular

1011
00:39:42,400 --> 00:39:46,160
objects for example files or sockets

1012
00:39:46,160 --> 00:39:48,160
as well as looking for generic evidence

1013
00:39:48,160 --> 00:39:50,240
such as memory manipulation and layout

1014
00:39:50,240 --> 00:39:51,280
control

1015
00:39:51,280 --> 00:39:53,440
some specific kernel interactions that

1016
00:39:53,440 --> 00:39:55,119
have been used to exploit different

1017
00:39:55,119 --> 00:39:57,200
vulnerabilities over recent years are

1018
00:39:57,200 --> 00:39:59,119
shown on the slide as well

1019
00:39:59,119 --> 00:40:00,560
these are from several different

1020
00:40:00,560 --> 00:40:03,359
exploits some are highly specific others

1021
00:40:03,359 --> 00:40:06,000
are more general techniques

1022
00:40:06,000 --> 00:40:07,920
i'm actually going to show behavior from

1023
00:40:07,920 --> 00:40:12,240
cve 2018 9568 for the detection video

1024
00:40:12,240 --> 00:40:14,720
this is better known as wz router by

1025
00:40:14,720 --> 00:40:16,079
thomas king

1026
00:40:16,079 --> 00:40:18,319
the technical paper has a similar manual

1027
00:40:18,319 --> 00:40:21,160
analysis on the cve

1028
00:40:21,160 --> 00:40:24,319
2021-0399 exploit

1029
00:40:24,319 --> 00:40:26,640
i have a couple of terminals on a phone

1030
00:40:26,640 --> 00:40:28,319
the one on the right is the monitoring

1031
00:40:28,319 --> 00:40:30,240
software the one on the left is where

1032
00:40:30,240 --> 00:40:33,359
i'm running the exploit

1033
00:40:33,359 --> 00:40:36,160
you can see the exploits starting up and

1034
00:40:36,160 --> 00:40:38,000
behavioral events being shown on the

1035
00:40:38,000 --> 00:40:40,160
right the device isn't actually

1036
00:40:40,160 --> 00:40:42,400
vulnerable in this case but the exploit

1037
00:40:42,400 --> 00:40:45,280
tries anyway

1038
00:40:47,200 --> 00:40:50,160
we stop monitoring after a short period

1039
00:40:50,160 --> 00:40:53,200
then i switch to another terminal

1040
00:40:53,200 --> 00:40:55,440
to download the save trace and put it

1041
00:40:55,440 --> 00:40:58,880
through the analysis software

1042
00:41:02,480 --> 00:41:04,880
so you can see here a number of events

1043
00:41:04,880 --> 00:41:07,040
have been highlighted

1044
00:41:07,040 --> 00:41:08,880
loops of syscalls you should be able to

1045
00:41:08,880 --> 00:41:11,839
see a few ioctal and close call loops

1046
00:41:11,839 --> 00:41:14,000
if we move further back we get to a

1047
00:41:14,000 --> 00:41:18,599
series of loops creating sockets

1048
00:41:21,920 --> 00:41:24,240
you can see there are several different

1049
00:41:24,240 --> 00:41:26,319
threads each creating hundreds of

1050
00:41:26,319 --> 00:41:28,880
sockets

1051
00:41:30,480 --> 00:41:32,160
here we are looking at some of the

1052
00:41:32,160 --> 00:41:35,440
different thread ids as you can see

1053
00:41:35,440 --> 00:41:37,920
each thread is creating several hundred

1054
00:41:37,920 --> 00:41:39,520
sockets

1055
00:41:39,520 --> 00:41:42,720
before finishing what it's doing

1056
00:41:42,720 --> 00:41:45,280
moving further back in the trace we can

1057
00:41:45,280 --> 00:41:48,160
see some more socket and closed loops

1058
00:41:48,160 --> 00:41:49,119
and

1059
00:41:49,119 --> 00:41:51,280
then if we go back a little further we

1060
00:41:51,280 --> 00:41:53,359
can see some clone calls where the

1061
00:41:53,359 --> 00:41:56,640
threads are being created

1062
00:41:59,440 --> 00:42:01,520
the behavior seen here where thousands

1063
00:42:01,520 --> 00:42:03,760
of sockets have been created and closed

1064
00:42:03,760 --> 00:42:06,560
is unusual and likely indicates that

1065
00:42:06,560 --> 00:42:09,040
kernel heat structure manipulation is

1066
00:42:09,040 --> 00:42:11,040
happening

1067
00:42:11,040 --> 00:42:14,200
it turns out that cv

1068
00:42:14,200 --> 00:42:17,280
2021-0399 could be exploited on devices

1069
00:42:17,280 --> 00:42:19,359
with the uao mitigation

1070
00:42:19,359 --> 00:42:20,960
if you're investigating whether a

1071
00:42:20,960 --> 00:42:23,359
vulnerability is exploitable keep

1072
00:42:23,359 --> 00:42:25,440
looking for workarounds or alternative

1073
00:42:25,440 --> 00:42:27,680
techniques and talk to people

1074
00:42:27,680 --> 00:42:29,520
the more knowledge you have about what's

1075
00:42:29,520 --> 00:42:31,440
available and what it can do the more

1076
00:42:31,440 --> 00:42:33,440
likely it is you will be able to come up

1077
00:42:33,440 --> 00:42:34,800
with something

1078
00:42:34,800 --> 00:42:36,880
xinhu encountered a number of problems

1079
00:42:36,880 --> 00:42:39,119
developing the exploit here but with a

1080
00:42:39,119 --> 00:42:41,760
lot of work plenty of heat manipulation

1081
00:42:41,760 --> 00:42:43,680
and help from other people he was able

1082
00:42:43,680 --> 00:42:45,440
to overcome them on his development

1083
00:42:45,440 --> 00:42:46,880
devices

1084
00:42:46,880 --> 00:42:48,720
the workarounds used were themselves

1085
00:42:48,720 --> 00:42:51,040
defeated by further mitigations which

1086
00:42:51,040 --> 00:42:52,800
you can find on current and future

1087
00:42:52,800 --> 00:42:54,480
android devices

1088
00:42:54,480 --> 00:42:56,400
we mentioned a generic kernel image

1089
00:42:56,400 --> 00:42:58,960
project earlier essentially this means

1090
00:42:58,960 --> 00:43:00,800
kernel updates will get onto user

1091
00:43:00,800 --> 00:43:03,359
devices faster as there is less effort

1092
00:43:03,359 --> 00:43:05,440
involved across the ecosystem in

1093
00:43:05,440 --> 00:43:09,040
applying security updates

1094
00:43:10,319 --> 00:43:12,160
thank you to two people without whom

1095
00:43:12,160 --> 00:43:14,160
this work would not have happened

1096
00:43:14,160 --> 00:43:16,400
yanborne for discussing exploitation

1097
00:43:16,400 --> 00:43:18,560
techniques suggesting workarounds for

1098
00:43:18,560 --> 00:43:20,800
mitigations and then more mitigations

1099
00:43:20,800 --> 00:43:23,599
for the workarounds and zyjo for

1100
00:43:23,599 --> 00:43:26,160
donating his mi9 phone to be used for

1101
00:43:26,160 --> 00:43:28,720
exploit development and testing

1102
00:43:28,720 --> 00:43:33,160
finally thank you for watching

