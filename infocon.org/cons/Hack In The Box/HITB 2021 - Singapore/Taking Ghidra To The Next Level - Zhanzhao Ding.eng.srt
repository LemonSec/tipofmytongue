1
00:00:09,920 --> 00:00:11,840
hey guys what's up

2
00:00:11,840 --> 00:00:14,080
in this talk i'm gonna talk about our

3
00:00:14,080 --> 00:00:16,239
recent work on ghidra the reverse

4
00:00:16,239 --> 00:00:17,840
engineering tool

5
00:00:17,840 --> 00:00:20,000
our goal is to push kira to the next

6
00:00:20,000 --> 00:00:23,039
level by fixing things adding features

7
00:00:23,039 --> 00:00:25,039
and introduce more state-of-the-art

8
00:00:25,039 --> 00:00:27,359
technologies hope you guys enjoy this

9
00:00:27,359 --> 00:00:28,400
talk

10
00:00:28,400 --> 00:00:31,039
first a little bit about me my name is

11
00:00:31,039 --> 00:00:33,280
tinjan dao or you might know me as

12
00:00:33,280 --> 00:00:36,079
anthony my nickname i work now at the

13
00:00:36,079 --> 00:00:38,640
dark cross technology responsible for

14
00:00:38,640 --> 00:00:41,680
binary analysis part of the portal lab

15
00:00:41,680 --> 00:00:44,000
portolab is our lab in starcraft

16
00:00:44,000 --> 00:00:46,320
technology where we research around

17
00:00:46,320 --> 00:00:50,320
topics like api security cloud security

18
00:00:50,320 --> 00:00:53,760
binary analysis reversing and so on

19
00:00:53,760 --> 00:00:55,840
i've been playing ctf for some years

20
00:00:55,840 --> 00:00:58,960
till now since 2017 some friends of me

21
00:00:58,960 --> 00:01:01,280
started team rocker big and i have been

22
00:01:01,280 --> 00:01:03,520
playing as team roka big for about four

23
00:01:03,520 --> 00:01:04,720
years

24
00:01:04,720 --> 00:01:07,520
since 2019 i started my team leadership

25
00:01:07,520 --> 00:01:10,240
of team rocket pick luckily right after

26
00:01:10,240 --> 00:01:12,240
we started team rocket pick we were

27
00:01:12,240 --> 00:01:15,439
qualified for defcon ctf final and again

28
00:01:15,439 --> 00:01:18,240
that is about 4 years now besides defcon

29
00:01:18,240 --> 00:01:21,200
ctf we also played many other ctfs and

30
00:01:21,200 --> 00:01:23,439
get awards in many of them such as

31
00:01:23,439 --> 00:01:27,280
xerocdf wctf and many more

32
00:01:27,280 --> 00:01:30,159
usually when i don't play ctf i do some

33
00:01:30,159 --> 00:01:32,479
open source developing especially

34
00:01:32,479 --> 00:01:34,799
enthusiasts in reverse engineering and

35
00:01:34,799 --> 00:01:36,880
binary analysis tools

36
00:01:36,880 --> 00:01:40,159
and that's why we have this talk today

37
00:01:40,159 --> 00:01:42,079
in this talk we will be first talking

38
00:01:42,079 --> 00:01:44,799
about vanilla ghidra how is he liking my

39
00:01:44,799 --> 00:01:47,119
personal view the next thing i'm gonna

40
00:01:47,119 --> 00:01:50,479
present you is my recent work minecraft

41
00:01:50,479 --> 00:01:52,560
we will be talking about my dedication

42
00:01:52,560 --> 00:01:54,720
and what we have done what we wanted to

43
00:01:54,720 --> 00:01:57,759
do and the lessons learned along the way

44
00:01:57,759 --> 00:02:00,240
okay the first question i want to ask

45
00:02:00,240 --> 00:02:02,240
before this presentation is

46
00:02:02,240 --> 00:02:04,960
what are actually needed in reversing

47
00:02:04,960 --> 00:02:06,560
i've been talking about this with my

48
00:02:06,560 --> 00:02:08,639
team members for many times

49
00:02:08,639 --> 00:02:10,479
while you reverse there's a lot of

50
00:02:10,479 --> 00:02:12,800
things you might be needing things like

51
00:02:12,800 --> 00:02:15,599
retyping variables renaming variables

52
00:02:15,599 --> 00:02:17,680
but first you need the basic thread

53
00:02:17,680 --> 00:02:20,840
which is f5 in ida the decompilation

54
00:02:20,840 --> 00:02:23,520
functionality time just passes many

55
00:02:23,520 --> 00:02:25,360
years ago we still have the gut to

56
00:02:25,360 --> 00:02:27,520
reverse any instruction set by just

57
00:02:27,520 --> 00:02:29,840
looking at the rule disassemblies but

58
00:02:29,840 --> 00:02:32,480
that time will never come back again now

59
00:02:32,480 --> 00:02:34,800
many people just can't leave without f5

60
00:02:34,800 --> 00:02:37,280
without decompilation

61
00:02:37,280 --> 00:02:38,080
so

62
00:02:38,080 --> 00:02:41,120
let's get real all analysis we need in

63
00:02:41,120 --> 00:02:43,440
actual reversing can be categorized in

64
00:02:43,440 --> 00:02:46,239
static analysis or dynamic analysis

65
00:02:46,239 --> 00:02:47,519
category

66
00:02:47,519 --> 00:02:49,599
listing every analysis in these two

67
00:02:49,599 --> 00:02:51,920
categories is not quite possible here

68
00:02:51,920 --> 00:02:54,480
since there are so many of them i listed

69
00:02:54,480 --> 00:02:56,640
what is the most important ones

70
00:02:56,640 --> 00:02:59,120
like in static analysis a reverse tool

71
00:02:59,120 --> 00:03:01,200
must have disassembly to be called a

72
00:03:01,200 --> 00:03:02,560
reverse tool

73
00:03:02,560 --> 00:03:04,800
if you are hardcore enough decompilation

74
00:03:04,800 --> 00:03:07,280
is not a must but people don't do that

75
00:03:07,280 --> 00:03:09,840
in this age now we definitely need

76
00:03:09,840 --> 00:03:13,200
decompilation for real world reversing

77
00:03:13,200 --> 00:03:16,000
as for dynamic analysis two things i can

78
00:03:16,000 --> 00:03:18,400
think of while reversing is debugging

79
00:03:18,400 --> 00:03:20,000
and emulation

80
00:03:20,000 --> 00:03:22,080
debugging allows us to inspect the

81
00:03:22,080 --> 00:03:23,920
internal status of the program during

82
00:03:23,920 --> 00:03:25,360
the runtime

83
00:03:25,360 --> 00:03:27,360
many of the time when the binary to

84
00:03:27,360 --> 00:03:30,319
reverse is absolutely complex debugging

85
00:03:30,319 --> 00:03:32,400
the internal is the only technique we

86
00:03:32,400 --> 00:03:35,040
left for understanding how it works

87
00:03:35,040 --> 00:03:37,360
you set the breakpoint run it check

88
00:03:37,360 --> 00:03:39,760
those register values and memory values

89
00:03:39,760 --> 00:03:41,599
and then continue again

90
00:03:41,599 --> 00:03:44,640
this value can reflect the logic behind

91
00:03:44,640 --> 00:03:46,799
the binary sometimes you can even guess

92
00:03:46,799 --> 00:03:48,879
the algorithm and verify that by

93
00:03:48,879 --> 00:03:51,599
inspecting only the internal status like

94
00:03:51,599 --> 00:03:54,879
the register values and memory values

95
00:03:54,879 --> 00:03:57,680
as for emulation emulation is mostly

96
00:03:57,680 --> 00:03:59,680
needed when i saw some binary has the

97
00:03:59,680 --> 00:04:02,480
runtime extraction technique used

98
00:04:02,480 --> 00:04:04,720
with that those binaries can prevent you

99
00:04:04,720 --> 00:04:07,040
from reading this internal logic without

100
00:04:07,040 --> 00:04:08,480
running the program

101
00:04:08,480 --> 00:04:10,799
or if you have the time for that you can

102
00:04:10,799 --> 00:04:12,879
just reverse it from the very beginning

103
00:04:12,879 --> 00:04:15,200
and completely understand the extraction

104
00:04:15,200 --> 00:04:17,918
logic then do it statically but that's

105
00:04:17,918 --> 00:04:19,600
just a rare case

106
00:04:19,600 --> 00:04:22,000
and since the extraction logic may not

107
00:04:22,000 --> 00:04:24,240
be used elsewhere if you do that you

108
00:04:24,240 --> 00:04:26,639
waste a lot of time on that

109
00:04:26,639 --> 00:04:29,120
which for me i think is not needed

110
00:04:29,120 --> 00:04:31,919
so we just do emulation get the result

111
00:04:31,919 --> 00:04:33,840
patch it back on the binary and check

112
00:04:33,840 --> 00:04:35,840
the decompilation that is how things

113
00:04:35,840 --> 00:04:37,840
work in this age

114
00:04:37,840 --> 00:04:39,919
consider those functionalities what do

115
00:04:39,919 --> 00:04:43,120
we have now ida is definitely the ruler

116
00:04:43,120 --> 00:04:45,040
without any question

117
00:04:45,040 --> 00:04:47,440
i can say that is the compiler is the

118
00:04:47,440 --> 00:04:49,520
state-of-the-art level since i know

119
00:04:49,520 --> 00:04:51,440
quite some research papers claiming that

120
00:04:51,440 --> 00:04:53,199
they have better decomposer compared to

121
00:04:53,199 --> 00:04:56,400
ida but it's undeniable that ida has at

122
00:04:56,400 --> 00:04:58,160
least the world's first classic

123
00:04:58,160 --> 00:04:59,199
competitor

124
00:04:59,199 --> 00:05:01,520
they have tuned it for many years

125
00:05:01,520 --> 00:05:03,440
one thing i learned in playing with the

126
00:05:03,440 --> 00:05:06,160
compiler technology is that making the

127
00:05:06,160 --> 00:05:08,720
decompiler work is not that hard many

128
00:05:08,720 --> 00:05:11,360
people overestimated the complexity of

129
00:05:11,360 --> 00:05:14,479
implementing a poc level decompiler but

130
00:05:14,479 --> 00:05:16,479
what makes it complex is that you need

131
00:05:16,479 --> 00:05:19,039
to adjust the decompiler to fit into

132
00:05:19,039 --> 00:05:21,360
many corner cases you never know what

133
00:05:21,360 --> 00:05:24,479
people would use the decompiler for many

134
00:05:24,479 --> 00:05:26,639
algorithms used in the decompiler have

135
00:05:26,639 --> 00:05:28,960
to deal with those special cases that's

136
00:05:28,960 --> 00:05:31,120
why you need a lot of time fixing those

137
00:05:31,120 --> 00:05:33,840
problems and either for sure with these

138
00:05:33,840 --> 00:05:36,240
years of fixing they made the decompiler

139
00:05:36,240 --> 00:05:39,199
quite reliable at least no other project

140
00:05:39,199 --> 00:05:41,360
can go beyond them in the industrial

141
00:05:41,360 --> 00:05:44,080
area for now apart from ida we still

142
00:05:44,080 --> 00:05:47,360
have some choices like gudra nsa open

143
00:05:47,360 --> 00:05:49,759
source which is our topic i will talk

144
00:05:49,759 --> 00:05:53,360
about it later next we have binary ninja

145
00:05:53,360 --> 00:05:55,840
it is a nice project if you ask me

146
00:05:55,840 --> 00:05:58,639
although commercial it has an intriguing

147
00:05:58,639 --> 00:06:01,199
design of the decompiler procedure they

148
00:06:01,199 --> 00:06:03,520
made it into several phases and each

149
00:06:03,520 --> 00:06:05,520
phase you get the result that you can

150
00:06:05,520 --> 00:06:06,479
read

151
00:06:06,479 --> 00:06:08,720
in this way they don't need to implement

152
00:06:08,720 --> 00:06:10,720
a decompiler immediately

153
00:06:10,720 --> 00:06:12,960
during this phase they gradually make

154
00:06:12,960 --> 00:06:16,319
disassembly graph view then each phase

155
00:06:16,319 --> 00:06:19,360
of the compilation output works and the

156
00:06:19,360 --> 00:06:22,400
apis are quite complete but the problem

157
00:06:22,400 --> 00:06:24,880
is they don't have it open source and

158
00:06:24,880 --> 00:06:27,120
they still need more time to make it as

159
00:06:27,120 --> 00:06:29,039
complete as either

160
00:06:29,039 --> 00:06:32,560
that decompiler still needs more fixings

161
00:06:32,560 --> 00:06:35,199
it is a binary analysis framework but as

162
00:06:35,199 --> 00:06:37,759
far as i know they seem to be moving to

163
00:06:37,759 --> 00:06:39,600
complete reverse engineering tool

164
00:06:39,600 --> 00:06:42,400
recently the decompiler seems to be

165
00:06:42,400 --> 00:06:44,560
commercial while the basic binary

166
00:06:44,560 --> 00:06:47,039
analysis thing is open sourced and the

167
00:06:47,039 --> 00:06:50,000
decompiler is not out yet the last one i

168
00:06:50,000 --> 00:06:52,639
want to talk about is reader 2 i totally

169
00:06:52,639 --> 00:06:54,560
like their philosophy the unique style

170
00:06:54,560 --> 00:06:57,280
reverse engineering tool really creative

171
00:06:57,280 --> 00:06:59,520
but when doing the reversing the command

172
00:06:59,520 --> 00:07:01,599
line interface compared to graphical

173
00:07:01,599 --> 00:07:03,919
user interface is not that convenient

174
00:07:03,919 --> 00:07:05,039
after all

175
00:07:05,039 --> 00:07:07,199
during reversing you may have multiple

176
00:07:07,199 --> 00:07:09,919
views simultaneously one display the

177
00:07:09,919 --> 00:07:12,479
disassembly one display the structures

178
00:07:12,479 --> 00:07:14,840
you identified and even one more for

179
00:07:14,840 --> 00:07:17,280
decompilation if you do that in the

180
00:07:17,280 --> 00:07:19,440
comment line you miss waste too much

181
00:07:19,440 --> 00:07:21,840
time on inspecting those information

182
00:07:21,840 --> 00:07:24,560
so for me it is interesting but not too

183
00:07:24,560 --> 00:07:27,680
good to be used in real world reversing

184
00:07:27,680 --> 00:07:29,360
and one thing they lack is the

185
00:07:29,360 --> 00:07:31,599
compilation i know about some efforts

186
00:07:31,599 --> 00:07:34,160
being made to reader 2 to integrate gyra

187
00:07:34,160 --> 00:07:36,479
or other decompilers but still it is an

188
00:07:36,479 --> 00:07:38,960
integration you need to translate things

189
00:07:38,960 --> 00:07:40,479
around several intermediate

190
00:07:40,479 --> 00:07:43,039
representations to make things just work

191
00:07:43,039 --> 00:07:45,919
sometimes it does not work so well

192
00:07:45,919 --> 00:07:47,840
they also provide a graphical user

193
00:07:47,840 --> 00:07:50,319
interface called cutter but the internal

194
00:07:50,319 --> 00:07:51,919
remains the same

195
00:07:51,919 --> 00:07:54,319
you may say that i'm a bit biased but in

196
00:07:54,319 --> 00:07:57,280
real i just haven't used it for serious

197
00:07:57,280 --> 00:08:00,479
reversing tasks maybe just maybe it is

198
00:08:00,479 --> 00:08:03,199
because i got so used to ida and can't

199
00:08:03,199 --> 00:08:05,039
move to a new type of working flow

200
00:08:05,039 --> 00:08:07,680
anyway that's my comment

201
00:08:07,680 --> 00:08:10,560
so to be honest the only one that i

202
00:08:10,560 --> 00:08:12,879
would like to use in real tasks is

203
00:08:12,879 --> 00:08:15,199
schedule if i have to choose in those

204
00:08:15,199 --> 00:08:18,080
tools except ida especially if i wanted

205
00:08:18,080 --> 00:08:20,479
to choose between the open source ones

206
00:08:20,479 --> 00:08:23,039
for me open source is an important issue

207
00:08:23,039 --> 00:08:25,680
as sometimes when i got into a problem i

208
00:08:25,680 --> 00:08:27,280
usually don't want to wait for the

209
00:08:27,280 --> 00:08:29,919
solution that would take quite some time

210
00:08:29,919 --> 00:08:31,919
and one more thing i am always the

211
00:08:31,919 --> 00:08:34,240
curious baby wondering what is the cause

212
00:08:34,240 --> 00:08:36,399
of such software bug not knowing the

213
00:08:36,399 --> 00:08:38,399
reason behind the bug is killing me

214
00:08:38,399 --> 00:08:40,399
that's why i always prefer open source

215
00:08:40,399 --> 00:08:41,360
software

216
00:08:41,360 --> 00:08:43,200
let's get back to the point

217
00:08:43,200 --> 00:08:46,000
gitra is open source in 2019 written in

218
00:08:46,000 --> 00:08:48,399
java and native language such as c plus

219
00:08:48,399 --> 00:08:49,279
plus

220
00:08:49,279 --> 00:08:51,440
it actually has not fixed the native

221
00:08:51,440 --> 00:08:53,920
languages you can use since the java

222
00:08:53,920 --> 00:08:56,560
would interact with native language in

223
00:08:56,560 --> 00:08:58,240
rpc protocol

224
00:08:58,240 --> 00:09:00,480
this would be talked about in detail

225
00:09:00,480 --> 00:09:02,560
when we get to the dedra decompiler

226
00:09:02,560 --> 00:09:03,920
internal part

227
00:09:03,920 --> 00:09:06,800
what i care is that didra has an almost

228
00:09:06,800 --> 00:09:09,440
complete feature set that is we have the

229
00:09:09,440 --> 00:09:12,160
compiler working graph view working

230
00:09:12,160 --> 00:09:14,880
debugger working this is not a complete

231
00:09:14,880 --> 00:09:15,760
list

232
00:09:15,760 --> 00:09:17,680
in short most of the things you might

233
00:09:17,680 --> 00:09:20,959
expect in ida is just there in gitra

234
00:09:20,959 --> 00:09:24,080
and the extensibility is extremely good

235
00:09:24,080 --> 00:09:26,399
as they use java for that

236
00:09:26,399 --> 00:09:28,480
i know many people complains about how

237
00:09:28,480 --> 00:09:31,279
java gets unreasonably long but let's

238
00:09:31,279 --> 00:09:33,839
just admit java suits perfectly when you

239
00:09:33,839 --> 00:09:36,320
need such extensibility the scripting

240
00:09:36,320 --> 00:09:38,080
interface provides you with java

241
00:09:38,080 --> 00:09:40,240
language scripting and the python

242
00:09:40,240 --> 00:09:42,240
scripting with jython

243
00:09:42,240 --> 00:09:44,640
one thing i can think of that fails is

244
00:09:44,640 --> 00:09:47,600
jython can only support python 2 and

245
00:09:47,600 --> 00:09:49,360
this might not improve in quite some

246
00:09:49,360 --> 00:09:51,360
time and the plugin

247
00:09:51,360 --> 00:09:54,000
import a jar file and you are good to go

248
00:09:54,000 --> 00:09:56,399
when developing the plugin you have

249
00:09:56,399 --> 00:09:58,640
almost the full power of key drug call

250
00:09:58,640 --> 00:10:00,800
any method you like it's just like

251
00:10:00,800 --> 00:10:03,200
developing part of the gita itself even

252
00:10:03,200 --> 00:10:06,320
gidra itself uses the plugin system

253
00:10:06,320 --> 00:10:09,600
to make the code more organized also

254
00:10:09,600 --> 00:10:12,480
hidra has a great architecture that i am

255
00:10:12,480 --> 00:10:15,120
referring to the slay dsl

256
00:10:15,120 --> 00:10:18,079
play is a programming language developed

257
00:10:18,079 --> 00:10:19,920
in the gitra project

258
00:10:19,920 --> 00:10:22,480
it is a dsl describing the relationship

259
00:10:22,480 --> 00:10:24,959
between binary the ir and then simply

260
00:10:24,959 --> 00:10:27,600
display in this way you don't need metal

261
00:10:27,600 --> 00:10:30,160
language to write down logic describing

262
00:10:30,160 --> 00:10:32,880
how the binary leads to ir and how the

263
00:10:32,880 --> 00:10:34,959
binary should be displayed in assembly

264
00:10:34,959 --> 00:10:38,079
languages you only need one such dsl for

265
00:10:38,079 --> 00:10:40,959
that to make this clear you write a 3

266
00:10:40,959 --> 00:10:43,920
language code you get a disassembler and

267
00:10:43,920 --> 00:10:45,600
a decompiler

268
00:10:45,600 --> 00:10:47,760
that i think is one of the strongest

269
00:10:47,760 --> 00:10:51,120
feature dja has comparing to other tools

270
00:10:51,120 --> 00:10:54,079
to sum up a little hidra is the only one

271
00:10:54,079 --> 00:10:56,000
in the open source world that competes

272
00:10:56,000 --> 00:10:57,760
with ida

273
00:10:57,760 --> 00:10:59,760
man how i wish kidro is just that

274
00:10:59,760 --> 00:11:01,680
perfect but the world doesn't go that

275
00:11:01,680 --> 00:11:04,480
way since kidro is a project of at least

276
00:11:04,480 --> 00:11:07,200
20 years of developing the historical

277
00:11:07,200 --> 00:11:10,240
issue is becoming its problem we have

278
00:11:10,240 --> 00:11:12,880
historical code in kidra and we might

279
00:11:12,880 --> 00:11:14,880
also encounter historical user

280
00:11:14,880 --> 00:11:17,040
experience issues

281
00:11:17,040 --> 00:11:19,440
this is one example of the historical

282
00:11:19,440 --> 00:11:22,480
code issue the c99 types are now a

283
00:11:22,480 --> 00:11:24,959
standard but still gujarati competitor

284
00:11:24,959 --> 00:11:26,880
is not using them but do something in

285
00:11:26,880 --> 00:11:29,360
their own this kind of thing is quite

286
00:11:29,360 --> 00:11:31,360
common especially in the decompounder

287
00:11:31,360 --> 00:11:33,920
code especially about the coding style

288
00:11:33,920 --> 00:11:35,760
some of the coding styles are proved to

289
00:11:35,760 --> 00:11:38,399
be bad practice in these years but those

290
00:11:38,399 --> 00:11:40,560
code cannot go away in the decomposer in

291
00:11:40,560 --> 00:11:42,880
a single glance and because of those

292
00:11:42,880 --> 00:11:45,360
code the developing of such components

293
00:11:45,360 --> 00:11:47,839
can be quite hard which prevents people

294
00:11:47,839 --> 00:11:50,639
from introducing interesting features

295
00:11:50,639 --> 00:11:52,800
as for the experience problem you can

296
00:11:52,800 --> 00:11:54,880
clearly see that in the ui interface

297
00:11:54,880 --> 00:11:57,440
right the ui interface feels so much

298
00:11:57,440 --> 00:12:00,079
like i was in the last century i know

299
00:12:00,079 --> 00:12:01,760
some people don't care about the ui

300
00:12:01,760 --> 00:12:04,160
interface when reversing generally but

301
00:12:04,160 --> 00:12:06,800
this is just an example for many people

302
00:12:06,800 --> 00:12:08,399
this is where the first thought about

303
00:12:08,399 --> 00:12:10,800
gitra goes in

304
00:12:10,800 --> 00:12:13,279
so i admit that gidra is a rather good

305
00:12:13,279 --> 00:12:16,000
project no doubt it is already nice

306
00:12:16,000 --> 00:12:18,800
enough to be used in many of the time

307
00:12:18,800 --> 00:12:20,800
people around me always use gidra with

308
00:12:20,800 --> 00:12:23,120
their ida is not working like before

309
00:12:23,120 --> 00:12:25,519
when we encounter bibs binary we always

310
00:12:25,519 --> 00:12:29,120
use gitra but is that it we just let go

311
00:12:29,120 --> 00:12:31,040
that way and only take it as the

312
00:12:31,040 --> 00:12:33,760
replacement tool when ida is not working

313
00:12:33,760 --> 00:12:36,000
i want more than that i want a project

314
00:12:36,000 --> 00:12:37,920
in the open source world that can grab

315
00:12:37,920 --> 00:12:40,160
some of the other users away instead of

316
00:12:40,160 --> 00:12:42,639
just seeing as a replacement i know

317
00:12:42,639 --> 00:12:44,800
that's a long way to go but we need to

318
00:12:44,800 --> 00:12:46,880
work out the first step the plan is

319
00:12:46,880 --> 00:12:49,279
simple we just modernize everything got

320
00:12:49,279 --> 00:12:52,399
into our site modernize the experience

321
00:12:52,399 --> 00:12:54,959
ui if you want an example

322
00:12:54,959 --> 00:12:57,279
add modern features apart from the

323
00:12:57,279 --> 00:13:00,000
vanilla key dramas and hopefully we can

324
00:13:00,000 --> 00:13:01,920
also refactor the code to make that

325
00:13:01,920 --> 00:13:04,560
modernized as well but that i know would

326
00:13:04,560 --> 00:13:07,760
take away quite some time so we might do

327
00:13:07,760 --> 00:13:10,480
that gradually step by step and for each

328
00:13:10,480 --> 00:13:13,120
step the project should stay working we

329
00:13:13,120 --> 00:13:14,959
never thought about totally start up a

330
00:13:14,959 --> 00:13:16,880
new project and just give up the

331
00:13:16,880 --> 00:13:19,360
official gizra that would take too much

332
00:13:19,360 --> 00:13:21,440
and we also don't have that manpower for

333
00:13:21,440 --> 00:13:23,920
maintaining such a huge beast so what

334
00:13:23,920 --> 00:13:26,320
are the differences what i think is we

335
00:13:26,320 --> 00:13:28,639
improve gear draw when we use it in this

336
00:13:28,639 --> 00:13:30,800
way we know what gizra lacks and since

337
00:13:30,800 --> 00:13:32,720
we know the internal of gizra we know

338
00:13:32,720 --> 00:13:34,639
how complex it is to implement the

339
00:13:34,639 --> 00:13:37,440
feature we want we play ctfs and that

340
00:13:37,440 --> 00:13:39,440
can be a quite good experience for

341
00:13:39,440 --> 00:13:42,639
tuning gear it's like extreme tests my

342
00:13:42,639 --> 00:13:44,880
wish is that by using this way of

343
00:13:44,880 --> 00:13:46,959
improving we can better understand of

344
00:13:46,959 --> 00:13:48,720
what we need as we are both the

345
00:13:48,720 --> 00:13:50,959
developer and the user i know some of

346
00:13:50,959 --> 00:13:53,360
you might think okay so you have ideas

347
00:13:53,360 --> 00:13:55,920
about qra you can develop those features

348
00:13:55,920 --> 00:13:57,760
and you don't have enough manpower to

349
00:13:57,760 --> 00:14:00,079
develop your own so why not just

350
00:14:00,079 --> 00:14:02,800
contribute that to the main repository

351
00:14:02,800 --> 00:14:04,720
well that would need some explain i'm

352
00:14:04,720 --> 00:14:06,959
not gonna deny that initially i wanted

353
00:14:06,959 --> 00:14:09,199
to do that this way but later i found

354
00:14:09,199 --> 00:14:11,279
that people all have different tastes

355
00:14:11,279 --> 00:14:14,079
this happens when adjusting the compiled

356
00:14:14,079 --> 00:14:16,560
coding style or user interface there's

357
00:14:16,560 --> 00:14:18,560
no such thing as ground truth in the

358
00:14:18,560 --> 00:14:21,040
compiled code if you ask me i think the

359
00:14:21,040 --> 00:14:22,959
compiler is never about recovering the

360
00:14:22,959 --> 00:14:24,720
original source code with only the

361
00:14:24,720 --> 00:14:27,279
binary but to give you more insight of

362
00:14:27,279 --> 00:14:29,279
how the original source code works and

363
00:14:29,279 --> 00:14:31,199
the decompiled code could make your life

364
00:14:31,199 --> 00:14:33,199
easier since you don't need to redraw

365
00:14:33,199 --> 00:14:35,279
assemblies for understand that

366
00:14:35,279 --> 00:14:37,440
that is we do not have a style that we

367
00:14:37,440 --> 00:14:40,240
all accept thus we always have the

368
00:14:40,240 --> 00:14:42,399
choice to make it style a or style b

369
00:14:42,399 --> 00:14:45,519
this is the same for ui as well and

370
00:14:45,519 --> 00:14:47,680
for this project when i decided to make

371
00:14:47,680 --> 00:14:50,079
it separate i was thinking about making

372
00:14:50,079 --> 00:14:51,680
it a different choice

373
00:14:51,680 --> 00:14:53,600
we have a different flavor and if you

374
00:14:53,600 --> 00:14:55,680
don't like it a solution you may choose

375
00:14:55,680 --> 00:14:58,000
ours one more choice is always good for

376
00:14:58,000 --> 00:14:59,600
this world isn't it

377
00:14:59,600 --> 00:15:01,839
two is the maintenance we will be

378
00:15:01,839 --> 00:15:04,240
following the upstream closely and if

379
00:15:04,240 --> 00:15:06,639
some of our features not about flavor

380
00:15:06,639 --> 00:15:08,320
issue we will still send that to the

381
00:15:08,320 --> 00:15:10,639
upstream so i'm not starting up a new

382
00:15:10,639 --> 00:15:13,279
religion like minecraft versus schedule

383
00:15:13,279 --> 00:15:14,880
no worry

384
00:15:14,880 --> 00:15:16,720
okay the name of the project as i

385
00:15:16,720 --> 00:15:18,959
mentioned is called bankrupt so what is

386
00:15:18,959 --> 00:15:21,279
minecraft i designed beancraft as a

387
00:15:21,279 --> 00:15:23,600
collection of scheduler related projects

388
00:15:23,600 --> 00:15:25,279
or a guitar release

389
00:15:25,279 --> 00:15:27,680
now bing craft has several projects

390
00:15:27,680 --> 00:15:30,399
first is our main topic today hiracraft

391
00:15:30,399 --> 00:15:32,800
which is a four giga following what

392
00:15:32,800 --> 00:15:35,120
rules we talked about already the second

393
00:15:35,120 --> 00:15:37,519
one we have is sleek craft i already

394
00:15:37,519 --> 00:15:39,360
mentioned slay dsl

395
00:15:39,360 --> 00:15:41,839
about what it is in general and how it

396
00:15:41,839 --> 00:15:44,480
provides the extensibility i believe you

397
00:15:44,480 --> 00:15:46,320
already know how great it is but

398
00:15:46,320 --> 00:15:48,639
unfortunately it is designed to be used

399
00:15:48,639 --> 00:15:51,600
in ghirar internally so sleek craft is

400
00:15:51,600 --> 00:15:54,399
to save you from that we provide apis in

401
00:15:54,399 --> 00:15:56,160
different programming languages to use

402
00:15:56,160 --> 00:15:58,720
display engine with that you can do what

403
00:15:58,720 --> 00:16:01,199
capstone is capable of and you even get

404
00:16:01,199 --> 00:16:02,880
the ir out of it

405
00:16:02,880 --> 00:16:05,759
and pickled craft a rust api to abstract

406
00:16:05,759 --> 00:16:08,639
away drastic compiler we tend to use

407
00:16:08,639 --> 00:16:11,040
that to complete our refactoring job and

408
00:16:11,040 --> 00:16:13,360
to split the vanilla ghetto decompiler

409
00:16:13,360 --> 00:16:16,079
into several reusable algorithms it is

410
00:16:16,079 --> 00:16:18,079
still not completed yet and so we will

411
00:16:18,079 --> 00:16:20,320
not talk about it in detail today

412
00:16:20,320 --> 00:16:22,560
minecraft is the name of the collections

413
00:16:22,560 --> 00:16:24,959
the reason we organize it this way

414
00:16:24,959 --> 00:16:27,199
is we may have many more projects

415
00:16:27,199 --> 00:16:29,839
according to our plan and many of them

416
00:16:29,839 --> 00:16:32,240
might be closely related so this

417
00:16:32,240 --> 00:16:34,839
collection could give you index to those

418
00:16:34,839 --> 00:16:37,680
projects let's get back to the guitar

419
00:16:37,680 --> 00:16:39,440
craft the main player we are going to

420
00:16:39,440 --> 00:16:41,440
talk about today till now the

421
00:16:41,440 --> 00:16:43,600
modernization is still in progress we

422
00:16:43,600 --> 00:16:45,920
have already done several tasks which i

423
00:16:45,920 --> 00:16:48,079
would like to share first we have the

424
00:16:48,079 --> 00:16:50,959
decompilation improvements this is more

425
00:16:50,959 --> 00:16:53,040
like a normal improvement but during

426
00:16:53,040 --> 00:16:55,440
that we face the flavor issue and tuning

427
00:16:55,440 --> 00:16:58,079
the style our way next thing to have is

428
00:16:58,079 --> 00:17:00,240
pickled patch feature this is the very

429
00:17:00,240 --> 00:17:02,079
first feature apart from the

430
00:17:02,079 --> 00:17:04,799
improvements you will get an idea of why

431
00:17:04,799 --> 00:17:07,359
we choose to do that shortly and finally

432
00:17:07,359 --> 00:17:10,799
we have partially modernized ui style

433
00:17:10,799 --> 00:17:12,959
let's dive into the first part about the

434
00:17:12,959 --> 00:17:15,439
decompilation you see every time the

435
00:17:15,439 --> 00:17:17,839
idac upgrade is out it would have an

436
00:17:17,839 --> 00:17:20,480
item seen that they did minor decompiler

437
00:17:20,480 --> 00:17:22,959
improvements before doing this i always

438
00:17:22,959 --> 00:17:25,119
think i can solve so many problems in

439
00:17:25,119 --> 00:17:27,520
the decompiler it turns out i was being

440
00:17:27,520 --> 00:17:30,000
too young the decompilation process is

441
00:17:30,000 --> 00:17:33,360
complex the code the algorithm the

442
00:17:33,360 --> 00:17:35,919
architecture are all complex especially

443
00:17:35,919 --> 00:17:38,720
when it is in c plus plus without modern

444
00:17:38,720 --> 00:17:41,440
c plus features references and raw

445
00:17:41,440 --> 00:17:43,679
pointers are everywhere and gidra even

446
00:17:43,679 --> 00:17:46,400
did a using namespace as td before every

447
00:17:46,400 --> 00:17:49,200
source code i have to admit this one is

448
00:17:49,200 --> 00:17:51,039
quite difficult to tune i will talk

449
00:17:51,039 --> 00:17:52,799
about some of it to give you a basic

450
00:17:52,799 --> 00:17:55,679
idea of how difficult it can be

451
00:17:55,679 --> 00:17:57,520
a little bit about gitrusty compiler

452
00:17:57,520 --> 00:17:59,840
first the overall structure is clear

453
00:17:59,840 --> 00:18:02,320
nothing special if you know that this is

454
00:18:02,320 --> 00:18:05,120
exactly how how vs code language server

455
00:18:05,120 --> 00:18:08,320
protocol will do a custom rpc protocol

456
00:18:08,320 --> 00:18:10,640
is used to interchange data between the

457
00:18:10,640 --> 00:18:13,039
java side and the c plus plus sign

458
00:18:13,039 --> 00:18:15,760
actually the github requires you to use

459
00:18:15,760 --> 00:18:18,000
such a way to connect java world and

460
00:18:18,000 --> 00:18:20,000
native world that's why when you need to

461
00:18:20,000 --> 00:18:22,320
write a plugin with native languages you

462
00:18:22,320 --> 00:18:24,400
can always choose the one you like as

463
00:18:24,400 --> 00:18:27,600
long as the rpc is working anyway the

464
00:18:27,600 --> 00:18:29,600
rpc protocol used by the keyword

465
00:18:29,600 --> 00:18:32,720
decompiler is in xml format mixed with

466
00:18:32,720 --> 00:18:34,799
binary values to mark starting and

467
00:18:34,799 --> 00:18:36,640
ending of a single packet

468
00:18:36,640 --> 00:18:39,200
each time gitra decompiles any function

469
00:18:39,200 --> 00:18:41,679
it launches the process send the

470
00:18:41,679 --> 00:18:44,320
previous result in xml format and the c

471
00:18:44,320 --> 00:18:46,880
plus plus executable deserialize it and

472
00:18:46,880 --> 00:18:48,799
does the decompilation send the

473
00:18:48,799 --> 00:18:52,080
decompiled result back in xml format

474
00:18:52,080 --> 00:18:54,640
just to mention that the xml format is

475
00:18:54,640 --> 00:18:57,039
treated engineer code as if it were a

476
00:18:57,039 --> 00:18:59,679
string in many places so if you'd like

477
00:18:59,679 --> 00:19:01,600
to add one more object that is both

478
00:19:01,600 --> 00:19:04,080
serializable and deserializable in java

479
00:19:04,080 --> 00:19:06,400
and c plus plus you have to define the

480
00:19:06,400 --> 00:19:08,640
serialization and deserialization

481
00:19:08,640 --> 00:19:10,720
yourself that is one place where your

482
00:19:10,720 --> 00:19:13,360
code gets very large

483
00:19:13,360 --> 00:19:15,360
about the c plus plus world it is more

484
00:19:15,360 --> 00:19:17,440
like a traditional compiler architecture

485
00:19:17,440 --> 00:19:20,480
like just like llvm we have the actions

486
00:19:20,480 --> 00:19:22,799
which might be called passes in the lvm

487
00:19:22,799 --> 00:19:25,039
or some of the compilers the global

488
00:19:25,039 --> 00:19:27,360
context is called architecture to

489
00:19:27,360 --> 00:19:29,200
provide architecture-specific

490
00:19:29,200 --> 00:19:31,600
information her function data is called

491
00:19:31,600 --> 00:19:34,400
just func data almost all the data in c

492
00:19:34,400 --> 00:19:36,320
plus plus world like architecture or

493
00:19:36,320 --> 00:19:38,160
func data is serializable and

494
00:19:38,160 --> 00:19:40,559
deserializable that is a requirement for

495
00:19:40,559 --> 00:19:42,799
java world to have full control over c

496
00:19:42,799 --> 00:19:44,720
plus plastic compiler you see the

497
00:19:44,720 --> 00:19:46,640
problem here there will be many code

498
00:19:46,640 --> 00:19:48,799
describing the serialization protocol

499
00:19:48,799 --> 00:19:51,200
and we don't have a dsl to describe such

500
00:19:51,200 --> 00:19:53,520
thing to make life easier once the

501
00:19:53,520 --> 00:19:55,679
protocol requested some result the

502
00:19:55,679 --> 00:19:58,720
actions are run each action performs one

503
00:19:58,720 --> 00:20:00,480
of the steps required by the

504
00:20:00,480 --> 00:20:03,840
decompilation the actions work on the ir

505
00:20:03,840 --> 00:20:06,559
manipulate them extract information

506
00:20:06,559 --> 00:20:08,559
record it into the function or

507
00:20:08,559 --> 00:20:10,960
architecture finally when we are all

508
00:20:10,960 --> 00:20:13,679
done the pseudo code is generated by a

509
00:20:13,679 --> 00:20:16,000
language printing component in xml

510
00:20:16,000 --> 00:20:18,240
format then the result is fed into the

511
00:20:18,240 --> 00:20:21,039
product again to reach java world

512
00:20:21,039 --> 00:20:22,960
as you can see the central of the

513
00:20:22,960 --> 00:20:25,679
decompower is the ir they used called

514
00:20:25,679 --> 00:20:29,039
picot the actions perform many pollution

515
00:20:29,039 --> 00:20:31,520
by inserting removing or modifying the

516
00:20:31,520 --> 00:20:34,320
picot ir the ir is designed to be

517
00:20:34,320 --> 00:20:36,960
suitable for low-level analysis it was

518
00:20:36,960 --> 00:20:39,120
originated from an ir between the

519
00:20:39,120 --> 00:20:41,520
translation of two instructions

520
00:20:41,520 --> 00:20:44,080
they model all variables as bar node

521
00:20:44,080 --> 00:20:46,480
identified by three parts the address

522
00:20:46,480 --> 00:20:48,559
space offset and size

523
00:20:48,559 --> 00:20:50,400
the address space is just like a piece

524
00:20:50,400 --> 00:20:53,280
of memory or a huge array if you'd like

525
00:20:53,280 --> 00:20:55,919
to think it that way along with the name

526
00:20:55,919 --> 00:20:58,240
some names have special semantics like

527
00:20:58,240 --> 00:21:01,039
register ram which is used as memory

528
00:21:01,039 --> 00:21:03,520
temporary values are in unique space

529
00:21:03,520 --> 00:21:06,080
even the constants or immediates have a

530
00:21:06,080 --> 00:21:07,919
space named const

531
00:21:07,919 --> 00:21:10,080
but that is a special space it is not a

532
00:21:10,080 --> 00:21:13,520
huge array the offset in constant space

533
00:21:13,520 --> 00:21:15,440
is treated as the constant itself

534
00:21:15,440 --> 00:21:16,640
directly

535
00:21:16,640 --> 00:21:18,960
one thing i feel quite intriguing in

536
00:21:18,960 --> 00:21:21,200
this kind of design is that how they

537
00:21:21,200 --> 00:21:23,520
model the registers as just a plain

538
00:21:23,520 --> 00:21:24,960
piece of memory

539
00:21:24,960 --> 00:21:28,159
normally registers are modeled as it is

540
00:21:28,159 --> 00:21:30,480
we have register names and size for each

541
00:21:30,480 --> 00:21:32,480
of them but if you consider the

542
00:21:32,480 --> 00:21:35,039
overlapping between registers that kind

543
00:21:35,039 --> 00:21:36,799
of model could just make things really

544
00:21:36,799 --> 00:21:38,240
complicated

545
00:21:38,240 --> 00:21:41,600
as for pqw we see that for example the

546
00:21:41,600 --> 00:21:44,159
zero offset in the register space under

547
00:21:44,159 --> 00:21:48,240
x86 is rax since we have the overlapping

548
00:21:48,240 --> 00:21:51,200
eax register is easily modeled as the

549
00:21:51,200 --> 00:21:53,520
same offset but different size

550
00:21:53,520 --> 00:21:55,760
operations are just normal operations

551
00:21:55,760 --> 00:21:58,000
like you may encounter in any risk-like

552
00:21:58,000 --> 00:21:59,600
instruction set

553
00:21:59,600 --> 00:22:01,600
there are some special operations we

554
00:22:01,600 --> 00:22:03,600
need to care about for example the

555
00:22:03,600 --> 00:22:06,320
multi-equal instruction this instruction

556
00:22:06,320 --> 00:22:08,480
is not intended to be used after the

557
00:22:08,480 --> 00:22:10,840
lifting but to be used during the

558
00:22:10,840 --> 00:22:14,000
decompilation multi-equal instruction is

559
00:22:14,000 --> 00:22:16,480
the fine node of ssa form

560
00:22:16,480 --> 00:22:18,880
it is internal to the decompiler itself

561
00:22:18,880 --> 00:22:21,360
by using such instructions the internal

562
00:22:21,360 --> 00:22:25,120
form such as ssa is still invalid picot

563
00:22:25,120 --> 00:22:26,720
and we don't need a different data

564
00:22:26,720 --> 00:22:29,440
structure to store them

565
00:22:29,440 --> 00:22:31,200
this is the overall structure of the

566
00:22:31,200 --> 00:22:33,679
decompiler the actions that are run when

567
00:22:33,679 --> 00:22:35,440
the function is requested to be

568
00:22:35,440 --> 00:22:38,080
decompiled it would be too much to talk

569
00:22:38,080 --> 00:22:40,559
about this in detail since it is not the

570
00:22:40,559 --> 00:22:41,919
goal of this talk

571
00:22:41,919 --> 00:22:44,480
i am just putting it there to have you

572
00:22:44,480 --> 00:22:46,480
understood how complex the comp

573
00:22:46,480 --> 00:22:49,120
decomposition process can be

574
00:22:49,120 --> 00:22:51,520
so let's get back to our tasks first

575
00:22:51,520 --> 00:22:53,679
thing to ask is what things should be

576
00:22:53,679 --> 00:22:56,320
done to improve the decompiler to

577
00:22:56,320 --> 00:22:58,080
balance between the implementation

578
00:22:58,080 --> 00:23:00,880
difficulty and its benefit during real

579
00:23:00,880 --> 00:23:03,679
world reversing we have selected out

580
00:23:03,679 --> 00:23:06,080
some of the goals as the first step

581
00:23:06,080 --> 00:23:08,159
those include the appearance of the

582
00:23:08,159 --> 00:23:11,840
magic functions such as concat or zext

583
00:23:11,840 --> 00:23:14,400
the lengthy default variable names the

584
00:23:14,400 --> 00:23:18,880
analysis figure and more minor problems

585
00:23:18,880 --> 00:23:21,120
about the magic functions this happens a

586
00:23:21,120 --> 00:23:23,760
lot in gitra sometimes when we reverse

587
00:23:23,760 --> 00:23:27,600
binary those functions like concat 44 or

588
00:23:27,600 --> 00:23:31,039
zex t8 just come out of nowhere since

589
00:23:31,039 --> 00:23:33,039
usually we don't have those functions in

590
00:23:33,039 --> 00:23:36,159
c language without documentation we will

591
00:23:36,159 --> 00:23:38,159
definitely have a hard time guessing

592
00:23:38,159 --> 00:23:39,520
what those mean

593
00:23:39,520 --> 00:23:42,080
it turns out they are just pico that is

594
00:23:42,080 --> 00:23:46,000
not translatable concat or zext is the p

595
00:23:46,000 --> 00:23:48,960
code instruction for example the concat

596
00:23:48,960 --> 00:23:51,760
44 is just concatenating four bytes and

597
00:23:51,760 --> 00:23:53,679
four bytes to form an eight bytes

598
00:23:53,679 --> 00:23:54,799
variable

599
00:23:54,799 --> 00:23:57,520
comparing to ida i found that ida tries

600
00:23:57,520 --> 00:23:59,520
to its best to not show those magic

601
00:23:59,520 --> 00:24:01,600
functions but this does not seem to be

602
00:24:01,600 --> 00:24:04,240
the same in github and following aydah's

603
00:24:04,240 --> 00:24:06,559
idea i think we have a better way of

604
00:24:06,559 --> 00:24:07,600
showing this

605
00:24:07,600 --> 00:24:10,320
as a result we added a rewrite rule to

606
00:24:10,320 --> 00:24:12,320
convert the concave instruction into

607
00:24:12,320 --> 00:24:14,799
typecasting and normal arithmetic

608
00:24:14,799 --> 00:24:17,520
operations just to mention while writing

609
00:24:17,520 --> 00:24:19,600
the rewrite rule we found gibra

610
00:24:19,600 --> 00:24:21,919
decompiler does not have an abstraction

611
00:24:21,919 --> 00:24:24,320
of rule matching and rewriting liking

612
00:24:24,320 --> 00:24:28,960
llvm llvm has an ast matching dsl which

613
00:24:28,960 --> 00:24:31,360
makes writing such matching convenient

614
00:24:31,360 --> 00:24:33,679
but in gidra you're on your own

615
00:24:33,679 --> 00:24:35,760
in the future when we decide to refactor

616
00:24:35,760 --> 00:24:39,440
this part of code we might add them

617
00:24:39,440 --> 00:24:41,520
about the default variables current

618
00:24:41,520 --> 00:24:43,679
gearjust variable names are way too long

619
00:24:43,679 --> 00:24:46,320
compared to ida i totally understand the

620
00:24:46,320 --> 00:24:48,559
reason they do this since they do not

621
00:24:48,559 --> 00:24:51,440
choose the way ida did use a short name

622
00:24:51,440 --> 00:24:53,520
and add a comment introducing extra

623
00:24:53,520 --> 00:24:55,919
information like the offset of this

624
00:24:55,919 --> 00:24:58,240
stack variable they decided to add

625
00:24:58,240 --> 00:25:01,039
everything in the variable names but the

626
00:25:01,039 --> 00:25:03,679
outcome seems to be too verbal

627
00:25:03,679 --> 00:25:05,760
when reversing a large function and

628
00:25:05,760 --> 00:25:08,559
since we get used to iodus way already

629
00:25:08,559 --> 00:25:11,039
we decided to change that this is not

630
00:25:11,039 --> 00:25:13,279
difficult but just a user experience

631
00:25:13,279 --> 00:25:15,919
issue and we made it into an option so

632
00:25:15,919 --> 00:25:18,960
we give you the choice

633
00:25:18,960 --> 00:25:21,279
okay the next thing we have is what

634
00:25:21,279 --> 00:25:24,000
matters the most the analysis failure

635
00:25:24,000 --> 00:25:26,240
take a look at this picture this is from

636
00:25:26,240 --> 00:25:28,400
a defcon course challenge this year

637
00:25:28,400 --> 00:25:30,720
called rad red

638
00:25:30,720 --> 00:25:33,360
the challenge is written in rust and as

639
00:25:33,360 --> 00:25:35,440
you can see the output code is totally

640
00:25:35,440 --> 00:25:37,520
not readable there are plenty of

641
00:25:37,520 --> 00:25:39,679
assignment to an array that appears to

642
00:25:39,679 --> 00:25:42,159
be a magic number if you take a look

643
00:25:42,159 --> 00:25:44,240
carefully you will notice that this

644
00:25:44,240 --> 00:25:46,559
assignment all happened before a call to

645
00:25:46,559 --> 00:25:49,039
a function and yeah as you might guess

646
00:25:49,039 --> 00:25:50,720
this number is where the function should

647
00:25:50,720 --> 00:25:51,600
return

648
00:25:51,600 --> 00:25:54,240
ie the next instruction address after

649
00:25:54,240 --> 00:25:56,400
the function call all other stack

650
00:25:56,400 --> 00:25:58,480
variables have this problem as well the

651
00:25:58,480 --> 00:26:00,720
simple operations are translated into a

652
00:26:00,720 --> 00:26:02,799
store into stack space

653
00:26:02,799 --> 00:26:04,799
there's a variable that contains a lot

654
00:26:04,799 --> 00:26:07,679
of f's in its name that is actually the

655
00:26:07,679 --> 00:26:09,039
stack base

656
00:26:09,039 --> 00:26:11,520
of this frame so all other stack

657
00:26:11,520 --> 00:26:14,000
variables are not analyzed out instead

658
00:26:14,000 --> 00:26:15,520
they are all translated into the

659
00:26:15,520 --> 00:26:17,520
relative addressing with reference to

660
00:26:17,520 --> 00:26:20,400
the stack f blah blah variable also all

661
00:26:20,400 --> 00:26:22,799
the function params are just gone

662
00:26:22,799 --> 00:26:25,200
after that ctf i played with it a little

663
00:26:25,200 --> 00:26:27,760
bit and fixed these two problems stack

664
00:26:27,760 --> 00:26:30,159
variable analysis failure and function

665
00:26:30,159 --> 00:26:32,559
params analysis figure at the time of

666
00:26:32,559 --> 00:26:35,039
defcon we used ida to reverse this

667
00:26:35,039 --> 00:26:37,279
challenge ada also suffers from the

668
00:26:37,279 --> 00:26:39,360
function patterns failure but is doing

669
00:26:39,360 --> 00:26:41,520
better in the stack variable analysis

670
00:26:41,520 --> 00:26:43,440
actually that is one of the most

671
00:26:43,440 --> 00:26:45,600
important problem as without the stack

672
00:26:45,600 --> 00:26:48,000
variables the decompilation result is

673
00:26:48,000 --> 00:26:50,559
not useful in the end especially because

674
00:26:50,559 --> 00:26:52,720
of gilda's mechanism you can never get

675
00:26:52,720 --> 00:26:54,640
rid of this assignment of the return

676
00:26:54,640 --> 00:26:56,720
address

677
00:26:56,720 --> 00:26:58,159
let's talk about the stack variable

678
00:26:58,159 --> 00:27:00,640
analysis problem first to understand

679
00:27:00,640 --> 00:27:02,400
this problem you will need to first

680
00:27:02,400 --> 00:27:04,000
understand how the stack variable

681
00:27:04,000 --> 00:27:06,480
analysis in gitra works i'm not gonna

682
00:27:06,480 --> 00:27:08,880
lie this takes me quite a while it is

683
00:27:08,880 --> 00:27:10,240
not because schedule has no

684
00:27:10,240 --> 00:27:12,480
documentation about it it is because the

685
00:27:12,480 --> 00:27:14,720
documentation is not something for me i

686
00:27:14,720 --> 00:27:16,640
think you may need to read the code

687
00:27:16,640 --> 00:27:18,799
again and again and the documentation as

688
00:27:18,799 --> 00:27:21,440
well to fully understand the mechanism

689
00:27:21,440 --> 00:27:23,919
anyway about the stack variable analysis

690
00:27:23,919 --> 00:27:26,399
in gitra the actual algorithm is way

691
00:27:26,399 --> 00:27:28,000
more complicated than this but this

692
00:27:28,000 --> 00:27:30,240
should give you the idea gidra first

693
00:27:30,240 --> 00:27:33,200
marks out the input rrsp the initial rsp

694
00:27:33,200 --> 00:27:35,440
value of this function that is used with

695
00:27:35,440 --> 00:27:37,039
but not defined

696
00:27:37,039 --> 00:27:39,840
let's give it another name rsp0 note

697
00:27:39,840 --> 00:27:42,159
that gidra does not do any inter

698
00:27:42,159 --> 00:27:44,559
procedure analysis which means when

699
00:27:44,559 --> 00:27:46,880
decompiles a function it does not take

700
00:27:46,880 --> 00:27:48,799
on any look at any other functions

701
00:27:48,799 --> 00:27:49,760
inside

702
00:27:49,760 --> 00:27:51,919
after that hydra will run a constant

703
00:27:51,919 --> 00:27:54,320
propagation procedure this constant

704
00:27:54,320 --> 00:27:56,720
propagation procedure is not specific to

705
00:27:56,720 --> 00:27:59,200
this analysis but its result is used

706
00:27:59,200 --> 00:28:00,000
here

707
00:28:00,000 --> 00:28:02,640
then hydra thinks after the constant

708
00:28:02,640 --> 00:28:05,760
propagation all the rsp values should be

709
00:28:05,760 --> 00:28:08,640
marked now in the form of input rsp or

710
00:28:08,640 --> 00:28:11,360
rsp0 adding a constant

711
00:28:11,360 --> 00:28:13,919
if it's not in this form for example if

712
00:28:13,919 --> 00:28:17,279
you got rsp 0 multiply something then it

713
00:28:17,279 --> 00:28:19,600
is not possible to be treated as stack

714
00:28:19,600 --> 00:28:20,720
variables

715
00:28:20,720 --> 00:28:23,840
and what causes the problem initially at

716
00:28:23,840 --> 00:28:25,840
the very beginning of the rust compiled

717
00:28:25,840 --> 00:28:28,720
function there's an rsp constant

718
00:28:28,720 --> 00:28:31,679
instruction after the end instruction

719
00:28:31,679 --> 00:28:35,120
the rsp values are now not rxp0 at a

720
00:28:35,120 --> 00:28:36,480
constant

721
00:28:36,480 --> 00:28:40,399
what we have is rsp0 and a constant then

722
00:28:40,399 --> 00:28:43,039
add another constant in this form gitra

723
00:28:43,039 --> 00:28:45,840
thinks okay you're not a stack variable

724
00:28:45,840 --> 00:28:48,720
then how about we treat you as an offset

725
00:28:48,720 --> 00:28:52,000
into the variable that equals rsp 0 and

726
00:28:52,000 --> 00:28:52,799
c

727
00:28:52,799 --> 00:28:55,919
about the magic numbers these are return

728
00:28:55,919 --> 00:28:58,080
addresses i already mentioned that the

729
00:28:58,080 --> 00:29:00,320
reason behind it that giza treat the

730
00:29:00,320 --> 00:29:02,559
return operation as if it were an

731
00:29:02,559 --> 00:29:04,559
indirect branch

732
00:29:04,559 --> 00:29:06,960
so it does not do anything about store

733
00:29:06,960 --> 00:29:09,679
the return value so the store return

734
00:29:09,679 --> 00:29:12,640
value operation is explicit once the

735
00:29:12,640 --> 00:29:15,200
stack variable analysis fails it has no

736
00:29:15,200 --> 00:29:17,440
idea that this is a store of a return

737
00:29:17,440 --> 00:29:20,559
value it sees it as a normal assignment

738
00:29:20,559 --> 00:29:22,640
that's why we get our final decompiled

739
00:29:22,640 --> 00:29:24,720
output full of such return address

740
00:29:24,720 --> 00:29:26,799
assignment

741
00:29:26,799 --> 00:29:29,520
as for the empty patterns problem this

742
00:29:29,520 --> 00:29:31,919
one is not that annoying but still i

743
00:29:31,919 --> 00:29:34,720
decided to fix it since i met it

744
00:29:34,720 --> 00:29:37,200
that is my philosophy at least i should

745
00:29:37,200 --> 00:29:39,760
fix things i met this problem is caused

746
00:29:39,760 --> 00:29:42,000
by the dwarf debugging information

747
00:29:42,000 --> 00:29:45,919
handling usually as in c or c plus when

748
00:29:45,919 --> 00:29:48,960
you do not specify hyphen g to enable

749
00:29:48,960 --> 00:29:51,200
debugging information the debugging

750
00:29:51,200 --> 00:29:53,679
information is not generated

751
00:29:53,679 --> 00:29:56,159
but ross does this in a different way it

752
00:29:56,159 --> 00:29:58,080
always generates the debugging

753
00:29:58,080 --> 00:30:00,320
information but if you do ask for

754
00:30:00,320 --> 00:30:02,960
optimization it generates incomplete

755
00:30:02,960 --> 00:30:05,039
debugging information

756
00:30:05,039 --> 00:30:07,120
parents information is one of the

757
00:30:07,120 --> 00:30:09,919
example it generates function names but

758
00:30:09,919 --> 00:30:12,880
not params then you just develop

759
00:30:12,880 --> 00:30:15,679
tailor things we have a function but no

760
00:30:15,679 --> 00:30:16,799
parents

761
00:30:16,799 --> 00:30:19,039
that gives us this situation

762
00:30:19,039 --> 00:30:21,600
ida also suffers from this problem rust

763
00:30:21,600 --> 00:30:23,840
is just not supported by the reverse

764
00:30:23,840 --> 00:30:26,640
engineering community for sure so next

765
00:30:26,640 --> 00:30:28,640
time you want to protect some important

766
00:30:28,640 --> 00:30:30,640
code just use rust

767
00:30:30,640 --> 00:30:33,360
the result is that we fix this by adding

768
00:30:33,360 --> 00:30:35,520
this special case and the pull request

769
00:30:35,520 --> 00:30:39,120
is already merged into the upstream

770
00:30:39,120 --> 00:30:42,080
and we have minor bugs such as the wrong

771
00:30:42,080 --> 00:30:44,159
display of the string in the decompiled

772
00:30:44,159 --> 00:30:45,039
panel

773
00:30:45,039 --> 00:30:47,679
as i remembered ida also suffers from

774
00:30:47,679 --> 00:30:50,559
this problem golan and rust compiled

775
00:30:50,559 --> 00:30:52,799
binary has a different layout of string

776
00:30:52,799 --> 00:30:54,960
multiple strings are put together

777
00:30:54,960 --> 00:30:57,679
and that confused the compiler display

778
00:30:57,679 --> 00:30:59,840
this is not a bug worth noting too much

779
00:30:59,840 --> 00:31:01,679
the fix is still in the pull request

780
00:31:01,679 --> 00:31:05,039
list of the upstream gear

781
00:31:05,039 --> 00:31:07,200
okay enough of the fixes let's talk

782
00:31:07,200 --> 00:31:09,760
about the feature a feature called picot

783
00:31:09,760 --> 00:31:11,919
patch has been added to our guitar craft

784
00:31:11,919 --> 00:31:14,399
which is responsible for modifying

785
00:31:14,399 --> 00:31:16,320
program semantic

786
00:31:16,320 --> 00:31:18,480
what makes things different is that we

787
00:31:18,480 --> 00:31:20,240
support both manual patching and

788
00:31:20,240 --> 00:31:22,640
descriptive patching many of you might

789
00:31:22,640 --> 00:31:25,039
already know that ida also has such a

790
00:31:25,039 --> 00:31:27,519
functionality but all in all we are

791
00:31:27,519 --> 00:31:28,720
still different

792
00:31:28,720 --> 00:31:31,200
ada called this ir patching micro code

793
00:31:31,200 --> 00:31:33,760
api you can insert a phase into the

794
00:31:33,760 --> 00:31:36,720
decompower pipeline to manipulate the ir

795
00:31:36,720 --> 00:31:38,559
when the compiler is run

796
00:31:38,559 --> 00:31:40,399
our way of patching is not in the

797
00:31:40,399 --> 00:31:42,799
decompiled pipeline but instead before

798
00:31:42,799 --> 00:31:44,880
the decompiler is run

799
00:31:44,880 --> 00:31:46,799
this allows us to achieve manual

800
00:31:46,799 --> 00:31:47,840
patching

801
00:31:47,840 --> 00:31:50,240
by right clicking on the p code you can

802
00:31:50,240 --> 00:31:53,200
patch insert or remove the p code before

803
00:31:53,200 --> 00:31:56,320
the decompiler runs in this way we get a

804
00:31:56,320 --> 00:31:58,799
more interactive analysis loop we

805
00:31:58,799 --> 00:32:01,600
inspect patch the p code then inspect

806
00:32:01,600 --> 00:32:02,960
again quickly

807
00:32:02,960 --> 00:32:06,159
no need to write the scripts for that

808
00:32:06,159 --> 00:32:08,000
the manual patching follows what is

809
00:32:08,000 --> 00:32:10,640
called raw picot format the picot

810
00:32:10,640 --> 00:32:12,399
instruction contains one node and

811
00:32:12,399 --> 00:32:15,039
operations each one node contains three

812
00:32:15,039 --> 00:32:16,080
parts

813
00:32:16,080 --> 00:32:18,559
the name offset and size

814
00:32:18,559 --> 00:32:20,480
the operation names follow gitra

815
00:32:20,480 --> 00:32:22,720
official reference to picot

816
00:32:22,720 --> 00:32:25,279
here we have an example of this syntax

817
00:32:25,279 --> 00:32:27,279
in this sentence we're adding two

818
00:32:27,279 --> 00:32:30,880
constants first one has offset eight and

819
00:32:30,880 --> 00:32:34,640
size eight second one has offset 16 and

820
00:32:34,640 --> 00:32:35,760
size eight

821
00:32:35,760 --> 00:32:38,080
as i said before the offset to the

822
00:32:38,080 --> 00:32:40,240
constant space is the actual value of

823
00:32:40,240 --> 00:32:41,519
the constant

824
00:32:41,519 --> 00:32:43,440
then the value gets assigned to the

825
00:32:43,440 --> 00:32:46,279
unique space variable offset

826
00:32:46,279 --> 00:32:50,559
0x1234 which should be a temporary value

827
00:32:50,559 --> 00:32:52,960
as for scripting you need to have the

828
00:32:52,960 --> 00:32:55,279
instruction instance to patch p code

829
00:32:55,279 --> 00:32:57,360
this is because precode is always

830
00:32:57,360 --> 00:33:00,159
attached to a single instruction then

831
00:33:00,159 --> 00:33:03,600
you can pass the raw picot syntax with

832
00:33:03,600 --> 00:33:06,559
picot raw parser to get a picot array

833
00:33:06,559 --> 00:33:08,559
and patch it on the instruction to

834
00:33:08,559 --> 00:33:10,880
modify its semantic

835
00:33:10,880 --> 00:33:13,200
when i initially wrote this i have

836
00:33:13,200 --> 00:33:15,919
thought about three use cases first one

837
00:33:15,919 --> 00:33:18,480
is to quickly modify program semantic

838
00:33:18,480 --> 00:33:20,960
that we have already discussed

839
00:33:20,960 --> 00:33:22,880
you can do things like modify part of

840
00:33:22,880 --> 00:33:25,760
the decompiled program by sp code then

841
00:33:25,760 --> 00:33:28,320
inspect the result instantly i know that

842
00:33:28,320 --> 00:33:30,080
if you patch the bytes on the

843
00:33:30,080 --> 00:33:32,000
instruction you can also get similar

844
00:33:32,000 --> 00:33:34,320
result but the difference is

845
00:33:34,320 --> 00:33:36,720
sometimes there are only little space

846
00:33:36,720 --> 00:33:39,039
you can put in the instruction box but

847
00:33:39,039 --> 00:33:41,120
if you patch the picot you don't need to

848
00:33:41,120 --> 00:33:42,480
care about that

849
00:33:42,480 --> 00:33:44,240
another thing to mention is the

850
00:33:44,240 --> 00:33:47,039
obfuscation the same as above

851
00:33:47,039 --> 00:33:48,880
you don't need to worry about length

852
00:33:48,880 --> 00:33:50,640
that is the major reason why still

853
00:33:50,640 --> 00:33:53,200
provides a scripting interface and the

854
00:33:53,200 --> 00:33:55,760
final one i like this one the most is to

855
00:33:55,760 --> 00:33:58,320
allow total custom decompilation you

856
00:33:58,320 --> 00:34:00,720
provide gizra the picot ir it gives you

857
00:34:00,720 --> 00:34:03,039
the decompiled code i really like this

858
00:34:03,039 --> 00:34:05,279
use case we'll be talking about it later

859
00:34:05,279 --> 00:34:07,840
in detail

860
00:34:08,000 --> 00:34:10,560
a simple example of the first use case

861
00:34:10,560 --> 00:34:12,639
this is a real example of my reversing a

862
00:34:12,639 --> 00:34:15,599
ctf challenge the challenge uses runtime

863
00:34:15,599 --> 00:34:17,440
extraction techniques to extract the

864
00:34:17,440 --> 00:34:19,599
basic blocks one by one

865
00:34:19,599 --> 00:34:21,839
i used the emulation technique to deal

866
00:34:21,839 --> 00:34:24,399
with that and successfully got all the

867
00:34:24,399 --> 00:34:27,040
basic blog instructions out the next

868
00:34:27,040 --> 00:34:29,040
problem i have is to connect these

869
00:34:29,040 --> 00:34:30,879
blocks together to get the full

870
00:34:30,879 --> 00:34:32,480
decompilation

871
00:34:32,480 --> 00:34:34,399
this should be normal if you could just

872
00:34:34,399 --> 00:34:36,480
patch the jumping instruction at the end

873
00:34:36,480 --> 00:34:38,399
of each basic block

874
00:34:38,399 --> 00:34:40,960
however this is not the case the

875
00:34:40,960 --> 00:34:43,199
challenge uses an ending mark to mark

876
00:34:43,199 --> 00:34:45,359
the end of each basic block and the

877
00:34:45,359 --> 00:34:47,839
handler to handle such ending bark when

878
00:34:47,839 --> 00:34:48,960
it's there

879
00:34:48,960 --> 00:34:51,280
long story short i was left just two

880
00:34:51,280 --> 00:34:53,119
bytes but i need to patch a jumping

881
00:34:53,119 --> 00:34:54,399
instruction there

882
00:34:54,399 --> 00:34:56,960
then i used picot patch to just patch

883
00:34:56,960 --> 00:34:59,359
the branching in picot and i got the

884
00:34:59,359 --> 00:35:02,640
decompilation working

885
00:35:02,640 --> 00:35:05,200
the obfuscation is nothing special to

886
00:35:05,200 --> 00:35:07,040
demonstrate that we wrote a simple

887
00:35:07,040 --> 00:35:09,119
script to deflating the control flow

888
00:35:09,119 --> 00:35:11,760
flattening contained in the ollvm

889
00:35:11,760 --> 00:35:13,680
obfuscation framework

890
00:35:13,680 --> 00:35:15,760
this script is provided in the gita

891
00:35:15,760 --> 00:35:18,400
crafts repository as well searching for

892
00:35:18,400 --> 00:35:21,440
llvm in the script manager will find it

893
00:35:21,440 --> 00:35:24,960
it works under multiple architectures

894
00:35:24,960 --> 00:35:27,040
now let's get to my favorite part the

895
00:35:27,040 --> 00:35:30,079
custom decompilation you patch the ir

896
00:35:30,079 --> 00:35:32,560
get the decompilation let's think about

897
00:35:32,560 --> 00:35:34,880
it first what is the normal way of

898
00:35:34,880 --> 00:35:37,520
decompile a custom instruction set

899
00:35:37,520 --> 00:35:39,920
because of the slay engine requirement

900
00:35:39,920 --> 00:35:42,720
we at least need to specify how to parse

901
00:35:42,720 --> 00:35:45,440
it binary into a tree how to display

902
00:35:45,440 --> 00:35:47,359
that tree that is to display the

903
00:35:47,359 --> 00:35:49,839
disassembly and then to translate the

904
00:35:49,839 --> 00:35:51,920
tree into a piece of picker

905
00:35:51,920 --> 00:35:54,000
this is not a problem if you are really

906
00:35:54,000 --> 00:35:56,640
dealing with an instruction set but what

907
00:35:56,640 --> 00:35:59,200
if you are not

908
00:35:59,200 --> 00:36:00,960
that is where we needed custom

909
00:36:00,960 --> 00:36:03,599
decompilation actually this should be

910
00:36:03,599 --> 00:36:05,839
just a trick leveraging the picopatch

911
00:36:05,839 --> 00:36:08,800
functionality to do that you can set up

912
00:36:08,800 --> 00:36:12,000
a new segment and not instruction there

913
00:36:12,000 --> 00:36:14,640
then patch the picot to that place once

914
00:36:14,640 --> 00:36:15,920
you've done that you get the

915
00:36:15,920 --> 00:36:17,359
decompilation

916
00:36:17,359 --> 00:36:19,359
in this way what you are doing is

917
00:36:19,359 --> 00:36:21,760
bypassing this slay engine so that you

918
00:36:21,760 --> 00:36:23,920
don't need to provide the complete slay

919
00:36:23,920 --> 00:36:27,920
dsl which sometimes is an overkill or

920
00:36:27,920 --> 00:36:30,400
sometimes you just can't do that

921
00:36:30,400 --> 00:36:32,640
under some circumstances you might be

922
00:36:32,640 --> 00:36:34,560
needing that like a weird instruction

923
00:36:34,560 --> 00:36:37,040
set you know how it can be translated

924
00:36:37,040 --> 00:36:39,760
into picot but the complete display is

925
00:36:39,760 --> 00:36:42,560
hard to write for example if your

926
00:36:42,560 --> 00:36:45,280
instruction is in text format

927
00:36:45,280 --> 00:36:48,240
no binary representation then the slave

928
00:36:48,240 --> 00:36:51,280
engine is getting troubles

929
00:36:51,280 --> 00:36:53,359
one example of that is the brain brimfox

930
00:36:53,359 --> 00:36:56,079
language it is an esolan i've picked up

931
00:36:56,079 --> 00:36:58,079
its semantic here you can see this

932
00:36:58,079 --> 00:37:00,640
language contains only several symbols

933
00:37:00,640 --> 00:37:02,640
and it's quite low level

934
00:37:02,640 --> 00:37:04,880
each symbol is like a single instruction

935
00:37:04,880 --> 00:37:06,880
within that instruction set

936
00:37:06,880 --> 00:37:08,800
we should be able to decompile this

937
00:37:08,800 --> 00:37:11,680
thing but the problem is if we'd like to

938
00:37:11,680 --> 00:37:14,240
do that we have to go through the whole

939
00:37:14,240 --> 00:37:17,520
slave pipeline and write a slave dsl for

940
00:37:17,520 --> 00:37:21,119
that which i think it's an overkill

941
00:37:21,119 --> 00:37:23,839
bring is kind of a special example

942
00:37:23,839 --> 00:37:26,560
that its symbol is all single characters

943
00:37:26,560 --> 00:37:28,960
if you insist you can still get slay

944
00:37:28,960 --> 00:37:31,200
working for brain but it is

945
00:37:31,200 --> 00:37:33,119
possible that we may have such an

946
00:37:33,119 --> 00:37:35,520
instruction set that has only text

947
00:37:35,520 --> 00:37:38,079
representation that you cannot directly

948
00:37:38,079 --> 00:37:40,480
use the slay engine to handle it this

949
00:37:40,480 --> 00:37:43,040
happens a lot in ctfs

950
00:37:43,040 --> 00:37:43,839
so

951
00:37:43,839 --> 00:37:45,920
what the result is like these two

952
00:37:45,920 --> 00:37:47,599
pictures show you the result of

953
00:37:47,599 --> 00:37:50,640
decompiling a hello world program in

954
00:37:50,640 --> 00:37:53,280
brinfog you can see that the looping is

955
00:37:53,280 --> 00:37:55,839
successfully translated and by doing a

956
00:37:55,839 --> 00:37:58,240
little bit more to add a code to the

957
00:37:58,240 --> 00:38:00,640
right instruction we made this even look

958
00:38:00,640 --> 00:38:01,680
better

959
00:38:01,680 --> 00:38:03,680
i definitely would like to reverse this

960
00:38:03,680 --> 00:38:05,839
kind of code instead of original brief

961
00:38:05,839 --> 00:38:07,040
code

962
00:38:07,040 --> 00:38:09,280
i know you might argue that by

963
00:38:09,280 --> 00:38:12,880
translating the code into x86 or r you

964
00:38:12,880 --> 00:38:15,599
can get this result probably as well

965
00:38:15,599 --> 00:38:17,920
but the thing is in that case the

966
00:38:17,920 --> 00:38:20,560
temporary variables like we used in

967
00:38:20,560 --> 00:38:22,800
unique address space the one that i

968
00:38:22,800 --> 00:38:24,560
mentioned to store the temporary

969
00:38:24,560 --> 00:38:26,960
variables in p code you have to manage

970
00:38:26,960 --> 00:38:28,480
that your own

971
00:38:28,480 --> 00:38:30,800
not to mention that picot is designed to

972
00:38:30,800 --> 00:38:33,599
be used between languages it is no doubt

973
00:38:33,599 --> 00:38:37,440
more easy to use to translate into

974
00:38:37,440 --> 00:38:39,920
as for the ui we have also did quite

975
00:38:39,920 --> 00:38:42,640
some jobs to make ui feel better things

976
00:38:42,640 --> 00:38:45,440
including fix some classical stylings

977
00:38:45,440 --> 00:38:48,640
and configurable color setting support

978
00:38:48,640 --> 00:38:51,119
guitar has a lot of colors and they are

979
00:38:51,119 --> 00:38:53,680
not equal some of them are configurable

980
00:38:53,680 --> 00:38:55,920
in the settings a color picker is

981
00:38:55,920 --> 00:38:58,400
implemented for that some of them just

982
00:38:58,400 --> 00:39:01,200
follows the underlying javascript theme

983
00:39:01,200 --> 00:39:03,680
but but that's not all of them

984
00:39:03,680 --> 00:39:05,599
some of the colors are hardcoded into

985
00:39:05,599 --> 00:39:08,079
the gita code i don't know about the

986
00:39:08,079 --> 00:39:10,560
reason they do it initially but that

987
00:39:10,560 --> 00:39:11,599
happens

988
00:39:11,599 --> 00:39:13,599
it is not configurable not in the

989
00:39:13,599 --> 00:39:16,240
settings or any kind of configure files

990
00:39:16,240 --> 00:39:17,839
just hard coded

991
00:39:17,839 --> 00:39:19,920
the javascript theme is possible to be

992
00:39:19,920 --> 00:39:22,480
switched in gita and if you do that

993
00:39:22,480 --> 00:39:24,480
those hard-coded colors appear to be

994
00:39:24,480 --> 00:39:26,960
really annoying some of them mess with

995
00:39:26,960 --> 00:39:28,880
the background and you can't see any

996
00:39:28,880 --> 00:39:30,800
characters that's why we make that

997
00:39:30,800 --> 00:39:32,880
configurable with the color dot

998
00:39:32,880 --> 00:39:35,760
properties file but unfortunately we can

999
00:39:35,760 --> 00:39:38,079
only do some of the adjust

1000
00:39:38,079 --> 00:39:40,400
the colors are too many in github and we

1001
00:39:40,400 --> 00:39:42,880
can just deal with it right now we might

1002
00:39:42,880 --> 00:39:45,280
use some helps on this

1003
00:39:45,280 --> 00:39:48,240
this is the demo of the ui for now it is

1004
00:39:48,240 --> 00:39:50,480
not possible to show you all the changes

1005
00:39:50,480 --> 00:39:53,040
but i think you get the basic idea

1006
00:39:53,040 --> 00:39:54,960
there's not much to talk about how we

1007
00:39:54,960 --> 00:39:57,440
feel about the new ui interface there

1008
00:39:57,440 --> 00:39:59,599
are still a lot of things we can do

1009
00:39:59,599 --> 00:40:02,640
fixing colors dealing with windows 98

1010
00:40:02,640 --> 00:40:06,240
styles we have fixed some but not all

1011
00:40:06,240 --> 00:40:08,319
this is not a really hard job to do but

1012
00:40:08,319 --> 00:40:11,280
we do need manpower on this

1013
00:40:11,280 --> 00:40:14,720
and what we have next is the grio vm

1014
00:40:14,720 --> 00:40:17,599
integration this is a planned feature

1015
00:40:17,599 --> 00:40:20,240
but honestly i just can't get it done in

1016
00:40:20,240 --> 00:40:22,640
time before the presentation but i think

1017
00:40:22,640 --> 00:40:25,119
the idea is intriguing so i decided to

1018
00:40:25,119 --> 00:40:28,000
share it with you guys

1019
00:40:28,000 --> 00:40:29,760
what is griovm

1020
00:40:29,760 --> 00:40:31,359
it is one of the state of the art

1021
00:40:31,359 --> 00:40:34,400
technology in compiler area developed by

1022
00:40:34,400 --> 00:40:35,680
oracle

1023
00:40:35,680 --> 00:40:37,599
the idea is quite fun

1024
00:40:37,599 --> 00:40:41,359
by reuse java hotspot jit engine griovm

1025
00:40:41,359 --> 00:40:43,760
is able to jit compile any programming

1026
00:40:43,760 --> 00:40:46,400
languages even low level ones such as

1027
00:40:46,400 --> 00:40:48,079
llvm

1028
00:40:48,079 --> 00:40:50,720
what i like most is about the analysis

1029
00:40:50,720 --> 00:40:52,640
part once you have the language

1030
00:40:52,640 --> 00:40:55,040
implementation it provides you with the

1031
00:40:55,040 --> 00:40:57,359
general instrumentation framework and

1032
00:40:57,359 --> 00:41:00,880
the instrumentation should work on a jit

1033
00:41:00,880 --> 00:41:03,839
to us this is definitely good news

1034
00:41:03,839 --> 00:41:05,839
we finally have the tools to achieve

1035
00:41:05,839 --> 00:41:08,160
cheated binary emulation without too

1036
00:41:08,160 --> 00:41:10,400
much of a work with the help of the grio

1037
00:41:10,400 --> 00:41:11,520
vm

1038
00:41:11,520 --> 00:41:14,160
current implementation of the emulation

1039
00:41:14,160 --> 00:41:16,880
in gitra is a nightmare it is

1040
00:41:16,880 --> 00:41:19,520
embarrassingly slow and with the help of

1041
00:41:19,520 --> 00:41:21,839
the instrumentation framework we might

1042
00:41:21,839 --> 00:41:24,400
even reuse the analysis designed for

1043
00:41:24,400 --> 00:41:26,160
another languages

1044
00:41:26,160 --> 00:41:28,880
we need to have that consensus binary

1045
00:41:28,880 --> 00:41:31,920
analysis is an extremely small area

1046
00:41:31,920 --> 00:41:33,440
comparing to general programming

1047
00:41:33,440 --> 00:41:35,680
languages analysis

1048
00:41:35,680 --> 00:41:38,319
no doubt those tools designed for other

1049
00:41:38,319 --> 00:41:41,040
languages must have a better maintenance

1050
00:41:41,040 --> 00:41:43,760
and luckily with this technology we are

1051
00:41:43,760 --> 00:41:46,319
finally possible to reuse them

1052
00:41:46,319 --> 00:41:48,800
we might have free tinted analysis or

1053
00:41:48,800 --> 00:41:51,520
even symbolic execution for free

1054
00:41:51,520 --> 00:41:54,400
well if not we might consider do that

1055
00:41:54,400 --> 00:41:56,720
anyway

1056
00:41:56,720 --> 00:41:58,720
gorilla vm provides a language

1057
00:41:58,720 --> 00:42:01,680
implementation framework called truffle

1058
00:42:01,680 --> 00:42:04,640
truffle eases the usage of grill vm by

1059
00:42:04,640 --> 00:42:07,359
allowing us to write the interpreter and

1060
00:42:07,359 --> 00:42:09,359
we get the jit out

1061
00:42:09,359 --> 00:42:11,440
automatically by applying partial

1062
00:42:11,440 --> 00:42:14,000
evaluation one of the state-of-the-art

1063
00:42:14,000 --> 00:42:16,880
dynamic compilation techniques

1064
00:42:16,880 --> 00:42:19,440
and this can be even easier as we do

1065
00:42:19,440 --> 00:42:22,319
need to design everything our own as the

1066
00:42:22,319 --> 00:42:25,839
griovm actually has an interpreter for

1067
00:42:25,839 --> 00:42:29,440
evaluating llvm bitcode which is quite

1068
00:42:29,440 --> 00:42:32,560
like to us called syulong

1069
00:42:32,560 --> 00:42:35,760
so what we are gonna do is to add one

1070
00:42:35,760 --> 00:42:38,240
more so-called language with the travel

1071
00:42:38,240 --> 00:42:41,280
api as any other languages this picture

1072
00:42:41,280 --> 00:42:44,720
just depicts that

1073
00:42:44,720 --> 00:42:46,960
since the p code has so many things in

1074
00:42:46,960 --> 00:42:49,040
common with llvm

1075
00:42:49,040 --> 00:42:51,119
we are like just following their

1076
00:42:51,119 --> 00:42:54,480
approach and get our things done

1077
00:42:54,480 --> 00:42:56,319
allow me to pirate the slide from

1078
00:42:56,319 --> 00:42:59,040
previous real vms work for executing the

1079
00:42:59,040 --> 00:43:00,319
llvm

1080
00:43:00,319 --> 00:43:03,920
to execute llvm bytecode we need clan to

1081
00:43:03,920 --> 00:43:06,160
generate the llvmir

1082
00:43:06,160 --> 00:43:09,040
and cylon what they developed to execute

1083
00:43:09,040 --> 00:43:12,480
llvmir receives the ir and use the

1084
00:43:12,480 --> 00:43:15,520
travel api to generate an asd

1085
00:43:15,520 --> 00:43:17,760
this ast is the base of the jit

1086
00:43:17,760 --> 00:43:20,800
compilation then the cst is sent to the

1087
00:43:20,800 --> 00:43:23,920
gvm where the actual jit compilation or

1088
00:43:23,920 --> 00:43:26,319
interpretation is happen

1089
00:43:26,319 --> 00:43:28,800
and for us we are almost following the

1090
00:43:28,800 --> 00:43:31,359
same approach use travel api to generate

1091
00:43:31,359 --> 00:43:34,240
the ast4 picker

1092
00:43:34,240 --> 00:43:37,520
how the mid silon works for llvm is out

1093
00:43:37,520 --> 00:43:38,560
of scope

1094
00:43:38,560 --> 00:43:40,400
one can always refer to their

1095
00:43:40,400 --> 00:43:42,400
publication to get what they need to

1096
00:43:42,400 --> 00:43:43,359
know

1097
00:43:43,359 --> 00:43:45,359
i myself learn a lot reading those

1098
00:43:45,359 --> 00:43:47,839
papers and i read their code sometimes

1099
00:43:47,839 --> 00:43:50,000
to understand how they get things done

1100
00:43:50,000 --> 00:43:53,880
when i get into a problem

1101
00:43:54,400 --> 00:43:56,560
the developing procedure is splitted

1102
00:43:56,560 --> 00:43:59,280
into four stages by the time of this

1103
00:43:59,280 --> 00:44:01,680
presentation the first two stages are

1104
00:44:01,680 --> 00:44:04,160
already finished because of current

1105
00:44:04,160 --> 00:44:06,560
emulation code within guidra does not

1106
00:44:06,560 --> 00:44:09,359
care about the extensibility this code

1107
00:44:09,359 --> 00:44:13,119
can be reused is not abstracted out

1108
00:44:13,119 --> 00:44:15,440
we have to do the refactor first that's

1109
00:44:15,440 --> 00:44:17,839
why we have stage zero

1110
00:44:17,839 --> 00:44:21,119
then a poc interpreter implemented using

1111
00:44:21,119 --> 00:44:23,520
truffle framework is needed to prove our

1112
00:44:23,520 --> 00:44:25,920
choice as possible

1113
00:44:25,920 --> 00:44:28,560
and to learn how the griovm should be

1114
00:44:28,560 --> 00:44:29,680
used

1115
00:44:29,680 --> 00:44:32,400
stage 2 and 3 is the next we are about

1116
00:44:32,400 --> 00:44:33,359
to do

1117
00:44:33,359 --> 00:44:35,520
do the true g team following official

1118
00:44:35,520 --> 00:44:37,520
grill vms so long

1119
00:44:37,520 --> 00:44:40,000
and finally we add the instrumentation

1120
00:44:40,000 --> 00:44:41,920
tricks to the world

1121
00:44:41,920 --> 00:44:43,520
initially i thought about we could

1122
00:44:43,520 --> 00:44:45,920
complete at least three stages before

1123
00:44:45,920 --> 00:44:48,319
the presentation but it needs more code

1124
00:44:48,319 --> 00:44:51,200
than i expected most of the time i used

1125
00:44:51,200 --> 00:44:54,000
to learn how griovm the another beast

1126
00:44:54,000 --> 00:44:56,319
works

1127
00:44:57,359 --> 00:44:59,119
that's it that's all the things we'd

1128
00:44:59,119 --> 00:45:02,000
like to demonstrate about gidra craft

1129
00:45:02,000 --> 00:45:04,160
as for the lessons learned kidra is

1130
00:45:04,160 --> 00:45:06,640
really a huge beast that you can handle

1131
00:45:06,640 --> 00:45:08,319
in a short time

1132
00:45:08,319 --> 00:45:10,720
sometimes the internal docs are missing

1133
00:45:10,720 --> 00:45:12,880
and you may cost quite some time to get

1134
00:45:12,880 --> 00:45:15,520
why the code is written in this way

1135
00:45:15,520 --> 00:45:17,920
especially because it is huge and

1136
00:45:17,920 --> 00:45:20,480
contains so many concepts

1137
00:45:20,480 --> 00:45:23,599
and the coding style is not quite modern

1138
00:45:23,599 --> 00:45:25,920
you may wonder sometimes why it is

1139
00:45:25,920 --> 00:45:27,920
written in this way instead of some way

1140
00:45:27,920 --> 00:45:29,359
you know better

1141
00:45:29,359 --> 00:45:31,440
it turns out those ways may not even

1142
00:45:31,440 --> 00:45:33,920
exist when this code is written

1143
00:45:33,920 --> 00:45:36,800
but the advantage is undeniable it is a

1144
00:45:36,800 --> 00:45:39,440
complete thing many of the basic stuff

1145
00:45:39,440 --> 00:45:42,000
you require to implement the feature of

1146
00:45:42,000 --> 00:45:44,319
fixes are just provided

1147
00:45:44,319 --> 00:45:46,160
you can always refer to them to

1148
00:45:46,160 --> 00:45:48,560
understand how things can be done

1149
00:45:48,560 --> 00:45:50,960
for that i think we still need more time

1150
00:45:50,960 --> 00:45:53,200
and a larger community to complete what

1151
00:45:53,200 --> 00:45:55,839
we started

1152
00:45:55,920 --> 00:45:57,839
thank you guys again for listening this

1153
00:45:57,839 --> 00:46:00,079
sharing we really hope to have you with

1154
00:46:00,079 --> 00:46:00,800
us

1155
00:46:00,800 --> 00:46:03,359
since we follow upstream closely it

1156
00:46:03,359 --> 00:46:05,599
should be fine to experience the early

1157
00:46:05,599 --> 00:46:08,400
development version we are still working

1158
00:46:08,400 --> 00:46:10,480
hard to provide at least a working build

1159
00:46:10,480 --> 00:46:12,960
so you can at least feel it

1160
00:46:12,960 --> 00:46:14,960
and it's extremely best if you could

1161
00:46:14,960 --> 00:46:17,359
join the development hope you guys

1162
00:46:17,359 --> 00:46:19,760
enjoyed this presentation see you next

1163
00:46:19,760 --> 00:46:22,760
time

