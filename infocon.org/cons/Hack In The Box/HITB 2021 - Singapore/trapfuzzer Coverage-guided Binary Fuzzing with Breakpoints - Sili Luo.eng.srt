1
00:00:09,599 --> 00:00:11,360
hello everyone thank you for attending

2
00:00:11,360 --> 00:00:14,160
my talk i'm sorry i'm happy to share my

3
00:00:14,160 --> 00:00:16,800
topic today my topic is chiropractor

4
00:00:16,800 --> 00:00:18,560
college guided binary fuzzing with

5
00:00:18,560 --> 00:00:21,279
breakpoint

6
00:00:21,520 --> 00:00:23,359
first of all please allow me to

7
00:00:23,359 --> 00:00:24,880
introduce myself

8
00:00:24,880 --> 00:00:27,119
i am security researcher at huawei root

9
00:00:27,119 --> 00:00:30,320
lab i focused on software availability

10
00:00:30,320 --> 00:00:32,719
research below are my twitter and github

11
00:00:32,719 --> 00:00:35,040
links the tour will be open sourced on

12
00:00:35,040 --> 00:00:37,680
github if you are interested you can

13
00:00:37,680 --> 00:00:38,719
follow me

14
00:00:38,719 --> 00:00:42,239
next i will show my topic

15
00:00:42,640 --> 00:00:44,719
let's start our topic this is alternate

16
00:00:44,719 --> 00:00:46,960
of today's presentation

17
00:00:46,960 --> 00:00:49,360
firstly i will introduce some background

18
00:00:49,360 --> 00:00:52,800
of cherry father next i will explain the

19
00:00:52,800 --> 00:00:55,199
implementation of the tool then i will

20
00:00:55,199 --> 00:00:58,160
take wps office as an example to explain

21
00:00:58,160 --> 00:01:00,399
how to further software with traverse

22
00:01:00,399 --> 00:01:02,239
and the frozen result

23
00:01:02,239 --> 00:01:04,319
finally i will summarize the speech and

24
00:01:04,319 --> 00:01:08,000
introduce some future plans

25
00:01:09,439 --> 00:01:11,600
now i will introduce some background

26
00:01:11,600 --> 00:01:13,439
knowledge of shellfish

27
00:01:13,439 --> 00:01:15,920
including the concept of fuzzing as well

28
00:01:15,920 --> 00:01:18,240
as the comparison of developing

29
00:01:18,240 --> 00:01:20,798
terrifies

30
00:01:20,880 --> 00:01:22,720
first of all let's take a look at what

31
00:01:22,720 --> 00:01:25,520
is fuzzing the simplest facet is showing

32
00:01:25,520 --> 00:01:28,000
in the figure the code in the figure is

33
00:01:28,000 --> 00:01:30,799
to generate random binary data then if

34
00:01:30,799 --> 00:01:33,280
we fill the output data to target

35
00:01:33,280 --> 00:01:34,240
process

36
00:01:34,240 --> 00:01:37,119
this is frozen

37
00:01:38,479 --> 00:01:40,400
next i will briefly introduce the

38
00:01:40,400 --> 00:01:42,320
courage guided buzzing the general

39
00:01:42,320 --> 00:01:44,799
workflow of curry guided father is shown

40
00:01:44,799 --> 00:01:47,360
in the figure it usually maintains a

41
00:01:47,360 --> 00:01:50,320
cure of cedar test case and performs a

42
00:01:50,320 --> 00:01:52,799
functioning rule first the father will

43
00:01:52,799 --> 00:01:55,840
select a test case and the mutated is to

44
00:01:55,840 --> 00:01:58,079
generate a new test case then father

45
00:01:58,079 --> 00:02:00,079
will fill the new test case to target

46
00:02:00,079 --> 00:02:01,280
the process

47
00:02:01,280 --> 00:02:03,520
unlike black box fuzzing courage guided

48
00:02:03,520 --> 00:02:05,280
father will monitor the program

49
00:02:05,280 --> 00:02:07,680
execution to check its code coverage if

50
00:02:07,680 --> 00:02:09,840
the test case find a new call coverage

51
00:02:09,840 --> 00:02:11,840
the father will approve the test kit

52
00:02:11,840 --> 00:02:13,360
into the queue

53
00:02:13,360 --> 00:02:15,360
through this feedback mechanism fuzzer

54
00:02:15,360 --> 00:02:17,440
can automatically generate a efficient

55
00:02:17,440 --> 00:02:19,599
test case so that father can find the

56
00:02:19,599 --> 00:02:23,200
deep logic of the program

57
00:02:23,200 --> 00:02:25,680
next let me introduce two main events

58
00:02:25,680 --> 00:02:27,840
that inspired me to develop a chat

59
00:02:27,840 --> 00:02:30,480
further as shown on the left side of the

60
00:02:30,480 --> 00:02:31,519
slide

61
00:02:31,519 --> 00:02:33,920
in april 2020

62
00:02:33,920 --> 00:02:36,560
google project xero published a research

63
00:02:36,560 --> 00:02:40,080
about fuzzing image i o or mac os system

64
00:02:40,080 --> 00:02:42,000
in order to perform encourage guided

65
00:02:42,000 --> 00:02:44,800
fuzzing in macos the os portal novel

66
00:02:44,800 --> 00:02:46,959
banner instrumentation method to hong

67
00:02:46,959 --> 00:02:49,760
kong it first obtains a start offset of

68
00:02:49,760 --> 00:02:52,319
each basic block in the program through

69
00:02:52,319 --> 00:02:54,800
either person then it will pass the

70
00:02:54,800 --> 00:02:57,440
module in memory which just replace the

71
00:02:57,440 --> 00:02:59,519
first byte of every basic block with

72
00:02:59,519 --> 00:03:03,519
0xcc crxcc is the breakpoint instruction

73
00:03:03,519 --> 00:03:04,640
on intel

74
00:03:04,640 --> 00:03:06,879
then it will register a secret traps

75
00:03:06,879 --> 00:03:09,440
handler to handle the breakpoint events

76
00:03:09,440 --> 00:03:11,599
and finally get the basic blocker that

77
00:03:11,599 --> 00:03:14,640
has been executed this article reminds

78
00:03:14,640 --> 00:03:18,480
me of a research research in 2018

79
00:03:18,480 --> 00:03:21,200
which is the right side of the slide

80
00:03:21,200 --> 00:03:23,440
its main idea is to obtain coverage by

81
00:03:23,440 --> 00:03:25,840
patching the first instruction of each

82
00:03:25,840 --> 00:03:27,840
basic block in file

83
00:03:27,840 --> 00:03:29,840
the difference with google project

84
00:03:29,840 --> 00:03:31,840
method is that it directly patches

85
00:03:31,840 --> 00:03:33,920
executable file instead of patching

86
00:03:33,920 --> 00:03:34,959
memory

87
00:03:34,959 --> 00:03:37,040
after patching the file it runs the

88
00:03:37,040 --> 00:03:39,519
target process by a custom debugger and

89
00:03:39,519 --> 00:03:43,440
handle the breakpoint event in it

90
00:03:44,560 --> 00:03:47,599
combining my previous fuzzing experience

91
00:03:47,599 --> 00:03:48,400
and

92
00:03:48,400 --> 00:03:51,519
this tool security research i realized

93
00:03:51,519 --> 00:03:54,159
that firstly the existing excellent

94
00:03:54,159 --> 00:03:56,959
response intros such as afl home files

95
00:03:56,959 --> 00:03:59,439
are not perfect and they are still

96
00:03:59,439 --> 00:04:02,080
unsupported error in completely

97
00:04:02,080 --> 00:04:04,640
supported scenarios such as large closed

98
00:04:04,640 --> 00:04:06,560
source programs and some special

99
00:04:06,560 --> 00:04:08,159
operating system

100
00:04:08,159 --> 00:04:09,120
second

101
00:04:09,120 --> 00:04:12,000
using relatively inefficient instrument

102
00:04:12,000 --> 00:04:14,400
method for fuzzing can also obtain

103
00:04:14,400 --> 00:04:16,720
better results than complete blackboard

104
00:04:16,720 --> 00:04:18,720
fuzzing such as instruments with

105
00:04:18,720 --> 00:04:20,238
breakpoints

106
00:04:20,238 --> 00:04:22,320
i also searched through google and found

107
00:04:22,320 --> 00:04:24,560
that fuzzing tools for larger clothes so

108
00:04:24,560 --> 00:04:27,360
things software are real

109
00:04:27,360 --> 00:04:29,840
commonly used linux fuzzing tools are

110
00:04:29,840 --> 00:04:32,479
pitch browser and afl they both have

111
00:04:32,479 --> 00:04:34,800
some shortcomings first page files don't

112
00:04:34,800 --> 00:04:36,639
support current information

113
00:04:36,639 --> 00:04:39,520
second aflq email mode is only suitable

114
00:04:39,520 --> 00:04:41,440
for relatively

115
00:04:41,440 --> 00:04:45,040
small program such as an imaging image

116
00:04:45,040 --> 00:04:47,840
path library

117
00:04:47,840 --> 00:04:50,720
so i decided to develop a further based

118
00:04:50,720 --> 00:04:53,360
on the breakpoint mechanism to support

119
00:04:53,360 --> 00:04:55,680
some scenarios that are not covered by

120
00:04:55,680 --> 00:04:57,440
exciting tools

121
00:04:57,440 --> 00:04:59,840
such as large closed source file parsing

122
00:04:59,840 --> 00:05:04,320
software and provides currency support

123
00:05:06,400 --> 00:05:08,479
next i will introduce the implementation

124
00:05:08,479 --> 00:05:10,639
of trail including the software

125
00:05:10,639 --> 00:05:13,120
architecture and the implementation of

126
00:05:13,120 --> 00:05:15,759
each module

127
00:05:16,880 --> 00:05:19,360
first let's take a look at the overall

128
00:05:19,360 --> 00:05:21,600
architecture of charifiers traffic can

129
00:05:21,600 --> 00:05:24,880
be divided into four components

130
00:05:24,880 --> 00:05:27,360
namely binary patch module further

131
00:05:27,360 --> 00:05:29,840
schedule module see the mutation module

132
00:05:29,840 --> 00:05:31,520
and the trace module

133
00:05:31,520 --> 00:05:34,479
the workflow of the tools is as follows

134
00:05:34,479 --> 00:05:37,039
first the user find the

135
00:05:37,039 --> 00:05:38,240
modules that are needed being

136
00:05:38,240 --> 00:05:40,880
instrumented then use binary pressure to

137
00:05:40,880 --> 00:05:43,680
pair the target module it will replace

138
00:05:43,680 --> 00:05:46,479
the first charging of each basic blocks

139
00:05:46,479 --> 00:05:49,520
with a breakpoint instruction

140
00:05:49,520 --> 00:05:51,520
in this step we directly pass the

141
00:05:51,520 --> 00:05:53,919
executable file in file system

142
00:05:53,919 --> 00:05:56,319
then user starts the file and provides

143
00:05:56,319 --> 00:05:58,880
some initial test case for fusing the

144
00:05:58,880 --> 00:06:01,520
further will randomly select a test case

145
00:06:01,520 --> 00:06:04,160
from the cdq and enhance it to the city

146
00:06:04,160 --> 00:06:05,680
mutation module

147
00:06:05,680 --> 00:06:07,919
just see the mutation module will mutate

148
00:06:07,919 --> 00:06:10,240
the test case to generate a new test

149
00:06:10,240 --> 00:06:12,560
case then father will fill the new test

150
00:06:12,560 --> 00:06:14,400
case to target program

151
00:06:14,400 --> 00:06:16,560
then the trace module starts the target

152
00:06:16,560 --> 00:06:18,880
process in debugger mode it will handle

153
00:06:18,880 --> 00:06:21,039
the breakpoint events of the target

154
00:06:21,039 --> 00:06:22,160
process

155
00:06:22,160 --> 00:06:24,639
finally the trace module will give the

156
00:06:24,639 --> 00:06:26,880
obtained coverage information to the

157
00:06:26,880 --> 00:06:29,440
father the further schedule module will

158
00:06:29,440 --> 00:06:31,440
use the discovery information to

159
00:06:31,440 --> 00:06:33,360
determine whether the test case needed

160
00:06:33,360 --> 00:06:35,280
to be added to the queue and

161
00:06:35,280 --> 00:06:37,520
at the same time puzzle will score the

162
00:06:37,520 --> 00:06:40,240
success in the queue the bubble is a

163
00:06:40,240 --> 00:06:43,600
approximate workflow of terrific next i

164
00:06:43,600 --> 00:06:48,039
will introduce each module in detail

165
00:06:48,319 --> 00:06:49,680
first i will introduce the

166
00:06:49,680 --> 00:06:51,360
implementation of the binary patch

167
00:06:51,360 --> 00:06:54,080
module this page describes the working

168
00:06:54,080 --> 00:06:58,400
mechanism of the binary patching module

169
00:06:58,400 --> 00:07:00,400
the input of binary patcher is a

170
00:07:00,400 --> 00:07:02,160
executable file that needs to be

171
00:07:02,160 --> 00:07:05,199
instrumented such as a library

172
00:07:05,199 --> 00:07:08,560
the output is a password the basic flow

173
00:07:08,560 --> 00:07:10,800
info file the basic block info file

174
00:07:10,800 --> 00:07:12,080
stores each

175
00:07:12,080 --> 00:07:14,800
basic block information or binary file

176
00:07:14,800 --> 00:07:17,199
including the virtual offset the fair

177
00:07:17,199 --> 00:07:19,840
offset and the first instruction of each

178
00:07:19,840 --> 00:07:22,560
basic block the workflow of this module

179
00:07:22,560 --> 00:07:24,960
is showing the figure

180
00:07:24,960 --> 00:07:27,199
first user provides some modules that

181
00:07:27,199 --> 00:07:30,080
need to be instrumented such as label a

182
00:07:30,080 --> 00:07:34,479
e dot so label b dot so liquid x dot so

183
00:07:34,479 --> 00:07:36,800
then the binary patcher will start a

184
00:07:36,800 --> 00:07:40,240
multiple ida pi instance to analyze this

185
00:07:40,240 --> 00:07:42,639
thread libraries after the ns is

186
00:07:42,639 --> 00:07:45,840
completed it will use the ida python

187
00:07:45,840 --> 00:07:48,319
script to actually get the information

188
00:07:48,319 --> 00:07:51,360
of each basic block and save it as a

189
00:07:51,360 --> 00:07:53,919
basic block info file finally the binary

190
00:07:53,919 --> 00:07:55,759
patcher will patch this straight library

191
00:07:55,759 --> 00:07:58,240
according to the basic blog info file it

192
00:07:58,240 --> 00:08:00,240
will replace the first instruction of

193
00:08:00,240 --> 00:08:03,520
basic block with breakpoint instruction

194
00:08:03,520 --> 00:08:08,000
next i will introduce some examples

195
00:08:10,080 --> 00:08:12,160
and show in the figure is an example of

196
00:08:12,160 --> 00:08:14,319
basic block info file the format of the

197
00:08:14,319 --> 00:08:17,280
file is as follows so first four bytes

198
00:08:17,280 --> 00:08:19,440
indicates the size of the file in the

199
00:08:19,440 --> 00:08:21,759
memory next is the file name of the

200
00:08:21,759 --> 00:08:23,680
executable file corresponding to the

201
00:08:23,680 --> 00:08:26,160
basic block info file the file name is

202
00:08:26,160 --> 00:08:28,720
followed by the bb enforce structure

203
00:08:28,720 --> 00:08:29,520
list

204
00:08:29,520 --> 00:08:32,880
the bb infos juggle is representing the

205
00:08:32,880 --> 00:08:36,320
information of each basic block

206
00:08:36,320 --> 00:08:38,080
there are three members in bb

207
00:08:38,080 --> 00:08:40,240
infrastructure the meaning of each

208
00:08:40,240 --> 00:08:42,320
member is as follows

209
00:08:42,320 --> 00:08:44,959
first rva represents the module offset

210
00:08:44,959 --> 00:08:47,120
of the basic plot in the processor

211
00:08:47,120 --> 00:08:48,240
memory

212
00:08:48,240 --> 00:08:49,680
fof

213
00:08:49,680 --> 00:08:52,000
represents the offset of the basic block

214
00:08:52,000 --> 00:08:53,680
in the file

215
00:08:53,680 --> 00:08:55,760
instasize and install indicate the

216
00:08:55,760 --> 00:08:58,000
particle for the first instruction of

217
00:08:58,000 --> 00:09:00,800
the basic block

218
00:09:02,880 --> 00:09:04,480
this picture shows the difference

219
00:09:04,480 --> 00:09:07,279
between an elf executable file before

220
00:09:07,279 --> 00:09:10,399
and after being positive

221
00:09:10,399 --> 00:09:12,160
the left side of the picture is the

222
00:09:12,160 --> 00:09:14,800
original file the right side is a patch

223
00:09:14,800 --> 00:09:17,600
the file we can see that some extraction

224
00:09:17,600 --> 00:09:20,399
in the original file has been replaced

225
00:09:20,399 --> 00:09:23,200
with zlxcc which is

226
00:09:23,200 --> 00:09:26,000
actually the back code of the breakpoint

227
00:09:26,000 --> 00:09:28,640
instruction

228
00:09:29,760 --> 00:09:32,800
here are two screenshots of ida the left

229
00:09:32,800 --> 00:09:35,040
is the original binary the right is a

230
00:09:35,040 --> 00:09:37,600
banner of the patch you can see that

231
00:09:37,600 --> 00:09:39,519
some mischaracters have been replaced

232
00:09:39,519 --> 00:09:43,600
with industry instruction

233
00:09:45,360 --> 00:09:47,360
next let's take a look at the

234
00:09:47,360 --> 00:09:50,160
implementation of the cd mutation module

235
00:09:50,160 --> 00:09:52,399
and show in the figure the seed mutation

236
00:09:52,399 --> 00:09:55,440
is to randomly replace some data in the

237
00:09:55,440 --> 00:09:57,200
test case

238
00:09:57,200 --> 00:09:59,680
currently there are two seed mutation

239
00:09:59,680 --> 00:10:02,399
modules in traversal red amsa and

240
00:10:02,399 --> 00:10:05,040
mutated and the tiny mutator an amster

241
00:10:05,040 --> 00:10:07,839
mutator encrypts later then amsterdam

242
00:10:07,839 --> 00:10:10,959
and msi is an open source seed mutation

243
00:10:10,959 --> 00:10:13,440
trust tiny mutator is a relatively

244
00:10:13,440 --> 00:10:15,519
simple system mutation taurus including

245
00:10:15,519 --> 00:10:17,839
some physical mutation strategies such

246
00:10:17,839 --> 00:10:19,680
as better flipping and the boundary

247
00:10:19,680 --> 00:10:21,920
value replacement

248
00:10:21,920 --> 00:10:24,160
unlike a random enzyme mutator tiny

249
00:10:24,160 --> 00:10:26,959
mutator surprise configure the ratio of

250
00:10:26,959 --> 00:10:29,839
seed mutation so that the mutator will

251
00:10:29,839 --> 00:10:32,079
only mutate a small part of the test

252
00:10:32,079 --> 00:10:34,959
case the comparison of this tool mutator

253
00:10:34,959 --> 00:10:37,120
will be introduced later

254
00:10:37,120 --> 00:10:39,920
let's continue

255
00:10:40,000 --> 00:10:41,839
on this page i will introduce the

256
00:10:41,839 --> 00:10:44,720
implementation of the further module the

257
00:10:44,720 --> 00:10:46,640
further module will first load the

258
00:10:46,640 --> 00:10:48,640
initial test case to see the queue and

259
00:10:48,640 --> 00:10:49,360
do

260
00:10:49,360 --> 00:10:52,800
corpus destination on it

261
00:10:52,800 --> 00:10:54,720
then it will

262
00:10:54,720 --> 00:10:57,440
traverse the cdq mutated the test case

263
00:10:57,440 --> 00:10:59,680
and use the trace module to start the

264
00:10:59,680 --> 00:11:02,320
target process finally it will carry the

265
00:11:02,320 --> 00:11:05,360
coverage and execution status of the

266
00:11:05,360 --> 00:11:08,640
process if new coverage is found the new

267
00:11:08,640 --> 00:11:11,680
test case will be added to the cdq if

268
00:11:11,680 --> 00:11:13,760
crash is found the crash contest is

269
00:11:13,760 --> 00:11:18,079
saved such as register and stack chase

270
00:11:18,079 --> 00:11:20,640
there are also two simple scheduling

271
00:11:20,640 --> 00:11:22,560
strategies in the further module the

272
00:11:22,560 --> 00:11:24,480
score of test cases that found new

273
00:11:24,480 --> 00:11:26,800
currency will increase the score of test

274
00:11:26,800 --> 00:11:29,279
case i trigger those availabilities will

275
00:11:29,279 --> 00:11:32,399
decrease the purpose the purpose of this

276
00:11:32,399 --> 00:11:35,279
is wanted to further explore new

277
00:11:35,279 --> 00:11:37,279
coverage as much as possible and the fun

278
00:11:37,279 --> 00:11:39,519
tool and to find them feel those

279
00:11:39,519 --> 00:11:42,480
vulnerabilities because those bug will

280
00:11:42,480 --> 00:11:45,760
waste too much time

281
00:11:47,760 --> 00:11:50,240
the workflow our corporate destination

282
00:11:50,240 --> 00:11:52,880
is as follows first the further let the

283
00:11:52,880 --> 00:11:54,800
program process each test case in the

284
00:11:54,800 --> 00:11:57,920
cdq they only save the test case which

285
00:11:57,920 --> 00:12:00,160
can generate a unique coverage to see

286
00:12:00,160 --> 00:12:02,480
the queue in this way we can reduce the

287
00:12:02,480 --> 00:12:05,120
number of test cases in the cdq

288
00:12:05,120 --> 00:12:07,519
the figure below is an example there are

289
00:12:07,519 --> 00:12:10,880
five test cases in the initial circuit

290
00:12:10,880 --> 00:12:13,360
the basic block coverage by this file

291
00:12:13,360 --> 00:12:17,440
test case iab cdef to test the case 1

292
00:12:17,440 --> 00:12:21,200
2 and 5 insert qr can also call

293
00:12:21,200 --> 00:12:23,920
abcdef therefore the final test case

294
00:12:23,920 --> 00:12:26,880
shielded in the cdq after destination is

295
00:12:26,880 --> 00:12:30,800
a test case one two five

296
00:12:34,800 --> 00:12:37,040
next i will introduce the implementation

297
00:12:37,040 --> 00:12:38,959
of the trace module

298
00:12:38,959 --> 00:12:41,519
i will first introduce the principle of

299
00:12:41,519 --> 00:12:43,680
the trace module firstly we use the

300
00:12:43,680 --> 00:12:45,920
binary patcher to replace the first

301
00:12:45,920 --> 00:12:48,320
instruction of each basic blocks in the

302
00:12:48,320 --> 00:12:50,839
executable file with breakpoint

303
00:12:50,839 --> 00:12:52,959
instruction then

304
00:12:52,959 --> 00:12:55,120
we use the trace module to start the

305
00:12:55,120 --> 00:12:56,320
program

306
00:12:56,320 --> 00:12:58,240
the trace module will process the

307
00:12:58,240 --> 00:13:00,639
breakpoint event and record the pc

308
00:13:00,639 --> 00:13:03,040
register when the breakpoint is

309
00:13:03,040 --> 00:13:05,120
triggered then it will replace the

310
00:13:05,120 --> 00:13:08,000
breakpoint instruction with the original

311
00:13:08,000 --> 00:13:10,560
instruction and then let the program

312
00:13:10,560 --> 00:13:11,600
continue

313
00:13:11,600 --> 00:13:13,839
in this way we can get all basic blocks

314
00:13:13,839 --> 00:13:16,959
that have been executed

315
00:13:16,959 --> 00:13:19,040
therefore the chase module in tribal

316
00:13:19,040 --> 00:13:23,199
files is actually a simple debugger

317
00:13:25,680 --> 00:13:27,519
next i will introduce the first trace

318
00:13:27,519 --> 00:13:30,160
module its name is a python ptrace

319
00:13:30,160 --> 00:13:31,440
tracer

320
00:13:31,440 --> 00:13:34,240
according to the previous introduction

321
00:13:34,240 --> 00:13:35,920
we note that the trace module is

322
00:13:35,920 --> 00:13:38,160
actually a simple debugger since the

323
00:13:38,160 --> 00:13:39,839
other module of shared browser are

324
00:13:39,839 --> 00:13:42,959
developed with python i also wanted to

325
00:13:42,959 --> 00:13:46,079
implement a debugger slow python after

326
00:13:46,079 --> 00:13:48,160
searching i found the python pictures

327
00:13:48,160 --> 00:13:50,880
library so this library we can use the

328
00:13:50,880 --> 00:13:53,199
ptracing in python

329
00:13:53,199 --> 00:13:55,760
in addition there is also a debug demo

330
00:13:55,760 --> 00:13:59,360
in the code of python phrase library

331
00:13:59,360 --> 00:14:01,760
so we can quickly implement the trace

332
00:14:01,760 --> 00:14:05,360
module based on the debugger demo

333
00:14:05,360 --> 00:14:07,440
the workflow of the trace module is as

334
00:14:07,440 --> 00:14:08,560
follows

335
00:14:08,560 --> 00:14:11,519
first we use create and attach process

336
00:14:11,519 --> 00:14:13,600
to start the target process

337
00:14:13,600 --> 00:14:15,600
then use continue function to let the

338
00:14:15,600 --> 00:14:18,480
process continue and use with signals

339
00:14:18,480 --> 00:14:20,720
function to wait for the process to

340
00:14:20,720 --> 00:14:23,440
trigger signature signals

341
00:14:23,440 --> 00:14:24,800
when the process

342
00:14:24,800 --> 00:14:26,320
executed a

343
00:14:26,320 --> 00:14:28,880
breakpoint it will trigger the 6-shaft

344
00:14:28,880 --> 00:14:32,160
single it means that a new basic block

345
00:14:32,160 --> 00:14:33,839
is executed

346
00:14:33,839 --> 00:14:37,440
then tracer saves a clinton pc register

347
00:14:37,440 --> 00:14:40,959
and removes the breakpoint instruction

348
00:14:40,959 --> 00:14:42,800
then it let the process continue to

349
00:14:42,800 --> 00:14:45,800
execute

350
00:14:46,800 --> 00:14:48,720
after to finish the first version of

351
00:14:48,720 --> 00:14:51,199
traffic i hope to found some real

352
00:14:51,199 --> 00:14:54,079
programs to test it after some searching

353
00:14:54,079 --> 00:14:56,560
i found that wps office released a linux

354
00:14:56,560 --> 00:14:59,440
version software in 2019

355
00:14:59,440 --> 00:15:02,639
wps is an office software in china that

356
00:15:02,639 --> 00:15:05,040
supports the viewing and editor word

357
00:15:05,040 --> 00:15:08,240
excel powerpoint and other file formats

358
00:15:08,240 --> 00:15:11,279
it supports various operating system

359
00:15:11,279 --> 00:15:14,399
including windows linux mac os and so on

360
00:15:14,399 --> 00:15:17,839
finally i decided to use wps as my first

361
00:15:17,839 --> 00:15:20,480
fuzzing target

362
00:15:20,480 --> 00:15:22,880
in the previous introduction we note

363
00:15:22,880 --> 00:15:25,839
that the terafather will trace program

364
00:15:25,839 --> 00:15:28,000
by patching executable file with

365
00:15:28,000 --> 00:15:30,800
breakpoint so we need to find the module

366
00:15:30,800 --> 00:15:33,279
need to be instrumented before frozen

367
00:15:33,279 --> 00:15:35,440
which is the module responsible for

368
00:15:35,440 --> 00:15:37,839
passing the input file next i will

369
00:15:37,839 --> 00:15:40,240
introduce how to quickly found the file

370
00:15:40,240 --> 00:15:44,399
passing modules in targeted software

371
00:15:46,160 --> 00:15:48,320
we know that the general workflow of the

372
00:15:48,320 --> 00:15:50,639
file parsing program is as follows

373
00:15:50,639 --> 00:15:53,040
firstly the program will open the file

374
00:15:53,040 --> 00:15:54,959
then it will read the data from the file

375
00:15:54,959 --> 00:15:56,160
and pass it

376
00:15:56,160 --> 00:15:58,639
finally it will close the file in this

377
00:15:58,639 --> 00:16:00,959
process program will cause some library

378
00:16:00,959 --> 00:16:04,079
functions therefore we can quickly find

379
00:16:04,079 --> 00:16:05,839
the file passing modules by hooking

380
00:16:05,839 --> 00:16:07,920
library functions such as file

381
00:16:07,920 --> 00:16:10,240
operations and then we can check the

382
00:16:10,240 --> 00:16:13,279
code stacks of target library functions

383
00:16:13,279 --> 00:16:15,360
on the windows platform we can use

384
00:16:15,360 --> 00:16:16,800
process monitor to trace the

385
00:16:16,800 --> 00:16:19,360
calibrations of the target process and

386
00:16:19,360 --> 00:16:22,399
obtain the corresponding call stack

387
00:16:22,399 --> 00:16:24,639
and showing the figure is an execution

388
00:16:24,639 --> 00:16:27,279
log captured by the process monitor when

389
00:16:27,279 --> 00:16:30,000
wps is passing a doc file

390
00:16:30,000 --> 00:16:32,320
when we check the code stack of the read

391
00:16:32,320 --> 00:16:34,880
file function we can find that there are

392
00:16:34,880 --> 00:16:38,759
two dll belong to the wps which are

393
00:16:38,759 --> 00:16:42,720
kso.dll and wpsman.drl

394
00:16:42,720 --> 00:16:45,120
read file is a windows api for reading

395
00:16:45,120 --> 00:16:47,600
file data we can inform from the log

396
00:16:47,600 --> 00:16:49,360
that these two libraries should be

397
00:16:49,360 --> 00:16:52,480
responsible for passing file data

398
00:16:52,480 --> 00:16:54,160
in this way we can follow the modules

399
00:16:54,160 --> 00:16:57,680
that are needed to be instrumented

400
00:16:58,480 --> 00:17:00,480
on the windows platform we can quickly

401
00:17:00,480 --> 00:17:02,720
locate the file passing module with the

402
00:17:02,720 --> 00:17:05,359
help of process monitor

403
00:17:05,359 --> 00:17:07,839
however there is no such easy to use

404
00:17:07,839 --> 00:17:10,559
monitor tools for linux platform

405
00:17:10,559 --> 00:17:12,000
similar tools

406
00:17:12,000 --> 00:17:14,319
under the linux platform are streets and

407
00:17:14,319 --> 00:17:16,799
electrics these tools are used to

408
00:17:16,799 --> 00:17:18,959
monitor system cost or library function

409
00:17:18,959 --> 00:17:22,240
cost brazil cannot obtain the cost stack

410
00:17:22,240 --> 00:17:24,720
or target function so it is not very

411
00:17:24,720 --> 00:17:27,039
useful for us

412
00:17:27,039 --> 00:17:29,919
after some research the best way to get

413
00:17:29,919 --> 00:17:32,080
the cost stack under the linux platform

414
00:17:32,080 --> 00:17:35,440
is gdp so i decided to implement a

415
00:17:35,440 --> 00:17:37,679
simple version of process monitor based

416
00:17:37,679 --> 00:17:40,240
on the gdp plugin

417
00:17:40,240 --> 00:17:43,039
its implementation is to set some

418
00:17:43,039 --> 00:17:46,000
breakpoints for commonly the file

419
00:17:46,000 --> 00:17:48,400
operation functions then it will check

420
00:17:48,400 --> 00:17:50,640
the file name after program hit the

421
00:17:50,640 --> 00:17:52,000
breakpoint

422
00:17:52,000 --> 00:17:54,000
if the file operation is for the target

423
00:17:54,000 --> 00:17:57,280
file the code stack is

424
00:17:58,840 --> 00:18:01,840
recorded let's take a brief look at the

425
00:18:01,840 --> 00:18:03,679
implementation of linux version fan

426
00:18:03,679 --> 00:18:05,120
monitor

427
00:18:05,120 --> 00:18:07,440
this picture on the left is the code for

428
00:18:07,440 --> 00:18:10,240
hooking f open function breakpoints can

429
00:18:10,240 --> 00:18:12,559
be set us through the gdp dot breakpoint

430
00:18:12,559 --> 00:18:15,280
class in the stop function of breakpoint

431
00:18:15,280 --> 00:18:18,080
class user can customize the breakpoint

432
00:18:18,080 --> 00:18:20,000
processing behavior

433
00:18:20,000 --> 00:18:22,720
if the file to be opened is determined

434
00:18:22,720 --> 00:18:26,000
to be a dlc file the code stack will be

435
00:18:26,000 --> 00:18:28,640
printed and some information will be

436
00:18:28,640 --> 00:18:31,120
recorded then it will replace a

437
00:18:31,120 --> 00:18:33,520
breakpoint on the written address of the

438
00:18:33,520 --> 00:18:36,799
call to f open the purpose is to obtain

439
00:18:36,799 --> 00:18:39,679
the return value of f open which is used

440
00:18:39,679 --> 00:18:40,480
to

441
00:18:40,480 --> 00:18:42,720
fighter f reader f right and other

442
00:18:42,720 --> 00:18:45,120
function calls later the picture on the

443
00:18:45,120 --> 00:18:47,360
right is the call stack of the read and

444
00:18:47,360 --> 00:18:50,240
refereed function when wps is passing

445
00:18:50,240 --> 00:18:51,600
the doc file

446
00:18:51,600 --> 00:18:54,320
in the code stack we found that the lens

447
00:18:54,320 --> 00:18:57,760
version of kso kso.diy and wpsman.dll

448
00:18:57,760 --> 00:18:59,480
namely

449
00:18:59,480 --> 00:19:01,320
wpsman.so and

450
00:19:01,320 --> 00:19:03,840
libcaso.so in addition i also found

451
00:19:03,840 --> 00:19:06,160
lib.psio.so

452
00:19:06,160 --> 00:19:08,559
in this way we can locate the fail

453
00:19:08,559 --> 00:19:12,960
passing module of wps for linux

454
00:19:14,960 --> 00:19:16,960
this page stores the modules that need

455
00:19:16,960 --> 00:19:19,360
to be patched when we pass the pass dock

456
00:19:19,360 --> 00:19:22,000
file on the windows analysis plan form

457
00:19:22,000 --> 00:19:24,160
on the left is linux on the right is the

458
00:19:24,160 --> 00:19:26,559
windows

459
00:19:26,559 --> 00:19:28,880
when i started fuzzing i found that

460
00:19:28,880 --> 00:19:31,679
python phase tracer can't trade the wps

461
00:19:31,679 --> 00:19:35,120
process after wps was executed for a

462
00:19:35,120 --> 00:19:37,760
period of time it will crash i guess

463
00:19:37,760 --> 00:19:40,320
that python p3s may have some bug in

464
00:19:40,320 --> 00:19:43,520
processing multi-thread programs after

465
00:19:43,520 --> 00:19:46,559
some research i found that gdb is an

466
00:19:46,559 --> 00:19:49,039
excellent debugger for linux platform so

467
00:19:49,039 --> 00:19:51,120
i decided to develop the stress module

468
00:19:51,120 --> 00:19:54,559
based on gdb the reasons are as follows

469
00:19:54,559 --> 00:19:57,520
first rgb has a few bugs and can get

470
00:19:57,520 --> 00:20:00,160
completely crosstalk of the process and

471
00:20:00,160 --> 00:20:04,880
support the various architectures

472
00:20:04,880 --> 00:20:07,679
second we can use python to develop gdp

473
00:20:07,679 --> 00:20:10,720
plugins third gdp is open source we can

474
00:20:10,720 --> 00:20:14,320
customize it as needed

475
00:20:15,600 --> 00:20:17,520
next i will introduce the implementation

476
00:20:17,520 --> 00:20:21,840
of gdp python plugin tracer

477
00:20:22,960 --> 00:20:25,360
first i will introduce sound gdp python

478
00:20:25,360 --> 00:20:28,640
api used by this tracer

479
00:20:28,640 --> 00:20:30,880
read the register function is used to

480
00:20:30,880 --> 00:20:33,840
read the register value

481
00:20:33,840 --> 00:20:36,000
read and write memory function is used

482
00:20:36,000 --> 00:20:38,559
to read and write process memory

483
00:20:38,559 --> 00:20:41,120
path energy world function is used to

484
00:20:41,120 --> 00:20:43,919
execute gdp expression and get as a

485
00:20:43,919 --> 00:20:46,880
result of transition

486
00:20:46,880 --> 00:20:49,520
execute function is used to execute gdb

487
00:20:49,520 --> 00:20:51,919
command and get the results or command

488
00:20:51,919 --> 00:20:54,480
execution

489
00:20:55,559 --> 00:20:57,600
gdb.events.stop.connect function is used

490
00:20:57,600 --> 00:21:01,120
to register a gdp stop event callback

491
00:21:01,120 --> 00:21:03,440
function when target processor triggers

492
00:21:03,440 --> 00:21:05,600
a signal it will enter the callback

493
00:21:05,600 --> 00:21:08,959
functions for processing

494
00:21:09,919 --> 00:21:11,919
next i will introduce the implementation

495
00:21:11,919 --> 00:21:14,640
of the tracer when the process executes

496
00:21:14,640 --> 00:21:15,679
the

497
00:21:15,679 --> 00:21:17,919
instruction the sig trap signal will be

498
00:21:17,919 --> 00:21:18,960
triggered

499
00:21:18,960 --> 00:21:21,600
if the breakpoint is not set by gdp the

500
00:21:21,600 --> 00:21:24,240
callback function reduced to the through

501
00:21:24,240 --> 00:21:26,960
gdp dot events that stop the connect

502
00:21:26,960 --> 00:21:28,480
will be triggered

503
00:21:28,480 --> 00:21:31,200
due to the limitation of the gdp python

504
00:21:31,200 --> 00:21:34,720
plugin when gdp enters the stop callback

505
00:21:34,720 --> 00:21:37,120
function the gdp processor will enter

506
00:21:37,120 --> 00:21:40,080
its command loop and the gdb needs

507
00:21:40,080 --> 00:21:41,360
waiting for

508
00:21:41,360 --> 00:21:43,600
user input

509
00:21:43,600 --> 00:21:46,000
therefore it is necessary to send the

510
00:21:46,000 --> 00:21:48,880
continual command to the std of gdb

511
00:21:48,880 --> 00:21:50,480
after it stops

512
00:21:50,480 --> 00:21:52,720
only in this way the debugger processor

513
00:21:52,720 --> 00:21:55,360
can continue execution after it executed

514
00:21:55,360 --> 00:21:58,960
a breakpoint instruction

515
00:21:58,960 --> 00:22:01,120
let's take a look at the communication

516
00:22:01,120 --> 00:22:03,360
between files and the tracer

517
00:22:03,360 --> 00:22:06,320
gdb python plug-in tracer consists of

518
00:22:06,320 --> 00:22:07,559
two parts

519
00:22:07,559 --> 00:22:10,400
childfather.py is a python plugin for

520
00:22:10,400 --> 00:22:14,080
gdb it runs in the gdp process

521
00:22:14,080 --> 00:22:16,640
gdb python plugin tracer.py is

522
00:22:16,640 --> 00:22:19,360
responsible for interacting with gdb

523
00:22:19,360 --> 00:22:21,840
including start one test and look at the

524
00:22:21,840 --> 00:22:23,440
results of the test

525
00:22:23,440 --> 00:22:26,640
it runs in further process first as the

526
00:22:26,640 --> 00:22:28,480
father general is test case through the

527
00:22:28,480 --> 00:22:31,200
sedimentation module the it could fit

528
00:22:31,200 --> 00:22:34,159
the desiccated to the target program

529
00:22:34,159 --> 00:22:36,080
then the father started the gdp with the

530
00:22:36,080 --> 00:22:38,000
trap.py

531
00:22:38,000 --> 00:22:41,039
after charlotte the py is loaded

532
00:22:41,039 --> 00:22:43,200
it will load the basic block info file

533
00:22:43,200 --> 00:22:46,320
and then start the process

534
00:22:46,320 --> 00:22:48,720
when the processor triggers a breakpoint

535
00:22:48,720 --> 00:22:51,679
gdp holder handles a sig check signal it

536
00:22:51,679 --> 00:22:53,520
will enter the callback function

537
00:22:53,520 --> 00:22:56,240
register in chat dot py the function

538
00:22:56,240 --> 00:22:58,240
will record the pc value at this time

539
00:22:58,240 --> 00:23:00,400
and then restore the original

540
00:23:00,400 --> 00:23:03,280
instruction and setup position

541
00:23:03,280 --> 00:23:05,679
due to the limitation of the gdp plugin

542
00:23:05,679 --> 00:23:08,320
the process will be suspended and the

543
00:23:08,320 --> 00:23:10,799
gdp will wait for user input then

544
00:23:10,799 --> 00:23:13,360
further processes sending container

545
00:23:13,360 --> 00:23:16,080
command to the http or gdb it would let

546
00:23:16,080 --> 00:23:20,600
target process continue execute

547
00:23:22,559 --> 00:23:25,360
next let's take a look at the code of

548
00:23:25,360 --> 00:23:28,000
the tracer first take a look at the code

549
00:23:28,000 --> 00:23:33,720
of the gdp plugin part which is trap.py

550
00:23:34,559 --> 00:23:36,799
in the code it'll first register the

551
00:23:36,799 --> 00:23:40,559
stop callback function through

552
00:23:41,400 --> 00:23:43,679
gdp.event.spotsstop.connector api in the

553
00:23:43,679 --> 00:23:45,919
callback function if it is a breakpoint

554
00:23:45,919 --> 00:23:48,720
event function first search basic plug

555
00:23:48,720 --> 00:23:51,520
info file according to the pc and get

556
00:23:51,520 --> 00:23:53,360
the original instruction at zedd

557
00:23:53,360 --> 00:23:56,159
location then it removes the breakpoint

558
00:23:56,159 --> 00:23:58,480
instruction and records the address of

559
00:23:58,480 --> 00:23:59,840
the basic block

560
00:23:59,840 --> 00:24:02,320
finally it will let the processor they

561
00:24:02,320 --> 00:24:04,799
executed this instruction by setting the

562
00:24:04,799 --> 00:24:07,918
pc register

563
00:24:08,960 --> 00:24:11,120
next i will introduce the implementation

564
00:24:11,120 --> 00:24:15,039
of gdb python plug-in tracer

565
00:24:15,679 --> 00:24:19,039
it was it first start the gdp process

566
00:24:19,039 --> 00:24:20,960
through sound process and load

567
00:24:20,960 --> 00:24:24,000
trouble.py then it will monitor the std

568
00:24:24,000 --> 00:24:27,360
out of the gdp if gdp prints receive the

569
00:24:27,360 --> 00:24:31,520
signal sig check it names it means that

570
00:24:31,520 --> 00:24:35,440
the process has executed a breakpoint

571
00:24:35,440 --> 00:24:38,000
and the child.py has already handled the

572
00:24:38,000 --> 00:24:41,279
signature signal and at this time

573
00:24:41,279 --> 00:24:43,520
it will send a continued command to

574
00:24:43,520 --> 00:24:46,559
stating of gdb to let the process

575
00:24:46,559 --> 00:24:48,960
continue to execute

576
00:24:48,960 --> 00:24:52,880
and after the process is started

577
00:24:52,880 --> 00:24:55,840
the script will set a timer and cure the

578
00:24:55,840 --> 00:24:59,600
process when the timer expands

579
00:24:59,600 --> 00:25:02,559
the purpose of the timer is to detect

580
00:25:02,559 --> 00:25:05,600
those availabilities

581
00:25:08,480 --> 00:25:10,320
now we have a trace module that can

582
00:25:10,320 --> 00:25:13,520
trace wps we can start finding with gdb

583
00:25:13,520 --> 00:25:15,919
python plug-in tracer but there are two

584
00:25:15,919 --> 00:25:18,720
problems that affect the fuzzing speed

585
00:25:18,720 --> 00:25:21,760
the first problem is that wps will not

586
00:25:21,760 --> 00:25:24,960
exit the process after passing the file

587
00:25:24,960 --> 00:25:27,360
but i will stay on the gi interface and

588
00:25:27,360 --> 00:25:30,080
waiting for the user to operate

589
00:25:30,080 --> 00:25:32,880
so the further need to manually kill the

590
00:25:32,880 --> 00:25:35,440
process therefore the problem is when to

591
00:25:35,440 --> 00:25:37,840
clear the process

592
00:25:37,840 --> 00:25:40,400
the company uses the method is to set a

593
00:25:40,400 --> 00:25:42,640
timeout when the timeout occurs the

594
00:25:42,640 --> 00:25:44,880
further will cure the process this

595
00:25:44,880 --> 00:25:47,039
approach have two disadvantages as

596
00:25:47,039 --> 00:25:50,080
follows the first disadvantage is that

597
00:25:50,080 --> 00:25:52,240
due to the setting or timeout the

598
00:25:52,240 --> 00:25:54,559
execution time for each test case is

599
00:25:54,559 --> 00:25:55,760
fixed

600
00:25:55,760 --> 00:25:58,320
when process pass simple test case which

601
00:25:58,320 --> 00:26:00,400
actually passing time is less than time

602
00:26:00,400 --> 00:26:03,039
off it will waste the time when process

603
00:26:03,039 --> 00:26:05,679
passes complex test case which actually

604
00:26:05,679 --> 00:26:07,840
passing time is greater than timeout it

605
00:26:07,840 --> 00:26:10,480
will result in an incomplete file

606
00:26:10,480 --> 00:26:12,480
passing

607
00:26:12,480 --> 00:26:14,799
the second disadvantage is that it

608
00:26:14,799 --> 00:26:18,960
cannot detect those availabilities

609
00:26:22,159 --> 00:26:24,320
the following describes child father's

610
00:26:24,320 --> 00:26:26,320
solution to this problem

611
00:26:26,320 --> 00:26:29,279
generally the application will execute

612
00:26:29,279 --> 00:26:31,520
the same code every time we enter enters

613
00:26:31,520 --> 00:26:34,080
the gi loop so if we clear the

614
00:26:34,080 --> 00:26:36,240
application when it enters one of the

615
00:26:36,240 --> 00:26:39,679
basic block of the gi loop we can avoid

616
00:26:39,679 --> 00:26:42,240
wasting time and ensure that the input

617
00:26:42,240 --> 00:26:45,200
file has been completely passed

618
00:26:45,200 --> 00:26:48,159
the workflow is as follows first we use

619
00:26:48,159 --> 00:26:50,480
a trace module to trace the program

620
00:26:50,480 --> 00:26:52,159
execution

621
00:26:52,159 --> 00:26:54,400
and printers and security the basic

622
00:26:54,400 --> 00:26:57,279
blocks then we can follow the last basic

623
00:26:57,279 --> 00:26:59,840
blocks executed by the process after it

624
00:26:59,840 --> 00:27:02,960
enters the gi loop we named it ether and

625
00:27:02,960 --> 00:27:04,080
the bbl

626
00:27:04,080 --> 00:27:05,360
in the following

627
00:27:05,360 --> 00:27:07,919
when the process reaches nwbr it means

628
00:27:07,919 --> 00:27:10,880
that the process have entered the gi

629
00:27:10,880 --> 00:27:13,360
loop and the process can be created at

630
00:27:13,360 --> 00:27:15,279
this time

631
00:27:15,279 --> 00:27:17,600
in addition during the frozen the father

632
00:27:17,600 --> 00:27:19,760
will also recall the execution time of

633
00:27:19,760 --> 00:27:22,640
each test case which is used to

634
00:27:22,640 --> 00:27:26,240
calculate the average execution time

635
00:27:26,240 --> 00:27:28,799
the average execution time is used to

636
00:27:28,799 --> 00:27:30,480
calculate the time out of those

637
00:27:30,480 --> 00:27:32,080
variabilities

638
00:27:32,080 --> 00:27:34,080
when the execution time is greater than

639
00:27:34,080 --> 00:27:36,559
timeout it is concerted that those

640
00:27:36,559 --> 00:27:40,080
availabilities have been found

641
00:27:41,600 --> 00:27:44,000
this is a video of obtaining and the bbl

642
00:27:44,000 --> 00:27:47,880
with the trace module

643
00:27:51,919 --> 00:27:53,760
it can be seen that the process will

644
00:27:53,760 --> 00:27:56,240
continue to execute the new basic blocks

645
00:27:56,240 --> 00:27:59,559
at the beginning

646
00:28:07,440 --> 00:28:10,240
but when it enters the gi loop there are

647
00:28:10,240 --> 00:28:11,039
no

648
00:28:11,039 --> 00:28:15,480
no basic blocker being triggered

649
00:28:23,279 --> 00:28:25,679
so when wps gi has finished the

650
00:28:25,679 --> 00:28:28,480
rendering the l market red in the figure

651
00:28:28,480 --> 00:28:31,520
is a basic block of gi loop we can use

652
00:28:31,520 --> 00:28:35,120
it as npbl

653
00:28:36,559 --> 00:28:38,799
next i will i will introduce the second

654
00:28:38,799 --> 00:28:41,679
problem that greatly affects the speed

655
00:28:41,679 --> 00:28:44,000
of browsing for large software because

656
00:28:44,000 --> 00:28:46,000
the number of breakpoints is very large

657
00:28:46,000 --> 00:28:48,080
it will take a lot of time for each

658
00:28:48,080 --> 00:28:49,600
execution

659
00:28:49,600 --> 00:28:52,000
this will cause our fusing speed to be

660
00:28:52,000 --> 00:28:54,000
very slow

661
00:28:54,000 --> 00:28:56,000
the following table shows the number of

662
00:28:56,000 --> 00:28:58,399
breakpoints that the program needs to

663
00:28:58,399 --> 00:29:00,719
patch

664
00:29:03,919 --> 00:29:05,679
chair further improvement

665
00:29:05,679 --> 00:29:09,600
accelerated mode to handle this problem

666
00:29:09,600 --> 00:29:11,360
first of all we know that in child

667
00:29:11,360 --> 00:29:13,520
brother the trace module will save and

668
00:29:13,520 --> 00:29:15,520
send the basic block information of each

669
00:29:15,520 --> 00:29:17,919
test case to the browser in the

670
00:29:17,919 --> 00:29:20,320
accelerated mode the father first

671
00:29:20,320 --> 00:29:22,559
obtained the security the basic blocks

672
00:29:22,559 --> 00:29:25,520
from the trace module then remove the

673
00:29:25,520 --> 00:29:27,760
breakpoints of this basic blocks in the

674
00:29:27,760 --> 00:29:29,039
file system

675
00:29:29,039 --> 00:29:31,760
in this way the breakpoint exchange of

676
00:29:31,760 --> 00:29:34,159
each basic block will only be triggered

677
00:29:34,159 --> 00:29:37,360
once during the entire filing process

678
00:29:37,360 --> 00:29:40,640
or it will never be triggered

679
00:29:40,640 --> 00:29:43,039
the result is that the average execution

680
00:29:43,039 --> 00:29:45,919
time of the program in france is similar

681
00:29:45,919 --> 00:29:49,039
to the program without instrumentation

682
00:29:49,039 --> 00:29:50,960
as shown in the figure the blue

683
00:29:50,960 --> 00:29:53,279
rectangle in the figure represents the

684
00:29:53,279 --> 00:29:55,440
module being instrumented

685
00:29:55,440 --> 00:29:57,520
the small yellow rectangle represents

686
00:29:57,520 --> 00:29:59,600
and the breakpoint extraction in the

687
00:29:59,600 --> 00:30:00,640
module

688
00:30:00,640 --> 00:30:03,520
the small vital rectangle

689
00:30:03,520 --> 00:30:05,760
represents the original instruction in

690
00:30:05,760 --> 00:30:08,080
the module

691
00:30:08,080 --> 00:30:10,240
first blue box indicates that when

692
00:30:10,240 --> 00:30:12,559
module is instrumented there will be a

693
00:30:12,559 --> 00:30:15,760
lot of breakpoints instructions in it

694
00:30:15,760 --> 00:30:16,880
the second

695
00:30:16,880 --> 00:30:19,840
blur box indicates that some breakpoints

696
00:30:19,840 --> 00:30:22,000
in the broad module are removed after

697
00:30:22,000 --> 00:30:24,320
the after the first

698
00:30:24,320 --> 00:30:26,879
execution

699
00:30:26,960 --> 00:30:29,760
the third blood box indicates that more

700
00:30:29,760 --> 00:30:32,720
breakpoints are removed after the second

701
00:30:32,720 --> 00:30:35,360
execution

702
00:30:35,760 --> 00:30:37,919
with the running of fuzzing there will

703
00:30:37,919 --> 00:30:39,760
be fill and few break points in the

704
00:30:39,760 --> 00:30:41,919
module and the number of the bigger

705
00:30:41,919 --> 00:30:45,039
points triggered by each execution will

706
00:30:45,039 --> 00:30:48,080
gradually increase so the trace the

707
00:30:48,080 --> 00:30:50,880
process will execute at a speed closer

708
00:30:50,880 --> 00:30:54,240
to the original execution

709
00:30:54,320 --> 00:30:56,399
of course there is a problem with this

710
00:30:56,399 --> 00:30:59,279
approach due to the optimization method

711
00:30:59,279 --> 00:31:01,440
we can only obtain basic block coverage

712
00:31:01,440 --> 00:31:03,279
information because owning test cases

713
00:31:03,279 --> 00:31:05,600
that triggered new basic block can be

714
00:31:05,600 --> 00:31:08,559
saved during the fuzzing process and

715
00:31:08,559 --> 00:31:11,919
there is no age coverage information

716
00:31:11,919 --> 00:31:14,480
but despite this it is much better than

717
00:31:14,480 --> 00:31:16,399
blackboard surviving which is without

718
00:31:16,399 --> 00:31:19,799
currency guiding

719
00:31:20,720 --> 00:31:23,039
after solving this problem we can

720
00:31:23,039 --> 00:31:25,600
finally start fixing wps let's take a

721
00:31:25,600 --> 00:31:30,039
look at a video of fuzzing.pps

722
00:31:35,519 --> 00:31:37,840
during the fasting process wps were

723
00:31:37,840 --> 00:31:40,399
restarted multiple times during the test

724
00:31:40,399 --> 00:31:43,279
gdp person plug-in tracer will process

725
00:31:43,279 --> 00:31:45,919
the breakpoint event triggered by the

726
00:31:45,919 --> 00:31:47,279
process and

727
00:31:47,279 --> 00:31:49,279
sends the result to the frozen when

728
00:31:49,279 --> 00:31:52,320
processor exit

729
00:31:55,110 --> 00:31:56,880
[Music]

730
00:31:56,880 --> 00:31:59,679
currently we can find ips i first found

731
00:31:59,679 --> 00:32:02,399
with the random theater but no crash was

732
00:32:02,399 --> 00:32:05,120
found after three days of fuzzy after

733
00:32:05,120 --> 00:32:07,919
that i tried to fuzzy with a tiny

734
00:32:07,919 --> 00:32:10,240
mutator and i found more than 10 crash

735
00:32:10,240 --> 00:32:14,080
after fizzing in one day

736
00:32:14,080 --> 00:32:16,960
i guess the reason may be as follows

737
00:32:16,960 --> 00:32:19,519
gender enzyme mutator doesn't consider

738
00:32:19,519 --> 00:32:21,679
the ratio of data mutation

739
00:32:21,679 --> 00:32:24,159
which directly mutates the content of

740
00:32:24,159 --> 00:32:25,840
the intel file

741
00:32:25,840 --> 00:32:28,960
this may seriously destroy the file

742
00:32:28,960 --> 00:32:31,200
structure cause the test case to be

743
00:32:31,200 --> 00:32:33,440
discarded very early

744
00:32:33,440 --> 00:32:35,760
so that deep probabilities cannot be

745
00:32:35,760 --> 00:32:37,679
found

746
00:32:37,679 --> 00:32:40,000
due to the mutation ratio tiny mutator

747
00:32:40,000 --> 00:32:42,000
will only mutate small part of the test

748
00:32:42,000 --> 00:32:44,880
case so that most of the structure is

749
00:32:44,880 --> 00:32:47,440
valid then we can find the deeper logic

750
00:32:47,440 --> 00:32:49,279
of the software and found more

751
00:32:49,279 --> 00:32:52,080
availabilities

752
00:32:53,039 --> 00:32:55,279
currently chiropractor can further linux

753
00:32:55,279 --> 00:32:58,000
software in order to further enhance the

754
00:32:58,000 --> 00:33:00,399
function speed of the linux plan form

755
00:33:00,399 --> 00:33:03,679
and make it easy for user debugging i

756
00:33:03,679 --> 00:33:06,880
developed a transfer the gdb tracer by

757
00:33:06,880 --> 00:33:09,679
modifying the gdp source code next i

758
00:33:09,679 --> 00:33:11,519
will introduce the implementation of

759
00:33:11,519 --> 00:33:13,840
this

760
00:33:14,399 --> 00:33:16,399
first of all i will introduce why i want

761
00:33:16,399 --> 00:33:18,720
to modify the gdp server code to

762
00:33:18,720 --> 00:33:21,440
developer child file gdp tracer

763
00:33:21,440 --> 00:33:22,399
also

764
00:33:22,399 --> 00:33:24,880
gdp python plug-in tracer can meet the

765
00:33:24,880 --> 00:33:27,360
fuzzing requirements there are still

766
00:33:27,360 --> 00:33:30,240
some shortcomings such as first it is

767
00:33:30,240 --> 00:33:32,960
inconvenient to debug we need a user

768
00:33:32,960 --> 00:33:34,720
python script to send a continuous

769
00:33:34,720 --> 00:33:37,039
command to the std of gdb

770
00:33:37,039 --> 00:33:40,080
second we need to raise star gdp for

771
00:33:40,080 --> 00:33:42,720
each test the python runtime the

772
00:33:42,720 --> 00:33:44,720
communication of the trace module and

773
00:33:44,720 --> 00:33:46,960
the further will cause additional

774
00:33:46,960 --> 00:33:50,080
performance overhead

775
00:33:51,120 --> 00:33:53,039
and the trail of other gdp tracer have

776
00:33:53,039 --> 00:33:55,039
following advantages

777
00:33:55,039 --> 00:33:57,679
first of all it has its speed will

778
00:33:57,679 --> 00:33:58,720
increase

779
00:33:58,720 --> 00:34:02,000
and we can compare static link gdp to

780
00:34:02,000 --> 00:34:04,720
reduce the requirements of environment

781
00:34:04,720 --> 00:34:08,320
and it is usa to debug

782
00:34:09,359 --> 00:34:11,918
in order to modify gb we first need to

783
00:34:11,918 --> 00:34:14,719
understand the code of gdb on the linux

784
00:34:14,719 --> 00:34:16,800
platform gdbo is a pre-traded for

785
00:34:16,800 --> 00:34:19,440
debugger program in addition

786
00:34:19,440 --> 00:34:22,399
it will pass the ell file used in the

787
00:34:22,399 --> 00:34:25,280
variable process so that a relatively

788
00:34:25,280 --> 00:34:28,639
complete call stack can be obtained

789
00:34:28,639 --> 00:34:31,280
when gdb starts the debugger program it

790
00:34:31,280 --> 00:34:34,000
will call start event loop function to

791
00:34:34,000 --> 00:34:36,320
start the event loop and waiting for

792
00:34:36,320 --> 00:34:38,879
events from the target process such as

793
00:34:38,879 --> 00:34:41,040
hitting a breakpoint creating a child

794
00:34:41,040 --> 00:34:43,359
process and so on

795
00:34:43,359 --> 00:34:45,280
the following figure shows the call

796
00:34:45,280 --> 00:34:48,320
stack of gdp when it handle breakpoint

797
00:34:48,320 --> 00:34:50,720
events

798
00:34:53,839 --> 00:34:56,560
next i will introduce how gdb processes

799
00:34:56,560 --> 00:34:58,400
the breakpoint events

800
00:34:58,400 --> 00:34:59,280
first

801
00:34:59,280 --> 00:35:01,280
gdp starts the event loops so the

802
00:35:01,280 --> 00:35:03,359
standard event loop function

803
00:35:03,359 --> 00:35:05,680
when the process reaches the breakpoint

804
00:35:05,680 --> 00:35:06,960
extraction

805
00:35:06,960 --> 00:35:09,359
the kernel will send the sig trap signal

806
00:35:09,359 --> 00:35:11,920
to the target process and this time gb

807
00:35:11,920 --> 00:35:15,040
will call gdb two one event to process

808
00:35:15,040 --> 00:35:16,400
the event

809
00:35:16,400 --> 00:35:19,440
and finally call handle inferior events

810
00:35:19,440 --> 00:35:21,359
to handle the event of the target

811
00:35:21,359 --> 00:35:22,320
process

812
00:35:22,320 --> 00:35:25,280
if it is a signal event it will enter

813
00:35:25,280 --> 00:35:28,320
handle signal stop

814
00:35:29,200 --> 00:35:31,280
handle single store functions used to

815
00:35:31,280 --> 00:35:33,520
handle the situation where the debug

816
00:35:33,520 --> 00:35:36,079
processor top due to receiving a signal

817
00:35:36,079 --> 00:35:38,560
the screenshot is a cardio student to

818
00:35:38,560 --> 00:35:40,640
handle the sig traverse event in the

819
00:35:40,640 --> 00:35:43,040
handle signal stop function we can also

820
00:35:43,040 --> 00:35:47,599
use similar code to implement our tracer

821
00:35:48,320 --> 00:35:50,400
next i will introduce the modification

822
00:35:50,400 --> 00:35:51,599
for gdb

823
00:35:51,599 --> 00:35:54,000
we manually modify the handle signal

824
00:35:54,000 --> 00:35:55,680
store function to let the gdp

825
00:35:55,680 --> 00:35:57,599
automatically handle the breakpoint

826
00:35:57,599 --> 00:35:59,760
events of process

827
00:35:59,760 --> 00:36:02,079
the logical processing sig trap second

828
00:36:02,079 --> 00:36:04,560
auto modification is as follows

829
00:36:04,560 --> 00:36:06,640
first it gets the value of the pc

830
00:36:06,640 --> 00:36:09,839
register and then from the modules at

831
00:36:09,839 --> 00:36:12,640
where the pc is located

832
00:36:12,640 --> 00:36:15,359
then according to pc and the basic block

833
00:36:15,359 --> 00:36:17,680
info file it can get the original

834
00:36:17,680 --> 00:36:19,839
instruction of the position

835
00:36:19,839 --> 00:36:22,000
finally replace the breakpoint

836
00:36:22,000 --> 00:36:23,440
instruction with the original

837
00:36:23,440 --> 00:36:26,000
instruction and let the process continue

838
00:36:26,000 --> 00:36:28,800
to execute

839
00:36:29,210 --> 00:36:32,289
[Music]

840
00:36:35,119 --> 00:36:37,040
next i will introduce sound user4gb

841
00:36:37,040 --> 00:36:38,160
functions

842
00:36:38,160 --> 00:36:41,680
we can use com function to add custom

843
00:36:41,680 --> 00:36:43,760
gdp commands

844
00:36:43,760 --> 00:36:46,079
and use execute command to string

845
00:36:46,079 --> 00:36:50,720
function to execute the gdb command

846
00:36:52,400 --> 00:36:54,800
the screen shot is the code that

847
00:36:54,800 --> 00:36:57,040
terrifies the gdb automatically process

848
00:36:57,040 --> 00:36:58,800
the sig trap signal

849
00:36:58,800 --> 00:37:01,040
the workflow is as follows first it

850
00:37:01,040 --> 00:37:02,720
defines the corresponding module

851
00:37:02,720 --> 00:37:04,160
occurring the pc

852
00:37:04,160 --> 00:37:07,200
and calculate the module offset then it

853
00:37:07,200 --> 00:37:09,200
removes the breakpoints instruction at

854
00:37:09,200 --> 00:37:11,440
this position according to the offset

855
00:37:11,440 --> 00:37:14,079
and the basic block info file finally it

856
00:37:14,079 --> 00:37:15,920
used keep going function to let the

857
00:37:15,920 --> 00:37:17,760
process continue to run

858
00:37:17,760 --> 00:37:20,240
and let gdp don't stop

859
00:37:20,240 --> 00:37:23,419
[Music]

860
00:37:24,240 --> 00:37:26,320
let's take a look at the interaction

861
00:37:26,320 --> 00:37:28,160
diagram between the trace ender's

862
00:37:28,160 --> 00:37:29,599
further

863
00:37:29,599 --> 00:37:31,760
the main difference is that all six trap

864
00:37:31,760 --> 00:37:34,400
events are processed in gdb and gdb will

865
00:37:34,400 --> 00:37:37,920
only be started once during the entire

866
00:37:37,920 --> 00:37:39,760
filing process

867
00:37:39,760 --> 00:37:43,040
the subsequent test control and tracer

868
00:37:43,040 --> 00:37:45,359
information interaction are all done so

869
00:37:45,359 --> 00:37:46,560
circuits

870
00:37:46,560 --> 00:37:48,720
first the father generates a new test

871
00:37:48,720 --> 00:37:51,599
case then further informs traffic gdp to

872
00:37:51,599 --> 00:37:53,839
start one fast task through the circuit

873
00:37:53,839 --> 00:37:56,240
and the tracer will start the target

874
00:37:56,240 --> 00:37:57,839
process

875
00:37:57,839 --> 00:37:59,920
if a breakpoint event is triggered

876
00:37:59,920 --> 00:38:02,320
during the execution or target process

877
00:38:02,320 --> 00:38:04,800
chevron's gdp will handle it

878
00:38:04,800 --> 00:38:06,560
chiropractor gdp will return the

879
00:38:06,560 --> 00:38:10,320
execution information to browser

880
00:38:11,280 --> 00:38:13,520
next i will introduce the implementation

881
00:38:13,520 --> 00:38:18,599
of trail files on the windows plan form

882
00:38:19,760 --> 00:38:21,760
in order to support windows platform we

883
00:38:21,760 --> 00:38:24,720
only needed to implement a windows

884
00:38:24,720 --> 00:38:26,640
debugger the best solution for

885
00:38:26,640 --> 00:38:28,800
developing windows debugger with python

886
00:38:28,800 --> 00:38:32,320
is when app dbg the advantages of using

887
00:38:32,320 --> 00:38:34,880
when avdvg to developer or debugger is

888
00:38:34,880 --> 00:38:38,400
that it is developed with python and

889
00:38:38,400 --> 00:38:40,640
there are many samples called

890
00:38:40,640 --> 00:38:42,880
we can quickly develop the tracer based

891
00:38:42,880 --> 00:38:44,720
on this sample course

892
00:38:44,720 --> 00:38:47,119
the disadvantage is that first because

893
00:38:47,119 --> 00:38:49,440
it is developed with python the

894
00:38:49,440 --> 00:38:52,320
execution speed is relatively slow

895
00:38:52,320 --> 00:38:55,359
second when apb dbg can't obtain the

896
00:38:55,359 --> 00:38:57,839
completed core stack

897
00:38:57,839 --> 00:39:00,400
the working mechanism of an app dvd

898
00:39:00,400 --> 00:39:02,880
tracer is no different with the previous

899
00:39:02,880 --> 00:39:05,040
tracer which is just the dealing with

900
00:39:05,040 --> 00:39:08,160
breakpoint advance

901
00:39:09,119 --> 00:39:11,920
as mentioned earlier when avv dvd has

902
00:39:11,920 --> 00:39:14,000
some shortcomings

903
00:39:14,000 --> 00:39:16,160
by searching in google i found that the

904
00:39:16,160 --> 00:39:18,720
dbg android api can be used to develop

905
00:39:18,720 --> 00:39:22,400
windows debugger so dbg engine api is a

906
00:39:22,400 --> 00:39:24,880
serious apis for developing debuggers

907
00:39:24,880 --> 00:39:27,520
provided by microsoft user only needed

908
00:39:27,520 --> 00:39:29,839
to register the corresponding callback

909
00:39:29,839 --> 00:39:32,560
function to implement a debugger the

910
00:39:32,560 --> 00:39:34,720
advantages of developing a debugger

911
00:39:34,720 --> 00:39:37,040
based on the debug android api are as

912
00:39:37,040 --> 00:39:38,720
follows

913
00:39:38,720 --> 00:39:42,320
first because of it is divided by c so

914
00:39:42,320 --> 00:39:45,760
execution speed is relatively fast

915
00:39:45,760 --> 00:39:48,640
second it can get the completely

916
00:39:48,640 --> 00:39:51,920
constant of the program

917
00:39:54,800 --> 00:39:56,960
next let's briefly introduce the code

918
00:39:56,960 --> 00:40:00,320
how dbg engine tracer handle breakpoints

919
00:40:00,320 --> 00:40:03,760
first in dbg engine you can use the

920
00:40:03,760 --> 00:40:05,839
right virtual and the radar virtual

921
00:40:05,839 --> 00:40:08,240
function to read and write memory of the

922
00:40:08,240 --> 00:40:11,760
process and the get stack trace function

923
00:40:11,760 --> 00:40:14,640
is used to get the call stack or the

924
00:40:14,640 --> 00:40:16,160
process

925
00:40:16,160 --> 00:40:18,880
the code for handle breakpoints is shown

926
00:40:18,880 --> 00:40:21,520
in the screenshot the logic of the code

927
00:40:21,520 --> 00:40:25,630
is similar so i want to repeat it here

928
00:40:25,630 --> 00:40:27,920
[Music]

929
00:40:27,920 --> 00:40:30,240
let's take a look at the demo of fuzzy

930
00:40:30,240 --> 00:40:33,959
windows plan form

931
00:40:40,510 --> 00:40:43,559
[Music]

932
00:40:52,890 --> 00:40:56,190
[Music]

933
00:40:56,400 --> 00:40:57,920
next i will introduce a crash

934
00:40:57,920 --> 00:41:01,520
duplication scheme in the chat function

935
00:41:01,520 --> 00:41:03,440
first we get the call stack of the

936
00:41:03,440 --> 00:41:05,920
process we need to crash then we'll take

937
00:41:05,920 --> 00:41:08,720
out the lowest 12 banks of each layer of

938
00:41:08,720 --> 00:41:11,760
the cost deck for pricing the results of

939
00:41:11,760 --> 00:41:15,119
spacing is used as the hash of the crash

940
00:41:15,119 --> 00:41:17,359
when a new crash occurs it will charge

941
00:41:17,359 --> 00:41:19,520
according to the hash whether the crash

942
00:41:19,520 --> 00:41:21,680
has recorded before

943
00:41:21,680 --> 00:41:24,079
the figure below is a example of

944
00:41:24,079 --> 00:41:27,839
calculating hash of the crash

945
00:41:31,760 --> 00:41:34,880
when the gi program is executed if there

946
00:41:34,880 --> 00:41:37,680
is an error it usually pops up a dialog

947
00:41:37,680 --> 00:41:40,720
box further needs to automatically

948
00:41:40,720 --> 00:41:43,680
handle this dialog box the commonly way

949
00:41:43,680 --> 00:41:46,960
to slow this problem is to use python

950
00:41:46,960 --> 00:41:49,359
autoit library to automatically process

951
00:41:49,359 --> 00:41:50,800
the dialog box

952
00:41:50,800 --> 00:41:53,280
as shown in the figure we can use outlet

953
00:41:53,280 --> 00:41:56,720
to search for target dialog box and then

954
00:41:56,720 --> 00:41:59,280
call out dot control click to

955
00:41:59,280 --> 00:42:03,640
automatically click the button

956
00:42:04,319 --> 00:42:06,880
or we can use some existing tools such

957
00:42:06,880 --> 00:42:10,079
as horon which is a chinese anti-virus

958
00:42:10,079 --> 00:42:12,319
software it carries a tool for

959
00:42:12,319 --> 00:42:15,280
processing the data box the advantages

960
00:42:15,280 --> 00:42:17,520
of using hold on is that you can

961
00:42:17,520 --> 00:42:19,520
directly use the gui to select the

962
00:42:19,520 --> 00:42:22,000
dialog box needed to be closed

963
00:42:22,000 --> 00:42:24,880
then as long as the database appears in

964
00:42:24,880 --> 00:42:27,280
the future it will automatically handle

965
00:42:27,280 --> 00:42:29,599
it for us the following figure shows

966
00:42:29,599 --> 00:42:32,400
several dialogue box rules which are

967
00:42:32,400 --> 00:42:37,119
used to finding microsoft office

968
00:42:38,640 --> 00:42:41,359
here is another useful feature of child

969
00:42:41,359 --> 00:42:44,160
brother child father will listen a

970
00:42:44,160 --> 00:42:47,119
management producer started user can

971
00:42:47,119 --> 00:42:49,280
connect to the managing products law and

972
00:42:49,280 --> 00:42:51,680
say at any time to check the

973
00:42:51,680 --> 00:42:54,319
status of the fusing process such as the

974
00:42:54,319 --> 00:42:56,800
number of past found crash information

975
00:42:56,800 --> 00:42:59,839
and execution speed

976
00:43:01,839 --> 00:43:04,560
next i will introduce the preparation

977
00:43:04,560 --> 00:43:07,520
for starting fuzzing and the results of

978
00:43:07,520 --> 00:43:10,520
fuzzing

979
00:43:15,200 --> 00:43:17,440
before we start advancing we need to

980
00:43:17,440 --> 00:43:19,760
prepare some environments we know that

981
00:43:19,760 --> 00:43:22,800
fuzzing has three important factors

982
00:43:22,800 --> 00:43:25,040
which is execution speed

983
00:43:25,040 --> 00:43:27,839
sample quantity quantity

984
00:43:27,839 --> 00:43:30,400
mutation algorithm there are several

985
00:43:30,400 --> 00:43:33,119
common methods for obtaining samples the

986
00:43:33,119 --> 00:43:35,839
details are as follows

987
00:43:35,839 --> 00:43:38,000
i usually use the second and first

988
00:43:38,000 --> 00:43:41,000
methods

989
00:43:42,400 --> 00:43:44,880
in order to further increase the speed

990
00:43:44,880 --> 00:43:47,520
we can use ram disk which can speed up

991
00:43:47,520 --> 00:43:50,319
the i o operation of the program

992
00:43:50,319 --> 00:43:52,240
for fail fusing it can improve the

993
00:43:52,240 --> 00:43:54,319
execution speed but you must pay

994
00:43:54,319 --> 00:43:56,960
attention to regular backup files

995
00:43:56,960 --> 00:43:59,119
because the files in the ram disk will

996
00:43:59,119 --> 00:44:02,000
no longer exist when the machine is

997
00:44:02,000 --> 00:44:03,599
restarted

998
00:44:03,599 --> 00:44:05,839
we can use the mount command to create

999
00:44:05,839 --> 00:44:09,520
the ram disk online and we can use im

1000
00:44:09,520 --> 00:44:13,040
disk toolkit on windows

1001
00:44:16,640 --> 00:44:19,520
my first equipment is my laptop its

1002
00:44:19,520 --> 00:44:22,960
configuration is as follows i run two

1003
00:44:22,960 --> 00:44:24,960
virtual machine on it

1004
00:44:24,960 --> 00:44:27,200
the final refining results are shown in

1005
00:44:27,200 --> 00:44:28,400
the table

1006
00:44:28,400 --> 00:44:30,560
you can see that the trail files have

1007
00:44:30,560 --> 00:44:32,480
found many availabilities in various

1008
00:44:32,480 --> 00:44:34,880
software

1009
00:44:34,880 --> 00:44:37,599
the following is a simple comparison

1010
00:44:37,599 --> 00:44:39,920
between trevor and other father after

1011
00:44:39,920 --> 00:44:42,800
comparison we know that the advantages

1012
00:44:42,800 --> 00:44:44,960
of chair brother is that it is

1013
00:44:44,960 --> 00:44:47,760
relatively simple to use and can support

1014
00:44:47,760 --> 00:44:50,760
courage

1015
00:44:51,359 --> 00:44:53,680
here i will summarize my speech first

1016
00:44:53,680 --> 00:44:56,319
the cd is important and mutation ratio

1017
00:44:56,319 --> 00:44:58,240
is also important

1018
00:44:58,240 --> 00:45:00,720
second the gdp and the debug engine api

1019
00:45:00,720 --> 00:45:02,079
is very nice

1020
00:45:02,079 --> 00:45:04,240
third fuzzing with brake coverage is

1021
00:45:04,240 --> 00:45:07,359
much better than now

1022
00:45:08,000 --> 00:45:10,640
there are some future plans

1023
00:45:10,640 --> 00:45:13,440
first support more architecture such as

1024
00:45:13,440 --> 00:45:17,359
arm mips second optimize the distributed

1025
00:45:17,359 --> 00:45:19,440
fuzzing scattering

1026
00:45:19,440 --> 00:45:21,599
third automatically detect the data

1027
00:45:21,599 --> 00:45:24,400
mutation ratio and the mutation range

1028
00:45:24,400 --> 00:45:27,280
first more processed crash duplication

1029
00:45:27,280 --> 00:45:30,640
mechanism and so on

1030
00:45:31,359 --> 00:45:33,359
thank you everyone so above with all my

1031
00:45:33,359 --> 00:45:36,359
speech

